"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-examples_calendar_basic_app_mjs"],{

/***/ "./examples/calendar/basic/MainContainer.mjs":
/*!***************************************************!*\
  !*** ./examples/calendar/basic/MainContainer.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/button/Base.mjs */ "./src/button/Base.mjs");
/* harmony import */ var _src_calendar_view_MainContainer_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/calendar/view/MainContainer.mjs */ "./src/calendar/view/MainContainer.mjs");
/* harmony import */ var _MainContainerController_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MainContainerController.mjs */ "./examples/calendar/basic/MainContainerController.mjs");
/* harmony import */ var _src_toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../src/toolbar/Base.mjs */ "./src/toolbar/Base.mjs");
/* harmony import */ var _src_container_Viewport_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../src/container/Viewport.mjs */ "./src/container/Viewport.mjs");






/**
 * @class Neo.examples.calendar.basic.MainContainer
 * @extends Neo.container.Viewport
 */
class MainContainer extends _src_container_Viewport_mjs__WEBPACK_IMPORTED_MODULE_4__["default"] {
    static config = {
        className : 'Neo.examples.calendar.basic.MainContainer',
        autoMount : true,
        cls       : ['neo-examples-calendar-maincontainer', 'neo-viewport'],
        controller: _MainContainerController_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
        layout    : {ntype: 'vbox', align: 'stretch'},

        items: [{
            module : _src_toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
            flex   : 'none',
            padding: 20,
            reference: 'headerToolbar',

            style: {
                backgroundColor: '#f2f2f2',
                padding        : '10px 5px 10px 10px'
            },

            items: [{
                ntype: 'component',
                cls  : ['neo-header'],
                html : '<i class="fa fa-calendar"></i>neo.mjs Calendar'
            }, '->', {
                module : _src_button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                handler: 'onSwitchThemeButtonClick',
                height : 27,
                iconCls: 'fa fa-moon',
                text   : 'Theme Dark'
            }, {
                module : _src_button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                height : 27,
                iconCls: 'fab fa-github',
                style  : {marginLeft: '5px'},
                text   : 'GitHub',
                url    : 'https://github.com/neomjs/neo/tree/dev/src/calendar'
            }]
        }, {
            module   : _src_calendar_view_MainContainer_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            flex     : 1,
            reference: 'calendar',

            calendarStoreConfig: {
                autoLoad: true,
                url     : '../../examples/calendar/basic/data/calendars.json'
            },

            eventStoreConfig: {
                autoLoad: true,
                url     : '../../examples/calendar/basic/data/events.json'
            },

            modelData: {
                currentDate: new Date('2024-07-21')
            }
        }]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MainContainer));


/***/ }),

/***/ "./examples/calendar/basic/MainContainerController.mjs":
/*!*************************************************************!*\
  !*** ./examples/calendar/basic/MainContainerController.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/controller/Component.mjs */ "./src/controller/Component.mjs");


/**
 * @class Neo.examples.calendar.basic.MainContainerController
 * @extends Neo.controller.Component
 */
class MainContainerController extends _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.examples.calendar.basic.MainContainerController'
         * @protected
         */
        className: 'Neo.examples.calendar.basic.MainContainerController'
    }

    /**
     * @param {Object} data
     */
    onSwitchThemeButtonClick(data) {
        let me            = this,
            button        = data.component,
            component     = me.component,
            headerToolbar = me.getReference('headerToolbar'),
            buttonText, headerColor, iconCls, style, theme;

        if (button.text === 'Theme Light') {
            buttonText  = 'Theme Dark';
            headerColor = '#f2f2f2';
            iconCls     = 'fa fa-moon';
            theme       = 'neo-theme-light'
        } else {
            buttonText  = 'Theme Light';
            headerColor = '#33343d';
            iconCls     = 'fa fa-sun';
            theme       = 'neo-theme-dark'
        }

        component.theme = theme;

        button.set({
            iconCls,
            text: buttonText
        });

        style = headerToolbar.style || {};
        style.backgroundColor = headerColor;
        headerToolbar.style = style
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MainContainerController));


/***/ }),

/***/ "./examples/calendar/basic/app.mjs":
/*!*****************************************!*\
  !*** ./examples/calendar/basic/app.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   onStart: () => (/* binding */ onStart)
/* harmony export */ });
/* harmony import */ var _MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MainContainer.mjs */ "./examples/calendar/basic/MainContainer.mjs");


const onStart = () => Neo.app({
    mainView: _MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
    name    : 'Neo.examples.calendar.basic'
});


/***/ }),

/***/ "./src/calendar/view/EditEventContainer.mjs":
/*!**************************************************!*\
  !*** ./src/calendar/view/EditEventContainer.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../button/Base.mjs */ "./src/button/Base.mjs");
/* harmony import */ var _store_Calendars_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../store/Calendars.mjs */ "./src/calendar/store/Calendars.mjs");
/* harmony import */ var _form_field_Color_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../form/field/Color.mjs */ "./src/form/field/Color.mjs");
/* harmony import */ var _util_Date_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/Date.mjs */ "./src/util/Date.mjs");
/* harmony import */ var _form_Container_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../form/Container.mjs */ "./src/form/Container.mjs");
/* harmony import */ var _form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../form/field/Text.mjs */ "./src/form/field/Text.mjs");
/* harmony import */ var _form_field_Time_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../form/field/Time.mjs */ "./src/form/field/Time.mjs");








/**
 * @class Neo.calendar.view.EditEventContainer
 * @extends Neo.form.Container
 */
class EditEventContainer extends _form_Container_mjs__WEBPACK_IMPORTED_MODULE_4__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.calendar.view.EditEventContainer'
         * @protected
         */
        className: 'Neo.calendar.view.EditEventContainer',
        /**
         * @member {String[]} baseCls=['neo-calendar-edit-event-container']
         */
        baseCls: ['neo-calendar-edit-event-container'],
        /**
         * @member {Object} bind
         */
        bind: {
            endTime             : data => data.endTime,
            intlFormat_time     : data => data.timeFormatter,
            minimumEventDuration: data => data.minimumEventDuration,
            startTime           : data => data.startTime
        },
        /**
         * @member {Object|null} calendarFieldConfig=null
         */
        calendarFieldConfig: null,
        /**
         * Only full hours are valid for now
         * format: 'hh:mm'
         * @member {String} endTime_='24:00'
         * @reactive
         */
        endTime_: '24:00',
        /**
         * @member {Object|null} endTimeFieldConfig=null
         */
        endTimeFieldConfig: null,
        /**
         * Bound to the state provider.
         * @member {Intl.DateTimeFormat|null} intlFormat_time=null
         * @protected
         */
        intlFormat_time: null,
        /**
         * @member {Neo.calendar.view.week.Component|null} owner=null
         */
        owner: null,
        /**
         * @member {Neo.calendar.model.Event|null} record_=null
         * @reactive
         */
        record_: null,
        /**
         * Only full hours are valid for now
         * format: 'hh:mm'
         * @member {String} startTime_='00:00'
         * @reactive
         */
        startTime_: '00:00',
        /**
         * @member {Object|null} startTimeFieldConfig=null
         */
        startTimeFieldConfig: null,
        /**
         * @member {Object|null} titleFieldConfig=null
         */
        titleFieldConfig: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        // focus trap, see: https://github.com/neomjs/neo/issues/2306
        this.vdom.tabIndex = -1
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);
        value && this.getField('title').then(field => field.focus())
    }

    /**
     * Triggered after the record config got changed
     * @param {Neo.calendar.model.Event} value
     * @param {Neo.calendar.model.Event} oldValue
     * @protected
     */
    afterSetRecord(value, oldValue) {
        if (value && oldValue) {
            let me                  = this,
                timeFormat          = me.intlFormat_time,
                {calendarId, title} = value;

            me.getField('endTime')  .then(field => field.minValue = me.getEndTimeMinValue(value));
            me.getField('startTime').then(field => field.maxValue = me.getStartTimeMaxValue(value));

            me.reset({
                calendarId,
                endTime  : timeFormat.format(value.endDate),
                startTime: timeFormat.format(value.startDate),
                title
            })
        } else if (value) {
            this.createItems()
        }
    }

    /**
     *
     */
    createItems() {
        let me         = this,
            {record}   = me,
            timeFormat = me.intlFormat_time,
            timeFieldDefaults = {
                module              : _form_field_Time_mjs__WEBPACK_IMPORTED_MODULE_6__["default"],
                clearToOriginalValue: true,
                flex                : 'none',
                labelPosition       : 'inline',
                listeners           : {change: me.onTimeFieldChange, scope: me},
                stepSize            : 15 * 60,
                width               : '9em'
            };

        if (record) {
            me.items = [{
                module              : _form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_5__["default"],
                clearToOriginalValue: true,
                flex                : 'none',
                labelPosition       : 'inline',
                labelText           : 'Title',
                listeners           : {change: me.onTitleFieldChange, scope: me},
                name                : 'title',
                required            : true,
                value               : record.title,
                ...me.titleFieldConfig
            }, {
                module              : _form_field_Color_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
                clearToOriginalValue: true,
                colorField          : 'color',
                displayField        : 'name',
                flex                : 'none',
                forceSelection      : true,
                labelPosition       : 'inline',
                labelText           : 'Calendar',
                listeners           : {change: me.onCalendarFieldChange, scope: me},
                name                : 'calendarId',
                required            : true,
                triggerAction       : 'all',
                value               : record.calendarId,

                colorFormatter: (scope,data) => {
                    let value = data[scope.colorField];

                    if (value === 'yellow') {
                        return 'var(--event-yellow-border-color)';
                    }

                    return `var(--event-${value}-color)`
                },

                store: {
                    module  : _store_Calendars_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                    sourceId: me.stateProvider.getStore('calendars').id
                },

                ...me.calendarFieldConfig
            }, {
                labelText: 'Start Time',
                maxValue : me.getStartTimeMaxValue(record),
                minValue : me.startTime,
                name     : 'startTime',
                value    : timeFormat.format(record.startDate),
                ...timeFieldDefaults,
                ...me.startTimeFieldConfig
            }, {
                labelText: 'End Time',
                maxValue : me.endTime,
                minValue : me.getEndTimeMinValue(record),
                name     : 'endTime',
                value    : timeFormat.format(record.endDate),
                ...timeFieldDefaults,
                ...me.endTimeFieldConfig
            }, {
                module : _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                cls    : ['neo-button', 'neo-red'],
                handler: me.onDeleteButtonClick.bind(me),
                iconCls: 'fas fa-trash-alt',
                style  : {marginTop: '3em'},
                text   : 'Delete'
            }];

            super.createItems()
        }
    }

    /**
     * @param {Neo.calendar.model.Event} record
     * @returns {String}
     */
    getEndTimeMinValue(record) {
        let date = new Date(record.startDate.valueOf());

        date.setMinutes(date.getMinutes() + this.minimumEventDuration);

        return this.intlFormat_time.format(date);
    }

    /**
     * @param {Neo.calendar.model.Event} record
     * @returns {String}
     */
    getStartTimeMaxValue(record) {
        let date = new Date(record.endDate.valueOf());

        date.setMinutes(date.getMinutes() - this.minimumEventDuration);

        return this.intlFormat_time.format(date)
    }

    /**
     * @param {Object} data
     */
    onCalendarFieldChange(data) {
        if (!Neo.isEmpty(data.value)) {
            this.record.calendarId = data.value[data.component.store.keyProperty]
        }
    }

    /**
     * todo: we could add a confirm dialog
     * @param {Object} data
     */
    onDeleteButtonClick(data) {
        let me = this;

        me.getStateProvider().getStore('events').remove(me.record);
        me.unmount()
    }

    /**
     * @param {Object} data
     */
    async onFocusLeave(data) {
        let me = this;

        // we need a short delay, since a TimeField picker could be open
        await me.timeout(100);

        me.mounted && me.unmount()
    }

    /**
     * @param {Object} data
     */
    onTimeFieldChange(data) {
        let me     = this,
            name   = data.component.name,
            field  = name === 'endTime' ? 'endDate' : 'startDate',
            record = me.record,
            date   = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].clone(me.record[field]),
            value  = data.value.split(':').map(e => Number(e));

        date.setHours(value[0]);
        date.setMinutes(value[1]);

        record[field] = date;

        if (name === 'endTime') {
            me.getField('startTime').then(field => field.maxValue = me.getStartTimeMaxValue(record))
        } else {
            me.getField('endTime')  .then(field => field.minValue = me.getEndTimeMinValue(record))
        }
    }

    /**
     * @param {Object} data
     */
    onTitleFieldChange(data) {
        if (!Neo.isEmpty(data.value)) {
            this.record.title = data.value
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(EditEventContainer));


/***/ }),

/***/ "./src/calendar/view/MainContainer.mjs":
/*!*********************************************!*\
  !*** ./src/calendar/view/MainContainer.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _calendars_Container_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./calendars/Container.mjs */ "./src/calendar/view/calendars/Container.mjs");
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _component_DateSelector_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../component/DateSelector.mjs */ "./src/component/DateSelector.mjs");
/* harmony import */ var _util_Date_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/Date.mjs */ "./src/util/Date.mjs");
/* harmony import */ var _calendars_EditContainer_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./calendars/EditContainer.mjs */ "./src/calendar/view/calendars/EditContainer.mjs");
/* harmony import */ var _EditEventContainer_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./EditEventContainer.mjs */ "./src/calendar/view/EditEventContainer.mjs");
/* harmony import */ var _MainContainerStateProvider_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./MainContainerStateProvider.mjs */ "./src/calendar/view/MainContainerStateProvider.mjs");
/* harmony import */ var _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../toolbar/Base.mjs */ "./src/toolbar/Base.mjs");









const todayDate = new Date();

/**
 * @class Neo.calendar.view.MainContainer
 * @extends Neo.container.Base
 */
class MainContainer extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    /**
     * Valid entries for the views config
     * @member {String[]} validViews=['day','week','month','year']
     * @static
     */
    static validViews = ['day', 'week', 'month', 'year']

    static config = {
        /**
         * @member {String} className='Neo.calendar.view.MainContainer'
         * @protected
         */
        className: 'Neo.calendar.view.MainContainer',
        /**
         * @member {String} ntype='calendar-maincontainer'
         * @protected
         */
        ntype: 'calendar-maincontainer',
        /**
         * The currently active view. Must be a value included inside the views config.
         * valid values: 'day', 'week', 'month', 'year'
         * @member {String} activeView_='week'
         * @reactive
         */
        activeView_: 'week',
        /**
         * @member {String[]} baseCls=['neo-calendar-maincontainer','neo-container']
         */
        baseCls: ['neo-calendar-maincontainer', 'neo-container'],
        /**
         * Scale the calendar with using s different base font-size
         * @member {Number|null} baseFontSize_=null
         * @reactive
         */
        baseFontSize_: null,
        /**
         * @member {Neo.calendar.view.Container|null} calendarsContainer=null
         */
        calendarsContainer: null,
        /**
         * @member {Object|null} calendarStoreConfig_=null
         * @reactive
         */
        calendarStoreConfig_: null,
        /**
         * @member {Object|null} colorStoreConfig_=null
         * @reactive
         */
        colorStoreConfig_: null,
        /**
         * @member {Neo.component.DateSelector|null} dateSelector=null
         */
        dateSelector: null,
        /**
         * @member {Object|null} dateSelectorConfig=null
         */
        dateSelectorConfig: null,
        /**
         * @member {Neo.calendar.view.DayComponent|null} dayComponent=null
         */
        dayComponent: null,
        /**
         * @member {Object|null} dayComponentConfig=null
         */
        dayComponentConfig: null,
        /**
         * Read only
         * @member {Neo.calendar.view.calendars.EditContainer|null} editCalendarContainer_=null
         * @reactive
         */
        editCalendarContainer_: null,
        /**
         * @member {Object|null} editCalendarContainerConfig=null
         */
        editCalendarContainerConfig: null,
        /**
         * Read only
         * @member {Neo.calendar.view.EditEventContainer|null} editEventContainer_=null
         * @reactive
         */
        editEventContainer_: null,
        /**
         * @member {Object|null} editEventContainerConfig=null
         */
        editEventContainerConfig: null,
        /**
         * @member {Object|null} eventStoreConfig_=null
         * @reactive
         */
        eventStoreConfig_: null,
        /**
         * @member {Object} layout={ntype:'vbox',align:'stretch'}
         * @protected
         * @reactive
         */
        layout: {ntype: 'vbox', align: 'stretch'},
        /**
         * @member {Neo.calendar.view.Component|null} monthComponent=null
         */
        monthComponent: null,
        /**
         * @member {Object|null} monthComponentConfig=null
         */
        monthComponentConfig: null,
        /**
         * True to only keep the active view inside the DOM
         * @member {Boolean} removeInactiveCards=true
         */
        removeInactiveCards: true,
        /**
         * @member {Object|null} settingsContainerConfig=null
         */
        settingsContainerConfig: null,
        /**
         * @member {Number} settingsContainerWidth=300
         */
        settingsContainerWidth: 310,
        /**
         * @member {Boolean} settingsExpanded_=false
         * @reactive
         */
        settingsExpanded_: false,
        /**
         * @member {Boolean} sideBarExpanded_=true
         * @reactive
         */
        sideBarExpanded_: true,
        /**
         * @member {Number} sideBarWidth=220
         */
        sideBarWidth: 220,
        /**
         * @member {Neo.calendar.view.MainContainerStateProvider} stateProvider=MainContainerStateProvider
         * @reactive
         */
        stateProvider: _MainContainerStateProvider_mjs__WEBPACK_IMPORTED_MODULE_6__["default"],
        /**
         * @member {Boolean} useSettingsContainer_=true
         * @reactive
         */
        useSettingsContainer_: true,
        /**
         * Any combination and order of 'day', 'week', 'month', 'year'
         * @member {String[]} views_=['day','week','month','year']
         * @reactive
         */
        views_: ['day', 'week', 'month', 'year'],
        /**
         * @member {Neo.calendar.view.Component|null} weekComponent=null
         */
        weekComponent: null,
        /**
         * @member {Object|null} weekComponentConfig=null
         */
        weekComponentConfig: null,
        /**
         * @member {Neo.calendar.view.YearComponent|null} yearComponent=null
         */
        yearComponent: null,
        /**
         * @member {Object|null} yearComponentConfig=null
         */
        yearComponentConfig: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.createItemsContent();
        !me.sideBarExpanded && me.afterSetSideBarExpanded(false, true)
    }

    /**
     * Triggered after the activeView config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetActiveView(value, oldValue) {
        if (oldValue !== undefined) {
            let me = this;

            me.items[1].items[1].layout.activeIndex = me.views.indexOf(value);

            me.items[0].items[1].items.forEach(item => {
                if (item.toggleGroup === 'mainViews') {
                    item.pressed = item.value === value
                }
            });
        }
    }

    /**
     * Triggered after the baseFontSize config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetBaseFontSize(value, oldValue) {
        if (oldValue !== undefined) {
            let style = this.style || {};

            if (!value) {
                delete style.fontSize
            } else {
                style.fontSize = `${value}px`
            }

            this.style = style
        }
    }

    /**
     * Triggered after the settingsExpanded config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetSettingsExpanded(value, oldValue) {
        if (Neo.isBoolean(oldValue)) {
            let me                = this,
                settingsContainer = me.items[1].items[2];

            if (value) {
                if (settingsContainer) {
                    settingsContainer.expand()
                } else {
                    me.createSettingsContainer(true).then(() => {
                        // short delay to ensure the vnode already exists
                        me.timeout(50).then(() => {
                            me.items[1].items[2].expand()
                        })
                    })
                }
            } else {
                settingsContainer.collapse(me.settingsContainerWidth)
            }
        }
    }

    /**
     * Triggered after the sideBarExpanded config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetSideBarExpanded(value, oldValue) {
        if (oldValue !== undefined) {
            let me      = this,
                sideBar = me.items[1].items[0],
                style   = sideBar.style || {};

            if (value) {
                me.updateDepth = -1;

                // todo: updates colliding with parent updates need to pass the update depth for the next parent update cycle
                delete sideBar.vdom.removeDom;

                me.promiseUpdate().then(() => {
                    sideBar.mounted = true;

                    me.timeout(50).then(() => {
                        style.marginLeft = '0px';
                        sideBar.style = style
                    })
                })
            } else {
                style.marginLeft    = `-${me.sideBarWidth}px`;
                sideBar._style      = style; // silent update
                sideBar._vdom.style = style; // silent update

                sideBar.promiseUpdate().then(() => {
                    me.timeout(400).then(() => {
                        sideBar.vdom.removeDom = true;
                        sideBar.update();

                        sideBar.mounted = false
                    })
                })
            }
        }
    }

    /**
     * Triggered after the theme config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetTheme(value, oldValue) {
        super.afterSetTheme(value, oldValue);

        let me = this;

        if (me._editCalendarContainer) {
            me._editCalendarContainer.theme = value
        }

        if (me._editEventContainer) {
            me._editEventContainer.theme = value
        }
    }

    /**
     * Triggered after the useSettingsContainer config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetUseSettingsContainer(value, oldValue) {
        let me = this;

        if (value) {
            me.settingsExpanded && me.createSettingsContainer(false);

            // we need a short delay to ensure the items already got created
            me.timeout(10).then(() => {
                me.items[0].items[1].add({
                    handler: me.toggleSettings.bind(me),
                    iconCls: 'fa fa-cog',
                    style  : {marginLeft: '10px'}
                })
            })
        } else if (!value && oldValue) {
            // we only need this logic in case we dynamically change the config from true to false
            me.items[1]         .removeLast();
            me.items[0].items[1].removeLast()
        }
    }

    /**
     * Gets triggered before getting the value of the editCalendarContainer config
     * @param {Neo.calendar.view.calendars.EditContainer|null} value
     * @returns {Neo.calendar.view.calendars.EditContainer}
     */
    beforeGetEditCalendarContainer(value) {
        if (!value) {
            let me = this;

            me._editCalendarContainer = value = Neo.create({
                module       : _calendars_EditContainer_mjs__WEBPACK_IMPORTED_MODULE_4__["default"],
                appName      : me.appName,
                owner        : me,
                stateProvider: {parent: me.getStateProvider()},
                theme        : me.theme,
                width        : 250,
                windowId     : me.windowId,
                ...me.editCalendarContainerConfig
            })
        }

        return value
    }

    /**
     * Gets triggered before getting the value of the editEventContainer config
     * @param {Neo.calendar.view.EditEventContainer|null} value
     * @returns {Neo.calendar.view.EditEventContainer}
     */
    beforeGetEditEventContainer(value) {
        if (!value) {
            let me = this;

            me._editEventContainer = value = Neo.create({
                module       : _EditEventContainer_mjs__WEBPACK_IMPORTED_MODULE_5__["default"],
                appName      : me.appName,
                owner        : me,
                stateProvider: {parent: me.getStateProvider()},
                theme        : me.theme,
                width        : 250,
                windowId     : me.windowId,
                ...me.editEventContainerConfig
            })
        }

        return value
    }

    /**
     * Triggered before the activeView config gets changed.
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetActiveView(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'activeView', 'validViews')
    }

    /**
     * Triggered before the views config gets changed.
     * @param {String[]} value
     * @param {String[]} oldValue
     * @protected
     */
    beforeSetViews(value, oldValue) {
        let validViews = this.getStaticConfig('validViews');

        value.forEach(view => {
            if (!validViews.includes(view)) {
                console.error(view, 'is not a valid entry for views. Stick to:', validViews);
                return oldValue
            }
        });

        return value
    }

    /**
     * @param {String} view
     * @protected
     */
    changeActiveView(view) {
        this.activeView = view
    }

    /**
     * @returns {Object[]}
     */
    createHeaderItems() {
        let me = this;

        return [{
            module: _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_7__["default"],
            cls   : ['neo-calendar-header-toolbar', 'neo-left', 'neo-toolbar'],
            width : me.sideBarWidth,
            items : [{
                handler: me.toggleSidebar.bind(me),
                iconCls: 'fa fa-bars'
            }, '->', {
                handler: me.onPreviousIntervalButtonClick.bind(me),
                iconCls: 'fa fa-chevron-left',
            }, {
                handler: me.onTodayButtonClick.bind(me),
                height : 24,
                text   : 'Today'
            }, {
                handler: me.onNextIntervalButtonClick.bind(me),
                iconCls: 'fa fa-chevron-right'
            }]
        }, {
            module: _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_7__["default"],
            cls   : ['neo-calendar-header-toolbar', 'neo-toolbar'],
            items : ['->', ...me.createViewHeaderButtons()]
        }]
    }

    /**
     * @protected
     */
    createItemsContent() {
        let me = this;

        me.calendarsContainer = Neo.create({
            module  : _calendars_Container_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
            flex    : 1,
            parentId: me.id, // we need the parentId to access the model inside the ctor
            owner   : me
        });

        me.dateSelector = Neo.create({
            module   : _component_DateSelector_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            appName  : me.appName,
            flex     : 'none',
            height   : me.sideBarWidth,
            listeners: {dateChange: me.onDateSelectorChange, scope: me},
            parentId : me.id, // we need the parentId to access the model inside the ctor
            value    : null,

            bind: {
                locale              : data => data.locale,
                scrollNewYearFromTop: data => data.scrollNewYearFromTop,
                showWeekends        : data => data.showWeekends,
                value               : data => _util_Date_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].convertToyyyymmdd(data.currentDate),
                weekStartDay        : data => data.weekStartDay
            },

            ...me.dateSelectorConfig
        });

        me.items = [{
            module: _container_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            flex  : 'none',
            layout: {ntype: 'hbox', align: 'stretch'},
            items : me.createHeaderItems()
        }, {
            module: _container_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            flex  : 1,
            layout: {ntype: 'hbox', align: 'stretch'},
            items : [{
                module  : _container_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                cls     : ['neo-calendar-sidebar', 'neo-container'],
                layout  : {ntype: 'vbox', align: 'stretch'},
                minWidth: me.sideBarWidth,
                width   : me.sideBarWidth,
                items   : [me.dateSelector, me.calendarsContainer]
            }, {
                module   : _container_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                flex     : 1,
                items    : me.createViews(),
                listeners: {cardLoaded: me.onCardLoaded, scope: me},
                layout   : {
                    ntype              : 'card',
                    activeIndex        : me.views.indexOf(me.activeView),
                    removeInactiveCards: me.removeInactiveCards
                }
            }]
        }]
    }

    /**
     * @param {Boolean} collapsed
     * @returns {Promise<*>}
     */
    createSettingsContainer(collapsed) {
        let me = this;

        return Promise.all(/*! import() */[__webpack_require__.e("vendors-src_tab_Container_mjs"), __webpack_require__.e("src_calendar_view_SettingsContainer_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ./SettingsContainer.mjs */ "./src/calendar/view/SettingsContainer.mjs")).then(module => {
            me.items[1].add({
                module             : module.default,
                collapsed,
                minWidth           : me.settingsContainerWidth,
                removeInactiveCards: me.removeInactiveCards,
                style              : {marginRight: !collapsed ? '0' : `-${me.settingsContainerWidth}px`},
                width              : me.settingsContainerWidth,
                ...me.settingsContainerConfig
            })
        })
    }

    /**
     * @returns {Object[]}
     */
    createViewHeaderButtons() {
        let me          = this,
            activeIndex = me.views.indexOf(me.activeView),
            buttons     = [];

        me.views.forEach((view, index) => {
            buttons.push({
                handler    : me.changeActiveView.bind(me, view),
                height     : 24,
                pressed    : activeIndex === index,
                text       : Neo.capitalize(view),
                toggleGroup: 'mainViews',
                value      : view
            })
        });

        return buttons
    }

    /**
     * @returns {Neo.component.Base[]}
     */
    createViews() {
        let me    = this,
            cards = [],
            cmp,

        defaultConfig = {
            appName : me.appName,
            owner   : me,
            parentId: me.id
        },

        map = {
            day: {
                module: () => Promise.all(/*! import() */[__webpack_require__.e("vendors-src_calendar_view_week_Component_mjs"), __webpack_require__.e("src_calendar_view_DayComponent_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ./DayComponent.mjs */ "./src/calendar/view/DayComponent.mjs")),
                flag  : 'day',
                ...defaultConfig,
                ...me.dayComponentConfig
            },
            month: {
                module: () => __webpack_require__.e(/*! import() */ "vendors-src_calendar_view_month_Component_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./month/Component.mjs */ "./src/calendar/view/month/Component.mjs")),
                flag  : 'month',
                ...defaultConfig,
                ...me.monthComponentConfig
            },
            week: {
                module: () => __webpack_require__.e(/*! import() */ "vendors-src_calendar_view_week_Component_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./week/Component.mjs */ "./src/calendar/view/week/Component.mjs")),
                flag  : 'week',
                ...defaultConfig,
                ...me.weekComponentConfig
            },
            year: {
                module: () => __webpack_require__.e(/*! import() */ "vendors-src_calendar_view_YearComponent_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./YearComponent.mjs */ "./src/calendar/view/YearComponent.mjs")),
                flag  : 'year',
                ...defaultConfig,
                ...me.yearComponentConfig
            }
        };

        me.views.forEach(view => {
            me[`${view}Component`] = cmp = map[view];
            cards.push(cmp);
        });

        return cards
    }

    /**
     * @param data
     */
    onCardLoaded(data) {
        this[`${data.item.flag}Component`] = data.item;

        // fire the event on this instance as well => setting views can subscribe to it more easily
        this.fire('cardLoaded', {item: data.item})
    }

    /**
     * @param {Object} data
     * @param {String} data.oldValue
     * @param {String} data.value
     */
    onDateSelectorChange({value}) {
        this.setState('currentDate', value)
    }

    /**
     * @param data
     */
    onNextIntervalButtonClick(data) {
        this.switchInterval(1)
    }

    /**
     * @param data
     */
    onPreviousIntervalButtonClick(data) {
        this.switchInterval(-1)
    }

    /**
     * @param data
     */
    onTodayButtonClick(data) {
        this.stateProvider.setData({
            currentDate: todayDate
        })
    }

    /**
     * @protected
     */
    toggleSettings() {
        this.settingsExpanded = !this.settingsExpanded
    }

    /**
     * @protected
     */
    toggleSidebar() {
        this.sideBarExpanded = !this.sideBarExpanded
    }

    /**
     * @param {Number} multiplier
     */
    switchInterval(multiplier) {
        let me            = this,
            {currentDate} = me.data,

        map = {
            day  : () => {currentDate.setDate(    currentDate.getDate()     + multiplier)},
            month: () => {currentDate.setMonth(   currentDate.getMonth()    + multiplier)},
            week : () => {currentDate.setDate(    currentDate.getDate() + 7 * multiplier)},
            year : () => {currentDate.setFullYear(currentDate.getFullYear() + multiplier)}
        };

        map[me.activeView]();

        me.stateProvider.setData({currentDate})
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MainContainer));


/***/ }),

/***/ "./src/calendar/view/calendars/ColorsList.mjs":
/*!****************************************************!*\
  !*** ./src/calendar/view/calendars/ColorsList.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _list_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../list/Base.mjs */ "./src/list/Base.mjs");


/**
 * @class Neo.calendar.view.calendars.ColorsList
 * @extends Neo.list.Base
 */
class ColorsList extends _list_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.calendar.view.calendars.ColorsList'
         * @protected
         */
        className: 'Neo.calendar.view.calendars.ColorsList',
        /**
         * @member {String[]} baseCls=['neo-calendars-colors-list','neo-list']
         */
        baseCls: ['neo-calendars-colors-list', 'neo-list'],
        /**
         * @member {Object} bind
         */
        bind: {
            store: 'stores.colors'
        },
        /**
         * Set this to true in case a keyboard navigation should immediately select the focussed item
         * @member {Boolean} selectOnFocus=true
         */
        selectOnFocus: true,
        /**
         * @member {Boolean} useWrapperNode=false
         * @reactive
         */
        useWrapperNode: false,
        /**
         * The list gets used as a form field, so we are adjusting the selection based on this config
         * @member {String} value_=null
         * @reactive
         */
        value_: null,
        /**
         * Added a tabIndex to enable tabbing through the form
         * @member {Object} _vdom={tag:'ul',cn:[],tabIndex:'0'}
         */
        _vdom:
        {tag: 'ul', cn: [], tabIndex: '0'}
    }

    /**
     * Triggered after the value config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetValue(value, oldValue) {
        let me = this,
            record;

        if (value && oldValue !== undefined && !me.disableSelection) {
            record = me.store.find('name', value)[0];
            me.selectionModel?.select(me.getItemId(record[me.getKeyProperty()]))
        }
    }

    /**
     * Override this method for custom renderers
     * @param {Object} record
     * @param {Number} index
     * @returns {Object|Object[]|String} Either a config object to assign to the item, a vdom cn array or a string.
     */
    createItemContent(record, index) {
        return {style: {
            backgroundColor: `var(--event-${record.name}-color)`,
            color          : `var(--event-${record.name}-color)` // needed for the box-shadow (CSS currentColor)
        }}
    }

    /**
     * @returns {Object}
     */
    getVdomRoot() {
        return this.vdom
    }

    /**
     * @returns {Object}
     */
    getVnodeRoot() {
        return this.vnode
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me      = this,
            {value} = me;

        value && me.afterSetValue(value, null)
    }

    /**
     * Gets triggered from selection.Model: select()
     * @param {String[]} items
     */
    onSelect(items) {
        let me       = this,
            recordId = me.getItemRecordId(items[0]);

        me.fire('change', {
            record: me.store.get(recordId)
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(ColorsList));


/***/ }),

/***/ "./src/calendar/view/calendars/Container.mjs":
/*!***************************************************!*\
  !*** ./src/calendar/view/calendars/Container.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _List_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./List.mjs */ "./src/calendar/view/calendars/List.mjs");



/**
 * @class Neo.calendar.view.calendars.Container
 * @extends Neo.container.Base
 */
class Container extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.calendar.view.calendars.Container'
         * @protected
         */
        className: 'Neo.calendar.view.calendars.Container',
        /**
         * @member {String[]} baseCls=['neo-calendar-calendarscontainer','neo-container']
         */
        baseCls: ['neo-calendar-calendarscontainer', 'neo-container'],
        /**
         * @member {Object} bind
         */
        bind: {
            calendarStore: 'stores.calendars'
        },
        /**
         * @member {Neo.calendar.store.Calendars|null} calendarStore_=null
         * @reactive
         */
        calendarStore: null,
        /**
         * @member {Object[]} items
         */
        items: [{
            module: _List_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            owner : '@config:owner' // passing the owner config downwards
        }, {
            ntype       : 'button',
            cls         : ['neo-add-calendar-button'],
            flex        : 'none',
            handler     : 'onAddCalendarButtonClick',
            handlerScope: 'this',
            style       : {marginTop: 'auto'},
            text        : 'Add Calendar'
        }],
        /**
         * @member {Object} layout={ntype:'vbox',align:'stretch'}
         * @protected
         * @reactive
         */
        layout: {ntype: 'vbox', align: 'stretch'},
        /**
         * @member {Neo.calendar.view.MainContainer|null} owner=null
         * @protected
         */
        owner: null
    }

    /**
     * @param {Object} data
     */
    onAddCalendarButtonClick(data) {
        this.calendarStore.add({
            active: true,
            color : 'red',
            name  : 'New Calendar'
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Container));


/***/ }),

/***/ "./src/calendar/view/calendars/EditContainer.mjs":
/*!*******************************************************!*\
  !*** ./src/calendar/view/calendars/EditContainer.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../button/Base.mjs */ "./src/button/Base.mjs");
/* harmony import */ var _ColorsList_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ColorsList.mjs */ "./src/calendar/view/calendars/ColorsList.mjs");
/* harmony import */ var _form_Container_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../form/Container.mjs */ "./src/form/Container.mjs");
/* harmony import */ var _form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../form/field/Text.mjs */ "./src/form/field/Text.mjs");





/**
 * @class Neo.calendar.view.calendars.EditContainer
 * @extends Neo.form.Container
 */
class EditContainer extends _form_Container_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.calendar.view.calendars.EditContainer'
         * @protected
         */
        className: 'Neo.calendar.view.calendars.EditContainer',
        /**
         * @member {String[]} baseCls=['neo-calendar-edit-container']
         */
        baseCls: ['neo-calendar-edit-container'],
        /**
         * @member {Neo.calendar.view.calendars.ColorsList|null} colorsList=null
         */
        colorsList: null,
        /**
         * @member {Object|null} colorsListConfig=null
         */
        colorsListConfig: null,
        /**
         * @member {Object|null} nameFieldConfig=null
         */
        nameFieldConfig: null,
        /**
         * @member {Neo.calendar.view.MainContainer|null} owner=null
         */
        owner: null,
        /**
         * @member {Neo.calendar.model.Calendar|null} record_=null
         * @reactive
         */
        record_: null,
        /**
         * @member {Number|null} unMountTimeoutId=null
         * @protected
         */
        unMountTimeoutId: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        // focus trap, see: https://github.com/neomjs/neo/issues/2306
        this.vdom.tabIndex = -1;
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        value && this.getField('name').then(field => {
            field.focus()
        })
    }

    /**
     * Triggered after the record config got changed
     * @param {Neo.calendar.model.Calendar} value
     * @param {Neo.calendar.model.Calendar} oldValue
     * @protected
     */
    afterSetRecord(value, oldValue) {
        let me = this;

        if (value && oldValue) {
            me.reset({
                name: value.name
            });

            me.colorsList.value = value.color;
        } else if (value) {
            me.createItems();
        }
    }

    /**
     * Triggered before the record config gets changed
     * We need the before method to also get clicks on the same edit icon,
     * since it does trigger for not changed values.
     * @param {Neo.calendar.model.Calendar} value
     * @param {Neo.calendar.model.Calendar} oldValue
     * @protected
     */
    beforeSetRecord(value, oldValue) {
        let me = this;

        if (me.unMountTimeoutId) {
            clearTimeout(me.unMountTimeoutId);
            me.unMountTimeoutId = null;
        }

        return value;
    }

    /**
     *
     */
    createItems() {
        let me       = this,
            {record} = me;

        if (record) {
            me.colorsList = Neo.create({
                module      : _ColorsList_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                listeners   : {change: me.onColorChange, scope: me},
                parentId    : me.parentId,
                value       : record.color,
                wrapperStyle: {marginTop: '0.2em'},
                ...me.colorsListConfig
            });

            me.items = [{
                module              : _form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
                clearToOriginalValue: true,
                flex                : 'none',
                labelPosition       : 'inline',
                labelText           : 'Calendar Name',
                listeners           : {change: me.onNameFieldChange, scope: me},
                name                : 'name',
                required            : true,
                value               : record.name,
                ...me.nameFieldConfig
            },
            me.colorsList, {
                module : _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                cls    : ['neo-red'],
                handler: me.onDeleteButtonClick.bind(me),
                iconCls: 'fas fa-trash-alt',
                style  : {marginTop: '3em'},
                text   : 'Delete'
            }];

            super.createItems();
        }
    }

    /**
     * @param {Object} data
     * @param {Object} data.record
     */
    onColorChange(data) {
        this.record.color = data.record.name;
    }

    /**
     * @param {Object} data
     */
    onDeleteButtonClick(data) {
        let me = this;

        // todo: we could add a confirm dialog

        me.getStateProvider().getStore('calendars').remove(me.record);
        me.unmount();
    }

    /**
     * @param {Object} [data]
     */
    onFocusLeave(data) {
        let me = this;

        // we need a short delay to get record-changes (clicking on another edit icon)
        me.unMountTimeoutId = setTimeout(() => {
            me.unMountTimeoutId = null;
            me.mounted && me.unmount();
        }, 200);
    }

    /**
     * @param {Object} data
     */
    onNameFieldChange(data) {
        if (!Neo.isEmpty(data.value)) {
            this.record.name = data.value;
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(EditContainer));


/***/ }),

/***/ "./src/calendar/view/calendars/List.mjs":
/*!**********************************************!*\
  !*** ./src/calendar/view/calendars/List.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _form_field_CheckBox_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../form/field/CheckBox.mjs */ "./src/form/field/CheckBox.mjs");
/* harmony import */ var _list_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../list/Component.mjs */ "./src/list/Component.mjs");



/**
 * @class Neo.calendar.view.calendars.List
 * @extends Neo.list.Component
 */
class List extends _list_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.calendar.view.calendars.List'
         * @protected
         */
        className: 'Neo.calendar.view.calendars.List',
        /**
         * @member {String[]} baseCls=['neo-calendars-list','neo-list']
         */
        baseCls: ['neo-calendars-list', 'neo-list'],
        /**
         * @member {Object} bind
         */
        bind: {
            store: 'stores.calendars'
        },
        /**
         * @member {Object} itemDefaults
         */
        itemDefaults: {
            module        : _form_field_CheckBox_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
            flex          : 'none',
            hideLabel     : true,
            iconCls       : ['fas', 'fa-square'],
            iconClsChecked: ['fas', 'fa-check-square']
        },
        /**
         * @member {Neo.calendar.view.MainContainer|null} owner=null
         * @protected
         */
        owner: null
    }

    /**
     * Override this method for custom renderers
     * @param {Object} record
     * @param {Number} index
     * @returns {Object|Object[]|String} Either a config object to assign to the item, a vdom cn array or a string.
     */
    createItemContent(record, index) {
        let me       = this,
            id       = record[me.getKeyProperty()],
            items    = me.items || [],
            checkBox = items[index],

        config = {
            checked   : record.active,
            cls       : [`neo-color-${record.color}`],
            fieldValue: id,
            id        : me.getComponentId(index),
            valueLabel: record.name
        };

        if (checkBox) {
            checkBox.setSilent(config)
        } else {
            items[index] = checkBox = Neo.create({
                appName  : me.appName,
                listeners: {change: me.onCheckboxChange, scope: me},
                parentId : me.id,
                windowId : me.windowId,
                ...me.itemDefaults,
                ...config
            })
        }

        me.items       = items;
        me.updateDepth = 2;

        return [
            checkBox.createVdomReference(),
            {tag: 'i', cls: ['neo-edit-icon', 'fas', 'fa-edit'], id: me.getEditIconId(index)}
        ]
    }

    /**
     * @param {Number} index
     * @returns {String}
     */
    getEditIconId(index) {
        return `${this.id}__${index}__edit-icon`
    }

    /**
     * @param {Object} data
     */
    onCheckboxChange(data) {
        this.store.get(data.component.fieldValue).active = data.value
    }

    /**
     * @param {Object} data
     */
    onClick(data) {
        // The click even arrives before the CheckBox onInputValueChange() gets triggered.
        // We need a short delay to ensure the vdom of the list item contains the new checked state
        this.timeout(20).then(() => {
            super.onClick(data)
        });

        if (data.path[0].cls.includes('neo-edit-icon')) {
            let me                    = this,
                listItemRect          = data.path[1].rect,
                mainContainer         = me.owner,
                editCalendarContainer = mainContainer.editCalendarContainer,
                {mounted, style}      = editCalendarContainer,
                record                = me.store.get(me.getItemRecordId(data.path[1].id));

            Object.assign(style, {
                left: `${listItemRect.right + 13}px`,
                top : `${listItemRect.top   - 10}px`
            });

            editCalendarContainer[mounted ? 'set' : 'setSilent']({
                parentId: mainContainer.id,
                record,
                style
            });

            if (!mounted) {
                editCalendarContainer.initVnode(true)
            } else {
                editCalendarContainer.afterSetMounted(true, false)
            }
        }
    }

    /**
     * @param {String} itemId
     */
    onKeyDownEnter(itemId) {
        let me       = this,
            recordId = me.getItemRecordId(itemId),
            checkBox = me.items[me.store.indexOf(recordId)];

        checkBox.checked = !checkBox.checked
    }

    /**
     * @param {String[]} items
     */
    onSelect(items) {
        this.setState('activeCalendarId', this.getItemRecordId(items[0]))
    }

    /**
     * Disabling the super class logic for now, since the collection.Base mutation event already covers the sorting
     * @param {Object} data
     */
    sortItems(data) {

    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(List));


/***/ }),

/***/ "./src/component/Label.mjs":
/*!*********************************!*\
  !*** ./src/component/Label.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/component/Base.mjs");


/**
 * Convenience class to render a label with a text
 * @class Neo.component.Label
 * @extends Neo.component.Base
 */
class Label extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.Label'
         * @protected
         */
        className: 'Neo.component.Label',
        /**
         * @member {String} ntype='label'
         * @protected
         */
        ntype: 'label',
        /**
         * @member {String[]} baseCls=['neo-label']
         */
        baseCls: ['neo-label'],
        /**
         * @member {String} tag='label'
         * @protected
         * @reactive
         */
        tag: 'label'
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Label));


/***/ }),

/***/ "./src/controller/Component.mjs":
/*!**************************************!*\
  !*** ./src/controller/Component.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/controller/Base.mjs");
/* harmony import */ var _util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Function.mjs */ "./src/util/Function.mjs");



/**
 * @class Neo.controller.Component
 * @extends Neo.controller.Base
 */
class Component extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.controller.Component'
         * @protected
         */
        className: 'Neo.controller.Component',
        /**
         * @member {String} ntype='component-controller'
         * @protected
         */
        ntype: 'component-controller',
        /**
         * @member {Neo.component.Base|null} component=null
         * @protected
         */
        component: null,
        /**
         * @member {Neo.controller.Component|null} parent_=null
         * @reactive
         */
        parent_: null,
        /**
         * @member {Object} references=null
         * @protected
         */
        references: null,
        /**
         * @member {Number|null} windowId=null
         */
        windowId: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me          = this,
            {component} = me;

        me.references = {};

        if (component.isConstructed) {
            me.onComponentConstructed()
        } else {
            component.on('constructed', () => {
                me.onComponentConstructed()
            }, me, {once: true})
        }
    }

    /**
     * Triggered before the parent config gets changed
     * @param {Neo.controller.Component|null} value
     * @param {Neo.controller.Component|null} oldValue
     * @protected
     */
    beforeSetParent(value, oldValue) {
        return value || this.getParent()
    }

    /**
     * @param {String} handlerName
     * @param {Neo.component.Base|null} [component]
     * @returns {Neo.controller.Component|Boolean|null}
     */
    getHandlerScope(handlerName, component) {
        let me       = this,
            {parent} = me,
            handlerCb;

        if (component) {
            // Look for ths function *name* first in the Component itself.
            // If we find it, return true so calling code knows not to continue to search.
            handlerCb = (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveCallback)(handlerName, component);

            // Handler fn is resolved in the Component or its own parent chain.
            // Return a status indicating that we do not need an early binding
            if (handlerCb.fn) {
                return true
            }
        }

        return Neo.isFunction(me[handlerName]) ?
            me : parent?.getHandlerScope(handlerName) || null
    }

    /**
     * Get the closest controller inside the components parent tree
     * @returns {Neo.controller.Component|null}
     */
    getParent() {
        let me       = this,
            {parent} = me;

        if (parent) {
            return parent
        }

        return me.component.parent?.getController() || null
    }

    /**
     * todo: update changed references (e.g. container.remove() then container.add() using the same key)
     * @param {String} name
     * @returns {*}
     */
    getReference(name) {
        let me        = this,
            component = me.references[name];

        if (!component) {
            component = me.component.down({reference: name});

            if (component) {
                me.references[name] = component
            }
        }

        return component || null
    }

    /**
     * Convenience shortcut
     * @param args
     * @returns {*}
     */
    getState(...args) {
        return this.getStateProvider().getData(...args)
    }

    /**
     * sameLevelOnly=false will return the closest stateProvider inside the component parent tree,
     * in case there is none on the same level.
     * @param {Boolean} [sameLevelOnly=false]
     */
    getStateProvider(sameLevelOnly=false) {
        let {component} = this;
        return sameLevelOnly ? component.stateProvider : component.getStateProvider()
    }

    /**
     * Convenience shortcut for accessing state.Provider based data.Stores
     * @param {String} key
     * @returns {Neo.data.Store}
     */
    getStore(key) {
        return this.getStateProvider().getStore(key)
    }

    /**
     * Override this method inside your view controllers as a starting point in case you need references
     * (instead of using onConstructed() inside your controller)
     */
    onComponentConstructed() {}

    /**
     * Will get called by component.Base: destroy() in case the component has a reference config
     * @param {Neo.component.Base} component
     */
    removeReference(component) {
        let me           = this,
            {references} = me,
            key;

        for (key in references) {
            if (component === references[key]) {
                delete references[key];
                break
            }
        }

        me.getParent()?.removeReference(component)
    }

    /**
     * Convenience shortcut
     * @param args
     */
    setState(...args) {
        this.getStateProvider().setData(...args)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Component));


/***/ }),

/***/ "./src/form/field/Color.mjs":
/*!**********************************!*\
  !*** ./src/form/field/Color.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _list_Color_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../list/Color.mjs */ "./src/list/Color.mjs");
/* harmony import */ var _ComboBox_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ComboBox.mjs */ "./src/form/field/ComboBox.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");




/**
 * @class Neo.form.field.Color
 * @extends Neo.form.field.ComboBox
 */
class Color extends _ComboBox_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.form.field.Color'
         * @protected
         */
        className: 'Neo.form.field.Color',
        /**
         * @member {String} ntype='colorfield'
         * @protected
         */
        ntype: 'colorfield',
        /**
         * @member {String[]} baseCls=['neo-colorfield','neo-combobox','neo-pickerfield','neo-textfield']
         */
        baseCls: ['neo-colorfield', 'neo-combobox', 'neo-pickerfield', 'neo-textfield'],
        /**
         * The data.Model field which contains the color value
         * @member {String} colorField='name'
         */
        colorField: 'name',
        /**
         * Override the formatter to apply a custom background-color styling.
         * E.g. using CSS vars for different themes
         * @member {Function} colorField=(scope,data)=>data[scope.colorField]
         */
        colorFormatter: (scope,data) => data[scope.colorField],
        /**
         * @member {Object|null} listConfig
         */
        listConfig: {
            module            : _list_Color_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
            colorField        : '@config:colorField',
            colorFormatter    : '@config:colorFormatter',
            silentSelectUpdate: true
        }
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me           = this,
            inputWrapper = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].find(me.vdom, me.getInputWrapperId());

        inputWrapper.vdom.cn.unshift({
            cls  : 'neo-color',
            id   : me.getColorIndicatorId(),
            style: {
                backgroundColor: me.getColor()
            }
        });

        me.update()
    }

    /**
     * Triggered after the value config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @param {Boolean} [preventFilter=false]
     * @protected
     */
    afterSetValue(value, oldValue, preventFilter=false) {
        let me             = this,
            colorIndicator = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].find(me.vdom, me.getColorIndicatorId())?.vdom,
            {list, record} = me,
            selectionModel = me.list?.selectionModel;

        if (colorIndicator) {
            colorIndicator.style.backgroundColor = me.getColor()
        }

        if (record) {
            selectionModel?.select(list.getItemId(record[me.store.keyProperty]))
        } else {
            selectionModel?.deselectAll(true)
        }

        // the super call will trigger the vdom update
        super.afterSetValue(value, oldValue, preventFilter)
    }

    /**
     * @returns {String}
     */
    getColor() {
        let me                  = this,
            {inputValue, value} = me;

        return value ? me.colorFormatter(me, value) : me.forceSelection ? null : inputValue
    }

    /**
     * @returns {String}
     */
    getColorIndicatorId() {
        return `${this.id}__color-indicator`
    }

    /**
     * @protected
     */
    onSelectPostLastItem() {
        let {list} = this,
            index  = list.store.getCount() - 1;

        list.vdom.cn[index] = list.createItem(list.store.getAt(index), index);

        super.onSelectPostLastItem()
    }

    /**
     * @protected
     */
    onSelectPreFirstItem() {
        let {list} = this;

        list.vdom.cn[0] = list.createItem(list.store.getAt(0), 0);

        super.onSelectPreFirstItem()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Color));


/***/ }),

/***/ "./src/list/Component.mjs":
/*!********************************!*\
  !*** ./src/list/Component.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/list/Base.mjs");


/**
 * A base class for lists which will use component based list items
 * @class Neo.list.Component
 * @extends Neo.list.Base
 */
class Component extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.list.Component'
         * @protected
         */
        className: 'Neo.list.Component',
        /**
         * @member {String} ntype='component-list'
         * @protected
         */
        ntype: 'component-list',
        /**
         * @member {Neo.component.Base[]|null} items=null
         */
        items: null
    }

    /**
     * Triggered after the appName config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetAppName(value, oldValue) {
        super.afterSetAppName(value, oldValue);

        value && this.items?.forEach(item => {
            item.appName = value
        })
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        super.afterSetWindowId(value, oldValue);

        value && this.items?.forEach(item => {
            item.windowId = value
        })
    }

    /**
     *
     */
    destroy(...args) {
        let items = this.items || [];

        items.forEach(item => {
            item.destroy()
        });

        super.destroy(...args)
    }

    /**
     * @param {Number} index
     * @returns {String}
     */
    getComponentId(index) {
        return `${this.id}__${index}__component`
    }

    /**
     * @param {Number|String} recordId
     * @returns {String}
     */
    getItemId(recordId) {
        return `${this.id}__${this.store.indexOf(recordId)}`
    }

    /**
     * @param {String} vnodeId
     * @returns {String|Number} itemId
     */
    getItemRecordId(vnodeId) {
        let itemId = vnodeId.split('__')[1];
        return this.store.getAt(parseInt(itemId))[this.getKeyProperty()]
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.items
     * @param {Object[]} data.previousItems
     * @param {Neo.data.Store} data.scope
     */
    onStoreSort(data) {
        this.sortItems(data);
        super.onStoreSort(data)
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.items
     * @param {Object[]} data.previousItems
     * @param {Neo.data.Store} data.scope
     */
    sortItems(data) {
        let me       = this,
            newItems = [],
            fromIndex, key, previousKeys;

        if (me.items) {
            me.items.forEach(item => {
                item.setSilent({id: null})
            });

            key          = me.getKeyProperty();
            previousKeys = data.previousItems.map(e => e[key]);

            data.items.forEach(item => {
                fromIndex = previousKeys.indexOf(item[key]);
                newItems.push(me.items[fromIndex])
            });

            me.updateDepth = -1;
            me.items = newItems
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Component));


/***/ }),

/***/ "./src/toolbar/Base.mjs":
/*!******************************!*\
  !*** ./src/toolbar/Base.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../button/Base.mjs */ "./src/button/Base.mjs");
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _component_Label_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../component/Label.mjs */ "./src/component/Label.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");






/**
 * @class Neo.toolbar.Base
 * @extends Neo.container.Base
 */
class Toolbar extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    /**
     * Valid values for dock
     * @member {String[]} dockPositions=['top','right','bottom','left', null]
     * @static
     */
    static dockPositions = ['top', 'right', 'bottom', 'left', null]

    static config = {
        /**
         * @member {String} className='Neo.toolbar.Base'
         * @protected
         */
        className: 'Neo.toolbar.Base',
        /**
         * @member {String} ntype='toolbar'
         * @protected
         */
        ntype: 'toolbar',
        /**
         * @member {String[]} baseCls=['neo-toolbar']
         */
        baseCls: ['neo-toolbar'],
        /**
         * @member {String|null} dock_=null
         * @reactive
         */
        dock_: null,
        /**
         * @member {Object} itemDefaults={ntype:'button'}
         * @reactive
         */
        itemDefaults: {
            ntype: 'button'
        },
        /**
         * @member {Object} layout={ntype:'flexbox',align:'center',direction: 'row', pack:'start'}
         * @reactive
         */
        layout: {
            ntype    : 'flexbox',
            align    : 'center',
            direction: 'row',
            pack     : 'start'
        },
        /**
         * @member {Boolean} sortable_=false
         * @reactive
         */
        sortable_: false,
        /**
         * @member {Neo.draggable.toolbar.SortZone|null} sortZone=null
         */
        sortZone: null,
        /**
         * @member {Object} sortZoneConfig=null
         */
        sortZoneConfig: null
    }

    /**
     * Triggered after the appName config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetAppName(value, oldValue) {
        super.afterSetAppName(value, oldValue);

        if (this.sortZone) {
            this.sortZone.appName = value
        }
    }

    /**
     * Triggered after the dock config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetDock(value, oldValue) {
        if (!value && !oldValue) {
            return
        }

        let me            = this,
            {cls}         = me,
            dockPositions = me.getStaticConfig('dockPositions'),
            layoutConfig  = me.getLayoutConfig();

        dockPositions.forEach(key => {
            key !== null && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].toggle(cls, 'neo-dock-' + key, key === value)
        });

        if (!me.layout) {
            layoutConfig.ntype = 'flexbox';
            me.set({cls, layout: layoutConfig})
        } else {
            me.layout.set(layoutConfig);
            me.cls = cls;
        }
    }

    /**
     * Triggered after the sortable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetSortable(value, oldValue) {
        let me = this;

        if (value && !me.sortZone) {
            Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("vendors-src_draggable_container_SortZone_mjs"), __webpack_require__.e("src_draggable_toolbar_SortZone_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ../draggable/toolbar/SortZone.mjs */ "./src/draggable/toolbar/SortZone.mjs")).then(module => {
                me.sortZone = Neo.create({
                    module             : module.default,
                    appName            : me.appName,
                    boundaryContainerId: me.id,
                    owner              : me,
                    windowId           : me.windowId,
                    ...me.sortZoneConfig
                })
            })
        }
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        super.afterSetWindowId(value, oldValue);

        if (this.sortZone) {
            this.sortZone.windowId = value
        }
    }

    /**
     * Checks if the new dock position matches a value of the static dockPositions config
     * @param {String} value
     * @param {String} oldValue
     * @returns {String} value
     * @protected
     */
    beforeSetDock(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'dock', 'dockPositions')
    }

    /**
     *
     */
    createItems() {
        let items = this._items;

        if (Array.isArray(items)) {
            this._items = items.map(item => this.replaceSpacer(item))
        }

        return super.createItems()
    }

    /**
     * Creates a layout config depending on this.dock
     * @returns {Object} layoutConfig
     */
    getLayoutConfig() {
        let me = this,
            layoutConfig;

        if (me.dock) {
            switch (me.dock) {
                case 'bottom':
                case 'top':
                    layoutConfig = {
                        align    : 'center',
                        direction: 'row',
                        pack     : 'start'
                    };
                    break
                case 'left':
                    layoutConfig = {
                        align    : 'center',
                        direction: 'column-reverse',
                        pack     : 'start'
                    };
                    break
                case 'right':
                    layoutConfig = {
                        align    : 'center',
                        direction: 'column',
                        pack     : 'start'
                    };
                    break
            }
        }

        return layoutConfig || me.layout
    }

    /**
     * Inserts an item or array of items at a specific index
     * @param {Number} index
     * @param {Array|Object} item
     * @param {Boolean} [silent=false]
     * @returns {Neo.component.Base|Neo.component.Base[]}
     */
    insert(index, item, silent=false) {
        if (Array.isArray(item)) {
            item = item.map(item => this.replaceSpacer(item))
        } else {
            item = this.replaceSpacer(item)
        }

        return super.insert(index, item, silent)
    }

    /**
     * @param {Array|Object|String} item
     * @returns {Array|Object}
     */
    replaceSpacer(item) {
        return item === '->' ? {module: _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"], flex: 1} : item
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Toolbar));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLWV4YW1wbGVzX2NhbGVuZGFyX2Jhc2ljX2FwcF9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW1FO0FBQ2dCO0FBQ2Y7QUFDQTtBQUNNOztBQUUxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtRUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvRUFBdUI7QUFDM0MscUJBQXFCLGdDQUFnQzs7QUFFckQ7QUFDQSxxQkFBcUIsNkRBQU87QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IseUJBQXlCLDREQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHlCQUF5Qiw0REFBTTtBQUMvQjtBQUNBO0FBQ0EsMEJBQTBCLGtCQUFrQjtBQUM1QztBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCx1QkFBdUIsNEVBQVE7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsaUVBQWUsNkJBQTZCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyRTJCOztBQUV4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxRUFBbUI7QUFDekQ7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUs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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGdDQUFnQyxRQUFRLDJEQUFTLFdBQVc7QUFDNUQ7QUFDQTs7QUFFQSxpRUFBZSx1QkFBdUIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9leGFtcGxlcy9jYWxlbmRhci9iYXNpYy9NYWluQ29udGFpbmVyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vZXhhbXBsZXMvY2FsZW5kYXIvYmFzaWMvTWFpbkNvbnRhaW5lckNvbnRyb2xsZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9leGFtcGxlcy9jYWxlbmRhci9iYXNpYy9hcHAubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY2FsZW5kYXIvdmlldy9FZGl0RXZlbnRDb250YWluZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY2FsZW5kYXIvdmlldy9NYWluQ29udGFpbmVyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NhbGVuZGFyL3ZpZXcvY2FsZW5kYXJzL0NvbG9yc0xpc3QubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY2FsZW5kYXIvdmlldy9jYWxlbmRhcnMvQ29udGFpbmVyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NhbGVuZGFyL3ZpZXcvY2FsZW5kYXJzL0VkaXRDb250YWluZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY2FsZW5kYXIvdmlldy9jYWxlbmRhcnMvTGlzdC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb21wb25lbnQvTGFiZWwubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29udHJvbGxlci9Db21wb25lbnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZm9ybS9maWVsZC9Db2xvci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9saXN0L0NvbXBvbmVudC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy90b29sYmFyL0Jhc2UubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCdXR0b24gICAgICAgICAgICAgICAgICBmcm9tICcuLi8uLi8uLi9zcmMvYnV0dG9uL0Jhc2UubWpzJztcbmltcG9ydCBDYWxlbmRhciAgICAgICAgICAgICAgICBmcm9tICcuLi8uLi8uLi9zcmMvY2FsZW5kYXIvdmlldy9NYWluQ29udGFpbmVyLm1qcyc7XG5pbXBvcnQgTWFpbkNvbnRhaW5lckNvbnRyb2xsZXIgZnJvbSAnLi9NYWluQ29udGFpbmVyQ29udHJvbGxlci5tanMnO1xuaW1wb3J0IFRvb2xiYXIgICAgICAgICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3NyYy90b29sYmFyL0Jhc2UubWpzJztcbmltcG9ydCBWaWV3cG9ydCAgICAgICAgICAgICAgICBmcm9tICcuLi8uLi8uLi9zcmMvY29udGFpbmVyL1ZpZXdwb3J0Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5leGFtcGxlcy5jYWxlbmRhci5iYXNpYy5NYWluQ29udGFpbmVyXG4gKiBAZXh0ZW5kcyBOZW8uY29udGFpbmVyLlZpZXdwb3J0XG4gKi9cbmNsYXNzIE1haW5Db250YWluZXIgZXh0ZW5kcyBWaWV3cG9ydCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgY2xhc3NOYW1lIDogJ05lby5leGFtcGxlcy5jYWxlbmRhci5iYXNpYy5NYWluQ29udGFpbmVyJyxcbiAgICAgICAgYXV0b01vdW50IDogdHJ1ZSxcbiAgICAgICAgY2xzICAgICAgIDogWyduZW8tZXhhbXBsZXMtY2FsZW5kYXItbWFpbmNvbnRhaW5lcicsICduZW8tdmlld3BvcnQnXSxcbiAgICAgICAgY29udHJvbGxlcjogTWFpbkNvbnRhaW5lckNvbnRyb2xsZXIsXG4gICAgICAgIGxheW91dCAgICA6IHtudHlwZTogJ3Zib3gnLCBhbGlnbjogJ3N0cmV0Y2gnfSxcblxuICAgICAgICBpdGVtczogW3tcbiAgICAgICAgICAgIG1vZHVsZSA6IFRvb2xiYXIsXG4gICAgICAgICAgICBmbGV4ICAgOiAnbm9uZScsXG4gICAgICAgICAgICBwYWRkaW5nOiAyMCxcbiAgICAgICAgICAgIHJlZmVyZW5jZTogJ2hlYWRlclRvb2xiYXInLFxuXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJyNmMmYyZjInLFxuICAgICAgICAgICAgICAgIHBhZGRpbmcgICAgICAgIDogJzEwcHggNXB4IDEwcHggMTBweCdcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGl0ZW1zOiBbe1xuICAgICAgICAgICAgICAgIG50eXBlOiAnY29tcG9uZW50JyxcbiAgICAgICAgICAgICAgICBjbHMgIDogWyduZW8taGVhZGVyJ10sXG4gICAgICAgICAgICAgICAgaHRtbCA6ICc8aSBjbGFzcz1cImZhIGZhLWNhbGVuZGFyXCI+PC9pPm5lby5tanMgQ2FsZW5kYXInXG4gICAgICAgICAgICB9LCAnLT4nLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlIDogQnV0dG9uLFxuICAgICAgICAgICAgICAgIGhhbmRsZXI6ICdvblN3aXRjaFRoZW1lQnV0dG9uQ2xpY2snLFxuICAgICAgICAgICAgICAgIGhlaWdodCA6IDI3LFxuICAgICAgICAgICAgICAgIGljb25DbHM6ICdmYSBmYS1tb29uJyxcbiAgICAgICAgICAgICAgICB0ZXh0ICAgOiAnVGhlbWUgRGFyaydcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUgOiBCdXR0b24sXG4gICAgICAgICAgICAgICAgaGVpZ2h0IDogMjcsXG4gICAgICAgICAgICAgICAgaWNvbkNsczogJ2ZhYiBmYS1naXRodWInLFxuICAgICAgICAgICAgICAgIHN0eWxlICA6IHttYXJnaW5MZWZ0OiAnNXB4J30sXG4gICAgICAgICAgICAgICAgdGV4dCAgIDogJ0dpdEh1YicsXG4gICAgICAgICAgICAgICAgdXJsICAgIDogJ2h0dHBzOi8vZ2l0aHViLmNvbS9uZW9tanMvbmVvL3RyZWUvZGV2L3NyYy9jYWxlbmRhcidcbiAgICAgICAgICAgIH1dXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1vZHVsZSAgIDogQ2FsZW5kYXIsXG4gICAgICAgICAgICBmbGV4ICAgICA6IDEsXG4gICAgICAgICAgICByZWZlcmVuY2U6ICdjYWxlbmRhcicsXG5cbiAgICAgICAgICAgIGNhbGVuZGFyU3RvcmVDb25maWc6IHtcbiAgICAgICAgICAgICAgICBhdXRvTG9hZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB1cmwgICAgIDogJy4uLy4uL2V4YW1wbGVzL2NhbGVuZGFyL2Jhc2ljL2RhdGEvY2FsZW5kYXJzLmpzb24nXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBldmVudFN0b3JlQ29uZmlnOiB7XG4gICAgICAgICAgICAgICAgYXV0b0xvYWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgdXJsICAgICA6ICcuLi8uLi9leGFtcGxlcy9jYWxlbmRhci9iYXNpYy9kYXRhL2V2ZW50cy5qc29uJ1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgbW9kZWxEYXRhOiB7XG4gICAgICAgICAgICAgICAgY3VycmVudERhdGU6IG5ldyBEYXRlKCcyMDI0LTA3LTIxJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfV1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKE1haW5Db250YWluZXIpO1xuIiwiaW1wb3J0IENvbXBvbmVudENvbnRyb2xsZXIgZnJvbSAnLi4vLi4vLi4vc3JjL2NvbnRyb2xsZXIvQ29tcG9uZW50Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5leGFtcGxlcy5jYWxlbmRhci5iYXNpYy5NYWluQ29udGFpbmVyQ29udHJvbGxlclxuICogQGV4dGVuZHMgTmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50XG4gKi9cbmNsYXNzIE1haW5Db250YWluZXJDb250cm9sbGVyIGV4dGVuZHMgQ29tcG9uZW50Q29udHJvbGxlciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZXhhbXBsZXMuY2FsZW5kYXIuYmFzaWMuTWFpbkNvbnRhaW5lckNvbnRyb2xsZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5leGFtcGxlcy5jYWxlbmRhci5iYXNpYy5NYWluQ29udGFpbmVyQ29udHJvbGxlcidcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uU3dpdGNoVGhlbWVCdXR0b25DbGljayhkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGJ1dHRvbiAgICAgICAgPSBkYXRhLmNvbXBvbmVudCxcbiAgICAgICAgICAgIGNvbXBvbmVudCAgICAgPSBtZS5jb21wb25lbnQsXG4gICAgICAgICAgICBoZWFkZXJUb29sYmFyID0gbWUuZ2V0UmVmZXJlbmNlKCdoZWFkZXJUb29sYmFyJyksXG4gICAgICAgICAgICBidXR0b25UZXh0LCBoZWFkZXJDb2xvciwgaWNvbkNscywgc3R5bGUsIHRoZW1lO1xuXG4gICAgICAgIGlmIChidXR0b24udGV4dCA9PT0gJ1RoZW1lIExpZ2h0Jykge1xuICAgICAgICAgICAgYnV0dG9uVGV4dCAgPSAnVGhlbWUgRGFyayc7XG4gICAgICAgICAgICBoZWFkZXJDb2xvciA9ICcjZjJmMmYyJztcbiAgICAgICAgICAgIGljb25DbHMgICAgID0gJ2ZhIGZhLW1vb24nO1xuICAgICAgICAgICAgdGhlbWUgICAgICAgPSAnbmVvLXRoZW1lLWxpZ2h0J1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnV0dG9uVGV4dCAgPSAnVGhlbWUgTGlnaHQnO1xuICAgICAgICAgICAgaGVhZGVyQ29sb3IgPSAnIzMzMzQzZCc7XG4gICAgICAgICAgICBpY29uQ2xzICAgICA9ICdmYSBmYS1zdW4nO1xuICAgICAgICAgICAgdGhlbWUgICAgICAgPSAnbmVvLXRoZW1lLWRhcmsnXG4gICAgICAgIH1cblxuICAgICAgICBjb21wb25lbnQudGhlbWUgPSB0aGVtZTtcblxuICAgICAgICBidXR0b24uc2V0KHtcbiAgICAgICAgICAgIGljb25DbHMsXG4gICAgICAgICAgICB0ZXh0OiBidXR0b25UZXh0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHN0eWxlID0gaGVhZGVyVG9vbGJhci5zdHlsZSB8fCB7fTtcbiAgICAgICAgc3R5bGUuYmFja2dyb3VuZENvbG9yID0gaGVhZGVyQ29sb3I7XG4gICAgICAgIGhlYWRlclRvb2xiYXIuc3R5bGUgPSBzdHlsZVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoTWFpbkNvbnRhaW5lckNvbnRyb2xsZXIpO1xuIiwiaW1wb3J0IE1haW5Db250YWluZXIgZnJvbSAnLi9NYWluQ29udGFpbmVyLm1qcyc7XG5cbmV4cG9ydCBjb25zdCBvblN0YXJ0ID0gKCkgPT4gTmVvLmFwcCh7XG4gICAgbWFpblZpZXc6IE1haW5Db250YWluZXIsXG4gICAgbmFtZSAgICA6ICdOZW8uZXhhbXBsZXMuY2FsZW5kYXIuYmFzaWMnXG59KTtcbiIsImltcG9ydCBCdXR0b24gICAgICAgIGZyb20gJy4uLy4uL2J1dHRvbi9CYXNlLm1qcyc7XG5pbXBvcnQgQ2FsZW5kYXJTdG9yZSBmcm9tICcuLi9zdG9yZS9DYWxlbmRhcnMubWpzJztcbmltcG9ydCBDb2xvckZpZWxkICAgIGZyb20gJy4uLy4uL2Zvcm0vZmllbGQvQ29sb3IubWpzJztcbmltcG9ydCBEYXRlVXRpbCAgICAgIGZyb20gJy4uLy4uL3V0aWwvRGF0ZS5tanMnO1xuaW1wb3J0IEZvcm1Db250YWluZXIgZnJvbSAnLi4vLi4vZm9ybS9Db250YWluZXIubWpzJztcbmltcG9ydCBUZXh0RmllbGQgICAgIGZyb20gJy4uLy4uL2Zvcm0vZmllbGQvVGV4dC5tanMnO1xuaW1wb3J0IFRpbWVGaWVsZCAgICAgZnJvbSAnLi4vLi4vZm9ybS9maWVsZC9UaW1lLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jYWxlbmRhci52aWV3LkVkaXRFdmVudENvbnRhaW5lclxuICogQGV4dGVuZHMgTmVvLmZvcm0uQ29udGFpbmVyXG4gKi9cbmNsYXNzIEVkaXRFdmVudENvbnRhaW5lciBleHRlbmRzIEZvcm1Db250YWluZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNhbGVuZGFyLnZpZXcuRWRpdEV2ZW50Q29udGFpbmVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY2FsZW5kYXIudmlldy5FZGl0RXZlbnRDb250YWluZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tY2FsZW5kYXItZWRpdC1ldmVudC1jb250YWluZXInXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tY2FsZW5kYXItZWRpdC1ldmVudC1jb250YWluZXInXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gYmluZFxuICAgICAgICAgKi9cbiAgICAgICAgYmluZDoge1xuICAgICAgICAgICAgZW5kVGltZSAgICAgICAgICAgICA6IGRhdGEgPT4gZGF0YS5lbmRUaW1lLFxuICAgICAgICAgICAgaW50bEZvcm1hdF90aW1lICAgICA6IGRhdGEgPT4gZGF0YS50aW1lRm9ybWF0dGVyLFxuICAgICAgICAgICAgbWluaW11bUV2ZW50RHVyYXRpb246IGRhdGEgPT4gZGF0YS5taW5pbXVtRXZlbnREdXJhdGlvbixcbiAgICAgICAgICAgIHN0YXJ0VGltZSAgICAgICAgICAgOiBkYXRhID0+IGRhdGEuc3RhcnRUaW1lXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gY2FsZW5kYXJGaWVsZENvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBjYWxlbmRhckZpZWxkQ29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogT25seSBmdWxsIGhvdXJzIGFyZSB2YWxpZCBmb3Igbm93XG4gICAgICAgICAqIGZvcm1hdDogJ2hoOm1tJ1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGVuZFRpbWVfPScyNDowMCdcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBlbmRUaW1lXzogJzI0OjAwJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBlbmRUaW1lRmllbGRDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZW5kVGltZUZpZWxkQ29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQm91bmQgdG8gdGhlIHN0YXRlIHByb3ZpZGVyLlxuICAgICAgICAgKiBAbWVtYmVyIHtJbnRsLkRhdGVUaW1lRm9ybWF0fG51bGx9IGludGxGb3JtYXRfdGltZT1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGludGxGb3JtYXRfdGltZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jYWxlbmRhci52aWV3LndlZWsuQ29tcG9uZW50fG51bGx9IG93bmVyPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIG93bmVyOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNhbGVuZGFyLm1vZGVsLkV2ZW50fG51bGx9IHJlY29yZF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHJlY29yZF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPbmx5IGZ1bGwgaG91cnMgYXJlIHZhbGlkIGZvciBub3dcbiAgICAgICAgICogZm9ybWF0OiAnaGg6bW0nXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gc3RhcnRUaW1lXz0nMDA6MDAnXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhcnRUaW1lXzogJzAwOjAwJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBzdGFydFRpbWVGaWVsZENvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBzdGFydFRpbWVGaWVsZENvbmZpZzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSB0aXRsZUZpZWxkQ29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHRpdGxlRmllbGRDb25maWc6IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICAvLyBmb2N1cyB0cmFwLCBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9uZW9tanMvbmVvL2lzc3Vlcy8yMzA2XG4gICAgICAgIHRoaXMudmRvbS50YWJJbmRleCA9IC0xXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtb3VudGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIHZhbHVlICYmIHRoaXMuZ2V0RmllbGQoJ3RpdGxlJykudGhlbihmaWVsZCA9PiBmaWVsZC5mb2N1cygpKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcmVjb3JkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TmVvLmNhbGVuZGFyLm1vZGVsLkV2ZW50fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLmNhbGVuZGFyLm1vZGVsLkV2ZW50fSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFJlY29yZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICYmIG9sZFZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgdGltZUZvcm1hdCAgICAgICAgICA9IG1lLmludGxGb3JtYXRfdGltZSxcbiAgICAgICAgICAgICAgICB7Y2FsZW5kYXJJZCwgdGl0bGV9ID0gdmFsdWU7XG5cbiAgICAgICAgICAgIG1lLmdldEZpZWxkKCdlbmRUaW1lJykgIC50aGVuKGZpZWxkID0+IGZpZWxkLm1pblZhbHVlID0gbWUuZ2V0RW5kVGltZU1pblZhbHVlKHZhbHVlKSk7XG4gICAgICAgICAgICBtZS5nZXRGaWVsZCgnc3RhcnRUaW1lJykudGhlbihmaWVsZCA9PiBmaWVsZC5tYXhWYWx1ZSA9IG1lLmdldFN0YXJ0VGltZU1heFZhbHVlKHZhbHVlKSk7XG5cbiAgICAgICAgICAgIG1lLnJlc2V0KHtcbiAgICAgICAgICAgICAgICBjYWxlbmRhcklkLFxuICAgICAgICAgICAgICAgIGVuZFRpbWUgIDogdGltZUZvcm1hdC5mb3JtYXQodmFsdWUuZW5kRGF0ZSksXG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lOiB0aW1lRm9ybWF0LmZvcm1hdCh2YWx1ZS5zdGFydERhdGUpLFxuICAgICAgICAgICAgICAgIHRpdGxlXG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUl0ZW1zKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgY3JlYXRlSXRlbXMoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtyZWNvcmR9ICAgPSBtZSxcbiAgICAgICAgICAgIHRpbWVGb3JtYXQgPSBtZS5pbnRsRm9ybWF0X3RpbWUsXG4gICAgICAgICAgICB0aW1lRmllbGREZWZhdWx0cyA9IHtcbiAgICAgICAgICAgICAgICBtb2R1bGUgICAgICAgICAgICAgIDogVGltZUZpZWxkLFxuICAgICAgICAgICAgICAgIGNsZWFyVG9PcmlnaW5hbFZhbHVlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGZsZXggICAgICAgICAgICAgICAgOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgbGFiZWxQb3NpdGlvbiAgICAgICA6ICdpbmxpbmUnLFxuICAgICAgICAgICAgICAgIGxpc3RlbmVycyAgICAgICAgICAgOiB7Y2hhbmdlOiBtZS5vblRpbWVGaWVsZENoYW5nZSwgc2NvcGU6IG1lfSxcbiAgICAgICAgICAgICAgICBzdGVwU2l6ZSAgICAgICAgICAgIDogMTUgKiA2MCxcbiAgICAgICAgICAgICAgICB3aWR0aCAgICAgICAgICAgICAgIDogJzllbSdcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICAgICAgbWUuaXRlbXMgPSBbe1xuICAgICAgICAgICAgICAgIG1vZHVsZSAgICAgICAgICAgICAgOiBUZXh0RmllbGQsXG4gICAgICAgICAgICAgICAgY2xlYXJUb09yaWdpbmFsVmFsdWU6IHRydWUsXG4gICAgICAgICAgICAgICAgZmxleCAgICAgICAgICAgICAgICA6ICdub25lJyxcbiAgICAgICAgICAgICAgICBsYWJlbFBvc2l0aW9uICAgICAgIDogJ2lubGluZScsXG4gICAgICAgICAgICAgICAgbGFiZWxUZXh0ICAgICAgICAgICA6ICdUaXRsZScsXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzICAgICAgICAgICA6IHtjaGFuZ2U6IG1lLm9uVGl0bGVGaWVsZENoYW5nZSwgc2NvcGU6IG1lfSxcbiAgICAgICAgICAgICAgICBuYW1lICAgICAgICAgICAgICAgIDogJ3RpdGxlJyxcbiAgICAgICAgICAgICAgICByZXF1aXJlZCAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZSAgICAgICAgICAgICAgIDogcmVjb3JkLnRpdGxlLFxuICAgICAgICAgICAgICAgIC4uLm1lLnRpdGxlRmllbGRDb25maWdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUgICAgICAgICAgICAgIDogQ29sb3JGaWVsZCxcbiAgICAgICAgICAgICAgICBjbGVhclRvT3JpZ2luYWxWYWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb2xvckZpZWxkICAgICAgICAgIDogJ2NvbG9yJyxcbiAgICAgICAgICAgICAgICBkaXNwbGF5RmllbGQgICAgICAgIDogJ25hbWUnLFxuICAgICAgICAgICAgICAgIGZsZXggICAgICAgICAgICAgICAgOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgZm9yY2VTZWxlY3Rpb24gICAgICA6IHRydWUsXG4gICAgICAgICAgICAgICAgbGFiZWxQb3NpdGlvbiAgICAgICA6ICdpbmxpbmUnLFxuICAgICAgICAgICAgICAgIGxhYmVsVGV4dCAgICAgICAgICAgOiAnQ2FsZW5kYXInLFxuICAgICAgICAgICAgICAgIGxpc3RlbmVycyAgICAgICAgICAgOiB7Y2hhbmdlOiBtZS5vbkNhbGVuZGFyRmllbGRDaGFuZ2UsIHNjb3BlOiBtZX0sXG4gICAgICAgICAgICAgICAgbmFtZSAgICAgICAgICAgICAgICA6ICdjYWxlbmRhcklkJyxcbiAgICAgICAgICAgICAgICByZXF1aXJlZCAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0cmlnZ2VyQWN0aW9uICAgICAgIDogJ2FsbCcsXG4gICAgICAgICAgICAgICAgdmFsdWUgICAgICAgICAgICAgICA6IHJlY29yZC5jYWxlbmRhcklkLFxuXG4gICAgICAgICAgICAgICAgY29sb3JGb3JtYXR0ZXI6IChzY29wZSxkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGRhdGFbc2NvcGUuY29sb3JGaWVsZF07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSAneWVsbG93Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd2YXIoLS1ldmVudC15ZWxsb3ctYm9yZGVyLWNvbG9yKSc7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYHZhcigtLWV2ZW50LSR7dmFsdWV9LWNvbG9yKWBcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgc3RvcmU6IHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlICA6IENhbGVuZGFyU3RvcmUsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZUlkOiBtZS5zdGF0ZVByb3ZpZGVyLmdldFN0b3JlKCdjYWxlbmRhcnMnKS5pZFxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAuLi5tZS5jYWxlbmRhckZpZWxkQ29uZmlnXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbGFiZWxUZXh0OiAnU3RhcnQgVGltZScsXG4gICAgICAgICAgICAgICAgbWF4VmFsdWUgOiBtZS5nZXRTdGFydFRpbWVNYXhWYWx1ZShyZWNvcmQpLFxuICAgICAgICAgICAgICAgIG1pblZhbHVlIDogbWUuc3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgIG5hbWUgICAgIDogJ3N0YXJ0VGltZScsXG4gICAgICAgICAgICAgICAgdmFsdWUgICAgOiB0aW1lRm9ybWF0LmZvcm1hdChyZWNvcmQuc3RhcnREYXRlKSxcbiAgICAgICAgICAgICAgICAuLi50aW1lRmllbGREZWZhdWx0cyxcbiAgICAgICAgICAgICAgICAuLi5tZS5zdGFydFRpbWVGaWVsZENvbmZpZ1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGxhYmVsVGV4dDogJ0VuZCBUaW1lJyxcbiAgICAgICAgICAgICAgICBtYXhWYWx1ZSA6IG1lLmVuZFRpbWUsXG4gICAgICAgICAgICAgICAgbWluVmFsdWUgOiBtZS5nZXRFbmRUaW1lTWluVmFsdWUocmVjb3JkKSxcbiAgICAgICAgICAgICAgICBuYW1lICAgICA6ICdlbmRUaW1lJyxcbiAgICAgICAgICAgICAgICB2YWx1ZSAgICA6IHRpbWVGb3JtYXQuZm9ybWF0KHJlY29yZC5lbmREYXRlKSxcbiAgICAgICAgICAgICAgICAuLi50aW1lRmllbGREZWZhdWx0cyxcbiAgICAgICAgICAgICAgICAuLi5tZS5lbmRUaW1lRmllbGRDb25maWdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUgOiBCdXR0b24sXG4gICAgICAgICAgICAgICAgY2xzICAgIDogWyduZW8tYnV0dG9uJywgJ25lby1yZWQnXSxcbiAgICAgICAgICAgICAgICBoYW5kbGVyOiBtZS5vbkRlbGV0ZUJ1dHRvbkNsaWNrLmJpbmQobWUpLFxuICAgICAgICAgICAgICAgIGljb25DbHM6ICdmYXMgZmEtdHJhc2gtYWx0JyxcbiAgICAgICAgICAgICAgICBzdHlsZSAgOiB7bWFyZ2luVG9wOiAnM2VtJ30sXG4gICAgICAgICAgICAgICAgdGV4dCAgIDogJ0RlbGV0ZSdcbiAgICAgICAgICAgIH1dO1xuXG4gICAgICAgICAgICBzdXBlci5jcmVhdGVJdGVtcygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jYWxlbmRhci5tb2RlbC5FdmVudH0gcmVjb3JkXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRFbmRUaW1lTWluVmFsdWUocmVjb3JkKSB7XG4gICAgICAgIGxldCBkYXRlID0gbmV3IERhdGUocmVjb3JkLnN0YXJ0RGF0ZS52YWx1ZU9mKCkpO1xuXG4gICAgICAgIGRhdGUuc2V0TWludXRlcyhkYXRlLmdldE1pbnV0ZXMoKSArIHRoaXMubWluaW11bUV2ZW50RHVyYXRpb24pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmludGxGb3JtYXRfdGltZS5mb3JtYXQoZGF0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uY2FsZW5kYXIubW9kZWwuRXZlbnR9IHJlY29yZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U3RhcnRUaW1lTWF4VmFsdWUocmVjb3JkKSB7XG4gICAgICAgIGxldCBkYXRlID0gbmV3IERhdGUocmVjb3JkLmVuZERhdGUudmFsdWVPZigpKTtcblxuICAgICAgICBkYXRlLnNldE1pbnV0ZXMoZGF0ZS5nZXRNaW51dGVzKCkgLSB0aGlzLm1pbmltdW1FdmVudER1cmF0aW9uKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5pbnRsRm9ybWF0X3RpbWUuZm9ybWF0KGRhdGUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkNhbGVuZGFyRmllbGRDaGFuZ2UoZGF0YSkge1xuICAgICAgICBpZiAoIU5lby5pc0VtcHR5KGRhdGEudmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLnJlY29yZC5jYWxlbmRhcklkID0gZGF0YS52YWx1ZVtkYXRhLmNvbXBvbmVudC5zdG9yZS5rZXlQcm9wZXJ0eV1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRvZG86IHdlIGNvdWxkIGFkZCBhIGNvbmZpcm0gZGlhbG9nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkRlbGV0ZUJ1dHRvbkNsaWNrKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5nZXRTdGF0ZVByb3ZpZGVyKCkuZ2V0U3RvcmUoJ2V2ZW50cycpLnJlbW92ZShtZS5yZWNvcmQpO1xuICAgICAgICBtZS51bm1vdW50KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGFzeW5jIG9uRm9jdXNMZWF2ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgLy8gd2UgbmVlZCBhIHNob3J0IGRlbGF5LCBzaW5jZSBhIFRpbWVGaWVsZCBwaWNrZXIgY291bGQgYmUgb3BlblxuICAgICAgICBhd2FpdCBtZS50aW1lb3V0KDEwMCk7XG5cbiAgICAgICAgbWUubW91bnRlZCAmJiBtZS51bm1vdW50KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uVGltZUZpZWxkQ2hhbmdlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICBuYW1lICAgPSBkYXRhLmNvbXBvbmVudC5uYW1lLFxuICAgICAgICAgICAgZmllbGQgID0gbmFtZSA9PT0gJ2VuZFRpbWUnID8gJ2VuZERhdGUnIDogJ3N0YXJ0RGF0ZScsXG4gICAgICAgICAgICByZWNvcmQgPSBtZS5yZWNvcmQsXG4gICAgICAgICAgICBkYXRlICAgPSBEYXRlVXRpbC5jbG9uZShtZS5yZWNvcmRbZmllbGRdKSxcbiAgICAgICAgICAgIHZhbHVlICA9IGRhdGEudmFsdWUuc3BsaXQoJzonKS5tYXAoZSA9PiBOdW1iZXIoZSkpO1xuXG4gICAgICAgIGRhdGUuc2V0SG91cnModmFsdWVbMF0pO1xuICAgICAgICBkYXRlLnNldE1pbnV0ZXModmFsdWVbMV0pO1xuXG4gICAgICAgIHJlY29yZFtmaWVsZF0gPSBkYXRlO1xuXG4gICAgICAgIGlmIChuYW1lID09PSAnZW5kVGltZScpIHtcbiAgICAgICAgICAgIG1lLmdldEZpZWxkKCdzdGFydFRpbWUnKS50aGVuKGZpZWxkID0+IGZpZWxkLm1heFZhbHVlID0gbWUuZ2V0U3RhcnRUaW1lTWF4VmFsdWUocmVjb3JkKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLmdldEZpZWxkKCdlbmRUaW1lJykgIC50aGVuKGZpZWxkID0+IGZpZWxkLm1pblZhbHVlID0gbWUuZ2V0RW5kVGltZU1pblZhbHVlKHJlY29yZCkpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uVGl0bGVGaWVsZENoYW5nZShkYXRhKSB7XG4gICAgICAgIGlmICghTmVvLmlzRW1wdHkoZGF0YS52YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVjb3JkLnRpdGxlID0gZGF0YS52YWx1ZVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhFZGl0RXZlbnRDb250YWluZXIpO1xuIiwiaW1wb3J0IENhbGVuZGFyc0NvbnRhaW5lciAgICAgICAgIGZyb20gJy4vY2FsZW5kYXJzL0NvbnRhaW5lci5tanMnO1xuaW1wb3J0IENvbnRhaW5lciAgICAgICAgICAgICAgICAgIGZyb20gJy4uLy4uL2NvbnRhaW5lci9CYXNlLm1qcyc7XG5pbXBvcnQgRGF0ZVNlbGVjdG9yICAgICAgICAgICAgICAgZnJvbSAnLi4vLi4vY29tcG9uZW50L0RhdGVTZWxlY3Rvci5tanMnO1xuaW1wb3J0IERhdGVVdGlsICAgICAgICAgICAgICAgICAgIGZyb20gJy4uLy4uL3V0aWwvRGF0ZS5tanMnO1xuaW1wb3J0IEVkaXRDYWxlbmRhckNvbnRhaW5lciAgICAgIGZyb20gJy4vY2FsZW5kYXJzL0VkaXRDb250YWluZXIubWpzJztcbmltcG9ydCBFZGl0RXZlbnRDb250YWluZXIgICAgICAgICBmcm9tICcuL0VkaXRFdmVudENvbnRhaW5lci5tanMnO1xuaW1wb3J0IE1haW5Db250YWluZXJTdGF0ZVByb3ZpZGVyIGZyb20gJy4vTWFpbkNvbnRhaW5lclN0YXRlUHJvdmlkZXIubWpzJztcbmltcG9ydCBUb29sYmFyICAgICAgICAgICAgICAgICAgICBmcm9tICcuLi8uLi90b29sYmFyL0Jhc2UubWpzJztcblxuY29uc3QgdG9kYXlEYXRlID0gbmV3IERhdGUoKTtcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNhbGVuZGFyLnZpZXcuTWFpbkNvbnRhaW5lclxuICogQGV4dGVuZHMgTmVvLmNvbnRhaW5lci5CYXNlXG4gKi9cbmNsYXNzIE1haW5Db250YWluZXIgZXh0ZW5kcyBDb250YWluZXIge1xuICAgIC8qKlxuICAgICAqIFZhbGlkIGVudHJpZXMgZm9yIHRoZSB2aWV3cyBjb25maWdcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gdmFsaWRWaWV3cz1bJ2RheScsJ3dlZWsnLCdtb250aCcsJ3llYXInXVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgdmFsaWRWaWV3cyA9IFsnZGF5JywgJ3dlZWsnLCAnbW9udGgnLCAneWVhciddXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jYWxlbmRhci52aWV3Lk1haW5Db250YWluZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jYWxlbmRhci52aWV3Lk1haW5Db250YWluZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nY2FsZW5kYXItbWFpbmNvbnRhaW5lcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdjYWxlbmRhci1tYWluY29udGFpbmVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIHZpZXcuIE11c3QgYmUgYSB2YWx1ZSBpbmNsdWRlZCBpbnNpZGUgdGhlIHZpZXdzIGNvbmZpZy5cbiAgICAgICAgICogdmFsaWQgdmFsdWVzOiAnZGF5JywgJ3dlZWsnLCAnbW9udGgnLCAneWVhcidcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBhY3RpdmVWaWV3Xz0nd2VlaydcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBhY3RpdmVWaWV3XzogJ3dlZWsnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tY2FsZW5kYXItbWFpbmNvbnRhaW5lcicsJ25lby1jb250YWluZXInXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tY2FsZW5kYXItbWFpbmNvbnRhaW5lcicsICduZW8tY29udGFpbmVyJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTY2FsZSB0aGUgY2FsZW5kYXIgd2l0aCB1c2luZyBzIGRpZmZlcmVudCBiYXNlIGZvbnQtc2l6ZVxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gYmFzZUZvbnRTaXplXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUZvbnRTaXplXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jYWxlbmRhci52aWV3LkNvbnRhaW5lcnxudWxsfSBjYWxlbmRhcnNDb250YWluZXI9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgY2FsZW5kYXJzQ29udGFpbmVyOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGNhbGVuZGFyU3RvcmVDb25maWdfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBjYWxlbmRhclN0b3JlQ29uZmlnXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBjb2xvclN0b3JlQ29uZmlnXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgY29sb3JTdG9yZUNvbmZpZ186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29tcG9uZW50LkRhdGVTZWxlY3RvcnxudWxsfSBkYXRlU2VsZWN0b3I9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZGF0ZVNlbGVjdG9yOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGRhdGVTZWxlY3RvckNvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkYXRlU2VsZWN0b3JDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY2FsZW5kYXIudmlldy5EYXlDb21wb25lbnR8bnVsbH0gZGF5Q29tcG9uZW50PW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRheUNvbXBvbmVudDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBkYXlDb21wb25lbnRDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZGF5Q29tcG9uZW50Q29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVhZCBvbmx5XG4gICAgICAgICAqIEBtZW1iZXIge05lby5jYWxlbmRhci52aWV3LmNhbGVuZGFycy5FZGl0Q29udGFpbmVyfG51bGx9IGVkaXRDYWxlbmRhckNvbnRhaW5lcl89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGVkaXRDYWxlbmRhckNvbnRhaW5lcl86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gZWRpdENhbGVuZGFyQ29udGFpbmVyQ29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGVkaXRDYWxlbmRhckNvbnRhaW5lckNvbmZpZzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlYWQgb25seVxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY2FsZW5kYXIudmlldy5FZGl0RXZlbnRDb250YWluZXJ8bnVsbH0gZWRpdEV2ZW50Q29udGFpbmVyXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgZWRpdEV2ZW50Q29udGFpbmVyXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBlZGl0RXZlbnRDb250YWluZXJDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZWRpdEV2ZW50Q29udGFpbmVyQ29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGV2ZW50U3RvcmVDb25maWdfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBldmVudFN0b3JlQ29uZmlnXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gbGF5b3V0PXtudHlwZTondmJveCcsYWxpZ246J3N0cmV0Y2gnfVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbGF5b3V0OiB7bnR5cGU6ICd2Ym94JywgYWxpZ246ICdzdHJldGNoJ30sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY2FsZW5kYXIudmlldy5Db21wb25lbnR8bnVsbH0gbW9udGhDb21wb25lbnQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgbW9udGhDb21wb25lbnQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gbW9udGhDb21wb25lbnRDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgbW9udGhDb21wb25lbnRDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIHRvIG9ubHkga2VlcCB0aGUgYWN0aXZlIHZpZXcgaW5zaWRlIHRoZSBET01cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gcmVtb3ZlSW5hY3RpdmVDYXJkcz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmVJbmFjdGl2ZUNhcmRzOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IHNldHRpbmdzQ29udGFpbmVyQ29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHNldHRpbmdzQ29udGFpbmVyQ29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBzZXR0aW5nc0NvbnRhaW5lcldpZHRoPTMwMFxuICAgICAgICAgKi9cbiAgICAgICAgc2V0dGluZ3NDb250YWluZXJXaWR0aDogMzEwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2V0dGluZ3NFeHBhbmRlZF89ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzZXR0aW5nc0V4cGFuZGVkXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaWRlQmFyRXhwYW5kZWRfPXRydWVcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzaWRlQmFyRXhwYW5kZWRfOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBzaWRlQmFyV2lkdGg9MjIwXG4gICAgICAgICAqL1xuICAgICAgICBzaWRlQmFyV2lkdGg6IDIyMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jYWxlbmRhci52aWV3Lk1haW5Db250YWluZXJTdGF0ZVByb3ZpZGVyfSBzdGF0ZVByb3ZpZGVyPU1haW5Db250YWluZXJTdGF0ZVByb3ZpZGVyXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGVQcm92aWRlcjogTWFpbkNvbnRhaW5lclN0YXRlUHJvdmlkZXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB1c2VTZXR0aW5nc0NvbnRhaW5lcl89dHJ1ZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHVzZVNldHRpbmdzQ29udGFpbmVyXzogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFueSBjb21iaW5hdGlvbiBhbmQgb3JkZXIgb2YgJ2RheScsICd3ZWVrJywgJ21vbnRoJywgJ3llYXInXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSB2aWV3c189WydkYXknLCd3ZWVrJywnbW9udGgnLCd5ZWFyJ11cbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB2aWV3c186IFsnZGF5JywgJ3dlZWsnLCAnbW9udGgnLCAneWVhciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNhbGVuZGFyLnZpZXcuQ29tcG9uZW50fG51bGx9IHdlZWtDb21wb25lbnQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgd2Vla0NvbXBvbmVudDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSB3ZWVrQ29tcG9uZW50Q29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHdlZWtDb21wb25lbnRDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY2FsZW5kYXIudmlldy5ZZWFyQ29tcG9uZW50fG51bGx9IHllYXJDb21wb25lbnQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgeWVhckNvbXBvbmVudDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSB5ZWFyQ29tcG9uZW50Q29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHllYXJDb21wb25lbnRDb25maWc6IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmNyZWF0ZUl0ZW1zQ29udGVudCgpO1xuICAgICAgICAhbWUuc2lkZUJhckV4cGFuZGVkICYmIG1lLmFmdGVyU2V0U2lkZUJhckV4cGFuZGVkKGZhbHNlLCB0cnVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgYWN0aXZlVmlldyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRBY3RpdmVWaWV3KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAgICAgbWUuaXRlbXNbMV0uaXRlbXNbMV0ubGF5b3V0LmFjdGl2ZUluZGV4ID0gbWUudmlld3MuaW5kZXhPZih2YWx1ZSk7XG5cbiAgICAgICAgICAgIG1lLml0ZW1zWzBdLml0ZW1zWzFdLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0udG9nZ2xlR3JvdXAgPT09ICdtYWluVmlld3MnKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0ucHJlc3NlZCA9IGl0ZW0udmFsdWUgPT09IHZhbHVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGJhc2VGb250U2l6ZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRCYXNlRm9udFNpemUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgc3R5bGUgPSB0aGlzLnN0eWxlIHx8IHt9O1xuXG4gICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHN0eWxlLmZvbnRTaXplXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0eWxlLmZvbnRTaXplID0gYCR7dmFsdWV9cHhgXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc3R5bGUgPSBzdHlsZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzZXR0aW5nc0V4cGFuZGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U2V0dGluZ3NFeHBhbmRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKE5lby5pc0Jvb2xlYW4ob2xkVmFsdWUpKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHNldHRpbmdzQ29udGFpbmVyID0gbWUuaXRlbXNbMV0uaXRlbXNbMl07XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0NvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0NvbnRhaW5lci5leHBhbmQoKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmNyZWF0ZVNldHRpbmdzQ29udGFpbmVyKHRydWUpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2hvcnQgZGVsYXkgdG8gZW5zdXJlIHRoZSB2bm9kZSBhbHJlYWR5IGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUudGltZW91dCg1MCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUuaXRlbXNbMV0uaXRlbXNbMl0uZXhwYW5kKClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5nc0NvbnRhaW5lci5jb2xsYXBzZShtZS5zZXR0aW5nc0NvbnRhaW5lcldpZHRoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzaWRlQmFyRXhwYW5kZWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTaWRlQmFyRXhwYW5kZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgc2lkZUJhciA9IG1lLml0ZW1zWzFdLml0ZW1zWzBdLFxuICAgICAgICAgICAgICAgIHN0eWxlICAgPSBzaWRlQmFyLnN0eWxlIHx8IHt9O1xuXG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBtZS51cGRhdGVEZXB0aCA9IC0xO1xuXG4gICAgICAgICAgICAgICAgLy8gdG9kbzogdXBkYXRlcyBjb2xsaWRpbmcgd2l0aCBwYXJlbnQgdXBkYXRlcyBuZWVkIHRvIHBhc3MgdGhlIHVwZGF0ZSBkZXB0aCBmb3IgdGhlIG5leHQgcGFyZW50IHVwZGF0ZSBjeWNsZVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBzaWRlQmFyLnZkb20ucmVtb3ZlRG9tO1xuXG4gICAgICAgICAgICAgICAgbWUucHJvbWlzZVVwZGF0ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzaWRlQmFyLm1vdW50ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIG1lLnRpbWVvdXQoNTApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUubWFyZ2luTGVmdCA9ICcwcHgnO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lkZUJhci5zdHlsZSA9IHN0eWxlXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3R5bGUubWFyZ2luTGVmdCAgICA9IGAtJHttZS5zaWRlQmFyV2lkdGh9cHhgO1xuICAgICAgICAgICAgICAgIHNpZGVCYXIuX3N0eWxlICAgICAgPSBzdHlsZTsgLy8gc2lsZW50IHVwZGF0ZVxuICAgICAgICAgICAgICAgIHNpZGVCYXIuX3Zkb20uc3R5bGUgPSBzdHlsZTsgLy8gc2lsZW50IHVwZGF0ZVxuXG4gICAgICAgICAgICAgICAgc2lkZUJhci5wcm9taXNlVXBkYXRlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnRpbWVvdXQoNDAwKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZGVCYXIudmRvbS5yZW1vdmVEb20gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lkZUJhci51cGRhdGUoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2lkZUJhci5tb3VudGVkID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB0aGVtZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRUaGVtZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRUaGVtZSh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLl9lZGl0Q2FsZW5kYXJDb250YWluZXIpIHtcbiAgICAgICAgICAgIG1lLl9lZGl0Q2FsZW5kYXJDb250YWluZXIudGhlbWUgPSB2YWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lLl9lZGl0RXZlbnRDb250YWluZXIpIHtcbiAgICAgICAgICAgIG1lLl9lZGl0RXZlbnRDb250YWluZXIudGhlbWUgPSB2YWx1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB1c2VTZXR0aW5nc0NvbnRhaW5lciBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFVzZVNldHRpbmdzQ29udGFpbmVyKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgbWUuc2V0dGluZ3NFeHBhbmRlZCAmJiBtZS5jcmVhdGVTZXR0aW5nc0NvbnRhaW5lcihmYWxzZSk7XG5cbiAgICAgICAgICAgIC8vIHdlIG5lZWQgYSBzaG9ydCBkZWxheSB0byBlbnN1cmUgdGhlIGl0ZW1zIGFscmVhZHkgZ290IGNyZWF0ZWRcbiAgICAgICAgICAgIG1lLnRpbWVvdXQoMTApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1lLml0ZW1zWzBdLml0ZW1zWzFdLmFkZCh7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXI6IG1lLnRvZ2dsZVNldHRpbmdzLmJpbmQobWUpLFxuICAgICAgICAgICAgICAgICAgICBpY29uQ2xzOiAnZmEgZmEtY29nJyxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUgIDoge21hcmdpbkxlZnQ6ICcxMHB4J31cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIGlmICghdmFsdWUgJiYgb2xkVmFsdWUpIHtcbiAgICAgICAgICAgIC8vIHdlIG9ubHkgbmVlZCB0aGlzIGxvZ2ljIGluIGNhc2Ugd2UgZHluYW1pY2FsbHkgY2hhbmdlIHRoZSBjb25maWcgZnJvbSB0cnVlIHRvIGZhbHNlXG4gICAgICAgICAgICBtZS5pdGVtc1sxXSAgICAgICAgIC5yZW1vdmVMYXN0KCk7XG4gICAgICAgICAgICBtZS5pdGVtc1swXS5pdGVtc1sxXS5yZW1vdmVMYXN0KClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdHJpZ2dlcmVkIGJlZm9yZSBnZXR0aW5nIHRoZSB2YWx1ZSBvZiB0aGUgZWRpdENhbGVuZGFyQ29udGFpbmVyIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7TmVvLmNhbGVuZGFyLnZpZXcuY2FsZW5kYXJzLkVkaXRDb250YWluZXJ8bnVsbH0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNhbGVuZGFyLnZpZXcuY2FsZW5kYXJzLkVkaXRDb250YWluZXJ9XG4gICAgICovXG4gICAgYmVmb3JlR2V0RWRpdENhbGVuZGFyQ29udGFpbmVyKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIG1lLl9lZGl0Q2FsZW5kYXJDb250YWluZXIgPSB2YWx1ZSA9IE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIG1vZHVsZSAgICAgICA6IEVkaXRDYWxlbmRhckNvbnRhaW5lcixcbiAgICAgICAgICAgICAgICBhcHBOYW1lICAgICAgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgICAgIG93bmVyICAgICAgICA6IG1lLFxuICAgICAgICAgICAgICAgIHN0YXRlUHJvdmlkZXI6IHtwYXJlbnQ6IG1lLmdldFN0YXRlUHJvdmlkZXIoKX0sXG4gICAgICAgICAgICAgICAgdGhlbWUgICAgICAgIDogbWUudGhlbWUsXG4gICAgICAgICAgICAgICAgd2lkdGggICAgICAgIDogMjUwLFxuICAgICAgICAgICAgICAgIHdpbmRvd0lkICAgICA6IG1lLndpbmRvd0lkLFxuICAgICAgICAgICAgICAgIC4uLm1lLmVkaXRDYWxlbmRhckNvbnRhaW5lckNvbmZpZ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdHJpZ2dlcmVkIGJlZm9yZSBnZXR0aW5nIHRoZSB2YWx1ZSBvZiB0aGUgZWRpdEV2ZW50Q29udGFpbmVyIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7TmVvLmNhbGVuZGFyLnZpZXcuRWRpdEV2ZW50Q29udGFpbmVyfG51bGx9IHZhbHVlXG4gICAgICogQHJldHVybnMge05lby5jYWxlbmRhci52aWV3LkVkaXRFdmVudENvbnRhaW5lcn1cbiAgICAgKi9cbiAgICBiZWZvcmVHZXRFZGl0RXZlbnRDb250YWluZXIodmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAgICAgbWUuX2VkaXRFdmVudENvbnRhaW5lciA9IHZhbHVlID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgbW9kdWxlICAgICAgIDogRWRpdEV2ZW50Q29udGFpbmVyLFxuICAgICAgICAgICAgICAgIGFwcE5hbWUgICAgICA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICAgICAgb3duZXIgICAgICAgIDogbWUsXG4gICAgICAgICAgICAgICAgc3RhdGVQcm92aWRlcjoge3BhcmVudDogbWUuZ2V0U3RhdGVQcm92aWRlcigpfSxcbiAgICAgICAgICAgICAgICB0aGVtZSAgICAgICAgOiBtZS50aGVtZSxcbiAgICAgICAgICAgICAgICB3aWR0aCAgICAgICAgOiAyNTAsXG4gICAgICAgICAgICAgICAgd2luZG93SWQgICAgIDogbWUud2luZG93SWQsXG4gICAgICAgICAgICAgICAgLi4ubWUuZWRpdEV2ZW50Q29udGFpbmVyQ29uZmlnXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgYWN0aXZlVmlldyBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRBY3RpdmVWaWV3KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnYWN0aXZlVmlldycsICd2YWxpZFZpZXdzJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSB2aWV3cyBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0Vmlld3ModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCB2YWxpZFZpZXdzID0gdGhpcy5nZXRTdGF0aWNDb25maWcoJ3ZhbGlkVmlld3MnKTtcblxuICAgICAgICB2YWx1ZS5mb3JFYWNoKHZpZXcgPT4ge1xuICAgICAgICAgICAgaWYgKCF2YWxpZFZpZXdzLmluY2x1ZGVzKHZpZXcpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcih2aWV3LCAnaXMgbm90IGEgdmFsaWQgZW50cnkgZm9yIHZpZXdzLiBTdGljayB0bzonLCB2YWxpZFZpZXdzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2xkVmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZpZXdcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY2hhbmdlQWN0aXZlVmlldyh2aWV3KSB7XG4gICAgICAgIHRoaXMuYWN0aXZlVmlldyA9IHZpZXdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0W119XG4gICAgICovXG4gICAgY3JlYXRlSGVhZGVySXRlbXMoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgICBtb2R1bGU6IFRvb2xiYXIsXG4gICAgICAgICAgICBjbHMgICA6IFsnbmVvLWNhbGVuZGFyLWhlYWRlci10b29sYmFyJywgJ25lby1sZWZ0JywgJ25lby10b29sYmFyJ10sXG4gICAgICAgICAgICB3aWR0aCA6IG1lLnNpZGVCYXJXaWR0aCxcbiAgICAgICAgICAgIGl0ZW1zIDogW3tcbiAgICAgICAgICAgICAgICBoYW5kbGVyOiBtZS50b2dnbGVTaWRlYmFyLmJpbmQobWUpLFxuICAgICAgICAgICAgICAgIGljb25DbHM6ICdmYSBmYS1iYXJzJ1xuICAgICAgICAgICAgfSwgJy0+Jywge1xuICAgICAgICAgICAgICAgIGhhbmRsZXI6IG1lLm9uUHJldmlvdXNJbnRlcnZhbEJ1dHRvbkNsaWNrLmJpbmQobWUpLFxuICAgICAgICAgICAgICAgIGljb25DbHM6ICdmYSBmYS1jaGV2cm9uLWxlZnQnLFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGhhbmRsZXI6IG1lLm9uVG9kYXlCdXR0b25DbGljay5iaW5kKG1lKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQgOiAyNCxcbiAgICAgICAgICAgICAgICB0ZXh0ICAgOiAnVG9kYXknXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcjogbWUub25OZXh0SW50ZXJ2YWxCdXR0b25DbGljay5iaW5kKG1lKSxcbiAgICAgICAgICAgICAgICBpY29uQ2xzOiAnZmEgZmEtY2hldnJvbi1yaWdodCdcbiAgICAgICAgICAgIH1dXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1vZHVsZTogVG9vbGJhcixcbiAgICAgICAgICAgIGNscyAgIDogWyduZW8tY2FsZW5kYXItaGVhZGVyLXRvb2xiYXInLCAnbmVvLXRvb2xiYXInXSxcbiAgICAgICAgICAgIGl0ZW1zIDogWyctPicsIC4uLm1lLmNyZWF0ZVZpZXdIZWFkZXJCdXR0b25zKCldXG4gICAgICAgIH1dXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNyZWF0ZUl0ZW1zQ29udGVudCgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5jYWxlbmRhcnNDb250YWluZXIgPSBOZW8uY3JlYXRlKHtcbiAgICAgICAgICAgIG1vZHVsZSAgOiBDYWxlbmRhcnNDb250YWluZXIsXG4gICAgICAgICAgICBmbGV4ICAgIDogMSxcbiAgICAgICAgICAgIHBhcmVudElkOiBtZS5pZCwgLy8gd2UgbmVlZCB0aGUgcGFyZW50SWQgdG8gYWNjZXNzIHRoZSBtb2RlbCBpbnNpZGUgdGhlIGN0b3JcbiAgICAgICAgICAgIG93bmVyICAgOiBtZVxuICAgICAgICB9KTtcblxuICAgICAgICBtZS5kYXRlU2VsZWN0b3IgPSBOZW8uY3JlYXRlKHtcbiAgICAgICAgICAgIG1vZHVsZSAgIDogRGF0ZVNlbGVjdG9yLFxuICAgICAgICAgICAgYXBwTmFtZSAgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgZmxleCAgICAgOiAnbm9uZScsXG4gICAgICAgICAgICBoZWlnaHQgICA6IG1lLnNpZGVCYXJXaWR0aCxcbiAgICAgICAgICAgIGxpc3RlbmVyczoge2RhdGVDaGFuZ2U6IG1lLm9uRGF0ZVNlbGVjdG9yQ2hhbmdlLCBzY29wZTogbWV9LFxuICAgICAgICAgICAgcGFyZW50SWQgOiBtZS5pZCwgLy8gd2UgbmVlZCB0aGUgcGFyZW50SWQgdG8gYWNjZXNzIHRoZSBtb2RlbCBpbnNpZGUgdGhlIGN0b3JcbiAgICAgICAgICAgIHZhbHVlICAgIDogbnVsbCxcblxuICAgICAgICAgICAgYmluZDoge1xuICAgICAgICAgICAgICAgIGxvY2FsZSAgICAgICAgICAgICAgOiBkYXRhID0+IGRhdGEubG9jYWxlLFxuICAgICAgICAgICAgICAgIHNjcm9sbE5ld1llYXJGcm9tVG9wOiBkYXRhID0+IGRhdGEuc2Nyb2xsTmV3WWVhckZyb21Ub3AsXG4gICAgICAgICAgICAgICAgc2hvd1dlZWtlbmRzICAgICAgICA6IGRhdGEgPT4gZGF0YS5zaG93V2Vla2VuZHMsXG4gICAgICAgICAgICAgICAgdmFsdWUgICAgICAgICAgICAgICA6IGRhdGEgPT4gRGF0ZVV0aWwuY29udmVydFRveXl5eW1tZGQoZGF0YS5jdXJyZW50RGF0ZSksXG4gICAgICAgICAgICAgICAgd2Vla1N0YXJ0RGF5ICAgICAgICA6IGRhdGEgPT4gZGF0YS53ZWVrU3RhcnREYXlcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC4uLm1lLmRhdGVTZWxlY3RvckNvbmZpZ1xuICAgICAgICB9KTtcblxuICAgICAgICBtZS5pdGVtcyA9IFt7XG4gICAgICAgICAgICBtb2R1bGU6IENvbnRhaW5lcixcbiAgICAgICAgICAgIGZsZXggIDogJ25vbmUnLFxuICAgICAgICAgICAgbGF5b3V0OiB7bnR5cGU6ICdoYm94JywgYWxpZ246ICdzdHJldGNoJ30sXG4gICAgICAgICAgICBpdGVtcyA6IG1lLmNyZWF0ZUhlYWRlckl0ZW1zKClcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbW9kdWxlOiBDb250YWluZXIsXG4gICAgICAgICAgICBmbGV4ICA6IDEsXG4gICAgICAgICAgICBsYXlvdXQ6IHtudHlwZTogJ2hib3gnLCBhbGlnbjogJ3N0cmV0Y2gnfSxcbiAgICAgICAgICAgIGl0ZW1zIDogW3tcbiAgICAgICAgICAgICAgICBtb2R1bGUgIDogQ29udGFpbmVyLFxuICAgICAgICAgICAgICAgIGNscyAgICAgOiBbJ25lby1jYWxlbmRhci1zaWRlYmFyJywgJ25lby1jb250YWluZXInXSxcbiAgICAgICAgICAgICAgICBsYXlvdXQgIDoge250eXBlOiAndmJveCcsIGFsaWduOiAnc3RyZXRjaCd9LFxuICAgICAgICAgICAgICAgIG1pbldpZHRoOiBtZS5zaWRlQmFyV2lkdGgsXG4gICAgICAgICAgICAgICAgd2lkdGggICA6IG1lLnNpZGVCYXJXaWR0aCxcbiAgICAgICAgICAgICAgICBpdGVtcyAgIDogW21lLmRhdGVTZWxlY3RvciwgbWUuY2FsZW5kYXJzQ29udGFpbmVyXVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIG1vZHVsZSAgIDogQ29udGFpbmVyLFxuICAgICAgICAgICAgICAgIGZsZXggICAgIDogMSxcbiAgICAgICAgICAgICAgICBpdGVtcyAgICA6IG1lLmNyZWF0ZVZpZXdzKCksXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzOiB7Y2FyZExvYWRlZDogbWUub25DYXJkTG9hZGVkLCBzY29wZTogbWV9LFxuICAgICAgICAgICAgICAgIGxheW91dCAgIDoge1xuICAgICAgICAgICAgICAgICAgICBudHlwZSAgICAgICAgICAgICAgOiAnY2FyZCcsXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZUluZGV4ICAgICAgICA6IG1lLnZpZXdzLmluZGV4T2YobWUuYWN0aXZlVmlldyksXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUluYWN0aXZlQ2FyZHM6IG1lLnJlbW92ZUluYWN0aXZlQ2FyZHNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XVxuICAgICAgICB9XVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY29sbGFwc2VkXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Kj59XG4gICAgICovXG4gICAgY3JlYXRlU2V0dGluZ3NDb250YWluZXIoY29sbGFwc2VkKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIGltcG9ydCgnLi9TZXR0aW5nc0NvbnRhaW5lci5tanMnKS50aGVuKG1vZHVsZSA9PiB7XG4gICAgICAgICAgICBtZS5pdGVtc1sxXS5hZGQoe1xuICAgICAgICAgICAgICAgIG1vZHVsZSAgICAgICAgICAgICA6IG1vZHVsZS5kZWZhdWx0LFxuICAgICAgICAgICAgICAgIGNvbGxhcHNlZCxcbiAgICAgICAgICAgICAgICBtaW5XaWR0aCAgICAgICAgICAgOiBtZS5zZXR0aW5nc0NvbnRhaW5lcldpZHRoLFxuICAgICAgICAgICAgICAgIHJlbW92ZUluYWN0aXZlQ2FyZHM6IG1lLnJlbW92ZUluYWN0aXZlQ2FyZHMsXG4gICAgICAgICAgICAgICAgc3R5bGUgICAgICAgICAgICAgIDoge21hcmdpblJpZ2h0OiAhY29sbGFwc2VkID8gJzAnIDogYC0ke21lLnNldHRpbmdzQ29udGFpbmVyV2lkdGh9cHhgfSxcbiAgICAgICAgICAgICAgICB3aWR0aCAgICAgICAgICAgICAgOiBtZS5zZXR0aW5nc0NvbnRhaW5lcldpZHRoLFxuICAgICAgICAgICAgICAgIC4uLm1lLnNldHRpbmdzQ29udGFpbmVyQ29uZmlnXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3RbXX1cbiAgICAgKi9cbiAgICBjcmVhdGVWaWV3SGVhZGVyQnV0dG9ucygpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGFjdGl2ZUluZGV4ID0gbWUudmlld3MuaW5kZXhPZihtZS5hY3RpdmVWaWV3KSxcbiAgICAgICAgICAgIGJ1dHRvbnMgICAgID0gW107XG5cbiAgICAgICAgbWUudmlld3MuZm9yRWFjaCgodmlldywgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGJ1dHRvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgaGFuZGxlciAgICA6IG1lLmNoYW5nZUFjdGl2ZVZpZXcuYmluZChtZSwgdmlldyksXG4gICAgICAgICAgICAgICAgaGVpZ2h0ICAgICA6IDI0LFxuICAgICAgICAgICAgICAgIHByZXNzZWQgICAgOiBhY3RpdmVJbmRleCA9PT0gaW5kZXgsXG4gICAgICAgICAgICAgICAgdGV4dCAgICAgICA6IE5lby5jYXBpdGFsaXplKHZpZXcpLFxuICAgICAgICAgICAgICAgIHRvZ2dsZUdyb3VwOiAnbWFpblZpZXdzJyxcbiAgICAgICAgICAgICAgICB2YWx1ZSAgICAgIDogdmlld1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGJ1dHRvbnNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlW119XG4gICAgICovXG4gICAgY3JlYXRlVmlld3MoKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICBjYXJkcyA9IFtdLFxuICAgICAgICAgICAgY21wLFxuXG4gICAgICAgIGRlZmF1bHRDb25maWcgPSB7XG4gICAgICAgICAgICBhcHBOYW1lIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgIG93bmVyICAgOiBtZSxcbiAgICAgICAgICAgIHBhcmVudElkOiBtZS5pZFxuICAgICAgICB9LFxuXG4gICAgICAgIG1hcCA9IHtcbiAgICAgICAgICAgIGRheToge1xuICAgICAgICAgICAgICAgIG1vZHVsZTogKCkgPT4gaW1wb3J0KCcuL0RheUNvbXBvbmVudC5tanMnKSxcbiAgICAgICAgICAgICAgICBmbGFnICA6ICdkYXknLFxuICAgICAgICAgICAgICAgIC4uLmRlZmF1bHRDb25maWcsXG4gICAgICAgICAgICAgICAgLi4ubWUuZGF5Q29tcG9uZW50Q29uZmlnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW9udGg6IHtcbiAgICAgICAgICAgICAgICBtb2R1bGU6ICgpID0+IGltcG9ydCgnLi9tb250aC9Db21wb25lbnQubWpzJyksXG4gICAgICAgICAgICAgICAgZmxhZyAgOiAnbW9udGgnLFxuICAgICAgICAgICAgICAgIC4uLmRlZmF1bHRDb25maWcsXG4gICAgICAgICAgICAgICAgLi4ubWUubW9udGhDb21wb25lbnRDb25maWdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3ZWVrOiB7XG4gICAgICAgICAgICAgICAgbW9kdWxlOiAoKSA9PiBpbXBvcnQoJy4vd2Vlay9Db21wb25lbnQubWpzJyksXG4gICAgICAgICAgICAgICAgZmxhZyAgOiAnd2VlaycsXG4gICAgICAgICAgICAgICAgLi4uZGVmYXVsdENvbmZpZyxcbiAgICAgICAgICAgICAgICAuLi5tZS53ZWVrQ29tcG9uZW50Q29uZmlnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeWVhcjoge1xuICAgICAgICAgICAgICAgIG1vZHVsZTogKCkgPT4gaW1wb3J0KCcuL1llYXJDb21wb25lbnQubWpzJyksXG4gICAgICAgICAgICAgICAgZmxhZyAgOiAneWVhcicsXG4gICAgICAgICAgICAgICAgLi4uZGVmYXVsdENvbmZpZyxcbiAgICAgICAgICAgICAgICAuLi5tZS55ZWFyQ29tcG9uZW50Q29uZmlnXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgbWUudmlld3MuZm9yRWFjaCh2aWV3ID0+IHtcbiAgICAgICAgICAgIG1lW2Ake3ZpZXd9Q29tcG9uZW50YF0gPSBjbXAgPSBtYXBbdmlld107XG4gICAgICAgICAgICBjYXJkcy5wdXNoKGNtcCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjYXJkc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICovXG4gICAgb25DYXJkTG9hZGVkKGRhdGEpIHtcbiAgICAgICAgdGhpc1tgJHtkYXRhLml0ZW0uZmxhZ31Db21wb25lbnRgXSA9IGRhdGEuaXRlbTtcblxuICAgICAgICAvLyBmaXJlIHRoZSBldmVudCBvbiB0aGlzIGluc3RhbmNlIGFzIHdlbGwgPT4gc2V0dGluZyB2aWV3cyBjYW4gc3Vic2NyaWJlIHRvIGl0IG1vcmUgZWFzaWx5XG4gICAgICAgIHRoaXMuZmlyZSgnY2FyZExvYWRlZCcsIHtpdGVtOiBkYXRhLml0ZW19KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEub2xkVmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS52YWx1ZVxuICAgICAqL1xuICAgIG9uRGF0ZVNlbGVjdG9yQ2hhbmdlKHt2YWx1ZX0pIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSgnY3VycmVudERhdGUnLCB2YWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqL1xuICAgIG9uTmV4dEludGVydmFsQnV0dG9uQ2xpY2soZGF0YSkge1xuICAgICAgICB0aGlzLnN3aXRjaEludGVydmFsKDEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKi9cbiAgICBvblByZXZpb3VzSW50ZXJ2YWxCdXR0b25DbGljayhkYXRhKSB7XG4gICAgICAgIHRoaXMuc3dpdGNoSW50ZXJ2YWwoLTEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKi9cbiAgICBvblRvZGF5QnV0dG9uQ2xpY2soZGF0YSkge1xuICAgICAgICB0aGlzLnN0YXRlUHJvdmlkZXIuc2V0RGF0YSh7XG4gICAgICAgICAgICBjdXJyZW50RGF0ZTogdG9kYXlEYXRlXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRvZ2dsZVNldHRpbmdzKCkge1xuICAgICAgICB0aGlzLnNldHRpbmdzRXhwYW5kZWQgPSAhdGhpcy5zZXR0aW5nc0V4cGFuZGVkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRvZ2dsZVNpZGViYXIoKSB7XG4gICAgICAgIHRoaXMuc2lkZUJhckV4cGFuZGVkID0gIXRoaXMuc2lkZUJhckV4cGFuZGVkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG11bHRpcGxpZXJcbiAgICAgKi9cbiAgICBzd2l0Y2hJbnRlcnZhbChtdWx0aXBsaWVyKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjdXJyZW50RGF0ZX0gPSBtZS5kYXRhLFxuXG4gICAgICAgIG1hcCA9IHtcbiAgICAgICAgICAgIGRheSAgOiAoKSA9PiB7Y3VycmVudERhdGUuc2V0RGF0ZSggICAgY3VycmVudERhdGUuZ2V0RGF0ZSgpICAgICArIG11bHRpcGxpZXIpfSxcbiAgICAgICAgICAgIG1vbnRoOiAoKSA9PiB7Y3VycmVudERhdGUuc2V0TW9udGgoICAgY3VycmVudERhdGUuZ2V0TW9udGgoKSAgICArIG11bHRpcGxpZXIpfSxcbiAgICAgICAgICAgIHdlZWsgOiAoKSA9PiB7Y3VycmVudERhdGUuc2V0RGF0ZSggICAgY3VycmVudERhdGUuZ2V0RGF0ZSgpICsgNyAqIG11bHRpcGxpZXIpfSxcbiAgICAgICAgICAgIHllYXIgOiAoKSA9PiB7Y3VycmVudERhdGUuc2V0RnVsbFllYXIoY3VycmVudERhdGUuZ2V0RnVsbFllYXIoKSArIG11bHRpcGxpZXIpfVxuICAgICAgICB9O1xuXG4gICAgICAgIG1hcFttZS5hY3RpdmVWaWV3XSgpO1xuXG4gICAgICAgIG1lLnN0YXRlUHJvdmlkZXIuc2V0RGF0YSh7Y3VycmVudERhdGV9KVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoTWFpbkNvbnRhaW5lcik7XG4iLCJpbXBvcnQgTGlzdCBmcm9tICcuLi8uLi8uLi9saXN0L0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNhbGVuZGFyLnZpZXcuY2FsZW5kYXJzLkNvbG9yc0xpc3RcbiAqIEBleHRlbmRzIE5lby5saXN0LkJhc2VcbiAqL1xuY2xhc3MgQ29sb3JzTGlzdCBleHRlbmRzIExpc3Qge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNhbGVuZGFyLnZpZXcuY2FsZW5kYXJzLkNvbG9yc0xpc3QnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jYWxlbmRhci52aWV3LmNhbGVuZGFycy5Db2xvcnNMaXN0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWNhbGVuZGFycy1jb2xvcnMtbGlzdCcsJ25lby1saXN0J11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWNhbGVuZGFycy1jb2xvcnMtbGlzdCcsICduZW8tbGlzdCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBiaW5kXG4gICAgICAgICAqL1xuICAgICAgICBiaW5kOiB7XG4gICAgICAgICAgICBzdG9yZTogJ3N0b3Jlcy5jb2xvcnMnXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhpcyB0byB0cnVlIGluIGNhc2UgYSBrZXlib2FyZCBuYXZpZ2F0aW9uIHNob3VsZCBpbW1lZGlhdGVseSBzZWxlY3QgdGhlIGZvY3Vzc2VkIGl0ZW1cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2VsZWN0T25Gb2N1cz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBzZWxlY3RPbkZvY3VzOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gdXNlV3JhcHBlck5vZGU9ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB1c2VXcmFwcGVyTm9kZTogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGlzdCBnZXRzIHVzZWQgYXMgYSBmb3JtIGZpZWxkLCBzbyB3ZSBhcmUgYWRqdXN0aW5nIHRoZSBzZWxlY3Rpb24gYmFzZWQgb24gdGhpcyBjb25maWdcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB2YWx1ZV89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZGVkIGEgdGFiSW5kZXggdG8gZW5hYmxlIHRhYmJpbmcgdGhyb3VnaCB0aGUgZm9ybVxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IF92ZG9tPXt0YWc6J3VsJyxjbjpbXSx0YWJJbmRleDonMCd9XG4gICAgICAgICAqL1xuICAgICAgICBfdmRvbTpcbiAgICAgICAge3RhZzogJ3VsJywgY246IFtdLCB0YWJJbmRleDogJzAnfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdmFsdWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFZhbHVlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgcmVjb3JkO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiBvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFtZS5kaXNhYmxlU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICByZWNvcmQgPSBtZS5zdG9yZS5maW5kKCduYW1lJywgdmFsdWUpWzBdO1xuICAgICAgICAgICAgbWUuc2VsZWN0aW9uTW9kZWw/LnNlbGVjdChtZS5nZXRJdGVtSWQocmVjb3JkW21lLmdldEtleVByb3BlcnR5KCldKSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGZvciBjdXN0b20gcmVuZGVyZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8T2JqZWN0W118U3RyaW5nfSBFaXRoZXIgYSBjb25maWcgb2JqZWN0IHRvIGFzc2lnbiB0byB0aGUgaXRlbSwgYSB2ZG9tIGNuIGFycmF5IG9yIGEgc3RyaW5nLlxuICAgICAqL1xuICAgIGNyZWF0ZUl0ZW1Db250ZW50KHJlY29yZCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHtzdHlsZToge1xuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBgdmFyKC0tZXZlbnQtJHtyZWNvcmQubmFtZX0tY29sb3IpYCxcbiAgICAgICAgICAgIGNvbG9yICAgICAgICAgIDogYHZhcigtLWV2ZW50LSR7cmVjb3JkLm5hbWV9LWNvbG9yKWAgLy8gbmVlZGVkIGZvciB0aGUgYm94LXNoYWRvdyAoQ1NTIGN1cnJlbnRDb2xvcilcbiAgICAgICAgfX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldFZkb21Sb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZG9tXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRWbm9kZVJvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZub2RlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNvbnN0cnVjdGVkKCkge1xuICAgICAgICBzdXBlci5vbkNvbnN0cnVjdGVkKCk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3ZhbHVlfSA9IG1lO1xuXG4gICAgICAgIHZhbHVlICYmIG1lLmFmdGVyU2V0VmFsdWUodmFsdWUsIG51bGwpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0cmlnZ2VyZWQgZnJvbSBzZWxlY3Rpb24uTW9kZWw6IHNlbGVjdCgpXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gaXRlbXNcbiAgICAgKi9cbiAgICBvblNlbGVjdChpdGVtcykge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgcmVjb3JkSWQgPSBtZS5nZXRJdGVtUmVjb3JkSWQoaXRlbXNbMF0pO1xuXG4gICAgICAgIG1lLmZpcmUoJ2NoYW5nZScsIHtcbiAgICAgICAgICAgIHJlY29yZDogbWUuc3RvcmUuZ2V0KHJlY29yZElkKVxuICAgICAgICB9KVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ29sb3JzTGlzdCk7XG4iLCJpbXBvcnQgQmFzZUNvbnRhaW5lciBmcm9tICcuLi8uLi8uLi9jb250YWluZXIvQmFzZS5tanMnO1xuaW1wb3J0IExpc3QgICAgICAgICAgZnJvbSAnLi9MaXN0Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jYWxlbmRhci52aWV3LmNhbGVuZGFycy5Db250YWluZXJcbiAqIEBleHRlbmRzIE5lby5jb250YWluZXIuQmFzZVxuICovXG5jbGFzcyBDb250YWluZXIgZXh0ZW5kcyBCYXNlQ29udGFpbmVyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jYWxlbmRhci52aWV3LmNhbGVuZGFycy5Db250YWluZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jYWxlbmRhci52aWV3LmNhbGVuZGFycy5Db250YWluZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tY2FsZW5kYXItY2FsZW5kYXJzY29udGFpbmVyJywnbmVvLWNvbnRhaW5lciddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1jYWxlbmRhci1jYWxlbmRhcnNjb250YWluZXInLCAnbmVvLWNvbnRhaW5lciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBiaW5kXG4gICAgICAgICAqL1xuICAgICAgICBiaW5kOiB7XG4gICAgICAgICAgICBjYWxlbmRhclN0b3JlOiAnc3RvcmVzLmNhbGVuZGFycydcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jYWxlbmRhci5zdG9yZS5DYWxlbmRhcnN8bnVsbH0gY2FsZW5kYXJTdG9yZV89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGNhbGVuZGFyU3RvcmU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gaXRlbXNcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1zOiBbe1xuICAgICAgICAgICAgbW9kdWxlOiBMaXN0LFxuICAgICAgICAgICAgb3duZXIgOiAnQGNvbmZpZzpvd25lcicgLy8gcGFzc2luZyB0aGUgb3duZXIgY29uZmlnIGRvd253YXJkc1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBudHlwZSAgICAgICA6ICdidXR0b24nLFxuICAgICAgICAgICAgY2xzICAgICAgICAgOiBbJ25lby1hZGQtY2FsZW5kYXItYnV0dG9uJ10sXG4gICAgICAgICAgICBmbGV4ICAgICAgICA6ICdub25lJyxcbiAgICAgICAgICAgIGhhbmRsZXIgICAgIDogJ29uQWRkQ2FsZW5kYXJCdXR0b25DbGljaycsXG4gICAgICAgICAgICBoYW5kbGVyU2NvcGU6ICd0aGlzJyxcbiAgICAgICAgICAgIHN0eWxlICAgICAgIDoge21hcmdpblRvcDogJ2F1dG8nfSxcbiAgICAgICAgICAgIHRleHQgICAgICAgIDogJ0FkZCBDYWxlbmRhcidcbiAgICAgICAgfV0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGxheW91dD17bnR5cGU6J3Zib3gnLGFsaWduOidzdHJldGNoJ31cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGxheW91dDoge250eXBlOiAndmJveCcsIGFsaWduOiAnc3RyZXRjaCd9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNhbGVuZGFyLnZpZXcuTWFpbkNvbnRhaW5lcnxudWxsfSBvd25lcj1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG93bmVyOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkFkZENhbGVuZGFyQnV0dG9uQ2xpY2soZGF0YSkge1xuICAgICAgICB0aGlzLmNhbGVuZGFyU3RvcmUuYWRkKHtcbiAgICAgICAgICAgIGFjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbG9yIDogJ3JlZCcsXG4gICAgICAgICAgICBuYW1lICA6ICdOZXcgQ2FsZW5kYXInXG4gICAgICAgIH0pXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhDb250YWluZXIpO1xuIiwiaW1wb3J0IEJ1dHRvbiAgICAgICAgZnJvbSAnLi4vLi4vLi4vYnV0dG9uL0Jhc2UubWpzJztcbmltcG9ydCBDb2xvcnNMaXN0ICAgIGZyb20gJy4vQ29sb3JzTGlzdC5tanMnO1xuaW1wb3J0IEZvcm1Db250YWluZXIgZnJvbSAnLi4vLi4vLi4vZm9ybS9Db250YWluZXIubWpzJztcbmltcG9ydCBUZXh0RmllbGQgICAgIGZyb20gJy4uLy4uLy4uL2Zvcm0vZmllbGQvVGV4dC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uY2FsZW5kYXIudmlldy5jYWxlbmRhcnMuRWRpdENvbnRhaW5lclxuICogQGV4dGVuZHMgTmVvLmZvcm0uQ29udGFpbmVyXG4gKi9cbmNsYXNzIEVkaXRDb250YWluZXIgZXh0ZW5kcyBGb3JtQ29udGFpbmVyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jYWxlbmRhci52aWV3LmNhbGVuZGFycy5FZGl0Q29udGFpbmVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY2FsZW5kYXIudmlldy5jYWxlbmRhcnMuRWRpdENvbnRhaW5lcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1jYWxlbmRhci1lZGl0LWNvbnRhaW5lciddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1jYWxlbmRhci1lZGl0LWNvbnRhaW5lciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNhbGVuZGFyLnZpZXcuY2FsZW5kYXJzLkNvbG9yc0xpc3R8bnVsbH0gY29sb3JzTGlzdD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBjb2xvcnNMaXN0OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGNvbG9yc0xpc3RDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgY29sb3JzTGlzdENvbmZpZzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBuYW1lRmllbGRDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgbmFtZUZpZWxkQ29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNhbGVuZGFyLnZpZXcuTWFpbkNvbnRhaW5lcnxudWxsfSBvd25lcj1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBvd25lcjogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jYWxlbmRhci5tb2RlbC5DYWxlbmRhcnxudWxsfSByZWNvcmRfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICByZWNvcmRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IHVuTW91bnRUaW1lb3V0SWQ9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB1bk1vdW50VGltZW91dElkOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgLy8gZm9jdXMgdHJhcCwgc2VlOiBodHRwczovL2dpdGh1Yi5jb20vbmVvbWpzL25lby9pc3N1ZXMvMjMwNlxuICAgICAgICB0aGlzLnZkb20udGFiSW5kZXggPSAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1vdW50ZWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICB2YWx1ZSAmJiB0aGlzLmdldEZpZWxkKCduYW1lJykudGhlbihmaWVsZCA9PiB7XG4gICAgICAgICAgICBmaWVsZC5mb2N1cygpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSByZWNvcmQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOZW8uY2FsZW5kYXIubW9kZWwuQ2FsZW5kYXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uY2FsZW5kYXIubW9kZWwuQ2FsZW5kYXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0UmVjb3JkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiBvbGRWYWx1ZSkge1xuICAgICAgICAgICAgbWUucmVzZXQoe1xuICAgICAgICAgICAgICAgIG5hbWU6IHZhbHVlLm5hbWVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS5jb2xvcnNMaXN0LnZhbHVlID0gdmFsdWUuY29sb3I7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIG1lLmNyZWF0ZUl0ZW1zKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSByZWNvcmQgY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIFdlIG5lZWQgdGhlIGJlZm9yZSBtZXRob2QgdG8gYWxzbyBnZXQgY2xpY2tzIG9uIHRoZSBzYW1lIGVkaXQgaWNvbixcbiAgICAgKiBzaW5jZSBpdCBkb2VzIHRyaWdnZXIgZm9yIG5vdCBjaGFuZ2VkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge05lby5jYWxlbmRhci5tb2RlbC5DYWxlbmRhcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5jYWxlbmRhci5tb2RlbC5DYWxlbmRhcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0UmVjb3JkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS51bk1vdW50VGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQobWUudW5Nb3VudFRpbWVvdXRJZCk7XG4gICAgICAgICAgICBtZS51bk1vdW50VGltZW91dElkID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGNyZWF0ZUl0ZW1zKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3JlY29yZH0gPSBtZTtcblxuICAgICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgICAgICBtZS5jb2xvcnNMaXN0ID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgbW9kdWxlICAgICAgOiBDb2xvcnNMaXN0LFxuICAgICAgICAgICAgICAgIGxpc3RlbmVycyAgIDoge2NoYW5nZTogbWUub25Db2xvckNoYW5nZSwgc2NvcGU6IG1lfSxcbiAgICAgICAgICAgICAgICBwYXJlbnRJZCAgICA6IG1lLnBhcmVudElkLFxuICAgICAgICAgICAgICAgIHZhbHVlICAgICAgIDogcmVjb3JkLmNvbG9yLFxuICAgICAgICAgICAgICAgIHdyYXBwZXJTdHlsZToge21hcmdpblRvcDogJzAuMmVtJ30sXG4gICAgICAgICAgICAgICAgLi4ubWUuY29sb3JzTGlzdENvbmZpZ1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLml0ZW1zID0gW3tcbiAgICAgICAgICAgICAgICBtb2R1bGUgICAgICAgICAgICAgIDogVGV4dEZpZWxkLFxuICAgICAgICAgICAgICAgIGNsZWFyVG9PcmlnaW5hbFZhbHVlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGZsZXggICAgICAgICAgICAgICAgOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgbGFiZWxQb3NpdGlvbiAgICAgICA6ICdpbmxpbmUnLFxuICAgICAgICAgICAgICAgIGxhYmVsVGV4dCAgICAgICAgICAgOiAnQ2FsZW5kYXIgTmFtZScsXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzICAgICAgICAgICA6IHtjaGFuZ2U6IG1lLm9uTmFtZUZpZWxkQ2hhbmdlLCBzY29wZTogbWV9LFxuICAgICAgICAgICAgICAgIG5hbWUgICAgICAgICAgICAgICAgOiAnbmFtZScsXG4gICAgICAgICAgICAgICAgcmVxdWlyZWQgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWUgICAgICAgICAgICAgICA6IHJlY29yZC5uYW1lLFxuICAgICAgICAgICAgICAgIC4uLm1lLm5hbWVGaWVsZENvbmZpZ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1lLmNvbG9yc0xpc3QsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUgOiBCdXR0b24sXG4gICAgICAgICAgICAgICAgY2xzICAgIDogWyduZW8tcmVkJ10sXG4gICAgICAgICAgICAgICAgaGFuZGxlcjogbWUub25EZWxldGVCdXR0b25DbGljay5iaW5kKG1lKSxcbiAgICAgICAgICAgICAgICBpY29uQ2xzOiAnZmFzIGZhLXRyYXNoLWFsdCcsXG4gICAgICAgICAgICAgICAgc3R5bGUgIDoge21hcmdpblRvcDogJzNlbSd9LFxuICAgICAgICAgICAgICAgIHRleHQgICA6ICdEZWxldGUnXG4gICAgICAgICAgICB9XTtcblxuICAgICAgICAgICAgc3VwZXIuY3JlYXRlSXRlbXMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEucmVjb3JkXG4gICAgICovXG4gICAgb25Db2xvckNoYW5nZShkYXRhKSB7XG4gICAgICAgIHRoaXMucmVjb3JkLmNvbG9yID0gZGF0YS5yZWNvcmQubmFtZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRGVsZXRlQnV0dG9uQ2xpY2soZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIC8vIHRvZG86IHdlIGNvdWxkIGFkZCBhIGNvbmZpcm0gZGlhbG9nXG5cbiAgICAgICAgbWUuZ2V0U3RhdGVQcm92aWRlcigpLmdldFN0b3JlKCdjYWxlbmRhcnMnKS5yZW1vdmUobWUucmVjb3JkKTtcbiAgICAgICAgbWUudW5tb3VudCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZGF0YV1cbiAgICAgKi9cbiAgICBvbkZvY3VzTGVhdmUoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIC8vIHdlIG5lZWQgYSBzaG9ydCBkZWxheSB0byBnZXQgcmVjb3JkLWNoYW5nZXMgKGNsaWNraW5nIG9uIGFub3RoZXIgZWRpdCBpY29uKVxuICAgICAgICBtZS51bk1vdW50VGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBtZS51bk1vdW50VGltZW91dElkID0gbnVsbDtcbiAgICAgICAgICAgIG1lLm1vdW50ZWQgJiYgbWUudW5tb3VudCgpO1xuICAgICAgICB9LCAyMDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25OYW1lRmllbGRDaGFuZ2UoZGF0YSkge1xuICAgICAgICBpZiAoIU5lby5pc0VtcHR5KGRhdGEudmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLnJlY29yZC5uYW1lID0gZGF0YS52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoRWRpdENvbnRhaW5lcik7XG4iLCJpbXBvcnQgQ2hlY2tCb3hGaWVsZCBmcm9tICcuLi8uLi8uLi9mb3JtL2ZpZWxkL0NoZWNrQm94Lm1qcyc7XG5pbXBvcnQgQ29tcG9uZW50TGlzdCBmcm9tICcuLi8uLi8uLi9saXN0L0NvbXBvbmVudC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uY2FsZW5kYXIudmlldy5jYWxlbmRhcnMuTGlzdFxuICogQGV4dGVuZHMgTmVvLmxpc3QuQ29tcG9uZW50XG4gKi9cbmNsYXNzIExpc3QgZXh0ZW5kcyBDb21wb25lbnRMaXN0IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jYWxlbmRhci52aWV3LmNhbGVuZGFycy5MaXN0J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY2FsZW5kYXIudmlldy5jYWxlbmRhcnMuTGlzdCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1jYWxlbmRhcnMtbGlzdCcsJ25lby1saXN0J11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWNhbGVuZGFycy1saXN0JywgJ25lby1saXN0J10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGJpbmRcbiAgICAgICAgICovXG4gICAgICAgIGJpbmQ6IHtcbiAgICAgICAgICAgIHN0b3JlOiAnc3RvcmVzLmNhbGVuZGFycydcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gaXRlbURlZmF1bHRzXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtRGVmYXVsdHM6IHtcbiAgICAgICAgICAgIG1vZHVsZSAgICAgICAgOiBDaGVja0JveEZpZWxkLFxuICAgICAgICAgICAgZmxleCAgICAgICAgICA6ICdub25lJyxcbiAgICAgICAgICAgIGhpZGVMYWJlbCAgICAgOiB0cnVlLFxuICAgICAgICAgICAgaWNvbkNscyAgICAgICA6IFsnZmFzJywgJ2ZhLXNxdWFyZSddLFxuICAgICAgICAgICAgaWNvbkNsc0NoZWNrZWQ6IFsnZmFzJywgJ2ZhLWNoZWNrLXNxdWFyZSddXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY2FsZW5kYXIudmlldy5NYWluQ29udGFpbmVyfG51bGx9IG93bmVyPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgb3duZXI6IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBmb3IgY3VzdG9tIHJlbmRlcmVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fE9iamVjdFtdfFN0cmluZ30gRWl0aGVyIGEgY29uZmlnIG9iamVjdCB0byBhc3NpZ24gdG8gdGhlIGl0ZW0sIGEgdmRvbSBjbiBhcnJheSBvciBhIHN0cmluZy5cbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtQ29udGVudChyZWNvcmQsIGluZGV4KSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpZCAgICAgICA9IHJlY29yZFttZS5nZXRLZXlQcm9wZXJ0eSgpXSxcbiAgICAgICAgICAgIGl0ZW1zICAgID0gbWUuaXRlbXMgfHwgW10sXG4gICAgICAgICAgICBjaGVja0JveCA9IGl0ZW1zW2luZGV4XSxcblxuICAgICAgICBjb25maWcgPSB7XG4gICAgICAgICAgICBjaGVja2VkICAgOiByZWNvcmQuYWN0aXZlLFxuICAgICAgICAgICAgY2xzICAgICAgIDogW2BuZW8tY29sb3ItJHtyZWNvcmQuY29sb3J9YF0sXG4gICAgICAgICAgICBmaWVsZFZhbHVlOiBpZCxcbiAgICAgICAgICAgIGlkICAgICAgICA6IG1lLmdldENvbXBvbmVudElkKGluZGV4KSxcbiAgICAgICAgICAgIHZhbHVlTGFiZWw6IHJlY29yZC5uYW1lXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGNoZWNrQm94KSB7XG4gICAgICAgICAgICBjaGVja0JveC5zZXRTaWxlbnQoY29uZmlnKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlbXNbaW5kZXhdID0gY2hlY2tCb3ggPSBOZW8uY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBhcHBOYW1lICA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzOiB7Y2hhbmdlOiBtZS5vbkNoZWNrYm94Q2hhbmdlLCBzY29wZTogbWV9LFxuICAgICAgICAgICAgICAgIHBhcmVudElkIDogbWUuaWQsXG4gICAgICAgICAgICAgICAgd2luZG93SWQgOiBtZS53aW5kb3dJZCxcbiAgICAgICAgICAgICAgICAuLi5tZS5pdGVtRGVmYXVsdHMsXG4gICAgICAgICAgICAgICAgLi4uY29uZmlnXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgbWUuaXRlbXMgICAgICAgPSBpdGVtcztcbiAgICAgICAgbWUudXBkYXRlRGVwdGggPSAyO1xuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBjaGVja0JveC5jcmVhdGVWZG9tUmVmZXJlbmNlKCksXG4gICAgICAgICAgICB7dGFnOiAnaScsIGNsczogWyduZW8tZWRpdC1pY29uJywgJ2ZhcycsICdmYS1lZGl0J10sIGlkOiBtZS5nZXRFZGl0SWNvbklkKGluZGV4KX1cbiAgICAgICAgXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0RWRpdEljb25JZChpbmRleCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5pZH1fXyR7aW5kZXh9X19lZGl0LWljb25gXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkNoZWNrYm94Q2hhbmdlKGRhdGEpIHtcbiAgICAgICAgdGhpcy5zdG9yZS5nZXQoZGF0YS5jb21wb25lbnQuZmllbGRWYWx1ZSkuYWN0aXZlID0gZGF0YS52YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25DbGljayhkYXRhKSB7XG4gICAgICAgIC8vIFRoZSBjbGljayBldmVuIGFycml2ZXMgYmVmb3JlIHRoZSBDaGVja0JveCBvbklucHV0VmFsdWVDaGFuZ2UoKSBnZXRzIHRyaWdnZXJlZC5cbiAgICAgICAgLy8gV2UgbmVlZCBhIHNob3J0IGRlbGF5IHRvIGVuc3VyZSB0aGUgdmRvbSBvZiB0aGUgbGlzdCBpdGVtIGNvbnRhaW5zIHRoZSBuZXcgY2hlY2tlZCBzdGF0ZVxuICAgICAgICB0aGlzLnRpbWVvdXQoMjApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgc3VwZXIub25DbGljayhkYXRhKVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZGF0YS5wYXRoWzBdLmNscy5pbmNsdWRlcygnbmVvLWVkaXQtaWNvbicpKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBsaXN0SXRlbVJlY3QgICAgICAgICAgPSBkYXRhLnBhdGhbMV0ucmVjdCxcbiAgICAgICAgICAgICAgICBtYWluQ29udGFpbmVyICAgICAgICAgPSBtZS5vd25lcixcbiAgICAgICAgICAgICAgICBlZGl0Q2FsZW5kYXJDb250YWluZXIgPSBtYWluQ29udGFpbmVyLmVkaXRDYWxlbmRhckNvbnRhaW5lcixcbiAgICAgICAgICAgICAgICB7bW91bnRlZCwgc3R5bGV9ICAgICAgPSBlZGl0Q2FsZW5kYXJDb250YWluZXIsXG4gICAgICAgICAgICAgICAgcmVjb3JkICAgICAgICAgICAgICAgID0gbWUuc3RvcmUuZ2V0KG1lLmdldEl0ZW1SZWNvcmRJZChkYXRhLnBhdGhbMV0uaWQpKTtcblxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzdHlsZSwge1xuICAgICAgICAgICAgICAgIGxlZnQ6IGAke2xpc3RJdGVtUmVjdC5yaWdodCArIDEzfXB4YCxcbiAgICAgICAgICAgICAgICB0b3AgOiBgJHtsaXN0SXRlbVJlY3QudG9wICAgLSAxMH1weGBcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBlZGl0Q2FsZW5kYXJDb250YWluZXJbbW91bnRlZCA/ICdzZXQnIDogJ3NldFNpbGVudCddKHtcbiAgICAgICAgICAgICAgICBwYXJlbnRJZDogbWFpbkNvbnRhaW5lci5pZCxcbiAgICAgICAgICAgICAgICByZWNvcmQsXG4gICAgICAgICAgICAgICAgc3R5bGVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIW1vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICBlZGl0Q2FsZW5kYXJDb250YWluZXIuaW5pdFZub2RlKHRydWUpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVkaXRDYWxlbmRhckNvbnRhaW5lci5hZnRlclNldE1vdW50ZWQodHJ1ZSwgZmFsc2UpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaXRlbUlkXG4gICAgICovXG4gICAgb25LZXlEb3duRW50ZXIoaXRlbUlkKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICByZWNvcmRJZCA9IG1lLmdldEl0ZW1SZWNvcmRJZChpdGVtSWQpLFxuICAgICAgICAgICAgY2hlY2tCb3ggPSBtZS5pdGVtc1ttZS5zdG9yZS5pbmRleE9mKHJlY29yZElkKV07XG5cbiAgICAgICAgY2hlY2tCb3guY2hlY2tlZCA9ICFjaGVja0JveC5jaGVja2VkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gaXRlbXNcbiAgICAgKi9cbiAgICBvblNlbGVjdChpdGVtcykge1xuICAgICAgICB0aGlzLnNldFN0YXRlKCdhY3RpdmVDYWxlbmRhcklkJywgdGhpcy5nZXRJdGVtUmVjb3JkSWQoaXRlbXNbMF0pKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc2FibGluZyB0aGUgc3VwZXIgY2xhc3MgbG9naWMgZm9yIG5vdywgc2luY2UgdGhlIGNvbGxlY3Rpb24uQmFzZSBtdXRhdGlvbiBldmVudCBhbHJlYWR5IGNvdmVycyB0aGUgc29ydGluZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgc29ydEl0ZW1zKGRhdGEpIHtcblxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoTGlzdCk7XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gJy4vQmFzZS5tanMnO1xuXG4vKipcbiAqIENvbnZlbmllbmNlIGNsYXNzIHRvIHJlbmRlciBhIGxhYmVsIHdpdGggYSB0ZXh0XG4gKiBAY2xhc3MgTmVvLmNvbXBvbmVudC5MYWJlbFxuICogQGV4dGVuZHMgTmVvLmNvbXBvbmVudC5CYXNlXG4gKi9cbmNsYXNzIExhYmVsIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb21wb25lbnQuTGFiZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb21wb25lbnQuTGFiZWwnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nbGFiZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnbGFiZWwnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tbGFiZWwnXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tbGFiZWwnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gdGFnPSdsYWJlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHRhZzogJ2xhYmVsJ1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoTGFiZWwpO1xuIiwiaW1wb3J0IEJhc2UgICAgICAgICAgICAgIGZyb20gJy4vQmFzZS5tanMnO1xuaW1wb3J0IHtyZXNvbHZlQ2FsbGJhY2t9IGZyb20gJy4uL3V0aWwvRnVuY3Rpb24ubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50XG4gKiBAZXh0ZW5kcyBOZW8uY29udHJvbGxlci5CYXNlXG4gKi9cbmNsYXNzIENvbXBvbmVudCBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29udHJvbGxlci5Db21wb25lbnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nY29tcG9uZW50LWNvbnRyb2xsZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnY29tcG9uZW50LWNvbnRyb2xsZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9IGNvbXBvbmVudD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNvbXBvbmVudDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb250cm9sbGVyLkNvbXBvbmVudHxudWxsfSBwYXJlbnRfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBwYXJlbnRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSByZWZlcmVuY2VzPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVmZXJlbmNlczogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSB3aW5kb3dJZD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB3aW5kb3dJZDogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y29tcG9uZW50fSA9IG1lO1xuXG4gICAgICAgIG1lLnJlZmVyZW5jZXMgPSB7fTtcblxuICAgICAgICBpZiAoY29tcG9uZW50LmlzQ29uc3RydWN0ZWQpIHtcbiAgICAgICAgICAgIG1lLm9uQ29tcG9uZW50Q29uc3RydWN0ZWQoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcG9uZW50Lm9uKCdjb25zdHJ1Y3RlZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBtZS5vbkNvbXBvbmVudENvbnN0cnVjdGVkKClcbiAgICAgICAgICAgIH0sIG1lLCB7b25jZTogdHJ1ZX0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBwYXJlbnQgY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0UGFyZW50KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgfHwgdGhpcy5nZXRQYXJlbnQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBoYW5kbGVyTmFtZVxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9IFtjb21wb25lbnRdXG4gICAgICogQHJldHVybnMge05lby5jb250cm9sbGVyLkNvbXBvbmVudHxCb29sZWFufG51bGx9XG4gICAgICovXG4gICAgZ2V0SGFuZGxlclNjb3BlKGhhbmRsZXJOYW1lLCBjb21wb25lbnQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtwYXJlbnR9ID0gbWUsXG4gICAgICAgICAgICBoYW5kbGVyQ2I7XG5cbiAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgLy8gTG9vayBmb3IgdGhzIGZ1bmN0aW9uICpuYW1lKiBmaXJzdCBpbiB0aGUgQ29tcG9uZW50IGl0c2VsZi5cbiAgICAgICAgICAgIC8vIElmIHdlIGZpbmQgaXQsIHJldHVybiB0cnVlIHNvIGNhbGxpbmcgY29kZSBrbm93cyBub3QgdG8gY29udGludWUgdG8gc2VhcmNoLlxuICAgICAgICAgICAgaGFuZGxlckNiID0gcmVzb2x2ZUNhbGxiYWNrKGhhbmRsZXJOYW1lLCBjb21wb25lbnQpO1xuXG4gICAgICAgICAgICAvLyBIYW5kbGVyIGZuIGlzIHJlc29sdmVkIGluIHRoZSBDb21wb25lbnQgb3IgaXRzIG93biBwYXJlbnQgY2hhaW4uXG4gICAgICAgICAgICAvLyBSZXR1cm4gYSBzdGF0dXMgaW5kaWNhdGluZyB0aGF0IHdlIGRvIG5vdCBuZWVkIGFuIGVhcmx5IGJpbmRpbmdcbiAgICAgICAgICAgIGlmIChoYW5kbGVyQ2IuZm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE5lby5pc0Z1bmN0aW9uKG1lW2hhbmRsZXJOYW1lXSkgP1xuICAgICAgICAgICAgbWUgOiBwYXJlbnQ/LmdldEhhbmRsZXJTY29wZShoYW5kbGVyTmFtZSkgfHwgbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY2xvc2VzdCBjb250cm9sbGVyIGluc2lkZSB0aGUgY29tcG9uZW50cyBwYXJlbnQgdHJlZVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRQYXJlbnQoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7cGFyZW50fSA9IG1lO1xuXG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZS5jb21wb25lbnQucGFyZW50Py5nZXRDb250cm9sbGVyKCkgfHwgbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRvZG86IHVwZGF0ZSBjaGFuZ2VkIHJlZmVyZW5jZXMgKGUuZy4gY29udGFpbmVyLnJlbW92ZSgpIHRoZW4gY29udGFpbmVyLmFkZCgpIHVzaW5nIHRoZSBzYW1lIGtleSlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFJlZmVyZW5jZShuYW1lKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY29tcG9uZW50ID0gbWUucmVmZXJlbmNlc1tuYW1lXTtcblxuICAgICAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgICAgICAgY29tcG9uZW50ID0gbWUuY29tcG9uZW50LmRvd24oe3JlZmVyZW5jZTogbmFtZX0pO1xuXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgbWUucmVmZXJlbmNlc1tuYW1lXSA9IGNvbXBvbmVudFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudCB8fCBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXRcbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFN0YXRlKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGVQcm92aWRlcigpLmdldERhdGEoLi4uYXJncylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzYW1lTGV2ZWxPbmx5PWZhbHNlIHdpbGwgcmV0dXJuIHRoZSBjbG9zZXN0IHN0YXRlUHJvdmlkZXIgaW5zaWRlIHRoZSBjb21wb25lbnQgcGFyZW50IHRyZWUsXG4gICAgICogaW4gY2FzZSB0aGVyZSBpcyBub25lIG9uIHRoZSBzYW1lIGxldmVsLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NhbWVMZXZlbE9ubHk9ZmFsc2VdXG4gICAgICovXG4gICAgZ2V0U3RhdGVQcm92aWRlcihzYW1lTGV2ZWxPbmx5PWZhbHNlKSB7XG4gICAgICAgIGxldCB7Y29tcG9uZW50fSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBzYW1lTGV2ZWxPbmx5ID8gY29tcG9uZW50LnN0YXRlUHJvdmlkZXIgOiBjb21wb25lbnQuZ2V0U3RhdGVQcm92aWRlcigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXQgZm9yIGFjY2Vzc2luZyBzdGF0ZS5Qcm92aWRlciBiYXNlZCBkYXRhLlN0b3Jlc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcmV0dXJucyB7TmVvLmRhdGEuU3RvcmV9XG4gICAgICovXG4gICAgZ2V0U3RvcmUoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0YXRlUHJvdmlkZXIoKS5nZXRTdG9yZShrZXkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgaW5zaWRlIHlvdXIgdmlldyBjb250cm9sbGVycyBhcyBhIHN0YXJ0aW5nIHBvaW50IGluIGNhc2UgeW91IG5lZWQgcmVmZXJlbmNlc1xuICAgICAqIChpbnN0ZWFkIG9mIHVzaW5nIG9uQ29uc3RydWN0ZWQoKSBpbnNpZGUgeW91ciBjb250cm9sbGVyKVxuICAgICAqL1xuICAgIG9uQ29tcG9uZW50Q29uc3RydWN0ZWQoKSB7fVxuXG4gICAgLyoqXG4gICAgICogV2lsbCBnZXQgY2FsbGVkIGJ5IGNvbXBvbmVudC5CYXNlOiBkZXN0cm95KCkgaW4gY2FzZSB0aGUgY29tcG9uZW50IGhhcyBhIHJlZmVyZW5jZSBjb25maWdcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50XG4gICAgICovXG4gICAgcmVtb3ZlUmVmZXJlbmNlKGNvbXBvbmVudCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtyZWZlcmVuY2VzfSA9IG1lLFxuICAgICAgICAgICAga2V5O1xuXG4gICAgICAgIGZvciAoa2V5IGluIHJlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQgPT09IHJlZmVyZW5jZXNba2V5XSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSByZWZlcmVuY2VzW2tleV07XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmdldFBhcmVudCgpPy5yZW1vdmVSZWZlcmVuY2UoY29tcG9uZW50KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIHNob3J0Y3V0XG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICBzZXRTdGF0ZSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuZ2V0U3RhdGVQcm92aWRlcigpLnNldERhdGEoLi4uYXJncylcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKENvbXBvbmVudCk7XG4iLCJpbXBvcnQgQ29sb3JMaXN0IGZyb20gJy4uLy4uL2xpc3QvQ29sb3IubWpzJ1xuaW1wb3J0IENvbWJvQm94ICBmcm9tICcuL0NvbWJvQm94Lm1qcyc7XG5pbXBvcnQgVkRvbVV0aWwgIGZyb20gJy4uLy4uL3V0aWwvVkRvbS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZm9ybS5maWVsZC5Db2xvclxuICogQGV4dGVuZHMgTmVvLmZvcm0uZmllbGQuQ29tYm9Cb3hcbiAqL1xuY2xhc3MgQ29sb3IgZXh0ZW5kcyBDb21ib0JveCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZm9ybS5maWVsZC5Db2xvcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmZvcm0uZmllbGQuQ29sb3InLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nY29sb3JmaWVsZCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdjb2xvcmZpZWxkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWNvbG9yZmllbGQnLCduZW8tY29tYm9ib3gnLCduZW8tcGlja2VyZmllbGQnLCduZW8tdGV4dGZpZWxkJ11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWNvbG9yZmllbGQnLCAnbmVvLWNvbWJvYm94JywgJ25lby1waWNrZXJmaWVsZCcsICduZW8tdGV4dGZpZWxkJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGF0YS5Nb2RlbCBmaWVsZCB3aGljaCBjb250YWlucyB0aGUgY29sb3IgdmFsdWVcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjb2xvckZpZWxkPSduYW1lJ1xuICAgICAgICAgKi9cbiAgICAgICAgY29sb3JGaWVsZDogJ25hbWUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogT3ZlcnJpZGUgdGhlIGZvcm1hdHRlciB0byBhcHBseSBhIGN1c3RvbSBiYWNrZ3JvdW5kLWNvbG9yIHN0eWxpbmcuXG4gICAgICAgICAqIEUuZy4gdXNpbmcgQ1NTIHZhcnMgZm9yIGRpZmZlcmVudCB0aGVtZXNcbiAgICAgICAgICogQG1lbWJlciB7RnVuY3Rpb259IGNvbG9yRmllbGQ9KHNjb3BlLGRhdGEpPT5kYXRhW3Njb3BlLmNvbG9yRmllbGRdXG4gICAgICAgICAqL1xuICAgICAgICBjb2xvckZvcm1hdHRlcjogKHNjb3BlLGRhdGEpID0+IGRhdGFbc2NvcGUuY29sb3JGaWVsZF0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gbGlzdENvbmZpZ1xuICAgICAgICAgKi9cbiAgICAgICAgbGlzdENvbmZpZzoge1xuICAgICAgICAgICAgbW9kdWxlICAgICAgICAgICAgOiBDb2xvckxpc3QsXG4gICAgICAgICAgICBjb2xvckZpZWxkICAgICAgICA6ICdAY29uZmlnOmNvbG9yRmllbGQnLFxuICAgICAgICAgICAgY29sb3JGb3JtYXR0ZXIgICAgOiAnQGNvbmZpZzpjb2xvckZvcm1hdHRlcicsXG4gICAgICAgICAgICBzaWxlbnRTZWxlY3RVcGRhdGU6IHRydWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaW5wdXRXcmFwcGVyID0gVkRvbVV0aWwuZmluZChtZS52ZG9tLCBtZS5nZXRJbnB1dFdyYXBwZXJJZCgpKTtcblxuICAgICAgICBpbnB1dFdyYXBwZXIudmRvbS5jbi51bnNoaWZ0KHtcbiAgICAgICAgICAgIGNscyAgOiAnbmVvLWNvbG9yJyxcbiAgICAgICAgICAgIGlkICAgOiBtZS5nZXRDb2xvckluZGljYXRvcklkKCksXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogbWUuZ2V0Q29sb3IoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdmFsdWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcHJldmVudEZpbHRlcj1mYWxzZV1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsIHByZXZlbnRGaWx0ZXI9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbG9ySW5kaWNhdG9yID0gVkRvbVV0aWwuZmluZChtZS52ZG9tLCBtZS5nZXRDb2xvckluZGljYXRvcklkKCkpPy52ZG9tLFxuICAgICAgICAgICAge2xpc3QsIHJlY29yZH0gPSBtZSxcbiAgICAgICAgICAgIHNlbGVjdGlvbk1vZGVsID0gbWUubGlzdD8uc2VsZWN0aW9uTW9kZWw7XG5cbiAgICAgICAgaWYgKGNvbG9ySW5kaWNhdG9yKSB7XG4gICAgICAgICAgICBjb2xvckluZGljYXRvci5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBtZS5nZXRDb2xvcigpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25Nb2RlbD8uc2VsZWN0KGxpc3QuZ2V0SXRlbUlkKHJlY29yZFttZS5zdG9yZS5rZXlQcm9wZXJ0eV0pKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZWN0aW9uTW9kZWw/LmRlc2VsZWN0QWxsKHRydWUpXG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGUgc3VwZXIgY2FsbCB3aWxsIHRyaWdnZXIgdGhlIHZkb20gdXBkYXRlXG4gICAgICAgIHN1cGVyLmFmdGVyU2V0VmFsdWUodmFsdWUsIG9sZFZhbHVlLCBwcmV2ZW50RmlsdGVyKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0Q29sb3IoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtpbnB1dFZhbHVlLCB2YWx1ZX0gPSBtZTtcblxuICAgICAgICByZXR1cm4gdmFsdWUgPyBtZS5jb2xvckZvcm1hdHRlcihtZSwgdmFsdWUpIDogbWUuZm9yY2VTZWxlY3Rpb24gPyBudWxsIDogaW5wdXRWYWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0Q29sb3JJbmRpY2F0b3JJZCgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWR9X19jb2xvci1pbmRpY2F0b3JgXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uU2VsZWN0UG9zdExhc3RJdGVtKCkge1xuICAgICAgICBsZXQge2xpc3R9ID0gdGhpcyxcbiAgICAgICAgICAgIGluZGV4ICA9IGxpc3Quc3RvcmUuZ2V0Q291bnQoKSAtIDE7XG5cbiAgICAgICAgbGlzdC52ZG9tLmNuW2luZGV4XSA9IGxpc3QuY3JlYXRlSXRlbShsaXN0LnN0b3JlLmdldEF0KGluZGV4KSwgaW5kZXgpO1xuXG4gICAgICAgIHN1cGVyLm9uU2VsZWN0UG9zdExhc3RJdGVtKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25TZWxlY3RQcmVGaXJzdEl0ZW0oKSB7XG4gICAgICAgIGxldCB7bGlzdH0gPSB0aGlzO1xuXG4gICAgICAgIGxpc3QudmRvbS5jblswXSA9IGxpc3QuY3JlYXRlSXRlbShsaXN0LnN0b3JlLmdldEF0KDApLCAwKTtcblxuICAgICAgICBzdXBlci5vblNlbGVjdFByZUZpcnN0SXRlbSgpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhDb2xvcik7XG4iLCJpbXBvcnQgTGlzdCBmcm9tICcuL0Jhc2UubWpzJztcblxuLyoqXG4gKiBBIGJhc2UgY2xhc3MgZm9yIGxpc3RzIHdoaWNoIHdpbGwgdXNlIGNvbXBvbmVudCBiYXNlZCBsaXN0IGl0ZW1zXG4gKiBAY2xhc3MgTmVvLmxpc3QuQ29tcG9uZW50XG4gKiBAZXh0ZW5kcyBOZW8ubGlzdC5CYXNlXG4gKi9cbmNsYXNzIENvbXBvbmVudCBleHRlbmRzIExpc3Qge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmxpc3QuQ29tcG9uZW50J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ubGlzdC5Db21wb25lbnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nY29tcG9uZW50LWxpc3QnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnY29tcG9uZW50LWxpc3QnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbXBvbmVudC5CYXNlW118bnVsbH0gaXRlbXM9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbXM6IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGFwcE5hbWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEFwcE5hbWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0QXBwTmFtZSh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIHZhbHVlICYmIHRoaXMuaXRlbXM/LmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpdGVtLmFwcE5hbWUgPSB2YWx1ZVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgd2luZG93SWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFdpbmRvd0lkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldFdpbmRvd0lkKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgdmFsdWUgJiYgdGhpcy5pdGVtcz8uZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGl0ZW0ud2luZG93SWQgPSB2YWx1ZVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZGVzdHJveSguLi5hcmdzKSB7XG4gICAgICAgIGxldCBpdGVtcyA9IHRoaXMuaXRlbXMgfHwgW107XG5cbiAgICAgICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGl0ZW0uZGVzdHJveSgpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koLi4uYXJncylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldENvbXBvbmVudElkKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmlkfV9fJHtpbmRleH1fX2NvbXBvbmVudGBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHJlY29yZElkXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRJdGVtSWQocmVjb3JkSWQpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWR9X18ke3RoaXMuc3RvcmUuaW5kZXhPZihyZWNvcmRJZCl9YFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2bm9kZUlkXG4gICAgICogQHJldHVybnMge1N0cmluZ3xOdW1iZXJ9IGl0ZW1JZFxuICAgICAqL1xuICAgIGdldEl0ZW1SZWNvcmRJZCh2bm9kZUlkKSB7XG4gICAgICAgIGxldCBpdGVtSWQgPSB2bm9kZUlkLnNwbGl0KCdfXycpWzFdO1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZS5nZXRBdChwYXJzZUludChpdGVtSWQpKVt0aGlzLmdldEtleVByb3BlcnR5KCldXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLml0ZW1zXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5wcmV2aW91c0l0ZW1zXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5TdG9yZX0gZGF0YS5zY29wZVxuICAgICAqL1xuICAgIG9uU3RvcmVTb3J0KGRhdGEpIHtcbiAgICAgICAgdGhpcy5zb3J0SXRlbXMoZGF0YSk7XG4gICAgICAgIHN1cGVyLm9uU3RvcmVTb3J0KGRhdGEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLml0ZW1zXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5wcmV2aW91c0l0ZW1zXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5TdG9yZX0gZGF0YS5zY29wZVxuICAgICAqL1xuICAgIHNvcnRJdGVtcyhkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBuZXdJdGVtcyA9IFtdLFxuICAgICAgICAgICAgZnJvbUluZGV4LCBrZXksIHByZXZpb3VzS2V5cztcblxuICAgICAgICBpZiAobWUuaXRlbXMpIHtcbiAgICAgICAgICAgIG1lLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgaXRlbS5zZXRTaWxlbnQoe2lkOiBudWxsfSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBrZXkgICAgICAgICAgPSBtZS5nZXRLZXlQcm9wZXJ0eSgpO1xuICAgICAgICAgICAgcHJldmlvdXNLZXlzID0gZGF0YS5wcmV2aW91c0l0ZW1zLm1hcChlID0+IGVba2V5XSk7XG5cbiAgICAgICAgICAgIGRhdGEuaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBmcm9tSW5kZXggPSBwcmV2aW91c0tleXMuaW5kZXhPZihpdGVtW2tleV0pO1xuICAgICAgICAgICAgICAgIG5ld0l0ZW1zLnB1c2gobWUuaXRlbXNbZnJvbUluZGV4XSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS51cGRhdGVEZXB0aCA9IC0xO1xuICAgICAgICAgICAgbWUuaXRlbXMgPSBuZXdJdGVtc1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhDb21wb25lbnQpO1xuIiwiaW1wb3J0IEJ1dHRvbiAgICBmcm9tICcuLi9idXR0b24vQmFzZS5tanMnO1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQvQmFzZS5tanMnO1xuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuLi9jb250YWluZXIvQmFzZS5tanMnO1xuaW1wb3J0IExhYmVsICAgICBmcm9tICcuLi9jb21wb25lbnQvTGFiZWwubWpzJztcbmltcG9ydCBOZW9BcnJheSAgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8udG9vbGJhci5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29udGFpbmVyLkJhc2VcbiAqL1xuY2xhc3MgVG9vbGJhciBleHRlbmRzIENvbnRhaW5lciB7XG4gICAgLyoqXG4gICAgICogVmFsaWQgdmFsdWVzIGZvciBkb2NrXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IGRvY2tQb3NpdGlvbnM9Wyd0b3AnLCdyaWdodCcsJ2JvdHRvbScsJ2xlZnQnLCBudWxsXVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgZG9ja1Bvc2l0aW9ucyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0JywgbnVsbF1cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnRvb2xiYXIuQmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnRvb2xiYXIuQmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSd0b29sYmFyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3Rvb2xiYXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tdG9vbGJhciddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby10b29sYmFyJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gZG9ja189bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGRvY2tfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBpdGVtRGVmYXVsdHM9e250eXBlOididXR0b24nfVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1EZWZhdWx0czoge1xuICAgICAgICAgICAgbnR5cGU6ICdidXR0b24nXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGxheW91dD17bnR5cGU6J2ZsZXhib3gnLGFsaWduOidjZW50ZXInLGRpcmVjdGlvbjogJ3JvdycsIHBhY2s6J3N0YXJ0J31cbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBsYXlvdXQ6IHtcbiAgICAgICAgICAgIG50eXBlICAgIDogJ2ZsZXhib3gnLFxuICAgICAgICAgICAgYWxpZ24gICAgOiAnY2VudGVyJyxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogJ3JvdycsXG4gICAgICAgICAgICBwYWNrICAgICA6ICdzdGFydCdcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNvcnRhYmxlXz1mYWxzZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHNvcnRhYmxlXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZHJhZ2dhYmxlLnRvb2xiYXIuU29ydFpvbmV8bnVsbH0gc29ydFpvbmU9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgc29ydFpvbmU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHNvcnRab25lQ29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHNvcnRab25lQ29uZmlnOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBhcHBOYW1lIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRBcHBOYW1lKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldEFwcE5hbWUodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBpZiAodGhpcy5zb3J0Wm9uZSkge1xuICAgICAgICAgICAgdGhpcy5zb3J0Wm9uZS5hcHBOYW1lID0gdmFsdWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZG9jayBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXREb2NrKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlICYmICFvbGRWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2xzfSAgICAgICAgID0gbWUsXG4gICAgICAgICAgICBkb2NrUG9zaXRpb25zID0gbWUuZ2V0U3RhdGljQ29uZmlnKCdkb2NrUG9zaXRpb25zJyksXG4gICAgICAgICAgICBsYXlvdXRDb25maWcgID0gbWUuZ2V0TGF5b3V0Q29uZmlnKCk7XG5cbiAgICAgICAgZG9ja1Bvc2l0aW9ucy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBrZXkgIT09IG51bGwgJiYgTmVvQXJyYXkudG9nZ2xlKGNscywgJ25lby1kb2NrLScgKyBrZXksIGtleSA9PT0gdmFsdWUpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghbWUubGF5b3V0KSB7XG4gICAgICAgICAgICBsYXlvdXRDb25maWcubnR5cGUgPSAnZmxleGJveCc7XG4gICAgICAgICAgICBtZS5zZXQoe2NscywgbGF5b3V0OiBsYXlvdXRDb25maWd9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUubGF5b3V0LnNldChsYXlvdXRDb25maWcpO1xuICAgICAgICAgICAgbWUuY2xzID0gY2xzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzb3J0YWJsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNvcnRhYmxlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiAhbWUuc29ydFpvbmUpIHtcbiAgICAgICAgICAgIGltcG9ydCgnLi4vZHJhZ2dhYmxlL3Rvb2xiYXIvU29ydFpvbmUubWpzJykudGhlbihtb2R1bGUgPT4ge1xuICAgICAgICAgICAgICAgIG1lLnNvcnRab25lID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZSAgICAgICAgICAgICA6IG1vZHVsZS5kZWZhdWx0LFxuICAgICAgICAgICAgICAgICAgICBhcHBOYW1lICAgICAgICAgICAgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgICAgICAgICBib3VuZGFyeUNvbnRhaW5lcklkOiBtZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgb3duZXIgICAgICAgICAgICAgIDogbWUsXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0lkICAgICAgICAgICA6IG1lLndpbmRvd0lkLFxuICAgICAgICAgICAgICAgICAgICAuLi5tZS5zb3J0Wm9uZUNvbmZpZ1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB3aW5kb3dJZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0V2luZG93SWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0V2luZG93SWQodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBpZiAodGhpcy5zb3J0Wm9uZSkge1xuICAgICAgICAgICAgdGhpcy5zb3J0Wm9uZS53aW5kb3dJZCA9IHZhbHVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIG5ldyBkb2NrIHBvc2l0aW9uIG1hdGNoZXMgYSB2YWx1ZSBvZiB0aGUgc3RhdGljIGRvY2tQb3NpdGlvbnMgY29uZmlnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0RG9jayh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ2RvY2snLCAnZG9ja1Bvc2l0aW9ucycpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtcygpIHtcbiAgICAgICAgbGV0IGl0ZW1zID0gdGhpcy5faXRlbXM7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgICAgICB0aGlzLl9pdGVtcyA9IGl0ZW1zLm1hcChpdGVtID0+IHRoaXMucmVwbGFjZVNwYWNlcihpdGVtKSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdXBlci5jcmVhdGVJdGVtcygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGxheW91dCBjb25maWcgZGVwZW5kaW5nIG9uIHRoaXMuZG9ja1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGxheW91dENvbmZpZ1xuICAgICAqL1xuICAgIGdldExheW91dENvbmZpZygpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIGxheW91dENvbmZpZztcblxuICAgICAgICBpZiAobWUuZG9jaykge1xuICAgICAgICAgICAgc3dpdGNoIChtZS5kb2NrKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICAgICAgICBsYXlvdXRDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbiAgICA6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAncm93JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhY2sgICAgIDogJ3N0YXJ0J1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgICAgICBsYXlvdXRDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbiAgICA6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnY29sdW1uLXJldmVyc2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFjayAgICAgOiAnc3RhcnQnXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgICAgICBsYXlvdXRDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbiAgICA6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnY29sdW1uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhY2sgICAgIDogJ3N0YXJ0J1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxheW91dENvbmZpZyB8fCBtZS5sYXlvdXRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGFuIGl0ZW0gb3IgYXJyYXkgb2YgaXRlbXMgYXQgYSBzcGVjaWZpYyBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBpdGVtXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2lsZW50PWZhbHNlXVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29tcG9uZW50LkJhc2V8TmVvLmNvbXBvbmVudC5CYXNlW119XG4gICAgICovXG4gICAgaW5zZXJ0KGluZGV4LCBpdGVtLCBzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgIGl0ZW0gPSBpdGVtLm1hcChpdGVtID0+IHRoaXMucmVwbGFjZVNwYWNlcihpdGVtKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0gPSB0aGlzLnJlcGxhY2VTcGFjZXIoaXRlbSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdXBlci5pbnNlcnQoaW5kZXgsIGl0ZW0sIHNpbGVudClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxTdHJpbmd9IGl0ZW1cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fVxuICAgICAqL1xuICAgIHJlcGxhY2VTcGFjZXIoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbSA9PT0gJy0+JyA/IHttb2R1bGU6IENvbXBvbmVudCwgZmxleDogMX0gOiBpdGVtXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhUb29sYmFyKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=