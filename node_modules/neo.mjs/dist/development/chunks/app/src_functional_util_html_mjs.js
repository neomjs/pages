"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["src_functional_util_html_mjs"],{

/***/ "./src/functional/util/html.mjs":
/*!**************************************!*\
  !*** ./src/functional/util/html.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _vdom_domConstants_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../vdom/domConstants.mjs */ "./src/vdom/domConstants.mjs");


/**
 * @param {Array<String>} strings
 * @param {Array<*>} values
 * @returns {Object} A VDomNodeConfig object.
 */
const html = (strings, ...values) => {
    let fullString = '';
    for (let i = 0; i < strings.length; i++) {
        fullString += strings[i];
        if (i < values.length) {
            // Use a unique placeholder for dynamic values
            fullString += `__DYNAMIC_VALUE_${i}__`;
        }
    }

    // Very basic parsing: find the first tag and its content
    const tagRegex = /<(\w+)([^>]*)>([\s\S]*?)<\/\1>/;
    const match = fullString.match(tagRegex);

    if (!match) {
        // If no matching tag, return a simple text node or empty div
        return { tag: 'div', text: fullString.replace(/__DYNAMIC_VALUE_\d+__/g, (m) => {
            const index = parseInt(m.match(/\d+/)[0]);
            return values[index];
        }) };
    }

    const rootTag = match[1];
    const attributesString = match[2];
    let innerContent = match[3];

    const vdomNode = {
        tag: rootTag,
        cn: []
    };

    // Parse attributes (very basic: only id for now)
    const idMatch = attributesString.match(/id="([^"]+)"/);
    if (idMatch) {
        vdomNode.id = idMatch[1];
    }

    // Replace dynamic placeholders with actual values in innerContent
    innerContent = innerContent.replace(/__DYNAMIC_VALUE_(\d+)__/g, (m, index) => {
        return values[parseInt(index)];
    });

    // For the current test case, we know it's <p> and <span>
    // This is still not a generic parser, but a step towards it.
    const pSpanRegex = /<p>([\s\S]*?)<\/p>\s*<span>([\s\S]*?)<\/span>/;
    const pSpanMatch = innerContent.match(pSpanRegex);

    if (pSpanMatch) {
        vdomNode.cn.push({
            tag: 'p',
            text: pSpanMatch[1]
        });
        vdomNode.cn.push({
            tag: 'span',
            text: pSpanMatch[2]
        });
    } else {
        // Fallback for simpler cases or if the regex doesn't match
        vdomNode.cn.push({
            tag: 'div', // Default child tag
            text: innerContent // Treat as plain text for now
        });
    }

    return vdomNode;
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (html);


/***/ }),

/***/ "./src/vdom/domConstants.mjs":
/*!***********************************!*\
  !*** ./src/vdom/domConstants.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   rawDimensionTags: () => (/* binding */ rawDimensionTags),
/* harmony export */   voidAttributes: () => (/* binding */ voidAttributes),
/* harmony export */   voidElements: () => (/* binding */ voidElements)
/* harmony export */ });
/**
 * The following top-level attributes will get converted into styles:
 * height, maxHeight, maxWidth, minHeight, minWidth, width
 *
 * Some tags must not do the transformation, so we add them here.
 * @member {Set} rawDimensionTags
 */
const rawDimensionTags = new Set([
    'circle',
    'clipPath',
    'ellipse',
    'filter',
    'foreignObject',
    'image',
    'marker',
    'mask',
    'pattern',
    'rect',
    'svg',
    'use'
]);

/**
 * Void attributes inside html tags
 * @member {Set} voidAttributes
 * @protected
 */
const voidAttributes = new Set([
    'checked',
    'defer',
    'disabled',
    'ismap',
    'multiple',
    'nohref',
    'noresize',
    'noshade',
    'nowrap',
    'open',
    'readonly',
    'required',
    'reversed',
    'selected'
]);

/**
 * Void html tags
 * @member {Set} voidElements
 * @protected
 */
const voidElements = new Set([
    'area',
    'base',
    'br',
    'col',
    'embed',
    'hr',
    'img',
    'input',
    'link',
    'meta',
    'param',
    'source',
    'track',
    'wbr'
]);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC9zcmNfZnVuY3Rpb25hbF91dGlsX2h0bWxfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQTZGOztBQUU3RjtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLFVBQVU7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLEVBQUU7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBLGlFQUFlLElBQUksRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQUs7QUFDakI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9mdW5jdGlvbmFsL3V0aWwvaHRtbC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy92ZG9tL2RvbUNvbnN0YW50cy5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmF3RGltZW5zaW9uVGFncywgdm9pZEF0dHJpYnV0ZXMsIHZvaWRFbGVtZW50cyB9IGZyb20gJy4uLy4uL3Zkb20vZG9tQ29uc3RhbnRzLm1qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxTdHJpbmc+fSBzdHJpbmdzXG4gKiBAcGFyYW0ge0FycmF5PCo+fSB2YWx1ZXNcbiAqIEByZXR1cm5zIHtPYmplY3R9IEEgVkRvbU5vZGVDb25maWcgb2JqZWN0LlxuICovXG5jb25zdCBodG1sID0gKHN0cmluZ3MsIC4uLnZhbHVlcykgPT4ge1xuICAgIGxldCBmdWxsU3RyaW5nID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZ1bGxTdHJpbmcgKz0gc3RyaW5nc1tpXTtcbiAgICAgICAgaWYgKGkgPCB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBVc2UgYSB1bmlxdWUgcGxhY2Vob2xkZXIgZm9yIGR5bmFtaWMgdmFsdWVzXG4gICAgICAgICAgICBmdWxsU3RyaW5nICs9IGBfX0RZTkFNSUNfVkFMVUVfJHtpfV9fYDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFZlcnkgYmFzaWMgcGFyc2luZzogZmluZCB0aGUgZmlyc3QgdGFnIGFuZCBpdHMgY29udGVudFxuICAgIGNvbnN0IHRhZ1JlZ2V4ID0gLzwoXFx3KykoW14+XSopPihbXFxzXFxTXSo/KTxcXC9cXDE+LztcbiAgICBjb25zdCBtYXRjaCA9IGZ1bGxTdHJpbmcubWF0Y2godGFnUmVnZXgpO1xuXG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAvLyBJZiBubyBtYXRjaGluZyB0YWcsIHJldHVybiBhIHNpbXBsZSB0ZXh0IG5vZGUgb3IgZW1wdHkgZGl2XG4gICAgICAgIHJldHVybiB7IHRhZzogJ2RpdicsIHRleHQ6IGZ1bGxTdHJpbmcucmVwbGFjZSgvX19EWU5BTUlDX1ZBTFVFX1xcZCtfXy9nLCAobSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwYXJzZUludChtLm1hdGNoKC9cXGQrLylbMF0pO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlc1tpbmRleF07XG4gICAgICAgIH0pIH07XG4gICAgfVxuXG4gICAgY29uc3Qgcm9vdFRhZyA9IG1hdGNoWzFdO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXNTdHJpbmcgPSBtYXRjaFsyXTtcbiAgICBsZXQgaW5uZXJDb250ZW50ID0gbWF0Y2hbM107XG5cbiAgICBjb25zdCB2ZG9tTm9kZSA9IHtcbiAgICAgICAgdGFnOiByb290VGFnLFxuICAgICAgICBjbjogW11cbiAgICB9O1xuXG4gICAgLy8gUGFyc2UgYXR0cmlidXRlcyAodmVyeSBiYXNpYzogb25seSBpZCBmb3Igbm93KVxuICAgIGNvbnN0IGlkTWF0Y2ggPSBhdHRyaWJ1dGVzU3RyaW5nLm1hdGNoKC9pZD1cIihbXlwiXSspXCIvKTtcbiAgICBpZiAoaWRNYXRjaCkge1xuICAgICAgICB2ZG9tTm9kZS5pZCA9IGlkTWF0Y2hbMV07XG4gICAgfVxuXG4gICAgLy8gUmVwbGFjZSBkeW5hbWljIHBsYWNlaG9sZGVycyB3aXRoIGFjdHVhbCB2YWx1ZXMgaW4gaW5uZXJDb250ZW50XG4gICAgaW5uZXJDb250ZW50ID0gaW5uZXJDb250ZW50LnJlcGxhY2UoL19fRFlOQU1JQ19WQUxVRV8oXFxkKylfXy9nLCAobSwgaW5kZXgpID0+IHtcbiAgICAgICAgcmV0dXJuIHZhbHVlc1twYXJzZUludChpbmRleCldO1xuICAgIH0pO1xuXG4gICAgLy8gRm9yIHRoZSBjdXJyZW50IHRlc3QgY2FzZSwgd2Uga25vdyBpdCdzIDxwPiBhbmQgPHNwYW4+XG4gICAgLy8gVGhpcyBpcyBzdGlsbCBub3QgYSBnZW5lcmljIHBhcnNlciwgYnV0IGEgc3RlcCB0b3dhcmRzIGl0LlxuICAgIGNvbnN0IHBTcGFuUmVnZXggPSAvPHA+KFtcXHNcXFNdKj8pPFxcL3A+XFxzKjxzcGFuPihbXFxzXFxTXSo/KTxcXC9zcGFuPi87XG4gICAgY29uc3QgcFNwYW5NYXRjaCA9IGlubmVyQ29udGVudC5tYXRjaChwU3BhblJlZ2V4KTtcblxuICAgIGlmIChwU3Bhbk1hdGNoKSB7XG4gICAgICAgIHZkb21Ob2RlLmNuLnB1c2goe1xuICAgICAgICAgICAgdGFnOiAncCcsXG4gICAgICAgICAgICB0ZXh0OiBwU3Bhbk1hdGNoWzFdXG4gICAgICAgIH0pO1xuICAgICAgICB2ZG9tTm9kZS5jbi5wdXNoKHtcbiAgICAgICAgICAgIHRhZzogJ3NwYW4nLFxuICAgICAgICAgICAgdGV4dDogcFNwYW5NYXRjaFsyXVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGYWxsYmFjayBmb3Igc2ltcGxlciBjYXNlcyBvciBpZiB0aGUgcmVnZXggZG9lc24ndCBtYXRjaFxuICAgICAgICB2ZG9tTm9kZS5jbi5wdXNoKHtcbiAgICAgICAgICAgIHRhZzogJ2RpdicsIC8vIERlZmF1bHQgY2hpbGQgdGFnXG4gICAgICAgICAgICB0ZXh0OiBpbm5lckNvbnRlbnQgLy8gVHJlYXQgYXMgcGxhaW4gdGV4dCBmb3Igbm93XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB2ZG9tTm9kZTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGh0bWw7XG4iLCIvKipcbiAqIFRoZSBmb2xsb3dpbmcgdG9wLWxldmVsIGF0dHJpYnV0ZXMgd2lsbCBnZXQgY29udmVydGVkIGludG8gc3R5bGVzOlxuICogaGVpZ2h0LCBtYXhIZWlnaHQsIG1heFdpZHRoLCBtaW5IZWlnaHQsIG1pbldpZHRoLCB3aWR0aFxuICpcbiAqIFNvbWUgdGFncyBtdXN0IG5vdCBkbyB0aGUgdHJhbnNmb3JtYXRpb24sIHNvIHdlIGFkZCB0aGVtIGhlcmUuXG4gKiBAbWVtYmVyIHtTZXR9IHJhd0RpbWVuc2lvblRhZ3NcbiAqL1xuZXhwb3J0IGNvbnN0IHJhd0RpbWVuc2lvblRhZ3MgPSBuZXcgU2V0KFtcbiAgICAnY2lyY2xlJyxcbiAgICAnY2xpcFBhdGgnLFxuICAgICdlbGxpcHNlJyxcbiAgICAnZmlsdGVyJyxcbiAgICAnZm9yZWlnbk9iamVjdCcsXG4gICAgJ2ltYWdlJyxcbiAgICAnbWFya2VyJyxcbiAgICAnbWFzaycsXG4gICAgJ3BhdHRlcm4nLFxuICAgICdyZWN0JyxcbiAgICAnc3ZnJyxcbiAgICAndXNlJ1xuXSk7XG5cbi8qKlxuICogVm9pZCBhdHRyaWJ1dGVzIGluc2lkZSBodG1sIHRhZ3NcbiAqIEBtZW1iZXIge1NldH0gdm9pZEF0dHJpYnV0ZXNcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHZvaWRBdHRyaWJ1dGVzID0gbmV3IFNldChbXG4gICAgJ2NoZWNrZWQnLFxuICAgICdkZWZlcicsXG4gICAgJ2Rpc2FibGVkJyxcbiAgICAnaXNtYXAnLFxuICAgICdtdWx0aXBsZScsXG4gICAgJ25vaHJlZicsXG4gICAgJ25vcmVzaXplJyxcbiAgICAnbm9zaGFkZScsXG4gICAgJ25vd3JhcCcsXG4gICAgJ29wZW4nLFxuICAgICdyZWFkb25seScsXG4gICAgJ3JlcXVpcmVkJyxcbiAgICAncmV2ZXJzZWQnLFxuICAgICdzZWxlY3RlZCdcbl0pO1xuXG4vKipcbiAqIFZvaWQgaHRtbCB0YWdzXG4gKiBAbWVtYmVyIHtTZXR9IHZvaWRFbGVtZW50c1xuICogQHByb3RlY3RlZFxuICovXG5leHBvcnQgY29uc3Qgdm9pZEVsZW1lbnRzID0gbmV3IFNldChbXG4gICAgJ2FyZWEnLFxuICAgICdiYXNlJyxcbiAgICAnYnInLFxuICAgICdjb2wnLFxuICAgICdlbWJlZCcsXG4gICAgJ2hyJyxcbiAgICAnaW1nJyxcbiAgICAnaW5wdXQnLFxuICAgICdsaW5rJyxcbiAgICAnbWV0YScsXG4gICAgJ3BhcmFtJyxcbiAgICAnc291cmNlJyxcbiAgICAndHJhY2snLFxuICAgICd3YnInXG5dKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==