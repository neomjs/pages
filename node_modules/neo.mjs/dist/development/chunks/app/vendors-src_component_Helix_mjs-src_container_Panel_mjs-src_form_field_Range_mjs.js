"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_component_Helix_mjs-src_container_Panel_mjs-src_form_field_Range_mjs"],{

/***/ "./src/component/Helix.mjs":
/*!*********************************!*\
  !*** ./src/component/Helix.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _selection_HelixModel_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../selection/HelixModel.mjs */ "./src/selection/HelixModel.mjs");
/* harmony import */ var _util_Matrix_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Matrix.mjs */ "./src/util/Matrix.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _data_Store_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../data/Store.mjs */ "./src/data/Store.mjs");







const itemsMounted = Symbol.for('itemsMounted');
const lockWheel    = Symbol.for('lockWheel'); // we can not use itemsMounted, since it is connected to onSort()

/**
 * @class Neo.component.Helix
 * @extends Neo.component.Base
 */
class Helix extends _Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.Helix'
         * @protected
         */
        className: 'Neo.component.Helix',
        /**
         * @member {String} ntype='helix'
         * @protected
         */
        ntype: 'helix',
        /**
         * The background color of the helix container
         * @member {String} backgroundColor_='#000000'
         */
        backgroundColor_: '#000000',
        /**
         * The background image of the helix container
         * @member {String} backgroundImage_=''
         */
        backgroundImage_: '',
        /**
         * @member {String[]} baseCls=['neo-helix']
         */
        baseCls: ['neo-helix'],
        /**
         * The ids of expanded items will get stored here
         * @member {Array} clonedItems=[]
         * @protected
         */
        clonedItems: [],
        /**
         * The vertical delta between each helix item (increasing this value will create a spiral)
         * @member {Number} deltaY_=1.5
         */
        deltaY_: 1.5,
        /**
         * Multiselections will reduce the opacity and set this flag to true
         * @member {Boolean} dimmed_=false
         */
        dimmed_: false,
        /**
         * Multiselections will reduce the opacity and set this flag to true
         * @member {Number} dimmedMaxOpacity_=0.3
         */
        dimmedMaxOpacity_: 0.3,
        /**
         * Multiselections will reduce the opacity and set this flag to true
         * @member {Number} dimmedMinOpacity_=0.2
         */
        dimmedMinOpacity_: 0.2,
        /**
         * False will prevent items from getting selected.
         * @member {Boolean} disableSelection=false
         */
        disableSelection : false,
        /**
         * Flip images by 180° for a not mirrored inner view
         * @member {Boolean} flipped_=false
         */
        flipped_: false,
        /**
         * True to rotate the helix when using keynav, so that the selected items stays in front
         * @member {Boolean} followSelection_=false
         */
        followSelection_: false,
        /**
         * The record field containing the image data.
         * Nested fields are supported (e.g. author.image)
         * @member {String} imageField='image'
         */
        imageField: 'image',
        /**
         * The path to the images folder
         * Will get set inside afterSetWindowId() to avoid issues inside the webpack builds
         * @member {String|null} imageSource_=Neo.config.resourcesPath + 'examples/'
         */
        imageSource_: null,
        /**
         * Amount of items per row (circle) -> 360° / 10 = 36
         * @member {Number} itemAngle_=8
         */
        itemAngle_: 8,
        /**
         * @member {Object} itemTpl_
         */
        itemTpl_:
        {cls: ['surface', 'neo-helix-item'], style: {}, tabIndex: '-1', cn: [
            {tag: 'img', cls: ['contact-item']}
        ]},
        /**
         * The unique record field containing the id.
         * @member {String} keyProperty='id'
         */
        keyProperty: 'id',
        /**
         * Additional used keys for the selection model
         * @member {Object} keys
         */
        keys: {
            'Enter': 'onKeyDownEnter',
            'Space': 'onKeyDownSpace'
        },
        /**
         * We store one instance of the matrix here to avoid creating new ones on each refresh operation
         * @member {Neo.util.Matrix|null} matrix=null
         * @protected
         */
        matrix: null,
        /**
         * The max amount of store items to show
         * @member {Number} maxItems_=300
         */
        maxItems_: 300,
        /**
         * The max opacity for items inside the foreground
         * @member {Number} maxOpacity_=0.8
         */
        maxOpacity_: 0.8,
        /**
         * The max opacity for items inside the background
         * @member {Number} minOpacity_=0.3
         */
        minOpacity_: 0.3,
        /**
         * The zooming factor which replaces the default wheelDelta.
         * @member {Number} mouseWheelDeltaX=5
         */
        mouseWheelDeltaX: 5,
        /**
         * The zooming factor which replaces the default wheelDelta.
         * @member {Number} mouseWheelDeltaY=50
         */
        mouseWheelDeltaY: 50,
        /**
         * Specifies whether the mouse wheel should change the translateZ value for zooming
         * @member {Boolean} mouseWheelEnabled_=true
         */
        mouseWheelEnabled_: true,
        /**
         * The DOM element offsetHeight of the top level div.
         * Gets fetched after the helix got mounted.
         * @member {Number|null} offsetHeight=null
         * @protected
         */
        offsetHeight: null,
        /**
         * The DOM element offsetWidth of the top level div.
         * Gets fetched after the helix got mounted.
         * @member {Number|null} offsetWidth=null
         * @protected
         */
        offsetWidth: null,
        /**
         * The perspective of the Helix view in px
         * @member {Number} perspective_=800
         */
        perspective_: 800,
        /**
         * The radius of the Helix in px
         * @member {Number} radius_=1500
         */
        radius_: 1500,
        /**
         * The rotationAngle of the Helix in degrees
         * @member {Number} rotationAngle_=780
         */
        rotationAngle_: 780,
        /**
         * We store one instance of the rotation matrix here to avoid creating new ones on each refresh operation
         * @member {Neo.util.Matrix|null} rotationMatrix=null
         * @protected
         */
        rotationMatrix: null,
        /**
         * True displays the first & last name record fields below an expanded item
         * @member {Boolean} showCloneInfo=true
         */
        showCloneInfo: true,
        /**
         * The name of the CSS rule for selected items
         * @member {String} selectedItemCls='neo-selected'
         */
        selectedItemCls: 'neo-selected',
        /**
         * uses the selection.HelixModel by default
         * @member {Neo.selection.HelixModel|null} selectionModel_=null
         */
        selectionModel_: null,
        /**
         * The store instance or class containing the data for the gallery items
         * @member {Neo.data.Store|null} store_=null
         */
        store_: null, // todo: use a store once collections are integrated
        /**
         * The setTimeout() ids for calls which can get cancelled
         * @member {Array} transitionTimeouts=[]
         * @protected
         */
        transitionTimeouts: [],
        /**
         * The translateX gets included into each helix item
         * @member {Number} translateX_=400
         */
        translateX_: 400,
        /**
         * The translateX value gets included into each helix item
         * @member {Number} translateY_=-350
         */
        translateY_: -350,
        /**
         * The translateX value gets included into each helix item
         * @member {Number} translateZ_=-5000
         */
        translateZ_: -5000,
        /**
         * The url for the store to load the data
         * @member {String} url_='../resources/examples/data/ai_contacts.json'
         */
        url_: '../../resources/examples/data/ai_contacts.json',
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {style: {}, tabIndex: '-1', cn: [
            {cls: ['container'], style: {}, cn: [
                {cls: ['group'], cn: [], style: {
                    opacity: 1, transform: 'matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 461, 452.5, -100700, 1)'}
                }
            ]}
        ]}
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me[itemsMounted] = false;
        me[lockWheel]    = true;

        me.addDomListeners({
            click    : me.onClick,
            touchmove: me.onTouchMove,
            wheel    : me.onMouseWheel,
            scope    : me
        })
    }

    /**
     * Triggered after the followSelection config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetFollowSelection(value, oldValue) {
        let {cls} = this;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"][value ? 'add' : 'remove'](cls, 'neo-follow-selection');
        this.cls = cls
    }

    /**
     * Triggered after the flipped config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetFlipped(value, oldValue) {
        this.applyItemTransitions(this.refresh, 1000)
    }

    /**
     * Triggered after the imageSource config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetImageSource(value, oldValue) {
        let me = this;

        if (oldValue) {
            me.getItemsRoot().cn = [];
            me.createItems()
        }
    }

    /**
     * Triggered after the maxItem config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetMaxItems(value, oldValue) {
        let me = this;

        if (value && me.rendered) {
            if (oldValue > value) {
                me.destroyItems(value, oldValue - value)
            } else {
                me.createItems(oldValue)
            }
        }
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);
        value && this.getOffsetValues()
    }

    /**
     * Triggered after the perspective config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetPerspective(value, oldValue) {
        let me = this;

        if (me.mounted) {
            Neo.applyDeltas(me.appName, {
                id   : me.vdom.id,
                style: {
                    perspective: value + 'px'
                }
            });

            me.updateCloneTranslate()
        }
    }

    /**
     * Triggered after the selectionModel config got changed
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @protected
     */
    afterSetSelectionModel(value, oldValue) {
        this.rendered && value.register(this)
    }

    /**
     * Triggered after the url config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetUrl(value, oldValue) {
        let me = this;

        if (me.rendered) {
            me.destroyItems();
            me.loadData()
        }
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        super.afterSetWindowId(value, oldValue);

        if (value) {
            this.imageSource = Neo.config.resourcesPath + 'examples/'
        }
    }

    /**
     * @param callback
     * @param animationTime
     * @param callbackParam
     * @protected
     */
    applyItemTransitions(callback, animationTime, callbackParam) {
        let me   = this,
            {id} = me,
            cls  = 'neo-transition-' + animationTime,
            timeoutId;

        me.transitionTimeouts.forEach(item => {
            clearTimeout(item)
        });

        me.transitionTimeouts.splice(0, me.transitionTimeouts.length);

        if (me.mounted) {
            Neo.applyDeltas(me.appName, {
                id,
                cls: {
                    add   : [cls],
                    remove: []
                }
            }).then(() => {
                callback.apply(me, [callbackParam]);

                timeoutId = setTimeout(() => {
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].remove(me.transitionTimeouts, timeoutId);

                    Neo.applyDeltas(me.appName, {
                        id,
                        cls: {
                            add   : [],
                            remove: [cls]
                        }
                    })
                }, animationTime + 200);

                me.transitionTimeouts.push(timeoutId)
            })
        }
    }

    /**
     * @returns {Object}
     */
    beforeGetItemTpl() {
        return Neo.clone(this._itemTpl, true)
    }

    /**
     * Triggered before the selectionModel config gets changed.
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @protected
     */
    beforeSetSelectionModel(value, oldValue) {
        oldValue?.destroy();

        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].beforeSetInstance(value, _selection_HelixModel_mjs__WEBPACK_IMPORTED_MODULE_2__["default"], {
            listeners: {
                selectionChange: this.onSelectionChange,
                scope          : this
            }
        })
    }

    /**
     * Triggered before the store config gets changed.
     * @param {Neo.data.Store|null} value
     * @param {Neo.data.Store|null} oldValue
     * @protected
     */
    beforeSetStore(value, oldValue) {
        let me = this;

        oldValue?.destroy();

        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].beforeSetInstance(value, _data_Store_mjs__WEBPACK_IMPORTED_MODULE_5__["default"], {
            listeners  : {
                load : me.onStoreLoad,
                sort : me.onSort,
                scope: me
            }
        })
    }

    /**
     * Calculate an opacity gradient based on the item rotation angle
     * @param {Object} item
     * @returns {Number}
     */
    calculateOpacity(item) {
        let me                       = this,
            {maxOpacity, minOpacity} = me,
            deltaOpacity             = maxOpacity - minOpacity,
            angle, opacity, opacityFactor;

        if (deltaOpacity === 0) {
            opacity = maxOpacity;
        } else {
            angle = item.rotationAngle % 360;

            while (angle < 0) {
                angle += 360
            }

            while (angle > 180) {
                angle = 360 - angle
            }

            // non-linear distribution, since the angle does not match delta translateZ
            opacityFactor = 1 - Math.sin(angle * Math.PI / 360);

            opacity = minOpacity + deltaOpacity * opacityFactor
        }

        return opacity
    }

    /**
     * Override this method to get different item-markups
     * @param {Object} vdomItem
     * @param {Object} record
     * @param {Number} index
     * @returns {Object} vdomItem
     */
    createItem(vdomItem, record, index) {
        let me = this;

        vdomItem.id = me.getItemVnodeId(record[me.keyProperty]);

        vdomItem.cn[0].id  = me.getItemVnodeId(record[me.keyProperty]) + '_img';
        vdomItem.cn[0].src = me.imageSource + Neo.ns(me.imageField, false, record);

        return vdomItem
    }

    /**
     * @param {Number} [startIndex] the start index for creating items,
     * e.g. increasing maxItems only needs to create the new ones
     * @protected
     */
    createItems(startIndex) {
        let me    = this,
            {deltaY, itemAngle, matrix, radius, rotationAngle, translateX, translateY, translateZ, vdom} = me,
            group = me.getItemsRoot(),
            i     = startIndex || 0,
            len   = Math.min(me.maxItems, me.store.items.length),
            angle, item, matrixItems, transformStyle, vdomItem, c, s, x, y, z;

        if (!me.mounted) {
            const listenerId = me.on('mounted', () => {
                me.un('mounted', listenerId);
                setTimeout(() => {
                    me.createItems(startIndex);
                }, 100)
            })
        } else {
            for (; i < len; i++) {
                item = me.store.items[i];

                angle = -rotationAngle + i * itemAngle;

                s = Math.sin(angle * Math.PI / 180);
                c = Math.cos(angle * Math.PI / 180);

                x = radius * s - 300 + translateX;
                y = -400 + angle * deltaY + translateY;
                z = 99800 + radius * c + translateZ;

                matrixItems = [
                    [c, 0, -s, 0],
                    [0, 1,  0, 0],
                    [s, 0,  c, 0],
                    [x, y,  z, 1]
                ];

                if (!matrix) {
                    me.matrix = matrix = Neo.create(_util_Matrix_mjs__WEBPACK_IMPORTED_MODULE_3__["default"], {
                        items: matrixItems
                    })
                } else {
                    matrix.items = matrixItems
                }

                transformStyle = matrix.getTransformStyle();

                vdomItem = me.createItem(me.itemTpl, item, i);

                item.rotationAngle  = angle;
                item.transformStyle = transformStyle;

                vdomItem. style = vdomItem.style || {};

                vdomItem.style.opacity   = me.calculateOpacity(item);
                vdomItem.style.transform = transformStyle;

                group.cn.push(vdomItem)
            }

            me[lockWheel] = true;

            me.promiseUpdate(vdom).then(() => {
                me[itemsMounted] = true;
                me.fire('itemsMounted');

                setTimeout(() => {
                    me[lockWheel] = false
                }, 200)
            })
        }
    }

    /**
     * @protected
     */
    destroyClones() {
        let me           = this,
            {store}      = me,
            deltas       = [],
            removeDeltas = [],
            id, record;

        if (me.clonedItems.length > 0) {
            me.clonedItems.forEach(item => {
                id     = me.getItemId(item.id);
                record = store.get(id);

                record.expanded = false;

                deltas.push({
                    id   : item.id,
                    style: {
                        opacity  : record.opacity,
                        transform: record.transformStyle
                    }
                });

                removeDeltas.push({
                    id    : item.id,
                    action: 'removeNode'
                })
            });

            me.clonedItems = [];

            Neo.applyDeltas(me.appName, deltas).then(data => {
                setTimeout(() => {
                    Neo.applyDeltas(me.appName, removeDeltas)
                }, 650)
            })
        }
    }

    /**
     * @param {Number} [startIndex]
     * @param {Number} [amountItems]
     */
    destroyItems(startIndex, amountItems) {
        let me = this;

        me.getItemsRoot().cn.splice(startIndex || 0, amountItems || me.store.getCount());
        me.update()
    }

    /**
     * Moves a clone of an item to the top left corner
     * @param {String} itemId
     */
    expandItem(itemId) {
        let me               = this,
            {appName, store} = me,
            record           = store.get(itemId),
            index            = store.indexOf(itemId),
            isExpanded       = !!record.expanded,
            group            = me.getItemsRoot(),
            itemVdom         = Neo.clone(group.cn[index], true);

        me.destroyClones();

        if (isExpanded !== true) {
            record.expanded = true;

            itemVdom.id = itemVdom.id + '__clone';
            itemVdom.style.transform = record.transformStyle;
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].add(itemVdom.cls, 'neo-transition-600');
            delete itemVdom.tabIndex;

            itemVdom.cn[0].id = itemVdom.cn[0].id + '__clone';

            if (me.showCloneInfo) {
                itemVdom.cn.push({
                    cls      : ['contact-name'],
                    innerHTML: record.firstname + ' ' + record.lastname
                })
            }

            Neo.vdom.Helper.create({
                appName,
                autoMount  : true,
                parentId   : group.id,
                parentIndex: store.getCount(),
                ...itemVdom
            }).then(data => {
                me.clonedItems.push(itemVdom);

                setTimeout(() => {
                    Neo.applyDeltas(appName, {
                        id   : itemVdom.id,
                        style: {
                            opacity  : 1,
                            transform: me.getCloneTransform()
                        }
                    })
                }, 50)
            })
        }
    }

    /**
     * @returns {String}
     */
    getCloneTransform() {
        let me         = this,
            translateX = (me.offsetWidth  - 1350) / 3,
            translateY = (me.offsetHeight - 1320) / 3,
            translateZ = 100700 + me.perspective / 1.5;

        return `matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,${translateX},${translateY},${translateZ},1`
    }

    /**
     * @param {String} vnodeId
     * @returns {Number}
     */
    getItemId(vnodeId) {
        return parseInt(vnodeId.split('__')[1])
    }

    /**
     * Returns the vdom node containing the helix items
     * @returns {Object} vdom
     */
    getItemsRoot() {
        return this.vdom.cn[0].cn[0]
    }

    /**
     * @param {Number|String} id
     * @returns {String}
     */
    getItemVnodeId(id) {
        return this.id + '__' + id
    }

    /**
     * @param {Number} [delay=100]
     */
    getOffsetValues(delay=100) {
        let me = this;

        setTimeout(() => {
            Neo.currentWorker.promiseMessage('main', {
                action    : 'readDom',
                appName   : me.appName,
                attributes: ['offsetHeight', 'offsetWidth'],
                vnodeId   : me.id
            }).then(data => {
                me.offsetHeight = data.attributes.offsetHeight;
                me.offsetWidth  = data.attributes.offsetWidth;
            })
        }, delay)
    }

    /**
     *
     */
    loadData() {
        let me = this;

        Neo.Xhr.promiseJson({
            insideNeo: true,
            url      : me.url
        }).catch(err => {
            console.log('Error for Neo.Xhr.request', err, me.id);
        }).then(data => {
            me.store.items = data.json.data;
            me.createItems()
        })
    }

    /**
     * @param {String} itemId
     */
    moveToSelectedItem(itemId) {
        let me = this;
        me.rotationAngle = me.store.get(itemId).rotationAngle + me.rotationAngle
    }

    /**
     * @param {Object} data
     */
    onClick(data) {
        this.fire(data.id === this.id ? 'containerClick' : 'itemClick', data)
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();
        this.selectionModel?.register(this)
    }

    /**
     * @param {Object} data
     */
    onKeyDownEnter(data) {
        let item = this.selectionModel.items[0];
        item && this.expandItem(item)
    }

    /**
     * @param {Object} data
     */
    onKeyDownSpace(data) {
        this.applyItemTransitions(this.moveToSelectedItem, 1000, this.selectionModel.items[0] || 0)
    }

    /**
     * @param {Object} data
     */
    onMouseWheel(data) {
        let me = this;

        if (me.mouseWheelEnabled && !me[lockWheel]) {
            me._rotationAngle = me.rotationAngle + (data.deltaX * me.mouseWheelDeltaX); // silent update
            me._translateZ    = me.translateZ    + (data.deltaY * me.mouseWheelDeltaY); // silent update

            me.refresh();

            me.fire('changeRotation',   me._rotationAngle);
            me.fire('changeTranslateZ', me._translateZ)
        }
    }

    /**
     * @param {String[]} value
     * @param {String[]} oldValue
     */
    onSelectionChange(value, oldValue) {
        let me = this;

        if (me.followSelection && value?.[0]) {
            me.applyItemTransitions(me.moveToSelectedItem, 100, value[0])
        }
    }

    /**
     * @protected
     */
    onSort() {
        let me = this;

        if (me[itemsMounted] === true) {
            me.applyItemTransitions(me.sortItems, 1000)
        }
    }

    /**
     * @param {Array} items
     */
    onStoreLoad(items) {
        this.getItemsRoot().cn = []; // silent update
        this.createItems()
    }

    /**
     * @param {Object} data
     */
    onTouchMove(data) {
        data.deltaX *= 1.5;
        data.deltaY *= 3;

        this.onMouseWheel(data)
    }

    /**
     * @protected
     */
    refresh() {
        let me     = this,
            deltas = [],
            {deltaY, flipped, itemAngle, matrix, radius, rotationAngle, rotationMatrix, translateX, translateY, translateZ, vdom} = me,
            index  = 0,
            len    = Math.min(me.maxItems, me.store.getCount()),
            angle, item, opacity, rotateY, transformStyle, vdomItem, c, s, x, y, z;

        if (flipped) {
            rotateY = _util_Matrix_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].rotateY(180 * Math.PI / 180);

            if (!rotationMatrix) {
                me.rotationMatrix = rotationMatrix = Neo.create(_util_Matrix_mjs__WEBPACK_IMPORTED_MODULE_3__["default"], {
                    items: rotateY
                })
            } else {
                rotationMatrix.items = rotateY
            }
        }

        for (; index < len; index++) {
            item     = me.store.items[index];
            vdomItem = vdom.cn[0].cn[0].cn[index];

            angle = -rotationAngle + index * itemAngle;

            s = Math.sin(angle * Math.PI / 180);
            c = Math.cos(angle * Math.PI / 180);

            x =  -300 + radius * s      + translateX;
            y =  -400 + angle  * deltaY + translateY;
            z = 99800 + radius * c      + translateZ;

            matrix.items = [
                [c, 0, -s, 0],
                [0, 1,  0, 0],
                [s, 0,  c, 0],
                [x, y,  z, 1]
            ];

            if (flipped) {
                matrix = rotationMatrix.x(matrix)
            }

            transformStyle = matrix.getTransformStyle();
            matrix.destroy();

            Object.assign(item, {
                rotationAngle: angle,
                transformStyle
            });

            opacity = me.calculateOpacity(item);
            item.opacity = opacity;

            Object.assign(item, {
                opacity,
                rotationAngle: angle,
                transformStyle
            });

            deltas.push({
                id   : me.getItemVnodeId(item[me.keyProperty]),
                style: {
                    opacity,
                    transform: transformStyle
                }
            })
        }

        Neo.applyDeltas(me.appName, deltas)
    }

    /**
     * @protected
     */
    refreshIfMounted() {
        this.mounted && this.refresh()
    }

    /**
     *
     */
    sortItems() {
        let me       = this,
            deltas   = [],
            parentId = me.vdom.cn[0].cn[0].id,
            i        = 0,
            len      = Math.min(me.maxItems, me.store.getCount());

        for (; i < len; i++) {
            deltas.push({
                action: 'moveNode',
                id    : me.getItemVnodeId(me.store.items[i][me.keyProperty]),
                index : i,
                parentId
            })
        }

        Neo.applyDeltas(me.appName, deltas).then(() => {
            me.refresh()
        });
    }

    /**
     * @protected
     */
    updateCloneTranslate() {
        let me           = this,
            afterDeltas  = [],
            deltas       = [],
            timeoutId, transform;

        if (me.clonedItems.length > 0) {
            transform = me.getCloneTransform(true);

            me.transitionTimeouts.forEach(item => {
                clearTimeout(item)
            });

            me.clonedItems.forEach(item => {
                deltas.push({
                    id : item.id,
                    cls: {
                        add   : [],
                        remove: ['neo-transition-600']
                    },
                    style: {
                        transform: transform
                    }
                });

                afterDeltas.push({
                    id : item.id,
                    cls: {
                        add   : ['neo-transition-600'],
                        remove: []
                    }
                });
            });

            Neo.applyDeltas(me.appName, deltas).then(() => {
                timeoutId = setTimeout(() => {
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].remove(me.transitionTimeouts, timeoutId);
                    Neo.applyDeltas(me.appName, afterDeltas)
                }, 200);

                me.transitionTimeouts.push(timeoutId)
            })
        }
    }
}

const cfg = {enumerable: false, value: Helix.prototype.refreshIfMounted};

Object.defineProperties(Helix.prototype, {
    afterSetDeltaY       : cfg,
    afterSetItemAngle    : cfg,
    afterSetMaxOpacity   : cfg,
    afterSetMinOpacity   : cfg,
    afterSetRadius       : cfg,
    afterSetRotationAngle: cfg,
    afterSetTranslateX   : cfg,
    afterSetTranslateY   : cfg,
    afterSetTranslateZ   : cfg
});

Neo.setupClass(Helix);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Helix);


/***/ }),

/***/ "./src/container/Panel.mjs":
/*!*********************************!*\
  !*** ./src/container/Panel.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toolbar/Base.mjs */ "./src/toolbar/Base.mjs");



/**
 * An extended Container supporting multiple docked header toolbars
 * @class Neo.container.Panel
 * @extends Neo.container.Base
 */
class Panel extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.container.Panel'
         * @protected
         */
        className: 'Neo.container.Panel',
        /**
         * @member {String} ntype='panel'
         * @protected
         */
        ntype: 'panel',
        /**
         * @member {String[]} baseCls=['neo-panel','neo-container']
         */
        baseCls: ['neo-panel', 'neo-container'],
        /**
         * @member {Object} containerConfig=null
         */
        containerConfig: null,
        /**
         * @member {Object} headerDefaults=null
         */
        headerDefaults: null,
        /**
         * @member {Array} headers=null
         */
        headers: null,
        /**
         * @member {Object} items={ntype: 'vbox', align: 'stretch'}
         */
        _layout: {
            ntype: 'vbox',
            align: 'stretch'
        },
        /**
         * @member {Boolean} verticalHeadersFirst=false
         */
        verticalHeadersFirst: false
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        if (me.hasHeaders() && me.verticalHeadersFirst === true) {
            me.layout = {
                ntype: 'hbox',
                align: 'stretch'
            };
        }
    }

    /**
     * @param {Object} header the header config
     * @returns {Object}
     */
    static createHeaderConfig(header) {
        if (Neo.typeOf(header) === 'NeoInstance') {
            return header;
        }

        let config = {
            flex: '0 1 auto'
        };

        if (!header.module && !header.ntype) {
            config.cls   = ['neo-panel-header-toolbar', 'neo-toolbar'];
            config.ntype = 'toolbar';
        }

        if (header.text) {
            config.items = [{
                ntype: 'label',
                cls  : ['neo-panel-header-text', 'neo-label'],
                text : header.text
            }];

            delete header.text;
        }

        // assuming all labels inside a Panel Header are meant to be titles -> look the same way
        if (Array.isArray(header.items)) {
            header.items.forEach(item => {
                if (item.ntype === 'label') {
                    item.cls = ['neo-panel-header-text', 'neo-label'];
                }
            });
        }

        return {...config, ...header}
    }

    /**
     *
     */
    createItems() {
        let me              = this,
            containerConfig = me.containerConfig;

        if (!me.hasHeaders()) {
            containerConfig && me.set(containerConfig);
            super.createItems();
        } else {
            let hf                   = me.verticalHeadersFirst === false,
                headers              = me.headers || [],
                bottomHeaders        = headers.filter(header => {return header.dock === (hf ?'bottom': 'right')}),
                leftHeaders          = headers.filter(header => {return header.dock === (hf ?'left'  : 'top')}),
                rightHeaders         = headers.filter(header => {return header.dock === (hf ?'right' : 'bottom')}),
                topHeaders           = headers.filter(header => {return header.dock === (hf ?'top'   : 'left')}),
                hasHorizontalHeaders = bottomHeaders.length > 0 || topHeaders  .length > 0,
                hasVerticalHeaders   = leftHeaders  .length > 0 || rightHeaders.length > 0,
                {items}              = me,
                horizontalItems      = [],
                verticalItems        = [],
                config;

            topHeaders.forEach(header => {
                verticalItems.push(Panel.createHeaderConfig(header))
            });

            if (hasVerticalHeaders && (hf && hasHorizontalHeaders || !hf && hasHorizontalHeaders)) {
                leftHeaders.forEach(header => {
                    horizontalItems.push(Panel.createHeaderConfig(header))
                });

                config = {
                    ntype       : 'container',
                    flex        : 1,
                    items,
                    itemDefaults: me.itemDefaults,
                    ...containerConfig
                };

                horizontalItems.push({...me.headerDefaults, ...config});

                rightHeaders.forEach(header => {
                    horizontalItems.push(Panel.createHeaderConfig(header))
                });

                verticalItems.push({
                    ntype : 'container',
                    items : horizontalItems,
                    layout: {
                        ntype: (hf ? 'hbox' : 'vbox'),
                        align: 'stretch'
                    }
                });
            } else {
                config = {
                    ntype       : 'container',
                    flex        : 1,
                    items,
                    itemDefaults: me.itemDefaults,
                    ...containerConfig
                };

                verticalItems.push({...me.headerDefaults, ...config})
            }

            bottomHeaders.forEach(header => {
                verticalItems.push(Panel.createHeaderConfig(header))
            });

            me.items = verticalItems;

            me.itemDefaults = null;

            super.createItems()
        }
    }

    /**
     * @returns {Boolean}
     */
    hasHeaders() {
        return Array.isArray(this.headers) && this.headers.length > 0
    }
}

Neo.setupClass(Panel);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Panel);


/***/ }),

/***/ "./src/form/field/Range.mjs":
/*!**********************************!*\
  !*** ./src/form/field/Range.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Number_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Number.mjs */ "./src/form/field/Number.mjs");


/**
 * @class Neo.form.field.Range
 * @extends Neo.form.field.Number
 */
class Range extends _Number_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Removing the debounce for range fields
     * @member {Object} delayable
     * @protected
     * @static
     */
    static delayable = {}

    static config = {
        /**
         * @member {String} className='Neo.form.field.Range'
         * @protected
         */
        className: 'Neo.form.field.Range',
        /**
         * @member {String} ntype='rangefield'
         * @protected
         */
        ntype: 'rangefield',
        /**
         * @member {String[]} baseCls=['neo-rangefield','neo-textfield']
         */
        baseCls: ['neo-rangefield', 'neo-textfield'],
        /**
         * True shows a clear trigger in case the field has a non empty value.
         * @member {Boolean} clearable=false
         */
        clearable: false,
        /**
         * Value for the inputType_ textfield config
         * @member {String} inputType='range'
         */
        inputType: 'range',
        /**
         * If true, shows the result of the slider in the label
         * @member {Boolean} showResultInLabel=false
         */
        showResultInLabel: false,
        /**
         * @member {Array} tickmarks_=[]
         */
        tickmarks_: [],
        /**
         * @member {Boolean} useInputEvent=false
         */
        useInputEvent: false,
        /**
         * Disables the field.Number buttons
         * @member {Boolean} useInputEvent=false
         */
        useSpinButtons: false
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me      = this,
            inputEl = me.vdom.cn[2];

        if (me.useInputEvent) {
            me.addDomListeners({
                input: {
                    fn   : me.onInputValueChange,
                    id   : me.vdom.cn[2].id,
                    scope: me
                }
            });
        }

        inputEl.cls = ['neo-rangefield-input']; // replace neo-textfield-input

        me.addValueToLabel()
    }

    /**
     * Triggered after the tickmarks config got changed
     * @param {Array} value
     * @param {Array} oldValue
     * @protected
     */
    afterSetTickmarks(value, oldValue) {
        // todo
    }

    /**
     * Triggered after the value config got changed
     * @param {Number} value
     * @param {Number} oldValue
     */
    afterSetValue(value, oldValue) {
        this.addValueToLabel();
        super.afterSetValue(value, oldValue)
    }

    /**
     * Update label with value
     */
    addValueToLabel() {
        let me = this;

        if (me.showResultInLabel) {
            me.getLabelEl().innerHTML = `[${me.value}] ` + me.labelText
        }
    }
}

Neo.setupClass(Range);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Range);


/***/ }),

/***/ "./src/selection/HelixModel.mjs":
/*!**************************************!*\
  !*** ./src/selection/HelixModel.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Model_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Model.mjs */ "./src/selection/Model.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * A selection model intended to use for Neo.component.Helix
 * @class Neo.selection.HelixModel
 * @extends Neo.selection.Model
 */
class HelixModel extends _Model_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.selection.HelixModel'
         * @protected
         */
        className: 'Neo.selection.HelixModel',
        /**
         * @member {String} ntype='selection-helixmodel'
         * @protected
         */
        ntype: 'selection-helixmodel',
        /**
         * True to stay in the same column when navigating with the up and down keys,
         * otherwise you will navigate to the next / prev column when moving out
         * @member {boolean} stayInColumn=false
         */
        stayInColumn: false
    }

    /**
     * Override to not apply a domListener
     */
    addDomListener() {}

    /**
     *
     */
    onContainerClick() {
        let me       = this,
            {view}   = me,
            oldItems = [...me.items],
            deltas   = [];

        me.items.forEach(item => {
            deltas.push({
                id : view.getItemVnodeId(item),
                cls: {
                    add   : [],
                    remove: ['neo-selected']
                }
            });
        });

        me.items.splice(0, me.items.length);

        Neo.applyDeltas(view.appName, deltas).then(() => {
            me.fire('selectionChange', me.items, oldItems)
        })
    }

    /**
     * @param {Object} data
     */
    onItemClick(data) {
        let i      = 0,
            len    = data.path.length,
            {view} = this,
            key;

        for (; i < len; i++) {
            if (data.path[i].cls.includes('neo-helix-item')) {
                key = view.getItemId(data.path[i].id);
                this.select(key);

                view.fire('select', {
                    record: view.store.get(key)
                });

                break
            }
        }
    }

    /**
     * @param {Object} data
     */
    onKeyDownDown(data) {
        this.onNavKeyColumn(1)
    }

    /**
     * @param {Object} data
     */
    onKeyDownLeft(data) {
        this.onNavKeyRow(-1)
    }

    /**
     * @param {Object} data
     */
    onKeyDownRight(data) {
        this.onNavKeyRow(1)
    }

    /**
     * @param {Object} data
     */
    onKeyDownUp(data) {
        this.onNavKeyColumn(-1)
    }

    /**
     * @param {Number} step=1
     */
    onNavKeyColumn(step=1) {
        let me                   = this,
            {stayInColumn, view} = me,
            {store}              = view,
            selected             = me.items[0],
            countRecords         = store.getCount(),
            itemsPerRow          = parseInt(360 / view.itemAngle),
            index, record;

        step *= itemsPerRow;

        if (selected) {
            index = store.indexOf(selected) + step
        } else {
            index = 0
        }

        if (index < 0) {
            if (!stayInColumn) {
                index++
            }
            while (index < (countRecords - itemsPerRow)) {
                index += itemsPerRow
            }
        } else if (index >= countRecords) {
            if (!stayInColumn) {
                index--
            }
            while (index >= itemsPerRow) {
                index -= itemsPerRow
            }
        }

        record = store.getAt(index);

        me.select(record[store.keyProperty]);

        view.fire('select', {
            record
        })
    }

    /**
     * @param {Number} step=1
     */
    onNavKeyRow(step=1) {
        let me           = this,
            {view}       = me,
            {store}      = view,
            selected     = me.items[0],
            countRecords = store.getCount(),
            index, record;

        if (selected) {
            index = store.indexOf(selected) + step
        } else {
            index = 0
        }

        if (index < 0) {
            index = countRecords - 1
        } else if (index >= countRecords) {
            index = 0
        }

        record = store.getAt(index);

        me.select(record[store.keyProperty]);

        view.fire('select', {
            record
        })
    }

    /**
     * @param {Neo.component.Base} component
     */
    register(component) {
        super.register(component);

        let me         = this,
            {id, view} = me;

        view.on({
            containerClick: me.onContainerClick,
            itemClick     : me.onItemClick,
            scope         : me
        });

        view.keys?._keys.push(
            {fn: 'onKeyDownDown'  ,key: 'Down'  ,scope: id},
            {fn: 'onKeyDownLeft'  ,key: 'Left'  ,scope: id},
            {fn: 'onKeyDownRight' ,key: 'Right' ,scope: id},
            {fn: 'onKeyDownUp'    ,key: 'Up'    ,scope: id}
        )
    }

    /**
     * @param {String} itemId
     * @param {Boolean} [toggleSelection=true]
     */
    select(itemId, toggleSelection=true) {
        let me         = this,
            view       = me.view,
            isSelected = toggleSelection === false ? false : me.items.includes(itemId),
            items      = me.items,
            oldItems   = [...items],
            deltas     = [],
            listenerId;

        // a select() call can happen before the view is registered
        if (!view) {
            return;
        }

        if (!view.mounted) {
            listenerId = view.on('mounted', () => {
                view.un('mounted', listenerId);

                setTimeout(() => {
                    me.select(itemId, toggleSelection);
                }, 300)
            })
        }

        if (me.singleSelect) {
            items.forEach(item => {
                if (item.id !== itemId) {
                    deltas.push({
                        id : view.getItemVnodeId(item),
                        cls: {
                            add   : [],
                            remove: ['neo-selected']
                        }
                    });
                }
            });

            items.splice(0, items.length);
        }

        deltas.push({
            id : view.getItemVnodeId(itemId),
            cls: {
                add   : isSelected ? [] : ['neo-selected'],
                remove: isSelected ? ['neo-selected'] : []
            }
        });

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"][isSelected ? 'remove' : 'add'](items, itemId);

        // console.log('select', itemId, isSelected, items);

        view.mounted && Neo.currentWorker.promiseMessage('main', {
            action : 'updateDom',
            appName: view.appName,
            deltas
        }).then(() => {
            view.onSelect?.(items);
            me.fire('selectionChange', items, oldItems);
        });
    }

    /**
     *
     */
    unregister() {
        let me   = this,
            id   = me.id,
            view = me.view;

        view.keys?.removeKeys([
            {fn: 'onKeyDownDown'  ,key: 'Down'  ,scope: id},
            {fn: 'onKeyDownLeft'  ,key: 'Left'  ,scope: id},
            {fn: 'onKeyDownRight' ,key: 'Right' ,scope: id},
            {fn: 'onKeyDownUp'    ,key: 'Up'    ,scope: id}
        ]);

        super.unregister();
    }
}

Neo.setupClass(HelixModel);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HelixModel);


/***/ }),

/***/ "./src/util/Matrix.mjs":
/*!*****************************!*\
  !*** ./src/util/Matrix.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * Utility class for Matrix based calculations
 * @class Neo.util.Matrix
 * @extends Neo.core.Base
 */
class Matrix extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.Matrix'
         * @protected
         */
        className: 'Neo.util.Matrix',
        /**
         * @member {Array|null} items_=null
         * @protected
         */
        items_: null
    }

    /**
     * shortcut for getElement
     */
    e(i, j) {
        return this.getElement(i, j)
    }

    /**
     * Returns the element (i,j) of the matrix
     * @param i
     * @param j
     * @returns {*}
     */
    getElement(i, j) {
        let items = this.items;

        if (i < 1 || i > items.length || j < 1 || j > items[0].length) {
            return null
        }

        return items[i - 1][j - 1]
    }

    /**
     *
     */
    getTransformStyle() {
        let me = this,
            p  = 10, // precision
            s;

        s  = 'matrix3d(';
        s += `${me.e(1,1).toFixed(p)},${me.e(1,2).toFixed(p)},${me.e(1,3).toFixed(p)},${me.e(1,4).toFixed(p)},`;
        s += `${me.e(2,1).toFixed(p)},${me.e(2,2).toFixed(p)},${me.e(2,3).toFixed(p)},${me.e(2,4).toFixed(p)},`;
        s += `${me.e(3,1).toFixed(p)},${me.e(3,2).toFixed(p)},${me.e(3,3).toFixed(p)},${me.e(3,4).toFixed(p)},`;
        s += `${me.e(4,1).toFixed(p)},${me.e(4,2).toFixed(p)},${me.e(4,3).toFixed(p)},${me.e(4,4).toFixed(p)}`;
        s += ')';

        return s
    }

    /**
     * Returns the result of multiplying the matrix from the right by the argument.
     * @param matrix
     * @returns {*}
     */
    multiply(matrix) {
        let me      = this,
            M       = matrix.items || matrix,
            {items} = me,
            ni      = items.length,
            ki      = ni,
            kj      = M[0].length,
            cols    = items[0].length,
            els     = [],
            c, i, j, nc, nj, sum;

        do {
            i      = ki - ni;
            els[i] = [];
            nj     = kj;

            do { j = kj - nj;
                sum = 0;
                nc  = cols;

                do {
                    c = cols - nc;
                    sum += items[i][c] * M[c][j]
                } while (--nc);
                els[i][j] = sum
            } while (--nj);
        } while (--ni);

        matrix.items = els;

        return matrix
    }

    /**
     * @param t
     * @returns {*}
     */
    static rotateX(t) {
        let c = Math.cos(t),
            s = Math.sin(t);

        return [
            [1, 0,  0, 0],
            [0, c, -s, 0],
            [0, s,  c, 0],
            [0, 0,  0, 1]
        ]
    }

    /**
     * @param t
     * @returns {*}
     */
    static rotateY(t) {
        let c = Math.cos(t),
            s = Math.sin(t);

        return [
            [c, 0, -s, 0],
            [0, 1,  0, 0],
            [s, 0,  c, 0],
            [0, 0,  0, 1]
        ]
    }

    /**
     * @param t
     * @returns {*}
     */
    static rotateZ(t) {
        let c = Math.cos(t),
            s = Math.sin(t);

        return [
            [c, -s, 0, 0],
            [s,  c, 0, 0],
            [0,  0, 1, 0],
            [0,  0, 0, 1]
        ]
    }

    /**
     * shortcut for multiply
     */
    x(matrix) {
        return this.multiply(matrix)
    }
}

Neo.setupClass(Matrix);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Matrix);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19jb21wb25lbnRfSGVsaXhfbWpzLXNyY19jb250YWluZXJfUGFuZWxfbWpzLXNyY19mb3JtX2ZpZWxkX1JhbmdlX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXNEO0FBQ2I7QUFDaUI7QUFDVDtBQUNEO0FBQ0E7O0FBRWhEO0FBQ0EsOENBQThDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpREFBUztBQUM3QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNB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O0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUI7QUFDN0csZ0JBQWdCLHFCQUFxQixHQUFHLHFCQUFxQixHQUFHLHFCQUFxQixHQUFHLHFCQUFxQjtBQUM3RyxnQkFBZ0IscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCO0FBQzdHLGdCQUFnQixxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUI7QUFDN0c7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGNBQWM7QUFDZCxVQUFVOztBQUVWOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUVBQWUsTUFBTSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb21wb25lbnQvSGVsaXgubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29udGFpbmVyL1BhbmVsLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2Zvcm0vZmllbGQvUmFuZ2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvc2VsZWN0aW9uL0hlbGl4TW9kZWwubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdXRpbC9NYXRyaXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDbGFzc1N5c3RlbVV0aWwgZnJvbSAnLi4vdXRpbC9DbGFzc1N5c3RlbS5tanMnO1xuaW1wb3J0IENvbXBvbmVudCAgICAgICBmcm9tICcuL0Jhc2UubWpzJztcbmltcG9ydCBIZWxpeE1vZGVsICAgICAgZnJvbSAnLi4vc2VsZWN0aW9uL0hlbGl4TW9kZWwubWpzJztcbmltcG9ydCBNYXRyaXggICAgICAgICAgZnJvbSAnLi4vdXRpbC9NYXRyaXgubWpzJztcbmltcG9ydCBOZW9BcnJheSAgICAgICAgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IFN0b3JlICAgICAgICAgICBmcm9tICcuLi9kYXRhL1N0b3JlLm1qcyc7XG5cbmNvbnN0IGl0ZW1zTW91bnRlZCA9IFN5bWJvbC5mb3IoJ2l0ZW1zTW91bnRlZCcpO1xuY29uc3QgbG9ja1doZWVsICAgID0gU3ltYm9sLmZvcignbG9ja1doZWVsJyk7IC8vIHdlIGNhbiBub3QgdXNlIGl0ZW1zTW91bnRlZCwgc2luY2UgaXQgaXMgY29ubmVjdGVkIHRvIG9uU29ydCgpXG5cbi8qKlxuICogQGNsYXNzIE5lby5jb21wb25lbnQuSGVsaXhcbiAqIEBleHRlbmRzIE5lby5jb21wb25lbnQuQmFzZVxuICovXG5jbGFzcyBIZWxpeCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29tcG9uZW50LkhlbGl4J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29tcG9uZW50LkhlbGl4JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2hlbGl4J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2hlbGl4JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBiYWNrZ3JvdW5kIGNvbG9yIG9mIHRoZSBoZWxpeCBjb250YWluZXJcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBiYWNrZ3JvdW5kQ29sb3JfPScjMDAwMDAwJ1xuICAgICAgICAgKi9cbiAgICAgICAgYmFja2dyb3VuZENvbG9yXzogJyMwMDAwMDAnLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJhY2tncm91bmQgaW1hZ2Ugb2YgdGhlIGhlbGl4IGNvbnRhaW5lclxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGJhY2tncm91bmRJbWFnZV89JydcbiAgICAgICAgICovXG4gICAgICAgIGJhY2tncm91bmRJbWFnZV86ICcnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8taGVsaXgnXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8taGVsaXgnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpZHMgb2YgZXhwYW5kZWQgaXRlbXMgd2lsbCBnZXQgc3RvcmVkIGhlcmVcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl9IGNsb25lZEl0ZW1zPVtdXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsb25lZEl0ZW1zOiBbXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB2ZXJ0aWNhbCBkZWx0YSBiZXR3ZWVuIGVhY2ggaGVsaXggaXRlbSAoaW5jcmVhc2luZyB0aGlzIHZhbHVlIHdpbGwgY3JlYXRlIGEgc3BpcmFsKVxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGRlbHRhWV89MS41XG4gICAgICAgICAqL1xuICAgICAgICBkZWx0YVlfOiAxLjUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNdWx0aXNlbGVjdGlvbnMgd2lsbCByZWR1Y2UgdGhlIG9wYWNpdHkgYW5kIHNldCB0aGlzIGZsYWcgdG8gdHJ1ZVxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBkaW1tZWRfPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBkaW1tZWRfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE11bHRpc2VsZWN0aW9ucyB3aWxsIHJlZHVjZSB0aGUgb3BhY2l0eSBhbmQgc2V0IHRoaXMgZmxhZyB0byB0cnVlXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gZGltbWVkTWF4T3BhY2l0eV89MC4zXG4gICAgICAgICAqL1xuICAgICAgICBkaW1tZWRNYXhPcGFjaXR5XzogMC4zLFxuICAgICAgICAvKipcbiAgICAgICAgICogTXVsdGlzZWxlY3Rpb25zIHdpbGwgcmVkdWNlIHRoZSBvcGFjaXR5IGFuZCBzZXQgdGhpcyBmbGFnIHRvIHRydWVcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBkaW1tZWRNaW5PcGFjaXR5Xz0wLjJcbiAgICAgICAgICovXG4gICAgICAgIGRpbW1lZE1pbk9wYWNpdHlfOiAwLjIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGYWxzZSB3aWxsIHByZXZlbnQgaXRlbXMgZnJvbSBnZXR0aW5nIHNlbGVjdGVkLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBkaXNhYmxlU2VsZWN0aW9uPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBkaXNhYmxlU2VsZWN0aW9uIDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGbGlwIGltYWdlcyBieSAxODDCsCBmb3IgYSBub3QgbWlycm9yZWQgaW5uZXIgdmlld1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBmbGlwcGVkXz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgZmxpcHBlZF86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSB0byByb3RhdGUgdGhlIGhlbGl4IHdoZW4gdXNpbmcga2V5bmF2LCBzbyB0aGF0IHRoZSBzZWxlY3RlZCBpdGVtcyBzdGF5cyBpbiBmcm9udFxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBmb2xsb3dTZWxlY3Rpb25fPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBmb2xsb3dTZWxlY3Rpb25fOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByZWNvcmQgZmllbGQgY29udGFpbmluZyB0aGUgaW1hZ2UgZGF0YS5cbiAgICAgICAgICogTmVzdGVkIGZpZWxkcyBhcmUgc3VwcG9ydGVkIChlLmcuIGF1dGhvci5pbWFnZSlcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBpbWFnZUZpZWxkPSdpbWFnZSdcbiAgICAgICAgICovXG4gICAgICAgIGltYWdlRmllbGQ6ICdpbWFnZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGF0aCB0byB0aGUgaW1hZ2VzIGZvbGRlclxuICAgICAgICAgKiBXaWxsIGdldCBzZXQgaW5zaWRlIGFmdGVyU2V0V2luZG93SWQoKSB0byBhdm9pZCBpc3N1ZXMgaW5zaWRlIHRoZSB3ZWJwYWNrIGJ1aWxkc1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gaW1hZ2VTb3VyY2VfPU5lby5jb25maWcucmVzb3VyY2VzUGF0aCArICdleGFtcGxlcy8nXG4gICAgICAgICAqL1xuICAgICAgICBpbWFnZVNvdXJjZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbW91bnQgb2YgaXRlbXMgcGVyIHJvdyAoY2lyY2xlKSAtPiAzNjDCsCAvIDEwID0gMzZcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBpdGVtQW5nbGVfPThcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1BbmdsZV86IDgsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGl0ZW1UcGxfXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtVHBsXzpcbiAgICAgICAge2NsczogWydzdXJmYWNlJywgJ25lby1oZWxpeC1pdGVtJ10sIHN0eWxlOiB7fSwgdGFiSW5kZXg6ICctMScsIGNuOiBbXG4gICAgICAgICAgICB7dGFnOiAnaW1nJywgY2xzOiBbJ2NvbnRhY3QtaXRlbSddfVxuICAgICAgICBdfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB1bmlxdWUgcmVjb3JkIGZpZWxkIGNvbnRhaW5pbmcgdGhlIGlkLlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGtleVByb3BlcnR5PSdpZCdcbiAgICAgICAgICovXG4gICAgICAgIGtleVByb3BlcnR5OiAnaWQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkaXRpb25hbCB1c2VkIGtleXMgZm9yIHRoZSBzZWxlY3Rpb24gbW9kZWxcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBrZXlzXG4gICAgICAgICAqL1xuICAgICAgICBrZXlzOiB7XG4gICAgICAgICAgICAnRW50ZXInOiAnb25LZXlEb3duRW50ZXInLFxuICAgICAgICAgICAgJ1NwYWNlJzogJ29uS2V5RG93blNwYWNlJ1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogV2Ugc3RvcmUgb25lIGluc3RhbmNlIG9mIHRoZSBtYXRyaXggaGVyZSB0byBhdm9pZCBjcmVhdGluZyBuZXcgb25lcyBvbiBlYWNoIHJlZnJlc2ggb3BlcmF0aW9uXG4gICAgICAgICAqIEBtZW1iZXIge05lby51dGlsLk1hdHJpeHxudWxsfSBtYXRyaXg9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBtYXRyaXg6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWF4IGFtb3VudCBvZiBzdG9yZSBpdGVtcyB0byBzaG93XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gbWF4SXRlbXNfPTMwMFxuICAgICAgICAgKi9cbiAgICAgICAgbWF4SXRlbXNfOiAzMDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWF4IG9wYWNpdHkgZm9yIGl0ZW1zIGluc2lkZSB0aGUgZm9yZWdyb3VuZFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IG1heE9wYWNpdHlfPTAuOFxuICAgICAgICAgKi9cbiAgICAgICAgbWF4T3BhY2l0eV86IDAuOCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtYXggb3BhY2l0eSBmb3IgaXRlbXMgaW5zaWRlIHRoZSBiYWNrZ3JvdW5kXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gbWluT3BhY2l0eV89MC4zXG4gICAgICAgICAqL1xuICAgICAgICBtaW5PcGFjaXR5XzogMC4zLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHpvb21pbmcgZmFjdG9yIHdoaWNoIHJlcGxhY2VzIHRoZSBkZWZhdWx0IHdoZWVsRGVsdGEuXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gbW91c2VXaGVlbERlbHRhWD01XG4gICAgICAgICAqL1xuICAgICAgICBtb3VzZVdoZWVsRGVsdGFYOiA1LFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHpvb21pbmcgZmFjdG9yIHdoaWNoIHJlcGxhY2VzIHRoZSBkZWZhdWx0IHdoZWVsRGVsdGEuXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gbW91c2VXaGVlbERlbHRhWT01MFxuICAgICAgICAgKi9cbiAgICAgICAgbW91c2VXaGVlbERlbHRhWTogNTAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgd2hldGhlciB0aGUgbW91c2Ugd2hlZWwgc2hvdWxkIGNoYW5nZSB0aGUgdHJhbnNsYXRlWiB2YWx1ZSBmb3Igem9vbWluZ1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBtb3VzZVdoZWVsRW5hYmxlZF89dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgbW91c2VXaGVlbEVuYWJsZWRfOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIERPTSBlbGVtZW50IG9mZnNldEhlaWdodCBvZiB0aGUgdG9wIGxldmVsIGRpdi5cbiAgICAgICAgICogR2V0cyBmZXRjaGVkIGFmdGVyIHRoZSBoZWxpeCBnb3QgbW91bnRlZC5cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IG9mZnNldEhlaWdodD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG9mZnNldEhlaWdodDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBET00gZWxlbWVudCBvZmZzZXRXaWR0aCBvZiB0aGUgdG9wIGxldmVsIGRpdi5cbiAgICAgICAgICogR2V0cyBmZXRjaGVkIGFmdGVyIHRoZSBoZWxpeCBnb3QgbW91bnRlZC5cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IG9mZnNldFdpZHRoPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgb2Zmc2V0V2lkdGg6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGVyc3BlY3RpdmUgb2YgdGhlIEhlbGl4IHZpZXcgaW4gcHhcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBwZXJzcGVjdGl2ZV89ODAwXG4gICAgICAgICAqL1xuICAgICAgICBwZXJzcGVjdGl2ZV86IDgwMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByYWRpdXMgb2YgdGhlIEhlbGl4IGluIHB4XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gcmFkaXVzXz0xNTAwXG4gICAgICAgICAqL1xuICAgICAgICByYWRpdXNfOiAxNTAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHJvdGF0aW9uQW5nbGUgb2YgdGhlIEhlbGl4IGluIGRlZ3JlZXNcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSByb3RhdGlvbkFuZ2xlXz03ODBcbiAgICAgICAgICovXG4gICAgICAgIHJvdGF0aW9uQW5nbGVfOiA3ODAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZSBzdG9yZSBvbmUgaW5zdGFuY2Ugb2YgdGhlIHJvdGF0aW9uIG1hdHJpeCBoZXJlIHRvIGF2b2lkIGNyZWF0aW5nIG5ldyBvbmVzIG9uIGVhY2ggcmVmcmVzaCBvcGVyYXRpb25cbiAgICAgICAgICogQG1lbWJlciB7TmVvLnV0aWwuTWF0cml4fG51bGx9IHJvdGF0aW9uTWF0cml4PW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcm90YXRpb25NYXRyaXg6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIGRpc3BsYXlzIHRoZSBmaXJzdCAmIGxhc3QgbmFtZSByZWNvcmQgZmllbGRzIGJlbG93IGFuIGV4cGFuZGVkIGl0ZW1cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2hvd0Nsb25lSW5mbz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBzaG93Q2xvbmVJbmZvOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG5hbWUgb2YgdGhlIENTUyBydWxlIGZvciBzZWxlY3RlZCBpdGVtc1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHNlbGVjdGVkSXRlbUNscz0nbmVvLXNlbGVjdGVkJ1xuICAgICAgICAgKi9cbiAgICAgICAgc2VsZWN0ZWRJdGVtQ2xzOiAnbmVvLXNlbGVjdGVkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHVzZXMgdGhlIHNlbGVjdGlvbi5IZWxpeE1vZGVsIGJ5IGRlZmF1bHRcbiAgICAgICAgICogQG1lbWJlciB7TmVvLnNlbGVjdGlvbi5IZWxpeE1vZGVsfG51bGx9IHNlbGVjdGlvbk1vZGVsXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBzZWxlY3Rpb25Nb2RlbF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc3RvcmUgaW5zdGFuY2Ugb3IgY2xhc3MgY29udGFpbmluZyB0aGUgZGF0YSBmb3IgdGhlIGdhbGxlcnkgaXRlbXNcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmRhdGEuU3RvcmV8bnVsbH0gc3RvcmVfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHN0b3JlXzogbnVsbCwgLy8gdG9kbzogdXNlIGEgc3RvcmUgb25jZSBjb2xsZWN0aW9ucyBhcmUgaW50ZWdyYXRlZFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNldFRpbWVvdXQoKSBpZHMgZm9yIGNhbGxzIHdoaWNoIGNhbiBnZXQgY2FuY2VsbGVkXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5fSB0cmFuc2l0aW9uVGltZW91dHM9W11cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdHJhbnNpdGlvblRpbWVvdXRzOiBbXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0cmFuc2xhdGVYIGdldHMgaW5jbHVkZWQgaW50byBlYWNoIGhlbGl4IGl0ZW1cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSB0cmFuc2xhdGVYXz00MDBcbiAgICAgICAgICovXG4gICAgICAgIHRyYW5zbGF0ZVhfOiA0MDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHJhbnNsYXRlWCB2YWx1ZSBnZXRzIGluY2x1ZGVkIGludG8gZWFjaCBoZWxpeCBpdGVtXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gdHJhbnNsYXRlWV89LTM1MFxuICAgICAgICAgKi9cbiAgICAgICAgdHJhbnNsYXRlWV86IC0zNTAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHJhbnNsYXRlWCB2YWx1ZSBnZXRzIGluY2x1ZGVkIGludG8gZWFjaCBoZWxpeCBpdGVtXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gdHJhbnNsYXRlWl89LTUwMDBcbiAgICAgICAgICovXG4gICAgICAgIHRyYW5zbGF0ZVpfOiAtNTAwMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB1cmwgZm9yIHRoZSBzdG9yZSB0byBsb2FkIHRoZSBkYXRhXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gdXJsXz0nLi4vcmVzb3VyY2VzL2V4YW1wbGVzL2RhdGEvYWlfY29udGFjdHMuanNvbidcbiAgICAgICAgICovXG4gICAgICAgIHVybF86ICcuLi8uLi9yZXNvdXJjZXMvZXhhbXBsZXMvZGF0YS9haV9jb250YWN0cy5qc29uJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gX3Zkb21cbiAgICAgICAgICovXG4gICAgICAgIF92ZG9tOlxuICAgICAgICB7c3R5bGU6IHt9LCB0YWJJbmRleDogJy0xJywgY246IFtcbiAgICAgICAgICAgIHtjbHM6IFsnY29udGFpbmVyJ10sIHN0eWxlOiB7fSwgY246IFtcbiAgICAgICAgICAgICAgICB7Y2xzOiBbJ2dyb3VwJ10sIGNuOiBbXSwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMSwgdHJhbnNmb3JtOiAnbWF0cml4M2QoMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgNDYxLCA0NTIuNSwgLTEwMDcwMCwgMSknfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF19XG4gICAgICAgIF19XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZVtpdGVtc01vdW50ZWRdID0gZmFsc2U7XG4gICAgICAgIG1lW2xvY2tXaGVlbF0gICAgPSB0cnVlO1xuXG4gICAgICAgIG1lLmFkZERvbUxpc3RlbmVycyh7XG4gICAgICAgICAgICBjbGljayAgICA6IG1lLm9uQ2xpY2ssXG4gICAgICAgICAgICB0b3VjaG1vdmU6IG1lLm9uVG91Y2hNb3ZlLFxuICAgICAgICAgICAgd2hlZWwgICAgOiBtZS5vbk1vdXNlV2hlZWwsXG4gICAgICAgICAgICBzY29wZSAgICA6IG1lXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBmb2xsb3dTZWxlY3Rpb24gY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRGb2xsb3dTZWxlY3Rpb24odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCB7Y2xzfSA9IHRoaXM7XG5cbiAgICAgICAgTmVvQXJyYXlbdmFsdWUgPyAnYWRkJyA6ICdyZW1vdmUnXShjbHMsICduZW8tZm9sbG93LXNlbGVjdGlvbicpO1xuICAgICAgICB0aGlzLmNscyA9IGNsc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZmxpcHBlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEZsaXBwZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMuYXBwbHlJdGVtVHJhbnNpdGlvbnModGhpcy5yZWZyZXNoLCAxMDAwKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaW1hZ2VTb3VyY2UgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEltYWdlU291cmNlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChvbGRWYWx1ZSkge1xuICAgICAgICAgICAgbWUuZ2V0SXRlbXNSb290KCkuY24gPSBbXTtcbiAgICAgICAgICAgIG1lLmNyZWF0ZUl0ZW1zKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbWF4SXRlbSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNYXhJdGVtcyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAodmFsdWUgJiYgbWUucmVuZGVyZWQpIHtcbiAgICAgICAgICAgIGlmIChvbGRWYWx1ZSA+IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbWUuZGVzdHJveUl0ZW1zKHZhbHVlLCBvbGRWYWx1ZSAtIHZhbHVlKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZS5jcmVhdGVJdGVtcyhvbGRWYWx1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbW91bnRlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB2YWx1ZSAmJiB0aGlzLmdldE9mZnNldFZhbHVlcygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBwZXJzcGVjdGl2ZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRQZXJzcGVjdGl2ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUubW91bnRlZCkge1xuICAgICAgICAgICAgTmVvLmFwcGx5RGVsdGFzKG1lLmFwcE5hbWUsIHtcbiAgICAgICAgICAgICAgICBpZCAgIDogbWUudmRvbS5pZCxcbiAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBwZXJzcGVjdGl2ZTogdmFsdWUgKyAncHgnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLnVwZGF0ZUNsb25lVHJhbnNsYXRlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc2VsZWN0aW9uTW9kZWwgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOZW8uc2VsZWN0aW9uLk1vZGVsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLnNlbGVjdGlvbi5Nb2RlbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTZWxlY3Rpb25Nb2RlbCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlZCAmJiB2YWx1ZS5yZWdpc3Rlcih0aGlzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdXJsIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFVybCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUucmVuZGVyZWQpIHtcbiAgICAgICAgICAgIG1lLmRlc3Ryb3lJdGVtcygpO1xuICAgICAgICAgICAgbWUubG9hZERhdGEoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB3aW5kb3dJZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRXaW5kb3dJZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRXaW5kb3dJZCh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5pbWFnZVNvdXJjZSA9IE5lby5jb25maWcucmVzb3VyY2VzUGF0aCArICdleGFtcGxlcy8nXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0gYW5pbWF0aW9uVGltZVxuICAgICAqIEBwYXJhbSBjYWxsYmFja1BhcmFtXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFwcGx5SXRlbVRyYW5zaXRpb25zKGNhbGxiYWNrLCBhbmltYXRpb25UaW1lLCBjYWxsYmFja1BhcmFtKSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIHtpZH0gPSBtZSxcbiAgICAgICAgICAgIGNscyAgPSAnbmVvLXRyYW5zaXRpb24tJyArIGFuaW1hdGlvblRpbWUsXG4gICAgICAgICAgICB0aW1lb3V0SWQ7XG5cbiAgICAgICAgbWUudHJhbnNpdGlvblRpbWVvdXRzLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoaXRlbSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUudHJhbnNpdGlvblRpbWVvdXRzLnNwbGljZSgwLCBtZS50cmFuc2l0aW9uVGltZW91dHMubGVuZ3RoKTtcblxuICAgICAgICBpZiAobWUubW91bnRlZCkge1xuICAgICAgICAgICAgTmVvLmFwcGx5RGVsdGFzKG1lLmFwcE5hbWUsIHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBjbHM6IHtcbiAgICAgICAgICAgICAgICAgICAgYWRkICAgOiBbY2xzXSxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlOiBbXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG1lLCBbY2FsbGJhY2tQYXJhbV0pO1xuXG4gICAgICAgICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZShtZS50cmFuc2l0aW9uVGltZW91dHMsIHRpbWVvdXRJZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgTmVvLmFwcGx5RGVsdGFzKG1lLmFwcE5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkICAgOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmU6IFtjbHNdXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSwgYW5pbWF0aW9uVGltZSArIDIwMCk7XG5cbiAgICAgICAgICAgICAgICBtZS50cmFuc2l0aW9uVGltZW91dHMucHVzaCh0aW1lb3V0SWQpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBiZWZvcmVHZXRJdGVtVHBsKCkge1xuICAgICAgICByZXR1cm4gTmVvLmNsb25lKHRoaXMuX2l0ZW1UcGwsIHRydWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgc2VsZWN0aW9uTW9kZWwgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge05lby5zZWxlY3Rpb24uTW9kZWx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uc2VsZWN0aW9uLk1vZGVsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRTZWxlY3Rpb25Nb2RlbCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWU/LmRlc3Ryb3koKTtcblxuICAgICAgICByZXR1cm4gQ2xhc3NTeXN0ZW1VdGlsLmJlZm9yZVNldEluc3RhbmNlKHZhbHVlLCBIZWxpeE1vZGVsLCB7XG4gICAgICAgICAgICBsaXN0ZW5lcnM6IHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25DaGFuZ2U6IHRoaXMub25TZWxlY3Rpb25DaGFuZ2UsXG4gICAgICAgICAgICAgICAgc2NvcGUgICAgICAgICAgOiB0aGlzXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgc3RvcmUgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLlN0b3JlfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5TdG9yZXxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRTdG9yZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBvbGRWYWx1ZT8uZGVzdHJveSgpO1xuXG4gICAgICAgIHJldHVybiBDbGFzc1N5c3RlbVV0aWwuYmVmb3JlU2V0SW5zdGFuY2UodmFsdWUsIFN0b3JlLCB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMgIDoge1xuICAgICAgICAgICAgICAgIGxvYWQgOiBtZS5vblN0b3JlTG9hZCxcbiAgICAgICAgICAgICAgICBzb3J0IDogbWUub25Tb3J0LFxuICAgICAgICAgICAgICAgIHNjb3BlOiBtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBhbiBvcGFjaXR5IGdyYWRpZW50IGJhc2VkIG9uIHRoZSBpdGVtIHJvdGF0aW9uIGFuZ2xlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIGNhbGN1bGF0ZU9wYWNpdHkoaXRlbSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHttYXhPcGFjaXR5LCBtaW5PcGFjaXR5fSA9IG1lLFxuICAgICAgICAgICAgZGVsdGFPcGFjaXR5ICAgICAgICAgICAgID0gbWF4T3BhY2l0eSAtIG1pbk9wYWNpdHksXG4gICAgICAgICAgICBhbmdsZSwgb3BhY2l0eSwgb3BhY2l0eUZhY3RvcjtcblxuICAgICAgICBpZiAoZGVsdGFPcGFjaXR5ID09PSAwKSB7XG4gICAgICAgICAgICBvcGFjaXR5ID0gbWF4T3BhY2l0eTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFuZ2xlID0gaXRlbS5yb3RhdGlvbkFuZ2xlICUgMzYwO1xuXG4gICAgICAgICAgICB3aGlsZSAoYW5nbGUgPCAwKSB7XG4gICAgICAgICAgICAgICAgYW5nbGUgKz0gMzYwXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdoaWxlIChhbmdsZSA+IDE4MCkge1xuICAgICAgICAgICAgICAgIGFuZ2xlID0gMzYwIC0gYW5nbGVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbm9uLWxpbmVhciBkaXN0cmlidXRpb24sIHNpbmNlIHRoZSBhbmdsZSBkb2VzIG5vdCBtYXRjaCBkZWx0YSB0cmFuc2xhdGVaXG4gICAgICAgICAgICBvcGFjaXR5RmFjdG9yID0gMSAtIE1hdGguc2luKGFuZ2xlICogTWF0aC5QSSAvIDM2MCk7XG5cbiAgICAgICAgICAgIG9wYWNpdHkgPSBtaW5PcGFjaXR5ICsgZGVsdGFPcGFjaXR5ICogb3BhY2l0eUZhY3RvclxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9wYWNpdHlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBnZXQgZGlmZmVyZW50IGl0ZW0tbWFya3Vwc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2ZG9tSXRlbVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB2ZG9tSXRlbVxuICAgICAqL1xuICAgIGNyZWF0ZUl0ZW0odmRvbUl0ZW0sIHJlY29yZCwgaW5kZXgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICB2ZG9tSXRlbS5pZCA9IG1lLmdldEl0ZW1Wbm9kZUlkKHJlY29yZFttZS5rZXlQcm9wZXJ0eV0pO1xuXG4gICAgICAgIHZkb21JdGVtLmNuWzBdLmlkICA9IG1lLmdldEl0ZW1Wbm9kZUlkKHJlY29yZFttZS5rZXlQcm9wZXJ0eV0pICsgJ19pbWcnO1xuICAgICAgICB2ZG9tSXRlbS5jblswXS5zcmMgPSBtZS5pbWFnZVNvdXJjZSArIE5lby5ucyhtZS5pbWFnZUZpZWxkLCBmYWxzZSwgcmVjb3JkKTtcblxuICAgICAgICByZXR1cm4gdmRvbUl0ZW1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0SW5kZXhdIHRoZSBzdGFydCBpbmRleCBmb3IgY3JlYXRpbmcgaXRlbXMsXG4gICAgICogZS5nLiBpbmNyZWFzaW5nIG1heEl0ZW1zIG9ubHkgbmVlZHMgdG8gY3JlYXRlIHRoZSBuZXcgb25lc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtcyhzdGFydEluZGV4KSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICB7ZGVsdGFZLCBpdGVtQW5nbGUsIG1hdHJpeCwgcmFkaXVzLCByb3RhdGlvbkFuZ2xlLCB0cmFuc2xhdGVYLCB0cmFuc2xhdGVZLCB0cmFuc2xhdGVaLCB2ZG9tfSA9IG1lLFxuICAgICAgICAgICAgZ3JvdXAgPSBtZS5nZXRJdGVtc1Jvb3QoKSxcbiAgICAgICAgICAgIGkgICAgID0gc3RhcnRJbmRleCB8fCAwLFxuICAgICAgICAgICAgbGVuICAgPSBNYXRoLm1pbihtZS5tYXhJdGVtcywgbWUuc3RvcmUuaXRlbXMubGVuZ3RoKSxcbiAgICAgICAgICAgIGFuZ2xlLCBpdGVtLCBtYXRyaXhJdGVtcywgdHJhbnNmb3JtU3R5bGUsIHZkb21JdGVtLCBjLCBzLCB4LCB5LCB6O1xuXG4gICAgICAgIGlmICghbWUubW91bnRlZCkge1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJJZCA9IG1lLm9uKCdtb3VudGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1lLnVuKCdtb3VudGVkJywgbGlzdGVuZXJJZCk7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmNyZWF0ZUl0ZW1zKHN0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgICAgIH0sIDEwMClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IG1lLnN0b3JlLml0ZW1zW2ldO1xuXG4gICAgICAgICAgICAgICAgYW5nbGUgPSAtcm90YXRpb25BbmdsZSArIGkgKiBpdGVtQW5nbGU7XG5cbiAgICAgICAgICAgICAgICBzID0gTWF0aC5zaW4oYW5nbGUgKiBNYXRoLlBJIC8gMTgwKTtcbiAgICAgICAgICAgICAgICBjID0gTWF0aC5jb3MoYW5nbGUgKiBNYXRoLlBJIC8gMTgwKTtcblxuICAgICAgICAgICAgICAgIHggPSByYWRpdXMgKiBzIC0gMzAwICsgdHJhbnNsYXRlWDtcbiAgICAgICAgICAgICAgICB5ID0gLTQwMCArIGFuZ2xlICogZGVsdGFZICsgdHJhbnNsYXRlWTtcbiAgICAgICAgICAgICAgICB6ID0gOTk4MDAgKyByYWRpdXMgKiBjICsgdHJhbnNsYXRlWjtcblxuICAgICAgICAgICAgICAgIG1hdHJpeEl0ZW1zID0gW1xuICAgICAgICAgICAgICAgICAgICBbYywgMCwgLXMsIDBdLFxuICAgICAgICAgICAgICAgICAgICBbMCwgMSwgIDAsIDBdLFxuICAgICAgICAgICAgICAgICAgICBbcywgMCwgIGMsIDBdLFxuICAgICAgICAgICAgICAgICAgICBbeCwgeSwgIHosIDFdXG4gICAgICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgICAgIGlmICghbWF0cml4KSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLm1hdHJpeCA9IG1hdHJpeCA9IE5lby5jcmVhdGUoTWF0cml4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogbWF0cml4SXRlbXNcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXRyaXguaXRlbXMgPSBtYXRyaXhJdGVtc1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybVN0eWxlID0gbWF0cml4LmdldFRyYW5zZm9ybVN0eWxlKCk7XG5cbiAgICAgICAgICAgICAgICB2ZG9tSXRlbSA9IG1lLmNyZWF0ZUl0ZW0obWUuaXRlbVRwbCwgaXRlbSwgaSk7XG5cbiAgICAgICAgICAgICAgICBpdGVtLnJvdGF0aW9uQW5nbGUgID0gYW5nbGU7XG4gICAgICAgICAgICAgICAgaXRlbS50cmFuc2Zvcm1TdHlsZSA9IHRyYW5zZm9ybVN0eWxlO1xuXG4gICAgICAgICAgICAgICAgdmRvbUl0ZW0uIHN0eWxlID0gdmRvbUl0ZW0uc3R5bGUgfHwge307XG5cbiAgICAgICAgICAgICAgICB2ZG9tSXRlbS5zdHlsZS5vcGFjaXR5ICAgPSBtZS5jYWxjdWxhdGVPcGFjaXR5KGl0ZW0pO1xuICAgICAgICAgICAgICAgIHZkb21JdGVtLnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVN0eWxlO1xuXG4gICAgICAgICAgICAgICAgZ3JvdXAuY24ucHVzaCh2ZG9tSXRlbSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWVbbG9ja1doZWVsXSA9IHRydWU7XG5cbiAgICAgICAgICAgIG1lLnByb21pc2VVcGRhdGUodmRvbSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgbWVbaXRlbXNNb3VudGVkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgbWUuZmlyZSgnaXRlbXNNb3VudGVkJyk7XG5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbWVbbG9ja1doZWVsXSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgfSwgMjAwKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBkZXN0cm95Q2xvbmVzKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtzdG9yZX0gICAgICA9IG1lLFxuICAgICAgICAgICAgZGVsdGFzICAgICAgID0gW10sXG4gICAgICAgICAgICByZW1vdmVEZWx0YXMgPSBbXSxcbiAgICAgICAgICAgIGlkLCByZWNvcmQ7XG5cbiAgICAgICAgaWYgKG1lLmNsb25lZEl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG1lLmNsb25lZEl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgaWQgICAgID0gbWUuZ2V0SXRlbUlkKGl0ZW0uaWQpO1xuICAgICAgICAgICAgICAgIHJlY29yZCA9IHN0b3JlLmdldChpZCk7XG5cbiAgICAgICAgICAgICAgICByZWNvcmQuZXhwYW5kZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGRlbHRhcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaWQgICA6IGl0ZW0uaWQsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5ICA6IHJlY29yZC5vcGFjaXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiByZWNvcmQudHJhbnNmb3JtU3R5bGVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmVtb3ZlRGVsdGFzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZCAgICA6IGl0ZW0uaWQsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogJ3JlbW92ZU5vZGUnXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS5jbG9uZWRJdGVtcyA9IFtdO1xuXG4gICAgICAgICAgICBOZW8uYXBwbHlEZWx0YXMobWUuYXBwTmFtZSwgZGVsdGFzKS50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBOZW8uYXBwbHlEZWx0YXMobWUuYXBwTmFtZSwgcmVtb3ZlRGVsdGFzKVxuICAgICAgICAgICAgICAgIH0sIDY1MClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0SW5kZXhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFthbW91bnRJdGVtc11cbiAgICAgKi9cbiAgICBkZXN0cm95SXRlbXMoc3RhcnRJbmRleCwgYW1vdW50SXRlbXMpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5nZXRJdGVtc1Jvb3QoKS5jbi5zcGxpY2Uoc3RhcnRJbmRleCB8fCAwLCBhbW91bnRJdGVtcyB8fCBtZS5zdG9yZS5nZXRDb3VudCgpKTtcbiAgICAgICAgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhIGNsb25lIG9mIGFuIGl0ZW0gdG8gdGhlIHRvcCBsZWZ0IGNvcm5lclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpdGVtSWRcbiAgICAgKi9cbiAgICBleHBhbmRJdGVtKGl0ZW1JZCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7YXBwTmFtZSwgc3RvcmV9ID0gbWUsXG4gICAgICAgICAgICByZWNvcmQgICAgICAgICAgID0gc3RvcmUuZ2V0KGl0ZW1JZCksXG4gICAgICAgICAgICBpbmRleCAgICAgICAgICAgID0gc3RvcmUuaW5kZXhPZihpdGVtSWQpLFxuICAgICAgICAgICAgaXNFeHBhbmRlZCAgICAgICA9ICEhcmVjb3JkLmV4cGFuZGVkLFxuICAgICAgICAgICAgZ3JvdXAgICAgICAgICAgICA9IG1lLmdldEl0ZW1zUm9vdCgpLFxuICAgICAgICAgICAgaXRlbVZkb20gICAgICAgICA9IE5lby5jbG9uZShncm91cC5jbltpbmRleF0sIHRydWUpO1xuXG4gICAgICAgIG1lLmRlc3Ryb3lDbG9uZXMoKTtcblxuICAgICAgICBpZiAoaXNFeHBhbmRlZCAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmVjb3JkLmV4cGFuZGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgaXRlbVZkb20uaWQgPSBpdGVtVmRvbS5pZCArICdfX2Nsb25lJztcbiAgICAgICAgICAgIGl0ZW1WZG9tLnN0eWxlLnRyYW5zZm9ybSA9IHJlY29yZC50cmFuc2Zvcm1TdHlsZTtcbiAgICAgICAgICAgIE5lb0FycmF5LmFkZChpdGVtVmRvbS5jbHMsICduZW8tdHJhbnNpdGlvbi02MDAnKTtcbiAgICAgICAgICAgIGRlbGV0ZSBpdGVtVmRvbS50YWJJbmRleDtcblxuICAgICAgICAgICAgaXRlbVZkb20uY25bMF0uaWQgPSBpdGVtVmRvbS5jblswXS5pZCArICdfX2Nsb25lJztcblxuICAgICAgICAgICAgaWYgKG1lLnNob3dDbG9uZUluZm8pIHtcbiAgICAgICAgICAgICAgICBpdGVtVmRvbS5jbi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgY2xzICAgICAgOiBbJ2NvbnRhY3QtbmFtZSddLFxuICAgICAgICAgICAgICAgICAgICBpbm5lckhUTUw6IHJlY29yZC5maXJzdG5hbWUgKyAnICcgKyByZWNvcmQubGFzdG5hbWVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBOZW8udmRvbS5IZWxwZXIuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBhcHBOYW1lLFxuICAgICAgICAgICAgICAgIGF1dG9Nb3VudCAgOiB0cnVlLFxuICAgICAgICAgICAgICAgIHBhcmVudElkICAgOiBncm91cC5pZCxcbiAgICAgICAgICAgICAgICBwYXJlbnRJbmRleDogc3RvcmUuZ2V0Q291bnQoKSxcbiAgICAgICAgICAgICAgICAuLi5pdGVtVmRvbVxuICAgICAgICAgICAgfSkudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgICAgICBtZS5jbG9uZWRJdGVtcy5wdXNoKGl0ZW1WZG9tKTtcblxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBOZW8uYXBwbHlEZWx0YXMoYXBwTmFtZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQgICA6IGl0ZW1WZG9tLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5ICA6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBtZS5nZXRDbG9uZVRyYW5zZm9ybSgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSwgNTApXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRDbG9uZVRyYW5zZm9ybSgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgdHJhbnNsYXRlWCA9IChtZS5vZmZzZXRXaWR0aCAgLSAxMzUwKSAvIDMsXG4gICAgICAgICAgICB0cmFuc2xhdGVZID0gKG1lLm9mZnNldEhlaWdodCAtIDEzMjApIC8gMyxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVogPSAxMDA3MDAgKyBtZS5wZXJzcGVjdGl2ZSAvIDEuNTtcblxuICAgICAgICByZXR1cm4gYG1hdHJpeDNkKDEsMCwwLDAsMCwxLDAsMCwwLDAsMSwwLCR7dHJhbnNsYXRlWH0sJHt0cmFuc2xhdGVZfSwke3RyYW5zbGF0ZVp9LDFgXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZub2RlSWRcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldEl0ZW1JZCh2bm9kZUlkKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludCh2bm9kZUlkLnNwbGl0KCdfXycpWzFdKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZkb20gbm9kZSBjb250YWluaW5nIHRoZSBoZWxpeCBpdGVtc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHZkb21cbiAgICAgKi9cbiAgICBnZXRJdGVtc1Jvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZkb20uY25bMF0uY25bMF1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGlkXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRJdGVtVm5vZGVJZChpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZCArICdfXycgKyBpZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsYXk9MTAwXVxuICAgICAqL1xuICAgIGdldE9mZnNldFZhbHVlcyhkZWxheT0xMDApIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIE5lby5jdXJyZW50V29ya2VyLnByb21pc2VNZXNzYWdlKCdtYWluJywge1xuICAgICAgICAgICAgICAgIGFjdGlvbiAgICA6ICdyZWFkRG9tJyxcbiAgICAgICAgICAgICAgICBhcHBOYW1lICAgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnb2Zmc2V0SGVpZ2h0JywgJ29mZnNldFdpZHRoJ10sXG4gICAgICAgICAgICAgICAgdm5vZGVJZCAgIDogbWUuaWRcbiAgICAgICAgICAgIH0pLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgbWUub2Zmc2V0SGVpZ2h0ID0gZGF0YS5hdHRyaWJ1dGVzLm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgICAgICBtZS5vZmZzZXRXaWR0aCAgPSBkYXRhLmF0dHJpYnV0ZXMub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9LCBkZWxheSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGxvYWREYXRhKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIE5lby5YaHIucHJvbWlzZUpzb24oe1xuICAgICAgICAgICAgaW5zaWRlTmVvOiB0cnVlLFxuICAgICAgICAgICAgdXJsICAgICAgOiBtZS51cmxcbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFcnJvciBmb3IgTmVvLlhoci5yZXF1ZXN0JywgZXJyLCBtZS5pZCk7XG4gICAgICAgIH0pLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICBtZS5zdG9yZS5pdGVtcyA9IGRhdGEuanNvbi5kYXRhO1xuICAgICAgICAgICAgbWUuY3JlYXRlSXRlbXMoKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpdGVtSWRcbiAgICAgKi9cbiAgICBtb3ZlVG9TZWxlY3RlZEl0ZW0oaXRlbUlkKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG4gICAgICAgIG1lLnJvdGF0aW9uQW5nbGUgPSBtZS5zdG9yZS5nZXQoaXRlbUlkKS5yb3RhdGlvbkFuZ2xlICsgbWUucm90YXRpb25BbmdsZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25DbGljayhkYXRhKSB7XG4gICAgICAgIHRoaXMuZmlyZShkYXRhLmlkID09PSB0aGlzLmlkID8gJ2NvbnRhaW5lckNsaWNrJyA6ICdpdGVtQ2xpY2snLCBkYXRhKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25Db25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgc3VwZXIub25Db25zdHJ1Y3RlZCgpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsPy5yZWdpc3Rlcih0aGlzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25LZXlEb3duRW50ZXIoZGF0YSkge1xuICAgICAgICBsZXQgaXRlbSA9IHRoaXMuc2VsZWN0aW9uTW9kZWwuaXRlbXNbMF07XG4gICAgICAgIGl0ZW0gJiYgdGhpcy5leHBhbmRJdGVtKGl0ZW0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbktleURvd25TcGFjZShkYXRhKSB7XG4gICAgICAgIHRoaXMuYXBwbHlJdGVtVHJhbnNpdGlvbnModGhpcy5tb3ZlVG9TZWxlY3RlZEl0ZW0sIDEwMDAsIHRoaXMuc2VsZWN0aW9uTW9kZWwuaXRlbXNbMF0gfHwgMClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uTW91c2VXaGVlbChkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLm1vdXNlV2hlZWxFbmFibGVkICYmICFtZVtsb2NrV2hlZWxdKSB7XG4gICAgICAgICAgICBtZS5fcm90YXRpb25BbmdsZSA9IG1lLnJvdGF0aW9uQW5nbGUgKyAoZGF0YS5kZWx0YVggKiBtZS5tb3VzZVdoZWVsRGVsdGFYKTsgLy8gc2lsZW50IHVwZGF0ZVxuICAgICAgICAgICAgbWUuX3RyYW5zbGF0ZVogICAgPSBtZS50cmFuc2xhdGVaICAgICsgKGRhdGEuZGVsdGFZICogbWUubW91c2VXaGVlbERlbHRhWSk7IC8vIHNpbGVudCB1cGRhdGVcblxuICAgICAgICAgICAgbWUucmVmcmVzaCgpO1xuXG4gICAgICAgICAgICBtZS5maXJlKCdjaGFuZ2VSb3RhdGlvbicsICAgbWUuX3JvdGF0aW9uQW5nbGUpO1xuICAgICAgICAgICAgbWUuZmlyZSgnY2hhbmdlVHJhbnNsYXRlWicsIG1lLl90cmFuc2xhdGVaKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIG9uU2VsZWN0aW9uQ2hhbmdlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5mb2xsb3dTZWxlY3Rpb24gJiYgdmFsdWU/LlswXSkge1xuICAgICAgICAgICAgbWUuYXBwbHlJdGVtVHJhbnNpdGlvbnMobWUubW92ZVRvU2VsZWN0ZWRJdGVtLCAxMDAsIHZhbHVlWzBdKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uU29ydCgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWVbaXRlbXNNb3VudGVkXSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbWUuYXBwbHlJdGVtVHJhbnNpdGlvbnMobWUuc29ydEl0ZW1zLCAxMDAwKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheX0gaXRlbXNcbiAgICAgKi9cbiAgICBvblN0b3JlTG9hZChpdGVtcykge1xuICAgICAgICB0aGlzLmdldEl0ZW1zUm9vdCgpLmNuID0gW107IC8vIHNpbGVudCB1cGRhdGVcbiAgICAgICAgdGhpcy5jcmVhdGVJdGVtcygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvblRvdWNoTW92ZShkYXRhKSB7XG4gICAgICAgIGRhdGEuZGVsdGFYICo9IDEuNTtcbiAgICAgICAgZGF0YS5kZWx0YVkgKj0gMztcblxuICAgICAgICB0aGlzLm9uTW91c2VXaGVlbChkYXRhKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICByZWZyZXNoKCkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGRlbHRhcyA9IFtdLFxuICAgICAgICAgICAge2RlbHRhWSwgZmxpcHBlZCwgaXRlbUFuZ2xlLCBtYXRyaXgsIHJhZGl1cywgcm90YXRpb25BbmdsZSwgcm90YXRpb25NYXRyaXgsIHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVksIHRyYW5zbGF0ZVosIHZkb219ID0gbWUsXG4gICAgICAgICAgICBpbmRleCAgPSAwLFxuICAgICAgICAgICAgbGVuICAgID0gTWF0aC5taW4obWUubWF4SXRlbXMsIG1lLnN0b3JlLmdldENvdW50KCkpLFxuICAgICAgICAgICAgYW5nbGUsIGl0ZW0sIG9wYWNpdHksIHJvdGF0ZVksIHRyYW5zZm9ybVN0eWxlLCB2ZG9tSXRlbSwgYywgcywgeCwgeSwgejtcblxuICAgICAgICBpZiAoZmxpcHBlZCkge1xuICAgICAgICAgICAgcm90YXRlWSA9IE1hdHJpeC5yb3RhdGVZKDE4MCAqIE1hdGguUEkgLyAxODApO1xuXG4gICAgICAgICAgICBpZiAoIXJvdGF0aW9uTWF0cml4KSB7XG4gICAgICAgICAgICAgICAgbWUucm90YXRpb25NYXRyaXggPSByb3RhdGlvbk1hdHJpeCA9IE5lby5jcmVhdGUoTWF0cml4LCB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zOiByb3RhdGVZXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcm90YXRpb25NYXRyaXguaXRlbXMgPSByb3RhdGVZXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW47IGluZGV4KyspIHtcbiAgICAgICAgICAgIGl0ZW0gICAgID0gbWUuc3RvcmUuaXRlbXNbaW5kZXhdO1xuICAgICAgICAgICAgdmRvbUl0ZW0gPSB2ZG9tLmNuWzBdLmNuWzBdLmNuW2luZGV4XTtcblxuICAgICAgICAgICAgYW5nbGUgPSAtcm90YXRpb25BbmdsZSArIGluZGV4ICogaXRlbUFuZ2xlO1xuXG4gICAgICAgICAgICBzID0gTWF0aC5zaW4oYW5nbGUgKiBNYXRoLlBJIC8gMTgwKTtcbiAgICAgICAgICAgIGMgPSBNYXRoLmNvcyhhbmdsZSAqIE1hdGguUEkgLyAxODApO1xuXG4gICAgICAgICAgICB4ID0gIC0zMDAgKyByYWRpdXMgKiBzICAgICAgKyB0cmFuc2xhdGVYO1xuICAgICAgICAgICAgeSA9ICAtNDAwICsgYW5nbGUgICogZGVsdGFZICsgdHJhbnNsYXRlWTtcbiAgICAgICAgICAgIHogPSA5OTgwMCArIHJhZGl1cyAqIGMgICAgICArIHRyYW5zbGF0ZVo7XG5cbiAgICAgICAgICAgIG1hdHJpeC5pdGVtcyA9IFtcbiAgICAgICAgICAgICAgICBbYywgMCwgLXMsIDBdLFxuICAgICAgICAgICAgICAgIFswLCAxLCAgMCwgMF0sXG4gICAgICAgICAgICAgICAgW3MsIDAsICBjLCAwXSxcbiAgICAgICAgICAgICAgICBbeCwgeSwgIHosIDFdXG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICBpZiAoZmxpcHBlZCkge1xuICAgICAgICAgICAgICAgIG1hdHJpeCA9IHJvdGF0aW9uTWF0cml4LngobWF0cml4KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cmFuc2Zvcm1TdHlsZSA9IG1hdHJpeC5nZXRUcmFuc2Zvcm1TdHlsZSgpO1xuICAgICAgICAgICAgbWF0cml4LmRlc3Ryb3koKTtcblxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihpdGVtLCB7XG4gICAgICAgICAgICAgICAgcm90YXRpb25BbmdsZTogYW5nbGUsXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtU3R5bGVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBvcGFjaXR5ID0gbWUuY2FsY3VsYXRlT3BhY2l0eShpdGVtKTtcbiAgICAgICAgICAgIGl0ZW0ub3BhY2l0eSA9IG9wYWNpdHk7XG5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaXRlbSwge1xuICAgICAgICAgICAgICAgIG9wYWNpdHksXG4gICAgICAgICAgICAgICAgcm90YXRpb25BbmdsZTogYW5nbGUsXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtU3R5bGVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkZWx0YXMucHVzaCh7XG4gICAgICAgICAgICAgICAgaWQgICA6IG1lLmdldEl0ZW1Wbm9kZUlkKGl0ZW1bbWUua2V5UHJvcGVydHldKSxcbiAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5LFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybVN0eWxlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIE5lby5hcHBseURlbHRhcyhtZS5hcHBOYW1lLCBkZWx0YXMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHJlZnJlc2hJZk1vdW50ZWQoKSB7XG4gICAgICAgIHRoaXMubW91bnRlZCAmJiB0aGlzLnJlZnJlc2goKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgc29ydEl0ZW1zKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZGVsdGFzICAgPSBbXSxcbiAgICAgICAgICAgIHBhcmVudElkID0gbWUudmRvbS5jblswXS5jblswXS5pZCxcbiAgICAgICAgICAgIGkgICAgICAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgICAgID0gTWF0aC5taW4obWUubWF4SXRlbXMsIG1lLnN0b3JlLmdldENvdW50KCkpO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGRlbHRhcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdtb3ZlTm9kZScsXG4gICAgICAgICAgICAgICAgaWQgICAgOiBtZS5nZXRJdGVtVm5vZGVJZChtZS5zdG9yZS5pdGVtc1tpXVttZS5rZXlQcm9wZXJ0eV0pLFxuICAgICAgICAgICAgICAgIGluZGV4IDogaSxcbiAgICAgICAgICAgICAgICBwYXJlbnRJZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIE5lby5hcHBseURlbHRhcyhtZS5hcHBOYW1lLCBkZWx0YXMpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgbWUucmVmcmVzaCgpXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB1cGRhdGVDbG9uZVRyYW5zbGF0ZSgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBhZnRlckRlbHRhcyAgPSBbXSxcbiAgICAgICAgICAgIGRlbHRhcyAgICAgICA9IFtdLFxuICAgICAgICAgICAgdGltZW91dElkLCB0cmFuc2Zvcm07XG5cbiAgICAgICAgaWYgKG1lLmNsb25lZEl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybSA9IG1lLmdldENsb25lVHJhbnNmb3JtKHRydWUpO1xuXG4gICAgICAgICAgICBtZS50cmFuc2l0aW9uVGltZW91dHMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoaXRlbSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS5jbG9uZWRJdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIGRlbHRhcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaWQgOiBpdGVtLmlkLFxuICAgICAgICAgICAgICAgICAgICBjbHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZCAgIDogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmU6IFsnbmVvLXRyYW5zaXRpb24tNjAwJ11cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGFmdGVyRGVsdGFzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZCA6IGl0ZW0uaWQsXG4gICAgICAgICAgICAgICAgICAgIGNsczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkICAgOiBbJ25lby10cmFuc2l0aW9uLTYwMCddLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlOiBbXVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgTmVvLmFwcGx5RGVsdGFzKG1lLmFwcE5hbWUsIGRlbHRhcykudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZShtZS50cmFuc2l0aW9uVGltZW91dHMsIHRpbWVvdXRJZCk7XG4gICAgICAgICAgICAgICAgICAgIE5lby5hcHBseURlbHRhcyhtZS5hcHBOYW1lLCBhZnRlckRlbHRhcylcbiAgICAgICAgICAgICAgICB9LCAyMDApO1xuXG4gICAgICAgICAgICAgICAgbWUudHJhbnNpdGlvblRpbWVvdXRzLnB1c2godGltZW91dElkKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgY2ZnID0ge2VudW1lcmFibGU6IGZhbHNlLCB2YWx1ZTogSGVsaXgucHJvdG90eXBlLnJlZnJlc2hJZk1vdW50ZWR9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhIZWxpeC5wcm90b3R5cGUsIHtcbiAgICBhZnRlclNldERlbHRhWSAgICAgICA6IGNmZyxcbiAgICBhZnRlclNldEl0ZW1BbmdsZSAgICA6IGNmZyxcbiAgICBhZnRlclNldE1heE9wYWNpdHkgICA6IGNmZyxcbiAgICBhZnRlclNldE1pbk9wYWNpdHkgICA6IGNmZyxcbiAgICBhZnRlclNldFJhZGl1cyAgICAgICA6IGNmZyxcbiAgICBhZnRlclNldFJvdGF0aW9uQW5nbGU6IGNmZyxcbiAgICBhZnRlclNldFRyYW5zbGF0ZVggICA6IGNmZyxcbiAgICBhZnRlclNldFRyYW5zbGF0ZVkgICA6IGNmZyxcbiAgICBhZnRlclNldFRyYW5zbGF0ZVogICA6IGNmZ1xufSk7XG5cbk5lby5zZXR1cENsYXNzKEhlbGl4KTtcblxuZXhwb3J0IGRlZmF1bHQgSGVsaXg7XG4iLCJpbXBvcnQgQ29udGFpbmVyIGZyb20gJy4vQmFzZS5tanMnO1xuaW1wb3J0IFRvb2xiYXIgICBmcm9tICcuLi90b29sYmFyL0Jhc2UubWpzJztcblxuLyoqXG4gKiBBbiBleHRlbmRlZCBDb250YWluZXIgc3VwcG9ydGluZyBtdWx0aXBsZSBkb2NrZWQgaGVhZGVyIHRvb2xiYXJzXG4gKiBAY2xhc3MgTmVvLmNvbnRhaW5lci5QYW5lbFxuICogQGV4dGVuZHMgTmVvLmNvbnRhaW5lci5CYXNlXG4gKi9cbmNsYXNzIFBhbmVsIGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb250YWluZXIuUGFuZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb250YWluZXIuUGFuZWwnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ncGFuZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAncGFuZWwnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tcGFuZWwnLCduZW8tY29udGFpbmVyJ11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLXBhbmVsJywgJ25lby1jb250YWluZXInXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gY29udGFpbmVyQ29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGNvbnRhaW5lckNvbmZpZzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gaGVhZGVyRGVmYXVsdHM9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgaGVhZGVyRGVmYXVsdHM6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheX0gaGVhZGVycz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBoZWFkZXJzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBpdGVtcz17bnR5cGU6ICd2Ym94JywgYWxpZ246ICdzdHJldGNoJ31cbiAgICAgICAgICovXG4gICAgICAgIF9sYXlvdXQ6IHtcbiAgICAgICAgICAgIG50eXBlOiAndmJveCcsXG4gICAgICAgICAgICBhbGlnbjogJ3N0cmV0Y2gnXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB2ZXJ0aWNhbEhlYWRlcnNGaXJzdD1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdmVydGljYWxIZWFkZXJzRmlyc3Q6IGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuaGFzSGVhZGVycygpICYmIG1lLnZlcnRpY2FsSGVhZGVyc0ZpcnN0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBtZS5sYXlvdXQgPSB7XG4gICAgICAgICAgICAgICAgbnR5cGU6ICdoYm94JyxcbiAgICAgICAgICAgICAgICBhbGlnbjogJ3N0cmV0Y2gnXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGhlYWRlciB0aGUgaGVhZGVyIGNvbmZpZ1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUhlYWRlckNvbmZpZyhoZWFkZXIpIHtcbiAgICAgICAgaWYgKE5lby50eXBlT2YoaGVhZGVyKSA9PT0gJ05lb0luc3RhbmNlJykge1xuICAgICAgICAgICAgcmV0dXJuIGhlYWRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjb25maWcgPSB7XG4gICAgICAgICAgICBmbGV4OiAnMCAxIGF1dG8nXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFoZWFkZXIubW9kdWxlICYmICFoZWFkZXIubnR5cGUpIHtcbiAgICAgICAgICAgIGNvbmZpZy5jbHMgICA9IFsnbmVvLXBhbmVsLWhlYWRlci10b29sYmFyJywgJ25lby10b29sYmFyJ107XG4gICAgICAgICAgICBjb25maWcubnR5cGUgPSAndG9vbGJhcic7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGVhZGVyLnRleHQpIHtcbiAgICAgICAgICAgIGNvbmZpZy5pdGVtcyA9IFt7XG4gICAgICAgICAgICAgICAgbnR5cGU6ICdsYWJlbCcsXG4gICAgICAgICAgICAgICAgY2xzICA6IFsnbmVvLXBhbmVsLWhlYWRlci10ZXh0JywgJ25lby1sYWJlbCddLFxuICAgICAgICAgICAgICAgIHRleHQgOiBoZWFkZXIudGV4dFxuICAgICAgICAgICAgfV07XG5cbiAgICAgICAgICAgIGRlbGV0ZSBoZWFkZXIudGV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFzc3VtaW5nIGFsbCBsYWJlbHMgaW5zaWRlIGEgUGFuZWwgSGVhZGVyIGFyZSBtZWFudCB0byBiZSB0aXRsZXMgLT4gbG9vayB0aGUgc2FtZSB3YXlcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVyLml0ZW1zKSkge1xuICAgICAgICAgICAgaGVhZGVyLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0ubnR5cGUgPT09ICdsYWJlbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5jbHMgPSBbJ25lby1wYW5lbC1oZWFkZXItdGV4dCcsICduZW8tbGFiZWwnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7Li4uY29uZmlnLCAuLi5oZWFkZXJ9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtcygpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb250YWluZXJDb25maWcgPSBtZS5jb250YWluZXJDb25maWc7XG5cbiAgICAgICAgaWYgKCFtZS5oYXNIZWFkZXJzKCkpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lckNvbmZpZyAmJiBtZS5zZXQoY29udGFpbmVyQ29uZmlnKTtcbiAgICAgICAgICAgIHN1cGVyLmNyZWF0ZUl0ZW1zKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgaGYgICAgICAgICAgICAgICAgICAgPSBtZS52ZXJ0aWNhbEhlYWRlcnNGaXJzdCA9PT0gZmFsc2UsXG4gICAgICAgICAgICAgICAgaGVhZGVycyAgICAgICAgICAgICAgPSBtZS5oZWFkZXJzIHx8IFtdLFxuICAgICAgICAgICAgICAgIGJvdHRvbUhlYWRlcnMgICAgICAgID0gaGVhZGVycy5maWx0ZXIoaGVhZGVyID0+IHtyZXR1cm4gaGVhZGVyLmRvY2sgPT09IChoZiA/J2JvdHRvbSc6ICdyaWdodCcpfSksXG4gICAgICAgICAgICAgICAgbGVmdEhlYWRlcnMgICAgICAgICAgPSBoZWFkZXJzLmZpbHRlcihoZWFkZXIgPT4ge3JldHVybiBoZWFkZXIuZG9jayA9PT0gKGhmID8nbGVmdCcgIDogJ3RvcCcpfSksXG4gICAgICAgICAgICAgICAgcmlnaHRIZWFkZXJzICAgICAgICAgPSBoZWFkZXJzLmZpbHRlcihoZWFkZXIgPT4ge3JldHVybiBoZWFkZXIuZG9jayA9PT0gKGhmID8ncmlnaHQnIDogJ2JvdHRvbScpfSksXG4gICAgICAgICAgICAgICAgdG9wSGVhZGVycyAgICAgICAgICAgPSBoZWFkZXJzLmZpbHRlcihoZWFkZXIgPT4ge3JldHVybiBoZWFkZXIuZG9jayA9PT0gKGhmID8ndG9wJyAgIDogJ2xlZnQnKX0pLFxuICAgICAgICAgICAgICAgIGhhc0hvcml6b250YWxIZWFkZXJzID0gYm90dG9tSGVhZGVycy5sZW5ndGggPiAwIHx8IHRvcEhlYWRlcnMgIC5sZW5ndGggPiAwLFxuICAgICAgICAgICAgICAgIGhhc1ZlcnRpY2FsSGVhZGVycyAgID0gbGVmdEhlYWRlcnMgIC5sZW5ndGggPiAwIHx8IHJpZ2h0SGVhZGVycy5sZW5ndGggPiAwLFxuICAgICAgICAgICAgICAgIHtpdGVtc30gICAgICAgICAgICAgID0gbWUsXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbEl0ZW1zICAgICAgPSBbXSxcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEl0ZW1zICAgICAgICA9IFtdLFxuICAgICAgICAgICAgICAgIGNvbmZpZztcblxuICAgICAgICAgICAgdG9wSGVhZGVycy5mb3JFYWNoKGhlYWRlciA9PiB7XG4gICAgICAgICAgICAgICAgdmVydGljYWxJdGVtcy5wdXNoKFBhbmVsLmNyZWF0ZUhlYWRlckNvbmZpZyhoZWFkZXIpKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChoYXNWZXJ0aWNhbEhlYWRlcnMgJiYgKGhmICYmIGhhc0hvcml6b250YWxIZWFkZXJzIHx8ICFoZiAmJiBoYXNIb3Jpem9udGFsSGVhZGVycykpIHtcbiAgICAgICAgICAgICAgICBsZWZ0SGVhZGVycy5mb3JFYWNoKGhlYWRlciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGhvcml6b250YWxJdGVtcy5wdXNoKFBhbmVsLmNyZWF0ZUhlYWRlckNvbmZpZyhoZWFkZXIpKVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgY29uZmlnID0ge1xuICAgICAgICAgICAgICAgICAgICBudHlwZSAgICAgICA6ICdjb250YWluZXInLFxuICAgICAgICAgICAgICAgICAgICBmbGV4ICAgICAgICA6IDEsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zLFxuICAgICAgICAgICAgICAgICAgICBpdGVtRGVmYXVsdHM6IG1lLml0ZW1EZWZhdWx0cyxcbiAgICAgICAgICAgICAgICAgICAgLi4uY29udGFpbmVyQ29uZmlnXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGhvcml6b250YWxJdGVtcy5wdXNoKHsuLi5tZS5oZWFkZXJEZWZhdWx0cywgLi4uY29uZmlnfSk7XG5cbiAgICAgICAgICAgICAgICByaWdodEhlYWRlcnMuZm9yRWFjaChoZWFkZXIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBob3Jpem9udGFsSXRlbXMucHVzaChQYW5lbC5jcmVhdGVIZWFkZXJDb25maWcoaGVhZGVyKSlcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHZlcnRpY2FsSXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG50eXBlIDogJ2NvbnRhaW5lcicsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zIDogaG9yaXpvbnRhbEl0ZW1zLFxuICAgICAgICAgICAgICAgICAgICBsYXlvdXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG50eXBlOiAoaGYgPyAnaGJveCcgOiAndmJveCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ246ICdzdHJldGNoJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgbnR5cGUgICAgICAgOiAnY29udGFpbmVyJyxcbiAgICAgICAgICAgICAgICAgICAgZmxleCAgICAgICAgOiAxLFxuICAgICAgICAgICAgICAgICAgICBpdGVtcyxcbiAgICAgICAgICAgICAgICAgICAgaXRlbURlZmF1bHRzOiBtZS5pdGVtRGVmYXVsdHMsXG4gICAgICAgICAgICAgICAgICAgIC4uLmNvbnRhaW5lckNvbmZpZ1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEl0ZW1zLnB1c2goey4uLm1lLmhlYWRlckRlZmF1bHRzLCAuLi5jb25maWd9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBib3R0b21IZWFkZXJzLmZvckVhY2goaGVhZGVyID0+IHtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEl0ZW1zLnB1c2goUGFuZWwuY3JlYXRlSGVhZGVyQ29uZmlnKGhlYWRlcikpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbWUuaXRlbXMgPSB2ZXJ0aWNhbEl0ZW1zO1xuXG4gICAgICAgICAgICBtZS5pdGVtRGVmYXVsdHMgPSBudWxsO1xuXG4gICAgICAgICAgICBzdXBlci5jcmVhdGVJdGVtcygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNIZWFkZXJzKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0aGlzLmhlYWRlcnMpICYmIHRoaXMuaGVhZGVycy5sZW5ndGggPiAwXG4gICAgfVxufVxuXG5OZW8uc2V0dXBDbGFzcyhQYW5lbCk7XG5cbmV4cG9ydCBkZWZhdWx0IFBhbmVsO1xuIiwiaW1wb3J0IE51bWJlciBmcm9tICcuL051bWJlci5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZm9ybS5maWVsZC5SYW5nZVxuICogQGV4dGVuZHMgTmVvLmZvcm0uZmllbGQuTnVtYmVyXG4gKi9cbmNsYXNzIFJhbmdlIGV4dGVuZHMgTnVtYmVyIHtcbiAgICAvKipcbiAgICAgKiBSZW1vdmluZyB0aGUgZGVib3VuY2UgZm9yIHJhbmdlIGZpZWxkc1xuICAgICAqIEBtZW1iZXIge09iamVjdH0gZGVsYXlhYmxlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgZGVsYXlhYmxlID0ge31cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmZvcm0uZmllbGQuUmFuZ2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5mb3JtLmZpZWxkLlJhbmdlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3JhbmdlZmllbGQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAncmFuZ2VmaWVsZCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1yYW5nZWZpZWxkJywnbmVvLXRleHRmaWVsZCddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1yYW5nZWZpZWxkJywgJ25lby10ZXh0ZmllbGQnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgc2hvd3MgYSBjbGVhciB0cmlnZ2VyIGluIGNhc2UgdGhlIGZpZWxkIGhhcyBhIG5vbiBlbXB0eSB2YWx1ZS5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gY2xlYXJhYmxlPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhcmFibGU6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVmFsdWUgZm9yIHRoZSBpbnB1dFR5cGVfIHRleHRmaWVsZCBjb25maWdcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBpbnB1dFR5cGU9J3JhbmdlJ1xuICAgICAgICAgKi9cbiAgICAgICAgaW5wdXRUeXBlOiAncmFuZ2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdHJ1ZSwgc2hvd3MgdGhlIHJlc3VsdCBvZiB0aGUgc2xpZGVyIGluIHRoZSBsYWJlbFxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaG93UmVzdWx0SW5MYWJlbD1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgc2hvd1Jlc3VsdEluTGFiZWw6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl9IHRpY2ttYXJrc189W11cbiAgICAgICAgICovXG4gICAgICAgIHRpY2ttYXJrc186IFtdLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gdXNlSW5wdXRFdmVudD1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdXNlSW5wdXRFdmVudDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNhYmxlcyB0aGUgZmllbGQuTnVtYmVyIGJ1dHRvbnNcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gdXNlSW5wdXRFdmVudD1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdXNlU3BpbkJ1dHRvbnM6IGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaW5wdXRFbCA9IG1lLnZkb20uY25bMl07XG5cbiAgICAgICAgaWYgKG1lLnVzZUlucHV0RXZlbnQpIHtcbiAgICAgICAgICAgIG1lLmFkZERvbUxpc3RlbmVycyh7XG4gICAgICAgICAgICAgICAgaW5wdXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZm4gICA6IG1lLm9uSW5wdXRWYWx1ZUNoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgaWQgICA6IG1lLnZkb20uY25bMl0uaWQsXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlOiBtZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5wdXRFbC5jbHMgPSBbJ25lby1yYW5nZWZpZWxkLWlucHV0J107IC8vIHJlcGxhY2UgbmVvLXRleHRmaWVsZC1pbnB1dFxuXG4gICAgICAgIG1lLmFkZFZhbHVlVG9MYWJlbCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB0aWNrbWFya3MgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFRpY2ttYXJrcyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgLy8gdG9kb1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdmFsdWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICovXG4gICAgYWZ0ZXJTZXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5hZGRWYWx1ZVRvTGFiZWwoKTtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGxhYmVsIHdpdGggdmFsdWVcbiAgICAgKi9cbiAgICBhZGRWYWx1ZVRvTGFiZWwoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLnNob3dSZXN1bHRJbkxhYmVsKSB7XG4gICAgICAgICAgICBtZS5nZXRMYWJlbEVsKCkuaW5uZXJIVE1MID0gYFske21lLnZhbHVlfV0gYCArIG1lLmxhYmVsVGV4dFxuICAgICAgICB9XG4gICAgfVxufVxuXG5OZW8uc2V0dXBDbGFzcyhSYW5nZSk7XG5cbmV4cG9ydCBkZWZhdWx0IFJhbmdlO1xuIiwiaW1wb3J0IE1vZGVsICAgIGZyb20gJy4vTW9kZWwubWpzJztcbmltcG9ydCBOZW9BcnJheSBmcm9tICcuLi91dGlsL0FycmF5Lm1qcyc7XG5cbi8qKlxuICogQSBzZWxlY3Rpb24gbW9kZWwgaW50ZW5kZWQgdG8gdXNlIGZvciBOZW8uY29tcG9uZW50LkhlbGl4XG4gKiBAY2xhc3MgTmVvLnNlbGVjdGlvbi5IZWxpeE1vZGVsXG4gKiBAZXh0ZW5kcyBOZW8uc2VsZWN0aW9uLk1vZGVsXG4gKi9cbmNsYXNzIEhlbGl4TW9kZWwgZXh0ZW5kcyBNb2RlbCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uc2VsZWN0aW9uLkhlbGl4TW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5zZWxlY3Rpb24uSGVsaXhNb2RlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdzZWxlY3Rpb24taGVsaXhtb2RlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdzZWxlY3Rpb24taGVsaXhtb2RlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIHRvIHN0YXkgaW4gdGhlIHNhbWUgY29sdW1uIHdoZW4gbmF2aWdhdGluZyB3aXRoIHRoZSB1cCBhbmQgZG93biBrZXlzLFxuICAgICAgICAgKiBvdGhlcndpc2UgeW91IHdpbGwgbmF2aWdhdGUgdG8gdGhlIG5leHQgLyBwcmV2IGNvbHVtbiB3aGVuIG1vdmluZyBvdXRcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn0gc3RheUluQ29sdW1uPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBzdGF5SW5Db2x1bW46IGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdG8gbm90IGFwcGx5IGEgZG9tTGlzdGVuZXJcbiAgICAgKi9cbiAgICBhZGREb21MaXN0ZW5lcigpIHt9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ29udGFpbmVyQ2xpY2soKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7dmlld30gICA9IG1lLFxuICAgICAgICAgICAgb2xkSXRlbXMgPSBbLi4ubWUuaXRlbXNdLFxuICAgICAgICAgICAgZGVsdGFzICAgPSBbXTtcblxuICAgICAgICBtZS5pdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgZGVsdGFzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkIDogdmlldy5nZXRJdGVtVm5vZGVJZChpdGVtKSxcbiAgICAgICAgICAgICAgICBjbHM6IHtcbiAgICAgICAgICAgICAgICAgICAgYWRkICAgOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlOiBbJ25lby1zZWxlY3RlZCddXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLml0ZW1zLnNwbGljZSgwLCBtZS5pdGVtcy5sZW5ndGgpO1xuXG4gICAgICAgIE5lby5hcHBseURlbHRhcyh2aWV3LmFwcE5hbWUsIGRlbHRhcykudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBtZS5maXJlKCdzZWxlY3Rpb25DaGFuZ2UnLCBtZS5pdGVtcywgb2xkSXRlbXMpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkl0ZW1DbGljayhkYXRhKSB7XG4gICAgICAgIGxldCBpICAgICAgPSAwLFxuICAgICAgICAgICAgbGVuICAgID0gZGF0YS5wYXRoLmxlbmd0aCxcbiAgICAgICAgICAgIHt2aWV3fSA9IHRoaXMsXG4gICAgICAgICAgICBrZXk7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGRhdGEucGF0aFtpXS5jbHMuaW5jbHVkZXMoJ25lby1oZWxpeC1pdGVtJykpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSB2aWV3LmdldEl0ZW1JZChkYXRhLnBhdGhbaV0uaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0KGtleSk7XG5cbiAgICAgICAgICAgICAgICB2aWV3LmZpcmUoJ3NlbGVjdCcsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkOiB2aWV3LnN0b3JlLmdldChrZXkpXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbktleURvd25Eb3duKGRhdGEpIHtcbiAgICAgICAgdGhpcy5vbk5hdktleUNvbHVtbigxKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25LZXlEb3duTGVmdChkYXRhKSB7XG4gICAgICAgIHRoaXMub25OYXZLZXlSb3coLTEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbktleURvd25SaWdodChkYXRhKSB7XG4gICAgICAgIHRoaXMub25OYXZLZXlSb3coMSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uS2V5RG93blVwKGRhdGEpIHtcbiAgICAgICAgdGhpcy5vbk5hdktleUNvbHVtbigtMSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RlcD0xXG4gICAgICovXG4gICAgb25OYXZLZXlDb2x1bW4oc3RlcD0xKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7c3RheUluQ29sdW1uLCB2aWV3fSA9IG1lLFxuICAgICAgICAgICAge3N0b3JlfSAgICAgICAgICAgICAgPSB2aWV3LFxuICAgICAgICAgICAgc2VsZWN0ZWQgICAgICAgICAgICAgPSBtZS5pdGVtc1swXSxcbiAgICAgICAgICAgIGNvdW50UmVjb3JkcyAgICAgICAgID0gc3RvcmUuZ2V0Q291bnQoKSxcbiAgICAgICAgICAgIGl0ZW1zUGVyUm93ICAgICAgICAgID0gcGFyc2VJbnQoMzYwIC8gdmlldy5pdGVtQW5nbGUpLFxuICAgICAgICAgICAgaW5kZXgsIHJlY29yZDtcblxuICAgICAgICBzdGVwICo9IGl0ZW1zUGVyUm93O1xuXG4gICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgaW5kZXggPSBzdG9yZS5pbmRleE9mKHNlbGVjdGVkKSArIHN0ZXBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4ID0gMFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgaWYgKCFzdGF5SW5Db2x1bW4pIHtcbiAgICAgICAgICAgICAgICBpbmRleCsrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoaW5kZXggPCAoY291bnRSZWNvcmRzIC0gaXRlbXNQZXJSb3cpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggKz0gaXRlbXNQZXJSb3dcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpbmRleCA+PSBjb3VudFJlY29yZHMpIHtcbiAgICAgICAgICAgIGlmICghc3RheUluQ29sdW1uKSB7XG4gICAgICAgICAgICAgICAgaW5kZXgtLVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGluZGV4ID49IGl0ZW1zUGVyUm93KSB7XG4gICAgICAgICAgICAgICAgaW5kZXggLT0gaXRlbXNQZXJSb3dcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlY29yZCA9IHN0b3JlLmdldEF0KGluZGV4KTtcblxuICAgICAgICBtZS5zZWxlY3QocmVjb3JkW3N0b3JlLmtleVByb3BlcnR5XSk7XG5cbiAgICAgICAgdmlldy5maXJlKCdzZWxlY3QnLCB7XG4gICAgICAgICAgICByZWNvcmRcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RlcD0xXG4gICAgICovXG4gICAgb25OYXZLZXlSb3coc3RlcD0xKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3ZpZXd9ICAgICAgID0gbWUsXG4gICAgICAgICAgICB7c3RvcmV9ICAgICAgPSB2aWV3LFxuICAgICAgICAgICAgc2VsZWN0ZWQgICAgID0gbWUuaXRlbXNbMF0sXG4gICAgICAgICAgICBjb3VudFJlY29yZHMgPSBzdG9yZS5nZXRDb3VudCgpLFxuICAgICAgICAgICAgaW5kZXgsIHJlY29yZDtcblxuICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIGluZGV4ID0gc3RvcmUuaW5kZXhPZihzZWxlY3RlZCkgKyBzdGVwXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmRleCA9IDBcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgIGluZGV4ID0gY291bnRSZWNvcmRzIC0gMVxuICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID49IGNvdW50UmVjb3Jkcykge1xuICAgICAgICAgICAgaW5kZXggPSAwXG4gICAgICAgIH1cblxuICAgICAgICByZWNvcmQgPSBzdG9yZS5nZXRBdChpbmRleCk7XG5cbiAgICAgICAgbWUuc2VsZWN0KHJlY29yZFtzdG9yZS5rZXlQcm9wZXJ0eV0pO1xuXG4gICAgICAgIHZpZXcuZmlyZSgnc2VsZWN0Jywge1xuICAgICAgICAgICAgcmVjb3JkXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudFxuICAgICAqL1xuICAgIHJlZ2lzdGVyKGNvbXBvbmVudCkge1xuICAgICAgICBzdXBlci5yZWdpc3Rlcihjb21wb25lbnQpO1xuXG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtpZCwgdmlld30gPSBtZTtcblxuICAgICAgICB2aWV3Lm9uKHtcbiAgICAgICAgICAgIGNvbnRhaW5lckNsaWNrOiBtZS5vbkNvbnRhaW5lckNsaWNrLFxuICAgICAgICAgICAgaXRlbUNsaWNrICAgICA6IG1lLm9uSXRlbUNsaWNrLFxuICAgICAgICAgICAgc2NvcGUgICAgICAgICA6IG1lXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZpZXcua2V5cz8uX2tleXMucHVzaChcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93bkRvd24nICAsa2V5OiAnRG93bicgICxzY29wZTogaWR9LFxuICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duTGVmdCcgICxrZXk6ICdMZWZ0JyAgLHNjb3BlOiBpZH0sXG4gICAgICAgICAgICB7Zm46ICdvbktleURvd25SaWdodCcgLGtleTogJ1JpZ2h0JyAsc2NvcGU6IGlkfSxcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93blVwJyAgICAsa2V5OiAnVXAnICAgICxzY29wZTogaWR9XG4gICAgICAgIClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaXRlbUlkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbdG9nZ2xlU2VsZWN0aW9uPXRydWVdXG4gICAgICovXG4gICAgc2VsZWN0KGl0ZW1JZCwgdG9nZ2xlU2VsZWN0aW9uPXRydWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgdmlldyAgICAgICA9IG1lLnZpZXcsXG4gICAgICAgICAgICBpc1NlbGVjdGVkID0gdG9nZ2xlU2VsZWN0aW9uID09PSBmYWxzZSA/IGZhbHNlIDogbWUuaXRlbXMuaW5jbHVkZXMoaXRlbUlkKSxcbiAgICAgICAgICAgIGl0ZW1zICAgICAgPSBtZS5pdGVtcyxcbiAgICAgICAgICAgIG9sZEl0ZW1zICAgPSBbLi4uaXRlbXNdLFxuICAgICAgICAgICAgZGVsdGFzICAgICA9IFtdLFxuICAgICAgICAgICAgbGlzdGVuZXJJZDtcblxuICAgICAgICAvLyBhIHNlbGVjdCgpIGNhbGwgY2FuIGhhcHBlbiBiZWZvcmUgdGhlIHZpZXcgaXMgcmVnaXN0ZXJlZFxuICAgICAgICBpZiAoIXZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdmlldy5tb3VudGVkKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcklkID0gdmlldy5vbignbW91bnRlZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICB2aWV3LnVuKCdtb3VudGVkJywgbGlzdGVuZXJJZCk7XG5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbWUuc2VsZWN0KGl0ZW1JZCwgdG9nZ2xlU2VsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9LCAzMDApXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lLnNpbmdsZVNlbGVjdCkge1xuICAgICAgICAgICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5pZCAhPT0gaXRlbUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkIDogdmlldy5nZXRJdGVtVm5vZGVJZChpdGVtKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZCAgIDogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlOiBbJ25lby1zZWxlY3RlZCddXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdGVtcy5zcGxpY2UoMCwgaXRlbXMubGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbHRhcy5wdXNoKHtcbiAgICAgICAgICAgIGlkIDogdmlldy5nZXRJdGVtVm5vZGVJZChpdGVtSWQpLFxuICAgICAgICAgICAgY2xzOiB7XG4gICAgICAgICAgICAgICAgYWRkICAgOiBpc1NlbGVjdGVkID8gW10gOiBbJ25lby1zZWxlY3RlZCddLFxuICAgICAgICAgICAgICAgIHJlbW92ZTogaXNTZWxlY3RlZCA/IFsnbmVvLXNlbGVjdGVkJ10gOiBbXVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBOZW9BcnJheVtpc1NlbGVjdGVkID8gJ3JlbW92ZScgOiAnYWRkJ10oaXRlbXMsIGl0ZW1JZCk7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3NlbGVjdCcsIGl0ZW1JZCwgaXNTZWxlY3RlZCwgaXRlbXMpO1xuXG4gICAgICAgIHZpZXcubW91bnRlZCAmJiBOZW8uY3VycmVudFdvcmtlci5wcm9taXNlTWVzc2FnZSgnbWFpbicsIHtcbiAgICAgICAgICAgIGFjdGlvbiA6ICd1cGRhdGVEb20nLFxuICAgICAgICAgICAgYXBwTmFtZTogdmlldy5hcHBOYW1lLFxuICAgICAgICAgICAgZGVsdGFzXG4gICAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdmlldy5vblNlbGVjdD8uKGl0ZW1zKTtcbiAgICAgICAgICAgIG1lLmZpcmUoJ3NlbGVjdGlvbkNoYW5nZScsIGl0ZW1zLCBvbGRJdGVtcyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgdW5yZWdpc3RlcigpIHtcbiAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgaWQgICA9IG1lLmlkLFxuICAgICAgICAgICAgdmlldyA9IG1lLnZpZXc7XG5cbiAgICAgICAgdmlldy5rZXlzPy5yZW1vdmVLZXlzKFtcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93bkRvd24nICAsa2V5OiAnRG93bicgICxzY29wZTogaWR9LFxuICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duTGVmdCcgICxrZXk6ICdMZWZ0JyAgLHNjb3BlOiBpZH0sXG4gICAgICAgICAgICB7Zm46ICdvbktleURvd25SaWdodCcgLGtleTogJ1JpZ2h0JyAsc2NvcGU6IGlkfSxcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93blVwJyAgICAsa2V5OiAnVXAnICAgICxzY29wZTogaWR9XG4gICAgICAgIF0pO1xuXG4gICAgICAgIHN1cGVyLnVucmVnaXN0ZXIoKTtcbiAgICB9XG59XG5cbk5lby5zZXR1cENsYXNzKEhlbGl4TW9kZWwpO1xuXG5leHBvcnQgZGVmYXVsdCBIZWxpeE1vZGVsO1xuIiwiaW1wb3J0IEJhc2UgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5cbi8qKlxuICogVXRpbGl0eSBjbGFzcyBmb3IgTWF0cml4IGJhc2VkIGNhbGN1bGF0aW9uc1xuICogQGNsYXNzIE5lby51dGlsLk1hdHJpeFxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBNYXRyaXggZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby51dGlsLk1hdHJpeCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnV0aWwuTWF0cml4JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5fG51bGx9IGl0ZW1zXz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1zXzogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNob3J0Y3V0IGZvciBnZXRFbGVtZW50XG4gICAgICovXG4gICAgZShpLCBqKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEVsZW1lbnQoaSwgailcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBlbGVtZW50IChpLGopIG9mIHRoZSBtYXRyaXhcbiAgICAgKiBAcGFyYW0gaVxuICAgICAqIEBwYXJhbSBqXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0RWxlbWVudChpLCBqKSB7XG4gICAgICAgIGxldCBpdGVtcyA9IHRoaXMuaXRlbXM7XG5cbiAgICAgICAgaWYgKGkgPCAxIHx8IGkgPiBpdGVtcy5sZW5ndGggfHwgaiA8IDEgfHwgaiA+IGl0ZW1zWzBdLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpdGVtc1tpIC0gMV1baiAtIDFdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBnZXRUcmFuc2Zvcm1TdHlsZSgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIHAgID0gMTAsIC8vIHByZWNpc2lvblxuICAgICAgICAgICAgcztcblxuICAgICAgICBzICA9ICdtYXRyaXgzZCgnO1xuICAgICAgICBzICs9IGAke21lLmUoMSwxKS50b0ZpeGVkKHApfSwke21lLmUoMSwyKS50b0ZpeGVkKHApfSwke21lLmUoMSwzKS50b0ZpeGVkKHApfSwke21lLmUoMSw0KS50b0ZpeGVkKHApfSxgO1xuICAgICAgICBzICs9IGAke21lLmUoMiwxKS50b0ZpeGVkKHApfSwke21lLmUoMiwyKS50b0ZpeGVkKHApfSwke21lLmUoMiwzKS50b0ZpeGVkKHApfSwke21lLmUoMiw0KS50b0ZpeGVkKHApfSxgO1xuICAgICAgICBzICs9IGAke21lLmUoMywxKS50b0ZpeGVkKHApfSwke21lLmUoMywyKS50b0ZpeGVkKHApfSwke21lLmUoMywzKS50b0ZpeGVkKHApfSwke21lLmUoMyw0KS50b0ZpeGVkKHApfSxgO1xuICAgICAgICBzICs9IGAke21lLmUoNCwxKS50b0ZpeGVkKHApfSwke21lLmUoNCwyKS50b0ZpeGVkKHApfSwke21lLmUoNCwzKS50b0ZpeGVkKHApfSwke21lLmUoNCw0KS50b0ZpeGVkKHApfWA7XG4gICAgICAgIHMgKz0gJyknO1xuXG4gICAgICAgIHJldHVybiBzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIG11bHRpcGx5aW5nIHRoZSBtYXRyaXggZnJvbSB0aGUgcmlnaHQgYnkgdGhlIGFyZ3VtZW50LlxuICAgICAqIEBwYXJhbSBtYXRyaXhcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBtdWx0aXBseShtYXRyaXgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgTSAgICAgICA9IG1hdHJpeC5pdGVtcyB8fCBtYXRyaXgsXG4gICAgICAgICAgICB7aXRlbXN9ID0gbWUsXG4gICAgICAgICAgICBuaSAgICAgID0gaXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAga2kgICAgICA9IG5pLFxuICAgICAgICAgICAga2ogICAgICA9IE1bMF0ubGVuZ3RoLFxuICAgICAgICAgICAgY29scyAgICA9IGl0ZW1zWzBdLmxlbmd0aCxcbiAgICAgICAgICAgIGVscyAgICAgPSBbXSxcbiAgICAgICAgICAgIGMsIGksIGosIG5jLCBuaiwgc3VtO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGkgICAgICA9IGtpIC0gbmk7XG4gICAgICAgICAgICBlbHNbaV0gPSBbXTtcbiAgICAgICAgICAgIG5qICAgICA9IGtqO1xuXG4gICAgICAgICAgICBkbyB7IGogPSBraiAtIG5qO1xuICAgICAgICAgICAgICAgIHN1bSA9IDA7XG4gICAgICAgICAgICAgICAgbmMgID0gY29scztcblxuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgYyA9IGNvbHMgLSBuYztcbiAgICAgICAgICAgICAgICAgICAgc3VtICs9IGl0ZW1zW2ldW2NdICogTVtjXVtqXVxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbmMpO1xuICAgICAgICAgICAgICAgIGVsc1tpXVtqXSA9IHN1bVxuICAgICAgICAgICAgfSB3aGlsZSAoLS1uaik7XG4gICAgICAgIH0gd2hpbGUgKC0tbmkpO1xuXG4gICAgICAgIG1hdHJpeC5pdGVtcyA9IGVscztcblxuICAgICAgICByZXR1cm4gbWF0cml4XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHRcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBzdGF0aWMgcm90YXRlWCh0KSB7XG4gICAgICAgIGxldCBjID0gTWF0aC5jb3ModCksXG4gICAgICAgICAgICBzID0gTWF0aC5zaW4odCk7XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIFsxLCAwLCAgMCwgMF0sXG4gICAgICAgICAgICBbMCwgYywgLXMsIDBdLFxuICAgICAgICAgICAgWzAsIHMsICBjLCAwXSxcbiAgICAgICAgICAgIFswLCAwLCAgMCwgMV1cbiAgICAgICAgXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB0XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgc3RhdGljIHJvdGF0ZVkodCkge1xuICAgICAgICBsZXQgYyA9IE1hdGguY29zKHQpLFxuICAgICAgICAgICAgcyA9IE1hdGguc2luKHQpO1xuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBbYywgMCwgLXMsIDBdLFxuICAgICAgICAgICAgWzAsIDEsICAwLCAwXSxcbiAgICAgICAgICAgIFtzLCAwLCAgYywgMF0sXG4gICAgICAgICAgICBbMCwgMCwgIDAsIDFdXG4gICAgICAgIF1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHN0YXRpYyByb3RhdGVaKHQpIHtcbiAgICAgICAgbGV0IGMgPSBNYXRoLmNvcyh0KSxcbiAgICAgICAgICAgIHMgPSBNYXRoLnNpbih0KTtcblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgW2MsIC1zLCAwLCAwXSxcbiAgICAgICAgICAgIFtzLCAgYywgMCwgMF0sXG4gICAgICAgICAgICBbMCwgIDAsIDEsIDBdLFxuICAgICAgICAgICAgWzAsICAwLCAwLCAxXVxuICAgICAgICBdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2hvcnRjdXQgZm9yIG11bHRpcGx5XG4gICAgICovXG4gICAgeChtYXRyaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHkobWF0cml4KVxuICAgIH1cbn1cblxuTmVvLnNldHVwQ2xhc3MoTWF0cml4KTtcblxuZXhwb3J0IGRlZmF1bHQgTWF0cml4O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9