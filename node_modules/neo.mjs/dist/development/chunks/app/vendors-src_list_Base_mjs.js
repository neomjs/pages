export const __webpack_esm_id__ = "vendors-src_list_Base_mjs";
export const __webpack_esm_ids__ = ["vendors-src_list_Base_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./src/list/Base.mjs"
/*!***************************!*\
  !*** ./src/list/Base.mjs ***!
  \***************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _selection_ListModel_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../selection/ListModel.mjs */ "./src/selection/ListModel.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _data_Store_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../data/Store.mjs */ "./src/data/Store.mjs");






/**
 * @class Neo.list.Base
 * @extends Neo.component.Base
 */
class List extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.list.Base'
         * @protected
         */
        className: 'Neo.list.Base',
        /**
         * @member {String} ntype='list'
         * @protected
         */
        ntype: 'list',
        /**
         * @member {Boolean} animate_=false
         * @reactive
         */
        animate_: false,
        /**
         * True will destroy the used collection / store when the component gets destroyed
         * @member {Boolean} autoDestroyStore=true
         */
        autoDestroyStore: true,
        /**
         * @member {String[]} baseCls=['neo-list']
         */
        baseCls: ['neo-list'],
        /**
         * An optional record field to make items non-clickable and visually greyed out.
         * The field expects the Boolean type.
         * @member {String} disabledField='disabled'
         */
        disabledField: 'disabled',
        /**
         * @member {Boolean} disableSelection_=false
         * @reactive
         */
        disableSelection_: false,
        /**
         * @member {String} displayField='name'
         */
        displayField: 'name',
        /**
         * @member {Boolean} draggable_=false
         * @reactive
         */
        draggable_: false,
        /**
         * @member {Neo.draggable.list.DragZone|null} dragZone=null
         */
        dragZone: null,
        /**
         * @member {Object} dragZoneConfig=null
         */
        dragZoneConfig: null,
        /**
         * Keeps track of the focussed item index and allows bindings and programmatic changes.
         * You can either pass the index or the related record
         * @member {Number|Object|null} focusIndex_=null
         * @reactive
         */
        focusIndex_: null,
        /**
         * In case we are using list item headers and want to bind list item indexes to e.g. a card layout
         * for e.g. a sidenav, this config comes in handy.
         * @member {Number|null} headerlessSelectedIndex_=null
         * @reactive
         */
        headerlessSelectedIndex_: null,
        /**
         * @member {Boolean} highlightFilterValue=true
         */
        highlightFilterValue: true,
        /**
         * @member {String} itemCls='neo-list-item'
         */
        itemCls: 'neo-list-item',
        /**
         * Defaults to px
         * @member {Number|null} itemHeight_=null
         * @reactive
         */
        itemHeight_: null,
        /**
         * The type of the node / tag for each list item
         * @member {String} itemTagName='li'
         */
        itemTagName: 'li',
        /**
         * Defaults to px
         * @member {Number|null} itemWidth_=null
         * @reactive
         */
        itemWidth_: null,
        /**
         * @member {Boolean} itemsFocusable=true
         */
        itemsFocusable: true,
        /**
         * The config will get passed to the navigator main thread addon.
         * E.g. for ComboBoxes, which shall preserve their focussed list item when filtering the store, use true.
         * @member {Boolean} keepFocusIndex=false
         */
        keepFocusIndex: false,
        /**
         * Additional used keys for the selection model
         * @member {Object} keys
         */
        keys: {},
        /**
         * config values for Neo.list.plugin.Animate
         * @member {Object} pluginAnimateConfig=null
         */
        pluginAnimateConfig: null,
        /**
         * Keeps track of the selected item index and allows bindings and programmatic changes
         * @member {Number|null} selectedIndex_=null
         * @reactive
         */
        selectedIndex_: null,
        /**
         * Either pass a selection.Model module, an instance or a config object
         * @member {Object|Neo.selection.Model} selectionModel_=null
         * @reactive
         */
        selectionModel_: null,
        /**
         * Set this to true in case a keyboard navigation should immediately select the focussed item
         * @member {Boolean} selectOnFocus=false
         */
        selectOnFocus: false,
        /**
         * Set this to true in case a select event should only update _vdom (e.g. when used inside a form.field.ComboBox
         * @member {Boolean} silentSelect=false
         */
        silentSelect: false,
        /**
         * @member {Neo.data.Store|null} store_=null
         * @reactive
         */
        store_: null,
        /**
         * True will add a checkbox in front of each list item
         * @member {Boolean} stacked_=true
         * @reactive
         */
        useCheckBoxes_: false,
        /**
         * @member {Boolean} useInternalId=true
         */
        useInternalId: true,
        /**
         * Setting this config to true will switch to dl, dt & dd tags instead of using ul & li.
         * Use the {Boolean} model field isHeader.
         * @member {Boolean} useHeaders_=false
         * @reactive
         */
        useHeaders_: false,
        /**
         * @member {Boolean} useWrapperNode_=false
         * @reactive
         */
        useWrapperNode_: false,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {tag: 'ul', cn: []}
    }

    /**
     * @member {String|null} itemRole=null
     */
    itemRole = null
    /**
     * An object to help configure the navigation. Used to pass to {@link Neo.main.addon.Navigator#subscribe}.
     * @member {Object} navigator={}
     */
    navigator = {}
    /**
     * Defaults to false in case useHeaders is set to true
     * @member {Boolean} scrollIntoViewOnFocus=true
     */
    scrollIntoViewOnFocus = true

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        if (me.useHeaders) {
            me.scrollIntoViewOnFocus = false
        }

        me.addDomListeners({
            click: me.onClick,
            scope: me
        })
    }

    /**
     * Triggered after the animate config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetAnimate(value, oldValue) {
        if (value && !this.getPlugin('list-animate')) {
            __webpack_require__.e(/*! import() */ "vendors-src_list_plugin_Animate_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./plugin/Animate.mjs */ "./src/list/plugin/Animate.mjs")).then(module => {
                let me      = this,
                    plugins = me.plugins || [];

                plugins.push({
                    module: module.default,
                    ...me.pluginAnimateConfig
                });

                me.plugins = plugins
            })
        }
    }

    /**
     * Triggered after the disableSelection config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetDisableSelection(value, oldValue) {
        value && this.vnodeInitialized && this.selectionModel?.deselectAll()
    }

    /**
     * Triggered after the draggable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetDraggable(value, oldValue) {
        let me = this;

        if (value && !me.dragZone) {
            Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("src_draggable_DragProxyContainer_mjs-src_draggable_list_DragZone_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ../draggable/list/DragZone.mjs */ "./src/draggable/list/DragZone.mjs")).then(module => {
                me.dragZone = Neo.create({
                    module  : module.default,
                    appName : me.appName,
                    owner   : me,
                    windowId: me.windowId,
                    ...me.dragZoneConfig
                })
            })
        }
    }

    /**
     * Triggered after the focusIndex config got changed
     * @param {Number|Object|null} value
     * @param {Number|Object|null} oldValue
     * @protected
     */
    afterSetFocusIndex(value, oldValue) {
        value !== null && this.updateItemFocus(value)
    }

    /**
     * Triggered after the headerlessSelectedIndex config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetHeaderlessSelectedIndex(value, oldValue) {
        let me = this;

        if (Neo.isNumber(value)) {
            me.selectedIndex = me.store.getCount() ? me.getSelectedIndex(value) : null
        } else if (Neo.isNumber(oldValue)) {
            me.selectedIndex = null
        }
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        let me = this;

        // Tear down navigation before we lose the element
        if (!value && me.hasNavigator) {
            Neo.main.addon.Navigator.unsubscribe(me.navigator);

            me.hasNavigator  = false;
            me.selectedIndex = null
        }

        if (value) {
            // Set up item navigation in the list
            if (!me.hasNavigator) {
                me.navigator = Neo.merge({
                    appName       : me.appName,
                    autoClick     : me.selectOnFocus,
                    id            : me.id,
                    keepFocusIndex: me.keepFocusIndex,
                    selector      : `.${me.itemCls}:not(.neo-disabled,.neo-list-header)`,
                    windowId      : me.windowId
                }, me.navigator);

                me.hasNavigator = true
            }

            Neo.main.addon.Navigator.subscribe(me.navigator)
        }

        super.afterSetMounted(value, oldValue)
    }

    /**
     * Triggered after the selectedIndex config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetSelectedIndex(value, oldValue) {
        let me               = this,
            {selectionModel} = me;

        if (Neo.isNumber(value)) {
            selectionModel?.selectAt(value);
            me.headerlessSelectedIndex = me.getHeaderlessIndex(value)
        } else if (Neo.isNumber(oldValue)) {
            selectionModel.deselectAll();
            me.headerlessSelectedIndex = null
        }
    }

    /**
     * Triggered after the selectionModel config got changed
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @protected
     */
    afterSetSelectionModel(value, oldValue) {
        this.vnodeInitialized && value.register(this)
    }

    /**
     * Triggered after the store config got changed
     * @param {Neo.data.Store} value
     * @param {Neo.data.Store} oldValue
     * @protected
     */
    afterSetStore(value, oldValue) {
        let me = this;

        value?.on({
            filter      : 'onStoreFilter',
            load        : 'onStoreLoad',
            recordChange: 'onStoreRecordChange',
            sort        : 'onStoreSort',
            scope       : me
        });

        value?.getCount() > 0 && me.onStoreLoad()
    }

    /**
     * Triggered after the useCheckBoxes config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetUseCheckBoxes(value, oldValue) {
        let me    = this,
            {cls} = me;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].toggle(cls, 'neo-use-checkicons', !!value);
        me.cls = cls
    }

    /**
     * Triggered after the useHeaders config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetUseHeaders(value, oldValue) {
        if (value) {
            let me = this;

            me.vdom.tag = 'dl';
            me.itemTagName = 'dd'
        }
    }

    /**
     * Triggered after the useWrapperNode config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetUseWrapperNode(value, oldValue) {
        let me                = this,
            {cls, wrapperCls} = me;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"][value ? 'add' : 'remove'](cls, 'neo-use-wrapper-node');
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"][value ? 'add' : 'remove'](wrapperCls, 'neo-list-wrapper');

        me.wrapperCls = wrapperCls;
        me.cls        = cls
    }

    /**
     * Triggered after the windowId config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        super.afterSetWindowId(value, oldValue);

        let {navigator} = this;

        if (value && navigator) {
            navigator.windowId = value
        }
    }

    /**
     * Triggered before the selectionModel config gets changed.
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @returns {Neo.selection.Model}
     * @protected
     */
    beforeSetSelectionModel(value, oldValue) {
        oldValue?.destroy();
        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].beforeSetInstance(value, _selection_ListModel_mjs__WEBPACK_IMPORTED_MODULE_2__["default"])
    }

    /**
     * Triggered before the store config gets changed.
     * @param {Object|Neo.data.Store} value
     * @param {Object|Neo.data.Store} oldValue
     * @returns {Neo.data.Store}
     * @protected
     */
    beforeSetStore(value, oldValue) {
        oldValue?.destroy();
        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].beforeSetInstance(value, _data_Store_mjs__WEBPACK_IMPORTED_MODULE_4__["default"])
    }

    /**
     * Override this method for custom list items
     * @param {Object} record
     * @param {Number} index
     * @returns {Object} The list item vdom object
     */
    createItem(record, index) {
        let me               = this,
            cls              = [me.itemCls],
            hasItemHeight    = me.itemHeight !== null,
            hasItemWidth     = me.itemWidth !== null,
            isHeader         = me.useHeaders && record.isHeader,
            itemContent      = me.createItemContent(record, index),
            itemId           = me.getItemId(me.getRecordId(record)),
            {selectionModel} = me,
            isSelected       = !me.disableSelection && selectionModel?.isSelected(itemId),
            item, removeDom;

        isHeader && cls.push('neo-list-header');

        if (isSelected){
            cls.push(selectionModel.selectedCls)
        }

        if (record.cls) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(cls, record.cls)
        }

        if (record[me.disabledField]) {
            cls.push('neo-disabled')
        }

        item = {
            id  : itemId,
            tag : isHeader ? 'dt' : me.itemTagName,
            'aria-selected' : isSelected,
            cls
        };

        if (me.itemsFocusable) {
            item.tabIndex = -1
        }

        if (record.hidden || itemContent.removeDom) {
            item.removeDom = true
        }

        if (me.itemRole) {
            item.role = me.itemRole
        }

        switch (Neo.typeOf(itemContent)) {
            case null: {
                return null
            }

            case 'Array': {
                item.cn = itemContent;

                removeDom = true;

                itemContent.forEach(item => {
                    if (!item.removeDom) {
                        removeDom = false
                    }
                })

                if (removeDom) {
                    item.removeDom = true
                }

                break
            }

            case 'Object': {
                // We want a merge for custom cls rules
                if (itemContent.cls) {
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(item.cls, itemContent.cls);
                    delete itemContent.cls
                }

                Object.assign(item, itemContent);
                break
            }

            case 'Number':
            case 'String': {
                item.html = itemContent;
                break
            }
        }

        if (hasItemHeight || hasItemWidth) {
            item.style = item.style || {};

            if (hasItemHeight && !item.hasOwnProperty('height')) {
                item.style.height = `${me.itemHeight}px`
            }

            if (hasItemWidth && !item.hasOwnProperty('width')) {
                item.style.width = `${me.itemWidth}px`
            }
        }

        return item
    }

    /**
     * Override this method for custom renderers
     * @param {Object} record
     * @param {Number} index
     * @returns {Object|Object[]|String} Either a config object to assign to the item, a vdom cn array or a html string
     */
    createItemContent(record, index) {
        let me       = this,
            itemText = record[me.displayField],
            filter;

        if (me.highlightFilterValue) {
            filter = me.store.getFilter(me.displayField);

            if (filter && filter.value !== null && filter.value !== '') {
                itemText = itemText.replace(new RegExp(filter.value, 'gi'), function(match) {
                    return '<span class="neo-highlight-search">' + match + '</span>'
                })
            }
        }

        return itemText
    }

    /**
     * @param {Boolean} silent=false
     */
    createItems(silent=false) {
        let me                        = this,
            {headerlessSelectedIndex} = me,
            vdom                      = me.getVdomRoot(),
            listItem;

        // in case we set headerlessSelectedIndex before the store was loaded, selectedIndex can be null
        // and the wanted selection is not initially there
        if (Neo.isNumber(headerlessSelectedIndex) && !Neo.isNumber(me.selectedIndex)) {
            me.afterSetHeaderlessSelectedIndex(headerlessSelectedIndex, null)
        }

        if (!(me.animate && !me.getPlugin('list-animate'))) {
            vdom.cn = [];

            me.store.forEach((item, index) => {
                listItem = me.createItem(item, index);
                listItem && vdom.cn.push(listItem)
            });

            !silent && me.promiseUpdate().then(() => {
                me.fire('createItems')
            })
        }
    }

    /**
     * @param args
     */
    destroy(...args) {
        let me = this;

        me.selectionModel?.destroy();

        me.autoDestroyStore && me.store?.destroy();

        super.destroy(...args)
    }

    /**
     * Calls focus() on the top level DOM node of this component or on a given node via id
     * @param {String} [id=this.id]
     */
    focus(id=this.id) {
        this.mounted && Neo.main.addon.Navigator.navigateTo({
            data    : this.navigator,
            target  : id,
            windowId: this.windowId
        })
    }

    /**
     * @param {Object} record
     * @returns {String|Number}
     */
    getRecordId(record) {
        return this.useInternalId ? this.store.getInternalId(record) : this.store.getKey(record)
    }

    /**
     * Transforms an index excluding list item headers into the real store index
     * @param {Number} headerlessSelectedIndex
     * @returns {Number}
     */
    getSelectedIndex(headerlessSelectedIndex) {
        let delta   = 0,
            i       = 0,
            records = this.store.items,
            len     = headerlessSelectedIndex;

        if (records.length < 1) {
            return null
        }

        for (; i <= len; i++) {
            if (records[i].isHeader) {
                delta++;
                len++
            }
        }

        return headerlessSelectedIndex + delta
    }

    /**
     * Returns the index of a list item excluding item headers
     * @param {Number} index
     * @returns {Number}
     */
    getHeaderlessIndex(index) {
        let headerlessIndex = 0,
            i               = 0,
            records         = this.store.items;

        for (; i < index; i++) {
            if (!records[i].isHeader) {
                headerlessIndex++
            }
        }

        return headerlessIndex
    }

    /**
     * @param {Number|String|object} recordOrId
     * @returns {String}
     */
    getItemId(recordOrId) {
        let id = recordOrId;

        if (recordOrId.isRecord) {
            id = this.getRecordId(recordOrId)
        }

        return `${this.id}__${id}`
    }

    /**
     * @param {String} vnodeId
     * @returns {String|Number} itemId
     */
    getItemRecordId(vnodeId) {
        let itemId = vnodeId.split('__')[1];

        if (!this.useInternalId && this.store.getKeyType()?.includes('int')) {
            itemId = parseInt(itemId)
        }

        return itemId
    }

    /**
     * Support collections & stores
     * @returns {String}
     */
    getKeyProperty() {
        return this.store.keyProperty || this.store.model.keyProperty
    }

    /**
     * @param {Object} data
     */
    onClick(data) {
        let me = this,
            item;

        if (data.path[0].id === me.id) {
            me.onContainerClick(data)
        } else {
            for (item of data.path) {
                if (item.cls.includes(me.itemCls)) {
                    me.onItemClick(item, data);
                    break
                }
            }
        }
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        this.selectionModel?.register(this)
    }

    /**
     * @param {Object} data
     */
    onContainerClick(data) {
        /**
         * The containerClick event fires when a click occurs on the component, but not on a list item
         * @event containerClick
         * @param {String[]} cls the classList of the target node (converted to an array)
         * @param {String} id the target dom id
         * @param {String[]} path the event path
         * @returns {Object}
         */
        this.fire('containerClick', data)
    }

    /**
     * @param {Object} node
     * @param {Object} data
     */
    onItemClick(node, data) {
        let me     = this,
            record = me.store.get(me.getItemRecordId(node.id));

        // pass the record to class extensions
        data.record = record;

        /**
         * The itemClick event fires when a click occurs on a list item
         * @event itemClick
         * @param {String} id the record matching the list item
         * @returns {Object}
         */
        me.fire('itemClick', {
            record
        })
    }

    /**
     *
     */
    onStoreFilter() {
        this.createItems()
    }

    /**
     *
     */
    onStoreLoad() {
        let me = this;

        if (!me.mounted && me.isVnodeInitializing) {
            me.on('mounted', () => {
                me.createItems()
            }, me, {once: true});
        } else {
            me.createItems()
        }
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.fields Each field object contains the keys: name, oldValue, value
     * @param {Number} data.index
     * @param {Neo.data.Model} data.model
     * @param {Object} data.record
     */
    onStoreRecordChange(data) {
        let me      = this,
            {index} = data;

        // ignore changes for records which have not been added to the list yet
        if (index > -1) {
            me.vdom.cn[index] = me.createItem(data.record, index);
            me.update()
        }
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.items
     * @param {Object[]} data.previousItems
     * @param {Neo.data.Store} data.scope
     */
    onStoreSort(data) {
        this.createItems()
    }

    /**
     * Convenience shortcut
     * @param {Number|String} item
     */
    selectItem(item) {
        let me = this;

        if (!me.disableSelection) {
            // Selecting index
            if (Neo.isNumber(item)) {
                me.selectionModel?.selectAt(item)
            }
            // Selecting record
            else if (item) {
                me.selectionModel?.selectAt(me.store.indexOf(item))
            }
        }
    }

    /**
     *
     * @param {Number|Object} value
     * @returns {Promise<void>}
     */
    async updateItemFocus(value) {
        let me           = this,
            {navigateTo} = Neo.main.addon.Navigator;

        if (me.mounted) {
            if (Neo.isNumber(value)) {
                navigateTo({
                    data    : me.navigator,
                    target  : me.getHeaderlessIndex(value),
                    windowId: me.windowId
                })
            } else if (value) {
                navigateTo({
                    data    : me.navigator,
                    target  : me.getItemId(me.getRecordId(value)),
                    windowId: me.windowId
                })
            }
        } else {
            me.on('mounted', () => {
                // We could subscribe multiple times before getting mounted,
                // so only trigger the callback for the last focusIndex
                if (value === me.focusIndex) {
                    me.updateItemFocus(me.focusIndex)
                }
            }, me, {once: true})
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(List));


/***/ },

/***/ "./src/selection/ListModel.mjs"
/*!*************************************!*\
  !*** ./src/selection/ListModel.mjs ***!
  \*************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Model_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Model.mjs */ "./src/selection/Model.mjs");


/**
 * @class Neo.selection.ListModel
 * @extends Neo.selection.Model
 */
class ListModel extends _Model_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.selection.ListModel'
         * @protected
         */
        className: 'Neo.selection.ListModel',
        /**
         * @member {String} ntype='selection-listmodel'
         * @protected
         */
        ntype: 'selection-listmodel'
    }

    /**
     * Placeholder method to get overridden by class extension list menu.ListModel
     * @param {Object} data
     */
    onKeyDownEscape(data) {}

    /**
     * Placeholder method to get overridden by class extension list menu.ListModel
     * @param {Object} data
     */
    onKeyDownDown(data) {}

    /**
     * Placeholder method to get overridden by class extension list menu.ListModel
     * @param {Object} data
     */
    onKeyDownEnter(data) {}

    /**
     * Placeholder method to get overridden by class extension list menu.ListModel
     * @param {Object} data
     */
    onKeyDownLeft(data) {}

    /**
     * Placeholder method to get overridden by class extension list menu.ListModel
     * @param {Object} data
     */
    onKeyDownRight(data) {}

    /**
     * Placeholder method to get overridden by class extension list menu.ListModel
     * @param {Object} data
     */
    onKeyDownUp(data) {}

    /**
     * @param {Object} data
     */
    onListClick({currentTarget}) {
        let {view} = this,
            id     = view.getItemRecordId(currentTarget),
            record = view.store.get(id);

        if (!view.disableSelection) {
            record && this.select(record)
        }
    }

    /**
     * @param {Object} data
     */
    onListNavigate(data) {
        let {view}  = this,
            {store} = view,
            record, recordId;

        if (data.activeItem) {
            recordId = view.getItemRecordId(data.activeItem);
            record   = store.get(recordId);
        }

        if (!record) {
            record = store.getAt(Math.min(data.activeIndex, store.getCount()))
        }

        data.record      = record;
        view._focusIndex = store.indexOf(record); // silent update, no need to refocus

        view.fire('itemNavigate', data)
    }

    /**
     * @param {Neo.component.Base} component
     */
    register(component) {
        super.register(component);

        let me         = this,
            {id, view} = me;

        view.addDomListeners([{
            click: me.onListClick,
            scope: me,

            // Should be `.${view.itemCls}:not(.neo-disabled,.neo-list-header)`
            // TODO parse delegate selectors
            delegate: path => {
                for (let i = 0, { length } = path; i < length; i++) {
                    const { cls } = path[i];

                    if (cls.includes(view.itemCls) && !cls.includes('neo-disabled') && !cls.includes('neo-list-header')) {
                        return i;
                    }
                }
            }
        }, {
            neonavigate : me.onListNavigate,
            scope       : me
        }]);

        view.keys?._keys.push(
            {fn: 'onKeyDownDown'   ,key: 'Down'   ,scope: id},
            {fn: 'onKeyDownEnter'  ,key: 'Enter'  ,scope: id},
            {fn: 'onKeyDownEscape' ,key: 'Escape' ,scope: id},
            {fn: 'onKeyDownLeft'   ,key: 'Left'   ,scope: id},
            {fn: 'onKeyDownRight'  ,key: 'Right'  ,scope: id},
            {fn: 'onKeyDownUp'     ,key: 'Up'     ,scope: id}
        )
    }

    /**
     * @param {Number} index
     */
    selectAt(index) {
        let {view} = this,
            record = view?.store.getAt(index),
            itemId = record && view.getItemId(view.getRecordId(record));

        itemId && this.select(itemId)
    }

    /**
     *
     */
    unregister() {
        let me         = this,
            {id, view} = me;

        view.keys?.removeKeys([
            {fn: 'onKeyDownDown'   ,key: 'Down'   ,scope: id},
            {fn: 'onKeyDownEnter'  ,key: 'Enter'  ,scope: id},
            {fn: 'onKeyDownEscape' ,key: 'Escape' ,scope: id},
            {fn: 'onKeyDownLeft'   ,key: 'Left'   ,scope: id},
            {fn: 'onKeyDownRight'  ,key: 'Right'  ,scope: id},
            {fn: 'onKeyDownUp'     ,key: 'Up'     ,scope: id}
        ]);

        super.unregister()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(ListModel));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,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aUVBQWUseUJBQXlCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2xpc3QvQmFzZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9zZWxlY3Rpb24vTGlzdE1vZGVsLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ2xhc3NTeXN0ZW1VdGlsIGZyb20gJy4uL3V0aWwvQ2xhc3NTeXN0ZW0ubWpzJztcbmltcG9ydCBDb21wb25lbnQgICAgICAgZnJvbSAnLi4vY29tcG9uZW50L0Jhc2UubWpzJztcbmltcG9ydCBMaXN0TW9kZWwgICAgICAgZnJvbSAnLi4vc2VsZWN0aW9uL0xpc3RNb2RlbC5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICAgICAgICBmcm9tICcuLi91dGlsL0FycmF5Lm1qcyc7XG5pbXBvcnQgU3RvcmUgICAgICAgICAgIGZyb20gJy4uL2RhdGEvU3RvcmUubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmxpc3QuQmFzZVxuICogQGV4dGVuZHMgTmVvLmNvbXBvbmVudC5CYXNlXG4gKi9cbmNsYXNzIExpc3QgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmxpc3QuQmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmxpc3QuQmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdsaXN0J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2xpc3QnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYW5pbWF0ZV89ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBhbmltYXRlXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIHdpbGwgZGVzdHJveSB0aGUgdXNlZCBjb2xsZWN0aW9uIC8gc3RvcmUgd2hlbiB0aGUgY29tcG9uZW50IGdldHMgZGVzdHJveWVkXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGF1dG9EZXN0cm95U3RvcmU9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXV0b0Rlc3Ryb3lTdG9yZTogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWxpc3QnXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tbGlzdCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gb3B0aW9uYWwgcmVjb3JkIGZpZWxkIHRvIG1ha2UgaXRlbXMgbm9uLWNsaWNrYWJsZSBhbmQgdmlzdWFsbHkgZ3JleWVkIG91dC5cbiAgICAgICAgICogVGhlIGZpZWxkIGV4cGVjdHMgdGhlIEJvb2xlYW4gdHlwZS5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBkaXNhYmxlZEZpZWxkPSdkaXNhYmxlZCdcbiAgICAgICAgICovXG4gICAgICAgIGRpc2FibGVkRmllbGQ6ICdkaXNhYmxlZCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBkaXNhYmxlU2VsZWN0aW9uXz1mYWxzZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGRpc2FibGVTZWxlY3Rpb25fOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gZGlzcGxheUZpZWxkPSduYW1lJ1xuICAgICAgICAgKi9cbiAgICAgICAgZGlzcGxheUZpZWxkOiAnbmFtZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBkcmFnZ2FibGVfPWZhbHNlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ2dhYmxlXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZHJhZ2dhYmxlLmxpc3QuRHJhZ1pvbmV8bnVsbH0gZHJhZ1pvbmU9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ1pvbmU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGRyYWdab25lQ29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdab25lQ29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogS2VlcHMgdHJhY2sgb2YgdGhlIGZvY3Vzc2VkIGl0ZW0gaW5kZXggYW5kIGFsbG93cyBiaW5kaW5ncyBhbmQgcHJvZ3JhbW1hdGljIGNoYW5nZXMuXG4gICAgICAgICAqIFlvdSBjYW4gZWl0aGVyIHBhc3MgdGhlIGluZGV4IG9yIHRoZSByZWxhdGVkIHJlY29yZFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8T2JqZWN0fG51bGx9IGZvY3VzSW5kZXhfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBmb2N1c0luZGV4XzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluIGNhc2Ugd2UgYXJlIHVzaW5nIGxpc3QgaXRlbSBoZWFkZXJzIGFuZCB3YW50IHRvIGJpbmQgbGlzdCBpdGVtIGluZGV4ZXMgdG8gZS5nLiBhIGNhcmQgbGF5b3V0XG4gICAgICAgICAqIGZvciBlLmcuIGEgc2lkZW5hdiwgdGhpcyBjb25maWcgY29tZXMgaW4gaGFuZHkuXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBoZWFkZXJsZXNzU2VsZWN0ZWRJbmRleF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGhlYWRlcmxlc3NTZWxlY3RlZEluZGV4XzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGhpZ2hsaWdodEZpbHRlclZhbHVlPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGhpZ2hsaWdodEZpbHRlclZhbHVlOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBpdGVtQ2xzPSduZW8tbGlzdC1pdGVtJ1xuICAgICAgICAgKi9cbiAgICAgICAgaXRlbUNsczogJ25lby1saXN0LWl0ZW0nLFxuICAgICAgICAvKipcbiAgICAgICAgICogRGVmYXVsdHMgdG8gcHhcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IGl0ZW1IZWlnaHRfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtSGVpZ2h0XzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIG9mIHRoZSBub2RlIC8gdGFnIGZvciBlYWNoIGxpc3QgaXRlbVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGl0ZW1UYWdOYW1lPSdsaSdcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1UYWdOYW1lOiAnbGknLFxuICAgICAgICAvKipcbiAgICAgICAgICogRGVmYXVsdHMgdG8gcHhcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IGl0ZW1XaWR0aF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1XaWR0aF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpdGVtc0ZvY3VzYWJsZT10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtc0ZvY3VzYWJsZTogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjb25maWcgd2lsbCBnZXQgcGFzc2VkIHRvIHRoZSBuYXZpZ2F0b3IgbWFpbiB0aHJlYWQgYWRkb24uXG4gICAgICAgICAqIEUuZy4gZm9yIENvbWJvQm94ZXMsIHdoaWNoIHNoYWxsIHByZXNlcnZlIHRoZWlyIGZvY3Vzc2VkIGxpc3QgaXRlbSB3aGVuIGZpbHRlcmluZyB0aGUgc3RvcmUsIHVzZSB0cnVlLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBrZWVwRm9jdXNJbmRleD1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAga2VlcEZvY3VzSW5kZXg6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkaXRpb25hbCB1c2VkIGtleXMgZm9yIHRoZSBzZWxlY3Rpb24gbW9kZWxcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBrZXlzXG4gICAgICAgICAqL1xuICAgICAgICBrZXlzOiB7fSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNvbmZpZyB2YWx1ZXMgZm9yIE5lby5saXN0LnBsdWdpbi5BbmltYXRlXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gcGx1Z2luQW5pbWF0ZUNvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBwbHVnaW5BbmltYXRlQ29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogS2VlcHMgdHJhY2sgb2YgdGhlIHNlbGVjdGVkIGl0ZW0gaW5kZXggYW5kIGFsbG93cyBiaW5kaW5ncyBhbmQgcHJvZ3JhbW1hdGljIGNoYW5nZXNcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IHNlbGVjdGVkSW5kZXhfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzZWxlY3RlZEluZGV4XzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVpdGhlciBwYXNzIGEgc2VsZWN0aW9uLk1vZGVsIG1vZHVsZSwgYW4gaW5zdGFuY2Ugb3IgYSBjb25maWcgb2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxOZW8uc2VsZWN0aW9uLk1vZGVsfSBzZWxlY3Rpb25Nb2RlbF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHNlbGVjdGlvbk1vZGVsXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGlzIHRvIHRydWUgaW4gY2FzZSBhIGtleWJvYXJkIG5hdmlnYXRpb24gc2hvdWxkIGltbWVkaWF0ZWx5IHNlbGVjdCB0aGUgZm9jdXNzZWQgaXRlbVxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzZWxlY3RPbkZvY3VzPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBzZWxlY3RPbkZvY3VzOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGlzIHRvIHRydWUgaW4gY2FzZSBhIHNlbGVjdCBldmVudCBzaG91bGQgb25seSB1cGRhdGUgX3Zkb20gKGUuZy4gd2hlbiB1c2VkIGluc2lkZSBhIGZvcm0uZmllbGQuQ29tYm9Cb3hcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2lsZW50U2VsZWN0PWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBzaWxlbnRTZWxlY3Q6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmRhdGEuU3RvcmV8bnVsbH0gc3RvcmVfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzdG9yZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIHdpbGwgYWRkIGEgY2hlY2tib3ggaW4gZnJvbnQgb2YgZWFjaCBsaXN0IGl0ZW1cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc3RhY2tlZF89dHJ1ZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHVzZUNoZWNrQm94ZXNfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHVzZUludGVybmFsSWQ9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgdXNlSW50ZXJuYWxJZDogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHRpbmcgdGhpcyBjb25maWcgdG8gdHJ1ZSB3aWxsIHN3aXRjaCB0byBkbCwgZHQgJiBkZCB0YWdzIGluc3RlYWQgb2YgdXNpbmcgdWwgJiBsaS5cbiAgICAgICAgICogVXNlIHRoZSB7Qm9vbGVhbn0gbW9kZWwgZmllbGQgaXNIZWFkZXIuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHVzZUhlYWRlcnNfPWZhbHNlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdXNlSGVhZGVyc186IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gdXNlV3JhcHBlck5vZGVfPWZhbHNlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdXNlV3JhcHBlck5vZGVfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gX3Zkb21cbiAgICAgICAgICovXG4gICAgICAgIF92ZG9tOlxuICAgICAgICB7dGFnOiAndWwnLCBjbjogW119XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGl0ZW1Sb2xlPW51bGxcbiAgICAgKi9cbiAgICBpdGVtUm9sZSA9IG51bGxcbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgdG8gaGVscCBjb25maWd1cmUgdGhlIG5hdmlnYXRpb24uIFVzZWQgdG8gcGFzcyB0byB7QGxpbmsgTmVvLm1haW4uYWRkb24uTmF2aWdhdG9yI3N1YnNjcmliZX0uXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBuYXZpZ2F0b3I9e31cbiAgICAgKi9cbiAgICBuYXZpZ2F0b3IgPSB7fVxuICAgIC8qKlxuICAgICAqIERlZmF1bHRzIHRvIGZhbHNlIGluIGNhc2UgdXNlSGVhZGVycyBpcyBzZXQgdG8gdHJ1ZVxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNjcm9sbEludG9WaWV3T25Gb2N1cz10cnVlXG4gICAgICovXG4gICAgc2Nyb2xsSW50b1ZpZXdPbkZvY3VzID0gdHJ1ZVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUudXNlSGVhZGVycykge1xuICAgICAgICAgICAgbWUuc2Nyb2xsSW50b1ZpZXdPbkZvY3VzID0gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmFkZERvbUxpc3RlbmVycyh7XG4gICAgICAgICAgICBjbGljazogbWUub25DbGljayxcbiAgICAgICAgICAgIHNjb3BlOiBtZVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgYW5pbWF0ZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEFuaW1hdGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiAhdGhpcy5nZXRQbHVnaW4oJ2xpc3QtYW5pbWF0ZScpKSB7XG4gICAgICAgICAgICBpbXBvcnQoJy4vcGx1Z2luL0FuaW1hdGUubWpzJykudGhlbihtb2R1bGUgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2lucyA9IG1lLnBsdWdpbnMgfHwgW107XG5cbiAgICAgICAgICAgICAgICBwbHVnaW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGU6IG1vZHVsZS5kZWZhdWx0LFxuICAgICAgICAgICAgICAgICAgICAuLi5tZS5wbHVnaW5BbmltYXRlQ29uZmlnXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBtZS5wbHVnaW5zID0gcGx1Z2luc1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZGlzYWJsZVNlbGVjdGlvbiBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldERpc2FibGVTZWxlY3Rpb24odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHZhbHVlICYmIHRoaXMudm5vZGVJbml0aWFsaXplZCAmJiB0aGlzLnNlbGVjdGlvbk1vZGVsPy5kZXNlbGVjdEFsbCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBkcmFnZ2FibGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXREcmFnZ2FibGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHZhbHVlICYmICFtZS5kcmFnWm9uZSkge1xuICAgICAgICAgICAgaW1wb3J0KCcuLi9kcmFnZ2FibGUvbGlzdC9EcmFnWm9uZS5tanMnKS50aGVuKG1vZHVsZSA9PiB7XG4gICAgICAgICAgICAgICAgbWUuZHJhZ1pvbmUgPSBOZW8uY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlICA6IG1vZHVsZS5kZWZhdWx0LFxuICAgICAgICAgICAgICAgICAgICBhcHBOYW1lIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgb3duZXIgICA6IG1lLFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3dJZDogbWUud2luZG93SWQsXG4gICAgICAgICAgICAgICAgICAgIC4uLm1lLmRyYWdab25lQ29uZmlnXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGZvY3VzSW5kZXggY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Rm9jdXNJbmRleCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdmFsdWUgIT09IG51bGwgJiYgdGhpcy51cGRhdGVJdGVtRm9jdXModmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBoZWFkZXJsZXNzU2VsZWN0ZWRJbmRleCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRIZWFkZXJsZXNzU2VsZWN0ZWRJbmRleCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgbWUuc2VsZWN0ZWRJbmRleCA9IG1lLnN0b3JlLmdldENvdW50KCkgPyBtZS5nZXRTZWxlY3RlZEluZGV4KHZhbHVlKSA6IG51bGxcbiAgICAgICAgfSBlbHNlIGlmIChOZW8uaXNOdW1iZXIob2xkVmFsdWUpKSB7XG4gICAgICAgICAgICBtZS5zZWxlY3RlZEluZGV4ID0gbnVsbFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtb3VudGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvLyBUZWFyIGRvd24gbmF2aWdhdGlvbiBiZWZvcmUgd2UgbG9zZSB0aGUgZWxlbWVudFxuICAgICAgICBpZiAoIXZhbHVlICYmIG1lLmhhc05hdmlnYXRvcikge1xuICAgICAgICAgICAgTmVvLm1haW4uYWRkb24uTmF2aWdhdG9yLnVuc3Vic2NyaWJlKG1lLm5hdmlnYXRvcik7XG5cbiAgICAgICAgICAgIG1lLmhhc05hdmlnYXRvciAgPSBmYWxzZTtcbiAgICAgICAgICAgIG1lLnNlbGVjdGVkSW5kZXggPSBudWxsXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIFNldCB1cCBpdGVtIG5hdmlnYXRpb24gaW4gdGhlIGxpc3RcbiAgICAgICAgICAgIGlmICghbWUuaGFzTmF2aWdhdG9yKSB7XG4gICAgICAgICAgICAgICAgbWUubmF2aWdhdG9yID0gTmVvLm1lcmdlKHtcbiAgICAgICAgICAgICAgICAgICAgYXBwTmFtZSAgICAgICA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGF1dG9DbGljayAgICAgOiBtZS5zZWxlY3RPbkZvY3VzLFxuICAgICAgICAgICAgICAgICAgICBpZCAgICAgICAgICAgIDogbWUuaWQsXG4gICAgICAgICAgICAgICAgICAgIGtlZXBGb2N1c0luZGV4OiBtZS5rZWVwRm9jdXNJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgICAgICA6IGAuJHttZS5pdGVtQ2xzfTpub3QoLm5lby1kaXNhYmxlZCwubmVvLWxpc3QtaGVhZGVyKWAsXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0lkICAgICAgOiBtZS53aW5kb3dJZFxuICAgICAgICAgICAgICAgIH0sIG1lLm5hdmlnYXRvcik7XG5cbiAgICAgICAgICAgICAgICBtZS5oYXNOYXZpZ2F0b3IgPSB0cnVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE5lby5tYWluLmFkZG9uLk5hdmlnYXRvci5zdWJzY3JpYmUobWUubmF2aWdhdG9yKVxuICAgICAgICB9XG5cbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNlbGVjdGVkSW5kZXggY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNlbGVjdGVkSW5kZXgodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtzZWxlY3Rpb25Nb2RlbH0gPSBtZTtcblxuICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgc2VsZWN0aW9uTW9kZWw/LnNlbGVjdEF0KHZhbHVlKTtcbiAgICAgICAgICAgIG1lLmhlYWRlcmxlc3NTZWxlY3RlZEluZGV4ID0gbWUuZ2V0SGVhZGVybGVzc0luZGV4KHZhbHVlKVxuICAgICAgICB9IGVsc2UgaWYgKE5lby5pc051bWJlcihvbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbk1vZGVsLmRlc2VsZWN0QWxsKCk7XG4gICAgICAgICAgICBtZS5oZWFkZXJsZXNzU2VsZWN0ZWRJbmRleCA9IG51bGxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc2VsZWN0aW9uTW9kZWwgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOZW8uc2VsZWN0aW9uLk1vZGVsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLnNlbGVjdGlvbi5Nb2RlbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTZWxlY3Rpb25Nb2RlbCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy52bm9kZUluaXRpYWxpemVkICYmIHZhbHVlLnJlZ2lzdGVyKHRoaXMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzdG9yZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLlN0b3JlfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuU3RvcmV9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U3RvcmUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgdmFsdWU/Lm9uKHtcbiAgICAgICAgICAgIGZpbHRlciAgICAgIDogJ29uU3RvcmVGaWx0ZXInLFxuICAgICAgICAgICAgbG9hZCAgICAgICAgOiAnb25TdG9yZUxvYWQnLFxuICAgICAgICAgICAgcmVjb3JkQ2hhbmdlOiAnb25TdG9yZVJlY29yZENoYW5nZScsXG4gICAgICAgICAgICBzb3J0ICAgICAgICA6ICdvblN0b3JlU29ydCcsXG4gICAgICAgICAgICBzY29wZSAgICAgICA6IG1lXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhbHVlPy5nZXRDb3VudCgpID4gMCAmJiBtZS5vblN0b3JlTG9hZCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB1c2VDaGVja0JveGVzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VXNlQ2hlY2tCb3hlcyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjbHN9ID0gbWU7XG5cbiAgICAgICAgTmVvQXJyYXkudG9nZ2xlKGNscywgJ25lby11c2UtY2hlY2tpY29ucycsICEhdmFsdWUpO1xuICAgICAgICBtZS5jbHMgPSBjbHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHVzZUhlYWRlcnMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRVc2VIZWFkZXJzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIG1lLnZkb20udGFnID0gJ2RsJztcbiAgICAgICAgICAgIG1lLml0ZW1UYWdOYW1lID0gJ2RkJ1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB1c2VXcmFwcGVyTm9kZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFVzZVdyYXBwZXJOb2RlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2Nscywgd3JhcHBlckNsc30gPSBtZTtcblxuICAgICAgICBOZW9BcnJheVt2YWx1ZSA/ICdhZGQnIDogJ3JlbW92ZSddKGNscywgJ25lby11c2Utd3JhcHBlci1ub2RlJyk7XG4gICAgICAgIE5lb0FycmF5W3ZhbHVlID8gJ2FkZCcgOiAncmVtb3ZlJ10od3JhcHBlckNscywgJ25lby1saXN0LXdyYXBwZXInKTtcblxuICAgICAgICBtZS53cmFwcGVyQ2xzID0gd3JhcHBlckNscztcbiAgICAgICAgbWUuY2xzICAgICAgICA9IGNsc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgd2luZG93SWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0V2luZG93SWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0V2luZG93SWQodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBsZXQge25hdmlnYXRvcn0gPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiBuYXZpZ2F0b3IpIHtcbiAgICAgICAgICAgIG5hdmlnYXRvci53aW5kb3dJZCA9IHZhbHVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBzZWxlY3Rpb25Nb2RlbCBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7TmVvLnNlbGVjdGlvbi5Nb2RlbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5zZWxlY3Rpb24uTW9kZWx9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge05lby5zZWxlY3Rpb24uTW9kZWx9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFNlbGVjdGlvbk1vZGVsKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZT8uZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gQ2xhc3NTeXN0ZW1VdGlsLmJlZm9yZVNldEluc3RhbmNlKHZhbHVlLCBMaXN0TW9kZWwpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgc3RvcmUgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxOZW8uZGF0YS5TdG9yZX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxOZW8uZGF0YS5TdG9yZX0gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TmVvLmRhdGEuU3RvcmV9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFN0b3JlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZT8uZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gQ2xhc3NTeXN0ZW1VdGlsLmJlZm9yZVNldEluc3RhbmNlKHZhbHVlLCBTdG9yZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBmb3IgY3VzdG9tIGxpc3QgaXRlbXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIGxpc3QgaXRlbSB2ZG9tIG9iamVjdFxuICAgICAqL1xuICAgIGNyZWF0ZUl0ZW0ocmVjb3JkLCBpbmRleCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjbHMgICAgICAgICAgICAgID0gW21lLml0ZW1DbHNdLFxuICAgICAgICAgICAgaGFzSXRlbUhlaWdodCAgICA9IG1lLml0ZW1IZWlnaHQgIT09IG51bGwsXG4gICAgICAgICAgICBoYXNJdGVtV2lkdGggICAgID0gbWUuaXRlbVdpZHRoICE9PSBudWxsLFxuICAgICAgICAgICAgaXNIZWFkZXIgICAgICAgICA9IG1lLnVzZUhlYWRlcnMgJiYgcmVjb3JkLmlzSGVhZGVyLFxuICAgICAgICAgICAgaXRlbUNvbnRlbnQgICAgICA9IG1lLmNyZWF0ZUl0ZW1Db250ZW50KHJlY29yZCwgaW5kZXgpLFxuICAgICAgICAgICAgaXRlbUlkICAgICAgICAgICA9IG1lLmdldEl0ZW1JZChtZS5nZXRSZWNvcmRJZChyZWNvcmQpKSxcbiAgICAgICAgICAgIHtzZWxlY3Rpb25Nb2RlbH0gPSBtZSxcbiAgICAgICAgICAgIGlzU2VsZWN0ZWQgICAgICAgPSAhbWUuZGlzYWJsZVNlbGVjdGlvbiAmJiBzZWxlY3Rpb25Nb2RlbD8uaXNTZWxlY3RlZChpdGVtSWQpLFxuICAgICAgICAgICAgaXRlbSwgcmVtb3ZlRG9tO1xuXG4gICAgICAgIGlzSGVhZGVyICYmIGNscy5wdXNoKCduZW8tbGlzdC1oZWFkZXInKTtcblxuICAgICAgICBpZiAoaXNTZWxlY3RlZCl7XG4gICAgICAgICAgICBjbHMucHVzaChzZWxlY3Rpb25Nb2RlbC5zZWxlY3RlZENscylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWNvcmQuY2xzKSB7XG4gICAgICAgICAgICBOZW9BcnJheS5hZGQoY2xzLCByZWNvcmQuY2xzKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlY29yZFttZS5kaXNhYmxlZEZpZWxkXSkge1xuICAgICAgICAgICAgY2xzLnB1c2goJ25lby1kaXNhYmxlZCcpXG4gICAgICAgIH1cblxuICAgICAgICBpdGVtID0ge1xuICAgICAgICAgICAgaWQgIDogaXRlbUlkLFxuICAgICAgICAgICAgdGFnIDogaXNIZWFkZXIgPyAnZHQnIDogbWUuaXRlbVRhZ05hbWUsXG4gICAgICAgICAgICAnYXJpYS1zZWxlY3RlZCcgOiBpc1NlbGVjdGVkLFxuICAgICAgICAgICAgY2xzXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG1lLml0ZW1zRm9jdXNhYmxlKSB7XG4gICAgICAgICAgICBpdGVtLnRhYkluZGV4ID0gLTFcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWNvcmQuaGlkZGVuIHx8IGl0ZW1Db250ZW50LnJlbW92ZURvbSkge1xuICAgICAgICAgICAgaXRlbS5yZW1vdmVEb20gPSB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWUuaXRlbVJvbGUpIHtcbiAgICAgICAgICAgIGl0ZW0ucm9sZSA9IG1lLml0ZW1Sb2xlXG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKE5lby50eXBlT2YoaXRlbUNvbnRlbnQpKSB7XG4gICAgICAgICAgICBjYXNlIG51bGw6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdBcnJheSc6IHtcbiAgICAgICAgICAgICAgICBpdGVtLmNuID0gaXRlbUNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgICByZW1vdmVEb20gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaXRlbUNvbnRlbnQuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtLnJlbW92ZURvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRG9tID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZlRG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0ucmVtb3ZlRG9tID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ09iamVjdCc6IHtcbiAgICAgICAgICAgICAgICAvLyBXZSB3YW50IGEgbWVyZ2UgZm9yIGN1c3RvbSBjbHMgcnVsZXNcbiAgICAgICAgICAgICAgICBpZiAoaXRlbUNvbnRlbnQuY2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIE5lb0FycmF5LmFkZChpdGVtLmNscywgaXRlbUNvbnRlbnQuY2xzKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGl0ZW1Db250ZW50LmNsc1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaXRlbSwgaXRlbUNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICAgICAgICBjYXNlICdTdHJpbmcnOiB7XG4gICAgICAgICAgICAgICAgaXRlbS5odG1sID0gaXRlbUNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNJdGVtSGVpZ2h0IHx8IGhhc0l0ZW1XaWR0aCkge1xuICAgICAgICAgICAgaXRlbS5zdHlsZSA9IGl0ZW0uc3R5bGUgfHwge307XG5cbiAgICAgICAgICAgIGlmIChoYXNJdGVtSGVpZ2h0ICYmICFpdGVtLmhhc093blByb3BlcnR5KCdoZWlnaHQnKSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uc3R5bGUuaGVpZ2h0ID0gYCR7bWUuaXRlbUhlaWdodH1weGBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGhhc0l0ZW1XaWR0aCAmJiAhaXRlbS5oYXNPd25Qcm9wZXJ0eSgnd2lkdGgnKSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uc3R5bGUud2lkdGggPSBgJHttZS5pdGVtV2lkdGh9cHhgXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlbVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGZvciBjdXN0b20gcmVuZGVyZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8T2JqZWN0W118U3RyaW5nfSBFaXRoZXIgYSBjb25maWcgb2JqZWN0IHRvIGFzc2lnbiB0byB0aGUgaXRlbSwgYSB2ZG9tIGNuIGFycmF5IG9yIGEgaHRtbCBzdHJpbmdcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtQ29udGVudChyZWNvcmQsIGluZGV4KSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtVGV4dCA9IHJlY29yZFttZS5kaXNwbGF5RmllbGRdLFxuICAgICAgICAgICAgZmlsdGVyO1xuXG4gICAgICAgIGlmIChtZS5oaWdobGlnaHRGaWx0ZXJWYWx1ZSkge1xuICAgICAgICAgICAgZmlsdGVyID0gbWUuc3RvcmUuZ2V0RmlsdGVyKG1lLmRpc3BsYXlGaWVsZCk7XG5cbiAgICAgICAgICAgIGlmIChmaWx0ZXIgJiYgZmlsdGVyLnZhbHVlICE9PSBudWxsICYmIGZpbHRlci52YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICBpdGVtVGV4dCA9IGl0ZW1UZXh0LnJlcGxhY2UobmV3IFJlZ0V4cChmaWx0ZXIudmFsdWUsICdnaScpLCBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJzxzcGFuIGNsYXNzPVwibmVvLWhpZ2hsaWdodC1zZWFyY2hcIj4nICsgbWF0Y2ggKyAnPC9zcGFuPidcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGl0ZW1UZXh0XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaWxlbnQ9ZmFsc2VcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtcyhzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2hlYWRlcmxlc3NTZWxlY3RlZEluZGV4fSA9IG1lLFxuICAgICAgICAgICAgdmRvbSAgICAgICAgICAgICAgICAgICAgICA9IG1lLmdldFZkb21Sb290KCksXG4gICAgICAgICAgICBsaXN0SXRlbTtcblxuICAgICAgICAvLyBpbiBjYXNlIHdlIHNldCBoZWFkZXJsZXNzU2VsZWN0ZWRJbmRleCBiZWZvcmUgdGhlIHN0b3JlIHdhcyBsb2FkZWQsIHNlbGVjdGVkSW5kZXggY2FuIGJlIG51bGxcbiAgICAgICAgLy8gYW5kIHRoZSB3YW50ZWQgc2VsZWN0aW9uIGlzIG5vdCBpbml0aWFsbHkgdGhlcmVcbiAgICAgICAgaWYgKE5lby5pc051bWJlcihoZWFkZXJsZXNzU2VsZWN0ZWRJbmRleCkgJiYgIU5lby5pc051bWJlcihtZS5zZWxlY3RlZEluZGV4KSkge1xuICAgICAgICAgICAgbWUuYWZ0ZXJTZXRIZWFkZXJsZXNzU2VsZWN0ZWRJbmRleChoZWFkZXJsZXNzU2VsZWN0ZWRJbmRleCwgbnVsbClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKG1lLmFuaW1hdGUgJiYgIW1lLmdldFBsdWdpbignbGlzdC1hbmltYXRlJykpKSB7XG4gICAgICAgICAgICB2ZG9tLmNuID0gW107XG5cbiAgICAgICAgICAgIG1lLnN0b3JlLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgbGlzdEl0ZW0gPSBtZS5jcmVhdGVJdGVtKGl0ZW0sIGluZGV4KTtcbiAgICAgICAgICAgICAgICBsaXN0SXRlbSAmJiB2ZG9tLmNuLnB1c2gobGlzdEl0ZW0pXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgIXNpbGVudCAmJiBtZS5wcm9taXNlVXBkYXRlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgbWUuZmlyZSgnY3JlYXRlSXRlbXMnKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICovXG4gICAgZGVzdHJveSguLi5hcmdzKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuc2VsZWN0aW9uTW9kZWw/LmRlc3Ryb3koKTtcblxuICAgICAgICBtZS5hdXRvRGVzdHJveVN0b3JlICYmIG1lLnN0b3JlPy5kZXN0cm95KCk7XG5cbiAgICAgICAgc3VwZXIuZGVzdHJveSguLi5hcmdzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxzIGZvY3VzKCkgb24gdGhlIHRvcCBsZXZlbCBET00gbm9kZSBvZiB0aGlzIGNvbXBvbmVudCBvciBvbiBhIGdpdmVuIG5vZGUgdmlhIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtpZD10aGlzLmlkXVxuICAgICAqL1xuICAgIGZvY3VzKGlkPXRoaXMuaWQpIHtcbiAgICAgICAgdGhpcy5tb3VudGVkICYmIE5lby5tYWluLmFkZG9uLk5hdmlnYXRvci5uYXZpZ2F0ZVRvKHtcbiAgICAgICAgICAgIGRhdGEgICAgOiB0aGlzLm5hdmlnYXRvcixcbiAgICAgICAgICAgIHRhcmdldCAgOiBpZCxcbiAgICAgICAgICAgIHdpbmRvd0lkOiB0aGlzLndpbmRvd0lkXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8TnVtYmVyfVxuICAgICAqL1xuICAgIGdldFJlY29yZElkKHJlY29yZCkge1xuICAgICAgICByZXR1cm4gdGhpcy51c2VJbnRlcm5hbElkID8gdGhpcy5zdG9yZS5nZXRJbnRlcm5hbElkKHJlY29yZCkgOiB0aGlzLnN0b3JlLmdldEtleShyZWNvcmQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBhbiBpbmRleCBleGNsdWRpbmcgbGlzdCBpdGVtIGhlYWRlcnMgaW50byB0aGUgcmVhbCBzdG9yZSBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWFkZXJsZXNzU2VsZWN0ZWRJbmRleFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0U2VsZWN0ZWRJbmRleChoZWFkZXJsZXNzU2VsZWN0ZWRJbmRleCkge1xuICAgICAgICBsZXQgZGVsdGEgICA9IDAsXG4gICAgICAgICAgICBpICAgICAgID0gMCxcbiAgICAgICAgICAgIHJlY29yZHMgPSB0aGlzLnN0b3JlLml0ZW1zLFxuICAgICAgICAgICAgbGVuICAgICA9IGhlYWRlcmxlc3NTZWxlY3RlZEluZGV4O1xuXG4gICAgICAgIGlmIChyZWNvcmRzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKDsgaSA8PSBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKHJlY29yZHNbaV0uaXNIZWFkZXIpIHtcbiAgICAgICAgICAgICAgICBkZWx0YSsrO1xuICAgICAgICAgICAgICAgIGxlbisrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaGVhZGVybGVzc1NlbGVjdGVkSW5kZXggKyBkZWx0YVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGluZGV4IG9mIGEgbGlzdCBpdGVtIGV4Y2x1ZGluZyBpdGVtIGhlYWRlcnNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldEhlYWRlcmxlc3NJbmRleChpbmRleCkge1xuICAgICAgICBsZXQgaGVhZGVybGVzc0luZGV4ID0gMCxcbiAgICAgICAgICAgIGkgICAgICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICByZWNvcmRzICAgICAgICAgPSB0aGlzLnN0b3JlLml0ZW1zO1xuXG4gICAgICAgIGZvciAoOyBpIDwgaW5kZXg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFyZWNvcmRzW2ldLmlzSGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVybGVzc0luZGV4KytcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoZWFkZXJsZXNzSW5kZXhcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8b2JqZWN0fSByZWNvcmRPcklkXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRJdGVtSWQocmVjb3JkT3JJZCkge1xuICAgICAgICBsZXQgaWQgPSByZWNvcmRPcklkO1xuXG4gICAgICAgIGlmIChyZWNvcmRPcklkLmlzUmVjb3JkKSB7XG4gICAgICAgICAgICBpZCA9IHRoaXMuZ2V0UmVjb3JkSWQocmVjb3JkT3JJZClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBgJHt0aGlzLmlkfV9fJHtpZH1gXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZub2RlSWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfE51bWJlcn0gaXRlbUlkXG4gICAgICovXG4gICAgZ2V0SXRlbVJlY29yZElkKHZub2RlSWQpIHtcbiAgICAgICAgbGV0IGl0ZW1JZCA9IHZub2RlSWQuc3BsaXQoJ19fJylbMV07XG5cbiAgICAgICAgaWYgKCF0aGlzLnVzZUludGVybmFsSWQgJiYgdGhpcy5zdG9yZS5nZXRLZXlUeXBlKCk/LmluY2x1ZGVzKCdpbnQnKSkge1xuICAgICAgICAgICAgaXRlbUlkID0gcGFyc2VJbnQoaXRlbUlkKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGl0ZW1JZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN1cHBvcnQgY29sbGVjdGlvbnMgJiBzdG9yZXNcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldEtleVByb3BlcnR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZS5rZXlQcm9wZXJ0eSB8fCB0aGlzLnN0b3JlLm1vZGVsLmtleVByb3BlcnR5XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkNsaWNrKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW07XG5cbiAgICAgICAgaWYgKGRhdGEucGF0aFswXS5pZCA9PT0gbWUuaWQpIHtcbiAgICAgICAgICAgIG1lLm9uQ29udGFpbmVyQ2xpY2soZGF0YSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoaXRlbSBvZiBkYXRhLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5jbHMuaW5jbHVkZXMobWUuaXRlbUNscykpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUub25JdGVtQ2xpY2soaXRlbSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNvbnN0cnVjdGVkKCkge1xuICAgICAgICBzdXBlci5vbkNvbnN0cnVjdGVkKCk7XG5cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbD8ucmVnaXN0ZXIodGhpcylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uQ29udGFpbmVyQ2xpY2soZGF0YSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvbnRhaW5lckNsaWNrIGV2ZW50IGZpcmVzIHdoZW4gYSBjbGljayBvY2N1cnMgb24gdGhlIGNvbXBvbmVudCwgYnV0IG5vdCBvbiBhIGxpc3QgaXRlbVxuICAgICAgICAgKiBAZXZlbnQgY29udGFpbmVyQ2xpY2tcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmdbXX0gY2xzIHRoZSBjbGFzc0xpc3Qgb2YgdGhlIHRhcmdldCBub2RlIChjb252ZXJ0ZWQgdG8gYW4gYXJyYXkpXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZCB0aGUgdGFyZ2V0IGRvbSBpZFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBwYXRoIHRoZSBldmVudCBwYXRoXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpcmUoJ2NvbnRhaW5lckNsaWNrJywgZGF0YSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25JdGVtQ2xpY2sobm9kZSwgZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHJlY29yZCA9IG1lLnN0b3JlLmdldChtZS5nZXRJdGVtUmVjb3JkSWQobm9kZS5pZCkpO1xuXG4gICAgICAgIC8vIHBhc3MgdGhlIHJlY29yZCB0byBjbGFzcyBleHRlbnNpb25zXG4gICAgICAgIGRhdGEucmVjb3JkID0gcmVjb3JkO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaXRlbUNsaWNrIGV2ZW50IGZpcmVzIHdoZW4gYSBjbGljayBvY2N1cnMgb24gYSBsaXN0IGl0ZW1cbiAgICAgICAgICogQGV2ZW50IGl0ZW1DbGlja1xuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgdGhlIHJlY29yZCBtYXRjaGluZyB0aGUgbGlzdCBpdGVtXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBtZS5maXJlKCdpdGVtQ2xpY2snLCB7XG4gICAgICAgICAgICByZWNvcmRcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uU3RvcmVGaWx0ZXIoKSB7XG4gICAgICAgIHRoaXMuY3JlYXRlSXRlbXMoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25TdG9yZUxvYWQoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5tb3VudGVkICYmIG1lLmlzVm5vZGVJbml0aWFsaXppbmcpIHtcbiAgICAgICAgICAgIG1lLm9uKCdtb3VudGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1lLmNyZWF0ZUl0ZW1zKClcbiAgICAgICAgICAgIH0sIG1lLCB7b25jZTogdHJ1ZX0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUuY3JlYXRlSXRlbXMoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLmZpZWxkcyBFYWNoIGZpZWxkIG9iamVjdCBjb250YWlucyB0aGUga2V5czogbmFtZSwgb2xkVmFsdWUsIHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEuaW5kZXhcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLk1vZGVsfSBkYXRhLm1vZGVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEucmVjb3JkXG4gICAgICovXG4gICAgb25TdG9yZVJlY29yZENoYW5nZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtpbmRleH0gPSBkYXRhO1xuXG4gICAgICAgIC8vIGlnbm9yZSBjaGFuZ2VzIGZvciByZWNvcmRzIHdoaWNoIGhhdmUgbm90IGJlZW4gYWRkZWQgdG8gdGhlIGxpc3QgeWV0XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICBtZS52ZG9tLmNuW2luZGV4XSA9IG1lLmNyZWF0ZUl0ZW0oZGF0YS5yZWNvcmQsIGluZGV4KTtcbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGEuaXRlbXNcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLnByZXZpb3VzSXRlbXNcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLlN0b3JlfSBkYXRhLnNjb3BlXG4gICAgICovXG4gICAgb25TdG9yZVNvcnQoZGF0YSkge1xuICAgICAgICB0aGlzLmNyZWF0ZUl0ZW1zKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gaXRlbVxuICAgICAqL1xuICAgIHNlbGVjdEl0ZW0oaXRlbSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUuZGlzYWJsZVNlbGVjdGlvbikge1xuICAgICAgICAgICAgLy8gU2VsZWN0aW5nIGluZGV4XG4gICAgICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgbWUuc2VsZWN0aW9uTW9kZWw/LnNlbGVjdEF0KGl0ZW0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZWxlY3RpbmcgcmVjb3JkXG4gICAgICAgICAgICBlbHNlIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgbWUuc2VsZWN0aW9uTW9kZWw/LnNlbGVjdEF0KG1lLnN0b3JlLmluZGV4T2YoaXRlbSkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVJdGVtRm9jdXModmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7bmF2aWdhdGVUb30gPSBOZW8ubWFpbi5hZGRvbi5OYXZpZ2F0b3I7XG5cbiAgICAgICAgaWYgKG1lLm1vdW50ZWQpIHtcbiAgICAgICAgICAgIGlmIChOZW8uaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgbmF2aWdhdGVUbyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgICAgOiBtZS5uYXZpZ2F0b3IsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCAgOiBtZS5nZXRIZWFkZXJsZXNzSW5kZXgodmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3dJZDogbWUud2luZG93SWRcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIG5hdmlnYXRlVG8oe1xuICAgICAgICAgICAgICAgICAgICBkYXRhICAgIDogbWUubmF2aWdhdG9yLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgIDogbWUuZ2V0SXRlbUlkKG1lLmdldFJlY29yZElkKHZhbHVlKSksXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0lkOiBtZS53aW5kb3dJZFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5vbignbW91bnRlZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBXZSBjb3VsZCBzdWJzY3JpYmUgbXVsdGlwbGUgdGltZXMgYmVmb3JlIGdldHRpbmcgbW91bnRlZCxcbiAgICAgICAgICAgICAgICAvLyBzbyBvbmx5IHRyaWdnZXIgdGhlIGNhbGxiYWNrIGZvciB0aGUgbGFzdCBmb2N1c0luZGV4XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBtZS5mb2N1c0luZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnVwZGF0ZUl0ZW1Gb2N1cyhtZS5mb2N1c0luZGV4KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIG1lLCB7b25jZTogdHJ1ZX0pXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKExpc3QpO1xuIiwiaW1wb3J0IE1vZGVsIGZyb20gJy4vTW9kZWwubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnNlbGVjdGlvbi5MaXN0TW9kZWxcbiAqIEBleHRlbmRzIE5lby5zZWxlY3Rpb24uTW9kZWxcbiAqL1xuY2xhc3MgTGlzdE1vZGVsIGV4dGVuZHMgTW9kZWwge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnNlbGVjdGlvbi5MaXN0TW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5zZWxlY3Rpb24uTGlzdE1vZGVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3NlbGVjdGlvbi1saXN0bW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnc2VsZWN0aW9uLWxpc3Rtb2RlbCdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQbGFjZWhvbGRlciBtZXRob2QgdG8gZ2V0IG92ZXJyaWRkZW4gYnkgY2xhc3MgZXh0ZW5zaW9uIGxpc3QgbWVudS5MaXN0TW9kZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uS2V5RG93bkVzY2FwZShkYXRhKSB7fVxuXG4gICAgLyoqXG4gICAgICogUGxhY2Vob2xkZXIgbWV0aG9kIHRvIGdldCBvdmVycmlkZGVuIGJ5IGNsYXNzIGV4dGVuc2lvbiBsaXN0IG1lbnUuTGlzdE1vZGVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbktleURvd25Eb3duKGRhdGEpIHt9XG5cbiAgICAvKipcbiAgICAgKiBQbGFjZWhvbGRlciBtZXRob2QgdG8gZ2V0IG92ZXJyaWRkZW4gYnkgY2xhc3MgZXh0ZW5zaW9uIGxpc3QgbWVudS5MaXN0TW9kZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uS2V5RG93bkVudGVyKGRhdGEpIHt9XG5cbiAgICAvKipcbiAgICAgKiBQbGFjZWhvbGRlciBtZXRob2QgdG8gZ2V0IG92ZXJyaWRkZW4gYnkgY2xhc3MgZXh0ZW5zaW9uIGxpc3QgbWVudS5MaXN0TW9kZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uS2V5RG93bkxlZnQoZGF0YSkge31cblxuICAgIC8qKlxuICAgICAqIFBsYWNlaG9sZGVyIG1ldGhvZCB0byBnZXQgb3ZlcnJpZGRlbiBieSBjbGFzcyBleHRlbnNpb24gbGlzdCBtZW51Lkxpc3RNb2RlbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25LZXlEb3duUmlnaHQoZGF0YSkge31cblxuICAgIC8qKlxuICAgICAqIFBsYWNlaG9sZGVyIG1ldGhvZCB0byBnZXQgb3ZlcnJpZGRlbiBieSBjbGFzcyBleHRlbnNpb24gbGlzdCBtZW51Lkxpc3RNb2RlbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25LZXlEb3duVXAoZGF0YSkge31cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25MaXN0Q2xpY2soe2N1cnJlbnRUYXJnZXR9KSB7XG4gICAgICAgIGxldCB7dmlld30gPSB0aGlzLFxuICAgICAgICAgICAgaWQgICAgID0gdmlldy5nZXRJdGVtUmVjb3JkSWQoY3VycmVudFRhcmdldCksXG4gICAgICAgICAgICByZWNvcmQgPSB2aWV3LnN0b3JlLmdldChpZCk7XG5cbiAgICAgICAgaWYgKCF2aWV3LmRpc2FibGVTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHJlY29yZCAmJiB0aGlzLnNlbGVjdChyZWNvcmQpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uTGlzdE5hdmlnYXRlKGRhdGEpIHtcbiAgICAgICAgbGV0IHt2aWV3fSAgPSB0aGlzLFxuICAgICAgICAgICAge3N0b3JlfSA9IHZpZXcsXG4gICAgICAgICAgICByZWNvcmQsIHJlY29yZElkO1xuXG4gICAgICAgIGlmIChkYXRhLmFjdGl2ZUl0ZW0pIHtcbiAgICAgICAgICAgIHJlY29yZElkID0gdmlldy5nZXRJdGVtUmVjb3JkSWQoZGF0YS5hY3RpdmVJdGVtKTtcbiAgICAgICAgICAgIHJlY29yZCAgID0gc3RvcmUuZ2V0KHJlY29yZElkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVjb3JkKSB7XG4gICAgICAgICAgICByZWNvcmQgPSBzdG9yZS5nZXRBdChNYXRoLm1pbihkYXRhLmFjdGl2ZUluZGV4LCBzdG9yZS5nZXRDb3VudCgpKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEucmVjb3JkICAgICAgPSByZWNvcmQ7XG4gICAgICAgIHZpZXcuX2ZvY3VzSW5kZXggPSBzdG9yZS5pbmRleE9mKHJlY29yZCk7IC8vIHNpbGVudCB1cGRhdGUsIG5vIG5lZWQgdG8gcmVmb2N1c1xuXG4gICAgICAgIHZpZXcuZmlyZSgnaXRlbU5hdmlnYXRlJywgZGF0YSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50XG4gICAgICovXG4gICAgcmVnaXN0ZXIoY29tcG9uZW50KSB7XG4gICAgICAgIHN1cGVyLnJlZ2lzdGVyKGNvbXBvbmVudCk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2lkLCB2aWV3fSA9IG1lO1xuXG4gICAgICAgIHZpZXcuYWRkRG9tTGlzdGVuZXJzKFt7XG4gICAgICAgICAgICBjbGljazogbWUub25MaXN0Q2xpY2ssXG4gICAgICAgICAgICBzY29wZTogbWUsXG5cbiAgICAgICAgICAgIC8vIFNob3VsZCBiZSBgLiR7dmlldy5pdGVtQ2xzfTpub3QoLm5lby1kaXNhYmxlZCwubmVvLWxpc3QtaGVhZGVyKWBcbiAgICAgICAgICAgIC8vIFRPRE8gcGFyc2UgZGVsZWdhdGUgc2VsZWN0b3JzXG4gICAgICAgICAgICBkZWxlZ2F0ZTogcGF0aCA9PiB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHsgbGVuZ3RoIH0gPSBwYXRoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBjbHMgfSA9IHBhdGhbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNscy5pbmNsdWRlcyh2aWV3Lml0ZW1DbHMpICYmICFjbHMuaW5jbHVkZXMoJ25lby1kaXNhYmxlZCcpICYmICFjbHMuaW5jbHVkZXMoJ25lby1saXN0LWhlYWRlcicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmVvbmF2aWdhdGUgOiBtZS5vbkxpc3ROYXZpZ2F0ZSxcbiAgICAgICAgICAgIHNjb3BlICAgICAgIDogbWVcbiAgICAgICAgfV0pO1xuXG4gICAgICAgIHZpZXcua2V5cz8uX2tleXMucHVzaChcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93bkRvd24nICAgLGtleTogJ0Rvd24nICAgLHNjb3BlOiBpZH0sXG4gICAgICAgICAgICB7Zm46ICdvbktleURvd25FbnRlcicgICxrZXk6ICdFbnRlcicgICxzY29wZTogaWR9LFxuICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duRXNjYXBlJyAsa2V5OiAnRXNjYXBlJyAsc2NvcGU6IGlkfSxcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93bkxlZnQnICAgLGtleTogJ0xlZnQnICAgLHNjb3BlOiBpZH0sXG4gICAgICAgICAgICB7Zm46ICdvbktleURvd25SaWdodCcgICxrZXk6ICdSaWdodCcgICxzY29wZTogaWR9LFxuICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duVXAnICAgICAsa2V5OiAnVXAnICAgICAsc2NvcGU6IGlkfVxuICAgICAgICApXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICovXG4gICAgc2VsZWN0QXQoaW5kZXgpIHtcbiAgICAgICAgbGV0IHt2aWV3fSA9IHRoaXMsXG4gICAgICAgICAgICByZWNvcmQgPSB2aWV3Py5zdG9yZS5nZXRBdChpbmRleCksXG4gICAgICAgICAgICBpdGVtSWQgPSByZWNvcmQgJiYgdmlldy5nZXRJdGVtSWQodmlldy5nZXRSZWNvcmRJZChyZWNvcmQpKTtcblxuICAgICAgICBpdGVtSWQgJiYgdGhpcy5zZWxlY3QoaXRlbUlkKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgdW5yZWdpc3RlcigpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2lkLCB2aWV3fSA9IG1lO1xuXG4gICAgICAgIHZpZXcua2V5cz8ucmVtb3ZlS2V5cyhbXG4gICAgICAgICAgICB7Zm46ICdvbktleURvd25Eb3duJyAgICxrZXk6ICdEb3duJyAgICxzY29wZTogaWR9LFxuICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duRW50ZXInICAsa2V5OiAnRW50ZXInICAsc2NvcGU6IGlkfSxcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93bkVzY2FwZScgLGtleTogJ0VzY2FwZScgLHNjb3BlOiBpZH0sXG4gICAgICAgICAgICB7Zm46ICdvbktleURvd25MZWZ0JyAgICxrZXk6ICdMZWZ0JyAgICxzY29wZTogaWR9LFxuICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duUmlnaHQnICAsa2V5OiAnUmlnaHQnICAsc2NvcGU6IGlkfSxcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93blVwJyAgICAgLGtleTogJ1VwJyAgICAgLHNjb3BlOiBpZH1cbiAgICAgICAgXSk7XG5cbiAgICAgICAgc3VwZXIudW5yZWdpc3RlcigpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhMaXN0TW9kZWwpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9