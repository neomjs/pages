"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_list_Base_mjs"],{

/***/ "./src/list/Base.mjs":
/*!***************************!*\
  !*** ./src/list/Base.mjs ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _selection_ListModel_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../selection/ListModel.mjs */ "./src/selection/ListModel.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _data_Store_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../data/Store.mjs */ "./src/data/Store.mjs");






/**
 * @class Neo.list.Base
 * @extends Neo.component.Base
 */
class List extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.list.Base'
         * @protected
         */
        className: 'Neo.list.Base',
        /**
         * @member {String} ntype='list'
         * @protected
         */
        ntype: 'list',
        /**
         * @member {Boolean} animate_=false
         */
        animate_: false,
        /**
         * True will destroy the used collection / store when the component gets destroyed
         * @member {Boolean} autoDestroyStore=true
         */
        autoDestroyStore: true,
        /**
         * @member {String[]} baseCls=['neo-list']
         */
        baseCls: ['neo-list'],
        /**
         * An optional record field to make items non-clickable and visually greyed out.
         * The field expects the Boolean type.
         * @member {String} disabledField='disabled'
         */
        disabledField: 'disabled',
        /**
         * @member {Boolean} disableSelection_=false
         */
        disableSelection_: false,
        /**
         * @member {String} displayField='name'
         */
        displayField: 'name',
        /**
         * @member {Boolean} draggable_=false
         */
        draggable_: false,
        /**
         * @member {Neo.draggable.list.DragZone|null} dragZone=null
         */
        dragZone: null,
        /**
         * @member {Object} dragZoneConfig=null
         */
        dragZoneConfig: null,
        /**
         * Keeps track of the focussed item index and allows bindings and programmatic changes.
         * You can either pass the index or the related record
         * @member {Number|Object|null} focusIndex_=null
         */
        focusIndex_: null,
        /**
         * In case we are using list item headers and want to bind list item indexes to e.g. a card layout
         * for e.g. a sidenav, this config comes in handy.
         * @member {Number|null} headerlessSelectedIndex_=null
         */
        headerlessSelectedIndex_: null,
        /**
         * @member {Boolean} highlightFilterValue=true
         */
        highlightFilterValue: true,
        /**
         * @member {String} itemCls='neo-list-item'
         */
        itemCls: 'neo-list-item',
        /**
         * Defaults to px
         * @member {Number|null} itemHeight_=null
         */
        itemHeight_: null,
        /**
         * The type of the node / tag for each list item
         * @member {String} itemTagName='li'
         */
        itemTagName: 'li',
        /**
         * Defaults to px
         * @member {Number|null} itemWidth_=null
         */
        itemWidth_: null,
        /**
         * @member {Boolean} itemsFocusable=true
         */
        itemsFocusable: true,
        /**
         * The config will get passed to the navigator main thread addon.
         * E.g. for ComboBoxes, which shall preserve their focussed list item when filtering the store, use true.
         * @member {Boolean} keepFocusIndex=false
         */
        keepFocusIndex: false,
        /**
         * Additional used keys for the selection model
         * @member {Object} keys
         */
        keys: {},
        /**
         * config values for Neo.list.plugin.Animate
         * @member {Object} pluginAnimateConfig=null
         */
        pluginAnimateConfig: null,
        /**
         * Keeps track of the selected item index and allows bindings and programmatic changes
         * @member {Number|null} selectedIndex_=null
         */
        selectedIndex_: null,
        /**
         * Either pass a selection.Model module, an instance or a config object
         * @member {Object|Neo.selection.Model} selectionModel_=null
         */
        selectionModel_: null,
        /**
         * Set this to true in case a keyboard navigation should immediately select the focussed item
         * @member {Boolean} selectOnFocus=false
         */
        selectOnFocus: false,
        /**
         * Set this to true in case a select event should only update _vdom (e.g. when used inside a form.field.ComboBox
         * @member {Boolean} silentSelect=false
         */
        silentSelect: false,
        /**
         * @member {Neo.data.Store|null} store_=null
         */
        store_: null,
        /**
         * True will add a checkbox in front of each list item
         * @member {Boolean} stacked_=true
         */
        useCheckBoxes_: false,
        /**
         * Setting this config to true will switch to dl, dt & dd tags instead of using ul & li.
         * Use the {Boolean} model field isHeader.
         * @member {Boolean} useHeaders_=false
         */
        useHeaders_: false,
        /**
         * @member {Boolean} useWrapperNode_=false
         */
        useWrapperNode_: false,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {tag: 'ul', cn: []}
    }

    /**
     * @member {String|null} itemRole=null
     */
    itemRole = null
    /**
     * An object to help configure the navigation. Used to pass to {@link Neo.main.addon.Navigator#subscribe}.
     * @member {Object} navigator={}
     */
    navigator = {}
    /**
     * Defaults to false in case useHeaders is set to true
     * @member {Boolean} scrollIntoViewOnFocus=true
     */
    scrollIntoViewOnFocus = true

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        if (me.useHeaders) {
            me.scrollIntoViewOnFocus = false
        }

        me.addDomListeners({
            click: me.onClick,
            scope: me
        })
    }

    /**
     * Triggered after the animate config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetAnimate(value, oldValue) {
        if (value && !this.getPlugin('list-animate')) {
            __webpack_require__.e(/*! import() */ "vendors-src_list_plugin_Animate_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./plugin/Animate.mjs */ "./src/list/plugin/Animate.mjs")).then(module => {
                let me      = this,
                    plugins = me.plugins || [];

                plugins.push({
                    module: module.default,
                    ...me.pluginAnimateConfig
                });

                me.plugins = plugins
            })
        }
    }

    /**
     * Triggered after the disableSelection config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetDisableSelection(value, oldValue) {
        value && this.rendered && this.selectionModel?.deselectAll()
    }

    /**
     * Triggered after the draggable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetDraggable(value, oldValue) {
        let me = this;

        if (value && !me.dragZone) {
            Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("src_draggable_list_DragZone_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ../draggable/list/DragZone.mjs */ "./src/draggable/list/DragZone.mjs")).then(module => {
                me.dragZone = Neo.create({
                    module  : module.default,
                    appName : me.appName,
                    owner   : me,
                    windowId: me.windowId,
                    ...me.dragZoneConfig
                })
            })
        }
    }

    /**
     * Triggered after the focusIndex config got changed
     * @param {Number|Object|null} value
     * @param {Number|Object|null} oldValue
     * @protected
     */
    afterSetFocusIndex(value, oldValue) {
        value !== null && this.updateItemFocus(value)
    }

    /**
     * Triggered after the headerlessSelectedIndex config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetHeaderlessSelectedIndex(value, oldValue) {
        let me = this;

        if (Neo.isNumber(value)) {
            me.selectedIndex = me.store.getCount() ? me.getSelectedIndex(value) : null
        } else if (Neo.isNumber(oldValue)) {
            me.selectedIndex = null
        }
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        let me = this;

        // Tear down navigation before we lose the element
        if (!value && me.hasNavigator) {
            Neo.main.addon.Navigator.unsubscribe(me.navigator);

            me.hasNavigator  = false;
            me.selectedIndex = null
        }

        if (value) {
            // Set up item navigation in the list
            if (!me.hasNavigator) {
                me.navigator = {
                    appName       : me.appName,
                    autoClick     : me.selectOnFocus,
                    id            : me.id,
                    keepFocusIndex: me.keepFocusIndex,
                    selector      : `.${me.itemCls}:not(.neo-disabled,.neo-list-header)`,
                    windowId      : me.windowId,
                    ...me.navigator
                };

                me.hasNavigator = true
            }

            Neo.main.addon.Navigator.subscribe(me.navigator)
        }

        super.afterSetMounted(value, oldValue)
    }

    /**
     * Triggered after the selectedIndex config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetSelectedIndex(value, oldValue) {
        let me               = this,
            {selectionModel} = me;

        if (Neo.isNumber(value)) {
            selectionModel?.selectAt(value);
            me.headerlessSelectedIndex = me.getHeaderlessIndex(value)
        } else if (Neo.isNumber(oldValue)) {
            selectionModel.deselectAll();
            me.headerlessSelectedIndex = null
        }
    }

    /**
     * Triggered after the selectionModel config got changed
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @protected
     */
    afterSetSelectionModel(value, oldValue) {
        this.rendered && value.register(this)
    }

    /**
     * Triggered after the store config got changed
     * @param {Neo.data.Store} value
     * @param {Neo.data.Store} oldValue
     * @protected
     */
    afterSetStore(value, oldValue) {
        let me = this;

        value?.on({
            filter      : 'onStoreFilter',
            load        : 'onStoreLoad',
            recordChange: 'onStoreRecordChange',
            sort        : 'onStoreSort',
            scope       : me
        });

        value?.getCount() > 0 && me.onStoreLoad()
    }

    /**
     * Triggered after the useCheckBoxes config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetUseCheckBoxes(value, oldValue) {
        let me    = this,
            {cls} = me;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].toggle(cls, 'neo-use-checkicons', !!value);
        me.cls = cls
    }

    /**
     * Triggered after the useHeaders config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetUseHeaders(value, oldValue) {
        if (value) {
            let me = this;

            me.vdom.tag = 'dl';
            me.itemTagName = 'dd'
        }
    }

    /**
     * Triggered after the useWrapperNode config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetUseWrapperNode(value, oldValue) {
        let me                = this,
            {cls, wrapperCls} = me;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"][value ? 'add' : 'remove'](cls, 'neo-use-wrapper-node');
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"][value ? 'add' : 'remove'](wrapperCls, 'neo-list-wrapper');

        me.wrapperCls = wrapperCls;
        me.cls        = cls
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        super.afterSetWindowId(value, oldValue);

        let {navigator} = this;

        if (navigator) {
            navigator.windowId = value
        }
    }

    /**
     * Triggered before the selectionModel config gets changed.
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @returns {Neo.selection.Model}
     * @protected
     */
    beforeSetSelectionModel(value, oldValue) {
        oldValue?.destroy();
        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].beforeSetInstance(value, _selection_ListModel_mjs__WEBPACK_IMPORTED_MODULE_2__["default"])
    }

    /**
     * Triggered before the store config gets changed.
     * @param {Object|Neo.data.Store} value
     * @param {Object|Neo.data.Store} oldValue
     * @returns {Neo.data.Store}
     * @protected
     */
    beforeSetStore(value, oldValue) {
        oldValue?.destroy();
        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].beforeSetInstance(value, _data_Store_mjs__WEBPACK_IMPORTED_MODULE_4__["default"])
    }

    /**
     * Override this method for custom list items
     * @param {Object} record
     * @param {Number} index
     * @returns {Object} The list item vdom object
     */
    createItem(record, index) {
        let me               = this,
            cls              = [me.itemCls],
            hasItemHeight    = me.itemHeight !== null,
            hasItemWidth     = me.itemWidth !== null,
            isHeader         = me.useHeaders && record.isHeader,
            itemContent      = me.createItemContent(record, index),
            itemId           = me.getItemId(record[me.getKeyProperty()]),
            {selectionModel} = me,
            isSelected       = !me.disableSelection && selectionModel?.isSelected(itemId),
            item, removeDom;

        isHeader && cls.push('neo-list-header');

        if (isSelected){
            cls.push(selectionModel.selectedCls)
        }

        if (record.cls) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(cls, record.cls)
        }

        if (record[me.disabledField]) {
            cls.push('neo-disabled')
        }

        item = {
            id  : itemId,
            tag : isHeader ? 'dt' : me.itemTagName,
            'aria-selected' : isSelected,
            cls
        };

        if (me.itemsFocusable) {
            item.tabIndex = -1
        }

        if (record.hidden || itemContent.removeDom) {
            item.removeDom = true
        }

        if (me.itemRole) {
            item.role = me.itemRole
        }

        switch (Neo.typeOf(itemContent)) {
            case null: {
                return null
            }

            case 'Array': {
                item.cn = itemContent;

                removeDom = true;

                itemContent.forEach(item => {
                    if (!item.removeDom) {
                        removeDom = false
                    }
                })

                if (removeDom) {
                    item.removeDom = true
                }

                break
            }

            case 'Object': {
                // We want a merge for custom cls rules
                if (itemContent.cls) {
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(item.cls, itemContent.cls);
                    delete itemContent.cls
                }

                Object.assign(item, itemContent);
                break
            }

            case 'Number':
            case 'String': {
                item.html = itemContent;
                break
            }
        }

        if (hasItemHeight || hasItemWidth) {
            item.style = item.style || {};

            if (hasItemHeight && !item.hasOwnProperty('height')) {
                item.style.height = `${me.itemHeight}px`
            }

            if (hasItemWidth && !item.hasOwnProperty('width')) {
                item.style.width = `${me.itemWidth}px`
            }
        }

        return item
    }

    /**
     * Override this method for custom renderers
     * @param {Object} record
     * @param {Number} index
     * @returns {Object|Object[]|String} Either a config object to assign to the item, a vdom cn array or a html string
     */
    createItemContent(record, index) {
        let me       = this,
            itemText = record[me.displayField],
            filter;

        if (me.highlightFilterValue) {
            filter = me.store.getFilter(me.displayField);

            if (filter && filter.value !== null && filter.value !== '') {
                itemText = itemText.replace(new RegExp(filter.value, 'gi'), function(match) {
                    return '<span class="neo-highlight-search">' + match + '</span>'
                })
            }
        }

        return itemText
    }

    /**
     * @param {Boolean} silent=false
     */
    createItems(silent=false) {
        let me                        = this,
            {headerlessSelectedIndex} = me,
            vdom                      = me.getVdomRoot(),
            listItem;

        // in case we set headerlessSelectedIndex before the store was loaded, selectedIndex can be null
        // and the wanted selection is not initially there
        if (Neo.isNumber(headerlessSelectedIndex) && !Neo.isNumber(me.selectedIndex)) {
            me.afterSetHeaderlessSelectedIndex(headerlessSelectedIndex, null)
        }

        if (!(me.animate && !me.getPlugin('list-animate'))) {
            vdom.cn = [];

            me.store.items.forEach((item, index) => {
                listItem = me.createItem(item, index);
                listItem && vdom.cn.push(listItem)
            });

            !silent && me.promiseUpdate().then(() => {
                me.fire('createItems')
            })
        }
    }

    /**
     * @param args
     */
    destroy(...args) {
        let me = this;

        me.selectionModel?.destroy();

        me.autoDestroyStore && me.store?.destroy();

        super.destroy(...args)
    }

    /**
     * Calls focus() on the top level DOM node of this component or on a given node via id
     * @param {String} [id=this.id]
     */
    focus(id=this.id) {
        this.mounted && Neo.main.addon.Navigator.navigateTo([id, this.navigator])
    }

    /**
     * Transforms an index excluding list item headers into the real store index
     * @param {Number} headerlessSelectedIndex
     * @returns {Number}
     */
    getSelectedIndex(headerlessSelectedIndex) {
        let delta   = 0,
            i       = 0,
            records = this.store.items,
            len     = headerlessSelectedIndex;

        if (records.length < 1) {
            return null
        }

        for (; i <= len; i++) {
            if (records[i].isHeader) {
                delta++;
                len++
            }
        }

        return headerlessSelectedIndex + delta
    }

    /**
     * Returns the index of a list item excluding item headers
     * @param {Number} index
     * @returns {Number}
     */
    getHeaderlessIndex(index) {
        let headerlessIndex = 0,
            i               = 0,
            records         = this.store.items;

        for (; i < index; i++) {
            if (!records[i].isHeader) {
                headerlessIndex++
            }
        }

        return headerlessIndex
    }

    /**
     * @param {Number|String|object} recordOrId
     * @returns {String}
     */
    getItemId(recordOrId) {
        return `${this.id}__${recordOrId.isRecord ? recordOrId[this.getKeyProperty()] : recordOrId}`
    }

    /**
     * @param {String} vnodeId
     * @returns {String|Number} itemId
     */
    getItemRecordId(vnodeId) {
        let itemId   = vnodeId.split('__')[1],
            {model}  = this.store,
            keyField = model?.getField(this.getKeyProperty()),
            keyType  = keyField?.type?.toLowerCase();

        if (keyType === 'int' || keyType === 'integer') {
            itemId = parseInt(itemId)
        }

        return itemId
    }

    /**
     * Support collections & stores
     * @returns {String}
     */
    getKeyProperty() {
        return this.store.keyProperty || this.store.model.keyProperty
    }

    /**
     * @param {Object} data
     */
    onClick(data) {
        let me = this,
            item;

        if (data.path[0].id === me.id) {
            me.onContainerClick(data)
        } else {
            for (item of data.path) {
                if (item.cls.includes(me.itemCls)) {
                    me.onItemClick(item, data);
                    break
                }
            }
        }
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        this.selectionModel?.register(this)
    }

    /**
     * @param {Object} data
     */
    onContainerClick(data) {
        /**
         * The containerClick event fires when a click occurs on the component, but not on a list item
         * @event containerClick
         * @param {String[]} cls the classList of the target node (converted to an array)
         * @param {String} id the target dom id
         * @param {String[]} path the event path
         * @returns {Object}
         */
        this.fire('containerClick', data)
    }

    /**
     * @param {Object} node
     * @param {Object} data
     */
    onItemClick(node, data) {
        let me     = this,
            record = me.store.get(me.getItemRecordId(node.id));

        // pass the record to class extensions
        data.record = record;

        /**
         * The itemClick event fires when a click occurs on a list item
         * @event itemClick
         * @param {String} id the record matching the list item
         * @returns {Object}
         */
        me.fire('itemClick', {
            record
        })
    }

    /**
     *
     */
    onStoreFilter() {
        this.createItems()
    }

    /**
     *
     */
    onStoreLoad() {
        let me = this;

        if (!me.mounted && me.rendering) {
            me.on('mounted', () => {
                me.createItems()
            }, me, {once: true});
        } else {
            me.createItems()
        }
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.fields Each field object contains the keys: name, oldValue, value
     * @param {Number} data.index
     * @param {Neo.data.Model} data.model
     * @param {Object} data.record
     */
    onStoreRecordChange(data) {
        let me      = this,
            {index} = data;

        // ignore changes for records which have not been added to the list yet
        if (index > -1) {
            me.vdom.cn[index] = me.createItem(data.record, index);
            me.update()
        }
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.items
     * @param {Object[]} data.previousItems
     * @param {Neo.data.Store} data.scope
     */
    onStoreSort(data) {
        this.createItems()
    }

    /**
     * Convenience shortcut
     * @param {Number|String} item
     */
    selectItem(item) {
        let me = this;

        if (!me.disableSelection) {
            // Selecting index
            if (Neo.isNumber(item)) {
                me.selectionModel?.selectAt(item)
            }
            // Selecting record
            else if (item) {
                me.selectionModel?.selectAt(me.store.indexOf(item))
            }
        }
    }

    /**
     *
     * @param {Number|Object} value
     * @returns {Promise<void>}
     */
    async updateItemFocus(value) {
        let me           = this,
            {navigateTo} = Neo.main.addon.Navigator;

        if (me.mounted) {
            if (Neo.isNumber(value)) {
                navigateTo([me.getHeaderlessIndex(value), me.navigator])
            } else if (value) {
                navigateTo([me.getItemId(value[me.getKeyProperty()]), me.navigator])
            }
        } else {
            me.on('mounted', () => {
                // We could subscribe multiple times before getting mounted,
                // so only trigger the callback for the last focusIndex
                if (value === me.focusIndex) {
                    me.updateItemFocus(me.focusIndex)
                }
            }, me, {once: true})
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(List));


/***/ }),

/***/ "./src/selection/ListModel.mjs":
/*!*************************************!*\
  !*** ./src/selection/ListModel.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Model_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Model.mjs */ "./src/selection/Model.mjs");


/**
 * @class Neo.selection.ListModel
 * @extends Neo.selection.Model
 */
class ListModel extends _Model_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.selection.ListModel'
         * @protected
         */
        className: 'Neo.selection.ListModel',
        /**
         * @member {String} ntype='selection-listmodel'
         * @protected
         */
        ntype: 'selection-listmodel'
    }

    /**
     * Placeholder method to get overridden by class extension list menu.ListModel
     * @param {Object} data
     */
    onKeyDownEscape(data) {}

    /**
     * Placeholder method to get overridden by class extension list menu.ListModel
     * @param {Object} data
     */
    onKeyDownDown(data) {}

    /**
     * Placeholder method to get overridden by class extension list menu.ListModel
     * @param {Object} data
     */
    onKeyDownEnter(data) {}

    /**
     * Placeholder method to get overridden by class extension list menu.ListModel
     * @param {Object} data
     */
    onKeyDownLeft(data) {}

    /**
     * Placeholder method to get overridden by class extension list menu.ListModel
     * @param {Object} data
     */
    onKeyDownRight(data) {}

    /**
     * Placeholder method to get overridden by class extension list menu.ListModel
     * @param {Object} data
     */
    onKeyDownUp(data) {}

    /**
     * @param {Object} data
     */
    onListClick({ currentTarget }) {
        let {view} = this,
            record;

        if (!view.disableSelection) {
            record = view.store.get(view.getItemRecordId(currentTarget));

            record && this.select(record)
        }
    }

    /**
     * @param {Object} data
     */
    onListNavigate(data) {
        let {view}  = this,
            {store} = view;

        data.record      = store.getAt(Math.min(data.activeIndex, store.getCount()));
        view._focusIndex = store.indexOf(data.record); // silent update, no need to refocus

        view.fire('itemNavigate', data)
    }

    /**
     * @param {Neo.component.Base} component
     */
    register(component) {
        super.register(component);

        let me         = this,
            {id, view} = me;

        view.addDomListeners([{
            click: me.onListClick,
            scope: me,

            // Should be `.${view.itemCls}:not(.neo-disabled,.neo-list-header)`
            // TODO parse delegate selectors
            delegate: path => {
                for (let i = 0, { length } = path; i < length; i++) {
                    const { cls } = path[i];

                    if (cls.includes(view.itemCls) && !cls.includes('neo-disabled') && !cls.includes('neo-list-header')) {
                        return i;
                    }
                }
            }
        }, {
            neonavigate : me.onListNavigate,
            scope       : me
        }]);

        view.keys?._keys.push(
            {fn: 'onKeyDownDown'   ,key: 'Down'   ,scope: id},
            {fn: 'onKeyDownEnter'  ,key: 'Enter'  ,scope: id},
            {fn: 'onKeyDownEscape' ,key: 'Escape' ,scope: id},
            {fn: 'onKeyDownLeft'   ,key: 'Left'   ,scope: id},
            {fn: 'onKeyDownRight'  ,key: 'Right'  ,scope: id},
            {fn: 'onKeyDownUp'     ,key: 'Up'     ,scope: id}
        )
    }

    /**
     * @param {Number} index
     */
    selectAt(index) {
        let {view}    = this,
            recordKey = view?.store.getKeyAt(index),
            itemId    = recordKey && view.getItemId(recordKey);

        itemId && this.select(itemId)
    }

    /**
     *
     */
    unregister() {
        let me         = this,
            {id, view} = me;

        view.keys?.removeKeys([
            {fn: 'onKeyDownDown'   ,key: 'Down'   ,scope: id},
            {fn: 'onKeyDownEnter'  ,key: 'Enter'  ,scope: id},
            {fn: 'onKeyDownEscape' ,key: 'Escape' ,scope: id},
            {fn: 'onKeyDownLeft'   ,key: 'Left'   ,scope: id},
            {fn: 'onKeyDownRight'  ,key: 'Right'  ,scope: id},
            {fn: 'onKeyDownUp'     ,key: 'Up'     ,scope: id}
        ]);

        super.unregister()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(ListModel));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFzRDtBQUNGO0FBQ0s7QUFDVDtBQUNBOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyREFBUztBQUM1QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQ0FBa0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0Isb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSx5Q0FBeUM7QUFDN0csZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2TEFBOEI7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksa1JBQXdDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQyxlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQixlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7O0FBRWxCLFFBQVEsdURBQVE7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7O0FBRTlCLFFBQVEsdURBQVE7QUFDaEIsUUFBUSx1REFBUTs7QUFFaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsV0FBVzs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDLGVBQWUscUJBQXFCO0FBQ3BDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNkRBQWUsMEJBQTBCLGdFQUFTO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QyxlQUFlLHVCQUF1QjtBQUN0QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZEQUFlLDBCQUEwQix1REFBSztBQUM3RDs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksdURBQVE7QUFDcEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdURBQVE7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUMsY0FBYztBQUNyRDs7QUFFQTtBQUNBLHNDQUFzQyxhQUFhO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUSxJQUFJLHFFQUFxRTtBQUNuRzs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsZUFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixVQUFVO0FBQzdCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU8sV0FBVztBQUMvQixVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTzs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekIsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTyxXQUFXO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxvQkFBb0IsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ3AyQko7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtEQUFLO0FBQzdCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakMsYUFBYSxNQUFNO0FBQ25COztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPOztBQUVwQjtBQUNBLHVEQUF1RDs7QUFFdkQ7QUFDQTs7QUFFQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsVUFBVTs7QUFFdkI7QUFDQTtBQUNBOztBQUVBLDZCQUE2QixhQUFhO0FBQzFDO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUyxRQUFRLFlBQVk7QUFDL0QsNEJBQTRCLE1BQU07O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxhQUFhLGdEQUFnRDtBQUM3RCxhQUFhLGdEQUFnRDtBQUM3RCxhQUFhLGdEQUFnRDtBQUM3RCxhQUFhLGdEQUFnRDtBQUM3RCxhQUFhLGdEQUFnRDtBQUM3RCxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVOztBQUV2QjtBQUNBLGFBQWEsZ0RBQWdEO0FBQzdELGFBQWEsZ0RBQWdEO0FBQzdELGFBQWEsZ0RBQWdEO0FBQzdELGFBQWEsZ0RBQWdEO0FBQzdELGFBQWEsZ0RBQWdEO0FBQzdELGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUseUJBQXlCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2xpc3QvQmFzZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9zZWxlY3Rpb24vTGlzdE1vZGVsLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ2xhc3NTeXN0ZW1VdGlsIGZyb20gJy4uL3V0aWwvQ2xhc3NTeXN0ZW0ubWpzJztcbmltcG9ydCBDb21wb25lbnQgICAgICAgZnJvbSAnLi4vY29tcG9uZW50L0Jhc2UubWpzJztcbmltcG9ydCBMaXN0TW9kZWwgICAgICAgZnJvbSAnLi4vc2VsZWN0aW9uL0xpc3RNb2RlbC5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICAgICAgICBmcm9tICcuLi91dGlsL0FycmF5Lm1qcyc7XG5pbXBvcnQgU3RvcmUgICAgICAgICAgIGZyb20gJy4uL2RhdGEvU3RvcmUubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmxpc3QuQmFzZVxuICogQGV4dGVuZHMgTmVvLmNvbXBvbmVudC5CYXNlXG4gKi9cbmNsYXNzIExpc3QgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmxpc3QuQmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmxpc3QuQmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdsaXN0J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2xpc3QnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYW5pbWF0ZV89ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGFuaW1hdGVfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgd2lsbCBkZXN0cm95IHRoZSB1c2VkIGNvbGxlY3Rpb24gLyBzdG9yZSB3aGVuIHRoZSBjb21wb25lbnQgZ2V0cyBkZXN0cm95ZWRcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXV0b0Rlc3Ryb3lTdG9yZT10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBhdXRvRGVzdHJveVN0b3JlOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tbGlzdCddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1saXN0J10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBvcHRpb25hbCByZWNvcmQgZmllbGQgdG8gbWFrZSBpdGVtcyBub24tY2xpY2thYmxlIGFuZCB2aXN1YWxseSBncmV5ZWQgb3V0LlxuICAgICAgICAgKiBUaGUgZmllbGQgZXhwZWN0cyB0aGUgQm9vbGVhbiB0eXBlLlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGRpc2FibGVkRmllbGQ9J2Rpc2FibGVkJ1xuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZWRGaWVsZDogJ2Rpc2FibGVkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGRpc2FibGVTZWxlY3Rpb25fPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBkaXNhYmxlU2VsZWN0aW9uXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGRpc3BsYXlGaWVsZD0nbmFtZSdcbiAgICAgICAgICovXG4gICAgICAgIGRpc3BsYXlGaWVsZDogJ25hbWUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZHJhZ2dhYmxlXz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ2dhYmxlXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZHJhZ2dhYmxlLmxpc3QuRHJhZ1pvbmV8bnVsbH0gZHJhZ1pvbmU9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ1pvbmU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGRyYWdab25lQ29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdab25lQ29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogS2VlcHMgdHJhY2sgb2YgdGhlIGZvY3Vzc2VkIGl0ZW0gaW5kZXggYW5kIGFsbG93cyBiaW5kaW5ncyBhbmQgcHJvZ3JhbW1hdGljIGNoYW5nZXMuXG4gICAgICAgICAqIFlvdSBjYW4gZWl0aGVyIHBhc3MgdGhlIGluZGV4IG9yIHRoZSByZWxhdGVkIHJlY29yZFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8T2JqZWN0fG51bGx9IGZvY3VzSW5kZXhfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGZvY3VzSW5kZXhfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW4gY2FzZSB3ZSBhcmUgdXNpbmcgbGlzdCBpdGVtIGhlYWRlcnMgYW5kIHdhbnQgdG8gYmluZCBsaXN0IGl0ZW0gaW5kZXhlcyB0byBlLmcuIGEgY2FyZCBsYXlvdXRcbiAgICAgICAgICogZm9yIGUuZy4gYSBzaWRlbmF2LCB0aGlzIGNvbmZpZyBjb21lcyBpbiBoYW5keS5cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IGhlYWRlcmxlc3NTZWxlY3RlZEluZGV4Xz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBoZWFkZXJsZXNzU2VsZWN0ZWRJbmRleF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBoaWdobGlnaHRGaWx0ZXJWYWx1ZT10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBoaWdobGlnaHRGaWx0ZXJWYWx1ZTogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gaXRlbUNscz0nbmVvLWxpc3QtaXRlbSdcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1DbHM6ICduZW8tbGlzdC1pdGVtJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmF1bHRzIHRvIHB4XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBpdGVtSGVpZ2h0Xz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtSGVpZ2h0XzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIG9mIHRoZSBub2RlIC8gdGFnIGZvciBlYWNoIGxpc3QgaXRlbVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGl0ZW1UYWdOYW1lPSdsaSdcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1UYWdOYW1lOiAnbGknLFxuICAgICAgICAvKipcbiAgICAgICAgICogRGVmYXVsdHMgdG8gcHhcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IGl0ZW1XaWR0aF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbVdpZHRoXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGl0ZW1zRm9jdXNhYmxlPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1zRm9jdXNhYmxlOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvbmZpZyB3aWxsIGdldCBwYXNzZWQgdG8gdGhlIG5hdmlnYXRvciBtYWluIHRocmVhZCBhZGRvbi5cbiAgICAgICAgICogRS5nLiBmb3IgQ29tYm9Cb3hlcywgd2hpY2ggc2hhbGwgcHJlc2VydmUgdGhlaXIgZm9jdXNzZWQgbGlzdCBpdGVtIHdoZW4gZmlsdGVyaW5nIHRoZSBzdG9yZSwgdXNlIHRydWUuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGtlZXBGb2N1c0luZGV4PWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBrZWVwRm9jdXNJbmRleDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRpdGlvbmFsIHVzZWQga2V5cyBmb3IgdGhlIHNlbGVjdGlvbiBtb2RlbFxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGtleXNcbiAgICAgICAgICovXG4gICAgICAgIGtleXM6IHt9LFxuICAgICAgICAvKipcbiAgICAgICAgICogY29uZmlnIHZhbHVlcyBmb3IgTmVvLmxpc3QucGx1Z2luLkFuaW1hdGVcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBwbHVnaW5BbmltYXRlQ29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHBsdWdpbkFuaW1hdGVDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBLZWVwcyB0cmFjayBvZiB0aGUgc2VsZWN0ZWQgaXRlbSBpbmRleCBhbmQgYWxsb3dzIGJpbmRpbmdzIGFuZCBwcm9ncmFtbWF0aWMgY2hhbmdlc1xuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gc2VsZWN0ZWRJbmRleF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZWN0ZWRJbmRleF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFaXRoZXIgcGFzcyBhIHNlbGVjdGlvbi5Nb2RlbCBtb2R1bGUsIGFuIGluc3RhbmNlIG9yIGEgY29uZmlnIG9iamVjdFxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8TmVvLnNlbGVjdGlvbi5Nb2RlbH0gc2VsZWN0aW9uTW9kZWxfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHNlbGVjdGlvbk1vZGVsXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGlzIHRvIHRydWUgaW4gY2FzZSBhIGtleWJvYXJkIG5hdmlnYXRpb24gc2hvdWxkIGltbWVkaWF0ZWx5IHNlbGVjdCB0aGUgZm9jdXNzZWQgaXRlbVxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzZWxlY3RPbkZvY3VzPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBzZWxlY3RPbkZvY3VzOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGlzIHRvIHRydWUgaW4gY2FzZSBhIHNlbGVjdCBldmVudCBzaG91bGQgb25seSB1cGRhdGUgX3Zkb20gKGUuZy4gd2hlbiB1c2VkIGluc2lkZSBhIGZvcm0uZmllbGQuQ29tYm9Cb3hcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2lsZW50U2VsZWN0PWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBzaWxlbnRTZWxlY3Q6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmRhdGEuU3RvcmV8bnVsbH0gc3RvcmVfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHN0b3JlXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgd2lsbCBhZGQgYSBjaGVja2JveCBpbiBmcm9udCBvZiBlYWNoIGxpc3QgaXRlbVxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzdGFja2VkXz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICB1c2VDaGVja0JveGVzXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXR0aW5nIHRoaXMgY29uZmlnIHRvIHRydWUgd2lsbCBzd2l0Y2ggdG8gZGwsIGR0ICYgZGQgdGFncyBpbnN0ZWFkIG9mIHVzaW5nIHVsICYgbGkuXG4gICAgICAgICAqIFVzZSB0aGUge0Jvb2xlYW59IG1vZGVsIGZpZWxkIGlzSGVhZGVyLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB1c2VIZWFkZXJzXz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdXNlSGVhZGVyc186IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gdXNlV3JhcHBlck5vZGVfPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB1c2VXcmFwcGVyTm9kZV86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbVxuICAgICAgICAgKi9cbiAgICAgICAgX3Zkb206XG4gICAgICAgIHt0YWc6ICd1bCcsIGNuOiBbXX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gaXRlbVJvbGU9bnVsbFxuICAgICAqL1xuICAgIGl0ZW1Sb2xlID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCB0byBoZWxwIGNvbmZpZ3VyZSB0aGUgbmF2aWdhdGlvbi4gVXNlZCB0byBwYXNzIHRvIHtAbGluayBOZW8ubWFpbi5hZGRvbi5OYXZpZ2F0b3Ijc3Vic2NyaWJlfS5cbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IG5hdmlnYXRvcj17fVxuICAgICAqL1xuICAgIG5hdmlnYXRvciA9IHt9XG4gICAgLyoqXG4gICAgICogRGVmYXVsdHMgdG8gZmFsc2UgaW4gY2FzZSB1c2VIZWFkZXJzIGlzIHNldCB0byB0cnVlXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2Nyb2xsSW50b1ZpZXdPbkZvY3VzPXRydWVcbiAgICAgKi9cbiAgICBzY3JvbGxJbnRvVmlld09uRm9jdXMgPSB0cnVlXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS51c2VIZWFkZXJzKSB7XG4gICAgICAgICAgICBtZS5zY3JvbGxJbnRvVmlld09uRm9jdXMgPSBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgbWUuYWRkRG9tTGlzdGVuZXJzKHtcbiAgICAgICAgICAgIGNsaWNrOiBtZS5vbkNsaWNrLFxuICAgICAgICAgICAgc2NvcGU6IG1lXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBhbmltYXRlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0QW5pbWF0ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICYmICF0aGlzLmdldFBsdWdpbignbGlzdC1hbmltYXRlJykpIHtcbiAgICAgICAgICAgIGltcG9ydCgnLi9wbHVnaW4vQW5pbWF0ZS5tanMnKS50aGVuKG1vZHVsZSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBwbHVnaW5zID0gbWUucGx1Z2lucyB8fCBbXTtcblxuICAgICAgICAgICAgICAgIHBsdWdpbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZTogbW9kdWxlLmRlZmF1bHQsXG4gICAgICAgICAgICAgICAgICAgIC4uLm1lLnBsdWdpbkFuaW1hdGVDb25maWdcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIG1lLnBsdWdpbnMgPSBwbHVnaW5zXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBkaXNhYmxlU2VsZWN0aW9uIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RGlzYWJsZVNlbGVjdGlvbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdmFsdWUgJiYgdGhpcy5yZW5kZXJlZCAmJiB0aGlzLnNlbGVjdGlvbk1vZGVsPy5kZXNlbGVjdEFsbCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBkcmFnZ2FibGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXREcmFnZ2FibGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHZhbHVlICYmICFtZS5kcmFnWm9uZSkge1xuICAgICAgICAgICAgaW1wb3J0KCcuLi9kcmFnZ2FibGUvbGlzdC9EcmFnWm9uZS5tanMnKS50aGVuKG1vZHVsZSA9PiB7XG4gICAgICAgICAgICAgICAgbWUuZHJhZ1pvbmUgPSBOZW8uY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlICA6IG1vZHVsZS5kZWZhdWx0LFxuICAgICAgICAgICAgICAgICAgICBhcHBOYW1lIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgb3duZXIgICA6IG1lLFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3dJZDogbWUud2luZG93SWQsXG4gICAgICAgICAgICAgICAgICAgIC4uLm1lLmRyYWdab25lQ29uZmlnXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGZvY3VzSW5kZXggY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Rm9jdXNJbmRleCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdmFsdWUgIT09IG51bGwgJiYgdGhpcy51cGRhdGVJdGVtRm9jdXModmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBoZWFkZXJsZXNzU2VsZWN0ZWRJbmRleCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRIZWFkZXJsZXNzU2VsZWN0ZWRJbmRleCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgbWUuc2VsZWN0ZWRJbmRleCA9IG1lLnN0b3JlLmdldENvdW50KCkgPyBtZS5nZXRTZWxlY3RlZEluZGV4KHZhbHVlKSA6IG51bGxcbiAgICAgICAgfSBlbHNlIGlmIChOZW8uaXNOdW1iZXIob2xkVmFsdWUpKSB7XG4gICAgICAgICAgICBtZS5zZWxlY3RlZEluZGV4ID0gbnVsbFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtb3VudGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvLyBUZWFyIGRvd24gbmF2aWdhdGlvbiBiZWZvcmUgd2UgbG9zZSB0aGUgZWxlbWVudFxuICAgICAgICBpZiAoIXZhbHVlICYmIG1lLmhhc05hdmlnYXRvcikge1xuICAgICAgICAgICAgTmVvLm1haW4uYWRkb24uTmF2aWdhdG9yLnVuc3Vic2NyaWJlKG1lLm5hdmlnYXRvcik7XG5cbiAgICAgICAgICAgIG1lLmhhc05hdmlnYXRvciAgPSBmYWxzZTtcbiAgICAgICAgICAgIG1lLnNlbGVjdGVkSW5kZXggPSBudWxsXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIFNldCB1cCBpdGVtIG5hdmlnYXRpb24gaW4gdGhlIGxpc3RcbiAgICAgICAgICAgIGlmICghbWUuaGFzTmF2aWdhdG9yKSB7XG4gICAgICAgICAgICAgICAgbWUubmF2aWdhdG9yID0ge1xuICAgICAgICAgICAgICAgICAgICBhcHBOYW1lICAgICAgIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYXV0b0NsaWNrICAgICA6IG1lLnNlbGVjdE9uRm9jdXMsXG4gICAgICAgICAgICAgICAgICAgIGlkICAgICAgICAgICAgOiBtZS5pZCxcbiAgICAgICAgICAgICAgICAgICAga2VlcEZvY3VzSW5kZXg6IG1lLmtlZXBGb2N1c0luZGV4LFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciAgICAgIDogYC4ke21lLml0ZW1DbHN9Om5vdCgubmVvLWRpc2FibGVkLC5uZW8tbGlzdC1oZWFkZXIpYCxcbiAgICAgICAgICAgICAgICAgICAgd2luZG93SWQgICAgICA6IG1lLndpbmRvd0lkLFxuICAgICAgICAgICAgICAgICAgICAuLi5tZS5uYXZpZ2F0b3JcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgbWUuaGFzTmF2aWdhdG9yID0gdHJ1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBOZW8ubWFpbi5hZGRvbi5OYXZpZ2F0b3Iuc3Vic2NyaWJlKG1lLm5hdmlnYXRvcilcbiAgICAgICAgfVxuXG4gICAgICAgIHN1cGVyLmFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzZWxlY3RlZEluZGV4IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTZWxlY3RlZEluZGV4KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7c2VsZWN0aW9uTW9kZWx9ID0gbWU7XG5cbiAgICAgICAgaWYgKE5lby5pc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbk1vZGVsPy5zZWxlY3RBdCh2YWx1ZSk7XG4gICAgICAgICAgICBtZS5oZWFkZXJsZXNzU2VsZWN0ZWRJbmRleCA9IG1lLmdldEhlYWRlcmxlc3NJbmRleCh2YWx1ZSlcbiAgICAgICAgfSBlbHNlIGlmIChOZW8uaXNOdW1iZXIob2xkVmFsdWUpKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25Nb2RlbC5kZXNlbGVjdEFsbCgpO1xuICAgICAgICAgICAgbWUuaGVhZGVybGVzc1NlbGVjdGVkSW5kZXggPSBudWxsXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNlbGVjdGlvbk1vZGVsIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TmVvLnNlbGVjdGlvbi5Nb2RlbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5zZWxlY3Rpb24uTW9kZWx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U2VsZWN0aW9uTW9kZWwodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZWQgJiYgdmFsdWUucmVnaXN0ZXIodGhpcylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHN0b3JlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuU3RvcmV9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5TdG9yZX0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTdG9yZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICB2YWx1ZT8ub24oe1xuICAgICAgICAgICAgZmlsdGVyICAgICAgOiAnb25TdG9yZUZpbHRlcicsXG4gICAgICAgICAgICBsb2FkICAgICAgICA6ICdvblN0b3JlTG9hZCcsXG4gICAgICAgICAgICByZWNvcmRDaGFuZ2U6ICdvblN0b3JlUmVjb3JkQ2hhbmdlJyxcbiAgICAgICAgICAgIHNvcnQgICAgICAgIDogJ29uU3RvcmVTb3J0JyxcbiAgICAgICAgICAgIHNjb3BlICAgICAgIDogbWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFsdWU/LmdldENvdW50KCkgPiAwICYmIG1lLm9uU3RvcmVMb2FkKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHVzZUNoZWNrQm94ZXMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRVc2VDaGVja0JveGVzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAge2Nsc30gPSBtZTtcblxuICAgICAgICBOZW9BcnJheS50b2dnbGUoY2xzLCAnbmVvLXVzZS1jaGVja2ljb25zJywgISF2YWx1ZSk7XG4gICAgICAgIG1lLmNscyA9IGNsc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdXNlSGVhZGVycyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFVzZUhlYWRlcnModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAgICAgbWUudmRvbS50YWcgPSAnZGwnO1xuICAgICAgICAgICAgbWUuaXRlbVRhZ05hbWUgPSAnZGQnXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHVzZVdyYXBwZXJOb2RlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VXNlV3JhcHBlck5vZGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2xzLCB3cmFwcGVyQ2xzfSA9IG1lO1xuXG4gICAgICAgIE5lb0FycmF5W3ZhbHVlID8gJ2FkZCcgOiAncmVtb3ZlJ10oY2xzLCAnbmVvLXVzZS13cmFwcGVyLW5vZGUnKTtcbiAgICAgICAgTmVvQXJyYXlbdmFsdWUgPyAnYWRkJyA6ICdyZW1vdmUnXSh3cmFwcGVyQ2xzLCAnbmVvLWxpc3Qtd3JhcHBlcicpO1xuXG4gICAgICAgIG1lLndyYXBwZXJDbHMgPSB3cmFwcGVyQ2xzO1xuICAgICAgICBtZS5jbHMgICAgICAgID0gY2xzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB3aW5kb3dJZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRXaW5kb3dJZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRXaW5kb3dJZCh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIGxldCB7bmF2aWdhdG9yfSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG5hdmlnYXRvcikge1xuICAgICAgICAgICAgbmF2aWdhdG9yLndpbmRvd0lkID0gdmFsdWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHNlbGVjdGlvbk1vZGVsIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtOZW8uc2VsZWN0aW9uLk1vZGVsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLnNlbGVjdGlvbi5Nb2RlbH0gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TmVvLnNlbGVjdGlvbi5Nb2RlbH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0U2VsZWN0aW9uTW9kZWwodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlPy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiBDbGFzc1N5c3RlbVV0aWwuYmVmb3JlU2V0SW5zdGFuY2UodmFsdWUsIExpc3RNb2RlbClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBzdG9yZSBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fE5lby5kYXRhLlN0b3JlfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fE5lby5kYXRhLlN0b3JlfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtOZW8uZGF0YS5TdG9yZX1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0U3RvcmUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlPy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiBDbGFzc1N5c3RlbVV0aWwuYmVmb3JlU2V0SW5zdGFuY2UodmFsdWUsIFN0b3JlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGZvciBjdXN0b20gbGlzdCBpdGVtc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgbGlzdCBpdGVtIHZkb20gb2JqZWN0XG4gICAgICovXG4gICAgY3JlYXRlSXRlbShyZWNvcmQsIGluZGV4KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNscyAgICAgICAgICAgICAgPSBbbWUuaXRlbUNsc10sXG4gICAgICAgICAgICBoYXNJdGVtSGVpZ2h0ICAgID0gbWUuaXRlbUhlaWdodCAhPT0gbnVsbCxcbiAgICAgICAgICAgIGhhc0l0ZW1XaWR0aCAgICAgPSBtZS5pdGVtV2lkdGggIT09IG51bGwsXG4gICAgICAgICAgICBpc0hlYWRlciAgICAgICAgID0gbWUudXNlSGVhZGVycyAmJiByZWNvcmQuaXNIZWFkZXIsXG4gICAgICAgICAgICBpdGVtQ29udGVudCAgICAgID0gbWUuY3JlYXRlSXRlbUNvbnRlbnQocmVjb3JkLCBpbmRleCksXG4gICAgICAgICAgICBpdGVtSWQgICAgICAgICAgID0gbWUuZ2V0SXRlbUlkKHJlY29yZFttZS5nZXRLZXlQcm9wZXJ0eSgpXSksXG4gICAgICAgICAgICB7c2VsZWN0aW9uTW9kZWx9ID0gbWUsXG4gICAgICAgICAgICBpc1NlbGVjdGVkICAgICAgID0gIW1lLmRpc2FibGVTZWxlY3Rpb24gJiYgc2VsZWN0aW9uTW9kZWw/LmlzU2VsZWN0ZWQoaXRlbUlkKSxcbiAgICAgICAgICAgIGl0ZW0sIHJlbW92ZURvbTtcblxuICAgICAgICBpc0hlYWRlciAmJiBjbHMucHVzaCgnbmVvLWxpc3QtaGVhZGVyJyk7XG5cbiAgICAgICAgaWYgKGlzU2VsZWN0ZWQpe1xuICAgICAgICAgICAgY2xzLnB1c2goc2VsZWN0aW9uTW9kZWwuc2VsZWN0ZWRDbHMpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVjb3JkLmNscykge1xuICAgICAgICAgICAgTmVvQXJyYXkuYWRkKGNscywgcmVjb3JkLmNscylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWNvcmRbbWUuZGlzYWJsZWRGaWVsZF0pIHtcbiAgICAgICAgICAgIGNscy5wdXNoKCduZW8tZGlzYWJsZWQnKVxuICAgICAgICB9XG5cbiAgICAgICAgaXRlbSA9IHtcbiAgICAgICAgICAgIGlkICA6IGl0ZW1JZCxcbiAgICAgICAgICAgIHRhZyA6IGlzSGVhZGVyID8gJ2R0JyA6IG1lLml0ZW1UYWdOYW1lLFxuICAgICAgICAgICAgJ2FyaWEtc2VsZWN0ZWQnIDogaXNTZWxlY3RlZCxcbiAgICAgICAgICAgIGNsc1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChtZS5pdGVtc0ZvY3VzYWJsZSkge1xuICAgICAgICAgICAgaXRlbS50YWJJbmRleCA9IC0xXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVjb3JkLmhpZGRlbiB8fCBpdGVtQ29udGVudC5yZW1vdmVEb20pIHtcbiAgICAgICAgICAgIGl0ZW0ucmVtb3ZlRG9tID0gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lLml0ZW1Sb2xlKSB7XG4gICAgICAgICAgICBpdGVtLnJvbGUgPSBtZS5pdGVtUm9sZVxuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChOZW8udHlwZU9mKGl0ZW1Db250ZW50KSkge1xuICAgICAgICAgICAgY2FzZSBudWxsOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnQXJyYXknOiB7XG4gICAgICAgICAgICAgICAgaXRlbS5jbiA9IGl0ZW1Db250ZW50O1xuXG4gICAgICAgICAgICAgICAgcmVtb3ZlRG9tID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIGl0ZW1Db250ZW50LmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXRlbS5yZW1vdmVEb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZURvbSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZURvbSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnJlbW92ZURvbSA9IHRydWVcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdPYmplY3QnOiB7XG4gICAgICAgICAgICAgICAgLy8gV2Ugd2FudCBhIG1lcmdlIGZvciBjdXN0b20gY2xzIHJ1bGVzXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1Db250ZW50LmNscykge1xuICAgICAgICAgICAgICAgICAgICBOZW9BcnJheS5hZGQoaXRlbS5jbHMsIGl0ZW1Db250ZW50LmNscyk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBpdGVtQ29udGVudC5jbHNcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGl0ZW0sIGl0ZW1Db250ZW50KTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgICAgICAgY2FzZSAnU3RyaW5nJzoge1xuICAgICAgICAgICAgICAgIGl0ZW0uaHRtbCA9IGl0ZW1Db250ZW50O1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzSXRlbUhlaWdodCB8fCBoYXNJdGVtV2lkdGgpIHtcbiAgICAgICAgICAgIGl0ZW0uc3R5bGUgPSBpdGVtLnN0eWxlIHx8IHt9O1xuXG4gICAgICAgICAgICBpZiAoaGFzSXRlbUhlaWdodCAmJiAhaXRlbS5oYXNPd25Qcm9wZXJ0eSgnaGVpZ2h0JykpIHtcbiAgICAgICAgICAgICAgICBpdGVtLnN0eWxlLmhlaWdodCA9IGAke21lLml0ZW1IZWlnaHR9cHhgXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChoYXNJdGVtV2lkdGggJiYgIWl0ZW0uaGFzT3duUHJvcGVydHkoJ3dpZHRoJykpIHtcbiAgICAgICAgICAgICAgICBpdGVtLnN0eWxlLndpZHRoID0gYCR7bWUuaXRlbVdpZHRofXB4YFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGl0ZW1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBmb3IgY3VzdG9tIHJlbmRlcmVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fE9iamVjdFtdfFN0cmluZ30gRWl0aGVyIGEgY29uZmlnIG9iamVjdCB0byBhc3NpZ24gdG8gdGhlIGl0ZW0sIGEgdmRvbSBjbiBhcnJheSBvciBhIGh0bWwgc3RyaW5nXG4gICAgICovXG4gICAgY3JlYXRlSXRlbUNvbnRlbnQocmVjb3JkLCBpbmRleCkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbVRleHQgPSByZWNvcmRbbWUuZGlzcGxheUZpZWxkXSxcbiAgICAgICAgICAgIGZpbHRlcjtcblxuICAgICAgICBpZiAobWUuaGlnaGxpZ2h0RmlsdGVyVmFsdWUpIHtcbiAgICAgICAgICAgIGZpbHRlciA9IG1lLnN0b3JlLmdldEZpbHRlcihtZS5kaXNwbGF5RmllbGQpO1xuXG4gICAgICAgICAgICBpZiAoZmlsdGVyICYmIGZpbHRlci52YWx1ZSAhPT0gbnVsbCAmJiBmaWx0ZXIudmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgaXRlbVRleHQgPSBpdGVtVGV4dC5yZXBsYWNlKG5ldyBSZWdFeHAoZmlsdGVyLnZhbHVlLCAnZ2knKSwgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICc8c3BhbiBjbGFzcz1cIm5lby1oaWdobGlnaHQtc2VhcmNoXCI+JyArIG1hdGNoICsgJzwvc3Bhbj4nXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpdGVtVGV4dFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50PWZhbHNlXG4gICAgICovXG4gICAgY3JlYXRlSXRlbXMoc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtoZWFkZXJsZXNzU2VsZWN0ZWRJbmRleH0gPSBtZSxcbiAgICAgICAgICAgIHZkb20gICAgICAgICAgICAgICAgICAgICAgPSBtZS5nZXRWZG9tUm9vdCgpLFxuICAgICAgICAgICAgbGlzdEl0ZW07XG5cbiAgICAgICAgLy8gaW4gY2FzZSB3ZSBzZXQgaGVhZGVybGVzc1NlbGVjdGVkSW5kZXggYmVmb3JlIHRoZSBzdG9yZSB3YXMgbG9hZGVkLCBzZWxlY3RlZEluZGV4IGNhbiBiZSBudWxsXG4gICAgICAgIC8vIGFuZCB0aGUgd2FudGVkIHNlbGVjdGlvbiBpcyBub3QgaW5pdGlhbGx5IHRoZXJlXG4gICAgICAgIGlmIChOZW8uaXNOdW1iZXIoaGVhZGVybGVzc1NlbGVjdGVkSW5kZXgpICYmICFOZW8uaXNOdW1iZXIobWUuc2VsZWN0ZWRJbmRleCkpIHtcbiAgICAgICAgICAgIG1lLmFmdGVyU2V0SGVhZGVybGVzc1NlbGVjdGVkSW5kZXgoaGVhZGVybGVzc1NlbGVjdGVkSW5kZXgsIG51bGwpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIShtZS5hbmltYXRlICYmICFtZS5nZXRQbHVnaW4oJ2xpc3QtYW5pbWF0ZScpKSkge1xuICAgICAgICAgICAgdmRvbS5jbiA9IFtdO1xuXG4gICAgICAgICAgICBtZS5zdG9yZS5pdGVtcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGxpc3RJdGVtID0gbWUuY3JlYXRlSXRlbShpdGVtLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgbGlzdEl0ZW0gJiYgdmRvbS5jbi5wdXNoKGxpc3RJdGVtKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICFzaWxlbnQgJiYgbWUucHJvbWlzZVVwZGF0ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1lLmZpcmUoJ2NyZWF0ZUl0ZW1zJylcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqL1xuICAgIGRlc3Ryb3koLi4uYXJncykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnNlbGVjdGlvbk1vZGVsPy5kZXN0cm95KCk7XG5cbiAgICAgICAgbWUuYXV0b0Rlc3Ryb3lTdG9yZSAmJiBtZS5zdG9yZT8uZGVzdHJveSgpO1xuXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koLi4uYXJncylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxscyBmb2N1cygpIG9uIHRoZSB0b3AgbGV2ZWwgRE9NIG5vZGUgb2YgdGhpcyBjb21wb25lbnQgb3Igb24gYSBnaXZlbiBub2RlIHZpYSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbaWQ9dGhpcy5pZF1cbiAgICAgKi9cbiAgICBmb2N1cyhpZD10aGlzLmlkKSB7XG4gICAgICAgIHRoaXMubW91bnRlZCAmJiBOZW8ubWFpbi5hZGRvbi5OYXZpZ2F0b3IubmF2aWdhdGVUbyhbaWQsIHRoaXMubmF2aWdhdG9yXSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGFuIGluZGV4IGV4Y2x1ZGluZyBsaXN0IGl0ZW0gaGVhZGVycyBpbnRvIHRoZSByZWFsIHN0b3JlIGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlYWRlcmxlc3NTZWxlY3RlZEluZGV4XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRTZWxlY3RlZEluZGV4KGhlYWRlcmxlc3NTZWxlY3RlZEluZGV4KSB7XG4gICAgICAgIGxldCBkZWx0YSAgID0gMCxcbiAgICAgICAgICAgIGkgICAgICAgPSAwLFxuICAgICAgICAgICAgcmVjb3JkcyA9IHRoaXMuc3RvcmUuaXRlbXMsXG4gICAgICAgICAgICBsZW4gICAgID0gaGVhZGVybGVzc1NlbGVjdGVkSW5kZXg7XG5cbiAgICAgICAgaWYgKHJlY29yZHMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoOyBpIDw9IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocmVjb3Jkc1tpXS5pc0hlYWRlcikge1xuICAgICAgICAgICAgICAgIGRlbHRhKys7XG4gICAgICAgICAgICAgICAgbGVuKytcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoZWFkZXJsZXNzU2VsZWN0ZWRJbmRleCArIGRlbHRhXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgYSBsaXN0IGl0ZW0gZXhjbHVkaW5nIGl0ZW0gaGVhZGVyc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0SGVhZGVybGVzc0luZGV4KGluZGV4KSB7XG4gICAgICAgIGxldCBoZWFkZXJsZXNzSW5kZXggPSAwLFxuICAgICAgICAgICAgaSAgICAgICAgICAgICAgID0gMCxcbiAgICAgICAgICAgIHJlY29yZHMgICAgICAgICA9IHRoaXMuc3RvcmUuaXRlbXM7XG5cbiAgICAgICAgZm9yICg7IGkgPCBpbmRleDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXJlY29yZHNbaV0uaXNIZWFkZXIpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJsZXNzSW5kZXgrK1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhlYWRlcmxlc3NJbmRleFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xvYmplY3R9IHJlY29yZE9ySWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldEl0ZW1JZChyZWNvcmRPcklkKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmlkfV9fJHtyZWNvcmRPcklkLmlzUmVjb3JkID8gcmVjb3JkT3JJZFt0aGlzLmdldEtleVByb3BlcnR5KCldIDogcmVjb3JkT3JJZH1gXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZub2RlSWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfE51bWJlcn0gaXRlbUlkXG4gICAgICovXG4gICAgZ2V0SXRlbVJlY29yZElkKHZub2RlSWQpIHtcbiAgICAgICAgbGV0IGl0ZW1JZCAgID0gdm5vZGVJZC5zcGxpdCgnX18nKVsxXSxcbiAgICAgICAgICAgIHttb2RlbH0gID0gdGhpcy5zdG9yZSxcbiAgICAgICAgICAgIGtleUZpZWxkID0gbW9kZWw/LmdldEZpZWxkKHRoaXMuZ2V0S2V5UHJvcGVydHkoKSksXG4gICAgICAgICAgICBrZXlUeXBlICA9IGtleUZpZWxkPy50eXBlPy50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIGlmIChrZXlUeXBlID09PSAnaW50JyB8fCBrZXlUeXBlID09PSAnaW50ZWdlcicpIHtcbiAgICAgICAgICAgIGl0ZW1JZCA9IHBhcnNlSW50KGl0ZW1JZClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpdGVtSWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdXBwb3J0IGNvbGxlY3Rpb25zICYgc3RvcmVzXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRLZXlQcm9wZXJ0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmUua2V5UHJvcGVydHkgfHwgdGhpcy5zdG9yZS5tb2RlbC5rZXlQcm9wZXJ0eVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25DbGljayhkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtO1xuXG4gICAgICAgIGlmIChkYXRhLnBhdGhbMF0uaWQgPT09IG1lLmlkKSB7XG4gICAgICAgICAgICBtZS5vbkNvbnRhaW5lckNsaWNrKGRhdGEpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGl0ZW0gb2YgZGF0YS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uY2xzLmluY2x1ZGVzKG1lLml0ZW1DbHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLm9uSXRlbUNsaWNrKGl0ZW0sIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25Db25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgc3VwZXIub25Db25zdHJ1Y3RlZCgpO1xuXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZWw/LnJlZ2lzdGVyKHRoaXMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkNvbnRhaW5lckNsaWNrKGRhdGEpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjb250YWluZXJDbGljayBldmVudCBmaXJlcyB3aGVuIGEgY2xpY2sgb2NjdXJzIG9uIHRoZSBjb21wb25lbnQsIGJ1dCBub3Qgb24gYSBsaXN0IGl0ZW1cbiAgICAgICAgICogQGV2ZW50IGNvbnRhaW5lckNsaWNrXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nW119IGNscyB0aGUgY2xhc3NMaXN0IG9mIHRoZSB0YXJnZXQgbm9kZSAoY29udmVydGVkIHRvIGFuIGFycmF5KVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgdGhlIHRhcmdldCBkb20gaWRcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmdbXX0gcGF0aCB0aGUgZXZlbnQgcGF0aFxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maXJlKCdjb250YWluZXJDbGljaycsIGRhdGEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uSXRlbUNsaWNrKG5vZGUsIGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICByZWNvcmQgPSBtZS5zdG9yZS5nZXQobWUuZ2V0SXRlbVJlY29yZElkKG5vZGUuaWQpKTtcblxuICAgICAgICAvLyBwYXNzIHRoZSByZWNvcmQgdG8gY2xhc3MgZXh0ZW5zaW9uc1xuICAgICAgICBkYXRhLnJlY29yZCA9IHJlY29yZDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGl0ZW1DbGljayBldmVudCBmaXJlcyB3aGVuIGEgY2xpY2sgb2NjdXJzIG9uIGEgbGlzdCBpdGVtXG4gICAgICAgICAqIEBldmVudCBpdGVtQ2xpY2tcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGlkIHRoZSByZWNvcmQgbWF0Y2hpbmcgdGhlIGxpc3QgaXRlbVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgbWUuZmlyZSgnaXRlbUNsaWNrJywge1xuICAgICAgICAgICAgcmVjb3JkXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvblN0b3JlRmlsdGVyKCkge1xuICAgICAgICB0aGlzLmNyZWF0ZUl0ZW1zKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uU3RvcmVMb2FkKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUubW91bnRlZCAmJiBtZS5yZW5kZXJpbmcpIHtcbiAgICAgICAgICAgIG1lLm9uKCdtb3VudGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1lLmNyZWF0ZUl0ZW1zKClcbiAgICAgICAgICAgIH0sIG1lLCB7b25jZTogdHJ1ZX0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUuY3JlYXRlSXRlbXMoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLmZpZWxkcyBFYWNoIGZpZWxkIG9iamVjdCBjb250YWlucyB0aGUga2V5czogbmFtZSwgb2xkVmFsdWUsIHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEuaW5kZXhcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLk1vZGVsfSBkYXRhLm1vZGVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEucmVjb3JkXG4gICAgICovXG4gICAgb25TdG9yZVJlY29yZENoYW5nZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtpbmRleH0gPSBkYXRhO1xuXG4gICAgICAgIC8vIGlnbm9yZSBjaGFuZ2VzIGZvciByZWNvcmRzIHdoaWNoIGhhdmUgbm90IGJlZW4gYWRkZWQgdG8gdGhlIGxpc3QgeWV0XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICBtZS52ZG9tLmNuW2luZGV4XSA9IG1lLmNyZWF0ZUl0ZW0oZGF0YS5yZWNvcmQsIGluZGV4KTtcbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGEuaXRlbXNcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLnByZXZpb3VzSXRlbXNcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLlN0b3JlfSBkYXRhLnNjb3BlXG4gICAgICovXG4gICAgb25TdG9yZVNvcnQoZGF0YSkge1xuICAgICAgICB0aGlzLmNyZWF0ZUl0ZW1zKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gaXRlbVxuICAgICAqL1xuICAgIHNlbGVjdEl0ZW0oaXRlbSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUuZGlzYWJsZVNlbGVjdGlvbikge1xuICAgICAgICAgICAgLy8gU2VsZWN0aW5nIGluZGV4XG4gICAgICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgbWUuc2VsZWN0aW9uTW9kZWw/LnNlbGVjdEF0KGl0ZW0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZWxlY3RpbmcgcmVjb3JkXG4gICAgICAgICAgICBlbHNlIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgbWUuc2VsZWN0aW9uTW9kZWw/LnNlbGVjdEF0KG1lLnN0b3JlLmluZGV4T2YoaXRlbSkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVJdGVtRm9jdXModmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7bmF2aWdhdGVUb30gPSBOZW8ubWFpbi5hZGRvbi5OYXZpZ2F0b3I7XG5cbiAgICAgICAgaWYgKG1lLm1vdW50ZWQpIHtcbiAgICAgICAgICAgIGlmIChOZW8uaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgbmF2aWdhdGVUbyhbbWUuZ2V0SGVhZGVybGVzc0luZGV4KHZhbHVlKSwgbWUubmF2aWdhdG9yXSlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvKFttZS5nZXRJdGVtSWQodmFsdWVbbWUuZ2V0S2V5UHJvcGVydHkoKV0pLCBtZS5uYXZpZ2F0b3JdKVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUub24oJ21vdW50ZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gV2UgY291bGQgc3Vic2NyaWJlIG11bHRpcGxlIHRpbWVzIGJlZm9yZSBnZXR0aW5nIG1vdW50ZWQsXG4gICAgICAgICAgICAgICAgLy8gc28gb25seSB0cmlnZ2VyIHRoZSBjYWxsYmFjayBmb3IgdGhlIGxhc3QgZm9jdXNJbmRleFxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbWUuZm9jdXNJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBtZS51cGRhdGVJdGVtRm9jdXMobWUuZm9jdXNJbmRleClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBtZSwge29uY2U6IHRydWV9KVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhMaXN0KTtcbiIsImltcG9ydCBNb2RlbCBmcm9tICcuL01vZGVsLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5zZWxlY3Rpb24uTGlzdE1vZGVsXG4gKiBAZXh0ZW5kcyBOZW8uc2VsZWN0aW9uLk1vZGVsXG4gKi9cbmNsYXNzIExpc3RNb2RlbCBleHRlbmRzIE1vZGVsIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5zZWxlY3Rpb24uTGlzdE1vZGVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uc2VsZWN0aW9uLkxpc3RNb2RlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdzZWxlY3Rpb24tbGlzdG1vZGVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3NlbGVjdGlvbi1saXN0bW9kZWwnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGxhY2Vob2xkZXIgbWV0aG9kIHRvIGdldCBvdmVycmlkZGVuIGJ5IGNsYXNzIGV4dGVuc2lvbiBsaXN0IG1lbnUuTGlzdE1vZGVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbktleURvd25Fc2NhcGUoZGF0YSkge31cblxuICAgIC8qKlxuICAgICAqIFBsYWNlaG9sZGVyIG1ldGhvZCB0byBnZXQgb3ZlcnJpZGRlbiBieSBjbGFzcyBleHRlbnNpb24gbGlzdCBtZW51Lkxpc3RNb2RlbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25LZXlEb3duRG93bihkYXRhKSB7fVxuXG4gICAgLyoqXG4gICAgICogUGxhY2Vob2xkZXIgbWV0aG9kIHRvIGdldCBvdmVycmlkZGVuIGJ5IGNsYXNzIGV4dGVuc2lvbiBsaXN0IG1lbnUuTGlzdE1vZGVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbktleURvd25FbnRlcihkYXRhKSB7fVxuXG4gICAgLyoqXG4gICAgICogUGxhY2Vob2xkZXIgbWV0aG9kIHRvIGdldCBvdmVycmlkZGVuIGJ5IGNsYXNzIGV4dGVuc2lvbiBsaXN0IG1lbnUuTGlzdE1vZGVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbktleURvd25MZWZ0KGRhdGEpIHt9XG5cbiAgICAvKipcbiAgICAgKiBQbGFjZWhvbGRlciBtZXRob2QgdG8gZ2V0IG92ZXJyaWRkZW4gYnkgY2xhc3MgZXh0ZW5zaW9uIGxpc3QgbWVudS5MaXN0TW9kZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uS2V5RG93blJpZ2h0KGRhdGEpIHt9XG5cbiAgICAvKipcbiAgICAgKiBQbGFjZWhvbGRlciBtZXRob2QgdG8gZ2V0IG92ZXJyaWRkZW4gYnkgY2xhc3MgZXh0ZW5zaW9uIGxpc3QgbWVudS5MaXN0TW9kZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uS2V5RG93blVwKGRhdGEpIHt9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uTGlzdENsaWNrKHsgY3VycmVudFRhcmdldCB9KSB7XG4gICAgICAgIGxldCB7dmlld30gPSB0aGlzLFxuICAgICAgICAgICAgcmVjb3JkO1xuXG4gICAgICAgIGlmICghdmlldy5kaXNhYmxlU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICByZWNvcmQgPSB2aWV3LnN0b3JlLmdldCh2aWV3LmdldEl0ZW1SZWNvcmRJZChjdXJyZW50VGFyZ2V0KSk7XG5cbiAgICAgICAgICAgIHJlY29yZCAmJiB0aGlzLnNlbGVjdChyZWNvcmQpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uTGlzdE5hdmlnYXRlKGRhdGEpIHtcbiAgICAgICAgbGV0IHt2aWV3fSAgPSB0aGlzLFxuICAgICAgICAgICAge3N0b3JlfSA9IHZpZXc7XG5cbiAgICAgICAgZGF0YS5yZWNvcmQgICAgICA9IHN0b3JlLmdldEF0KE1hdGgubWluKGRhdGEuYWN0aXZlSW5kZXgsIHN0b3JlLmdldENvdW50KCkpKTtcbiAgICAgICAgdmlldy5fZm9jdXNJbmRleCA9IHN0b3JlLmluZGV4T2YoZGF0YS5yZWNvcmQpOyAvLyBzaWxlbnQgdXBkYXRlLCBubyBuZWVkIHRvIHJlZm9jdXNcblxuICAgICAgICB2aWV3LmZpcmUoJ2l0ZW1OYXZpZ2F0ZScsIGRhdGEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudFxuICAgICAqL1xuICAgIHJlZ2lzdGVyKGNvbXBvbmVudCkge1xuICAgICAgICBzdXBlci5yZWdpc3Rlcihjb21wb25lbnQpO1xuXG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtpZCwgdmlld30gPSBtZTtcblxuICAgICAgICB2aWV3LmFkZERvbUxpc3RlbmVycyhbe1xuICAgICAgICAgICAgY2xpY2s6IG1lLm9uTGlzdENsaWNrLFxuICAgICAgICAgICAgc2NvcGU6IG1lLFxuXG4gICAgICAgICAgICAvLyBTaG91bGQgYmUgYC4ke3ZpZXcuaXRlbUNsc306bm90KC5uZW8tZGlzYWJsZWQsLm5lby1saXN0LWhlYWRlcilgXG4gICAgICAgICAgICAvLyBUT0RPIHBhcnNlIGRlbGVnYXRlIHNlbGVjdG9yc1xuICAgICAgICAgICAgZGVsZWdhdGU6IHBhdGggPT4ge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCB7IGxlbmd0aCB9ID0gcGF0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgY2xzIH0gPSBwYXRoW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbHMuaW5jbHVkZXModmlldy5pdGVtQ2xzKSAmJiAhY2xzLmluY2x1ZGVzKCduZW8tZGlzYWJsZWQnKSAmJiAhY2xzLmluY2x1ZGVzKCduZW8tbGlzdC1oZWFkZXInKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5lb25hdmlnYXRlIDogbWUub25MaXN0TmF2aWdhdGUsXG4gICAgICAgICAgICBzY29wZSAgICAgICA6IG1lXG4gICAgICAgIH1dKTtcblxuICAgICAgICB2aWV3LmtleXM/Ll9rZXlzLnB1c2goXG4gICAgICAgICAgICB7Zm46ICdvbktleURvd25Eb3duJyAgICxrZXk6ICdEb3duJyAgICxzY29wZTogaWR9LFxuICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duRW50ZXInICAsa2V5OiAnRW50ZXInICAsc2NvcGU6IGlkfSxcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93bkVzY2FwZScgLGtleTogJ0VzY2FwZScgLHNjb3BlOiBpZH0sXG4gICAgICAgICAgICB7Zm46ICdvbktleURvd25MZWZ0JyAgICxrZXk6ICdMZWZ0JyAgICxzY29wZTogaWR9LFxuICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duUmlnaHQnICAsa2V5OiAnUmlnaHQnICAsc2NvcGU6IGlkfSxcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93blVwJyAgICAgLGtleTogJ1VwJyAgICAgLHNjb3BlOiBpZH1cbiAgICAgICAgKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqL1xuICAgIHNlbGVjdEF0KGluZGV4KSB7XG4gICAgICAgIGxldCB7dmlld30gICAgPSB0aGlzLFxuICAgICAgICAgICAgcmVjb3JkS2V5ID0gdmlldz8uc3RvcmUuZ2V0S2V5QXQoaW5kZXgpLFxuICAgICAgICAgICAgaXRlbUlkICAgID0gcmVjb3JkS2V5ICYmIHZpZXcuZ2V0SXRlbUlkKHJlY29yZEtleSk7XG5cbiAgICAgICAgaXRlbUlkICYmIHRoaXMuc2VsZWN0KGl0ZW1JZClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHVucmVnaXN0ZXIoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtpZCwgdmlld30gPSBtZTtcblxuICAgICAgICB2aWV3LmtleXM/LnJlbW92ZUtleXMoW1xuICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duRG93bicgICAsa2V5OiAnRG93bicgICAsc2NvcGU6IGlkfSxcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93bkVudGVyJyAgLGtleTogJ0VudGVyJyAgLHNjb3BlOiBpZH0sXG4gICAgICAgICAgICB7Zm46ICdvbktleURvd25Fc2NhcGUnICxrZXk6ICdFc2NhcGUnICxzY29wZTogaWR9LFxuICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duTGVmdCcgICAsa2V5OiAnTGVmdCcgICAsc2NvcGU6IGlkfSxcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93blJpZ2h0JyAgLGtleTogJ1JpZ2h0JyAgLHNjb3BlOiBpZH0sXG4gICAgICAgICAgICB7Zm46ICdvbktleURvd25VcCcgICAgICxrZXk6ICdVcCcgICAgICxzY29wZTogaWR9XG4gICAgICAgIF0pO1xuXG4gICAgICAgIHN1cGVyLnVucmVnaXN0ZXIoKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoTGlzdE1vZGVsKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==