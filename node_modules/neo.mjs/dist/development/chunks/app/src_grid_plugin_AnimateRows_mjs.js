"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["src_grid_plugin_AnimateRows_mjs"],{

/***/ "./src/grid/plugin/AnimateRows.mjs"
/*!*****************************************!*\
  !*** ./src/grid/plugin/AnimateRows.mjs ***!
  \*****************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _plugin_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../plugin/Base.mjs */ "./src/plugin/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @class Neo.grid.plugin.AnimateRows
 * @extends Neo.plugin.Base
 */
class AnimateRows extends _plugin_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for transitionEasing
     * @member {String[]} transitionEasings=['ease','ease-in','ease-out','ease-in-out','linear']
     * @protected
     * @static
     */
    static transitionEasings = ['ease', 'ease-in', 'ease-out', 'ease-in-out', 'linear']

    static config = {
        /**
         * @member {String} className='Neo.grid.plugin.AnimateRows'
         * @protected
         */
        className: 'Neo.grid.plugin.AnimateRows',
        /**
         * @member {String} ntype='plugin-grid-animate-rows'
         * @protected
         */
        ntype: 'plugin-grid-animate-rows',
        /**
         * Time in ms for the background-color, opacity & transform transitions
         * @member {Number} transitionDuration_=500
         * @reactive
         */
        transitionDuration_: 500,
        /**
         * The easing used for fadeIn, fadeOut and position changes.
         * Valid values: 'ease','ease-in','ease-out','ease-in-out','linear'
         * @member {String} transitionEasing_='ease-out'
         * @reactive
         */
        transitionEasing_: 'ease-out'
    }

    /**
     * The id of the setTimeout() call which gets triggered after a transition is done.
     * @member {Number|null} transitionTimeoutId=null
     * @protected
     */
    transitionTimeoutId = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me      = this,
            {owner} = me,
            {store} = owner;

        // Remove the previous view listeners
        owner.store = null;

        owner.onStoreFilter = me.onStoreFilter.bind(me);
        owner.onStoreLoad   = me.onStoreLoad  .bind(me);

        // Add the re-bound listeners
        owner.store = store;

        owner.addCls('neo-animate-rows')
    }

    /**
     * Triggered after the transitionDuration config got changed.
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetTransitionDuration(value, oldValue) {
        this.owner.addStyle({'--neo-duration': value + 'ms'})
    }

    /**
     * Triggered after the transitionEasing config got changed.
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetTransitionEasing(value, oldValue) {
        this.owner.addStyle({'--neo-easing': value})
    }

    /**
     * Triggered before the transitionEasing config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetTransitionEasing(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'transitionEasing')
    }

    /**
     * @param {Object} args
     */
    destroy(...args) {
        this.owner.addStyle({
            '--neo-duration': null,
            '--neo-easing'  : null
        });

        super.destroy(...args)
    }

    /**
     * @param {Object} data
     * @param {Boolean} data.isFiltered
     * @param {Object[]} data.items
     * @param {Object[]} data.oldItems
     * @param {Neo.data.Store} data.scope
     */
    onStoreFilter(data) {
        this.updateView()
    }

    /**
     * @param {Object[]} data
     * @protected
     */
    onStoreLoad(data) {
        this.updateView()
    }

    /**
     *
     */
    updateView() {
        let me            = this,
            {owner}       = me,
            {mountedRows} = owner,
            addedRows     = [],
            hasChange     = false,
            map           = {},
            rowsContainer = owner.getVdomRoot().cn,
            id, mapItem, record, row, rowIndex, transform;

        rowsContainer.forEach(row => {
            map[row.id] = row
        });

        // Creates the new start & end indexes inside mountedRows
        owner.updateMountedAndVisibleRows();

        for (rowIndex=mountedRows[0]; rowIndex < mountedRows[1]; rowIndex++) {
            record  = owner.store.getAt(rowIndex);
            id      = owner.getRowId(rowIndex)
            mapItem = map[id];

            if (mapItem) {
                // Inside the map (previous state) & vdom => move OP
                transform = `translate(0px, ${rowIndex * owner.rowHeight}px)`;

                if (mapItem.style.transform !== transform) {
                    mapItem.style.opacity   = .9; // slightly less than 1 to see visual overlays while moving
                    mapItem.style.transform = transform;
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].toggle(mapItem.cls, 'neo-even', rowIndex % 2 !== 0);
                    hasChange = true
                }

                delete map[id]
            } else {
                // Inside the vdom, but not the map => insert OP
                row = owner.createRow({record, rowIndex});

                row.style.opacity = 0;

                addedRows    .push(row);
                rowsContainer.push(row);

                owner.updateDepth = -1; // Added rows might contain components
                hasChange = true
            }
        }

        // Only rows which need to get removed are still inside the map
        Object.values(map).forEach(row => {
            row.style.opacity = 0;
            hasChange = true
        });

        if (hasChange) {
            clearTimeout(me.transitionTimeoutId);

            owner.promiseUpdate().then(() => {
                if (addedRows.length > 0) {
                    // Added rows need a 2nd DOM update to change the opacity from 0 to 1.
                    // If we added them with 1 directly, there would not be a fade-in transition.
                    addedRows.forEach(row => {
                        row.style.opacity = 1
                    });

                    owner.update()
                }
            });

            me.transitionTimeoutId = setTimeout(() => {
                me.transitionTimeoutId = null;
                owner.createViewData()
            }, me.transitionDuration)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(AnimateRows));


/***/ },

/***/ "./src/plugin/Base.mjs"
/*!*****************************!*\
  !*** ./src/plugin/Base.mjs ***!
  \*****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * Abstract base class for plugin implementations.
 * Plugins are intended to get put into the plugins config of component.Base
 * to enhance them or add additional features
 * @class Neo.plugin.Base
 * @extends Neo.core.Base
 */
class Plugin extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.plugin.Base'
         * @protected
         */
        className: 'Neo.plugin.Base',
        /**
         * All plugin ntypes need to start with 'plugin-' to ensure that component.Base: getPlugin() can find them
         * @member {String} ntype='plugin'
         * @protected
         */
        ntype: 'plugin',
        /**
         * @member {Neo.component.Base} owner=null
         * @protected
         */
        owner: null,
        /**
         * @member {Number|null} windowId_=null
         * @reactive
         */
        windowId_: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me      = this,
            {owner} = me;

        if (owner.isConstructed) {
            me.onOwnerConstructed()
        } else {
            owner.on('constructed', () => {
                me.onOwnerConstructed()
            }, me, {once: true})
        }

        if (owner.mounted) {
            me.onOwnerMounted();
        } else {
            owner.on('mounted', me.onOwnerMounted, me);
        }
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        value && Neo.currentWorker.insertThemeFiles(value, this.__proto__)
    }

    /**
     * Override this method to apply changes to the owner Component when it is constructed
     */
    onOwnerConstructed() {
        let {owner} = this;

        if (owner.windowId) {
            this.windowId = owner.windowId
        }
    }

    /**
     * Override this method to apply changes to the owner Component when it does get mounted
     */
    onOwnerMounted() {

    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Plugin));


/***/ }

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC9zcmNfZ3JpZF9wbHVnaW5fQW5pbWF0ZVJvd3NfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUE2QztBQUNEOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3REFBSTtBQUM5QjtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTzs7QUFFcEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsK0JBQStCO0FBQzVEOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixzQkFBc0I7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUEsc0NBQXNDLDJCQUEyQjtBQUNqRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhDQUE4QywyQkFBMkI7O0FBRXpFO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0Esb0JBQW9CLHVEQUFRO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQSx1Q0FBdUMsaUJBQWlCOztBQUV4RDs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBLGlFQUFlLDJCQUEyQixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDcE5QOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzREFBSTtBQUN6QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTzs7QUFFcEI7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsYUFBYSxPQUFPLFdBQVc7QUFDL0I7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTzs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpRUFBZSxzQkFBc0IsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvZ3JpZC9wbHVnaW4vQW5pbWF0ZVJvd3MubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvcGx1Z2luL0Jhc2UubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCYXNlICAgICBmcm9tICcuLi8uLi9wbHVnaW4vQmFzZS5tanMnO1xuaW1wb3J0IE5lb0FycmF5IGZyb20gJy4uLy4uL3V0aWwvQXJyYXkubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmdyaWQucGx1Z2luLkFuaW1hdGVSb3dzXG4gKiBAZXh0ZW5kcyBOZW8ucGx1Z2luLkJhc2VcbiAqL1xuY2xhc3MgQW5pbWF0ZVJvd3MgZXh0ZW5kcyBCYXNlIHtcbiAgICAvKipcbiAgICAgKiBWYWxpZCB2YWx1ZXMgZm9yIHRyYW5zaXRpb25FYXNpbmdcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gdHJhbnNpdGlvbkVhc2luZ3M9WydlYXNlJywnZWFzZS1pbicsJ2Vhc2Utb3V0JywnZWFzZS1pbi1vdXQnLCdsaW5lYXInXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIHRyYW5zaXRpb25FYXNpbmdzID0gWydlYXNlJywgJ2Vhc2UtaW4nLCAnZWFzZS1vdXQnLCAnZWFzZS1pbi1vdXQnLCAnbGluZWFyJ11cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmdyaWQucGx1Z2luLkFuaW1hdGVSb3dzJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZ3JpZC5wbHVnaW4uQW5pbWF0ZVJvd3MnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ncGx1Z2luLWdyaWQtYW5pbWF0ZS1yb3dzJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3BsdWdpbi1ncmlkLWFuaW1hdGUtcm93cycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaW1lIGluIG1zIGZvciB0aGUgYmFja2dyb3VuZC1jb2xvciwgb3BhY2l0eSAmIHRyYW5zZm9ybSB0cmFuc2l0aW9uc1xuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHRyYW5zaXRpb25EdXJhdGlvbl89NTAwXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uXzogNTAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGVhc2luZyB1c2VkIGZvciBmYWRlSW4sIGZhZGVPdXQgYW5kIHBvc2l0aW9uIGNoYW5nZXMuXG4gICAgICAgICAqIFZhbGlkIHZhbHVlczogJ2Vhc2UnLCdlYXNlLWluJywnZWFzZS1vdXQnLCdlYXNlLWluLW91dCcsJ2xpbmVhcidcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB0cmFuc2l0aW9uRWFzaW5nXz0nZWFzZS1vdXQnXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdHJhbnNpdGlvbkVhc2luZ186ICdlYXNlLW91dCdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaWQgb2YgdGhlIHNldFRpbWVvdXQoKSBjYWxsIHdoaWNoIGdldHMgdHJpZ2dlcmVkIGFmdGVyIGEgdHJhbnNpdGlvbiBpcyBkb25lLlxuICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSB0cmFuc2l0aW9uVGltZW91dElkPW51bGxcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdHJhbnNpdGlvblRpbWVvdXRJZCA9IG51bGxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtvd25lcn0gPSBtZSxcbiAgICAgICAgICAgIHtzdG9yZX0gPSBvd25lcjtcblxuICAgICAgICAvLyBSZW1vdmUgdGhlIHByZXZpb3VzIHZpZXcgbGlzdGVuZXJzXG4gICAgICAgIG93bmVyLnN0b3JlID0gbnVsbDtcblxuICAgICAgICBvd25lci5vblN0b3JlRmlsdGVyID0gbWUub25TdG9yZUZpbHRlci5iaW5kKG1lKTtcbiAgICAgICAgb3duZXIub25TdG9yZUxvYWQgICA9IG1lLm9uU3RvcmVMb2FkICAuYmluZChtZSk7XG5cbiAgICAgICAgLy8gQWRkIHRoZSByZS1ib3VuZCBsaXN0ZW5lcnNcbiAgICAgICAgb3duZXIuc3RvcmUgPSBzdG9yZTtcblxuICAgICAgICBvd25lci5hZGRDbHMoJ25lby1hbmltYXRlLXJvd3MnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdHJhbnNpdGlvbkR1cmF0aW9uIGNvbmZpZyBnb3QgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRUcmFuc2l0aW9uRHVyYXRpb24odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMub3duZXIuYWRkU3R5bGUoeyctLW5lby1kdXJhdGlvbic6IHZhbHVlICsgJ21zJ30pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB0cmFuc2l0aW9uRWFzaW5nIGNvbmZpZyBnb3QgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRUcmFuc2l0aW9uRWFzaW5nKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLm93bmVyLmFkZFN0eWxlKHsnLS1uZW8tZWFzaW5nJzogdmFsdWV9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHRyYW5zaXRpb25FYXNpbmcgY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRUcmFuc2l0aW9uRWFzaW5nKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAndHJhbnNpdGlvbkVhc2luZycpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcbiAgICAgKi9cbiAgICBkZXN0cm95KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5vd25lci5hZGRTdHlsZSh7XG4gICAgICAgICAgICAnLS1uZW8tZHVyYXRpb24nOiBudWxsLFxuICAgICAgICAgICAgJy0tbmVvLWVhc2luZycgIDogbnVsbFxuICAgICAgICB9KTtcblxuICAgICAgICBzdXBlci5kZXN0cm95KC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRhdGEuaXNGaWx0ZXJlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGEuaXRlbXNcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLm9sZEl0ZW1zXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5TdG9yZX0gZGF0YS5zY29wZVxuICAgICAqL1xuICAgIG9uU3RvcmVGaWx0ZXIoZGF0YSkge1xuICAgICAgICB0aGlzLnVwZGF0ZVZpZXcoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGFcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25TdG9yZUxvYWQoZGF0YSkge1xuICAgICAgICB0aGlzLnVwZGF0ZVZpZXcoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgdXBkYXRlVmlldygpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge293bmVyfSAgICAgICA9IG1lLFxuICAgICAgICAgICAge21vdW50ZWRSb3dzfSA9IG93bmVyLFxuICAgICAgICAgICAgYWRkZWRSb3dzICAgICA9IFtdLFxuICAgICAgICAgICAgaGFzQ2hhbmdlICAgICA9IGZhbHNlLFxuICAgICAgICAgICAgbWFwICAgICAgICAgICA9IHt9LFxuICAgICAgICAgICAgcm93c0NvbnRhaW5lciA9IG93bmVyLmdldFZkb21Sb290KCkuY24sXG4gICAgICAgICAgICBpZCwgbWFwSXRlbSwgcmVjb3JkLCByb3csIHJvd0luZGV4LCB0cmFuc2Zvcm07XG5cbiAgICAgICAgcm93c0NvbnRhaW5lci5mb3JFYWNoKHJvdyA9PiB7XG4gICAgICAgICAgICBtYXBbcm93LmlkXSA9IHJvd1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDcmVhdGVzIHRoZSBuZXcgc3RhcnQgJiBlbmQgaW5kZXhlcyBpbnNpZGUgbW91bnRlZFJvd3NcbiAgICAgICAgb3duZXIudXBkYXRlTW91bnRlZEFuZFZpc2libGVSb3dzKCk7XG5cbiAgICAgICAgZm9yIChyb3dJbmRleD1tb3VudGVkUm93c1swXTsgcm93SW5kZXggPCBtb3VudGVkUm93c1sxXTsgcm93SW5kZXgrKykge1xuICAgICAgICAgICAgcmVjb3JkICA9IG93bmVyLnN0b3JlLmdldEF0KHJvd0luZGV4KTtcbiAgICAgICAgICAgIGlkICAgICAgPSBvd25lci5nZXRSb3dJZChyb3dJbmRleClcbiAgICAgICAgICAgIG1hcEl0ZW0gPSBtYXBbaWRdO1xuXG4gICAgICAgICAgICBpZiAobWFwSXRlbSkge1xuICAgICAgICAgICAgICAgIC8vIEluc2lkZSB0aGUgbWFwIChwcmV2aW91cyBzdGF0ZSkgJiB2ZG9tID0+IG1vdmUgT1BcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKDBweCwgJHtyb3dJbmRleCAqIG93bmVyLnJvd0hlaWdodH1weClgO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1hcEl0ZW0uc3R5bGUudHJhbnNmb3JtICE9PSB0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwSXRlbS5zdHlsZS5vcGFjaXR5ICAgPSAuOTsgLy8gc2xpZ2h0bHkgbGVzcyB0aGFuIDEgdG8gc2VlIHZpc3VhbCBvdmVybGF5cyB3aGlsZSBtb3ZpbmdcbiAgICAgICAgICAgICAgICAgICAgbWFwSXRlbS5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgICAgIE5lb0FycmF5LnRvZ2dsZShtYXBJdGVtLmNscywgJ25lby1ldmVuJywgcm93SW5kZXggJSAyICE9PSAwKTtcbiAgICAgICAgICAgICAgICAgICAgaGFzQ2hhbmdlID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRlbGV0ZSBtYXBbaWRdXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEluc2lkZSB0aGUgdmRvbSwgYnV0IG5vdCB0aGUgbWFwID0+IGluc2VydCBPUFxuICAgICAgICAgICAgICAgIHJvdyA9IG93bmVyLmNyZWF0ZVJvdyh7cmVjb3JkLCByb3dJbmRleH0pO1xuXG4gICAgICAgICAgICAgICAgcm93LnN0eWxlLm9wYWNpdHkgPSAwO1xuXG4gICAgICAgICAgICAgICAgYWRkZWRSb3dzICAgIC5wdXNoKHJvdyk7XG4gICAgICAgICAgICAgICAgcm93c0NvbnRhaW5lci5wdXNoKHJvdyk7XG5cbiAgICAgICAgICAgICAgICBvd25lci51cGRhdGVEZXB0aCA9IC0xOyAvLyBBZGRlZCByb3dzIG1pZ2h0IGNvbnRhaW4gY29tcG9uZW50c1xuICAgICAgICAgICAgICAgIGhhc0NoYW5nZSA9IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9ubHkgcm93cyB3aGljaCBuZWVkIHRvIGdldCByZW1vdmVkIGFyZSBzdGlsbCBpbnNpZGUgdGhlIG1hcFxuICAgICAgICBPYmplY3QudmFsdWVzKG1hcCkuZm9yRWFjaChyb3cgPT4ge1xuICAgICAgICAgICAgcm93LnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICAgICAgaGFzQ2hhbmdlID0gdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoaGFzQ2hhbmdlKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQobWUudHJhbnNpdGlvblRpbWVvdXRJZCk7XG5cbiAgICAgICAgICAgIG93bmVyLnByb21pc2VVcGRhdGUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYWRkZWRSb3dzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkZWQgcm93cyBuZWVkIGEgMm5kIERPTSB1cGRhdGUgdG8gY2hhbmdlIHRoZSBvcGFjaXR5IGZyb20gMCB0byAxLlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhZGRlZCB0aGVtIHdpdGggMSBkaXJlY3RseSwgdGhlcmUgd291bGQgbm90IGJlIGEgZmFkZS1pbiB0cmFuc2l0aW9uLlxuICAgICAgICAgICAgICAgICAgICBhZGRlZFJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93LnN0eWxlLm9wYWNpdHkgPSAxXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIG93bmVyLnVwZGF0ZSgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLnRyYW5zaXRpb25UaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBtZS50cmFuc2l0aW9uVGltZW91dElkID0gbnVsbDtcbiAgICAgICAgICAgICAgICBvd25lci5jcmVhdGVWaWV3RGF0YSgpXG4gICAgICAgICAgICB9LCBtZS50cmFuc2l0aW9uRHVyYXRpb24pXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEFuaW1hdGVSb3dzKTtcbiIsImltcG9ydCBCYXNlIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuXG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIHBsdWdpbiBpbXBsZW1lbnRhdGlvbnMuXG4gKiBQbHVnaW5zIGFyZSBpbnRlbmRlZCB0byBnZXQgcHV0IGludG8gdGhlIHBsdWdpbnMgY29uZmlnIG9mIGNvbXBvbmVudC5CYXNlXG4gKiB0byBlbmhhbmNlIHRoZW0gb3IgYWRkIGFkZGl0aW9uYWwgZmVhdHVyZXNcbiAqIEBjbGFzcyBOZW8ucGx1Z2luLkJhc2VcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgUGx1Z2luIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ucGx1Z2luLkJhc2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5wbHVnaW4uQmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGwgcGx1Z2luIG50eXBlcyBuZWVkIHRvIHN0YXJ0IHdpdGggJ3BsdWdpbi0nIHRvIGVuc3VyZSB0aGF0IGNvbXBvbmVudC5CYXNlOiBnZXRQbHVnaW4oKSBjYW4gZmluZCB0aGVtXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3BsdWdpbidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdwbHVnaW4nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbXBvbmVudC5CYXNlfSBvd25lcj1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG93bmVyOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IHdpbmRvd0lkXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgd2luZG93SWRfOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge293bmVyfSA9IG1lO1xuXG4gICAgICAgIGlmIChvd25lci5pc0NvbnN0cnVjdGVkKSB7XG4gICAgICAgICAgICBtZS5vbk93bmVyQ29uc3RydWN0ZWQoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3duZXIub24oJ2NvbnN0cnVjdGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1lLm9uT3duZXJDb25zdHJ1Y3RlZCgpXG4gICAgICAgICAgICB9LCBtZSwge29uY2U6IHRydWV9KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG93bmVyLm1vdW50ZWQpIHtcbiAgICAgICAgICAgIG1lLm9uT3duZXJNb3VudGVkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvd25lci5vbignbW91bnRlZCcsIG1lLm9uT3duZXJNb3VudGVkLCBtZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHdpbmRvd0lkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRXaW5kb3dJZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdmFsdWUgJiYgTmVvLmN1cnJlbnRXb3JrZXIuaW5zZXJ0VGhlbWVGaWxlcyh2YWx1ZSwgdGhpcy5fX3Byb3RvX18pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gYXBwbHkgY2hhbmdlcyB0byB0aGUgb3duZXIgQ29tcG9uZW50IHdoZW4gaXQgaXMgY29uc3RydWN0ZWRcbiAgICAgKi9cbiAgICBvbk93bmVyQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIGxldCB7b3duZXJ9ID0gdGhpcztcblxuICAgICAgICBpZiAob3duZXIud2luZG93SWQpIHtcbiAgICAgICAgICAgIHRoaXMud2luZG93SWQgPSBvd25lci53aW5kb3dJZFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gYXBwbHkgY2hhbmdlcyB0byB0aGUgb3duZXIgQ29tcG9uZW50IHdoZW4gaXQgZG9lcyBnZXQgbW91bnRlZFxuICAgICAqL1xuICAgIG9uT3duZXJNb3VudGVkKCkge1xuXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhQbHVnaW4pO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==