"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["src_grid_plugin_AnimateRows_mjs"],{

/***/ "./src/grid/plugin/AnimateRows.mjs":
/*!*****************************************!*\
  !*** ./src/grid/plugin/AnimateRows.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _plugin_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../plugin/Base.mjs */ "./src/plugin/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @class Neo.grid.plugin.AnimateRows
 * @extends Neo.plugin.Base
 */
class AnimateRows extends _plugin_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for transitionEasing
     * @member {String[]} transitionEasings=['ease','ease-in','ease-out','ease-in-out','linear']
     * @protected
     * @static
     */
    static transitionEasings = ['ease', 'ease-in', 'ease-out', 'ease-in-out', 'linear']

    static config = {
        /**
         * @member {String} className='Neo.grid.plugin.AnimateRows'
         * @protected
         */
        className: 'Neo.grid.plugin.AnimateRows',
        /**
         * @member {String} ntype='plugin-grid-animate-rows'
         * @protected
         */
        ntype: 'plugin-grid-animate-rows',
        /**
         * Time in ms for the background-color, opacity & transform transitions
         * @member {Number} transitionDuration_=500
         */
        transitionDuration_: 500,
        /**
         * The easing used for fadeIn, fadeOut and position changes.
         * Valid values: 'ease','ease-in','ease-out','ease-in-out','linear'
         * @member {String} transitionEasing_='ease-out'
         */
        transitionEasing_: 'ease-out'
    }

    /**
     * The id of the setTimeout() call which gets triggered after a transition is done.
     * @member {Number|null} transitionTimeoutId=null
     * @protected
     */
    transitionTimeoutId = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me      = this,
            {owner} = me,
            {store} = owner;

        // Remove the previous view listeners
        owner.store = null;

        owner.onStoreFilter = me.onStoreFilter.bind(me);
        owner.onStoreLoad   = me.onStoreLoad  .bind(me);

        // Add the re-bound listeners
        owner.store = store;

        owner.addCls('neo-animate-rows')
    }

    /**
     * Triggered after the transitionDuration config got changed.
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetTransitionDuration(value, oldValue) {
        this.owner.addStyle({'--neo-duration': value + 'ms'})
    }

    /**
     * Triggered after the transitionEasing config got changed.
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetTransitionEasing(value, oldValue) {
        this.owner.addStyle({'--neo-easing': value})
    }

    /**
     * Triggered before the transitionEasing config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetTransitionEasing(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'transitionEasing')
    }

    /**
     * @param {Object} args
     */
    destroy(...args) {
        this.owner.addStyle({
            '--neo-duration': null,
            '--neo-easing'  : null
        });

        super.destroy(...args)
    }

    /**
     * @param {Object} data
     * @param {Boolean} data.isFiltered
     * @param {Object[]} data.items
     * @param {Object[]} data.oldItems
     * @param {Neo.data.Store} data.scope
     */
    onStoreFilter(data) {
        this.updateView()
    }

    /**
     * @param {Object[]} data
     * @protected
     */
    onStoreLoad(data) {
        this.updateView()
    }

    /**
     *
     */
    updateView() {
        let me            = this,
            {owner}       = me,
            {mountedRows} = owner,
            addedRows     = [],
            hasChange     = false,
            map           = {},
            rowsContainer = owner.getVdomRoot().cn,
            id, mapItem, record, row, rowIndex, transform;

        rowsContainer.forEach(row => {
            map[row.id] = row
        });

        // Creates the new start & end indexes inside mountedRows
        owner.updateMountedAndVisibleRows();

        for (rowIndex=mountedRows[0]; rowIndex < mountedRows[1]; rowIndex++) {
            record  = owner.store.getAt(rowIndex);
            id      = owner.getRowId(rowIndex)
            mapItem = map[id];

            if (mapItem) {
                // Inside the map (previous state) & vdom => move OP
                transform = `translate(0px, ${rowIndex * owner.rowHeight}px)`;

                if (mapItem.style.transform !== transform) {
                    mapItem.style.opacity   = .9; // slightly less than 1 to see visual overlays while moving
                    mapItem.style.transform = transform;
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].toggle(mapItem.cls, 'neo-even', rowIndex % 2 !== 0);
                    hasChange = true
                }

                delete map[id]
            } else {
                // Inside the vdom, but not the map => insert OP
                row = owner.createRow({record, rowIndex});

                row.style.opacity = 0;

                addedRows    .push(row);
                rowsContainer.push(row);

                owner.updateDepth = -1; // Added rows might contain components
                hasChange = true
            }
        }

        // Only rows which need to get removed are still inside the map
        Object.values(map).forEach(row => {
            row.style.opacity = 0;
            hasChange = true
        });

        if (hasChange) {
            clearTimeout(me.transitionTimeoutId);

            owner.promiseUpdate().then(() => {
                if (addedRows.length > 0) {
                    // Added rows need a 2nd DOM update to change the opacity from 0 to 1.
                    // If we added them with 1 directly, there would not be a fade-in transition.
                    addedRows.forEach(row => {
                        row.style.opacity = 1
                    });

                    owner.update()
                }
            });

            me.transitionTimeoutId = setTimeout(() => {
                me.transitionTimeoutId = null;
                owner.createViewData()
            }, me.transitionDuration)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(AnimateRows));


/***/ }),

/***/ "./src/plugin/Base.mjs":
/*!*****************************!*\
  !*** ./src/plugin/Base.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * Abstract base class for plugin implementations.
 * Plugins are intended to get put into the plugins config of component.Base
 * to enhance them or add additional features
 * @class Neo.plugin.Base
 * @extends Neo.core.Base
 */
class Plugin extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.plugin.Base'
         * @protected
         */
        className: 'Neo.plugin.Base',
        /**
         * All plugin ntypes need to start with 'plugin-' to ensure that component.Base: getPlugin() can find them
         * @member {String} ntype='plugin'
         * @protected
         */
        ntype: 'plugin',
        /**
         * @member {Neo.component.Base} owner=null
         * @protected
         */
        owner: null,
        /**
         * @member {Number|null} windowId_=null
         */
        windowId_: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me      = this,
            {owner} = me;

        if (owner.isConstructed) {
            me.onOwnerConstructed()
        } else {
            owner.on('constructed', () => {
                me.onOwnerConstructed()
            }, me, {once: true})
        }

        if (owner.mounted) {
            me.onOwnerMounted();
        } else {
            owner.on('mounted', me.onOwnerMounted, me);
        }
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        value && Neo.currentWorker.insertThemeFiles(value, this.__proto__)
    }

    /**
     * Override this method to apply changes to the owner Component when it is constructed
     */
    onOwnerConstructed() {
        let {owner} = this;

        if (owner.windowId) {
            this.windowId = owner.windowId
        }
    }

    /**
     * Override this method to apply changes to the owner Component when it does get mounted
     */
    onOwnerMounted() {

    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Plugin));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC9zcmNfZ3JpZF9wbHVnaW5fQW5pbWF0ZVJvd3NfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUE2QztBQUNEOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3REFBSTtBQUM5QjtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPOztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwrQkFBK0I7QUFDNUQ7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNCQUFzQjtBQUNuRDs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekIsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQSxzQ0FBc0MsMkJBQTJCO0FBQ2pFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDLDJCQUEyQjs7QUFFekU7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxvQkFBb0IsdURBQVE7QUFDNUI7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBLHVDQUF1QyxpQkFBaUI7O0FBRXhEOztBQUVBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsMkJBQTJCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsTlA7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNEQUFJO0FBQ3pCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTzs7QUFFcEI7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsYUFBYSxPQUFPLFdBQVc7QUFDL0I7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTzs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpRUFBZSxzQkFBc0IsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvZ3JpZC9wbHVnaW4vQW5pbWF0ZVJvd3MubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvcGx1Z2luL0Jhc2UubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCYXNlICAgICBmcm9tICcuLi8uLi9wbHVnaW4vQmFzZS5tanMnO1xuaW1wb3J0IE5lb0FycmF5IGZyb20gJy4uLy4uL3V0aWwvQXJyYXkubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmdyaWQucGx1Z2luLkFuaW1hdGVSb3dzXG4gKiBAZXh0ZW5kcyBOZW8ucGx1Z2luLkJhc2VcbiAqL1xuY2xhc3MgQW5pbWF0ZVJvd3MgZXh0ZW5kcyBCYXNlIHtcbiAgICAvKipcbiAgICAgKiBWYWxpZCB2YWx1ZXMgZm9yIHRyYW5zaXRpb25FYXNpbmdcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gdHJhbnNpdGlvbkVhc2luZ3M9WydlYXNlJywnZWFzZS1pbicsJ2Vhc2Utb3V0JywnZWFzZS1pbi1vdXQnLCdsaW5lYXInXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIHRyYW5zaXRpb25FYXNpbmdzID0gWydlYXNlJywgJ2Vhc2UtaW4nLCAnZWFzZS1vdXQnLCAnZWFzZS1pbi1vdXQnLCAnbGluZWFyJ11cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmdyaWQucGx1Z2luLkFuaW1hdGVSb3dzJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZ3JpZC5wbHVnaW4uQW5pbWF0ZVJvd3MnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ncGx1Z2luLWdyaWQtYW5pbWF0ZS1yb3dzJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3BsdWdpbi1ncmlkLWFuaW1hdGUtcm93cycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaW1lIGluIG1zIGZvciB0aGUgYmFja2dyb3VuZC1jb2xvciwgb3BhY2l0eSAmIHRyYW5zZm9ybSB0cmFuc2l0aW9uc1xuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHRyYW5zaXRpb25EdXJhdGlvbl89NTAwXG4gICAgICAgICAqL1xuICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb25fOiA1MDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZWFzaW5nIHVzZWQgZm9yIGZhZGVJbiwgZmFkZU91dCBhbmQgcG9zaXRpb24gY2hhbmdlcy5cbiAgICAgICAgICogVmFsaWQgdmFsdWVzOiAnZWFzZScsJ2Vhc2UtaW4nLCdlYXNlLW91dCcsJ2Vhc2UtaW4tb3V0JywnbGluZWFyJ1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHRyYW5zaXRpb25FYXNpbmdfPSdlYXNlLW91dCdcbiAgICAgICAgICovXG4gICAgICAgIHRyYW5zaXRpb25FYXNpbmdfOiAnZWFzZS1vdXQnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGlkIG9mIHRoZSBzZXRUaW1lb3V0KCkgY2FsbCB3aGljaCBnZXRzIHRyaWdnZXJlZCBhZnRlciBhIHRyYW5zaXRpb24gaXMgZG9uZS5cbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gdHJhbnNpdGlvblRpbWVvdXRJZD1udWxsXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRyYW5zaXRpb25UaW1lb3V0SWQgPSBudWxsXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7b3duZXJ9ID0gbWUsXG4gICAgICAgICAgICB7c3RvcmV9ID0gb3duZXI7XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBwcmV2aW91cyB2aWV3IGxpc3RlbmVyc1xuICAgICAgICBvd25lci5zdG9yZSA9IG51bGw7XG5cbiAgICAgICAgb3duZXIub25TdG9yZUZpbHRlciA9IG1lLm9uU3RvcmVGaWx0ZXIuYmluZChtZSk7XG4gICAgICAgIG93bmVyLm9uU3RvcmVMb2FkICAgPSBtZS5vblN0b3JlTG9hZCAgLmJpbmQobWUpO1xuXG4gICAgICAgIC8vIEFkZCB0aGUgcmUtYm91bmQgbGlzdGVuZXJzXG4gICAgICAgIG93bmVyLnN0b3JlID0gc3RvcmU7XG5cbiAgICAgICAgb3duZXIuYWRkQ2xzKCduZW8tYW5pbWF0ZS1yb3dzJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHRyYW5zaXRpb25EdXJhdGlvbiBjb25maWcgZ290IGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VHJhbnNpdGlvbkR1cmF0aW9uKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLm93bmVyLmFkZFN0eWxlKHsnLS1uZW8tZHVyYXRpb24nOiB2YWx1ZSArICdtcyd9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdHJhbnNpdGlvbkVhc2luZyBjb25maWcgZ290IGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VHJhbnNpdGlvbkVhc2luZyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5vd25lci5hZGRTdHlsZSh7Jy0tbmVvLWVhc2luZyc6IHZhbHVlfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSB0cmFuc2l0aW9uRWFzaW5nIGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0VHJhbnNpdGlvbkVhc2luZyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ3RyYW5zaXRpb25FYXNpbmcnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXG4gICAgICovXG4gICAgZGVzdHJveSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMub3duZXIuYWRkU3R5bGUoe1xuICAgICAgICAgICAgJy0tbmVvLWR1cmF0aW9uJzogbnVsbCxcbiAgICAgICAgICAgICctLW5lby1lYXNpbmcnICA6IG51bGxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc3VwZXIuZGVzdHJveSguLi5hcmdzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBkYXRhLmlzRmlsdGVyZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLml0ZW1zXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5vbGRJdGVtc1xuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuU3RvcmV9IGRhdGEuc2NvcGVcbiAgICAgKi9cbiAgICBvblN0b3JlRmlsdGVyKGRhdGEpIHtcbiAgICAgICAgdGhpcy51cGRhdGVWaWV3KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uU3RvcmVMb2FkKGRhdGEpIHtcbiAgICAgICAgdGhpcy51cGRhdGVWaWV3KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHVwZGF0ZVZpZXcoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtvd25lcn0gICAgICAgPSBtZSxcbiAgICAgICAgICAgIHttb3VudGVkUm93c30gPSBvd25lcixcbiAgICAgICAgICAgIGFkZGVkUm93cyAgICAgPSBbXSxcbiAgICAgICAgICAgIGhhc0NoYW5nZSAgICAgPSBmYWxzZSxcbiAgICAgICAgICAgIG1hcCAgICAgICAgICAgPSB7fSxcbiAgICAgICAgICAgIHJvd3NDb250YWluZXIgPSBvd25lci5nZXRWZG9tUm9vdCgpLmNuLFxuICAgICAgICAgICAgaWQsIG1hcEl0ZW0sIHJlY29yZCwgcm93LCByb3dJbmRleCwgdHJhbnNmb3JtO1xuXG4gICAgICAgIHJvd3NDb250YWluZXIuZm9yRWFjaChyb3cgPT4ge1xuICAgICAgICAgICAgbWFwW3Jvdy5pZF0gPSByb3dcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ3JlYXRlcyB0aGUgbmV3IHN0YXJ0ICYgZW5kIGluZGV4ZXMgaW5zaWRlIG1vdW50ZWRSb3dzXG4gICAgICAgIG93bmVyLnVwZGF0ZU1vdW50ZWRBbmRWaXNpYmxlUm93cygpO1xuXG4gICAgICAgIGZvciAocm93SW5kZXg9bW91bnRlZFJvd3NbMF07IHJvd0luZGV4IDwgbW91bnRlZFJvd3NbMV07IHJvd0luZGV4KyspIHtcbiAgICAgICAgICAgIHJlY29yZCAgPSBvd25lci5zdG9yZS5nZXRBdChyb3dJbmRleCk7XG4gICAgICAgICAgICBpZCAgICAgID0gb3duZXIuZ2V0Um93SWQocm93SW5kZXgpXG4gICAgICAgICAgICBtYXBJdGVtID0gbWFwW2lkXTtcblxuICAgICAgICAgICAgaWYgKG1hcEl0ZW0pIHtcbiAgICAgICAgICAgICAgICAvLyBJbnNpZGUgdGhlIG1hcCAocHJldmlvdXMgc3RhdGUpICYgdmRvbSA9PiBtb3ZlIE9QXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgwcHgsICR7cm93SW5kZXggKiBvd25lci5yb3dIZWlnaHR9cHgpYDtcblxuICAgICAgICAgICAgICAgIGlmIChtYXBJdGVtLnN0eWxlLnRyYW5zZm9ybSAhPT0gdHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcEl0ZW0uc3R5bGUub3BhY2l0eSAgID0gLjk7IC8vIHNsaWdodGx5IGxlc3MgdGhhbiAxIHRvIHNlZSB2aXN1YWwgb3ZlcmxheXMgd2hpbGUgbW92aW5nXG4gICAgICAgICAgICAgICAgICAgIG1hcEl0ZW0uc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgICAgICBOZW9BcnJheS50b2dnbGUobWFwSXRlbS5jbHMsICduZW8tZXZlbicsIHJvd0luZGV4ICUgMiAhPT0gMCk7XG4gICAgICAgICAgICAgICAgICAgIGhhc0NoYW5nZSA9IHRydWVcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkZWxldGUgbWFwW2lkXVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJbnNpZGUgdGhlIHZkb20sIGJ1dCBub3QgdGhlIG1hcCA9PiBpbnNlcnQgT1BcbiAgICAgICAgICAgICAgICByb3cgPSBvd25lci5jcmVhdGVSb3coe3JlY29yZCwgcm93SW5kZXh9KTtcblxuICAgICAgICAgICAgICAgIHJvdy5zdHlsZS5vcGFjaXR5ID0gMDtcblxuICAgICAgICAgICAgICAgIGFkZGVkUm93cyAgICAucHVzaChyb3cpO1xuICAgICAgICAgICAgICAgIHJvd3NDb250YWluZXIucHVzaChyb3cpO1xuXG4gICAgICAgICAgICAgICAgb3duZXIudXBkYXRlRGVwdGggPSAtMTsgLy8gQWRkZWQgcm93cyBtaWdodCBjb250YWluIGNvbXBvbmVudHNcbiAgICAgICAgICAgICAgICBoYXNDaGFuZ2UgPSB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPbmx5IHJvd3Mgd2hpY2ggbmVlZCB0byBnZXQgcmVtb3ZlZCBhcmUgc3RpbGwgaW5zaWRlIHRoZSBtYXBcbiAgICAgICAgT2JqZWN0LnZhbHVlcyhtYXApLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgICAgIHJvdy5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgICAgIGhhc0NoYW5nZSA9IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGhhc0NoYW5nZSkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KG1lLnRyYW5zaXRpb25UaW1lb3V0SWQpO1xuXG4gICAgICAgICAgICBvd25lci5wcm9taXNlVXBkYXRlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGFkZGVkUm93cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZGVkIHJvd3MgbmVlZCBhIDJuZCBET00gdXBkYXRlIHRvIGNoYW5nZSB0aGUgb3BhY2l0eSBmcm9tIDAgdG8gMS5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgYWRkZWQgdGhlbSB3aXRoIDEgZGlyZWN0bHksIHRoZXJlIHdvdWxkIG5vdCBiZSBhIGZhZGUtaW4gdHJhbnNpdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgYWRkZWRSb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5zdHlsZS5vcGFjaXR5ID0gMVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBvd25lci51cGRhdGUoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS50cmFuc2l0aW9uVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgbWUudHJhbnNpdGlvblRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgb3duZXIuY3JlYXRlVmlld0RhdGEoKVxuICAgICAgICAgICAgfSwgbWUudHJhbnNpdGlvbkR1cmF0aW9uKVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhBbmltYXRlUm93cyk7XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBwbHVnaW4gaW1wbGVtZW50YXRpb25zLlxuICogUGx1Z2lucyBhcmUgaW50ZW5kZWQgdG8gZ2V0IHB1dCBpbnRvIHRoZSBwbHVnaW5zIGNvbmZpZyBvZiBjb21wb25lbnQuQmFzZVxuICogdG8gZW5oYW5jZSB0aGVtIG9yIGFkZCBhZGRpdGlvbmFsIGZlYXR1cmVzXG4gKiBAY2xhc3MgTmVvLnBsdWdpbi5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIFBsdWdpbiBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnBsdWdpbi5CYXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ucGx1Z2luLkJhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQWxsIHBsdWdpbiBudHlwZXMgbmVlZCB0byBzdGFydCB3aXRoICdwbHVnaW4tJyB0byBlbnN1cmUgdGhhdCBjb21wb25lbnQuQmFzZTogZ2V0UGx1Z2luKCkgY2FuIGZpbmQgdGhlbVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdwbHVnaW4nXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAncGx1Z2luJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb21wb25lbnQuQmFzZX0gb3duZXI9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBvd25lcjogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSB3aW5kb3dJZF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgd2luZG93SWRfOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge293bmVyfSA9IG1lO1xuXG4gICAgICAgIGlmIChvd25lci5pc0NvbnN0cnVjdGVkKSB7XG4gICAgICAgICAgICBtZS5vbk93bmVyQ29uc3RydWN0ZWQoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3duZXIub24oJ2NvbnN0cnVjdGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1lLm9uT3duZXJDb25zdHJ1Y3RlZCgpXG4gICAgICAgICAgICB9LCBtZSwge29uY2U6IHRydWV9KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG93bmVyLm1vdW50ZWQpIHtcbiAgICAgICAgICAgIG1lLm9uT3duZXJNb3VudGVkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvd25lci5vbignbW91bnRlZCcsIG1lLm9uT3duZXJNb3VudGVkLCBtZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHdpbmRvd0lkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRXaW5kb3dJZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdmFsdWUgJiYgTmVvLmN1cnJlbnRXb3JrZXIuaW5zZXJ0VGhlbWVGaWxlcyh2YWx1ZSwgdGhpcy5fX3Byb3RvX18pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gYXBwbHkgY2hhbmdlcyB0byB0aGUgb3duZXIgQ29tcG9uZW50IHdoZW4gaXQgaXMgY29uc3RydWN0ZWRcbiAgICAgKi9cbiAgICBvbk93bmVyQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIGxldCB7b3duZXJ9ID0gdGhpcztcblxuICAgICAgICBpZiAob3duZXIud2luZG93SWQpIHtcbiAgICAgICAgICAgIHRoaXMud2luZG93SWQgPSBvd25lci53aW5kb3dJZFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gYXBwbHkgY2hhbmdlcyB0byB0aGUgb3duZXIgQ29tcG9uZW50IHdoZW4gaXQgZG9lcyBnZXQgbW91bnRlZFxuICAgICAqL1xuICAgIG9uT3duZXJNb3VudGVkKCkge1xuXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhQbHVnaW4pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9