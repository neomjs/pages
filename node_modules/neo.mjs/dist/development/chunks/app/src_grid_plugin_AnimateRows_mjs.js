"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["src_grid_plugin_AnimateRows_mjs"],{

/***/ "./src/grid/plugin/AnimateRows.mjs":
/*!*****************************************!*\
  !*** ./src/grid/plugin/AnimateRows.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _plugin_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../plugin/Base.mjs */ "./src/plugin/Base.mjs");
/* harmony import */ var _util_Css_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Css.mjs */ "./src/util/Css.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");




/**
 * @class Neo.grid.plugin.AnimateRows
 * @extends Neo.plugin.Base
 */
class AnimateRows extends _plugin_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for transitionEasing
     * @member {String[]} transitionEasings=['ease','ease-in','ease-out','ease-in-out','linear']
     * @protected
     * @static
     */
    static transitionEasings = ['ease', 'ease-in', 'ease-out', 'ease-in-out', 'linear']

    static config = {
        /**
         * @member {String} className='Neo.grid.plugin.AnimateRows'
         * @protected
         */
        className: 'Neo.grid.plugin.AnimateRows',
        /**
         * @member {String} ntype='plugin-grid-animate-rows'
         * @protected
         */
        ntype: 'plugin-grid-animate-rows',
        /**
         * Time in ms. Please ensure to match the CSS based value, in case you change the default.
         * @member {Number} transitionDuration_=500
         */
        transitionDuration_: 500,
        /**
         * The easing used for fadeIn, fadeOut and position changes.
         * Valid values: 'ease','ease-in','ease-out','ease-in-out','linear'
         * @member {String} transitionEasing_='ease-out'
         */
        transitionEasing_: 'ease-out'
    }

    /**
     * The id of the setTimeout() call which gets triggered after a transition is done.
     * @member {Number|null} transitionTimeoutId=null
     * @protected
     */
    transitionTimeoutId = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me      = this,
            {owner} = me,
            {store} = owner;

        // Remove the previous view listeners
        owner.store = null;

        owner.onStoreFilter = me.onStoreFilter.bind(me);
        owner.onStoreLoad   = me.onStoreLoad  .bind(me);

        // Add the re-bound listeners
        owner.store = store;

        me.updateTransitionDetails()
    }

    /**
     * Triggered after the transitionDuration config got changed.
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetTransitionDuration(value, oldValue) {
        this.isConstructed && this.updateTransitionDetails(Neo.isNumber(oldValue))
    }

    /**
     * Triggered after the transitionEasing config got changed.
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetTransitionEasing(value, oldValue) {
        this.isConstructed && this.updateTransitionDetails(!!oldValue)
    }

    /**
     * Triggered before the transitionEasing config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetTransitionEasing(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'transitionEasing')
    }

    /**
     * @param {Object} args
     */
    destroy(...args) {
        _util_Css_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].deleteRules(this.appName, `#${this.owner.id} .neo-grid-row`);
        super.destroy(...args)
    }

    /**
     * @param {Object} data
     * @param {Boolean} data.isFiltered
     * @param {Object[]} data.items
     * @param {Object[]} data.oldItems
     * @param {Neo.data.Store} data.scope
     */
    onStoreFilter(data) {
        this.updateView()
    }

    /**
     * @param {Object[]} data
     * @protected
     */
    onStoreLoad(data) {
        this.updateView()
    }

    /**
     * We do not want to apply the style to each list item itself,
     * so we are using Neo.util.Css
     * @param {Boolean} deleteRule=false
     * @protected
     */
    async updateTransitionDetails(deleteRule=false) {
        let me       = this,
            duration = me.transitionDuration,
            easing   = me.transitionEasing,
            {id}     = me.owner;

        if (deleteRule) {
            await _util_Css_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].deleteRules(me.appName, `#${id} .neo-grid-row`)
        }

        _util_Css_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].insertRules(me.appName, [
            `#${id} .neo-grid-row {`,
                'transition:',
                    `background-color ${duration}ms ${easing},`,
                    `opacity ${duration}ms ${easing},`,
                    `transform ${duration}ms ${easing}`,
            '}'
        ].join(''))
    }

    /**
     *
     */
    updateView() {
        let me            = this,
            {owner}       = me,
            {mountedRows} = owner,
            addedRows     = [],
            hasChange     = false,
            map           = {},
            rowsContainer = owner.getVdomRoot().cn,
            id, mapItem, record, row, rowIndex, transform;

        rowsContainer.forEach(row => {
            map[row.id] = row
        });

        // Creates the new start & end indexes inside mountedRows
        owner.updateMountedAndVisibleRows();

        for (rowIndex=mountedRows[0]; rowIndex < mountedRows[1]; rowIndex++) {
            record  = owner.store.getAt(rowIndex);
            id      = owner.getRowId(record, rowIndex)
            mapItem = map[id];

            if (mapItem) {
                // Inside the map (previous state) & vdom => move OP
                transform = `translate(0px, ${rowIndex * owner.rowHeight}px)`;

                if (mapItem.style.transform !== transform) {
                    mapItem.style.opacity   = .9; // slightly less than 1 to see visual overlays while moving
                    mapItem.style.transform = transform;
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].toggle(mapItem.cls, 'neo-even', rowIndex % 2 !== 0);
                    hasChange = true
                }

                delete map[id]
            } else {
                // Inside the vdom, but not the map => insert OP
                row = owner.createRow({record, rowIndex});

                row.style.opacity = 0;

                addedRows    .push(row);
                rowsContainer.push(row);

                owner.updateDepth = -1; // Added rows might contain components
                hasChange = true
            }
        }

        // Only rows which need to get removed are still inside the map
        Object.values(map).forEach(row => {
            row.style.opacity = 0;
            hasChange = true
        });

        if (hasChange) {
            clearTimeout(me.transitionTimeoutId);

            owner.promiseUpdate().then(() => {
                if (addedRows.length > 0) {
                    // Added rows need a 2nd DOM update to change the opacity from 0 to 1.
                    // If we added them with 1 directly, there would not be a fade-in transition.
                    addedRows.forEach(row => {
                        row.style.opacity = 1
                    });

                    owner.update()
                }
            });

            me.transitionTimeoutId = setTimeout(() => {
                me.transitionTimeoutId = null;
                owner.createViewData()
            }, me.transitionDuration)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(AnimateRows));


/***/ }),

/***/ "./src/plugin/Base.mjs":
/*!*****************************!*\
  !*** ./src/plugin/Base.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * Abstract base class for plugin implementations.
 * Plugins are intended to get put into the plugins config of component.Base
 * to enhance them or add additional features
 * @class Neo.plugin.Base
 * @extends Neo.core.Base
 */
class Plugin extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.plugin.Base'
         * @protected
         */
        className: 'Neo.plugin.Base',
        /**
         * All plugin ntypes need to start with 'plugin-' to ensure that component.Base: getPlugin() can find them
         * @member {String} ntype='plugin'
         * @protected
         */
        ntype: 'plugin',
        /**
         * @member {Neo.component.Base} owner=null
         * @protected
         */
        owner: null,
        /**
         * @member {Number|null} windowId_=null
         */
        windowId_: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        if (me.owner.mounted) {
            me.onOwnerMounted();
        } else {
            me.owner.on('mounted', me.onOwnerMounted, me);
        }
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        value && Neo.currentWorker.insertThemeFiles(value, this.__proto__)
    }

    /**
     * Override this method to apply changes to the owner Component when it does get mounted
     */
    onOwnerMounted() {

    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Plugin));


/***/ }),

/***/ "./src/util/Css.mjs":
/*!**************************!*\
  !*** ./src/util/Css.mjs ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.util.Css
 * @extends Neo.core.Base
 */
class Css extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.Css'
         * @protected
         */
        className: 'Neo.util.Css'
    }

    /**
     * Pass the selectorText of the rules which you want to remove
     * @param {String} appName
     * @param {String[]|String} rules
     */
    static deleteRules(appName, rules) {
        if (!Array.isArray(rules)) {
            rules = [rules]
        }

        Neo.main.addon.Stylesheet.deleteCssRules({appName, rules})
    }

    /**
     * @param {String} appName
     * @param {String[]|String} rules
     */
    static insertRules(appName, rules) {
        if (!Array.isArray(rules)) {
            rules = [rules]
        }

        Neo.main.addon.Stylesheet.insertCssRules({appName, rules})
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Css));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC9zcmNfZ3JpZF9wbHVnaW5fQW5pbWF0ZVJvd3NfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNkM7QUFDSDtBQUNFOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3REFBSTtBQUM5QjtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPOztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxRQUFRLHFEQUFPLCtCQUErQixlQUFlO0FBQzdEO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekIsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFROztBQUVyQjtBQUNBLGtCQUFrQixxREFBTyw2QkFBNkIsSUFBSTtBQUMxRDs7QUFFQSxRQUFRLHFEQUFPO0FBQ2YsZ0JBQWdCLElBQUksZUFBZTtBQUNuQztBQUNBLHdDQUF3QyxTQUFTLEtBQUssT0FBTztBQUM3RCwrQkFBK0IsU0FBUyxLQUFLLE9BQU87QUFDcEQsaUNBQWlDLFNBQVMsS0FBSyxPQUFPO0FBQ3RELGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBLHNDQUFzQywyQkFBMkI7QUFDakU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEMsMkJBQTJCOztBQUV6RTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLG9CQUFvQix1REFBUTtBQUM1QjtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsdUNBQXVDLGlCQUFpQjs7QUFFeEQ7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSwyQkFBMkIsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ3pPUDs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0RBQUk7QUFDekI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpRUFBZSxzQkFBc0IsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ2xFRjs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0RBQUk7QUFDdEI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrREFBa0QsZUFBZTtBQUNqRTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtEQUFrRCxlQUFlO0FBQ2pFO0FBQ0E7O0FBRUEsaUVBQWUsbUJBQW1CLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2dyaWQvcGx1Z2luL0FuaW1hdGVSb3dzLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3BsdWdpbi9CYXNlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3V0aWwvQ3NzLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZSAgICAgZnJvbSAnLi4vLi4vcGx1Z2luL0Jhc2UubWpzJztcbmltcG9ydCBDc3NVdGlsICBmcm9tICcuLi8uLi91dGlsL0Nzcy5tanMnO1xuaW1wb3J0IE5lb0FycmF5IGZyb20gJy4uLy4uL3V0aWwvQXJyYXkubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmdyaWQucGx1Z2luLkFuaW1hdGVSb3dzXG4gKiBAZXh0ZW5kcyBOZW8ucGx1Z2luLkJhc2VcbiAqL1xuY2xhc3MgQW5pbWF0ZVJvd3MgZXh0ZW5kcyBCYXNlIHtcbiAgICAvKipcbiAgICAgKiBWYWxpZCB2YWx1ZXMgZm9yIHRyYW5zaXRpb25FYXNpbmdcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gdHJhbnNpdGlvbkVhc2luZ3M9WydlYXNlJywnZWFzZS1pbicsJ2Vhc2Utb3V0JywnZWFzZS1pbi1vdXQnLCdsaW5lYXInXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIHRyYW5zaXRpb25FYXNpbmdzID0gWydlYXNlJywgJ2Vhc2UtaW4nLCAnZWFzZS1vdXQnLCAnZWFzZS1pbi1vdXQnLCAnbGluZWFyJ11cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmdyaWQucGx1Z2luLkFuaW1hdGVSb3dzJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZ3JpZC5wbHVnaW4uQW5pbWF0ZVJvd3MnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ncGx1Z2luLWdyaWQtYW5pbWF0ZS1yb3dzJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3BsdWdpbi1ncmlkLWFuaW1hdGUtcm93cycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaW1lIGluIG1zLiBQbGVhc2UgZW5zdXJlIHRvIG1hdGNoIHRoZSBDU1MgYmFzZWQgdmFsdWUsIGluIGNhc2UgeW91IGNoYW5nZSB0aGUgZGVmYXVsdC5cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSB0cmFuc2l0aW9uRHVyYXRpb25fPTUwMFxuICAgICAgICAgKi9cbiAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uXzogNTAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGVhc2luZyB1c2VkIGZvciBmYWRlSW4sIGZhZGVPdXQgYW5kIHBvc2l0aW9uIGNoYW5nZXMuXG4gICAgICAgICAqIFZhbGlkIHZhbHVlczogJ2Vhc2UnLCdlYXNlLWluJywnZWFzZS1vdXQnLCdlYXNlLWluLW91dCcsJ2xpbmVhcidcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB0cmFuc2l0aW9uRWFzaW5nXz0nZWFzZS1vdXQnXG4gICAgICAgICAqL1xuICAgICAgICB0cmFuc2l0aW9uRWFzaW5nXzogJ2Vhc2Utb3V0J1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBpZCBvZiB0aGUgc2V0VGltZW91dCgpIGNhbGwgd2hpY2ggZ2V0cyB0cmlnZ2VyZWQgYWZ0ZXIgYSB0cmFuc2l0aW9uIGlzIGRvbmUuXG4gICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IHRyYW5zaXRpb25UaW1lb3V0SWQ9bnVsbFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0cmFuc2l0aW9uVGltZW91dElkID0gbnVsbFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge293bmVyfSA9IG1lLFxuICAgICAgICAgICAge3N0b3JlfSA9IG93bmVyO1xuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgcHJldmlvdXMgdmlldyBsaXN0ZW5lcnNcbiAgICAgICAgb3duZXIuc3RvcmUgPSBudWxsO1xuXG4gICAgICAgIG93bmVyLm9uU3RvcmVGaWx0ZXIgPSBtZS5vblN0b3JlRmlsdGVyLmJpbmQobWUpO1xuICAgICAgICBvd25lci5vblN0b3JlTG9hZCAgID0gbWUub25TdG9yZUxvYWQgIC5iaW5kKG1lKTtcblxuICAgICAgICAvLyBBZGQgdGhlIHJlLWJvdW5kIGxpc3RlbmVyc1xuICAgICAgICBvd25lci5zdG9yZSA9IHN0b3JlO1xuXG4gICAgICAgIG1lLnVwZGF0ZVRyYW5zaXRpb25EZXRhaWxzKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHRyYW5zaXRpb25EdXJhdGlvbiBjb25maWcgZ290IGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VHJhbnNpdGlvbkR1cmF0aW9uKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmlzQ29uc3RydWN0ZWQgJiYgdGhpcy51cGRhdGVUcmFuc2l0aW9uRGV0YWlscyhOZW8uaXNOdW1iZXIob2xkVmFsdWUpKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdHJhbnNpdGlvbkVhc2luZyBjb25maWcgZ290IGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VHJhbnNpdGlvbkVhc2luZyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5pc0NvbnN0cnVjdGVkICYmIHRoaXMudXBkYXRlVHJhbnNpdGlvbkRldGFpbHMoISFvbGRWYWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSB0cmFuc2l0aW9uRWFzaW5nIGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0VHJhbnNpdGlvbkVhc2luZyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ3RyYW5zaXRpb25FYXNpbmcnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXG4gICAgICovXG4gICAgZGVzdHJveSguLi5hcmdzKSB7XG4gICAgICAgIENzc1V0aWwuZGVsZXRlUnVsZXModGhpcy5hcHBOYW1lLCBgIyR7dGhpcy5vd25lci5pZH0gLm5lby1ncmlkLXJvd2ApO1xuICAgICAgICBzdXBlci5kZXN0cm95KC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRhdGEuaXNGaWx0ZXJlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGEuaXRlbXNcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLm9sZEl0ZW1zXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5TdG9yZX0gZGF0YS5zY29wZVxuICAgICAqL1xuICAgIG9uU3RvcmVGaWx0ZXIoZGF0YSkge1xuICAgICAgICB0aGlzLnVwZGF0ZVZpZXcoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGFcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25TdG9yZUxvYWQoZGF0YSkge1xuICAgICAgICB0aGlzLnVwZGF0ZVZpZXcoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdlIGRvIG5vdCB3YW50IHRvIGFwcGx5IHRoZSBzdHlsZSB0byBlYWNoIGxpc3QgaXRlbSBpdHNlbGYsXG4gICAgICogc28gd2UgYXJlIHVzaW5nIE5lby51dGlsLkNzc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGVsZXRlUnVsZT1mYWxzZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVUcmFuc2l0aW9uRGV0YWlscyhkZWxldGVSdWxlPWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBkdXJhdGlvbiA9IG1lLnRyYW5zaXRpb25EdXJhdGlvbixcbiAgICAgICAgICAgIGVhc2luZyAgID0gbWUudHJhbnNpdGlvbkVhc2luZyxcbiAgICAgICAgICAgIHtpZH0gICAgID0gbWUub3duZXI7XG5cbiAgICAgICAgaWYgKGRlbGV0ZVJ1bGUpIHtcbiAgICAgICAgICAgIGF3YWl0IENzc1V0aWwuZGVsZXRlUnVsZXMobWUuYXBwTmFtZSwgYCMke2lkfSAubmVvLWdyaWQtcm93YClcbiAgICAgICAgfVxuXG4gICAgICAgIENzc1V0aWwuaW5zZXJ0UnVsZXMobWUuYXBwTmFtZSwgW1xuICAgICAgICAgICAgYCMke2lkfSAubmVvLWdyaWQtcm93IHtgLFxuICAgICAgICAgICAgICAgICd0cmFuc2l0aW9uOicsXG4gICAgICAgICAgICAgICAgICAgIGBiYWNrZ3JvdW5kLWNvbG9yICR7ZHVyYXRpb259bXMgJHtlYXNpbmd9LGAsXG4gICAgICAgICAgICAgICAgICAgIGBvcGFjaXR5ICR7ZHVyYXRpb259bXMgJHtlYXNpbmd9LGAsXG4gICAgICAgICAgICAgICAgICAgIGB0cmFuc2Zvcm0gJHtkdXJhdGlvbn1tcyAke2Vhc2luZ31gLFxuICAgICAgICAgICAgJ30nXG4gICAgICAgIF0uam9pbignJykpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICB1cGRhdGVWaWV3KCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7b3duZXJ9ICAgICAgID0gbWUsXG4gICAgICAgICAgICB7bW91bnRlZFJvd3N9ID0gb3duZXIsXG4gICAgICAgICAgICBhZGRlZFJvd3MgICAgID0gW10sXG4gICAgICAgICAgICBoYXNDaGFuZ2UgICAgID0gZmFsc2UsXG4gICAgICAgICAgICBtYXAgICAgICAgICAgID0ge30sXG4gICAgICAgICAgICByb3dzQ29udGFpbmVyID0gb3duZXIuZ2V0VmRvbVJvb3QoKS5jbixcbiAgICAgICAgICAgIGlkLCBtYXBJdGVtLCByZWNvcmQsIHJvdywgcm93SW5kZXgsIHRyYW5zZm9ybTtcblxuICAgICAgICByb3dzQ29udGFpbmVyLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgICAgIG1hcFtyb3cuaWRdID0gcm93XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENyZWF0ZXMgdGhlIG5ldyBzdGFydCAmIGVuZCBpbmRleGVzIGluc2lkZSBtb3VudGVkUm93c1xuICAgICAgICBvd25lci51cGRhdGVNb3VudGVkQW5kVmlzaWJsZVJvd3MoKTtcblxuICAgICAgICBmb3IgKHJvd0luZGV4PW1vdW50ZWRSb3dzWzBdOyByb3dJbmRleCA8IG1vdW50ZWRSb3dzWzFdOyByb3dJbmRleCsrKSB7XG4gICAgICAgICAgICByZWNvcmQgID0gb3duZXIuc3RvcmUuZ2V0QXQocm93SW5kZXgpO1xuICAgICAgICAgICAgaWQgICAgICA9IG93bmVyLmdldFJvd0lkKHJlY29yZCwgcm93SW5kZXgpXG4gICAgICAgICAgICBtYXBJdGVtID0gbWFwW2lkXTtcblxuICAgICAgICAgICAgaWYgKG1hcEl0ZW0pIHtcbiAgICAgICAgICAgICAgICAvLyBJbnNpZGUgdGhlIG1hcCAocHJldmlvdXMgc3RhdGUpICYgdmRvbSA9PiBtb3ZlIE9QXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgwcHgsICR7cm93SW5kZXggKiBvd25lci5yb3dIZWlnaHR9cHgpYDtcblxuICAgICAgICAgICAgICAgIGlmIChtYXBJdGVtLnN0eWxlLnRyYW5zZm9ybSAhPT0gdHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcEl0ZW0uc3R5bGUub3BhY2l0eSAgID0gLjk7IC8vIHNsaWdodGx5IGxlc3MgdGhhbiAxIHRvIHNlZSB2aXN1YWwgb3ZlcmxheXMgd2hpbGUgbW92aW5nXG4gICAgICAgICAgICAgICAgICAgIG1hcEl0ZW0uc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgICAgICBOZW9BcnJheS50b2dnbGUobWFwSXRlbS5jbHMsICduZW8tZXZlbicsIHJvd0luZGV4ICUgMiAhPT0gMCk7XG4gICAgICAgICAgICAgICAgICAgIGhhc0NoYW5nZSA9IHRydWVcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkZWxldGUgbWFwW2lkXVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJbnNpZGUgdGhlIHZkb20sIGJ1dCBub3QgdGhlIG1hcCA9PiBpbnNlcnQgT1BcbiAgICAgICAgICAgICAgICByb3cgPSBvd25lci5jcmVhdGVSb3coe3JlY29yZCwgcm93SW5kZXh9KTtcblxuICAgICAgICAgICAgICAgIHJvdy5zdHlsZS5vcGFjaXR5ID0gMDtcblxuICAgICAgICAgICAgICAgIGFkZGVkUm93cyAgICAucHVzaChyb3cpO1xuICAgICAgICAgICAgICAgIHJvd3NDb250YWluZXIucHVzaChyb3cpO1xuXG4gICAgICAgICAgICAgICAgb3duZXIudXBkYXRlRGVwdGggPSAtMTsgLy8gQWRkZWQgcm93cyBtaWdodCBjb250YWluIGNvbXBvbmVudHNcbiAgICAgICAgICAgICAgICBoYXNDaGFuZ2UgPSB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPbmx5IHJvd3Mgd2hpY2ggbmVlZCB0byBnZXQgcmVtb3ZlZCBhcmUgc3RpbGwgaW5zaWRlIHRoZSBtYXBcbiAgICAgICAgT2JqZWN0LnZhbHVlcyhtYXApLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgICAgIHJvdy5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgICAgIGhhc0NoYW5nZSA9IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGhhc0NoYW5nZSkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KG1lLnRyYW5zaXRpb25UaW1lb3V0SWQpO1xuXG4gICAgICAgICAgICBvd25lci5wcm9taXNlVXBkYXRlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGFkZGVkUm93cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZGVkIHJvd3MgbmVlZCBhIDJuZCBET00gdXBkYXRlIHRvIGNoYW5nZSB0aGUgb3BhY2l0eSBmcm9tIDAgdG8gMS5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgYWRkZWQgdGhlbSB3aXRoIDEgZGlyZWN0bHksIHRoZXJlIHdvdWxkIG5vdCBiZSBhIGZhZGUtaW4gdHJhbnNpdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgYWRkZWRSb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5zdHlsZS5vcGFjaXR5ID0gMVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBvd25lci51cGRhdGUoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS50cmFuc2l0aW9uVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgbWUudHJhbnNpdGlvblRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgb3duZXIuY3JlYXRlVmlld0RhdGEoKVxuICAgICAgICAgICAgfSwgbWUudHJhbnNpdGlvbkR1cmF0aW9uKVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhBbmltYXRlUm93cyk7XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBwbHVnaW4gaW1wbGVtZW50YXRpb25zLlxuICogUGx1Z2lucyBhcmUgaW50ZW5kZWQgdG8gZ2V0IHB1dCBpbnRvIHRoZSBwbHVnaW5zIGNvbmZpZyBvZiBjb21wb25lbnQuQmFzZVxuICogdG8gZW5oYW5jZSB0aGVtIG9yIGFkZCBhZGRpdGlvbmFsIGZlYXR1cmVzXG4gKiBAY2xhc3MgTmVvLnBsdWdpbi5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIFBsdWdpbiBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnBsdWdpbi5CYXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ucGx1Z2luLkJhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQWxsIHBsdWdpbiBudHlwZXMgbmVlZCB0byBzdGFydCB3aXRoICdwbHVnaW4tJyB0byBlbnN1cmUgdGhhdCBjb21wb25lbnQuQmFzZTogZ2V0UGx1Z2luKCkgY2FuIGZpbmQgdGhlbVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdwbHVnaW4nXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAncGx1Z2luJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb21wb25lbnQuQmFzZX0gb3duZXI9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBvd25lcjogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSB3aW5kb3dJZF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgd2luZG93SWRfOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUub3duZXIubW91bnRlZCkge1xuICAgICAgICAgICAgbWUub25Pd25lck1vdW50ZWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLm93bmVyLm9uKCdtb3VudGVkJywgbWUub25Pd25lck1vdW50ZWQsIG1lKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgd2luZG93SWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFdpbmRvd0lkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB2YWx1ZSAmJiBOZW8uY3VycmVudFdvcmtlci5pbnNlcnRUaGVtZUZpbGVzKHZhbHVlLCB0aGlzLl9fcHJvdG9fXylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBhcHBseSBjaGFuZ2VzIHRvIHRoZSBvd25lciBDb21wb25lbnQgd2hlbiBpdCBkb2VzIGdldCBtb3VudGVkXG4gICAgICovXG4gICAgb25Pd25lck1vdW50ZWQoKSB7XG5cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFBsdWdpbik7XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnV0aWwuQ3NzXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIENzcyBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnV0aWwuQ3NzJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8udXRpbC5Dc3MnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFzcyB0aGUgc2VsZWN0b3JUZXh0IG9mIHRoZSBydWxlcyB3aGljaCB5b3Ugd2FudCB0byByZW1vdmVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXBwTmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nW118U3RyaW5nfSBydWxlc1xuICAgICAqL1xuICAgIHN0YXRpYyBkZWxldGVSdWxlcyhhcHBOYW1lLCBydWxlcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocnVsZXMpKSB7XG4gICAgICAgICAgICBydWxlcyA9IFtydWxlc11cbiAgICAgICAgfVxuXG4gICAgICAgIE5lby5tYWluLmFkZG9uLlN0eWxlc2hlZXQuZGVsZXRlQ3NzUnVsZXMoe2FwcE5hbWUsIHJ1bGVzfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXBwTmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nW118U3RyaW5nfSBydWxlc1xuICAgICAqL1xuICAgIHN0YXRpYyBpbnNlcnRSdWxlcyhhcHBOYW1lLCBydWxlcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocnVsZXMpKSB7XG4gICAgICAgICAgICBydWxlcyA9IFtydWxlc11cbiAgICAgICAgfVxuXG4gICAgICAgIE5lby5tYWluLmFkZG9uLlN0eWxlc2hlZXQuaW5zZXJ0Q3NzUnVsZXMoe2FwcE5hbWUsIHJ1bGVzfSlcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKENzcyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=