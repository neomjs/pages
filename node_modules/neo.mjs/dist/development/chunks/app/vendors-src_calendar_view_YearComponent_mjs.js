"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_calendar_view_YearComponent_mjs"],{

/***/ "./src/calendar/view/YearComponent.mjs"
/*!*********************************************!*\
  !*** ./src/calendar/view/YearComponent.mjs ***!
  \*********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Date.mjs */ "./src/util/Date.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");




const todayDate = new Date();

const today = {
    day  : todayDate.getDate(),
    month: todayDate.getMonth(),
    year : todayDate.getFullYear()
};

/**
 * @class Neo.calendar.view.YearComponent
 * @extends Neo.component.Base
 */
class YearComponent extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.calendar.view.YearComponent'
         * @protected
         */
        className: 'Neo.calendar.view.YearComponent',
        /**
         * @member {String[]} baseCls=['neo-calendar-yearcomponent']
         */
        baseCls: ['neo-calendar-yearcomponent'],
        /**
         * @member {Object} bind
         */
        bind: {
            calendarStore       : 'stores.calendars',
            currentDate         : data => data.currentDate,
            eventStore          : 'stores.events',
            locale              : data => data.locale,
            scrollNewYearFromTop: data => data.scrollNewYearFromTop,
            showWeekends        : data => data.showWeekends,
            weekStartDay        : data => data.weekStartDay
        },
        /**
         * Stores the last date change which got triggered while a year transition was running
         * @member {Date|null} cachedUpdate=null
         * @protected
         */
        cachedUpdate: null,
        /**
         * Bound to the state provider.
         * @member {Neo.calendar.store.Calendars|null} calendarStore_=null
         * @reactive
         */
        calendarStore_: null,
        /**
         * Will get passed from the MainContainer
         * @member {Date|null} currentDate_=null
         * @protected
         * @reactive
         */
        currentDate_: null,
        /**
         * The format of the column headers.
         * Valid values are: narrow, short & long
         * @member {String} dayNameFormat_='narrow'
         * @reactive
         */
        dayNameFormat_: 'narrow',
        /**
         * @member {Number} eventIndicatorHigh_=3
         * @reactive
         */
        eventIndicatorHigh_: 3,
        /**
         * @member {Number} eventIndicatorLow_=1
         * @reactive
         */
        eventIndicatorLow_: 1,
        /**
         * @member {Number} eventIndicatorMedium_=2
         * @reactive
         */
        eventIndicatorMedium_: 2,
        /**
         * Bound to the state provider.
         * @member {Neo.calendar.store.Events|null} eventStore_=null
         * @reactive
         */
        eventStore_: null,
        /**
         * @member {Intl.DateTimeFormat|null} intlFormat_day=null
         * @protected
         */
        intlFormat_day: null,
        /**
         * @member {Intl.DateTimeFormat|null} intlFormat_month=null
         * @protected
         */
        intlFormat_month: null,
        /**
         * Internal flag to prevent changing the date while change animations are still running
         * @member {Boolean} isUpdating_=false
         * @protected
         * @reactive
         */
        isUpdating_: false,
        /**
         * Bound to the state provider.
         * @member {String} locale_=Neo.config.locale
         * @reactive
         */
        locale_: Neo.config.locale,
        /**
         * The format of the month header names.
         * Valid values are: narrow, short & long
         * @member {String} monthNameFormat_='long'
         * @reactive
         */
        monthNameFormat_: 'long',
        /**
         * Internal flag to store if createMonths() got called while not being mounted
         * @member {Boolean} needsEventUpdate=false
         * @protected
         */
        needsEventUpdate: false,
        /**
         * @member {Neo.calendar.view.MainContainer|null} owner=null
         * @protected
         */
        owner: null,
        /**
         * True to scroll new years in from the top
         * @member {Boolean} scrollNewYearFromTop=false
         */
        scrollNewYearFromTop: false,
        /**
         * True to show borders for the calendar month cells
         * @member {Boolean} showCellBorders_=false
         * @reactive
         */
        showCellBorders_: false,
        /**
         * True to show the days of the previous or next month (not selectable)
         * @member {Boolean} showDisabledDays_=true
         * @reactive
         */
        showDisabledDays_: true,
        /**
         * Bound to the state provider.
         * @member {Boolean} showWeekends_=true
         * @reactive
         */
        showWeekends_: true,
        /**
         * True to show the week number as the first column of each month
         * @member {Boolean} showWeekNumbers_=true
         * @reactive
         */
        showWeekNumbers_: true,
        /**
         * True to show 6 weeks for each month, so that all months have the same height
         * @member {Boolean} sixWeeksPerMonth_=false
         * @reactive
         */
        sixWeeksPerMonth_: false,
        /**
         * True to use sliding animations
         * @member {Boolean} useAnimations=true
         */
        useAnimations: true,
        /**
         * @member {Object} vdom
         */
        vdom:
        {cn: [
            {cls: ['neo-content-wrapper'], cn: [
                {cls: ['neo-year-header'], cn: [
                    {},
                    {cls: ['neo-nav-button', 'neo-prev-button']},
                    {cls: ['neo-nav-button', 'neo-next-button']}
                ]},
                {cls: ['neo-months-container']}
            ]}
        ]},
        /**
         * 0-6 => Sun-Sat
         * Bound to the state provider.
         * @member {Number} weekStartDay_=0
         * @reactive
         */
        weekStartDay_: 0
    }

    /**
     * @param config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.addDomListeners([
            {click: me.onNavButtonClick, delegate: '.neo-nav-button', scope: me},
            {wheel: me.onWheel, scope: me}
        ]);

        if (me.calendarStore.getCount() > 0 && me.eventStore.getCount() > 0) {
            me.createMonths(true) // silent update
        }

        me.updateHeaderYear()
    }

    /**
     * Triggered after the calendarStore config got changed
     * @param {Neo.calendar.store.Calendars|null} value
     * @param {Neo.calendar.store.Calendars|null} oldValue
     * @protected
     */
    afterSetCalendarStore(value, oldValue) {
        let me = this,

        listeners = {
            load        : me.onCalendarStoreLoad,
            recordChange: me.onCalendarStoreRecordChange,
            scope       : me
        };

        oldValue?.un(listeners);
        value   ?.on(listeners)
    }

    /**
     * Triggered after the currentDate config got changed
     * @param {Date} value
     * @param {Date} oldValue
     * @protected
     */
    afterSetCurrentDate(value, oldValue) {
        if (this.isConstructed) {
            let oldYear = oldValue.getFullYear(),
                year    = value   .getFullYear();

            if (year !== oldYear) {
                this.changeYear(year - oldYear)
            }
        }
    }

    /**
     * Triggered after the dayNameFormat config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetDayNameFormat(value, oldValue) {
        this.updateDayNamesRows(value, oldValue)
    }

    /**
     * Triggered after the eventIndicatorHigh config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetEventIndicatorHigh(value, oldValue) {
        oldValue !== undefined && this.createMonths()
    }

    /**
     * Triggered after the eventIndicatorLow config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetEventIndicatorLow(value, oldValue) {
        oldValue !== undefined && this.createMonths()
    }

    /**
     * Triggered after the eventIndicatorMedium config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetEventIndicatorMedium(value, oldValue) {
        oldValue !== undefined && this.createMonths()
    }

    /**
     * Triggered after the eventStore config got changed
     * @param {Neo.calendar.store.Events|null} value
     * @param {Neo.calendar.store.Events|null} oldValue
     * @protected
     */
    afterSetEventStore(value, oldValue) {
        let me = this,

        listeners = {
            load        : me.onEventStoreLoad,
            recordChange: me.onEventStoreRecordChange,
            scope       : me
        };

        oldValue?.un(listeners);
        value   ?.on(listeners)
    }

    /**
     * Triggered after the locale config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetLocale(value, oldValue) {
        if (oldValue !== undefined) {
            let me = this;

            me.updateDayNamesRows(me.dayNameFormat, '', true);
            me.updateMonthNameFormat(me.monthNameFormat, '')
        }
    }

    /**
     * Triggered after the monthNameFormat config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetMonthNameFormat(value, oldValue) {
        this.updateMonthNameFormat(value, oldValue)
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        let me = this;

        if (value && me.needsEventUpdate) {
            me.createMonths();
            me.needsEventUpdate = false
        }
    }

    /**
     * Triggered after the showCellBorders config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowCellBorders(value, oldValue) {
        let cls = this.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"][value ? 'add' : 'remove'](cls, 'neo-show-cell-borders');
        this.cls = cls
    }

    /**
     * Triggered after the showWeekends config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowWeekends(value, oldValue) {
        if (oldValue !== undefined) {
            let me     = this,
                {vdom} = me,
                i      = 0,
                item, itemCn, j, k, len;

            for (; i < 12; i++) { // months
                itemCn = vdom.cn[0].cn[1].cn[i].cn;
                len    = itemCn.length;

                for (j=1; j < len; j++) { // weeks
                    for (k=1; k < 8; k++) { // days
                        item = itemCn[j].cn[k];

                        if (item.cls.includes('neo-weekend')) {
                            if (value) {
                                delete item.removeDom
                            } else {
                                item.removeDom = true
                            }
                        }
                    }
                }
            }

            // triggers the vdom update
            me.updateDayNamesRows(me.dayNameFormat, '')
        }
    }

    /**
     * Triggered after the showWeekNumbers config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowWeekNumbers(value, oldValue) {
        if (oldValue !== undefined) {
            let me = this,
                i  = 0,
                itemCn, j, len;

            for (; i < 12; i++) {
                itemCn = me.vdom.cn[0].cn[1].cn[i].cn;
                len    = itemCn.length;

                for (j = 1; j < len; j++) {
                    itemCn[j].cn[0].removeDom = !value
                }
            }

            me.update()
        }
    }

    /**
     * Triggered after the sixWeeksPerMonth config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetSixWeeksPerMonth(value, oldValue) {
        if (oldValue !== undefined) {
            let me   = this,
                date = me.currentDate, // cloned
                i    = 0;

            date.setMonth(0);
            date.setDate(1);

            for (; i < 12; i++) {
                me.vdom.cn[0].cn[1].cn[i].cn[7].removeDom = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getWeeksOfMonth(date, me.weekStartDay) === 5 && !value;
                date.setMonth(date.getMonth() + 1)
            }

            me.update()
        }
    }

    /**
     * Triggered after the weekStartDay config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetWeekStartDay(value, oldValue) {
        oldValue !== undefined && this.createMonths()
    }

    /**
     * Triggered before the dayNameFormat config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetDayNameFormat(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'dayNameFormat', _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.dayNameFormats)
    }

    /**
     * Triggered before the monthNameFormat config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetMonthNameFormat(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'monthNameFormat', _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.monthNameFormats)
    }

    /**
     * Stores the last date change which could not get applied while a transition was running
     * @param {Date} [date=this.currentDate]
     * @protected
     */
    cacheUpdate(date=this.currentDate) {
        this.cachedUpdate = date
    }

    /**
     * @param {Number} increment
     */
    changeYear(increment) {
        let me = this,
            scrollFromTop, vdom, y;

        if (!me.useAnimations) {
            // me.recreateContent(increment); // todo
        } else {
            if (!me.isUpdating) {
                me.isUpdating = true;

                me.getDomRect().then(data => {
                    scrollFromTop = me.scrollNewYearFromTop && increment < 0 || !me.scrollNewYearFromTop && increment > 0;
                    vdom          = me.vdom;
                    y             = scrollFromTop ? 0 : -data.height;

                    vdom.cn.push(
                        {cls: ['neo-relative'], cn: [
                            {cls: ['neo-animation-wrapper'], cn: [
                                {cls: ['neo-content-wrapper'], cn: [
                                    {cls: ['neo-year-header'], cn: [
                                        {text: me.currentDate.getFullYear()},
                                        {cls: ['neo-nav-button', 'neo-prev-button']},
                                        {cls: ['neo-nav-button', 'neo-next-button']}
                                    ]},
                                    {cls: ['neo-months-container']}
                                ]}
                            ],
                            style: {
                                height   : `${2 * data.height}px`,
                                transform: `translateY(${y}px)`,
                                width    : `${data.width}px`
                            }}
                        ]}
                    );

                    me.createMonths(true, vdom.cn[1].cn[0].cn[0].cn[1]);
                    vdom.cn[1].cn[0].cn[scrollFromTop ? 'unshift' : 'push'](vdom.cn[0]);
                    vdom.cn.splice(0, 1);

                    me.promiseUpdate().then(() => {
                        y = scrollFromTop ? -data.height : 0;
                        vdom.cn[0].cn[0].style.transform = `translateY(${y}px)`;
                        me.update();

                        me.timeout(300).then(() => {
                            vdom.cn[0] = vdom.cn[0].cn[0].cn[scrollFromTop ? 1 : 0];
                            me.triggerVdomUpdate()
                        })
                    })
                })
            }
        }
    }

    /**
     *
     */
    createDayNamesRow() {
        let me   = this,
            date = me.currentDate, // cloned
            i    = 0,
            row  = {cls: ['neo-calendar-week'], cn: [{cls: ['neo-cell', 'neo-top-left-spacer']}]},
            day, node;

        date.setDate(me.currentDate.getDate() - me.currentDate.getDay() + me.weekStartDay);

        for (; i < 7; i++) {
            node = {
                cls : ['neo-cell', 'neo-weekday-cell'],
                text: me.intlFormat_day.format(date)
            };

            day = date.getDay();

            if (!me.showWeekends && (day === 0 || day === 6)) {
                node.removeDom = true
            }

            row.cn.push(node);

            date.setDate(date.getDate() + 1)
        }

        return row
    }

    /**
     * @param {Object} containerEl
     * @param {Date} currentDate
     * @returns {Object} vdom
     */
    createMonthContent(containerEl, currentDate) {
        let me             = this,
            {calendarStore, eventStore} = me,
            currentDay     = currentDate.getDate(),
            currentMonth   = currentDate.getMonth(),
            currentYear    = currentDate.getFullYear(),
            date           = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].clone(currentDate),
            valueDate      = me.currentDate, // cloned
            valueMonth     = valueDate.getMonth(),
            valueYear      = valueDate.getFullYear(),
            daysInMonth    = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getDaysInMonth(currentDate),
            firstDayOffset = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getFirstDayOffset(currentDate, me.weekStartDay),
            columns        = 7,
            i              = 0,
            weekDate       = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].clone(currentDate),
            cellId, config, configCls, dateDay, day, dayRecords, hasContent, j, row, rows;

        rows = (daysInMonth + firstDayOffset) / 7 > 5 ? 6 : 5;
        day  = 1 - firstDayOffset;

        date.setDate(day);
        weekDate.setDate(day + 7);

        for (; i < 6; i++) {
            row = {
                cls      : ['neo-calendar-week'],
                removeDom: i === rows && !me.sixWeeksPerMonth,

                cn: [{
                    cls      : ['neo-cell', 'neo-weeknumber-cell'],
                    removeDom: !me.showWeekNumbers,
                    text     : _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getWeekOfYear(weekDate)
                }]
            };

            weekDate.setDate(weekDate.getDate() + 7);

            for (j=0; j < columns; j++) {
                hasContent = day > 0 && day <= daysInMonth;
                cellId     = me.getCellId(currentYear, currentMonth + 1, day);
                dateDay    = date.getDay();

                config = {
                    id      : cellId,
                    cls     : hasContent ? ['neo-cell'] : ['neo-cell', 'neo-disabled'],
                    tabIndex: hasContent ? -1 : null,

                    cn: [{
                        cls : ['neo-cell-content'],
                        text: hasContent ? day : me.showDisabledDays ? date.getDate() : ''
                    }]
                };

                configCls = config.cls;

                if (dateDay === 0 || dateDay === 6) {
                    configCls.push('neo-weekend');

                    if (!me.showWeekends) {
                        config.removeDom = true
                    }
                }


                if (today.year === currentYear && today.month === currentMonth && today.day === day) {
                    config.cn[0].cls.push('neo-today')
                }

                if (valueYear === currentYear && valueMonth === currentMonth && day === currentDay) {
                    configCls.push('neo-selected')
                }

                if (!config.removeDom) {
                    dayRecords = eventStore.getDayRecords(date);
                    dayRecords = dayRecords.filter(record => calendarStore.get(record.calendarId).active);

                         if (dayRecords.length >= me.eventIndicatorHigh)   {configCls.push('neo-events-high');}
                    else if (dayRecords.length >= me.eventIndicatorMedium) {configCls.push('neo-events-medium');}
                    else if (dayRecords.length >= me.eventIndicatorLow)    {configCls.push('neo-events-low');}
                }

                row.cn.push(config);

                date.setDate(date.getDate() + 1);

                day++
            }

            containerEl.cn.push(row)
        }

        return containerEl
    }

    /**
     * @param {Boolean} [silent=false] true to update the vdom silently
     * @param {Object} [containerEl]
     */
    createMonths(silent=false, containerEl) {
        let me = this;

        if (!me.mounted) {
            me.needsEventUpdate = true
        } else {
            let currentDate    = me.currentDate, // cloned
                {vdom}         = me,
                monthContainer = containerEl || vdom.cn[0].cn[1],
                i              = 0,
                monthVdom;

            monthContainer.cn = [];

            for (; i < 12; i++) {
                currentDate.setMonth(i);
                currentDate.setDate(1);

                monthVdom =
                {cls: ['neo-month'], cn: [
                    {cls: ['neo-month-name'], text: me.intlFormat_month.format(currentDate)},
                    me.createDayNamesRow()
                ]};

                monthVdom = me.createMonthContent(monthVdom, _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].clone(currentDate));

                monthContainer.cn.push(monthVdom)
            }

            !silent && me.update()
        }
    }

    /**
     * @param {Number|String} year
     * @param {Number|String} month
     * @param {Number|String} day
     * @returns {String} id
     */
    getCellId(year, month, day) {
        day = day.toString();

        if (day.length < 2) {
            day = '0' + day
        }

        month = month.toString();

        if (month.length < 2) {
            month = '0' + month
        }

        return this.id + '__' + year + '-' + month + '-' + day
    }

    /**
     * @param {Object[]} data
     */
    onCalendarStoreLoad(data) {
        this.eventStore.getCount() > 0 && this.createMonths()
    }

    /**
     * @param {Object} data
     */
    onCalendarStoreRecordChange(data) {
        this.createMonths()
    }

    /**
     * @param {Object[]} data
     */
    onEventStoreLoad(data) {
        this.calendarStore.getCount() > 0 && this.createMonths()
    }

    /**
     * @param {Object[]} data
     */
    onEventStoreRecordChange(data) {
        this.createMonths()
    }

    /**
     * @param {Object} data
     */
    onNavButtonClick(data) {
        let me            = this,
            {currentDate} = me; // cloned

        currentDate.setFullYear(currentDate.getFullYear() + (data.path[0].cls.includes('neo-next-button') ? 1 : -1));

        me.getStateProvider().setData({currentDate})
    }

    /**
     * @param {Object} data
     */
    onWheel(data) {
        if (Math.abs(data.deltaY) > Math.abs(data.deltaX)) {
            let me            = this,
                {currentDate} = me; // cloned

            currentDate.setFullYear(currentDate.getFullYear() + (data.deltaY > 0 ? 1 : -1));

            me.getStateProvider().setData({currentDate})
        }
    }

    /**
     * Triggers a vdom update & sets isUpdating
     * @param {Boolean} [silent=false]
     * @protected
     */
    triggerVdomUpdate(silent=false) {
        if (!silent) {
            let me = this;

            me.isUpdating = true;

            me.promiseUpdate().then(() => {
                me.isUpdating = false
            })
        }
    }

    /**
     * Dynamically update the weekday rows inside each month
     * @param {String} value
     * @param {String} oldValue
     * @param {Boolean} [silent=false]
     */
    updateDayNamesRows(value, oldValue, silent=false) {
        let me = this;

        me.intlFormat_day = new Intl.DateTimeFormat(me.locale, {weekday: value});

        if (oldValue !== undefined) {
            let date   = me.currentDate, // cloned
                {vdom} = me,
                i      = 1,
                day, j, node;

            date.setDate(me.currentDate.getDate() - me.currentDate.getDay() + me.weekStartDay);

            for (; i < 8; i++) {
                for (j=0; j < 12; j++) {
                    day  = date.getDay();
                    node = vdom.cn[0].cn[1].cn[j].cn[1].cn[i];

                    node.text = me.intlFormat_day.format(date);

                    if (!me.showWeekends && (day === 0 || day === 6)) {
                        node.removeDom = true
                    } else {
                        delete node.removeDom
                    }
                }

                date.setDate(date.getDate() + 1)
            }

            !silent && me.update()
        }
    }

    /**
     *
     */
    updateHeaderYear() {
        this.vdom.cn[0].cn[0].cn[0].text = this.currentDate.getFullYear()
    }

    /**
     * Dynamically update the monthNameFormat
     * @param {String} value
     * @param {String} oldValue
     * @param {Boolean} [silent=false]
     * @protected
     */
    updateMonthNameFormat(value, oldValue, silent=false) {
        let me = this;

        me.intlFormat_month = new Intl.DateTimeFormat(me.locale, {month: value});

        if (oldValue !== undefined) {
            let {currentDate, vdom} = me,
                i                   = 0;

            for (; i < 12; i++) {
                currentDate.setMonth(i);
                currentDate.setDate(1);

                vdom.cn[0].cn[1].cn[i].cn[0].text = me.intlFormat_month.format(currentDate)
            }

            !silent && me.update()
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(YearComponent));


/***/ }

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19jYWxlbmRhcl92aWV3X1llYXJDb21wb25lbnRfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUQ7QUFDTDtBQUNDOztBQUU3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJEQUFTO0FBQ3JDO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQ0FBbUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQ0FBZ0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFD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Q0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQSxnRUFBZ0UsZUFBZTs7QUFFL0U7QUFDQTtBQUNBLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLE9BQU87QUFDMUIsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtFQUFrRSxhQUFhOztBQUUvRTtBQUNBLGlCQUFpQixtQkFBbUI7QUFDcEM7O0FBRUEsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLDZCQUE2QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jYWxlbmRhci92aWV3L1llYXJDb21wb25lbnQubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vLi4vY29tcG9uZW50L0Jhc2UubWpzJztcbmltcG9ydCBEYXRlVXRpbCAgZnJvbSAnLi4vLi4vdXRpbC9EYXRlLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgIGZyb20gJy4uLy4uL3V0aWwvQXJyYXkubWpzJztcblxuY29uc3QgdG9kYXlEYXRlID0gbmV3IERhdGUoKTtcblxuY29uc3QgdG9kYXkgPSB7XG4gICAgZGF5ICA6IHRvZGF5RGF0ZS5nZXREYXRlKCksXG4gICAgbW9udGg6IHRvZGF5RGF0ZS5nZXRNb250aCgpLFxuICAgIHllYXIgOiB0b2RheURhdGUuZ2V0RnVsbFllYXIoKVxufTtcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNhbGVuZGFyLnZpZXcuWWVhckNvbXBvbmVudFxuICogQGV4dGVuZHMgTmVvLmNvbXBvbmVudC5CYXNlXG4gKi9cbmNsYXNzIFllYXJDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNhbGVuZGFyLnZpZXcuWWVhckNvbXBvbmVudCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNhbGVuZGFyLnZpZXcuWWVhckNvbXBvbmVudCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1jYWxlbmRhci15ZWFyY29tcG9uZW50J11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWNhbGVuZGFyLXllYXJjb21wb25lbnQnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gYmluZFxuICAgICAgICAgKi9cbiAgICAgICAgYmluZDoge1xuICAgICAgICAgICAgY2FsZW5kYXJTdG9yZSAgICAgICA6ICdzdG9yZXMuY2FsZW5kYXJzJyxcbiAgICAgICAgICAgIGN1cnJlbnREYXRlICAgICAgICAgOiBkYXRhID0+IGRhdGEuY3VycmVudERhdGUsXG4gICAgICAgICAgICBldmVudFN0b3JlICAgICAgICAgIDogJ3N0b3Jlcy5ldmVudHMnLFxuICAgICAgICAgICAgbG9jYWxlICAgICAgICAgICAgICA6IGRhdGEgPT4gZGF0YS5sb2NhbGUsXG4gICAgICAgICAgICBzY3JvbGxOZXdZZWFyRnJvbVRvcDogZGF0YSA9PiBkYXRhLnNjcm9sbE5ld1llYXJGcm9tVG9wLFxuICAgICAgICAgICAgc2hvd1dlZWtlbmRzICAgICAgICA6IGRhdGEgPT4gZGF0YS5zaG93V2Vla2VuZHMsXG4gICAgICAgICAgICB3ZWVrU3RhcnREYXkgICAgICAgIDogZGF0YSA9PiBkYXRhLndlZWtTdGFydERheVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcmVzIHRoZSBsYXN0IGRhdGUgY2hhbmdlIHdoaWNoIGdvdCB0cmlnZ2VyZWQgd2hpbGUgYSB5ZWFyIHRyYW5zaXRpb24gd2FzIHJ1bm5pbmdcbiAgICAgICAgICogQG1lbWJlciB7RGF0ZXxudWxsfSBjYWNoZWRVcGRhdGU9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjYWNoZWRVcGRhdGU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCb3VuZCB0byB0aGUgc3RhdGUgcHJvdmlkZXIuXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jYWxlbmRhci5zdG9yZS5DYWxlbmRhcnN8bnVsbH0gY2FsZW5kYXJTdG9yZV89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGNhbGVuZGFyU3RvcmVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogV2lsbCBnZXQgcGFzc2VkIGZyb20gdGhlIE1haW5Db250YWluZXJcbiAgICAgICAgICogQG1lbWJlciB7RGF0ZXxudWxsfSBjdXJyZW50RGF0ZV89bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgY3VycmVudERhdGVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGZvcm1hdCBvZiB0aGUgY29sdW1uIGhlYWRlcnMuXG4gICAgICAgICAqIFZhbGlkIHZhbHVlcyBhcmU6IG5hcnJvdywgc2hvcnQgJiBsb25nXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gZGF5TmFtZUZvcm1hdF89J25hcnJvdydcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBkYXlOYW1lRm9ybWF0XzogJ25hcnJvdycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGV2ZW50SW5kaWNhdG9ySGlnaF89M1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGV2ZW50SW5kaWNhdG9ySGlnaF86IDMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGV2ZW50SW5kaWNhdG9yTG93Xz0xXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgZXZlbnRJbmRpY2F0b3JMb3dfOiAxLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBldmVudEluZGljYXRvck1lZGl1bV89MlxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGV2ZW50SW5kaWNhdG9yTWVkaXVtXzogMixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJvdW5kIHRvIHRoZSBzdGF0ZSBwcm92aWRlci5cbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNhbGVuZGFyLnN0b3JlLkV2ZW50c3xudWxsfSBldmVudFN0b3JlXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgZXZlbnRTdG9yZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtJbnRsLkRhdGVUaW1lRm9ybWF0fG51bGx9IGludGxGb3JtYXRfZGF5PW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaW50bEZvcm1hdF9kYXk6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtJbnRsLkRhdGVUaW1lRm9ybWF0fG51bGx9IGludGxGb3JtYXRfbW9udGg9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBpbnRsRm9ybWF0X21vbnRoOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgZmxhZyB0byBwcmV2ZW50IGNoYW5naW5nIHRoZSBkYXRlIHdoaWxlIGNoYW5nZSBhbmltYXRpb25zIGFyZSBzdGlsbCBydW5uaW5nXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzVXBkYXRpbmdfPWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBpc1VwZGF0aW5nXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCb3VuZCB0byB0aGUgc3RhdGUgcHJvdmlkZXIuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbG9jYWxlXz1OZW8uY29uZmlnLmxvY2FsZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGxvY2FsZV86IE5lby5jb25maWcubG9jYWxlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGZvcm1hdCBvZiB0aGUgbW9udGggaGVhZGVyIG5hbWVzLlxuICAgICAgICAgKiBWYWxpZCB2YWx1ZXMgYXJlOiBuYXJyb3csIHNob3J0ICYgbG9uZ1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG1vbnRoTmFtZUZvcm1hdF89J2xvbmcnXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbW9udGhOYW1lRm9ybWF0XzogJ2xvbmcnLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgZmxhZyB0byBzdG9yZSBpZiBjcmVhdGVNb250aHMoKSBnb3QgY2FsbGVkIHdoaWxlIG5vdCBiZWluZyBtb3VudGVkXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG5lZWRzRXZlbnRVcGRhdGU9ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbmVlZHNFdmVudFVwZGF0ZTogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY2FsZW5kYXIudmlldy5NYWluQ29udGFpbmVyfG51bGx9IG93bmVyPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgb3duZXI6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIHRvIHNjcm9sbCBuZXcgeWVhcnMgaW4gZnJvbSB0aGUgdG9wXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNjcm9sbE5ld1llYXJGcm9tVG9wPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBzY3JvbGxOZXdZZWFyRnJvbVRvcDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIHRvIHNob3cgYm9yZGVycyBmb3IgdGhlIGNhbGVuZGFyIG1vbnRoIGNlbGxzXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNob3dDZWxsQm9yZGVyc189ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzaG93Q2VsbEJvcmRlcnNfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgdG8gc2hvdyB0aGUgZGF5cyBvZiB0aGUgcHJldmlvdXMgb3IgbmV4dCBtb250aCAobm90IHNlbGVjdGFibGUpXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNob3dEaXNhYmxlZERheXNfPXRydWVcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzaG93RGlzYWJsZWREYXlzXzogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJvdW5kIHRvIHRoZSBzdGF0ZSBwcm92aWRlci5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2hvd1dlZWtlbmRzXz10cnVlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2hvd1dlZWtlbmRzXzogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgdG8gc2hvdyB0aGUgd2VlayBudW1iZXIgYXMgdGhlIGZpcnN0IGNvbHVtbiBvZiBlYWNoIG1vbnRoXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNob3dXZWVrTnVtYmVyc189dHJ1ZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHNob3dXZWVrTnVtYmVyc186IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIHRvIHNob3cgNiB3ZWVrcyBmb3IgZWFjaCBtb250aCwgc28gdGhhdCBhbGwgbW9udGhzIGhhdmUgdGhlIHNhbWUgaGVpZ2h0XG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpeFdlZWtzUGVyTW9udGhfPWZhbHNlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2l4V2Vla3NQZXJNb250aF86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSB0byB1c2Ugc2xpZGluZyBhbmltYXRpb25zXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHVzZUFuaW1hdGlvbnM9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgdXNlQW5pbWF0aW9uczogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gdmRvbVxuICAgICAgICAgKi9cbiAgICAgICAgdmRvbTpcbiAgICAgICAge2NuOiBbXG4gICAgICAgICAgICB7Y2xzOiBbJ25lby1jb250ZW50LXdyYXBwZXInXSwgY246IFtcbiAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby15ZWFyLWhlYWRlciddLCBjbjogW1xuICAgICAgICAgICAgICAgICAgICB7fSxcbiAgICAgICAgICAgICAgICAgICAge2NsczogWyduZW8tbmF2LWJ1dHRvbicsICduZW8tcHJldi1idXR0b24nXX0sXG4gICAgICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLW5hdi1idXR0b24nLCAnbmVvLW5leHQtYnV0dG9uJ119XG4gICAgICAgICAgICAgICAgXX0sXG4gICAgICAgICAgICAgICAge2NsczogWyduZW8tbW9udGhzLWNvbnRhaW5lciddfVxuICAgICAgICAgICAgXX1cbiAgICAgICAgXX0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAwLTYgPT4gU3VuLVNhdFxuICAgICAgICAgKiBCb3VuZCB0byB0aGUgc3RhdGUgcHJvdmlkZXIuXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gd2Vla1N0YXJ0RGF5Xz0wXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgd2Vla1N0YXJ0RGF5XzogMFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuYWRkRG9tTGlzdGVuZXJzKFtcbiAgICAgICAgICAgIHtjbGljazogbWUub25OYXZCdXR0b25DbGljaywgZGVsZWdhdGU6ICcubmVvLW5hdi1idXR0b24nLCBzY29wZTogbWV9LFxuICAgICAgICAgICAge3doZWVsOiBtZS5vbldoZWVsLCBzY29wZTogbWV9XG4gICAgICAgIF0pO1xuXG4gICAgICAgIGlmIChtZS5jYWxlbmRhclN0b3JlLmdldENvdW50KCkgPiAwICYmIG1lLmV2ZW50U3RvcmUuZ2V0Q291bnQoKSA+IDApIHtcbiAgICAgICAgICAgIG1lLmNyZWF0ZU1vbnRocyh0cnVlKSAvLyBzaWxlbnQgdXBkYXRlXG4gICAgICAgIH1cblxuICAgICAgICBtZS51cGRhdGVIZWFkZXJZZWFyKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGNhbGVuZGFyU3RvcmUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOZW8uY2FsZW5kYXIuc3RvcmUuQ2FsZW5kYXJzfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uY2FsZW5kYXIuc3RvcmUuQ2FsZW5kYXJzfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Q2FsZW5kYXJTdG9yZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcblxuICAgICAgICBsaXN0ZW5lcnMgPSB7XG4gICAgICAgICAgICBsb2FkICAgICAgICA6IG1lLm9uQ2FsZW5kYXJTdG9yZUxvYWQsXG4gICAgICAgICAgICByZWNvcmRDaGFuZ2U6IG1lLm9uQ2FsZW5kYXJTdG9yZVJlY29yZENoYW5nZSxcbiAgICAgICAgICAgIHNjb3BlICAgICAgIDogbWVcbiAgICAgICAgfTtcblxuICAgICAgICBvbGRWYWx1ZT8udW4obGlzdGVuZXJzKTtcbiAgICAgICAgdmFsdWUgICA/Lm9uKGxpc3RlbmVycylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGN1cnJlbnREYXRlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7RGF0ZX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0RhdGV9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Q3VycmVudERhdGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ29uc3RydWN0ZWQpIHtcbiAgICAgICAgICAgIGxldCBvbGRZZWFyID0gb2xkVmFsdWUuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgICAgICAgICB5ZWFyICAgID0gdmFsdWUgICAuZ2V0RnVsbFllYXIoKTtcblxuICAgICAgICAgICAgaWYgKHllYXIgIT09IG9sZFllYXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZVllYXIoeWVhciAtIG9sZFllYXIpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGRheU5hbWVGb3JtYXQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RGF5TmFtZUZvcm1hdCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVEYXlOYW1lc1Jvd3ModmFsdWUsIG9sZFZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZXZlbnRJbmRpY2F0b3JIaWdoIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEV2ZW50SW5kaWNhdG9ySGlnaCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmNyZWF0ZU1vbnRocygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBldmVudEluZGljYXRvckxvdyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRFdmVudEluZGljYXRvckxvdyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmNyZWF0ZU1vbnRocygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBldmVudEluZGljYXRvck1lZGl1bSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRFdmVudEluZGljYXRvck1lZGl1bSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmNyZWF0ZU1vbnRocygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBldmVudFN0b3JlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TmVvLmNhbGVuZGFyLnN0b3JlLkV2ZW50c3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLmNhbGVuZGFyLnN0b3JlLkV2ZW50c3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEV2ZW50U3RvcmUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG5cbiAgICAgICAgbGlzdGVuZXJzID0ge1xuICAgICAgICAgICAgbG9hZCAgICAgICAgOiBtZS5vbkV2ZW50U3RvcmVMb2FkLFxuICAgICAgICAgICAgcmVjb3JkQ2hhbmdlOiBtZS5vbkV2ZW50U3RvcmVSZWNvcmRDaGFuZ2UsXG4gICAgICAgICAgICBzY29wZSAgICAgICA6IG1lXG4gICAgICAgIH07XG5cbiAgICAgICAgb2xkVmFsdWU/LnVuKGxpc3RlbmVycyk7XG4gICAgICAgIHZhbHVlICAgPy5vbihsaXN0ZW5lcnMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBsb2NhbGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TG9jYWxlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAgICAgbWUudXBkYXRlRGF5TmFtZXNSb3dzKG1lLmRheU5hbWVGb3JtYXQsICcnLCB0cnVlKTtcbiAgICAgICAgICAgIG1lLnVwZGF0ZU1vbnRoTmFtZUZvcm1hdChtZS5tb250aE5hbWVGb3JtYXQsICcnKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtb250aE5hbWVGb3JtYXQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TW9udGhOYW1lRm9ybWF0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZU1vbnRoTmFtZUZvcm1hdCh2YWx1ZSwgb2xkVmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtb3VudGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAodmFsdWUgJiYgbWUubmVlZHNFdmVudFVwZGF0ZSkge1xuICAgICAgICAgICAgbWUuY3JlYXRlTW9udGhzKCk7XG4gICAgICAgICAgICBtZS5uZWVkc0V2ZW50VXBkYXRlID0gZmFsc2VcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc2hvd0NlbGxCb3JkZXJzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U2hvd0NlbGxCb3JkZXJzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgY2xzID0gdGhpcy5jbHM7XG5cbiAgICAgICAgTmVvQXJyYXlbdmFsdWUgPyAnYWRkJyA6ICdyZW1vdmUnXShjbHMsICduZW8tc2hvdy1jZWxsLWJvcmRlcnMnKTtcbiAgICAgICAgdGhpcy5jbHMgPSBjbHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNob3dXZWVrZW5kcyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNob3dXZWVrZW5kcyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHt2ZG9tfSA9IG1lLFxuICAgICAgICAgICAgICAgIGkgICAgICA9IDAsXG4gICAgICAgICAgICAgICAgaXRlbSwgaXRlbUNuLCBqLCBrLCBsZW47XG5cbiAgICAgICAgICAgIGZvciAoOyBpIDwgMTI7IGkrKykgeyAvLyBtb250aHNcbiAgICAgICAgICAgICAgICBpdGVtQ24gPSB2ZG9tLmNuWzBdLmNuWzFdLmNuW2ldLmNuO1xuICAgICAgICAgICAgICAgIGxlbiAgICA9IGl0ZW1Dbi5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGo9MTsgaiA8IGxlbjsgaisrKSB7IC8vIHdlZWtzXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaz0xOyBrIDwgODsgaysrKSB7IC8vIGRheXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBpdGVtQ25bal0uY25ba107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmNscy5pbmNsdWRlcygnbmVvLXdlZWtlbmQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgaXRlbS5yZW1vdmVEb21cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnJlbW92ZURvbSA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRyaWdnZXJzIHRoZSB2ZG9tIHVwZGF0ZVxuICAgICAgICAgICAgbWUudXBkYXRlRGF5TmFtZXNSb3dzKG1lLmRheU5hbWVGb3JtYXQsICcnKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzaG93V2Vla051bWJlcnMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTaG93V2Vla051bWJlcnModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGkgID0gMCxcbiAgICAgICAgICAgICAgICBpdGVtQ24sIGosIGxlbjtcblxuICAgICAgICAgICAgZm9yICg7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaXRlbUNuID0gbWUudmRvbS5jblswXS5jblsxXS5jbltpXS5jbjtcbiAgICAgICAgICAgICAgICBsZW4gICAgPSBpdGVtQ24ubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgZm9yIChqID0gMTsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1DbltqXS5jblswXS5yZW1vdmVEb20gPSAhdmFsdWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNpeFdlZWtzUGVyTW9udGggY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTaXhXZWVrc1Blck1vbnRoKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGRhdGUgPSBtZS5jdXJyZW50RGF0ZSwgLy8gY2xvbmVkXG4gICAgICAgICAgICAgICAgaSAgICA9IDA7XG5cbiAgICAgICAgICAgIGRhdGUuc2V0TW9udGgoMCk7XG4gICAgICAgICAgICBkYXRlLnNldERhdGUoMSk7XG5cbiAgICAgICAgICAgIGZvciAoOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgICAgIG1lLnZkb20uY25bMF0uY25bMV0uY25baV0uY25bN10ucmVtb3ZlRG9tID0gRGF0ZVV0aWwuZ2V0V2Vla3NPZk1vbnRoKGRhdGUsIG1lLndlZWtTdGFydERheSkgPT09IDUgJiYgIXZhbHVlO1xuICAgICAgICAgICAgICAgIGRhdGUuc2V0TW9udGgoZGF0ZS5nZXRNb250aCgpICsgMSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUudXBkYXRlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgd2Vla1N0YXJ0RGF5IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFdlZWtTdGFydERheSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmNyZWF0ZU1vbnRocygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgZGF5TmFtZUZvcm1hdCBjb25maWcgZ2V0cyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldERheU5hbWVGb3JtYXQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlZm9yZVNldEVudW1WYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICdkYXlOYW1lRm9ybWF0JywgRGF0ZVV0aWwucHJvdG90eXBlLmRheU5hbWVGb3JtYXRzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIG1vbnRoTmFtZUZvcm1hdCBjb25maWcgZ2V0cyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldE1vbnRoTmFtZUZvcm1hdCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ21vbnRoTmFtZUZvcm1hdCcsIERhdGVVdGlsLnByb3RvdHlwZS5tb250aE5hbWVGb3JtYXRzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3JlcyB0aGUgbGFzdCBkYXRlIGNoYW5nZSB3aGljaCBjb3VsZCBub3QgZ2V0IGFwcGxpZWQgd2hpbGUgYSB0cmFuc2l0aW9uIHdhcyBydW5uaW5nXG4gICAgICogQHBhcmFtIHtEYXRlfSBbZGF0ZT10aGlzLmN1cnJlbnREYXRlXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjYWNoZVVwZGF0ZShkYXRlPXRoaXMuY3VycmVudERhdGUpIHtcbiAgICAgICAgdGhpcy5jYWNoZWRVcGRhdGUgPSBkYXRlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluY3JlbWVudFxuICAgICAqL1xuICAgIGNoYW5nZVllYXIoaW5jcmVtZW50KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBzY3JvbGxGcm9tVG9wLCB2ZG9tLCB5O1xuXG4gICAgICAgIGlmICghbWUudXNlQW5pbWF0aW9ucykge1xuICAgICAgICAgICAgLy8gbWUucmVjcmVhdGVDb250ZW50KGluY3JlbWVudCk7IC8vIHRvZG9cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghbWUuaXNVcGRhdGluZykge1xuICAgICAgICAgICAgICAgIG1lLmlzVXBkYXRpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgbWUuZ2V0RG9tUmVjdCgpLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbEZyb21Ub3AgPSBtZS5zY3JvbGxOZXdZZWFyRnJvbVRvcCAmJiBpbmNyZW1lbnQgPCAwIHx8ICFtZS5zY3JvbGxOZXdZZWFyRnJvbVRvcCAmJiBpbmNyZW1lbnQgPiAwO1xuICAgICAgICAgICAgICAgICAgICB2ZG9tICAgICAgICAgID0gbWUudmRvbTtcbiAgICAgICAgICAgICAgICAgICAgeSAgICAgICAgICAgICA9IHNjcm9sbEZyb21Ub3AgPyAwIDogLWRhdGEuaGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgICAgIHZkb20uY24ucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLXJlbGF0aXZlJ10sIGNuOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2NsczogWyduZW8tYW5pbWF0aW9uLXdyYXBwZXInXSwgY246IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2NsczogWyduZW8tY29udGVudC13cmFwcGVyJ10sIGNuOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby15ZWFyLWhlYWRlciddLCBjbjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0ZXh0OiBtZS5jdXJyZW50RGF0ZS5nZXRGdWxsWWVhcigpfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1uYXYtYnV0dG9uJywgJ25lby1wcmV2LWJ1dHRvbiddfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1uYXYtYnV0dG9uJywgJ25lby1uZXh0LWJ1dHRvbiddfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1tb250aHMtY29udGFpbmVyJ119XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQgICA6IGAkezIgKiBkYXRhLmhlaWdodH1weGAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZVkoJHt5fXB4KWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoICAgIDogYCR7ZGF0YS53aWR0aH1weGBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgXX1cbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICBtZS5jcmVhdGVNb250aHModHJ1ZSwgdmRvbS5jblsxXS5jblswXS5jblswXS5jblsxXSk7XG4gICAgICAgICAgICAgICAgICAgIHZkb20uY25bMV0uY25bMF0uY25bc2Nyb2xsRnJvbVRvcCA/ICd1bnNoaWZ0JyA6ICdwdXNoJ10odmRvbS5jblswXSk7XG4gICAgICAgICAgICAgICAgICAgIHZkb20uY24uc3BsaWNlKDAsIDEpO1xuXG4gICAgICAgICAgICAgICAgICAgIG1lLnByb21pc2VVcGRhdGUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBzY3JvbGxGcm9tVG9wID8gLWRhdGEuaGVpZ2h0IDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZkb20uY25bMF0uY25bMF0uc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZVkoJHt5fXB4KWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS51cGRhdGUoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbWUudGltZW91dCgzMDApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZkb20uY25bMF0gPSB2ZG9tLmNuWzBdLmNuWzBdLmNuW3Njcm9sbEZyb21Ub3AgPyAxIDogMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUudHJpZ2dlclZkb21VcGRhdGUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBjcmVhdGVEYXlOYW1lc1JvdygpIHtcbiAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgZGF0ZSA9IG1lLmN1cnJlbnREYXRlLCAvLyBjbG9uZWRcbiAgICAgICAgICAgIGkgICAgPSAwLFxuICAgICAgICAgICAgcm93ICA9IHtjbHM6IFsnbmVvLWNhbGVuZGFyLXdlZWsnXSwgY246IFt7Y2xzOiBbJ25lby1jZWxsJywgJ25lby10b3AtbGVmdC1zcGFjZXInXX1dfSxcbiAgICAgICAgICAgIGRheSwgbm9kZTtcblxuICAgICAgICBkYXRlLnNldERhdGUobWUuY3VycmVudERhdGUuZ2V0RGF0ZSgpIC0gbWUuY3VycmVudERhdGUuZ2V0RGF5KCkgKyBtZS53ZWVrU3RhcnREYXkpO1xuXG4gICAgICAgIGZvciAoOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBub2RlID0ge1xuICAgICAgICAgICAgICAgIGNscyA6IFsnbmVvLWNlbGwnLCAnbmVvLXdlZWtkYXktY2VsbCddLFxuICAgICAgICAgICAgICAgIHRleHQ6IG1lLmludGxGb3JtYXRfZGF5LmZvcm1hdChkYXRlKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZGF5ID0gZGF0ZS5nZXREYXkoKTtcblxuICAgICAgICAgICAgaWYgKCFtZS5zaG93V2Vla2VuZHMgJiYgKGRheSA9PT0gMCB8fCBkYXkgPT09IDYpKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVEb20gPSB0cnVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJvdy5jbi5wdXNoKG5vZGUpO1xuXG4gICAgICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyAxKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJvd1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250YWluZXJFbFxuICAgICAqIEBwYXJhbSB7RGF0ZX0gY3VycmVudERhdGVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB2ZG9tXG4gICAgICovXG4gICAgY3JlYXRlTW9udGhDb250ZW50KGNvbnRhaW5lckVsLCBjdXJyZW50RGF0ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2NhbGVuZGFyU3RvcmUsIGV2ZW50U3RvcmV9ID0gbWUsXG4gICAgICAgICAgICBjdXJyZW50RGF5ICAgICA9IGN1cnJlbnREYXRlLmdldERhdGUoKSxcbiAgICAgICAgICAgIGN1cnJlbnRNb250aCAgID0gY3VycmVudERhdGUuZ2V0TW9udGgoKSxcbiAgICAgICAgICAgIGN1cnJlbnRZZWFyICAgID0gY3VycmVudERhdGUuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgICAgIGRhdGUgICAgICAgICAgID0gRGF0ZVV0aWwuY2xvbmUoY3VycmVudERhdGUpLFxuICAgICAgICAgICAgdmFsdWVEYXRlICAgICAgPSBtZS5jdXJyZW50RGF0ZSwgLy8gY2xvbmVkXG4gICAgICAgICAgICB2YWx1ZU1vbnRoICAgICA9IHZhbHVlRGF0ZS5nZXRNb250aCgpLFxuICAgICAgICAgICAgdmFsdWVZZWFyICAgICAgPSB2YWx1ZURhdGUuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgICAgIGRheXNJbk1vbnRoICAgID0gRGF0ZVV0aWwuZ2V0RGF5c0luTW9udGgoY3VycmVudERhdGUpLFxuICAgICAgICAgICAgZmlyc3REYXlPZmZzZXQgPSBEYXRlVXRpbC5nZXRGaXJzdERheU9mZnNldChjdXJyZW50RGF0ZSwgbWUud2Vla1N0YXJ0RGF5KSxcbiAgICAgICAgICAgIGNvbHVtbnMgICAgICAgID0gNyxcbiAgICAgICAgICAgIGkgICAgICAgICAgICAgID0gMCxcbiAgICAgICAgICAgIHdlZWtEYXRlICAgICAgID0gRGF0ZVV0aWwuY2xvbmUoY3VycmVudERhdGUpLFxuICAgICAgICAgICAgY2VsbElkLCBjb25maWcsIGNvbmZpZ0NscywgZGF0ZURheSwgZGF5LCBkYXlSZWNvcmRzLCBoYXNDb250ZW50LCBqLCByb3csIHJvd3M7XG5cbiAgICAgICAgcm93cyA9IChkYXlzSW5Nb250aCArIGZpcnN0RGF5T2Zmc2V0KSAvIDcgPiA1ID8gNiA6IDU7XG4gICAgICAgIGRheSAgPSAxIC0gZmlyc3REYXlPZmZzZXQ7XG5cbiAgICAgICAgZGF0ZS5zZXREYXRlKGRheSk7XG4gICAgICAgIHdlZWtEYXRlLnNldERhdGUoZGF5ICsgNyk7XG5cbiAgICAgICAgZm9yICg7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgICAgIHJvdyA9IHtcbiAgICAgICAgICAgICAgICBjbHMgICAgICA6IFsnbmVvLWNhbGVuZGFyLXdlZWsnXSxcbiAgICAgICAgICAgICAgICByZW1vdmVEb206IGkgPT09IHJvd3MgJiYgIW1lLnNpeFdlZWtzUGVyTW9udGgsXG5cbiAgICAgICAgICAgICAgICBjbjogW3tcbiAgICAgICAgICAgICAgICAgICAgY2xzICAgICAgOiBbJ25lby1jZWxsJywgJ25lby13ZWVrbnVtYmVyLWNlbGwnXSxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRG9tOiAhbWUuc2hvd1dlZWtOdW1iZXJzLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0ICAgICA6IERhdGVVdGlsLmdldFdlZWtPZlllYXIod2Vla0RhdGUpXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHdlZWtEYXRlLnNldERhdGUod2Vla0RhdGUuZ2V0RGF0ZSgpICsgNyk7XG5cbiAgICAgICAgICAgIGZvciAoaj0wOyBqIDwgY29sdW1uczsgaisrKSB7XG4gICAgICAgICAgICAgICAgaGFzQ29udGVudCA9IGRheSA+IDAgJiYgZGF5IDw9IGRheXNJbk1vbnRoO1xuICAgICAgICAgICAgICAgIGNlbGxJZCAgICAgPSBtZS5nZXRDZWxsSWQoY3VycmVudFllYXIsIGN1cnJlbnRNb250aCArIDEsIGRheSk7XG4gICAgICAgICAgICAgICAgZGF0ZURheSAgICA9IGRhdGUuZ2V0RGF5KCk7XG5cbiAgICAgICAgICAgICAgICBjb25maWcgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkICAgICAgOiBjZWxsSWQsXG4gICAgICAgICAgICAgICAgICAgIGNscyAgICAgOiBoYXNDb250ZW50ID8gWyduZW8tY2VsbCddIDogWyduZW8tY2VsbCcsICduZW8tZGlzYWJsZWQnXSxcbiAgICAgICAgICAgICAgICAgICAgdGFiSW5kZXg6IGhhc0NvbnRlbnQgPyAtMSA6IG51bGwsXG5cbiAgICAgICAgICAgICAgICAgICAgY246IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbHMgOiBbJ25lby1jZWxsLWNvbnRlbnQnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGhhc0NvbnRlbnQgPyBkYXkgOiBtZS5zaG93RGlzYWJsZWREYXlzID8gZGF0ZS5nZXREYXRlKCkgOiAnJ1xuICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBjb25maWdDbHMgPSBjb25maWcuY2xzO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRhdGVEYXkgPT09IDAgfHwgZGF0ZURheSA9PT0gNikge1xuICAgICAgICAgICAgICAgICAgICBjb25maWdDbHMucHVzaCgnbmVvLXdlZWtlbmQnKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIW1lLnNob3dXZWVrZW5kcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnJlbW92ZURvbSA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgaWYgKHRvZGF5LnllYXIgPT09IGN1cnJlbnRZZWFyICYmIHRvZGF5Lm1vbnRoID09PSBjdXJyZW50TW9udGggJiYgdG9kYXkuZGF5ID09PSBkYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmNuWzBdLmNscy5wdXNoKCduZW8tdG9kYXknKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVllYXIgPT09IGN1cnJlbnRZZWFyICYmIHZhbHVlTW9udGggPT09IGN1cnJlbnRNb250aCAmJiBkYXkgPT09IGN1cnJlbnREYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnQ2xzLnB1c2goJ25lby1zZWxlY3RlZCcpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFjb25maWcucmVtb3ZlRG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGRheVJlY29yZHMgPSBldmVudFN0b3JlLmdldERheVJlY29yZHMoZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGRheVJlY29yZHMgPSBkYXlSZWNvcmRzLmZpbHRlcihyZWNvcmQgPT4gY2FsZW5kYXJTdG9yZS5nZXQocmVjb3JkLmNhbGVuZGFySWQpLmFjdGl2ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF5UmVjb3Jkcy5sZW5ndGggPj0gbWUuZXZlbnRJbmRpY2F0b3JIaWdoKSAgIHtjb25maWdDbHMucHVzaCgnbmVvLWV2ZW50cy1oaWdoJyk7fVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkYXlSZWNvcmRzLmxlbmd0aCA+PSBtZS5ldmVudEluZGljYXRvck1lZGl1bSkge2NvbmZpZ0Nscy5wdXNoKCduZW8tZXZlbnRzLW1lZGl1bScpO31cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGF5UmVjb3Jkcy5sZW5ndGggPj0gbWUuZXZlbnRJbmRpY2F0b3JMb3cpICAgIHtjb25maWdDbHMucHVzaCgnbmVvLWV2ZW50cy1sb3cnKTt9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcm93LmNuLnB1c2goY29uZmlnKTtcblxuICAgICAgICAgICAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIDEpO1xuXG4gICAgICAgICAgICAgICAgZGF5KytcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGFpbmVyRWwuY24ucHVzaChyb3cpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29udGFpbmVyRWxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdIHRydWUgdG8gdXBkYXRlIHRoZSB2ZG9tIHNpbGVudGx5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb250YWluZXJFbF1cbiAgICAgKi9cbiAgICBjcmVhdGVNb250aHMoc2lsZW50PWZhbHNlLCBjb250YWluZXJFbCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUubW91bnRlZCkge1xuICAgICAgICAgICAgbWUubmVlZHNFdmVudFVwZGF0ZSA9IHRydWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50RGF0ZSAgICA9IG1lLmN1cnJlbnREYXRlLCAvLyBjbG9uZWRcbiAgICAgICAgICAgICAgICB7dmRvbX0gICAgICAgICA9IG1lLFxuICAgICAgICAgICAgICAgIG1vbnRoQ29udGFpbmVyID0gY29udGFpbmVyRWwgfHwgdmRvbS5jblswXS5jblsxXSxcbiAgICAgICAgICAgICAgICBpICAgICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICAgICAgbW9udGhWZG9tO1xuXG4gICAgICAgICAgICBtb250aENvbnRhaW5lci5jbiA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50RGF0ZS5zZXRNb250aChpKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50RGF0ZS5zZXREYXRlKDEpO1xuXG4gICAgICAgICAgICAgICAgbW9udGhWZG9tID1cbiAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1tb250aCddLCBjbjogW1xuICAgICAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1tb250aC1uYW1lJ10sIHRleHQ6IG1lLmludGxGb3JtYXRfbW9udGguZm9ybWF0KGN1cnJlbnREYXRlKX0sXG4gICAgICAgICAgICAgICAgICAgIG1lLmNyZWF0ZURheU5hbWVzUm93KClcbiAgICAgICAgICAgICAgICBdfTtcblxuICAgICAgICAgICAgICAgIG1vbnRoVmRvbSA9IG1lLmNyZWF0ZU1vbnRoQ29udGVudChtb250aFZkb20sIERhdGVVdGlsLmNsb25lKGN1cnJlbnREYXRlKSk7XG5cbiAgICAgICAgICAgICAgICBtb250aENvbnRhaW5lci5jbi5wdXNoKG1vbnRoVmRvbSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgIXNpbGVudCAmJiBtZS51cGRhdGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSB5ZWFyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBtb250aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gZGF5XG4gICAgICogQHJldHVybnMge1N0cmluZ30gaWRcbiAgICAgKi9cbiAgICBnZXRDZWxsSWQoeWVhciwgbW9udGgsIGRheSkge1xuICAgICAgICBkYXkgPSBkYXkudG9TdHJpbmcoKTtcblxuICAgICAgICBpZiAoZGF5Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIGRheSA9ICcwJyArIGRheVxuICAgICAgICB9XG5cbiAgICAgICAgbW9udGggPSBtb250aC50b1N0cmluZygpO1xuXG4gICAgICAgIGlmIChtb250aC5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICBtb250aCA9ICcwJyArIG1vbnRoXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5pZCArICdfXycgKyB5ZWFyICsgJy0nICsgbW9udGggKyAnLScgKyBkYXlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhXG4gICAgICovXG4gICAgb25DYWxlbmRhclN0b3JlTG9hZChkYXRhKSB7XG4gICAgICAgIHRoaXMuZXZlbnRTdG9yZS5nZXRDb3VudCgpID4gMCAmJiB0aGlzLmNyZWF0ZU1vbnRocygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkNhbGVuZGFyU3RvcmVSZWNvcmRDaGFuZ2UoZGF0YSkge1xuICAgICAgICB0aGlzLmNyZWF0ZU1vbnRocygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YVxuICAgICAqL1xuICAgIG9uRXZlbnRTdG9yZUxvYWQoZGF0YSkge1xuICAgICAgICB0aGlzLmNhbGVuZGFyU3RvcmUuZ2V0Q291bnQoKSA+IDAgJiYgdGhpcy5jcmVhdGVNb250aHMoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGFcbiAgICAgKi9cbiAgICBvbkV2ZW50U3RvcmVSZWNvcmRDaGFuZ2UoZGF0YSkge1xuICAgICAgICB0aGlzLmNyZWF0ZU1vbnRocygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbk5hdkJ1dHRvbkNsaWNrKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2N1cnJlbnREYXRlfSA9IG1lOyAvLyBjbG9uZWRcblxuICAgICAgICBjdXJyZW50RGF0ZS5zZXRGdWxsWWVhcihjdXJyZW50RGF0ZS5nZXRGdWxsWWVhcigpICsgKGRhdGEucGF0aFswXS5jbHMuaW5jbHVkZXMoJ25lby1uZXh0LWJ1dHRvbicpID8gMSA6IC0xKSk7XG5cbiAgICAgICAgbWUuZ2V0U3RhdGVQcm92aWRlcigpLnNldERhdGEoe2N1cnJlbnREYXRlfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uV2hlZWwoZGF0YSkge1xuICAgICAgICBpZiAoTWF0aC5hYnMoZGF0YS5kZWx0YVkpID4gTWF0aC5hYnMoZGF0YS5kZWx0YVgpKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAge2N1cnJlbnREYXRlfSA9IG1lOyAvLyBjbG9uZWRcblxuICAgICAgICAgICAgY3VycmVudERhdGUuc2V0RnVsbFllYXIoY3VycmVudERhdGUuZ2V0RnVsbFllYXIoKSArIChkYXRhLmRlbHRhWSA+IDAgPyAxIDogLTEpKTtcblxuICAgICAgICAgICAgbWUuZ2V0U3RhdGVQcm92aWRlcigpLnNldERhdGEoe2N1cnJlbnREYXRlfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJzIGEgdmRvbSB1cGRhdGUgJiBzZXRzIGlzVXBkYXRpbmdcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRyaWdnZXJWZG9tVXBkYXRlKHNpbGVudD1mYWxzZSkge1xuICAgICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAgICAgbWUuaXNVcGRhdGluZyA9IHRydWU7XG5cbiAgICAgICAgICAgIG1lLnByb21pc2VVcGRhdGUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBtZS5pc1VwZGF0aW5nID0gZmFsc2VcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEeW5hbWljYWxseSB1cGRhdGUgdGhlIHdlZWtkYXkgcm93cyBpbnNpZGUgZWFjaCBtb250aFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbGVudD1mYWxzZV1cbiAgICAgKi9cbiAgICB1cGRhdGVEYXlOYW1lc1Jvd3ModmFsdWUsIG9sZFZhbHVlLCBzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5pbnRsRm9ybWF0X2RheSA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KG1lLmxvY2FsZSwge3dlZWtkYXk6IHZhbHVlfSk7XG5cbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBkYXRlICAgPSBtZS5jdXJyZW50RGF0ZSwgLy8gY2xvbmVkXG4gICAgICAgICAgICAgICAge3Zkb219ID0gbWUsXG4gICAgICAgICAgICAgICAgaSAgICAgID0gMSxcbiAgICAgICAgICAgICAgICBkYXksIGosIG5vZGU7XG5cbiAgICAgICAgICAgIGRhdGUuc2V0RGF0ZShtZS5jdXJyZW50RGF0ZS5nZXREYXRlKCkgLSBtZS5jdXJyZW50RGF0ZS5nZXREYXkoKSArIG1lLndlZWtTdGFydERheSk7XG5cbiAgICAgICAgICAgIGZvciAoOyBpIDwgODsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChqPTA7IGogPCAxMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGRheSAgPSBkYXRlLmdldERheSgpO1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gdmRvbS5jblswXS5jblsxXS5jbltqXS5jblsxXS5jbltpXTtcblxuICAgICAgICAgICAgICAgICAgICBub2RlLnRleHQgPSBtZS5pbnRsRm9ybWF0X2RheS5mb3JtYXQoZGF0ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtZS5zaG93V2Vla2VuZHMgJiYgKGRheSA9PT0gMCB8fCBkYXkgPT09IDYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJlbW92ZURvbSA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlLnJlbW92ZURvbVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgMSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgIXNpbGVudCAmJiBtZS51cGRhdGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICB1cGRhdGVIZWFkZXJZZWFyKCkge1xuICAgICAgICB0aGlzLnZkb20uY25bMF0uY25bMF0uY25bMF0udGV4dCA9IHRoaXMuY3VycmVudERhdGUuZ2V0RnVsbFllYXIoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIER5bmFtaWNhbGx5IHVwZGF0ZSB0aGUgbW9udGhOYW1lRm9ybWF0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2lsZW50PWZhbHNlXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB1cGRhdGVNb250aE5hbWVGb3JtYXQodmFsdWUsIG9sZFZhbHVlLCBzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5pbnRsRm9ybWF0X21vbnRoID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobWUubG9jYWxlLCB7bW9udGg6IHZhbHVlfSk7XG5cbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCB7Y3VycmVudERhdGUsIHZkb219ID0gbWUsXG4gICAgICAgICAgICAgICAgaSAgICAgICAgICAgICAgICAgICA9IDA7XG5cbiAgICAgICAgICAgIGZvciAoOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnREYXRlLnNldE1vbnRoKGkpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnREYXRlLnNldERhdGUoMSk7XG5cbiAgICAgICAgICAgICAgICB2ZG9tLmNuWzBdLmNuWzFdLmNuW2ldLmNuWzBdLnRleHQgPSBtZS5pbnRsRm9ybWF0X21vbnRoLmZvcm1hdChjdXJyZW50RGF0ZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgIXNpbGVudCAmJiBtZS51cGRhdGUoKVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhZZWFyQ29tcG9uZW50KTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=