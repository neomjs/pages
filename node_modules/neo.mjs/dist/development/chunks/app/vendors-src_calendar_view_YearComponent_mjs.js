"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_calendar_view_YearComponent_mjs"],{

/***/ "./src/calendar/view/YearComponent.mjs":
/*!*********************************************!*\
  !*** ./src/calendar/view/YearComponent.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Date.mjs */ "./src/util/Date.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");




const todayDate = new Date();

const today = {
    day  : todayDate.getDate(),
    month: todayDate.getMonth(),
    year : todayDate.getFullYear()
};

/**
 * @class Neo.calendar.view.YearComponent
 * @extends Neo.component.Base
 */
class YearComponent extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.calendar.view.YearComponent'
         * @protected
         */
        className: 'Neo.calendar.view.YearComponent',
        /**
         * @member {String[]} baseCls=['neo-calendar-yearcomponent']
         */
        baseCls: ['neo-calendar-yearcomponent'],
        /**
         * @member {Object} bind
         */
        bind: {
            calendarStore       : 'stores.calendars',
            currentDate         : data => data.currentDate,
            eventStore          : 'stores.events',
            locale              : data => data.locale,
            scrollNewYearFromTop: data => data.scrollNewYearFromTop,
            showWeekends        : data => data.showWeekends,
            weekStartDay        : data => data.weekStartDay
        },
        /**
         * Stores the last date change which got triggered while a year transition was running
         * @member {Date|null} cachedUpdate=null
         * @protected
         */
        cachedUpdate: null,
        /**
         * Bound to the state provider.
         * @member {Neo.calendar.store.Calendars|null} calendarStore_=null
         */
        calendarStore_: null,
        /**
         * Will get passed from the MainContainer
         * @member {Date|null} currentDate_=null
         * @protected
         */
        currentDate_: null,
        /**
         * The format of the column headers.
         * Valid values are: narrow, short & long
         * @member {String} dayNameFormat_='narrow'
         */
        dayNameFormat_: 'narrow',
        /**
         * @member {Number} eventIndicatorHigh_=3
         */
        eventIndicatorHigh_: 3,
        /**
         * @member {Number} eventIndicatorLow_=1
         */
        eventIndicatorLow_: 1,
        /**
         * @member {Number} eventIndicatorMedium_=2
         */
        eventIndicatorMedium_: 2,
        /**
         * Bound to the state provider.
         * @member {Neo.calendar.store.Events|null} eventStore_=null
         */
        eventStore_: null,
        /**
         * @member {Intl.DateTimeFormat|null} intlFormat_day=null
         * @protected
         */
        intlFormat_day: null,
        /**
         * @member {Intl.DateTimeFormat|null} intlFormat_month=null
         * @protected
         */
        intlFormat_month: null,
        /**
         * Internal flag to prevent changing the date while change animations are still running
         * @member {Boolean} isUpdating_=false
         * @protected
         */
        isUpdating_: false,
        /**
         * Bound to the state provider.
         * @member {String} locale_=Neo.config.locale
         */
        locale_: Neo.config.locale,
        /**
         * The format of the month header names.
         * Valid values are: narrow, short & long
         * @member {String} monthNameFormat_='long'
         */
        monthNameFormat_: 'long',
        /**
         * Internal flag to store if createMonths() got called while not being mounted
         * @member {Boolean} needsEventUpdate=false
         * @protected
         */
        needsEventUpdate: false,
        /**
         * @member {Neo.calendar.view.MainContainer|null} owner=null
         * @protected
         */
        owner: null,
        /**
         * True to scroll new years in from the top
         * @member {Boolean} scrollNewYearFromTop=false
         */
        scrollNewYearFromTop: false,
        /**
         * True to show borders for the calendar month cells
         * @member {Boolean} showCellBorders_=false
         */
        showCellBorders_: false,
        /**
         * True to show the days of the previous or next month (not selectable)
         * @member {Boolean} showDisabledDays_=true
         */
        showDisabledDays_: true,
        /**
         * Bound to the state provider.
         * @member {Boolean} showWeekends_=true
         */
        showWeekends_: true,
        /**
         * True to show the week number as the first column of each month
         * @member {Boolean} showWeekNumbers_=true
         */
        showWeekNumbers_: true,
        /**
         * True to show 6 weeks for each month, so that all months have the same height
         * @member {Boolean} sixWeeksPerMonth_=false
         */
        sixWeeksPerMonth_: false,
        /**
         * True to use sliding animations
         * @member {Boolean} useAnimations=true
         */
        useAnimations: true,
        /**
         * @member {Object} vdom
         */
        vdom:
        {cn: [
            {cls: ['neo-content-wrapper'], cn: [
                {cls: ['neo-year-header'], cn: [
                    {},
                    {cls: ['neo-nav-button', 'neo-prev-button']},
                    {cls: ['neo-nav-button', 'neo-next-button']}
                ]},
                {cls: ['neo-months-container']}
            ]}
        ]},
        /**
         * 0-6 => Sun-Sat
         * Bound to the state provider.
         * @member {Number} weekStartDay_=0
         */
        weekStartDay_: 0
    }

    /**
     * @param config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.addDomListeners([
            {click: me.onNavButtonClick, delegate: '.neo-nav-button', scope: me},
            {wheel: me.onWheel, scope: me}
        ]);

        if (me.calendarStore.getCount() > 0 && me.eventStore.getCount() > 0) {
            me.createMonths(true) // silent update
        }

        me.updateHeaderYear()
    }

    /**
     * Triggered after the calendarStore config got changed
     * @param {Neo.calendar.store.Calendars|null} value
     * @param {Neo.calendar.store.Calendars|null} oldValue
     * @protected
     */
    afterSetCalendarStore(value, oldValue) {
        let me = this,

        listeners = {
            load        : me.onCalendarStoreLoad,
            recordChange: me.onCalendarStoreRecordChange,
            scope       : me
        };

        oldValue?.un(listeners);
        value   ?.on(listeners)
    }

    /**
     * Triggered after the currentDate config got changed
     * @param {Date} value
     * @param {Date} oldValue
     * @protected
     */
    afterSetCurrentDate(value, oldValue) {
        if (this.isConstructed) {
            let oldYear = oldValue.getFullYear(),
                year    = value   .getFullYear();

            if (year !== oldYear) {
                this.changeYear(year - oldYear)
            }
        }
    }

    /**
     * Triggered after the dayNameFormat config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetDayNameFormat(value, oldValue) {
        this.updateDayNamesRows(value, oldValue)
    }

    /**
     * Triggered after the eventIndicatorHigh config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetEventIndicatorHigh(value, oldValue) {
        oldValue !== undefined && this.createMonths()
    }

    /**
     * Triggered after the eventIndicatorLow config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetEventIndicatorLow(value, oldValue) {
        oldValue !== undefined && this.createMonths()
    }

    /**
     * Triggered after the eventIndicatorMedium config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetEventIndicatorMedium(value, oldValue) {
        oldValue !== undefined && this.createMonths()
    }

    /**
     * Triggered after the eventStore config got changed
     * @param {Neo.calendar.store.Events|null} value
     * @param {Neo.calendar.store.Events|null} oldValue
     * @protected
     */
    afterSetEventStore(value, oldValue) {
        let me = this,

        listeners = {
            load        : me.onEventStoreLoad,
            recordChange: me.onEventStoreRecordChange,
            scope       : me
        };

        oldValue?.un(listeners);
        value   ?.on(listeners)
    }

    /**
     * Triggered after the locale config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetLocale(value, oldValue) {
        if (oldValue !== undefined) {
            let me = this;

            me.updateDayNamesRows(me.dayNameFormat, '', true);
            me.updateMonthNameFormat(me.monthNameFormat, '')
        }
    }

    /**
     * Triggered after the monthNameFormat config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetMonthNameFormat(value, oldValue) {
        this.updateMonthNameFormat(value, oldValue)
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        let me = this;

        if (value && me.needsEventUpdate) {
            me.createMonths();
            me.needsEventUpdate = false
        }
    }

    /**
     * Triggered after the showCellBorders config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowCellBorders(value, oldValue) {
        let cls = this.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"][value ? 'add' : 'remove'](cls, 'neo-show-cell-borders');
        this.cls = cls
    }

    /**
     * Triggered after the showWeekends config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowWeekends(value, oldValue) {
        if (oldValue !== undefined) {
            let me     = this,
                {vdom} = me,
                i      = 0,
                item, itemCn, j, k, len;

            for (; i < 12; i++) { // months
                itemCn = vdom.cn[0].cn[1].cn[i].cn;
                len    = itemCn.length;

                for (j=1; j < len; j++) { // weeks
                    for (k=1; k < 8; k++) { // days
                        item = itemCn[j].cn[k];

                        if (item.cls.includes('neo-weekend')) {
                            if (value) {
                                delete item.removeDom
                            } else {
                                item.removeDom = true
                            }
                        }
                    }
                }
            }

            // triggers the vdom update
            me.updateDayNamesRows(me.dayNameFormat, '')
        }
    }

    /**
     * Triggered after the showWeekNumbers config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowWeekNumbers(value, oldValue) {
        if (oldValue !== undefined) {
            let me = this,
                i  = 0,
                itemCn, j, len;

            for (; i < 12; i++) {
                itemCn = me.vdom.cn[0].cn[1].cn[i].cn;
                len    = itemCn.length;

                for (j = 1; j < len; j++) {
                    itemCn[j].cn[0].removeDom = !value
                }
            }

            me.update()
        }
    }

    /**
     * Triggered after the sixWeeksPerMonth config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetSixWeeksPerMonth(value, oldValue) {
        if (oldValue !== undefined) {
            let me   = this,
                date = me.currentDate, // cloned
                i    = 0;

            date.setMonth(0);
            date.setDate(1);

            for (; i < 12; i++) {
                me.vdom.cn[0].cn[1].cn[i].cn[7].removeDom = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getWeeksOfMonth(date, me.weekStartDay) === 5 && !value;
                date.setMonth(date.getMonth() + 1)
            }

            me.update()
        }
    }

    /**
     * Triggered after the weekStartDay config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetWeekStartDay(value, oldValue) {
        oldValue !== undefined && this.createMonths()
    }

    /**
     * Triggered before the dayNameFormat config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetDayNameFormat(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'dayNameFormat', _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.dayNameFormats)
    }

    /**
     * Triggered before the monthNameFormat config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetMonthNameFormat(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'monthNameFormat', _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.monthNameFormats)
    }

    /**
     * Stores the last date change which could not get applied while a transition was running
     * @param {Date} [date=this.currentDate]
     * @protected
     */
    cacheUpdate(date=this.currentDate) {
        this.cachedUpdate = date
    }

    /**
     * @param {Number} increment
     */
    changeYear(increment) {
        let me = this,
            scrollFromTop, vdom, y;

        if (!me.useAnimations) {
            // me.recreateContent(increment); // todo
        } else {
            if (!me.isUpdating) {
                me.isUpdating = true;

                me.getDomRect().then(data => {
                    scrollFromTop = me.scrollNewYearFromTop && increment < 0 || !me.scrollNewYearFromTop && increment > 0;
                    vdom          = me.vdom;
                    y             = scrollFromTop ? 0 : -data.height;

                    vdom.cn.push(
                        {cls: ['neo-relative'], cn: [
                            {cls: ['neo-animation-wrapper'], cn: [
                                {cls: ['neo-content-wrapper'], cn: [
                                    {cls: ['neo-year-header'], cn: [
                                        {html: me.currentDate.getFullYear()},
                                        {cls: ['neo-nav-button', 'neo-prev-button']},
                                        {cls: ['neo-nav-button', 'neo-next-button']}
                                    ]},
                                    {cls: ['neo-months-container']}
                                ]}
                            ],
                            style: {
                                height   : `${2 * data.height}px`,
                                transform: `translateY(${y}px)`,
                                width    : `${data.width}px`
                            }}
                        ]}
                    );

                    me.createMonths(true, vdom.cn[1].cn[0].cn[0].cn[1]);
                    vdom.cn[1].cn[0].cn[scrollFromTop ? 'unshift' : 'push'](vdom.cn[0]);
                    vdom.cn.splice(0, 1);

                    me.promiseUpdate(vdom).then(() => {
                        y = scrollFromTop ? -data.height : 0;
                        vdom.cn[0].cn[0].style.transform = `translateY(${y}px)`;
                        me.update();

                        me.timeout(300).then(() => {
                            vdom.cn[0] = vdom.cn[0].cn[0].cn[scrollFromTop ? 1 : 0];
                            me.triggerVdomUpdate()
                        })
                    })
                })
            }
        }
    }

    /**
     *
     */
    createDayNamesRow() {
        let me   = this,
            date = me.currentDate, // cloned
            i    = 0,
            row  = {cls: ['neo-calendar-week'], cn: [{cls: ['neo-cell', 'neo-top-left-spacer']}]},
            day, node;

        date.setDate(me.currentDate.getDate() - me.currentDate.getDay() + me.weekStartDay);

        for (; i < 7; i++) {
            node = {
                cls : ['neo-cell', 'neo-weekday-cell'],
                html: me.intlFormat_day.format(date)
            };

            day = date.getDay();

            if (!me.showWeekends && (day === 0 || day === 6)) {
                node.removeDom = true
            }

            row.cn.push(node);

            date.setDate(date.getDate() + 1)
        }

        return row
    }

    /**
     * @param {Object} containerEl
     * @param {Date} currentDate
     * @returns {Object} vdom
     */
    createMonthContent(containerEl, currentDate) {
        let me             = this,
            {calendarStore, eventStore} = me,
            currentDay     = currentDate.getDate(),
            currentMonth   = currentDate.getMonth(),
            currentYear    = currentDate.getFullYear(),
            date           = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].clone(currentDate),
            valueDate      = me.currentDate, // cloned
            valueMonth     = valueDate.getMonth(),
            valueYear      = valueDate.getFullYear(),
            daysInMonth    = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getDaysInMonth(currentDate),
            firstDayOffset = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getFirstDayOffset(currentDate, me.weekStartDay),
            columns        = 7,
            i              = 0,
            weekDate       = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].clone(currentDate),
            cellId, config, configCls, dateDay, day, dayRecords, hasContent, j, row, rows;

        rows = (daysInMonth + firstDayOffset) / 7 > 5 ? 6 : 5;
        day  = 1 - firstDayOffset;

        date.setDate(day);
        weekDate.setDate(day + 7);

        for (; i < 6; i++) {
            row = {
                cls      : ['neo-calendar-week'],
                removeDom: i === rows && !me.sixWeeksPerMonth,

                cn: [{
                    cls      : ['neo-cell', 'neo-weeknumber-cell'],
                    html     : _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getWeekOfYear(weekDate),
                    removeDom: !me.showWeekNumbers
                }]
            };

            weekDate.setDate(weekDate.getDate() + 7);

            for (j=0; j < columns; j++) {
                hasContent = day > 0 && day <= daysInMonth;
                cellId     = me.getCellId(currentYear, currentMonth + 1, day);
                dateDay    = date.getDay();

                config = {
                    id      : cellId,
                    cls     : hasContent ? ['neo-cell'] : ['neo-cell', 'neo-disabled'],
                    tabIndex: hasContent ? -1 : null,

                    cn: [{
                        cls : ['neo-cell-content'],
                        html: hasContent ? day : me.showDisabledDays ? date.getDate() : ''
                    }]
                };

                configCls = config.cls;

                if (dateDay === 0 || dateDay === 6) {
                    configCls.push('neo-weekend');

                    if (!me.showWeekends) {
                        config.removeDom = true
                    }
                }


                if (today.year === currentYear && today.month === currentMonth && today.day === day) {
                    config.cn[0].cls.push('neo-today')
                }

                if (valueYear === currentYear && valueMonth === currentMonth && day === currentDay) {
                    configCls.push('neo-selected')
                }

                if (!config.removeDom) {
                    dayRecords = eventStore.getDayRecords(date);
                    dayRecords = dayRecords.filter(record => calendarStore.get(record.calendarId).active);

                         if (dayRecords.length >= me.eventIndicatorHigh)   {configCls.push('neo-events-high');}
                    else if (dayRecords.length >= me.eventIndicatorMedium) {configCls.push('neo-events-medium');}
                    else if (dayRecords.length >= me.eventIndicatorLow)    {configCls.push('neo-events-low');}
                }

                row.cn.push(config);

                date.setDate(date.getDate() + 1);

                day++
            }

            containerEl.cn.push(row)
        }

        return containerEl
    }

    /**
     * @param {Boolean} [silent=false] true to update the vdom silently
     * @param {Object} [containerEl]
     */
    createMonths(silent=false, containerEl) {
        let me = this;

        if (!me.mounted) {
            me.needsEventUpdate = true
        } else {
            let currentDate    = me.currentDate, // cloned
                {vdom}         = me,
                monthContainer = containerEl || vdom.cn[0].cn[1],
                i              = 0,
                monthVdom;

            monthContainer.cn = [];

            for (; i < 12; i++) {
                currentDate.setMonth(i);
                currentDate.setDate(1);

                monthVdom =
                {cls: ['neo-month'], cn: [
                    {cls: ['neo-month-name'], html: me.intlFormat_month.format(currentDate)},
                    me.createDayNamesRow()
                ]};

                monthVdom = me.createMonthContent(monthVdom, _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].clone(currentDate));

                monthContainer.cn.push(monthVdom)
            }

            !silent && me.update()
        }
    }

    /**
     * @param {Number|String} year
     * @param {Number|String} month
     * @param {Number|String} day
     * @returns {String} id
     */
    getCellId(year, month, day) {
        day = day.toString();

        if (day.length < 2) {
            day = '0' + day
        }

        month = month.toString();

        if (month.length < 2) {
            month = '0' + month
        }

        return this.id + '__' + year + '-' + month + '-' + day
    }

    /**
     * @param {Object[]} data
     */
    onCalendarStoreLoad(data) {
        this.eventStore.getCount() > 0 && this.createMonths()
    }

    /**
     * @param {Object} data
     */
    onCalendarStoreRecordChange(data) {
        this.createMonths()
    }

    /**
     * @param {Object[]} data
     */
    onEventStoreLoad(data) {
        this.calendarStore.getCount() > 0 && this.createMonths()
    }

    /**
     * @param {Object[]} data
     */
    onEventStoreRecordChange(data) {
        this.createMonths()
    }

    /**
     * @param {Object} data
     */
    onNavButtonClick(data) {
        let me            = this,
            {currentDate} = me; // cloned

        currentDate.setFullYear(currentDate.getFullYear() + (data.path[0].cls.includes('neo-next-button') ? 1 : -1));

        me.currentDate = currentDate
    }

    /**
     * @param {Object} data
     */
    onWheel(data) {
        if (Math.abs(data.deltaY) > Math.abs(data.deltaX)) {
            let me            = this,
                {currentDate} = me; // cloned

            currentDate.setFullYear(currentDate.getFullYear() + (data.deltaY > 0 ? 1 : -1));

            me.currentDate = currentDate
        }
    }

    /**
     * Triggers a vdom update & sets isUpdating
     * @param {Boolean} [silent=false]
     * @protected
     */
    triggerVdomUpdate(silent=false) {
        if (!silent) {
            let me = this;

            me.isUpdating = true;

            me.promiseUpdate(me.vdom).then(() => {
                me.isUpdating = false
            })
        }
    }

    /**
     * Dynamically update the weekday rows inside each month
     * @param {String} value
     * @param {String} oldValue
     * @param {Boolean} [silent=false]
     */
    updateDayNamesRows(value, oldValue, silent=false) {
        let me = this;

        me.intlFormat_day = new Intl.DateTimeFormat(me.locale, {weekday: value});

        if (oldValue !== undefined) {
            let date   = me.currentDate, // cloned
                {vdom} = me,
                i      = 1,
                day, j, node;

            date.setDate(me.currentDate.getDate() - me.currentDate.getDay() + me.weekStartDay);

            for (; i < 8; i++) {
                for (j=0; j < 12; j++) {
                    day  = date.getDay();
                    node = vdom.cn[0].cn[1].cn[j].cn[1].cn[i];

                    node.html = me.intlFormat_day.format(date);

                    if (!me.showWeekends && (day === 0 || day === 6)) {
                        node.removeDom = true
                    } else {
                        delete node.removeDom
                    }
                }

                date.setDate(date.getDate() + 1)
            }

            !silent && me.update()
        }
    }

    /**
     *
     */
    updateHeaderYear() {
        this.vdom.cn[0].cn[0].cn[0].html = this.currentDate.getFullYear()
    }

    /**
     * Dynamically update the monthNameFormat
     * @param {String} value
     * @param {String} oldValue
     * @param {Boolean} [silent=false]
     * @protected
     */
    updateMonthNameFormat(value, oldValue, silent=false) {
        let me = this;

        me.intlFormat_month = new Intl.DateTimeFormat(me.locale, {month: value});

        if (oldValue !== undefined) {
            let {currentDate, vdom} = me,
                i                   = 0;

            for (; i < 12; i++) {
                currentDate.setMonth(i);
                currentDate.setDate(1);

                vdom.cn[0].cn[1].cn[i].cn[0].html = me.intlFormat_month.format(currentDate)
            }

            !silent && me.update()
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(YearComponent));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19jYWxlbmRhcl92aWV3X1llYXJDb21wb25lbnRfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUQ7QUFDTDtBQUNDOztBQUU3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJEQUFTO0FBQ3JDO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQ0FBbUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQ0FBZ0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNB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O0FBQ0EsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsT0FBTztBQUMxQiwwQkFBMEIsUUFBUTtBQUNsQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0VBQWtFLGFBQWE7O0FBRS9FO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQzs7QUFFQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsNkJBQTZCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NhbGVuZGFyL3ZpZXcvWWVhckNvbXBvbmVudC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi8uLi9jb21wb25lbnQvQmFzZS5tanMnO1xuaW1wb3J0IERhdGVVdGlsICBmcm9tICcuLi8uLi91dGlsL0RhdGUubWpzJztcbmltcG9ydCBOZW9BcnJheSAgZnJvbSAnLi4vLi4vdXRpbC9BcnJheS5tanMnO1xuXG5jb25zdCB0b2RheURhdGUgPSBuZXcgRGF0ZSgpO1xuXG5jb25zdCB0b2RheSA9IHtcbiAgICBkYXkgIDogdG9kYXlEYXRlLmdldERhdGUoKSxcbiAgICBtb250aDogdG9kYXlEYXRlLmdldE1vbnRoKCksXG4gICAgeWVhciA6IHRvZGF5RGF0ZS5nZXRGdWxsWWVhcigpXG59O1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uY2FsZW5kYXIudmlldy5ZZWFyQ29tcG9uZW50XG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqL1xuY2xhc3MgWWVhckNvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY2FsZW5kYXIudmlldy5ZZWFyQ29tcG9uZW50J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY2FsZW5kYXIudmlldy5ZZWFyQ29tcG9uZW50JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWNhbGVuZGFyLXllYXJjb21wb25lbnQnXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tY2FsZW5kYXIteWVhcmNvbXBvbmVudCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBiaW5kXG4gICAgICAgICAqL1xuICAgICAgICBiaW5kOiB7XG4gICAgICAgICAgICBjYWxlbmRhclN0b3JlICAgICAgIDogJ3N0b3Jlcy5jYWxlbmRhcnMnLFxuICAgICAgICAgICAgY3VycmVudERhdGUgICAgICAgICA6IGRhdGEgPT4gZGF0YS5jdXJyZW50RGF0ZSxcbiAgICAgICAgICAgIGV2ZW50U3RvcmUgICAgICAgICAgOiAnc3RvcmVzLmV2ZW50cycsXG4gICAgICAgICAgICBsb2NhbGUgICAgICAgICAgICAgIDogZGF0YSA9PiBkYXRhLmxvY2FsZSxcbiAgICAgICAgICAgIHNjcm9sbE5ld1llYXJGcm9tVG9wOiBkYXRhID0+IGRhdGEuc2Nyb2xsTmV3WWVhckZyb21Ub3AsXG4gICAgICAgICAgICBzaG93V2Vla2VuZHMgICAgICAgIDogZGF0YSA9PiBkYXRhLnNob3dXZWVrZW5kcyxcbiAgICAgICAgICAgIHdlZWtTdGFydERheSAgICAgICAgOiBkYXRhID0+IGRhdGEud2Vla1N0YXJ0RGF5XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9yZXMgdGhlIGxhc3QgZGF0ZSBjaGFuZ2Ugd2hpY2ggZ290IHRyaWdnZXJlZCB3aGlsZSBhIHllYXIgdHJhbnNpdGlvbiB3YXMgcnVubmluZ1xuICAgICAgICAgKiBAbWVtYmVyIHtEYXRlfG51bGx9IGNhY2hlZFVwZGF0ZT1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNhY2hlZFVwZGF0ZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJvdW5kIHRvIHRoZSBzdGF0ZSBwcm92aWRlci5cbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNhbGVuZGFyLnN0b3JlLkNhbGVuZGFyc3xudWxsfSBjYWxlbmRhclN0b3JlXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBjYWxlbmRhclN0b3JlXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdpbGwgZ2V0IHBhc3NlZCBmcm9tIHRoZSBNYWluQ29udGFpbmVyXG4gICAgICAgICAqIEBtZW1iZXIge0RhdGV8bnVsbH0gY3VycmVudERhdGVfPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY3VycmVudERhdGVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGZvcm1hdCBvZiB0aGUgY29sdW1uIGhlYWRlcnMuXG4gICAgICAgICAqIFZhbGlkIHZhbHVlcyBhcmU6IG5hcnJvdywgc2hvcnQgJiBsb25nXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gZGF5TmFtZUZvcm1hdF89J25hcnJvdydcbiAgICAgICAgICovXG4gICAgICAgIGRheU5hbWVGb3JtYXRfOiAnbmFycm93JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gZXZlbnRJbmRpY2F0b3JIaWdoXz0zXG4gICAgICAgICAqL1xuICAgICAgICBldmVudEluZGljYXRvckhpZ2hfOiAzLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBldmVudEluZGljYXRvckxvd189MVxuICAgICAgICAgKi9cbiAgICAgICAgZXZlbnRJbmRpY2F0b3JMb3dfOiAxLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBldmVudEluZGljYXRvck1lZGl1bV89MlxuICAgICAgICAgKi9cbiAgICAgICAgZXZlbnRJbmRpY2F0b3JNZWRpdW1fOiAyLFxuICAgICAgICAvKipcbiAgICAgICAgICogQm91bmQgdG8gdGhlIHN0YXRlIHByb3ZpZGVyLlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY2FsZW5kYXIuc3RvcmUuRXZlbnRzfG51bGx9IGV2ZW50U3RvcmVfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGV2ZW50U3RvcmVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7SW50bC5EYXRlVGltZUZvcm1hdHxudWxsfSBpbnRsRm9ybWF0X2RheT1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGludGxGb3JtYXRfZGF5OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7SW50bC5EYXRlVGltZUZvcm1hdHxudWxsfSBpbnRsRm9ybWF0X21vbnRoPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaW50bEZvcm1hdF9tb250aDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGZsYWcgdG8gcHJldmVudCBjaGFuZ2luZyB0aGUgZGF0ZSB3aGlsZSBjaGFuZ2UgYW5pbWF0aW9ucyBhcmUgc3RpbGwgcnVubmluZ1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc1VwZGF0aW5nXz1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBpc1VwZGF0aW5nXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCb3VuZCB0byB0aGUgc3RhdGUgcHJvdmlkZXIuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbG9jYWxlXz1OZW8uY29uZmlnLmxvY2FsZVxuICAgICAgICAgKi9cbiAgICAgICAgbG9jYWxlXzogTmVvLmNvbmZpZy5sb2NhbGUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZm9ybWF0IG9mIHRoZSBtb250aCBoZWFkZXIgbmFtZXMuXG4gICAgICAgICAqIFZhbGlkIHZhbHVlcyBhcmU6IG5hcnJvdywgc2hvcnQgJiBsb25nXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbW9udGhOYW1lRm9ybWF0Xz0nbG9uZydcbiAgICAgICAgICovXG4gICAgICAgIG1vbnRoTmFtZUZvcm1hdF86ICdsb25nJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGZsYWcgdG8gc3RvcmUgaWYgY3JlYXRlTW9udGhzKCkgZ290IGNhbGxlZCB3aGlsZSBub3QgYmVpbmcgbW91bnRlZFxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBuZWVkc0V2ZW50VXBkYXRlPWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG5lZWRzRXZlbnRVcGRhdGU6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNhbGVuZGFyLnZpZXcuTWFpbkNvbnRhaW5lcnxudWxsfSBvd25lcj1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG93bmVyOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSB0byBzY3JvbGwgbmV3IHllYXJzIGluIGZyb20gdGhlIHRvcFxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzY3JvbGxOZXdZZWFyRnJvbVRvcD1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgc2Nyb2xsTmV3WWVhckZyb21Ub3A6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSB0byBzaG93IGJvcmRlcnMgZm9yIHRoZSBjYWxlbmRhciBtb250aCBjZWxsc1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaG93Q2VsbEJvcmRlcnNfPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBzaG93Q2VsbEJvcmRlcnNfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgdG8gc2hvdyB0aGUgZGF5cyBvZiB0aGUgcHJldmlvdXMgb3IgbmV4dCBtb250aCAobm90IHNlbGVjdGFibGUpXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNob3dEaXNhYmxlZERheXNfPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIHNob3dEaXNhYmxlZERheXNfOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQm91bmQgdG8gdGhlIHN0YXRlIHByb3ZpZGVyLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaG93V2Vla2VuZHNfPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIHNob3dXZWVrZW5kc186IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIHRvIHNob3cgdGhlIHdlZWsgbnVtYmVyIGFzIHRoZSBmaXJzdCBjb2x1bW4gb2YgZWFjaCBtb250aFxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaG93V2Vla051bWJlcnNfPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIHNob3dXZWVrTnVtYmVyc186IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIHRvIHNob3cgNiB3ZWVrcyBmb3IgZWFjaCBtb250aCwgc28gdGhhdCBhbGwgbW9udGhzIGhhdmUgdGhlIHNhbWUgaGVpZ2h0XG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpeFdlZWtzUGVyTW9udGhfPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBzaXhXZWVrc1Blck1vbnRoXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIHRvIHVzZSBzbGlkaW5nIGFuaW1hdGlvbnNcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gdXNlQW5pbWF0aW9ucz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICB1c2VBbmltYXRpb25zOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSB2ZG9tXG4gICAgICAgICAqL1xuICAgICAgICB2ZG9tOlxuICAgICAgICB7Y246IFtcbiAgICAgICAgICAgIHtjbHM6IFsnbmVvLWNvbnRlbnQtd3JhcHBlciddLCBjbjogW1xuICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLXllYXItaGVhZGVyJ10sIGNuOiBbXG4gICAgICAgICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1uYXYtYnV0dG9uJywgJ25lby1wcmV2LWJ1dHRvbiddfSxcbiAgICAgICAgICAgICAgICAgICAge2NsczogWyduZW8tbmF2LWJ1dHRvbicsICduZW8tbmV4dC1idXR0b24nXX1cbiAgICAgICAgICAgICAgICBdfSxcbiAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1tb250aHMtY29udGFpbmVyJ119XG4gICAgICAgICAgICBdfVxuICAgICAgICBdfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIDAtNiA9PiBTdW4tU2F0XG4gICAgICAgICAqIEJvdW5kIHRvIHRoZSBzdGF0ZSBwcm92aWRlci5cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSB3ZWVrU3RhcnREYXlfPTBcbiAgICAgICAgICovXG4gICAgICAgIHdlZWtTdGFydERheV86IDBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmFkZERvbUxpc3RlbmVycyhbXG4gICAgICAgICAgICB7Y2xpY2s6IG1lLm9uTmF2QnV0dG9uQ2xpY2ssIGRlbGVnYXRlOiAnLm5lby1uYXYtYnV0dG9uJywgc2NvcGU6IG1lfSxcbiAgICAgICAgICAgIHt3aGVlbDogbWUub25XaGVlbCwgc2NvcGU6IG1lfVxuICAgICAgICBdKTtcblxuICAgICAgICBpZiAobWUuY2FsZW5kYXJTdG9yZS5nZXRDb3VudCgpID4gMCAmJiBtZS5ldmVudFN0b3JlLmdldENvdW50KCkgPiAwKSB7XG4gICAgICAgICAgICBtZS5jcmVhdGVNb250aHModHJ1ZSkgLy8gc2lsZW50IHVwZGF0ZVxuICAgICAgICB9XG5cbiAgICAgICAgbWUudXBkYXRlSGVhZGVyWWVhcigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBjYWxlbmRhclN0b3JlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TmVvLmNhbGVuZGFyLnN0b3JlLkNhbGVuZGFyc3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLmNhbGVuZGFyLnN0b3JlLkNhbGVuZGFyc3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldENhbGVuZGFyU3RvcmUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG5cbiAgICAgICAgbGlzdGVuZXJzID0ge1xuICAgICAgICAgICAgbG9hZCAgICAgICAgOiBtZS5vbkNhbGVuZGFyU3RvcmVMb2FkLFxuICAgICAgICAgICAgcmVjb3JkQ2hhbmdlOiBtZS5vbkNhbGVuZGFyU3RvcmVSZWNvcmRDaGFuZ2UsXG4gICAgICAgICAgICBzY29wZSAgICAgICA6IG1lXG4gICAgICAgIH07XG5cbiAgICAgICAgb2xkVmFsdWU/LnVuKGxpc3RlbmVycyk7XG4gICAgICAgIHZhbHVlICAgPy5vbihsaXN0ZW5lcnMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBjdXJyZW50RGF0ZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0RhdGV9IHZhbHVlXG4gICAgICogQHBhcmFtIHtEYXRlfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEN1cnJlbnREYXRlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5pc0NvbnN0cnVjdGVkKSB7XG4gICAgICAgICAgICBsZXQgb2xkWWVhciA9IG9sZFZhbHVlLmdldEZ1bGxZZWFyKCksXG4gICAgICAgICAgICAgICAgeWVhciAgICA9IHZhbHVlICAgLmdldEZ1bGxZZWFyKCk7XG5cbiAgICAgICAgICAgIGlmICh5ZWFyICE9PSBvbGRZZWFyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VZZWFyKHllYXIgLSBvbGRZZWFyKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBkYXlOYW1lRm9ybWF0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldERheU5hbWVGb3JtYXQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRGF5TmFtZXNSb3dzKHZhbHVlLCBvbGRWYWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGV2ZW50SW5kaWNhdG9ySGlnaCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRFdmVudEluZGljYXRvckhpZ2godmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5jcmVhdGVNb250aHMoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZXZlbnRJbmRpY2F0b3JMb3cgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RXZlbnRJbmRpY2F0b3JMb3codmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5jcmVhdGVNb250aHMoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZXZlbnRJbmRpY2F0b3JNZWRpdW0gY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RXZlbnRJbmRpY2F0b3JNZWRpdW0odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5jcmVhdGVNb250aHMoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZXZlbnRTdG9yZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge05lby5jYWxlbmRhci5zdG9yZS5FdmVudHN8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5jYWxlbmRhci5zdG9yZS5FdmVudHN8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRFdmVudFN0b3JlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuXG4gICAgICAgIGxpc3RlbmVycyA9IHtcbiAgICAgICAgICAgIGxvYWQgICAgICAgIDogbWUub25FdmVudFN0b3JlTG9hZCxcbiAgICAgICAgICAgIHJlY29yZENoYW5nZTogbWUub25FdmVudFN0b3JlUmVjb3JkQ2hhbmdlLFxuICAgICAgICAgICAgc2NvcGUgICAgICAgOiBtZVxuICAgICAgICB9O1xuXG4gICAgICAgIG9sZFZhbHVlPy51bihsaXN0ZW5lcnMpO1xuICAgICAgICB2YWx1ZSAgID8ub24obGlzdGVuZXJzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbG9jYWxlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldExvY2FsZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIG1lLnVwZGF0ZURheU5hbWVzUm93cyhtZS5kYXlOYW1lRm9ybWF0LCAnJywgdHJ1ZSk7XG4gICAgICAgICAgICBtZS51cGRhdGVNb250aE5hbWVGb3JtYXQobWUubW9udGhOYW1lRm9ybWF0LCAnJylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbW9udGhOYW1lRm9ybWF0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vbnRoTmFtZUZvcm1hdCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVNb250aE5hbWVGb3JtYXQodmFsdWUsIG9sZFZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbW91bnRlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHZhbHVlICYmIG1lLm5lZWRzRXZlbnRVcGRhdGUpIHtcbiAgICAgICAgICAgIG1lLmNyZWF0ZU1vbnRocygpO1xuICAgICAgICAgICAgbWUubmVlZHNFdmVudFVwZGF0ZSA9IGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNob3dDZWxsQm9yZGVycyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNob3dDZWxsQm9yZGVycyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IGNscyA9IHRoaXMuY2xzO1xuXG4gICAgICAgIE5lb0FycmF5W3ZhbHVlID8gJ2FkZCcgOiAncmVtb3ZlJ10oY2xzLCAnbmVvLXNob3ctY2VsbC1ib3JkZXJzJyk7XG4gICAgICAgIHRoaXMuY2xzID0gY2xzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzaG93V2Vla2VuZHMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTaG93V2Vla2VuZHModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICB7dmRvbX0gPSBtZSxcbiAgICAgICAgICAgICAgICBpICAgICAgPSAwLFxuICAgICAgICAgICAgICAgIGl0ZW0sIGl0ZW1DbiwgaiwgaywgbGVuO1xuXG4gICAgICAgICAgICBmb3IgKDsgaSA8IDEyOyBpKyspIHsgLy8gbW9udGhzXG4gICAgICAgICAgICAgICAgaXRlbUNuID0gdmRvbS5jblswXS5jblsxXS5jbltpXS5jbjtcbiAgICAgICAgICAgICAgICBsZW4gICAgPSBpdGVtQ24ubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgZm9yIChqPTE7IGogPCBsZW47IGorKykgeyAvLyB3ZWVrc1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGs9MTsgayA8IDg7IGsrKykgeyAvLyBkYXlzXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0gaXRlbUNuW2pdLmNuW2tdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5jbHMuaW5jbHVkZXMoJ25lby13ZWVrZW5kJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGl0ZW0ucmVtb3ZlRG9tXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5yZW1vdmVEb20gPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0cmlnZ2VycyB0aGUgdmRvbSB1cGRhdGVcbiAgICAgICAgICAgIG1lLnVwZGF0ZURheU5hbWVzUm93cyhtZS5kYXlOYW1lRm9ybWF0LCAnJylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc2hvd1dlZWtOdW1iZXJzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U2hvd1dlZWtOdW1iZXJzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgICAgICBpICA9IDAsXG4gICAgICAgICAgICAgICAgaXRlbUNuLCBqLCBsZW47XG5cbiAgICAgICAgICAgIGZvciAoOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgICAgIGl0ZW1DbiA9IG1lLnZkb20uY25bMF0uY25bMV0uY25baV0uY247XG4gICAgICAgICAgICAgICAgbGVuICAgID0gaXRlbUNuLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDE7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtQ25bal0uY25bMF0ucmVtb3ZlRG9tID0gIXZhbHVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS51cGRhdGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzaXhXZWVrc1Blck1vbnRoIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U2l4V2Vla3NQZXJNb250aCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBkYXRlID0gbWUuY3VycmVudERhdGUsIC8vIGNsb25lZFxuICAgICAgICAgICAgICAgIGkgICAgPSAwO1xuXG4gICAgICAgICAgICBkYXRlLnNldE1vbnRoKDApO1xuICAgICAgICAgICAgZGF0ZS5zZXREYXRlKDEpO1xuXG4gICAgICAgICAgICBmb3IgKDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtZS52ZG9tLmNuWzBdLmNuWzFdLmNuW2ldLmNuWzddLnJlbW92ZURvbSA9IERhdGVVdGlsLmdldFdlZWtzT2ZNb250aChkYXRlLCBtZS53ZWVrU3RhcnREYXkpID09PSA1ICYmICF2YWx1ZTtcbiAgICAgICAgICAgICAgICBkYXRlLnNldE1vbnRoKGRhdGUuZ2V0TW9udGgoKSArIDEpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHdlZWtTdGFydERheSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRXZWVrU3RhcnREYXkodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5jcmVhdGVNb250aHMoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGRheU5hbWVGb3JtYXQgY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXREYXlOYW1lRm9ybWF0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnZGF5TmFtZUZvcm1hdCcsIERhdGVVdGlsLnByb3RvdHlwZS5kYXlOYW1lRm9ybWF0cylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBtb250aE5hbWVGb3JtYXQgY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRNb250aE5hbWVGb3JtYXQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlZm9yZVNldEVudW1WYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICdtb250aE5hbWVGb3JtYXQnLCBEYXRlVXRpbC5wcm90b3R5cGUubW9udGhOYW1lRm9ybWF0cylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdG9yZXMgdGhlIGxhc3QgZGF0ZSBjaGFuZ2Ugd2hpY2ggY291bGQgbm90IGdldCBhcHBsaWVkIHdoaWxlIGEgdHJhbnNpdGlvbiB3YXMgcnVubmluZ1xuICAgICAqIEBwYXJhbSB7RGF0ZX0gW2RhdGU9dGhpcy5jdXJyZW50RGF0ZV1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY2FjaGVVcGRhdGUoZGF0ZT10aGlzLmN1cnJlbnREYXRlKSB7XG4gICAgICAgIHRoaXMuY2FjaGVkVXBkYXRlID0gZGF0ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmNyZW1lbnRcbiAgICAgKi9cbiAgICBjaGFuZ2VZZWFyKGluY3JlbWVudCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgc2Nyb2xsRnJvbVRvcCwgdmRvbSwgeTtcblxuICAgICAgICBpZiAoIW1lLnVzZUFuaW1hdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIG1lLnJlY3JlYXRlQ29udGVudChpbmNyZW1lbnQpOyAvLyB0b2RvXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIW1lLmlzVXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICBtZS5pc1VwZGF0aW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIG1lLmdldERvbVJlY3QoKS50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxGcm9tVG9wID0gbWUuc2Nyb2xsTmV3WWVhckZyb21Ub3AgJiYgaW5jcmVtZW50IDwgMCB8fCAhbWUuc2Nyb2xsTmV3WWVhckZyb21Ub3AgJiYgaW5jcmVtZW50ID4gMDtcbiAgICAgICAgICAgICAgICAgICAgdmRvbSAgICAgICAgICA9IG1lLnZkb207XG4gICAgICAgICAgICAgICAgICAgIHkgICAgICAgICAgICAgPSBzY3JvbGxGcm9tVG9wID8gMCA6IC1kYXRhLmhlaWdodDtcblxuICAgICAgICAgICAgICAgICAgICB2ZG9tLmNuLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1yZWxhdGl2ZSddLCBjbjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLWFuaW1hdGlvbi13cmFwcGVyJ10sIGNuOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLWNvbnRlbnQtd3JhcHBlciddLCBjbjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2NsczogWyduZW8teWVhci1oZWFkZXInXSwgY246IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7aHRtbDogbWUuY3VycmVudERhdGUuZ2V0RnVsbFllYXIoKX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2NsczogWyduZW8tbmF2LWJ1dHRvbicsICduZW8tcHJldi1idXR0b24nXX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2NsczogWyduZW8tbmF2LWJ1dHRvbicsICduZW8tbmV4dC1idXR0b24nXX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF19LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2NsczogWyduZW8tbW9udGhzLWNvbnRhaW5lciddfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ICAgOiBgJHsyICogZGF0YS5oZWlnaHR9cHhgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGVZKCR7eX1weClgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCAgICA6IGAke2RhdGEud2lkdGh9cHhgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgIF19XG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgbWUuY3JlYXRlTW9udGhzKHRydWUsIHZkb20uY25bMV0uY25bMF0uY25bMF0uY25bMV0pO1xuICAgICAgICAgICAgICAgICAgICB2ZG9tLmNuWzFdLmNuWzBdLmNuW3Njcm9sbEZyb21Ub3AgPyAndW5zaGlmdCcgOiAncHVzaCddKHZkb20uY25bMF0pO1xuICAgICAgICAgICAgICAgICAgICB2ZG9tLmNuLnNwbGljZSgwLCAxKTtcblxuICAgICAgICAgICAgICAgICAgICBtZS5wcm9taXNlVXBkYXRlKHZkb20pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHNjcm9sbEZyb21Ub3AgPyAtZGF0YS5oZWlnaHQgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmRvbS5jblswXS5jblswXS5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlWSgke3l9cHgpYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLnVwZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBtZS50aW1lb3V0KDMwMCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmRvbS5jblswXSA9IHZkb20uY25bMF0uY25bMF0uY25bc2Nyb2xsRnJvbVRvcCA/IDEgOiAwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS50cmlnZ2VyVmRvbVVwZGF0ZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGNyZWF0ZURheU5hbWVzUm93KCkge1xuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICBkYXRlID0gbWUuY3VycmVudERhdGUsIC8vIGNsb25lZFxuICAgICAgICAgICAgaSAgICA9IDAsXG4gICAgICAgICAgICByb3cgID0ge2NsczogWyduZW8tY2FsZW5kYXItd2VlayddLCBjbjogW3tjbHM6IFsnbmVvLWNlbGwnLCAnbmVvLXRvcC1sZWZ0LXNwYWNlciddfV19LFxuICAgICAgICAgICAgZGF5LCBub2RlO1xuXG4gICAgICAgIGRhdGUuc2V0RGF0ZShtZS5jdXJyZW50RGF0ZS5nZXREYXRlKCkgLSBtZS5jdXJyZW50RGF0ZS5nZXREYXkoKSArIG1lLndlZWtTdGFydERheSk7XG5cbiAgICAgICAgZm9yICg7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIG5vZGUgPSB7XG4gICAgICAgICAgICAgICAgY2xzIDogWyduZW8tY2VsbCcsICduZW8td2Vla2RheS1jZWxsJ10sXG4gICAgICAgICAgICAgICAgaHRtbDogbWUuaW50bEZvcm1hdF9kYXkuZm9ybWF0KGRhdGUpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBkYXkgPSBkYXRlLmdldERheSgpO1xuXG4gICAgICAgICAgICBpZiAoIW1lLnNob3dXZWVrZW5kcyAmJiAoZGF5ID09PSAwIHx8IGRheSA9PT0gNikpIHtcbiAgICAgICAgICAgICAgICBub2RlLnJlbW92ZURvbSA9IHRydWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcm93LmNuLnB1c2gobm9kZSk7XG5cbiAgICAgICAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIDEpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcm93XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRhaW5lckVsXG4gICAgICogQHBhcmFtIHtEYXRlfSBjdXJyZW50RGF0ZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHZkb21cbiAgICAgKi9cbiAgICBjcmVhdGVNb250aENvbnRlbnQoY29udGFpbmVyRWwsIGN1cnJlbnREYXRlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2FsZW5kYXJTdG9yZSwgZXZlbnRTdG9yZX0gPSBtZSxcbiAgICAgICAgICAgIGN1cnJlbnREYXkgICAgID0gY3VycmVudERhdGUuZ2V0RGF0ZSgpLFxuICAgICAgICAgICAgY3VycmVudE1vbnRoICAgPSBjdXJyZW50RGF0ZS5nZXRNb250aCgpLFxuICAgICAgICAgICAgY3VycmVudFllYXIgICAgPSBjdXJyZW50RGF0ZS5nZXRGdWxsWWVhcigpLFxuICAgICAgICAgICAgZGF0ZSAgICAgICAgICAgPSBEYXRlVXRpbC5jbG9uZShjdXJyZW50RGF0ZSksXG4gICAgICAgICAgICB2YWx1ZURhdGUgICAgICA9IG1lLmN1cnJlbnREYXRlLCAvLyBjbG9uZWRcbiAgICAgICAgICAgIHZhbHVlTW9udGggICAgID0gdmFsdWVEYXRlLmdldE1vbnRoKCksXG4gICAgICAgICAgICB2YWx1ZVllYXIgICAgICA9IHZhbHVlRGF0ZS5nZXRGdWxsWWVhcigpLFxuICAgICAgICAgICAgZGF5c0luTW9udGggICAgPSBEYXRlVXRpbC5nZXREYXlzSW5Nb250aChjdXJyZW50RGF0ZSksXG4gICAgICAgICAgICBmaXJzdERheU9mZnNldCA9IERhdGVVdGlsLmdldEZpcnN0RGF5T2Zmc2V0KGN1cnJlbnREYXRlLCBtZS53ZWVrU3RhcnREYXkpLFxuICAgICAgICAgICAgY29sdW1ucyAgICAgICAgPSA3LFxuICAgICAgICAgICAgaSAgICAgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgd2Vla0RhdGUgICAgICAgPSBEYXRlVXRpbC5jbG9uZShjdXJyZW50RGF0ZSksXG4gICAgICAgICAgICBjZWxsSWQsIGNvbmZpZywgY29uZmlnQ2xzLCBkYXRlRGF5LCBkYXksIGRheVJlY29yZHMsIGhhc0NvbnRlbnQsIGosIHJvdywgcm93cztcblxuICAgICAgICByb3dzID0gKGRheXNJbk1vbnRoICsgZmlyc3REYXlPZmZzZXQpIC8gNyA+IDUgPyA2IDogNTtcbiAgICAgICAgZGF5ICA9IDEgLSBmaXJzdERheU9mZnNldDtcblxuICAgICAgICBkYXRlLnNldERhdGUoZGF5KTtcbiAgICAgICAgd2Vla0RhdGUuc2V0RGF0ZShkYXkgKyA3KTtcblxuICAgICAgICBmb3IgKDsgaSA8IDY7IGkrKykge1xuICAgICAgICAgICAgcm93ID0ge1xuICAgICAgICAgICAgICAgIGNscyAgICAgIDogWyduZW8tY2FsZW5kYXItd2VlayddLFxuICAgICAgICAgICAgICAgIHJlbW92ZURvbTogaSA9PT0gcm93cyAmJiAhbWUuc2l4V2Vla3NQZXJNb250aCxcblxuICAgICAgICAgICAgICAgIGNuOiBbe1xuICAgICAgICAgICAgICAgICAgICBjbHMgICAgICA6IFsnbmVvLWNlbGwnLCAnbmVvLXdlZWtudW1iZXItY2VsbCddLFxuICAgICAgICAgICAgICAgICAgICBodG1sICAgICA6IERhdGVVdGlsLmdldFdlZWtPZlllYXIod2Vla0RhdGUpLFxuICAgICAgICAgICAgICAgICAgICByZW1vdmVEb206ICFtZS5zaG93V2Vla051bWJlcnNcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgd2Vla0RhdGUuc2V0RGF0ZSh3ZWVrRGF0ZS5nZXREYXRlKCkgKyA3KTtcblxuICAgICAgICAgICAgZm9yIChqPTA7IGogPCBjb2x1bW5zOyBqKyspIHtcbiAgICAgICAgICAgICAgICBoYXNDb250ZW50ID0gZGF5ID4gMCAmJiBkYXkgPD0gZGF5c0luTW9udGg7XG4gICAgICAgICAgICAgICAgY2VsbElkICAgICA9IG1lLmdldENlbGxJZChjdXJyZW50WWVhciwgY3VycmVudE1vbnRoICsgMSwgZGF5KTtcbiAgICAgICAgICAgICAgICBkYXRlRGF5ICAgID0gZGF0ZS5nZXREYXkoKTtcblxuICAgICAgICAgICAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWQgICAgICA6IGNlbGxJZCxcbiAgICAgICAgICAgICAgICAgICAgY2xzICAgICA6IGhhc0NvbnRlbnQgPyBbJ25lby1jZWxsJ10gOiBbJ25lby1jZWxsJywgJ25lby1kaXNhYmxlZCddLFxuICAgICAgICAgICAgICAgICAgICB0YWJJbmRleDogaGFzQ29udGVudCA/IC0xIDogbnVsbCxcblxuICAgICAgICAgICAgICAgICAgICBjbjogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGNscyA6IFsnbmVvLWNlbGwtY29udGVudCddLFxuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDogaGFzQ29udGVudCA/IGRheSA6IG1lLnNob3dEaXNhYmxlZERheXMgPyBkYXRlLmdldERhdGUoKSA6ICcnXG4gICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGNvbmZpZ0NscyA9IGNvbmZpZy5jbHM7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGF0ZURheSA9PT0gMCB8fCBkYXRlRGF5ID09PSA2KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ0Nscy5wdXNoKCduZW8td2Vla2VuZCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghbWUuc2hvd1dlZWtlbmRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcucmVtb3ZlRG9tID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICBpZiAodG9kYXkueWVhciA9PT0gY3VycmVudFllYXIgJiYgdG9kYXkubW9udGggPT09IGN1cnJlbnRNb250aCAmJiB0b2RheS5kYXkgPT09IGRheSkge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuY25bMF0uY2xzLnB1c2goJ25lby10b2RheScpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlWWVhciA9PT0gY3VycmVudFllYXIgJiYgdmFsdWVNb250aCA9PT0gY3VycmVudE1vbnRoICYmIGRheSA9PT0gY3VycmVudERheSkge1xuICAgICAgICAgICAgICAgICAgICBjb25maWdDbHMucHVzaCgnbmVvLXNlbGVjdGVkJylcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWNvbmZpZy5yZW1vdmVEb20pIHtcbiAgICAgICAgICAgICAgICAgICAgZGF5UmVjb3JkcyA9IGV2ZW50U3RvcmUuZ2V0RGF5UmVjb3JkcyhkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgZGF5UmVjb3JkcyA9IGRheVJlY29yZHMuZmlsdGVyKHJlY29yZCA9PiBjYWxlbmRhclN0b3JlLmdldChyZWNvcmQuY2FsZW5kYXJJZCkuYWN0aXZlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXlSZWNvcmRzLmxlbmd0aCA+PSBtZS5ldmVudEluZGljYXRvckhpZ2gpICAge2NvbmZpZ0Nscy5wdXNoKCduZW8tZXZlbnRzLWhpZ2gnKTt9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRheVJlY29yZHMubGVuZ3RoID49IG1lLmV2ZW50SW5kaWNhdG9yTWVkaXVtKSB7Y29uZmlnQ2xzLnB1c2goJ25lby1ldmVudHMtbWVkaXVtJyk7fVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkYXlSZWNvcmRzLmxlbmd0aCA+PSBtZS5ldmVudEluZGljYXRvckxvdykgICAge2NvbmZpZ0Nscy5wdXNoKCduZW8tZXZlbnRzLWxvdycpO31cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByb3cuY24ucHVzaChjb25maWcpO1xuXG4gICAgICAgICAgICAgICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgMSk7XG5cbiAgICAgICAgICAgICAgICBkYXkrK1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250YWluZXJFbC5jbi5wdXNoKHJvdylcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb250YWluZXJFbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbGVudD1mYWxzZV0gdHJ1ZSB0byB1cGRhdGUgdGhlIHZkb20gc2lsZW50bHlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRhaW5lckVsXVxuICAgICAqL1xuICAgIGNyZWF0ZU1vbnRocyhzaWxlbnQ9ZmFsc2UsIGNvbnRhaW5lckVsKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5tb3VudGVkKSB7XG4gICAgICAgICAgICBtZS5uZWVkc0V2ZW50VXBkYXRlID0gdHJ1ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnREYXRlICAgID0gbWUuY3VycmVudERhdGUsIC8vIGNsb25lZFxuICAgICAgICAgICAgICAgIHt2ZG9tfSAgICAgICAgID0gbWUsXG4gICAgICAgICAgICAgICAgbW9udGhDb250YWluZXIgPSBjb250YWluZXJFbCB8fCB2ZG9tLmNuWzBdLmNuWzFdLFxuICAgICAgICAgICAgICAgIGkgICAgICAgICAgICAgID0gMCxcbiAgICAgICAgICAgICAgICBtb250aFZkb207XG5cbiAgICAgICAgICAgIG1vbnRoQ29udGFpbmVyLmNuID0gW107XG5cbiAgICAgICAgICAgIGZvciAoOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnREYXRlLnNldE1vbnRoKGkpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnREYXRlLnNldERhdGUoMSk7XG5cbiAgICAgICAgICAgICAgICBtb250aFZkb20gPVxuICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLW1vbnRoJ10sIGNuOiBbXG4gICAgICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLW1vbnRoLW5hbWUnXSwgaHRtbDogbWUuaW50bEZvcm1hdF9tb250aC5mb3JtYXQoY3VycmVudERhdGUpfSxcbiAgICAgICAgICAgICAgICAgICAgbWUuY3JlYXRlRGF5TmFtZXNSb3coKVxuICAgICAgICAgICAgICAgIF19O1xuXG4gICAgICAgICAgICAgICAgbW9udGhWZG9tID0gbWUuY3JlYXRlTW9udGhDb250ZW50KG1vbnRoVmRvbSwgRGF0ZVV0aWwuY2xvbmUoY3VycmVudERhdGUpKTtcblxuICAgICAgICAgICAgICAgIG1vbnRoQ29udGFpbmVyLmNuLnB1c2gobW9udGhWZG9tKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAhc2lsZW50ICYmIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHllYXJcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IG1vbnRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBkYXlcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBpZFxuICAgICAqL1xuICAgIGdldENlbGxJZCh5ZWFyLCBtb250aCwgZGF5KSB7XG4gICAgICAgIGRheSA9IGRheS50b1N0cmluZygpO1xuXG4gICAgICAgIGlmIChkYXkubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgZGF5ID0gJzAnICsgZGF5XG4gICAgICAgIH1cblxuICAgICAgICBtb250aCA9IG1vbnRoLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgaWYgKG1vbnRoLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIG1vbnRoID0gJzAnICsgbW9udGhcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmlkICsgJ19fJyArIHllYXIgKyAnLScgKyBtb250aCArICctJyArIGRheVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGFcbiAgICAgKi9cbiAgICBvbkNhbGVuZGFyU3RvcmVMb2FkKGRhdGEpIHtcbiAgICAgICAgdGhpcy5ldmVudFN0b3JlLmdldENvdW50KCkgPiAwICYmIHRoaXMuY3JlYXRlTW9udGhzKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uQ2FsZW5kYXJTdG9yZVJlY29yZENoYW5nZShkYXRhKSB7XG4gICAgICAgIHRoaXMuY3JlYXRlTW9udGhzKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhXG4gICAgICovXG4gICAgb25FdmVudFN0b3JlTG9hZChkYXRhKSB7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJTdG9yZS5nZXRDb3VudCgpID4gMCAmJiB0aGlzLmNyZWF0ZU1vbnRocygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YVxuICAgICAqL1xuICAgIG9uRXZlbnRTdG9yZVJlY29yZENoYW5nZShkYXRhKSB7XG4gICAgICAgIHRoaXMuY3JlYXRlTW9udGhzKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uTmF2QnV0dG9uQ2xpY2soZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y3VycmVudERhdGV9ID0gbWU7IC8vIGNsb25lZFxuXG4gICAgICAgIGN1cnJlbnREYXRlLnNldEZ1bGxZZWFyKGN1cnJlbnREYXRlLmdldEZ1bGxZZWFyKCkgKyAoZGF0YS5wYXRoWzBdLmNscy5pbmNsdWRlcygnbmVvLW5leHQtYnV0dG9uJykgPyAxIDogLTEpKTtcblxuICAgICAgICBtZS5jdXJyZW50RGF0ZSA9IGN1cnJlbnREYXRlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbldoZWVsKGRhdGEpIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKGRhdGEuZGVsdGFZKSA+IE1hdGguYWJzKGRhdGEuZGVsdGFYKSkge1xuICAgICAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHtjdXJyZW50RGF0ZX0gPSBtZTsgLy8gY2xvbmVkXG5cbiAgICAgICAgICAgIGN1cnJlbnREYXRlLnNldEZ1bGxZZWFyKGN1cnJlbnREYXRlLmdldEZ1bGxZZWFyKCkgKyAoZGF0YS5kZWx0YVkgPiAwID8gMSA6IC0xKSk7XG5cbiAgICAgICAgICAgIG1lLmN1cnJlbnREYXRlID0gY3VycmVudERhdGVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJzIGEgdmRvbSB1cGRhdGUgJiBzZXRzIGlzVXBkYXRpbmdcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRyaWdnZXJWZG9tVXBkYXRlKHNpbGVudD1mYWxzZSkge1xuICAgICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAgICAgbWUuaXNVcGRhdGluZyA9IHRydWU7XG5cbiAgICAgICAgICAgIG1lLnByb21pc2VVcGRhdGUobWUudmRvbSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgbWUuaXNVcGRhdGluZyA9IGZhbHNlXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHluYW1pY2FsbHkgdXBkYXRlIHRoZSB3ZWVrZGF5IHJvd3MgaW5zaWRlIGVhY2ggbW9udGhcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdXG4gICAgICovXG4gICAgdXBkYXRlRGF5TmFtZXNSb3dzKHZhbHVlLCBvbGRWYWx1ZSwgc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuaW50bEZvcm1hdF9kYXkgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChtZS5sb2NhbGUsIHt3ZWVrZGF5OiB2YWx1ZX0pO1xuXG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgZGF0ZSAgID0gbWUuY3VycmVudERhdGUsIC8vIGNsb25lZFxuICAgICAgICAgICAgICAgIHt2ZG9tfSA9IG1lLFxuICAgICAgICAgICAgICAgIGkgICAgICA9IDEsXG4gICAgICAgICAgICAgICAgZGF5LCBqLCBub2RlO1xuXG4gICAgICAgICAgICBkYXRlLnNldERhdGUobWUuY3VycmVudERhdGUuZ2V0RGF0ZSgpIC0gbWUuY3VycmVudERhdGUuZ2V0RGF5KCkgKyBtZS53ZWVrU3RhcnREYXkpO1xuXG4gICAgICAgICAgICBmb3IgKDsgaSA8IDg7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAoaj0wOyBqIDwgMTI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBkYXkgID0gZGF0ZS5nZXREYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHZkb20uY25bMF0uY25bMV0uY25bal0uY25bMV0uY25baV07XG5cbiAgICAgICAgICAgICAgICAgICAgbm9kZS5odG1sID0gbWUuaW50bEZvcm1hdF9kYXkuZm9ybWF0KGRhdGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghbWUuc2hvd1dlZWtlbmRzICYmIChkYXkgPT09IDAgfHwgZGF5ID09PSA2KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVEb20gPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgbm9kZS5yZW1vdmVEb21cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIDEpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICFzaWxlbnQgJiYgbWUudXBkYXRlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgdXBkYXRlSGVhZGVyWWVhcigpIHtcbiAgICAgICAgdGhpcy52ZG9tLmNuWzBdLmNuWzBdLmNuWzBdLmh0bWwgPSB0aGlzLmN1cnJlbnREYXRlLmdldEZ1bGxZZWFyKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEeW5hbWljYWxseSB1cGRhdGUgdGhlIG1vbnRoTmFtZUZvcm1hdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbGVudD1mYWxzZV1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdXBkYXRlTW9udGhOYW1lRm9ybWF0KHZhbHVlLCBvbGRWYWx1ZSwgc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuaW50bEZvcm1hdF9tb250aCA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KG1lLmxvY2FsZSwge21vbnRoOiB2YWx1ZX0pO1xuXG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQge2N1cnJlbnREYXRlLCB2ZG9tfSA9IG1lLFxuICAgICAgICAgICAgICAgIGkgICAgICAgICAgICAgICAgICAgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50RGF0ZS5zZXRNb250aChpKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50RGF0ZS5zZXREYXRlKDEpO1xuXG4gICAgICAgICAgICAgICAgdmRvbS5jblswXS5jblsxXS5jbltpXS5jblswXS5odG1sID0gbWUuaW50bEZvcm1hdF9tb250aC5mb3JtYXQoY3VycmVudERhdGUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICFzaWxlbnQgJiYgbWUudXBkYXRlKClcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoWWVhckNvbXBvbmVudCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=