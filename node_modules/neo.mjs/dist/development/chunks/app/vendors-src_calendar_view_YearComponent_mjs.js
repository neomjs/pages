"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_calendar_view_YearComponent_mjs"],{

/***/ "./src/calendar/view/YearComponent.mjs":
/*!*********************************************!*\
  !*** ./src/calendar/view/YearComponent.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Date.mjs */ "./src/util/Date.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");




const todayDate = new Date();

const today = {
    day  : todayDate.getDate(),
    month: todayDate.getMonth(),
    year : todayDate.getFullYear()
};

/**
 * @class Neo.calendar.view.YearComponent
 * @extends Neo.component.Base
 */
class YearComponent extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.calendar.view.YearComponent'
         * @protected
         */
        className: 'Neo.calendar.view.YearComponent',
        /**
         * @member {String[]} baseCls=['neo-calendar-yearcomponent']
         */
        baseCls: ['neo-calendar-yearcomponent'],
        /**
         * @member {Object} bind
         */
        bind: {
            calendarStore       : 'stores.calendars',
            currentDate         : data => data.currentDate,
            eventStore          : 'stores.events',
            locale              : data => data.locale,
            scrollNewYearFromTop: data => data.scrollNewYearFromTop,
            showWeekends        : data => data.showWeekends,
            weekStartDay        : data => data.weekStartDay
        },
        /**
         * Stores the last date change which got triggered while a year transition was running
         * @member {Date|null} cachedUpdate=null
         * @protected
         */
        cachedUpdate: null,
        /**
         * Bound to the state provider.
         * @member {Neo.calendar.store.Calendars|null} calendarStore_=null
         */
        calendarStore_: null,
        /**
         * Will get passed from the MainContainer
         * @member {Date|null} currentDate_=null
         * @protected
         */
        currentDate_: null,
        /**
         * The format of the column headers.
         * Valid values are: narrow, short & long
         * @member {String} dayNameFormat_='narrow'
         */
        dayNameFormat_: 'narrow',
        /**
         * @member {Number} eventIndicatorHigh_=3
         */
        eventIndicatorHigh_: 3,
        /**
         * @member {Number} eventIndicatorLow_=1
         */
        eventIndicatorLow_: 1,
        /**
         * @member {Number} eventIndicatorMedium_=2
         */
        eventIndicatorMedium_: 2,
        /**
         * Bound to the state provider.
         * @member {Neo.calendar.store.Events|null} eventStore_=null
         */
        eventStore_: null,
        /**
         * @member {Intl.DateTimeFormat|null} intlFormat_day=null
         * @protected
         */
        intlFormat_day: null,
        /**
         * @member {Intl.DateTimeFormat|null} intlFormat_month=null
         * @protected
         */
        intlFormat_month: null,
        /**
         * Internal flag to prevent changing the date while change animations are still running
         * @member {Boolean} isUpdating_=false
         * @protected
         */
        isUpdating_: false,
        /**
         * Bound to the state provider.
         * @member {String} locale_=Neo.config.locale
         */
        locale_: Neo.config.locale,
        /**
         * The format of the month header names.
         * Valid values are: narrow, short & long
         * @member {String} monthNameFormat_='long'
         */
        monthNameFormat_: 'long',
        /**
         * Internal flag to store if createMonths() got called while not being mounted
         * @member {Boolean} needsEventUpdate=false
         * @protected
         */
        needsEventUpdate: false,
        /**
         * @member {Neo.calendar.view.MainContainer|null} owner=null
         * @protected
         */
        owner: null,
        /**
         * True to scroll new years in from the top
         * @member {Boolean} scrollNewYearFromTop=false
         */
        scrollNewYearFromTop: false,
        /**
         * True to show borders for the calendar month cells
         * @member {Boolean} showCellBorders_=false
         */
        showCellBorders_: false,
        /**
         * True to show the days of the previous or next month (not selectable)
         * @member {Boolean} showDisabledDays_=true
         */
        showDisabledDays_: true,
        /**
         * Bound to the state provider.
         * @member {Boolean} showWeekends_=true
         */
        showWeekends_: true,
        /**
         * True to show the week number as the first column of each month
         * @member {Boolean} showWeekNumbers_=true
         */
        showWeekNumbers_: true,
        /**
         * True to show 6 weeks for each month, so that all months have the same height
         * @member {Boolean} sixWeeksPerMonth_=false
         */
        sixWeeksPerMonth_: false,
        /**
         * True to use sliding animations
         * @member {Boolean} useAnimations=true
         */
        useAnimations: true,
        /**
         * @member {Object} vdom
         */
        vdom:
        {cn: [
            {cls: ['neo-content-wrapper'], cn: [
                {cls: ['neo-year-header'], cn: [
                    {},
                    {cls: ['neo-nav-button', 'neo-prev-button']},
                    {cls: ['neo-nav-button', 'neo-next-button']}
                ]},
                {cls: ['neo-months-container']}
            ]}
        ]},
        /**
         * 0-6 => Sun-Sat
         * Bound to the state provider.
         * @member {Number} weekStartDay_=0
         */
        weekStartDay_: 0
    }

    /**
     * @param config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.addDomListeners([
            {click: me.onNavButtonClick, delegate: '.neo-nav-button', scope: me},
            {wheel: me.onWheel, scope: me}
        ]);

        if (me.calendarStore.getCount() > 0 && me.eventStore.getCount() > 0) {
            me.createMonths(true) // silent update
        }

        me.updateHeaderYear()
    }

    /**
     * Triggered after the calendarStore config got changed
     * @param {Neo.calendar.store.Calendars|null} value
     * @param {Neo.calendar.store.Calendars|null} oldValue
     * @protected
     */
    afterSetCalendarStore(value, oldValue) {
        let me = this,

        listeners = {
            load        : me.onCalendarStoreLoad,
            recordChange: me.onCalendarStoreRecordChange,
            scope       : me
        };

        oldValue?.un(listeners);
        value   ?.on(listeners)
    }

    /**
     * Triggered after the currentDate config got changed
     * @param {Date} value
     * @param {Date} oldValue
     * @protected
     */
    afterSetCurrentDate(value, oldValue) {
        if (this.isConstructed) {
            let oldYear = oldValue.getFullYear(),
                year    = value   .getFullYear();

            if (year !== oldYear) {
                this.changeYear(year - oldYear)
            }
        }
    }

    /**
     * Triggered after the dayNameFormat config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetDayNameFormat(value, oldValue) {
        this.updateDayNamesRows(value, oldValue)
    }

    /**
     * Triggered after the eventIndicatorHigh config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetEventIndicatorHigh(value, oldValue) {
        oldValue !== undefined && this.createMonths()
    }

    /**
     * Triggered after the eventIndicatorLow config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetEventIndicatorLow(value, oldValue) {
        oldValue !== undefined && this.createMonths()
    }

    /**
     * Triggered after the eventIndicatorMedium config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetEventIndicatorMedium(value, oldValue) {
        oldValue !== undefined && this.createMonths()
    }

    /**
     * Triggered after the eventStore config got changed
     * @param {Neo.calendar.store.Events|null} value
     * @param {Neo.calendar.store.Events|null} oldValue
     * @protected
     */
    afterSetEventStore(value, oldValue) {
        let me = this,

        listeners = {
            load        : me.onEventStoreLoad,
            recordChange: me.onEventStoreRecordChange,
            scope       : me
        };

        oldValue?.un(listeners);
        value   ?.on(listeners)
    }

    /**
     * Triggered after the locale config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetLocale(value, oldValue) {
        if (oldValue !== undefined) {
            let me = this;

            me.updateDayNamesRows(me.dayNameFormat, '', true);
            me.updateMonthNameFormat(me.monthNameFormat, '')
        }
    }

    /**
     * Triggered after the monthNameFormat config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetMonthNameFormat(value, oldValue) {
        this.updateMonthNameFormat(value, oldValue)
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        let me = this;

        if (value && me.needsEventUpdate) {
            me.createMonths();
            me.needsEventUpdate = false
        }
    }

    /**
     * Triggered after the showCellBorders config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowCellBorders(value, oldValue) {
        let cls = this.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"][value ? 'add' : 'remove'](cls, 'neo-show-cell-borders');
        this.cls = cls
    }

    /**
     * Triggered after the showWeekends config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowWeekends(value, oldValue) {
        if (oldValue !== undefined) {
            let me     = this,
                {vdom} = me,
                i      = 0,
                item, itemCn, j, k, len;

            for (; i < 12; i++) { // months
                itemCn = vdom.cn[0].cn[1].cn[i].cn;
                len    = itemCn.length;

                for (j=1; j < len; j++) { // weeks
                    for (k=1; k < 8; k++) { // days
                        item = itemCn[j].cn[k];

                        if (item.cls.includes('neo-weekend')) {
                            if (value) {
                                delete item.removeDom
                            } else {
                                item.removeDom = true
                            }
                        }
                    }
                }
            }

            // triggers the vdom update
            me.updateDayNamesRows(me.dayNameFormat, '')
        }
    }

    /**
     * Triggered after the showWeekNumbers config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowWeekNumbers(value, oldValue) {
        if (oldValue !== undefined) {
            let me = this,
                i  = 0,
                itemCn, j, len;

            for (; i < 12; i++) {
                itemCn = me.vdom.cn[0].cn[1].cn[i].cn;
                len    = itemCn.length;

                for (j = 1; j < len; j++) {
                    itemCn[j].cn[0].removeDom = !value
                }
            }

            me.update()
        }
    }

    /**
     * Triggered after the sixWeeksPerMonth config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetSixWeeksPerMonth(value, oldValue) {
        if (oldValue !== undefined) {
            let me   = this,
                date = me.currentDate, // cloned
                i    = 0;

            date.setMonth(0);
            date.setDate(1);

            for (; i < 12; i++) {
                me.vdom.cn[0].cn[1].cn[i].cn[7].removeDom = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getWeeksOfMonth(date, me.weekStartDay) === 5 && !value;
                date.setMonth(date.getMonth() + 1)
            }

            me.update()
        }
    }

    /**
     * Triggered after the weekStartDay config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetWeekStartDay(value, oldValue) {
        oldValue !== undefined && this.createMonths()
    }

    /**
     * Triggered before the dayNameFormat config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetDayNameFormat(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'dayNameFormat', _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.dayNameFormats)
    }

    /**
     * Triggered before the monthNameFormat config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetMonthNameFormat(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'monthNameFormat', _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.monthNameFormats)
    }

    /**
     * Stores the last date change which could not get applied while a transition was running
     * @param {Date} [date=this.currentDate]
     * @protected
     */
    cacheUpdate(date=this.currentDate) {
        this.cachedUpdate = date
    }

    /**
     * @param {Number} increment
     */
    changeYear(increment) {
        let me = this,
            scrollFromTop, vdom, y;

        if (!me.useAnimations) {
            // me.recreateContent(increment); // todo
        } else {
            if (!me.isUpdating) {
                me.isUpdating = true;

                me.getDomRect().then(data => {
                    scrollFromTop = me.scrollNewYearFromTop && increment < 0 || !me.scrollNewYearFromTop && increment > 0;
                    vdom          = me.vdom;
                    y             = scrollFromTop ? 0 : -data.height;

                    vdom.cn.push(
                        {cls: ['neo-relative'], cn: [
                            {cls: ['neo-animation-wrapper'], cn: [
                                {cls: ['neo-content-wrapper'], cn: [
                                    {cls: ['neo-year-header'], cn: [
                                        {text: me.currentDate.getFullYear()},
                                        {cls: ['neo-nav-button', 'neo-prev-button']},
                                        {cls: ['neo-nav-button', 'neo-next-button']}
                                    ]},
                                    {cls: ['neo-months-container']}
                                ]}
                            ],
                            style: {
                                height   : `${2 * data.height}px`,
                                transform: `translateY(${y}px)`,
                                width    : `${data.width}px`
                            }}
                        ]}
                    );

                    me.createMonths(true, vdom.cn[1].cn[0].cn[0].cn[1]);
                    vdom.cn[1].cn[0].cn[scrollFromTop ? 'unshift' : 'push'](vdom.cn[0]);
                    vdom.cn.splice(0, 1);

                    me.promiseUpdate().then(() => {
                        y = scrollFromTop ? -data.height : 0;
                        vdom.cn[0].cn[0].style.transform = `translateY(${y}px)`;
                        me.update();

                        me.timeout(300).then(() => {
                            vdom.cn[0] = vdom.cn[0].cn[0].cn[scrollFromTop ? 1 : 0];
                            me.triggerVdomUpdate()
                        })
                    })
                })
            }
        }
    }

    /**
     *
     */
    createDayNamesRow() {
        let me   = this,
            date = me.currentDate, // cloned
            i    = 0,
            row  = {cls: ['neo-calendar-week'], cn: [{cls: ['neo-cell', 'neo-top-left-spacer']}]},
            day, node;

        date.setDate(me.currentDate.getDate() - me.currentDate.getDay() + me.weekStartDay);

        for (; i < 7; i++) {
            node = {
                cls : ['neo-cell', 'neo-weekday-cell'],
                text: me.intlFormat_day.format(date)
            };

            day = date.getDay();

            if (!me.showWeekends && (day === 0 || day === 6)) {
                node.removeDom = true
            }

            row.cn.push(node);

            date.setDate(date.getDate() + 1)
        }

        return row
    }

    /**
     * @param {Object} containerEl
     * @param {Date} currentDate
     * @returns {Object} vdom
     */
    createMonthContent(containerEl, currentDate) {
        let me             = this,
            {calendarStore, eventStore} = me,
            currentDay     = currentDate.getDate(),
            currentMonth   = currentDate.getMonth(),
            currentYear    = currentDate.getFullYear(),
            date           = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].clone(currentDate),
            valueDate      = me.currentDate, // cloned
            valueMonth     = valueDate.getMonth(),
            valueYear      = valueDate.getFullYear(),
            daysInMonth    = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getDaysInMonth(currentDate),
            firstDayOffset = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getFirstDayOffset(currentDate, me.weekStartDay),
            columns        = 7,
            i              = 0,
            weekDate       = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].clone(currentDate),
            cellId, config, configCls, dateDay, day, dayRecords, hasContent, j, row, rows;

        rows = (daysInMonth + firstDayOffset) / 7 > 5 ? 6 : 5;
        day  = 1 - firstDayOffset;

        date.setDate(day);
        weekDate.setDate(day + 7);

        for (; i < 6; i++) {
            row = {
                cls      : ['neo-calendar-week'],
                removeDom: i === rows && !me.sixWeeksPerMonth,

                cn: [{
                    cls      : ['neo-cell', 'neo-weeknumber-cell'],
                    removeDom: !me.showWeekNumbers,
                    text     : _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getWeekOfYear(weekDate)
                }]
            };

            weekDate.setDate(weekDate.getDate() + 7);

            for (j=0; j < columns; j++) {
                hasContent = day > 0 && day <= daysInMonth;
                cellId     = me.getCellId(currentYear, currentMonth + 1, day);
                dateDay    = date.getDay();

                config = {
                    id      : cellId,
                    cls     : hasContent ? ['neo-cell'] : ['neo-cell', 'neo-disabled'],
                    tabIndex: hasContent ? -1 : null,

                    cn: [{
                        cls : ['neo-cell-content'],
                        text: hasContent ? day : me.showDisabledDays ? date.getDate() : ''
                    }]
                };

                configCls = config.cls;

                if (dateDay === 0 || dateDay === 6) {
                    configCls.push('neo-weekend');

                    if (!me.showWeekends) {
                        config.removeDom = true
                    }
                }


                if (today.year === currentYear && today.month === currentMonth && today.day === day) {
                    config.cn[0].cls.push('neo-today')
                }

                if (valueYear === currentYear && valueMonth === currentMonth && day === currentDay) {
                    configCls.push('neo-selected')
                }

                if (!config.removeDom) {
                    dayRecords = eventStore.getDayRecords(date);
                    dayRecords = dayRecords.filter(record => calendarStore.get(record.calendarId).active);

                         if (dayRecords.length >= me.eventIndicatorHigh)   {configCls.push('neo-events-high');}
                    else if (dayRecords.length >= me.eventIndicatorMedium) {configCls.push('neo-events-medium');}
                    else if (dayRecords.length >= me.eventIndicatorLow)    {configCls.push('neo-events-low');}
                }

                row.cn.push(config);

                date.setDate(date.getDate() + 1);

                day++
            }

            containerEl.cn.push(row)
        }

        return containerEl
    }

    /**
     * @param {Boolean} [silent=false] true to update the vdom silently
     * @param {Object} [containerEl]
     */
    createMonths(silent=false, containerEl) {
        let me = this;

        if (!me.mounted) {
            me.needsEventUpdate = true
        } else {
            let currentDate    = me.currentDate, // cloned
                {vdom}         = me,
                monthContainer = containerEl || vdom.cn[0].cn[1],
                i              = 0,
                monthVdom;

            monthContainer.cn = [];

            for (; i < 12; i++) {
                currentDate.setMonth(i);
                currentDate.setDate(1);

                monthVdom =
                {cls: ['neo-month'], cn: [
                    {cls: ['neo-month-name'], text: me.intlFormat_month.format(currentDate)},
                    me.createDayNamesRow()
                ]};

                monthVdom = me.createMonthContent(monthVdom, _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].clone(currentDate));

                monthContainer.cn.push(monthVdom)
            }

            !silent && me.update()
        }
    }

    /**
     * @param {Number|String} year
     * @param {Number|String} month
     * @param {Number|String} day
     * @returns {String} id
     */
    getCellId(year, month, day) {
        day = day.toString();

        if (day.length < 2) {
            day = '0' + day
        }

        month = month.toString();

        if (month.length < 2) {
            month = '0' + month
        }

        return this.id + '__' + year + '-' + month + '-' + day
    }

    /**
     * @param {Object[]} data
     */
    onCalendarStoreLoad(data) {
        this.eventStore.getCount() > 0 && this.createMonths()
    }

    /**
     * @param {Object} data
     */
    onCalendarStoreRecordChange(data) {
        this.createMonths()
    }

    /**
     * @param {Object[]} data
     */
    onEventStoreLoad(data) {
        this.calendarStore.getCount() > 0 && this.createMonths()
    }

    /**
     * @param {Object[]} data
     */
    onEventStoreRecordChange(data) {
        this.createMonths()
    }

    /**
     * @param {Object} data
     */
    onNavButtonClick(data) {
        let me            = this,
            {currentDate} = me; // cloned

        currentDate.setFullYear(currentDate.getFullYear() + (data.path[0].cls.includes('neo-next-button') ? 1 : -1));

        me.currentDate = currentDate
    }

    /**
     * @param {Object} data
     */
    onWheel(data) {
        if (Math.abs(data.deltaY) > Math.abs(data.deltaX)) {
            let me            = this,
                {currentDate} = me; // cloned

            currentDate.setFullYear(currentDate.getFullYear() + (data.deltaY > 0 ? 1 : -1));

            me.currentDate = currentDate
        }
    }

    /**
     * Triggers a vdom update & sets isUpdating
     * @param {Boolean} [silent=false]
     * @protected
     */
    triggerVdomUpdate(silent=false) {
        if (!silent) {
            let me = this;

            me.isUpdating = true;

            me.promiseUpdate().then(() => {
                me.isUpdating = false
            })
        }
    }

    /**
     * Dynamically update the weekday rows inside each month
     * @param {String} value
     * @param {String} oldValue
     * @param {Boolean} [silent=false]
     */
    updateDayNamesRows(value, oldValue, silent=false) {
        let me = this;

        me.intlFormat_day = new Intl.DateTimeFormat(me.locale, {weekday: value});

        if (oldValue !== undefined) {
            let date   = me.currentDate, // cloned
                {vdom} = me,
                i      = 1,
                day, j, node;

            date.setDate(me.currentDate.getDate() - me.currentDate.getDay() + me.weekStartDay);

            for (; i < 8; i++) {
                for (j=0; j < 12; j++) {
                    day  = date.getDay();
                    node = vdom.cn[0].cn[1].cn[j].cn[1].cn[i];

                    node.text = me.intlFormat_day.format(date);

                    if (!me.showWeekends && (day === 0 || day === 6)) {
                        node.removeDom = true
                    } else {
                        delete node.removeDom
                    }
                }

                date.setDate(date.getDate() + 1)
            }

            !silent && me.update()
        }
    }

    /**
     *
     */
    updateHeaderYear() {
        this.vdom.cn[0].cn[0].cn[0].text = this.currentDate.getFullYear()
    }

    /**
     * Dynamically update the monthNameFormat
     * @param {String} value
     * @param {String} oldValue
     * @param {Boolean} [silent=false]
     * @protected
     */
    updateMonthNameFormat(value, oldValue, silent=false) {
        let me = this;

        me.intlFormat_month = new Intl.DateTimeFormat(me.locale, {month: value});

        if (oldValue !== undefined) {
            let {currentDate, vdom} = me,
                i                   = 0;

            for (; i < 12; i++) {
                currentDate.setMonth(i);
                currentDate.setDate(1);

                vdom.cn[0].cn[1].cn[i].cn[0].text = me.intlFormat_month.format(currentDate)
            }

            !silent && me.update()
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(YearComponent));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19jYWxlbmRhcl92aWV3X1llYXJDb21wb25lbnRfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUQ7QUFDTDtBQUNDOztBQUU3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJEQUFTO0FBQ3JDO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQ0FBbUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQ0FBZ0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNB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O0FBQ0EsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsT0FBTztBQUMxQiwwQkFBMEIsUUFBUTtBQUNsQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0VBQWtFLGFBQWE7O0FBRS9FO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQzs7QUFFQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsNkJBQTZCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NhbGVuZGFyL3ZpZXcvWWVhckNvbXBvbmVudC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi8uLi9jb21wb25lbnQvQmFzZS5tanMnO1xuaW1wb3J0IERhdGVVdGlsICBmcm9tICcuLi8uLi91dGlsL0RhdGUubWpzJztcbmltcG9ydCBOZW9BcnJheSAgZnJvbSAnLi4vLi4vdXRpbC9BcnJheS5tanMnO1xuXG5jb25zdCB0b2RheURhdGUgPSBuZXcgRGF0ZSgpO1xuXG5jb25zdCB0b2RheSA9IHtcbiAgICBkYXkgIDogdG9kYXlEYXRlLmdldERhdGUoKSxcbiAgICBtb250aDogdG9kYXlEYXRlLmdldE1vbnRoKCksXG4gICAgeWVhciA6IHRvZGF5RGF0ZS5nZXRGdWxsWWVhcigpXG59O1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uY2FsZW5kYXIudmlldy5ZZWFyQ29tcG9uZW50XG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqL1xuY2xhc3MgWWVhckNvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY2FsZW5kYXIudmlldy5ZZWFyQ29tcG9uZW50J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY2FsZW5kYXIudmlldy5ZZWFyQ29tcG9uZW50JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWNhbGVuZGFyLXllYXJjb21wb25lbnQnXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tY2FsZW5kYXIteWVhcmNvbXBvbmVudCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBiaW5kXG4gICAgICAgICAqL1xuICAgICAgICBiaW5kOiB7XG4gICAgICAgICAgICBjYWxlbmRhclN0b3JlICAgICAgIDogJ3N0b3Jlcy5jYWxlbmRhcnMnLFxuICAgICAgICAgICAgY3VycmVudERhdGUgICAgICAgICA6IGRhdGEgPT4gZGF0YS5jdXJyZW50RGF0ZSxcbiAgICAgICAgICAgIGV2ZW50U3RvcmUgICAgICAgICAgOiAnc3RvcmVzLmV2ZW50cycsXG4gICAgICAgICAgICBsb2NhbGUgICAgICAgICAgICAgIDogZGF0YSA9PiBkYXRhLmxvY2FsZSxcbiAgICAgICAgICAgIHNjcm9sbE5ld1llYXJGcm9tVG9wOiBkYXRhID0+IGRhdGEuc2Nyb2xsTmV3WWVhckZyb21Ub3AsXG4gICAgICAgICAgICBzaG93V2Vla2VuZHMgICAgICAgIDogZGF0YSA9PiBkYXRhLnNob3dXZWVrZW5kcyxcbiAgICAgICAgICAgIHdlZWtTdGFydERheSAgICAgICAgOiBkYXRhID0+IGRhdGEud2Vla1N0YXJ0RGF5XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9yZXMgdGhlIGxhc3QgZGF0ZSBjaGFuZ2Ugd2hpY2ggZ290IHRyaWdnZXJlZCB3aGlsZSBhIHllYXIgdHJhbnNpdGlvbiB3YXMgcnVubmluZ1xuICAgICAgICAgKiBAbWVtYmVyIHtEYXRlfG51bGx9IGNhY2hlZFVwZGF0ZT1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNhY2hlZFVwZGF0ZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJvdW5kIHRvIHRoZSBzdGF0ZSBwcm92aWRlci5cbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNhbGVuZGFyLnN0b3JlLkNhbGVuZGFyc3xudWxsfSBjYWxlbmRhclN0b3JlXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBjYWxlbmRhclN0b3JlXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdpbGwgZ2V0IHBhc3NlZCBmcm9tIHRoZSBNYWluQ29udGFpbmVyXG4gICAgICAgICAqIEBtZW1iZXIge0RhdGV8bnVsbH0gY3VycmVudERhdGVfPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY3VycmVudERhdGVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGZvcm1hdCBvZiB0aGUgY29sdW1uIGhlYWRlcnMuXG4gICAgICAgICAqIFZhbGlkIHZhbHVlcyBhcmU6IG5hcnJvdywgc2hvcnQgJiBsb25nXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gZGF5TmFtZUZvcm1hdF89J25hcnJvdydcbiAgICAgICAgICovXG4gICAgICAgIGRheU5hbWVGb3JtYXRfOiAnbmFycm93JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gZXZlbnRJbmRpY2F0b3JIaWdoXz0zXG4gICAgICAgICAqL1xuICAgICAgICBldmVudEluZGljYXRvckhpZ2hfOiAzLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBldmVudEluZGljYXRvckxvd189MVxuICAgICAgICAgKi9cbiAgICAgICAgZXZlbnRJbmRpY2F0b3JMb3dfOiAxLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBldmVudEluZGljYXRvck1lZGl1bV89MlxuICAgICAgICAgKi9cbiAgICAgICAgZXZlbnRJbmRpY2F0b3JNZWRpdW1fOiAyLFxuICAgICAgICAvKipcbiAgICAgICAgICogQm91bmQgdG8gdGhlIHN0YXRlIHByb3ZpZGVyLlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY2FsZW5kYXIuc3RvcmUuRXZlbnRzfG51bGx9IGV2ZW50U3RvcmVfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGV2ZW50U3RvcmVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7SW50bC5EYXRlVGltZUZvcm1hdHxudWxsfSBpbnRsRm9ybWF0X2RheT1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGludGxGb3JtYXRfZGF5OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7SW50bC5EYXRlVGltZUZvcm1hdHxudWxsfSBpbnRsRm9ybWF0X21vbnRoPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaW50bEZvcm1hdF9tb250aDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGZsYWcgdG8gcHJldmVudCBjaGFuZ2luZyB0aGUgZGF0ZSB3aGlsZSBjaGFuZ2UgYW5pbWF0aW9ucyBhcmUgc3RpbGwgcnVubmluZ1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc1VwZGF0aW5nXz1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBpc1VwZGF0aW5nXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCb3VuZCB0byB0aGUgc3RhdGUgcHJvdmlkZXIuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbG9jYWxlXz1OZW8uY29uZmlnLmxvY2FsZVxuICAgICAgICAgKi9cbiAgICAgICAgbG9jYWxlXzogTmVvLmNvbmZpZy5sb2NhbGUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZm9ybWF0IG9mIHRoZSBtb250aCBoZWFkZXIgbmFtZXMuXG4gICAgICAgICAqIFZhbGlkIHZhbHVlcyBhcmU6IG5hcnJvdywgc2hvcnQgJiBsb25nXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbW9udGhOYW1lRm9ybWF0Xz0nbG9uZydcbiAgICAgICAgICovXG4gICAgICAgIG1vbnRoTmFtZUZvcm1hdF86ICdsb25nJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGZsYWcgdG8gc3RvcmUgaWYgY3JlYXRlTW9udGhzKCkgZ290IGNhbGxlZCB3aGlsZSBub3QgYmVpbmcgbW91bnRlZFxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBuZWVkc0V2ZW50VXBkYXRlPWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG5lZWRzRXZlbnRVcGRhdGU6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNhbGVuZGFyLnZpZXcuTWFpbkNvbnRhaW5lcnxudWxsfSBvd25lcj1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG93bmVyOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSB0byBzY3JvbGwgbmV3IHllYXJzIGluIGZyb20gdGhlIHRvcFxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzY3JvbGxOZXdZZWFyRnJvbVRvcD1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgc2Nyb2xsTmV3WWVhckZyb21Ub3A6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSB0byBzaG93IGJvcmRlcnMgZm9yIHRoZSBjYWxlbmRhciBtb250aCBjZWxsc1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaG93Q2VsbEJvcmRlcnNfPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBzaG93Q2VsbEJvcmRlcnNfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgdG8gc2hvdyB0aGUgZGF5cyBvZiB0aGUgcHJldmlvdXMgb3IgbmV4dCBtb250aCAobm90IHNlbGVjdGFibGUpXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNob3dEaXNhYmxlZERheXNfPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIHNob3dEaXNhYmxlZERheXNfOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQm91bmQgdG8gdGhlIHN0YXRlIHByb3ZpZGVyLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaG93V2Vla2VuZHNfPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIHNob3dXZWVrZW5kc186IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIHRvIHNob3cgdGhlIHdlZWsgbnVtYmVyIGFzIHRoZSBmaXJzdCBjb2x1bW4gb2YgZWFjaCBtb250aFxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaG93V2Vla051bWJlcnNfPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIHNob3dXZWVrTnVtYmVyc186IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIHRvIHNob3cgNiB3ZWVrcyBmb3IgZWFjaCBtb250aCwgc28gdGhhdCBhbGwgbW9udGhzIGhhdmUgdGhlIHNhbWUgaGVpZ2h0XG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpeFdlZWtzUGVyTW9udGhfPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBzaXhXZWVrc1Blck1vbnRoXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIHRvIHVzZSBzbGlkaW5nIGFuaW1hdGlvbnNcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gdXNlQW5pbWF0aW9ucz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICB1c2VBbmltYXRpb25zOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSB2ZG9tXG4gICAgICAgICAqL1xuICAgICAgICB2ZG9tOlxuICAgICAgICB7Y246IFtcbiAgICAgICAgICAgIHtjbHM6IFsnbmVvLWNvbnRlbnQtd3JhcHBlciddLCBjbjogW1xuICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLXllYXItaGVhZGVyJ10sIGNuOiBbXG4gICAgICAgICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1uYXYtYnV0dG9uJywgJ25lby1wcmV2LWJ1dHRvbiddfSxcbiAgICAgICAgICAgICAgICAgICAge2NsczogWyduZW8tbmF2LWJ1dHRvbicsICduZW8tbmV4dC1idXR0b24nXX1cbiAgICAgICAgICAgICAgICBdfSxcbiAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1tb250aHMtY29udGFpbmVyJ119XG4gICAgICAgICAgICBdfVxuICAgICAgICBdfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIDAtNiA9PiBTdW4tU2F0XG4gICAgICAgICAqIEJvdW5kIHRvIHRoZSBzdGF0ZSBwcm92aWRlci5cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSB3ZWVrU3RhcnREYXlfPTBcbiAgICAgICAgICovXG4gICAgICAgIHdlZWtTdGFydERheV86IDBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmFkZERvbUxpc3RlbmVycyhbXG4gICAgICAgICAgICB7Y2xpY2s6IG1lLm9uTmF2QnV0dG9uQ2xpY2ssIGRlbGVnYXRlOiAnLm5lby1uYXYtYnV0dG9uJywgc2NvcGU6IG1lfSxcbiAgICAgICAgICAgIHt3aGVlbDogbWUub25XaGVlbCwgc2NvcGU6IG1lfVxuICAgICAgICBdKTtcblxuICAgICAgICBpZiAobWUuY2FsZW5kYXJTdG9yZS5nZXRDb3VudCgpID4gMCAmJiBtZS5ldmVudFN0b3JlLmdldENvdW50KCkgPiAwKSB7XG4gICAgICAgICAgICBtZS5jcmVhdGVNb250aHModHJ1ZSkgLy8gc2lsZW50IHVwZGF0ZVxuICAgICAgICB9XG5cbiAgICAgICAgbWUudXBkYXRlSGVhZGVyWWVhcigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBjYWxlbmRhclN0b3JlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TmVvLmNhbGVuZGFyLnN0b3JlLkNhbGVuZGFyc3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLmNhbGVuZGFyLnN0b3JlLkNhbGVuZGFyc3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldENhbGVuZGFyU3RvcmUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG5cbiAgICAgICAgbGlzdGVuZXJzID0ge1xuICAgICAgICAgICAgbG9hZCAgICAgICAgOiBtZS5vbkNhbGVuZGFyU3RvcmVMb2FkLFxuICAgICAgICAgICAgcmVjb3JkQ2hhbmdlOiBtZS5vbkNhbGVuZGFyU3RvcmVSZWNvcmRDaGFuZ2UsXG4gICAgICAgICAgICBzY29wZSAgICAgICA6IG1lXG4gICAgICAgIH07XG5cbiAgICAgICAgb2xkVmFsdWU/LnVuKGxpc3RlbmVycyk7XG4gICAgICAgIHZhbHVlICAgPy5vbihsaXN0ZW5lcnMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBjdXJyZW50RGF0ZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0RhdGV9IHZhbHVlXG4gICAgICogQHBhcmFtIHtEYXRlfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEN1cnJlbnREYXRlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5pc0NvbnN0cnVjdGVkKSB7XG4gICAgICAgICAgICBsZXQgb2xkWWVhciA9IG9sZFZhbHVlLmdldEZ1bGxZZWFyKCksXG4gICAgICAgICAgICAgICAgeWVhciAgICA9IHZhbHVlICAgLmdldEZ1bGxZZWFyKCk7XG5cbiAgICAgICAgICAgIGlmICh5ZWFyICE9PSBvbGRZZWFyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VZZWFyKHllYXIgLSBvbGRZZWFyKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBkYXlOYW1lRm9ybWF0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldERheU5hbWVGb3JtYXQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRGF5TmFtZXNSb3dzKHZhbHVlLCBvbGRWYWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGV2ZW50SW5kaWNhdG9ySGlnaCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRFdmVudEluZGljYXRvckhpZ2godmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5jcmVhdGVNb250aHMoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZXZlbnRJbmRpY2F0b3JMb3cgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RXZlbnRJbmRpY2F0b3JMb3codmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5jcmVhdGVNb250aHMoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZXZlbnRJbmRpY2F0b3JNZWRpdW0gY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RXZlbnRJbmRpY2F0b3JNZWRpdW0odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5jcmVhdGVNb250aHMoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZXZlbnRTdG9yZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge05lby5jYWxlbmRhci5zdG9yZS5FdmVudHN8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5jYWxlbmRhci5zdG9yZS5FdmVudHN8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRFdmVudFN0b3JlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuXG4gICAgICAgIGxpc3RlbmVycyA9IHtcbiAgICAgICAgICAgIGxvYWQgICAgICAgIDogbWUub25FdmVudFN0b3JlTG9hZCxcbiAgICAgICAgICAgIHJlY29yZENoYW5nZTogbWUub25FdmVudFN0b3JlUmVjb3JkQ2hhbmdlLFxuICAgICAgICAgICAgc2NvcGUgICAgICAgOiBtZVxuICAgICAgICB9O1xuXG4gICAgICAgIG9sZFZhbHVlPy51bihsaXN0ZW5lcnMpO1xuICAgICAgICB2YWx1ZSAgID8ub24obGlzdGVuZXJzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbG9jYWxlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldExvY2FsZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIG1lLnVwZGF0ZURheU5hbWVzUm93cyhtZS5kYXlOYW1lRm9ybWF0LCAnJywgdHJ1ZSk7XG4gICAgICAgICAgICBtZS51cGRhdGVNb250aE5hbWVGb3JtYXQobWUubW9udGhOYW1lRm9ybWF0LCAnJylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbW9udGhOYW1lRm9ybWF0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vbnRoTmFtZUZvcm1hdCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVNb250aE5hbWVGb3JtYXQodmFsdWUsIG9sZFZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbW91bnRlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHZhbHVlICYmIG1lLm5lZWRzRXZlbnRVcGRhdGUpIHtcbiAgICAgICAgICAgIG1lLmNyZWF0ZU1vbnRocygpO1xuICAgICAgICAgICAgbWUubmVlZHNFdmVudFVwZGF0ZSA9IGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNob3dDZWxsQm9yZGVycyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNob3dDZWxsQm9yZGVycyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IGNscyA9IHRoaXMuY2xzO1xuXG4gICAgICAgIE5lb0FycmF5W3ZhbHVlID8gJ2FkZCcgOiAncmVtb3ZlJ10oY2xzLCAnbmVvLXNob3ctY2VsbC1ib3JkZXJzJyk7XG4gICAgICAgIHRoaXMuY2xzID0gY2xzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzaG93V2Vla2VuZHMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTaG93V2Vla2VuZHModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICB7dmRvbX0gPSBtZSxcbiAgICAgICAgICAgICAgICBpICAgICAgPSAwLFxuICAgICAgICAgICAgICAgIGl0ZW0sIGl0ZW1DbiwgaiwgaywgbGVuO1xuXG4gICAgICAgICAgICBmb3IgKDsgaSA8IDEyOyBpKyspIHsgLy8gbW9udGhzXG4gICAgICAgICAgICAgICAgaXRlbUNuID0gdmRvbS5jblswXS5jblsxXS5jbltpXS5jbjtcbiAgICAgICAgICAgICAgICBsZW4gICAgPSBpdGVtQ24ubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgZm9yIChqPTE7IGogPCBsZW47IGorKykgeyAvLyB3ZWVrc1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGs9MTsgayA8IDg7IGsrKykgeyAvLyBkYXlzXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0gaXRlbUNuW2pdLmNuW2tdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5jbHMuaW5jbHVkZXMoJ25lby13ZWVrZW5kJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGl0ZW0ucmVtb3ZlRG9tXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5yZW1vdmVEb20gPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0cmlnZ2VycyB0aGUgdmRvbSB1cGRhdGVcbiAgICAgICAgICAgIG1lLnVwZGF0ZURheU5hbWVzUm93cyhtZS5kYXlOYW1lRm9ybWF0LCAnJylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc2hvd1dlZWtOdW1iZXJzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U2hvd1dlZWtOdW1iZXJzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgICAgICBpICA9IDAsXG4gICAgICAgICAgICAgICAgaXRlbUNuLCBqLCBsZW47XG5cbiAgICAgICAgICAgIGZvciAoOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgICAgIGl0ZW1DbiA9IG1lLnZkb20uY25bMF0uY25bMV0uY25baV0uY247XG4gICAgICAgICAgICAgICAgbGVuICAgID0gaXRlbUNuLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDE7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtQ25bal0uY25bMF0ucmVtb3ZlRG9tID0gIXZhbHVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS51cGRhdGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzaXhXZWVrc1Blck1vbnRoIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U2l4V2Vla3NQZXJNb250aCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBkYXRlID0gbWUuY3VycmVudERhdGUsIC8vIGNsb25lZFxuICAgICAgICAgICAgICAgIGkgICAgPSAwO1xuXG4gICAgICAgICAgICBkYXRlLnNldE1vbnRoKDApO1xuICAgICAgICAgICAgZGF0ZS5zZXREYXRlKDEpO1xuXG4gICAgICAgICAgICBmb3IgKDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtZS52ZG9tLmNuWzBdLmNuWzFdLmNuW2ldLmNuWzddLnJlbW92ZURvbSA9IERhdGVVdGlsLmdldFdlZWtzT2ZNb250aChkYXRlLCBtZS53ZWVrU3RhcnREYXkpID09PSA1ICYmICF2YWx1ZTtcbiAgICAgICAgICAgICAgICBkYXRlLnNldE1vbnRoKGRhdGUuZ2V0TW9udGgoKSArIDEpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHdlZWtTdGFydERheSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRXZWVrU3RhcnREYXkodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5jcmVhdGVNb250aHMoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGRheU5hbWVGb3JtYXQgY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXREYXlOYW1lRm9ybWF0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnZGF5TmFtZUZvcm1hdCcsIERhdGVVdGlsLnByb3RvdHlwZS5kYXlOYW1lRm9ybWF0cylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBtb250aE5hbWVGb3JtYXQgY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRNb250aE5hbWVGb3JtYXQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlZm9yZVNldEVudW1WYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICdtb250aE5hbWVGb3JtYXQnLCBEYXRlVXRpbC5wcm90b3R5cGUubW9udGhOYW1lRm9ybWF0cylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdG9yZXMgdGhlIGxhc3QgZGF0ZSBjaGFuZ2Ugd2hpY2ggY291bGQgbm90IGdldCBhcHBsaWVkIHdoaWxlIGEgdHJhbnNpdGlvbiB3YXMgcnVubmluZ1xuICAgICAqIEBwYXJhbSB7RGF0ZX0gW2RhdGU9dGhpcy5jdXJyZW50RGF0ZV1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY2FjaGVVcGRhdGUoZGF0ZT10aGlzLmN1cnJlbnREYXRlKSB7XG4gICAgICAgIHRoaXMuY2FjaGVkVXBkYXRlID0gZGF0ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmNyZW1lbnRcbiAgICAgKi9cbiAgICBjaGFuZ2VZZWFyKGluY3JlbWVudCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgc2Nyb2xsRnJvbVRvcCwgdmRvbSwgeTtcblxuICAgICAgICBpZiAoIW1lLnVzZUFuaW1hdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIG1lLnJlY3JlYXRlQ29udGVudChpbmNyZW1lbnQpOyAvLyB0b2RvXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIW1lLmlzVXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICBtZS5pc1VwZGF0aW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIG1lLmdldERvbVJlY3QoKS50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxGcm9tVG9wID0gbWUuc2Nyb2xsTmV3WWVhckZyb21Ub3AgJiYgaW5jcmVtZW50IDwgMCB8fCAhbWUuc2Nyb2xsTmV3WWVhckZyb21Ub3AgJiYgaW5jcmVtZW50ID4gMDtcbiAgICAgICAgICAgICAgICAgICAgdmRvbSAgICAgICAgICA9IG1lLnZkb207XG4gICAgICAgICAgICAgICAgICAgIHkgICAgICAgICAgICAgPSBzY3JvbGxGcm9tVG9wID8gMCA6IC1kYXRhLmhlaWdodDtcblxuICAgICAgICAgICAgICAgICAgICB2ZG9tLmNuLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1yZWxhdGl2ZSddLCBjbjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLWFuaW1hdGlvbi13cmFwcGVyJ10sIGNuOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLWNvbnRlbnQtd3JhcHBlciddLCBjbjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2NsczogWyduZW8teWVhci1oZWFkZXInXSwgY246IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dGV4dDogbWUuY3VycmVudERhdGUuZ2V0RnVsbFllYXIoKX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2NsczogWyduZW8tbmF2LWJ1dHRvbicsICduZW8tcHJldi1idXR0b24nXX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2NsczogWyduZW8tbmF2LWJ1dHRvbicsICduZW8tbmV4dC1idXR0b24nXX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF19LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2NsczogWyduZW8tbW9udGhzLWNvbnRhaW5lciddfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ICAgOiBgJHsyICogZGF0YS5oZWlnaHR9cHhgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGVZKCR7eX1weClgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCAgICA6IGAke2RhdGEud2lkdGh9cHhgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgIF19XG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgbWUuY3JlYXRlTW9udGhzKHRydWUsIHZkb20uY25bMV0uY25bMF0uY25bMF0uY25bMV0pO1xuICAgICAgICAgICAgICAgICAgICB2ZG9tLmNuWzFdLmNuWzBdLmNuW3Njcm9sbEZyb21Ub3AgPyAndW5zaGlmdCcgOiAncHVzaCddKHZkb20uY25bMF0pO1xuICAgICAgICAgICAgICAgICAgICB2ZG9tLmNuLnNwbGljZSgwLCAxKTtcblxuICAgICAgICAgICAgICAgICAgICBtZS5wcm9taXNlVXBkYXRlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gc2Nyb2xsRnJvbVRvcCA/IC1kYXRhLmhlaWdodCA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ZG9tLmNuWzBdLmNuWzBdLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGVZKCR7eX1weClgO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUudXBkYXRlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLnRpbWVvdXQoMzAwKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZG9tLmNuWzBdID0gdmRvbS5jblswXS5jblswXS5jbltzY3JvbGxGcm9tVG9wID8gMSA6IDBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLnRyaWdnZXJWZG9tVXBkYXRlKClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgY3JlYXRlRGF5TmFtZXNSb3coKSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIGRhdGUgPSBtZS5jdXJyZW50RGF0ZSwgLy8gY2xvbmVkXG4gICAgICAgICAgICBpICAgID0gMCxcbiAgICAgICAgICAgIHJvdyAgPSB7Y2xzOiBbJ25lby1jYWxlbmRhci13ZWVrJ10sIGNuOiBbe2NsczogWyduZW8tY2VsbCcsICduZW8tdG9wLWxlZnQtc3BhY2VyJ119XX0sXG4gICAgICAgICAgICBkYXksIG5vZGU7XG5cbiAgICAgICAgZGF0ZS5zZXREYXRlKG1lLmN1cnJlbnREYXRlLmdldERhdGUoKSAtIG1lLmN1cnJlbnREYXRlLmdldERheSgpICsgbWUud2Vla1N0YXJ0RGF5KTtcblxuICAgICAgICBmb3IgKDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgbm9kZSA9IHtcbiAgICAgICAgICAgICAgICBjbHMgOiBbJ25lby1jZWxsJywgJ25lby13ZWVrZGF5LWNlbGwnXSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBtZS5pbnRsRm9ybWF0X2RheS5mb3JtYXQoZGF0ZSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGRheSA9IGRhdGUuZ2V0RGF5KCk7XG5cbiAgICAgICAgICAgIGlmICghbWUuc2hvd1dlZWtlbmRzICYmIChkYXkgPT09IDAgfHwgZGF5ID09PSA2KSkge1xuICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlRG9tID0gdHJ1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByb3cuY24ucHVzaChub2RlKTtcblxuICAgICAgICAgICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgMSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByb3dcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGFpbmVyRWxcbiAgICAgKiBAcGFyYW0ge0RhdGV9IGN1cnJlbnREYXRlXG4gICAgICogQHJldHVybnMge09iamVjdH0gdmRvbVxuICAgICAqL1xuICAgIGNyZWF0ZU1vbnRoQ29udGVudChjb250YWluZXJFbCwgY3VycmVudERhdGUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjYWxlbmRhclN0b3JlLCBldmVudFN0b3JlfSA9IG1lLFxuICAgICAgICAgICAgY3VycmVudERheSAgICAgPSBjdXJyZW50RGF0ZS5nZXREYXRlKCksXG4gICAgICAgICAgICBjdXJyZW50TW9udGggICA9IGN1cnJlbnREYXRlLmdldE1vbnRoKCksXG4gICAgICAgICAgICBjdXJyZW50WWVhciAgICA9IGN1cnJlbnREYXRlLmdldEZ1bGxZZWFyKCksXG4gICAgICAgICAgICBkYXRlICAgICAgICAgICA9IERhdGVVdGlsLmNsb25lKGN1cnJlbnREYXRlKSxcbiAgICAgICAgICAgIHZhbHVlRGF0ZSAgICAgID0gbWUuY3VycmVudERhdGUsIC8vIGNsb25lZFxuICAgICAgICAgICAgdmFsdWVNb250aCAgICAgPSB2YWx1ZURhdGUuZ2V0TW9udGgoKSxcbiAgICAgICAgICAgIHZhbHVlWWVhciAgICAgID0gdmFsdWVEYXRlLmdldEZ1bGxZZWFyKCksXG4gICAgICAgICAgICBkYXlzSW5Nb250aCAgICA9IERhdGVVdGlsLmdldERheXNJbk1vbnRoKGN1cnJlbnREYXRlKSxcbiAgICAgICAgICAgIGZpcnN0RGF5T2Zmc2V0ID0gRGF0ZVV0aWwuZ2V0Rmlyc3REYXlPZmZzZXQoY3VycmVudERhdGUsIG1lLndlZWtTdGFydERheSksXG4gICAgICAgICAgICBjb2x1bW5zICAgICAgICA9IDcsXG4gICAgICAgICAgICBpICAgICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICB3ZWVrRGF0ZSAgICAgICA9IERhdGVVdGlsLmNsb25lKGN1cnJlbnREYXRlKSxcbiAgICAgICAgICAgIGNlbGxJZCwgY29uZmlnLCBjb25maWdDbHMsIGRhdGVEYXksIGRheSwgZGF5UmVjb3JkcywgaGFzQ29udGVudCwgaiwgcm93LCByb3dzO1xuXG4gICAgICAgIHJvd3MgPSAoZGF5c0luTW9udGggKyBmaXJzdERheU9mZnNldCkgLyA3ID4gNSA/IDYgOiA1O1xuICAgICAgICBkYXkgID0gMSAtIGZpcnN0RGF5T2Zmc2V0O1xuXG4gICAgICAgIGRhdGUuc2V0RGF0ZShkYXkpO1xuICAgICAgICB3ZWVrRGF0ZS5zZXREYXRlKGRheSArIDcpO1xuXG4gICAgICAgIGZvciAoOyBpIDwgNjsgaSsrKSB7XG4gICAgICAgICAgICByb3cgPSB7XG4gICAgICAgICAgICAgICAgY2xzICAgICAgOiBbJ25lby1jYWxlbmRhci13ZWVrJ10sXG4gICAgICAgICAgICAgICAgcmVtb3ZlRG9tOiBpID09PSByb3dzICYmICFtZS5zaXhXZWVrc1Blck1vbnRoLFxuXG4gICAgICAgICAgICAgICAgY246IFt7XG4gICAgICAgICAgICAgICAgICAgIGNscyAgICAgIDogWyduZW8tY2VsbCcsICduZW8td2Vla251bWJlci1jZWxsJ10sXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZURvbTogIW1lLnNob3dXZWVrTnVtYmVycyxcbiAgICAgICAgICAgICAgICAgICAgdGV4dCAgICAgOiBEYXRlVXRpbC5nZXRXZWVrT2ZZZWFyKHdlZWtEYXRlKVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB3ZWVrRGF0ZS5zZXREYXRlKHdlZWtEYXRlLmdldERhdGUoKSArIDcpO1xuXG4gICAgICAgICAgICBmb3IgKGo9MDsgaiA8IGNvbHVtbnM7IGorKykge1xuICAgICAgICAgICAgICAgIGhhc0NvbnRlbnQgPSBkYXkgPiAwICYmIGRheSA8PSBkYXlzSW5Nb250aDtcbiAgICAgICAgICAgICAgICBjZWxsSWQgICAgID0gbWUuZ2V0Q2VsbElkKGN1cnJlbnRZZWFyLCBjdXJyZW50TW9udGggKyAxLCBkYXkpO1xuICAgICAgICAgICAgICAgIGRhdGVEYXkgICAgPSBkYXRlLmdldERheSgpO1xuXG4gICAgICAgICAgICAgICAgY29uZmlnID0ge1xuICAgICAgICAgICAgICAgICAgICBpZCAgICAgIDogY2VsbElkLFxuICAgICAgICAgICAgICAgICAgICBjbHMgICAgIDogaGFzQ29udGVudCA/IFsnbmVvLWNlbGwnXSA6IFsnbmVvLWNlbGwnLCAnbmVvLWRpc2FibGVkJ10sXG4gICAgICAgICAgICAgICAgICAgIHRhYkluZGV4OiBoYXNDb250ZW50ID8gLTEgOiBudWxsLFxuXG4gICAgICAgICAgICAgICAgICAgIGNuOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xzIDogWyduZW8tY2VsbC1jb250ZW50J10sXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBoYXNDb250ZW50ID8gZGF5IDogbWUuc2hvd0Rpc2FibGVkRGF5cyA/IGRhdGUuZ2V0RGF0ZSgpIDogJydcbiAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgY29uZmlnQ2xzID0gY29uZmlnLmNscztcblxuICAgICAgICAgICAgICAgIGlmIChkYXRlRGF5ID09PSAwIHx8IGRhdGVEYXkgPT09IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnQ2xzLnB1c2goJ25lby13ZWVrZW5kJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtZS5zaG93V2Vla2VuZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5yZW1vdmVEb20gPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgIGlmICh0b2RheS55ZWFyID09PSBjdXJyZW50WWVhciAmJiB0b2RheS5tb250aCA9PT0gY3VycmVudE1vbnRoICYmIHRvZGF5LmRheSA9PT0gZGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5jblswXS5jbHMucHVzaCgnbmVvLXRvZGF5JylcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWVZZWFyID09PSBjdXJyZW50WWVhciAmJiB2YWx1ZU1vbnRoID09PSBjdXJyZW50TW9udGggJiYgZGF5ID09PSBjdXJyZW50RGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ0Nscy5wdXNoKCduZW8tc2VsZWN0ZWQnKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghY29uZmlnLnJlbW92ZURvbSkge1xuICAgICAgICAgICAgICAgICAgICBkYXlSZWNvcmRzID0gZXZlbnRTdG9yZS5nZXREYXlSZWNvcmRzKGRhdGUpO1xuICAgICAgICAgICAgICAgICAgICBkYXlSZWNvcmRzID0gZGF5UmVjb3Jkcy5maWx0ZXIocmVjb3JkID0+IGNhbGVuZGFyU3RvcmUuZ2V0KHJlY29yZC5jYWxlbmRhcklkKS5hY3RpdmUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRheVJlY29yZHMubGVuZ3RoID49IG1lLmV2ZW50SW5kaWNhdG9ySGlnaCkgICB7Y29uZmlnQ2xzLnB1c2goJ25lby1ldmVudHMtaGlnaCcpO31cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGF5UmVjb3Jkcy5sZW5ndGggPj0gbWUuZXZlbnRJbmRpY2F0b3JNZWRpdW0pIHtjb25maWdDbHMucHVzaCgnbmVvLWV2ZW50cy1tZWRpdW0nKTt9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRheVJlY29yZHMubGVuZ3RoID49IG1lLmV2ZW50SW5kaWNhdG9yTG93KSAgICB7Y29uZmlnQ2xzLnB1c2goJ25lby1ldmVudHMtbG93Jyk7fVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJvdy5jbi5wdXNoKGNvbmZpZyk7XG5cbiAgICAgICAgICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyAxKTtcblxuICAgICAgICAgICAgICAgIGRheSsrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRhaW5lckVsLmNuLnB1c2gocm93KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lckVsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2lsZW50PWZhbHNlXSB0cnVlIHRvIHVwZGF0ZSB0aGUgdmRvbSBzaWxlbnRseVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGFpbmVyRWxdXG4gICAgICovXG4gICAgY3JlYXRlTW9udGhzKHNpbGVudD1mYWxzZSwgY29udGFpbmVyRWwpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIW1lLm1vdW50ZWQpIHtcbiAgICAgICAgICAgIG1lLm5lZWRzRXZlbnRVcGRhdGUgPSB0cnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudERhdGUgICAgPSBtZS5jdXJyZW50RGF0ZSwgLy8gY2xvbmVkXG4gICAgICAgICAgICAgICAge3Zkb219ICAgICAgICAgPSBtZSxcbiAgICAgICAgICAgICAgICBtb250aENvbnRhaW5lciA9IGNvbnRhaW5lckVsIHx8IHZkb20uY25bMF0uY25bMV0sXG4gICAgICAgICAgICAgICAgaSAgICAgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgICAgIG1vbnRoVmRvbTtcblxuICAgICAgICAgICAgbW9udGhDb250YWluZXIuY24gPSBbXTtcblxuICAgICAgICAgICAgZm9yICg7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudERhdGUuc2V0TW9udGgoaSk7XG4gICAgICAgICAgICAgICAgY3VycmVudERhdGUuc2V0RGF0ZSgxKTtcblxuICAgICAgICAgICAgICAgIG1vbnRoVmRvbSA9XG4gICAgICAgICAgICAgICAge2NsczogWyduZW8tbW9udGgnXSwgY246IFtcbiAgICAgICAgICAgICAgICAgICAge2NsczogWyduZW8tbW9udGgtbmFtZSddLCB0ZXh0OiBtZS5pbnRsRm9ybWF0X21vbnRoLmZvcm1hdChjdXJyZW50RGF0ZSl9LFxuICAgICAgICAgICAgICAgICAgICBtZS5jcmVhdGVEYXlOYW1lc1JvdygpXG4gICAgICAgICAgICAgICAgXX07XG5cbiAgICAgICAgICAgICAgICBtb250aFZkb20gPSBtZS5jcmVhdGVNb250aENvbnRlbnQobW9udGhWZG9tLCBEYXRlVXRpbC5jbG9uZShjdXJyZW50RGF0ZSkpO1xuXG4gICAgICAgICAgICAgICAgbW9udGhDb250YWluZXIuY24ucHVzaChtb250aFZkb20pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICFzaWxlbnQgJiYgbWUudXBkYXRlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30geWVhclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gbW9udGhcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGRheVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IGlkXG4gICAgICovXG4gICAgZ2V0Q2VsbElkKHllYXIsIG1vbnRoLCBkYXkpIHtcbiAgICAgICAgZGF5ID0gZGF5LnRvU3RyaW5nKCk7XG5cbiAgICAgICAgaWYgKGRheS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICBkYXkgPSAnMCcgKyBkYXlcbiAgICAgICAgfVxuXG4gICAgICAgIG1vbnRoID0gbW9udGgudG9TdHJpbmcoKTtcblxuICAgICAgICBpZiAobW9udGgubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgbW9udGggPSAnMCcgKyBtb250aFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuaWQgKyAnX18nICsgeWVhciArICctJyArIG1vbnRoICsgJy0nICsgZGF5XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YVxuICAgICAqL1xuICAgIG9uQ2FsZW5kYXJTdG9yZUxvYWQoZGF0YSkge1xuICAgICAgICB0aGlzLmV2ZW50U3RvcmUuZ2V0Q291bnQoKSA+IDAgJiYgdGhpcy5jcmVhdGVNb250aHMoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25DYWxlbmRhclN0b3JlUmVjb3JkQ2hhbmdlKGRhdGEpIHtcbiAgICAgICAgdGhpcy5jcmVhdGVNb250aHMoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGFcbiAgICAgKi9cbiAgICBvbkV2ZW50U3RvcmVMb2FkKGRhdGEpIHtcbiAgICAgICAgdGhpcy5jYWxlbmRhclN0b3JlLmdldENvdW50KCkgPiAwICYmIHRoaXMuY3JlYXRlTW9udGhzKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhXG4gICAgICovXG4gICAgb25FdmVudFN0b3JlUmVjb3JkQ2hhbmdlKGRhdGEpIHtcbiAgICAgICAgdGhpcy5jcmVhdGVNb250aHMoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25OYXZCdXR0b25DbGljayhkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjdXJyZW50RGF0ZX0gPSBtZTsgLy8gY2xvbmVkXG5cbiAgICAgICAgY3VycmVudERhdGUuc2V0RnVsbFllYXIoY3VycmVudERhdGUuZ2V0RnVsbFllYXIoKSArIChkYXRhLnBhdGhbMF0uY2xzLmluY2x1ZGVzKCduZW8tbmV4dC1idXR0b24nKSA/IDEgOiAtMSkpO1xuXG4gICAgICAgIG1lLmN1cnJlbnREYXRlID0gY3VycmVudERhdGVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uV2hlZWwoZGF0YSkge1xuICAgICAgICBpZiAoTWF0aC5hYnMoZGF0YS5kZWx0YVkpID4gTWF0aC5hYnMoZGF0YS5kZWx0YVgpKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAge2N1cnJlbnREYXRlfSA9IG1lOyAvLyBjbG9uZWRcblxuICAgICAgICAgICAgY3VycmVudERhdGUuc2V0RnVsbFllYXIoY3VycmVudERhdGUuZ2V0RnVsbFllYXIoKSArIChkYXRhLmRlbHRhWSA+IDAgPyAxIDogLTEpKTtcblxuICAgICAgICAgICAgbWUuY3VycmVudERhdGUgPSBjdXJyZW50RGF0ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcnMgYSB2ZG9tIHVwZGF0ZSAmIHNldHMgaXNVcGRhdGluZ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbGVudD1mYWxzZV1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdHJpZ2dlclZkb21VcGRhdGUoc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgICAgICBtZS5pc1VwZGF0aW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgbWUucHJvbWlzZVVwZGF0ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1lLmlzVXBkYXRpbmcgPSBmYWxzZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIER5bmFtaWNhbGx5IHVwZGF0ZSB0aGUgd2Vla2RheSByb3dzIGluc2lkZSBlYWNoIG1vbnRoXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2lsZW50PWZhbHNlXVxuICAgICAqL1xuICAgIHVwZGF0ZURheU5hbWVzUm93cyh2YWx1ZSwgb2xkVmFsdWUsIHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmludGxGb3JtYXRfZGF5ID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobWUubG9jYWxlLCB7d2Vla2RheTogdmFsdWV9KTtcblxuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IGRhdGUgICA9IG1lLmN1cnJlbnREYXRlLCAvLyBjbG9uZWRcbiAgICAgICAgICAgICAgICB7dmRvbX0gPSBtZSxcbiAgICAgICAgICAgICAgICBpICAgICAgPSAxLFxuICAgICAgICAgICAgICAgIGRheSwgaiwgbm9kZTtcblxuICAgICAgICAgICAgZGF0ZS5zZXREYXRlKG1lLmN1cnJlbnREYXRlLmdldERhdGUoKSAtIG1lLmN1cnJlbnREYXRlLmdldERheSgpICsgbWUud2Vla1N0YXJ0RGF5KTtcblxuICAgICAgICAgICAgZm9yICg7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGo9MDsgaiA8IDEyOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZGF5ICA9IGRhdGUuZ2V0RGF5KCk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSB2ZG9tLmNuWzBdLmNuWzFdLmNuW2pdLmNuWzFdLmNuW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIG5vZGUudGV4dCA9IG1lLmludGxGb3JtYXRfZGF5LmZvcm1hdChkYXRlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIW1lLnNob3dXZWVrZW5kcyAmJiAoZGF5ID09PSAwIHx8IGRheSA9PT0gNikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlRG9tID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG5vZGUucmVtb3ZlRG9tXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyAxKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAhc2lsZW50ICYmIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHVwZGF0ZUhlYWRlclllYXIoKSB7XG4gICAgICAgIHRoaXMudmRvbS5jblswXS5jblswXS5jblswXS50ZXh0ID0gdGhpcy5jdXJyZW50RGF0ZS5nZXRGdWxsWWVhcigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHluYW1pY2FsbHkgdXBkYXRlIHRoZSBtb250aE5hbWVGb3JtYXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHVwZGF0ZU1vbnRoTmFtZUZvcm1hdCh2YWx1ZSwgb2xkVmFsdWUsIHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmludGxGb3JtYXRfbW9udGggPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChtZS5sb2NhbGUsIHttb250aDogdmFsdWV9KTtcblxuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IHtjdXJyZW50RGF0ZSwgdmRvbX0gPSBtZSxcbiAgICAgICAgICAgICAgICBpICAgICAgICAgICAgICAgICAgID0gMDtcblxuICAgICAgICAgICAgZm9yICg7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudERhdGUuc2V0TW9udGgoaSk7XG4gICAgICAgICAgICAgICAgY3VycmVudERhdGUuc2V0RGF0ZSgxKTtcblxuICAgICAgICAgICAgICAgIHZkb20uY25bMF0uY25bMV0uY25baV0uY25bMF0udGV4dCA9IG1lLmludGxGb3JtYXRfbW9udGguZm9ybWF0KGN1cnJlbnREYXRlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAhc2lsZW50ICYmIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFllYXJDb21wb25lbnQpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9