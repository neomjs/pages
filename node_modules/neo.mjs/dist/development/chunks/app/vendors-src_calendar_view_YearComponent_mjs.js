"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_calendar_view_YearComponent_mjs"],{

/***/ "./src/calendar/view/YearComponent.mjs":
/*!*********************************************!*\
  !*** ./src/calendar/view/YearComponent.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Date.mjs */ "./src/util/Date.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");




const todayDate = new Date();

const today = {
    day  : todayDate.getDate(),
    month: todayDate.getMonth(),
    year : todayDate.getFullYear()
};

/**
 * @class Neo.calendar.view.YearComponent
 * @extends Neo.component.Base
 */
class YearComponent extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.calendar.view.YearComponent'
         * @protected
         */
        className: 'Neo.calendar.view.YearComponent',
        /**
         * @member {String[]} baseCls=['neo-calendar-yearcomponent']
         */
        baseCls: ['neo-calendar-yearcomponent'],
        /**
         * @member {Object} bind
         */
        bind: {
            calendarStore       : 'stores.calendars',
            currentDate         : data => data.currentDate,
            eventStore          : 'stores.events',
            locale              : data => data.locale,
            scrollNewYearFromTop: data => data.scrollNewYearFromTop,
            showWeekends        : data => data.showWeekends,
            weekStartDay        : data => data.weekStartDay
        },
        /**
         * Stores the last date change which got triggered while a year transition was running
         * @member {Date|null} cachedUpdate=null
         * @protected
         */
        cachedUpdate: null,
        /**
         * Bound to the view model.
         * @member {Neo.calendar.store.Calendars|null} calendarStore_=null
         */
        calendarStore_: null,
        /**
         * Will get passed from the MainContainer
         * @member {Date|null} currentDate_=null
         * @protected
         */
        currentDate_: null,
        /**
         * The format of the column headers.
         * Valid values are: narrow, short & long
         * @member {String} dayNameFormat_='narrow'
         */
        dayNameFormat_: 'narrow',
        /**
         * @member {Number} eventIndicatorHigh_=3
         */
        eventIndicatorHigh_: 3,
        /**
         * @member {Number} eventIndicatorLow_=1
         */
        eventIndicatorLow_: 1,
        /**
         * @member {Number} eventIndicatorMedium_=2
         */
        eventIndicatorMedium_: 2,
        /**
         * Bound to the view model.
         * @member {Neo.calendar.store.Events|null} eventStore_=null
         */
        eventStore_: null,
        /**
         * @member {Intl.DateTimeFormat|null} intlFormat_day=null
         * @protected
         */
        intlFormat_day: null,
        /**
         * @member {Intl.DateTimeFormat|null} intlFormat_month=null
         * @protected
         */
        intlFormat_month: null,
        /**
         * Internal flag to prevent changing the date while change animations are still running
         * @member {Boolean} isUpdating_=false
         * @protected
         */
        isUpdating_: false,
        /**
         * Bound to the view model.
         * @member {String} locale_=Neo.config.locale
         */
        locale_: Neo.config.locale,
        /**
         * The format of the month header names.
         * Valid values are: narrow, short & long
         * @member {String} monthNameFormat_='long'
         */
        monthNameFormat_: 'long',
        /**
         * Internal flag to store if createMonths() got called while not being mounted
         * @member {Boolean} needsEventUpdate=false
         * @protected
         */
        needsEventUpdate: false,
        /**
         * @member {Neo.calendar.view.MainContainer|null} owner=null
         * @protected
         */
        owner: null,
        /**
         * True to scroll new years in from the top
         * @member {Boolean} scrollNewYearFromTop=false
         */
        scrollNewYearFromTop: false,
        /**
         * True to show borders for the calendar month cells
         * @member {Boolean} showCellBorders_=false
         */
        showCellBorders_: false,
        /**
         * True to show the days of the previous or next month (not selectable)
         * @member {Boolean} showDisabledDays_=true
         */
        showDisabledDays_: true,
        /**
         * Bound to the view model.
         * @member {Boolean} showWeekends_=true
         */
        showWeekends_: true,
        /**
         * True to show the week number as the first column of each month
         * @member {Boolean} showWeekNumbers_=true
         */
        showWeekNumbers_: true,
        /**
         * True to show 6 weeks for each month, so that all months have the same height
         * @member {Boolean} sixWeeksPerMonth_=false
         */
        sixWeeksPerMonth_: false,
        /**
         * True to use sliding animations
         * @member {Boolean} useAnimations=true
         */
        useAnimations: true,
        /**
         * @member {Object} vdom
         */
        vdom:
        {cn: [
            {cls: ['neo-content-wrapper'], cn: [
                {cls: ['neo-year-header'], cn: [
                    {},
                    {cls: ['neo-nav-button', 'neo-prev-button']},
                    {cls: ['neo-nav-button', 'neo-next-button']}
                ]},
                {cls: ['neo-months-container']}
            ]}
        ]},
        /**
         * 0-6 => Sun-Sat
         * Bound to the view model.
         * @member {Number} weekStartDay_=0
         */
        weekStartDay_: 0
    }

    /**
     * @param config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.addDomListeners([
            {click: me.onNavButtonClick, delegate: '.neo-nav-button', scope: me},
            {wheel: me.onWheel, scope: me}
        ]);

        if (me.calendarStore.getCount() > 0 && me.eventStore.getCount() > 0) {
            me.createMonths(true) // silent update
        }

        me.updateHeaderYear()
    }

    /**
     * Triggered after the calendarStore config got changed
     * @param {Neo.calendar.store.Calendars|null} value
     * @param {Neo.calendar.store.Calendars|null} oldValue
     * @protected
     */
    afterSetCalendarStore(value, oldValue) {
        let me = this,

        listeners = {
            load        : me.onCalendarStoreLoad,
            recordChange: me.onCalendarStoreRecordChange,
            scope       : me
        };

        oldValue?.un(listeners);
        value   ?.on(listeners)
    }

    /**
     * Triggered after the currentDate config got changed
     * @param {Date} value
     * @param {Date} oldValue
     * @protected
     */
    afterSetCurrentDate(value, oldValue) {
        if (this.isConstructed) {
            let oldYear = oldValue.getFullYear(),
                year    = value   .getFullYear();

            if (year !== oldYear) {
                this.changeYear(year - oldYear)
            }
        }
    }

    /**
     * Triggered after the dayNameFormat config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetDayNameFormat(value, oldValue) {
        this.updateDayNamesRows(value, oldValue)
    }

    /**
     * Triggered after the eventIndicatorHigh config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetEventIndicatorHigh(value, oldValue) {
        oldValue !== undefined && this.createMonths()
    }

    /**
     * Triggered after the eventIndicatorLow config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetEventIndicatorLow(value, oldValue) {
        oldValue !== undefined && this.createMonths()
    }

    /**
     * Triggered after the eventIndicatorMedium config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetEventIndicatorMedium(value, oldValue) {
        oldValue !== undefined && this.createMonths()
    }

    /**
     * Triggered after the eventStore config got changed
     * @param {Neo.calendar.store.Events|null} value
     * @param {Neo.calendar.store.Events|null} oldValue
     * @protected
     */
    afterSetEventStore(value, oldValue) {
        let me = this,

        listeners = {
            load        : me.onEventStoreLoad,
            recordChange: me.onEventStoreRecordChange,
            scope       : me
        };

        oldValue?.un(listeners);
        value   ?.on(listeners)
    }

    /**
     * Triggered after the locale config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetLocale(value, oldValue) {
        if (oldValue !== undefined) {
            let me = this;

            me.updateDayNamesRows(me.dayNameFormat, '', true);
            me.updateMonthNameFormat(me.monthNameFormat, '')
        }
    }

    /**
     * Triggered after the monthNameFormat config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetMonthNameFormat(value, oldValue) {
        this.updateMonthNameFormat(value, oldValue)
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        let me = this;

        if (value && me.needsEventUpdate) {
            me.createMonths();
            me.needsEventUpdate = false
        }
    }

    /**
     * Triggered after the showCellBorders config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowCellBorders(value, oldValue) {
        let cls = this.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"][value ? 'add' : 'remove'](cls, 'neo-show-cell-borders');
        this.cls = cls
    }

    /**
     * Triggered after the showWeekends config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowWeekends(value, oldValue) {
        if (oldValue !== undefined) {
            let me     = this,
                {vdom} = me,
                i      = 0,
                item, itemCn, j, k, len;

            for (; i < 12; i++) { // months
                itemCn = vdom.cn[0].cn[1].cn[i].cn;
                len    = itemCn.length;

                for (j=1; j < len; j++) { // weeks
                    for (k=1; k < 8; k++) { // days
                        item = itemCn[j].cn[k];

                        if (item.cls.includes('neo-weekend')) {
                            if (value) {
                                delete item.removeDom
                            } else {
                                item.removeDom = true
                            }
                        }
                    }
                }
            }

            // triggers the vdom update
            me.updateDayNamesRows(me.dayNameFormat, '')
        }
    }

    /**
     * Triggered after the showWeekNumbers config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowWeekNumbers(value, oldValue) {
        if (oldValue !== undefined) {
            let me = this,
                i  = 0,
                itemCn, j, len;

            for (; i < 12; i++) {
                itemCn = me.vdom.cn[0].cn[1].cn[i].cn;
                len    = itemCn.length;

                for (j = 1; j < len; j++) {
                    itemCn[j].cn[0].removeDom = !value
                }
            }

            me.update()
        }
    }

    /**
     * Triggered after the sixWeeksPerMonth config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetSixWeeksPerMonth(value, oldValue) {
        if (oldValue !== undefined) {
            let me   = this,
                date = me.currentDate, // cloned
                i    = 0;

            date.setMonth(0);
            date.setDate(1);

            for (; i < 12; i++) {
                me.vdom.cn[0].cn[1].cn[i].cn[7].removeDom = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getWeeksOfMonth(date, me.weekStartDay) === 5 && !value;
                date.setMonth(date.getMonth() + 1)
            }

            me.update()
        }
    }

    /**
     * Triggered after the weekStartDay config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetWeekStartDay(value, oldValue) {
        oldValue !== undefined && this.createMonths()
    }

    /**
     * Triggered before the dayNameFormat config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetDayNameFormat(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'dayNameFormat', _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.dayNameFormats)
    }

    /**
     * Triggered before the monthNameFormat config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetMonthNameFormat(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'monthNameFormat', _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.monthNameFormats)
    }

    /**
     * Stores the last date change which could not get applied while a transition was running
     * @param {Date} [date=this.currentDate]
     * @protected
     */
    cacheUpdate(date=this.currentDate) {
        this.cachedUpdate = date
    }

    /**
     * @param {Number} increment
     */
    changeYear(increment) {
        let me = this,
            scrollFromTop, vdom, y;

        if (!me.useAnimations) {
            // me.recreateContent(increment); // todo
        } else {
            if (!me.isUpdating) {
                me.isUpdating = true;

                me.getDomRect().then(data => {
                    scrollFromTop = me.scrollNewYearFromTop && increment < 0 || !me.scrollNewYearFromTop && increment > 0;
                    vdom          = me.vdom;
                    y             = scrollFromTop ? 0 : -data.height;

                    vdom.cn.push(
                        {cls: ['neo-relative'], cn: [
                            {cls: ['neo-animation-wrapper'], cn: [
                                {cls: ['neo-content-wrapper'], cn: [
                                    {cls: ['neo-year-header'], cn: [
                                        {html: me.currentDate.getFullYear()},
                                        {cls: ['neo-nav-button', 'neo-prev-button']},
                                        {cls: ['neo-nav-button', 'neo-next-button']}
                                    ]},
                                    {cls: ['neo-months-container']}
                                ]}
                            ],
                            style: {
                                height   : `${2 * data.height}px`,
                                transform: `translateY(${y}px)`,
                                width    : `${data.width}px`
                            }}
                        ]}
                    );

                    me.createMonths(true, vdom.cn[1].cn[0].cn[0].cn[1]);
                    vdom.cn[1].cn[0].cn[scrollFromTop ? 'unshift' : 'push'](vdom.cn[0]);
                    vdom.cn.splice(0, 1);

                    me.promiseUpdate(vdom).then(() => {
                        y = scrollFromTop ? -data.height : 0;
                        vdom.cn[0].cn[0].style.transform = `translateY(${y}px)`;
                        me.update();

                        me.timeout(300).then(() => {
                            vdom.cn[0] = vdom.cn[0].cn[0].cn[scrollFromTop ? 1 : 0];
                            me.triggerVdomUpdate()
                        })
                    })
                })
            }
        }
    }

    /**
     *
     */
    createDayNamesRow() {
        let me   = this,
            date = me.currentDate, // cloned
            i    = 0,
            row  = {cls: ['neo-calendar-week'], cn: [{cls: ['neo-cell', 'neo-top-left-spacer']}]},
            day, node;

        date.setDate(me.currentDate.getDate() - me.currentDate.getDay() + me.weekStartDay);

        for (; i < 7; i++) {
            node = {
                cls : ['neo-cell', 'neo-weekday-cell'],
                html: me.intlFormat_day.format(date)
            };

            day = date.getDay();

            if (!me.showWeekends && (day === 0 || day === 6)) {
                node.removeDom = true
            }

            row.cn.push(node);

            date.setDate(date.getDate() + 1)
        }

        return row
    }

    /**
     * @param {Object} containerEl
     * @param {Date} currentDate
     * @returns {Object} vdom
     */
    createMonthContent(containerEl, currentDate) {
        let me             = this,
            {calendarStore, eventStore} = me,
            currentDay     = currentDate.getDate(),
            currentMonth   = currentDate.getMonth(),
            currentYear    = currentDate.getFullYear(),
            date           = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].clone(currentDate),
            valueDate      = me.currentDate, // cloned
            valueMonth     = valueDate.getMonth(),
            valueYear      = valueDate.getFullYear(),
            daysInMonth    = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getDaysInMonth(currentDate),
            firstDayOffset = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getFirstDayOffset(currentDate, me.weekStartDay),
            columns        = 7,
            i              = 0,
            weekDate       = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].clone(currentDate),
            cellId, config, configCls, dateDay, day, dayRecords, hasContent, j, row, rows;

        rows = (daysInMonth + firstDayOffset) / 7 > 5 ? 6 : 5;
        day  = 1 - firstDayOffset;

        date.setDate(day);
        weekDate.setDate(day + 7);

        for (; i < 6; i++) {
            row = {
                cls      : ['neo-calendar-week'],
                removeDom: i === rows && !me.sixWeeksPerMonth,

                cn: [{
                    cls      : ['neo-cell', 'neo-weeknumber-cell'],
                    html     : _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getWeekOfYear(weekDate),
                    removeDom: !me.showWeekNumbers
                }]
            };

            weekDate.setDate(weekDate.getDate() + 7);

            for (j=0; j < columns; j++) {
                hasContent = day > 0 && day <= daysInMonth;
                cellId     = me.getCellId(currentYear, currentMonth + 1, day);
                dateDay    = date.getDay();

                config = {
                    id      : cellId,
                    cls     : hasContent ? ['neo-cell'] : ['neo-cell', 'neo-disabled'],
                    tabIndex: hasContent ? -1 : null,

                    cn: [{
                        cls : ['neo-cell-content'],
                        html: hasContent ? day : me.showDisabledDays ? date.getDate() : ''
                    }]
                };

                configCls = config.cls;

                if (dateDay === 0 || dateDay === 6) {
                    configCls.push('neo-weekend');

                    if (!me.showWeekends) {
                        config.removeDom = true
                    }
                }


                if (today.year === currentYear && today.month === currentMonth && today.day === day) {
                    config.cn[0].cls.push('neo-today')
                }

                if (valueYear === currentYear && valueMonth === currentMonth && day === currentDay) {
                    configCls.push('neo-selected')
                }

                if (!config.removeDom) {
                    dayRecords = eventStore.getDayRecords(date);
                    dayRecords = dayRecords.filter(record => calendarStore.get(record.calendarId).active);

                         if (dayRecords.length >= me.eventIndicatorHigh)   {configCls.push('neo-events-high');}
                    else if (dayRecords.length >= me.eventIndicatorMedium) {configCls.push('neo-events-medium');}
                    else if (dayRecords.length >= me.eventIndicatorLow)    {configCls.push('neo-events-low');}
                }

                row.cn.push(config);

                date.setDate(date.getDate() + 1);

                day++
            }

            containerEl.cn.push(row)
        }

        return containerEl
    }

    /**
     * @param {Boolean} [silent=false] true to update the vdom silently
     * @param {Object} [containerEl]
     */
    createMonths(silent=false, containerEl) {
        let me = this;

        if (!me.mounted) {
            me.needsEventUpdate = true
        } else {
            let currentDate    = me.currentDate, // cloned
                {vdom}         = me,
                monthContainer = containerEl || vdom.cn[0].cn[1],
                i              = 0,
                monthVdom;

            monthContainer.cn = [];

            for (; i < 12; i++) {
                currentDate.setMonth(i);
                currentDate.setDate(1);

                monthVdom =
                {cls: ['neo-month'], cn: [
                    {cls: ['neo-month-name'], html: me.intlFormat_month.format(currentDate)},
                    me.createDayNamesRow()
                ]};

                monthVdom = me.createMonthContent(monthVdom, _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].clone(currentDate));

                monthContainer.cn.push(monthVdom)
            }

            !silent && me.update()
        }
    }

    /**
     * @param {Number|String} year
     * @param {Number|String} month
     * @param {Number|String} day
     * @returns {String} id
     */
    getCellId(year, month, day) {
        day = day.toString();

        if (day.length < 2) {
            day = '0' + day
        }

        month = month.toString();

        if (month.length < 2) {
            month = '0' + month
        }

        return this.id + '__' + year + '-' + month + '-' + day
    }

    /**
     * @param {Object[]} data
     */
    onCalendarStoreLoad(data) {
        this.eventStore.getCount() > 0 && this.createMonths()
    }

    /**
     * @param {Object} data
     */
    onCalendarStoreRecordChange(data) {
        this.createMonths()
    }

    /**
     * @param {Object[]} data
     */
    onEventStoreLoad(data) {
        this.calendarStore.getCount() > 0 && this.createMonths()
    }

    /**
     * @param {Object[]} data
     */
    onEventStoreRecordChange(data) {
        this.createMonths()
    }

    /**
     * @param {Object} data
     */
    onNavButtonClick(data) {
        let me            = this,
            {currentDate} = me; // cloned

        currentDate.setFullYear(currentDate.getFullYear() + (data.path[0].cls.includes('neo-next-button') ? 1 : -1));

        me.currentDate = currentDate
    }

    /**
     * @param {Object} data
     */
    onWheel(data) {
        if (Math.abs(data.deltaY) > Math.abs(data.deltaX)) {
            let me            = this,
                {currentDate} = me; // cloned

            currentDate.setFullYear(currentDate.getFullYear() + (data.deltaY > 0 ? 1 : -1));

            me.currentDate = currentDate
        }
    }

    /**
     * Triggers a vdom update & sets isUpdating
     * @param {Boolean} [silent=false]
     * @protected
     */
    triggerVdomUpdate(silent=false) {
        if (!silent) {
            let me = this;

            me.isUpdating = true;

            me.promiseUpdate(me.vdom).then(() => {
                me.isUpdating = false
            })
        }
    }

    /**
     * Dynamically update the weekday rows inside each month
     * @param {String} value
     * @param {String} oldValue
     * @param {Boolean} [silent=false]
     */
    updateDayNamesRows(value, oldValue, silent=false) {
        let me = this;

        me.intlFormat_day = new Intl.DateTimeFormat(me.locale, {weekday: value});

        if (oldValue !== undefined) {
            let date   = me.currentDate, // cloned
                {vdom} = me,
                i      = 1,
                day, j, node;

            date.setDate(me.currentDate.getDate() - me.currentDate.getDay() + me.weekStartDay);

            for (; i < 8; i++) {
                for (j=0; j < 12; j++) {
                    day  = date.getDay();
                    node = vdom.cn[0].cn[1].cn[j].cn[1].cn[i];

                    node.html = me.intlFormat_day.format(date);

                    if (!me.showWeekends && (day === 0 || day === 6)) {
                        node.removeDom = true
                    } else {
                        delete node.removeDom
                    }
                }

                date.setDate(date.getDate() + 1)
            }

            !silent && me.update()
        }
    }

    /**
     *
     */
    updateHeaderYear() {
        this.vdom.cn[0].cn[0].cn[0].html = this.currentDate.getFullYear()
    }

    /**
     * Dynamically update the monthNameFormat
     * @param {String} value
     * @param {String} oldValue
     * @param {Boolean} [silent=false]
     * @protected
     */
    updateMonthNameFormat(value, oldValue, silent=false) {
        let me = this;

        me.intlFormat_month = new Intl.DateTimeFormat(me.locale, {month: value});

        if (oldValue !== undefined) {
            let {currentDate, vdom} = me,
                i                   = 0;

            for (; i < 12; i++) {
                currentDate.setMonth(i);
                currentDate.setDate(1);

                vdom.cn[0].cn[1].cn[i].cn[0].html = me.intlFormat_month.format(currentDate)
            }

            !silent && me.update()
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(YearComponent));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19jYWxlbmRhcl92aWV3X1llYXJDb21wb25lbnRfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUQ7QUFDTDtBQUNDOztBQUU3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJEQUFTO0FBQ3JDO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQ0FBbUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQ0FBZ0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNB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O0FBQ0EsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsT0FBTztBQUMxQiwwQkFBMEIsUUFBUTtBQUNsQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0VBQWtFLGFBQWE7O0FBRS9FO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQzs7QUFFQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsNkJBQTZCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NhbGVuZGFyL3ZpZXcvWWVhckNvbXBvbmVudC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi8uLi9jb21wb25lbnQvQmFzZS5tanMnO1xuaW1wb3J0IERhdGVVdGlsICBmcm9tICcuLi8uLi91dGlsL0RhdGUubWpzJztcbmltcG9ydCBOZW9BcnJheSAgZnJvbSAnLi4vLi4vdXRpbC9BcnJheS5tanMnO1xuXG5jb25zdCB0b2RheURhdGUgPSBuZXcgRGF0ZSgpO1xuXG5jb25zdCB0b2RheSA9IHtcbiAgICBkYXkgIDogdG9kYXlEYXRlLmdldERhdGUoKSxcbiAgICBtb250aDogdG9kYXlEYXRlLmdldE1vbnRoKCksXG4gICAgeWVhciA6IHRvZGF5RGF0ZS5nZXRGdWxsWWVhcigpXG59O1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uY2FsZW5kYXIudmlldy5ZZWFyQ29tcG9uZW50XG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqL1xuY2xhc3MgWWVhckNvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY2FsZW5kYXIudmlldy5ZZWFyQ29tcG9uZW50J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY2FsZW5kYXIudmlldy5ZZWFyQ29tcG9uZW50JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWNhbGVuZGFyLXllYXJjb21wb25lbnQnXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tY2FsZW5kYXIteWVhcmNvbXBvbmVudCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBiaW5kXG4gICAgICAgICAqL1xuICAgICAgICBiaW5kOiB7XG4gICAgICAgICAgICBjYWxlbmRhclN0b3JlICAgICAgIDogJ3N0b3Jlcy5jYWxlbmRhcnMnLFxuICAgICAgICAgICAgY3VycmVudERhdGUgICAgICAgICA6IGRhdGEgPT4gZGF0YS5jdXJyZW50RGF0ZSxcbiAgICAgICAgICAgIGV2ZW50U3RvcmUgICAgICAgICAgOiAnc3RvcmVzLmV2ZW50cycsXG4gICAgICAgICAgICBsb2NhbGUgICAgICAgICAgICAgIDogZGF0YSA9PiBkYXRhLmxvY2FsZSxcbiAgICAgICAgICAgIHNjcm9sbE5ld1llYXJGcm9tVG9wOiBkYXRhID0+IGRhdGEuc2Nyb2xsTmV3WWVhckZyb21Ub3AsXG4gICAgICAgICAgICBzaG93V2Vla2VuZHMgICAgICAgIDogZGF0YSA9PiBkYXRhLnNob3dXZWVrZW5kcyxcbiAgICAgICAgICAgIHdlZWtTdGFydERheSAgICAgICAgOiBkYXRhID0+IGRhdGEud2Vla1N0YXJ0RGF5XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9yZXMgdGhlIGxhc3QgZGF0ZSBjaGFuZ2Ugd2hpY2ggZ290IHRyaWdnZXJlZCB3aGlsZSBhIHllYXIgdHJhbnNpdGlvbiB3YXMgcnVubmluZ1xuICAgICAgICAgKiBAbWVtYmVyIHtEYXRlfG51bGx9IGNhY2hlZFVwZGF0ZT1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNhY2hlZFVwZGF0ZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJvdW5kIHRvIHRoZSB2aWV3IG1vZGVsLlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY2FsZW5kYXIuc3RvcmUuQ2FsZW5kYXJzfG51bGx9IGNhbGVuZGFyU3RvcmVfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGNhbGVuZGFyU3RvcmVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogV2lsbCBnZXQgcGFzc2VkIGZyb20gdGhlIE1haW5Db250YWluZXJcbiAgICAgICAgICogQG1lbWJlciB7RGF0ZXxudWxsfSBjdXJyZW50RGF0ZV89bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjdXJyZW50RGF0ZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZm9ybWF0IG9mIHRoZSBjb2x1bW4gaGVhZGVycy5cbiAgICAgICAgICogVmFsaWQgdmFsdWVzIGFyZTogbmFycm93LCBzaG9ydCAmIGxvbmdcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBkYXlOYW1lRm9ybWF0Xz0nbmFycm93J1xuICAgICAgICAgKi9cbiAgICAgICAgZGF5TmFtZUZvcm1hdF86ICduYXJyb3cnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBldmVudEluZGljYXRvckhpZ2hfPTNcbiAgICAgICAgICovXG4gICAgICAgIGV2ZW50SW5kaWNhdG9ySGlnaF86IDMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGV2ZW50SW5kaWNhdG9yTG93Xz0xXG4gICAgICAgICAqL1xuICAgICAgICBldmVudEluZGljYXRvckxvd186IDEsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGV2ZW50SW5kaWNhdG9yTWVkaXVtXz0yXG4gICAgICAgICAqL1xuICAgICAgICBldmVudEluZGljYXRvck1lZGl1bV86IDIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCb3VuZCB0byB0aGUgdmlldyBtb2RlbC5cbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNhbGVuZGFyLnN0b3JlLkV2ZW50c3xudWxsfSBldmVudFN0b3JlXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBldmVudFN0b3JlXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0ludGwuRGF0ZVRpbWVGb3JtYXR8bnVsbH0gaW50bEZvcm1hdF9kYXk9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBpbnRsRm9ybWF0X2RheTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0ludGwuRGF0ZVRpbWVGb3JtYXR8bnVsbH0gaW50bEZvcm1hdF9tb250aD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGludGxGb3JtYXRfbW9udGg6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBmbGFnIHRvIHByZXZlbnQgY2hhbmdpbmcgdGhlIGRhdGUgd2hpbGUgY2hhbmdlIGFuaW1hdGlvbnMgYXJlIHN0aWxsIHJ1bm5pbmdcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNVcGRhdGluZ189ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaXNVcGRhdGluZ186IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQm91bmQgdG8gdGhlIHZpZXcgbW9kZWwuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbG9jYWxlXz1OZW8uY29uZmlnLmxvY2FsZVxuICAgICAgICAgKi9cbiAgICAgICAgbG9jYWxlXzogTmVvLmNvbmZpZy5sb2NhbGUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZm9ybWF0IG9mIHRoZSBtb250aCBoZWFkZXIgbmFtZXMuXG4gICAgICAgICAqIFZhbGlkIHZhbHVlcyBhcmU6IG5hcnJvdywgc2hvcnQgJiBsb25nXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbW9udGhOYW1lRm9ybWF0Xz0nbG9uZydcbiAgICAgICAgICovXG4gICAgICAgIG1vbnRoTmFtZUZvcm1hdF86ICdsb25nJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGZsYWcgdG8gc3RvcmUgaWYgY3JlYXRlTW9udGhzKCkgZ290IGNhbGxlZCB3aGlsZSBub3QgYmVpbmcgbW91bnRlZFxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBuZWVkc0V2ZW50VXBkYXRlPWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG5lZWRzRXZlbnRVcGRhdGU6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNhbGVuZGFyLnZpZXcuTWFpbkNvbnRhaW5lcnxudWxsfSBvd25lcj1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG93bmVyOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSB0byBzY3JvbGwgbmV3IHllYXJzIGluIGZyb20gdGhlIHRvcFxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzY3JvbGxOZXdZZWFyRnJvbVRvcD1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgc2Nyb2xsTmV3WWVhckZyb21Ub3A6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSB0byBzaG93IGJvcmRlcnMgZm9yIHRoZSBjYWxlbmRhciBtb250aCBjZWxsc1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaG93Q2VsbEJvcmRlcnNfPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBzaG93Q2VsbEJvcmRlcnNfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgdG8gc2hvdyB0aGUgZGF5cyBvZiB0aGUgcHJldmlvdXMgb3IgbmV4dCBtb250aCAobm90IHNlbGVjdGFibGUpXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNob3dEaXNhYmxlZERheXNfPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIHNob3dEaXNhYmxlZERheXNfOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQm91bmQgdG8gdGhlIHZpZXcgbW9kZWwuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNob3dXZWVrZW5kc189dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2hvd1dlZWtlbmRzXzogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgdG8gc2hvdyB0aGUgd2VlayBudW1iZXIgYXMgdGhlIGZpcnN0IGNvbHVtbiBvZiBlYWNoIG1vbnRoXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNob3dXZWVrTnVtYmVyc189dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2hvd1dlZWtOdW1iZXJzXzogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgdG8gc2hvdyA2IHdlZWtzIGZvciBlYWNoIG1vbnRoLCBzbyB0aGF0IGFsbCBtb250aHMgaGF2ZSB0aGUgc2FtZSBoZWlnaHRcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2l4V2Vla3NQZXJNb250aF89ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHNpeFdlZWtzUGVyTW9udGhfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgdG8gdXNlIHNsaWRpbmcgYW5pbWF0aW9uc1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB1c2VBbmltYXRpb25zPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIHVzZUFuaW1hdGlvbnM6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHZkb21cbiAgICAgICAgICovXG4gICAgICAgIHZkb206XG4gICAgICAgIHtjbjogW1xuICAgICAgICAgICAge2NsczogWyduZW8tY29udGVudC13cmFwcGVyJ10sIGNuOiBbXG4gICAgICAgICAgICAgICAge2NsczogWyduZW8teWVhci1oZWFkZXInXSwgY246IFtcbiAgICAgICAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLW5hdi1idXR0b24nLCAnbmVvLXByZXYtYnV0dG9uJ119LFxuICAgICAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1uYXYtYnV0dG9uJywgJ25lby1uZXh0LWJ1dHRvbiddfVxuICAgICAgICAgICAgICAgIF19LFxuICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLW1vbnRocy1jb250YWluZXInXX1cbiAgICAgICAgICAgIF19XG4gICAgICAgIF19LFxuICAgICAgICAvKipcbiAgICAgICAgICogMC02ID0+IFN1bi1TYXRcbiAgICAgICAgICogQm91bmQgdG8gdGhlIHZpZXcgbW9kZWwuXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gd2Vla1N0YXJ0RGF5Xz0wXG4gICAgICAgICAqL1xuICAgICAgICB3ZWVrU3RhcnREYXlfOiAwXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5hZGREb21MaXN0ZW5lcnMoW1xuICAgICAgICAgICAge2NsaWNrOiBtZS5vbk5hdkJ1dHRvbkNsaWNrLCBkZWxlZ2F0ZTogJy5uZW8tbmF2LWJ1dHRvbicsIHNjb3BlOiBtZX0sXG4gICAgICAgICAgICB7d2hlZWw6IG1lLm9uV2hlZWwsIHNjb3BlOiBtZX1cbiAgICAgICAgXSk7XG5cbiAgICAgICAgaWYgKG1lLmNhbGVuZGFyU3RvcmUuZ2V0Q291bnQoKSA+IDAgJiYgbWUuZXZlbnRTdG9yZS5nZXRDb3VudCgpID4gMCkge1xuICAgICAgICAgICAgbWUuY3JlYXRlTW9udGhzKHRydWUpIC8vIHNpbGVudCB1cGRhdGVcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnVwZGF0ZUhlYWRlclllYXIoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgY2FsZW5kYXJTdG9yZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge05lby5jYWxlbmRhci5zdG9yZS5DYWxlbmRhcnN8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5jYWxlbmRhci5zdG9yZS5DYWxlbmRhcnN8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRDYWxlbmRhclN0b3JlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuXG4gICAgICAgIGxpc3RlbmVycyA9IHtcbiAgICAgICAgICAgIGxvYWQgICAgICAgIDogbWUub25DYWxlbmRhclN0b3JlTG9hZCxcbiAgICAgICAgICAgIHJlY29yZENoYW5nZTogbWUub25DYWxlbmRhclN0b3JlUmVjb3JkQ2hhbmdlLFxuICAgICAgICAgICAgc2NvcGUgICAgICAgOiBtZVxuICAgICAgICB9O1xuXG4gICAgICAgIG9sZFZhbHVlPy51bihsaXN0ZW5lcnMpO1xuICAgICAgICB2YWx1ZSAgID8ub24obGlzdGVuZXJzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgY3VycmVudERhdGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtEYXRlfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7RGF0ZX0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRDdXJyZW50RGF0ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDb25zdHJ1Y3RlZCkge1xuICAgICAgICAgICAgbGV0IG9sZFllYXIgPSBvbGRWYWx1ZS5nZXRGdWxsWWVhcigpLFxuICAgICAgICAgICAgICAgIHllYXIgICAgPSB2YWx1ZSAgIC5nZXRGdWxsWWVhcigpO1xuXG4gICAgICAgICAgICBpZiAoeWVhciAhPT0gb2xkWWVhcikge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlWWVhcih5ZWFyIC0gb2xkWWVhcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZGF5TmFtZUZvcm1hdCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXREYXlOYW1lRm9ybWF0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZURheU5hbWVzUm93cyh2YWx1ZSwgb2xkVmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBldmVudEluZGljYXRvckhpZ2ggY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RXZlbnRJbmRpY2F0b3JIaWdoKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuY3JlYXRlTW9udGhzKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGV2ZW50SW5kaWNhdG9yTG93IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEV2ZW50SW5kaWNhdG9yTG93KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuY3JlYXRlTW9udGhzKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGV2ZW50SW5kaWNhdG9yTWVkaXVtIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEV2ZW50SW5kaWNhdG9yTWVkaXVtKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuY3JlYXRlTW9udGhzKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGV2ZW50U3RvcmUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOZW8uY2FsZW5kYXIuc3RvcmUuRXZlbnRzfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uY2FsZW5kYXIuc3RvcmUuRXZlbnRzfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RXZlbnRTdG9yZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcblxuICAgICAgICBsaXN0ZW5lcnMgPSB7XG4gICAgICAgICAgICBsb2FkICAgICAgICA6IG1lLm9uRXZlbnRTdG9yZUxvYWQsXG4gICAgICAgICAgICByZWNvcmRDaGFuZ2U6IG1lLm9uRXZlbnRTdG9yZVJlY29yZENoYW5nZSxcbiAgICAgICAgICAgIHNjb3BlICAgICAgIDogbWVcbiAgICAgICAgfTtcblxuICAgICAgICBvbGRWYWx1ZT8udW4obGlzdGVuZXJzKTtcbiAgICAgICAgdmFsdWUgICA/Lm9uKGxpc3RlbmVycylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGxvY2FsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRMb2NhbGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgICAgICBtZS51cGRhdGVEYXlOYW1lc1Jvd3MobWUuZGF5TmFtZUZvcm1hdCwgJycsIHRydWUpO1xuICAgICAgICAgICAgbWUudXBkYXRlTW9udGhOYW1lRm9ybWF0KG1lLm1vbnRoTmFtZUZvcm1hdCwgJycpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1vbnRoTmFtZUZvcm1hdCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNb250aE5hbWVGb3JtYXQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlTW9udGhOYW1lRm9ybWF0KHZhbHVlLCBvbGRWYWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1vdW50ZWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiBtZS5uZWVkc0V2ZW50VXBkYXRlKSB7XG4gICAgICAgICAgICBtZS5jcmVhdGVNb250aHMoKTtcbiAgICAgICAgICAgIG1lLm5lZWRzRXZlbnRVcGRhdGUgPSBmYWxzZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzaG93Q2VsbEJvcmRlcnMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTaG93Q2VsbEJvcmRlcnModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBjbHMgPSB0aGlzLmNscztcblxuICAgICAgICBOZW9BcnJheVt2YWx1ZSA/ICdhZGQnIDogJ3JlbW92ZSddKGNscywgJ25lby1zaG93LWNlbGwtYm9yZGVycycpO1xuICAgICAgICB0aGlzLmNscyA9IGNsc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc2hvd1dlZWtlbmRzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U2hvd1dlZWtlbmRzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAge3Zkb219ID0gbWUsXG4gICAgICAgICAgICAgICAgaSAgICAgID0gMCxcbiAgICAgICAgICAgICAgICBpdGVtLCBpdGVtQ24sIGosIGssIGxlbjtcblxuICAgICAgICAgICAgZm9yICg7IGkgPCAxMjsgaSsrKSB7IC8vIG1vbnRoc1xuICAgICAgICAgICAgICAgIGl0ZW1DbiA9IHZkb20uY25bMF0uY25bMV0uY25baV0uY247XG4gICAgICAgICAgICAgICAgbGVuICAgID0gaXRlbUNuLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGZvciAoaj0xOyBqIDwgbGVuOyBqKyspIHsgLy8gd2Vla3NcbiAgICAgICAgICAgICAgICAgICAgZm9yIChrPTE7IGsgPCA4OyBrKyspIHsgLy8gZGF5c1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9IGl0ZW1DbltqXS5jbltrXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uY2xzLmluY2x1ZGVzKCduZW8td2Vla2VuZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBpdGVtLnJlbW92ZURvbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ucmVtb3ZlRG9tID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdHJpZ2dlcnMgdGhlIHZkb20gdXBkYXRlXG4gICAgICAgICAgICBtZS51cGRhdGVEYXlOYW1lc1Jvd3MobWUuZGF5TmFtZUZvcm1hdCwgJycpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNob3dXZWVrTnVtYmVycyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNob3dXZWVrTnVtYmVycyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICAgICAgaSAgPSAwLFxuICAgICAgICAgICAgICAgIGl0ZW1DbiwgaiwgbGVuO1xuXG4gICAgICAgICAgICBmb3IgKDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpdGVtQ24gPSBtZS52ZG9tLmNuWzBdLmNuWzFdLmNuW2ldLmNuO1xuICAgICAgICAgICAgICAgIGxlbiAgICA9IGl0ZW1Dbi5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGogPSAxOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbUNuW2pdLmNuWzBdLnJlbW92ZURvbSA9ICF2YWx1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUudXBkYXRlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc2l4V2Vla3NQZXJNb250aCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNpeFdlZWtzUGVyTW9udGgodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgZGF0ZSA9IG1lLmN1cnJlbnREYXRlLCAvLyBjbG9uZWRcbiAgICAgICAgICAgICAgICBpICAgID0gMDtcblxuICAgICAgICAgICAgZGF0ZS5zZXRNb250aCgwKTtcbiAgICAgICAgICAgIGRhdGUuc2V0RGF0ZSgxKTtcblxuICAgICAgICAgICAgZm9yICg7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbWUudmRvbS5jblswXS5jblsxXS5jbltpXS5jbls3XS5yZW1vdmVEb20gPSBEYXRlVXRpbC5nZXRXZWVrc09mTW9udGgoZGF0ZSwgbWUud2Vla1N0YXJ0RGF5KSA9PT0gNSAmJiAhdmFsdWU7XG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRNb250aChkYXRlLmdldE1vbnRoKCkgKyAxKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS51cGRhdGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB3ZWVrU3RhcnREYXkgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0V2Vla1N0YXJ0RGF5KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuY3JlYXRlTW9udGhzKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBkYXlOYW1lRm9ybWF0IGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0RGF5TmFtZUZvcm1hdCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ2RheU5hbWVGb3JtYXQnLCBEYXRlVXRpbC5wcm90b3R5cGUuZGF5TmFtZUZvcm1hdHMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgbW9udGhOYW1lRm9ybWF0IGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0TW9udGhOYW1lRm9ybWF0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnbW9udGhOYW1lRm9ybWF0JywgRGF0ZVV0aWwucHJvdG90eXBlLm1vbnRoTmFtZUZvcm1hdHMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RvcmVzIHRoZSBsYXN0IGRhdGUgY2hhbmdlIHdoaWNoIGNvdWxkIG5vdCBnZXQgYXBwbGllZCB3aGlsZSBhIHRyYW5zaXRpb24gd2FzIHJ1bm5pbmdcbiAgICAgKiBAcGFyYW0ge0RhdGV9IFtkYXRlPXRoaXMuY3VycmVudERhdGVdXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNhY2hlVXBkYXRlKGRhdGU9dGhpcy5jdXJyZW50RGF0ZSkge1xuICAgICAgICB0aGlzLmNhY2hlZFVwZGF0ZSA9IGRhdGVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5jcmVtZW50XG4gICAgICovXG4gICAgY2hhbmdlWWVhcihpbmNyZW1lbnQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIHNjcm9sbEZyb21Ub3AsIHZkb20sIHk7XG5cbiAgICAgICAgaWYgKCFtZS51c2VBbmltYXRpb25zKSB7XG4gICAgICAgICAgICAvLyBtZS5yZWNyZWF0ZUNvbnRlbnQoaW5jcmVtZW50KTsgLy8gdG9kb1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFtZS5pc1VwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgbWUuaXNVcGRhdGluZyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBtZS5nZXREb21SZWN0KCkudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsRnJvbVRvcCA9IG1lLnNjcm9sbE5ld1llYXJGcm9tVG9wICYmIGluY3JlbWVudCA8IDAgfHwgIW1lLnNjcm9sbE5ld1llYXJGcm9tVG9wICYmIGluY3JlbWVudCA+IDA7XG4gICAgICAgICAgICAgICAgICAgIHZkb20gICAgICAgICAgPSBtZS52ZG9tO1xuICAgICAgICAgICAgICAgICAgICB5ICAgICAgICAgICAgID0gc2Nyb2xsRnJvbVRvcCA/IDAgOiAtZGF0YS5oZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgdmRvbS5jbi5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAge2NsczogWyduZW8tcmVsYXRpdmUnXSwgY246IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1hbmltYXRpb24td3JhcHBlciddLCBjbjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1jb250ZW50LXdyYXBwZXInXSwgY246IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLXllYXItaGVhZGVyJ10sIGNuOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2h0bWw6IG1lLmN1cnJlbnREYXRlLmdldEZ1bGxZZWFyKCl9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLW5hdi1idXR0b24nLCAnbmVvLXByZXYtYnV0dG9uJ119LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLW5hdi1idXR0b24nLCAnbmVvLW5leHQtYnV0dG9uJ119XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLW1vbnRocy1jb250YWluZXInXX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCAgIDogYCR7MiAqIGRhdGEuaGVpZ2h0fXB4YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlWSgke3l9cHgpYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggICAgOiBgJHtkYXRhLndpZHRofXB4YFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgICAgICBdfVxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIG1lLmNyZWF0ZU1vbnRocyh0cnVlLCB2ZG9tLmNuWzFdLmNuWzBdLmNuWzBdLmNuWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgdmRvbS5jblsxXS5jblswXS5jbltzY3JvbGxGcm9tVG9wID8gJ3Vuc2hpZnQnIDogJ3B1c2gnXSh2ZG9tLmNuWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgdmRvbS5jbi5zcGxpY2UoMCwgMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgbWUucHJvbWlzZVVwZGF0ZSh2ZG9tKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBzY3JvbGxGcm9tVG9wID8gLWRhdGEuaGVpZ2h0IDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZkb20uY25bMF0uY25bMF0uc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZVkoJHt5fXB4KWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS51cGRhdGUoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbWUudGltZW91dCgzMDApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZkb20uY25bMF0gPSB2ZG9tLmNuWzBdLmNuWzBdLmNuW3Njcm9sbEZyb21Ub3AgPyAxIDogMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUudHJpZ2dlclZkb21VcGRhdGUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBjcmVhdGVEYXlOYW1lc1JvdygpIHtcbiAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgZGF0ZSA9IG1lLmN1cnJlbnREYXRlLCAvLyBjbG9uZWRcbiAgICAgICAgICAgIGkgICAgPSAwLFxuICAgICAgICAgICAgcm93ICA9IHtjbHM6IFsnbmVvLWNhbGVuZGFyLXdlZWsnXSwgY246IFt7Y2xzOiBbJ25lby1jZWxsJywgJ25lby10b3AtbGVmdC1zcGFjZXInXX1dfSxcbiAgICAgICAgICAgIGRheSwgbm9kZTtcblxuICAgICAgICBkYXRlLnNldERhdGUobWUuY3VycmVudERhdGUuZ2V0RGF0ZSgpIC0gbWUuY3VycmVudERhdGUuZ2V0RGF5KCkgKyBtZS53ZWVrU3RhcnREYXkpO1xuXG4gICAgICAgIGZvciAoOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBub2RlID0ge1xuICAgICAgICAgICAgICAgIGNscyA6IFsnbmVvLWNlbGwnLCAnbmVvLXdlZWtkYXktY2VsbCddLFxuICAgICAgICAgICAgICAgIGh0bWw6IG1lLmludGxGb3JtYXRfZGF5LmZvcm1hdChkYXRlKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZGF5ID0gZGF0ZS5nZXREYXkoKTtcblxuICAgICAgICAgICAgaWYgKCFtZS5zaG93V2Vla2VuZHMgJiYgKGRheSA9PT0gMCB8fCBkYXkgPT09IDYpKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVEb20gPSB0cnVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJvdy5jbi5wdXNoKG5vZGUpO1xuXG4gICAgICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyAxKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJvd1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250YWluZXJFbFxuICAgICAqIEBwYXJhbSB7RGF0ZX0gY3VycmVudERhdGVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB2ZG9tXG4gICAgICovXG4gICAgY3JlYXRlTW9udGhDb250ZW50KGNvbnRhaW5lckVsLCBjdXJyZW50RGF0ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2NhbGVuZGFyU3RvcmUsIGV2ZW50U3RvcmV9ID0gbWUsXG4gICAgICAgICAgICBjdXJyZW50RGF5ICAgICA9IGN1cnJlbnREYXRlLmdldERhdGUoKSxcbiAgICAgICAgICAgIGN1cnJlbnRNb250aCAgID0gY3VycmVudERhdGUuZ2V0TW9udGgoKSxcbiAgICAgICAgICAgIGN1cnJlbnRZZWFyICAgID0gY3VycmVudERhdGUuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgICAgIGRhdGUgICAgICAgICAgID0gRGF0ZVV0aWwuY2xvbmUoY3VycmVudERhdGUpLFxuICAgICAgICAgICAgdmFsdWVEYXRlICAgICAgPSBtZS5jdXJyZW50RGF0ZSwgLy8gY2xvbmVkXG4gICAgICAgICAgICB2YWx1ZU1vbnRoICAgICA9IHZhbHVlRGF0ZS5nZXRNb250aCgpLFxuICAgICAgICAgICAgdmFsdWVZZWFyICAgICAgPSB2YWx1ZURhdGUuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgICAgIGRheXNJbk1vbnRoICAgID0gRGF0ZVV0aWwuZ2V0RGF5c0luTW9udGgoY3VycmVudERhdGUpLFxuICAgICAgICAgICAgZmlyc3REYXlPZmZzZXQgPSBEYXRlVXRpbC5nZXRGaXJzdERheU9mZnNldChjdXJyZW50RGF0ZSwgbWUud2Vla1N0YXJ0RGF5KSxcbiAgICAgICAgICAgIGNvbHVtbnMgICAgICAgID0gNyxcbiAgICAgICAgICAgIGkgICAgICAgICAgICAgID0gMCxcbiAgICAgICAgICAgIHdlZWtEYXRlICAgICAgID0gRGF0ZVV0aWwuY2xvbmUoY3VycmVudERhdGUpLFxuICAgICAgICAgICAgY2VsbElkLCBjb25maWcsIGNvbmZpZ0NscywgZGF0ZURheSwgZGF5LCBkYXlSZWNvcmRzLCBoYXNDb250ZW50LCBqLCByb3csIHJvd3M7XG5cbiAgICAgICAgcm93cyA9IChkYXlzSW5Nb250aCArIGZpcnN0RGF5T2Zmc2V0KSAvIDcgPiA1ID8gNiA6IDU7XG4gICAgICAgIGRheSAgPSAxIC0gZmlyc3REYXlPZmZzZXQ7XG5cbiAgICAgICAgZGF0ZS5zZXREYXRlKGRheSk7XG4gICAgICAgIHdlZWtEYXRlLnNldERhdGUoZGF5ICsgNyk7XG5cbiAgICAgICAgZm9yICg7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgICAgIHJvdyA9IHtcbiAgICAgICAgICAgICAgICBjbHMgICAgICA6IFsnbmVvLWNhbGVuZGFyLXdlZWsnXSxcbiAgICAgICAgICAgICAgICByZW1vdmVEb206IGkgPT09IHJvd3MgJiYgIW1lLnNpeFdlZWtzUGVyTW9udGgsXG5cbiAgICAgICAgICAgICAgICBjbjogW3tcbiAgICAgICAgICAgICAgICAgICAgY2xzICAgICAgOiBbJ25lby1jZWxsJywgJ25lby13ZWVrbnVtYmVyLWNlbGwnXSxcbiAgICAgICAgICAgICAgICAgICAgaHRtbCAgICAgOiBEYXRlVXRpbC5nZXRXZWVrT2ZZZWFyKHdlZWtEYXRlKSxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRG9tOiAhbWUuc2hvd1dlZWtOdW1iZXJzXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHdlZWtEYXRlLnNldERhdGUod2Vla0RhdGUuZ2V0RGF0ZSgpICsgNyk7XG5cbiAgICAgICAgICAgIGZvciAoaj0wOyBqIDwgY29sdW1uczsgaisrKSB7XG4gICAgICAgICAgICAgICAgaGFzQ29udGVudCA9IGRheSA+IDAgJiYgZGF5IDw9IGRheXNJbk1vbnRoO1xuICAgICAgICAgICAgICAgIGNlbGxJZCAgICAgPSBtZS5nZXRDZWxsSWQoY3VycmVudFllYXIsIGN1cnJlbnRNb250aCArIDEsIGRheSk7XG4gICAgICAgICAgICAgICAgZGF0ZURheSAgICA9IGRhdGUuZ2V0RGF5KCk7XG5cbiAgICAgICAgICAgICAgICBjb25maWcgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkICAgICAgOiBjZWxsSWQsXG4gICAgICAgICAgICAgICAgICAgIGNscyAgICAgOiBoYXNDb250ZW50ID8gWyduZW8tY2VsbCddIDogWyduZW8tY2VsbCcsICduZW8tZGlzYWJsZWQnXSxcbiAgICAgICAgICAgICAgICAgICAgdGFiSW5kZXg6IGhhc0NvbnRlbnQgPyAtMSA6IG51bGwsXG5cbiAgICAgICAgICAgICAgICAgICAgY246IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbHMgOiBbJ25lby1jZWxsLWNvbnRlbnQnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IGhhc0NvbnRlbnQgPyBkYXkgOiBtZS5zaG93RGlzYWJsZWREYXlzID8gZGF0ZS5nZXREYXRlKCkgOiAnJ1xuICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBjb25maWdDbHMgPSBjb25maWcuY2xzO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRhdGVEYXkgPT09IDAgfHwgZGF0ZURheSA9PT0gNikge1xuICAgICAgICAgICAgICAgICAgICBjb25maWdDbHMucHVzaCgnbmVvLXdlZWtlbmQnKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIW1lLnNob3dXZWVrZW5kcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnJlbW92ZURvbSA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgaWYgKHRvZGF5LnllYXIgPT09IGN1cnJlbnRZZWFyICYmIHRvZGF5Lm1vbnRoID09PSBjdXJyZW50TW9udGggJiYgdG9kYXkuZGF5ID09PSBkYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmNuWzBdLmNscy5wdXNoKCduZW8tdG9kYXknKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVllYXIgPT09IGN1cnJlbnRZZWFyICYmIHZhbHVlTW9udGggPT09IGN1cnJlbnRNb250aCAmJiBkYXkgPT09IGN1cnJlbnREYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnQ2xzLnB1c2goJ25lby1zZWxlY3RlZCcpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFjb25maWcucmVtb3ZlRG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGRheVJlY29yZHMgPSBldmVudFN0b3JlLmdldERheVJlY29yZHMoZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGRheVJlY29yZHMgPSBkYXlSZWNvcmRzLmZpbHRlcihyZWNvcmQgPT4gY2FsZW5kYXJTdG9yZS5nZXQocmVjb3JkLmNhbGVuZGFySWQpLmFjdGl2ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF5UmVjb3Jkcy5sZW5ndGggPj0gbWUuZXZlbnRJbmRpY2F0b3JIaWdoKSAgIHtjb25maWdDbHMucHVzaCgnbmVvLWV2ZW50cy1oaWdoJyk7fVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkYXlSZWNvcmRzLmxlbmd0aCA+PSBtZS5ldmVudEluZGljYXRvck1lZGl1bSkge2NvbmZpZ0Nscy5wdXNoKCduZW8tZXZlbnRzLW1lZGl1bScpO31cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGF5UmVjb3Jkcy5sZW5ndGggPj0gbWUuZXZlbnRJbmRpY2F0b3JMb3cpICAgIHtjb25maWdDbHMucHVzaCgnbmVvLWV2ZW50cy1sb3cnKTt9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcm93LmNuLnB1c2goY29uZmlnKTtcblxuICAgICAgICAgICAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIDEpO1xuXG4gICAgICAgICAgICAgICAgZGF5KytcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGFpbmVyRWwuY24ucHVzaChyb3cpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29udGFpbmVyRWxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdIHRydWUgdG8gdXBkYXRlIHRoZSB2ZG9tIHNpbGVudGx5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb250YWluZXJFbF1cbiAgICAgKi9cbiAgICBjcmVhdGVNb250aHMoc2lsZW50PWZhbHNlLCBjb250YWluZXJFbCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUubW91bnRlZCkge1xuICAgICAgICAgICAgbWUubmVlZHNFdmVudFVwZGF0ZSA9IHRydWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50RGF0ZSAgICA9IG1lLmN1cnJlbnREYXRlLCAvLyBjbG9uZWRcbiAgICAgICAgICAgICAgICB7dmRvbX0gICAgICAgICA9IG1lLFxuICAgICAgICAgICAgICAgIG1vbnRoQ29udGFpbmVyID0gY29udGFpbmVyRWwgfHwgdmRvbS5jblswXS5jblsxXSxcbiAgICAgICAgICAgICAgICBpICAgICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICAgICAgbW9udGhWZG9tO1xuXG4gICAgICAgICAgICBtb250aENvbnRhaW5lci5jbiA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50RGF0ZS5zZXRNb250aChpKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50RGF0ZS5zZXREYXRlKDEpO1xuXG4gICAgICAgICAgICAgICAgbW9udGhWZG9tID1cbiAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1tb250aCddLCBjbjogW1xuICAgICAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1tb250aC1uYW1lJ10sIGh0bWw6IG1lLmludGxGb3JtYXRfbW9udGguZm9ybWF0KGN1cnJlbnREYXRlKX0sXG4gICAgICAgICAgICAgICAgICAgIG1lLmNyZWF0ZURheU5hbWVzUm93KClcbiAgICAgICAgICAgICAgICBdfTtcblxuICAgICAgICAgICAgICAgIG1vbnRoVmRvbSA9IG1lLmNyZWF0ZU1vbnRoQ29udGVudChtb250aFZkb20sIERhdGVVdGlsLmNsb25lKGN1cnJlbnREYXRlKSk7XG5cbiAgICAgICAgICAgICAgICBtb250aENvbnRhaW5lci5jbi5wdXNoKG1vbnRoVmRvbSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgIXNpbGVudCAmJiBtZS51cGRhdGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSB5ZWFyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBtb250aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gZGF5XG4gICAgICogQHJldHVybnMge1N0cmluZ30gaWRcbiAgICAgKi9cbiAgICBnZXRDZWxsSWQoeWVhciwgbW9udGgsIGRheSkge1xuICAgICAgICBkYXkgPSBkYXkudG9TdHJpbmcoKTtcblxuICAgICAgICBpZiAoZGF5Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIGRheSA9ICcwJyArIGRheVxuICAgICAgICB9XG5cbiAgICAgICAgbW9udGggPSBtb250aC50b1N0cmluZygpO1xuXG4gICAgICAgIGlmIChtb250aC5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICBtb250aCA9ICcwJyArIG1vbnRoXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5pZCArICdfXycgKyB5ZWFyICsgJy0nICsgbW9udGggKyAnLScgKyBkYXlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhXG4gICAgICovXG4gICAgb25DYWxlbmRhclN0b3JlTG9hZChkYXRhKSB7XG4gICAgICAgIHRoaXMuZXZlbnRTdG9yZS5nZXRDb3VudCgpID4gMCAmJiB0aGlzLmNyZWF0ZU1vbnRocygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkNhbGVuZGFyU3RvcmVSZWNvcmRDaGFuZ2UoZGF0YSkge1xuICAgICAgICB0aGlzLmNyZWF0ZU1vbnRocygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YVxuICAgICAqL1xuICAgIG9uRXZlbnRTdG9yZUxvYWQoZGF0YSkge1xuICAgICAgICB0aGlzLmNhbGVuZGFyU3RvcmUuZ2V0Q291bnQoKSA+IDAgJiYgdGhpcy5jcmVhdGVNb250aHMoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGFcbiAgICAgKi9cbiAgICBvbkV2ZW50U3RvcmVSZWNvcmRDaGFuZ2UoZGF0YSkge1xuICAgICAgICB0aGlzLmNyZWF0ZU1vbnRocygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbk5hdkJ1dHRvbkNsaWNrKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2N1cnJlbnREYXRlfSA9IG1lOyAvLyBjbG9uZWRcblxuICAgICAgICBjdXJyZW50RGF0ZS5zZXRGdWxsWWVhcihjdXJyZW50RGF0ZS5nZXRGdWxsWWVhcigpICsgKGRhdGEucGF0aFswXS5jbHMuaW5jbHVkZXMoJ25lby1uZXh0LWJ1dHRvbicpID8gMSA6IC0xKSk7XG5cbiAgICAgICAgbWUuY3VycmVudERhdGUgPSBjdXJyZW50RGF0ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25XaGVlbChkYXRhKSB7XG4gICAgICAgIGlmIChNYXRoLmFicyhkYXRhLmRlbHRhWSkgPiBNYXRoLmFicyhkYXRhLmRlbHRhWCkpIHtcbiAgICAgICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICB7Y3VycmVudERhdGV9ID0gbWU7IC8vIGNsb25lZFxuXG4gICAgICAgICAgICBjdXJyZW50RGF0ZS5zZXRGdWxsWWVhcihjdXJyZW50RGF0ZS5nZXRGdWxsWWVhcigpICsgKGRhdGEuZGVsdGFZID4gMCA/IDEgOiAtMSkpO1xuXG4gICAgICAgICAgICBtZS5jdXJyZW50RGF0ZSA9IGN1cnJlbnREYXRlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyBhIHZkb20gdXBkYXRlICYgc2V0cyBpc1VwZGF0aW5nXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2lsZW50PWZhbHNlXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0cmlnZ2VyVmRvbVVwZGF0ZShzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIG1lLmlzVXBkYXRpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICBtZS5wcm9taXNlVXBkYXRlKG1lLnZkb20pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1lLmlzVXBkYXRpbmcgPSBmYWxzZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIER5bmFtaWNhbGx5IHVwZGF0ZSB0aGUgd2Vla2RheSByb3dzIGluc2lkZSBlYWNoIG1vbnRoXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2lsZW50PWZhbHNlXVxuICAgICAqL1xuICAgIHVwZGF0ZURheU5hbWVzUm93cyh2YWx1ZSwgb2xkVmFsdWUsIHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmludGxGb3JtYXRfZGF5ID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobWUubG9jYWxlLCB7d2Vla2RheTogdmFsdWV9KTtcblxuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IGRhdGUgICA9IG1lLmN1cnJlbnREYXRlLCAvLyBjbG9uZWRcbiAgICAgICAgICAgICAgICB7dmRvbX0gPSBtZSxcbiAgICAgICAgICAgICAgICBpICAgICAgPSAxLFxuICAgICAgICAgICAgICAgIGRheSwgaiwgbm9kZTtcblxuICAgICAgICAgICAgZGF0ZS5zZXREYXRlKG1lLmN1cnJlbnREYXRlLmdldERhdGUoKSAtIG1lLmN1cnJlbnREYXRlLmdldERheSgpICsgbWUud2Vla1N0YXJ0RGF5KTtcblxuICAgICAgICAgICAgZm9yICg7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGo9MDsgaiA8IDEyOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZGF5ICA9IGRhdGUuZ2V0RGF5KCk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSB2ZG9tLmNuWzBdLmNuWzFdLmNuW2pdLmNuWzFdLmNuW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuaHRtbCA9IG1lLmludGxGb3JtYXRfZGF5LmZvcm1hdChkYXRlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIW1lLnNob3dXZWVrZW5kcyAmJiAoZGF5ID09PSAwIHx8IGRheSA9PT0gNikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlRG9tID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG5vZGUucmVtb3ZlRG9tXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyAxKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAhc2lsZW50ICYmIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHVwZGF0ZUhlYWRlclllYXIoKSB7XG4gICAgICAgIHRoaXMudmRvbS5jblswXS5jblswXS5jblswXS5odG1sID0gdGhpcy5jdXJyZW50RGF0ZS5nZXRGdWxsWWVhcigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHluYW1pY2FsbHkgdXBkYXRlIHRoZSBtb250aE5hbWVGb3JtYXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHVwZGF0ZU1vbnRoTmFtZUZvcm1hdCh2YWx1ZSwgb2xkVmFsdWUsIHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmludGxGb3JtYXRfbW9udGggPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChtZS5sb2NhbGUsIHttb250aDogdmFsdWV9KTtcblxuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IHtjdXJyZW50RGF0ZSwgdmRvbX0gPSBtZSxcbiAgICAgICAgICAgICAgICBpICAgICAgICAgICAgICAgICAgID0gMDtcblxuICAgICAgICAgICAgZm9yICg7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudERhdGUuc2V0TW9udGgoaSk7XG4gICAgICAgICAgICAgICAgY3VycmVudERhdGUuc2V0RGF0ZSgxKTtcblxuICAgICAgICAgICAgICAgIHZkb20uY25bMF0uY25bMV0uY25baV0uY25bMF0uaHRtbCA9IG1lLmludGxGb3JtYXRfbW9udGguZm9ybWF0KGN1cnJlbnREYXRlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAhc2lsZW50ICYmIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFllYXJDb21wb25lbnQpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9