export const __webpack_esm_id__ = "vendors-src_grid_Container_mjs";
export const __webpack_esm_ids__ = ["vendors-src_grid_Container_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./src/component/Progress.mjs"
/*!************************************!*\
  !*** ./src/component/Progress.mjs ***!
  \************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");


/**
 * @class Neo.component.Progress
 * @extends Neo.component.Base
 */
class Progress extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.Progress'
         * @protected
         */
        className: 'Neo.component.Progress',
        /**
         * @member {String} ntype='progress'
         * @protected
         */
        ntype: 'progress',
        /**
         * @member {String[]} baseCls=['neo-progress-label']
         * @protected
         */
        baseCls: ['neo-progress'],
        /**
         * @member {String|null} labelText_=null
         * @reactive
         */
        labelText_: null,
        /**
         * @member {Number} max_=100
         * @reactive
         */
        max_: 100,
        /**
         * @member {Number|null} value_=null
         * @reactive
         */
        value_: null,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {tag: 'div', cls: ['neo-progress-wrapper'], cn: [
            {tag: 'label'},
            {tag: 'progress'}
        ]}
    }

    /**
     * @member {Object} label
     */
    get label() {
        return this.vdom.cn[0]
    }
    /**
     * @member {Object} progress
     */
    get progress() {
        return this.vdom.cn[1]
    }

    /**
     * @protected
     */
    ensureStableIds() {
        super.ensureStableIds();
        this.label.for = this.id
    }

    /**
     * Triggered after the labelText config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetLabelText(value, oldValue) {
        let {label} = this;

        if (!value) {
            label.removeDom = true
        } else {
            delete label.removeDom
        }

        label.text = value;
        this.update()
    }

    /**
     * Triggered after the max config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetMax(value, oldValue) {
        this.progress.max = value;
        this.update()
    }

    /**
     * Triggered after the value config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetValue(value, oldValue) {
        this.progress.value = value;
        this.update()
    }

    /**
     * Specify a different vdom root if needed to apply the top level style attributes on a different level.
     * Make sure to use getVnodeRoot() as well, to keep the vdom & vnode trees in sync.
     * @returns {Object} The new vdom root
     */
    getVdomRoot() {
        return this.vdom.cn[1]
    }

    /**
     * Specify a different vnode root if needed to apply the top level style attributes on a different level.
     * Make sure to use getVdomRoot() as well, to keep the vdom & vnode trees in sync.
     * @returns {Object} The new vnode root
     */
    getVnodeRoot() {
        return this.vnode.childNodes[1]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Progress));


/***/ },

/***/ "./src/grid/Body.mjs"
/*!***************************!*\
  !*** ./src/grid/Body.mjs ***!
  \***************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../collection/Base.mjs */ "./src/collection/Base.mjs");
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _selection_grid_RowModel_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../selection/grid/RowModel.mjs */ "./src/selection/grid/RowModel.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/VDom.mjs */ "./src/util/VDom.mjs");







/**
 * @class Neo.grid.Body
 * @extends Neo.component.Base
 */
class GridBody extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.grid.Body'
         * @protected
         */
        className: 'Neo.grid.Body',
        /**
         * @member {String} ntype='grid-body'
         * @protected
         */
        ntype: 'grid-body',
        /**
         * @member {Boolean} animatedRowSorting_=false
         * @reactive
         */
        animatedRowSorting_: false,
        /**
         * Internal flag. Gets calculated when mounting the grid.Container
         * @member {Number} availableHeight_=0
         * @reactive
         */
        availableHeight_: 0,
        /**
         * Internal flag. Gets calculated when changing the availableHeight config
         * @member {Number} availableRows_=0
         * @reactive
         */
        availableRows_: 0,
        /**
         * Internal flag. Gets calculated after mounting grid.Body rows
         * @member {Number} availableWidth_=0
         * @reactive
         */
        availableWidth_: 0,
        /**
         * @member {String[]} baseCls=['neo-grid-body']
         * @protected
         */
        baseCls: ['neo-grid-body'],
        /**
         * The number of columns (cells) to paint before the first and after the last visible column,
         * to enhance the scrolling performance
         * @member {Number} bufferColumnRange_=0
         * @reactive
         */
        bufferColumnRange_: 0,
        /**
         * The number of rows to paint before the first and after the last visible row,
         * to enhance the scrolling performance
         * @member {Number} bufferRowRange_=3
         * @reactive
         */
        bufferRowRange_: 3,
        /**
         * Define which model field contains the value of colspan definitions
         * @member {String} colspanField='colspan'
         */
        colspanField: 'colspan',
        /**
         * Internal flag. Gets calculated after mounting grid.Body rows
         * @member {Number} containerWidth_=0
         * @reactive
         */
        containerWidth_: 0,
        /**
         * @member {Neo.collection.Base|null} columnPositions_=null
         * @protected
         * @reactive
         */
        columnPositions_: null,
        /**
         * @member {Boolean} highlightModifiedCells_=false
         * @reactive
         */
        highlightModifiedCells_: false,
        /**
         * @member {Boolean} isScrolling_=false
         * @reactive
         */
        isScrolling_: false,
        /**
         * Additional used keys for the selection model
         * @member {Object} keys
         */
        keys: {},
        /**
         * Stores the indexes of the first & last mounted columns, including bufferColumnRange
         * @member {Number[]} mountedColumns_=[0,0]
         * @protected
         * @reactive
         */
        mountedColumns_: [0, 0],
        /**
         * Stores the indexes of the first & last mounted rows, including bufferRowRange
         * @member {Number[]} mountedRows=[0,0]
         * @protected
         */
        mountedRows: [0, 0],
        /**
         * Optional config values for Neo.grid.plugin.AnimateRows
         * @member {Object} pluginAnimateRowsConfig=null
         */
        pluginAnimateRowsConfig: null,
        /**
         * @member {String} role='rowgroup'
         * @reactive
         */
        role: 'rowgroup',
        /**
         * Number in px
         * @member {Number} rowHeight_=0
         * @reactive
         */
        rowHeight_: 0,
        /**
         * @member {Number} scrollLeft_=0
         * @protected
         * @reactive
         */
        scrollLeft_: 0,
        /**
         * @member {Number} scrollTop_=0
         * @protected
         * @reactive
         */
        scrollTop_: 0,
        /**
         * @member {Neo.selection.Model} selectionModel_=null
         * @reactive
         */
        selectionModel_: null,
        /**
         * @member {String} selectedRecordField='annotations.selected'
         */
        selectedRecordField: 'annotations.selected',
        /**
         * @member {Number} startIndex_=0
         * @reactive
         */
        startIndex_: 0,
        /**
         * @member {Neo.data.Store|null} store_=null
         * @reactive
         */
        store_: null,
        /**
         * Stores the indexes of the first & last painted columns
         * @member {Number[]} visibleColumns=[0,0]
         * @protected
         */
        visibleColumns: [0, 0],
        /**
         * Stores the indexes of the first & last visible rows, excluding bufferRowRange
         * @member {Number[]} visibleRows=[0,0]
         * @protected
         */
        visibleRows: [0, 0],
        /**
         * @member {String[]} wrapperCls=['neo-grid-body-wrapper']
         * @reactive
         */
        wrapperCls: ['neo-grid-body-wrapper'],
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {tabIndex: '-1', cn: [
            {cn: []}
        ]}
    }

    /**
     * Internal flag to adopt to store.add() passing an initial chunk.
     * @member {Number} #initialChunkSize=0
     */
    #initialChunkSize = 0
    /**
     * Internal flag to adopt to store.add() passing an initial chunk.
     * @member {Number} #initialChunkSize=0
     */
    #initialTotalSize = 0

    /**
     * @member {String[]} selectedCells
     */
    get selectedCells() {
        let {selectionModel} = this;

        if (selectionModel.ntype?.includes('cell')) {
            return selectionModel.items
        }

        return []
    }

    /**
     * @member {String[]} selectedRows
     */
    get selectedRows() {
        let {selectionModel} = this;

        if (selectionModel.ntype?.includes('row')) {
            return selectionModel.selectedRows
        }

        return []
    }

    /**
     * @param config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.addDomListeners([{
            click   : me.onCellClick,
            dblclick: me.onCellDoubleClick,
            delegate: '.neo-grid-cell',
            scope   : me
        }, {
            click   : me.onRowClick,
            dblclick: me.onRowDoubleClick,
            delegate: '.neo-grid-row',
            scope   : me
        }])
    }

    /**
     * Triggered after the animatedRowSorting config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetAnimatedRowSorting(value, oldValue) {
        if (value && !this.getPlugin('grid-animate-rows')) {
            __webpack_require__.e(/*! import() */ "src_grid_plugin_AnimateRows_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./plugin/AnimateRows.mjs */ "./src/grid/plugin/AnimateRows.mjs")).then(module => {
                let me      = this,
                    plugins = me.plugins || [];

                plugins.push({
                    module: module.default,
                    ...me.pluginAnimateRowsConfig
                });

                me.plugins = plugins
            })
        }
    }

    /**
     * Triggered after the availableHeight config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetAvailableHeight(value, oldValue) {
        if (value > 0) {
            this.availableRows = Math.ceil(value / this.rowHeight) - 1
        }
    }

    /**
     * Triggered after the availableRows config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetAvailableRows(value, oldValue) {
        value > 0 && this.createViewData()
    }

    /**
     * Triggered after the availableWidth config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetAvailableWidth(value, oldValue) {
        if (value > 0) {
            let me = this;

            me.vdom.width = value + 'px';
            me.vdom.cn[0].width = value + 'px';
            me.update()
        }
    }

    /**
     * Triggered after the bufferColumnRange config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetBufferColumnRange(value, oldValue) {
        oldValue !== undefined && this.createViewData()
    }

    /**
     * Triggered after the bufferRowRange config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetBufferRowRange(value, oldValue) {
        oldValue !== undefined && this.createViewData()
    }

    /**
     * Triggered after the containerWidth config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetContainerWidth(value, oldValue) {
        value > 0 && this.updateMountedAndVisibleColumns()
    }



    /**
     * Triggered after the isScrolling config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetIsScrolling(value, oldValue) {
        this.toggleCls('neo-is-scrolling', value)
    }

    /**
     * Triggered after the mountedColumns config got changed
     * @param {Number[]} value
     * @param {Number[]} oldValue
     * @protected
     */
    afterSetMountedColumns(value, oldValue) {
        oldValue && this.createViewData()
    }

    /**
     * Triggered after the rowHeight config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetRowHeight(value, oldValue) {
        value > 0 && this.updateScrollHeight()
    }

    /**
     * Triggered after the scrollLeft config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetScrollLeft(value, oldValue) {
        this.updateMountedAndVisibleColumns()
    }

    /**
     * Triggered after the scrollTop config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetScrollTop(value, oldValue) {
        let me               = this,
            {bufferRowRange} = me,
            newStartIndex    = Math.floor(value / me.rowHeight);

        if (Math.abs(me.startIndex - newStartIndex) >= bufferRowRange) {
            me.startIndex = newStartIndex
        } else {
            me.visibleRows[0] = newStartIndex;
            me.visibleRows[1] = newStartIndex + me.availableRows
        }
    }

    /**
     * Triggered after the selectionModel config got changed
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @protected
     */
    afterSetSelectionModel(value, oldValue) {
        this.vnodeInitialized && value.register(this)
    }

    /**
     * Triggered after the startIndex config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetStartIndex(value, oldValue) {
        oldValue !== undefined && this.createViewData()
    }

    /**
     * Triggered after the store config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetStore(value, oldValue) {
        let me        = this,
            listeners = {
                filter      : me.onStoreFilter,
                load        : me.onStoreLoad,
                recordChange: me.onStoreRecordChange,
                scope       : me
            };

        oldValue?.un(listeners);
        value   ?.on(listeners);

        // Clear component instances when the store changes or is replaced
        if (oldValue) {
            me.clearComponentColumnMaps();
        }
    }

    /**
     * @param {Object} data
     * @param {String} [data.cellId]
     * @param {Object} data.column
     * @param {Number} data.columnIndex
     * @param {Object} data.record
     * @param {Number} data.rowIndex
     * @returns {Object}
     */
    applyRendererOutput({cellId, column, columnIndex, record, rowIndex}) {
        let me                     = this,
            gridContainer          = me.parent,
            {selectedCells, store} = me,
            cellCls                = ['neo-grid-cell'],
            colspan                = record[me.colspanField],
            {dataField}            = column,
            {model}                = store,
            fieldValue             = record[dataField],
            cellConfig, rendererOutput;

        if (!model.getField(dataField)) {
            let nsArray   = dataField.split('.'),
                fieldName = nsArray.pop();

            fieldValue = Neo.ns(nsArray, false, record[Symbol.for('data')])?.[fieldName]
        }

        if (fieldValue === null || fieldValue === undefined) {
            fieldValue = ''
        }

        if (column.rendererScope === 'me' || column.rendererScope === 'this') {
            column.rendererScope = column;
        }

        me.bindCallback(column.renderer, 'renderer', column.rendererScope || me, column);

        rendererOutput = column.renderer.call(column.rendererScope || me, {
            column,
            columnIndex,
            dataField,
            gridContainer,
            record,
            rowIndex,
            store,
            value: fieldValue
        });

        switch (Neo.typeOf(rendererOutput)) {
            case 'Object': {
                if (rendererOutput.html || rendererOutput.text) {
                    rendererOutput.cls && cellCls.push(...rendererOutput.cls);
                } else {
                    rendererOutput = [rendererOutput];
                }
                break
            }
            case 'Date':
            case 'Number':
            case 'String': {
                rendererOutput = {
                    cls : cellCls,
                    html: rendererOutput?.toString()
                };
                break
            }
        }

        if (rendererOutput === null || rendererOutput === undefined) {
            rendererOutput = ''
        }

        if (column.cellAlign !== 'left') {
            cellCls.push('neo-' + column.cellAlign)
        }

        if (me.highlightModifiedCells) {
            if (record.isModifiedField(dataField)) {
                cellCls.push('neo-is-modified')
            }
        }

        if (!cellId) {
            cellId = me.getCellId(rowIndex, column.dataField)
        }

        if (selectedCells.includes(cellId)) {
            cellCls.push('neo-selected')
        }

        if (me.selectionModel?.selectedColumns?.includes(dataField)) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(cellCls, me.selectionModel.selectedColumnCellCls || 'neo-selected')
        }

        cellConfig = {
            'aria-colindex': columnIndex + 1, // 1 based
            id             : cellId,
            cls            : cellCls,
            role           : 'gridcell',
            style          : rendererOutput.style || {}
        };

        if (column.width) {
            cellConfig.style.minWidth = `${column.width}px`
        }

        if (colspan && Object.keys(colspan).includes(dataField)) {
            cellConfig.colspan = colspan[dataField]
        }

        if (Neo.typeOf(rendererOutput) === 'Object') {
            if (Object.hasOwn(rendererOutput, 'html')) {
                cellConfig.html = rendererOutput.html  || ''
            } else {
                cellConfig.text = rendererOutput.text  || ''
            }
        } else {
            cellConfig.cn = rendererOutput
        }

        return cellConfig
    }

    /**
     * Triggered when accessing the columnPositions config
     * @param {Object} value
     * @protected
     */
    beforeGetColumnPositions(value) {
        if (!value) {
            this._columnPositions = value = Neo.create({
                module     : _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                keyProperty: 'dataField'
            })
        }

        return value
    }

    /**
     * Triggered before the selectionModel config gets changed.
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @protected
     */
    beforeSetSelectionModel(value, oldValue) {
        oldValue?.destroy();

        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].beforeSetInstance(value, _selection_grid_RowModel_mjs__WEBPACK_IMPORTED_MODULE_4__["default"])
    }

    /**
     * Destroys all component instances created by component columns.
     * @protected
     */
    clearComponentColumnMaps() {
        let me      = this,
            columns = me.parent.columns.items;

        columns.forEach(column => {
            if (column instanceof Neo.grid.column.Component) {
                column.map.forEach(component => {
                    component.destroy()
                });
                column.map.clear()
            }
        });
    }

    /**
     * Cleans up component instances that are no longer visible or needed.
     * @protected
     */
    cleanupComponentInstances() {
        let me = this;

        me.parent.columns.items.forEach(column => {
            if (column instanceof Neo.grid.column.Component) {
                column.map.forEach((component, id) => {
                    // Extract rowIndex from component ID (e.g., "grid-body-1-component-950")
                    const componentRowIndex = parseInt(id.split('-').pop());

                    if (componentRowIndex < me.mountedRows[0] || componentRowIndex > me.mountedRows[1]) {
                        component.destroy();
                        column.map.delete(id)
                    }
                });
            }
        });
    }

    /**
     * @param {Object} opts
     * @param {Object} opts.record
     * @param {Number} [opts.rowIndex]
     * @returns {Object}
     */
    createRow({record, rowIndex}) {
        if (!Neo.isNumber(rowIndex)) {
            rowIndex = this.store.indexOf(record)
        }

        let me            = this,
            {mountedColumns, selectedRows} = me,
            gridContainer = me.parent,
            {columns}     = gridContainer,
            id            = me.getRowId(rowIndex),
            recordId      = record[me.store.getKeyProperty()],
            rowCls        = me.getRowClass(record, rowIndex),
            config, column, columnPosition,  gridRow, i;

        if (rowIndex % 2 !== 0) {
            rowCls.push('neo-even')
        }

        if (selectedRows && record[me.selectedRecordField]) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(selectedRows, recordId)
        }

        gridRow = {
            id,
            'aria-rowindex': rowIndex + 2, // header row => 1, first body row => 2
            cls            : rowCls,
            cn             : [],
            data           : {recordId},
            role           : 'row',

            style: {
                height   : me.rowHeight + 'px',
                transform: `translate3d(0px, ${rowIndex * me.rowHeight}px, 0px)`
            }
        };

        if (selectedRows?.includes(recordId)) {
            rowCls.push('neo-selected');
            gridRow['aria-selected'] = true;
            gridContainer.fire('select', {record})
        }

        for (i=mountedColumns[0]; i <= mountedColumns[1]; i++) {
            column = columns.getAt(i);
            config = me.applyRendererOutput({column, columnIndex: i, record, rowIndex});

            if (column.dock) {
                config.cls = ['neo-locked', ...config.cls || []]
            }

            columnPosition = me.columnPositions.get(column.dataField);

            config.style = {
                ...config.style,
                left : columnPosition.x     + 'px',
                width: columnPosition.width + 'px'
            }

            // Happens during a column header drag OP, when leaving the painted range
            if (columnPosition.hidden) {
                config.style.visibility = 'hidden'
            }

            gridRow.cn.push(config)
        }

        return gridRow
    }

    /**
     * @param {Boolean} silent=false
     */
    createViewData(silent=false) {
        let me                   = this,
            {mountedRows, store} = me,
            rows                 = [],
            endIndex, i, range;

        if (
            store.isLoading                   ||
            me.availableRows              < 1 ||
            me._containerWidth            < 1 || // we are not checking me.containerWidth, since we want to ignore the config symbol
            me.columnPositions.getCount() < 1 ||
            me.mountedColumns[1]          < 1
        ) {
            return
        }

        if (me.#initialChunkSize > 0) {
            endIndex = me.#initialChunkSize;
            range    = endIndex;
        } else {
            // Creates the new start & end indexes
            me.updateMountedAndVisibleRows();
            endIndex = mountedRows[1]
        }

        for (i=mountedRows[0]; i < endIndex; i++) {
            rows.push(me.createRow({record: store.getAt(i), rowIndex: i}))
        }

        me.getVdomRoot().cn = rows;

        me.parent.isLoading = false;

        me.updateScrollHeight(true, range); // silent
        !silent && me.update()
    }

    /**
     * @param args
     */
    destroy(...args) {
        this.store = null; // remove the listeners
        this.clearComponentColumnMaps(); // Destroy component instances

        super.destroy(...args)
    }

    /**
     * @param {Object} data
     * @param {String} eventName
     */
    fireCellEvent(data, eventName) {
        let me        = this,
            id        = data.currentTarget,
            dataField = me.getCellDataField(id),
            record    = me.getRecord(id);

        me.parent.fire(eventName, {body: me, data, dataField, record})
    }

    /**
     * @param {Object} data
     * @param {String} eventName
     */
    fireRowEvent(data, eventName) {
        let me     = this,
            id     = data.currentTarget,
            record = me.getRecord(id);

        me.parent.fire(eventName, {body: me, data, record})
    }

    /**
     * @param {String} cellId
     * @returns {String}
     */
    getCellDataField(cellId) {
        return cellId.split('__')[2]
    }

    /**
     * @param {Number} rowIndex
     * @param {String} dataField
     * @returns {String}
     */
    getCellId(rowIndex, dataField) {
        return this.getRowId(rowIndex) + '__' + dataField
    }

    /**
     * Get a grid column or column index by a given field name
     * @param {String} field
     * @param {Boolean} returnIndex=false
     * @returns {Object|Number|null}
     */
    getColumn(field, returnIndex=false) {
        let {columns} = this.parent,
            column    = columns.get(field);

        if (column) {
            return returnIndex ? columns.indexOf(column) : column
        }

        return null
    }

    /**
     * Get all painted column cells (visible + buffer range)
     * @param {String} dataField
     * @returns {Object[]}
     */
    getColumnCells(dataField) {
        let me          = this,
            cells       = [],
            columnIndex = -1,
            vdomRoot    = me.getVdomRoot(),
            firstRow    = vdomRoot.cn[0],
            i           = 0,
            len         = firstRow.cn.length,
            cell;

        // Columns might get moved via drag&drop, so let's check for the current match
        for (; i < len; i++) {
            if (dataField === me.getDataField(firstRow.cn[i].id)) {
                columnIndex = i;
                break;
            }
        }

        if (columnIndex > -1) {
            vdomRoot.cn.forEach(row => {
                cell = row.cn[columnIndex];
                cell && cells.push(cell)
            })
        }

        return cells
    }

    /**
     * @param {String} cellId
     * @returns {String}
     */
    getDataField(cellId) {
        return cellId.split('__')[2]
    }

    /**
     * Get the matching record by passing a row id, a cell id or an id inside a grid cell.
     * Limited to mounted rows (must be inside the vdom).
     * @param {String} nodeId
     * @returns {Object|null}
     */
    getRecord(nodeId) {
        let me     = this,
            record = me.getRecordByRowId(nodeId),
            node, parentNodes;

        if (record) {
            return record;
        }

        parentNodes = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].getParentNodes(me.vdom, nodeId);

        for (node of parentNodes || []) {
            record = me.getRecordByRowId(node.id);

            if (record) {
                return record
            }
        }

        return null
    }

    /**
     * @param {String} rowId
     * @returns {Record|null}
     */
    getRecordByRowId(rowId) {
        let me       = this,
            node     = me.getVdomChild(rowId),
            rowIndex = node['aria-rowindex'];

        if (Neo.isNumber(rowIndex)) {
            // aria-rowindex is 1 based & also includes the header
            rowIndex -= 2;

            return me.store.getAt(rowIndex)
        }

        return null
    }

    /**
     * Override this method to apply custom CSS rules to grid rows
     * @param {Object} record
     * @param {Number} rowIndex
     * @returns {String[]}
     */
    getRowClass(record, rowIndex) {
        return ['neo-grid-row']
    }

    /**
     * @param {Number} rowIndex
     * @returns {String}
     */
    getRowId(rowIndex) {
        let me = this;

        if (me.#initialChunkSize > 0) {
            return `${me.id}__row-${rowIndex}`
        } else {
            return `${me.id}__row-${rowIndex % (me.availableRows + 2 * me.bufferRowRange)}`
        }
    }

    /**
     * @override
     * @returns {*}
     */
    getVdomRoot() {
        return this.vdom.cn[0]
    }

    /**
     * @returns {Object[]} The new vdom items root
     */
    getVdomItemsRoot() {
        return this.vdom.cn[0]
    }

    /**
     * @override
     * @returns {Neo.vdom.VNode}
     */
    getVnodeRoot() {
        return this.vnode.childNodes[0]
    }

    /**
     * @param {Object} data
     */
    onCellClick(data) {
        this.fireCellEvent(data, 'cellClick')
    }

    /**
     * @param {Object} data
     */
    onCellDoubleClick(data) {
        this.fireCellEvent(data, 'cellDoubleClick')
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();
        this.selectionModel?.register(this)
    }

    /**
     * @param {Object} data
     */
    onRowClick(data) {
        this.fireRowEvent(data, 'rowClick')
    }

    /**
     * @param {Object} data
     */
    onRowDoubleClick(data) {
        this.fireRowEvent(data, 'rowDoubleClick')
    }

    /**
     * @param {Object} data
     */
    onScrollCapture(data) {
        super.onScrollCapture(data);
        this.parent.scrollManager.onBodyScroll(data)
    }

    /**
     * @param {Object} data
     */
    onStoreFilter() {
        this.onStoreLoad({items: this.store.items})
    }

    /**
     * @param {Object}   data
     * @param {Object[]} data.items
     * @param {Boolean}  [data.postChunkLoad]
     * @param {Number}   [data.total]
     * @protected
     */
    onStoreLoad({items, postChunkLoad, total}) {
        let me         = this,
            {windowId} = me;

        /*
         * Fast path to handle clearing all rows (e.g., store.removeAll()).
         * A full vdom diff against all existing rows is a performance bottleneck.
         * This logic bypasses the standard update() cycle by directly clearing the vdom,
         * vnode cache and the real DOM via textContent.
         */
        if (items?.length < 1) {
            const vdomRoot = me.getVdomRoot();

            // No change, opt out
            if (vdomRoot.cn.length < 1) {
                return
            }

            vdomRoot.cn = [];
            me.getVnodeRoot().childNodes = [];

            Neo.applyDeltas(windowId, {
                id         : vdomRoot.id,
                textContent: ''
            });

            return
        }

        // If it's the first chunked load (data.total exists and data.items is a subset of total)
        // Render the entire chunk for immediate scrollability
        if (total && items.length < total) {
            me.#initialChunkSize = items.length;
            me.#initialTotalSize = total;
            me.createViewData();
            me.#initialChunkSize = 0
            me.#initialTotalSize = 0
        } else {
            me.createViewData()
        }

        if (me.mounted && !postChunkLoad) {
            me.timeout(50).then(() => {
                Neo.main.DomAccess.scrollTo({
                    direction: 'top',
                    id       : me.vdom.id,
                    value    : 0,
                    windowId
                })
            })
        }

        // Cleanup component instances after chunked load
        if (postChunkLoad) {
            me.cleanupComponentInstances()
        }
    }

    /**
     * @param {Object}         data
     * @param {Object[]}       data.fields Each field object contains the keys: name, oldValue, value
     * @param {Neo.data.Model} data.model  The model instance of the changed record
     * @param {Object}         data.record
     */
    onStoreRecordChange({fields, record}) {
        let me                            = this,
            fieldNames                    = fields.map(field => field.name),
            needsUpdate                   = false,
            rowIndex                      = me.store.indexOf(record),
            {mountedRows, selectionModel} = me,
            column, needsCellUpdate, recordId;

        if (fieldNames.includes(me.colspanField)) {
            me.vdom.cn[rowIndex] = me.createRow({record, rowIndex});
            me.update()
        } else {
            if (rowIndex >= mountedRows[0] && rowIndex <= mountedRows[1]) {
                for (column of me.parent.columns.items) {
                    if (
                        column instanceof Neo.grid.column.Component &&
                        Neo.typeOf(column.component === 'Function') &&
                        !fieldNames.includes(column.dataField)
                    ) {
                        needsCellUpdate = me.updateCellNode(record, column.dataField);
                        needsUpdate     = needsUpdate || needsCellUpdate
                    }
                }

                fields.forEach(field => {
                    if (field.name === me.selectedRecordField) {
                        if (selectionModel.ntype === 'selection-grid-rowmodel') {
                            recordId = record[me.store.getKeyProperty()];

                            selectionModel[field.value ? 'selectRow' : 'deselectRow'](recordId)
                        }
                    } else {
                        needsCellUpdate = me.updateCellNode(record, field.name);
                        needsUpdate     = needsUpdate || needsCellUpdate
                    }
                })
            }
        }

        needsUpdate && me.update()
    }

    /**
     * Used for keyboard navigation (selection models)
     * @param {Number} index
     * @param {Number} step
     */
    scrollByRows(index, step) {
        let me                         = this,
            {mountedRows, visibleRows} = me,
            countRecords               = me.store.getCount(),
            newIndex                   = index + step,
            lastRowGap, mounted, scrollTop, visible;

        if (newIndex >= countRecords) {
            newIndex %= countRecords;
            step     = newIndex - index
        }

        while (newIndex < 0) {
            newIndex += countRecords;
            step     += countRecords
        }

        mounted = newIndex >= mountedRows[0] && newIndex <= mountedRows[1];

        // Not using >= or <=, since the first / last row might not be fully visible
        visible = newIndex > visibleRows[0] && newIndex < visibleRows[1];

        if (!visible) {
            // Leaving the mounted area will re-calculate the visibleRows for us
            if (mounted) {
                visibleRows[0] += step;
                visibleRows[1] += step
            }

            if (step < 0) {
                scrollTop = newIndex * me.rowHeight
            } else {
                lastRowGap = me.rowHeight - (me.availableHeight % me.rowHeight);
                scrollTop  = (newIndex - me.availableRows) * me.rowHeight + lastRowGap
            }

            Neo.main.DomAccess.scrollTo({
                id      : me.vdom.id,
                value   : scrollTop,
                windowId: me.windowId
            })
        }
    }

    /**
     * Update the cell vdom silently
     * @param {Record} record
     * @param {String} dataField
     * @returns {Boolean} true in case the view needs an update
     */
    updateCellNode(record, dataField) {
        let me          = this,
            rowIndex    = me.store.indexOf(record),
            cellId      = me.getCellId(rowIndex, dataField),
            cellNode    = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].find(me.vdom, cellId),
            needsUpdate = false,
            cellStyle, cellVdom, column, columnIndex;

        // The vdom might not exist yet => nothing to do in this case
        if (cellNode?.vdom) {
            cellStyle   = cellNode.vdom.style;
            column      = me.getColumn(dataField);
            columnIndex = cellNode.index;
            cellVdom    = me.applyRendererOutput({cellId, column, columnIndex, record, rowIndex});
            needsUpdate = true;

            // The cell-positioning logic happens outside applyRendererOutput()
            // We need to preserve these styles
            Object.assign(cellVdom.style, {
                left : cellStyle.left,
                width: cellStyle.width
            });

            cellNode.parentNode.cn[columnIndex] = cellVdom
        }

        return needsUpdate
    }

    /**
     *
     */
    updateMountedAndVisibleColumns() {
        let me       = this,
            {bufferColumnRange, columnPositions, mountedColumns, visibleColumns} = me,
            i            = 0,
            countColumns = columnPositions.getCount(),
            endIndex     = countColumns - 1,
            x            = me.scrollLeft,
            column, startIndex;

        if (countColumns < 1) {
            return
        }

        for (; i < countColumns; i++) {
            column = columnPositions.getAt(i);

            if (x >= column.x && x <= column.x + column.width) {
                startIndex = i
            }

            if (me.containerWidth + x < column.x) {
                endIndex = i - 1;
                break
            }
        }

        visibleColumns[0] = startIndex; // update the array inline
        visibleColumns[1] = endIndex;

        if (visibleColumns[0] <= mountedColumns[0] || visibleColumns[1] >= mountedColumns[1]) {
            startIndex = Math.max(0, visibleColumns[0] - bufferColumnRange);
            endIndex   = Math.min(countColumns - 1, visibleColumns[1] + bufferColumnRange);

            me.mountedColumns = [startIndex, endIndex]
        }
    }

    /**
     *
     */
    updateMountedAndVisibleRows() {
        let me           = this,
            {bufferRowRange, startIndex, store} = me,
            countRecords = store.getCount(),
            endIndex     = Math.min(countRecords, startIndex + me.availableRows);

        me.visibleRows[0] = startIndex; // update the array inline
        me.visibleRows[1] = endIndex;

        startIndex = Math.max(0, startIndex - bufferRowRange);
        endIndex   = Math.min(countRecords, endIndex + bufferRowRange);

        me.mountedRows[0] = startIndex; // update the array inline
        me.mountedRows[1] = endIndex
    }

    /**
     * @param {Boolean} silent=false
     */
    updateScrollHeight(silent=false) {
        let me           = this,
            countRecords = me.#initialTotalSize || me.store?.count || 0,
            {rowHeight}  = me;

        if (countRecords > 0 && rowHeight > 0) {
            me.vdom.cn[0].height = `${(countRecords + 1) * rowHeight}px`;
            !silent && me.update()
        }
    }

    /**
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            animatedRowSorting    : me.animatedRowSorting,
            bufferColumnRange     : me.bufferColumnRange,
            bufferRowRange        : me.bufferRowRange,
            colspanField          : me.colspanField,
            highlightModifiedCells: me.highlightModifiedCells,
            rowHeight             : me.rowHeight,
            selectedRecordField   : me.selectedRecordField,
            selectionModel        : me.selectionModel?.toJSON()
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(GridBody));


/***/ },

/***/ "./src/grid/Container.mjs"
/*!********************************!*\
  !*** ./src/grid/Container.mjs ***!
  \********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../collection/Base.mjs */ "./src/collection/Base.mjs");
/* harmony import */ var _Body_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Body.mjs */ "./src/grid/Body.mjs");
/* harmony import */ var _ScrollManager_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ScrollManager.mjs */ "./src/grid/ScrollManager.mjs");
/* harmony import */ var _data_Store_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../data/Store.mjs */ "./src/data/Store.mjs");
/* harmony import */ var _VerticalScrollbar_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./VerticalScrollbar.mjs */ "./src/grid/VerticalScrollbar.mjs");
/* harmony import */ var _column_export_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./column/_export.mjs */ "./src/grid/column/_export.mjs");
/* harmony import */ var _header_export_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./header/_export.mjs */ "./src/grid/header/_export.mjs");
/* harmony import */ var _core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../core/ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");











/**
 * @class Neo.grid.Container
 * @extends Neo.container.Base
 */
class GridContainer extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @member {Object} columnTypes
     * @protected
     * @static
     */
    static columnTypes = {
        animatedChange  : _column_export_mjs__WEBPACK_IMPORTED_MODULE_7__.AnimatedChange,
        animatedCurrency: _column_export_mjs__WEBPACK_IMPORTED_MODULE_7__.AnimatedCurrency,
        column          : _column_export_mjs__WEBPACK_IMPORTED_MODULE_7__.Base,
        component       : _column_export_mjs__WEBPACK_IMPORTED_MODULE_7__.Component,
        currency        : _column_export_mjs__WEBPACK_IMPORTED_MODULE_7__.Currency,
        index           : _column_export_mjs__WEBPACK_IMPORTED_MODULE_7__.Index,
        progress        : _column_export_mjs__WEBPACK_IMPORTED_MODULE_7__.Progress
    }
    /**
     * @member {Object} delayable
     * @protected
     * @static
     */
    static delayable = {
        onResize: {type: 'buffer', timer: 300}
    }

    static config = {
        /**
         * @member {String} className='Neo.grid.Container'
         * @protected
         */
        className: 'Neo.grid.Container',
        /**
         * @member {String} ntype='grid-container'
         * @protected
         */
        ntype: 'grid-container',
        /**
         * @member {String[]} baseCls=['neo-grid-container']
         * @protected
         */
        baseCls: ['neo-grid-container'],
        /**
         * Configs for Neo.grid.Body
         * @member {Object|null} [body_={[isDescriptor]: true, merge: 'deep', value: null}]
         * @reactive
         */
        body_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_9__.isDescriptor]: true,
            merge         : 'deep',
            value         : null
        },
        /**
         * true uses grid.plugin.CellEditing
         * @member {Boolean} cellEditing_=false
         * @reactive
         */
        cellEditing_: false,
        /**
         * Default configs for each column
         * @member {Object} columnDefaults=null
         */
        columnDefaults: null,
        /**
         * @member {Object[]} columns_=[]
         * @reactive
         */
        columns_: [],
        /**
         * Configs for Neo.grid.header.Toolbar
         * @member {Object|null} [headerToolbar_={[isDescriptor]: true, merge: 'deep', value: null}]
         * @reactive
         */
        headerToolbar_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_9__.isDescriptor]: true,
            merge         : 'deep',
            value         : null
        },
        /**
         * @member {String} layout='base'
         * @reactive
         */
        layout: 'base',
        /**
         * @member {String} role='grid'
         * @reactive
         */
        role: 'grid',
        /**
         * Number in px
         * @member {Number} rowHeight_=32
         * @reactive
         */
        rowHeight_: 32,
        /**
         * @member {Neo.grid.Scrollbar|null} scrollbar=null
         * @protected
         */
        scrollbar: null,
        /**
         * @member {Boolean} showHeaderFilters_=false
         * @reactive
         */
        showHeaderFilters_: false,
        /**
         * @member {Boolean} sortable_=true
         * @reactive
         */
        sortable_: true,
        /**
         * @member {Neo.data.Store} store_=null
         * @reactive
         */
        store_: null,
        /**
         * @member {Array|null} items=null
         * @protected
         * @reactive
         */
        items: null,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {cls: ['neo-grid-wrapper'], cn: [
            {'aria-colcount': 0, 'aria-rowcount': 1, cn: []} // aria-rowcount includes the column headers
        ]}
    }

    /**
     * We do not need the first event to trigger logic, since afterSetMounted() handles this
     * @member {Boolean} initialResizeEvent=true
     * @protected
     */
    initialResizeEvent = true
    /**
     * @member {Neo.grid.ScrollManager|null} scrollManager=null
     * @protected
     */
    scrollManager = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this,
            {appName, rowHeight, store, windowId} = me;

        me.items = [me.headerToolbar, me.body];

        me.scrollbar = Neo.create({
            module  : _VerticalScrollbar_mjs__WEBPACK_IMPORTED_MODULE_6__["default"],
            appName,
            parentId: me.id,
            rowHeight,
            store,
            windowId
        });

        me.vdom.cn.push(me.scrollbar.createVdomReference())

        me.vdom.id = me.getWrapperId();

        me._columns = me.createColumns(me.columns);
        me.updateColCount();

        me.addDomListeners({
            resize: me.onResize,
            scope : me
        })
    }

    /**
     * @param {Boolean} mounted
     * @protected
     */
    async addResizeObserver(mounted) {
        let me             = this,
            {windowId}     = me,
            ResizeObserver = await Neo.currentWorker.getAddon('ResizeObserver', windowId),
            resizeParams   = {id: me.id, windowId};

        if (mounted) {
            ResizeObserver.register(resizeParams);
            await me.passSizeToBody()
        } else {
            me.initialResizeEvent = true;
            ResizeObserver.unregister(resizeParams)
        }
    }

    /**
     * Triggered after the cellEditing config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetCellEditing(value, oldValue) {
        if (value) {
            Promise.all(/*! import() */[__webpack_require__.e("vendors-src_table_plugin_CellEditing_mjs"), __webpack_require__.e("src_grid_plugin_CellEditing_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ./plugin/CellEditing.mjs */ "./src/grid/plugin/CellEditing.mjs")).then(module => {
                let me        = this,
                    {appName} = me,
                    plugins   = me.plugins || [];

                plugins.push({
                    module: module.default,
                    appName
                });

                me.plugins = plugins
            })
        }
    }

    /**
     * Triggered after the columns config got changed
     * @param {Neo.collection.Base|null}          value
     * @param {Object[]|Neo.collection.Base|null} oldValue
     * @protected
     */
    async afterSetColumns(value, oldValue) {
        let me              = this,
            {headerToolbar} = me;

        // - If columns changed at run-time OR
        // - In case the `header.Toolbar#createItems()` method has run before columns where available
        if (oldValue?.count || (value?.count && headerToolbar?.isConstructed)) {
            headerToolbar?.createItems()

            await me.timeout(50);

            await me.passSizeToBody();

            me.body?.createViewData()
        }

        me.configsApplied && me.updateColCount()
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);
        oldValue !== undefined && this.addResizeObserver(value);

        let {scrollManager} = this;

        if (scrollManager) {
            scrollManager.mounted = value
        }
    }

    /**
     * Triggered after the rowHeight config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetRowHeight(value, oldValue) {
        if (value > 0) {
            let {body, scrollbar} = this;

            if (scrollbar) {
                scrollbar.rowHeight = value
            }

            if (body) {
                body.rowHeight = value
            }
        }
    }

    /**
     * Triggered after the showHeaderFilters config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowHeaderFilters(value, oldValue) {
        if (oldValue !== undefined) {
            this.headerToolbar.showHeaderFilters = value
        }
    }

    /**
     * Triggered after the sortable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetSortable(value, oldValue) {
        if (oldValue !== undefined) {
            this.headerToolbar.sortable = value
        }
    }

    /**
     * Triggered after the store config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetStore(value, oldValue) {
        let me        = this,
            listeners = {
                filter: me.onStoreFilter,
                load  : me.onStoreLoad,
                scope : me
            };

        value   ?.on(listeners);
        oldValue?.un(listeners);

        // in case we dynamically change the store, grid.Body needs to get the new reference
        if (me.body) {
            me.body.store = value
        }
    }

    /**
     * Triggered before the body config gets changed.
     * @param {Object|Neo.grid.Body|null} value
     * @param {Object|Neo.grid.Body|null} oldValue
     * @protected
     */
    beforeSetBody(value, oldValue) {
        const me = this;

        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, _Body_mjs__WEBPACK_IMPORTED_MODULE_3__["default"], {
            flex         : 1,
            gridContainer: me,
            parentId     : me.id,
            store        : me.store
        })
    }

    /**
     * Triggered before the columns config gets changed.
     * @param {Object[]} value
     * @param {Object[]} oldValue
     * @protected
     */
    beforeSetColumns(value, oldValue) {
        if (this.configsApplied) {
            return this.createColumns(value)
        }

        return value
    }

    /**
     * Triggered before the headerToolbar config gets changed.
     * @param {Object|Neo.grid.header.Toolbar|null} value
     * @param {Object|Neo.grid.header.Toolbar|null} oldValue
     * @protected
     */
    beforeSetHeaderToolbar(value, oldValue) {
        const me = this;

        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, _header_export_mjs__WEBPACK_IMPORTED_MODULE_8__.Toolbar, {
            parentId         : me.id,
            showHeaderFilters: me.showHeaderFilters,
            sortable         : me.sortable
        })
    }

    /**
     * Triggered before the store config gets changed.
     * @param {Object|Neo.data.Store|null} value
     * @param {Neo.data.Store}             oldValue
     * @protected
     */
    beforeSetStore(value, oldValue) {
        if (value) {
            value = _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, _data_Store_mjs__WEBPACK_IMPORTED_MODULE_5__["default"])
        }

        return value
    }

    /**
     * In case you want to update multiple existing records in parallel,
     * using this method is faster than updating each record one by one.
     * At least until we introduce row based vdom updates.
     * @param {Object[]} records
     */
    bulkUpdateRecords(records) {
        let {body, store} = this,
            {keyProperty} = store;

        if (body) {
            body.silentVdomUpdate = true;

            records.forEach(item => {
                store.get(item[keyProperty])?.set(item)
            });

            body.silentVdomUpdate = false;

            body.update()
        }
    }

    /**
     * @param {Object[]} columns
     * @returns {*}
     */
    createColumns(columns) {
        let me               = this,
            {columnDefaults} = me,
            headerButtons    = [],
            sorters          = me.store?.sorters,
            columnClass, renderer;

        columns?.forEach((column, index) => {
            renderer = column.renderer;

            columnDefaults && Neo.assignDefaults(column, columnDefaults);

            if (renderer && Neo.isString(renderer) && me[renderer]) {
                column.renderer = me[renderer]
            }

            if (sorters?.[0] && column.dataField === sorters[0].property) {
                column.isSorted = sorters[0].direction
            }

            column.listeners = {
                sort : me.onSortColumn,
                scope: me
            };

            headerButtons.push(column);

            if (column.component && !column.type) {
                column.type = 'component'
            }

            columnClass = me.constructor.columnTypes[column.type || 'column'];
            delete column.type;

            columns[index] = Neo.create(columnClass, {
                parent  : me,
                windowId: me.windowId,
                ...column
            })
        });

        me.headerToolbar.items = headerButtons;
        me.headerToolbar.createItems();

        if (Neo.typeOf(me._columns) === 'NeoInstance') {
            me._columns.clear();
            me._columns.add(columns);

            return me._columns
        }

        return Neo.create(_collection_Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"], {
            keyProperty: 'dataField',
            items      : columns,
            listeners  : {mutate: me.onColumnsMutate, scope: me}
        })
    }

    /**
     * @param args
     */
    destroy(...args) {
        let me = this;

        me.store = null; // remove the listeners

        me.scrollManager.destroy();

        me.mounted && Neo.main.addon.ResizeObserver.unregister({
            id      : me.id,
            windowId: me.windowId
        });

        super.destroy(...args)
    }

    /**
     * @override
     * @returns {*}
     */
    getVdomRoot() {
        return this.vdom.cn[0]
    }

    /**
     * @override
     * @returns {Neo.vdom.VNode}
     */
    getVnodeRoot() {
        return this.vnode.childNodes[0]
    }

    /**
     * @returns {String}
     */
    getWrapperId() {
        return `${this.id}__wrapper`
    }

    /**
     * @param {Object} data
     */
    onColumnsMutate(data) {
        this.updateColCount()
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me = this;

        me.scrollManager = Neo.create({
            gridBody     : me.body,
            module       : _ScrollManager_mjs__WEBPACK_IMPORTED_MODULE_4__["default"],
            gridContainer: me
        })
    }

    /**
     * @param {Object} data
     * @returns {Promise<void>}
     */
    async onResize(data) {
        let me = this;

        if (!me.initialResizeEvent) {
            await me.passSizeToBody(true);

            me.body.updateMountedAndVisibleColumns();

            await me.headerToolbar.passSizeToBody()
        } else {
            me.initialResizeEvent = false
        }
    }

    /**
     * @param {Object} data
     */
    onScrollCapture(data) {
        super.onScrollCapture(data);
        this.scrollManager.onContainerScroll(data)
    }

    /**
     * @param {Object} opts
     * @param {String} opts.direction
     * @param {String} opts.property
     * @protected
     */
    onSortColumn(opts) {
        let me = this;

        me.store.sort(opts);
        me.removeSortingCss(opts.property)
    }

    /**
     *
     */
    onStoreFilter() {
        this.updateRowCount()
    }

    /**
     * @param {Object}   data
     * @param {Object[]} data.items
     * @param {Number}   [data.total]
     * @protected
     */
    onStoreLoad(data) {
        let me         = this,
            totalCount = data.total ? data.total : this.store.count;

        me.updateRowCount(totalCount);

        if (me.store.sorters?.length < 1) {
            me.removeSortingCss()
        }
    }

    /**
     * @param {Boolean} silent=false
     * @returns {Promise<void>}
     */
    async passSizeToBody(silent=false) {
        let me                          = this,
            [containerRect, headerRect] = await me.getDomRect([me.id, me.headerToolbar.id]);

        // delay for slow connections, where the container-sizing is not done yet
        if (containerRect.height === headerRect.height) {
            await me.timeout(100);
            await me.passSizeToBody(silent)
        } else {
            me.body[silent ? 'setSilent' : 'set']({
                availableHeight: containerRect.height - headerRect.height,
                containerWidth : containerRect.width
            })
        }
    }

    /**
     * @param {String} dataField
     * @protected
     */
    removeSortingCss(dataField) {
        this.headerToolbar?.items.forEach(column => {
            if (column.dataField !== dataField) {return;
                // removed by dead control flow

                // removed by dead control flow

            }
        })
    }

    /**
     * Used for keyboard navigation (selection models)
     * @param {Number} index
     * @param {Number} step
     */
    scrollByColumns(index, step) {
        let me           = this,
            {body}       = me,
            {columnPositions, containerWidth, mountedColumns, visibleColumns} = body,
            countColumns = columnPositions.getCount(),
            newIndex     = index + step,
            column, mounted, scrollLeft, visible;

        if (newIndex >= countColumns) {
            newIndex %= countColumns;
            step     = newIndex - index
        }

        while (newIndex < 0) {
            newIndex += countColumns;
            step     += countColumns
        }

        mounted = newIndex >= mountedColumns[0] && newIndex <= mountedColumns[1];

        // Not using >= or <=, since the first / last column might not be fully visible
        visible = newIndex > visibleColumns[0] && newIndex < visibleColumns[1];

        if (!visible) {
            // Leaving the mounted area will re-calculate the visibleColumns for us
            if (mounted) {
                visibleColumns[0] += step;
                visibleColumns[1] += step
            }

            column = columnPositions.getAt(newIndex);

            if (step < 0) {
                scrollLeft = column.x
            } else {
                scrollLeft = column.x - containerWidth + column.width
            }

            Neo.main.DomAccess.scrollTo({
                direction: 'left',
                id       : me.id,
                value    : scrollLeft,
                windowId : me.windowId
            })
        }
    }

    /**
     * Serializes the instance into a JSON-compatible object for the Neural Link.
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            body             : me.body?.toJSON(),
            cellEditing      : me.cellEditing,
            columns          : me.columns?.items.map(item => item.toJSON()),
            headerToolbar    : me.headerToolbar?.toJSON(),
            rowHeight        : me.rowHeight,
            scrollbar        : me.scrollbar?.toJSON(),
            scrollManager    : me.scrollManager?.toJSON(),
            showHeaderFilters: me.showHeaderFilters,
            sortable         : me.sortable,
            store            : me.store?.toJSON()
        }
    }

    /**
     * @param {Boolean} [silent=false]
     */
    updateColCount(silent=false) {
        let me = this;

        me.getVdomRoot()['aria-colcount'] = me.columns.count;
        !silent && me.update()
    }

    /**
     * @param {Number} [count] The total number of rows in the store. Optional, will use store.count if not provided.
     * @param {Boolean} [silent=false]
     */
    updateRowCount(count, silent=false) {
        let me         = this,
            finalCount = count ? count : me.store.count;

        me.getVdomRoot()['aria-rowcount'] = finalCount + 1;
        !silent && me.update()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(GridContainer));


/***/ },

/***/ "./src/grid/ScrollManager.mjs"
/*!************************************!*\
  !*** ./src/grid/ScrollManager.mjs ***!
  \************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.grid.ScrollManager
 * @extends Neo.core.Base
 */
class ScrollManager extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @member {Object} delayable
     * @protected
     * @static
     */
    static delayable = {
        onBodyScroll     : {type: 'throttle', timer:  16},
        onBodyScrollEnd  : {type: 'buffer',   timer: 150},
        onContainerScroll: {type: 'throttle', timer:  16}
    }

    static config = {
        /**
         * @member {String} className='Neo.grid.ScrollManager'
         * @protected
         */
        className: 'Neo.grid.ScrollManager',
        /**
         * @member {Boolean} dragScroll_=true
         * @reactive
         */
        dragScroll_: true,
        /**
         * @member {Boolean} mounted_=false
         * @protected
         * @reactive
         */
        mounted_: false,
        /**
         * @member {Number} scrollLeft_=0
         * @protected
         * @reactive
         */
        scrollLeft_: 0,
        /**
         * @member {Number} scrollTop_=0
         * @protected
         * @reactive
         */
        scrollTop_: 0
    }

    /**
     * @member {Neo.grid.Body|null} gridBody=null
     * @protected
     */
    gridBody = null
    /**
     * @member {Neo.grid.Container|null} gridContainer=null
     * @protected
     */
    gridContainer = null

    /**
     * @param {Boolean} value
     * @param {Boolean} oldValue
     */
    afterSetDragScroll(value, oldValue) {
        let cls = 'neo-mouse-drag-scroll';

        if (value) {
            this.gridBody.addCls(cls)
        } else if (oldValue) {
            this.gridBody.removeCls(cls)
        }

        if (this.mounted) {
            this.updateDragScrollAddon(value)
        }
    }

    /**
     * @param {Boolean} value
     * @param {Boolean} oldValue
     */
    afterSetMounted(value, oldValue) {
        if (value) {
            this.dragScroll && this.updateDragScrollAddon(true)
        } else if (oldValue) {
            this.updateDragScrollAddon(false)
        }
    }

    /**
     * Only triggers for vertical scrolling
     * @param {Object} data
     * @protected
     */
    onBodyScroll({scrollTop}) {
        let me   = this,
            body = me.gridBody;

        me.scrollTop = scrollTop;

        body.set({isScrolling: true, scrollTop});

        me.onBodyScrollEnd()
    }

    /**
     * @protected
     */
    onBodyScrollEnd() {
        this.gridBody.isScrolling = false
    }

    /**
     * @param {Object} data
     * @param {Number} data.scrollLeft
     * @param {Object} data.target
     */
    onContainerScroll({scrollLeft, target}) {
        let me   = this,
            body = me.gridBody;

        // We must ignore events for grid-scrollbar
        if (target.id.includes('grid-container')) {
            body.isScrolling = true;
            me.onBodyScrollEnd();

            me  .scrollLeft = scrollLeft;
            body.scrollLeft = scrollLeft;

            me.gridContainer.headerToolbar.scrollLeft = scrollLeft
        }
    }

    /**
     * @param {Boolean} active
     * @returns {Promise<void>}
     */
    async updateDragScrollAddon(active) {
        let me    = this,
            addon = await Neo.currentWorker.getAddon('GridDragScroll', me.windowId);

        if (active) {
            addon.register({
                bodyId     : me.gridBody.id + '__wrapper',
                containerId: me.gridContainer.id,
                id         : me.id
            })
        } else {
            addon.unregister({id: me.id})
        }
    }

    /**
     * @returns {Object}
     */
    toJSON() {
        return {
            ...super.toJSON(),
            scrollLeft: this.scrollLeft,
            scrollTop : this.scrollTop
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(ScrollManager));


/***/ },

/***/ "./src/grid/VerticalScrollbar.mjs"
/*!****************************************!*\
  !*** ./src/grid/VerticalScrollbar.mjs ***!
  \****************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");


/**
 * We do not want to use the default scrollbar for vertical scrolling, since it would show up at the right edge
 * of the last column. Instead, we want to show it at the right edge of the container (always visible when scrolling).
 * @class Neo.grid.VerticalScrollbar
 * @extends Neo.component.Base
 */
class VerticalScrollbar extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.grid.VerticalScrollbar'
         * @protected
         */
        className: 'Neo.grid.VerticalScrollbar',
        /**
         * @member {String} ntype='grid-vertical-scrollbar'
         * @protected
         */
        ntype: 'grid-vertical-scrollbar',
        /**
         * @member {String[]} baseCls=['neo-grid-vertical-scrollbar']
         * @protected
         */
        baseCls: ['neo-grid-vertical-scrollbar'],
        /**
         * Number in px
         * @member {Number} rowHeight_=0
         * @reactive
         */
        rowHeight_: 0,
        /**
         * @member {Neo.data.Store|null} store_=null
         * @reactive
         */
        store_: null,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {cn: [
            {cls: ['neo-grid-scrollbar-content']}
        ]}
    }

    /**
     * @param {Boolean} mounted
     * @protected
     */
    async addScrollSync(mounted) {
        let me         = this,
            {windowId} = me,
            ScrollSync = await Neo.currentWorker.getAddon('ScrollSync', windowId),
            params     = {id: me.id, windowId};

        if (mounted) {
            ScrollSync.register({
                fromId: me.parent.body.vdom.id,
                toId  : me.id,
                twoWay: Neo.config.hasMouseEvents, // Syncing the scroller back to the body affects mobile scrolling
                ...params
            })
        } else {
            ScrollSync.unregister(params)
        }
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);
        oldValue !== undefined && this.addScrollSync(value)
    }

    /**
     * Triggered after the rowHeight config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetRowHeight(value, oldValue) {
        value > 0 && this.updateScrollHeight()
    }

    /**
     * Triggered after the store config got changed
     * @param {Neo.data.Store|null} value
     * @param {Neo.data.Store|null} oldValue
     * @protected
     */
    afterSetStore(value, oldValue) {
        if (value) {
            let me = this;

            value.on({
                filter: me.updateScrollHeight,
                load  : me.updateScrollHeight,
                scope : me
            })
        }
    }

    /**
     * @param {Object}   data
     * @param {Object[]} data.items
     * @param {Number}   [data.total]
     * @protected
     */
    updateScrollHeight(data) {
        let me           = this,
            countRecords = data?.total ? data.total : me.store.count,
            {rowHeight}  = me;

        if (countRecords > 0 && rowHeight > 0) {
            me.vdom.cn[0].height = `${(countRecords + 1) * rowHeight}px`;
            me.update()
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(VerticalScrollbar));


/***/ },

/***/ "./src/grid/column/AnimatedChange.mjs"
/*!********************************************!*\
  !*** ./src/grid/column/AnimatedChange.mjs ***!
  \********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/grid/column/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");




/**
 * @class Neo.grid.column.AnimatedChange
 * @extends Neo.grid.column.Base
 */
class AnimatedChange extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.grid.column.AnimatedChange'
         * @protected
         */
        className: 'Neo.grid.column.AnimatedChange',
        /**
         * @member {String} animationCls='neo-animated'
         */
        animationCls: 'neo-animated',
        /**
         * @member {String} type='animatedChange'
         * @protected
         */
        type: 'animatedChange'
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.parent.store.on({
            recordChange: me.onRecordChange,
            scope       : me
        })
    }

    /**
     * Override as needed for dynamic record-based animation classes
     * @param {Record} record
     * @returns {String}
     */
    getAnimationCls(record) {
        return this.animationCls
    }

    /**
     * @param {Object}         data
     * @param {Object[]}       data.fields Each field object contains the keys: name, oldValue, value
     * @param {Neo.data.Model} data.model The model instance of the changed record
     * @param {Object}         data.record
     */
    async onRecordChange({fields, record}) {
        let me     = this,
            {body} = me.parent,
            cellId, field, node;

        for (field of fields) {
            if (field.name === me.dataField) {
                // Wait for the next animation frame
                await me.timeout(20);

                cellId = body.getCellId(me.parent.store.indexOf(record), me.dataField);
                node   = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].find(body.vdom, cellId)?.vdom;

                if (node) {
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(node.cls, me.getAnimationCls(record));

                    // This will trigger a 2nd body update, after grid.Body: onStoreRecordChange()
                    // It is crucial to restart the keyframe based animation
                    // => The previous update call will remove the last animationCls
                    body.update()
                }

                break
            }
        }
    }

    /**
     * Serializes the instance into a JSON-compatible object for the Neural Link.
     * @returns {Object}
     */
    toJSON() {
        return {
            ...super.toJSON(),
            animationCls: this.animationCls
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(AnimatedChange));


/***/ },

/***/ "./src/grid/column/AnimatedCurrency.mjs"
/*!**********************************************!*\
  !*** ./src/grid/column/AnimatedCurrency.mjs ***!
  \**********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _AnimatedChange_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AnimatedChange.mjs */ "./src/grid/column/AnimatedChange.mjs");


/**
 * @class Neo.grid.column.AnimatedCurrency
 * @extends Neo.grid.column.AnimatedChange
 */
class AnimatedCurrency extends _AnimatedChange_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.grid.column.AnimatedCurrency'
         * @protected
         */
        className: 'Neo.grid.column.AnimatedCurrency',
        /**
         * @member {String} type='animatedCurrency'
         * @protected
         */
        type: 'animatedCurrency',
        /**
         * Set a different record field to base the change on.
         * Defaults this.dataField
         * @member {String|null} compareField=null
         */
        compareField: null,
        /**
         * @member {String} currency='USD'
         */
        currency: 'USD',
        /**
         * @member {String} locale='default'
         */
        locale: 'default'
    }

    /**
     * @member {Intl.NumberFormat|null} formatter=null
     */
    formatter = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);
        this.createFormatter()
    }

    /**
     * @param {Object}             data
     * @param {Neo.button.Base}    data.column
     * @param {Number}             data.columnIndex
     * @param {String}             data.dataField
     * @param {Neo.grid.Container} data.gridContainer
     * @param {Object}             data.record
     * @param {Number}             data.rowIndex
     * @param {Neo.data.Store}     data.store
     * @param {Number|String}      data.value
     * @returns {*}
     */
    cellRenderer({column, value}) {
        if (value === null || value === undefined) {
            return ''
        }

        return column.formatter.format(value)
    }

    /**
     *
     */
    createFormatter() {
        let me = this;

        me.formatter = new Intl.NumberFormat(me.locale, {style: 'currency', currency: me.currency})
    }

    /**
     * Override as needed for dynamic record-based animation classes
     * @param {Record} record
     * @returns {String}
     */
    getAnimationCls(record) {
        return record[this.compareField || this.dataField] < 0 ? 'neo-animated-negative' : 'neo-animated-positive'
    }

    /**
     * Serializes the instance into a JSON-compatible object for the Neural Link.
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            compareField: me.compareField,
            currency    : me.currency,
            locale      : me.locale
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(AnimatedCurrency));


/***/ },

/***/ "./src/grid/column/Base.mjs"
/*!**********************************!*\
  !*** ./src/grid/column/Base.mjs ***!
  \**********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Function.mjs */ "./src/util/Function.mjs");



/**
 * @class Neo.grid.column.Base
 * @extends Neo.core.Base
 */
class Column extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.grid.column.Base'
         * @protected
         */
        className: 'Neo.grid.column.Base',
        /**
         * @member {String|null} dataField=null
         */
        dataField: null,
        /**
         * @member {Neo.grid.Container|null} parent=null
         */
        parent: null,
        /**
         * @member {Function|String|null} renderer_='cellRenderer'
         * @reactive
         */
        renderer_: 'cellRenderer',
        /**
         * Scope to execute the column renderer.
         * Defaults to the grid.Body.
         * You can pass the strings 'this' or 'me'
         * @member {Neo.core.Base|String|null} rendererScope=null
         */
        rendererScope: null,
        /**
         * @member {String} type='column'
         * @protected
         */
        type: 'column',
        /**
         * @member {Number|null} windowId_=null
         * @reactive
         */
        windowId_: null
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        value && Neo.currentWorker.insertThemeFiles(value, this.__proto__)
    }

    /**
     * Triggered before the renderer config gets changed
     * @param {Function|String|null} value
     * @param {Function|String|null} oldValue
     * @protected
     */
    beforeSetRenderer(value, oldValue) {
        // If no fn is found inside the parent tree, return the plain value for view controllers to match
        return (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveCallback)(value, this).fn || value
    }

    /**
     * @param {Object}             data
     * @param {Neo.button.Base}    data.column
     * @param {Number}             data.columnIndex
     * @param {String}             data.dataField
     * @param {Neo.grid.Container} data.gridContainer
     * @param {Object}             data.record
     * @param {Number}             data.rowIndex
     * @param {Neo.data.Store}     data.store
     * @param {Number|String}      data.value
     * @returns {*}
     */
    cellRenderer({value}) {
        return value
    }

    /**
     * Serializes the instance into a JSON-compatible object for the Neural Link.
     * @returns {Object}
     */
    toJSON() {
        let me  = this,
            out = super.toJSON();

        out.dataField = me.dataField;
        out.type      = me.type;

        if (Neo.isString(me.renderer)) {
            out.renderer = me.renderer
        }

        return out
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Column));


/***/ },

/***/ "./src/grid/column/Component.mjs"
/*!***************************************!*\
  !*** ./src/grid/column/Component.mjs ***!
  \***************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/grid/column/Base.mjs");


/**
 * @class Neo.grid.column.Component
 * @extends Neo.grid.column.Base
 */
class Component extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.grid.column.Component'
         * @protected
         */
        className: 'Neo.grid.column.Component',
        /**
         * @member {Function|Object|null} component=null
         */
        component: null,
        /**
         * @member {Object} defaults
         * @protected
         */
        defaults: null,
        /**
         * Components can delegate event listeners (or button handlers) into methods somewhere inside
         * the view controller or component tree hierarchy.
         *
         * In this case, it is helpful to know what the related record is, so we are adding the record
         * to the component as a property. By default, as 'record', but this config can change the property name.
         * @member {String} recordProperty='record'
         */
        recordProperty: 'record',
        /**
         * @member {String} rendererScope='this'
         * @protected
         */
        rendererScope: 'this',
        /**
         * @member {String} type='component'
         * @protected
         */
        type: 'component',
        /**
         * Set this config to true, in case you want to use 'bind' inside your cell based component.
         * @member {Boolean} useBindings=false
         */
        useBindings: false
    }

    /**
     * @member {Map} map=new Map()
     * @protected
     */
    map = new Map()

    /**
     * Override as needed inside class extensions
     * @param {Object} config
     * @param {Record} record
     * @returns {Object}
     */
    applyRecordConfigs(config, record) {
        return config
    }

    /**
     * @param {Object}             data
     * @param {Neo.column.Base}    data.column
     * @param {Number}             data.columnIndex
     * @param {String}             data.dataField
     * @param {Neo.grid.Container} data.gridContainer
     * @param {Object}             data.record
     * @param {Number}             data.rowIndex
     * @param {Neo.data.Store}     data.store
     * @param {Number|String}      data.value
     * @returns {*}
     */
    cellRenderer(data) {
        let {gridContainer, record, rowIndex} = data,
            {appName, body, windowId}         = gridContainer,
            me               = this,
            {recordProperty} = me,
            id               = me.getComponentId(rowIndex),
            component        = me.map.get(id),
            componentConfig  = me.component;

        if (Neo.typeOf(componentConfig) === 'Function') {
            componentConfig = componentConfig(data)
        }

        componentConfig = me.applyRecordConfigs(componentConfig, record);
        componentConfig = {...componentConfig};

        if (component) {
            delete componentConfig.className;
            delete componentConfig.module;
            delete componentConfig.ntype;

            componentConfig[recordProperty] = record;

            component.set(componentConfig)
        } else {
            component = Neo.create({
                ...me.defaults,
                ...componentConfig,
                appName,
                id,
                parentComponent : body,
                [recordProperty]: record,
                windowId
            });

            // We need to ensure that wrapped components always get the same index-based id.
            if (!component.vdom.id) {
                component.vdom.id = id + '__wrapper'
            }

            me.map.set(id, component)
        }

        if (me.useBindings) {
            body.getStateProvider()?.createBindings(component)
        }

        body.updateDepth = -1;

        return component.createVdomReference()
    }

    /**
     * @param {Number} rowIndex
     * @returns {String}
     */
    getComponentId(rowIndex) {
        let me     = this,
            {body} = me.parent,
            store  = body.store; // Access the store from the body

        if (store.chunkingTotal) { // Check if chunking is active
            return `${me.id}-component-${rowIndex}`; // Use rowIndex directly
        } else {
            return `${me.id}-component-${rowIndex % (body.availableRows + 2 * body.bufferRowRange)}`
        }
    }

    /**
     * Serializes the instance into a JSON-compatible object for the Neural Link.
     * @returns {Object}
     */
    toJSON() {
        let me  = this,
            out = super.toJSON();

        out.recordProperty = me.recordProperty;
        out.useBindings    = me.useBindings;

        if (Neo.isObject(me.component)) {
            out.component = me.serializeConfig(me.component)
        }

        return out
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Component));


/***/ },

/***/ "./src/grid/column/Currency.mjs"
/*!**************************************!*\
  !*** ./src/grid/column/Currency.mjs ***!
  \**************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/grid/column/Base.mjs");


/**
 * @class Neo.grid.column.Currency
 * @extends Neo.grid.column.Base
 */
class Currency extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.grid.column.Currency'
         * @protected
         */
        className: 'Neo.grid.column.Currency',
        /**
         * @member {String} type='currency'
         * @protected
         */
        type: 'currency',
        /**
         * @member {String} currency='USD'
         */
        currency: 'USD',
        /**
         * @member {String} locale='default'
         */
        locale: 'default'
    }

    /**
     * @member {Intl.NumberFormat|null} formatter=null
     */
    formatter = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);
        this.createFormatter()
    }

    /**
     * @param {Object}             data
     * @param {Neo.button.Base}    data.column
     * @param {Number}             data.columnIndex
     * @param {String}             data.dataField
     * @param {Neo.grid.Container} data.gridContainer
     * @param {Object}             data.record
     * @param {Number}             data.rowIndex
     * @param {Neo.data.Store}     data.store
     * @param {Number|String}      data.value
     * @returns {*}
     */
    cellRenderer({value}) {
        if (value === null || value === undefined) {
            return ''
        }

        return this.formatter.format(value)
    }

    /**
     *
     */
    createFormatter() {
        let me = this;

        me.formatter = new Intl.NumberFormat(me.locale, {style: 'currency', currency: me.currency})
    }

    /**
     * Serializes the instance into a JSON-compatible object for the Neural Link.
     * @returns {Object}
     */
    toJSON() {
        return {
            ...super.toJSON(),
            currency: this.currency,
            locale  : this.locale
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Currency));


/***/ },

/***/ "./src/grid/column/Index.mjs"
/*!***********************************!*\
  !*** ./src/grid/column/Index.mjs ***!
  \***********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/grid/column/Base.mjs");


/**
 * @class Neo.grid.column.Index
 * @extends Neo.grid.column.Base
 */
class Index extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.grid.column.Index'
         * @protected
         */
        className: 'Neo.grid.column.Index',
        /**
         * @member {String} type='index'
         * @protected
         */
        type: 'index',
        /**
         * @member {Boolean} zeroBased=false
         */
        zeroBased: false
    }

    /**
     * @param {Object}             data
     * @param {Neo.button.Base}    data.column
     * @param {Number}             data.columnIndex
     * @param {String}             data.dataField
     * @param {Neo.grid.Container} data.gridContainer
     * @param {Object}             data.record
     * @param {Number}             data.rowIndex
     * @param {Neo.data.Store}     data.store
     * @param {Number|String}      data.value
     * @returns {*}
     */
    cellRenderer({rowIndex}) {
        return rowIndex + (this.zeroBased ? 0 : 1)
    }

    /**
     * Serializes the instance into a JSON-compatible object for the Neural Link.
     * @returns {Object}
     */
    toJSON() {
        return {
            ...super.toJSON(),
            zeroBased: this.zeroBased
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Index));


/***/ },

/***/ "./src/grid/column/Progress.mjs"
/*!**************************************!*\
  !*** ./src/grid/column/Progress.mjs ***!
  \**************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Component.mjs */ "./src/grid/column/Component.mjs");
/* harmony import */ var _component_Progress_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../component/Progress.mjs */ "./src/component/Progress.mjs");



/**
 * @class Neo.grid.column.Progress
 * @extends Neo.grid.column.Component
 */
class Progress extends _Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.grid.column.Progress'
         * @protected
         */
        className: 'Neo.grid.column.Progress',
        /**
         * @member {Object} defaults
         * @protected
         */
        defaults: {
            module: _component_Progress_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]
        },
        /**
         * @member {String} type='progress'
         * @protected
         */
        type: 'progress'
    }

    /**
     * @param {Object} config
     * @param {Record} record
     * @returns {Object}
     */
    applyRecordConfigs(config, record) {
        return {
            value: record[this.dataField],
            ...config
        }
    }

    /**
     * Serializes the instance into a JSON-compatible object for the Neural Link.
     * @returns {Object}
     */
    toJSON() {
        return {
            ...super.toJSON(),
            defaults: this.serializeConfig(this.defaults)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Progress));


/***/ },

/***/ "./src/grid/column/_export.mjs"
/*!*************************************!*\
  !*** ./src/grid/column/_export.mjs ***!
  \*************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AnimatedChange: () => (/* reexport safe */ _AnimatedChange_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   AnimatedCurrency: () => (/* reexport safe */ _AnimatedCurrency_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   Base: () => (/* reexport safe */ _Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   Component: () => (/* reexport safe */ _Component_mjs__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   Currency: () => (/* reexport safe */ _Currency_mjs__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   Index: () => (/* reexport safe */ _Index_mjs__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   Progress: () => (/* reexport safe */ _Progress_mjs__WEBPACK_IMPORTED_MODULE_6__["default"])
/* harmony export */ });
/* harmony import */ var _AnimatedChange_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AnimatedChange.mjs */ "./src/grid/column/AnimatedChange.mjs");
/* harmony import */ var _AnimatedCurrency_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AnimatedCurrency.mjs */ "./src/grid/column/AnimatedCurrency.mjs");
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Base.mjs */ "./src/grid/column/Base.mjs");
/* harmony import */ var _Component_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Component.mjs */ "./src/grid/column/Component.mjs");
/* harmony import */ var _Currency_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Currency.mjs */ "./src/grid/column/Currency.mjs");
/* harmony import */ var _Index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Index.mjs */ "./src/grid/column/Index.mjs");
/* harmony import */ var _Progress_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Progress.mjs */ "./src/grid/column/Progress.mjs");











/***/ },

/***/ "./src/grid/header/Button.mjs"
/*!************************************!*\
  !*** ./src/grid/header/Button.mjs ***!
  \************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../button/Base.mjs */ "./src/button/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../form/field/Text.mjs */ "./src/form/field/Text.mjs");




/**
 * @class Neo.grid.header.Button
 * @extends Neo.button.Base
 */
class Button extends _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for align
     * @member {String[]} cellAlignValues: ['left','center','right']
     * @protected
     * @static
     */
    static cellAlignValues = ['left', 'center', 'right']

    static config = {
        /**
         * @member {String} className='Neo.grid.header.Button'
         * @protected
         */
        className: 'Neo.grid.header.Button',
        /**
         * @member {String} ntype='grid-header-button'
         * @protected
         */
        ntype: 'grid-header-button',
        /**
         * @member {String[]} baseCls=['neo-grid-header-button','neo-button']
         */
        baseCls: ['neo-grid-header-button', 'neo-button'],
        /**
         * Alignment of the matching grid cells. Valid values are left, center, right
         * @member {String} cellAlign_='left'
         * @reactive
         */
        cellAlign_: 'left',
        /**
         * @member {String|null} dataField=null
         */
        dataField: null,
        /**
         * Sort direction when clicking on an unsorted button
         * @member {String} defaultSortDirection='ASC'
         */
        defaultSortDirection: 'ASC',
        /**
         * @member {Object} editorConfig=null
         */
        editorConfig: null,
        /**
         * @member {Object} filterConfig=null
         */
        filterConfig: null,
        /**
         * @member {Neo.form.field.Base|null} filterField=null
         * @protected
         */
        filterField: null,
        /**
         * @member {String} iconCls='fa fa-arrow-circle-up'
         * @reactive
         */
        iconCls: 'fa fa-arrow-circle-up',
        /**
         * @member {String} iconPosition='right'
         * @reactive
         */
        iconPosition: 'right',
        /**
         * 'ASC', 'DESC' or null
         * @member {String|null} isSorted_=null
         * @protected
         * @reactive
         */
        isSorted_: null,
        /**
         * @member {String} role='columnheader'
         * @reactive
         */
        role: 'columnheader',
        /**
         * @member {Boolean} showHeaderFilter_=false
         * @reactive
         */
        showHeaderFilter_: false,
        /**
         * @member {Boolean} sortable_=true
         * @reactive
         */
        sortable_: true
    }

    /**
     * Triggered after the isSorted config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetIsSorted(value, oldValue) {
        let me        = this,
            {cls}     = me,
            container = me.up('grid-container');

        switch (value) {
            case null:
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-sort-hidden');
                break
            case 'ASC':
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, 'neo-sort-desc');
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, 'neo-sort-hidden');
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-sort-asc');
                break
            case 'DESC':
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, 'neo-sort-asc');
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, 'neo-sort-hidden');
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-sort-desc');
                break
        }

        me.cls = cls;

        // testing check until all example grids have a store
        if (!container || !container.store) {
            return
        }

        me.mounted && me.fire('sort', {
            direction: value,
            property : me.dataField
        })
    }

    /**
     * Triggered after the showHeaderFilter config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowHeaderFilter(value, oldValue) {
        let me = this;

        if (value) {
            if (!me.filterField) {
                me.filterField = Neo.create({
                    module   : _form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
                    appName  : me.appName,
                    flag     : 'filter-field',
                    hideLabel: true,
                    parentId : me.id,
                    style    : {marginLeft: '.5em', marginRight: '.5em'},
                    windowId : me.windowId,

                    listeners: {
                        change        : me.changeFilterValue,
                        operatorChange: me.changeFilterOperator,
                        scope         : me
                    },

                    ...me.editorConfig
                });

                me.vdom.cn.push(me.filterField.createVdomReference())
            } else {
                delete me.filterField.vdom.removeDom
            }
        } else if (me.filterField) {
            me.filterField.vdom.removeDom = true
        }

        me.updateDepth = 2;
        me.update()
    }

    /**
     * Triggered after the sortable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetSortable(value, oldValue) {
        let me    = this,
            {cls} = me;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].toggle(cls, 'neo-sort-hidden', !value);

        me.cls = cls;
        me.update()
    }

    /**
     * Triggered before the cellAlign config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetCellAlign(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'cellAlign', 'cellAlignValues')
    }

    /**
     *
     */
    destroy(...args) {
        this.filterField?.destroy();
        super.destroy(...args)
    }

    /**
     * @param {Object} data
     * @protected
     */
    onClick(data) {
        let me = this,
            map;

        if (me.defaultSortDirection === 'DESC') {
            map = {
                ASC : null,
                DESC: 'ASC',
                null: 'DESC'
            }
        } else {
            map = {
                ASC : 'DESC',
                DESC: null,
                null: 'ASC'
            }
        }

        me.isSorted = map[me.isSorted + ''];

        super.onClick(data)
    }

    /**
     * @param {Object} data
     */
    changeFilterOperator(data) {
        let me            = this,
            gridContainer = me.up('grid-container'),
            store         = gridContainer?.store,
            operator      = data.value,
            filter, filters;

        if (store) {
            filter = store.getFilter(me.dataField);

            if (!filter) {
                filters = store.filters;

                filters.push({
                    property: me.dataField,
                    operator,
                    value   : null,
                    ...me.filterConfig
                });

                store.filters = filters
            } else {
                filter.operator = operator
            }
        }
    }

    /**
     * @param {Object} data
     */
    changeFilterValue(data) {
        let me            = this,
            gridContainer = me.up('grid-container'),
            store         = gridContainer?.store,
            {value}       = data,
            field, filter, filters, model;

        if (store) {
            filter = store.getFilter(me.dataField);
            model  = store.model;
            field  = model.getField(me.dataField);

            if (value && field?.type.toLowerCase() === 'date') {
                value = new Date(value)
            }

            if (!filter) {
                filters = store.filters;

                filters.push({
                    property: me.dataField,
                    operator: 'like',
                    value,
                    ...me.filterConfig
                });

                store.filters = filters
            } else {
                filter.value = value
            }
        }
    }

    /**
     * @protected
     */
    removeSortingCss() {
        let me    = this,
            {cls} = me;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-sort-hidden');

        me.cls       = cls;
        me._isSorted = null
    }

    /**
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            cellAlign           : me.cellAlign,
            dataField           : me.dataField,
            defaultSortDirection: me.defaultSortDirection,
            editorConfig        : me.serializeConfig(me.editorConfig),
            filterConfig        : me.serializeConfig(me.filterConfig),
            isSorted            : me.isSorted,
            showHeaderFilter    : me.showHeaderFilter,
            sortable            : me.sortable
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Button));


/***/ },

/***/ "./src/grid/header/Toolbar.mjs"
/*!*************************************!*\
  !*** ./src/grid/header/Toolbar.mjs ***!
  \*************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../toolbar/Base.mjs */ "./src/toolbar/Base.mjs");


/**
 * @class Neo.grid.header.Toolbar
 * @extends Neo.toolbar.Base
 */
class Toolbar extends _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.grid.header.Toolbar'
         * @protected
         */
        className: 'Neo.grid.header.Toolbar',
        /**
         * @member {String} ntype='grid-header-toolbar'
         * @protected
         */
        ntype: 'grid-header-toolbar',
        /**
         * @member {String[]} baseCls=['neo-grid-header-toolbar','neo-toolbar']
         */
        baseCls: ['neo-grid-header-toolbar', 'neo-toolbar'],
        /**
         * @member {Boolean} dragResortable=true
         * @reactive
         */
        dragResortable: true,
        /**
         * @member {Object} itemDefaults={ntype: 'grid-header-button'}
         * @reactive
         */
        itemDefaults: {
            ntype: 'grid-header-button'
        },
        /**
         * @member {String} role='row'
         * @reactive
         */
        role: 'row',
        /**
         * @member {Number} scrollLeft_=0
         * @reactive
         */
        scrollLeft_: 0,
        /**
         * @member {Boolean} showHeaderFilters_=false
         * @reactive
         */
        showHeaderFilters_: false,
        /**
         * Convenience shortcut to pass sortable to all toolbar items.
         * If set to true, header clicks will sort the matching column (ASC, DESC, null)
         * @member {Boolean} sortable_=true
         * @reactive
         */
        sortable_: true,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {'aria-rowindex': 1, cn: [{cn: []}]}
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);
        value && this.passSizeToBody()
    }

    /**
     * Triggered after the showHeaderFilters config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowHeaderFilters(value, oldValue) {
        if (oldValue !== undefined) {
            let me = this;

            me.items.forEach(item => {
                item.setSilent({
                    showHeaderFilter: value
                })
            });

            me.updateDepth = -1; // filters can be deeply nested
            me.update()
        }
    }

    /**
     * Triggered after the scrollLeft config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetScrollLeft(value, oldValue) {
        if (oldValue !== undefined && this.sortZone) {
            this.sortZone.scrollLeft = value
        }
    }

    /**
     * Triggered after the sortable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetSortable(value, oldValue) {
        if (oldValue !== undefined) {
            let me = this;

            me.items.forEach(item => {
                item.setSilent({
                    sortable: value
                })
            });

            me.updateDepth = 2;
            me.update()
        }
    }

    /**
     *
     */
    createItems() {
        let me        = this,
            {mounted} = me;

        me.itemDefaults.showHeaderFilter = me.showHeaderFilters;

        me.items.forEach(item => {
            if (!Object.hasOwn(item, 'sortable')) {
                item.sortable = me.sortable
            }
        });

        super.createItems();

        let {items} = me,
            style;

        items.forEach((item, index) => {
            item.vdom['aria-colindex'] = index + 1; // 1 based

            style = item.wrapperStyle;

            // todo: only add px if number
            if (item.maxWidth) {style.maxWidth = item.maxWidth + 'px'}
            if (item.minWidth) {style.minWidth = item.minWidth + 'px'}
            if (item.width)    {style.width    = item.width    + 'px'}

            item.wrapperStyle = style
        });

        me.promiseUpdate().then(() => {
            // To prevent duplicate calls, we need to check the mounted state before the update call
            mounted && me.passSizeToBody()
        })
    }

    /**
     * @param {Object} config
     */
    createSortZone(config) {
        let me = this;

        Neo.merge(config, {
            boundaryContainerId: [me.id, me.parent.id],
            scrollLeft         : me.scrollLeft
        });

        super.createSortZone(config)
    }

    /**
     * @param {String} dataField
     * @returns {Neo.button.Base|null}
     */
    getColumn(dataField) {
        for (const item of this.items) {
            if (item.dataField === dataField) {
                return item
            }
        }

        return null
    }

    /**
     * @returns {Promise<any>}
     */
    loadSortZoneModule() {
        return Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("vendors-src_draggable_container_SortZone_mjs"), __webpack_require__.e("vendors-src_draggable_DragProxyContainer_mjs-src_draggable_grid_header_toolbar_SortZone_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ../../draggable/grid/header/toolbar/SortZone.mjs */ "./src/draggable/grid/header/toolbar/SortZone.mjs"))
    }

    /**
     * @param {Boolean} silent=false
     * @returns {Promise<void>}
     */
    async passSizeToBody(silent=false) {
        let me              = this,
            {items}         = me,
            {body}          = me.parent,
            rects           = await me.getDomRect(items.map(item => item.id)),
            lastItem        = rects[rects.length - 1],
            columnPositions = rects.map((item, index) => ({dataField: items[index].dataField, width: item.width, x: item.x - rects[0].x})),
            i               = 1,
            len             = columnPositions.length,
            layoutFinished  = true;

        // If the css sizing is not done, columns after the first one can get x = 0
        for (; i < len; i++) {
            if (columnPositions[i].x === 0) {
                layoutFinished = false;
                break;
            }
        }

        // Delay for slow connections, where the container-sizing is not done yet
        if (!layoutFinished) {
            await me.timeout(100);
            await me.passSizeToBody(silent)
        } else {
            body.columnPositions.clear();
            body.columnPositions.add(columnPositions);

            body[silent ? 'setSilent' : 'set']({
                availableWidth: lastItem.x + lastItem.width - rects[0].x
            });

            !silent && body.updateMountedAndVisibleColumns()
        }
    }

    /**
     * @param {Number}  index
     * @returns {Promise<void>}
     */
    async scrollToIndex(index) {
        await Neo.main.DomAccess.scrollIntoView({
            delay   : 125,
            id      : this.items[index].id,
            windowId: this.windowId
        })
    }

    /**
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            scrollLeft       : me.scrollLeft,
            showHeaderFilters: me.showHeaderFilters,
            sortable         : me.sortable
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Toolbar));


/***/ },

/***/ "./src/grid/header/_export.mjs"
/*!*************************************!*\
  !*** ./src/grid/header/_export.mjs ***!
  \*************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Button: () => (/* reexport safe */ _Button_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   Toolbar: () => (/* reexport safe */ _Toolbar_mjs__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var _Button_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Button.mjs */ "./src/grid/header/Button.mjs");
/* harmony import */ var _Toolbar_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Toolbar.mjs */ "./src/grid/header/Toolbar.mjs");





/***/ },

/***/ "./src/selection/Model.mjs"
/*!*********************************!*\
  !*** ./src/selection/Model.mjs ***!
  \*********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");





/**
 * @class Neo.selection.Model
 * @extends Neo.core.Base
 * @mixes Neo.core.Observable
 */
class Model extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.selection.Model'
         * @protected
         */
        className: 'Neo.selection.Model',
        /**
         * @member {String} ntype='selection-model'
         * @protected
         */
        ntype: 'selection-model',
        /**
         * Placeholder for extended classes to add a custom css rule to this owner component
         * @member {String|null} cls=null
         * @protected
         */
        cls: null,
        /**
         * @member {Array} items_
         * @protected
         * @reactive
         */
        items_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_3__.isDescriptor]: true,
            clone         : 'shallow',
            cloneOnGet    : 'none',
            isEqual       : () => false,
            value         : []
        },
        /**
         * @member {String} selectedCls='selected'
         */
        selectedCls: 'neo-selected',
        /**
         * @member {Boolean} singleSelect=true
         */
        singleSelect: true,
        /**
         * Internally saves the view id, but the getter will return the matching instance
         * @member {Object} view_=null
         * @protected
         * @reactive
         */
        view_: null
    }

    /**
     * Gets triggered before getting the value of the view config
     * @param {String} value
     * @returns {Neo.component.Base}
     */
    beforeGetView(value) {
        return Neo.getComponent(this._view)
    }

    /**
     * Gets triggered before setting the value of the view config
     * @returns {String} the view id
     */
    beforeSetView(value) {
        return value && value.id
    }

    /**
     *
     */
    addDomListener() {}

    /**
     * @param {Object} item
     * @param {Boolean} [silent] true to prevent a vdom update
     * @param {Object[]|String[]} itemCollection=this.items
     * @param {String} [selectedCls]
     */
    deselect(item, silent, itemCollection=this.items, selectedCls) {
        let me     = this,
            {view} = me,
            node;

        // We hold vdom ids for now, so all incoming selections must be converted.
        item = item.isRecord ? view.getItemId(item) : Neo.isObject(item) ? item.id : item;

        if (itemCollection.includes(item)) {
            node = view.getVdomChild(item);

            if (node) {
                node.cls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(node.cls || [], selectedCls || me.selectedCls);
                delete node['aria-selected']
            }

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(itemCollection, item);

            if (!silent) {
                view.update();

                view.parent?.onDeselect?.(); // grid.Container & table.Container
                view.onDeselect?.();

                me.fire('selectionChange', {
                    selection: itemCollection
                })
            }
        } else if (!silent) {
            me.fire('noChange')
        }
    }

    /**
     * @param {Boolean} [silent] true to prevent a vdom update
     * @param {Object[]|String[]} itemCollection=this.items
     */
    deselectAll(silent, itemCollection=this.items) {
        let me     = this,
            items  = [...itemCollection],
            {view} = me;

        if (items.length) {
            items.forEach(item => {
                me.deselect(item, true)
            });

            if (!silent && items.length > 0) {
                view.update()
            }

            me.fire('selectionChange', {
                selection: this.items
            })
        } else if (!silent) {
            me.fire('noChange')
        }
    }

    /**
     *
     */
    destroy(...args) {
        this.unregister();
        super.destroy(...args)
    }

    /**
     * Important for mapping listeners to view controllers
     * @returns {Neo.controller.Component|null}
     */
    getController() {
        return this.view.getController()
    }

    /**
     * @returns {Array} this.items
     */
    getSelection() {
        return this.items
    }

    /**
     * @returns {Boolean}
     */
    hasSelection() {
        return this.items.length > 0
    }

    /**
     * @param {String} id
     * @returns {Boolean} true in case the item is selected
     */
    isSelected(id) {
        return this.items.includes(id)
    }

    /**
     * @param {Neo.component.Base} component
     */
    register(component) {
        let me  = this,
            cls = component.wrapperCls || [];

        if (me.cls && !cls.includes(me.cls)) {
            cls.push(me.cls);
            component.wrapperCls = cls
        }

        me.view = component;
        me.addDomListener();

        component.fire('selectionModelChange', {
            value: me
        })
    }

    /**
     *
     */
    removeDomListeners() {
        let me           = this,
            component    = me.view,
            domListeners = [...component.domListeners];

        component.domListeners.forEach(listener => {
            if (listener.scope === me) {
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(domListeners, listener)
            }
        });

        component.domListeners = domListeners
    }

    /**
     * @param {Object|Object[]|String[]} items
     * @param {Object[]|String[]} itemCollection=this.items
     * @param {String} [selectedCls]
     */
    select(items, itemCollection=this.items, selectedCls) {
        if (!Array.isArray(items)) {
            items = [items]
        }

        let me      = this,
            {view}  = me,
            records = items.map(item => {
                if (item.isRecord) return item;

                const recordId = view.getItemRecordId?.(item);

                return recordId && view.store?.get(recordId) || item
            });

        // We hold vdom ids for now, so all incoming selections must be converted.
        items = items.map(item => item.isRecord ? view.getItemId(item) : Neo.isObject(item) ? item.id : item);

        if (!Neo.isEqual(itemCollection, items)) {
            if (me.singleSelect && itemCollection === me.items) {
                me.deselectAll(true, itemCollection)
            }

            items.forEach(node => {
                node = view.getVdomChild(node);

                if (node) {
                    node.cls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(node.cls || [], selectedCls || me.selectedCls);
                    node['aria-selected'] = true
                }
            });

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(itemCollection, items);

            if (!view.silentSelect) {
                view.update()
            }

            view.parent?.onSelect?.(items); // grid.Container & table.Container
            view.onSelect?.(items);

            view.fire('select', {
                records,
                selection: itemCollection
            });

            me.fire('selectionChange', {
                records,
                selection: itemCollection
            })
        }
        else {
            me.fire('noChange')
        }
    }

    /**
     * @param {Object} item
     */
    toggleSelection(item) {
        let me = this;

        if (me.isSelected(item)) {
            me.deselect(item)
        } else {
            me.select(item)
        }
    }

    /**
     * @returns {Object}
     */
    toJSON() {
        const
            me    = this,
            items = (me.items || []).map(item => {
                if (Neo.isRecord(item)) {
                    return item.toJSON()
                }

                return item
            });

        return {
            ...super.toJSON(),
            items,
            selectedCls : me.selectedCls,
            singleSelect: me.singleSelect
        }
    }

    /**
     *
     */
    unregister() {
        let me     = this,
            {view} = me;

        if (!view.isDestroying) {
            let cls = view.wrapperCls || [];

            if (me.cls && cls.includes(me.cls)) {
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, me.cls);
                view.wrapperCls = cls
            }

            me.deselectAll();

            me.removeDomListeners()
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Model));


/***/ },

/***/ "./src/selection/grid/BaseModel.mjs"
/*!******************************************!*\
  !*** ./src/selection/grid/BaseModel.mjs ***!
  \******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Model_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Model.mjs */ "./src/selection/Model.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * Abstract base class for all grid related selection models
 * @class Neo.selection.grid.BaseModel
 * @extends Neo.selection.Model
 * @abstract
 */
class BaseModel extends _Model_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.selection.grid.BaseModel'
         * @protected
         */
        className: 'Neo.selection.grid.BaseModel',
        /**
         * Storing the column dataFields
         * @member {String[]} selectedColumns=[]
         */
        selectedColumns: [],
        /**
         * Storing the record ids
         * @member {Number[]|String[]} selectedRows=[]
         * @protected
         */
        selectedRows: []
    }

    /**
     * Convenience shortcut
     * @member {String[]} dataFields
     */
    get dataFields() {
        return this.view.parent.columns.items.map(column => column.dataField)
    }

    /**
     * @param {Boolean} [silent=false] true to prevent a vdom update
     */
    deselectAllRows(silent=false) {
        let me     = this,
            items  = [...me.selectedRows],
            {view} = me;

        if (items.length) {
            items.forEach(item => {
                me.deselectRow(item, true)
            });

            if (!silent && items.length > 0) {
                view.update()
            }

            me.fire('selectionChange', {
                records  : me.selectedRows.map(id => view.store.get(id)),
                selection: me.selectedRows
            })
        } else if (!silent) {
            me.fire('noChange')
        }
    }

    /**
     * @param {Number|String} recordId
     * @param {Boolean}       [silent=false]
     */
    deselectRow(recordId, silent=false) {
        let me      = this,
            {view}  = me,
            {store} = view,
            record  = store.get(recordId),
            rowId   = view.getRowId(store.indexOf(record)),
            node    = view.getVdomChild(rowId);

        if (node) {
            node.cls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(node.cls || [], me.selectedCls);
            delete node['aria-selected']
        }

        me.selectedRows = [recordId];

        !silent && view.update()
    }

    /**
     * Get the record for a given event path
     * @param {Object[]} path
     * @returns {Number|String|null}
     */
    getRecord(path) {
        let node, rowIndex;

        for (node of path) {
            if (node.aria.rowindex) {
                rowIndex = parseInt(node.aria.rowindex);

                // aria-rowindex is 1 based & also includes the header
                rowIndex -= 2;

                return this.view.store.getAt(rowIndex)
            }
        }

        return null
    }

    /**
     * @param {Record} record
     * @returns {Boolean}
     */
    hasAnnotations(record) {
        return !!Object.getOwnPropertyDescriptor(record.__proto__, this.view.selectedRecordField)
    }

    /**
     * Checks if an event path contains a grid cell editor
     * @param {Object}   data
     * @param {Object[]} data.path
     * @returns {Boolean}
     */
    hasEditorFocus({path}) {
        for (const node of path) {
            if (node.cls?.includes('neo-grid-editor')) {
                return true
            }
        }

        return false
    }

    /**
     * @param {String} dataField
     * @returns {Boolean} true in case the column is selected
     */
    isSelectedColumn(dataField) {
        return this.selectedColumns.includes(dataField)
    }

    /**
     * @param {Number|String} recordId
     * @returns {Boolean} true in case the row is selected
     */
    isSelectedRow(recordId) {
        return this.selectedRows.includes(recordId)
    }

    /**
     * @param {Number|String} recordId
     * @param {Boolean}       [silent=false]
     */
    selectRow(recordId, silent=false) {
        let me      = this,
            {view}  = me,
            {store} = view,
            record  = store.get(recordId),
            rowId   = view.getRowId(store.indexOf(record)),
            node    = view.getVdomChild(rowId);

        if (me.singleSelect) {
            me.deselectAllRows(true)
        }

        if (node) {
            node.cls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(node.cls || [], me.selectedCls);
            node['aria-selected'] = true
        }

        me.selectedRows = [recordId];

        !silent && view.update()
    }

    /**
     * @param {Number|String} recordId
     * @param {Boolean}       [silent=false]
     */
    toggleRowSelection(recordId, silent=false) {
        this[this.isSelectedRow(recordId) ? 'deselectRow' : 'selectRow'](recordId, silent)
    }

    /**
     * @returns {Object}
     */
    toJSON() {
        return {
            ...super.toJSON(),
            selectedColumns: this.selectedColumns,
            selectedRows   : this.selectedRows
        }
    }

    /**
     *
     */
    unregister() {
        let me        = this,
            countRows = me.selectedRows.length;

        me.selectedRows = [];

        countRows > 0 && me.view.createViewData();

        super.unregister()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(BaseModel));


/***/ },

/***/ "./src/selection/grid/RowModel.mjs"
/*!*****************************************!*\
  !*** ./src/selection/grid/RowModel.mjs ***!
  \*****************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _BaseModel_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseModel.mjs */ "./src/selection/grid/BaseModel.mjs");


/**
 * @class Neo.selection.grid.RowModel
 * @extends Neo.selection.grid.BaseModel
 */
class RowModel extends _BaseModel_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.selection.grid.RowModel'
         * @protected
         */
        className: 'Neo.selection.grid.RowModel',
        /**
         * @member {String} ntype='selection-grid-rowmodel'
         * @protected
         */
        ntype: 'selection-grid-rowmodel',
        /**
         * @member {String} cls='neo-selection-rowmodel'
         * @protected
         */
        cls: 'neo-selection-rowmodel'
    }

    /**
     *
     */
    addDomListener() {
        let me = this;

        me.view.parent.on('rowClick', me.onRowClick, me)
    }

    /**
     * @param args
     */
    destroy(...args) {
        let me = this;

        me.view.parent.un('rowClick', me.onRowClick, me);

        super.destroy(...args)
    }

    /**
     * @param {Object} data
     */
    onKeyDownDown(data) {
        !this.hasEditorFocus(data) && this.onNavKeyRow(1)
    }

    /**
     * @param {Object} data
     */
    onKeyDownUp(data) {
        !this.hasEditorFocus(data) && this.onNavKeyRow(-1)
    }

    /**
     * @param {Number} step
     */
    onNavKeyRow(step) {
        let me           = this,
            {view}       = me,
            {store}      = view,
            countRecords = store.getCount(),
            keyProperty  = store.getKeyProperty(),
            recordId     = me.selectedRows[0] || store.getAt(0)[keyProperty],
            record       = store.get(recordId),
            index        = store.indexOf(record),
            newIndex     = (index + step) % countRecords;

        while (newIndex < 0) {
            newIndex += countRecords
        }

        record = store.getAt(newIndex);

        if (me.hasAnnotations(record)) {
            me.updateAnnotations(record)
        } else {
            recordId = record[keyProperty];

            if (recordId) {
                me.selectRow(recordId);

                view.scrollByRows(index, step);
                view.fire('select', {record})
            }
        }
    }

    /**
     * @param {Object} data
     */
    onRowClick({data}) {
        let me     = this,
            {view} = me,
            record = me.getRecord(data.path),
            recordId;

        if (record) {
            if (me.hasAnnotations(record)) {
                me.updateAnnotations(record)
            } else {
                recordId = record[view.store.getKeyProperty()];

                me.toggleRowSelection(recordId);

                view.fire(me.isSelectedRow(recordId) ? 'select' : 'deselect', {record})
            }
        }
    }

    /**
     * @param {Neo.component.Base} component
     */
    register(component) {
        super.register(component);

        let {id, view} = this;

        view.keys?._keys.push(
            {fn: 'onKeyDownDown', key: 'Down', scope: id},
            {fn: 'onKeyDownUp',   key: 'Up',   scope: id}
        )
    }

    /**
     *
     */
    unregister() {
        let {id, view} = this;

        view.keys?.removeKeys([
            {fn: 'onKeyDownDown', key: 'Down', scope: id},
            {fn: 'onKeyDownUp',   key: 'Up',   scope: id}
        ]);

        super.unregister()
    }

    /**
     * @param {Record} record
     */
    updateAnnotations(record) {
        let me               = this,
            {view}           = me,
            {store}          = view,
            recordId         = record[store.getKeyProperty()],
            isSelected       = me.isSelectedRow(recordId),
            annotationsField = view.selectedRecordField;

        if (me.singleSelect) {
            if (isSelected) {
                record[annotationsField] = false
            } else {
                me.selectedRows.forEach(recordId => {
                    // We can use setSilent(), since the last change will trigger a view update
                    store.get(recordId).setSilent({[annotationsField]: false})
                });

                record[annotationsField] = true
            }
        } else {
            record[annotationsField] = !record[annotationsField]
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(RowModel));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19ncmlkX0NvbnRhaW5lcl9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQXlDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwyREFBSTtBQUMzQjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBLFNBQVM7QUFDVCxhQUFhLGFBQWE7QUFDMUIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPOztBQUVwQjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FB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QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpTUFBa0M7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNB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QUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZ0JBQWdCLEtBQUs7QUFDckI7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7O0FBRUEsK0VBQStFLE9BQU87QUFDdEY7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBOztBQUVBLGFBQWEsVUFBVTs7QUFFdkI7QUFDQSxhQUFhLDRDQUE0QztBQUN6RCxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTs7QUFFdkI7QUFDQSxhQUFhLDRDQUE0QztBQUN6RCxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QixhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxtREFBbUQsMEJBQTBCO0FBQzdFLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSx3QkFBd0IsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvY29tcG9uZW50L1Byb2dyZXNzLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2dyaWQvQm9keS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9ncmlkL0NvbnRhaW5lci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9ncmlkL1Njcm9sbE1hbmFnZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZ3JpZC9WZXJ0aWNhbFNjcm9sbGJhci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9ncmlkL2NvbHVtbi9BbmltYXRlZENoYW5nZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9ncmlkL2NvbHVtbi9BbmltYXRlZEN1cnJlbmN5Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2dyaWQvY29sdW1uL0Jhc2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZ3JpZC9jb2x1bW4vQ29tcG9uZW50Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2dyaWQvY29sdW1uL0N1cnJlbmN5Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2dyaWQvY29sdW1uL0luZGV4Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2dyaWQvY29sdW1uL1Byb2dyZXNzLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2dyaWQvY29sdW1uL19leHBvcnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZ3JpZC9oZWFkZXIvQnV0dG9uLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2dyaWQvaGVhZGVyL1Rvb2xiYXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZ3JpZC9oZWFkZXIvX2V4cG9ydC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9zZWxlY3Rpb24vTW9kZWwubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvc2VsZWN0aW9uL2dyaWQvQmFzZU1vZGVsLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3NlbGVjdGlvbi9ncmlkL1Jvd01vZGVsLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZSBmcm9tICcuLi9jb21wb25lbnQvQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uY29tcG9uZW50LlByb2dyZXNzXG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqL1xuY2xhc3MgUHJvZ3Jlc3MgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb21wb25lbnQuUHJvZ3Jlc3MnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb21wb25lbnQuUHJvZ3Jlc3MnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ncHJvZ3Jlc3MnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAncHJvZ3Jlc3MnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tcHJvZ3Jlc3MtbGFiZWwnXVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1wcm9ncmVzcyddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGxhYmVsVGV4dF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGxhYmVsVGV4dF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IG1heF89MTAwXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbWF4XzogMTAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IHZhbHVlXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbVxuICAgICAgICAgKi9cbiAgICAgICAgX3Zkb206XG4gICAgICAgIHt0YWc6ICdkaXYnLCBjbHM6IFsnbmVvLXByb2dyZXNzLXdyYXBwZXInXSwgY246IFtcbiAgICAgICAgICAgIHt0YWc6ICdsYWJlbCd9LFxuICAgICAgICAgICAge3RhZzogJ3Byb2dyZXNzJ31cbiAgICAgICAgXX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGxhYmVsXG4gICAgICovXG4gICAgZ2V0IGxhYmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZG9tLmNuWzBdXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gcHJvZ3Jlc3NcbiAgICAgKi9cbiAgICBnZXQgcHJvZ3Jlc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZkb20uY25bMV1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZW5zdXJlU3RhYmxlSWRzKCkge1xuICAgICAgICBzdXBlci5lbnN1cmVTdGFibGVJZHMoKTtcbiAgICAgICAgdGhpcy5sYWJlbC5mb3IgPSB0aGlzLmlkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBsYWJlbFRleHQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldExhYmVsVGV4dCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IHtsYWJlbH0gPSB0aGlzO1xuXG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIGxhYmVsLnJlbW92ZURvbSA9IHRydWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBsYWJlbC5yZW1vdmVEb21cbiAgICAgICAgfVxuXG4gICAgICAgIGxhYmVsLnRleHQgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbWF4IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1heCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5wcm9ncmVzcy5tYXggPSB2YWx1ZTtcbiAgICAgICAgdGhpcy51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdmFsdWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFZhbHVlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnByb2dyZXNzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IGEgZGlmZmVyZW50IHZkb20gcm9vdCBpZiBuZWVkZWQgdG8gYXBwbHkgdGhlIHRvcCBsZXZlbCBzdHlsZSBhdHRyaWJ1dGVzIG9uIGEgZGlmZmVyZW50IGxldmVsLlxuICAgICAqIE1ha2Ugc3VyZSB0byB1c2UgZ2V0Vm5vZGVSb290KCkgYXMgd2VsbCwgdG8ga2VlcCB0aGUgdmRvbSAmIHZub2RlIHRyZWVzIGluIHN5bmMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIG5ldyB2ZG9tIHJvb3RcbiAgICAgKi9cbiAgICBnZXRWZG9tUm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmRvbS5jblsxXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgYSBkaWZmZXJlbnQgdm5vZGUgcm9vdCBpZiBuZWVkZWQgdG8gYXBwbHkgdGhlIHRvcCBsZXZlbCBzdHlsZSBhdHRyaWJ1dGVzIG9uIGEgZGlmZmVyZW50IGxldmVsLlxuICAgICAqIE1ha2Ugc3VyZSB0byB1c2UgZ2V0VmRvbVJvb3QoKSBhcyB3ZWxsLCB0byBrZWVwIHRoZSB2ZG9tICYgdm5vZGUgdHJlZXMgaW4gc3luYy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgbmV3IHZub2RlIHJvb3RcbiAgICAgKi9cbiAgICBnZXRWbm9kZVJvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZub2RlLmNoaWxkTm9kZXNbMV1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFByb2dyZXNzKTtcbiIsImltcG9ydCBDbGFzc1N5c3RlbVV0aWwgZnJvbSAnLi4vdXRpbC9DbGFzc1N5c3RlbS5tanMnO1xuaW1wb3J0IENvbGxlY3Rpb24gICAgICBmcm9tICcuLi9jb2xsZWN0aW9uL0Jhc2UubWpzJztcbmltcG9ydCBDb21wb25lbnQgICAgICAgZnJvbSAnLi4vY29tcG9uZW50L0Jhc2UubWpzJztcbmltcG9ydCBOZW9BcnJheSAgICAgICAgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IFJvd01vZGVsICAgICAgICBmcm9tICcuLi9zZWxlY3Rpb24vZ3JpZC9Sb3dNb2RlbC5tanMnO1xuaW1wb3J0IFZEb21VdGlsICAgICAgICBmcm9tICcuLi91dGlsL1ZEb20ubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmdyaWQuQm9keVxuICogQGV4dGVuZHMgTmVvLmNvbXBvbmVudC5CYXNlXG4gKi9cbmNsYXNzIEdyaWRCb2R5IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5ncmlkLkJvZHknXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5ncmlkLkJvZHknLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nZ3JpZC1ib2R5J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2dyaWQtYm9keScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhbmltYXRlZFJvd1NvcnRpbmdfPWZhbHNlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgYW5pbWF0ZWRSb3dTb3J0aW5nXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBmbGFnLiBHZXRzIGNhbGN1bGF0ZWQgd2hlbiBtb3VudGluZyB0aGUgZ3JpZC5Db250YWluZXJcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBhdmFpbGFibGVIZWlnaHRfPTBcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBhdmFpbGFibGVIZWlnaHRfOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgZmxhZy4gR2V0cyBjYWxjdWxhdGVkIHdoZW4gY2hhbmdpbmcgdGhlIGF2YWlsYWJsZUhlaWdodCBjb25maWdcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBhdmFpbGFibGVSb3dzXz0wXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXZhaWxhYmxlUm93c186IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBmbGFnLiBHZXRzIGNhbGN1bGF0ZWQgYWZ0ZXIgbW91bnRpbmcgZ3JpZC5Cb2R5IHJvd3NcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBhdmFpbGFibGVXaWR0aF89MFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGF2YWlsYWJsZVdpZHRoXzogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWdyaWQtYm9keSddXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWdyaWQtYm9keSddLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG51bWJlciBvZiBjb2x1bW5zIChjZWxscykgdG8gcGFpbnQgYmVmb3JlIHRoZSBmaXJzdCBhbmQgYWZ0ZXIgdGhlIGxhc3QgdmlzaWJsZSBjb2x1bW4sXG4gICAgICAgICAqIHRvIGVuaGFuY2UgdGhlIHNjcm9sbGluZyBwZXJmb3JtYW5jZVxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGJ1ZmZlckNvbHVtblJhbmdlXz0wXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgYnVmZmVyQ29sdW1uUmFuZ2VfOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG51bWJlciBvZiByb3dzIHRvIHBhaW50IGJlZm9yZSB0aGUgZmlyc3QgYW5kIGFmdGVyIHRoZSBsYXN0IHZpc2libGUgcm93LFxuICAgICAgICAgKiB0byBlbmhhbmNlIHRoZSBzY3JvbGxpbmcgcGVyZm9ybWFuY2VcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBidWZmZXJSb3dSYW5nZV89M1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGJ1ZmZlclJvd1JhbmdlXzogMyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZSB3aGljaCBtb2RlbCBmaWVsZCBjb250YWlucyB0aGUgdmFsdWUgb2YgY29sc3BhbiBkZWZpbml0aW9uc1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNvbHNwYW5GaWVsZD0nY29sc3BhbidcbiAgICAgICAgICovXG4gICAgICAgIGNvbHNwYW5GaWVsZDogJ2NvbHNwYW4nLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgZmxhZy4gR2V0cyBjYWxjdWxhdGVkIGFmdGVyIG1vdW50aW5nIGdyaWQuQm9keSByb3dzXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gY29udGFpbmVyV2lkdGhfPTBcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluZXJXaWR0aF86IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29sbGVjdGlvbi5CYXNlfG51bGx9IGNvbHVtblBvc2l0aW9uc189bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgY29sdW1uUG9zaXRpb25zXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGhpZ2hsaWdodE1vZGlmaWVkQ2VsbHNfPWZhbHNlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgaGlnaGxpZ2h0TW9kaWZpZWRDZWxsc186IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNTY3JvbGxpbmdfPWZhbHNlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgaXNTY3JvbGxpbmdfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZGl0aW9uYWwgdXNlZCBrZXlzIGZvciB0aGUgc2VsZWN0aW9uIG1vZGVsXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0ga2V5c1xuICAgICAgICAgKi9cbiAgICAgICAga2V5czoge30sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9yZXMgdGhlIGluZGV4ZXMgb2YgdGhlIGZpcnN0ICYgbGFzdCBtb3VudGVkIGNvbHVtbnMsIGluY2x1ZGluZyBidWZmZXJDb2x1bW5SYW5nZVxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJbXX0gbW91bnRlZENvbHVtbnNfPVswLDBdXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBtb3VudGVkQ29sdW1uc186IFswLCAwXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3JlcyB0aGUgaW5kZXhlcyBvZiB0aGUgZmlyc3QgJiBsYXN0IG1vdW50ZWQgcm93cywgaW5jbHVkaW5nIGJ1ZmZlclJvd1JhbmdlXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcltdfSBtb3VudGVkUm93cz1bMCwwXVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBtb3VudGVkUm93czogWzAsIDBdLFxuICAgICAgICAvKipcbiAgICAgICAgICogT3B0aW9uYWwgY29uZmlnIHZhbHVlcyBmb3IgTmVvLmdyaWQucGx1Z2luLkFuaW1hdGVSb3dzXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gcGx1Z2luQW5pbWF0ZVJvd3NDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgcGx1Z2luQW5pbWF0ZVJvd3NDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHJvbGU9J3Jvd2dyb3VwJ1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHJvbGU6ICdyb3dncm91cCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOdW1iZXIgaW4gcHhcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSByb3dIZWlnaHRfPTBcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICByb3dIZWlnaHRfOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBzY3JvbGxMZWZ0Xz0wXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzY3JvbGxMZWZ0XzogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gc2Nyb2xsVG9wXz0wXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzY3JvbGxUb3BfOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLnNlbGVjdGlvbi5Nb2RlbH0gc2VsZWN0aW9uTW9kZWxfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzZWxlY3Rpb25Nb2RlbF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHNlbGVjdGVkUmVjb3JkRmllbGQ9J2Fubm90YXRpb25zLnNlbGVjdGVkJ1xuICAgICAgICAgKi9cbiAgICAgICAgc2VsZWN0ZWRSZWNvcmRGaWVsZDogJ2Fubm90YXRpb25zLnNlbGVjdGVkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gc3RhcnRJbmRleF89MFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHN0YXJ0SW5kZXhfOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmRhdGEuU3RvcmV8bnVsbH0gc3RvcmVfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzdG9yZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9yZXMgdGhlIGluZGV4ZXMgb2YgdGhlIGZpcnN0ICYgbGFzdCBwYWludGVkIGNvbHVtbnNcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyW119IHZpc2libGVDb2x1bW5zPVswLDBdXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHZpc2libGVDb2x1bW5zOiBbMCwgMF0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9yZXMgdGhlIGluZGV4ZXMgb2YgdGhlIGZpcnN0ICYgbGFzdCB2aXNpYmxlIHJvd3MsIGV4Y2x1ZGluZyBidWZmZXJSb3dSYW5nZVxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJbXX0gdmlzaWJsZVJvd3M9WzAsMF1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdmlzaWJsZVJvd3M6IFswLCAwXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSB3cmFwcGVyQ2xzPVsnbmVvLWdyaWQtYm9keS13cmFwcGVyJ11cbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB3cmFwcGVyQ2xzOiBbJ25lby1ncmlkLWJvZHktd3JhcHBlciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbVxuICAgICAgICAgKi9cbiAgICAgICAgX3Zkb206XG4gICAgICAgIHt0YWJJbmRleDogJy0xJywgY246IFtcbiAgICAgICAgICAgIHtjbjogW119XG4gICAgICAgIF19XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgZmxhZyB0byBhZG9wdCB0byBzdG9yZS5hZGQoKSBwYXNzaW5nIGFuIGluaXRpYWwgY2h1bmsuXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSAjaW5pdGlhbENodW5rU2l6ZT0wXG4gICAgICovXG4gICAgI2luaXRpYWxDaHVua1NpemUgPSAwXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgZmxhZyB0byBhZG9wdCB0byBzdG9yZS5hZGQoKSBwYXNzaW5nIGFuIGluaXRpYWwgY2h1bmsuXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSAjaW5pdGlhbENodW5rU2l6ZT0wXG4gICAgICovXG4gICAgI2luaXRpYWxUb3RhbFNpemUgPSAwXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gc2VsZWN0ZWRDZWxsc1xuICAgICAqL1xuICAgIGdldCBzZWxlY3RlZENlbGxzKCkge1xuICAgICAgICBsZXQge3NlbGVjdGlvbk1vZGVsfSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbk1vZGVsLm50eXBlPy5pbmNsdWRlcygnY2VsbCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0aW9uTW9kZWwuaXRlbXNcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBzZWxlY3RlZFJvd3NcbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0ZWRSb3dzKCkge1xuICAgICAgICBsZXQge3NlbGVjdGlvbk1vZGVsfSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbk1vZGVsLm50eXBlPy5pbmNsdWRlcygncm93JykpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb25Nb2RlbC5zZWxlY3RlZFJvd3NcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuYWRkRG9tTGlzdGVuZXJzKFt7XG4gICAgICAgICAgICBjbGljayAgIDogbWUub25DZWxsQ2xpY2ssXG4gICAgICAgICAgICBkYmxjbGljazogbWUub25DZWxsRG91YmxlQ2xpY2ssXG4gICAgICAgICAgICBkZWxlZ2F0ZTogJy5uZW8tZ3JpZC1jZWxsJyxcbiAgICAgICAgICAgIHNjb3BlICAgOiBtZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBjbGljayAgIDogbWUub25Sb3dDbGljayxcbiAgICAgICAgICAgIGRibGNsaWNrOiBtZS5vblJvd0RvdWJsZUNsaWNrLFxuICAgICAgICAgICAgZGVsZWdhdGU6ICcubmVvLWdyaWQtcm93JyxcbiAgICAgICAgICAgIHNjb3BlICAgOiBtZVxuICAgICAgICB9XSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGFuaW1hdGVkUm93U29ydGluZyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEFuaW1hdGVkUm93U29ydGluZyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICYmICF0aGlzLmdldFBsdWdpbignZ3JpZC1hbmltYXRlLXJvd3MnKSkge1xuICAgICAgICAgICAgaW1wb3J0KCcuL3BsdWdpbi9BbmltYXRlUm93cy5tanMnKS50aGVuKG1vZHVsZSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBwbHVnaW5zID0gbWUucGx1Z2lucyB8fCBbXTtcblxuICAgICAgICAgICAgICAgIHBsdWdpbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZTogbW9kdWxlLmRlZmF1bHQsXG4gICAgICAgICAgICAgICAgICAgIC4uLm1lLnBsdWdpbkFuaW1hdGVSb3dzQ29uZmlnXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBtZS5wbHVnaW5zID0gcGx1Z2luc1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgYXZhaWxhYmxlSGVpZ2h0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEF2YWlsYWJsZUhlaWdodCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID4gMCkge1xuICAgICAgICAgICAgdGhpcy5hdmFpbGFibGVSb3dzID0gTWF0aC5jZWlsKHZhbHVlIC8gdGhpcy5yb3dIZWlnaHQpIC0gMVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBhdmFpbGFibGVSb3dzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEF2YWlsYWJsZVJvd3ModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHZhbHVlID4gMCAmJiB0aGlzLmNyZWF0ZVZpZXdEYXRhKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGF2YWlsYWJsZVdpZHRoIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEF2YWlsYWJsZVdpZHRoKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPiAwKSB7XG4gICAgICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgICAgICBtZS52ZG9tLndpZHRoID0gdmFsdWUgKyAncHgnO1xuICAgICAgICAgICAgbWUudmRvbS5jblswXS53aWR0aCA9IHZhbHVlICsgJ3B4JztcbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGJ1ZmZlckNvbHVtblJhbmdlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEJ1ZmZlckNvbHVtblJhbmdlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuY3JlYXRlVmlld0RhdGEoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgYnVmZmVyUm93UmFuZ2UgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0QnVmZmVyUm93UmFuZ2UodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5jcmVhdGVWaWV3RGF0YSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBjb250YWluZXJXaWR0aCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRDb250YWluZXJXaWR0aCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPiAwICYmIHRoaXMudXBkYXRlTW91bnRlZEFuZFZpc2libGVDb2x1bW5zKClcbiAgICB9XG5cblxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBpc1Njcm9sbGluZyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRJc1Njcm9sbGluZyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy50b2dnbGVDbHMoJ25lby1pcy1zY3JvbGxpbmcnLCB2YWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1vdW50ZWRDb2x1bW5zIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNb3VudGVkQ29sdW1ucyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWUgJiYgdGhpcy5jcmVhdGVWaWV3RGF0YSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSByb3dIZWlnaHQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Um93SGVpZ2h0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB2YWx1ZSA+IDAgJiYgdGhpcy51cGRhdGVTY3JvbGxIZWlnaHQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc2Nyb2xsTGVmdCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTY3JvbGxMZWZ0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZU1vdW50ZWRBbmRWaXNpYmxlQ29sdW1ucygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzY3JvbGxUb3AgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U2Nyb2xsVG9wKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7YnVmZmVyUm93UmFuZ2V9ID0gbWUsXG4gICAgICAgICAgICBuZXdTdGFydEluZGV4ICAgID0gTWF0aC5mbG9vcih2YWx1ZSAvIG1lLnJvd0hlaWdodCk7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKG1lLnN0YXJ0SW5kZXggLSBuZXdTdGFydEluZGV4KSA+PSBidWZmZXJSb3dSYW5nZSkge1xuICAgICAgICAgICAgbWUuc3RhcnRJbmRleCA9IG5ld1N0YXJ0SW5kZXhcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLnZpc2libGVSb3dzWzBdID0gbmV3U3RhcnRJbmRleDtcbiAgICAgICAgICAgIG1lLnZpc2libGVSb3dzWzFdID0gbmV3U3RhcnRJbmRleCArIG1lLmF2YWlsYWJsZVJvd3NcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc2VsZWN0aW9uTW9kZWwgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOZW8uc2VsZWN0aW9uLk1vZGVsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLnNlbGVjdGlvbi5Nb2RlbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTZWxlY3Rpb25Nb2RlbCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy52bm9kZUluaXRpYWxpemVkICYmIHZhbHVlLnJlZ2lzdGVyKHRoaXMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzdGFydEluZGV4IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFN0YXJ0SW5kZXgodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5jcmVhdGVWaWV3RGF0YSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzdG9yZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTdG9yZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBsaXN0ZW5lcnMgPSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyICAgICAgOiBtZS5vblN0b3JlRmlsdGVyLFxuICAgICAgICAgICAgICAgIGxvYWQgICAgICAgIDogbWUub25TdG9yZUxvYWQsXG4gICAgICAgICAgICAgICAgcmVjb3JkQ2hhbmdlOiBtZS5vblN0b3JlUmVjb3JkQ2hhbmdlLFxuICAgICAgICAgICAgICAgIHNjb3BlICAgICAgIDogbWVcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgb2xkVmFsdWU/LnVuKGxpc3RlbmVycyk7XG4gICAgICAgIHZhbHVlICAgPy5vbihsaXN0ZW5lcnMpO1xuXG4gICAgICAgIC8vIENsZWFyIGNvbXBvbmVudCBpbnN0YW5jZXMgd2hlbiB0aGUgc3RvcmUgY2hhbmdlcyBvciBpcyByZXBsYWNlZFxuICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgIG1lLmNsZWFyQ29tcG9uZW50Q29sdW1uTWFwcygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2RhdGEuY2VsbElkXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhLmNvbHVtblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLmNvbHVtbkluZGV4XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEucmVjb3JkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEucm93SW5kZXhcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGFwcGx5UmVuZGVyZXJPdXRwdXQoe2NlbGxJZCwgY29sdW1uLCBjb2x1bW5JbmRleCwgcmVjb3JkLCByb3dJbmRleH0pIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZ3JpZENvbnRhaW5lciAgICAgICAgICA9IG1lLnBhcmVudCxcbiAgICAgICAgICAgIHtzZWxlY3RlZENlbGxzLCBzdG9yZX0gPSBtZSxcbiAgICAgICAgICAgIGNlbGxDbHMgICAgICAgICAgICAgICAgPSBbJ25lby1ncmlkLWNlbGwnXSxcbiAgICAgICAgICAgIGNvbHNwYW4gICAgICAgICAgICAgICAgPSByZWNvcmRbbWUuY29sc3BhbkZpZWxkXSxcbiAgICAgICAgICAgIHtkYXRhRmllbGR9ICAgICAgICAgICAgPSBjb2x1bW4sXG4gICAgICAgICAgICB7bW9kZWx9ICAgICAgICAgICAgICAgID0gc3RvcmUsXG4gICAgICAgICAgICBmaWVsZFZhbHVlICAgICAgICAgICAgID0gcmVjb3JkW2RhdGFGaWVsZF0sXG4gICAgICAgICAgICBjZWxsQ29uZmlnLCByZW5kZXJlck91dHB1dDtcblxuICAgICAgICBpZiAoIW1vZGVsLmdldEZpZWxkKGRhdGFGaWVsZCkpIHtcbiAgICAgICAgICAgIGxldCBuc0FycmF5ICAgPSBkYXRhRmllbGQuc3BsaXQoJy4nKSxcbiAgICAgICAgICAgICAgICBmaWVsZE5hbWUgPSBuc0FycmF5LnBvcCgpO1xuXG4gICAgICAgICAgICBmaWVsZFZhbHVlID0gTmVvLm5zKG5zQXJyYXksIGZhbHNlLCByZWNvcmRbU3ltYm9sLmZvcignZGF0YScpXSk/LltmaWVsZE5hbWVdXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmllbGRWYWx1ZSA9PT0gbnVsbCB8fCBmaWVsZFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZpZWxkVmFsdWUgPSAnJ1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbHVtbi5yZW5kZXJlclNjb3BlID09PSAnbWUnIHx8IGNvbHVtbi5yZW5kZXJlclNjb3BlID09PSAndGhpcycpIHtcbiAgICAgICAgICAgIGNvbHVtbi5yZW5kZXJlclNjb3BlID0gY29sdW1uO1xuICAgICAgICB9XG5cbiAgICAgICAgbWUuYmluZENhbGxiYWNrKGNvbHVtbi5yZW5kZXJlciwgJ3JlbmRlcmVyJywgY29sdW1uLnJlbmRlcmVyU2NvcGUgfHwgbWUsIGNvbHVtbik7XG5cbiAgICAgICAgcmVuZGVyZXJPdXRwdXQgPSBjb2x1bW4ucmVuZGVyZXIuY2FsbChjb2x1bW4ucmVuZGVyZXJTY29wZSB8fCBtZSwge1xuICAgICAgICAgICAgY29sdW1uLFxuICAgICAgICAgICAgY29sdW1uSW5kZXgsXG4gICAgICAgICAgICBkYXRhRmllbGQsXG4gICAgICAgICAgICBncmlkQ29udGFpbmVyLFxuICAgICAgICAgICAgcmVjb3JkLFxuICAgICAgICAgICAgcm93SW5kZXgsXG4gICAgICAgICAgICBzdG9yZSxcbiAgICAgICAgICAgIHZhbHVlOiBmaWVsZFZhbHVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHN3aXRjaCAoTmVvLnR5cGVPZihyZW5kZXJlck91dHB1dCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ09iamVjdCc6IHtcbiAgICAgICAgICAgICAgICBpZiAocmVuZGVyZXJPdXRwdXQuaHRtbCB8fCByZW5kZXJlck91dHB1dC50ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyT3V0cHV0LmNscyAmJiBjZWxsQ2xzLnB1c2goLi4ucmVuZGVyZXJPdXRwdXQuY2xzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJlck91dHB1dCA9IFtyZW5kZXJlck91dHB1dF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdEYXRlJzpcbiAgICAgICAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICAgICAgICBjYXNlICdTdHJpbmcnOiB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXJPdXRwdXQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNscyA6IGNlbGxDbHMsXG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHJlbmRlcmVyT3V0cHV0Py50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlbmRlcmVyT3V0cHV0ID09PSBudWxsIHx8IHJlbmRlcmVyT3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyT3V0cHV0ID0gJydcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2x1bW4uY2VsbEFsaWduICE9PSAnbGVmdCcpIHtcbiAgICAgICAgICAgIGNlbGxDbHMucHVzaCgnbmVvLScgKyBjb2x1bW4uY2VsbEFsaWduKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lLmhpZ2hsaWdodE1vZGlmaWVkQ2VsbHMpIHtcbiAgICAgICAgICAgIGlmIChyZWNvcmQuaXNNb2RpZmllZEZpZWxkKGRhdGFGaWVsZCkpIHtcbiAgICAgICAgICAgICAgICBjZWxsQ2xzLnB1c2goJ25lby1pcy1tb2RpZmllZCcpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNlbGxJZCkge1xuICAgICAgICAgICAgY2VsbElkID0gbWUuZ2V0Q2VsbElkKHJvd0luZGV4LCBjb2x1bW4uZGF0YUZpZWxkKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGVjdGVkQ2VsbHMuaW5jbHVkZXMoY2VsbElkKSkge1xuICAgICAgICAgICAgY2VsbENscy5wdXNoKCduZW8tc2VsZWN0ZWQnKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lLnNlbGVjdGlvbk1vZGVsPy5zZWxlY3RlZENvbHVtbnM/LmluY2x1ZGVzKGRhdGFGaWVsZCkpIHtcbiAgICAgICAgICAgIE5lb0FycmF5LmFkZChjZWxsQ2xzLCBtZS5zZWxlY3Rpb25Nb2RlbC5zZWxlY3RlZENvbHVtbkNlbGxDbHMgfHwgJ25lby1zZWxlY3RlZCcpXG4gICAgICAgIH1cblxuICAgICAgICBjZWxsQ29uZmlnID0ge1xuICAgICAgICAgICAgJ2FyaWEtY29saW5kZXgnOiBjb2x1bW5JbmRleCArIDEsIC8vIDEgYmFzZWRcbiAgICAgICAgICAgIGlkICAgICAgICAgICAgIDogY2VsbElkLFxuICAgICAgICAgICAgY2xzICAgICAgICAgICAgOiBjZWxsQ2xzLFxuICAgICAgICAgICAgcm9sZSAgICAgICAgICAgOiAnZ3JpZGNlbGwnLFxuICAgICAgICAgICAgc3R5bGUgICAgICAgICAgOiByZW5kZXJlck91dHB1dC5zdHlsZSB8fCB7fVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChjb2x1bW4ud2lkdGgpIHtcbiAgICAgICAgICAgIGNlbGxDb25maWcuc3R5bGUubWluV2lkdGggPSBgJHtjb2x1bW4ud2lkdGh9cHhgXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29sc3BhbiAmJiBPYmplY3Qua2V5cyhjb2xzcGFuKS5pbmNsdWRlcyhkYXRhRmllbGQpKSB7XG4gICAgICAgICAgICBjZWxsQ29uZmlnLmNvbHNwYW4gPSBjb2xzcGFuW2RhdGFGaWVsZF1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChOZW8udHlwZU9mKHJlbmRlcmVyT3V0cHV0KSA9PT0gJ09iamVjdCcpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKHJlbmRlcmVyT3V0cHV0LCAnaHRtbCcpKSB7XG4gICAgICAgICAgICAgICAgY2VsbENvbmZpZy5odG1sID0gcmVuZGVyZXJPdXRwdXQuaHRtbCAgfHwgJydcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2VsbENvbmZpZy50ZXh0ID0gcmVuZGVyZXJPdXRwdXQudGV4dCAgfHwgJydcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNlbGxDb25maWcuY24gPSByZW5kZXJlck91dHB1dFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNlbGxDb25maWdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhY2Nlc3NpbmcgdGhlIGNvbHVtblBvc2l0aW9ucyBjb25maWdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlR2V0Q29sdW1uUG9zaXRpb25zKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbHVtblBvc2l0aW9ucyA9IHZhbHVlID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgbW9kdWxlICAgICA6IENvbGxlY3Rpb24sXG4gICAgICAgICAgICAgICAga2V5UHJvcGVydHk6ICdkYXRhRmllbGQnXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgc2VsZWN0aW9uTW9kZWwgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge05lby5zZWxlY3Rpb24uTW9kZWx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uc2VsZWN0aW9uLk1vZGVsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRTZWxlY3Rpb25Nb2RlbCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWU/LmRlc3Ryb3koKTtcblxuICAgICAgICByZXR1cm4gQ2xhc3NTeXN0ZW1VdGlsLmJlZm9yZVNldEluc3RhbmNlKHZhbHVlLCBSb3dNb2RlbClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyBhbGwgY29tcG9uZW50IGluc3RhbmNlcyBjcmVhdGVkIGJ5IGNvbXBvbmVudCBjb2x1bW5zLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjbGVhckNvbXBvbmVudENvbHVtbk1hcHMoKSB7XG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbHVtbnMgPSBtZS5wYXJlbnQuY29sdW1ucy5pdGVtcztcblxuICAgICAgICBjb2x1bW5zLmZvckVhY2goY29sdW1uID0+IHtcbiAgICAgICAgICAgIGlmIChjb2x1bW4gaW5zdGFuY2VvZiBOZW8uZ3JpZC5jb2x1bW4uQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgY29sdW1uLm1hcC5mb3JFYWNoKGNvbXBvbmVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5kZXN0cm95KClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb2x1bW4ubWFwLmNsZWFyKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYW5zIHVwIGNvbXBvbmVudCBpbnN0YW5jZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIHZpc2libGUgb3IgbmVlZGVkLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjbGVhbnVwQ29tcG9uZW50SW5zdGFuY2VzKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnBhcmVudC5jb2x1bW5zLml0ZW1zLmZvckVhY2goY29sdW1uID0+IHtcbiAgICAgICAgICAgIGlmIChjb2x1bW4gaW5zdGFuY2VvZiBOZW8uZ3JpZC5jb2x1bW4uQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgY29sdW1uLm1hcC5mb3JFYWNoKChjb21wb25lbnQsIGlkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3Qgcm93SW5kZXggZnJvbSBjb21wb25lbnQgSUQgKGUuZy4sIFwiZ3JpZC1ib2R5LTEtY29tcG9uZW50LTk1MFwiKVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wb25lbnRSb3dJbmRleCA9IHBhcnNlSW50KGlkLnNwbGl0KCctJykucG9wKCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnRSb3dJbmRleCA8IG1lLm1vdW50ZWRSb3dzWzBdIHx8IGNvbXBvbmVudFJvd0luZGV4ID4gbWUubW91bnRlZFJvd3NbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4ubWFwLmRlbGV0ZShpZClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLnJlY29yZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0cy5yb3dJbmRleF1cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGNyZWF0ZVJvdyh7cmVjb3JkLCByb3dJbmRleH0pIHtcbiAgICAgICAgaWYgKCFOZW8uaXNOdW1iZXIocm93SW5kZXgpKSB7XG4gICAgICAgICAgICByb3dJbmRleCA9IHRoaXMuc3RvcmUuaW5kZXhPZihyZWNvcmQpXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7bW91bnRlZENvbHVtbnMsIHNlbGVjdGVkUm93c30gPSBtZSxcbiAgICAgICAgICAgIGdyaWRDb250YWluZXIgPSBtZS5wYXJlbnQsXG4gICAgICAgICAgICB7Y29sdW1uc30gICAgID0gZ3JpZENvbnRhaW5lcixcbiAgICAgICAgICAgIGlkICAgICAgICAgICAgPSBtZS5nZXRSb3dJZChyb3dJbmRleCksXG4gICAgICAgICAgICByZWNvcmRJZCAgICAgID0gcmVjb3JkW21lLnN0b3JlLmdldEtleVByb3BlcnR5KCldLFxuICAgICAgICAgICAgcm93Q2xzICAgICAgICA9IG1lLmdldFJvd0NsYXNzKHJlY29yZCwgcm93SW5kZXgpLFxuICAgICAgICAgICAgY29uZmlnLCBjb2x1bW4sIGNvbHVtblBvc2l0aW9uLCAgZ3JpZFJvdywgaTtcblxuICAgICAgICBpZiAocm93SW5kZXggJSAyICE9PSAwKSB7XG4gICAgICAgICAgICByb3dDbHMucHVzaCgnbmVvLWV2ZW4nKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGVjdGVkUm93cyAmJiByZWNvcmRbbWUuc2VsZWN0ZWRSZWNvcmRGaWVsZF0pIHtcbiAgICAgICAgICAgIE5lb0FycmF5LmFkZChzZWxlY3RlZFJvd3MsIHJlY29yZElkKVxuICAgICAgICB9XG5cbiAgICAgICAgZ3JpZFJvdyA9IHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgJ2FyaWEtcm93aW5kZXgnOiByb3dJbmRleCArIDIsIC8vIGhlYWRlciByb3cgPT4gMSwgZmlyc3QgYm9keSByb3cgPT4gMlxuICAgICAgICAgICAgY2xzICAgICAgICAgICAgOiByb3dDbHMsXG4gICAgICAgICAgICBjbiAgICAgICAgICAgICA6IFtdLFxuICAgICAgICAgICAgZGF0YSAgICAgICAgICAgOiB7cmVjb3JkSWR9LFxuICAgICAgICAgICAgcm9sZSAgICAgICAgICAgOiAncm93JyxcblxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBoZWlnaHQgICA6IG1lLnJvd0hlaWdodCArICdweCcsXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoMHB4LCAke3Jvd0luZGV4ICogbWUucm93SGVpZ2h0fXB4LCAwcHgpYFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChzZWxlY3RlZFJvd3M/LmluY2x1ZGVzKHJlY29yZElkKSkge1xuICAgICAgICAgICAgcm93Q2xzLnB1c2goJ25lby1zZWxlY3RlZCcpO1xuICAgICAgICAgICAgZ3JpZFJvd1snYXJpYS1zZWxlY3RlZCddID0gdHJ1ZTtcbiAgICAgICAgICAgIGdyaWRDb250YWluZXIuZmlyZSgnc2VsZWN0Jywge3JlY29yZH0pXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGk9bW91bnRlZENvbHVtbnNbMF07IGkgPD0gbW91bnRlZENvbHVtbnNbMV07IGkrKykge1xuICAgICAgICAgICAgY29sdW1uID0gY29sdW1ucy5nZXRBdChpKTtcbiAgICAgICAgICAgIGNvbmZpZyA9IG1lLmFwcGx5UmVuZGVyZXJPdXRwdXQoe2NvbHVtbiwgY29sdW1uSW5kZXg6IGksIHJlY29yZCwgcm93SW5kZXh9KTtcblxuICAgICAgICAgICAgaWYgKGNvbHVtbi5kb2NrKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLmNscyA9IFsnbmVvLWxvY2tlZCcsIC4uLmNvbmZpZy5jbHMgfHwgW11dXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbHVtblBvc2l0aW9uID0gbWUuY29sdW1uUG9zaXRpb25zLmdldChjb2x1bW4uZGF0YUZpZWxkKTtcblxuICAgICAgICAgICAgY29uZmlnLnN0eWxlID0ge1xuICAgICAgICAgICAgICAgIC4uLmNvbmZpZy5zdHlsZSxcbiAgICAgICAgICAgICAgICBsZWZ0IDogY29sdW1uUG9zaXRpb24ueCAgICAgKyAncHgnLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBjb2x1bW5Qb3NpdGlvbi53aWR0aCArICdweCdcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSGFwcGVucyBkdXJpbmcgYSBjb2x1bW4gaGVhZGVyIGRyYWcgT1AsIHdoZW4gbGVhdmluZyB0aGUgcGFpbnRlZCByYW5nZVxuICAgICAgICAgICAgaWYgKGNvbHVtblBvc2l0aW9uLmhpZGRlbikge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbidcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ3JpZFJvdy5jbi5wdXNoKGNvbmZpZylcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBncmlkUm93XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaWxlbnQ9ZmFsc2VcbiAgICAgKi9cbiAgICBjcmVhdGVWaWV3RGF0YShzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHttb3VudGVkUm93cywgc3RvcmV9ID0gbWUsXG4gICAgICAgICAgICByb3dzICAgICAgICAgICAgICAgICA9IFtdLFxuICAgICAgICAgICAgZW5kSW5kZXgsIGksIHJhbmdlO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHN0b3JlLmlzTG9hZGluZyAgICAgICAgICAgICAgICAgICB8fFxuICAgICAgICAgICAgbWUuYXZhaWxhYmxlUm93cyAgICAgICAgICAgICAgPCAxIHx8XG4gICAgICAgICAgICBtZS5fY29udGFpbmVyV2lkdGggICAgICAgICAgICA8IDEgfHwgLy8gd2UgYXJlIG5vdCBjaGVja2luZyBtZS5jb250YWluZXJXaWR0aCwgc2luY2Ugd2Ugd2FudCB0byBpZ25vcmUgdGhlIGNvbmZpZyBzeW1ib2xcbiAgICAgICAgICAgIG1lLmNvbHVtblBvc2l0aW9ucy5nZXRDb3VudCgpIDwgMSB8fFxuICAgICAgICAgICAgbWUubW91bnRlZENvbHVtbnNbMV0gICAgICAgICAgPCAxXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWUuI2luaXRpYWxDaHVua1NpemUgPiAwKSB7XG4gICAgICAgICAgICBlbmRJbmRleCA9IG1lLiNpbml0aWFsQ2h1bmtTaXplO1xuICAgICAgICAgICAgcmFuZ2UgICAgPSBlbmRJbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZXMgdGhlIG5ldyBzdGFydCAmIGVuZCBpbmRleGVzXG4gICAgICAgICAgICBtZS51cGRhdGVNb3VudGVkQW5kVmlzaWJsZVJvd3MoKTtcbiAgICAgICAgICAgIGVuZEluZGV4ID0gbW91bnRlZFJvd3NbMV1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaT1tb3VudGVkUm93c1swXTsgaSA8IGVuZEluZGV4OyBpKyspIHtcbiAgICAgICAgICAgIHJvd3MucHVzaChtZS5jcmVhdGVSb3coe3JlY29yZDogc3RvcmUuZ2V0QXQoaSksIHJvd0luZGV4OiBpfSkpXG4gICAgICAgIH1cblxuICAgICAgICBtZS5nZXRWZG9tUm9vdCgpLmNuID0gcm93cztcblxuICAgICAgICBtZS5wYXJlbnQuaXNMb2FkaW5nID0gZmFsc2U7XG5cbiAgICAgICAgbWUudXBkYXRlU2Nyb2xsSGVpZ2h0KHRydWUsIHJhbmdlKTsgLy8gc2lsZW50XG4gICAgICAgICFzaWxlbnQgJiYgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqL1xuICAgIGRlc3Ryb3koLi4uYXJncykge1xuICAgICAgICB0aGlzLnN0b3JlID0gbnVsbDsgLy8gcmVtb3ZlIHRoZSBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5jbGVhckNvbXBvbmVudENvbHVtbk1hcHMoKTsgLy8gRGVzdHJveSBjb21wb25lbnQgaW5zdGFuY2VzXG5cbiAgICAgICAgc3VwZXIuZGVzdHJveSguLi5hcmdzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICAgICAqL1xuICAgIGZpcmVDZWxsRXZlbnQoZGF0YSwgZXZlbnROYW1lKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaWQgICAgICAgID0gZGF0YS5jdXJyZW50VGFyZ2V0LFxuICAgICAgICAgICAgZGF0YUZpZWxkID0gbWUuZ2V0Q2VsbERhdGFGaWVsZChpZCksXG4gICAgICAgICAgICByZWNvcmQgICAgPSBtZS5nZXRSZWNvcmQoaWQpO1xuXG4gICAgICAgIG1lLnBhcmVudC5maXJlKGV2ZW50TmFtZSwge2JvZHk6IG1lLCBkYXRhLCBkYXRhRmllbGQsIHJlY29yZH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXG4gICAgICovXG4gICAgZmlyZVJvd0V2ZW50KGRhdGEsIGV2ZW50TmFtZSkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGlkICAgICA9IGRhdGEuY3VycmVudFRhcmdldCxcbiAgICAgICAgICAgIHJlY29yZCA9IG1lLmdldFJlY29yZChpZCk7XG5cbiAgICAgICAgbWUucGFyZW50LmZpcmUoZXZlbnROYW1lLCB7Ym9keTogbWUsIGRhdGEsIHJlY29yZH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNlbGxJZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0Q2VsbERhdGFGaWVsZChjZWxsSWQpIHtcbiAgICAgICAgcmV0dXJuIGNlbGxJZC5zcGxpdCgnX18nKVsyXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByb3dJbmRleFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhRmllbGRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldENlbGxJZChyb3dJbmRleCwgZGF0YUZpZWxkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJvd0lkKHJvd0luZGV4KSArICdfXycgKyBkYXRhRmllbGRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBncmlkIGNvbHVtbiBvciBjb2x1bW4gaW5kZXggYnkgYSBnaXZlbiBmaWVsZCBuYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSByZXR1cm5JbmRleD1mYWxzZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8TnVtYmVyfG51bGx9XG4gICAgICovXG4gICAgZ2V0Q29sdW1uKGZpZWxkLCByZXR1cm5JbmRleD1mYWxzZSkge1xuICAgICAgICBsZXQge2NvbHVtbnN9ID0gdGhpcy5wYXJlbnQsXG4gICAgICAgICAgICBjb2x1bW4gICAgPSBjb2x1bW5zLmdldChmaWVsZCk7XG5cbiAgICAgICAgaWYgKGNvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIHJldHVybkluZGV4ID8gY29sdW1ucy5pbmRleE9mKGNvbHVtbikgOiBjb2x1bW5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBwYWludGVkIGNvbHVtbiBjZWxscyAodmlzaWJsZSArIGJ1ZmZlciByYW5nZSlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YUZpZWxkXG4gICAgICogQHJldHVybnMge09iamVjdFtdfVxuICAgICAqL1xuICAgIGdldENvbHVtbkNlbGxzKGRhdGFGaWVsZCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY2VsbHMgICAgICAgPSBbXSxcbiAgICAgICAgICAgIGNvbHVtbkluZGV4ID0gLTEsXG4gICAgICAgICAgICB2ZG9tUm9vdCAgICA9IG1lLmdldFZkb21Sb290KCksXG4gICAgICAgICAgICBmaXJzdFJvdyAgICA9IHZkb21Sb290LmNuWzBdLFxuICAgICAgICAgICAgaSAgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgbGVuICAgICAgICAgPSBmaXJzdFJvdy5jbi5sZW5ndGgsXG4gICAgICAgICAgICBjZWxsO1xuXG4gICAgICAgIC8vIENvbHVtbnMgbWlnaHQgZ2V0IG1vdmVkIHZpYSBkcmFnJmRyb3AsIHNvIGxldCdzIGNoZWNrIGZvciB0aGUgY3VycmVudCBtYXRjaFxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZGF0YUZpZWxkID09PSBtZS5nZXREYXRhRmllbGQoZmlyc3RSb3cuY25baV0uaWQpKSB7XG4gICAgICAgICAgICAgICAgY29sdW1uSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbHVtbkluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHZkb21Sb290LmNuLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgICAgICAgICBjZWxsID0gcm93LmNuW2NvbHVtbkluZGV4XTtcbiAgICAgICAgICAgICAgICBjZWxsICYmIGNlbGxzLnB1c2goY2VsbClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2VsbHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2VsbElkXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXREYXRhRmllbGQoY2VsbElkKSB7XG4gICAgICAgIHJldHVybiBjZWxsSWQuc3BsaXQoJ19fJylbMl1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG1hdGNoaW5nIHJlY29yZCBieSBwYXNzaW5nIGEgcm93IGlkLCBhIGNlbGwgaWQgb3IgYW4gaWQgaW5zaWRlIGEgZ3JpZCBjZWxsLlxuICAgICAqIExpbWl0ZWQgdG8gbW91bnRlZCByb3dzIChtdXN0IGJlIGluc2lkZSB0aGUgdmRvbSkuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5vZGVJZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRSZWNvcmQobm9kZUlkKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgcmVjb3JkID0gbWUuZ2V0UmVjb3JkQnlSb3dJZChub2RlSWQpLFxuICAgICAgICAgICAgbm9kZSwgcGFyZW50Tm9kZXM7XG5cbiAgICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmVudE5vZGVzID0gVkRvbVV0aWwuZ2V0UGFyZW50Tm9kZXMobWUudmRvbSwgbm9kZUlkKTtcblxuICAgICAgICBmb3IgKG5vZGUgb2YgcGFyZW50Tm9kZXMgfHwgW10pIHtcbiAgICAgICAgICAgIHJlY29yZCA9IG1lLmdldFJlY29yZEJ5Um93SWQobm9kZS5pZCk7XG5cbiAgICAgICAgICAgIGlmIChyZWNvcmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjb3JkXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByb3dJZFxuICAgICAqIEByZXR1cm5zIHtSZWNvcmR8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRSZWNvcmRCeVJvd0lkKHJvd0lkKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBub2RlICAgICA9IG1lLmdldFZkb21DaGlsZChyb3dJZCksXG4gICAgICAgICAgICByb3dJbmRleCA9IG5vZGVbJ2FyaWEtcm93aW5kZXgnXTtcblxuICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKHJvd0luZGV4KSkge1xuICAgICAgICAgICAgLy8gYXJpYS1yb3dpbmRleCBpcyAxIGJhc2VkICYgYWxzbyBpbmNsdWRlcyB0aGUgaGVhZGVyXG4gICAgICAgICAgICByb3dJbmRleCAtPSAyO1xuXG4gICAgICAgICAgICByZXR1cm4gbWUuc3RvcmUuZ2V0QXQocm93SW5kZXgpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGFwcGx5IGN1c3RvbSBDU1MgcnVsZXMgdG8gZ3JpZCByb3dzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByb3dJbmRleFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmdbXX1cbiAgICAgKi9cbiAgICBnZXRSb3dDbGFzcyhyZWNvcmQsIHJvd0luZGV4KSB7XG4gICAgICAgIHJldHVybiBbJ25lby1ncmlkLXJvdyddXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJvd0luZGV4XG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRSb3dJZChyb3dJbmRleCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS4jaW5pdGlhbENodW5rU2l6ZSA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBgJHttZS5pZH1fX3Jvdy0ke3Jvd0luZGV4fWBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgJHttZS5pZH1fX3Jvdy0ke3Jvd0luZGV4ICUgKG1lLmF2YWlsYWJsZVJvd3MgKyAyICogbWUuYnVmZmVyUm93UmFuZ2UpfWBcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFZkb21Sb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZG9tLmNuWzBdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge09iamVjdFtdfSBUaGUgbmV3IHZkb20gaXRlbXMgcm9vdFxuICAgICAqL1xuICAgIGdldFZkb21JdGVtc1Jvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZkb20uY25bMF1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcmV0dXJucyB7TmVvLnZkb20uVk5vZGV9XG4gICAgICovXG4gICAgZ2V0Vm5vZGVSb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52bm9kZS5jaGlsZE5vZGVzWzBdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkNlbGxDbGljayhkYXRhKSB7XG4gICAgICAgIHRoaXMuZmlyZUNlbGxFdmVudChkYXRhLCAnY2VsbENsaWNrJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uQ2VsbERvdWJsZUNsaWNrKGRhdGEpIHtcbiAgICAgICAgdGhpcy5maXJlQ2VsbEV2ZW50KGRhdGEsICdjZWxsRG91YmxlQ2xpY2snKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25Db25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgc3VwZXIub25Db25zdHJ1Y3RlZCgpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsPy5yZWdpc3Rlcih0aGlzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Sb3dDbGljayhkYXRhKSB7XG4gICAgICAgIHRoaXMuZmlyZVJvd0V2ZW50KGRhdGEsICdyb3dDbGljaycpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvblJvd0RvdWJsZUNsaWNrKGRhdGEpIHtcbiAgICAgICAgdGhpcy5maXJlUm93RXZlbnQoZGF0YSwgJ3Jvd0RvdWJsZUNsaWNrJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uU2Nyb2xsQ2FwdHVyZShkYXRhKSB7XG4gICAgICAgIHN1cGVyLm9uU2Nyb2xsQ2FwdHVyZShkYXRhKTtcbiAgICAgICAgdGhpcy5wYXJlbnQuc2Nyb2xsTWFuYWdlci5vbkJvZHlTY3JvbGwoZGF0YSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uU3RvcmVGaWx0ZXIoKSB7XG4gICAgICAgIHRoaXMub25TdG9yZUxvYWQoe2l0ZW1zOiB0aGlzLnN0b3JlLml0ZW1zfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5pdGVtc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gIFtkYXRhLnBvc3RDaHVua0xvYWRdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgW2RhdGEudG90YWxdXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uU3RvcmVMb2FkKHtpdGVtcywgcG9zdENodW5rTG9hZCwgdG90YWx9KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt3aW5kb3dJZH0gPSBtZTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBGYXN0IHBhdGggdG8gaGFuZGxlIGNsZWFyaW5nIGFsbCByb3dzIChlLmcuLCBzdG9yZS5yZW1vdmVBbGwoKSkuXG4gICAgICAgICAqIEEgZnVsbCB2ZG9tIGRpZmYgYWdhaW5zdCBhbGwgZXhpc3Rpbmcgcm93cyBpcyBhIHBlcmZvcm1hbmNlIGJvdHRsZW5lY2suXG4gICAgICAgICAqIFRoaXMgbG9naWMgYnlwYXNzZXMgdGhlIHN0YW5kYXJkIHVwZGF0ZSgpIGN5Y2xlIGJ5IGRpcmVjdGx5IGNsZWFyaW5nIHRoZSB2ZG9tLFxuICAgICAgICAgKiB2bm9kZSBjYWNoZSBhbmQgdGhlIHJlYWwgRE9NIHZpYSB0ZXh0Q29udGVudC5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChpdGVtcz8ubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgY29uc3QgdmRvbVJvb3QgPSBtZS5nZXRWZG9tUm9vdCgpO1xuXG4gICAgICAgICAgICAvLyBObyBjaGFuZ2UsIG9wdCBvdXRcbiAgICAgICAgICAgIGlmICh2ZG9tUm9vdC5jbi5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZkb21Sb290LmNuID0gW107XG4gICAgICAgICAgICBtZS5nZXRWbm9kZVJvb3QoKS5jaGlsZE5vZGVzID0gW107XG5cbiAgICAgICAgICAgIE5lby5hcHBseURlbHRhcyh3aW5kb3dJZCwge1xuICAgICAgICAgICAgICAgIGlkICAgICAgICAgOiB2ZG9tUm9vdC5pZCxcbiAgICAgICAgICAgICAgICB0ZXh0Q29udGVudDogJydcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGl0J3MgdGhlIGZpcnN0IGNodW5rZWQgbG9hZCAoZGF0YS50b3RhbCBleGlzdHMgYW5kIGRhdGEuaXRlbXMgaXMgYSBzdWJzZXQgb2YgdG90YWwpXG4gICAgICAgIC8vIFJlbmRlciB0aGUgZW50aXJlIGNodW5rIGZvciBpbW1lZGlhdGUgc2Nyb2xsYWJpbGl0eVxuICAgICAgICBpZiAodG90YWwgJiYgaXRlbXMubGVuZ3RoIDwgdG90YWwpIHtcbiAgICAgICAgICAgIG1lLiNpbml0aWFsQ2h1bmtTaXplID0gaXRlbXMubGVuZ3RoO1xuICAgICAgICAgICAgbWUuI2luaXRpYWxUb3RhbFNpemUgPSB0b3RhbDtcbiAgICAgICAgICAgIG1lLmNyZWF0ZVZpZXdEYXRhKCk7XG4gICAgICAgICAgICBtZS4jaW5pdGlhbENodW5rU2l6ZSA9IDBcbiAgICAgICAgICAgIG1lLiNpbml0aWFsVG90YWxTaXplID0gMFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUuY3JlYXRlVmlld0RhdGEoKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lLm1vdW50ZWQgJiYgIXBvc3RDaHVua0xvYWQpIHtcbiAgICAgICAgICAgIG1lLnRpbWVvdXQoNTApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIE5lby5tYWluLkRvbUFjY2Vzcy5zY3JvbGxUbyh7XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ3RvcCcsXG4gICAgICAgICAgICAgICAgICAgIGlkICAgICAgIDogbWUudmRvbS5pZCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgICAgOiAwLFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3dJZFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2xlYW51cCBjb21wb25lbnQgaW5zdGFuY2VzIGFmdGVyIGNodW5rZWQgbG9hZFxuICAgICAgICBpZiAocG9zdENodW5rTG9hZCkge1xuICAgICAgICAgICAgbWUuY2xlYW51cENvbXBvbmVudEluc3RhbmNlcygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gICAgICAgZGF0YS5maWVsZHMgRWFjaCBmaWVsZCBvYmplY3QgY29udGFpbnMgdGhlIGtleXM6IG5hbWUsIG9sZFZhbHVlLCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuTW9kZWx9IGRhdGEubW9kZWwgIFRoZSBtb2RlbCBpbnN0YW5jZSBvZiB0aGUgY2hhbmdlZCByZWNvcmRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICBkYXRhLnJlY29yZFxuICAgICAqL1xuICAgIG9uU3RvcmVSZWNvcmRDaGFuZ2Uoe2ZpZWxkcywgcmVjb3JkfSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZmllbGROYW1lcyAgICAgICAgICAgICAgICAgICAgPSBmaWVsZHMubWFwKGZpZWxkID0+IGZpZWxkLm5hbWUpLFxuICAgICAgICAgICAgbmVlZHNVcGRhdGUgICAgICAgICAgICAgICAgICAgPSBmYWxzZSxcbiAgICAgICAgICAgIHJvd0luZGV4ICAgICAgICAgICAgICAgICAgICAgID0gbWUuc3RvcmUuaW5kZXhPZihyZWNvcmQpLFxuICAgICAgICAgICAge21vdW50ZWRSb3dzLCBzZWxlY3Rpb25Nb2RlbH0gPSBtZSxcbiAgICAgICAgICAgIGNvbHVtbiwgbmVlZHNDZWxsVXBkYXRlLCByZWNvcmRJZDtcblxuICAgICAgICBpZiAoZmllbGROYW1lcy5pbmNsdWRlcyhtZS5jb2xzcGFuRmllbGQpKSB7XG4gICAgICAgICAgICBtZS52ZG9tLmNuW3Jvd0luZGV4XSA9IG1lLmNyZWF0ZVJvdyh7cmVjb3JkLCByb3dJbmRleH0pO1xuICAgICAgICAgICAgbWUudXBkYXRlKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChyb3dJbmRleCA+PSBtb3VudGVkUm93c1swXSAmJiByb3dJbmRleCA8PSBtb3VudGVkUm93c1sxXSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29sdW1uIG9mIG1lLnBhcmVudC5jb2x1bW5zLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbiBpbnN0YW5jZW9mIE5lby5ncmlkLmNvbHVtbi5Db21wb25lbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIE5lby50eXBlT2YoY29sdW1uLmNvbXBvbmVudCA9PT0gJ0Z1bmN0aW9uJykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFmaWVsZE5hbWVzLmluY2x1ZGVzKGNvbHVtbi5kYXRhRmllbGQpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVlZHNDZWxsVXBkYXRlID0gbWUudXBkYXRlQ2VsbE5vZGUocmVjb3JkLCBjb2x1bW4uZGF0YUZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lZWRzVXBkYXRlICAgICA9IG5lZWRzVXBkYXRlIHx8IG5lZWRzQ2VsbFVwZGF0ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZmllbGRzLmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQubmFtZSA9PT0gbWUuc2VsZWN0ZWRSZWNvcmRGaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbk1vZGVsLm50eXBlID09PSAnc2VsZWN0aW9uLWdyaWQtcm93bW9kZWwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkSWQgPSByZWNvcmRbbWUuc3RvcmUuZ2V0S2V5UHJvcGVydHkoKV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25Nb2RlbFtmaWVsZC52YWx1ZSA/ICdzZWxlY3RSb3cnIDogJ2Rlc2VsZWN0Um93J10ocmVjb3JkSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZWVkc0NlbGxVcGRhdGUgPSBtZS51cGRhdGVDZWxsTm9kZShyZWNvcmQsIGZpZWxkLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVlZHNVcGRhdGUgICAgID0gbmVlZHNVcGRhdGUgfHwgbmVlZHNDZWxsVXBkYXRlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbmVlZHNVcGRhdGUgJiYgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBrZXlib2FyZCBuYXZpZ2F0aW9uIChzZWxlY3Rpb24gbW9kZWxzKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGVwXG4gICAgICovXG4gICAgc2Nyb2xsQnlSb3dzKGluZGV4LCBzdGVwKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7bW91bnRlZFJvd3MsIHZpc2libGVSb3dzfSA9IG1lLFxuICAgICAgICAgICAgY291bnRSZWNvcmRzICAgICAgICAgICAgICAgPSBtZS5zdG9yZS5nZXRDb3VudCgpLFxuICAgICAgICAgICAgbmV3SW5kZXggICAgICAgICAgICAgICAgICAgPSBpbmRleCArIHN0ZXAsXG4gICAgICAgICAgICBsYXN0Um93R2FwLCBtb3VudGVkLCBzY3JvbGxUb3AsIHZpc2libGU7XG5cbiAgICAgICAgaWYgKG5ld0luZGV4ID49IGNvdW50UmVjb3Jkcykge1xuICAgICAgICAgICAgbmV3SW5kZXggJT0gY291bnRSZWNvcmRzO1xuICAgICAgICAgICAgc3RlcCAgICAgPSBuZXdJbmRleCAtIGluZGV4XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAobmV3SW5kZXggPCAwKSB7XG4gICAgICAgICAgICBuZXdJbmRleCArPSBjb3VudFJlY29yZHM7XG4gICAgICAgICAgICBzdGVwICAgICArPSBjb3VudFJlY29yZHNcbiAgICAgICAgfVxuXG4gICAgICAgIG1vdW50ZWQgPSBuZXdJbmRleCA+PSBtb3VudGVkUm93c1swXSAmJiBuZXdJbmRleCA8PSBtb3VudGVkUm93c1sxXTtcblxuICAgICAgICAvLyBOb3QgdXNpbmcgPj0gb3IgPD0sIHNpbmNlIHRoZSBmaXJzdCAvIGxhc3Qgcm93IG1pZ2h0IG5vdCBiZSBmdWxseSB2aXNpYmxlXG4gICAgICAgIHZpc2libGUgPSBuZXdJbmRleCA+IHZpc2libGVSb3dzWzBdICYmIG5ld0luZGV4IDwgdmlzaWJsZVJvd3NbMV07XG5cbiAgICAgICAgaWYgKCF2aXNpYmxlKSB7XG4gICAgICAgICAgICAvLyBMZWF2aW5nIHRoZSBtb3VudGVkIGFyZWEgd2lsbCByZS1jYWxjdWxhdGUgdGhlIHZpc2libGVSb3dzIGZvciB1c1xuICAgICAgICAgICAgaWYgKG1vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICB2aXNpYmxlUm93c1swXSArPSBzdGVwO1xuICAgICAgICAgICAgICAgIHZpc2libGVSb3dzWzFdICs9IHN0ZXBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0ZXAgPCAwKSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsVG9wID0gbmV3SW5kZXggKiBtZS5yb3dIZWlnaHRcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGFzdFJvd0dhcCA9IG1lLnJvd0hlaWdodCAtIChtZS5hdmFpbGFibGVIZWlnaHQgJSBtZS5yb3dIZWlnaHQpO1xuICAgICAgICAgICAgICAgIHNjcm9sbFRvcCAgPSAobmV3SW5kZXggLSBtZS5hdmFpbGFibGVSb3dzKSAqIG1lLnJvd0hlaWdodCArIGxhc3RSb3dHYXBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgTmVvLm1haW4uRG9tQWNjZXNzLnNjcm9sbFRvKHtcbiAgICAgICAgICAgICAgICBpZCAgICAgIDogbWUudmRvbS5pZCxcbiAgICAgICAgICAgICAgICB2YWx1ZSAgIDogc2Nyb2xsVG9wLFxuICAgICAgICAgICAgICAgIHdpbmRvd0lkOiBtZS53aW5kb3dJZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgY2VsbCB2ZG9tIHNpbGVudGx5XG4gICAgICogQHBhcmFtIHtSZWNvcmR9IHJlY29yZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhRmllbGRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpbiBjYXNlIHRoZSB2aWV3IG5lZWRzIGFuIHVwZGF0ZVxuICAgICAqL1xuICAgIHVwZGF0ZUNlbGxOb2RlKHJlY29yZCwgZGF0YUZpZWxkKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICByb3dJbmRleCAgICA9IG1lLnN0b3JlLmluZGV4T2YocmVjb3JkKSxcbiAgICAgICAgICAgIGNlbGxJZCAgICAgID0gbWUuZ2V0Q2VsbElkKHJvd0luZGV4LCBkYXRhRmllbGQpLFxuICAgICAgICAgICAgY2VsbE5vZGUgICAgPSBWRG9tVXRpbC5maW5kKG1lLnZkb20sIGNlbGxJZCksXG4gICAgICAgICAgICBuZWVkc1VwZGF0ZSA9IGZhbHNlLFxuICAgICAgICAgICAgY2VsbFN0eWxlLCBjZWxsVmRvbSwgY29sdW1uLCBjb2x1bW5JbmRleDtcblxuICAgICAgICAvLyBUaGUgdmRvbSBtaWdodCBub3QgZXhpc3QgeWV0ID0+IG5vdGhpbmcgdG8gZG8gaW4gdGhpcyBjYXNlXG4gICAgICAgIGlmIChjZWxsTm9kZT8udmRvbSkge1xuICAgICAgICAgICAgY2VsbFN0eWxlICAgPSBjZWxsTm9kZS52ZG9tLnN0eWxlO1xuICAgICAgICAgICAgY29sdW1uICAgICAgPSBtZS5nZXRDb2x1bW4oZGF0YUZpZWxkKTtcbiAgICAgICAgICAgIGNvbHVtbkluZGV4ID0gY2VsbE5vZGUuaW5kZXg7XG4gICAgICAgICAgICBjZWxsVmRvbSAgICA9IG1lLmFwcGx5UmVuZGVyZXJPdXRwdXQoe2NlbGxJZCwgY29sdW1uLCBjb2x1bW5JbmRleCwgcmVjb3JkLCByb3dJbmRleH0pO1xuICAgICAgICAgICAgbmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBUaGUgY2VsbC1wb3NpdGlvbmluZyBsb2dpYyBoYXBwZW5zIG91dHNpZGUgYXBwbHlSZW5kZXJlck91dHB1dCgpXG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHByZXNlcnZlIHRoZXNlIHN0eWxlc1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihjZWxsVmRvbS5zdHlsZSwge1xuICAgICAgICAgICAgICAgIGxlZnQgOiBjZWxsU3R5bGUubGVmdCxcbiAgICAgICAgICAgICAgICB3aWR0aDogY2VsbFN0eWxlLndpZHRoXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY2VsbE5vZGUucGFyZW50Tm9kZS5jbltjb2x1bW5JbmRleF0gPSBjZWxsVmRvbVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5lZWRzVXBkYXRlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICB1cGRhdGVNb3VudGVkQW5kVmlzaWJsZUNvbHVtbnMoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7YnVmZmVyQ29sdW1uUmFuZ2UsIGNvbHVtblBvc2l0aW9ucywgbW91bnRlZENvbHVtbnMsIHZpc2libGVDb2x1bW5zfSA9IG1lLFxuICAgICAgICAgICAgaSAgICAgICAgICAgID0gMCxcbiAgICAgICAgICAgIGNvdW50Q29sdW1ucyA9IGNvbHVtblBvc2l0aW9ucy5nZXRDb3VudCgpLFxuICAgICAgICAgICAgZW5kSW5kZXggICAgID0gY291bnRDb2x1bW5zIC0gMSxcbiAgICAgICAgICAgIHggICAgICAgICAgICA9IG1lLnNjcm9sbExlZnQsXG4gICAgICAgICAgICBjb2x1bW4sIHN0YXJ0SW5kZXg7XG5cbiAgICAgICAgaWYgKGNvdW50Q29sdW1ucyA8IDEpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICg7IGkgPCBjb3VudENvbHVtbnM7IGkrKykge1xuICAgICAgICAgICAgY29sdW1uID0gY29sdW1uUG9zaXRpb25zLmdldEF0KGkpO1xuXG4gICAgICAgICAgICBpZiAoeCA+PSBjb2x1bW4ueCAmJiB4IDw9IGNvbHVtbi54ICsgY29sdW1uLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRJbmRleCA9IGlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1lLmNvbnRhaW5lcldpZHRoICsgeCA8IGNvbHVtbi54KSB7XG4gICAgICAgICAgICAgICAgZW5kSW5kZXggPSBpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmlzaWJsZUNvbHVtbnNbMF0gPSBzdGFydEluZGV4OyAvLyB1cGRhdGUgdGhlIGFycmF5IGlubGluZVxuICAgICAgICB2aXNpYmxlQ29sdW1uc1sxXSA9IGVuZEluZGV4O1xuXG4gICAgICAgIGlmICh2aXNpYmxlQ29sdW1uc1swXSA8PSBtb3VudGVkQ29sdW1uc1swXSB8fCB2aXNpYmxlQ29sdW1uc1sxXSA+PSBtb3VudGVkQ29sdW1uc1sxXSkge1xuICAgICAgICAgICAgc3RhcnRJbmRleCA9IE1hdGgubWF4KDAsIHZpc2libGVDb2x1bW5zWzBdIC0gYnVmZmVyQ29sdW1uUmFuZ2UpO1xuICAgICAgICAgICAgZW5kSW5kZXggICA9IE1hdGgubWluKGNvdW50Q29sdW1ucyAtIDEsIHZpc2libGVDb2x1bW5zWzFdICsgYnVmZmVyQ29sdW1uUmFuZ2UpO1xuXG4gICAgICAgICAgICBtZS5tb3VudGVkQ29sdW1ucyA9IFtzdGFydEluZGV4LCBlbmRJbmRleF1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgdXBkYXRlTW91bnRlZEFuZFZpc2libGVSb3dzKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtidWZmZXJSb3dSYW5nZSwgc3RhcnRJbmRleCwgc3RvcmV9ID0gbWUsXG4gICAgICAgICAgICBjb3VudFJlY29yZHMgPSBzdG9yZS5nZXRDb3VudCgpLFxuICAgICAgICAgICAgZW5kSW5kZXggICAgID0gTWF0aC5taW4oY291bnRSZWNvcmRzLCBzdGFydEluZGV4ICsgbWUuYXZhaWxhYmxlUm93cyk7XG5cbiAgICAgICAgbWUudmlzaWJsZVJvd3NbMF0gPSBzdGFydEluZGV4OyAvLyB1cGRhdGUgdGhlIGFycmF5IGlubGluZVxuICAgICAgICBtZS52aXNpYmxlUm93c1sxXSA9IGVuZEluZGV4O1xuXG4gICAgICAgIHN0YXJ0SW5kZXggPSBNYXRoLm1heCgwLCBzdGFydEluZGV4IC0gYnVmZmVyUm93UmFuZ2UpO1xuICAgICAgICBlbmRJbmRleCAgID0gTWF0aC5taW4oY291bnRSZWNvcmRzLCBlbmRJbmRleCArIGJ1ZmZlclJvd1JhbmdlKTtcblxuICAgICAgICBtZS5tb3VudGVkUm93c1swXSA9IHN0YXJ0SW5kZXg7IC8vIHVwZGF0ZSB0aGUgYXJyYXkgaW5saW5lXG4gICAgICAgIG1lLm1vdW50ZWRSb3dzWzFdID0gZW5kSW5kZXhcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNpbGVudD1mYWxzZVxuICAgICAqL1xuICAgIHVwZGF0ZVNjcm9sbEhlaWdodChzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb3VudFJlY29yZHMgPSBtZS4jaW5pdGlhbFRvdGFsU2l6ZSB8fCBtZS5zdG9yZT8uY291bnQgfHwgMCxcbiAgICAgICAgICAgIHtyb3dIZWlnaHR9ICA9IG1lO1xuXG4gICAgICAgIGlmIChjb3VudFJlY29yZHMgPiAwICYmIHJvd0hlaWdodCA+IDApIHtcbiAgICAgICAgICAgIG1lLnZkb20uY25bMF0uaGVpZ2h0ID0gYCR7KGNvdW50UmVjb3JkcyArIDEpICogcm93SGVpZ2h0fXB4YDtcbiAgICAgICAgICAgICFzaWxlbnQgJiYgbWUudXBkYXRlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcbiAgICAgICAgICAgIGFuaW1hdGVkUm93U29ydGluZyAgICA6IG1lLmFuaW1hdGVkUm93U29ydGluZyxcbiAgICAgICAgICAgIGJ1ZmZlckNvbHVtblJhbmdlICAgICA6IG1lLmJ1ZmZlckNvbHVtblJhbmdlLFxuICAgICAgICAgICAgYnVmZmVyUm93UmFuZ2UgICAgICAgIDogbWUuYnVmZmVyUm93UmFuZ2UsXG4gICAgICAgICAgICBjb2xzcGFuRmllbGQgICAgICAgICAgOiBtZS5jb2xzcGFuRmllbGQsXG4gICAgICAgICAgICBoaWdobGlnaHRNb2RpZmllZENlbGxzOiBtZS5oaWdobGlnaHRNb2RpZmllZENlbGxzLFxuICAgICAgICAgICAgcm93SGVpZ2h0ICAgICAgICAgICAgIDogbWUucm93SGVpZ2h0LFxuICAgICAgICAgICAgc2VsZWN0ZWRSZWNvcmRGaWVsZCAgIDogbWUuc2VsZWN0ZWRSZWNvcmRGaWVsZCxcbiAgICAgICAgICAgIHNlbGVjdGlvbk1vZGVsICAgICAgICA6IG1lLnNlbGVjdGlvbk1vZGVsPy50b0pTT04oKVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhHcmlkQm9keSk7XG4iLCJpbXBvcnQgQmFzZUNvbnRhaW5lciAgICAgZnJvbSAnLi4vY29udGFpbmVyL0Jhc2UubWpzJztcbmltcG9ydCBDbGFzc1N5c3RlbVV0aWwgICBmcm9tICcuLi91dGlsL0NsYXNzU3lzdGVtLm1qcyc7XG5pbXBvcnQgQ29sbGVjdGlvbiAgICAgICAgZnJvbSAnLi4vY29sbGVjdGlvbi9CYXNlLm1qcyc7XG5pbXBvcnQgR3JpZEJvZHkgICAgICAgICAgZnJvbSAnLi9Cb2R5Lm1qcyc7XG5pbXBvcnQgU2Nyb2xsTWFuYWdlciAgICAgZnJvbSAnLi9TY3JvbGxNYW5hZ2VyLm1qcyc7XG5pbXBvcnQgU3RvcmUgICAgICAgICAgICAgZnJvbSAnLi4vZGF0YS9TdG9yZS5tanMnO1xuaW1wb3J0IFZlcnRpY2FsU2Nyb2xsYmFyIGZyb20gJy4vVmVydGljYWxTY3JvbGxiYXIubWpzJztcbmltcG9ydCAqIGFzIGNvbHVtbiAgICAgICBmcm9tICcuL2NvbHVtbi9fZXhwb3J0Lm1qcyc7XG5pbXBvcnQgKiBhcyBoZWFkZXIgICAgICAgZnJvbSAnLi9oZWFkZXIvX2V4cG9ydC5tanMnO1xuaW1wb3J0IHtpc0Rlc2NyaXB0b3J9ICAgIGZyb20gJy4uL2NvcmUvQ29uZmlnU3ltYm9scy5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZ3JpZC5Db250YWluZXJcbiAqIEBleHRlbmRzIE5lby5jb250YWluZXIuQmFzZVxuICovXG5jbGFzcyBHcmlkQ29udGFpbmVyIGV4dGVuZHMgQmFzZUNvbnRhaW5lciB7XG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBjb2x1bW5UeXBlc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGNvbHVtblR5cGVzID0ge1xuICAgICAgICBhbmltYXRlZENoYW5nZSAgOiBjb2x1bW4uQW5pbWF0ZWRDaGFuZ2UsXG4gICAgICAgIGFuaW1hdGVkQ3VycmVuY3k6IGNvbHVtbi5BbmltYXRlZEN1cnJlbmN5LFxuICAgICAgICBjb2x1bW4gICAgICAgICAgOiBjb2x1bW4uQmFzZSxcbiAgICAgICAgY29tcG9uZW50ICAgICAgIDogY29sdW1uLkNvbXBvbmVudCxcbiAgICAgICAgY3VycmVuY3kgICAgICAgIDogY29sdW1uLkN1cnJlbmN5LFxuICAgICAgICBpbmRleCAgICAgICAgICAgOiBjb2x1bW4uSW5kZXgsXG4gICAgICAgIHByb2dyZXNzICAgICAgICA6IGNvbHVtbi5Qcm9ncmVzc1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGRlbGF5YWJsZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGRlbGF5YWJsZSA9IHtcbiAgICAgICAgb25SZXNpemU6IHt0eXBlOiAnYnVmZmVyJywgdGltZXI6IDMwMH1cbiAgICB9XG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5ncmlkLkNvbnRhaW5lcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmdyaWQuQ29udGFpbmVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2dyaWQtY29udGFpbmVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2dyaWQtY29udGFpbmVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWdyaWQtY29udGFpbmVyJ11cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tZ3JpZC1jb250YWluZXInXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbmZpZ3MgZm9yIE5lby5ncmlkLkJvZHlcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IFtib2R5Xz17W2lzRGVzY3JpcHRvcl06IHRydWUsIG1lcmdlOiAnZGVlcCcsIHZhbHVlOiBudWxsfV1cbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBib2R5Xzoge1xuICAgICAgICAgICAgW2lzRGVzY3JpcHRvcl06IHRydWUsXG4gICAgICAgICAgICBtZXJnZSAgICAgICAgIDogJ2RlZXAnLFxuICAgICAgICAgICAgdmFsdWUgICAgICAgICA6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRydWUgdXNlcyBncmlkLnBsdWdpbi5DZWxsRWRpdGluZ1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBjZWxsRWRpdGluZ189ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBjZWxsRWRpdGluZ186IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogRGVmYXVsdCBjb25maWdzIGZvciBlYWNoIGNvbHVtblxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGNvbHVtbkRlZmF1bHRzPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGNvbHVtbkRlZmF1bHRzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0W119IGNvbHVtbnNfPVtdXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgY29sdW1uc186IFtdLFxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uZmlncyBmb3IgTmVvLmdyaWQuaGVhZGVyLlRvb2xiYXJcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IFtoZWFkZXJUb29sYmFyXz17W2lzRGVzY3JpcHRvcl06IHRydWUsIG1lcmdlOiAnZGVlcCcsIHZhbHVlOiBudWxsfV1cbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBoZWFkZXJUb29sYmFyXzoge1xuICAgICAgICAgICAgW2lzRGVzY3JpcHRvcl06IHRydWUsXG4gICAgICAgICAgICBtZXJnZSAgICAgICAgIDogJ2RlZXAnLFxuICAgICAgICAgICAgdmFsdWUgICAgICAgICA6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbGF5b3V0PSdiYXNlJ1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGxheW91dDogJ2Jhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSByb2xlPSdncmlkJ1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHJvbGU6ICdncmlkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE51bWJlciBpbiBweFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHJvd0hlaWdodF89MzJcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICByb3dIZWlnaHRfOiAzMixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5ncmlkLlNjcm9sbGJhcnxudWxsfSBzY3JvbGxiYXI9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzY3JvbGxiYXI6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaG93SGVhZGVyRmlsdGVyc189ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzaG93SGVhZGVyRmlsdGVyc186IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc29ydGFibGVfPXRydWVcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzb3J0YWJsZV86IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZGF0YS5TdG9yZX0gc3RvcmVfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzdG9yZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheXxudWxsfSBpdGVtcz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtczogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gX3Zkb21cbiAgICAgICAgICovXG4gICAgICAgIF92ZG9tOlxuICAgICAgICB7Y2xzOiBbJ25lby1ncmlkLXdyYXBwZXInXSwgY246IFtcbiAgICAgICAgICAgIHsnYXJpYS1jb2xjb3VudCc6IDAsICdhcmlhLXJvd2NvdW50JzogMSwgY246IFtdfSAvLyBhcmlhLXJvd2NvdW50IGluY2x1ZGVzIHRoZSBjb2x1bW4gaGVhZGVyc1xuICAgICAgICBdfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdlIGRvIG5vdCBuZWVkIHRoZSBmaXJzdCBldmVudCB0byB0cmlnZ2VyIGxvZ2ljLCBzaW5jZSBhZnRlclNldE1vdW50ZWQoKSBoYW5kbGVzIHRoaXNcbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpbml0aWFsUmVzaXplRXZlbnQ9dHJ1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpbml0aWFsUmVzaXplRXZlbnQgPSB0cnVlXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7TmVvLmdyaWQuU2Nyb2xsTWFuYWdlcnxudWxsfSBzY3JvbGxNYW5hZ2VyPW51bGxcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2Nyb2xsTWFuYWdlciA9IG51bGxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICB7YXBwTmFtZSwgcm93SGVpZ2h0LCBzdG9yZSwgd2luZG93SWR9ID0gbWU7XG5cbiAgICAgICAgbWUuaXRlbXMgPSBbbWUuaGVhZGVyVG9vbGJhciwgbWUuYm9keV07XG5cbiAgICAgICAgbWUuc2Nyb2xsYmFyID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICBtb2R1bGUgIDogVmVydGljYWxTY3JvbGxiYXIsXG4gICAgICAgICAgICBhcHBOYW1lLFxuICAgICAgICAgICAgcGFyZW50SWQ6IG1lLmlkLFxuICAgICAgICAgICAgcm93SGVpZ2h0LFxuICAgICAgICAgICAgc3RvcmUsXG4gICAgICAgICAgICB3aW5kb3dJZFxuICAgICAgICB9KTtcblxuICAgICAgICBtZS52ZG9tLmNuLnB1c2gobWUuc2Nyb2xsYmFyLmNyZWF0ZVZkb21SZWZlcmVuY2UoKSlcblxuICAgICAgICBtZS52ZG9tLmlkID0gbWUuZ2V0V3JhcHBlcklkKCk7XG5cbiAgICAgICAgbWUuX2NvbHVtbnMgPSBtZS5jcmVhdGVDb2x1bW5zKG1lLmNvbHVtbnMpO1xuICAgICAgICBtZS51cGRhdGVDb2xDb3VudCgpO1xuXG4gICAgICAgIG1lLmFkZERvbUxpc3RlbmVycyh7XG4gICAgICAgICAgICByZXNpemU6IG1lLm9uUmVzaXplLFxuICAgICAgICAgICAgc2NvcGUgOiBtZVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gbW91bnRlZFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBhZGRSZXNpemVPYnNlcnZlcihtb3VudGVkKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7d2luZG93SWR9ICAgICA9IG1lLFxuICAgICAgICAgICAgUmVzaXplT2JzZXJ2ZXIgPSBhd2FpdCBOZW8uY3VycmVudFdvcmtlci5nZXRBZGRvbignUmVzaXplT2JzZXJ2ZXInLCB3aW5kb3dJZCksXG4gICAgICAgICAgICByZXNpemVQYXJhbXMgICA9IHtpZDogbWUuaWQsIHdpbmRvd0lkfTtcblxuICAgICAgICBpZiAobW91bnRlZCkge1xuICAgICAgICAgICAgUmVzaXplT2JzZXJ2ZXIucmVnaXN0ZXIocmVzaXplUGFyYW1zKTtcbiAgICAgICAgICAgIGF3YWl0IG1lLnBhc3NTaXplVG9Cb2R5KClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLmluaXRpYWxSZXNpemVFdmVudCA9IHRydWU7XG4gICAgICAgICAgICBSZXNpemVPYnNlcnZlci51bnJlZ2lzdGVyKHJlc2l6ZVBhcmFtcylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgY2VsbEVkaXRpbmcgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRDZWxsRWRpdGluZyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBpbXBvcnQoJy4vcGx1Z2luL0NlbGxFZGl0aW5nLm1qcycpLnRoZW4obW9kdWxlID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAge2FwcE5hbWV9ID0gbWUsXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbnMgICA9IG1lLnBsdWdpbnMgfHwgW107XG5cbiAgICAgICAgICAgICAgICBwbHVnaW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGU6IG1vZHVsZS5kZWZhdWx0LFxuICAgICAgICAgICAgICAgICAgICBhcHBOYW1lXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBtZS5wbHVnaW5zID0gcGx1Z2luc1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgY29sdW1ucyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge05lby5jb2xsZWN0aW9uLkJhc2V8bnVsbH0gICAgICAgICAgdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfE5lby5jb2xsZWN0aW9uLkJhc2V8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYXN5bmMgYWZ0ZXJTZXRDb2x1bW5zKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtoZWFkZXJUb29sYmFyfSA9IG1lO1xuXG4gICAgICAgIC8vIC0gSWYgY29sdW1ucyBjaGFuZ2VkIGF0IHJ1bi10aW1lIE9SXG4gICAgICAgIC8vIC0gSW4gY2FzZSB0aGUgYGhlYWRlci5Ub29sYmFyI2NyZWF0ZUl0ZW1zKClgIG1ldGhvZCBoYXMgcnVuIGJlZm9yZSBjb2x1bW5zIHdoZXJlIGF2YWlsYWJsZVxuICAgICAgICBpZiAob2xkVmFsdWU/LmNvdW50IHx8ICh2YWx1ZT8uY291bnQgJiYgaGVhZGVyVG9vbGJhcj8uaXNDb25zdHJ1Y3RlZCkpIHtcbiAgICAgICAgICAgIGhlYWRlclRvb2xiYXI/LmNyZWF0ZUl0ZW1zKClcblxuICAgICAgICAgICAgYXdhaXQgbWUudGltZW91dCg1MCk7XG5cbiAgICAgICAgICAgIGF3YWl0IG1lLnBhc3NTaXplVG9Cb2R5KCk7XG5cbiAgICAgICAgICAgIG1lLmJvZHk/LmNyZWF0ZVZpZXdEYXRhKClcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmNvbmZpZ3NBcHBsaWVkICYmIG1lLnVwZGF0ZUNvbENvdW50KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1vdW50ZWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgb2xkVmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmFkZFJlc2l6ZU9ic2VydmVyKHZhbHVlKTtcblxuICAgICAgICBsZXQge3Njcm9sbE1hbmFnZXJ9ID0gdGhpcztcblxuICAgICAgICBpZiAoc2Nyb2xsTWFuYWdlcikge1xuICAgICAgICAgICAgc2Nyb2xsTWFuYWdlci5tb3VudGVkID0gdmFsdWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcm93SGVpZ2h0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFJvd0hlaWdodCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID4gMCkge1xuICAgICAgICAgICAgbGV0IHtib2R5LCBzY3JvbGxiYXJ9ID0gdGhpcztcblxuICAgICAgICAgICAgaWYgKHNjcm9sbGJhcikge1xuICAgICAgICAgICAgICAgIHNjcm9sbGJhci5yb3dIZWlnaHQgPSB2YWx1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYm9keSkge1xuICAgICAgICAgICAgICAgIGJvZHkucm93SGVpZ2h0ID0gdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc2hvd0hlYWRlckZpbHRlcnMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTaG93SGVhZGVyRmlsdGVycyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyVG9vbGJhci5zaG93SGVhZGVyRmlsdGVycyA9IHZhbHVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNvcnRhYmxlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U29ydGFibGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlclRvb2xiYXIuc29ydGFibGUgPSB2YWx1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzdG9yZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTdG9yZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBsaXN0ZW5lcnMgPSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyOiBtZS5vblN0b3JlRmlsdGVyLFxuICAgICAgICAgICAgICAgIGxvYWQgIDogbWUub25TdG9yZUxvYWQsXG4gICAgICAgICAgICAgICAgc2NvcGUgOiBtZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICB2YWx1ZSAgID8ub24obGlzdGVuZXJzKTtcbiAgICAgICAgb2xkVmFsdWU/LnVuKGxpc3RlbmVycyk7XG5cbiAgICAgICAgLy8gaW4gY2FzZSB3ZSBkeW5hbWljYWxseSBjaGFuZ2UgdGhlIHN0b3JlLCBncmlkLkJvZHkgbmVlZHMgdG8gZ2V0IHRoZSBuZXcgcmVmZXJlbmNlXG4gICAgICAgIGlmIChtZS5ib2R5KSB7XG4gICAgICAgICAgICBtZS5ib2R5LnN0b3JlID0gdmFsdWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGJvZHkgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxOZW8uZ3JpZC5Cb2R5fG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R8TmVvLmdyaWQuQm9keXxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRCb2R5KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIENsYXNzU3lzdGVtVXRpbC5iZWZvcmVTZXRJbnN0YW5jZSh2YWx1ZSwgR3JpZEJvZHksIHtcbiAgICAgICAgICAgIGZsZXggICAgICAgICA6IDEsXG4gICAgICAgICAgICBncmlkQ29udGFpbmVyOiBtZSxcbiAgICAgICAgICAgIHBhcmVudElkICAgICA6IG1lLmlkLFxuICAgICAgICAgICAgc3RvcmUgICAgICAgIDogbWUuc3RvcmVcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBjb2x1bW5zIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRDb2x1bW5zKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5jb25maWdzQXBwbGllZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ29sdW1ucyh2YWx1ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGhlYWRlclRvb2xiYXIgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxOZW8uZ3JpZC5oZWFkZXIuVG9vbGJhcnxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fE5lby5ncmlkLmhlYWRlci5Ub29sYmFyfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldEhlYWRlclRvb2xiYXIodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lID0gdGhpcztcblxuICAgICAgICByZXR1cm4gQ2xhc3NTeXN0ZW1VdGlsLmJlZm9yZVNldEluc3RhbmNlKHZhbHVlLCBoZWFkZXIuVG9vbGJhciwge1xuICAgICAgICAgICAgcGFyZW50SWQgICAgICAgICA6IG1lLmlkLFxuICAgICAgICAgICAgc2hvd0hlYWRlckZpbHRlcnM6IG1lLnNob3dIZWFkZXJGaWx0ZXJzLFxuICAgICAgICAgICAgc29ydGFibGUgICAgICAgICA6IG1lLnNvcnRhYmxlXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgc3RvcmUgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxOZW8uZGF0YS5TdG9yZXxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuU3RvcmV9ICAgICAgICAgICAgIG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFN0b3JlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gQ2xhc3NTeXN0ZW1VdGlsLmJlZm9yZVNldEluc3RhbmNlKHZhbHVlLCBTdG9yZSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluIGNhc2UgeW91IHdhbnQgdG8gdXBkYXRlIG11bHRpcGxlIGV4aXN0aW5nIHJlY29yZHMgaW4gcGFyYWxsZWwsXG4gICAgICogdXNpbmcgdGhpcyBtZXRob2QgaXMgZmFzdGVyIHRoYW4gdXBkYXRpbmcgZWFjaCByZWNvcmQgb25lIGJ5IG9uZS5cbiAgICAgKiBBdCBsZWFzdCB1bnRpbCB3ZSBpbnRyb2R1Y2Ugcm93IGJhc2VkIHZkb20gdXBkYXRlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSByZWNvcmRzXG4gICAgICovXG4gICAgYnVsa1VwZGF0ZVJlY29yZHMocmVjb3Jkcykge1xuICAgICAgICBsZXQge2JvZHksIHN0b3JlfSA9IHRoaXMsXG4gICAgICAgICAgICB7a2V5UHJvcGVydHl9ID0gc3RvcmU7XG5cbiAgICAgICAgaWYgKGJvZHkpIHtcbiAgICAgICAgICAgIGJvZHkuc2lsZW50VmRvbVVwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgICAgIHJlY29yZHMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBzdG9yZS5nZXQoaXRlbVtrZXlQcm9wZXJ0eV0pPy5zZXQoaXRlbSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBib2R5LnNpbGVudFZkb21VcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICAgICAgYm9keS51cGRhdGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gY29sdW1uc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGNyZWF0ZUNvbHVtbnMoY29sdW1ucykge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y29sdW1uRGVmYXVsdHN9ID0gbWUsXG4gICAgICAgICAgICBoZWFkZXJCdXR0b25zICAgID0gW10sXG4gICAgICAgICAgICBzb3J0ZXJzICAgICAgICAgID0gbWUuc3RvcmU/LnNvcnRlcnMsXG4gICAgICAgICAgICBjb2x1bW5DbGFzcywgcmVuZGVyZXI7XG5cbiAgICAgICAgY29sdW1ucz8uZm9yRWFjaCgoY29sdW1uLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgcmVuZGVyZXIgPSBjb2x1bW4ucmVuZGVyZXI7XG5cbiAgICAgICAgICAgIGNvbHVtbkRlZmF1bHRzICYmIE5lby5hc3NpZ25EZWZhdWx0cyhjb2x1bW4sIGNvbHVtbkRlZmF1bHRzKTtcblxuICAgICAgICAgICAgaWYgKHJlbmRlcmVyICYmIE5lby5pc1N0cmluZyhyZW5kZXJlcikgJiYgbWVbcmVuZGVyZXJdKSB7XG4gICAgICAgICAgICAgICAgY29sdW1uLnJlbmRlcmVyID0gbWVbcmVuZGVyZXJdXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzb3J0ZXJzPy5bMF0gJiYgY29sdW1uLmRhdGFGaWVsZCA9PT0gc29ydGVyc1swXS5wcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIGNvbHVtbi5pc1NvcnRlZCA9IHNvcnRlcnNbMF0uZGlyZWN0aW9uXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbHVtbi5saXN0ZW5lcnMgPSB7XG4gICAgICAgICAgICAgICAgc29ydCA6IG1lLm9uU29ydENvbHVtbixcbiAgICAgICAgICAgICAgICBzY29wZTogbWVcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGhlYWRlckJ1dHRvbnMucHVzaChjb2x1bW4pO1xuXG4gICAgICAgICAgICBpZiAoY29sdW1uLmNvbXBvbmVudCAmJiAhY29sdW1uLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW4udHlwZSA9ICdjb21wb25lbnQnXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbHVtbkNsYXNzID0gbWUuY29uc3RydWN0b3IuY29sdW1uVHlwZXNbY29sdW1uLnR5cGUgfHwgJ2NvbHVtbiddO1xuICAgICAgICAgICAgZGVsZXRlIGNvbHVtbi50eXBlO1xuXG4gICAgICAgICAgICBjb2x1bW5zW2luZGV4XSA9IE5lby5jcmVhdGUoY29sdW1uQ2xhc3MsIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQgIDogbWUsXG4gICAgICAgICAgICAgICAgd2luZG93SWQ6IG1lLndpbmRvd0lkLFxuICAgICAgICAgICAgICAgIC4uLmNvbHVtblxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUuaGVhZGVyVG9vbGJhci5pdGVtcyA9IGhlYWRlckJ1dHRvbnM7XG4gICAgICAgIG1lLmhlYWRlclRvb2xiYXIuY3JlYXRlSXRlbXMoKTtcblxuICAgICAgICBpZiAoTmVvLnR5cGVPZihtZS5fY29sdW1ucykgPT09ICdOZW9JbnN0YW5jZScpIHtcbiAgICAgICAgICAgIG1lLl9jb2x1bW5zLmNsZWFyKCk7XG4gICAgICAgICAgICBtZS5fY29sdW1ucy5hZGQoY29sdW1ucyk7XG5cbiAgICAgICAgICAgIHJldHVybiBtZS5fY29sdW1uc1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE5lby5jcmVhdGUoQ29sbGVjdGlvbiwge1xuICAgICAgICAgICAga2V5UHJvcGVydHk6ICdkYXRhRmllbGQnLFxuICAgICAgICAgICAgaXRlbXMgICAgICA6IGNvbHVtbnMsXG4gICAgICAgICAgICBsaXN0ZW5lcnMgIDoge211dGF0ZTogbWUub25Db2x1bW5zTXV0YXRlLCBzY29wZTogbWV9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICBkZXN0cm95KC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5zdG9yZSA9IG51bGw7IC8vIHJlbW92ZSB0aGUgbGlzdGVuZXJzXG5cbiAgICAgICAgbWUuc2Nyb2xsTWFuYWdlci5kZXN0cm95KCk7XG5cbiAgICAgICAgbWUubW91bnRlZCAmJiBOZW8ubWFpbi5hZGRvbi5SZXNpemVPYnNlcnZlci51bnJlZ2lzdGVyKHtcbiAgICAgICAgICAgIGlkICAgICAgOiBtZS5pZCxcbiAgICAgICAgICAgIHdpbmRvd0lkOiBtZS53aW5kb3dJZFxuICAgICAgICB9KTtcblxuICAgICAgICBzdXBlci5kZXN0cm95KC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0VmRvbVJvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZkb20uY25bMF1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcmV0dXJucyB7TmVvLnZkb20uVk5vZGV9XG4gICAgICovXG4gICAgZ2V0Vm5vZGVSb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52bm9kZS5jaGlsZE5vZGVzWzBdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRXcmFwcGVySWQoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmlkfV9fd3JhcHBlcmBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uQ29sdW1uc011dGF0ZShkYXRhKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQ29sQ291bnQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25Db25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgc3VwZXIub25Db25zdHJ1Y3RlZCgpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuc2Nyb2xsTWFuYWdlciA9IE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgZ3JpZEJvZHkgICAgIDogbWUuYm9keSxcbiAgICAgICAgICAgIG1vZHVsZSAgICAgICA6IFNjcm9sbE1hbmFnZXIsXG4gICAgICAgICAgICBncmlkQ29udGFpbmVyOiBtZVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYXN5bmMgb25SZXNpemUoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUuaW5pdGlhbFJlc2l6ZUV2ZW50KSB7XG4gICAgICAgICAgICBhd2FpdCBtZS5wYXNzU2l6ZVRvQm9keSh0cnVlKTtcblxuICAgICAgICAgICAgbWUuYm9keS51cGRhdGVNb3VudGVkQW5kVmlzaWJsZUNvbHVtbnMoKTtcblxuICAgICAgICAgICAgYXdhaXQgbWUuaGVhZGVyVG9vbGJhci5wYXNzU2l6ZVRvQm9keSgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5pbml0aWFsUmVzaXplRXZlbnQgPSBmYWxzZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvblNjcm9sbENhcHR1cmUoZGF0YSkge1xuICAgICAgICBzdXBlci5vblNjcm9sbENhcHR1cmUoZGF0YSk7XG4gICAgICAgIHRoaXMuc2Nyb2xsTWFuYWdlci5vbkNvbnRhaW5lclNjcm9sbChkYXRhKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdHMuZGlyZWN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdHMucHJvcGVydHlcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25Tb3J0Q29sdW1uKG9wdHMpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5zdG9yZS5zb3J0KG9wdHMpO1xuICAgICAgICBtZS5yZW1vdmVTb3J0aW5nQ3NzKG9wdHMucHJvcGVydHkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvblN0b3JlRmlsdGVyKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVJvd0NvdW50KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5pdGVtc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgIFtkYXRhLnRvdGFsXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvblN0b3JlTG9hZChkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHRvdGFsQ291bnQgPSBkYXRhLnRvdGFsID8gZGF0YS50b3RhbCA6IHRoaXMuc3RvcmUuY291bnQ7XG5cbiAgICAgICAgbWUudXBkYXRlUm93Q291bnQodG90YWxDb3VudCk7XG5cbiAgICAgICAgaWYgKG1lLnN0b3JlLnNvcnRlcnM/Lmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIG1lLnJlbW92ZVNvcnRpbmdDc3MoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaWxlbnQ9ZmFsc2VcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBwYXNzU2l6ZVRvQm9keShzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBbY29udGFpbmVyUmVjdCwgaGVhZGVyUmVjdF0gPSBhd2FpdCBtZS5nZXREb21SZWN0KFttZS5pZCwgbWUuaGVhZGVyVG9vbGJhci5pZF0pO1xuXG4gICAgICAgIC8vIGRlbGF5IGZvciBzbG93IGNvbm5lY3Rpb25zLCB3aGVyZSB0aGUgY29udGFpbmVyLXNpemluZyBpcyBub3QgZG9uZSB5ZXRcbiAgICAgICAgaWYgKGNvbnRhaW5lclJlY3QuaGVpZ2h0ID09PSBoZWFkZXJSZWN0LmhlaWdodCkge1xuICAgICAgICAgICAgYXdhaXQgbWUudGltZW91dCgxMDApO1xuICAgICAgICAgICAgYXdhaXQgbWUucGFzc1NpemVUb0JvZHkoc2lsZW50KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUuYm9keVtzaWxlbnQgPyAnc2V0U2lsZW50JyA6ICdzZXQnXSh7XG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0OiBjb250YWluZXJSZWN0LmhlaWdodCAtIGhlYWRlclJlY3QuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcldpZHRoIDogY29udGFpbmVyUmVjdC53aWR0aFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhRmllbGRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcmVtb3ZlU29ydGluZ0NzcyhkYXRhRmllbGQpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJUb29sYmFyPy5pdGVtcy5mb3JFYWNoKGNvbHVtbiA9PiB7XG4gICAgICAgICAgICBpZiAoY29sdW1uLmRhdGFGaWVsZCAhPT0gZGF0YUZpZWxkKSB7cmV0dXJuO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGNvbHVtbiwgZGF0YUZpZWxkKVxuICAgICAgICAgICAgICAgIGNvbHVtbi5yZW1vdmVTb3J0aW5nQ3NzKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBrZXlib2FyZCBuYXZpZ2F0aW9uIChzZWxlY3Rpb24gbW9kZWxzKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGVwXG4gICAgICovXG4gICAgc2Nyb2xsQnlDb2x1bW5zKGluZGV4LCBzdGVwKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2JvZHl9ICAgICAgID0gbWUsXG4gICAgICAgICAgICB7Y29sdW1uUG9zaXRpb25zLCBjb250YWluZXJXaWR0aCwgbW91bnRlZENvbHVtbnMsIHZpc2libGVDb2x1bW5zfSA9IGJvZHksXG4gICAgICAgICAgICBjb3VudENvbHVtbnMgPSBjb2x1bW5Qb3NpdGlvbnMuZ2V0Q291bnQoKSxcbiAgICAgICAgICAgIG5ld0luZGV4ICAgICA9IGluZGV4ICsgc3RlcCxcbiAgICAgICAgICAgIGNvbHVtbiwgbW91bnRlZCwgc2Nyb2xsTGVmdCwgdmlzaWJsZTtcblxuICAgICAgICBpZiAobmV3SW5kZXggPj0gY291bnRDb2x1bW5zKSB7XG4gICAgICAgICAgICBuZXdJbmRleCAlPSBjb3VudENvbHVtbnM7XG4gICAgICAgICAgICBzdGVwICAgICA9IG5ld0luZGV4IC0gaW5kZXhcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChuZXdJbmRleCA8IDApIHtcbiAgICAgICAgICAgIG5ld0luZGV4ICs9IGNvdW50Q29sdW1ucztcbiAgICAgICAgICAgIHN0ZXAgICAgICs9IGNvdW50Q29sdW1uc1xuICAgICAgICB9XG5cbiAgICAgICAgbW91bnRlZCA9IG5ld0luZGV4ID49IG1vdW50ZWRDb2x1bW5zWzBdICYmIG5ld0luZGV4IDw9IG1vdW50ZWRDb2x1bW5zWzFdO1xuXG4gICAgICAgIC8vIE5vdCB1c2luZyA+PSBvciA8PSwgc2luY2UgdGhlIGZpcnN0IC8gbGFzdCBjb2x1bW4gbWlnaHQgbm90IGJlIGZ1bGx5IHZpc2libGVcbiAgICAgICAgdmlzaWJsZSA9IG5ld0luZGV4ID4gdmlzaWJsZUNvbHVtbnNbMF0gJiYgbmV3SW5kZXggPCB2aXNpYmxlQ29sdW1uc1sxXTtcblxuICAgICAgICBpZiAoIXZpc2libGUpIHtcbiAgICAgICAgICAgIC8vIExlYXZpbmcgdGhlIG1vdW50ZWQgYXJlYSB3aWxsIHJlLWNhbGN1bGF0ZSB0aGUgdmlzaWJsZUNvbHVtbnMgZm9yIHVzXG4gICAgICAgICAgICBpZiAobW91bnRlZCkge1xuICAgICAgICAgICAgICAgIHZpc2libGVDb2x1bW5zWzBdICs9IHN0ZXA7XG4gICAgICAgICAgICAgICAgdmlzaWJsZUNvbHVtbnNbMV0gKz0gc3RlcFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb2x1bW4gPSBjb2x1bW5Qb3NpdGlvbnMuZ2V0QXQobmV3SW5kZXgpO1xuXG4gICAgICAgICAgICBpZiAoc3RlcCA8IDApIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxMZWZ0ID0gY29sdW1uLnhcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsTGVmdCA9IGNvbHVtbi54IC0gY29udGFpbmVyV2lkdGggKyBjb2x1bW4ud2lkdGhcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgTmVvLm1haW4uRG9tQWNjZXNzLnNjcm9sbFRvKHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdsZWZ0JyxcbiAgICAgICAgICAgICAgICBpZCAgICAgICA6IG1lLmlkLFxuICAgICAgICAgICAgICAgIHZhbHVlICAgIDogc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgICAgICB3aW5kb3dJZCA6IG1lLndpbmRvd0lkXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0aGUgaW5zdGFuY2UgaW50byBhIEpTT04tY29tcGF0aWJsZSBvYmplY3QgZm9yIHRoZSBOZXVyYWwgTGluay5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXG4gICAgICAgICAgICBib2R5ICAgICAgICAgICAgIDogbWUuYm9keT8udG9KU09OKCksXG4gICAgICAgICAgICBjZWxsRWRpdGluZyAgICAgIDogbWUuY2VsbEVkaXRpbmcsXG4gICAgICAgICAgICBjb2x1bW5zICAgICAgICAgIDogbWUuY29sdW1ucz8uaXRlbXMubWFwKGl0ZW0gPT4gaXRlbS50b0pTT04oKSksXG4gICAgICAgICAgICBoZWFkZXJUb29sYmFyICAgIDogbWUuaGVhZGVyVG9vbGJhcj8udG9KU09OKCksXG4gICAgICAgICAgICByb3dIZWlnaHQgICAgICAgIDogbWUucm93SGVpZ2h0LFxuICAgICAgICAgICAgc2Nyb2xsYmFyICAgICAgICA6IG1lLnNjcm9sbGJhcj8udG9KU09OKCksXG4gICAgICAgICAgICBzY3JvbGxNYW5hZ2VyICAgIDogbWUuc2Nyb2xsTWFuYWdlcj8udG9KU09OKCksXG4gICAgICAgICAgICBzaG93SGVhZGVyRmlsdGVyczogbWUuc2hvd0hlYWRlckZpbHRlcnMsXG4gICAgICAgICAgICBzb3J0YWJsZSAgICAgICAgIDogbWUuc29ydGFibGUsXG4gICAgICAgICAgICBzdG9yZSAgICAgICAgICAgIDogbWUuc3RvcmU/LnRvSlNPTigpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdXG4gICAgICovXG4gICAgdXBkYXRlQ29sQ291bnQoc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuZ2V0VmRvbVJvb3QoKVsnYXJpYS1jb2xjb3VudCddID0gbWUuY29sdW1ucy5jb3VudDtcbiAgICAgICAgIXNpbGVudCAmJiBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY291bnRdIFRoZSB0b3RhbCBudW1iZXIgb2Ygcm93cyBpbiB0aGUgc3RvcmUuIE9wdGlvbmFsLCB3aWxsIHVzZSBzdG9yZS5jb3VudCBpZiBub3QgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2lsZW50PWZhbHNlXVxuICAgICAqL1xuICAgIHVwZGF0ZVJvd0NvdW50KGNvdW50LCBzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZmluYWxDb3VudCA9IGNvdW50ID8gY291bnQgOiBtZS5zdG9yZS5jb3VudDtcblxuICAgICAgICBtZS5nZXRWZG9tUm9vdCgpWydhcmlhLXJvd2NvdW50J10gPSBmaW5hbENvdW50ICsgMTtcbiAgICAgICAgIXNpbGVudCAmJiBtZS51cGRhdGUoKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoR3JpZENvbnRhaW5lcik7XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmdyaWQuU2Nyb2xsTWFuYWdlclxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBTY3JvbGxNYW5hZ2VyIGV4dGVuZHMgQmFzZSB7XG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBkZWxheWFibGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBkZWxheWFibGUgPSB7XG4gICAgICAgIG9uQm9keVNjcm9sbCAgICAgOiB7dHlwZTogJ3Rocm90dGxlJywgdGltZXI6ICAxNn0sXG4gICAgICAgIG9uQm9keVNjcm9sbEVuZCAgOiB7dHlwZTogJ2J1ZmZlcicsICAgdGltZXI6IDE1MH0sXG4gICAgICAgIG9uQ29udGFpbmVyU2Nyb2xsOiB7dHlwZTogJ3Rocm90dGxlJywgdGltZXI6ICAxNn1cbiAgICB9XG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5ncmlkLlNjcm9sbE1hbmFnZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5ncmlkLlNjcm9sbE1hbmFnZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZHJhZ1Njcm9sbF89dHJ1ZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdTY3JvbGxfOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbW91bnRlZF89ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIG1vdW50ZWRfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gc2Nyb2xsTGVmdF89MFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2Nyb2xsTGVmdF86IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHNjcm9sbFRvcF89MFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2Nyb2xsVG9wXzogMFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge05lby5ncmlkLkJvZHl8bnVsbH0gZ3JpZEJvZHk9bnVsbFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBncmlkQm9keSA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOZW8uZ3JpZC5Db250YWluZXJ8bnVsbH0gZ3JpZENvbnRhaW5lcj1udWxsXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGdyaWRDb250YWluZXIgPSBudWxsXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIGFmdGVyU2V0RHJhZ1Njcm9sbCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IGNscyA9ICduZW8tbW91c2UtZHJhZy1zY3JvbGwnO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5ncmlkQm9keS5hZGRDbHMoY2xzKVxuICAgICAgICB9IGVsc2UgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmdyaWRCb2R5LnJlbW92ZUNscyhjbHMpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5tb3VudGVkKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZURyYWdTY3JvbGxBZGRvbih2YWx1ZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ1Njcm9sbCAmJiB0aGlzLnVwZGF0ZURyYWdTY3JvbGxBZGRvbih0cnVlKVxuICAgICAgICB9IGVsc2UgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZURyYWdTY3JvbGxBZGRvbihmYWxzZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9ubHkgdHJpZ2dlcnMgZm9yIHZlcnRpY2FsIHNjcm9sbGluZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uQm9keVNjcm9sbCh7c2Nyb2xsVG9wfSkge1xuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICBib2R5ID0gbWUuZ3JpZEJvZHk7XG5cbiAgICAgICAgbWUuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuXG4gICAgICAgIGJvZHkuc2V0KHtpc1Njcm9sbGluZzogdHJ1ZSwgc2Nyb2xsVG9wfSk7XG5cbiAgICAgICAgbWUub25Cb2R5U2Nyb2xsRW5kKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25Cb2R5U2Nyb2xsRW5kKCkge1xuICAgICAgICB0aGlzLmdyaWRCb2R5LmlzU2Nyb2xsaW5nID0gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLnNjcm9sbExlZnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YS50YXJnZXRcbiAgICAgKi9cbiAgICBvbkNvbnRhaW5lclNjcm9sbCh7c2Nyb2xsTGVmdCwgdGFyZ2V0fSkge1xuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICBib2R5ID0gbWUuZ3JpZEJvZHk7XG5cbiAgICAgICAgLy8gV2UgbXVzdCBpZ25vcmUgZXZlbnRzIGZvciBncmlkLXNjcm9sbGJhclxuICAgICAgICBpZiAodGFyZ2V0LmlkLmluY2x1ZGVzKCdncmlkLWNvbnRhaW5lcicpKSB7XG4gICAgICAgICAgICBib2R5LmlzU2Nyb2xsaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIG1lLm9uQm9keVNjcm9sbEVuZCgpO1xuXG4gICAgICAgICAgICBtZSAgLnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xuICAgICAgICAgICAgYm9keS5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcblxuICAgICAgICAgICAgbWUuZ3JpZENvbnRhaW5lci5oZWFkZXJUb29sYmFyLnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFjdGl2ZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZURyYWdTY3JvbGxBZGRvbihhY3RpdmUpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIGFkZG9uID0gYXdhaXQgTmVvLmN1cnJlbnRXb3JrZXIuZ2V0QWRkb24oJ0dyaWREcmFnU2Nyb2xsJywgbWUud2luZG93SWQpO1xuXG4gICAgICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICAgICAgIGFkZG9uLnJlZ2lzdGVyKHtcbiAgICAgICAgICAgICAgICBib2R5SWQgICAgIDogbWUuZ3JpZEJvZHkuaWQgKyAnX193cmFwcGVyJyxcbiAgICAgICAgICAgICAgICBjb250YWluZXJJZDogbWUuZ3JpZENvbnRhaW5lci5pZCxcbiAgICAgICAgICAgICAgICBpZCAgICAgICAgIDogbWUuaWRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGRvbi51bnJlZ2lzdGVyKHtpZDogbWUuaWR9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcbiAgICAgICAgICAgIHNjcm9sbExlZnQ6IHRoaXMuc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgIHNjcm9sbFRvcCA6IHRoaXMuc2Nyb2xsVG9wXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFNjcm9sbE1hbmFnZXIpO1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQvQmFzZS5tanMnO1xuXG4vKipcbiAqIFdlIGRvIG5vdCB3YW50IHRvIHVzZSB0aGUgZGVmYXVsdCBzY3JvbGxiYXIgZm9yIHZlcnRpY2FsIHNjcm9sbGluZywgc2luY2UgaXQgd291bGQgc2hvdyB1cCBhdCB0aGUgcmlnaHQgZWRnZVxuICogb2YgdGhlIGxhc3QgY29sdW1uLiBJbnN0ZWFkLCB3ZSB3YW50IHRvIHNob3cgaXQgYXQgdGhlIHJpZ2h0IGVkZ2Ugb2YgdGhlIGNvbnRhaW5lciAoYWx3YXlzIHZpc2libGUgd2hlbiBzY3JvbGxpbmcpLlxuICogQGNsYXNzIE5lby5ncmlkLlZlcnRpY2FsU2Nyb2xsYmFyXG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqL1xuY2xhc3MgVmVydGljYWxTY3JvbGxiYXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmdyaWQuVmVydGljYWxTY3JvbGxiYXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5ncmlkLlZlcnRpY2FsU2Nyb2xsYmFyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2dyaWQtdmVydGljYWwtc2Nyb2xsYmFyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2dyaWQtdmVydGljYWwtc2Nyb2xsYmFyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWdyaWQtdmVydGljYWwtc2Nyb2xsYmFyJ11cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tZ3JpZC12ZXJ0aWNhbC1zY3JvbGxiYXInXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE51bWJlciBpbiBweFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHJvd0hlaWdodF89MFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHJvd0hlaWdodF86IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZGF0YS5TdG9yZXxudWxsfSBzdG9yZV89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHN0b3JlXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gX3Zkb21cbiAgICAgICAgICovXG4gICAgICAgIF92ZG9tOlxuICAgICAgICB7Y246IFtcbiAgICAgICAgICAgIHtjbHM6IFsnbmVvLWdyaWQtc2Nyb2xsYmFyLWNvbnRlbnQnXX1cbiAgICAgICAgXX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG1vdW50ZWRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYXN5bmMgYWRkU2Nyb2xsU3luYyhtb3VudGVkKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt3aW5kb3dJZH0gPSBtZSxcbiAgICAgICAgICAgIFNjcm9sbFN5bmMgPSBhd2FpdCBOZW8uY3VycmVudFdvcmtlci5nZXRBZGRvbignU2Nyb2xsU3luYycsIHdpbmRvd0lkKSxcbiAgICAgICAgICAgIHBhcmFtcyAgICAgPSB7aWQ6IG1lLmlkLCB3aW5kb3dJZH07XG5cbiAgICAgICAgaWYgKG1vdW50ZWQpIHtcbiAgICAgICAgICAgIFNjcm9sbFN5bmMucmVnaXN0ZXIoe1xuICAgICAgICAgICAgICAgIGZyb21JZDogbWUucGFyZW50LmJvZHkudmRvbS5pZCxcbiAgICAgICAgICAgICAgICB0b0lkICA6IG1lLmlkLFxuICAgICAgICAgICAgICAgIHR3b1dheTogTmVvLmNvbmZpZy5oYXNNb3VzZUV2ZW50cywgLy8gU3luY2luZyB0aGUgc2Nyb2xsZXIgYmFjayB0byB0aGUgYm9keSBhZmZlY3RzIG1vYmlsZSBzY3JvbGxpbmdcbiAgICAgICAgICAgICAgICAuLi5wYXJhbXNcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBTY3JvbGxTeW5jLnVucmVnaXN0ZXIocGFyYW1zKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtb3VudGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIG9sZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5hZGRTY3JvbGxTeW5jKHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcm93SGVpZ2h0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFJvd0hlaWdodCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPiAwICYmIHRoaXMudXBkYXRlU2Nyb2xsSGVpZ2h0KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHN0b3JlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuU3RvcmV8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLlN0b3JlfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U3RvcmUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAgICAgdmFsdWUub24oe1xuICAgICAgICAgICAgICAgIGZpbHRlcjogbWUudXBkYXRlU2Nyb2xsSGVpZ2h0LFxuICAgICAgICAgICAgICAgIGxvYWQgIDogbWUudXBkYXRlU2Nyb2xsSGVpZ2h0LFxuICAgICAgICAgICAgICAgIHNjb3BlIDogbWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5pdGVtc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgIFtkYXRhLnRvdGFsXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB1cGRhdGVTY3JvbGxIZWlnaHQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvdW50UmVjb3JkcyA9IGRhdGE/LnRvdGFsID8gZGF0YS50b3RhbCA6IG1lLnN0b3JlLmNvdW50LFxuICAgICAgICAgICAge3Jvd0hlaWdodH0gID0gbWU7XG5cbiAgICAgICAgaWYgKGNvdW50UmVjb3JkcyA+IDAgJiYgcm93SGVpZ2h0ID4gMCkge1xuICAgICAgICAgICAgbWUudmRvbS5jblswXS5oZWlnaHQgPSBgJHsoY291bnRSZWNvcmRzICsgMSkgKiByb3dIZWlnaHR9cHhgO1xuICAgICAgICAgICAgbWUudXBkYXRlKClcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVmVydGljYWxTY3JvbGxiYXIpO1xuIiwiaW1wb3J0IENvbHVtbiAgIGZyb20gJy4vQmFzZS5tanMnO1xuaW1wb3J0IE5lb0FycmF5IGZyb20gJy4uLy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBWZG9tVXRpbCBmcm9tICcuLi8uLi91dGlsL1ZEb20ubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmdyaWQuY29sdW1uLkFuaW1hdGVkQ2hhbmdlXG4gKiBAZXh0ZW5kcyBOZW8uZ3JpZC5jb2x1bW4uQmFzZVxuICovXG5jbGFzcyBBbmltYXRlZENoYW5nZSBleHRlbmRzIENvbHVtbiB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZ3JpZC5jb2x1bW4uQW5pbWF0ZWRDaGFuZ2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5ncmlkLmNvbHVtbi5BbmltYXRlZENoYW5nZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGFuaW1hdGlvbkNscz0nbmVvLWFuaW1hdGVkJ1xuICAgICAgICAgKi9cbiAgICAgICAgYW5pbWF0aW9uQ2xzOiAnbmVvLWFuaW1hdGVkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gdHlwZT0nYW5pbWF0ZWRDaGFuZ2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHR5cGU6ICdhbmltYXRlZENoYW5nZSdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnBhcmVudC5zdG9yZS5vbih7XG4gICAgICAgICAgICByZWNvcmRDaGFuZ2U6IG1lLm9uUmVjb3JkQ2hhbmdlLFxuICAgICAgICAgICAgc2NvcGUgICAgICAgOiBtZVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIGFzIG5lZWRlZCBmb3IgZHluYW1pYyByZWNvcmQtYmFzZWQgYW5pbWF0aW9uIGNsYXNzZXNcbiAgICAgKiBAcGFyYW0ge1JlY29yZH0gcmVjb3JkXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRBbmltYXRpb25DbHMocmVjb3JkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGlvbkNsc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgIGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSAgICAgICBkYXRhLmZpZWxkcyBFYWNoIGZpZWxkIG9iamVjdCBjb250YWlucyB0aGUga2V5czogbmFtZSwgb2xkVmFsdWUsIHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5Nb2RlbH0gZGF0YS5tb2RlbCBUaGUgbW9kZWwgaW5zdGFuY2Ugb2YgdGhlIGNoYW5nZWQgcmVjb3JkXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgZGF0YS5yZWNvcmRcbiAgICAgKi9cbiAgICBhc3luYyBvblJlY29yZENoYW5nZSh7ZmllbGRzLCByZWNvcmR9KSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2JvZHl9ID0gbWUucGFyZW50LFxuICAgICAgICAgICAgY2VsbElkLCBmaWVsZCwgbm9kZTtcblxuICAgICAgICBmb3IgKGZpZWxkIG9mIGZpZWxkcykge1xuICAgICAgICAgICAgaWYgKGZpZWxkLm5hbWUgPT09IG1lLmRhdGFGaWVsZCkge1xuICAgICAgICAgICAgICAgIC8vIFdhaXQgZm9yIHRoZSBuZXh0IGFuaW1hdGlvbiBmcmFtZVxuICAgICAgICAgICAgICAgIGF3YWl0IG1lLnRpbWVvdXQoMjApO1xuXG4gICAgICAgICAgICAgICAgY2VsbElkID0gYm9keS5nZXRDZWxsSWQobWUucGFyZW50LnN0b3JlLmluZGV4T2YocmVjb3JkKSwgbWUuZGF0YUZpZWxkKTtcbiAgICAgICAgICAgICAgICBub2RlICAgPSBWZG9tVXRpbC5maW5kKGJvZHkudmRvbSwgY2VsbElkKT8udmRvbTtcblxuICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIE5lb0FycmF5LmFkZChub2RlLmNscywgbWUuZ2V0QW5pbWF0aW9uQ2xzKHJlY29yZCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIGEgMm5kIGJvZHkgdXBkYXRlLCBhZnRlciBncmlkLkJvZHk6IG9uU3RvcmVSZWNvcmRDaGFuZ2UoKVxuICAgICAgICAgICAgICAgICAgICAvLyBJdCBpcyBjcnVjaWFsIHRvIHJlc3RhcnQgdGhlIGtleWZyYW1lIGJhc2VkIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyA9PiBUaGUgcHJldmlvdXMgdXBkYXRlIGNhbGwgd2lsbCByZW1vdmUgdGhlIGxhc3QgYW5pbWF0aW9uQ2xzXG4gICAgICAgICAgICAgICAgICAgIGJvZHkudXBkYXRlKClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0aGUgaW5zdGFuY2UgaW50byBhIEpTT04tY29tcGF0aWJsZSBvYmplY3QgZm9yIHRoZSBOZXVyYWwgTGluay5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLnRvSlNPTigpLFxuICAgICAgICAgICAgYW5pbWF0aW9uQ2xzOiB0aGlzLmFuaW1hdGlvbkNsc1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhBbmltYXRlZENoYW5nZSk7XG4iLCJpbXBvcnQgQW5pbWF0ZWRDaGFuZ2UgZnJvbSAnLi9BbmltYXRlZENoYW5nZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZ3JpZC5jb2x1bW4uQW5pbWF0ZWRDdXJyZW5jeVxuICogQGV4dGVuZHMgTmVvLmdyaWQuY29sdW1uLkFuaW1hdGVkQ2hhbmdlXG4gKi9cbmNsYXNzIEFuaW1hdGVkQ3VycmVuY3kgZXh0ZW5kcyBBbmltYXRlZENoYW5nZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZ3JpZC5jb2x1bW4uQW5pbWF0ZWRDdXJyZW5jeSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmdyaWQuY29sdW1uLkFuaW1hdGVkQ3VycmVuY3knLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB0eXBlPSdhbmltYXRlZEN1cnJlbmN5J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0eXBlOiAnYW5pbWF0ZWRDdXJyZW5jeScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgYSBkaWZmZXJlbnQgcmVjb3JkIGZpZWxkIHRvIGJhc2UgdGhlIGNoYW5nZSBvbi5cbiAgICAgICAgICogRGVmYXVsdHMgdGhpcy5kYXRhRmllbGRcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGNvbXBhcmVGaWVsZD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBjb21wYXJlRmllbGQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGN1cnJlbmN5PSdVU0QnXG4gICAgICAgICAqL1xuICAgICAgICBjdXJyZW5jeTogJ1VTRCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGxvY2FsZT0nZGVmYXVsdCdcbiAgICAgICAgICovXG4gICAgICAgIGxvY2FsZTogJ2RlZmF1bHQnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7SW50bC5OdW1iZXJGb3JtYXR8bnVsbH0gZm9ybWF0dGVyPW51bGxcbiAgICAgKi9cbiAgICBmb3JtYXR0ZXIgPSBudWxsXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcbiAgICAgICAgdGhpcy5jcmVhdGVGb3JtYXR0ZXIoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgICBkYXRhXG4gICAgICogQHBhcmFtIHtOZW8uYnV0dG9uLkJhc2V9ICAgIGRhdGEuY29sdW1uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgICAgIGRhdGEuY29sdW1uSW5kZXhcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICAgICAgICAgZGF0YS5kYXRhRmllbGRcbiAgICAgKiBAcGFyYW0ge05lby5ncmlkLkNvbnRhaW5lcn0gZGF0YS5ncmlkQ29udGFpbmVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICAgIGRhdGEucmVjb3JkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgICAgIGRhdGEucm93SW5kZXhcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLlN0b3JlfSAgICAgZGF0YS5zdG9yZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gICAgICBkYXRhLnZhbHVlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgY2VsbFJlbmRlcmVyKHtjb2x1bW4sIHZhbHVlfSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuICcnXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29sdW1uLmZvcm1hdHRlci5mb3JtYXQodmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBjcmVhdGVGb3JtYXR0ZXIoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuZm9ybWF0dGVyID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KG1lLmxvY2FsZSwge3N0eWxlOiAnY3VycmVuY3knLCBjdXJyZW5jeTogbWUuY3VycmVuY3l9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIGFzIG5lZWRlZCBmb3IgZHluYW1pYyByZWNvcmQtYmFzZWQgYW5pbWF0aW9uIGNsYXNzZXNcbiAgICAgKiBAcGFyYW0ge1JlY29yZH0gcmVjb3JkXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRBbmltYXRpb25DbHMocmVjb3JkKSB7XG4gICAgICAgIHJldHVybiByZWNvcmRbdGhpcy5jb21wYXJlRmllbGQgfHwgdGhpcy5kYXRhRmllbGRdIDwgMCA/ICduZW8tYW5pbWF0ZWQtbmVnYXRpdmUnIDogJ25lby1hbmltYXRlZC1wb3NpdGl2ZSdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIHRoZSBpbnN0YW5jZSBpbnRvIGEgSlNPTi1jb21wYXRpYmxlIG9iamVjdCBmb3IgdGhlIE5ldXJhbCBMaW5rLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcbiAgICAgICAgICAgIGNvbXBhcmVGaWVsZDogbWUuY29tcGFyZUZpZWxkLFxuICAgICAgICAgICAgY3VycmVuY3kgICAgOiBtZS5jdXJyZW5jeSxcbiAgICAgICAgICAgIGxvY2FsZSAgICAgIDogbWUubG9jYWxlXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEFuaW1hdGVkQ3VycmVuY3kpO1xuIiwiaW1wb3J0IEJhc2UgICAgICAgICAgICAgIGZyb20gJy4uLy4uL2NvcmUvQmFzZS5tanMnO1xuaW1wb3J0IHtyZXNvbHZlQ2FsbGJhY2t9IGZyb20gJy4uLy4uL3V0aWwvRnVuY3Rpb24ubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmdyaWQuY29sdW1uLkJhc2VcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgQ29sdW1uIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZ3JpZC5jb2x1bW4uQmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmdyaWQuY29sdW1uLkJhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGRhdGFGaWVsZD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkYXRhRmllbGQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZ3JpZC5Db250YWluZXJ8bnVsbH0gcGFyZW50PW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufFN0cmluZ3xudWxsfSByZW5kZXJlcl89J2NlbGxSZW5kZXJlcidcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICByZW5kZXJlcl86ICdjZWxsUmVuZGVyZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2NvcGUgdG8gZXhlY3V0ZSB0aGUgY29sdW1uIHJlbmRlcmVyLlxuICAgICAgICAgKiBEZWZhdWx0cyB0byB0aGUgZ3JpZC5Cb2R5LlxuICAgICAgICAgKiBZb3UgY2FuIHBhc3MgdGhlIHN0cmluZ3MgJ3RoaXMnIG9yICdtZSdcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvcmUuQmFzZXxTdHJpbmd8bnVsbH0gcmVuZGVyZXJTY29wZT1udWxsXG4gICAgICAgICAqL1xuICAgICAgICByZW5kZXJlclNjb3BlOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB0eXBlPSdjb2x1bW4nXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHR5cGU6ICdjb2x1bW4nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IHdpbmRvd0lkXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgd2luZG93SWRfOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB3aW5kb3dJZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFdpbmRvd0lkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB2YWx1ZSAmJiBOZW8uY3VycmVudFdvcmtlci5pbnNlcnRUaGVtZUZpbGVzKHZhbHVlLCB0aGlzLl9fcHJvdG9fXylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSByZW5kZXJlciBjb25maWcgZ2V0cyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRSZW5kZXJlcih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgLy8gSWYgbm8gZm4gaXMgZm91bmQgaW5zaWRlIHRoZSBwYXJlbnQgdHJlZSwgcmV0dXJuIHRoZSBwbGFpbiB2YWx1ZSBmb3IgdmlldyBjb250cm9sbGVycyB0byBtYXRjaFxuICAgICAgICByZXR1cm4gcmVzb2x2ZUNhbGxiYWNrKHZhbHVlLCB0aGlzKS5mbiB8fCB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgICBkYXRhXG4gICAgICogQHBhcmFtIHtOZW8uYnV0dG9uLkJhc2V9ICAgIGRhdGEuY29sdW1uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgICAgIGRhdGEuY29sdW1uSW5kZXhcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICAgICAgICAgZGF0YS5kYXRhRmllbGRcbiAgICAgKiBAcGFyYW0ge05lby5ncmlkLkNvbnRhaW5lcn0gZGF0YS5ncmlkQ29udGFpbmVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICAgIGRhdGEucmVjb3JkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgICAgIGRhdGEucm93SW5kZXhcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLlN0b3JlfSAgICAgZGF0YS5zdG9yZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gICAgICBkYXRhLnZhbHVlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgY2VsbFJlbmRlcmVyKHt2YWx1ZX0pIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0aGUgaW5zdGFuY2UgaW50byBhIEpTT04tY29tcGF0aWJsZSBvYmplY3QgZm9yIHRoZSBOZXVyYWwgTGluay5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IG1lICA9IHRoaXMsXG4gICAgICAgICAgICBvdXQgPSBzdXBlci50b0pTT04oKTtcblxuICAgICAgICBvdXQuZGF0YUZpZWxkID0gbWUuZGF0YUZpZWxkO1xuICAgICAgICBvdXQudHlwZSAgICAgID0gbWUudHlwZTtcblxuICAgICAgICBpZiAoTmVvLmlzU3RyaW5nKG1lLnJlbmRlcmVyKSkge1xuICAgICAgICAgICAgb3V0LnJlbmRlcmVyID0gbWUucmVuZGVyZXJcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKENvbHVtbik7XG4iLCJpbXBvcnQgQ29sdW1uIGZyb20gJy4vQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZ3JpZC5jb2x1bW4uQ29tcG9uZW50XG4gKiBAZXh0ZW5kcyBOZW8uZ3JpZC5jb2x1bW4uQmFzZVxuICovXG5jbGFzcyBDb21wb25lbnQgZXh0ZW5kcyBDb2x1bW4ge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmdyaWQuY29sdW1uLkNvbXBvbmVudCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmdyaWQuY29sdW1uLkNvbXBvbmVudCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbnxPYmplY3R8bnVsbH0gY29tcG9uZW50PW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGNvbXBvbmVudDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gZGVmYXVsdHNcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgZGVmYXVsdHM6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wb25lbnRzIGNhbiBkZWxlZ2F0ZSBldmVudCBsaXN0ZW5lcnMgKG9yIGJ1dHRvbiBoYW5kbGVycykgaW50byBtZXRob2RzIHNvbWV3aGVyZSBpbnNpZGVcbiAgICAgICAgICogdGhlIHZpZXcgY29udHJvbGxlciBvciBjb21wb25lbnQgdHJlZSBoaWVyYXJjaHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEluIHRoaXMgY2FzZSwgaXQgaXMgaGVscGZ1bCB0byBrbm93IHdoYXQgdGhlIHJlbGF0ZWQgcmVjb3JkIGlzLCBzbyB3ZSBhcmUgYWRkaW5nIHRoZSByZWNvcmRcbiAgICAgICAgICogdG8gdGhlIGNvbXBvbmVudCBhcyBhIHByb3BlcnR5LiBCeSBkZWZhdWx0LCBhcyAncmVjb3JkJywgYnV0IHRoaXMgY29uZmlnIGNhbiBjaGFuZ2UgdGhlIHByb3BlcnR5IG5hbWUuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gcmVjb3JkUHJvcGVydHk9J3JlY29yZCdcbiAgICAgICAgICovXG4gICAgICAgIHJlY29yZFByb3BlcnR5OiAncmVjb3JkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gcmVuZGVyZXJTY29wZT0ndGhpcydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVuZGVyZXJTY29wZTogJ3RoaXMnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB0eXBlPSdjb21wb25lbnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHR5cGU6ICdjb21wb25lbnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoaXMgY29uZmlnIHRvIHRydWUsIGluIGNhc2UgeW91IHdhbnQgdG8gdXNlICdiaW5kJyBpbnNpZGUgeW91ciBjZWxsIGJhc2VkIGNvbXBvbmVudC5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gdXNlQmluZGluZ3M9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHVzZUJpbmRpbmdzOiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge01hcH0gbWFwPW5ldyBNYXAoKVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBtYXAgPSBuZXcgTWFwKClcblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIGFzIG5lZWRlZCBpbnNpZGUgY2xhc3MgZXh0ZW5zaW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge1JlY29yZH0gcmVjb3JkXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBhcHBseVJlY29yZENvbmZpZ3MoY29uZmlnLCByZWNvcmQpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgICBkYXRhXG4gICAgICogQHBhcmFtIHtOZW8uY29sdW1uLkJhc2V9ICAgIGRhdGEuY29sdW1uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgICAgIGRhdGEuY29sdW1uSW5kZXhcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICAgICAgICAgZGF0YS5kYXRhRmllbGRcbiAgICAgKiBAcGFyYW0ge05lby5ncmlkLkNvbnRhaW5lcn0gZGF0YS5ncmlkQ29udGFpbmVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICAgIGRhdGEucmVjb3JkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgICAgIGRhdGEucm93SW5kZXhcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLlN0b3JlfSAgICAgZGF0YS5zdG9yZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gICAgICBkYXRhLnZhbHVlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgY2VsbFJlbmRlcmVyKGRhdGEpIHtcbiAgICAgICAgbGV0IHtncmlkQ29udGFpbmVyLCByZWNvcmQsIHJvd0luZGV4fSA9IGRhdGEsXG4gICAgICAgICAgICB7YXBwTmFtZSwgYm9keSwgd2luZG93SWR9ICAgICAgICAgPSBncmlkQ29udGFpbmVyLFxuICAgICAgICAgICAgbWUgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7cmVjb3JkUHJvcGVydHl9ID0gbWUsXG4gICAgICAgICAgICBpZCAgICAgICAgICAgICAgID0gbWUuZ2V0Q29tcG9uZW50SWQocm93SW5kZXgpLFxuICAgICAgICAgICAgY29tcG9uZW50ICAgICAgICA9IG1lLm1hcC5nZXQoaWQpLFxuICAgICAgICAgICAgY29tcG9uZW50Q29uZmlnICA9IG1lLmNvbXBvbmVudDtcblxuICAgICAgICBpZiAoTmVvLnR5cGVPZihjb21wb25lbnRDb25maWcpID09PSAnRnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb21wb25lbnRDb25maWcgPSBjb21wb25lbnRDb25maWcoZGF0YSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBvbmVudENvbmZpZyA9IG1lLmFwcGx5UmVjb3JkQ29uZmlncyhjb21wb25lbnRDb25maWcsIHJlY29yZCk7XG4gICAgICAgIGNvbXBvbmVudENvbmZpZyA9IHsuLi5jb21wb25lbnRDb25maWd9O1xuXG4gICAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb21wb25lbnRDb25maWcuY2xhc3NOYW1lO1xuICAgICAgICAgICAgZGVsZXRlIGNvbXBvbmVudENvbmZpZy5tb2R1bGU7XG4gICAgICAgICAgICBkZWxldGUgY29tcG9uZW50Q29uZmlnLm50eXBlO1xuXG4gICAgICAgICAgICBjb21wb25lbnRDb25maWdbcmVjb3JkUHJvcGVydHldID0gcmVjb3JkO1xuXG4gICAgICAgICAgICBjb21wb25lbnQuc2V0KGNvbXBvbmVudENvbmZpZylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbXBvbmVudCA9IE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIC4uLm1lLmRlZmF1bHRzLFxuICAgICAgICAgICAgICAgIC4uLmNvbXBvbmVudENvbmZpZyxcbiAgICAgICAgICAgICAgICBhcHBOYW1lLFxuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCA6IGJvZHksXG4gICAgICAgICAgICAgICAgW3JlY29yZFByb3BlcnR5XTogcmVjb3JkLFxuICAgICAgICAgICAgICAgIHdpbmRvd0lkXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBlbnN1cmUgdGhhdCB3cmFwcGVkIGNvbXBvbmVudHMgYWx3YXlzIGdldCB0aGUgc2FtZSBpbmRleC1iYXNlZCBpZC5cbiAgICAgICAgICAgIGlmICghY29tcG9uZW50LnZkb20uaWQpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQudmRvbS5pZCA9IGlkICsgJ19fd3JhcHBlcidcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUubWFwLnNldChpZCwgY29tcG9uZW50KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lLnVzZUJpbmRpbmdzKSB7XG4gICAgICAgICAgICBib2R5LmdldFN0YXRlUHJvdmlkZXIoKT8uY3JlYXRlQmluZGluZ3MoY29tcG9uZW50KVxuICAgICAgICB9XG5cbiAgICAgICAgYm9keS51cGRhdGVEZXB0aCA9IC0xO1xuXG4gICAgICAgIHJldHVybiBjb21wb25lbnQuY3JlYXRlVmRvbVJlZmVyZW5jZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJvd0luZGV4XG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRDb21wb25lbnRJZChyb3dJbmRleCkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtib2R5fSA9IG1lLnBhcmVudCxcbiAgICAgICAgICAgIHN0b3JlICA9IGJvZHkuc3RvcmU7IC8vIEFjY2VzcyB0aGUgc3RvcmUgZnJvbSB0aGUgYm9keVxuXG4gICAgICAgIGlmIChzdG9yZS5jaHVua2luZ1RvdGFsKSB7IC8vIENoZWNrIGlmIGNodW5raW5nIGlzIGFjdGl2ZVxuICAgICAgICAgICAgcmV0dXJuIGAke21lLmlkfS1jb21wb25lbnQtJHtyb3dJbmRleH1gOyAvLyBVc2Ugcm93SW5kZXggZGlyZWN0bHlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgJHttZS5pZH0tY29tcG9uZW50LSR7cm93SW5kZXggJSAoYm9keS5hdmFpbGFibGVSb3dzICsgMiAqIGJvZHkuYnVmZmVyUm93UmFuZ2UpfWBcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIGluc3RhbmNlIGludG8gYSBKU09OLWNvbXBhdGlibGUgb2JqZWN0IGZvciB0aGUgTmV1cmFsIExpbmsuXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBtZSAgPSB0aGlzLFxuICAgICAgICAgICAgb3V0ID0gc3VwZXIudG9KU09OKCk7XG5cbiAgICAgICAgb3V0LnJlY29yZFByb3BlcnR5ID0gbWUucmVjb3JkUHJvcGVydHk7XG4gICAgICAgIG91dC51c2VCaW5kaW5ncyAgICA9IG1lLnVzZUJpbmRpbmdzO1xuXG4gICAgICAgIGlmIChOZW8uaXNPYmplY3QobWUuY29tcG9uZW50KSkge1xuICAgICAgICAgICAgb3V0LmNvbXBvbmVudCA9IG1lLnNlcmlhbGl6ZUNvbmZpZyhtZS5jb21wb25lbnQpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhDb21wb25lbnQpO1xuIiwiaW1wb3J0IENvbHVtbiBmcm9tICcuL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmdyaWQuY29sdW1uLkN1cnJlbmN5XG4gKiBAZXh0ZW5kcyBOZW8uZ3JpZC5jb2x1bW4uQmFzZVxuICovXG5jbGFzcyBDdXJyZW5jeSBleHRlbmRzIENvbHVtbiB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZ3JpZC5jb2x1bW4uQ3VycmVuY3knXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5ncmlkLmNvbHVtbi5DdXJyZW5jeScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHR5cGU9J2N1cnJlbmN5J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0eXBlOiAnY3VycmVuY3knLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjdXJyZW5jeT0nVVNEJ1xuICAgICAgICAgKi9cbiAgICAgICAgY3VycmVuY3k6ICdVU0QnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBsb2NhbGU9J2RlZmF1bHQnXG4gICAgICAgICAqL1xuICAgICAgICBsb2NhbGU6ICdkZWZhdWx0J1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0ludGwuTnVtYmVyRm9ybWF0fG51bGx9IGZvcm1hdHRlcj1udWxsXG4gICAgICovXG4gICAgZm9ybWF0dGVyID0gbnVsbFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG4gICAgICAgIHRoaXMuY3JlYXRlRm9ybWF0dGVyKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgICAgZGF0YVxuICAgICAqIEBwYXJhbSB7TmVvLmJ1dHRvbi5CYXNlfSAgICBkYXRhLmNvbHVtblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgICAgICAgICAgICBkYXRhLmNvbHVtbkluZGV4XG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgICAgICAgICAgIGRhdGEuZGF0YUZpZWxkXG4gICAgICogQHBhcmFtIHtOZW8uZ3JpZC5Db250YWluZXJ9IGRhdGEuZ3JpZENvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgICBkYXRhLnJlY29yZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgICAgICAgICAgICBkYXRhLnJvd0luZGV4XG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5TdG9yZX0gICAgIGRhdGEuc3RvcmVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9ICAgICAgZGF0YS52YWx1ZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGNlbGxSZW5kZXJlcih7dmFsdWV9KSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gJydcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdHRlci5mb3JtYXQodmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBjcmVhdGVGb3JtYXR0ZXIoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuZm9ybWF0dGVyID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KG1lLmxvY2FsZSwge3N0eWxlOiAnY3VycmVuY3knLCBjdXJyZW5jeTogbWUuY3VycmVuY3l9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIGluc3RhbmNlIGludG8gYSBKU09OLWNvbXBhdGlibGUgb2JqZWN0IGZvciB0aGUgTmV1cmFsIExpbmsuXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcbiAgICAgICAgICAgIGN1cnJlbmN5OiB0aGlzLmN1cnJlbmN5LFxuICAgICAgICAgICAgbG9jYWxlICA6IHRoaXMubG9jYWxlXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEN1cnJlbmN5KTtcbiIsImltcG9ydCBDb2x1bW4gZnJvbSAnLi9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5ncmlkLmNvbHVtbi5JbmRleFxuICogQGV4dGVuZHMgTmVvLmdyaWQuY29sdW1uLkJhc2VcbiAqL1xuY2xhc3MgSW5kZXggZXh0ZW5kcyBDb2x1bW4ge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmdyaWQuY29sdW1uLkluZGV4J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZ3JpZC5jb2x1bW4uSW5kZXgnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB0eXBlPSdpbmRleCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdHlwZTogJ2luZGV4JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHplcm9CYXNlZD1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgemVyb0Jhc2VkOiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgICBkYXRhXG4gICAgICogQHBhcmFtIHtOZW8uYnV0dG9uLkJhc2V9ICAgIGRhdGEuY29sdW1uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgICAgIGRhdGEuY29sdW1uSW5kZXhcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICAgICAgICAgZGF0YS5kYXRhRmllbGRcbiAgICAgKiBAcGFyYW0ge05lby5ncmlkLkNvbnRhaW5lcn0gZGF0YS5ncmlkQ29udGFpbmVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICAgIGRhdGEucmVjb3JkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgICAgIGRhdGEucm93SW5kZXhcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLlN0b3JlfSAgICAgZGF0YS5zdG9yZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gICAgICBkYXRhLnZhbHVlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgY2VsbFJlbmRlcmVyKHtyb3dJbmRleH0pIHtcbiAgICAgICAgcmV0dXJuIHJvd0luZGV4ICsgKHRoaXMuemVyb0Jhc2VkID8gMCA6IDEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0aGUgaW5zdGFuY2UgaW50byBhIEpTT04tY29tcGF0aWJsZSBvYmplY3QgZm9yIHRoZSBOZXVyYWwgTGluay5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLnRvSlNPTigpLFxuICAgICAgICAgICAgemVyb0Jhc2VkOiB0aGlzLnplcm9CYXNlZFxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhJbmRleCk7XG4iLCJpbXBvcnQgQ29tcG9uZW50Q29sdW1uICAgZnJvbSAnLi9Db21wb25lbnQubWpzJztcbmltcG9ydCBQcm9ncmVzc0NvbXBvbmVudCBmcm9tICcuLi8uLi9jb21wb25lbnQvUHJvZ3Jlc3MubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmdyaWQuY29sdW1uLlByb2dyZXNzXG4gKiBAZXh0ZW5kcyBOZW8uZ3JpZC5jb2x1bW4uQ29tcG9uZW50XG4gKi9cbmNsYXNzIFByb2dyZXNzIGV4dGVuZHMgQ29tcG9uZW50Q29sdW1uIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5ncmlkLmNvbHVtbi5Qcm9ncmVzcydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmdyaWQuY29sdW1uLlByb2dyZXNzJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gZGVmYXVsdHNcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgICAgIG1vZHVsZTogUHJvZ3Jlc3NDb21wb25lbnRcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gdHlwZT0ncHJvZ3Jlc3MnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHR5cGU6ICdwcm9ncmVzcydcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtSZWNvcmR9IHJlY29yZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgYXBwbHlSZWNvcmRDb25maWdzKGNvbmZpZywgcmVjb3JkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkW3RoaXMuZGF0YUZpZWxkXSxcbiAgICAgICAgICAgIC4uLmNvbmZpZ1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0aGUgaW5zdGFuY2UgaW50byBhIEpTT04tY29tcGF0aWJsZSBvYmplY3QgZm9yIHRoZSBOZXVyYWwgTGluay5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLnRvSlNPTigpLFxuICAgICAgICAgICAgZGVmYXVsdHM6IHRoaXMuc2VyaWFsaXplQ29uZmlnKHRoaXMuZGVmYXVsdHMpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFByb2dyZXNzKTtcbiIsImltcG9ydCBBbmltYXRlZENoYW5nZSAgIGZyb20gJy4vQW5pbWF0ZWRDaGFuZ2UubWpzJztcbmltcG9ydCBBbmltYXRlZEN1cnJlbmN5IGZyb20gJy4vQW5pbWF0ZWRDdXJyZW5jeS5tanMnO1xuaW1wb3J0IEJhc2UgICAgICAgICAgICAgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQgQ29tcG9uZW50ICAgICAgICBmcm9tICcuL0NvbXBvbmVudC5tanMnO1xuaW1wb3J0IEN1cnJlbmN5ICAgICAgICAgZnJvbSAnLi9DdXJyZW5jeS5tanMnO1xuaW1wb3J0IEluZGV4ICAgICAgICAgICAgZnJvbSAnLi9JbmRleC5tanMnO1xuaW1wb3J0IFByb2dyZXNzICAgICAgICAgZnJvbSAnLi9Qcm9ncmVzcy5tanMnO1xuXG5leHBvcnQge0FuaW1hdGVkQ2hhbmdlLCBBbmltYXRlZEN1cnJlbmN5LCBCYXNlLCBDb21wb25lbnQsIEN1cnJlbmN5LCBJbmRleCwgUHJvZ3Jlc3N9O1xuIiwiaW1wb3J0IEJhc2VCdXR0b24gZnJvbSAnLi4vLi4vYnV0dG9uL0Jhc2UubWpzJztcbmltcG9ydCBOZW9BcnJheSAgIGZyb20gJy4uLy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBUZXh0RmllbGQgIGZyb20gJy4uLy4uL2Zvcm0vZmllbGQvVGV4dC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZ3JpZC5oZWFkZXIuQnV0dG9uXG4gKiBAZXh0ZW5kcyBOZW8uYnV0dG9uLkJhc2VcbiAqL1xuY2xhc3MgQnV0dG9uIGV4dGVuZHMgQmFzZUJ1dHRvbiB7XG4gICAgLyoqXG4gICAgICogVmFsaWQgdmFsdWVzIGZvciBhbGlnblxuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBjZWxsQWxpZ25WYWx1ZXM6IFsnbGVmdCcsJ2NlbnRlcicsJ3JpZ2h0J11cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBjZWxsQWxpZ25WYWx1ZXMgPSBbJ2xlZnQnLCAnY2VudGVyJywgJ3JpZ2h0J11cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmdyaWQuaGVhZGVyLkJ1dHRvbidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmdyaWQuaGVhZGVyLkJ1dHRvbicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdncmlkLWhlYWRlci1idXR0b24nXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnZ3JpZC1oZWFkZXItYnV0dG9uJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWdyaWQtaGVhZGVyLWJ1dHRvbicsJ25lby1idXR0b24nXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tZ3JpZC1oZWFkZXItYnV0dG9uJywgJ25lby1idXR0b24nXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsaWdubWVudCBvZiB0aGUgbWF0Y2hpbmcgZ3JpZCBjZWxscy4gVmFsaWQgdmFsdWVzIGFyZSBsZWZ0LCBjZW50ZXIsIHJpZ2h0XG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2VsbEFsaWduXz0nbGVmdCdcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBjZWxsQWxpZ25fOiAnbGVmdCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gZGF0YUZpZWxkPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRhdGFGaWVsZDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNvcnQgZGlyZWN0aW9uIHdoZW4gY2xpY2tpbmcgb24gYW4gdW5zb3J0ZWQgYnV0dG9uXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gZGVmYXVsdFNvcnREaXJlY3Rpb249J0FTQydcbiAgICAgICAgICovXG4gICAgICAgIGRlZmF1bHRTb3J0RGlyZWN0aW9uOiAnQVNDJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gZWRpdG9yQ29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGVkaXRvckNvbmZpZzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gZmlsdGVyQ29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGZpbHRlckNvbmZpZzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5mb3JtLmZpZWxkLkJhc2V8bnVsbH0gZmlsdGVyRmllbGQ9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBmaWx0ZXJGaWVsZDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gaWNvbkNscz0nZmEgZmEtYXJyb3ctY2lyY2xlLXVwJ1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGljb25DbHM6ICdmYSBmYS1hcnJvdy1jaXJjbGUtdXAnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBpY29uUG9zaXRpb249J3JpZ2h0J1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGljb25Qb3NpdGlvbjogJ3JpZ2h0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqICdBU0MnLCAnREVTQycgb3IgbnVsbFxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gaXNTb3J0ZWRfPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGlzU29ydGVkXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gcm9sZT0nY29sdW1uaGVhZGVyJ1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHJvbGU6ICdjb2x1bW5oZWFkZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2hvd0hlYWRlckZpbHRlcl89ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzaG93SGVhZGVyRmlsdGVyXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzb3J0YWJsZV89dHJ1ZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHNvcnRhYmxlXzogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaXNTb3J0ZWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldElzU29ydGVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjbHN9ICAgICA9IG1lLFxuICAgICAgICAgICAgY29udGFpbmVyID0gbWUudXAoJ2dyaWQtY29udGFpbmVyJyk7XG5cbiAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSBudWxsOlxuICAgICAgICAgICAgICAgIE5lb0FycmF5LmFkZChjbHMsICduZW8tc29ydC1oaWRkZW4nKTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSAnQVNDJzpcbiAgICAgICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUoY2xzLCAnbmVvLXNvcnQtZGVzYycpO1xuICAgICAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZShjbHMsICduZW8tc29ydC1oaWRkZW4nKTtcbiAgICAgICAgICAgICAgICBOZW9BcnJheS5hZGQoY2xzLCAnbmVvLXNvcnQtYXNjJyk7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgJ0RFU0MnOlxuICAgICAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZShjbHMsICduZW8tc29ydC1hc2MnKTtcbiAgICAgICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUoY2xzLCAnbmVvLXNvcnQtaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgTmVvQXJyYXkuYWRkKGNscywgJ25lby1zb3J0LWRlc2MnKTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgICAgbWUuY2xzID0gY2xzO1xuXG4gICAgICAgIC8vIHRlc3RpbmcgY2hlY2sgdW50aWwgYWxsIGV4YW1wbGUgZ3JpZHMgaGF2ZSBhIHN0b3JlXG4gICAgICAgIGlmICghY29udGFpbmVyIHx8ICFjb250YWluZXIuc3RvcmUpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgbWUubW91bnRlZCAmJiBtZS5maXJlKCdzb3J0Jywge1xuICAgICAgICAgICAgZGlyZWN0aW9uOiB2YWx1ZSxcbiAgICAgICAgICAgIHByb3BlcnR5IDogbWUuZGF0YUZpZWxkXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzaG93SGVhZGVyRmlsdGVyIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U2hvd0hlYWRlckZpbHRlcih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghbWUuZmlsdGVyRmllbGQpIHtcbiAgICAgICAgICAgICAgICBtZS5maWx0ZXJGaWVsZCA9IE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGUgICA6IFRleHRGaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgYXBwTmFtZSAgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgICAgICAgICBmbGFnICAgICA6ICdmaWx0ZXItZmllbGQnLFxuICAgICAgICAgICAgICAgICAgICBoaWRlTGFiZWw6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudElkIDogbWUuaWQsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlICAgIDoge21hcmdpbkxlZnQ6ICcuNWVtJywgbWFyZ2luUmlnaHQ6ICcuNWVtJ30sXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0lkIDogbWUud2luZG93SWQsXG5cbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2UgICAgICAgIDogbWUuY2hhbmdlRmlsdGVyVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvckNoYW5nZTogbWUuY2hhbmdlRmlsdGVyT3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZSAgICAgICAgIDogbWVcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAuLi5tZS5lZGl0b3JDb25maWdcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIG1lLnZkb20uY24ucHVzaChtZS5maWx0ZXJGaWVsZC5jcmVhdGVWZG9tUmVmZXJlbmNlKCkpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBtZS5maWx0ZXJGaWVsZC52ZG9tLnJlbW92ZURvbVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1lLmZpbHRlckZpZWxkKSB7XG4gICAgICAgICAgICBtZS5maWx0ZXJGaWVsZC52ZG9tLnJlbW92ZURvbSA9IHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnVwZGF0ZURlcHRoID0gMjtcbiAgICAgICAgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNvcnRhYmxlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U29ydGFibGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2xzfSA9IG1lO1xuXG4gICAgICAgIE5lb0FycmF5LnRvZ2dsZShjbHMsICduZW8tc29ydC1oaWRkZW4nLCAhdmFsdWUpO1xuXG4gICAgICAgIG1lLmNscyA9IGNscztcbiAgICAgICAgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBjZWxsQWxpZ24gY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRDZWxsQWxpZ24odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlZm9yZVNldEVudW1WYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICdjZWxsQWxpZ24nLCAnY2VsbEFsaWduVmFsdWVzJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGRlc3Ryb3koLi4uYXJncykge1xuICAgICAgICB0aGlzLmZpbHRlckZpZWxkPy5kZXN0cm95KCk7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koLi4uYXJncylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbkNsaWNrKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIG1hcDtcblxuICAgICAgICBpZiAobWUuZGVmYXVsdFNvcnREaXJlY3Rpb24gPT09ICdERVNDJykge1xuICAgICAgICAgICAgbWFwID0ge1xuICAgICAgICAgICAgICAgIEFTQyA6IG51bGwsXG4gICAgICAgICAgICAgICAgREVTQzogJ0FTQycsXG4gICAgICAgICAgICAgICAgbnVsbDogJ0RFU0MnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXAgPSB7XG4gICAgICAgICAgICAgICAgQVNDIDogJ0RFU0MnLFxuICAgICAgICAgICAgICAgIERFU0M6IG51bGwsXG4gICAgICAgICAgICAgICAgbnVsbDogJ0FTQydcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmlzU29ydGVkID0gbWFwW21lLmlzU29ydGVkICsgJyddO1xuXG4gICAgICAgIHN1cGVyLm9uQ2xpY2soZGF0YSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGNoYW5nZUZpbHRlck9wZXJhdG9yKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZ3JpZENvbnRhaW5lciA9IG1lLnVwKCdncmlkLWNvbnRhaW5lcicpLFxuICAgICAgICAgICAgc3RvcmUgICAgICAgICA9IGdyaWRDb250YWluZXI/LnN0b3JlLFxuICAgICAgICAgICAgb3BlcmF0b3IgICAgICA9IGRhdGEudmFsdWUsXG4gICAgICAgICAgICBmaWx0ZXIsIGZpbHRlcnM7XG5cbiAgICAgICAgaWYgKHN0b3JlKSB7XG4gICAgICAgICAgICBmaWx0ZXIgPSBzdG9yZS5nZXRGaWx0ZXIobWUuZGF0YUZpZWxkKTtcblxuICAgICAgICAgICAgaWYgKCFmaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJzID0gc3RvcmUuZmlsdGVycztcblxuICAgICAgICAgICAgICAgIGZpbHRlcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBtZS5kYXRhRmllbGQsXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgLi4ubWUuZmlsdGVyQ29uZmlnXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBzdG9yZS5maWx0ZXJzID0gZmlsdGVyc1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIub3BlcmF0b3IgPSBvcGVyYXRvclxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBjaGFuZ2VGaWx0ZXJWYWx1ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGdyaWRDb250YWluZXIgPSBtZS51cCgnZ3JpZC1jb250YWluZXInKSxcbiAgICAgICAgICAgIHN0b3JlICAgICAgICAgPSBncmlkQ29udGFpbmVyPy5zdG9yZSxcbiAgICAgICAgICAgIHt2YWx1ZX0gICAgICAgPSBkYXRhLFxuICAgICAgICAgICAgZmllbGQsIGZpbHRlciwgZmlsdGVycywgbW9kZWw7XG5cbiAgICAgICAgaWYgKHN0b3JlKSB7XG4gICAgICAgICAgICBmaWx0ZXIgPSBzdG9yZS5nZXRGaWx0ZXIobWUuZGF0YUZpZWxkKTtcbiAgICAgICAgICAgIG1vZGVsICA9IHN0b3JlLm1vZGVsO1xuICAgICAgICAgICAgZmllbGQgID0gbW9kZWwuZ2V0RmllbGQobWUuZGF0YUZpZWxkKTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlICYmIGZpZWxkPy50eXBlLnRvTG93ZXJDYXNlKCkgPT09ICdkYXRlJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUodmFsdWUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVycyA9IHN0b3JlLmZpbHRlcnM7XG5cbiAgICAgICAgICAgICAgICBmaWx0ZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogbWUuZGF0YUZpZWxkLFxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogJ2xpa2UnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgLi4ubWUuZmlsdGVyQ29uZmlnXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBzdG9yZS5maWx0ZXJzID0gZmlsdGVyc1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIudmFsdWUgPSB2YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHJlbW92ZVNvcnRpbmdDc3MoKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2xzfSA9IG1lO1xuXG4gICAgICAgIE5lb0FycmF5LmFkZChjbHMsICduZW8tc29ydC1oaWRkZW4nKTtcblxuICAgICAgICBtZS5jbHMgICAgICAgPSBjbHM7XG4gICAgICAgIG1lLl9pc1NvcnRlZCA9IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXG4gICAgICAgICAgICBjZWxsQWxpZ24gICAgICAgICAgIDogbWUuY2VsbEFsaWduLFxuICAgICAgICAgICAgZGF0YUZpZWxkICAgICAgICAgICA6IG1lLmRhdGFGaWVsZCxcbiAgICAgICAgICAgIGRlZmF1bHRTb3J0RGlyZWN0aW9uOiBtZS5kZWZhdWx0U29ydERpcmVjdGlvbixcbiAgICAgICAgICAgIGVkaXRvckNvbmZpZyAgICAgICAgOiBtZS5zZXJpYWxpemVDb25maWcobWUuZWRpdG9yQ29uZmlnKSxcbiAgICAgICAgICAgIGZpbHRlckNvbmZpZyAgICAgICAgOiBtZS5zZXJpYWxpemVDb25maWcobWUuZmlsdGVyQ29uZmlnKSxcbiAgICAgICAgICAgIGlzU29ydGVkICAgICAgICAgICAgOiBtZS5pc1NvcnRlZCxcbiAgICAgICAgICAgIHNob3dIZWFkZXJGaWx0ZXIgICAgOiBtZS5zaG93SGVhZGVyRmlsdGVyLFxuICAgICAgICAgICAgc29ydGFibGUgICAgICAgICAgICA6IG1lLnNvcnRhYmxlXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEJ1dHRvbik7XG4iLCJpbXBvcnQgQmFzZVRvb2xiYXIgZnJvbSAnLi4vLi4vdG9vbGJhci9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5ncmlkLmhlYWRlci5Ub29sYmFyXG4gKiBAZXh0ZW5kcyBOZW8udG9vbGJhci5CYXNlXG4gKi9cbmNsYXNzIFRvb2xiYXIgZXh0ZW5kcyBCYXNlVG9vbGJhciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZ3JpZC5oZWFkZXIuVG9vbGJhcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmdyaWQuaGVhZGVyLlRvb2xiYXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nZ3JpZC1oZWFkZXItdG9vbGJhcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdncmlkLWhlYWRlci10b29sYmFyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWdyaWQtaGVhZGVyLXRvb2xiYXInLCduZW8tdG9vbGJhciddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1ncmlkLWhlYWRlci10b29sYmFyJywgJ25lby10b29sYmFyJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBkcmFnUmVzb3J0YWJsZT10cnVlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ1Jlc29ydGFibGU6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGl0ZW1EZWZhdWx0cz17bnR5cGU6ICdncmlkLWhlYWRlci1idXR0b24nfVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1EZWZhdWx0czoge1xuICAgICAgICAgICAgbnR5cGU6ICdncmlkLWhlYWRlci1idXR0b24nXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHJvbGU9J3JvdydcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICByb2xlOiAncm93JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gc2Nyb2xsTGVmdF89MFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHNjcm9sbExlZnRfOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2hvd0hlYWRlckZpbHRlcnNfPWZhbHNlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2hvd0hlYWRlckZpbHRlcnNfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlbmllbmNlIHNob3J0Y3V0IHRvIHBhc3Mgc29ydGFibGUgdG8gYWxsIHRvb2xiYXIgaXRlbXMuXG4gICAgICAgICAqIElmIHNldCB0byB0cnVlLCBoZWFkZXIgY2xpY2tzIHdpbGwgc29ydCB0aGUgbWF0Y2hpbmcgY29sdW1uIChBU0MsIERFU0MsIG51bGwpXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNvcnRhYmxlXz10cnVlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgc29ydGFibGVfOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbVxuICAgICAgICAgKi9cbiAgICAgICAgX3Zkb206XG4gICAgICAgIHsnYXJpYS1yb3dpbmRleCc6IDEsIGNuOiBbe2NuOiBbXX1dfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbW91bnRlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB2YWx1ZSAmJiB0aGlzLnBhc3NTaXplVG9Cb2R5KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNob3dIZWFkZXJGaWx0ZXJzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U2hvd0hlYWRlckZpbHRlcnModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgICAgICBtZS5pdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIGl0ZW0uc2V0U2lsZW50KHtcbiAgICAgICAgICAgICAgICAgICAgc2hvd0hlYWRlckZpbHRlcjogdmFsdWVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLnVwZGF0ZURlcHRoID0gLTE7IC8vIGZpbHRlcnMgY2FuIGJlIGRlZXBseSBuZXN0ZWRcbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNjcm9sbExlZnQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U2Nyb2xsTGVmdCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5zb3J0Wm9uZSkge1xuICAgICAgICAgICAgdGhpcy5zb3J0Wm9uZS5zY3JvbGxMZWZ0ID0gdmFsdWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc29ydGFibGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTb3J0YWJsZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIG1lLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgaXRlbS5zZXRTaWxlbnQoe1xuICAgICAgICAgICAgICAgICAgICBzb3J0YWJsZTogdmFsdWVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLnVwZGF0ZURlcHRoID0gMjtcbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGNyZWF0ZUl0ZW1zKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHttb3VudGVkfSA9IG1lO1xuXG4gICAgICAgIG1lLml0ZW1EZWZhdWx0cy5zaG93SGVhZGVyRmlsdGVyID0gbWUuc2hvd0hlYWRlckZpbHRlcnM7XG5cbiAgICAgICAgbWUuaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGlmICghT2JqZWN0Lmhhc093bihpdGVtLCAnc29ydGFibGUnKSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uc29ydGFibGUgPSBtZS5zb3J0YWJsZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBzdXBlci5jcmVhdGVJdGVtcygpO1xuXG4gICAgICAgIGxldCB7aXRlbXN9ID0gbWUsXG4gICAgICAgICAgICBzdHlsZTtcblxuICAgICAgICBpdGVtcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaXRlbS52ZG9tWydhcmlhLWNvbGluZGV4J10gPSBpbmRleCArIDE7IC8vIDEgYmFzZWRcblxuICAgICAgICAgICAgc3R5bGUgPSBpdGVtLndyYXBwZXJTdHlsZTtcblxuICAgICAgICAgICAgLy8gdG9kbzogb25seSBhZGQgcHggaWYgbnVtYmVyXG4gICAgICAgICAgICBpZiAoaXRlbS5tYXhXaWR0aCkge3N0eWxlLm1heFdpZHRoID0gaXRlbS5tYXhXaWR0aCArICdweCd9XG4gICAgICAgICAgICBpZiAoaXRlbS5taW5XaWR0aCkge3N0eWxlLm1pbldpZHRoID0gaXRlbS5taW5XaWR0aCArICdweCd9XG4gICAgICAgICAgICBpZiAoaXRlbS53aWR0aCkgICAge3N0eWxlLndpZHRoICAgID0gaXRlbS53aWR0aCAgICArICdweCd9XG5cbiAgICAgICAgICAgIGl0ZW0ud3JhcHBlclN0eWxlID0gc3R5bGVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUucHJvbWlzZVVwZGF0ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgLy8gVG8gcHJldmVudCBkdXBsaWNhdGUgY2FsbHMsIHdlIG5lZWQgdG8gY2hlY2sgdGhlIG1vdW50ZWQgc3RhdGUgYmVmb3JlIHRoZSB1cGRhdGUgY2FsbFxuICAgICAgICAgICAgbW91bnRlZCAmJiBtZS5wYXNzU2l6ZVRvQm9keSgpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNyZWF0ZVNvcnRab25lKGNvbmZpZykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIE5lby5tZXJnZShjb25maWcsIHtcbiAgICAgICAgICAgIGJvdW5kYXJ5Q29udGFpbmVySWQ6IFttZS5pZCwgbWUucGFyZW50LmlkXSxcbiAgICAgICAgICAgIHNjcm9sbExlZnQgICAgICAgICA6IG1lLnNjcm9sbExlZnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc3VwZXIuY3JlYXRlU29ydFpvbmUoY29uZmlnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhRmllbGRcbiAgICAgKiBAcmV0dXJucyB7TmVvLmJ1dHRvbi5CYXNlfG51bGx9XG4gICAgICovXG4gICAgZ2V0Q29sdW1uKGRhdGFGaWVsZCkge1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5pdGVtcykge1xuICAgICAgICAgICAgaWYgKGl0ZW0uZGF0YUZpZWxkID09PSBkYXRhRmllbGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIGxvYWRTb3J0Wm9uZU1vZHVsZSgpIHtcbiAgICAgICAgcmV0dXJuIGltcG9ydCgnLi4vLi4vZHJhZ2dhYmxlL2dyaWQvaGVhZGVyL3Rvb2xiYXIvU29ydFpvbmUubWpzJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNpbGVudD1mYWxzZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIHBhc3NTaXplVG9Cb2R5KHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtpdGVtc30gICAgICAgICA9IG1lLFxuICAgICAgICAgICAge2JvZHl9ICAgICAgICAgID0gbWUucGFyZW50LFxuICAgICAgICAgICAgcmVjdHMgICAgICAgICAgID0gYXdhaXQgbWUuZ2V0RG9tUmVjdChpdGVtcy5tYXAoaXRlbSA9PiBpdGVtLmlkKSksXG4gICAgICAgICAgICBsYXN0SXRlbSAgICAgICAgPSByZWN0c1tyZWN0cy5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIGNvbHVtblBvc2l0aW9ucyA9IHJlY3RzLm1hcCgoaXRlbSwgaW5kZXgpID0+ICh7ZGF0YUZpZWxkOiBpdGVtc1tpbmRleF0uZGF0YUZpZWxkLCB3aWR0aDogaXRlbS53aWR0aCwgeDogaXRlbS54IC0gcmVjdHNbMF0ueH0pKSxcbiAgICAgICAgICAgIGkgICAgICAgICAgICAgICA9IDEsXG4gICAgICAgICAgICBsZW4gICAgICAgICAgICAgPSBjb2x1bW5Qb3NpdGlvbnMubGVuZ3RoLFxuICAgICAgICAgICAgbGF5b3V0RmluaXNoZWQgID0gdHJ1ZTtcblxuICAgICAgICAvLyBJZiB0aGUgY3NzIHNpemluZyBpcyBub3QgZG9uZSwgY29sdW1ucyBhZnRlciB0aGUgZmlyc3Qgb25lIGNhbiBnZXQgeCA9IDBcbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGNvbHVtblBvc2l0aW9uc1tpXS54ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbGF5b3V0RmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlbGF5IGZvciBzbG93IGNvbm5lY3Rpb25zLCB3aGVyZSB0aGUgY29udGFpbmVyLXNpemluZyBpcyBub3QgZG9uZSB5ZXRcbiAgICAgICAgaWYgKCFsYXlvdXRGaW5pc2hlZCkge1xuICAgICAgICAgICAgYXdhaXQgbWUudGltZW91dCgxMDApO1xuICAgICAgICAgICAgYXdhaXQgbWUucGFzc1NpemVUb0JvZHkoc2lsZW50KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYm9keS5jb2x1bW5Qb3NpdGlvbnMuY2xlYXIoKTtcbiAgICAgICAgICAgIGJvZHkuY29sdW1uUG9zaXRpb25zLmFkZChjb2x1bW5Qb3NpdGlvbnMpO1xuXG4gICAgICAgICAgICBib2R5W3NpbGVudCA/ICdzZXRTaWxlbnQnIDogJ3NldCddKHtcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVXaWR0aDogbGFzdEl0ZW0ueCArIGxhc3RJdGVtLndpZHRoIC0gcmVjdHNbMF0ueFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICFzaWxlbnQgJiYgYm9keS51cGRhdGVNb3VudGVkQW5kVmlzaWJsZUNvbHVtbnMoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICBpbmRleFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIHNjcm9sbFRvSW5kZXgoaW5kZXgpIHtcbiAgICAgICAgYXdhaXQgTmVvLm1haW4uRG9tQWNjZXNzLnNjcm9sbEludG9WaWV3KHtcbiAgICAgICAgICAgIGRlbGF5ICAgOiAxMjUsXG4gICAgICAgICAgICBpZCAgICAgIDogdGhpcy5pdGVtc1tpbmRleF0uaWQsXG4gICAgICAgICAgICB3aW5kb3dJZDogdGhpcy53aW5kb3dJZFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcbiAgICAgICAgICAgIHNjcm9sbExlZnQgICAgICAgOiBtZS5zY3JvbGxMZWZ0LFxuICAgICAgICAgICAgc2hvd0hlYWRlckZpbHRlcnM6IG1lLnNob3dIZWFkZXJGaWx0ZXJzLFxuICAgICAgICAgICAgc29ydGFibGUgICAgICAgICA6IG1lLnNvcnRhYmxlXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFRvb2xiYXIpO1xuIiwiaW1wb3J0IEJ1dHRvbiAgZnJvbSAnLi9CdXR0b24ubWpzJztcbmltcG9ydCBUb29sYmFyIGZyb20gJy4vVG9vbGJhci5tanMnO1xuXG5leHBvcnQge0J1dHRvbiwgVG9vbGJhcn07IiwiaW1wb3J0IEJhc2UgICAgICAgICAgIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICAgICAgIGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBPYnNlcnZhYmxlICAgICBmcm9tICcuLi9jb3JlL09ic2VydmFibGUubWpzJztcbmltcG9ydCB7aXNEZXNjcmlwdG9yfSBmcm9tICcuLi9jb3JlL0NvbmZpZ1N5bWJvbHMubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnNlbGVjdGlvbi5Nb2RlbFxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICogQG1peGVzIE5lby5jb3JlLk9ic2VydmFibGVcbiAqL1xuY2xhc3MgTW9kZWwgZXh0ZW5kcyBCYXNlIHtcbiAgICAvKipcbiAgICAgKiBUcnVlIGF1dG9tYXRpY2FsbHkgYXBwbGllcyB0aGUgY29yZS5PYnNlcnZhYmxlIG1peGluXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gb2JzZXJ2YWJsZT10cnVlXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBvYnNlcnZhYmxlID0gdHJ1ZVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uc2VsZWN0aW9uLk1vZGVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uc2VsZWN0aW9uLk1vZGVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3NlbGVjdGlvbi1tb2RlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdzZWxlY3Rpb24tbW9kZWwnLFxuICAgICAgICAvKipcbiAgICAgICAgICogUGxhY2Vob2xkZXIgZm9yIGV4dGVuZGVkIGNsYXNzZXMgdG8gYWRkIGEgY3VzdG9tIGNzcyBydWxlIHRvIHRoaXMgb3duZXIgY29tcG9uZW50XG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBjbHM9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbHM6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheX0gaXRlbXNfXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtc186IHtcbiAgICAgICAgICAgIFtpc0Rlc2NyaXB0b3JdOiB0cnVlLFxuICAgICAgICAgICAgY2xvbmUgICAgICAgICA6ICdzaGFsbG93JyxcbiAgICAgICAgICAgIGNsb25lT25HZXQgICAgOiAnbm9uZScsXG4gICAgICAgICAgICBpc0VxdWFsICAgICAgIDogKCkgPT4gZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZSAgICAgICAgIDogW11cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gc2VsZWN0ZWRDbHM9J3NlbGVjdGVkJ1xuICAgICAgICAgKi9cbiAgICAgICAgc2VsZWN0ZWRDbHM6ICduZW8tc2VsZWN0ZWQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2luZ2xlU2VsZWN0PXRydWVcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZVNlbGVjdDogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsbHkgc2F2ZXMgdGhlIHZpZXcgaWQsIGJ1dCB0aGUgZ2V0dGVyIHdpbGwgcmV0dXJuIHRoZSBtYXRjaGluZyBpbnN0YW5jZVxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHZpZXdfPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHZpZXdfOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0cmlnZ2VyZWQgYmVmb3JlIGdldHRpbmcgdGhlIHZhbHVlIG9mIHRoZSB2aWV3IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29tcG9uZW50LkJhc2V9XG4gICAgICovXG4gICAgYmVmb3JlR2V0Vmlldyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gTmVvLmdldENvbXBvbmVudCh0aGlzLl92aWV3KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdHJpZ2dlcmVkIGJlZm9yZSBzZXR0aW5nIHRoZSB2YWx1ZSBvZiB0aGUgdmlldyBjb25maWdcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB0aGUgdmlldyBpZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFZpZXcodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICYmIHZhbHVlLmlkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBhZGREb21MaXN0ZW5lcigpIHt9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbGVudF0gdHJ1ZSB0byBwcmV2ZW50IGEgdmRvbSB1cGRhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfFN0cmluZ1tdfSBpdGVtQ29sbGVjdGlvbj10aGlzLml0ZW1zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzZWxlY3RlZENsc11cbiAgICAgKi9cbiAgICBkZXNlbGVjdChpdGVtLCBzaWxlbnQsIGl0ZW1Db2xsZWN0aW9uPXRoaXMuaXRlbXMsIHNlbGVjdGVkQ2xzKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3ZpZXd9ID0gbWUsXG4gICAgICAgICAgICBub2RlO1xuXG4gICAgICAgIC8vIFdlIGhvbGQgdmRvbSBpZHMgZm9yIG5vdywgc28gYWxsIGluY29taW5nIHNlbGVjdGlvbnMgbXVzdCBiZSBjb252ZXJ0ZWQuXG4gICAgICAgIGl0ZW0gPSBpdGVtLmlzUmVjb3JkID8gdmlldy5nZXRJdGVtSWQoaXRlbSkgOiBOZW8uaXNPYmplY3QoaXRlbSkgPyBpdGVtLmlkIDogaXRlbTtcblxuICAgICAgICBpZiAoaXRlbUNvbGxlY3Rpb24uaW5jbHVkZXMoaXRlbSkpIHtcbiAgICAgICAgICAgIG5vZGUgPSB2aWV3LmdldFZkb21DaGlsZChpdGVtKTtcblxuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBub2RlLmNscyA9IE5lb0FycmF5LnJlbW92ZShub2RlLmNscyB8fCBbXSwgc2VsZWN0ZWRDbHMgfHwgbWUuc2VsZWN0ZWRDbHMpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlWydhcmlhLXNlbGVjdGVkJ11cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGl0ZW1Db2xsZWN0aW9uLCBpdGVtKTtcblxuICAgICAgICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgICAgICAgICB2aWV3LnVwZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgdmlldy5wYXJlbnQ/Lm9uRGVzZWxlY3Q/LigpOyAvLyBncmlkLkNvbnRhaW5lciAmIHRhYmxlLkNvbnRhaW5lclxuICAgICAgICAgICAgICAgIHZpZXcub25EZXNlbGVjdD8uKCk7XG5cbiAgICAgICAgICAgICAgICBtZS5maXJlKCdzZWxlY3Rpb25DaGFuZ2UnLCB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogaXRlbUNvbGxlY3Rpb25cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgICAgIG1lLmZpcmUoJ25vQ2hhbmdlJylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbGVudF0gdHJ1ZSB0byBwcmV2ZW50IGEgdmRvbSB1cGRhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfFN0cmluZ1tdfSBpdGVtQ29sbGVjdGlvbj10aGlzLml0ZW1zXG4gICAgICovXG4gICAgZGVzZWxlY3RBbGwoc2lsZW50LCBpdGVtQ29sbGVjdGlvbj10aGlzLml0ZW1zKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbXMgID0gWy4uLml0ZW1Db2xsZWN0aW9uXSxcbiAgICAgICAgICAgIHt2aWV3fSA9IG1lO1xuXG4gICAgICAgIGlmIChpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgbWUuZGVzZWxlY3QoaXRlbSwgdHJ1ZSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIXNpbGVudCAmJiBpdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmlldy51cGRhdGUoKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5maXJlKCdzZWxlY3Rpb25DaGFuZ2UnLCB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uOiB0aGlzLml0ZW1zXG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2UgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgICAgIG1lLmZpcmUoJ25vQ2hhbmdlJylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZGVzdHJveSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMudW5yZWdpc3RlcigpO1xuICAgICAgICBzdXBlci5kZXN0cm95KC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW1wb3J0YW50IGZvciBtYXBwaW5nIGxpc3RlbmVycyB0byB2aWV3IGNvbnRyb2xsZXJzXG4gICAgICogQHJldHVybnMge05lby5jb250cm9sbGVyLkNvbXBvbmVudHxudWxsfVxuICAgICAqL1xuICAgIGdldENvbnRyb2xsZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuZ2V0Q29udHJvbGxlcigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FycmF5fSB0aGlzLml0ZW1zXG4gICAgICovXG4gICAgZ2V0U2VsZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGhhc1NlbGVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMubGVuZ3RoID4gMFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGluIGNhc2UgdGhlIGl0ZW0gaXMgc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBpc1NlbGVjdGVkKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmluY2x1ZGVzKGlkKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBjb21wb25lbnRcbiAgICAgKi9cbiAgICByZWdpc3Rlcihjb21wb25lbnQpIHtcbiAgICAgICAgbGV0IG1lICA9IHRoaXMsXG4gICAgICAgICAgICBjbHMgPSBjb21wb25lbnQud3JhcHBlckNscyB8fCBbXTtcblxuICAgICAgICBpZiAobWUuY2xzICYmICFjbHMuaW5jbHVkZXMobWUuY2xzKSkge1xuICAgICAgICAgICAgY2xzLnB1c2gobWUuY2xzKTtcbiAgICAgICAgICAgIGNvbXBvbmVudC53cmFwcGVyQ2xzID0gY2xzXG4gICAgICAgIH1cblxuICAgICAgICBtZS52aWV3ID0gY29tcG9uZW50O1xuICAgICAgICBtZS5hZGREb21MaXN0ZW5lcigpO1xuXG4gICAgICAgIGNvbXBvbmVudC5maXJlKCdzZWxlY3Rpb25Nb2RlbENoYW5nZScsIHtcbiAgICAgICAgICAgIHZhbHVlOiBtZVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgcmVtb3ZlRG9tTGlzdGVuZXJzKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbXBvbmVudCAgICA9IG1lLnZpZXcsXG4gICAgICAgICAgICBkb21MaXN0ZW5lcnMgPSBbLi4uY29tcG9uZW50LmRvbUxpc3RlbmVyc107XG5cbiAgICAgICAgY29tcG9uZW50LmRvbUxpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IHtcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lci5zY29wZSA9PT0gbWUpIHtcbiAgICAgICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUoZG9tTGlzdGVuZXJzLCBsaXN0ZW5lcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29tcG9uZW50LmRvbUxpc3RlbmVycyA9IGRvbUxpc3RlbmVyc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fE9iamVjdFtdfFN0cmluZ1tdfSBpdGVtc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0W118U3RyaW5nW119IGl0ZW1Db2xsZWN0aW9uPXRoaXMuaXRlbXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NlbGVjdGVkQ2xzXVxuICAgICAqL1xuICAgIHNlbGVjdChpdGVtcywgaXRlbUNvbGxlY3Rpb249dGhpcy5pdGVtcywgc2VsZWN0ZWRDbHMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICAgICAgaXRlbXMgPSBbaXRlbXNdXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7dmlld30gID0gbWUsXG4gICAgICAgICAgICByZWNvcmRzID0gaXRlbXMubWFwKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmlzUmVjb3JkKSByZXR1cm4gaXRlbTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlY29yZElkID0gdmlldy5nZXRJdGVtUmVjb3JkSWQ/LihpdGVtKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiByZWNvcmRJZCAmJiB2aWV3LnN0b3JlPy5nZXQocmVjb3JkSWQpIHx8IGl0ZW1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFdlIGhvbGQgdmRvbSBpZHMgZm9yIG5vdywgc28gYWxsIGluY29taW5nIHNlbGVjdGlvbnMgbXVzdCBiZSBjb252ZXJ0ZWQuXG4gICAgICAgIGl0ZW1zID0gaXRlbXMubWFwKGl0ZW0gPT4gaXRlbS5pc1JlY29yZCA/IHZpZXcuZ2V0SXRlbUlkKGl0ZW0pIDogTmVvLmlzT2JqZWN0KGl0ZW0pID8gaXRlbS5pZCA6IGl0ZW0pO1xuXG4gICAgICAgIGlmICghTmVvLmlzRXF1YWwoaXRlbUNvbGxlY3Rpb24sIGl0ZW1zKSkge1xuICAgICAgICAgICAgaWYgKG1lLnNpbmdsZVNlbGVjdCAmJiBpdGVtQ29sbGVjdGlvbiA9PT0gbWUuaXRlbXMpIHtcbiAgICAgICAgICAgICAgICBtZS5kZXNlbGVjdEFsbCh0cnVlLCBpdGVtQ29sbGVjdGlvbilcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXRlbXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgICAgICBub2RlID0gdmlldy5nZXRWZG9tQ2hpbGQobm9kZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmNscyA9IE5lb0FycmF5LmFkZChub2RlLmNscyB8fCBbXSwgc2VsZWN0ZWRDbHMgfHwgbWUuc2VsZWN0ZWRDbHMpO1xuICAgICAgICAgICAgICAgICAgICBub2RlWydhcmlhLXNlbGVjdGVkJ10gPSB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIE5lb0FycmF5LmFkZChpdGVtQ29sbGVjdGlvbiwgaXRlbXMpO1xuXG4gICAgICAgICAgICBpZiAoIXZpZXcuc2lsZW50U2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgdmlldy51cGRhdGUoKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2aWV3LnBhcmVudD8ub25TZWxlY3Q/LihpdGVtcyk7IC8vIGdyaWQuQ29udGFpbmVyICYgdGFibGUuQ29udGFpbmVyXG4gICAgICAgICAgICB2aWV3Lm9uU2VsZWN0Py4oaXRlbXMpO1xuXG4gICAgICAgICAgICB2aWV3LmZpcmUoJ3NlbGVjdCcsIHtcbiAgICAgICAgICAgICAgICByZWNvcmRzLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogaXRlbUNvbGxlY3Rpb25cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS5maXJlKCdzZWxlY3Rpb25DaGFuZ2UnLCB7XG4gICAgICAgICAgICAgICAgcmVjb3JkcyxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb246IGl0ZW1Db2xsZWN0aW9uXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWUuZmlyZSgnbm9DaGFuZ2UnKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cbiAgICAgKi9cbiAgICB0b2dnbGVTZWxlY3Rpb24oaXRlbSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5pc1NlbGVjdGVkKGl0ZW0pKSB7XG4gICAgICAgICAgICBtZS5kZXNlbGVjdChpdGVtKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUuc2VsZWN0KGl0ZW0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW1zID0gKG1lLml0ZW1zIHx8IFtdKS5tYXAoaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKE5lby5pc1JlY29yZChpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS50b0pTT04oKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXG4gICAgICAgICAgICBpdGVtcyxcbiAgICAgICAgICAgIHNlbGVjdGVkQ2xzIDogbWUuc2VsZWN0ZWRDbHMsXG4gICAgICAgICAgICBzaW5nbGVTZWxlY3Q6IG1lLnNpbmdsZVNlbGVjdFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICB1bnJlZ2lzdGVyKCkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt2aWV3fSA9IG1lO1xuXG4gICAgICAgIGlmICghdmlldy5pc0Rlc3Ryb3lpbmcpIHtcbiAgICAgICAgICAgIGxldCBjbHMgPSB2aWV3LndyYXBwZXJDbHMgfHwgW107XG5cbiAgICAgICAgICAgIGlmIChtZS5jbHMgJiYgY2xzLmluY2x1ZGVzKG1lLmNscykpIHtcbiAgICAgICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUoY2xzLCBtZS5jbHMpO1xuICAgICAgICAgICAgICAgIHZpZXcud3JhcHBlckNscyA9IGNsc1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5kZXNlbGVjdEFsbCgpO1xuXG4gICAgICAgICAgICBtZS5yZW1vdmVEb21MaXN0ZW5lcnMoKVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhNb2RlbCk7XG4iLCJpbXBvcnQgTW9kZWwgICAgZnJvbSAnLi4vTW9kZWwubWpzJztcbmltcG9ydCBOZW9BcnJheSBmcm9tICcuLi8uLi91dGlsL0FycmF5Lm1qcyc7XG5cbi8qKlxuICogQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgYWxsIGdyaWQgcmVsYXRlZCBzZWxlY3Rpb24gbW9kZWxzXG4gKiBAY2xhc3MgTmVvLnNlbGVjdGlvbi5ncmlkLkJhc2VNb2RlbFxuICogQGV4dGVuZHMgTmVvLnNlbGVjdGlvbi5Nb2RlbFxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIEJhc2VNb2RlbCBleHRlbmRzIE1vZGVsIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5zZWxlY3Rpb24uZ3JpZC5CYXNlTW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5zZWxlY3Rpb24uZ3JpZC5CYXNlTW9kZWwnLFxuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcmluZyB0aGUgY29sdW1uIGRhdGFGaWVsZHNcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IHNlbGVjdGVkQ29sdW1ucz1bXVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZWN0ZWRDb2x1bW5zOiBbXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3JpbmcgdGhlIHJlY29yZCBpZHNcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyW118U3RyaW5nW119IHNlbGVjdGVkUm93cz1bXVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzZWxlY3RlZFJvd3M6IFtdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXRcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gZGF0YUZpZWxkc1xuICAgICAqL1xuICAgIGdldCBkYXRhRmllbGRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LnBhcmVudC5jb2x1bW5zLml0ZW1zLm1hcChjb2x1bW4gPT4gY29sdW1uLmRhdGFGaWVsZClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdIHRydWUgdG8gcHJldmVudCBhIHZkb20gdXBkYXRlXG4gICAgICovXG4gICAgZGVzZWxlY3RBbGxSb3dzKHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW1zICA9IFsuLi5tZS5zZWxlY3RlZFJvd3NdLFxuICAgICAgICAgICAge3ZpZXd9ID0gbWU7XG5cbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBtZS5kZXNlbGVjdFJvdyhpdGVtLCB0cnVlKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghc2lsZW50ICYmIGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2aWV3LnVwZGF0ZSgpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLmZpcmUoJ3NlbGVjdGlvbkNoYW5nZScsIHtcbiAgICAgICAgICAgICAgICByZWNvcmRzICA6IG1lLnNlbGVjdGVkUm93cy5tYXAoaWQgPT4gdmlldy5zdG9yZS5nZXQoaWQpKSxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb246IG1lLnNlbGVjdGVkUm93c1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgICBtZS5maXJlKCdub0NoYW5nZScpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHJlY29yZElkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICBbc2lsZW50PWZhbHNlXVxuICAgICAqL1xuICAgIGRlc2VsZWN0Um93KHJlY29yZElkLCBzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3ZpZXd9ICA9IG1lLFxuICAgICAgICAgICAge3N0b3JlfSA9IHZpZXcsXG4gICAgICAgICAgICByZWNvcmQgID0gc3RvcmUuZ2V0KHJlY29yZElkKSxcbiAgICAgICAgICAgIHJvd0lkICAgPSB2aWV3LmdldFJvd0lkKHN0b3JlLmluZGV4T2YocmVjb3JkKSksXG4gICAgICAgICAgICBub2RlICAgID0gdmlldy5nZXRWZG9tQ2hpbGQocm93SWQpO1xuXG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBub2RlLmNscyA9IE5lb0FycmF5LnJlbW92ZShub2RlLmNscyB8fCBbXSwgbWUuc2VsZWN0ZWRDbHMpO1xuICAgICAgICAgICAgZGVsZXRlIG5vZGVbJ2FyaWEtc2VsZWN0ZWQnXVxuICAgICAgICB9XG5cbiAgICAgICAgbWUuc2VsZWN0ZWRSb3dzID0gW3JlY29yZElkXTtcblxuICAgICAgICAhc2lsZW50ICYmIHZpZXcudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHJlY29yZCBmb3IgYSBnaXZlbiBldmVudCBwYXRoXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gcGF0aFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8U3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgZ2V0UmVjb3JkKHBhdGgpIHtcbiAgICAgICAgbGV0IG5vZGUsIHJvd0luZGV4O1xuXG4gICAgICAgIGZvciAobm9kZSBvZiBwYXRoKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5hcmlhLnJvd2luZGV4KSB7XG4gICAgICAgICAgICAgICAgcm93SW5kZXggPSBwYXJzZUludChub2RlLmFyaWEucm93aW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgLy8gYXJpYS1yb3dpbmRleCBpcyAxIGJhc2VkICYgYWxzbyBpbmNsdWRlcyB0aGUgaGVhZGVyXG4gICAgICAgICAgICAgICAgcm93SW5kZXggLT0gMjtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXcuc3RvcmUuZ2V0QXQocm93SW5kZXgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UmVjb3JkfSByZWNvcmRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNBbm5vdGF0aW9ucyhyZWNvcmQpIHtcbiAgICAgICAgcmV0dXJuICEhT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyZWNvcmQuX19wcm90b19fLCB0aGlzLnZpZXcuc2VsZWN0ZWRSZWNvcmRGaWVsZClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYW4gZXZlbnQgcGF0aCBjb250YWlucyBhIGdyaWQgY2VsbCBlZGl0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5wYXRoXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzRWRpdG9yRm9jdXMoe3BhdGh9KSB7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBwYXRoKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5jbHM/LmluY2x1ZGVzKCduZW8tZ3JpZC1lZGl0b3InKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YUZpZWxkXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaW4gY2FzZSB0aGUgY29sdW1uIGlzIHNlbGVjdGVkXG4gICAgICovXG4gICAgaXNTZWxlY3RlZENvbHVtbihkYXRhRmllbGQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRDb2x1bW5zLmluY2x1ZGVzKGRhdGFGaWVsZClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHJlY29yZElkXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaW4gY2FzZSB0aGUgcm93IGlzIHNlbGVjdGVkXG4gICAgICovXG4gICAgaXNTZWxlY3RlZFJvdyhyZWNvcmRJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZFJvd3MuaW5jbHVkZXMocmVjb3JkSWQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSByZWNvcmRJZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgW3NpbGVudD1mYWxzZV1cbiAgICAgKi9cbiAgICBzZWxlY3RSb3cocmVjb3JkSWQsIHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7dmlld30gID0gbWUsXG4gICAgICAgICAgICB7c3RvcmV9ID0gdmlldyxcbiAgICAgICAgICAgIHJlY29yZCAgPSBzdG9yZS5nZXQocmVjb3JkSWQpLFxuICAgICAgICAgICAgcm93SWQgICA9IHZpZXcuZ2V0Um93SWQoc3RvcmUuaW5kZXhPZihyZWNvcmQpKSxcbiAgICAgICAgICAgIG5vZGUgICAgPSB2aWV3LmdldFZkb21DaGlsZChyb3dJZCk7XG5cbiAgICAgICAgaWYgKG1lLnNpbmdsZVNlbGVjdCkge1xuICAgICAgICAgICAgbWUuZGVzZWxlY3RBbGxSb3dzKHRydWUpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgbm9kZS5jbHMgPSBOZW9BcnJheS5hZGQobm9kZS5jbHMgfHwgW10sIG1lLnNlbGVjdGVkQ2xzKTtcbiAgICAgICAgICAgIG5vZGVbJ2FyaWEtc2VsZWN0ZWQnXSA9IHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnNlbGVjdGVkUm93cyA9IFtyZWNvcmRJZF07XG5cbiAgICAgICAgIXNpbGVudCAmJiB2aWV3LnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSByZWNvcmRJZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgW3NpbGVudD1mYWxzZV1cbiAgICAgKi9cbiAgICB0b2dnbGVSb3dTZWxlY3Rpb24ocmVjb3JkSWQsIHNpbGVudD1mYWxzZSkge1xuICAgICAgICB0aGlzW3RoaXMuaXNTZWxlY3RlZFJvdyhyZWNvcmRJZCkgPyAnZGVzZWxlY3RSb3cnIDogJ3NlbGVjdFJvdyddKHJlY29yZElkLCBzaWxlbnQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcbiAgICAgICAgICAgIHNlbGVjdGVkQ29sdW1uczogdGhpcy5zZWxlY3RlZENvbHVtbnMsXG4gICAgICAgICAgICBzZWxlY3RlZFJvd3MgICA6IHRoaXMuc2VsZWN0ZWRSb3dzXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHVucmVnaXN0ZXIoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY291bnRSb3dzID0gbWUuc2VsZWN0ZWRSb3dzLmxlbmd0aDtcblxuICAgICAgICBtZS5zZWxlY3RlZFJvd3MgPSBbXTtcblxuICAgICAgICBjb3VudFJvd3MgPiAwICYmIG1lLnZpZXcuY3JlYXRlVmlld0RhdGEoKTtcblxuICAgICAgICBzdXBlci51bnJlZ2lzdGVyKClcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEJhc2VNb2RlbCk7XG4iLCJpbXBvcnQgQmFzZU1vZGVsIGZyb20gJy4vQmFzZU1vZGVsLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5zZWxlY3Rpb24uZ3JpZC5Sb3dNb2RlbFxuICogQGV4dGVuZHMgTmVvLnNlbGVjdGlvbi5ncmlkLkJhc2VNb2RlbFxuICovXG5jbGFzcyBSb3dNb2RlbCBleHRlbmRzIEJhc2VNb2RlbCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uc2VsZWN0aW9uLmdyaWQuUm93TW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5zZWxlY3Rpb24uZ3JpZC5Sb3dNb2RlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdzZWxlY3Rpb24tZ3JpZC1yb3dtb2RlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdzZWxlY3Rpb24tZ3JpZC1yb3dtb2RlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNscz0nbmVvLXNlbGVjdGlvbi1yb3dtb2RlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xzOiAnbmVvLXNlbGVjdGlvbi1yb3dtb2RlbCdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGFkZERvbUxpc3RlbmVyKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnZpZXcucGFyZW50Lm9uKCdyb3dDbGljaycsIG1lLm9uUm93Q2xpY2ssIG1lKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICovXG4gICAgZGVzdHJveSguLi5hcmdzKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUudmlldy5wYXJlbnQudW4oJ3Jvd0NsaWNrJywgbWUub25Sb3dDbGljaywgbWUpO1xuXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koLi4uYXJncylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uS2V5RG93bkRvd24oZGF0YSkge1xuICAgICAgICAhdGhpcy5oYXNFZGl0b3JGb2N1cyhkYXRhKSAmJiB0aGlzLm9uTmF2S2V5Um93KDEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbktleURvd25VcChkYXRhKSB7XG4gICAgICAgICF0aGlzLmhhc0VkaXRvckZvY3VzKGRhdGEpICYmIHRoaXMub25OYXZLZXlSb3coLTEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0ZXBcbiAgICAgKi9cbiAgICBvbk5hdktleVJvdyhzdGVwKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3ZpZXd9ICAgICAgID0gbWUsXG4gICAgICAgICAgICB7c3RvcmV9ICAgICAgPSB2aWV3LFxuICAgICAgICAgICAgY291bnRSZWNvcmRzID0gc3RvcmUuZ2V0Q291bnQoKSxcbiAgICAgICAgICAgIGtleVByb3BlcnR5ICA9IHN0b3JlLmdldEtleVByb3BlcnR5KCksXG4gICAgICAgICAgICByZWNvcmRJZCAgICAgPSBtZS5zZWxlY3RlZFJvd3NbMF0gfHwgc3RvcmUuZ2V0QXQoMClba2V5UHJvcGVydHldLFxuICAgICAgICAgICAgcmVjb3JkICAgICAgID0gc3RvcmUuZ2V0KHJlY29yZElkKSxcbiAgICAgICAgICAgIGluZGV4ICAgICAgICA9IHN0b3JlLmluZGV4T2YocmVjb3JkKSxcbiAgICAgICAgICAgIG5ld0luZGV4ICAgICA9IChpbmRleCArIHN0ZXApICUgY291bnRSZWNvcmRzO1xuXG4gICAgICAgIHdoaWxlIChuZXdJbmRleCA8IDApIHtcbiAgICAgICAgICAgIG5ld0luZGV4ICs9IGNvdW50UmVjb3Jkc1xuICAgICAgICB9XG5cbiAgICAgICAgcmVjb3JkID0gc3RvcmUuZ2V0QXQobmV3SW5kZXgpO1xuXG4gICAgICAgIGlmIChtZS5oYXNBbm5vdGF0aW9ucyhyZWNvcmQpKSB7XG4gICAgICAgICAgICBtZS51cGRhdGVBbm5vdGF0aW9ucyhyZWNvcmQpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWNvcmRJZCA9IHJlY29yZFtrZXlQcm9wZXJ0eV07XG5cbiAgICAgICAgICAgIGlmIChyZWNvcmRJZCkge1xuICAgICAgICAgICAgICAgIG1lLnNlbGVjdFJvdyhyZWNvcmRJZCk7XG5cbiAgICAgICAgICAgICAgICB2aWV3LnNjcm9sbEJ5Um93cyhpbmRleCwgc3RlcCk7XG4gICAgICAgICAgICAgICAgdmlldy5maXJlKCdzZWxlY3QnLCB7cmVjb3JkfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Sb3dDbGljayh7ZGF0YX0pIHtcbiAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7dmlld30gPSBtZSxcbiAgICAgICAgICAgIHJlY29yZCA9IG1lLmdldFJlY29yZChkYXRhLnBhdGgpLFxuICAgICAgICAgICAgcmVjb3JkSWQ7XG5cbiAgICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICAgICAgaWYgKG1lLmhhc0Fubm90YXRpb25zKHJlY29yZCkpIHtcbiAgICAgICAgICAgICAgICBtZS51cGRhdGVBbm5vdGF0aW9ucyhyZWNvcmQpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlY29yZElkID0gcmVjb3JkW3ZpZXcuc3RvcmUuZ2V0S2V5UHJvcGVydHkoKV07XG5cbiAgICAgICAgICAgICAgICBtZS50b2dnbGVSb3dTZWxlY3Rpb24ocmVjb3JkSWQpO1xuXG4gICAgICAgICAgICAgICAgdmlldy5maXJlKG1lLmlzU2VsZWN0ZWRSb3cocmVjb3JkSWQpID8gJ3NlbGVjdCcgOiAnZGVzZWxlY3QnLCB7cmVjb3JkfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBjb21wb25lbnRcbiAgICAgKi9cbiAgICByZWdpc3Rlcihjb21wb25lbnQpIHtcbiAgICAgICAgc3VwZXIucmVnaXN0ZXIoY29tcG9uZW50KTtcblxuICAgICAgICBsZXQge2lkLCB2aWV3fSA9IHRoaXM7XG5cbiAgICAgICAgdmlldy5rZXlzPy5fa2V5cy5wdXNoKFxuICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duRG93bicsIGtleTogJ0Rvd24nLCBzY29wZTogaWR9LFxuICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duVXAnLCAgIGtleTogJ1VwJywgICBzY29wZTogaWR9XG4gICAgICAgIClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHVucmVnaXN0ZXIoKSB7XG4gICAgICAgIGxldCB7aWQsIHZpZXd9ID0gdGhpcztcblxuICAgICAgICB2aWV3LmtleXM/LnJlbW92ZUtleXMoW1xuICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duRG93bicsIGtleTogJ0Rvd24nLCBzY29wZTogaWR9LFxuICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duVXAnLCAgIGtleTogJ1VwJywgICBzY29wZTogaWR9XG4gICAgICAgIF0pO1xuXG4gICAgICAgIHN1cGVyLnVucmVnaXN0ZXIoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UmVjb3JkfSByZWNvcmRcbiAgICAgKi9cbiAgICB1cGRhdGVBbm5vdGF0aW9ucyhyZWNvcmQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3ZpZXd9ICAgICAgICAgICA9IG1lLFxuICAgICAgICAgICAge3N0b3JlfSAgICAgICAgICA9IHZpZXcsXG4gICAgICAgICAgICByZWNvcmRJZCAgICAgICAgID0gcmVjb3JkW3N0b3JlLmdldEtleVByb3BlcnR5KCldLFxuICAgICAgICAgICAgaXNTZWxlY3RlZCAgICAgICA9IG1lLmlzU2VsZWN0ZWRSb3cocmVjb3JkSWQpLFxuICAgICAgICAgICAgYW5ub3RhdGlvbnNGaWVsZCA9IHZpZXcuc2VsZWN0ZWRSZWNvcmRGaWVsZDtcblxuICAgICAgICBpZiAobWUuc2luZ2xlU2VsZWN0KSB7XG4gICAgICAgICAgICBpZiAoaXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIHJlY29yZFthbm5vdGF0aW9uc0ZpZWxkXSA9IGZhbHNlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lLnNlbGVjdGVkUm93cy5mb3JFYWNoKHJlY29yZElkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgY2FuIHVzZSBzZXRTaWxlbnQoKSwgc2luY2UgdGhlIGxhc3QgY2hhbmdlIHdpbGwgdHJpZ2dlciBhIHZpZXcgdXBkYXRlXG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLmdldChyZWNvcmRJZCkuc2V0U2lsZW50KHtbYW5ub3RhdGlvbnNGaWVsZF06IGZhbHNlfSlcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJlY29yZFthbm5vdGF0aW9uc0ZpZWxkXSA9IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlY29yZFthbm5vdGF0aW9uc0ZpZWxkXSA9ICFyZWNvcmRbYW5ub3RhdGlvbnNGaWVsZF1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoUm93TW9kZWwpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==