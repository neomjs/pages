"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_grid_Container_mjs"],{

/***/ "./src/grid/Container.mjs":
/*!********************************!*\
  !*** ./src/grid/Container.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _View_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./View.mjs */ "./src/grid/View.mjs");
/* harmony import */ var _ScrollManager_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ScrollManager.mjs */ "./src/grid/ScrollManager.mjs");
/* harmony import */ var _data_Store_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../data/Store.mjs */ "./src/data/Store.mjs");
/* harmony import */ var _VerticalScrollbar_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./VerticalScrollbar.mjs */ "./src/grid/VerticalScrollbar.mjs");
/* harmony import */ var _header_export_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./header/_export.mjs */ "./src/grid/header/_export.mjs");








/**
 * @class Neo.grid.Container
 * @extends Neo.container.Base
 */
class GridContainer extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @member {Object} delayable
     * @protected
     * @static
     */
    static delayable = {
        onResize: {type: 'buffer', timer: 300}
    }

    static config = {
        /**
         * @member {String} className='Neo.grid.Container'
         * @protected
         */
        className: 'Neo.grid.Container',
        /**
         * @member {String} ntype='grid-container'
         * @protected
         */
        ntype: 'grid-container',
        /**
         * @member {String[]} baseCls=['neo-grid-container']
         * @protected
         */
        baseCls: ['neo-grid-container'],
        /**
         * true uses grid.plugin.CellEditing
         * @member {Boolean} cellEditing_=false
         */
        cellEditing_: false,
        /**
         * Default configs for each column
         * @member {Object} columnDefaults=null
         */
        columnDefaults: null,
        /**
         * @member {Object[]} columns_=[]
         */
        columns_: [],
        /**
         * Configs for Neo.grid.header.Toolbar
         * @member {Object|null} [headerToolbarConfig=null]
         */
        headerToolbarConfig: null,
        /**
         * @member {String|null} headerToolbarId_=null
         */
        headerToolbarId_: null,
        /**
         * @member {String} layout='base'
         */
        layout: 'base',
        /**
         * @member {String} role='grid'
         */
        role: 'grid',
        /**
         * Number in px
         * @member {Number} rowHeight_=32
         */
        rowHeight_: 32,
        /**
         * @member {Neo.grid.Scrollbar|null} scrollbar=null
         * @protected
         */
        scrollbar: null,
        /**
         * @member {Boolean} showHeaderFilters_=false
         */
        showHeaderFilters_: false,
        /**
         * @member {Boolean} sortable_=true
         */
        sortable_: true,
        /**
         * @member {Neo.data.Store} store_=null
         */
        store_: null,
        /**
         * Configs for Neo.grid.View
         * @member {Object|null} [viewConfig=null]
         */
        viewConfig: null,
        /**
         * @member {String|null} viewId_=null
         * @protected
         */
        viewId_: null,
        /**
         * @member {Array|null} items=null
         * @protected
         */
        items: null,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {cls: ['neo-grid-wrapper'], cn: [
            {'aria-rowcount': 1, cn: []} // aria-rowcount includes the column headers
        ]}
    }

    /**
     * We do not need the first event to trigger logic, since afterSetMounted() handles this
     * @member {Boolean} initialResizeEvent=true
     * @protected
     */
    initialResizeEvent = true
    /**
     * @member {Neo.grid.ScrollManager|null} scrollManager=null
     * @protected
     */
    scrollManager = null

    /**
     * Convenience method to access the Neo.grid.header.Toolbar
     * @returns {Neo.grid.header.Toolbar|null}
     */
    get headerToolbar() {
        return Neo.getComponent(this.headerToolbarId) || Neo.get(this.headerToolbarId)
    }

    /**
     * Convenience method to access the Neo.grid.View
     * @returns {Neo.grid.View|null}
     */
    get view() {
        return Neo.getComponent(this.viewId) || Neo.get(this.viewId)
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this,
            {appName, rowHeight, store, windowId} = me;

        me.headerToolbarId = Neo.getId('grid-header-toolbar');
        me.viewId          = Neo.getId('grid-view');

        me.items = [{
            module           : _header_export_mjs__WEBPACK_IMPORTED_MODULE_6__.Toolbar,
            id               : me.headerToolbarId,
            showHeaderFilters: me.showHeaderFilters,
            sortable         : me.sortable,
            ...me.headerToolbarConfig
        }, {
            module       : _View_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            flex         : 1,
            gridContainer: me,
            id           : me.viewId,
            rowHeight,
            store,
            ...me.viewConfig
        }];

        me.scrollbar = Neo.create({
            module  : _VerticalScrollbar_mjs__WEBPACK_IMPORTED_MODULE_5__["default"],
            appName,
            parentId: me.id,
            rowHeight,
            store,
            windowId
        });

        me.vdom.cn.push(me.scrollbar.createVdomReference())

        me.vdom.id = me.getWrapperId();

        me.createColumns(me.columns);

        me.addDomListeners({
            resize: me.onResize,
            scope : me
        })
    }

    /**
     * @param {Boolean} mounted
     * @protected
     */
    async addResizeObserver(mounted) {
        let me             = this,
            {windowId}     = me,
            ResizeObserver = await Neo.currentWorker.getAddon('ResizeObserver', windowId),
            resizeParams   = {id: me.id, windowId};

        if (mounted) {
            ResizeObserver.register(resizeParams);
            await me.passSizeToView()
        } else {
            me.initialResizeEvent = true;
            ResizeObserver.unregister(resizeParams)
        }
    }

    /**
     * Triggered after the cellEditing config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetCellEditing(value, oldValue) {
        if (value) {
            Promise.all(/*! import() */[__webpack_require__.e("vendors-src_table_plugin_CellEditing_mjs"), __webpack_require__.e("src_grid_plugin_CellEditing_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ./plugin/CellEditing.mjs */ "./src/grid/plugin/CellEditing.mjs")).then(module => {
                let me                  = this,
                    {appName, windowId} = me,
                    plugins             = me.plugins || [];

                plugins.push({
                    module : module.default,
                    appName,
                    windowId
                });

                me.plugins = plugins
            })
        }
    }

    /**
     * Triggered after the columns config got changed
     * @param {Object[]|null} value
     * @param {Object[]|null} oldValue
     * @protected
     */
    async afterSetColumns(value, oldValue) {
        if (oldValue?.length > 0) {
            let me              = this,
                {headerToolbar} = me;

            if (headerToolbar) {
                headerToolbar.items = value;
                headerToolbar.createItems()
            }

            await me.timeout(50);

            await me.passSizeToView();

            me.view?.createViewData()
        }
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);
        oldValue !== undefined && this.addResizeObserver(value)
    }

    /**
     * Triggered after the rowHeight config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetRowHeight(value, oldValue) {
        if (value > 0) {
            let {scrollbar, view} = this;

            if (scrollbar) {
                scrollbar.rowHeight = value
            }

            if (view) {
                view.rowHeight = value
            }
        }
    }

    /**
     * Triggered after the showHeaderFilters config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowHeaderFilters(value, oldValue) {
        if (oldValue !== undefined) {
            this.headerToolbar.showHeaderFilters = value
        }
    }

    /**
     * Triggered after the sortable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetSortable(value, oldValue) {
        if (oldValue !== undefined) {
            this.headerToolbar.sortable = value
        }
    }

    /**
     * Triggered before the columns config gets changed.
     * @param {Object[]} value
     * @param {Object[]} oldValue
     * @protected
     */
    beforeSetColumns(value, oldValue) {
        if (this.configsApplied) {
            return this.createColumns(value)
        }

        return value
    }

    /**
     * Triggered before the headerToolbarId config gets changed.
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetHeaderToolbarId(value, oldValue) {
        return value || oldValue
    }

    /**
     * Triggered before the store config gets changed.
     * @param {Neo.data.Store} value
     * @param {Neo.data.Store} oldValue
     * @protected
     */
    beforeSetStore(value, oldValue) {
        oldValue?.destroy();

        if (value) {
            let me = this,

                listeners = {
                    filter      : me.onStoreFilter,
                    load        : me.onStoreLoad,
                    recordChange: me.onStoreRecordChange,
                    scope       : me
                };

            if (value instanceof _data_Store_mjs__WEBPACK_IMPORTED_MODULE_4__["default"]) {
                value.on(listeners);
                value.getCount() > 0 && me.onStoreLoad(value.items)
            } else {
                value = _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, _data_Store_mjs__WEBPACK_IMPORTED_MODULE_4__["default"], {
                    listeners
                })
            }

            // in case we dynamically change the store, the view needs to get the new reference
            if (me.view) {
                me.view.store = value
            }
        }

        return value
    }

    /**
     * Triggered before the viewId config gets changed.
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetViewId(value, oldValue) {
        return value || oldValue
    }

    /**
     * In case you want to update multiple existing records in parallel,
     * using this method is faster than updating each record one by one.
     * At least until we introduce row based vdom updates.
     * @param {Object[]} records
     */
    bulkUpdateRecords(records) {
        let {store, view} = this,
            {keyProperty} = store;

        if (view) {
            view.silentVdomUpdate = true;

            records.forEach(item => {
                store.get(item[keyProperty])?.set(item)
            });

            view.silentVdomUpdate = false;

            view.update()
        }
    }

    /**
     * @param {Object[]} columns
     * @returns {*}
     */
    createColumns(columns) {
        let me               = this,
            {columnDefaults} = me,
            sorters          = me.store?.sorters,
            renderer;

        if (!columns || !columns.length) {
            Neo.logError('Attempting to create a grid.Container without defined columns', me.id);
        }

        columns.forEach(column => {
            renderer = column.renderer;

            columnDefaults && Neo.assignDefaults(column, columnDefaults);

            if (column.dock && !column.width) {
                Neo.logError('Attempting to create a docked column without a defined width', column, me.id);
            }

            if (renderer && Neo.isString(renderer) && me[renderer]) {
                column.renderer = me[renderer]
            }

            if (sorters?.[0]) {
                if (column.dataField === sorters[0].property) {
                    column.isSorted = sorters[0].direction
                }
            }

            column.listeners = {
                sort : me.onSortColumn,
                scope: me
            }
        });

        me.items[0].items = columns;

        return columns
    }

    /**
     * @param {Array} inputData
     */
    createViewData(inputData) {
        let me = this;

        me.getVdomRoot()['aria-rowcount'] = inputData.length + 2; // 1 based & the header row counts as well
        me.update();

        me.view.createViewData()
    }

    /**
     * @param args
     */
    destroy(...args) {
        let me = this;

        me.scrollManager.destroy();

        me.mounted && Neo.main.addon.ResizeObserver.unregister({
            id      : me.id,
            windowId: me.windowId
        });

        super.destroy(...args)
    }

    /**
     * @override
     * @returns {*}
     */
    getVdomRoot() {
        return this.vdom.cn[0]
    }

    /**
     * @override
     * @returns {Neo.vdom.VNode}
     */
    getVnodeRoot() {
        return this.vnode.childNodes[0]
    }

    /**
     * @returns {String}
     */
    getWrapperId() {
        return `${this.id}__wrapper`
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me = this;

        me.scrollManager = Neo.create({
            module       : _ScrollManager_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
            gridContainer: me,
            gridView     : me.view
        })
    }

    /**
     * @param {Object} data
     */
    async onResize(data) {
        let me = this;

        if (!me.initialResizeEvent) {
            await me.passSizeToView(true);

            me.view.updateMountedAndVisibleColumns();

            await me.headerToolbar.passSizeToView()
        } else {
            me.initialResizeEvent = false
        }
    }

    /**
     * @param {Object} opts
     * @param {String} opts.direction
     * @param {String} opts.property
     * @protected
     */
    onSortColumn(opts) {
        let me = this;

        me.store.sort(opts);
        me.removeSortingCss(opts.property);
        me.onStoreLoad(me.store.items)
    }

    /**
     *
     */
    onStoreFilter() {
        this.onStoreLoad(this.store.items)
    }

    /**
     * @param {Object[]} data
     * @protected
     */
    onStoreLoad(data) {
        let me = this;

        if (me.rendered) {
            me.createViewData(data);

            me.timeout(50).then(() => {
                Neo.main.DomAccess.scrollTo({
                    direction: 'top',
                    id       : me.view.vdom.id,
                    value    : 0
                })
            })

            if (me.store.sorters.length < 1) {
                me.removeSortingCss()
            }
        }
    }

    /**
     * Gets triggered after changing the value of a record field.
     * E.g. myRecord.foo = 'bar';
     * @param {Object} opts
     * @param {String} opts.field The name of the field which got changed
     * @param {Neo.data.Model} opts.model The model instance of the changed record
     * @param {*} opts.oldValue
     * @param {Object} opts.record
     * @param {*} opts.value
     */
    onStoreRecordChange(opts) {
        this.view.onStoreRecordChange(opts)
    }

    /**
     * @param {Boolean} silent=false
     * @returns {Promise<void>}
     */
    async passSizeToView(silent=false) {
        let me                          = this,
            [containerRect, headerRect] = await me.getDomRect([me.id, me.headerToolbarId]);

        // delay for slow connections, where the container-sizing is not done yet
        if (containerRect.height === headerRect.height) {
            await me.timeout(100);
            await me.passSizeToView(silent)
        } else {
            me.view[silent ? 'setSilent' : 'set']({
                availableHeight: containerRect.height - headerRect.height,
                containerWidth : containerRect.width
            })
        }
    }

    /**
     * @param {String} dataField
     * @protected
     */
    removeSortingCss(dataField) {
        this.headerToolbar.items.forEach(column => {
            if (column.dataField !== dataField) {
                column.removeSortingCss()
            }
        })
    }

    /**
     * Used for keyboard navigation (selection models)
     * @param {Number} index
     * @param {Number} step
     */
    scrollByColumns(index, step) {
        let me           = this,
            {view}       = me,
            {columnPositions, containerWidth, mountedColumns, visibleColumns} = view,
            countColumns = columnPositions.getCount(),
            newIndex     = index + step,
            column, mounted, scrollLeft, visible;

        if (newIndex >= countColumns) {
            newIndex %= countColumns;
            step     = newIndex - index
        }

        while (newIndex < 0) {
            newIndex += countColumns;
            step     += countColumns
        }

        mounted = newIndex >= mountedColumns[0] && newIndex <= mountedColumns[1];

        // Not using >= or <=, since the first / last column might not be fully visible
        visible = newIndex > visibleColumns[0] && newIndex < visibleColumns[1];

        if (!visible) {
            // Leaving the mounted area will re-calculate the visibleColumns for us
            if (mounted) {
                visibleColumns[0] += step;
                visibleColumns[1] += step
            }

            column = columnPositions.getAt(newIndex);

            if (step < 0) {
                scrollLeft = column.x
            } else {
                scrollLeft = column.x - containerWidth + column.width
            }

            Neo.main.DomAccess.scrollTo({
                direction: 'left',
                id       : me.id,
                value    : scrollLeft,
                windowId : me.windowId
            })
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(GridContainer));


/***/ }),

/***/ "./src/grid/ScrollManager.mjs":
/*!************************************!*\
  !*** ./src/grid/ScrollManager.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.grid.ScrollManager
 * @extends Neo.core.Base
 */
class ScrollManager extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.grid.ScrollManager'
         * @protected
         */
        className: 'Neo.grid.ScrollManager',
        /**
         * @member {Number} scrollLeft_=0
         * @protected
         */
        scrollLeft_: 0,
        /**
         * @member {Number} scrollTop_=0
         * @protected
         */
        scrollTop_: 0
    }

    /**
     * @member {Neo.grid.Container|null} gridContainer=null
     * @protected
     */
    gridContainer = null
    /**
     * @member {Neo.grid.View|null} gridView=null
     * @protected
     */
    gridView = null
    /**
     * Storing touchmove position for mobile envs
     * @member {Number} lastTouchX=0
     * @protected
     */
    lastTouchX = 0
    /**
     * Storing touchmove position for mobile envs
     * @member {Number} lastTouchY=0
     * @protected
     */
    lastTouchY = 0
    /**
     * @member {Number|null}} scrollTimeoutId=null
     * @protected
     */
    scrollTimeoutId = null
    /**
     * Flag for identifying the ownership of a touchmove operation
     * @member {'container'|'view'|null} touchMoveOwner=null
     * @protected
     */
    touchMoveOwner = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.gridContainer.addDomListeners({
            scroll: me.onContainerScroll,
            scope : me
        });

        me.gridView.addDomListeners({
            scroll     : me.onViewScroll,
            touchcancel: me.onTouchCancel,
            touchend   : me.onTouchEnd,
            scope      : me
        })
    }

    /**
     * @param {Object} data
     * @param {Number} data.scrollLeft
     * @param {Object} data.target
     * @param {Object} data.touches
     */
    onContainerScroll({scrollLeft, target, touches}) {
        let me    = this,
            view = me.gridView,
            deltaY, lastTouchY;

        // We must ignore events for grid-scrollbar
        if (target.id.includes('grid-container')) {
            me  .scrollLeft = scrollLeft;
            view.scrollLeft = scrollLeft;

            me.gridContainer.headerToolbar.scrollLeft = scrollLeft;

            if (touches && !me.gridContainer.headerToolbar.cls.includes('neo-is-dragging')) {
                if (me.touchMoveOwner !== 'view') {
                    me.touchMoveOwner = 'container'
                }

                if (me.touchMoveOwner === 'container') {
                    lastTouchY = touches.lastTouch.clientY - touches.firstTouch.clientY;
                    deltaY     = me.lastTouchY - lastTouchY;

                    deltaY !== 0 && Neo.main.DomAccess.scrollTo({
                        direction: 'top',
                        id       : view.vdom.id,
                        value    : me.scrollTop + deltaY
                    })

                    me.lastTouchY = lastTouchY
                }
            }
        }
    }

    /**
     * @param {Object} data
     */
    onTouchCancel(data) {
        this.onTouchEnd(data)
    }

    /**
     * @param {Object} data
     */
    onTouchEnd(data) {
        let me = this;

        me.touchMoveOwner = null;
        me.lastTouchX     = 0;
        me.lastTouchY     = 0
    }

    /**
     * Only triggers for vertical scrolling
     * @param {Object} data
     * @protected
     */
    onViewScroll({scrollTop, touches}) {
        let me   = this,
            view = me.gridView,
            deltaX, lastTouchX;

        me.scrollTop = scrollTop;

        me.scrollTimeoutId && clearTimeout(me.scrollTimeoutId);

        me.scrollTimeoutId = setTimeout(() => {
            view.isScrolling = false
        }, 30);

        view.set({isScrolling: true, scrollTop});

        if (touches) {
            if (me.touchMoveOwner !== 'container') {
                me.touchMoveOwner = 'view'
            }

            if (me.touchMoveOwner === 'view') {
                lastTouchX = touches.lastTouch.clientX - touches.firstTouch.clientX;
                deltaX     = me.lastTouchX - lastTouchX;

                deltaX !== 0 && Neo.main.DomAccess.scrollTo({
                    direction: 'left',
                    id       : me.gridContainer.id,
                    value    : me.scrollLeft + deltaX
                })

                me.lastTouchX = lastTouchX
            }
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(ScrollManager));


/***/ }),

/***/ "./src/grid/VerticalScrollbar.mjs":
/*!****************************************!*\
  !*** ./src/grid/VerticalScrollbar.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");


/**
 * We do not want to use the default scrollbar for vertical scrolling, since it would show up at the right edge
 * of the last column. Instead, we want to show it at the right edge of the container (always visible when scrolling).
 * @class Neo.grid.VerticalScrollbar
 * @extends Neo.component.Base
 */
class VerticalScrollbar extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.grid.VerticalScrollbar'
         * @protected
         */
        className: 'Neo.grid.VerticalScrollbar',
        /**
         * @member {String} ntype='grid-vertical-scrollbar'
         * @protected
         */
        ntype: 'grid-vertical-scrollbar',
        /**
         * @member {String[]} baseCls=['neo-grid-vertical-scrollbar']
         * @protected
         */
        baseCls: ['neo-grid-vertical-scrollbar'],
        /**
         * Number in px
         * @member {Number} rowHeight_=0
         */
        rowHeight_: 0,
        /**
         * @member {Neo.data.Store|null} store_=null
         */
        store_: null,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {cn: [
            {cls: ['neo-grid-scrollbar-content']}
        ]}
    }

    /**
     * @param {Boolean} mounted
     * @protected
     */
    async addScrollSync(mounted) {
        let me         = this,
            {windowId} = me,
            ScrollSync = await Neo.currentWorker.getAddon('ScrollSync', windowId),
            params     = {id: me.id, windowId};

        if (mounted) {
            ScrollSync.register({
                fromId: me.parent.view.vdom.id,
                toId  : me.id,
                twoWay: !Neo.config.hasTouchEvents, // Syncing the scroller back to the view affects mobile scrolling
                ...params
            })
        } else {
            ScrollSync.unregister(params)
        }
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);
        oldValue !== undefined && this.addScrollSync(value)
    }

    /**
     * Triggered after the rowHeight config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetRowHeight(value, oldValue) {
        value > 0 && this.updateScrollHeight()
    }

    /**
     * Triggered after the store config got changed
     * @param {Neo.data.Store|null} value
     * @param {Neo.data.Store|null} oldValue
     * @protected
     */
    afterSetStore(value, oldValue) {
        if (value) {
            let me = this;

            value.on({
                load : me.updateScrollHeight,
                scope: me
            });

            value.getCount() > 0 && me.updateScrollHeight()
        }
    }

    /**
     *
     */
    updateScrollHeight() {
        let me           = this,
            countRecords = me.store.getCount(),
            {rowHeight}  = me;

        if (countRecords > 0 && rowHeight > 0) {
            me.vdom.cn[0].height = `${(countRecords + 1) * rowHeight}px`;
            me.update()
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(VerticalScrollbar));


/***/ }),

/***/ "./src/grid/View.mjs":
/*!***************************!*\
  !*** ./src/grid/View.mjs ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../collection/Base.mjs */ "./src/collection/Base.mjs");
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _selection_grid_RowModel_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../selection/grid/RowModel.mjs */ "./src/selection/grid/RowModel.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/VDom.mjs */ "./src/util/VDom.mjs");







/**
 * @class Neo.grid.View
 * @extends Neo.component.Base
 */
class GridView extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.grid.View'
         * @protected
         */
        className: 'Neo.grid.View',
        /**
         * @member {String} ntype='grid-view'
         * @protected
         */
        ntype: 'grid-view',
        /**
         * Internal flag. Gets calculated when mounting the grid.Container
         * @member {Number} availableHeight_=0
         */
        availableHeight_: 0,
        /**
         * Internal flag. Gets calculated when changing the availableHeight config
         * @member {Number} availableRows_=0
         */
        availableRows_: 0,
        /**
         * Internal flag. Gets calculated after mounting grid.View rows
         * @member {Number} availableWidth_=0
         */
        availableWidth_: 0,
        /**
         * @member {String[]} baseCls=['neo-grid-view']
         * @protected
         */
        baseCls: ['neo-grid-view'],
        /**
         * The amount of columns (cells) to paint before the first & after the last visible column,
         * to enhance the scrolling performance
         * @member {Number} bufferColumnRange_=0
         */
        bufferColumnRange_: 0,
        /**
         * The amount of rows to paint before the first & after the last visible row,
         * to enhance the scrolling performance
         * @member {Number} bufferRowRange_=3
         */
        bufferRowRange_: 3,
        /**
         * Define which model field contains the value of colspan definitions
         * @member {String} colspanField='colspan'
         */
        colspanField: 'colspan',
        /**
         * Internal flag. Gets calculated after mounting grid.View rows
         * @member {Number} containerWidth_=0
         */
        containerWidth_: 0,
        /**
         * @member {Neo.collection.Base|null} columnPositions_=null
         * @protected
         */
        columnPositions_: null,
        /**
         * @member {Boolean} highlightModifiedCells_=false
         */
        highlightModifiedCells_: false,
        /**
         * @member {Boolean} isScrolling_=false
         */
        isScrolling_: false,
        /**
         * Additional used keys for the selection model
         * @member {Object} keys
         */
        keys: {},
        /**
         * Stores the indexes of the first & last mounted columns, including bufferColumnRange
         * @member {Number[]} mountedColumns_=[0,0]
         * @protected
         */
        mountedColumns_: [0, 0],
        /**
         * Stores the indexes of the first & last mounted rows, including bufferRowRange
         * @member {Number[]} mountedRows=[0,0]
         * @protected
         */
        mountedRows: [0, 0],
        /**
         * @member {String} role='rowgroup'
         */
        role: 'rowgroup',
        /**
         * Number in px
         * @member {Number} rowHeight_=0
         */
        rowHeight_: 0,
        /**
         * @member {Number} scrollLeft_=0
         * @protected
         */
        scrollLeft_: 0,
        /**
         * @member {Number} scrollTop_=0
         * @protected
         */
        scrollTop_: 0,
        /**
         * @member {Neo.selection.Model} selectionModel_=null
         */
        selectionModel_: null,
        /**
         * @member {String} selectedRecordField='annotations.selected'
         */
        selectedRecordField: 'annotations.selected',
        /**
         * @member {Number} startIndex_=0
         */
        startIndex_: 0,
        /**
         * @member {Neo.data.Store|null} store_=null
         */
        store_: null,
        /**
         * Stores the indexes of the first & last painted columns
         * @member {Number[]} visibleColumns=[0,0]
         * @protected
         */
        visibleColumns: [0, 0],
        /**
         * Stores the indexes of the first & last visible rows, excluding bufferRowRange
         * @member {Number[]} visibleRows=[0,0]
         * @protected
         */
        visibleRows: [0, 0],
        /**
         * @member {String[]} wrapperCls=[]
         */
        wrapperCls: ['neo-grid-view-wrapper'],
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {tabIndex: '-1', cn: [
            {cn: []}
        ]}
    }

    /**
     * @member {String[]} selectedCells
     */
    get selectedCells() {
        let {selectionModel} = this;

        if (selectionModel.ntype?.includes('cell')) {
            return selectionModel.items
        }

        return []
    }

    /**
     * @member {String[]} selectedRows
     */
    get selectedRows() {
        let {selectionModel} = this;

        if (selectionModel.ntype === 'selection-grid-rowmodel') {
            return selectionModel.items
        }

        if (selectionModel.ntype?.includes('row')) {
            return selectionModel.selectedRows
        }

        return []
    }

    /**
     * @param config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.addDomListeners([{
            click   : me.onCellClick,
            dblclick: me.onCellDoubleClick,
            delegate: '.neo-grid-cell',
            scope   : me
        }, {
            click   : me.onRowClick,
            dblclick: me.onRowDoubleClick,
            delegate: '.neo-grid-row',
            scope   : me
        }])
    }

    /**
     * Triggered after the availableHeight config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetAvailableHeight(value, oldValue) {
        if (value > 0) {
            this.availableRows = Math.ceil(value / this.rowHeight) - 1
        }
    }

    /**
     * Triggered after the availableRows config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetAvailableRows(value, oldValue) {
        value > 0 && this.createViewData()
    }

    /**
     * Triggered after the availableWidth config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetAvailableWidth(value, oldValue) {
        if (value > 0) {
            let me = this;

            me.vdom.width = value + 'px';
            me.vdom.cn[0].width = value + 'px';
            me.update()
        }
    }

    /**
     * Triggered after the bufferColumnRange config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetBufferColumnRange(value, oldValue) {
        oldValue !== undefined && this.createViewData()
    }

    /**
     * Triggered after the bufferRowRange config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetBufferRowRange(value, oldValue) {
        oldValue !== undefined && this.createViewData()
    }

    /**
     * Triggered after the containerWidth config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetContainerWidth(value, oldValue) {
        value > 0 && this.updateMountedAndVisibleColumns()
    }

    /**
     * Triggered after the id config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetId(value, oldValue) {
        this.vdom.id = value + '__wrapper';

        // silent vdom update, the super call will trigger the engine
        super.afterSetId(value, oldValue);
    }

    /**
     * Triggered after the isScrolling config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetIsScrolling(value, oldValue) {
        this.toggleCls('neo-is-scrolling', value)
    }

    /**
     * Triggered after the mountedColumns config got changed
     * @param {Number[]} value
     * @param {Number[]} oldValue
     * @protected
     */
    afterSetMountedColumns(value, oldValue) {
        oldValue && this.createViewData()
    }

    /**
     * Triggered after the rowHeight config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetRowHeight(value, oldValue) {
        value > 0 && this.updateScrollHeight()
    }

    /**
     * Triggered after the scrollLeft config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetScrollLeft(value, oldValue) {
        this.updateMountedAndVisibleColumns()
    }

    /**
     * Triggered after the scrollTop config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetScrollTop(value, oldValue) {
        let me               = this,
            {bufferRowRange} = me,
            newStartIndex    = Math.floor(value / me.rowHeight);

        if (Math.abs(me.startIndex - newStartIndex) >= bufferRowRange) {
            me.startIndex = newStartIndex
        } else {
            me.visibleRows[0] = newStartIndex;
            me.visibleRows[1] = newStartIndex + me.availableRows
        }
    }

    /**
     * Triggered after the selectionModel config got changed
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @protected
     */
    afterSetSelectionModel(value, oldValue) {
        this.rendered && value.register(this)
    }

    /**
     * Triggered after the startIndex config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetStartIndex(value, oldValue) {
        oldValue !== undefined && this.createViewData()
    }

    /**
     * @param {Object} data
     * @param {String} [data.cellId]
     * @param {Object} data.column
     * @param {Number} data.columnIndex
     * @param {Object} data.record
     * @param {Number} data.rowIndex
     * @returns {Object}
     */
    applyRendererOutput(data) {
        let {cellId, column, columnIndex, record, rowIndex} = data,
            me                     = this,
            gridContainer          = me.parent,
            {selectedCells, store} = me,
            cellCls                = ['neo-grid-cell'],
            colspan                = record[me.colspanField],
            {dataField}            = column,
            fieldValue             = record[dataField],
            cellConfig, rendererOutput;

        if (fieldValue === null || fieldValue === undefined) {
            fieldValue = ''
        }

        rendererOutput = column.renderer.call(column.rendererScope || gridContainer, {
            column,
            columnIndex,
            dataField,
            gridContainer,
            record,
            rowIndex,
            store,
            value: fieldValue
        });

        switch (Neo.typeOf(rendererOutput)) {
            case 'Object': {
                if (rendererOutput.html) {
                    rendererOutput.cls && cellCls.push(...rendererOutput.cls);
                } else {
                    rendererOutput = [rendererOutput];
                }
                break
            }
            case 'Date':
            case 'Number':
            case 'String': {
                rendererOutput = {
                    cls : cellCls,
                    html: rendererOutput?.toString()
                };
                break
            }
        }

        if (rendererOutput === null || rendererOutput === undefined) {
            rendererOutput = ''
        }

        if (column.cellAlign !== 'left') {
            cellCls.push('neo-' + column.cellAlign)
        }

        if (me.highlightModifiedCells) {
            if (record.isModifiedField(dataField)) {
                cellCls.push('neo-is-modified')
            }
        }

        if (!cellId) {
            cellId = me.getCellId(record, column.dataField)
        }

        if (selectedCells.includes(cellId)) {
            cellCls.push('neo-selected')
        }

        if (me.selectionModel?.selectedColumns?.includes(dataField)) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(cellCls, me.selectionModel.selectedColumnCellCls || 'neo-selected')
        }

        cellConfig = {
            'aria-colindex': columnIndex + 1, // 1 based
            id             : cellId,
            cls            : cellCls,
            role           : 'gridcell',
            style          : rendererOutput.style || {}
        };

        if (column.width) {
            cellConfig.style.minWidth = `${column.width}px`
        }

        if (colspan && Object.keys(colspan).includes(dataField)) {
            cellConfig.colspan = colspan[dataField]
        }

        if (Neo.typeOf(rendererOutput) === 'Object') {
            cellConfig.innerHTML = rendererOutput.html  || ''
        } else {
            cellConfig.cn = rendererOutput
        }

        return cellConfig
    }

    /**
     * Triggered when accessing the columnPositions config
     * @param {Object} value
     * @protected
     */
    beforeGetColumnPositions(value) {
        if (!value) {
            this._columnPositions = value = Neo.create({
                module     : _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                keyProperty: 'dataField'
            })
        }

        return value
    }

    /**
     * Triggered before the selectionModel config gets changed.
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @protected
     */
    beforeSetSelectionModel(value, oldValue) {
        oldValue?.destroy();

        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].beforeSetInstance(value, _selection_grid_RowModel_mjs__WEBPACK_IMPORTED_MODULE_4__["default"])
    }

    /**
     * @param {Object} opts
     * @param {Object} opts.record
     * @param {Number} [opts.rowIndex]
     * @returns {Object}
     */
    createRow({record, rowIndex}) {
        if (!Neo.isNumber(rowIndex)) {
            rowIndex = this.store.indexOf(record)
        }

        let me            = this,
            {mountedColumns, selectedRows} = me,
            gridContainer = me.parent,
            columns       = gridContainer.headerToolbar.items,
            id            = me.getRowId(record, rowIndex),
            rowCls        = me.getRowClass(record, rowIndex),
            config, column, columnPosition,  gridRow, i;

        if (rowIndex % 2 !== 0) {
            rowCls.push('neo-even')
        }

        if (selectedRows && record[me.selectedRecordField]) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(selectedRows, id)
        }

        if (selectedRows?.includes(id)) {
            rowCls.push('neo-selected');
            gridContainer.fire('select', {record})
        }

        gridRow = {
            id,
            'aria-rowindex': rowIndex + 2, // header row => 1, first body row => 2
            cls            : rowCls,
            cn             : [],
            role           : 'row',

            style: {
                height   : me.rowHeight + 'px',
                transform: `translate(0px, ${rowIndex * me.rowHeight}px)`
            }
        };

        for (i=mountedColumns[0]; i <= mountedColumns[1]; i++) {
            column = columns[i];
            config = me.applyRendererOutput({column, columnIndex: i, record, rowIndex});

            if (column.dock) {
                config.cls = ['neo-locked', ...config.cls || []]
            }

            columnPosition = me.columnPositions.get(column.dataField);

            config.style = {
                ...config.style,
                left : columnPosition.x     + 'px',
                width: columnPosition.width + 'px'
            }

            // Happens during a column header drag OP, when leaving the painted range
            if (columnPosition.hidden) {
                config.style.visibility = 'hidden'
            }

            gridRow.cn.push(config)
        }

        return gridRow
    }

    /**
     * @param {Boolean} silent=false
     */
    createViewData(silent=false) {
        let me                   = this,
            {mountedRows, store} = me,
            rows                 = [],
            i;

        if (
            store.isLoading                   ||
            me.availableRows              < 1 ||
            me._containerWidth            < 1 || // we are not checking me.containerWidth, since we want to ignore the config symbol
            me.columnPositions.getCount() < 1 ||
            me.mountedColumns[1]          < 1
        ) {
            return
        }

        // Creates the new start & end indexes
        me.updateMountedAndVisibleRows();

        for (i=mountedRows[0]; i < mountedRows[1]; i++) {
            rows.push(me.createRow({record: store.items[i], rowIndex: i}))
        }

        me.getVdomRoot().cn = rows;

        me.parent.isLoading = false;

        me.updateScrollHeight(true); // silent
        !silent && me.update()
    }

    /**
     * @param args
     */
    destroy(...args) {
        this.store = null;
        super.destroy(...args)
    }

    /**
     * @param {Object} data
     * @param {String} eventName
     */
    fireCellEvent(data, eventName) {
        let me        = this,
            id        = data.currentTarget,
            dataField = me.getCellDataField(id),
            record    = me.getRecord(id);

        me.parent.fire(eventName, {data, dataField, record, view: me})
    }

    /**
     * @param {Object} data
     * @param {String} eventName
     */
    fireRowEvent(data, eventName) {
        let me     = this,
            id     = data.currentTarget,
            record = me.getRecord(id);

        me.parent.fire(eventName, {data, record, view: me})
    }

    /**
     * @param {String} cellId
     * @returns {String}
     */
    getCellDataField(cellId) {
        return cellId.split('__')[2]
    }

    /**
     * @param {Object} record
     * @param {String} dataField
     * @returns {String}
     */
    getCellId(record, dataField) {
        return this.id + '__' + record[this.store.getKeyProperty()] + '__' + dataField
    }

    /**
     * Get a grid column or column index by a given field name
     * @param {String} field
     * @param {Boolean} returnIndex=false
     * @returns {Object|Number|null}
     */
    getColumn(field, returnIndex=false) {
        let columns = this.parent.headerToolbar.items,
            i       = 0,
            len     = columns.length,
            column;

        for (; i < len; i++) {
            column = columns[i];

            if (column.dataField === field) {
                return returnIndex ? i : column
            }
        }

        return null
    }

    /**
     * Get all painted column cells (visible + buffer range)
     * @param {String} dataField
     * @returns {Object[]}
     */
    getColumnCells(dataField) {
        let me          = this,
            cells       = [],
            columnIndex = -1,
            vdomRoot    = me.getVdomRoot(),
            firstRow    = vdomRoot.cn[0],
            i           = 0,
            len         = firstRow.cn.length,
            cell;

        // Columns might get moved via drag&drop, so let's check for the current match
        for (; i < len; i++) {
            if (dataField === me.getDataField(firstRow.cn[i].id)) {
                columnIndex = i;
                break;
            }
        }

        if (columnIndex > -1) {
            vdomRoot.cn.forEach(row => {
                cell = row.cn[columnIndex];
                cell && cells.push(cell)
            })
        }

        return cells
    }

    /**
     * @param {String} cellId
     * @returns {String}
     */
    getDataField(cellId) {
        return cellId.split('__')[2]
    }

    /**
     * Get the matching record by passing a row id, a cell id or an id inside a grid cell.
     * Limited to mounted rows (must be inside the vdom).
     * @param {String} nodeId
     * @returns {Object|null}
     */
    getRecord(nodeId) {
        let me     = this,
            record = me.getRecordByRowId(nodeId),
            node, parentNodes;

        if (record) {
            return record;
        }

        parentNodes = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].getParentNodes(me.vdom, nodeId);

        for (node of parentNodes || []) {
            record = me.getRecordByRowId(node.id);

            if (record) {
                return record
            }
        }

        return null
    }

    /**
     * @param {String} cellId
     * @returns {Record}
     */
    getRecordByCellId(cellId) {
        let recordId = cellId.split('__')[1],
            {store}  = this,
            keyType  = store.getKeyType();

        if (keyType === 'int' || keyType === 'integer') {
            recordId = parseInt(recordId)
        }

        return store.get(recordId)
    }

    /**
     * @param {String} rowId
     * @returns {Record}
     */
    getRecordByRowId(rowId) {
        let recordId = rowId.split('__')[2],
            {store}  = this,
            keyType  = store.getKeyType();

        if (keyType === 'int' || keyType === 'integer') {
            recordId = parseInt(recordId)
        }

        return store.get(recordId)
    }

    /**
     * Override this method to apply custom CSS rules to grid rows
     * @param {Object} record
     * @param {Number} rowIndex
     * @returns {String[]}
     */
    getRowClass(record, rowIndex) {
        return ['neo-grid-row']
    }

    /**
     * @param {Object} record
     * @returns {String}
     */
    getRowId(record) {
        return `${this.id}__tr__${record[this.store.getKeyProperty()]}`
    }

    /**
     * @override
     * @returns {*}
     */
    getVdomRoot() {
        return this.vdom.cn[0]
    }

    /**
     * @returns {Object[]} The new vdom items root
     */
    getVdomItemsRoot() {
        return this.vdom.cn[0]
    }

    /**
     * @override
     * @returns {Neo.vdom.VNode}
     */
    getVnodeRoot() {
        return this.vnode.childNodes[0]
    }

    /**
     * @param {Object} data
     */
    onCellClick(data) {
        this.fireCellEvent(data, 'cellClick')
    }

    /**
     * @param {Object} data
     */
    onCellDoubleClick(data) {
        this.fireCellEvent(data, 'cellDoubleClick')
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();
        this.selectionModel?.register(this)
    }

    /**
     * @param {Object} data
     */
    onRowClick(data) {
        this.fireRowEvent(data, 'rowClick')
    }

    /**
     * @param {Object} data
     */
    onRowDoubleClick(data) {
        this.fireRowEvent(data, 'rowDoubleClick')
    }

    /**
     * Gets triggered after changing the value of a record field.
     * E.g. myRecord.foo = 'bar';
     * @param {Object} opts
     * @param {Object[]} opts.fields Each field object contains the keys: name, oldValue, value
     * @param {Neo.data.Model} opts.model The model instance of the changed record
     * @param {Object} opts.record
     */
    onStoreRecordChange({fields, record}) {
        let me                     = this,
            fieldNames             = fields.map(field => field.name),
            needsUpdate            = false,
            rowIndex               = me.store.indexOf(record),
            {selectionModel, vdom} = me,
            cellId, cellNode, cellStyle, cellVdom, column, columnIndex;

        if (fieldNames.includes(me.colspanField)) {
            me.vdom.cn[rowIndex] = me.createRow({record, rowIndex});
            me.update()
        } else {
            fields.forEach(field => {
                if (field.name === me.selectedRecordField) {
                    if (selectionModel.ntype === 'selection-grid-rowmodel') {
                        selectionModel[field.value ? 'select' : 'deselect'](me.getRowId(record))
                    }
                } else {
                    cellId   = me.getCellId(record, field.name);
                    cellNode = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].find(vdom, cellId);

                    // The vdom might not exist yet => nothing to do in this case
                    if (cellNode?.vdom) {
                        cellStyle   = cellNode.vdom.style;
                        column      = me.getColumn(field.name);
                        columnIndex = cellNode.index;
                        cellVdom    = me.applyRendererOutput({cellId, column, columnIndex, record, rowIndex});
                        needsUpdate = true;

                        // The cell-positioning logic happens outside applyRendererOutput()
                        // We need to preserve these styles
                        Object.assign(cellVdom.style, {
                            left : cellStyle.left,
                            width: cellStyle.width
                        });

                        cellNode.parentNode.cn[columnIndex] = cellVdom
                    }
                }
            })
        }

        needsUpdate && me.update()
    }

    /**
     * Used for keyboard navigation (selection models)
     * @param {Number} index
     * @param {Number} step
     */
    scrollByRows(index, step) {
        let me                         = this,
            {mountedRows, visibleRows} = me,
            countRecords               = me.store.getCount(),
            newIndex                   = index + step,
            lastRowGap, mounted, scrollTop, visible;

        if (newIndex >= countRecords) {
            newIndex %= countRecords;
            step     = newIndex - index
        }

        while (newIndex < 0) {
            newIndex += countRecords;
            step     += countRecords
        }

        mounted = newIndex >= mountedRows[0] && newIndex <= mountedRows[1];

        // Not using >= or <=, since the first / last row might not be fully visible
        visible = newIndex > visibleRows[0] && newIndex < visibleRows[1];

        if (!visible) {
            // Leaving the mounted area will re-calculate the visibleRows for us
            if (mounted) {
                visibleRows[0] += step;
                visibleRows[1] += step
            }

            if (step < 0) {
                scrollTop = newIndex * me.rowHeight
            } else {
                lastRowGap = me.rowHeight - (me.availableHeight % me.rowHeight);
                scrollTop  = (newIndex - me.availableRows) * me.rowHeight + lastRowGap
            }

            Neo.main.DomAccess.scrollTo({
                id      : me.vdom.id,
                value   : scrollTop,
                windowId: me.windowId
            })
        }
    }

    /**
     *
     */
    updateMountedAndVisibleColumns() {
        let me       = this,
            {bufferColumnRange, columnPositions, mountedColumns, visibleColumns} = me,
            i            = 0,
            countColumns = columnPositions.getCount(),
            endIndex     = countColumns - 1,
            x            = me.scrollLeft,
            column, startIndex;

        if (countColumns < 1) {
            return
        }

        for (; i < countColumns; i++) {
            column = columnPositions.getAt(i);

            if (x >= column.x && x <= column.x + column.width) {
                startIndex = i
            }

            if (me.containerWidth + x < column.x) {
                endIndex = i - 1;
                break
            }
        }

        visibleColumns[0] = startIndex; // update the array inline
        visibleColumns[1] = endIndex;

        if (visibleColumns[0] <= mountedColumns[0] || visibleColumns[1] >= mountedColumns[1]) {
            startIndex = Math.max(0, visibleColumns[0] - bufferColumnRange);
            endIndex   = Math.min(countColumns - 1, visibleColumns[1] + bufferColumnRange);

            me.mountedColumns = [startIndex, endIndex]
        }
    }

    /**
     *
     */
    updateMountedAndVisibleRows() {
        let me           = this,
            {bufferRowRange, startIndex, store} = me,
            countRecords = store.getCount(),
            endIndex     = Math.min(countRecords, startIndex + me.availableRows);

        me.visibleRows[0] = startIndex; // update the array inline
        me.visibleRows[1] = endIndex;

        startIndex = Math.max(0, startIndex - bufferRowRange);
        endIndex   = Math.min(countRecords, endIndex + bufferRowRange);

        me.mountedRows[0] = startIndex; // update the array inline
        me.mountedRows[1] = endIndex;
    }

    /**
     * @param {Boolean} silent=false
     */
    updateScrollHeight(silent=false) {
        let me           = this,
            countRecords = me.store.getCount(),
            {rowHeight}  = me;

        if (countRecords > 0 && rowHeight > 0) {
            me.vdom.cn[0].height = `${(countRecords + 1) * rowHeight}px`;
            !silent && me.update()
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(GridView));


/***/ }),

/***/ "./src/grid/header/Button.mjs":
/*!************************************!*\
  !*** ./src/grid/header/Button.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../button/Base.mjs */ "./src/button/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../form/field/Text.mjs */ "./src/form/field/Text.mjs");
/* harmony import */ var _util_Function_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/Function.mjs */ "./src/util/Function.mjs");





/**
 * @class Neo.grid.header.Button
 * @extends Neo.button.Base
 */
class Button extends _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for align
     * @member {String[]} cellAlignValues: ['left','center','right']
     * @protected
     * @static
     */
    static cellAlignValues = ['left', 'center', 'right']

    static config = {
        /**
         * @member {String} className='Neo.grid.header.Button'
         * @protected
         */
        className: 'Neo.grid.header.Button',
        /**
         * @member {String} ntype='grid-header-button'
         * @protected
         */
        ntype: 'grid-header-button',
        /**
         * @member {String[]} baseCls=['neo-grid-header-button','neo-button']
         */
        baseCls: ['neo-grid-header-button', 'neo-button'],
        /**
         * Alignment of the matching grid cells. Valid values are left, center, right
         * @member {String} cellAlign_='left'
         */
        cellAlign_: 'left',
        /**
         * @member {String|null} dataField=null
         */
        dataField: null,
        /**
         * Sort direction when clicking on an unsorted button
         * @member {String} defaultSortDirection='ASC'
         */
        defaultSortDirection: 'ASC',
        /**
         * @member {Object} editorConfig=null
         */
        editorConfig: null,
        /**
         * @member {Object} filterConfig=null
         */
        filterConfig: null,
        /**
         * @member {Neo.form.field.Base|null} filterField=null
         * @protected
         */
        filterField: null,
        /**
         * @member {String} iconCls='fa fa-arrow-circle-up'
         */
        iconCls: 'fa fa-arrow-circle-up',
        /**
         * @member {String} iconPosition='right'
         */
        iconPosition: 'right',
        /**
         * 'ASC', 'DESC' or null
         * @member {String|null} isSorted_=null
         * @protected
         */
        isSorted_: null,
        /**
         * @member {Function|String|null} renderer_='cellRenderer'
         */
        renderer_: 'cellRenderer',
        /**
         * Scope to execute the column renderer.
         * Defaults to the matching grid.Container
         * @member {Neo.core.Base|null} rendererScope=null
         */
        rendererScope: null,
        /**
         * @member {String} role='columnheader'
         */
        role: 'columnheader',
        /**
         * @member {Boolean} showHeaderFilter_=false
         */
        showHeaderFilter_: false,
        /**
         * @member {Boolean} sortable_=true
         */
        sortable_: true
    }

    /**
     * Triggered after the isSorted config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetIsSorted(value, oldValue) {
        let me        = this,
            {cls}     = me,
            container = me.up('grid-container');

        switch(value) {
            case null:
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-sort-hidden');
                break
            case 'ASC':
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, 'neo-sort-desc');
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, 'neo-sort-hidden');
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-sort-asc');
                break
            case 'DESC':
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, 'neo-sort-asc');
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, 'neo-sort-hidden');
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-sort-desc');
                break
        }

        me.cls = cls;

        // testing check until all example grids have a store
        if (!container || !container.store) {
            return
        }

        me.mounted && me.fire('sort', {
            direction: value,
            property : me.dataField
        })
    }

    /**
     * Triggered after the showHeaderFilter config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowHeaderFilter(value, oldValue) {
        let me = this;

        if (value) {
            if (!me.filterField) {
                me.filterField = Neo.create({
                    module   : _form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
                    appName  : me.appName,
                    flag     : 'filter-field',
                    hideLabel: true,
                    parentId : me.id,
                    style    : {marginLeft: '.5em', marginRight: '.5em'},
                    windowId : me.windowId,

                    listeners: {
                        change        : me.changeFilterValue,
                        operatorChange: me.changeFilterOperator,
                        scope         : me
                    },

                    ...me.editorConfig
                });

                me.vdom.cn.push(me.filterField.createVdomReference())
            } else {
                delete me.filterField.vdom.removeDom
            }
        } else if (me.filterField) {
            me.filterField.vdom.removeDom = true
        }

        me.updateDepth = 2;
        me.update()
    }

    /**
     * Triggered after the sortable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetSortable(value, oldValue) {
        let me    = this,
            {cls} = me;

        if (value === true) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, 'neo-sort-hidden');

            me.addDomListeners({
                click: me.onButtonClick,
                scope: me
            })
        } else {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-sort-hidden');

            me.removeDomListeners({
                click: me.onButtonClick,
                scope: me
            })
        }

        me.cls = cls;
        me.update()
    }

    /**
     * Triggered before the cellAlign config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetCellAlign(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'cellAlign', 'cellAlignValues')
    }

    /**
     * Triggered before the renderer config gets changed
     * @param {Function|String|null} value
     * @param {Function|String|null} oldValue
     * @protected
     */
    beforeSetRenderer(value, oldValue) {
        return (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_3__.resolveCallback)(value, this).fn
    }

    /**
     * @param {Object}             data
     * @param {Neo.button.Base}    data.column
     * @param {Number}             data.columnIndex
     * @param {String}             data.dataField
     * @param {Neo.grid.Container} data.gridContainer
     * @param {Object}             data.record
     * @param {Number}             data.rowIndex
     * @param {Neo.data.Store}     data.store
     * @param {Number|String}      data.value
     * @returns {*}
     */
    cellRenderer(data) {
        return data.value
    }

    /**
     *
     */
    destroy(...args) {
        this.filterField?.destroy();

        super.destroy(...args)
    }

    /**
     * @protected
     */
    onButtonClick() {
        let me = this,
            map;

        if (me.defaultSortDirection === 'DESC') {
            map = {
                ASC : null,
                DESC: 'ASC',
                null: 'DESC'
            }
        } else {
            map = {
                ASC : 'DESC',
                DESC: null,
                null: 'ASC'
            }
        }

        me.isSorted = map[me.isSorted + '']
    }

    /**
     * @param {Object} data
     */
    changeFilterOperator(data) {
        let me            = this,
            gridContainer = me.up('grid-container'),
            store         = gridContainer?.store,
            operator      = data.value,
            filter, filters;

        if (store) {
            filter = store.getFilter(me.dataField);

            if (!filter) {
                filters = store.filters;

                filters.push({
                    property: me.dataField,
                    operator,
                    value   : null,
                    ...me.filterConfig
                });

                store.filters = filters
            } else {
                filter.operator = operator
            }
        }
    }

    /**
     * @param {Object} data
     */
    changeFilterValue(data) {
        let me            = this,
            gridContainer = me.up('grid-container'),
            store         = gridContainer?.store,
            {value}       = data,
            field, filter, filters, model;

        if (store) {
            filter = store.getFilter(me.dataField);
            model  = store.model;
            field  = model.getField(me.dataField);

            if (value && field?.type.toLowerCase() === 'date') {
                value = new Date(value)
            }

            if (!filter) {
                filters = store.filters;

                filters.push({
                    property: me.dataField,
                    operator: 'like',
                    value,
                    ...me.filterConfig
                });

                store.filters = filters
            } else {
                filter.value = value
            }
        }
    }

    /**
     * @protected
     */
    removeSortingCss() {
        let me    = this,
            {cls} = me;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-sort-hidden');

        me.cls       = cls;
        me._isSorted = null
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Button));


/***/ }),

/***/ "./src/grid/header/Toolbar.mjs":
/*!*************************************!*\
  !*** ./src/grid/header/Toolbar.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../toolbar/Base.mjs */ "./src/toolbar/Base.mjs");


/**
 * @class Neo.grid.header.Toolbar
 * @extends Neo.toolbar.Base
 */
class Toolbar extends _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.grid.header.Toolbar'
         * @protected
         */
        className: 'Neo.grid.header.Toolbar',
        /**
         * @member {String} ntype='grid-header-toolbar'
         * @protected
         */
        ntype: 'grid-header-toolbar',
        /**
         * @member {String[]} baseCls=['neo-grid-header-toolbar','neo-toolbar']
         */
        baseCls: ['neo-grid-header-toolbar', 'neo-toolbar'],
        /**
         * @member {Boolean} draggable_=true
         */
        draggable_: true,
        /**
         * @member {Object} itemDefaults={ntype: 'grid-header-button'}
         */
        itemDefaults: {
            ntype: 'grid-header-button'
        },
        /**
         * @member {String} role='row'
         */
        role: 'row',
        /**
         * @member {Number} scrollLeft_=0
         */
        scrollLeft_: 0,
        /**
         * @member {Boolean} showHeaderFilters_=false
         */
        showHeaderFilters_: false,
        /**
         * Convenience shortcut to pass sortable to all toolbar items.
         * If set to true, header clicks will sort the matching column (ASC, DESC, null)
         * @member {Boolean} sortable=true
         */
        sortable: true,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {'aria-rowindex': 1, cn: [{cn: []}]}
    }

    /**
     * Triggered after the draggable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetDraggable(value, oldValue) {
        let me = this;

        if (value && !me.sortZone) {
            Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("vendors-src_draggable_toolbar_SortZone_mjs"), __webpack_require__.e("src_draggable_grid_header_toolbar_SortZone_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ../../draggable/grid/header/toolbar/SortZone.mjs */ "./src/draggable/grid/header/toolbar/SortZone.mjs")).then(module => {
                let {appName, id, scrollLeft, windowId} = me;

                me.sortZone = Neo.create({
                    module             : module.default,
                    appName,
                    boundaryContainerId: [id, me.parent.id],
                    owner              : me,
                    scrollLeft,
                    windowId,
                    ...me.sortZoneConfig
                })
            })
        }
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);
        value && this.passSizeToView()
    }

    /**
     * Triggered after the showHeaderFilters config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowHeaderFilters(value, oldValue) {
        if (oldValue !== undefined) {
            let me = this;

            me.items.forEach(item => {
                item.setSilent({
                    showHeaderFilter: value
                })
            });

            me.updateDepth = -1; // filters can be deeply nested
            me.update()
        }
    }

    /**
     * Triggered after the scrollLeft config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetScrollLeft(value, oldValue) {
        if (oldValue !== undefined && this.sortZone) {
            this.sortZone.scrollLeft = value
        }
    }

    /**
     * Triggered after the sortable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetSortable(value, oldValue) {
        if (oldValue !== undefined) {
            let me = this;

            me.items.forEach(item => {
                item.setSilent({
                    sortable: value
                })
            });

            me.updateDepth = 2;
            me.update()
        }
    }

    /**
     *
     */
    createItems() {
        let me        = this,
            {mounted} = me;

        me.itemDefaults.showHeaderFilter = me.showHeaderFilters;

        super.createItems();

        let {items} = me,
            style;

        items.forEach((item, index) => {
            item.vdom['aria-colindex'] = index + 1; // 1 based

            style = item.wrapperStyle;

            // todo: only add px if number
            if (item.maxWidth) {style.maxWidth = item.maxWidth + 'px'}
            if (item.minWidth) {style.minWidth = item.minWidth + 'px'}
            if (item.width)    {style.width    = item.width    + 'px'}

            item.sortable = me.sortable;
            item.wrapperStyle = style
        });

        me.promiseUpdate().then(() => {
            // To prevent duplicate calls, we need to check the mounted state before the update call
            mounted && me.passSizeToView()
        })
    }

    /**
     * @param {String} dataField
     * @returns {Neo.button.Base|null}
     */
    getColumn(dataField) {
        for (const item of this.items) {
            if (item.dataField === dataField) {
                return item
            }
        }

        return null
    }

    /**
     * @param {Boolean} silent=false
     * @returns {Promise<void>}
     */
    async passSizeToView(silent=false) {
        let me              = this,
            {items}         = me,
            {view}          = me.parent,
            rects           = await me.getDomRect(items.map(item => item.id)),
            lastItem        = rects[rects.length - 1],
            columnPositions = rects.map((item, index) => ({dataField: items[index].dataField, width: item.width, x: item.x - rects[0].x})),
            i               = 1,
            len             = columnPositions.length,
            layoutFinished  = true;

        // If the css sizing is not done, columns after the first one can get x = 0
        for (; i < len; i++) {
            if (columnPositions[i].x === 0) {
                layoutFinished = false;
                break;
            }
        }

        // Delay for slow connections, where the container-sizing is not done yet
        if (!layoutFinished) {
            await me.timeout(100);
            await me.passSizeToView(silent)
        } else {
            view.columnPositions.clear();
            view.columnPositions.add(columnPositions);

            view[silent ? 'setSilent' : 'set']({
                availableWidth: lastItem.x + lastItem.width - rects[0].x
            });

            !silent && view.updateMountedAndVisibleColumns()
        }
    }

    /**
     * @param {Number}  index
     * @returns {Promise<void>}
     */
    async scrollToIndex(index) {
        await Neo.main.DomAccess.scrollIntoView({
            delay   : 125,
            id      : this.items[index].id,
            windowId: this.windowId
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Toolbar));


/***/ }),

/***/ "./src/grid/header/_export.mjs":
/*!*************************************!*\
  !*** ./src/grid/header/_export.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Button: () => (/* reexport safe */ _Button_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   Toolbar: () => (/* reexport safe */ _Toolbar_mjs__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var _Button_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Button.mjs */ "./src/grid/header/Button.mjs");
/* harmony import */ var _Toolbar_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Toolbar.mjs */ "./src/grid/header/Toolbar.mjs");





/***/ }),

/***/ "./src/selection/Model.mjs":
/*!*********************************!*\
  !*** ./src/selection/Model.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");




/**
 * @class Neo.selection.Model
 * @extends Neo.core.Base
 */
class Model extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.selection.Model'
         * @protected
         */
        className: 'Neo.selection.Model',
        /**
         * @member {String} ntype='selection-model'
         * @protected
         */
        ntype: 'selection-model',
        /**
         * Placeholder for extended classes to add a custom css rule to this owner component
         * @member {String|null} cls=null
         * @protected
         */
        cls: null,
        /**
         * @member {Array} items_=null
         * @protected
         */
        items_: null,
        /**
         * @member {String} selectedCls='selected'
         */
        selectedCls: 'neo-selected',
        /**
         * @member {Boolean} singleSelect=true
         */
        singleSelect: true,
        /**
         * Internally saves the view id, but the getter will return the matching instance
         * @member {Object} view_=null
         * @protected
         */
        view_: null
    }

    /**
     * Gets triggered before getting the value of the items config
     * @param {Array|null} value
     * @returns {Array}
     */
    beforeGetItems(value) {
        if (!value) {
            this._items = value = []
        }

        return value
    }

    /**
     * Gets triggered before getting the value of the view config
     * @param {String} value
     * @returns {Neo.component.Base}
     */
    beforeGetView(value) {
        return Neo.getComponent(this._view)
    }

    /**
     * Gets triggered before setting the value of the view config
     * @returns {String} the view id
     */
    beforeSetView(value) {
        return value && value.id
    }

    /**
     *
     */
    addDomListener() {}

    /**
     * @param {Object} item
     * @param {Boolean} [silent] true to prevent a vdom update
     * @param {Object[]|String[]} itemCollection=this.items
     * @param {String} [selectedCls]
     */
    deselect(item, silent, itemCollection=this.items, selectedCls) {
        // We hold vdom ids for now, so all incoming selections must be converted.
        item = item.isRecord ? view.getItemId(item) : Neo.isObject(item) ? item.id : item;

        if (itemCollection.includes(item)) {
            let me     = this,
                {view} = me,
                node   = view.getVdomChild(item);

            if (node) {
                node.cls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(node.cls || [], selectedCls || me.selectedCls);
                node['aria-selected'] = false
            }

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(itemCollection, item);

            if (!silent) {
                view.update();

                me.fire('selectionChange', {
                    selection: itemCollection
                })
            }
        }
        else if (!silent) {
            this.fire('noChange')
        }
    }

    /**
     * @param {Boolean} [silent] true to prevent a vdom update
     * @param {Object[]|String[]} itemCollection=this.items
     */
    deselectAll(silent, itemCollection=this.items) {
        let me     = this,
            items  = [...itemCollection],
            {view} = me;

        if (items.length) {
            items.forEach(item => {
                me.deselect(item, true)
            });

            if (!silent && items.length > 0) {
                view.update()
            }

            me.fire('selectionChange', {
                selection: this.items
            })
        }
        else if (!silent) {
            me.fire('noChange')
        }
    }

    /**
     *
     */
    destroy(...args) {
        this.unregister();
        super.destroy(...args)
    }

    /**
     * @returns {Array} this.items
     */
    getSelection() {
        return this.items
    }

    /**
     * @returns {Boolean}
     */
    hasSelection() {
        return this.items.length > 0
    }

    /**
     * @param {String} id
     * @returns {Boolean} true in case the item is selected
     */
    isSelected(id) {
        return this.items.includes(id)
    }

    /**
     * @param {Neo.component.Base} component
     */
    register(component) {
        let me  = this,
            cls = component.wrapperCls || [];

        if (me.cls && !cls.includes(me.cls)) {
            cls.push(me.cls);
            component.wrapperCls = cls
        }

        me.view = component;
        me.addDomListener();

        component.fire('selectionModelChange', {
            value: me
        })
    }

    /**
     *
     */
    removeDomListeners() {
        let me           = this,
            component    = me.view,
            domListeners = [...component.domListeners];

        component.domListeners.forEach(listener => {
            if (listener.scope === me) {
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(domListeners, listener)
            }
        });

        component.domListeners = domListeners
    }

    /**
     * @param {Object|Object[]|String[]} items
     * @param {Object[]|String[]} itemCollection=this.items
     * @param {String} [selectedCls]
     */
    select(items, itemCollection=this.items, selectedCls) {
        let me     = this,
            {view} = me;

        // We hold vdom ids for now, so all incoming selections must be converted.
        items = (items = Array.isArray(items) ?
            items: [items]).map(item => item.isRecord ? view.getItemId(item) : Neo.isObject(item) ? item.id : item);

        if (!Neo.isEqual(itemCollection, items)) {
            if (me.singleSelect && itemCollection === me.items) {
                me.deselectAll(true, itemCollection)
            }

            items.forEach(node => {
                node = view.getVdomChild(node);

                if (node) {
                    node.cls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(node.cls || [], selectedCls || me.selectedCls);
                    node['aria-selected'] = true
                }
            });

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(itemCollection, items);

            if (!view.silentSelect) {
                view.update()
            }

            view.onSelect?.(items);

            me.fire('selectionChange', {
                selection: itemCollection
            })
        }
        else {
            me.fire('noChange')
        }
    }

    /**
     * @param {Object} item
     */
    toggleSelection(item) {
        let me = this;

        if (me.isSelected(item)) {
            me.deselect(item)
        } else {
            me.select(item)
        }
    }

    /**
     *
     */
    unregister() {
        let me  = this,
            cls = me.view.wrapperCls || [];

        if (me.cls && cls.includes(me.cls)) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, me.cls);
            me.view.wrapperCls = cls
        }

        me.deselectAll();

        me.removeDomListeners()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Model));


/***/ }),

/***/ "./src/selection/grid/BaseModel.mjs":
/*!******************************************!*\
  !*** ./src/selection/grid/BaseModel.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Model_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Model.mjs */ "./src/selection/Model.mjs");


/**
 * Abstract base class for all grid related selection models
 * @class Neo.selection.grid.BaseModel
 * @extends Neo.selection.Model
 * @abstract
 */
class BaseModel extends _Model_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.selection.grid.BaseModel'
         * @protected
         */
        className: 'Neo.selection.grid.BaseModel'
    }

    /**
     * Convenience shortcut
     * @member {String[]} dataFields
     */
    get dataFields() {
        return this.view.parent.columns.map(column => column.dataField)
    }

    /**
     * Checks if an event path contains a grid cell editor
     * @param {Object}   data
     * @param {Object[]} data.path
     * @returns {Boolean}
     */
    hasEditorFocus({path}) {
        for (const node of path) {
            if (node.cls?.includes('neo-grid-editor')) {
                return true
            }
        }

        return false
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(BaseModel));


/***/ }),

/***/ "./src/selection/grid/RowModel.mjs":
/*!*****************************************!*\
  !*** ./src/selection/grid/RowModel.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _BaseModel_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseModel.mjs */ "./src/selection/grid/BaseModel.mjs");


/**
 * @class Neo.selection.grid.RowModel
 * @extends Neo.selection.grid.BaseModel
 */
class RowModel extends _BaseModel_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.selection.grid.RowModel'
         * @protected
         */
        className: 'Neo.selection.grid.RowModel',
        /**
         * @member {String} ntype='selection-grid-rowmodel'
         * @protected
         */
        ntype: 'selection-grid-rowmodel',
        /**
         * @member {String} cls='neo-selection-rowmodel'
         * @protected
         */
        cls: 'neo-selection-rowmodel'
    }

    /**
     *
     */
    addDomListener() {
        let me = this;

        me.view.parent.on('rowClick', me.onRowClick, me)
    }

    /**
     * @param args
     */
    destroy(...args) {
        let me = this;

        me.view.parent.un('rowClick', me.onRowClick, me);

        super.destroy(...args)
    }

    /**
     * @param {Record} record
     * @returns {Boolean}
     */
    hasAnnotations(record) {
        return !!Object.getOwnPropertyDescriptor(record.__proto__, this.view.selectedRecordField)
    }

    /**
     * @param {Object} data
     */
    onKeyDownDown(data) {
        !this.hasEditorFocus(data) && this.onNavKeyRow(1)
    }

    /**
     * @param {Object} data
     */
    onKeyDownUp(data) {
        !this.hasEditorFocus(data) && this.onNavKeyRow(-1)
    }

    /**
     * @param {Number} step
     */
    onNavKeyRow(step) {
        let me           = this,
            {view}       = me,
            {store}      = view,
            countRecords = store.getCount(),
            currentIndex = 0,
            newIndex, record, rowId;

        if (me.hasSelection()) {
            currentIndex = store.indexOf(view.getRecordByRowId(me.items[0]))
        }

        newIndex = (currentIndex + step) % countRecords;

        while (newIndex < 0) {
            newIndex += countRecords
        }

        record = store.getAt(newIndex);

        if (me.hasAnnotations(record)) {
            me.updateAnnotations(record)
        } else {
            rowId = view.getRowId(record);

            if (rowId) {
                me.select(rowId);

                view.scrollByRows(currentIndex, step);
                view.fire('select', {record})
            }
        }
    }

    /**
     * @param {Object} data
     */
    onRowClick(data) {
        let me     = this,
            id     = data.data.currentTarget,
            {view} = me,
            isSelected, record;

        if (id) {
            record = view.getRecord(id);

            if (me.hasAnnotations(record)) {
                me.updateAnnotations(record)
            } else {
                me.toggleSelection(id);

                isSelected = me.isSelected(id);

                !isSelected && view.onDeselect?.(record);

                view.fire(isSelected ? 'select' : 'deselect', {record})
            }
        }
    }

    /**
     * @param {Neo.component.Base} component
     */
    register(component) {
        super.register(component);

        let {id, view} = this;

        view.keys?._keys.push(
            {fn: 'onKeyDownDown', key: 'Down', scope: id},
            {fn: 'onKeyDownUp',   key: 'Up',   scope: id}
        )
    }

    /**
     *
     */
    unregister() {
        let {id, view} = this;

        view.keys?.removeKeys([
            {fn: 'onKeyDownDown', key: 'Down', scope: id},
            {fn: 'onKeyDownUp',   key: 'Up',   scope: id}
        ]);

        super.unregister()
    }

    /**
     * @param {Record} record
     */
    updateAnnotations(record) {
        let me               = this,
            {view}           = me,
            rowId            = view.getRowId(record),
            isSelected       = me.isSelected(rowId),
            annotationsField = view.selectedRecordField;

        if (me.singleSelect) {
            if (isSelected) {
                record[annotationsField] = false
            } else {
                me.items.forEach(rowId => {
                    // We can use setSilent(), since the last change will trigger a view update
                    view.getRecordByRowId(rowId).setSilent({[annotationsField]: false})
                });

                record[annotationsField] = true
            }
        } else {
            record[annotationsField] = !record[annotationsField]
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(RowModel));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19ncmlkX0NvbnRhaW5lcl9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBc0Q7QUFDRTtBQUNiO0FBQ1M7QUFDRjtBQUNNO0FBQ0g7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJEQUFhO0FBQ3pDO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNB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QVk7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25COztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTs7QUFFQTs7QUFFQSwrREFBK0QsT0FBTztBQUN0RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7O0FBRUEsYUFBYSxVQUFVOztBQUV2QjtBQUNBLGFBQWEsNENBQTRDO0FBQ3pELGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVOztBQUV2QjtBQUNBLGFBQWEsNENBQTRDO0FBQ3pELGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLDREQUE0RCwwQkFBMEI7QUFDdEYsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLHdCQUF3QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9ncmlkL0NvbnRhaW5lci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9ncmlkL1Njcm9sbE1hbmFnZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZ3JpZC9WZXJ0aWNhbFNjcm9sbGJhci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9ncmlkL1ZpZXcubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZ3JpZC9oZWFkZXIvQnV0dG9uLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2dyaWQvaGVhZGVyL1Rvb2xiYXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZ3JpZC9oZWFkZXIvX2V4cG9ydC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9zZWxlY3Rpb24vTW9kZWwubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvc2VsZWN0aW9uL2dyaWQvQmFzZU1vZGVsLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3NlbGVjdGlvbi9ncmlkL1Jvd01vZGVsLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZUNvbnRhaW5lciAgICAgZnJvbSAnLi4vY29udGFpbmVyL0Jhc2UubWpzJztcbmltcG9ydCBDbGFzc1N5c3RlbVV0aWwgICBmcm9tICcuLi91dGlsL0NsYXNzU3lzdGVtLm1qcyc7XG5pbXBvcnQgR3JpZFZpZXcgICAgICAgICAgZnJvbSAnLi9WaWV3Lm1qcyc7XG5pbXBvcnQgU2Nyb2xsTWFuYWdlciAgICAgZnJvbSAnLi9TY3JvbGxNYW5hZ2VyLm1qcyc7XG5pbXBvcnQgU3RvcmUgICAgICAgICAgICAgZnJvbSAnLi4vZGF0YS9TdG9yZS5tanMnO1xuaW1wb3J0IFZlcnRpY2FsU2Nyb2xsYmFyIGZyb20gJy4vVmVydGljYWxTY3JvbGxiYXIubWpzJztcbmltcG9ydCAqIGFzIGhlYWRlciAgICAgICBmcm9tICcuL2hlYWRlci9fZXhwb3J0Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5ncmlkLkNvbnRhaW5lclxuICogQGV4dGVuZHMgTmVvLmNvbnRhaW5lci5CYXNlXG4gKi9cbmNsYXNzIEdyaWRDb250YWluZXIgZXh0ZW5kcyBCYXNlQ29udGFpbmVyIHtcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGRlbGF5YWJsZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGRlbGF5YWJsZSA9IHtcbiAgICAgICAgb25SZXNpemU6IHt0eXBlOiAnYnVmZmVyJywgdGltZXI6IDMwMH1cbiAgICB9XG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5ncmlkLkNvbnRhaW5lcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmdyaWQuQ29udGFpbmVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2dyaWQtY29udGFpbmVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2dyaWQtY29udGFpbmVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWdyaWQtY29udGFpbmVyJ11cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tZ3JpZC1jb250YWluZXInXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRydWUgdXNlcyBncmlkLnBsdWdpbi5DZWxsRWRpdGluZ1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBjZWxsRWRpdGluZ189ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGNlbGxFZGl0aW5nXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZhdWx0IGNvbmZpZ3MgZm9yIGVhY2ggY29sdW1uXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gY29sdW1uRGVmYXVsdHM9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgY29sdW1uRGVmYXVsdHM6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gY29sdW1uc189W11cbiAgICAgICAgICovXG4gICAgICAgIGNvbHVtbnNfOiBbXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbmZpZ3MgZm9yIE5lby5ncmlkLmhlYWRlci5Ub29sYmFyXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBbaGVhZGVyVG9vbGJhckNvbmZpZz1udWxsXVxuICAgICAgICAgKi9cbiAgICAgICAgaGVhZGVyVG9vbGJhckNvbmZpZzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBoZWFkZXJUb29sYmFySWRfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGhlYWRlclRvb2xiYXJJZF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGxheW91dD0nYmFzZSdcbiAgICAgICAgICovXG4gICAgICAgIGxheW91dDogJ2Jhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSByb2xlPSdncmlkJ1xuICAgICAgICAgKi9cbiAgICAgICAgcm9sZTogJ2dyaWQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogTnVtYmVyIGluIHB4XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gcm93SGVpZ2h0Xz0zMlxuICAgICAgICAgKi9cbiAgICAgICAgcm93SGVpZ2h0XzogMzIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZ3JpZC5TY3JvbGxiYXJ8bnVsbH0gc2Nyb2xsYmFyPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2Nyb2xsYmFyOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2hvd0hlYWRlckZpbHRlcnNfPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBzaG93SGVhZGVyRmlsdGVyc186IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc29ydGFibGVfPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIHNvcnRhYmxlXzogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5kYXRhLlN0b3JlfSBzdG9yZV89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgc3RvcmVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uZmlncyBmb3IgTmVvLmdyaWQuVmlld1xuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gW3ZpZXdDb25maWc9bnVsbF1cbiAgICAgICAgICovXG4gICAgICAgIHZpZXdDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gdmlld0lkXz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHZpZXdJZF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheXxudWxsfSBpdGVtcz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1zOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbVxuICAgICAgICAgKi9cbiAgICAgICAgX3Zkb206XG4gICAgICAgIHtjbHM6IFsnbmVvLWdyaWQtd3JhcHBlciddLCBjbjogW1xuICAgICAgICAgICAgeydhcmlhLXJvd2NvdW50JzogMSwgY246IFtdfSAvLyBhcmlhLXJvd2NvdW50IGluY2x1ZGVzIHRoZSBjb2x1bW4gaGVhZGVyc1xuICAgICAgICBdfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdlIGRvIG5vdCBuZWVkIHRoZSBmaXJzdCBldmVudCB0byB0cmlnZ2VyIGxvZ2ljLCBzaW5jZSBhZnRlclNldE1vdW50ZWQoKSBoYW5kbGVzIHRoaXNcbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpbml0aWFsUmVzaXplRXZlbnQ9dHJ1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpbml0aWFsUmVzaXplRXZlbnQgPSB0cnVlXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7TmVvLmdyaWQuU2Nyb2xsTWFuYWdlcnxudWxsfSBzY3JvbGxNYW5hZ2VyPW51bGxcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2Nyb2xsTWFuYWdlciA9IG51bGxcblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCB0byBhY2Nlc3MgdGhlIE5lby5ncmlkLmhlYWRlci5Ub29sYmFyXG4gICAgICogQHJldHVybnMge05lby5ncmlkLmhlYWRlci5Ub29sYmFyfG51bGx9XG4gICAgICovXG4gICAgZ2V0IGhlYWRlclRvb2xiYXIoKSB7XG4gICAgICAgIHJldHVybiBOZW8uZ2V0Q29tcG9uZW50KHRoaXMuaGVhZGVyVG9vbGJhcklkKSB8fCBOZW8uZ2V0KHRoaXMuaGVhZGVyVG9vbGJhcklkKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCB0byBhY2Nlc3MgdGhlIE5lby5ncmlkLlZpZXdcbiAgICAgKiBAcmV0dXJucyB7TmVvLmdyaWQuVmlld3xudWxsfVxuICAgICAqL1xuICAgIGdldCB2aWV3KCkge1xuICAgICAgICByZXR1cm4gTmVvLmdldENvbXBvbmVudCh0aGlzLnZpZXdJZCkgfHwgTmVvLmdldCh0aGlzLnZpZXdJZClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAge2FwcE5hbWUsIHJvd0hlaWdodCwgc3RvcmUsIHdpbmRvd0lkfSA9IG1lO1xuXG4gICAgICAgIG1lLmhlYWRlclRvb2xiYXJJZCA9IE5lby5nZXRJZCgnZ3JpZC1oZWFkZXItdG9vbGJhcicpO1xuICAgICAgICBtZS52aWV3SWQgICAgICAgICAgPSBOZW8uZ2V0SWQoJ2dyaWQtdmlldycpO1xuXG4gICAgICAgIG1lLml0ZW1zID0gW3tcbiAgICAgICAgICAgIG1vZHVsZSAgICAgICAgICAgOiBoZWFkZXIuVG9vbGJhcixcbiAgICAgICAgICAgIGlkICAgICAgICAgICAgICAgOiBtZS5oZWFkZXJUb29sYmFySWQsXG4gICAgICAgICAgICBzaG93SGVhZGVyRmlsdGVyczogbWUuc2hvd0hlYWRlckZpbHRlcnMsXG4gICAgICAgICAgICBzb3J0YWJsZSAgICAgICAgIDogbWUuc29ydGFibGUsXG4gICAgICAgICAgICAuLi5tZS5oZWFkZXJUb29sYmFyQ29uZmlnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1vZHVsZSAgICAgICA6IEdyaWRWaWV3LFxuICAgICAgICAgICAgZmxleCAgICAgICAgIDogMSxcbiAgICAgICAgICAgIGdyaWRDb250YWluZXI6IG1lLFxuICAgICAgICAgICAgaWQgICAgICAgICAgIDogbWUudmlld0lkLFxuICAgICAgICAgICAgcm93SGVpZ2h0LFxuICAgICAgICAgICAgc3RvcmUsXG4gICAgICAgICAgICAuLi5tZS52aWV3Q29uZmlnXG4gICAgICAgIH1dO1xuXG4gICAgICAgIG1lLnNjcm9sbGJhciA9IE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgbW9kdWxlICA6IFZlcnRpY2FsU2Nyb2xsYmFyLFxuICAgICAgICAgICAgYXBwTmFtZSxcbiAgICAgICAgICAgIHBhcmVudElkOiBtZS5pZCxcbiAgICAgICAgICAgIHJvd0hlaWdodCxcbiAgICAgICAgICAgIHN0b3JlLFxuICAgICAgICAgICAgd2luZG93SWRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUudmRvbS5jbi5wdXNoKG1lLnNjcm9sbGJhci5jcmVhdGVWZG9tUmVmZXJlbmNlKCkpXG5cbiAgICAgICAgbWUudmRvbS5pZCA9IG1lLmdldFdyYXBwZXJJZCgpO1xuXG4gICAgICAgIG1lLmNyZWF0ZUNvbHVtbnMobWUuY29sdW1ucyk7XG5cbiAgICAgICAgbWUuYWRkRG9tTGlzdGVuZXJzKHtcbiAgICAgICAgICAgIHJlc2l6ZTogbWUub25SZXNpemUsXG4gICAgICAgICAgICBzY29wZSA6IG1lXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBtb3VudGVkXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIGFkZFJlc2l6ZU9ic2VydmVyKG1vdW50ZWQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt3aW5kb3dJZH0gICAgID0gbWUsXG4gICAgICAgICAgICBSZXNpemVPYnNlcnZlciA9IGF3YWl0IE5lby5jdXJyZW50V29ya2VyLmdldEFkZG9uKCdSZXNpemVPYnNlcnZlcicsIHdpbmRvd0lkKSxcbiAgICAgICAgICAgIHJlc2l6ZVBhcmFtcyAgID0ge2lkOiBtZS5pZCwgd2luZG93SWR9O1xuXG4gICAgICAgIGlmIChtb3VudGVkKSB7XG4gICAgICAgICAgICBSZXNpemVPYnNlcnZlci5yZWdpc3RlcihyZXNpemVQYXJhbXMpO1xuICAgICAgICAgICAgYXdhaXQgbWUucGFzc1NpemVUb1ZpZXcoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUuaW5pdGlhbFJlc2l6ZUV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIFJlc2l6ZU9ic2VydmVyLnVucmVnaXN0ZXIocmVzaXplUGFyYW1zKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBjZWxsRWRpdGluZyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldENlbGxFZGl0aW5nKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGltcG9ydCgnLi9wbHVnaW4vQ2VsbEVkaXRpbmcubWpzJykudGhlbihtb2R1bGUgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAge2FwcE5hbWUsIHdpbmRvd0lkfSA9IG1lLFxuICAgICAgICAgICAgICAgICAgICBwbHVnaW5zICAgICAgICAgICAgID0gbWUucGx1Z2lucyB8fCBbXTtcblxuICAgICAgICAgICAgICAgIHBsdWdpbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZSA6IG1vZHVsZS5kZWZhdWx0LFxuICAgICAgICAgICAgICAgICAgICBhcHBOYW1lLFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3dJZFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgbWUucGx1Z2lucyA9IHBsdWdpbnNcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGNvbHVtbnMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtPYmplY3RbXXxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W118bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYXN5bmMgYWZ0ZXJTZXRDb2x1bW5zKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWU/Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxldCBtZSAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHtoZWFkZXJUb29sYmFyfSA9IG1lO1xuXG4gICAgICAgICAgICBpZiAoaGVhZGVyVG9vbGJhcikge1xuICAgICAgICAgICAgICAgIGhlYWRlclRvb2xiYXIuaXRlbXMgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBoZWFkZXJUb29sYmFyLmNyZWF0ZUl0ZW1zKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXdhaXQgbWUudGltZW91dCg1MCk7XG5cbiAgICAgICAgICAgIGF3YWl0IG1lLnBhc3NTaXplVG9WaWV3KCk7XG5cbiAgICAgICAgICAgIG1lLnZpZXc/LmNyZWF0ZVZpZXdEYXRhKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbW91bnRlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICBvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuYWRkUmVzaXplT2JzZXJ2ZXIodmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSByb3dIZWlnaHQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Um93SGVpZ2h0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPiAwKSB7XG4gICAgICAgICAgICBsZXQge3Njcm9sbGJhciwgdmlld30gPSB0aGlzO1xuXG4gICAgICAgICAgICBpZiAoc2Nyb2xsYmFyKSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsYmFyLnJvd0hlaWdodCA9IHZhbHVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgICAgICAgdmlldy5yb3dIZWlnaHQgPSB2YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzaG93SGVhZGVyRmlsdGVycyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNob3dIZWFkZXJGaWx0ZXJzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJUb29sYmFyLnNob3dIZWFkZXJGaWx0ZXJzID0gdmFsdWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc29ydGFibGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTb3J0YWJsZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyVG9vbGJhci5zb3J0YWJsZSA9IHZhbHVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBjb2x1bW5zIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRDb2x1bW5zKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5jb25maWdzQXBwbGllZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ29sdW1ucyh2YWx1ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGhlYWRlclRvb2xiYXJJZCBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRIZWFkZXJUb29sYmFySWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSB8fCBvbGRWYWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHN0b3JlIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5TdG9yZX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLlN0b3JlfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRTdG9yZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWU/LmRlc3Ryb3koKTtcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXMsXG5cbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlciAgICAgIDogbWUub25TdG9yZUZpbHRlcixcbiAgICAgICAgICAgICAgICAgICAgbG9hZCAgICAgICAgOiBtZS5vblN0b3JlTG9hZCxcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkQ2hhbmdlOiBtZS5vblN0b3JlUmVjb3JkQ2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICBzY29wZSAgICAgICA6IG1lXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU3RvcmUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS5vbihsaXN0ZW5lcnMpO1xuICAgICAgICAgICAgICAgIHZhbHVlLmdldENvdW50KCkgPiAwICYmIG1lLm9uU3RvcmVMb2FkKHZhbHVlLml0ZW1zKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IENsYXNzU3lzdGVtVXRpbC5iZWZvcmVTZXRJbnN0YW5jZSh2YWx1ZSwgU3RvcmUsIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaW4gY2FzZSB3ZSBkeW5hbWljYWxseSBjaGFuZ2UgdGhlIHN0b3JlLCB0aGUgdmlldyBuZWVkcyB0byBnZXQgdGhlIG5ldyByZWZlcmVuY2VcbiAgICAgICAgICAgIGlmIChtZS52aWV3KSB7XG4gICAgICAgICAgICAgICAgbWUudmlldy5zdG9yZSA9IHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSB2aWV3SWQgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0Vmlld0lkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgfHwgb2xkVmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbiBjYXNlIHlvdSB3YW50IHRvIHVwZGF0ZSBtdWx0aXBsZSBleGlzdGluZyByZWNvcmRzIGluIHBhcmFsbGVsLFxuICAgICAqIHVzaW5nIHRoaXMgbWV0aG9kIGlzIGZhc3RlciB0aGFuIHVwZGF0aW5nIGVhY2ggcmVjb3JkIG9uZSBieSBvbmUuXG4gICAgICogQXQgbGVhc3QgdW50aWwgd2UgaW50cm9kdWNlIHJvdyBiYXNlZCB2ZG9tIHVwZGF0ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gcmVjb3Jkc1xuICAgICAqL1xuICAgIGJ1bGtVcGRhdGVSZWNvcmRzKHJlY29yZHMpIHtcbiAgICAgICAgbGV0IHtzdG9yZSwgdmlld30gPSB0aGlzLFxuICAgICAgICAgICAge2tleVByb3BlcnR5fSA9IHN0b3JlO1xuXG4gICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgICB2aWV3LnNpbGVudFZkb21VcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgICAgICByZWNvcmRzLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgc3RvcmUuZ2V0KGl0ZW1ba2V5UHJvcGVydHldKT8uc2V0KGl0ZW0pXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmlldy5zaWxlbnRWZG9tVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHZpZXcudXBkYXRlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGNvbHVtbnNcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBjcmVhdGVDb2x1bW5zKGNvbHVtbnMpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2NvbHVtbkRlZmF1bHRzfSA9IG1lLFxuICAgICAgICAgICAgc29ydGVycyAgICAgICAgICA9IG1lLnN0b3JlPy5zb3J0ZXJzLFxuICAgICAgICAgICAgcmVuZGVyZXI7XG5cbiAgICAgICAgaWYgKCFjb2x1bW5zIHx8ICFjb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgTmVvLmxvZ0Vycm9yKCdBdHRlbXB0aW5nIHRvIGNyZWF0ZSBhIGdyaWQuQ29udGFpbmVyIHdpdGhvdXQgZGVmaW5lZCBjb2x1bW5zJywgbWUuaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29sdW1ucy5mb3JFYWNoKGNvbHVtbiA9PiB7XG4gICAgICAgICAgICByZW5kZXJlciA9IGNvbHVtbi5yZW5kZXJlcjtcblxuICAgICAgICAgICAgY29sdW1uRGVmYXVsdHMgJiYgTmVvLmFzc2lnbkRlZmF1bHRzKGNvbHVtbiwgY29sdW1uRGVmYXVsdHMpO1xuXG4gICAgICAgICAgICBpZiAoY29sdW1uLmRvY2sgJiYgIWNvbHVtbi53aWR0aCkge1xuICAgICAgICAgICAgICAgIE5lby5sb2dFcnJvcignQXR0ZW1wdGluZyB0byBjcmVhdGUgYSBkb2NrZWQgY29sdW1uIHdpdGhvdXQgYSBkZWZpbmVkIHdpZHRoJywgY29sdW1uLCBtZS5pZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZW5kZXJlciAmJiBOZW8uaXNTdHJpbmcocmVuZGVyZXIpICYmIG1lW3JlbmRlcmVyXSkge1xuICAgICAgICAgICAgICAgIGNvbHVtbi5yZW5kZXJlciA9IG1lW3JlbmRlcmVyXVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc29ydGVycz8uWzBdKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbi5kYXRhRmllbGQgPT09IHNvcnRlcnNbMF0ucHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uLmlzU29ydGVkID0gc29ydGVyc1swXS5kaXJlY3Rpb25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbHVtbi5saXN0ZW5lcnMgPSB7XG4gICAgICAgICAgICAgICAgc29ydCA6IG1lLm9uU29ydENvbHVtbixcbiAgICAgICAgICAgICAgICBzY29wZTogbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUuaXRlbXNbMF0uaXRlbXMgPSBjb2x1bW5zO1xuXG4gICAgICAgIHJldHVybiBjb2x1bW5zXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheX0gaW5wdXREYXRhXG4gICAgICovXG4gICAgY3JlYXRlVmlld0RhdGEoaW5wdXREYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuZ2V0VmRvbVJvb3QoKVsnYXJpYS1yb3djb3VudCddID0gaW5wdXREYXRhLmxlbmd0aCArIDI7IC8vIDEgYmFzZWQgJiB0aGUgaGVhZGVyIHJvdyBjb3VudHMgYXMgd2VsbFxuICAgICAgICBtZS51cGRhdGUoKTtcblxuICAgICAgICBtZS52aWV3LmNyZWF0ZVZpZXdEYXRhKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqL1xuICAgIGRlc3Ryb3koLi4uYXJncykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnNjcm9sbE1hbmFnZXIuZGVzdHJveSgpO1xuXG4gICAgICAgIG1lLm1vdW50ZWQgJiYgTmVvLm1haW4uYWRkb24uUmVzaXplT2JzZXJ2ZXIudW5yZWdpc3Rlcih7XG4gICAgICAgICAgICBpZCAgICAgIDogbWUuaWQsXG4gICAgICAgICAgICB3aW5kb3dJZDogbWUud2luZG93SWRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc3VwZXIuZGVzdHJveSguLi5hcmdzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFZkb21Sb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZG9tLmNuWzBdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHJldHVybnMge05lby52ZG9tLlZOb2RlfVxuICAgICAqL1xuICAgIGdldFZub2RlUm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudm5vZGUuY2hpbGROb2Rlc1swXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0V3JhcHBlcklkKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5pZH1fX3dyYXBwZXJgXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNvbnN0cnVjdGVkKCkge1xuICAgICAgICBzdXBlci5vbkNvbnN0cnVjdGVkKCk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5zY3JvbGxNYW5hZ2VyID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICBtb2R1bGUgICAgICAgOiBTY3JvbGxNYW5hZ2VyLFxuICAgICAgICAgICAgZ3JpZENvbnRhaW5lcjogbWUsXG4gICAgICAgICAgICBncmlkVmlldyAgICAgOiBtZS52aWV3XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBhc3luYyBvblJlc2l6ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5pbml0aWFsUmVzaXplRXZlbnQpIHtcbiAgICAgICAgICAgIGF3YWl0IG1lLnBhc3NTaXplVG9WaWV3KHRydWUpO1xuXG4gICAgICAgICAgICBtZS52aWV3LnVwZGF0ZU1vdW50ZWRBbmRWaXNpYmxlQ29sdW1ucygpO1xuXG4gICAgICAgICAgICBhd2FpdCBtZS5oZWFkZXJUb29sYmFyLnBhc3NTaXplVG9WaWV3KClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLmluaXRpYWxSZXNpemVFdmVudCA9IGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRzLmRpcmVjdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRzLnByb3BlcnR5XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uU29ydENvbHVtbihvcHRzKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuc3RvcmUuc29ydChvcHRzKTtcbiAgICAgICAgbWUucmVtb3ZlU29ydGluZ0NzcyhvcHRzLnByb3BlcnR5KTtcbiAgICAgICAgbWUub25TdG9yZUxvYWQobWUuc3RvcmUuaXRlbXMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvblN0b3JlRmlsdGVyKCkge1xuICAgICAgICB0aGlzLm9uU3RvcmVMb2FkKHRoaXMuc3RvcmUuaXRlbXMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvblN0b3JlTG9hZChkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLnJlbmRlcmVkKSB7XG4gICAgICAgICAgICBtZS5jcmVhdGVWaWV3RGF0YShkYXRhKTtcblxuICAgICAgICAgICAgbWUudGltZW91dCg1MCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgTmVvLm1haW4uRG9tQWNjZXNzLnNjcm9sbFRvKHtcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAndG9wJyxcbiAgICAgICAgICAgICAgICAgICAgaWQgICAgICAgOiBtZS52aWV3LnZkb20uaWQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICAgIDogMFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICBpZiAobWUuc3RvcmUuc29ydGVycy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICAgICAgbWUucmVtb3ZlU29ydGluZ0NzcygpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCBhZnRlciBjaGFuZ2luZyB0aGUgdmFsdWUgb2YgYSByZWNvcmQgZmllbGQuXG4gICAgICogRS5nLiBteVJlY29yZC5mb28gPSAnYmFyJztcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRzLmZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB3aGljaCBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuTW9kZWx9IG9wdHMubW9kZWwgVGhlIG1vZGVsIGluc3RhbmNlIG9mIHRoZSBjaGFuZ2VkIHJlY29yZFxuICAgICAqIEBwYXJhbSB7Kn0gb3B0cy5vbGRWYWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLnJlY29yZFxuICAgICAqIEBwYXJhbSB7Kn0gb3B0cy52YWx1ZVxuICAgICAqL1xuICAgIG9uU3RvcmVSZWNvcmRDaGFuZ2Uob3B0cykge1xuICAgICAgICB0aGlzLnZpZXcub25TdG9yZVJlY29yZENoYW5nZShvcHRzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50PWZhbHNlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYXN5bmMgcGFzc1NpemVUb1ZpZXcoc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgW2NvbnRhaW5lclJlY3QsIGhlYWRlclJlY3RdID0gYXdhaXQgbWUuZ2V0RG9tUmVjdChbbWUuaWQsIG1lLmhlYWRlclRvb2xiYXJJZF0pO1xuXG4gICAgICAgIC8vIGRlbGF5IGZvciBzbG93IGNvbm5lY3Rpb25zLCB3aGVyZSB0aGUgY29udGFpbmVyLXNpemluZyBpcyBub3QgZG9uZSB5ZXRcbiAgICAgICAgaWYgKGNvbnRhaW5lclJlY3QuaGVpZ2h0ID09PSBoZWFkZXJSZWN0LmhlaWdodCkge1xuICAgICAgICAgICAgYXdhaXQgbWUudGltZW91dCgxMDApO1xuICAgICAgICAgICAgYXdhaXQgbWUucGFzc1NpemVUb1ZpZXcoc2lsZW50KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUudmlld1tzaWxlbnQgPyAnc2V0U2lsZW50JyA6ICdzZXQnXSh7XG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0OiBjb250YWluZXJSZWN0LmhlaWdodCAtIGhlYWRlclJlY3QuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcldpZHRoIDogY29udGFpbmVyUmVjdC53aWR0aFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhRmllbGRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcmVtb3ZlU29ydGluZ0NzcyhkYXRhRmllbGQpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJUb29sYmFyLml0ZW1zLmZvckVhY2goY29sdW1uID0+IHtcbiAgICAgICAgICAgIGlmIChjb2x1bW4uZGF0YUZpZWxkICE9PSBkYXRhRmllbGQpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW4ucmVtb3ZlU29ydGluZ0NzcygpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBmb3Iga2V5Ym9hcmQgbmF2aWdhdGlvbiAoc2VsZWN0aW9uIG1vZGVscylcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RlcFxuICAgICAqL1xuICAgIHNjcm9sbEJ5Q29sdW1ucyhpbmRleCwgc3RlcCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt2aWV3fSAgICAgICA9IG1lLFxuICAgICAgICAgICAge2NvbHVtblBvc2l0aW9ucywgY29udGFpbmVyV2lkdGgsIG1vdW50ZWRDb2x1bW5zLCB2aXNpYmxlQ29sdW1uc30gPSB2aWV3LFxuICAgICAgICAgICAgY291bnRDb2x1bW5zID0gY29sdW1uUG9zaXRpb25zLmdldENvdW50KCksXG4gICAgICAgICAgICBuZXdJbmRleCAgICAgPSBpbmRleCArIHN0ZXAsXG4gICAgICAgICAgICBjb2x1bW4sIG1vdW50ZWQsIHNjcm9sbExlZnQsIHZpc2libGU7XG5cbiAgICAgICAgaWYgKG5ld0luZGV4ID49IGNvdW50Q29sdW1ucykge1xuICAgICAgICAgICAgbmV3SW5kZXggJT0gY291bnRDb2x1bW5zO1xuICAgICAgICAgICAgc3RlcCAgICAgPSBuZXdJbmRleCAtIGluZGV4XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAobmV3SW5kZXggPCAwKSB7XG4gICAgICAgICAgICBuZXdJbmRleCArPSBjb3VudENvbHVtbnM7XG4gICAgICAgICAgICBzdGVwICAgICArPSBjb3VudENvbHVtbnNcbiAgICAgICAgfVxuXG4gICAgICAgIG1vdW50ZWQgPSBuZXdJbmRleCA+PSBtb3VudGVkQ29sdW1uc1swXSAmJiBuZXdJbmRleCA8PSBtb3VudGVkQ29sdW1uc1sxXTtcblxuICAgICAgICAvLyBOb3QgdXNpbmcgPj0gb3IgPD0sIHNpbmNlIHRoZSBmaXJzdCAvIGxhc3QgY29sdW1uIG1pZ2h0IG5vdCBiZSBmdWxseSB2aXNpYmxlXG4gICAgICAgIHZpc2libGUgPSBuZXdJbmRleCA+IHZpc2libGVDb2x1bW5zWzBdICYmIG5ld0luZGV4IDwgdmlzaWJsZUNvbHVtbnNbMV07XG5cbiAgICAgICAgaWYgKCF2aXNpYmxlKSB7XG4gICAgICAgICAgICAvLyBMZWF2aW5nIHRoZSBtb3VudGVkIGFyZWEgd2lsbCByZS1jYWxjdWxhdGUgdGhlIHZpc2libGVDb2x1bW5zIGZvciB1c1xuICAgICAgICAgICAgaWYgKG1vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICB2aXNpYmxlQ29sdW1uc1swXSArPSBzdGVwO1xuICAgICAgICAgICAgICAgIHZpc2libGVDb2x1bW5zWzFdICs9IHN0ZXBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29sdW1uID0gY29sdW1uUG9zaXRpb25zLmdldEF0KG5ld0luZGV4KTtcblxuICAgICAgICAgICAgaWYgKHN0ZXAgPCAwKSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsTGVmdCA9IGNvbHVtbi54XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjcm9sbExlZnQgPSBjb2x1bW4ueCAtIGNvbnRhaW5lcldpZHRoICsgY29sdW1uLndpZHRoXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE5lby5tYWluLkRvbUFjY2Vzcy5zY3JvbGxUbyh7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnbGVmdCcsXG4gICAgICAgICAgICAgICAgaWQgICAgICAgOiBtZS5pZCxcbiAgICAgICAgICAgICAgICB2YWx1ZSAgICA6IHNjcm9sbExlZnQsXG4gICAgICAgICAgICAgICAgd2luZG93SWQgOiBtZS53aW5kb3dJZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoR3JpZENvbnRhaW5lcik7XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmdyaWQuU2Nyb2xsTWFuYWdlclxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBTY3JvbGxNYW5hZ2VyIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZ3JpZC5TY3JvbGxNYW5hZ2VyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZ3JpZC5TY3JvbGxNYW5hZ2VyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gc2Nyb2xsTGVmdF89MFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzY3JvbGxMZWZ0XzogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gc2Nyb2xsVG9wXz0wXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNjcm9sbFRvcF86IDBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOZW8uZ3JpZC5Db250YWluZXJ8bnVsbH0gZ3JpZENvbnRhaW5lcj1udWxsXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGdyaWRDb250YWluZXIgPSBudWxsXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7TmVvLmdyaWQuVmlld3xudWxsfSBncmlkVmlldz1udWxsXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGdyaWRWaWV3ID0gbnVsbFxuICAgIC8qKlxuICAgICAqIFN0b3JpbmcgdG91Y2htb3ZlIHBvc2l0aW9uIGZvciBtb2JpbGUgZW52c1xuICAgICAqIEBtZW1iZXIge051bWJlcn0gbGFzdFRvdWNoWD0wXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGxhc3RUb3VjaFggPSAwXG4gICAgLyoqXG4gICAgICogU3RvcmluZyB0b3VjaG1vdmUgcG9zaXRpb24gZm9yIG1vYmlsZSBlbnZzXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSBsYXN0VG91Y2hZPTBcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgbGFzdFRvdWNoWSA9IDBcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH19IHNjcm9sbFRpbWVvdXRJZD1udWxsXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNjcm9sbFRpbWVvdXRJZCA9IG51bGxcbiAgICAvKipcbiAgICAgKiBGbGFnIGZvciBpZGVudGlmeWluZyB0aGUgb3duZXJzaGlwIG9mIGEgdG91Y2htb3ZlIG9wZXJhdGlvblxuICAgICAqIEBtZW1iZXIgeydjb250YWluZXInfCd2aWV3J3xudWxsfSB0b3VjaE1vdmVPd25lcj1udWxsXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRvdWNoTW92ZU93bmVyID0gbnVsbFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5ncmlkQ29udGFpbmVyLmFkZERvbUxpc3RlbmVycyh7XG4gICAgICAgICAgICBzY3JvbGw6IG1lLm9uQ29udGFpbmVyU2Nyb2xsLFxuICAgICAgICAgICAgc2NvcGUgOiBtZVxuICAgICAgICB9KTtcblxuICAgICAgICBtZS5ncmlkVmlldy5hZGREb21MaXN0ZW5lcnMoe1xuICAgICAgICAgICAgc2Nyb2xsICAgICA6IG1lLm9uVmlld1Njcm9sbCxcbiAgICAgICAgICAgIHRvdWNoY2FuY2VsOiBtZS5vblRvdWNoQ2FuY2VsLFxuICAgICAgICAgICAgdG91Y2hlbmQgICA6IG1lLm9uVG91Y2hFbmQsXG4gICAgICAgICAgICBzY29wZSAgICAgIDogbWVcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLnNjcm9sbExlZnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YS50YXJnZXRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YS50b3VjaGVzXG4gICAgICovXG4gICAgb25Db250YWluZXJTY3JvbGwoe3Njcm9sbExlZnQsIHRhcmdldCwgdG91Y2hlc30pIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIHZpZXcgPSBtZS5ncmlkVmlldyxcbiAgICAgICAgICAgIGRlbHRhWSwgbGFzdFRvdWNoWTtcblxuICAgICAgICAvLyBXZSBtdXN0IGlnbm9yZSBldmVudHMgZm9yIGdyaWQtc2Nyb2xsYmFyXG4gICAgICAgIGlmICh0YXJnZXQuaWQuaW5jbHVkZXMoJ2dyaWQtY29udGFpbmVyJykpIHtcbiAgICAgICAgICAgIG1lICAuc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQ7XG4gICAgICAgICAgICB2aWV3LnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xuXG4gICAgICAgICAgICBtZS5ncmlkQ29udGFpbmVyLmhlYWRlclRvb2xiYXIuc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQ7XG5cbiAgICAgICAgICAgIGlmICh0b3VjaGVzICYmICFtZS5ncmlkQ29udGFpbmVyLmhlYWRlclRvb2xiYXIuY2xzLmluY2x1ZGVzKCduZW8taXMtZHJhZ2dpbmcnKSkge1xuICAgICAgICAgICAgICAgIGlmIChtZS50b3VjaE1vdmVPd25lciAhPT0gJ3ZpZXcnKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnRvdWNoTW92ZU93bmVyID0gJ2NvbnRhaW5lcidcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobWUudG91Y2hNb3ZlT3duZXIgPT09ICdjb250YWluZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb3VjaFkgPSB0b3VjaGVzLmxhc3RUb3VjaC5jbGllbnRZIC0gdG91Y2hlcy5maXJzdFRvdWNoLmNsaWVudFk7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhWSAgICAgPSBtZS5sYXN0VG91Y2hZIC0gbGFzdFRvdWNoWTtcblxuICAgICAgICAgICAgICAgICAgICBkZWx0YVkgIT09IDAgJiYgTmVvLm1haW4uRG9tQWNjZXNzLnNjcm9sbFRvKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ3RvcCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZCAgICAgICA6IHZpZXcudmRvbS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICAgIDogbWUuc2Nyb2xsVG9wICsgZGVsdGFZXG4gICAgICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICAgICAgbWUubGFzdFRvdWNoWSA9IGxhc3RUb3VjaFlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uVG91Y2hDYW5jZWwoZGF0YSkge1xuICAgICAgICB0aGlzLm9uVG91Y2hFbmQoZGF0YSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uVG91Y2hFbmQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnRvdWNoTW92ZU93bmVyID0gbnVsbDtcbiAgICAgICAgbWUubGFzdFRvdWNoWCAgICAgPSAwO1xuICAgICAgICBtZS5sYXN0VG91Y2hZICAgICA9IDBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPbmx5IHRyaWdnZXJzIGZvciB2ZXJ0aWNhbCBzY3JvbGxpbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvblZpZXdTY3JvbGwoe3Njcm9sbFRvcCwgdG91Y2hlc30pIHtcbiAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgdmlldyA9IG1lLmdyaWRWaWV3LFxuICAgICAgICAgICAgZGVsdGFYLCBsYXN0VG91Y2hYO1xuXG4gICAgICAgIG1lLnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcblxuICAgICAgICBtZS5zY3JvbGxUaW1lb3V0SWQgJiYgY2xlYXJUaW1lb3V0KG1lLnNjcm9sbFRpbWVvdXRJZCk7XG5cbiAgICAgICAgbWUuc2Nyb2xsVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB2aWV3LmlzU2Nyb2xsaW5nID0gZmFsc2VcbiAgICAgICAgfSwgMzApO1xuXG4gICAgICAgIHZpZXcuc2V0KHtpc1Njcm9sbGluZzogdHJ1ZSwgc2Nyb2xsVG9wfSk7XG5cbiAgICAgICAgaWYgKHRvdWNoZXMpIHtcbiAgICAgICAgICAgIGlmIChtZS50b3VjaE1vdmVPd25lciAhPT0gJ2NvbnRhaW5lcicpIHtcbiAgICAgICAgICAgICAgICBtZS50b3VjaE1vdmVPd25lciA9ICd2aWV3J1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWUudG91Y2hNb3ZlT3duZXIgPT09ICd2aWV3Jykge1xuICAgICAgICAgICAgICAgIGxhc3RUb3VjaFggPSB0b3VjaGVzLmxhc3RUb3VjaC5jbGllbnRYIC0gdG91Y2hlcy5maXJzdFRvdWNoLmNsaWVudFg7XG4gICAgICAgICAgICAgICAgZGVsdGFYICAgICA9IG1lLmxhc3RUb3VjaFggLSBsYXN0VG91Y2hYO1xuXG4gICAgICAgICAgICAgICAgZGVsdGFYICE9PSAwICYmIE5lby5tYWluLkRvbUFjY2Vzcy5zY3JvbGxUbyh7XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2xlZnQnLFxuICAgICAgICAgICAgICAgICAgICBpZCAgICAgICA6IG1lLmdyaWRDb250YWluZXIuaWQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICAgIDogbWUuc2Nyb2xsTGVmdCArIGRlbHRhWFxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICBtZS5sYXN0VG91Y2hYID0gbGFzdFRvdWNoWFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhTY3JvbGxNYW5hZ2VyKTtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50L0Jhc2UubWpzJztcblxuLyoqXG4gKiBXZSBkbyBub3Qgd2FudCB0byB1c2UgdGhlIGRlZmF1bHQgc2Nyb2xsYmFyIGZvciB2ZXJ0aWNhbCBzY3JvbGxpbmcsIHNpbmNlIGl0IHdvdWxkIHNob3cgdXAgYXQgdGhlIHJpZ2h0IGVkZ2VcbiAqIG9mIHRoZSBsYXN0IGNvbHVtbi4gSW5zdGVhZCwgd2Ugd2FudCB0byBzaG93IGl0IGF0IHRoZSByaWdodCBlZGdlIG9mIHRoZSBjb250YWluZXIgKGFsd2F5cyB2aXNpYmxlIHdoZW4gc2Nyb2xsaW5nKS5cbiAqIEBjbGFzcyBOZW8uZ3JpZC5WZXJ0aWNhbFNjcm9sbGJhclxuICogQGV4dGVuZHMgTmVvLmNvbXBvbmVudC5CYXNlXG4gKi9cbmNsYXNzIFZlcnRpY2FsU2Nyb2xsYmFyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5ncmlkLlZlcnRpY2FsU2Nyb2xsYmFyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZ3JpZC5WZXJ0aWNhbFNjcm9sbGJhcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdncmlkLXZlcnRpY2FsLXNjcm9sbGJhcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdncmlkLXZlcnRpY2FsLXNjcm9sbGJhcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1ncmlkLXZlcnRpY2FsLXNjcm9sbGJhciddXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWdyaWQtdmVydGljYWwtc2Nyb2xsYmFyJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOdW1iZXIgaW4gcHhcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSByb3dIZWlnaHRfPTBcbiAgICAgICAgICovXG4gICAgICAgIHJvd0hlaWdodF86IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZGF0YS5TdG9yZXxudWxsfSBzdG9yZV89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgc3RvcmVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbVxuICAgICAgICAgKi9cbiAgICAgICAgX3Zkb206XG4gICAgICAgIHtjbjogW1xuICAgICAgICAgICAge2NsczogWyduZW8tZ3JpZC1zY3JvbGxiYXItY29udGVudCddfVxuICAgICAgICBdfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gbW91bnRlZFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBhZGRTY3JvbGxTeW5jKG1vdW50ZWQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3dpbmRvd0lkfSA9IG1lLFxuICAgICAgICAgICAgU2Nyb2xsU3luYyA9IGF3YWl0IE5lby5jdXJyZW50V29ya2VyLmdldEFkZG9uKCdTY3JvbGxTeW5jJywgd2luZG93SWQpLFxuICAgICAgICAgICAgcGFyYW1zICAgICA9IHtpZDogbWUuaWQsIHdpbmRvd0lkfTtcblxuICAgICAgICBpZiAobW91bnRlZCkge1xuICAgICAgICAgICAgU2Nyb2xsU3luYy5yZWdpc3Rlcih7XG4gICAgICAgICAgICAgICAgZnJvbUlkOiBtZS5wYXJlbnQudmlldy52ZG9tLmlkLFxuICAgICAgICAgICAgICAgIHRvSWQgIDogbWUuaWQsXG4gICAgICAgICAgICAgICAgdHdvV2F5OiAhTmVvLmNvbmZpZy5oYXNUb3VjaEV2ZW50cywgLy8gU3luY2luZyB0aGUgc2Nyb2xsZXIgYmFjayB0byB0aGUgdmlldyBhZmZlY3RzIG1vYmlsZSBzY3JvbGxpbmdcbiAgICAgICAgICAgICAgICAuLi5wYXJhbXNcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBTY3JvbGxTeW5jLnVucmVnaXN0ZXIocGFyYW1zKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtb3VudGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIG9sZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5hZGRTY3JvbGxTeW5jKHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcm93SGVpZ2h0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFJvd0hlaWdodCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPiAwICYmIHRoaXMudXBkYXRlU2Nyb2xsSGVpZ2h0KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHN0b3JlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuU3RvcmV8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLlN0b3JlfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U3RvcmUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAgICAgdmFsdWUub24oe1xuICAgICAgICAgICAgICAgIGxvYWQgOiBtZS51cGRhdGVTY3JvbGxIZWlnaHQsXG4gICAgICAgICAgICAgICAgc2NvcGU6IG1lXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFsdWUuZ2V0Q291bnQoKSA+IDAgJiYgbWUudXBkYXRlU2Nyb2xsSGVpZ2h0KClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgdXBkYXRlU2Nyb2xsSGVpZ2h0KCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvdW50UmVjb3JkcyA9IG1lLnN0b3JlLmdldENvdW50KCksXG4gICAgICAgICAgICB7cm93SGVpZ2h0fSAgPSBtZTtcblxuICAgICAgICBpZiAoY291bnRSZWNvcmRzID4gMCAmJiByb3dIZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICBtZS52ZG9tLmNuWzBdLmhlaWdodCA9IGAkeyhjb3VudFJlY29yZHMgKyAxKSAqIHJvd0hlaWdodH1weGA7XG4gICAgICAgICAgICBtZS51cGRhdGUoKVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhWZXJ0aWNhbFNjcm9sbGJhcik7XG4iLCJpbXBvcnQgQ2xhc3NTeXN0ZW1VdGlsIGZyb20gJy4uL3V0aWwvQ2xhc3NTeXN0ZW0ubWpzJztcbmltcG9ydCBDb2xsZWN0aW9uICAgICAgZnJvbSAnLi4vY29sbGVjdGlvbi9CYXNlLm1qcyc7XG5pbXBvcnQgQ29tcG9uZW50ICAgICAgIGZyb20gJy4uL2NvbXBvbmVudC9CYXNlLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgICAgIGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBSb3dNb2RlbCAgICAgICAgZnJvbSAnLi4vc2VsZWN0aW9uL2dyaWQvUm93TW9kZWwubWpzJztcbmltcG9ydCBWRG9tVXRpbCAgICAgICAgZnJvbSAnLi4vdXRpbC9WRG9tLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5ncmlkLlZpZXdcbiAqIEBleHRlbmRzIE5lby5jb21wb25lbnQuQmFzZVxuICovXG5jbGFzcyBHcmlkVmlldyBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZ3JpZC5WaWV3J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZ3JpZC5WaWV3JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2dyaWQtdmlldydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdncmlkLXZpZXcnLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgZmxhZy4gR2V0cyBjYWxjdWxhdGVkIHdoZW4gbW91bnRpbmcgdGhlIGdyaWQuQ29udGFpbmVyXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gYXZhaWxhYmxlSGVpZ2h0Xz0wXG4gICAgICAgICAqL1xuICAgICAgICBhdmFpbGFibGVIZWlnaHRfOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgZmxhZy4gR2V0cyBjYWxjdWxhdGVkIHdoZW4gY2hhbmdpbmcgdGhlIGF2YWlsYWJsZUhlaWdodCBjb25maWdcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBhdmFpbGFibGVSb3dzXz0wXG4gICAgICAgICAqL1xuICAgICAgICBhdmFpbGFibGVSb3dzXzogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGZsYWcuIEdldHMgY2FsY3VsYXRlZCBhZnRlciBtb3VudGluZyBncmlkLlZpZXcgcm93c1xuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGF2YWlsYWJsZVdpZHRoXz0wXG4gICAgICAgICAqL1xuICAgICAgICBhdmFpbGFibGVXaWR0aF86IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1ncmlkLXZpZXcnXVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1ncmlkLXZpZXcnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhbW91bnQgb2YgY29sdW1ucyAoY2VsbHMpIHRvIHBhaW50IGJlZm9yZSB0aGUgZmlyc3QgJiBhZnRlciB0aGUgbGFzdCB2aXNpYmxlIGNvbHVtbixcbiAgICAgICAgICogdG8gZW5oYW5jZSB0aGUgc2Nyb2xsaW5nIHBlcmZvcm1hbmNlXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gYnVmZmVyQ29sdW1uUmFuZ2VfPTBcbiAgICAgICAgICovXG4gICAgICAgIGJ1ZmZlckNvbHVtblJhbmdlXzogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhbW91bnQgb2Ygcm93cyB0byBwYWludCBiZWZvcmUgdGhlIGZpcnN0ICYgYWZ0ZXIgdGhlIGxhc3QgdmlzaWJsZSByb3csXG4gICAgICAgICAqIHRvIGVuaGFuY2UgdGhlIHNjcm9sbGluZyBwZXJmb3JtYW5jZVxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGJ1ZmZlclJvd1JhbmdlXz0zXG4gICAgICAgICAqL1xuICAgICAgICBidWZmZXJSb3dSYW5nZV86IDMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmUgd2hpY2ggbW9kZWwgZmllbGQgY29udGFpbnMgdGhlIHZhbHVlIG9mIGNvbHNwYW4gZGVmaW5pdGlvbnNcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjb2xzcGFuRmllbGQ9J2NvbHNwYW4nXG4gICAgICAgICAqL1xuICAgICAgICBjb2xzcGFuRmllbGQ6ICdjb2xzcGFuJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGZsYWcuIEdldHMgY2FsY3VsYXRlZCBhZnRlciBtb3VudGluZyBncmlkLlZpZXcgcm93c1xuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGNvbnRhaW5lcldpZHRoXz0wXG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluZXJXaWR0aF86IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29sbGVjdGlvbi5CYXNlfG51bGx9IGNvbHVtblBvc2l0aW9uc189bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjb2x1bW5Qb3NpdGlvbnNfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaGlnaGxpZ2h0TW9kaWZpZWRDZWxsc189ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGhpZ2hsaWdodE1vZGlmaWVkQ2VsbHNfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzU2Nyb2xsaW5nXz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgaXNTY3JvbGxpbmdfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZGl0aW9uYWwgdXNlZCBrZXlzIGZvciB0aGUgc2VsZWN0aW9uIG1vZGVsXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0ga2V5c1xuICAgICAgICAgKi9cbiAgICAgICAga2V5czoge30sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9yZXMgdGhlIGluZGV4ZXMgb2YgdGhlIGZpcnN0ICYgbGFzdCBtb3VudGVkIGNvbHVtbnMsIGluY2x1ZGluZyBidWZmZXJDb2x1bW5SYW5nZVxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJbXX0gbW91bnRlZENvbHVtbnNfPVswLDBdXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG1vdW50ZWRDb2x1bW5zXzogWzAsIDBdLFxuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcmVzIHRoZSBpbmRleGVzIG9mIHRoZSBmaXJzdCAmIGxhc3QgbW91bnRlZCByb3dzLCBpbmNsdWRpbmcgYnVmZmVyUm93UmFuZ2VcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyW119IG1vdW50ZWRSb3dzPVswLDBdXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG1vdW50ZWRSb3dzOiBbMCwgMF0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHJvbGU9J3Jvd2dyb3VwJ1xuICAgICAgICAgKi9cbiAgICAgICAgcm9sZTogJ3Jvd2dyb3VwJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE51bWJlciBpbiBweFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHJvd0hlaWdodF89MFxuICAgICAgICAgKi9cbiAgICAgICAgcm93SGVpZ2h0XzogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gc2Nyb2xsTGVmdF89MFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzY3JvbGxMZWZ0XzogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gc2Nyb2xsVG9wXz0wXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNjcm9sbFRvcF86IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uc2VsZWN0aW9uLk1vZGVsfSBzZWxlY3Rpb25Nb2RlbF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZWN0aW9uTW9kZWxfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBzZWxlY3RlZFJlY29yZEZpZWxkPSdhbm5vdGF0aW9ucy5zZWxlY3RlZCdcbiAgICAgICAgICovXG4gICAgICAgIHNlbGVjdGVkUmVjb3JkRmllbGQ6ICdhbm5vdGF0aW9ucy5zZWxlY3RlZCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHN0YXJ0SW5kZXhfPTBcbiAgICAgICAgICovXG4gICAgICAgIHN0YXJ0SW5kZXhfOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmRhdGEuU3RvcmV8bnVsbH0gc3RvcmVfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHN0b3JlXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3JlcyB0aGUgaW5kZXhlcyBvZiB0aGUgZmlyc3QgJiBsYXN0IHBhaW50ZWQgY29sdW1uc1xuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJbXX0gdmlzaWJsZUNvbHVtbnM9WzAsMF1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdmlzaWJsZUNvbHVtbnM6IFswLCAwXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3JlcyB0aGUgaW5kZXhlcyBvZiB0aGUgZmlyc3QgJiBsYXN0IHZpc2libGUgcm93cywgZXhjbHVkaW5nIGJ1ZmZlclJvd1JhbmdlXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcltdfSB2aXNpYmxlUm93cz1bMCwwXVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB2aXNpYmxlUm93czogWzAsIDBdLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IHdyYXBwZXJDbHM9W11cbiAgICAgICAgICovXG4gICAgICAgIHdyYXBwZXJDbHM6IFsnbmVvLWdyaWQtdmlldy13cmFwcGVyJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IF92ZG9tXG4gICAgICAgICAqL1xuICAgICAgICBfdmRvbTpcbiAgICAgICAge3RhYkluZGV4OiAnLTEnLCBjbjogW1xuICAgICAgICAgICAge2NuOiBbXX1cbiAgICAgICAgXX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gc2VsZWN0ZWRDZWxsc1xuICAgICAqL1xuICAgIGdldCBzZWxlY3RlZENlbGxzKCkge1xuICAgICAgICBsZXQge3NlbGVjdGlvbk1vZGVsfSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbk1vZGVsLm50eXBlPy5pbmNsdWRlcygnY2VsbCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0aW9uTW9kZWwuaXRlbXNcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBzZWxlY3RlZFJvd3NcbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0ZWRSb3dzKCkge1xuICAgICAgICBsZXQge3NlbGVjdGlvbk1vZGVsfSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbk1vZGVsLm50eXBlID09PSAnc2VsZWN0aW9uLWdyaWQtcm93bW9kZWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0aW9uTW9kZWwuaXRlbXNcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxlY3Rpb25Nb2RlbC5udHlwZT8uaW5jbHVkZXMoJ3JvdycpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0aW9uTW9kZWwuc2VsZWN0ZWRSb3dzXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW11cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmFkZERvbUxpc3RlbmVycyhbe1xuICAgICAgICAgICAgY2xpY2sgICA6IG1lLm9uQ2VsbENsaWNrLFxuICAgICAgICAgICAgZGJsY2xpY2s6IG1lLm9uQ2VsbERvdWJsZUNsaWNrLFxuICAgICAgICAgICAgZGVsZWdhdGU6ICcubmVvLWdyaWQtY2VsbCcsXG4gICAgICAgICAgICBzY29wZSAgIDogbWVcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgY2xpY2sgICA6IG1lLm9uUm93Q2xpY2ssXG4gICAgICAgICAgICBkYmxjbGljazogbWUub25Sb3dEb3VibGVDbGljayxcbiAgICAgICAgICAgIGRlbGVnYXRlOiAnLm5lby1ncmlkLXJvdycsXG4gICAgICAgICAgICBzY29wZSAgIDogbWVcbiAgICAgICAgfV0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBhdmFpbGFibGVIZWlnaHQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0QXZhaWxhYmxlSGVpZ2h0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmF2YWlsYWJsZVJvd3MgPSBNYXRoLmNlaWwodmFsdWUgLyB0aGlzLnJvd0hlaWdodCkgLSAxXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGF2YWlsYWJsZVJvd3MgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0QXZhaWxhYmxlUm93cyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPiAwICYmIHRoaXMuY3JlYXRlVmlld0RhdGEoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgYXZhaWxhYmxlV2lkdGggY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0QXZhaWxhYmxlV2lkdGgodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA+IDApIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIG1lLnZkb20ud2lkdGggPSB2YWx1ZSArICdweCc7XG4gICAgICAgICAgICBtZS52ZG9tLmNuWzBdLndpZHRoID0gdmFsdWUgKyAncHgnO1xuICAgICAgICAgICAgbWUudXBkYXRlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgYnVmZmVyQ29sdW1uUmFuZ2UgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0QnVmZmVyQ29sdW1uUmFuZ2UodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5jcmVhdGVWaWV3RGF0YSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBidWZmZXJSb3dSYW5nZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRCdWZmZXJSb3dSYW5nZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmNyZWF0ZVZpZXdEYXRhKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGNvbnRhaW5lcldpZHRoIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldENvbnRhaW5lcldpZHRoKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB2YWx1ZSA+IDAgJiYgdGhpcy51cGRhdGVNb3VudGVkQW5kVmlzaWJsZUNvbHVtbnMoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMudmRvbS5pZCA9IHZhbHVlICsgJ19fd3JhcHBlcic7XG5cbiAgICAgICAgLy8gc2lsZW50IHZkb20gdXBkYXRlLCB0aGUgc3VwZXIgY2FsbCB3aWxsIHRyaWdnZXIgdGhlIGVuZ2luZVxuICAgICAgICBzdXBlci5hZnRlclNldElkKHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBpc1Njcm9sbGluZyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRJc1Njcm9sbGluZyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy50b2dnbGVDbHMoJ25lby1pcy1zY3JvbGxpbmcnLCB2YWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1vdW50ZWRDb2x1bW5zIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNb3VudGVkQ29sdW1ucyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWUgJiYgdGhpcy5jcmVhdGVWaWV3RGF0YSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSByb3dIZWlnaHQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Um93SGVpZ2h0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB2YWx1ZSA+IDAgJiYgdGhpcy51cGRhdGVTY3JvbGxIZWlnaHQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc2Nyb2xsTGVmdCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTY3JvbGxMZWZ0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZU1vdW50ZWRBbmRWaXNpYmxlQ29sdW1ucygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzY3JvbGxUb3AgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U2Nyb2xsVG9wKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7YnVmZmVyUm93UmFuZ2V9ID0gbWUsXG4gICAgICAgICAgICBuZXdTdGFydEluZGV4ICAgID0gTWF0aC5mbG9vcih2YWx1ZSAvIG1lLnJvd0hlaWdodCk7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKG1lLnN0YXJ0SW5kZXggLSBuZXdTdGFydEluZGV4KSA+PSBidWZmZXJSb3dSYW5nZSkge1xuICAgICAgICAgICAgbWUuc3RhcnRJbmRleCA9IG5ld1N0YXJ0SW5kZXhcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLnZpc2libGVSb3dzWzBdID0gbmV3U3RhcnRJbmRleDtcbiAgICAgICAgICAgIG1lLnZpc2libGVSb3dzWzFdID0gbmV3U3RhcnRJbmRleCArIG1lLmF2YWlsYWJsZVJvd3NcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc2VsZWN0aW9uTW9kZWwgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOZW8uc2VsZWN0aW9uLk1vZGVsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLnNlbGVjdGlvbi5Nb2RlbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTZWxlY3Rpb25Nb2RlbCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlZCAmJiB2YWx1ZS5yZWdpc3Rlcih0aGlzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc3RhcnRJbmRleCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTdGFydEluZGV4KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuY3JlYXRlVmlld0RhdGEoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtkYXRhLmNlbGxJZF1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YS5jb2x1bW5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5jb2x1bW5JbmRleFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhLnJlY29yZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLnJvd0luZGV4XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBhcHBseVJlbmRlcmVyT3V0cHV0KGRhdGEpIHtcbiAgICAgICAgbGV0IHtjZWxsSWQsIGNvbHVtbiwgY29sdW1uSW5kZXgsIHJlY29yZCwgcm93SW5kZXh9ID0gZGF0YSxcbiAgICAgICAgICAgIG1lICAgICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZ3JpZENvbnRhaW5lciAgICAgICAgICA9IG1lLnBhcmVudCxcbiAgICAgICAgICAgIHtzZWxlY3RlZENlbGxzLCBzdG9yZX0gPSBtZSxcbiAgICAgICAgICAgIGNlbGxDbHMgICAgICAgICAgICAgICAgPSBbJ25lby1ncmlkLWNlbGwnXSxcbiAgICAgICAgICAgIGNvbHNwYW4gICAgICAgICAgICAgICAgPSByZWNvcmRbbWUuY29sc3BhbkZpZWxkXSxcbiAgICAgICAgICAgIHtkYXRhRmllbGR9ICAgICAgICAgICAgPSBjb2x1bW4sXG4gICAgICAgICAgICBmaWVsZFZhbHVlICAgICAgICAgICAgID0gcmVjb3JkW2RhdGFGaWVsZF0sXG4gICAgICAgICAgICBjZWxsQ29uZmlnLCByZW5kZXJlck91dHB1dDtcblxuICAgICAgICBpZiAoZmllbGRWYWx1ZSA9PT0gbnVsbCB8fCBmaWVsZFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZpZWxkVmFsdWUgPSAnJ1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyZXJPdXRwdXQgPSBjb2x1bW4ucmVuZGVyZXIuY2FsbChjb2x1bW4ucmVuZGVyZXJTY29wZSB8fCBncmlkQ29udGFpbmVyLCB7XG4gICAgICAgICAgICBjb2x1bW4sXG4gICAgICAgICAgICBjb2x1bW5JbmRleCxcbiAgICAgICAgICAgIGRhdGFGaWVsZCxcbiAgICAgICAgICAgIGdyaWRDb250YWluZXIsXG4gICAgICAgICAgICByZWNvcmQsXG4gICAgICAgICAgICByb3dJbmRleCxcbiAgICAgICAgICAgIHN0b3JlLFxuICAgICAgICAgICAgdmFsdWU6IGZpZWxkVmFsdWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc3dpdGNoIChOZW8udHlwZU9mKHJlbmRlcmVyT3V0cHV0KSkge1xuICAgICAgICAgICAgY2FzZSAnT2JqZWN0Jzoge1xuICAgICAgICAgICAgICAgIGlmIChyZW5kZXJlck91dHB1dC5odG1sKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyT3V0cHV0LmNscyAmJiBjZWxsQ2xzLnB1c2goLi4ucmVuZGVyZXJPdXRwdXQuY2xzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJlck91dHB1dCA9IFtyZW5kZXJlck91dHB1dF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdEYXRlJzpcbiAgICAgICAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICAgICAgICBjYXNlICdTdHJpbmcnOiB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXJPdXRwdXQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNscyA6IGNlbGxDbHMsXG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHJlbmRlcmVyT3V0cHV0Py50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlbmRlcmVyT3V0cHV0ID09PSBudWxsIHx8IHJlbmRlcmVyT3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyT3V0cHV0ID0gJydcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2x1bW4uY2VsbEFsaWduICE9PSAnbGVmdCcpIHtcbiAgICAgICAgICAgIGNlbGxDbHMucHVzaCgnbmVvLScgKyBjb2x1bW4uY2VsbEFsaWduKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lLmhpZ2hsaWdodE1vZGlmaWVkQ2VsbHMpIHtcbiAgICAgICAgICAgIGlmIChyZWNvcmQuaXNNb2RpZmllZEZpZWxkKGRhdGFGaWVsZCkpIHtcbiAgICAgICAgICAgICAgICBjZWxsQ2xzLnB1c2goJ25lby1pcy1tb2RpZmllZCcpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNlbGxJZCkge1xuICAgICAgICAgICAgY2VsbElkID0gbWUuZ2V0Q2VsbElkKHJlY29yZCwgY29sdW1uLmRhdGFGaWVsZClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxlY3RlZENlbGxzLmluY2x1ZGVzKGNlbGxJZCkpIHtcbiAgICAgICAgICAgIGNlbGxDbHMucHVzaCgnbmVvLXNlbGVjdGVkJylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZS5zZWxlY3Rpb25Nb2RlbD8uc2VsZWN0ZWRDb2x1bW5zPy5pbmNsdWRlcyhkYXRhRmllbGQpKSB7XG4gICAgICAgICAgICBOZW9BcnJheS5hZGQoY2VsbENscywgbWUuc2VsZWN0aW9uTW9kZWwuc2VsZWN0ZWRDb2x1bW5DZWxsQ2xzIHx8ICduZW8tc2VsZWN0ZWQnKVxuICAgICAgICB9XG5cbiAgICAgICAgY2VsbENvbmZpZyA9IHtcbiAgICAgICAgICAgICdhcmlhLWNvbGluZGV4JzogY29sdW1uSW5kZXggKyAxLCAvLyAxIGJhc2VkXG4gICAgICAgICAgICBpZCAgICAgICAgICAgICA6IGNlbGxJZCxcbiAgICAgICAgICAgIGNscyAgICAgICAgICAgIDogY2VsbENscyxcbiAgICAgICAgICAgIHJvbGUgICAgICAgICAgIDogJ2dyaWRjZWxsJyxcbiAgICAgICAgICAgIHN0eWxlICAgICAgICAgIDogcmVuZGVyZXJPdXRwdXQuc3R5bGUgfHwge31cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoY29sdW1uLndpZHRoKSB7XG4gICAgICAgICAgICBjZWxsQ29uZmlnLnN0eWxlLm1pbldpZHRoID0gYCR7Y29sdW1uLndpZHRofXB4YFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbHNwYW4gJiYgT2JqZWN0LmtleXMoY29sc3BhbikuaW5jbHVkZXMoZGF0YUZpZWxkKSkge1xuICAgICAgICAgICAgY2VsbENvbmZpZy5jb2xzcGFuID0gY29sc3BhbltkYXRhRmllbGRdXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoTmVvLnR5cGVPZihyZW5kZXJlck91dHB1dCkgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICBjZWxsQ29uZmlnLmlubmVySFRNTCA9IHJlbmRlcmVyT3V0cHV0Lmh0bWwgIHx8ICcnXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjZWxsQ29uZmlnLmNuID0gcmVuZGVyZXJPdXRwdXRcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjZWxsQ29uZmlnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gYWNjZXNzaW5nIHRoZSBjb2x1bW5Qb3NpdGlvbnMgY29uZmlnXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZUdldENvbHVtblBvc2l0aW9ucyh2YWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9jb2x1bW5Qb3NpdGlvbnMgPSB2YWx1ZSA9IE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIG1vZHVsZSAgICAgOiBDb2xsZWN0aW9uLFxuICAgICAgICAgICAgICAgIGtleVByb3BlcnR5OiAnZGF0YUZpZWxkJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHNlbGVjdGlvbk1vZGVsIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtOZW8uc2VsZWN0aW9uLk1vZGVsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLnNlbGVjdGlvbi5Nb2RlbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0U2VsZWN0aW9uTW9kZWwodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlPy5kZXN0cm95KCk7XG5cbiAgICAgICAgcmV0dXJuIENsYXNzU3lzdGVtVXRpbC5iZWZvcmVTZXRJbnN0YW5jZSh2YWx1ZSwgUm93TW9kZWwpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5yZWNvcmRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdHMucm93SW5kZXhdXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBjcmVhdGVSb3coe3JlY29yZCwgcm93SW5kZXh9KSB7XG4gICAgICAgIGlmICghTmVvLmlzTnVtYmVyKHJvd0luZGV4KSkge1xuICAgICAgICAgICAgcm93SW5kZXggPSB0aGlzLnN0b3JlLmluZGV4T2YocmVjb3JkKVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge21vdW50ZWRDb2x1bW5zLCBzZWxlY3RlZFJvd3N9ID0gbWUsXG4gICAgICAgICAgICBncmlkQ29udGFpbmVyID0gbWUucGFyZW50LFxuICAgICAgICAgICAgY29sdW1ucyAgICAgICA9IGdyaWRDb250YWluZXIuaGVhZGVyVG9vbGJhci5pdGVtcyxcbiAgICAgICAgICAgIGlkICAgICAgICAgICAgPSBtZS5nZXRSb3dJZChyZWNvcmQsIHJvd0luZGV4KSxcbiAgICAgICAgICAgIHJvd0NscyAgICAgICAgPSBtZS5nZXRSb3dDbGFzcyhyZWNvcmQsIHJvd0luZGV4KSxcbiAgICAgICAgICAgIGNvbmZpZywgY29sdW1uLCBjb2x1bW5Qb3NpdGlvbiwgIGdyaWRSb3csIGk7XG5cbiAgICAgICAgaWYgKHJvd0luZGV4ICUgMiAhPT0gMCkge1xuICAgICAgICAgICAgcm93Q2xzLnB1c2goJ25lby1ldmVuJylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxlY3RlZFJvd3MgJiYgcmVjb3JkW21lLnNlbGVjdGVkUmVjb3JkRmllbGRdKSB7XG4gICAgICAgICAgICBOZW9BcnJheS5hZGQoc2VsZWN0ZWRSb3dzLCBpZClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxlY3RlZFJvd3M/LmluY2x1ZGVzKGlkKSkge1xuICAgICAgICAgICAgcm93Q2xzLnB1c2goJ25lby1zZWxlY3RlZCcpO1xuICAgICAgICAgICAgZ3JpZENvbnRhaW5lci5maXJlKCdzZWxlY3QnLCB7cmVjb3JkfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGdyaWRSb3cgPSB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICdhcmlhLXJvd2luZGV4Jzogcm93SW5kZXggKyAyLCAvLyBoZWFkZXIgcm93ID0+IDEsIGZpcnN0IGJvZHkgcm93ID0+IDJcbiAgICAgICAgICAgIGNscyAgICAgICAgICAgIDogcm93Q2xzLFxuICAgICAgICAgICAgY24gICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgICAgIHJvbGUgICAgICAgICAgIDogJ3JvdycsXG5cbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ICAgOiBtZS5yb3dIZWlnaHQgKyAncHgnLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgwcHgsICR7cm93SW5kZXggKiBtZS5yb3dIZWlnaHR9cHgpYFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAoaT1tb3VudGVkQ29sdW1uc1swXTsgaSA8PSBtb3VudGVkQ29sdW1uc1sxXTsgaSsrKSB7XG4gICAgICAgICAgICBjb2x1bW4gPSBjb2x1bW5zW2ldO1xuICAgICAgICAgICAgY29uZmlnID0gbWUuYXBwbHlSZW5kZXJlck91dHB1dCh7Y29sdW1uLCBjb2x1bW5JbmRleDogaSwgcmVjb3JkLCByb3dJbmRleH0pO1xuXG4gICAgICAgICAgICBpZiAoY29sdW1uLmRvY2spIHtcbiAgICAgICAgICAgICAgICBjb25maWcuY2xzID0gWyduZW8tbG9ja2VkJywgLi4uY29uZmlnLmNscyB8fCBbXV1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29sdW1uUG9zaXRpb24gPSBtZS5jb2x1bW5Qb3NpdGlvbnMuZ2V0KGNvbHVtbi5kYXRhRmllbGQpO1xuXG4gICAgICAgICAgICBjb25maWcuc3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgLi4uY29uZmlnLnN0eWxlLFxuICAgICAgICAgICAgICAgIGxlZnQgOiBjb2x1bW5Qb3NpdGlvbi54ICAgICArICdweCcsXG4gICAgICAgICAgICAgICAgd2lkdGg6IGNvbHVtblBvc2l0aW9uLndpZHRoICsgJ3B4J1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBIYXBwZW5zIGR1cmluZyBhIGNvbHVtbiBoZWFkZXIgZHJhZyBPUCwgd2hlbiBsZWF2aW5nIHRoZSBwYWludGVkIHJhbmdlXG4gICAgICAgICAgICBpZiAoY29sdW1uUG9zaXRpb24uaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJ1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBncmlkUm93LmNuLnB1c2goY29uZmlnKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdyaWRSb3dcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNpbGVudD1mYWxzZVxuICAgICAqL1xuICAgIGNyZWF0ZVZpZXdEYXRhKHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge21vdW50ZWRSb3dzLCBzdG9yZX0gPSBtZSxcbiAgICAgICAgICAgIHJvd3MgICAgICAgICAgICAgICAgID0gW10sXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHN0b3JlLmlzTG9hZGluZyAgICAgICAgICAgICAgICAgICB8fFxuICAgICAgICAgICAgbWUuYXZhaWxhYmxlUm93cyAgICAgICAgICAgICAgPCAxIHx8XG4gICAgICAgICAgICBtZS5fY29udGFpbmVyV2lkdGggICAgICAgICAgICA8IDEgfHwgLy8gd2UgYXJlIG5vdCBjaGVja2luZyBtZS5jb250YWluZXJXaWR0aCwgc2luY2Ugd2Ugd2FudCB0byBpZ25vcmUgdGhlIGNvbmZpZyBzeW1ib2xcbiAgICAgICAgICAgIG1lLmNvbHVtblBvc2l0aW9ucy5nZXRDb3VudCgpIDwgMSB8fFxuICAgICAgICAgICAgbWUubW91bnRlZENvbHVtbnNbMV0gICAgICAgICAgPCAxXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGVzIHRoZSBuZXcgc3RhcnQgJiBlbmQgaW5kZXhlc1xuICAgICAgICBtZS51cGRhdGVNb3VudGVkQW5kVmlzaWJsZVJvd3MoKTtcblxuICAgICAgICBmb3IgKGk9bW91bnRlZFJvd3NbMF07IGkgPCBtb3VudGVkUm93c1sxXTsgaSsrKSB7XG4gICAgICAgICAgICByb3dzLnB1c2gobWUuY3JlYXRlUm93KHtyZWNvcmQ6IHN0b3JlLml0ZW1zW2ldLCByb3dJbmRleDogaX0pKVxuICAgICAgICB9XG5cbiAgICAgICAgbWUuZ2V0VmRvbVJvb3QoKS5jbiA9IHJvd3M7XG5cbiAgICAgICAgbWUucGFyZW50LmlzTG9hZGluZyA9IGZhbHNlO1xuXG4gICAgICAgIG1lLnVwZGF0ZVNjcm9sbEhlaWdodCh0cnVlKTsgLy8gc2lsZW50XG4gICAgICAgICFzaWxlbnQgJiYgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqL1xuICAgIGRlc3Ryb3koLi4uYXJncykge1xuICAgICAgICB0aGlzLnN0b3JlID0gbnVsbDtcbiAgICAgICAgc3VwZXIuZGVzdHJveSguLi5hcmdzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICAgICAqL1xuICAgIGZpcmVDZWxsRXZlbnQoZGF0YSwgZXZlbnROYW1lKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaWQgICAgICAgID0gZGF0YS5jdXJyZW50VGFyZ2V0LFxuICAgICAgICAgICAgZGF0YUZpZWxkID0gbWUuZ2V0Q2VsbERhdGFGaWVsZChpZCksXG4gICAgICAgICAgICByZWNvcmQgICAgPSBtZS5nZXRSZWNvcmQoaWQpO1xuXG4gICAgICAgIG1lLnBhcmVudC5maXJlKGV2ZW50TmFtZSwge2RhdGEsIGRhdGFGaWVsZCwgcmVjb3JkLCB2aWV3OiBtZX0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXG4gICAgICovXG4gICAgZmlyZVJvd0V2ZW50KGRhdGEsIGV2ZW50TmFtZSkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGlkICAgICA9IGRhdGEuY3VycmVudFRhcmdldCxcbiAgICAgICAgICAgIHJlY29yZCA9IG1lLmdldFJlY29yZChpZCk7XG5cbiAgICAgICAgbWUucGFyZW50LmZpcmUoZXZlbnROYW1lLCB7ZGF0YSwgcmVjb3JkLCB2aWV3OiBtZX0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNlbGxJZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0Q2VsbERhdGFGaWVsZChjZWxsSWQpIHtcbiAgICAgICAgcmV0dXJuIGNlbGxJZC5zcGxpdCgnX18nKVsyXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YUZpZWxkXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRDZWxsSWQocmVjb3JkLCBkYXRhRmllbGQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWQgKyAnX18nICsgcmVjb3JkW3RoaXMuc3RvcmUuZ2V0S2V5UHJvcGVydHkoKV0gKyAnX18nICsgZGF0YUZpZWxkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgZ3JpZCBjb2x1bW4gb3IgY29sdW1uIGluZGV4IGJ5IGEgZ2l2ZW4gZmllbGQgbmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmV0dXJuSW5kZXg9ZmFsc2VcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fE51bWJlcnxudWxsfVxuICAgICAqL1xuICAgIGdldENvbHVtbihmaWVsZCwgcmV0dXJuSW5kZXg9ZmFsc2UpIHtcbiAgICAgICAgbGV0IGNvbHVtbnMgPSB0aGlzLnBhcmVudC5oZWFkZXJUb29sYmFyLml0ZW1zLFxuICAgICAgICAgICAgaSAgICAgICA9IDAsXG4gICAgICAgICAgICBsZW4gICAgID0gY29sdW1ucy5sZW5ndGgsXG4gICAgICAgICAgICBjb2x1bW47XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29sdW1uID0gY29sdW1uc1tpXTtcblxuICAgICAgICAgICAgaWYgKGNvbHVtbi5kYXRhRmllbGQgPT09IGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHVybkluZGV4ID8gaSA6IGNvbHVtblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHBhaW50ZWQgY29sdW1uIGNlbGxzICh2aXNpYmxlICsgYnVmZmVyIHJhbmdlKVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhRmllbGRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0W119XG4gICAgICovXG4gICAgZ2V0Q29sdW1uQ2VsbHMoZGF0YUZpZWxkKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjZWxscyAgICAgICA9IFtdLFxuICAgICAgICAgICAgY29sdW1uSW5kZXggPSAtMSxcbiAgICAgICAgICAgIHZkb21Sb290ICAgID0gbWUuZ2V0VmRvbVJvb3QoKSxcbiAgICAgICAgICAgIGZpcnN0Um93ICAgID0gdmRvbVJvb3QuY25bMF0sXG4gICAgICAgICAgICBpICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICBsZW4gICAgICAgICA9IGZpcnN0Um93LmNuLmxlbmd0aCxcbiAgICAgICAgICAgIGNlbGw7XG5cbiAgICAgICAgLy8gQ29sdW1ucyBtaWdodCBnZXQgbW92ZWQgdmlhIGRyYWcmZHJvcCwgc28gbGV0J3MgY2hlY2sgZm9yIHRoZSBjdXJyZW50IG1hdGNoXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChkYXRhRmllbGQgPT09IG1lLmdldERhdGFGaWVsZChmaXJzdFJvdy5jbltpXS5pZCkpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5JbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29sdW1uSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgdmRvbVJvb3QuY24uZm9yRWFjaChyb3cgPT4ge1xuICAgICAgICAgICAgICAgIGNlbGwgPSByb3cuY25bY29sdW1uSW5kZXhdO1xuICAgICAgICAgICAgICAgIGNlbGwgJiYgY2VsbHMucHVzaChjZWxsKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjZWxsc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjZWxsSWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldERhdGFGaWVsZChjZWxsSWQpIHtcbiAgICAgICAgcmV0dXJuIGNlbGxJZC5zcGxpdCgnX18nKVsyXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbWF0Y2hpbmcgcmVjb3JkIGJ5IHBhc3NpbmcgYSByb3cgaWQsIGEgY2VsbCBpZCBvciBhbiBpZCBpbnNpZGUgYSBncmlkIGNlbGwuXG4gICAgICogTGltaXRlZCB0byBtb3VudGVkIHJvd3MgKG11c3QgYmUgaW5zaWRlIHRoZSB2ZG9tKS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbm9kZUlkXG4gICAgICogQHJldHVybnMge09iamVjdHxudWxsfVxuICAgICAqL1xuICAgIGdldFJlY29yZChub2RlSWQpIHtcbiAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICByZWNvcmQgPSBtZS5nZXRSZWNvcmRCeVJvd0lkKG5vZGVJZCksXG4gICAgICAgICAgICBub2RlLCBwYXJlbnROb2RlcztcblxuICAgICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50Tm9kZXMgPSBWRG9tVXRpbC5nZXRQYXJlbnROb2RlcyhtZS52ZG9tLCBub2RlSWQpO1xuXG4gICAgICAgIGZvciAobm9kZSBvZiBwYXJlbnROb2RlcyB8fCBbXSkge1xuICAgICAgICAgICAgcmVjb3JkID0gbWUuZ2V0UmVjb3JkQnlSb3dJZChub2RlLmlkKTtcblxuICAgICAgICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWNvcmRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNlbGxJZFxuICAgICAqIEByZXR1cm5zIHtSZWNvcmR9XG4gICAgICovXG4gICAgZ2V0UmVjb3JkQnlDZWxsSWQoY2VsbElkKSB7XG4gICAgICAgIGxldCByZWNvcmRJZCA9IGNlbGxJZC5zcGxpdCgnX18nKVsxXSxcbiAgICAgICAgICAgIHtzdG9yZX0gID0gdGhpcyxcbiAgICAgICAgICAgIGtleVR5cGUgID0gc3RvcmUuZ2V0S2V5VHlwZSgpO1xuXG4gICAgICAgIGlmIChrZXlUeXBlID09PSAnaW50JyB8fCBrZXlUeXBlID09PSAnaW50ZWdlcicpIHtcbiAgICAgICAgICAgIHJlY29yZElkID0gcGFyc2VJbnQocmVjb3JkSWQpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RvcmUuZ2V0KHJlY29yZElkKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByb3dJZFxuICAgICAqIEByZXR1cm5zIHtSZWNvcmR9XG4gICAgICovXG4gICAgZ2V0UmVjb3JkQnlSb3dJZChyb3dJZCkge1xuICAgICAgICBsZXQgcmVjb3JkSWQgPSByb3dJZC5zcGxpdCgnX18nKVsyXSxcbiAgICAgICAgICAgIHtzdG9yZX0gID0gdGhpcyxcbiAgICAgICAgICAgIGtleVR5cGUgID0gc3RvcmUuZ2V0S2V5VHlwZSgpO1xuXG4gICAgICAgIGlmIChrZXlUeXBlID09PSAnaW50JyB8fCBrZXlUeXBlID09PSAnaW50ZWdlcicpIHtcbiAgICAgICAgICAgIHJlY29yZElkID0gcGFyc2VJbnQocmVjb3JkSWQpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RvcmUuZ2V0KHJlY29yZElkKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGFwcGx5IGN1c3RvbSBDU1MgcnVsZXMgdG8gZ3JpZCByb3dzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByb3dJbmRleFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmdbXX1cbiAgICAgKi9cbiAgICBnZXRSb3dDbGFzcyhyZWNvcmQsIHJvd0luZGV4KSB7XG4gICAgICAgIHJldHVybiBbJ25lby1ncmlkLXJvdyddXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0Um93SWQocmVjb3JkKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmlkfV9fdHJfXyR7cmVjb3JkW3RoaXMuc3RvcmUuZ2V0S2V5UHJvcGVydHkoKV19YFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFZkb21Sb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZG9tLmNuWzBdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge09iamVjdFtdfSBUaGUgbmV3IHZkb20gaXRlbXMgcm9vdFxuICAgICAqL1xuICAgIGdldFZkb21JdGVtc1Jvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZkb20uY25bMF1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcmV0dXJucyB7TmVvLnZkb20uVk5vZGV9XG4gICAgICovXG4gICAgZ2V0Vm5vZGVSb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52bm9kZS5jaGlsZE5vZGVzWzBdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkNlbGxDbGljayhkYXRhKSB7XG4gICAgICAgIHRoaXMuZmlyZUNlbGxFdmVudChkYXRhLCAnY2VsbENsaWNrJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uQ2VsbERvdWJsZUNsaWNrKGRhdGEpIHtcbiAgICAgICAgdGhpcy5maXJlQ2VsbEV2ZW50KGRhdGEsICdjZWxsRG91YmxlQ2xpY2snKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25Db25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgc3VwZXIub25Db25zdHJ1Y3RlZCgpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsPy5yZWdpc3Rlcih0aGlzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Sb3dDbGljayhkYXRhKSB7XG4gICAgICAgIHRoaXMuZmlyZVJvd0V2ZW50KGRhdGEsICdyb3dDbGljaycpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvblJvd0RvdWJsZUNsaWNrKGRhdGEpIHtcbiAgICAgICAgdGhpcy5maXJlUm93RXZlbnQoZGF0YSwgJ3Jvd0RvdWJsZUNsaWNrJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCBhZnRlciBjaGFuZ2luZyB0aGUgdmFsdWUgb2YgYSByZWNvcmQgZmllbGQuXG4gICAgICogRS5nLiBteVJlY29yZC5mb28gPSAnYmFyJztcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IG9wdHMuZmllbGRzIEVhY2ggZmllbGQgb2JqZWN0IGNvbnRhaW5zIHRoZSBrZXlzOiBuYW1lLCBvbGRWYWx1ZSwgdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLk1vZGVsfSBvcHRzLm1vZGVsIFRoZSBtb2RlbCBpbnN0YW5jZSBvZiB0aGUgY2hhbmdlZCByZWNvcmRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5yZWNvcmRcbiAgICAgKi9cbiAgICBvblN0b3JlUmVjb3JkQ2hhbmdlKHtmaWVsZHMsIHJlY29yZH0pIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZmllbGROYW1lcyAgICAgICAgICAgICA9IGZpZWxkcy5tYXAoZmllbGQgPT4gZmllbGQubmFtZSksXG4gICAgICAgICAgICBuZWVkc1VwZGF0ZSAgICAgICAgICAgID0gZmFsc2UsXG4gICAgICAgICAgICByb3dJbmRleCAgICAgICAgICAgICAgID0gbWUuc3RvcmUuaW5kZXhPZihyZWNvcmQpLFxuICAgICAgICAgICAge3NlbGVjdGlvbk1vZGVsLCB2ZG9tfSA9IG1lLFxuICAgICAgICAgICAgY2VsbElkLCBjZWxsTm9kZSwgY2VsbFN0eWxlLCBjZWxsVmRvbSwgY29sdW1uLCBjb2x1bW5JbmRleDtcblxuICAgICAgICBpZiAoZmllbGROYW1lcy5pbmNsdWRlcyhtZS5jb2xzcGFuRmllbGQpKSB7XG4gICAgICAgICAgICBtZS52ZG9tLmNuW3Jvd0luZGV4XSA9IG1lLmNyZWF0ZVJvdyh7cmVjb3JkLCByb3dJbmRleH0pO1xuICAgICAgICAgICAgbWUudXBkYXRlKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpZWxkcy5mb3JFYWNoKGZpZWxkID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQubmFtZSA9PT0gbWUuc2VsZWN0ZWRSZWNvcmRGaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uTW9kZWwubnR5cGUgPT09ICdzZWxlY3Rpb24tZ3JpZC1yb3dtb2RlbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbk1vZGVsW2ZpZWxkLnZhbHVlID8gJ3NlbGVjdCcgOiAnZGVzZWxlY3QnXShtZS5nZXRSb3dJZChyZWNvcmQpKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbElkICAgPSBtZS5nZXRDZWxsSWQocmVjb3JkLCBmaWVsZC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY2VsbE5vZGUgPSBWRG9tVXRpbC5maW5kKHZkb20sIGNlbGxJZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHZkb20gbWlnaHQgbm90IGV4aXN0IHlldCA9PiBub3RoaW5nIHRvIGRvIGluIHRoaXMgY2FzZVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbE5vZGU/LnZkb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxTdHlsZSAgID0gY2VsbE5vZGUudmRvbS5zdHlsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbiAgICAgID0gbWUuZ2V0Q29sdW1uKGZpZWxkLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uSW5kZXggPSBjZWxsTm9kZS5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxWZG9tICAgID0gbWUuYXBwbHlSZW5kZXJlck91dHB1dCh7Y2VsbElkLCBjb2x1bW4sIGNvbHVtbkluZGV4LCByZWNvcmQsIHJvd0luZGV4fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBjZWxsLXBvc2l0aW9uaW5nIGxvZ2ljIGhhcHBlbnMgb3V0c2lkZSBhcHBseVJlbmRlcmVyT3V0cHV0KClcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gcHJlc2VydmUgdGhlc2Ugc3R5bGVzXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGNlbGxWZG9tLnN0eWxlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA6IGNlbGxTdHlsZS5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjZWxsU3R5bGUud2lkdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsTm9kZS5wYXJlbnROb2RlLmNuW2NvbHVtbkluZGV4XSA9IGNlbGxWZG9tXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgbmVlZHNVcGRhdGUgJiYgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBrZXlib2FyZCBuYXZpZ2F0aW9uIChzZWxlY3Rpb24gbW9kZWxzKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGVwXG4gICAgICovXG4gICAgc2Nyb2xsQnlSb3dzKGluZGV4LCBzdGVwKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7bW91bnRlZFJvd3MsIHZpc2libGVSb3dzfSA9IG1lLFxuICAgICAgICAgICAgY291bnRSZWNvcmRzICAgICAgICAgICAgICAgPSBtZS5zdG9yZS5nZXRDb3VudCgpLFxuICAgICAgICAgICAgbmV3SW5kZXggICAgICAgICAgICAgICAgICAgPSBpbmRleCArIHN0ZXAsXG4gICAgICAgICAgICBsYXN0Um93R2FwLCBtb3VudGVkLCBzY3JvbGxUb3AsIHZpc2libGU7XG5cbiAgICAgICAgaWYgKG5ld0luZGV4ID49IGNvdW50UmVjb3Jkcykge1xuICAgICAgICAgICAgbmV3SW5kZXggJT0gY291bnRSZWNvcmRzO1xuICAgICAgICAgICAgc3RlcCAgICAgPSBuZXdJbmRleCAtIGluZGV4XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAobmV3SW5kZXggPCAwKSB7XG4gICAgICAgICAgICBuZXdJbmRleCArPSBjb3VudFJlY29yZHM7XG4gICAgICAgICAgICBzdGVwICAgICArPSBjb3VudFJlY29yZHNcbiAgICAgICAgfVxuXG4gICAgICAgIG1vdW50ZWQgPSBuZXdJbmRleCA+PSBtb3VudGVkUm93c1swXSAmJiBuZXdJbmRleCA8PSBtb3VudGVkUm93c1sxXTtcblxuICAgICAgICAvLyBOb3QgdXNpbmcgPj0gb3IgPD0sIHNpbmNlIHRoZSBmaXJzdCAvIGxhc3Qgcm93IG1pZ2h0IG5vdCBiZSBmdWxseSB2aXNpYmxlXG4gICAgICAgIHZpc2libGUgPSBuZXdJbmRleCA+IHZpc2libGVSb3dzWzBdICYmIG5ld0luZGV4IDwgdmlzaWJsZVJvd3NbMV07XG5cbiAgICAgICAgaWYgKCF2aXNpYmxlKSB7XG4gICAgICAgICAgICAvLyBMZWF2aW5nIHRoZSBtb3VudGVkIGFyZWEgd2lsbCByZS1jYWxjdWxhdGUgdGhlIHZpc2libGVSb3dzIGZvciB1c1xuICAgICAgICAgICAgaWYgKG1vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICB2aXNpYmxlUm93c1swXSArPSBzdGVwO1xuICAgICAgICAgICAgICAgIHZpc2libGVSb3dzWzFdICs9IHN0ZXBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0ZXAgPCAwKSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsVG9wID0gbmV3SW5kZXggKiBtZS5yb3dIZWlnaHRcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGFzdFJvd0dhcCA9IG1lLnJvd0hlaWdodCAtIChtZS5hdmFpbGFibGVIZWlnaHQgJSBtZS5yb3dIZWlnaHQpO1xuICAgICAgICAgICAgICAgIHNjcm9sbFRvcCAgPSAobmV3SW5kZXggLSBtZS5hdmFpbGFibGVSb3dzKSAqIG1lLnJvd0hlaWdodCArIGxhc3RSb3dHYXBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgTmVvLm1haW4uRG9tQWNjZXNzLnNjcm9sbFRvKHtcbiAgICAgICAgICAgICAgICBpZCAgICAgIDogbWUudmRvbS5pZCxcbiAgICAgICAgICAgICAgICB2YWx1ZSAgIDogc2Nyb2xsVG9wLFxuICAgICAgICAgICAgICAgIHdpbmRvd0lkOiBtZS53aW5kb3dJZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgdXBkYXRlTW91bnRlZEFuZFZpc2libGVDb2x1bW5zKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2J1ZmZlckNvbHVtblJhbmdlLCBjb2x1bW5Qb3NpdGlvbnMsIG1vdW50ZWRDb2x1bW5zLCB2aXNpYmxlQ29sdW1uc30gPSBtZSxcbiAgICAgICAgICAgIGkgICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICBjb3VudENvbHVtbnMgPSBjb2x1bW5Qb3NpdGlvbnMuZ2V0Q291bnQoKSxcbiAgICAgICAgICAgIGVuZEluZGV4ICAgICA9IGNvdW50Q29sdW1ucyAtIDEsXG4gICAgICAgICAgICB4ICAgICAgICAgICAgPSBtZS5zY3JvbGxMZWZ0LFxuICAgICAgICAgICAgY29sdW1uLCBzdGFydEluZGV4O1xuXG4gICAgICAgIGlmIChjb3VudENvbHVtbnMgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoOyBpIDwgY291bnRDb2x1bW5zOyBpKyspIHtcbiAgICAgICAgICAgIGNvbHVtbiA9IGNvbHVtblBvc2l0aW9ucy5nZXRBdChpKTtcblxuICAgICAgICAgICAgaWYgKHggPj0gY29sdW1uLnggJiYgeCA8PSBjb2x1bW4ueCArIGNvbHVtbi53aWR0aCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtZS5jb250YWluZXJXaWR0aCArIHggPCBjb2x1bW4ueCkge1xuICAgICAgICAgICAgICAgIGVuZEluZGV4ID0gaSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZpc2libGVDb2x1bW5zWzBdID0gc3RhcnRJbmRleDsgLy8gdXBkYXRlIHRoZSBhcnJheSBpbmxpbmVcbiAgICAgICAgdmlzaWJsZUNvbHVtbnNbMV0gPSBlbmRJbmRleDtcblxuICAgICAgICBpZiAodmlzaWJsZUNvbHVtbnNbMF0gPD0gbW91bnRlZENvbHVtbnNbMF0gfHwgdmlzaWJsZUNvbHVtbnNbMV0gPj0gbW91bnRlZENvbHVtbnNbMV0pIHtcbiAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBNYXRoLm1heCgwLCB2aXNpYmxlQ29sdW1uc1swXSAtIGJ1ZmZlckNvbHVtblJhbmdlKTtcbiAgICAgICAgICAgIGVuZEluZGV4ICAgPSBNYXRoLm1pbihjb3VudENvbHVtbnMgLSAxLCB2aXNpYmxlQ29sdW1uc1sxXSArIGJ1ZmZlckNvbHVtblJhbmdlKTtcblxuICAgICAgICAgICAgbWUubW91bnRlZENvbHVtbnMgPSBbc3RhcnRJbmRleCwgZW5kSW5kZXhdXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHVwZGF0ZU1vdW50ZWRBbmRWaXNpYmxlUm93cygpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7YnVmZmVyUm93UmFuZ2UsIHN0YXJ0SW5kZXgsIHN0b3JlfSA9IG1lLFxuICAgICAgICAgICAgY291bnRSZWNvcmRzID0gc3RvcmUuZ2V0Q291bnQoKSxcbiAgICAgICAgICAgIGVuZEluZGV4ICAgICA9IE1hdGgubWluKGNvdW50UmVjb3Jkcywgc3RhcnRJbmRleCArIG1lLmF2YWlsYWJsZVJvd3MpO1xuXG4gICAgICAgIG1lLnZpc2libGVSb3dzWzBdID0gc3RhcnRJbmRleDsgLy8gdXBkYXRlIHRoZSBhcnJheSBpbmxpbmVcbiAgICAgICAgbWUudmlzaWJsZVJvd3NbMV0gPSBlbmRJbmRleDtcblxuICAgICAgICBzdGFydEluZGV4ID0gTWF0aC5tYXgoMCwgc3RhcnRJbmRleCAtIGJ1ZmZlclJvd1JhbmdlKTtcbiAgICAgICAgZW5kSW5kZXggICA9IE1hdGgubWluKGNvdW50UmVjb3JkcywgZW5kSW5kZXggKyBidWZmZXJSb3dSYW5nZSk7XG5cbiAgICAgICAgbWUubW91bnRlZFJvd3NbMF0gPSBzdGFydEluZGV4OyAvLyB1cGRhdGUgdGhlIGFycmF5IGlubGluZVxuICAgICAgICBtZS5tb3VudGVkUm93c1sxXSA9IGVuZEluZGV4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50PWZhbHNlXG4gICAgICovXG4gICAgdXBkYXRlU2Nyb2xsSGVpZ2h0KHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvdW50UmVjb3JkcyA9IG1lLnN0b3JlLmdldENvdW50KCksXG4gICAgICAgICAgICB7cm93SGVpZ2h0fSAgPSBtZTtcblxuICAgICAgICBpZiAoY291bnRSZWNvcmRzID4gMCAmJiByb3dIZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICBtZS52ZG9tLmNuWzBdLmhlaWdodCA9IGAkeyhjb3VudFJlY29yZHMgKyAxKSAqIHJvd0hlaWdodH1weGA7XG4gICAgICAgICAgICAhc2lsZW50ICYmIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEdyaWRWaWV3KTtcbiIsImltcG9ydCBCYXNlQnV0dG9uICAgICAgICBmcm9tICcuLi8uLi9idXR0b24vQmFzZS5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICAgICAgICAgIGZyb20gJy4uLy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBUZXh0RmllbGQgICAgICAgICBmcm9tICcuLi8uLi9mb3JtL2ZpZWxkL1RleHQubWpzJztcbmltcG9ydCB7cmVzb2x2ZUNhbGxiYWNrfSBmcm9tICcuLi8uLi91dGlsL0Z1bmN0aW9uLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5ncmlkLmhlYWRlci5CdXR0b25cbiAqIEBleHRlbmRzIE5lby5idXR0b24uQmFzZVxuICovXG5jbGFzcyBCdXR0b24gZXh0ZW5kcyBCYXNlQnV0dG9uIHtcbiAgICAvKipcbiAgICAgKiBWYWxpZCB2YWx1ZXMgZm9yIGFsaWduXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IGNlbGxBbGlnblZhbHVlczogWydsZWZ0JywnY2VudGVyJywncmlnaHQnXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGNlbGxBbGlnblZhbHVlcyA9IFsnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnXVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZ3JpZC5oZWFkZXIuQnV0dG9uJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZ3JpZC5oZWFkZXIuQnV0dG9uJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2dyaWQtaGVhZGVyLWJ1dHRvbidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdncmlkLWhlYWRlci1idXR0b24nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tZ3JpZC1oZWFkZXItYnV0dG9uJywnbmVvLWJ1dHRvbiddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1ncmlkLWhlYWRlci1idXR0b24nLCAnbmVvLWJ1dHRvbiddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQWxpZ25tZW50IG9mIHRoZSBtYXRjaGluZyBncmlkIGNlbGxzLiBWYWxpZCB2YWx1ZXMgYXJlIGxlZnQsIGNlbnRlciwgcmlnaHRcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjZWxsQWxpZ25fPSdsZWZ0J1xuICAgICAgICAgKi9cbiAgICAgICAgY2VsbEFsaWduXzogJ2xlZnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGRhdGFGaWVsZD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkYXRhRmllbGQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTb3J0IGRpcmVjdGlvbiB3aGVuIGNsaWNraW5nIG9uIGFuIHVuc29ydGVkIGJ1dHRvblxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGRlZmF1bHRTb3J0RGlyZWN0aW9uPSdBU0MnXG4gICAgICAgICAqL1xuICAgICAgICBkZWZhdWx0U29ydERpcmVjdGlvbjogJ0FTQycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGVkaXRvckNvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBlZGl0b3JDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGZpbHRlckNvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBmaWx0ZXJDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZm9ybS5maWVsZC5CYXNlfG51bGx9IGZpbHRlckZpZWxkPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgZmlsdGVyRmllbGQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGljb25DbHM9J2ZhIGZhLWFycm93LWNpcmNsZS11cCdcbiAgICAgICAgICovXG4gICAgICAgIGljb25DbHM6ICdmYSBmYS1hcnJvdy1jaXJjbGUtdXAnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBpY29uUG9zaXRpb249J3JpZ2h0J1xuICAgICAgICAgKi9cbiAgICAgICAgaWNvblBvc2l0aW9uOiAncmlnaHQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogJ0FTQycsICdERVNDJyBvciBudWxsXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBpc1NvcnRlZF89bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBpc1NvcnRlZF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbnxTdHJpbmd8bnVsbH0gcmVuZGVyZXJfPSdjZWxsUmVuZGVyZXInXG4gICAgICAgICAqL1xuICAgICAgICByZW5kZXJlcl86ICdjZWxsUmVuZGVyZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2NvcGUgdG8gZXhlY3V0ZSB0aGUgY29sdW1uIHJlbmRlcmVyLlxuICAgICAgICAgKiBEZWZhdWx0cyB0byB0aGUgbWF0Y2hpbmcgZ3JpZC5Db250YWluZXJcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvcmUuQmFzZXxudWxsfSByZW5kZXJlclNjb3BlPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHJlbmRlcmVyU2NvcGU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHJvbGU9J2NvbHVtbmhlYWRlcidcbiAgICAgICAgICovXG4gICAgICAgIHJvbGU6ICdjb2x1bW5oZWFkZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2hvd0hlYWRlckZpbHRlcl89ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHNob3dIZWFkZXJGaWx0ZXJfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNvcnRhYmxlXz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBzb3J0YWJsZV86IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGlzU29ydGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRJc1NvcnRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2xzfSAgICAgPSBtZSxcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IG1lLnVwKCdncmlkLWNvbnRhaW5lcicpO1xuXG4gICAgICAgIHN3aXRjaCh2YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSBudWxsOlxuICAgICAgICAgICAgICAgIE5lb0FycmF5LmFkZChjbHMsICduZW8tc29ydC1oaWRkZW4nKTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSAnQVNDJzpcbiAgICAgICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUoY2xzLCAnbmVvLXNvcnQtZGVzYycpO1xuICAgICAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZShjbHMsICduZW8tc29ydC1oaWRkZW4nKTtcbiAgICAgICAgICAgICAgICBOZW9BcnJheS5hZGQoY2xzLCAnbmVvLXNvcnQtYXNjJyk7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgJ0RFU0MnOlxuICAgICAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZShjbHMsICduZW8tc29ydC1hc2MnKTtcbiAgICAgICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUoY2xzLCAnbmVvLXNvcnQtaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgTmVvQXJyYXkuYWRkKGNscywgJ25lby1zb3J0LWRlc2MnKTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgICAgbWUuY2xzID0gY2xzO1xuXG4gICAgICAgIC8vIHRlc3RpbmcgY2hlY2sgdW50aWwgYWxsIGV4YW1wbGUgZ3JpZHMgaGF2ZSBhIHN0b3JlXG4gICAgICAgIGlmICghY29udGFpbmVyIHx8ICFjb250YWluZXIuc3RvcmUpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgbWUubW91bnRlZCAmJiBtZS5maXJlKCdzb3J0Jywge1xuICAgICAgICAgICAgZGlyZWN0aW9uOiB2YWx1ZSxcbiAgICAgICAgICAgIHByb3BlcnR5IDogbWUuZGF0YUZpZWxkXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzaG93SGVhZGVyRmlsdGVyIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U2hvd0hlYWRlckZpbHRlcih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghbWUuZmlsdGVyRmllbGQpIHtcbiAgICAgICAgICAgICAgICBtZS5maWx0ZXJGaWVsZCA9IE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGUgICA6IFRleHRGaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgYXBwTmFtZSAgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgICAgICAgICBmbGFnICAgICA6ICdmaWx0ZXItZmllbGQnLFxuICAgICAgICAgICAgICAgICAgICBoaWRlTGFiZWw6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudElkIDogbWUuaWQsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlICAgIDoge21hcmdpbkxlZnQ6ICcuNWVtJywgbWFyZ2luUmlnaHQ6ICcuNWVtJ30sXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0lkIDogbWUud2luZG93SWQsXG5cbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2UgICAgICAgIDogbWUuY2hhbmdlRmlsdGVyVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvckNoYW5nZTogbWUuY2hhbmdlRmlsdGVyT3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZSAgICAgICAgIDogbWVcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAuLi5tZS5lZGl0b3JDb25maWdcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIG1lLnZkb20uY24ucHVzaChtZS5maWx0ZXJGaWVsZC5jcmVhdGVWZG9tUmVmZXJlbmNlKCkpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBtZS5maWx0ZXJGaWVsZC52ZG9tLnJlbW92ZURvbVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1lLmZpbHRlckZpZWxkKSB7XG4gICAgICAgICAgICBtZS5maWx0ZXJGaWVsZC52ZG9tLnJlbW92ZURvbSA9IHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnVwZGF0ZURlcHRoID0gMjtcbiAgICAgICAgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNvcnRhYmxlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U29ydGFibGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2xzfSA9IG1lO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgJ25lby1zb3J0LWhpZGRlbicpO1xuXG4gICAgICAgICAgICBtZS5hZGREb21MaXN0ZW5lcnMoe1xuICAgICAgICAgICAgICAgIGNsaWNrOiBtZS5vbkJ1dHRvbkNsaWNrLFxuICAgICAgICAgICAgICAgIHNjb3BlOiBtZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIE5lb0FycmF5LmFkZChjbHMsICduZW8tc29ydC1oaWRkZW4nKTtcblxuICAgICAgICAgICAgbWUucmVtb3ZlRG9tTGlzdGVuZXJzKHtcbiAgICAgICAgICAgICAgICBjbGljazogbWUub25CdXR0b25DbGljayxcbiAgICAgICAgICAgICAgICBzY29wZTogbWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBtZS5jbHMgPSBjbHM7XG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgY2VsbEFsaWduIGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0Q2VsbEFsaWduKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnY2VsbEFsaWduJywgJ2NlbGxBbGlnblZhbHVlcycpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgcmVuZGVyZXIgY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0UmVuZGVyZXIodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlQ2FsbGJhY2sodmFsdWUsIHRoaXMpLmZuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICAgIGRhdGFcbiAgICAgKiBAcGFyYW0ge05lby5idXR0b24uQmFzZX0gICAgZGF0YS5jb2x1bW5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gICAgICAgICAgICAgZGF0YS5jb2x1bW5JbmRleFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgICAgICAgICBkYXRhLmRhdGFGaWVsZFxuICAgICAqIEBwYXJhbSB7TmVvLmdyaWQuQ29udGFpbmVyfSBkYXRhLmdyaWRDb250YWluZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgICAgZGF0YS5yZWNvcmRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gICAgICAgICAgICAgZGF0YS5yb3dJbmRleFxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuU3RvcmV9ICAgICBkYXRhLnN0b3JlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSAgICAgIGRhdGEudmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBjZWxsUmVuZGVyZXIoZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YS52YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZGVzdHJveSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuZmlsdGVyRmllbGQ/LmRlc3Ryb3koKTtcblxuICAgICAgICBzdXBlci5kZXN0cm95KC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uQnV0dG9uQ2xpY2soKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBtYXA7XG5cbiAgICAgICAgaWYgKG1lLmRlZmF1bHRTb3J0RGlyZWN0aW9uID09PSAnREVTQycpIHtcbiAgICAgICAgICAgIG1hcCA9IHtcbiAgICAgICAgICAgICAgICBBU0MgOiBudWxsLFxuICAgICAgICAgICAgICAgIERFU0M6ICdBU0MnLFxuICAgICAgICAgICAgICAgIG51bGw6ICdERVNDJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFwID0ge1xuICAgICAgICAgICAgICAgIEFTQyA6ICdERVNDJyxcbiAgICAgICAgICAgICAgICBERVNDOiBudWxsLFxuICAgICAgICAgICAgICAgIG51bGw6ICdBU0MnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtZS5pc1NvcnRlZCA9IG1hcFttZS5pc1NvcnRlZCArICcnXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgY2hhbmdlRmlsdGVyT3BlcmF0b3IoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBncmlkQ29udGFpbmVyID0gbWUudXAoJ2dyaWQtY29udGFpbmVyJyksXG4gICAgICAgICAgICBzdG9yZSAgICAgICAgID0gZ3JpZENvbnRhaW5lcj8uc3RvcmUsXG4gICAgICAgICAgICBvcGVyYXRvciAgICAgID0gZGF0YS52YWx1ZSxcbiAgICAgICAgICAgIGZpbHRlciwgZmlsdGVycztcblxuICAgICAgICBpZiAoc3RvcmUpIHtcbiAgICAgICAgICAgIGZpbHRlciA9IHN0b3JlLmdldEZpbHRlcihtZS5kYXRhRmllbGQpO1xuXG4gICAgICAgICAgICBpZiAoIWZpbHRlcikge1xuICAgICAgICAgICAgICAgIGZpbHRlcnMgPSBzdG9yZS5maWx0ZXJzO1xuXG4gICAgICAgICAgICAgICAgZmlsdGVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IG1lLmRhdGFGaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICAgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAuLi5tZS5maWx0ZXJDb25maWdcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHN0b3JlLmZpbHRlcnMgPSBmaWx0ZXJzXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpbHRlci5vcGVyYXRvciA9IG9wZXJhdG9yXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGNoYW5nZUZpbHRlclZhbHVlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZ3JpZENvbnRhaW5lciA9IG1lLnVwKCdncmlkLWNvbnRhaW5lcicpLFxuICAgICAgICAgICAgc3RvcmUgICAgICAgICA9IGdyaWRDb250YWluZXI/LnN0b3JlLFxuICAgICAgICAgICAge3ZhbHVlfSAgICAgICA9IGRhdGEsXG4gICAgICAgICAgICBmaWVsZCwgZmlsdGVyLCBmaWx0ZXJzLCBtb2RlbDtcblxuICAgICAgICBpZiAoc3RvcmUpIHtcbiAgICAgICAgICAgIGZpbHRlciA9IHN0b3JlLmdldEZpbHRlcihtZS5kYXRhRmllbGQpO1xuICAgICAgICAgICAgbW9kZWwgID0gc3RvcmUubW9kZWw7XG4gICAgICAgICAgICBmaWVsZCAgPSBtb2RlbC5nZXRGaWVsZChtZS5kYXRhRmllbGQpO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgZmllbGQ/LnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ2RhdGUnKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgRGF0ZSh2YWx1ZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFmaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJzID0gc3RvcmUuZmlsdGVycztcblxuICAgICAgICAgICAgICAgIGZpbHRlcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBtZS5kYXRhRmllbGQsXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiAnbGlrZScsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAuLi5tZS5maWx0ZXJDb25maWdcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHN0b3JlLmZpbHRlcnMgPSBmaWx0ZXJzXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpbHRlci52YWx1ZSA9IHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcmVtb3ZlU29ydGluZ0NzcygpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjbHN9ID0gbWU7XG5cbiAgICAgICAgTmVvQXJyYXkuYWRkKGNscywgJ25lby1zb3J0LWhpZGRlbicpO1xuXG4gICAgICAgIG1lLmNscyAgICAgICA9IGNscztcbiAgICAgICAgbWUuX2lzU29ydGVkID0gbnVsbFxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQnV0dG9uKTtcbiIsImltcG9ydCBCYXNlVG9vbGJhciBmcm9tICcuLi8uLi90b29sYmFyL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmdyaWQuaGVhZGVyLlRvb2xiYXJcbiAqIEBleHRlbmRzIE5lby50b29sYmFyLkJhc2VcbiAqL1xuY2xhc3MgVG9vbGJhciBleHRlbmRzIEJhc2VUb29sYmFyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5ncmlkLmhlYWRlci5Ub29sYmFyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZ3JpZC5oZWFkZXIuVG9vbGJhcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdncmlkLWhlYWRlci10b29sYmFyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2dyaWQtaGVhZGVyLXRvb2xiYXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tZ3JpZC1oZWFkZXItdG9vbGJhcicsJ25lby10b29sYmFyJ11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWdyaWQtaGVhZGVyLXRvb2xiYXInLCAnbmVvLXRvb2xiYXInXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGRyYWdnYWJsZV89dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ2dhYmxlXzogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gaXRlbURlZmF1bHRzPXtudHlwZTogJ2dyaWQtaGVhZGVyLWJ1dHRvbid9XG4gICAgICAgICAqL1xuICAgICAgICBpdGVtRGVmYXVsdHM6IHtcbiAgICAgICAgICAgIG50eXBlOiAnZ3JpZC1oZWFkZXItYnV0dG9uJ1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSByb2xlPSdyb3cnXG4gICAgICAgICAqL1xuICAgICAgICByb2xlOiAncm93JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gc2Nyb2xsTGVmdF89MFxuICAgICAgICAgKi9cbiAgICAgICAgc2Nyb2xsTGVmdF86IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaG93SGVhZGVyRmlsdGVyc189ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHNob3dIZWFkZXJGaWx0ZXJzXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dCB0byBwYXNzIHNvcnRhYmxlIHRvIGFsbCB0b29sYmFyIGl0ZW1zLlxuICAgICAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgaGVhZGVyIGNsaWNrcyB3aWxsIHNvcnQgdGhlIG1hdGNoaW5nIGNvbHVtbiAoQVNDLCBERVNDLCBudWxsKVxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzb3J0YWJsZT10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBzb3J0YWJsZTogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gX3Zkb21cbiAgICAgICAgICovXG4gICAgICAgIF92ZG9tOlxuICAgICAgICB7J2FyaWEtcm93aW5kZXgnOiAxLCBjbjogW3tjbjogW119XX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGRyYWdnYWJsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldERyYWdnYWJsZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAodmFsdWUgJiYgIW1lLnNvcnRab25lKSB7XG4gICAgICAgICAgICBpbXBvcnQoJy4uLy4uL2RyYWdnYWJsZS9ncmlkL2hlYWRlci90b29sYmFyL1NvcnRab25lLm1qcycpLnRoZW4obW9kdWxlID0+IHtcbiAgICAgICAgICAgICAgICBsZXQge2FwcE5hbWUsIGlkLCBzY3JvbGxMZWZ0LCB3aW5kb3dJZH0gPSBtZTtcblxuICAgICAgICAgICAgICAgIG1lLnNvcnRab25lID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZSAgICAgICAgICAgICA6IG1vZHVsZS5kZWZhdWx0LFxuICAgICAgICAgICAgICAgICAgICBhcHBOYW1lLFxuICAgICAgICAgICAgICAgICAgICBib3VuZGFyeUNvbnRhaW5lcklkOiBbaWQsIG1lLnBhcmVudC5pZF0sXG4gICAgICAgICAgICAgICAgICAgIG93bmVyICAgICAgICAgICAgICA6IG1lLFxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxMZWZ0LFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3dJZCxcbiAgICAgICAgICAgICAgICAgICAgLi4ubWUuc29ydFpvbmVDb25maWdcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbW91bnRlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB2YWx1ZSAmJiB0aGlzLnBhc3NTaXplVG9WaWV3KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNob3dIZWFkZXJGaWx0ZXJzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U2hvd0hlYWRlckZpbHRlcnModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgICAgICBtZS5pdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIGl0ZW0uc2V0U2lsZW50KHtcbiAgICAgICAgICAgICAgICAgICAgc2hvd0hlYWRlckZpbHRlcjogdmFsdWVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLnVwZGF0ZURlcHRoID0gLTE7IC8vIGZpbHRlcnMgY2FuIGJlIGRlZXBseSBuZXN0ZWRcbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNjcm9sbExlZnQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U2Nyb2xsTGVmdCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5zb3J0Wm9uZSkge1xuICAgICAgICAgICAgdGhpcy5zb3J0Wm9uZS5zY3JvbGxMZWZ0ID0gdmFsdWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc29ydGFibGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTb3J0YWJsZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIG1lLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgaXRlbS5zZXRTaWxlbnQoe1xuICAgICAgICAgICAgICAgICAgICBzb3J0YWJsZTogdmFsdWVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLnVwZGF0ZURlcHRoID0gMjtcbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGNyZWF0ZUl0ZW1zKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHttb3VudGVkfSA9IG1lO1xuXG4gICAgICAgIG1lLml0ZW1EZWZhdWx0cy5zaG93SGVhZGVyRmlsdGVyID0gbWUuc2hvd0hlYWRlckZpbHRlcnM7XG5cbiAgICAgICAgc3VwZXIuY3JlYXRlSXRlbXMoKTtcblxuICAgICAgICBsZXQge2l0ZW1zfSA9IG1lLFxuICAgICAgICAgICAgc3R5bGU7XG5cbiAgICAgICAgaXRlbXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGl0ZW0udmRvbVsnYXJpYS1jb2xpbmRleCddID0gaW5kZXggKyAxOyAvLyAxIGJhc2VkXG5cbiAgICAgICAgICAgIHN0eWxlID0gaXRlbS53cmFwcGVyU3R5bGU7XG5cbiAgICAgICAgICAgIC8vIHRvZG86IG9ubHkgYWRkIHB4IGlmIG51bWJlclxuICAgICAgICAgICAgaWYgKGl0ZW0ubWF4V2lkdGgpIHtzdHlsZS5tYXhXaWR0aCA9IGl0ZW0ubWF4V2lkdGggKyAncHgnfVxuICAgICAgICAgICAgaWYgKGl0ZW0ubWluV2lkdGgpIHtzdHlsZS5taW5XaWR0aCA9IGl0ZW0ubWluV2lkdGggKyAncHgnfVxuICAgICAgICAgICAgaWYgKGl0ZW0ud2lkdGgpICAgIHtzdHlsZS53aWR0aCAgICA9IGl0ZW0ud2lkdGggICAgKyAncHgnfVxuXG4gICAgICAgICAgICBpdGVtLnNvcnRhYmxlID0gbWUuc29ydGFibGU7XG4gICAgICAgICAgICBpdGVtLndyYXBwZXJTdHlsZSA9IHN0eWxlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLnByb21pc2VVcGRhdGUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIC8vIFRvIHByZXZlbnQgZHVwbGljYXRlIGNhbGxzLCB3ZSBuZWVkIHRvIGNoZWNrIHRoZSBtb3VudGVkIHN0YXRlIGJlZm9yZSB0aGUgdXBkYXRlIGNhbGxcbiAgICAgICAgICAgIG1vdW50ZWQgJiYgbWUucGFzc1NpemVUb1ZpZXcoKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhRmllbGRcbiAgICAgKiBAcmV0dXJucyB7TmVvLmJ1dHRvbi5CYXNlfG51bGx9XG4gICAgICovXG4gICAgZ2V0Q29sdW1uKGRhdGFGaWVsZCkge1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5pdGVtcykge1xuICAgICAgICAgICAgaWYgKGl0ZW0uZGF0YUZpZWxkID09PSBkYXRhRmllbGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNpbGVudD1mYWxzZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIHBhc3NTaXplVG9WaWV3KHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtpdGVtc30gICAgICAgICA9IG1lLFxuICAgICAgICAgICAge3ZpZXd9ICAgICAgICAgID0gbWUucGFyZW50LFxuICAgICAgICAgICAgcmVjdHMgICAgICAgICAgID0gYXdhaXQgbWUuZ2V0RG9tUmVjdChpdGVtcy5tYXAoaXRlbSA9PiBpdGVtLmlkKSksXG4gICAgICAgICAgICBsYXN0SXRlbSAgICAgICAgPSByZWN0c1tyZWN0cy5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIGNvbHVtblBvc2l0aW9ucyA9IHJlY3RzLm1hcCgoaXRlbSwgaW5kZXgpID0+ICh7ZGF0YUZpZWxkOiBpdGVtc1tpbmRleF0uZGF0YUZpZWxkLCB3aWR0aDogaXRlbS53aWR0aCwgeDogaXRlbS54IC0gcmVjdHNbMF0ueH0pKSxcbiAgICAgICAgICAgIGkgICAgICAgICAgICAgICA9IDEsXG4gICAgICAgICAgICBsZW4gICAgICAgICAgICAgPSBjb2x1bW5Qb3NpdGlvbnMubGVuZ3RoLFxuICAgICAgICAgICAgbGF5b3V0RmluaXNoZWQgID0gdHJ1ZTtcblxuICAgICAgICAvLyBJZiB0aGUgY3NzIHNpemluZyBpcyBub3QgZG9uZSwgY29sdW1ucyBhZnRlciB0aGUgZmlyc3Qgb25lIGNhbiBnZXQgeCA9IDBcbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGNvbHVtblBvc2l0aW9uc1tpXS54ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbGF5b3V0RmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlbGF5IGZvciBzbG93IGNvbm5lY3Rpb25zLCB3aGVyZSB0aGUgY29udGFpbmVyLXNpemluZyBpcyBub3QgZG9uZSB5ZXRcbiAgICAgICAgaWYgKCFsYXlvdXRGaW5pc2hlZCkge1xuICAgICAgICAgICAgYXdhaXQgbWUudGltZW91dCgxMDApO1xuICAgICAgICAgICAgYXdhaXQgbWUucGFzc1NpemVUb1ZpZXcoc2lsZW50KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmlldy5jb2x1bW5Qb3NpdGlvbnMuY2xlYXIoKTtcbiAgICAgICAgICAgIHZpZXcuY29sdW1uUG9zaXRpb25zLmFkZChjb2x1bW5Qb3NpdGlvbnMpO1xuXG4gICAgICAgICAgICB2aWV3W3NpbGVudCA/ICdzZXRTaWxlbnQnIDogJ3NldCddKHtcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVXaWR0aDogbGFzdEl0ZW0ueCArIGxhc3RJdGVtLndpZHRoIC0gcmVjdHNbMF0ueFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICFzaWxlbnQgJiYgdmlldy51cGRhdGVNb3VudGVkQW5kVmlzaWJsZUNvbHVtbnMoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICBpbmRleFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIHNjcm9sbFRvSW5kZXgoaW5kZXgpIHtcbiAgICAgICAgYXdhaXQgTmVvLm1haW4uRG9tQWNjZXNzLnNjcm9sbEludG9WaWV3KHtcbiAgICAgICAgICAgIGRlbGF5ICAgOiAxMjUsXG4gICAgICAgICAgICBpZCAgICAgIDogdGhpcy5pdGVtc1tpbmRleF0uaWQsXG4gICAgICAgICAgICB3aW5kb3dJZDogdGhpcy53aW5kb3dJZFxuICAgICAgICB9KVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVG9vbGJhcik7XG4iLCJpbXBvcnQgQnV0dG9uICBmcm9tICcuL0J1dHRvbi5tanMnO1xuaW1wb3J0IFRvb2xiYXIgZnJvbSAnLi9Ub29sYmFyLm1qcyc7XG5cbmV4cG9ydCB7QnV0dG9uLCBUb29sYmFyfTsiLCJpbXBvcnQgQmFzZSAgICAgICBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBOZW9BcnJheSAgIGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBPYnNlcnZhYmxlIGZyb20gJy4uL2NvcmUvT2JzZXJ2YWJsZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uc2VsZWN0aW9uLk1vZGVsXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIE1vZGVsIGV4dGVuZHMgQmFzZSB7XG4gICAgLyoqXG4gICAgICogVHJ1ZSBhdXRvbWF0aWNhbGx5IGFwcGxpZXMgdGhlIGNvcmUuT2JzZXJ2YWJsZSBtaXhpblxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG9ic2VydmFibGU9dHJ1ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgb2JzZXJ2YWJsZSA9IHRydWVcblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnNlbGVjdGlvbi5Nb2RlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnNlbGVjdGlvbi5Nb2RlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdzZWxlY3Rpb24tbW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnc2VsZWN0aW9uLW1vZGVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBsYWNlaG9sZGVyIGZvciBleHRlbmRlZCBjbGFzc2VzIHRvIGFkZCBhIGN1c3RvbSBjc3MgcnVsZSB0byB0aGlzIG93bmVyIGNvbXBvbmVudFxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gY2xzPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl9IGl0ZW1zXz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1zXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gc2VsZWN0ZWRDbHM9J3NlbGVjdGVkJ1xuICAgICAgICAgKi9cbiAgICAgICAgc2VsZWN0ZWRDbHM6ICduZW8tc2VsZWN0ZWQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2luZ2xlU2VsZWN0PXRydWVcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZVNlbGVjdDogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsbHkgc2F2ZXMgdGhlIHZpZXcgaWQsIGJ1dCB0aGUgZ2V0dGVyIHdpbGwgcmV0dXJuIHRoZSBtYXRjaGluZyBpbnN0YW5jZVxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHZpZXdfPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdmlld186IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCBiZWZvcmUgZ2V0dGluZyB0aGUgdmFsdWUgb2YgdGhlIGl0ZW1zIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7QXJyYXl8bnVsbH0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgYmVmb3JlR2V0SXRlbXModmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5faXRlbXMgPSB2YWx1ZSA9IFtdXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCBiZWZvcmUgZ2V0dGluZyB0aGUgdmFsdWUgb2YgdGhlIHZpZXcgY29uZmlnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZX1cbiAgICAgKi9cbiAgICBiZWZvcmVHZXRWaWV3KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBOZW8uZ2V0Q29tcG9uZW50KHRoaXMuX3ZpZXcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0cmlnZ2VyZWQgYmVmb3JlIHNldHRpbmcgdGhlIHZhbHVlIG9mIHRoZSB2aWV3IGNvbmZpZ1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSB2aWV3IGlkXG4gICAgICovXG4gICAgYmVmb3JlU2V0Vmlldyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWUuaWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGFkZERvbUxpc3RlbmVyKCkge31cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2lsZW50XSB0cnVlIHRvIHByZXZlbnQgYSB2ZG9tIHVwZGF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W118U3RyaW5nW119IGl0ZW1Db2xsZWN0aW9uPXRoaXMuaXRlbXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NlbGVjdGVkQ2xzXVxuICAgICAqL1xuICAgIGRlc2VsZWN0KGl0ZW0sIHNpbGVudCwgaXRlbUNvbGxlY3Rpb249dGhpcy5pdGVtcywgc2VsZWN0ZWRDbHMpIHtcbiAgICAgICAgLy8gV2UgaG9sZCB2ZG9tIGlkcyBmb3Igbm93LCBzbyBhbGwgaW5jb21pbmcgc2VsZWN0aW9ucyBtdXN0IGJlIGNvbnZlcnRlZC5cbiAgICAgICAgaXRlbSA9IGl0ZW0uaXNSZWNvcmQgPyB2aWV3LmdldEl0ZW1JZChpdGVtKSA6IE5lby5pc09iamVjdChpdGVtKSA/IGl0ZW0uaWQgOiBpdGVtO1xuXG4gICAgICAgIGlmIChpdGVtQ29sbGVjdGlvbi5pbmNsdWRlcyhpdGVtKSkge1xuICAgICAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAge3ZpZXd9ID0gbWUsXG4gICAgICAgICAgICAgICAgbm9kZSAgID0gdmlldy5nZXRWZG9tQ2hpbGQoaXRlbSk7XG5cbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5jbHMgPSBOZW9BcnJheS5yZW1vdmUobm9kZS5jbHMgfHwgW10sIHNlbGVjdGVkQ2xzIHx8IG1lLnNlbGVjdGVkQ2xzKTtcbiAgICAgICAgICAgICAgICBub2RlWydhcmlhLXNlbGVjdGVkJ10gPSBmYWxzZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUoaXRlbUNvbGxlY3Rpb24sIGl0ZW0pO1xuXG4gICAgICAgICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAgICAgICAgIHZpZXcudXBkYXRlKCk7XG5cbiAgICAgICAgICAgICAgICBtZS5maXJlKCdzZWxlY3Rpb25DaGFuZ2UnLCB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogaXRlbUNvbGxlY3Rpb25cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnbm9DaGFuZ2UnKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2lsZW50XSB0cnVlIHRvIHByZXZlbnQgYSB2ZG9tIHVwZGF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W118U3RyaW5nW119IGl0ZW1Db2xsZWN0aW9uPXRoaXMuaXRlbXNcbiAgICAgKi9cbiAgICBkZXNlbGVjdEFsbChzaWxlbnQsIGl0ZW1Db2xsZWN0aW9uPXRoaXMuaXRlbXMpIHtcbiAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtcyAgPSBbLi4uaXRlbUNvbGxlY3Rpb25dLFxuICAgICAgICAgICAge3ZpZXd9ID0gbWU7XG5cbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBtZS5kZXNlbGVjdChpdGVtLCB0cnVlKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghc2lsZW50ICYmIGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2aWV3LnVwZGF0ZSgpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLmZpcmUoJ3NlbGVjdGlvbkNoYW5nZScsIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb246IHRoaXMuaXRlbXNcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXNpbGVudCkge1xuICAgICAgICAgICAgbWUuZmlyZSgnbm9DaGFuZ2UnKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBkZXN0cm95KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy51bnJlZ2lzdGVyKCk7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koLi4uYXJncylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IHRoaXMuaXRlbXNcbiAgICAgKi9cbiAgICBnZXRTZWxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzU2VsZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5sZW5ndGggPiAwXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaW4gY2FzZSB0aGUgaXRlbSBpcyBzZWxlY3RlZFxuICAgICAqL1xuICAgIGlzU2VsZWN0ZWQoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMuaW5jbHVkZXMoaWQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudFxuICAgICAqL1xuICAgIHJlZ2lzdGVyKGNvbXBvbmVudCkge1xuICAgICAgICBsZXQgbWUgID0gdGhpcyxcbiAgICAgICAgICAgIGNscyA9IGNvbXBvbmVudC53cmFwcGVyQ2xzIHx8IFtdO1xuXG4gICAgICAgIGlmIChtZS5jbHMgJiYgIWNscy5pbmNsdWRlcyhtZS5jbHMpKSB7XG4gICAgICAgICAgICBjbHMucHVzaChtZS5jbHMpO1xuICAgICAgICAgICAgY29tcG9uZW50LndyYXBwZXJDbHMgPSBjbHNcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnZpZXcgPSBjb21wb25lbnQ7XG4gICAgICAgIG1lLmFkZERvbUxpc3RlbmVyKCk7XG5cbiAgICAgICAgY29tcG9uZW50LmZpcmUoJ3NlbGVjdGlvbk1vZGVsQ2hhbmdlJywge1xuICAgICAgICAgICAgdmFsdWU6IG1lXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICByZW1vdmVEb21MaXN0ZW5lcnMoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY29tcG9uZW50ICAgID0gbWUudmlldyxcbiAgICAgICAgICAgIGRvbUxpc3RlbmVycyA9IFsuLi5jb21wb25lbnQuZG9tTGlzdGVuZXJzXTtcblxuICAgICAgICBjb21wb25lbnQuZG9tTGlzdGVuZXJzLmZvckVhY2gobGlzdGVuZXIgPT4ge1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVyLnNjb3BlID09PSBtZSkge1xuICAgICAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZShkb21MaXN0ZW5lcnMsIGxpc3RlbmVyKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjb21wb25lbnQuZG9tTGlzdGVuZXJzID0gZG9tTGlzdGVuZXJzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R8T2JqZWN0W118U3RyaW5nW119IGl0ZW1zXG4gICAgICogQHBhcmFtIHtPYmplY3RbXXxTdHJpbmdbXX0gaXRlbUNvbGxlY3Rpb249dGhpcy5pdGVtc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2VsZWN0ZWRDbHNdXG4gICAgICovXG4gICAgc2VsZWN0KGl0ZW1zLCBpdGVtQ29sbGVjdGlvbj10aGlzLml0ZW1zLCBzZWxlY3RlZENscykge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt2aWV3fSA9IG1lO1xuXG4gICAgICAgIC8vIFdlIGhvbGQgdmRvbSBpZHMgZm9yIG5vdywgc28gYWxsIGluY29taW5nIHNlbGVjdGlvbnMgbXVzdCBiZSBjb252ZXJ0ZWQuXG4gICAgICAgIGl0ZW1zID0gKGl0ZW1zID0gQXJyYXkuaXNBcnJheShpdGVtcykgP1xuICAgICAgICAgICAgaXRlbXM6IFtpdGVtc10pLm1hcChpdGVtID0+IGl0ZW0uaXNSZWNvcmQgPyB2aWV3LmdldEl0ZW1JZChpdGVtKSA6IE5lby5pc09iamVjdChpdGVtKSA/IGl0ZW0uaWQgOiBpdGVtKTtcblxuICAgICAgICBpZiAoIU5lby5pc0VxdWFsKGl0ZW1Db2xsZWN0aW9uLCBpdGVtcykpIHtcbiAgICAgICAgICAgIGlmIChtZS5zaW5nbGVTZWxlY3QgJiYgaXRlbUNvbGxlY3Rpb24gPT09IG1lLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgbWUuZGVzZWxlY3RBbGwodHJ1ZSwgaXRlbUNvbGxlY3Rpb24pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGl0ZW1zLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHZpZXcuZ2V0VmRvbUNoaWxkKG5vZGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jbHMgPSBOZW9BcnJheS5hZGQobm9kZS5jbHMgfHwgW10sIHNlbGVjdGVkQ2xzIHx8IG1lLnNlbGVjdGVkQ2xzKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZVsnYXJpYS1zZWxlY3RlZCddID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBOZW9BcnJheS5hZGQoaXRlbUNvbGxlY3Rpb24sIGl0ZW1zKTtcblxuICAgICAgICAgICAgaWYgKCF2aWV3LnNpbGVudFNlbGVjdCkge1xuICAgICAgICAgICAgICAgIHZpZXcudXBkYXRlKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmlldy5vblNlbGVjdD8uKGl0ZW1zKTtcblxuICAgICAgICAgICAgbWUuZmlyZSgnc2VsZWN0aW9uQ2hhbmdlJywge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogaXRlbUNvbGxlY3Rpb25cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZS5maXJlKCdub0NoYW5nZScpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuICAgICAqL1xuICAgIHRvZ2dsZVNlbGVjdGlvbihpdGVtKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmlzU2VsZWN0ZWQoaXRlbSkpIHtcbiAgICAgICAgICAgIG1lLmRlc2VsZWN0KGl0ZW0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5zZWxlY3QoaXRlbSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgdW5yZWdpc3RlcigpIHtcbiAgICAgICAgbGV0IG1lICA9IHRoaXMsXG4gICAgICAgICAgICBjbHMgPSBtZS52aWV3LndyYXBwZXJDbHMgfHwgW107XG5cbiAgICAgICAgaWYgKG1lLmNscyAmJiBjbHMuaW5jbHVkZXMobWUuY2xzKSkge1xuICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgbWUuY2xzKTtcbiAgICAgICAgICAgIG1lLnZpZXcud3JhcHBlckNscyA9IGNsc1xuICAgICAgICB9XG5cbiAgICAgICAgbWUuZGVzZWxlY3RBbGwoKTtcblxuICAgICAgICBtZS5yZW1vdmVEb21MaXN0ZW5lcnMoKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoTW9kZWwpO1xuIiwiaW1wb3J0IE1vZGVsIGZyb20gJy4uL01vZGVsLm1qcyc7XG5cbi8qKlxuICogQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgYWxsIGdyaWQgcmVsYXRlZCBzZWxlY3Rpb24gbW9kZWxzXG4gKiBAY2xhc3MgTmVvLnNlbGVjdGlvbi5ncmlkLkJhc2VNb2RlbFxuICogQGV4dGVuZHMgTmVvLnNlbGVjdGlvbi5Nb2RlbFxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIEJhc2VNb2RlbCBleHRlbmRzIE1vZGVsIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5zZWxlY3Rpb24uZ3JpZC5CYXNlTW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5zZWxlY3Rpb24uZ3JpZC5CYXNlTW9kZWwnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXRcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gZGF0YUZpZWxkc1xuICAgICAqL1xuICAgIGdldCBkYXRhRmllbGRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LnBhcmVudC5jb2x1bW5zLm1hcChjb2x1bW4gPT4gY29sdW1uLmRhdGFGaWVsZClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYW4gZXZlbnQgcGF0aCBjb250YWlucyBhIGdyaWQgY2VsbCBlZGl0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5wYXRoXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzRWRpdG9yRm9jdXMoe3BhdGh9KSB7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBwYXRoKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5jbHM/LmluY2x1ZGVzKCduZW8tZ3JpZC1lZGl0b3InKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEJhc2VNb2RlbCk7XG4iLCJpbXBvcnQgQmFzZU1vZGVsIGZyb20gJy4vQmFzZU1vZGVsLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5zZWxlY3Rpb24uZ3JpZC5Sb3dNb2RlbFxuICogQGV4dGVuZHMgTmVvLnNlbGVjdGlvbi5ncmlkLkJhc2VNb2RlbFxuICovXG5jbGFzcyBSb3dNb2RlbCBleHRlbmRzIEJhc2VNb2RlbCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uc2VsZWN0aW9uLmdyaWQuUm93TW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5zZWxlY3Rpb24uZ3JpZC5Sb3dNb2RlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdzZWxlY3Rpb24tZ3JpZC1yb3dtb2RlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdzZWxlY3Rpb24tZ3JpZC1yb3dtb2RlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNscz0nbmVvLXNlbGVjdGlvbi1yb3dtb2RlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xzOiAnbmVvLXNlbGVjdGlvbi1yb3dtb2RlbCdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGFkZERvbUxpc3RlbmVyKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnZpZXcucGFyZW50Lm9uKCdyb3dDbGljaycsIG1lLm9uUm93Q2xpY2ssIG1lKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICovXG4gICAgZGVzdHJveSguLi5hcmdzKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUudmlldy5wYXJlbnQudW4oJ3Jvd0NsaWNrJywgbWUub25Sb3dDbGljaywgbWUpO1xuXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koLi4uYXJncylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1JlY29yZH0gcmVjb3JkXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzQW5ub3RhdGlvbnMocmVjb3JkKSB7XG4gICAgICAgIHJldHVybiAhIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocmVjb3JkLl9fcHJvdG9fXywgdGhpcy52aWV3LnNlbGVjdGVkUmVjb3JkRmllbGQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbktleURvd25Eb3duKGRhdGEpIHtcbiAgICAgICAgIXRoaXMuaGFzRWRpdG9yRm9jdXMoZGF0YSkgJiYgdGhpcy5vbk5hdktleVJvdygxKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25LZXlEb3duVXAoZGF0YSkge1xuICAgICAgICAhdGhpcy5oYXNFZGl0b3JGb2N1cyhkYXRhKSAmJiB0aGlzLm9uTmF2S2V5Um93KC0xKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGVwXG4gICAgICovXG4gICAgb25OYXZLZXlSb3coc3RlcCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt2aWV3fSAgICAgICA9IG1lLFxuICAgICAgICAgICAge3N0b3JlfSAgICAgID0gdmlldyxcbiAgICAgICAgICAgIGNvdW50UmVjb3JkcyA9IHN0b3JlLmdldENvdW50KCksXG4gICAgICAgICAgICBjdXJyZW50SW5kZXggPSAwLFxuICAgICAgICAgICAgbmV3SW5kZXgsIHJlY29yZCwgcm93SWQ7XG5cbiAgICAgICAgaWYgKG1lLmhhc1NlbGVjdGlvbigpKSB7XG4gICAgICAgICAgICBjdXJyZW50SW5kZXggPSBzdG9yZS5pbmRleE9mKHZpZXcuZ2V0UmVjb3JkQnlSb3dJZChtZS5pdGVtc1swXSkpXG4gICAgICAgIH1cblxuICAgICAgICBuZXdJbmRleCA9IChjdXJyZW50SW5kZXggKyBzdGVwKSAlIGNvdW50UmVjb3JkcztcblxuICAgICAgICB3aGlsZSAobmV3SW5kZXggPCAwKSB7XG4gICAgICAgICAgICBuZXdJbmRleCArPSBjb3VudFJlY29yZHNcbiAgICAgICAgfVxuXG4gICAgICAgIHJlY29yZCA9IHN0b3JlLmdldEF0KG5ld0luZGV4KTtcblxuICAgICAgICBpZiAobWUuaGFzQW5ub3RhdGlvbnMocmVjb3JkKSkge1xuICAgICAgICAgICAgbWUudXBkYXRlQW5ub3RhdGlvbnMocmVjb3JkKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcm93SWQgPSB2aWV3LmdldFJvd0lkKHJlY29yZCk7XG5cbiAgICAgICAgICAgIGlmIChyb3dJZCkge1xuICAgICAgICAgICAgICAgIG1lLnNlbGVjdChyb3dJZCk7XG5cbiAgICAgICAgICAgICAgICB2aWV3LnNjcm9sbEJ5Um93cyhjdXJyZW50SW5kZXgsIHN0ZXApO1xuICAgICAgICAgICAgICAgIHZpZXcuZmlyZSgnc2VsZWN0Jywge3JlY29yZH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uUm93Q2xpY2soZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGlkICAgICA9IGRhdGEuZGF0YS5jdXJyZW50VGFyZ2V0LFxuICAgICAgICAgICAge3ZpZXd9ID0gbWUsXG4gICAgICAgICAgICBpc1NlbGVjdGVkLCByZWNvcmQ7XG5cbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICByZWNvcmQgPSB2aWV3LmdldFJlY29yZChpZCk7XG5cbiAgICAgICAgICAgIGlmIChtZS5oYXNBbm5vdGF0aW9ucyhyZWNvcmQpKSB7XG4gICAgICAgICAgICAgICAgbWUudXBkYXRlQW5ub3RhdGlvbnMocmVjb3JkKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZS50b2dnbGVTZWxlY3Rpb24oaWQpO1xuXG4gICAgICAgICAgICAgICAgaXNTZWxlY3RlZCA9IG1lLmlzU2VsZWN0ZWQoaWQpO1xuXG4gICAgICAgICAgICAgICAgIWlzU2VsZWN0ZWQgJiYgdmlldy5vbkRlc2VsZWN0Py4ocmVjb3JkKTtcblxuICAgICAgICAgICAgICAgIHZpZXcuZmlyZShpc1NlbGVjdGVkID8gJ3NlbGVjdCcgOiAnZGVzZWxlY3QnLCB7cmVjb3JkfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBjb21wb25lbnRcbiAgICAgKi9cbiAgICByZWdpc3Rlcihjb21wb25lbnQpIHtcbiAgICAgICAgc3VwZXIucmVnaXN0ZXIoY29tcG9uZW50KTtcblxuICAgICAgICBsZXQge2lkLCB2aWV3fSA9IHRoaXM7XG5cbiAgICAgICAgdmlldy5rZXlzPy5fa2V5cy5wdXNoKFxuICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duRG93bicsIGtleTogJ0Rvd24nLCBzY29wZTogaWR9LFxuICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duVXAnLCAgIGtleTogJ1VwJywgICBzY29wZTogaWR9XG4gICAgICAgIClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHVucmVnaXN0ZXIoKSB7XG4gICAgICAgIGxldCB7aWQsIHZpZXd9ID0gdGhpcztcblxuICAgICAgICB2aWV3LmtleXM/LnJlbW92ZUtleXMoW1xuICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duRG93bicsIGtleTogJ0Rvd24nLCBzY29wZTogaWR9LFxuICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duVXAnLCAgIGtleTogJ1VwJywgICBzY29wZTogaWR9XG4gICAgICAgIF0pO1xuXG4gICAgICAgIHN1cGVyLnVucmVnaXN0ZXIoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UmVjb3JkfSByZWNvcmRcbiAgICAgKi9cbiAgICB1cGRhdGVBbm5vdGF0aW9ucyhyZWNvcmQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3ZpZXd9ICAgICAgICAgICA9IG1lLFxuICAgICAgICAgICAgcm93SWQgICAgICAgICAgICA9IHZpZXcuZ2V0Um93SWQocmVjb3JkKSxcbiAgICAgICAgICAgIGlzU2VsZWN0ZWQgICAgICAgPSBtZS5pc1NlbGVjdGVkKHJvd0lkKSxcbiAgICAgICAgICAgIGFubm90YXRpb25zRmllbGQgPSB2aWV3LnNlbGVjdGVkUmVjb3JkRmllbGQ7XG5cbiAgICAgICAgaWYgKG1lLnNpbmdsZVNlbGVjdCkge1xuICAgICAgICAgICAgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICByZWNvcmRbYW5ub3RhdGlvbnNGaWVsZF0gPSBmYWxzZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZS5pdGVtcy5mb3JFYWNoKHJvd0lkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgY2FuIHVzZSBzZXRTaWxlbnQoKSwgc2luY2UgdGhlIGxhc3QgY2hhbmdlIHdpbGwgdHJpZ2dlciBhIHZpZXcgdXBkYXRlXG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZ2V0UmVjb3JkQnlSb3dJZChyb3dJZCkuc2V0U2lsZW50KHtbYW5ub3RhdGlvbnNGaWVsZF06IGZhbHNlfSlcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJlY29yZFthbm5vdGF0aW9uc0ZpZWxkXSA9IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlY29yZFthbm5vdGF0aW9uc0ZpZWxkXSA9ICFyZWNvcmRbYW5ub3RhdGlvbnNGaWVsZF1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoUm93TW9kZWwpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9