export const __webpack_esm_id__ = "vendors-src_grid_Container_mjs";
export const __webpack_esm_ids__ = ["vendors-src_grid_Container_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./src/component/CountryFlag.mjs"
/*!***************************************!*\
  !*** ./src/component/CountryFlag.mjs ***!
  \***************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _util_CountryFlags_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/CountryFlags.mjs */ "./src/util/CountryFlags.mjs");



/**
 * @class Neo.component.CountryFlag
 * @extends Neo.component.Base
 */
class CountryFlag extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.CountryFlag'
         * @protected
         */
        className: 'Neo.component.CountryFlag',
        /**
         * @member {String[]} baseCls=['neo-country-flag']
         */
        baseCls: ['neo-country-flag'],
        /**
         * @member {String|null} countryCode_=null
         */
        countryCode_: null,
        /**
         * @member {String|null} location_=null
         */
        location_: null,
        /**
         * @member {Boolean} resolveCountryCode_=false
         */
        resolveCountryCode_: false,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {cn: [
            {tag: 'img', cls: ['neo-country-flag']},
            {tag: 'span', cls: ['neo-location-text']}
        ]}
    }

    /**
     * @param {String|null} value
     * @param {String|null} oldValue
     */
    afterSetCountryCode(value, oldValue) {
        this.updateFlag()
    }

    /**
     * @param {String|null} value
     * @param {String|null} oldValue
     */
    afterSetLocation(value, oldValue) {
        let me = this;

        me.vdom.cn[1].text = value || '';

        if (me.resolveCountryCode) {
            me.updateFlag()
        } else {
            me.update()
        }
    }

    /**
     * @param {Boolean} value
     * @param {Boolean} oldValue
     */
    afterSetResolveCountryCode(value, oldValue) {
        if (oldValue !== undefined) {
            this.updateFlag()
        }
    }

    /**
     *
     */
    updateFlag() {
        let me              = this,
            {countryCode, location, resolveCountryCode, vdom} = me,
            flag            = vdom.cn[0],
            url;

        if (countryCode) {
            url = _util_CountryFlags_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getFlagUrl(countryCode)
        } else if (resolveCountryCode && location) {
            url = _util_CountryFlags_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getFlagUrl(location)
        }

        // Performance Optimization:
        // We maintain a persistent <img> tag in the VDOM structure to ensure a stable DOM.
        // Swapping tags (e.g. img <-> span) or removing nodes triggers layout thrashing
        // during rapid recycling (e.g. Grid scrolling).
        // We toggle visibility instead of structural changes.
        if (url) {
            flag.src   = url;
            flag.style = null; // Remove visibility: hidden
            flag.title = location || countryCode;
        } else {
            delete flag.src;
            delete flag.title;
            flag.style = {visibility: 'hidden'};
        }

        me.update()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(CountryFlag));


/***/ },

/***/ "./src/component/GitHubOrgs.mjs"
/*!**************************************!*\
  !*** ./src/component/GitHubOrgs.mjs ***!
  \**************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/component/Base.mjs");


/**
 * @summary Displays a list of GitHub Organization avatars with links.
 *
 * This component supports two rendering modes:
 * 1. **Standard Mode (Default):** Renders only the organizations present in the data. The component size adapts to the content.
 * 2. **Stable Mode (`renderFullPool: true`):** Pre-allocates a fixed number of nodes (`maxItems`) and toggles their visibility.
 *    This ensures the component's dimensions remain constant (reserving space), which is critical for preventing
 *    layout thrashing in high-frequency update scenarios like Grids.
 *
 * @class Neo.component.GitHubOrgs
 * @extends Neo.component.Base
 */
class GitHubOrgs extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.GitHubOrgs'
         * @protected
         */
        className: 'Neo.component.GitHubOrgs',
        /**
         * Size in px for the avatar image request.
         * Recommended to use 2x the display size for high DPI screens.
         * @member {Number} avatarSize=40
         */
        avatarSize: 40,
        /**
         * @member {String[]} baseCls=['neo-github-orgs']
         */
        baseCls: ['neo-github-orgs'],
        /**
         * @member {Number} maxItems_=5
         */
        maxItems_: 5,
        /**
         * @member {Object[]|null} orgs_=null
         */
        orgs_: null,
        /**
         * If true, the component will always render `maxItems` nodes.
         * Unused nodes will be hidden via `visibility: hidden` but will still occupy layout space.
         * Use this setting for Grids to prevent layout thrashing during scrolling.
         * @member {Boolean} renderFullPool_=false
         */
        renderFullPool_: false,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {cn: []}
    }

    /**
     * @param {Object[]|null} value
     * @param {Object[]|null} oldValue
     */
    afterSetOrgs(value, oldValue) {
        let me       = this,
            maxItems = me.maxItems,
            vdom     = me.vdom,
            items    = Array.isArray(value) ? value : [];

        if (me.renderFullPool) {
            // Optimization: Maintain a fixed pool of nodes to prevent layout shifts.
            if (vdom.cn.length < maxItems) {
                for (let i = vdom.cn.length; i < maxItems; i++) {
                    vdom.cn.push({
                        tag   : 'a',
                        cls   : ['neo-org-link'],
                        target: '_blank',
                        cn    : [{
                            tag: 'img',
                            cls: ['neo-org-avatar']
                        }]
                    })
                }
            }

            vdom.cn.forEach((node, index) => {
                let org = items[index],
                    img = node.cn[0];

                if (org) {
                    let avatarUrl = org.avatarUrl;

                    if (avatarUrl) {
                        let urlStr = String(avatarUrl);
                        if (!urlStr.startsWith('http')) {
                            avatarUrl = `https://avatars.githubusercontent.com/u/${avatarUrl}?v=4&s=${me.avatarSize}`;
                        } else {
                            let url = new URL(avatarUrl);
                            url.searchParams.set('s', me.avatarSize);
                            avatarUrl = url.toString()
                        }
                    }

                    node.href  = `https://github.com/${org.login}`;
                    node.title = org.name || org.login;
                    node.style = null; // Remove visibility: hidden

                    img.src = avatarUrl;
                } else {
                    delete node.href;
                    delete node.title;
                    node.style = {visibility: 'hidden'};

                    delete img.src;
                }
            });
        } else {
            // Standard behavior: Render only what exists
            let newItems = [];

            items.slice(0, maxItems).forEach(org => {
                let avatarUrl = org.avatarUrl;

                if (avatarUrl) {
                    let urlStr = String(avatarUrl);
                    if (!urlStr.startsWith('http')) {
                        avatarUrl = `https://avatars.githubusercontent.com/u/${avatarUrl}?v=4&s=${me.avatarSize}`;
                    } else {
                        let url = new URL(avatarUrl);
                        url.searchParams.set('s', me.avatarSize);
                        avatarUrl = url.toString()
                    }
                }

                newItems.push({
                    tag   : 'a',
                    cls   : ['neo-org-link'],
                    href  : `https://github.com/${org.login}`,
                    target: '_blank',
                    title : org.name || org.login,
                    cn    : [{
                        tag: 'img',
                        cls: ['neo-org-avatar'],
                        src: avatarUrl
                    }]
                })
            });

            vdom.cn = newItems;
        }

        me.update()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(GitHubOrgs));


/***/ },

/***/ "./src/component/GitHubUser.mjs"
/*!**************************************!*\
  !*** ./src/component/GitHubUser.mjs ***!
  \**************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/component/Base.mjs");


/**
 * @class Neo.component.GitHubUser
 * @extends Neo.component.Base
 */
class GitHubUser extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.GitHubUser'
         * @protected
         */
        className: 'Neo.component.GitHubUser',
        /**
         * Size in px for the avatar image request.
         * Recommended to use 2x the display size for high DPI screens.
         * @member {Number} avatarSize=64
         */
        avatarSize: 64,
        /**
         * @member {String|null} avatarUrl_=null
         */
        avatarUrl_: null,
        /**
         * @member {String[]} baseCls=['neo-github-user']
         */
        baseCls: ['neo-github-user'],
        /**
         * @member {String|null} fullName_=null
         */
        fullName_: null,
        /**
         * @member {String|null} username_=null
         */
        username_: null,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {cn: [
            {tag: 'img', cls: ['neo-avatar']},
            {cls: ['neo-user-info'], cn: [
                {tag: 'a',    cls: ['neo-username'], target: '_blank'},
                {tag: 'span', cls: ['neo-name']}
            ]}
        ]}
    }

    /**
     * @param {String|null} value
     * @param {String|null} oldValue
     */
    afterSetAvatarUrl(value, oldValue) {
        let me = this;

        if (value) {
            let urlStr = String(value);

            if (!urlStr.startsWith('http')) {
                urlStr = `https://avatars.githubusercontent.com/u/${value}?v=4&s=${me.avatarSize}`;
            } else {
                let url = new URL(value);
                url.searchParams.set('s', me.avatarSize);
                urlStr = url.toString();
            }

            me.vdom.cn[0].src = urlStr;
            me.update()
        }
    }

    /**
     * @param {String|null} value
     * @param {String|null} oldValue
     */
    afterSetFullName(value, oldValue) {
        let me = this;

        if (value) {
            me.vdom.cn[1].cn[1].text = value;
            me.update()
        }
    }

    /**
     * @param {String|null} value
     * @param {String|null} oldValue
     */
    afterSetUsername(value, oldValue) {
        let me = this;

        if (value) {
            let link = me.vdom.cn[1].cn[0];

            link.href = `https://github.com/${value}`;
            link.text = value;
            me.update()
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(GitHubUser));


/***/ },

/***/ "./src/component/Icon.mjs"
/*!********************************!*\
  !*** ./src/component/Icon.mjs ***!
  \********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @class Neo.component.Icon
 * @extends Neo.component.Base
 */
class Icon extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.Icon'
         * @protected
         */
        className: 'Neo.component.Icon',
        /**
         * @member {String} ntype='icon'
         * @protected
         */
        ntype: 'icon',
        /**
         * @member {String[]} baseCls=['neo-icon']
         */
        baseCls: ['neo-icon'],
        /**
         * @member {String|null} cellIconCls_=null
         * @reactive
         */
        cellIconCls_: null,
        /**
         * @member {String} tag='i'
         */
        tag: 'i'
    }

    /**
     * Triggered after the cellIconCls config got changed
     * @param {String|String[]|null} value
     * @param {String|String[]|null} oldValue
     */
    afterSetCellIconCls(value, oldValue) {
        let cls = this.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].removeAdd(cls, oldValue, value);

        this.cls = cls
    }

    /**
     * Triggered before the cellIconCls config gets changed. Converts the string into an array if needed.
     * @param {Array|String|null} value    The new value of the cellIconCls config.
     * @param {Array|String|null} oldValue The old value of the cellIconCls config.
     * @returns {Array}
     * @protected
     */
    beforeSetCellIconCls(value, oldValue) {
        if (value && !Array.isArray(value)) {
            value = value.split(' ').filter(Boolean)
        }

        return value
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Icon));


/***/ },

/***/ "./src/component/IconLink.mjs"
/*!************************************!*\
  !*** ./src/component/IconLink.mjs ***!
  \************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @class Neo.component.IconLink
 * @extends Neo.component.Base
 */
class IconLink extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.IconLink'
         * @protected
         */
        className: 'Neo.component.IconLink',
        /**
         * @member {String} ntype='icon-link'
         * @protected
         */
        ntype: 'icon-link',
        /**
         * @member {String[]} baseCls=['neo-icon-link']
         */
        baseCls: ['neo-icon-link'],
        /**
         * @member {String|null} cellIconCls_=null
         * @reactive
         */
        cellIconCls_: null,
        /**
         * @member {String|null} label_=null
         * @reactive
         */
        label_: null,
        /**
         * @member {String} tag='a'
         */
        tag: 'a',
        /**
         * @member {String} target_='_blank'
         * @reactive
         */
        target_: '_blank',
        /**
         * @member {String|null} url_=null
         * @reactive
         */
        url_: null,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {cn: [
            {tag: 'i', cls: []},
            {tag: 'span', cls: ['neo-link-label'], style: {visibility: 'hidden'}}
        ]}
    }

    /**
     * Triggered after the cellIconCls config got changed
     * @param {String|String[]|null} value
     * @param {String|String[]|null} oldValue
     */
    afterSetCellIconCls(value, oldValue) {
        let me   = this,
            node = me.vdom.cn[0],
            cls  = node.cls || [];

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].removeAdd(cls, oldValue, value);

        node.cls = cls;
        me.update()
    }

    /**
     * Triggered after the label config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     */
    afterSetLabel(value, oldValue) {
        let me   = this,
            node = me.vdom.cn[1];

        if (value) {
            node.html = value;
            delete node.style
        } else {
            node.style = {visibility: 'hidden'}
        }

        me.update()
    }

    /**
     * Triggered after the target config got changed
     * @param {String} value
     * @param {String} oldValue
     */
    afterSetTarget(value, oldValue) {
        this.changeVdomRootKey('target', value)
    }

    /**
     * Triggered after the url config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     */
    afterSetUrl(value, oldValue) {
        let me = this;

        if (value) {
            me.vdom.href = value;
            me.hidden    = false
        } else {
            delete me.vdom.href;
            me.hidden = true
        }

        me.update()
    }

    /**
     * Triggered before the cellIconCls config gets changed. Converts the string into an array if needed.
     * @param {Array|String|null} value    The new value of the cellIconCls config.
     * @param {Array|String|null} oldValue The old value of the cellIconCls config.
     * @returns {Array}
     * @protected
     */
    beforeSetCellIconCls(value, oldValue) {
        if (value && !Array.isArray(value)) {
            value = value.split(' ').filter(Boolean)
        }

        return value
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(IconLink));


/***/ },

/***/ "./src/component/Progress.mjs"
/*!************************************!*\
  !*** ./src/component/Progress.mjs ***!
  \************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");


/**
 * @class Neo.component.Progress
 * @extends Neo.component.Base
 */
class Progress extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.Progress'
         * @protected
         */
        className: 'Neo.component.Progress',
        /**
         * @member {String} ntype='progress'
         * @protected
         */
        ntype: 'progress',
        /**
         * @member {String[]} baseCls=['neo-progress-label']
         * @protected
         */
        baseCls: ['neo-progress'],
        /**
         * @member {String|null} labelText_=null
         * @reactive
         */
        labelText_: null,
        /**
         * @member {Number} max_=100
         * @reactive
         */
        max_: 100,
        /**
         * @member {Number|null} value_=null
         * @reactive
         */
        value_: null,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {tag: 'div', cls: ['neo-progress-wrapper'], cn: [
            {tag: 'label'},
            {tag: 'progress'}
        ]}
    }

    /**
     * @member {Object} label
     */
    get label() {
        return this.vdom.cn[0]
    }
    /**
     * @member {Object} progress
     */
    get progress() {
        return this.vdom.cn[1]
    }

    /**
     * @protected
     */
    ensureStableIds() {
        super.ensureStableIds();
        this.label.for = this.id
    }

    /**
     * Triggered after the labelText config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetLabelText(value, oldValue) {
        let {label} = this;

        if (!value) {
            label.removeDom = true
        } else {
            delete label.removeDom
        }

        label.text = value;
        this.update()
    }

    /**
     * Triggered after the max config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetMax(value, oldValue) {
        this.progress.max = value;
        this.update()
    }

    /**
     * Triggered after the value config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetValue(value, oldValue) {
        this.progress.value = value;
        this.update()
    }

    /**
     * Specify a different vdom root if needed to apply the top level style attributes on a different level.
     * Make sure to use getVnodeRoot() as well, to keep the vdom & vnode trees in sync.
     * @returns {Object} The new vdom root
     */
    getVdomRoot() {
        return this.vdom.cn[1]
    }

    /**
     * Specify a different vnode root if needed to apply the top level style attributes on a different level.
     * Make sure to use getVdomRoot() as well, to keep the vdom & vnode trees in sync.
     * @returns {Object} The new vnode root
     */
    getVnodeRoot() {
        return this.vnode.childNodes[1]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Progress));


/***/ },

/***/ "./src/component/Sparkline.mjs"
/*!*************************************!*\
  !*** ./src/component/Sparkline.mjs ***!
  \*************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Canvas_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Canvas.mjs */ "./src/component/Canvas.mjs");


/**
 * @class Neo.component.Sparkline
 * @extends Neo.component.Canvas
 */
class Sparkline extends _Canvas_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.Sparkline'
         * @protected
         */
        className: 'Neo.component.Sparkline',
        /**
         * @member {String[]} cls=['neo-sparkline-canvas']
         */
        cls: ['neo-sparkline-canvas'],
        /**
         * @member {Object[]} domListeners
         */
        domListeners: [{
            mousemove : {fn: 'onMouseMove', local: true},
            mouseleave: 'onMouseLeave'
        }],
        /**
         * @member {Object} listeners
         */
        listeners: {
            resize: 'onResize'
        },
        /**
         * @member {String} ntype='sparkline'
         * @protected
         */
        ntype: 'sparkline',
        /**
         * The class name of the renderer to use in the worker.
         * @member {String} rendererClassName='Neo.canvas.Sparkline'
         */
        rendererClassName: 'Neo.canvas.Sparkline',
        /**
         * The import path for the renderer module.
         * @member {String} rendererImportPath='src/canvas/Sparkline.mjs'
         */
        rendererImportPath: 'src/canvas/Sparkline.mjs',
        /**
         * Controls the "Living Pulse" animation.
         * Set to `false` to disable the background animation.
         * @member {Boolean} usePulse_=true
         */
        usePulse_: true,
        /**
         * Set to `false` to disable the data change animation.
         * @member {Boolean} useTransition_=true
         */
        useTransition_: true,
        /**
         * @member {Number[]|null} values_=null
         */
        values_: null,
        /**
         * @member {String[]} wrapperCls=['neo-sparkline-wrapper']
         */
        wrapperCls: ['neo-sparkline-wrapper'],
        /**
         * @member {Object} _vdom
         */
        _vdom: {
            cn: [{
                tag: 'canvas'
            }]
        }
    }

    /**
     * Updates the pulse configuration in the worker when `usePulse` changes.
     * @param {Boolean} value
     * @param {Boolean} oldValue
     */
    afterSetUsePulse(value, oldValue) {
        let me = this;

        if (me.offscreenRegistered && value !== undefined) {
            me.renderer?.updateConfig({
                canvasId: me.id,
                usePulse: value
            })
        }
    }

    /**
     * Updates the transition configuration in the worker when `useTransition` changes.
     * @param {Boolean} value
     * @param {Boolean} oldValue
     */
    afterSetUseTransition(value, oldValue) {
        let me = this;

        if (me.offscreenRegistered && value !== undefined) {
            me.renderer?.updateConfig({
                canvasId     : me.id,
                useTransition: value
            })
        }
    }

    /**
     * Triggered after the theme config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetTheme(value, oldValue) {
        super.afterSetTheme(value, oldValue);

        let me = this;

        if (me.offscreenRegistered && value) {
            let theme = value.includes('dark') ? 'dark' : 'light';

            me.renderer?.updateConfig({
                canvasId: me.id,
                theme
            })
        }
    }

    /**
     * @param {Number[]|null} value
     * @param {Number[]|null} oldValue
     */
    afterSetValues(value, oldValue) {
        let me = this;

        if (me.offscreenRegistered && value) {
            me.renderer?.updateData({
                canvasId: me.id,
                values  : value
            })
        }
    }

    /**
     * @param {...*} args
     */
    destroy(...args) {
        let me = this;

        if (me.offscreenRegistered) {
            me.renderer?.unregister({
                canvasId: me.id
            })
        }

        super.destroy(...args)
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    async afterSetMounted(value, oldValue) {
        let me = this;

        if (value) {
            await me.ready()
        } else if (me.offscreenRegistered) {
            me.renderer?.unregister({
                canvasId: me.id
            })
        }

        super.afterSetMounted(value, oldValue)
    }

    /**
     * @param {Boolean} value
     * @param {Boolean} oldValue
     */
    async afterSetOffscreenRegistered(value, oldValue) {
        if (value) {
            let me       = this,
                {values} = me;

            await me.renderer?.register({
                canvasId        : me.id,
                devicePixelRatio: Neo.config.devicePixelRatio,
                theme           : me.theme?.includes('dark') ? 'dark' : 'light',
                usePulse        : me.usePulse,
                useTransition   : me.useTransition,
                windowId        : me.windowId
            });

            if (values) {
                me.renderer?.updateData({
                    canvasId: me.id,
                    values
                })
            }

            // Initial size sync
            let rect = await me.getDomRect(me.id);
            if (rect) {
                me.renderer?.updateSize({
                    canvasId: me.id,
                    devicePixelRatio: Neo.config.devicePixelRatio,
                    height  : rect.height,
                    width   : rect.width
                })
            }
        }
    }

    /**
     * @returns {Object|null}
     */
    get renderer() {
        return this.rendererClassName ? Neo.ns(this.rendererClassName) : null
    }

    /**
     * @returns {Object}
     */
    getVdomRoot() {
        return this.vdom.cn[0]
    }

    /**
     * @returns {Object}
     */
    getVnodeRoot() {
        return this.vnode.childNodes[0]
    }

    /**
     * @returns {Promise<void>}
     */
    async initAsync() {
        await super.initAsync();

        if (this.rendererImportPath) {
             // Ensure Canvas Worker is running
            await Neo.worker.Manager.startWorker({name: 'canvas'});

            // Wait for the Canvas Worker remote to be available.
            let i = 0;

            while (!Neo.ns('Neo.worker.Canvas.loadModule') && i < 40) {
                await this.timeout(50);
                i++
            }

            if (Neo.ns('Neo.worker.Canvas.loadModule')) {
                // Load the specific renderer module for this component
                await Neo.worker.Canvas.loadModule({
                    path: this.rendererImportPath
                })
            } else {
                console.error('Neo.component.Sparkline: Canvas Worker failed to register remote methods.')
            }
        }
    }

    /**
     * @param {Object} data
     */
    onMouseLeave(data) {
        this.renderer?.onMouseLeave({
            canvasId: this.id
        })
    }

    /**
     * @param {Object} data
     */
    onMouseMove(data) {
        this.renderer?.onMouseMove({
            canvasId: this.id,
            x       : data.offsetX,
            y       : data.offsetY
        })
    }

    /**
     * @param {Object} data
     */
    onResize(data) {
        this.renderer?.updateSize({
            canvasId        : this.id,
            devicePixelRatio: Neo.config.devicePixelRatio,
            height          : data.contentRect.height,
            width           : data.contentRect.width
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Sparkline));


/***/ },

/***/ "./src/grid/Body.mjs"
/*!***************************!*\
  !*** ./src/grid/Body.mjs ***!
  \***************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../collection/Base.mjs */ "./src/collection/Base.mjs");
/* harmony import */ var _Row_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Row.mjs */ "./src/grid/Row.mjs");
/* harmony import */ var _selection_grid_RowModel_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../selection/grid/RowModel.mjs */ "./src/selection/grid/RowModel.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/VDom.mjs */ "./src/util/VDom.mjs");







/**
 * @summary Manages the scrollable viewport and row rendering for the Grid.
 *
 * `Neo.grid.Body` is the engine behind the Grid's virtual scrolling. It extends {@link Neo.component.Base} rather than
 * `Neo.container.Base` to enforce a strict **Row Pooling** architecture.
 *
 * **Why Component and not Container?**
 * Since the Grid uses a **Fixed-DOM-Order** strategy, the standard Container APIs (`add`, `remove`, `move`) are
 * fundamentally incompatible with the row pooling logic. By extending `Component`, we hide these unsafe methods
 * while manually implementing the necessary config propagation (theme, appName, windowId) to the managed Row instances.
 *
 * **Row Pooling:**
 * Instead of creating a component for every record in the store, it uses a pool:
 *
 * 1.  It creates a fixed pool of {@link Neo.grid.Row} components based on the visible height + a buffer.
 * 2.  As the user scrolls, these Row instances are recycled. Their `record` and `rowIndex` configs are updated via
 *     {@link Neo.grid.Row#updateContent}, triggering a lightweight VDOM update.
 * 3.  It calculates the `mountedRows` (rendered DOM nodes) and `visibleRows` (viewport intersection) to optimize rendering.
 *
 * This architecture ensures O(1) performance for record updates and constant memory usage regardless of dataset size.
 *
 * **Fixed-DOM-Order Strategy:**
 * To maximize scrolling performance, `Body` uses a "recycling in place" strategy. The Row components in the `items`
 * array and the corresponding DOM nodes in `vdom.cn` **never change their order**.
 *
 * - When a row scrolls off the top, it remains the "first" child in the DOM but is visually repositioned
 *   to the bottom via CSS transform (`translate3d`) and updated with new record content.
 * - This approach eliminates `moveNode`, `insertNode`, and `removeNode` operations, resulting in
 *   zero layout thrashing during scrolling.
 *
 * @class Neo.grid.Body
 * @extends Neo.component.Base
 * @see Neo.grid.Row
 * @see Neo.grid.Container
 */
class GridBody extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.grid.Body'
         * @protected
         */
        className: 'Neo.grid.Body',
        /**
         * @member {String} ntype='grid-body'
         * @protected
         */
        ntype: 'grid-body',
        /**
         * @member {Boolean} animatedRowSorting_=false
         * @reactive
         */
        animatedRowSorting_: false,
        /**
         * Internal flag. Gets calculated when mounting the grid.Container
         * @member {Number} availableHeight_=0
         * @reactive
         */
        availableHeight_: 0,
        /**
         * Internal flag. Gets calculated when changing the availableHeight config
         * @member {Number} availableRows_=0
         * @reactive
         */
        availableRows_: 0,
        /**
         * Internal flag. Gets calculated after mounting grid.Body rows
         * @member {Number} availableWidth_=0
         * @reactive
         */
        availableWidth_: 0,
        /**
         * @member {String[]} baseCls=['neo-grid-body']
         * @protected
         */
        baseCls: ['neo-grid-body'],
        /**
         * The number of columns (cells) to paint before the first and after the last visible column,
         * to enhance the scrolling performance
         * @member {Number} bufferColumnRange_=0
         * @reactive
         */
        bufferColumnRange_: 0,
        /**
         * The number of rows to paint before the first and after the last visible row,
         * to enhance the scrolling performance
         * @member {Number} bufferRowRange_=3
         * @reactive
         */
        bufferRowRange_: 3,
        /**
         * The pool size for recyclable cells.
         * Auto-calculated based on mounted columns range.
         * @member {Number} cellPoolSize_=20
         * @protected
         * @reactive
         */
        cellPoolSize_: 20,
        /**
         * Define which model field contains the value of colspan definitions
         * @member {String} colspanField='colspan'
         */
        colspanField: 'colspan',
        /**
         * Internal flag. Gets calculated after mounting grid.Body rows
         * @member {Number} containerWidth_=0
         * @reactive
         */
        containerWidth_: 0,
        /**
         * @member {Neo.collection.Base|null} columnPositions_=null
         * @protected
         * @reactive
         */
        columnPositions_: null,
        /**
         * @member {Boolean} highlightModifiedCells_=false
         * @reactive
         */
        highlightModifiedCells_: false,
        /**
         * @member {Boolean} isScrolling_=false
         * @reactive
         */
        isScrolling_: false,
        /**
         * Additional used keys for the selection model
         * @member {Object} keys
         */
        keys: {},
        /**
         * Stores the indexes of the first & last mounted columns, including bufferColumnRange
         * @member {Number[]} mountedColumns_=[0,0]
         * @protected
         * @reactive
         */
        mountedColumns_: [0, 0],
        /**
         * Stores the indexes of the first & last mounted rows, including bufferRowRange
         * @member {Number[]} mountedRows=[0,0]
         * @protected
         */
        mountedRows: [0, 0],
        /**
         * Optional config values for Neo.grid.plugin.AnimateRows
         * @member {Object} pluginAnimateRowsConfig=null
         */
        pluginAnimateRowsConfig: null,
        /**
         * @member {String} role='rowgroup'
         * @reactive
         */
        role: 'rowgroup',
        /**
         * Number in px
         * @member {Number} rowHeight_=0
         * @reactive
         */
        rowHeight_: 0,
        /**
         * @member {Number} scrollLeft_=0
         * @protected
         * @reactive
         */
        scrollLeft_: 0,
        /**
         * @member {Number} scrollTop_=0
         * @protected
         * @reactive
         */
        scrollTop_: 0,
        /**
         * @member {Neo.selection.Model} selectionModel_=null
         * @reactive
         */
        selectionModel_: null,
        /**
         * @member {String} selectedRecordField='annotations.selected'
         */
        selectedRecordField: 'annotations.selected',
        /**
         * @member {Number} startIndex_=0
         * @reactive
         */
        startIndex_: 0,
        /**
         * @member {Neo.data.Store|null} store_=null
         * @reactive
         */
        store_: null,
        /**
         * Stores the indexes of the first & last painted columns
         * @member {Number[]} visibleColumns=[0,0]
         * @protected
         */
        visibleColumns: [0, 0],
        /**
         * Stores the indexes of the first & last visible rows, excluding bufferRowRange
         * @member {Number[]} visibleRows=[0,0]
         * @protected
         */
        visibleRows: [0, 0],
        /**
         * @member {String[]} wrapperCls=['neo-grid-body-wrapper']
         * @reactive
         */
        wrapperCls: ['neo-grid-body-wrapper'],
        /**
         * @member {Boolean} useRowRecordIds=true
         */
        useRowRecordIds: true,
        /**
         * @member {Boolean} useInternalId=true
         */
        useInternalId: true,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {tabIndex: '-1', cn: [
            {cn: []}
        ]}
    }

    /**
     * Internal flag to adopt to store.add() passing an initial chunk.
     * @member {Number} #initialChunkSize=0
     */
    #initialChunkSize = 0
    /**
     * Internal flag to adopt to store.add() passing an initial chunk.
     * @member {Number} #initialChunkSize=0
     */
    #initialTotalSize = 0
    /**
     * Internal cache for the last mountedColumns state.
     * Used to detect horizontal scrolling/resizing to force row updates.
     * @member {Number[]|null} #lastMountedColumns=null
     */
    #lastMountedColumns = null
    /**
     * @member {Object[]} items=[]
     */
    items = []

    /**
     * @member {String[]} selectedCells
     */
    get selectedCells() {
        let {selectionModel} = this;

        if (selectionModel.ntype?.includes('cell')) {
            return selectionModel.items
        }

        return []
    }

    /**
     * @member {String[]} selectedRows
     */
    get selectedRows() {
        let {selectionModel} = this;

        if (selectionModel.ntype?.includes('row')) {
            return selectionModel.selectedRows
        }

        return []
    }

    /**
     * @param config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.addDomListeners([{
            click   : me.onCellClick,
            dblclick: me.onCellDoubleClick,
            delegate: '.neo-grid-cell',
            scope   : me
        }, {
            click   : me.onRowClick,
            dblclick: me.onRowDoubleClick,
            delegate: '.neo-grid-row',
            scope   : me
        }])
    }

    /**
     * Triggered after the animatedRowSorting config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetAnimatedRowSorting(value, oldValue) {
        if (value && !this.getPlugin('grid-animate-rows')) {
            __webpack_require__.e(/*! import() */ "src_grid_plugin_AnimateRows_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./plugin/AnimateRows.mjs */ "./src/grid/plugin/AnimateRows.mjs")).then(module => {
                let me      = this,
                    plugins = me.plugins || [];

                plugins.push({
                    module: module.default,
                    ...me.pluginAnimateRowsConfig
                });

                me.plugins = plugins
            })
        }
    }

    /**
     * Triggered after the appName config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetAppName(value, oldValue) {
        let me = this;

        super.afterSetAppName(value, oldValue);

        if (value) {
            for (let i = 0, len = me.items.length; i < len; i++) {
                me.items[i].appName = value
            }
        }
    }

    /**
     * Triggered after the availableHeight config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetAvailableHeight(value, oldValue) {
        if (value > 0) {
            this.availableRows = Math.ceil(value / this.rowHeight) - 1
        }
    }

    /**
     * Triggered after the availableRows config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetAvailableRows(value, oldValue) {
        value > 0 && this.createViewData()
    }

    /**
     * Triggered after the availableWidth config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetAvailableWidth(value, oldValue) {
        if (value > 0) {
            let me = this;

            me.vdom.width = value + 'px';
            me.vdom.cn[0].width = value + 'px';
            me.update()
        }
    }

    /**
     * Triggered after the bufferColumnRange config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetBufferColumnRange(value, oldValue) {
        if (oldValue !== undefined) {
            this.skipCreateViewData = true;
            this.updateMountedAndVisibleColumns(true);
            this.skipCreateViewData = false;
            this.createViewData()
        }
    }

    /**
     * Triggered after the bufferRowRange config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetBufferRowRange(value, oldValue) {
        if (oldValue !== undefined) {
            let current = Math.floor(this.scrollTop / this.rowHeight);

            if (Math.abs(this.startIndex - current) >= value) {
                this.skipCreateViewData = true;
                this.startIndex = current;
                this.skipCreateViewData = false;
            }

            this.createViewData(false, true)
        }
    }

    /**
     * Triggered after the containerWidth config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetContainerWidth(value, oldValue) {
        value > 0 && this.updateMountedAndVisibleColumns()
    }

    /**
     * Triggered after the isScrolling config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetIsScrolling(value, oldValue) {
        this.toggleCls('neo-is-scrolling', value);
        this.fire('isScrollingChange', {value})
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        if (oldValue !== undefined) {
            let i = 0, len = this.items.length, item;
            for (; i < len; i++) {
                item = this.items[i];
                if (!item.vdom.removeDom) {
                    item.mounted = value
                }
            }
        }
    }

    /**
     * Triggered after the mountedColumns config got changed
     * @param {Number[]} value
     * @param {Number[]} oldValue
     * @protected
     */
    afterSetMountedColumns(value, oldValue) {
        oldValue && this.createViewData()
    }

    /**
     * Triggered after the rowHeight config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetRowHeight(value, oldValue) {
        value > 0 && this.updateScrollHeight()
    }

    /**
     * Triggered after the scrollLeft config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetScrollLeft(value, oldValue) {
        this.updateMountedAndVisibleColumns()
    }

    /**
     * Triggered after the scrollTop config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetScrollTop(value, oldValue) {
        let me               = this,
            {bufferRowRange} = me,
            newStartIndex    = Math.floor(value / me.rowHeight);

        if (Math.abs(me.startIndex - newStartIndex) >= bufferRowRange) {
            me.startIndex = newStartIndex
        } else {
            me.visibleRows[0] = newStartIndex;
            me.visibleRows[1] = newStartIndex + me.availableRows
        }
    }

    /**
     * Triggered after the selectionModel config got changed
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @protected
     */
    afterSetSelectionModel(value, oldValue) {
        this.vnodeInitialized && value.register(this)
    }

    /**
     * Triggered after the startIndex config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetStartIndex(value, oldValue) {
        oldValue !== undefined && this.createViewData()
    }

    /**
     * Triggered after the store config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetStore(value, oldValue) {
        let me        = this,
            listeners = {
                filter      : me.onStoreFilter,
                load        : me.onStoreLoad,
                recordChange: me.onStoreRecordChange,
                scope       : me
            };

        oldValue?.un(listeners);
        value   ?.on(listeners);
    }

    /**
     * Triggered after the theme config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetTheme(value, oldValue) {
        let me = this;

        super.afterSetTheme(value, oldValue);

        if (value) {
            for (let i = 0, len = me.items.length; i < len; i++) {
                me.items[i].theme = value
            }
        }
    }

    /**
     * Triggered after the windowId config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        let me = this;

        super.afterSetWindowId(value, oldValue);

        if (value) {
            for (let i = 0, len = me.items.length; i < len; i++) {
                me.items[i].windowId = value
            }
        }
    }

    /**
     * Triggered after the columnPositions config got changed
     * @param {Object} value
     * @protected
     */
    beforeGetColumnPositions(value) {
        if (!value) {
            this._columnPositions = value = Neo.create({
                module     : _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
                keyProperty: 'dataField'
            })
        }

        return value
    }

    /**
     * Triggered before the selectionModel config gets changed.
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @protected
     */
    beforeSetSelectionModel(value, oldValue) {
        oldValue?.destroy();

        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].beforeSetInstance(value, _selection_grid_RowModel_mjs__WEBPACK_IMPORTED_MODULE_4__["default"])
    }

    /**
     * Initializes or expands the pool of `Neo.grid.Row` instances.
     *
     * This method calculates the number of rows needed to cover the viewport plus the buffer range.
     * If the current number of child items (Rows) is less than required, it creates new instances
     * and adds them to the container. This ensures we have enough "physical" rows to recycle during scrolling.
     *
     * @protected
     */
    createRowPool() {
        let me      = this,
            needed  = me.availableRows + 2 * me.bufferRowRange,
            current = me.items.length,
            delta   = needed - current,
            newRows = [],
            config, i;

        if (delta > 0) {
            for (i = 0; i < delta; i++) {
                config = {
                    module       : _Row_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
                    appName      : me.appName,
                    gridContainer: me.parent,
                    id           : me.getRowId(current + i),
                    parentId     : me.id,
                    record       : null,
                    rowIndex     : -1,
                    theme        : me.theme,
                    windowId     : me.windowId
                };

                newRows.push(Neo.create(config))
            }
            me.items.push(...newRows)
        } else if (delta < 0) {
            // Self-Healing: Destroy excess rows to free memory and VDOM overhead.
            // This restores performance if the buffer is reduced after being large.
            for (i = current - 1; i >= needed; i--) {
                me.items[i].destroy();
                me.items.pop()
            }
        }

        // Fixed-DOM-Order Strategy:
        // We ensure the VDOM children (cn) matches the full pool of items exactly.
        // We never remove or reorder these nodes. We only update their content and transform.
        me.getVdomRoot().cn = me.items.map(item => item.createVdomReference())
    }

    /**
     * The main rendering loop for the Grid Body.
     *
     * This method:
     * 1.  Calculates the range of records to render based on scroll position.
     * 2.  Calls `createRowPool` to ensure enough Row components exist.
     * 3.  Iterates through the visible record range.
     * 4.  **Recycles** existing Row components by calling {@link Neo.grid.Row#updateContent} with the new record data.
     * 5.  Updates the scroll spacer height.
     *
     * **Optimization Strategies:**
     * - **Row Skipping:** If `force` is false and the record/rowIndex match, `Row.updateContent` skips VDOM generation.
     * - **Cell Recycling:** If horizontal scrolling is detected (implicit force), `recycle=true` is passed to Rows, allowing them to reuse existing cell VDOM nodes.
     * - **Forced Updates:** Explicit `force=true` (e.g. from column resize) disables recycling to ensure full re-render.
     *
     * @param {Boolean} [silent=false] True to suppress the final VDOM update (used when batching).
     * @param {Boolean} [force=false] True to force row updates even if records haven't changed (e.g. column resize).
     */
    createViewData(silent=false, force=false) {
        let me = this;

        if (me.skipCreateViewData) {
            return
        }

        let {mountedRows, store} = me,
            endIndex, i, item, itemIndex, poolSize, range, recycle = true;

        if (
            store.isLoading                   ||
            me.availableRows              < 1 ||
            me._containerWidth            < 1 || // we are not checking me.containerWidth, since we want to ignore the config symbol
            me.columnPositions.getCount() < 1 ||
            me.mountedColumns[1]          < 1
        ) {
            return
        }

        if (me.isVdomUpdating) {
            Neo.manager.VDomUpdate.registerPreUpdate(me.id, () => {
                me.createViewData(silent, force)
            });
            return
        }

        // Auto-detect if columns changed (horizontal scroll or resize)
        if (!force && !Neo.isEqual(me.mountedColumns, me.#lastMountedColumns)) {
            force = true
        }
        // If force was explicitly passed (e.g. column dataField change), we must disable recycling
        // to ensure new dataField values are picked up.
        // If force was implicit (scroll), recycling is safe and desired.
        else if (force) {
            recycle = false
        }

        me.#lastMountedColumns = [...me.mountedColumns];

        if (me.#initialChunkSize > 0) {
            endIndex = me.#initialChunkSize;
            range    = endIndex;
        } else {
            // Creates the new start & end indexes
            me.updateMountedAndVisibleRows();
            endIndex = mountedRows[1]
        }

        me.createRowPool();

        poolSize = me.items.length;

        // Fixed-DOM-Order Strategy:
        // We do NOT clear vdomRoot.cn. The Row components remain in the VDOM array.
        // We iterate the logical range, mapping records to the fixed pool items via modulo.

        let usedMap = new Array(poolSize).fill(false);

        for (i=mountedRows[0]; i < endIndex; i++) {
            itemIndex = i % poolSize;
            item      = me.items[itemIndex];

            usedMap[itemIndex] = true;

            item.updateContent({
                force,
                record  : store.getAt(i),
                recycle,
                rowIndex: i,
                silent  : true
            });
        }

        // Hide unused pool items (e.g. when filtering or at the end of the store)
        for (i = 0; i < poolSize; i++) {
            if (!usedMap[i]) {
                item = me.items[i];
                // Only update if it currently has a record (was visible)
                if (item.record) {
                    item.updateContent({
                        record  : null,
                        rowIndex: -1,
                        silent  : true
                    })
                }
            }
        }

        me.parent.isLoading = false;

        me.updateScrollHeight(true, range); // silent

        if (!silent) {
            me.updateDepth = -1;
            me.update()
        }
    }

    /**
     * @param args
     */
    destroy(...args) {
        let me = this;

        for (let i = 0, len = me.items.length; i < len; i++) {
            me.items[i].destroy()
        }

        me.store = null; // remove the listeners

        super.destroy(...args)
    }

    /**
     * @param {Object} data
     * @param {String} eventName
     */
    fireCellEvent(data, eventName) {
        let me        = this,
            id        = data.currentTarget,
            dataField, record, recordId, target;

        for (target of data.path) {
            if (target.data?.field) {
                dataField = target.data.field;
                recordId  = target.data.recordId;
                record    = me.getRecord(recordId);
                break
            }
        }

        if (!dataField) {
            dataField = me.getCellDataField(id);
            record    = me.getRecord(id)
        }

        me.parent.fire(eventName, {body: me, data, dataField, record})
    }

    /**
     * @param {Object} data
     * @param {String} eventName
     */
    fireRowEvent(data, eventName) {
        let me     = this,
            id     = data.currentTarget,
            record, recordId, target;

        for (target of data.path) {
            if (target.cls?.includes('neo-grid-row') && target.data?.recordId) {
                recordId = target.data.recordId;
                record   = me.getRecord(recordId);
                break
            }
        }

        if (!record) {
            record = me.getRecord(id)
        }

        me.parent.fire(eventName, {body: me, data, record})
    }

    /**
     * @param {String} cellId
     * @returns {String}
     */
    getCellDataField(cellId) {
        return this.getDataField(cellId)
    }

    /**
     * @param {Number} rowIndex
     * @param {String} dataField
     * @returns {String}
     */
    getCellId(rowIndex, dataField) {
        let me          = this,
            column      = me.getColumn(dataField),
            columnIndex = me.getColumn(dataField, true),
            rowId       = me.getRowId(rowIndex);

        if (column.hideMode === 'removeDom') {
            return `${rowId}__cell-${columnIndex % me.cellPoolSize}`
        }

        return `${rowId}__${dataField}`
    }

    /**
     * @param {Object} record
     * @param {String} dataField
     * @returns {String}
     */
    getLogicalCellId(record, dataField) {
        return `${this.getRecordId(record)}__${dataField}`
    }

    /**
     * Get a grid column or column index by a given field name
     * @param {String} field
     * @param {Boolean} returnIndex=false
     * @returns {Object|Number|null}
     */
    getColumn(field, returnIndex=false) {
        let {columns} = this.parent,
            column    = columns.get(field);

        if (column) {
            return returnIndex ? columns.indexOf(column) : column
        }

        return null
    }

    /**
     * Get all painted column cells (visible + buffer range)
     * @param {String} dataField
     * @returns {Object[]}
     */
    getColumnCells(dataField) {
        let me          = this,
            cells       = [],
            columnIndex = -1,
            firstRow    = me.items[0].vdom,
            i           = 0,
            len         = firstRow.cn.length,
            cell;

        // Columns might get moved via drag&drop, so let's check for the current match
        for (; i < len; i++) {
            if (dataField === me.getDataField(firstRow.cn[i].id)) {
                columnIndex = i;
                break;
            }
        }

        if (columnIndex > -1) {
            for (i = 0, len = me.items.length; i < len; i++) {
                cell = me.items[i].vdom.cn[columnIndex];
                cell && cells.push(cell)
            }
        }

        return cells
    }

    /**
     * @param {String} cellId
     * @returns {String}
     */
    getDataField(cellId) {
        if (cellId.includes('__cell-')) {
            let me            = this,
                poolIndex     = parseInt(cellId.split('__cell-')[1]),
                columns       = me.parent.columns,
                {cellPoolSize, mountedColumns} = me,
                i             = mountedColumns[0],
                len           = mountedColumns[1],
                column;

            for (; i <= len; i++) {
                if (i % cellPoolSize === poolIndex) {
                    column = columns.getAt(i);
                    // Sanity check: ensure this column is actually pooled
                    if (column && column.hideMode === 'removeDom') {
                        return column.dataField
                    }
                }
            }
        }

        return cellId.split('__').pop()
    }

    /**
     * Get the matching record by passing a row id, a cell id or an id inside a grid cell.
     * Limited to mounted rows (must be inside the vdom).
     * @param {String} nodeId
     * @returns {Object|null}
     */
    getRecord(nodeId) {
        let me     = this,
            record = me.getRecordByRowId(nodeId),
            node, parentNodes;

        if (record) {
            return record;
        }

        // Check if nodeId is a recordId (internalId or PK)
        record = me.store.get(nodeId);
        if (record) return record;

        parentNodes = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].getParentNodes(me.vdom, nodeId);

        for (node of parentNodes || []) {
            record = me.getRecordByRowId(node.componentId || node.id);

            if (record) {
                return record
            }
        }

        return null
    }

    /**
     * @param {Object} record
     * @returns {String|Number}
     */
    getRecordId(record) {
        return this.useInternalId ? this.store.getInternalId(record) : this.store.getKey(record)
    }

    /**
     * @param {String} logicalId
     * @returns {Neo.data.Model|null}
     */
    getRecordFromLogicalId(logicalId) {
        let me        = this,
            dataField = me.getDataField(logicalId),
            recordId  = logicalId.substring(0, logicalId.length - dataField.length - 2),
            record    = me.getRecord(recordId); // Uses the new robust getRecord()

        if (!record) {
            record = me.store.get(parseInt(recordId))
        }

        return record
    }

    /**
     * @param {String} rowId
     * @returns {Record|null}
     */
    getRecordByRowId(rowId) {
        let me       = this,
            node     = Neo.getComponent(rowId)?.vdom,
            rowIndex = node?.['aria-rowindex'];

        if (Neo.isNumber(rowIndex)) {
            // aria-rowindex is 1 based & also includes the header
            rowIndex -= 2;

            return me.store.getAt(rowIndex)
        }

        return null
    }

    /**
     * @param {Object} record
     * @returns {Neo.grid.Row|null}
     */
    getRow(record) {
        let me       = this,
            rowIndex = me.store.indexOf(record),
            itemIndex;

        if (rowIndex > -1 && rowIndex >= me.mountedRows[0] && rowIndex <= me.mountedRows[1]) {
            itemIndex = rowIndex % me.items.length;
            return me.items[itemIndex]
        }

        return null
    }

    /**
     * Override this method to apply custom CSS rules to grid rows
     * @param {Object} record
     * @param {Number} rowIndex
     * @returns {String[]}
     */
    getRowClass(record, rowIndex) {
        return ['neo-grid-row']
    }

    /**
     * @param {Number} rowIndex
     * @returns {String}
     */
    getRowId(rowIndex) {
        let me = this;

        if (me.#initialChunkSize > 0) {
            return `${me.id}__row-${rowIndex}`
        } else {
            return `${me.id}__row-${rowIndex % (me.availableRows + 2 * me.bufferRowRange)}`
        }
    }

    /**
     * @override
     * @returns {*}
     */
    getVdomRoot() {
        return this.vdom.cn[0]
    }

    /**
     * @returns {Object[]} The new vdom items root
     */
    getVdomItemsRoot() {
        return this.vdom.cn[0]
    }

    /**
     * @override
     * @returns {Neo.vdom.VNode}
     */
    getVnodeRoot() {
        return this.vnode.childNodes[0]
    }

    /**
     * @param {Object} data
     */
    onCellClick(data) {
        this.fireCellEvent(data, 'cellClick')
    }

    /**
     * @param {Object} data
     */
    onCellDoubleClick(data) {
        this.fireCellEvent(data, 'cellDoubleClick')
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();
        this.selectionModel?.register(this)
    }

    /**
     * @param {Object} data
     */
    onRowClick(data) {
        this.focus(this.vdom.id, false, true);
        this.fireRowEvent(data, 'rowClick')
    }

    /**
     * @param {Object} data
     */
    onRowDoubleClick(data) {
        this.fireRowEvent(data, 'rowDoubleClick')
    }

    /**
     * @param {Object} data
     */
    onScrollCapture(data) {
        super.onScrollCapture(data);
        this.parent.scrollManager.onBodyScroll(data)
    }

    /**
     * @param {Object} data
     */
    onStoreFilter() {
        this.onStoreLoad({items: this.store.items})
    }

    /**
     * @param {Object}   data
     * @param {Object[]} data.items
     * @param {Boolean}  [data.postChunkLoad]
     * @param {Number}   [data.total]
     * @protected
     */
    onStoreLoad({items, postChunkLoad, total}) {
        let me         = this,
            {windowId} = me;

        // If it's the first chunked load (data.total exists and data.items is a subset of total)
        // Render the entire chunk for immediate scrollability
        if (total && items.length < total) {
            me.#initialChunkSize = items.length;
            me.#initialTotalSize = total;
            me.createViewData();
            me.#initialChunkSize = 0
            me.#initialTotalSize = 0
        } else {
            me.createViewData()
        }

        if (me.mounted && !postChunkLoad) {
            me.timeout(50).then(() => {
                Neo.main.DomAccess.scrollTo({
                    direction: 'top',
                    id       : me.vdom.id,
                    value    : 0,
                    windowId
                })
            })
        }
    }

    /**
     * @param {Object}         data
     * @param {Object[]}       data.fields Each field object contains the keys: name, oldValue, value
     * @param {Neo.data.Model} data.model  The model instance of the changed record
     * @param {Object}         data.record
     */
    onStoreRecordChange({fields, record}) {
        let me                            = this,
            fieldNames                    = fields.map(field => field.name),
            rowIndex                      = me.store.indexOf(record),
            {mountedRows, selectionModel} = me,
            poolSize                      = me.items.length,
            itemIndex, recordId, row;

        if (fieldNames.includes(me.colspanField)) {
            me.createViewData()
        } else {
            if (rowIndex >= mountedRows[0] && rowIndex <= mountedRows[1]) {
                itemIndex = rowIndex % poolSize;
                row       = me.items[itemIndex];

                if (row) {
                    row.createVdom()
                }

                for (let i = 0, len = fields.length; i < len; i++) {
                    let field = fields[i];
                    if (field.name === me.selectedRecordField) {
                        if (selectionModel.ntype === 'selection-grid-rowmodel') {
                            recordId = me.getRecordId(record);

                            selectionModel[field.value ? 'selectRow' : 'deselectRow'](recordId)
                        }
                    }
                }
            }
        }
    }

    /**
     * Used for keyboard navigation (selection models)
     * @param {Number} index
     * @param {Number} step
     */
    scrollByRows(index, step) {
        let me                         = this,
            {mountedRows, visibleRows} = me,
            countRecords               = me.store.getCount(),
            newIndex                   = index + step,
            lastRowGap, mounted, scrollTop, visible;

        if (newIndex >= countRecords) {
            newIndex %= countRecords;
            step     = newIndex - index
        }

        while (newIndex < 0) {
            newIndex += countRecords;
            step     += countRecords
        }

        mounted = newIndex >= mountedRows[0] && newIndex <= mountedRows[1];

        // Not using >= or <=, since the first / last row might not be fully visible
        visible = newIndex > visibleRows[0] && newIndex < visibleRows[1];

        if (!visible) {
            // Leaving the mounted area will re-calculate the visibleRows for us
            if (mounted) {
                visibleRows[0] += step;
                visibleRows[1] += step
            }

            if (step < 0) {
                scrollTop = newIndex * me.rowHeight
            } else {
                lastRowGap = me.rowHeight - (me.availableHeight % me.rowHeight);
                scrollTop  = (newIndex - me.availableRows) * me.rowHeight + lastRowGap
            }

            Neo.main.DomAccess.scrollTo({
                id      : me.vdom.id,
                value   : scrollTop,
                windowId: me.windowId
            })
        }
    }

    /**
     * @param {Boolean} [force=false]
     */
    updateMountedAndVisibleColumns(force=false) {
        let me       = this,
            {bufferColumnRange, cellPoolSize, columnPositions, mountedColumns, visibleColumns} = me,
            i            = 0,
            countColumns = columnPositions.getCount(),
            endIndex     = countColumns - 1,
            x            = me.scrollLeft,
            column, newPoolSize, startIndex = 0;

        if (countColumns < 1) {
            return
        }

        for (; i < countColumns; i++) {
            column = columnPositions.getAt(i);

            if (x >= column.x && x <= column.x + column.width) {
                startIndex = i
            }

            if (me.containerWidth + x < column.x) {
                endIndex = i - 1;
                break
            }
        }

        visibleColumns[0] = startIndex; // update the array inline
        visibleColumns[1] = endIndex;

        if (force || visibleColumns[0] <= mountedColumns[0] || visibleColumns[1] >= mountedColumns[1]) {
            startIndex = Math.max(0, visibleColumns[0] - bufferColumnRange);
            endIndex   = Math.min(countColumns - 1, visibleColumns[1] + bufferColumnRange);

            if (endIndex - startIndex >= cellPoolSize) {
                newPoolSize = endIndex - startIndex + 5;
            }

            me.set({
                cellPoolSize  : newPoolSize || cellPoolSize,
                mountedColumns: [startIndex, endIndex]
            })
        }
    }

    /**
     *
     */
    updateMountedAndVisibleRows() {
        let me             = this,
            {bufferRowRange, availableRows, startIndex, store} = me,
            countRecords   = store.getCount(),
            windowSize     = availableRows + 2 * bufferRowRange,
            endIndex       = Math.min(countRecords, startIndex + availableRows),
            mountedStart   = startIndex - bufferRowRange,
            mountedEnd     = endIndex   + bufferRowRange;

        me.visibleRows[0] = startIndex; // update the array inline
        me.visibleRows[1] = endIndex;

        // We want to maintain a constant window size (Modulus) to ensure row recycling works
        // via moveNode operations instead of removeNode + insertNode.
        // If we are at the top, extend the end to fill the window.
        if (mountedStart < 0) {
            mountedEnd  += Math.abs(mountedStart);
            mountedStart = 0
        }

        // Clamp to record count
        mountedEnd = Math.min(countRecords, mountedEnd);

        // If we are at the bottom (hit the ceiling), pull the start back to fill the window.
        // This ensures we keep the DOM nodes alive for as long as possible.
        if (mountedEnd - mountedStart < windowSize) {
            let needed   = windowSize - (mountedEnd - mountedStart);
            mountedStart = Math.max(0, mountedStart - needed)
        }

        me.mountedRows[0] = mountedStart; // update the array inline
        me.mountedRows[1] = mountedEnd
    }

    /**
     * @param {Boolean} silent=false
     */
    updateScrollHeight(silent=false) {
        let me           = this,
            countRecords = me.#initialTotalSize || me.store?.count || 0,
            {rowHeight}  = me;

        if (countRecords > 0 && rowHeight > 0) {
            me.vdom.cn[0].height = `${(countRecords + 1) * rowHeight}px`;
            !silent && me.update()
        }
    }

    /**
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            animatedRowSorting    : me.animatedRowSorting,
            bufferColumnRange     : me.bufferColumnRange,
            bufferRowRange        : me.bufferRowRange,
            colspanField          : me.colspanField,
            highlightModifiedCells: me.highlightModifiedCells,
            rowHeight             : me.rowHeight,
            selectedRecordField   : me.selectedRecordField,
            selectionModel        : me.selectionModel?.toJSON()
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(GridBody));


/***/ },

/***/ "./src/grid/Container.mjs"
/*!********************************!*\
  !*** ./src/grid/Container.mjs ***!
  \********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../collection/Base.mjs */ "./src/collection/Base.mjs");
/* harmony import */ var _Body_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Body.mjs */ "./src/grid/Body.mjs");
/* harmony import */ var _ScrollManager_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ScrollManager.mjs */ "./src/grid/ScrollManager.mjs");
/* harmony import */ var _data_Store_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../data/Store.mjs */ "./src/data/Store.mjs");
/* harmony import */ var _VerticalScrollbar_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./VerticalScrollbar.mjs */ "./src/grid/VerticalScrollbar.mjs");
/* harmony import */ var _footer_Toolbar_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./footer/Toolbar.mjs */ "./src/grid/footer/Toolbar.mjs");
/* harmony import */ var _column_export_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./column/_export.mjs */ "./src/grid/column/_export.mjs");
/* harmony import */ var _header_export_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./header/_export.mjs */ "./src/grid/header/_export.mjs");
/* harmony import */ var _core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../core/ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");












/**
 * @summary The main entry point for creating Data Grids in Neo.mjs.
 *
 * `Neo.grid.Container` orchestrates the entire Grid component. It uses a composite architecture consisting of:
 * 1.  `headerToolbar` ({@link Neo.grid.header.Toolbar}): Manages column headers, sorting, and filtering UI.
 * 2.  `body` ({@link Neo.grid.Body}): The scrollable area containing the data rows.
 * 3.  `scrollbar` ({@link Neo.grid.VerticalScrollbar}): A virtualized scrollbar for handling large datasets.
 *
 * Key features include:
 * -   **Virtual Scrolling:** Only renders visible rows and columns (plus a small buffer) for high performance with large datasets.
 * -   **Store Integration:** Binds directly to a {@link Neo.data.Store} for data management, sorting, and filtering.
 * -   **Column Management:** Supports various column types (text, component, widget) via the `columns` config.
 * -   **Multi-Threaded:** Logic runs in the App Worker, ensuring the UI stays responsive.
 *
 * @class Neo.grid.Container
 * @extends Neo.container.Base
 * @see Neo.grid.Body
 * @see Neo.grid.Row
 * @see Neo.data.Store
 */
class GridContainer extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @member {Object} columnTypes
     * @protected
     * @static
     */
    static columnTypes = {
        animatedChange  : _column_export_mjs__WEBPACK_IMPORTED_MODULE_8__.AnimatedChange,
        animatedCurrency: _column_export_mjs__WEBPACK_IMPORTED_MODULE_8__.AnimatedCurrency,
        column          : _column_export_mjs__WEBPACK_IMPORTED_MODULE_8__.Base,
        component       : _column_export_mjs__WEBPACK_IMPORTED_MODULE_8__.Component,
        countryFlag     : _column_export_mjs__WEBPACK_IMPORTED_MODULE_8__.CountryFlag,
        currency        : _column_export_mjs__WEBPACK_IMPORTED_MODULE_8__.Currency,
        githubOrgs      : _column_export_mjs__WEBPACK_IMPORTED_MODULE_8__.GitHubOrgs,
        githubUser      : _column_export_mjs__WEBPACK_IMPORTED_MODULE_8__.GitHubUser,
        icon            : _column_export_mjs__WEBPACK_IMPORTED_MODULE_8__.Icon,
        iconLink        : _column_export_mjs__WEBPACK_IMPORTED_MODULE_8__.IconLink,
        index           : _column_export_mjs__WEBPACK_IMPORTED_MODULE_8__.Index,
        linkedin        : _column_export_mjs__WEBPACK_IMPORTED_MODULE_8__.LinkedIn,
        progress        : _column_export_mjs__WEBPACK_IMPORTED_MODULE_8__.Progress,
        sparkline       : _column_export_mjs__WEBPACK_IMPORTED_MODULE_8__.Sparkline
    }
    /**
     * @member {Object} delayable
     * @protected
     * @static
     */
    static delayable = {
        onResize: {type: 'buffer', timer: 300}
    }

    static config = {
        /**
         * @member {String} className='Neo.grid.Container'
         * @protected
         */
        className: 'Neo.grid.Container',
        /**
         * @member {String} ntype='grid-container'
         * @protected
         */
        ntype: 'grid-container',
        /**
         * @member {String[]} baseCls=['neo-grid-container']
         * @protected
         */
        baseCls: ['neo-grid-container'],
        /**
         * Configs for Neo.grid.Body
         * @member {Object|null} [body_={[isDescriptor]: true, merge: 'deep', value: null}]
         * @reactive
         */
        body_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_10__.isDescriptor]: true,
            merge         : 'deep',
            value         : null
        },
        /**
         * true uses grid.plugin.CellEditing
         * @member {Boolean} cellEditing_=false
         * @reactive
         */
        cellEditing_: false,
        /**
         * Default configs for each column
         * @member {Object} columnDefaults=null
         */
        columnDefaults: null,
        /**
         * @member {Object[]} columns_=[]
         * @reactive
         */
        columns_: [],
        /**
         * Configs for Neo.toolbar.Base
         * @member {Object|null} [footerToolbar_={[isDescriptor]:true,merge:'deep',value:null}]
         * @reactive
         */
        footerToolbar_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_10__.isDescriptor]: true,
            merge         : 'deep',
            value         : null
        },
        /**
         * Configs for Neo.grid.header.Toolbar
         * @member {Object|null} [headerToolbar_={[isDescriptor]:true,merge:'deep',value:null}]
         * @reactive
         */
        headerToolbar_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_10__.isDescriptor]: true,
            merge         : 'deep',
            value         : null
        },
        /**
         * @member {Object} layout={ntype: 'vbox', align: 'stretch'}
         * @reactive
         */
        layout: {ntype: 'vbox', align: 'stretch'},
        /**
         * @member {String} role='grid'
         * @reactive
         */
        role: 'grid',
        /**
         * Number in px
         * @member {Number} rowHeight_=32
         * @reactive
         */
        rowHeight_: 32,
        /**
         * @member {Neo.grid.Scrollbar|null} scrollbar=null
         * @protected
         */
        scrollbar: null,
        /**
         * @member {Boolean} showHeaderFilters_=false
         * @reactive
         */
        showHeaderFilters_: false,
        /**
         * @member {Boolean} sortable_=true
         * @reactive
         */
        sortable_: true,
        /**
         * @member {Boolean} useInternalId_=true
         * @reactive
         */
        useInternalId_: true,
        /**
         * True enables restoring the initial sort state (ASC, DESC, null)
         * @member {Boolean} useTriStateSorting_=false
         * @reactive
         */
        useTriStateSorting_: false,
        /**
         * @member {Neo.data.Store} store_=null
         * @reactive
         */
        store_: null,
        /**
         * @member {Array|null} items=null
         * @protected
         * @reactive
         */
        items: null,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {cls: ['neo-grid-wrapper'], cn: [
            {'aria-colcount': 0, 'aria-rowcount': 1, cn: []} // aria-rowcount includes the column headers
        ]}
    }

    /**
     * We do not need the first event to trigger logic, since afterSetMounted() handles this
     * @member {Boolean} initialResizeEvent=true
     * @protected
     */
    initialResizeEvent = true
    /**
     * @member {Neo.grid.ScrollManager|null} scrollManager=null
     * @protected
     */
    scrollManager = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this,
            {appName, rowHeight, store, windowId} = me;

        me.items = [me.headerToolbar, me.body];

        if (me.footerToolbar) {
            me.items.push(me.footerToolbar)
        }

        me.scrollbar = Neo.create({
            module  : _VerticalScrollbar_mjs__WEBPACK_IMPORTED_MODULE_6__["default"],
            appName,
            parentId: me.id,
            rowHeight,
            store,
            theme   : me.theme,
            windowId
        });

        me.vdom.cn.push(me.scrollbar.createVdomReference())

        me.vdom.id = me.getWrapperId();

        me._columns = me.createColumns(me.columns);
        me.updateColCount();

        me.addDomListeners({
            resize: me.onResize,
            scope : me
        })
    }

    /**
     * @param {Boolean} mounted
     * @protected
     */
    async addResizeObserver(mounted) {
        let me             = this,
            {windowId}     = me,
            ResizeObserver = await Neo.currentWorker.getAddon('ResizeObserver', windowId),
            resizeParams   = {id: me.id, windowId};

        if (mounted) {
            ResizeObserver.register(resizeParams);
            await me.passSizeToBody()
        } else {
            me.initialResizeEvent = true;
            ResizeObserver.unregister(resizeParams)
        }
    }

    /**
     * Triggered after the cellEditing config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetCellEditing(value, oldValue) {
        if (value) {
            Promise.all(/*! import() */[__webpack_require__.e("vendors-src_table_plugin_CellEditing_mjs"), __webpack_require__.e("src_grid_plugin_CellEditing_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ./plugin/CellEditing.mjs */ "./src/grid/plugin/CellEditing.mjs")).then(module => {
                let me        = this,
                    {appName} = me,
                    plugins   = me.plugins || [];

                plugins.push({
                    module: module.default,
                    appName
                });

                me.plugins = plugins
            })
        }
    }

    /**
     * Triggered after the columns config got changed
     * @param {Neo.collection.Base|null}          value
     * @param {Object[]|Neo.collection.Base|null} oldValue
     * @protected
     */
    async afterSetColumns(value, oldValue) {
        let me              = this,
            {headerToolbar} = me;

        // - If columns changed at run-time OR
        // - In case the `header.Toolbar#createItems()` method has run before columns where available
        if (oldValue?.count || (value?.count && headerToolbar?.isConstructed)) {
            headerToolbar?.createItems()

            await me.timeout(50);

            await me.passSizeToBody();

            me.body?.createViewData()
        }

        me.configsApplied && me.updateColCount()
    }

    /**
     * Triggered after the footerToolbar config got changed
     * @param {Neo.toolbar.Base} value
     * @param {Neo.toolbar.Base} oldValue
     * @protected
     */
    afterSetFooterToolbar(value, oldValue) {
        let me = this;

        if (value && me.store && value.store !== me.store) {
            value.store = me.store
        }
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);
        oldValue !== undefined && this.addResizeObserver(value);

        let {scrollManager} = this;

        if (scrollManager) {
            scrollManager.mounted = value
        }
    }

    /**
     * Triggered after the rowHeight config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetRowHeight(value, oldValue) {
        if (value > 0) {
            let {body, scrollbar} = this;

            if (scrollbar) {
                scrollbar.rowHeight = value
            }

            if (body) {
                body.rowHeight = value
            }
        }
    }

    /**
     * Triggered after the showHeaderFilters config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowHeaderFilters(value, oldValue) {
        if (oldValue !== undefined) {
            this.headerToolbar.showHeaderFilters = value
        }
    }

    /**
     * Triggered after the sortable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetSortable(value, oldValue) {
        if (oldValue !== undefined) {
            this.headerToolbar.sortable = value
        }
    }

    /**
     * Triggered after the useTriStateSorting config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetUseTriStateSorting(value, oldValue) {
        if (oldValue !== undefined) {
            this.headerToolbar.useTriStateSorting = value
        }
    }

    /**
     * Triggered after the store config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetStore(value, oldValue) {
        let me        = this,
            listeners = {
                filter: me.onStoreFilter,
                load  : me.onStoreLoad,
                scope : me
            };

        value   ?.on(listeners);
        oldValue?.un(listeners);

        // in case we dynamically change the store, grid.Body needs to get the new reference
        if (me.body) {
            me.body.store = value
        }

        if (me.footerToolbar && me.footerToolbar.store !== value) {
            me.footerToolbar.store = value
        }
    }

    /**
     * Triggered after the useInternalId config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetUseInternalId(value, oldValue) {
        if (oldValue !== undefined && this.body) {
            this.body.useInternalId = value
        }
    }

    /**
     * Triggered before the body config gets changed.
     * @param {Object|Neo.grid.Body|null} value
     * @param {Object|Neo.grid.Body|null} oldValue
     * @protected
     */
    beforeSetBody(value, oldValue) {
        const me = this;

        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, _Body_mjs__WEBPACK_IMPORTED_MODULE_3__["default"], {
            flex         : 1,
            gridContainer: me,
            parentId     : me.id,
            store        : me.store,
            theme        : me.theme,
            useInternalId: me.useInternalId
        })
    }

    /**
     * Triggered before the columns config gets changed.
     * @param {Object[]} value
     * @param {Object[]} oldValue
     * @protected
     */
    beforeSetColumns(value, oldValue) {
        if (this.configsApplied) {
            return this.createColumns(value)
        }

        return value
    }

    /**
     * Triggered before.footerToolbar config gets changed.
     * @param {Object|Neo.toolbar.Base|null} value
     * @param {Object|Neo.toolbar.Base|null} oldValue
     * @returns {Neo.toolbar.Base|null}
     * @protected
     */
    beforeSetFooterToolbar(value, oldValue) {
        if (!value) return null;

        const me = this;

        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, _footer_Toolbar_mjs__WEBPACK_IMPORTED_MODULE_7__["default"], {
            flex    : 'none',
            parentId: me.id,
            theme   : me.theme
        })
    }

    /**
     * Triggered before the headerToolbar config gets changed.
     * @param {Object|Neo.grid.header.Toolbar|null} value
     * @param {Object|Neo.grid.header.Toolbar|null} oldValue
     * @returns {Neo.toolbar.Base|null}
     * @protected
     */
    beforeSetHeaderToolbar(value, oldValue) {
        const me = this;

        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, _header_export_mjs__WEBPACK_IMPORTED_MODULE_9__.Toolbar, {
            flex              : 'none',
            parentId          : me.id,
            showHeaderFilters : me.showHeaderFilters,
            sortable          : me.sortable,
            theme             : me.theme,
            useTriStateSorting: me.useTriStateSorting
        })
    }

    /**
     * Triggered before the store config gets changed.
     * @param {Object|Neo.data.Store|null} value
     * @param {Neo.data.Store}             oldValue
     * @protected
     */
    beforeSetStore(value, oldValue) {
        if (value) {
            value = _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, _data_Store_mjs__WEBPACK_IMPORTED_MODULE_5__["default"])
        }

        return value
    }

    /**
     * In case you want to update multiple existing records in parallel,
     * using this method is faster than updating each record one by one.
     * At least until we introduce row based vdom updates.
     * @param {Object[]} records
     */
    bulkUpdateRecords(records) {
        let {body, store} = this,
            {keyProperty} = store;

        if (body) {
            body.silentVdomUpdate = true;

            for (let i = 0, len = records.length; i < len; i++) {
                store.get(records[i][keyProperty])?.set(records[i])
            }

            body.silentVdomUpdate = false;

            body.update()
        }
    }

    /**
     * @param {Object[]} columns
     * @returns {*}
     */
    createColumns(columns) {
        let me               = this,
            {columnDefaults} = me,
            headerButtons    = [],
            sorters          = me.store?.sorters,
            columnClass, renderer;

        if (columns) {
            for (let index = 0, len = columns.length; index < len; index++) {
                let column = columns[index];
                renderer = column.renderer;

                columnDefaults && Neo.assignDefaults(column, columnDefaults);

                if (renderer && Neo.isString(renderer) && me[renderer]) {
                    column.renderer = me[renderer]
                }

                if (sorters?.[0] && column.dataField === sorters[0].property) {
                    column.isSorted = sorters[0].direction
                }

                column.listeners = {
                    sort : me.onSortColumn,
                    scope: me
                };

                headerButtons.push(column);

                if (column.component && !column.type) {
                    column.type = 'component'
                }

                columnClass = me.constructor.columnTypes[column.type || 'column'];
                delete column.type;

                columns[index] = Neo.create(columnClass, {
                    parent  : me,
                    windowId: me.windowId,
                    ...column
                })
            }
        }

        me.headerToolbar.items = headerButtons;
        me.headerToolbar.createItems();

        if (Neo.typeOf(me._columns) === 'NeoInstance') {
            me._columns.clear();
            me._columns.add(columns);

            return me._columns
        }

        return Neo.create(_collection_Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"], {
            keyProperty: 'dataField',
            items      : columns,
            listeners  : {mutate: me.onColumnsMutate, scope: me}
        })
    }

    /**
     * @param args
     */
    destroy(...args) {
        let me = this;

        me.store = null; // remove the listeners

        me.scrollManager.destroy();

        me.mounted && Neo.main.addon.ResizeObserver.unregister({
            id      : me.id,
            windowId: me.windowId
        });

        super.destroy(...args)
    }

    /**
     * @override
     * @returns {*}
     */
    getVdomRoot() {
        return this.vdom.cn[0]
    }

    /**
     * @override
     * @returns {Neo.vdom.VNode}
     */
    getVnodeRoot() {
        return this.vnode.childNodes[0]
    }

    /**
     * @returns {String}
     */
    getWrapperId() {
        return `${this.id}__wrapper`
    }

    /**
     * @param {Object} data
     */
    onColumnsMutate(data) {
        this.updateColCount()
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me = this;

        me.scrollManager = Neo.create({
            gridBody     : me.body,
            module       : _ScrollManager_mjs__WEBPACK_IMPORTED_MODULE_4__["default"],
            gridContainer: me
        })
    }

    /**
     * @param {Object} data
     * @returns {Promise<void>}
     */
    async onResize(data) {
        let me = this;

        if (!me.initialResizeEvent) {
            await me.passSizeToBody(true);

            me.body.updateMountedAndVisibleColumns();

            await me.headerToolbar.passSizeToBody()
        } else {
            me.initialResizeEvent = false
        }
    }

    /**
     * @param {Object} data
     */
    onScrollCapture(data) {
        super.onScrollCapture(data);
        this.scrollManager.onContainerScroll(data)
    }

    /**
     * @param {Object} opts
     * @param {String} opts.direction
     * @param {String} opts.property
     * @protected
     */
    onSortColumn(opts) {
        let me = this;

        me.store.sort(opts);
        me.removeSortingCss(opts.property)
    }

    /**
     *
     */
    onStoreFilter() {
        this.updateRowCount()
    }

    /**
     * @param {Object}   data
     * @param {Object[]} data.items
     * @param {Number}   [data.total]
     * @protected
     */
    onStoreLoad(data) {
        let me         = this,
            totalCount = data.total ? data.total : this.store.count;

        me.updateRowCount(totalCount);

        if (me.store.sorters?.length < 1) {
            me.removeSortingCss()
        }
    }

    /**
     * @param {Boolean} silent=false
     * @returns {Promise<void>}
     */
    async passSizeToBody(silent=false) {
        let me            = this,
            {footerToolbar, headerToolbar} = me,
            domRects      = [me.id, headerToolbar.id],
            containerRect, footerRect, headerRect;

        if (footerToolbar) {
            domRects.push(footerToolbar.id)
        }

        [containerRect, headerRect, footerRect] = await me.getDomRect(domRects);

        // delay for slow connections, where the container-sizing is not done yet
        if (containerRect.height === headerRect.height) {
            await me.timeout(100);
            await me.passSizeToBody(silent)
        } else {
            me.body[silent ? 'setSilent' : 'set']({
                availableHeight: containerRect.height - headerRect.height - (footerRect?.height || 0),
                containerWidth : containerRect.width
            })
        }
    }

    /**
     * @param {String} dataField
     * @protected
     */
    removeSortingCss(dataField) {
        let items = this.headerToolbar?.items;
        if (items) {
            for (let i = 0, len = items.length; i < len; i++) {
                if (items[i].dataField !== dataField) {
                    items[i].removeSortingCss()
                }
            }
        }
    }

    /**
     * Used for keyboard navigation (selection models)
     * @param {Number} index
     * @param {Number} step
     */
    scrollByColumns(index, step) {
        let me           = this,
            {body}       = me,
            {columnPositions, containerWidth, mountedColumns, visibleColumns} = body,
            countColumns = columnPositions.getCount(),
            newIndex     = index + step,
            column, mounted, scrollLeft, visible;

        if (newIndex >= countColumns) {
            newIndex %= countColumns;
            step     = newIndex - index
        }

        while (newIndex < 0) {
            newIndex += countColumns;
            step     += countColumns
        }

        mounted = newIndex >= mountedColumns[0] && newIndex <= mountedColumns[1];

        // Not using >= or <=, since the first / last column might not be fully visible
        visible = newIndex > visibleColumns[0] && newIndex < visibleColumns[1];

        if (!visible) {
            // Leaving the mounted area will re-calculate the visibleColumns for us
            if (mounted) {
                visibleColumns[0] += step;
                visibleColumns[1] += step
            }

            column = columnPositions.getAt(newIndex);

            if (step < 0) {
                scrollLeft = column.x
            } else {
                scrollLeft = column.x - containerWidth + column.width
            }

            Neo.main.DomAccess.scrollTo({
                direction: 'left',
                id       : me.getVdomRoot().id,
                value    : scrollLeft,
                windowId : me.windowId
            })
        }
    }

    /**
     * Serializes the instance into a JSON-compatible object for the Neural Link.
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            body             : me.body?.toJSON(),
            cellEditing      : me.cellEditing,
            columns          : me.columns?.items.map(item => item.toJSON()),
            footerToolbar    : me.footerToolbar?.toJSON(),
            headerToolbar    : me.headerToolbar?.toJSON(),
            rowHeight        : me.rowHeight,
            scrollbar         : me.scrollbar?.toJSON(),
            scrollManager     : me.scrollManager?.toJSON(),
            showHeaderFilters : me.showHeaderFilters,
            sortable          : me.sortable,
            store             : me.store?.toJSON(),
            useTriStateSorting: me.useTriStateSorting
        }
    }

    /**
     * @param {Boolean} [silent=false]
     */
    updateColCount(silent=false) {
        let me = this;

        me.getVdomRoot()['aria-colcount'] = me.columns.count;
        !silent && me.update()
    }

    /**
     * @param {Number} [count] The total number of rows in the store. Optional, will use store.count if not provided.
     * @param {Boolean} [silent=false]
     */
    updateRowCount(count, silent=false) {
        let me         = this,
            finalCount = count ? count : me.store.count;

        me.getVdomRoot()['aria-rowcount'] = finalCount + 1;
        !silent && me.update()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(GridContainer));


/***/ },

/***/ "./src/grid/Row.mjs"
/*!**************************!*\
  !*** ./src/grid/Row.mjs ***!
  \**************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @summary Represents a single visible row in the Grid.
 *
 * `Neo.grid.Row` is a specialized component designed for the **Row Pooling** architecture.
 * It is NOT destroyed when a record scrolls off-screen. Instead, it is **recycled**:
 * its `record` and `rowIndex` configs are updated to display new data.
 *
 * **Full Pool Rendering Strategy:**
 * To ensure O(1) scrolling performance and eliminate Garbage Collection (GC) pauses, this class
 * implements a "Full Pool Rendering" strategy for cell content. It renders a stable, fixed-size
 * array of cell nodes matching `gridBody.cellPoolSize`.
 *
 * - **Active Cells:** Cells corresponding to visible columns are rendered with content.
 * - **Inactive Cells:** Slots in the pool not currently needed by a column are rendered as
 *   lightweight placeholders (`display: none`).
 *
 * This guarantees that the VDOM structure (the number and order of child nodes) *never changes*
 * during horizontal scrolling. The browser only processes efficient attribute updates (style, content),
 * with **zero** DOM node insertions, removals, or reordering operations.
 *
 * **Split Dataset Strategy:**
 * To support the Fixed-DOM-Order strategy and robust event delegation, this class renders split data attributes
 * instead of composite IDs:
 *
 * - `data-record-id`: The stable ID of the record currently bound to this row.
 * - `data-field`: The data field name of the column (for cells).
 *
 * This avoids the need for fragile string parsing (e.g. `split('__')`) in event handlers.
 *
 * Key Responsibilities:
 * -   **Cell Rendering:** Generates the VDOM for all cells in the row based on the columns config.
 * -   **Granular Updates:** When a bound record changes, only this specific Row instance updates its VDOM, avoiding a full Grid re-render.
 * -   **Component Management:** Manages the lifecycle of cell components (e.g., Sparklines, Widgets) defined in `Neo.grid.column.Component`.
 *
 * @class Neo.grid.Row
 * @extends Neo.component.Base
 * @see Neo.grid.Body
 */
class Row extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.grid.Row'
         * @protected
         */
        className: 'Neo.grid.Row',
        /**
         * @member {String} ntype='grid-row'
         * @protected
         */
        ntype: 'grid-row',
        /**
         * @member {String[]} baseCls=['neo-grid-row']
         * @protected
         */
        baseCls: ['neo-grid-row'],
        /**
         * @member {Object|null} record=null
         */
        record: null,
        /**
         * @member {Number|null} rowIndex=null
         */
        rowIndex: null,
        /**
         * @member {Number} updateDepth=-1
         */
        updateDepth: -1,
        /**
         * @member {Object} _vdom={cn: []}
         */
        _vdom:
        {cn: []}
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        if (this.components) {
            for (const key in this.components) {
                this.components[key].mounted = value
            }
        }
    }

    /**
     * Triggered after the theme config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetTheme(value, oldValue) {
        super.afterSetTheme(value, oldValue);

        if (this.components) {
            for (const key in this.components) {
                this.components[key].theme = value
            }
        }
    }

    /**
     * Generates the VDOM configuration for a single cell.
     *
     * @param {Object} data
     * @param {String} [data.cellId]
     * @param {Object} data.column
     * @param {Number} data.columnIndex
     * @param {Boolean} [data.isLastColumn] True if this is the visually last column (for border styling).
     * @param {Object} data.record
     * @param {Number} data.rowIndex
     * @param {Boolean} [data.silent]
     * @returns {Object} VDOM object for the cell
     */
    applyRendererOutput({cellId, column, columnIndex, isLastColumn, record, rowIndex, silent}) {
        let me                     = this,
            gridContainer          = me.parent.parent, // Row -> Body -> GridContainer
            gridBody               = me.parent,
            {selectedCells, store} = gridBody,
            cellCls                = ['neo-grid-cell'],
            colspan                = record[gridBody.colspanField],
            {dataField}            = column,
            recordId               = gridBody.getRecordId(record),
            logicalCellId          = gridBody.getLogicalCellId(record, dataField),
            fieldValue             = record.get(dataField),
            cellConfig, rendererOutput;

        if (fieldValue === null || fieldValue === undefined) {
            fieldValue = ''
        }

        if (column.rendererScope === 'me' || column.rendererScope === 'this') {
            column.rendererScope = column;
        }

        let rendererConfig = {
            column,
            columnIndex,
            component: me.components?.[column.dataField],
            dataField,
            gridContainer,
            record,
            row: me,
            rowIndex,
            silent,
            store,
            value: fieldValue
        };

        rendererOutput = column.renderer.call(column.rendererScope || column, rendererConfig);

        if (column.cellCls) {
            let extraCls = column.cellCls;

            if (Neo.typeOf(extraCls) === 'Function') {
                extraCls = extraCls.call(column.rendererScope || column, rendererConfig)
            }

            if (extraCls) {
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cellCls, extraCls)
            }
        }

        if (rendererOutput instanceof Neo.component.Base) {
            me.components ??= {};

            if (!me.components[column.dataField]) {
                me.components[column.dataField] = rendererOutput
            }

            rendererOutput = rendererOutput.createVdomReference()
        }

        switch (Neo.typeOf(rendererOutput)) {
            case 'Object': {
                if (rendererOutput.html || rendererOutput.text) {
                    rendererOutput.cls && cellCls.push(...rendererOutput.cls);
                } else {
                    rendererOutput = [rendererOutput];
                }
                break
            }
            case 'Date':
            case 'Number':
            case 'String': {
                rendererOutput = {
                    cls : cellCls,
                    html: rendererOutput?.toString()
                };
                break
            }
        }

        if (rendererOutput === null || rendererOutput === undefined) {
            rendererOutput = ''
        }

        if (column.cellAlign !== 'left') {
            cellCls.push('neo-' + column.cellAlign)
        }

        if (gridBody.highlightModifiedCells) {
            if (record.isModifiedField(dataField)) {
                cellCls.push('neo-is-modified')
            }
        }

        if (!cellId) {
            cellId = me.getCellId(column.dataField)
        }

        if (gridBody.selectionModel?.selectedColumns?.includes(dataField)) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cellCls, gridBody.selectionModel.selectedColumnCellCls || 'neo-selected')
        }

        if (isLastColumn) {
            cellCls.push('neo-last-column')
        }

        cellConfig = {
            'aria-colindex': columnIndex + 1, // 1 based
            data           : {field: dataField, recordId},
            id             : cellId,
            cls            : cellCls,
            role           : 'gridcell',
            style          : rendererOutput.style || {}
        };

        if (selectedCells.includes(logicalCellId)) {
            cellCls.push('neo-selected');
            cellConfig['aria-selected'] = true
        }

        if (column.width) {
            cellConfig.style.minWidth = `${column.width}px`
        }

        if (colspan && Object.keys(colspan).includes(dataField)) {
            cellConfig.colspan = colspan[dataField]
        }

        if (Neo.typeOf(rendererOutput) === 'Object') {
            if (Object.hasOwn(rendererOutput, 'html')) {
                cellConfig.html = rendererOutput.html  || ''
            } else {
                cellConfig.text = rendererOutput.text  || ''
            }
        } else {
            cellConfig.cn = rendererOutput
        }

        return cellConfig
    }

    /**
     * Generates the VDOM for the row.
     *
     * This method implements the **Full Pool Rendering** strategy.
     * It iterates through two passes:
     *
     * 1.  **Pooled Cells (O(1) Stability):**
     *     - Iterates through the currently `mountedColumns`.
     *     - Maps each column to a fixed slot in the `pooledCells` array based on `poolIndex = columnIndex % cellPoolSize`.
     *     - Fills any unused slots in the `pooledCells` array with hidden placeholders.
     *     - Appends the *entire* dense `pooledCells` array to the VDOM.
     *     - This ensures the VDOM children list length and IDs remain constant during horizontal scrolling,
     *       resulting in zero structural deltas (no `moveNode`, `insertNode`, or `removeNode`).
     *
     *     **Cell Recycling (Horizontal Scroll Optimization):**
     *     If `recycle=true`, the method attempts to reuse existing VDOM nodes for cells that are still visible
     *     but have moved to a new pool index (due to horizontal scroll).
     *     - It captures the previous VDOM children (`oldCn`) into a Map keyed by `dataField`.
     *     - If a match is found for the current column and record, the old node is reused directly.
     *     - This skips the expensive `applyRendererOutput` and `updateCellComponents` calls, ensuring O(1) performance for horizontal scrolling.
     *
     * 2.  **Permanent Cells:**
     *     - Appends cells that opt-out of pooling (e.g., complex components like Charts/Canvas).
     *     - These are always rendered to preserve their internal state (e.g. Canvas context).
     *
     * @param {Boolean} [silent=false]
     * @param {Boolean} [recycle=true] True to attempt reusing existing cell VDOMs.
     */
    createVdom(silent=false, recycle=true) {
        let me               = this,
            record           = me.record,
            rowIndex         = me.rowIndex,
            gridBody         = me.parent, // The Row is an item of Body
            gridContainer    = gridBody.parent,
            vdom             = me.vdom,
            {columns}        = gridContainer,
            cellConfig, column, columnPosition, i, isMounted, lastColumnIndex, oldCn, poolIndex, poolSize, pooledCells;

        if (!record) {
            vdom.style = {display: 'none'};
            !silent && me.update();
            return
        }

        let {mountedColumns} = gridBody,
            {selectedRows}   = gridBody,
            recordId         = gridBody.getRecordId(record),
            countColumns     = columns.getCount();

        Object.assign(vdom, {
            'aria-rowindex': rowIndex + 2, // header row => 1, first body row => 2
            data           : {recordId, rowId: rowIndex},
            role           : 'row',
            style          : {
                display  : null, // Reset display in case it was hidden
                height   : gridBody.rowHeight + 'px',
                transform: `translate3d(0px, ${rowIndex * gridBody.rowHeight}px, 0px)`
            }
        });

        // Capture previous children for recycling check
        oldCn   = vdom.cn;
        vdom.cn = [];

        let oldCellMap = null;

        if (recycle && oldCn) {
            oldCellMap = new Map();
            // Map existing cells by dataField for robust retrieval regardless of pool index changes
            for (let i = 0, len = oldCn.length; i < len; i++) {
                let node = oldCn[i];
                if (node.data?.field) {
                    oldCellMap.set(node.data.field, node)
                }
            }
        }

        let rowCls = gridBody.getRowClass(record, rowIndex);

        if (rowIndex % 2 !== 0) {
            rowCls.push('neo-even')
        }

        if (selectedRows && record[gridBody.selectedRecordField]) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(selectedRows, recordId)
        }

        if (selectedRows?.includes(recordId)) {
            rowCls.push('neo-selected');
            vdom['aria-selected'] = true;
            // Note: fire('select') should ideally be handled by the SelectionModel observing the store/records,
            // or we keep it here but suppress events during rendering if needed.
            // gridContainer.fire('select', {record})
        } else {
            delete vdom['aria-selected']
        }

        vdom.cls = rowCls;

        lastColumnIndex = gridBody.columnPositions.getCount() - 1;
        poolSize        = gridBody.cellPoolSize;
        pooledCells     = new Array(poolSize);

        // Pass 1: Render Pooled Cells (hideMode === 'removeDom')
        // We render the FULL pool to ensure stable VDOM structure (0 inserts/moves).
        for (i=mountedColumns[0]; i <= mountedColumns[1]; i++) {
            column = columns.getAt(i);

            // Sanity check for bounds (e.g. if column count changed)
            if (!column) continue;

            if (column.hideMode === 'removeDom') {
                poolIndex = i % poolSize;

                // Cell Recycling: Reuse existing VDOM if record and column match
                if (recycle && oldCellMap) {
                    let oldNode = oldCellMap.get(column.dataField);

                    if (oldNode && oldNode.data?.recordId === recordId) {
                        // We must update the ID and colindex to match the new physical slot
                        oldNode.id = `${me.id}__cell-${poolIndex}`;
                        oldNode['aria-colindex'] = i + 1;

                        // Update position
                        columnPosition = gridBody.columnPositions.get(column.dataField);
                        if (columnPosition) {
                            oldNode.style.left  = columnPosition.x + 'px';
                            oldNode.style.width = columnPosition.width + 'px';
                            // Reset visibility in case it was hidden by drag
                            if (!columnPosition.hidden) {
                                oldNode.style.visibility = null
                            }
                        }

                        pooledCells[poolIndex] = oldNode;
                        continue
                    }
                }

                cellConfig = me.applyRendererOutput({
                    cellId      : `${me.id}__cell-${poolIndex}`,
                    column,
                    columnIndex : i,
                    isLastColumn: i === lastColumnIndex,
                    record,
                    rowIndex,
                    silent
                });

                if (column.dock) {
                    cellConfig.cls = ['neo-locked', ...cellConfig.cls || []]
                }

                columnPosition = gridBody.columnPositions.get(column.dataField);

                if (!columnPosition) {
                    continue
                }

                cellConfig.style = {
                    ...cellConfig.style,
                    left : columnPosition.x     + 'px',
                    width: columnPosition.width + 'px'
                };

                // Happens during a column header drag OP, when leaving the painted range
                if (columnPosition.hidden) {
                    cellConfig.style.visibility = 'hidden'
                }

                pooledCells[poolIndex] = cellConfig
            }
        }

        // Fill gaps with placeholders to maintain O(1) stability
        for (i = 0; i < poolSize; i++) {
            if (!pooledCells[i]) {
                pooledCells[i] = {
                    id   : `${me.id}__cell-${i}`,
                    style: {display: 'none'}
                }
            }
        }

        vdom.cn.push(...pooledCells);

        // Pass 2: Render Permanent Cells (hideMode !== 'removeDom')
        // We MUST render these even if they are off-screen to preserve their DOM state (e.g. Canvas context).
        // This loop is O(TotalColumns), but typically few columns use this mode.
        for (i=0; i < countColumns; i++) {
            column = columns.getAt(i);

            if (column.hideMode !== 'removeDom') {
                isMounted = i >= mountedColumns[0] && i <= mountedColumns[1];

                cellConfig = me.applyRendererOutput({
                    cellId      : `${me.id}__${column.dataField}`,
                    column,
                    columnIndex : i,
                    isLastColumn: i === lastColumnIndex,
                    record,
                    rowIndex,
                    silent
                });

                if (column.dock) {
                    cellConfig.cls = ['neo-locked', ...cellConfig.cls || []]
                }

                columnPosition = gridBody.columnPositions.get(column.dataField);

                if (!columnPosition) {
                    continue
                }

                cellConfig.style = {
                    ...cellConfig.style,
                    left : columnPosition.x     + 'px',
                    width: columnPosition.width + 'px'
                };

                // Visibility Logic
                if (isMounted) {
                    if (columnPosition.hidden) {
                        cellConfig.style.visibility = 'hidden'
                    }
                } else {
                    if (column.hideMode === 'visibility') {
                        cellConfig.style.visibility = 'hidden'
                    } else if (column.hideMode === 'display') {
                        cellConfig.style.display = 'none'
                    }
                }

                vdom.cn.push(cellConfig)
            }
        }

        !silent && me.update()
    }

    /**
     *
     */
    destroy() {
        let me = this;

        if (me.components) {
            for (const key in me.components) {
                me.components[key].destroy()
            }
        }

        super.destroy()
    }

    /**
     * @param {String} dataField
     * @returns {String}
     */
    getCellId(dataField) {
        return `${this.id}__${dataField}`
    }

    /**
     * Updates components inside the row matching a specific identifier (ntype, className or Class)
     * @param {String|Neo.core.Base} identifier
     * @param {Object} config
     */
    updateCellComponents(identifier, config) {
        let me = this,
            isString, proto;

        if (me.components) {
            isString = Neo.isString(identifier);

            if (!isString) {
                proto      = identifier.prototype;
                identifier = proto.ntype || proto.className
            }

            for (const key in me.components) {
                let component = me.components[key];
                if (isString ? (component.ntype === identifier || component.className === identifier) : (component instanceof identifier)) {
                    component.set(config)
                }
            }
        }
    }

    /**
     * Updates the content of this Row instance to display a new record.
     *
     * This is the core method of the Row Pooling architecture. It is called by `Neo.grid.Body`
     * during scrolling or rendering. It updates the internal state (`record`, `rowIndex`)
     * and triggers a VDOM update to reflect the new data.
     *
     * @param {Object} data
     * @param {Boolean} [data.force=false] True to force a VDOM update even if record and rowIndex are unchanged.
     * @param {Object} data.record The new record to display.
     * @param {Boolean} [data.recycle=true] True to attempt reusing existing cell VDOMs (performance optimization).
     * @param {Number} data.rowIndex The new row index.
     * @param {Boolean} [data.silent=false] True to prevent an immediate VDOM update (useful for batching).
     */
    updateContent({force=false, record, recycle=true, rowIndex, silent=false}) {
        let me = this;

        // Optimization: Skip VDOM generation if the state hasn't changed.
        // This prevents thousands of redundant updates during simple scrolling.
        if (!force && me.record === record && me.rowIndex === rowIndex) {
            return
        }

        me.record   = record;
        me.rowIndex = rowIndex;

        me.createVdom(silent, recycle)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Row));


/***/ },

/***/ "./src/grid/ScrollManager.mjs"
/*!************************************!*\
  !*** ./src/grid/ScrollManager.mjs ***!
  \************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.grid.ScrollManager
 * @extends Neo.core.Base
 */
class ScrollManager extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @member {Object} delayable
     * @protected
     * @static
     */
    static delayable = {
        onBodyScrollEnd: {type: 'buffer',   timer: 150},
        syncGridBody   : {type: 'throttle', timer:  16}
    }

    static config = {
        /**
         * @member {String} className='Neo.grid.ScrollManager'
         * @protected
         */
        className: 'Neo.grid.ScrollManager',
        /**
         * @member {Boolean} dragScroll_=true
         * @reactive
         */
        dragScroll_: true,
        /**
         * @member {Boolean} mounted_=false
         * @protected
         * @reactive
         */
        mounted_: false,
        /**
         * @member {Number} scrollLeft_=0
         * @protected
         * @reactive
         */
        scrollLeft_: 0,
        /**
         * @member {Number} scrollTop_=0
         * @protected
         * @reactive
         */
        scrollTop_: 0
    }

    /**
     * @member {Neo.grid.Body|null} gridBody=null
     * @protected
     */
    gridBody = null
    /**
     * @member {Neo.grid.Container|null} gridContainer=null
     * @protected
     */
    gridContainer = null

    /**
     * @param {Boolean} value
     * @param {Boolean} oldValue
     */
    afterSetDragScroll(value, oldValue) {
        let cls = 'neo-mouse-drag-scroll';

        if (value) {
            this.gridBody.addCls(cls)
        } else if (oldValue) {
            this.gridBody.removeCls(cls)
        }

        if (this.mounted) {
            this.updateDragScrollAddon(value)
        }
    }

    /**
     * @param {Boolean} value
     * @param {Boolean} oldValue
     */
    afterSetMounted(value, oldValue) {
        if (value) {
            this.dragScroll && this.updateDragScrollAddon(true)
        } else if (oldValue) {
            this.updateDragScrollAddon(false)
        }
    }

    /**
     * Only triggers for vertical scrolling
     * @param {Object} data
     * @protected
     */
    onBodyScroll({scrollTop}) {
        let me = this;

        me.scrollTop           = scrollTop;
        me.gridBody.isScrolling = true;

        me.onBodyScrollEnd();
        me.syncGridBody()
    }

    /**
     * @protected
     */
    onBodyScrollEnd() {
        this.gridBody.isScrolling = false
    }

    /**
     * @param {Object} data
     * @param {Number} data.scrollLeft
     * @param {Object} data.target
     */
    onContainerScroll({scrollLeft, target}) {
        let me = this;

        // We must ignore events for grid-scrollbar
        if (target.id.includes('grid-container')) {
            me.scrollLeft          = scrollLeft;
            me.gridBody.isScrolling = true;

            me.onBodyScrollEnd();
            me.syncGridBody()
        }
    }

    /**
     * @protected
     */
    syncGridBody() {
        let me   = this,
            body = me.gridBody;

        body.skipCreateViewData = true;

        body.set({
            scrollLeft: me.scrollLeft,
            scrollTop : me.scrollTop
        });

        body.skipCreateViewData = false;
        body.createViewData();

        me.gridContainer.headerToolbar.scrollLeft = me.scrollLeft
    }

    /**
     * @param {Boolean} active
     * @returns {Promise<void>}
     */
    async updateDragScrollAddon(active) {
        let me    = this,
            addon = await Neo.currentWorker.getAddon('GridDragScroll', me.windowId);

        if (active) {
            addon.register({
                bodyId     : me.gridBody.id + '__wrapper',
                containerId: me.gridContainer.id,
                id         : me.id
            })
        } else {
            addon.unregister({id: me.id})
        }
    }

    /**
     * @returns {Object}
     */
    toJSON() {
        return {
            ...super.toJSON(),
            scrollLeft: this.scrollLeft,
            scrollTop : this.scrollTop
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(ScrollManager));


/***/ },

/***/ "./src/grid/VerticalScrollbar.mjs"
/*!****************************************!*\
  !*** ./src/grid/VerticalScrollbar.mjs ***!
  \****************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");


/**
 * We do not want to use the default scrollbar for vertical scrolling, since it would show up at the right edge
 * of the last column. Instead, we want to show it at the right edge of the container (always visible when scrolling).
 * @class Neo.grid.VerticalScrollbar
 * @extends Neo.component.Base
 */
class VerticalScrollbar extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.grid.VerticalScrollbar'
         * @protected
         */
        className: 'Neo.grid.VerticalScrollbar',
        /**
         * @member {String} ntype='grid-vertical-scrollbar'
         * @protected
         */
        ntype: 'grid-vertical-scrollbar',
        /**
         * @member {String[]} baseCls=['neo-grid-vertical-scrollbar']
         * @protected
         */
        baseCls: ['neo-grid-vertical-scrollbar'],
        /**
         * Number in px
         * @member {Number} rowHeight_=0
         * @reactive
         */
        rowHeight_: 0,
        /**
         * @member {Neo.data.Store|null} store_=null
         * @reactive
         */
        store_: null,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {cn: [
            {cls: ['neo-grid-scrollbar-content']}
        ]}
    }

    /**
     * @param {Boolean} mounted
     * @protected
     */
    async addScrollSync(mounted) {
        let me         = this,
            {windowId} = me,
            ScrollSync = await Neo.currentWorker.getAddon('ScrollSync', windowId),
            params     = {id: me.id, windowId};

        if (mounted) {
            ScrollSync.register({
                fromId: me.parent.body.vdom.id,
                toId  : me.id,
                twoWay: Neo.config.hasMouseEvents, // Syncing the scroller back to the body affects mobile scrolling
                ...params
            })
        } else {
            ScrollSync.unregister(params)
        }
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);
        oldValue !== undefined && this.addScrollSync(value)
    }

    /**
     * Triggered after the rowHeight config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetRowHeight(value, oldValue) {
        value > 0 && this.updateScrollHeight()
    }

    /**
     * Triggered after the store config got changed
     * @param {Neo.data.Store|null} value
     * @param {Neo.data.Store|null} oldValue
     * @protected
     */
    afterSetStore(value, oldValue) {
        if (value) {
            let me = this;

            value.on({
                filter: me.updateScrollHeight,
                load  : me.updateScrollHeight,
                scope : me
            })
        }
    }

    /**
     * @param {Object}   data
     * @param {Object[]} data.items
     * @param {Number}   [data.total]
     * @protected
     */
    updateScrollHeight(data) {
        let me           = this,
            countRecords = data?.total ? data.total : me.store.count,
            {rowHeight}  = me;

        if (countRecords > 0 && rowHeight > 0) {
            me.vdom.cn[0].height = `${(countRecords + 1) * rowHeight}px`;
            me.update()
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(VerticalScrollbar));


/***/ },

/***/ "./src/grid/column/AnimatedChange.mjs"
/*!********************************************!*\
  !*** ./src/grid/column/AnimatedChange.mjs ***!
  \********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/grid/column/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");




/**
 * @class Neo.grid.column.AnimatedChange
 * @extends Neo.grid.column.Base
 */
class AnimatedChange extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.grid.column.AnimatedChange'
         * @protected
         */
        className: 'Neo.grid.column.AnimatedChange',
        /**
         * @member {String} animationCls='neo-animated'
         */
        animationCls: 'neo-animated',
        /**
         * @member {String} type='animatedChange'
         * @protected
         */
        type: 'animatedChange'
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.parent.store.on({
            recordChange: me.onRecordChange,
            scope       : me
        })
    }

    /**
     * Override as needed for dynamic record-based animation classes
     * @param {Record} record
     * @returns {String}
     */
    getAnimationCls(record) {
        return this.animationCls
    }

    /**
     * @param {Object}         data
     * @param {Object[]}       data.fields Each field object contains the keys: name, oldValue, value
     * @param {Neo.data.Model} data.model The model instance of the changed record
     * @param {Object}         data.record
     */
    async onRecordChange({fields, record}) {
        let me = this,
            field;

        for (field of fields) {
            if (field.name === me.dataField) {
                // Wait for the next animation frame
                await me.timeout(20);

                let {body} = me.parent,
                    row    = body.getRow(record),
                    cellId, node;

                if (row) {
                    cellId = body.getCellId(row.rowIndex, me.dataField);
                    node   = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].find(row.vdom, cellId)?.vdom;

                    if (node) {
                        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(node.cls, me.getAnimationCls(record));

                        // This will trigger a 2nd row update, after grid.Body: onStoreRecordChange()
                        // It is crucial to restart the keyframe based animation
                        // => The previous update call will remove the last animationCls
                        row.update()
                    }
                }

                break
            }
        }
    }

    /**
     * Serializes the instance into a JSON-compatible object for the Neural Link.
     * @returns {Object}
     */
    toJSON() {
        return {
            ...super.toJSON(),
            animationCls: this.animationCls
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(AnimatedChange));


/***/ },

/***/ "./src/grid/column/AnimatedCurrency.mjs"
/*!**********************************************!*\
  !*** ./src/grid/column/AnimatedCurrency.mjs ***!
  \**********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _AnimatedChange_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AnimatedChange.mjs */ "./src/grid/column/AnimatedChange.mjs");


/**
 * @class Neo.grid.column.AnimatedCurrency
 * @extends Neo.grid.column.AnimatedChange
 */
class AnimatedCurrency extends _AnimatedChange_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.grid.column.AnimatedCurrency'
         * @protected
         */
        className: 'Neo.grid.column.AnimatedCurrency',
        /**
         * @member {String} type='animatedCurrency'
         * @protected
         */
        type: 'animatedCurrency',
        /**
         * Set a different record field to base the change on.
         * Defaults this.dataField
         * @member {String|null} compareField=null
         */
        compareField: null,
        /**
         * @member {String} currency='USD'
         */
        currency: 'USD',
        /**
         * @member {String} locale='default'
         */
        locale: 'default'
    }

    /**
     * @member {Intl.NumberFormat|null} formatter=null
     */
    formatter = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);
        this.createFormatter()
    }

    /**
     * @param {Object}             data
     * @param {Neo.button.Base}    data.column
     * @param {Number}             data.columnIndex
     * @param {String}             data.dataField
     * @param {Neo.grid.Container} data.gridContainer
     * @param {Object}             data.record
     * @param {Number}             data.rowIndex
     * @param {Neo.data.Store}     data.store
     * @param {Number|String}      data.value
     * @returns {*}
     */
    cellRenderer({column, value}) {
        if (value === null || value === undefined) {
            return ''
        }

        return column.formatter.format(value)
    }

    /**
     *
     */
    createFormatter() {
        let me = this;

        me.formatter = new Intl.NumberFormat(me.locale, {style: 'currency', currency: me.currency})
    }

    /**
     * Override as needed for dynamic record-based animation classes
     * @param {Record} record
     * @returns {String}
     */
    getAnimationCls(record) {
        return record[this.compareField || this.dataField] < 0 ? 'neo-animated-negative' : 'neo-animated-positive'
    }

    /**
     * Serializes the instance into a JSON-compatible object for the Neural Link.
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            compareField: me.compareField,
            currency    : me.currency,
            locale      : me.locale
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(AnimatedCurrency));


/***/ },

/***/ "./src/grid/column/Base.mjs"
/*!**********************************!*\
  !*** ./src/grid/column/Base.mjs ***!
  \**********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Function.mjs */ "./src/util/Function.mjs");



/**
 * @class Neo.grid.column.Base
 * @extends Neo.core.Base
 */
class Column extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for hideMode
     * @member {String[]} hideModes=['display','removeDom','visibility']
     * @protected
     * @static
     */
    static hideModes = ['display', 'removeDom', 'visibility']

    static config = {
        /**
         * @member {String} className='Neo.grid.column.Base'
         * @protected
         */
        className: 'Neo.grid.column.Base',
        /**
         * Additional CSS classes to add to the cell.
         * These classes are appended to the default ones (e.g. 'neo-grid-cell').
         * @member {Function|String|String[]|null} cellCls=null
         */
        cellCls: null,
        /**
         * The field name of the data.Model to read the value from.
         * Must be unique within the grid instance.
         *
         * **Runtime Updates:**
         * You can change this config at runtime to point the column to a different model field.
         * The Grid will automatically:
         * 1. Update the internal `columnPositions` map (preserving sort order).
         * 2. Refresh the visible rows to display the new data.
         *
         * @member {String|null} dataField_=null
         * @reactive
         */
        dataField_: null,
        /**
         * @member {String} hideMode_='removeDom'
         */
        hideMode_: 'removeDom',
        /**
         * @member {Neo.grid.Container|null} parent=null
         */
        parent: null,
        /**
         * @member {Function|String|null} renderer_='cellRenderer'
         * @reactive
         */
        renderer_: 'cellRenderer',
        /**
         * Scope to execute the column renderer.
         * Defaults to the grid.Body.
         * You can pass the strings 'this' or 'me'
         * @member {Neo.core.Base|String|null} rendererScope=null
         */
        rendererScope: null,
        /**
         * @member {String} type='column'
         * @protected
         */
        type: 'column',
        /**
         * @member {Number|null} windowId_=null
         * @reactive
         */
        windowId_: null
    }

    /**
     * Triggered after the dataField config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     */
    afterSetDataField(value, oldValue) {
        if (oldValue !== undefined) {
            let me            = this,
                gridContainer = me.parent,
                body          = gridContainer?.body,
                headerToolbar = gridContainer?.headerToolbar,
                colPositions  = body?.columnPositions,
                button        = headerToolbar?.getColumn(oldValue),
                pos           = colPositions?.get(oldValue);

            if (pos) {
                // The columnPositions collection is keyed by 'dataField'.
                // To update the key in the internal Map, we must remove the item (using the old key),
                // update the property, and re-add it (indexing with the new key).
                // Modifying it in-place would break the Map index.
                colPositions.map.delete(oldValue);
                pos.dataField = value;
                colPositions.map.set(value, pos)
            }

            if (button) {
                button.dataField = value
            }
        }
    }

    /**
     * Triggered after the windowId config got changed.
     *
     * **Non-Component Theme Injection**
     * Although `Neo.grid.column.Base` and its subclasses are not components (they extend `core.Base`),
     * they hook into the theme engine exactly like components do.
     *
     * This is a powerful architectural pattern. It allows specific column implementations
     * (like `Neo.grid.column.Icon` or `Neo.grid.column.Component`) to inject their own SCSS
     * theme files (e.g., `resources/scss/theme-neo-dark/grid/column/IconLink.scss`).
     *
     * **Best Practice:**
     * Because columns do not render their own outer DOM nodes with unique CSS classes,
     * any CSS rules defined in these injected files MUST be scoped inside `.neo-grid-cell`
     * to prevent unintended side effects on standalone components elsewhere in the application.
     *
     * @param {Number} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        value && Neo.currentWorker.insertThemeFiles(value, this.__proto__)
    }

    /**
     * Triggered before the hideMode config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetHideMode(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'hideMode')
    }

    /**
     * Triggered before the renderer config gets changed
     * @param {Function|String|null} value
     * @param {Function|String|null} oldValue
     * @protected
     */
    beforeSetRenderer(value, oldValue) {
        // If no fn is found inside the parent tree, return the plain value for view controllers to match
        return (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveCallback)(value, this).fn || value
    }

    /**
     * @param {Object}             data
     * @param {Neo.button.Base}    data.column
     * @param {Number}             data.columnIndex
     * @param {String}             data.dataField
     * @param {Neo.grid.Container} data.gridContainer
     * @param {Object}             data.record
     * @param {Number}             data.rowIndex
     * @param {Neo.data.Store}     data.store
     * @param {Number|String}      data.value
     * @returns {*}
     */
    cellRenderer({value}) {
        return value
    }

    /**
     * Serializes the instance into a JSON-compatible object for the Neural Link.
     * @returns {Object}
     */
    toJSON() {
        let me  = this,
            out = super.toJSON();

        out.dataField = me.dataField;
        out.type      = me.type;

        if (Neo.isString(me.renderer)) {
            out.renderer = me.renderer
        }

        return out
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Column));


/***/ },

/***/ "./src/grid/column/Component.mjs"
/*!***************************************!*\
  !*** ./src/grid/column/Component.mjs ***!
  \***************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Base.mjs */ "./src/grid/column/Base.mjs");



/**
 * @class Neo.grid.column.Component
 * @extends Neo.grid.column.Base
 */
class Component extends _Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.grid.column.Component'
         * @protected
         */
        className: 'Neo.grid.column.Component',
        /**
         * @member {Function|Object|null} component=null
         */
        component: null,
        /**
         * @member {Object} defaults_
         * @protected
         * @reactive
         */
        defaults_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_0__.isDescriptor]: true,
            merge         : 'deep',
            value         : null
        },
        /**
         * @member {String} hideMode='visibility'
         */
        hideMode: 'visibility',
        /**
         * Components can delegate event listeners (or button handlers) into methods somewhere inside
         * the view controller or component tree hierarchy.
         *
         * In this case, it is helpful to know what the related record is, so we are adding the record
         * to the component as a property. By default, as 'record', but this config can change the property name.
         * @member {String} recordProperty='record'
         */
        recordProperty: 'record',
        /**
         * @member {String} rendererScope='this'
         * @protected
         */
        rendererScope: 'this',
        /**
         * @member {String} type='component'
         * @protected
         */
        type: 'component',
        /**
         * Set this config to true, in case you want to use 'bind' inside your cell based component.
         *
         * **Performance Warning (Static Bindings Only):**
         * Because grid cells are pooled and recycled during scrolling, `StateProvider` bindings are evaluated
         * exactly **once** when the component is first instantiated.
         *
         * Your `bind` functions must **never** rely on dynamically iterating `record` data from the `cellRenderer` scope.
         * Bindings are strictly for global or hierarchical UI state (e.g. `animateVisuals`).
         * For record-specific data, pass the values directly within the component config object, which is updated on every recycle.
         *
         * @member {Boolean} useBindings=false
         */
        useBindings: false
    }

    /**
     * Override as needed inside class extensions
     * @param {Object} config
     * @param {Record} record
     * @returns {Object}
     */
    applyRecordConfigs(config, record) {
        return config
    }

    /**
     * @param {Object}             data
     * @param {Neo.column.Base}    data.column
     * @param {Number}             data.columnIndex
     * @param {Neo.component.Base} [data.component]
     * @param {String}             data.dataField
     * @param {Neo.grid.Container} data.gridContainer
     * @param {Object}             data.record
     * @param {Neo.grid.Row}       data.row
     * @param {Number}             data.rowIndex
     * @param {Neo.data.Store}     data.store
     * @param {Number|String}      data.value
     * @returns {*}
     */
    cellRenderer(data) {
        let {component, gridContainer, record, row, silent} = data,
            {appName, windowId} = gridContainer,
            me               = this,
            {recordProperty} = me,
            componentConfig  = me.component;

        /**
         * Optimization: If the record instance AND its version haven't changed, we can short-circuit.
         * This skips:
         * 1. Executing the 'component' config function (if it is one).
         * 2. Calling component.set() which triggers the config system overhead.
         * 3. Unnecessary VDOM updates.
         */
        if (component && component[recordProperty] === record && component.lastRecordVersion === record.version) {
            return component
        }

        if (Neo.typeOf(componentConfig) === 'Function') {
            componentConfig = componentConfig(data)
        }

        componentConfig = me.applyRecordConfigs(componentConfig, record);
        componentConfig = {...componentConfig};

        if (component) {
            component.lastRecordVersion = record.version;

            delete componentConfig.className;
            delete componentConfig.module;
            delete componentConfig.ntype;

            componentConfig[recordProperty] = record;

            if (componentConfig.hideMode === undefined) {
                componentConfig.hideMode = me.hideMode
            }

            // **Prevent Stale State in Pooled Cells**
            // During grid scrolling (Row Pooling), existing cell components are recycled for new records.
            // If a new record is missing a data field, `record[dataField]` returns `undefined`.
            // The Neo.mjs config system's `set()` method ignores `undefined` values, meaning the
            // component would retain the old record's state, causing visual bugs (e.g., showing a
            // GitHub org from the previous row on a user who has no orgs).
            // Converting `undefined` to `null` forces the change detection to explicitly clear the state.
            for (const key in componentConfig) {
                if (componentConfig[key] === undefined) {
                    componentConfig[key] = null
                }
            }

            // Enforce static bindings on pooled components to prevent OOM leaks
            // Bindings belong to the global UI state, not iterating record state.
            delete componentConfig.bind;

            component.set(componentConfig, silent)
        } else {
            component = Neo.create({
                hideMode: me.hideMode,
                ...me.defaults,
                ...componentConfig,
                appName,
                parentComponent  : row,
                [recordProperty] : record,
                lastRecordVersion: record.version,
                theme            : row.theme,
                windowId
            });

            // Only create bindings ONCE upon component instantiation
            if (me.useBindings) {
                gridContainer.body.getStateProvider()?.createBindings(component)
            }
        }

        return component
    }

    /**
     * Serializes the instance into a JSON-compatible object for the Neural Link.
     * @returns {Object}
     */
    toJSON() {
        let me  = this,
            out = super.toJSON();

        out.recordProperty = me.recordProperty;
        out.useBindings    = me.useBindings;

        if (Neo.isObject(me.component)) {
            out.component = me.serializeConfig(me.component)
        }

        if (Neo.isObject(me.defaults)) {
            out.defaults = me.serializeConfig(me.defaults)
        }

        return out
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Component));


/***/ },

/***/ "./src/grid/column/CountryFlag.mjs"
/*!*****************************************!*\
  !*** ./src/grid/column/CountryFlag.mjs ***!
  \*****************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Component.mjs */ "./src/grid/column/Component.mjs");
/* harmony import */ var _component_CountryFlag_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../component/CountryFlag.mjs */ "./src/component/CountryFlag.mjs");



/**
 * @class Neo.grid.column.CountryFlag
 * @extends Neo.grid.column.Component
 */
class CountryFlag extends _Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.grid.column.CountryFlag'
         * @protected
         */
        className: 'Neo.grid.column.CountryFlag',
        /**
         * @member {String} contentField='location'
         */
        contentField: 'location',
        /**
         * @member {Object} defaults
         * @protected
         */
        defaults: {
            module: _component_CountryFlag_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]
        },
        /**
         * @member {String} type='countryFlag'
         * @protected
         */
        type: 'countryFlag'
    }

    /**
     * @param {Object} config
     * @param {Record} record
     * @returns {Object}
     */
    applyRecordConfigs(config, record) {
        return {
            countryCode: record[this.dataField],
            location   : record[this.contentField],
            ...config
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(CountryFlag));


/***/ },

/***/ "./src/grid/column/Currency.mjs"
/*!**************************************!*\
  !*** ./src/grid/column/Currency.mjs ***!
  \**************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/grid/column/Base.mjs");


/**
 * @class Neo.grid.column.Currency
 * @extends Neo.grid.column.Base
 */
class Currency extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.grid.column.Currency'
         * @protected
         */
        className: 'Neo.grid.column.Currency',
        /**
         * @member {String} type='currency'
         * @protected
         */
        type: 'currency',
        /**
         * @member {String} currency='USD'
         */
        currency: 'USD',
        /**
         * @member {String} locale='default'
         */
        locale: 'default'
    }

    /**
     * @member {Intl.NumberFormat|null} formatter=null
     */
    formatter = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);
        this.createFormatter()
    }

    /**
     * @param {Object}             data
     * @param {Neo.button.Base}    data.column
     * @param {Number}             data.columnIndex
     * @param {String}             data.dataField
     * @param {Neo.grid.Container} data.gridContainer
     * @param {Object}             data.record
     * @param {Number}             data.rowIndex
     * @param {Neo.data.Store}     data.store
     * @param {Number|String}      data.value
     * @returns {*}
     */
    cellRenderer({value}) {
        if (value === null || value === undefined) {
            return ''
        }

        return this.formatter.format(value)
    }

    /**
     *
     */
    createFormatter() {
        let me = this;

        me.formatter = new Intl.NumberFormat(me.locale, {style: 'currency', currency: me.currency})
    }

    /**
     * Serializes the instance into a JSON-compatible object for the Neural Link.
     * @returns {Object}
     */
    toJSON() {
        return {
            ...super.toJSON(),
            currency: this.currency,
            locale  : this.locale
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Currency));


/***/ },

/***/ "./src/grid/column/GitHubOrgs.mjs"
/*!****************************************!*\
  !*** ./src/grid/column/GitHubOrgs.mjs ***!
  \****************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Component.mjs */ "./src/grid/column/Component.mjs");
/* harmony import */ var _component_GitHubOrgs_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../component/GitHubOrgs.mjs */ "./src/component/GitHubOrgs.mjs");



/**
 * @class Neo.grid.column.GitHubOrgs
 * @extends Neo.grid.column.Component
 */
class GitHubOrgs extends _Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.grid.column.GitHubOrgs'
         * @protected
         */
        className: 'Neo.grid.column.GitHubOrgs',
        /**
         * @member {Object} defaults
         * @protected
         */
        defaults: {
            module        : _component_GitHubOrgs_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            renderFullPool: true
        },
        /**
         * @member {String} type='githubOrgs'
         * @protected
         */
        type: 'githubOrgs'
    }

    /**
     * @param {Object} config
     * @param {Record} record
     * @returns {Object}
     */
    applyRecordConfigs(config, record) {
        return {
            orgs: record.organizations,
            ...config
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(GitHubOrgs));


/***/ },

/***/ "./src/grid/column/GitHubUser.mjs"
/*!****************************************!*\
  !*** ./src/grid/column/GitHubUser.mjs ***!
  \****************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Component.mjs */ "./src/grid/column/Component.mjs");
/* harmony import */ var _component_GitHubUser_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../component/GitHubUser.mjs */ "./src/component/GitHubUser.mjs");



/**
 * @class Neo.grid.column.GitHubUser
 * @extends Neo.grid.column.Component
 */
class GitHubUser extends _Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.grid.column.GitHubUser'
         * @protected
         */
        className: 'Neo.grid.column.GitHubUser',
        /**
         * @member {Object} defaults
         * @protected
         */
        defaults: {
            module: _component_GitHubUser_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]
        },
        /**
         * @member {String} type='githubUser'
         * @protected
         */
        type: 'githubUser'
    }

    /**
     * @param {Object} config
     * @param {Record} record
     * @returns {Object}
     */
    applyRecordConfigs(config, record) {
        return {
            avatarUrl: record.avatarUrl,
            fullName : record.name && record.name !== record.login ? record.name : '',
            username : record.login,
            ...config
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(GitHubUser));


/***/ },

/***/ "./src/grid/column/Icon.mjs"
/*!**********************************!*\
  !*** ./src/grid/column/Icon.mjs ***!
  \**********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Component.mjs */ "./src/grid/column/Component.mjs");
/* harmony import */ var _component_Icon_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../component/Icon.mjs */ "./src/component/Icon.mjs");



/**
 * @class Neo.grid.column.Icon
 * @extends Neo.grid.column.Component
 */
class Icon extends _Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.grid.column.Icon'
         * @protected
         */
        className: 'Neo.grid.column.Icon',
        /**
         * @member {Object} defaults
         * @protected
         */
        defaults: {
            module: _component_Icon_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]
        },
        /**
         * @member {String|null} cellIconCls=null
         */
        cellIconCls: null,
        /**
         * @member {String} type='icon'
         * @protected
         */
        type: 'icon'
    }

    /**
     * @param {Object} config
     * @param {Record} record
     * @returns {Object}
     */
    applyRecordConfigs(config, record) {
        let me          = this,
            value       = record[me.dataField],
            cellIconCls = me.cellIconCls;

        if (cellIconCls) {
            return {
                cellIconCls,
                hidden: !value,
                ...config
            }
        }

        return {
            cellIconCls: value,
            hidden     : !value,
            ...config
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Icon));


/***/ },

/***/ "./src/grid/column/IconLink.mjs"
/*!**************************************!*\
  !*** ./src/grid/column/IconLink.mjs ***!
  \**************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Component.mjs */ "./src/grid/column/Component.mjs");
/* harmony import */ var _component_IconLink_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../component/IconLink.mjs */ "./src/component/IconLink.mjs");



/**
 * @class Neo.grid.column.IconLink
 * @extends Neo.grid.column.Component
 */
class IconLink extends _Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.grid.column.IconLink'
         * @protected
         */
        className: 'Neo.grid.column.IconLink',
        /**
         * @member {Object} defaults
         * @protected
         */
        defaults: {
            module: _component_IconLink_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]
        },
        /**
         * @member {String|null} cellIconCls=null
         */
        cellIconCls: null,
        /**
         * @member {String|null} labelField=null
         */
        labelField: null,
        /**
         * @member {Function|null} labelFormatter=null
         */
        labelFormatter: null,
        /**
         * @member {String} type='iconLink'
         * @protected
         */
        type: 'iconLink',
        /**
         * @member {Function|null} urlFormatter=null
         */
        urlFormatter: null
    }

    /**
     * @param {Object} config
     * @param {Record} record
     * @returns {Object}
     */
    applyRecordConfigs(config, record) {
        let me        = this,
            dataValue = record[me.dataField],
            url       = dataValue,
            label     = me.labelField ? record[me.labelField] : null;

        if (me.urlFormatter) {
            url = me.urlFormatter(dataValue, record)
        }

        if (me.labelFormatter) {
            label = me.labelFormatter(me.labelField ? label : dataValue, record)
        }

        return {
            cellIconCls: me.cellIconCls,
            label,
            url,
            ...config
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(IconLink));


/***/ },

/***/ "./src/grid/column/Index.mjs"
/*!***********************************!*\
  !*** ./src/grid/column/Index.mjs ***!
  \***********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/grid/column/Base.mjs");


/**
 * @class Neo.grid.column.Index
 * @extends Neo.grid.column.Base
 */
class Index extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.grid.column.Index'
         * @protected
         */
        className: 'Neo.grid.column.Index',
        /**
         * @member {String} type='index'
         * @protected
         */
        type: 'index',
        /**
         * @member {Boolean} zeroBased=false
         */
        zeroBased: false
    }

    /**
     * @param {Object}             data
     * @param {Neo.button.Base}    data.column
     * @param {Number}             data.columnIndex
     * @param {String}             data.dataField
     * @param {Neo.grid.Container} data.gridContainer
     * @param {Object}             data.record
     * @param {Number}             data.rowIndex
     * @param {Neo.data.Store}     data.store
     * @param {Number|String}      data.value
     * @returns {*}
     */
    cellRenderer({rowIndex}) {
        return rowIndex + (this.zeroBased ? 0 : 1)
    }

    /**
     * Serializes the instance into a JSON-compatible object for the Neural Link.
     * @returns {Object}
     */
    toJSON() {
        return {
            ...super.toJSON(),
            zeroBased: this.zeroBased
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Index));


/***/ },

/***/ "./src/grid/column/LinkedIn.mjs"
/*!**************************************!*\
  !*** ./src/grid/column/LinkedIn.mjs ***!
  \**************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Component.mjs */ "./src/grid/column/Component.mjs");
/* harmony import */ var _component_IconLink_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../component/IconLink.mjs */ "./src/component/IconLink.mjs");



/**
 * @class Neo.grid.column.LinkedIn
 * @extends Neo.grid.column.Component
 */
class LinkedIn extends _Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.grid.column.LinkedIn'
         * @protected
         */
        className: 'Neo.grid.column.LinkedIn',
        /**
         * @member {Object} defaults
         * @protected
         */
        defaults: {
            module: _component_IconLink_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]
        },
        /**
         * @member {String|null} cellIconCls='fa-brands fa-linkedin'
         */
        cellIconCls: 'fa-brands fa-linkedin',
        /**
         * @member {String} type='linkedin'
         * @protected
         */
        type: 'linkedin'
    }

    /**
     * @param {Object} config
     * @param {Record} record
     * @returns {Object}
     */
    applyRecordConfigs(config, record) {
        let me  = this,
            url = record[me.dataField];

        if (url && !url.startsWith('http')) {
            url = `https://www.linkedin.com/in/${url}/`
        }

        return {
            cellIconCls: me.cellIconCls,
            url,
            ...config
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(LinkedIn));


/***/ },

/***/ "./src/grid/column/Progress.mjs"
/*!**************************************!*\
  !*** ./src/grid/column/Progress.mjs ***!
  \**************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Component.mjs */ "./src/grid/column/Component.mjs");
/* harmony import */ var _component_Progress_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../component/Progress.mjs */ "./src/component/Progress.mjs");



/**
 * @class Neo.grid.column.Progress
 * @extends Neo.grid.column.Component
 */
class Progress extends _Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.grid.column.Progress'
         * @protected
         */
        className: 'Neo.grid.column.Progress',
        /**
         * @member {Object} defaults
         * @protected
         */
        defaults: {
            module: _component_Progress_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]
        },
        /**
         * @member {String} type='progress'
         * @protected
         */
        type: 'progress'
    }

    /**
     * @param {Object} config
     * @param {Record} record
     * @returns {Object}
     */
    applyRecordConfigs(config, record) {
        return {
            value: record[this.dataField],
            ...config
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Progress));


/***/ },

/***/ "./src/grid/column/Sparkline.mjs"
/*!***************************************!*\
  !*** ./src/grid/column/Sparkline.mjs ***!
  \***************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Component.mjs */ "./src/grid/column/Component.mjs");
/* harmony import */ var _component_Sparkline_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../component/Sparkline.mjs */ "./src/component/Sparkline.mjs");



/**
 * @class Neo.grid.column.Sparkline
 * @extends Neo.grid.column.Component
 */
class Sparkline extends _Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.grid.column.Sparkline'
         * @protected
         */
        className: 'Neo.grid.column.Sparkline',
        /**
         * @member {Object} defaults
         * @protected
         */
        defaults: {
            module: _component_Sparkline_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]
        },
        /**
         * @member {String|null} rendererClassName=null
         */
        rendererClassName: null,
        /**
         * @member {String|null} rendererImportPath=null
         */
        rendererImportPath: null,
        /**
         * @member {String} type='sparkline'
         * @protected
         */
        type: 'sparkline'
    }

    /**
     * @param {Object} config
     * @param {Record} record
     * @returns {Object}
     */
    applyRecordConfigs(config, record) {
        return {
            values: record[this.dataField],
            ...config
        }
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        if (me.rendererClassName || me.rendererImportPath) {
            me.defaults = {
                ...me.defaults,
                rendererClassName : me.rendererClassName,
                rendererImportPath: me.rendererImportPath
            }
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Sparkline));


/***/ },

/***/ "./src/grid/column/_export.mjs"
/*!*************************************!*\
  !*** ./src/grid/column/_export.mjs ***!
  \*************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AnimatedChange: () => (/* reexport safe */ _AnimatedChange_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   AnimatedCurrency: () => (/* reexport safe */ _AnimatedCurrency_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   Base: () => (/* reexport safe */ _Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   Component: () => (/* reexport safe */ _Component_mjs__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   CountryFlag: () => (/* reexport safe */ _CountryFlag_mjs__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   Currency: () => (/* reexport safe */ _Currency_mjs__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   GitHubOrgs: () => (/* reexport safe */ _GitHubOrgs_mjs__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   GitHubUser: () => (/* reexport safe */ _GitHubUser_mjs__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   Icon: () => (/* reexport safe */ _Icon_mjs__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   IconLink: () => (/* reexport safe */ _IconLink_mjs__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   Index: () => (/* reexport safe */ _Index_mjs__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   LinkedIn: () => (/* reexport safe */ _LinkedIn_mjs__WEBPACK_IMPORTED_MODULE_11__["default"]),
/* harmony export */   Progress: () => (/* reexport safe */ _Progress_mjs__WEBPACK_IMPORTED_MODULE_12__["default"]),
/* harmony export */   Sparkline: () => (/* reexport safe */ _Sparkline_mjs__WEBPACK_IMPORTED_MODULE_13__["default"])
/* harmony export */ });
/* harmony import */ var _AnimatedChange_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AnimatedChange.mjs */ "./src/grid/column/AnimatedChange.mjs");
/* harmony import */ var _AnimatedCurrency_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AnimatedCurrency.mjs */ "./src/grid/column/AnimatedCurrency.mjs");
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Base.mjs */ "./src/grid/column/Base.mjs");
/* harmony import */ var _Component_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Component.mjs */ "./src/grid/column/Component.mjs");
/* harmony import */ var _CountryFlag_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CountryFlag.mjs */ "./src/grid/column/CountryFlag.mjs");
/* harmony import */ var _Currency_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Currency.mjs */ "./src/grid/column/Currency.mjs");
/* harmony import */ var _GitHubOrgs_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./GitHubOrgs.mjs */ "./src/grid/column/GitHubOrgs.mjs");
/* harmony import */ var _GitHubUser_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./GitHubUser.mjs */ "./src/grid/column/GitHubUser.mjs");
/* harmony import */ var _Icon_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Icon.mjs */ "./src/grid/column/Icon.mjs");
/* harmony import */ var _IconLink_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./IconLink.mjs */ "./src/grid/column/IconLink.mjs");
/* harmony import */ var _Index_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Index.mjs */ "./src/grid/column/Index.mjs");
/* harmony import */ var _LinkedIn_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./LinkedIn.mjs */ "./src/grid/column/LinkedIn.mjs");
/* harmony import */ var _Progress_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Progress.mjs */ "./src/grid/column/Progress.mjs");
/* harmony import */ var _Sparkline_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Sparkline.mjs */ "./src/grid/column/Sparkline.mjs");


















/***/ },

/***/ "./src/grid/footer/Toolbar.mjs"
/*!*************************************!*\
  !*** ./src/grid/footer/Toolbar.mjs ***!
  \*************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../toolbar/Base.mjs */ "./src/toolbar/Base.mjs");


/**
 * @class Neo.grid.footer.Toolbar
 * @extends Neo.toolbar.Base
 *
 * @summary A specialized Toolbar designed for the footer area of a Grid Container.
 *
 * This class extends the standard Toolbar to provide built-in integration with the Grid's Data Store.
 * It automatically binds to the following Store events when a store is assigned:
 * - `load`: Triggers `onStoreLoad`
 * - `filter`: Triggers `onStoreFilter`
 * - `progress`: Triggers `onStoreProgress` (useful for streaming proxies)
 *
 * Subclasses should override these placeholder methods to implement specific logic, such as
 * updating status text, progress bars, or pagination controls.
 *
 * @see Neo.grid.Container
 */
class GridFooterToolbar extends _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.grid.footer.Toolbar'
         * @protected
         */
        className: 'Neo.grid.footer.Toolbar',
        /**
         * @member {String} ntype='grid-footer-toolbar'
         * @protected
         */
        ntype: 'grid-footer-toolbar',
        /**
         * @member {String[]} baseCls=['neo-grid-footer-toolbar', 'neo-toolbar']
         * @protected
         */
        baseCls: ['neo-grid-footer-toolbar', 'neo-toolbar'],
        /**
         * @member {Neo.data.Store|null} store_=null
         * @reactive
         */
        store_: null
    }

    /**
     * Triggered before the store config gets changed.
     * @param {Neo.data.Store|Object|null} value
     * @param {Neo.data.Store|null} oldValue
     * @returns {Neo.data.Store}
     * @protected
     */
    beforeSetStore(value, oldValue) {
        let me        = this,
            listeners = {
                filter  : me.onStoreFilter,
                load    : me.onStoreLoad,
                progress: me.onStoreProgress,
                scope   : me
            };

        oldValue?.un(listeners);

        // Store might be passed as an instance or config
        if (value && value.on) {
            value.on(listeners)
        } else if (value) {
            value.listeners ??= {};
            Object.assign(value.listeners, listeners)
        }

        return value
    }

    /**
     Overwrite as needed
     * @param {Object} data
     */
    onStoreFilter(data) {}

    /**
     * Overwrite as needed
     * @param {Object} data
     */
    onStoreLoad(data) {}

    /**
     Overwrite as needed
     * @param {Object} data {loaded, total}
     */
    onStoreProgress(data) {}
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(GridFooterToolbar));


/***/ },

/***/ "./src/grid/header/Button.mjs"
/*!************************************!*\
  !*** ./src/grid/header/Button.mjs ***!
  \************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../button/Base.mjs */ "./src/button/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../form/field/Text.mjs */ "./src/form/field/Text.mjs");




/**
 * @class Neo.grid.header.Button
 * @extends Neo.button.Base
 */
class Button extends _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for align
     * @member {String[]} cellAlignValues: ['left','center','right']
     * @protected
     * @static
     */
    static cellAlignValues = ['left', 'center', 'right']

    static config = {
        /**
         * @member {String} className='Neo.grid.header.Button'
         * @protected
         */
        className: 'Neo.grid.header.Button',
        /**
         * @member {String} ntype='grid-header-button'
         * @protected
         */
        ntype: 'grid-header-button',
        /**
         * @member {String[]} baseCls=['neo-grid-header-button','neo-button']
         */
        baseCls: ['neo-grid-header-button', 'neo-button'],
        /**
         * Alignment of the matching grid cells. Valid values are left, center, right
         * @member {String} cellAlign_='left'
         * @reactive
         */
        cellAlign_: 'left',
        /**
         * @member {String|null} dataField=null
         */
        dataField: null,
        /**
         * Sort direction when clicking on an unsorted button
         * @member {String} defaultSortDirection='ASC'
         */
        defaultSortDirection: 'ASC',
        /**
         * @member {Object} editorConfig=null
         */
        editorConfig: null,
        /**
         * @member {Object} filterConfig=null
         */
        filterConfig: null,
        /**
         * @member {Neo.form.field.Base|null} filterField=null
         * @protected
         */
        filterField: null,
        /**
         * @member {String} iconCls='fa fa-arrow-circle-up'
         * @reactive
         */
        iconCls: 'fa fa-arrow-circle-up',
        /**
         * @member {String} iconPosition='right'
         * @reactive
         */
        iconPosition: 'right',
        /**
         * 'ASC', 'DESC' or null
         * @member {String|null} isSorted_=null
         * @protected
         * @reactive
         */
        isSorted_: null,
        /**
         * @member {String} role='columnheader'
         * @reactive
         */
        role: 'columnheader',
        /**
         * @member {Boolean} showHeaderFilter_=false
         * @reactive
         */
        showHeaderFilter_: false,
        /**
         * @member {Boolean} sortable_=true
         * @reactive
         */
        sortable_: true,
        /**
         * True enables restoring the initial sort state (ASC, DESC, null)
         * @member {Boolean} useTriStateSorting_=false
         * @reactive
         */
        useTriStateSorting_: false
    }

    /**
     * Triggered after the isSorted config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetIsSorted(value, oldValue) {
        let me        = this,
            {cls}     = me,
            container = me.up('grid-container');

        switch (value) {
            case null:
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-sort-hidden');
                break
            case 'ASC':
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, 'neo-sort-desc');
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, 'neo-sort-hidden');
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-sort-asc');
                break
            case 'DESC':
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, 'neo-sort-asc');
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, 'neo-sort-hidden');
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-sort-desc');
                break
        }

        me.cls = cls;

        // testing check until all example grids have a store
        if (!container || !container.store) {
            return
        }

        me.mounted && me.fire('sort', {
            direction: value,
            property : me.dataField
        })
    }

    /**
     * Triggered after the showHeaderFilter config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowHeaderFilter(value, oldValue) {
        let me = this;

        if (value) {
            if (!me.filterField) {
                me.filterField = Neo.create({
                    module   : _form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
                    appName  : me.appName,
                    flag     : 'filter-field',
                    hideLabel: true,
                    parentId : me.id,
                    style    : {marginLeft: '.5em', marginRight: '.5em'},
                    windowId : me.windowId,

                    listeners: {
                        change        : me.changeFilterValue,
                        operatorChange: me.changeFilterOperator,
                        scope         : me
                    },

                    ...me.editorConfig
                });

                me.vdom.cn.push(me.filterField.createVdomReference())
            } else {
                delete me.filterField.vdom.removeDom
            }
        } else if (me.filterField) {
            me.filterField.vdom.removeDom = true
        }

        me.updateDepth = 2;
        me.update()
    }

    /**
     * Triggered after the sortable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetSortable(value, oldValue) {
        let me    = this,
            {cls} = me;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].toggle(cls, 'neo-sort-hidden', !value);

        me.cls = cls;
        me.update()
    }

    /**
     * Triggered before the cellAlign config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetCellAlign(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'cellAlign', 'cellAlignValues')
    }

    /**
     *
     */
    destroy(...args) {
        this.filterField?.destroy();
        super.destroy(...args)
    }

    /**
     * @param {Object} data
     * @protected
     */
    onClick(data) {
        let me = this,
            map;

        if (me.defaultSortDirection === 'DESC') {
            map = {
                ASC : me.useTriStateSorting ? null : 'DESC',
                DESC: 'ASC',
                null: 'DESC'
            }
        } else {
            map = {
                ASC : 'DESC',
                DESC: me.useTriStateSorting ? null : 'ASC',
                null: 'ASC'
            }
        }

        me.isSorted = map[me.isSorted + ''];

        super.onClick(data)
    }

    /**
     * @param {Object} data
     */
    changeFilterOperator(data) {
        let me            = this,
            gridContainer = me.up('grid-container'),
            store         = gridContainer?.store,
            operator      = data.value,
            filter, filters;

        if (store) {
            filter = store.getFilter(me.dataField);

            if (!filter) {
                filters = store.filters;

                filters.push({
                    property: me.dataField,
                    operator,
                    value   : null,
                    ...me.filterConfig
                });

                store.filters = filters
            } else {
                filter.operator = operator
            }
        }
    }

    /**
     * @param {Object} data
     */
    changeFilterValue(data) {
        let me            = this,
            gridContainer = me.up('grid-container'),
            store         = gridContainer?.store,
            {value}       = data,
            field, filter, filters, model;

        if (store) {
            filter = store.getFilter(me.dataField);
            model  = store.model;
            field  = model.getField(me.dataField);

            if (value && field?.type.toLowerCase() === 'date') {
                value = new Date(value)
            }

            if (!filter) {
                filters = store.filters;

                filters.push({
                    property: me.dataField,
                    operator: 'like',
                    value,
                    ...me.filterConfig
                });

                store.filters = filters
            } else {
                filter.value = value
            }
        }
    }

    /**
     * @protected
     */
    removeSortingCss() {
        let me    = this,
            {cls} = me;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-sort-hidden');

        me.cls       = cls;
        me._isSorted = null
    }

    /**
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            cellAlign           : me.cellAlign,
            dataField           : me.dataField,
            defaultSortDirection: me.defaultSortDirection,
            editorConfig        : me.serializeConfig(me.editorConfig),
            filterConfig        : me.serializeConfig(me.filterConfig),
            isSorted            : me.isSorted,
            showHeaderFilter    : me.showHeaderFilter,
            sortable            : me.sortable,
            useTriStateSorting  : me.useTriStateSorting
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Button));


/***/ },

/***/ "./src/grid/header/Toolbar.mjs"
/*!*************************************!*\
  !*** ./src/grid/header/Toolbar.mjs ***!
  \*************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../toolbar/Base.mjs */ "./src/toolbar/Base.mjs");


/**
 * @class Neo.grid.header.Toolbar
 * @extends Neo.toolbar.Base
 */
class Toolbar extends _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.grid.header.Toolbar'
         * @protected
         */
        className: 'Neo.grid.header.Toolbar',
        /**
         * @member {String} ntype='grid-header-toolbar'
         * @protected
         */
        ntype: 'grid-header-toolbar',
        /**
         * @member {String[]} baseCls=['neo-grid-header-toolbar','neo-toolbar']
         */
        baseCls: ['neo-grid-header-toolbar', 'neo-toolbar'],
        /**
         * @member {Boolean} dragResortable=true
         * @reactive
         */
        dragResortable: true,
        /**
         * @member {Object} itemDefaults={ntype: 'grid-header-button'}
         * @reactive
         */
        itemDefaults: {
            ntype: 'grid-header-button'
        },
        /**
         * @member {String} role='row'
         * @reactive
         */
        role: 'row',
        /**
         * @member {Number} scrollLeft_=0
         * @reactive
         */
        scrollLeft_: 0,
        /**
         * @member {Boolean} showHeaderFilters_=false
         * @reactive
         */
        showHeaderFilters_: false,
        /**
         * Convenience shortcut to pass sortable to all toolbar items.
         * If set to true, header clicks will sort the matching column (ASC, DESC, null)
         * @member {Boolean} sortable_=true
         * @reactive
         */
        sortable_: true,
        /**
         * Convenience shortcut to pass useTriStateSorting to all toolbar items.
         * True enables restoring the initial sort state (ASC, DESC, null)
         * @member {Boolean} useTriStateSorting_=false
         * @reactive
         */
        useTriStateSorting_: false,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {'aria-rowindex': 1, cn: [{cn: []}]}
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);
        value && this.passSizeToBody()
    }

    /**
     * Triggered after the showHeaderFilters config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowHeaderFilters(value, oldValue) {
        if (oldValue !== undefined) {
            let me = this;

            me.items.forEach(item => {
                item.setSilent({
                    showHeaderFilter: value
                })
            });

            me.updateDepth = -1; // filters can be deeply nested
            me.update()
        }
    }

    /**
     * Triggered after the scrollLeft config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetScrollLeft(value, oldValue) {
        if (oldValue !== undefined && this.sortZone) {
            this.sortZone.scrollLeft = value
        }
    }

    /**
     * Triggered after the sortable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetSortable(value, oldValue) {
        if (oldValue !== undefined) {
            let me = this;

            me.items.forEach(item => {
                item.setSilent({
                    sortable: value
                })
            });

            me.updateDepth = 2;
            me.update()
        }
    }

    /**
     * Triggered after the useTriStateSorting config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetUseTriStateSorting(value, oldValue) {
        if (oldValue !== undefined) {
            let me = this;

            me.items.forEach(item => {
                item.setSilent({
                    useTriStateSorting: value
                })
            });

            me.updateDepth = 2;
            me.update()
        }
    }

    /**
     *
     */
    createItems() {
        let me        = this,
            {mounted} = me;

        me.itemDefaults.showHeaderFilter = me.showHeaderFilters;

        me.items.forEach(item => {
            if (!Object.hasOwn(item, 'sortable')) {
                item.sortable = me.sortable
            }

            if (!Object.hasOwn(item, 'useTriStateSorting')) {
                item.useTriStateSorting = me.useTriStateSorting
            }
        });

        super.createItems();

        let {items} = me,
            style;

        items.forEach((item, index) => {
            item.vdom['aria-colindex'] = index + 1; // 1 based

            style = item.wrapperStyle;

            // todo: only add px if number
            if (item.maxWidth) {style.maxWidth = item.maxWidth + 'px'}
            if (item.minWidth) {style.minWidth = item.minWidth + 'px'}
            if (item.width)    {style.width    = item.width    + 'px'}

            item.wrapperStyle = style
        });

        me.promiseUpdate().then(() => {
            // To prevent duplicate calls, we need to check the mounted state before the update call
            mounted && me.passSizeToBody()
        })
    }

    /**
     * @param {Object} config
     */
    createSortZone(config) {
        let me = this;

        Neo.merge(config, {
            boundaryContainerId: [me.id, me.parent.id],
            scrollLeft         : me.scrollLeft
        });

        super.createSortZone(config)
    }

    /**
     * @param {String} dataField
     * @returns {Neo.button.Base|null}
     */
    getColumn(dataField) {
        for (const item of this.items) {
            if (item.dataField === dataField) {
                return item
            }
        }

        return null
    }

    /**
     * @returns {Promise<any>}
     */
    loadSortZoneModule() {
        return Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("vendors-src_draggable_container_SortZone_mjs"), __webpack_require__.e("vendors-src_draggable_DragProxyContainer_mjs-src_draggable_grid_header_toolbar_SortZone_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ../../draggable/grid/header/toolbar/SortZone.mjs */ "./src/draggable/grid/header/toolbar/SortZone.mjs"))
    }

    /**
     * @param {Boolean} silent=false
     * @returns {Promise<void>}
     */
    async passSizeToBody(silent=false) {
        let me              = this,
            {items}         = me,
            {body}          = me.parent,
            rects           = await me.getDomRect(items.map(item => item.id)),
            lastItem        = rects[rects.length - 1],
            columnPositions = rects.map((item, index) => ({dataField: items[index].dataField, width: item.width, x: item.x - rects[0].x})),
            i               = 1,
            len             = columnPositions.length,
            layoutFinished  = true;

        // If the css sizing is not done, columns after the first one can get x = 0
        for (; i < len; i++) {
            if (columnPositions[i].x === 0) {
                layoutFinished = false;
                break;
            }
        }

        // Delay for slow connections, where the container-sizing is not done yet
        if (!layoutFinished) {
            await me.timeout(100);
            await me.passSizeToBody(silent)
        } else {
            body.columnPositions.clear();
            body.columnPositions.add(columnPositions);

            body[silent ? 'setSilent' : 'set']({
                availableWidth: lastItem.x + lastItem.width - rects[0].x
            });

            !silent && body.updateMountedAndVisibleColumns()
        }
    }

    /**
     * @param {Number}  index
     * @returns {Promise<void>}
     */
    async scrollToIndex(index) {
        await Neo.main.DomAccess.scrollIntoView({
            delay   : 125,
            id      : this.items[index].id,
            windowId: this.windowId
        })
    }

    /**
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            scrollLeft        : me.scrollLeft,
            showHeaderFilters : me.showHeaderFilters,
            sortable          : me.sortable,
            useTriStateSorting: me.useTriStateSorting
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Toolbar));


/***/ },

/***/ "./src/grid/header/_export.mjs"
/*!*************************************!*\
  !*** ./src/grid/header/_export.mjs ***!
  \*************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Button: () => (/* reexport safe */ _Button_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   Toolbar: () => (/* reexport safe */ _Toolbar_mjs__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var _Button_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Button.mjs */ "./src/grid/header/Button.mjs");
/* harmony import */ var _Toolbar_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Toolbar.mjs */ "./src/grid/header/Toolbar.mjs");





/***/ },

/***/ "./src/selection/Model.mjs"
/*!*********************************!*\
  !*** ./src/selection/Model.mjs ***!
  \*********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");





/**
 * @class Neo.selection.Model
 * @extends Neo.core.Base
 * @mixes Neo.core.Observable
 */
class Model extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.selection.Model'
         * @protected
         */
        className: 'Neo.selection.Model',
        /**
         * @member {String} ntype='selection-model'
         * @protected
         */
        ntype: 'selection-model',
        /**
         * Placeholder for extended classes to add a custom css rule to this owner component
         * @member {String|null} cls=null
         * @protected
         */
        cls: null,
        /**
         * @member {Array} items_
         * @protected
         * @reactive
         */
        items_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_3__.isDescriptor]: true,
            clone         : 'shallow',
            cloneOnGet    : 'none',
            isEqual       : () => false,
            value         : []
        },
        /**
         * @member {String} selectedCls='selected'
         */
        selectedCls: 'neo-selected',
        /**
         * @member {Boolean} singleSelect=true
         */
        singleSelect: true,
        /**
         * Internally saves the view id, but the getter will return the matching instance
         * @member {Object} view_=null
         * @protected
         * @reactive
         */
        view_: null
    }

    /**
     * Gets triggered before getting the value of the view config
     * @param {String} value
     * @returns {Neo.component.Base}
     */
    beforeGetView(value) {
        return Neo.getComponent(this._view)
    }

    /**
     * Gets triggered before setting the value of the view config
     * @returns {String} the view id
     */
    beforeSetView(value) {
        return value && value.id
    }

    /**
     *
     */
    addDomListener() {}

    /**
     * @param {Object} item
     * @param {Boolean} [silent] true to prevent a vdom update
     * @param {Object[]|String[]} itemCollection=this.items
     * @param {String} [selectedCls]
     */
    deselect(item, silent, itemCollection=this.items, selectedCls) {
        let me     = this,
            {view} = me,
            node;

        // We hold vdom ids for now, so all incoming selections must be converted.
        item = item.isRecord ? view.getItemId(item) : Neo.isObject(item) ? item.id : item;

        if (itemCollection.includes(item)) {
            node = view.getVdomChild(item);

            if (node) {
                node.cls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(node.cls || [], selectedCls || me.selectedCls);
                delete node['aria-selected']
            }

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(itemCollection, item);

            if (!silent) {
                view.update();

                view.parent?.onDeselect?.(); // grid.Container & table.Container
                view.onDeselect?.();

                me.fire('selectionChange', {
                    selection: itemCollection
                })
            }
        } else if (!silent) {
            me.fire('noChange')
        }
    }

    /**
     * @param {Boolean} [silent] true to prevent a vdom update
     * @param {Object[]|String[]} itemCollection=this.items
     */
    deselectAll(silent, itemCollection=this.items) {
        let me     = this,
            items  = [...itemCollection],
            {view} = me;

        if (items.length) {
            items.forEach(item => {
                me.deselect(item, true)
            });

            if (!silent && items.length > 0) {
                view.update()
            }

            me.fire('selectionChange', {
                selection: this.items
            })
        } else if (!silent) {
            me.fire('noChange')
        }
    }

    /**
     *
     */
    destroy(...args) {
        this.unregister();
        super.destroy(...args)
    }

    /**
     * Important for mapping listeners to view controllers
     * @returns {Neo.controller.Component|null}
     */
    getController() {
        return this.view.getController()
    }

    /**
     * @returns {Array} this.items
     */
    getSelection() {
        return this.items
    }

    /**
     * @returns {Boolean}
     */
    hasSelection() {
        return this.items.length > 0
    }

    /**
     * @param {String} id
     * @returns {Boolean} true in case the item is selected
     */
    isSelected(id) {
        return this.items.includes(id)
    }

    /**
     * @param {Neo.component.Base} component
     */
    register(component) {
        let me  = this,
            cls = component.wrapperCls || [];

        if (me.cls && !cls.includes(me.cls)) {
            cls.push(me.cls);
            component.wrapperCls = cls
        }

        me.view = component;
        me.addDomListener();

        component.fire('selectionModelChange', {
            value: me
        })
    }

    /**
     *
     */
    removeDomListeners() {
        let me           = this,
            component    = me.view,
            domListeners = [...component.domListeners];

        component.domListeners.forEach(listener => {
            if (listener.scope === me) {
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(domListeners, listener)
            }
        });

        component.domListeners = domListeners
    }

    /**
     * @param {Object|Object[]|String[]} items
     * @param {Object[]|String[]} itemCollection=this.items
     * @param {String} [selectedCls]
     */
    select(items, itemCollection=this.items, selectedCls) {
        if (!Array.isArray(items)) {
            items = [items]
        }

        let me      = this,
            {view}  = me,
            records = items.map(item => {
                if (item.isRecord) return item;

                const recordId = view.getItemRecordId?.(item);

                return recordId && view.store?.get(recordId) || item
            });

        // We hold vdom ids for now, so all incoming selections must be converted.
        items = items.map(item => item.isRecord ? view.getItemId(item) : Neo.isObject(item) ? item.id : item);

        if (!Neo.isEqual(itemCollection, items)) {
            if (me.singleSelect && itemCollection === me.items) {
                me.deselectAll(true, itemCollection)
            }

            items.forEach(node => {
                node = view.getVdomChild(node);

                if (node) {
                    node.cls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(node.cls || [], selectedCls || me.selectedCls);
                    node['aria-selected'] = true
                }
            });

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(itemCollection, items);

            if (!view.silentSelect) {
                view.update()
            }

            view.parent?.onSelect?.(items); // grid.Container & table.Container
            view.onSelect?.(items);

            view.fire('select', {
                records,
                selection: itemCollection
            });

            me.fire('selectionChange', {
                records,
                selection: itemCollection
            })
        }
        else {
            me.fire('noChange')
        }
    }

    /**
     * @param {Object} item
     */
    toggleSelection(item) {
        let me = this;

        if (me.isSelected(item)) {
            me.deselect(item)
        } else {
            me.select(item)
        }
    }

    /**
     * @returns {Object}
     */
    toJSON() {
        const
            me    = this,
            items = (me.items || []).map(item => {
                if (Neo.isRecord(item)) {
                    return item.toJSON()
                }

                return item
            });

        return {
            ...super.toJSON(),
            items,
            selectedCls : me.selectedCls,
            singleSelect: me.singleSelect
        }
    }

    /**
     *
     */
    unregister() {
        let me     = this,
            {view} = me;

        if (!view.isDestroying) {
            let cls = view.wrapperCls || [];

            if (me.cls && cls.includes(me.cls)) {
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, me.cls);
                view.wrapperCls = cls
            }

            me.deselectAll();

            me.removeDomListeners()
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Model));


/***/ },

/***/ "./src/selection/grid/BaseModel.mjs"
/*!******************************************!*\
  !*** ./src/selection/grid/BaseModel.mjs ***!
  \******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Model_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Model.mjs */ "./src/selection/Model.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * Abstract base class for all grid related selection models
 * @class Neo.selection.grid.BaseModel
 * @extends Neo.selection.Model
 * @abstract
 */
class BaseModel extends _Model_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.selection.grid.BaseModel'
         * @protected
         */
        className: 'Neo.selection.grid.BaseModel',
        /**
         * Storing the column dataFields
         * @member {String[]} selectedColumns=[]
         */
        selectedColumns: [],
        /**
         * Storing the record ids
         * @member {Number[]|String[]} selectedRows=[]
         * @protected
         */
        selectedRows: []
    }

    /**
     * Convenience shortcut
     * @member {String[]} dataFields
     */
    get dataFields() {
        return this.view.parent.columns.items.map(column => column.dataField)
    }

    /**
     * Updates the visual state (selection class) of specific rows or cells without triggering a full Body update.
     *
     * This method implements the **Granular Update** strategy:
     * 1.  It iterates over the provided items (logical cell IDs or record IDs).
     * 2.  It resolves the corresponding `Neo.grid.Row` component.
     * 3.  It inspects the **current VDOM state** of the target node (row or cell).
     * 4.  It ONLY mutates the VDOM and triggers `row.update()` if the selection state has actually changed.
     *
     * This ensures O(1) performance for selection operations, regardless of grid size, and eliminates redundant VDOM traffic.
     *
     * @param {Object[]|String[]} items - Array of Record IDs (for RowModel) or Logical Cell IDs (for CellModel).
     * @param {Boolean} [silent=false] - If true, mutates the VDOM but suppresses the `row.update()` call.
     */
    updateRows(items, silent=false) {
        if (!items || items.length === 0) return;

        if (!Array.isArray(items)) {
            items = [items]
        }

        let me        = this,
            {view}    = me,
            {store}   = view,
            processed = new Set();

        items.forEach(item => {
            let hasChanged = false,
                isCell     = item.toString().includes('__'),
                recordId, row;

            if (isCell) {
                // item is a logical ID: recordId__dataField
                // We resolve the record to find the row.
                let record = view.getRecordFromLogicalId(item);
                if (record) {
                    row = view.getRow(record);

                    if (row && !processed.has(item)) {
                        processed.add(item); // Process each logical cell only once per batch

                        // Find the cell node in the row's VDOM
                        let dataField     = view.getDataField(item),
                            cellNode      = row.vdom.cn.find(n => n.data?.field === dataField),
                            shouldSelect  = me.isSelected(item),
                            alreadySelect = cellNode?.cls?.includes(me.selectedCls);

                        if (cellNode && shouldSelect !== alreadySelect) {
                            // Mutate VDOM directly: Toggle selection class
                            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"][shouldSelect ? 'add' : 'remove'](cellNode.cls, me.selectedCls);

                            if (shouldSelect) {
                                cellNode['aria-selected'] = true
                            } else {
                                delete cellNode['aria-selected']
                            }

                            hasChanged = true
                        }

                        // We must trigger the update on the row to flush the VDOM change
                        if (hasChanged && !silent) {
                            row.update()
                        }
                    }
                }
            } else {
                // item is a recordId (RowModel)
                recordId = item;

                if (!processed.has(recordId)) {
                    processed.add(recordId);
                    let record = store.get(recordId);

                    if (record) {
                        row = view.getRow(record);

                        if (row) {
                            let isSelected    = me.isSelectedRow(recordId),
                                alreadySelect = row.vdom.cls?.includes(me.selectedCls);

                            if (isSelected !== alreadySelect) {
                                // Mutate VDOM directly: Toggle selection class on the row
                                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"][isSelected ? 'add' : 'remove'](row.vdom.cls, me.selectedCls);

                                if (isSelected) {
                                    row.vdom['aria-selected'] = true
                                } else {
                                    delete row.vdom['aria-selected']
                                }

                                hasChanged = true
                            }

                            if (hasChanged && !silent) {
                                row.update()
                            }
                        }
                    }
                }
            }
        })
    }

    /**
     * @param {Object} item
     * @param {Boolean} [silent] true to prevent a vdom update
     * @param {Object[]|String[]} itemCollection=this.items
     * @param {String} [selectedCls]
     */
    deselect(item, silent, itemCollection, selectedCls) {
        let me = this;

        me.view.silentSelect = true;
        super.deselect(item, silent, itemCollection, selectedCls);
        me.view.silentSelect = false;

        if (!silent) {
            me.updateRows(item)
        }
    }

    /**
     * @param {Boolean} [silent] true to prevent a vdom update
     * @param {Object[]|String[]} itemCollection=this.items
     */
    deselectAll(silent, itemCollection) {
        let me    = this,
            items = [...itemCollection || me.items]; // Capture items before they are removed

        me.view.silentSelect = true;
        super.deselectAll(silent, itemCollection);
        me.view.silentSelect = false;

        me.updateRows(items)
    }

    /**
     * @param {Object|Object[]|String[]} items
     * @param {Object[]|String[]} itemCollection=this.items
     * @param {String} [selectedCls]
     */
    select(items, itemCollection, selectedCls) {
        let me = this;

        me.view.silentSelect = true;
        super.select(items, itemCollection, selectedCls);
        me.view.silentSelect = false;

        me.updateRows(items)
    }

    /**
     * @param {Boolean} [silent=false] true to prevent a vdom update
     */
    deselectAllRows(silent=false) {
        let me    = this,
            items = [...me.selectedRows];

        if (items.length) {
            items.forEach(item => {
                me.deselectRow(item, true)
            });

            if (!silent) {
                me.updateRows(items)
            }

            me.fire('selectionChange', {
                records  : me.selectedRows.map(id => me.view.store.get(id)),
                selection: me.selectedRows
            })
        } else if (!silent) {
            me.fire('noChange')
        }
    }

    /**
     * @param {Number|String} recordId
     * @param {Boolean}       [silent=false]
     */
    deselectRow(recordId, silent=false) {
        let me = this;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(me.selectedRows, recordId);

        me.updateRows(recordId, silent)
    }

    /**
     * @param {Object} path
     * @returns {Number|String|null}
     */
    getRecord(path) {
        let node, rowIndex;

        for (node of path) {
            if (node.aria?.rowindex) {
                rowIndex = parseInt(node.aria.rowindex);

                // aria-rowindex is 1 based & also includes the header
                rowIndex -= 2;

                return this.view.store.getAt(rowIndex)
            }
        }

        return null
    }

    /**
     * Resolves a record from an ID (PK or internalId).
     * @param {String|Number} id
     * @returns {Neo.data.Record|null}
     */
    getRowRecord(id) {
        if (!id) return null;

        let me    = this,
            {view} = me,
            {store}= view,
            record = store.get(id);

        if (record) return record;

        // Fast path: Check visible rows
        if (view.items) {
            let row = view.items.find(r => r.record && view.getRecordId(r.record) === id);
            if (row) return row.record
        }

        return null
    }

    /**
     * @param {Number|String} recordId
     * @returns {Neo.grid.Row|null}
     */
    getRowComponent(recordId) {
        return this.view.items.find(row => row.record && this.view.store.getKey(row.record) === recordId) || null
    }

    /**
     * @param {Record} record
     * @returns {Boolean}
     */
    hasAnnotations(record) {
        return !!Object.getOwnPropertyDescriptor(record.__proto__, this.view.selectedRecordField)
    }

    /**
     * Checks if an event path contains a grid cell editor
     * @param {Object}   data
     * @param {Object[]} data.path
     * @returns {Boolean}
     */
    hasEditorFocus({path}) {
        for (const node of path) {
            if (node.cls?.includes('neo-grid-editor')) {
                return true
            }
        }

        return false
    }

    /**
     * @param {String} dataField
     * @returns {Boolean} true in case the column is selected
     */
    isSelectedColumn(dataField) {
        return this.selectedColumns.includes(dataField)
    }

    /**
     * @param {Number|String} recordId
     * @returns {Boolean} true in case the row is selected
     */
    isSelectedRow(recordId) {
        return this.selectedRows.includes(recordId)
    }

    /**
     * @param {Number|String} recordId
     * @param {Boolean}       [silent=false]
     */
    selectRow(recordId, silent=false) {
        let me = this;

        if (me.singleSelect) {
            [...me.selectedRows].forEach(id => me.deselectRow(id))
        }

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(me.selectedRows, recordId);

        me.updateRows(recordId, silent)
    }

    /**
     * @param {Number|String} recordId
     * @param {Boolean}       [silent=false]
     */
    toggleRowSelection(recordId, silent=false) {
        this[this.isSelectedRow(recordId) ? 'deselectRow' : 'selectRow'](recordId, silent)
    }

    /**
     * @returns {Object}
     */
    toJSON() {
        return {
            ...super.toJSON(),
            selectedColumns: this.selectedColumns,
            selectedRows   : this.selectedRows
        }
    }

    /**
     *
     */
    unregister() {
        let me        = this,
            countRows = me.selectedRows.length;

        me.selectedRows = [];

        countRows > 0 && me.view.createViewData();

        super.unregister()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(BaseModel));


/***/ },

/***/ "./src/selection/grid/RowModel.mjs"
/*!*****************************************!*\
  !*** ./src/selection/grid/RowModel.mjs ***!
  \*****************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _BaseModel_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseModel.mjs */ "./src/selection/grid/BaseModel.mjs");


/**
 * @class Neo.selection.grid.RowModel
 * @extends Neo.selection.grid.BaseModel
 */
class RowModel extends _BaseModel_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.selection.grid.RowModel'
         * @protected
         */
        className: 'Neo.selection.grid.RowModel',
        /**
         * @member {String} ntype='selection-grid-rowmodel'
         * @protected
         */
        ntype: 'selection-grid-rowmodel',
        /**
         * @member {String} cls='neo-selection-rowmodel'
         * @protected
         */
        cls: 'neo-selection-rowmodel'
    }

    /**
     *
     */
    addDomListener() {
        let me = this;

        me.view.parent.on('rowClick', me.onRowClick, me)
    }

    /**
     * @param args
     */
    destroy(...args) {
        let me = this;

        me.view.parent.un('rowClick', me.onRowClick, me);

        super.destroy(...args)
    }

    /**
     * @param {Object} data
     */
    onKeyDownDown(data) {
        !this.hasEditorFocus(data) && this.onNavKeyRow(1)
    }

    /**
     * @param {Object} data
     */
    onKeyDownUp(data) {
        !this.hasEditorFocus(data) && this.onNavKeyRow(-1)
    }

    /**
     * @param {Number} step
     */
    onNavKeyRow(step) {
        let me           = this,
            {view}       = me,
            {store}      = view,
            countRecords = store.getCount(),
            recordId     = me.selectedRows[0] || view.getRecordId(store.getAt(0)),
            record       = me.getRowRecord(recordId),
            index        = store.indexOf(record),
            newIndex     = (index + step) % countRecords;

        while (newIndex < 0) {
            newIndex += countRecords
        }

        record = store.getAt(newIndex);

        if (me.hasAnnotations(record)) {
            me.updateAnnotations(record)
        } else {
            recordId = view.getRecordId(record);

            if (recordId) {
                me.selectRow(recordId);

                view.scrollByRows(index, step);
                view.fire('select', {record})
            }
        }
    }

    /**
     * @param {Object} data
     */
    onRowClick({data}) {
        let me     = this,
            {view} = me,
            record = me.getRecord(data.path),
            recordId;

        if (record) {
            if (me.hasAnnotations(record)) {
                me.updateAnnotations(record)
            } else {
                recordId = view.getRecordId(record);

                me.toggleRowSelection(recordId);

                view.fire(me.isSelectedRow(recordId) ? 'select' : 'deselect', {record})
            }
        }
    }

    /**
     * @param {Neo.component.Base} component
     */
    register(component) {
        super.register(component);

        let {id, view} = this;

        view.keys?._keys.push(
            {fn: 'onKeyDownDown', key: 'Down', scope: id},
            {fn: 'onKeyDownUp',   key: 'Up',   scope: id}
        )
    }

    /**
     *
     */
    unregister() {
        let {id, view} = this;

        view.keys?.removeKeys([
            {fn: 'onKeyDownDown', key: 'Down', scope: id},
            {fn: 'onKeyDownUp',   key: 'Up',   scope: id}
        ]);

        super.unregister()
    }

    /**
     * @param {Record} record
     */
    updateAnnotations(record) {
        let me               = this,
            {view}           = me,
            {store}          = view,
            recordId         = view.getRecordId(record),
            isSelected       = me.isSelectedRow(recordId),
            annotationsField = view.selectedRecordField;

        if (me.singleSelect) {
            if (isSelected) {
                record[annotationsField] = false
            } else {
                me.selectedRows.forEach(recordId => {
                    // We can use setSilent(), since the last change will trigger a view update
                    store.get(recordId).setSilent({[annotationsField]: false})
                });

                record[annotationsField] = true
            }
        } else {
            record[annotationsField] = !record[annotationsField]
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(RowModel));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19ncmlkX0NvbnRhaW5lcl9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFzQztBQUNjOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpREFBUztBQUNuQztBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0EsU0FBUztBQUNULGFBQWEsc0NBQXNDO0FBQ25ELGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaURBQWlEO0FBQzlEO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsOERBQVk7QUFDOUIsVUFBVTtBQUNWLGtCQUFrQiw4REFBWTtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSwyQkFBMkIsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQzVHUjs7QUFFbkM7QUFD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aUVBQWUsd0JBQXdCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbXBvbmVudC9Db3VudHJ5RmxhZy5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb21wb25lbnQvR2l0SHViT3Jncy5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb21wb25lbnQvR2l0SHViVXNlci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb21wb25lbnQvSWNvbi5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb21wb25lbnQvSWNvbkxpbmsubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29tcG9uZW50L1Byb2dyZXNzLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbXBvbmVudC9TcGFya2xpbmUubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZ3JpZC9Cb2R5Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2dyaWQvQ29udGFpbmVyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2dyaWQvUm93Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2dyaWQvU2Nyb2xsTWFuYWdlci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9ncmlkL1ZlcnRpY2FsU2Nyb2xsYmFyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2dyaWQvY29sdW1uL0FuaW1hdGVkQ2hhbmdlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2dyaWQvY29sdW1uL0FuaW1hdGVkQ3VycmVuY3kubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZ3JpZC9jb2x1bW4vQmFzZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9ncmlkL2NvbHVtbi9Db21wb25lbnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZ3JpZC9jb2x1bW4vQ291bnRyeUZsYWcubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZ3JpZC9jb2x1bW4vQ3VycmVuY3kubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZ3JpZC9jb2x1bW4vR2l0SHViT3Jncy5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9ncmlkL2NvbHVtbi9HaXRIdWJVc2VyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2dyaWQvY29sdW1uL0ljb24ubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZ3JpZC9jb2x1bW4vSWNvbkxpbmsubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZ3JpZC9jb2x1bW4vSW5kZXgubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZ3JpZC9jb2x1bW4vTGlua2VkSW4ubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZ3JpZC9jb2x1bW4vUHJvZ3Jlc3MubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZ3JpZC9jb2x1bW4vU3BhcmtsaW5lLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2dyaWQvY29sdW1uL19leHBvcnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZ3JpZC9mb290ZXIvVG9vbGJhci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9ncmlkL2hlYWRlci9CdXR0b24ubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZ3JpZC9oZWFkZXIvVG9vbGJhci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9ncmlkL2hlYWRlci9fZXhwb3J0Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3NlbGVjdGlvbi9Nb2RlbC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9zZWxlY3Rpb24vZ3JpZC9CYXNlTW9kZWwubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvc2VsZWN0aW9uL2dyaWQvUm93TW9kZWwubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDb21wb25lbnQgICAgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQgQ291bnRyeUZsYWdzIGZyb20gJy4uL3V0aWwvQ291bnRyeUZsYWdzLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jb21wb25lbnQuQ291bnRyeUZsYWdcbiAqIEBleHRlbmRzIE5lby5jb21wb25lbnQuQmFzZVxuICovXG5jbGFzcyBDb3VudHJ5RmxhZyBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29tcG9uZW50LkNvdW50cnlGbGFnJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29tcG9uZW50LkNvdW50cnlGbGFnJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWNvdW50cnktZmxhZyddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1jb3VudHJ5LWZsYWcnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBjb3VudHJ5Q29kZV89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgY291bnRyeUNvZGVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGxvY2F0aW9uXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBsb2NhdGlvbl86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSByZXNvbHZlQ291bnRyeUNvZGVfPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICByZXNvbHZlQ291bnRyeUNvZGVfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gX3Zkb21cbiAgICAgICAgICovXG4gICAgICAgIF92ZG9tOlxuICAgICAgICB7Y246IFtcbiAgICAgICAgICAgIHt0YWc6ICdpbWcnLCBjbHM6IFsnbmVvLWNvdW50cnktZmxhZyddfSxcbiAgICAgICAgICAgIHt0YWc6ICdzcGFuJywgY2xzOiBbJ25lby1sb2NhdGlvbi10ZXh0J119XG4gICAgICAgIF19XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIGFmdGVyU2V0Q291bnRyeUNvZGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRmxhZygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIGFmdGVyU2V0TG9jYXRpb24odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUudmRvbS5jblsxXS50ZXh0ID0gdmFsdWUgfHwgJyc7XG5cbiAgICAgICAgaWYgKG1lLnJlc29sdmVDb3VudHJ5Q29kZSkge1xuICAgICAgICAgICAgbWUudXBkYXRlRmxhZygpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS51cGRhdGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhZnRlclNldFJlc29sdmVDb3VudHJ5Q29kZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRmxhZygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHVwZGF0ZUZsYWcoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2NvdW50cnlDb2RlLCBsb2NhdGlvbiwgcmVzb2x2ZUNvdW50cnlDb2RlLCB2ZG9tfSA9IG1lLFxuICAgICAgICAgICAgZmxhZyAgICAgICAgICAgID0gdmRvbS5jblswXSxcbiAgICAgICAgICAgIHVybDtcblxuICAgICAgICBpZiAoY291bnRyeUNvZGUpIHtcbiAgICAgICAgICAgIHVybCA9IENvdW50cnlGbGFncy5nZXRGbGFnVXJsKGNvdW50cnlDb2RlKVxuICAgICAgICB9IGVsc2UgaWYgKHJlc29sdmVDb3VudHJ5Q29kZSAmJiBsb2NhdGlvbikge1xuICAgICAgICAgICAgdXJsID0gQ291bnRyeUZsYWdzLmdldEZsYWdVcmwobG9jYXRpb24pXG4gICAgICAgIH1cblxuICAgICAgICAvLyBQZXJmb3JtYW5jZSBPcHRpbWl6YXRpb246XG4gICAgICAgIC8vIFdlIG1haW50YWluIGEgcGVyc2lzdGVudCA8aW1nPiB0YWcgaW4gdGhlIFZET00gc3RydWN0dXJlIHRvIGVuc3VyZSBhIHN0YWJsZSBET00uXG4gICAgICAgIC8vIFN3YXBwaW5nIHRhZ3MgKGUuZy4gaW1nIDwtPiBzcGFuKSBvciByZW1vdmluZyBub2RlcyB0cmlnZ2VycyBsYXlvdXQgdGhyYXNoaW5nXG4gICAgICAgIC8vIGR1cmluZyByYXBpZCByZWN5Y2xpbmcgKGUuZy4gR3JpZCBzY3JvbGxpbmcpLlxuICAgICAgICAvLyBXZSB0b2dnbGUgdmlzaWJpbGl0eSBpbnN0ZWFkIG9mIHN0cnVjdHVyYWwgY2hhbmdlcy5cbiAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgICAgZmxhZy5zcmMgICA9IHVybDtcbiAgICAgICAgICAgIGZsYWcuc3R5bGUgPSBudWxsOyAvLyBSZW1vdmUgdmlzaWJpbGl0eTogaGlkZGVuXG4gICAgICAgICAgICBmbGFnLnRpdGxlID0gbG9jYXRpb24gfHwgY291bnRyeUNvZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgZmxhZy5zcmM7XG4gICAgICAgICAgICBkZWxldGUgZmxhZy50aXRsZTtcbiAgICAgICAgICAgIGZsYWcuc3R5bGUgPSB7dmlzaWJpbGl0eTogJ2hpZGRlbid9O1xuICAgICAgICB9XG5cbiAgICAgICAgbWUudXBkYXRlKClcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKENvdW50cnlGbGFnKTtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi9CYXNlLm1qcyc7XG5cbi8qKlxuICogQHN1bW1hcnkgRGlzcGxheXMgYSBsaXN0IG9mIEdpdEh1YiBPcmdhbml6YXRpb24gYXZhdGFycyB3aXRoIGxpbmtzLlxuICpcbiAqIFRoaXMgY29tcG9uZW50IHN1cHBvcnRzIHR3byByZW5kZXJpbmcgbW9kZXM6XG4gKiAxLiAqKlN0YW5kYXJkIE1vZGUgKERlZmF1bHQpOioqIFJlbmRlcnMgb25seSB0aGUgb3JnYW5pemF0aW9ucyBwcmVzZW50IGluIHRoZSBkYXRhLiBUaGUgY29tcG9uZW50IHNpemUgYWRhcHRzIHRvIHRoZSBjb250ZW50LlxuICogMi4gKipTdGFibGUgTW9kZSAoYHJlbmRlckZ1bGxQb29sOiB0cnVlYCk6KiogUHJlLWFsbG9jYXRlcyBhIGZpeGVkIG51bWJlciBvZiBub2RlcyAoYG1heEl0ZW1zYCkgYW5kIHRvZ2dsZXMgdGhlaXIgdmlzaWJpbGl0eS5cbiAqICAgIFRoaXMgZW5zdXJlcyB0aGUgY29tcG9uZW50J3MgZGltZW5zaW9ucyByZW1haW4gY29uc3RhbnQgKHJlc2VydmluZyBzcGFjZSksIHdoaWNoIGlzIGNyaXRpY2FsIGZvciBwcmV2ZW50aW5nXG4gKiAgICBsYXlvdXQgdGhyYXNoaW5nIGluIGhpZ2gtZnJlcXVlbmN5IHVwZGF0ZSBzY2VuYXJpb3MgbGlrZSBHcmlkcy5cbiAqXG4gKiBAY2xhc3MgTmVvLmNvbXBvbmVudC5HaXRIdWJPcmdzXG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqL1xuY2xhc3MgR2l0SHViT3JncyBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29tcG9uZW50LkdpdEh1Yk9yZ3MnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb21wb25lbnQuR2l0SHViT3JncycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaXplIGluIHB4IGZvciB0aGUgYXZhdGFyIGltYWdlIHJlcXVlc3QuXG4gICAgICAgICAqIFJlY29tbWVuZGVkIHRvIHVzZSAyeCB0aGUgZGlzcGxheSBzaXplIGZvciBoaWdoIERQSSBzY3JlZW5zLlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGF2YXRhclNpemU9NDBcbiAgICAgICAgICovXG4gICAgICAgIGF2YXRhclNpemU6IDQwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tZ2l0aHViLW9yZ3MnXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tZ2l0aHViLW9yZ3MnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gbWF4SXRlbXNfPTVcbiAgICAgICAgICovXG4gICAgICAgIG1heEl0ZW1zXzogNSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdFtdfG51bGx9IG9yZ3NfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIG9yZ3NfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdHJ1ZSwgdGhlIGNvbXBvbmVudCB3aWxsIGFsd2F5cyByZW5kZXIgYG1heEl0ZW1zYCBub2Rlcy5cbiAgICAgICAgICogVW51c2VkIG5vZGVzIHdpbGwgYmUgaGlkZGVuIHZpYSBgdmlzaWJpbGl0eTogaGlkZGVuYCBidXQgd2lsbCBzdGlsbCBvY2N1cHkgbGF5b3V0IHNwYWNlLlxuICAgICAgICAgKiBVc2UgdGhpcyBzZXR0aW5nIGZvciBHcmlkcyB0byBwcmV2ZW50IGxheW91dCB0aHJhc2hpbmcgZHVyaW5nIHNjcm9sbGluZy5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gcmVuZGVyRnVsbFBvb2xfPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICByZW5kZXJGdWxsUG9vbF86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbVxuICAgICAgICAgKi9cbiAgICAgICAgX3Zkb206XG4gICAgICAgIHtjbjogW119XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3RbXXxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W118bnVsbH0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhZnRlclNldE9yZ3ModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBtYXhJdGVtcyA9IG1lLm1heEl0ZW1zLFxuICAgICAgICAgICAgdmRvbSAgICAgPSBtZS52ZG9tLFxuICAgICAgICAgICAgaXRlbXMgICAgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW107XG5cbiAgICAgICAgaWYgKG1lLnJlbmRlckZ1bGxQb29sKSB7XG4gICAgICAgICAgICAvLyBPcHRpbWl6YXRpb246IE1haW50YWluIGEgZml4ZWQgcG9vbCBvZiBub2RlcyB0byBwcmV2ZW50IGxheW91dCBzaGlmdHMuXG4gICAgICAgICAgICBpZiAodmRvbS5jbi5sZW5ndGggPCBtYXhJdGVtcykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSB2ZG9tLmNuLmxlbmd0aDsgaSA8IG1heEl0ZW1zOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmRvbS5jbi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZyAgIDogJ2EnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xzICAgOiBbJ25lby1vcmctbGluayddLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiAnX2JsYW5rJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNuICAgIDogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWc6ICdpbWcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsczogWyduZW8tb3JnLWF2YXRhciddXG4gICAgICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmRvbS5jbi5mb3JFYWNoKChub2RlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBvcmcgPSBpdGVtc1tpbmRleF0sXG4gICAgICAgICAgICAgICAgICAgIGltZyA9IG5vZGUuY25bMF07XG5cbiAgICAgICAgICAgICAgICBpZiAob3JnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhdmF0YXJVcmwgPSBvcmcuYXZhdGFyVXJsO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhdmF0YXJVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB1cmxTdHIgPSBTdHJpbmcoYXZhdGFyVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdXJsU3RyLnN0YXJ0c1dpdGgoJ2h0dHAnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF2YXRhclVybCA9IGBodHRwczovL2F2YXRhcnMuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3UvJHthdmF0YXJVcmx9P3Y9NCZzPSR7bWUuYXZhdGFyU2l6ZX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdXJsID0gbmV3IFVSTChhdmF0YXJVcmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdzJywgbWUuYXZhdGFyU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXZhdGFyVXJsID0gdXJsLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuaHJlZiAgPSBgaHR0cHM6Ly9naXRodWIuY29tLyR7b3JnLmxvZ2lufWA7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUudGl0bGUgPSBvcmcubmFtZSB8fCBvcmcubG9naW47XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUgPSBudWxsOyAvLyBSZW1vdmUgdmlzaWJpbGl0eTogaGlkZGVuXG5cbiAgICAgICAgICAgICAgICAgICAgaW1nLnNyYyA9IGF2YXRhclVybDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbm9kZS5ocmVmO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbm9kZS50aXRsZTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zdHlsZSA9IHt2aXNpYmlsaXR5OiAnaGlkZGVuJ307XG5cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGltZy5zcmM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBTdGFuZGFyZCBiZWhhdmlvcjogUmVuZGVyIG9ubHkgd2hhdCBleGlzdHNcbiAgICAgICAgICAgIGxldCBuZXdJdGVtcyA9IFtdO1xuXG4gICAgICAgICAgICBpdGVtcy5zbGljZSgwLCBtYXhJdGVtcykuZm9yRWFjaChvcmcgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBhdmF0YXJVcmwgPSBvcmcuYXZhdGFyVXJsO1xuXG4gICAgICAgICAgICAgICAgaWYgKGF2YXRhclVybCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdXJsU3RyID0gU3RyaW5nKGF2YXRhclVybCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdXJsU3RyLnN0YXJ0c1dpdGgoJ2h0dHAnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXZhdGFyVXJsID0gYGh0dHBzOi8vYXZhdGFycy5naXRodWJ1c2VyY29udGVudC5jb20vdS8ke2F2YXRhclVybH0/dj00JnM9JHttZS5hdmF0YXJTaXplfWA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdXJsID0gbmV3IFVSTChhdmF0YXJVcmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3MnLCBtZS5hdmF0YXJTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF2YXRhclVybCA9IHVybC50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBuZXdJdGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdGFnICAgOiAnYScsXG4gICAgICAgICAgICAgICAgICAgIGNscyAgIDogWyduZW8tb3JnLWxpbmsnXSxcbiAgICAgICAgICAgICAgICAgICAgaHJlZiAgOiBgaHR0cHM6Ly9naXRodWIuY29tLyR7b3JnLmxvZ2lufWAsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogJ19ibGFuaycsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlIDogb3JnLm5hbWUgfHwgb3JnLmxvZ2luLFxuICAgICAgICAgICAgICAgICAgICBjbiAgICA6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWc6ICdpbWcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xzOiBbJ25lby1vcmctYXZhdGFyJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICBzcmM6IGF2YXRhclVybFxuICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmRvbS5jbiA9IG5ld0l0ZW1zO1xuICAgICAgICB9XG5cbiAgICAgICAgbWUudXBkYXRlKClcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEdpdEh1Yk9yZ3MpO1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNvbXBvbmVudC5HaXRIdWJVc2VyXG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqL1xuY2xhc3MgR2l0SHViVXNlciBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29tcG9uZW50LkdpdEh1YlVzZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb21wb25lbnQuR2l0SHViVXNlcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaXplIGluIHB4IGZvciB0aGUgYXZhdGFyIGltYWdlIHJlcXVlc3QuXG4gICAgICAgICAqIFJlY29tbWVuZGVkIHRvIHVzZSAyeCB0aGUgZGlzcGxheSBzaXplIGZvciBoaWdoIERQSSBzY3JlZW5zLlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGF2YXRhclNpemU9NjRcbiAgICAgICAgICovXG4gICAgICAgIGF2YXRhclNpemU6IDY0LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGF2YXRhclVybF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgYXZhdGFyVXJsXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWdpdGh1Yi11c2VyJ11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWdpdGh1Yi11c2VyJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gZnVsbE5hbWVfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGZ1bGxOYW1lXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSB1c2VybmFtZV89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgdXNlcm5hbWVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbVxuICAgICAgICAgKi9cbiAgICAgICAgX3Zkb206XG4gICAgICAgIHtjbjogW1xuICAgICAgICAgICAge3RhZzogJ2ltZycsIGNsczogWyduZW8tYXZhdGFyJ119LFxuICAgICAgICAgICAge2NsczogWyduZW8tdXNlci1pbmZvJ10sIGNuOiBbXG4gICAgICAgICAgICAgICAge3RhZzogJ2EnLCAgICBjbHM6IFsnbmVvLXVzZXJuYW1lJ10sIHRhcmdldDogJ19ibGFuayd9LFxuICAgICAgICAgICAgICAgIHt0YWc6ICdzcGFuJywgY2xzOiBbJ25lby1uYW1lJ119XG4gICAgICAgICAgICBdfVxuICAgICAgICBdfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhZnRlclNldEF2YXRhclVybCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGxldCB1cmxTdHIgPSBTdHJpbmcodmFsdWUpO1xuXG4gICAgICAgICAgICBpZiAoIXVybFN0ci5zdGFydHNXaXRoKCdodHRwJykpIHtcbiAgICAgICAgICAgICAgICB1cmxTdHIgPSBgaHR0cHM6Ly9hdmF0YXJzLmdpdGh1YnVzZXJjb250ZW50LmNvbS91LyR7dmFsdWV9P3Y9NCZzPSR7bWUuYXZhdGFyU2l6ZX1gO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgdXJsID0gbmV3IFVSTCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3MnLCBtZS5hdmF0YXJTaXplKTtcbiAgICAgICAgICAgICAgICB1cmxTdHIgPSB1cmwudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUudmRvbS5jblswXS5zcmMgPSB1cmxTdHI7XG4gICAgICAgICAgICBtZS51cGRhdGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIGFmdGVyU2V0RnVsbE5hbWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBtZS52ZG9tLmNuWzFdLmNuWzFdLnRleHQgPSB2YWx1ZTtcbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICovXG4gICAgYWZ0ZXJTZXRVc2VybmFtZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBsaW5rID0gbWUudmRvbS5jblsxXS5jblswXTtcblxuICAgICAgICAgICAgbGluay5ocmVmID0gYGh0dHBzOi8vZ2l0aHViLmNvbS8ke3ZhbHVlfWA7XG4gICAgICAgICAgICBsaW5rLnRleHQgPSB2YWx1ZTtcbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEdpdEh1YlVzZXIpO1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuL0Jhc2UubWpzJztcbmltcG9ydCBOZW9BcnJheSAgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uY29tcG9uZW50Lkljb25cbiAqIEBleHRlbmRzIE5lby5jb21wb25lbnQuQmFzZVxuICovXG5jbGFzcyBJY29uIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb21wb25lbnQuSWNvbidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbXBvbmVudC5JY29uJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2ljb24nXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnaWNvbicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1pY29uJ11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWljb24nXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBjZWxsSWNvbkNsc189bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGNlbGxJY29uQ2xzXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gdGFnPSdpJ1xuICAgICAgICAgKi9cbiAgICAgICAgdGFnOiAnaSdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGNlbGxJY29uQ2xzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfFN0cmluZ1tdfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8U3RyaW5nW118bnVsbH0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhZnRlclNldENlbGxJY29uQ2xzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgY2xzID0gdGhpcy5jbHM7XG5cbiAgICAgICAgTmVvQXJyYXkucmVtb3ZlQWRkKGNscywgb2xkVmFsdWUsIHZhbHVlKTtcblxuICAgICAgICB0aGlzLmNscyA9IGNsc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGNlbGxJY29uQ2xzIGNvbmZpZyBnZXRzIGNoYW5nZWQuIENvbnZlcnRzIHRoZSBzdHJpbmcgaW50byBhbiBhcnJheSBpZiBuZWVkZWQuXG4gICAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd8bnVsbH0gdmFsdWUgICAgVGhlIG5ldyB2YWx1ZSBvZiB0aGUgY2VsbEljb25DbHMgY29uZmlnLlxuICAgICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfG51bGx9IG9sZFZhbHVlIFRoZSBvbGQgdmFsdWUgb2YgdGhlIGNlbGxJY29uQ2xzIGNvbmZpZy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldENlbGxJY29uQ2xzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNwbGl0KCcgJykuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEljb24pO1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuL0Jhc2UubWpzJztcbmltcG9ydCBOZW9BcnJheSAgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uY29tcG9uZW50Lkljb25MaW5rXG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqL1xuY2xhc3MgSWNvbkxpbmsgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbXBvbmVudC5JY29uTGluaydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbXBvbmVudC5JY29uTGluaycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdpY29uLWxpbmsnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnaWNvbi1saW5rJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWljb24tbGluayddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1pY29uLWxpbmsnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBjZWxsSWNvbkNsc189bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGNlbGxJY29uQ2xzXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBsYWJlbF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGxhYmVsXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gdGFnPSdhJ1xuICAgICAgICAgKi9cbiAgICAgICAgdGFnOiAnYScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHRhcmdldF89J19ibGFuaydcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB0YXJnZXRfOiAnX2JsYW5rJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSB1cmxfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB1cmxfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbVxuICAgICAgICAgKi9cbiAgICAgICAgX3Zkb206XG4gICAgICAgIHtjbjogW1xuICAgICAgICAgICAge3RhZzogJ2knLCBjbHM6IFtdfSxcbiAgICAgICAgICAgIHt0YWc6ICdzcGFuJywgY2xzOiBbJ25lby1saW5rLWxhYmVsJ10sIHN0eWxlOiB7dmlzaWJpbGl0eTogJ2hpZGRlbid9fVxuICAgICAgICBdfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgY2VsbEljb25DbHMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8U3RyaW5nW118bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xTdHJpbmdbXXxudWxsfSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIGFmdGVyU2V0Q2VsbEljb25DbHModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIG5vZGUgPSBtZS52ZG9tLmNuWzBdLFxuICAgICAgICAgICAgY2xzICA9IG5vZGUuY2xzIHx8IFtdO1xuXG4gICAgICAgIE5lb0FycmF5LnJlbW92ZUFkZChjbHMsIG9sZFZhbHVlLCB2YWx1ZSk7XG5cbiAgICAgICAgbm9kZS5jbHMgPSBjbHM7XG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBsYWJlbCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICovXG4gICAgYWZ0ZXJTZXRMYWJlbCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgbm9kZSA9IG1lLnZkb20uY25bMV07XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBub2RlLmh0bWwgPSB2YWx1ZTtcbiAgICAgICAgICAgIGRlbGV0ZSBub2RlLnN0eWxlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlLnN0eWxlID0ge3Zpc2liaWxpdHk6ICdoaWRkZW4nfVxuICAgICAgICB9XG5cbiAgICAgICAgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHRhcmdldCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhZnRlclNldFRhcmdldCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VWZG9tUm9vdEtleSgndGFyZ2V0JywgdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB1cmwgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIGFmdGVyU2V0VXJsKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgbWUudmRvbS5ocmVmID0gdmFsdWU7XG4gICAgICAgICAgICBtZS5oaWRkZW4gICAgPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIG1lLnZkb20uaHJlZjtcbiAgICAgICAgICAgIG1lLmhpZGRlbiA9IHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgY2VsbEljb25DbHMgY29uZmlnIGdldHMgY2hhbmdlZC4gQ29udmVydHMgdGhlIHN0cmluZyBpbnRvIGFuIGFycmF5IGlmIG5lZWRlZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ3xudWxsfSB2YWx1ZSAgICBUaGUgbmV3IHZhbHVlIG9mIHRoZSBjZWxsSWNvbkNscyBjb25maWcuXG4gICAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd8bnVsbH0gb2xkVmFsdWUgVGhlIG9sZCB2YWx1ZSBvZiB0aGUgY2VsbEljb25DbHMgY29uZmlnLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0Q2VsbEljb25DbHModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3BsaXQoJyAnKS5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoSWNvbkxpbmspO1xuIiwiaW1wb3J0IEJhc2UgZnJvbSAnLi4vY29tcG9uZW50L0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNvbXBvbmVudC5Qcm9ncmVzc1xuICogQGV4dGVuZHMgTmVvLmNvbXBvbmVudC5CYXNlXG4gKi9cbmNsYXNzIFByb2dyZXNzIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29tcG9uZW50LlByb2dyZXNzJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29tcG9uZW50LlByb2dyZXNzJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3Byb2dyZXNzJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3Byb2dyZXNzJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLXByb2dyZXNzLWxhYmVsJ11cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tcHJvZ3Jlc3MnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBsYWJlbFRleHRfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBsYWJlbFRleHRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBtYXhfPTEwMFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIG1heF86IDEwMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSB2YWx1ZV89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gX3Zkb21cbiAgICAgICAgICovXG4gICAgICAgIF92ZG9tOlxuICAgICAgICB7dGFnOiAnZGl2JywgY2xzOiBbJ25lby1wcm9ncmVzcy13cmFwcGVyJ10sIGNuOiBbXG4gICAgICAgICAgICB7dGFnOiAnbGFiZWwnfSxcbiAgICAgICAgICAgIHt0YWc6ICdwcm9ncmVzcyd9XG4gICAgICAgIF19XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBsYWJlbFxuICAgICAqL1xuICAgIGdldCBsYWJlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmRvbS5jblswXVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHByb2dyZXNzXG4gICAgICovXG4gICAgZ2V0IHByb2dyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZG9tLmNuWzFdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGVuc3VyZVN0YWJsZUlkcygpIHtcbiAgICAgICAgc3VwZXIuZW5zdXJlU3RhYmxlSWRzKCk7XG4gICAgICAgIHRoaXMubGFiZWwuZm9yID0gdGhpcy5pZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbGFiZWxUZXh0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRMYWJlbFRleHQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCB7bGFiZWx9ID0gdGhpcztcblxuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICBsYWJlbC5yZW1vdmVEb20gPSB0cnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgbGFiZWwucmVtb3ZlRG9tXG4gICAgICAgIH1cblxuICAgICAgICBsYWJlbC50ZXh0ID0gdmFsdWU7XG4gICAgICAgIHRoaXMudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1heCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNYXgodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMucHJvZ3Jlc3MubWF4ID0gdmFsdWU7XG4gICAgICAgIHRoaXMudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHZhbHVlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5wcm9ncmVzcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3BlY2lmeSBhIGRpZmZlcmVudCB2ZG9tIHJvb3QgaWYgbmVlZGVkIHRvIGFwcGx5IHRoZSB0b3AgbGV2ZWwgc3R5bGUgYXR0cmlidXRlcyBvbiBhIGRpZmZlcmVudCBsZXZlbC5cbiAgICAgKiBNYWtlIHN1cmUgdG8gdXNlIGdldFZub2RlUm9vdCgpIGFzIHdlbGwsIHRvIGtlZXAgdGhlIHZkb20gJiB2bm9kZSB0cmVlcyBpbiBzeW5jLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBuZXcgdmRvbSByb290XG4gICAgICovXG4gICAgZ2V0VmRvbVJvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZkb20uY25bMV1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IGEgZGlmZmVyZW50IHZub2RlIHJvb3QgaWYgbmVlZGVkIHRvIGFwcGx5IHRoZSB0b3AgbGV2ZWwgc3R5bGUgYXR0cmlidXRlcyBvbiBhIGRpZmZlcmVudCBsZXZlbC5cbiAgICAgKiBNYWtlIHN1cmUgdG8gdXNlIGdldFZkb21Sb290KCkgYXMgd2VsbCwgdG8ga2VlcCB0aGUgdmRvbSAmIHZub2RlIHRyZWVzIGluIHN5bmMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIG5ldyB2bm9kZSByb290XG4gICAgICovXG4gICAgZ2V0Vm5vZGVSb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52bm9kZS5jaGlsZE5vZGVzWzFdXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhQcm9ncmVzcyk7XG4iLCJpbXBvcnQgQ2FudmFzIGZyb20gJy4vQ2FudmFzLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jb21wb25lbnQuU3BhcmtsaW5lXG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkNhbnZhc1xuICovXG5jbGFzcyBTcGFya2xpbmUgZXh0ZW5kcyBDYW52YXMge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbXBvbmVudC5TcGFya2xpbmUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb21wb25lbnQuU3BhcmtsaW5lJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBjbHM9WyduZW8tc3BhcmtsaW5lLWNhbnZhcyddXG4gICAgICAgICAqL1xuICAgICAgICBjbHM6IFsnbmVvLXNwYXJrbGluZS1jYW52YXMnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdFtdfSBkb21MaXN0ZW5lcnNcbiAgICAgICAgICovXG4gICAgICAgIGRvbUxpc3RlbmVyczogW3tcbiAgICAgICAgICAgIG1vdXNlbW92ZSA6IHtmbjogJ29uTW91c2VNb3ZlJywgbG9jYWw6IHRydWV9LFxuICAgICAgICAgICAgbW91c2VsZWF2ZTogJ29uTW91c2VMZWF2ZSdcbiAgICAgICAgfV0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGxpc3RlbmVyc1xuICAgICAgICAgKi9cbiAgICAgICAgbGlzdGVuZXJzOiB7XG4gICAgICAgICAgICByZXNpemU6ICdvblJlc2l6ZSdcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3NwYXJrbGluZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdzcGFya2xpbmUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNsYXNzIG5hbWUgb2YgdGhlIHJlbmRlcmVyIHRvIHVzZSBpbiB0aGUgd29ya2VyLlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHJlbmRlcmVyQ2xhc3NOYW1lPSdOZW8uY2FudmFzLlNwYXJrbGluZSdcbiAgICAgICAgICovXG4gICAgICAgIHJlbmRlcmVyQ2xhc3NOYW1lOiAnTmVvLmNhbnZhcy5TcGFya2xpbmUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGltcG9ydCBwYXRoIGZvciB0aGUgcmVuZGVyZXIgbW9kdWxlLlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHJlbmRlcmVySW1wb3J0UGF0aD0nc3JjL2NhbnZhcy9TcGFya2xpbmUubWpzJ1xuICAgICAgICAgKi9cbiAgICAgICAgcmVuZGVyZXJJbXBvcnRQYXRoOiAnc3JjL2NhbnZhcy9TcGFya2xpbmUubWpzJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnRyb2xzIHRoZSBcIkxpdmluZyBQdWxzZVwiIGFuaW1hdGlvbi5cbiAgICAgICAgICogU2V0IHRvIGBmYWxzZWAgdG8gZGlzYWJsZSB0aGUgYmFja2dyb3VuZCBhbmltYXRpb24uXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHVzZVB1bHNlXz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICB1c2VQdWxzZV86IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdG8gYGZhbHNlYCB0byBkaXNhYmxlIHRoZSBkYXRhIGNoYW5nZSBhbmltYXRpb24uXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHVzZVRyYW5zaXRpb25fPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIHVzZVRyYW5zaXRpb25fOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyW118bnVsbH0gdmFsdWVzXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZXNfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IHdyYXBwZXJDbHM9WyduZW8tc3BhcmtsaW5lLXdyYXBwZXInXVxuICAgICAgICAgKi9cbiAgICAgICAgd3JhcHBlckNsczogWyduZW8tc3BhcmtsaW5lLXdyYXBwZXInXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gX3Zkb21cbiAgICAgICAgICovXG4gICAgICAgIF92ZG9tOiB7XG4gICAgICAgICAgICBjbjogW3tcbiAgICAgICAgICAgICAgICB0YWc6ICdjYW52YXMnXG4gICAgICAgICAgICB9XVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcHVsc2UgY29uZmlndXJhdGlvbiBpbiB0aGUgd29ya2VyIHdoZW4gYHVzZVB1bHNlYCBjaGFuZ2VzLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICovXG4gICAgYWZ0ZXJTZXRVc2VQdWxzZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUub2Zmc2NyZWVuUmVnaXN0ZXJlZCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtZS5yZW5kZXJlcj8udXBkYXRlQ29uZmlnKHtcbiAgICAgICAgICAgICAgICBjYW52YXNJZDogbWUuaWQsXG4gICAgICAgICAgICAgICAgdXNlUHVsc2U6IHZhbHVlXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgdHJhbnNpdGlvbiBjb25maWd1cmF0aW9uIGluIHRoZSB3b3JrZXIgd2hlbiBgdXNlVHJhbnNpdGlvbmAgY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIGFmdGVyU2V0VXNlVHJhbnNpdGlvbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUub2Zmc2NyZWVuUmVnaXN0ZXJlZCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtZS5yZW5kZXJlcj8udXBkYXRlQ29uZmlnKHtcbiAgICAgICAgICAgICAgICBjYW52YXNJZCAgICAgOiBtZS5pZCxcbiAgICAgICAgICAgICAgICB1c2VUcmFuc2l0aW9uOiB2YWx1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdGhlbWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFRoZW1lKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldFRoZW1lKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUub2Zmc2NyZWVuUmVnaXN0ZXJlZCAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgbGV0IHRoZW1lID0gdmFsdWUuaW5jbHVkZXMoJ2RhcmsnKSA/ICdkYXJrJyA6ICdsaWdodCc7XG5cbiAgICAgICAgICAgIG1lLnJlbmRlcmVyPy51cGRhdGVDb25maWcoe1xuICAgICAgICAgICAgICAgIGNhbnZhc0lkOiBtZS5pZCxcbiAgICAgICAgICAgICAgICB0aGVtZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyW118bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcltdfG51bGx9IG9sZFZhbHVlXG4gICAgICovXG4gICAgYWZ0ZXJTZXRWYWx1ZXModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLm9mZnNjcmVlblJlZ2lzdGVyZWQgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIG1lLnJlbmRlcmVyPy51cGRhdGVEYXRhKHtcbiAgICAgICAgICAgICAgICBjYW52YXNJZDogbWUuaWQsXG4gICAgICAgICAgICAgICAgdmFsdWVzICA6IHZhbHVlXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsuLi4qfSBhcmdzXG4gICAgICovXG4gICAgZGVzdHJveSguLi5hcmdzKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLm9mZnNjcmVlblJlZ2lzdGVyZWQpIHtcbiAgICAgICAgICAgIG1lLnJlbmRlcmVyPy51bnJlZ2lzdGVyKHtcbiAgICAgICAgICAgICAgICBjYW52YXNJZDogbWUuaWRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBzdXBlci5kZXN0cm95KC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtb3VudGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIGFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGF3YWl0IG1lLnJlYWR5KClcbiAgICAgICAgfSBlbHNlIGlmIChtZS5vZmZzY3JlZW5SZWdpc3RlcmVkKSB7XG4gICAgICAgICAgICBtZS5yZW5kZXJlcj8udW5yZWdpc3Rlcih7XG4gICAgICAgICAgICAgICAgY2FudmFzSWQ6IG1lLmlkXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIGFzeW5jIGFmdGVyU2V0T2Zmc2NyZWVuUmVnaXN0ZXJlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHt2YWx1ZXN9ID0gbWU7XG5cbiAgICAgICAgICAgIGF3YWl0IG1lLnJlbmRlcmVyPy5yZWdpc3Rlcih7XG4gICAgICAgICAgICAgICAgY2FudmFzSWQgICAgICAgIDogbWUuaWQsXG4gICAgICAgICAgICAgICAgZGV2aWNlUGl4ZWxSYXRpbzogTmVvLmNvbmZpZy5kZXZpY2VQaXhlbFJhdGlvLFxuICAgICAgICAgICAgICAgIHRoZW1lICAgICAgICAgICA6IG1lLnRoZW1lPy5pbmNsdWRlcygnZGFyaycpID8gJ2RhcmsnIDogJ2xpZ2h0JyxcbiAgICAgICAgICAgICAgICB1c2VQdWxzZSAgICAgICAgOiBtZS51c2VQdWxzZSxcbiAgICAgICAgICAgICAgICB1c2VUcmFuc2l0aW9uICAgOiBtZS51c2VUcmFuc2l0aW9uLFxuICAgICAgICAgICAgICAgIHdpbmRvd0lkICAgICAgICA6IG1lLndpbmRvd0lkXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICAgICAgICAgIG1lLnJlbmRlcmVyPy51cGRhdGVEYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzSWQ6IG1lLmlkLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJbml0aWFsIHNpemUgc3luY1xuICAgICAgICAgICAgbGV0IHJlY3QgPSBhd2FpdCBtZS5nZXREb21SZWN0KG1lLmlkKTtcbiAgICAgICAgICAgIGlmIChyZWN0KSB7XG4gICAgICAgICAgICAgICAgbWUucmVuZGVyZXI/LnVwZGF0ZVNpemUoe1xuICAgICAgICAgICAgICAgICAgICBjYW52YXNJZDogbWUuaWQsXG4gICAgICAgICAgICAgICAgICAgIGRldmljZVBpeGVsUmF0aW86IE5lby5jb25maWcuZGV2aWNlUGl4ZWxSYXRpbyxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ICA6IHJlY3QuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB3aWR0aCAgIDogcmVjdC53aWR0aFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgZ2V0IHJlbmRlcmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlckNsYXNzTmFtZSA/IE5lby5ucyh0aGlzLnJlbmRlcmVyQ2xhc3NOYW1lKSA6IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldFZkb21Sb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZG9tLmNuWzBdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRWbm9kZVJvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZub2RlLmNoaWxkTm9kZXNbMF1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBpbml0QXN5bmMoKSB7XG4gICAgICAgIGF3YWl0IHN1cGVyLmluaXRBc3luYygpO1xuXG4gICAgICAgIGlmICh0aGlzLnJlbmRlcmVySW1wb3J0UGF0aCkge1xuICAgICAgICAgICAgIC8vIEVuc3VyZSBDYW52YXMgV29ya2VyIGlzIHJ1bm5pbmdcbiAgICAgICAgICAgIGF3YWl0IE5lby53b3JrZXIuTWFuYWdlci5zdGFydFdvcmtlcih7bmFtZTogJ2NhbnZhcyd9KTtcblxuICAgICAgICAgICAgLy8gV2FpdCBmb3IgdGhlIENhbnZhcyBXb3JrZXIgcmVtb3RlIHRvIGJlIGF2YWlsYWJsZS5cbiAgICAgICAgICAgIGxldCBpID0gMDtcblxuICAgICAgICAgICAgd2hpbGUgKCFOZW8ubnMoJ05lby53b3JrZXIuQ2FudmFzLmxvYWRNb2R1bGUnKSAmJiBpIDwgNDApIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnRpbWVvdXQoNTApO1xuICAgICAgICAgICAgICAgIGkrK1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoTmVvLm5zKCdOZW8ud29ya2VyLkNhbnZhcy5sb2FkTW9kdWxlJykpIHtcbiAgICAgICAgICAgICAgICAvLyBMb2FkIHRoZSBzcGVjaWZpYyByZW5kZXJlciBtb2R1bGUgZm9yIHRoaXMgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgYXdhaXQgTmVvLndvcmtlci5DYW52YXMubG9hZE1vZHVsZSh7XG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IHRoaXMucmVuZGVyZXJJbXBvcnRQYXRoXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignTmVvLmNvbXBvbmVudC5TcGFya2xpbmU6IENhbnZhcyBXb3JrZXIgZmFpbGVkIHRvIHJlZ2lzdGVyIHJlbW90ZSBtZXRob2RzLicpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uTW91c2VMZWF2ZShkYXRhKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXI/Lm9uTW91c2VMZWF2ZSh7XG4gICAgICAgICAgICBjYW52YXNJZDogdGhpcy5pZFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Nb3VzZU1vdmUoZGF0YSkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyPy5vbk1vdXNlTW92ZSh7XG4gICAgICAgICAgICBjYW52YXNJZDogdGhpcy5pZCxcbiAgICAgICAgICAgIHggICAgICAgOiBkYXRhLm9mZnNldFgsXG4gICAgICAgICAgICB5ICAgICAgIDogZGF0YS5vZmZzZXRZXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvblJlc2l6ZShkYXRhKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXI/LnVwZGF0ZVNpemUoe1xuICAgICAgICAgICAgY2FudmFzSWQgICAgICAgIDogdGhpcy5pZCxcbiAgICAgICAgICAgIGRldmljZVBpeGVsUmF0aW86IE5lby5jb25maWcuZGV2aWNlUGl4ZWxSYXRpbyxcbiAgICAgICAgICAgIGhlaWdodCAgICAgICAgICA6IGRhdGEuY29udGVudFJlY3QuaGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGggICAgICAgICAgIDogZGF0YS5jb250ZW50UmVjdC53aWR0aFxuICAgICAgICB9KVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoU3BhcmtsaW5lKTtcbiIsImltcG9ydCBDbGFzc1N5c3RlbVV0aWwgZnJvbSAnLi4vdXRpbC9DbGFzc1N5c3RlbS5tanMnO1xuaW1wb3J0IENvbXBvbmVudCAgICAgICBmcm9tICcuLi9jb21wb25lbnQvQmFzZS5tanMnO1xuaW1wb3J0IENvbGxlY3Rpb24gICAgICBmcm9tICcuLi9jb2xsZWN0aW9uL0Jhc2UubWpzJztcbmltcG9ydCBSb3cgICAgICAgICAgICAgZnJvbSAnLi9Sb3cubWpzJztcbmltcG9ydCBSb3dNb2RlbCAgICAgICAgZnJvbSAnLi4vc2VsZWN0aW9uL2dyaWQvUm93TW9kZWwubWpzJztcbmltcG9ydCBWRG9tVXRpbCAgICAgICAgZnJvbSAnLi4vdXRpbC9WRG9tLm1qcyc7XG5cbi8qKlxuICogQHN1bW1hcnkgTWFuYWdlcyB0aGUgc2Nyb2xsYWJsZSB2aWV3cG9ydCBhbmQgcm93IHJlbmRlcmluZyBmb3IgdGhlIEdyaWQuXG4gKlxuICogYE5lby5ncmlkLkJvZHlgIGlzIHRoZSBlbmdpbmUgYmVoaW5kIHRoZSBHcmlkJ3MgdmlydHVhbCBzY3JvbGxpbmcuIEl0IGV4dGVuZHMge0BsaW5rIE5lby5jb21wb25lbnQuQmFzZX0gcmF0aGVyIHRoYW5cbiAqIGBOZW8uY29udGFpbmVyLkJhc2VgIHRvIGVuZm9yY2UgYSBzdHJpY3QgKipSb3cgUG9vbGluZyoqIGFyY2hpdGVjdHVyZS5cbiAqXG4gKiAqKldoeSBDb21wb25lbnQgYW5kIG5vdCBDb250YWluZXI/KipcbiAqIFNpbmNlIHRoZSBHcmlkIHVzZXMgYSAqKkZpeGVkLURPTS1PcmRlcioqIHN0cmF0ZWd5LCB0aGUgc3RhbmRhcmQgQ29udGFpbmVyIEFQSXMgKGBhZGRgLCBgcmVtb3ZlYCwgYG1vdmVgKSBhcmVcbiAqIGZ1bmRhbWVudGFsbHkgaW5jb21wYXRpYmxlIHdpdGggdGhlIHJvdyBwb29saW5nIGxvZ2ljLiBCeSBleHRlbmRpbmcgYENvbXBvbmVudGAsIHdlIGhpZGUgdGhlc2UgdW5zYWZlIG1ldGhvZHNcbiAqIHdoaWxlIG1hbnVhbGx5IGltcGxlbWVudGluZyB0aGUgbmVjZXNzYXJ5IGNvbmZpZyBwcm9wYWdhdGlvbiAodGhlbWUsIGFwcE5hbWUsIHdpbmRvd0lkKSB0byB0aGUgbWFuYWdlZCBSb3cgaW5zdGFuY2VzLlxuICpcbiAqICoqUm93IFBvb2xpbmc6KipcbiAqIEluc3RlYWQgb2YgY3JlYXRpbmcgYSBjb21wb25lbnQgZm9yIGV2ZXJ5IHJlY29yZCBpbiB0aGUgc3RvcmUsIGl0IHVzZXMgYSBwb29sOlxuICpcbiAqIDEuICBJdCBjcmVhdGVzIGEgZml4ZWQgcG9vbCBvZiB7QGxpbmsgTmVvLmdyaWQuUm93fSBjb21wb25lbnRzIGJhc2VkIG9uIHRoZSB2aXNpYmxlIGhlaWdodCArIGEgYnVmZmVyLlxuICogMi4gIEFzIHRoZSB1c2VyIHNjcm9sbHMsIHRoZXNlIFJvdyBpbnN0YW5jZXMgYXJlIHJlY3ljbGVkLiBUaGVpciBgcmVjb3JkYCBhbmQgYHJvd0luZGV4YCBjb25maWdzIGFyZSB1cGRhdGVkIHZpYVxuICogICAgIHtAbGluayBOZW8uZ3JpZC5Sb3cjdXBkYXRlQ29udGVudH0sIHRyaWdnZXJpbmcgYSBsaWdodHdlaWdodCBWRE9NIHVwZGF0ZS5cbiAqIDMuICBJdCBjYWxjdWxhdGVzIHRoZSBgbW91bnRlZFJvd3NgIChyZW5kZXJlZCBET00gbm9kZXMpIGFuZCBgdmlzaWJsZVJvd3NgICh2aWV3cG9ydCBpbnRlcnNlY3Rpb24pIHRvIG9wdGltaXplIHJlbmRlcmluZy5cbiAqXG4gKiBUaGlzIGFyY2hpdGVjdHVyZSBlbnN1cmVzIE8oMSkgcGVyZm9ybWFuY2UgZm9yIHJlY29yZCB1cGRhdGVzIGFuZCBjb25zdGFudCBtZW1vcnkgdXNhZ2UgcmVnYXJkbGVzcyBvZiBkYXRhc2V0IHNpemUuXG4gKlxuICogKipGaXhlZC1ET00tT3JkZXIgU3RyYXRlZ3k6KipcbiAqIFRvIG1heGltaXplIHNjcm9sbGluZyBwZXJmb3JtYW5jZSwgYEJvZHlgIHVzZXMgYSBcInJlY3ljbGluZyBpbiBwbGFjZVwiIHN0cmF0ZWd5LiBUaGUgUm93IGNvbXBvbmVudHMgaW4gdGhlIGBpdGVtc2BcbiAqIGFycmF5IGFuZCB0aGUgY29ycmVzcG9uZGluZyBET00gbm9kZXMgaW4gYHZkb20uY25gICoqbmV2ZXIgY2hhbmdlIHRoZWlyIG9yZGVyKiouXG4gKlxuICogLSBXaGVuIGEgcm93IHNjcm9sbHMgb2ZmIHRoZSB0b3AsIGl0IHJlbWFpbnMgdGhlIFwiZmlyc3RcIiBjaGlsZCBpbiB0aGUgRE9NIGJ1dCBpcyB2aXN1YWxseSByZXBvc2l0aW9uZWRcbiAqICAgdG8gdGhlIGJvdHRvbSB2aWEgQ1NTIHRyYW5zZm9ybSAoYHRyYW5zbGF0ZTNkYCkgYW5kIHVwZGF0ZWQgd2l0aCBuZXcgcmVjb3JkIGNvbnRlbnQuXG4gKiAtIFRoaXMgYXBwcm9hY2ggZWxpbWluYXRlcyBgbW92ZU5vZGVgLCBgaW5zZXJ0Tm9kZWAsIGFuZCBgcmVtb3ZlTm9kZWAgb3BlcmF0aW9ucywgcmVzdWx0aW5nIGluXG4gKiAgIHplcm8gbGF5b3V0IHRocmFzaGluZyBkdXJpbmcgc2Nyb2xsaW5nLlxuICpcbiAqIEBjbGFzcyBOZW8uZ3JpZC5Cb2R5XG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqIEBzZWUgTmVvLmdyaWQuUm93XG4gKiBAc2VlIE5lby5ncmlkLkNvbnRhaW5lclxuICovXG5jbGFzcyBHcmlkQm9keSBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZ3JpZC5Cb2R5J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZ3JpZC5Cb2R5JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2dyaWQtYm9keSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdncmlkLWJvZHknLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYW5pbWF0ZWRSb3dTb3J0aW5nXz1mYWxzZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGFuaW1hdGVkUm93U29ydGluZ186IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgZmxhZy4gR2V0cyBjYWxjdWxhdGVkIHdoZW4gbW91bnRpbmcgdGhlIGdyaWQuQ29udGFpbmVyXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gYXZhaWxhYmxlSGVpZ2h0Xz0wXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXZhaWxhYmxlSGVpZ2h0XzogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGZsYWcuIEdldHMgY2FsY3VsYXRlZCB3aGVuIGNoYW5naW5nIHRoZSBhdmFpbGFibGVIZWlnaHQgY29uZmlnXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gYXZhaWxhYmxlUm93c189MFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGF2YWlsYWJsZVJvd3NfOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgZmxhZy4gR2V0cyBjYWxjdWxhdGVkIGFmdGVyIG1vdW50aW5nIGdyaWQuQm9keSByb3dzXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gYXZhaWxhYmxlV2lkdGhfPTBcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBhdmFpbGFibGVXaWR0aF86IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1ncmlkLWJvZHknXVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1ncmlkLWJvZHknXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgY29sdW1ucyAoY2VsbHMpIHRvIHBhaW50IGJlZm9yZSB0aGUgZmlyc3QgYW5kIGFmdGVyIHRoZSBsYXN0IHZpc2libGUgY29sdW1uLFxuICAgICAgICAgKiB0byBlbmhhbmNlIHRoZSBzY3JvbGxpbmcgcGVyZm9ybWFuY2VcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBidWZmZXJDb2x1bW5SYW5nZV89MFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGJ1ZmZlckNvbHVtblJhbmdlXzogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2Ygcm93cyB0byBwYWludCBiZWZvcmUgdGhlIGZpcnN0IGFuZCBhZnRlciB0aGUgbGFzdCB2aXNpYmxlIHJvdyxcbiAgICAgICAgICogdG8gZW5oYW5jZSB0aGUgc2Nyb2xsaW5nIHBlcmZvcm1hbmNlXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gYnVmZmVyUm93UmFuZ2VfPTNcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBidWZmZXJSb3dSYW5nZV86IDMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcG9vbCBzaXplIGZvciByZWN5Y2xhYmxlIGNlbGxzLlxuICAgICAgICAgKiBBdXRvLWNhbGN1bGF0ZWQgYmFzZWQgb24gbW91bnRlZCBjb2x1bW5zIHJhbmdlLlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGNlbGxQb29sU2l6ZV89MjBcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGNlbGxQb29sU2l6ZV86IDIwLFxuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lIHdoaWNoIG1vZGVsIGZpZWxkIGNvbnRhaW5zIHRoZSB2YWx1ZSBvZiBjb2xzcGFuIGRlZmluaXRpb25zXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY29sc3BhbkZpZWxkPSdjb2xzcGFuJ1xuICAgICAgICAgKi9cbiAgICAgICAgY29sc3BhbkZpZWxkOiAnY29sc3BhbicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBmbGFnLiBHZXRzIGNhbGN1bGF0ZWQgYWZ0ZXIgbW91bnRpbmcgZ3JpZC5Cb2R5IHJvd3NcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBjb250YWluZXJXaWR0aF89MFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGNvbnRhaW5lcldpZHRoXzogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb2xsZWN0aW9uLkJhc2V8bnVsbH0gY29sdW1uUG9zaXRpb25zXz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBjb2x1bW5Qb3NpdGlvbnNfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaGlnaGxpZ2h0TW9kaWZpZWRDZWxsc189ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBoaWdobGlnaHRNb2RpZmllZENlbGxzXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc1Njcm9sbGluZ189ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBpc1Njcm9sbGluZ186IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkaXRpb25hbCB1c2VkIGtleXMgZm9yIHRoZSBzZWxlY3Rpb24gbW9kZWxcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBrZXlzXG4gICAgICAgICAqL1xuICAgICAgICBrZXlzOiB7fSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3JlcyB0aGUgaW5kZXhlcyBvZiB0aGUgZmlyc3QgJiBsYXN0IG1vdW50ZWQgY29sdW1ucywgaW5jbHVkaW5nIGJ1ZmZlckNvbHVtblJhbmdlXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcltdfSBtb3VudGVkQ29sdW1uc189WzAsMF1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIG1vdW50ZWRDb2x1bW5zXzogWzAsIDBdLFxuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcmVzIHRoZSBpbmRleGVzIG9mIHRoZSBmaXJzdCAmIGxhc3QgbW91bnRlZCByb3dzLCBpbmNsdWRpbmcgYnVmZmVyUm93UmFuZ2VcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyW119IG1vdW50ZWRSb3dzPVswLDBdXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG1vdW50ZWRSb3dzOiBbMCwgMF0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPcHRpb25hbCBjb25maWcgdmFsdWVzIGZvciBOZW8uZ3JpZC5wbHVnaW4uQW5pbWF0ZVJvd3NcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBwbHVnaW5BbmltYXRlUm93c0NvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBwbHVnaW5BbmltYXRlUm93c0NvbmZpZzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gcm9sZT0ncm93Z3JvdXAnXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgcm9sZTogJ3Jvd2dyb3VwJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE51bWJlciBpbiBweFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHJvd0hlaWdodF89MFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHJvd0hlaWdodF86IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHNjcm9sbExlZnRfPTBcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHNjcm9sbExlZnRfOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBzY3JvbGxUb3BfPTBcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHNjcm9sbFRvcF86IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uc2VsZWN0aW9uLk1vZGVsfSBzZWxlY3Rpb25Nb2RlbF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHNlbGVjdGlvbk1vZGVsXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gc2VsZWN0ZWRSZWNvcmRGaWVsZD0nYW5ub3RhdGlvbnMuc2VsZWN0ZWQnXG4gICAgICAgICAqL1xuICAgICAgICBzZWxlY3RlZFJlY29yZEZpZWxkOiAnYW5ub3RhdGlvbnMuc2VsZWN0ZWQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBzdGFydEluZGV4Xz0wXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhcnRJbmRleF86IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZGF0YS5TdG9yZXxudWxsfSBzdG9yZV89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHN0b3JlXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3JlcyB0aGUgaW5kZXhlcyBvZiB0aGUgZmlyc3QgJiBsYXN0IHBhaW50ZWQgY29sdW1uc1xuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJbXX0gdmlzaWJsZUNvbHVtbnM9WzAsMF1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdmlzaWJsZUNvbHVtbnM6IFswLCAwXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3JlcyB0aGUgaW5kZXhlcyBvZiB0aGUgZmlyc3QgJiBsYXN0IHZpc2libGUgcm93cywgZXhjbHVkaW5nIGJ1ZmZlclJvd1JhbmdlXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcltdfSB2aXNpYmxlUm93cz1bMCwwXVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB2aXNpYmxlUm93czogWzAsIDBdLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IHdyYXBwZXJDbHM9WyduZW8tZ3JpZC1ib2R5LXdyYXBwZXInXVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHdyYXBwZXJDbHM6IFsnbmVvLWdyaWQtYm9keS13cmFwcGVyJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB1c2VSb3dSZWNvcmRJZHM9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgdXNlUm93UmVjb3JkSWRzOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gdXNlSW50ZXJuYWxJZD10cnVlXG4gICAgICAgICAqL1xuICAgICAgICB1c2VJbnRlcm5hbElkOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbVxuICAgICAgICAgKi9cbiAgICAgICAgX3Zkb206XG4gICAgICAgIHt0YWJJbmRleDogJy0xJywgY246IFtcbiAgICAgICAgICAgIHtjbjogW119XG4gICAgICAgIF19XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgZmxhZyB0byBhZG9wdCB0byBzdG9yZS5hZGQoKSBwYXNzaW5nIGFuIGluaXRpYWwgY2h1bmsuXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSAjaW5pdGlhbENodW5rU2l6ZT0wXG4gICAgICovXG4gICAgI2luaXRpYWxDaHVua1NpemUgPSAwXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgZmxhZyB0byBhZG9wdCB0byBzdG9yZS5hZGQoKSBwYXNzaW5nIGFuIGluaXRpYWwgY2h1bmsuXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSAjaW5pdGlhbENodW5rU2l6ZT0wXG4gICAgICovXG4gICAgI2luaXRpYWxUb3RhbFNpemUgPSAwXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgY2FjaGUgZm9yIHRoZSBsYXN0IG1vdW50ZWRDb2x1bW5zIHN0YXRlLlxuICAgICAqIFVzZWQgdG8gZGV0ZWN0IGhvcml6b250YWwgc2Nyb2xsaW5nL3Jlc2l6aW5nIHRvIGZvcmNlIHJvdyB1cGRhdGVzLlxuICAgICAqIEBtZW1iZXIge051bWJlcltdfG51bGx9ICNsYXN0TW91bnRlZENvbHVtbnM9bnVsbFxuICAgICAqL1xuICAgICNsYXN0TW91bnRlZENvbHVtbnMgPSBudWxsXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0W119IGl0ZW1zPVtdXG4gICAgICovXG4gICAgaXRlbXMgPSBbXVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IHNlbGVjdGVkQ2VsbHNcbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0ZWRDZWxscygpIHtcbiAgICAgICAgbGV0IHtzZWxlY3Rpb25Nb2RlbH0gPSB0aGlzO1xuXG4gICAgICAgIGlmIChzZWxlY3Rpb25Nb2RlbC5udHlwZT8uaW5jbHVkZXMoJ2NlbGwnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGlvbk1vZGVsLml0ZW1zXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW11cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gc2VsZWN0ZWRSb3dzXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGVkUm93cygpIHtcbiAgICAgICAgbGV0IHtzZWxlY3Rpb25Nb2RlbH0gPSB0aGlzO1xuXG4gICAgICAgIGlmIChzZWxlY3Rpb25Nb2RlbC5udHlwZT8uaW5jbHVkZXMoJ3JvdycpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0aW9uTW9kZWwuc2VsZWN0ZWRSb3dzXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW11cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmFkZERvbUxpc3RlbmVycyhbe1xuICAgICAgICAgICAgY2xpY2sgICA6IG1lLm9uQ2VsbENsaWNrLFxuICAgICAgICAgICAgZGJsY2xpY2s6IG1lLm9uQ2VsbERvdWJsZUNsaWNrLFxuICAgICAgICAgICAgZGVsZWdhdGU6ICcubmVvLWdyaWQtY2VsbCcsXG4gICAgICAgICAgICBzY29wZSAgIDogbWVcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgY2xpY2sgICA6IG1lLm9uUm93Q2xpY2ssXG4gICAgICAgICAgICBkYmxjbGljazogbWUub25Sb3dEb3VibGVDbGljayxcbiAgICAgICAgICAgIGRlbGVnYXRlOiAnLm5lby1ncmlkLXJvdycsXG4gICAgICAgICAgICBzY29wZSAgIDogbWVcbiAgICAgICAgfV0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBhbmltYXRlZFJvd1NvcnRpbmcgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRBbmltYXRlZFJvd1NvcnRpbmcodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiAhdGhpcy5nZXRQbHVnaW4oJ2dyaWQtYW5pbWF0ZS1yb3dzJykpIHtcbiAgICAgICAgICAgIGltcG9ydCgnLi9wbHVnaW4vQW5pbWF0ZVJvd3MubWpzJykudGhlbihtb2R1bGUgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2lucyA9IG1lLnBsdWdpbnMgfHwgW107XG5cbiAgICAgICAgICAgICAgICBwbHVnaW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGU6IG1vZHVsZS5kZWZhdWx0LFxuICAgICAgICAgICAgICAgICAgICAuLi5tZS5wbHVnaW5BbmltYXRlUm93c0NvbmZpZ1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgbWUucGx1Z2lucyA9IHBsdWdpbnNcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGFwcE5hbWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEFwcE5hbWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRBcHBOYW1lKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbWUuaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtZS5pdGVtc1tpXS5hcHBOYW1lID0gdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgYXZhaWxhYmxlSGVpZ2h0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEF2YWlsYWJsZUhlaWdodCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID4gMCkge1xuICAgICAgICAgICAgdGhpcy5hdmFpbGFibGVSb3dzID0gTWF0aC5jZWlsKHZhbHVlIC8gdGhpcy5yb3dIZWlnaHQpIC0gMVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBhdmFpbGFibGVSb3dzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEF2YWlsYWJsZVJvd3ModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHZhbHVlID4gMCAmJiB0aGlzLmNyZWF0ZVZpZXdEYXRhKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGF2YWlsYWJsZVdpZHRoIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEF2YWlsYWJsZVdpZHRoKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPiAwKSB7XG4gICAgICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgICAgICBtZS52ZG9tLndpZHRoID0gdmFsdWUgKyAncHgnO1xuICAgICAgICAgICAgbWUudmRvbS5jblswXS53aWR0aCA9IHZhbHVlICsgJ3B4JztcbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGJ1ZmZlckNvbHVtblJhbmdlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEJ1ZmZlckNvbHVtblJhbmdlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5za2lwQ3JlYXRlVmlld0RhdGEgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVNb3VudGVkQW5kVmlzaWJsZUNvbHVtbnModHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnNraXBDcmVhdGVWaWV3RGF0YSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVWaWV3RGF0YSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGJ1ZmZlclJvd1JhbmdlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEJ1ZmZlclJvd1JhbmdlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSBNYXRoLmZsb29yKHRoaXMuc2Nyb2xsVG9wIC8gdGhpcy5yb3dIZWlnaHQpO1xuXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5zdGFydEluZGV4IC0gY3VycmVudCkgPj0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNraXBDcmVhdGVWaWV3RGF0YSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydEluZGV4ID0gY3VycmVudDtcbiAgICAgICAgICAgICAgICB0aGlzLnNraXBDcmVhdGVWaWV3RGF0YSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVZpZXdEYXRhKGZhbHNlLCB0cnVlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBjb250YWluZXJXaWR0aCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRDb250YWluZXJXaWR0aCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPiAwICYmIHRoaXMudXBkYXRlTW91bnRlZEFuZFZpc2libGVDb2x1bW5zKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGlzU2Nyb2xsaW5nIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldElzU2Nyb2xsaW5nKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnRvZ2dsZUNscygnbmVvLWlzLXNjcm9sbGluZycsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5maXJlKCdpc1Njcm9sbGluZ0NoYW5nZScsIHt2YWx1ZX0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtb3VudGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBpID0gMCwgbGVuID0gdGhpcy5pdGVtcy5sZW5ndGgsIGl0ZW07XG4gICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IHRoaXMuaXRlbXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtLnZkb20ucmVtb3ZlRG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0ubW91bnRlZCA9IHZhbHVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtb3VudGVkQ29sdW1ucyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TW91bnRlZENvbHVtbnModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlICYmIHRoaXMuY3JlYXRlVmlld0RhdGEoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcm93SGVpZ2h0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFJvd0hlaWdodCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPiAwICYmIHRoaXMudXBkYXRlU2Nyb2xsSGVpZ2h0KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNjcm9sbExlZnQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U2Nyb2xsTGVmdCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVNb3VudGVkQW5kVmlzaWJsZUNvbHVtbnMoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc2Nyb2xsVG9wIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNjcm9sbFRvcCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2J1ZmZlclJvd1JhbmdlfSA9IG1lLFxuICAgICAgICAgICAgbmV3U3RhcnRJbmRleCAgICA9IE1hdGguZmxvb3IodmFsdWUgLyBtZS5yb3dIZWlnaHQpO1xuXG4gICAgICAgIGlmIChNYXRoLmFicyhtZS5zdGFydEluZGV4IC0gbmV3U3RhcnRJbmRleCkgPj0gYnVmZmVyUm93UmFuZ2UpIHtcbiAgICAgICAgICAgIG1lLnN0YXJ0SW5kZXggPSBuZXdTdGFydEluZGV4XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS52aXNpYmxlUm93c1swXSA9IG5ld1N0YXJ0SW5kZXg7XG4gICAgICAgICAgICBtZS52aXNpYmxlUm93c1sxXSA9IG5ld1N0YXJ0SW5kZXggKyBtZS5hdmFpbGFibGVSb3dzXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNlbGVjdGlvbk1vZGVsIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TmVvLnNlbGVjdGlvbi5Nb2RlbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5zZWxlY3Rpb24uTW9kZWx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U2VsZWN0aW9uTW9kZWwodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMudm5vZGVJbml0aWFsaXplZCAmJiB2YWx1ZS5yZWdpc3Rlcih0aGlzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc3RhcnRJbmRleCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTdGFydEluZGV4KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuY3JlYXRlVmlld0RhdGEoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc3RvcmUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U3RvcmUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgbGlzdGVuZXJzID0ge1xuICAgICAgICAgICAgICAgIGZpbHRlciAgICAgIDogbWUub25TdG9yZUZpbHRlcixcbiAgICAgICAgICAgICAgICBsb2FkICAgICAgICA6IG1lLm9uU3RvcmVMb2FkLFxuICAgICAgICAgICAgICAgIHJlY29yZENoYW5nZTogbWUub25TdG9yZVJlY29yZENoYW5nZSxcbiAgICAgICAgICAgICAgICBzY29wZSAgICAgICA6IG1lXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIG9sZFZhbHVlPy51bihsaXN0ZW5lcnMpO1xuICAgICAgICB2YWx1ZSAgID8ub24obGlzdGVuZXJzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHRoZW1lIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRUaGVtZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBzdXBlci5hZnRlclNldFRoZW1lKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbWUuaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtZS5pdGVtc1tpXS50aGVtZSA9IHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHdpbmRvd0lkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRXaW5kb3dJZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBzdXBlci5hZnRlclNldFdpbmRvd0lkKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbWUuaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtZS5pdGVtc1tpXS53aW5kb3dJZCA9IHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGNvbHVtblBvc2l0aW9ucyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlR2V0Q29sdW1uUG9zaXRpb25zKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbHVtblBvc2l0aW9ucyA9IHZhbHVlID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgbW9kdWxlICAgICA6IENvbGxlY3Rpb24sXG4gICAgICAgICAgICAgICAga2V5UHJvcGVydHk6ICdkYXRhRmllbGQnXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgc2VsZWN0aW9uTW9kZWwgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge05lby5zZWxlY3Rpb24uTW9kZWx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uc2VsZWN0aW9uLk1vZGVsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRTZWxlY3Rpb25Nb2RlbCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWU/LmRlc3Ryb3koKTtcblxuICAgICAgICByZXR1cm4gQ2xhc3NTeXN0ZW1VdGlsLmJlZm9yZVNldEluc3RhbmNlKHZhbHVlLCBSb3dNb2RlbClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBvciBleHBhbmRzIHRoZSBwb29sIG9mIGBOZW8uZ3JpZC5Sb3dgIGluc3RhbmNlcy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGNhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiByb3dzIG5lZWRlZCB0byBjb3ZlciB0aGUgdmlld3BvcnQgcGx1cyB0aGUgYnVmZmVyIHJhbmdlLlxuICAgICAqIElmIHRoZSBjdXJyZW50IG51bWJlciBvZiBjaGlsZCBpdGVtcyAoUm93cykgaXMgbGVzcyB0aGFuIHJlcXVpcmVkLCBpdCBjcmVhdGVzIG5ldyBpbnN0YW5jZXNcbiAgICAgKiBhbmQgYWRkcyB0aGVtIHRvIHRoZSBjb250YWluZXIuIFRoaXMgZW5zdXJlcyB3ZSBoYXZlIGVub3VnaCBcInBoeXNpY2FsXCIgcm93cyB0byByZWN5Y2xlIGR1cmluZyBzY3JvbGxpbmcuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY3JlYXRlUm93UG9vbCgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgbmVlZGVkICA9IG1lLmF2YWlsYWJsZVJvd3MgKyAyICogbWUuYnVmZmVyUm93UmFuZ2UsXG4gICAgICAgICAgICBjdXJyZW50ID0gbWUuaXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgZGVsdGEgICA9IG5lZWRlZCAtIGN1cnJlbnQsXG4gICAgICAgICAgICBuZXdSb3dzID0gW10sXG4gICAgICAgICAgICBjb25maWcsIGk7XG5cbiAgICAgICAgaWYgKGRlbHRhID4gMCkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGRlbHRhOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25maWcgPSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZSAgICAgICA6IFJvdyxcbiAgICAgICAgICAgICAgICAgICAgYXBwTmFtZSAgICAgIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZ3JpZENvbnRhaW5lcjogbWUucGFyZW50LFxuICAgICAgICAgICAgICAgICAgICBpZCAgICAgICAgICAgOiBtZS5nZXRSb3dJZChjdXJyZW50ICsgaSksXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudElkICAgICA6IG1lLmlkLFxuICAgICAgICAgICAgICAgICAgICByZWNvcmQgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICByb3dJbmRleCAgICAgOiAtMSxcbiAgICAgICAgICAgICAgICAgICAgdGhlbWUgICAgICAgIDogbWUudGhlbWUsXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0lkICAgICA6IG1lLndpbmRvd0lkXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIG5ld1Jvd3MucHVzaChOZW8uY3JlYXRlKGNvbmZpZykpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZS5pdGVtcy5wdXNoKC4uLm5ld1Jvd3MpXG4gICAgICAgIH0gZWxzZSBpZiAoZGVsdGEgPCAwKSB7XG4gICAgICAgICAgICAvLyBTZWxmLUhlYWxpbmc6IERlc3Ryb3kgZXhjZXNzIHJvd3MgdG8gZnJlZSBtZW1vcnkgYW5kIFZET00gb3ZlcmhlYWQuXG4gICAgICAgICAgICAvLyBUaGlzIHJlc3RvcmVzIHBlcmZvcm1hbmNlIGlmIHRoZSBidWZmZXIgaXMgcmVkdWNlZCBhZnRlciBiZWluZyBsYXJnZS5cbiAgICAgICAgICAgIGZvciAoaSA9IGN1cnJlbnQgLSAxOyBpID49IG5lZWRlZDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgbWUuaXRlbXNbaV0uZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIG1lLml0ZW1zLnBvcCgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaXhlZC1ET00tT3JkZXIgU3RyYXRlZ3k6XG4gICAgICAgIC8vIFdlIGVuc3VyZSB0aGUgVkRPTSBjaGlsZHJlbiAoY24pIG1hdGNoZXMgdGhlIGZ1bGwgcG9vbCBvZiBpdGVtcyBleGFjdGx5LlxuICAgICAgICAvLyBXZSBuZXZlciByZW1vdmUgb3IgcmVvcmRlciB0aGVzZSBub2Rlcy4gV2Ugb25seSB1cGRhdGUgdGhlaXIgY29udGVudCBhbmQgdHJhbnNmb3JtLlxuICAgICAgICBtZS5nZXRWZG9tUm9vdCgpLmNuID0gbWUuaXRlbXMubWFwKGl0ZW0gPT4gaXRlbS5jcmVhdGVWZG9tUmVmZXJlbmNlKCkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG1haW4gcmVuZGVyaW5nIGxvb3AgZm9yIHRoZSBHcmlkIEJvZHkuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZDpcbiAgICAgKiAxLiAgQ2FsY3VsYXRlcyB0aGUgcmFuZ2Ugb2YgcmVjb3JkcyB0byByZW5kZXIgYmFzZWQgb24gc2Nyb2xsIHBvc2l0aW9uLlxuICAgICAqIDIuICBDYWxscyBgY3JlYXRlUm93UG9vbGAgdG8gZW5zdXJlIGVub3VnaCBSb3cgY29tcG9uZW50cyBleGlzdC5cbiAgICAgKiAzLiAgSXRlcmF0ZXMgdGhyb3VnaCB0aGUgdmlzaWJsZSByZWNvcmQgcmFuZ2UuXG4gICAgICogNC4gICoqUmVjeWNsZXMqKiBleGlzdGluZyBSb3cgY29tcG9uZW50cyBieSBjYWxsaW5nIHtAbGluayBOZW8uZ3JpZC5Sb3cjdXBkYXRlQ29udGVudH0gd2l0aCB0aGUgbmV3IHJlY29yZCBkYXRhLlxuICAgICAqIDUuICBVcGRhdGVzIHRoZSBzY3JvbGwgc3BhY2VyIGhlaWdodC5cbiAgICAgKlxuICAgICAqICoqT3B0aW1pemF0aW9uIFN0cmF0ZWdpZXM6KipcbiAgICAgKiAtICoqUm93IFNraXBwaW5nOioqIElmIGBmb3JjZWAgaXMgZmFsc2UgYW5kIHRoZSByZWNvcmQvcm93SW5kZXggbWF0Y2gsIGBSb3cudXBkYXRlQ29udGVudGAgc2tpcHMgVkRPTSBnZW5lcmF0aW9uLlxuICAgICAqIC0gKipDZWxsIFJlY3ljbGluZzoqKiBJZiBob3Jpem9udGFsIHNjcm9sbGluZyBpcyBkZXRlY3RlZCAoaW1wbGljaXQgZm9yY2UpLCBgcmVjeWNsZT10cnVlYCBpcyBwYXNzZWQgdG8gUm93cywgYWxsb3dpbmcgdGhlbSB0byByZXVzZSBleGlzdGluZyBjZWxsIFZET00gbm9kZXMuXG4gICAgICogLSAqKkZvcmNlZCBVcGRhdGVzOioqIEV4cGxpY2l0IGBmb3JjZT10cnVlYCAoZS5nLiBmcm9tIGNvbHVtbiByZXNpemUpIGRpc2FibGVzIHJlY3ljbGluZyB0byBlbnN1cmUgZnVsbCByZS1yZW5kZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdIFRydWUgdG8gc3VwcHJlc3MgdGhlIGZpbmFsIFZET00gdXBkYXRlICh1c2VkIHdoZW4gYmF0Y2hpbmcpLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZvcmNlPWZhbHNlXSBUcnVlIHRvIGZvcmNlIHJvdyB1cGRhdGVzIGV2ZW4gaWYgcmVjb3JkcyBoYXZlbid0IGNoYW5nZWQgKGUuZy4gY29sdW1uIHJlc2l6ZSkuXG4gICAgICovXG4gICAgY3JlYXRlVmlld0RhdGEoc2lsZW50PWZhbHNlLCBmb3JjZT1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5za2lwQ3JlYXRlVmlld0RhdGEpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHttb3VudGVkUm93cywgc3RvcmV9ID0gbWUsXG4gICAgICAgICAgICBlbmRJbmRleCwgaSwgaXRlbSwgaXRlbUluZGV4LCBwb29sU2l6ZSwgcmFuZ2UsIHJlY3ljbGUgPSB0cnVlO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHN0b3JlLmlzTG9hZGluZyAgICAgICAgICAgICAgICAgICB8fFxuICAgICAgICAgICAgbWUuYXZhaWxhYmxlUm93cyAgICAgICAgICAgICAgPCAxIHx8XG4gICAgICAgICAgICBtZS5fY29udGFpbmVyV2lkdGggICAgICAgICAgICA8IDEgfHwgLy8gd2UgYXJlIG5vdCBjaGVja2luZyBtZS5jb250YWluZXJXaWR0aCwgc2luY2Ugd2Ugd2FudCB0byBpZ25vcmUgdGhlIGNvbmZpZyBzeW1ib2xcbiAgICAgICAgICAgIG1lLmNvbHVtblBvc2l0aW9ucy5nZXRDb3VudCgpIDwgMSB8fFxuICAgICAgICAgICAgbWUubW91bnRlZENvbHVtbnNbMV0gICAgICAgICAgPCAxXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWUuaXNWZG9tVXBkYXRpbmcpIHtcbiAgICAgICAgICAgIE5lby5tYW5hZ2VyLlZEb21VcGRhdGUucmVnaXN0ZXJQcmVVcGRhdGUobWUuaWQsICgpID0+IHtcbiAgICAgICAgICAgICAgICBtZS5jcmVhdGVWaWV3RGF0YShzaWxlbnQsIGZvcmNlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEF1dG8tZGV0ZWN0IGlmIGNvbHVtbnMgY2hhbmdlZCAoaG9yaXpvbnRhbCBzY3JvbGwgb3IgcmVzaXplKVxuICAgICAgICBpZiAoIWZvcmNlICYmICFOZW8uaXNFcXVhbChtZS5tb3VudGVkQ29sdW1ucywgbWUuI2xhc3RNb3VudGVkQ29sdW1ucykpIHtcbiAgICAgICAgICAgIGZvcmNlID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIGZvcmNlIHdhcyBleHBsaWNpdGx5IHBhc3NlZCAoZS5nLiBjb2x1bW4gZGF0YUZpZWxkIGNoYW5nZSksIHdlIG11c3QgZGlzYWJsZSByZWN5Y2xpbmdcbiAgICAgICAgLy8gdG8gZW5zdXJlIG5ldyBkYXRhRmllbGQgdmFsdWVzIGFyZSBwaWNrZWQgdXAuXG4gICAgICAgIC8vIElmIGZvcmNlIHdhcyBpbXBsaWNpdCAoc2Nyb2xsKSwgcmVjeWNsaW5nIGlzIHNhZmUgYW5kIGRlc2lyZWQuXG4gICAgICAgIGVsc2UgaWYgKGZvcmNlKSB7XG4gICAgICAgICAgICByZWN5Y2xlID0gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLiNsYXN0TW91bnRlZENvbHVtbnMgPSBbLi4ubWUubW91bnRlZENvbHVtbnNdO1xuXG4gICAgICAgIGlmIChtZS4jaW5pdGlhbENodW5rU2l6ZSA+IDApIHtcbiAgICAgICAgICAgIGVuZEluZGV4ID0gbWUuI2luaXRpYWxDaHVua1NpemU7XG4gICAgICAgICAgICByYW5nZSAgICA9IGVuZEluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ3JlYXRlcyB0aGUgbmV3IHN0YXJ0ICYgZW5kIGluZGV4ZXNcbiAgICAgICAgICAgIG1lLnVwZGF0ZU1vdW50ZWRBbmRWaXNpYmxlUm93cygpO1xuICAgICAgICAgICAgZW5kSW5kZXggPSBtb3VudGVkUm93c1sxXVxuICAgICAgICB9XG5cbiAgICAgICAgbWUuY3JlYXRlUm93UG9vbCgpO1xuXG4gICAgICAgIHBvb2xTaXplID0gbWUuaXRlbXMubGVuZ3RoO1xuXG4gICAgICAgIC8vIEZpeGVkLURPTS1PcmRlciBTdHJhdGVneTpcbiAgICAgICAgLy8gV2UgZG8gTk9UIGNsZWFyIHZkb21Sb290LmNuLiBUaGUgUm93IGNvbXBvbmVudHMgcmVtYWluIGluIHRoZSBWRE9NIGFycmF5LlxuICAgICAgICAvLyBXZSBpdGVyYXRlIHRoZSBsb2dpY2FsIHJhbmdlLCBtYXBwaW5nIHJlY29yZHMgdG8gdGhlIGZpeGVkIHBvb2wgaXRlbXMgdmlhIG1vZHVsby5cblxuICAgICAgICBsZXQgdXNlZE1hcCA9IG5ldyBBcnJheShwb29sU2l6ZSkuZmlsbChmYWxzZSk7XG5cbiAgICAgICAgZm9yIChpPW1vdW50ZWRSb3dzWzBdOyBpIDwgZW5kSW5kZXg7IGkrKykge1xuICAgICAgICAgICAgaXRlbUluZGV4ID0gaSAlIHBvb2xTaXplO1xuICAgICAgICAgICAgaXRlbSAgICAgID0gbWUuaXRlbXNbaXRlbUluZGV4XTtcblxuICAgICAgICAgICAgdXNlZE1hcFtpdGVtSW5kZXhdID0gdHJ1ZTtcblxuICAgICAgICAgICAgaXRlbS51cGRhdGVDb250ZW50KHtcbiAgICAgICAgICAgICAgICBmb3JjZSxcbiAgICAgICAgICAgICAgICByZWNvcmQgIDogc3RvcmUuZ2V0QXQoaSksXG4gICAgICAgICAgICAgICAgcmVjeWNsZSxcbiAgICAgICAgICAgICAgICByb3dJbmRleDogaSxcbiAgICAgICAgICAgICAgICBzaWxlbnQgIDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIaWRlIHVudXNlZCBwb29sIGl0ZW1zIChlLmcuIHdoZW4gZmlsdGVyaW5nIG9yIGF0IHRoZSBlbmQgb2YgdGhlIHN0b3JlKVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcG9vbFNpemU7IGkrKykge1xuICAgICAgICAgICAgaWYgKCF1c2VkTWFwW2ldKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IG1lLml0ZW1zW2ldO1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgdXBkYXRlIGlmIGl0IGN1cnJlbnRseSBoYXMgYSByZWNvcmQgKHdhcyB2aXNpYmxlKVxuICAgICAgICAgICAgICAgIGlmIChpdGVtLnJlY29yZCkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnVwZGF0ZUNvbnRlbnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkICA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dJbmRleDogLTEsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWxlbnQgIDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnBhcmVudC5pc0xvYWRpbmcgPSBmYWxzZTtcblxuICAgICAgICBtZS51cGRhdGVTY3JvbGxIZWlnaHQodHJ1ZSwgcmFuZ2UpOyAvLyBzaWxlbnRcblxuICAgICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAgICAgbWUudXBkYXRlRGVwdGggPSAtMTtcbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqL1xuICAgIGRlc3Ryb3koLi4uYXJncykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBtZS5pdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgbWUuaXRlbXNbaV0uZGVzdHJveSgpXG4gICAgICAgIH1cblxuICAgICAgICBtZS5zdG9yZSA9IG51bGw7IC8vIHJlbW92ZSB0aGUgbGlzdGVuZXJzXG5cbiAgICAgICAgc3VwZXIuZGVzdHJveSguLi5hcmdzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICAgICAqL1xuICAgIGZpcmVDZWxsRXZlbnQoZGF0YSwgZXZlbnROYW1lKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaWQgICAgICAgID0gZGF0YS5jdXJyZW50VGFyZ2V0LFxuICAgICAgICAgICAgZGF0YUZpZWxkLCByZWNvcmQsIHJlY29yZElkLCB0YXJnZXQ7XG5cbiAgICAgICAgZm9yICh0YXJnZXQgb2YgZGF0YS5wYXRoKSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0LmRhdGE/LmZpZWxkKSB7XG4gICAgICAgICAgICAgICAgZGF0YUZpZWxkID0gdGFyZ2V0LmRhdGEuZmllbGQ7XG4gICAgICAgICAgICAgICAgcmVjb3JkSWQgID0gdGFyZ2V0LmRhdGEucmVjb3JkSWQ7XG4gICAgICAgICAgICAgICAgcmVjb3JkICAgID0gbWUuZ2V0UmVjb3JkKHJlY29yZElkKTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkYXRhRmllbGQpIHtcbiAgICAgICAgICAgIGRhdGFGaWVsZCA9IG1lLmdldENlbGxEYXRhRmllbGQoaWQpO1xuICAgICAgICAgICAgcmVjb3JkICAgID0gbWUuZ2V0UmVjb3JkKGlkKVxuICAgICAgICB9XG5cbiAgICAgICAgbWUucGFyZW50LmZpcmUoZXZlbnROYW1lLCB7Ym9keTogbWUsIGRhdGEsIGRhdGFGaWVsZCwgcmVjb3JkfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAgICAgKi9cbiAgICBmaXJlUm93RXZlbnQoZGF0YSwgZXZlbnROYW1lKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaWQgICAgID0gZGF0YS5jdXJyZW50VGFyZ2V0LFxuICAgICAgICAgICAgcmVjb3JkLCByZWNvcmRJZCwgdGFyZ2V0O1xuXG4gICAgICAgIGZvciAodGFyZ2V0IG9mIGRhdGEucGF0aCkge1xuICAgICAgICAgICAgaWYgKHRhcmdldC5jbHM/LmluY2x1ZGVzKCduZW8tZ3JpZC1yb3cnKSAmJiB0YXJnZXQuZGF0YT8ucmVjb3JkSWQpIHtcbiAgICAgICAgICAgICAgICByZWNvcmRJZCA9IHRhcmdldC5kYXRhLnJlY29yZElkO1xuICAgICAgICAgICAgICAgIHJlY29yZCAgID0gbWUuZ2V0UmVjb3JkKHJlY29yZElkKTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZWNvcmQpIHtcbiAgICAgICAgICAgIHJlY29yZCA9IG1lLmdldFJlY29yZChpZClcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnBhcmVudC5maXJlKGV2ZW50TmFtZSwge2JvZHk6IG1lLCBkYXRhLCByZWNvcmR9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjZWxsSWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldENlbGxEYXRhRmllbGQoY2VsbElkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldERhdGFGaWVsZChjZWxsSWQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJvd0luZGV4XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFGaWVsZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0Q2VsbElkKHJvd0luZGV4LCBkYXRhRmllbGQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbHVtbiAgICAgID0gbWUuZ2V0Q29sdW1uKGRhdGFGaWVsZCksXG4gICAgICAgICAgICBjb2x1bW5JbmRleCA9IG1lLmdldENvbHVtbihkYXRhRmllbGQsIHRydWUpLFxuICAgICAgICAgICAgcm93SWQgICAgICAgPSBtZS5nZXRSb3dJZChyb3dJbmRleCk7XG5cbiAgICAgICAgaWYgKGNvbHVtbi5oaWRlTW9kZSA9PT0gJ3JlbW92ZURvbScpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHtyb3dJZH1fX2NlbGwtJHtjb2x1bW5JbmRleCAlIG1lLmNlbGxQb29sU2l6ZX1gXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYCR7cm93SWR9X18ke2RhdGFGaWVsZH1gXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhRmllbGRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldExvZ2ljYWxDZWxsSWQocmVjb3JkLCBkYXRhRmllbGQpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuZ2V0UmVjb3JkSWQocmVjb3JkKX1fXyR7ZGF0YUZpZWxkfWBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBncmlkIGNvbHVtbiBvciBjb2x1bW4gaW5kZXggYnkgYSBnaXZlbiBmaWVsZCBuYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSByZXR1cm5JbmRleD1mYWxzZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8TnVtYmVyfG51bGx9XG4gICAgICovXG4gICAgZ2V0Q29sdW1uKGZpZWxkLCByZXR1cm5JbmRleD1mYWxzZSkge1xuICAgICAgICBsZXQge2NvbHVtbnN9ID0gdGhpcy5wYXJlbnQsXG4gICAgICAgICAgICBjb2x1bW4gICAgPSBjb2x1bW5zLmdldChmaWVsZCk7XG5cbiAgICAgICAgaWYgKGNvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIHJldHVybkluZGV4ID8gY29sdW1ucy5pbmRleE9mKGNvbHVtbikgOiBjb2x1bW5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBwYWludGVkIGNvbHVtbiBjZWxscyAodmlzaWJsZSArIGJ1ZmZlciByYW5nZSlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YUZpZWxkXG4gICAgICogQHJldHVybnMge09iamVjdFtdfVxuICAgICAqL1xuICAgIGdldENvbHVtbkNlbGxzKGRhdGFGaWVsZCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY2VsbHMgICAgICAgPSBbXSxcbiAgICAgICAgICAgIGNvbHVtbkluZGV4ID0gLTEsXG4gICAgICAgICAgICBmaXJzdFJvdyAgICA9IG1lLml0ZW1zWzBdLnZkb20sXG4gICAgICAgICAgICBpICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICBsZW4gICAgICAgICA9IGZpcnN0Um93LmNuLmxlbmd0aCxcbiAgICAgICAgICAgIGNlbGw7XG5cbiAgICAgICAgLy8gQ29sdW1ucyBtaWdodCBnZXQgbW92ZWQgdmlhIGRyYWcmZHJvcCwgc28gbGV0J3MgY2hlY2sgZm9yIHRoZSBjdXJyZW50IG1hdGNoXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChkYXRhRmllbGQgPT09IG1lLmdldERhdGFGaWVsZChmaXJzdFJvdy5jbltpXS5pZCkpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5JbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29sdW1uSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbWUuaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjZWxsID0gbWUuaXRlbXNbaV0udmRvbS5jbltjb2x1bW5JbmRleF07XG4gICAgICAgICAgICAgICAgY2VsbCAmJiBjZWxscy5wdXNoKGNlbGwpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2VsbHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2VsbElkXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXREYXRhRmllbGQoY2VsbElkKSB7XG4gICAgICAgIGlmIChjZWxsSWQuaW5jbHVkZXMoJ19fY2VsbC0nKSkge1xuICAgICAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHBvb2xJbmRleCAgICAgPSBwYXJzZUludChjZWxsSWQuc3BsaXQoJ19fY2VsbC0nKVsxXSksXG4gICAgICAgICAgICAgICAgY29sdW1ucyAgICAgICA9IG1lLnBhcmVudC5jb2x1bW5zLFxuICAgICAgICAgICAgICAgIHtjZWxsUG9vbFNpemUsIG1vdW50ZWRDb2x1bW5zfSA9IG1lLFxuICAgICAgICAgICAgICAgIGkgICAgICAgICAgICAgPSBtb3VudGVkQ29sdW1uc1swXSxcbiAgICAgICAgICAgICAgICBsZW4gICAgICAgICAgID0gbW91bnRlZENvbHVtbnNbMV0sXG4gICAgICAgICAgICAgICAgY29sdW1uO1xuXG4gICAgICAgICAgICBmb3IgKDsgaSA8PSBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpICUgY2VsbFBvb2xTaXplID09PSBwb29sSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uID0gY29sdW1ucy5nZXRBdChpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FuaXR5IGNoZWNrOiBlbnN1cmUgdGhpcyBjb2x1bW4gaXMgYWN0dWFsbHkgcG9vbGVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2x1bW4gJiYgY29sdW1uLmhpZGVNb2RlID09PSAncmVtb3ZlRG9tJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbHVtbi5kYXRhRmllbGRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjZWxsSWQuc3BsaXQoJ19fJykucG9wKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG1hdGNoaW5nIHJlY29yZCBieSBwYXNzaW5nIGEgcm93IGlkLCBhIGNlbGwgaWQgb3IgYW4gaWQgaW5zaWRlIGEgZ3JpZCBjZWxsLlxuICAgICAqIExpbWl0ZWQgdG8gbW91bnRlZCByb3dzIChtdXN0IGJlIGluc2lkZSB0aGUgdmRvbSkuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5vZGVJZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRSZWNvcmQobm9kZUlkKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgcmVjb3JkID0gbWUuZ2V0UmVjb3JkQnlSb3dJZChub2RlSWQpLFxuICAgICAgICAgICAgbm9kZSwgcGFyZW50Tm9kZXM7XG5cbiAgICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIG5vZGVJZCBpcyBhIHJlY29yZElkIChpbnRlcm5hbElkIG9yIFBLKVxuICAgICAgICByZWNvcmQgPSBtZS5zdG9yZS5nZXQobm9kZUlkKTtcbiAgICAgICAgaWYgKHJlY29yZCkgcmV0dXJuIHJlY29yZDtcblxuICAgICAgICBwYXJlbnROb2RlcyA9IFZEb21VdGlsLmdldFBhcmVudE5vZGVzKG1lLnZkb20sIG5vZGVJZCk7XG5cbiAgICAgICAgZm9yIChub2RlIG9mIHBhcmVudE5vZGVzIHx8IFtdKSB7XG4gICAgICAgICAgICByZWNvcmQgPSBtZS5nZXRSZWNvcmRCeVJvd0lkKG5vZGUuY29tcG9uZW50SWQgfHwgbm9kZS5pZCk7XG5cbiAgICAgICAgICAgIGlmIChyZWNvcmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjb3JkXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfE51bWJlcn1cbiAgICAgKi9cbiAgICBnZXRSZWNvcmRJZChyZWNvcmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXNlSW50ZXJuYWxJZCA/IHRoaXMuc3RvcmUuZ2V0SW50ZXJuYWxJZChyZWNvcmQpIDogdGhpcy5zdG9yZS5nZXRLZXkocmVjb3JkKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsb2dpY2FsSWRcbiAgICAgKiBAcmV0dXJucyB7TmVvLmRhdGEuTW9kZWx8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRSZWNvcmRGcm9tTG9naWNhbElkKGxvZ2ljYWxJZCkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGRhdGFGaWVsZCA9IG1lLmdldERhdGFGaWVsZChsb2dpY2FsSWQpLFxuICAgICAgICAgICAgcmVjb3JkSWQgID0gbG9naWNhbElkLnN1YnN0cmluZygwLCBsb2dpY2FsSWQubGVuZ3RoIC0gZGF0YUZpZWxkLmxlbmd0aCAtIDIpLFxuICAgICAgICAgICAgcmVjb3JkICAgID0gbWUuZ2V0UmVjb3JkKHJlY29yZElkKTsgLy8gVXNlcyB0aGUgbmV3IHJvYnVzdCBnZXRSZWNvcmQoKVxuXG4gICAgICAgIGlmICghcmVjb3JkKSB7XG4gICAgICAgICAgICByZWNvcmQgPSBtZS5zdG9yZS5nZXQocGFyc2VJbnQocmVjb3JkSWQpKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlY29yZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByb3dJZFxuICAgICAqIEByZXR1cm5zIHtSZWNvcmR8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRSZWNvcmRCeVJvd0lkKHJvd0lkKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBub2RlICAgICA9IE5lby5nZXRDb21wb25lbnQocm93SWQpPy52ZG9tLFxuICAgICAgICAgICAgcm93SW5kZXggPSBub2RlPy5bJ2FyaWEtcm93aW5kZXgnXTtcblxuICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKHJvd0luZGV4KSkge1xuICAgICAgICAgICAgLy8gYXJpYS1yb3dpbmRleCBpcyAxIGJhc2VkICYgYWxzbyBpbmNsdWRlcyB0aGUgaGVhZGVyXG4gICAgICAgICAgICByb3dJbmRleCAtPSAyO1xuXG4gICAgICAgICAgICByZXR1cm4gbWUuc3RvcmUuZ2V0QXQocm93SW5kZXgpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAgICAgKiBAcmV0dXJucyB7TmVvLmdyaWQuUm93fG51bGx9XG4gICAgICovXG4gICAgZ2V0Um93KHJlY29yZCkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgcm93SW5kZXggPSBtZS5zdG9yZS5pbmRleE9mKHJlY29yZCksXG4gICAgICAgICAgICBpdGVtSW5kZXg7XG5cbiAgICAgICAgaWYgKHJvd0luZGV4ID4gLTEgJiYgcm93SW5kZXggPj0gbWUubW91bnRlZFJvd3NbMF0gJiYgcm93SW5kZXggPD0gbWUubW91bnRlZFJvd3NbMV0pIHtcbiAgICAgICAgICAgIGl0ZW1JbmRleCA9IHJvd0luZGV4ICUgbWUuaXRlbXMubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIG1lLml0ZW1zW2l0ZW1JbmRleF1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gYXBwbHkgY3VzdG9tIENTUyBydWxlcyB0byBncmlkIHJvd3NcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJvd0luZGV4XG4gICAgICogQHJldHVybnMge1N0cmluZ1tdfVxuICAgICAqL1xuICAgIGdldFJvd0NsYXNzKHJlY29yZCwgcm93SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIFsnbmVvLWdyaWQtcm93J11cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcm93SW5kZXhcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFJvd0lkKHJvd0luZGV4KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLiNpbml0aWFsQ2h1bmtTaXplID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGAke21lLmlkfV9fcm93LSR7cm93SW5kZXh9YFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGAke21lLmlkfV9fcm93LSR7cm93SW5kZXggJSAobWUuYXZhaWxhYmxlUm93cyArIDIgKiBtZS5idWZmZXJSb3dSYW5nZSl9YFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0VmRvbVJvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZkb20uY25bMF1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0W119IFRoZSBuZXcgdmRvbSBpdGVtcyByb290XG4gICAgICovXG4gICAgZ2V0VmRvbUl0ZW1zUm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmRvbS5jblswXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEByZXR1cm5zIHtOZW8udmRvbS5WTm9kZX1cbiAgICAgKi9cbiAgICBnZXRWbm9kZVJvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZub2RlLmNoaWxkTm9kZXNbMF1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uQ2VsbENsaWNrKGRhdGEpIHtcbiAgICAgICAgdGhpcy5maXJlQ2VsbEV2ZW50KGRhdGEsICdjZWxsQ2xpY2snKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25DZWxsRG91YmxlQ2xpY2soZGF0YSkge1xuICAgICAgICB0aGlzLmZpcmVDZWxsRXZlbnQoZGF0YSwgJ2NlbGxEb3VibGVDbGljaycpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNvbnN0cnVjdGVkKCkge1xuICAgICAgICBzdXBlci5vbkNvbnN0cnVjdGVkKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZWw/LnJlZ2lzdGVyKHRoaXMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvblJvd0NsaWNrKGRhdGEpIHtcbiAgICAgICAgdGhpcy5mb2N1cyh0aGlzLnZkb20uaWQsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgdGhpcy5maXJlUm93RXZlbnQoZGF0YSwgJ3Jvd0NsaWNrJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uUm93RG91YmxlQ2xpY2soZGF0YSkge1xuICAgICAgICB0aGlzLmZpcmVSb3dFdmVudChkYXRhLCAncm93RG91YmxlQ2xpY2snKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25TY3JvbGxDYXB0dXJlKGRhdGEpIHtcbiAgICAgICAgc3VwZXIub25TY3JvbGxDYXB0dXJlKGRhdGEpO1xuICAgICAgICB0aGlzLnBhcmVudC5zY3JvbGxNYW5hZ2VyLm9uQm9keVNjcm9sbChkYXRhKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25TdG9yZUZpbHRlcigpIHtcbiAgICAgICAgdGhpcy5vblN0b3JlTG9hZCh7aXRlbXM6IHRoaXMuc3RvcmUuaXRlbXN9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgIGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLml0ZW1zXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgW2RhdGEucG9zdENodW5rTG9hZF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gICBbZGF0YS50b3RhbF1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25TdG9yZUxvYWQoe2l0ZW1zLCBwb3N0Q2h1bmtMb2FkLCB0b3RhbH0pIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3dpbmRvd0lkfSA9IG1lO1xuXG4gICAgICAgIC8vIElmIGl0J3MgdGhlIGZpcnN0IGNodW5rZWQgbG9hZCAoZGF0YS50b3RhbCBleGlzdHMgYW5kIGRhdGEuaXRlbXMgaXMgYSBzdWJzZXQgb2YgdG90YWwpXG4gICAgICAgIC8vIFJlbmRlciB0aGUgZW50aXJlIGNodW5rIGZvciBpbW1lZGlhdGUgc2Nyb2xsYWJpbGl0eVxuICAgICAgICBpZiAodG90YWwgJiYgaXRlbXMubGVuZ3RoIDwgdG90YWwpIHtcbiAgICAgICAgICAgIG1lLiNpbml0aWFsQ2h1bmtTaXplID0gaXRlbXMubGVuZ3RoO1xuICAgICAgICAgICAgbWUuI2luaXRpYWxUb3RhbFNpemUgPSB0b3RhbDtcbiAgICAgICAgICAgIG1lLmNyZWF0ZVZpZXdEYXRhKCk7XG4gICAgICAgICAgICBtZS4jaW5pdGlhbENodW5rU2l6ZSA9IDBcbiAgICAgICAgICAgIG1lLiNpbml0aWFsVG90YWxTaXplID0gMFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUuY3JlYXRlVmlld0RhdGEoKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lLm1vdW50ZWQgJiYgIXBvc3RDaHVua0xvYWQpIHtcbiAgICAgICAgICAgIG1lLnRpbWVvdXQoNTApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIE5lby5tYWluLkRvbUFjY2Vzcy5zY3JvbGxUbyh7XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ3RvcCcsXG4gICAgICAgICAgICAgICAgICAgIGlkICAgICAgIDogbWUudmRvbS5pZCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgICAgOiAwLFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3dJZFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119ICAgICAgIGRhdGEuZmllbGRzIEVhY2ggZmllbGQgb2JqZWN0IGNvbnRhaW5zIHRoZSBrZXlzOiBuYW1lLCBvbGRWYWx1ZSwgdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLk1vZGVsfSBkYXRhLm1vZGVsICBUaGUgbW9kZWwgaW5zdGFuY2Ugb2YgdGhlIGNoYW5nZWQgcmVjb3JkXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgZGF0YS5yZWNvcmRcbiAgICAgKi9cbiAgICBvblN0b3JlUmVjb3JkQ2hhbmdlKHtmaWVsZHMsIHJlY29yZH0pIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGZpZWxkTmFtZXMgICAgICAgICAgICAgICAgICAgID0gZmllbGRzLm1hcChmaWVsZCA9PiBmaWVsZC5uYW1lKSxcbiAgICAgICAgICAgIHJvd0luZGV4ICAgICAgICAgICAgICAgICAgICAgID0gbWUuc3RvcmUuaW5kZXhPZihyZWNvcmQpLFxuICAgICAgICAgICAge21vdW50ZWRSb3dzLCBzZWxlY3Rpb25Nb2RlbH0gPSBtZSxcbiAgICAgICAgICAgIHBvb2xTaXplICAgICAgICAgICAgICAgICAgICAgID0gbWUuaXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgaXRlbUluZGV4LCByZWNvcmRJZCwgcm93O1xuXG4gICAgICAgIGlmIChmaWVsZE5hbWVzLmluY2x1ZGVzKG1lLmNvbHNwYW5GaWVsZCkpIHtcbiAgICAgICAgICAgIG1lLmNyZWF0ZVZpZXdEYXRhKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChyb3dJbmRleCA+PSBtb3VudGVkUm93c1swXSAmJiByb3dJbmRleCA8PSBtb3VudGVkUm93c1sxXSkge1xuICAgICAgICAgICAgICAgIGl0ZW1JbmRleCA9IHJvd0luZGV4ICUgcG9vbFNpemU7XG4gICAgICAgICAgICAgICAgcm93ICAgICAgID0gbWUuaXRlbXNbaXRlbUluZGV4XTtcblxuICAgICAgICAgICAgICAgIGlmIChyb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93LmNyZWF0ZVZkb20oKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBmaWVsZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZpZWxkID0gZmllbGRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQubmFtZSA9PT0gbWUuc2VsZWN0ZWRSZWNvcmRGaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbk1vZGVsLm50eXBlID09PSAnc2VsZWN0aW9uLWdyaWQtcm93bW9kZWwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkSWQgPSBtZS5nZXRSZWNvcmRJZChyZWNvcmQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uTW9kZWxbZmllbGQudmFsdWUgPyAnc2VsZWN0Um93JyA6ICdkZXNlbGVjdFJvdyddKHJlY29yZElkKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBmb3Iga2V5Ym9hcmQgbmF2aWdhdGlvbiAoc2VsZWN0aW9uIG1vZGVscylcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RlcFxuICAgICAqL1xuICAgIHNjcm9sbEJ5Um93cyhpbmRleCwgc3RlcCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge21vdW50ZWRSb3dzLCB2aXNpYmxlUm93c30gPSBtZSxcbiAgICAgICAgICAgIGNvdW50UmVjb3JkcyAgICAgICAgICAgICAgID0gbWUuc3RvcmUuZ2V0Q291bnQoKSxcbiAgICAgICAgICAgIG5ld0luZGV4ICAgICAgICAgICAgICAgICAgID0gaW5kZXggKyBzdGVwLFxuICAgICAgICAgICAgbGFzdFJvd0dhcCwgbW91bnRlZCwgc2Nyb2xsVG9wLCB2aXNpYmxlO1xuXG4gICAgICAgIGlmIChuZXdJbmRleCA+PSBjb3VudFJlY29yZHMpIHtcbiAgICAgICAgICAgIG5ld0luZGV4ICU9IGNvdW50UmVjb3JkcztcbiAgICAgICAgICAgIHN0ZXAgICAgID0gbmV3SW5kZXggLSBpbmRleFxuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKG5ld0luZGV4IDwgMCkge1xuICAgICAgICAgICAgbmV3SW5kZXggKz0gY291bnRSZWNvcmRzO1xuICAgICAgICAgICAgc3RlcCAgICAgKz0gY291bnRSZWNvcmRzXG4gICAgICAgIH1cblxuICAgICAgICBtb3VudGVkID0gbmV3SW5kZXggPj0gbW91bnRlZFJvd3NbMF0gJiYgbmV3SW5kZXggPD0gbW91bnRlZFJvd3NbMV07XG5cbiAgICAgICAgLy8gTm90IHVzaW5nID49IG9yIDw9LCBzaW5jZSB0aGUgZmlyc3QgLyBsYXN0IHJvdyBtaWdodCBub3QgYmUgZnVsbHkgdmlzaWJsZVxuICAgICAgICB2aXNpYmxlID0gbmV3SW5kZXggPiB2aXNpYmxlUm93c1swXSAmJiBuZXdJbmRleCA8IHZpc2libGVSb3dzWzFdO1xuXG4gICAgICAgIGlmICghdmlzaWJsZSkge1xuICAgICAgICAgICAgLy8gTGVhdmluZyB0aGUgbW91bnRlZCBhcmVhIHdpbGwgcmUtY2FsY3VsYXRlIHRoZSB2aXNpYmxlUm93cyBmb3IgdXNcbiAgICAgICAgICAgIGlmIChtb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgdmlzaWJsZVJvd3NbMF0gKz0gc3RlcDtcbiAgICAgICAgICAgICAgICB2aXNpYmxlUm93c1sxXSArPSBzdGVwXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdGVwIDwgMCkge1xuICAgICAgICAgICAgICAgIHNjcm9sbFRvcCA9IG5ld0luZGV4ICogbWUucm93SGVpZ2h0XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxhc3RSb3dHYXAgPSBtZS5yb3dIZWlnaHQgLSAobWUuYXZhaWxhYmxlSGVpZ2h0ICUgbWUucm93SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBzY3JvbGxUb3AgID0gKG5ld0luZGV4IC0gbWUuYXZhaWxhYmxlUm93cykgKiBtZS5yb3dIZWlnaHQgKyBsYXN0Um93R2FwXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE5lby5tYWluLkRvbUFjY2Vzcy5zY3JvbGxUbyh7XG4gICAgICAgICAgICAgICAgaWQgICAgICA6IG1lLnZkb20uaWQsXG4gICAgICAgICAgICAgICAgdmFsdWUgICA6IHNjcm9sbFRvcCxcbiAgICAgICAgICAgICAgICB3aW5kb3dJZDogbWUud2luZG93SWRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JjZT1mYWxzZV1cbiAgICAgKi9cbiAgICB1cGRhdGVNb3VudGVkQW5kVmlzaWJsZUNvbHVtbnMoZm9yY2U9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtidWZmZXJDb2x1bW5SYW5nZSwgY2VsbFBvb2xTaXplLCBjb2x1bW5Qb3NpdGlvbnMsIG1vdW50ZWRDb2x1bW5zLCB2aXNpYmxlQ29sdW1uc30gPSBtZSxcbiAgICAgICAgICAgIGkgICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICBjb3VudENvbHVtbnMgPSBjb2x1bW5Qb3NpdGlvbnMuZ2V0Q291bnQoKSxcbiAgICAgICAgICAgIGVuZEluZGV4ICAgICA9IGNvdW50Q29sdW1ucyAtIDEsXG4gICAgICAgICAgICB4ICAgICAgICAgICAgPSBtZS5zY3JvbGxMZWZ0LFxuICAgICAgICAgICAgY29sdW1uLCBuZXdQb29sU2l6ZSwgc3RhcnRJbmRleCA9IDA7XG5cbiAgICAgICAgaWYgKGNvdW50Q29sdW1ucyA8IDEpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICg7IGkgPCBjb3VudENvbHVtbnM7IGkrKykge1xuICAgICAgICAgICAgY29sdW1uID0gY29sdW1uUG9zaXRpb25zLmdldEF0KGkpO1xuXG4gICAgICAgICAgICBpZiAoeCA+PSBjb2x1bW4ueCAmJiB4IDw9IGNvbHVtbi54ICsgY29sdW1uLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRJbmRleCA9IGlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1lLmNvbnRhaW5lcldpZHRoICsgeCA8IGNvbHVtbi54KSB7XG4gICAgICAgICAgICAgICAgZW5kSW5kZXggPSBpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmlzaWJsZUNvbHVtbnNbMF0gPSBzdGFydEluZGV4OyAvLyB1cGRhdGUgdGhlIGFycmF5IGlubGluZVxuICAgICAgICB2aXNpYmxlQ29sdW1uc1sxXSA9IGVuZEluZGV4O1xuXG4gICAgICAgIGlmIChmb3JjZSB8fCB2aXNpYmxlQ29sdW1uc1swXSA8PSBtb3VudGVkQ29sdW1uc1swXSB8fCB2aXNpYmxlQ29sdW1uc1sxXSA+PSBtb3VudGVkQ29sdW1uc1sxXSkge1xuICAgICAgICAgICAgc3RhcnRJbmRleCA9IE1hdGgubWF4KDAsIHZpc2libGVDb2x1bW5zWzBdIC0gYnVmZmVyQ29sdW1uUmFuZ2UpO1xuICAgICAgICAgICAgZW5kSW5kZXggICA9IE1hdGgubWluKGNvdW50Q29sdW1ucyAtIDEsIHZpc2libGVDb2x1bW5zWzFdICsgYnVmZmVyQ29sdW1uUmFuZ2UpO1xuXG4gICAgICAgICAgICBpZiAoZW5kSW5kZXggLSBzdGFydEluZGV4ID49IGNlbGxQb29sU2l6ZSkge1xuICAgICAgICAgICAgICAgIG5ld1Bvb2xTaXplID0gZW5kSW5kZXggLSBzdGFydEluZGV4ICsgNTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUuc2V0KHtcbiAgICAgICAgICAgICAgICBjZWxsUG9vbFNpemUgIDogbmV3UG9vbFNpemUgfHwgY2VsbFBvb2xTaXplLFxuICAgICAgICAgICAgICAgIG1vdW50ZWRDb2x1bW5zOiBbc3RhcnRJbmRleCwgZW5kSW5kZXhdXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICB1cGRhdGVNb3VudGVkQW5kVmlzaWJsZVJvd3MoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7YnVmZmVyUm93UmFuZ2UsIGF2YWlsYWJsZVJvd3MsIHN0YXJ0SW5kZXgsIHN0b3JlfSA9IG1lLFxuICAgICAgICAgICAgY291bnRSZWNvcmRzICAgPSBzdG9yZS5nZXRDb3VudCgpLFxuICAgICAgICAgICAgd2luZG93U2l6ZSAgICAgPSBhdmFpbGFibGVSb3dzICsgMiAqIGJ1ZmZlclJvd1JhbmdlLFxuICAgICAgICAgICAgZW5kSW5kZXggICAgICAgPSBNYXRoLm1pbihjb3VudFJlY29yZHMsIHN0YXJ0SW5kZXggKyBhdmFpbGFibGVSb3dzKSxcbiAgICAgICAgICAgIG1vdW50ZWRTdGFydCAgID0gc3RhcnRJbmRleCAtIGJ1ZmZlclJvd1JhbmdlLFxuICAgICAgICAgICAgbW91bnRlZEVuZCAgICAgPSBlbmRJbmRleCAgICsgYnVmZmVyUm93UmFuZ2U7XG5cbiAgICAgICAgbWUudmlzaWJsZVJvd3NbMF0gPSBzdGFydEluZGV4OyAvLyB1cGRhdGUgdGhlIGFycmF5IGlubGluZVxuICAgICAgICBtZS52aXNpYmxlUm93c1sxXSA9IGVuZEluZGV4O1xuXG4gICAgICAgIC8vIFdlIHdhbnQgdG8gbWFpbnRhaW4gYSBjb25zdGFudCB3aW5kb3cgc2l6ZSAoTW9kdWx1cykgdG8gZW5zdXJlIHJvdyByZWN5Y2xpbmcgd29ya3NcbiAgICAgICAgLy8gdmlhIG1vdmVOb2RlIG9wZXJhdGlvbnMgaW5zdGVhZCBvZiByZW1vdmVOb2RlICsgaW5zZXJ0Tm9kZS5cbiAgICAgICAgLy8gSWYgd2UgYXJlIGF0IHRoZSB0b3AsIGV4dGVuZCB0aGUgZW5kIHRvIGZpbGwgdGhlIHdpbmRvdy5cbiAgICAgICAgaWYgKG1vdW50ZWRTdGFydCA8IDApIHtcbiAgICAgICAgICAgIG1vdW50ZWRFbmQgICs9IE1hdGguYWJzKG1vdW50ZWRTdGFydCk7XG4gICAgICAgICAgICBtb3VudGVkU3RhcnQgPSAwXG4gICAgICAgIH1cblxuICAgICAgICAvLyBDbGFtcCB0byByZWNvcmQgY291bnRcbiAgICAgICAgbW91bnRlZEVuZCA9IE1hdGgubWluKGNvdW50UmVjb3JkcywgbW91bnRlZEVuZCk7XG5cbiAgICAgICAgLy8gSWYgd2UgYXJlIGF0IHRoZSBib3R0b20gKGhpdCB0aGUgY2VpbGluZyksIHB1bGwgdGhlIHN0YXJ0IGJhY2sgdG8gZmlsbCB0aGUgd2luZG93LlxuICAgICAgICAvLyBUaGlzIGVuc3VyZXMgd2Uga2VlcCB0aGUgRE9NIG5vZGVzIGFsaXZlIGZvciBhcyBsb25nIGFzIHBvc3NpYmxlLlxuICAgICAgICBpZiAobW91bnRlZEVuZCAtIG1vdW50ZWRTdGFydCA8IHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgIGxldCBuZWVkZWQgICA9IHdpbmRvd1NpemUgLSAobW91bnRlZEVuZCAtIG1vdW50ZWRTdGFydCk7XG4gICAgICAgICAgICBtb3VudGVkU3RhcnQgPSBNYXRoLm1heCgwLCBtb3VudGVkU3RhcnQgLSBuZWVkZWQpXG4gICAgICAgIH1cblxuICAgICAgICBtZS5tb3VudGVkUm93c1swXSA9IG1vdW50ZWRTdGFydDsgLy8gdXBkYXRlIHRoZSBhcnJheSBpbmxpbmVcbiAgICAgICAgbWUubW91bnRlZFJvd3NbMV0gPSBtb3VudGVkRW5kXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaWxlbnQ9ZmFsc2VcbiAgICAgKi9cbiAgICB1cGRhdGVTY3JvbGxIZWlnaHQoc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY291bnRSZWNvcmRzID0gbWUuI2luaXRpYWxUb3RhbFNpemUgfHwgbWUuc3RvcmU/LmNvdW50IHx8IDAsXG4gICAgICAgICAgICB7cm93SGVpZ2h0fSAgPSBtZTtcblxuICAgICAgICBpZiAoY291bnRSZWNvcmRzID4gMCAmJiByb3dIZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICBtZS52ZG9tLmNuWzBdLmhlaWdodCA9IGAkeyhjb3VudFJlY29yZHMgKyAxKSAqIHJvd0hlaWdodH1weGA7XG4gICAgICAgICAgICAhc2lsZW50ICYmIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXG4gICAgICAgICAgICBhbmltYXRlZFJvd1NvcnRpbmcgICAgOiBtZS5hbmltYXRlZFJvd1NvcnRpbmcsXG4gICAgICAgICAgICBidWZmZXJDb2x1bW5SYW5nZSAgICAgOiBtZS5idWZmZXJDb2x1bW5SYW5nZSxcbiAgICAgICAgICAgIGJ1ZmZlclJvd1JhbmdlICAgICAgICA6IG1lLmJ1ZmZlclJvd1JhbmdlLFxuICAgICAgICAgICAgY29sc3BhbkZpZWxkICAgICAgICAgIDogbWUuY29sc3BhbkZpZWxkLFxuICAgICAgICAgICAgaGlnaGxpZ2h0TW9kaWZpZWRDZWxsczogbWUuaGlnaGxpZ2h0TW9kaWZpZWRDZWxscyxcbiAgICAgICAgICAgIHJvd0hlaWdodCAgICAgICAgICAgICA6IG1lLnJvd0hlaWdodCxcbiAgICAgICAgICAgIHNlbGVjdGVkUmVjb3JkRmllbGQgICA6IG1lLnNlbGVjdGVkUmVjb3JkRmllbGQsXG4gICAgICAgICAgICBzZWxlY3Rpb25Nb2RlbCAgICAgICAgOiBtZS5zZWxlY3Rpb25Nb2RlbD8udG9KU09OKClcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoR3JpZEJvZHkpO1xuIiwiaW1wb3J0IEJhc2VDb250YWluZXIgICAgIGZyb20gJy4uL2NvbnRhaW5lci9CYXNlLm1qcyc7XG5pbXBvcnQgQ2xhc3NTeXN0ZW1VdGlsICAgZnJvbSAnLi4vdXRpbC9DbGFzc1N5c3RlbS5tanMnO1xuaW1wb3J0IENvbGxlY3Rpb24gICAgICAgIGZyb20gJy4uL2NvbGxlY3Rpb24vQmFzZS5tanMnO1xuaW1wb3J0IEdyaWRCb2R5ICAgICAgICAgIGZyb20gJy4vQm9keS5tanMnO1xuaW1wb3J0IFNjcm9sbE1hbmFnZXIgICAgIGZyb20gJy4vU2Nyb2xsTWFuYWdlci5tanMnO1xuaW1wb3J0IFN0b3JlICAgICAgICAgICAgIGZyb20gJy4uL2RhdGEvU3RvcmUubWpzJztcbmltcG9ydCBWZXJ0aWNhbFNjcm9sbGJhciBmcm9tICcuL1ZlcnRpY2FsU2Nyb2xsYmFyLm1qcyc7XG5pbXBvcnQgRm9vdGVyVG9vbGJhciAgICAgZnJvbSAnLi9mb290ZXIvVG9vbGJhci5tanMnO1xuaW1wb3J0ICogYXMgY29sdW1uICAgICAgIGZyb20gJy4vY29sdW1uL19leHBvcnQubWpzJztcbmltcG9ydCAqIGFzIGhlYWRlciAgICAgICBmcm9tICcuL2hlYWRlci9fZXhwb3J0Lm1qcyc7XG5pbXBvcnQge2lzRGVzY3JpcHRvcn0gICAgZnJvbSAnLi4vY29yZS9Db25maWdTeW1ib2xzLm1qcyc7XG5cbi8qKlxuICogQHN1bW1hcnkgVGhlIG1haW4gZW50cnkgcG9pbnQgZm9yIGNyZWF0aW5nIERhdGEgR3JpZHMgaW4gTmVvLm1qcy5cbiAqXG4gKiBgTmVvLmdyaWQuQ29udGFpbmVyYCBvcmNoZXN0cmF0ZXMgdGhlIGVudGlyZSBHcmlkIGNvbXBvbmVudC4gSXQgdXNlcyBhIGNvbXBvc2l0ZSBhcmNoaXRlY3R1cmUgY29uc2lzdGluZyBvZjpcbiAqIDEuICBgaGVhZGVyVG9vbGJhcmAgKHtAbGluayBOZW8uZ3JpZC5oZWFkZXIuVG9vbGJhcn0pOiBNYW5hZ2VzIGNvbHVtbiBoZWFkZXJzLCBzb3J0aW5nLCBhbmQgZmlsdGVyaW5nIFVJLlxuICogMi4gIGBib2R5YCAoe0BsaW5rIE5lby5ncmlkLkJvZHl9KTogVGhlIHNjcm9sbGFibGUgYXJlYSBjb250YWluaW5nIHRoZSBkYXRhIHJvd3MuXG4gKiAzLiAgYHNjcm9sbGJhcmAgKHtAbGluayBOZW8uZ3JpZC5WZXJ0aWNhbFNjcm9sbGJhcn0pOiBBIHZpcnR1YWxpemVkIHNjcm9sbGJhciBmb3IgaGFuZGxpbmcgbGFyZ2UgZGF0YXNldHMuXG4gKlxuICogS2V5IGZlYXR1cmVzIGluY2x1ZGU6XG4gKiAtICAgKipWaXJ0dWFsIFNjcm9sbGluZzoqKiBPbmx5IHJlbmRlcnMgdmlzaWJsZSByb3dzIGFuZCBjb2x1bW5zIChwbHVzIGEgc21hbGwgYnVmZmVyKSBmb3IgaGlnaCBwZXJmb3JtYW5jZSB3aXRoIGxhcmdlIGRhdGFzZXRzLlxuICogLSAgICoqU3RvcmUgSW50ZWdyYXRpb246KiogQmluZHMgZGlyZWN0bHkgdG8gYSB7QGxpbmsgTmVvLmRhdGEuU3RvcmV9IGZvciBkYXRhIG1hbmFnZW1lbnQsIHNvcnRpbmcsIGFuZCBmaWx0ZXJpbmcuXG4gKiAtICAgKipDb2x1bW4gTWFuYWdlbWVudDoqKiBTdXBwb3J0cyB2YXJpb3VzIGNvbHVtbiB0eXBlcyAodGV4dCwgY29tcG9uZW50LCB3aWRnZXQpIHZpYSB0aGUgYGNvbHVtbnNgIGNvbmZpZy5cbiAqIC0gICAqKk11bHRpLVRocmVhZGVkOioqIExvZ2ljIHJ1bnMgaW4gdGhlIEFwcCBXb3JrZXIsIGVuc3VyaW5nIHRoZSBVSSBzdGF5cyByZXNwb25zaXZlLlxuICpcbiAqIEBjbGFzcyBOZW8uZ3JpZC5Db250YWluZXJcbiAqIEBleHRlbmRzIE5lby5jb250YWluZXIuQmFzZVxuICogQHNlZSBOZW8uZ3JpZC5Cb2R5XG4gKiBAc2VlIE5lby5ncmlkLlJvd1xuICogQHNlZSBOZW8uZGF0YS5TdG9yZVxuICovXG5jbGFzcyBHcmlkQ29udGFpbmVyIGV4dGVuZHMgQmFzZUNvbnRhaW5lciB7XG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBjb2x1bW5UeXBlc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGNvbHVtblR5cGVzID0ge1xuICAgICAgICBhbmltYXRlZENoYW5nZSAgOiBjb2x1bW4uQW5pbWF0ZWRDaGFuZ2UsXG4gICAgICAgIGFuaW1hdGVkQ3VycmVuY3k6IGNvbHVtbi5BbmltYXRlZEN1cnJlbmN5LFxuICAgICAgICBjb2x1bW4gICAgICAgICAgOiBjb2x1bW4uQmFzZSxcbiAgICAgICAgY29tcG9uZW50ICAgICAgIDogY29sdW1uLkNvbXBvbmVudCxcbiAgICAgICAgY291bnRyeUZsYWcgICAgIDogY29sdW1uLkNvdW50cnlGbGFnLFxuICAgICAgICBjdXJyZW5jeSAgICAgICAgOiBjb2x1bW4uQ3VycmVuY3ksXG4gICAgICAgIGdpdGh1Yk9yZ3MgICAgICA6IGNvbHVtbi5HaXRIdWJPcmdzLFxuICAgICAgICBnaXRodWJVc2VyICAgICAgOiBjb2x1bW4uR2l0SHViVXNlcixcbiAgICAgICAgaWNvbiAgICAgICAgICAgIDogY29sdW1uLkljb24sXG4gICAgICAgIGljb25MaW5rICAgICAgICA6IGNvbHVtbi5JY29uTGluayxcbiAgICAgICAgaW5kZXggICAgICAgICAgIDogY29sdW1uLkluZGV4LFxuICAgICAgICBsaW5rZWRpbiAgICAgICAgOiBjb2x1bW4uTGlua2VkSW4sXG4gICAgICAgIHByb2dyZXNzICAgICAgICA6IGNvbHVtbi5Qcm9ncmVzcyxcbiAgICAgICAgc3BhcmtsaW5lICAgICAgIDogY29sdW1uLlNwYXJrbGluZVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGRlbGF5YWJsZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGRlbGF5YWJsZSA9IHtcbiAgICAgICAgb25SZXNpemU6IHt0eXBlOiAnYnVmZmVyJywgdGltZXI6IDMwMH1cbiAgICB9XG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5ncmlkLkNvbnRhaW5lcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmdyaWQuQ29udGFpbmVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2dyaWQtY29udGFpbmVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2dyaWQtY29udGFpbmVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWdyaWQtY29udGFpbmVyJ11cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tZ3JpZC1jb250YWluZXInXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbmZpZ3MgZm9yIE5lby5ncmlkLkJvZHlcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IFtib2R5Xz17W2lzRGVzY3JpcHRvcl06IHRydWUsIG1lcmdlOiAnZGVlcCcsIHZhbHVlOiBudWxsfV1cbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBib2R5Xzoge1xuICAgICAgICAgICAgW2lzRGVzY3JpcHRvcl06IHRydWUsXG4gICAgICAgICAgICBtZXJnZSAgICAgICAgIDogJ2RlZXAnLFxuICAgICAgICAgICAgdmFsdWUgICAgICAgICA6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRydWUgdXNlcyBncmlkLnBsdWdpbi5DZWxsRWRpdGluZ1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBjZWxsRWRpdGluZ189ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBjZWxsRWRpdGluZ186IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogRGVmYXVsdCBjb25maWdzIGZvciBlYWNoIGNvbHVtblxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGNvbHVtbkRlZmF1bHRzPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGNvbHVtbkRlZmF1bHRzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0W119IGNvbHVtbnNfPVtdXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgY29sdW1uc186IFtdLFxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uZmlncyBmb3IgTmVvLnRvb2xiYXIuQmFzZVxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gW2Zvb3RlclRvb2xiYXJfPXtbaXNEZXNjcmlwdG9yXTp0cnVlLG1lcmdlOidkZWVwJyx2YWx1ZTpudWxsfV1cbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBmb290ZXJUb29sYmFyXzoge1xuICAgICAgICAgICAgW2lzRGVzY3JpcHRvcl06IHRydWUsXG4gICAgICAgICAgICBtZXJnZSAgICAgICAgIDogJ2RlZXAnLFxuICAgICAgICAgICAgdmFsdWUgICAgICAgICA6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbmZpZ3MgZm9yIE5lby5ncmlkLmhlYWRlci5Ub29sYmFyXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBbaGVhZGVyVG9vbGJhcl89e1tpc0Rlc2NyaXB0b3JdOnRydWUsbWVyZ2U6J2RlZXAnLHZhbHVlOm51bGx9XVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGhlYWRlclRvb2xiYXJfOiB7XG4gICAgICAgICAgICBbaXNEZXNjcmlwdG9yXTogdHJ1ZSxcbiAgICAgICAgICAgIG1lcmdlICAgICAgICAgOiAnZGVlcCcsXG4gICAgICAgICAgICB2YWx1ZSAgICAgICAgIDogbnVsbFxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBsYXlvdXQ9e250eXBlOiAndmJveCcsIGFsaWduOiAnc3RyZXRjaCd9XG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbGF5b3V0OiB7bnR5cGU6ICd2Ym94JywgYWxpZ246ICdzdHJldGNoJ30sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHJvbGU9J2dyaWQnXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgcm9sZTogJ2dyaWQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogTnVtYmVyIGluIHB4XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gcm93SGVpZ2h0Xz0zMlxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHJvd0hlaWdodF86IDMyLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmdyaWQuU2Nyb2xsYmFyfG51bGx9IHNjcm9sbGJhcj1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNjcm9sbGJhcjogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNob3dIZWFkZXJGaWx0ZXJzXz1mYWxzZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHNob3dIZWFkZXJGaWx0ZXJzXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzb3J0YWJsZV89dHJ1ZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHNvcnRhYmxlXzogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHVzZUludGVybmFsSWRfPXRydWVcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB1c2VJbnRlcm5hbElkXzogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgZW5hYmxlcyByZXN0b3JpbmcgdGhlIGluaXRpYWwgc29ydCBzdGF0ZSAoQVNDLCBERVNDLCBudWxsKVxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB1c2VUcmlTdGF0ZVNvcnRpbmdfPWZhbHNlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdXNlVHJpU3RhdGVTb3J0aW5nXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZGF0YS5TdG9yZX0gc3RvcmVfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzdG9yZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheXxudWxsfSBpdGVtcz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtczogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gX3Zkb21cbiAgICAgICAgICovXG4gICAgICAgIF92ZG9tOlxuICAgICAgICB7Y2xzOiBbJ25lby1ncmlkLXdyYXBwZXInXSwgY246IFtcbiAgICAgICAgICAgIHsnYXJpYS1jb2xjb3VudCc6IDAsICdhcmlhLXJvd2NvdW50JzogMSwgY246IFtdfSAvLyBhcmlhLXJvd2NvdW50IGluY2x1ZGVzIHRoZSBjb2x1bW4gaGVhZGVyc1xuICAgICAgICBdfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdlIGRvIG5vdCBuZWVkIHRoZSBmaXJzdCBldmVudCB0byB0cmlnZ2VyIGxvZ2ljLCBzaW5jZSBhZnRlclNldE1vdW50ZWQoKSBoYW5kbGVzIHRoaXNcbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpbml0aWFsUmVzaXplRXZlbnQ9dHJ1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpbml0aWFsUmVzaXplRXZlbnQgPSB0cnVlXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7TmVvLmdyaWQuU2Nyb2xsTWFuYWdlcnxudWxsfSBzY3JvbGxNYW5hZ2VyPW51bGxcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2Nyb2xsTWFuYWdlciA9IG51bGxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICB7YXBwTmFtZSwgcm93SGVpZ2h0LCBzdG9yZSwgd2luZG93SWR9ID0gbWU7XG5cbiAgICAgICAgbWUuaXRlbXMgPSBbbWUuaGVhZGVyVG9vbGJhciwgbWUuYm9keV07XG5cbiAgICAgICAgaWYgKG1lLmZvb3RlclRvb2xiYXIpIHtcbiAgICAgICAgICAgIG1lLml0ZW1zLnB1c2gobWUuZm9vdGVyVG9vbGJhcilcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnNjcm9sbGJhciA9IE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgbW9kdWxlICA6IFZlcnRpY2FsU2Nyb2xsYmFyLFxuICAgICAgICAgICAgYXBwTmFtZSxcbiAgICAgICAgICAgIHBhcmVudElkOiBtZS5pZCxcbiAgICAgICAgICAgIHJvd0hlaWdodCxcbiAgICAgICAgICAgIHN0b3JlLFxuICAgICAgICAgICAgdGhlbWUgICA6IG1lLnRoZW1lLFxuICAgICAgICAgICAgd2luZG93SWRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUudmRvbS5jbi5wdXNoKG1lLnNjcm9sbGJhci5jcmVhdGVWZG9tUmVmZXJlbmNlKCkpXG5cbiAgICAgICAgbWUudmRvbS5pZCA9IG1lLmdldFdyYXBwZXJJZCgpO1xuXG4gICAgICAgIG1lLl9jb2x1bW5zID0gbWUuY3JlYXRlQ29sdW1ucyhtZS5jb2x1bW5zKTtcbiAgICAgICAgbWUudXBkYXRlQ29sQ291bnQoKTtcblxuICAgICAgICBtZS5hZGREb21MaXN0ZW5lcnMoe1xuICAgICAgICAgICAgcmVzaXplOiBtZS5vblJlc2l6ZSxcbiAgICAgICAgICAgIHNjb3BlIDogbWVcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG1vdW50ZWRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYXN5bmMgYWRkUmVzaXplT2JzZXJ2ZXIobW91bnRlZCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3dpbmRvd0lkfSAgICAgPSBtZSxcbiAgICAgICAgICAgIFJlc2l6ZU9ic2VydmVyID0gYXdhaXQgTmVvLmN1cnJlbnRXb3JrZXIuZ2V0QWRkb24oJ1Jlc2l6ZU9ic2VydmVyJywgd2luZG93SWQpLFxuICAgICAgICAgICAgcmVzaXplUGFyYW1zICAgPSB7aWQ6IG1lLmlkLCB3aW5kb3dJZH07XG5cbiAgICAgICAgaWYgKG1vdW50ZWQpIHtcbiAgICAgICAgICAgIFJlc2l6ZU9ic2VydmVyLnJlZ2lzdGVyKHJlc2l6ZVBhcmFtcyk7XG4gICAgICAgICAgICBhd2FpdCBtZS5wYXNzU2l6ZVRvQm9keSgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5pbml0aWFsUmVzaXplRXZlbnQgPSB0cnVlO1xuICAgICAgICAgICAgUmVzaXplT2JzZXJ2ZXIudW5yZWdpc3RlcihyZXNpemVQYXJhbXMpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGNlbGxFZGl0aW5nIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Q2VsbEVkaXRpbmcodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgaW1wb3J0KCcuL3BsdWdpbi9DZWxsRWRpdGluZy5tanMnKS50aGVuKG1vZHVsZSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIHthcHBOYW1lfSA9IG1lLFxuICAgICAgICAgICAgICAgICAgICBwbHVnaW5zICAgPSBtZS5wbHVnaW5zIHx8IFtdO1xuXG4gICAgICAgICAgICAgICAgcGx1Z2lucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlOiBtb2R1bGUuZGVmYXVsdCxcbiAgICAgICAgICAgICAgICAgICAgYXBwTmFtZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgbWUucGx1Z2lucyA9IHBsdWdpbnNcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGNvbHVtbnMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOZW8uY29sbGVjdGlvbi5CYXNlfG51bGx9ICAgICAgICAgIHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3RbXXxOZW8uY29sbGVjdGlvbi5CYXNlfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIGFmdGVyU2V0Q29sdW1ucyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7aGVhZGVyVG9vbGJhcn0gPSBtZTtcblxuICAgICAgICAvLyAtIElmIGNvbHVtbnMgY2hhbmdlZCBhdCBydW4tdGltZSBPUlxuICAgICAgICAvLyAtIEluIGNhc2UgdGhlIGBoZWFkZXIuVG9vbGJhciNjcmVhdGVJdGVtcygpYCBtZXRob2QgaGFzIHJ1biBiZWZvcmUgY29sdW1ucyB3aGVyZSBhdmFpbGFibGVcbiAgICAgICAgaWYgKG9sZFZhbHVlPy5jb3VudCB8fCAodmFsdWU/LmNvdW50ICYmIGhlYWRlclRvb2xiYXI/LmlzQ29uc3RydWN0ZWQpKSB7XG4gICAgICAgICAgICBoZWFkZXJUb29sYmFyPy5jcmVhdGVJdGVtcygpXG5cbiAgICAgICAgICAgIGF3YWl0IG1lLnRpbWVvdXQoNTApO1xuXG4gICAgICAgICAgICBhd2FpdCBtZS5wYXNzU2l6ZVRvQm9keSgpO1xuXG4gICAgICAgICAgICBtZS5ib2R5Py5jcmVhdGVWaWV3RGF0YSgpXG4gICAgICAgIH1cblxuICAgICAgICBtZS5jb25maWdzQXBwbGllZCAmJiBtZS51cGRhdGVDb2xDb3VudCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBmb290ZXJUb29sYmFyIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TmVvLnRvb2xiYXIuQmFzZX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby50b29sYmFyLkJhc2V9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Rm9vdGVyVG9vbGJhcih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAodmFsdWUgJiYgbWUuc3RvcmUgJiYgdmFsdWUuc3RvcmUgIT09IG1lLnN0b3JlKSB7XG4gICAgICAgICAgICB2YWx1ZS5zdG9yZSA9IG1lLnN0b3JlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1vdW50ZWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgb2xkVmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmFkZFJlc2l6ZU9ic2VydmVyKHZhbHVlKTtcblxuICAgICAgICBsZXQge3Njcm9sbE1hbmFnZXJ9ID0gdGhpcztcblxuICAgICAgICBpZiAoc2Nyb2xsTWFuYWdlcikge1xuICAgICAgICAgICAgc2Nyb2xsTWFuYWdlci5tb3VudGVkID0gdmFsdWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcm93SGVpZ2h0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFJvd0hlaWdodCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID4gMCkge1xuICAgICAgICAgICAgbGV0IHtib2R5LCBzY3JvbGxiYXJ9ID0gdGhpcztcblxuICAgICAgICAgICAgaWYgKHNjcm9sbGJhcikge1xuICAgICAgICAgICAgICAgIHNjcm9sbGJhci5yb3dIZWlnaHQgPSB2YWx1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYm9keSkge1xuICAgICAgICAgICAgICAgIGJvZHkucm93SGVpZ2h0ID0gdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc2hvd0hlYWRlckZpbHRlcnMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTaG93SGVhZGVyRmlsdGVycyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyVG9vbGJhci5zaG93SGVhZGVyRmlsdGVycyA9IHZhbHVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNvcnRhYmxlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U29ydGFibGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlclRvb2xiYXIuc29ydGFibGUgPSB2YWx1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB1c2VUcmlTdGF0ZVNvcnRpbmcgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRVc2VUcmlTdGF0ZVNvcnRpbmcodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlclRvb2xiYXIudXNlVHJpU3RhdGVTb3J0aW5nID0gdmFsdWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc3RvcmUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U3RvcmUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgbGlzdGVuZXJzID0ge1xuICAgICAgICAgICAgICAgIGZpbHRlcjogbWUub25TdG9yZUZpbHRlcixcbiAgICAgICAgICAgICAgICBsb2FkICA6IG1lLm9uU3RvcmVMb2FkLFxuICAgICAgICAgICAgICAgIHNjb3BlIDogbWVcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgdmFsdWUgICA/Lm9uKGxpc3RlbmVycyk7XG4gICAgICAgIG9sZFZhbHVlPy51bihsaXN0ZW5lcnMpO1xuXG4gICAgICAgIC8vIGluIGNhc2Ugd2UgZHluYW1pY2FsbHkgY2hhbmdlIHRoZSBzdG9yZSwgZ3JpZC5Cb2R5IG5lZWRzIHRvIGdldCB0aGUgbmV3IHJlZmVyZW5jZVxuICAgICAgICBpZiAobWUuYm9keSkge1xuICAgICAgICAgICAgbWUuYm9keS5zdG9yZSA9IHZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWUuZm9vdGVyVG9vbGJhciAmJiBtZS5mb290ZXJUb29sYmFyLnN0b3JlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgbWUuZm9vdGVyVG9vbGJhci5zdG9yZSA9IHZhbHVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHVzZUludGVybmFsSWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRVc2VJbnRlcm5hbElkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMuYm9keS51c2VJbnRlcm5hbElkID0gdmFsdWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGJvZHkgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxOZW8uZ3JpZC5Cb2R5fG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R8TmVvLmdyaWQuQm9keXxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRCb2R5KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIENsYXNzU3lzdGVtVXRpbC5iZWZvcmVTZXRJbnN0YW5jZSh2YWx1ZSwgR3JpZEJvZHksIHtcbiAgICAgICAgICAgIGZsZXggICAgICAgICA6IDEsXG4gICAgICAgICAgICBncmlkQ29udGFpbmVyOiBtZSxcbiAgICAgICAgICAgIHBhcmVudElkICAgICA6IG1lLmlkLFxuICAgICAgICAgICAgc3RvcmUgICAgICAgIDogbWUuc3RvcmUsXG4gICAgICAgICAgICB0aGVtZSAgICAgICAgOiBtZS50aGVtZSxcbiAgICAgICAgICAgIHVzZUludGVybmFsSWQ6IG1lLnVzZUludGVybmFsSWRcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBjb2x1bW5zIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRDb2x1bW5zKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5jb25maWdzQXBwbGllZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ29sdW1ucyh2YWx1ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUuZm9vdGVyVG9vbGJhciBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fE5lby50b29sYmFyLkJhc2V8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxOZW8udG9vbGJhci5CYXNlfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge05lby50b29sYmFyLkJhc2V8bnVsbH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0Rm9vdGVyVG9vbGJhcih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBDbGFzc1N5c3RlbVV0aWwuYmVmb3JlU2V0SW5zdGFuY2UodmFsdWUsIEZvb3RlclRvb2xiYXIsIHtcbiAgICAgICAgICAgIGZsZXggICAgOiAnbm9uZScsXG4gICAgICAgICAgICBwYXJlbnRJZDogbWUuaWQsXG4gICAgICAgICAgICB0aGVtZSAgIDogbWUudGhlbWVcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBoZWFkZXJUb29sYmFyIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R8TmVvLmdyaWQuaGVhZGVyLlRvb2xiYXJ8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxOZW8uZ3JpZC5oZWFkZXIuVG9vbGJhcnxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtOZW8udG9vbGJhci5CYXNlfG51bGx9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldEhlYWRlclRvb2xiYXIodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lID0gdGhpcztcblxuICAgICAgICByZXR1cm4gQ2xhc3NTeXN0ZW1VdGlsLmJlZm9yZVNldEluc3RhbmNlKHZhbHVlLCBoZWFkZXIuVG9vbGJhciwge1xuICAgICAgICAgICAgZmxleCAgICAgICAgICAgICAgOiAnbm9uZScsXG4gICAgICAgICAgICBwYXJlbnRJZCAgICAgICAgICA6IG1lLmlkLFxuICAgICAgICAgICAgc2hvd0hlYWRlckZpbHRlcnMgOiBtZS5zaG93SGVhZGVyRmlsdGVycyxcbiAgICAgICAgICAgIHNvcnRhYmxlICAgICAgICAgIDogbWUuc29ydGFibGUsXG4gICAgICAgICAgICB0aGVtZSAgICAgICAgICAgICA6IG1lLnRoZW1lLFxuICAgICAgICAgICAgdXNlVHJpU3RhdGVTb3J0aW5nOiBtZS51c2VUcmlTdGF0ZVNvcnRpbmdcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBzdG9yZSBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fE5lby5kYXRhLlN0b3JlfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5TdG9yZX0gICAgICAgICAgICAgb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0U3RvcmUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBDbGFzc1N5c3RlbVV0aWwuYmVmb3JlU2V0SW5zdGFuY2UodmFsdWUsIFN0b3JlKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW4gY2FzZSB5b3Ugd2FudCB0byB1cGRhdGUgbXVsdGlwbGUgZXhpc3RpbmcgcmVjb3JkcyBpbiBwYXJhbGxlbCxcbiAgICAgKiB1c2luZyB0aGlzIG1ldGhvZCBpcyBmYXN0ZXIgdGhhbiB1cGRhdGluZyBlYWNoIHJlY29yZCBvbmUgYnkgb25lLlxuICAgICAqIEF0IGxlYXN0IHVudGlsIHdlIGludHJvZHVjZSByb3cgYmFzZWQgdmRvbSB1cGRhdGVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IHJlY29yZHNcbiAgICAgKi9cbiAgICBidWxrVXBkYXRlUmVjb3JkcyhyZWNvcmRzKSB7XG4gICAgICAgIGxldCB7Ym9keSwgc3RvcmV9ID0gdGhpcyxcbiAgICAgICAgICAgIHtrZXlQcm9wZXJ0eX0gPSBzdG9yZTtcblxuICAgICAgICBpZiAoYm9keSkge1xuICAgICAgICAgICAgYm9keS5zaWxlbnRWZG9tVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHJlY29yZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzdG9yZS5nZXQocmVjb3Jkc1tpXVtrZXlQcm9wZXJ0eV0pPy5zZXQocmVjb3Jkc1tpXSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYm9keS5zaWxlbnRWZG9tVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGJvZHkudXBkYXRlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGNvbHVtbnNcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBjcmVhdGVDb2x1bW5zKGNvbHVtbnMpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2NvbHVtbkRlZmF1bHRzfSA9IG1lLFxuICAgICAgICAgICAgaGVhZGVyQnV0dG9ucyAgICA9IFtdLFxuICAgICAgICAgICAgc29ydGVycyAgICAgICAgICA9IG1lLnN0b3JlPy5zb3J0ZXJzLFxuICAgICAgICAgICAgY29sdW1uQ2xhc3MsIHJlbmRlcmVyO1xuXG4gICAgICAgIGlmIChjb2x1bW5zKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDAsIGxlbiA9IGNvbHVtbnMubGVuZ3RoOyBpbmRleCA8IGxlbjsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGxldCBjb2x1bW4gPSBjb2x1bW5zW2luZGV4XTtcbiAgICAgICAgICAgICAgICByZW5kZXJlciA9IGNvbHVtbi5yZW5kZXJlcjtcblxuICAgICAgICAgICAgICAgIGNvbHVtbkRlZmF1bHRzICYmIE5lby5hc3NpZ25EZWZhdWx0cyhjb2x1bW4sIGNvbHVtbkRlZmF1bHRzKTtcblxuICAgICAgICAgICAgICAgIGlmIChyZW5kZXJlciAmJiBOZW8uaXNTdHJpbmcocmVuZGVyZXIpICYmIG1lW3JlbmRlcmVyXSkge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4ucmVuZGVyZXIgPSBtZVtyZW5kZXJlcl1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc29ydGVycz8uWzBdICYmIGNvbHVtbi5kYXRhRmllbGQgPT09IHNvcnRlcnNbMF0ucHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uLmlzU29ydGVkID0gc29ydGVyc1swXS5kaXJlY3Rpb25cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb2x1bW4ubGlzdGVuZXJzID0ge1xuICAgICAgICAgICAgICAgICAgICBzb3J0IDogbWUub25Tb3J0Q29sdW1uLFxuICAgICAgICAgICAgICAgICAgICBzY29wZTogbWVcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaGVhZGVyQnV0dG9ucy5wdXNoKGNvbHVtbik7XG5cbiAgICAgICAgICAgICAgICBpZiAoY29sdW1uLmNvbXBvbmVudCAmJiAhY29sdW1uLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uLnR5cGUgPSAnY29tcG9uZW50J1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbHVtbkNsYXNzID0gbWUuY29uc3RydWN0b3IuY29sdW1uVHlwZXNbY29sdW1uLnR5cGUgfHwgJ2NvbHVtbiddO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBjb2x1bW4udHlwZTtcblxuICAgICAgICAgICAgICAgIGNvbHVtbnNbaW5kZXhdID0gTmVvLmNyZWF0ZShjb2x1bW5DbGFzcywge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQgIDogbWUsXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0lkOiBtZS53aW5kb3dJZCxcbiAgICAgICAgICAgICAgICAgICAgLi4uY29sdW1uXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmhlYWRlclRvb2xiYXIuaXRlbXMgPSBoZWFkZXJCdXR0b25zO1xuICAgICAgICBtZS5oZWFkZXJUb29sYmFyLmNyZWF0ZUl0ZW1zKCk7XG5cbiAgICAgICAgaWYgKE5lby50eXBlT2YobWUuX2NvbHVtbnMpID09PSAnTmVvSW5zdGFuY2UnKSB7XG4gICAgICAgICAgICBtZS5fY29sdW1ucy5jbGVhcigpO1xuICAgICAgICAgICAgbWUuX2NvbHVtbnMuYWRkKGNvbHVtbnMpO1xuXG4gICAgICAgICAgICByZXR1cm4gbWUuX2NvbHVtbnNcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBOZW8uY3JlYXRlKENvbGxlY3Rpb24sIHtcbiAgICAgICAgICAgIGtleVByb3BlcnR5OiAnZGF0YUZpZWxkJyxcbiAgICAgICAgICAgIGl0ZW1zICAgICAgOiBjb2x1bW5zLFxuICAgICAgICAgICAgbGlzdGVuZXJzICA6IHttdXRhdGU6IG1lLm9uQ29sdW1uc011dGF0ZSwgc2NvcGU6IG1lfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICovXG4gICAgZGVzdHJveSguLi5hcmdzKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuc3RvcmUgPSBudWxsOyAvLyByZW1vdmUgdGhlIGxpc3RlbmVyc1xuXG4gICAgICAgIG1lLnNjcm9sbE1hbmFnZXIuZGVzdHJveSgpO1xuXG4gICAgICAgIG1lLm1vdW50ZWQgJiYgTmVvLm1haW4uYWRkb24uUmVzaXplT2JzZXJ2ZXIudW5yZWdpc3Rlcih7XG4gICAgICAgICAgICBpZCAgICAgIDogbWUuaWQsXG4gICAgICAgICAgICB3aW5kb3dJZDogbWUud2luZG93SWRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc3VwZXIuZGVzdHJveSguLi5hcmdzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFZkb21Sb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZG9tLmNuWzBdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHJldHVybnMge05lby52ZG9tLlZOb2RlfVxuICAgICAqL1xuICAgIGdldFZub2RlUm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudm5vZGUuY2hpbGROb2Rlc1swXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0V3JhcHBlcklkKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5pZH1fX3dyYXBwZXJgXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkNvbHVtbnNNdXRhdGUoZGF0YSkge1xuICAgICAgICB0aGlzLnVwZGF0ZUNvbENvdW50KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIHN1cGVyLm9uQ29uc3RydWN0ZWQoKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnNjcm9sbE1hbmFnZXIgPSBOZW8uY3JlYXRlKHtcbiAgICAgICAgICAgIGdyaWRCb2R5ICAgICA6IG1lLmJvZHksXG4gICAgICAgICAgICBtb2R1bGUgICAgICAgOiBTY3JvbGxNYW5hZ2VyLFxuICAgICAgICAgICAgZ3JpZENvbnRhaW5lcjogbWVcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIG9uUmVzaXplKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIW1lLmluaXRpYWxSZXNpemVFdmVudCkge1xuICAgICAgICAgICAgYXdhaXQgbWUucGFzc1NpemVUb0JvZHkodHJ1ZSk7XG5cbiAgICAgICAgICAgIG1lLmJvZHkudXBkYXRlTW91bnRlZEFuZFZpc2libGVDb2x1bW5zKCk7XG5cbiAgICAgICAgICAgIGF3YWl0IG1lLmhlYWRlclRvb2xiYXIucGFzc1NpemVUb0JvZHkoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUuaW5pdGlhbFJlc2l6ZUV2ZW50ID0gZmFsc2VcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25TY3JvbGxDYXB0dXJlKGRhdGEpIHtcbiAgICAgICAgc3VwZXIub25TY3JvbGxDYXB0dXJlKGRhdGEpO1xuICAgICAgICB0aGlzLnNjcm9sbE1hbmFnZXIub25Db250YWluZXJTY3JvbGwoZGF0YSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRzLmRpcmVjdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRzLnByb3BlcnR5XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uU29ydENvbHVtbihvcHRzKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuc3RvcmUuc29ydChvcHRzKTtcbiAgICAgICAgbWUucmVtb3ZlU29ydGluZ0NzcyhvcHRzLnByb3BlcnR5KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25TdG9yZUZpbHRlcigpIHtcbiAgICAgICAgdGhpcy51cGRhdGVSb3dDb3VudCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGEuaXRlbXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gICBbZGF0YS50b3RhbF1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25TdG9yZUxvYWQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB0b3RhbENvdW50ID0gZGF0YS50b3RhbCA/IGRhdGEudG90YWwgOiB0aGlzLnN0b3JlLmNvdW50O1xuXG4gICAgICAgIG1lLnVwZGF0ZVJvd0NvdW50KHRvdGFsQ291bnQpO1xuXG4gICAgICAgIGlmIChtZS5zdG9yZS5zb3J0ZXJzPy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICBtZS5yZW1vdmVTb3J0aW5nQ3NzKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50PWZhbHNlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYXN5bmMgcGFzc1NpemVUb0JvZHkoc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtmb290ZXJUb29sYmFyLCBoZWFkZXJUb29sYmFyfSA9IG1lLFxuICAgICAgICAgICAgZG9tUmVjdHMgICAgICA9IFttZS5pZCwgaGVhZGVyVG9vbGJhci5pZF0sXG4gICAgICAgICAgICBjb250YWluZXJSZWN0LCBmb290ZXJSZWN0LCBoZWFkZXJSZWN0O1xuXG4gICAgICAgIGlmIChmb290ZXJUb29sYmFyKSB7XG4gICAgICAgICAgICBkb21SZWN0cy5wdXNoKGZvb3RlclRvb2xiYXIuaWQpXG4gICAgICAgIH1cblxuICAgICAgICBbY29udGFpbmVyUmVjdCwgaGVhZGVyUmVjdCwgZm9vdGVyUmVjdF0gPSBhd2FpdCBtZS5nZXREb21SZWN0KGRvbVJlY3RzKTtcblxuICAgICAgICAvLyBkZWxheSBmb3Igc2xvdyBjb25uZWN0aW9ucywgd2hlcmUgdGhlIGNvbnRhaW5lci1zaXppbmcgaXMgbm90IGRvbmUgeWV0XG4gICAgICAgIGlmIChjb250YWluZXJSZWN0LmhlaWdodCA9PT0gaGVhZGVyUmVjdC5oZWlnaHQpIHtcbiAgICAgICAgICAgIGF3YWl0IG1lLnRpbWVvdXQoMTAwKTtcbiAgICAgICAgICAgIGF3YWl0IG1lLnBhc3NTaXplVG9Cb2R5KHNpbGVudClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLmJvZHlbc2lsZW50ID8gJ3NldFNpbGVudCcgOiAnc2V0J10oe1xuICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodDogY29udGFpbmVyUmVjdC5oZWlnaHQgLSBoZWFkZXJSZWN0LmhlaWdodCAtIChmb290ZXJSZWN0Py5oZWlnaHQgfHwgMCksXG4gICAgICAgICAgICAgICAgY29udGFpbmVyV2lkdGggOiBjb250YWluZXJSZWN0LndpZHRoXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFGaWVsZFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICByZW1vdmVTb3J0aW5nQ3NzKGRhdGFGaWVsZCkge1xuICAgICAgICBsZXQgaXRlbXMgPSB0aGlzLmhlYWRlclRvb2xiYXI/Lml0ZW1zO1xuICAgICAgICBpZiAoaXRlbXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtc1tpXS5kYXRhRmllbGQgIT09IGRhdGFGaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtc1tpXS5yZW1vdmVTb3J0aW5nQ3NzKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBrZXlib2FyZCBuYXZpZ2F0aW9uIChzZWxlY3Rpb24gbW9kZWxzKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGVwXG4gICAgICovXG4gICAgc2Nyb2xsQnlDb2x1bW5zKGluZGV4LCBzdGVwKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2JvZHl9ICAgICAgID0gbWUsXG4gICAgICAgICAgICB7Y29sdW1uUG9zaXRpb25zLCBjb250YWluZXJXaWR0aCwgbW91bnRlZENvbHVtbnMsIHZpc2libGVDb2x1bW5zfSA9IGJvZHksXG4gICAgICAgICAgICBjb3VudENvbHVtbnMgPSBjb2x1bW5Qb3NpdGlvbnMuZ2V0Q291bnQoKSxcbiAgICAgICAgICAgIG5ld0luZGV4ICAgICA9IGluZGV4ICsgc3RlcCxcbiAgICAgICAgICAgIGNvbHVtbiwgbW91bnRlZCwgc2Nyb2xsTGVmdCwgdmlzaWJsZTtcblxuICAgICAgICBpZiAobmV3SW5kZXggPj0gY291bnRDb2x1bW5zKSB7XG4gICAgICAgICAgICBuZXdJbmRleCAlPSBjb3VudENvbHVtbnM7XG4gICAgICAgICAgICBzdGVwICAgICA9IG5ld0luZGV4IC0gaW5kZXhcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChuZXdJbmRleCA8IDApIHtcbiAgICAgICAgICAgIG5ld0luZGV4ICs9IGNvdW50Q29sdW1ucztcbiAgICAgICAgICAgIHN0ZXAgICAgICs9IGNvdW50Q29sdW1uc1xuICAgICAgICB9XG5cbiAgICAgICAgbW91bnRlZCA9IG5ld0luZGV4ID49IG1vdW50ZWRDb2x1bW5zWzBdICYmIG5ld0luZGV4IDw9IG1vdW50ZWRDb2x1bW5zWzFdO1xuXG4gICAgICAgIC8vIE5vdCB1c2luZyA+PSBvciA8PSwgc2luY2UgdGhlIGZpcnN0IC8gbGFzdCBjb2x1bW4gbWlnaHQgbm90IGJlIGZ1bGx5IHZpc2libGVcbiAgICAgICAgdmlzaWJsZSA9IG5ld0luZGV4ID4gdmlzaWJsZUNvbHVtbnNbMF0gJiYgbmV3SW5kZXggPCB2aXNpYmxlQ29sdW1uc1sxXTtcblxuICAgICAgICBpZiAoIXZpc2libGUpIHtcbiAgICAgICAgICAgIC8vIExlYXZpbmcgdGhlIG1vdW50ZWQgYXJlYSB3aWxsIHJlLWNhbGN1bGF0ZSB0aGUgdmlzaWJsZUNvbHVtbnMgZm9yIHVzXG4gICAgICAgICAgICBpZiAobW91bnRlZCkge1xuICAgICAgICAgICAgICAgIHZpc2libGVDb2x1bW5zWzBdICs9IHN0ZXA7XG4gICAgICAgICAgICAgICAgdmlzaWJsZUNvbHVtbnNbMV0gKz0gc3RlcFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb2x1bW4gPSBjb2x1bW5Qb3NpdGlvbnMuZ2V0QXQobmV3SW5kZXgpO1xuXG4gICAgICAgICAgICBpZiAoc3RlcCA8IDApIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxMZWZ0ID0gY29sdW1uLnhcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsTGVmdCA9IGNvbHVtbi54IC0gY29udGFpbmVyV2lkdGggKyBjb2x1bW4ud2lkdGhcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgTmVvLm1haW4uRG9tQWNjZXNzLnNjcm9sbFRvKHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdsZWZ0JyxcbiAgICAgICAgICAgICAgICBpZCAgICAgICA6IG1lLmdldFZkb21Sb290KCkuaWQsXG4gICAgICAgICAgICAgICAgdmFsdWUgICAgOiBzY3JvbGxMZWZ0LFxuICAgICAgICAgICAgICAgIHdpbmRvd0lkIDogbWUud2luZG93SWRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIHRoZSBpbnN0YW5jZSBpbnRvIGEgSlNPTi1jb21wYXRpYmxlIG9iamVjdCBmb3IgdGhlIE5ldXJhbCBMaW5rLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcbiAgICAgICAgICAgIGJvZHkgICAgICAgICAgICAgOiBtZS5ib2R5Py50b0pTT04oKSxcbiAgICAgICAgICAgIGNlbGxFZGl0aW5nICAgICAgOiBtZS5jZWxsRWRpdGluZyxcbiAgICAgICAgICAgIGNvbHVtbnMgICAgICAgICAgOiBtZS5jb2x1bW5zPy5pdGVtcy5tYXAoaXRlbSA9PiBpdGVtLnRvSlNPTigpKSxcbiAgICAgICAgICAgIGZvb3RlclRvb2xiYXIgICAgOiBtZS5mb290ZXJUb29sYmFyPy50b0pTT04oKSxcbiAgICAgICAgICAgIGhlYWRlclRvb2xiYXIgICAgOiBtZS5oZWFkZXJUb29sYmFyPy50b0pTT04oKSxcbiAgICAgICAgICAgIHJvd0hlaWdodCAgICAgICAgOiBtZS5yb3dIZWlnaHQsXG4gICAgICAgICAgICBzY3JvbGxiYXIgICAgICAgICA6IG1lLnNjcm9sbGJhcj8udG9KU09OKCksXG4gICAgICAgICAgICBzY3JvbGxNYW5hZ2VyICAgICA6IG1lLnNjcm9sbE1hbmFnZXI/LnRvSlNPTigpLFxuICAgICAgICAgICAgc2hvd0hlYWRlckZpbHRlcnMgOiBtZS5zaG93SGVhZGVyRmlsdGVycyxcbiAgICAgICAgICAgIHNvcnRhYmxlICAgICAgICAgIDogbWUuc29ydGFibGUsXG4gICAgICAgICAgICBzdG9yZSAgICAgICAgICAgICA6IG1lLnN0b3JlPy50b0pTT04oKSxcbiAgICAgICAgICAgIHVzZVRyaVN0YXRlU29ydGluZzogbWUudXNlVHJpU3RhdGVTb3J0aW5nXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdXG4gICAgICovXG4gICAgdXBkYXRlQ29sQ291bnQoc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuZ2V0VmRvbVJvb3QoKVsnYXJpYS1jb2xjb3VudCddID0gbWUuY29sdW1ucy5jb3VudDtcbiAgICAgICAgIXNpbGVudCAmJiBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY291bnRdIFRoZSB0b3RhbCBudW1iZXIgb2Ygcm93cyBpbiB0aGUgc3RvcmUuIE9wdGlvbmFsLCB3aWxsIHVzZSBzdG9yZS5jb3VudCBpZiBub3QgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2lsZW50PWZhbHNlXVxuICAgICAqL1xuICAgIHVwZGF0ZVJvd0NvdW50KGNvdW50LCBzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZmluYWxDb3VudCA9IGNvdW50ID8gY291bnQgOiBtZS5zdG9yZS5jb3VudDtcblxuICAgICAgICBtZS5nZXRWZG9tUm9vdCgpWydhcmlhLXJvd2NvdW50J10gPSBmaW5hbENvdW50ICsgMTtcbiAgICAgICAgIXNpbGVudCAmJiBtZS51cGRhdGUoKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoR3JpZENvbnRhaW5lcik7XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudC9CYXNlLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgIGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcblxuLyoqXG4gKiBAc3VtbWFyeSBSZXByZXNlbnRzIGEgc2luZ2xlIHZpc2libGUgcm93IGluIHRoZSBHcmlkLlxuICpcbiAqIGBOZW8uZ3JpZC5Sb3dgIGlzIGEgc3BlY2lhbGl6ZWQgY29tcG9uZW50IGRlc2lnbmVkIGZvciB0aGUgKipSb3cgUG9vbGluZyoqIGFyY2hpdGVjdHVyZS5cbiAqIEl0IGlzIE5PVCBkZXN0cm95ZWQgd2hlbiBhIHJlY29yZCBzY3JvbGxzIG9mZi1zY3JlZW4uIEluc3RlYWQsIGl0IGlzICoqcmVjeWNsZWQqKjpcbiAqIGl0cyBgcmVjb3JkYCBhbmQgYHJvd0luZGV4YCBjb25maWdzIGFyZSB1cGRhdGVkIHRvIGRpc3BsYXkgbmV3IGRhdGEuXG4gKlxuICogKipGdWxsIFBvb2wgUmVuZGVyaW5nIFN0cmF0ZWd5OioqXG4gKiBUbyBlbnN1cmUgTygxKSBzY3JvbGxpbmcgcGVyZm9ybWFuY2UgYW5kIGVsaW1pbmF0ZSBHYXJiYWdlIENvbGxlY3Rpb24gKEdDKSBwYXVzZXMsIHRoaXMgY2xhc3NcbiAqIGltcGxlbWVudHMgYSBcIkZ1bGwgUG9vbCBSZW5kZXJpbmdcIiBzdHJhdGVneSBmb3IgY2VsbCBjb250ZW50LiBJdCByZW5kZXJzIGEgc3RhYmxlLCBmaXhlZC1zaXplXG4gKiBhcnJheSBvZiBjZWxsIG5vZGVzIG1hdGNoaW5nIGBncmlkQm9keS5jZWxsUG9vbFNpemVgLlxuICpcbiAqIC0gKipBY3RpdmUgQ2VsbHM6KiogQ2VsbHMgY29ycmVzcG9uZGluZyB0byB2aXNpYmxlIGNvbHVtbnMgYXJlIHJlbmRlcmVkIHdpdGggY29udGVudC5cbiAqIC0gKipJbmFjdGl2ZSBDZWxsczoqKiBTbG90cyBpbiB0aGUgcG9vbCBub3QgY3VycmVudGx5IG5lZWRlZCBieSBhIGNvbHVtbiBhcmUgcmVuZGVyZWQgYXNcbiAqICAgbGlnaHR3ZWlnaHQgcGxhY2Vob2xkZXJzIChgZGlzcGxheTogbm9uZWApLlxuICpcbiAqIFRoaXMgZ3VhcmFudGVlcyB0aGF0IHRoZSBWRE9NIHN0cnVjdHVyZSAodGhlIG51bWJlciBhbmQgb3JkZXIgb2YgY2hpbGQgbm9kZXMpICpuZXZlciBjaGFuZ2VzKlxuICogZHVyaW5nIGhvcml6b250YWwgc2Nyb2xsaW5nLiBUaGUgYnJvd3NlciBvbmx5IHByb2Nlc3NlcyBlZmZpY2llbnQgYXR0cmlidXRlIHVwZGF0ZXMgKHN0eWxlLCBjb250ZW50KSxcbiAqIHdpdGggKip6ZXJvKiogRE9NIG5vZGUgaW5zZXJ0aW9ucywgcmVtb3ZhbHMsIG9yIHJlb3JkZXJpbmcgb3BlcmF0aW9ucy5cbiAqXG4gKiAqKlNwbGl0IERhdGFzZXQgU3RyYXRlZ3k6KipcbiAqIFRvIHN1cHBvcnQgdGhlIEZpeGVkLURPTS1PcmRlciBzdHJhdGVneSBhbmQgcm9idXN0IGV2ZW50IGRlbGVnYXRpb24sIHRoaXMgY2xhc3MgcmVuZGVycyBzcGxpdCBkYXRhIGF0dHJpYnV0ZXNcbiAqIGluc3RlYWQgb2YgY29tcG9zaXRlIElEczpcbiAqXG4gKiAtIGBkYXRhLXJlY29yZC1pZGA6IFRoZSBzdGFibGUgSUQgb2YgdGhlIHJlY29yZCBjdXJyZW50bHkgYm91bmQgdG8gdGhpcyByb3cuXG4gKiAtIGBkYXRhLWZpZWxkYDogVGhlIGRhdGEgZmllbGQgbmFtZSBvZiB0aGUgY29sdW1uIChmb3IgY2VsbHMpLlxuICpcbiAqIFRoaXMgYXZvaWRzIHRoZSBuZWVkIGZvciBmcmFnaWxlIHN0cmluZyBwYXJzaW5nIChlLmcuIGBzcGxpdCgnX18nKWApIGluIGV2ZW50IGhhbmRsZXJzLlxuICpcbiAqIEtleSBSZXNwb25zaWJpbGl0aWVzOlxuICogLSAgICoqQ2VsbCBSZW5kZXJpbmc6KiogR2VuZXJhdGVzIHRoZSBWRE9NIGZvciBhbGwgY2VsbHMgaW4gdGhlIHJvdyBiYXNlZCBvbiB0aGUgY29sdW1ucyBjb25maWcuXG4gKiAtICAgKipHcmFudWxhciBVcGRhdGVzOioqIFdoZW4gYSBib3VuZCByZWNvcmQgY2hhbmdlcywgb25seSB0aGlzIHNwZWNpZmljIFJvdyBpbnN0YW5jZSB1cGRhdGVzIGl0cyBWRE9NLCBhdm9pZGluZyBhIGZ1bGwgR3JpZCByZS1yZW5kZXIuXG4gKiAtICAgKipDb21wb25lbnQgTWFuYWdlbWVudDoqKiBNYW5hZ2VzIHRoZSBsaWZlY3ljbGUgb2YgY2VsbCBjb21wb25lbnRzIChlLmcuLCBTcGFya2xpbmVzLCBXaWRnZXRzKSBkZWZpbmVkIGluIGBOZW8uZ3JpZC5jb2x1bW4uQ29tcG9uZW50YC5cbiAqXG4gKiBAY2xhc3MgTmVvLmdyaWQuUm93XG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqIEBzZWUgTmVvLmdyaWQuQm9keVxuICovXG5jbGFzcyBSb3cgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmdyaWQuUm93J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZ3JpZC5Sb3cnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nZ3JpZC1yb3cnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnZ3JpZC1yb3cnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tZ3JpZC1yb3cnXVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1ncmlkLXJvdyddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IHJlY29yZD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICByZWNvcmQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gcm93SW5kZXg9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgcm93SW5kZXg6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHVwZGF0ZURlcHRoPS0xXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVEZXB0aDogLTEsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IF92ZG9tPXtjbjogW119XG4gICAgICAgICAqL1xuICAgICAgICBfdmRvbTpcbiAgICAgICAge2NuOiBbXX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1vdW50ZWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBpZiAodGhpcy5jb21wb25lbnRzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLmNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudHNba2V5XS5tb3VudGVkID0gdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdGhlbWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFRoZW1lKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldFRoZW1lKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50cykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5jb21wb25lbnRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzW2tleV0udGhlbWUgPSB2YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIHRoZSBWRE9NIGNvbmZpZ3VyYXRpb24gZm9yIGEgc2luZ2xlIGNlbGwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZGF0YS5jZWxsSWRdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEuY29sdW1uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEuY29sdW1uSW5kZXhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkYXRhLmlzTGFzdENvbHVtbl0gVHJ1ZSBpZiB0aGlzIGlzIHRoZSB2aXN1YWxseSBsYXN0IGNvbHVtbiAoZm9yIGJvcmRlciBzdHlsaW5nKS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YS5yZWNvcmRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5yb3dJbmRleFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2RhdGEuc2lsZW50XVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFZET00gb2JqZWN0IGZvciB0aGUgY2VsbFxuICAgICAqL1xuICAgIGFwcGx5UmVuZGVyZXJPdXRwdXQoe2NlbGxJZCwgY29sdW1uLCBjb2x1bW5JbmRleCwgaXNMYXN0Q29sdW1uLCByZWNvcmQsIHJvd0luZGV4LCBzaWxlbnR9KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGdyaWRDb250YWluZXIgICAgICAgICAgPSBtZS5wYXJlbnQucGFyZW50LCAvLyBSb3cgLT4gQm9keSAtPiBHcmlkQ29udGFpbmVyXG4gICAgICAgICAgICBncmlkQm9keSAgICAgICAgICAgICAgID0gbWUucGFyZW50LFxuICAgICAgICAgICAge3NlbGVjdGVkQ2VsbHMsIHN0b3JlfSA9IGdyaWRCb2R5LFxuICAgICAgICAgICAgY2VsbENscyAgICAgICAgICAgICAgICA9IFsnbmVvLWdyaWQtY2VsbCddLFxuICAgICAgICAgICAgY29sc3BhbiAgICAgICAgICAgICAgICA9IHJlY29yZFtncmlkQm9keS5jb2xzcGFuRmllbGRdLFxuICAgICAgICAgICAge2RhdGFGaWVsZH0gICAgICAgICAgICA9IGNvbHVtbixcbiAgICAgICAgICAgIHJlY29yZElkICAgICAgICAgICAgICAgPSBncmlkQm9keS5nZXRSZWNvcmRJZChyZWNvcmQpLFxuICAgICAgICAgICAgbG9naWNhbENlbGxJZCAgICAgICAgICA9IGdyaWRCb2R5LmdldExvZ2ljYWxDZWxsSWQocmVjb3JkLCBkYXRhRmllbGQpLFxuICAgICAgICAgICAgZmllbGRWYWx1ZSAgICAgICAgICAgICA9IHJlY29yZC5nZXQoZGF0YUZpZWxkKSxcbiAgICAgICAgICAgIGNlbGxDb25maWcsIHJlbmRlcmVyT3V0cHV0O1xuXG4gICAgICAgIGlmIChmaWVsZFZhbHVlID09PSBudWxsIHx8IGZpZWxkVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZmllbGRWYWx1ZSA9ICcnXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29sdW1uLnJlbmRlcmVyU2NvcGUgPT09ICdtZScgfHwgY29sdW1uLnJlbmRlcmVyU2NvcGUgPT09ICd0aGlzJykge1xuICAgICAgICAgICAgY29sdW1uLnJlbmRlcmVyU2NvcGUgPSBjb2x1bW47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVuZGVyZXJDb25maWcgPSB7XG4gICAgICAgICAgICBjb2x1bW4sXG4gICAgICAgICAgICBjb2x1bW5JbmRleCxcbiAgICAgICAgICAgIGNvbXBvbmVudDogbWUuY29tcG9uZW50cz8uW2NvbHVtbi5kYXRhRmllbGRdLFxuICAgICAgICAgICAgZGF0YUZpZWxkLFxuICAgICAgICAgICAgZ3JpZENvbnRhaW5lcixcbiAgICAgICAgICAgIHJlY29yZCxcbiAgICAgICAgICAgIHJvdzogbWUsXG4gICAgICAgICAgICByb3dJbmRleCxcbiAgICAgICAgICAgIHNpbGVudCxcbiAgICAgICAgICAgIHN0b3JlLFxuICAgICAgICAgICAgdmFsdWU6IGZpZWxkVmFsdWVcbiAgICAgICAgfTtcblxuICAgICAgICByZW5kZXJlck91dHB1dCA9IGNvbHVtbi5yZW5kZXJlci5jYWxsKGNvbHVtbi5yZW5kZXJlclNjb3BlIHx8IGNvbHVtbiwgcmVuZGVyZXJDb25maWcpO1xuXG4gICAgICAgIGlmIChjb2x1bW4uY2VsbENscykge1xuICAgICAgICAgICAgbGV0IGV4dHJhQ2xzID0gY29sdW1uLmNlbGxDbHM7XG5cbiAgICAgICAgICAgIGlmIChOZW8udHlwZU9mKGV4dHJhQ2xzKSA9PT0gJ0Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGV4dHJhQ2xzID0gZXh0cmFDbHMuY2FsbChjb2x1bW4ucmVuZGVyZXJTY29wZSB8fCBjb2x1bW4sIHJlbmRlcmVyQ29uZmlnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXh0cmFDbHMpIHtcbiAgICAgICAgICAgICAgICBOZW9BcnJheS5hZGQoY2VsbENscywgZXh0cmFDbHMpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVuZGVyZXJPdXRwdXQgaW5zdGFuY2VvZiBOZW8uY29tcG9uZW50LkJhc2UpIHtcbiAgICAgICAgICAgIG1lLmNvbXBvbmVudHMgPz89IHt9O1xuXG4gICAgICAgICAgICBpZiAoIW1lLmNvbXBvbmVudHNbY29sdW1uLmRhdGFGaWVsZF0pIHtcbiAgICAgICAgICAgICAgICBtZS5jb21wb25lbnRzW2NvbHVtbi5kYXRhRmllbGRdID0gcmVuZGVyZXJPdXRwdXRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVuZGVyZXJPdXRwdXQgPSByZW5kZXJlck91dHB1dC5jcmVhdGVWZG9tUmVmZXJlbmNlKClcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoTmVvLnR5cGVPZihyZW5kZXJlck91dHB1dCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ09iamVjdCc6IHtcbiAgICAgICAgICAgICAgICBpZiAocmVuZGVyZXJPdXRwdXQuaHRtbCB8fCByZW5kZXJlck91dHB1dC50ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyT3V0cHV0LmNscyAmJiBjZWxsQ2xzLnB1c2goLi4ucmVuZGVyZXJPdXRwdXQuY2xzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJlck91dHB1dCA9IFtyZW5kZXJlck91dHB1dF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdEYXRlJzpcbiAgICAgICAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICAgICAgICBjYXNlICdTdHJpbmcnOiB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXJPdXRwdXQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNscyA6IGNlbGxDbHMsXG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHJlbmRlcmVyT3V0cHV0Py50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlbmRlcmVyT3V0cHV0ID09PSBudWxsIHx8IHJlbmRlcmVyT3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyT3V0cHV0ID0gJydcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2x1bW4uY2VsbEFsaWduICE9PSAnbGVmdCcpIHtcbiAgICAgICAgICAgIGNlbGxDbHMucHVzaCgnbmVvLScgKyBjb2x1bW4uY2VsbEFsaWduKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdyaWRCb2R5LmhpZ2hsaWdodE1vZGlmaWVkQ2VsbHMpIHtcbiAgICAgICAgICAgIGlmIChyZWNvcmQuaXNNb2RpZmllZEZpZWxkKGRhdGFGaWVsZCkpIHtcbiAgICAgICAgICAgICAgICBjZWxsQ2xzLnB1c2goJ25lby1pcy1tb2RpZmllZCcpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNlbGxJZCkge1xuICAgICAgICAgICAgY2VsbElkID0gbWUuZ2V0Q2VsbElkKGNvbHVtbi5kYXRhRmllbGQpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ3JpZEJvZHkuc2VsZWN0aW9uTW9kZWw/LnNlbGVjdGVkQ29sdW1ucz8uaW5jbHVkZXMoZGF0YUZpZWxkKSkge1xuICAgICAgICAgICAgTmVvQXJyYXkuYWRkKGNlbGxDbHMsIGdyaWRCb2R5LnNlbGVjdGlvbk1vZGVsLnNlbGVjdGVkQ29sdW1uQ2VsbENscyB8fCAnbmVvLXNlbGVjdGVkJylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0xhc3RDb2x1bW4pIHtcbiAgICAgICAgICAgIGNlbGxDbHMucHVzaCgnbmVvLWxhc3QtY29sdW1uJylcbiAgICAgICAgfVxuXG4gICAgICAgIGNlbGxDb25maWcgPSB7XG4gICAgICAgICAgICAnYXJpYS1jb2xpbmRleCc6IGNvbHVtbkluZGV4ICsgMSwgLy8gMSBiYXNlZFxuICAgICAgICAgICAgZGF0YSAgICAgICAgICAgOiB7ZmllbGQ6IGRhdGFGaWVsZCwgcmVjb3JkSWR9LFxuICAgICAgICAgICAgaWQgICAgICAgICAgICAgOiBjZWxsSWQsXG4gICAgICAgICAgICBjbHMgICAgICAgICAgICA6IGNlbGxDbHMsXG4gICAgICAgICAgICByb2xlICAgICAgICAgICA6ICdncmlkY2VsbCcsXG4gICAgICAgICAgICBzdHlsZSAgICAgICAgICA6IHJlbmRlcmVyT3V0cHV0LnN0eWxlIHx8IHt9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHNlbGVjdGVkQ2VsbHMuaW5jbHVkZXMobG9naWNhbENlbGxJZCkpIHtcbiAgICAgICAgICAgIGNlbGxDbHMucHVzaCgnbmVvLXNlbGVjdGVkJyk7XG4gICAgICAgICAgICBjZWxsQ29uZmlnWydhcmlhLXNlbGVjdGVkJ10gPSB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29sdW1uLndpZHRoKSB7XG4gICAgICAgICAgICBjZWxsQ29uZmlnLnN0eWxlLm1pbldpZHRoID0gYCR7Y29sdW1uLndpZHRofXB4YFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbHNwYW4gJiYgT2JqZWN0LmtleXMoY29sc3BhbikuaW5jbHVkZXMoZGF0YUZpZWxkKSkge1xuICAgICAgICAgICAgY2VsbENvbmZpZy5jb2xzcGFuID0gY29sc3BhbltkYXRhRmllbGRdXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoTmVvLnR5cGVPZihyZW5kZXJlck91dHB1dCkgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihyZW5kZXJlck91dHB1dCwgJ2h0bWwnKSkge1xuICAgICAgICAgICAgICAgIGNlbGxDb25maWcuaHRtbCA9IHJlbmRlcmVyT3V0cHV0Lmh0bWwgIHx8ICcnXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNlbGxDb25maWcudGV4dCA9IHJlbmRlcmVyT3V0cHV0LnRleHQgIHx8ICcnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjZWxsQ29uZmlnLmNuID0gcmVuZGVyZXJPdXRwdXRcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjZWxsQ29uZmlnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIHRoZSBWRE9NIGZvciB0aGUgcm93LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaW1wbGVtZW50cyB0aGUgKipGdWxsIFBvb2wgUmVuZGVyaW5nKiogc3RyYXRlZ3kuXG4gICAgICogSXQgaXRlcmF0ZXMgdGhyb3VnaCB0d28gcGFzc2VzOlxuICAgICAqXG4gICAgICogMS4gICoqUG9vbGVkIENlbGxzIChPKDEpIFN0YWJpbGl0eSk6KipcbiAgICAgKiAgICAgLSBJdGVyYXRlcyB0aHJvdWdoIHRoZSBjdXJyZW50bHkgYG1vdW50ZWRDb2x1bW5zYC5cbiAgICAgKiAgICAgLSBNYXBzIGVhY2ggY29sdW1uIHRvIGEgZml4ZWQgc2xvdCBpbiB0aGUgYHBvb2xlZENlbGxzYCBhcnJheSBiYXNlZCBvbiBgcG9vbEluZGV4ID0gY29sdW1uSW5kZXggJSBjZWxsUG9vbFNpemVgLlxuICAgICAqICAgICAtIEZpbGxzIGFueSB1bnVzZWQgc2xvdHMgaW4gdGhlIGBwb29sZWRDZWxsc2AgYXJyYXkgd2l0aCBoaWRkZW4gcGxhY2Vob2xkZXJzLlxuICAgICAqICAgICAtIEFwcGVuZHMgdGhlICplbnRpcmUqIGRlbnNlIGBwb29sZWRDZWxsc2AgYXJyYXkgdG8gdGhlIFZET00uXG4gICAgICogICAgIC0gVGhpcyBlbnN1cmVzIHRoZSBWRE9NIGNoaWxkcmVuIGxpc3QgbGVuZ3RoIGFuZCBJRHMgcmVtYWluIGNvbnN0YW50IGR1cmluZyBob3Jpem9udGFsIHNjcm9sbGluZyxcbiAgICAgKiAgICAgICByZXN1bHRpbmcgaW4gemVybyBzdHJ1Y3R1cmFsIGRlbHRhcyAobm8gYG1vdmVOb2RlYCwgYGluc2VydE5vZGVgLCBvciBgcmVtb3ZlTm9kZWApLlxuICAgICAqXG4gICAgICogICAgICoqQ2VsbCBSZWN5Y2xpbmcgKEhvcml6b250YWwgU2Nyb2xsIE9wdGltaXphdGlvbik6KipcbiAgICAgKiAgICAgSWYgYHJlY3ljbGU9dHJ1ZWAsIHRoZSBtZXRob2QgYXR0ZW1wdHMgdG8gcmV1c2UgZXhpc3RpbmcgVkRPTSBub2RlcyBmb3IgY2VsbHMgdGhhdCBhcmUgc3RpbGwgdmlzaWJsZVxuICAgICAqICAgICBidXQgaGF2ZSBtb3ZlZCB0byBhIG5ldyBwb29sIGluZGV4IChkdWUgdG8gaG9yaXpvbnRhbCBzY3JvbGwpLlxuICAgICAqICAgICAtIEl0IGNhcHR1cmVzIHRoZSBwcmV2aW91cyBWRE9NIGNoaWxkcmVuIChgb2xkQ25gKSBpbnRvIGEgTWFwIGtleWVkIGJ5IGBkYXRhRmllbGRgLlxuICAgICAqICAgICAtIElmIGEgbWF0Y2ggaXMgZm91bmQgZm9yIHRoZSBjdXJyZW50IGNvbHVtbiBhbmQgcmVjb3JkLCB0aGUgb2xkIG5vZGUgaXMgcmV1c2VkIGRpcmVjdGx5LlxuICAgICAqICAgICAtIFRoaXMgc2tpcHMgdGhlIGV4cGVuc2l2ZSBgYXBwbHlSZW5kZXJlck91dHB1dGAgYW5kIGB1cGRhdGVDZWxsQ29tcG9uZW50c2AgY2FsbHMsIGVuc3VyaW5nIE8oMSkgcGVyZm9ybWFuY2UgZm9yIGhvcml6b250YWwgc2Nyb2xsaW5nLlxuICAgICAqXG4gICAgICogMi4gICoqUGVybWFuZW50IENlbGxzOioqXG4gICAgICogICAgIC0gQXBwZW5kcyBjZWxscyB0aGF0IG9wdC1vdXQgb2YgcG9vbGluZyAoZS5nLiwgY29tcGxleCBjb21wb25lbnRzIGxpa2UgQ2hhcnRzL0NhbnZhcykuXG4gICAgICogICAgIC0gVGhlc2UgYXJlIGFsd2F5cyByZW5kZXJlZCB0byBwcmVzZXJ2ZSB0aGVpciBpbnRlcm5hbCBzdGF0ZSAoZS5nLiBDYW52YXMgY29udGV4dCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcmVjeWNsZT10cnVlXSBUcnVlIHRvIGF0dGVtcHQgcmV1c2luZyBleGlzdGluZyBjZWxsIFZET01zLlxuICAgICAqL1xuICAgIGNyZWF0ZVZkb20oc2lsZW50PWZhbHNlLCByZWN5Y2xlPXRydWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgcmVjb3JkICAgICAgICAgICA9IG1lLnJlY29yZCxcbiAgICAgICAgICAgIHJvd0luZGV4ICAgICAgICAgPSBtZS5yb3dJbmRleCxcbiAgICAgICAgICAgIGdyaWRCb2R5ICAgICAgICAgPSBtZS5wYXJlbnQsIC8vIFRoZSBSb3cgaXMgYW4gaXRlbSBvZiBCb2R5XG4gICAgICAgICAgICBncmlkQ29udGFpbmVyICAgID0gZ3JpZEJvZHkucGFyZW50LFxuICAgICAgICAgICAgdmRvbSAgICAgICAgICAgICA9IG1lLnZkb20sXG4gICAgICAgICAgICB7Y29sdW1uc30gICAgICAgID0gZ3JpZENvbnRhaW5lcixcbiAgICAgICAgICAgIGNlbGxDb25maWcsIGNvbHVtbiwgY29sdW1uUG9zaXRpb24sIGksIGlzTW91bnRlZCwgbGFzdENvbHVtbkluZGV4LCBvbGRDbiwgcG9vbEluZGV4LCBwb29sU2l6ZSwgcG9vbGVkQ2VsbHM7XG5cbiAgICAgICAgaWYgKCFyZWNvcmQpIHtcbiAgICAgICAgICAgIHZkb20uc3R5bGUgPSB7ZGlzcGxheTogJ25vbmUnfTtcbiAgICAgICAgICAgICFzaWxlbnQgJiYgbWUudXBkYXRlKCk7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB7bW91bnRlZENvbHVtbnN9ID0gZ3JpZEJvZHksXG4gICAgICAgICAgICB7c2VsZWN0ZWRSb3dzfSAgID0gZ3JpZEJvZHksXG4gICAgICAgICAgICByZWNvcmRJZCAgICAgICAgID0gZ3JpZEJvZHkuZ2V0UmVjb3JkSWQocmVjb3JkKSxcbiAgICAgICAgICAgIGNvdW50Q29sdW1ucyAgICAgPSBjb2x1bW5zLmdldENvdW50KCk7XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbih2ZG9tLCB7XG4gICAgICAgICAgICAnYXJpYS1yb3dpbmRleCc6IHJvd0luZGV4ICsgMiwgLy8gaGVhZGVyIHJvdyA9PiAxLCBmaXJzdCBib2R5IHJvdyA9PiAyXG4gICAgICAgICAgICBkYXRhICAgICAgICAgICA6IHtyZWNvcmRJZCwgcm93SWQ6IHJvd0luZGV4fSxcbiAgICAgICAgICAgIHJvbGUgICAgICAgICAgIDogJ3JvdycsXG4gICAgICAgICAgICBzdHlsZSAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5ICA6IG51bGwsIC8vIFJlc2V0IGRpc3BsYXkgaW4gY2FzZSBpdCB3YXMgaGlkZGVuXG4gICAgICAgICAgICAgICAgaGVpZ2h0ICAgOiBncmlkQm9keS5yb3dIZWlnaHQgKyAncHgnLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKDBweCwgJHtyb3dJbmRleCAqIGdyaWRCb2R5LnJvd0hlaWdodH1weCwgMHB4KWBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ2FwdHVyZSBwcmV2aW91cyBjaGlsZHJlbiBmb3IgcmVjeWNsaW5nIGNoZWNrXG4gICAgICAgIG9sZENuICAgPSB2ZG9tLmNuO1xuICAgICAgICB2ZG9tLmNuID0gW107XG5cbiAgICAgICAgbGV0IG9sZENlbGxNYXAgPSBudWxsO1xuXG4gICAgICAgIGlmIChyZWN5Y2xlICYmIG9sZENuKSB7XG4gICAgICAgICAgICBvbGRDZWxsTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgLy8gTWFwIGV4aXN0aW5nIGNlbGxzIGJ5IGRhdGFGaWVsZCBmb3Igcm9idXN0IHJldHJpZXZhbCByZWdhcmRsZXNzIG9mIHBvb2wgaW5kZXggY2hhbmdlc1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG9sZENuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBvbGRDbltpXTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5kYXRhPy5maWVsZCkge1xuICAgICAgICAgICAgICAgICAgICBvbGRDZWxsTWFwLnNldChub2RlLmRhdGEuZmllbGQsIG5vZGUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJvd0NscyA9IGdyaWRCb2R5LmdldFJvd0NsYXNzKHJlY29yZCwgcm93SW5kZXgpO1xuXG4gICAgICAgIGlmIChyb3dJbmRleCAlIDIgIT09IDApIHtcbiAgICAgICAgICAgIHJvd0Nscy5wdXNoKCduZW8tZXZlbicpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZWN0ZWRSb3dzICYmIHJlY29yZFtncmlkQm9keS5zZWxlY3RlZFJlY29yZEZpZWxkXSkge1xuICAgICAgICAgICAgTmVvQXJyYXkuYWRkKHNlbGVjdGVkUm93cywgcmVjb3JkSWQpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZWN0ZWRSb3dzPy5pbmNsdWRlcyhyZWNvcmRJZCkpIHtcbiAgICAgICAgICAgIHJvd0Nscy5wdXNoKCduZW8tc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgIHZkb21bJ2FyaWEtc2VsZWN0ZWQnXSA9IHRydWU7XG4gICAgICAgICAgICAvLyBOb3RlOiBmaXJlKCdzZWxlY3QnKSBzaG91bGQgaWRlYWxseSBiZSBoYW5kbGVkIGJ5IHRoZSBTZWxlY3Rpb25Nb2RlbCBvYnNlcnZpbmcgdGhlIHN0b3JlL3JlY29yZHMsXG4gICAgICAgICAgICAvLyBvciB3ZSBrZWVwIGl0IGhlcmUgYnV0IHN1cHByZXNzIGV2ZW50cyBkdXJpbmcgcmVuZGVyaW5nIGlmIG5lZWRlZC5cbiAgICAgICAgICAgIC8vIGdyaWRDb250YWluZXIuZmlyZSgnc2VsZWN0Jywge3JlY29yZH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgdmRvbVsnYXJpYS1zZWxlY3RlZCddXG4gICAgICAgIH1cblxuICAgICAgICB2ZG9tLmNscyA9IHJvd0NscztcblxuICAgICAgICBsYXN0Q29sdW1uSW5kZXggPSBncmlkQm9keS5jb2x1bW5Qb3NpdGlvbnMuZ2V0Q291bnQoKSAtIDE7XG4gICAgICAgIHBvb2xTaXplICAgICAgICA9IGdyaWRCb2R5LmNlbGxQb29sU2l6ZTtcbiAgICAgICAgcG9vbGVkQ2VsbHMgICAgID0gbmV3IEFycmF5KHBvb2xTaXplKTtcblxuICAgICAgICAvLyBQYXNzIDE6IFJlbmRlciBQb29sZWQgQ2VsbHMgKGhpZGVNb2RlID09PSAncmVtb3ZlRG9tJylcbiAgICAgICAgLy8gV2UgcmVuZGVyIHRoZSBGVUxMIHBvb2wgdG8gZW5zdXJlIHN0YWJsZSBWRE9NIHN0cnVjdHVyZSAoMCBpbnNlcnRzL21vdmVzKS5cbiAgICAgICAgZm9yIChpPW1vdW50ZWRDb2x1bW5zWzBdOyBpIDw9IG1vdW50ZWRDb2x1bW5zWzFdOyBpKyspIHtcbiAgICAgICAgICAgIGNvbHVtbiA9IGNvbHVtbnMuZ2V0QXQoaSk7XG5cbiAgICAgICAgICAgIC8vIFNhbml0eSBjaGVjayBmb3IgYm91bmRzIChlLmcuIGlmIGNvbHVtbiBjb3VudCBjaGFuZ2VkKVxuICAgICAgICAgICAgaWYgKCFjb2x1bW4pIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBpZiAoY29sdW1uLmhpZGVNb2RlID09PSAncmVtb3ZlRG9tJykge1xuICAgICAgICAgICAgICAgIHBvb2xJbmRleCA9IGkgJSBwb29sU2l6ZTtcblxuICAgICAgICAgICAgICAgIC8vIENlbGwgUmVjeWNsaW5nOiBSZXVzZSBleGlzdGluZyBWRE9NIGlmIHJlY29yZCBhbmQgY29sdW1uIG1hdGNoXG4gICAgICAgICAgICAgICAgaWYgKHJlY3ljbGUgJiYgb2xkQ2VsbE1hcCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb2xkTm9kZSA9IG9sZENlbGxNYXAuZ2V0KGNvbHVtbi5kYXRhRmllbGQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGROb2RlICYmIG9sZE5vZGUuZGF0YT8ucmVjb3JkSWQgPT09IHJlY29yZElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBtdXN0IHVwZGF0ZSB0aGUgSUQgYW5kIGNvbGluZGV4IHRvIG1hdGNoIHRoZSBuZXcgcGh5c2ljYWwgc2xvdFxuICAgICAgICAgICAgICAgICAgICAgICAgb2xkTm9kZS5pZCA9IGAke21lLmlkfV9fY2VsbC0ke3Bvb2xJbmRleH1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2xkTm9kZVsnYXJpYS1jb2xpbmRleCddID0gaSArIDE7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uUG9zaXRpb24gPSBncmlkQm9keS5jb2x1bW5Qb3NpdGlvbnMuZ2V0KGNvbHVtbi5kYXRhRmllbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbHVtblBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkTm9kZS5zdHlsZS5sZWZ0ICA9IGNvbHVtblBvc2l0aW9uLnggKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZE5vZGUuc3R5bGUud2lkdGggPSBjb2x1bW5Qb3NpdGlvbi53aWR0aCArICdweCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdmlzaWJpbGl0eSBpbiBjYXNlIGl0IHdhcyBoaWRkZW4gYnkgZHJhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29sdW1uUG9zaXRpb24uaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZE5vZGUuc3R5bGUudmlzaWJpbGl0eSA9IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvb2xlZENlbGxzW3Bvb2xJbmRleF0gPSBvbGROb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNlbGxDb25maWcgPSBtZS5hcHBseVJlbmRlcmVyT3V0cHV0KHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbElkICAgICAgOiBgJHttZS5pZH1fX2NlbGwtJHtwb29sSW5kZXh9YCxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5JbmRleCA6IGksXG4gICAgICAgICAgICAgICAgICAgIGlzTGFzdENvbHVtbjogaSA9PT0gbGFzdENvbHVtbkluZGV4LFxuICAgICAgICAgICAgICAgICAgICByZWNvcmQsXG4gICAgICAgICAgICAgICAgICAgIHJvd0luZGV4LFxuICAgICAgICAgICAgICAgICAgICBzaWxlbnRcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmIChjb2x1bW4uZG9jaykge1xuICAgICAgICAgICAgICAgICAgICBjZWxsQ29uZmlnLmNscyA9IFsnbmVvLWxvY2tlZCcsIC4uLmNlbGxDb25maWcuY2xzIHx8IFtdXVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbHVtblBvc2l0aW9uID0gZ3JpZEJvZHkuY29sdW1uUG9zaXRpb25zLmdldChjb2x1bW4uZGF0YUZpZWxkKTtcblxuICAgICAgICAgICAgICAgIGlmICghY29sdW1uUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjZWxsQ29uZmlnLnN0eWxlID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jZWxsQ29uZmlnLnN0eWxlLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0IDogY29sdW1uUG9zaXRpb24ueCAgICAgKyAncHgnLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogY29sdW1uUG9zaXRpb24ud2lkdGggKyAncHgnXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIEhhcHBlbnMgZHVyaW5nIGEgY29sdW1uIGhlYWRlciBkcmFnIE9QLCB3aGVuIGxlYXZpbmcgdGhlIHBhaW50ZWQgcmFuZ2VcbiAgICAgICAgICAgICAgICBpZiAoY29sdW1uUG9zaXRpb24uaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxDb25maWcuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcG9vbGVkQ2VsbHNbcG9vbEluZGV4XSA9IGNlbGxDb25maWdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbGwgZ2FwcyB3aXRoIHBsYWNlaG9sZGVycyB0byBtYWludGFpbiBPKDEpIHN0YWJpbGl0eVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcG9vbFNpemU7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFwb29sZWRDZWxsc1tpXSkge1xuICAgICAgICAgICAgICAgIHBvb2xlZENlbGxzW2ldID0ge1xuICAgICAgICAgICAgICAgICAgICBpZCAgIDogYCR7bWUuaWR9X19jZWxsLSR7aX1gLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZToge2Rpc3BsYXk6ICdub25lJ31cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2ZG9tLmNuLnB1c2goLi4ucG9vbGVkQ2VsbHMpO1xuXG4gICAgICAgIC8vIFBhc3MgMjogUmVuZGVyIFBlcm1hbmVudCBDZWxscyAoaGlkZU1vZGUgIT09ICdyZW1vdmVEb20nKVxuICAgICAgICAvLyBXZSBNVVNUIHJlbmRlciB0aGVzZSBldmVuIGlmIHRoZXkgYXJlIG9mZi1zY3JlZW4gdG8gcHJlc2VydmUgdGhlaXIgRE9NIHN0YXRlIChlLmcuIENhbnZhcyBjb250ZXh0KS5cbiAgICAgICAgLy8gVGhpcyBsb29wIGlzIE8oVG90YWxDb2x1bW5zKSwgYnV0IHR5cGljYWxseSBmZXcgY29sdW1ucyB1c2UgdGhpcyBtb2RlLlxuICAgICAgICBmb3IgKGk9MDsgaSA8IGNvdW50Q29sdW1uczsgaSsrKSB7XG4gICAgICAgICAgICBjb2x1bW4gPSBjb2x1bW5zLmdldEF0KGkpO1xuXG4gICAgICAgICAgICBpZiAoY29sdW1uLmhpZGVNb2RlICE9PSAncmVtb3ZlRG9tJykge1xuICAgICAgICAgICAgICAgIGlzTW91bnRlZCA9IGkgPj0gbW91bnRlZENvbHVtbnNbMF0gJiYgaSA8PSBtb3VudGVkQ29sdW1uc1sxXTtcblxuICAgICAgICAgICAgICAgIGNlbGxDb25maWcgPSBtZS5hcHBseVJlbmRlcmVyT3V0cHV0KHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbElkICAgICAgOiBgJHttZS5pZH1fXyR7Y29sdW1uLmRhdGFGaWVsZH1gLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbkluZGV4IDogaSxcbiAgICAgICAgICAgICAgICAgICAgaXNMYXN0Q29sdW1uOiBpID09PSBsYXN0Q29sdW1uSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZCxcbiAgICAgICAgICAgICAgICAgICAgcm93SW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIHNpbGVudFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbi5kb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxDb25maWcuY2xzID0gWyduZW8tbG9ja2VkJywgLi4uY2VsbENvbmZpZy5jbHMgfHwgW11dXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29sdW1uUG9zaXRpb24gPSBncmlkQm9keS5jb2x1bW5Qb3NpdGlvbnMuZ2V0KGNvbHVtbi5kYXRhRmllbGQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFjb2x1bW5Qb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNlbGxDb25maWcuc3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNlbGxDb25maWcuc3R5bGUsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgOiBjb2x1bW5Qb3NpdGlvbi54ICAgICArICdweCcsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjb2x1bW5Qb3NpdGlvbi53aWR0aCArICdweCdcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gVmlzaWJpbGl0eSBMb2dpY1xuICAgICAgICAgICAgICAgIGlmIChpc01vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbHVtblBvc2l0aW9uLmhpZGRlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbENvbmZpZy5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbidcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2x1bW4uaGlkZU1vZGUgPT09ICd2aXNpYmlsaXR5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbENvbmZpZy5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbidcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2x1bW4uaGlkZU1vZGUgPT09ICdkaXNwbGF5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbENvbmZpZy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2ZG9tLmNuLnB1c2goY2VsbENvbmZpZylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICFzaWxlbnQgJiYgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG1lLmNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgICAgICBtZS5jb21wb25lbnRzW2tleV0uZGVzdHJveSgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdXBlci5kZXN0cm95KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YUZpZWxkXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRDZWxsSWQoZGF0YUZpZWxkKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmlkfV9fJHtkYXRhRmllbGR9YFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgY29tcG9uZW50cyBpbnNpZGUgdGhlIHJvdyBtYXRjaGluZyBhIHNwZWNpZmljIGlkZW50aWZpZXIgKG50eXBlLCBjbGFzc05hbWUgb3IgQ2xhc3MpXG4gICAgICogQHBhcmFtIHtTdHJpbmd8TmVvLmNvcmUuQmFzZX0gaWRlbnRpZmllclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICB1cGRhdGVDZWxsQ29tcG9uZW50cyhpZGVudGlmaWVyLCBjb25maWcpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIGlzU3RyaW5nLCBwcm90bztcblxuICAgICAgICBpZiAobWUuY29tcG9uZW50cykge1xuICAgICAgICAgICAgaXNTdHJpbmcgPSBOZW8uaXNTdHJpbmcoaWRlbnRpZmllcik7XG5cbiAgICAgICAgICAgIGlmICghaXNTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICBwcm90byAgICAgID0gaWRlbnRpZmllci5wcm90b3R5cGU7XG4gICAgICAgICAgICAgICAgaWRlbnRpZmllciA9IHByb3RvLm50eXBlIHx8IHByb3RvLmNsYXNzTmFtZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBtZS5jb21wb25lbnRzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvbXBvbmVudCA9IG1lLmNvbXBvbmVudHNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcgPyAoY29tcG9uZW50Lm50eXBlID09PSBpZGVudGlmaWVyIHx8IGNvbXBvbmVudC5jbGFzc05hbWUgPT09IGlkZW50aWZpZXIpIDogKGNvbXBvbmVudCBpbnN0YW5jZW9mIGlkZW50aWZpZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5zZXQoY29uZmlnKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGNvbnRlbnQgb2YgdGhpcyBSb3cgaW5zdGFuY2UgdG8gZGlzcGxheSBhIG5ldyByZWNvcmQuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHRoZSBjb3JlIG1ldGhvZCBvZiB0aGUgUm93IFBvb2xpbmcgYXJjaGl0ZWN0dXJlLiBJdCBpcyBjYWxsZWQgYnkgYE5lby5ncmlkLkJvZHlgXG4gICAgICogZHVyaW5nIHNjcm9sbGluZyBvciByZW5kZXJpbmcuIEl0IHVwZGF0ZXMgdGhlIGludGVybmFsIHN0YXRlIChgcmVjb3JkYCwgYHJvd0luZGV4YClcbiAgICAgKiBhbmQgdHJpZ2dlcnMgYSBWRE9NIHVwZGF0ZSB0byByZWZsZWN0IHRoZSBuZXcgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZGF0YS5mb3JjZT1mYWxzZV0gVHJ1ZSB0byBmb3JjZSBhIFZET00gdXBkYXRlIGV2ZW4gaWYgcmVjb3JkIGFuZCByb3dJbmRleCBhcmUgdW5jaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhLnJlY29yZCBUaGUgbmV3IHJlY29yZCB0byBkaXNwbGF5LlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2RhdGEucmVjeWNsZT10cnVlXSBUcnVlIHRvIGF0dGVtcHQgcmV1c2luZyBleGlzdGluZyBjZWxsIFZET01zIChwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24pLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLnJvd0luZGV4IFRoZSBuZXcgcm93IGluZGV4LlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2RhdGEuc2lsZW50PWZhbHNlXSBUcnVlIHRvIHByZXZlbnQgYW4gaW1tZWRpYXRlIFZET00gdXBkYXRlICh1c2VmdWwgZm9yIGJhdGNoaW5nKS5cbiAgICAgKi9cbiAgICB1cGRhdGVDb250ZW50KHtmb3JjZT1mYWxzZSwgcmVjb3JkLCByZWN5Y2xlPXRydWUsIHJvd0luZGV4LCBzaWxlbnQ9ZmFsc2V9KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgLy8gT3B0aW1pemF0aW9uOiBTa2lwIFZET00gZ2VuZXJhdGlvbiBpZiB0aGUgc3RhdGUgaGFzbid0IGNoYW5nZWQuXG4gICAgICAgIC8vIFRoaXMgcHJldmVudHMgdGhvdXNhbmRzIG9mIHJlZHVuZGFudCB1cGRhdGVzIGR1cmluZyBzaW1wbGUgc2Nyb2xsaW5nLlxuICAgICAgICBpZiAoIWZvcmNlICYmIG1lLnJlY29yZCA9PT0gcmVjb3JkICYmIG1lLnJvd0luZGV4ID09PSByb3dJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBtZS5yZWNvcmQgICA9IHJlY29yZDtcbiAgICAgICAgbWUucm93SW5kZXggPSByb3dJbmRleDtcblxuICAgICAgICBtZS5jcmVhdGVWZG9tKHNpbGVudCwgcmVjeWNsZSlcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFJvdyk7XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmdyaWQuU2Nyb2xsTWFuYWdlclxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBTY3JvbGxNYW5hZ2VyIGV4dGVuZHMgQmFzZSB7XG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBkZWxheWFibGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBkZWxheWFibGUgPSB7XG4gICAgICAgIG9uQm9keVNjcm9sbEVuZDoge3R5cGU6ICdidWZmZXInLCAgIHRpbWVyOiAxNTB9LFxuICAgICAgICBzeW5jR3JpZEJvZHkgICA6IHt0eXBlOiAndGhyb3R0bGUnLCB0aW1lcjogIDE2fVxuICAgIH1cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmdyaWQuU2Nyb2xsTWFuYWdlcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmdyaWQuU2Nyb2xsTWFuYWdlcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBkcmFnU2Nyb2xsXz10cnVlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ1Njcm9sbF86IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBtb3VudGVkXz1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbW91bnRlZF86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBzY3JvbGxMZWZ0Xz0wXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzY3JvbGxMZWZ0XzogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gc2Nyb2xsVG9wXz0wXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzY3JvbGxUb3BfOiAwXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7TmVvLmdyaWQuQm9keXxudWxsfSBncmlkQm9keT1udWxsXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGdyaWRCb2R5ID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge05lby5ncmlkLkNvbnRhaW5lcnxudWxsfSBncmlkQ29udGFpbmVyPW51bGxcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZ3JpZENvbnRhaW5lciA9IG51bGxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICovXG4gICAgYWZ0ZXJTZXREcmFnU2Nyb2xsKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgY2xzID0gJ25lby1tb3VzZS1kcmFnLXNjcm9sbCc7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmdyaWRCb2R5LmFkZENscyhjbHMpXG4gICAgICAgIH0gZWxzZSBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZEJvZHkucmVtb3ZlQ2xzKGNscylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm1vdW50ZWQpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRHJhZ1Njcm9sbEFkZG9uKHZhbHVlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5kcmFnU2Nyb2xsICYmIHRoaXMudXBkYXRlRHJhZ1Njcm9sbEFkZG9uKHRydWUpXG4gICAgICAgIH0gZWxzZSBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRHJhZ1Njcm9sbEFkZG9uKGZhbHNlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT25seSB0cmlnZ2VycyBmb3IgdmVydGljYWwgc2Nyb2xsaW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25Cb2R5U2Nyb2xsKHtzY3JvbGxUb3B9KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuc2Nyb2xsVG9wICAgICAgICAgICA9IHNjcm9sbFRvcDtcbiAgICAgICAgbWUuZ3JpZEJvZHkuaXNTY3JvbGxpbmcgPSB0cnVlO1xuXG4gICAgICAgIG1lLm9uQm9keVNjcm9sbEVuZCgpO1xuICAgICAgICBtZS5zeW5jR3JpZEJvZHkoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbkJvZHlTY3JvbGxFbmQoKSB7XG4gICAgICAgIHRoaXMuZ3JpZEJvZHkuaXNTY3JvbGxpbmcgPSBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEuc2Nyb2xsTGVmdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhLnRhcmdldFxuICAgICAqL1xuICAgIG9uQ29udGFpbmVyU2Nyb2xsKHtzY3JvbGxMZWZ0LCB0YXJnZXR9KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgLy8gV2UgbXVzdCBpZ25vcmUgZXZlbnRzIGZvciBncmlkLXNjcm9sbGJhclxuICAgICAgICBpZiAodGFyZ2V0LmlkLmluY2x1ZGVzKCdncmlkLWNvbnRhaW5lcicpKSB7XG4gICAgICAgICAgICBtZS5zY3JvbGxMZWZ0ICAgICAgICAgID0gc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgIG1lLmdyaWRCb2R5LmlzU2Nyb2xsaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgbWUub25Cb2R5U2Nyb2xsRW5kKCk7XG4gICAgICAgICAgICBtZS5zeW5jR3JpZEJvZHkoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHN5bmNHcmlkQm9keSgpIHtcbiAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgYm9keSA9IG1lLmdyaWRCb2R5O1xuXG4gICAgICAgIGJvZHkuc2tpcENyZWF0ZVZpZXdEYXRhID0gdHJ1ZTtcblxuICAgICAgICBib2R5LnNldCh7XG4gICAgICAgICAgICBzY3JvbGxMZWZ0OiBtZS5zY3JvbGxMZWZ0LFxuICAgICAgICAgICAgc2Nyb2xsVG9wIDogbWUuc2Nyb2xsVG9wXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGJvZHkuc2tpcENyZWF0ZVZpZXdEYXRhID0gZmFsc2U7XG4gICAgICAgIGJvZHkuY3JlYXRlVmlld0RhdGEoKTtcblxuICAgICAgICBtZS5ncmlkQ29udGFpbmVyLmhlYWRlclRvb2xiYXIuc2Nyb2xsTGVmdCA9IG1lLnNjcm9sbExlZnRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFjdGl2ZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZURyYWdTY3JvbGxBZGRvbihhY3RpdmUpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIGFkZG9uID0gYXdhaXQgTmVvLmN1cnJlbnRXb3JrZXIuZ2V0QWRkb24oJ0dyaWREcmFnU2Nyb2xsJywgbWUud2luZG93SWQpO1xuXG4gICAgICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICAgICAgIGFkZG9uLnJlZ2lzdGVyKHtcbiAgICAgICAgICAgICAgICBib2R5SWQgICAgIDogbWUuZ3JpZEJvZHkuaWQgKyAnX193cmFwcGVyJyxcbiAgICAgICAgICAgICAgICBjb250YWluZXJJZDogbWUuZ3JpZENvbnRhaW5lci5pZCxcbiAgICAgICAgICAgICAgICBpZCAgICAgICAgIDogbWUuaWRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGRvbi51bnJlZ2lzdGVyKHtpZDogbWUuaWR9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcbiAgICAgICAgICAgIHNjcm9sbExlZnQ6IHRoaXMuc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgIHNjcm9sbFRvcCA6IHRoaXMuc2Nyb2xsVG9wXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFNjcm9sbE1hbmFnZXIpO1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQvQmFzZS5tanMnO1xuXG4vKipcbiAqIFdlIGRvIG5vdCB3YW50IHRvIHVzZSB0aGUgZGVmYXVsdCBzY3JvbGxiYXIgZm9yIHZlcnRpY2FsIHNjcm9sbGluZywgc2luY2UgaXQgd291bGQgc2hvdyB1cCBhdCB0aGUgcmlnaHQgZWRnZVxuICogb2YgdGhlIGxhc3QgY29sdW1uLiBJbnN0ZWFkLCB3ZSB3YW50IHRvIHNob3cgaXQgYXQgdGhlIHJpZ2h0IGVkZ2Ugb2YgdGhlIGNvbnRhaW5lciAoYWx3YXlzIHZpc2libGUgd2hlbiBzY3JvbGxpbmcpLlxuICogQGNsYXNzIE5lby5ncmlkLlZlcnRpY2FsU2Nyb2xsYmFyXG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqL1xuY2xhc3MgVmVydGljYWxTY3JvbGxiYXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmdyaWQuVmVydGljYWxTY3JvbGxiYXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5ncmlkLlZlcnRpY2FsU2Nyb2xsYmFyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2dyaWQtdmVydGljYWwtc2Nyb2xsYmFyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2dyaWQtdmVydGljYWwtc2Nyb2xsYmFyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWdyaWQtdmVydGljYWwtc2Nyb2xsYmFyJ11cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tZ3JpZC12ZXJ0aWNhbC1zY3JvbGxiYXInXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE51bWJlciBpbiBweFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHJvd0hlaWdodF89MFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHJvd0hlaWdodF86IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZGF0YS5TdG9yZXxudWxsfSBzdG9yZV89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHN0b3JlXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gX3Zkb21cbiAgICAgICAgICovXG4gICAgICAgIF92ZG9tOlxuICAgICAgICB7Y246IFtcbiAgICAgICAgICAgIHtjbHM6IFsnbmVvLWdyaWQtc2Nyb2xsYmFyLWNvbnRlbnQnXX1cbiAgICAgICAgXX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG1vdW50ZWRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYXN5bmMgYWRkU2Nyb2xsU3luYyhtb3VudGVkKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt3aW5kb3dJZH0gPSBtZSxcbiAgICAgICAgICAgIFNjcm9sbFN5bmMgPSBhd2FpdCBOZW8uY3VycmVudFdvcmtlci5nZXRBZGRvbignU2Nyb2xsU3luYycsIHdpbmRvd0lkKSxcbiAgICAgICAgICAgIHBhcmFtcyAgICAgPSB7aWQ6IG1lLmlkLCB3aW5kb3dJZH07XG5cbiAgICAgICAgaWYgKG1vdW50ZWQpIHtcbiAgICAgICAgICAgIFNjcm9sbFN5bmMucmVnaXN0ZXIoe1xuICAgICAgICAgICAgICAgIGZyb21JZDogbWUucGFyZW50LmJvZHkudmRvbS5pZCxcbiAgICAgICAgICAgICAgICB0b0lkICA6IG1lLmlkLFxuICAgICAgICAgICAgICAgIHR3b1dheTogTmVvLmNvbmZpZy5oYXNNb3VzZUV2ZW50cywgLy8gU3luY2luZyB0aGUgc2Nyb2xsZXIgYmFjayB0byB0aGUgYm9keSBhZmZlY3RzIG1vYmlsZSBzY3JvbGxpbmdcbiAgICAgICAgICAgICAgICAuLi5wYXJhbXNcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBTY3JvbGxTeW5jLnVucmVnaXN0ZXIocGFyYW1zKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtb3VudGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIG9sZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5hZGRTY3JvbGxTeW5jKHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcm93SGVpZ2h0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFJvd0hlaWdodCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPiAwICYmIHRoaXMudXBkYXRlU2Nyb2xsSGVpZ2h0KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHN0b3JlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuU3RvcmV8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLlN0b3JlfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U3RvcmUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAgICAgdmFsdWUub24oe1xuICAgICAgICAgICAgICAgIGZpbHRlcjogbWUudXBkYXRlU2Nyb2xsSGVpZ2h0LFxuICAgICAgICAgICAgICAgIGxvYWQgIDogbWUudXBkYXRlU2Nyb2xsSGVpZ2h0LFxuICAgICAgICAgICAgICAgIHNjb3BlIDogbWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5pdGVtc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgIFtkYXRhLnRvdGFsXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB1cGRhdGVTY3JvbGxIZWlnaHQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvdW50UmVjb3JkcyA9IGRhdGE/LnRvdGFsID8gZGF0YS50b3RhbCA6IG1lLnN0b3JlLmNvdW50LFxuICAgICAgICAgICAge3Jvd0hlaWdodH0gID0gbWU7XG5cbiAgICAgICAgaWYgKGNvdW50UmVjb3JkcyA+IDAgJiYgcm93SGVpZ2h0ID4gMCkge1xuICAgICAgICAgICAgbWUudmRvbS5jblswXS5oZWlnaHQgPSBgJHsoY291bnRSZWNvcmRzICsgMSkgKiByb3dIZWlnaHR9cHhgO1xuICAgICAgICAgICAgbWUudXBkYXRlKClcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVmVydGljYWxTY3JvbGxiYXIpO1xuIiwiaW1wb3J0IENvbHVtbiAgIGZyb20gJy4vQmFzZS5tanMnO1xuaW1wb3J0IE5lb0FycmF5IGZyb20gJy4uLy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBWZG9tVXRpbCBmcm9tICcuLi8uLi91dGlsL1ZEb20ubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmdyaWQuY29sdW1uLkFuaW1hdGVkQ2hhbmdlXG4gKiBAZXh0ZW5kcyBOZW8uZ3JpZC5jb2x1bW4uQmFzZVxuICovXG5jbGFzcyBBbmltYXRlZENoYW5nZSBleHRlbmRzIENvbHVtbiB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZ3JpZC5jb2x1bW4uQW5pbWF0ZWRDaGFuZ2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5ncmlkLmNvbHVtbi5BbmltYXRlZENoYW5nZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGFuaW1hdGlvbkNscz0nbmVvLWFuaW1hdGVkJ1xuICAgICAgICAgKi9cbiAgICAgICAgYW5pbWF0aW9uQ2xzOiAnbmVvLWFuaW1hdGVkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gdHlwZT0nYW5pbWF0ZWRDaGFuZ2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHR5cGU6ICdhbmltYXRlZENoYW5nZSdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnBhcmVudC5zdG9yZS5vbih7XG4gICAgICAgICAgICByZWNvcmRDaGFuZ2U6IG1lLm9uUmVjb3JkQ2hhbmdlLFxuICAgICAgICAgICAgc2NvcGUgICAgICAgOiBtZVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIGFzIG5lZWRlZCBmb3IgZHluYW1pYyByZWNvcmQtYmFzZWQgYW5pbWF0aW9uIGNsYXNzZXNcbiAgICAgKiBAcGFyYW0ge1JlY29yZH0gcmVjb3JkXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRBbmltYXRpb25DbHMocmVjb3JkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGlvbkNsc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgIGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSAgICAgICBkYXRhLmZpZWxkcyBFYWNoIGZpZWxkIG9iamVjdCBjb250YWlucyB0aGUga2V5czogbmFtZSwgb2xkVmFsdWUsIHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5Nb2RlbH0gZGF0YS5tb2RlbCBUaGUgbW9kZWwgaW5zdGFuY2Ugb2YgdGhlIGNoYW5nZWQgcmVjb3JkXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgZGF0YS5yZWNvcmRcbiAgICAgKi9cbiAgICBhc3luYyBvblJlY29yZENoYW5nZSh7ZmllbGRzLCByZWNvcmR9KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBmaWVsZDtcblxuICAgICAgICBmb3IgKGZpZWxkIG9mIGZpZWxkcykge1xuICAgICAgICAgICAgaWYgKGZpZWxkLm5hbWUgPT09IG1lLmRhdGFGaWVsZCkge1xuICAgICAgICAgICAgICAgIC8vIFdhaXQgZm9yIHRoZSBuZXh0IGFuaW1hdGlvbiBmcmFtZVxuICAgICAgICAgICAgICAgIGF3YWl0IG1lLnRpbWVvdXQoMjApO1xuXG4gICAgICAgICAgICAgICAgbGV0IHtib2R5fSA9IG1lLnBhcmVudCxcbiAgICAgICAgICAgICAgICAgICAgcm93ICAgID0gYm9keS5nZXRSb3cocmVjb3JkKSxcbiAgICAgICAgICAgICAgICAgICAgY2VsbElkLCBub2RlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJvdykge1xuICAgICAgICAgICAgICAgICAgICBjZWxsSWQgPSBib2R5LmdldENlbGxJZChyb3cucm93SW5kZXgsIG1lLmRhdGFGaWVsZCk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgICA9IFZkb21VdGlsLmZpbmQocm93LnZkb20sIGNlbGxJZCk/LnZkb207XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE5lb0FycmF5LmFkZChub2RlLmNscywgbWUuZ2V0QW5pbWF0aW9uQ2xzKHJlY29yZCkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgdHJpZ2dlciBhIDJuZCByb3cgdXBkYXRlLCBhZnRlciBncmlkLkJvZHk6IG9uU3RvcmVSZWNvcmRDaGFuZ2UoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXQgaXMgY3J1Y2lhbCB0byByZXN0YXJ0IHRoZSBrZXlmcmFtZSBiYXNlZCBhbmltYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vID0+IFRoZSBwcmV2aW91cyB1cGRhdGUgY2FsbCB3aWxsIHJlbW92ZSB0aGUgbGFzdCBhbmltYXRpb25DbHNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdy51cGRhdGUoKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIGluc3RhbmNlIGludG8gYSBKU09OLWNvbXBhdGlibGUgb2JqZWN0IGZvciB0aGUgTmV1cmFsIExpbmsuXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcbiAgICAgICAgICAgIGFuaW1hdGlvbkNsczogdGhpcy5hbmltYXRpb25DbHNcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQW5pbWF0ZWRDaGFuZ2UpO1xuIiwiaW1wb3J0IEFuaW1hdGVkQ2hhbmdlIGZyb20gJy4vQW5pbWF0ZWRDaGFuZ2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmdyaWQuY29sdW1uLkFuaW1hdGVkQ3VycmVuY3lcbiAqIEBleHRlbmRzIE5lby5ncmlkLmNvbHVtbi5BbmltYXRlZENoYW5nZVxuICovXG5jbGFzcyBBbmltYXRlZEN1cnJlbmN5IGV4dGVuZHMgQW5pbWF0ZWRDaGFuZ2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmdyaWQuY29sdW1uLkFuaW1hdGVkQ3VycmVuY3knXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5ncmlkLmNvbHVtbi5BbmltYXRlZEN1cnJlbmN5JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gdHlwZT0nYW5pbWF0ZWRDdXJyZW5jeSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdHlwZTogJ2FuaW1hdGVkQ3VycmVuY3knLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGEgZGlmZmVyZW50IHJlY29yZCBmaWVsZCB0byBiYXNlIHRoZSBjaGFuZ2Ugb24uXG4gICAgICAgICAqIERlZmF1bHRzIHRoaXMuZGF0YUZpZWxkXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBjb21wYXJlRmllbGQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgY29tcGFyZUZpZWxkOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjdXJyZW5jeT0nVVNEJ1xuICAgICAgICAgKi9cbiAgICAgICAgY3VycmVuY3k6ICdVU0QnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBsb2NhbGU9J2RlZmF1bHQnXG4gICAgICAgICAqL1xuICAgICAgICBsb2NhbGU6ICdkZWZhdWx0J1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0ludGwuTnVtYmVyRm9ybWF0fG51bGx9IGZvcm1hdHRlcj1udWxsXG4gICAgICovXG4gICAgZm9ybWF0dGVyID0gbnVsbFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG4gICAgICAgIHRoaXMuY3JlYXRlRm9ybWF0dGVyKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgICAgZGF0YVxuICAgICAqIEBwYXJhbSB7TmVvLmJ1dHRvbi5CYXNlfSAgICBkYXRhLmNvbHVtblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgICAgICAgICAgICBkYXRhLmNvbHVtbkluZGV4XG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgICAgICAgICAgIGRhdGEuZGF0YUZpZWxkXG4gICAgICogQHBhcmFtIHtOZW8uZ3JpZC5Db250YWluZXJ9IGRhdGEuZ3JpZENvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgICBkYXRhLnJlY29yZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgICAgICAgICAgICBkYXRhLnJvd0luZGV4XG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5TdG9yZX0gICAgIGRhdGEuc3RvcmVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9ICAgICAgZGF0YS52YWx1ZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGNlbGxSZW5kZXJlcih7Y29sdW1uLCB2YWx1ZX0pIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAnJ1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbHVtbi5mb3JtYXR0ZXIuZm9ybWF0KHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgY3JlYXRlRm9ybWF0dGVyKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmZvcm1hdHRlciA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChtZS5sb2NhbGUsIHtzdHlsZTogJ2N1cnJlbmN5JywgY3VycmVuY3k6IG1lLmN1cnJlbmN5fSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBhcyBuZWVkZWQgZm9yIGR5bmFtaWMgcmVjb3JkLWJhc2VkIGFuaW1hdGlvbiBjbGFzc2VzXG4gICAgICogQHBhcmFtIHtSZWNvcmR9IHJlY29yZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0QW5pbWF0aW9uQ2xzKHJlY29yZCkge1xuICAgICAgICByZXR1cm4gcmVjb3JkW3RoaXMuY29tcGFyZUZpZWxkIHx8IHRoaXMuZGF0YUZpZWxkXSA8IDAgPyAnbmVvLWFuaW1hdGVkLW5lZ2F0aXZlJyA6ICduZW8tYW5pbWF0ZWQtcG9zaXRpdmUnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0aGUgaW5zdGFuY2UgaW50byBhIEpTT04tY29tcGF0aWJsZSBvYmplY3QgZm9yIHRoZSBOZXVyYWwgTGluay5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXG4gICAgICAgICAgICBjb21wYXJlRmllbGQ6IG1lLmNvbXBhcmVGaWVsZCxcbiAgICAgICAgICAgIGN1cnJlbmN5ICAgIDogbWUuY3VycmVuY3ksXG4gICAgICAgICAgICBsb2NhbGUgICAgICA6IG1lLmxvY2FsZVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhBbmltYXRlZEN1cnJlbmN5KTtcbiIsImltcG9ydCBCYXNlICAgICAgICAgICAgICBmcm9tICcuLi8uLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCB7cmVzb2x2ZUNhbGxiYWNrfSBmcm9tICcuLi8uLi91dGlsL0Z1bmN0aW9uLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5ncmlkLmNvbHVtbi5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIENvbHVtbiBleHRlbmRzIEJhc2Uge1xuICAgIC8qKlxuICAgICAqIFZhbGlkIHZhbHVlcyBmb3IgaGlkZU1vZGVcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gaGlkZU1vZGVzPVsnZGlzcGxheScsJ3JlbW92ZURvbScsJ3Zpc2liaWxpdHknXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGhpZGVNb2RlcyA9IFsnZGlzcGxheScsICdyZW1vdmVEb20nLCAndmlzaWJpbGl0eSddXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5ncmlkLmNvbHVtbi5CYXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZ3JpZC5jb2x1bW4uQmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRpdGlvbmFsIENTUyBjbGFzc2VzIHRvIGFkZCB0byB0aGUgY2VsbC5cbiAgICAgICAgICogVGhlc2UgY2xhc3NlcyBhcmUgYXBwZW5kZWQgdG8gdGhlIGRlZmF1bHQgb25lcyAoZS5nLiAnbmVvLWdyaWQtY2VsbCcpLlxuICAgICAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbnxTdHJpbmd8U3RyaW5nW118bnVsbH0gY2VsbENscz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBjZWxsQ2xzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGZpZWxkIG5hbWUgb2YgdGhlIGRhdGEuTW9kZWwgdG8gcmVhZCB0aGUgdmFsdWUgZnJvbS5cbiAgICAgICAgICogTXVzdCBiZSB1bmlxdWUgd2l0aGluIHRoZSBncmlkIGluc3RhbmNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiAqKlJ1bnRpbWUgVXBkYXRlczoqKlxuICAgICAgICAgKiBZb3UgY2FuIGNoYW5nZSB0aGlzIGNvbmZpZyBhdCBydW50aW1lIHRvIHBvaW50IHRoZSBjb2x1bW4gdG8gYSBkaWZmZXJlbnQgbW9kZWwgZmllbGQuXG4gICAgICAgICAqIFRoZSBHcmlkIHdpbGwgYXV0b21hdGljYWxseTpcbiAgICAgICAgICogMS4gVXBkYXRlIHRoZSBpbnRlcm5hbCBgY29sdW1uUG9zaXRpb25zYCBtYXAgKHByZXNlcnZpbmcgc29ydCBvcmRlcikuXG4gICAgICAgICAqIDIuIFJlZnJlc2ggdGhlIHZpc2libGUgcm93cyB0byBkaXNwbGF5IHRoZSBuZXcgZGF0YS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGRhdGFGaWVsZF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGRhdGFGaWVsZF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGhpZGVNb2RlXz0ncmVtb3ZlRG9tJ1xuICAgICAgICAgKi9cbiAgICAgICAgaGlkZU1vZGVfOiAncmVtb3ZlRG9tJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5ncmlkLkNvbnRhaW5lcnxudWxsfSBwYXJlbnQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7RnVuY3Rpb258U3RyaW5nfG51bGx9IHJlbmRlcmVyXz0nY2VsbFJlbmRlcmVyJ1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHJlbmRlcmVyXzogJ2NlbGxSZW5kZXJlcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTY29wZSB0byBleGVjdXRlIHRoZSBjb2x1bW4gcmVuZGVyZXIuXG4gICAgICAgICAqIERlZmF1bHRzIHRvIHRoZSBncmlkLkJvZHkuXG4gICAgICAgICAqIFlvdSBjYW4gcGFzcyB0aGUgc3RyaW5ncyAndGhpcycgb3IgJ21lJ1xuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29yZS5CYXNlfFN0cmluZ3xudWxsfSByZW5kZXJlclNjb3BlPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHJlbmRlcmVyU2NvcGU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHR5cGU9J2NvbHVtbidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdHlwZTogJ2NvbHVtbicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gd2luZG93SWRfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB3aW5kb3dJZF86IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGRhdGFGaWVsZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICovXG4gICAgYWZ0ZXJTZXREYXRhRmllbGQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgZ3JpZENvbnRhaW5lciA9IG1lLnBhcmVudCxcbiAgICAgICAgICAgICAgICBib2R5ICAgICAgICAgID0gZ3JpZENvbnRhaW5lcj8uYm9keSxcbiAgICAgICAgICAgICAgICBoZWFkZXJUb29sYmFyID0gZ3JpZENvbnRhaW5lcj8uaGVhZGVyVG9vbGJhcixcbiAgICAgICAgICAgICAgICBjb2xQb3NpdGlvbnMgID0gYm9keT8uY29sdW1uUG9zaXRpb25zLFxuICAgICAgICAgICAgICAgIGJ1dHRvbiAgICAgICAgPSBoZWFkZXJUb29sYmFyPy5nZXRDb2x1bW4ob2xkVmFsdWUpLFxuICAgICAgICAgICAgICAgIHBvcyAgICAgICAgICAgPSBjb2xQb3NpdGlvbnM/LmdldChvbGRWYWx1ZSk7XG5cbiAgICAgICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgY29sdW1uUG9zaXRpb25zIGNvbGxlY3Rpb24gaXMga2V5ZWQgYnkgJ2RhdGFGaWVsZCcuXG4gICAgICAgICAgICAgICAgLy8gVG8gdXBkYXRlIHRoZSBrZXkgaW4gdGhlIGludGVybmFsIE1hcCwgd2UgbXVzdCByZW1vdmUgdGhlIGl0ZW0gKHVzaW5nIHRoZSBvbGQga2V5KSxcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHByb3BlcnR5LCBhbmQgcmUtYWRkIGl0IChpbmRleGluZyB3aXRoIHRoZSBuZXcga2V5KS5cbiAgICAgICAgICAgICAgICAvLyBNb2RpZnlpbmcgaXQgaW4tcGxhY2Ugd291bGQgYnJlYWsgdGhlIE1hcCBpbmRleC5cbiAgICAgICAgICAgICAgICBjb2xQb3NpdGlvbnMubWFwLmRlbGV0ZShvbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgcG9zLmRhdGFGaWVsZCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbFBvc2l0aW9ucy5tYXAuc2V0KHZhbHVlLCBwb3MpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChidXR0b24pIHtcbiAgICAgICAgICAgICAgICBidXR0b24uZGF0YUZpZWxkID0gdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgd2luZG93SWQgY29uZmlnIGdvdCBjaGFuZ2VkLlxuICAgICAqXG4gICAgICogKipOb24tQ29tcG9uZW50IFRoZW1lIEluamVjdGlvbioqXG4gICAgICogQWx0aG91Z2ggYE5lby5ncmlkLmNvbHVtbi5CYXNlYCBhbmQgaXRzIHN1YmNsYXNzZXMgYXJlIG5vdCBjb21wb25lbnRzICh0aGV5IGV4dGVuZCBgY29yZS5CYXNlYCksXG4gICAgICogdGhleSBob29rIGludG8gdGhlIHRoZW1lIGVuZ2luZSBleGFjdGx5IGxpa2UgY29tcG9uZW50cyBkby5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYSBwb3dlcmZ1bCBhcmNoaXRlY3R1cmFsIHBhdHRlcm4uIEl0IGFsbG93cyBzcGVjaWZpYyBjb2x1bW4gaW1wbGVtZW50YXRpb25zXG4gICAgICogKGxpa2UgYE5lby5ncmlkLmNvbHVtbi5JY29uYCBvciBgTmVvLmdyaWQuY29sdW1uLkNvbXBvbmVudGApIHRvIGluamVjdCB0aGVpciBvd24gU0NTU1xuICAgICAqIHRoZW1lIGZpbGVzIChlLmcuLCBgcmVzb3VyY2VzL3Njc3MvdGhlbWUtbmVvLWRhcmsvZ3JpZC9jb2x1bW4vSWNvbkxpbmsuc2Nzc2ApLlxuICAgICAqXG4gICAgICogKipCZXN0IFByYWN0aWNlOioqXG4gICAgICogQmVjYXVzZSBjb2x1bW5zIGRvIG5vdCByZW5kZXIgdGhlaXIgb3duIG91dGVyIERPTSBub2RlcyB3aXRoIHVuaXF1ZSBDU1MgY2xhc3NlcyxcbiAgICAgKiBhbnkgQ1NTIHJ1bGVzIGRlZmluZWQgaW4gdGhlc2UgaW5qZWN0ZWQgZmlsZXMgTVVTVCBiZSBzY29wZWQgaW5zaWRlIGAubmVvLWdyaWQtY2VsbGBcbiAgICAgKiB0byBwcmV2ZW50IHVuaW50ZW5kZWQgc2lkZSBlZmZlY3RzIG9uIHN0YW5kYWxvbmUgY29tcG9uZW50cyBlbHNld2hlcmUgaW4gdGhlIGFwcGxpY2F0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRXaW5kb3dJZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdmFsdWUgJiYgTmVvLmN1cnJlbnRXb3JrZXIuaW5zZXJ0VGhlbWVGaWxlcyh2YWx1ZSwgdGhpcy5fX3Byb3RvX18pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgaGlkZU1vZGUgY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRIaWRlTW9kZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ2hpZGVNb2RlJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSByZW5kZXJlciBjb25maWcgZ2V0cyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRSZW5kZXJlcih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgLy8gSWYgbm8gZm4gaXMgZm91bmQgaW5zaWRlIHRoZSBwYXJlbnQgdHJlZSwgcmV0dXJuIHRoZSBwbGFpbiB2YWx1ZSBmb3IgdmlldyBjb250cm9sbGVycyB0byBtYXRjaFxuICAgICAgICByZXR1cm4gcmVzb2x2ZUNhbGxiYWNrKHZhbHVlLCB0aGlzKS5mbiB8fCB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgICBkYXRhXG4gICAgICogQHBhcmFtIHtOZW8uYnV0dG9uLkJhc2V9ICAgIGRhdGEuY29sdW1uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgICAgIGRhdGEuY29sdW1uSW5kZXhcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICAgICAgICAgZGF0YS5kYXRhRmllbGRcbiAgICAgKiBAcGFyYW0ge05lby5ncmlkLkNvbnRhaW5lcn0gZGF0YS5ncmlkQ29udGFpbmVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICAgIGRhdGEucmVjb3JkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgICAgIGRhdGEucm93SW5kZXhcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLlN0b3JlfSAgICAgZGF0YS5zdG9yZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gICAgICBkYXRhLnZhbHVlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgY2VsbFJlbmRlcmVyKHt2YWx1ZX0pIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0aGUgaW5zdGFuY2UgaW50byBhIEpTT04tY29tcGF0aWJsZSBvYmplY3QgZm9yIHRoZSBOZXVyYWwgTGluay5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IG1lICA9IHRoaXMsXG4gICAgICAgICAgICBvdXQgPSBzdXBlci50b0pTT04oKTtcblxuICAgICAgICBvdXQuZGF0YUZpZWxkID0gbWUuZGF0YUZpZWxkO1xuICAgICAgICBvdXQudHlwZSAgICAgID0gbWUudHlwZTtcblxuICAgICAgICBpZiAoTmVvLmlzU3RyaW5nKG1lLnJlbmRlcmVyKSkge1xuICAgICAgICAgICAgb3V0LnJlbmRlcmVyID0gbWUucmVuZGVyZXJcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKENvbHVtbik7XG4iLCJpbXBvcnQge2lzRGVzY3JpcHRvcn0gZnJvbSAnLi4vLi4vY29yZS9Db25maWdTeW1ib2xzLm1qcyc7XG5pbXBvcnQgQ29sdW1uICAgICAgICAgZnJvbSAnLi9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5ncmlkLmNvbHVtbi5Db21wb25lbnRcbiAqIEBleHRlbmRzIE5lby5ncmlkLmNvbHVtbi5CYXNlXG4gKi9cbmNsYXNzIENvbXBvbmVudCBleHRlbmRzIENvbHVtbiB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZ3JpZC5jb2x1bW4uQ29tcG9uZW50J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZ3JpZC5jb2x1bW4uQ29tcG9uZW50JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufE9iamVjdHxudWxsfSBjb21wb25lbnQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgY29tcG9uZW50OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBkZWZhdWx0c19cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGRlZmF1bHRzXzoge1xuICAgICAgICAgICAgW2lzRGVzY3JpcHRvcl06IHRydWUsXG4gICAgICAgICAgICBtZXJnZSAgICAgICAgIDogJ2RlZXAnLFxuICAgICAgICAgICAgdmFsdWUgICAgICAgICA6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gaGlkZU1vZGU9J3Zpc2liaWxpdHknXG4gICAgICAgICAqL1xuICAgICAgICBoaWRlTW9kZTogJ3Zpc2liaWxpdHknLFxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcG9uZW50cyBjYW4gZGVsZWdhdGUgZXZlbnQgbGlzdGVuZXJzIChvciBidXR0b24gaGFuZGxlcnMpIGludG8gbWV0aG9kcyBzb21ld2hlcmUgaW5zaWRlXG4gICAgICAgICAqIHRoZSB2aWV3IGNvbnRyb2xsZXIgb3IgY29tcG9uZW50IHRyZWUgaGllcmFyY2h5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBJbiB0aGlzIGNhc2UsIGl0IGlzIGhlbHBmdWwgdG8ga25vdyB3aGF0IHRoZSByZWxhdGVkIHJlY29yZCBpcywgc28gd2UgYXJlIGFkZGluZyB0aGUgcmVjb3JkXG4gICAgICAgICAqIHRvIHRoZSBjb21wb25lbnQgYXMgYSBwcm9wZXJ0eS4gQnkgZGVmYXVsdCwgYXMgJ3JlY29yZCcsIGJ1dCB0aGlzIGNvbmZpZyBjYW4gY2hhbmdlIHRoZSBwcm9wZXJ0eSBuYW1lLlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHJlY29yZFByb3BlcnR5PSdyZWNvcmQnXG4gICAgICAgICAqL1xuICAgICAgICByZWNvcmRQcm9wZXJ0eTogJ3JlY29yZCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHJlbmRlcmVyU2NvcGU9J3RoaXMnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHJlbmRlcmVyU2NvcGU6ICd0aGlzJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gdHlwZT0nY29tcG9uZW50J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0eXBlOiAnY29tcG9uZW50JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGlzIGNvbmZpZyB0byB0cnVlLCBpbiBjYXNlIHlvdSB3YW50IHRvIHVzZSAnYmluZCcgaW5zaWRlIHlvdXIgY2VsbCBiYXNlZCBjb21wb25lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqICoqUGVyZm9ybWFuY2UgV2FybmluZyAoU3RhdGljIEJpbmRpbmdzIE9ubHkpOioqXG4gICAgICAgICAqIEJlY2F1c2UgZ3JpZCBjZWxscyBhcmUgcG9vbGVkIGFuZCByZWN5Y2xlZCBkdXJpbmcgc2Nyb2xsaW5nLCBgU3RhdGVQcm92aWRlcmAgYmluZGluZ3MgYXJlIGV2YWx1YXRlZFxuICAgICAgICAgKiBleGFjdGx5ICoqb25jZSoqIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBmaXJzdCBpbnN0YW50aWF0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFlvdXIgYGJpbmRgIGZ1bmN0aW9ucyBtdXN0ICoqbmV2ZXIqKiByZWx5IG9uIGR5bmFtaWNhbGx5IGl0ZXJhdGluZyBgcmVjb3JkYCBkYXRhIGZyb20gdGhlIGBjZWxsUmVuZGVyZXJgIHNjb3BlLlxuICAgICAgICAgKiBCaW5kaW5ncyBhcmUgc3RyaWN0bHkgZm9yIGdsb2JhbCBvciBoaWVyYXJjaGljYWwgVUkgc3RhdGUgKGUuZy4gYGFuaW1hdGVWaXN1YWxzYCkuXG4gICAgICAgICAqIEZvciByZWNvcmQtc3BlY2lmaWMgZGF0YSwgcGFzcyB0aGUgdmFsdWVzIGRpcmVjdGx5IHdpdGhpbiB0aGUgY29tcG9uZW50IGNvbmZpZyBvYmplY3QsIHdoaWNoIGlzIHVwZGF0ZWQgb24gZXZlcnkgcmVjeWNsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gdXNlQmluZGluZ3M9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHVzZUJpbmRpbmdzOiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIGFzIG5lZWRlZCBpbnNpZGUgY2xhc3MgZXh0ZW5zaW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge1JlY29yZH0gcmVjb3JkXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBhcHBseVJlY29yZENvbmZpZ3MoY29uZmlnLCByZWNvcmQpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgICBkYXRhXG4gICAgICogQHBhcmFtIHtOZW8uY29sdW1uLkJhc2V9ICAgIGRhdGEuY29sdW1uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgICAgIGRhdGEuY29sdW1uSW5kZXhcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gW2RhdGEuY29tcG9uZW50XVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgICAgICAgICBkYXRhLmRhdGFGaWVsZFxuICAgICAqIEBwYXJhbSB7TmVvLmdyaWQuQ29udGFpbmVyfSBkYXRhLmdyaWRDb250YWluZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgICAgZGF0YS5yZWNvcmRcbiAgICAgKiBAcGFyYW0ge05lby5ncmlkLlJvd30gICAgICAgZGF0YS5yb3dcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gICAgICAgICAgICAgZGF0YS5yb3dJbmRleFxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuU3RvcmV9ICAgICBkYXRhLnN0b3JlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSAgICAgIGRhdGEudmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBjZWxsUmVuZGVyZXIoZGF0YSkge1xuICAgICAgICBsZXQge2NvbXBvbmVudCwgZ3JpZENvbnRhaW5lciwgcmVjb3JkLCByb3csIHNpbGVudH0gPSBkYXRhLFxuICAgICAgICAgICAge2FwcE5hbWUsIHdpbmRvd0lkfSA9IGdyaWRDb250YWluZXIsXG4gICAgICAgICAgICBtZSAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtyZWNvcmRQcm9wZXJ0eX0gPSBtZSxcbiAgICAgICAgICAgIGNvbXBvbmVudENvbmZpZyAgPSBtZS5jb21wb25lbnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wdGltaXphdGlvbjogSWYgdGhlIHJlY29yZCBpbnN0YW5jZSBBTkQgaXRzIHZlcnNpb24gaGF2ZW4ndCBjaGFuZ2VkLCB3ZSBjYW4gc2hvcnQtY2lyY3VpdC5cbiAgICAgICAgICogVGhpcyBza2lwczpcbiAgICAgICAgICogMS4gRXhlY3V0aW5nIHRoZSAnY29tcG9uZW50JyBjb25maWcgZnVuY3Rpb24gKGlmIGl0IGlzIG9uZSkuXG4gICAgICAgICAqIDIuIENhbGxpbmcgY29tcG9uZW50LnNldCgpIHdoaWNoIHRyaWdnZXJzIHRoZSBjb25maWcgc3lzdGVtIG92ZXJoZWFkLlxuICAgICAgICAgKiAzLiBVbm5lY2Vzc2FyeSBWRE9NIHVwZGF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoY29tcG9uZW50ICYmIGNvbXBvbmVudFtyZWNvcmRQcm9wZXJ0eV0gPT09IHJlY29yZCAmJiBjb21wb25lbnQubGFzdFJlY29yZFZlcnNpb24gPT09IHJlY29yZC52ZXJzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcG9uZW50XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoTmVvLnR5cGVPZihjb21wb25lbnRDb25maWcpID09PSAnRnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb21wb25lbnRDb25maWcgPSBjb21wb25lbnRDb25maWcoZGF0YSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBvbmVudENvbmZpZyA9IG1lLmFwcGx5UmVjb3JkQ29uZmlncyhjb21wb25lbnRDb25maWcsIHJlY29yZCk7XG4gICAgICAgIGNvbXBvbmVudENvbmZpZyA9IHsuLi5jb21wb25lbnRDb25maWd9O1xuXG4gICAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudC5sYXN0UmVjb3JkVmVyc2lvbiA9IHJlY29yZC52ZXJzaW9uO1xuXG4gICAgICAgICAgICBkZWxldGUgY29tcG9uZW50Q29uZmlnLmNsYXNzTmFtZTtcbiAgICAgICAgICAgIGRlbGV0ZSBjb21wb25lbnRDb25maWcubW9kdWxlO1xuICAgICAgICAgICAgZGVsZXRlIGNvbXBvbmVudENvbmZpZy5udHlwZTtcblxuICAgICAgICAgICAgY29tcG9uZW50Q29uZmlnW3JlY29yZFByb3BlcnR5XSA9IHJlY29yZDtcblxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudENvbmZpZy5oaWRlTW9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50Q29uZmlnLmhpZGVNb2RlID0gbWUuaGlkZU1vZGVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gKipQcmV2ZW50IFN0YWxlIFN0YXRlIGluIFBvb2xlZCBDZWxscyoqXG4gICAgICAgICAgICAvLyBEdXJpbmcgZ3JpZCBzY3JvbGxpbmcgKFJvdyBQb29saW5nKSwgZXhpc3RpbmcgY2VsbCBjb21wb25lbnRzIGFyZSByZWN5Y2xlZCBmb3IgbmV3IHJlY29yZHMuXG4gICAgICAgICAgICAvLyBJZiBhIG5ldyByZWNvcmQgaXMgbWlzc2luZyBhIGRhdGEgZmllbGQsIGByZWNvcmRbZGF0YUZpZWxkXWAgcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAgICAgICAgICAgIC8vIFRoZSBOZW8ubWpzIGNvbmZpZyBzeXN0ZW0ncyBgc2V0KClgIG1ldGhvZCBpZ25vcmVzIGB1bmRlZmluZWRgIHZhbHVlcywgbWVhbmluZyB0aGVcbiAgICAgICAgICAgIC8vIGNvbXBvbmVudCB3b3VsZCByZXRhaW4gdGhlIG9sZCByZWNvcmQncyBzdGF0ZSwgY2F1c2luZyB2aXN1YWwgYnVncyAoZS5nLiwgc2hvd2luZyBhXG4gICAgICAgICAgICAvLyBHaXRIdWIgb3JnIGZyb20gdGhlIHByZXZpb3VzIHJvdyBvbiBhIHVzZXIgd2hvIGhhcyBubyBvcmdzKS5cbiAgICAgICAgICAgIC8vIENvbnZlcnRpbmcgYHVuZGVmaW5lZGAgdG8gYG51bGxgIGZvcmNlcyB0aGUgY2hhbmdlIGRldGVjdGlvbiB0byBleHBsaWNpdGx5IGNsZWFyIHRoZSBzdGF0ZS5cbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGNvbXBvbmVudENvbmZpZykge1xuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnRDb25maWdba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudENvbmZpZ1trZXldID0gbnVsbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRW5mb3JjZSBzdGF0aWMgYmluZGluZ3Mgb24gcG9vbGVkIGNvbXBvbmVudHMgdG8gcHJldmVudCBPT00gbGVha3NcbiAgICAgICAgICAgIC8vIEJpbmRpbmdzIGJlbG9uZyB0byB0aGUgZ2xvYmFsIFVJIHN0YXRlLCBub3QgaXRlcmF0aW5nIHJlY29yZCBzdGF0ZS5cbiAgICAgICAgICAgIGRlbGV0ZSBjb21wb25lbnRDb25maWcuYmluZDtcblxuICAgICAgICAgICAgY29tcG9uZW50LnNldChjb21wb25lbnRDb25maWcsIHNpbGVudClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbXBvbmVudCA9IE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIGhpZGVNb2RlOiBtZS5oaWRlTW9kZSxcbiAgICAgICAgICAgICAgICAuLi5tZS5kZWZhdWx0cyxcbiAgICAgICAgICAgICAgICAuLi5jb21wb25lbnRDb25maWcsXG4gICAgICAgICAgICAgICAgYXBwTmFtZSxcbiAgICAgICAgICAgICAgICBwYXJlbnRDb21wb25lbnQgIDogcm93LFxuICAgICAgICAgICAgICAgIFtyZWNvcmRQcm9wZXJ0eV0gOiByZWNvcmQsXG4gICAgICAgICAgICAgICAgbGFzdFJlY29yZFZlcnNpb246IHJlY29yZC52ZXJzaW9uLFxuICAgICAgICAgICAgICAgIHRoZW1lICAgICAgICAgICAgOiByb3cudGhlbWUsXG4gICAgICAgICAgICAgICAgd2luZG93SWRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBPbmx5IGNyZWF0ZSBiaW5kaW5ncyBPTkNFIHVwb24gY29tcG9uZW50IGluc3RhbnRpYXRpb25cbiAgICAgICAgICAgIGlmIChtZS51c2VCaW5kaW5ncykge1xuICAgICAgICAgICAgICAgIGdyaWRDb250YWluZXIuYm9keS5nZXRTdGF0ZVByb3ZpZGVyKCk/LmNyZWF0ZUJpbmRpbmdzKGNvbXBvbmVudClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21wb25lbnRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIHRoZSBpbnN0YW5jZSBpbnRvIGEgSlNPTi1jb21wYXRpYmxlIG9iamVjdCBmb3IgdGhlIE5ldXJhbCBMaW5rLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgbWUgID0gdGhpcyxcbiAgICAgICAgICAgIG91dCA9IHN1cGVyLnRvSlNPTigpO1xuXG4gICAgICAgIG91dC5yZWNvcmRQcm9wZXJ0eSA9IG1lLnJlY29yZFByb3BlcnR5O1xuICAgICAgICBvdXQudXNlQmluZGluZ3MgICAgPSBtZS51c2VCaW5kaW5ncztcblxuICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KG1lLmNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIG91dC5jb21wb25lbnQgPSBtZS5zZXJpYWxpemVDb25maWcobWUuY29tcG9uZW50KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE5lby5pc09iamVjdChtZS5kZWZhdWx0cykpIHtcbiAgICAgICAgICAgIG91dC5kZWZhdWx0cyA9IG1lLnNlcmlhbGl6ZUNvbmZpZyhtZS5kZWZhdWx0cylcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKENvbXBvbmVudCk7XG4iLCJpbXBvcnQgQ29tcG9uZW50Q29sdW1uICAgICAgZnJvbSAnLi9Db21wb25lbnQubWpzJztcbmltcG9ydCBDb3VudHJ5RmxhZ0NvbXBvbmVudCBmcm9tICcuLi8uLi9jb21wb25lbnQvQ291bnRyeUZsYWcubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmdyaWQuY29sdW1uLkNvdW50cnlGbGFnXG4gKiBAZXh0ZW5kcyBOZW8uZ3JpZC5jb2x1bW4uQ29tcG9uZW50XG4gKi9cbmNsYXNzIENvdW50cnlGbGFnIGV4dGVuZHMgQ29tcG9uZW50Q29sdW1uIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5ncmlkLmNvbHVtbi5Db3VudHJ5RmxhZydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmdyaWQuY29sdW1uLkNvdW50cnlGbGFnJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY29udGVudEZpZWxkPSdsb2NhdGlvbidcbiAgICAgICAgICovXG4gICAgICAgIGNvbnRlbnRGaWVsZDogJ2xvY2F0aW9uJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gZGVmYXVsdHNcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgICAgIG1vZHVsZTogQ291bnRyeUZsYWdDb21wb25lbnRcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gdHlwZT0nY291bnRyeUZsYWcnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHR5cGU6ICdjb3VudHJ5RmxhZydcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtSZWNvcmR9IHJlY29yZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgYXBwbHlSZWNvcmRDb25maWdzKGNvbmZpZywgcmVjb3JkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb3VudHJ5Q29kZTogcmVjb3JkW3RoaXMuZGF0YUZpZWxkXSxcbiAgICAgICAgICAgIGxvY2F0aW9uICAgOiByZWNvcmRbdGhpcy5jb250ZW50RmllbGRdLFxuICAgICAgICAgICAgLi4uY29uZmlnXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKENvdW50cnlGbGFnKTtcbiIsImltcG9ydCBDb2x1bW4gZnJvbSAnLi9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5ncmlkLmNvbHVtbi5DdXJyZW5jeVxuICogQGV4dGVuZHMgTmVvLmdyaWQuY29sdW1uLkJhc2VcbiAqL1xuY2xhc3MgQ3VycmVuY3kgZXh0ZW5kcyBDb2x1bW4ge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmdyaWQuY29sdW1uLkN1cnJlbmN5J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZ3JpZC5jb2x1bW4uQ3VycmVuY3knLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB0eXBlPSdjdXJyZW5jeSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdHlwZTogJ2N1cnJlbmN5JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY3VycmVuY3k9J1VTRCdcbiAgICAgICAgICovXG4gICAgICAgIGN1cnJlbmN5OiAnVVNEJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbG9jYWxlPSdkZWZhdWx0J1xuICAgICAgICAgKi9cbiAgICAgICAgbG9jYWxlOiAnZGVmYXVsdCdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtJbnRsLk51bWJlckZvcm1hdHxudWxsfSBmb3JtYXR0ZXI9bnVsbFxuICAgICAqL1xuICAgIGZvcm1hdHRlciA9IG51bGxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuICAgICAgICB0aGlzLmNyZWF0ZUZvcm1hdHRlcigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICAgIGRhdGFcbiAgICAgKiBAcGFyYW0ge05lby5idXR0b24uQmFzZX0gICAgZGF0YS5jb2x1bW5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gICAgICAgICAgICAgZGF0YS5jb2x1bW5JbmRleFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgICAgICAgICBkYXRhLmRhdGFGaWVsZFxuICAgICAqIEBwYXJhbSB7TmVvLmdyaWQuQ29udGFpbmVyfSBkYXRhLmdyaWRDb250YWluZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgICAgZGF0YS5yZWNvcmRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gICAgICAgICAgICAgZGF0YS5yb3dJbmRleFxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuU3RvcmV9ICAgICBkYXRhLnN0b3JlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSAgICAgIGRhdGEudmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBjZWxsUmVuZGVyZXIoe3ZhbHVlfSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuICcnXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXR0ZXIuZm9ybWF0KHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgY3JlYXRlRm9ybWF0dGVyKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmZvcm1hdHRlciA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChtZS5sb2NhbGUsIHtzdHlsZTogJ2N1cnJlbmN5JywgY3VycmVuY3k6IG1lLmN1cnJlbmN5fSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIHRoZSBpbnN0YW5jZSBpbnRvIGEgSlNPTi1jb21wYXRpYmxlIG9iamVjdCBmb3IgdGhlIE5ldXJhbCBMaW5rLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXG4gICAgICAgICAgICBjdXJyZW5jeTogdGhpcy5jdXJyZW5jeSxcbiAgICAgICAgICAgIGxvY2FsZSAgOiB0aGlzLmxvY2FsZVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhDdXJyZW5jeSk7XG4iLCJpbXBvcnQgQ29tcG9uZW50Q29sdW1uICAgICAgZnJvbSAnLi9Db21wb25lbnQubWpzJztcbmltcG9ydCBHaXRIdWJPcmdzQ29tcG9uZW50ICBmcm9tICcuLi8uLi9jb21wb25lbnQvR2l0SHViT3Jncy5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZ3JpZC5jb2x1bW4uR2l0SHViT3Jnc1xuICogQGV4dGVuZHMgTmVvLmdyaWQuY29sdW1uLkNvbXBvbmVudFxuICovXG5jbGFzcyBHaXRIdWJPcmdzIGV4dGVuZHMgQ29tcG9uZW50Q29sdW1uIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5ncmlkLmNvbHVtbi5HaXRIdWJPcmdzJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZ3JpZC5jb2x1bW4uR2l0SHViT3JncycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGRlZmF1bHRzXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGRlZmF1bHRzOiB7XG4gICAgICAgICAgICBtb2R1bGUgICAgICAgIDogR2l0SHViT3Jnc0NvbXBvbmVudCxcbiAgICAgICAgICAgIHJlbmRlckZ1bGxQb29sOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHR5cGU9J2dpdGh1Yk9yZ3MnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHR5cGU6ICdnaXRodWJPcmdzJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge1JlY29yZH0gcmVjb3JkXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBhcHBseVJlY29yZENvbmZpZ3MoY29uZmlnLCByZWNvcmQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9yZ3M6IHJlY29yZC5vcmdhbml6YXRpb25zLFxuICAgICAgICAgICAgLi4uY29uZmlnXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEdpdEh1Yk9yZ3MpO1xuIiwiaW1wb3J0IENvbXBvbmVudENvbHVtbiAgICAgZnJvbSAnLi9Db21wb25lbnQubWpzJztcbmltcG9ydCBHaXRIdWJVc2VyQ29tcG9uZW50IGZyb20gJy4uLy4uL2NvbXBvbmVudC9HaXRIdWJVc2VyLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5ncmlkLmNvbHVtbi5HaXRIdWJVc2VyXG4gKiBAZXh0ZW5kcyBOZW8uZ3JpZC5jb2x1bW4uQ29tcG9uZW50XG4gKi9cbmNsYXNzIEdpdEh1YlVzZXIgZXh0ZW5kcyBDb21wb25lbnRDb2x1bW4ge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmdyaWQuY29sdW1uLkdpdEh1YlVzZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5ncmlkLmNvbHVtbi5HaXRIdWJVc2VyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gZGVmYXVsdHNcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgICAgIG1vZHVsZTogR2l0SHViVXNlckNvbXBvbmVudFxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB0eXBlPSdnaXRodWJVc2VyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0eXBlOiAnZ2l0aHViVXNlcidcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtSZWNvcmR9IHJlY29yZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgYXBwbHlSZWNvcmRDb25maWdzKGNvbmZpZywgcmVjb3JkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhdmF0YXJVcmw6IHJlY29yZC5hdmF0YXJVcmwsXG4gICAgICAgICAgICBmdWxsTmFtZSA6IHJlY29yZC5uYW1lICYmIHJlY29yZC5uYW1lICE9PSByZWNvcmQubG9naW4gPyByZWNvcmQubmFtZSA6ICcnLFxuICAgICAgICAgICAgdXNlcm5hbWUgOiByZWNvcmQubG9naW4sXG4gICAgICAgICAgICAuLi5jb25maWdcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoR2l0SHViVXNlcik7XG4iLCJpbXBvcnQgQ29tcG9uZW50Q29sdW1uIGZyb20gJy4vQ29tcG9uZW50Lm1qcyc7XG5pbXBvcnQgSWNvbkNvbXBvbmVudCAgIGZyb20gJy4uLy4uL2NvbXBvbmVudC9JY29uLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5ncmlkLmNvbHVtbi5JY29uXG4gKiBAZXh0ZW5kcyBOZW8uZ3JpZC5jb2x1bW4uQ29tcG9uZW50XG4gKi9cbmNsYXNzIEljb24gZXh0ZW5kcyBDb21wb25lbnRDb2x1bW4ge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmdyaWQuY29sdW1uLkljb24nXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5ncmlkLmNvbHVtbi5JY29uJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gZGVmYXVsdHNcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgICAgIG1vZHVsZTogSWNvbkNvbXBvbmVudFxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGNlbGxJY29uQ2xzPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGNlbGxJY29uQ2xzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB0eXBlPSdpY29uJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0eXBlOiAnaWNvbidcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtSZWNvcmR9IHJlY29yZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgYXBwbHlSZWNvcmRDb25maWdzKGNvbmZpZywgcmVjb3JkKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB2YWx1ZSAgICAgICA9IHJlY29yZFttZS5kYXRhRmllbGRdLFxuICAgICAgICAgICAgY2VsbEljb25DbHMgPSBtZS5jZWxsSWNvbkNscztcblxuICAgICAgICBpZiAoY2VsbEljb25DbHMpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY2VsbEljb25DbHMsXG4gICAgICAgICAgICAgICAgaGlkZGVuOiAhdmFsdWUsXG4gICAgICAgICAgICAgICAgLi4uY29uZmlnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2VsbEljb25DbHM6IHZhbHVlLFxuICAgICAgICAgICAgaGlkZGVuICAgICA6ICF2YWx1ZSxcbiAgICAgICAgICAgIC4uLmNvbmZpZ1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhJY29uKTtcbiIsImltcG9ydCBDb21wb25lbnRDb2x1bW4gZnJvbSAnLi9Db21wb25lbnQubWpzJztcbmltcG9ydCBJY29uTGlua0NvbXBvbmVudCBmcm9tICcuLi8uLi9jb21wb25lbnQvSWNvbkxpbmsubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmdyaWQuY29sdW1uLkljb25MaW5rXG4gKiBAZXh0ZW5kcyBOZW8uZ3JpZC5jb2x1bW4uQ29tcG9uZW50XG4gKi9cbmNsYXNzIEljb25MaW5rIGV4dGVuZHMgQ29tcG9uZW50Q29sdW1uIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5ncmlkLmNvbHVtbi5JY29uTGluaydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmdyaWQuY29sdW1uLkljb25MaW5rJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gZGVmYXVsdHNcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgICAgIG1vZHVsZTogSWNvbkxpbmtDb21wb25lbnRcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBjZWxsSWNvbkNscz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBjZWxsSWNvbkNsczogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBsYWJlbEZpZWxkPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGxhYmVsRmllbGQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbnxudWxsfSBsYWJlbEZvcm1hdHRlcj1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBsYWJlbEZvcm1hdHRlcjogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gdHlwZT0naWNvbkxpbmsnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHR5cGU6ICdpY29uTGluaycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbnxudWxsfSB1cmxGb3JtYXR0ZXI9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgdXJsRm9ybWF0dGVyOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7UmVjb3JkfSByZWNvcmRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGFwcGx5UmVjb3JkQ29uZmlncyhjb25maWcsIHJlY29yZCkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGRhdGFWYWx1ZSA9IHJlY29yZFttZS5kYXRhRmllbGRdLFxuICAgICAgICAgICAgdXJsICAgICAgID0gZGF0YVZhbHVlLFxuICAgICAgICAgICAgbGFiZWwgICAgID0gbWUubGFiZWxGaWVsZCA/IHJlY29yZFttZS5sYWJlbEZpZWxkXSA6IG51bGw7XG5cbiAgICAgICAgaWYgKG1lLnVybEZvcm1hdHRlcikge1xuICAgICAgICAgICAgdXJsID0gbWUudXJsRm9ybWF0dGVyKGRhdGFWYWx1ZSwgcmVjb3JkKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lLmxhYmVsRm9ybWF0dGVyKSB7XG4gICAgICAgICAgICBsYWJlbCA9IG1lLmxhYmVsRm9ybWF0dGVyKG1lLmxhYmVsRmllbGQgPyBsYWJlbCA6IGRhdGFWYWx1ZSwgcmVjb3JkKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNlbGxJY29uQ2xzOiBtZS5jZWxsSWNvbkNscyxcbiAgICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgLi4uY29uZmlnXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEljb25MaW5rKTtcbiIsImltcG9ydCBDb2x1bW4gZnJvbSAnLi9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5ncmlkLmNvbHVtbi5JbmRleFxuICogQGV4dGVuZHMgTmVvLmdyaWQuY29sdW1uLkJhc2VcbiAqL1xuY2xhc3MgSW5kZXggZXh0ZW5kcyBDb2x1bW4ge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmdyaWQuY29sdW1uLkluZGV4J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZ3JpZC5jb2x1bW4uSW5kZXgnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB0eXBlPSdpbmRleCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdHlwZTogJ2luZGV4JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHplcm9CYXNlZD1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgemVyb0Jhc2VkOiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgICBkYXRhXG4gICAgICogQHBhcmFtIHtOZW8uYnV0dG9uLkJhc2V9ICAgIGRhdGEuY29sdW1uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgICAgIGRhdGEuY29sdW1uSW5kZXhcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICAgICAgICAgZGF0YS5kYXRhRmllbGRcbiAgICAgKiBAcGFyYW0ge05lby5ncmlkLkNvbnRhaW5lcn0gZGF0YS5ncmlkQ29udGFpbmVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICAgIGRhdGEucmVjb3JkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgICAgIGRhdGEucm93SW5kZXhcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLlN0b3JlfSAgICAgZGF0YS5zdG9yZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gICAgICBkYXRhLnZhbHVlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgY2VsbFJlbmRlcmVyKHtyb3dJbmRleH0pIHtcbiAgICAgICAgcmV0dXJuIHJvd0luZGV4ICsgKHRoaXMuemVyb0Jhc2VkID8gMCA6IDEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0aGUgaW5zdGFuY2UgaW50byBhIEpTT04tY29tcGF0aWJsZSBvYmplY3QgZm9yIHRoZSBOZXVyYWwgTGluay5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLnRvSlNPTigpLFxuICAgICAgICAgICAgemVyb0Jhc2VkOiB0aGlzLnplcm9CYXNlZFxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhJbmRleCk7XG4iLCJpbXBvcnQgQ29tcG9uZW50Q29sdW1uICAgZnJvbSAnLi9Db21wb25lbnQubWpzJztcbmltcG9ydCBJY29uTGlua0NvbXBvbmVudCBmcm9tICcuLi8uLi9jb21wb25lbnQvSWNvbkxpbmsubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmdyaWQuY29sdW1uLkxpbmtlZEluXG4gKiBAZXh0ZW5kcyBOZW8uZ3JpZC5jb2x1bW4uQ29tcG9uZW50XG4gKi9cbmNsYXNzIExpbmtlZEluIGV4dGVuZHMgQ29tcG9uZW50Q29sdW1uIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5ncmlkLmNvbHVtbi5MaW5rZWRJbidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmdyaWQuY29sdW1uLkxpbmtlZEluJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gZGVmYXVsdHNcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgICAgIG1vZHVsZTogSWNvbkxpbmtDb21wb25lbnRcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBjZWxsSWNvbkNscz0nZmEtYnJhbmRzIGZhLWxpbmtlZGluJ1xuICAgICAgICAgKi9cbiAgICAgICAgY2VsbEljb25DbHM6ICdmYS1icmFuZHMgZmEtbGlua2VkaW4nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB0eXBlPSdsaW5rZWRpbidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdHlwZTogJ2xpbmtlZGluJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge1JlY29yZH0gcmVjb3JkXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBhcHBseVJlY29yZENvbmZpZ3MoY29uZmlnLCByZWNvcmQpIHtcbiAgICAgICAgbGV0IG1lICA9IHRoaXMsXG4gICAgICAgICAgICB1cmwgPSByZWNvcmRbbWUuZGF0YUZpZWxkXTtcblxuICAgICAgICBpZiAodXJsICYmICF1cmwuc3RhcnRzV2l0aCgnaHR0cCcpKSB7XG4gICAgICAgICAgICB1cmwgPSBgaHR0cHM6Ly93d3cubGlua2VkaW4uY29tL2luLyR7dXJsfS9gXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2VsbEljb25DbHM6IG1lLmNlbGxJY29uQ2xzLFxuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgLi4uY29uZmlnXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKExpbmtlZEluKTtcbiIsImltcG9ydCBDb21wb25lbnRDb2x1bW4gICBmcm9tICcuL0NvbXBvbmVudC5tanMnO1xuaW1wb3J0IFByb2dyZXNzQ29tcG9uZW50IGZyb20gJy4uLy4uL2NvbXBvbmVudC9Qcm9ncmVzcy5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZ3JpZC5jb2x1bW4uUHJvZ3Jlc3NcbiAqIEBleHRlbmRzIE5lby5ncmlkLmNvbHVtbi5Db21wb25lbnRcbiAqL1xuY2xhc3MgUHJvZ3Jlc3MgZXh0ZW5kcyBDb21wb25lbnRDb2x1bW4ge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmdyaWQuY29sdW1uLlByb2dyZXNzJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZ3JpZC5jb2x1bW4uUHJvZ3Jlc3MnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBkZWZhdWx0c1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBkZWZhdWx0czoge1xuICAgICAgICAgICAgbW9kdWxlOiBQcm9ncmVzc0NvbXBvbmVudFxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB0eXBlPSdwcm9ncmVzcydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdHlwZTogJ3Byb2dyZXNzJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge1JlY29yZH0gcmVjb3JkXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBhcHBseVJlY29yZENvbmZpZ3MoY29uZmlnLCByZWNvcmQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmRbdGhpcy5kYXRhRmllbGRdLFxuICAgICAgICAgICAgLi4uY29uZmlnXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFByb2dyZXNzKTtcbiIsImltcG9ydCBDb21wb25lbnRDb2x1bW4gICAgZnJvbSAnLi9Db21wb25lbnQubWpzJztcbmltcG9ydCBTcGFya2xpbmVDb21wb25lbnQgZnJvbSAnLi4vLi4vY29tcG9uZW50L1NwYXJrbGluZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZ3JpZC5jb2x1bW4uU3BhcmtsaW5lXG4gKiBAZXh0ZW5kcyBOZW8uZ3JpZC5jb2x1bW4uQ29tcG9uZW50XG4gKi9cbmNsYXNzIFNwYXJrbGluZSBleHRlbmRzIENvbXBvbmVudENvbHVtbiB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZ3JpZC5jb2x1bW4uU3BhcmtsaW5lJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZ3JpZC5jb2x1bW4uU3BhcmtsaW5lJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gZGVmYXVsdHNcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgICAgIG1vZHVsZTogU3BhcmtsaW5lQ29tcG9uZW50XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gcmVuZGVyZXJDbGFzc05hbWU9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgcmVuZGVyZXJDbGFzc05hbWU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gcmVuZGVyZXJJbXBvcnRQYXRoPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHJlbmRlcmVySW1wb3J0UGF0aDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gdHlwZT0nc3BhcmtsaW5lJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0eXBlOiAnc3BhcmtsaW5lJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge1JlY29yZH0gcmVjb3JkXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBhcHBseVJlY29yZENvbmZpZ3MoY29uZmlnLCByZWNvcmQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlczogcmVjb3JkW3RoaXMuZGF0YUZpZWxkXSxcbiAgICAgICAgICAgIC4uLmNvbmZpZ1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUucmVuZGVyZXJDbGFzc05hbWUgfHwgbWUucmVuZGVyZXJJbXBvcnRQYXRoKSB7XG4gICAgICAgICAgICBtZS5kZWZhdWx0cyA9IHtcbiAgICAgICAgICAgICAgICAuLi5tZS5kZWZhdWx0cyxcbiAgICAgICAgICAgICAgICByZW5kZXJlckNsYXNzTmFtZSA6IG1lLnJlbmRlcmVyQ2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIHJlbmRlcmVySW1wb3J0UGF0aDogbWUucmVuZGVyZXJJbXBvcnRQYXRoXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFNwYXJrbGluZSk7XG4iLCJpbXBvcnQgQW5pbWF0ZWRDaGFuZ2UgICBmcm9tICcuL0FuaW1hdGVkQ2hhbmdlLm1qcyc7XG5pbXBvcnQgQW5pbWF0ZWRDdXJyZW5jeSBmcm9tICcuL0FuaW1hdGVkQ3VycmVuY3kubWpzJztcbmltcG9ydCBCYXNlICAgICAgICAgICAgIGZyb20gJy4vQmFzZS5tanMnO1xuaW1wb3J0IENvbXBvbmVudCAgICAgICAgZnJvbSAnLi9Db21wb25lbnQubWpzJztcbmltcG9ydCBDb3VudHJ5RmxhZyAgICAgIGZyb20gJy4vQ291bnRyeUZsYWcubWpzJztcbmltcG9ydCBDdXJyZW5jeSAgICAgICAgIGZyb20gJy4vQ3VycmVuY3kubWpzJztcbmltcG9ydCBHaXRIdWJPcmdzICAgICAgIGZyb20gJy4vR2l0SHViT3Jncy5tanMnO1xuaW1wb3J0IEdpdEh1YlVzZXIgICAgICAgZnJvbSAnLi9HaXRIdWJVc2VyLm1qcyc7XG5pbXBvcnQgSWNvbiAgICAgICAgICAgICBmcm9tICcuL0ljb24ubWpzJztcbmltcG9ydCBJY29uTGluayAgICAgICAgIGZyb20gJy4vSWNvbkxpbmsubWpzJztcbmltcG9ydCBJbmRleCAgICAgICAgICAgIGZyb20gJy4vSW5kZXgubWpzJztcbmltcG9ydCBMaW5rZWRJbiAgICAgICAgIGZyb20gJy4vTGlua2VkSW4ubWpzJztcbmltcG9ydCBQcm9ncmVzcyAgICAgICAgIGZyb20gJy4vUHJvZ3Jlc3MubWpzJztcbmltcG9ydCBTcGFya2xpbmUgICAgICAgIGZyb20gJy4vU3BhcmtsaW5lLm1qcyc7XG5cbmV4cG9ydCB7XG4gICAgQW5pbWF0ZWRDaGFuZ2UsXG4gICAgQW5pbWF0ZWRDdXJyZW5jeSxcbiAgICBCYXNlLFxuICAgIENvbXBvbmVudCxcbiAgICBDb3VudHJ5RmxhZyxcbiAgICBDdXJyZW5jeSxcbiAgICBHaXRIdWJPcmdzLFxuICAgIEdpdEh1YlVzZXIsXG4gICAgSWNvbixcbiAgICBJY29uTGluayxcbiAgICBJbmRleCxcbiAgICBMaW5rZWRJbixcbiAgICBQcm9ncmVzcyxcbiAgICBTcGFya2xpbmVcbn07XG4iLCJpbXBvcnQgVG9vbGJhciBmcm9tICcuLi8uLi90b29sYmFyL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmdyaWQuZm9vdGVyLlRvb2xiYXJcbiAqIEBleHRlbmRzIE5lby50b29sYmFyLkJhc2VcbiAqXG4gKiBAc3VtbWFyeSBBIHNwZWNpYWxpemVkIFRvb2xiYXIgZGVzaWduZWQgZm9yIHRoZSBmb290ZXIgYXJlYSBvZiBhIEdyaWQgQ29udGFpbmVyLlxuICpcbiAqIFRoaXMgY2xhc3MgZXh0ZW5kcyB0aGUgc3RhbmRhcmQgVG9vbGJhciB0byBwcm92aWRlIGJ1aWx0LWluIGludGVncmF0aW9uIHdpdGggdGhlIEdyaWQncyBEYXRhIFN0b3JlLlxuICogSXQgYXV0b21hdGljYWxseSBiaW5kcyB0byB0aGUgZm9sbG93aW5nIFN0b3JlIGV2ZW50cyB3aGVuIGEgc3RvcmUgaXMgYXNzaWduZWQ6XG4gKiAtIGBsb2FkYDogVHJpZ2dlcnMgYG9uU3RvcmVMb2FkYFxuICogLSBgZmlsdGVyYDogVHJpZ2dlcnMgYG9uU3RvcmVGaWx0ZXJgXG4gKiAtIGBwcm9ncmVzc2A6IFRyaWdnZXJzIGBvblN0b3JlUHJvZ3Jlc3NgICh1c2VmdWwgZm9yIHN0cmVhbWluZyBwcm94aWVzKVxuICpcbiAqIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoZXNlIHBsYWNlaG9sZGVyIG1ldGhvZHMgdG8gaW1wbGVtZW50IHNwZWNpZmljIGxvZ2ljLCBzdWNoIGFzXG4gKiB1cGRhdGluZyBzdGF0dXMgdGV4dCwgcHJvZ3Jlc3MgYmFycywgb3IgcGFnaW5hdGlvbiBjb250cm9scy5cbiAqXG4gKiBAc2VlIE5lby5ncmlkLkNvbnRhaW5lclxuICovXG5jbGFzcyBHcmlkRm9vdGVyVG9vbGJhciBleHRlbmRzIFRvb2xiYXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmdyaWQuZm9vdGVyLlRvb2xiYXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5ncmlkLmZvb3Rlci5Ub29sYmFyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2dyaWQtZm9vdGVyLXRvb2xiYXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnZ3JpZC1mb290ZXItdG9vbGJhcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1ncmlkLWZvb3Rlci10b29sYmFyJywgJ25lby10b29sYmFyJ11cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tZ3JpZC1mb290ZXItdG9vbGJhcicsICduZW8tdG9vbGJhciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmRhdGEuU3RvcmV8bnVsbH0gc3RvcmVfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzdG9yZV86IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBzdG9yZSBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuU3RvcmV8T2JqZWN0fG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5TdG9yZXxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtOZW8uZGF0YS5TdG9yZX1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0U3RvcmUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgbGlzdGVuZXJzID0ge1xuICAgICAgICAgICAgICAgIGZpbHRlciAgOiBtZS5vblN0b3JlRmlsdGVyLFxuICAgICAgICAgICAgICAgIGxvYWQgICAgOiBtZS5vblN0b3JlTG9hZCxcbiAgICAgICAgICAgICAgICBwcm9ncmVzczogbWUub25TdG9yZVByb2dyZXNzLFxuICAgICAgICAgICAgICAgIHNjb3BlICAgOiBtZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICBvbGRWYWx1ZT8udW4obGlzdGVuZXJzKTtcblxuICAgICAgICAvLyBTdG9yZSBtaWdodCBiZSBwYXNzZWQgYXMgYW4gaW5zdGFuY2Ugb3IgY29uZmlnXG4gICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5vbikge1xuICAgICAgICAgICAgdmFsdWUub24obGlzdGVuZXJzKVxuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZS5saXN0ZW5lcnMgPz89IHt9O1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih2YWx1ZS5saXN0ZW5lcnMsIGxpc3RlbmVycylcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICBPdmVyd3JpdGUgYXMgbmVlZGVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvblN0b3JlRmlsdGVyKGRhdGEpIHt9XG5cbiAgICAvKipcbiAgICAgKiBPdmVyd3JpdGUgYXMgbmVlZGVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvblN0b3JlTG9hZChkYXRhKSB7fVxuXG4gICAgLyoqXG4gICAgIE92ZXJ3cml0ZSBhcyBuZWVkZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSB7bG9hZGVkLCB0b3RhbH1cbiAgICAgKi9cbiAgICBvblN0b3JlUHJvZ3Jlc3MoZGF0YSkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoR3JpZEZvb3RlclRvb2xiYXIpO1xuIiwiaW1wb3J0IEJhc2VCdXR0b24gZnJvbSAnLi4vLi4vYnV0dG9uL0Jhc2UubWpzJztcbmltcG9ydCBOZW9BcnJheSAgIGZyb20gJy4uLy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBUZXh0RmllbGQgIGZyb20gJy4uLy4uL2Zvcm0vZmllbGQvVGV4dC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZ3JpZC5oZWFkZXIuQnV0dG9uXG4gKiBAZXh0ZW5kcyBOZW8uYnV0dG9uLkJhc2VcbiAqL1xuY2xhc3MgQnV0dG9uIGV4dGVuZHMgQmFzZUJ1dHRvbiB7XG4gICAgLyoqXG4gICAgICogVmFsaWQgdmFsdWVzIGZvciBhbGlnblxuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBjZWxsQWxpZ25WYWx1ZXM6IFsnbGVmdCcsJ2NlbnRlcicsJ3JpZ2h0J11cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBjZWxsQWxpZ25WYWx1ZXMgPSBbJ2xlZnQnLCAnY2VudGVyJywgJ3JpZ2h0J11cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmdyaWQuaGVhZGVyLkJ1dHRvbidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmdyaWQuaGVhZGVyLkJ1dHRvbicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdncmlkLWhlYWRlci1idXR0b24nXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnZ3JpZC1oZWFkZXItYnV0dG9uJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWdyaWQtaGVhZGVyLWJ1dHRvbicsJ25lby1idXR0b24nXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tZ3JpZC1oZWFkZXItYnV0dG9uJywgJ25lby1idXR0b24nXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsaWdubWVudCBvZiB0aGUgbWF0Y2hpbmcgZ3JpZCBjZWxscy4gVmFsaWQgdmFsdWVzIGFyZSBsZWZ0LCBjZW50ZXIsIHJpZ2h0XG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2VsbEFsaWduXz0nbGVmdCdcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBjZWxsQWxpZ25fOiAnbGVmdCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gZGF0YUZpZWxkPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRhdGFGaWVsZDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNvcnQgZGlyZWN0aW9uIHdoZW4gY2xpY2tpbmcgb24gYW4gdW5zb3J0ZWQgYnV0dG9uXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gZGVmYXVsdFNvcnREaXJlY3Rpb249J0FTQydcbiAgICAgICAgICovXG4gICAgICAgIGRlZmF1bHRTb3J0RGlyZWN0aW9uOiAnQVNDJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gZWRpdG9yQ29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGVkaXRvckNvbmZpZzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gZmlsdGVyQ29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGZpbHRlckNvbmZpZzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5mb3JtLmZpZWxkLkJhc2V8bnVsbH0gZmlsdGVyRmllbGQ9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBmaWx0ZXJGaWVsZDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gaWNvbkNscz0nZmEgZmEtYXJyb3ctY2lyY2xlLXVwJ1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGljb25DbHM6ICdmYSBmYS1hcnJvdy1jaXJjbGUtdXAnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBpY29uUG9zaXRpb249J3JpZ2h0J1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGljb25Qb3NpdGlvbjogJ3JpZ2h0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqICdBU0MnLCAnREVTQycgb3IgbnVsbFxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gaXNTb3J0ZWRfPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGlzU29ydGVkXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gcm9sZT0nY29sdW1uaGVhZGVyJ1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHJvbGU6ICdjb2x1bW5oZWFkZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2hvd0hlYWRlckZpbHRlcl89ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzaG93SGVhZGVyRmlsdGVyXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzb3J0YWJsZV89dHJ1ZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHNvcnRhYmxlXzogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgZW5hYmxlcyByZXN0b3JpbmcgdGhlIGluaXRpYWwgc29ydCBzdGF0ZSAoQVNDLCBERVNDLCBudWxsKVxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB1c2VUcmlTdGF0ZVNvcnRpbmdfPWZhbHNlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdXNlVHJpU3RhdGVTb3J0aW5nXzogZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGlzU29ydGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRJc1NvcnRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2xzfSAgICAgPSBtZSxcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IG1lLnVwKCdncmlkLWNvbnRhaW5lcicpO1xuXG4gICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgbnVsbDpcbiAgICAgICAgICAgICAgICBOZW9BcnJheS5hZGQoY2xzLCAnbmVvLXNvcnQtaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgJ0FTQyc6XG4gICAgICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgJ25lby1zb3J0LWRlc2MnKTtcbiAgICAgICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUoY2xzLCAnbmVvLXNvcnQtaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgTmVvQXJyYXkuYWRkKGNscywgJ25lby1zb3J0LWFzYycpO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlICdERVNDJzpcbiAgICAgICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUoY2xzLCAnbmVvLXNvcnQtYXNjJyk7XG4gICAgICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgJ25lby1zb3J0LWhpZGRlbicpO1xuICAgICAgICAgICAgICAgIE5lb0FycmF5LmFkZChjbHMsICduZW8tc29ydC1kZXNjJyk7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmNscyA9IGNscztcblxuICAgICAgICAvLyB0ZXN0aW5nIGNoZWNrIHVudGlsIGFsbCBleGFtcGxlIGdyaWRzIGhhdmUgYSBzdG9yZVxuICAgICAgICBpZiAoIWNvbnRhaW5lciB8fCAhY29udGFpbmVyLnN0b3JlKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIG1lLm1vdW50ZWQgJiYgbWUuZmlyZSgnc29ydCcsIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbjogdmFsdWUsXG4gICAgICAgICAgICBwcm9wZXJ0eSA6IG1lLmRhdGFGaWVsZFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc2hvd0hlYWRlckZpbHRlciBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNob3dIZWFkZXJGaWx0ZXIodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIW1lLmZpbHRlckZpZWxkKSB7XG4gICAgICAgICAgICAgICAgbWUuZmlsdGVyRmllbGQgPSBOZW8uY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlICAgOiBUZXh0RmllbGQsXG4gICAgICAgICAgICAgICAgICAgIGFwcE5hbWUgIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZmxhZyAgICAgOiAnZmlsdGVyLWZpZWxkJyxcbiAgICAgICAgICAgICAgICAgICAgaGlkZUxhYmVsOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZCA6IG1lLmlkLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZSAgICA6IHttYXJnaW5MZWZ0OiAnLjVlbScsIG1hcmdpblJpZ2h0OiAnLjVlbSd9LFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3dJZCA6IG1lLndpbmRvd0lkLFxuXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlICAgICAgICA6IG1lLmNoYW5nZUZpbHRlclZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3JDaGFuZ2U6IG1lLmNoYW5nZUZpbHRlck9wZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUgICAgICAgICA6IG1lXG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgLi4ubWUuZWRpdG9yQ29uZmlnXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBtZS52ZG9tLmNuLnB1c2gobWUuZmlsdGVyRmllbGQuY3JlYXRlVmRvbVJlZmVyZW5jZSgpKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgbWUuZmlsdGVyRmllbGQudmRvbS5yZW1vdmVEb21cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtZS5maWx0ZXJGaWVsZCkge1xuICAgICAgICAgICAgbWUuZmlsdGVyRmllbGQudmRvbS5yZW1vdmVEb20gPSB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICBtZS51cGRhdGVEZXB0aCA9IDI7XG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzb3J0YWJsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNvcnRhYmxlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAge2Nsc30gPSBtZTtcblxuICAgICAgICBOZW9BcnJheS50b2dnbGUoY2xzLCAnbmVvLXNvcnQtaGlkZGVuJywgIXZhbHVlKTtcblxuICAgICAgICBtZS5jbHMgPSBjbHM7XG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgY2VsbEFsaWduIGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0Q2VsbEFsaWduKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnY2VsbEFsaWduJywgJ2NlbGxBbGlnblZhbHVlcycpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBkZXN0cm95KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5maWx0ZXJGaWVsZD8uZGVzdHJveSgpO1xuICAgICAgICBzdXBlci5kZXN0cm95KC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25DbGljayhkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBtYXA7XG5cbiAgICAgICAgaWYgKG1lLmRlZmF1bHRTb3J0RGlyZWN0aW9uID09PSAnREVTQycpIHtcbiAgICAgICAgICAgIG1hcCA9IHtcbiAgICAgICAgICAgICAgICBBU0MgOiBtZS51c2VUcmlTdGF0ZVNvcnRpbmcgPyBudWxsIDogJ0RFU0MnLFxuICAgICAgICAgICAgICAgIERFU0M6ICdBU0MnLFxuICAgICAgICAgICAgICAgIG51bGw6ICdERVNDJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFwID0ge1xuICAgICAgICAgICAgICAgIEFTQyA6ICdERVNDJyxcbiAgICAgICAgICAgICAgICBERVNDOiBtZS51c2VUcmlTdGF0ZVNvcnRpbmcgPyBudWxsIDogJ0FTQycsXG4gICAgICAgICAgICAgICAgbnVsbDogJ0FTQydcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmlzU29ydGVkID0gbWFwW21lLmlzU29ydGVkICsgJyddO1xuXG4gICAgICAgIHN1cGVyLm9uQ2xpY2soZGF0YSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGNoYW5nZUZpbHRlck9wZXJhdG9yKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZ3JpZENvbnRhaW5lciA9IG1lLnVwKCdncmlkLWNvbnRhaW5lcicpLFxuICAgICAgICAgICAgc3RvcmUgICAgICAgICA9IGdyaWRDb250YWluZXI/LnN0b3JlLFxuICAgICAgICAgICAgb3BlcmF0b3IgICAgICA9IGRhdGEudmFsdWUsXG4gICAgICAgICAgICBmaWx0ZXIsIGZpbHRlcnM7XG5cbiAgICAgICAgaWYgKHN0b3JlKSB7XG4gICAgICAgICAgICBmaWx0ZXIgPSBzdG9yZS5nZXRGaWx0ZXIobWUuZGF0YUZpZWxkKTtcblxuICAgICAgICAgICAgaWYgKCFmaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJzID0gc3RvcmUuZmlsdGVycztcblxuICAgICAgICAgICAgICAgIGZpbHRlcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBtZS5kYXRhRmllbGQsXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgLi4ubWUuZmlsdGVyQ29uZmlnXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBzdG9yZS5maWx0ZXJzID0gZmlsdGVyc1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIub3BlcmF0b3IgPSBvcGVyYXRvclxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBjaGFuZ2VGaWx0ZXJWYWx1ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGdyaWRDb250YWluZXIgPSBtZS51cCgnZ3JpZC1jb250YWluZXInKSxcbiAgICAgICAgICAgIHN0b3JlICAgICAgICAgPSBncmlkQ29udGFpbmVyPy5zdG9yZSxcbiAgICAgICAgICAgIHt2YWx1ZX0gICAgICAgPSBkYXRhLFxuICAgICAgICAgICAgZmllbGQsIGZpbHRlciwgZmlsdGVycywgbW9kZWw7XG5cbiAgICAgICAgaWYgKHN0b3JlKSB7XG4gICAgICAgICAgICBmaWx0ZXIgPSBzdG9yZS5nZXRGaWx0ZXIobWUuZGF0YUZpZWxkKTtcbiAgICAgICAgICAgIG1vZGVsICA9IHN0b3JlLm1vZGVsO1xuICAgICAgICAgICAgZmllbGQgID0gbW9kZWwuZ2V0RmllbGQobWUuZGF0YUZpZWxkKTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlICYmIGZpZWxkPy50eXBlLnRvTG93ZXJDYXNlKCkgPT09ICdkYXRlJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUodmFsdWUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVycyA9IHN0b3JlLmZpbHRlcnM7XG5cbiAgICAgICAgICAgICAgICBmaWx0ZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogbWUuZGF0YUZpZWxkLFxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogJ2xpa2UnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgLi4ubWUuZmlsdGVyQ29uZmlnXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBzdG9yZS5maWx0ZXJzID0gZmlsdGVyc1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIudmFsdWUgPSB2YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHJlbW92ZVNvcnRpbmdDc3MoKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2xzfSA9IG1lO1xuXG4gICAgICAgIE5lb0FycmF5LmFkZChjbHMsICduZW8tc29ydC1oaWRkZW4nKTtcblxuICAgICAgICBtZS5jbHMgICAgICAgPSBjbHM7XG4gICAgICAgIG1lLl9pc1NvcnRlZCA9IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXG4gICAgICAgICAgICBjZWxsQWxpZ24gICAgICAgICAgIDogbWUuY2VsbEFsaWduLFxuICAgICAgICAgICAgZGF0YUZpZWxkICAgICAgICAgICA6IG1lLmRhdGFGaWVsZCxcbiAgICAgICAgICAgIGRlZmF1bHRTb3J0RGlyZWN0aW9uOiBtZS5kZWZhdWx0U29ydERpcmVjdGlvbixcbiAgICAgICAgICAgIGVkaXRvckNvbmZpZyAgICAgICAgOiBtZS5zZXJpYWxpemVDb25maWcobWUuZWRpdG9yQ29uZmlnKSxcbiAgICAgICAgICAgIGZpbHRlckNvbmZpZyAgICAgICAgOiBtZS5zZXJpYWxpemVDb25maWcobWUuZmlsdGVyQ29uZmlnKSxcbiAgICAgICAgICAgIGlzU29ydGVkICAgICAgICAgICAgOiBtZS5pc1NvcnRlZCxcbiAgICAgICAgICAgIHNob3dIZWFkZXJGaWx0ZXIgICAgOiBtZS5zaG93SGVhZGVyRmlsdGVyLFxuICAgICAgICAgICAgc29ydGFibGUgICAgICAgICAgICA6IG1lLnNvcnRhYmxlLFxuICAgICAgICAgICAgdXNlVHJpU3RhdGVTb3J0aW5nICA6IG1lLnVzZVRyaVN0YXRlU29ydGluZ1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhCdXR0b24pO1xuIiwiaW1wb3J0IEJhc2VUb29sYmFyIGZyb20gJy4uLy4uL3Rvb2xiYXIvQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZ3JpZC5oZWFkZXIuVG9vbGJhclxuICogQGV4dGVuZHMgTmVvLnRvb2xiYXIuQmFzZVxuICovXG5jbGFzcyBUb29sYmFyIGV4dGVuZHMgQmFzZVRvb2xiYXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmdyaWQuaGVhZGVyLlRvb2xiYXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5ncmlkLmhlYWRlci5Ub29sYmFyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2dyaWQtaGVhZGVyLXRvb2xiYXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnZ3JpZC1oZWFkZXItdG9vbGJhcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1ncmlkLWhlYWRlci10b29sYmFyJywnbmVvLXRvb2xiYXInXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tZ3JpZC1oZWFkZXItdG9vbGJhcicsICduZW8tdG9vbGJhciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZHJhZ1Jlc29ydGFibGU9dHJ1ZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdSZXNvcnRhYmxlOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBpdGVtRGVmYXVsdHM9e250eXBlOiAnZ3JpZC1oZWFkZXItYnV0dG9uJ31cbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtRGVmYXVsdHM6IHtcbiAgICAgICAgICAgIG50eXBlOiAnZ3JpZC1oZWFkZXItYnV0dG9uJ1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSByb2xlPSdyb3cnXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgcm9sZTogJ3JvdycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHNjcm9sbExlZnRfPTBcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzY3JvbGxMZWZ0XzogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNob3dIZWFkZXJGaWx0ZXJzXz1mYWxzZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHNob3dIZWFkZXJGaWx0ZXJzXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dCB0byBwYXNzIHNvcnRhYmxlIHRvIGFsbCB0b29sYmFyIGl0ZW1zLlxuICAgICAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgaGVhZGVyIGNsaWNrcyB3aWxsIHNvcnQgdGhlIG1hdGNoaW5nIGNvbHVtbiAoQVNDLCBERVNDLCBudWxsKVxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzb3J0YWJsZV89dHJ1ZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHNvcnRhYmxlXzogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlbmllbmNlIHNob3J0Y3V0IHRvIHBhc3MgdXNlVHJpU3RhdGVTb3J0aW5nIHRvIGFsbCB0b29sYmFyIGl0ZW1zLlxuICAgICAgICAgKiBUcnVlIGVuYWJsZXMgcmVzdG9yaW5nIHRoZSBpbml0aWFsIHNvcnQgc3RhdGUgKEFTQywgREVTQywgbnVsbClcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gdXNlVHJpU3RhdGVTb3J0aW5nXz1mYWxzZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHVzZVRyaVN0YXRlU29ydGluZ186IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbVxuICAgICAgICAgKi9cbiAgICAgICAgX3Zkb206XG4gICAgICAgIHsnYXJpYS1yb3dpbmRleCc6IDEsIGNuOiBbe2NuOiBbXX1dfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbW91bnRlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB2YWx1ZSAmJiB0aGlzLnBhc3NTaXplVG9Cb2R5KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNob3dIZWFkZXJGaWx0ZXJzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U2hvd0hlYWRlckZpbHRlcnModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgICAgICBtZS5pdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIGl0ZW0uc2V0U2lsZW50KHtcbiAgICAgICAgICAgICAgICAgICAgc2hvd0hlYWRlckZpbHRlcjogdmFsdWVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLnVwZGF0ZURlcHRoID0gLTE7IC8vIGZpbHRlcnMgY2FuIGJlIGRlZXBseSBuZXN0ZWRcbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNjcm9sbExlZnQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U2Nyb2xsTGVmdCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5zb3J0Wm9uZSkge1xuICAgICAgICAgICAgdGhpcy5zb3J0Wm9uZS5zY3JvbGxMZWZ0ID0gdmFsdWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc29ydGFibGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTb3J0YWJsZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIG1lLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgaXRlbS5zZXRTaWxlbnQoe1xuICAgICAgICAgICAgICAgICAgICBzb3J0YWJsZTogdmFsdWVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLnVwZGF0ZURlcHRoID0gMjtcbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHVzZVRyaVN0YXRlU29ydGluZyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFVzZVRyaVN0YXRlU29ydGluZyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIG1lLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgaXRlbS5zZXRTaWxlbnQoe1xuICAgICAgICAgICAgICAgICAgICB1c2VUcmlTdGF0ZVNvcnRpbmc6IHZhbHVlXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS51cGRhdGVEZXB0aCA9IDI7XG4gICAgICAgICAgICBtZS51cGRhdGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtcygpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7bW91bnRlZH0gPSBtZTtcblxuICAgICAgICBtZS5pdGVtRGVmYXVsdHMuc2hvd0hlYWRlckZpbHRlciA9IG1lLnNob3dIZWFkZXJGaWx0ZXJzO1xuXG4gICAgICAgIG1lLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5oYXNPd24oaXRlbSwgJ3NvcnRhYmxlJykpIHtcbiAgICAgICAgICAgICAgICBpdGVtLnNvcnRhYmxlID0gbWUuc29ydGFibGVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFPYmplY3QuaGFzT3duKGl0ZW0sICd1c2VUcmlTdGF0ZVNvcnRpbmcnKSkge1xuICAgICAgICAgICAgICAgIGl0ZW0udXNlVHJpU3RhdGVTb3J0aW5nID0gbWUudXNlVHJpU3RhdGVTb3J0aW5nXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHN1cGVyLmNyZWF0ZUl0ZW1zKCk7XG5cbiAgICAgICAgbGV0IHtpdGVtc30gPSBtZSxcbiAgICAgICAgICAgIHN0eWxlO1xuXG4gICAgICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpdGVtLnZkb21bJ2FyaWEtY29saW5kZXgnXSA9IGluZGV4ICsgMTsgLy8gMSBiYXNlZFxuXG4gICAgICAgICAgICBzdHlsZSA9IGl0ZW0ud3JhcHBlclN0eWxlO1xuXG4gICAgICAgICAgICAvLyB0b2RvOiBvbmx5IGFkZCBweCBpZiBudW1iZXJcbiAgICAgICAgICAgIGlmIChpdGVtLm1heFdpZHRoKSB7c3R5bGUubWF4V2lkdGggPSBpdGVtLm1heFdpZHRoICsgJ3B4J31cbiAgICAgICAgICAgIGlmIChpdGVtLm1pbldpZHRoKSB7c3R5bGUubWluV2lkdGggPSBpdGVtLm1pbldpZHRoICsgJ3B4J31cbiAgICAgICAgICAgIGlmIChpdGVtLndpZHRoKSAgICB7c3R5bGUud2lkdGggICAgPSBpdGVtLndpZHRoICAgICsgJ3B4J31cblxuICAgICAgICAgICAgaXRlbS53cmFwcGVyU3R5bGUgPSBzdHlsZVxuICAgICAgICB9KTtcblxuICAgICAgICBtZS5wcm9taXNlVXBkYXRlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAvLyBUbyBwcmV2ZW50IGR1cGxpY2F0ZSBjYWxscywgd2UgbmVlZCB0byBjaGVjayB0aGUgbW91bnRlZCBzdGF0ZSBiZWZvcmUgdGhlIHVwZGF0ZSBjYWxsXG4gICAgICAgICAgICBtb3VudGVkICYmIG1lLnBhc3NTaXplVG9Cb2R5KClcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY3JlYXRlU29ydFpvbmUoY29uZmlnKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgTmVvLm1lcmdlKGNvbmZpZywge1xuICAgICAgICAgICAgYm91bmRhcnlDb250YWluZXJJZDogW21lLmlkLCBtZS5wYXJlbnQuaWRdLFxuICAgICAgICAgICAgc2Nyb2xsTGVmdCAgICAgICAgIDogbWUuc2Nyb2xsTGVmdFxuICAgICAgICB9KTtcblxuICAgICAgICBzdXBlci5jcmVhdGVTb3J0Wm9uZShjb25maWcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFGaWVsZFxuICAgICAqIEByZXR1cm5zIHtOZW8uYnV0dG9uLkJhc2V8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRDb2x1bW4oZGF0YUZpZWxkKSB7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLml0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5kYXRhRmllbGQgPT09IGRhdGFGaWVsZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgbG9hZFNvcnRab25lTW9kdWxlKCkge1xuICAgICAgICByZXR1cm4gaW1wb3J0KCcuLi8uLi9kcmFnZ2FibGUvZ3JpZC9oZWFkZXIvdG9vbGJhci9Tb3J0Wm9uZS5tanMnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50PWZhbHNlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYXN5bmMgcGFzc1NpemVUb0JvZHkoc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2l0ZW1zfSAgICAgICAgID0gbWUsXG4gICAgICAgICAgICB7Ym9keX0gICAgICAgICAgPSBtZS5wYXJlbnQsXG4gICAgICAgICAgICByZWN0cyAgICAgICAgICAgPSBhd2FpdCBtZS5nZXREb21SZWN0KGl0ZW1zLm1hcChpdGVtID0+IGl0ZW0uaWQpKSxcbiAgICAgICAgICAgIGxhc3RJdGVtICAgICAgICA9IHJlY3RzW3JlY3RzLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgY29sdW1uUG9zaXRpb25zID0gcmVjdHMubWFwKChpdGVtLCBpbmRleCkgPT4gKHtkYXRhRmllbGQ6IGl0ZW1zW2luZGV4XS5kYXRhRmllbGQsIHdpZHRoOiBpdGVtLndpZHRoLCB4OiBpdGVtLnggLSByZWN0c1swXS54fSkpLFxuICAgICAgICAgICAgaSAgICAgICAgICAgICAgID0gMSxcbiAgICAgICAgICAgIGxlbiAgICAgICAgICAgICA9IGNvbHVtblBvc2l0aW9ucy5sZW5ndGgsXG4gICAgICAgICAgICBsYXlvdXRGaW5pc2hlZCAgPSB0cnVlO1xuXG4gICAgICAgIC8vIElmIHRoZSBjc3Mgc2l6aW5nIGlzIG5vdCBkb25lLCBjb2x1bW5zIGFmdGVyIHRoZSBmaXJzdCBvbmUgY2FuIGdldCB4ID0gMFxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY29sdW1uUG9zaXRpb25zW2ldLnggPT09IDApIHtcbiAgICAgICAgICAgICAgICBsYXlvdXRGaW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVsYXkgZm9yIHNsb3cgY29ubmVjdGlvbnMsIHdoZXJlIHRoZSBjb250YWluZXItc2l6aW5nIGlzIG5vdCBkb25lIHlldFxuICAgICAgICBpZiAoIWxheW91dEZpbmlzaGVkKSB7XG4gICAgICAgICAgICBhd2FpdCBtZS50aW1lb3V0KDEwMCk7XG4gICAgICAgICAgICBhd2FpdCBtZS5wYXNzU2l6ZVRvQm9keShzaWxlbnQpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBib2R5LmNvbHVtblBvc2l0aW9ucy5jbGVhcigpO1xuICAgICAgICAgICAgYm9keS5jb2x1bW5Qb3NpdGlvbnMuYWRkKGNvbHVtblBvc2l0aW9ucyk7XG5cbiAgICAgICAgICAgIGJvZHlbc2lsZW50ID8gJ3NldFNpbGVudCcgOiAnc2V0J10oe1xuICAgICAgICAgICAgICAgIGF2YWlsYWJsZVdpZHRoOiBsYXN0SXRlbS54ICsgbGFzdEl0ZW0ud2lkdGggLSByZWN0c1swXS54XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgIXNpbGVudCAmJiBib2R5LnVwZGF0ZU1vdW50ZWRBbmRWaXNpYmxlQ29sdW1ucygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gIGluZGV4XG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYXN5bmMgc2Nyb2xsVG9JbmRleChpbmRleCkge1xuICAgICAgICBhd2FpdCBOZW8ubWFpbi5Eb21BY2Nlc3Muc2Nyb2xsSW50b1ZpZXcoe1xuICAgICAgICAgICAgZGVsYXkgICA6IDEyNSxcbiAgICAgICAgICAgIGlkICAgICAgOiB0aGlzLml0ZW1zW2luZGV4XS5pZCxcbiAgICAgICAgICAgIHdpbmRvd0lkOiB0aGlzLndpbmRvd0lkXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLnRvSlNPTigpLFxuICAgICAgICAgICAgc2Nyb2xsTGVmdCAgICAgICAgOiBtZS5zY3JvbGxMZWZ0LFxuICAgICAgICAgICAgc2hvd0hlYWRlckZpbHRlcnMgOiBtZS5zaG93SGVhZGVyRmlsdGVycyxcbiAgICAgICAgICAgIHNvcnRhYmxlICAgICAgICAgIDogbWUuc29ydGFibGUsXG4gICAgICAgICAgICB1c2VUcmlTdGF0ZVNvcnRpbmc6IG1lLnVzZVRyaVN0YXRlU29ydGluZ1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhUb29sYmFyKTtcbiIsImltcG9ydCBCdXR0b24gIGZyb20gJy4vQnV0dG9uLm1qcyc7XG5pbXBvcnQgVG9vbGJhciBmcm9tICcuL1Rvb2xiYXIubWpzJztcblxuZXhwb3J0IHtCdXR0b24sIFRvb2xiYXJ9OyIsImltcG9ydCBCYXNlICAgICAgICAgICBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBOZW9BcnJheSAgICAgICBmcm9tICcuLi91dGlsL0FycmF5Lm1qcyc7XG5pbXBvcnQgT2JzZXJ2YWJsZSAgICAgZnJvbSAnLi4vY29yZS9PYnNlcnZhYmxlLm1qcyc7XG5pbXBvcnQge2lzRGVzY3JpcHRvcn0gZnJvbSAnLi4vY29yZS9Db25maWdTeW1ib2xzLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5zZWxlY3Rpb24uTW9kZWxcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqIEBtaXhlcyBOZW8uY29yZS5PYnNlcnZhYmxlXG4gKi9cbmNsYXNzIE1vZGVsIGV4dGVuZHMgQmFzZSB7XG4gICAgLyoqXG4gICAgICogVHJ1ZSBhdXRvbWF0aWNhbGx5IGFwcGxpZXMgdGhlIGNvcmUuT2JzZXJ2YWJsZSBtaXhpblxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG9ic2VydmFibGU9dHJ1ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgb2JzZXJ2YWJsZSA9IHRydWVcblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnNlbGVjdGlvbi5Nb2RlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnNlbGVjdGlvbi5Nb2RlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdzZWxlY3Rpb24tbW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnc2VsZWN0aW9uLW1vZGVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBsYWNlaG9sZGVyIGZvciBleHRlbmRlZCBjbGFzc2VzIHRvIGFkZCBhIGN1c3RvbSBjc3MgcnVsZSB0byB0aGlzIG93bmVyIGNvbXBvbmVudFxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gY2xzPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl9IGl0ZW1zX1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbXNfOiB7XG4gICAgICAgICAgICBbaXNEZXNjcmlwdG9yXTogdHJ1ZSxcbiAgICAgICAgICAgIGNsb25lICAgICAgICAgOiAnc2hhbGxvdycsXG4gICAgICAgICAgICBjbG9uZU9uR2V0ICAgIDogJ25vbmUnLFxuICAgICAgICAgICAgaXNFcXVhbCAgICAgICA6ICgpID0+IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWUgICAgICAgICA6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHNlbGVjdGVkQ2xzPSdzZWxlY3RlZCdcbiAgICAgICAgICovXG4gICAgICAgIHNlbGVjdGVkQ2xzOiAnbmVvLXNlbGVjdGVkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZVNlbGVjdD10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBzaW5nbGVTZWxlY3Q6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbGx5IHNhdmVzIHRoZSB2aWV3IGlkLCBidXQgdGhlIGdldHRlciB3aWxsIHJldHVybiB0aGUgbWF0Y2hpbmcgaW5zdGFuY2VcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSB2aWV3Xz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB2aWV3XzogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdHJpZ2dlcmVkIGJlZm9yZSBnZXR0aW5nIHRoZSB2YWx1ZSBvZiB0aGUgdmlldyBjb25maWdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlfVxuICAgICAqL1xuICAgIGJlZm9yZUdldFZpZXcodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIE5lby5nZXRDb21wb25lbnQodGhpcy5fdmlldylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCBiZWZvcmUgc2V0dGluZyB0aGUgdmFsdWUgb2YgdGhlIHZpZXcgY29uZmlnXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdGhlIHZpZXcgaWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRWaWV3KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS5pZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgYWRkRG9tTGlzdGVuZXIoKSB7fVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnRdIHRydWUgdG8gcHJldmVudCBhIHZkb20gdXBkYXRlXG4gICAgICogQHBhcmFtIHtPYmplY3RbXXxTdHJpbmdbXX0gaXRlbUNvbGxlY3Rpb249dGhpcy5pdGVtc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2VsZWN0ZWRDbHNdXG4gICAgICovXG4gICAgZGVzZWxlY3QoaXRlbSwgc2lsZW50LCBpdGVtQ29sbGVjdGlvbj10aGlzLml0ZW1zLCBzZWxlY3RlZENscykge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt2aWV3fSA9IG1lLFxuICAgICAgICAgICAgbm9kZTtcblxuICAgICAgICAvLyBXZSBob2xkIHZkb20gaWRzIGZvciBub3csIHNvIGFsbCBpbmNvbWluZyBzZWxlY3Rpb25zIG11c3QgYmUgY29udmVydGVkLlxuICAgICAgICBpdGVtID0gaXRlbS5pc1JlY29yZCA/IHZpZXcuZ2V0SXRlbUlkKGl0ZW0pIDogTmVvLmlzT2JqZWN0KGl0ZW0pID8gaXRlbS5pZCA6IGl0ZW07XG5cbiAgICAgICAgaWYgKGl0ZW1Db2xsZWN0aW9uLmluY2x1ZGVzKGl0ZW0pKSB7XG4gICAgICAgICAgICBub2RlID0gdmlldy5nZXRWZG9tQ2hpbGQoaXRlbSk7XG5cbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5jbHMgPSBOZW9BcnJheS5yZW1vdmUobm9kZS5jbHMgfHwgW10sIHNlbGVjdGVkQ2xzIHx8IG1lLnNlbGVjdGVkQ2xzKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgbm9kZVsnYXJpYS1zZWxlY3RlZCddXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZShpdGVtQ29sbGVjdGlvbiwgaXRlbSk7XG5cbiAgICAgICAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgdmlldy51cGRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHZpZXcucGFyZW50Py5vbkRlc2VsZWN0Py4oKTsgLy8gZ3JpZC5Db250YWluZXIgJiB0YWJsZS5Db250YWluZXJcbiAgICAgICAgICAgICAgICB2aWV3Lm9uRGVzZWxlY3Q/LigpO1xuXG4gICAgICAgICAgICAgICAgbWUuZmlyZSgnc2VsZWN0aW9uQ2hhbmdlJywge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb246IGl0ZW1Db2xsZWN0aW9uXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgICBtZS5maXJlKCdub0NoYW5nZScpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnRdIHRydWUgdG8gcHJldmVudCBhIHZkb20gdXBkYXRlXG4gICAgICogQHBhcmFtIHtPYmplY3RbXXxTdHJpbmdbXX0gaXRlbUNvbGxlY3Rpb249dGhpcy5pdGVtc1xuICAgICAqL1xuICAgIGRlc2VsZWN0QWxsKHNpbGVudCwgaXRlbUNvbGxlY3Rpb249dGhpcy5pdGVtcykge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW1zICA9IFsuLi5pdGVtQ29sbGVjdGlvbl0sXG4gICAgICAgICAgICB7dmlld30gPSBtZTtcblxuICAgICAgICBpZiAoaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIG1lLmRlc2VsZWN0KGl0ZW0sIHRydWUpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFzaWxlbnQgJiYgaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZpZXcudXBkYXRlKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUuZmlyZSgnc2VsZWN0aW9uQ2hhbmdlJywge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogdGhpcy5pdGVtc1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgICBtZS5maXJlKCdub0NoYW5nZScpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGRlc3Ryb3koLi4uYXJncykge1xuICAgICAgICB0aGlzLnVucmVnaXN0ZXIoKTtcbiAgICAgICAgc3VwZXIuZGVzdHJveSguLi5hcmdzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEltcG9ydGFudCBmb3IgbWFwcGluZyBsaXN0ZW5lcnMgdG8gdmlldyBjb250cm9sbGVyc1xuICAgICAqIEByZXR1cm5zIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRDb250cm9sbGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LmdldENvbnRyb2xsZXIoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gdGhpcy5pdGVtc1xuICAgICAqL1xuICAgIGdldFNlbGVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNTZWxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmxlbmd0aCA+IDBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpbiBjYXNlIHRoZSBpdGVtIGlzIHNlbGVjdGVkXG4gICAgICovXG4gICAgaXNTZWxlY3RlZChpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5pbmNsdWRlcyhpZClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50XG4gICAgICovXG4gICAgcmVnaXN0ZXIoY29tcG9uZW50KSB7XG4gICAgICAgIGxldCBtZSAgPSB0aGlzLFxuICAgICAgICAgICAgY2xzID0gY29tcG9uZW50LndyYXBwZXJDbHMgfHwgW107XG5cbiAgICAgICAgaWYgKG1lLmNscyAmJiAhY2xzLmluY2x1ZGVzKG1lLmNscykpIHtcbiAgICAgICAgICAgIGNscy5wdXNoKG1lLmNscyk7XG4gICAgICAgICAgICBjb21wb25lbnQud3JhcHBlckNscyA9IGNsc1xuICAgICAgICB9XG5cbiAgICAgICAgbWUudmlldyA9IGNvbXBvbmVudDtcbiAgICAgICAgbWUuYWRkRG9tTGlzdGVuZXIoKTtcblxuICAgICAgICBjb21wb25lbnQuZmlyZSgnc2VsZWN0aW9uTW9kZWxDaGFuZ2UnLCB7XG4gICAgICAgICAgICB2YWx1ZTogbWVcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHJlbW92ZURvbUxpc3RlbmVycygpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb21wb25lbnQgICAgPSBtZS52aWV3LFxuICAgICAgICAgICAgZG9tTGlzdGVuZXJzID0gWy4uLmNvbXBvbmVudC5kb21MaXN0ZW5lcnNdO1xuXG4gICAgICAgIGNvbXBvbmVudC5kb21MaXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiB7XG4gICAgICAgICAgICBpZiAobGlzdGVuZXIuc2NvcGUgPT09IG1lKSB7XG4gICAgICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGRvbUxpc3RlbmVycywgbGlzdGVuZXIpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbXBvbmVudC5kb21MaXN0ZW5lcnMgPSBkb21MaXN0ZW5lcnNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdHxPYmplY3RbXXxTdHJpbmdbXX0gaXRlbXNcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfFN0cmluZ1tdfSBpdGVtQ29sbGVjdGlvbj10aGlzLml0ZW1zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzZWxlY3RlZENsc11cbiAgICAgKi9cbiAgICBzZWxlY3QoaXRlbXMsIGl0ZW1Db2xsZWN0aW9uPXRoaXMuaXRlbXMsIHNlbGVjdGVkQ2xzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICAgICAgICAgIGl0ZW1zID0gW2l0ZW1zXVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3ZpZXd9ICA9IG1lLFxuICAgICAgICAgICAgcmVjb3JkcyA9IGl0ZW1zLm1hcChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5pc1JlY29yZCkgcmV0dXJuIGl0ZW07XG5cbiAgICAgICAgICAgICAgICBjb25zdCByZWNvcmRJZCA9IHZpZXcuZ2V0SXRlbVJlY29yZElkPy4oaXRlbSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjb3JkSWQgJiYgdmlldy5zdG9yZT8uZ2V0KHJlY29yZElkKSB8fCBpdGVtXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBXZSBob2xkIHZkb20gaWRzIGZvciBub3csIHNvIGFsbCBpbmNvbWluZyBzZWxlY3Rpb25zIG11c3QgYmUgY29udmVydGVkLlxuICAgICAgICBpdGVtcyA9IGl0ZW1zLm1hcChpdGVtID0+IGl0ZW0uaXNSZWNvcmQgPyB2aWV3LmdldEl0ZW1JZChpdGVtKSA6IE5lby5pc09iamVjdChpdGVtKSA/IGl0ZW0uaWQgOiBpdGVtKTtcblxuICAgICAgICBpZiAoIU5lby5pc0VxdWFsKGl0ZW1Db2xsZWN0aW9uLCBpdGVtcykpIHtcbiAgICAgICAgICAgIGlmIChtZS5zaW5nbGVTZWxlY3QgJiYgaXRlbUNvbGxlY3Rpb24gPT09IG1lLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgbWUuZGVzZWxlY3RBbGwodHJ1ZSwgaXRlbUNvbGxlY3Rpb24pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGl0ZW1zLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHZpZXcuZ2V0VmRvbUNoaWxkKG5vZGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jbHMgPSBOZW9BcnJheS5hZGQobm9kZS5jbHMgfHwgW10sIHNlbGVjdGVkQ2xzIHx8IG1lLnNlbGVjdGVkQ2xzKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZVsnYXJpYS1zZWxlY3RlZCddID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBOZW9BcnJheS5hZGQoaXRlbUNvbGxlY3Rpb24sIGl0ZW1zKTtcblxuICAgICAgICAgICAgaWYgKCF2aWV3LnNpbGVudFNlbGVjdCkge1xuICAgICAgICAgICAgICAgIHZpZXcudXBkYXRlKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmlldy5wYXJlbnQ/Lm9uU2VsZWN0Py4oaXRlbXMpOyAvLyBncmlkLkNvbnRhaW5lciAmIHRhYmxlLkNvbnRhaW5lclxuICAgICAgICAgICAgdmlldy5vblNlbGVjdD8uKGl0ZW1zKTtcblxuICAgICAgICAgICAgdmlldy5maXJlKCdzZWxlY3QnLCB7XG4gICAgICAgICAgICAgICAgcmVjb3JkcyxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb246IGl0ZW1Db2xsZWN0aW9uXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbWUuZmlyZSgnc2VsZWN0aW9uQ2hhbmdlJywge1xuICAgICAgICAgICAgICAgIHJlY29yZHMsXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBpdGVtQ29sbGVjdGlvblxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lLmZpcmUoJ25vQ2hhbmdlJylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG4gICAgICovXG4gICAgdG9nZ2xlU2VsZWN0aW9uKGl0ZW0pIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuaXNTZWxlY3RlZChpdGVtKSkge1xuICAgICAgICAgICAgbWUuZGVzZWxlY3QoaXRlbSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLnNlbGVjdChpdGVtKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtcyA9IChtZS5pdGVtcyB8fCBbXSkubWFwKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIGlmIChOZW8uaXNSZWNvcmQoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0udG9KU09OKClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLnRvSlNPTigpLFxuICAgICAgICAgICAgaXRlbXMsXG4gICAgICAgICAgICBzZWxlY3RlZENscyA6IG1lLnNlbGVjdGVkQ2xzLFxuICAgICAgICAgICAgc2luZ2xlU2VsZWN0OiBtZS5zaW5nbGVTZWxlY3RcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgdW5yZWdpc3RlcigpIHtcbiAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7dmlld30gPSBtZTtcblxuICAgICAgICBpZiAoIXZpZXcuaXNEZXN0cm95aW5nKSB7XG4gICAgICAgICAgICBsZXQgY2xzID0gdmlldy53cmFwcGVyQ2xzIHx8IFtdO1xuXG4gICAgICAgICAgICBpZiAobWUuY2xzICYmIGNscy5pbmNsdWRlcyhtZS5jbHMpKSB7XG4gICAgICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgbWUuY2xzKTtcbiAgICAgICAgICAgICAgICB2aWV3LndyYXBwZXJDbHMgPSBjbHNcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUuZGVzZWxlY3RBbGwoKTtcblxuICAgICAgICAgICAgbWUucmVtb3ZlRG9tTGlzdGVuZXJzKClcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoTW9kZWwpO1xuIiwiaW1wb3J0IE1vZGVsICAgIGZyb20gJy4uL01vZGVsLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgZnJvbSAnLi4vLi4vdXRpbC9BcnJheS5tanMnO1xuXG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIGFsbCBncmlkIHJlbGF0ZWQgc2VsZWN0aW9uIG1vZGVsc1xuICogQGNsYXNzIE5lby5zZWxlY3Rpb24uZ3JpZC5CYXNlTW9kZWxcbiAqIEBleHRlbmRzIE5lby5zZWxlY3Rpb24uTW9kZWxcbiAqIEBhYnN0cmFjdFxuICovXG5jbGFzcyBCYXNlTW9kZWwgZXh0ZW5kcyBNb2RlbCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uc2VsZWN0aW9uLmdyaWQuQmFzZU1vZGVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uc2VsZWN0aW9uLmdyaWQuQmFzZU1vZGVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3JpbmcgdGhlIGNvbHVtbiBkYXRhRmllbGRzXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBzZWxlY3RlZENvbHVtbnM9W11cbiAgICAgICAgICovXG4gICAgICAgIHNlbGVjdGVkQ29sdW1uczogW10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9yaW5nIHRoZSByZWNvcmQgaWRzXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcltdfFN0cmluZ1tdfSBzZWxlY3RlZFJvd3M9W11cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZWN0ZWRSb3dzOiBbXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIHNob3J0Y3V0XG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IGRhdGFGaWVsZHNcbiAgICAgKi9cbiAgICBnZXQgZGF0YUZpZWxkcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5wYXJlbnQuY29sdW1ucy5pdGVtcy5tYXAoY29sdW1uID0+IGNvbHVtbi5kYXRhRmllbGQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgdmlzdWFsIHN0YXRlIChzZWxlY3Rpb24gY2xhc3MpIG9mIHNwZWNpZmljIHJvd3Mgb3IgY2VsbHMgd2l0aG91dCB0cmlnZ2VyaW5nIGEgZnVsbCBCb2R5IHVwZGF0ZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGltcGxlbWVudHMgdGhlICoqR3JhbnVsYXIgVXBkYXRlKiogc3RyYXRlZ3k6XG4gICAgICogMS4gIEl0IGl0ZXJhdGVzIG92ZXIgdGhlIHByb3ZpZGVkIGl0ZW1zIChsb2dpY2FsIGNlbGwgSURzIG9yIHJlY29yZCBJRHMpLlxuICAgICAqIDIuICBJdCByZXNvbHZlcyB0aGUgY29ycmVzcG9uZGluZyBgTmVvLmdyaWQuUm93YCBjb21wb25lbnQuXG4gICAgICogMy4gIEl0IGluc3BlY3RzIHRoZSAqKmN1cnJlbnQgVkRPTSBzdGF0ZSoqIG9mIHRoZSB0YXJnZXQgbm9kZSAocm93IG9yIGNlbGwpLlxuICAgICAqIDQuICBJdCBPTkxZIG11dGF0ZXMgdGhlIFZET00gYW5kIHRyaWdnZXJzIGByb3cudXBkYXRlKClgIGlmIHRoZSBzZWxlY3Rpb24gc3RhdGUgaGFzIGFjdHVhbGx5IGNoYW5nZWQuXG4gICAgICpcbiAgICAgKiBUaGlzIGVuc3VyZXMgTygxKSBwZXJmb3JtYW5jZSBmb3Igc2VsZWN0aW9uIG9wZXJhdGlvbnMsIHJlZ2FyZGxlc3Mgb2YgZ3JpZCBzaXplLCBhbmQgZWxpbWluYXRlcyByZWR1bmRhbnQgVkRPTSB0cmFmZmljLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3RbXXxTdHJpbmdbXX0gaXRlbXMgLSBBcnJheSBvZiBSZWNvcmQgSURzIChmb3IgUm93TW9kZWwpIG9yIExvZ2ljYWwgQ2VsbCBJRHMgKGZvciBDZWxsTW9kZWwpLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbGVudD1mYWxzZV0gLSBJZiB0cnVlLCBtdXRhdGVzIHRoZSBWRE9NIGJ1dCBzdXBwcmVzc2VzIHRoZSBgcm93LnVwZGF0ZSgpYCBjYWxsLlxuICAgICAqL1xuICAgIHVwZGF0ZVJvd3MoaXRlbXMsIHNpbGVudD1mYWxzZSkge1xuICAgICAgICBpZiAoIWl0ZW1zIHx8IGl0ZW1zLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICAgICAgICAgIGl0ZW1zID0gW2l0ZW1zXVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7dmlld30gICAgPSBtZSxcbiAgICAgICAgICAgIHtzdG9yZX0gICA9IHZpZXcsXG4gICAgICAgICAgICBwcm9jZXNzZWQgPSBuZXcgU2V0KCk7XG5cbiAgICAgICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGxldCBoYXNDaGFuZ2VkID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNDZWxsICAgICA9IGl0ZW0udG9TdHJpbmcoKS5pbmNsdWRlcygnX18nKSxcbiAgICAgICAgICAgICAgICByZWNvcmRJZCwgcm93O1xuXG4gICAgICAgICAgICBpZiAoaXNDZWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gaXRlbSBpcyBhIGxvZ2ljYWwgSUQ6IHJlY29yZElkX19kYXRhRmllbGRcbiAgICAgICAgICAgICAgICAvLyBXZSByZXNvbHZlIHRoZSByZWNvcmQgdG8gZmluZCB0aGUgcm93LlxuICAgICAgICAgICAgICAgIGxldCByZWNvcmQgPSB2aWV3LmdldFJlY29yZEZyb21Mb2dpY2FsSWQoaXRlbSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICAgICAgICAgICAgICByb3cgPSB2aWV3LmdldFJvdyhyZWNvcmQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3cgJiYgIXByb2Nlc3NlZC5oYXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NlZC5hZGQoaXRlbSk7IC8vIFByb2Nlc3MgZWFjaCBsb2dpY2FsIGNlbGwgb25seSBvbmNlIHBlciBiYXRjaFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBjZWxsIG5vZGUgaW4gdGhlIHJvdydzIFZET01cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkYXRhRmllbGQgICAgID0gdmlldy5nZXREYXRhRmllbGQoaXRlbSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbE5vZGUgICAgICA9IHJvdy52ZG9tLmNuLmZpbmQobiA9PiBuLmRhdGE/LmZpZWxkID09PSBkYXRhRmllbGQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFNlbGVjdCAgPSBtZS5pc1NlbGVjdGVkKGl0ZW0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscmVhZHlTZWxlY3QgPSBjZWxsTm9kZT8uY2xzPy5pbmNsdWRlcyhtZS5zZWxlY3RlZENscyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZWxsTm9kZSAmJiBzaG91bGRTZWxlY3QgIT09IGFscmVhZHlTZWxlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNdXRhdGUgVkRPTSBkaXJlY3RseTogVG9nZ2xlIHNlbGVjdGlvbiBjbGFzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5lb0FycmF5W3Nob3VsZFNlbGVjdCA/ICdhZGQnIDogJ3JlbW92ZSddKGNlbGxOb2RlLmNscywgbWUuc2VsZWN0ZWRDbHMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZFNlbGVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsTm9kZVsnYXJpYS1zZWxlY3RlZCddID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjZWxsTm9kZVsnYXJpYS1zZWxlY3RlZCddXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzQ2hhbmdlZCA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgbXVzdCB0cmlnZ2VyIHRoZSB1cGRhdGUgb24gdGhlIHJvdyB0byBmbHVzaCB0aGUgVkRPTSBjaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNDaGFuZ2VkICYmICFzaWxlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3cudXBkYXRlKClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaXRlbSBpcyBhIHJlY29yZElkIChSb3dNb2RlbClcbiAgICAgICAgICAgICAgICByZWNvcmRJZCA9IGl0ZW07XG5cbiAgICAgICAgICAgICAgICBpZiAoIXByb2Nlc3NlZC5oYXMocmVjb3JkSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NlZC5hZGQocmVjb3JkSWQpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVjb3JkID0gc3RvcmUuZ2V0KHJlY29yZElkKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3cgPSB2aWV3LmdldFJvdyhyZWNvcmQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlzU2VsZWN0ZWQgICAgPSBtZS5pc1NlbGVjdGVkUm93KHJlY29yZElkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxyZWFkeVNlbGVjdCA9IHJvdy52ZG9tLmNscz8uaW5jbHVkZXMobWUuc2VsZWN0ZWRDbHMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2VsZWN0ZWQgIT09IGFscmVhZHlTZWxlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTXV0YXRlIFZET00gZGlyZWN0bHk6IFRvZ2dsZSBzZWxlY3Rpb24gY2xhc3Mgb24gdGhlIHJvd1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOZW9BcnJheVtpc1NlbGVjdGVkID8gJ2FkZCcgOiAncmVtb3ZlJ10ocm93LnZkb20uY2xzLCBtZS5zZWxlY3RlZENscyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdy52ZG9tWydhcmlhLXNlbGVjdGVkJ10gPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcm93LnZkb21bJ2FyaWEtc2VsZWN0ZWQnXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzQ2hhbmdlZCA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzQ2hhbmdlZCAmJiAhc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdy51cGRhdGUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbGVudF0gdHJ1ZSB0byBwcmV2ZW50IGEgdmRvbSB1cGRhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfFN0cmluZ1tdfSBpdGVtQ29sbGVjdGlvbj10aGlzLml0ZW1zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzZWxlY3RlZENsc11cbiAgICAgKi9cbiAgICBkZXNlbGVjdChpdGVtLCBzaWxlbnQsIGl0ZW1Db2xsZWN0aW9uLCBzZWxlY3RlZENscykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnZpZXcuc2lsZW50U2VsZWN0ID0gdHJ1ZTtcbiAgICAgICAgc3VwZXIuZGVzZWxlY3QoaXRlbSwgc2lsZW50LCBpdGVtQ29sbGVjdGlvbiwgc2VsZWN0ZWRDbHMpO1xuICAgICAgICBtZS52aWV3LnNpbGVudFNlbGVjdCA9IGZhbHNlO1xuXG4gICAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgICBtZS51cGRhdGVSb3dzKGl0ZW0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnRdIHRydWUgdG8gcHJldmVudCBhIHZkb20gdXBkYXRlXG4gICAgICogQHBhcmFtIHtPYmplY3RbXXxTdHJpbmdbXX0gaXRlbUNvbGxlY3Rpb249dGhpcy5pdGVtc1xuICAgICAqL1xuICAgIGRlc2VsZWN0QWxsKHNpbGVudCwgaXRlbUNvbGxlY3Rpb24pIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW1zID0gWy4uLml0ZW1Db2xsZWN0aW9uIHx8IG1lLml0ZW1zXTsgLy8gQ2FwdHVyZSBpdGVtcyBiZWZvcmUgdGhleSBhcmUgcmVtb3ZlZFxuXG4gICAgICAgIG1lLnZpZXcuc2lsZW50U2VsZWN0ID0gdHJ1ZTtcbiAgICAgICAgc3VwZXIuZGVzZWxlY3RBbGwoc2lsZW50LCBpdGVtQ29sbGVjdGlvbik7XG4gICAgICAgIG1lLnZpZXcuc2lsZW50U2VsZWN0ID0gZmFsc2U7XG5cbiAgICAgICAgbWUudXBkYXRlUm93cyhpdGVtcylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdHxPYmplY3RbXXxTdHJpbmdbXX0gaXRlbXNcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfFN0cmluZ1tdfSBpdGVtQ29sbGVjdGlvbj10aGlzLml0ZW1zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzZWxlY3RlZENsc11cbiAgICAgKi9cbiAgICBzZWxlY3QoaXRlbXMsIGl0ZW1Db2xsZWN0aW9uLCBzZWxlY3RlZENscykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnZpZXcuc2lsZW50U2VsZWN0ID0gdHJ1ZTtcbiAgICAgICAgc3VwZXIuc2VsZWN0KGl0ZW1zLCBpdGVtQ29sbGVjdGlvbiwgc2VsZWN0ZWRDbHMpO1xuICAgICAgICBtZS52aWV3LnNpbGVudFNlbGVjdCA9IGZhbHNlO1xuXG4gICAgICAgIG1lLnVwZGF0ZVJvd3MoaXRlbXMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2lsZW50PWZhbHNlXSB0cnVlIHRvIHByZXZlbnQgYSB2ZG9tIHVwZGF0ZVxuICAgICAqL1xuICAgIGRlc2VsZWN0QWxsUm93cyhzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW1zID0gWy4uLm1lLnNlbGVjdGVkUm93c107XG5cbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBtZS5kZXNlbGVjdFJvdyhpdGVtLCB0cnVlKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgbWUudXBkYXRlUm93cyhpdGVtcylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUuZmlyZSgnc2VsZWN0aW9uQ2hhbmdlJywge1xuICAgICAgICAgICAgICAgIHJlY29yZHMgIDogbWUuc2VsZWN0ZWRSb3dzLm1hcChpZCA9PiBtZS52aWV3LnN0b3JlLmdldChpZCkpLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogbWUuc2VsZWN0ZWRSb3dzXG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2UgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgICAgIG1lLmZpcmUoJ25vQ2hhbmdlJylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gcmVjb3JkSWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgIFtzaWxlbnQ9ZmFsc2VdXG4gICAgICovXG4gICAgZGVzZWxlY3RSb3cocmVjb3JkSWQsIHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIE5lb0FycmF5LnJlbW92ZShtZS5zZWxlY3RlZFJvd3MsIHJlY29yZElkKTtcblxuICAgICAgICBtZS51cGRhdGVSb3dzKHJlY29yZElkLCBzaWxlbnQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhdGhcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfFN0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIGdldFJlY29yZChwYXRoKSB7XG4gICAgICAgIGxldCBub2RlLCByb3dJbmRleDtcblxuICAgICAgICBmb3IgKG5vZGUgb2YgcGF0aCkge1xuICAgICAgICAgICAgaWYgKG5vZGUuYXJpYT8ucm93aW5kZXgpIHtcbiAgICAgICAgICAgICAgICByb3dJbmRleCA9IHBhcnNlSW50KG5vZGUuYXJpYS5yb3dpbmRleCk7XG5cbiAgICAgICAgICAgICAgICAvLyBhcmlhLXJvd2luZGV4IGlzIDEgYmFzZWQgJiBhbHNvIGluY2x1ZGVzIHRoZSBoZWFkZXJcbiAgICAgICAgICAgICAgICByb3dJbmRleCAtPSAyO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlldy5zdG9yZS5nZXRBdChyb3dJbmRleClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgYSByZWNvcmQgZnJvbSBhbiBJRCAoUEsgb3IgaW50ZXJuYWxJZCkuXG4gICAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBpZFxuICAgICAqIEByZXR1cm5zIHtOZW8uZGF0YS5SZWNvcmR8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRSb3dSZWNvcmQoaWQpIHtcbiAgICAgICAgaWYgKCFpZCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt2aWV3fSA9IG1lLFxuICAgICAgICAgICAge3N0b3JlfT0gdmlldyxcbiAgICAgICAgICAgIHJlY29yZCA9IHN0b3JlLmdldChpZCk7XG5cbiAgICAgICAgaWYgKHJlY29yZCkgcmV0dXJuIHJlY29yZDtcblxuICAgICAgICAvLyBGYXN0IHBhdGg6IENoZWNrIHZpc2libGUgcm93c1xuICAgICAgICBpZiAodmlldy5pdGVtcykge1xuICAgICAgICAgICAgbGV0IHJvdyA9IHZpZXcuaXRlbXMuZmluZChyID0+IHIucmVjb3JkICYmIHZpZXcuZ2V0UmVjb3JkSWQoci5yZWNvcmQpID09PSBpZCk7XG4gICAgICAgICAgICBpZiAocm93KSByZXR1cm4gcm93LnJlY29yZFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHJlY29yZElkXG4gICAgICogQHJldHVybnMge05lby5ncmlkLlJvd3xudWxsfVxuICAgICAqL1xuICAgIGdldFJvd0NvbXBvbmVudChyZWNvcmRJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3Lml0ZW1zLmZpbmQocm93ID0+IHJvdy5yZWNvcmQgJiYgdGhpcy52aWV3LnN0b3JlLmdldEtleShyb3cucmVjb3JkKSA9PT0gcmVjb3JkSWQpIHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1JlY29yZH0gcmVjb3JkXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzQW5ub3RhdGlvbnMocmVjb3JkKSB7XG4gICAgICAgIHJldHVybiAhIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocmVjb3JkLl9fcHJvdG9fXywgdGhpcy52aWV3LnNlbGVjdGVkUmVjb3JkRmllbGQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGFuIGV2ZW50IHBhdGggY29udGFpbnMgYSBncmlkIGNlbGwgZWRpdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGEucGF0aFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGhhc0VkaXRvckZvY3VzKHtwYXRofSkge1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgcGF0aCkge1xuICAgICAgICAgICAgaWYgKG5vZGUuY2xzPy5pbmNsdWRlcygnbmVvLWdyaWQtZWRpdG9yJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFGaWVsZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGluIGNhc2UgdGhlIGNvbHVtbiBpcyBzZWxlY3RlZFxuICAgICAqL1xuICAgIGlzU2VsZWN0ZWRDb2x1bW4oZGF0YUZpZWxkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkQ29sdW1ucy5pbmNsdWRlcyhkYXRhRmllbGQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSByZWNvcmRJZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGluIGNhc2UgdGhlIHJvdyBpcyBzZWxlY3RlZFxuICAgICAqL1xuICAgIGlzU2VsZWN0ZWRSb3cocmVjb3JkSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRSb3dzLmluY2x1ZGVzKHJlY29yZElkKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gcmVjb3JkSWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgIFtzaWxlbnQ9ZmFsc2VdXG4gICAgICovXG4gICAgc2VsZWN0Um93KHJlY29yZElkLCBzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuc2luZ2xlU2VsZWN0KSB7XG4gICAgICAgICAgICBbLi4ubWUuc2VsZWN0ZWRSb3dzXS5mb3JFYWNoKGlkID0+IG1lLmRlc2VsZWN0Um93KGlkKSlcbiAgICAgICAgfVxuXG4gICAgICAgIE5lb0FycmF5LmFkZChtZS5zZWxlY3RlZFJvd3MsIHJlY29yZElkKTtcblxuICAgICAgICBtZS51cGRhdGVSb3dzKHJlY29yZElkLCBzaWxlbnQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSByZWNvcmRJZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgW3NpbGVudD1mYWxzZV1cbiAgICAgKi9cbiAgICB0b2dnbGVSb3dTZWxlY3Rpb24ocmVjb3JkSWQsIHNpbGVudD1mYWxzZSkge1xuICAgICAgICB0aGlzW3RoaXMuaXNTZWxlY3RlZFJvdyhyZWNvcmRJZCkgPyAnZGVzZWxlY3RSb3cnIDogJ3NlbGVjdFJvdyddKHJlY29yZElkLCBzaWxlbnQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcbiAgICAgICAgICAgIHNlbGVjdGVkQ29sdW1uczogdGhpcy5zZWxlY3RlZENvbHVtbnMsXG4gICAgICAgICAgICBzZWxlY3RlZFJvd3MgICA6IHRoaXMuc2VsZWN0ZWRSb3dzXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHVucmVnaXN0ZXIoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY291bnRSb3dzID0gbWUuc2VsZWN0ZWRSb3dzLmxlbmd0aDtcblxuICAgICAgICBtZS5zZWxlY3RlZFJvd3MgPSBbXTtcblxuICAgICAgICBjb3VudFJvd3MgPiAwICYmIG1lLnZpZXcuY3JlYXRlVmlld0RhdGEoKTtcblxuICAgICAgICBzdXBlci51bnJlZ2lzdGVyKClcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEJhc2VNb2RlbCk7XG4iLCJpbXBvcnQgQmFzZU1vZGVsIGZyb20gJy4vQmFzZU1vZGVsLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5zZWxlY3Rpb24uZ3JpZC5Sb3dNb2RlbFxuICogQGV4dGVuZHMgTmVvLnNlbGVjdGlvbi5ncmlkLkJhc2VNb2RlbFxuICovXG5jbGFzcyBSb3dNb2RlbCBleHRlbmRzIEJhc2VNb2RlbCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uc2VsZWN0aW9uLmdyaWQuUm93TW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5zZWxlY3Rpb24uZ3JpZC5Sb3dNb2RlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdzZWxlY3Rpb24tZ3JpZC1yb3dtb2RlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdzZWxlY3Rpb24tZ3JpZC1yb3dtb2RlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNscz0nbmVvLXNlbGVjdGlvbi1yb3dtb2RlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xzOiAnbmVvLXNlbGVjdGlvbi1yb3dtb2RlbCdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGFkZERvbUxpc3RlbmVyKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnZpZXcucGFyZW50Lm9uKCdyb3dDbGljaycsIG1lLm9uUm93Q2xpY2ssIG1lKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICovXG4gICAgZGVzdHJveSguLi5hcmdzKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUudmlldy5wYXJlbnQudW4oJ3Jvd0NsaWNrJywgbWUub25Sb3dDbGljaywgbWUpO1xuXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koLi4uYXJncylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uS2V5RG93bkRvd24oZGF0YSkge1xuICAgICAgICAhdGhpcy5oYXNFZGl0b3JGb2N1cyhkYXRhKSAmJiB0aGlzLm9uTmF2S2V5Um93KDEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbktleURvd25VcChkYXRhKSB7XG4gICAgICAgICF0aGlzLmhhc0VkaXRvckZvY3VzKGRhdGEpICYmIHRoaXMub25OYXZLZXlSb3coLTEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0ZXBcbiAgICAgKi9cbiAgICBvbk5hdktleVJvdyhzdGVwKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3ZpZXd9ICAgICAgID0gbWUsXG4gICAgICAgICAgICB7c3RvcmV9ICAgICAgPSB2aWV3LFxuICAgICAgICAgICAgY291bnRSZWNvcmRzID0gc3RvcmUuZ2V0Q291bnQoKSxcbiAgICAgICAgICAgIHJlY29yZElkICAgICA9IG1lLnNlbGVjdGVkUm93c1swXSB8fCB2aWV3LmdldFJlY29yZElkKHN0b3JlLmdldEF0KDApKSxcbiAgICAgICAgICAgIHJlY29yZCAgICAgICA9IG1lLmdldFJvd1JlY29yZChyZWNvcmRJZCksXG4gICAgICAgICAgICBpbmRleCAgICAgICAgPSBzdG9yZS5pbmRleE9mKHJlY29yZCksXG4gICAgICAgICAgICBuZXdJbmRleCAgICAgPSAoaW5kZXggKyBzdGVwKSAlIGNvdW50UmVjb3JkcztcblxuICAgICAgICB3aGlsZSAobmV3SW5kZXggPCAwKSB7XG4gICAgICAgICAgICBuZXdJbmRleCArPSBjb3VudFJlY29yZHNcbiAgICAgICAgfVxuXG4gICAgICAgIHJlY29yZCA9IHN0b3JlLmdldEF0KG5ld0luZGV4KTtcblxuICAgICAgICBpZiAobWUuaGFzQW5ub3RhdGlvbnMocmVjb3JkKSkge1xuICAgICAgICAgICAgbWUudXBkYXRlQW5ub3RhdGlvbnMocmVjb3JkKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVjb3JkSWQgPSB2aWV3LmdldFJlY29yZElkKHJlY29yZCk7XG5cbiAgICAgICAgICAgIGlmIChyZWNvcmRJZCkge1xuICAgICAgICAgICAgICAgIG1lLnNlbGVjdFJvdyhyZWNvcmRJZCk7XG5cbiAgICAgICAgICAgICAgICB2aWV3LnNjcm9sbEJ5Um93cyhpbmRleCwgc3RlcCk7XG4gICAgICAgICAgICAgICAgdmlldy5maXJlKCdzZWxlY3QnLCB7cmVjb3JkfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Sb3dDbGljayh7ZGF0YX0pIHtcbiAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7dmlld30gPSBtZSxcbiAgICAgICAgICAgIHJlY29yZCA9IG1lLmdldFJlY29yZChkYXRhLnBhdGgpLFxuICAgICAgICAgICAgcmVjb3JkSWQ7XG5cbiAgICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICAgICAgaWYgKG1lLmhhc0Fubm90YXRpb25zKHJlY29yZCkpIHtcbiAgICAgICAgICAgICAgICBtZS51cGRhdGVBbm5vdGF0aW9ucyhyZWNvcmQpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlY29yZElkID0gdmlldy5nZXRSZWNvcmRJZChyZWNvcmQpO1xuXG4gICAgICAgICAgICAgICAgbWUudG9nZ2xlUm93U2VsZWN0aW9uKHJlY29yZElkKTtcblxuICAgICAgICAgICAgICAgIHZpZXcuZmlyZShtZS5pc1NlbGVjdGVkUm93KHJlY29yZElkKSA/ICdzZWxlY3QnIDogJ2Rlc2VsZWN0Jywge3JlY29yZH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50XG4gICAgICovXG4gICAgcmVnaXN0ZXIoY29tcG9uZW50KSB7XG4gICAgICAgIHN1cGVyLnJlZ2lzdGVyKGNvbXBvbmVudCk7XG5cbiAgICAgICAgbGV0IHtpZCwgdmlld30gPSB0aGlzO1xuXG4gICAgICAgIHZpZXcua2V5cz8uX2tleXMucHVzaChcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93bkRvd24nLCBrZXk6ICdEb3duJywgc2NvcGU6IGlkfSxcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93blVwJywgICBrZXk6ICdVcCcsICAgc2NvcGU6IGlkfVxuICAgICAgICApXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICB1bnJlZ2lzdGVyKCkge1xuICAgICAgICBsZXQge2lkLCB2aWV3fSA9IHRoaXM7XG5cbiAgICAgICAgdmlldy5rZXlzPy5yZW1vdmVLZXlzKFtcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93bkRvd24nLCBrZXk6ICdEb3duJywgc2NvcGU6IGlkfSxcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93blVwJywgICBrZXk6ICdVcCcsICAgc2NvcGU6IGlkfVxuICAgICAgICBdKTtcblxuICAgICAgICBzdXBlci51bnJlZ2lzdGVyKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1JlY29yZH0gcmVjb3JkXG4gICAgICovXG4gICAgdXBkYXRlQW5ub3RhdGlvbnMocmVjb3JkKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt2aWV3fSAgICAgICAgICAgPSBtZSxcbiAgICAgICAgICAgIHtzdG9yZX0gICAgICAgICAgPSB2aWV3LFxuICAgICAgICAgICAgcmVjb3JkSWQgICAgICAgICA9IHZpZXcuZ2V0UmVjb3JkSWQocmVjb3JkKSxcbiAgICAgICAgICAgIGlzU2VsZWN0ZWQgICAgICAgPSBtZS5pc1NlbGVjdGVkUm93KHJlY29yZElkKSxcbiAgICAgICAgICAgIGFubm90YXRpb25zRmllbGQgPSB2aWV3LnNlbGVjdGVkUmVjb3JkRmllbGQ7XG5cbiAgICAgICAgaWYgKG1lLnNpbmdsZVNlbGVjdCkge1xuICAgICAgICAgICAgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICByZWNvcmRbYW5ub3RhdGlvbnNGaWVsZF0gPSBmYWxzZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZS5zZWxlY3RlZFJvd3MuZm9yRWFjaChyZWNvcmRJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGNhbiB1c2Ugc2V0U2lsZW50KCksIHNpbmNlIHRoZSBsYXN0IGNoYW5nZSB3aWxsIHRyaWdnZXIgYSB2aWV3IHVwZGF0ZVxuICAgICAgICAgICAgICAgICAgICBzdG9yZS5nZXQocmVjb3JkSWQpLnNldFNpbGVudCh7W2Fubm90YXRpb25zRmllbGRdOiBmYWxzZX0pXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZWNvcmRbYW5ub3RhdGlvbnNGaWVsZF0gPSB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWNvcmRbYW5ub3RhdGlvbnNGaWVsZF0gPSAhcmVjb3JkW2Fubm90YXRpb25zRmllbGRdXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFJvd01vZGVsKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==