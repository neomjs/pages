export const __webpack_esm_id__ = "vendors-src_tab_Container_mjs";
export const __webpack_esm_ids__ = ["vendors-src_tab_Container_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./src/tab/BodyContainer.mjs"
/*!***********************************!*\
  !*** ./src/tab/BodyContainer.mjs ***!
  \***********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");


/**
 * @class Neo.tab.BodyContainer
 * @extends Neo.container.Base
 */
class BodyContainer extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.tab.BodyContainer'
         * @protected
         */
        className: 'Neo.tab.BodyContainer',
        /**
         * @member {String[]} baseCls=['neo-tab-body-container','neo-container']
         * @protected
         */
        baseCls: ['neo-tab-body-container', 'neo-container']
    }

    /**
     * When adding an existing tab into a different container, it will get automatically from the closest parent.
     * In this case, we also want to remove the tab.header.Button from the tab.header.Toolbar.
     * Use case: SharedCovid.view.MainContainerController
     * @param {Neo.component.Base} component
     * @param {Boolean} [destroyItem=true]
     * @param {Boolean} [silent=false]
     * @returns {Neo.component.Base|null}
     */
    remove(component, destroyItem, silent) {
        if (component?.isTab) {
            this.parent.remove(component, destroyItem, silent)
        } else {
            super.remove(component, destroyItem, silent)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(BodyContainer));


/***/ },

/***/ "./src/tab/Container.mjs"
/*!*******************************!*\
  !*** ./src/tab/Container.mjs ***!
  \*******************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _BodyContainer_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BodyContainer.mjs */ "./src/tab/BodyContainer.mjs");
/* harmony import */ var _header_Button_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./header/Button.mjs */ "./src/tab/header/Button.mjs");
/* harmony import */ var _header_Toolbar_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./header/Toolbar.mjs */ "./src/tab/header/Toolbar.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _Strip_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Strip.mjs */ "./src/tab/Strip.mjs");







/**
 * @summary Manages a tabbed interface with a header toolbar and a content body.
 *
 * This class acts as the main orchestrator for a tabbed view. It uses a flexbox layout to arrange its
 * two primary children: a `Neo.tab.header.Toolbar` for the tab buttons and a `Neo.tab.BodyContainer`.
 * The `BodyContainer` is configured with a `card` layout. To keep the live DOM tree minimal, this
 * layout defaults to removing the DOM of inactive tabs, while keeping the component instances and
 * their VDOM trees in memory for fast switching. This behavior can be changed via the `removeInactiveCards` config.
 *
 * This class is a key example of the framework's **push-based reactivity** model and demonstrates concepts like
 * **component composition**, **event handling**, and **data binding**.
 *
 * @see Neo.examples.tab.Container
 * @class Neo.tab.Container
 * @extends Neo.container.Base
 */
class Container extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for tabBarPosition
     * @member {String[]} tabBarPositions=['top','right','bottom','left']
     * @protected
     * @static
     */
    static tabBarPositions = ['top', 'right', 'bottom', 'left']

    static config = {
        /**
         * @member {String} className='Neo.tab.Container'
         * @protected
         */
        className: 'Neo.tab.Container',
        /**
         * @member {String} ntype='tab-container'
         * @protected
         */
        ntype: 'tab-container',
        /**
         * You can use null to not mount any items initially
         * @member {Number|null} activeIndex_=0
         * @reactive
         */
        activeIndex_: 0,
        /**
         * True will activate a tab which gets dynamically inserted / added after the TabContainer is mounted
         * @member {Boolean} activateInsertedTabs=false
         */
        activateInsertedTabs: false,
        /**
         * @member {String[]} baseCls=['neo-tab-container'],
         * @protected
         */
        baseCls: ['neo-tab-container'],
        /**
         * Default configs for the tab.BodyContainer
         * @member {Object|null} bodyContainer=null
         */
        bodyContainer: null,
        /**
         * @member {String|null} bodyContainerId=null
         */
        bodyContainerId: null,
        /**
         * true enables sorting tabs via drag&drop.
         * The config gets passed to the header toolbar
         * @member {Boolean} dragResortable=false
         * @reactive
         */
        dragResortable: false,
        /**
         * Default configs for the tab.HeaderToolbar
         * @member {Object|null} headerToolbar=null
         */
        headerToolbar: null,
        /**
         * @member {Object|null} layout=null
         * @reactive
         */
        layout: null,
        /**
         * True to not apply a background effect to the tab header container
         * @member {Boolean} plain_=true
         * @reactive
         */
        plain_: true,
        /**
         * Remove the DOM of inactive cards (TabContainer Body).
         * This will keep the instances & vdom trees
         * @member {Boolean} removeInactiveCards=true
         */
        removeInactiveCards: true,
        /**
         * @member {String|null} tabBarId=null
         */
        tabBarId: null,
        /**
         * Default configs for the tab.Strip
         * @member {Object|null} tabStrip=null
         */
        tabStrip: null,
        /**
         * @member {String|null} tabStripId=null
         */
        tabStripId: null,
        /**
         * The position of the tab header toolbar.
         * Valid values are top, right, bottom, left.
         * @member {String} tabBarPosition_='top'
         * @reactive
         */
        tabBarPosition_: 'top',
        /**
         * adds tabContainerCls + '-plain' is case plain is set to true
         * @member {String} tabContainerCls='neo-tab-container'
         */
        tabContainerCls: 'neo-tab-container',
        /**
         * @member {Boolean} useActiveTabIndicator_=true
         * @reactive
         */
        useActiveTabIndicator_: true
    }

    /**
     * Adds one or more tab items to the end of the container.
     * @param {Object|Object[]} item The configuration object for a new tab or an array of such objects.
     * @returns {Neo.component.Base|Neo.component.Base[]} The newly created component(s).
     */
    add(item) {
        return this.insert(this.getTabBar().items.length, item)
    }

    /**
     * Handles the logic after the `activeIndex` config has changed. It ensures that the
     * layout of the `BodyContainer` is updated to show the correct card and fires the
     * `activeIndexChange` event.
     * @param {Number|null} value The new active index.
     * @param {Number|null} oldValue The previous active index.
     * @protected
     */
     async afterSetActiveIndex(value, oldValue) {
        let me            = this,
            cardContainer = Neo.getComponent(me.bodyContainerId);

        if (Neo.isNumber(value) && value > -1 && !cardContainer) {
            me.on('constructed', () => {
                me.afterSetActiveIndex(value, oldValue)
            }, me, {once: true})
        } else {
            if (Neo.isNumber(value) && value > -1) {
                // we need to ensure the afterSet method triggers when lazy loading the module
                cardContainer.layout._activeIndex = value;
                await cardContainer.layout.afterSetActiveIndex(value, oldValue);

                if (oldValue !== undefined) {
                    me.updateTabButtons();

                    me.fire('activeIndexChange', {
                        item: me.getActiveCard(),
                        oldValue,
                        value
                    })
                }
            }
        }
    }

    /**
     * Applies or removes the plain CSS class when the `plain` config changes.
     * @param {Boolean} value The new value for `plain`.
     * @param {Boolean} oldValue The old value for `plain`.
     * @protected
     */
    afterSetPlain(value, oldValue) {
        let me    = this,
            {cls} = me;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"][value ? 'unshift' : 'remove'](cls, me.tabContainerCls + '-plain');
        me.cls = cls
    }

    /**
     * Passes the `dragResortable` config down to the `HeaderToolbar` instance.
     * @param {Boolean} value The new value for `dragResortable`.
     * @param {Boolean} oldValue The old value for `dragResortable`.
     * @protected
     */
    afterSetDragResortable(value, oldValue) {
        if (oldValue !== undefined) {
            this.getTabBar().dragResortable = value
        }
    }

    /**
     * Adjusts the container's layout and CSS classes when the tab bar position changes.
     * This method ensures that the `HeaderToolbar` is docked correctly and that the overall
     * flexbox layout direction is updated to accommodate the new position (e.g., row for left/right,
     * column for top/bottom).
     * @param {String} value The new tab bar position ('top', 'right', 'bottom', 'left').
     * @param {String} oldValue The old tab bar position.
     * @protected
     */
    afterSetTabBarPosition(value, oldValue) {
        let me    = this,
            {cls} = me;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].remove(cls, 'neo-' + oldValue);
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].add(cls, 'neo-' + value);
        me.setSilent({cls});

        if (me.vnodeInitialized) {
            me.layout.setSilent(me.getLayoutConfig());
            me.getTabBar().setSilent({dock: value});
            me.getTabStrip().setSilent({cls: ['neo-tab-strip',  'neo-dock-' + value]});

            me.updateDepth = 2;

            me.fire('tabBarPositionChange', {
                component: me,
                oldValue,
                value
            })
        }

        me.update()
    }

    /**
     * Passes the `useActiveTabIndicator` config down to the `HeaderToolbar` and `Strip` instances.
     * @param {Boolean} value The new value for `useActiveTabIndicator`.
     * @param {Boolean} oldValue The old value for `useActiveTabIndicator`.
     * @protected
     */
    afterSetUseActiveTabIndicator(value, oldValue) {
        if (oldValue !== undefined) {
            this.getTabBar()  .useActiveTabIndicator = value;
            this.getTabStrip().useActiveTabIndicator = value
        }
    }

    /**
     * Validates the new value for the `tabBarPosition` config.
     * @param {String} value The new value.
     * @param {String} oldValue The old value.
     * @protected
     * @returns {String} The validated value.
     */
    beforeSetTabBarPosition(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'tabBarPosition')
    }

    /**
     * Overrides the base `createItems` lifecycle method to construct the specific component
     * hierarchy required for a tab container. It transforms the user-provided `items` array
     * into the three core child components: `HeaderToolbar`, `Strip`, and `BodyContainer`.
     * @protected
     */
    createItems() {
        let me            = this,
            {activeIndex, removeInactiveCards, useActiveTabIndicator} = me,
            items         = me.items || [],
            tabButtons    = [],
            tabComponents = [];

        Object.assign(me, {
            bodyContainerId: me.bodyContainerId || Neo.getId('container'),
            tabBarId       : me.tabBarId        || Neo.getId('tab-header-toolbar'),
            tabStripId     : me.tabStripId      || Neo.getId('tab-strip')
        });

        items.forEach((item, index) => {
            tabButtons.push(me.getTabButtonConfig(item.header, index));

            if (!(item instanceof Neo.component.Base)) {
                item = {flex: 1, ...me.itemDefaults, isTab: true, ...item}
            }

            tabComponents.push(item)
        });

        me.items = [{
            module        : _header_Toolbar_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
            dock          : me.tabBarPosition,
            dragResortable: me.dragResortable,
            flex          : 'none',
            id            : me.tabBarId,
            items         : tabButtons,
            useActiveTabIndicator,
            ...me.headerToolbar
        }, {
            module        : _Strip_mjs__WEBPACK_IMPORTED_MODULE_5__["default"],
            cls           : ['neo-dock-' + me.tabBarPosition],
            flex          : 'none',
            id            : me.tabStripId,
            tabContainerId: me.id,
            useActiveTabIndicator,
            ...me.tabStrip
        }, {
            module      : _BodyContainer_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            id          : me.bodyContainerId,
            itemDefaults: me.itemDefaults,
            items       : tabComponents,
            layout      : {ntype: 'card', activeIndex, removeInactiveCards},
            useActiveTabIndicator,
            ...me.bodyContainer
        }];

        me.itemDefaults = null;

        super.createItems()
    }

    /**
     * Retrieves the component instance for the currently active tab.
     * @returns {Neo.component.Base|null} The active card component or null if none is active.
     */
    getActiveCard() {
        return this.getCardContainer()?.items[this.activeIndex] || null
    }

    /**
     * Retrieves the component instance for a tab at a specific index.
     * @param {Number} index The index of the card to retrieve.
     * @returns {Neo.component.Base|null} The card component or null if not found.
     */
    getCard(index) {
        return this.getCardContainer()?.items[index] || null
    }

    /**
     * A convenience method to get the `BodyContainer` instance that holds the tab content cards.
     * @returns {Neo.container.Base} The body container instance.
     */
    getCardContainer() {
        return Neo.getComponent(this.bodyContainerId)
    }

    /**
     * Returns the total number of tabs in the container.
     * @returns {Number} The number of tabs.
     */
    getCount() {
        return this.getTabBar().items.length
    }

    /**
     * Generates the appropriate flexbox layout configuration based on the current `tabBarPosition`.
     * For example, a 'top' or 'bottom' position requires a vertical layout, while 'left' or 'right'
     * requires a horizontal one.
     * @returns {Object} The flexbox layout configuration object.
     * @protected
     */
    getLayoutConfig() {
        let layoutMap = {
            bottom: {
                align    : 'stretch',
                direction: 'column-reverse',
                pack     : 'start'
            },
            left: {
                align    : 'stretch',
                direction: 'row',
                pack     : 'start'
            },
            right: {
                align    : 'stretch',
                direction: 'row-reverse',
                pack     : 'start'
            },
            top: {
                align    : 'stretch',
                direction: 'column',
                pack     : 'start'
            }
        };

        return layoutMap[this.tabBarPosition] || null
    }

    /**
     * Retrieves the `HeaderButton` instance for a tab at a specific index.
     * @param {Number} index The index of the tab button to retrieve.
     * @returns {Neo.tab.header.Button|null} The tab button component or null if not found.
     */
    getTabAtIndex(index) {
        return this.getTabBar().items[index] || null
    }

    /**
     * A convenience method to get the `HeaderToolbar` instance that holds the tab buttons.
     * @returns {Neo.toolbar.Base} The header toolbar instance.
     */
    getTabBar() {
        return Neo.getComponent(this.tabBarId)
    }

    /**
     * Creates the configuration object for a single tab button. It merges a default configuration
     * (including the module, index, and a click listener to change `activeIndex`) with the
     * user-provided configuration from the item's `header` property.
     * @param {Object} config The user-provided configuration from `item.header`.
     * @param {Number} index The index of this tab button.
     * @returns {Object} The merged configuration object for the tab button.
     * @protected
     */
    getTabButtonConfig(config, index) {
        let me = this,

        defaultConfig = {
            module : _header_Button_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            flex   : 'none',
            index  : index,
            pressed: me.activeIndex === index,

            domListeners: [{
                click(data) {
                    me.activeIndex = data.component.index
                },
                scope: me
            }]
        };

        return {...defaultConfig, ...config}
    }

    /**
     * A convenience method to get the `Strip` instance, which is responsible for rendering
     * the active tab indicator.
     * @returns {Neo.tab.Strip} The strip instance.
     */
    getTabStrip() {
        return Neo.getComponent(this.tabStripId)
    }

    /**
     * Inserts one or more tab items at a specific index.
     * @param {Number} index The index at which to insert the new item(s).
     * @param {Object|Object[]} item The configuration object for a new tab or an array of such objects.
     * @param {Boolean} [silent=false] Set to true to prevent `updateTabButtons` from being called.
     * @returns {Neo.component.Base|Neo.component.Base[]} The newly created component(s).
     */
    insert(index, item, silent=false) {
        let me            = this,
            cardContainer = me.getCardContainer(),
            tabBar        = me.getTabBar(),
            hasItem       = false,
            i, len, returnArray, superItem, tab;

        if (Array.isArray(item)) {
            i           = 0;
            len         = item.length;
            returnArray = [];

            for (; i < len; i++) {
                // insert the array backwards
                returnArray.unshift(me.insert(index, item[len - 1 - i], true))
            }

            superItem = returnArray;
        } else if (typeof item === 'object') {
            i   = 0;
            len = cardContainer.items.length;

            for (; i < len; i++) {
                if (cardContainer.items[i].id === item.id) {
                    hasItem   = true;
                    superItem = cardContainer.items[i];

                    if (me.activateInsertedTabs) {
                        me.activeIndex = i
                    }

                    break
                }
            }

            if (!hasItem) {
                tab = tabBar.insert(index, me.getTabButtonConfig(item.header, index));

                // todo: non index based matching of tab buttons and cards
                i = 0;
                len = tabBar.items.length;

                for (; i < len; i++) {
                    tabBar.items[i].index = i
                }

                item.flex = 1;
                superItem = cardContainer.insert(index, item, silent);

                if (me.activateInsertedTabs) {
                    if (!me.vnode) {
                        me.activeIndex = index
                    } else {
                        tab.on('mounted', me.onTabButtonMounted, me)
                    }
                }
            }
        }

        !silent && me.updateTabButtons();

        return superItem
    }

    /**
     * Moves an existing tab (both its button and its card) from one index to another.
     * This is primarily used for drag-and-drop reordering.
     * @param {Number} fromIndex The original index of the tab.
     * @param {Number} toIndex The new index for the tab.
     * @returns {Neo.component.Base} The card component that was moved.
     */
    moveTo(fromIndex, toIndex) {
        let me            = this,
            cardContainer = me.getCardContainer(),
            tabBar        = me.getTabBar(),
            activeTab     = tabBar.items[me.activeIndex],
            index, returnValue;

        tabBar.moveTo(fromIndex, toIndex);
        index = activeTab.index;

        if (index !== me.activeIndex) {
            // silent updates
            me._activeIndex = index;
            cardContainer.layout._activeIndex = index
        }

        returnValue = cardContainer.moveTo(fromIndex, toIndex);

        me.fire('moveTo', {
            fromIndex,
            toIndex
        });

        return returnValue
    }

    /**
     * Overrides the base `onConstructed` lifecycle method to apply the initial flexbox layout
     * configuration after the main construction process is complete.
     * @protected
     */
    onConstructed() {
        this.layout = {ntype: 'flexbox', ...this.getLayoutConfig()};
        super.onConstructed()
    }

    /**
     * A handler that is triggered when a dynamically added tab button is mounted to the DOM.
     * If `activateInsertedTabs` is true, this method ensures that the `activeIndex` is set
     * correctly after the new tab's corresponding card is also mounted.
     * @param {String} buttonId The ID of the mounted button.
     * @protected
     */
    onTabButtonMounted(buttonId) {
        let me            = this,
            cardContainer = me.getCardContainer(),
            tabBar        = me.getTabBar(),
            i             = 0,
            len           = tabBar.items.length,
            index         = -1,
            card;

        for (; i < len; i++) {
            if (tabBar.items[i].id === buttonId) {
                index = i;
                break
            }
        }

        if (index > -1) {
            card = cardContainer.items[index];

            if (me.vnode && !card.mounted) {
                card.on('mounted', () => {
                    me.activeIndex = index
                }, me, {once: true})
            } else {
                me.activeIndex = index
            }
        }
    }

    /**
     * Removes a tab from the container using a reference to the card component.
     * @param {Neo.component.Base} component The card component instance to remove.
     * @param {Boolean} [destroyItem=true] Set to false to keep the component instance in memory.
     * @param {Boolean} [silent=false] Set to true to prevent `updateTabButtons` from being called.
     */
    remove(component, destroyItem=true, silent=false) {
        let items = [...this.getCardContainer().items],
            i     = 0,
            len   = items.length;

        for (; i < len; i++) {
            if (items[i].id === component.id) {
                this.removeAt(i, destroyItem, silent)
            }
        }
    }

    /**
     * Removes a tab from the container at a specific index.
     * @param {Number} index The index of the tab to remove.
     * @param {Boolean} [destroyItem=true] Set to false to keep the component instance in memory.
     * @param {Boolean} [silent=false] Set to true to prevent `updateTabButtons` from being called.
     */
    removeAt(index, destroyItem=true, silent=false) {
        let me            = this,
            {activeIndex} = me,
            cardContainer = me.getCardContainer(),
            tabBar        = me.getTabBar(),
            i, len;

        cardContainer.removeAt(index, destroyItem, silent);
        tabBar       .removeAt(index, true,        false);

        if (index < activeIndex) {
            // silent updates
            me._activeIndex = activeIndex - 1;
            cardContainer.layout._activeIndex = activeIndex - 1
        } else if (index === activeIndex) {
            me.activeIndex = activeIndex - 1
        }

        // todo: non index based matching of tab buttons and cards
        i   = 0;
        len = tabBar.items.length;

        for (; i < len; i++) {
            tabBar.items[i].index = i
        }
    }

    /**
     * Synchronizes the `pressed` state of all tab buttons with the container's `activeIndex`.
     * This ensures that only the button corresponding to the active tab appears pressed.
     * @protected
     */
    updateTabButtons() {
        let me            = this,
            {activeIndex} = me,
            tabButtons    = me.getTabBar()?.items || [];

        tabButtons.forEach((item, index) => {
            item.pressed = index === activeIndex
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Container));


/***/ },

/***/ "./src/tab/Strip.mjs"
/*!***************************!*\
  !*** ./src/tab/Strip.mjs ***!
  \***************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");


/**
 * @class Neo.tab.Strip
 * @extends Neo.component.Base
 */
class Strip extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.tab.Strip'
         * @protected
         */
        className: 'Neo.tab.Strip',
        /**
         * @member {String} ntype='tab-strip'
         * @protected
         */
        ntype: 'tab-strip',
        /**
         * @member {String[]} baseCls=['neo-tab-strip']
         */
        baseCls: ['neo-tab-strip'],
        /**
         * @member {String|null} tabContainerId=null
         */
        tabContainerId: null,
        /**
         * @member {Boolean} useActiveTabIndicator_=true
         * @reactive
         */
        useActiveTabIndicator_: true,
        /**
         * @member {Object} _vdom={cn: [{cls: 'neo-active-tab-indicator'}]}
         */
        _vdom:
        {cn: [
            {cls: ['neo-active-tab-indicator']}
        ]}
    }

    /**
     * Triggered after the useActiveTabIndicator config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetUseActiveTabIndicator(value, oldValue) {
        this.vdom.cn[0].removeDom = !value;
        this.update()
    }

    /**
     * Gets the DomRect of the active tab, then moves the indicator
     * @param {Object|null} opts
     * @param {Number} opts.oldValue
     * @param {Number} opts.value
     */
    getActiveTabRectThenMove(opts) {
        let me           = this,
            ids          = [me.id],
            tabContainer = me.getTabContainer(),
            oldTab;

        // We do not need a movement, in case there is no oldValue
        if (me.useActiveTabIndicator && me.vnode && Neo.isNumber(opts?.oldValue)) {
            oldTab = tabContainer.getTabAtIndex(opts.oldValue);

            // The activeIndexChange event can get triggered when removing the currently active tab,
            // In this case, we can no longer access the related DOMRect and need to opt out.
            if (oldTab) {
                ids.push(tabContainer.getTabAtIndex(opts.value).id, oldTab.id);

                me.getDomRect(ids).then(data => {
                    me.moveActiveIndicator(data)
                })
            }
        }
    }

    /**
     *
     */
    getTabContainer() {
        return Neo.getComponent(this.tabContainerId)
    }

    /**
     * Can either contain the new target rect or the new and old one
     * @param {Object[]} rects
     * @param {Number} rects[0].bottom
     * @param {Number} rects[0].height
     * @param {Number} rects[0].left
     * @param {Number} rects[0].right
     * @param {Number} rects[0].top
     * @param {Number} rects[0].width
     * @param {Number} rects[0].x
     * @param {Number} rects[0].y
     */
    moveActiveIndicator(rects) {
        let me           = this,
            tabStripRect = rects.shift(),
            rect         = rects[1] || rects[0],
            activeTabIndicator, tabContainer;

        if (me.useActiveTabIndicator) {
            activeTabIndicator = me.vdom.cn[0];
            tabContainer       = me.getTabContainer();

            switch (tabContainer.tabBarPosition) {
                case 'bottom':
                case 'top':
                    activeTabIndicator.style = {
                        height: null,
                        left  : `${rect.left - tabStripRect.left}px`,
                        top   : null,
                        width : `${rect.width}px`
                    };
                    break
                case 'left':
                case 'right':
                    activeTabIndicator.style = {
                        height: `${rect.height}px`,
                        left  : null,
                        top   : `${rect.top - tabStripRect.top}px`,
                        width : null
                    };
                    break
            }

            // in case there is a dynamic change (oldValue), call this method again
            if (rects[1]) {
                activeTabIndicator.style.opacity = 0;
                me.update();

                me.timeout(50).then(() => {
                    me.moveActiveIndicator([tabStripRect, rects[0]])
                })
            } else {
                activeTabIndicator.style.opacity = 1;
                me.update();

                me.timeout(300).then(() => {
                    activeTabIndicator.style.opacity = 0;
                    me.update()
                })
            }
        }
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me = this;

        me.getTabContainer().on({
            activeIndexChange: me.getActiveTabRectThenMove,
            scope            : me
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Strip));


/***/ },

/***/ "./src/tab/header/Button.mjs"
/*!***********************************!*\
  !*** ./src/tab/header/Button.mjs ***!
  \***********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../button/Base.mjs */ "./src/button/Base.mjs");


/**
 * @class Neo.tab.header.Button
 * @extends Neo.button.Base
 */
class Button extends _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.tab.header.Button'
         * @protected
         */
        className: 'Neo.tab.header.Button',
        /**
         * @member {String} ntype='tab-header-button'
         * @protected
         */
        ntype: 'tab-header-button',
        /**
         * @member {String[]} baseCls=['neo-button','neo-tab-button']
         */
        baseCls: ['neo-tab-header-button', 'neo-button'],
        /**
         * Specify a role tag attribute for the vdom root.
         * @member {String|null} role='tab'
         * @reactive
         */
        role: 'tab',
        /**
         * @member {Boolean} useActiveTabIndicator_=true
         * @reactive
         */
        useActiveTabIndicator_: true,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {tag: 'button', cn: [
            {tag: 'span', cls: ['neo-button-glyph']},
            {tag: 'span', cls: ['neo-button-text']},
            {cls: ['neo-button-badge']},
            {cls: ['neo-button-ripple-wrapper'], cn: [
                    {cls: ['neo-button-ripple']}
                ]},
            {cls: ['neo-tab-button-indicator']}
        ]}
    }

    /**
     * Triggered after the pressed config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetPressed(value, oldValue) {
        super.afterSetPressed(value, oldValue);

        let me = this;

        if (value) {
            me.vdom['aria-selected'] = true
        } else {
            delete me.vdom['aria-selected']
        }

        me.update()
    }

    /**
     * Triggered after the useActiveTabIndicator config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetUseActiveTabIndicator(value, oldValue) {
        this.updateUseActiveTabIndicator()
    }

    /**
     * @param {Object} data
     */
    showRipple(data) {
        !this.pressed && super.showRipple(data)
    }

    /**
     * @param {Boolean} silent=false
     */
    updateUseActiveTabIndicator(silent=false) {
        let me = this;

        me.vdom.cn[4].removeDom = !me.useActiveTabIndicator;
        !silent && me.update()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Button));


/***/ },

/***/ "./src/tab/header/Toolbar.mjs"
/*!************************************!*\
  !*** ./src/tab/header/Toolbar.mjs ***!
  \************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../toolbar/Base.mjs */ "./src/toolbar/Base.mjs");


/**
 * @class Neo.tab.header.Toolbar
 * @extends Neo.toolbar.Base
 */
class Toolbar extends _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.tab.header.Toolbar'
         * @protected
         */
        className: 'Neo.tab.header.Toolbar',
        /**
         * @member {String} ntype='tab-header-toolbar'
         * @protected
         */
        ntype: 'tab-header-toolbar',
        /**
         * @member {String[]} baseCls=['neo-tab-header-toolbar','neo-toolbar']
         */
        baseCls: ['neo-tab-header-toolbar', 'neo-toolbar'],
        /**
         * @member {Boolean} useActiveTabIndicator_=true
         * @reactive
         */
        useActiveTabIndicator_: true
    }

    /**
     * @returns {Promise<any>}
     */
    loadSortZoneModule() {
        return Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("vendors-src_draggable_container_SortZone_mjs"), __webpack_require__.e("src_draggable_DragProxyContainer_mjs-src_draggable_tab_header_toolbar_SortZone_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ../../draggable/tab/header/toolbar/SortZone.mjs */ "./src/draggable/tab/header/toolbar/SortZone.mjs"))
    }

    /**
     * Triggered after the useActiveTabIndicator config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetUseActiveTabIndicator(value, oldValue) {
        if (oldValue !== undefined) {
            let me = this;

            me.items.forEach(item => {
                // silent updates
                item._useActiveTabIndicator = value;
                item.updateUseActiveTabIndicator(true)
            });

            me.update()
        }
    }

    /**
     * @protected
     */
    createItems() {
        let me       = this,
            defaults = me.itemDefaults || {};

        defaults.useActiveTabIndicator = me.useActiveTabIndicator;
        me.itemDefaults = defaults;

        super.createItems()
    }

    /**
     * Returns the layout config matching to the dock position
     * @returns {Object} layoutConfig
     * @protected
     */
    getLayoutConfig() {
        let layoutConfig;

        switch (this.dock) {
            case 'bottom':
            case 'top':
                layoutConfig = {
                    align    : 'center',
                    direction: 'row',
                    pack     : 'start'
                };
                break
            case 'left':
                layoutConfig = {
                    align    : 'center',
                    direction: 'column-reverse',
                    pack     : 'end'
                };
                break
            case 'right':
                layoutConfig = {
                    align    : 'center',
                    direction: 'column',
                    pack     : 'start'
                };
                break
        }

        return layoutConfig
    }

    /**
     * Moves an existing item to a new index
     * @param {Number} fromIndex
     * @param {Number} toIndex
     * @returns {Neo.component.Base}
     */
    moveTo(fromIndex, toIndex) {
        let returnValue = super.moveTo(fromIndex, toIndex);

        if (fromIndex !== toIndex) {
            this.items.forEach((item, index) => {
                item.index = index
            })
        }

        return returnValue
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Toolbar));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY190YWJfQ29udGFpbmVyX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBOEM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJEQUFTO0FBQ3JDO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsNkJBQTZCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RDSztBQUNGO0FBQ0E7QUFDQztBQUNIO0FBQ047O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJEQUFhO0FBQ3JDO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtB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QUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSx1QkFBdUIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvdGFiL0JvZHlDb250YWluZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdGFiL0NvbnRhaW5lci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy90YWIvU3RyaXAubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdGFiL2hlYWRlci9CdXR0b24ubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdGFiL2hlYWRlci9Ub29sYmFyLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ29udGFpbmVyIGZyb20gJy4uL2NvbnRhaW5lci9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby50YWIuQm9keUNvbnRhaW5lclxuICogQGV4dGVuZHMgTmVvLmNvbnRhaW5lci5CYXNlXG4gKi9cbmNsYXNzIEJvZHlDb250YWluZXIgZXh0ZW5kcyBDb250YWluZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnRhYi5Cb2R5Q29udGFpbmVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8udGFiLkJvZHlDb250YWluZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tdGFiLWJvZHktY29udGFpbmVyJywnbmVvLWNvbnRhaW5lciddXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLXRhYi1ib2R5LWNvbnRhaW5lcicsICduZW8tY29udGFpbmVyJ11cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGFkZGluZyBhbiBleGlzdGluZyB0YWIgaW50byBhIGRpZmZlcmVudCBjb250YWluZXIsIGl0IHdpbGwgZ2V0IGF1dG9tYXRpY2FsbHkgZnJvbSB0aGUgY2xvc2VzdCBwYXJlbnQuXG4gICAgICogSW4gdGhpcyBjYXNlLCB3ZSBhbHNvIHdhbnQgdG8gcmVtb3ZlIHRoZSB0YWIuaGVhZGVyLkJ1dHRvbiBmcm9tIHRoZSB0YWIuaGVhZGVyLlRvb2xiYXIuXG4gICAgICogVXNlIGNhc2U6IFNoYXJlZENvdmlkLnZpZXcuTWFpbkNvbnRhaW5lckNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZGVzdHJveUl0ZW09dHJ1ZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdXG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZXxudWxsfVxuICAgICAqL1xuICAgIHJlbW92ZShjb21wb25lbnQsIGRlc3Ryb3lJdGVtLCBzaWxlbnQpIHtcbiAgICAgICAgaWYgKGNvbXBvbmVudD8uaXNUYWIpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LnJlbW92ZShjb21wb25lbnQsIGRlc3Ryb3lJdGVtLCBzaWxlbnQpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdXBlci5yZW1vdmUoY29tcG9uZW50LCBkZXN0cm95SXRlbSwgc2lsZW50KVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhCb2R5Q29udGFpbmVyKTtcbiIsImltcG9ydCBCYXNlQ29udGFpbmVyIGZyb20gJy4uL2NvbnRhaW5lci9CYXNlLm1qcyc7XG5pbXBvcnQgQm9keUNvbnRhaW5lciBmcm9tICcuL0JvZHlDb250YWluZXIubWpzJztcbmltcG9ydCBIZWFkZXJCdXR0b24gIGZyb20gJy4vaGVhZGVyL0J1dHRvbi5tanMnO1xuaW1wb3J0IEhlYWRlclRvb2xiYXIgZnJvbSAnLi9oZWFkZXIvVG9vbGJhci5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICAgICAgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IFN0cmlwICAgICAgICAgZnJvbSAnLi9TdHJpcC5tanMnO1xuXG4vKipcbiAqIEBzdW1tYXJ5IE1hbmFnZXMgYSB0YWJiZWQgaW50ZXJmYWNlIHdpdGggYSBoZWFkZXIgdG9vbGJhciBhbmQgYSBjb250ZW50IGJvZHkuXG4gKlxuICogVGhpcyBjbGFzcyBhY3RzIGFzIHRoZSBtYWluIG9yY2hlc3RyYXRvciBmb3IgYSB0YWJiZWQgdmlldy4gSXQgdXNlcyBhIGZsZXhib3ggbGF5b3V0IHRvIGFycmFuZ2UgaXRzXG4gKiB0d28gcHJpbWFyeSBjaGlsZHJlbjogYSBgTmVvLnRhYi5oZWFkZXIuVG9vbGJhcmAgZm9yIHRoZSB0YWIgYnV0dG9ucyBhbmQgYSBgTmVvLnRhYi5Cb2R5Q29udGFpbmVyYC5cbiAqIFRoZSBgQm9keUNvbnRhaW5lcmAgaXMgY29uZmlndXJlZCB3aXRoIGEgYGNhcmRgIGxheW91dC4gVG8ga2VlcCB0aGUgbGl2ZSBET00gdHJlZSBtaW5pbWFsLCB0aGlzXG4gKiBsYXlvdXQgZGVmYXVsdHMgdG8gcmVtb3ZpbmcgdGhlIERPTSBvZiBpbmFjdGl2ZSB0YWJzLCB3aGlsZSBrZWVwaW5nIHRoZSBjb21wb25lbnQgaW5zdGFuY2VzIGFuZFxuICogdGhlaXIgVkRPTSB0cmVlcyBpbiBtZW1vcnkgZm9yIGZhc3Qgc3dpdGNoaW5nLiBUaGlzIGJlaGF2aW9yIGNhbiBiZSBjaGFuZ2VkIHZpYSB0aGUgYHJlbW92ZUluYWN0aXZlQ2FyZHNgIGNvbmZpZy5cbiAqXG4gKiBUaGlzIGNsYXNzIGlzIGEga2V5IGV4YW1wbGUgb2YgdGhlIGZyYW1ld29yaydzICoqcHVzaC1iYXNlZCByZWFjdGl2aXR5KiogbW9kZWwgYW5kIGRlbW9uc3RyYXRlcyBjb25jZXB0cyBsaWtlXG4gKiAqKmNvbXBvbmVudCBjb21wb3NpdGlvbioqLCAqKmV2ZW50IGhhbmRsaW5nKiosIGFuZCAqKmRhdGEgYmluZGluZyoqLlxuICpcbiAqIEBzZWUgTmVvLmV4YW1wbGVzLnRhYi5Db250YWluZXJcbiAqIEBjbGFzcyBOZW8udGFiLkNvbnRhaW5lclxuICogQGV4dGVuZHMgTmVvLmNvbnRhaW5lci5CYXNlXG4gKi9cbmNsYXNzIENvbnRhaW5lciBleHRlbmRzIEJhc2VDb250YWluZXIge1xuICAgIC8qKlxuICAgICAqIFZhbGlkIHZhbHVlcyBmb3IgdGFiQmFyUG9zaXRpb25cbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gdGFiQmFyUG9zaXRpb25zPVsndG9wJywncmlnaHQnLCdib3R0b20nLCdsZWZ0J11cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyB0YWJCYXJQb3NpdGlvbnMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby50YWIuQ29udGFpbmVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8udGFiLkNvbnRhaW5lcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSd0YWItY29udGFpbmVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3RhYi1jb250YWluZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogWW91IGNhbiB1c2UgbnVsbCB0byBub3QgbW91bnQgYW55IGl0ZW1zIGluaXRpYWxseVxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gYWN0aXZlSW5kZXhfPTBcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBhY3RpdmVJbmRleF86IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIHdpbGwgYWN0aXZhdGUgYSB0YWIgd2hpY2ggZ2V0cyBkeW5hbWljYWxseSBpbnNlcnRlZCAvIGFkZGVkIGFmdGVyIHRoZSBUYWJDb250YWluZXIgaXMgbW91bnRlZFxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhY3RpdmF0ZUluc2VydGVkVGFicz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZhdGVJbnNlcnRlZFRhYnM6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tdGFiLWNvbnRhaW5lciddLFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby10YWItY29udGFpbmVyJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZhdWx0IGNvbmZpZ3MgZm9yIHRoZSB0YWIuQm9keUNvbnRhaW5lclxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gYm9keUNvbnRhaW5lcj1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBib2R5Q29udGFpbmVyOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGJvZHlDb250YWluZXJJZD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBib2R5Q29udGFpbmVySWQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0cnVlIGVuYWJsZXMgc29ydGluZyB0YWJzIHZpYSBkcmFnJmRyb3AuXG4gICAgICAgICAqIFRoZSBjb25maWcgZ2V0cyBwYXNzZWQgdG8gdGhlIGhlYWRlciB0b29sYmFyXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGRyYWdSZXNvcnRhYmxlPWZhbHNlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ1Jlc29ydGFibGU6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogRGVmYXVsdCBjb25maWdzIGZvciB0aGUgdGFiLkhlYWRlclRvb2xiYXJcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGhlYWRlclRvb2xiYXI9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgaGVhZGVyVG9vbGJhcjogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBsYXlvdXQ9bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGxheW91dDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgdG8gbm90IGFwcGx5IGEgYmFja2dyb3VuZCBlZmZlY3QgdG8gdGhlIHRhYiBoZWFkZXIgY29udGFpbmVyXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHBsYWluXz10cnVlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgcGxhaW5fOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIHRoZSBET00gb2YgaW5hY3RpdmUgY2FyZHMgKFRhYkNvbnRhaW5lciBCb2R5KS5cbiAgICAgICAgICogVGhpcyB3aWxsIGtlZXAgdGhlIGluc3RhbmNlcyAmIHZkb20gdHJlZXNcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gcmVtb3ZlSW5hY3RpdmVDYXJkcz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmVJbmFjdGl2ZUNhcmRzOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IHRhYkJhcklkPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHRhYkJhcklkOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogRGVmYXVsdCBjb25maWdzIGZvciB0aGUgdGFiLlN0cmlwXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSB0YWJTdHJpcD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB0YWJTdHJpcDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSB0YWJTdHJpcElkPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHRhYlN0cmlwSWQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcG9zaXRpb24gb2YgdGhlIHRhYiBoZWFkZXIgdG9vbGJhci5cbiAgICAgICAgICogVmFsaWQgdmFsdWVzIGFyZSB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gdGFiQmFyUG9zaXRpb25fPSd0b3AnXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGFiQmFyUG9zaXRpb25fOiAndG9wJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGFkZHMgdGFiQ29udGFpbmVyQ2xzICsgJy1wbGFpbicgaXMgY2FzZSBwbGFpbiBpcyBzZXQgdG8gdHJ1ZVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHRhYkNvbnRhaW5lckNscz0nbmVvLXRhYi1jb250YWluZXInXG4gICAgICAgICAqL1xuICAgICAgICB0YWJDb250YWluZXJDbHM6ICduZW8tdGFiLWNvbnRhaW5lcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB1c2VBY3RpdmVUYWJJbmRpY2F0b3JfPXRydWVcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB1c2VBY3RpdmVUYWJJbmRpY2F0b3JfOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBvbmUgb3IgbW9yZSB0YWIgaXRlbXMgdG8gdGhlIGVuZCBvZiB0aGUgY29udGFpbmVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fE9iamVjdFtdfSBpdGVtIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgYSBuZXcgdGFiIG9yIGFuIGFycmF5IG9mIHN1Y2ggb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlfE5lby5jb21wb25lbnQuQmFzZVtdfSBUaGUgbmV3bHkgY3JlYXRlZCBjb21wb25lbnQocykuXG4gICAgICovXG4gICAgYWRkKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0KHRoaXMuZ2V0VGFiQmFyKCkuaXRlbXMubGVuZ3RoLCBpdGVtKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlIGxvZ2ljIGFmdGVyIHRoZSBgYWN0aXZlSW5kZXhgIGNvbmZpZyBoYXMgY2hhbmdlZC4gSXQgZW5zdXJlcyB0aGF0IHRoZVxuICAgICAqIGxheW91dCBvZiB0aGUgYEJvZHlDb250YWluZXJgIGlzIHVwZGF0ZWQgdG8gc2hvdyB0aGUgY29ycmVjdCBjYXJkIGFuZCBmaXJlcyB0aGVcbiAgICAgKiBgYWN0aXZlSW5kZXhDaGFuZ2VgIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IHZhbHVlIFRoZSBuZXcgYWN0aXZlIGluZGV4LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IG9sZFZhbHVlIFRoZSBwcmV2aW91cyBhY3RpdmUgaW5kZXguXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgICBhc3luYyBhZnRlclNldEFjdGl2ZUluZGV4KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjYXJkQ29udGFpbmVyID0gTmVvLmdldENvbXBvbmVudChtZS5ib2R5Q29udGFpbmVySWQpO1xuXG4gICAgICAgIGlmIChOZW8uaXNOdW1iZXIodmFsdWUpICYmIHZhbHVlID4gLTEgJiYgIWNhcmRDb250YWluZXIpIHtcbiAgICAgICAgICAgIG1lLm9uKCdjb25zdHJ1Y3RlZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBtZS5hZnRlclNldEFjdGl2ZUluZGV4KHZhbHVlLCBvbGRWYWx1ZSlcbiAgICAgICAgICAgIH0sIG1lLCB7b25jZTogdHJ1ZX0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKHZhbHVlKSAmJiB2YWx1ZSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBlbnN1cmUgdGhlIGFmdGVyU2V0IG1ldGhvZCB0cmlnZ2VycyB3aGVuIGxhenkgbG9hZGluZyB0aGUgbW9kdWxlXG4gICAgICAgICAgICAgICAgY2FyZENvbnRhaW5lci5sYXlvdXQuX2FjdGl2ZUluZGV4ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYXdhaXQgY2FyZENvbnRhaW5lci5sYXlvdXQuYWZ0ZXJTZXRBY3RpdmVJbmRleCh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUudXBkYXRlVGFiQnV0dG9ucygpO1xuXG4gICAgICAgICAgICAgICAgICAgIG1lLmZpcmUoJ2FjdGl2ZUluZGV4Q2hhbmdlJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbTogbWUuZ2V0QWN0aXZlQ2FyZCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgb3IgcmVtb3ZlcyB0aGUgcGxhaW4gQ1NTIGNsYXNzIHdoZW4gdGhlIGBwbGFpbmAgY29uZmlnIGNoYW5nZXMuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSBUaGUgbmV3IHZhbHVlIGZvciBgcGxhaW5gLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWUgVGhlIG9sZCB2YWx1ZSBmb3IgYHBsYWluYC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRQbGFpbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjbHN9ID0gbWU7XG5cbiAgICAgICAgTmVvQXJyYXlbdmFsdWUgPyAndW5zaGlmdCcgOiAncmVtb3ZlJ10oY2xzLCBtZS50YWJDb250YWluZXJDbHMgKyAnLXBsYWluJyk7XG4gICAgICAgIG1lLmNscyA9IGNsc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhc3NlcyB0aGUgYGRyYWdSZXNvcnRhYmxlYCBjb25maWcgZG93biB0byB0aGUgYEhlYWRlclRvb2xiYXJgIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgVGhlIG5ldyB2YWx1ZSBmb3IgYGRyYWdSZXNvcnRhYmxlYC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlIFRoZSBvbGQgdmFsdWUgZm9yIGBkcmFnUmVzb3J0YWJsZWAuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RHJhZ1Jlc29ydGFibGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmdldFRhYkJhcigpLmRyYWdSZXNvcnRhYmxlID0gdmFsdWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkanVzdHMgdGhlIGNvbnRhaW5lcidzIGxheW91dCBhbmQgQ1NTIGNsYXNzZXMgd2hlbiB0aGUgdGFiIGJhciBwb3NpdGlvbiBjaGFuZ2VzLlxuICAgICAqIFRoaXMgbWV0aG9kIGVuc3VyZXMgdGhhdCB0aGUgYEhlYWRlclRvb2xiYXJgIGlzIGRvY2tlZCBjb3JyZWN0bHkgYW5kIHRoYXQgdGhlIG92ZXJhbGxcbiAgICAgKiBmbGV4Ym94IGxheW91dCBkaXJlY3Rpb24gaXMgdXBkYXRlZCB0byBhY2NvbW1vZGF0ZSB0aGUgbmV3IHBvc2l0aW9uIChlLmcuLCByb3cgZm9yIGxlZnQvcmlnaHQsXG4gICAgICogY29sdW1uIGZvciB0b3AvYm90dG9tKS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIG5ldyB0YWIgYmFyIHBvc2l0aW9uICgndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0JykuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlIFRoZSBvbGQgdGFiIGJhciBwb3NpdGlvbi5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRUYWJCYXJQb3NpdGlvbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjbHN9ID0gbWU7XG5cbiAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgJ25lby0nICsgb2xkVmFsdWUpO1xuICAgICAgICBOZW9BcnJheS5hZGQoY2xzLCAnbmVvLScgKyB2YWx1ZSk7XG4gICAgICAgIG1lLnNldFNpbGVudCh7Y2xzfSk7XG5cbiAgICAgICAgaWYgKG1lLnZub2RlSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIG1lLmxheW91dC5zZXRTaWxlbnQobWUuZ2V0TGF5b3V0Q29uZmlnKCkpO1xuICAgICAgICAgICAgbWUuZ2V0VGFiQmFyKCkuc2V0U2lsZW50KHtkb2NrOiB2YWx1ZX0pO1xuICAgICAgICAgICAgbWUuZ2V0VGFiU3RyaXAoKS5zZXRTaWxlbnQoe2NsczogWyduZW8tdGFiLXN0cmlwJywgICduZW8tZG9jay0nICsgdmFsdWVdfSk7XG5cbiAgICAgICAgICAgIG1lLnVwZGF0ZURlcHRoID0gMjtcblxuICAgICAgICAgICAgbWUuZmlyZSgndGFiQmFyUG9zaXRpb25DaGFuZ2UnLCB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50OiBtZSxcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFzc2VzIHRoZSBgdXNlQWN0aXZlVGFiSW5kaWNhdG9yYCBjb25maWcgZG93biB0byB0aGUgYEhlYWRlclRvb2xiYXJgIGFuZCBgU3RyaXBgIGluc3RhbmNlcy5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIFRoZSBuZXcgdmFsdWUgZm9yIGB1c2VBY3RpdmVUYWJJbmRpY2F0b3JgLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWUgVGhlIG9sZCB2YWx1ZSBmb3IgYHVzZUFjdGl2ZVRhYkluZGljYXRvcmAuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VXNlQWN0aXZlVGFiSW5kaWNhdG9yKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5nZXRUYWJCYXIoKSAgLnVzZUFjdGl2ZVRhYkluZGljYXRvciA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5nZXRUYWJTdHJpcCgpLnVzZUFjdGl2ZVRhYkluZGljYXRvciA9IHZhbHVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgdGhlIG5ldyB2YWx1ZSBmb3IgdGhlIGB0YWJCYXJQb3NpdGlvbmAgY29uZmlnLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBUaGUgbmV3IHZhbHVlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZSBUaGUgb2xkIHZhbHVlLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgdmFsaWRhdGVkIHZhbHVlLlxuICAgICAqL1xuICAgIGJlZm9yZVNldFRhYkJhclBvc2l0aW9uKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAndGFiQmFyUG9zaXRpb24nKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyB0aGUgYmFzZSBgY3JlYXRlSXRlbXNgIGxpZmVjeWNsZSBtZXRob2QgdG8gY29uc3RydWN0IHRoZSBzcGVjaWZpYyBjb21wb25lbnRcbiAgICAgKiBoaWVyYXJjaHkgcmVxdWlyZWQgZm9yIGEgdGFiIGNvbnRhaW5lci4gSXQgdHJhbnNmb3JtcyB0aGUgdXNlci1wcm92aWRlZCBgaXRlbXNgIGFycmF5XG4gICAgICogaW50byB0aGUgdGhyZWUgY29yZSBjaGlsZCBjb21wb25lbnRzOiBgSGVhZGVyVG9vbGJhcmAsIGBTdHJpcGAsIGFuZCBgQm9keUNvbnRhaW5lcmAuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNyZWF0ZUl0ZW1zKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7YWN0aXZlSW5kZXgsIHJlbW92ZUluYWN0aXZlQ2FyZHMsIHVzZUFjdGl2ZVRhYkluZGljYXRvcn0gPSBtZSxcbiAgICAgICAgICAgIGl0ZW1zICAgICAgICAgPSBtZS5pdGVtcyB8fCBbXSxcbiAgICAgICAgICAgIHRhYkJ1dHRvbnMgICAgPSBbXSxcbiAgICAgICAgICAgIHRhYkNvbXBvbmVudHMgPSBbXTtcblxuICAgICAgICBPYmplY3QuYXNzaWduKG1lLCB7XG4gICAgICAgICAgICBib2R5Q29udGFpbmVySWQ6IG1lLmJvZHlDb250YWluZXJJZCB8fCBOZW8uZ2V0SWQoJ2NvbnRhaW5lcicpLFxuICAgICAgICAgICAgdGFiQmFySWQgICAgICAgOiBtZS50YWJCYXJJZCAgICAgICAgfHwgTmVvLmdldElkKCd0YWItaGVhZGVyLXRvb2xiYXInKSxcbiAgICAgICAgICAgIHRhYlN0cmlwSWQgICAgIDogbWUudGFiU3RyaXBJZCAgICAgIHx8IE5lby5nZXRJZCgndGFiLXN0cmlwJylcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIHRhYkJ1dHRvbnMucHVzaChtZS5nZXRUYWJCdXR0b25Db25maWcoaXRlbS5oZWFkZXIsIGluZGV4KSk7XG5cbiAgICAgICAgICAgIGlmICghKGl0ZW0gaW5zdGFuY2VvZiBOZW8uY29tcG9uZW50LkJhc2UpKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IHtmbGV4OiAxLCAuLi5tZS5pdGVtRGVmYXVsdHMsIGlzVGFiOiB0cnVlLCAuLi5pdGVtfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0YWJDb21wb25lbnRzLnB1c2goaXRlbSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUuaXRlbXMgPSBbe1xuICAgICAgICAgICAgbW9kdWxlICAgICAgICA6IEhlYWRlclRvb2xiYXIsXG4gICAgICAgICAgICBkb2NrICAgICAgICAgIDogbWUudGFiQmFyUG9zaXRpb24sXG4gICAgICAgICAgICBkcmFnUmVzb3J0YWJsZTogbWUuZHJhZ1Jlc29ydGFibGUsXG4gICAgICAgICAgICBmbGV4ICAgICAgICAgIDogJ25vbmUnLFxuICAgICAgICAgICAgaWQgICAgICAgICAgICA6IG1lLnRhYkJhcklkLFxuICAgICAgICAgICAgaXRlbXMgICAgICAgICA6IHRhYkJ1dHRvbnMsXG4gICAgICAgICAgICB1c2VBY3RpdmVUYWJJbmRpY2F0b3IsXG4gICAgICAgICAgICAuLi5tZS5oZWFkZXJUb29sYmFyXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1vZHVsZSAgICAgICAgOiBTdHJpcCxcbiAgICAgICAgICAgIGNscyAgICAgICAgICAgOiBbJ25lby1kb2NrLScgKyBtZS50YWJCYXJQb3NpdGlvbl0sXG4gICAgICAgICAgICBmbGV4ICAgICAgICAgIDogJ25vbmUnLFxuICAgICAgICAgICAgaWQgICAgICAgICAgICA6IG1lLnRhYlN0cmlwSWQsXG4gICAgICAgICAgICB0YWJDb250YWluZXJJZDogbWUuaWQsXG4gICAgICAgICAgICB1c2VBY3RpdmVUYWJJbmRpY2F0b3IsXG4gICAgICAgICAgICAuLi5tZS50YWJTdHJpcFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtb2R1bGUgICAgICA6IEJvZHlDb250YWluZXIsXG4gICAgICAgICAgICBpZCAgICAgICAgICA6IG1lLmJvZHlDb250YWluZXJJZCxcbiAgICAgICAgICAgIGl0ZW1EZWZhdWx0czogbWUuaXRlbURlZmF1bHRzLFxuICAgICAgICAgICAgaXRlbXMgICAgICAgOiB0YWJDb21wb25lbnRzLFxuICAgICAgICAgICAgbGF5b3V0ICAgICAgOiB7bnR5cGU6ICdjYXJkJywgYWN0aXZlSW5kZXgsIHJlbW92ZUluYWN0aXZlQ2FyZHN9LFxuICAgICAgICAgICAgdXNlQWN0aXZlVGFiSW5kaWNhdG9yLFxuICAgICAgICAgICAgLi4ubWUuYm9keUNvbnRhaW5lclxuICAgICAgICB9XTtcblxuICAgICAgICBtZS5pdGVtRGVmYXVsdHMgPSBudWxsO1xuXG4gICAgICAgIHN1cGVyLmNyZWF0ZUl0ZW1zKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGNvbXBvbmVudCBpbnN0YW5jZSBmb3IgdGhlIGN1cnJlbnRseSBhY3RpdmUgdGFiLlxuICAgICAqIEByZXR1cm5zIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH0gVGhlIGFjdGl2ZSBjYXJkIGNvbXBvbmVudCBvciBudWxsIGlmIG5vbmUgaXMgYWN0aXZlLlxuICAgICAqL1xuICAgIGdldEFjdGl2ZUNhcmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENhcmRDb250YWluZXIoKT8uaXRlbXNbdGhpcy5hY3RpdmVJbmRleF0gfHwgbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgY29tcG9uZW50IGluc3RhbmNlIGZvciBhIHRhYiBhdCBhIHNwZWNpZmljIGluZGV4LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGNhcmQgdG8gcmV0cmlldmUuXG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZXxudWxsfSBUaGUgY2FyZCBjb21wb25lbnQgb3IgbnVsbCBpZiBub3QgZm91bmQuXG4gICAgICovXG4gICAgZ2V0Q2FyZChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDYXJkQ29udGFpbmVyKCk/Lml0ZW1zW2luZGV4XSB8fCBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBjb252ZW5pZW5jZSBtZXRob2QgdG8gZ2V0IHRoZSBgQm9keUNvbnRhaW5lcmAgaW5zdGFuY2UgdGhhdCBob2xkcyB0aGUgdGFiIGNvbnRlbnQgY2FyZHMuXG4gICAgICogQHJldHVybnMge05lby5jb250YWluZXIuQmFzZX0gVGhlIGJvZHkgY29udGFpbmVyIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGdldENhcmRDb250YWluZXIoKSB7XG4gICAgICAgIHJldHVybiBOZW8uZ2V0Q29tcG9uZW50KHRoaXMuYm9keUNvbnRhaW5lcklkKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRvdGFsIG51bWJlciBvZiB0YWJzIGluIHRoZSBjb250YWluZXIuXG4gICAgICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWJlciBvZiB0YWJzLlxuICAgICAqL1xuICAgIGdldENvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRUYWJCYXIoKS5pdGVtcy5sZW5ndGhcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgdGhlIGFwcHJvcHJpYXRlIGZsZXhib3ggbGF5b3V0IGNvbmZpZ3VyYXRpb24gYmFzZWQgb24gdGhlIGN1cnJlbnQgYHRhYkJhclBvc2l0aW9uYC5cbiAgICAgKiBGb3IgZXhhbXBsZSwgYSAndG9wJyBvciAnYm90dG9tJyBwb3NpdGlvbiByZXF1aXJlcyBhIHZlcnRpY2FsIGxheW91dCwgd2hpbGUgJ2xlZnQnIG9yICdyaWdodCdcbiAgICAgKiByZXF1aXJlcyBhIGhvcml6b250YWwgb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBmbGV4Ym94IGxheW91dCBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZ2V0TGF5b3V0Q29uZmlnKCkge1xuICAgICAgICBsZXQgbGF5b3V0TWFwID0ge1xuICAgICAgICAgICAgYm90dG9tOiB7XG4gICAgICAgICAgICAgICAgYWxpZ24gICAgOiAnc3RyZXRjaCcsXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnY29sdW1uLXJldmVyc2UnLFxuICAgICAgICAgICAgICAgIHBhY2sgICAgIDogJ3N0YXJ0J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxlZnQ6IHtcbiAgICAgICAgICAgICAgICBhbGlnbiAgICA6ICdzdHJldGNoJyxcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdyb3cnLFxuICAgICAgICAgICAgICAgIHBhY2sgICAgIDogJ3N0YXJ0J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJpZ2h0OiB7XG4gICAgICAgICAgICAgICAgYWxpZ24gICAgOiAnc3RyZXRjaCcsXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAncm93LXJldmVyc2UnLFxuICAgICAgICAgICAgICAgIHBhY2sgICAgIDogJ3N0YXJ0J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvcDoge1xuICAgICAgICAgICAgICAgIGFsaWduICAgIDogJ3N0cmV0Y2gnLFxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgICAgICAgICAgICAgcGFjayAgICAgOiAnc3RhcnQnXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGxheW91dE1hcFt0aGlzLnRhYkJhclBvc2l0aW9uXSB8fCBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBgSGVhZGVyQnV0dG9uYCBpbnN0YW5jZSBmb3IgYSB0YWIgYXQgYSBzcGVjaWZpYyBpbmRleC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSB0YWIgYnV0dG9uIHRvIHJldHJpZXZlLlxuICAgICAqIEByZXR1cm5zIHtOZW8udGFiLmhlYWRlci5CdXR0b258bnVsbH0gVGhlIHRhYiBidXR0b24gY29tcG9uZW50IG9yIG51bGwgaWYgbm90IGZvdW5kLlxuICAgICAqL1xuICAgIGdldFRhYkF0SW5kZXgoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGFiQmFyKCkuaXRlbXNbaW5kZXhdIHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGNvbnZlbmllbmNlIG1ldGhvZCB0byBnZXQgdGhlIGBIZWFkZXJUb29sYmFyYCBpbnN0YW5jZSB0aGF0IGhvbGRzIHRoZSB0YWIgYnV0dG9ucy5cbiAgICAgKiBAcmV0dXJucyB7TmVvLnRvb2xiYXIuQmFzZX0gVGhlIGhlYWRlciB0b29sYmFyIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGdldFRhYkJhcigpIHtcbiAgICAgICAgcmV0dXJuIE5lby5nZXRDb21wb25lbnQodGhpcy50YWJCYXJJZClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgYSBzaW5nbGUgdGFiIGJ1dHRvbi4gSXQgbWVyZ2VzIGEgZGVmYXVsdCBjb25maWd1cmF0aW9uXG4gICAgICogKGluY2x1ZGluZyB0aGUgbW9kdWxlLCBpbmRleCwgYW5kIGEgY2xpY2sgbGlzdGVuZXIgdG8gY2hhbmdlIGBhY3RpdmVJbmRleGApIHdpdGggdGhlXG4gICAgICogdXNlci1wcm92aWRlZCBjb25maWd1cmF0aW9uIGZyb20gdGhlIGl0ZW0ncyBgaGVhZGVyYCBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSB1c2VyLXByb3ZpZGVkIGNvbmZpZ3VyYXRpb24gZnJvbSBgaXRlbS5oZWFkZXJgLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhpcyB0YWIgYnV0dG9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBtZXJnZWQgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHRoZSB0YWIgYnV0dG9uLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBnZXRUYWJCdXR0b25Db25maWcoY29uZmlnLCBpbmRleCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuXG4gICAgICAgIGRlZmF1bHRDb25maWcgPSB7XG4gICAgICAgICAgICBtb2R1bGUgOiBIZWFkZXJCdXR0b24sXG4gICAgICAgICAgICBmbGV4ICAgOiAnbm9uZScsXG4gICAgICAgICAgICBpbmRleCAgOiBpbmRleCxcbiAgICAgICAgICAgIHByZXNzZWQ6IG1lLmFjdGl2ZUluZGV4ID09PSBpbmRleCxcblxuICAgICAgICAgICAgZG9tTGlzdGVuZXJzOiBbe1xuICAgICAgICAgICAgICAgIGNsaWNrKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuYWN0aXZlSW5kZXggPSBkYXRhLmNvbXBvbmVudC5pbmRleFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2NvcGU6IG1lXG4gICAgICAgICAgICB9XVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB7Li4uZGVmYXVsdENvbmZpZywgLi4uY29uZmlnfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgY29udmVuaWVuY2UgbWV0aG9kIHRvIGdldCB0aGUgYFN0cmlwYCBpbnN0YW5jZSwgd2hpY2ggaXMgcmVzcG9uc2libGUgZm9yIHJlbmRlcmluZ1xuICAgICAqIHRoZSBhY3RpdmUgdGFiIGluZGljYXRvci5cbiAgICAgKiBAcmV0dXJucyB7TmVvLnRhYi5TdHJpcH0gVGhlIHN0cmlwIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGdldFRhYlN0cmlwKCkge1xuICAgICAgICByZXR1cm4gTmVvLmdldENvbXBvbmVudCh0aGlzLnRhYlN0cmlwSWQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBvbmUgb3IgbW9yZSB0YWIgaXRlbXMgYXQgYSBzcGVjaWZpYyBpbmRleC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggVGhlIGluZGV4IGF0IHdoaWNoIHRvIGluc2VydCB0aGUgbmV3IGl0ZW0ocykuXG4gICAgICogQHBhcmFtIHtPYmplY3R8T2JqZWN0W119IGl0ZW0gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBhIG5ldyB0YWIgb3IgYW4gYXJyYXkgb2Ygc3VjaCBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbGVudD1mYWxzZV0gU2V0IHRvIHRydWUgdG8gcHJldmVudCBgdXBkYXRlVGFiQnV0dG9uc2AgZnJvbSBiZWluZyBjYWxsZWQuXG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZXxOZW8uY29tcG9uZW50LkJhc2VbXX0gVGhlIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50KHMpLlxuICAgICAqL1xuICAgIGluc2VydChpbmRleCwgaXRlbSwgc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNhcmRDb250YWluZXIgPSBtZS5nZXRDYXJkQ29udGFpbmVyKCksXG4gICAgICAgICAgICB0YWJCYXIgICAgICAgID0gbWUuZ2V0VGFiQmFyKCksXG4gICAgICAgICAgICBoYXNJdGVtICAgICAgID0gZmFsc2UsXG4gICAgICAgICAgICBpLCBsZW4sIHJldHVybkFycmF5LCBzdXBlckl0ZW0sIHRhYjtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICAgICAgaSAgICAgICAgICAgPSAwO1xuICAgICAgICAgICAgbGVuICAgICAgICAgPSBpdGVtLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybkFycmF5ID0gW107XG5cbiAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBpbnNlcnQgdGhlIGFycmF5IGJhY2t3YXJkc1xuICAgICAgICAgICAgICAgIHJldHVybkFycmF5LnVuc2hpZnQobWUuaW5zZXJ0KGluZGV4LCBpdGVtW2xlbiAtIDEgLSBpXSwgdHJ1ZSkpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN1cGVySXRlbSA9IHJldHVybkFycmF5O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpdGVtID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaSAgID0gMDtcbiAgICAgICAgICAgIGxlbiA9IGNhcmRDb250YWluZXIuaXRlbXMubGVuZ3RoO1xuXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhcmRDb250YWluZXIuaXRlbXNbaV0uaWQgPT09IGl0ZW0uaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzSXRlbSAgID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXJJdGVtID0gY2FyZENvbnRhaW5lci5pdGVtc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobWUuYWN0aXZhdGVJbnNlcnRlZFRhYnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLmFjdGl2ZUluZGV4ID0gaVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaGFzSXRlbSkge1xuICAgICAgICAgICAgICAgIHRhYiA9IHRhYkJhci5pbnNlcnQoaW5kZXgsIG1lLmdldFRhYkJ1dHRvbkNvbmZpZyhpdGVtLmhlYWRlciwgaW5kZXgpKTtcblxuICAgICAgICAgICAgICAgIC8vIHRvZG86IG5vbiBpbmRleCBiYXNlZCBtYXRjaGluZyBvZiB0YWIgYnV0dG9ucyBhbmQgY2FyZHNcbiAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICBsZW4gPSB0YWJCYXIuaXRlbXMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0YWJCYXIuaXRlbXNbaV0uaW5kZXggPSBpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaXRlbS5mbGV4ID0gMTtcbiAgICAgICAgICAgICAgICBzdXBlckl0ZW0gPSBjYXJkQ29udGFpbmVyLmluc2VydChpbmRleCwgaXRlbSwgc2lsZW50KTtcblxuICAgICAgICAgICAgICAgIGlmIChtZS5hY3RpdmF0ZUluc2VydGVkVGFicykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1lLnZub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5hY3RpdmVJbmRleCA9IGluZGV4XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWIub24oJ21vdW50ZWQnLCBtZS5vblRhYkJ1dHRvbk1vdW50ZWQsIG1lKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgIXNpbGVudCAmJiBtZS51cGRhdGVUYWJCdXR0b25zKCk7XG5cbiAgICAgICAgcmV0dXJuIHN1cGVySXRlbVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGFuIGV4aXN0aW5nIHRhYiAoYm90aCBpdHMgYnV0dG9uIGFuZCBpdHMgY2FyZCkgZnJvbSBvbmUgaW5kZXggdG8gYW5vdGhlci5cbiAgICAgKiBUaGlzIGlzIHByaW1hcmlseSB1c2VkIGZvciBkcmFnLWFuZC1kcm9wIHJlb3JkZXJpbmcuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZyb21JbmRleCBUaGUgb3JpZ2luYWwgaW5kZXggb2YgdGhlIHRhYi5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdG9JbmRleCBUaGUgbmV3IGluZGV4IGZvciB0aGUgdGFiLlxuICAgICAqIEByZXR1cm5zIHtOZW8uY29tcG9uZW50LkJhc2V9IFRoZSBjYXJkIGNvbXBvbmVudCB0aGF0IHdhcyBtb3ZlZC5cbiAgICAgKi9cbiAgICBtb3ZlVG8oZnJvbUluZGV4LCB0b0luZGV4KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNhcmRDb250YWluZXIgPSBtZS5nZXRDYXJkQ29udGFpbmVyKCksXG4gICAgICAgICAgICB0YWJCYXIgICAgICAgID0gbWUuZ2V0VGFiQmFyKCksXG4gICAgICAgICAgICBhY3RpdmVUYWIgICAgID0gdGFiQmFyLml0ZW1zW21lLmFjdGl2ZUluZGV4XSxcbiAgICAgICAgICAgIGluZGV4LCByZXR1cm5WYWx1ZTtcblxuICAgICAgICB0YWJCYXIubW92ZVRvKGZyb21JbmRleCwgdG9JbmRleCk7XG4gICAgICAgIGluZGV4ID0gYWN0aXZlVGFiLmluZGV4O1xuXG4gICAgICAgIGlmIChpbmRleCAhPT0gbWUuYWN0aXZlSW5kZXgpIHtcbiAgICAgICAgICAgIC8vIHNpbGVudCB1cGRhdGVzXG4gICAgICAgICAgICBtZS5fYWN0aXZlSW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIGNhcmRDb250YWluZXIubGF5b3V0Ll9hY3RpdmVJbmRleCA9IGluZGV4XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm5WYWx1ZSA9IGNhcmRDb250YWluZXIubW92ZVRvKGZyb21JbmRleCwgdG9JbmRleCk7XG5cbiAgICAgICAgbWUuZmlyZSgnbW92ZVRvJywge1xuICAgICAgICAgICAgZnJvbUluZGV4LFxuICAgICAgICAgICAgdG9JbmRleFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgdGhlIGJhc2UgYG9uQ29uc3RydWN0ZWRgIGxpZmVjeWNsZSBtZXRob2QgdG8gYXBwbHkgdGhlIGluaXRpYWwgZmxleGJveCBsYXlvdXRcbiAgICAgKiBjb25maWd1cmF0aW9uIGFmdGVyIHRoZSBtYWluIGNvbnN0cnVjdGlvbiBwcm9jZXNzIGlzIGNvbXBsZXRlLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbkNvbnN0cnVjdGVkKCkge1xuICAgICAgICB0aGlzLmxheW91dCA9IHtudHlwZTogJ2ZsZXhib3gnLCAuLi50aGlzLmdldExheW91dENvbmZpZygpfTtcbiAgICAgICAgc3VwZXIub25Db25zdHJ1Y3RlZCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBoYW5kbGVyIHRoYXQgaXMgdHJpZ2dlcmVkIHdoZW4gYSBkeW5hbWljYWxseSBhZGRlZCB0YWIgYnV0dG9uIGlzIG1vdW50ZWQgdG8gdGhlIERPTS5cbiAgICAgKiBJZiBgYWN0aXZhdGVJbnNlcnRlZFRhYnNgIGlzIHRydWUsIHRoaXMgbWV0aG9kIGVuc3VyZXMgdGhhdCB0aGUgYGFjdGl2ZUluZGV4YCBpcyBzZXRcbiAgICAgKiBjb3JyZWN0bHkgYWZ0ZXIgdGhlIG5ldyB0YWIncyBjb3JyZXNwb25kaW5nIGNhcmQgaXMgYWxzbyBtb3VudGVkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBidXR0b25JZCBUaGUgSUQgb2YgdGhlIG1vdW50ZWQgYnV0dG9uLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvblRhYkJ1dHRvbk1vdW50ZWQoYnV0dG9uSWQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY2FyZENvbnRhaW5lciA9IG1lLmdldENhcmRDb250YWluZXIoKSxcbiAgICAgICAgICAgIHRhYkJhciAgICAgICAgPSBtZS5nZXRUYWJCYXIoKSxcbiAgICAgICAgICAgIGkgICAgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgbGVuICAgICAgICAgICA9IHRhYkJhci5pdGVtcy5sZW5ndGgsXG4gICAgICAgICAgICBpbmRleCAgICAgICAgID0gLTEsXG4gICAgICAgICAgICBjYXJkO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0YWJCYXIuaXRlbXNbaV0uaWQgPT09IGJ1dHRvbklkKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgY2FyZCA9IGNhcmRDb250YWluZXIuaXRlbXNbaW5kZXhdO1xuXG4gICAgICAgICAgICBpZiAobWUudm5vZGUgJiYgIWNhcmQubW91bnRlZCkge1xuICAgICAgICAgICAgICAgIGNhcmQub24oJ21vdW50ZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmFjdGl2ZUluZGV4ID0gaW5kZXhcbiAgICAgICAgICAgICAgICB9LCBtZSwge29uY2U6IHRydWV9KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZS5hY3RpdmVJbmRleCA9IGluZGV4XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgdGFiIGZyb20gdGhlIGNvbnRhaW5lciB1c2luZyBhIHJlZmVyZW5jZSB0byB0aGUgY2FyZCBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudCBUaGUgY2FyZCBjb21wb25lbnQgaW5zdGFuY2UgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2Rlc3Ryb3lJdGVtPXRydWVdIFNldCB0byBmYWxzZSB0byBrZWVwIHRoZSBjb21wb25lbnQgaW5zdGFuY2UgaW4gbWVtb3J5LlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbGVudD1mYWxzZV0gU2V0IHRvIHRydWUgdG8gcHJldmVudCBgdXBkYXRlVGFiQnV0dG9uc2AgZnJvbSBiZWluZyBjYWxsZWQuXG4gICAgICovXG4gICAgcmVtb3ZlKGNvbXBvbmVudCwgZGVzdHJveUl0ZW09dHJ1ZSwgc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBpdGVtcyA9IFsuLi50aGlzLmdldENhcmRDb250YWluZXIoKS5pdGVtc10sXG4gICAgICAgICAgICBpICAgICA9IDAsXG4gICAgICAgICAgICBsZW4gICA9IGl0ZW1zLmxlbmd0aDtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaXRlbXNbaV0uaWQgPT09IGNvbXBvbmVudC5pZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQXQoaSwgZGVzdHJveUl0ZW0sIHNpbGVudClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSB0YWIgZnJvbSB0aGUgY29udGFpbmVyIGF0IGEgc3BlY2lmaWMgaW5kZXguXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGFiIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkZXN0cm95SXRlbT10cnVlXSBTZXQgdG8gZmFsc2UgdG8ga2VlcCB0aGUgY29tcG9uZW50IGluc3RhbmNlIGluIG1lbW9yeS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdIFNldCB0byB0cnVlIHRvIHByZXZlbnQgYHVwZGF0ZVRhYkJ1dHRvbnNgIGZyb20gYmVpbmcgY2FsbGVkLlxuICAgICAqL1xuICAgIHJlbW92ZUF0KGluZGV4LCBkZXN0cm95SXRlbT10cnVlLCBzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2FjdGl2ZUluZGV4fSA9IG1lLFxuICAgICAgICAgICAgY2FyZENvbnRhaW5lciA9IG1lLmdldENhcmRDb250YWluZXIoKSxcbiAgICAgICAgICAgIHRhYkJhciAgICAgICAgPSBtZS5nZXRUYWJCYXIoKSxcbiAgICAgICAgICAgIGksIGxlbjtcblxuICAgICAgICBjYXJkQ29udGFpbmVyLnJlbW92ZUF0KGluZGV4LCBkZXN0cm95SXRlbSwgc2lsZW50KTtcbiAgICAgICAgdGFiQmFyICAgICAgIC5yZW1vdmVBdChpbmRleCwgdHJ1ZSwgICAgICAgIGZhbHNlKTtcblxuICAgICAgICBpZiAoaW5kZXggPCBhY3RpdmVJbmRleCkge1xuICAgICAgICAgICAgLy8gc2lsZW50IHVwZGF0ZXNcbiAgICAgICAgICAgIG1lLl9hY3RpdmVJbmRleCA9IGFjdGl2ZUluZGV4IC0gMTtcbiAgICAgICAgICAgIGNhcmRDb250YWluZXIubGF5b3V0Ll9hY3RpdmVJbmRleCA9IGFjdGl2ZUluZGV4IC0gMVxuICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID09PSBhY3RpdmVJbmRleCkge1xuICAgICAgICAgICAgbWUuYWN0aXZlSW5kZXggPSBhY3RpdmVJbmRleCAtIDFcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRvZG86IG5vbiBpbmRleCBiYXNlZCBtYXRjaGluZyBvZiB0YWIgYnV0dG9ucyBhbmQgY2FyZHNcbiAgICAgICAgaSAgID0gMDtcbiAgICAgICAgbGVuID0gdGFiQmFyLml0ZW1zLmxlbmd0aDtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0YWJCYXIuaXRlbXNbaV0uaW5kZXggPSBpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTeW5jaHJvbml6ZXMgdGhlIGBwcmVzc2VkYCBzdGF0ZSBvZiBhbGwgdGFiIGJ1dHRvbnMgd2l0aCB0aGUgY29udGFpbmVyJ3MgYGFjdGl2ZUluZGV4YC5cbiAgICAgKiBUaGlzIGVuc3VyZXMgdGhhdCBvbmx5IHRoZSBidXR0b24gY29ycmVzcG9uZGluZyB0byB0aGUgYWN0aXZlIHRhYiBhcHBlYXJzIHByZXNzZWQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHVwZGF0ZVRhYkJ1dHRvbnMoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHthY3RpdmVJbmRleH0gPSBtZSxcbiAgICAgICAgICAgIHRhYkJ1dHRvbnMgICAgPSBtZS5nZXRUYWJCYXIoKT8uaXRlbXMgfHwgW107XG5cbiAgICAgICAgdGFiQnV0dG9ucy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaXRlbS5wcmVzc2VkID0gaW5kZXggPT09IGFjdGl2ZUluZGV4XG4gICAgICAgIH0pXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhDb250YWluZXIpO1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQvQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8udGFiLlN0cmlwXG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqL1xuY2xhc3MgU3RyaXAgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnRhYi5TdHJpcCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnRhYi5TdHJpcCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSd0YWItc3RyaXAnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAndGFiLXN0cmlwJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLXRhYi1zdHJpcCddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby10YWItc3RyaXAnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSB0YWJDb250YWluZXJJZD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB0YWJDb250YWluZXJJZDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHVzZUFjdGl2ZVRhYkluZGljYXRvcl89dHJ1ZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHVzZUFjdGl2ZVRhYkluZGljYXRvcl86IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IF92ZG9tPXtjbjogW3tjbHM6ICduZW8tYWN0aXZlLXRhYi1pbmRpY2F0b3InfV19XG4gICAgICAgICAqL1xuICAgICAgICBfdmRvbTpcbiAgICAgICAge2NuOiBbXG4gICAgICAgICAgICB7Y2xzOiBbJ25lby1hY3RpdmUtdGFiLWluZGljYXRvciddfVxuICAgICAgICBdfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdXNlQWN0aXZlVGFiSW5kaWNhdG9yIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VXNlQWN0aXZlVGFiSW5kaWNhdG9yKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnZkb20uY25bMF0ucmVtb3ZlRG9tID0gIXZhbHVlO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgRG9tUmVjdCBvZiB0aGUgYWN0aXZlIHRhYiwgdGhlbiBtb3ZlcyB0aGUgaW5kaWNhdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R8bnVsbH0gb3B0c1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRzLm9sZFZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdHMudmFsdWVcbiAgICAgKi9cbiAgICBnZXRBY3RpdmVUYWJSZWN0VGhlbk1vdmUob3B0cykge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGlkcyAgICAgICAgICA9IFttZS5pZF0sXG4gICAgICAgICAgICB0YWJDb250YWluZXIgPSBtZS5nZXRUYWJDb250YWluZXIoKSxcbiAgICAgICAgICAgIG9sZFRhYjtcblxuICAgICAgICAvLyBXZSBkbyBub3QgbmVlZCBhIG1vdmVtZW50LCBpbiBjYXNlIHRoZXJlIGlzIG5vIG9sZFZhbHVlXG4gICAgICAgIGlmIChtZS51c2VBY3RpdmVUYWJJbmRpY2F0b3IgJiYgbWUudm5vZGUgJiYgTmVvLmlzTnVtYmVyKG9wdHM/Lm9sZFZhbHVlKSkge1xuICAgICAgICAgICAgb2xkVGFiID0gdGFiQ29udGFpbmVyLmdldFRhYkF0SW5kZXgob3B0cy5vbGRWYWx1ZSk7XG5cbiAgICAgICAgICAgIC8vIFRoZSBhY3RpdmVJbmRleENoYW5nZSBldmVudCBjYW4gZ2V0IHRyaWdnZXJlZCB3aGVuIHJlbW92aW5nIHRoZSBjdXJyZW50bHkgYWN0aXZlIHRhYixcbiAgICAgICAgICAgIC8vIEluIHRoaXMgY2FzZSwgd2UgY2FuIG5vIGxvbmdlciBhY2Nlc3MgdGhlIHJlbGF0ZWQgRE9NUmVjdCBhbmQgbmVlZCB0byBvcHQgb3V0LlxuICAgICAgICAgICAgaWYgKG9sZFRhYikge1xuICAgICAgICAgICAgICAgIGlkcy5wdXNoKHRhYkNvbnRhaW5lci5nZXRUYWJBdEluZGV4KG9wdHMudmFsdWUpLmlkLCBvbGRUYWIuaWQpO1xuXG4gICAgICAgICAgICAgICAgbWUuZ2V0RG9tUmVjdChpZHMpLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG1lLm1vdmVBY3RpdmVJbmRpY2F0b3IoZGF0YSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBnZXRUYWJDb250YWluZXIoKSB7XG4gICAgICAgIHJldHVybiBOZW8uZ2V0Q29tcG9uZW50KHRoaXMudGFiQ29udGFpbmVySWQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FuIGVpdGhlciBjb250YWluIHRoZSBuZXcgdGFyZ2V0IHJlY3Qgb3IgdGhlIG5ldyBhbmQgb2xkIG9uZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IHJlY3RzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJlY3RzWzBdLmJvdHRvbVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByZWN0c1swXS5oZWlnaHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmVjdHNbMF0ubGVmdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByZWN0c1swXS5yaWdodFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByZWN0c1swXS50b3BcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmVjdHNbMF0ud2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmVjdHNbMF0ueFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByZWN0c1swXS55XG4gICAgICovXG4gICAgbW92ZUFjdGl2ZUluZGljYXRvcihyZWN0cykge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHRhYlN0cmlwUmVjdCA9IHJlY3RzLnNoaWZ0KCksXG4gICAgICAgICAgICByZWN0ICAgICAgICAgPSByZWN0c1sxXSB8fCByZWN0c1swXSxcbiAgICAgICAgICAgIGFjdGl2ZVRhYkluZGljYXRvciwgdGFiQ29udGFpbmVyO1xuXG4gICAgICAgIGlmIChtZS51c2VBY3RpdmVUYWJJbmRpY2F0b3IpIHtcbiAgICAgICAgICAgIGFjdGl2ZVRhYkluZGljYXRvciA9IG1lLnZkb20uY25bMF07XG4gICAgICAgICAgICB0YWJDb250YWluZXIgICAgICAgPSBtZS5nZXRUYWJDb250YWluZXIoKTtcblxuICAgICAgICAgICAgc3dpdGNoICh0YWJDb250YWluZXIudGFiQmFyUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZVRhYkluZGljYXRvci5zdHlsZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgIDogYCR7cmVjdC5sZWZ0IC0gdGFiU3RyaXBSZWN0LmxlZnR9cHhgLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wICAgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggOiBgJHtyZWN0LndpZHRofXB4YFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlVGFiSW5kaWNhdG9yLnN0eWxlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBgJHtyZWN0LmhlaWdodH1weGAsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ICA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AgICA6IGAke3JlY3QudG9wIC0gdGFiU3RyaXBSZWN0LnRvcH1weGAsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGVyZSBpcyBhIGR5bmFtaWMgY2hhbmdlIChvbGRWYWx1ZSksIGNhbGwgdGhpcyBtZXRob2QgYWdhaW5cbiAgICAgICAgICAgIGlmIChyZWN0c1sxXSkge1xuICAgICAgICAgICAgICAgIGFjdGl2ZVRhYkluZGljYXRvci5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgICAgICAgICBtZS51cGRhdGUoKTtcblxuICAgICAgICAgICAgICAgIG1lLnRpbWVvdXQoNTApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBtZS5tb3ZlQWN0aXZlSW5kaWNhdG9yKFt0YWJTdHJpcFJlY3QsIHJlY3RzWzBdXSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVUYWJJbmRpY2F0b3Iuc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgICAgICAgICAgICAgbWUudXBkYXRlKCk7XG5cbiAgICAgICAgICAgICAgICBtZS50aW1lb3V0KDMwMCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZVRhYkluZGljYXRvci5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbWUudXBkYXRlKClcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNvbnN0cnVjdGVkKCkge1xuICAgICAgICBzdXBlci5vbkNvbnN0cnVjdGVkKCk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5nZXRUYWJDb250YWluZXIoKS5vbih7XG4gICAgICAgICAgICBhY3RpdmVJbmRleENoYW5nZTogbWUuZ2V0QWN0aXZlVGFiUmVjdFRoZW5Nb3ZlLFxuICAgICAgICAgICAgc2NvcGUgICAgICAgICAgICA6IG1lXG4gICAgICAgIH0pXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhTdHJpcCk7XG4iLCJpbXBvcnQgQmFzZUJ1dHRvbiBmcm9tICcuLi8uLi9idXR0b24vQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8udGFiLmhlYWRlci5CdXR0b25cbiAqIEBleHRlbmRzIE5lby5idXR0b24uQmFzZVxuICovXG5jbGFzcyBCdXR0b24gZXh0ZW5kcyBCYXNlQnV0dG9uIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby50YWIuaGVhZGVyLkJ1dHRvbidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnRhYi5oZWFkZXIuQnV0dG9uJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3RhYi1oZWFkZXItYnV0dG9uJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3RhYi1oZWFkZXItYnV0dG9uJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWJ1dHRvbicsJ25lby10YWItYnV0dG9uJ11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLXRhYi1oZWFkZXItYnV0dG9uJywgJ25lby1idXR0b24nXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZnkgYSByb2xlIHRhZyBhdHRyaWJ1dGUgZm9yIHRoZSB2ZG9tIHJvb3QuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSByb2xlPSd0YWInXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgcm9sZTogJ3RhYicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB1c2VBY3RpdmVUYWJJbmRpY2F0b3JfPXRydWVcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB1c2VBY3RpdmVUYWJJbmRpY2F0b3JfOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbVxuICAgICAgICAgKi9cbiAgICAgICAgX3Zkb206XG4gICAgICAgIHt0YWc6ICdidXR0b24nLCBjbjogW1xuICAgICAgICAgICAge3RhZzogJ3NwYW4nLCBjbHM6IFsnbmVvLWJ1dHRvbi1nbHlwaCddfSxcbiAgICAgICAgICAgIHt0YWc6ICdzcGFuJywgY2xzOiBbJ25lby1idXR0b24tdGV4dCddfSxcbiAgICAgICAgICAgIHtjbHM6IFsnbmVvLWJ1dHRvbi1iYWRnZSddfSxcbiAgICAgICAgICAgIHtjbHM6IFsnbmVvLWJ1dHRvbi1yaXBwbGUtd3JhcHBlciddLCBjbjogW1xuICAgICAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1idXR0b24tcmlwcGxlJ119XG4gICAgICAgICAgICAgICAgXX0sXG4gICAgICAgICAgICB7Y2xzOiBbJ25lby10YWItYnV0dG9uLWluZGljYXRvciddfVxuICAgICAgICBdfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcHJlc3NlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFByZXNzZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0UHJlc3NlZCh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBtZS52ZG9tWydhcmlhLXNlbGVjdGVkJ10gPSB0cnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgbWUudmRvbVsnYXJpYS1zZWxlY3RlZCddXG4gICAgICAgIH1cblxuICAgICAgICBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdXNlQWN0aXZlVGFiSW5kaWNhdG9yIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VXNlQWN0aXZlVGFiSW5kaWNhdG9yKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZVVzZUFjdGl2ZVRhYkluZGljYXRvcigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBzaG93UmlwcGxlKGRhdGEpIHtcbiAgICAgICAgIXRoaXMucHJlc3NlZCAmJiBzdXBlci5zaG93UmlwcGxlKGRhdGEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaWxlbnQ9ZmFsc2VcbiAgICAgKi9cbiAgICB1cGRhdGVVc2VBY3RpdmVUYWJJbmRpY2F0b3Ioc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUudmRvbS5jbls0XS5yZW1vdmVEb20gPSAhbWUudXNlQWN0aXZlVGFiSW5kaWNhdG9yO1xuICAgICAgICAhc2lsZW50ICYmIG1lLnVwZGF0ZSgpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhCdXR0b24pO1xuIiwiaW1wb3J0IEJhc2VUb29sYmFyIGZyb20gJy4uLy4uL3Rvb2xiYXIvQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8udGFiLmhlYWRlci5Ub29sYmFyXG4gKiBAZXh0ZW5kcyBOZW8udG9vbGJhci5CYXNlXG4gKi9cbmNsYXNzIFRvb2xiYXIgZXh0ZW5kcyBCYXNlVG9vbGJhciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8udGFiLmhlYWRlci5Ub29sYmFyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8udGFiLmhlYWRlci5Ub29sYmFyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3RhYi1oZWFkZXItdG9vbGJhcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICd0YWItaGVhZGVyLXRvb2xiYXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tdGFiLWhlYWRlci10b29sYmFyJywnbmVvLXRvb2xiYXInXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tdGFiLWhlYWRlci10b29sYmFyJywgJ25lby10b29sYmFyJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB1c2VBY3RpdmVUYWJJbmRpY2F0b3JfPXRydWVcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB1c2VBY3RpdmVUYWJJbmRpY2F0b3JfOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBsb2FkU29ydFpvbmVNb2R1bGUoKSB7XG4gICAgICAgIHJldHVybiBpbXBvcnQoJy4uLy4uL2RyYWdnYWJsZS90YWIvaGVhZGVyL3Rvb2xiYXIvU29ydFpvbmUubWpzJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHVzZUFjdGl2ZVRhYkluZGljYXRvciBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFVzZUFjdGl2ZVRhYkluZGljYXRvcih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIG1lLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gc2lsZW50IHVwZGF0ZXNcbiAgICAgICAgICAgICAgICBpdGVtLl91c2VBY3RpdmVUYWJJbmRpY2F0b3IgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpdGVtLnVwZGF0ZVVzZUFjdGl2ZVRhYkluZGljYXRvcih0cnVlKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY3JlYXRlSXRlbXMoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBkZWZhdWx0cyA9IG1lLml0ZW1EZWZhdWx0cyB8fCB7fTtcblxuICAgICAgICBkZWZhdWx0cy51c2VBY3RpdmVUYWJJbmRpY2F0b3IgPSBtZS51c2VBY3RpdmVUYWJJbmRpY2F0b3I7XG4gICAgICAgIG1lLml0ZW1EZWZhdWx0cyA9IGRlZmF1bHRzO1xuXG4gICAgICAgIHN1cGVyLmNyZWF0ZUl0ZW1zKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsYXlvdXQgY29uZmlnIG1hdGNoaW5nIHRvIHRoZSBkb2NrIHBvc2l0aW9uXG4gICAgICogQHJldHVybnMge09iamVjdH0gbGF5b3V0Q29uZmlnXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGdldExheW91dENvbmZpZygpIHtcbiAgICAgICAgbGV0IGxheW91dENvbmZpZztcblxuICAgICAgICBzd2l0Y2ggKHRoaXMuZG9jaykge1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgbGF5b3V0Q29uZmlnID0ge1xuICAgICAgICAgICAgICAgICAgICBhbGlnbiAgICA6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdyb3cnLFxuICAgICAgICAgICAgICAgICAgICBwYWNrICAgICA6ICdzdGFydCdcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICBsYXlvdXRDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgICAgIGFsaWduICAgIDogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2NvbHVtbi1yZXZlcnNlJyxcbiAgICAgICAgICAgICAgICAgICAgcGFjayAgICAgOiAnZW5kJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICBsYXlvdXRDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgICAgIGFsaWduICAgIDogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgICAgICAgICAgICAgICAgIHBhY2sgICAgIDogJ3N0YXJ0J1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsYXlvdXRDb25maWdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhbiBleGlzdGluZyBpdGVtIHRvIGEgbmV3IGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZyb21JbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0b0luZGV4XG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZX1cbiAgICAgKi9cbiAgICBtb3ZlVG8oZnJvbUluZGV4LCB0b0luZGV4KSB7XG4gICAgICAgIGxldCByZXR1cm5WYWx1ZSA9IHN1cGVyLm1vdmVUbyhmcm9tSW5kZXgsIHRvSW5kZXgpO1xuXG4gICAgICAgIGlmIChmcm9tSW5kZXggIT09IHRvSW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBpdGVtLmluZGV4ID0gaW5kZXhcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWVcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFRvb2xiYXIpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==