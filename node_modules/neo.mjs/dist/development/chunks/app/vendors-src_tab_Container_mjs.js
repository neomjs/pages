"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_tab_Container_mjs"],{

/***/ "./src/tab/BodyContainer.mjs":
/*!***********************************!*\
  !*** ./src/tab/BodyContainer.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");


/**
 * @class Neo.tab.BodyContainer
 * @extends Neo.container.Base
 */
class BodyContainer extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.tab.BodyContainer'
         * @protected
         */
        className: 'Neo.tab.BodyContainer',
        /**
         * @member {String[]} baseCls=['neo-tab-body-container','neo-container']
         * @protected
         */
        baseCls: ['neo-tab-body-container', 'neo-container']
    }

    /**
     * When adding an existing tab into a different container, it will get automatically from the closest parent.
     * In this case, we also want to remove the tab.header.Button from the tab.header.Toolbar.
     * Use case: SharedCovid.view.MainContainerController
     * @param {Neo.component.Base} component
     * @param {Boolean} [destroyItem=true]
     * @param {Boolean} [silent=false]
     * @returns {Neo.component.Base|null}
     */
    remove(component, destroyItem, silent) {
        if (component?.isTab) {
            this.parent.remove(component, destroyItem, silent)
        } else {
            super.remove(component, destroyItem, silent)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(BodyContainer));


/***/ }),

/***/ "./src/tab/Container.mjs":
/*!*******************************!*\
  !*** ./src/tab/Container.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _BodyContainer_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BodyContainer.mjs */ "./src/tab/BodyContainer.mjs");
/* harmony import */ var _header_Button_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./header/Button.mjs */ "./src/tab/header/Button.mjs");
/* harmony import */ var _header_Toolbar_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./header/Toolbar.mjs */ "./src/tab/header/Toolbar.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _Strip_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Strip.mjs */ "./src/tab/Strip.mjs");







/**
 * @summary Manages a tabbed interface with a header toolbar and a content body.
 *
 * This class acts as the main orchestrator for a tabbed view. It uses a flexbox layout to arrange its
 * two primary children: a `Neo.tab.header.Toolbar` for the tab buttons and a `Neo.tab.BodyContainer`.
 * The `BodyContainer` is configured with a `card` layout. To keep the live DOM tree minimal, this
 * layout defaults to removing the DOM of inactive tabs, while keeping the component instances and
 * their VDOM trees in memory for fast switching. This behavior can be changed via the `removeInactiveCards` config.
 *
 * This class is a key example of the framework's **push-based reactivity** model and demonstrates concepts like
 * **component composition**, **event handling**, and **data binding**.
 *
 * @see Neo.examples.tab.Container
 * @class Neo.tab.Container
 * @extends Neo.container.Base
 */
class Container extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for tabBarPosition
     * @member {String[]} tabBarPositions=['top','right','bottom','left']
     * @protected
     * @static
     */
    static tabBarPositions = ['top', 'right', 'bottom', 'left']

    static config = {
        /**
         * @member {String} className='Neo.tab.Container'
         * @protected
         */
        className: 'Neo.tab.Container',
        /**
         * @member {String} ntype='tab-container'
         * @protected
         */
        ntype: 'tab-container',
        /**
         * You can use null to not mount any items initially
         * @member {Number|null} activeIndex_=0
         * @reactive
         */
        activeIndex_: 0,
        /**
         * True will activate a tab which gets dynamically inserted / added after the TabContainer is mounted
         * @member {Boolean} activateInsertedTabs=false
         */
        activateInsertedTabs: false,
        /**
         * @member {String[]} baseCls=['neo-tab-container'],
         * @protected
         */
        baseCls: ['neo-tab-container'],
        /**
         * Default configs for the tab.BodyContainer
         * @member {Object|null} bodyContainer=null
         */
        bodyContainer: null,
        /**
         * @member {String|null} bodyContainerId=null
         */
        bodyContainerId: null,
        /**
         * Default configs for the tab.HeaderToolbar
         * @member {Object|null} headerToolbar=null
         */
        headerToolbar: null,
        /**
         * @member {Object|null} layout=null
         * @reactive
         */
        layout: null,
        /**
         * True to not apply a background effect to the tab header container
         * @member {Boolean} plain_=true
         * @reactive
         */
        plain_: true,
        /*
         * Remove the DOM of inactive cards (TabContainer Body).
         * This will keep the instances & vdom trees
         * @member {Boolean} removeInactiveCards=true
         */
        removeInactiveCards: true,
        /**
         * true enables sorting tabs via drag&drop.
         * The config gets passed to the header toolbar
         * @member {Boolean} sortable_=false
         * @reactive
         */
        sortable_: false,
        /**
         * @member {String|null} tabBarId=null
         */
        tabBarId: null,
        /**
         * Default configs for the tab.Strip
         * @member {Object|null} tabStrip=null
         */
        tabStrip: null,
        /**
         * @member {String|null} tabStripId=null
         */
        tabStripId: null,
        /**
         * The position of the tab header toolbar.
         * Valid values are top, right, bottom, left.
         * @member {String} tabBarPosition_='top'
         * @reactive
         */
        tabBarPosition_: 'top',
        /**
         * adds tabContainerCls + '-plain' is case plain is set to true
         * @member {String} tabContainerCls='neo-tab-container'
         */
        tabContainerCls: 'neo-tab-container',
        /**
         * @member {Boolean} useActiveTabIndicator_=true
         * @reactive
         */
        useActiveTabIndicator_: true
    }

    /**
     * Adds one or more tab items to the end of the container.
     * @param {Object|Object[]} item The configuration object for a new tab or an array of such objects.
     * @returns {Neo.component.Base|Neo.component.Base[]} The newly created component(s).
     */
    add(item) {
        return this.insert(this.getTabBar().items.length, item)
    }

    /**
     * Handles the logic after the `activeIndex` config has changed. It ensures that the
     * layout of the `BodyContainer` is updated to show the correct card and fires the
     * `activeIndexChange` event.
     * @param {Number|null} value The new active index.
     * @param {Number|null} oldValue The previous active index.
     * @protected
     */
     async afterSetActiveIndex(value, oldValue) {
        let me            = this,
            cardContainer = Neo.getComponent(me.bodyContainerId);

        if (Neo.isNumber(value) && value > -1 && !cardContainer) {
            me.on('constructed', () => {
                me.afterSetActiveIndex(value, oldValue)
            }, me, {once: true})
        } else {
            if (Neo.isNumber(value) && value > -1) {
                // we need to ensure the afterSet method triggers when lazy loading the module
                cardContainer.layout._activeIndex = value;
                await cardContainer.layout.afterSetActiveIndex(value, oldValue);

                if (oldValue !== undefined) {
                    me.updateTabButtons();

                    me.fire('activeIndexChange', {
                        item: me.getActiveCard(),
                        oldValue,
                        value
                    })
                }
            }
        }
    }

    /**
     * Applies or removes the plain CSS class when the `plain` config changes.
     * @param {Boolean} value The new value for `plain`.
     * @param {Boolean} oldValue The old value for `plain`.
     * @protected
     */
    afterSetPlain(value, oldValue) {
        let me    = this,
            {cls} = me;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"][value ? 'unshift' : 'remove'](cls, me.tabContainerCls + '-plain');
        me.cls = cls
    }

    /**
     * Passes the `sortable` config down to the `HeaderToolbar` instance.
     * @param {Boolean} value The new value for `sortable`.
     * @param {Boolean} oldValue The old value for `sortable`.
     * @protected
     */
    afterSetSortable(value, oldValue) {
        if (oldValue !== undefined) {
            this.getTabBar().sortable = value
        }
    }

    /**
     * Adjusts the container's layout and CSS classes when the tab bar position changes.
     * This method ensures that the `HeaderToolbar` is docked correctly and that the overall
     * flexbox layout direction is updated to accommodate the new position (e.g., row for left/right,
     * column for top/bottom).
     * @param {String} value The new tab bar position ('top', 'right', 'bottom', 'left').
     * @param {String} oldValue The old tab bar position.
     * @protected
     */
    afterSetTabBarPosition(value, oldValue) {
        let me    = this,
            {cls} = me;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].remove(cls, 'neo-' + oldValue);
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].add(cls, 'neo-' + value);
        me.setSilent({cls});

        if (me.vnodeInitialized) {
            me.layout.setSilent(me.getLayoutConfig());
            me.getTabBar().setSilent({dock: value});
            me.getTabStrip().setSilent({cls: ['neo-tab-strip',  'neo-dock-' + value]});

            me.updateDepth = 2;

            me.fire('tabBarPositionChange', {
                component: me,
                oldValue,
                value
            })
        }

        me.update()
    }

    /**
     * Passes the `useActiveTabIndicator` config down to the `HeaderToolbar` and `Strip` instances.
     * @param {Boolean} value The new value for `useActiveTabIndicator`.
     * @param {Boolean} oldValue The old value for `useActiveTabIndicator`.
     * @protected
     */
    afterSetUseActiveTabIndicator(value, oldValue) {
        if (oldValue !== undefined) {
            this.getTabBar()  .useActiveTabIndicator = value;
            this.getTabStrip().useActiveTabIndicator = value
        }
    }

    /**
     * Validates the new value for the `tabBarPosition` config.
     * @param {String} value The new value.
     * @param {String} oldValue The old value.
     * @protected
     * @returns {String} The validated value.
     */
    beforeSetTabBarPosition(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'tabBarPosition')
    }

    /**
     * Overrides the base `createItems` lifecycle method to construct the specific component
     * hierarchy required for a tab container. It transforms the user-provided `items` array
     * into the three core child components: `HeaderToolbar`, `Strip`, and `BodyContainer`.
     * @protected
     */
    createItems() {
        let me            = this,
            {activeIndex, removeInactiveCards, useActiveTabIndicator} = me,
            items         = me.items || [],
            tabButtons    = [],
            tabComponents = [];

        Object.assign(me, {
            bodyContainerId: me.bodyContainerId || Neo.getId('container'),
            tabBarId       : me.tabBarId        || Neo.getId('tab-header-toolbar'),
            tabStripId     : me.tabStripId      || Neo.getId('tab-strip')
        });

        items.forEach((item, index) => {
            tabButtons.push(me.getTabButtonConfig(item.header, index));

            if (!(item instanceof Neo.component.Base)) {
                item = {flex: 1, ...me.itemDefaults, isTab: true, ...item}
            }

            tabComponents.push(item)
        });

        me.items = [{
            module  : _header_Toolbar_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
            dock    : me.tabBarPosition,
            flex    : 'none',
            id      : me.tabBarId,
            items   : tabButtons,
            sortable: me.sortable,
            useActiveTabIndicator,
            ...me.headerToolbar
        }, {
            module        : _Strip_mjs__WEBPACK_IMPORTED_MODULE_5__["default"],
            cls           : ['neo-dock-' + me.tabBarPosition],
            flex          : 'none',
            id            : me.tabStripId,
            tabContainerId: me.id,
            useActiveTabIndicator,
            ...me.tabStrip
        }, {
            module      : _BodyContainer_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            id          : me.bodyContainerId,
            itemDefaults: me.itemDefaults,
            items       : tabComponents,
            layout      : {ntype: 'card', activeIndex, removeInactiveCards},
            useActiveTabIndicator,
            ...me.bodyContainer
        }];

        me.itemDefaults = null;

        super.createItems()
    }

    /**
     * Retrieves the component instance for the currently active tab.
     * @returns {Neo.component.Base|null} The active card component or null if none is active.
     */
    getActiveCard() {
        return this.getCardContainer()?.items[this.activeIndex] || null
    }

    /**
     * Retrieves the component instance for a tab at a specific index.
     * @param {Number} index The index of the card to retrieve.
     * @returns {Neo.component.Base|null} The card component or null if not found.
     */
    getCard(index) {
        return this.getCardContainer()?.items[index] || null
    }

    /**
     * A convenience method to get the `BodyContainer` instance that holds the tab content cards.
     * @returns {Neo.container.Base} The body container instance.
     */
    getCardContainer() {
        return Neo.getComponent(this.bodyContainerId)
    }

    /**
     * Returns the total number of tabs in the container.
     * @returns {Number} The number of tabs.
     */
    getCount() {
        return this.getTabBar().items.length
    }

    /**
     * Generates the appropriate flexbox layout configuration based on the current `tabBarPosition`.
     * For example, a 'top' or 'bottom' position requires a vertical layout, while 'left' or 'right'
     * requires a horizontal one.
     * @returns {Object} The flexbox layout configuration object.
     * @protected
     */
    getLayoutConfig() {
        let layoutMap = {
            bottom: {
                align    : 'stretch',
                direction: 'column-reverse',
                pack     : 'start'
            },
            left: {
                align    : 'stretch',
                direction: 'row',
                pack     : 'start'
            },
            right: {
                align    : 'stretch',
                direction: 'row-reverse',
                pack     : 'start'
            },
            top: {
                align    : 'stretch',
                direction: 'column',
                pack     : 'start'
            }
        };

        return layoutMap[this.tabBarPosition] || null
    }

    /**
     * Retrieves the `HeaderButton` instance for a tab at a specific index.
     * @param {Number} index The index of the tab button to retrieve.
     * @returns {Neo.tab.header.Button|null} The tab button component or null if not found.
     */
    getTabAtIndex(index) {
        return this.getTabBar().items[index] || null
    }

    /**
     * A convenience method to get the `HeaderToolbar` instance that holds the tab buttons.
     * @returns {Neo.toolbar.Base} The header toolbar instance.
     */
    getTabBar() {
        return Neo.getComponent(this.tabBarId)
    }

    /**
     * Creates the configuration object for a single tab button. It merges a default configuration
     * (including the module, index, and a click listener to change `activeIndex`) with the
     * user-provided configuration from the item's `header` property.
     * @param {Object} config The user-provided configuration from `item.header`.
     * @param {Number} index The index of this tab button.
     * @returns {Object} The merged configuration object for the tab button.
     * @protected
     */
    getTabButtonConfig(config, index) {
        let me = this,

        defaultConfig = {
            module : _header_Button_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            flex   : 'none',
            index  : index,
            pressed: me.activeIndex === index,

            domListeners: [{
                click(data) {
                    me.activeIndex = data.component.index
                },
                scope: me
            }]
        };

        return {...defaultConfig, ...config}
    }

    /**
     * A convenience method to get the `Strip` instance, which is responsible for rendering
     * the active tab indicator.
     * @returns {Neo.tab.Strip} The strip instance.
     */
    getTabStrip() {
        return Neo.getComponent(this.tabStripId)
    }

    /**
     * Inserts one or more tab items at a specific index.
     * @param {Number} index The index at which to insert the new item(s).
     * @param {Object|Object[]} item The configuration object for a new tab or an array of such objects.
     * @param {Boolean} [silent=false] Set to true to prevent `updateTabButtons` from being called.
     * @returns {Neo.component.Base|Neo.component.Base[]} The newly created component(s).
     */
    insert(index, item, silent=false) {
        let me            = this,
            cardContainer = me.getCardContainer(),
            tabBar        = me.getTabBar(),
            hasItem       = false,
            i, len, returnArray, superItem, tab;

        if (Array.isArray(item)) {
            i           = 0;
            len         = item.length;
            returnArray = [];

            for (; i < len; i++) {
                // insert the array backwards
                returnArray.unshift(me.insert(index, item[len - 1 - i], true))
            }

            superItem = returnArray;
        } else if (typeof item === 'object') {
            i   = 0;
            len = cardContainer.items.length;

            for (; i < len; i++) {
                if (cardContainer.items[i].id === item.id) {
                    hasItem   = true;
                    superItem = cardContainer.items[i];

                    if (me.activateInsertedTabs) {
                        me.activeIndex = i
                    }

                    break
                }
            }

            if (!hasItem) {
                tab = tabBar.insert(index, me.getTabButtonConfig(item.header, index));

                // todo: non index based matching of tab buttons and cards
                i = 0;
                len = tabBar.items.length;

                for (; i < len; i++) {
                    tabBar.items[i].index = i
                }

                item.flex = 1;
                superItem = cardContainer.insert(index, item, silent);

                if (me.activateInsertedTabs) {
                    if (!me.vnode) {
                        me.activeIndex = index
                    } else {
                        tab.on('mounted', me.onTabButtonMounted, me)
                    }
                }
            }
        }

        !silent && me.updateTabButtons();

        return superItem
    }

    /**
     * Moves an existing tab (both its button and its card) from one index to another.
     * This is primarily used for drag-and-drop reordering.
     * @param {Number} fromIndex The original index of the tab.
     * @param {Number} toIndex The new index for the tab.
     * @returns {Neo.component.Base} The card component that was moved.
     */
    moveTo(fromIndex, toIndex) {
        let me            = this,
            cardContainer = me.getCardContainer(),
            tabBar        = me.getTabBar(),
            activeTab     = tabBar.items[me.activeIndex],
            index, returnValue;

        tabBar.moveTo(fromIndex, toIndex);
        index = activeTab.index;

        if (index !== me.activeIndex) {
            // silent updates
            me._activeIndex = index;
            cardContainer.layout._activeIndex = index
        }

        returnValue = cardContainer.moveTo(fromIndex, toIndex);

        me.fire('moveTo', {
            fromIndex,
            toIndex
        });

        return returnValue
    }

    /**
     * Overrides the base `onConstructed` lifecycle method to apply the initial flexbox layout
     * configuration after the main construction process is complete.
     * @protected
     */
    onConstructed() {
        this.layout = {ntype: 'flexbox', ...this.getLayoutConfig()};
        super.onConstructed()
    }

    /**
     * A handler that is triggered when a dynamically added tab button is mounted to the DOM.
     * If `activateInsertedTabs` is true, this method ensures that the `activeIndex` is set
     * correctly after the new tab's corresponding card is also mounted.
     * @param {String} buttonId The ID of the mounted button.
     * @protected
     */
    onTabButtonMounted(buttonId) {
        let me            = this,
            cardContainer = me.getCardContainer(),
            tabBar        = me.getTabBar(),
            i             = 0,
            len           = tabBar.items.length,
            index         = -1,
            card;

        for (; i < len; i++) {
            if (tabBar.items[i].id === buttonId) {
                index = i;
                break
            }
        }

        if (index > -1) {
            card = cardContainer.items[index];

            if (me.vnode && !card.mounted) {
                card.on('mounted', () => {
                    me.activeIndex = index
                }, me, {once: true})
            } else {
                me.activeIndex = index
            }
        }
    }

    /**
     * Removes a tab from the container using a reference to the card component.
     * @param {Neo.component.Base} component The card component instance to remove.
     * @param {Boolean} [destroyItem=true] Set to false to keep the component instance in memory.
     * @param {Boolean} [silent=false] Set to true to prevent `updateTabButtons` from being called.
     */
    remove(component, destroyItem=true, silent=false) {
        let items = [...this.getCardContainer().items],
            i     = 0,
            len   = items.length;

        for (; i < len; i++) {
            if (items[i].id === component.id) {
                this.removeAt(i, destroyItem, silent)
            }
        }
    }

    /**
     * Removes a tab from the container at a specific index.
     * @param {Number} index The index of the tab to remove.
     * @param {Boolean} [destroyItem=true] Set to false to keep the component instance in memory.
     * @param {Boolean} [silent=false] Set to true to prevent `updateTabButtons` from being called.
     */
    removeAt(index, destroyItem=true, silent=false) {
        let me            = this,
            {activeIndex} = me,
            cardContainer = me.getCardContainer(),
            tabBar        = me.getTabBar(),
            i, len;

        cardContainer.removeAt(index, destroyItem, silent);
        tabBar       .removeAt(index, true,        false);

        if (index < activeIndex) {
            // silent updates
            me._activeIndex = activeIndex - 1;
            cardContainer.layout._activeIndex = activeIndex - 1
        } else if (index === activeIndex) {
            me.activeIndex = activeIndex - 1
        }

        // todo: non index based matching of tab buttons and cards
        i   = 0;
        len = tabBar.items.length;

        for (; i < len; i++) {
            tabBar.items[i].index = i
        }
    }

    /**
     * Synchronizes the `pressed` state of all tab buttons with the container's `activeIndex`.
     * This ensures that only the button corresponding to the active tab appears pressed.
     * @protected
     */
    updateTabButtons() {
        let me            = this,
            {activeIndex} = me,
            tabButtons    = me.getTabBar()?.items || [];

        tabButtons.forEach((item, index) => {
            item.pressed = index === activeIndex
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Container));


/***/ }),

/***/ "./src/tab/Strip.mjs":
/*!***************************!*\
  !*** ./src/tab/Strip.mjs ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");


/**
 * @class Neo.tab.Strip
 * @extends Neo.component.Base
 */
class Strip extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.tab.Strip'
         * @protected
         */
        className: 'Neo.tab.Strip',
        /**
         * @member {String} ntype='tab-strip'
         * @protected
         */
        ntype: 'tab-strip',
        /**
         * @member {String[]} baseCls=['neo-tab-strip']
         */
        baseCls: ['neo-tab-strip'],
        /**
         * @member {String|null} tabContainerId=null
         */
        tabContainerId: null,
        /**
         * @member {Boolean} useActiveTabIndicator_=true
         * @reactive
         */
        useActiveTabIndicator_: true,
        /**
         * @member {Object} _vdom={cn: [{cls: 'neo-active-tab-indicator'}]}
         */
        _vdom:
        {cn: [
            {cls: ['neo-active-tab-indicator']}
        ]}
    }

    /**
     * Triggered after the useActiveTabIndicator config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetUseActiveTabIndicator(value, oldValue) {
        this.vdom.cn[0].removeDom = !value;
        this.update()
    }

    /**
     * Gets the DomRect of the active tab, then moves the indicator
     * @param {Object|null} opts
     * @param {Number} opts.oldValue
     * @param {Number} opts.value
     */
    getActiveTabRectThenMove(opts) {
        let me           = this,
            ids          = [me.id],
            tabContainer = me.getTabContainer(),
            oldTab;

        // We do not need a movement, in case there is no oldValue
        if (me.useActiveTabIndicator && me.vnode && Neo.isNumber(opts?.oldValue)) {
            oldTab = tabContainer.getTabAtIndex(opts.oldValue);

            // The activeIndexChange event can get triggered when removing the currently active tab,
            // In this case, we can no longer access the related DOMRect and need to opt out.
            if (oldTab) {
                ids.push(tabContainer.getTabAtIndex(opts.value).id, oldTab.id);

                me.getDomRect(ids).then(data => {
                    me.moveActiveIndicator(data)
                })
            }
        }
    }

    /**
     *
     */
    getTabContainer() {
        return Neo.getComponent(this.tabContainerId)
    }

    /**
     * Can either contain the new target rect or the new and old one
     * @param {Object[]} rects
     * @param {Number} rects[0].bottom
     * @param {Number} rects[0].height
     * @param {Number} rects[0].left
     * @param {Number} rects[0].right
     * @param {Number} rects[0].top
     * @param {Number} rects[0].width
     * @param {Number} rects[0].x
     * @param {Number} rects[0].y
     */
    moveActiveIndicator(rects) {
        let me           = this,
            tabStripRect = rects.shift(),
            rect         = rects[1] || rects[0],
            activeTabIndicator, tabContainer;

        if (me.useActiveTabIndicator) {
            activeTabIndicator = me.vdom.cn[0];
            tabContainer       = me.getTabContainer();

            switch (tabContainer.tabBarPosition) {
                case 'bottom':
                case 'top':
                    activeTabIndicator.style = {
                        height: null,
                        left  : `${rect.left - tabStripRect.left}px`,
                        top   : null,
                        width : `${rect.width}px`
                    };
                    break
                case 'left':
                case 'right':
                    activeTabIndicator.style = {
                        height: `${rect.height}px`,
                        left  : null,
                        top   : `${rect.top - tabStripRect.top}px`,
                        width : null
                    };
                    break
            }

            // in case there is a dynamic change (oldValue), call this method again
            if (rects[1]) {
                activeTabIndicator.style.opacity = 0;
                me.update();

                me.timeout(50).then(() => {
                    me.moveActiveIndicator([tabStripRect, rects[0]])
                })
            } else {
                activeTabIndicator.style.opacity = 1;
                me.update();

                me.timeout(300).then(() => {
                    activeTabIndicator.style.opacity = 0;
                    me.update()
                })
            }
        }
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me = this;

        me.getTabContainer().on({
            activeIndexChange: me.getActiveTabRectThenMove,
            scope            : me
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Strip));


/***/ }),

/***/ "./src/tab/header/Button.mjs":
/*!***********************************!*\
  !*** ./src/tab/header/Button.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../button/Base.mjs */ "./src/button/Base.mjs");


/**
 * @class Neo.tab.header.Button
 * @extends Neo.button.Base
 */
class Button extends _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.tab.header.Button'
         * @protected
         */
        className: 'Neo.tab.header.Button',
        /**
         * @member {String} ntype='tab-header-button'
         * @protected
         */
        ntype: 'tab-header-button',
        /**
         * @member {String[]} baseCls=['neo-button','neo-tab-button']
         */
        baseCls: ['neo-tab-header-button', 'neo-button'],
        /**
         * Specify a role tag attribute for the vdom root.
         * @member {String|null} role='tab'
         * @reactive
         */
        role: 'tab',
        /**
         * @member {Boolean} useActiveTabIndicator_=true
         * @reactive
         */
        useActiveTabIndicator_: true,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {tag: 'button', cn: [
            {tag: 'span', cls: ['neo-button-glyph']},
            {tag: 'span', cls: ['neo-button-text']},
            {cls: ['neo-button-badge']},
            {cls: ['neo-button-ripple-wrapper'], cn: [
                    {cls: ['neo-button-ripple']}
                ]},
            {cls: ['neo-tab-button-indicator']}
        ]}
    }

    /**
     * Triggered after the pressed config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetPressed(value, oldValue) {
        super.afterSetPressed(value, oldValue);

        let me = this;

        if (value) {
            me.vdom['aria-selected'] = true
        } else {
            delete me.vdom['aria-selected']
        }

        me.update()
    }

    /**
     * Triggered after the useActiveTabIndicator config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetUseActiveTabIndicator(value, oldValue) {
        this.updateUseActiveTabIndicator()
    }

    /**
     * @param {Object} data
     */
    showRipple(data) {
        !this.pressed && super.showRipple(data)
    }

    /**
     * @param {Boolean} silent=false
     */
    updateUseActiveTabIndicator(silent=false) {
        let me = this;

        me.vdom.cn[4].removeDom = !me.useActiveTabIndicator;
        !silent && me.update()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Button));


/***/ }),

/***/ "./src/tab/header/Toolbar.mjs":
/*!************************************!*\
  !*** ./src/tab/header/Toolbar.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../toolbar/Base.mjs */ "./src/toolbar/Base.mjs");


/**
 * @class Neo.tab.header.Toolbar
 * @extends Neo.toolbar.Base
 */
class Toolbar extends _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.tab.header.Toolbar'
         * @protected
         */
        className: 'Neo.tab.header.Toolbar',
        /**
         * @member {String} ntype='tab-header-toolbar'
         * @protected
         */
        ntype: 'tab-header-toolbar',
        /**
         * @member {String[]} baseCls=['neo-tab-header-toolbar','neo-toolbar']
         */
        baseCls: ['neo-tab-header-toolbar', 'neo-toolbar'],
        /**
         * @member {Boolean} useActiveTabIndicator_=true
         * @reactive
         */
        useActiveTabIndicator_: true
    }

    /**
     * Triggered after the sortable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetSortable(value, oldValue) {
        let me = this;

        if (value && !me.sortZone) {
            Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("vendors-src_draggable_container_SortZone_mjs"), __webpack_require__.e("src_draggable_tab_header_toolbar_SortZone_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ../../draggable/tab/header/toolbar/SortZone.mjs */ "./src/draggable/tab/header/toolbar/SortZone.mjs")).then(module => {
                let {appName, id, windowId} = me;

                me.sortZone = Neo.create({
                    module             : module.default,
                    appName,
                    boundaryContainerId: id,
                    owner              : me,
                    windowId,
                    ...me.sortZoneConfig
                })
            })
        }
    }

    /**
     * Triggered after the useActiveTabIndicator config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetUseActiveTabIndicator(value, oldValue) {
        if (oldValue !== undefined) {
            let me = this;

            me.items.forEach(item => {
                // silent updates
                item._useActiveTabIndicator = value;
                item.updateUseActiveTabIndicator(true)
            });

            me.update()
        }
    }

    /**
     * @protected
     */
    createItems() {
        let me       = this,
            defaults = me.itemDefaults || {};

        defaults.useActiveTabIndicator = me.useActiveTabIndicator;
        me.itemDefaults = defaults;

        super.createItems()
    }

    /**
     * Returns the layout config matching to the dock position
     * @returns {Object} layoutConfig
     * @protected
     */
    getLayoutConfig() {
        let layoutConfig;

        switch (this.dock) {
            case 'bottom':
            case 'top':
                layoutConfig = {
                    align    : 'center',
                    direction: 'row',
                    pack     : 'start'
                };
                break
            case 'left':
                layoutConfig = {
                    align    : 'center',
                    direction: 'column-reverse',
                    pack     : 'end'
                };
                break
            case 'right':
                layoutConfig = {
                    align    : 'center',
                    direction: 'column',
                    pack     : 'start'
                };
                break
        }

        return layoutConfig
    }

    /**
     * Moves an existing item to a new index
     * @param {Number} fromIndex
     * @param {Number} toIndex
     * @returns {Neo.component.Base}
     */
    moveTo(fromIndex, toIndex) {
        let returnValue = super.moveTo(fromIndex, toIndex);

        if (fromIndex !== toIndex) {
            this.items.forEach((item, index) => {
                item.index = index
            })
        }

        return returnValue
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Toolbar));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY190YWJfQ29udGFpbmVyX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUE4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkRBQVM7QUFDckM7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSw2QkFBNkIsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdENLO0FBQ0Y7QUFDQTtBQUNDO0FBQ0g7QUFDTjs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkRBQWE7QUFDckM7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSx1QkFBdUIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvdGFiL0JvZHlDb250YWluZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdGFiL0NvbnRhaW5lci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy90YWIvU3RyaXAubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdGFiL2hlYWRlci9CdXR0b24ubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdGFiL2hlYWRlci9Ub29sYmFyLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ29udGFpbmVyIGZyb20gJy4uL2NvbnRhaW5lci9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby50YWIuQm9keUNvbnRhaW5lclxuICogQGV4dGVuZHMgTmVvLmNvbnRhaW5lci5CYXNlXG4gKi9cbmNsYXNzIEJvZHlDb250YWluZXIgZXh0ZW5kcyBDb250YWluZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnRhYi5Cb2R5Q29udGFpbmVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8udGFiLkJvZHlDb250YWluZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tdGFiLWJvZHktY29udGFpbmVyJywnbmVvLWNvbnRhaW5lciddXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLXRhYi1ib2R5LWNvbnRhaW5lcicsICduZW8tY29udGFpbmVyJ11cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGFkZGluZyBhbiBleGlzdGluZyB0YWIgaW50byBhIGRpZmZlcmVudCBjb250YWluZXIsIGl0IHdpbGwgZ2V0IGF1dG9tYXRpY2FsbHkgZnJvbSB0aGUgY2xvc2VzdCBwYXJlbnQuXG4gICAgICogSW4gdGhpcyBjYXNlLCB3ZSBhbHNvIHdhbnQgdG8gcmVtb3ZlIHRoZSB0YWIuaGVhZGVyLkJ1dHRvbiBmcm9tIHRoZSB0YWIuaGVhZGVyLlRvb2xiYXIuXG4gICAgICogVXNlIGNhc2U6IFNoYXJlZENvdmlkLnZpZXcuTWFpbkNvbnRhaW5lckNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZGVzdHJveUl0ZW09dHJ1ZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdXG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZXxudWxsfVxuICAgICAqL1xuICAgIHJlbW92ZShjb21wb25lbnQsIGRlc3Ryb3lJdGVtLCBzaWxlbnQpIHtcbiAgICAgICAgaWYgKGNvbXBvbmVudD8uaXNUYWIpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LnJlbW92ZShjb21wb25lbnQsIGRlc3Ryb3lJdGVtLCBzaWxlbnQpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdXBlci5yZW1vdmUoY29tcG9uZW50LCBkZXN0cm95SXRlbSwgc2lsZW50KVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhCb2R5Q29udGFpbmVyKTtcbiIsImltcG9ydCBCYXNlQ29udGFpbmVyIGZyb20gJy4uL2NvbnRhaW5lci9CYXNlLm1qcyc7XG5pbXBvcnQgQm9keUNvbnRhaW5lciBmcm9tICcuL0JvZHlDb250YWluZXIubWpzJztcbmltcG9ydCBIZWFkZXJCdXR0b24gIGZyb20gJy4vaGVhZGVyL0J1dHRvbi5tanMnO1xuaW1wb3J0IEhlYWRlclRvb2xiYXIgZnJvbSAnLi9oZWFkZXIvVG9vbGJhci5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICAgICAgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IFN0cmlwICAgICAgICAgZnJvbSAnLi9TdHJpcC5tanMnO1xuXG4vKipcbiAqIEBzdW1tYXJ5IE1hbmFnZXMgYSB0YWJiZWQgaW50ZXJmYWNlIHdpdGggYSBoZWFkZXIgdG9vbGJhciBhbmQgYSBjb250ZW50IGJvZHkuXG4gKlxuICogVGhpcyBjbGFzcyBhY3RzIGFzIHRoZSBtYWluIG9yY2hlc3RyYXRvciBmb3IgYSB0YWJiZWQgdmlldy4gSXQgdXNlcyBhIGZsZXhib3ggbGF5b3V0IHRvIGFycmFuZ2UgaXRzXG4gKiB0d28gcHJpbWFyeSBjaGlsZHJlbjogYSBgTmVvLnRhYi5oZWFkZXIuVG9vbGJhcmAgZm9yIHRoZSB0YWIgYnV0dG9ucyBhbmQgYSBgTmVvLnRhYi5Cb2R5Q29udGFpbmVyYC5cbiAqIFRoZSBgQm9keUNvbnRhaW5lcmAgaXMgY29uZmlndXJlZCB3aXRoIGEgYGNhcmRgIGxheW91dC4gVG8ga2VlcCB0aGUgbGl2ZSBET00gdHJlZSBtaW5pbWFsLCB0aGlzXG4gKiBsYXlvdXQgZGVmYXVsdHMgdG8gcmVtb3ZpbmcgdGhlIERPTSBvZiBpbmFjdGl2ZSB0YWJzLCB3aGlsZSBrZWVwaW5nIHRoZSBjb21wb25lbnQgaW5zdGFuY2VzIGFuZFxuICogdGhlaXIgVkRPTSB0cmVlcyBpbiBtZW1vcnkgZm9yIGZhc3Qgc3dpdGNoaW5nLiBUaGlzIGJlaGF2aW9yIGNhbiBiZSBjaGFuZ2VkIHZpYSB0aGUgYHJlbW92ZUluYWN0aXZlQ2FyZHNgIGNvbmZpZy5cbiAqXG4gKiBUaGlzIGNsYXNzIGlzIGEga2V5IGV4YW1wbGUgb2YgdGhlIGZyYW1ld29yaydzICoqcHVzaC1iYXNlZCByZWFjdGl2aXR5KiogbW9kZWwgYW5kIGRlbW9uc3RyYXRlcyBjb25jZXB0cyBsaWtlXG4gKiAqKmNvbXBvbmVudCBjb21wb3NpdGlvbioqLCAqKmV2ZW50IGhhbmRsaW5nKiosIGFuZCAqKmRhdGEgYmluZGluZyoqLlxuICpcbiAqIEBzZWUgTmVvLmV4YW1wbGVzLnRhYi5Db250YWluZXJcbiAqIEBjbGFzcyBOZW8udGFiLkNvbnRhaW5lclxuICogQGV4dGVuZHMgTmVvLmNvbnRhaW5lci5CYXNlXG4gKi9cbmNsYXNzIENvbnRhaW5lciBleHRlbmRzIEJhc2VDb250YWluZXIge1xuICAgIC8qKlxuICAgICAqIFZhbGlkIHZhbHVlcyBmb3IgdGFiQmFyUG9zaXRpb25cbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gdGFiQmFyUG9zaXRpb25zPVsndG9wJywncmlnaHQnLCdib3R0b20nLCdsZWZ0J11cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyB0YWJCYXJQb3NpdGlvbnMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby50YWIuQ29udGFpbmVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8udGFiLkNvbnRhaW5lcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSd0YWItY29udGFpbmVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3RhYi1jb250YWluZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogWW91IGNhbiB1c2UgbnVsbCB0byBub3QgbW91bnQgYW55IGl0ZW1zIGluaXRpYWxseVxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gYWN0aXZlSW5kZXhfPTBcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBhY3RpdmVJbmRleF86IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIHdpbGwgYWN0aXZhdGUgYSB0YWIgd2hpY2ggZ2V0cyBkeW5hbWljYWxseSBpbnNlcnRlZCAvIGFkZGVkIGFmdGVyIHRoZSBUYWJDb250YWluZXIgaXMgbW91bnRlZFxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhY3RpdmF0ZUluc2VydGVkVGFicz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZhdGVJbnNlcnRlZFRhYnM6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tdGFiLWNvbnRhaW5lciddLFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby10YWItY29udGFpbmVyJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZhdWx0IGNvbmZpZ3MgZm9yIHRoZSB0YWIuQm9keUNvbnRhaW5lclxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gYm9keUNvbnRhaW5lcj1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBib2R5Q29udGFpbmVyOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGJvZHlDb250YWluZXJJZD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBib2R5Q29udGFpbmVySWQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZhdWx0IGNvbmZpZ3MgZm9yIHRoZSB0YWIuSGVhZGVyVG9vbGJhclxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gaGVhZGVyVG9vbGJhcj1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBoZWFkZXJUb29sYmFyOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGxheW91dD1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbGF5b3V0OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSB0byBub3QgYXBwbHkgYSBiYWNrZ3JvdW5kIGVmZmVjdCB0byB0aGUgdGFiIGhlYWRlciBjb250YWluZXJcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gcGxhaW5fPXRydWVcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBwbGFpbl86IHRydWUsXG4gICAgICAgIC8qXG4gICAgICAgICAqIFJlbW92ZSB0aGUgRE9NIG9mIGluYWN0aXZlIGNhcmRzIChUYWJDb250YWluZXIgQm9keSkuXG4gICAgICAgICAqIFRoaXMgd2lsbCBrZWVwIHRoZSBpbnN0YW5jZXMgJiB2ZG9tIHRyZWVzXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHJlbW92ZUluYWN0aXZlQ2FyZHM9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlSW5hY3RpdmVDYXJkczogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRydWUgZW5hYmxlcyBzb3J0aW5nIHRhYnMgdmlhIGRyYWcmZHJvcC5cbiAgICAgICAgICogVGhlIGNvbmZpZyBnZXRzIHBhc3NlZCB0byB0aGUgaGVhZGVyIHRvb2xiYXJcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc29ydGFibGVfPWZhbHNlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgc29ydGFibGVfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSB0YWJCYXJJZD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB0YWJCYXJJZDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmF1bHQgY29uZmlncyBmb3IgdGhlIHRhYi5TdHJpcFxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gdGFiU3RyaXA9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgdGFiU3RyaXA6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gdGFiU3RyaXBJZD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB0YWJTdHJpcElkOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBvc2l0aW9uIG9mIHRoZSB0YWIgaGVhZGVyIHRvb2xiYXIuXG4gICAgICAgICAqIFZhbGlkIHZhbHVlcyBhcmUgdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHRhYkJhclBvc2l0aW9uXz0ndG9wJ1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHRhYkJhclBvc2l0aW9uXzogJ3RvcCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhZGRzIHRhYkNvbnRhaW5lckNscyArICctcGxhaW4nIGlzIGNhc2UgcGxhaW4gaXMgc2V0IHRvIHRydWVcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB0YWJDb250YWluZXJDbHM9J25lby10YWItY29udGFpbmVyJ1xuICAgICAgICAgKi9cbiAgICAgICAgdGFiQ29udGFpbmVyQ2xzOiAnbmVvLXRhYi1jb250YWluZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gdXNlQWN0aXZlVGFiSW5kaWNhdG9yXz10cnVlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdXNlQWN0aXZlVGFiSW5kaWNhdG9yXzogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgb25lIG9yIG1vcmUgdGFiIGl0ZW1zIHRvIHRoZSBlbmQgb2YgdGhlIGNvbnRhaW5lci5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxPYmplY3RbXX0gaXRlbSBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGEgbmV3IHRhYiBvciBhbiBhcnJheSBvZiBzdWNoIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZXxOZW8uY29tcG9uZW50LkJhc2VbXX0gVGhlIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50KHMpLlxuICAgICAqL1xuICAgIGFkZChpdGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluc2VydCh0aGlzLmdldFRhYkJhcigpLml0ZW1zLmxlbmd0aCwgaXRlbSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSBsb2dpYyBhZnRlciB0aGUgYGFjdGl2ZUluZGV4YCBjb25maWcgaGFzIGNoYW5nZWQuIEl0IGVuc3VyZXMgdGhhdCB0aGVcbiAgICAgKiBsYXlvdXQgb2YgdGhlIGBCb2R5Q29udGFpbmVyYCBpcyB1cGRhdGVkIHRvIHNob3cgdGhlIGNvcnJlY3QgY2FyZCBhbmQgZmlyZXMgdGhlXG4gICAgICogYGFjdGl2ZUluZGV4Q2hhbmdlYCBldmVudC5cbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSB2YWx1ZSBUaGUgbmV3IGFjdGl2ZSBpbmRleC5cbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBvbGRWYWx1ZSBUaGUgcHJldmlvdXMgYWN0aXZlIGluZGV4LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICAgYXN5bmMgYWZ0ZXJTZXRBY3RpdmVJbmRleCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY2FyZENvbnRhaW5lciA9IE5lby5nZXRDb21wb25lbnQobWUuYm9keUNvbnRhaW5lcklkKTtcblxuICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKHZhbHVlKSAmJiB2YWx1ZSA+IC0xICYmICFjYXJkQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBtZS5vbignY29uc3RydWN0ZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbWUuYWZ0ZXJTZXRBY3RpdmVJbmRleCh2YWx1ZSwgb2xkVmFsdWUpXG4gICAgICAgICAgICB9LCBtZSwge29uY2U6IHRydWV9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKE5lby5pc051bWJlcih2YWx1ZSkgJiYgdmFsdWUgPiAtMSkge1xuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gZW5zdXJlIHRoZSBhZnRlclNldCBtZXRob2QgdHJpZ2dlcnMgd2hlbiBsYXp5IGxvYWRpbmcgdGhlIG1vZHVsZVxuICAgICAgICAgICAgICAgIGNhcmRDb250YWluZXIubGF5b3V0Ll9hY3RpdmVJbmRleCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGF3YWl0IGNhcmRDb250YWluZXIubGF5b3V0LmFmdGVyU2V0QWN0aXZlSW5kZXgodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICAgICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnVwZGF0ZVRhYkJ1dHRvbnMoKTtcblxuICAgICAgICAgICAgICAgICAgICBtZS5maXJlKCdhY3RpdmVJbmRleENoYW5nZScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW06IG1lLmdldEFjdGl2ZUNhcmQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIG9yIHJlbW92ZXMgdGhlIHBsYWluIENTUyBjbGFzcyB3aGVuIHRoZSBgcGxhaW5gIGNvbmZpZyBjaGFuZ2VzLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgVGhlIG5ldyB2YWx1ZSBmb3IgYHBsYWluYC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlIFRoZSBvbGQgdmFsdWUgZm9yIGBwbGFpbmAuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0UGxhaW4odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2xzfSA9IG1lO1xuXG4gICAgICAgIE5lb0FycmF5W3ZhbHVlID8gJ3Vuc2hpZnQnIDogJ3JlbW92ZSddKGNscywgbWUudGFiQ29udGFpbmVyQ2xzICsgJy1wbGFpbicpO1xuICAgICAgICBtZS5jbHMgPSBjbHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXNzZXMgdGhlIGBzb3J0YWJsZWAgY29uZmlnIGRvd24gdG8gdGhlIGBIZWFkZXJUb29sYmFyYCBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIFRoZSBuZXcgdmFsdWUgZm9yIGBzb3J0YWJsZWAuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZSBUaGUgb2xkIHZhbHVlIGZvciBgc29ydGFibGVgLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNvcnRhYmxlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5nZXRUYWJCYXIoKS5zb3J0YWJsZSA9IHZhbHVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGp1c3RzIHRoZSBjb250YWluZXIncyBsYXlvdXQgYW5kIENTUyBjbGFzc2VzIHdoZW4gdGhlIHRhYiBiYXIgcG9zaXRpb24gY2hhbmdlcy5cbiAgICAgKiBUaGlzIG1ldGhvZCBlbnN1cmVzIHRoYXQgdGhlIGBIZWFkZXJUb29sYmFyYCBpcyBkb2NrZWQgY29ycmVjdGx5IGFuZCB0aGF0IHRoZSBvdmVyYWxsXG4gICAgICogZmxleGJveCBsYXlvdXQgZGlyZWN0aW9uIGlzIHVwZGF0ZWQgdG8gYWNjb21tb2RhdGUgdGhlIG5ldyBwb3NpdGlvbiAoZS5nLiwgcm93IGZvciBsZWZ0L3JpZ2h0LFxuICAgICAqIGNvbHVtbiBmb3IgdG9wL2JvdHRvbSkuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFRoZSBuZXcgdGFiIGJhciBwb3NpdGlvbiAoJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCcpLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZSBUaGUgb2xkIHRhYiBiYXIgcG9zaXRpb24uXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VGFiQmFyUG9zaXRpb24odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2xzfSA9IG1lO1xuXG4gICAgICAgIE5lb0FycmF5LnJlbW92ZShjbHMsICduZW8tJyArIG9sZFZhbHVlKTtcbiAgICAgICAgTmVvQXJyYXkuYWRkKGNscywgJ25lby0nICsgdmFsdWUpO1xuICAgICAgICBtZS5zZXRTaWxlbnQoe2Nsc30pO1xuXG4gICAgICAgIGlmIChtZS52bm9kZUluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICBtZS5sYXlvdXQuc2V0U2lsZW50KG1lLmdldExheW91dENvbmZpZygpKTtcbiAgICAgICAgICAgIG1lLmdldFRhYkJhcigpLnNldFNpbGVudCh7ZG9jazogdmFsdWV9KTtcbiAgICAgICAgICAgIG1lLmdldFRhYlN0cmlwKCkuc2V0U2lsZW50KHtjbHM6IFsnbmVvLXRhYi1zdHJpcCcsICAnbmVvLWRvY2stJyArIHZhbHVlXX0pO1xuXG4gICAgICAgICAgICBtZS51cGRhdGVEZXB0aCA9IDI7XG5cbiAgICAgICAgICAgIG1lLmZpcmUoJ3RhYkJhclBvc2l0aW9uQ2hhbmdlJywge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudDogbWUsXG4gICAgICAgICAgICAgICAgb2xkVmFsdWUsXG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhc3NlcyB0aGUgYHVzZUFjdGl2ZVRhYkluZGljYXRvcmAgY29uZmlnIGRvd24gdG8gdGhlIGBIZWFkZXJUb29sYmFyYCBhbmQgYFN0cmlwYCBpbnN0YW5jZXMuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSBUaGUgbmV3IHZhbHVlIGZvciBgdXNlQWN0aXZlVGFiSW5kaWNhdG9yYC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlIFRoZSBvbGQgdmFsdWUgZm9yIGB1c2VBY3RpdmVUYWJJbmRpY2F0b3JgLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFVzZUFjdGl2ZVRhYkluZGljYXRvcih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0VGFiQmFyKCkgIC51c2VBY3RpdmVUYWJJbmRpY2F0b3IgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuZ2V0VGFiU3RyaXAoKS51c2VBY3RpdmVUYWJJbmRpY2F0b3IgPSB2YWx1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHRoZSBuZXcgdmFsdWUgZm9yIHRoZSBgdGFiQmFyUG9zaXRpb25gIGNvbmZpZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIG5ldyB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWUgVGhlIG9sZCB2YWx1ZS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIHZhbGlkYXRlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBiZWZvcmVTZXRUYWJCYXJQb3NpdGlvbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ3RhYkJhclBvc2l0aW9uJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgdGhlIGJhc2UgYGNyZWF0ZUl0ZW1zYCBsaWZlY3ljbGUgbWV0aG9kIHRvIGNvbnN0cnVjdCB0aGUgc3BlY2lmaWMgY29tcG9uZW50XG4gICAgICogaGllcmFyY2h5IHJlcXVpcmVkIGZvciBhIHRhYiBjb250YWluZXIuIEl0IHRyYW5zZm9ybXMgdGhlIHVzZXItcHJvdmlkZWQgYGl0ZW1zYCBhcnJheVxuICAgICAqIGludG8gdGhlIHRocmVlIGNvcmUgY2hpbGQgY29tcG9uZW50czogYEhlYWRlclRvb2xiYXJgLCBgU3RyaXBgLCBhbmQgYEJvZHlDb250YWluZXJgLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtcygpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2FjdGl2ZUluZGV4LCByZW1vdmVJbmFjdGl2ZUNhcmRzLCB1c2VBY3RpdmVUYWJJbmRpY2F0b3J9ID0gbWUsXG4gICAgICAgICAgICBpdGVtcyAgICAgICAgID0gbWUuaXRlbXMgfHwgW10sXG4gICAgICAgICAgICB0YWJCdXR0b25zICAgID0gW10sXG4gICAgICAgICAgICB0YWJDb21wb25lbnRzID0gW107XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihtZSwge1xuICAgICAgICAgICAgYm9keUNvbnRhaW5lcklkOiBtZS5ib2R5Q29udGFpbmVySWQgfHwgTmVvLmdldElkKCdjb250YWluZXInKSxcbiAgICAgICAgICAgIHRhYkJhcklkICAgICAgIDogbWUudGFiQmFySWQgICAgICAgIHx8IE5lby5nZXRJZCgndGFiLWhlYWRlci10b29sYmFyJyksXG4gICAgICAgICAgICB0YWJTdHJpcElkICAgICA6IG1lLnRhYlN0cmlwSWQgICAgICB8fCBOZW8uZ2V0SWQoJ3RhYi1zdHJpcCcpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICB0YWJCdXR0b25zLnB1c2gobWUuZ2V0VGFiQnV0dG9uQ29uZmlnKGl0ZW0uaGVhZGVyLCBpbmRleCkpO1xuXG4gICAgICAgICAgICBpZiAoIShpdGVtIGluc3RhbmNlb2YgTmVvLmNvbXBvbmVudC5CYXNlKSkge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSB7ZmxleDogMSwgLi4ubWUuaXRlbURlZmF1bHRzLCBpc1RhYjogdHJ1ZSwgLi4uaXRlbX1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGFiQ29tcG9uZW50cy5wdXNoKGl0ZW0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLml0ZW1zID0gW3tcbiAgICAgICAgICAgIG1vZHVsZSAgOiBIZWFkZXJUb29sYmFyLFxuICAgICAgICAgICAgZG9jayAgICA6IG1lLnRhYkJhclBvc2l0aW9uLFxuICAgICAgICAgICAgZmxleCAgICA6ICdub25lJyxcbiAgICAgICAgICAgIGlkICAgICAgOiBtZS50YWJCYXJJZCxcbiAgICAgICAgICAgIGl0ZW1zICAgOiB0YWJCdXR0b25zLFxuICAgICAgICAgICAgc29ydGFibGU6IG1lLnNvcnRhYmxlLFxuICAgICAgICAgICAgdXNlQWN0aXZlVGFiSW5kaWNhdG9yLFxuICAgICAgICAgICAgLi4ubWUuaGVhZGVyVG9vbGJhclxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtb2R1bGUgICAgICAgIDogU3RyaXAsXG4gICAgICAgICAgICBjbHMgICAgICAgICAgIDogWyduZW8tZG9jay0nICsgbWUudGFiQmFyUG9zaXRpb25dLFxuICAgICAgICAgICAgZmxleCAgICAgICAgICA6ICdub25lJyxcbiAgICAgICAgICAgIGlkICAgICAgICAgICAgOiBtZS50YWJTdHJpcElkLFxuICAgICAgICAgICAgdGFiQ29udGFpbmVySWQ6IG1lLmlkLFxuICAgICAgICAgICAgdXNlQWN0aXZlVGFiSW5kaWNhdG9yLFxuICAgICAgICAgICAgLi4ubWUudGFiU3RyaXBcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbW9kdWxlICAgICAgOiBCb2R5Q29udGFpbmVyLFxuICAgICAgICAgICAgaWQgICAgICAgICAgOiBtZS5ib2R5Q29udGFpbmVySWQsXG4gICAgICAgICAgICBpdGVtRGVmYXVsdHM6IG1lLml0ZW1EZWZhdWx0cyxcbiAgICAgICAgICAgIGl0ZW1zICAgICAgIDogdGFiQ29tcG9uZW50cyxcbiAgICAgICAgICAgIGxheW91dCAgICAgIDoge250eXBlOiAnY2FyZCcsIGFjdGl2ZUluZGV4LCByZW1vdmVJbmFjdGl2ZUNhcmRzfSxcbiAgICAgICAgICAgIHVzZUFjdGl2ZVRhYkluZGljYXRvcixcbiAgICAgICAgICAgIC4uLm1lLmJvZHlDb250YWluZXJcbiAgICAgICAgfV07XG5cbiAgICAgICAgbWUuaXRlbURlZmF1bHRzID0gbnVsbDtcblxuICAgICAgICBzdXBlci5jcmVhdGVJdGVtcygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBjb21wb25lbnQgaW5zdGFuY2UgZm9yIHRoZSBjdXJyZW50bHkgYWN0aXZlIHRhYi5cbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9IFRoZSBhY3RpdmUgY2FyZCBjb21wb25lbnQgb3IgbnVsbCBpZiBub25lIGlzIGFjdGl2ZS5cbiAgICAgKi9cbiAgICBnZXRBY3RpdmVDYXJkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDYXJkQ29udGFpbmVyKCk/Lml0ZW1zW3RoaXMuYWN0aXZlSW5kZXhdIHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGNvbXBvbmVudCBpbnN0YW5jZSBmb3IgYSB0YWIgYXQgYSBzcGVjaWZpYyBpbmRleC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBjYXJkIHRvIHJldHJpZXZlLlxuICAgICAqIEByZXR1cm5zIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH0gVGhlIGNhcmQgY29tcG9uZW50IG9yIG51bGwgaWYgbm90IGZvdW5kLlxuICAgICAqL1xuICAgIGdldENhcmQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2FyZENvbnRhaW5lcigpPy5pdGVtc1tpbmRleF0gfHwgbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgY29udmVuaWVuY2UgbWV0aG9kIHRvIGdldCB0aGUgYEJvZHlDb250YWluZXJgIGluc3RhbmNlIHRoYXQgaG9sZHMgdGhlIHRhYiBjb250ZW50IGNhcmRzLlxuICAgICAqIEByZXR1cm5zIHtOZW8uY29udGFpbmVyLkJhc2V9IFRoZSBib2R5IGNvbnRhaW5lciBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBnZXRDYXJkQ29udGFpbmVyKCkge1xuICAgICAgICByZXR1cm4gTmVvLmdldENvbXBvbmVudCh0aGlzLmJvZHlDb250YWluZXJJZClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0b3RhbCBudW1iZXIgb2YgdGFicyBpbiB0aGUgY29udGFpbmVyLlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgdGFicy5cbiAgICAgKi9cbiAgICBnZXRDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGFiQmFyKCkuaXRlbXMubGVuZ3RoXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIHRoZSBhcHByb3ByaWF0ZSBmbGV4Ym94IGxheW91dCBjb25maWd1cmF0aW9uIGJhc2VkIG9uIHRoZSBjdXJyZW50IGB0YWJCYXJQb3NpdGlvbmAuXG4gICAgICogRm9yIGV4YW1wbGUsIGEgJ3RvcCcgb3IgJ2JvdHRvbScgcG9zaXRpb24gcmVxdWlyZXMgYSB2ZXJ0aWNhbCBsYXlvdXQsIHdoaWxlICdsZWZ0JyBvciAncmlnaHQnXG4gICAgICogcmVxdWlyZXMgYSBob3Jpem9udGFsIG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZmxleGJveCBsYXlvdXQgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGdldExheW91dENvbmZpZygpIHtcbiAgICAgICAgbGV0IGxheW91dE1hcCA9IHtcbiAgICAgICAgICAgIGJvdHRvbToge1xuICAgICAgICAgICAgICAgIGFsaWduICAgIDogJ3N0cmV0Y2gnLFxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2NvbHVtbi1yZXZlcnNlJyxcbiAgICAgICAgICAgICAgICBwYWNrICAgICA6ICdzdGFydCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsZWZ0OiB7XG4gICAgICAgICAgICAgICAgYWxpZ24gICAgOiAnc3RyZXRjaCcsXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAncm93JyxcbiAgICAgICAgICAgICAgICBwYWNrICAgICA6ICdzdGFydCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByaWdodDoge1xuICAgICAgICAgICAgICAgIGFsaWduICAgIDogJ3N0cmV0Y2gnLFxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ3Jvdy1yZXZlcnNlJyxcbiAgICAgICAgICAgICAgICBwYWNrICAgICA6ICdzdGFydCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b3A6IHtcbiAgICAgICAgICAgICAgICBhbGlnbiAgICA6ICdzdHJldGNoJyxcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdjb2x1bW4nLFxuICAgICAgICAgICAgICAgIHBhY2sgICAgIDogJ3N0YXJ0J1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBsYXlvdXRNYXBbdGhpcy50YWJCYXJQb3NpdGlvbl0gfHwgbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgYEhlYWRlckJ1dHRvbmAgaW5zdGFuY2UgZm9yIGEgdGFiIGF0IGEgc3BlY2lmaWMgaW5kZXguXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGFiIGJ1dHRvbiB0byByZXRyaWV2ZS5cbiAgICAgKiBAcmV0dXJucyB7TmVvLnRhYi5oZWFkZXIuQnV0dG9ufG51bGx9IFRoZSB0YWIgYnV0dG9uIGNvbXBvbmVudCBvciBudWxsIGlmIG5vdCBmb3VuZC5cbiAgICAgKi9cbiAgICBnZXRUYWJBdEluZGV4KGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFRhYkJhcigpLml0ZW1zW2luZGV4XSB8fCBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBjb252ZW5pZW5jZSBtZXRob2QgdG8gZ2V0IHRoZSBgSGVhZGVyVG9vbGJhcmAgaW5zdGFuY2UgdGhhdCBob2xkcyB0aGUgdGFiIGJ1dHRvbnMuXG4gICAgICogQHJldHVybnMge05lby50b29sYmFyLkJhc2V9IFRoZSBoZWFkZXIgdG9vbGJhciBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBnZXRUYWJCYXIoKSB7XG4gICAgICAgIHJldHVybiBOZW8uZ2V0Q29tcG9uZW50KHRoaXMudGFiQmFySWQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGEgc2luZ2xlIHRhYiBidXR0b24uIEl0IG1lcmdlcyBhIGRlZmF1bHQgY29uZmlndXJhdGlvblxuICAgICAqIChpbmNsdWRpbmcgdGhlIG1vZHVsZSwgaW5kZXgsIGFuZCBhIGNsaWNrIGxpc3RlbmVyIHRvIGNoYW5nZSBgYWN0aXZlSW5kZXhgKSB3aXRoIHRoZVxuICAgICAqIHVzZXItcHJvdmlkZWQgY29uZmlndXJhdGlvbiBmcm9tIHRoZSBpdGVtJ3MgYGhlYWRlcmAgcHJvcGVydHkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgdXNlci1wcm92aWRlZCBjb25maWd1cmF0aW9uIGZyb20gYGl0ZW0uaGVhZGVyYC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoaXMgdGFiIGJ1dHRvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgbWVyZ2VkIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB0aGUgdGFiIGJ1dHRvbi5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZ2V0VGFiQnV0dG9uQ29uZmlnKGNvbmZpZywgaW5kZXgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcblxuICAgICAgICBkZWZhdWx0Q29uZmlnID0ge1xuICAgICAgICAgICAgbW9kdWxlIDogSGVhZGVyQnV0dG9uLFxuICAgICAgICAgICAgZmxleCAgIDogJ25vbmUnLFxuICAgICAgICAgICAgaW5kZXggIDogaW5kZXgsXG4gICAgICAgICAgICBwcmVzc2VkOiBtZS5hY3RpdmVJbmRleCA9PT0gaW5kZXgsXG5cbiAgICAgICAgICAgIGRvbUxpc3RlbmVyczogW3tcbiAgICAgICAgICAgICAgICBjbGljayhkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmFjdGl2ZUluZGV4ID0gZGF0YS5jb21wb25lbnQuaW5kZXhcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNjb3BlOiBtZVxuICAgICAgICAgICAgfV1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gey4uLmRlZmF1bHRDb25maWcsIC4uLmNvbmZpZ31cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGNvbnZlbmllbmNlIG1ldGhvZCB0byBnZXQgdGhlIGBTdHJpcGAgaW5zdGFuY2UsIHdoaWNoIGlzIHJlc3BvbnNpYmxlIGZvciByZW5kZXJpbmdcbiAgICAgKiB0aGUgYWN0aXZlIHRhYiBpbmRpY2F0b3IuXG4gICAgICogQHJldHVybnMge05lby50YWIuU3RyaXB9IFRoZSBzdHJpcCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBnZXRUYWJTdHJpcCgpIHtcbiAgICAgICAgcmV0dXJuIE5lby5nZXRDb21wb25lbnQodGhpcy50YWJTdHJpcElkKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgb25lIG9yIG1vcmUgdGFiIGl0ZW1zIGF0IGEgc3BlY2lmaWMgaW5kZXguXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCBhdCB3aGljaCB0byBpbnNlcnQgdGhlIG5ldyBpdGVtKHMpLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fE9iamVjdFtdfSBpdGVtIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgYSBuZXcgdGFiIG9yIGFuIGFycmF5IG9mIHN1Y2ggb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdIFNldCB0byB0cnVlIHRvIHByZXZlbnQgYHVwZGF0ZVRhYkJ1dHRvbnNgIGZyb20gYmVpbmcgY2FsbGVkLlxuICAgICAqIEByZXR1cm5zIHtOZW8uY29tcG9uZW50LkJhc2V8TmVvLmNvbXBvbmVudC5CYXNlW119IFRoZSBuZXdseSBjcmVhdGVkIGNvbXBvbmVudChzKS5cbiAgICAgKi9cbiAgICBpbnNlcnQoaW5kZXgsIGl0ZW0sIHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjYXJkQ29udGFpbmVyID0gbWUuZ2V0Q2FyZENvbnRhaW5lcigpLFxuICAgICAgICAgICAgdGFiQmFyICAgICAgICA9IG1lLmdldFRhYkJhcigpLFxuICAgICAgICAgICAgaGFzSXRlbSAgICAgICA9IGZhbHNlLFxuICAgICAgICAgICAgaSwgbGVuLCByZXR1cm5BcnJheSwgc3VwZXJJdGVtLCB0YWI7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgIGkgICAgICAgICAgID0gMDtcbiAgICAgICAgICAgIGxlbiAgICAgICAgID0gaXRlbS5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm5BcnJheSA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gaW5zZXJ0IHRoZSBhcnJheSBiYWNrd2FyZHNcbiAgICAgICAgICAgICAgICByZXR1cm5BcnJheS51bnNoaWZ0KG1lLmluc2VydChpbmRleCwgaXRlbVtsZW4gLSAxIC0gaV0sIHRydWUpKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdXBlckl0ZW0gPSByZXR1cm5BcnJheTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGkgICA9IDA7XG4gICAgICAgICAgICBsZW4gPSBjYXJkQ29udGFpbmVyLml0ZW1zLmxlbmd0aDtcblxuICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChjYXJkQ29udGFpbmVyLml0ZW1zW2ldLmlkID09PSBpdGVtLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc0l0ZW0gICA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVySXRlbSA9IGNhcmRDb250YWluZXIuaXRlbXNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lLmFjdGl2YXRlSW5zZXJ0ZWRUYWJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5hY3RpdmVJbmRleCA9IGlcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWhhc0l0ZW0pIHtcbiAgICAgICAgICAgICAgICB0YWIgPSB0YWJCYXIuaW5zZXJ0KGluZGV4LCBtZS5nZXRUYWJCdXR0b25Db25maWcoaXRlbS5oZWFkZXIsIGluZGV4KSk7XG5cbiAgICAgICAgICAgICAgICAvLyB0b2RvOiBub24gaW5kZXggYmFzZWQgbWF0Y2hpbmcgb2YgdGFiIGJ1dHRvbnMgYW5kIGNhcmRzXG4gICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgbGVuID0gdGFiQmFyLml0ZW1zLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGFiQmFyLml0ZW1zW2ldLmluZGV4ID0gaVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGl0ZW0uZmxleCA9IDE7XG4gICAgICAgICAgICAgICAgc3VwZXJJdGVtID0gY2FyZENvbnRhaW5lci5pbnNlcnQoaW5kZXgsIGl0ZW0sIHNpbGVudCk7XG5cbiAgICAgICAgICAgICAgICBpZiAobWUuYWN0aXZhdGVJbnNlcnRlZFRhYnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtZS52bm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUuYWN0aXZlSW5kZXggPSBpbmRleFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFiLm9uKCdtb3VudGVkJywgbWUub25UYWJCdXR0b25Nb3VudGVkLCBtZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICFzaWxlbnQgJiYgbWUudXBkYXRlVGFiQnV0dG9ucygpO1xuXG4gICAgICAgIHJldHVybiBzdXBlckl0ZW1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhbiBleGlzdGluZyB0YWIgKGJvdGggaXRzIGJ1dHRvbiBhbmQgaXRzIGNhcmQpIGZyb20gb25lIGluZGV4IHRvIGFub3RoZXIuXG4gICAgICogVGhpcyBpcyBwcmltYXJpbHkgdXNlZCBmb3IgZHJhZy1hbmQtZHJvcCByZW9yZGVyaW5nLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmcm9tSW5kZXggVGhlIG9yaWdpbmFsIGluZGV4IG9mIHRoZSB0YWIuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvSW5kZXggVGhlIG5ldyBpbmRleCBmb3IgdGhlIHRhYi5cbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlfSBUaGUgY2FyZCBjb21wb25lbnQgdGhhdCB3YXMgbW92ZWQuXG4gICAgICovXG4gICAgbW92ZVRvKGZyb21JbmRleCwgdG9JbmRleCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjYXJkQ29udGFpbmVyID0gbWUuZ2V0Q2FyZENvbnRhaW5lcigpLFxuICAgICAgICAgICAgdGFiQmFyICAgICAgICA9IG1lLmdldFRhYkJhcigpLFxuICAgICAgICAgICAgYWN0aXZlVGFiICAgICA9IHRhYkJhci5pdGVtc1ttZS5hY3RpdmVJbmRleF0sXG4gICAgICAgICAgICBpbmRleCwgcmV0dXJuVmFsdWU7XG5cbiAgICAgICAgdGFiQmFyLm1vdmVUbyhmcm9tSW5kZXgsIHRvSW5kZXgpO1xuICAgICAgICBpbmRleCA9IGFjdGl2ZVRhYi5pbmRleDtcblxuICAgICAgICBpZiAoaW5kZXggIT09IG1lLmFjdGl2ZUluZGV4KSB7XG4gICAgICAgICAgICAvLyBzaWxlbnQgdXBkYXRlc1xuICAgICAgICAgICAgbWUuX2FjdGl2ZUluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICBjYXJkQ29udGFpbmVyLmxheW91dC5fYWN0aXZlSW5kZXggPSBpbmRleFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuVmFsdWUgPSBjYXJkQ29udGFpbmVyLm1vdmVUbyhmcm9tSW5kZXgsIHRvSW5kZXgpO1xuXG4gICAgICAgIG1lLmZpcmUoJ21vdmVUbycsIHtcbiAgICAgICAgICAgIGZyb21JbmRleCxcbiAgICAgICAgICAgIHRvSW5kZXhcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIHRoZSBiYXNlIGBvbkNvbnN0cnVjdGVkYCBsaWZlY3ljbGUgbWV0aG9kIHRvIGFwcGx5IHRoZSBpbml0aWFsIGZsZXhib3ggbGF5b3V0XG4gICAgICogY29uZmlndXJhdGlvbiBhZnRlciB0aGUgbWFpbiBjb25zdHJ1Y3Rpb24gcHJvY2VzcyBpcyBjb21wbGV0ZS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25Db25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgdGhpcy5sYXlvdXQgPSB7bnR5cGU6ICdmbGV4Ym94JywgLi4udGhpcy5nZXRMYXlvdXRDb25maWcoKX07XG4gICAgICAgIHN1cGVyLm9uQ29uc3RydWN0ZWQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgaGFuZGxlciB0aGF0IGlzIHRyaWdnZXJlZCB3aGVuIGEgZHluYW1pY2FsbHkgYWRkZWQgdGFiIGJ1dHRvbiBpcyBtb3VudGVkIHRvIHRoZSBET00uXG4gICAgICogSWYgYGFjdGl2YXRlSW5zZXJ0ZWRUYWJzYCBpcyB0cnVlLCB0aGlzIG1ldGhvZCBlbnN1cmVzIHRoYXQgdGhlIGBhY3RpdmVJbmRleGAgaXMgc2V0XG4gICAgICogY29ycmVjdGx5IGFmdGVyIHRoZSBuZXcgdGFiJ3MgY29ycmVzcG9uZGluZyBjYXJkIGlzIGFsc28gbW91bnRlZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYnV0dG9uSWQgVGhlIElEIG9mIHRoZSBtb3VudGVkIGJ1dHRvbi5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25UYWJCdXR0b25Nb3VudGVkKGJ1dHRvbklkKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNhcmRDb250YWluZXIgPSBtZS5nZXRDYXJkQ29udGFpbmVyKCksXG4gICAgICAgICAgICB0YWJCYXIgICAgICAgID0gbWUuZ2V0VGFiQmFyKCksXG4gICAgICAgICAgICBpICAgICAgICAgICAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgICAgICAgICAgPSB0YWJCYXIuaXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgaW5kZXggICAgICAgICA9IC0xLFxuICAgICAgICAgICAgY2FyZDtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGFiQmFyLml0ZW1zW2ldLmlkID09PSBidXR0b25JZCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIGNhcmQgPSBjYXJkQ29udGFpbmVyLml0ZW1zW2luZGV4XTtcblxuICAgICAgICAgICAgaWYgKG1lLnZub2RlICYmICFjYXJkLm1vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICBjYXJkLm9uKCdtb3VudGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBtZS5hY3RpdmVJbmRleCA9IGluZGV4XG4gICAgICAgICAgICAgICAgfSwgbWUsIHtvbmNlOiB0cnVlfSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWUuYWN0aXZlSW5kZXggPSBpbmRleFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHRhYiBmcm9tIHRoZSBjb250YWluZXIgdXNpbmcgYSByZWZlcmVuY2UgdG8gdGhlIGNhcmQgY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBjb21wb25lbnQgVGhlIGNhcmQgY29tcG9uZW50IGluc3RhbmNlIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkZXN0cm95SXRlbT10cnVlXSBTZXQgdG8gZmFsc2UgdG8ga2VlcCB0aGUgY29tcG9uZW50IGluc3RhbmNlIGluIG1lbW9yeS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdIFNldCB0byB0cnVlIHRvIHByZXZlbnQgYHVwZGF0ZVRhYkJ1dHRvbnNgIGZyb20gYmVpbmcgY2FsbGVkLlxuICAgICAqL1xuICAgIHJlbW92ZShjb21wb25lbnQsIGRlc3Ryb3lJdGVtPXRydWUsIHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgaXRlbXMgPSBbLi4udGhpcy5nZXRDYXJkQ29udGFpbmVyKCkuaXRlbXNdLFxuICAgICAgICAgICAgaSAgICAgPSAwLFxuICAgICAgICAgICAgbGVuICAgPSBpdGVtcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGl0ZW1zW2ldLmlkID09PSBjb21wb25lbnQuaWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUF0KGksIGRlc3Ryb3lJdGVtLCBzaWxlbnQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgdGFiIGZyb20gdGhlIGNvbnRhaW5lciBhdCBhIHNwZWNpZmljIGluZGV4LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHRhYiB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZGVzdHJveUl0ZW09dHJ1ZV0gU2V0IHRvIGZhbHNlIHRvIGtlZXAgdGhlIGNvbXBvbmVudCBpbnN0YW5jZSBpbiBtZW1vcnkuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2lsZW50PWZhbHNlXSBTZXQgdG8gdHJ1ZSB0byBwcmV2ZW50IGB1cGRhdGVUYWJCdXR0b25zYCBmcm9tIGJlaW5nIGNhbGxlZC5cbiAgICAgKi9cbiAgICByZW1vdmVBdChpbmRleCwgZGVzdHJveUl0ZW09dHJ1ZSwgc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHthY3RpdmVJbmRleH0gPSBtZSxcbiAgICAgICAgICAgIGNhcmRDb250YWluZXIgPSBtZS5nZXRDYXJkQ29udGFpbmVyKCksXG4gICAgICAgICAgICB0YWJCYXIgICAgICAgID0gbWUuZ2V0VGFiQmFyKCksXG4gICAgICAgICAgICBpLCBsZW47XG5cbiAgICAgICAgY2FyZENvbnRhaW5lci5yZW1vdmVBdChpbmRleCwgZGVzdHJveUl0ZW0sIHNpbGVudCk7XG4gICAgICAgIHRhYkJhciAgICAgICAucmVtb3ZlQXQoaW5kZXgsIHRydWUsICAgICAgICBmYWxzZSk7XG5cbiAgICAgICAgaWYgKGluZGV4IDwgYWN0aXZlSW5kZXgpIHtcbiAgICAgICAgICAgIC8vIHNpbGVudCB1cGRhdGVzXG4gICAgICAgICAgICBtZS5fYWN0aXZlSW5kZXggPSBhY3RpdmVJbmRleCAtIDE7XG4gICAgICAgICAgICBjYXJkQ29udGFpbmVyLmxheW91dC5fYWN0aXZlSW5kZXggPSBhY3RpdmVJbmRleCAtIDFcbiAgICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gYWN0aXZlSW5kZXgpIHtcbiAgICAgICAgICAgIG1lLmFjdGl2ZUluZGV4ID0gYWN0aXZlSW5kZXggLSAxXG4gICAgICAgIH1cblxuICAgICAgICAvLyB0b2RvOiBub24gaW5kZXggYmFzZWQgbWF0Y2hpbmcgb2YgdGFiIGJ1dHRvbnMgYW5kIGNhcmRzXG4gICAgICAgIGkgICA9IDA7XG4gICAgICAgIGxlbiA9IHRhYkJhci5pdGVtcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdGFiQmFyLml0ZW1zW2ldLmluZGV4ID0gaVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3luY2hyb25pemVzIHRoZSBgcHJlc3NlZGAgc3RhdGUgb2YgYWxsIHRhYiBidXR0b25zIHdpdGggdGhlIGNvbnRhaW5lcidzIGBhY3RpdmVJbmRleGAuXG4gICAgICogVGhpcyBlbnN1cmVzIHRoYXQgb25seSB0aGUgYnV0dG9uIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGFjdGl2ZSB0YWIgYXBwZWFycyBwcmVzc2VkLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB1cGRhdGVUYWJCdXR0b25zKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7YWN0aXZlSW5kZXh9ID0gbWUsXG4gICAgICAgICAgICB0YWJCdXR0b25zICAgID0gbWUuZ2V0VGFiQmFyKCk/Lml0ZW1zIHx8IFtdO1xuXG4gICAgICAgIHRhYkJ1dHRvbnMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGl0ZW0ucHJlc3NlZCA9IGluZGV4ID09PSBhY3RpdmVJbmRleFxuICAgICAgICB9KVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ29udGFpbmVyKTtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50L0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnRhYi5TdHJpcFxuICogQGV4dGVuZHMgTmVvLmNvbXBvbmVudC5CYXNlXG4gKi9cbmNsYXNzIFN0cmlwIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby50YWIuU3RyaXAnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby50YWIuU3RyaXAnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ndGFiLXN0cmlwJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3RhYi1zdHJpcCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby10YWItc3RyaXAnXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tdGFiLXN0cmlwJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gdGFiQ29udGFpbmVySWQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgdGFiQ29udGFpbmVySWQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB1c2VBY3RpdmVUYWJJbmRpY2F0b3JfPXRydWVcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB1c2VBY3RpdmVUYWJJbmRpY2F0b3JfOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbT17Y246IFt7Y2xzOiAnbmVvLWFjdGl2ZS10YWItaW5kaWNhdG9yJ31dfVxuICAgICAgICAgKi9cbiAgICAgICAgX3Zkb206XG4gICAgICAgIHtjbjogW1xuICAgICAgICAgICAge2NsczogWyduZW8tYWN0aXZlLXRhYi1pbmRpY2F0b3InXX1cbiAgICAgICAgXX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHVzZUFjdGl2ZVRhYkluZGljYXRvciBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFVzZUFjdGl2ZVRhYkluZGljYXRvcih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy52ZG9tLmNuWzBdLnJlbW92ZURvbSA9ICF2YWx1ZTtcbiAgICAgICAgdGhpcy51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIERvbVJlY3Qgb2YgdGhlIGFjdGl2ZSB0YWIsIHRoZW4gbW92ZXMgdGhlIGluZGljYXRvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fG51bGx9IG9wdHNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb3B0cy5vbGRWYWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRzLnZhbHVlXG4gICAgICovXG4gICAgZ2V0QWN0aXZlVGFiUmVjdFRoZW5Nb3ZlKG9wdHMpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpZHMgICAgICAgICAgPSBbbWUuaWRdLFxuICAgICAgICAgICAgdGFiQ29udGFpbmVyID0gbWUuZ2V0VGFiQ29udGFpbmVyKCksXG4gICAgICAgICAgICBvbGRUYWI7XG5cbiAgICAgICAgLy8gV2UgZG8gbm90IG5lZWQgYSBtb3ZlbWVudCwgaW4gY2FzZSB0aGVyZSBpcyBubyBvbGRWYWx1ZVxuICAgICAgICBpZiAobWUudXNlQWN0aXZlVGFiSW5kaWNhdG9yICYmIG1lLnZub2RlICYmIE5lby5pc051bWJlcihvcHRzPy5vbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgIG9sZFRhYiA9IHRhYkNvbnRhaW5lci5nZXRUYWJBdEluZGV4KG9wdHMub2xkVmFsdWUpO1xuXG4gICAgICAgICAgICAvLyBUaGUgYWN0aXZlSW5kZXhDaGFuZ2UgZXZlbnQgY2FuIGdldCB0cmlnZ2VyZWQgd2hlbiByZW1vdmluZyB0aGUgY3VycmVudGx5IGFjdGl2ZSB0YWIsXG4gICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIHdlIGNhbiBubyBsb25nZXIgYWNjZXNzIHRoZSByZWxhdGVkIERPTVJlY3QgYW5kIG5lZWQgdG8gb3B0IG91dC5cbiAgICAgICAgICAgIGlmIChvbGRUYWIpIHtcbiAgICAgICAgICAgICAgICBpZHMucHVzaCh0YWJDb250YWluZXIuZ2V0VGFiQXRJbmRleChvcHRzLnZhbHVlKS5pZCwgb2xkVGFiLmlkKTtcblxuICAgICAgICAgICAgICAgIG1lLmdldERvbVJlY3QoaWRzKS50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgICAgICAgICBtZS5tb3ZlQWN0aXZlSW5kaWNhdG9yKGRhdGEpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZ2V0VGFiQ29udGFpbmVyKCkge1xuICAgICAgICByZXR1cm4gTmVvLmdldENvbXBvbmVudCh0aGlzLnRhYkNvbnRhaW5lcklkKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbiBlaXRoZXIgY29udGFpbiB0aGUgbmV3IHRhcmdldCByZWN0IG9yIHRoZSBuZXcgYW5kIG9sZCBvbmVcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSByZWN0c1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByZWN0c1swXS5ib3R0b21cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmVjdHNbMF0uaGVpZ2h0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJlY3RzWzBdLmxlZnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmVjdHNbMF0ucmlnaHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmVjdHNbMF0udG9wXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJlY3RzWzBdLndpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJlY3RzWzBdLnhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmVjdHNbMF0ueVxuICAgICAqL1xuICAgIG1vdmVBY3RpdmVJbmRpY2F0b3IocmVjdHMpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB0YWJTdHJpcFJlY3QgPSByZWN0cy5zaGlmdCgpLFxuICAgICAgICAgICAgcmVjdCAgICAgICAgID0gcmVjdHNbMV0gfHwgcmVjdHNbMF0sXG4gICAgICAgICAgICBhY3RpdmVUYWJJbmRpY2F0b3IsIHRhYkNvbnRhaW5lcjtcblxuICAgICAgICBpZiAobWUudXNlQWN0aXZlVGFiSW5kaWNhdG9yKSB7XG4gICAgICAgICAgICBhY3RpdmVUYWJJbmRpY2F0b3IgPSBtZS52ZG9tLmNuWzBdO1xuICAgICAgICAgICAgdGFiQ29udGFpbmVyICAgICAgID0gbWUuZ2V0VGFiQ29udGFpbmVyKCk7XG5cbiAgICAgICAgICAgIHN3aXRjaCAodGFiQ29udGFpbmVyLnRhYkJhclBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICAgICAgICBhY3RpdmVUYWJJbmRpY2F0b3Iuc3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ICA6IGAke3JlY3QubGVmdCAtIHRhYlN0cmlwUmVjdC5sZWZ0fXB4YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcCAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoIDogYCR7cmVjdC53aWR0aH1weGBcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZVRhYkluZGljYXRvci5zdHlsZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogYCR7cmVjdC5oZWlnaHR9cHhgLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCAgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wICAgOiBgJHtyZWN0LnRvcCAtIHRhYlN0cmlwUmVjdC50b3B9cHhgLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggOiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGluIGNhc2UgdGhlcmUgaXMgYSBkeW5hbWljIGNoYW5nZSAob2xkVmFsdWUpLCBjYWxsIHRoaXMgbWV0aG9kIGFnYWluXG4gICAgICAgICAgICBpZiAocmVjdHNbMV0pIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVUYWJJbmRpY2F0b3Iuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgICAgICAgICAgbWUudXBkYXRlKCk7XG5cbiAgICAgICAgICAgICAgICBtZS50aW1lb3V0KDUwKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbWUubW92ZUFjdGl2ZUluZGljYXRvcihbdGFiU3RyaXBSZWN0LCByZWN0c1swXV0pXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlVGFiSW5kaWNhdG9yLnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICAgICAgICAgIG1lLnVwZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgbWUudGltZW91dCgzMDApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVUYWJJbmRpY2F0b3Iuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25Db25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgc3VwZXIub25Db25zdHJ1Y3RlZCgpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuZ2V0VGFiQ29udGFpbmVyKCkub24oe1xuICAgICAgICAgICAgYWN0aXZlSW5kZXhDaGFuZ2U6IG1lLmdldEFjdGl2ZVRhYlJlY3RUaGVuTW92ZSxcbiAgICAgICAgICAgIHNjb3BlICAgICAgICAgICAgOiBtZVxuICAgICAgICB9KVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoU3RyaXApO1xuIiwiaW1wb3J0IEJhc2VCdXR0b24gZnJvbSAnLi4vLi4vYnV0dG9uL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnRhYi5oZWFkZXIuQnV0dG9uXG4gKiBAZXh0ZW5kcyBOZW8uYnV0dG9uLkJhc2VcbiAqL1xuY2xhc3MgQnV0dG9uIGV4dGVuZHMgQmFzZUJ1dHRvbiB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8udGFiLmhlYWRlci5CdXR0b24nXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby50YWIuaGVhZGVyLkJ1dHRvbicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSd0YWItaGVhZGVyLWJ1dHRvbidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICd0YWItaGVhZGVyLWJ1dHRvbicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1idXR0b24nLCduZW8tdGFiLWJ1dHRvbiddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby10YWItaGVhZGVyLWJ1dHRvbicsICduZW8tYnV0dG9uJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZ5IGEgcm9sZSB0YWcgYXR0cmlidXRlIGZvciB0aGUgdmRvbSByb290LlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gcm9sZT0ndGFiJ1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHJvbGU6ICd0YWInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gdXNlQWN0aXZlVGFiSW5kaWNhdG9yXz10cnVlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdXNlQWN0aXZlVGFiSW5kaWNhdG9yXzogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gX3Zkb21cbiAgICAgICAgICovXG4gICAgICAgIF92ZG9tOlxuICAgICAgICB7dGFnOiAnYnV0dG9uJywgY246IFtcbiAgICAgICAgICAgIHt0YWc6ICdzcGFuJywgY2xzOiBbJ25lby1idXR0b24tZ2x5cGgnXX0sXG4gICAgICAgICAgICB7dGFnOiAnc3BhbicsIGNsczogWyduZW8tYnV0dG9uLXRleHQnXX0sXG4gICAgICAgICAgICB7Y2xzOiBbJ25lby1idXR0b24tYmFkZ2UnXX0sXG4gICAgICAgICAgICB7Y2xzOiBbJ25lby1idXR0b24tcmlwcGxlLXdyYXBwZXInXSwgY246IFtcbiAgICAgICAgICAgICAgICAgICAge2NsczogWyduZW8tYnV0dG9uLXJpcHBsZSddfVxuICAgICAgICAgICAgICAgIF19LFxuICAgICAgICAgICAge2NsczogWyduZW8tdGFiLWJ1dHRvbi1pbmRpY2F0b3InXX1cbiAgICAgICAgXX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHByZXNzZWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRQcmVzc2VkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldFByZXNzZWQodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgbWUudmRvbVsnYXJpYS1zZWxlY3RlZCddID0gdHJ1ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIG1lLnZkb21bJ2FyaWEtc2VsZWN0ZWQnXVxuICAgICAgICB9XG5cbiAgICAgICAgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHVzZUFjdGl2ZVRhYkluZGljYXRvciBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFVzZUFjdGl2ZVRhYkluZGljYXRvcih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVVc2VBY3RpdmVUYWJJbmRpY2F0b3IoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgc2hvd1JpcHBsZShkYXRhKSB7XG4gICAgICAgICF0aGlzLnByZXNzZWQgJiYgc3VwZXIuc2hvd1JpcHBsZShkYXRhKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50PWZhbHNlXG4gICAgICovXG4gICAgdXBkYXRlVXNlQWN0aXZlVGFiSW5kaWNhdG9yKHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnZkb20uY25bNF0ucmVtb3ZlRG9tID0gIW1lLnVzZUFjdGl2ZVRhYkluZGljYXRvcjtcbiAgICAgICAgIXNpbGVudCAmJiBtZS51cGRhdGUoKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQnV0dG9uKTtcbiIsImltcG9ydCBCYXNlVG9vbGJhciBmcm9tICcuLi8uLi90b29sYmFyL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnRhYi5oZWFkZXIuVG9vbGJhclxuICogQGV4dGVuZHMgTmVvLnRvb2xiYXIuQmFzZVxuICovXG5jbGFzcyBUb29sYmFyIGV4dGVuZHMgQmFzZVRvb2xiYXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnRhYi5oZWFkZXIuVG9vbGJhcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnRhYi5oZWFkZXIuVG9vbGJhcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSd0YWItaGVhZGVyLXRvb2xiYXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAndGFiLWhlYWRlci10b29sYmFyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLXRhYi1oZWFkZXItdG9vbGJhcicsJ25lby10b29sYmFyJ11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLXRhYi1oZWFkZXItdG9vbGJhcicsICduZW8tdG9vbGJhciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gdXNlQWN0aXZlVGFiSW5kaWNhdG9yXz10cnVlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdXNlQWN0aXZlVGFiSW5kaWNhdG9yXzogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc29ydGFibGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTb3J0YWJsZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAodmFsdWUgJiYgIW1lLnNvcnRab25lKSB7XG4gICAgICAgICAgICBpbXBvcnQoJy4uLy4uL2RyYWdnYWJsZS90YWIvaGVhZGVyL3Rvb2xiYXIvU29ydFpvbmUubWpzJykudGhlbihtb2R1bGUgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB7YXBwTmFtZSwgaWQsIHdpbmRvd0lkfSA9IG1lO1xuXG4gICAgICAgICAgICAgICAgbWUuc29ydFpvbmUgPSBOZW8uY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlICAgICAgICAgICAgIDogbW9kdWxlLmRlZmF1bHQsXG4gICAgICAgICAgICAgICAgICAgIGFwcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5Q29udGFpbmVySWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICBvd25lciAgICAgICAgICAgICAgOiBtZSxcbiAgICAgICAgICAgICAgICAgICAgd2luZG93SWQsXG4gICAgICAgICAgICAgICAgICAgIC4uLm1lLnNvcnRab25lQ29uZmlnXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHVzZUFjdGl2ZVRhYkluZGljYXRvciBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFVzZUFjdGl2ZVRhYkluZGljYXRvcih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIG1lLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gc2lsZW50IHVwZGF0ZXNcbiAgICAgICAgICAgICAgICBpdGVtLl91c2VBY3RpdmVUYWJJbmRpY2F0b3IgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpdGVtLnVwZGF0ZVVzZUFjdGl2ZVRhYkluZGljYXRvcih0cnVlKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY3JlYXRlSXRlbXMoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBkZWZhdWx0cyA9IG1lLml0ZW1EZWZhdWx0cyB8fCB7fTtcblxuICAgICAgICBkZWZhdWx0cy51c2VBY3RpdmVUYWJJbmRpY2F0b3IgPSBtZS51c2VBY3RpdmVUYWJJbmRpY2F0b3I7XG4gICAgICAgIG1lLml0ZW1EZWZhdWx0cyA9IGRlZmF1bHRzO1xuXG4gICAgICAgIHN1cGVyLmNyZWF0ZUl0ZW1zKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsYXlvdXQgY29uZmlnIG1hdGNoaW5nIHRvIHRoZSBkb2NrIHBvc2l0aW9uXG4gICAgICogQHJldHVybnMge09iamVjdH0gbGF5b3V0Q29uZmlnXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGdldExheW91dENvbmZpZygpIHtcbiAgICAgICAgbGV0IGxheW91dENvbmZpZztcblxuICAgICAgICBzd2l0Y2ggKHRoaXMuZG9jaykge1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgbGF5b3V0Q29uZmlnID0ge1xuICAgICAgICAgICAgICAgICAgICBhbGlnbiAgICA6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdyb3cnLFxuICAgICAgICAgICAgICAgICAgICBwYWNrICAgICA6ICdzdGFydCdcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICBsYXlvdXRDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgICAgIGFsaWduICAgIDogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2NvbHVtbi1yZXZlcnNlJyxcbiAgICAgICAgICAgICAgICAgICAgcGFjayAgICAgOiAnZW5kJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICBsYXlvdXRDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgICAgIGFsaWduICAgIDogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgICAgICAgICAgICAgICAgIHBhY2sgICAgIDogJ3N0YXJ0J1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsYXlvdXRDb25maWdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhbiBleGlzdGluZyBpdGVtIHRvIGEgbmV3IGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZyb21JbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0b0luZGV4XG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZX1cbiAgICAgKi9cbiAgICBtb3ZlVG8oZnJvbUluZGV4LCB0b0luZGV4KSB7XG4gICAgICAgIGxldCByZXR1cm5WYWx1ZSA9IHN1cGVyLm1vdmVUbyhmcm9tSW5kZXgsIHRvSW5kZXgpO1xuXG4gICAgICAgIGlmIChmcm9tSW5kZXggIT09IHRvSW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBpdGVtLmluZGV4ID0gaW5kZXhcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWVcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFRvb2xiYXIpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9