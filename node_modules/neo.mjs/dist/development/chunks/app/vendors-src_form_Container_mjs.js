export const __webpack_esm_id__ = "vendors-src_form_Container_mjs";
export const __webpack_esm_ids__ = ["vendors-src_form_Container_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./src/form/Container.mjs"
/*!********************************!*\
  !*** ./src/form/Container.mjs ***!
  \********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _form_field_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../form/field/Base.mjs */ "./src/form/field/Base.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../manager/Component.mjs */ "./src/manager/Component.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");





/**
 * @class Neo.form.Container
 * @extends Neo.container.Base
 */
class Container extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.form.Container'
         * @protected
         */
        className: 'Neo.form.Container',
        /**
         * @member {String} ntype='form-container'
         * @protected
         */
        ntype: 'form-container',
        /**
         * @member {String[]} baseCls=['neo-form-container'],
         * @protected
         */
        baseCls: ['neo-form-container'],
        /**
         * @member {Object} vdom={tag: 'form',cn:[],onsubmit:'return false;'}
         */
        vdom:
        {tag: 'form', cn: [], onsubmit: 'return false;'}
    }

    /**
     * Helper function used by setValues() which wraps the leaves of a tree structure into a new property.
     * @param {Object} values
     * @param {String} configName
     * @param {String[]} fieldPaths
     * @param {String} currentPath=''
     */
    static adjustTreeLeaves(values={}, configName, fieldPaths, currentPath='') {
        let assign, newPath, type;

        Object.entries(values).forEach(([key, value]) => {
            assign  = true;
            newPath = currentPath === '' ? key : `${currentPath}.${key}`;
            type    = Neo.typeOf(value);

            if (type === 'Array' || type === 'Object') {
                assign = fieldPaths.includes(newPath);

                if (type === 'Array') {
                    value.forEach((item, index) => {
                        if (Neo.typeOf(item) === 'Object') {
                            this.adjustTreeLeaves(item, configName, fieldPaths, `${newPath}[${index}]`)
                        }
                    })
                } else if (type === 'Object') {
                    this.adjustTreeLeaves(value, configName, fieldPaths, newPath)
                }
            }

            if (assign) {
                if (key === configName) {
                    values[key] = value
                } else {
                    values[key] = {[configName]: value}
                }
            }
        })
    }

    /**
     * @param {Neo.container.Base} parent
     * @param {Object[]} modules
     * @returns {Object[]}
     */
    findNotLoadedModules(parent=this, modules=[]) {
        parent.items.forEach(item => {
            if (Neo.typeOf(item.module) === 'Function' && !item.isLoading) {
                modules.push({item, parent})
            } else {
                item.items && this.findNotLoadedModules(item, modules)
            }
        });

        return modules
    }

    /**
     * Either pass a field name or id
     * @param {String} name
     * @returns {Promise<Neo.form.field.Base|null>} fields
     */
    async getField(name) {
        await this.loadModules();

        let fields = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getChildComponents(this),
            field;

        for (field of fields) {
            if (field instanceof _form_field_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]) {
                if (field.name === name || field.id === name) {
                    return field
                }
            }
        }

        return null
    }

    /**
     * @param {Neo.form.field.Base} field
     * @returns {String}
     */
    getFieldPath(field) {
        let path = field.formGroup ? field.formGroup.split('.') : [];

        path.push(field.name || field.id);

        return path.join('.')
    }

    /**
     * @returns {Promise<Neo.form.field.Base[]>} fields
     */
    async getFields() {
        let fields = [];

        await this.loadModules();

        _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getChildComponents(this).forEach(field => {
            field instanceof _form_field_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] && fields.push(field)
        });

        return fields
    }


    /**
     * This function will return one of the following states:
     * - clean      => all fields are clean (untouched)
     * - invalid    => at least one field is invalid
     * - valid      => all required fields are valid
     * - inProgress => at least one field is valid, at least one field is clean
     * @returns {Promise<String>}
     */
    async getFormState() {
        let fields           = await this.getFields(),
            i                = 0,
            hasCleanFields   = false,
            hasAlertFields   = false,
            hasInvalidFields = false,
            hasUncleanFields = false,
            hasValidFields   = false,
            len              = fields.length,
            field, isClean, isValid;

        for (; i < len; i++) {
            field   = fields[i];
            isClean = field.clean;
            isValid = field.isValid();

            if (!isClean && !isValid) {
                if (field.isEmptyAndRequired?.()) {
                    hasAlertFields = true
                } else {
                    return 'invalid'
                }
            } else if (isValid) {
                hasValidFields = true
            } else if (!isValid) {
                if (field.isEmptyAndRequired?.()) {
                    hasAlertFields = true
                } else {
                    hasInvalidFields = true
                }
            }

            if (isClean) {
                hasCleanFields = true
            } else {
                hasUncleanFields = true
            }
        }

        if (!hasAlertFields && !hasInvalidFields) {
            return 'valid'
        }

        if (!hasAlertFields && hasCleanFields && !hasUncleanFields) {
            return 'clean'
        }

        return 'inProgress'
    }

    /**
     * @returns {Promise<Object>}
     */
    async getSubmitValues() {
        let fields = await this.getFields(),
            Radio  = Neo.form.field.Radio,
            values = {},
            fieldName, key, ns, nsArray, value;

        fields.forEach(field => {
            value = field.getSubmitValue();

            if (field.name) {
                fieldName = field.name;

                if (field.formGroup) {
                    fieldName = field.formGroup + '.' + fieldName;
                }

                nsArray = fieldName.split('.');
                key     = nsArray.pop();
                ns      = Neo.nsWithArrays(nsArray, true, values);
            } else {
                key = field.id;
                ns  = values
            }

            // Ensuring that Radios will not return arrays
            if (Radio && field instanceof Radio) {
                // Only overwrite an existing value with a checked value
                if (Object.hasOwn(ns, key)) {
                    if (value !== field.uncheckedValue) {
                        ns[key] = value
                    }
                } else {
                    ns[key] = value
                }
            }
            /*
             * CheckBoxes need custom logic
             * => we only want to pass the uncheckedValue in case the field does not belong to a group
             * (multiple fields using the same name)
             */
            else if (Object.hasOwn(ns, key) && value !== undefined) {
                if (ns[key] === field.uncheckedValue) {
                    ns[key] = []
                } else if (!Array.isArray(ns[key])) {
                    ns[key] = [ns[key]]
                }

                value !== field.uncheckedValue && ns[key].unshift(value)
            } else if (value !== undefined) {
                ns[key] = value
            }
        });

        return values
    }

    /**
     * @deprecated in v7.x
     * @returns {Promise<Object>}
     */
    async getValues() {
        return this.getSubmitValues()
    }

    /**
     * Returns true in case no form field isValid() call returns false
     * @returns {Promise<Boolean>}
     */
    async isValid() {
        let fields = await this.getFields(),
            i      = 0,
            len    = fields.length;

        for (; i < len; i++) {
            if (!fields[i].isValid()) {
                return false
            }
        }

        return true
    }

    /**
     * Loads all not loaded items inside card layouts
     * @returns {Promise<Neo.component.Base[]>}
     */
    async loadModules() {
        let me       = this,
            modules  = me.findNotLoadedModules(),
            promises = [];

        modules.forEach(module => {
            promises.push(module.parent.layout.loadModule(module.item));
        });

        modules = await Promise.all(promises);

        return modules
    }

    /**
     * Resets field values by field name or field id.
     * Fields not included with a value will get reset to null.
     * @param {Object} [values]
     */
    async reset(values={}) {
        let me     = this,
            fields = await me.getFields(),
            path, value;

        fields.forEach(field => {
            path  = me.getFieldPath(field);
            value = Neo.nsWithArrays(path, false, values);

            field.reset(path ? value : null)
        })
    }

    /**
     * Set field configs by field name or field id
     * @param {Object} configs={}
     * @param {Boolean} suspendEvents=false
     */
    async setConfigs(configs={}, suspendEvents=false) {
        let me     = this,
            fields = await me.getFields(),
            fieldConfigs, isCheckBox, isRadio, path, value;

        fields.forEach(field => {
            path         = me.getFieldPath(field);
            fieldConfigs = Neo.nsWithArrays(path, false, configs);

            if (fieldConfigs) {
                if (suspendEvents) {
                    field.suspendEvents = true
                }

                isCheckBox = Neo.form.field?.CheckBox && field instanceof Neo.form.field.CheckBox;
                isRadio    = Neo.form.field?.Radio    && field instanceof Neo.form.field.Radio;
                value      = fieldConfigs.value;

                if (isCheckBox || isRadio) {
                    /*
                     * we want to only change the checked state, in case a value is set.
                     * since fields of the same group might need it too, we are cloning the fieldConfigs
                     */
                    if (Object.hasOwn(fieldConfigs, 'value')) {
                        fieldConfigs = Neo.clone(fieldConfigs, true);

                        if (isRadio) {
                            fieldConfigs.checked = field.value === value
                        } else if (isCheckBox) {
                            if (Neo.typeOf(value) === 'Array') {
                                if (value.includes(field.value)) {
                                    fieldConfigs.checked = true
                                }
                            } else {
                                fieldConfigs.checked = field.value === value
                            }
                        }

                        delete fieldConfigs.value
                    }
                }

                field.set(fieldConfigs)

                if (suspendEvents) {
                    delete field.suspendEvents
                }
            }
        })
    }

    /**
     * Set field values by field name or field id
     * @param {Object} values={}
     * @param {Boolean} suspendEvents=false
     */
    async setValues(values={}, suspendEvents=false) {
        let fields     = await this.getFields(),
            fieldPaths = [],
            path;

        // Grouped CheckBoxes & Radios can have the same path
        // => using NeoArray to ensure they only get added once
        fields.map(field => {
            path = field.getPath();
            path && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(fieldPaths, path)
        });

        values = Neo.clone(values, true);

        Container.adjustTreeLeaves(values, 'value', fieldPaths);

        await this.setConfigs(values, suspendEvents)
    }

    /**
     * Serializes the form container into a JSON-compatible object.
     * Includes the current values of all child fields.
     * @returns {Object}
     */
    toJSON() {
        let me     = this,
            Radio  = Neo.form.field?.Radio,
            values = {},
            fieldName, fields, key, ns, nsArray, value;

        // Synchronously get all currently instantiated child components
        fields = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getChildComponents(me);

        fields.forEach(field => {
            if (field.isBasefield) { // Check for isBasefield flag (auto-generated by ntype: 'basefield')
                value = field.getSubmitValue();

                if (field.name) {
                    fieldName = field.name;

                    if (field.formGroup) {
                        fieldName = field.formGroup + '.' + fieldName;
                    }

                    nsArray = fieldName.split('.');
                    key     = nsArray.pop();
                    ns      = Neo.nsWithArrays(nsArray, true, values);
                } else {
                    key = field.id;
                    ns  = values
                }

                // Ensuring that Radios will not return arrays
                if (Radio && field instanceof Radio) {
                    // Only overwrite an existing value with a checked value
                    if (Object.hasOwn(ns, key)) {
                        if (value !== field.uncheckedValue) {
                            ns[key] = value
                        }
                    } else {
                        ns[key] = value
                    }
                }
                /*
                 * CheckBoxes need custom logic
                 * => we only want to pass the uncheckedValue in case the field does not belong to a group
                 * (multiple fields using the same name)
                 */
                else if (Object.hasOwn(ns, key) && value !== undefined) {
                    if (ns[key] === field.uncheckedValue) {
                        ns[key] = []
                    } else if (!Array.isArray(ns[key])) {
                        ns[key] = [ns[key]]
                    }

                    value !== field.uncheckedValue && ns[key].unshift(value)
                } else if (value !== undefined) {
                    ns[key] = value
                }
            }
        });

        return {
            ...super.toJSON(),
            values
        }
    }

    /**
     * Updates the invalid state for all fields which have validate() implemented.
     * This can be useful for create-entity forms which show up "clean" until pressing a submit button.
     * @returns {Promise<Boolean>}
     */
    async validate() {
        let isValid = true,
            fields  = await this.getFields(),
            validField;

        fields.forEach(field => {
            validField = field.validate?.(false);

            if (validField === false) {
                isValid = false
            }
        });

        return isValid
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Container));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19mb3JtX0NvbnRhaW5lcl9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFEO0FBQ0M7QUFDRTtBQUNQOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyREFBYTtBQUNyQztBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVEsTUFBTSx5Q0FBeUM7QUFDM0U7QUFDQTtBQUNBLFNBQVMsNkNBQTZDO0FBQ3REOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxxQ0FBcUM7QUFDckM7O0FBRUE7QUFDQTtBQUNBLG9EQUFvRCxZQUFZLEdBQUcsSUFBSTtBQUN2RTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixRQUFRLEdBQUcsTUFBTTtBQUNwRztBQUNBLHFCQUFxQjtBQUNyQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsVUFBVTtBQUN6QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsYUFBYTtBQUMzQyxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixtQ0FBbUM7QUFDcEQ7QUFDQTtBQUNBOztBQUVBLHFCQUFxQiw4REFBZ0I7QUFDckM7O0FBRUE7QUFDQSxpQ0FBaUMsNERBQVM7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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBLGlFQUFlLHlCQUF5QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9mb3JtL0NvbnRhaW5lci5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2VDb250YWluZXIgICAgZnJvbSAnLi4vY29udGFpbmVyL0Jhc2UubWpzJztcbmltcG9ydCBCYXNlRmllbGQgICAgICAgIGZyb20gJy4uL2Zvcm0vZmllbGQvQmFzZS5tanMnO1xuaW1wb3J0IENvbXBvbmVudE1hbmFnZXIgZnJvbSAnLi4vbWFuYWdlci9Db21wb25lbnQubWpzJztcbmltcG9ydCBOZW9BcnJheSAgICAgICAgIGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmZvcm0uQ29udGFpbmVyXG4gKiBAZXh0ZW5kcyBOZW8uY29udGFpbmVyLkJhc2VcbiAqL1xuY2xhc3MgQ29udGFpbmVyIGV4dGVuZHMgQmFzZUNvbnRhaW5lciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZm9ybS5Db250YWluZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5mb3JtLkNvbnRhaW5lcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdmb3JtLWNvbnRhaW5lcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdmb3JtLWNvbnRhaW5lcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1mb3JtLWNvbnRhaW5lciddLFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1mb3JtLWNvbnRhaW5lciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSB2ZG9tPXt0YWc6ICdmb3JtJyxjbjpbXSxvbnN1Ym1pdDoncmV0dXJuIGZhbHNlOyd9XG4gICAgICAgICAqL1xuICAgICAgICB2ZG9tOlxuICAgICAgICB7dGFnOiAnZm9ybScsIGNuOiBbXSwgb25zdWJtaXQ6ICdyZXR1cm4gZmFsc2U7J31cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdXNlZCBieSBzZXRWYWx1ZXMoKSB3aGljaCB3cmFwcyB0aGUgbGVhdmVzIG9mIGEgdHJlZSBzdHJ1Y3R1cmUgaW50byBhIG5ldyBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZ05hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBmaWVsZFBhdGhzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGN1cnJlbnRQYXRoPScnXG4gICAgICovXG4gICAgc3RhdGljIGFkanVzdFRyZWVMZWF2ZXModmFsdWVzPXt9LCBjb25maWdOYW1lLCBmaWVsZFBhdGhzLCBjdXJyZW50UGF0aD0nJykge1xuICAgICAgICBsZXQgYXNzaWduLCBuZXdQYXRoLCB0eXBlO1xuXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHZhbHVlcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBhc3NpZ24gID0gdHJ1ZTtcbiAgICAgICAgICAgIG5ld1BhdGggPSBjdXJyZW50UGF0aCA9PT0gJycgPyBrZXkgOiBgJHtjdXJyZW50UGF0aH0uJHtrZXl9YDtcbiAgICAgICAgICAgIHR5cGUgICAgPSBOZW8udHlwZU9mKHZhbHVlKTtcblxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdBcnJheScgfHwgdHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBhc3NpZ24gPSBmaWVsZFBhdGhzLmluY2x1ZGVzKG5ld1BhdGgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdBcnJheScpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChOZW8udHlwZU9mKGl0ZW0pID09PSAnT2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRqdXN0VHJlZUxlYXZlcyhpdGVtLCBjb25maWdOYW1lLCBmaWVsZFBhdGhzLCBgJHtuZXdQYXRofVske2luZGV4fV1gKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGp1c3RUcmVlTGVhdmVzKHZhbHVlLCBjb25maWdOYW1lLCBmaWVsZFBhdGhzLCBuZXdQYXRoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFzc2lnbikge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IGNvbmZpZ05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzW2tleV0gPSB2YWx1ZVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlc1trZXldID0ge1tjb25maWdOYW1lXTogdmFsdWV9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmNvbnRhaW5lci5CYXNlfSBwYXJlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBtb2R1bGVzXG4gICAgICogQHJldHVybnMge09iamVjdFtdfVxuICAgICAqL1xuICAgIGZpbmROb3RMb2FkZWRNb2R1bGVzKHBhcmVudD10aGlzLCBtb2R1bGVzPVtdKSB7XG4gICAgICAgIHBhcmVudC5pdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaWYgKE5lby50eXBlT2YoaXRlbS5tb2R1bGUpID09PSAnRnVuY3Rpb24nICYmICFpdGVtLmlzTG9hZGluZykge1xuICAgICAgICAgICAgICAgIG1vZHVsZXMucHVzaCh7aXRlbSwgcGFyZW50fSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlbS5pdGVtcyAmJiB0aGlzLmZpbmROb3RMb2FkZWRNb2R1bGVzKGl0ZW0sIG1vZHVsZXMpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBtb2R1bGVzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRWl0aGVyIHBhc3MgYSBmaWVsZCBuYW1lIG9yIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxOZW8uZm9ybS5maWVsZC5CYXNlfG51bGw+fSBmaWVsZHNcbiAgICAgKi9cbiAgICBhc3luYyBnZXRGaWVsZChuYW1lKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1vZHVsZXMoKTtcblxuICAgICAgICBsZXQgZmllbGRzID0gQ29tcG9uZW50TWFuYWdlci5nZXRDaGlsZENvbXBvbmVudHModGhpcyksXG4gICAgICAgICAgICBmaWVsZDtcblxuICAgICAgICBmb3IgKGZpZWxkIG9mIGZpZWxkcykge1xuICAgICAgICAgICAgaWYgKGZpZWxkIGluc3RhbmNlb2YgQmFzZUZpZWxkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkLm5hbWUgPT09IG5hbWUgfHwgZmllbGQuaWQgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5mb3JtLmZpZWxkLkJhc2V9IGZpZWxkXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRGaWVsZFBhdGgoZmllbGQpIHtcbiAgICAgICAgbGV0IHBhdGggPSBmaWVsZC5mb3JtR3JvdXAgPyBmaWVsZC5mb3JtR3JvdXAuc3BsaXQoJy4nKSA6IFtdO1xuXG4gICAgICAgIHBhdGgucHVzaChmaWVsZC5uYW1lIHx8IGZpZWxkLmlkKTtcblxuICAgICAgICByZXR1cm4gcGF0aC5qb2luKCcuJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxOZW8uZm9ybS5maWVsZC5CYXNlW10+fSBmaWVsZHNcbiAgICAgKi9cbiAgICBhc3luYyBnZXRGaWVsZHMoKSB7XG4gICAgICAgIGxldCBmaWVsZHMgPSBbXTtcblxuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNb2R1bGVzKCk7XG5cbiAgICAgICAgQ29tcG9uZW50TWFuYWdlci5nZXRDaGlsZENvbXBvbmVudHModGhpcykuZm9yRWFjaChmaWVsZCA9PiB7XG4gICAgICAgICAgICBmaWVsZCBpbnN0YW5jZW9mIEJhc2VGaWVsZCAmJiBmaWVsZHMucHVzaChmaWVsZClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZpZWxkc1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiBvbmUgb2YgdGhlIGZvbGxvd2luZyBzdGF0ZXM6XG4gICAgICogLSBjbGVhbiAgICAgID0+IGFsbCBmaWVsZHMgYXJlIGNsZWFuICh1bnRvdWNoZWQpXG4gICAgICogLSBpbnZhbGlkICAgID0+IGF0IGxlYXN0IG9uZSBmaWVsZCBpcyBpbnZhbGlkXG4gICAgICogLSB2YWxpZCAgICAgID0+IGFsbCByZXF1aXJlZCBmaWVsZHMgYXJlIHZhbGlkXG4gICAgICogLSBpblByb2dyZXNzID0+IGF0IGxlYXN0IG9uZSBmaWVsZCBpcyB2YWxpZCwgYXQgbGVhc3Qgb25lIGZpZWxkIGlzIGNsZWFuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8U3RyaW5nPn1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRGb3JtU3RhdGUoKSB7XG4gICAgICAgIGxldCBmaWVsZHMgICAgICAgICAgID0gYXdhaXQgdGhpcy5nZXRGaWVsZHMoKSxcbiAgICAgICAgICAgIGkgICAgICAgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgaGFzQ2xlYW5GaWVsZHMgICA9IGZhbHNlLFxuICAgICAgICAgICAgaGFzQWxlcnRGaWVsZHMgICA9IGZhbHNlLFxuICAgICAgICAgICAgaGFzSW52YWxpZEZpZWxkcyA9IGZhbHNlLFxuICAgICAgICAgICAgaGFzVW5jbGVhbkZpZWxkcyA9IGZhbHNlLFxuICAgICAgICAgICAgaGFzVmFsaWRGaWVsZHMgICA9IGZhbHNlLFxuICAgICAgICAgICAgbGVuICAgICAgICAgICAgICA9IGZpZWxkcy5sZW5ndGgsXG4gICAgICAgICAgICBmaWVsZCwgaXNDbGVhbiwgaXNWYWxpZDtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBmaWVsZCAgID0gZmllbGRzW2ldO1xuICAgICAgICAgICAgaXNDbGVhbiA9IGZpZWxkLmNsZWFuO1xuICAgICAgICAgICAgaXNWYWxpZCA9IGZpZWxkLmlzVmFsaWQoKTtcblxuICAgICAgICAgICAgaWYgKCFpc0NsZWFuICYmICFpc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkLmlzRW1wdHlBbmRSZXF1aXJlZD8uKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzQWxlcnRGaWVsZHMgPSB0cnVlXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdpbnZhbGlkJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgIGhhc1ZhbGlkRmllbGRzID0gdHJ1ZVxuICAgICAgICAgICAgfSBlbHNlIGlmICghaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZC5pc0VtcHR5QW5kUmVxdWlyZWQ/LigpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc0FsZXJ0RmllbGRzID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc0ludmFsaWRGaWVsZHMgPSB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNDbGVhbikge1xuICAgICAgICAgICAgICAgIGhhc0NsZWFuRmllbGRzID0gdHJ1ZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBoYXNVbmNsZWFuRmllbGRzID0gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFoYXNBbGVydEZpZWxkcyAmJiAhaGFzSW52YWxpZEZpZWxkcykge1xuICAgICAgICAgICAgcmV0dXJuICd2YWxpZCdcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGFzQWxlcnRGaWVsZHMgJiYgaGFzQ2xlYW5GaWVsZHMgJiYgIWhhc1VuY2xlYW5GaWVsZHMpIHtcbiAgICAgICAgICAgIHJldHVybiAnY2xlYW4nXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJ2luUHJvZ3Jlc3MnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRTdWJtaXRWYWx1ZXMoKSB7XG4gICAgICAgIGxldCBmaWVsZHMgPSBhd2FpdCB0aGlzLmdldEZpZWxkcygpLFxuICAgICAgICAgICAgUmFkaW8gID0gTmVvLmZvcm0uZmllbGQuUmFkaW8sXG4gICAgICAgICAgICB2YWx1ZXMgPSB7fSxcbiAgICAgICAgICAgIGZpZWxkTmFtZSwga2V5LCBucywgbnNBcnJheSwgdmFsdWU7XG5cbiAgICAgICAgZmllbGRzLmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgICAgICAgdmFsdWUgPSBmaWVsZC5nZXRTdWJtaXRWYWx1ZSgpO1xuXG4gICAgICAgICAgICBpZiAoZmllbGQubmFtZSkge1xuICAgICAgICAgICAgICAgIGZpZWxkTmFtZSA9IGZpZWxkLm5hbWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoZmllbGQuZm9ybUdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkTmFtZSA9IGZpZWxkLmZvcm1Hcm91cCArICcuJyArIGZpZWxkTmFtZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBuc0FycmF5ID0gZmllbGROYW1lLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICAgICAga2V5ICAgICA9IG5zQXJyYXkucG9wKCk7XG4gICAgICAgICAgICAgICAgbnMgICAgICA9IE5lby5uc1dpdGhBcnJheXMobnNBcnJheSwgdHJ1ZSwgdmFsdWVzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAga2V5ID0gZmllbGQuaWQ7XG4gICAgICAgICAgICAgICAgbnMgID0gdmFsdWVzXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEVuc3VyaW5nIHRoYXQgUmFkaW9zIHdpbGwgbm90IHJldHVybiBhcnJheXNcbiAgICAgICAgICAgIGlmIChSYWRpbyAmJiBmaWVsZCBpbnN0YW5jZW9mIFJhZGlvKSB7XG4gICAgICAgICAgICAgICAgLy8gT25seSBvdmVyd3JpdGUgYW4gZXhpc3RpbmcgdmFsdWUgd2l0aCBhIGNoZWNrZWQgdmFsdWVcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihucywga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IGZpZWxkLnVuY2hlY2tlZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuc1trZXldID0gdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5zW2tleV0gPSB2YWx1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBDaGVja0JveGVzIG5lZWQgY3VzdG9tIGxvZ2ljXG4gICAgICAgICAgICAgKiA9PiB3ZSBvbmx5IHdhbnQgdG8gcGFzcyB0aGUgdW5jaGVja2VkVmFsdWUgaW4gY2FzZSB0aGUgZmllbGQgZG9lcyBub3QgYmVsb25nIHRvIGEgZ3JvdXBcbiAgICAgICAgICAgICAqIChtdWx0aXBsZSBmaWVsZHMgdXNpbmcgdGhlIHNhbWUgbmFtZSlcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZWxzZSBpZiAoT2JqZWN0Lmhhc093bihucywga2V5KSAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5zW2tleV0gPT09IGZpZWxkLnVuY2hlY2tlZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5zW2tleV0gPSBbXVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkobnNba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbnNba2V5XSA9IFtuc1trZXldXVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhbHVlICE9PSBmaWVsZC51bmNoZWNrZWRWYWx1ZSAmJiBuc1trZXldLnVuc2hpZnQodmFsdWUpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBuc1trZXldID0gdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIGluIHY3LnhcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fVxuICAgICAqL1xuICAgIGFzeW5jIGdldFZhbHVlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3VibWl0VmFsdWVzKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaW4gY2FzZSBubyBmb3JtIGZpZWxkIGlzVmFsaWQoKSBjYWxsIHJldHVybnMgZmFsc2VcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCb29sZWFuPn1cbiAgICAgKi9cbiAgICBhc3luYyBpc1ZhbGlkKCkge1xuICAgICAgICBsZXQgZmllbGRzID0gYXdhaXQgdGhpcy5nZXRGaWVsZHMoKSxcbiAgICAgICAgICAgIGkgICAgICA9IDAsXG4gICAgICAgICAgICBsZW4gICAgPSBmaWVsZHMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghZmllbGRzW2ldLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhbGwgbm90IGxvYWRlZCBpdGVtcyBpbnNpZGUgY2FyZCBsYXlvdXRzXG4gICAgICogQHJldHVybnMge1Byb21pc2U8TmVvLmNvbXBvbmVudC5CYXNlW10+fVxuICAgICAqL1xuICAgIGFzeW5jIGxvYWRNb2R1bGVzKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgbW9kdWxlcyAgPSBtZS5maW5kTm90TG9hZGVkTW9kdWxlcygpLFxuICAgICAgICAgICAgcHJvbWlzZXMgPSBbXTtcblxuICAgICAgICBtb2R1bGVzLmZvckVhY2gobW9kdWxlID0+IHtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2gobW9kdWxlLnBhcmVudC5sYXlvdXQubG9hZE1vZHVsZShtb2R1bGUuaXRlbSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICBtb2R1bGVzID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuXG4gICAgICAgIHJldHVybiBtb2R1bGVzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIGZpZWxkIHZhbHVlcyBieSBmaWVsZCBuYW1lIG9yIGZpZWxkIGlkLlxuICAgICAqIEZpZWxkcyBub3QgaW5jbHVkZWQgd2l0aCBhIHZhbHVlIHdpbGwgZ2V0IHJlc2V0IHRvIG51bGwuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFt2YWx1ZXNdXG4gICAgICovXG4gICAgYXN5bmMgcmVzZXQodmFsdWVzPXt9KSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZmllbGRzID0gYXdhaXQgbWUuZ2V0RmllbGRzKCksXG4gICAgICAgICAgICBwYXRoLCB2YWx1ZTtcblxuICAgICAgICBmaWVsZHMuZm9yRWFjaChmaWVsZCA9PiB7XG4gICAgICAgICAgICBwYXRoICA9IG1lLmdldEZpZWxkUGF0aChmaWVsZCk7XG4gICAgICAgICAgICB2YWx1ZSA9IE5lby5uc1dpdGhBcnJheXMocGF0aCwgZmFsc2UsIHZhbHVlcyk7XG5cbiAgICAgICAgICAgIGZpZWxkLnJlc2V0KHBhdGggPyB2YWx1ZSA6IG51bGwpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IGZpZWxkIGNvbmZpZ3MgYnkgZmllbGQgbmFtZSBvciBmaWVsZCBpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdzPXt9XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzdXNwZW5kRXZlbnRzPWZhbHNlXG4gICAgICovXG4gICAgYXN5bmMgc2V0Q29uZmlncyhjb25maWdzPXt9LCBzdXNwZW5kRXZlbnRzPWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZmllbGRzID0gYXdhaXQgbWUuZ2V0RmllbGRzKCksXG4gICAgICAgICAgICBmaWVsZENvbmZpZ3MsIGlzQ2hlY2tCb3gsIGlzUmFkaW8sIHBhdGgsIHZhbHVlO1xuXG4gICAgICAgIGZpZWxkcy5mb3JFYWNoKGZpZWxkID0+IHtcbiAgICAgICAgICAgIHBhdGggICAgICAgICA9IG1lLmdldEZpZWxkUGF0aChmaWVsZCk7XG4gICAgICAgICAgICBmaWVsZENvbmZpZ3MgPSBOZW8ubnNXaXRoQXJyYXlzKHBhdGgsIGZhbHNlLCBjb25maWdzKTtcblxuICAgICAgICAgICAgaWYgKGZpZWxkQ29uZmlncykge1xuICAgICAgICAgICAgICAgIGlmIChzdXNwZW5kRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkLnN1c3BlbmRFdmVudHMgPSB0cnVlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaXNDaGVja0JveCA9IE5lby5mb3JtLmZpZWxkPy5DaGVja0JveCAmJiBmaWVsZCBpbnN0YW5jZW9mIE5lby5mb3JtLmZpZWxkLkNoZWNrQm94O1xuICAgICAgICAgICAgICAgIGlzUmFkaW8gICAgPSBOZW8uZm9ybS5maWVsZD8uUmFkaW8gICAgJiYgZmllbGQgaW5zdGFuY2VvZiBOZW8uZm9ybS5maWVsZC5SYWRpbztcbiAgICAgICAgICAgICAgICB2YWx1ZSAgICAgID0gZmllbGRDb25maWdzLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzQ2hlY2tCb3ggfHwgaXNSYWRpbykge1xuICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgKiB3ZSB3YW50IHRvIG9ubHkgY2hhbmdlIHRoZSBjaGVja2VkIHN0YXRlLCBpbiBjYXNlIGEgdmFsdWUgaXMgc2V0LlxuICAgICAgICAgICAgICAgICAgICAgKiBzaW5jZSBmaWVsZHMgb2YgdGhlIHNhbWUgZ3JvdXAgbWlnaHQgbmVlZCBpdCB0b28sIHdlIGFyZSBjbG9uaW5nIHRoZSBmaWVsZENvbmZpZ3NcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKGZpZWxkQ29uZmlncywgJ3ZhbHVlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkQ29uZmlncyA9IE5lby5jbG9uZShmaWVsZENvbmZpZ3MsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNSYWRpbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkQ29uZmlncy5jaGVja2VkID0gZmllbGQudmFsdWUgPT09IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzQ2hlY2tCb3gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoTmVvLnR5cGVPZih2YWx1ZSkgPT09ICdBcnJheScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKGZpZWxkLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRDb25maWdzLmNoZWNrZWQgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZENvbmZpZ3MuY2hlY2tlZCA9IGZpZWxkLnZhbHVlID09PSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGZpZWxkQ29uZmlncy52YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZmllbGQuc2V0KGZpZWxkQ29uZmlncylcblxuICAgICAgICAgICAgICAgIGlmIChzdXNwZW5kRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBmaWVsZC5zdXNwZW5kRXZlbnRzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBmaWVsZCB2YWx1ZXMgYnkgZmllbGQgbmFtZSBvciBmaWVsZCBpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXM9e31cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHN1c3BlbmRFdmVudHM9ZmFsc2VcbiAgICAgKi9cbiAgICBhc3luYyBzZXRWYWx1ZXModmFsdWVzPXt9LCBzdXNwZW5kRXZlbnRzPWZhbHNlKSB7XG4gICAgICAgIGxldCBmaWVsZHMgICAgID0gYXdhaXQgdGhpcy5nZXRGaWVsZHMoKSxcbiAgICAgICAgICAgIGZpZWxkUGF0aHMgPSBbXSxcbiAgICAgICAgICAgIHBhdGg7XG5cbiAgICAgICAgLy8gR3JvdXBlZCBDaGVja0JveGVzICYgUmFkaW9zIGNhbiBoYXZlIHRoZSBzYW1lIHBhdGhcbiAgICAgICAgLy8gPT4gdXNpbmcgTmVvQXJyYXkgdG8gZW5zdXJlIHRoZXkgb25seSBnZXQgYWRkZWQgb25jZVxuICAgICAgICBmaWVsZHMubWFwKGZpZWxkID0+IHtcbiAgICAgICAgICAgIHBhdGggPSBmaWVsZC5nZXRQYXRoKCk7XG4gICAgICAgICAgICBwYXRoICYmIE5lb0FycmF5LmFkZChmaWVsZFBhdGhzLCBwYXRoKVxuICAgICAgICB9KTtcblxuICAgICAgICB2YWx1ZXMgPSBOZW8uY2xvbmUodmFsdWVzLCB0cnVlKTtcblxuICAgICAgICBDb250YWluZXIuYWRqdXN0VHJlZUxlYXZlcyh2YWx1ZXMsICd2YWx1ZScsIGZpZWxkUGF0aHMpO1xuXG4gICAgICAgIGF3YWl0IHRoaXMuc2V0Q29uZmlncyh2YWx1ZXMsIHN1c3BlbmRFdmVudHMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0aGUgZm9ybSBjb250YWluZXIgaW50byBhIEpTT04tY29tcGF0aWJsZSBvYmplY3QuXG4gICAgICogSW5jbHVkZXMgdGhlIGN1cnJlbnQgdmFsdWVzIG9mIGFsbCBjaGlsZCBmaWVsZHMuXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgUmFkaW8gID0gTmVvLmZvcm0uZmllbGQ/LlJhZGlvLFxuICAgICAgICAgICAgdmFsdWVzID0ge30sXG4gICAgICAgICAgICBmaWVsZE5hbWUsIGZpZWxkcywga2V5LCBucywgbnNBcnJheSwgdmFsdWU7XG5cbiAgICAgICAgLy8gU3luY2hyb25vdXNseSBnZXQgYWxsIGN1cnJlbnRseSBpbnN0YW50aWF0ZWQgY2hpbGQgY29tcG9uZW50c1xuICAgICAgICBmaWVsZHMgPSBDb21wb25lbnRNYW5hZ2VyLmdldENoaWxkQ29tcG9uZW50cyhtZSk7XG5cbiAgICAgICAgZmllbGRzLmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgICAgICAgaWYgKGZpZWxkLmlzQmFzZWZpZWxkKSB7IC8vIENoZWNrIGZvciBpc0Jhc2VmaWVsZCBmbGFnIChhdXRvLWdlbmVyYXRlZCBieSBudHlwZTogJ2Jhc2VmaWVsZCcpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBmaWVsZC5nZXRTdWJtaXRWYWx1ZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGROYW1lID0gZmllbGQubmFtZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQuZm9ybUdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZE5hbWUgPSBmaWVsZC5mb3JtR3JvdXAgKyAnLicgKyBmaWVsZE5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBuc0FycmF5ID0gZmllbGROYW1lLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICAgICAgICAgIGtleSAgICAgPSBuc0FycmF5LnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBucyAgICAgID0gTmVvLm5zV2l0aEFycmF5cyhuc0FycmF5LCB0cnVlLCB2YWx1ZXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGZpZWxkLmlkO1xuICAgICAgICAgICAgICAgICAgICBucyAgPSB2YWx1ZXNcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBFbnN1cmluZyB0aGF0IFJhZGlvcyB3aWxsIG5vdCByZXR1cm4gYXJyYXlzXG4gICAgICAgICAgICAgICAgaWYgKFJhZGlvICYmIGZpZWxkIGluc3RhbmNlb2YgUmFkaW8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSBvdmVyd3JpdGUgYW4gZXhpc3RpbmcgdmFsdWUgd2l0aCBhIGNoZWNrZWQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd24obnMsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gZmllbGQudW5jaGVja2VkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuc1trZXldID0gdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5zW2tleV0gPSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogQ2hlY2tCb3hlcyBuZWVkIGN1c3RvbSBsb2dpY1xuICAgICAgICAgICAgICAgICAqID0+IHdlIG9ubHkgd2FudCB0byBwYXNzIHRoZSB1bmNoZWNrZWRWYWx1ZSBpbiBjYXNlIHRoZSBmaWVsZCBkb2VzIG5vdCBiZWxvbmcgdG8gYSBncm91cFxuICAgICAgICAgICAgICAgICAqIChtdWx0aXBsZSBmaWVsZHMgdXNpbmcgdGhlIHNhbWUgbmFtZSlcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChPYmplY3QuaGFzT3duKG5zLCBrZXkpICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5zW2tleV0gPT09IGZpZWxkLnVuY2hlY2tlZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuc1trZXldID0gW11cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShuc1trZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnNba2V5XSA9IFtuc1trZXldXVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgIT09IGZpZWxkLnVuY2hlY2tlZFZhbHVlICYmIG5zW2tleV0udW5zaGlmdCh2YWx1ZSlcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbnNba2V5XSA9IHZhbHVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXG4gICAgICAgICAgICB2YWx1ZXNcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGludmFsaWQgc3RhdGUgZm9yIGFsbCBmaWVsZHMgd2hpY2ggaGF2ZSB2YWxpZGF0ZSgpIGltcGxlbWVudGVkLlxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3IgY3JlYXRlLWVudGl0eSBmb3JtcyB3aGljaCBzaG93IHVwIFwiY2xlYW5cIiB1bnRpbCBwcmVzc2luZyBhIHN1Ym1pdCBidXR0b24uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Qm9vbGVhbj59XG4gICAgICovXG4gICAgYXN5bmMgdmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCBpc1ZhbGlkID0gdHJ1ZSxcbiAgICAgICAgICAgIGZpZWxkcyAgPSBhd2FpdCB0aGlzLmdldEZpZWxkcygpLFxuICAgICAgICAgICAgdmFsaWRGaWVsZDtcblxuICAgICAgICBmaWVsZHMuZm9yRWFjaChmaWVsZCA9PiB7XG4gICAgICAgICAgICB2YWxpZEZpZWxkID0gZmllbGQudmFsaWRhdGU/LihmYWxzZSk7XG5cbiAgICAgICAgICAgIGlmICh2YWxpZEZpZWxkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gaXNWYWxpZFxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ29udGFpbmVyKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==