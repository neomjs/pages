"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_form_Container_mjs"],{

/***/ "./src/form/Container.mjs":
/*!********************************!*\
  !*** ./src/form/Container.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _form_field_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../form/field/Base.mjs */ "./src/form/field/Base.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../manager/Component.mjs */ "./src/manager/Component.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");





/**
 * @class Neo.form.Container
 * @extends Neo.container.Base
 */
class Container extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.form.Container'
         * @protected
         */
        className: 'Neo.form.Container',
        /**
         * @member {String} ntype='form-container'
         * @protected
         */
        ntype: 'form-container',
        /**
         * @member {String[]} baseCls=['neo-form-container'],
         * @protected
         */
        baseCls: ['neo-form-container'],
        /**
         * @member {Object} vdom={tag: 'form',cn:[],onsubmit:'return false;'}
         */
        vdom:
        {tag: 'form', cn: [], onsubmit: 'return false;'}
    }

    /**
     * Helper function used by setValues() which wraps the leaves of a tree structure into a new property.
     * @param {Object} values
     * @param {String} configName
     * @param {String[]} fieldPaths
     * @param {String} currentPath=''
     */
    static adjustTreeLeaves(values={}, configName, fieldPaths, currentPath='') {
        let assign, newPath, type;

        Object.entries(values).forEach(([key, value]) => {
            assign  = true;
            newPath = currentPath === '' ? key : `${currentPath}.${key}`;
            type    = Neo.typeOf(value);

            if (type === 'Array' || type === 'Object') {
                assign = fieldPaths.includes(newPath);

                if (type === 'Array') {
                    value.forEach((item, index) => {
                        if (Neo.typeOf(item) === 'Object') {
                            this.adjustTreeLeaves(item, configName, fieldPaths, `${newPath}[${index}]`)
                        }
                    })
                } else if (type === 'Object') {
                    this.adjustTreeLeaves(value, configName, fieldPaths, newPath)
                }
            }

            if (assign) {
                if (key === configName) {
                    values[key] = value
                } else {
                    values[key] = {[configName]: value}
                }
            }
        })
    }

    /**
     * @param {Neo.container.Base} parent
     * @param {Object[]} modules
     * @returns {Object[]}
     */
    findNotLoadedModules(parent=this, modules=[]) {
        parent.items.forEach(item => {
            if (Neo.typeOf(item.module) === 'Function' && !item.isLoading) {
                modules.push({item, parent})
            } else {
                item.items && this.findNotLoadedModules(item, modules)
            }
        });

        return modules
    }

    /**
     * Either pass a field name or id
     * @param {String} name
     * @returns {Promise<Neo.form.field.Base|null>} fields
     */
    async getField(name) {
        await this.loadModules();

        let fields = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getChildComponents(this),
            field;

        for (field of fields) {
            if (field instanceof _form_field_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]) {
                if (field.name === name || field.id === name) {
                    return field
                }
            }
        }

        return null
    }

    /**
     * @param {Neo.form.field.Base} field
     * @returns {String}
     */
    getFieldPath(field) {
        let path = field.formGroup ? field.formGroup.split('.') : [];

        path.push(field.name || field.id);

        return path.join('.')
    }

    /**
     * @returns {Promise<Neo.form.field.Base[]>} fields
     */
    async getFields() {
        let fields = [];

        await this.loadModules();

        _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getChildComponents(this).forEach(field => {
            field instanceof _form_field_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] && fields.push(field)
        });

        return fields
    }


    /**
     * This function will return one of the following states:
     * - clean      => all fields are clean (untouched)
     * - invalid    => at least one field is invalid
     * - valid      => all required fields are valid
     * - inProgress => at least one field is valid, at least one field is clean
     * @returns {Promise<String>}
     */
    async getFormState() {
        let fields           = await this.getFields(),
            i                = 0,
            hasCleanFields   = false,
            hasAlertFields   = false,
            hasInvalidFields = false,
            hasUncleanFields = false,
            hasValidFields   = false,
            len              = fields.length,
            field, isClean, isValid;

        for (; i < len; i++) {
            field   = fields[i];
            isClean = field.clean;
            isValid = field.isValid();

            if (!isClean && !isValid) {
                if (field.isEmptyAndRequired?.()) {
                    hasAlertFields = true
                } else {
                    return 'invalid'
                }
            } else if (isValid) {
                hasValidFields = true
            } else if (!isValid) {
                if (field.isEmptyAndRequired?.()) {
                    hasAlertFields = true
                } else {
                    hasInvalidFields = true
                }
            }

            if (isClean) {
                hasCleanFields = true
            } else {
                hasUncleanFields = true
            }
        }

        if (!hasAlertFields && !hasInvalidFields) {
            return 'valid'
        }

        if (!hasAlertFields && hasCleanFields && !hasUncleanFields) {
            return 'clean'
        }

        return 'inProgress'
    }

    /**
     * @returns {Promise<Object>}
     */
    async getSubmitValues() {
        let fields = await this.getFields(),
            Radio  = Neo.form.field.Radio,
            values = {},
            fieldName, key, ns, nsArray, value;

        fields.forEach(field => {
            value = field.getSubmitValue();

            if (field.name) {
                fieldName = field.name;

                if (field.formGroup) {
                    fieldName = field.formGroup + '.' + fieldName;
                }

                nsArray = fieldName.split('.');
                key     = nsArray.pop();
                ns      = Neo.nsWithArrays(nsArray, true, values);
            } else {
                key = field.id;
                ns  = values
            }

            // Ensuring that Radios will not return arrays
            if (Radio && field instanceof Radio) {
                // Only overwrite an existing value with a checked value
                if (Object.hasOwn(ns, key)) {
                    if (value !== field.uncheckedValue) {
                        ns[key] = value
                    }
                } else {
                    ns[key] = value
                }
            }
            /*
             * CheckBoxes need custom logic
             * => we only want to pass the uncheckedValue in case the field does not belong to a group
             * (multiple fields using the same name)
             */
            else if (Object.hasOwn(ns, key) && value !== undefined) {
                if (ns[key] === field.uncheckedValue) {
                    ns[key] = []
                } else if (!Array.isArray(ns[key])) {
                    ns[key] = [ns[key]]
                }

                value !== field.uncheckedValue && ns[key].unshift(value)
            } else if (value !== undefined) {
                ns[key] = value
            }
        });

        return values
    }

    /**
     * @deprecated in v7.x
     * @returns {Promise<Object>}
     */
    async getValues() {
        return this.getSubmitValues()
    }

    /**
     * Returns true in case no form field isValid() call returns false
     * @returns {Promise<Boolean>}
     */
    async isValid() {
        let fields = await this.getFields(),
            i      = 0,
            len    = fields.length;

        for (; i < len; i++) {
            if (!fields[i].isValid()) {
                return false
            }
        }

        return true
    }

    /**
     * Loads all not loaded items inside card layouts
     * @returns {Promise<Neo.component.Base[]>}
     */
    async loadModules() {
        let me       = this,
            modules  = me.findNotLoadedModules(),
            promises = [];

        modules.forEach(module => {
            promises.push(module.parent.layout.loadModule(module.item));
        });

        modules = await Promise.all(promises);

        return modules
    }

    /**
     * Resets field values by field name or field id.
     * Fields not included with a value will get reset to null.
     * @param {Object} [values]
     */
    async reset(values={}) {
        let me     = this,
            fields = await me.getFields(),
            path, value;

        fields.forEach(field => {
            path  = me.getFieldPath(field);
            value = Neo.nsWithArrays(path, false, values);

            field.reset(path ? value : null)
        })
    }

    /**
     * Set field configs by field name or field id
     * @param {Object} configs={}
     * @param {Boolean} suspendEvents=false
     */
    async setConfigs(configs={}, suspendEvents=false) {
        let me     = this,
            fields = await me.getFields(),
            fieldConfigs, isCheckBox, isRadio, path, value;

        fields.forEach(field => {
            path         = me.getFieldPath(field);
            fieldConfigs = Neo.nsWithArrays(path, false, configs);

            if (fieldConfigs) {
                if (suspendEvents) {
                    field.suspendEvents = true
                }

                isCheckBox = Neo.form.field?.CheckBox && field instanceof Neo.form.field.CheckBox;
                isRadio    = Neo.form.field?.Radio    && field instanceof Neo.form.field.Radio;
                value      = fieldConfigs.value;

                if (isCheckBox || isRadio) {
                    /*
                     * we want to only change the checked state, in case a value is set.
                     * since fields of the same group might need it too, we are cloning the fieldConfigs
                     */
                    if (Object.hasOwn(fieldConfigs, 'value')) {
                        fieldConfigs = Neo.clone(fieldConfigs, true);

                        if (isRadio) {
                            fieldConfigs.checked = field.value === value
                        } else if (isCheckBox) {
                            if (Neo.typeOf(value) === 'Array') {
                                if (value.includes(field.value)) {
                                    fieldConfigs.checked = true
                                }
                            } else {
                                fieldConfigs.checked = field.value === value
                            }
                        }

                        delete fieldConfigs.value
                    }
                }

                field.set(fieldConfigs)

                if (suspendEvents) {
                    delete field.suspendEvents
                }
            }
        })
    }

    /**
     * Set field values by field name or field id
     * @param {Object} values={}
     * @param {Boolean} suspendEvents=false
     */
    async setValues(values={}, suspendEvents=false) {
        let fields     = await this.getFields(),
            fieldPaths = [],
            path;

        // Grouped CheckBoxes & Radios can have the same path
        // => using NeoArray to ensure they only get added once
        fields.map(field => {
            path = field.getPath();
            path && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(fieldPaths, path)
        });

        values = Neo.clone(values, true);

        Container.adjustTreeLeaves(values, 'value', fieldPaths);

        await this.setConfigs(values, suspendEvents)
    }

    /**
     * Updates the invalid state for all fields which have validate() implemented.
     * This can be useful for create-entity forms which show up "clean" until pressing a submit button.
     * @returns {Promise<Boolean>}
     */
    async validate() {
        let isValid = true,
            fields  = await this.getFields(),
            validField;

        fields.forEach(field => {
            validField = field.validate?.(false);

            if (!validField) {
                isValid = false
            }
        });

        return isValid
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Container));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19mb3JtX0NvbnRhaW5lcl9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUQ7QUFDQztBQUNFO0FBQ1A7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJEQUFhO0FBQ3JDO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUSxNQUFNLHlDQUF5QztBQUMzRTtBQUNBO0FBQ0EsU0FBUyw2Q0FBNkM7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLHFDQUFxQztBQUNyQzs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9ELFlBQVksR0FBRyxJQUFJO0FBQ3ZFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLFFBQVEsR0FBRyxNQUFNO0FBQ3BHO0FBQ0EscUJBQXFCO0FBQ3JCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLG1DQUFtQztBQUNuQztBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixhQUFhO0FBQzNDLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLG1DQUFtQztBQUNwRDtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLDhEQUFnQjtBQUNyQzs7QUFFQTtBQUNBLGlDQUFpQyw0REFBUztB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dXJjZXNDb250ZW50IjpbImltcG9ydCBCYXNlQ29udGFpbmVyICAgIGZyb20gJy4uL2NvbnRhaW5lci9CYXNlLm1qcyc7XG5pbXBvcnQgQmFzZUZpZWxkICAgICAgICBmcm9tICcuLi9mb3JtL2ZpZWxkL0Jhc2UubWpzJztcbmltcG9ydCBDb21wb25lbnRNYW5hZ2VyIGZyb20gJy4uL21hbmFnZXIvQ29tcG9uZW50Lm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgICAgICBmcm9tICcuLi91dGlsL0FycmF5Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5mb3JtLkNvbnRhaW5lclxuICogQGV4dGVuZHMgTmVvLmNvbnRhaW5lci5CYXNlXG4gKi9cbmNsYXNzIENvbnRhaW5lciBleHRlbmRzIEJhc2VDb250YWluZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmZvcm0uQ29udGFpbmVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZm9ybS5Db250YWluZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nZm9ybS1jb250YWluZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnZm9ybS1jb250YWluZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tZm9ybS1jb250YWluZXInXSxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tZm9ybS1jb250YWluZXInXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gdmRvbT17dGFnOiAnZm9ybScsY246W10sb25zdWJtaXQ6J3JldHVybiBmYWxzZTsnfVxuICAgICAgICAgKi9cbiAgICAgICAgdmRvbTpcbiAgICAgICAge3RhZzogJ2Zvcm0nLCBjbjogW10sIG9uc3VibWl0OiAncmV0dXJuIGZhbHNlOyd9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHVzZWQgYnkgc2V0VmFsdWVzKCkgd2hpY2ggd3JhcHMgdGhlIGxlYXZlcyBvZiBhIHRyZWUgc3RydWN0dXJlIGludG8gYSBuZXcgcHJvcGVydHkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWdOYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gZmllbGRQYXRoc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjdXJyZW50UGF0aD0nJ1xuICAgICAqL1xuICAgIHN0YXRpYyBhZGp1c3RUcmVlTGVhdmVzKHZhbHVlcz17fSwgY29uZmlnTmFtZSwgZmllbGRQYXRocywgY3VycmVudFBhdGg9JycpIHtcbiAgICAgICAgbGV0IGFzc2lnbiwgbmV3UGF0aCwgdHlwZTtcblxuICAgICAgICBPYmplY3QuZW50cmllcyh2YWx1ZXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgYXNzaWduICA9IHRydWU7XG4gICAgICAgICAgICBuZXdQYXRoID0gY3VycmVudFBhdGggPT09ICcnID8ga2V5IDogYCR7Y3VycmVudFBhdGh9LiR7a2V5fWA7XG4gICAgICAgICAgICB0eXBlICAgID0gTmVvLnR5cGVPZih2YWx1ZSk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnQXJyYXknIHx8IHR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgYXNzaWduID0gZmllbGRQYXRocy5pbmNsdWRlcyhuZXdQYXRoKTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnQXJyYXknKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTmVvLnR5cGVPZihpdGVtKSA9PT0gJ09iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkanVzdFRyZWVMZWF2ZXMoaXRlbSwgY29uZmlnTmFtZSwgZmllbGRQYXRocywgYCR7bmV3UGF0aH1bJHtpbmRleH1dYClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRqdXN0VHJlZUxlYXZlcyh2YWx1ZSwgY29uZmlnTmFtZSwgZmllbGRQYXRocywgbmV3UGF0aClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhc3NpZ24pIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBjb25maWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlc1trZXldID0gdmFsdWVcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNba2V5XSA9IHtbY29uZmlnTmFtZV06IHZhbHVlfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb250YWluZXIuQmFzZX0gcGFyZW50XG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gbW9kdWxlc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3RbXX1cbiAgICAgKi9cbiAgICBmaW5kTm90TG9hZGVkTW9kdWxlcyhwYXJlbnQ9dGhpcywgbW9kdWxlcz1bXSkge1xuICAgICAgICBwYXJlbnQuaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGlmIChOZW8udHlwZU9mKGl0ZW0ubW9kdWxlKSA9PT0gJ0Z1bmN0aW9uJyAmJiAhaXRlbS5pc0xvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVzLnB1c2goe2l0ZW0sIHBhcmVudH0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZW0uaXRlbXMgJiYgdGhpcy5maW5kTm90TG9hZGVkTW9kdWxlcyhpdGVtLCBtb2R1bGVzKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbW9kdWxlc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVpdGhlciBwYXNzIGEgZmllbGQgbmFtZSBvciBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybnMge1Byb21pc2U8TmVvLmZvcm0uZmllbGQuQmFzZXxudWxsPn0gZmllbGRzXG4gICAgICovXG4gICAgYXN5bmMgZ2V0RmllbGQobmFtZSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNb2R1bGVzKCk7XG5cbiAgICAgICAgbGV0IGZpZWxkcyA9IENvbXBvbmVudE1hbmFnZXIuZ2V0Q2hpbGRDb21wb25lbnRzKHRoaXMpLFxuICAgICAgICAgICAgZmllbGQ7XG5cbiAgICAgICAgZm9yIChmaWVsZCBvZiBmaWVsZHMpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZCBpbnN0YW5jZW9mIEJhc2VGaWVsZCkge1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZC5uYW1lID09PSBuYW1lIHx8IGZpZWxkLmlkID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uZm9ybS5maWVsZC5CYXNlfSBmaWVsZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0RmllbGRQYXRoKGZpZWxkKSB7XG4gICAgICAgIGxldCBwYXRoID0gZmllbGQuZm9ybUdyb3VwID8gZmllbGQuZm9ybUdyb3VwLnNwbGl0KCcuJykgOiBbXTtcblxuICAgICAgICBwYXRoLnB1c2goZmllbGQubmFtZSB8fCBmaWVsZC5pZCk7XG5cbiAgICAgICAgcmV0dXJuIHBhdGguam9pbignLicpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8TmVvLmZvcm0uZmllbGQuQmFzZVtdPn0gZmllbGRzXG4gICAgICovXG4gICAgYXN5bmMgZ2V0RmllbGRzKCkge1xuICAgICAgICBsZXQgZmllbGRzID0gW107XG5cbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTW9kdWxlcygpO1xuXG4gICAgICAgIENvbXBvbmVudE1hbmFnZXIuZ2V0Q2hpbGRDb21wb25lbnRzKHRoaXMpLmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgICAgICAgZmllbGQgaW5zdGFuY2VvZiBCYXNlRmllbGQgJiYgZmllbGRzLnB1c2goZmllbGQpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBmaWVsZHNcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gb25lIG9mIHRoZSBmb2xsb3dpbmcgc3RhdGVzOlxuICAgICAqIC0gY2xlYW4gICAgICA9PiBhbGwgZmllbGRzIGFyZSBjbGVhbiAodW50b3VjaGVkKVxuICAgICAqIC0gaW52YWxpZCAgICA9PiBhdCBsZWFzdCBvbmUgZmllbGQgaXMgaW52YWxpZFxuICAgICAqIC0gdmFsaWQgICAgICA9PiBhbGwgcmVxdWlyZWQgZmllbGRzIGFyZSB2YWxpZFxuICAgICAqIC0gaW5Qcm9ncmVzcyA9PiBhdCBsZWFzdCBvbmUgZmllbGQgaXMgdmFsaWQsIGF0IGxlYXN0IG9uZSBmaWVsZCBpcyBjbGVhblxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFN0cmluZz59XG4gICAgICovXG4gICAgYXN5bmMgZ2V0Rm9ybVN0YXRlKCkge1xuICAgICAgICBsZXQgZmllbGRzICAgICAgICAgICA9IGF3YWl0IHRoaXMuZ2V0RmllbGRzKCksXG4gICAgICAgICAgICBpICAgICAgICAgICAgICAgID0gMCxcbiAgICAgICAgICAgIGhhc0NsZWFuRmllbGRzICAgPSBmYWxzZSxcbiAgICAgICAgICAgIGhhc0FsZXJ0RmllbGRzICAgPSBmYWxzZSxcbiAgICAgICAgICAgIGhhc0ludmFsaWRGaWVsZHMgPSBmYWxzZSxcbiAgICAgICAgICAgIGhhc1VuY2xlYW5GaWVsZHMgPSBmYWxzZSxcbiAgICAgICAgICAgIGhhc1ZhbGlkRmllbGRzICAgPSBmYWxzZSxcbiAgICAgICAgICAgIGxlbiAgICAgICAgICAgICAgPSBmaWVsZHMubGVuZ3RoLFxuICAgICAgICAgICAgZmllbGQsIGlzQ2xlYW4sIGlzVmFsaWQ7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgZmllbGQgICA9IGZpZWxkc1tpXTtcbiAgICAgICAgICAgIGlzQ2xlYW4gPSBmaWVsZC5jbGVhbjtcbiAgICAgICAgICAgIGlzVmFsaWQgPSBmaWVsZC5pc1ZhbGlkKCk7XG5cbiAgICAgICAgICAgIGlmICghaXNDbGVhbiAmJiAhaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZC5pc0VtcHR5QW5kUmVxdWlyZWQ/LigpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc0FsZXJ0RmllbGRzID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnaW52YWxpZCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICBoYXNWYWxpZEZpZWxkcyA9IHRydWVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQuaXNFbXB0eUFuZFJlcXVpcmVkPy4oKSkge1xuICAgICAgICAgICAgICAgICAgICBoYXNBbGVydEZpZWxkcyA9IHRydWVcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoYXNJbnZhbGlkRmllbGRzID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzQ2xlYW4pIHtcbiAgICAgICAgICAgICAgICBoYXNDbGVhbkZpZWxkcyA9IHRydWVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaGFzVW5jbGVhbkZpZWxkcyA9IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGFzQWxlcnRGaWVsZHMgJiYgIWhhc0ludmFsaWRGaWVsZHMpIHtcbiAgICAgICAgICAgIHJldHVybiAndmFsaWQnXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhhc0FsZXJ0RmllbGRzICYmIGhhc0NsZWFuRmllbGRzICYmICFoYXNVbmNsZWFuRmllbGRzKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2NsZWFuJ1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICdpblByb2dyZXNzJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59XG4gICAgICovXG4gICAgYXN5bmMgZ2V0U3VibWl0VmFsdWVzKCkge1xuICAgICAgICBsZXQgZmllbGRzID0gYXdhaXQgdGhpcy5nZXRGaWVsZHMoKSxcbiAgICAgICAgICAgIFJhZGlvICA9IE5lby5mb3JtLmZpZWxkLlJhZGlvLFxuICAgICAgICAgICAgdmFsdWVzID0ge30sXG4gICAgICAgICAgICBmaWVsZE5hbWUsIGtleSwgbnMsIG5zQXJyYXksIHZhbHVlO1xuXG4gICAgICAgIGZpZWxkcy5mb3JFYWNoKGZpZWxkID0+IHtcbiAgICAgICAgICAgIHZhbHVlID0gZmllbGQuZ2V0U3VibWl0VmFsdWUoKTtcblxuICAgICAgICAgICAgaWYgKGZpZWxkLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBmaWVsZE5hbWUgPSBmaWVsZC5uYW1lO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkLmZvcm1Hcm91cCkge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZE5hbWUgPSBmaWVsZC5mb3JtR3JvdXAgKyAnLicgKyBmaWVsZE5hbWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbnNBcnJheSA9IGZpZWxkTmFtZS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgICAgIGtleSAgICAgPSBuc0FycmF5LnBvcCgpO1xuICAgICAgICAgICAgICAgIG5zICAgICAgPSBOZW8ubnNXaXRoQXJyYXlzKG5zQXJyYXksIHRydWUsIHZhbHVlcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGtleSA9IGZpZWxkLmlkO1xuICAgICAgICAgICAgICAgIG5zICA9IHZhbHVlc1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFbnN1cmluZyB0aGF0IFJhZGlvcyB3aWxsIG5vdCByZXR1cm4gYXJyYXlzXG4gICAgICAgICAgICBpZiAoUmFkaW8gJiYgZmllbGQgaW5zdGFuY2VvZiBSYWRpbykge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgb3ZlcndyaXRlIGFuIGV4aXN0aW5nIHZhbHVlIHdpdGggYSBjaGVja2VkIHZhbHVlXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd24obnMsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBmaWVsZC51bmNoZWNrZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnNba2V5XSA9IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuc1trZXldID0gdmFsdWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogQ2hlY2tCb3hlcyBuZWVkIGN1c3RvbSBsb2dpY1xuICAgICAgICAgICAgICogPT4gd2Ugb25seSB3YW50IHRvIHBhc3MgdGhlIHVuY2hlY2tlZFZhbHVlIGluIGNhc2UgdGhlIGZpZWxkIGRvZXMgbm90IGJlbG9uZyB0byBhIGdyb3VwXG4gICAgICAgICAgICAgKiAobXVsdGlwbGUgZmllbGRzIHVzaW5nIHRoZSBzYW1lIG5hbWUpXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGVsc2UgaWYgKE9iamVjdC5oYXNPd24obnMsIGtleSkgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChuc1trZXldID09PSBmaWVsZC51bmNoZWNrZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBuc1trZXldID0gW11cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KG5zW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIG5zW2tleV0gPSBbbnNba2V5XV1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YWx1ZSAhPT0gZmllbGQudW5jaGVja2VkVmFsdWUgJiYgbnNba2V5XS51bnNoaWZ0KHZhbHVlKVxuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbnNba2V5XSA9IHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBpbiB2Ny54XG4gICAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRWYWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN1Ym1pdFZhbHVlcygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGluIGNhc2Ugbm8gZm9ybSBmaWVsZCBpc1ZhbGlkKCkgY2FsbCByZXR1cm5zIGZhbHNlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Qm9vbGVhbj59XG4gICAgICovXG4gICAgYXN5bmMgaXNWYWxpZCgpIHtcbiAgICAgICAgbGV0IGZpZWxkcyA9IGF3YWl0IHRoaXMuZ2V0RmllbGRzKCksXG4gICAgICAgICAgICBpICAgICAgPSAwLFxuICAgICAgICAgICAgbGVuICAgID0gZmllbGRzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWZpZWxkc1tpXS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZHMgYWxsIG5vdCBsb2FkZWQgaXRlbXMgaW5zaWRlIGNhcmQgbGF5b3V0c1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE5lby5jb21wb25lbnQuQmFzZVtdPn1cbiAgICAgKi9cbiAgICBhc3luYyBsb2FkTW9kdWxlcygpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIG1vZHVsZXMgID0gbWUuZmluZE5vdExvYWRlZE1vZHVsZXMoKSxcbiAgICAgICAgICAgIHByb21pc2VzID0gW107XG5cbiAgICAgICAgbW9kdWxlcy5mb3JFYWNoKG1vZHVsZSA9PiB7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKG1vZHVsZS5wYXJlbnQubGF5b3V0LmxvYWRNb2R1bGUobW9kdWxlLml0ZW0pKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbW9kdWxlcyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcblxuICAgICAgICByZXR1cm4gbW9kdWxlc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyBmaWVsZCB2YWx1ZXMgYnkgZmllbGQgbmFtZSBvciBmaWVsZCBpZC5cbiAgICAgKiBGaWVsZHMgbm90IGluY2x1ZGVkIHdpdGggYSB2YWx1ZSB3aWxsIGdldCByZXNldCB0byBudWxsLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbdmFsdWVzXVxuICAgICAqL1xuICAgIGFzeW5jIHJlc2V0KHZhbHVlcz17fSkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGZpZWxkcyA9IGF3YWl0IG1lLmdldEZpZWxkcygpLFxuICAgICAgICAgICAgcGF0aCwgdmFsdWU7XG5cbiAgICAgICAgZmllbGRzLmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgICAgICAgcGF0aCAgPSBtZS5nZXRGaWVsZFBhdGgoZmllbGQpO1xuICAgICAgICAgICAgdmFsdWUgPSBOZW8ubnNXaXRoQXJyYXlzKHBhdGgsIGZhbHNlLCB2YWx1ZXMpO1xuXG4gICAgICAgICAgICBmaWVsZC5yZXNldChwYXRoID8gdmFsdWUgOiBudWxsKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBmaWVsZCBjb25maWdzIGJ5IGZpZWxkIG5hbWUgb3IgZmllbGQgaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlncz17fVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc3VzcGVuZEV2ZW50cz1mYWxzZVxuICAgICAqL1xuICAgIGFzeW5jIHNldENvbmZpZ3MoY29uZmlncz17fSwgc3VzcGVuZEV2ZW50cz1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGZpZWxkcyA9IGF3YWl0IG1lLmdldEZpZWxkcygpLFxuICAgICAgICAgICAgZmllbGRDb25maWdzLCBpc0NoZWNrQm94LCBpc1JhZGlvLCBwYXRoLCB2YWx1ZTtcblxuICAgICAgICBmaWVsZHMuZm9yRWFjaChmaWVsZCA9PiB7XG4gICAgICAgICAgICBwYXRoICAgICAgICAgPSBtZS5nZXRGaWVsZFBhdGgoZmllbGQpO1xuICAgICAgICAgICAgZmllbGRDb25maWdzID0gTmVvLm5zV2l0aEFycmF5cyhwYXRoLCBmYWxzZSwgY29uZmlncyk7XG5cbiAgICAgICAgICAgIGlmIChmaWVsZENvbmZpZ3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3VzcGVuZEV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZC5zdXNwZW5kRXZlbnRzID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlzQ2hlY2tCb3ggPSBOZW8uZm9ybS5maWVsZD8uQ2hlY2tCb3ggJiYgZmllbGQgaW5zdGFuY2VvZiBOZW8uZm9ybS5maWVsZC5DaGVja0JveDtcbiAgICAgICAgICAgICAgICBpc1JhZGlvICAgID0gTmVvLmZvcm0uZmllbGQ/LlJhZGlvICAgICYmIGZpZWxkIGluc3RhbmNlb2YgTmVvLmZvcm0uZmllbGQuUmFkaW87XG4gICAgICAgICAgICAgICAgdmFsdWUgICAgICA9IGZpZWxkQ29uZmlncy52YWx1ZTtcblxuICAgICAgICAgICAgICAgIGlmIChpc0NoZWNrQm94IHx8IGlzUmFkaW8pIHtcbiAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICogd2Ugd2FudCB0byBvbmx5IGNoYW5nZSB0aGUgY2hlY2tlZCBzdGF0ZSwgaW4gY2FzZSBhIHZhbHVlIGlzIHNldC5cbiAgICAgICAgICAgICAgICAgICAgICogc2luY2UgZmllbGRzIG9mIHRoZSBzYW1lIGdyb3VwIG1pZ2h0IG5lZWQgaXQgdG9vLCB3ZSBhcmUgY2xvbmluZyB0aGUgZmllbGRDb25maWdzXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihmaWVsZENvbmZpZ3MsICd2YWx1ZScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZENvbmZpZ3MgPSBOZW8uY2xvbmUoZmllbGRDb25maWdzLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzUmFkaW8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZENvbmZpZ3MuY2hlY2tlZCA9IGZpZWxkLnZhbHVlID09PSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc0NoZWNrQm94KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE5lby50eXBlT2YodmFsdWUpID09PSAnQXJyYXknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcyhmaWVsZC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkQ29uZmlncy5jaGVja2VkID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRDb25maWdzLmNoZWNrZWQgPSBmaWVsZC52YWx1ZSA9PT0gdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBmaWVsZENvbmZpZ3MudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZpZWxkLnNldChmaWVsZENvbmZpZ3MpXG5cbiAgICAgICAgICAgICAgICBpZiAoc3VzcGVuZEV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZmllbGQuc3VzcGVuZEV2ZW50c1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgZmllbGQgdmFsdWVzIGJ5IGZpZWxkIG5hbWUgb3IgZmllbGQgaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzPXt9XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzdXNwZW5kRXZlbnRzPWZhbHNlXG4gICAgICovXG4gICAgYXN5bmMgc2V0VmFsdWVzKHZhbHVlcz17fSwgc3VzcGVuZEV2ZW50cz1mYWxzZSkge1xuICAgICAgICBsZXQgZmllbGRzICAgICA9IGF3YWl0IHRoaXMuZ2V0RmllbGRzKCksXG4gICAgICAgICAgICBmaWVsZFBhdGhzID0gW10sXG4gICAgICAgICAgICBwYXRoO1xuXG4gICAgICAgIC8vIEdyb3VwZWQgQ2hlY2tCb3hlcyAmIFJhZGlvcyBjYW4gaGF2ZSB0aGUgc2FtZSBwYXRoXG4gICAgICAgIC8vID0+IHVzaW5nIE5lb0FycmF5IHRvIGVuc3VyZSB0aGV5IG9ubHkgZ2V0IGFkZGVkIG9uY2VcbiAgICAgICAgZmllbGRzLm1hcChmaWVsZCA9PiB7XG4gICAgICAgICAgICBwYXRoID0gZmllbGQuZ2V0UGF0aCgpO1xuICAgICAgICAgICAgcGF0aCAmJiBOZW9BcnJheS5hZGQoZmllbGRQYXRocywgcGF0aClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFsdWVzID0gTmVvLmNsb25lKHZhbHVlcywgdHJ1ZSk7XG5cbiAgICAgICAgQ29udGFpbmVyLmFkanVzdFRyZWVMZWF2ZXModmFsdWVzLCAndmFsdWUnLCBmaWVsZFBhdGhzKTtcblxuICAgICAgICBhd2FpdCB0aGlzLnNldENvbmZpZ3ModmFsdWVzLCBzdXNwZW5kRXZlbnRzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGludmFsaWQgc3RhdGUgZm9yIGFsbCBmaWVsZHMgd2hpY2ggaGF2ZSB2YWxpZGF0ZSgpIGltcGxlbWVudGVkLlxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3IgY3JlYXRlLWVudGl0eSBmb3JtcyB3aGljaCBzaG93IHVwIFwiY2xlYW5cIiB1bnRpbCBwcmVzc2luZyBhIHN1Ym1pdCBidXR0b24uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Qm9vbGVhbj59XG4gICAgICovXG4gICAgYXN5bmMgdmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCBpc1ZhbGlkID0gdHJ1ZSxcbiAgICAgICAgICAgIGZpZWxkcyAgPSBhd2FpdCB0aGlzLmdldEZpZWxkcygpLFxuICAgICAgICAgICAgdmFsaWRGaWVsZDtcblxuICAgICAgICBmaWVsZHMuZm9yRWFjaChmaWVsZCA9PiB7XG4gICAgICAgICAgICB2YWxpZEZpZWxkID0gZmllbGQudmFsaWRhdGU/LihmYWxzZSk7XG5cbiAgICAgICAgICAgIGlmICghdmFsaWRGaWVsZCkge1xuICAgICAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gaXNWYWxpZFxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ29udGFpbmVyKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==