"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_form_field_Text_mjs"],{

/***/ "./src/form/field/Text.mjs":
/*!*********************************!*\
  !*** ./src/form/field/Text.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/form/field/Base.mjs");
/* harmony import */ var _trigger_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./trigger/Base.mjs */ "./src/form/field/trigger/Base.mjs");
/* harmony import */ var _trigger_Clear_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./trigger/Clear.mjs */ "./src/form/field/trigger/Clear.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_String_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/String.mjs */ "./src/util/String.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");
/* harmony import */ var _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/VNode.mjs */ "./src/util/VNode.mjs");








/**
 * @class Neo.form.field.Text
 * @extends Neo.form.field.Base
 */
class Text extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for autoCapitalize
     * @member {String[]} autoCapitalizeValues=['characters','none','on','off','sentences','words']
     * @protected
     * @static
     */
    static autoCapitalizeValues = ['characters', 'none', 'on', 'off', 'sentences', 'words']
    /**
     * Valid values for labelPosition
     * @member {String[]} labelPositions=['bottom','inline','left','right','top']
     * @protected
     * @static
     */
    static labelPositions = ['bottom', 'inline', 'left', 'right', 'top']

    static config = {
        /**
         * @member {String} className='Neo.form.field.Text'
         * @protected
         */
        className: 'Neo.form.field.Text',
        /**
         * @member {String} ntype='textfield'
         * @protected
         */
        ntype: 'textfield',
        /**
         * An enumerated attribute that controls whether and how text input is automatically capitalized as it is
         * entered/edited by the user.
         * Valid values: 'characters', 'none', 'on', 'off', 'sentences', 'words'
         * @member {String} autoCapitalize=off'
         */
        autoCapitalize_: 'off',
        /**
         * @member {Boolean} autoComplete_=false
         */
        autoComplete_: false,
        /**
         * @member {String[]} baseCls=['neo-textfield']
         */
        baseCls: ['neo-textfield'],
        /**
         * Internal variable to store the actual width for the label centerBorderEl
         * (only needed for labelPosition: 'inline')
         * @member {Number|null} centerBorderElWidth=null
         * @protected
         */
        centerBorderElWidth: null,
        /**
         * True shows a clear trigger in case the field has a non-empty value.
         * @member {Boolean} clearable_=true
         */
        clearable_: true,
        /**
         * True will reset the field to its initial value config.
         * Recommended for fields with required: true
         * @member {Boolean} clearToOriginalValue_=false
         */
        clearToOriginalValue_: false,
        /**
         * Prevent users from typing specific characters.
         * E.g. disabling +-e for NumberFields
         * @member {String[]|null} disabledChars_=null
         */
        disabledChars_: null,
        /**
         * Setting `editable` to `false` means that the input field will be read-only
         * but the field is still workable and may have its value changed by user interaction.
         *
         * For example picker fields such as `Date` and `Select` may still have their
         * values changed by selecting from the picker using keyboard or pointer.
         * @member {Boolean} editable_=true
         */
        editable_: true,
        /**
         * Configure the value of empty fields. null or an empty string is recommended.
         * @member {String|null} emptyValue=null
         */
        emptyValue: null,
        /**
         * @member {String|null} error_=null
         */
        error_: null,
        /**
         * Useful for fields inside a css grid where errors should live outside the layout
         * @member {Boolean} errorPositionAbsolute_=false
         */
        errorPositionAbsolute_: false,
        /**
         * data passes inputPattern, maxLength, minLength & valueLength properties
         * @member {Function} errorTextInputPattern=data=>`Input pattern violation: ${data.inputPattern}`
         */
        errorTextInputPattern: data => `Input pattern violation: ${data.inputPattern}`,
        /**
         * data passes inputPattern, maxLength, minLength & valueLength properties
         * @member {Function} errorTextMaxLength=data=>`Max length violation: ${valueLength} / ${maxLength}`
         */
        errorTextMaxLength: data => `Max length violation: ${data.valueLength} / ${data.maxLength}`,
        /**
         * data passes inputPattern, maxLength, minLength & valueLength properties
         * @member {Function} errorTextMinLength=data=>`Min length violation: ${data.valueLength} / ${data.minLength}`
         */
        errorTextMinLength: data => `Min length violation: ${data.valueLength} / ${data.minLength}`,
        /**
         * @member {String} errorTextRequired='Required'
         */
        errorTextRequired: 'Required',
        /**
         * @member {Boolean} hideLabel_=false
         */
        hideLabel_: false,
        /**
         * @member {RegExp|null} inputPattern_=null
         */
        inputPattern_: null,
        /**
         * If false, the inputPattern will only get validated via JavaScript, but not getting applied on DOM level.
         * The regex support for input based patterns is not fully there yet, so feel free to disable this feature
         * if needed (E.g. form.field.Phone).
         * @member {Boolean} inputPatternDOM_=true
         */
        inputPatternDOM_: true,
        /**
         * @member {String} inputType_='text'
         */
        inputType_: 'text',
        /**
         * @member {String|null} inputValue_=null
         */
        inputValue_: null,
        /**
         * @member {String[]} labelBaseCls=['neo-textfield-label']
         */
        labelBaseCls: ['neo-textfield-label'],
        /**
         * @member {String[]} labelCls_=[]
         */
        labelCls_: [],
        /**
         * Edge-case config in case we want to render leading content with their own selectors like:
         * <span class="my-label-id-cls">E10</span> • Firstname
         * @member {String|null} labelId_=null
         */
        labelId_: null,
        /**
         * CSS rules for labelId
         * @member {String[]} labelIdCls_=[]
         */
        labelIdCls_: [],
        /**
         * Separator between labelId & labelText
         * @member {String} labelIdSeparator_=' · '
         */
        labelIdSeparator_: ' · ',
        /**
         * @member {String} labelOptionalText_=' (Optional)'
         */
        labelOptionalText_: ' (Optional)',
        /**
         * Valid values: 'bottom', 'inline', 'left', 'right', 'top'
         * @member {String} labelPosition_='left'
         */
        labelPosition_: 'left',
        /**
         * @member {String} labelText_='LabelText'
         */
        labelText_: 'LabelText',
        /**
         * defaults to px
         * @member {Number|String} labelWidth_=150
         */
        labelWidth_: 150,
        /**
         * The maximum amount of chars which you can enter into this field
         * @member {Number|null} maxLength_=null
         */
        maxLength_: null,
        /**
         * The minimum amount of chars which you can enter into this field
         * @member {Number|null} minLength_=null
         */
        minLength_: null,
        /**
         * @member {String|null} placeholderText_=null
         */
        placeholderText_: null,
        /**
         * Setting `readOnly` means that the field may not be changed by user interaction.
         *
         * The input field will be read-only and other ways of changing the field's value
         * (such as by operating pickers) will be disabled.
         * @member {Boolean} readOnly_=false
         */
        readOnly_: false,
        /**
         * @member {Boolean} required_=false
         */
        required_: false,
        /**
         * @member {Boolean} showOptionalText_=false
         */
        showOptionalText_: false,
        /**
         * null => Follow the element's default behavior for spell checking
         * @member {Boolean|null} spellCheck_=false
         */
        spellCheck_: false,
        /**
         * @member {String[]} subLabelBaseCls=['neo-textfield-sublabel']
         */
        subLabelBaseCls: ['neo-textfield-sublabel'],
        /**
         * @member {String[]} subLabelCls_=[]
         */
        subLabelCls_: [],
        /**
         * @member {String} subLabelText_=null
         */
        subLabelText_: null,
        /**
         * @member {Object|Object[]|null} triggers_=null
         */
        triggers_: null,
        /**
         * Using the alert state will display an empty but required field in orange instead of red.
         * Intended to get combined with form.Container: getFormState().
         * See apps/form as an example.
         * @member {Boolean} useAlertState_=false
         */
        useAlertState_: false,
        /**
         * A string based value will get resolved into the closest controller which implements it
         * @member {Function|String|null} validator=null
         */
        validator: null,
        /**
         * getVlue can be xssProtected and values are escaped
         * @member {Boolean} xssProtected=false
         */
        xssProtected_: false,
        /**
         * @member {Object} _vdom
         */
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {cn: [
            {tag: 'label', cls: [], style: {}},
            {tag: 'label', cls: []},
            {tag: 'input', cls: ['neo-textfield-input'], flag: 'neo-real-input', style: {}},
            {cls: ['neo-textfield-error-wrapper'], removeDom: true, cn: [
                {cls: ['neo-textfield-error']}
            ]}
        ]}
    }

    /**
     * Set this value to false, in case a field should display errors up front.
     * Otherwise, errors will stay hidden on mounting, unless you trigger validate(false).
     * @member {Boolean} clean=true
     */
    clean = true

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.addDomListeners([
            {input     : me.onInputValueChange, scope: me},
            {mouseenter: me.onMouseEnter,       scope: me},
            {mouseleave: me.onMouseLeave,       scope: me}
        ])
    }

    /**
     * Triggered after the appName config got changed
     * @param {String} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetAppName(value, oldValue) {
        super.afterSetAppName(value, oldValue);

        value && this.triggers?.forEach(item => {
            item.appName = value
        })
    }

    /**
     * Triggered after the autoCapitalize config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetAutoCapitalize(value, oldValue) {
        this.changeInputElKey('autocapitalize', value === 'off' || value === 'none' ? null : value)
    }

    /**
     * Triggered after the autoComplete config got changed
     * Chrome ignores a value of "off", so we stick to a different value instead
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetAutoComplete(value, oldValue) {
        // while "off" is the correct value, browser vendors ignore it. Arbitrary strings do the trick.
        this.changeInputElKey('autocomplete', value ? null : 'no')
    }

    /**
     * Triggered after the clearable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetClearable(value, oldValue) {
        let me = this,
            triggers;

        if (value) {
            triggers = me.triggers || [];
            triggers.unshift(_trigger_Clear_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]);
            me.triggers = triggers
        } else {
            me.removeTrigger('clear')
        }
    }

    /**
     * Triggered after the clearToOriginalValue config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetClearToOriginalValue(value, oldValue) {
        this.fire('changeClearToOriginalValue', {
            oldValue,
            value
        })
    }

    /**
     * Triggered after the disabledChars config got changed
     * @param {String[]|null} value
     * @param {String[]|null} oldValue
     * @protected
     */
    afterSetDisabledChars(value, oldValue) {
        if (value) {
            let me = this;

            Neo.main.DomEvents.registerDisabledInputChars({
                appName: me.appName,
                chars  : value,
                id     : me.getInputEl().id
            })
        }
    }

    /**
     * Triggered after the editable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetEditable(value, oldValue) {
        let me      = this,
            {cls} = me;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].toggle(cls, 'neo-not-editable', !value);
        me.cls = cls;

        me.updateReadOnlyState()
    }

    /**
     * Triggered after the error config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetError(value, oldValue) {
        this.updateError(value)
    }

    /**
     * Triggered after the errorPositionAbsolute config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetErrorPositionAbsolute(value, oldValue) {
        let me  = this,
            cls = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].findVdomChild(me.vdom, {cls: 'neo-textfield-error'}).vdom.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"][value ? 'add' : 'remove'](cls, 'neo-absolute');

        me.update()
    }

    /**
     * Triggered after the hideLabel config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetHideLabel(value, oldValue) {
        let me   = this,
            node = me.labelPosition === 'inline' ? me.getCenterBorderEl() : me.vdom.cn[0];

        node.removeDom = value;
        me.updateInputWidth()
    }

    /**
     * Triggered after the id config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetId(value, oldValue) {
        let me        = this,
            inputEl   = me.getInputEl(),
            inputElId = me.getInputElId(),
            labelEl   = me.getLabelEl();

        inputEl.id  = inputElId;
        labelEl.id  = me.getLabelId();
        labelEl.for = inputElId;

        // silent vdom update, the super call will trigger the engine
        super.afterSetId(value, oldValue)
    }

    /**
     * Triggered after the inputPattern config got changed
     * @param {RegExp|null} value
     * @param {RegExp|null} oldValue
     * @protected
     */
    afterSetInputPattern(value, oldValue) {
        if (this.inputPatternDOM) {
            if (value) {
                value = value.toString();
                value = value.substring(1, value.length - 1)
            }

            this.changeInputElKey('pattern', value)
        }
    }

    /**
     * Triggered after the inputType config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetInputType(value, oldValue) {
        this.changeInputElKey('type', value)
    }

    /**
     * Triggered after the inputValue config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetInputValue(value, oldValue) {
        let me    = this,
            {cls} = me;

        me.getInputEl().value = me.containsFocus ? value : me.inputValueRenderer(value);

        me.useAlertState && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].toggle(cls, 'neo-empty-required', me.isEmpty() && me.required);

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].toggle(cls, 'neo-has-content', me.hasContent());
        me.cls = cls;

        me.updateValueFromInputValue(value)
    }

    /**
     * Triggered after the labelCls config got changed
     * @param {String[]} value
     * @param {String[]} oldValue
     * @protected
     */
    afterSetLabelCls(value, oldValue) {
        let me  = this,
            cls = me.getLabelEl().cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].remove(cls, oldValue);
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(cls, value);

        me.update()
    }

    /**
     * Triggered after the labelOptionalText config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetLabelOptionalText(value, oldValue) {
        this.labelText = this.labelText // triggers a vdom update
    }

    /**
     * Triggered after the labelPosition config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetLabelPosition(value, oldValue) {
        let me          = this,
            {cls, vdom} = me,
            centerBorderElCls, isEmpty;

        vdom.cn[1].removeDom = value !== 'top' ? true : !Boolean(me.subLabelText);

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].remove(cls, 'label-' + oldValue);
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(cls, 'label-' + value);
        me.cls = cls; // todo: silent update if needed

        if (oldValue === 'inline') {
            vdom.cn[0] = me.getLabelEl(); // remove the wrapper

            vdom.cn[0].removeDom = me.hideLabel;
            vdom.cn[0].width     = me.labelWidth;
            me.updateInputWidth()
        } else if (value === 'inline') {
            centerBorderElCls = ['neo-center-border'];
            isEmpty           = me.isEmpty();
            vdom              = me.vdom;

            !isEmpty && centerBorderElCls.push('neo-float-above');

            delete vdom.cn[0].width;

            vdom.cn[0] = {
                cls: ['neo-label-wrapper'],
                cn : [{
                    cls: ['neo-left-border']
                }, {
                    cls      : centerBorderElCls,
                    cn       : [vdom.cn[0]],
                    removeDom: me.hideLabel
                }, {
                    cls: ['neo-right-border']
                }]
            };

            me.updateInputWidth();

            !isEmpty && setTimeout(() => {
                me.updateCenterBorderElWidth(false)
            }, 20)
        } else {
            // changes from e.g. left to top
            me.updateInputWidth()
        }
    }

    /**
     * Triggered after the labelText config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetLabelText(value, oldValue) {
        let me      = this,
            isEmpty = me.isEmpty();

        if (me.labelId) {
            value = `<span class="${me.labelIdCls.join(',')}">${me.labelId}</span>${me.labelIdSeparator + value}`
        }

        me.getLabelEl().innerHTML = value;

        if (!me.hideLabel) {
            if (me.labelPosition === 'inline') {
                if (!isEmpty) {
                    delete me.getCenterBorderEl()?.width
                }

                me.promiseUpdate().then(() => {
                    me.updateCenterBorderElWidth(isEmpty)
                })
            } else {
                me.update()
            }
        }
    }

    /**
     * Triggered after the labelWidth config got changed
     * @param {Number|String} value
     * @param {Number|String} oldValue
     * @protected
     */
    afterSetLabelWidth(value, oldValue) {
        if (this.labelPosition !== 'inline') {
            let me    = this,
                label = me.vdom.cn[0];

            label.width = value;
            !me.hideLabel && me.updateInputWidth()
        }
    }

    /**
     * Triggered after the maxLength config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetMaxLength(value, oldValue) {
        this.validate(); // silent
        this.changeInputElKey('maxlength', value)
    }

    /**
     * Triggered after the minLength config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetMinLength(value, oldValue) {
        this.validate(); // silent
        this.changeInputElKey('minlength', value)
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        let me = this;

        if (oldValue !== undefined) {
            let triggers = me.triggers || [],
                i        = 0,
                len      = triggers.length;

            for (; i < len; i++) {
                if (!triggers[i].vdom.removeDom) {
                    triggers[i].mounted = value
                }
            }

            if (me.labelPosition === 'inline') {
                if (value) {
                    me.updateCenterBorderElWidth()
                } else {
                    delete me.getCenterBorderEl().width
                }
            }
        }
    }

    /**
     * Triggered after the placeholderText config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetPlaceholderText(value, oldValue) {
        let me    = this,
            {cls} = me;

        me.changeInputElKey('placeholder', value === '' ? null : value);

        // a non-empty placeholder needs to keep the 'neo-has-content' rule
        // => labelPosition: 'inline' should keep the label at the top
        if (Neo.isEmpty(value) !== Neo.isEmpty(oldValue)) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"][value !== null && value.toString().length > 0 ? 'add' : 'remove'](cls, 'neo-has-content');
            me.cls = cls
        }
    }

    /**
     * Triggered after the readOnly config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetReadOnly(value, oldValue) {
        let me    = this,
            {cls} = me;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"][value ? 'add' : 'remove'](cls, 'neo-readonly');
        me.cls = cls;

        me.updateReadOnlyState();

        me.triggers?.forEach(trigger => {
            trigger.hidden = value ? true : trigger.getHiddenState?.() || false
        })
    }

    /**
     * Triggered after the required config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetRequired(value, oldValue) {
        let me = this;

        me.silentVdomUpdate = true;

        oldValue !== undefined && me.validate(me.clean);
        me.changeInputElKey('required', value ? value : null);
        me.labelText = me.labelText; // apply the optional text if needed

        me.silentVdomUpdate = false;

        me.update()
    }

    /**
     * Triggered after the showOptionalText config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowOptionalText(value, oldValue) {
        this.labelText = this.labelText // triggers a vdom update
    }

    /**
     * Triggered after the spellCheck config got changed
     * @param {Boolean|null} value
     * @param {Boolean|null} oldValue
     * @protected
     */
    afterSetSpellCheck(value, oldValue) {
        this.changeInputElKey('spellcheck', Neo.isBoolean(value) ? value : null)
    }

    /**
     * Triggered after the subLabelCls config got changed
     * @param {String[]} value
     * @param {String[]} oldValue
     * @protected
     */
    afterSetSubLabelCls(value, oldValue) {
        let me    = this,
            {cls} = me.vdom.cn[1];

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].remove(cls, oldValue);
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(cls, value);

        me.update()
    }

    /**
     * Triggered after the subLabelText config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetSubLabelText(value, oldValue) {
        let me        = this,
            showLabel = me.labelPosition === 'top',
            subLabel  = me.vdom.cn[1];

        subLabel.html      = value;
        subLabel.removeDom = !showLabel;

        me.update()
    }

    /**
     * Triggered after the triggers config got changed
     * @param {Object[]} value
     * @param {Object[]} oldValue
     * @protected
     */
    afterSetTriggers(value, oldValue) {
        let me           = this,
            {vdom}       = me,
            inputEl      = vdom.cn[2], // inputEl or inputWrapperEl
            preTriggers  = [],
            postTriggers = [],
            width;

        oldValue?.forEach(item => {
            if (!me.getTrigger(item.type)) {
                item.destroy()
            }
        });

        if (value.length > 0) {
            value.forEach(item => {
                if (item.align === 'start') {
                    preTriggers.push(item);
                } else {
                    postTriggers.push(item);
                }
            });

            postTriggers.sort((a, b) => b.weight - a.weight); // DESC
            preTriggers.sort((a, b) => a.weight - b.weight); // ASC

            postTriggers = postTriggers.map(a => a.vdom);
            preTriggers  = preTriggers.map(a => a.vdom);

            if (inputEl.tag === 'input') {
                // wrap the input tag
                vdom.cn[2] = {
                    cls  : ['neo-input-wrapper'],
                    cn   : [...preTriggers, inputEl, ...postTriggers],
                    id   : me.getInputWrapperId(),
                    width: inputEl.width
                };

                delete inputEl.width
            } else {
                inputEl.cn = [...preTriggers, me.getInputEl(), ...postTriggers]
            }
        } else {
            if (inputEl.tag !== 'input') {
                // replacing the input wrapper div with the input tag
                width            = inputEl.width;
                vdom.cn[2]       = me.getInputEl();
                vdom.cn[2].width = width;
            }
        }

        me.promiseUpdate().then(() => {
            me.updateTriggerVnodes()
        })
    }

    /**
     * Triggered after the value config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetValue(value, oldValue) {
        let me = this,
            cls;

        me.silentVdomUpdate = true;

        me.updateInputValueFromValue(value);

        me.validate(); // silent

        cls = me.cls;
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].toggle(cls, 'neo-is-dirty', me.isDirty);
        me.cls = cls;

        me.silentVdomUpdate = false;

        me.update();

        super.afterSetValue(value, oldValue) // fires the change event
    }

    /**
     * Triggered after the width config got changed
     * @param {Number|String} value
     * @param {Number|String} oldValue
     * @protected
     */
    afterSetWidth(value, oldValue) {
        super.afterSetWidth(value, oldValue);
        this.updateInputWidth()
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        value && this.triggers?.forEach(item => {
            item.windowId = value
        })
    }

    /**
     * Return a shallow copy of the triggers config
     * @param {Array|null} value
     * @protected
     */
    beforeGetTriggers(value) {
        if (Array.isArray(value)) {
            return [...value]
        }

        return value
    }

    /**
     * Triggered before the autoCapitalize config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     * @returns {String}
     */
    beforeSetAutoCapitalize(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'autoCapitalize', 'autoCapitalizeValues')
    }

    /**
     * Triggered before the labelCls config gets changed.
     * @param {String[]} value
     * @param {String[]} oldValue
     * @protected
     */
    beforeSetLabelCls(value, oldValue) {
        return _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].union(value || [], this.labelBaseCls)
    }

    /**
     * Triggered before the labelPosition config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     * @returns {String}
     */
    beforeSetLabelPosition(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'labelPosition')
    }

    /**
     * Triggered before the labelText config gets changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     * @returns {String}
     */
    beforeSetLabelText(value, oldValue) {
        let me                = this,
            labelOptionalText = me.labelOptionalText,
            hasOptionalText   = value.endsWith(labelOptionalText);

        if (me.showOptionalText && !me.required) {
            if (!hasOptionalText) {
                value += labelOptionalText
            }
        } else if (value && hasOptionalText) {
            value = value.replace(labelOptionalText, '')
        }

        return value
    }

    /**
     * Triggered before the subLabelCls config gets changed
     * @param {String[]} value
     * @param {String[]} oldValue
     * @returns {String[]}
     * @protected
     */
    beforeSetSubLabelCls(value, oldValue) {
        return _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].union(value || [], this.subLabelBaseCls)
    }

    /**
     * Triggered before the triggers config gets changed
     * @param {Object|Object[]} value
     * @param {Object[]} oldValue
     * @returns {Object[]} the parsed triggers config
     * @protected
     * @returns {Object|Object[]}
     */
    beforeSetTriggers(value, oldValue) {
        if (!value) {
            value = [];
        } else if (!Array.isArray(value)) {
            value = [value]
        }

        let me                  = this,
            {appName, windowId} = me;

        value.forEach((item, index) => {
            if (item.isClass) {
                value[index] = Neo.create(item, {
                    appName,
                    id   : me.getTriggerId(item.prototype.type),
                    field: me,
                    windowId
                })
            } else if (!(item instanceof _trigger_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"])) {
                if (!item.module && !item.ntype) {
                    item.ntype = 'trigger'
                }

                if (item.module) {
                    item.className = item.module.prototype.className;
                    item.id        = me.getTriggerId(item.module.prototype.type)
                }

                value[index] = Neo[item.className ? 'create' : 'ntype']({
                    ...item,
                    appName,
                    field: me,
                    windowId
                })
            }
        });

        return value
    }

    /**
     * Triggered before the value config gets changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @returns {String|null}
     * @protected
     */
    beforeSetValue(value, oldValue) {
        if (value === null || value === '') {
            return this.emptyValue
        }

        return value
    }

    /**
     * Resets the field to its original value or null depending on the clearToOriginalValue config
     */
    clear() {
        let me = this;

        me.value = me.clearToOriginalValue ? me.originalConfig.value : null;
        me.fire('clear')
    }

    /**
     *
     * @param args
     */
    destroy(...args) {
        let me = this;

        if (me.disabledChars) {
            Neo.main.DomEvents.unregisterDisabledInputChars({
                appName: me.appName,
                id     : me.getInputEl().id
            })
        }

        super.destroy(...args)
    }

    /**
     * Calls focus() on the inputEl node instead
     * @param {String} id
     * @override
     */
    focus(id) {
        super.focus(this.getInputElId())
    }

    /**
     * @returns {Object|null}
     */
    getCenterBorderEl() {
        return _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].findVdomChild(this.vdom, {cls: 'neo-center-border'})?.vdom || null
    }

    /**
     * @returns {Object|null}
     */
    getInputEl() {
        return _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].findVdomChild(this.vdom, {flag: 'neo-real-input'})?.vdom || null
    }

    /**
     * @returns {String}
     */
    getInputElId() {
        return `${this.id}__input`
    }

    /**
     * Calculates the new inputWidth based on the labelWidth & total width
     * @returns {Number|null} null in case this.width is unknown
     */
    getInputWidth() {
        let me          = this,
            ignoreLabel = me.hideLabel || me.labelPosition === 'bottom' || me.labelPosition === 'inline' || me.labelPosition === 'top',
            labelWidth  = ignoreLabel ? 0 : me.labelWidth,
            {width}     = me;

        if (labelWidth && width) {
            return parseInt(width) - parseInt(labelWidth)
        } else if (width) {
            return width
        }

        return null
    }

    /**
     * @returns {String}
     */
    getInputWrapperId() {
        return `${this.id}__input-wrapper`
    }

    /**
     * @returns {Object|null}
     */
    getLabelEl() {
        return _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].findVdomChild(this.vdom, {tag: 'label'})?.vdom || null
    }

    /**
     * @returns {String}
     */
    getLabelId() {
        return `${this.id}__label`
    }

    /**
     * @returns {*}
     */
    getSubmitValue() {
        let superSubmitValue = super.getSubmitValue();

        return this.xssProtected ? _util_String_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].escapeHtml(superSubmitValue) : superSubmitValue
    }

    /**
     * @param {String} type
     * @returns {Neo.form.field.trigger.Base|null}
     */
    getTrigger(type) {
        let me       = this,
            triggers = me.triggers || [],
            i        = 0,
            len      = triggers.length;

        for (; i < len; i++) {
            if (triggers[i].type === type) {
                return triggers[i]
            }
        }

        return null
    }

    /**
     * @param {String} id
     * @returns {Neo.form.field.trigger.Base|null}
     */
    getTriggerById(id) {
        let me       = this,
            triggers = me.triggers || [],
            i        = 0,
            len      = triggers.length;

        for (; i < len; i++) {
            if (triggers[i].id === id) {
                return triggers[i]
            }
        }

        return null
    }

    /**
     * @param {String} type
     * @protected
     * @returns {String} The trigger node id
     */
    getTriggerId(type) {
        return this.id + '-trigger-' + type
    }

    /**
     * @returns {Boolean}
     */
    hasContent() {
        let value = this.inputValue;

        return this.placeholderText?.length > 0 || value !== null && value.toString().length > 0
    }

    /**
     * Finds a trigger by a given type config
     * @param {String} type
     * @returns {Boolean}
     */
    hasTrigger(type) {
        let triggers = this.triggers || [],
            i        = 0,
            len      = triggers.length;

        for (; i < len; i++) {
            if (triggers[i].type === type) {
                return true
            }
        }

        return false
    }

    /**
     * Transform an input node value before applied to this.value.
     * Override as needed
     * @param {*} value
     * @returns {*}
     */
    inputValueAdjustor(value) {
        return value
    }

    /**
     * Transform a value before getting rendered.
     * Override as needed
     * @param {*} value
     * @returns {*}
     */
    inputValueRenderer(value) {
        return value
    }

    /**
     * @returns {Boolean}
     */
    isEmpty() {
        return !(this.value?.toString().length > 0)
    }

    /**
     * @returns {Boolean}
     */
    isEmptyAndRequired() {
        return this.isEmpty() && this.required
    }

    /**
     * @returns {Boolean}
     */
    isValid() {
        this.validate(true); // silent

        return this.error ? false : super.isValid()
    }

    /**
     * @param args
     * @returns {Object} config
     */
    mergeConfig(...args) {
        let me       = this,
            config   = super.mergeConfig(...args),
            triggers = config.triggers || me.triggers;

        me[triggers ? 'triggers' : '_triggers'] = triggers;

        delete config.triggers;
        return config
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.path
     * @protected
     */
    onFocusEnter(data) {
        super.onFocusEnter(data);

        let me    = this,
            {cls} = me;

        if (!me.readOnly) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(cls, 'neo-focus');
            me.cls = cls;

            if (me.labelPosition === 'inline') {
                if (me.centerBorderElWidth) {
                    me.getCenterBorderEl().width = me.centerBorderElWidth;
                    me.update()
                } else {
                    me.updateCenterBorderElWidth(false)
                }
            }
        }
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.oldPath
     * @protected
     */
    onFocusLeave(data) {
        let me             = this,
            centerBorderEl = me.getCenterBorderEl(), // labelPosition: 'inline'
            cls;

        if (!me.readOnly) {
            me.validate(false);

            cls = me.cls; // has to get set after validate()

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].remove(cls, 'neo-focus');
            me.cls = cls;

            if (centerBorderEl && me.isEmpty()) {
                delete centerBorderEl.width
            }
        }

        if (Neo.isString(me.value)) {
            me.value = me.value.trim()
        }

        me.update();

        super.onFocusLeave(data)
    }

    /**
     * Gets triggered by the 'input' DOM event.
     * @param {Object} data
     * @protected
     */
    onInputValueChange(data) {
        let me         = this,
            oldValue   = me.value,
            inputValue = data.value,
            vnode      = _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].findChildVnode(me.vnode, {nodeName: 'input'});

        if (vnode) {
            // Update the current state (modified DOM by the user) to enable the delta-updates logic.
            // Required e.g. for validation -> revert a wrong user input
            vnode.vnode.attributes.value = inputValue
        }

        if (Neo.isString(inputValue)) {
            inputValue = inputValue.trim()
        }

        me.clean      = false;
        me.inputValue = me.inputValueAdjustor(inputValue); // updates this.value

        me.fireUserChangeEvent(me.value, oldValue)
    }

    /**
     * @param {Object} data
     */
    onMouseEnter(data) {
        let me    = this,
            {cls} = me;

        if (!me.readOnly) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(cls, 'neo-hovered');
            me.cls = cls
        }
    }

    /**
     * @param {Object} data
     */
    onMouseLeave(data) {
        let me    = this,
            {cls} = me;

        if (!me.readOnly) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].remove(cls, 'neo-hovered');
            me.cls = cls
        }
    }

    /**
     * Removes all triggers of a given type
     * @param {String} type
     * @param {Boolean} [silent=false] true prevents a vdom update
     * @param {Array} [triggerSource] pass a shallow copy of this.triggers
     * @returns {Boolean} true in case a trigger was found & removed
     */
    removeTrigger(type, silent = false, triggerSource) {
        let me       = this,
            hasMatch = false,
            triggers = triggerSource || me.triggers || [],
            i        = 0,
            len      = triggers.length,
            trigger;

        for (; i < len; i++) {
            trigger = triggers[i];

            if (trigger.type === type) {
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].remove(triggers, trigger);
                len--;
                hasMatch = true
            }
        }

        if (hasMatch && !silent) {
            me.triggers = triggers
        }

        return hasMatch
    }

    /**
     * Resets the field to its original value or null depending on the clearToOriginalValue config
     * You can optionally pass a new value, which will adjust the originalConfig.value if needed.
     * @param {String|null} [value=null]
     */
    reset(value = null) {
        let me = this;

        if (me.clearToOriginalValue) {
            if (value) {
                me.originalConfig.value = value
            } else {
                value = me.originalConfig.value
            }
        }

        super.reset(value);

        if (value === null && me.clean) {
            me.updateError(null)
        }
    }

    /**
     * Used for labelPosition: 'inline' to adjust the top border matching to the length of the label
     * @param {Boolean} [silent=false] true to get the value, but not apply it to the DOM
     * @protected
     */
    updateCenterBorderElWidth(silent = false) {
        let me = this;

        me.mounted && me.getDomRect(me.getCenterBorderEl().id).then(data => {
            me.centerBorderElWidth = Math.round(data.width * .7) + 8;

            if (!silent) {
                me.getCenterBorderEl().width = me.centerBorderElWidth;
                me.update()
            }
        })
    }

    /**
     @param {String|null} value
     @param {Boolean} silent=false
     */
    updateError(value, silent = false) {
        let me    = this,
            {cls} = me,
            errorNode, errorWrapper;

        if (!(me.clean && !me.mounted)) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"][value ? 'add' : 'remove'](cls, 'neo-invalid');
            me.cls = cls;

            errorWrapper = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].findVdomChild(me.vdom, {cls: 'neo-textfield-error-wrapper'}).vdom;
            errorNode    = errorWrapper.cn[0];

            if (value) {
                errorNode.html = value
            } else {
                delete errorNode.html
            }

            errorWrapper.removeDom = !value;

            !silent && me.update()
        }
    }

    /**
     * Override this method as needed inside class extensions.
     * @param {*} value
     * @protected
     */
    updateInputValueFromValue(value) {
        this.inputValue = value
    }

    /**
     * Calculates the new inputWidth based on the labelWidth & total width
     * @protected
     */
    updateInputWidth() {
        let me         = this,
            inputWidth = me.getInputWidth();

        if (inputWidth !== null && inputWidth !== me.width) {
            me.vdom.cn[1].width = inputWidth
        } else {
            delete me.vdom.cn[1].width
        }

        me.update()
    }

    /**
     * The DOM based readonly attribute needs to honor the editable & readOnly configs
     */
    updateReadOnlyState() {
        let me = this;

        me.changeInputElKey('readonly', !me.editable || me.readOnly || null)
    }

    /**
     * Since triggers do not get rendered, assign the relevant props
     * todo: this could be handled by component.Base
     */
    updateTriggerVnodes() {
        let me          = this,
            triggerRoot = me.vnode?.childNodes[1],
            childNodes  = triggerRoot?.childNodes || [],
            trigger;

        childNodes.forEach(vnode => {
            trigger = me.getTriggerById(vnode.id);

            trigger && Object.assign(trigger, {
                vnode,
                _rendered: true,
                _mounted : true
            })
        })
    }

    /**
     * Override this method as needed inside class extensions.
     * @param {String} inputValue
     * @protected
     */
    updateValueFromInputValue(inputValue) {
        this.value = inputValue
    }

    /**
     * Checks for client-side field errors
     * @param {Boolean} silent=true
     * @returns {Boolean} Returns true in case there are no client-side errors
     */
    validate(silent=true) {
        let me          = this,
            {inputPattern, maxLength, minLength, required, value} = me,
            returnValue = true,
            valueLength = value?.toString().length,
            isEmpty     = value !== 0 && (!value || valueLength < 1),
            errorParam  = {inputPattern, maxLength, minLength, valueLength},
            errorText;

        if (!silent) {
            // in case we manually call validate(false) on a form or field before it is mounted, we do want to see errors.
            me.clean = false
        }

        if (isEmpty) {
            if (required) {
                me._error   = me.errorTextRequired;
                returnValue = false
            }
        } else {
            if (Neo.isNumber(maxLength) && valueLength > maxLength) {
                me._error   = me.errorTextMaxLength(errorParam);
                returnValue = false
            } else if (Neo.isNumber(minLength) && valueLength < minLength) {
                me._error   = me.errorTextMinLength(errorParam);
                returnValue = false
            } else if (inputPattern && !inputPattern.test(value)) {
                me._error   = me.errorTextInputPattern(errorParam);
                returnValue = false
            } else if (Neo.isFunction(me.validator)) {
                errorText = me.validator(me);

                if (errorText !== true) {
                    me._error   = errorText;
                    returnValue = false
                }
            }
        }

        if (returnValue) {
            me._error = null
        }

        !me.clean && me.updateError(me._error, silent);

        return !returnValue ? false : super.validate(silent)
    }
}

Neo.setupClass(Text);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Text);


/***/ }),

/***/ "./src/form/field/trigger/Base.mjs":
/*!*****************************************!*\
  !*** ./src/form/field/trigger/Base.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * Base class for form field Triggers
 * @class Neo.form.field.trigger.Base
 * @extends Neo.component.Base
 */
class Base extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for align
     * @member {String[]} alignValues=['end', 'start']
     * @protected
     * @static
     */
    static alignValues = ['end', 'start']

    static config = {
        /**
         * @member {String} className='Neo.form.field.trigger.Base'
         * @protected
         */
        className: 'Neo.form.field.trigger.Base',
        /**
         * @member {String} ntype='trigger'
         * @protected
         */
        ntype: 'trigger',
        /**
         * @member {String} align_='end'
         */
        align: 'end',
        /**
         * @member {String[]} baseCls=['neo-field-trigger']
         */
        baseCls: ['neo-field-trigger'],
        /**
         * @member {Neo.form.field.Base|null} field=null
         */
        field_: null,
        /**
         * @member {String|null} iconCls_=null
         */
        iconCls_: null,
        /**
         * @member {Boolean} isHovered=false
         * @protected
         */
        isHovered: false,
        /**
         * The scope of the trigger handler
         * @member {Neo.core.Base|null} scope=null
         */
        scope: null,
        /**
         * @member {Boolean} showOnHover=false
         */
        showOnHover: false,
        /**
         * Internal flag used by field.getTrigger()
         * @member {String} type='base'
         * @protected
         */
        type: 'base',
        /**
         * @member {Number} weight_=10
         */
        weight_: 10
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.addDomListeners(
            {click: me.onTriggerClick, scope: me}
        );

        if (me.showOnHover) {
            me.hidden = true;

            me.field.on('constructed', () => {
                me.field.addDomListeners([
                    {mouseenter: me.onMouseEnter, scope: me},
                    {mouseleave: me.onMouseLeave, scope: me}
                ])
            }, me)
        }
    }

    /**
     * Triggered after the align config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetAlign(value, oldValue) {
        let cls = this.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"][value === 'start' ? 'add' : 'remove'](cls, 'neo-align-start');
        this.cls = cls
    }

    /**
     * Triggered after the field config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetField(value, oldValue) {
        (this.vdom.data || (this.vdom.data = {})).focus = value?.getInputElId()
    }

    /**
     * Triggered after the hidden config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetHidden(value, oldValue) {
        let {style} = this;

        style.display = value ? 'none' : 'inherit';
        this.style = style
    }

    /**
     * Triggered after the iconCls config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetIconCls(value, oldValue) {
        let {cls} = this;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, oldValue);

        if (value && value !== '') {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, value)
        }

        this.cls = cls
    }

    /**
     * Triggered before the align config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetAlign(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'align', 'alignValues')
    }

    /**
     * @param {Boolean} updateParentVdom
     * @param {Boolean} silent
     */
    destroy(updateParentVdom, silent) {
        let me = this;

        me.removeDomListeners(
            {click: me.onTriggerClick, scope: me}
        );

        delete me.field;

        super.destroy(updateParentVdom, silent)
    }

    /**
     *
     */
    onMouseEnter() {
        this.isHovered = true;
        this.hidden    = false;
    }

    /**
     *
     */
    onMouseLeave() {
        this.isHovered = false;
        this.hidden    = true;
    }

    /**
     * click domEvent listener
     * @param {Object} data
     * @protected
     */
    onTriggerClick(data) {
        let me    = this,
            scope = me.scope || me;

        if (me.handler) {
            scope[me.handler].call(scope)
        }
    }
}

Neo.setupClass(Base);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Base);


/***/ }),

/***/ "./src/form/field/trigger/Clear.mjs":
/*!******************************************!*\
  !*** ./src/form/field/trigger/Clear.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/form/field/trigger/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * Clear Trigger to remove the input value of TextFields or subclasses
 * @class Neo.form.field.trigger.Clear
 * @extends Neo.form.field.trigger.Base
 */
class Clear extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.form.field.trigger.Clear'
         * @protected
         */
        className: 'Neo.form.field.trigger.Clear',
        /**
         * @member {String} ntype='trigger-clear'
         * @protected
         */
        ntype: 'trigger-clear',
        /**
         * @member {String[]} baseCls=['neo-field-trigger','neo-trigger-clear']
         */
        baseCls: ['neo-field-trigger', 'neo-trigger-clear'],
        /**
         * @member {String|null} iconCls='fa fa-times'
         */
        iconCls: 'fa fa-times',
        /**
         * Internal flag used by field.getTrigger()
         * @member {String} type='clear'
         * @protected
         */
        type: 'clear',
        /**
         * @member {Number} weight_=20
         */
        weight: 20
    }

    /**
     * Triggered after the hidden config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetHidden(value, oldValue) {
        let {cls} = this;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"][value ? 'add' : 'remove'](cls, 'neo-is-hidden');
        this.cls = cls;
    }

    /**
     * Triggered before the hidden config gets changed.
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    beforeSetHidden(value, oldValue) {
        if (this.showOnHover && !this.isHovered) {
            return true
        }

        return value
    }

    /**
     *
     */
    destroy(...args) {
        let me = this;

        me.field.un({
            change                    : me.onFieldChange,
            changeClearToOriginalValue: me.onFieldChange,
            scope                     : me
        });

        super.destroy(...args)
    }

    /**
     * @returns {Boolean} true in case the trigger should be hidden
     */
    getHiddenState() {
        let me      = this,
            {field} = me,
            {value} = field;

        if (field.clearToOriginalValue) {
            return value === field.originalConfig.value;
        } else {
            if (value === 0) {
                value = '0'
            }

            return !field.value || value.toString().length < 1
        }
    }

    /**
     * @param {Object} opts
     */
    onFieldChange(opts) {
        this.hidden = this.getHiddenState()
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me = this;

        me.field.on({
            change                    : me.onFieldChange,
            changeClearToOriginalValue: me.onFieldChange,
            scope                     : me
        });

        me.hidden = me.getHiddenState()
    }

    /**
     * @override
     */
    onMouseEnter() {
        let me = this;

        me.isHovered = true;
        me.hidden    = me.getHiddenState()
    }

    /**
     * @param {Object} data
     */
    onTriggerClick(data) {
        this.field.clear()
    }
}

Neo.setupClass(Clear);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Clear);


/***/ }),

/***/ "./src/util/String.mjs":
/*!*****************************!*\
  !*** ./src/util/String.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.util.String
 * @extends Neo.core.Base
 */
class StringUtil extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @member {Object} charEntityMap
     * @static
     */
    static charEntityMap = {
        '&' : '&amp;',
        '<' : '&lt;',
        '>' : '&gt;',
        '"' : '&quot;',
        '\'': '&apos;',
        '$' : '&dollar;',
        '\\': '&bsol;',
        '/' : '&sol;'
    }
    /**
     * @member {RegExp} charPattern
     * @static
     */
    static charPattern = /[&<>"'$\\]/g
    /**
     * @member {RegExp} entityPattern
     * @static
     */
    static entityPattern = /(&amp;)|(&lt;)|(&gt;)|(&quot;)|(&apos;)|(&dollar;)|(&bsol;)|(&sol;)/g

    static config = {
        /**
         * @member {String} className='Neo.util.String'
         * @protected
         */
        className: 'Neo.util.String'
    }

    /**
     * Escape HTML special characters
     * @param {String} value
     */
    static escapeHtml(value) {
        let me = this; // inside a static method, we are pointing to the class prototype

        if (!Neo.isString(value)) {
            return value
        }

        return value.replace(me.charPattern, me.getEntityFromChar.bind(me))
    }

    /**
     * Get char equivalent of a mapped entity
     * @param {String} entity
     */
    static getCharFromEntity(entity) {
        let mappedChar = Object.keys(this.charEntityMap).find(key => this.charEntityMap[key] === entity);
        return mappedChar || entity
    }

    /**
     * Get entity equivalent of a mapped char
     * @param {String} char
     */
    static getEntityFromChar(char) {
        return this.charEntityMap[char] || char
    }

    /**
     * Unescape HTML special characters
     * @param {String} value
     */
    static unescapeHtml(value) {
        let me = this; // inside a static method, we are pointing to the class prototype

        if (!Neo.isString(value)) {
            return value
        }

        return value.replace(me.entityPattern, me.getCharFromEntity.bind(me))
    }

    /**
     * Returns the passed string with the first letter uncapitalized.
     * @param {String} value
     * @returns  {String}
     */
    static uncapitalize(value) {
        return value && value[0].toLowerCase() + value.substring(1)
    }
}

Neo.setupClass(StringUtil);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StringUtil);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXNDO0FBQ1E7QUFDQztBQUNDO0FBQ0M7QUFDRjtBQUNDOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpREFBSTtBQUN2QjtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVLHdEQUF3RCxrQkFBa0I7QUFDeEc7QUFDQSxtRUFBbUUsa0JBQWtCO0FBQ3JGO0FBQ0E7QUFDQSxvQkFBb0IsVUFB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dkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlFQUFlLFVBQVUsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvZm9ybS9maWVsZC9UZXh0Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2Zvcm0vZmllbGQvdHJpZ2dlci9CYXNlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2Zvcm0vZmllbGQvdHJpZ2dlci9DbGVhci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy91dGlsL1N0cmluZy5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2UgICAgICAgICBmcm9tICcuL0Jhc2UubWpzJztcbmltcG9ydCBCYXNlVHJpZ2dlciAgZnJvbSAnLi90cmlnZ2VyL0Jhc2UubWpzJztcbmltcG9ydCBDbGVhclRyaWdnZXIgZnJvbSAnLi90cmlnZ2VyL0NsZWFyLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgIGZyb20gJy4uLy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBTdHJpbmdVdGlsICAgZnJvbSAnLi4vLi4vdXRpbC9TdHJpbmcubWpzJztcbmltcG9ydCBWRG9tVXRpbCAgICAgZnJvbSAnLi4vLi4vdXRpbC9WRG9tLm1qcyc7XG5pbXBvcnQgVk5vZGVVdGlsICAgIGZyb20gJy4uLy4uL3V0aWwvVk5vZGUubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmZvcm0uZmllbGQuVGV4dFxuICogQGV4dGVuZHMgTmVvLmZvcm0uZmllbGQuQmFzZVxuICovXG5jbGFzcyBUZXh0IGV4dGVuZHMgQmFzZSB7XG4gICAgLyoqXG4gICAgICogVmFsaWQgdmFsdWVzIGZvciBhdXRvQ2FwaXRhbGl6ZVxuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBhdXRvQ2FwaXRhbGl6ZVZhbHVlcz1bJ2NoYXJhY3RlcnMnLCdub25lJywnb24nLCdvZmYnLCdzZW50ZW5jZXMnLCd3b3JkcyddXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgYXV0b0NhcGl0YWxpemVWYWx1ZXMgPSBbJ2NoYXJhY3RlcnMnLCAnbm9uZScsICdvbicsICdvZmYnLCAnc2VudGVuY2VzJywgJ3dvcmRzJ11cbiAgICAvKipcbiAgICAgKiBWYWxpZCB2YWx1ZXMgZm9yIGxhYmVsUG9zaXRpb25cbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gbGFiZWxQb3NpdGlvbnM9Wydib3R0b20nLCdpbmxpbmUnLCdsZWZ0JywncmlnaHQnLCd0b3AnXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGxhYmVsUG9zaXRpb25zID0gWydib3R0b20nLCAnaW5saW5lJywgJ2xlZnQnLCAncmlnaHQnLCAndG9wJ11cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmZvcm0uZmllbGQuVGV4dCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmZvcm0uZmllbGQuVGV4dCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSd0ZXh0ZmllbGQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAndGV4dGZpZWxkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGVudW1lcmF0ZWQgYXR0cmlidXRlIHRoYXQgY29udHJvbHMgd2hldGhlciBhbmQgaG93IHRleHQgaW5wdXQgaXMgYXV0b21hdGljYWxseSBjYXBpdGFsaXplZCBhcyBpdCBpc1xuICAgICAgICAgKiBlbnRlcmVkL2VkaXRlZCBieSB0aGUgdXNlci5cbiAgICAgICAgICogVmFsaWQgdmFsdWVzOiAnY2hhcmFjdGVycycsICdub25lJywgJ29uJywgJ29mZicsICdzZW50ZW5jZXMnLCAnd29yZHMnXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gYXV0b0NhcGl0YWxpemU9b2ZmJ1xuICAgICAgICAgKi9cbiAgICAgICAgYXV0b0NhcGl0YWxpemVfOiAnb2ZmJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGF1dG9Db21wbGV0ZV89ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9Db21wbGV0ZV86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tdGV4dGZpZWxkJ11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLXRleHRmaWVsZCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgdmFyaWFibGUgdG8gc3RvcmUgdGhlIGFjdHVhbCB3aWR0aCBmb3IgdGhlIGxhYmVsIGNlbnRlckJvcmRlckVsXG4gICAgICAgICAqIChvbmx5IG5lZWRlZCBmb3IgbGFiZWxQb3NpdGlvbjogJ2lubGluZScpXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBjZW50ZXJCb3JkZXJFbFdpZHRoPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2VudGVyQm9yZGVyRWxXaWR0aDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgc2hvd3MgYSBjbGVhciB0cmlnZ2VyIGluIGNhc2UgdGhlIGZpZWxkIGhhcyBhIG5vbi1lbXB0eSB2YWx1ZS5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gY2xlYXJhYmxlXz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhcmFibGVfOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSB3aWxsIHJlc2V0IHRoZSBmaWVsZCB0byBpdHMgaW5pdGlhbCB2YWx1ZSBjb25maWcuXG4gICAgICAgICAqIFJlY29tbWVuZGVkIGZvciBmaWVsZHMgd2l0aCByZXF1aXJlZDogdHJ1ZVxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBjbGVhclRvT3JpZ2luYWxWYWx1ZV89ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyVG9PcmlnaW5hbFZhbHVlXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcmV2ZW50IHVzZXJzIGZyb20gdHlwaW5nIHNwZWNpZmljIGNoYXJhY3RlcnMuXG4gICAgICAgICAqIEUuZy4gZGlzYWJsaW5nICstZSBmb3IgTnVtYmVyRmllbGRzXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfG51bGx9IGRpc2FibGVkQ2hhcnNfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRpc2FibGVkQ2hhcnNfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0dGluZyBgZWRpdGFibGVgIHRvIGBmYWxzZWAgbWVhbnMgdGhhdCB0aGUgaW5wdXQgZmllbGQgd2lsbCBiZSByZWFkLW9ubHlcbiAgICAgICAgICogYnV0IHRoZSBmaWVsZCBpcyBzdGlsbCB3b3JrYWJsZSBhbmQgbWF5IGhhdmUgaXRzIHZhbHVlIGNoYW5nZWQgYnkgdXNlciBpbnRlcmFjdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIGV4YW1wbGUgcGlja2VyIGZpZWxkcyBzdWNoIGFzIGBEYXRlYCBhbmQgYFNlbGVjdGAgbWF5IHN0aWxsIGhhdmUgdGhlaXJcbiAgICAgICAgICogdmFsdWVzIGNoYW5nZWQgYnkgc2VsZWN0aW5nIGZyb20gdGhlIHBpY2tlciB1c2luZyBrZXlib2FyZCBvciBwb2ludGVyLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBlZGl0YWJsZV89dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgZWRpdGFibGVfOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uZmlndXJlIHRoZSB2YWx1ZSBvZiBlbXB0eSBmaWVsZHMuIG51bGwgb3IgYW4gZW1wdHkgc3RyaW5nIGlzIHJlY29tbWVuZGVkLlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gZW1wdHlWYWx1ZT1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBlbXB0eVZhbHVlOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGVycm9yXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBlcnJvcl86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VmdWwgZm9yIGZpZWxkcyBpbnNpZGUgYSBjc3MgZ3JpZCB3aGVyZSBlcnJvcnMgc2hvdWxkIGxpdmUgb3V0c2lkZSB0aGUgbGF5b3V0XG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGVycm9yUG9zaXRpb25BYnNvbHV0ZV89ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGVycm9yUG9zaXRpb25BYnNvbHV0ZV86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogZGF0YSBwYXNzZXMgaW5wdXRQYXR0ZXJuLCBtYXhMZW5ndGgsIG1pbkxlbmd0aCAmIHZhbHVlTGVuZ3RoIHByb3BlcnRpZXNcbiAgICAgICAgICogQG1lbWJlciB7RnVuY3Rpb259IGVycm9yVGV4dElucHV0UGF0dGVybj1kYXRhPT5gSW5wdXQgcGF0dGVybiB2aW9sYXRpb246ICR7ZGF0YS5pbnB1dFBhdHRlcm59YFxuICAgICAgICAgKi9cbiAgICAgICAgZXJyb3JUZXh0SW5wdXRQYXR0ZXJuOiBkYXRhID0+IGBJbnB1dCBwYXR0ZXJuIHZpb2xhdGlvbjogJHtkYXRhLmlucHV0UGF0dGVybn1gLFxuICAgICAgICAvKipcbiAgICAgICAgICogZGF0YSBwYXNzZXMgaW5wdXRQYXR0ZXJuLCBtYXhMZW5ndGgsIG1pbkxlbmd0aCAmIHZhbHVlTGVuZ3RoIHByb3BlcnRpZXNcbiAgICAgICAgICogQG1lbWJlciB7RnVuY3Rpb259IGVycm9yVGV4dE1heExlbmd0aD1kYXRhPT5gTWF4IGxlbmd0aCB2aW9sYXRpb246ICR7dmFsdWVMZW5ndGh9IC8gJHttYXhMZW5ndGh9YFxuICAgICAgICAgKi9cbiAgICAgICAgZXJyb3JUZXh0TWF4TGVuZ3RoOiBkYXRhID0+IGBNYXggbGVuZ3RoIHZpb2xhdGlvbjogJHtkYXRhLnZhbHVlTGVuZ3RofSAvICR7ZGF0YS5tYXhMZW5ndGh9YCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRhdGEgcGFzc2VzIGlucHV0UGF0dGVybiwgbWF4TGVuZ3RoLCBtaW5MZW5ndGggJiB2YWx1ZUxlbmd0aCBwcm9wZXJ0aWVzXG4gICAgICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBlcnJvclRleHRNaW5MZW5ndGg9ZGF0YT0+YE1pbiBsZW5ndGggdmlvbGF0aW9uOiAke2RhdGEudmFsdWVMZW5ndGh9IC8gJHtkYXRhLm1pbkxlbmd0aH1gXG4gICAgICAgICAqL1xuICAgICAgICBlcnJvclRleHRNaW5MZW5ndGg6IGRhdGEgPT4gYE1pbiBsZW5ndGggdmlvbGF0aW9uOiAke2RhdGEudmFsdWVMZW5ndGh9IC8gJHtkYXRhLm1pbkxlbmd0aH1gLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBlcnJvclRleHRSZXF1aXJlZD0nUmVxdWlyZWQnXG4gICAgICAgICAqL1xuICAgICAgICBlcnJvclRleHRSZXF1aXJlZDogJ1JlcXVpcmVkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGhpZGVMYWJlbF89ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGhpZGVMYWJlbF86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7UmVnRXhwfG51bGx9IGlucHV0UGF0dGVybl89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgaW5wdXRQYXR0ZXJuXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGZhbHNlLCB0aGUgaW5wdXRQYXR0ZXJuIHdpbGwgb25seSBnZXQgdmFsaWRhdGVkIHZpYSBKYXZhU2NyaXB0LCBidXQgbm90IGdldHRpbmcgYXBwbGllZCBvbiBET00gbGV2ZWwuXG4gICAgICAgICAqIFRoZSByZWdleCBzdXBwb3J0IGZvciBpbnB1dCBiYXNlZCBwYXR0ZXJucyBpcyBub3QgZnVsbHkgdGhlcmUgeWV0LCBzbyBmZWVsIGZyZWUgdG8gZGlzYWJsZSB0aGlzIGZlYXR1cmVcbiAgICAgICAgICogaWYgbmVlZGVkIChFLmcuIGZvcm0uZmllbGQuUGhvbmUpLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpbnB1dFBhdHRlcm5ET01fPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGlucHV0UGF0dGVybkRPTV86IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGlucHV0VHlwZV89J3RleHQnXG4gICAgICAgICAqL1xuICAgICAgICBpbnB1dFR5cGVfOiAndGV4dCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gaW5wdXRWYWx1ZV89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgaW5wdXRWYWx1ZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gbGFiZWxCYXNlQ2xzPVsnbmVvLXRleHRmaWVsZC1sYWJlbCddXG4gICAgICAgICAqL1xuICAgICAgICBsYWJlbEJhc2VDbHM6IFsnbmVvLXRleHRmaWVsZC1sYWJlbCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGxhYmVsQ2xzXz1bXVxuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWxDbHNfOiBbXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVkZ2UtY2FzZSBjb25maWcgaW4gY2FzZSB3ZSB3YW50IHRvIHJlbmRlciBsZWFkaW5nIGNvbnRlbnQgd2l0aCB0aGVpciBvd24gc2VsZWN0b3JzIGxpa2U6XG4gICAgICAgICAqIDxzcGFuIGNsYXNzPVwibXktbGFiZWwtaWQtY2xzXCI+RTEwPC9zcGFuPiDigKIgRmlyc3RuYW1lXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBsYWJlbElkXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBsYWJlbElkXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENTUyBydWxlcyBmb3IgbGFiZWxJZFxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gbGFiZWxJZENsc189W11cbiAgICAgICAgICovXG4gICAgICAgIGxhYmVsSWRDbHNfOiBbXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlcGFyYXRvciBiZXR3ZWVuIGxhYmVsSWQgJiBsYWJlbFRleHRcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBsYWJlbElkU2VwYXJhdG9yXz0nIMK3ICdcbiAgICAgICAgICovXG4gICAgICAgIGxhYmVsSWRTZXBhcmF0b3JfOiAnIMK3ICcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGxhYmVsT3B0aW9uYWxUZXh0Xz0nIChPcHRpb25hbCknXG4gICAgICAgICAqL1xuICAgICAgICBsYWJlbE9wdGlvbmFsVGV4dF86ICcgKE9wdGlvbmFsKScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWxpZCB2YWx1ZXM6ICdib3R0b20nLCAnaW5saW5lJywgJ2xlZnQnLCAncmlnaHQnLCAndG9wJ1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGxhYmVsUG9zaXRpb25fPSdsZWZ0J1xuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWxQb3NpdGlvbl86ICdsZWZ0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbGFiZWxUZXh0Xz0nTGFiZWxUZXh0J1xuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWxUZXh0XzogJ0xhYmVsVGV4dCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkZWZhdWx0cyB0byBweFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8U3RyaW5nfSBsYWJlbFdpZHRoXz0xNTBcbiAgICAgICAgICovXG4gICAgICAgIGxhYmVsV2lkdGhfOiAxNTAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWF4aW11bSBhbW91bnQgb2YgY2hhcnMgd2hpY2ggeW91IGNhbiBlbnRlciBpbnRvIHRoaXMgZmllbGRcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IG1heExlbmd0aF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgbWF4TGVuZ3RoXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtaW5pbXVtIGFtb3VudCBvZiBjaGFycyB3aGljaCB5b3UgY2FuIGVudGVyIGludG8gdGhpcyBmaWVsZFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gbWluTGVuZ3RoXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBtaW5MZW5ndGhfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IHBsYWNlaG9sZGVyVGV4dF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgcGxhY2Vob2xkZXJUZXh0XzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHRpbmcgYHJlYWRPbmx5YCBtZWFucyB0aGF0IHRoZSBmaWVsZCBtYXkgbm90IGJlIGNoYW5nZWQgYnkgdXNlciBpbnRlcmFjdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGlucHV0IGZpZWxkIHdpbGwgYmUgcmVhZC1vbmx5IGFuZCBvdGhlciB3YXlzIG9mIGNoYW5naW5nIHRoZSBmaWVsZCdzIHZhbHVlXG4gICAgICAgICAqIChzdWNoIGFzIGJ5IG9wZXJhdGluZyBwaWNrZXJzKSB3aWxsIGJlIGRpc2FibGVkLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSByZWFkT25seV89ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHJlYWRPbmx5XzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSByZXF1aXJlZF89ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHJlcXVpcmVkXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaG93T3B0aW9uYWxUZXh0Xz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgc2hvd09wdGlvbmFsVGV4dF86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogbnVsbCA9PiBGb2xsb3cgdGhlIGVsZW1lbnQncyBkZWZhdWx0IGJlaGF2aW9yIGZvciBzcGVsbCBjaGVja2luZ1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufG51bGx9IHNwZWxsQ2hlY2tfPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBzcGVsbENoZWNrXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gc3ViTGFiZWxCYXNlQ2xzPVsnbmVvLXRleHRmaWVsZC1zdWJsYWJlbCddXG4gICAgICAgICAqL1xuICAgICAgICBzdWJMYWJlbEJhc2VDbHM6IFsnbmVvLXRleHRmaWVsZC1zdWJsYWJlbCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IHN1YkxhYmVsQ2xzXz1bXVxuICAgICAgICAgKi9cbiAgICAgICAgc3ViTGFiZWxDbHNfOiBbXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gc3ViTGFiZWxUZXh0Xz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBzdWJMYWJlbFRleHRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fE9iamVjdFtdfG51bGx9IHRyaWdnZXJzXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB0cmlnZ2Vyc186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2luZyB0aGUgYWxlcnQgc3RhdGUgd2lsbCBkaXNwbGF5IGFuIGVtcHR5IGJ1dCByZXF1aXJlZCBmaWVsZCBpbiBvcmFuZ2UgaW5zdGVhZCBvZiByZWQuXG4gICAgICAgICAqIEludGVuZGVkIHRvIGdldCBjb21iaW5lZCB3aXRoIGZvcm0uQ29udGFpbmVyOiBnZXRGb3JtU3RhdGUoKS5cbiAgICAgICAgICogU2VlIGFwcHMvZm9ybSBhcyBhbiBleGFtcGxlLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB1c2VBbGVydFN0YXRlXz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdXNlQWxlcnRTdGF0ZV86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQSBzdHJpbmcgYmFzZWQgdmFsdWUgd2lsbCBnZXQgcmVzb2x2ZWQgaW50byB0aGUgY2xvc2VzdCBjb250cm9sbGVyIHdoaWNoIGltcGxlbWVudHMgaXRcbiAgICAgICAgICogQG1lbWJlciB7RnVuY3Rpb258U3RyaW5nfG51bGx9IHZhbGlkYXRvcj1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB2YWxpZGF0b3I6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXRWbHVlIGNhbiBiZSB4c3NQcm90ZWN0ZWQgYW5kIHZhbHVlcyBhcmUgZXNjYXBlZFxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB4c3NQcm90ZWN0ZWQ9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHhzc1Byb3RlY3RlZF86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbVxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gX3Zkb21cbiAgICAgICAgICovXG4gICAgICAgIF92ZG9tOlxuICAgICAgICB7Y246IFtcbiAgICAgICAgICAgIHt0YWc6ICdsYWJlbCcsIGNsczogW10sIHN0eWxlOiB7fX0sXG4gICAgICAgICAgICB7dGFnOiAnbGFiZWwnLCBjbHM6IFtdfSxcbiAgICAgICAgICAgIHt0YWc6ICdpbnB1dCcsIGNsczogWyduZW8tdGV4dGZpZWxkLWlucHV0J10sIGZsYWc6ICduZW8tcmVhbC1pbnB1dCcsIHN0eWxlOiB7fX0sXG4gICAgICAgICAgICB7Y2xzOiBbJ25lby10ZXh0ZmllbGQtZXJyb3Itd3JhcHBlciddLCByZW1vdmVEb206IHRydWUsIGNuOiBbXG4gICAgICAgICAgICAgICAge2NsczogWyduZW8tdGV4dGZpZWxkLWVycm9yJ119XG4gICAgICAgICAgICBdfVxuICAgICAgICBdfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGlzIHZhbHVlIHRvIGZhbHNlLCBpbiBjYXNlIGEgZmllbGQgc2hvdWxkIGRpc3BsYXkgZXJyb3JzIHVwIGZyb250LlxuICAgICAqIE90aGVyd2lzZSwgZXJyb3JzIHdpbGwgc3RheSBoaWRkZW4gb24gbW91bnRpbmcsIHVubGVzcyB5b3UgdHJpZ2dlciB2YWxpZGF0ZShmYWxzZSkuXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gY2xlYW49dHJ1ZVxuICAgICAqL1xuICAgIGNsZWFuID0gdHJ1ZVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5hZGREb21MaXN0ZW5lcnMoW1xuICAgICAgICAgICAge2lucHV0ICAgICA6IG1lLm9uSW5wdXRWYWx1ZUNoYW5nZSwgc2NvcGU6IG1lfSxcbiAgICAgICAgICAgIHttb3VzZWVudGVyOiBtZS5vbk1vdXNlRW50ZXIsICAgICAgIHNjb3BlOiBtZX0sXG4gICAgICAgICAgICB7bW91c2VsZWF2ZTogbWUub25Nb3VzZUxlYXZlLCAgICAgICBzY29wZTogbWV9XG4gICAgICAgIF0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBhcHBOYW1lIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0QXBwTmFtZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRBcHBOYW1lKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgdmFsdWUgJiYgdGhpcy50cmlnZ2Vycz8uZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGl0ZW0uYXBwTmFtZSA9IHZhbHVlXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBhdXRvQ2FwaXRhbGl6ZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRBdXRvQ2FwaXRhbGl6ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VJbnB1dEVsS2V5KCdhdXRvY2FwaXRhbGl6ZScsIHZhbHVlID09PSAnb2ZmJyB8fCB2YWx1ZSA9PT0gJ25vbmUnID8gbnVsbCA6IHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgYXV0b0NvbXBsZXRlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIENocm9tZSBpZ25vcmVzIGEgdmFsdWUgb2YgXCJvZmZcIiwgc28gd2Ugc3RpY2sgdG8gYSBkaWZmZXJlbnQgdmFsdWUgaW5zdGVhZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0QXV0b0NvbXBsZXRlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICAvLyB3aGlsZSBcIm9mZlwiIGlzIHRoZSBjb3JyZWN0IHZhbHVlLCBicm93c2VyIHZlbmRvcnMgaWdub3JlIGl0LiBBcmJpdHJhcnkgc3RyaW5ncyBkbyB0aGUgdHJpY2suXG4gICAgICAgIHRoaXMuY2hhbmdlSW5wdXRFbEtleSgnYXV0b2NvbXBsZXRlJywgdmFsdWUgPyBudWxsIDogJ25vJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGNsZWFyYWJsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldENsZWFyYWJsZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIHRyaWdnZXJzO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdHJpZ2dlcnMgPSBtZS50cmlnZ2VycyB8fCBbXTtcbiAgICAgICAgICAgIHRyaWdnZXJzLnVuc2hpZnQoQ2xlYXJUcmlnZ2VyKTtcbiAgICAgICAgICAgIG1lLnRyaWdnZXJzID0gdHJpZ2dlcnNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLnJlbW92ZVRyaWdnZXIoJ2NsZWFyJylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgY2xlYXJUb09yaWdpbmFsVmFsdWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRDbGVhclRvT3JpZ2luYWxWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5maXJlKCdjaGFuZ2VDbGVhclRvT3JpZ2luYWxWYWx1ZScsIHtcbiAgICAgICAgICAgIG9sZFZhbHVlLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGRpc2FibGVkQ2hhcnMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXXxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nW118bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXREaXNhYmxlZENoYXJzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIE5lby5tYWluLkRvbUV2ZW50cy5yZWdpc3RlckRpc2FibGVkSW5wdXRDaGFycyh7XG4gICAgICAgICAgICAgICAgYXBwTmFtZTogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICBjaGFycyAgOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBpZCAgICAgOiBtZS5nZXRJbnB1dEVsKCkuaWRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGVkaXRhYmxlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RWRpdGFibGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjbHN9ID0gbWU7XG5cbiAgICAgICAgTmVvQXJyYXkudG9nZ2xlKGNscywgJ25lby1ub3QtZWRpdGFibGUnLCAhdmFsdWUpO1xuICAgICAgICBtZS5jbHMgPSBjbHM7XG5cbiAgICAgICAgbWUudXBkYXRlUmVhZE9ubHlTdGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBlcnJvciBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RXJyb3IodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRXJyb3IodmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBlcnJvclBvc2l0aW9uQWJzb2x1dGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRFcnJvclBvc2l0aW9uQWJzb2x1dGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgPSB0aGlzLFxuICAgICAgICAgICAgY2xzID0gVkRvbVV0aWwuZmluZFZkb21DaGlsZChtZS52ZG9tLCB7Y2xzOiAnbmVvLXRleHRmaWVsZC1lcnJvcid9KS52ZG9tLmNscztcblxuICAgICAgICBOZW9BcnJheVt2YWx1ZSA/ICdhZGQnIDogJ3JlbW92ZSddKGNscywgJ25lby1hYnNvbHV0ZScpO1xuXG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBoaWRlTGFiZWwgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRIaWRlTGFiZWwodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIG5vZGUgPSBtZS5sYWJlbFBvc2l0aW9uID09PSAnaW5saW5lJyA/IG1lLmdldENlbnRlckJvcmRlckVsKCkgOiBtZS52ZG9tLmNuWzBdO1xuXG4gICAgICAgIG5vZGUucmVtb3ZlRG9tID0gdmFsdWU7XG4gICAgICAgIG1lLnVwZGF0ZUlucHV0V2lkdGgoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaW5wdXRFbCAgID0gbWUuZ2V0SW5wdXRFbCgpLFxuICAgICAgICAgICAgaW5wdXRFbElkID0gbWUuZ2V0SW5wdXRFbElkKCksXG4gICAgICAgICAgICBsYWJlbEVsICAgPSBtZS5nZXRMYWJlbEVsKCk7XG5cbiAgICAgICAgaW5wdXRFbC5pZCAgPSBpbnB1dEVsSWQ7XG4gICAgICAgIGxhYmVsRWwuaWQgID0gbWUuZ2V0TGFiZWxJZCgpO1xuICAgICAgICBsYWJlbEVsLmZvciA9IGlucHV0RWxJZDtcblxuICAgICAgICAvLyBzaWxlbnQgdmRvbSB1cGRhdGUsIHRoZSBzdXBlciBjYWxsIHdpbGwgdHJpZ2dlciB0aGUgZW5naW5lXG4gICAgICAgIHN1cGVyLmFmdGVyU2V0SWQodmFsdWUsIG9sZFZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaW5wdXRQYXR0ZXJuIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7UmVnRXhwfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtSZWdFeHB8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRJbnB1dFBhdHRlcm4odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlucHV0UGF0dGVybkRPTSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDEsIHZhbHVlLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY2hhbmdlSW5wdXRFbEtleSgncGF0dGVybicsIHZhbHVlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBpbnB1dFR5cGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SW5wdXRUeXBlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmNoYW5nZUlucHV0RWxLZXkoJ3R5cGUnLCB2YWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGlucHV0VmFsdWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldElucHV0VmFsdWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2xzfSA9IG1lO1xuXG4gICAgICAgIG1lLmdldElucHV0RWwoKS52YWx1ZSA9IG1lLmNvbnRhaW5zRm9jdXMgPyB2YWx1ZSA6IG1lLmlucHV0VmFsdWVSZW5kZXJlcih2YWx1ZSk7XG5cbiAgICAgICAgbWUudXNlQWxlcnRTdGF0ZSAmJiBOZW9BcnJheS50b2dnbGUoY2xzLCAnbmVvLWVtcHR5LXJlcXVpcmVkJywgbWUuaXNFbXB0eSgpICYmIG1lLnJlcXVpcmVkKTtcblxuICAgICAgICBOZW9BcnJheS50b2dnbGUoY2xzLCAnbmVvLWhhcy1jb250ZW50JywgbWUuaGFzQ29udGVudCgpKTtcbiAgICAgICAgbWUuY2xzID0gY2xzO1xuXG4gICAgICAgIG1lLnVwZGF0ZVZhbHVlRnJvbUlucHV0VmFsdWUodmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBsYWJlbENscyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TGFiZWxDbHModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgPSB0aGlzLFxuICAgICAgICAgICAgY2xzID0gbWUuZ2V0TGFiZWxFbCgpLmNscztcblxuICAgICAgICBOZW9BcnJheS5yZW1vdmUoY2xzLCBvbGRWYWx1ZSk7XG4gICAgICAgIE5lb0FycmF5LmFkZChjbHMsIHZhbHVlKTtcblxuICAgICAgICBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbGFiZWxPcHRpb25hbFRleHQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TGFiZWxPcHRpb25hbFRleHQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMubGFiZWxUZXh0ID0gdGhpcy5sYWJlbFRleHQgLy8gdHJpZ2dlcnMgYSB2ZG9tIHVwZGF0ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbGFiZWxQb3NpdGlvbiBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRMYWJlbFBvc2l0aW9uKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2NscywgdmRvbX0gPSBtZSxcbiAgICAgICAgICAgIGNlbnRlckJvcmRlckVsQ2xzLCBpc0VtcHR5O1xuXG4gICAgICAgIHZkb20uY25bMV0ucmVtb3ZlRG9tID0gdmFsdWUgIT09ICd0b3AnID8gdHJ1ZSA6ICFCb29sZWFuKG1lLnN1YkxhYmVsVGV4dCk7XG5cbiAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgJ2xhYmVsLScgKyBvbGRWYWx1ZSk7XG4gICAgICAgIE5lb0FycmF5LmFkZChjbHMsICdsYWJlbC0nICsgdmFsdWUpO1xuICAgICAgICBtZS5jbHMgPSBjbHM7IC8vIHRvZG86IHNpbGVudCB1cGRhdGUgaWYgbmVlZGVkXG5cbiAgICAgICAgaWYgKG9sZFZhbHVlID09PSAnaW5saW5lJykge1xuICAgICAgICAgICAgdmRvbS5jblswXSA9IG1lLmdldExhYmVsRWwoKTsgLy8gcmVtb3ZlIHRoZSB3cmFwcGVyXG5cbiAgICAgICAgICAgIHZkb20uY25bMF0ucmVtb3ZlRG9tID0gbWUuaGlkZUxhYmVsO1xuICAgICAgICAgICAgdmRvbS5jblswXS53aWR0aCAgICAgPSBtZS5sYWJlbFdpZHRoO1xuICAgICAgICAgICAgbWUudXBkYXRlSW5wdXRXaWR0aCgpXG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICdpbmxpbmUnKSB7XG4gICAgICAgICAgICBjZW50ZXJCb3JkZXJFbENscyA9IFsnbmVvLWNlbnRlci1ib3JkZXInXTtcbiAgICAgICAgICAgIGlzRW1wdHkgICAgICAgICAgID0gbWUuaXNFbXB0eSgpO1xuICAgICAgICAgICAgdmRvbSAgICAgICAgICAgICAgPSBtZS52ZG9tO1xuXG4gICAgICAgICAgICAhaXNFbXB0eSAmJiBjZW50ZXJCb3JkZXJFbENscy5wdXNoKCduZW8tZmxvYXQtYWJvdmUnKTtcblxuICAgICAgICAgICAgZGVsZXRlIHZkb20uY25bMF0ud2lkdGg7XG5cbiAgICAgICAgICAgIHZkb20uY25bMF0gPSB7XG4gICAgICAgICAgICAgICAgY2xzOiBbJ25lby1sYWJlbC13cmFwcGVyJ10sXG4gICAgICAgICAgICAgICAgY24gOiBbe1xuICAgICAgICAgICAgICAgICAgICBjbHM6IFsnbmVvLWxlZnQtYm9yZGVyJ11cbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIGNscyAgICAgIDogY2VudGVyQm9yZGVyRWxDbHMsXG4gICAgICAgICAgICAgICAgICAgIGNuICAgICAgIDogW3Zkb20uY25bMF1dLFxuICAgICAgICAgICAgICAgICAgICByZW1vdmVEb206IG1lLmhpZGVMYWJlbFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgY2xzOiBbJ25lby1yaWdodC1ib3JkZXInXVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBtZS51cGRhdGVJbnB1dFdpZHRoKCk7XG5cbiAgICAgICAgICAgICFpc0VtcHR5ICYmIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1lLnVwZGF0ZUNlbnRlckJvcmRlckVsV2lkdGgoZmFsc2UpXG4gICAgICAgICAgICB9LCAyMClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNoYW5nZXMgZnJvbSBlLmcuIGxlZnQgdG8gdG9wXG4gICAgICAgICAgICBtZS51cGRhdGVJbnB1dFdpZHRoKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbGFiZWxUZXh0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldExhYmVsVGV4dCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaXNFbXB0eSA9IG1lLmlzRW1wdHkoKTtcblxuICAgICAgICBpZiAobWUubGFiZWxJZCkge1xuICAgICAgICAgICAgdmFsdWUgPSBgPHNwYW4gY2xhc3M9XCIke21lLmxhYmVsSWRDbHMuam9pbignLCcpfVwiPiR7bWUubGFiZWxJZH08L3NwYW4+JHttZS5sYWJlbElkU2VwYXJhdG9yICsgdmFsdWV9YFxuICAgICAgICB9XG5cbiAgICAgICAgbWUuZ2V0TGFiZWxFbCgpLmlubmVySFRNTCA9IHZhbHVlO1xuXG4gICAgICAgIGlmICghbWUuaGlkZUxhYmVsKSB7XG4gICAgICAgICAgICBpZiAobWUubGFiZWxQb3NpdGlvbiA9PT0gJ2lubGluZScpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG1lLmdldENlbnRlckJvcmRlckVsKCk/LndpZHRoXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWUucHJvbWlzZVVwZGF0ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBtZS51cGRhdGVDZW50ZXJCb3JkZXJFbFdpZHRoKGlzRW1wdHkpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWUudXBkYXRlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbGFiZWxXaWR0aCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldExhYmVsV2lkdGgodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmxhYmVsUG9zaXRpb24gIT09ICdpbmxpbmUnKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGxhYmVsID0gbWUudmRvbS5jblswXTtcblxuICAgICAgICAgICAgbGFiZWwud2lkdGggPSB2YWx1ZTtcbiAgICAgICAgICAgICFtZS5oaWRlTGFiZWwgJiYgbWUudXBkYXRlSW5wdXRXaWR0aCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1heExlbmd0aCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TWF4TGVuZ3RoKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnZhbGlkYXRlKCk7IC8vIHNpbGVudFxuICAgICAgICB0aGlzLmNoYW5nZUlucHV0RWxLZXkoJ21heGxlbmd0aCcsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbWluTGVuZ3RoIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNaW5MZW5ndGgodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGUoKTsgLy8gc2lsZW50XG4gICAgICAgIHRoaXMuY2hhbmdlSW5wdXRFbEtleSgnbWlubGVuZ3RoJywgdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtb3VudGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IHRyaWdnZXJzID0gbWUudHJpZ2dlcnMgfHwgW10sXG4gICAgICAgICAgICAgICAgaSAgICAgICAgPSAwLFxuICAgICAgICAgICAgICAgIGxlbiAgICAgID0gdHJpZ2dlcnMubGVuZ3RoO1xuXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0cmlnZ2Vyc1tpXS52ZG9tLnJlbW92ZURvbSkge1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2Vyc1tpXS5tb3VudGVkID0gdmFsdWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtZS5sYWJlbFBvc2l0aW9uID09PSAnaW5saW5lJykge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBtZS51cGRhdGVDZW50ZXJCb3JkZXJFbFdpZHRoKClcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbWUuZ2V0Q2VudGVyQm9yZGVyRWwoKS53aWR0aFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcGxhY2Vob2xkZXJUZXh0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRQbGFjZWhvbGRlclRleHQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2xzfSA9IG1lO1xuXG4gICAgICAgIG1lLmNoYW5nZUlucHV0RWxLZXkoJ3BsYWNlaG9sZGVyJywgdmFsdWUgPT09ICcnID8gbnVsbCA6IHZhbHVlKTtcblxuICAgICAgICAvLyBhIG5vbi1lbXB0eSBwbGFjZWhvbGRlciBuZWVkcyB0byBrZWVwIHRoZSAnbmVvLWhhcy1jb250ZW50JyBydWxlXG4gICAgICAgIC8vID0+IGxhYmVsUG9zaXRpb246ICdpbmxpbmUnIHNob3VsZCBrZWVwIHRoZSBsYWJlbCBhdCB0aGUgdG9wXG4gICAgICAgIGlmIChOZW8uaXNFbXB0eSh2YWx1ZSkgIT09IE5lby5pc0VtcHR5KG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgTmVvQXJyYXlbdmFsdWUgIT09IG51bGwgJiYgdmFsdWUudG9TdHJpbmcoKS5sZW5ndGggPiAwID8gJ2FkZCcgOiAncmVtb3ZlJ10oY2xzLCAnbmVvLWhhcy1jb250ZW50Jyk7XG4gICAgICAgICAgICBtZS5jbHMgPSBjbHNcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcmVhZE9ubHkgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRSZWFkT25seSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjbHN9ID0gbWU7XG5cbiAgICAgICAgTmVvQXJyYXlbdmFsdWUgPyAnYWRkJyA6ICdyZW1vdmUnXShjbHMsICduZW8tcmVhZG9ubHknKTtcbiAgICAgICAgbWUuY2xzID0gY2xzO1xuXG4gICAgICAgIG1lLnVwZGF0ZVJlYWRPbmx5U3RhdGUoKTtcblxuICAgICAgICBtZS50cmlnZ2Vycz8uZm9yRWFjaCh0cmlnZ2VyID0+IHtcbiAgICAgICAgICAgIHRyaWdnZXIuaGlkZGVuID0gdmFsdWUgPyB0cnVlIDogdHJpZ2dlci5nZXRIaWRkZW5TdGF0ZT8uKCkgfHwgZmFsc2VcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHJlcXVpcmVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0UmVxdWlyZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuc2lsZW50VmRvbVVwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgb2xkVmFsdWUgIT09IHVuZGVmaW5lZCAmJiBtZS52YWxpZGF0ZShtZS5jbGVhbik7XG4gICAgICAgIG1lLmNoYW5nZUlucHV0RWxLZXkoJ3JlcXVpcmVkJywgdmFsdWUgPyB2YWx1ZSA6IG51bGwpO1xuICAgICAgICBtZS5sYWJlbFRleHQgPSBtZS5sYWJlbFRleHQ7IC8vIGFwcGx5IHRoZSBvcHRpb25hbCB0ZXh0IGlmIG5lZWRlZFxuXG4gICAgICAgIG1lLnNpbGVudFZkb21VcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc2hvd09wdGlvbmFsVGV4dCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNob3dPcHRpb25hbFRleHQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMubGFiZWxUZXh0ID0gdGhpcy5sYWJlbFRleHQgLy8gdHJpZ2dlcnMgYSB2ZG9tIHVwZGF0ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc3BlbGxDaGVjayBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW58bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW58bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTcGVsbENoZWNrKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmNoYW5nZUlucHV0RWxLZXkoJ3NwZWxsY2hlY2snLCBOZW8uaXNCb29sZWFuKHZhbHVlKSA/IHZhbHVlIDogbnVsbClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHN1YkxhYmVsQ2xzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTdWJMYWJlbENscyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjbHN9ID0gbWUudmRvbS5jblsxXTtcblxuICAgICAgICBOZW9BcnJheS5yZW1vdmUoY2xzLCBvbGRWYWx1ZSk7XG4gICAgICAgIE5lb0FycmF5LmFkZChjbHMsIHZhbHVlKTtcblxuICAgICAgICBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc3ViTGFiZWxUZXh0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTdWJMYWJlbFRleHQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgc2hvd0xhYmVsID0gbWUubGFiZWxQb3NpdGlvbiA9PT0gJ3RvcCcsXG4gICAgICAgICAgICBzdWJMYWJlbCAgPSBtZS52ZG9tLmNuWzFdO1xuXG4gICAgICAgIHN1YkxhYmVsLmh0bWwgICAgICA9IHZhbHVlO1xuICAgICAgICBzdWJMYWJlbC5yZW1vdmVEb20gPSAhc2hvd0xhYmVsO1xuXG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB0cmlnZ2VycyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VHJpZ2dlcnModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3Zkb219ICAgICAgID0gbWUsXG4gICAgICAgICAgICBpbnB1dEVsICAgICAgPSB2ZG9tLmNuWzJdLCAvLyBpbnB1dEVsIG9yIGlucHV0V3JhcHBlckVsXG4gICAgICAgICAgICBwcmVUcmlnZ2VycyAgPSBbXSxcbiAgICAgICAgICAgIHBvc3RUcmlnZ2VycyA9IFtdLFxuICAgICAgICAgICAgd2lkdGg7XG5cbiAgICAgICAgb2xkVmFsdWU/LmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpZiAoIW1lLmdldFRyaWdnZXIoaXRlbS50eXBlKSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uZGVzdHJveSgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZVRyaWdnZXJzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zdFRyaWdnZXJzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHBvc3RUcmlnZ2Vycy5zb3J0KChhLCBiKSA9PiBiLndlaWdodCAtIGEud2VpZ2h0KTsgLy8gREVTQ1xuICAgICAgICAgICAgcHJlVHJpZ2dlcnMuc29ydCgoYSwgYikgPT4gYS53ZWlnaHQgLSBiLndlaWdodCk7IC8vIEFTQ1xuXG4gICAgICAgICAgICBwb3N0VHJpZ2dlcnMgPSBwb3N0VHJpZ2dlcnMubWFwKGEgPT4gYS52ZG9tKTtcbiAgICAgICAgICAgIHByZVRyaWdnZXJzICA9IHByZVRyaWdnZXJzLm1hcChhID0+IGEudmRvbSk7XG5cbiAgICAgICAgICAgIGlmIChpbnB1dEVsLnRhZyA9PT0gJ2lucHV0Jykge1xuICAgICAgICAgICAgICAgIC8vIHdyYXAgdGhlIGlucHV0IHRhZ1xuICAgICAgICAgICAgICAgIHZkb20uY25bMl0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGNscyAgOiBbJ25lby1pbnB1dC13cmFwcGVyJ10sXG4gICAgICAgICAgICAgICAgICAgIGNuICAgOiBbLi4ucHJlVHJpZ2dlcnMsIGlucHV0RWwsIC4uLnBvc3RUcmlnZ2Vyc10sXG4gICAgICAgICAgICAgICAgICAgIGlkICAgOiBtZS5nZXRJbnB1dFdyYXBwZXJJZCgpLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogaW5wdXRFbC53aWR0aFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBkZWxldGUgaW5wdXRFbC53aWR0aFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnB1dEVsLmNuID0gWy4uLnByZVRyaWdnZXJzLCBtZS5nZXRJbnB1dEVsKCksIC4uLnBvc3RUcmlnZ2Vyc11cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpbnB1dEVsLnRhZyAhPT0gJ2lucHV0Jykge1xuICAgICAgICAgICAgICAgIC8vIHJlcGxhY2luZyB0aGUgaW5wdXQgd3JhcHBlciBkaXYgd2l0aCB0aGUgaW5wdXQgdGFnXG4gICAgICAgICAgICAgICAgd2lkdGggICAgICAgICAgICA9IGlucHV0RWwud2lkdGg7XG4gICAgICAgICAgICAgICAgdmRvbS5jblsyXSAgICAgICA9IG1lLmdldElucHV0RWwoKTtcbiAgICAgICAgICAgICAgICB2ZG9tLmNuWzJdLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtZS5wcm9taXNlVXBkYXRlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBtZS51cGRhdGVUcmlnZ2VyVm5vZGVzKClcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHZhbHVlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFZhbHVlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgY2xzO1xuXG4gICAgICAgIG1lLnNpbGVudFZkb21VcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgIG1lLnVwZGF0ZUlucHV0VmFsdWVGcm9tVmFsdWUodmFsdWUpO1xuXG4gICAgICAgIG1lLnZhbGlkYXRlKCk7IC8vIHNpbGVudFxuXG4gICAgICAgIGNscyA9IG1lLmNscztcbiAgICAgICAgTmVvQXJyYXkudG9nZ2xlKGNscywgJ25lby1pcy1kaXJ0eScsIG1lLmlzRGlydHkpO1xuICAgICAgICBtZS5jbHMgPSBjbHM7XG5cbiAgICAgICAgbWUuc2lsZW50VmRvbVVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgICAgIG1lLnVwZGF0ZSgpO1xuXG4gICAgICAgIHN1cGVyLmFmdGVyU2V0VmFsdWUodmFsdWUsIG9sZFZhbHVlKSAvLyBmaXJlcyB0aGUgY2hhbmdlIGV2ZW50XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB3aWR0aCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFdpZHRoKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldFdpZHRoKHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIHRoaXMudXBkYXRlSW5wdXRXaWR0aCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB3aW5kb3dJZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFdpbmRvd0lkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB2YWx1ZSAmJiB0aGlzLnRyaWdnZXJzPy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaXRlbS53aW5kb3dJZCA9IHZhbHVlXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgc2hhbGxvdyBjb3B5IG9mIHRoZSB0cmlnZ2VycyBjb25maWdcbiAgICAgKiBAcGFyYW0ge0FycmF5fG51bGx9IHZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZUdldFRyaWdnZXJzKHZhbHVlKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFsuLi52YWx1ZV1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGF1dG9DYXBpdGFsaXplIGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBiZWZvcmVTZXRBdXRvQ2FwaXRhbGl6ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ2F1dG9DYXBpdGFsaXplJywgJ2F1dG9DYXBpdGFsaXplVmFsdWVzJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBsYWJlbENscyBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0TGFiZWxDbHModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiBOZW9BcnJheS51bmlvbih2YWx1ZSB8fCBbXSwgdGhpcy5sYWJlbEJhc2VDbHMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgbGFiZWxQb3NpdGlvbiBjb25maWcgZ2V0cyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgYmVmb3JlU2V0TGFiZWxQb3NpdGlvbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ2xhYmVsUG9zaXRpb24nKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGxhYmVsVGV4dCBjb25maWcgZ2V0cyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGJlZm9yZVNldExhYmVsVGV4dCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGxhYmVsT3B0aW9uYWxUZXh0ID0gbWUubGFiZWxPcHRpb25hbFRleHQsXG4gICAgICAgICAgICBoYXNPcHRpb25hbFRleHQgICA9IHZhbHVlLmVuZHNXaXRoKGxhYmVsT3B0aW9uYWxUZXh0KTtcblxuICAgICAgICBpZiAobWUuc2hvd09wdGlvbmFsVGV4dCAmJiAhbWUucmVxdWlyZWQpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3B0aW9uYWxUZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gbGFiZWxPcHRpb25hbFRleHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSAmJiBoYXNPcHRpb25hbFRleHQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShsYWJlbE9wdGlvbmFsVGV4dCwgJycpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBzdWJMYWJlbENscyBjb25maWcgZ2V0cyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmdbXX1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0U3ViTGFiZWxDbHModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiBOZW9BcnJheS51bmlvbih2YWx1ZSB8fCBbXSwgdGhpcy5zdWJMYWJlbEJhc2VDbHMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgdHJpZ2dlcnMgY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fE9iamVjdFtdfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge09iamVjdFtdfSB0aGUgcGFyc2VkIHRyaWdnZXJzIGNvbmZpZ1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fE9iamVjdFtdfVxuICAgICAqL1xuICAgIGJlZm9yZVNldFRyaWdnZXJzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IFtdO1xuICAgICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBbdmFsdWVdXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7YXBwTmFtZSwgd2luZG93SWR9ID0gbWU7XG5cbiAgICAgICAgdmFsdWUuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChpdGVtLmlzQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVtpbmRleF0gPSBOZW8uY3JlYXRlKGl0ZW0sIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgaWQgICA6IG1lLmdldFRyaWdnZXJJZChpdGVtLnByb3RvdHlwZS50eXBlKSxcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IG1lLFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3dJZFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCEoaXRlbSBpbnN0YW5jZW9mIEJhc2VUcmlnZ2VyKSkge1xuICAgICAgICAgICAgICAgIGlmICghaXRlbS5tb2R1bGUgJiYgIWl0ZW0ubnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5udHlwZSA9ICd0cmlnZ2VyJ1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpdGVtLm1vZHVsZSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmNsYXNzTmFtZSA9IGl0ZW0ubW9kdWxlLnByb3RvdHlwZS5jbGFzc05hbWU7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uaWQgICAgICAgID0gbWUuZ2V0VHJpZ2dlcklkKGl0ZW0ubW9kdWxlLnByb3RvdHlwZS50eXBlKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhbHVlW2luZGV4XSA9IE5lb1tpdGVtLmNsYXNzTmFtZSA/ICdjcmVhdGUnIDogJ250eXBlJ10oe1xuICAgICAgICAgICAgICAgICAgICAuLi5pdGVtLFxuICAgICAgICAgICAgICAgICAgICBhcHBOYW1lLFxuICAgICAgICAgICAgICAgICAgICBmaWVsZDogbWUsXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0lkXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgdmFsdWUgY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFZhbHVlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbXB0eVZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIGZpZWxkIHRvIGl0cyBvcmlnaW5hbCB2YWx1ZSBvciBudWxsIGRlcGVuZGluZyBvbiB0aGUgY2xlYXJUb09yaWdpbmFsVmFsdWUgY29uZmlnXG4gICAgICovXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUudmFsdWUgPSBtZS5jbGVhclRvT3JpZ2luYWxWYWx1ZSA/IG1lLm9yaWdpbmFsQ29uZmlnLnZhbHVlIDogbnVsbDtcbiAgICAgICAgbWUuZmlyZSgnY2xlYXInKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICBkZXN0cm95KC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuZGlzYWJsZWRDaGFycykge1xuICAgICAgICAgICAgTmVvLm1haW4uRG9tRXZlbnRzLnVucmVnaXN0ZXJEaXNhYmxlZElucHV0Q2hhcnMoe1xuICAgICAgICAgICAgICAgIGFwcE5hbWU6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICAgICAgaWQgICAgIDogbWUuZ2V0SW5wdXRFbCgpLmlkXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgc3VwZXIuZGVzdHJveSguLi5hcmdzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxzIGZvY3VzKCkgb24gdGhlIGlucHV0RWwgbm9kZSBpbnN0ZWFkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgZm9jdXMoaWQpIHtcbiAgICAgICAgc3VwZXIuZm9jdXModGhpcy5nZXRJbnB1dEVsSWQoKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgZ2V0Q2VudGVyQm9yZGVyRWwoKSB7XG4gICAgICAgIHJldHVybiBWRG9tVXRpbC5maW5kVmRvbUNoaWxkKHRoaXMudmRvbSwge2NsczogJ25lby1jZW50ZXItYm9yZGVyJ30pPy52ZG9tIHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgZ2V0SW5wdXRFbCgpIHtcbiAgICAgICAgcmV0dXJuIFZEb21VdGlsLmZpbmRWZG9tQ2hpbGQodGhpcy52ZG9tLCB7ZmxhZzogJ25lby1yZWFsLWlucHV0J30pPy52ZG9tIHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldElucHV0RWxJZCgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWR9X19pbnB1dGBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBuZXcgaW5wdXRXaWR0aCBiYXNlZCBvbiB0aGUgbGFiZWxXaWR0aCAmIHRvdGFsIHdpZHRoXG4gICAgICogQHJldHVybnMge051bWJlcnxudWxsfSBudWxsIGluIGNhc2UgdGhpcy53aWR0aCBpcyB1bmtub3duXG4gICAgICovXG4gICAgZ2V0SW5wdXRXaWR0aCgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGlnbm9yZUxhYmVsID0gbWUuaGlkZUxhYmVsIHx8IG1lLmxhYmVsUG9zaXRpb24gPT09ICdib3R0b20nIHx8IG1lLmxhYmVsUG9zaXRpb24gPT09ICdpbmxpbmUnIHx8IG1lLmxhYmVsUG9zaXRpb24gPT09ICd0b3AnLFxuICAgICAgICAgICAgbGFiZWxXaWR0aCAgPSBpZ25vcmVMYWJlbCA/IDAgOiBtZS5sYWJlbFdpZHRoLFxuICAgICAgICAgICAge3dpZHRofSAgICAgPSBtZTtcblxuICAgICAgICBpZiAobGFiZWxXaWR0aCAmJiB3aWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHdpZHRoKSAtIHBhcnNlSW50KGxhYmVsV2lkdGgpXG4gICAgICAgIH0gZWxzZSBpZiAod2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiB3aWR0aFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldElucHV0V3JhcHBlcklkKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5pZH1fX2lucHV0LXdyYXBwZXJgXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge09iamVjdHxudWxsfVxuICAgICAqL1xuICAgIGdldExhYmVsRWwoKSB7XG4gICAgICAgIHJldHVybiBWRG9tVXRpbC5maW5kVmRvbUNoaWxkKHRoaXMudmRvbSwge3RhZzogJ2xhYmVsJ30pPy52ZG9tIHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldExhYmVsSWQoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmlkfV9fbGFiZWxgXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0U3VibWl0VmFsdWUoKSB7XG4gICAgICAgIGxldCBzdXBlclN1Ym1pdFZhbHVlID0gc3VwZXIuZ2V0U3VibWl0VmFsdWUoKTtcblxuICAgICAgICByZXR1cm4gdGhpcy54c3NQcm90ZWN0ZWQgPyBTdHJpbmdVdGlsLmVzY2FwZUh0bWwoc3VwZXJTdWJtaXRWYWx1ZSkgOiBzdXBlclN1Ym1pdFZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAcmV0dXJucyB7TmVvLmZvcm0uZmllbGQudHJpZ2dlci5CYXNlfG51bGx9XG4gICAgICovXG4gICAgZ2V0VHJpZ2dlcih0eXBlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB0cmlnZ2VycyA9IG1lLnRyaWdnZXJzIHx8IFtdLFxuICAgICAgICAgICAgaSAgICAgICAgPSAwLFxuICAgICAgICAgICAgbGVuICAgICAgPSB0cmlnZ2Vycy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKHRyaWdnZXJzW2ldLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJpZ2dlcnNbaV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gICAgICogQHJldHVybnMge05lby5mb3JtLmZpZWxkLnRyaWdnZXIuQmFzZXxudWxsfVxuICAgICAqL1xuICAgIGdldFRyaWdnZXJCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB0cmlnZ2VycyA9IG1lLnRyaWdnZXJzIHx8IFtdLFxuICAgICAgICAgICAgaSAgICAgICAgPSAwLFxuICAgICAgICAgICAgbGVuICAgICAgPSB0cmlnZ2Vycy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKHRyaWdnZXJzW2ldLmlkID09PSBpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmlnZ2Vyc1tpXVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgdHJpZ2dlciBub2RlIGlkXG4gICAgICovXG4gICAgZ2V0VHJpZ2dlcklkKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWQgKyAnLXRyaWdnZXItJyArIHR5cGVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNDb250ZW50KCkge1xuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmlucHV0VmFsdWU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucGxhY2Vob2xkZXJUZXh0Py5sZW5ndGggPiAwIHx8IHZhbHVlICE9PSBudWxsICYmIHZhbHVlLnRvU3RyaW5nKCkubGVuZ3RoID4gMFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmRzIGEgdHJpZ2dlciBieSBhIGdpdmVuIHR5cGUgY29uZmlnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNUcmlnZ2VyKHR5cGUpIHtcbiAgICAgICAgbGV0IHRyaWdnZXJzID0gdGhpcy50cmlnZ2VycyB8fCBbXSxcbiAgICAgICAgICAgIGkgICAgICAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgICAgID0gdHJpZ2dlcnMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0cmlnZ2Vyc1tpXS50eXBlID09PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSBhbiBpbnB1dCBub2RlIHZhbHVlIGJlZm9yZSBhcHBsaWVkIHRvIHRoaXMudmFsdWUuXG4gICAgICogT3ZlcnJpZGUgYXMgbmVlZGVkXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGlucHV0VmFsdWVBZGp1c3Rvcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm0gYSB2YWx1ZSBiZWZvcmUgZ2V0dGluZyByZW5kZXJlZC5cbiAgICAgKiBPdmVycmlkZSBhcyBuZWVkZWRcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgaW5wdXRWYWx1ZVJlbmRlcmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiAhKHRoaXMudmFsdWU/LnRvU3RyaW5nKCkubGVuZ3RoID4gMClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0VtcHR5QW5kUmVxdWlyZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzRW1wdHkoKSAmJiB0aGlzLnJlcXVpcmVkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNWYWxpZCgpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0ZSh0cnVlKTsgLy8gc2lsZW50XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IgPyBmYWxzZSA6IHN1cGVyLmlzVmFsaWQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICogQHJldHVybnMge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgbWVyZ2VDb25maWcoLi4uYXJncykge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnICAgPSBzdXBlci5tZXJnZUNvbmZpZyguLi5hcmdzKSxcbiAgICAgICAgICAgIHRyaWdnZXJzID0gY29uZmlnLnRyaWdnZXJzIHx8IG1lLnRyaWdnZXJzO1xuXG4gICAgICAgIG1lW3RyaWdnZXJzID8gJ3RyaWdnZXJzJyA6ICdfdHJpZ2dlcnMnXSA9IHRyaWdnZXJzO1xuXG4gICAgICAgIGRlbGV0ZSBjb25maWcudHJpZ2dlcnM7XG4gICAgICAgIHJldHVybiBjb25maWdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGEucGF0aFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbkZvY3VzRW50ZXIoZGF0YSkge1xuICAgICAgICBzdXBlci5vbkZvY3VzRW50ZXIoZGF0YSk7XG5cbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjbHN9ID0gbWU7XG5cbiAgICAgICAgaWYgKCFtZS5yZWFkT25seSkge1xuICAgICAgICAgICAgTmVvQXJyYXkuYWRkKGNscywgJ25lby1mb2N1cycpO1xuICAgICAgICAgICAgbWUuY2xzID0gY2xzO1xuXG4gICAgICAgICAgICBpZiAobWUubGFiZWxQb3NpdGlvbiA9PT0gJ2lubGluZScpIHtcbiAgICAgICAgICAgICAgICBpZiAobWUuY2VudGVyQm9yZGVyRWxXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBtZS5nZXRDZW50ZXJCb3JkZXJFbCgpLndpZHRoID0gbWUuY2VudGVyQm9yZGVyRWxXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgbWUudXBkYXRlKClcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZS51cGRhdGVDZW50ZXJCb3JkZXJFbFdpZHRoKGZhbHNlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5vbGRQYXRoXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uRm9jdXNMZWF2ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjZW50ZXJCb3JkZXJFbCA9IG1lLmdldENlbnRlckJvcmRlckVsKCksIC8vIGxhYmVsUG9zaXRpb246ICdpbmxpbmUnXG4gICAgICAgICAgICBjbHM7XG5cbiAgICAgICAgaWYgKCFtZS5yZWFkT25seSkge1xuICAgICAgICAgICAgbWUudmFsaWRhdGUoZmFsc2UpO1xuXG4gICAgICAgICAgICBjbHMgPSBtZS5jbHM7IC8vIGhhcyB0byBnZXQgc2V0IGFmdGVyIHZhbGlkYXRlKClcblxuICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgJ25lby1mb2N1cycpO1xuICAgICAgICAgICAgbWUuY2xzID0gY2xzO1xuXG4gICAgICAgICAgICBpZiAoY2VudGVyQm9yZGVyRWwgJiYgbWUuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNlbnRlckJvcmRlckVsLndpZHRoXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoTmVvLmlzU3RyaW5nKG1lLnZhbHVlKSkge1xuICAgICAgICAgICAgbWUudmFsdWUgPSBtZS52YWx1ZS50cmltKClcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnVwZGF0ZSgpO1xuXG4gICAgICAgIHN1cGVyLm9uRm9jdXNMZWF2ZShkYXRhKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdHJpZ2dlcmVkIGJ5IHRoZSAnaW5wdXQnIERPTSBldmVudC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbklucHV0VmFsdWVDaGFuZ2UoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBvbGRWYWx1ZSAgID0gbWUudmFsdWUsXG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gZGF0YS52YWx1ZSxcbiAgICAgICAgICAgIHZub2RlICAgICAgPSBWTm9kZVV0aWwuZmluZENoaWxkVm5vZGUobWUudm5vZGUsIHtub2RlTmFtZTogJ2lucHV0J30pO1xuXG4gICAgICAgIGlmICh2bm9kZSkge1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBjdXJyZW50IHN0YXRlIChtb2RpZmllZCBET00gYnkgdGhlIHVzZXIpIHRvIGVuYWJsZSB0aGUgZGVsdGEtdXBkYXRlcyBsb2dpYy5cbiAgICAgICAgICAgIC8vIFJlcXVpcmVkIGUuZy4gZm9yIHZhbGlkYXRpb24gLT4gcmV2ZXJ0IGEgd3JvbmcgdXNlciBpbnB1dFxuICAgICAgICAgICAgdm5vZGUudm5vZGUuYXR0cmlidXRlcy52YWx1ZSA9IGlucHV0VmFsdWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChOZW8uaXNTdHJpbmcoaW5wdXRWYWx1ZSkpIHtcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSBpbnB1dFZhbHVlLnRyaW0oKVxuICAgICAgICB9XG5cbiAgICAgICAgbWUuY2xlYW4gICAgICA9IGZhbHNlO1xuICAgICAgICBtZS5pbnB1dFZhbHVlID0gbWUuaW5wdXRWYWx1ZUFkanVzdG9yKGlucHV0VmFsdWUpOyAvLyB1cGRhdGVzIHRoaXMudmFsdWVcblxuICAgICAgICBtZS5maXJlVXNlckNoYW5nZUV2ZW50KG1lLnZhbHVlLCBvbGRWYWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uTW91c2VFbnRlcihkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2xzfSA9IG1lO1xuXG4gICAgICAgIGlmICghbWUucmVhZE9ubHkpIHtcbiAgICAgICAgICAgIE5lb0FycmF5LmFkZChjbHMsICduZW8taG92ZXJlZCcpO1xuICAgICAgICAgICAgbWUuY2xzID0gY2xzXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uTW91c2VMZWF2ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2xzfSA9IG1lO1xuXG4gICAgICAgIGlmICghbWUucmVhZE9ubHkpIHtcbiAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZShjbHMsICduZW8taG92ZXJlZCcpO1xuICAgICAgICAgICAgbWUuY2xzID0gY2xzXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCB0cmlnZ2VycyBvZiBhIGdpdmVuIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbGVudD1mYWxzZV0gdHJ1ZSBwcmV2ZW50cyBhIHZkb20gdXBkYXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3RyaWdnZXJTb3VyY2VdIHBhc3MgYSBzaGFsbG93IGNvcHkgb2YgdGhpcy50cmlnZ2Vyc1xuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGluIGNhc2UgYSB0cmlnZ2VyIHdhcyBmb3VuZCAmIHJlbW92ZWRcbiAgICAgKi9cbiAgICByZW1vdmVUcmlnZ2VyKHR5cGUsIHNpbGVudCA9IGZhbHNlLCB0cmlnZ2VyU291cmNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBoYXNNYXRjaCA9IGZhbHNlLFxuICAgICAgICAgICAgdHJpZ2dlcnMgPSB0cmlnZ2VyU291cmNlIHx8IG1lLnRyaWdnZXJzIHx8IFtdLFxuICAgICAgICAgICAgaSAgICAgICAgPSAwLFxuICAgICAgICAgICAgbGVuICAgICAgPSB0cmlnZ2Vycy5sZW5ndGgsXG4gICAgICAgICAgICB0cmlnZ2VyO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRyaWdnZXIgPSB0cmlnZ2Vyc1tpXTtcblxuICAgICAgICAgICAgaWYgKHRyaWdnZXIudHlwZSA9PT0gdHlwZSkge1xuICAgICAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZSh0cmlnZ2VycywgdHJpZ2dlcik7XG4gICAgICAgICAgICAgICAgbGVuLS07XG4gICAgICAgICAgICAgICAgaGFzTWF0Y2ggPSB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzTWF0Y2ggJiYgIXNpbGVudCkge1xuICAgICAgICAgICAgbWUudHJpZ2dlcnMgPSB0cmlnZ2Vyc1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhhc01hdGNoXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBmaWVsZCB0byBpdHMgb3JpZ2luYWwgdmFsdWUgb3IgbnVsbCBkZXBlbmRpbmcgb24gdGhlIGNsZWFyVG9PcmlnaW5hbFZhbHVlIGNvbmZpZ1xuICAgICAqIFlvdSBjYW4gb3B0aW9uYWxseSBwYXNzIGEgbmV3IHZhbHVlLCB3aGljaCB3aWxsIGFkanVzdCB0aGUgb3JpZ2luYWxDb25maWcudmFsdWUgaWYgbmVlZGVkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IFt2YWx1ZT1udWxsXVxuICAgICAqL1xuICAgIHJlc2V0KHZhbHVlID0gbnVsbCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5jbGVhclRvT3JpZ2luYWxWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbWUub3JpZ2luYWxDb25maWcudmFsdWUgPSB2YWx1ZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG1lLm9yaWdpbmFsQ29uZmlnLnZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdXBlci5yZXNldCh2YWx1ZSk7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsICYmIG1lLmNsZWFuKSB7XG4gICAgICAgICAgICBtZS51cGRhdGVFcnJvcihudWxsKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgbGFiZWxQb3NpdGlvbjogJ2lubGluZScgdG8gYWRqdXN0IHRoZSB0b3AgYm9yZGVyIG1hdGNoaW5nIHRvIHRoZSBsZW5ndGggb2YgdGhlIGxhYmVsXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2lsZW50PWZhbHNlXSB0cnVlIHRvIGdldCB0aGUgdmFsdWUsIGJ1dCBub3QgYXBwbHkgaXQgdG8gdGhlIERPTVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB1cGRhdGVDZW50ZXJCb3JkZXJFbFdpZHRoKHNpbGVudCA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUubW91bnRlZCAmJiBtZS5nZXREb21SZWN0KG1lLmdldENlbnRlckJvcmRlckVsKCkuaWQpLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICBtZS5jZW50ZXJCb3JkZXJFbFdpZHRoID0gTWF0aC5yb3VuZChkYXRhLndpZHRoICogLjcpICsgODtcblxuICAgICAgICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgICAgICAgICBtZS5nZXRDZW50ZXJCb3JkZXJFbCgpLndpZHRoID0gbWUuY2VudGVyQm9yZGVyRWxXaWR0aDtcbiAgICAgICAgICAgICAgICBtZS51cGRhdGUoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICBAcGFyYW0ge0Jvb2xlYW59IHNpbGVudD1mYWxzZVxuICAgICAqL1xuICAgIHVwZGF0ZUVycm9yKHZhbHVlLCBzaWxlbnQgPSBmYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAge2Nsc30gPSBtZSxcbiAgICAgICAgICAgIGVycm9yTm9kZSwgZXJyb3JXcmFwcGVyO1xuXG4gICAgICAgIGlmICghKG1lLmNsZWFuICYmICFtZS5tb3VudGVkKSkge1xuICAgICAgICAgICAgTmVvQXJyYXlbdmFsdWUgPyAnYWRkJyA6ICdyZW1vdmUnXShjbHMsICduZW8taW52YWxpZCcpO1xuICAgICAgICAgICAgbWUuY2xzID0gY2xzO1xuXG4gICAgICAgICAgICBlcnJvcldyYXBwZXIgPSBWRG9tVXRpbC5maW5kVmRvbUNoaWxkKG1lLnZkb20sIHtjbHM6ICduZW8tdGV4dGZpZWxkLWVycm9yLXdyYXBwZXInfSkudmRvbTtcbiAgICAgICAgICAgIGVycm9yTm9kZSAgICA9IGVycm9yV3JhcHBlci5jblswXTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JOb2RlLmh0bWwgPSB2YWx1ZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZXJyb3JOb2RlLmh0bWxcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXJyb3JXcmFwcGVyLnJlbW92ZURvbSA9ICF2YWx1ZTtcblxuICAgICAgICAgICAgIXNpbGVudCAmJiBtZS51cGRhdGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgYXMgbmVlZGVkIGluc2lkZSBjbGFzcyBleHRlbnNpb25zLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdXBkYXRlSW5wdXRWYWx1ZUZyb21WYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLmlucHV0VmFsdWUgPSB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIG5ldyBpbnB1dFdpZHRoIGJhc2VkIG9uIHRoZSBsYWJlbFdpZHRoICYgdG90YWwgd2lkdGhcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdXBkYXRlSW5wdXRXaWR0aCgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaW5wdXRXaWR0aCA9IG1lLmdldElucHV0V2lkdGgoKTtcblxuICAgICAgICBpZiAoaW5wdXRXaWR0aCAhPT0gbnVsbCAmJiBpbnB1dFdpZHRoICE9PSBtZS53aWR0aCkge1xuICAgICAgICAgICAgbWUudmRvbS5jblsxXS53aWR0aCA9IGlucHV0V2lkdGhcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBtZS52ZG9tLmNuWzFdLndpZHRoXG4gICAgICAgIH1cblxuICAgICAgICBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBET00gYmFzZWQgcmVhZG9ubHkgYXR0cmlidXRlIG5lZWRzIHRvIGhvbm9yIHRoZSBlZGl0YWJsZSAmIHJlYWRPbmx5IGNvbmZpZ3NcbiAgICAgKi9cbiAgICB1cGRhdGVSZWFkT25seVN0YXRlKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmNoYW5nZUlucHV0RWxLZXkoJ3JlYWRvbmx5JywgIW1lLmVkaXRhYmxlIHx8IG1lLnJlYWRPbmx5IHx8IG51bGwpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2luY2UgdHJpZ2dlcnMgZG8gbm90IGdldCByZW5kZXJlZCwgYXNzaWduIHRoZSByZWxldmFudCBwcm9wc1xuICAgICAqIHRvZG86IHRoaXMgY291bGQgYmUgaGFuZGxlZCBieSBjb21wb25lbnQuQmFzZVxuICAgICAqL1xuICAgIHVwZGF0ZVRyaWdnZXJWbm9kZXMoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB0cmlnZ2VyUm9vdCA9IG1lLnZub2RlPy5jaGlsZE5vZGVzWzFdLFxuICAgICAgICAgICAgY2hpbGROb2RlcyAgPSB0cmlnZ2VyUm9vdD8uY2hpbGROb2RlcyB8fCBbXSxcbiAgICAgICAgICAgIHRyaWdnZXI7XG5cbiAgICAgICAgY2hpbGROb2Rlcy5mb3JFYWNoKHZub2RlID0+IHtcbiAgICAgICAgICAgIHRyaWdnZXIgPSBtZS5nZXRUcmlnZ2VyQnlJZCh2bm9kZS5pZCk7XG5cbiAgICAgICAgICAgIHRyaWdnZXIgJiYgT2JqZWN0LmFzc2lnbih0cmlnZ2VyLCB7XG4gICAgICAgICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgICAgICAgX3JlbmRlcmVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIF9tb3VudGVkIDogdHJ1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBhcyBuZWVkZWQgaW5zaWRlIGNsYXNzIGV4dGVuc2lvbnMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlucHV0VmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdXBkYXRlVmFsdWVGcm9tSW5wdXRWYWx1ZShpbnB1dFZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBpbnB1dFZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGZvciBjbGllbnQtc2lkZSBmaWVsZCBlcnJvcnNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNpbGVudD10cnVlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpbiBjYXNlIHRoZXJlIGFyZSBubyBjbGllbnQtc2lkZSBlcnJvcnNcbiAgICAgKi9cbiAgICB2YWxpZGF0ZShzaWxlbnQ9dHJ1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2lucHV0UGF0dGVybiwgbWF4TGVuZ3RoLCBtaW5MZW5ndGgsIHJlcXVpcmVkLCB2YWx1ZX0gPSBtZSxcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlTGVuZ3RoID0gdmFsdWU/LnRvU3RyaW5nKCkubGVuZ3RoLFxuICAgICAgICAgICAgaXNFbXB0eSAgICAgPSB2YWx1ZSAhPT0gMCAmJiAoIXZhbHVlIHx8IHZhbHVlTGVuZ3RoIDwgMSksXG4gICAgICAgICAgICBlcnJvclBhcmFtICA9IHtpbnB1dFBhdHRlcm4sIG1heExlbmd0aCwgbWluTGVuZ3RoLCB2YWx1ZUxlbmd0aH0sXG4gICAgICAgICAgICBlcnJvclRleHQ7XG5cbiAgICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgICAgIC8vIGluIGNhc2Ugd2UgbWFudWFsbHkgY2FsbCB2YWxpZGF0ZShmYWxzZSkgb24gYSBmb3JtIG9yIGZpZWxkIGJlZm9yZSBpdCBpcyBtb3VudGVkLCB3ZSBkbyB3YW50IHRvIHNlZSBlcnJvcnMuXG4gICAgICAgICAgICBtZS5jbGVhbiA9IGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNFbXB0eSkge1xuICAgICAgICAgICAgaWYgKHJlcXVpcmVkKSB7XG4gICAgICAgICAgICAgICAgbWUuX2Vycm9yICAgPSBtZS5lcnJvclRleHRSZXF1aXJlZDtcbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKG1heExlbmd0aCkgJiYgdmFsdWVMZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBtZS5fZXJyb3IgICA9IG1lLmVycm9yVGV4dE1heExlbmd0aChlcnJvclBhcmFtKTtcbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IGZhbHNlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKE5lby5pc051bWJlcihtaW5MZW5ndGgpICYmIHZhbHVlTGVuZ3RoIDwgbWluTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbWUuX2Vycm9yICAgPSBtZS5lcnJvclRleHRNaW5MZW5ndGgoZXJyb3JQYXJhbSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBmYWxzZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dFBhdHRlcm4gJiYgIWlucHV0UGF0dGVybi50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG1lLl9lcnJvciAgID0gbWUuZXJyb3JUZXh0SW5wdXRQYXR0ZXJuKGVycm9yUGFyYW0pO1xuICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gZmFsc2VcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTmVvLmlzRnVuY3Rpb24obWUudmFsaWRhdG9yKSkge1xuICAgICAgICAgICAgICAgIGVycm9yVGV4dCA9IG1lLnZhbGlkYXRvcihtZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JUZXh0ICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLl9lcnJvciAgID0gZXJyb3JUZXh0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJldHVyblZhbHVlKSB7XG4gICAgICAgICAgICBtZS5fZXJyb3IgPSBudWxsXG4gICAgICAgIH1cblxuICAgICAgICAhbWUuY2xlYW4gJiYgbWUudXBkYXRlRXJyb3IobWUuX2Vycm9yLCBzaWxlbnQpO1xuXG4gICAgICAgIHJldHVybiAhcmV0dXJuVmFsdWUgPyBmYWxzZSA6IHN1cGVyLnZhbGlkYXRlKHNpbGVudClcbiAgICB9XG59XG5cbk5lby5zZXR1cENsYXNzKFRleHQpO1xuXG5leHBvcnQgZGVmYXVsdCBUZXh0O1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi8uLi8uLi9jb21wb25lbnQvQmFzZS5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICBmcm9tICcuLi8uLi8uLi91dGlsL0FycmF5Lm1qcyc7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgZm9ybSBmaWVsZCBUcmlnZ2Vyc1xuICogQGNsYXNzIE5lby5mb3JtLmZpZWxkLnRyaWdnZXIuQmFzZVxuICogQGV4dGVuZHMgTmVvLmNvbXBvbmVudC5CYXNlXG4gKi9cbmNsYXNzIEJhc2UgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIFZhbGlkIHZhbHVlcyBmb3IgYWxpZ25cbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYWxpZ25WYWx1ZXM9WydlbmQnLCAnc3RhcnQnXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGFsaWduVmFsdWVzID0gWydlbmQnLCAnc3RhcnQnXVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZm9ybS5maWVsZC50cmlnZ2VyLkJhc2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5mb3JtLmZpZWxkLnRyaWdnZXIuQmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSd0cmlnZ2VyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3RyaWdnZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBhbGlnbl89J2VuZCdcbiAgICAgICAgICovXG4gICAgICAgIGFsaWduOiAnZW5kJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWZpZWxkLXRyaWdnZXInXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tZmllbGQtdHJpZ2dlciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmZvcm0uZmllbGQuQmFzZXxudWxsfSBmaWVsZD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBmaWVsZF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gaWNvbkNsc189bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgaWNvbkNsc186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc0hvdmVyZWQ9ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaXNIb3ZlcmVkOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzY29wZSBvZiB0aGUgdHJpZ2dlciBoYW5kbGVyXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb3JlLkJhc2V8bnVsbH0gc2NvcGU9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgc2NvcGU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaG93T25Ib3Zlcj1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgc2hvd09uSG92ZXI6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgZmxhZyB1c2VkIGJ5IGZpZWxkLmdldFRyaWdnZXIoKVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHR5cGU9J2Jhc2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHR5cGU6ICdiYXNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gd2VpZ2h0Xz0xMFxuICAgICAgICAgKi9cbiAgICAgICAgd2VpZ2h0XzogMTBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmFkZERvbUxpc3RlbmVycyhcbiAgICAgICAgICAgIHtjbGljazogbWUub25UcmlnZ2VyQ2xpY2ssIHNjb3BlOiBtZX1cbiAgICAgICAgKTtcblxuICAgICAgICBpZiAobWUuc2hvd09uSG92ZXIpIHtcbiAgICAgICAgICAgIG1lLmhpZGRlbiA9IHRydWU7XG5cbiAgICAgICAgICAgIG1lLmZpZWxkLm9uKCdjb25zdHJ1Y3RlZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBtZS5maWVsZC5hZGREb21MaXN0ZW5lcnMoW1xuICAgICAgICAgICAgICAgICAgICB7bW91c2VlbnRlcjogbWUub25Nb3VzZUVudGVyLCBzY29wZTogbWV9LFxuICAgICAgICAgICAgICAgICAgICB7bW91c2VsZWF2ZTogbWUub25Nb3VzZUxlYXZlLCBzY29wZTogbWV9XG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIH0sIG1lKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBhbGlnbiBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRBbGlnbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IGNscyA9IHRoaXMuY2xzO1xuXG4gICAgICAgIE5lb0FycmF5W3ZhbHVlID09PSAnc3RhcnQnID8gJ2FkZCcgOiAncmVtb3ZlJ10oY2xzLCAnbmVvLWFsaWduLXN0YXJ0Jyk7XG4gICAgICAgIHRoaXMuY2xzID0gY2xzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBmaWVsZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRGaWVsZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgKHRoaXMudmRvbS5kYXRhIHx8ICh0aGlzLnZkb20uZGF0YSA9IHt9KSkuZm9jdXMgPSB2YWx1ZT8uZ2V0SW5wdXRFbElkKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGhpZGRlbiBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEhpZGRlbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IHtzdHlsZX0gPSB0aGlzO1xuXG4gICAgICAgIHN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/ICdub25lJyA6ICdpbmhlcml0JztcbiAgICAgICAgdGhpcy5zdHlsZSA9IHN0eWxlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBpY29uQ2xzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEljb25DbHModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCB7Y2xzfSA9IHRoaXM7XG5cbiAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgb2xkVmFsdWUpO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgICAgIE5lb0FycmF5LmFkZChjbHMsIHZhbHVlKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jbHMgPSBjbHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBhbGlnbiBjb25maWcgZ2V0cyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldEFsaWduKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnYWxpZ24nLCAnYWxpZ25WYWx1ZXMnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdXBkYXRlUGFyZW50VmRvbVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50XG4gICAgICovXG4gICAgZGVzdHJveSh1cGRhdGVQYXJlbnRWZG9tLCBzaWxlbnQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5yZW1vdmVEb21MaXN0ZW5lcnMoXG4gICAgICAgICAgICB7Y2xpY2s6IG1lLm9uVHJpZ2dlckNsaWNrLCBzY29wZTogbWV9XG4gICAgICAgICk7XG5cbiAgICAgICAgZGVsZXRlIG1lLmZpZWxkO1xuXG4gICAgICAgIHN1cGVyLmRlc3Ryb3kodXBkYXRlUGFyZW50VmRvbSwgc2lsZW50KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25Nb3VzZUVudGVyKCkge1xuICAgICAgICB0aGlzLmlzSG92ZXJlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaGlkZGVuICAgID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbk1vdXNlTGVhdmUoKSB7XG4gICAgICAgIHRoaXMuaXNIb3ZlcmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGlkZGVuICAgID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjbGljayBkb21FdmVudCBsaXN0ZW5lclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uVHJpZ2dlckNsaWNrKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIHNjb3BlID0gbWUuc2NvcGUgfHwgbWU7XG5cbiAgICAgICAgaWYgKG1lLmhhbmRsZXIpIHtcbiAgICAgICAgICAgIHNjb3BlW21lLmhhbmRsZXJdLmNhbGwoc2NvcGUpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbk5lby5zZXR1cENsYXNzKEJhc2UpO1xuXG5leHBvcnQgZGVmYXVsdCBCYXNlO1xuIiwiaW1wb3J0IEJhc2UgICAgIGZyb20gJy4vQmFzZS5tanMnO1xuaW1wb3J0IE5lb0FycmF5IGZyb20gJy4uLy4uLy4uL3V0aWwvQXJyYXkubWpzJztcblxuLyoqXG4gKiBDbGVhciBUcmlnZ2VyIHRvIHJlbW92ZSB0aGUgaW5wdXQgdmFsdWUgb2YgVGV4dEZpZWxkcyBvciBzdWJjbGFzc2VzXG4gKiBAY2xhc3MgTmVvLmZvcm0uZmllbGQudHJpZ2dlci5DbGVhclxuICogQGV4dGVuZHMgTmVvLmZvcm0uZmllbGQudHJpZ2dlci5CYXNlXG4gKi9cbmNsYXNzIENsZWFyIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZm9ybS5maWVsZC50cmlnZ2VyLkNsZWFyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZm9ybS5maWVsZC50cmlnZ2VyLkNsZWFyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3RyaWdnZXItY2xlYXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAndHJpZ2dlci1jbGVhcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1maWVsZC10cmlnZ2VyJywnbmVvLXRyaWdnZXItY2xlYXInXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tZmllbGQtdHJpZ2dlcicsICduZW8tdHJpZ2dlci1jbGVhciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGljb25DbHM9J2ZhIGZhLXRpbWVzJ1xuICAgICAgICAgKi9cbiAgICAgICAgaWNvbkNsczogJ2ZhIGZhLXRpbWVzJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGZsYWcgdXNlZCBieSBmaWVsZC5nZXRUcmlnZ2VyKClcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB0eXBlPSdjbGVhcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdHlwZTogJ2NsZWFyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gd2VpZ2h0Xz0yMFxuICAgICAgICAgKi9cbiAgICAgICAgd2VpZ2h0OiAyMFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaGlkZGVuIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SGlkZGVuKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQge2Nsc30gPSB0aGlzO1xuXG4gICAgICAgIE5lb0FycmF5W3ZhbHVlID8gJ2FkZCcgOiAncmVtb3ZlJ10oY2xzLCAnbmVvLWlzLWhpZGRlbicpO1xuICAgICAgICB0aGlzLmNscyA9IGNscztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBoaWRkZW4gY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRIaWRkZW4odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnNob3dPbkhvdmVyICYmICF0aGlzLmlzSG92ZXJlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZGVzdHJveSguLi5hcmdzKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuZmllbGQudW4oe1xuICAgICAgICAgICAgY2hhbmdlICAgICAgICAgICAgICAgICAgICA6IG1lLm9uRmllbGRDaGFuZ2UsXG4gICAgICAgICAgICBjaGFuZ2VDbGVhclRvT3JpZ2luYWxWYWx1ZTogbWUub25GaWVsZENoYW5nZSxcbiAgICAgICAgICAgIHNjb3BlICAgICAgICAgICAgICAgICAgICAgOiBtZVxuICAgICAgICB9KTtcblxuICAgICAgICBzdXBlci5kZXN0cm95KC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaW4gY2FzZSB0aGUgdHJpZ2dlciBzaG91bGQgYmUgaGlkZGVuXG4gICAgICovXG4gICAgZ2V0SGlkZGVuU3RhdGUoKSB7XG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtmaWVsZH0gPSBtZSxcbiAgICAgICAgICAgIHt2YWx1ZX0gPSBmaWVsZDtcblxuICAgICAgICBpZiAoZmllbGQuY2xlYXJUb09yaWdpbmFsVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gZmllbGQub3JpZ2luYWxDb25maWcudmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICcwJ1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gIWZpZWxkLnZhbHVlIHx8IHZhbHVlLnRvU3RyaW5nKCkubGVuZ3RoIDwgMVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKi9cbiAgICBvbkZpZWxkQ2hhbmdlKG9wdHMpIHtcbiAgICAgICAgdGhpcy5oaWRkZW4gPSB0aGlzLmdldEhpZGRlblN0YXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIHN1cGVyLm9uQ29uc3RydWN0ZWQoKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmZpZWxkLm9uKHtcbiAgICAgICAgICAgIGNoYW5nZSAgICAgICAgICAgICAgICAgICAgOiBtZS5vbkZpZWxkQ2hhbmdlLFxuICAgICAgICAgICAgY2hhbmdlQ2xlYXJUb09yaWdpbmFsVmFsdWU6IG1lLm9uRmllbGRDaGFuZ2UsXG4gICAgICAgICAgICBzY29wZSAgICAgICAgICAgICAgICAgICAgIDogbWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUuaGlkZGVuID0gbWUuZ2V0SGlkZGVuU3RhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIG9uTW91c2VFbnRlcigpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5pc0hvdmVyZWQgPSB0cnVlO1xuICAgICAgICBtZS5oaWRkZW4gICAgPSBtZS5nZXRIaWRkZW5TdGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvblRyaWdnZXJDbGljayhkYXRhKSB7XG4gICAgICAgIHRoaXMuZmllbGQuY2xlYXIoKVxuICAgIH1cbn1cblxuTmVvLnNldHVwQ2xhc3MoQ2xlYXIpO1xuXG5leHBvcnQgZGVmYXVsdCBDbGVhcjtcbiIsImltcG9ydCBCYXNlIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8udXRpbC5TdHJpbmdcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgU3RyaW5nVXRpbCBleHRlbmRzIEJhc2Uge1xuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gY2hhckVudGl0eU1hcFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgY2hhckVudGl0eU1hcCA9IHtcbiAgICAgICAgJyYnIDogJyZhbXA7JyxcbiAgICAgICAgJzwnIDogJyZsdDsnLFxuICAgICAgICAnPicgOiAnJmd0OycsXG4gICAgICAgICdcIicgOiAnJnF1b3Q7JyxcbiAgICAgICAgJ1xcJyc6ICcmYXBvczsnLFxuICAgICAgICAnJCcgOiAnJmRvbGxhcjsnLFxuICAgICAgICAnXFxcXCc6ICcmYnNvbDsnLFxuICAgICAgICAnLycgOiAnJnNvbDsnXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge1JlZ0V4cH0gY2hhclBhdHRlcm5cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGNoYXJQYXR0ZXJuID0gL1smPD5cIickXFxcXF0vZ1xuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge1JlZ0V4cH0gZW50aXR5UGF0dGVyblxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgZW50aXR5UGF0dGVybiA9IC8oJmFtcDspfCgmbHQ7KXwoJmd0Oyl8KCZxdW90Oyl8KCZhcG9zOyl8KCZkb2xsYXI7KXwoJmJzb2w7KXwoJnNvbDspL2dcblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnV0aWwuU3RyaW5nJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8udXRpbC5TdHJpbmcnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXNjYXBlIEhUTUwgc3BlY2lhbCBjaGFyYWN0ZXJzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICovXG4gICAgc3RhdGljIGVzY2FwZUh0bWwodmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpczsgLy8gaW5zaWRlIGEgc3RhdGljIG1ldGhvZCwgd2UgYXJlIHBvaW50aW5nIHRvIHRoZSBjbGFzcyBwcm90b3R5cGVcblxuICAgICAgICBpZiAoIU5lby5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UobWUuY2hhclBhdHRlcm4sIG1lLmdldEVudGl0eUZyb21DaGFyLmJpbmQobWUpKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBjaGFyIGVxdWl2YWxlbnQgb2YgYSBtYXBwZWQgZW50aXR5XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGVudGl0eVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRDaGFyRnJvbUVudGl0eShlbnRpdHkpIHtcbiAgICAgICAgbGV0IG1hcHBlZENoYXIgPSBPYmplY3Qua2V5cyh0aGlzLmNoYXJFbnRpdHlNYXApLmZpbmQoa2V5ID0+IHRoaXMuY2hhckVudGl0eU1hcFtrZXldID09PSBlbnRpdHkpO1xuICAgICAgICByZXR1cm4gbWFwcGVkQ2hhciB8fCBlbnRpdHlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZW50aXR5IGVxdWl2YWxlbnQgb2YgYSBtYXBwZWQgY2hhclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjaGFyXG4gICAgICovXG4gICAgc3RhdGljIGdldEVudGl0eUZyb21DaGFyKGNoYXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhckVudGl0eU1hcFtjaGFyXSB8fCBjaGFyXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5lc2NhcGUgSFRNTCBzcGVjaWFsIGNoYXJhY3RlcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cbiAgICBzdGF0aWMgdW5lc2NhcGVIdG1sKHZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7IC8vIGluc2lkZSBhIHN0YXRpYyBtZXRob2QsIHdlIGFyZSBwb2ludGluZyB0byB0aGUgY2xhc3MgcHJvdG90eXBlXG5cbiAgICAgICAgaWYgKCFOZW8uaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKG1lLmVudGl0eVBhdHRlcm4sIG1lLmdldENoYXJGcm9tRW50aXR5LmJpbmQobWUpKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBhc3NlZCBzdHJpbmcgd2l0aCB0aGUgZmlyc3QgbGV0dGVyIHVuY2FwaXRhbGl6ZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHJldHVybnMgIHtTdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIHVuY2FwaXRhbGl6ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWVbMF0udG9Mb3dlckNhc2UoKSArIHZhbHVlLnN1YnN0cmluZygxKVxuICAgIH1cbn1cblxuTmVvLnNldHVwQ2xhc3MoU3RyaW5nVXRpbCk7XG5cbmV4cG9ydCBkZWZhdWx0IFN0cmluZ1V0aWw7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=