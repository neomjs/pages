"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_list_plugin_Animate_mjs"],{

/***/ "./src/list/plugin/Animate.mjs":
/*!*************************************!*\
  !*** ./src/list/plugin/Animate.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _plugin_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../plugin/Base.mjs */ "./src/plugin/Base.mjs");
/* harmony import */ var _util_Css_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Css.mjs */ "./src/util/Css.mjs");



/**
 * @class Neo.list.plugin.Animate
 * @extends Neo.plugin.Base
 */
class Animate extends _plugin_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for transitionEasing
     * @member {String[]} transitionEasings=['ease','ease-in','ease-out','ease-in-out','linear']
     * @protected
     * @static
     */
    static transitionEasings = ['ease', 'ease-in', 'ease-out', 'ease-in-out', 'linear']

    static config = {
        /**
         * @member {String} className='Neo.list.plugin.Animate'
         * @protected
         */
        className: 'Neo.list.plugin.Animate',
        /**
         * @member {String} ntype='plugin-list-animate'
         * @protected
         */
        ntype: 'plugin-list-animate',
        /**
         * Read only
         * @member {Number|null} columns=null
         */
        columns: null,
        /**
         * Value in px
         * @member {Number} itemMargin=10
         */
        itemMargin: 10,
        /**
         * @member {DOMRect|null} ownerRect=null
         */
        ownerRect: null,
        /**
         * Read only
         * @member {Number|null} rows=null
         */
        rows: null,
        /**
         * Time in ms. Please ensure to match the CSS based value, in case you change the default.
         * @member {Number} transitionDuration_=500
         */
        transitionDuration_: 500,
        /**
         * The easing used for fadeIn, fadeOut and position changes.
         * Valid values: 'ease','ease-in','ease-out','ease-in-out','linear'
         * @member {String} transitionEasing_='ease-in-out'
         */
        transitionEasing_: 'ease-in-out',
        /**
         * The id of the setTimeout() call which gets triggered after a transition is done.
         * @member {Number|null} transitionTimeoutId=null
         */
        transitionTimeoutId: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me      = this,
            {owner} = me;

        if (!owner.itemHeight || !owner.itemWidth) {
            console.error('list.plugin.Animate requires fixed itemHeight and itemWidth values', owner)
        }

        me.adjustCreateItem();

        owner.onStoreFilter = me.onStoreFilter.bind(me);
        owner.onStoreSort   = me.onStoreSort  .bind(me);

        this.updateTransitionDetails()
    }

    /**
     *
     */
    adjustCreateItem() {
        let me      = this,
            {owner} = me;

        me.ownerCreateItem = owner.createItem.bind(owner);
        owner.createItem   = me.createItem.bind(owner, me)
    }

    /**
     * Triggered after the transitionDuration config got changed.
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetTransitionDuration(value, oldValue) {
        this.isConstructed && this.updateTransitionDetails(Neo.isNumber(oldValue))
    }

    /**
     * Triggered after the transitionEasing config got changed.
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetTransitionEasing(value, oldValue) {
        this.isConstructed && this.updateTransitionDetails(!!oldValue)
    }

    /**
     * Triggered before the transitionEasing config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetTransitionEasing(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'transitionEasing')
    }

    /**
     * @param {Neo.list.plugin.Animate} me
     * @param {Object} record
     * @param {Number} index
     * @returns {Object}
     */
    createItem(me, record, index) {
        let item     = me.ownerCreateItem(record, index),
            {owner}  = me,
            position = me.getItemPosition(record, index),
            style    = item.style || {};

        if (!me.ownerRect) {
            return null
        }

        Object.assign(style, {
            height   : `${owner.itemHeight}px`,
            position : 'absolute',
            transform: `translate(${position.x}px, ${position.y}px)`,
            width    : `${owner.itemWidth}px`
        });

        item.style = style;

        return item
    }

    /**
     * @param {Object} args
     */
    destroy(...args) {
        _util_Css_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].deleteRules(this.windowId, `#${this.owner.id} .neo-list-item`);
        super.destroy(...args)
    }

    /**
     * @param {Object} record
     * @param {Number} index
     * @returns {{x: Number, y: Number}}
     */
    getItemPosition(record, index) {
        let me     = this,
            column = index % me.columns,
            margin = me.itemMargin,
            owner  = me.owner,
            row    = Math.floor(index / me.columns),
            x      = column * (margin + owner.itemWidth)  + margin,
            y      = row    * (margin + owner.itemHeight) + margin;

        return {x, y}
    }

    /**
     * @param {Object} obj
     * @param {String[]} map
     * @param {Boolean} intercept
     * @returns {Number}
     */
    getItemIndex(obj, map, intercept) {
        if (!intercept) {
            return obj.index
        }

        let owner = this.owner,
            key   = owner.getKeyProperty();

        return map.indexOf(owner.getItemId(obj.record[key]))
    }

    /**
     *
     */
    onOwnerMounted() {
        let me    = this,
            owner = me.owner;

        owner.getDomRect().then(rect => {
            Object.assign(me, {
                columns  : Math.floor(rect.width / owner.itemWidth),
                ownerRect: rect,
                rows     : Math.floor(rect.height / owner.itemHeight)
            });

            // if the store got loaded before this plugin is ready, create the items now
            owner.store.getCount() > 0 && owner.createItems()
        })
    }

    /**
     * @param {Object} data
     * @param {Boolean} data.isFiltered
     * @param {Object[]} data.items
     * @param {Object[]} data.oldItems
     * @param {Neo.data.Store} data.scope
     */
    onStoreFilter(data) {
        let me                  = this,
            owner               = me.owner,
            key                 = owner.getKeyProperty(),
            hasAddedItems       = false,
            addedItems          = [],
            movedItems          = [],
            removedItems        = [],
            transitionTimeoutId = me.transitionTimeoutId,
            intercept           = !!transitionTimeoutId,
            vdom                = owner.vdom,
            index, item, map, position;

        if (transitionTimeoutId) {
            clearTimeout(transitionTimeoutId);
            me.transitionTimeoutId = null;
        }

        map = intercept ? vdom.cn.map(e => e.id) : [];

        data.items.forEach((record, index) => {
            item = {index, record};

            if (!data.oldItems.includes(record)) {
                // flag items which are still inside the DOM (running remove OP)
                if (intercept && map.includes(owner.getItemId(record[key]))) {
                    item.reAdded = true;
                }

                addedItems.push(item)
            } else {
                movedItems.push(item)
            }
        });

        data.oldItems.forEach((record, index) => {
            if (!data.items.includes(record)) {
                removedItems.push({index, record})
            }
        });

        addedItems.forEach(obj => {
            if (!obj.reAdded) {
                index = me.getItemIndex(obj, map, intercept);

                if (index > -1) {
                    hasAddedItems = true;

                    vdom.cn.splice(index, 0, me.createItem(me, obj.record, obj.index));

                    obj.item = vdom.cn[index];
                    obj.item.style.opacity = 0
                }
            }
        });

        hasAddedItems && owner.update();

        // ensure to get into the next animation frame
        me.timeout(50).then(() => {
            // new items are already added into the vdom, while old items are not yet removed
            // => we need a map to ensure getting the correct index
            map = vdom.cn.map(e => e.id);

            addedItems.forEach(obj => {
                index = me.getItemIndex(obj, map, intercept);

                if (index > -1) {
                    // we can change the opacity for re-added items too => the vdom engine will ignore this
                    vdom.cn[index].style.opacity = 1
                }
            });

            movedItems.forEach(obj => {
                index = me.getItemIndex(obj, map, true); // honor removed items, even without interceptions

                if (index > -1) {
                    position = me.getItemPosition(obj.record, obj.index);

                    Object.assign(vdom.cn[index].style, {
                        opacity  : 1,
                        transform: `translate(${position.x}px, ${position.y}px)`
                    })
                }
            });

            removedItems.forEach(obj => {
                index = me.getItemIndex(obj, map, intercept);

                if (index > -1) {
                    obj.item = vdom.cn[index];
                    obj.item.style.opacity = 0
                }
            });

            owner.update();
            me.triggerTransitionCallback()
        })
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.items
     * @param {Object[]} data.previousItems
     * @param {Neo.data.Store} data.scope
     */
    onStoreSort(data) {
        let me = this;

        if (Neo.list.Component && me.owner instanceof Neo.list.Component) {
            me.sortComponentList(data);
        } else {
            me.sortBaseList(data);
        }
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.items
     * @param {Object[]} data.previousItems
     * @param {Neo.data.Store} data.scope
     */
    sortBaseList(data) {
        let me            = this,
            hasChange     = false,
            owner         = me.owner,
            key           = owner.getKeyProperty(),
            newVdomCn     = [],
            previousKeys  = data.previousItems.map(e => e[key]),
            vdom          = owner.vdom,
            fromIndex;

        if (vdom.cn.length > 0) {
            data.items.forEach((item, index) => {
                fromIndex = previousKeys.indexOf(item[key]);

                newVdomCn.push(vdom.cn[fromIndex]);

                if (fromIndex !== index) {
                    hasChange = true
                }
            });

            if (hasChange) {
                vdom.cn = newVdomCn;
                owner.update();

                // we need to ensure to get this call into the next animation frame
                me.timeout(50).then(() => {
                    owner.createItems()
                })
            }
        }
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.items
     * @param {Object[]} data.previousItems
     * @param {Neo.data.Store} data.scope
     */
    sortComponentList(data) {
        let me           = this,
            owner        = me.owner,
            key          = owner.getKeyProperty(),
            previousKeys = data.previousItems.map(e => e[key]),
            vdom         = owner.vdom,
            fromIndex, item, position;

        owner.sortItems(data);

        previousKeys = owner.items.map(e => owner.getItemRecordId(e[key]));

        if (vdom.cn.length > 0) {
            data.items.forEach((record, index) => {
                fromIndex = previousKeys.indexOf(record[key]);
                item      = vdom.cn[fromIndex];
                position  = me.getItemPosition(record, index);

                item.style.transform = `translate(${position.x}px, ${position.y}px)`
            });

            owner.update()
        }
    }

    /**
     *
     */
    triggerTransitionCallback() {
        let me = this;

        me.transitionTimeoutId = setTimeout(() => {
            me.transitionTimeoutId = null;

            me.owner.createItems()
        }, me.transitionDuration)
    }

    /**
     * We do not want to apply the style to each list item itself, so we are using Neo.util.Css
     * @param {Boolean} deleteRule=false
     * @protected
     */
    async updateTransitionDetails(deleteRule=false) {
        let me       = this,
            duration = me.transitionDuration,
            easing   = me.transitionEasing,
            {id}     = me.owner;

        if (deleteRule) {
            await _util_Css_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].deleteRules(me.windowId, `#${id} .neo-list-item`)
        }

        _util_Css_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].insertRules(me.windowId, [
            `#${id} .neo-list-item {`,
                `transition: opacity ${duration}ms ${easing}, transform ${duration}ms ${easing}`,
            '}'
        ].join(''))
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Animate));


/***/ }),

/***/ "./src/plugin/Base.mjs":
/*!*****************************!*\
  !*** ./src/plugin/Base.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * Abstract base class for plugin implementations.
 * Plugins are intended to get put into the plugins config of component.Base
 * to enhance them or add additional features
 * @class Neo.plugin.Base
 * @extends Neo.core.Base
 */
class Plugin extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.plugin.Base'
         * @protected
         */
        className: 'Neo.plugin.Base',
        /**
         * All plugin ntypes need to start with 'plugin-' to ensure that component.Base: getPlugin() can find them
         * @member {String} ntype='plugin'
         * @protected
         */
        ntype: 'plugin',
        /**
         * @member {Neo.component.Base} owner=null
         * @protected
         */
        owner: null,
        /**
         * @member {Number|null} windowId_=null
         */
        windowId_: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me      = this,
            {owner} = me;

        if (owner.isConstructed) {
            me.onOwnerConstructed()
        } else {
            owner.on('constructed', () => {
                me.onOwnerConstructed()
            }, me, {once: true})
        }

        if (owner.mounted) {
            me.onOwnerMounted();
        } else {
            owner.on('mounted', me.onOwnerMounted, me);
        }
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        value && Neo.currentWorker.insertThemeFiles(value, this.__proto__)
    }

    /**
     * Override this method to apply changes to the owner Component when it is constructed
     */
    onOwnerConstructed() {
        let {owner} = this;

        if (owner.windowId) {
            this.windowId = owner.windowId
        }
    }

    /**
     * Override this method to apply changes to the owner Component when it does get mounted
     */
    onOwnerMounted() {

    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Plugin));


/***/ }),

/***/ "./src/util/Css.mjs":
/*!**************************!*\
  !*** ./src/util/Css.mjs ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.util.Css
 * @extends Neo.core.Base
 */
class Css extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.Css'
         * @protected
         */
        className: 'Neo.util.Css'
    }

    /**
     * Pass the selectorText of the rules which you want to remove
     * @param {Number} windowId
     * @param {String[]|String} rules
     */
    static deleteRules(windowId, rules) {
        if (!Array.isArray(rules)) {
            rules = [rules]
        }

        Neo.main.addon.Stylesheet.deleteCssRules({rules, windowId})
    }

    /**
     * @param {Number} windowId
     * @param {String[]|String} rules
     */
    static insertRules(windowId, rules) {
        if (!Array.isArray(rules)) {
            rules = [rules]
        }

        Neo.main.addon.Stylesheet.insertCssRules({rules, windowId})
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Css));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19saXN0X3BsdWdpbl9BbmltYXRlX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBNEM7QUFDSDs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0RBQUk7QUFDMUI7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPOztBQUVwQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87O0FBRXBCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFD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Ozs7Ozs7Ozs7O0FDdEZGOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzREFBSTtBQUN0QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtEQUFrRCxnQkFBZ0I7QUFDbEU7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrREFBa0QsZ0JBQWdCO0FBQ2xFO0FBQ0E7O0FBRUEsaUVBQWUsbUJBQW1CLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2xpc3QvcGx1Z2luL0FuaW1hdGUubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvcGx1Z2luL0Jhc2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdXRpbC9Dc3MubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCYXNlICAgIGZyb20gJy4uLy4uL3BsdWdpbi9CYXNlLm1qcyc7XG5pbXBvcnQgQ3NzVXRpbCBmcm9tICcuLi8uLi91dGlsL0Nzcy5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8ubGlzdC5wbHVnaW4uQW5pbWF0ZVxuICogQGV4dGVuZHMgTmVvLnBsdWdpbi5CYXNlXG4gKi9cbmNsYXNzIEFuaW1hdGUgZXh0ZW5kcyBCYXNlIHtcbiAgICAvKipcbiAgICAgKiBWYWxpZCB2YWx1ZXMgZm9yIHRyYW5zaXRpb25FYXNpbmdcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gdHJhbnNpdGlvbkVhc2luZ3M9WydlYXNlJywnZWFzZS1pbicsJ2Vhc2Utb3V0JywnZWFzZS1pbi1vdXQnLCdsaW5lYXInXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIHRyYW5zaXRpb25FYXNpbmdzID0gWydlYXNlJywgJ2Vhc2UtaW4nLCAnZWFzZS1vdXQnLCAnZWFzZS1pbi1vdXQnLCAnbGluZWFyJ11cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmxpc3QucGx1Z2luLkFuaW1hdGUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5saXN0LnBsdWdpbi5BbmltYXRlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3BsdWdpbi1saXN0LWFuaW1hdGUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAncGx1Z2luLWxpc3QtYW5pbWF0ZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWFkIG9ubHlcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IGNvbHVtbnM9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgY29sdW1uczogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhbHVlIGluIHB4XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gaXRlbU1hcmdpbj0xMFxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbU1hcmdpbjogMTAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtET01SZWN0fG51bGx9IG93bmVyUmVjdD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBvd25lclJlY3Q6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWFkIG9ubHlcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IHJvd3M9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgcm93czogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRpbWUgaW4gbXMuIFBsZWFzZSBlbnN1cmUgdG8gbWF0Y2ggdGhlIENTUyBiYXNlZCB2YWx1ZSwgaW4gY2FzZSB5b3UgY2hhbmdlIHRoZSBkZWZhdWx0LlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHRyYW5zaXRpb25EdXJhdGlvbl89NTAwXG4gICAgICAgICAqL1xuICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb25fOiA1MDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZWFzaW5nIHVzZWQgZm9yIGZhZGVJbiwgZmFkZU91dCBhbmQgcG9zaXRpb24gY2hhbmdlcy5cbiAgICAgICAgICogVmFsaWQgdmFsdWVzOiAnZWFzZScsJ2Vhc2UtaW4nLCdlYXNlLW91dCcsJ2Vhc2UtaW4tb3V0JywnbGluZWFyJ1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHRyYW5zaXRpb25FYXNpbmdfPSdlYXNlLWluLW91dCdcbiAgICAgICAgICovXG4gICAgICAgIHRyYW5zaXRpb25FYXNpbmdfOiAnZWFzZS1pbi1vdXQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGlkIG9mIHRoZSBzZXRUaW1lb3V0KCkgY2FsbCB3aGljaCBnZXRzIHRyaWdnZXJlZCBhZnRlciBhIHRyYW5zaXRpb24gaXMgZG9uZS5cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IHRyYW5zaXRpb25UaW1lb3V0SWQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgdHJhbnNpdGlvblRpbWVvdXRJZDogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtvd25lcn0gPSBtZTtcblxuICAgICAgICBpZiAoIW93bmVyLml0ZW1IZWlnaHQgfHwgIW93bmVyLml0ZW1XaWR0aCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignbGlzdC5wbHVnaW4uQW5pbWF0ZSByZXF1aXJlcyBmaXhlZCBpdGVtSGVpZ2h0IGFuZCBpdGVtV2lkdGggdmFsdWVzJywgb3duZXIpXG4gICAgICAgIH1cblxuICAgICAgICBtZS5hZGp1c3RDcmVhdGVJdGVtKCk7XG5cbiAgICAgICAgb3duZXIub25TdG9yZUZpbHRlciA9IG1lLm9uU3RvcmVGaWx0ZXIuYmluZChtZSk7XG4gICAgICAgIG93bmVyLm9uU3RvcmVTb3J0ICAgPSBtZS5vblN0b3JlU29ydCAgLmJpbmQobWUpO1xuXG4gICAgICAgIHRoaXMudXBkYXRlVHJhbnNpdGlvbkRldGFpbHMoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgYWRqdXN0Q3JlYXRlSXRlbSgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge293bmVyfSA9IG1lO1xuXG4gICAgICAgIG1lLm93bmVyQ3JlYXRlSXRlbSA9IG93bmVyLmNyZWF0ZUl0ZW0uYmluZChvd25lcik7XG4gICAgICAgIG93bmVyLmNyZWF0ZUl0ZW0gICA9IG1lLmNyZWF0ZUl0ZW0uYmluZChvd25lciwgbWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB0cmFuc2l0aW9uRHVyYXRpb24gY29uZmlnIGdvdCBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VHJhbnNpdGlvbkR1cmF0aW9uKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmlzQ29uc3RydWN0ZWQgJiYgdGhpcy51cGRhdGVUcmFuc2l0aW9uRGV0YWlscyhOZW8uaXNOdW1iZXIob2xkVmFsdWUpKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdHJhbnNpdGlvbkVhc2luZyBjb25maWcgZ290IGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VHJhbnNpdGlvbkVhc2luZyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5pc0NvbnN0cnVjdGVkICYmIHRoaXMudXBkYXRlVHJhbnNpdGlvbkRldGFpbHMoISFvbGRWYWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSB0cmFuc2l0aW9uRWFzaW5nIGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0VHJhbnNpdGlvbkVhc2luZyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ3RyYW5zaXRpb25FYXNpbmcnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmxpc3QucGx1Z2luLkFuaW1hdGV9IG1lXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgY3JlYXRlSXRlbShtZSwgcmVjb3JkLCBpbmRleCkge1xuICAgICAgICBsZXQgaXRlbSAgICAgPSBtZS5vd25lckNyZWF0ZUl0ZW0ocmVjb3JkLCBpbmRleCksXG4gICAgICAgICAgICB7b3duZXJ9ICA9IG1lLFxuICAgICAgICAgICAgcG9zaXRpb24gPSBtZS5nZXRJdGVtUG9zaXRpb24ocmVjb3JkLCBpbmRleCksXG4gICAgICAgICAgICBzdHlsZSAgICA9IGl0ZW0uc3R5bGUgfHwge307XG5cbiAgICAgICAgaWYgKCFtZS5vd25lclJlY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3QuYXNzaWduKHN0eWxlLCB7XG4gICAgICAgICAgICBoZWlnaHQgICA6IGAke293bmVyLml0ZW1IZWlnaHR9cHhgLFxuICAgICAgICAgICAgcG9zaXRpb24gOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7cG9zaXRpb24ueH1weCwgJHtwb3NpdGlvbi55fXB4KWAsXG4gICAgICAgICAgICB3aWR0aCAgICA6IGAke293bmVyLml0ZW1XaWR0aH1weGBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbS5zdHlsZSA9IHN0eWxlO1xuXG4gICAgICAgIHJldHVybiBpdGVtXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcbiAgICAgKi9cbiAgICBkZXN0cm95KC4uLmFyZ3MpIHtcbiAgICAgICAgQ3NzVXRpbC5kZWxldGVSdWxlcyh0aGlzLndpbmRvd0lkLCBgIyR7dGhpcy5vd25lci5pZH0gLm5lby1saXN0LWl0ZW1gKTtcbiAgICAgICAgc3VwZXIuZGVzdHJveSguLi5hcmdzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7e3g6IE51bWJlciwgeTogTnVtYmVyfX1cbiAgICAgKi9cbiAgICBnZXRJdGVtUG9zaXRpb24ocmVjb3JkLCBpbmRleCkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbHVtbiA9IGluZGV4ICUgbWUuY29sdW1ucyxcbiAgICAgICAgICAgIG1hcmdpbiA9IG1lLml0ZW1NYXJnaW4sXG4gICAgICAgICAgICBvd25lciAgPSBtZS5vd25lcixcbiAgICAgICAgICAgIHJvdyAgICA9IE1hdGguZmxvb3IoaW5kZXggLyBtZS5jb2x1bW5zKSxcbiAgICAgICAgICAgIHggICAgICA9IGNvbHVtbiAqIChtYXJnaW4gKyBvd25lci5pdGVtV2lkdGgpICArIG1hcmdpbixcbiAgICAgICAgICAgIHkgICAgICA9IHJvdyAgICAqIChtYXJnaW4gKyBvd25lci5pdGVtSGVpZ2h0KSArIG1hcmdpbjtcblxuICAgICAgICByZXR1cm4ge3gsIHl9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IG1hcFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW50ZXJjZXB0XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRJdGVtSW5kZXgob2JqLCBtYXAsIGludGVyY2VwdCkge1xuICAgICAgICBpZiAoIWludGVyY2VwdCkge1xuICAgICAgICAgICAgcmV0dXJuIG9iai5pbmRleFxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG93bmVyID0gdGhpcy5vd25lcixcbiAgICAgICAgICAgIGtleSAgID0gb3duZXIuZ2V0S2V5UHJvcGVydHkoKTtcblxuICAgICAgICByZXR1cm4gbWFwLmluZGV4T2Yob3duZXIuZ2V0SXRlbUlkKG9iai5yZWNvcmRba2V5XSkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbk93bmVyTW91bnRlZCgpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIG93bmVyID0gbWUub3duZXI7XG5cbiAgICAgICAgb3duZXIuZ2V0RG9tUmVjdCgpLnRoZW4ocmVjdCA9PiB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG1lLCB7XG4gICAgICAgICAgICAgICAgY29sdW1ucyAgOiBNYXRoLmZsb29yKHJlY3Qud2lkdGggLyBvd25lci5pdGVtV2lkdGgpLFxuICAgICAgICAgICAgICAgIG93bmVyUmVjdDogcmVjdCxcbiAgICAgICAgICAgICAgICByb3dzICAgICA6IE1hdGguZmxvb3IocmVjdC5oZWlnaHQgLyBvd25lci5pdGVtSGVpZ2h0KVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBzdG9yZSBnb3QgbG9hZGVkIGJlZm9yZSB0aGlzIHBsdWdpbiBpcyByZWFkeSwgY3JlYXRlIHRoZSBpdGVtcyBub3dcbiAgICAgICAgICAgIG93bmVyLnN0b3JlLmdldENvdW50KCkgPiAwICYmIG93bmVyLmNyZWF0ZUl0ZW1zKClcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGF0YS5pc0ZpbHRlcmVkXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5pdGVtc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGEub2xkSXRlbXNcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLlN0b3JlfSBkYXRhLnNjb3BlXG4gICAgICovXG4gICAgb25TdG9yZUZpbHRlcihkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIG93bmVyICAgICAgICAgICAgICAgPSBtZS5vd25lcixcbiAgICAgICAgICAgIGtleSAgICAgICAgICAgICAgICAgPSBvd25lci5nZXRLZXlQcm9wZXJ0eSgpLFxuICAgICAgICAgICAgaGFzQWRkZWRJdGVtcyAgICAgICA9IGZhbHNlLFxuICAgICAgICAgICAgYWRkZWRJdGVtcyAgICAgICAgICA9IFtdLFxuICAgICAgICAgICAgbW92ZWRJdGVtcyAgICAgICAgICA9IFtdLFxuICAgICAgICAgICAgcmVtb3ZlZEl0ZW1zICAgICAgICA9IFtdLFxuICAgICAgICAgICAgdHJhbnNpdGlvblRpbWVvdXRJZCA9IG1lLnRyYW5zaXRpb25UaW1lb3V0SWQsXG4gICAgICAgICAgICBpbnRlcmNlcHQgICAgICAgICAgID0gISF0cmFuc2l0aW9uVGltZW91dElkLFxuICAgICAgICAgICAgdmRvbSAgICAgICAgICAgICAgICA9IG93bmVyLnZkb20sXG4gICAgICAgICAgICBpbmRleCwgaXRlbSwgbWFwLCBwb3NpdGlvbjtcblxuICAgICAgICBpZiAodHJhbnNpdGlvblRpbWVvdXRJZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRyYW5zaXRpb25UaW1lb3V0SWQpO1xuICAgICAgICAgICAgbWUudHJhbnNpdGlvblRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBtYXAgPSBpbnRlcmNlcHQgPyB2ZG9tLmNuLm1hcChlID0+IGUuaWQpIDogW107XG5cbiAgICAgICAgZGF0YS5pdGVtcy5mb3JFYWNoKChyZWNvcmQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpdGVtID0ge2luZGV4LCByZWNvcmR9O1xuXG4gICAgICAgICAgICBpZiAoIWRhdGEub2xkSXRlbXMuaW5jbHVkZXMocmVjb3JkKSkge1xuICAgICAgICAgICAgICAgIC8vIGZsYWcgaXRlbXMgd2hpY2ggYXJlIHN0aWxsIGluc2lkZSB0aGUgRE9NIChydW5uaW5nIHJlbW92ZSBPUClcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJjZXB0ICYmIG1hcC5pbmNsdWRlcyhvd25lci5nZXRJdGVtSWQocmVjb3JkW2tleV0pKSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnJlQWRkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFkZGVkSXRlbXMucHVzaChpdGVtKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb3ZlZEl0ZW1zLnB1c2goaXRlbSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGF0YS5vbGRJdGVtcy5mb3JFYWNoKChyZWNvcmQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWRhdGEuaXRlbXMuaW5jbHVkZXMocmVjb3JkKSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZWRJdGVtcy5wdXNoKHtpbmRleCwgcmVjb3JkfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgYWRkZWRJdGVtcy5mb3JFYWNoKG9iaiA9PiB7XG4gICAgICAgICAgICBpZiAoIW9iai5yZUFkZGVkKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBtZS5nZXRJdGVtSW5kZXgob2JqLCBtYXAsIGludGVyY2VwdCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBoYXNBZGRlZEl0ZW1zID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICB2ZG9tLmNuLnNwbGljZShpbmRleCwgMCwgbWUuY3JlYXRlSXRlbShtZSwgb2JqLnJlY29yZCwgb2JqLmluZGV4KSk7XG5cbiAgICAgICAgICAgICAgICAgICAgb2JqLml0ZW0gPSB2ZG9tLmNuW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgb2JqLml0ZW0uc3R5bGUub3BhY2l0eSA9IDBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGhhc0FkZGVkSXRlbXMgJiYgb3duZXIudXBkYXRlKCk7XG5cbiAgICAgICAgLy8gZW5zdXJlIHRvIGdldCBpbnRvIHRoZSBuZXh0IGFuaW1hdGlvbiBmcmFtZVxuICAgICAgICBtZS50aW1lb3V0KDUwKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIC8vIG5ldyBpdGVtcyBhcmUgYWxyZWFkeSBhZGRlZCBpbnRvIHRoZSB2ZG9tLCB3aGlsZSBvbGQgaXRlbXMgYXJlIG5vdCB5ZXQgcmVtb3ZlZFxuICAgICAgICAgICAgLy8gPT4gd2UgbmVlZCBhIG1hcCB0byBlbnN1cmUgZ2V0dGluZyB0aGUgY29ycmVjdCBpbmRleFxuICAgICAgICAgICAgbWFwID0gdmRvbS5jbi5tYXAoZSA9PiBlLmlkKTtcblxuICAgICAgICAgICAgYWRkZWRJdGVtcy5mb3JFYWNoKG9iaiA9PiB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBtZS5nZXRJdGVtSW5kZXgob2JqLCBtYXAsIGludGVyY2VwdCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjYW4gY2hhbmdlIHRoZSBvcGFjaXR5IGZvciByZS1hZGRlZCBpdGVtcyB0b28gPT4gdGhlIHZkb20gZW5naW5lIHdpbGwgaWdub3JlIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgdmRvbS5jbltpbmRleF0uc3R5bGUub3BhY2l0eSA9IDFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbW92ZWRJdGVtcy5mb3JFYWNoKG9iaiA9PiB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBtZS5nZXRJdGVtSW5kZXgob2JqLCBtYXAsIHRydWUpOyAvLyBob25vciByZW1vdmVkIGl0ZW1zLCBldmVuIHdpdGhvdXQgaW50ZXJjZXB0aW9uc1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBtZS5nZXRJdGVtUG9zaXRpb24ob2JqLnJlY29yZCwgb2JqLmluZGV4KTtcblxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHZkb20uY25baW5kZXhdLnN0eWxlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5ICA6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHtwb3NpdGlvbi54fXB4LCAke3Bvc2l0aW9uLnl9cHgpYFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZW1vdmVkSXRlbXMuZm9yRWFjaChvYmogPT4ge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gbWUuZ2V0SXRlbUluZGV4KG9iaiwgbWFwLCBpbnRlcmNlcHQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLml0ZW0gPSB2ZG9tLmNuW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgb2JqLml0ZW0uc3R5bGUub3BhY2l0eSA9IDBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgb3duZXIudXBkYXRlKCk7XG4gICAgICAgICAgICBtZS50cmlnZ2VyVHJhbnNpdGlvbkNhbGxiYWNrKClcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGEuaXRlbXNcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLnByZXZpb3VzSXRlbXNcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLlN0b3JlfSBkYXRhLnNjb3BlXG4gICAgICovXG4gICAgb25TdG9yZVNvcnQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChOZW8ubGlzdC5Db21wb25lbnQgJiYgbWUub3duZXIgaW5zdGFuY2VvZiBOZW8ubGlzdC5Db21wb25lbnQpIHtcbiAgICAgICAgICAgIG1lLnNvcnRDb21wb25lbnRMaXN0KGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUuc29ydEJhc2VMaXN0KGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLml0ZW1zXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5wcmV2aW91c0l0ZW1zXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5TdG9yZX0gZGF0YS5zY29wZVxuICAgICAqL1xuICAgIHNvcnRCYXNlTGlzdChkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGhhc0NoYW5nZSAgICAgPSBmYWxzZSxcbiAgICAgICAgICAgIG93bmVyICAgICAgICAgPSBtZS5vd25lcixcbiAgICAgICAgICAgIGtleSAgICAgICAgICAgPSBvd25lci5nZXRLZXlQcm9wZXJ0eSgpLFxuICAgICAgICAgICAgbmV3VmRvbUNuICAgICA9IFtdLFxuICAgICAgICAgICAgcHJldmlvdXNLZXlzICA9IGRhdGEucHJldmlvdXNJdGVtcy5tYXAoZSA9PiBlW2tleV0pLFxuICAgICAgICAgICAgdmRvbSAgICAgICAgICA9IG93bmVyLnZkb20sXG4gICAgICAgICAgICBmcm9tSW5kZXg7XG5cbiAgICAgICAgaWYgKHZkb20uY24ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZGF0YS5pdGVtcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGZyb21JbmRleCA9IHByZXZpb3VzS2V5cy5pbmRleE9mKGl0ZW1ba2V5XSk7XG5cbiAgICAgICAgICAgICAgICBuZXdWZG9tQ24ucHVzaCh2ZG9tLmNuW2Zyb21JbmRleF0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZyb21JbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzQ2hhbmdlID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoaGFzQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgdmRvbS5jbiA9IG5ld1Zkb21DbjtcbiAgICAgICAgICAgICAgICBvd25lci51cGRhdGUoKTtcblxuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gZW5zdXJlIHRvIGdldCB0aGlzIGNhbGwgaW50byB0aGUgbmV4dCBhbmltYXRpb24gZnJhbWVcbiAgICAgICAgICAgICAgICBtZS50aW1lb3V0KDUwKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb3duZXIuY3JlYXRlSXRlbXMoKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGEuaXRlbXNcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLnByZXZpb3VzSXRlbXNcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLlN0b3JlfSBkYXRhLnNjb3BlXG4gICAgICovXG4gICAgc29ydENvbXBvbmVudExpc3QoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIG93bmVyICAgICAgICA9IG1lLm93bmVyLFxuICAgICAgICAgICAga2V5ICAgICAgICAgID0gb3duZXIuZ2V0S2V5UHJvcGVydHkoKSxcbiAgICAgICAgICAgIHByZXZpb3VzS2V5cyA9IGRhdGEucHJldmlvdXNJdGVtcy5tYXAoZSA9PiBlW2tleV0pLFxuICAgICAgICAgICAgdmRvbSAgICAgICAgID0gb3duZXIudmRvbSxcbiAgICAgICAgICAgIGZyb21JbmRleCwgaXRlbSwgcG9zaXRpb247XG5cbiAgICAgICAgb3duZXIuc29ydEl0ZW1zKGRhdGEpO1xuXG4gICAgICAgIHByZXZpb3VzS2V5cyA9IG93bmVyLml0ZW1zLm1hcChlID0+IG93bmVyLmdldEl0ZW1SZWNvcmRJZChlW2tleV0pKTtcblxuICAgICAgICBpZiAodmRvbS5jbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBkYXRhLml0ZW1zLmZvckVhY2goKHJlY29yZCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBmcm9tSW5kZXggPSBwcmV2aW91c0tleXMuaW5kZXhPZihyZWNvcmRba2V5XSk7XG4gICAgICAgICAgICAgICAgaXRlbSAgICAgID0gdmRvbS5jbltmcm9tSW5kZXhdO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uICA9IG1lLmdldEl0ZW1Qb3NpdGlvbihyZWNvcmQsIGluZGV4KTtcblxuICAgICAgICAgICAgICAgIGl0ZW0uc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke3Bvc2l0aW9uLnh9cHgsICR7cG9zaXRpb24ueX1weClgXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgb3duZXIudXBkYXRlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgdHJpZ2dlclRyYW5zaXRpb25DYWxsYmFjaygpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS50cmFuc2l0aW9uVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBtZS50cmFuc2l0aW9uVGltZW91dElkID0gbnVsbDtcblxuICAgICAgICAgICAgbWUub3duZXIuY3JlYXRlSXRlbXMoKVxuICAgICAgICB9LCBtZS50cmFuc2l0aW9uRHVyYXRpb24pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2UgZG8gbm90IHdhbnQgdG8gYXBwbHkgdGhlIHN0eWxlIHRvIGVhY2ggbGlzdCBpdGVtIGl0c2VsZiwgc28gd2UgYXJlIHVzaW5nIE5lby51dGlsLkNzc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGVsZXRlUnVsZT1mYWxzZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVUcmFuc2l0aW9uRGV0YWlscyhkZWxldGVSdWxlPWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBkdXJhdGlvbiA9IG1lLnRyYW5zaXRpb25EdXJhdGlvbixcbiAgICAgICAgICAgIGVhc2luZyAgID0gbWUudHJhbnNpdGlvbkVhc2luZyxcbiAgICAgICAgICAgIHtpZH0gICAgID0gbWUub3duZXI7XG5cbiAgICAgICAgaWYgKGRlbGV0ZVJ1bGUpIHtcbiAgICAgICAgICAgIGF3YWl0IENzc1V0aWwuZGVsZXRlUnVsZXMobWUud2luZG93SWQsIGAjJHtpZH0gLm5lby1saXN0LWl0ZW1gKVxuICAgICAgICB9XG5cbiAgICAgICAgQ3NzVXRpbC5pbnNlcnRSdWxlcyhtZS53aW5kb3dJZCwgW1xuICAgICAgICAgICAgYCMke2lkfSAubmVvLWxpc3QtaXRlbSB7YCxcbiAgICAgICAgICAgICAgICBgdHJhbnNpdGlvbjogb3BhY2l0eSAke2R1cmF0aW9ufW1zICR7ZWFzaW5nfSwgdHJhbnNmb3JtICR7ZHVyYXRpb259bXMgJHtlYXNpbmd9YCxcbiAgICAgICAgICAgICd9J1xuICAgICAgICBdLmpvaW4oJycpKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQW5pbWF0ZSk7XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBwbHVnaW4gaW1wbGVtZW50YXRpb25zLlxuICogUGx1Z2lucyBhcmUgaW50ZW5kZWQgdG8gZ2V0IHB1dCBpbnRvIHRoZSBwbHVnaW5zIGNvbmZpZyBvZiBjb21wb25lbnQuQmFzZVxuICogdG8gZW5oYW5jZSB0aGVtIG9yIGFkZCBhZGRpdGlvbmFsIGZlYXR1cmVzXG4gKiBAY2xhc3MgTmVvLnBsdWdpbi5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIFBsdWdpbiBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnBsdWdpbi5CYXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ucGx1Z2luLkJhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQWxsIHBsdWdpbiBudHlwZXMgbmVlZCB0byBzdGFydCB3aXRoICdwbHVnaW4tJyB0byBlbnN1cmUgdGhhdCBjb21wb25lbnQuQmFzZTogZ2V0UGx1Z2luKCkgY2FuIGZpbmQgdGhlbVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdwbHVnaW4nXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAncGx1Z2luJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb21wb25lbnQuQmFzZX0gb3duZXI9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBvd25lcjogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSB3aW5kb3dJZF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgd2luZG93SWRfOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge293bmVyfSA9IG1lO1xuXG4gICAgICAgIGlmIChvd25lci5pc0NvbnN0cnVjdGVkKSB7XG4gICAgICAgICAgICBtZS5vbk93bmVyQ29uc3RydWN0ZWQoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3duZXIub24oJ2NvbnN0cnVjdGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1lLm9uT3duZXJDb25zdHJ1Y3RlZCgpXG4gICAgICAgICAgICB9LCBtZSwge29uY2U6IHRydWV9KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG93bmVyLm1vdW50ZWQpIHtcbiAgICAgICAgICAgIG1lLm9uT3duZXJNb3VudGVkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvd25lci5vbignbW91bnRlZCcsIG1lLm9uT3duZXJNb3VudGVkLCBtZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHdpbmRvd0lkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRXaW5kb3dJZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdmFsdWUgJiYgTmVvLmN1cnJlbnRXb3JrZXIuaW5zZXJ0VGhlbWVGaWxlcyh2YWx1ZSwgdGhpcy5fX3Byb3RvX18pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gYXBwbHkgY2hhbmdlcyB0byB0aGUgb3duZXIgQ29tcG9uZW50IHdoZW4gaXQgaXMgY29uc3RydWN0ZWRcbiAgICAgKi9cbiAgICBvbk93bmVyQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIGxldCB7b3duZXJ9ID0gdGhpcztcblxuICAgICAgICBpZiAob3duZXIud2luZG93SWQpIHtcbiAgICAgICAgICAgIHRoaXMud2luZG93SWQgPSBvd25lci53aW5kb3dJZFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gYXBwbHkgY2hhbmdlcyB0byB0aGUgb3duZXIgQ29tcG9uZW50IHdoZW4gaXQgZG9lcyBnZXQgbW91bnRlZFxuICAgICAqL1xuICAgIG9uT3duZXJNb3VudGVkKCkge1xuXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhQbHVnaW4pO1xuIiwiaW1wb3J0IEJhc2UgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby51dGlsLkNzc1xuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBDc3MgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby51dGlsLkNzcydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnV0aWwuQ3NzJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhc3MgdGhlIHNlbGVjdG9yVGV4dCBvZiB0aGUgcnVsZXMgd2hpY2ggeW91IHdhbnQgdG8gcmVtb3ZlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpbmRvd0lkXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXXxTdHJpbmd9IHJ1bGVzXG4gICAgICovXG4gICAgc3RhdGljIGRlbGV0ZVJ1bGVzKHdpbmRvd0lkLCBydWxlcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocnVsZXMpKSB7XG4gICAgICAgICAgICBydWxlcyA9IFtydWxlc11cbiAgICAgICAgfVxuXG4gICAgICAgIE5lby5tYWluLmFkZG9uLlN0eWxlc2hlZXQuZGVsZXRlQ3NzUnVsZXMoe3J1bGVzLCB3aW5kb3dJZH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpbmRvd0lkXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXXxTdHJpbmd9IHJ1bGVzXG4gICAgICovXG4gICAgc3RhdGljIGluc2VydFJ1bGVzKHdpbmRvd0lkLCBydWxlcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocnVsZXMpKSB7XG4gICAgICAgICAgICBydWxlcyA9IFtydWxlc11cbiAgICAgICAgfVxuXG4gICAgICAgIE5lby5tYWluLmFkZG9uLlN0eWxlc2hlZXQuaW5zZXJ0Q3NzUnVsZXMoe3J1bGVzLCB3aW5kb3dJZH0pXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhDc3MpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9