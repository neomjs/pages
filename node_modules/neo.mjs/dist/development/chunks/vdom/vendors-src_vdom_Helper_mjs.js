"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_vdom_Helper_mjs"],{

/***/ "./src/util/String.mjs"
/*!*****************************!*\
  !*** ./src/util/String.mjs ***!
  \*****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.util.String
 * @extends Neo.core.Base
 */
class StringUtil extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @member {Object} charEntityMap
     * @static
     */
    static charEntityMap = {
        '&' : '&amp;',
        '<' : '&lt;',
        '>' : '&gt;',
        '"' : '&quot;',
        '\'': '&apos;',
        '$' : '&dollar;',
        '\\': '&bsol;',
        '/' : '&sol;'
    }
    /**
     * @member {RegExp} charPattern
     * @static
     */
    static charPattern = /[&<>"'$\\]/g
    /**
     * @member {RegExp} entityPattern
     * @static
     */
    static entityPattern = /(&amp;)|(&lt;)|(&gt;)|(&quot;)|(&apos;)|(&dollar;)|(&bsol;)|(&sol;)/g

    static config = {
        /**
         * @member {String} className='Neo.util.String'
         * @protected
         */
        className: 'Neo.util.String'
    }

    /**
     * Escape HTML special characters
     * @param {String} value
     */
    static escapeHtml(value) {
        let me = this; // inside a static method, we are pointing to the class prototype

        if (!Neo.isString(value)) {
            return value
        }

        return value.replace(me.charPattern, me.getEntityFromChar.bind(me))
    }

    /**
     * Get char equivalent of a mapped entity
     * @param {String} entity
     */
    static getCharFromEntity(entity) {
        let mappedChar = Object.keys(this.charEntityMap).find(key => this.charEntityMap[key] === entity);
        return mappedChar || entity
    }

    /**
     * Get entity equivalent of a mapped char
     * @param {String} char
     */
    static getEntityFromChar(char) {
        return this.charEntityMap[char] || char
    }

    /**
     * Unescape HTML special characters
     * @param {String} value
     */
    static unescapeHtml(value) {
        let me = this; // inside a static method, we are pointing to the class prototype

        if (!Neo.isString(value)) {
            return value
        }

        return value.replace(me.entityPattern, me.getCharFromEntity.bind(me))
    }

    /**
     * Returns the passed string with the first letter uncapitalized.
     * @param {String} value
     * @returns  {String}
     */
    static uncapitalize(value) {
        return value && value[0].toLowerCase() + value.substring(1)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(StringUtil));


/***/ },

/***/ "./src/util/Style.mjs"
/*!****************************!*\
  !*** ./src/util/Style.mjs ***!
  \****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.util.Style
 * @extends Neo.core.Base
 */
class Style extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.Style'
         * @protected
         */
        className: 'Neo.util.Style'
    }

    /**
     * Creates an delta object, containing the styles of newStyle which are not included or different than in oldStyle
     * Styles included in oldStyle but missing in newStyle will get a value of null
     * see: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style
     * @param {Object|String} newStyle
     * @param {Object|String} oldStyle
     * @returns {Object} style delta
     */
    static compareStyles(newStyle, oldStyle) {
        let styles = {};

        if (Neo.isString(newStyle)) {
            newStyle = Neo.createStyleObject(newStyle)
        }

        if (Neo.isString(oldStyle)) {
            oldStyle = Neo.createStyleObject(oldStyle)
        }

        if (!newStyle && !oldStyle) {
            return null
        } else if (!oldStyle) {
            return Neo.clone(newStyle)
        } else {
            newStyle && Object.keys(newStyle).forEach(style => {
                if (!oldStyle.hasOwnProperty(style) || oldStyle[style] !== newStyle[style]) {
                    styles[style] = newStyle[style]
                }
            });

            Object.keys(oldStyle).forEach(style => {
                if (!newStyle  || !newStyle.hasOwnProperty(style)) {
                    styles[style] = null
                }
            });

            if (Object.keys(styles).length > 0) {
                return styles
            }

            return null
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Style));


/***/ },

/***/ "./src/vdom/Helper.mjs"
/*!*****************************!*\
  !*** ./src/vdom/Helper.mjs ***!
  \*****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_Style_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Style.mjs */ "./src/util/Style.mjs");
/* harmony import */ var _domConstants_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./domConstants.mjs */ "./src/vdom/domConstants.mjs");
/* harmony import */ var _VNode_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./VNode.mjs */ "./src/vdom/VNode.mjs");






const NeoConfig = Neo.config;

/**
 * The central class for the VDom worker to create vnodes & delta updates.
 * @class Neo.vdom.Helper
 * @extends Neo.core.Base
 * @singleton
 */
class Helper extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.vdom.Helper'
         * @protected
         */
        className: 'Neo.vdom.Helper',
        /**
         * Remote method access for other workers
         * @member {Object} remote={app:['create','update']}
         * @protected
         * @reactive
         */
        remote: {
            app: [
                'create',
                'update'
            ]
        },
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * @param {Object}         config
     * @param {Object}         config.deltas
     * @param {Neo.vdom.VNode} config.oldVnode
     * @param {Neo.vdom.VNode} config.vnode
     * @param {Map}            config.vnodeMap
     * @returns {Object} deltas
     * @protected
     */
    compareAttributes({deltas, oldVnode, vnode, vnodeMap}) {
        // If either vnode is a component placeholder (indicated by the presence of componentId),
        // we must not compare element attributes.
        if (vnode.componentId || oldVnode.componentId) {
            return deltas;
        }

        // Fragments are "transparent" containers. They do not have physical DOM attributes or styles.
        // Therefore, we skip attribute comparison entirely.
        if (vnode.nodeName === 'fragment') {
            return deltas
        }

        let delta = {},
            attributes, value, keys, styles, add, remove;

        if (vnode.vtype === 'text' && vnode.textContent !== oldVnode.textContent) {
            deltas.default.push({
                action  : 'updateVtext',
                id      : vnode.id,
                parentId: vnodeMap.get(vnode.id).parentNode.id,
                value   : vnode.textContent
            })
        } else {
            keys = Object.keys(vnode);

            Object.keys(oldVnode).forEach(prop => {
                if (!Object.hasOwn(vnode, prop)) {
                    keys.push(prop)
                } else if (prop === 'attributes') { // Find removed attributes
                    Object.keys(oldVnode[prop]).forEach(attr => {
                        if (!Object.hasOwn(vnode[prop], attr)) {
                            vnode[prop][attr] = null
                        }
                    })
                }
            });

            keys.forEach(prop => {
                value = vnode[prop];

                switch (prop) {
                    case 'attributes':
                        attributes = {};

                        Object.entries(value).forEach(([key, value]) => {
                            const
                                oldValue    = oldVnode.attributes[key],
                                hasOldValue = Object.hasOwn(oldVnode.attributes, key);

                            // If the attribute has an old value AND the value hasn't changed, skip.
                            if (hasOldValue && oldValue === value) {
                                return
                            }

                            // If the current value is null, or it's a non-string empty value (e.g., [], {}), skip.
                            // Note: An empty string ('') is a valid value and should NOT be skipped here.
                            if (value !== null && !Neo.isString(value) && Neo.isEmpty(value)) {
                                return
                            }

                            attributes[key] = value
                        });

                        if (Object.keys(attributes).length > 0) {
                            delta.attributes = attributes;

                            Object.entries(attributes).forEach(([key, value]) => {
                                if (value === null || value === '') {
                                    delete vnode.attributes[key]
                                }
                            })
                        }
                        break
                    case 'nodeName':
                    case 'innerHTML':
                    case 'scrollLeft':
                    case 'scrollTop':
                    case 'textContent':
                        if (value !== oldVnode[prop]) {
                            delta[prop] = value
                        }
                        break
                    case 'style':
                        styles = _util_Style_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].compareStyles(value, oldVnode.style);
                        if (styles) {
                            delta.style = styles
                        }
                        break
                    case 'className':
                        if (oldVnode.className) {
                            add    = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].difference(value, oldVnode.className);
                            remove = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].difference(oldVnode.className, value)
                        } else {
                            add    =  value;
                            remove = []
                        }

                        if (add.length > 0 || remove.length > 0) {
                            delta.cls = {};

                            if (add   .length > 0) {delta.cls.add    = add}
                            if (remove.length > 0) {delta.cls.remove = remove}
                        }
                        break
                }
            });

            if (Object.keys(delta).length > 0) {
                delta.id = vnode.id;
                deltas.default.push(delta)
            }
        }

        return deltas
    }

    /**
     * Creates a Neo.vdom.VNode tree for the given vdom template.
     * The top level vnode contains the outerHTML as a string,
     * in case Neo.config.useDomApiRenderer === false
     * @param {Object} opts
     * @param {String} opts.appName
     * @param {Boolean} [opts.autoMount]
     * @param {String} opts.parentId
     * @param {Number} opts.parentIndex
     * @param {Object} opts.vdom
     * @param {Number} opts.windowId
     * @returns {Object}
     */
    create(opts) {
        let me               = this,
            {util}           = Neo.vdom,
            postMountUpdates = [],
            returnValue, vnode;

        vnode       = me.createVnode(opts.vdom);
        returnValue = {...opts, vnode};

        delete returnValue.vdom;

        if (!NeoConfig.useDomApiRenderer) {
            if (!util.StringFromVnode) {
                throw new Error('VDom Helper render utilities are not loaded yet!')
            }

            returnValue.outerHTML = util.StringFromVnode.create(vnode, null, postMountUpdates);

            if (postMountUpdates.length > 0) {
                returnValue.postMountUpdates = postMountUpdates
            }
        }

        return returnValue
    }

    /**
     * @param {Object}                config
     * @param {Object}                [config.deltas={default: [], remove: []}]
     * @param {Neo.vdom.VNode|Object} config.oldVnode
     * @param {Map}                   [config.oldVnodeMap]
     * @param {Neo.vdom.VNode|Object} config.vnode
     * @param {Map}                   [config.vnodeMap]
     * @returns {Object} deltas
     * @protected
     */
    createDeltas(config) {
        let {deltas={default: [], remove: []}, oldVnode, vnode} = config,
            vnodeId = vnode?.id;

        // Edge case: setting `removeDom: true` on a top-level vdom node
        if (!vnode && (oldVnode?.id || oldVnode?.componentId)) {
            deltas.remove.push({action: 'removeNode', id: oldVnode.id || oldVnode.componentId});
            return deltas
        }

        if (vnode.static) {
            return deltas
        }

        // The top-level nodes passed to createDeltas must be the same logical node. The VdomLifecycle
        // mixin ensures symmetric trees, so IDs and types (component vs element) must match.
        if (vnode.id !== oldVnode.id || vnode.componentId !== oldVnode.componentId) {
            throw new Error(`createDeltas() must be called for the same node. new: {id: ${vnode.id}, cId: ${vnode.componentId}}, old: {id: ${oldVnode.id}, cId: ${oldVnode.componentId}}`);
        }

        let me            = this,
            oldVnodeMap   = config.oldVnodeMap  || me.createVnodeMap({vnode: oldVnode}),
            vnodeMap      = config.vnodeMap     || me.createVnodeMap({vnode}),
            childNodes    = vnode   .childNodes || [],
            oldChildNodes = oldVnode.childNodes || [],
            i             = 0,
            indexDelta    = 0,
            insertDelta   = 0,
            len           = Math.max(childNodes.length, oldChildNodes.length),
            childNode, nodeInNewTree, oldChildNode, oldChildNodeId;

        me.compareAttributes({deltas, oldVnode, vnode, vnodeMap});

        if (childNodes.length === 0 && oldChildNodes.length > 1) {
            deltas.remove.push({action: 'removeAll', parentId: vnodeId});
            return deltas
        }

        for (; i < len; i++) {
            childNode    = childNodes[i];
            oldChildNode = oldChildNodes[i + indexDelta];

            if (!childNode && !oldChildNode) {
                break
            }

            // A "match" requires nodes to be of the same type (placeholder or element) and have
            // the same identifier. The VdomLifecycle mixin ensures that both the old (vnode)
            // and new (vdom) trees are expanded to the same symmetric depth before diffing.
            if (childNode && oldChildNode && (
                // Case 1: Both nodes are elements with the same ID
                (!childNode.componentId && !oldChildNode.componentId && childNode.id === oldChildNode.id) ||
                // Case 2: Both nodes are placeholders for the same component
                (childNode.componentId && childNode.componentId === oldChildNode.componentId)
            )) {
                if (childNode.neoIgnore) {
                    delete childNode.neoIgnore;
                    continue
                }

                me.createDeltas({deltas, oldVnode: oldChildNode, oldVnodeMap, vnode: childNode, vnodeMap});
                continue
            }

            if (oldChildNode) {
                oldChildNodeId = oldChildNode.id || oldChildNode.componentId;
                nodeInNewTree  = vnodeMap.get(oldChildNodeId);

                // Remove node, if no longer inside the new tree
                if (!nodeInNewTree) {
                    me.removeNode({deltas, oldVnode: oldChildNode, oldVnodeMap});
                    i--;
                    insertDelta++;
                    continue
                }

                // The old child node got moved into a different not processed array. It will get picked up there.
                if (childNode && vnodeId !== nodeInNewTree.parentNode.id) {
                    i--;
                    indexDelta++;
                    continue
                }
            }

            if (childNode) {
                if (me.isMovedNode(childNode, oldVnodeMap)) {
                    me.moveNode({deltas, insertDelta, oldVnodeMap, vnode: childNode, vnodeMap})
                } else {
                    me.insertNode({deltas, index: i + insertDelta, oldVnodeMap, vnode: childNode, vnodeMap})
                }

                if (oldChildNode && vnodeId === vnodeMap.get(oldChildNodeId)?.parentNode.id) {
                    len++
                }
            }
        }

        return deltas
    }

    /**
     * @param {Object} opts
     * @returns {Object|Neo.vdom.VNode|null}
     * @protected
     */
    createVnode(opts) {
        // do not create vnode instances for component reference objects
        if (opts.componentId) {
            opts.childNodes ??= []; // Consistency: Every VNode has a childNodes array
            opts.id         ??= opts.componentId

            return opts
        }

        if (opts.removeDom === true) {
            return null
        }

        let me   = this,
            node = {attributes: {}, style: {}},
            potentialNode;

        Object.entries(opts).forEach(([key, value]) => {
            if (value !== undefined && value !== null && key !== 'flag' && key !== 'removeDom') {
                let hasUnit, newValue, style;

                switch (key) {
                    case 'tag':
                        node.nodeName = value;
                        break
                    case 'cls':
                        node.className = value;
                        break
                    case 'html':
                        node.innerHTML = value.toString(); // support for numbers
                        break
                    case 'text':
                        node.textContent = value
                        break
                    case 'cn':
                        if (!Array.isArray(value)) {
                            value = [value]
                        }

                        newValue = [];

                        value.filter(Boolean).forEach(item => {
                            if (item.removeDom !== true) {
                                delete item.removeDom; // could be false
                                potentialNode = me.createVnode(item);

                                if (potentialNode) { // don't add null values
                                    newValue.push(potentialNode)
                                }
                            }
                        });

                        node.childNodes = newValue;
                        break

                    case 'data':
                        if (value && Neo.typeOf(value) === 'Object') {
                            Object.entries(value).forEach(([key, val]) => {
                                node.attributes[`data-${Neo.decamel(key)}`] = val
                            })
                        }
                        break;
                    case 'height':
                    case 'maxHeight':
                    case 'maxWidth':
                    case 'minHeight':
                    case 'minWidth':
                    case 'width':
                        if (_domConstants_mjs__WEBPACK_IMPORTED_MODULE_3__.rawDimensionTags.has(node.nodeName)) {
                            node.attributes[key] = value + ''
                        } else {
                            hasUnit = value != parseInt(value);
                            node.style[key] = value + (hasUnit ? '' : 'px')
                        }
                        break
                    case 'componentId':
                    case 'id':
                    case 'scrollLeft':
                    case 'scrollTop':
                    case 'static':
                    case 'vtype':
                        node[key] = value;
                        break
                    case 'style':
                        style = node.style;
                        if (Neo.isString(value)) {
                            node.style = Object.assign(style, Neo.core.Util.createStyleObject(value))
                        } else {
                            node.style = Object.assign(style, value)
                        }
                        break
                    default:
                        node.attributes[key] = value + '';
                        break
                }
            }
        });

        // Relevant for vtype='text'
        if (Object.keys(node.attributes).length < 1) {
            delete node.attributes
        }

        // Relevant for vtype='text'
        if (Object.keys(node.style).length < 1) {
            delete node.style
        }

        return new _VNode_mjs__WEBPACK_IMPORTED_MODULE_4__["default"](node)
    }

    /**
     * Creates a flat map of the tree, containing ids as keys and infos as values
     * @param {Object}         config
     * @param {Number}         [config.index=0]
     * @param {Map}            [config.map=new Map()]
     * @param {Neo.vdom.VNode} [config.parentNode=null]
     * @param {Neo.vdom.VNode} config.vnode
     * @returns {Map}
     *     {String}         id vnode.id (convenience shortcut)
     *     {Number}         index
     *     {String}         parentId
     *     {Neo.vdom.VNode} vnode
     * @protected
     */
    createVnodeMap({index=0, map=new Map(), parentNode=null, vnode}) {
        if (vnode) {
            let id = vnode.id || vnode.componentId;

            map.set(id, {id, index, parentNode, vnode});

            vnode.childNodes?.forEach((childNode, index) => {
                this.createVnodeMap({index, map, parentNode: vnode, vnode: childNode})
            })
        }

        return map
    }

    /**
     * The logic will parse the vnode (tree) to find existing items inside a given map.
     * It will not search for further childNodes inside an already found vnode.
     * @param {Object}         config
     * @param {Map}            [config.movedNodes=new Map()]
     * @param {Map}            config.oldVnodeMap
     * @param {Neo.vdom.VNode} config.vnode
     * @param {Map}            config.vnodeMap
     * @returns {Map}
     * @protected
     */
    findMovedNodes({movedNodes=new Map(), oldVnodeMap, vnode, vnodeMap}) {
        let id = vnode?.id;

        if (id) {
            if (this.isMovedNode(vnode, oldVnodeMap)) {
                movedNodes.set(id, vnodeMap.get(id))
            } else {
                vnode.childNodes?.forEach(childNode => {
                    if (childNode.vtype !== 'text') {
                        this.findMovedNodes({movedNodes, oldVnodeMap, vnode: childNode, vnodeMap})
                    }
                })
            }
        }

        return movedNodes
    }

    /**
     * Recursive helper to count the physical nodes a fragment expands to.
     *
     * **Formula:** `2 (Start/End Anchors) + Sum(Child Physical Counts)`
     *
     * This method is essential for converting a "Logical Index" (where the fragment is 1 item)
     * into a "Physical Index" (where the fragment is a range of N DOM nodes).
     *
     * @param {Neo.vdom.VNode} fragmentNode
     * @returns {Number}
     */
    getFragmentPhysicalCount(fragmentNode) {
        let count = 2; // Start + End anchors

        fragmentNode.childNodes?.forEach(child => {
            if (child.vtype === 'text') {
                count += 3
            } else if (child.nodeName === 'fragment') {
                count += this.getFragmentPhysicalCount(child)
            } else {
                count += 1
            }
        });

        return count
    }

    /**
     * Calculates the physical DOM index for a given logical child index.
     *
     * **The "Physical vs. Logical" Problem:**
     * In the VDOM, a child list is simple: `[Div, Fragment, Span]`.
     * In the real DOM, this expands to: `div`, `<!--frag-start-->`, `p`, `<!--frag-end-->`, `span`.
     *
     * This method iterates through the preceding siblings and sums up their "Physical Count":
     * - Standard Element: 1
     * - Text Node: 3 (`<!--text-->` + text + `<!--/text-->`)
     * - Fragment: N (`2 + children`)
     *
     * @param {Neo.vdom.VNode} parentNode
     * @param {Number}         logicalIndex
     * @returns {Number}
     */
    getPhysicalIndex(parentNode, logicalIndex) {
        let physicalIndex = logicalIndex,
            i             = 0,
            child;

        for (; i < logicalIndex; i++) {
            child = parentNode.childNodes[i];

            if (child) {
                if (child.vtype === 'text') {
                    physicalIndex += 2 // Accounts for <!--neo-vtext--> wrappers
                } else if (child.nodeName === 'fragment') {
                    physicalIndex += (this.getFragmentPhysicalCount(child) - 1)
                }
            }
        }

        return physicalIndex
    }

    /**
     * Imports either (if not already imported):
     * `Neo.vdom.util.DomApiVnodeCreator` if Neo.config.useDomApiRenderer === true
     * `Neo.vdom.util.StringFromVnode`    if Neo.config.useDomApiRenderer === false
     * @returns {Promise<void>}
     * @protected
     */
    async importUtil() {
        const {util} = Neo.vdom;

        if (NeoConfig.useDomApiRenderer) {
            if (!util?.DomApiVnodeCreator) {
                await __webpack_require__.e(/*! import() */ "src_vdom_util_DomApiVnodeCreator_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./util/DomApiVnodeCreator.mjs */ "./src/vdom/util/DomApiVnodeCreator.mjs"))
            }
        } else {
            if (!util?.StringFromVnode) {
                await __webpack_require__.e(/*! import() */ "src_vdom_util_StringFromVnode_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./util/StringFromVnode.mjs */ "./src/vdom/util/StringFromVnode.mjs"))
            }
        }
    }

    /**
     * @returns {Promise<void>}
     */
    async initAsync() {
        super.initAsync();

        let me = this;

        // Subscribe to global Neo.config changes for dynamic renderer switching.
        Neo.currentWorker?.on({
            neoConfigChange: me.onNeoConfigChange,
            scope          : me
        });

        await me.importUtil()
    }

    /**
     * @param {Object}         config
     * @param {Object}         config.deltas
     * @param {Number}         config.index
     * @param {Map}            config.oldVnodeMap
     * @param {Neo.vdom.VNode} config.vnode
     * @param {Map}            config.vnodeMap
     * @protected
     */
    insertNode({deltas, index, oldVnodeMap, vnode, vnodeMap}) {
        let details      = vnodeMap.get(vnode.id),
            {parentNode} = details,
            parentId     = parentNode.id,
            me           = this,
            movedNodes   = me.findMovedNodes({oldVnodeMap, vnode, vnodeMap}),
            delta        = {action: 'insertNode', parentId};

        // Processes the children of the *NEW* parent's VNode in the *current* state
        delta.index = me.getPhysicalIndex(parentNode, index);

        if (NeoConfig.useDomApiRenderer) {
            // For direct DOM API mounting, pass the pruned VNode tree
            delta.vnode = Neo.vdom.util.DomApiVnodeCreator.create(vnode, movedNodes)
        } else {
            let postMountUpdates = [];

            // For string-based mounting, pass a string excluding moved nodes
            delta.outerHTML = Neo.vdom.util.StringFromVnode.create(vnode, movedNodes, postMountUpdates);

            if (postMountUpdates.length > 0) {
                delta.postMountUpdates = postMountUpdates
            }
        }

        deltas.default.push(delta);

        // Insert the new node into the old tree, to simplify future OPs
        oldVnodeMap.get(parentId).vnode.childNodes.splice(index, 0, vnode);

        movedNodes.forEach(details => {
            let {id}     = details,
                parentId = details.parentNode.id;

            deltas.default.push({action: 'moveNode', id, index: details.index, parentId});

            me.createDeltas({deltas, oldVnode: oldVnodeMap.get(id).vnode, oldVnodeMap, vnode: details.vnode, vnodeMap})
        })
    }

    /**
     *
     * @param {Neo.vdom.VNode} vnode
     * @param {Map} oldVnodeMap
     * @returns {Boolean}
     * @protected
     */
    isMovedNode(vnode, oldVnodeMap) {
        let oldVnode = oldVnodeMap.get(vnode.id);

        return oldVnode && (
            !oldVnode.vnode.componentId ||                   // the old vnode is not a reference
            vnode.componentId === oldVnode.vnode.componentId // old & new nodes are the same references
        )
    }

    /**
     * @param {Object}         config
     * @param {Object}         config.deltas
     * @param {Number}         config.insertDelta
     * @param {Map}            config.oldVnodeMap
     * @param {Neo.vdom.VNode} config.vnode
     * @param {Map}            config.vnodeMap
     * @protected
     */
    moveNode({deltas, insertDelta, oldVnodeMap, vnode, vnodeMap}) {
        let details             = vnodeMap.get(vnode.id),
            {index, parentNode} = details,
            parentId            = parentNode.id,
            movedNode           = oldVnodeMap.get(vnode.id),
            movedParentNode     = movedNode.parentNode,
            {childNodes}        = movedParentNode,
            delta               = {action: 'moveNode', id: vnode.id, parentId},
            physicalIndex       = this.getPhysicalIndex(parentNode, index); // Processes the children of the *NEW* parent's VNode in the *current* state (parentNode.childNodes)

        Object.assign(delta, {index: physicalIndex + insertDelta});
        deltas.default.push(delta);

        // This block implements the "corrupting the old tree" optimization for performance.
        // It pre-modifies the old VNode map to reflect the move, preventing redundant deltas later.
        if (parentId !== movedParentNode.id) {
            // We need to remove the node from the old parent childNodes
            // (which must not be the same as the node they got moved into)
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(childNodes, movedNode.vnode);

            // Get the VNode representing the *new parent* from the 'old VNode map'.
            // This is crucial: 'oldParentNode' here is the *old state's VNode for the new parent*.
            let oldParentNode = oldVnodeMap.get(parentId);

            if (oldParentNode) {
                // If moved into a new parent node, update the reference inside the flat map
                movedNode.parentNode = oldParentNode.vnode;

                // Reassign 'childNodes' property to now point to the 'childNodes' array
                // of this 'old state's VNode for the new parent'.
                childNodes = movedNode.parentNode.childNodes
            }
        }

        // Add the node into the old vnode tree to simplify future OPs.
        // NeoArray.insert() will switch to move() in case the node already exists.
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].insert(childNodes, index, movedNode.vnode);

        this.createDeltas({deltas, oldVnode: movedNode.vnode, oldVnodeMap, vnode, vnodeMap})
    }

    /**
     * Handler for global Neo.config changes.
     * If the `Neo.config.useDomApiRenderer` value changes, this method dynamically loads the renderer utilities.
     * @param {Object} config
     * @return {Promise<void>}
     */
    async onNeoConfigChange(config) {
        if (Object.hasOwn(config, 'useDomApiRenderer')) {
            await this.importUtil()
        }
    }

    /**
     * @param {Object}         config
     * @param {Object}         config.deltas
     * @param {Neo.vdom.VNode} config.oldVnode
     * @param {Map}            config.oldVnodeMap
     * @protected
     */
    removeNode({deltas, oldVnode, oldVnodeMap}) {
        if (oldVnode.componentId) {
            oldVnode.id ??= oldVnode.componentId
        }

        let delta        = {action: 'removeNode', id: oldVnode.id},
            {parentNode} = oldVnodeMap.get(oldVnode.id);

        if (oldVnode.vtype === 'text' || oldVnode.nodeName === 'fragment') {
            delta.parentId = parentNode.id
        }

        deltas.remove.push(delta);

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(parentNode.childNodes, oldVnode)
    }

    /**
     * Creates a Neo.vdom.VNode tree for the given vdom template and compares the new vnode with the current one
     * to calculate the vdom deltas.
     * @param {Object} opts
     * @param {Object} opts.vdom
     * @param {Object} opts.vnode
     * @returns {Object}
     */
    update(opts) {
        let me     = this,
            {util} = Neo.vdom,
            deltas, vnode;

        if (NeoConfig.useDomApiRenderer) {
            if (!util.DomApiVnodeCreator) {
                throw new Error('Neo.vdom.Helper: DomApiVnodeCreator is not loaded yet for updates!')
            }
        } else {
            if (!util.StringFromVnode) {
                throw new Error('Neo.vdom.Helper: StringFromVnode is not loaded yet for updates!');
            }
        }

        vnode  = me.createVnode(opts.vdom);
        deltas = me.createDeltas({oldVnode: opts.vnode, vnode});

        // Trees to remove could contain nodes which we want to re-use (move),
        // so we need to execute the removeNode OPs last.
        deltas = deltas.default.concat(deltas.remove);

        return {deltas, updateVdom: true, vnode}
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Helper));


/***/ },

/***/ "./src/vdom/VNode.mjs"
/*!****************************!*\
  !*** ./src/vdom/VNode.mjs ***!
  \****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_String_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/String.mjs */ "./src/util/String.mjs");


/**
 * Wrapper class for vnode objects.
 * For convenience, a VNode instance will always contain a childNodes array, which can be empty.
 * A VNode can optionally have `innerHTML` xor `textContent`
 * `textContent` is better from a XSS security perspective.
 * If by accident both are set, `innerHTML` will get the priority.
 *
 * @class Neo.vdom.VNode
 */
class VNode {
    /**
     * @param {Object} config
     */
    constructor(config) {
        /**
         * Not set for vtype='text' nodes
         * @member {Object} attributes={}
         */

        /**
         * @member {Array} childNodes=[]
         */

        /**
         * Not set for vtype='text' nodes
         * @member {Array} className=[]
         */

        /**
         * @member {String} id=Neo.getId('vnode')
         */

        /**
         * @member {String} innerHTML
         */

        /**
         * @member {String} nodeName
         */

        /**
         * true excludes the node from delta-updates
         * @member {Boolean} static
         */

        /**
         * Not set for vtype='text' nodes
         * @member {Object} style
         */

        /**
         * @member {Number} scrollLeft
         */

        /**
         * @member {Number} scrollTop
         */

        /**
         * @member {String} textContent
         */

        /**
         * Valid values are "root", "text" & "vnode"
         * @member {String} vtype='vnode'
         */

        let me            = this,
            {textContent} = config,
            hasInnerHtml  = Object.hasOwn(config, 'innerHTML'),
            isVText       = config.vtype === 'text';

        Object.assign(me, {
            childNodes: config.childNodes || [],
            id        : config.id         || Neo.getId(isVText ? 'vtext' : 'vnode'),
            vtype     : config.vtype      || 'vnode'
        });

        if (isVText) {
            // A vtext node represents a pure text node. It should not be created from an innerHTML property.
            // For XSS Security, we escape the content when using the string-based renderer.
            me.textContent = Neo.config.useDomApiRenderer ? textContent : _util_String_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].escapeHtml(textContent);
        } else {
            Object.assign(me, {
                attributes: config.attributes || {},
                className : normalizeClassName(config.className),
                nodeName  : config.nodeName   || 'div',
                scrollLeft: config.scrollLeft,
                scrollTop : config.scrollTop,
                style     : config.style      || {}
            });

            // Use vdom.html on your own risk, it is not fully XSS secure.
            if (hasInnerHtml) {
                me.innerHTML = config.innerHTML
            }

            // We only apply textContent, in case it has content
            else if (Object.hasOwn(config, 'textContent')) {
                me.textContent = Neo.config.useDomApiRenderer ? textContent : _util_String_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].escapeHtml(textContent)
            }
        }

        // We only apply the static attribute, in case the value is true
        if (config.static) {
            me.static = true
        }
    }
}

/**
 * vdom cls definitions might contain spaces, especially when it comes to iconCls.
 * @example: myVdom = {cls: ['my-button', 'fa fa-user']}
 *
 * On DOM level, classList.add() will throw, in case it gets an input containing a space.
 *
 * This is a module-scoped utility function, not a method of the VNode class.
 * VNodes are transferred via structured cloning (e.g., in postMessage()), which strips methods.
 * Keeping this logic separate from the VNode class itself ensures conceptual purity and a cleaner data model,
 * as methods defined on the VNode instance would be lost during transfer anyway.
 *
 * @param {String|String[]} classNameInput
 * @returns {String[]}
 * @private
 */
function normalizeClassName(classNameInput) {
    let normalizedClasses = [];

    if (Neo.isString(classNameInput)) {
        normalizedClasses = classNameInput.split(' ').filter(Boolean)
    } else if (Array.isArray(classNameInput)) {
        classNameInput.forEach(cls => {
            if (Neo.isString(cls)) {
                if (cls.includes(' ')) {
                    normalizedClasses.push(...cls.split(' ').filter(Boolean))
                } else if (cls !== '') {
                    normalizedClasses.push(cls)
                }
            }
        })
    }

    // Remove duplicates if necessary
    return [...new Set(normalizedClasses)]
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.gatekeep(VNode, 'Neo.vdom.VNode'));


/***/ },

/***/ "./src/vdom/domConstants.mjs"
/*!***********************************!*\
  !*** ./src/vdom/domConstants.mjs ***!
  \***********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   rawDimensionTags: () => (/* binding */ rawDimensionTags),
/* harmony export */   voidAttributes: () => (/* binding */ voidAttributes),
/* harmony export */   voidElements: () => (/* binding */ voidElements)
/* harmony export */ });
/**
 * The following top-level attributes will get converted into styles:
 * height, maxHeight, maxWidth, minHeight, minWidth, width
 *
 * Some tags must not do the transformation, so we add them here.
 * @member {Set} rawDimensionTags
 */
const rawDimensionTags = new Set([
    'circle',
    'clipPath',
    'ellipse',
    'filter',
    'foreignObject',
    'image',
    'marker',
    'mask',
    'pattern',
    'rect',
    'svg',
    'use'
]);

/**
 * Void attributes inside html tags
 * @member {Set} voidAttributes
 * @protected
 */
const voidAttributes = new Set([
    'checked',
    'defer',
    'disabled',
    'ismap',
    'multiple',
    'nohref',
    'noresize',
    'noshade',
    'nowrap',
    'open',
    'readonly',
    'required',
    'reversed',
    'selected'
]);

/**
 * Void html tags
 * @member {Set} voidElements
 * @protected
 */
const voidElements = new Set([
    'area',
    'base',
    'br',
    'col',
    'embed',
    'hr',
    'img',
    'input',
    'link',
    'meta',
    'param',
    'source',
    'track',
    'wbr'
]);


/***/ }

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL3Zkb20vdmVuZG9ycy1zcmNfdmRvbV9IZWxwZXJfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixzREFBSTtBQUM3QjtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIsdUJBQXVCO0FBQ3ZCLHFCQUFxQjtBQUNyQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBLGtDQUFrQyxPQUFPLE9BQU8sU0FBUyxTQUFTLFdBQVcsU0FBUyxRQUFROztBQUU5RjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsMEJBQTBCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvRk47O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNEQUFJO0FBQ3hCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7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QVU7QUFDVjtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEVBQThFLHdEQUFVO0FBQ3hGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUscUNBQXFDLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcEpyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvdXRpbC9TdHJpbmcubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdXRpbC9TdHlsZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy92ZG9tL0hlbHBlci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy92ZG9tL1ZOb2RlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3Zkb20vZG9tQ29uc3RhbnRzLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZSBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnV0aWwuU3RyaW5nXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIFN0cmluZ1V0aWwgZXh0ZW5kcyBCYXNlIHtcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGNoYXJFbnRpdHlNYXBcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGNoYXJFbnRpdHlNYXAgPSB7XG4gICAgICAgICcmJyA6ICcmYW1wOycsXG4gICAgICAgICc8JyA6ICcmbHQ7JyxcbiAgICAgICAgJz4nIDogJyZndDsnLFxuICAgICAgICAnXCInIDogJyZxdW90OycsXG4gICAgICAgICdcXCcnOiAnJmFwb3M7JyxcbiAgICAgICAgJyQnIDogJyZkb2xsYXI7JyxcbiAgICAgICAgJ1xcXFwnOiAnJmJzb2w7JyxcbiAgICAgICAgJy8nIDogJyZzb2w7J1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtSZWdFeHB9IGNoYXJQYXR0ZXJuXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBjaGFyUGF0dGVybiA9IC9bJjw+XCInJFxcXFxdL2dcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtSZWdFeHB9IGVudGl0eVBhdHRlcm5cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGVudGl0eVBhdHRlcm4gPSAvKCZhbXA7KXwoJmx0Oyl8KCZndDspfCgmcXVvdDspfCgmYXBvczspfCgmZG9sbGFyOyl8KCZic29sOyl8KCZzb2w7KS9nXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby51dGlsLlN0cmluZydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnV0aWwuU3RyaW5nJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVzY2FwZSBIVE1MIHNwZWNpYWwgY2hhcmFjdGVyc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIHN0YXRpYyBlc2NhcGVIdG1sKHZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7IC8vIGluc2lkZSBhIHN0YXRpYyBtZXRob2QsIHdlIGFyZSBwb2ludGluZyB0byB0aGUgY2xhc3MgcHJvdG90eXBlXG5cbiAgICAgICAgaWYgKCFOZW8uaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKG1lLmNoYXJQYXR0ZXJuLCBtZS5nZXRFbnRpdHlGcm9tQ2hhci5iaW5kKG1lKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY2hhciBlcXVpdmFsZW50IG9mIGEgbWFwcGVkIGVudGl0eVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBlbnRpdHlcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q2hhckZyb21FbnRpdHkoZW50aXR5KSB7XG4gICAgICAgIGxldCBtYXBwZWRDaGFyID0gT2JqZWN0LmtleXModGhpcy5jaGFyRW50aXR5TWFwKS5maW5kKGtleSA9PiB0aGlzLmNoYXJFbnRpdHlNYXBba2V5XSA9PT0gZW50aXR5KTtcbiAgICAgICAgcmV0dXJuIG1hcHBlZENoYXIgfHwgZW50aXR5XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGVudGl0eSBlcXVpdmFsZW50IG9mIGEgbWFwcGVkIGNoYXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2hhclxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRFbnRpdHlGcm9tQ2hhcihjaGFyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYXJFbnRpdHlNYXBbY2hhcl0gfHwgY2hhclxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVuZXNjYXBlIEhUTUwgc3BlY2lhbCBjaGFyYWN0ZXJzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICovXG4gICAgc3RhdGljIHVuZXNjYXBlSHRtbCh2YWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzOyAvLyBpbnNpZGUgYSBzdGF0aWMgbWV0aG9kLCB3ZSBhcmUgcG9pbnRpbmcgdG8gdGhlIGNsYXNzIHByb3RvdHlwZVxuXG4gICAgICAgIGlmICghTmVvLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWUucmVwbGFjZShtZS5lbnRpdHlQYXR0ZXJuLCBtZS5nZXRDaGFyRnJvbUVudGl0eS5iaW5kKG1lKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwYXNzZWQgc3RyaW5nIHdpdGggdGhlIGZpcnN0IGxldHRlciB1bmNhcGl0YWxpemVkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zICB7U3RyaW5nfVxuICAgICAqL1xuICAgIHN0YXRpYyB1bmNhcGl0YWxpemUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICYmIHZhbHVlWzBdLnRvTG93ZXJDYXNlKCkgKyB2YWx1ZS5zdWJzdHJpbmcoMSlcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFN0cmluZ1V0aWwpO1xuIiwiaW1wb3J0IEJhc2UgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby51dGlsLlN0eWxlXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIFN0eWxlIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8udXRpbC5TdHlsZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnV0aWwuU3R5bGUnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBkZWx0YSBvYmplY3QsIGNvbnRhaW5pbmcgdGhlIHN0eWxlcyBvZiBuZXdTdHlsZSB3aGljaCBhcmUgbm90IGluY2x1ZGVkIG9yIGRpZmZlcmVudCB0aGFuIGluIG9sZFN0eWxlXG4gICAgICogU3R5bGVzIGluY2x1ZGVkIGluIG9sZFN0eWxlIGJ1dCBtaXNzaW5nIGluIG5ld1N0eWxlIHdpbGwgZ2V0IGEgdmFsdWUgb2YgbnVsbFxuICAgICAqIHNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxFbGVtZW50L3N0eWxlXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBuZXdTdHlsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gb2xkU3R5bGVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBzdHlsZSBkZWx0YVxuICAgICAqL1xuICAgIHN0YXRpYyBjb21wYXJlU3R5bGVzKG5ld1N0eWxlLCBvbGRTdHlsZSkge1xuICAgICAgICBsZXQgc3R5bGVzID0ge307XG5cbiAgICAgICAgaWYgKE5lby5pc1N0cmluZyhuZXdTdHlsZSkpIHtcbiAgICAgICAgICAgIG5ld1N0eWxlID0gTmVvLmNyZWF0ZVN0eWxlT2JqZWN0KG5ld1N0eWxlKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE5lby5pc1N0cmluZyhvbGRTdHlsZSkpIHtcbiAgICAgICAgICAgIG9sZFN0eWxlID0gTmVvLmNyZWF0ZVN0eWxlT2JqZWN0KG9sZFN0eWxlKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFuZXdTdHlsZSAmJiAhb2xkU3R5bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH0gZWxzZSBpZiAoIW9sZFN0eWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gTmVvLmNsb25lKG5ld1N0eWxlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3U3R5bGUgJiYgT2JqZWN0LmtleXMobmV3U3R5bGUpLmZvckVhY2goc3R5bGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghb2xkU3R5bGUuaGFzT3duUHJvcGVydHkoc3R5bGUpIHx8IG9sZFN0eWxlW3N0eWxlXSAhPT0gbmV3U3R5bGVbc3R5bGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlc1tzdHlsZV0gPSBuZXdTdHlsZVtzdHlsZV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgT2JqZWN0LmtleXMob2xkU3R5bGUpLmZvckVhY2goc3R5bGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghbmV3U3R5bGUgIHx8ICFuZXdTdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzW3N0eWxlXSA9IG51bGxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHN0eWxlcykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHlsZXNcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoU3R5bGUpO1xuIiwiaW1wb3J0IEJhc2UgICAgICAgICAgICAgICBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBOZW9BcnJheSAgICAgICAgICAgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IFN0eWxlICAgICAgICAgICAgICBmcm9tICcuLi91dGlsL1N0eWxlLm1qcyc7XG5pbXBvcnQge3Jhd0RpbWVuc2lvblRhZ3N9IGZyb20gJy4vZG9tQ29uc3RhbnRzLm1qcyc7XG5pbXBvcnQgVk5vZGUgICAgICAgICAgICAgIGZyb20gJy4vVk5vZGUubWpzJztcblxuY29uc3QgTmVvQ29uZmlnID0gTmVvLmNvbmZpZztcblxuLyoqXG4gKiBUaGUgY2VudHJhbCBjbGFzcyBmb3IgdGhlIFZEb20gd29ya2VyIHRvIGNyZWF0ZSB2bm9kZXMgJiBkZWx0YSB1cGRhdGVzLlxuICogQGNsYXNzIE5lby52ZG9tLkhlbHBlclxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICogQHNpbmdsZXRvblxuICovXG5jbGFzcyBIZWxwZXIgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby52ZG9tLkhlbHBlcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnZkb20uSGVscGVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW90ZSBtZXRob2QgYWNjZXNzIGZvciBvdGhlciB3b3JrZXJzXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gcmVtb3RlPXthcHA6WydjcmVhdGUnLCd1cGRhdGUnXX1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHJlbW90ZToge1xuICAgICAgICAgICAgYXBwOiBbXG4gICAgICAgICAgICAgICAgJ2NyZWF0ZScsXG4gICAgICAgICAgICAgICAgJ3VwZGF0ZSdcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZXRvbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZXRvbjogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgIGNvbmZpZy5kZWx0YXNcbiAgICAgKiBAcGFyYW0ge05lby52ZG9tLlZOb2RlfSBjb25maWcub2xkVm5vZGVcbiAgICAgKiBAcGFyYW0ge05lby52ZG9tLlZOb2RlfSBjb25maWcudm5vZGVcbiAgICAgKiBAcGFyYW0ge01hcH0gICAgICAgICAgICBjb25maWcudm5vZGVNYXBcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBkZWx0YXNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY29tcGFyZUF0dHJpYnV0ZXMoe2RlbHRhcywgb2xkVm5vZGUsIHZub2RlLCB2bm9kZU1hcH0pIHtcbiAgICAgICAgLy8gSWYgZWl0aGVyIHZub2RlIGlzIGEgY29tcG9uZW50IHBsYWNlaG9sZGVyIChpbmRpY2F0ZWQgYnkgdGhlIHByZXNlbmNlIG9mIGNvbXBvbmVudElkKSxcbiAgICAgICAgLy8gd2UgbXVzdCBub3QgY29tcGFyZSBlbGVtZW50IGF0dHJpYnV0ZXMuXG4gICAgICAgIGlmICh2bm9kZS5jb21wb25lbnRJZCB8fCBvbGRWbm9kZS5jb21wb25lbnRJZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlbHRhcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZyYWdtZW50cyBhcmUgXCJ0cmFuc3BhcmVudFwiIGNvbnRhaW5lcnMuIFRoZXkgZG8gbm90IGhhdmUgcGh5c2ljYWwgRE9NIGF0dHJpYnV0ZXMgb3Igc3R5bGVzLlxuICAgICAgICAvLyBUaGVyZWZvcmUsIHdlIHNraXAgYXR0cmlidXRlIGNvbXBhcmlzb24gZW50aXJlbHkuXG4gICAgICAgIGlmICh2bm9kZS5ub2RlTmFtZSA9PT0gJ2ZyYWdtZW50Jykge1xuICAgICAgICAgICAgcmV0dXJuIGRlbHRhc1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGRlbHRhID0ge30sXG4gICAgICAgICAgICBhdHRyaWJ1dGVzLCB2YWx1ZSwga2V5cywgc3R5bGVzLCBhZGQsIHJlbW92ZTtcblxuICAgICAgICBpZiAodm5vZGUudnR5cGUgPT09ICd0ZXh0JyAmJiB2bm9kZS50ZXh0Q29udGVudCAhPT0gb2xkVm5vZGUudGV4dENvbnRlbnQpIHtcbiAgICAgICAgICAgIGRlbHRhcy5kZWZhdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgIGFjdGlvbiAgOiAndXBkYXRlVnRleHQnLFxuICAgICAgICAgICAgICAgIGlkICAgICAgOiB2bm9kZS5pZCxcbiAgICAgICAgICAgICAgICBwYXJlbnRJZDogdm5vZGVNYXAuZ2V0KHZub2RlLmlkKS5wYXJlbnROb2RlLmlkLFxuICAgICAgICAgICAgICAgIHZhbHVlICAgOiB2bm9kZS50ZXh0Q29udGVudFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyh2bm9kZSk7XG5cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG9sZFZub2RlKS5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghT2JqZWN0Lmhhc093bih2bm9kZSwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKHByb3ApXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSAnYXR0cmlidXRlcycpIHsgLy8gRmluZCByZW1vdmVkIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMob2xkVm5vZGVbcHJvcF0pLmZvckVhY2goYXR0ciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5oYXNPd24odm5vZGVbcHJvcF0sIGF0dHIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdm5vZGVbcHJvcF1bYXR0cl0gPSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGtleXMuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZub2RlW3Byb3BdO1xuXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2F0dHJpYnV0ZXMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcyA9IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZW50cmllcyh2YWx1ZSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWUgICAgPSBvbGRWbm9kZS5hdHRyaWJ1dGVzW2tleV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc09sZFZhbHVlID0gT2JqZWN0Lmhhc093bihvbGRWbm9kZS5hdHRyaWJ1dGVzLCBrZXkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGF0dHJpYnV0ZSBoYXMgYW4gb2xkIHZhbHVlIEFORCB0aGUgdmFsdWUgaGFzbid0IGNoYW5nZWQsIHNraXAuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc09sZFZhbHVlICYmIG9sZFZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY3VycmVudCB2YWx1ZSBpcyBudWxsLCBvciBpdCdzIGEgbm9uLXN0cmluZyBlbXB0eSB2YWx1ZSAoZS5nLiwgW10sIHt9KSwgc2tpcC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiBBbiBlbXB0eSBzdHJpbmcgKCcnKSBpcyBhIHZhbGlkIHZhbHVlIGFuZCBzaG91bGQgTk9UIGJlIHNraXBwZWQgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgIU5lby5pc1N0cmluZyh2YWx1ZSkgJiYgTmVvLmlzRW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YS5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGF0dHJpYnV0ZXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdm5vZGUuYXR0cmlidXRlc1trZXldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbm9kZU5hbWUnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdpbm5lckhUTUwnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzY3JvbGxMZWZ0JzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2Nyb2xsVG9wJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndGV4dENvbnRlbnQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBvbGRWbm9kZVtwcm9wXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhW3Byb3BdID0gdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N0eWxlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlcyA9IFN0eWxlLmNvbXBhcmVTdHlsZXModmFsdWUsIG9sZFZub2RlLnN0eWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YS5zdHlsZSA9IHN0eWxlc1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2xhc3NOYW1lJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbGRWbm9kZS5jbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGQgICAgPSBOZW9BcnJheS5kaWZmZXJlbmNlKHZhbHVlLCBvbGRWbm9kZS5jbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZSA9IE5lb0FycmF5LmRpZmZlcmVuY2Uob2xkVm5vZGUuY2xhc3NOYW1lLCB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkICAgID0gIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZSA9IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGQubGVuZ3RoID4gMCB8fCByZW1vdmUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhLmNscyA9IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZCAgIC5sZW5ndGggPiAwKSB7ZGVsdGEuY2xzLmFkZCAgICA9IGFkZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVtb3ZlLmxlbmd0aCA+IDApIHtkZWx0YS5jbHMucmVtb3ZlID0gcmVtb3ZlfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGRlbHRhKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZGVsdGEuaWQgPSB2bm9kZS5pZDtcbiAgICAgICAgICAgICAgICBkZWx0YXMuZGVmYXVsdC5wdXNoKGRlbHRhKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlbHRhc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBOZW8udmRvbS5WTm9kZSB0cmVlIGZvciB0aGUgZ2l2ZW4gdmRvbSB0ZW1wbGF0ZS5cbiAgICAgKiBUaGUgdG9wIGxldmVsIHZub2RlIGNvbnRhaW5zIHRoZSBvdXRlckhUTUwgYXMgYSBzdHJpbmcsXG4gICAgICogaW4gY2FzZSBOZW8uY29uZmlnLnVzZURvbUFwaVJlbmRlcmVyID09PSBmYWxzZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdHMuYXBwTmFtZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdHMuYXV0b01vdW50XVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRzLnBhcmVudElkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdHMucGFyZW50SW5kZXhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy52ZG9tXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdHMud2luZG93SWRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGNyZWF0ZShvcHRzKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt1dGlsfSAgICAgICAgICAgPSBOZW8udmRvbSxcbiAgICAgICAgICAgIHBvc3RNb3VudFVwZGF0ZXMgPSBbXSxcbiAgICAgICAgICAgIHJldHVyblZhbHVlLCB2bm9kZTtcblxuICAgICAgICB2bm9kZSAgICAgICA9IG1lLmNyZWF0ZVZub2RlKG9wdHMudmRvbSk7XG4gICAgICAgIHJldHVyblZhbHVlID0gey4uLm9wdHMsIHZub2RlfTtcblxuICAgICAgICBkZWxldGUgcmV0dXJuVmFsdWUudmRvbTtcblxuICAgICAgICBpZiAoIU5lb0NvbmZpZy51c2VEb21BcGlSZW5kZXJlcikge1xuICAgICAgICAgICAgaWYgKCF1dGlsLlN0cmluZ0Zyb21Wbm9kZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVkRvbSBIZWxwZXIgcmVuZGVyIHV0aWxpdGllcyBhcmUgbm90IGxvYWRlZCB5ZXQhJylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuVmFsdWUub3V0ZXJIVE1MID0gdXRpbC5TdHJpbmdGcm9tVm5vZGUuY3JlYXRlKHZub2RlLCBudWxsLCBwb3N0TW91bnRVcGRhdGVzKTtcblxuICAgICAgICAgICAgaWYgKHBvc3RNb3VudFVwZGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVyblZhbHVlLnBvc3RNb3VudFVwZGF0ZXMgPSBwb3N0TW91bnRVcGRhdGVzXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgICAgICAgY29uZmlnXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICAgICAgIFtjb25maWcuZGVsdGFzPXtkZWZhdWx0OiBbXSwgcmVtb3ZlOiBbXX1dXG4gICAgICogQHBhcmFtIHtOZW8udmRvbS5WTm9kZXxPYmplY3R9IGNvbmZpZy5vbGRWbm9kZVxuICAgICAqIEBwYXJhbSB7TWFwfSAgICAgICAgICAgICAgICAgICBbY29uZmlnLm9sZFZub2RlTWFwXVxuICAgICAqIEBwYXJhbSB7TmVvLnZkb20uVk5vZGV8T2JqZWN0fSBjb25maWcudm5vZGVcbiAgICAgKiBAcGFyYW0ge01hcH0gICAgICAgICAgICAgICAgICAgW2NvbmZpZy52bm9kZU1hcF1cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBkZWx0YXNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY3JlYXRlRGVsdGFzKGNvbmZpZykge1xuICAgICAgICBsZXQge2RlbHRhcz17ZGVmYXVsdDogW10sIHJlbW92ZTogW119LCBvbGRWbm9kZSwgdm5vZGV9ID0gY29uZmlnLFxuICAgICAgICAgICAgdm5vZGVJZCA9IHZub2RlPy5pZDtcblxuICAgICAgICAvLyBFZGdlIGNhc2U6IHNldHRpbmcgYHJlbW92ZURvbTogdHJ1ZWAgb24gYSB0b3AtbGV2ZWwgdmRvbSBub2RlXG4gICAgICAgIGlmICghdm5vZGUgJiYgKG9sZFZub2RlPy5pZCB8fCBvbGRWbm9kZT8uY29tcG9uZW50SWQpKSB7XG4gICAgICAgICAgICBkZWx0YXMucmVtb3ZlLnB1c2goe2FjdGlvbjogJ3JlbW92ZU5vZGUnLCBpZDogb2xkVm5vZGUuaWQgfHwgb2xkVm5vZGUuY29tcG9uZW50SWR9KTtcbiAgICAgICAgICAgIHJldHVybiBkZWx0YXNcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2bm9kZS5zdGF0aWMpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWx0YXNcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSB0b3AtbGV2ZWwgbm9kZXMgcGFzc2VkIHRvIGNyZWF0ZURlbHRhcyBtdXN0IGJlIHRoZSBzYW1lIGxvZ2ljYWwgbm9kZS4gVGhlIFZkb21MaWZlY3ljbGVcbiAgICAgICAgLy8gbWl4aW4gZW5zdXJlcyBzeW1tZXRyaWMgdHJlZXMsIHNvIElEcyBhbmQgdHlwZXMgKGNvbXBvbmVudCB2cyBlbGVtZW50KSBtdXN0IG1hdGNoLlxuICAgICAgICBpZiAodm5vZGUuaWQgIT09IG9sZFZub2RlLmlkIHx8IHZub2RlLmNvbXBvbmVudElkICE9PSBvbGRWbm9kZS5jb21wb25lbnRJZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjcmVhdGVEZWx0YXMoKSBtdXN0IGJlIGNhbGxlZCBmb3IgdGhlIHNhbWUgbm9kZS4gbmV3OiB7aWQ6ICR7dm5vZGUuaWR9LCBjSWQ6ICR7dm5vZGUuY29tcG9uZW50SWR9fSwgb2xkOiB7aWQ6ICR7b2xkVm5vZGUuaWR9LCBjSWQ6ICR7b2xkVm5vZGUuY29tcG9uZW50SWR9fWApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgb2xkVm5vZGVNYXAgICA9IGNvbmZpZy5vbGRWbm9kZU1hcCAgfHwgbWUuY3JlYXRlVm5vZGVNYXAoe3Zub2RlOiBvbGRWbm9kZX0pLFxuICAgICAgICAgICAgdm5vZGVNYXAgICAgICA9IGNvbmZpZy52bm9kZU1hcCAgICAgfHwgbWUuY3JlYXRlVm5vZGVNYXAoe3Zub2RlfSksXG4gICAgICAgICAgICBjaGlsZE5vZGVzICAgID0gdm5vZGUgICAuY2hpbGROb2RlcyB8fCBbXSxcbiAgICAgICAgICAgIG9sZENoaWxkTm9kZXMgPSBvbGRWbm9kZS5jaGlsZE5vZGVzIHx8IFtdLFxuICAgICAgICAgICAgaSAgICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICBpbmRleERlbHRhICAgID0gMCxcbiAgICAgICAgICAgIGluc2VydERlbHRhICAgPSAwLFxuICAgICAgICAgICAgbGVuICAgICAgICAgICA9IE1hdGgubWF4KGNoaWxkTm9kZXMubGVuZ3RoLCBvbGRDaGlsZE5vZGVzLmxlbmd0aCksXG4gICAgICAgICAgICBjaGlsZE5vZGUsIG5vZGVJbk5ld1RyZWUsIG9sZENoaWxkTm9kZSwgb2xkQ2hpbGROb2RlSWQ7XG5cbiAgICAgICAgbWUuY29tcGFyZUF0dHJpYnV0ZXMoe2RlbHRhcywgb2xkVm5vZGUsIHZub2RlLCB2bm9kZU1hcH0pO1xuXG4gICAgICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCA9PT0gMCAmJiBvbGRDaGlsZE5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGRlbHRhcy5yZW1vdmUucHVzaCh7YWN0aW9uOiAncmVtb3ZlQWxsJywgcGFyZW50SWQ6IHZub2RlSWR9KTtcbiAgICAgICAgICAgIHJldHVybiBkZWx0YXNcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNoaWxkTm9kZSAgICA9IGNoaWxkTm9kZXNbaV07XG4gICAgICAgICAgICBvbGRDaGlsZE5vZGUgPSBvbGRDaGlsZE5vZGVzW2kgKyBpbmRleERlbHRhXTtcblxuICAgICAgICAgICAgaWYgKCFjaGlsZE5vZGUgJiYgIW9sZENoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEEgXCJtYXRjaFwiIHJlcXVpcmVzIG5vZGVzIHRvIGJlIG9mIHRoZSBzYW1lIHR5cGUgKHBsYWNlaG9sZGVyIG9yIGVsZW1lbnQpIGFuZCBoYXZlXG4gICAgICAgICAgICAvLyB0aGUgc2FtZSBpZGVudGlmaWVyLiBUaGUgVmRvbUxpZmVjeWNsZSBtaXhpbiBlbnN1cmVzIHRoYXQgYm90aCB0aGUgb2xkICh2bm9kZSlcbiAgICAgICAgICAgIC8vIGFuZCBuZXcgKHZkb20pIHRyZWVzIGFyZSBleHBhbmRlZCB0byB0aGUgc2FtZSBzeW1tZXRyaWMgZGVwdGggYmVmb3JlIGRpZmZpbmcuXG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlICYmIG9sZENoaWxkTm9kZSAmJiAoXG4gICAgICAgICAgICAgICAgLy8gQ2FzZSAxOiBCb3RoIG5vZGVzIGFyZSBlbGVtZW50cyB3aXRoIHRoZSBzYW1lIElEXG4gICAgICAgICAgICAgICAgKCFjaGlsZE5vZGUuY29tcG9uZW50SWQgJiYgIW9sZENoaWxkTm9kZS5jb21wb25lbnRJZCAmJiBjaGlsZE5vZGUuaWQgPT09IG9sZENoaWxkTm9kZS5pZCkgfHxcbiAgICAgICAgICAgICAgICAvLyBDYXNlIDI6IEJvdGggbm9kZXMgYXJlIHBsYWNlaG9sZGVycyBmb3IgdGhlIHNhbWUgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgKGNoaWxkTm9kZS5jb21wb25lbnRJZCAmJiBjaGlsZE5vZGUuY29tcG9uZW50SWQgPT09IG9sZENoaWxkTm9kZS5jb21wb25lbnRJZClcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlLm5lb0lnbm9yZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgY2hpbGROb2RlLm5lb0lnbm9yZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZS5jcmVhdGVEZWx0YXMoe2RlbHRhcywgb2xkVm5vZGU6IG9sZENoaWxkTm9kZSwgb2xkVm5vZGVNYXAsIHZub2RlOiBjaGlsZE5vZGUsIHZub2RlTWFwfSk7XG4gICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9sZENoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAgIG9sZENoaWxkTm9kZUlkID0gb2xkQ2hpbGROb2RlLmlkIHx8IG9sZENoaWxkTm9kZS5jb21wb25lbnRJZDtcbiAgICAgICAgICAgICAgICBub2RlSW5OZXdUcmVlICA9IHZub2RlTWFwLmdldChvbGRDaGlsZE5vZGVJZCk7XG5cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgbm9kZSwgaWYgbm8gbG9uZ2VyIGluc2lkZSB0aGUgbmV3IHRyZWVcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGVJbk5ld1RyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUucmVtb3ZlTm9kZSh7ZGVsdGFzLCBvbGRWbm9kZTogb2xkQ2hpbGROb2RlLCBvbGRWbm9kZU1hcH0pO1xuICAgICAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgICAgIGluc2VydERlbHRhKys7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVGhlIG9sZCBjaGlsZCBub2RlIGdvdCBtb3ZlZCBpbnRvIGEgZGlmZmVyZW50IG5vdCBwcm9jZXNzZWQgYXJyYXkuIEl0IHdpbGwgZ2V0IHBpY2tlZCB1cCB0aGVyZS5cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlICYmIHZub2RlSWQgIT09IG5vZGVJbk5ld1RyZWUucGFyZW50Tm9kZS5pZCkge1xuICAgICAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgICAgIGluZGV4RGVsdGErKztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAobWUuaXNNb3ZlZE5vZGUoY2hpbGROb2RlLCBvbGRWbm9kZU1hcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUubW92ZU5vZGUoe2RlbHRhcywgaW5zZXJ0RGVsdGEsIG9sZFZub2RlTWFwLCB2bm9kZTogY2hpbGROb2RlLCB2bm9kZU1hcH0pXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuaW5zZXJ0Tm9kZSh7ZGVsdGFzLCBpbmRleDogaSArIGluc2VydERlbHRhLCBvbGRWbm9kZU1hcCwgdm5vZGU6IGNoaWxkTm9kZSwgdm5vZGVNYXB9KVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvbGRDaGlsZE5vZGUgJiYgdm5vZGVJZCA9PT0gdm5vZGVNYXAuZ2V0KG9sZENoaWxkTm9kZUlkKT8ucGFyZW50Tm9kZS5pZCkge1xuICAgICAgICAgICAgICAgICAgICBsZW4rK1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWx0YXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R8TmVvLnZkb20uVk5vZGV8bnVsbH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY3JlYXRlVm5vZGUob3B0cykge1xuICAgICAgICAvLyBkbyBub3QgY3JlYXRlIHZub2RlIGluc3RhbmNlcyBmb3IgY29tcG9uZW50IHJlZmVyZW5jZSBvYmplY3RzXG4gICAgICAgIGlmIChvcHRzLmNvbXBvbmVudElkKSB7XG4gICAgICAgICAgICBvcHRzLmNoaWxkTm9kZXMgPz89IFtdOyAvLyBDb25zaXN0ZW5jeTogRXZlcnkgVk5vZGUgaGFzIGEgY2hpbGROb2RlcyBhcnJheVxuICAgICAgICAgICAgb3B0cy5pZCAgICAgICAgID8/PSBvcHRzLmNvbXBvbmVudElkXG5cbiAgICAgICAgICAgIHJldHVybiBvcHRzXG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0cy5yZW1vdmVEb20gPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICBub2RlID0ge2F0dHJpYnV0ZXM6IHt9LCBzdHlsZToge319LFxuICAgICAgICAgICAgcG90ZW50aWFsTm9kZTtcblxuICAgICAgICBPYmplY3QuZW50cmllcyhvcHRzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsICYmIGtleSAhPT0gJ2ZsYWcnICYmIGtleSAhPT0gJ3JlbW92ZURvbScpIHtcbiAgICAgICAgICAgICAgICBsZXQgaGFzVW5pdCwgbmV3VmFsdWUsIHN0eWxlO1xuXG4gICAgICAgICAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndGFnJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubm9kZU5hbWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Nscyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmNsYXNzTmFtZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmlubmVySFRNTCA9IHZhbHVlLnRvU3RyaW5nKCk7IC8vIHN1cHBvcnQgZm9yIG51bWJlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS50ZXh0Q29udGVudCA9IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjbic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBbdmFsdWVdXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLmZpbHRlcihCb29sZWFuKS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnJlbW92ZURvbSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgaXRlbS5yZW1vdmVEb207IC8vIGNvdWxkIGJlIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbE5vZGUgPSBtZS5jcmVhdGVWbm9kZShpdGVtKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocG90ZW50aWFsTm9kZSkgeyAvLyBkb24ndCBhZGQgbnVsbCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlLnB1c2gocG90ZW50aWFsTm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmNoaWxkTm9kZXMgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGF0YSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgTmVvLnR5cGVPZih2YWx1ZSkgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXModmFsdWUpLmZvckVhY2goKFtrZXksIHZhbF0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hdHRyaWJ1dGVzW2BkYXRhLSR7TmVvLmRlY2FtZWwoa2V5KX1gXSA9IHZhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaGVpZ2h0JzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWF4SGVpZ2h0JzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWF4V2lkdGgnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtaW5IZWlnaHQnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtaW5XaWR0aCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3dpZHRoJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYXdEaW1lbnNpb25UYWdzLmhhcyhub2RlLm5vZGVOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYXR0cmlidXRlc1trZXldID0gdmFsdWUgKyAnJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNVbml0ID0gdmFsdWUgIT0gcGFyc2VJbnQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3R5bGVba2V5XSA9IHZhbHVlICsgKGhhc1VuaXQgPyAnJyA6ICdweCcpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjb21wb25lbnRJZCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2lkJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2Nyb2xsTGVmdCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Njcm9sbFRvcCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N0YXRpYyc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Z0eXBlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3R5bGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUgPSBub2RlLnN0eWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE5lby5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnN0eWxlID0gT2JqZWN0LmFzc2lnbihzdHlsZSwgTmVvLmNvcmUuVXRpbC5jcmVhdGVTdHlsZU9iamVjdCh2YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUgPSBPYmplY3QuYXNzaWduKHN0eWxlLCB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlICsgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUmVsZXZhbnQgZm9yIHZ0eXBlPSd0ZXh0J1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMobm9kZS5hdHRyaWJ1dGVzKS5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICBkZWxldGUgbm9kZS5hdHRyaWJ1dGVzXG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWxldmFudCBmb3IgdnR5cGU9J3RleHQnXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhub2RlLnN0eWxlKS5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICBkZWxldGUgbm9kZS5zdHlsZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBWTm9kZShub2RlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmbGF0IG1hcCBvZiB0aGUgdHJlZSwgY29udGFpbmluZyBpZHMgYXMga2V5cyBhbmQgaW5mb3MgYXMgdmFsdWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgY29uZmlnXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgW2NvbmZpZy5pbmRleD0wXVxuICAgICAqIEBwYXJhbSB7TWFwfSAgICAgICAgICAgIFtjb25maWcubWFwPW5ldyBNYXAoKV1cbiAgICAgKiBAcGFyYW0ge05lby52ZG9tLlZOb2RlfSBbY29uZmlnLnBhcmVudE5vZGU9bnVsbF1cbiAgICAgKiBAcGFyYW0ge05lby52ZG9tLlZOb2RlfSBjb25maWcudm5vZGVcbiAgICAgKiBAcmV0dXJucyB7TWFwfVxuICAgICAqICAgICB7U3RyaW5nfSAgICAgICAgIGlkIHZub2RlLmlkIChjb252ZW5pZW5jZSBzaG9ydGN1dClcbiAgICAgKiAgICAge051bWJlcn0gICAgICAgICBpbmRleFxuICAgICAqICAgICB7U3RyaW5nfSAgICAgICAgIHBhcmVudElkXG4gICAgICogICAgIHtOZW8udmRvbS5WTm9kZX0gdm5vZGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY3JlYXRlVm5vZGVNYXAoe2luZGV4PTAsIG1hcD1uZXcgTWFwKCksIHBhcmVudE5vZGU9bnVsbCwgdm5vZGV9KSB7XG4gICAgICAgIGlmICh2bm9kZSkge1xuICAgICAgICAgICAgbGV0IGlkID0gdm5vZGUuaWQgfHwgdm5vZGUuY29tcG9uZW50SWQ7XG5cbiAgICAgICAgICAgIG1hcC5zZXQoaWQsIHtpZCwgaW5kZXgsIHBhcmVudE5vZGUsIHZub2RlfSk7XG5cbiAgICAgICAgICAgIHZub2RlLmNoaWxkTm9kZXM/LmZvckVhY2goKGNoaWxkTm9kZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVZub2RlTWFwKHtpbmRleCwgbWFwLCBwYXJlbnROb2RlOiB2bm9kZSwgdm5vZGU6IGNoaWxkTm9kZX0pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hcFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBsb2dpYyB3aWxsIHBhcnNlIHRoZSB2bm9kZSAodHJlZSkgdG8gZmluZCBleGlzdGluZyBpdGVtcyBpbnNpZGUgYSBnaXZlbiBtYXAuXG4gICAgICogSXQgd2lsbCBub3Qgc2VhcmNoIGZvciBmdXJ0aGVyIGNoaWxkTm9kZXMgaW5zaWRlIGFuIGFscmVhZHkgZm91bmQgdm5vZGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgY29uZmlnXG4gICAgICogQHBhcmFtIHtNYXB9ICAgICAgICAgICAgW2NvbmZpZy5tb3ZlZE5vZGVzPW5ldyBNYXAoKV1cbiAgICAgKiBAcGFyYW0ge01hcH0gICAgICAgICAgICBjb25maWcub2xkVm5vZGVNYXBcbiAgICAgKiBAcGFyYW0ge05lby52ZG9tLlZOb2RlfSBjb25maWcudm5vZGVcbiAgICAgKiBAcGFyYW0ge01hcH0gICAgICAgICAgICBjb25maWcudm5vZGVNYXBcbiAgICAgKiBAcmV0dXJucyB7TWFwfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBmaW5kTW92ZWROb2Rlcyh7bW92ZWROb2Rlcz1uZXcgTWFwKCksIG9sZFZub2RlTWFwLCB2bm9kZSwgdm5vZGVNYXB9KSB7XG4gICAgICAgIGxldCBpZCA9IHZub2RlPy5pZDtcblxuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTW92ZWROb2RlKHZub2RlLCBvbGRWbm9kZU1hcCkpIHtcbiAgICAgICAgICAgICAgICBtb3ZlZE5vZGVzLnNldChpZCwgdm5vZGVNYXAuZ2V0KGlkKSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdm5vZGUuY2hpbGROb2Rlcz8uZm9yRWFjaChjaGlsZE5vZGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlLnZ0eXBlICE9PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmluZE1vdmVkTm9kZXMoe21vdmVkTm9kZXMsIG9sZFZub2RlTWFwLCB2bm9kZTogY2hpbGROb2RlLCB2bm9kZU1hcH0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1vdmVkTm9kZXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmUgaGVscGVyIHRvIGNvdW50IHRoZSBwaHlzaWNhbCBub2RlcyBhIGZyYWdtZW50IGV4cGFuZHMgdG8uXG4gICAgICpcbiAgICAgKiAqKkZvcm11bGE6KiogYDIgKFN0YXJ0L0VuZCBBbmNob3JzKSArIFN1bShDaGlsZCBQaHlzaWNhbCBDb3VudHMpYFxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgZXNzZW50aWFsIGZvciBjb252ZXJ0aW5nIGEgXCJMb2dpY2FsIEluZGV4XCIgKHdoZXJlIHRoZSBmcmFnbWVudCBpcyAxIGl0ZW0pXG4gICAgICogaW50byBhIFwiUGh5c2ljYWwgSW5kZXhcIiAod2hlcmUgdGhlIGZyYWdtZW50IGlzIGEgcmFuZ2Ugb2YgTiBET00gbm9kZXMpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOZW8udmRvbS5WTm9kZX0gZnJhZ21lbnROb2RlXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRGcmFnbWVudFBoeXNpY2FsQ291bnQoZnJhZ21lbnROb2RlKSB7XG4gICAgICAgIGxldCBjb3VudCA9IDI7IC8vIFN0YXJ0ICsgRW5kIGFuY2hvcnNcblxuICAgICAgICBmcmFnbWVudE5vZGUuY2hpbGROb2Rlcz8uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgICBpZiAoY2hpbGQudnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgIGNvdW50ICs9IDNcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGQubm9kZU5hbWUgPT09ICdmcmFnbWVudCcpIHtcbiAgICAgICAgICAgICAgICBjb3VudCArPSB0aGlzLmdldEZyYWdtZW50UGh5c2ljYWxDb3VudChjaGlsZClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY291bnQgKz0gMVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY291bnRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBwaHlzaWNhbCBET00gaW5kZXggZm9yIGEgZ2l2ZW4gbG9naWNhbCBjaGlsZCBpbmRleC5cbiAgICAgKlxuICAgICAqICoqVGhlIFwiUGh5c2ljYWwgdnMuIExvZ2ljYWxcIiBQcm9ibGVtOioqXG4gICAgICogSW4gdGhlIFZET00sIGEgY2hpbGQgbGlzdCBpcyBzaW1wbGU6IGBbRGl2LCBGcmFnbWVudCwgU3Bhbl1gLlxuICAgICAqIEluIHRoZSByZWFsIERPTSwgdGhpcyBleHBhbmRzIHRvOiBgZGl2YCwgYDwhLS1mcmFnLXN0YXJ0LS0+YCwgYHBgLCBgPCEtLWZyYWctZW5kLS0+YCwgYHNwYW5gLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXRlcmF0ZXMgdGhyb3VnaCB0aGUgcHJlY2VkaW5nIHNpYmxpbmdzIGFuZCBzdW1zIHVwIHRoZWlyIFwiUGh5c2ljYWwgQ291bnRcIjpcbiAgICAgKiAtIFN0YW5kYXJkIEVsZW1lbnQ6IDFcbiAgICAgKiAtIFRleHQgTm9kZTogMyAoYDwhLS10ZXh0LS0+YCArIHRleHQgKyBgPCEtLS90ZXh0LS0+YClcbiAgICAgKiAtIEZyYWdtZW50OiBOIChgMiArIGNoaWxkcmVuYClcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TmVvLnZkb20uVk5vZGV9IHBhcmVudE5vZGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gICAgICAgICBsb2dpY2FsSW5kZXhcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldFBoeXNpY2FsSW5kZXgocGFyZW50Tm9kZSwgbG9naWNhbEluZGV4KSB7XG4gICAgICAgIGxldCBwaHlzaWNhbEluZGV4ID0gbG9naWNhbEluZGV4LFxuICAgICAgICAgICAgaSAgICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICBjaGlsZDtcblxuICAgICAgICBmb3IgKDsgaSA8IGxvZ2ljYWxJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICBjaGlsZCA9IHBhcmVudE5vZGUuY2hpbGROb2Rlc1tpXTtcblxuICAgICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnZ0eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcGh5c2ljYWxJbmRleCArPSAyIC8vIEFjY291bnRzIGZvciA8IS0tbmVvLXZ0ZXh0LS0+IHdyYXBwZXJzXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGlsZC5ub2RlTmFtZSA9PT0gJ2ZyYWdtZW50Jykge1xuICAgICAgICAgICAgICAgICAgICBwaHlzaWNhbEluZGV4ICs9ICh0aGlzLmdldEZyYWdtZW50UGh5c2ljYWxDb3VudChjaGlsZCkgLSAxKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwaHlzaWNhbEluZGV4XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW1wb3J0cyBlaXRoZXIgKGlmIG5vdCBhbHJlYWR5IGltcG9ydGVkKTpcbiAgICAgKiBgTmVvLnZkb20udXRpbC5Eb21BcGlWbm9kZUNyZWF0b3JgIGlmIE5lby5jb25maWcudXNlRG9tQXBpUmVuZGVyZXIgPT09IHRydWVcbiAgICAgKiBgTmVvLnZkb20udXRpbC5TdHJpbmdGcm9tVm5vZGVgICAgIGlmIE5lby5jb25maWcudXNlRG9tQXBpUmVuZGVyZXIgPT09IGZhbHNlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIGltcG9ydFV0aWwoKSB7XG4gICAgICAgIGNvbnN0IHt1dGlsfSA9IE5lby52ZG9tO1xuXG4gICAgICAgIGlmIChOZW9Db25maWcudXNlRG9tQXBpUmVuZGVyZXIpIHtcbiAgICAgICAgICAgIGlmICghdXRpbD8uRG9tQXBpVm5vZGVDcmVhdG9yKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgaW1wb3J0KCcuL3V0aWwvRG9tQXBpVm5vZGVDcmVhdG9yLm1qcycpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXV0aWw/LlN0cmluZ0Zyb21Wbm9kZSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGltcG9ydCgnLi91dGlsL1N0cmluZ0Zyb21Wbm9kZS5tanMnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYXN5bmMgaW5pdEFzeW5jKCkge1xuICAgICAgICBzdXBlci5pbml0QXN5bmMoKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byBnbG9iYWwgTmVvLmNvbmZpZyBjaGFuZ2VzIGZvciBkeW5hbWljIHJlbmRlcmVyIHN3aXRjaGluZy5cbiAgICAgICAgTmVvLmN1cnJlbnRXb3JrZXI/Lm9uKHtcbiAgICAgICAgICAgIG5lb0NvbmZpZ0NoYW5nZTogbWUub25OZW9Db25maWdDaGFuZ2UsXG4gICAgICAgICAgICBzY29wZSAgICAgICAgICA6IG1lXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF3YWl0IG1lLmltcG9ydFV0aWwoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgIGNvbmZpZy5kZWx0YXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gICAgICAgICBjb25maWcuaW5kZXhcbiAgICAgKiBAcGFyYW0ge01hcH0gICAgICAgICAgICBjb25maWcub2xkVm5vZGVNYXBcbiAgICAgKiBAcGFyYW0ge05lby52ZG9tLlZOb2RlfSBjb25maWcudm5vZGVcbiAgICAgKiBAcGFyYW0ge01hcH0gICAgICAgICAgICBjb25maWcudm5vZGVNYXBcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaW5zZXJ0Tm9kZSh7ZGVsdGFzLCBpbmRleCwgb2xkVm5vZGVNYXAsIHZub2RlLCB2bm9kZU1hcH0pIHtcbiAgICAgICAgbGV0IGRldGFpbHMgICAgICA9IHZub2RlTWFwLmdldCh2bm9kZS5pZCksXG4gICAgICAgICAgICB7cGFyZW50Tm9kZX0gPSBkZXRhaWxzLFxuICAgICAgICAgICAgcGFyZW50SWQgICAgID0gcGFyZW50Tm9kZS5pZCxcbiAgICAgICAgICAgIG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBtb3ZlZE5vZGVzICAgPSBtZS5maW5kTW92ZWROb2Rlcyh7b2xkVm5vZGVNYXAsIHZub2RlLCB2bm9kZU1hcH0pLFxuICAgICAgICAgICAgZGVsdGEgICAgICAgID0ge2FjdGlvbjogJ2luc2VydE5vZGUnLCBwYXJlbnRJZH07XG5cbiAgICAgICAgLy8gUHJvY2Vzc2VzIHRoZSBjaGlsZHJlbiBvZiB0aGUgKk5FVyogcGFyZW50J3MgVk5vZGUgaW4gdGhlICpjdXJyZW50KiBzdGF0ZVxuICAgICAgICBkZWx0YS5pbmRleCA9IG1lLmdldFBoeXNpY2FsSW5kZXgocGFyZW50Tm9kZSwgaW5kZXgpO1xuXG4gICAgICAgIGlmIChOZW9Db25maWcudXNlRG9tQXBpUmVuZGVyZXIpIHtcbiAgICAgICAgICAgIC8vIEZvciBkaXJlY3QgRE9NIEFQSSBtb3VudGluZywgcGFzcyB0aGUgcHJ1bmVkIFZOb2RlIHRyZWVcbiAgICAgICAgICAgIGRlbHRhLnZub2RlID0gTmVvLnZkb20udXRpbC5Eb21BcGlWbm9kZUNyZWF0b3IuY3JlYXRlKHZub2RlLCBtb3ZlZE5vZGVzKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHBvc3RNb3VudFVwZGF0ZXMgPSBbXTtcblxuICAgICAgICAgICAgLy8gRm9yIHN0cmluZy1iYXNlZCBtb3VudGluZywgcGFzcyBhIHN0cmluZyBleGNsdWRpbmcgbW92ZWQgbm9kZXNcbiAgICAgICAgICAgIGRlbHRhLm91dGVySFRNTCA9IE5lby52ZG9tLnV0aWwuU3RyaW5nRnJvbVZub2RlLmNyZWF0ZSh2bm9kZSwgbW92ZWROb2RlcywgcG9zdE1vdW50VXBkYXRlcyk7XG5cbiAgICAgICAgICAgIGlmIChwb3N0TW91bnRVcGRhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBkZWx0YS5wb3N0TW91bnRVcGRhdGVzID0gcG9zdE1vdW50VXBkYXRlc1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGVsdGFzLmRlZmF1bHQucHVzaChkZWx0YSk7XG5cbiAgICAgICAgLy8gSW5zZXJ0IHRoZSBuZXcgbm9kZSBpbnRvIHRoZSBvbGQgdHJlZSwgdG8gc2ltcGxpZnkgZnV0dXJlIE9Qc1xuICAgICAgICBvbGRWbm9kZU1hcC5nZXQocGFyZW50SWQpLnZub2RlLmNoaWxkTm9kZXMuc3BsaWNlKGluZGV4LCAwLCB2bm9kZSk7XG5cbiAgICAgICAgbW92ZWROb2Rlcy5mb3JFYWNoKGRldGFpbHMgPT4ge1xuICAgICAgICAgICAgbGV0IHtpZH0gICAgID0gZGV0YWlscyxcbiAgICAgICAgICAgICAgICBwYXJlbnRJZCA9IGRldGFpbHMucGFyZW50Tm9kZS5pZDtcblxuICAgICAgICAgICAgZGVsdGFzLmRlZmF1bHQucHVzaCh7YWN0aW9uOiAnbW92ZU5vZGUnLCBpZCwgaW5kZXg6IGRldGFpbHMuaW5kZXgsIHBhcmVudElkfSk7XG5cbiAgICAgICAgICAgIG1lLmNyZWF0ZURlbHRhcyh7ZGVsdGFzLCBvbGRWbm9kZTogb2xkVm5vZGVNYXAuZ2V0KGlkKS52bm9kZSwgb2xkVm5vZGVNYXAsIHZub2RlOiBkZXRhaWxzLnZub2RlLCB2bm9kZU1hcH0pXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05lby52ZG9tLlZOb2RlfSB2bm9kZVxuICAgICAqIEBwYXJhbSB7TWFwfSBvbGRWbm9kZU1hcFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpc01vdmVkTm9kZSh2bm9kZSwgb2xkVm5vZGVNYXApIHtcbiAgICAgICAgbGV0IG9sZFZub2RlID0gb2xkVm5vZGVNYXAuZ2V0KHZub2RlLmlkKTtcblxuICAgICAgICByZXR1cm4gb2xkVm5vZGUgJiYgKFxuICAgICAgICAgICAgIW9sZFZub2RlLnZub2RlLmNvbXBvbmVudElkIHx8ICAgICAgICAgICAgICAgICAgIC8vIHRoZSBvbGQgdm5vZGUgaXMgbm90IGEgcmVmZXJlbmNlXG4gICAgICAgICAgICB2bm9kZS5jb21wb25lbnRJZCA9PT0gb2xkVm5vZGUudm5vZGUuY29tcG9uZW50SWQgLy8gb2xkICYgbmV3IG5vZGVzIGFyZSB0aGUgc2FtZSByZWZlcmVuY2VzXG4gICAgICAgIClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICBjb25maWdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICBjb25maWcuZGVsdGFzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgY29uZmlnLmluc2VydERlbHRhXG4gICAgICogQHBhcmFtIHtNYXB9ICAgICAgICAgICAgY29uZmlnLm9sZFZub2RlTWFwXG4gICAgICogQHBhcmFtIHtOZW8udmRvbS5WTm9kZX0gY29uZmlnLnZub2RlXG4gICAgICogQHBhcmFtIHtNYXB9ICAgICAgICAgICAgY29uZmlnLnZub2RlTWFwXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG1vdmVOb2RlKHtkZWx0YXMsIGluc2VydERlbHRhLCBvbGRWbm9kZU1hcCwgdm5vZGUsIHZub2RlTWFwfSkge1xuICAgICAgICBsZXQgZGV0YWlscyAgICAgICAgICAgICA9IHZub2RlTWFwLmdldCh2bm9kZS5pZCksXG4gICAgICAgICAgICB7aW5kZXgsIHBhcmVudE5vZGV9ID0gZGV0YWlscyxcbiAgICAgICAgICAgIHBhcmVudElkICAgICAgICAgICAgPSBwYXJlbnROb2RlLmlkLFxuICAgICAgICAgICAgbW92ZWROb2RlICAgICAgICAgICA9IG9sZFZub2RlTWFwLmdldCh2bm9kZS5pZCksXG4gICAgICAgICAgICBtb3ZlZFBhcmVudE5vZGUgICAgID0gbW92ZWROb2RlLnBhcmVudE5vZGUsXG4gICAgICAgICAgICB7Y2hpbGROb2Rlc30gICAgICAgID0gbW92ZWRQYXJlbnROb2RlLFxuICAgICAgICAgICAgZGVsdGEgICAgICAgICAgICAgICA9IHthY3Rpb246ICdtb3ZlTm9kZScsIGlkOiB2bm9kZS5pZCwgcGFyZW50SWR9LFxuICAgICAgICAgICAgcGh5c2ljYWxJbmRleCAgICAgICA9IHRoaXMuZ2V0UGh5c2ljYWxJbmRleChwYXJlbnROb2RlLCBpbmRleCk7IC8vIFByb2Nlc3NlcyB0aGUgY2hpbGRyZW4gb2YgdGhlICpORVcqIHBhcmVudCdzIFZOb2RlIGluIHRoZSAqY3VycmVudCogc3RhdGUgKHBhcmVudE5vZGUuY2hpbGROb2RlcylcblxuICAgICAgICBPYmplY3QuYXNzaWduKGRlbHRhLCB7aW5kZXg6IHBoeXNpY2FsSW5kZXggKyBpbnNlcnREZWx0YX0pO1xuICAgICAgICBkZWx0YXMuZGVmYXVsdC5wdXNoKGRlbHRhKTtcblxuICAgICAgICAvLyBUaGlzIGJsb2NrIGltcGxlbWVudHMgdGhlIFwiY29ycnVwdGluZyB0aGUgb2xkIHRyZWVcIiBvcHRpbWl6YXRpb24gZm9yIHBlcmZvcm1hbmNlLlxuICAgICAgICAvLyBJdCBwcmUtbW9kaWZpZXMgdGhlIG9sZCBWTm9kZSBtYXAgdG8gcmVmbGVjdCB0aGUgbW92ZSwgcHJldmVudGluZyByZWR1bmRhbnQgZGVsdGFzIGxhdGVyLlxuICAgICAgICBpZiAocGFyZW50SWQgIT09IG1vdmVkUGFyZW50Tm9kZS5pZCkge1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byByZW1vdmUgdGhlIG5vZGUgZnJvbSB0aGUgb2xkIHBhcmVudCBjaGlsZE5vZGVzXG4gICAgICAgICAgICAvLyAod2hpY2ggbXVzdCBub3QgYmUgdGhlIHNhbWUgYXMgdGhlIG5vZGUgdGhleSBnb3QgbW92ZWQgaW50bylcbiAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZShjaGlsZE5vZGVzLCBtb3ZlZE5vZGUudm5vZGUpO1xuXG4gICAgICAgICAgICAvLyBHZXQgdGhlIFZOb2RlIHJlcHJlc2VudGluZyB0aGUgKm5ldyBwYXJlbnQqIGZyb20gdGhlICdvbGQgVk5vZGUgbWFwJy5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgY3J1Y2lhbDogJ29sZFBhcmVudE5vZGUnIGhlcmUgaXMgdGhlICpvbGQgc3RhdGUncyBWTm9kZSBmb3IgdGhlIG5ldyBwYXJlbnQqLlxuICAgICAgICAgICAgbGV0IG9sZFBhcmVudE5vZGUgPSBvbGRWbm9kZU1hcC5nZXQocGFyZW50SWQpO1xuXG4gICAgICAgICAgICBpZiAob2xkUGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIC8vIElmIG1vdmVkIGludG8gYSBuZXcgcGFyZW50IG5vZGUsIHVwZGF0ZSB0aGUgcmVmZXJlbmNlIGluc2lkZSB0aGUgZmxhdCBtYXBcbiAgICAgICAgICAgICAgICBtb3ZlZE5vZGUucGFyZW50Tm9kZSA9IG9sZFBhcmVudE5vZGUudm5vZGU7XG5cbiAgICAgICAgICAgICAgICAvLyBSZWFzc2lnbiAnY2hpbGROb2RlcycgcHJvcGVydHkgdG8gbm93IHBvaW50IHRvIHRoZSAnY2hpbGROb2RlcycgYXJyYXlcbiAgICAgICAgICAgICAgICAvLyBvZiB0aGlzICdvbGQgc3RhdGUncyBWTm9kZSBmb3IgdGhlIG5ldyBwYXJlbnQnLlxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXMgPSBtb3ZlZE5vZGUucGFyZW50Tm9kZS5jaGlsZE5vZGVzXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgdGhlIG5vZGUgaW50byB0aGUgb2xkIHZub2RlIHRyZWUgdG8gc2ltcGxpZnkgZnV0dXJlIE9Qcy5cbiAgICAgICAgLy8gTmVvQXJyYXkuaW5zZXJ0KCkgd2lsbCBzd2l0Y2ggdG8gbW92ZSgpIGluIGNhc2UgdGhlIG5vZGUgYWxyZWFkeSBleGlzdHMuXG4gICAgICAgIE5lb0FycmF5Lmluc2VydChjaGlsZE5vZGVzLCBpbmRleCwgbW92ZWROb2RlLnZub2RlKTtcblxuICAgICAgICB0aGlzLmNyZWF0ZURlbHRhcyh7ZGVsdGFzLCBvbGRWbm9kZTogbW92ZWROb2RlLnZub2RlLCBvbGRWbm9kZU1hcCwgdm5vZGUsIHZub2RlTWFwfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciBnbG9iYWwgTmVvLmNvbmZpZyBjaGFuZ2VzLlxuICAgICAqIElmIHRoZSBgTmVvLmNvbmZpZy51c2VEb21BcGlSZW5kZXJlcmAgdmFsdWUgY2hhbmdlcywgdGhpcyBtZXRob2QgZHluYW1pY2FsbHkgbG9hZHMgdGhlIHJlbmRlcmVyIHV0aWxpdGllcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBvbk5lb0NvbmZpZ0NoYW5nZShjb25maWcpIHtcbiAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oY29uZmlnLCAndXNlRG9tQXBpUmVuZGVyZXInKSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5pbXBvcnRVdGlsKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgIGNvbmZpZy5kZWx0YXNcbiAgICAgKiBAcGFyYW0ge05lby52ZG9tLlZOb2RlfSBjb25maWcub2xkVm5vZGVcbiAgICAgKiBAcGFyYW0ge01hcH0gICAgICAgICAgICBjb25maWcub2xkVm5vZGVNYXBcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcmVtb3ZlTm9kZSh7ZGVsdGFzLCBvbGRWbm9kZSwgb2xkVm5vZGVNYXB9KSB7XG4gICAgICAgIGlmIChvbGRWbm9kZS5jb21wb25lbnRJZCkge1xuICAgICAgICAgICAgb2xkVm5vZGUuaWQgPz89IG9sZFZub2RlLmNvbXBvbmVudElkXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZGVsdGEgICAgICAgID0ge2FjdGlvbjogJ3JlbW92ZU5vZGUnLCBpZDogb2xkVm5vZGUuaWR9LFxuICAgICAgICAgICAge3BhcmVudE5vZGV9ID0gb2xkVm5vZGVNYXAuZ2V0KG9sZFZub2RlLmlkKTtcblxuICAgICAgICBpZiAob2xkVm5vZGUudnR5cGUgPT09ICd0ZXh0JyB8fCBvbGRWbm9kZS5ub2RlTmFtZSA9PT0gJ2ZyYWdtZW50Jykge1xuICAgICAgICAgICAgZGVsdGEucGFyZW50SWQgPSBwYXJlbnROb2RlLmlkXG4gICAgICAgIH1cblxuICAgICAgICBkZWx0YXMucmVtb3ZlLnB1c2goZGVsdGEpO1xuXG4gICAgICAgIE5lb0FycmF5LnJlbW92ZShwYXJlbnROb2RlLmNoaWxkTm9kZXMsIG9sZFZub2RlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBOZW8udmRvbS5WTm9kZSB0cmVlIGZvciB0aGUgZ2l2ZW4gdmRvbSB0ZW1wbGF0ZSBhbmQgY29tcGFyZXMgdGhlIG5ldyB2bm9kZSB3aXRoIHRoZSBjdXJyZW50IG9uZVxuICAgICAqIHRvIGNhbGN1bGF0ZSB0aGUgdmRvbSBkZWx0YXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy52ZG9tXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMudm5vZGVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHVwZGF0ZShvcHRzKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3V0aWx9ID0gTmVvLnZkb20sXG4gICAgICAgICAgICBkZWx0YXMsIHZub2RlO1xuXG4gICAgICAgIGlmIChOZW9Db25maWcudXNlRG9tQXBpUmVuZGVyZXIpIHtcbiAgICAgICAgICAgIGlmICghdXRpbC5Eb21BcGlWbm9kZUNyZWF0b3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lby52ZG9tLkhlbHBlcjogRG9tQXBpVm5vZGVDcmVhdG9yIGlzIG5vdCBsb2FkZWQgeWV0IGZvciB1cGRhdGVzIScpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXV0aWwuU3RyaW5nRnJvbVZub2RlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZW8udmRvbS5IZWxwZXI6IFN0cmluZ0Zyb21Wbm9kZSBpcyBub3QgbG9hZGVkIHlldCBmb3IgdXBkYXRlcyEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZub2RlICA9IG1lLmNyZWF0ZVZub2RlKG9wdHMudmRvbSk7XG4gICAgICAgIGRlbHRhcyA9IG1lLmNyZWF0ZURlbHRhcyh7b2xkVm5vZGU6IG9wdHMudm5vZGUsIHZub2RlfSk7XG5cbiAgICAgICAgLy8gVHJlZXMgdG8gcmVtb3ZlIGNvdWxkIGNvbnRhaW4gbm9kZXMgd2hpY2ggd2Ugd2FudCB0byByZS11c2UgKG1vdmUpLFxuICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIGV4ZWN1dGUgdGhlIHJlbW92ZU5vZGUgT1BzIGxhc3QuXG4gICAgICAgIGRlbHRhcyA9IGRlbHRhcy5kZWZhdWx0LmNvbmNhdChkZWx0YXMucmVtb3ZlKTtcblxuICAgICAgICByZXR1cm4ge2RlbHRhcywgdXBkYXRlVmRvbTogdHJ1ZSwgdm5vZGV9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhIZWxwZXIpO1xuIiwiaW1wb3J0IFN0cmluZ1V0aWwgZnJvbSAnLi4vdXRpbC9TdHJpbmcubWpzJztcblxuLyoqXG4gKiBXcmFwcGVyIGNsYXNzIGZvciB2bm9kZSBvYmplY3RzLlxuICogRm9yIGNvbnZlbmllbmNlLCBhIFZOb2RlIGluc3RhbmNlIHdpbGwgYWx3YXlzIGNvbnRhaW4gYSBjaGlsZE5vZGVzIGFycmF5LCB3aGljaCBjYW4gYmUgZW1wdHkuXG4gKiBBIFZOb2RlIGNhbiBvcHRpb25hbGx5IGhhdmUgYGlubmVySFRNTGAgeG9yIGB0ZXh0Q29udGVudGBcbiAqIGB0ZXh0Q29udGVudGAgaXMgYmV0dGVyIGZyb20gYSBYU1Mgc2VjdXJpdHkgcGVyc3BlY3RpdmUuXG4gKiBJZiBieSBhY2NpZGVudCBib3RoIGFyZSBzZXQsIGBpbm5lckhUTUxgIHdpbGwgZ2V0IHRoZSBwcmlvcml0eS5cbiAqXG4gKiBAY2xhc3MgTmVvLnZkb20uVk5vZGVcbiAqL1xuY2xhc3MgVk5vZGUge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vdCBzZXQgZm9yIHZ0eXBlPSd0ZXh0JyBub2Rlc1xuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGF0dHJpYnV0ZXM9e31cbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5fSBjaGlsZE5vZGVzPVtdXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb3Qgc2V0IGZvciB2dHlwZT0ndGV4dCcgbm9kZXNcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl9IGNsYXNzTmFtZT1bXVxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBpZD1OZW8uZ2V0SWQoJ3Zub2RlJylcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gaW5uZXJIVE1MXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG5vZGVOYW1lXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0cnVlIGV4Y2x1ZGVzIHRoZSBub2RlIGZyb20gZGVsdGEtdXBkYXRlc1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzdGF0aWNcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vdCBzZXQgZm9yIHZ0eXBlPSd0ZXh0JyBub2Rlc1xuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHN0eWxlXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHNjcm9sbExlZnRcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gc2Nyb2xsVG9wXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHRleHRDb250ZW50XG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWxpZCB2YWx1ZXMgYXJlIFwicm9vdFwiLCBcInRleHRcIiAmIFwidm5vZGVcIlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHZ0eXBlPSd2bm9kZSdcbiAgICAgICAgICovXG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3RleHRDb250ZW50fSA9IGNvbmZpZyxcbiAgICAgICAgICAgIGhhc0lubmVySHRtbCAgPSBPYmplY3QuaGFzT3duKGNvbmZpZywgJ2lubmVySFRNTCcpLFxuICAgICAgICAgICAgaXNWVGV4dCAgICAgICA9IGNvbmZpZy52dHlwZSA9PT0gJ3RleHQnO1xuXG4gICAgICAgIE9iamVjdC5hc3NpZ24obWUsIHtcbiAgICAgICAgICAgIGNoaWxkTm9kZXM6IGNvbmZpZy5jaGlsZE5vZGVzIHx8IFtdLFxuICAgICAgICAgICAgaWQgICAgICAgIDogY29uZmlnLmlkICAgICAgICAgfHwgTmVvLmdldElkKGlzVlRleHQgPyAndnRleHQnIDogJ3Zub2RlJyksXG4gICAgICAgICAgICB2dHlwZSAgICAgOiBjb25maWcudnR5cGUgICAgICB8fCAndm5vZGUnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChpc1ZUZXh0KSB7XG4gICAgICAgICAgICAvLyBBIHZ0ZXh0IG5vZGUgcmVwcmVzZW50cyBhIHB1cmUgdGV4dCBub2RlLiBJdCBzaG91bGQgbm90IGJlIGNyZWF0ZWQgZnJvbSBhbiBpbm5lckhUTUwgcHJvcGVydHkuXG4gICAgICAgICAgICAvLyBGb3IgWFNTIFNlY3VyaXR5LCB3ZSBlc2NhcGUgdGhlIGNvbnRlbnQgd2hlbiB1c2luZyB0aGUgc3RyaW5nLWJhc2VkIHJlbmRlcmVyLlxuICAgICAgICAgICAgbWUudGV4dENvbnRlbnQgPSBOZW8uY29uZmlnLnVzZURvbUFwaVJlbmRlcmVyID8gdGV4dENvbnRlbnQgOiBTdHJpbmdVdGlsLmVzY2FwZUh0bWwodGV4dENvbnRlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihtZSwge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IGNvbmZpZy5hdHRyaWJ1dGVzIHx8IHt9LFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA6IG5vcm1hbGl6ZUNsYXNzTmFtZShjb25maWcuY2xhc3NOYW1lKSxcbiAgICAgICAgICAgICAgICBub2RlTmFtZSAgOiBjb25maWcubm9kZU5hbWUgICB8fCAnZGl2JyxcbiAgICAgICAgICAgICAgICBzY3JvbGxMZWZ0OiBjb25maWcuc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgICAgICBzY3JvbGxUb3AgOiBjb25maWcuc2Nyb2xsVG9wLFxuICAgICAgICAgICAgICAgIHN0eWxlICAgICA6IGNvbmZpZy5zdHlsZSAgICAgIHx8IHt9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gVXNlIHZkb20uaHRtbCBvbiB5b3VyIG93biByaXNrLCBpdCBpcyBub3QgZnVsbHkgWFNTIHNlY3VyZS5cbiAgICAgICAgICAgIGlmIChoYXNJbm5lckh0bWwpIHtcbiAgICAgICAgICAgICAgICBtZS5pbm5lckhUTUwgPSBjb25maWcuaW5uZXJIVE1MXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdlIG9ubHkgYXBwbHkgdGV4dENvbnRlbnQsIGluIGNhc2UgaXQgaGFzIGNvbnRlbnRcbiAgICAgICAgICAgIGVsc2UgaWYgKE9iamVjdC5oYXNPd24oY29uZmlnLCAndGV4dENvbnRlbnQnKSkge1xuICAgICAgICAgICAgICAgIG1lLnRleHRDb250ZW50ID0gTmVvLmNvbmZpZy51c2VEb21BcGlSZW5kZXJlciA/IHRleHRDb250ZW50IDogU3RyaW5nVXRpbC5lc2NhcGVIdG1sKHRleHRDb250ZW50KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2Ugb25seSBhcHBseSB0aGUgc3RhdGljIGF0dHJpYnV0ZSwgaW4gY2FzZSB0aGUgdmFsdWUgaXMgdHJ1ZVxuICAgICAgICBpZiAoY29uZmlnLnN0YXRpYykge1xuICAgICAgICAgICAgbWUuc3RhdGljID0gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIHZkb20gY2xzIGRlZmluaXRpb25zIG1pZ2h0IGNvbnRhaW4gc3BhY2VzLCBlc3BlY2lhbGx5IHdoZW4gaXQgY29tZXMgdG8gaWNvbkNscy5cbiAqIEBleGFtcGxlOiBteVZkb20gPSB7Y2xzOiBbJ215LWJ1dHRvbicsICdmYSBmYS11c2VyJ119XG4gKlxuICogT24gRE9NIGxldmVsLCBjbGFzc0xpc3QuYWRkKCkgd2lsbCB0aHJvdywgaW4gY2FzZSBpdCBnZXRzIGFuIGlucHV0IGNvbnRhaW5pbmcgYSBzcGFjZS5cbiAqXG4gKiBUaGlzIGlzIGEgbW9kdWxlLXNjb3BlZCB1dGlsaXR5IGZ1bmN0aW9uLCBub3QgYSBtZXRob2Qgb2YgdGhlIFZOb2RlIGNsYXNzLlxuICogVk5vZGVzIGFyZSB0cmFuc2ZlcnJlZCB2aWEgc3RydWN0dXJlZCBjbG9uaW5nIChlLmcuLCBpbiBwb3N0TWVzc2FnZSgpKSwgd2hpY2ggc3RyaXBzIG1ldGhvZHMuXG4gKiBLZWVwaW5nIHRoaXMgbG9naWMgc2VwYXJhdGUgZnJvbSB0aGUgVk5vZGUgY2xhc3MgaXRzZWxmIGVuc3VyZXMgY29uY2VwdHVhbCBwdXJpdHkgYW5kIGEgY2xlYW5lciBkYXRhIG1vZGVsLFxuICogYXMgbWV0aG9kcyBkZWZpbmVkIG9uIHRoZSBWTm9kZSBpbnN0YW5jZSB3b3VsZCBiZSBsb3N0IGR1cmluZyB0cmFuc2ZlciBhbnl3YXkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8U3RyaW5nW119IGNsYXNzTmFtZUlucHV0XG4gKiBAcmV0dXJucyB7U3RyaW5nW119XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVDbGFzc05hbWUoY2xhc3NOYW1lSW5wdXQpIHtcbiAgICBsZXQgbm9ybWFsaXplZENsYXNzZXMgPSBbXTtcblxuICAgIGlmIChOZW8uaXNTdHJpbmcoY2xhc3NOYW1lSW5wdXQpKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRDbGFzc2VzID0gY2xhc3NOYW1lSW5wdXQuc3BsaXQoJyAnKS5maWx0ZXIoQm9vbGVhbilcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2xhc3NOYW1lSW5wdXQpKSB7XG4gICAgICAgIGNsYXNzTmFtZUlucHV0LmZvckVhY2goY2xzID0+IHtcbiAgICAgICAgICAgIGlmIChOZW8uaXNTdHJpbmcoY2xzKSkge1xuICAgICAgICAgICAgICAgIGlmIChjbHMuaW5jbHVkZXMoJyAnKSkge1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkQ2xhc3Nlcy5wdXNoKC4uLmNscy5zcGxpdCgnICcpLmZpbHRlcihCb29sZWFuKSlcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNscyAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZENsYXNzZXMucHVzaChjbHMpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8vIFJlbW92ZSBkdXBsaWNhdGVzIGlmIG5lY2Vzc2FyeVxuICAgIHJldHVybiBbLi4ubmV3IFNldChub3JtYWxpemVkQ2xhc3NlcyldXG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5nYXRla2VlcChWTm9kZSwgJ05lby52ZG9tLlZOb2RlJyk7XG4iLCIvKipcbiAqIFRoZSBmb2xsb3dpbmcgdG9wLWxldmVsIGF0dHJpYnV0ZXMgd2lsbCBnZXQgY29udmVydGVkIGludG8gc3R5bGVzOlxuICogaGVpZ2h0LCBtYXhIZWlnaHQsIG1heFdpZHRoLCBtaW5IZWlnaHQsIG1pbldpZHRoLCB3aWR0aFxuICpcbiAqIFNvbWUgdGFncyBtdXN0IG5vdCBkbyB0aGUgdHJhbnNmb3JtYXRpb24sIHNvIHdlIGFkZCB0aGVtIGhlcmUuXG4gKiBAbWVtYmVyIHtTZXR9IHJhd0RpbWVuc2lvblRhZ3NcbiAqL1xuZXhwb3J0IGNvbnN0IHJhd0RpbWVuc2lvblRhZ3MgPSBuZXcgU2V0KFtcbiAgICAnY2lyY2xlJyxcbiAgICAnY2xpcFBhdGgnLFxuICAgICdlbGxpcHNlJyxcbiAgICAnZmlsdGVyJyxcbiAgICAnZm9yZWlnbk9iamVjdCcsXG4gICAgJ2ltYWdlJyxcbiAgICAnbWFya2VyJyxcbiAgICAnbWFzaycsXG4gICAgJ3BhdHRlcm4nLFxuICAgICdyZWN0JyxcbiAgICAnc3ZnJyxcbiAgICAndXNlJ1xuXSk7XG5cbi8qKlxuICogVm9pZCBhdHRyaWJ1dGVzIGluc2lkZSBodG1sIHRhZ3NcbiAqIEBtZW1iZXIge1NldH0gdm9pZEF0dHJpYnV0ZXNcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHZvaWRBdHRyaWJ1dGVzID0gbmV3IFNldChbXG4gICAgJ2NoZWNrZWQnLFxuICAgICdkZWZlcicsXG4gICAgJ2Rpc2FibGVkJyxcbiAgICAnaXNtYXAnLFxuICAgICdtdWx0aXBsZScsXG4gICAgJ25vaHJlZicsXG4gICAgJ25vcmVzaXplJyxcbiAgICAnbm9zaGFkZScsXG4gICAgJ25vd3JhcCcsXG4gICAgJ29wZW4nLFxuICAgICdyZWFkb25seScsXG4gICAgJ3JlcXVpcmVkJyxcbiAgICAncmV2ZXJzZWQnLFxuICAgICdzZWxlY3RlZCdcbl0pO1xuXG4vKipcbiAqIFZvaWQgaHRtbCB0YWdzXG4gKiBAbWVtYmVyIHtTZXR9IHZvaWRFbGVtZW50c1xuICogQHByb3RlY3RlZFxuICovXG5leHBvcnQgY29uc3Qgdm9pZEVsZW1lbnRzID0gbmV3IFNldChbXG4gICAgJ2FyZWEnLFxuICAgICdiYXNlJyxcbiAgICAnYnInLFxuICAgICdjb2wnLFxuICAgICdlbWJlZCcsXG4gICAgJ2hyJyxcbiAgICAnaW1nJyxcbiAgICAnaW5wdXQnLFxuICAgICdsaW5rJyxcbiAgICAnbWV0YScsXG4gICAgJ3BhcmFtJyxcbiAgICAnc291cmNlJyxcbiAgICAndHJhY2snLFxuICAgICd3YnInXG5dKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=