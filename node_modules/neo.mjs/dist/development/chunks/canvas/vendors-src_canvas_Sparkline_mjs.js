export const __webpack_esm_id__ = "vendors-src_canvas_Sparkline_mjs";
export const __webpack_esm_ids__ = ["vendors-src_canvas_Sparkline_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./src/canvas/Sparkline.mjs"
/*!**********************************!*\
  !*** ./src/canvas/Sparkline.mjs ***!
  \**********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/core/Base.mjs */ "./src/core/Base.mjs");


const hasRaf = typeof requestAnimationFrame === 'function';

/**
 * @summary SharedWorker renderer for the DevIndex "Living Sparklines".
 *
 * Implements a high-performance, canvas-based visualization for activity trends.
 * Unlike standard charts, these sparklines are designed to feel "alive" without consuming excessive resources.
 *
 * **Visual Architecture:**
 * 1.  **Living Sparklines:** The grid is not static. A "Pulse" effect randomly travels through different
 *     charts, creating the impression of a busy, active system ("The Server Room Effect").
 * 2.  **Sparse Animation Strategy:** Instead of animating all 50+ visible charts simultaneously (which would
 *     kill performance), a single **Master Loop** randomly selects *one* chart to animate every few seconds.
 *     This reduces the GPU load to that of a single active chart while maintaining a dynamic atmosphere.
 * 3.  **Data Packets:** The pulse is visualized as a glowing data packet traversing the timeline.
 * 4.  **Physics & Visuals:**
 *     - **Speed Normalization:** The pulse travels at constant speed along the path (Euclidean distance),
 *       regardless of slope steepness.
 *     - **Trend Coloring:** The pulse color dynamically shifts based on the local trend (Green for up, Red for down).
 *     - **Peak Flash:** A subtle halo expands when the pulse hits the all-time maximum value.
 *
 * **Interaction:**
 * -   **Mouse Scanning:** Hovering overrides the idle animation, creating a "Scanner" effect that snaps
 *     to the nearest data point and displays precise values.
 *
 * @class Neo.canvas.Sparkline
 * @extends Neo.core.Base
 * @singleton
 */
class Sparkline extends _src_core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static colors = {
        dark: {
            fillStart : 'rgba(62, 99, 221, 0.4)',
            fillEnd   : 'rgba(62, 99, 221, 0.0)',
            line      : '#3E63DD',
            marker    : '#3E63DD',
            pulseRGB  : '255, 255, 255',
            scanner   : '#FFFFFF',
            textYear  : '#AAAAAA',
            textValue : '#FFFFFF'
        },
        light: {
            fillStart : 'rgba(62, 99, 221, 0.4)',
            fillEnd   : 'rgba(62, 99, 221, 0.0)',
            line      : '#3E63DD',
            marker    : '#3E63DD',
            pulseRGB  : '62, 99, 221',
            scanner   : '#000000',
            textYear  : '#666666',
            textValue : '#000000'
        }
    }

    static config = {
        /**
         * @member {String} className='Neo.canvas.Sparkline'
         * @protected
         */
        className: 'Neo.canvas.Sparkline',
        /**
         * Remote method access
         * @member {Object} remote
         * @protected
         */
        remote: {
            app: [
                'onMouseLeave',
                'onMouseMove',
                'register',
                'unregister',
                'updateConfig',
                'updateData',
                'updateSize'
            ]
        },
        /**
         * Max concurrent data transitions allowed before snapping.
         * @member {Number} maxConcurrentTransitions=30
         */
        maxConcurrentTransitions: 30,
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * Set of currently animating items (the "Pulse" candidates).
     * @member {Set} activeItems=new Set()
     */
    activeItems = new Set()
    /**
     * Smoothed average frame time (ms).
     * @member {Number} avgFrameTime=16
     */
    avgFrameTime = 16
    /**
     * Map of registered canvas items.
     * Key: canvasId, Value: {canvas, ctx, values, points...}
     * @member {Map<String, Object>} items=new Map()
     */
    items = new Map()
    /**
     * Timestamp of the last frame.
     * @member {Number} lastFrameTime=0
     */
    lastFrameTime = 0
    /**
     * Timestamp of the last pulse spawn.
     * @member {Number} lastPulseSpawn=0
     */
    lastPulseSpawn = 0
    /**
     * Calculated stress level (avgFrameTime / 16).
     * > 1.0 means we are dropping frames.
     * @member {Number} stressLevel=0
     */
    stressLevel = 0

    /**
     * Clears the interaction overlay when mouse leaves the canvas.
     * @param {Object} data
     * @param {String} data.canvasId
     */
    onMouseLeave(data) {
        let item = this.items.get(data.canvasId);
        if (item) {
            item.mouseActive = false;
            this.draw(item) // Redraw to clear overlay
        }
    }

    /**
     * Handles mouse movement to update the "Scanner" overlay.
     * @param {Object} data
     * @param {String} data.canvasId
     * @param {Number} data.x
     * @param {Number} data.y
     */
    onMouseMove(data) {
        let item = this.items.get(data.canvasId);
        if (item) {
            item.mouseActive = true;
            item.mouseX      = data.x;
            this.draw(item)
        }
    }

    /**
     * Registers a new offscreen canvas for rendering.
     * @param {Object} data
     * @param {String} data.canvasId
     * @param {Number} [data.devicePixelRatio=1]
     * @param {String} [data.theme='light']
     * @param {Boolean} [data.usePulse=true]
     * @param {Boolean} [data.useTransition=true]
     * @param {String} data.windowId
     */
    register(data) {
        let me         = this,
            {canvasId} = data,
            canvas     = Neo.worker.Canvas.map[canvasId];

        if (canvas) {
            me.items.set(canvasId, {
                canvas,
                ctx             : canvas.getContext('2d'),
                devicePixelRatio: data.devicePixelRatio || 1,
                height          : canvas.height,
                id              : canvasId,
                mouseActive     : false,
                mouseX          : 0,
                pulseProgress   : 0,
                theme           : data.theme || 'light',
                usePulse        : data.usePulse !== false,
                useTransition   : data.useTransition !== false,
                width           : canvas.width
            });

            if (!me.animationId) {
                me.renderLoop()
            }
        }
    }

    /**
     * Unregisters a canvas.
     * @param {Object} data
     * @param {String} data.canvasId
     */
    unregister(data) {
        let me   = this,
            item = me.items.get(data.canvasId);

        if (item) {
            me.activeItems.delete(item);
            me.items.delete(data.canvasId)
        }
    }

    /**
     * Main animation loop for the "Living Sparklines" effect.
     * Implements a "Sparse Animation" strategy:
     * - Only animates a few items at a time to save performance.
     * - Randomly picks an item to "pulse" every 200ms-1.2s.
     * - Updates the animation state of active items.
     */
    renderLoop() {
        let me  = this,
            now = performance.now(); // High precision timer for frame budget

        // 0. Performance Monitoring (Adaptive Backpressure)
        if (me.lastFrameTime > 0) {
            let delta = now - me.lastFrameTime;

            // Only update average if delta is sanity-checked (ignore tab suspension pauses)
            if (delta < 500) {
                // Exponential Moving Average (alpha = 0.05 for smooth stability)
                me.avgFrameTime = (me.avgFrameTime * 0.95) + (delta * 0.05);
                me.stressLevel  = me.avgFrameTime / 16;
            }
        }
        me.lastFrameTime = now;

        // 1. Spawn new pulse?
        // Random interval between 200ms and 1.2s
        if (now - me.lastPulseSpawn > (Math.random() * 1000 + 200)) {
            let candidates = Array.from(me.items.values()).filter(item => !me.activeItems.has(item) && item.usePulse);

            if (candidates.length > 0) {
                // Pick random candidate
                let winner = candidates[Math.floor(Math.random() * candidates.length)];
                winner.pulseProgress = 0;
                me.activeItems.add(winner);
                me.lastPulseSpawn = now
            }
        }

        // 2. Animate active items
        if (me.activeItems.size > 0) {
            me.activeItems.forEach(item => {
                let needsDraw = false;

                // Handle Data Transition
                if (item.isTransitioning) {
                    let progress = (now - item.transitionStartTime) / item.transitionDuration;

                    if (progress >= 1) {
                        item.values          = item.targetValues;
                        item.isTransitioning = false;
                        progress             = 1
                    } else {
                        // Cubic Ease Out
                        progress = 1 - Math.pow(1 - progress, 3);

                        item.values = item.startValues.map((val, i) => {
                            return val + (item.targetValues[i] - val) * progress
                        })
                    }

                    item.points = null; // Force geometry recalc
                    needsDraw   = true
                }

                // Handle Pulse Animation
                // Remove from active set if usePulse got disabled mid-animation
                if (!item.usePulse && !item.isTransitioning) {
                    me.activeItems.delete(item);
                    me.draw(item); // Force redraw to clear artifacts
                    return
                }

                if (item.usePulse && !item.mouseActive) { // Pause pulse on hover? No, just render
                    // Speed: Full crossing in ~1.5s
                    item.pulseProgress += 0.015;

                    if (item.pulseProgress >= 1) {
                        item.pulseProgress = 0;
                        // Only remove if not transitioning
                        if (!item.isTransitioning) {
                            me.activeItems.delete(item);
                            me.draw(item); // Final clean draw
                            return
                        }
                    } else {
                        needsDraw = true
                    }
                }

                if (needsDraw) {
                    me.draw(item, {
                        pulseProgress: item.usePulse ? item.pulseProgress : undefined
                    })
                }
            });
        }

        if (hasRaf) {
            me.animationId = requestAnimationFrame(me.renderLoop.bind(me))
        } else {
            me.animationId = setTimeout(me.renderLoop.bind(me), 16)
        }
    }

    /**
     * Updates the configuration for a specific canvas.
     * @param {Object} data
     * @param {String} data.canvasId
     * @param {String} [data.theme]
     * @param {Boolean} [data.usePulse]
     * @param {Boolean} [data.useTransition]
     */
    updateConfig(data) {
        let me   = this,
            item = me.items.get(data.canvasId);

        if (item) {
            if (data.theme !== undefined) {
                item.theme = data.theme;
                me.draw(item)
            }
            if (data.usePulse !== undefined) {
                item.usePulse = data.usePulse
            }
            if (data.useTransition !== undefined) {
                item.useTransition = data.useTransition
            }
        }
    }

    /**
     * Updates the data values for a specific chart.
     * Invalidates the geometry cache to force a recalculation on next draw.
     * @param {Object} data
     * @param {String} data.canvasId
     * @param {Number[]} data.values
     */
    updateData(data) {
        let me   = this,
            item = me.items.get(data.canvasId);

        if (item) {
            // Adaptive Backpressure:
            // If the worker is stressed (> 16ms/frame) OR we have too many active transitions,
            // we force a "Snap" update (skip transition) to recover performance.
            let isStressed    = me.stressLevel > 1.1, // Allow small jitter (55fps)
                isOverloaded  = me.activeItems.size >= me.maxConcurrentTransitions,
                canTransition = item.useTransition && !isStressed && !isOverloaded;

            // Initial load or invalid data: snap instantly
            // Or if transitions are disabled/throttled
            if (!canTransition || !item.values || !Array.isArray(data.values) || item.values.length !== data.values.length) {
                item.values = data.values;
                item.points = null; // Invalidate cache
                me.draw(item)
            } else {
                // Start transition
                item.targetValues = data.values;
                item.startValues  = [...item.values];
                item.transitionStartTime = performance.now();
                item.transitionDuration  = 300; // ms

                if (!item.isTransitioning) {
                    item.isTransitioning = true;
                    me.activeItems.add(item);

                    if (!me.animationId) {
                        me.renderLoop()
                    }
                }
            }
        }
    }

    /**
     * Handles resize events from the main thread.
     * Updates dimensions and triggers a redraw.
     * @param {Object} data
     * @param {String} data.canvasId
     * @param {Number} [data.devicePixelRatio]
     * @param {Number} data.height
     * @param {Number} data.width
     */
    updateSize(data) {
        let me   = this,
            item = me.items.get(data.canvasId);

        if (item) {
            item.devicePixelRatio = data.devicePixelRatio || item.devicePixelRatio || 1;
            item.height           = data.height;
            item.width            = data.width;
            item.points           = null; // Invalidate cache
            me.draw(item)
        }
    }

    /**
     * The core rendering method.
     * Handles:
     * 1. **Geometry Calculation:** Caches point coordinates and path lengths for consistent speed.
     * 2. **Base Chart:** Draws the gradient area and the line stroke.
     * 3. **Scanner Overlay:** Draws the interactive cursor if `mouseActive` is true.
     * 4. **Pulse Effect:** Draws the "Data Packet" if `pulseProgress` is active.
     *
     * @param {Object} item - The canvas item state
     * @param {Object} [config] - Optional render config
     * @param {Number} [config.pulseProgress] - 0 to 1 progress for the pulse animation
     */
    draw(item, config) {
        let me            = this,
            {ctx, devicePixelRatio, height, values, width, theme} = item,
            colors        = me.constructor.colors[theme] || me.constructor.colors.light,
            pulseProgress = config?.pulseProgress;

        // Handle DPR Scaling & Clearing
        if (pulseProgress === undefined) {
            let pixelWidth  = width  * devicePixelRatio,
                pixelHeight = height * devicePixelRatio;

            // Only resize if dimensions changed (avoids context reset)
            if (item.canvas.width !== pixelWidth || item.canvas.height !== pixelHeight) {
                item.canvas.width  = pixelWidth;
                item.canvas.height = pixelHeight;
                ctx.scale(devicePixelRatio, devicePixelRatio)
            } else {
                ctx.clearRect(0, 0, width, height)
            }
        } else {
            // For pulse, we clear the canvas to redraw this frame
            ctx.clearRect(0, 0, width, height)
        }

        if (!Array.isArray(values) || values.length < 2) {
            return
        }

        let len      = values.length,
            max      = Math.max(...values),
            min      = Math.min(...values),
            range    = max - min || 1,
            paddingY = 6,
            paddingX = 4,
            h        = height - (paddingY * 2),
            w        = width  - (paddingX * 2),
            stepX    = w / (len - 1);

        // Calculate or retrieve cached points
        if (!item.points) {
            item.points = [];
            item.totalLength = 0;

            values.forEach((val, index) => {
                let normalized = (val - min) / range,
                    x = paddingX + index * stepX,
                    y = height - paddingY - (normalized * h),
                    point = {
                        x        : x,
                        y        : y,
                        val      : val,
                        year     : 2010 + index,
                        dist     : 0,
                        accumDist: 0
                    };

                if (index > 0) {
                    let prev = item.points[index - 1],
                        dx = x - prev.x,
                        dy = y - prev.y;

                    point.dist = Math.sqrt(dx * dx + dy * dy);
                    item.totalLength += point.dist;
                    point.accumDist = item.totalLength;

                    // Trend Color
                    // Up (y decreases) -> Green, Down (y increases) -> Red
                    point.color = (y < prev.y) ? '#3E63DD' : (y > prev.y) ? '#FF4444' : '#3E63DD';
                }

                item.points.push(point);
            });

            // Normalize distances
            item.points.forEach(p => {
                p.normalizedPos = p.accumDist / (item.totalLength || 1)
            });
        }

        let points = item.points;

        // 1. Draw Base Chart
        // Gradient
        let gradient = ctx.createLinearGradient(0, 0, 0, height);
        gradient.addColorStop(0, colors.fillStart);
        gradient.addColorStop(1, colors.fillEnd);

        ctx.beginPath();
        ctx.moveTo(points[0].x, height);
        ctx.lineTo(points[0].x, points[0].y);

        for (let i = 0; i < len - 1; i++) {
            let p0   = points[i],
                p1   = points[i + 1],
                midX = (p0.x + p1.x) / 2,
                midY = (p0.y + p1.y) / 2;

            if (i === len - 2) {
                ctx.quadraticCurveTo(p0.x, p0.y, p1.x, p1.y)
            } else {
                ctx.quadraticCurveTo(p0.x, p0.y, midX, midY)
            }
        }

        ctx.lineTo(points[len - 1].x, height);
        ctx.closePath();
        ctx.fillStyle = gradient;
        ctx.fill();

        // Line
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);

        for (let i = 0; i < len - 1; i++) {
            let p0   = points[i],
                p1   = points[i + 1],
                midX = (p0.x + p1.x) / 2,
                midY = (p0.y + p1.y) / 2;

            if (i === len - 2) {
                ctx.quadraticCurveTo(p0.x, p0.y, p1.x, p1.y)
            } else {
                ctx.quadraticCurveTo(p0.x, p0.y, midX, midY)
            }
        }

        ctx.strokeStyle = colors.line;
        ctx.lineWidth   = 1;
        ctx.lineCap     = 'round';
        ctx.lineJoin    = 'round';
        ctx.stroke();

        // 2. Draw Interaction Overlay
        if (item.mouseActive) {
            // Find nearest point
            let nearestDist = Infinity,
                nearestPoint = null;

            points.forEach(p => {
                let dist = Math.abs(p.x - item.mouseX);
                if (dist < nearestDist) {
                    nearestDist  = dist;
                    nearestPoint = p
                }
            });

            if (nearestPoint) {
                // Scanner Line
                ctx.beginPath();
                ctx.moveTo(nearestPoint.x, 0);
                ctx.lineTo(nearestPoint.x, height);
                ctx.strokeStyle = colors.scanner;
                ctx.lineWidth = 1;
                ctx.setLineDash([2, 2]);
                ctx.stroke();
                ctx.setLineDash([]);

                // Intersection Dot
                ctx.beginPath();
                ctx.arc(nearestPoint.x, nearestPoint.y, 3, 0, Math.PI * 2);
                ctx.fillStyle = colors.scanner;
                ctx.fill();
                ctx.beginPath();
                ctx.arc(nearestPoint.x, nearestPoint.y, 1.5, 0, Math.PI * 2);
                ctx.fillStyle = colors.line;
                ctx.fill();

                // Text Label
                ctx.font = 'bold 10px sans-serif';
                let textY = 10;
                let x = nearestPoint.x;

                // Always align left (text on right) unless near right edge
                if (x > width - 50) {
                    ctx.textAlign = 'right';
                    x -= 6
                } else {
                    ctx.textAlign = 'left';
                    x += 6
                }

                // Draw Year
                ctx.fillStyle = colors.textYear;
                ctx.fillText(String(nearestPoint.year), x, textY);

                // Draw Value
                let valueText = new Intl.NumberFormat().format(nearestPoint.val);
                ctx.fillStyle = colors.textValue;
                ctx.fillText(valueText, x, textY + 12)
            }
        } else if (pulseProgress !== undefined) {
             // 3. Draw Pulse Effect ("Data Packet")

             // A. Speed Normalization
             // Find the segment based on distance traveled (normalizedPos)
             let segmentIndex = 0;
             for (let i = 1; i < points.length; i++) {
                 if (pulseProgress <= points[i].normalizedPos) {
                     segmentIndex = i - 1;
                     break
                 }
             }

             // Interpolate within the segment
             let p0 = points[segmentIndex];
             let p1 = points[segmentIndex + 1];

             // Handle edge case where totalLength might be 0 or pulseProgress > 1
             if (!p1) {
                 p0 = points[points.length - 2];
                 p1 = points[points.length - 1]
             }

             let segmentDist = p1.normalizedPos - p0.normalizedPos;
             let segmentProgress = (segmentDist === 0) ? 0 : (pulseProgress - p0.normalizedPos) / segmentDist;

             let x = p0.x + (p1.x - p0.x) * segmentProgress;
             let y = p0.y + (p1.y - p0.y) * segmentProgress;

             // B. Trend Coloring
             // Use the color of the target point (p1)
             let pulseColor = p1.color || '#FFFFFF';

             // C. Peak Flash
             // Check if we are near the absolute max
             if (p0.val === max || p1.val === max) {
                 // Check distance to peak
                 let peak = (p0.val === max) ? p0 : p1;
                 let dx = x - peak.x;
                 let dy = y - peak.y;
                 let dist = Math.sqrt(dx*dx + dy*dy);

                 if (dist < 10) {
                     let alpha = 1 - (dist / 10);
                     ctx.beginPath();
                     ctx.arc(peak.x, peak.y, 10, 0, Math.PI * 2);
                     ctx.fillStyle = `rgba(${colors.pulseRGB}, ${alpha * 0.5})`;
                     ctx.fill()
                 }
             }

             // Draw Glow
             let gradient = ctx.createRadialGradient(x, y, 0, x, y, 6);
             gradient.addColorStop(0, `rgba(${colors.pulseRGB}, 1)`);
             gradient.addColorStop(0.4, `rgba(${colors.pulseRGB}, 0.4)`);
             gradient.addColorStop(1, `rgba(${colors.pulseRGB}, 0)`);

             ctx.beginPath();
             ctx.arc(x, y, 6, 0, Math.PI * 2);
             ctx.fillStyle = gradient;
             ctx.fill();

             // Draw Core
             ctx.beginPath();
             ctx.arc(x, y, 1.5, 0, Math.PI * 2);
             ctx.fillStyle = pulseColor; // Trend Color
             ctx.fill()
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Sparkline));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2NhbnZhcy92ZW5kb3JzLXNyY19jYW52YXNfU3BhcmtsaW5lX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBMkM7O0FBRTNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwREFBSTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQSx3Q0FBd0M7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBOztBQUVBLDBEQUEwRDtBQUMxRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGFBQWEscURBQXFEO0FBQ2xFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsYUFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUJBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGdCQUFnQixJQUFJLFlBQVk7QUFDN0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0JBQWdCO0FBQzlELGdEQUFnRCxnQkFBZ0I7QUFDaEUsOENBQThDLGdCQUFnQjs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLHlCQUF5QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jYW52YXMvU3BhcmtsaW5lLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZSBmcm9tICcuLi8uLi9zcmMvY29yZS9CYXNlLm1qcyc7XG5cbmNvbnN0IGhhc1JhZiA9IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09ICdmdW5jdGlvbic7XG5cbi8qKlxuICogQHN1bW1hcnkgU2hhcmVkV29ya2VyIHJlbmRlcmVyIGZvciB0aGUgRGV2SW5kZXggXCJMaXZpbmcgU3BhcmtsaW5lc1wiLlxuICpcbiAqIEltcGxlbWVudHMgYSBoaWdoLXBlcmZvcm1hbmNlLCBjYW52YXMtYmFzZWQgdmlzdWFsaXphdGlvbiBmb3IgYWN0aXZpdHkgdHJlbmRzLlxuICogVW5saWtlIHN0YW5kYXJkIGNoYXJ0cywgdGhlc2Ugc3BhcmtsaW5lcyBhcmUgZGVzaWduZWQgdG8gZmVlbCBcImFsaXZlXCIgd2l0aG91dCBjb25zdW1pbmcgZXhjZXNzaXZlIHJlc291cmNlcy5cbiAqXG4gKiAqKlZpc3VhbCBBcmNoaXRlY3R1cmU6KipcbiAqIDEuICAqKkxpdmluZyBTcGFya2xpbmVzOioqIFRoZSBncmlkIGlzIG5vdCBzdGF0aWMuIEEgXCJQdWxzZVwiIGVmZmVjdCByYW5kb21seSB0cmF2ZWxzIHRocm91Z2ggZGlmZmVyZW50XG4gKiAgICAgY2hhcnRzLCBjcmVhdGluZyB0aGUgaW1wcmVzc2lvbiBvZiBhIGJ1c3ksIGFjdGl2ZSBzeXN0ZW0gKFwiVGhlIFNlcnZlciBSb29tIEVmZmVjdFwiKS5cbiAqIDIuICAqKlNwYXJzZSBBbmltYXRpb24gU3RyYXRlZ3k6KiogSW5zdGVhZCBvZiBhbmltYXRpbmcgYWxsIDUwKyB2aXNpYmxlIGNoYXJ0cyBzaW11bHRhbmVvdXNseSAod2hpY2ggd291bGRcbiAqICAgICBraWxsIHBlcmZvcm1hbmNlKSwgYSBzaW5nbGUgKipNYXN0ZXIgTG9vcCoqIHJhbmRvbWx5IHNlbGVjdHMgKm9uZSogY2hhcnQgdG8gYW5pbWF0ZSBldmVyeSBmZXcgc2Vjb25kcy5cbiAqICAgICBUaGlzIHJlZHVjZXMgdGhlIEdQVSBsb2FkIHRvIHRoYXQgb2YgYSBzaW5nbGUgYWN0aXZlIGNoYXJ0IHdoaWxlIG1haW50YWluaW5nIGEgZHluYW1pYyBhdG1vc3BoZXJlLlxuICogMy4gICoqRGF0YSBQYWNrZXRzOioqIFRoZSBwdWxzZSBpcyB2aXN1YWxpemVkIGFzIGEgZ2xvd2luZyBkYXRhIHBhY2tldCB0cmF2ZXJzaW5nIHRoZSB0aW1lbGluZS5cbiAqIDQuICAqKlBoeXNpY3MgJiBWaXN1YWxzOioqXG4gKiAgICAgLSAqKlNwZWVkIE5vcm1hbGl6YXRpb246KiogVGhlIHB1bHNlIHRyYXZlbHMgYXQgY29uc3RhbnQgc3BlZWQgYWxvbmcgdGhlIHBhdGggKEV1Y2xpZGVhbiBkaXN0YW5jZSksXG4gKiAgICAgICByZWdhcmRsZXNzIG9mIHNsb3BlIHN0ZWVwbmVzcy5cbiAqICAgICAtICoqVHJlbmQgQ29sb3Jpbmc6KiogVGhlIHB1bHNlIGNvbG9yIGR5bmFtaWNhbGx5IHNoaWZ0cyBiYXNlZCBvbiB0aGUgbG9jYWwgdHJlbmQgKEdyZWVuIGZvciB1cCwgUmVkIGZvciBkb3duKS5cbiAqICAgICAtICoqUGVhayBGbGFzaDoqKiBBIHN1YnRsZSBoYWxvIGV4cGFuZHMgd2hlbiB0aGUgcHVsc2UgaGl0cyB0aGUgYWxsLXRpbWUgbWF4aW11bSB2YWx1ZS5cbiAqXG4gKiAqKkludGVyYWN0aW9uOioqXG4gKiAtICAgKipNb3VzZSBTY2FubmluZzoqKiBIb3ZlcmluZyBvdmVycmlkZXMgdGhlIGlkbGUgYW5pbWF0aW9uLCBjcmVhdGluZyBhIFwiU2Nhbm5lclwiIGVmZmVjdCB0aGF0IHNuYXBzXG4gKiAgICAgdG8gdGhlIG5lYXJlc3QgZGF0YSBwb2ludCBhbmQgZGlzcGxheXMgcHJlY2lzZSB2YWx1ZXMuXG4gKlxuICogQGNsYXNzIE5lby5jYW52YXMuU3BhcmtsaW5lXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKiBAc2luZ2xldG9uXG4gKi9cbmNsYXNzIFNwYXJrbGluZSBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb2xvcnMgPSB7XG4gICAgICAgIGRhcms6IHtcbiAgICAgICAgICAgIGZpbGxTdGFydCA6ICdyZ2JhKDYyLCA5OSwgMjIxLCAwLjQpJyxcbiAgICAgICAgICAgIGZpbGxFbmQgICA6ICdyZ2JhKDYyLCA5OSwgMjIxLCAwLjApJyxcbiAgICAgICAgICAgIGxpbmUgICAgICA6ICcjM0U2M0REJyxcbiAgICAgICAgICAgIG1hcmtlciAgICA6ICcjM0U2M0REJyxcbiAgICAgICAgICAgIHB1bHNlUkdCICA6ICcyNTUsIDI1NSwgMjU1JyxcbiAgICAgICAgICAgIHNjYW5uZXIgICA6ICcjRkZGRkZGJyxcbiAgICAgICAgICAgIHRleHRZZWFyICA6ICcjQUFBQUFBJyxcbiAgICAgICAgICAgIHRleHRWYWx1ZSA6ICcjRkZGRkZGJ1xuICAgICAgICB9LFxuICAgICAgICBsaWdodDoge1xuICAgICAgICAgICAgZmlsbFN0YXJ0IDogJ3JnYmEoNjIsIDk5LCAyMjEsIDAuNCknLFxuICAgICAgICAgICAgZmlsbEVuZCAgIDogJ3JnYmEoNjIsIDk5LCAyMjEsIDAuMCknLFxuICAgICAgICAgICAgbGluZSAgICAgIDogJyMzRTYzREQnLFxuICAgICAgICAgICAgbWFya2VyICAgIDogJyMzRTYzREQnLFxuICAgICAgICAgICAgcHVsc2VSR0IgIDogJzYyLCA5OSwgMjIxJyxcbiAgICAgICAgICAgIHNjYW5uZXIgICA6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgIHRleHRZZWFyICA6ICcjNjY2NjY2JyxcbiAgICAgICAgICAgIHRleHRWYWx1ZSA6ICcjMDAwMDAwJ1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY2FudmFzLlNwYXJrbGluZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNhbnZhcy5TcGFya2xpbmUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3RlIG1ldGhvZCBhY2Nlc3NcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSByZW1vdGVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3RlOiB7XG4gICAgICAgICAgICBhcHA6IFtcbiAgICAgICAgICAgICAgICAnb25Nb3VzZUxlYXZlJyxcbiAgICAgICAgICAgICAgICAnb25Nb3VzZU1vdmUnLFxuICAgICAgICAgICAgICAgICdyZWdpc3RlcicsXG4gICAgICAgICAgICAgICAgJ3VucmVnaXN0ZXInLFxuICAgICAgICAgICAgICAgICd1cGRhdGVDb25maWcnLFxuICAgICAgICAgICAgICAgICd1cGRhdGVEYXRhJyxcbiAgICAgICAgICAgICAgICAndXBkYXRlU2l6ZSdcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1heCBjb25jdXJyZW50IGRhdGEgdHJhbnNpdGlvbnMgYWxsb3dlZCBiZWZvcmUgc25hcHBpbmcuXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gbWF4Q29uY3VycmVudFRyYW5zaXRpb25zPTMwXG4gICAgICAgICAqL1xuICAgICAgICBtYXhDb25jdXJyZW50VHJhbnNpdGlvbnM6IDMwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2luZ2xldG9uPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2luZ2xldG9uOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IG9mIGN1cnJlbnRseSBhbmltYXRpbmcgaXRlbXMgKHRoZSBcIlB1bHNlXCIgY2FuZGlkYXRlcykuXG4gICAgICogQG1lbWJlciB7U2V0fSBhY3RpdmVJdGVtcz1uZXcgU2V0KClcbiAgICAgKi9cbiAgICBhY3RpdmVJdGVtcyA9IG5ldyBTZXQoKVxuICAgIC8qKlxuICAgICAqIFNtb290aGVkIGF2ZXJhZ2UgZnJhbWUgdGltZSAobXMpLlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gYXZnRnJhbWVUaW1lPTE2XG4gICAgICovXG4gICAgYXZnRnJhbWVUaW1lID0gMTZcbiAgICAvKipcbiAgICAgKiBNYXAgb2YgcmVnaXN0ZXJlZCBjYW52YXMgaXRlbXMuXG4gICAgICogS2V5OiBjYW52YXNJZCwgVmFsdWU6IHtjYW52YXMsIGN0eCwgdmFsdWVzLCBwb2ludHMuLi59XG4gICAgICogQG1lbWJlciB7TWFwPFN0cmluZywgT2JqZWN0Pn0gaXRlbXM9bmV3IE1hcCgpXG4gICAgICovXG4gICAgaXRlbXMgPSBuZXcgTWFwKClcbiAgICAvKipcbiAgICAgKiBUaW1lc3RhbXAgb2YgdGhlIGxhc3QgZnJhbWUuXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSBsYXN0RnJhbWVUaW1lPTBcbiAgICAgKi9cbiAgICBsYXN0RnJhbWVUaW1lID0gMFxuICAgIC8qKlxuICAgICAqIFRpbWVzdGFtcCBvZiB0aGUgbGFzdCBwdWxzZSBzcGF3bi5cbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGxhc3RQdWxzZVNwYXduPTBcbiAgICAgKi9cbiAgICBsYXN0UHVsc2VTcGF3biA9IDBcbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVkIHN0cmVzcyBsZXZlbCAoYXZnRnJhbWVUaW1lIC8gMTYpLlxuICAgICAqID4gMS4wIG1lYW5zIHdlIGFyZSBkcm9wcGluZyBmcmFtZXMuXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSBzdHJlc3NMZXZlbD0wXG4gICAgICovXG4gICAgc3RyZXNzTGV2ZWwgPSAwXG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGludGVyYWN0aW9uIG92ZXJsYXkgd2hlbiBtb3VzZSBsZWF2ZXMgdGhlIGNhbnZhcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmNhbnZhc0lkXG4gICAgICovXG4gICAgb25Nb3VzZUxlYXZlKGRhdGEpIHtcbiAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLml0ZW1zLmdldChkYXRhLmNhbnZhc0lkKTtcbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIGl0ZW0ubW91c2VBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZHJhdyhpdGVtKSAvLyBSZWRyYXcgdG8gY2xlYXIgb3ZlcmxheVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBtb3VzZSBtb3ZlbWVudCB0byB1cGRhdGUgdGhlIFwiU2Nhbm5lclwiIG92ZXJsYXkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5jYW52YXNJZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLnhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS55XG4gICAgICovXG4gICAgb25Nb3VzZU1vdmUoZGF0YSkge1xuICAgICAgICBsZXQgaXRlbSA9IHRoaXMuaXRlbXMuZ2V0KGRhdGEuY2FudmFzSWQpO1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgaXRlbS5tb3VzZUFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICBpdGVtLm1vdXNlWCAgICAgID0gZGF0YS54O1xuICAgICAgICAgICAgdGhpcy5kcmF3KGl0ZW0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBuZXcgb2Zmc2NyZWVuIGNhbnZhcyBmb3IgcmVuZGVyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuY2FudmFzSWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2RhdGEuZGV2aWNlUGl4ZWxSYXRpbz0xXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZGF0YS50aGVtZT0nbGlnaHQnXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2RhdGEudXNlUHVsc2U9dHJ1ZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkYXRhLnVzZVRyYW5zaXRpb249dHJ1ZV1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS53aW5kb3dJZFxuICAgICAqL1xuICAgIHJlZ2lzdGVyKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2NhbnZhc0lkfSA9IGRhdGEsXG4gICAgICAgICAgICBjYW52YXMgICAgID0gTmVvLndvcmtlci5DYW52YXMubWFwW2NhbnZhc0lkXTtcblxuICAgICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgICAgICBtZS5pdGVtcy5zZXQoY2FudmFzSWQsIHtcbiAgICAgICAgICAgICAgICBjYW52YXMsXG4gICAgICAgICAgICAgICAgY3R4ICAgICAgICAgICAgIDogY2FudmFzLmdldENvbnRleHQoJzJkJyksXG4gICAgICAgICAgICAgICAgZGV2aWNlUGl4ZWxSYXRpbzogZGF0YS5kZXZpY2VQaXhlbFJhdGlvIHx8IDEsXG4gICAgICAgICAgICAgICAgaGVpZ2h0ICAgICAgICAgIDogY2FudmFzLmhlaWdodCxcbiAgICAgICAgICAgICAgICBpZCAgICAgICAgICAgICAgOiBjYW52YXNJZCxcbiAgICAgICAgICAgICAgICBtb3VzZUFjdGl2ZSAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtb3VzZVggICAgICAgICAgOiAwLFxuICAgICAgICAgICAgICAgIHB1bHNlUHJvZ3Jlc3MgICA6IDAsXG4gICAgICAgICAgICAgICAgdGhlbWUgICAgICAgICAgIDogZGF0YS50aGVtZSB8fCAnbGlnaHQnLFxuICAgICAgICAgICAgICAgIHVzZVB1bHNlICAgICAgICA6IGRhdGEudXNlUHVsc2UgIT09IGZhbHNlLFxuICAgICAgICAgICAgICAgIHVzZVRyYW5zaXRpb24gICA6IGRhdGEudXNlVHJhbnNpdGlvbiAhPT0gZmFsc2UsXG4gICAgICAgICAgICAgICAgd2lkdGggICAgICAgICAgIDogY2FudmFzLndpZHRoXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFtZS5hbmltYXRpb25JZCkge1xuICAgICAgICAgICAgICAgIG1lLnJlbmRlckxvb3AoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5yZWdpc3RlcnMgYSBjYW52YXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5jYW52YXNJZFxuICAgICAqL1xuICAgIHVucmVnaXN0ZXIoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtID0gbWUuaXRlbXMuZ2V0KGRhdGEuY2FudmFzSWQpO1xuXG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICBtZS5hY3RpdmVJdGVtcy5kZWxldGUoaXRlbSk7XG4gICAgICAgICAgICBtZS5pdGVtcy5kZWxldGUoZGF0YS5jYW52YXNJZClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1haW4gYW5pbWF0aW9uIGxvb3AgZm9yIHRoZSBcIkxpdmluZyBTcGFya2xpbmVzXCIgZWZmZWN0LlxuICAgICAqIEltcGxlbWVudHMgYSBcIlNwYXJzZSBBbmltYXRpb25cIiBzdHJhdGVneTpcbiAgICAgKiAtIE9ubHkgYW5pbWF0ZXMgYSBmZXcgaXRlbXMgYXQgYSB0aW1lIHRvIHNhdmUgcGVyZm9ybWFuY2UuXG4gICAgICogLSBSYW5kb21seSBwaWNrcyBhbiBpdGVtIHRvIFwicHVsc2VcIiBldmVyeSAyMDBtcy0xLjJzLlxuICAgICAqIC0gVXBkYXRlcyB0aGUgYW5pbWF0aW9uIHN0YXRlIG9mIGFjdGl2ZSBpdGVtcy5cbiAgICAgKi9cbiAgICByZW5kZXJMb29wKCkge1xuICAgICAgICBsZXQgbWUgID0gdGhpcyxcbiAgICAgICAgICAgIG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpOyAvLyBIaWdoIHByZWNpc2lvbiB0aW1lciBmb3IgZnJhbWUgYnVkZ2V0XG5cbiAgICAgICAgLy8gMC4gUGVyZm9ybWFuY2UgTW9uaXRvcmluZyAoQWRhcHRpdmUgQmFja3ByZXNzdXJlKVxuICAgICAgICBpZiAobWUubGFzdEZyYW1lVGltZSA+IDApIHtcbiAgICAgICAgICAgIGxldCBkZWx0YSA9IG5vdyAtIG1lLmxhc3RGcmFtZVRpbWU7XG5cbiAgICAgICAgICAgIC8vIE9ubHkgdXBkYXRlIGF2ZXJhZ2UgaWYgZGVsdGEgaXMgc2FuaXR5LWNoZWNrZWQgKGlnbm9yZSB0YWIgc3VzcGVuc2lvbiBwYXVzZXMpXG4gICAgICAgICAgICBpZiAoZGVsdGEgPCA1MDApIHtcbiAgICAgICAgICAgICAgICAvLyBFeHBvbmVudGlhbCBNb3ZpbmcgQXZlcmFnZSAoYWxwaGEgPSAwLjA1IGZvciBzbW9vdGggc3RhYmlsaXR5KVxuICAgICAgICAgICAgICAgIG1lLmF2Z0ZyYW1lVGltZSA9IChtZS5hdmdGcmFtZVRpbWUgKiAwLjk1KSArIChkZWx0YSAqIDAuMDUpO1xuICAgICAgICAgICAgICAgIG1lLnN0cmVzc0xldmVsICA9IG1lLmF2Z0ZyYW1lVGltZSAvIDE2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1lLmxhc3RGcmFtZVRpbWUgPSBub3c7XG5cbiAgICAgICAgLy8gMS4gU3Bhd24gbmV3IHB1bHNlP1xuICAgICAgICAvLyBSYW5kb20gaW50ZXJ2YWwgYmV0d2VlbiAyMDBtcyBhbmQgMS4yc1xuICAgICAgICBpZiAobm93IC0gbWUubGFzdFB1bHNlU3Bhd24gPiAoTWF0aC5yYW5kb20oKSAqIDEwMDAgKyAyMDApKSB7XG4gICAgICAgICAgICBsZXQgY2FuZGlkYXRlcyA9IEFycmF5LmZyb20obWUuaXRlbXMudmFsdWVzKCkpLmZpbHRlcihpdGVtID0+ICFtZS5hY3RpdmVJdGVtcy5oYXMoaXRlbSkgJiYgaXRlbS51c2VQdWxzZSk7XG5cbiAgICAgICAgICAgIGlmIChjYW5kaWRhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBQaWNrIHJhbmRvbSBjYW5kaWRhdGVcbiAgICAgICAgICAgICAgICBsZXQgd2lubmVyID0gY2FuZGlkYXRlc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjYW5kaWRhdGVzLmxlbmd0aCldO1xuICAgICAgICAgICAgICAgIHdpbm5lci5wdWxzZVByb2dyZXNzID0gMDtcbiAgICAgICAgICAgICAgICBtZS5hY3RpdmVJdGVtcy5hZGQod2lubmVyKTtcbiAgICAgICAgICAgICAgICBtZS5sYXN0UHVsc2VTcGF3biA9IG5vd1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gMi4gQW5pbWF0ZSBhY3RpdmUgaXRlbXNcbiAgICAgICAgaWYgKG1lLmFjdGl2ZUl0ZW1zLnNpemUgPiAwKSB7XG4gICAgICAgICAgICBtZS5hY3RpdmVJdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIGxldCBuZWVkc0RyYXcgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBEYXRhIFRyYW5zaXRpb25cbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5pc1RyYW5zaXRpb25pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByb2dyZXNzID0gKG5vdyAtIGl0ZW0udHJhbnNpdGlvblN0YXJ0VGltZSkgLyBpdGVtLnRyYW5zaXRpb25EdXJhdGlvbjtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvZ3Jlc3MgPj0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS52YWx1ZXMgICAgICAgICAgPSBpdGVtLnRhcmdldFZhbHVlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uaXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzcyAgICAgICAgICAgICA9IDFcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEN1YmljIEVhc2UgT3V0XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzcyA9IDEgLSBNYXRoLnBvdygxIC0gcHJvZ3Jlc3MsIDMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnZhbHVlcyA9IGl0ZW0uc3RhcnRWYWx1ZXMubWFwKCh2YWwsIGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsICsgKGl0ZW0udGFyZ2V0VmFsdWVzW2ldIC0gdmFsKSAqIHByb2dyZXNzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaXRlbS5wb2ludHMgPSBudWxsOyAvLyBGb3JjZSBnZW9tZXRyeSByZWNhbGNcbiAgICAgICAgICAgICAgICAgICAgbmVlZHNEcmF3ICAgPSB0cnVlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIFB1bHNlIEFuaW1hdGlvblxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIGFjdGl2ZSBzZXQgaWYgdXNlUHVsc2UgZ290IGRpc2FibGVkIG1pZC1hbmltYXRpb25cbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0udXNlUHVsc2UgJiYgIWl0ZW0uaXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmFjdGl2ZUl0ZW1zLmRlbGV0ZShpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgbWUuZHJhdyhpdGVtKTsgLy8gRm9yY2UgcmVkcmF3IHRvIGNsZWFyIGFydGlmYWN0c1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbS51c2VQdWxzZSAmJiAhaXRlbS5tb3VzZUFjdGl2ZSkgeyAvLyBQYXVzZSBwdWxzZSBvbiBob3Zlcj8gTm8sIGp1c3QgcmVuZGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNwZWVkOiBGdWxsIGNyb3NzaW5nIGluIH4xLjVzXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0ucHVsc2VQcm9ncmVzcyArPSAwLjAxNTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5wdWxzZVByb2dyZXNzID49IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ucHVsc2VQcm9ncmVzcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHJlbW92ZSBpZiBub3QgdHJhbnNpdGlvbmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtLmlzVHJhbnNpdGlvbmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLmFjdGl2ZUl0ZW1zLmRlbGV0ZShpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5kcmF3KGl0ZW0pOyAvLyBGaW5hbCBjbGVhbiBkcmF3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZWVkc0RyYXcgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobmVlZHNEcmF3KSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmRyYXcoaXRlbSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHVsc2VQcm9ncmVzczogaXRlbS51c2VQdWxzZSA/IGl0ZW0ucHVsc2VQcm9ncmVzcyA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc1JhZikge1xuICAgICAgICAgICAgbWUuYW5pbWF0aW9uSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobWUucmVuZGVyTG9vcC5iaW5kKG1lKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLmFuaW1hdGlvbklkID0gc2V0VGltZW91dChtZS5yZW5kZXJMb29wLmJpbmQobWUpLCAxNilcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGNvbmZpZ3VyYXRpb24gZm9yIGEgc3BlY2lmaWMgY2FudmFzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuY2FudmFzSWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2RhdGEudGhlbWVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZGF0YS51c2VQdWxzZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkYXRhLnVzZVRyYW5zaXRpb25dXG4gICAgICovXG4gICAgdXBkYXRlQ29uZmlnKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbSA9IG1lLml0ZW1zLmdldChkYXRhLmNhbnZhc0lkKTtcblxuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgaWYgKGRhdGEudGhlbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGl0ZW0udGhlbWUgPSBkYXRhLnRoZW1lO1xuICAgICAgICAgICAgICAgIG1lLmRyYXcoaXRlbSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLnVzZVB1bHNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpdGVtLnVzZVB1bHNlID0gZGF0YS51c2VQdWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEudXNlVHJhbnNpdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaXRlbS51c2VUcmFuc2l0aW9uID0gZGF0YS51c2VUcmFuc2l0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBkYXRhIHZhbHVlcyBmb3IgYSBzcGVjaWZpYyBjaGFydC5cbiAgICAgKiBJbnZhbGlkYXRlcyB0aGUgZ2VvbWV0cnkgY2FjaGUgdG8gZm9yY2UgYSByZWNhbGN1bGF0aW9uIG9uIG5leHQgZHJhdy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmNhbnZhc0lkXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0gZGF0YS52YWx1ZXNcbiAgICAgKi9cbiAgICB1cGRhdGVEYXRhKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbSA9IG1lLml0ZW1zLmdldChkYXRhLmNhbnZhc0lkKTtcblxuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgLy8gQWRhcHRpdmUgQmFja3ByZXNzdXJlOlxuICAgICAgICAgICAgLy8gSWYgdGhlIHdvcmtlciBpcyBzdHJlc3NlZCAoPiAxNm1zL2ZyYW1lKSBPUiB3ZSBoYXZlIHRvbyBtYW55IGFjdGl2ZSB0cmFuc2l0aW9ucyxcbiAgICAgICAgICAgIC8vIHdlIGZvcmNlIGEgXCJTbmFwXCIgdXBkYXRlIChza2lwIHRyYW5zaXRpb24pIHRvIHJlY292ZXIgcGVyZm9ybWFuY2UuXG4gICAgICAgICAgICBsZXQgaXNTdHJlc3NlZCAgICA9IG1lLnN0cmVzc0xldmVsID4gMS4xLCAvLyBBbGxvdyBzbWFsbCBqaXR0ZXIgKDU1ZnBzKVxuICAgICAgICAgICAgICAgIGlzT3ZlcmxvYWRlZCAgPSBtZS5hY3RpdmVJdGVtcy5zaXplID49IG1lLm1heENvbmN1cnJlbnRUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgICAgICBjYW5UcmFuc2l0aW9uID0gaXRlbS51c2VUcmFuc2l0aW9uICYmICFpc1N0cmVzc2VkICYmICFpc092ZXJsb2FkZWQ7XG5cbiAgICAgICAgICAgIC8vIEluaXRpYWwgbG9hZCBvciBpbnZhbGlkIGRhdGE6IHNuYXAgaW5zdGFudGx5XG4gICAgICAgICAgICAvLyBPciBpZiB0cmFuc2l0aW9ucyBhcmUgZGlzYWJsZWQvdGhyb3R0bGVkXG4gICAgICAgICAgICBpZiAoIWNhblRyYW5zaXRpb24gfHwgIWl0ZW0udmFsdWVzIHx8ICFBcnJheS5pc0FycmF5KGRhdGEudmFsdWVzKSB8fCBpdGVtLnZhbHVlcy5sZW5ndGggIT09IGRhdGEudmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGl0ZW0udmFsdWVzID0gZGF0YS52YWx1ZXM7XG4gICAgICAgICAgICAgICAgaXRlbS5wb2ludHMgPSBudWxsOyAvLyBJbnZhbGlkYXRlIGNhY2hlXG4gICAgICAgICAgICAgICAgbWUuZHJhdyhpdGVtKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTdGFydCB0cmFuc2l0aW9uXG4gICAgICAgICAgICAgICAgaXRlbS50YXJnZXRWYWx1ZXMgPSBkYXRhLnZhbHVlcztcbiAgICAgICAgICAgICAgICBpdGVtLnN0YXJ0VmFsdWVzICA9IFsuLi5pdGVtLnZhbHVlc107XG4gICAgICAgICAgICAgICAgaXRlbS50cmFuc2l0aW9uU3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICAgICAgaXRlbS50cmFuc2l0aW9uRHVyYXRpb24gID0gMzAwOyAvLyBtc1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtLmlzVHJhbnNpdGlvbmluZykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmlzVHJhbnNpdGlvbmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG1lLmFjdGl2ZUl0ZW1zLmFkZChpdGVtKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIW1lLmFuaW1hdGlvbklkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5yZW5kZXJMb29wKClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgcmVzaXplIGV2ZW50cyBmcm9tIHRoZSBtYWluIHRocmVhZC5cbiAgICAgKiBVcGRhdGVzIGRpbWVuc2lvbnMgYW5kIHRyaWdnZXJzIGEgcmVkcmF3LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuY2FudmFzSWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2RhdGEuZGV2aWNlUGl4ZWxSYXRpb11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5oZWlnaHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS53aWR0aFxuICAgICAqL1xuICAgIHVwZGF0ZVNpemUoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtID0gbWUuaXRlbXMuZ2V0KGRhdGEuY2FudmFzSWQpO1xuXG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICBpdGVtLmRldmljZVBpeGVsUmF0aW8gPSBkYXRhLmRldmljZVBpeGVsUmF0aW8gfHwgaXRlbS5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgICAgICAgICBpdGVtLmhlaWdodCAgICAgICAgICAgPSBkYXRhLmhlaWdodDtcbiAgICAgICAgICAgIGl0ZW0ud2lkdGggICAgICAgICAgICA9IGRhdGEud2lkdGg7XG4gICAgICAgICAgICBpdGVtLnBvaW50cyAgICAgICAgICAgPSBudWxsOyAvLyBJbnZhbGlkYXRlIGNhY2hlXG4gICAgICAgICAgICBtZS5kcmF3KGl0ZW0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29yZSByZW5kZXJpbmcgbWV0aG9kLlxuICAgICAqIEhhbmRsZXM6XG4gICAgICogMS4gKipHZW9tZXRyeSBDYWxjdWxhdGlvbjoqKiBDYWNoZXMgcG9pbnQgY29vcmRpbmF0ZXMgYW5kIHBhdGggbGVuZ3RocyBmb3IgY29uc2lzdGVudCBzcGVlZC5cbiAgICAgKiAyLiAqKkJhc2UgQ2hhcnQ6KiogRHJhd3MgdGhlIGdyYWRpZW50IGFyZWEgYW5kIHRoZSBsaW5lIHN0cm9rZS5cbiAgICAgKiAzLiAqKlNjYW5uZXIgT3ZlcmxheToqKiBEcmF3cyB0aGUgaW50ZXJhY3RpdmUgY3Vyc29yIGlmIGBtb3VzZUFjdGl2ZWAgaXMgdHJ1ZS5cbiAgICAgKiA0LiAqKlB1bHNlIEVmZmVjdDoqKiBEcmF3cyB0aGUgXCJEYXRhIFBhY2tldFwiIGlmIGBwdWxzZVByb2dyZXNzYCBpcyBhY3RpdmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbSAtIFRoZSBjYW52YXMgaXRlbSBzdGF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSAtIE9wdGlvbmFsIHJlbmRlciBjb25maWdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5wdWxzZVByb2dyZXNzXSAtIDAgdG8gMSBwcm9ncmVzcyBmb3IgdGhlIHB1bHNlIGFuaW1hdGlvblxuICAgICAqL1xuICAgIGRyYXcoaXRlbSwgY29uZmlnKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjdHgsIGRldmljZVBpeGVsUmF0aW8sIGhlaWdodCwgdmFsdWVzLCB3aWR0aCwgdGhlbWV9ID0gaXRlbSxcbiAgICAgICAgICAgIGNvbG9ycyAgICAgICAgPSBtZS5jb25zdHJ1Y3Rvci5jb2xvcnNbdGhlbWVdIHx8IG1lLmNvbnN0cnVjdG9yLmNvbG9ycy5saWdodCxcbiAgICAgICAgICAgIHB1bHNlUHJvZ3Jlc3MgPSBjb25maWc/LnB1bHNlUHJvZ3Jlc3M7XG5cbiAgICAgICAgLy8gSGFuZGxlIERQUiBTY2FsaW5nICYgQ2xlYXJpbmdcbiAgICAgICAgaWYgKHB1bHNlUHJvZ3Jlc3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IHBpeGVsV2lkdGggID0gd2lkdGggICogZGV2aWNlUGl4ZWxSYXRpbyxcbiAgICAgICAgICAgICAgICBwaXhlbEhlaWdodCA9IGhlaWdodCAqIGRldmljZVBpeGVsUmF0aW87XG5cbiAgICAgICAgICAgIC8vIE9ubHkgcmVzaXplIGlmIGRpbWVuc2lvbnMgY2hhbmdlZCAoYXZvaWRzIGNvbnRleHQgcmVzZXQpXG4gICAgICAgICAgICBpZiAoaXRlbS5jYW52YXMud2lkdGggIT09IHBpeGVsV2lkdGggfHwgaXRlbS5jYW52YXMuaGVpZ2h0ICE9PSBwaXhlbEhlaWdodCkge1xuICAgICAgICAgICAgICAgIGl0ZW0uY2FudmFzLndpZHRoICA9IHBpeGVsV2lkdGg7XG4gICAgICAgICAgICAgICAgaXRlbS5jYW52YXMuaGVpZ2h0ID0gcGl4ZWxIZWlnaHQ7XG4gICAgICAgICAgICAgICAgY3R4LnNjYWxlKGRldmljZVBpeGVsUmF0aW8sIGRldmljZVBpeGVsUmF0aW8pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZvciBwdWxzZSwgd2UgY2xlYXIgdGhlIGNhbnZhcyB0byByZWRyYXcgdGhpcyBmcmFtZVxuICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykgfHwgdmFsdWVzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGxlbiAgICAgID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgICAgIG1heCAgICAgID0gTWF0aC5tYXgoLi4udmFsdWVzKSxcbiAgICAgICAgICAgIG1pbiAgICAgID0gTWF0aC5taW4oLi4udmFsdWVzKSxcbiAgICAgICAgICAgIHJhbmdlICAgID0gbWF4IC0gbWluIHx8IDEsXG4gICAgICAgICAgICBwYWRkaW5nWSA9IDYsXG4gICAgICAgICAgICBwYWRkaW5nWCA9IDQsXG4gICAgICAgICAgICBoICAgICAgICA9IGhlaWdodCAtIChwYWRkaW5nWSAqIDIpLFxuICAgICAgICAgICAgdyAgICAgICAgPSB3aWR0aCAgLSAocGFkZGluZ1ggKiAyKSxcbiAgICAgICAgICAgIHN0ZXBYICAgID0gdyAvIChsZW4gLSAxKTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgb3IgcmV0cmlldmUgY2FjaGVkIHBvaW50c1xuICAgICAgICBpZiAoIWl0ZW0ucG9pbnRzKSB7XG4gICAgICAgICAgICBpdGVtLnBvaW50cyA9IFtdO1xuICAgICAgICAgICAgaXRlbS50b3RhbExlbmd0aCA9IDA7XG5cbiAgICAgICAgICAgIHZhbHVlcy5mb3JFYWNoKCh2YWwsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG5vcm1hbGl6ZWQgPSAodmFsIC0gbWluKSAvIHJhbmdlLFxuICAgICAgICAgICAgICAgICAgICB4ID0gcGFkZGluZ1ggKyBpbmRleCAqIHN0ZXBYLFxuICAgICAgICAgICAgICAgICAgICB5ID0gaGVpZ2h0IC0gcGFkZGluZ1kgLSAobm9ybWFsaXplZCAqIGgpLFxuICAgICAgICAgICAgICAgICAgICBwb2ludCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggICAgICAgIDogeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgICAgICAgIDogeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCAgICAgIDogdmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgeWVhciAgICAgOiAyMDEwICsgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXN0ICAgICA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY2N1bURpc3Q6IDBcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByZXYgPSBpdGVtLnBvaW50c1tpbmRleCAtIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHggPSB4IC0gcHJldi54LFxuICAgICAgICAgICAgICAgICAgICAgICAgZHkgPSB5IC0gcHJldi55O1xuXG4gICAgICAgICAgICAgICAgICAgIHBvaW50LmRpc3QgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnRvdGFsTGVuZ3RoICs9IHBvaW50LmRpc3Q7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50LmFjY3VtRGlzdCA9IGl0ZW0udG90YWxMZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVHJlbmQgQ29sb3JcbiAgICAgICAgICAgICAgICAgICAgLy8gVXAgKHkgZGVjcmVhc2VzKSAtPiBHcmVlbiwgRG93biAoeSBpbmNyZWFzZXMpIC0+IFJlZFxuICAgICAgICAgICAgICAgICAgICBwb2ludC5jb2xvciA9ICh5IDwgcHJldi55KSA/ICcjM0U2M0REJyA6ICh5ID4gcHJldi55KSA/ICcjRkY0NDQ0JyA6ICcjM0U2M0REJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpdGVtLnBvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgZGlzdGFuY2VzXG4gICAgICAgICAgICBpdGVtLnBvaW50cy5mb3JFYWNoKHAgPT4ge1xuICAgICAgICAgICAgICAgIHAubm9ybWFsaXplZFBvcyA9IHAuYWNjdW1EaXN0IC8gKGl0ZW0udG90YWxMZW5ndGggfHwgMSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHBvaW50cyA9IGl0ZW0ucG9pbnRzO1xuXG4gICAgICAgIC8vIDEuIERyYXcgQmFzZSBDaGFydFxuICAgICAgICAvLyBHcmFkaWVudFxuICAgICAgICBsZXQgZ3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgMCwgMCwgaGVpZ2h0KTtcbiAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsIGNvbG9ycy5maWxsU3RhcnQpO1xuICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgY29sb3JzLmZpbGxFbmQpO1xuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhwb2ludHNbMF0ueCwgaGVpZ2h0KTtcbiAgICAgICAgY3R4LmxpbmVUbyhwb2ludHNbMF0ueCwgcG9pbnRzWzBdLnkpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcDAgICA9IHBvaW50c1tpXSxcbiAgICAgICAgICAgICAgICBwMSAgID0gcG9pbnRzW2kgKyAxXSxcbiAgICAgICAgICAgICAgICBtaWRYID0gKHAwLnggKyBwMS54KSAvIDIsXG4gICAgICAgICAgICAgICAgbWlkWSA9IChwMC55ICsgcDEueSkgLyAyO1xuXG4gICAgICAgICAgICBpZiAoaSA9PT0gbGVuIC0gMikge1xuICAgICAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHAwLngsIHAwLnksIHAxLngsIHAxLnkpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHAwLngsIHAwLnksIG1pZFgsIG1pZFkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjdHgubGluZVRvKHBvaW50c1tsZW4gLSAxXS54LCBoZWlnaHQpO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBncmFkaWVudDtcbiAgICAgICAgY3R4LmZpbGwoKTtcblxuICAgICAgICAvLyBMaW5lXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhwb2ludHNbMF0ueCwgcG9pbnRzWzBdLnkpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcDAgICA9IHBvaW50c1tpXSxcbiAgICAgICAgICAgICAgICBwMSAgID0gcG9pbnRzW2kgKyAxXSxcbiAgICAgICAgICAgICAgICBtaWRYID0gKHAwLnggKyBwMS54KSAvIDIsXG4gICAgICAgICAgICAgICAgbWlkWSA9IChwMC55ICsgcDEueSkgLyAyO1xuXG4gICAgICAgICAgICBpZiAoaSA9PT0gbGVuIC0gMikge1xuICAgICAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHAwLngsIHAwLnksIHAxLngsIHAxLnkpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHAwLngsIHAwLnksIG1pZFgsIG1pZFkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcnMubGluZTtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCAgID0gMTtcbiAgICAgICAgY3R4LmxpbmVDYXAgICAgID0gJ3JvdW5kJztcbiAgICAgICAgY3R4LmxpbmVKb2luICAgID0gJ3JvdW5kJztcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgIC8vIDIuIERyYXcgSW50ZXJhY3Rpb24gT3ZlcmxheVxuICAgICAgICBpZiAoaXRlbS5tb3VzZUFjdGl2ZSkge1xuICAgICAgICAgICAgLy8gRmluZCBuZWFyZXN0IHBvaW50XG4gICAgICAgICAgICBsZXQgbmVhcmVzdERpc3QgPSBJbmZpbml0eSxcbiAgICAgICAgICAgICAgICBuZWFyZXN0UG9pbnQgPSBudWxsO1xuXG4gICAgICAgICAgICBwb2ludHMuZm9yRWFjaChwID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZGlzdCA9IE1hdGguYWJzKHAueCAtIGl0ZW0ubW91c2VYKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlzdCA8IG5lYXJlc3REaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5lYXJlc3REaXN0ICA9IGRpc3Q7XG4gICAgICAgICAgICAgICAgICAgIG5lYXJlc3RQb2ludCA9IHBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKG5lYXJlc3RQb2ludCkge1xuICAgICAgICAgICAgICAgIC8vIFNjYW5uZXIgTGluZVxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKG5lYXJlc3RQb2ludC54LCAwKTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKG5lYXJlc3RQb2ludC54LCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9ycy5zY2FubmVyO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgICAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChbMiwgMl0pO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICBjdHguc2V0TGluZURhc2goW10pO1xuXG4gICAgICAgICAgICAgICAgLy8gSW50ZXJzZWN0aW9uIERvdFxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHguYXJjKG5lYXJlc3RQb2ludC54LCBuZWFyZXN0UG9pbnQueSwgMywgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcnMuc2Nhbm5lcjtcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHguYXJjKG5lYXJlc3RQb2ludC54LCBuZWFyZXN0UG9pbnQueSwgMS41LCAwLCBNYXRoLlBJICogMik7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9ycy5saW5lO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBUZXh0IExhYmVsXG4gICAgICAgICAgICAgICAgY3R4LmZvbnQgPSAnYm9sZCAxMHB4IHNhbnMtc2VyaWYnO1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0WSA9IDEwO1xuICAgICAgICAgICAgICAgIGxldCB4ID0gbmVhcmVzdFBvaW50Lng7XG5cbiAgICAgICAgICAgICAgICAvLyBBbHdheXMgYWxpZ24gbGVmdCAodGV4dCBvbiByaWdodCkgdW5sZXNzIG5lYXIgcmlnaHQgZWRnZVxuICAgICAgICAgICAgICAgIGlmICh4ID4gd2lkdGggLSA1MCkge1xuICAgICAgICAgICAgICAgICAgICBjdHgudGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICAgICAgeCAtPSA2XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICAgICAgeCArPSA2XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRHJhdyBZZWFyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9ycy50ZXh0WWVhcjtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQoU3RyaW5nKG5lYXJlc3RQb2ludC55ZWFyKSwgeCwgdGV4dFkpO1xuXG4gICAgICAgICAgICAgICAgLy8gRHJhdyBWYWx1ZVxuICAgICAgICAgICAgICAgIGxldCB2YWx1ZVRleHQgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQoKS5mb3JtYXQobmVhcmVzdFBvaW50LnZhbCk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9ycy50ZXh0VmFsdWU7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHZhbHVlVGV4dCwgeCwgdGV4dFkgKyAxMilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChwdWxzZVByb2dyZXNzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAvLyAzLiBEcmF3IFB1bHNlIEVmZmVjdCAoXCJEYXRhIFBhY2tldFwiKVxuXG4gICAgICAgICAgICAgLy8gQS4gU3BlZWQgTm9ybWFsaXphdGlvblxuICAgICAgICAgICAgIC8vIEZpbmQgdGhlIHNlZ21lbnQgYmFzZWQgb24gZGlzdGFuY2UgdHJhdmVsZWQgKG5vcm1hbGl6ZWRQb3MpXG4gICAgICAgICAgICAgbGV0IHNlZ21lbnRJbmRleCA9IDA7XG4gICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgaWYgKHB1bHNlUHJvZ3Jlc3MgPD0gcG9pbnRzW2ldLm5vcm1hbGl6ZWRQb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRJbmRleCA9IGkgLSAxO1xuICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgIC8vIEludGVycG9sYXRlIHdpdGhpbiB0aGUgc2VnbWVudFxuICAgICAgICAgICAgIGxldCBwMCA9IHBvaW50c1tzZWdtZW50SW5kZXhdO1xuICAgICAgICAgICAgIGxldCBwMSA9IHBvaW50c1tzZWdtZW50SW5kZXggKyAxXTtcblxuICAgICAgICAgICAgIC8vIEhhbmRsZSBlZGdlIGNhc2Ugd2hlcmUgdG90YWxMZW5ndGggbWlnaHQgYmUgMCBvciBwdWxzZVByb2dyZXNzID4gMVxuICAgICAgICAgICAgIGlmICghcDEpIHtcbiAgICAgICAgICAgICAgICAgcDAgPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgICAgICBwMSA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV1cbiAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICBsZXQgc2VnbWVudERpc3QgPSBwMS5ub3JtYWxpemVkUG9zIC0gcDAubm9ybWFsaXplZFBvcztcbiAgICAgICAgICAgICBsZXQgc2VnbWVudFByb2dyZXNzID0gKHNlZ21lbnREaXN0ID09PSAwKSA/IDAgOiAocHVsc2VQcm9ncmVzcyAtIHAwLm5vcm1hbGl6ZWRQb3MpIC8gc2VnbWVudERpc3Q7XG5cbiAgICAgICAgICAgICBsZXQgeCA9IHAwLnggKyAocDEueCAtIHAwLngpICogc2VnbWVudFByb2dyZXNzO1xuICAgICAgICAgICAgIGxldCB5ID0gcDAueSArIChwMS55IC0gcDAueSkgKiBzZWdtZW50UHJvZ3Jlc3M7XG5cbiAgICAgICAgICAgICAvLyBCLiBUcmVuZCBDb2xvcmluZ1xuICAgICAgICAgICAgIC8vIFVzZSB0aGUgY29sb3Igb2YgdGhlIHRhcmdldCBwb2ludCAocDEpXG4gICAgICAgICAgICAgbGV0IHB1bHNlQ29sb3IgPSBwMS5jb2xvciB8fCAnI0ZGRkZGRic7XG5cbiAgICAgICAgICAgICAvLyBDLiBQZWFrIEZsYXNoXG4gICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UgYXJlIG5lYXIgdGhlIGFic29sdXRlIG1heFxuICAgICAgICAgICAgIGlmIChwMC52YWwgPT09IG1heCB8fCBwMS52YWwgPT09IG1heCkge1xuICAgICAgICAgICAgICAgICAvLyBDaGVjayBkaXN0YW5jZSB0byBwZWFrXG4gICAgICAgICAgICAgICAgIGxldCBwZWFrID0gKHAwLnZhbCA9PT0gbWF4KSA/IHAwIDogcDE7XG4gICAgICAgICAgICAgICAgIGxldCBkeCA9IHggLSBwZWFrLng7XG4gICAgICAgICAgICAgICAgIGxldCBkeSA9IHkgLSBwZWFrLnk7XG4gICAgICAgICAgICAgICAgIGxldCBkaXN0ID0gTWF0aC5zcXJ0KGR4KmR4ICsgZHkqZHkpO1xuXG4gICAgICAgICAgICAgICAgIGlmIChkaXN0IDwgMTApIHtcbiAgICAgICAgICAgICAgICAgICAgIGxldCBhbHBoYSA9IDEgLSAoZGlzdCAvIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgIGN0eC5hcmMocGVhay54LCBwZWFrLnksIDEwLCAwLCBNYXRoLlBJICogMik7XG4gICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gYHJnYmEoJHtjb2xvcnMucHVsc2VSR0J9LCAke2FscGhhICogMC41fSlgO1xuICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGwoKVxuICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgLy8gRHJhdyBHbG93XG4gICAgICAgICAgICAgbGV0IGdyYWRpZW50ID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KHgsIHksIDAsIHgsIHksIDYpO1xuICAgICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCBgcmdiYSgke2NvbG9ycy5wdWxzZVJHQn0sIDEpYCk7XG4gICAgICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAuNCwgYHJnYmEoJHtjb2xvcnMucHVsc2VSR0J9LCAwLjQpYCk7XG4gICAgICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsIGByZ2JhKCR7Y29sb3JzLnB1bHNlUkdCfSwgMClgKTtcblxuICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICBjdHguYXJjKHgsIHksIDYsIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZ3JhZGllbnQ7XG4gICAgICAgICAgICAgY3R4LmZpbGwoKTtcblxuICAgICAgICAgICAgIC8vIERyYXcgQ29yZVxuICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICBjdHguYXJjKHgsIHksIDEuNSwgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBwdWxzZUNvbG9yOyAvLyBUcmVuZCBDb2xvclxuICAgICAgICAgICAgIGN0eC5maWxsKClcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoU3BhcmtsaW5lKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==