export const __webpack_esm_id__ = "vendors-apps_portal_canvas_ServicesCanvas_mjs";
export const __webpack_esm_ids__ = ["vendors-apps_portal_canvas_ServicesCanvas_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./apps/portal/canvas/ServicesCanvas.mjs"
/*!***********************************************!*\
  !*** ./apps/portal/canvas/ServicesCanvas.mjs ***!
  \***********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_canvas_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/canvas/Base.mjs */ "./src/canvas/Base.mjs");


const
    hasRaf          = typeof requestAnimationFrame === 'function',
    HEX_SIZE        = 30,
    STRIDE          = 8,  // q, r, x, y, scale, energy, buildCharge, colorIdx
    RUNNER_COUNT    = 30,
    /**
     * Agent Buffer Layout (Float32Array):
     * - 0: x (Current X)
     * - 1: y (Current Y)
     * - 2: tx (Target X)
     * - 3: ty (Target Y)
     * - 4: progress (Animation progress, 0-1)
     * - 5: speed (Movement speed)
     * - 6: currentHexIdx (Index of occupied node)
     * - 7: colorIdx (Palette index)
     * - 8: state (0 = Moving, 1 = Scanning)
     * - 9: scanTime (0-1 progress of the scan action)
     */
    RUNNER_STRIDE   = 10,
    SUPER_HEX_MAX   = 5,
    KERNEL_HEX_SIZE = 120,
    PARTICLE_COUNT  = 200,
    PARTICLE_STRIDE = 8, // x, y, z, vx, vy, vz, life, colorIdx
    STRATA_COUNT    = 15,
    STRATA_STRIDE   = 4; // x, y, z, size

/**
 * @summary SharedWorker renderer for the Portal Services "Neural Fabric" background.
 *
 * Implements a **Hexagonal Fabric** representing the engineered, structured nature of the Neo.mjs runtime.
 * The grid acts as a living "Motherboard" or "VDOM Registry" where cells (Components) can be inspected
 * and mutated.
 *
 * **Visual Architecture:**
 * 1. **Kernel Layer (Parallax):** A deep, slow-moving background grid representing the framework core.
 * 2. **Data Strata (Mid-Ground):** Floating clusters bridging the depth gap.
 * 3. **Application Layer (Fabric):** The main efficient structure (The App Engine).
 * 4. **Neural Agents:** High-speed packets visualizing throughput and intelligent maintenance.
 * 5. **Runtime Permutation:** Dynamic fusion of cells into "Super Modules" (construction/upload effects).
 * 6. **Construction Particles:** Particle effects visualizing memory allocation and object assembly.
 *
 * **Performance Architecture (Zero-Allocation):**
 * To ensure 60fps performance on high-resolution displays, this class employs a strict **Zero-Allocation** strategy:
 * 1.  **TypedArray Buffers:** All entity data is stored in pre-allocated `Float32Array` buffers.
 * 2.  **Persistent Objects:** Reusable objects (like `projectionPoint`, `projectionMatrix`) are used
 *     instead of creating new objects per frame.
 * 3.  **Inlined Math:** Projection and vector calculations are performed in-place.
 *
 * **Node Buffer Layout (Float32Array):**
 * - 0: q (Axial Coord Q)
 * - 1: r (Axial Coord R)
 * - 2: x (Screen X)
 * - 3: y (Screen Y)
 * - 4: scale (Visual scale, 0-1)
 * - 5: energy (Interaction state, 0-1)
 * - 6: buildCharge (Accumulator for Super Hex formation)
 * - 7: colorIdx (Palette index)
 *
 * **Runner Buffer Layout (Float32Array):**
 * - 0: x (Current X)
 * - 1: y (Current Y)
 * - 2: tx (Target X)
 * - 3: ty (Target Y)
 * - 4: progress (Animation progress, 0-1)
 * - 5: speed (Movement speed)
 * - 6: currentHexIdx (Index of occupied node)
 * - 7: colorIdx (Palette index)
 *
 * @class Portal.canvas.ServicesCanvas
 * @extends Portal.canvas.Base
 * @singleton
 */
class ServicesCanvas extends _src_canvas_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static colors = {
        dark : {
            background     : ['rgba(30, 30, 35, 1)', 'rgba(20, 20, 25, 1)'],
            particlePalette: ['#E0E0E0', '#00BFFF', '#3E63DD', '#8BA6FF'], // White, Cyan, Neo Blue, Light Blue
            hexLine        : 'rgba(139, 166, 255, 0.1)',
            hexActive      : 'rgba(0, 191, 255, 0.15)',
            activePalette  : ['#00BFFF', '#536DFE', '#3E63DD', '#00E5FF'], // Cyan, Indigo, Neo Blue, Turquoise
            kernel         : 'rgba(62, 99, 221, 0.08)',
            runner         : '#00BFFF',
            runnerPalette  : ['#00BFFF', '#536DFE', '#3E63DD', '#00E5FF'],
            agentHead      : '#FFFFFF',
            superHex       : 'rgba(62, 99, 221, 0.3)',
            strata         : 'rgba(139, 166, 255, 0.08)'
        },
        light: {
            background     : ['rgba(255, 255, 255, 1)', 'rgba(245, 247, 255, 1)'],
            particlePalette: ['#3E63DD', '#00BFFF', '#536DFE', '#283593'], // Neo Blue, Cyan, Indigo, Dark Blue
            hexLine        : 'rgba(62, 99, 221, 0.25)',
            hexActive      : 'rgba(0, 191, 255, 0.2)',
            activePalette  : ['#00BFFF', '#536DFE', '#3E63DD', '#00E5FF'],
            kernel         : 'rgba(62, 99, 221, 0.08)',
            runner         : '#00BFFF',
            runnerPalette  : ['#00BFFF', '#536DFE', '#3E63DD', '#00E5FF'],
            agentHead      : '#3E63DD',
            superHex       : 'rgba(62, 99, 221, 0.3)',
            strata         : 'rgba(62, 99, 221, 0.05)'
        }
    }

    static config = {
            /**
             * @member {String} className='Portal.canvas.ServicesCanvas'
             * @protected
             */
            className: 'Portal.canvas.ServicesCanvas',
            /**
             * Remote method access for the App Worker.
         * Allows the UI (Controller) to control the simulation state and input.
         * @member {Object} remote
         * @protected
         */
        remote: {
            app: [
                'updateSize'
            ]
        },
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * @member {Number|null} animationId=null
     */
    animationId = null
    /**
     * ID of the canvas element in the DOM.
     * @member {String|null} canvasId=null
     */
    canvasId = null
    /**
     * Current dimensions of the canvas.
     * @member {Object|null} canvasSize=null
     */
    canvasSize = null
    /**
     * The 2D rendering context.
     * @member {OffscreenCanvasRenderingContext2D|null} context=null
     */
    context = null

    /**
     * Buffer for the main Application Lattice (The Graph).
     * @member {Float32Array|null} cellBuffer
     */
    cellBuffer = null
    /**
     * Buffer for Data Runners (High-speed packets).
     * @member {Float32Array|null} runnerBuffer
     */
    runnerBuffer = null
    /**
     * Buffer for the Kernel Layer (Background Parallax).
     * @member {Float32Array|null} kernelBuffer
     */
    kernelBuffer = null
    /**
     * Buffer for Data Strata (Mid-ground Clusters).
     * @member {Float32Array|null} strataBuffer
     */
    strataBuffer = null

    /**
     * Buffer for Construction Particles.
     * Stride: [x, y, z, vx, vy, vz, life, colorIdx]
     * @member {Float32Array|null} particleBuffer
     */
    particleBuffer = null

    /**
     * Reusable object for projection calculations to avoid GC
     * @member {Object} projectionPoint
     * @protected
     */
    projectionPoint = {x: 0, y: 0, scale: 0, visible: false}

    /**
     * Projection matrix cache
     * @member {Object} projectionMatrix
     * @protected
     */
    projectionMatrix = {cx: 0, cy: 0, cosX: 0, sinX: 0, cosY: 0, sinY: 0}

    /**
     * List of active "Super Hexes" (Merged cells).
     * @member {Object[]} superHexes=[]
     */
    superHexes = []
    /**
     * Scaling factor relative to reference viewport.
     * @member {Number} scale=1
     */
    scale = 1
    /**
     * Current camera rotation in radians (Pitch, Yaw).
     * @member {Object} rotation={x: -0.4, y: 0}
     */
    rotation = {x: -0.4, y: 0} // Base tilt (radians) - Floor Perspective

    /**
     * Clears the graph state and stops the render loop.
     * Used when the component is destroyed or the route changes to release memory.
     */
    clearGraph() {
        let me = this;
        super.clearGraph();
        me.cellBuffer   = null;
        me.runnerBuffer = null;
        me.kernelBuffer = null;
        me.strataBuffer = null;
        me.particleBuffer = null;
        me.superHexes   = [];
        me.scale        = 1
    }

    /**
     * Hook to initialize nodes and buffers after context is ready
     * @param {Number} width
     * @param {Number} height
     */
    onGraphMounted(width, height) {
        this.updateSize({width, height})
    }

    /**
     * Draws a single Hexagon projected into 3D space.
     * Uses the reused `projectionPoint` to avoid allocations.
     * @param {CanvasRenderingContext2D} ctx
     * @param {Number} x World X
     * @param {Number} y World Y
     * @param {Number} z World Z
     * @param {Number} size Radius in pixels
     */
    drawHex(ctx, x, y, z, size) {
        let me    = this,
            first = true,
            p;

        ctx.beginPath();

        for (let i = 0; i < 6; i++) {
            const angle_deg = 60 * i + 30;
            const angle_rad = Math.PI / 180 * angle_deg;

            const px = x + size * Math.cos(angle_rad);
            const py = y + size * Math.sin(angle_rad);

            p = me.project(px, py, z);

            if (first) {
                ctx.moveTo(p.x, p.y);
                first = false;
            } else {
                ctx.lineTo(p.x, p.y);
            }
        }
        ctx.closePath();
    }

    /**
     * Draws the Kernel Layer (Background).
     * This layer moves slowly (Parallax) to create depth.
     * @param {CanvasRenderingContext2D} ctx
     * @param {Number} width
     * @param {Number} height
     */
    drawKernel(ctx, width, height) {
        let me = this;
        if (!me.kernelBuffer) {
            return;
        }

        const
            buffer      = me.kernelBuffer,
            count       = buffer.length / 2,
            s           = me.scale,
            size        = KERNEL_HEX_SIZE * s,
            themeColors = me.constructor.colors[me.theme];

        ctx.strokeStyle = themeColors.kernel;
        ctx.lineWidth   = 2 * s;
        ctx.lineJoin    = 'round';

        let panX = Math.sin(me.time * 0.2) * 20 * s,
            panY = Math.cos(me.time * 0.2) * 20 * s;

        ctx.beginPath();
        for (let i = 0; i < count; i++) {
            let x = buffer[i * 2] + panX,
                y = buffer[i * 2 + 1] + panY;
            me.drawHex(ctx, x, y, 400, size);
        }
        ctx.stroke();
    }

    /**
     * Draws the Data Strata (Mid-ground floating clusters).
     * These elements sit between the background and the main lattice.
     * @param {CanvasRenderingContext2D} ctx
     * @param {Number} width
     * @param {Number} height
     */
    drawStrata(ctx, width, height) {
        let me = this;
        if (!me.strataBuffer) {
            return;
        }

        const
            buffer      = me.strataBuffer,
            count       = STRATA_COUNT,
            s           = me.scale,
            themeColors = me.constructor.colors[me.theme];

        ctx.fillStyle = themeColors.strata;

        let panX = Math.sin(me.time * 0.15) * 30 * s,
            panY = Math.cos(me.time * 0.15) * 30 * s;

        for (let i = 0; i < count; i++) {
            let idx  = i * STRATA_STRIDE,
                x    = buffer[idx] + panX,
                y    = buffer[idx + 1] + panY,
                z    = buffer[idx + 2],
                size = buffer[idx + 3] * s;

            me.drawHex(ctx, x, y, z, size);
            ctx.fill();
        }
    }

    /**
     * Draws the main Application Lattice (Foreground).
     * Handles 3 batches:
     * 1. **Idle Hexes:** Faint outlines.
     * 2. **Super Hexes:** Large, merged modules with fill and center glow.
     * 3. **Active Hexes:** Energized nodes with "Holographic Pop" (3D extrusion).
     * @param {CanvasRenderingContext2D} ctx
     * @param {Number} width
     * @param {Number} height
     */
    drawGraph(ctx, width, height) {
        let me = this;

        if (!me.cellBuffer) {
            return;
        }

        const
            buffer      = me.cellBuffer,
            count       = buffer.length / STRIDE,
            themeColors = me.constructor.colors[me.theme],
            s           = me.scale,
            baseSize    = HEX_SIZE * s;

        ctx.lineWidth = 1 * s;
        ctx.lineJoin  = 'round';

        // Batch 1: Idle Hexes
        ctx.beginPath();
        ctx.strokeStyle = themeColors.hexLine;

        for (let i = 0; i < count; i++) {
            let idx    = i * STRIDE,
                x      = buffer[idx + 2],
                y      = buffer[idx + 3],
                scale  = buffer[idx + 4],
                energy = buffer[idx + 5];

            if (energy <= 0.01 && scale > 0.1) {
                let size = baseSize * 0.95 * scale;
                me.drawHex(ctx, x, y, 0, size);
            }
        }
        ctx.stroke();

        // Batch 2: Super Hexes
        ctx.lineWidth = 2 * s;
        for (let sh of me.superHexes) {
            let idx      = sh.centerIdx,
                x        = buffer[idx + 2],
                y        = buffer[idx + 3],
                colorIdx = buffer[idx + 7],
                progress = 0;

            if (sh.state === 0) {
                progress = sh.age / 30;
            } else if (sh.state === 1) {
                progress = 1;
            } else {
                progress = 1 - (sh.age / 30);
            }

            if (progress > 0) {
                let color = themeColors.activePalette[colorIdx];

                ctx.beginPath();
                me.drawHex(ctx, x, y, 0, baseSize * 2.5 * progress);

                ctx.strokeStyle = color;
                ctx.globalAlpha = 0.3 * progress;
                ctx.stroke();

                ctx.fillStyle = themeColors.superHex;
                ctx.fill();

                let p = me.project(x, y, 0);

                ctx.beginPath();
                ctx.arc(p.x, p.y, 4 * s * progress * p.scale, 0, Math.PI * 2);
                ctx.fillStyle   = color;
                ctx.globalAlpha = 0.8 * progress;
                ctx.fill();
            }
        }
        ctx.globalAlpha = 1;
        ctx.lineWidth   = 1 * s;

        // Batch 3: Active / Energized Hexes
        for (let i = 0; i < count; i++) {
            let idx      = i * STRIDE,
                x        = buffer[idx + 2],
                y        = buffer[idx + 3],
                scale    = buffer[idx + 4],
                energy   = buffer[idx + 5],
                colorIdx = buffer[idx + 7];

            if (energy > 0.01 && scale > 0.5) {
                let currentSize = baseSize * (0.95 + (energy * 0.1)),
                    color       = themeColors.activePalette[colorIdx];

                ctx.beginPath();
                me.drawHex(ctx, x, y, 0, currentSize);

                ctx.fillStyle   = themeColors.hexActive;
                ctx.globalAlpha = energy * 0.4;
                ctx.fill();

                ctx.strokeStyle = color;
                ctx.lineWidth   = (1 + energy) * s;
                ctx.globalAlpha = energy * 0.8;
                ctx.stroke();

                // Holographic Pop (Ghost Hex)
                if (energy > 0.3) {
                    ctx.beginPath();
                    let popZ = -50 * energy; // Float up
                    me.drawHex(ctx, x, y, popZ, currentSize);
                    ctx.strokeStyle = color;
                    ctx.globalAlpha = energy * 0.4;
                    ctx.lineWidth   = 1 * s;
                    ctx.stroke();
                }

                ctx.globalAlpha = 1;
                ctx.lineWidth   = 1 * s;
            }
        }
    }

    /**
     * Draws Data Runners (High-speed Packets).
     * Visualized as a gradient line (Trail) leading to a white head.
     * Uses optimized projection re-use.
     * @param {CanvasRenderingContext2D} ctx
     */
    drawRunners(ctx) {
        let me = this;
        if (!me.runnerBuffer) {
            return;
        }

        const
            buffer      = me.runnerBuffer,
            count       = RUNNER_COUNT,
            themeColors = me.constructor.colors[me.theme],
            s           = me.scale,
            pp          = me.projectionPoint; // Shortcut

        ctx.lineCap = 'round';

        for (let i = 0; i < count; i++) {
            let idx      = i * RUNNER_STRIDE,
                x        = buffer[idx],
                y        = buffer[idx + 1],
                tx       = buffer[idx + 2],
                ty       = buffer[idx + 3],
                sp       = buffer[idx + 5],
                colorIdx = buffer[idx + 7],
                state    = buffer[idx + 8],
                scanTime = buffer[idx + 9];

            // Project Head (Always needed)
            me.project(x, y, 0);

            if (!pp.visible) {
                continue;
            }
            let headX = pp.x,
                headY = pp.y,
                headS = pp.scale;

            let color = themeColors.runnerPalette[colorIdx];

            // STATE 0: MOVING (Draw Trail)
            if (state === 0) {
                let dx   = tx - x,
                    dy   = ty - y,
                    dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > 0) {
                    let tailLen = sp * 12 * s;
                    let dirX    = dx / dist,
                        dirY    = dy / dist;

                    let tailX = x - dirX * tailLen,
                        tailY = y - dirY * tailLen;

                    // Project Tail
                    me.project(tailX, tailY, 0);
                    let p1x   = pp.x,
                        p1y   = pp.y;

                    let g = ctx.createLinearGradient(p1x, p1y, headX, headY);
                    g.addColorStop(0, 'rgba(0,0,0,0)');
                    g.addColorStop(0.2, color);
                    g.addColorStop(0.6, color);
                    g.addColorStop(1, themeColors.agentHead);

                    ctx.beginPath();
                    ctx.strokeStyle = g;
                    ctx.lineWidth   = 3 * s * headS;
                    ctx.moveTo(p1x, p1y);
                    ctx.lineTo(headX, headY);
                    ctx.stroke();
                }
            }
            // STATE 1: SCANNING (Draw Pulse)
            else if (state === 1) {
                let radius = (HEX_SIZE * s * 1.5) * scanTime * headS;

                ctx.beginPath();
                ctx.arc(headX, headY, radius, 0, Math.PI * 2);
                ctx.strokeStyle = color;
                ctx.lineWidth   = 2 * s * headS * (1 - scanTime); // Fade out
                ctx.stroke();

                // Scanning Beam (Vertical)
                ctx.beginPath();
                ctx.moveTo(headX, headY);
                ctx.lineTo(headX, headY - (30 * s * headS * Math.sin(scanTime * Math.PI)));
                ctx.strokeStyle = themeColors.agentHead;
                ctx.lineWidth   = 2 * s * headS;
                ctx.stroke();
            }

            // Draw Head (Diamond Shape)
            ctx.beginPath();
            ctx.fillStyle = themeColors.agentHead;
            let hs = 4 * s * headS; // Head Size
            ctx.moveTo(headX, headY - hs);
            ctx.lineTo(headX + hs, headY);
            ctx.lineTo(headX, headY + hs);
            ctx.lineTo(headX - hs, headY);
            ctx.closePath();
            ctx.fill();

            // Glow
            ctx.shadowBlur  = 10 * s;
            ctx.shadowColor = color;
            ctx.shadowBlur  = 0;
        }
    }

    /**
     * Draws construction particles.
     * @param {CanvasRenderingContext2D} ctx
     */
    drawParticles(ctx) {
        let me = this;
        if (!me.particleBuffer) {
            return;
        }

        const
            buffer      = me.particleBuffer,
            count       = PARTICLE_COUNT,
            themeColors = me.constructor.colors[me.theme],
            s           = me.scale,
            pp          = me.projectionPoint;

        for (let i = 0; i < count; i++) {
            let idx  = i * PARTICLE_STRIDE,
                life = buffer[idx + 6]; // life is now at index 6

            if (life > 0) {
                let x    = buffer[idx],
                    y    = buffer[idx + 1],
                    z    = buffer[idx + 2],
                    size = 3 * s * life; // Shrink as it dies

                me.project(x, y, z);

                if (pp.visible) {
                    let scaledSize = size * pp.scale,
                        colorIdx   = buffer[idx + 7]; // colorIdx at index 7

                    ctx.fillStyle   = themeColors.particlePalette[colorIdx];
                    ctx.globalAlpha = life;
                    ctx.fillRect(pp.x - scaledSize / 2, pp.y - scaledSize / 2, scaledSize, scaledSize);
                }
            }
        }
        ctx.globalAlpha = 1;
    }

    /**
     * Allocates the Particle Buffer (Construction Effects).
     */
    initParticles() {
        let me = this;
        if (!me.particleBuffer) {
            me.particleBuffer = new Float32Array(PARTICLE_COUNT * PARTICLE_STRIDE);
        }
    }

    /**
     * Initializes the Kernel Buffer (Background Grid).
     * Creates a large-scale Hex grid that extends beyond the viewport for parallax movement.
     * @param {Number} width
     * @param {Number} height
     */
    initKernel(width, height) {
        let me      = this;
        const
            s       = me.scale,
            size    = KERNEL_HEX_SIZE * s,
            colStep = size * 1.5,
            rowStep = size * Math.sqrt(3),
            cols    = Math.ceil(width / colStep) + 4,
            rows    = Math.ceil(height / rowStep) + 4,
            count   = cols * rows;

        me.kernelBuffer = new Float32Array(count * 2);

        let i      = 0;
        let startX = -(colStep * 2),
            startY = -(rowStep * 2);

        for (let c = 0; c < cols; c++) {
            for (let r = 0; r < rows; r++) {
                let x = startX + c * colStep;
                let y = startY + r * rowStep;
                if (c % 2 === 1) {
                    y += rowStep / 2;
                }
                me.kernelBuffer[i * 2]     = x;
                me.kernelBuffer[i * 2 + 1] = y;
                i++;
            }
        }
    }

    /**
     * Initializes the Main Lattice (Application Layer).
     * Creates a standard Hexagonal Grid covering the screen + margins.
     * @param {Number} width
     * @param {Number} height
     */
    initNodes(width, height) {
        let me = this;

        const
            s       = me.scale,
            size    = HEX_SIZE * s,
            colStep = size * 1.5,
            rowStep = size * Math.sqrt(3),
            cols    = Math.ceil(width / colStep) + 2,
            // Extend rows upwards for perspective (Horizon Buffer)
            rows    = Math.ceil(height / rowStep) + 12,
            count   = cols * rows;

        if (!me.cellBuffer || me.cellBuffer.length !== count * STRIDE) {
            me.cellBuffer = new Float32Array(count * STRIDE);
        }

        const buffer = me.cellBuffer;

        let i = 0;
        // Start 10 rows higher up to fill the distance
        for (let c = -1; c < cols; c++) {
            for (let r = -10; r < rows - 10; r++) {
                let x = c * colStep;
                let y = r * rowStep;
                if (c % 2 === 1) {
                    y += rowStep / 2;
                }

                let idx         = i * STRIDE;
                buffer[idx]     = c;
                buffer[idx + 1] = r;
                buffer[idx + 2] = x;
                buffer[idx + 3] = y;
                buffer[idx + 4] = 1;
                buffer[idx + 5] = 0;
                buffer[idx + 6] = 0;
                buffer[idx + 7] = Math.floor(Math.random() * 4); // colorIdx

                i++;
                if (i >= count) {
                    break;
                }
            }
        }
    }

    /**
     * Initializes Data Runners (Traffic).
     * @param {Number} width
     * @param {Number} height
     */
    initRunners(width, height) {
        let me = this;
        if (!me.runnerBuffer) {
            me.runnerBuffer = new Float32Array(RUNNER_COUNT * RUNNER_STRIDE);
        }

        const
            buffer = me.runnerBuffer;

        for (let i = 0; i < RUNNER_COUNT; i++) {
            me.resetRunner(i, width, height);
            let idx         = i * RUNNER_STRIDE;
            buffer[idx + 4] = Math.random(); // Random start progress
            buffer[idx + 8] = 0; // State: Moving
            buffer[idx + 9] = 0; // ScanTime
        }
    }

    /**
     * Initializes Data Strata (Floating Mid-ground Clusters).
     * Randomly placed 3D coordinates.
     * @param {Number} width
     * @param {Number} height
     */
    initStrata(width, height) {
        let me = this;

        me.strataBuffer = new Float32Array(STRATA_COUNT * STRATA_STRIDE);
        const buffer    = me.strataBuffer;

        for (let i = 0; i < STRATA_COUNT; i++) {
            let idx         = i * STRATA_STRIDE;
            buffer[idx]     = (Math.random() - 0.5) * width * 2;
            buffer[idx + 1] = (Math.random() - 0.5) * height * 3;
            buffer[idx + 2] = 150 + Math.random() * 150; // Z depth 150-300
            buffer[idx + 3] = (HEX_SIZE * 3) + Math.random() * HEX_SIZE * 4; // Size
        }
    }

    /**
     * Finds the nearest hex node to a given screen position.
     * @param {Number} x
     * @param {Number} y
     * @returns {Number} Index of the nearest node or -1
     */
    findNearestNode(x, y) {
        let me      = this,
            buffer  = me.cellBuffer,
            count   = buffer.length / STRIDE,
            minDist = Infinity,
            bestIdx = -1;

        for (let i = 0; i < count; i++) {
            let idx  = i * STRIDE,
                nx   = buffer[idx + 2],
                ny   = buffer[idx + 3],
                dist = (nx - x) ** 2 + (ny - y) ** 2;

            if (dist < minDist) {
                minDist = dist;
                bestIdx = idx;
            }
        }
        return bestIdx;
    }

    /**
     * Resets a runner to a random position.
     * @param {Number} index
     * @param {Number} width
     * @param {Number} height
     */
    resetRunner(index, width, height) {
        let me        = this,
            buffer    = me.runnerBuffer,
            nodes     = me.cellBuffer,
            idx       = index * RUNNER_STRIDE,
            nodeCount = nodes.length / STRIDE;

        let nIdx = Math.floor(Math.random() * nodeCount) * STRIDE;

        buffer[idx]     = nodes[nIdx + 2];
        buffer[idx + 1] = nodes[nIdx + 3];

        buffer[idx + 2] = buffer[idx];
        buffer[idx + 3] = buffer[idx + 1];
        buffer[idx + 4] = 1;
        buffer[idx + 5] = (Math.random() * 4 + 5) * me.scale;
        buffer[idx + 6] = nIdx;
        buffer[idx + 7] = Math.floor(Math.random() * 4); // colorIdx
        buffer[idx + 8] = 0; // State: Moving
        buffer[idx + 9] = 0; // ScanTime
    }

    /**
     * Spawns construction particles.
     *
     * **Visual Metaphors:**
     * - **'implode'**: Particles fly *inward* from a radius to the center. Represents **Assembly**,
     *   **Memory Allocation**, or **Crystallization**. Used when a Super Hex is born.
     * - **'upload'**: Particles fly *upward* (Z-axis) and fade out. Represents **Data Transfer**,
     *   **Cloud Sync**, or **release**. Used when a Super Hex finishes its lifecycle.
     *
     * @param {Number} x World X
     * @param {Number} y World Y
     * @param {Number} count Number of particles to spawn
     * @param {String} type 'implode' or 'upload'
     */
    spawnParticles(x, y, count, type) {
        let me = this;
        if (!me.particleBuffer) {
            return;
        }

        const
            buffer = me.particleBuffer,
            total  = PARTICLE_COUNT,
            s      = me.scale;

        // Find empty slots
        let spawned = 0;
        for (let i = 0; i < total; i++) {
            let idx = i * PARTICLE_STRIDE;

            // If slot is empty (life <= 0)
            if (buffer[idx + 6] <= 0) {
                let angle = Math.random() * Math.PI * 2,
                    speed = (Math.random() * 3 + 2) * s;

                if (type === 'implode') {
                    // Start OUTSIDE, move IN
                    let radius      = 60 * s;
                    buffer[idx]     = x + Math.cos(angle) * radius;
                    buffer[idx + 1] = y + Math.sin(angle) * radius;
                    buffer[idx + 2] = 0; // z
                    buffer[idx + 3] = -Math.cos(angle) * speed; // vx
                    buffer[idx + 4] = -Math.sin(angle) * speed; // vy
                    buffer[idx + 5] = 0; // vz
                } else if (type === 'upload') {
                    // Start CENTER, move UP (Z-axis)
                    buffer[idx]     = x + (Math.random() - 0.5) * 20 * s;
                    buffer[idx + 1] = y + (Math.random() - 0.5) * 20 * s;
                    buffer[idx + 2] = 0; // z
                    buffer[idx + 3] = 0; // vx
                    buffer[idx + 4] = 0; // vy
                    buffer[idx + 5] = -speed * 1.5; // vz (Upwards in 3D space is negative Z in our projection usually, or handle in render)
                    // Let's assume negative Z is 'up/away' or just use Y for 'up'.
                    // Actually, 'Up' in 3D world space (if Y is down) is negative Y.
                    // But here we want a 'Holographic Upload' effect, which implies Z-axis lift.
                    // Let's try Negative Z (towards camera? or away?).
                    // In drawHex, Z is depth. Lower Z is closer?
                    // Let's make them float 'up' in World Y (-Y) and 'out' in Z (-Z).
                    buffer[idx + 4] = -1 * s; // Slow rise Y
                    buffer[idx + 5] = -5 * s; // Fast rise Z (towards camera)
                } else {
                    // Default explode
                     buffer[idx]     = x;
                     buffer[idx + 1] = y;
                     buffer[idx + 2] = 0;
                     buffer[idx + 3] = Math.cos(angle) * speed;
                     buffer[idx + 4] = Math.sin(angle) * speed;
                     buffer[idx + 5] = 0;
                }

                buffer[idx + 6] = 1.0; // Life
                buffer[idx + 7] = Math.floor(Math.random() * 4); // Color Index

                spawned++;
                if (spawned >= count) {
                    break;
                }
            }
        }
    }

    /**
     * Main Render Loop.
     * Updates physics, projects geometry, and draws all layers.
     */
    render() {
        let me = this;

        if (!me.canRender) {
            return
        }

        const
            ctx    = me.context,
            width  = me.canvasSize?.width || 100,
            height = me.canvasSize?.height || 50;

        me.time += 0.01;

        if (!me.cellBuffer) {
            me.initNodes(width, height);
        }
        if (!me.kernelBuffer) {
            me.initKernel(width, height);
        }
        if (!me.strataBuffer) {
            me.initStrata(width, height);
        }
        if (!me.runnerBuffer) {
            me.initRunners(width, height);
        }
        if (!me.particleBuffer) {
            me.initParticles();
        }

        me.updatePhysics(width, height);
        me.updateRotation(width, height);
        me.updateSuperHexes(width, height);
        me.updateRunners(width, height);
        me.updateParticles();
        me.updateProjection(width, height);

        ctx.clearRect(0, 0, width, height);

        if (me.gradients.bgGradient) {
            ctx.fillStyle = me.gradients.bgGradient;
            ctx.fillRect(0, 0, width, height)
        }

        me.drawKernel(ctx, width, height);
        me.drawStrata(ctx, width, height);
        me.drawGraph(ctx, width, height);
        me.drawRunners(ctx);
        me.drawParticles(ctx); // Render particles on top

        if (hasRaf) {
            me.animationId = requestAnimationFrame(me.renderLoop)
        } else {
            me.animationId = setTimeout(me.renderLoop, 1000 / 60)
        }
    }

    /**
     * Updates particle physics (movement, decay).
     */
    updateParticles() {
        let me = this;
        if (!me.particleBuffer) {
            return;
        }

        const buffer = me.particleBuffer,
              count  = PARTICLE_COUNT;

        for (let i = 0; i < count; i++) {
            let idx = i * PARTICLE_STRIDE;
            if (buffer[idx + 6] > 0) { // Check life
                // Move x, y, z by vx, vy, vz
                buffer[idx]     += buffer[idx + 3];
                buffer[idx + 1] += buffer[idx + 4];
                buffer[idx + 2] += buffer[idx + 5];

                // Decay life
                buffer[idx + 6] -= 0.03;
            }
        }
    }

    /**
     * Manages the lifecycle of Super Hexes.
     * Detects highly charged cells, triggers implosions to form Super Hexes,
     * and manages their growth and final explosion.
     * @param {Number} width
     * @param {Number} height
     */
    updateSuperHexes(width, height) {
        let me = this;
        if (!me.cellBuffer) {
            return;
        }

        if (me.superHexes.length < SUPER_HEX_MAX) {
            const buffer = me.cellBuffer,
                  count  = buffer.length / STRIDE;

            for (let i = 0; i < 20; i++) {
                let idx    = Math.floor(Math.random() * count) * STRIDE,
                    charge = buffer[idx + 6];

                if (charge > 3) {
                    me.superHexes.push({
                        centerIdx: idx,
                        age      : 0,
                        state    : 0,
                        neighbors: me.findNeighbors(idx)
                    });

                    // Trigger Implosion!
                    let x = buffer[idx + 2],
                        y = buffer[idx + 3];
                    me.spawnParticles(x, y, 12, 'implode');

                    buffer[idx + 6] = 0;
                    break;
                }
            }
        }

        for (let i = me.superHexes.length - 1; i >= 0; i--) {
            let sh = me.superHexes[i];
            sh.age++;

            if (sh.state === 0 && sh.age > 30) {
                sh.state = 1;
                sh.age   = 0;
            } else if (sh.state === 1 && sh.age > 120) {
                sh.state = 2;
                sh.age   = 0;
            } else if (sh.state === 2 && sh.age > 30) {
                // Done - Trigger Upload
                let idx = sh.centerIdx,
                    x   = me.cellBuffer[idx + 2],
                    y   = me.cellBuffer[idx + 3];

                me.spawnParticles(x, y, 12, 'upload');

                sh.neighbors.forEach(nIdx => {
                    me.cellBuffer[nIdx + 4] = 1;
                });
                me.superHexes.splice(i, 1);
                continue;
            }

            let targetScale = 1;
            if (sh.state === 0) {
                targetScale = 1 - (sh.age / 30);
            } else if (sh.state === 1) {
                targetScale = 0;
            } else {
                targetScale = sh.age / 30;
            }

            sh.neighbors.forEach(nIdx => {
                me.cellBuffer[nIdx + 4] = targetScale;
            });
        }
    }

    /**
     * Finds immediate neighbors for Super Hex formation.
     * @param {Number} centerIdx
     * @returns {Number[]} Array of neighbor indices
     */
    findNeighbors(centerIdx) {
        let me        = this,
            buffer    = me.cellBuffer,
            cx        = buffer[centerIdx + 2],
            cy        = buffer[centerIdx + 3],
            neighbors = [centerIdx],
            count     = buffer.length / STRIDE,
            s         = me.scale,
            radius    = HEX_SIZE * s * 2.1;

        for (let i = 0; i < count; i++) {
            let idx = i * STRIDE;
            if (idx === centerIdx) {
                continue;
            }

            let x    = buffer[idx + 2],
                y    = buffer[idx + 3],
                dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);

            if (dist < radius) {
                neighbors.push(idx);
            }
        }
        return neighbors;
    }

    /**
     * Updates interaction physics for the main lattice.
     * Handles mouse hover energy transfer and decay.
     * @param {Number} width
     * @param {Number} height
     */
    updatePhysics(width, height) {
        let me = this;
        if (!me.cellBuffer) {
            return;
        }

        const
            buffer = me.cellBuffer,
            count  = buffer.length / STRIDE,
            mx     = me.mouse.x,
            my     = me.mouse.y,
            s      = me.scale;

        for (let i = 0; i < count; i++) {
            let idx    = i * STRIDE,
                x      = buffer[idx + 2],
                y      = buffer[idx + 3],
                active = 0;

            if (mx !== -1000) {
                let dx     = x - mx,
                    dy     = y - my,
                    distSq = dx * dx + dy * dy,
                    radius = 250 * s;

                if (distSq < radius * radius) {
                    let dist = Math.sqrt(distSq);
                    active   = (radius - dist) / radius;
                    active   = Math.pow(active, 2);
                }
            }

            let currentEnergy = buffer[idx + 5];
            let targetEnergy  = active * 0.8;

            // Speed up hover reaction (0.1 -> 0.3)
            if (currentEnergy > targetEnergy) {
                buffer[idx + 5] *= 0.9;
            } else {
                buffer[idx + 5] += (targetEnergy - currentEnergy) * 0.3;
            }

            if (buffer[idx + 5] < 0.001) {
                buffer[idx + 5] = 0;
            }

            if (buffer[idx + 6] > 0) {
                buffer[idx + 6] -= 0.05;
                if (buffer[idx + 6] < 0) {
                    buffer[idx + 6] = 0;
                }
            }
        }
    }

    /**
     * Updates Neural Agent logic (The "Intelligence" Layer).
     *
     * Implements a 2-State Machine for Agents:
     *
     * **State 0: Moving**
     * - Agents travel along grid edges to a target node.
     * - Uses "Magnetic Pathfinding" to bias movement towards the mouse cursor.
     * - Upon arrival, there is a **20% chance** to switch to "Scanning".
     *
     * **State 1: Scanning**
     * - The Agent locks onto a node and performs a "Deep Scan" (visualized as a pulse).
     * - **Construction Trigger:** When the scan completes, the Agent injects massive `BuildCharge` (+5)
     *   into the node. This deterministically triggers the formation of a **Super Hex**, creating
     *   a direct cause-and-effect relationship between "Agent Work" and "Structure Creation".
     *
     * @param {Number} width
     * @param {Number} height
     */
    updateRunners(width, height) {
        let me = this;
        if (!me.runnerBuffer) {
            return;
        }

        const
            runners = me.runnerBuffer,
            nodes   = me.cellBuffer,
            count   = RUNNER_COUNT,
            s       = me.scale;

        for (let i = 0; i < count; i++) {
            let idx      = i * RUNNER_STRIDE,
                state    = runners[idx + 8];

            // STATE 0: MOVING
            if (state === 0) {
                let progress = runners[idx + 4],
                    speed    = runners[idx + 5];

                if (progress < 1) {
                    let x  = runners[idx],
                        y  = runners[idx + 1],
                        tx = runners[idx + 2],
                        ty = runners[idx + 3];

                    let dx   = tx - x,
                        dy   = ty - y,
                        dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < speed) {
                        runners[idx]     = tx;
                        runners[idx + 1] = ty;
                        runners[idx + 4] = 1; // Arrived

                        // Decision Point: Scan or Move?
                        // 20% Chance to Scan, but only if on a valid node
                        let nodeIdx = me.findNearestNode(tx, ty);

                        if (nodeIdx !== -1 && Math.random() > 0.8) {
                            runners[idx + 8] = 1; // Switch to Scanning
                            runners[idx + 9] = 0; // Reset Scan Time
                            runners[idx + 6] = nodeIdx; // Lock to node
                        } else {
                            // Just passing through - Standard Energy Boost
                            if (nodeIdx !== -1) {
                                nodes[nodeIdx + 5] = 1.0; // Flash
                                nodes[nodeIdx + 6] += 0.5; // Small contribution
                                nodes[nodeIdx + 7] = runners[idx + 7];
                                runners[idx + 6]   = nodeIdx;
                            }
                        }
                    } else {
                        runners[idx]     += (dx / dist) * speed;
                        runners[idx + 1] += (dy / dist) * speed;
                    }
                } else {
                    // Pick Next Target
                    let currentHexIdx = runners[idx + 6];

                    if (currentHexIdx !== undefined && currentHexIdx !== -1) {
                        // Magnetic Logic: Bias direction towards mouse
                        let bestDir   = -1,
                            bestScore = -Infinity;

                        let weights = [1, 1, 1, 1, 1, 1];

                        if (me.mouse.x !== -1000) {
                            let cx = runners[idx],
                                cy = runners[idx + 1];

                            for (let d = 0; d < 6; d++) {
                                let deg  = 30 + (d * 60),
                                    rad  = deg * Math.PI / 180,
                                    jump = HEX_SIZE * s * Math.sqrt(3),
                                    tx   = cx + Math.cos(rad) * jump,
                                    ty   = cy + Math.sin(rad) * jump;

                                let distSq = (tx - me.mouse.x) ** 2 + (ty - me.mouse.y) ** 2;
                                weights[d] += (100000 / (distSq + 100)) * 5;
                            }
                        }

                        let totalWeight = weights.reduce((a, b) => a + b, 0),
                            random      = Math.random() * totalWeight,
                            sum         = 0,
                            dir         = 0;

                        for (let d = 0; d < 6; d++) {
                            sum += weights[d];
                            if (random <= sum) {
                                dir = d;
                                break;
                            }
                        }

                        let deg  = 30 + (dir * 60),
                            rad  = deg * Math.PI / 180,
                            jump = HEX_SIZE * s * Math.sqrt(3),
                            cx   = runners[idx],
                            cy   = runners[idx + 1],
                            tx   = cx + Math.cos(rad) * jump,
                            ty   = cy + Math.sin(rad) * jump;

                        if (tx < -50 || tx > width + 50 || ty < -500 || ty > height + 50) {
                            me.resetRunner(i, width, height);
                            continue;
                        }

                        runners[idx + 2] = tx;
                        runners[idx + 3] = ty;
                        runners[idx + 4] = 0; // Reset progress
                    } else {
                        me.resetRunner(i, width, height);
                    }
                }
            }
            // STATE 1: SCANNING
            else if (state === 1) {
                // Increment Scan Time
                runners[idx + 9] += 0.02; // Scan speed

                // Visual Effect on Node (Pulse)
                let nodeIdx = runners[idx + 6];
                if (nodeIdx !== -1) {
                     nodes[nodeIdx + 5] = 0.5 + (Math.sin(runners[idx + 9] * 10) * 0.5); // Pulse Energy
                }

                // Scan Complete?
                if (runners[idx + 9] >= 1) {
                    runners[idx + 8] = 0; // Resume Moving

                    // THE PAYOFF: Massive BuildCharge injection
                    if (nodeIdx !== -1) {
                        nodes[nodeIdx + 6] += 5; // Instant Super Hex Trigger (>3)
                        nodes[nodeIdx + 5] = 1.0; // Max Energy
                        nodes[nodeIdx + 7] = runners[idx + 7]; // Color
                    }
                }
            }
        }
    }

    /**
     * Updates camera rotation based on mouse position.
     * Creates a "Floor Perspective" tilt effect.
     * @param {Number} width
     * @param {Number} height
     */
    updateRotation(width, height) {
        let me = this,
            mx = me.mouse.x,
            my = me.mouse.y,
            tx = -0.4, // Base tilt X (pitch)
            ty = 0;   // Base yaw

        if (mx !== -1000) {
            // Map mouse X to Yaw (+/- 0.2 rad)
            ty = ((mx / width) - 0.5) * 0.4;
            // Map mouse Y to Pitch (-0.6 to -0.2 rad)
            tx = -0.4 + ((my / height) - 0.5) * 0.4;
        }

        // Smooth interpolate
        me.rotation.x += (tx - me.rotation.x) * 0.05;
        me.rotation.y += (ty - me.rotation.y) * 0.05;
    }

    /**
     * Updates the projection matrix based on current rotation and size.
     * @param {Number} width
     * @param {Number} height
     */
    updateProjection(width, height) {
        let me = this,
            pm = me.projectionMatrix;

        pm.cx   = width / 2;
        pm.cy   = height / 2;
        pm.cosX = Math.cos(me.rotation.x);
        pm.sinX = Math.sin(me.rotation.x);
        pm.cosY = Math.cos(me.rotation.y);
        pm.sinY = Math.sin(me.rotation.y);
    }

    /**
     * Projects a 3D point to 2D screen space using the cached matrix.
     * writes result to this.projectionPoint to avoid allocation.
     * @param {Number} x
     * @param {Number} y
     * @param {Number} z
     * @returns {Object} this.projectionPoint
     */
    project(x, y, z) {
        let me  = this,
            pm  = me.projectionMatrix,
            pp  = me.projectionPoint,
            fov = 1000,
            dx  = x - pm.cx,
            dy  = y - pm.cy,
            dz  = z;

        // Rotate Y
        let x1 = dx * pm.cosY - dz * pm.sinY;
        let z1 = dz * pm.cosY + dx * pm.sinY;

        // Rotate X
        let y2 = dy * pm.cosX - z1 * pm.sinX;
        let z2 = z1 * pm.cosX + dy * pm.sinX;

        // Project
        let scale = fov / (fov + z2);

        pp.x       = x1 * scale + pm.cx;
        pp.y       = y2 * scale + pm.cy;
        pp.scale   = scale;
        pp.visible = z2 > -fov; // Clip if behind camera

        return pp;
    }

    /**
     * Creates and caches gradients.
     * @param {Number} width
     * @param {Number} height
     */
    updateResources(width, height) {
        let me  = this,
            ctx = me.context;

        if (!ctx) {
            return;
        }

        const
            themeColors = me.constructor.colors[me.theme],
            gradient    = ctx.createLinearGradient(0, 0, width, height);

        gradient.addColorStop(0, themeColors.background[0]);
        gradient.addColorStop(1, themeColors.background[1]);

        me.gradients.bgGradient = gradient
    }

    /**
     * Handles canvas resize.
     * Re-calculates scale and re-initializes buffers.
     * @param {Object} size
     * @param {Number} size.height
     * @param {Number} size.width
     */
    updateSize(size) {
        let me        = this;
        me.canvasSize = size;
        me.scale      = Math.sqrt((size.width * size.height) / 2073600);

        if (me.context) {
            me.context.canvas.width  = size.width;
            me.context.canvas.height = size.height;
            me.cellBuffer            = null;
            me.runnerBuffer          = null;
            me.kernelBuffer          = null;
            me.strataBuffer          = null;
            me.debrisBuffer          = null;
            me.initNodes(size.width, size.height);
            me.updateResources(size.width, size.height)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(ServicesCanvas));


/***/ },

/***/ "./src/canvas/Base.mjs"
/*!*****************************!*\
  !*** ./src/canvas/Base.mjs ***!
  \*****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @summary Abstract base class for Canvas Renderers.
 *
 * This class serves as the foundation for the specialized canvas visualizations (Header, Home, Services, Ticket)
 * that run within the **Neo.mjs Canvas SharedWorker**.
 *
 * It creates helper singletons that manage their own `OffscreenCanvas` instances, providing a standardized
 * architecture for:
 * - **Lifecycle Management:** Initialization (`initGraph`), destruction (`clearGraph`), and resource cleanup.
 * - **Render Loop Control:** Unified `render` loop with pause/resume capabilities and frame scheduling.
 * - **Context Management:** Robust handling of `OffscreenCanvas` transfer and context acquisition via `waitForCanvas`.
 * - **Shared State:** Common state management for mouse interaction, time, and theming.
 *
 * These renderers operate off the main thread to ensure high-performance, 60fps animations without
 * blocking the UI.
 *
 * @class Neo.canvas.Base
 * @extends Neo.core.Base
 */
class Base extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.canvas.Base'
         * @protected
         */
        className: 'Neo.canvas.Base',
        /**
         * Remote method access
         * @member {Object} remote
         * @protected
         */
        remote: {
            app: [
                'clearGraph',
                'initGraph',
                'pause',
                'resume',
                'setTheme',
                'updateMouseState',
                'updateSize'
            ]
        },
        /**
         * The active color theme ('light' or 'dark').
         * @member {String} theme_='light'
         * @reactive
         */
        theme_: 'light'
    }

    /**
     * @member {Number|null} animationId=null
     */
    animationId = null
    /**
     * @member {String|null} canvasId=null
     */
    canvasId = null
    /**
     * @member {Object|null} canvasSize=null
     */
    canvasSize = null
    /**
     * @member {OffscreenCanvasRenderingContext2D|null} context=null
     */
    context = null
    /**
     * Cache for reusable gradients to prevent GC.
     * @member {Object} gradients={}
     */
    gradients = {}
    /**
     * Flag to pause the render loop.
     * @member {Boolean} isPaused=false
     */
    isPaused = false
    /**
     * Tracked mouse position for interactive physics.
     * Initialize off-screen to prevent startup jitters.
     * @member {Object} mouse={x: -1000, y: -1000}
     */
    mouse = {x: -1000, y: -1000}
    /**
     * Global simulation time.
     * @member {Number} time=0
     */
    time = 0

    /**
     * @member {Function} renderLoop=this.render.bind(this)
     */
    renderLoop = this.render.bind(this)

    /**
     * Triggered after the `theme` config is changed.
     * Updates the resource cache (gradients, colors) to reflect the new theme immediately.
     * @param {String} value
     * @param {String} oldValue
     */
    afterSetTheme(value, oldValue) {
        if (value && this.canvasSize) {
            this.updateResources?.(this.canvasSize.width, this.canvasSize.height)
        }
    }

    /**
     * Checks if the canvas is ready to render.
     * Returns true only if the context exists and the simulation is not paused.
     * Subclasses should call this at the start of their `render` loop.
     * @returns {Boolean}
     */
    get canRender() {
        let me = this;
        return !!(me.context && !me.isPaused)
    }

    /**
     * Clears the graph state and stops the render loop.
     * Use this to cleanup resources when the component is destroyed or unmounted.
     */
    clearGraph() {
        let me = this;
        me.context     = null;
        me.canvasId    = null;
        me.canvasSize  = null;
        me.animationId = null;
        me.isPaused    = false;
        me.gradients   = {};
        me.mouse       = {x: -1000, y: -1000};
        me.time        = 0
    }

    /**
     * Initializes the canvas context.
     * Starts the polling mechanism to wait for the OffscreenCanvas transfer from the Main Thread.
     * @param {Object} opts
     * @param {String} opts.canvasId
     * @param {String} opts.windowId
     */
    initGraph({canvasId, windowId}) {
        let me        = this,
            hasChange = me.canvasId !== canvasId;

        me.canvasId = canvasId;

        me.waitForCanvas(canvasId, windowId, hasChange)
    }

    /**
     * Hook for subclasses to handle mouse clicks.
     * Called by `updateMouseState` when a click event is received.
     * @param {Object} data
     */
    onMouseClick(data) {}

    /**
     * Pauses the simulation.
     * The render loop will exit early while `isPaused` is true.
     */
    pause() {
        this.isPaused = true
    }

    /**
     * Abstract render method.
     * Subclasses must implement this method to draw the frame.
     */
    render() {}

    /**
     * Resumes the simulation.
     * If the simulation was paused, this restarts the render loop.
     */
    resume() {
        let me = this;

        if (me.isPaused) {
            me.isPaused = false;
            me.renderLoop()
        }
    }

    /**
     * Exposed method for Remote Access to trigger the reactive config setter.
     * @param {String} value
     */
    setTheme(value) {
        this.theme = value
    }

    /**
     * Updates the local mouse state from main thread events.
     * Delegates click events to `onMouseClick`.
     * @param {Object} data
     * @param {Boolean} [data.click]
     * @param {Boolean} [data.leave]
     * @param {Number} [data.x]
     * @param {Number} [data.y]
     */
    updateMouseState(data) {
        let me = this;

        if (data.leave) {
            me.mouse.x = -1000;
            me.mouse.y = -1000
        } else {
            if (data.x !== undefined) me.mouse.x = data.x;
            if (data.y !== undefined) me.mouse.y = data.y;

            if (data.click) {
                me.onMouseClick(data)
            }
        }
    }

    /**
     * Updates the canvas size and resizes the internal context.
     * Triggers `updateResources` hook to allow subclasses to regenerate buffers/gradients.
     * @param {Object} size
     * @param {Number} size.height
     * @param {Number} size.width
     */
    updateSize(size) {
        let me = this;

        me.canvasSize = size;

        if (me.context) {
            me.context.canvas.width  = size.width;
            me.context.canvas.height = size.height;
            // Calls the hook to re-generate resources if implemented
            me.updateResources?.(size.width, size.height)
        }
    }

    /**
     * Polls for the OffscreenCanvas until it is available in the Worker's `canvasWindowMap`.
     * Once found, it initializes the context and starts the render loop.
     * @param {String} canvasId
     * @param {String} windowId
     * @param {Boolean} hasChange
     * @protected
     */
    waitForCanvas(canvasId, windowId, hasChange) {
        let me     = this,
            canvas = Neo.currentWorker.canvasWindowMap[canvasId]?.[windowId];

        if (canvas) {
            me.context = canvas.getContext('2d');

            // Standardize size update
            me.updateSize({width: canvas.width, height: canvas.height});

            // Optional hook for subclasses
            me.onGraphMounted?.(canvas.width, canvas.height);

            if (hasChange && !me.animationId) {
                me.renderLoop()
            }
        } else {
            setTimeout(me.waitForCanvas.bind(me, canvasId, windowId, hasChange), 50)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Base));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2NhbnZhcy92ZW5kb3JzLWFwcHNfcG9ydGFsX2NhbnZhc19TZXJ2aWNlc0NhbnZhc19tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDREQUFJO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFn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QUFnQixRQUFRO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQiwyQ0FBMkM7O0FBRXRFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLG9CQUFvQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvcG9ydGFsL2NhbnZhcy9TZXJ2aWNlc0NhbnZhcy5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jYW52YXMvQmFzZS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2UgZnJvbSAnLi4vLi4vLi4vc3JjL2NhbnZhcy9CYXNlLm1qcyc7XG5cbmNvbnN0XG4gICAgaGFzUmFmICAgICAgICAgID0gdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gJ2Z1bmN0aW9uJyxcbiAgICBIRVhfU0laRSAgICAgICAgPSAzMCxcbiAgICBTVFJJREUgICAgICAgICAgPSA4LCAgLy8gcSwgciwgeCwgeSwgc2NhbGUsIGVuZXJneSwgYnVpbGRDaGFyZ2UsIGNvbG9ySWR4XG4gICAgUlVOTkVSX0NPVU5UICAgID0gMzAsXG4gICAgLyoqXG4gICAgICogQWdlbnQgQnVmZmVyIExheW91dCAoRmxvYXQzMkFycmF5KTpcbiAgICAgKiAtIDA6IHggKEN1cnJlbnQgWClcbiAgICAgKiAtIDE6IHkgKEN1cnJlbnQgWSlcbiAgICAgKiAtIDI6IHR4IChUYXJnZXQgWClcbiAgICAgKiAtIDM6IHR5IChUYXJnZXQgWSlcbiAgICAgKiAtIDQ6IHByb2dyZXNzIChBbmltYXRpb24gcHJvZ3Jlc3MsIDAtMSlcbiAgICAgKiAtIDU6IHNwZWVkIChNb3ZlbWVudCBzcGVlZClcbiAgICAgKiAtIDY6IGN1cnJlbnRIZXhJZHggKEluZGV4IG9mIG9jY3VwaWVkIG5vZGUpXG4gICAgICogLSA3OiBjb2xvcklkeCAoUGFsZXR0ZSBpbmRleClcbiAgICAgKiAtIDg6IHN0YXRlICgwID0gTW92aW5nLCAxID0gU2Nhbm5pbmcpXG4gICAgICogLSA5OiBzY2FuVGltZSAoMC0xIHByb2dyZXNzIG9mIHRoZSBzY2FuIGFjdGlvbilcbiAgICAgKi9cbiAgICBSVU5ORVJfU1RSSURFICAgPSAxMCxcbiAgICBTVVBFUl9IRVhfTUFYICAgPSA1LFxuICAgIEtFUk5FTF9IRVhfU0laRSA9IDEyMCxcbiAgICBQQVJUSUNMRV9DT1VOVCAgPSAyMDAsXG4gICAgUEFSVElDTEVfU1RSSURFID0gOCwgLy8geCwgeSwgeiwgdngsIHZ5LCB2eiwgbGlmZSwgY29sb3JJZHhcbiAgICBTVFJBVEFfQ09VTlQgICAgPSAxNSxcbiAgICBTVFJBVEFfU1RSSURFICAgPSA0OyAvLyB4LCB5LCB6LCBzaXplXG5cbi8qKlxuICogQHN1bW1hcnkgU2hhcmVkV29ya2VyIHJlbmRlcmVyIGZvciB0aGUgUG9ydGFsIFNlcnZpY2VzIFwiTmV1cmFsIEZhYnJpY1wiIGJhY2tncm91bmQuXG4gKlxuICogSW1wbGVtZW50cyBhICoqSGV4YWdvbmFsIEZhYnJpYyoqIHJlcHJlc2VudGluZyB0aGUgZW5naW5lZXJlZCwgc3RydWN0dXJlZCBuYXR1cmUgb2YgdGhlIE5lby5tanMgcnVudGltZS5cbiAqIFRoZSBncmlkIGFjdHMgYXMgYSBsaXZpbmcgXCJNb3RoZXJib2FyZFwiIG9yIFwiVkRPTSBSZWdpc3RyeVwiIHdoZXJlIGNlbGxzIChDb21wb25lbnRzKSBjYW4gYmUgaW5zcGVjdGVkXG4gKiBhbmQgbXV0YXRlZC5cbiAqXG4gKiAqKlZpc3VhbCBBcmNoaXRlY3R1cmU6KipcbiAqIDEuICoqS2VybmVsIExheWVyIChQYXJhbGxheCk6KiogQSBkZWVwLCBzbG93LW1vdmluZyBiYWNrZ3JvdW5kIGdyaWQgcmVwcmVzZW50aW5nIHRoZSBmcmFtZXdvcmsgY29yZS5cbiAqIDIuICoqRGF0YSBTdHJhdGEgKE1pZC1Hcm91bmQpOioqIEZsb2F0aW5nIGNsdXN0ZXJzIGJyaWRnaW5nIHRoZSBkZXB0aCBnYXAuXG4gKiAzLiAqKkFwcGxpY2F0aW9uIExheWVyIChGYWJyaWMpOioqIFRoZSBtYWluIGVmZmljaWVudCBzdHJ1Y3R1cmUgKFRoZSBBcHAgRW5naW5lKS5cbiAqIDQuICoqTmV1cmFsIEFnZW50czoqKiBIaWdoLXNwZWVkIHBhY2tldHMgdmlzdWFsaXppbmcgdGhyb3VnaHB1dCBhbmQgaW50ZWxsaWdlbnQgbWFpbnRlbmFuY2UuXG4gKiA1LiAqKlJ1bnRpbWUgUGVybXV0YXRpb246KiogRHluYW1pYyBmdXNpb24gb2YgY2VsbHMgaW50byBcIlN1cGVyIE1vZHVsZXNcIiAoY29uc3RydWN0aW9uL3VwbG9hZCBlZmZlY3RzKS5cbiAqIDYuICoqQ29uc3RydWN0aW9uIFBhcnRpY2xlczoqKiBQYXJ0aWNsZSBlZmZlY3RzIHZpc3VhbGl6aW5nIG1lbW9yeSBhbGxvY2F0aW9uIGFuZCBvYmplY3QgYXNzZW1ibHkuXG4gKlxuICogKipQZXJmb3JtYW5jZSBBcmNoaXRlY3R1cmUgKFplcm8tQWxsb2NhdGlvbik6KipcbiAqIFRvIGVuc3VyZSA2MGZwcyBwZXJmb3JtYW5jZSBvbiBoaWdoLXJlc29sdXRpb24gZGlzcGxheXMsIHRoaXMgY2xhc3MgZW1wbG95cyBhIHN0cmljdCAqKlplcm8tQWxsb2NhdGlvbioqIHN0cmF0ZWd5OlxuICogMS4gICoqVHlwZWRBcnJheSBCdWZmZXJzOioqIEFsbCBlbnRpdHkgZGF0YSBpcyBzdG9yZWQgaW4gcHJlLWFsbG9jYXRlZCBgRmxvYXQzMkFycmF5YCBidWZmZXJzLlxuICogMi4gICoqUGVyc2lzdGVudCBPYmplY3RzOioqIFJldXNhYmxlIG9iamVjdHMgKGxpa2UgYHByb2plY3Rpb25Qb2ludGAsIGBwcm9qZWN0aW9uTWF0cml4YCkgYXJlIHVzZWRcbiAqICAgICBpbnN0ZWFkIG9mIGNyZWF0aW5nIG5ldyBvYmplY3RzIHBlciBmcmFtZS5cbiAqIDMuICAqKklubGluZWQgTWF0aDoqKiBQcm9qZWN0aW9uIGFuZCB2ZWN0b3IgY2FsY3VsYXRpb25zIGFyZSBwZXJmb3JtZWQgaW4tcGxhY2UuXG4gKlxuICogKipOb2RlIEJ1ZmZlciBMYXlvdXQgKEZsb2F0MzJBcnJheSk6KipcbiAqIC0gMDogcSAoQXhpYWwgQ29vcmQgUSlcbiAqIC0gMTogciAoQXhpYWwgQ29vcmQgUilcbiAqIC0gMjogeCAoU2NyZWVuIFgpXG4gKiAtIDM6IHkgKFNjcmVlbiBZKVxuICogLSA0OiBzY2FsZSAoVmlzdWFsIHNjYWxlLCAwLTEpXG4gKiAtIDU6IGVuZXJneSAoSW50ZXJhY3Rpb24gc3RhdGUsIDAtMSlcbiAqIC0gNjogYnVpbGRDaGFyZ2UgKEFjY3VtdWxhdG9yIGZvciBTdXBlciBIZXggZm9ybWF0aW9uKVxuICogLSA3OiBjb2xvcklkeCAoUGFsZXR0ZSBpbmRleClcbiAqXG4gKiAqKlJ1bm5lciBCdWZmZXIgTGF5b3V0IChGbG9hdDMyQXJyYXkpOioqXG4gKiAtIDA6IHggKEN1cnJlbnQgWClcbiAqIC0gMTogeSAoQ3VycmVudCBZKVxuICogLSAyOiB0eCAoVGFyZ2V0IFgpXG4gKiAtIDM6IHR5IChUYXJnZXQgWSlcbiAqIC0gNDogcHJvZ3Jlc3MgKEFuaW1hdGlvbiBwcm9ncmVzcywgMC0xKVxuICogLSA1OiBzcGVlZCAoTW92ZW1lbnQgc3BlZWQpXG4gKiAtIDY6IGN1cnJlbnRIZXhJZHggKEluZGV4IG9mIG9jY3VwaWVkIG5vZGUpXG4gKiAtIDc6IGNvbG9ySWR4IChQYWxldHRlIGluZGV4KVxuICpcbiAqIEBjbGFzcyBQb3J0YWwuY2FudmFzLlNlcnZpY2VzQ2FudmFzXG4gKiBAZXh0ZW5kcyBQb3J0YWwuY2FudmFzLkJhc2VcbiAqIEBzaW5nbGV0b25cbiAqL1xuY2xhc3MgU2VydmljZXNDYW52YXMgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29sb3JzID0ge1xuICAgICAgICBkYXJrIDoge1xuICAgICAgICAgICAgYmFja2dyb3VuZCAgICAgOiBbJ3JnYmEoMzAsIDMwLCAzNSwgMSknLCAncmdiYSgyMCwgMjAsIDI1LCAxKSddLFxuICAgICAgICAgICAgcGFydGljbGVQYWxldHRlOiBbJyNFMEUwRTAnLCAnIzAwQkZGRicsICcjM0U2M0REJywgJyM4QkE2RkYnXSwgLy8gV2hpdGUsIEN5YW4sIE5lbyBCbHVlLCBMaWdodCBCbHVlXG4gICAgICAgICAgICBoZXhMaW5lICAgICAgICA6ICdyZ2JhKDEzOSwgMTY2LCAyNTUsIDAuMSknLFxuICAgICAgICAgICAgaGV4QWN0aXZlICAgICAgOiAncmdiYSgwLCAxOTEsIDI1NSwgMC4xNSknLFxuICAgICAgICAgICAgYWN0aXZlUGFsZXR0ZSAgOiBbJyMwMEJGRkYnLCAnIzUzNkRGRScsICcjM0U2M0REJywgJyMwMEU1RkYnXSwgLy8gQ3lhbiwgSW5kaWdvLCBOZW8gQmx1ZSwgVHVycXVvaXNlXG4gICAgICAgICAgICBrZXJuZWwgICAgICAgICA6ICdyZ2JhKDYyLCA5OSwgMjIxLCAwLjA4KScsXG4gICAgICAgICAgICBydW5uZXIgICAgICAgICA6ICcjMDBCRkZGJyxcbiAgICAgICAgICAgIHJ1bm5lclBhbGV0dGUgIDogWycjMDBCRkZGJywgJyM1MzZERkUnLCAnIzNFNjNERCcsICcjMDBFNUZGJ10sXG4gICAgICAgICAgICBhZ2VudEhlYWQgICAgICA6ICcjRkZGRkZGJyxcbiAgICAgICAgICAgIHN1cGVySGV4ICAgICAgIDogJ3JnYmEoNjIsIDk5LCAyMjEsIDAuMyknLFxuICAgICAgICAgICAgc3RyYXRhICAgICAgICAgOiAncmdiYSgxMzksIDE2NiwgMjU1LCAwLjA4KSdcbiAgICAgICAgfSxcbiAgICAgICAgbGlnaHQ6IHtcbiAgICAgICAgICAgIGJhY2tncm91bmQgICAgIDogWydyZ2JhKDI1NSwgMjU1LCAyNTUsIDEpJywgJ3JnYmEoMjQ1LCAyNDcsIDI1NSwgMSknXSxcbiAgICAgICAgICAgIHBhcnRpY2xlUGFsZXR0ZTogWycjM0U2M0REJywgJyMwMEJGRkYnLCAnIzUzNkRGRScsICcjMjgzNTkzJ10sIC8vIE5lbyBCbHVlLCBDeWFuLCBJbmRpZ28sIERhcmsgQmx1ZVxuICAgICAgICAgICAgaGV4TGluZSAgICAgICAgOiAncmdiYSg2MiwgOTksIDIyMSwgMC4yNSknLFxuICAgICAgICAgICAgaGV4QWN0aXZlICAgICAgOiAncmdiYSgwLCAxOTEsIDI1NSwgMC4yKScsXG4gICAgICAgICAgICBhY3RpdmVQYWxldHRlICA6IFsnIzAwQkZGRicsICcjNTM2REZFJywgJyMzRTYzREQnLCAnIzAwRTVGRiddLFxuICAgICAgICAgICAga2VybmVsICAgICAgICAgOiAncmdiYSg2MiwgOTksIDIyMSwgMC4wOCknLFxuICAgICAgICAgICAgcnVubmVyICAgICAgICAgOiAnIzAwQkZGRicsXG4gICAgICAgICAgICBydW5uZXJQYWxldHRlICA6IFsnIzAwQkZGRicsICcjNTM2REZFJywgJyMzRTYzREQnLCAnIzAwRTVGRiddLFxuICAgICAgICAgICAgYWdlbnRIZWFkICAgICAgOiAnIzNFNjNERCcsXG4gICAgICAgICAgICBzdXBlckhleCAgICAgICA6ICdyZ2JhKDYyLCA5OSwgMjIxLCAwLjMpJyxcbiAgICAgICAgICAgIHN0cmF0YSAgICAgICAgIDogJ3JnYmEoNjIsIDk5LCAyMjEsIDAuMDUpJ1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J1BvcnRhbC5jYW52YXMuU2VydmljZXNDYW52YXMnXG4gICAgICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ1BvcnRhbC5jYW52YXMuU2VydmljZXNDYW52YXMnLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZW1vdGUgbWV0aG9kIGFjY2VzcyBmb3IgdGhlIEFwcCBXb3JrZXIuXG4gICAgICAgICAqIEFsbG93cyB0aGUgVUkgKENvbnRyb2xsZXIpIHRvIGNvbnRyb2wgdGhlIHNpbXVsYXRpb24gc3RhdGUgYW5kIGlucHV0LlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHJlbW90ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdGU6IHtcbiAgICAgICAgICAgIGFwcDogW1xuICAgICAgICAgICAgICAgICd1cGRhdGVTaXplJ1xuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2luZ2xldG9uPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2luZ2xldG9uOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IGFuaW1hdGlvbklkPW51bGxcbiAgICAgKi9cbiAgICBhbmltYXRpb25JZCA9IG51bGxcbiAgICAvKipcbiAgICAgKiBJRCBvZiB0aGUgY2FudmFzIGVsZW1lbnQgaW4gdGhlIERPTS5cbiAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gY2FudmFzSWQ9bnVsbFxuICAgICAqL1xuICAgIGNhbnZhc0lkID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgZGltZW5zaW9ucyBvZiB0aGUgY2FudmFzLlxuICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBjYW52YXNTaXplPW51bGxcbiAgICAgKi9cbiAgICBjYW52YXNTaXplID0gbnVsbFxuICAgIC8qKlxuICAgICAqIFRoZSAyRCByZW5kZXJpbmcgY29udGV4dC5cbiAgICAgKiBAbWVtYmVyIHtPZmZzY3JlZW5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkR8bnVsbH0gY29udGV4dD1udWxsXG4gICAgICovXG4gICAgY29udGV4dCA9IG51bGxcblxuICAgIC8qKlxuICAgICAqIEJ1ZmZlciBmb3IgdGhlIG1haW4gQXBwbGljYXRpb24gTGF0dGljZSAoVGhlIEdyYXBoKS5cbiAgICAgKiBAbWVtYmVyIHtGbG9hdDMyQXJyYXl8bnVsbH0gY2VsbEJ1ZmZlclxuICAgICAqL1xuICAgIGNlbGxCdWZmZXIgPSBudWxsXG4gICAgLyoqXG4gICAgICogQnVmZmVyIGZvciBEYXRhIFJ1bm5lcnMgKEhpZ2gtc3BlZWQgcGFja2V0cykuXG4gICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fG51bGx9IHJ1bm5lckJ1ZmZlclxuICAgICAqL1xuICAgIHJ1bm5lckJ1ZmZlciA9IG51bGxcbiAgICAvKipcbiAgICAgKiBCdWZmZXIgZm9yIHRoZSBLZXJuZWwgTGF5ZXIgKEJhY2tncm91bmQgUGFyYWxsYXgpLlxuICAgICAqIEBtZW1iZXIge0Zsb2F0MzJBcnJheXxudWxsfSBrZXJuZWxCdWZmZXJcbiAgICAgKi9cbiAgICBrZXJuZWxCdWZmZXIgPSBudWxsXG4gICAgLyoqXG4gICAgICogQnVmZmVyIGZvciBEYXRhIFN0cmF0YSAoTWlkLWdyb3VuZCBDbHVzdGVycykuXG4gICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fG51bGx9IHN0cmF0YUJ1ZmZlclxuICAgICAqL1xuICAgIHN0cmF0YUJ1ZmZlciA9IG51bGxcblxuICAgIC8qKlxuICAgICAqIEJ1ZmZlciBmb3IgQ29uc3RydWN0aW9uIFBhcnRpY2xlcy5cbiAgICAgKiBTdHJpZGU6IFt4LCB5LCB6LCB2eCwgdnksIHZ6LCBsaWZlLCBjb2xvcklkeF1cbiAgICAgKiBAbWVtYmVyIHtGbG9hdDMyQXJyYXl8bnVsbH0gcGFydGljbGVCdWZmZXJcbiAgICAgKi9cbiAgICBwYXJ0aWNsZUJ1ZmZlciA9IG51bGxcblxuICAgIC8qKlxuICAgICAqIFJldXNhYmxlIG9iamVjdCBmb3IgcHJvamVjdGlvbiBjYWxjdWxhdGlvbnMgdG8gYXZvaWQgR0NcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHByb2plY3Rpb25Qb2ludFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwcm9qZWN0aW9uUG9pbnQgPSB7eDogMCwgeTogMCwgc2NhbGU6IDAsIHZpc2libGU6IGZhbHNlfVxuXG4gICAgLyoqXG4gICAgICogUHJvamVjdGlvbiBtYXRyaXggY2FjaGVcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHByb2plY3Rpb25NYXRyaXhcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcHJvamVjdGlvbk1hdHJpeCA9IHtjeDogMCwgY3k6IDAsIGNvc1g6IDAsIHNpblg6IDAsIGNvc1k6IDAsIHNpblk6IDB9XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIGFjdGl2ZSBcIlN1cGVyIEhleGVzXCIgKE1lcmdlZCBjZWxscykuXG4gICAgICogQG1lbWJlciB7T2JqZWN0W119IHN1cGVySGV4ZXM9W11cbiAgICAgKi9cbiAgICBzdXBlckhleGVzID0gW11cbiAgICAvKipcbiAgICAgKiBTY2FsaW5nIGZhY3RvciByZWxhdGl2ZSB0byByZWZlcmVuY2Ugdmlld3BvcnQuXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSBzY2FsZT0xXG4gICAgICovXG4gICAgc2NhbGUgPSAxXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBjYW1lcmEgcm90YXRpb24gaW4gcmFkaWFucyAoUGl0Y2gsIFlhdykuXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSByb3RhdGlvbj17eDogLTAuNCwgeTogMH1cbiAgICAgKi9cbiAgICByb3RhdGlvbiA9IHt4OiAtMC40LCB5OiAwfSAvLyBCYXNlIHRpbHQgKHJhZGlhbnMpIC0gRmxvb3IgUGVyc3BlY3RpdmVcblxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgZ3JhcGggc3RhdGUgYW5kIHN0b3BzIHRoZSByZW5kZXIgbG9vcC5cbiAgICAgKiBVc2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgb3IgdGhlIHJvdXRlIGNoYW5nZXMgdG8gcmVsZWFzZSBtZW1vcnkuXG4gICAgICovXG4gICAgY2xlYXJHcmFwaCgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcbiAgICAgICAgc3VwZXIuY2xlYXJHcmFwaCgpO1xuICAgICAgICBtZS5jZWxsQnVmZmVyICAgPSBudWxsO1xuICAgICAgICBtZS5ydW5uZXJCdWZmZXIgPSBudWxsO1xuICAgICAgICBtZS5rZXJuZWxCdWZmZXIgPSBudWxsO1xuICAgICAgICBtZS5zdHJhdGFCdWZmZXIgPSBudWxsO1xuICAgICAgICBtZS5wYXJ0aWNsZUJ1ZmZlciA9IG51bGw7XG4gICAgICAgIG1lLnN1cGVySGV4ZXMgICA9IFtdO1xuICAgICAgICBtZS5zY2FsZSAgICAgICAgPSAxXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSG9vayB0byBpbml0aWFsaXplIG5vZGVzIGFuZCBidWZmZXJzIGFmdGVyIGNvbnRleHQgaXMgcmVhZHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAgICovXG4gICAgb25HcmFwaE1vdW50ZWQod2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVNpemUoe3dpZHRoLCBoZWlnaHR9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYXdzIGEgc2luZ2xlIEhleGFnb24gcHJvamVjdGVkIGludG8gM0Qgc3BhY2UuXG4gICAgICogVXNlcyB0aGUgcmV1c2VkIGBwcm9qZWN0aW9uUG9pbnRgIHRvIGF2b2lkIGFsbG9jYXRpb25zLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBXb3JsZCBYXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgV29ybGQgWVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB6IFdvcmxkIFpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2l6ZSBSYWRpdXMgaW4gcGl4ZWxzXG4gICAgICovXG4gICAgZHJhd0hleChjdHgsIHgsIHksIHosIHNpemUpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIGZpcnN0ID0gdHJ1ZSxcbiAgICAgICAgICAgIHA7XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBhbmdsZV9kZWcgPSA2MCAqIGkgKyAzMDtcbiAgICAgICAgICAgIGNvbnN0IGFuZ2xlX3JhZCA9IE1hdGguUEkgLyAxODAgKiBhbmdsZV9kZWc7XG5cbiAgICAgICAgICAgIGNvbnN0IHB4ID0geCArIHNpemUgKiBNYXRoLmNvcyhhbmdsZV9yYWQpO1xuICAgICAgICAgICAgY29uc3QgcHkgPSB5ICsgc2l6ZSAqIE1hdGguc2luKGFuZ2xlX3JhZCk7XG5cbiAgICAgICAgICAgIHAgPSBtZS5wcm9qZWN0KHB4LCBweSwgeik7XG5cbiAgICAgICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8ocC54LCBwLnkpO1xuICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8ocC54LCBwLnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgS2VybmVsIExheWVyIChCYWNrZ3JvdW5kKS5cbiAgICAgKiBUaGlzIGxheWVyIG1vdmVzIHNsb3dseSAoUGFyYWxsYXgpIHRvIGNyZWF0ZSBkZXB0aC5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqL1xuICAgIGRyYXdLZXJuZWwoY3R4LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG4gICAgICAgIGlmICghbWUua2VybmVsQnVmZmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdFxuICAgICAgICAgICAgYnVmZmVyICAgICAgPSBtZS5rZXJuZWxCdWZmZXIsXG4gICAgICAgICAgICBjb3VudCAgICAgICA9IGJ1ZmZlci5sZW5ndGggLyAyLFxuICAgICAgICAgICAgcyAgICAgICAgICAgPSBtZS5zY2FsZSxcbiAgICAgICAgICAgIHNpemUgICAgICAgID0gS0VSTkVMX0hFWF9TSVpFICogcyxcbiAgICAgICAgICAgIHRoZW1lQ29sb3JzID0gbWUuY29uc3RydWN0b3IuY29sb3JzW21lLnRoZW1lXTtcblxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGVtZUNvbG9ycy5rZXJuZWw7XG4gICAgICAgIGN0eC5saW5lV2lkdGggICA9IDIgKiBzO1xuICAgICAgICBjdHgubGluZUpvaW4gICAgPSAncm91bmQnO1xuXG4gICAgICAgIGxldCBwYW5YID0gTWF0aC5zaW4obWUudGltZSAqIDAuMikgKiAyMCAqIHMsXG4gICAgICAgICAgICBwYW5ZID0gTWF0aC5jb3MobWUudGltZSAqIDAuMikgKiAyMCAqIHM7XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGxldCB4ID0gYnVmZmVyW2kgKiAyXSArIHBhblgsXG4gICAgICAgICAgICAgICAgeSA9IGJ1ZmZlcltpICogMiArIDFdICsgcGFuWTtcbiAgICAgICAgICAgIG1lLmRyYXdIZXgoY3R4LCB4LCB5LCA0MDAsIHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgRGF0YSBTdHJhdGEgKE1pZC1ncm91bmQgZmxvYXRpbmcgY2x1c3RlcnMpLlxuICAgICAqIFRoZXNlIGVsZW1lbnRzIHNpdCBiZXR3ZWVuIHRoZSBiYWNrZ3JvdW5kIGFuZCB0aGUgbWFpbiBsYXR0aWNlLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAgICovXG4gICAgZHJhd1N0cmF0YShjdHgsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcbiAgICAgICAgaWYgKCFtZS5zdHJhdGFCdWZmZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBidWZmZXIgICAgICA9IG1lLnN0cmF0YUJ1ZmZlcixcbiAgICAgICAgICAgIGNvdW50ICAgICAgID0gU1RSQVRBX0NPVU5ULFxuICAgICAgICAgICAgcyAgICAgICAgICAgPSBtZS5zY2FsZSxcbiAgICAgICAgICAgIHRoZW1lQ29sb3JzID0gbWUuY29uc3RydWN0b3IuY29sb3JzW21lLnRoZW1lXTtcblxuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhlbWVDb2xvcnMuc3RyYXRhO1xuXG4gICAgICAgIGxldCBwYW5YID0gTWF0aC5zaW4obWUudGltZSAqIDAuMTUpICogMzAgKiBzLFxuICAgICAgICAgICAgcGFuWSA9IE1hdGguY29zKG1lLnRpbWUgKiAwLjE1KSAqIDMwICogcztcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpZHggID0gaSAqIFNUUkFUQV9TVFJJREUsXG4gICAgICAgICAgICAgICAgeCAgICA9IGJ1ZmZlcltpZHhdICsgcGFuWCxcbiAgICAgICAgICAgICAgICB5ICAgID0gYnVmZmVyW2lkeCArIDFdICsgcGFuWSxcbiAgICAgICAgICAgICAgICB6ICAgID0gYnVmZmVyW2lkeCArIDJdLFxuICAgICAgICAgICAgICAgIHNpemUgPSBidWZmZXJbaWR4ICsgM10gKiBzO1xuXG4gICAgICAgICAgICBtZS5kcmF3SGV4KGN0eCwgeCwgeSwgeiwgc2l6ZSk7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIG1haW4gQXBwbGljYXRpb24gTGF0dGljZSAoRm9yZWdyb3VuZCkuXG4gICAgICogSGFuZGxlcyAzIGJhdGNoZXM6XG4gICAgICogMS4gKipJZGxlIEhleGVzOioqIEZhaW50IG91dGxpbmVzLlxuICAgICAqIDIuICoqU3VwZXIgSGV4ZXM6KiogTGFyZ2UsIG1lcmdlZCBtb2R1bGVzIHdpdGggZmlsbCBhbmQgY2VudGVyIGdsb3cuXG4gICAgICogMy4gKipBY3RpdmUgSGV4ZXM6KiogRW5lcmdpemVkIG5vZGVzIHdpdGggXCJIb2xvZ3JhcGhpYyBQb3BcIiAoM0QgZXh0cnVzaW9uKS5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqL1xuICAgIGRyYXdHcmFwaChjdHgsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIW1lLmNlbGxCdWZmZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBidWZmZXIgICAgICA9IG1lLmNlbGxCdWZmZXIsXG4gICAgICAgICAgICBjb3VudCAgICAgICA9IGJ1ZmZlci5sZW5ndGggLyBTVFJJREUsXG4gICAgICAgICAgICB0aGVtZUNvbG9ycyA9IG1lLmNvbnN0cnVjdG9yLmNvbG9yc1ttZS50aGVtZV0sXG4gICAgICAgICAgICBzICAgICAgICAgICA9IG1lLnNjYWxlLFxuICAgICAgICAgICAgYmFzZVNpemUgICAgPSBIRVhfU0laRSAqIHM7XG5cbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDEgKiBzO1xuICAgICAgICBjdHgubGluZUpvaW4gID0gJ3JvdW5kJztcblxuICAgICAgICAvLyBCYXRjaCAxOiBJZGxlIEhleGVzXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhlbWVDb2xvcnMuaGV4TGluZTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpZHggICAgPSBpICogU1RSSURFLFxuICAgICAgICAgICAgICAgIHggICAgICA9IGJ1ZmZlcltpZHggKyAyXSxcbiAgICAgICAgICAgICAgICB5ICAgICAgPSBidWZmZXJbaWR4ICsgM10sXG4gICAgICAgICAgICAgICAgc2NhbGUgID0gYnVmZmVyW2lkeCArIDRdLFxuICAgICAgICAgICAgICAgIGVuZXJneSA9IGJ1ZmZlcltpZHggKyA1XTtcblxuICAgICAgICAgICAgaWYgKGVuZXJneSA8PSAwLjAxICYmIHNjYWxlID4gMC4xKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNpemUgPSBiYXNlU2l6ZSAqIDAuOTUgKiBzY2FsZTtcbiAgICAgICAgICAgICAgICBtZS5kcmF3SGV4KGN0eCwgeCwgeSwgMCwgc2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgIC8vIEJhdGNoIDI6IFN1cGVyIEhleGVzXG4gICAgICAgIGN0eC5saW5lV2lkdGggPSAyICogcztcbiAgICAgICAgZm9yIChsZXQgc2ggb2YgbWUuc3VwZXJIZXhlcykge1xuICAgICAgICAgICAgbGV0IGlkeCAgICAgID0gc2guY2VudGVySWR4LFxuICAgICAgICAgICAgICAgIHggICAgICAgID0gYnVmZmVyW2lkeCArIDJdLFxuICAgICAgICAgICAgICAgIHkgICAgICAgID0gYnVmZmVyW2lkeCArIDNdLFxuICAgICAgICAgICAgICAgIGNvbG9ySWR4ID0gYnVmZmVyW2lkeCArIDddLFxuICAgICAgICAgICAgICAgIHByb2dyZXNzID0gMDtcblxuICAgICAgICAgICAgaWYgKHNoLnN0YXRlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3MgPSBzaC5hZ2UgLyAzMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2guc3RhdGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzcyA9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb2dyZXNzID0gMSAtIChzaC5hZ2UgLyAzMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcm9ncmVzcyA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgY29sb3IgPSB0aGVtZUNvbG9ycy5hY3RpdmVQYWxldHRlW2NvbG9ySWR4XTtcblxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBtZS5kcmF3SGV4KGN0eCwgeCwgeSwgMCwgYmFzZVNpemUgKiAyLjUgKiBwcm9ncmVzcyk7XG5cbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjMgKiBwcm9ncmVzcztcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhlbWVDb2xvcnMuc3VwZXJIZXg7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcblxuICAgICAgICAgICAgICAgIGxldCBwID0gbWUucHJvamVjdCh4LCB5LCAwKTtcblxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHguYXJjKHAueCwgcC55LCA0ICogcyAqIHByb2dyZXNzICogcC5zY2FsZSwgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgICA9IGNvbG9yO1xuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuOCAqIHByb2dyZXNzO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCAgID0gMSAqIHM7XG5cbiAgICAgICAgLy8gQmF0Y2ggMzogQWN0aXZlIC8gRW5lcmdpemVkIEhleGVzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkeCAgICAgID0gaSAqIFNUUklERSxcbiAgICAgICAgICAgICAgICB4ICAgICAgICA9IGJ1ZmZlcltpZHggKyAyXSxcbiAgICAgICAgICAgICAgICB5ICAgICAgICA9IGJ1ZmZlcltpZHggKyAzXSxcbiAgICAgICAgICAgICAgICBzY2FsZSAgICA9IGJ1ZmZlcltpZHggKyA0XSxcbiAgICAgICAgICAgICAgICBlbmVyZ3kgICA9IGJ1ZmZlcltpZHggKyA1XSxcbiAgICAgICAgICAgICAgICBjb2xvcklkeCA9IGJ1ZmZlcltpZHggKyA3XTtcblxuICAgICAgICAgICAgaWYgKGVuZXJneSA+IDAuMDEgJiYgc2NhbGUgPiAwLjUpIHtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudFNpemUgPSBiYXNlU2l6ZSAqICgwLjk1ICsgKGVuZXJneSAqIDAuMSkpLFxuICAgICAgICAgICAgICAgICAgICBjb2xvciAgICAgICA9IHRoZW1lQ29sb3JzLmFjdGl2ZVBhbGV0dGVbY29sb3JJZHhdO1xuXG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIG1lLmRyYXdIZXgoY3R4LCB4LCB5LCAwLCBjdXJyZW50U2l6ZSk7XG5cbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlICAgPSB0aGVtZUNvbG9ycy5oZXhBY3RpdmU7XG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gZW5lcmd5ICogMC40O1xuICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG5cbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoICAgPSAoMSArIGVuZXJneSkgKiBzO1xuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGVuZXJneSAqIDAuODtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBIb2xvZ3JhcGhpYyBQb3AgKEdob3N0IEhleClcbiAgICAgICAgICAgICAgICBpZiAoZW5lcmd5ID4gMC4zKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvcFogPSAtNTAgKiBlbmVyZ3k7IC8vIEZsb2F0IHVwXG4gICAgICAgICAgICAgICAgICAgIG1lLmRyYXdIZXgoY3R4LCB4LCB5LCBwb3BaLCBjdXJyZW50U2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBlbmVyZ3kgKiAwLjQ7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggICA9IDEgKiBzO1xuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoICAgPSAxICogcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYXdzIERhdGEgUnVubmVycyAoSGlnaC1zcGVlZCBQYWNrZXRzKS5cbiAgICAgKiBWaXN1YWxpemVkIGFzIGEgZ3JhZGllbnQgbGluZSAoVHJhaWwpIGxlYWRpbmcgdG8gYSB3aGl0ZSBoZWFkLlxuICAgICAqIFVzZXMgb3B0aW1pemVkIHByb2plY3Rpb24gcmUtdXNlLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKi9cbiAgICBkcmF3UnVubmVycyhjdHgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcbiAgICAgICAgaWYgKCFtZS5ydW5uZXJCdWZmZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBidWZmZXIgICAgICA9IG1lLnJ1bm5lckJ1ZmZlcixcbiAgICAgICAgICAgIGNvdW50ICAgICAgID0gUlVOTkVSX0NPVU5ULFxuICAgICAgICAgICAgdGhlbWVDb2xvcnMgPSBtZS5jb25zdHJ1Y3Rvci5jb2xvcnNbbWUudGhlbWVdLFxuICAgICAgICAgICAgcyAgICAgICAgICAgPSBtZS5zY2FsZSxcbiAgICAgICAgICAgIHBwICAgICAgICAgID0gbWUucHJvamVjdGlvblBvaW50OyAvLyBTaG9ydGN1dFxuXG4gICAgICAgIGN0eC5saW5lQ2FwID0gJ3JvdW5kJztcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpZHggICAgICA9IGkgKiBSVU5ORVJfU1RSSURFLFxuICAgICAgICAgICAgICAgIHggICAgICAgID0gYnVmZmVyW2lkeF0sXG4gICAgICAgICAgICAgICAgeSAgICAgICAgPSBidWZmZXJbaWR4ICsgMV0sXG4gICAgICAgICAgICAgICAgdHggICAgICAgPSBidWZmZXJbaWR4ICsgMl0sXG4gICAgICAgICAgICAgICAgdHkgICAgICAgPSBidWZmZXJbaWR4ICsgM10sXG4gICAgICAgICAgICAgICAgc3AgICAgICAgPSBidWZmZXJbaWR4ICsgNV0sXG4gICAgICAgICAgICAgICAgY29sb3JJZHggPSBidWZmZXJbaWR4ICsgN10sXG4gICAgICAgICAgICAgICAgc3RhdGUgICAgPSBidWZmZXJbaWR4ICsgOF0sXG4gICAgICAgICAgICAgICAgc2NhblRpbWUgPSBidWZmZXJbaWR4ICsgOV07XG5cbiAgICAgICAgICAgIC8vIFByb2plY3QgSGVhZCAoQWx3YXlzIG5lZWRlZClcbiAgICAgICAgICAgIG1lLnByb2plY3QoeCwgeSwgMCk7XG5cbiAgICAgICAgICAgIGlmICghcHAudmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGhlYWRYID0gcHAueCxcbiAgICAgICAgICAgICAgICBoZWFkWSA9IHBwLnksXG4gICAgICAgICAgICAgICAgaGVhZFMgPSBwcC5zY2FsZTtcblxuICAgICAgICAgICAgbGV0IGNvbG9yID0gdGhlbWVDb2xvcnMucnVubmVyUGFsZXR0ZVtjb2xvcklkeF07XG5cbiAgICAgICAgICAgIC8vIFNUQVRFIDA6IE1PVklORyAoRHJhdyBUcmFpbClcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxldCBkeCAgID0gdHggLSB4LFxuICAgICAgICAgICAgICAgICAgICBkeSAgID0gdHkgLSB5LFxuICAgICAgICAgICAgICAgICAgICBkaXN0ID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAgICAgICAgICAgICAgIGlmIChkaXN0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGFpbExlbiA9IHNwICogMTIgKiBzO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGlyWCAgICA9IGR4IC8gZGlzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpclkgICAgPSBkeSAvIGRpc3Q7XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHRhaWxYID0geCAtIGRpclggKiB0YWlsTGVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFpbFkgPSB5IC0gZGlyWSAqIHRhaWxMZW47XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUHJvamVjdCBUYWlsXG4gICAgICAgICAgICAgICAgICAgIG1lLnByb2plY3QodGFpbFgsIHRhaWxZLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHAxeCAgID0gcHAueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHAxeSAgID0gcHAueTtcblxuICAgICAgICAgICAgICAgICAgICBsZXQgZyA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudChwMXgsIHAxeSwgaGVhZFgsIGhlYWRZKTtcbiAgICAgICAgICAgICAgICAgICAgZy5hZGRDb2xvclN0b3AoMCwgJ3JnYmEoMCwwLDAsMCknKTtcbiAgICAgICAgICAgICAgICAgICAgZy5hZGRDb2xvclN0b3AoMC4yLCBjb2xvcik7XG4gICAgICAgICAgICAgICAgICAgIGcuYWRkQ29sb3JTdG9wKDAuNiwgY29sb3IpO1xuICAgICAgICAgICAgICAgICAgICBnLmFkZENvbG9yU3RvcCgxLCB0aGVtZUNvbG9ycy5hZ2VudEhlYWQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gZztcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCAgID0gMyAqIHMgKiBoZWFkUztcbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhwMXgsIHAxeSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oaGVhZFgsIGhlYWRZKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNUQVRFIDE6IFNDQU5OSU5HIChEcmF3IFB1bHNlKVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhdGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmFkaXVzID0gKEhFWF9TSVpFICogcyAqIDEuNSkgKiBzY2FuVGltZSAqIGhlYWRTO1xuXG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5hcmMoaGVhZFgsIGhlYWRZLCByYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoICAgPSAyICogcyAqIGhlYWRTICogKDEgLSBzY2FuVGltZSk7IC8vIEZhZGUgb3V0XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgICAgICAgICAgLy8gU2Nhbm5pbmcgQmVhbSAoVmVydGljYWwpXG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oaGVhZFgsIGhlYWRZKTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKGhlYWRYLCBoZWFkWSAtICgzMCAqIHMgKiBoZWFkUyAqIE1hdGguc2luKHNjYW5UaW1lICogTWF0aC5QSSkpKTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGVtZUNvbG9ycy5hZ2VudEhlYWQ7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCAgID0gMiAqIHMgKiBoZWFkUztcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERyYXcgSGVhZCAoRGlhbW9uZCBTaGFwZSlcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGVtZUNvbG9ycy5hZ2VudEhlYWQ7XG4gICAgICAgICAgICBsZXQgaHMgPSA0ICogcyAqIGhlYWRTOyAvLyBIZWFkIFNpemVcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oaGVhZFgsIGhlYWRZIC0gaHMpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhoZWFkWCArIGhzLCBoZWFkWSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKGhlYWRYLCBoZWFkWSArIGhzKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oaGVhZFggLSBocywgaGVhZFkpO1xuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcblxuICAgICAgICAgICAgLy8gR2xvd1xuICAgICAgICAgICAgY3R4LnNoYWRvd0JsdXIgID0gMTAgKiBzO1xuICAgICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gY29sb3I7XG4gICAgICAgICAgICBjdHguc2hhZG93Qmx1ciAgPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgY29uc3RydWN0aW9uIHBhcnRpY2xlcy5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICovXG4gICAgZHJhd1BhcnRpY2xlcyhjdHgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcbiAgICAgICAgaWYgKCFtZS5wYXJ0aWNsZUJ1ZmZlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIGJ1ZmZlciAgICAgID0gbWUucGFydGljbGVCdWZmZXIsXG4gICAgICAgICAgICBjb3VudCAgICAgICA9IFBBUlRJQ0xFX0NPVU5ULFxuICAgICAgICAgICAgdGhlbWVDb2xvcnMgPSBtZS5jb25zdHJ1Y3Rvci5jb2xvcnNbbWUudGhlbWVdLFxuICAgICAgICAgICAgcyAgICAgICAgICAgPSBtZS5zY2FsZSxcbiAgICAgICAgICAgIHBwICAgICAgICAgID0gbWUucHJvamVjdGlvblBvaW50O1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkeCAgPSBpICogUEFSVElDTEVfU1RSSURFLFxuICAgICAgICAgICAgICAgIGxpZmUgPSBidWZmZXJbaWR4ICsgNl07IC8vIGxpZmUgaXMgbm93IGF0IGluZGV4IDZcblxuICAgICAgICAgICAgaWYgKGxpZmUgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHggICAgPSBidWZmZXJbaWR4XSxcbiAgICAgICAgICAgICAgICAgICAgeSAgICA9IGJ1ZmZlcltpZHggKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgeiAgICA9IGJ1ZmZlcltpZHggKyAyXSxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IDMgKiBzICogbGlmZTsgLy8gU2hyaW5rIGFzIGl0IGRpZXNcblxuICAgICAgICAgICAgICAgIG1lLnByb2plY3QoeCwgeSwgeik7XG5cbiAgICAgICAgICAgICAgICBpZiAocHAudmlzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2NhbGVkU2l6ZSA9IHNpemUgKiBwcC5zY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9ySWR4ICAgPSBidWZmZXJbaWR4ICsgN107IC8vIGNvbG9ySWR4IGF0IGluZGV4IDdcblxuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlICAgPSB0aGVtZUNvbG9ycy5wYXJ0aWNsZVBhbGV0dGVbY29sb3JJZHhdO1xuICAgICAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBsaWZlO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QocHAueCAtIHNjYWxlZFNpemUgLyAyLCBwcC55IC0gc2NhbGVkU2l6ZSAvIDIsIHNjYWxlZFNpemUsIHNjYWxlZFNpemUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsbG9jYXRlcyB0aGUgUGFydGljbGUgQnVmZmVyIChDb25zdHJ1Y3Rpb24gRWZmZWN0cykuXG4gICAgICovXG4gICAgaW5pdFBhcnRpY2xlcygpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcbiAgICAgICAgaWYgKCFtZS5wYXJ0aWNsZUJ1ZmZlcikge1xuICAgICAgICAgICAgbWUucGFydGljbGVCdWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KFBBUlRJQ0xFX0NPVU5UICogUEFSVElDTEVfU1RSSURFKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBLZXJuZWwgQnVmZmVyIChCYWNrZ3JvdW5kIEdyaWQpLlxuICAgICAqIENyZWF0ZXMgYSBsYXJnZS1zY2FsZSBIZXggZ3JpZCB0aGF0IGV4dGVuZHMgYmV5b25kIHRoZSB2aWV3cG9ydCBmb3IgcGFyYWxsYXggbW92ZW1lbnQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqL1xuICAgIGluaXRLZXJuZWwod2lkdGgsIGhlaWdodCkge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXM7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBzICAgICAgID0gbWUuc2NhbGUsXG4gICAgICAgICAgICBzaXplICAgID0gS0VSTkVMX0hFWF9TSVpFICogcyxcbiAgICAgICAgICAgIGNvbFN0ZXAgPSBzaXplICogMS41LFxuICAgICAgICAgICAgcm93U3RlcCA9IHNpemUgKiBNYXRoLnNxcnQoMyksXG4gICAgICAgICAgICBjb2xzICAgID0gTWF0aC5jZWlsKHdpZHRoIC8gY29sU3RlcCkgKyA0LFxuICAgICAgICAgICAgcm93cyAgICA9IE1hdGguY2VpbChoZWlnaHQgLyByb3dTdGVwKSArIDQsXG4gICAgICAgICAgICBjb3VudCAgID0gY29scyAqIHJvd3M7XG5cbiAgICAgICAgbWUua2VybmVsQnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShjb3VudCAqIDIpO1xuXG4gICAgICAgIGxldCBpICAgICAgPSAwO1xuICAgICAgICBsZXQgc3RhcnRYID0gLShjb2xTdGVwICogMiksXG4gICAgICAgICAgICBzdGFydFkgPSAtKHJvd1N0ZXAgKiAyKTtcblxuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGNvbHM7IGMrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCByb3dzOyByKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgeCA9IHN0YXJ0WCArIGMgKiBjb2xTdGVwO1xuICAgICAgICAgICAgICAgIGxldCB5ID0gc3RhcnRZICsgciAqIHJvd1N0ZXA7XG4gICAgICAgICAgICAgICAgaWYgKGMgJSAyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gcm93U3RlcCAvIDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1lLmtlcm5lbEJ1ZmZlcltpICogMl0gICAgID0geDtcbiAgICAgICAgICAgICAgICBtZS5rZXJuZWxCdWZmZXJbaSAqIDIgKyAxXSA9IHk7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIE1haW4gTGF0dGljZSAoQXBwbGljYXRpb24gTGF5ZXIpLlxuICAgICAqIENyZWF0ZXMgYSBzdGFuZGFyZCBIZXhhZ29uYWwgR3JpZCBjb3ZlcmluZyB0aGUgc2NyZWVuICsgbWFyZ2lucy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAgICovXG4gICAgaW5pdE5vZGVzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBjb25zdFxuICAgICAgICAgICAgcyAgICAgICA9IG1lLnNjYWxlLFxuICAgICAgICAgICAgc2l6ZSAgICA9IEhFWF9TSVpFICogcyxcbiAgICAgICAgICAgIGNvbFN0ZXAgPSBzaXplICogMS41LFxuICAgICAgICAgICAgcm93U3RlcCA9IHNpemUgKiBNYXRoLnNxcnQoMyksXG4gICAgICAgICAgICBjb2xzICAgID0gTWF0aC5jZWlsKHdpZHRoIC8gY29sU3RlcCkgKyAyLFxuICAgICAgICAgICAgLy8gRXh0ZW5kIHJvd3MgdXB3YXJkcyBmb3IgcGVyc3BlY3RpdmUgKEhvcml6b24gQnVmZmVyKVxuICAgICAgICAgICAgcm93cyAgICA9IE1hdGguY2VpbChoZWlnaHQgLyByb3dTdGVwKSArIDEyLFxuICAgICAgICAgICAgY291bnQgICA9IGNvbHMgKiByb3dzO1xuXG4gICAgICAgIGlmICghbWUuY2VsbEJ1ZmZlciB8fCBtZS5jZWxsQnVmZmVyLmxlbmd0aCAhPT0gY291bnQgKiBTVFJJREUpIHtcbiAgICAgICAgICAgIG1lLmNlbGxCdWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KGNvdW50ICogU1RSSURFKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IG1lLmNlbGxCdWZmZXI7XG5cbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAvLyBTdGFydCAxMCByb3dzIGhpZ2hlciB1cCB0byBmaWxsIHRoZSBkaXN0YW5jZVxuICAgICAgICBmb3IgKGxldCBjID0gLTE7IGMgPCBjb2xzOyBjKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHIgPSAtMTA7IHIgPCByb3dzIC0gMTA7IHIrKykge1xuICAgICAgICAgICAgICAgIGxldCB4ID0gYyAqIGNvbFN0ZXA7XG4gICAgICAgICAgICAgICAgbGV0IHkgPSByICogcm93U3RlcDtcbiAgICAgICAgICAgICAgICBpZiAoYyAlIDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgeSArPSByb3dTdGVwIC8gMjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgaWR4ICAgICAgICAgPSBpICogU1RSSURFO1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltpZHhdICAgICA9IGM7XG4gICAgICAgICAgICAgICAgYnVmZmVyW2lkeCArIDFdID0gcjtcbiAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgMl0gPSB4O1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltpZHggKyAzXSA9IHk7XG4gICAgICAgICAgICAgICAgYnVmZmVyW2lkeCArIDRdID0gMTtcbiAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgNV0gPSAwO1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltpZHggKyA2XSA9IDA7XG4gICAgICAgICAgICAgICAgYnVmZmVyW2lkeCArIDddID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNCk7IC8vIGNvbG9ySWR4XG5cbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgRGF0YSBSdW5uZXJzIChUcmFmZmljKS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAgICovXG4gICAgaW5pdFJ1bm5lcnMod2lkdGgsIGhlaWdodCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuICAgICAgICBpZiAoIW1lLnJ1bm5lckJ1ZmZlcikge1xuICAgICAgICAgICAgbWUucnVubmVyQnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShSVU5ORVJfQ09VTlQgKiBSVU5ORVJfU1RSSURFKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBidWZmZXIgPSBtZS5ydW5uZXJCdWZmZXI7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBSVU5ORVJfQ09VTlQ7IGkrKykge1xuICAgICAgICAgICAgbWUucmVzZXRSdW5uZXIoaSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICBsZXQgaWR4ICAgICAgICAgPSBpICogUlVOTkVSX1NUUklERTtcbiAgICAgICAgICAgIGJ1ZmZlcltpZHggKyA0XSA9IE1hdGgucmFuZG9tKCk7IC8vIFJhbmRvbSBzdGFydCBwcm9ncmVzc1xuICAgICAgICAgICAgYnVmZmVyW2lkeCArIDhdID0gMDsgLy8gU3RhdGU6IE1vdmluZ1xuICAgICAgICAgICAgYnVmZmVyW2lkeCArIDldID0gMDsgLy8gU2NhblRpbWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIERhdGEgU3RyYXRhIChGbG9hdGluZyBNaWQtZ3JvdW5kIENsdXN0ZXJzKS5cbiAgICAgKiBSYW5kb21seSBwbGFjZWQgM0QgY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqL1xuICAgIGluaXRTdHJhdGEod2lkdGgsIGhlaWdodCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnN0cmF0YUJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoU1RSQVRBX0NPVU5UICogU1RSQVRBX1NUUklERSk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciAgICA9IG1lLnN0cmF0YUJ1ZmZlcjtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IFNUUkFUQV9DT1VOVDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaWR4ICAgICAgICAgPSBpICogU1RSQVRBX1NUUklERTtcbiAgICAgICAgICAgIGJ1ZmZlcltpZHhdICAgICA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIHdpZHRoICogMjtcbiAgICAgICAgICAgIGJ1ZmZlcltpZHggKyAxXSA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIGhlaWdodCAqIDM7XG4gICAgICAgICAgICBidWZmZXJbaWR4ICsgMl0gPSAxNTAgKyBNYXRoLnJhbmRvbSgpICogMTUwOyAvLyBaIGRlcHRoIDE1MC0zMDBcbiAgICAgICAgICAgIGJ1ZmZlcltpZHggKyAzXSA9IChIRVhfU0laRSAqIDMpICsgTWF0aC5yYW5kb20oKSAqIEhFWF9TSVpFICogNDsgLy8gU2l6ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIG5lYXJlc3QgaGV4IG5vZGUgdG8gYSBnaXZlbiBzY3JlZW4gcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IEluZGV4IG9mIHRoZSBuZWFyZXN0IG5vZGUgb3IgLTFcbiAgICAgKi9cbiAgICBmaW5kTmVhcmVzdE5vZGUoeCwgeSkge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBidWZmZXIgID0gbWUuY2VsbEJ1ZmZlcixcbiAgICAgICAgICAgIGNvdW50ICAgPSBidWZmZXIubGVuZ3RoIC8gU1RSSURFLFxuICAgICAgICAgICAgbWluRGlzdCA9IEluZmluaXR5LFxuICAgICAgICAgICAgYmVzdElkeCA9IC0xO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkeCAgPSBpICogU1RSSURFLFxuICAgICAgICAgICAgICAgIG54ICAgPSBidWZmZXJbaWR4ICsgMl0sXG4gICAgICAgICAgICAgICAgbnkgICA9IGJ1ZmZlcltpZHggKyAzXSxcbiAgICAgICAgICAgICAgICBkaXN0ID0gKG54IC0geCkgKiogMiArIChueSAtIHkpICoqIDI7XG5cbiAgICAgICAgICAgIGlmIChkaXN0IDwgbWluRGlzdCkge1xuICAgICAgICAgICAgICAgIG1pbkRpc3QgPSBkaXN0O1xuICAgICAgICAgICAgICAgIGJlc3RJZHggPSBpZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJlc3RJZHg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIGEgcnVubmVyIHRvIGEgcmFuZG9tIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgKi9cbiAgICByZXNldFJ1bm5lcihpbmRleCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGJ1ZmZlciAgICA9IG1lLnJ1bm5lckJ1ZmZlcixcbiAgICAgICAgICAgIG5vZGVzICAgICA9IG1lLmNlbGxCdWZmZXIsXG4gICAgICAgICAgICBpZHggICAgICAgPSBpbmRleCAqIFJVTk5FUl9TVFJJREUsXG4gICAgICAgICAgICBub2RlQ291bnQgPSBub2Rlcy5sZW5ndGggLyBTVFJJREU7XG5cbiAgICAgICAgbGV0IG5JZHggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBub2RlQ291bnQpICogU1RSSURFO1xuXG4gICAgICAgIGJ1ZmZlcltpZHhdICAgICA9IG5vZGVzW25JZHggKyAyXTtcbiAgICAgICAgYnVmZmVyW2lkeCArIDFdID0gbm9kZXNbbklkeCArIDNdO1xuXG4gICAgICAgIGJ1ZmZlcltpZHggKyAyXSA9IGJ1ZmZlcltpZHhdO1xuICAgICAgICBidWZmZXJbaWR4ICsgM10gPSBidWZmZXJbaWR4ICsgMV07XG4gICAgICAgIGJ1ZmZlcltpZHggKyA0XSA9IDE7XG4gICAgICAgIGJ1ZmZlcltpZHggKyA1XSA9IChNYXRoLnJhbmRvbSgpICogNCArIDUpICogbWUuc2NhbGU7XG4gICAgICAgIGJ1ZmZlcltpZHggKyA2XSA9IG5JZHg7XG4gICAgICAgIGJ1ZmZlcltpZHggKyA3XSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDQpOyAvLyBjb2xvcklkeFxuICAgICAgICBidWZmZXJbaWR4ICsgOF0gPSAwOyAvLyBTdGF0ZTogTW92aW5nXG4gICAgICAgIGJ1ZmZlcltpZHggKyA5XSA9IDA7IC8vIFNjYW5UaW1lXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3Bhd25zIGNvbnN0cnVjdGlvbiBwYXJ0aWNsZXMuXG4gICAgICpcbiAgICAgKiAqKlZpc3VhbCBNZXRhcGhvcnM6KipcbiAgICAgKiAtICoqJ2ltcGxvZGUnKio6IFBhcnRpY2xlcyBmbHkgKmlud2FyZCogZnJvbSBhIHJhZGl1cyB0byB0aGUgY2VudGVyLiBSZXByZXNlbnRzICoqQXNzZW1ibHkqKixcbiAgICAgKiAgICoqTWVtb3J5IEFsbG9jYXRpb24qKiwgb3IgKipDcnlzdGFsbGl6YXRpb24qKi4gVXNlZCB3aGVuIGEgU3VwZXIgSGV4IGlzIGJvcm4uXG4gICAgICogLSAqKid1cGxvYWQnKio6IFBhcnRpY2xlcyBmbHkgKnVwd2FyZCogKFotYXhpcykgYW5kIGZhZGUgb3V0LiBSZXByZXNlbnRzICoqRGF0YSBUcmFuc2ZlcioqLFxuICAgICAqICAgKipDbG91ZCBTeW5jKiosIG9yICoqcmVsZWFzZSoqLiBVc2VkIHdoZW4gYSBTdXBlciBIZXggZmluaXNoZXMgaXRzIGxpZmVjeWNsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IFdvcmxkIFhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSBXb3JsZCBZXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiBwYXJ0aWNsZXMgdG8gc3Bhd25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAnaW1wbG9kZScgb3IgJ3VwbG9hZCdcbiAgICAgKi9cbiAgICBzcGF3blBhcnRpY2xlcyh4LCB5LCBjb3VudCwgdHlwZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuICAgICAgICBpZiAoIW1lLnBhcnRpY2xlQnVmZmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdFxuICAgICAgICAgICAgYnVmZmVyID0gbWUucGFydGljbGVCdWZmZXIsXG4gICAgICAgICAgICB0b3RhbCAgPSBQQVJUSUNMRV9DT1VOVCxcbiAgICAgICAgICAgIHMgICAgICA9IG1lLnNjYWxlO1xuXG4gICAgICAgIC8vIEZpbmQgZW1wdHkgc2xvdHNcbiAgICAgICAgbGV0IHNwYXduZWQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpZHggPSBpICogUEFSVElDTEVfU1RSSURFO1xuXG4gICAgICAgICAgICAvLyBJZiBzbG90IGlzIGVtcHR5IChsaWZlIDw9IDApXG4gICAgICAgICAgICBpZiAoYnVmZmVyW2lkeCArIDZdIDw9IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgYW5nbGUgPSBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDIsXG4gICAgICAgICAgICAgICAgICAgIHNwZWVkID0gKE1hdGgucmFuZG9tKCkgKiAzICsgMikgKiBzO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdpbXBsb2RlJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdGFydCBPVVRTSURFLCBtb3ZlIElOXG4gICAgICAgICAgICAgICAgICAgIGxldCByYWRpdXMgICAgICA9IDYwICogcztcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2lkeF0gICAgID0geCArIE1hdGguY29zKGFuZ2xlKSAqIHJhZGl1cztcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2lkeCArIDFdID0geSArIE1hdGguc2luKGFuZ2xlKSAqIHJhZGl1cztcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2lkeCArIDJdID0gMDsgLy8gelxuICAgICAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgM10gPSAtTWF0aC5jb3MoYW5nbGUpICogc3BlZWQ7IC8vIHZ4XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltpZHggKyA0XSA9IC1NYXRoLnNpbihhbmdsZSkgKiBzcGVlZDsgLy8gdnlcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2lkeCArIDVdID0gMDsgLy8gdnpcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd1cGxvYWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IENFTlRFUiwgbW92ZSBVUCAoWi1heGlzKVxuICAgICAgICAgICAgICAgICAgICBidWZmZXJbaWR4XSAgICAgPSB4ICsgKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMjAgKiBzO1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgMV0gPSB5ICsgKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMjAgKiBzO1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgMl0gPSAwOyAvLyB6XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltpZHggKyAzXSA9IDA7IC8vIHZ4XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltpZHggKyA0XSA9IDA7IC8vIHZ5XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltpZHggKyA1XSA9IC1zcGVlZCAqIDEuNTsgLy8gdnogKFVwd2FyZHMgaW4gM0Qgc3BhY2UgaXMgbmVnYXRpdmUgWiBpbiBvdXIgcHJvamVjdGlvbiB1c3VhbGx5LCBvciBoYW5kbGUgaW4gcmVuZGVyKVxuICAgICAgICAgICAgICAgICAgICAvLyBMZXQncyBhc3N1bWUgbmVnYXRpdmUgWiBpcyAndXAvYXdheScgb3IganVzdCB1c2UgWSBmb3IgJ3VwJy5cbiAgICAgICAgICAgICAgICAgICAgLy8gQWN0dWFsbHksICdVcCcgaW4gM0Qgd29ybGQgc3BhY2UgKGlmIFkgaXMgZG93bikgaXMgbmVnYXRpdmUgWS5cbiAgICAgICAgICAgICAgICAgICAgLy8gQnV0IGhlcmUgd2Ugd2FudCBhICdIb2xvZ3JhcGhpYyBVcGxvYWQnIGVmZmVjdCwgd2hpY2ggaW1wbGllcyBaLWF4aXMgbGlmdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gTGV0J3MgdHJ5IE5lZ2F0aXZlIFogKHRvd2FyZHMgY2FtZXJhPyBvciBhd2F5PykuXG4gICAgICAgICAgICAgICAgICAgIC8vIEluIGRyYXdIZXgsIFogaXMgZGVwdGguIExvd2VyIFogaXMgY2xvc2VyP1xuICAgICAgICAgICAgICAgICAgICAvLyBMZXQncyBtYWtlIHRoZW0gZmxvYXQgJ3VwJyBpbiBXb3JsZCBZICgtWSkgYW5kICdvdXQnIGluIFogKC1aKS5cbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2lkeCArIDRdID0gLTEgKiBzOyAvLyBTbG93IHJpc2UgWVxuICAgICAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgNV0gPSAtNSAqIHM7IC8vIEZhc3QgcmlzZSBaICh0b3dhcmRzIGNhbWVyYSlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IGV4cGxvZGVcbiAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltpZHhdICAgICA9IHg7XG4gICAgICAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgMV0gPSB5O1xuICAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2lkeCArIDJdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltpZHggKyAzXSA9IE1hdGguY29zKGFuZ2xlKSAqIHNwZWVkO1xuICAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2lkeCArIDRdID0gTWF0aC5zaW4oYW5nbGUpICogc3BlZWQ7XG4gICAgICAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgNV0gPSAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJ1ZmZlcltpZHggKyA2XSA9IDEuMDsgLy8gTGlmZVxuICAgICAgICAgICAgICAgIGJ1ZmZlcltpZHggKyA3XSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDQpOyAvLyBDb2xvciBJbmRleFxuXG4gICAgICAgICAgICAgICAgc3Bhd25lZCsrO1xuICAgICAgICAgICAgICAgIGlmIChzcGF3bmVkID49IGNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1haW4gUmVuZGVyIExvb3AuXG4gICAgICogVXBkYXRlcyBwaHlzaWNzLCBwcm9qZWN0cyBnZW9tZXRyeSwgYW5kIGRyYXdzIGFsbCBsYXllcnMuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUuY2FuUmVuZGVyKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBjdHggICAgPSBtZS5jb250ZXh0LFxuICAgICAgICAgICAgd2lkdGggID0gbWUuY2FudmFzU2l6ZT8ud2lkdGggfHwgMTAwLFxuICAgICAgICAgICAgaGVpZ2h0ID0gbWUuY2FudmFzU2l6ZT8uaGVpZ2h0IHx8IDUwO1xuXG4gICAgICAgIG1lLnRpbWUgKz0gMC4wMTtcblxuICAgICAgICBpZiAoIW1lLmNlbGxCdWZmZXIpIHtcbiAgICAgICAgICAgIG1lLmluaXROb2Rlcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1lLmtlcm5lbEJ1ZmZlcikge1xuICAgICAgICAgICAgbWUuaW5pdEtlcm5lbCh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1lLnN0cmF0YUJ1ZmZlcikge1xuICAgICAgICAgICAgbWUuaW5pdFN0cmF0YSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1lLnJ1bm5lckJ1ZmZlcikge1xuICAgICAgICAgICAgbWUuaW5pdFJ1bm5lcnMod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtZS5wYXJ0aWNsZUJ1ZmZlcikge1xuICAgICAgICAgICAgbWUuaW5pdFBhcnRpY2xlcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgbWUudXBkYXRlUGh5c2ljcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgbWUudXBkYXRlUm90YXRpb24od2lkdGgsIGhlaWdodCk7XG4gICAgICAgIG1lLnVwZGF0ZVN1cGVySGV4ZXMod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIG1lLnVwZGF0ZVJ1bm5lcnMod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIG1lLnVwZGF0ZVBhcnRpY2xlcygpO1xuICAgICAgICBtZS51cGRhdGVQcm9qZWN0aW9uKHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgaWYgKG1lLmdyYWRpZW50cy5iZ0dyYWRpZW50KSB7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gbWUuZ3JhZGllbnRzLmJnR3JhZGllbnQ7XG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodClcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmRyYXdLZXJuZWwoY3R4LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgbWUuZHJhd1N0cmF0YShjdHgsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBtZS5kcmF3R3JhcGgoY3R4LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgbWUuZHJhd1J1bm5lcnMoY3R4KTtcbiAgICAgICAgbWUuZHJhd1BhcnRpY2xlcyhjdHgpOyAvLyBSZW5kZXIgcGFydGljbGVzIG9uIHRvcFxuXG4gICAgICAgIGlmIChoYXNSYWYpIHtcbiAgICAgICAgICAgIG1lLmFuaW1hdGlvbklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKG1lLnJlbmRlckxvb3ApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5hbmltYXRpb25JZCA9IHNldFRpbWVvdXQobWUucmVuZGVyTG9vcCwgMTAwMCAvIDYwKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBwYXJ0aWNsZSBwaHlzaWNzIChtb3ZlbWVudCwgZGVjYXkpLlxuICAgICAqL1xuICAgIHVwZGF0ZVBhcnRpY2xlcygpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcbiAgICAgICAgaWYgKCFtZS5wYXJ0aWNsZUJ1ZmZlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYnVmZmVyID0gbWUucGFydGljbGVCdWZmZXIsXG4gICAgICAgICAgICAgIGNvdW50ICA9IFBBUlRJQ0xFX0NPVU5UO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkeCA9IGkgKiBQQVJUSUNMRV9TVFJJREU7XG4gICAgICAgICAgICBpZiAoYnVmZmVyW2lkeCArIDZdID4gMCkgeyAvLyBDaGVjayBsaWZlXG4gICAgICAgICAgICAgICAgLy8gTW92ZSB4LCB5LCB6IGJ5IHZ4LCB2eSwgdnpcbiAgICAgICAgICAgICAgICBidWZmZXJbaWR4XSAgICAgKz0gYnVmZmVyW2lkeCArIDNdO1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltpZHggKyAxXSArPSBidWZmZXJbaWR4ICsgNF07XG4gICAgICAgICAgICAgICAgYnVmZmVyW2lkeCArIDJdICs9IGJ1ZmZlcltpZHggKyA1XTtcblxuICAgICAgICAgICAgICAgIC8vIERlY2F5IGxpZmVcbiAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgNl0gLT0gMC4wMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1hbmFnZXMgdGhlIGxpZmVjeWNsZSBvZiBTdXBlciBIZXhlcy5cbiAgICAgKiBEZXRlY3RzIGhpZ2hseSBjaGFyZ2VkIGNlbGxzLCB0cmlnZ2VycyBpbXBsb3Npb25zIHRvIGZvcm0gU3VwZXIgSGV4ZXMsXG4gICAgICogYW5kIG1hbmFnZXMgdGhlaXIgZ3Jvd3RoIGFuZCBmaW5hbCBleHBsb3Npb24uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqL1xuICAgIHVwZGF0ZVN1cGVySGV4ZXMod2lkdGgsIGhlaWdodCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuICAgICAgICBpZiAoIW1lLmNlbGxCdWZmZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZS5zdXBlckhleGVzLmxlbmd0aCA8IFNVUEVSX0hFWF9NQVgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IG1lLmNlbGxCdWZmZXIsXG4gICAgICAgICAgICAgICAgICBjb3VudCAgPSBidWZmZXIubGVuZ3RoIC8gU1RSSURFO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDIwOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgaWR4ICAgID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY291bnQpICogU1RSSURFLFxuICAgICAgICAgICAgICAgICAgICBjaGFyZ2UgPSBidWZmZXJbaWR4ICsgNl07XG5cbiAgICAgICAgICAgICAgICBpZiAoY2hhcmdlID4gMykge1xuICAgICAgICAgICAgICAgICAgICBtZS5zdXBlckhleGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VudGVySWR4OiBpZHgsXG4gICAgICAgICAgICAgICAgICAgICAgICBhZ2UgICAgICA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSAgICA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnM6IG1lLmZpbmROZWlnaGJvcnMoaWR4KVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUcmlnZ2VyIEltcGxvc2lvbiFcbiAgICAgICAgICAgICAgICAgICAgbGV0IHggPSBidWZmZXJbaWR4ICsgMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gYnVmZmVyW2lkeCArIDNdO1xuICAgICAgICAgICAgICAgICAgICBtZS5zcGF3blBhcnRpY2xlcyh4LCB5LCAxMiwgJ2ltcGxvZGUnKTtcblxuICAgICAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgNl0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gbWUuc3VwZXJIZXhlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHNoID0gbWUuc3VwZXJIZXhlc1tpXTtcbiAgICAgICAgICAgIHNoLmFnZSsrO1xuXG4gICAgICAgICAgICBpZiAoc2guc3RhdGUgPT09IDAgJiYgc2guYWdlID4gMzApIHtcbiAgICAgICAgICAgICAgICBzaC5zdGF0ZSA9IDE7XG4gICAgICAgICAgICAgICAgc2guYWdlICAgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzaC5zdGF0ZSA9PT0gMSAmJiBzaC5hZ2UgPiAxMjApIHtcbiAgICAgICAgICAgICAgICBzaC5zdGF0ZSA9IDI7XG4gICAgICAgICAgICAgICAgc2guYWdlICAgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzaC5zdGF0ZSA9PT0gMiAmJiBzaC5hZ2UgPiAzMCkge1xuICAgICAgICAgICAgICAgIC8vIERvbmUgLSBUcmlnZ2VyIFVwbG9hZFxuICAgICAgICAgICAgICAgIGxldCBpZHggPSBzaC5jZW50ZXJJZHgsXG4gICAgICAgICAgICAgICAgICAgIHggICA9IG1lLmNlbGxCdWZmZXJbaWR4ICsgMl0sXG4gICAgICAgICAgICAgICAgICAgIHkgICA9IG1lLmNlbGxCdWZmZXJbaWR4ICsgM107XG5cbiAgICAgICAgICAgICAgICBtZS5zcGF3blBhcnRpY2xlcyh4LCB5LCAxMiwgJ3VwbG9hZCcpO1xuXG4gICAgICAgICAgICAgICAgc2gubmVpZ2hib3JzLmZvckVhY2gobklkeCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmNlbGxCdWZmZXJbbklkeCArIDRdID0gMTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBtZS5zdXBlckhleGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHRhcmdldFNjYWxlID0gMTtcbiAgICAgICAgICAgIGlmIChzaC5zdGF0ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRhcmdldFNjYWxlID0gMSAtIChzaC5hZ2UgLyAzMCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNoLnN0YXRlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0U2NhbGUgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRTY2FsZSA9IHNoLmFnZSAvIDMwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzaC5uZWlnaGJvcnMuZm9yRWFjaChuSWR4ID0+IHtcbiAgICAgICAgICAgICAgICBtZS5jZWxsQnVmZmVyW25JZHggKyA0XSA9IHRhcmdldFNjYWxlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyBpbW1lZGlhdGUgbmVpZ2hib3JzIGZvciBTdXBlciBIZXggZm9ybWF0aW9uLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjZW50ZXJJZHhcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyW119IEFycmF5IG9mIG5laWdoYm9yIGluZGljZXNcbiAgICAgKi9cbiAgICBmaW5kTmVpZ2hib3JzKGNlbnRlcklkeCkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGJ1ZmZlciAgICA9IG1lLmNlbGxCdWZmZXIsXG4gICAgICAgICAgICBjeCAgICAgICAgPSBidWZmZXJbY2VudGVySWR4ICsgMl0sXG4gICAgICAgICAgICBjeSAgICAgICAgPSBidWZmZXJbY2VudGVySWR4ICsgM10sXG4gICAgICAgICAgICBuZWlnaGJvcnMgPSBbY2VudGVySWR4XSxcbiAgICAgICAgICAgIGNvdW50ICAgICA9IGJ1ZmZlci5sZW5ndGggLyBTVFJJREUsXG4gICAgICAgICAgICBzICAgICAgICAgPSBtZS5zY2FsZSxcbiAgICAgICAgICAgIHJhZGl1cyAgICA9IEhFWF9TSVpFICogcyAqIDIuMTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpZHggPSBpICogU1RSSURFO1xuICAgICAgICAgICAgaWYgKGlkeCA9PT0gY2VudGVySWR4KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCB4ICAgID0gYnVmZmVyW2lkeCArIDJdLFxuICAgICAgICAgICAgICAgIHkgICAgPSBidWZmZXJbaWR4ICsgM10sXG4gICAgICAgICAgICAgICAgZGlzdCA9IE1hdGguc3FydCgoeCAtIGN4KSAqKiAyICsgKHkgLSBjeSkgKiogMik7XG5cbiAgICAgICAgICAgIGlmIChkaXN0IDwgcmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goaWR4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmVpZ2hib3JzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgaW50ZXJhY3Rpb24gcGh5c2ljcyBmb3IgdGhlIG1haW4gbGF0dGljZS5cbiAgICAgKiBIYW5kbGVzIG1vdXNlIGhvdmVyIGVuZXJneSB0cmFuc2ZlciBhbmQgZGVjYXkuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqL1xuICAgIHVwZGF0ZVBoeXNpY3Mod2lkdGgsIGhlaWdodCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuICAgICAgICBpZiAoIW1lLmNlbGxCdWZmZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBidWZmZXIgPSBtZS5jZWxsQnVmZmVyLFxuICAgICAgICAgICAgY291bnQgID0gYnVmZmVyLmxlbmd0aCAvIFNUUklERSxcbiAgICAgICAgICAgIG14ICAgICA9IG1lLm1vdXNlLngsXG4gICAgICAgICAgICBteSAgICAgPSBtZS5tb3VzZS55LFxuICAgICAgICAgICAgcyAgICAgID0gbWUuc2NhbGU7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaWR4ICAgID0gaSAqIFNUUklERSxcbiAgICAgICAgICAgICAgICB4ICAgICAgPSBidWZmZXJbaWR4ICsgMl0sXG4gICAgICAgICAgICAgICAgeSAgICAgID0gYnVmZmVyW2lkeCArIDNdLFxuICAgICAgICAgICAgICAgIGFjdGl2ZSA9IDA7XG5cbiAgICAgICAgICAgIGlmIChteCAhPT0gLTEwMDApIHtcbiAgICAgICAgICAgICAgICBsZXQgZHggICAgID0geCAtIG14LFxuICAgICAgICAgICAgICAgICAgICBkeSAgICAgPSB5IC0gbXksXG4gICAgICAgICAgICAgICAgICAgIGRpc3RTcSA9IGR4ICogZHggKyBkeSAqIGR5LFxuICAgICAgICAgICAgICAgICAgICByYWRpdXMgPSAyNTAgKiBzO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRpc3RTcSA8IHJhZGl1cyAqIHJhZGl1cykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGlzdCA9IE1hdGguc3FydChkaXN0U3EpO1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmUgICA9IChyYWRpdXMgLSBkaXN0KSAvIHJhZGl1cztcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlICAgPSBNYXRoLnBvdyhhY3RpdmUsIDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGN1cnJlbnRFbmVyZ3kgPSBidWZmZXJbaWR4ICsgNV07XG4gICAgICAgICAgICBsZXQgdGFyZ2V0RW5lcmd5ICA9IGFjdGl2ZSAqIDAuODtcblxuICAgICAgICAgICAgLy8gU3BlZWQgdXAgaG92ZXIgcmVhY3Rpb24gKDAuMSAtPiAwLjMpXG4gICAgICAgICAgICBpZiAoY3VycmVudEVuZXJneSA+IHRhcmdldEVuZXJneSkge1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltpZHggKyA1XSAqPSAwLjk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltpZHggKyA1XSArPSAodGFyZ2V0RW5lcmd5IC0gY3VycmVudEVuZXJneSkgKiAwLjM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChidWZmZXJbaWR4ICsgNV0gPCAwLjAwMSkge1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltpZHggKyA1XSA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChidWZmZXJbaWR4ICsgNl0gPiAwKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyW2lkeCArIDZdIC09IDAuMDU7XG4gICAgICAgICAgICAgICAgaWYgKGJ1ZmZlcltpZHggKyA2XSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2lkeCArIDZdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIE5ldXJhbCBBZ2VudCBsb2dpYyAoVGhlIFwiSW50ZWxsaWdlbmNlXCIgTGF5ZXIpLlxuICAgICAqXG4gICAgICogSW1wbGVtZW50cyBhIDItU3RhdGUgTWFjaGluZSBmb3IgQWdlbnRzOlxuICAgICAqXG4gICAgICogKipTdGF0ZSAwOiBNb3ZpbmcqKlxuICAgICAqIC0gQWdlbnRzIHRyYXZlbCBhbG9uZyBncmlkIGVkZ2VzIHRvIGEgdGFyZ2V0IG5vZGUuXG4gICAgICogLSBVc2VzIFwiTWFnbmV0aWMgUGF0aGZpbmRpbmdcIiB0byBiaWFzIG1vdmVtZW50IHRvd2FyZHMgdGhlIG1vdXNlIGN1cnNvci5cbiAgICAgKiAtIFVwb24gYXJyaXZhbCwgdGhlcmUgaXMgYSAqKjIwJSBjaGFuY2UqKiB0byBzd2l0Y2ggdG8gXCJTY2FubmluZ1wiLlxuICAgICAqXG4gICAgICogKipTdGF0ZSAxOiBTY2FubmluZyoqXG4gICAgICogLSBUaGUgQWdlbnQgbG9ja3Mgb250byBhIG5vZGUgYW5kIHBlcmZvcm1zIGEgXCJEZWVwIFNjYW5cIiAodmlzdWFsaXplZCBhcyBhIHB1bHNlKS5cbiAgICAgKiAtICoqQ29uc3RydWN0aW9uIFRyaWdnZXI6KiogV2hlbiB0aGUgc2NhbiBjb21wbGV0ZXMsIHRoZSBBZ2VudCBpbmplY3RzIG1hc3NpdmUgYEJ1aWxkQ2hhcmdlYCAoKzUpXG4gICAgICogICBpbnRvIHRoZSBub2RlLiBUaGlzIGRldGVybWluaXN0aWNhbGx5IHRyaWdnZXJzIHRoZSBmb3JtYXRpb24gb2YgYSAqKlN1cGVyIEhleCoqLCBjcmVhdGluZ1xuICAgICAqICAgYSBkaXJlY3QgY2F1c2UtYW5kLWVmZmVjdCByZWxhdGlvbnNoaXAgYmV0d2VlbiBcIkFnZW50IFdvcmtcIiBhbmQgXCJTdHJ1Y3R1cmUgQ3JlYXRpb25cIi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgKi9cbiAgICB1cGRhdGVSdW5uZXJzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcbiAgICAgICAgaWYgKCFtZS5ydW5uZXJCdWZmZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBydW5uZXJzID0gbWUucnVubmVyQnVmZmVyLFxuICAgICAgICAgICAgbm9kZXMgICA9IG1lLmNlbGxCdWZmZXIsXG4gICAgICAgICAgICBjb3VudCAgID0gUlVOTkVSX0NPVU5ULFxuICAgICAgICAgICAgcyAgICAgICA9IG1lLnNjYWxlO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkeCAgICAgID0gaSAqIFJVTk5FUl9TVFJJREUsXG4gICAgICAgICAgICAgICAgc3RhdGUgICAgPSBydW5uZXJzW2lkeCArIDhdO1xuXG4gICAgICAgICAgICAvLyBTVEFURSAwOiBNT1ZJTkdcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxldCBwcm9ncmVzcyA9IHJ1bm5lcnNbaWR4ICsgNF0sXG4gICAgICAgICAgICAgICAgICAgIHNwZWVkICAgID0gcnVubmVyc1tpZHggKyA1XTtcblxuICAgICAgICAgICAgICAgIGlmIChwcm9ncmVzcyA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHggID0gcnVubmVyc1tpZHhdLFxuICAgICAgICAgICAgICAgICAgICAgICAgeSAgPSBydW5uZXJzW2lkeCArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHggPSBydW5uZXJzW2lkeCArIDJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHkgPSBydW5uZXJzW2lkeCArIDNdO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBkeCAgID0gdHggLSB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgZHkgICA9IHR5IC0geSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3QgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXN0IDwgc3BlZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5lcnNbaWR4XSAgICAgPSB0eDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5lcnNbaWR4ICsgMV0gPSB0eTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5lcnNbaWR4ICsgNF0gPSAxOyAvLyBBcnJpdmVkXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlY2lzaW9uIFBvaW50OiBTY2FuIG9yIE1vdmU/XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAyMCUgQ2hhbmNlIHRvIFNjYW4sIGJ1dCBvbmx5IGlmIG9uIGEgdmFsaWQgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGVJZHggPSBtZS5maW5kTmVhcmVzdE5vZGUodHgsIHR5KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVJZHggIT09IC0xICYmIE1hdGgucmFuZG9tKCkgPiAwLjgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydW5uZXJzW2lkeCArIDhdID0gMTsgLy8gU3dpdGNoIHRvIFNjYW5uaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVubmVyc1tpZHggKyA5XSA9IDA7IC8vIFJlc2V0IFNjYW4gVGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5lcnNbaWR4ICsgNl0gPSBub2RlSWR4OyAvLyBMb2NrIHRvIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSnVzdCBwYXNzaW5nIHRocm91Z2ggLSBTdGFuZGFyZCBFbmVyZ3kgQm9vc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZUlkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXNbbm9kZUlkeCArIDVdID0gMS4wOyAvLyBGbGFzaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlc1tub2RlSWR4ICsgNl0gKz0gMC41OyAvLyBTbWFsbCBjb250cmlidXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXNbbm9kZUlkeCArIDddID0gcnVubmVyc1tpZHggKyA3XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVubmVyc1tpZHggKyA2XSAgID0gbm9kZUlkeDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBydW5uZXJzW2lkeF0gICAgICs9IChkeCAvIGRpc3QpICogc3BlZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBydW5uZXJzW2lkeCArIDFdICs9IChkeSAvIGRpc3QpICogc3BlZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBQaWNrIE5leHQgVGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW50SGV4SWR4ID0gcnVubmVyc1tpZHggKyA2XTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudEhleElkeCAhPT0gdW5kZWZpbmVkICYmIGN1cnJlbnRIZXhJZHggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWduZXRpYyBMb2dpYzogQmlhcyBkaXJlY3Rpb24gdG93YXJkcyBtb3VzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJlc3REaXIgICA9IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RTY29yZSA9IC1JbmZpbml0eTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHdlaWdodHMgPSBbMSwgMSwgMSwgMSwgMSwgMV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZS5tb3VzZS54ICE9PSAtMTAwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjeCA9IHJ1bm5lcnNbaWR4XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3kgPSBydW5uZXJzW2lkeCArIDFdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCA2OyBkKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRlZyAgPSAzMCArIChkICogNjApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFkICA9IGRlZyAqIE1hdGguUEkgLyAxODAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqdW1wID0gSEVYX1NJWkUgKiBzICogTWF0aC5zcXJ0KDMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHggICA9IGN4ICsgTWF0aC5jb3MocmFkKSAqIGp1bXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eSAgID0gY3kgKyBNYXRoLnNpbihyYWQpICoganVtcDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGlzdFNxID0gKHR4IC0gbWUubW91c2UueCkgKiogMiArICh0eSAtIG1lLm1vdXNlLnkpICoqIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodHNbZF0gKz0gKDEwMDAwMCAvIChkaXN0U3EgKyAxMDApKSAqIDU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdG90YWxXZWlnaHQgPSB3ZWlnaHRzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmRvbSAgICAgID0gTWF0aC5yYW5kb20oKSAqIHRvdGFsV2VpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1bSAgICAgICAgID0gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXIgICAgICAgICA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgNjsgZCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VtICs9IHdlaWdodHNbZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmRvbSA8PSBzdW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyID0gZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGVnICA9IDMwICsgKGRpciAqIDYwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWQgID0gZGVnICogTWF0aC5QSSAvIDE4MCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqdW1wID0gSEVYX1NJWkUgKiBzICogTWF0aC5zcXJ0KDMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4ICAgPSBydW5uZXJzW2lkeF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3kgICA9IHJ1bm5lcnNbaWR4ICsgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHggICA9IGN4ICsgTWF0aC5jb3MocmFkKSAqIGp1bXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHkgICA9IGN5ICsgTWF0aC5zaW4ocmFkKSAqIGp1bXA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eCA8IC01MCB8fCB0eCA+IHdpZHRoICsgNTAgfHwgdHkgPCAtNTAwIHx8IHR5ID4gaGVpZ2h0ICsgNTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5yZXNldFJ1bm5lcihpLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcnVubmVyc1tpZHggKyAyXSA9IHR4O1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVubmVyc1tpZHggKyAzXSA9IHR5O1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVubmVyc1tpZHggKyA0XSA9IDA7IC8vIFJlc2V0IHByb2dyZXNzXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5yZXNldFJ1bm5lcihpLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNUQVRFIDE6IFNDQU5OSU5HXG4gICAgICAgICAgICBlbHNlIGlmIChzdGF0ZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIEluY3JlbWVudCBTY2FuIFRpbWVcbiAgICAgICAgICAgICAgICBydW5uZXJzW2lkeCArIDldICs9IDAuMDI7IC8vIFNjYW4gc3BlZWRcblxuICAgICAgICAgICAgICAgIC8vIFZpc3VhbCBFZmZlY3Qgb24gTm9kZSAoUHVsc2UpXG4gICAgICAgICAgICAgICAgbGV0IG5vZGVJZHggPSBydW5uZXJzW2lkeCArIDZdO1xuICAgICAgICAgICAgICAgIGlmIChub2RlSWR4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgbm9kZXNbbm9kZUlkeCArIDVdID0gMC41ICsgKE1hdGguc2luKHJ1bm5lcnNbaWR4ICsgOV0gKiAxMCkgKiAwLjUpOyAvLyBQdWxzZSBFbmVyZ3lcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBTY2FuIENvbXBsZXRlP1xuICAgICAgICAgICAgICAgIGlmIChydW5uZXJzW2lkeCArIDldID49IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVubmVyc1tpZHggKyA4XSA9IDA7IC8vIFJlc3VtZSBNb3ZpbmdcblxuICAgICAgICAgICAgICAgICAgICAvLyBUSEUgUEFZT0ZGOiBNYXNzaXZlIEJ1aWxkQ2hhcmdlIGluamVjdGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZUlkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzW25vZGVJZHggKyA2XSArPSA1OyAvLyBJbnN0YW50IFN1cGVyIEhleCBUcmlnZ2VyICg+MylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzW25vZGVJZHggKyA1XSA9IDEuMDsgLy8gTWF4IEVuZXJneVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXNbbm9kZUlkeCArIDddID0gcnVubmVyc1tpZHggKyA3XTsgLy8gQ29sb3JcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgY2FtZXJhIHJvdGF0aW9uIGJhc2VkIG9uIG1vdXNlIHBvc2l0aW9uLlxuICAgICAqIENyZWF0ZXMgYSBcIkZsb29yIFBlcnNwZWN0aXZlXCIgdGlsdCBlZmZlY3QuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqL1xuICAgIHVwZGF0ZVJvdGF0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIG14ID0gbWUubW91c2UueCxcbiAgICAgICAgICAgIG15ID0gbWUubW91c2UueSxcbiAgICAgICAgICAgIHR4ID0gLTAuNCwgLy8gQmFzZSB0aWx0IFggKHBpdGNoKVxuICAgICAgICAgICAgdHkgPSAwOyAgIC8vIEJhc2UgeWF3XG5cbiAgICAgICAgaWYgKG14ICE9PSAtMTAwMCkge1xuICAgICAgICAgICAgLy8gTWFwIG1vdXNlIFggdG8gWWF3ICgrLy0gMC4yIHJhZClcbiAgICAgICAgICAgIHR5ID0gKChteCAvIHdpZHRoKSAtIDAuNSkgKiAwLjQ7XG4gICAgICAgICAgICAvLyBNYXAgbW91c2UgWSB0byBQaXRjaCAoLTAuNiB0byAtMC4yIHJhZClcbiAgICAgICAgICAgIHR4ID0gLTAuNCArICgobXkgLyBoZWlnaHQpIC0gMC41KSAqIDAuNDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNtb290aCBpbnRlcnBvbGF0ZVxuICAgICAgICBtZS5yb3RhdGlvbi54ICs9ICh0eCAtIG1lLnJvdGF0aW9uLngpICogMC4wNTtcbiAgICAgICAgbWUucm90YXRpb24ueSArPSAodHkgLSBtZS5yb3RhdGlvbi55KSAqIDAuMDU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcHJvamVjdGlvbiBtYXRyaXggYmFzZWQgb24gY3VycmVudCByb3RhdGlvbiBhbmQgc2l6ZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAgICovXG4gICAgdXBkYXRlUHJvamVjdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBwbSA9IG1lLnByb2plY3Rpb25NYXRyaXg7XG5cbiAgICAgICAgcG0uY3ggICA9IHdpZHRoIC8gMjtcbiAgICAgICAgcG0uY3kgICA9IGhlaWdodCAvIDI7XG4gICAgICAgIHBtLmNvc1ggPSBNYXRoLmNvcyhtZS5yb3RhdGlvbi54KTtcbiAgICAgICAgcG0uc2luWCA9IE1hdGguc2luKG1lLnJvdGF0aW9uLngpO1xuICAgICAgICBwbS5jb3NZID0gTWF0aC5jb3MobWUucm90YXRpb24ueSk7XG4gICAgICAgIHBtLnNpblkgPSBNYXRoLnNpbihtZS5yb3RhdGlvbi55KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9qZWN0cyBhIDNEIHBvaW50IHRvIDJEIHNjcmVlbiBzcGFjZSB1c2luZyB0aGUgY2FjaGVkIG1hdHJpeC5cbiAgICAgKiB3cml0ZXMgcmVzdWx0IHRvIHRoaXMucHJvamVjdGlvblBvaW50IHRvIGF2b2lkIGFsbG9jYXRpb24uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB6XG4gICAgICogQHJldHVybnMge09iamVjdH0gdGhpcy5wcm9qZWN0aW9uUG9pbnRcbiAgICAgKi9cbiAgICBwcm9qZWN0KHgsIHksIHopIHtcbiAgICAgICAgbGV0IG1lICA9IHRoaXMsXG4gICAgICAgICAgICBwbSAgPSBtZS5wcm9qZWN0aW9uTWF0cml4LFxuICAgICAgICAgICAgcHAgID0gbWUucHJvamVjdGlvblBvaW50LFxuICAgICAgICAgICAgZm92ID0gMTAwMCxcbiAgICAgICAgICAgIGR4ICA9IHggLSBwbS5jeCxcbiAgICAgICAgICAgIGR5ICA9IHkgLSBwbS5jeSxcbiAgICAgICAgICAgIGR6ICA9IHo7XG5cbiAgICAgICAgLy8gUm90YXRlIFlcbiAgICAgICAgbGV0IHgxID0gZHggKiBwbS5jb3NZIC0gZHogKiBwbS5zaW5ZO1xuICAgICAgICBsZXQgejEgPSBkeiAqIHBtLmNvc1kgKyBkeCAqIHBtLnNpblk7XG5cbiAgICAgICAgLy8gUm90YXRlIFhcbiAgICAgICAgbGV0IHkyID0gZHkgKiBwbS5jb3NYIC0gejEgKiBwbS5zaW5YO1xuICAgICAgICBsZXQgejIgPSB6MSAqIHBtLmNvc1ggKyBkeSAqIHBtLnNpblg7XG5cbiAgICAgICAgLy8gUHJvamVjdFxuICAgICAgICBsZXQgc2NhbGUgPSBmb3YgLyAoZm92ICsgejIpO1xuXG4gICAgICAgIHBwLnggICAgICAgPSB4MSAqIHNjYWxlICsgcG0uY3g7XG4gICAgICAgIHBwLnkgICAgICAgPSB5MiAqIHNjYWxlICsgcG0uY3k7XG4gICAgICAgIHBwLnNjYWxlICAgPSBzY2FsZTtcbiAgICAgICAgcHAudmlzaWJsZSA9IHoyID4gLWZvdjsgLy8gQ2xpcCBpZiBiZWhpbmQgY2FtZXJhXG5cbiAgICAgICAgcmV0dXJuIHBwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW5kIGNhY2hlcyBncmFkaWVudHMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqL1xuICAgIHVwZGF0ZVJlc291cmNlcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGxldCBtZSAgPSB0aGlzLFxuICAgICAgICAgICAgY3R4ID0gbWUuY29udGV4dDtcblxuICAgICAgICBpZiAoIWN0eCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIHRoZW1lQ29sb3JzID0gbWUuY29uc3RydWN0b3IuY29sb3JzW21lLnRoZW1lXSxcbiAgICAgICAgICAgIGdyYWRpZW50ICAgID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCB0aGVtZUNvbG9ycy5iYWNrZ3JvdW5kWzBdKTtcbiAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsIHRoZW1lQ29sb3JzLmJhY2tncm91bmRbMV0pO1xuXG4gICAgICAgIG1lLmdyYWRpZW50cy5iZ0dyYWRpZW50ID0gZ3JhZGllbnRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGNhbnZhcyByZXNpemUuXG4gICAgICogUmUtY2FsY3VsYXRlcyBzY2FsZSBhbmQgcmUtaW5pdGlhbGl6ZXMgYnVmZmVycy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2l6ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzaXplLmhlaWdodFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzaXplLndpZHRoXG4gICAgICovXG4gICAgdXBkYXRlU2l6ZShzaXplKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzO1xuICAgICAgICBtZS5jYW52YXNTaXplID0gc2l6ZTtcbiAgICAgICAgbWUuc2NhbGUgICAgICA9IE1hdGguc3FydCgoc2l6ZS53aWR0aCAqIHNpemUuaGVpZ2h0KSAvIDIwNzM2MDApO1xuXG4gICAgICAgIGlmIChtZS5jb250ZXh0KSB7XG4gICAgICAgICAgICBtZS5jb250ZXh0LmNhbnZhcy53aWR0aCAgPSBzaXplLndpZHRoO1xuICAgICAgICAgICAgbWUuY29udGV4dC5jYW52YXMuaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgICBtZS5jZWxsQnVmZmVyICAgICAgICAgICAgPSBudWxsO1xuICAgICAgICAgICAgbWUucnVubmVyQnVmZmVyICAgICAgICAgID0gbnVsbDtcbiAgICAgICAgICAgIG1lLmtlcm5lbEJ1ZmZlciAgICAgICAgICA9IG51bGw7XG4gICAgICAgICAgICBtZS5zdHJhdGFCdWZmZXIgICAgICAgICAgPSBudWxsO1xuICAgICAgICAgICAgbWUuZGVicmlzQnVmZmVyICAgICAgICAgID0gbnVsbDtcbiAgICAgICAgICAgIG1lLmluaXROb2RlcyhzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG4gICAgICAgICAgICBtZS51cGRhdGVSZXNvdXJjZXMoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFNlcnZpY2VzQ2FudmFzKTtcbiIsImltcG9ydCBOZW9CYXNlIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuXG4vKipcbiAqIEBzdW1tYXJ5IEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIENhbnZhcyBSZW5kZXJlcnMuXG4gKlxuICogVGhpcyBjbGFzcyBzZXJ2ZXMgYXMgdGhlIGZvdW5kYXRpb24gZm9yIHRoZSBzcGVjaWFsaXplZCBjYW52YXMgdmlzdWFsaXphdGlvbnMgKEhlYWRlciwgSG9tZSwgU2VydmljZXMsIFRpY2tldClcbiAqIHRoYXQgcnVuIHdpdGhpbiB0aGUgKipOZW8ubWpzIENhbnZhcyBTaGFyZWRXb3JrZXIqKi5cbiAqXG4gKiBJdCBjcmVhdGVzIGhlbHBlciBzaW5nbGV0b25zIHRoYXQgbWFuYWdlIHRoZWlyIG93biBgT2Zmc2NyZWVuQ2FudmFzYCBpbnN0YW5jZXMsIHByb3ZpZGluZyBhIHN0YW5kYXJkaXplZFxuICogYXJjaGl0ZWN0dXJlIGZvcjpcbiAqIC0gKipMaWZlY3ljbGUgTWFuYWdlbWVudDoqKiBJbml0aWFsaXphdGlvbiAoYGluaXRHcmFwaGApLCBkZXN0cnVjdGlvbiAoYGNsZWFyR3JhcGhgKSwgYW5kIHJlc291cmNlIGNsZWFudXAuXG4gKiAtICoqUmVuZGVyIExvb3AgQ29udHJvbDoqKiBVbmlmaWVkIGByZW5kZXJgIGxvb3Agd2l0aCBwYXVzZS9yZXN1bWUgY2FwYWJpbGl0aWVzIGFuZCBmcmFtZSBzY2hlZHVsaW5nLlxuICogLSAqKkNvbnRleHQgTWFuYWdlbWVudDoqKiBSb2J1c3QgaGFuZGxpbmcgb2YgYE9mZnNjcmVlbkNhbnZhc2AgdHJhbnNmZXIgYW5kIGNvbnRleHQgYWNxdWlzaXRpb24gdmlhIGB3YWl0Rm9yQ2FudmFzYC5cbiAqIC0gKipTaGFyZWQgU3RhdGU6KiogQ29tbW9uIHN0YXRlIG1hbmFnZW1lbnQgZm9yIG1vdXNlIGludGVyYWN0aW9uLCB0aW1lLCBhbmQgdGhlbWluZy5cbiAqXG4gKiBUaGVzZSByZW5kZXJlcnMgb3BlcmF0ZSBvZmYgdGhlIG1haW4gdGhyZWFkIHRvIGVuc3VyZSBoaWdoLXBlcmZvcm1hbmNlLCA2MGZwcyBhbmltYXRpb25zIHdpdGhvdXRcbiAqIGJsb2NraW5nIHRoZSBVSS5cbiAqXG4gKiBAY2xhc3MgTmVvLmNhbnZhcy5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIEJhc2UgZXh0ZW5kcyBOZW9CYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jYW52YXMuQmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNhbnZhcy5CYXNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW90ZSBtZXRob2QgYWNjZXNzXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gcmVtb3RlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHJlbW90ZToge1xuICAgICAgICAgICAgYXBwOiBbXG4gICAgICAgICAgICAgICAgJ2NsZWFyR3JhcGgnLFxuICAgICAgICAgICAgICAgICdpbml0R3JhcGgnLFxuICAgICAgICAgICAgICAgICdwYXVzZScsXG4gICAgICAgICAgICAgICAgJ3Jlc3VtZScsXG4gICAgICAgICAgICAgICAgJ3NldFRoZW1lJyxcbiAgICAgICAgICAgICAgICAndXBkYXRlTW91c2VTdGF0ZScsXG4gICAgICAgICAgICAgICAgJ3VwZGF0ZVNpemUnXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYWN0aXZlIGNvbG9yIHRoZW1lICgnbGlnaHQnIG9yICdkYXJrJykuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gdGhlbWVfPSdsaWdodCdcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB0aGVtZV86ICdsaWdodCdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gYW5pbWF0aW9uSWQ9bnVsbFxuICAgICAqL1xuICAgIGFuaW1hdGlvbklkID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBjYW52YXNJZD1udWxsXG4gICAgICovXG4gICAgY2FudmFzSWQgPSBudWxsXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGNhbnZhc1NpemU9bnVsbFxuICAgICAqL1xuICAgIGNhbnZhc1NpemUgPSBudWxsXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2Zmc2NyZWVuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfG51bGx9IGNvbnRleHQ9bnVsbFxuICAgICAqL1xuICAgIGNvbnRleHQgPSBudWxsXG4gICAgLyoqXG4gICAgICogQ2FjaGUgZm9yIHJldXNhYmxlIGdyYWRpZW50cyB0byBwcmV2ZW50IEdDLlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gZ3JhZGllbnRzPXt9XG4gICAgICovXG4gICAgZ3JhZGllbnRzID0ge31cbiAgICAvKipcbiAgICAgKiBGbGFnIHRvIHBhdXNlIHRoZSByZW5kZXIgbG9vcC5cbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc1BhdXNlZD1mYWxzZVxuICAgICAqL1xuICAgIGlzUGF1c2VkID0gZmFsc2VcbiAgICAvKipcbiAgICAgKiBUcmFja2VkIG1vdXNlIHBvc2l0aW9uIGZvciBpbnRlcmFjdGl2ZSBwaHlzaWNzLlxuICAgICAqIEluaXRpYWxpemUgb2ZmLXNjcmVlbiB0byBwcmV2ZW50IHN0YXJ0dXAgaml0dGVycy5cbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vdXNlPXt4OiAtMTAwMCwgeTogLTEwMDB9XG4gICAgICovXG4gICAgbW91c2UgPSB7eDogLTEwMDAsIHk6IC0xMDAwfVxuICAgIC8qKlxuICAgICAqIEdsb2JhbCBzaW11bGF0aW9uIHRpbWUuXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSB0aW1lPTBcbiAgICAgKi9cbiAgICB0aW1lID0gMFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7RnVuY3Rpb259IHJlbmRlckxvb3A9dGhpcy5yZW5kZXIuYmluZCh0aGlzKVxuICAgICAqL1xuICAgIHJlbmRlckxvb3AgPSB0aGlzLnJlbmRlci5iaW5kKHRoaXMpXG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGB0aGVtZWAgY29uZmlnIGlzIGNoYW5nZWQuXG4gICAgICogVXBkYXRlcyB0aGUgcmVzb3VyY2UgY2FjaGUgKGdyYWRpZW50cywgY29sb3JzKSB0byByZWZsZWN0IHRoZSBuZXcgdGhlbWUgaW1tZWRpYXRlbHkuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICovXG4gICAgYWZ0ZXJTZXRUaGVtZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICYmIHRoaXMuY2FudmFzU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVSZXNvdXJjZXM/Lih0aGlzLmNhbnZhc1NpemUud2lkdGgsIHRoaXMuY2FudmFzU2l6ZS5oZWlnaHQpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGNhbnZhcyBpcyByZWFkeSB0byByZW5kZXIuXG4gICAgICogUmV0dXJucyB0cnVlIG9ubHkgaWYgdGhlIGNvbnRleHQgZXhpc3RzIGFuZCB0aGUgc2ltdWxhdGlvbiBpcyBub3QgcGF1c2VkLlxuICAgICAqIFN1YmNsYXNzZXMgc2hvdWxkIGNhbGwgdGhpcyBhdCB0aGUgc3RhcnQgb2YgdGhlaXIgYHJlbmRlcmAgbG9vcC5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgY2FuUmVuZGVyKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuICAgICAgICByZXR1cm4gISEobWUuY29udGV4dCAmJiAhbWUuaXNQYXVzZWQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBncmFwaCBzdGF0ZSBhbmQgc3RvcHMgdGhlIHJlbmRlciBsb29wLlxuICAgICAqIFVzZSB0aGlzIHRvIGNsZWFudXAgcmVzb3VyY2VzIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgb3IgdW5tb3VudGVkLlxuICAgICAqL1xuICAgIGNsZWFyR3JhcGgoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG4gICAgICAgIG1lLmNvbnRleHQgICAgID0gbnVsbDtcbiAgICAgICAgbWUuY2FudmFzSWQgICAgPSBudWxsO1xuICAgICAgICBtZS5jYW52YXNTaXplICA9IG51bGw7XG4gICAgICAgIG1lLmFuaW1hdGlvbklkID0gbnVsbDtcbiAgICAgICAgbWUuaXNQYXVzZWQgICAgPSBmYWxzZTtcbiAgICAgICAgbWUuZ3JhZGllbnRzICAgPSB7fTtcbiAgICAgICAgbWUubW91c2UgICAgICAgPSB7eDogLTEwMDAsIHk6IC0xMDAwfTtcbiAgICAgICAgbWUudGltZSAgICAgICAgPSAwXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIGNhbnZhcyBjb250ZXh0LlxuICAgICAqIFN0YXJ0cyB0aGUgcG9sbGluZyBtZWNoYW5pc20gdG8gd2FpdCBmb3IgdGhlIE9mZnNjcmVlbkNhbnZhcyB0cmFuc2ZlciBmcm9tIHRoZSBNYWluIFRocmVhZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRzLmNhbnZhc0lkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdHMud2luZG93SWRcbiAgICAgKi9cbiAgICBpbml0R3JhcGgoe2NhbnZhc0lkLCB3aW5kb3dJZH0pIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBoYXNDaGFuZ2UgPSBtZS5jYW52YXNJZCAhPT0gY2FudmFzSWQ7XG5cbiAgICAgICAgbWUuY2FudmFzSWQgPSBjYW52YXNJZDtcblxuICAgICAgICBtZS53YWl0Rm9yQ2FudmFzKGNhbnZhc0lkLCB3aW5kb3dJZCwgaGFzQ2hhbmdlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhvb2sgZm9yIHN1YmNsYXNzZXMgdG8gaGFuZGxlIG1vdXNlIGNsaWNrcy5cbiAgICAgKiBDYWxsZWQgYnkgYHVwZGF0ZU1vdXNlU3RhdGVgIHdoZW4gYSBjbGljayBldmVudCBpcyByZWNlaXZlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uTW91c2VDbGljayhkYXRhKSB7fVxuXG4gICAgLyoqXG4gICAgICogUGF1c2VzIHRoZSBzaW11bGF0aW9uLlxuICAgICAqIFRoZSByZW5kZXIgbG9vcCB3aWxsIGV4aXQgZWFybHkgd2hpbGUgYGlzUGF1c2VkYCBpcyB0cnVlLlxuICAgICAqL1xuICAgIHBhdXNlKCkge1xuICAgICAgICB0aGlzLmlzUGF1c2VkID0gdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFic3RyYWN0IHJlbmRlciBtZXRob2QuXG4gICAgICogU3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byBkcmF3IHRoZSBmcmFtZS5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7fVxuXG4gICAgLyoqXG4gICAgICogUmVzdW1lcyB0aGUgc2ltdWxhdGlvbi5cbiAgICAgKiBJZiB0aGUgc2ltdWxhdGlvbiB3YXMgcGF1c2VkLCB0aGlzIHJlc3RhcnRzIHRoZSByZW5kZXIgbG9vcC5cbiAgICAgKi9cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmlzUGF1c2VkKSB7XG4gICAgICAgICAgICBtZS5pc1BhdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgbWUucmVuZGVyTG9vcCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHBvc2VkIG1ldGhvZCBmb3IgUmVtb3RlIEFjY2VzcyB0byB0cmlnZ2VyIHRoZSByZWFjdGl2ZSBjb25maWcgc2V0dGVyLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIHNldFRoZW1lKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudGhlbWUgPSB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGxvY2FsIG1vdXNlIHN0YXRlIGZyb20gbWFpbiB0aHJlYWQgZXZlbnRzLlxuICAgICAqIERlbGVnYXRlcyBjbGljayBldmVudHMgdG8gYG9uTW91c2VDbGlja2AuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkYXRhLmNsaWNrXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2RhdGEubGVhdmVdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtkYXRhLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtkYXRhLnldXG4gICAgICovXG4gICAgdXBkYXRlTW91c2VTdGF0ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKGRhdGEubGVhdmUpIHtcbiAgICAgICAgICAgIG1lLm1vdXNlLnggPSAtMTAwMDtcbiAgICAgICAgICAgIG1lLm1vdXNlLnkgPSAtMTAwMFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRhdGEueCAhPT0gdW5kZWZpbmVkKSBtZS5tb3VzZS54ID0gZGF0YS54O1xuICAgICAgICAgICAgaWYgKGRhdGEueSAhPT0gdW5kZWZpbmVkKSBtZS5tb3VzZS55ID0gZGF0YS55O1xuXG4gICAgICAgICAgICBpZiAoZGF0YS5jbGljaykge1xuICAgICAgICAgICAgICAgIG1lLm9uTW91c2VDbGljayhkYXRhKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgY2FudmFzIHNpemUgYW5kIHJlc2l6ZXMgdGhlIGludGVybmFsIGNvbnRleHQuXG4gICAgICogVHJpZ2dlcnMgYHVwZGF0ZVJlc291cmNlc2AgaG9vayB0byBhbGxvdyBzdWJjbGFzc2VzIHRvIHJlZ2VuZXJhdGUgYnVmZmVycy9ncmFkaWVudHMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNpemVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2l6ZS5oZWlnaHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2l6ZS53aWR0aFxuICAgICAqL1xuICAgIHVwZGF0ZVNpemUoc2l6ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmNhbnZhc1NpemUgPSBzaXplO1xuXG4gICAgICAgIGlmIChtZS5jb250ZXh0KSB7XG4gICAgICAgICAgICBtZS5jb250ZXh0LmNhbnZhcy53aWR0aCAgPSBzaXplLndpZHRoO1xuICAgICAgICAgICAgbWUuY29udGV4dC5jYW52YXMuaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgICAvLyBDYWxscyB0aGUgaG9vayB0byByZS1nZW5lcmF0ZSByZXNvdXJjZXMgaWYgaW1wbGVtZW50ZWRcbiAgICAgICAgICAgIG1lLnVwZGF0ZVJlc291cmNlcz8uKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUG9sbHMgZm9yIHRoZSBPZmZzY3JlZW5DYW52YXMgdW50aWwgaXQgaXMgYXZhaWxhYmxlIGluIHRoZSBXb3JrZXIncyBgY2FudmFzV2luZG93TWFwYC5cbiAgICAgKiBPbmNlIGZvdW5kLCBpdCBpbml0aWFsaXplcyB0aGUgY29udGV4dCBhbmQgc3RhcnRzIHRoZSByZW5kZXIgbG9vcC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2FudmFzSWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gd2luZG93SWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGhhc0NoYW5nZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB3YWl0Rm9yQ2FudmFzKGNhbnZhc0lkLCB3aW5kb3dJZCwgaGFzQ2hhbmdlKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY2FudmFzID0gTmVvLmN1cnJlbnRXb3JrZXIuY2FudmFzV2luZG93TWFwW2NhbnZhc0lkXT8uW3dpbmRvd0lkXTtcblxuICAgICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgICAgICBtZS5jb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgIC8vIFN0YW5kYXJkaXplIHNpemUgdXBkYXRlXG4gICAgICAgICAgICBtZS51cGRhdGVTaXplKHt3aWR0aDogY2FudmFzLndpZHRoLCBoZWlnaHQ6IGNhbnZhcy5oZWlnaHR9KTtcblxuICAgICAgICAgICAgLy8gT3B0aW9uYWwgaG9vayBmb3Igc3ViY2xhc3Nlc1xuICAgICAgICAgICAgbWUub25HcmFwaE1vdW50ZWQ/LihjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuXG4gICAgICAgICAgICBpZiAoaGFzQ2hhbmdlICYmICFtZS5hbmltYXRpb25JZCkge1xuICAgICAgICAgICAgICAgIG1lLnJlbmRlckxvb3AoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dChtZS53YWl0Rm9yQ2FudmFzLmJpbmQobWUsIGNhbnZhc0lkLCB3aW5kb3dJZCwgaGFzQ2hhbmdlKSwgNTApXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEJhc2UpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9