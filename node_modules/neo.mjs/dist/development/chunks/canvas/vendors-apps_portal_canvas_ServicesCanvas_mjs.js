export const __webpack_esm_id__ = "vendors-apps_portal_canvas_ServicesCanvas_mjs";
export const __webpack_esm_ids__ = ["vendors-apps_portal_canvas_ServicesCanvas_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./apps/portal/canvas/Base.mjs"
/*!*************************************!*\
  !*** ./apps/portal/canvas/Base.mjs ***!
  \*************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @summary Abstract base class for Portal Canvas Renderers.
 *
 * This class serves as the foundation for the specialized canvas visualizations (Header, Home, Services, Ticket)
 * that run within the **Neo.mjs Canvas SharedWorker**.
 *
 * It creates helper singletons that manage their own `OffscreenCanvas` instances, providing a standardized
 * architecture for:
 * - **Lifecycle Management:** Initialization (`initGraph`), destruction (`clearGraph`), and resource cleanup.
 * - **Render Loop Control:** Unified `render` loop with pause/resume capabilities and frame scheduling.
 * - **Context Management:** Robust handling of `OffscreenCanvas` transfer and context acquisition via `waitForCanvas`.
 * - **Shared State:** Common state management for mouse interaction, time, and theming.
 *
 * These renderers operate off the main thread to ensure high-performance, 60fps animations without
 * blocking the UI.
 *
 * @class Portal.canvas.Base
 * @extends Neo.core.Base
 */
class Base extends _src_core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.canvas.Base'
         * @protected
         */
        className: 'Portal.canvas.Base',
        /**
         * Remote method access
         * @member {Object} remote
         * @protected
         */
        remote: {
            app: [
                'clearGraph',
                'initGraph',
                'pause',
                'resume',
                'setTheme',
                'updateMouseState',
                'updateSize'
            ]
        },
        /**
         * The active color theme ('light' or 'dark').
         * @member {String} theme_='light'
         * @reactive
         */
        theme_: 'light'
    }

    /**
     * @member {Number|null} animationId=null
     */
    animationId = null
    /**
     * @member {String|null} canvasId=null
     */
    canvasId = null
    /**
     * @member {Object|null} canvasSize=null
     */
    canvasSize = null
    /**
     * @member {OffscreenCanvasRenderingContext2D|null} context=null
     */
    context = null
    /**
     * Cache for reusable gradients to prevent GC.
     * @member {Object} gradients={}
     */
    gradients = {}
    /**
     * Flag to pause the render loop.
     * @member {Boolean} isPaused=false
     */
    isPaused = false
    /**
     * Tracked mouse position for interactive physics.
     * Initialize off-screen to prevent startup jitters.
     * @member {Object} mouse={x: -1000, y: -1000}
     */
    mouse = {x: -1000, y: -1000}
    /**
     * Global simulation time.
     * @member {Number} time=0
     */
    time = 0

    /**
     * @member {Function} renderLoop=this.render.bind(this)
     */
    renderLoop = this.render.bind(this)

    /**
     * Triggered after the `theme` config is changed.
     * Updates the resource cache (gradients, colors) to reflect the new theme immediately.
     * @param {String} value
     * @param {String} oldValue
     */
    afterSetTheme(value, oldValue) {
        if (value && this.canvasSize) {
            this.updateResources?.(this.canvasSize.width, this.canvasSize.height)
        }
    }

    /**
     * Checks if the canvas is ready to render.
     * Returns true only if the context exists and the simulation is not paused.
     * Subclasses should call this at the start of their `render` loop.
     * @returns {Boolean}
     */
    get canRender() {
        let me = this;
        return !!(me.context && !me.isPaused)
    }

    /**
     * Clears the graph state and stops the render loop.
     * Use this to cleanup resources when the component is destroyed or unmounted.
     */
    clearGraph() {
        let me = this;
        me.context     = null;
        me.canvasId    = null;
        me.canvasSize  = null;
        me.animationId = null;
        me.isPaused    = false;
        me.gradients   = {};
        me.mouse       = {x: -1000, y: -1000};
        me.time        = 0
    }

    /**
     * Initializes the canvas context.
     * Starts the polling mechanism to wait for the OffscreenCanvas transfer from the Main Thread.
     * @param {Object} opts
     * @param {String} opts.canvasId
     * @param {String} opts.windowId
     */
    initGraph({canvasId, windowId}) {
        let me        = this,
            hasChange = me.canvasId !== canvasId;

        me.canvasId = canvasId;

        me.waitForCanvas(canvasId, windowId, hasChange)
    }

    /**
     * Hook for subclasses to handle mouse clicks.
     * Called by `updateMouseState` when a click event is received.
     * @param {Object} data
     */
    onMouseClick(data) {}

    /**
     * Pauses the simulation.
     * The render loop will exit early while `isPaused` is true.
     */
    pause() {
        this.isPaused = true
    }

    /**
     * Abstract render method.
     * Subclasses must implement this method to draw the frame.
     */
    render() {}

    /**
     * Resumes the simulation.
     * If the simulation was paused, this restarts the render loop.
     */
    resume() {
        let me = this;

        if (me.isPaused) {
            me.isPaused = false;
            me.renderLoop()
        }
    }

    /**
     * Exposed method for Remote Access to trigger the reactive config setter.
     * @param {String} value
     */
    setTheme(value) {
        this.theme = value
    }

    /**
     * Updates the local mouse state from main thread events.
     * Delegates click events to `onMouseClick`.
     * @param {Object} data
     * @param {Boolean} [data.click]
     * @param {Boolean} [data.leave]
     * @param {Number} [data.x]
     * @param {Number} [data.y]
     */
    updateMouseState(data) {
        let me = this;

        if (data.leave) {
            me.mouse.x = -1000;
            me.mouse.y = -1000
        } else {
            if (data.x !== undefined) me.mouse.x = data.x;
            if (data.y !== undefined) me.mouse.y = data.y;

            if (data.click) {
                me.onMouseClick(data)
            }
        }
    }

    /**
     * Updates the canvas size and resizes the internal context.
     * Triggers `updateResources` hook to allow subclasses to regenerate buffers/gradients.
     * @param {Object} size
     * @param {Number} size.height
     * @param {Number} size.width
     */
    updateSize(size) {
        let me = this;

        me.canvasSize = size;

        if (me.context) {
            me.context.canvas.width  = size.width;
            me.context.canvas.height = size.height;
            // Calls the hook to re-generate resources if implemented
            me.updateResources?.(size.width, size.height)
        }
    }

    /**
     * Polls for the OffscreenCanvas until it is available in the Worker's `canvasWindowMap`.
     * Once found, it initializes the context and starts the render loop.
     * @param {String} canvasId
     * @param {String} windowId
     * @param {Boolean} hasChange
     * @protected
     */
    waitForCanvas(canvasId, windowId, hasChange) {
        let me     = this,
            canvas = Neo.currentWorker.canvasWindowMap[canvasId]?.[windowId];

        if (canvas) {
            me.context = canvas.getContext('2d');

            // Standardize size update
            me.updateSize({width: canvas.width, height: canvas.height});

            // Optional hook for subclasses
            me.onGraphMounted?.(canvas.width, canvas.height);

            if (hasChange && !me.animationId) {
                me.renderLoop()
            }
        } else {
            setTimeout(me.waitForCanvas.bind(me, canvasId, windowId, hasChange), 50)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Base));


/***/ },

/***/ "./apps/portal/canvas/ServicesCanvas.mjs"
/*!***********************************************!*\
  !*** ./apps/portal/canvas/ServicesCanvas.mjs ***!
  \***********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./apps/portal/canvas/Base.mjs");


const
    hasRaf          = typeof requestAnimationFrame === 'function',
    HEX_SIZE        = 30,
    STRIDE          = 8,  // q, r, x, y, scale, energy, buildCharge, colorIdx
    RUNNER_COUNT    = 30,
    /**
     * Agent Buffer Layout (Float32Array):
     * - 0: x (Current X)
     * - 1: y (Current Y)
     * - 2: tx (Target X)
     * - 3: ty (Target Y)
     * - 4: progress (Animation progress, 0-1)
     * - 5: speed (Movement speed)
     * - 6: currentHexIdx (Index of occupied node)
     * - 7: colorIdx (Palette index)
     * - 8: state (0 = Moving, 1 = Scanning)
     * - 9: scanTime (0-1 progress of the scan action)
     */
    RUNNER_STRIDE   = 10,
    SUPER_HEX_MAX   = 5,
    KERNEL_HEX_SIZE = 120,
    PARTICLE_COUNT  = 200,
    PARTICLE_STRIDE = 8, // x, y, z, vx, vy, vz, life, colorIdx
    STRATA_COUNT    = 15,
    STRATA_STRIDE   = 4; // x, y, z, size

/**
 * @summary SharedWorker renderer for the Portal Services "Neural Fabric" background.
 *
 * Implements a **Hexagonal Fabric** representing the engineered, structured nature of the Neo.mjs runtime.
 * The grid acts as a living "Motherboard" or "VDOM Registry" where cells (Components) can be inspected
 * and mutated.
 *
 * **Visual Architecture:**
 * 1. **Kernel Layer (Parallax):** A deep, slow-moving background grid representing the framework core.
 * 2. **Data Strata (Mid-Ground):** Floating clusters bridging the depth gap.
 * 3. **Application Layer (Fabric):** The main efficient structure (The App Engine).
 * 4. **Neural Agents:** High-speed packets visualizing throughput and intelligent maintenance.
 * 5. **Runtime Permutation:** Dynamic fusion of cells into "Super Modules" (construction/upload effects).
 * 6. **Construction Particles:** Particle effects visualizing memory allocation and object assembly.
 *
 * **Performance Architecture (Zero-Allocation):**
 * To ensure 60fps performance on high-resolution displays, this class employs a strict **Zero-Allocation** strategy:
 * 1.  **TypedArray Buffers:** All entity data is stored in pre-allocated `Float32Array` buffers.
 * 2.  **Persistent Objects:** Reusable objects (like `projectionPoint`, `projectionMatrix`) are used
 *     instead of creating new objects per frame.
 * 3.  **Inlined Math:** Projection and vector calculations are performed in-place.
 *
 * **Node Buffer Layout (Float32Array):**
 * - 0: q (Axial Coord Q)
 * - 1: r (Axial Coord R)
 * - 2: x (Screen X)
 * - 3: y (Screen Y)
 * - 4: scale (Visual scale, 0-1)
 * - 5: energy (Interaction state, 0-1)
 * - 6: buildCharge (Accumulator for Super Hex formation)
 * - 7: colorIdx (Palette index)
 *
 * **Runner Buffer Layout (Float32Array):**
 * - 0: x (Current X)
 * - 1: y (Current Y)
 * - 2: tx (Target X)
 * - 3: ty (Target Y)
 * - 4: progress (Animation progress, 0-1)
 * - 5: speed (Movement speed)
 * - 6: currentHexIdx (Index of occupied node)
 * - 7: colorIdx (Palette index)
 *
 * @class Portal.canvas.ServicesCanvas
 * @extends Portal.canvas.Base
 * @singleton
 */
class ServicesCanvas extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static colors = {
        dark : {
            background     : ['rgba(30, 30, 35, 1)', 'rgba(20, 20, 25, 1)'],
            particlePalette: ['#E0E0E0', '#00BFFF', '#3E63DD', '#8BA6FF'], // White, Cyan, Neo Blue, Light Blue
            hexLine        : 'rgba(139, 166, 255, 0.1)',
            hexActive      : 'rgba(0, 191, 255, 0.15)',
            activePalette  : ['#00BFFF', '#536DFE', '#3E63DD', '#00E5FF'], // Cyan, Indigo, Neo Blue, Turquoise
            kernel         : 'rgba(62, 99, 221, 0.08)',
            runner         : '#00BFFF',
            runnerPalette  : ['#00BFFF', '#536DFE', '#3E63DD', '#00E5FF'],
            agentHead      : '#FFFFFF',
            superHex       : 'rgba(62, 99, 221, 0.3)',
            strata         : 'rgba(139, 166, 255, 0.08)'
        },
        light: {
            background     : ['rgba(255, 255, 255, 1)', 'rgba(245, 247, 255, 1)'],
            particlePalette: ['#3E63DD', '#00BFFF', '#536DFE', '#283593'], // Neo Blue, Cyan, Indigo, Dark Blue
            hexLine        : 'rgba(62, 99, 221, 0.25)',
            hexActive      : 'rgba(0, 191, 255, 0.2)',
            activePalette  : ['#00BFFF', '#536DFE', '#3E63DD', '#00E5FF'],
            kernel         : 'rgba(62, 99, 221, 0.08)',
            runner         : '#00BFFF',
            runnerPalette  : ['#00BFFF', '#536DFE', '#3E63DD', '#00E5FF'],
            agentHead      : '#3E63DD',
            superHex       : 'rgba(62, 99, 221, 0.3)',
            strata         : 'rgba(62, 99, 221, 0.05)'
        }
    }

    static config = {
            /**
             * @member {String} className='Portal.canvas.ServicesCanvas'
             * @protected
             */
            className: 'Portal.canvas.ServicesCanvas',
            /**
             * Remote method access for the App Worker.
         * Allows the UI (Controller) to control the simulation state and input.
         * @member {Object} remote
         * @protected
         */
        remote: {
            app: [
                'updateSize'
            ]
        },
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * @member {Number|null} animationId=null
     */
    animationId = null
    /**
     * ID of the canvas element in the DOM.
     * @member {String|null} canvasId=null
     */
    canvasId = null
    /**
     * Current dimensions of the canvas.
     * @member {Object|null} canvasSize=null
     */
    canvasSize = null
    /**
     * The 2D rendering context.
     * @member {OffscreenCanvasRenderingContext2D|null} context=null
     */
    context = null

    /**
     * Buffer for the main Application Lattice (The Graph).
     * @member {Float32Array|null} cellBuffer
     */
    cellBuffer = null
    /**
     * Buffer for Data Runners (High-speed packets).
     * @member {Float32Array|null} runnerBuffer
     */
    runnerBuffer = null
    /**
     * Buffer for the Kernel Layer (Background Parallax).
     * @member {Float32Array|null} kernelBuffer
     */
    kernelBuffer = null
    /**
     * Buffer for Data Strata (Mid-ground Clusters).
     * @member {Float32Array|null} strataBuffer
     */
    strataBuffer = null

    /**
     * Buffer for Construction Particles.
     * Stride: [x, y, z, vx, vy, vz, life, colorIdx]
     * @member {Float32Array|null} particleBuffer
     */
    particleBuffer = null

    /**
     * Reusable object for projection calculations to avoid GC
     * @member {Object} projectionPoint
     * @protected
     */
    projectionPoint = {x: 0, y: 0, scale: 0, visible: false}

    /**
     * Projection matrix cache
     * @member {Object} projectionMatrix
     * @protected
     */
    projectionMatrix = {cx: 0, cy: 0, cosX: 0, sinX: 0, cosY: 0, sinY: 0}

    /**
     * List of active "Super Hexes" (Merged cells).
     * @member {Object[]} superHexes=[]
     */
    superHexes = []
    /**
     * Scaling factor relative to reference viewport.
     * @member {Number} scale=1
     */
    scale = 1
    /**
     * Current camera rotation in radians (Pitch, Yaw).
     * @member {Object} rotation={x: -0.4, y: 0}
     */
    rotation = {x: -0.4, y: 0} // Base tilt (radians) - Floor Perspective

    /**
     * Clears the graph state and stops the render loop.
     * Used when the component is destroyed or the route changes to release memory.
     */
    clearGraph() {
        let me = this;
        super.clearGraph();
        me.cellBuffer   = null;
        me.runnerBuffer = null;
        me.kernelBuffer = null;
        me.strataBuffer = null;
        me.particleBuffer = null;
        me.superHexes   = [];
        me.scale        = 1
    }

    /**
     * Hook to initialize nodes and buffers after context is ready
     * @param {Number} width
     * @param {Number} height
     */
    onGraphMounted(width, height) {
        this.updateSize({width, height})
    }

    /**
     * Draws a single Hexagon projected into 3D space.
     * Uses the reused `projectionPoint` to avoid allocations.
     * @param {CanvasRenderingContext2D} ctx
     * @param {Number} x World X
     * @param {Number} y World Y
     * @param {Number} z World Z
     * @param {Number} size Radius in pixels
     */
    drawHex(ctx, x, y, z, size) {
        let me    = this,
            first = true,
            p;

        ctx.beginPath();

        for (let i = 0; i < 6; i++) {
            const angle_deg = 60 * i + 30;
            const angle_rad = Math.PI / 180 * angle_deg;

            const px = x + size * Math.cos(angle_rad);
            const py = y + size * Math.sin(angle_rad);

            p = me.project(px, py, z);

            if (first) {
                ctx.moveTo(p.x, p.y);
                first = false;
            } else {
                ctx.lineTo(p.x, p.y);
            }
        }
        ctx.closePath();
    }

    /**
     * Draws the Kernel Layer (Background).
     * This layer moves slowly (Parallax) to create depth.
     * @param {CanvasRenderingContext2D} ctx
     * @param {Number} width
     * @param {Number} height
     */
    drawKernel(ctx, width, height) {
        let me = this;
        if (!me.kernelBuffer) {
            return;
        }

        const
            buffer      = me.kernelBuffer,
            count       = buffer.length / 2,
            s           = me.scale,
            size        = KERNEL_HEX_SIZE * s,
            themeColors = me.constructor.colors[me.theme];

        ctx.strokeStyle = themeColors.kernel;
        ctx.lineWidth   = 2 * s;
        ctx.lineJoin    = 'round';

        let panX = Math.sin(me.time * 0.2) * 20 * s,
            panY = Math.cos(me.time * 0.2) * 20 * s;

        ctx.beginPath();
        for (let i = 0; i < count; i++) {
            let x = buffer[i * 2] + panX,
                y = buffer[i * 2 + 1] + panY;
            me.drawHex(ctx, x, y, 400, size);
        }
        ctx.stroke();
    }

    /**
     * Draws the Data Strata (Mid-ground floating clusters).
     * These elements sit between the background and the main lattice.
     * @param {CanvasRenderingContext2D} ctx
     * @param {Number} width
     * @param {Number} height
     */
    drawStrata(ctx, width, height) {
        let me = this;
        if (!me.strataBuffer) {
            return;
        }

        const
            buffer      = me.strataBuffer,
            count       = STRATA_COUNT,
            s           = me.scale,
            themeColors = me.constructor.colors[me.theme];

        ctx.fillStyle = themeColors.strata;

        let panX = Math.sin(me.time * 0.15) * 30 * s,
            panY = Math.cos(me.time * 0.15) * 30 * s;

        for (let i = 0; i < count; i++) {
            let idx  = i * STRATA_STRIDE,
                x    = buffer[idx] + panX,
                y    = buffer[idx + 1] + panY,
                z    = buffer[idx + 2],
                size = buffer[idx + 3] * s;

            me.drawHex(ctx, x, y, z, size);
            ctx.fill();
        }
    }

    /**
     * Draws the main Application Lattice (Foreground).
     * Handles 3 batches:
     * 1. **Idle Hexes:** Faint outlines.
     * 2. **Super Hexes:** Large, merged modules with fill and center glow.
     * 3. **Active Hexes:** Energized nodes with "Holographic Pop" (3D extrusion).
     * @param {CanvasRenderingContext2D} ctx
     * @param {Number} width
     * @param {Number} height
     */
    drawGraph(ctx, width, height) {
        let me = this;

        if (!me.cellBuffer) {
            return;
        }

        const
            buffer      = me.cellBuffer,
            count       = buffer.length / STRIDE,
            themeColors = me.constructor.colors[me.theme],
            s           = me.scale,
            baseSize    = HEX_SIZE * s;

        ctx.lineWidth = 1 * s;
        ctx.lineJoin  = 'round';

        // Batch 1: Idle Hexes
        ctx.beginPath();
        ctx.strokeStyle = themeColors.hexLine;

        for (let i = 0; i < count; i++) {
            let idx    = i * STRIDE,
                x      = buffer[idx + 2],
                y      = buffer[idx + 3],
                scale  = buffer[idx + 4],
                energy = buffer[idx + 5];

            if (energy <= 0.01 && scale > 0.1) {
                let size = baseSize * 0.95 * scale;
                me.drawHex(ctx, x, y, 0, size);
            }
        }
        ctx.stroke();

        // Batch 2: Super Hexes
        ctx.lineWidth = 2 * s;
        for (let sh of me.superHexes) {
            let idx      = sh.centerIdx,
                x        = buffer[idx + 2],
                y        = buffer[idx + 3],
                colorIdx = buffer[idx + 7],
                progress = 0;

            if (sh.state === 0) {
                progress = sh.age / 30;
            } else if (sh.state === 1) {
                progress = 1;
            } else {
                progress = 1 - (sh.age / 30);
            }

            if (progress > 0) {
                let color = themeColors.activePalette[colorIdx];

                ctx.beginPath();
                me.drawHex(ctx, x, y, 0, baseSize * 2.5 * progress);

                ctx.strokeStyle = color;
                ctx.globalAlpha = 0.3 * progress;
                ctx.stroke();

                ctx.fillStyle = themeColors.superHex;
                ctx.fill();

                let p = me.project(x, y, 0);

                ctx.beginPath();
                ctx.arc(p.x, p.y, 4 * s * progress * p.scale, 0, Math.PI * 2);
                ctx.fillStyle   = color;
                ctx.globalAlpha = 0.8 * progress;
                ctx.fill();
            }
        }
        ctx.globalAlpha = 1;
        ctx.lineWidth   = 1 * s;

        // Batch 3: Active / Energized Hexes
        for (let i = 0; i < count; i++) {
            let idx      = i * STRIDE,
                x        = buffer[idx + 2],
                y        = buffer[idx + 3],
                scale    = buffer[idx + 4],
                energy   = buffer[idx + 5],
                colorIdx = buffer[idx + 7];

            if (energy > 0.01 && scale > 0.5) {
                let currentSize = baseSize * (0.95 + (energy * 0.1)),
                    color       = themeColors.activePalette[colorIdx];

                ctx.beginPath();
                me.drawHex(ctx, x, y, 0, currentSize);

                ctx.fillStyle   = themeColors.hexActive;
                ctx.globalAlpha = energy * 0.4;
                ctx.fill();

                ctx.strokeStyle = color;
                ctx.lineWidth   = (1 + energy) * s;
                ctx.globalAlpha = energy * 0.8;
                ctx.stroke();

                // Holographic Pop (Ghost Hex)
                if (energy > 0.3) {
                    ctx.beginPath();
                    let popZ = -50 * energy; // Float up
                    me.drawHex(ctx, x, y, popZ, currentSize);
                    ctx.strokeStyle = color;
                    ctx.globalAlpha = energy * 0.4;
                    ctx.lineWidth   = 1 * s;
                    ctx.stroke();
                }

                ctx.globalAlpha = 1;
                ctx.lineWidth   = 1 * s;
            }
        }
    }

    /**
     * Draws Data Runners (High-speed Packets).
     * Visualized as a gradient line (Trail) leading to a white head.
     * Uses optimized projection re-use.
     * @param {CanvasRenderingContext2D} ctx
     */
    drawRunners(ctx) {
        let me = this;
        if (!me.runnerBuffer) {
            return;
        }

        const
            buffer      = me.runnerBuffer,
            count       = RUNNER_COUNT,
            themeColors = me.constructor.colors[me.theme],
            s           = me.scale,
            pp          = me.projectionPoint; // Shortcut

        ctx.lineCap = 'round';

        for (let i = 0; i < count; i++) {
            let idx      = i * RUNNER_STRIDE,
                x        = buffer[idx],
                y        = buffer[idx + 1],
                tx       = buffer[idx + 2],
                ty       = buffer[idx + 3],
                sp       = buffer[idx + 5],
                colorIdx = buffer[idx + 7],
                state    = buffer[idx + 8],
                scanTime = buffer[idx + 9];

            // Project Head (Always needed)
            me.project(x, y, 0);

            if (!pp.visible) {
                continue;
            }
            let headX = pp.x,
                headY = pp.y,
                headS = pp.scale;

            let color = themeColors.runnerPalette[colorIdx];

            // STATE 0: MOVING (Draw Trail)
            if (state === 0) {
                let dx   = tx - x,
                    dy   = ty - y,
                    dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > 0) {
                    let tailLen = sp * 12 * s;
                    let dirX    = dx / dist,
                        dirY    = dy / dist;

                    let tailX = x - dirX * tailLen,
                        tailY = y - dirY * tailLen;

                    // Project Tail
                    me.project(tailX, tailY, 0);
                    let p1x   = pp.x,
                        p1y   = pp.y;

                    let g = ctx.createLinearGradient(p1x, p1y, headX, headY);
                    g.addColorStop(0, 'rgba(0,0,0,0)');
                    g.addColorStop(0.2, color);
                    g.addColorStop(0.6, color);
                    g.addColorStop(1, themeColors.agentHead);

                    ctx.beginPath();
                    ctx.strokeStyle = g;
                    ctx.lineWidth   = 3 * s * headS;
                    ctx.moveTo(p1x, p1y);
                    ctx.lineTo(headX, headY);
                    ctx.stroke();
                }
            }
            // STATE 1: SCANNING (Draw Pulse)
            else if (state === 1) {
                let radius = (HEX_SIZE * s * 1.5) * scanTime * headS;

                ctx.beginPath();
                ctx.arc(headX, headY, radius, 0, Math.PI * 2);
                ctx.strokeStyle = color;
                ctx.lineWidth   = 2 * s * headS * (1 - scanTime); // Fade out
                ctx.stroke();

                // Scanning Beam (Vertical)
                ctx.beginPath();
                ctx.moveTo(headX, headY);
                ctx.lineTo(headX, headY - (30 * s * headS * Math.sin(scanTime * Math.PI)));
                ctx.strokeStyle = themeColors.agentHead;
                ctx.lineWidth   = 2 * s * headS;
                ctx.stroke();
            }

            // Draw Head (Diamond Shape)
            ctx.beginPath();
            ctx.fillStyle = themeColors.agentHead;
            let hs = 4 * s * headS; // Head Size
            ctx.moveTo(headX, headY - hs);
            ctx.lineTo(headX + hs, headY);
            ctx.lineTo(headX, headY + hs);
            ctx.lineTo(headX - hs, headY);
            ctx.closePath();
            ctx.fill();

            // Glow
            ctx.shadowBlur  = 10 * s;
            ctx.shadowColor = color;
            ctx.shadowBlur  = 0;
        }
    }

    /**
     * Draws construction particles.
     * @param {CanvasRenderingContext2D} ctx
     */
    drawParticles(ctx) {
        let me = this;
        if (!me.particleBuffer) {
            return;
        }

        const
            buffer      = me.particleBuffer,
            count       = PARTICLE_COUNT,
            themeColors = me.constructor.colors[me.theme],
            s           = me.scale,
            pp          = me.projectionPoint;

        for (let i = 0; i < count; i++) {
            let idx  = i * PARTICLE_STRIDE,
                life = buffer[idx + 6]; // life is now at index 6

            if (life > 0) {
                let x    = buffer[idx],
                    y    = buffer[idx + 1],
                    z    = buffer[idx + 2],
                    size = 3 * s * life; // Shrink as it dies

                me.project(x, y, z);

                if (pp.visible) {
                    let scaledSize = size * pp.scale,
                        colorIdx   = buffer[idx + 7]; // colorIdx at index 7

                    ctx.fillStyle   = themeColors.particlePalette[colorIdx];
                    ctx.globalAlpha = life;
                    ctx.fillRect(pp.x - scaledSize / 2, pp.y - scaledSize / 2, scaledSize, scaledSize);
                }
            }
        }
        ctx.globalAlpha = 1;
    }

    /**
     * Allocates the Particle Buffer (Construction Effects).
     */
    initParticles() {
        let me = this;
        if (!me.particleBuffer) {
            me.particleBuffer = new Float32Array(PARTICLE_COUNT * PARTICLE_STRIDE);
        }
    }

    /**
     * Initializes the Kernel Buffer (Background Grid).
     * Creates a large-scale Hex grid that extends beyond the viewport for parallax movement.
     * @param {Number} width
     * @param {Number} height
     */
    initKernel(width, height) {
        let me      = this;
        const
            s       = me.scale,
            size    = KERNEL_HEX_SIZE * s,
            colStep = size * 1.5,
            rowStep = size * Math.sqrt(3),
            cols    = Math.ceil(width / colStep) + 4,
            rows    = Math.ceil(height / rowStep) + 4,
            count   = cols * rows;

        me.kernelBuffer = new Float32Array(count * 2);

        let i      = 0;
        let startX = -(colStep * 2),
            startY = -(rowStep * 2);

        for (let c = 0; c < cols; c++) {
            for (let r = 0; r < rows; r++) {
                let x = startX + c * colStep;
                let y = startY + r * rowStep;
                if (c % 2 === 1) {
                    y += rowStep / 2;
                }
                me.kernelBuffer[i * 2]     = x;
                me.kernelBuffer[i * 2 + 1] = y;
                i++;
            }
        }
    }

    /**
     * Initializes the Main Lattice (Application Layer).
     * Creates a standard Hexagonal Grid covering the screen + margins.
     * @param {Number} width
     * @param {Number} height
     */
    initNodes(width, height) {
        let me = this;

        const
            s       = me.scale,
            size    = HEX_SIZE * s,
            colStep = size * 1.5,
            rowStep = size * Math.sqrt(3),
            cols    = Math.ceil(width / colStep) + 2,
            // Extend rows upwards for perspective (Horizon Buffer)
            rows    = Math.ceil(height / rowStep) + 12,
            count   = cols * rows;

        if (!me.cellBuffer || me.cellBuffer.length !== count * STRIDE) {
            me.cellBuffer = new Float32Array(count * STRIDE);
        }

        const buffer = me.cellBuffer;

        let i = 0;
        // Start 10 rows higher up to fill the distance
        for (let c = -1; c < cols; c++) {
            for (let r = -10; r < rows - 10; r++) {
                let x = c * colStep;
                let y = r * rowStep;
                if (c % 2 === 1) {
                    y += rowStep / 2;
                }

                let idx         = i * STRIDE;
                buffer[idx]     = c;
                buffer[idx + 1] = r;
                buffer[idx + 2] = x;
                buffer[idx + 3] = y;
                buffer[idx + 4] = 1;
                buffer[idx + 5] = 0;
                buffer[idx + 6] = 0;
                buffer[idx + 7] = Math.floor(Math.random() * 4); // colorIdx

                i++;
                if (i >= count) {
                    break;
                }
            }
        }
    }

    /**
     * Initializes Data Runners (Traffic).
     * @param {Number} width
     * @param {Number} height
     */
    initRunners(width, height) {
        let me = this;
        if (!me.runnerBuffer) {
            me.runnerBuffer = new Float32Array(RUNNER_COUNT * RUNNER_STRIDE);
        }

        const
            buffer = me.runnerBuffer;

        for (let i = 0; i < RUNNER_COUNT; i++) {
            me.resetRunner(i, width, height);
            let idx         = i * RUNNER_STRIDE;
            buffer[idx + 4] = Math.random(); // Random start progress
            buffer[idx + 8] = 0; // State: Moving
            buffer[idx + 9] = 0; // ScanTime
        }
    }

    /**
     * Initializes Data Strata (Floating Mid-ground Clusters).
     * Randomly placed 3D coordinates.
     * @param {Number} width
     * @param {Number} height
     */
    initStrata(width, height) {
        let me = this;

        me.strataBuffer = new Float32Array(STRATA_COUNT * STRATA_STRIDE);
        const buffer    = me.strataBuffer;

        for (let i = 0; i < STRATA_COUNT; i++) {
            let idx         = i * STRATA_STRIDE;
            buffer[idx]     = (Math.random() - 0.5) * width * 2;
            buffer[idx + 1] = (Math.random() - 0.5) * height * 3;
            buffer[idx + 2] = 150 + Math.random() * 150; // Z depth 150-300
            buffer[idx + 3] = (HEX_SIZE * 3) + Math.random() * HEX_SIZE * 4; // Size
        }
    }

    /**
     * Finds the nearest hex node to a given screen position.
     * @param {Number} x
     * @param {Number} y
     * @returns {Number} Index of the nearest node or -1
     */
    findNearestNode(x, y) {
        let me      = this,
            buffer  = me.cellBuffer,
            count   = buffer.length / STRIDE,
            minDist = Infinity,
            bestIdx = -1;

        for (let i = 0; i < count; i++) {
            let idx  = i * STRIDE,
                nx   = buffer[idx + 2],
                ny   = buffer[idx + 3],
                dist = (nx - x) ** 2 + (ny - y) ** 2;

            if (dist < minDist) {
                minDist = dist;
                bestIdx = idx;
            }
        }
        return bestIdx;
    }

    /**
     * Resets a runner to a random position.
     * @param {Number} index
     * @param {Number} width
     * @param {Number} height
     */
    resetRunner(index, width, height) {
        let me        = this,
            buffer    = me.runnerBuffer,
            nodes     = me.cellBuffer,
            idx       = index * RUNNER_STRIDE,
            nodeCount = nodes.length / STRIDE;

        let nIdx = Math.floor(Math.random() * nodeCount) * STRIDE;

        buffer[idx]     = nodes[nIdx + 2];
        buffer[idx + 1] = nodes[nIdx + 3];

        buffer[idx + 2] = buffer[idx];
        buffer[idx + 3] = buffer[idx + 1];
        buffer[idx + 4] = 1;
        buffer[idx + 5] = (Math.random() * 4 + 5) * me.scale;
        buffer[idx + 6] = nIdx;
        buffer[idx + 7] = Math.floor(Math.random() * 4); // colorIdx
        buffer[idx + 8] = 0; // State: Moving
        buffer[idx + 9] = 0; // ScanTime
    }

    /**
     * Spawns construction particles.
     *
     * **Visual Metaphors:**
     * - **'implode'**: Particles fly *inward* from a radius to the center. Represents **Assembly**,
     *   **Memory Allocation**, or **Crystallization**. Used when a Super Hex is born.
     * - **'upload'**: Particles fly *upward* (Z-axis) and fade out. Represents **Data Transfer**,
     *   **Cloud Sync**, or **release**. Used when a Super Hex finishes its lifecycle.
     *
     * @param {Number} x World X
     * @param {Number} y World Y
     * @param {Number} count Number of particles to spawn
     * @param {String} type 'implode' or 'upload'
     */
    spawnParticles(x, y, count, type) {
        let me = this;
        if (!me.particleBuffer) {
            return;
        }

        const
            buffer = me.particleBuffer,
            total  = PARTICLE_COUNT,
            s      = me.scale;

        // Find empty slots
        let spawned = 0;
        for (let i = 0; i < total; i++) {
            let idx = i * PARTICLE_STRIDE;

            // If slot is empty (life <= 0)
            if (buffer[idx + 6] <= 0) {
                let angle = Math.random() * Math.PI * 2,
                    speed = (Math.random() * 3 + 2) * s;

                if (type === 'implode') {
                    // Start OUTSIDE, move IN
                    let radius      = 60 * s;
                    buffer[idx]     = x + Math.cos(angle) * radius;
                    buffer[idx + 1] = y + Math.sin(angle) * radius;
                    buffer[idx + 2] = 0; // z
                    buffer[idx + 3] = -Math.cos(angle) * speed; // vx
                    buffer[idx + 4] = -Math.sin(angle) * speed; // vy
                    buffer[idx + 5] = 0; // vz
                } else if (type === 'upload') {
                    // Start CENTER, move UP (Z-axis)
                    buffer[idx]     = x + (Math.random() - 0.5) * 20 * s;
                    buffer[idx + 1] = y + (Math.random() - 0.5) * 20 * s;
                    buffer[idx + 2] = 0; // z
                    buffer[idx + 3] = 0; // vx
                    buffer[idx + 4] = 0; // vy
                    buffer[idx + 5] = -speed * 1.5; // vz (Upwards in 3D space is negative Z in our projection usually, or handle in render)
                    // Let's assume negative Z is 'up/away' or just use Y for 'up'.
                    // Actually, 'Up' in 3D world space (if Y is down) is negative Y.
                    // But here we want a 'Holographic Upload' effect, which implies Z-axis lift.
                    // Let's try Negative Z (towards camera? or away?).
                    // In drawHex, Z is depth. Lower Z is closer?
                    // Let's make them float 'up' in World Y (-Y) and 'out' in Z (-Z).
                    buffer[idx + 4] = -1 * s; // Slow rise Y
                    buffer[idx + 5] = -5 * s; // Fast rise Z (towards camera)
                } else {
                    // Default explode
                     buffer[idx]     = x;
                     buffer[idx + 1] = y;
                     buffer[idx + 2] = 0;
                     buffer[idx + 3] = Math.cos(angle) * speed;
                     buffer[idx + 4] = Math.sin(angle) * speed;
                     buffer[idx + 5] = 0;
                }

                buffer[idx + 6] = 1.0; // Life
                buffer[idx + 7] = Math.floor(Math.random() * 4); // Color Index

                spawned++;
                if (spawned >= count) {
                    break;
                }
            }
        }
    }

    /**
     * Main Render Loop.
     * Updates physics, projects geometry, and draws all layers.
     */
    render() {
        let me = this;

        if (!me.canRender) {
            return
        }

        const
            ctx    = me.context,
            width  = me.canvasSize?.width || 100,
            height = me.canvasSize?.height || 50;

        me.time += 0.01;

        if (!me.cellBuffer) {
            me.initNodes(width, height);
        }
        if (!me.kernelBuffer) {
            me.initKernel(width, height);
        }
        if (!me.strataBuffer) {
            me.initStrata(width, height);
        }
        if (!me.runnerBuffer) {
            me.initRunners(width, height);
        }
        if (!me.particleBuffer) {
            me.initParticles();
        }

        me.updatePhysics(width, height);
        me.updateRotation(width, height);
        me.updateSuperHexes(width, height);
        me.updateRunners(width, height);
        me.updateParticles();
        me.updateProjection(width, height);

        ctx.clearRect(0, 0, width, height);

        if (me.gradients.bgGradient) {
            ctx.fillStyle = me.gradients.bgGradient;
            ctx.fillRect(0, 0, width, height)
        }

        me.drawKernel(ctx, width, height);
        me.drawStrata(ctx, width, height);
        me.drawGraph(ctx, width, height);
        me.drawRunners(ctx);
        me.drawParticles(ctx); // Render particles on top

        if (hasRaf) {
            me.animationId = requestAnimationFrame(me.renderLoop)
        } else {
            me.animationId = setTimeout(me.renderLoop, 1000 / 60)
        }
    }

    /**
     * Updates particle physics (movement, decay).
     */
    updateParticles() {
        let me = this;
        if (!me.particleBuffer) {
            return;
        }

        const buffer = me.particleBuffer,
              count  = PARTICLE_COUNT;

        for (let i = 0; i < count; i++) {
            let idx = i * PARTICLE_STRIDE;
            if (buffer[idx + 6] > 0) { // Check life
                // Move x, y, z by vx, vy, vz
                buffer[idx]     += buffer[idx + 3];
                buffer[idx + 1] += buffer[idx + 4];
                buffer[idx + 2] += buffer[idx + 5];

                // Decay life
                buffer[idx + 6] -= 0.03;
            }
        }
    }

    /**
     * Manages the lifecycle of Super Hexes.
     * Detects highly charged cells, triggers implosions to form Super Hexes,
     * and manages their growth and final explosion.
     * @param {Number} width
     * @param {Number} height
     */
    updateSuperHexes(width, height) {
        let me = this;
        if (!me.cellBuffer) {
            return;
        }

        if (me.superHexes.length < SUPER_HEX_MAX) {
            const buffer = me.cellBuffer,
                  count  = buffer.length / STRIDE;

            for (let i = 0; i < 20; i++) {
                let idx    = Math.floor(Math.random() * count) * STRIDE,
                    charge = buffer[idx + 6];

                if (charge > 3) {
                    me.superHexes.push({
                        centerIdx: idx,
                        age      : 0,
                        state    : 0,
                        neighbors: me.findNeighbors(idx)
                    });

                    // Trigger Implosion!
                    let x = buffer[idx + 2],
                        y = buffer[idx + 3];
                    me.spawnParticles(x, y, 12, 'implode');

                    buffer[idx + 6] = 0;
                    break;
                }
            }
        }

        for (let i = me.superHexes.length - 1; i >= 0; i--) {
            let sh = me.superHexes[i];
            sh.age++;

            if (sh.state === 0 && sh.age > 30) {
                sh.state = 1;
                sh.age   = 0;
            } else if (sh.state === 1 && sh.age > 120) {
                sh.state = 2;
                sh.age   = 0;
            } else if (sh.state === 2 && sh.age > 30) {
                // Done - Trigger Upload
                let idx = sh.centerIdx,
                    x   = me.cellBuffer[idx + 2],
                    y   = me.cellBuffer[idx + 3];

                me.spawnParticles(x, y, 12, 'upload');

                sh.neighbors.forEach(nIdx => {
                    me.cellBuffer[nIdx + 4] = 1;
                });
                me.superHexes.splice(i, 1);
                continue;
            }

            let targetScale = 1;
            if (sh.state === 0) {
                targetScale = 1 - (sh.age / 30);
            } else if (sh.state === 1) {
                targetScale = 0;
            } else {
                targetScale = sh.age / 30;
            }

            sh.neighbors.forEach(nIdx => {
                me.cellBuffer[nIdx + 4] = targetScale;
            });
        }
    }

    /**
     * Finds immediate neighbors for Super Hex formation.
     * @param {Number} centerIdx
     * @returns {Number[]} Array of neighbor indices
     */
    findNeighbors(centerIdx) {
        let me        = this,
            buffer    = me.cellBuffer,
            cx        = buffer[centerIdx + 2],
            cy        = buffer[centerIdx + 3],
            neighbors = [centerIdx],
            count     = buffer.length / STRIDE,
            s         = me.scale,
            radius    = HEX_SIZE * s * 2.1;

        for (let i = 0; i < count; i++) {
            let idx = i * STRIDE;
            if (idx === centerIdx) {
                continue;
            }

            let x    = buffer[idx + 2],
                y    = buffer[idx + 3],
                dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);

            if (dist < radius) {
                neighbors.push(idx);
            }
        }
        return neighbors;
    }

    /**
     * Updates interaction physics for the main lattice.
     * Handles mouse hover energy transfer and decay.
     * @param {Number} width
     * @param {Number} height
     */
    updatePhysics(width, height) {
        let me = this;
        if (!me.cellBuffer) {
            return;
        }

        const
            buffer = me.cellBuffer,
            count  = buffer.length / STRIDE,
            mx     = me.mouse.x,
            my     = me.mouse.y,
            s      = me.scale;

        for (let i = 0; i < count; i++) {
            let idx    = i * STRIDE,
                x      = buffer[idx + 2],
                y      = buffer[idx + 3],
                active = 0;

            if (mx !== -1000) {
                let dx     = x - mx,
                    dy     = y - my,
                    distSq = dx * dx + dy * dy,
                    radius = 250 * s;

                if (distSq < radius * radius) {
                    let dist = Math.sqrt(distSq);
                    active   = (radius - dist) / radius;
                    active   = Math.pow(active, 2);
                }
            }

            let currentEnergy = buffer[idx + 5];
            let targetEnergy  = active * 0.8;

            // Speed up hover reaction (0.1 -> 0.3)
            if (currentEnergy > targetEnergy) {
                buffer[idx + 5] *= 0.9;
            } else {
                buffer[idx + 5] += (targetEnergy - currentEnergy) * 0.3;
            }

            if (buffer[idx + 5] < 0.001) {
                buffer[idx + 5] = 0;
            }

            if (buffer[idx + 6] > 0) {
                buffer[idx + 6] -= 0.05;
                if (buffer[idx + 6] < 0) {
                    buffer[idx + 6] = 0;
                }
            }
        }
    }

    /**
     * Updates Neural Agent logic (The "Intelligence" Layer).
     *
     * Implements a 2-State Machine for Agents:
     *
     * **State 0: Moving**
     * - Agents travel along grid edges to a target node.
     * - Uses "Magnetic Pathfinding" to bias movement towards the mouse cursor.
     * - Upon arrival, there is a **20% chance** to switch to "Scanning".
     *
     * **State 1: Scanning**
     * - The Agent locks onto a node and performs a "Deep Scan" (visualized as a pulse).
     * - **Construction Trigger:** When the scan completes, the Agent injects massive `BuildCharge` (+5)
     *   into the node. This deterministically triggers the formation of a **Super Hex**, creating
     *   a direct cause-and-effect relationship between "Agent Work" and "Structure Creation".
     *
     * @param {Number} width
     * @param {Number} height
     */
    updateRunners(width, height) {
        let me = this;
        if (!me.runnerBuffer) {
            return;
        }

        const
            runners = me.runnerBuffer,
            nodes   = me.cellBuffer,
            count   = RUNNER_COUNT,
            s       = me.scale;

        for (let i = 0; i < count; i++) {
            let idx      = i * RUNNER_STRIDE,
                state    = runners[idx + 8];

            // STATE 0: MOVING
            if (state === 0) {
                let progress = runners[idx + 4],
                    speed    = runners[idx + 5];

                if (progress < 1) {
                    let x  = runners[idx],
                        y  = runners[idx + 1],
                        tx = runners[idx + 2],
                        ty = runners[idx + 3];

                    let dx   = tx - x,
                        dy   = ty - y,
                        dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < speed) {
                        runners[idx]     = tx;
                        runners[idx + 1] = ty;
                        runners[idx + 4] = 1; // Arrived

                        // Decision Point: Scan or Move?
                        // 20% Chance to Scan, but only if on a valid node
                        let nodeIdx = me.findNearestNode(tx, ty);

                        if (nodeIdx !== -1 && Math.random() > 0.8) {
                            runners[idx + 8] = 1; // Switch to Scanning
                            runners[idx + 9] = 0; // Reset Scan Time
                            runners[idx + 6] = nodeIdx; // Lock to node
                        } else {
                            // Just passing through - Standard Energy Boost
                            if (nodeIdx !== -1) {
                                nodes[nodeIdx + 5] = 1.0; // Flash
                                nodes[nodeIdx + 6] += 0.5; // Small contribution
                                nodes[nodeIdx + 7] = runners[idx + 7];
                                runners[idx + 6]   = nodeIdx;
                            }
                        }
                    } else {
                        runners[idx]     += (dx / dist) * speed;
                        runners[idx + 1] += (dy / dist) * speed;
                    }
                } else {
                    // Pick Next Target
                    let currentHexIdx = runners[idx + 6];

                    if (currentHexIdx !== undefined && currentHexIdx !== -1) {
                        // Magnetic Logic: Bias direction towards mouse
                        let bestDir   = -1,
                            bestScore = -Infinity;

                        let weights = [1, 1, 1, 1, 1, 1];

                        if (me.mouse.x !== -1000) {
                            let cx = runners[idx],
                                cy = runners[idx + 1];

                            for (let d = 0; d < 6; d++) {
                                let deg  = 30 + (d * 60),
                                    rad  = deg * Math.PI / 180,
                                    jump = HEX_SIZE * s * Math.sqrt(3),
                                    tx   = cx + Math.cos(rad) * jump,
                                    ty   = cy + Math.sin(rad) * jump;

                                let distSq = (tx - me.mouse.x) ** 2 + (ty - me.mouse.y) ** 2;
                                weights[d] += (100000 / (distSq + 100)) * 5;
                            }
                        }

                        let totalWeight = weights.reduce((a, b) => a + b, 0),
                            random      = Math.random() * totalWeight,
                            sum         = 0,
                            dir         = 0;

                        for (let d = 0; d < 6; d++) {
                            sum += weights[d];
                            if (random <= sum) {
                                dir = d;
                                break;
                            }
                        }

                        let deg  = 30 + (dir * 60),
                            rad  = deg * Math.PI / 180,
                            jump = HEX_SIZE * s * Math.sqrt(3),
                            cx   = runners[idx],
                            cy   = runners[idx + 1],
                            tx   = cx + Math.cos(rad) * jump,
                            ty   = cy + Math.sin(rad) * jump;

                        if (tx < -50 || tx > width + 50 || ty < -500 || ty > height + 50) {
                            me.resetRunner(i, width, height);
                            continue;
                        }

                        runners[idx + 2] = tx;
                        runners[idx + 3] = ty;
                        runners[idx + 4] = 0; // Reset progress
                    } else {
                        me.resetRunner(i, width, height);
                    }
                }
            }
            // STATE 1: SCANNING
            else if (state === 1) {
                // Increment Scan Time
                runners[idx + 9] += 0.02; // Scan speed

                // Visual Effect on Node (Pulse)
                let nodeIdx = runners[idx + 6];
                if (nodeIdx !== -1) {
                     nodes[nodeIdx + 5] = 0.5 + (Math.sin(runners[idx + 9] * 10) * 0.5); // Pulse Energy
                }

                // Scan Complete?
                if (runners[idx + 9] >= 1) {
                    runners[idx + 8] = 0; // Resume Moving

                    // THE PAYOFF: Massive BuildCharge injection
                    if (nodeIdx !== -1) {
                        nodes[nodeIdx + 6] += 5; // Instant Super Hex Trigger (>3)
                        nodes[nodeIdx + 5] = 1.0; // Max Energy
                        nodes[nodeIdx + 7] = runners[idx + 7]; // Color
                    }
                }
            }
        }
    }

    /**
     * Updates camera rotation based on mouse position.
     * Creates a "Floor Perspective" tilt effect.
     * @param {Number} width
     * @param {Number} height
     */
    updateRotation(width, height) {
        let me = this,
            mx = me.mouse.x,
            my = me.mouse.y,
            tx = -0.4, // Base tilt X (pitch)
            ty = 0;   // Base yaw

        if (mx !== -1000) {
            // Map mouse X to Yaw (+/- 0.2 rad)
            ty = ((mx / width) - 0.5) * 0.4;
            // Map mouse Y to Pitch (-0.6 to -0.2 rad)
            tx = -0.4 + ((my / height) - 0.5) * 0.4;
        }

        // Smooth interpolate
        me.rotation.x += (tx - me.rotation.x) * 0.05;
        me.rotation.y += (ty - me.rotation.y) * 0.05;
    }

    /**
     * Updates the projection matrix based on current rotation and size.
     * @param {Number} width
     * @param {Number} height
     */
    updateProjection(width, height) {
        let me = this,
            pm = me.projectionMatrix;

        pm.cx   = width / 2;
        pm.cy   = height / 2;
        pm.cosX = Math.cos(me.rotation.x);
        pm.sinX = Math.sin(me.rotation.x);
        pm.cosY = Math.cos(me.rotation.y);
        pm.sinY = Math.sin(me.rotation.y);
    }

    /**
     * Projects a 3D point to 2D screen space using the cached matrix.
     * writes result to this.projectionPoint to avoid allocation.
     * @param {Number} x
     * @param {Number} y
     * @param {Number} z
     * @returns {Object} this.projectionPoint
     */
    project(x, y, z) {
        let me  = this,
            pm  = me.projectionMatrix,
            pp  = me.projectionPoint,
            fov = 1000,
            dx  = x - pm.cx,
            dy  = y - pm.cy,
            dz  = z;

        // Rotate Y
        let x1 = dx * pm.cosY - dz * pm.sinY;
        let z1 = dz * pm.cosY + dx * pm.sinY;

        // Rotate X
        let y2 = dy * pm.cosX - z1 * pm.sinX;
        let z2 = z1 * pm.cosX + dy * pm.sinX;

        // Project
        let scale = fov / (fov + z2);

        pp.x       = x1 * scale + pm.cx;
        pp.y       = y2 * scale + pm.cy;
        pp.scale   = scale;
        pp.visible = z2 > -fov; // Clip if behind camera

        return pp;
    }

    /**
     * Creates and caches gradients.
     * @param {Number} width
     * @param {Number} height
     */
    updateResources(width, height) {
        let me  = this,
            ctx = me.context;

        if (!ctx) {
            return;
        }

        const
            themeColors = me.constructor.colors[me.theme],
            gradient    = ctx.createLinearGradient(0, 0, width, height);

        gradient.addColorStop(0, themeColors.background[0]);
        gradient.addColorStop(1, themeColors.background[1]);

        me.gradients.bgGradient = gradient
    }

    /**
     * Handles canvas resize.
     * Re-calculates scale and re-initializes buffers.
     * @param {Object} size
     * @param {Number} size.height
     * @param {Number} size.width
     */
    updateSize(size) {
        let me        = this;
        me.canvasSize = size;
        me.scale      = Math.sqrt((size.width * size.height) / 2073600);

        if (me.context) {
            me.context.canvas.width  = size.width;
            me.context.canvas.height = size.height;
            me.cellBuffer            = null;
            me.runnerBuffer          = null;
            me.kernelBuffer          = null;
            me.strataBuffer          = null;
            me.debrisBuffer          = null;
            me.initNodes(size.width, size.height);
            me.updateResources(size.width, size.height)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(ServicesCanvas));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2NhbnZhcy92ZW5kb3JzLWFwcHNfcG9ydGFsX2NhbnZhc19TZXJ2aWNlc0NhbnZhc19tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQWlEOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwREFBTztBQUMxQjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0NBQXdDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVEsT0FBTztBQUMvQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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RUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsOEJBQThCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9wb3J0YWwvY2FudmFzL0Jhc2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL3BvcnRhbC9jYW52YXMvU2VydmljZXNDYW52YXMubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBOZW9CYXNlIGZyb20gJy4uLy4uLy4uL3NyYy9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAc3VtbWFyeSBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBQb3J0YWwgQ2FudmFzIFJlbmRlcmVycy5cbiAqXG4gKiBUaGlzIGNsYXNzIHNlcnZlcyBhcyB0aGUgZm91bmRhdGlvbiBmb3IgdGhlIHNwZWNpYWxpemVkIGNhbnZhcyB2aXN1YWxpemF0aW9ucyAoSGVhZGVyLCBIb21lLCBTZXJ2aWNlcywgVGlja2V0KVxuICogdGhhdCBydW4gd2l0aGluIHRoZSAqKk5lby5tanMgQ2FudmFzIFNoYXJlZFdvcmtlcioqLlxuICpcbiAqIEl0IGNyZWF0ZXMgaGVscGVyIHNpbmdsZXRvbnMgdGhhdCBtYW5hZ2UgdGhlaXIgb3duIGBPZmZzY3JlZW5DYW52YXNgIGluc3RhbmNlcywgcHJvdmlkaW5nIGEgc3RhbmRhcmRpemVkXG4gKiBhcmNoaXRlY3R1cmUgZm9yOlxuICogLSAqKkxpZmVjeWNsZSBNYW5hZ2VtZW50OioqIEluaXRpYWxpemF0aW9uIChgaW5pdEdyYXBoYCksIGRlc3RydWN0aW9uIChgY2xlYXJHcmFwaGApLCBhbmQgcmVzb3VyY2UgY2xlYW51cC5cbiAqIC0gKipSZW5kZXIgTG9vcCBDb250cm9sOioqIFVuaWZpZWQgYHJlbmRlcmAgbG9vcCB3aXRoIHBhdXNlL3Jlc3VtZSBjYXBhYmlsaXRpZXMgYW5kIGZyYW1lIHNjaGVkdWxpbmcuXG4gKiAtICoqQ29udGV4dCBNYW5hZ2VtZW50OioqIFJvYnVzdCBoYW5kbGluZyBvZiBgT2Zmc2NyZWVuQ2FudmFzYCB0cmFuc2ZlciBhbmQgY29udGV4dCBhY3F1aXNpdGlvbiB2aWEgYHdhaXRGb3JDYW52YXNgLlxuICogLSAqKlNoYXJlZCBTdGF0ZToqKiBDb21tb24gc3RhdGUgbWFuYWdlbWVudCBmb3IgbW91c2UgaW50ZXJhY3Rpb24sIHRpbWUsIGFuZCB0aGVtaW5nLlxuICpcbiAqIFRoZXNlIHJlbmRlcmVycyBvcGVyYXRlIG9mZiB0aGUgbWFpbiB0aHJlYWQgdG8gZW5zdXJlIGhpZ2gtcGVyZm9ybWFuY2UsIDYwZnBzIGFuaW1hdGlvbnMgd2l0aG91dFxuICogYmxvY2tpbmcgdGhlIFVJLlxuICpcbiAqIEBjbGFzcyBQb3J0YWwuY2FudmFzLkJhc2VcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgQmFzZSBleHRlbmRzIE5lb0Jhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nUG9ydGFsLmNhbnZhcy5CYXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdQb3J0YWwuY2FudmFzLkJhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3RlIG1ldGhvZCBhY2Nlc3NcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSByZW1vdGVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3RlOiB7XG4gICAgICAgICAgICBhcHA6IFtcbiAgICAgICAgICAgICAgICAnY2xlYXJHcmFwaCcsXG4gICAgICAgICAgICAgICAgJ2luaXRHcmFwaCcsXG4gICAgICAgICAgICAgICAgJ3BhdXNlJyxcbiAgICAgICAgICAgICAgICAncmVzdW1lJyxcbiAgICAgICAgICAgICAgICAnc2V0VGhlbWUnLFxuICAgICAgICAgICAgICAgICd1cGRhdGVNb3VzZVN0YXRlJyxcbiAgICAgICAgICAgICAgICAndXBkYXRlU2l6ZSdcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhY3RpdmUgY29sb3IgdGhlbWUgKCdsaWdodCcgb3IgJ2RhcmsnKS5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB0aGVtZV89J2xpZ2h0J1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHRoZW1lXzogJ2xpZ2h0J1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBhbmltYXRpb25JZD1udWxsXG4gICAgICovXG4gICAgYW5pbWF0aW9uSWQgPSBudWxsXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGNhbnZhc0lkPW51bGxcbiAgICAgKi9cbiAgICBjYW52YXNJZCA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gY2FudmFzU2l6ZT1udWxsXG4gICAgICovXG4gICAgY2FudmFzU2l6ZSA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPZmZzY3JlZW5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkR8bnVsbH0gY29udGV4dD1udWxsXG4gICAgICovXG4gICAgY29udGV4dCA9IG51bGxcbiAgICAvKipcbiAgICAgKiBDYWNoZSBmb3IgcmV1c2FibGUgZ3JhZGllbnRzIHRvIHByZXZlbnQgR0MuXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBncmFkaWVudHM9e31cbiAgICAgKi9cbiAgICBncmFkaWVudHMgPSB7fVxuICAgIC8qKlxuICAgICAqIEZsYWcgdG8gcGF1c2UgdGhlIHJlbmRlciBsb29wLlxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzUGF1c2VkPWZhbHNlXG4gICAgICovXG4gICAgaXNQYXVzZWQgPSBmYWxzZVxuICAgIC8qKlxuICAgICAqIFRyYWNrZWQgbW91c2UgcG9zaXRpb24gZm9yIGludGVyYWN0aXZlIHBoeXNpY3MuXG4gICAgICogSW5pdGlhbGl6ZSBvZmYtc2NyZWVuIHRvIHByZXZlbnQgc3RhcnR1cCBqaXR0ZXJzLlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gbW91c2U9e3g6IC0xMDAwLCB5OiAtMTAwMH1cbiAgICAgKi9cbiAgICBtb3VzZSA9IHt4OiAtMTAwMCwgeTogLTEwMDB9XG4gICAgLyoqXG4gICAgICogR2xvYmFsIHNpbXVsYXRpb24gdGltZS5cbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHRpbWU9MFxuICAgICAqL1xuICAgIHRpbWUgPSAwXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gcmVuZGVyTG9vcD10aGlzLnJlbmRlci5iaW5kKHRoaXMpXG4gICAgICovXG4gICAgcmVuZGVyTG9vcCA9IHRoaXMucmVuZGVyLmJpbmQodGhpcylcblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgYHRoZW1lYCBjb25maWcgaXMgY2hhbmdlZC5cbiAgICAgKiBVcGRhdGVzIHRoZSByZXNvdXJjZSBjYWNoZSAoZ3JhZGllbnRzLCBjb2xvcnMpIHRvIHJlZmxlY3QgdGhlIG5ldyB0aGVtZSBpbW1lZGlhdGVseS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhZnRlclNldFRoZW1lKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgJiYgdGhpcy5jYW52YXNTaXplKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVJlc291cmNlcz8uKHRoaXMuY2FudmFzU2l6ZS53aWR0aCwgdGhpcy5jYW52YXNTaXplLmhlaWdodClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgY2FudmFzIGlzIHJlYWR5IHRvIHJlbmRlci5cbiAgICAgKiBSZXR1cm5zIHRydWUgb25seSBpZiB0aGUgY29udGV4dCBleGlzdHMgYW5kIHRoZSBzaW11bGF0aW9uIGlzIG5vdCBwYXVzZWQuXG4gICAgICogU3ViY2xhc3NlcyBzaG91bGQgY2FsbCB0aGlzIGF0IHRoZSBzdGFydCBvZiB0aGVpciBgcmVuZGVyYCBsb29wLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGdldCBjYW5SZW5kZXIoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAhIShtZS5jb250ZXh0ICYmICFtZS5pc1BhdXNlZClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGdyYXBoIHN0YXRlIGFuZCBzdG9wcyB0aGUgcmVuZGVyIGxvb3AuXG4gICAgICogVXNlIHRoaXMgdG8gY2xlYW51cCByZXNvdXJjZXMgd2hlbiB0aGUgY29tcG9uZW50IGlzIGRlc3Ryb3llZCBvciB1bm1vdW50ZWQuXG4gICAgICovXG4gICAgY2xlYXJHcmFwaCgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcbiAgICAgICAgbWUuY29udGV4dCAgICAgPSBudWxsO1xuICAgICAgICBtZS5jYW52YXNJZCAgICA9IG51bGw7XG4gICAgICAgIG1lLmNhbnZhc1NpemUgID0gbnVsbDtcbiAgICAgICAgbWUuYW5pbWF0aW9uSWQgPSBudWxsO1xuICAgICAgICBtZS5pc1BhdXNlZCAgICA9IGZhbHNlO1xuICAgICAgICBtZS5ncmFkaWVudHMgICA9IHt9O1xuICAgICAgICBtZS5tb3VzZSAgICAgICA9IHt4OiAtMTAwMCwgeTogLTEwMDB9O1xuICAgICAgICBtZS50aW1lICAgICAgICA9IDBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgY2FudmFzIGNvbnRleHQuXG4gICAgICogU3RhcnRzIHRoZSBwb2xsaW5nIG1lY2hhbmlzbSB0byB3YWl0IGZvciB0aGUgT2Zmc2NyZWVuQ2FudmFzIHRyYW5zZmVyIGZyb20gdGhlIE1haW4gVGhyZWFkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdHMuY2FudmFzSWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy53aW5kb3dJZFxuICAgICAqL1xuICAgIGluaXRHcmFwaCh7Y2FudmFzSWQsIHdpbmRvd0lkfSkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGhhc0NoYW5nZSA9IG1lLmNhbnZhc0lkICE9PSBjYW52YXNJZDtcblxuICAgICAgICBtZS5jYW52YXNJZCA9IGNhbnZhc0lkO1xuXG4gICAgICAgIG1lLndhaXRGb3JDYW52YXMoY2FudmFzSWQsIHdpbmRvd0lkLCBoYXNDaGFuZ2UpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSG9vayBmb3Igc3ViY2xhc3NlcyB0byBoYW5kbGUgbW91c2UgY2xpY2tzLlxuICAgICAqIENhbGxlZCBieSBgdXBkYXRlTW91c2VTdGF0ZWAgd2hlbiBhIGNsaWNrIGV2ZW50IGlzIHJlY2VpdmVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Nb3VzZUNsaWNrKGRhdGEpIHt9XG5cbiAgICAvKipcbiAgICAgKiBQYXVzZXMgdGhlIHNpbXVsYXRpb24uXG4gICAgICogVGhlIHJlbmRlciBsb29wIHdpbGwgZXhpdCBlYXJseSB3aGlsZSBgaXNQYXVzZWRgIGlzIHRydWUuXG4gICAgICovXG4gICAgcGF1c2UoKSB7XG4gICAgICAgIHRoaXMuaXNQYXVzZWQgPSB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWJzdHJhY3QgcmVuZGVyIG1ldGhvZC5cbiAgICAgKiBTdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvIGRyYXcgdGhlIGZyYW1lLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHt9XG5cbiAgICAvKipcbiAgICAgKiBSZXN1bWVzIHRoZSBzaW11bGF0aW9uLlxuICAgICAqIElmIHRoZSBzaW11bGF0aW9uIHdhcyBwYXVzZWQsIHRoaXMgcmVzdGFydHMgdGhlIHJlbmRlciBsb29wLlxuICAgICAqL1xuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuaXNQYXVzZWQpIHtcbiAgICAgICAgICAgIG1lLmlzUGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICBtZS5yZW5kZXJMb29wKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4cG9zZWQgbWV0aG9kIGZvciBSZW1vdGUgQWNjZXNzIHRvIHRyaWdnZXIgdGhlIHJlYWN0aXZlIGNvbmZpZyBzZXR0ZXIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICovXG4gICAgc2V0VGhlbWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy50aGVtZSA9IHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgbG9jYWwgbW91c2Ugc3RhdGUgZnJvbSBtYWluIHRocmVhZCBldmVudHMuXG4gICAgICogRGVsZWdhdGVzIGNsaWNrIGV2ZW50cyB0byBgb25Nb3VzZUNsaWNrYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2RhdGEuY2xpY2tdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZGF0YS5sZWF2ZV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2RhdGEueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2RhdGEueV1cbiAgICAgKi9cbiAgICB1cGRhdGVNb3VzZVN0YXRlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoZGF0YS5sZWF2ZSkge1xuICAgICAgICAgICAgbWUubW91c2UueCA9IC0xMDAwO1xuICAgICAgICAgICAgbWUubW91c2UueSA9IC0xMDAwXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZGF0YS54ICE9PSB1bmRlZmluZWQpIG1lLm1vdXNlLnggPSBkYXRhLng7XG4gICAgICAgICAgICBpZiAoZGF0YS55ICE9PSB1bmRlZmluZWQpIG1lLm1vdXNlLnkgPSBkYXRhLnk7XG5cbiAgICAgICAgICAgIGlmIChkYXRhLmNsaWNrKSB7XG4gICAgICAgICAgICAgICAgbWUub25Nb3VzZUNsaWNrKGRhdGEpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBjYW52YXMgc2l6ZSBhbmQgcmVzaXplcyB0aGUgaW50ZXJuYWwgY29udGV4dC5cbiAgICAgKiBUcmlnZ2VycyBgdXBkYXRlUmVzb3VyY2VzYCBob29rIHRvIGFsbG93IHN1YmNsYXNzZXMgdG8gcmVnZW5lcmF0ZSBidWZmZXJzL2dyYWRpZW50cy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2l6ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzaXplLmhlaWdodFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzaXplLndpZHRoXG4gICAgICovXG4gICAgdXBkYXRlU2l6ZShzaXplKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuY2FudmFzU2l6ZSA9IHNpemU7XG5cbiAgICAgICAgaWYgKG1lLmNvbnRleHQpIHtcbiAgICAgICAgICAgIG1lLmNvbnRleHQuY2FudmFzLndpZHRoICA9IHNpemUud2lkdGg7XG4gICAgICAgICAgICBtZS5jb250ZXh0LmNhbnZhcy5oZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgICAgICAgICAgIC8vIENhbGxzIHRoZSBob29rIHRvIHJlLWdlbmVyYXRlIHJlc291cmNlcyBpZiBpbXBsZW1lbnRlZFxuICAgICAgICAgICAgbWUudXBkYXRlUmVzb3VyY2VzPy4oc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQb2xscyBmb3IgdGhlIE9mZnNjcmVlbkNhbnZhcyB1bnRpbCBpdCBpcyBhdmFpbGFibGUgaW4gdGhlIFdvcmtlcidzIGBjYW52YXNXaW5kb3dNYXBgLlxuICAgICAqIE9uY2UgZm91bmQsIGl0IGluaXRpYWxpemVzIHRoZSBjb250ZXh0IGFuZCBzdGFydHMgdGhlIHJlbmRlciBsb29wLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjYW52YXNJZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB3aW5kb3dJZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaGFzQ2hhbmdlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHdhaXRGb3JDYW52YXMoY2FudmFzSWQsIHdpbmRvd0lkLCBoYXNDaGFuZ2UpIHtcbiAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjYW52YXMgPSBOZW8uY3VycmVudFdvcmtlci5jYW52YXNXaW5kb3dNYXBbY2FudmFzSWRdPy5bd2luZG93SWRdO1xuXG4gICAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgICAgIG1lLmNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAgICAgLy8gU3RhbmRhcmRpemUgc2l6ZSB1cGRhdGVcbiAgICAgICAgICAgIG1lLnVwZGF0ZVNpemUoe3dpZHRoOiBjYW52YXMud2lkdGgsIGhlaWdodDogY2FudmFzLmhlaWdodH0pO1xuXG4gICAgICAgICAgICAvLyBPcHRpb25hbCBob29rIGZvciBzdWJjbGFzc2VzXG4gICAgICAgICAgICBtZS5vbkdyYXBoTW91bnRlZD8uKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgICAgICAgICAgIGlmIChoYXNDaGFuZ2UgJiYgIW1lLmFuaW1hdGlvbklkKSB7XG4gICAgICAgICAgICAgICAgbWUucmVuZGVyTG9vcCgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KG1lLndhaXRGb3JDYW52YXMuYmluZChtZSwgY2FudmFzSWQsIHdpbmRvd0lkLCBoYXNDaGFuZ2UpLCA1MClcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQmFzZSk7XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuL0Jhc2UubWpzJztcblxuY29uc3RcbiAgICBoYXNSYWYgICAgICAgICAgPSB0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nLFxuICAgIEhFWF9TSVpFICAgICAgICA9IDMwLFxuICAgIFNUUklERSAgICAgICAgICA9IDgsICAvLyBxLCByLCB4LCB5LCBzY2FsZSwgZW5lcmd5LCBidWlsZENoYXJnZSwgY29sb3JJZHhcbiAgICBSVU5ORVJfQ09VTlQgICAgPSAzMCxcbiAgICAvKipcbiAgICAgKiBBZ2VudCBCdWZmZXIgTGF5b3V0IChGbG9hdDMyQXJyYXkpOlxuICAgICAqIC0gMDogeCAoQ3VycmVudCBYKVxuICAgICAqIC0gMTogeSAoQ3VycmVudCBZKVxuICAgICAqIC0gMjogdHggKFRhcmdldCBYKVxuICAgICAqIC0gMzogdHkgKFRhcmdldCBZKVxuICAgICAqIC0gNDogcHJvZ3Jlc3MgKEFuaW1hdGlvbiBwcm9ncmVzcywgMC0xKVxuICAgICAqIC0gNTogc3BlZWQgKE1vdmVtZW50IHNwZWVkKVxuICAgICAqIC0gNjogY3VycmVudEhleElkeCAoSW5kZXggb2Ygb2NjdXBpZWQgbm9kZSlcbiAgICAgKiAtIDc6IGNvbG9ySWR4IChQYWxldHRlIGluZGV4KVxuICAgICAqIC0gODogc3RhdGUgKDAgPSBNb3ZpbmcsIDEgPSBTY2FubmluZylcbiAgICAgKiAtIDk6IHNjYW5UaW1lICgwLTEgcHJvZ3Jlc3Mgb2YgdGhlIHNjYW4gYWN0aW9uKVxuICAgICAqL1xuICAgIFJVTk5FUl9TVFJJREUgICA9IDEwLFxuICAgIFNVUEVSX0hFWF9NQVggICA9IDUsXG4gICAgS0VSTkVMX0hFWF9TSVpFID0gMTIwLFxuICAgIFBBUlRJQ0xFX0NPVU5UICA9IDIwMCxcbiAgICBQQVJUSUNMRV9TVFJJREUgPSA4LCAvLyB4LCB5LCB6LCB2eCwgdnksIHZ6LCBsaWZlLCBjb2xvcklkeFxuICAgIFNUUkFUQV9DT1VOVCAgICA9IDE1LFxuICAgIFNUUkFUQV9TVFJJREUgICA9IDQ7IC8vIHgsIHksIHosIHNpemVcblxuLyoqXG4gKiBAc3VtbWFyeSBTaGFyZWRXb3JrZXIgcmVuZGVyZXIgZm9yIHRoZSBQb3J0YWwgU2VydmljZXMgXCJOZXVyYWwgRmFicmljXCIgYmFja2dyb3VuZC5cbiAqXG4gKiBJbXBsZW1lbnRzIGEgKipIZXhhZ29uYWwgRmFicmljKiogcmVwcmVzZW50aW5nIHRoZSBlbmdpbmVlcmVkLCBzdHJ1Y3R1cmVkIG5hdHVyZSBvZiB0aGUgTmVvLm1qcyBydW50aW1lLlxuICogVGhlIGdyaWQgYWN0cyBhcyBhIGxpdmluZyBcIk1vdGhlcmJvYXJkXCIgb3IgXCJWRE9NIFJlZ2lzdHJ5XCIgd2hlcmUgY2VsbHMgKENvbXBvbmVudHMpIGNhbiBiZSBpbnNwZWN0ZWRcbiAqIGFuZCBtdXRhdGVkLlxuICpcbiAqICoqVmlzdWFsIEFyY2hpdGVjdHVyZToqKlxuICogMS4gKipLZXJuZWwgTGF5ZXIgKFBhcmFsbGF4KToqKiBBIGRlZXAsIHNsb3ctbW92aW5nIGJhY2tncm91bmQgZ3JpZCByZXByZXNlbnRpbmcgdGhlIGZyYW1ld29yayBjb3JlLlxuICogMi4gKipEYXRhIFN0cmF0YSAoTWlkLUdyb3VuZCk6KiogRmxvYXRpbmcgY2x1c3RlcnMgYnJpZGdpbmcgdGhlIGRlcHRoIGdhcC5cbiAqIDMuICoqQXBwbGljYXRpb24gTGF5ZXIgKEZhYnJpYyk6KiogVGhlIG1haW4gZWZmaWNpZW50IHN0cnVjdHVyZSAoVGhlIEFwcCBFbmdpbmUpLlxuICogNC4gKipOZXVyYWwgQWdlbnRzOioqIEhpZ2gtc3BlZWQgcGFja2V0cyB2aXN1YWxpemluZyB0aHJvdWdocHV0IGFuZCBpbnRlbGxpZ2VudCBtYWludGVuYW5jZS5cbiAqIDUuICoqUnVudGltZSBQZXJtdXRhdGlvbjoqKiBEeW5hbWljIGZ1c2lvbiBvZiBjZWxscyBpbnRvIFwiU3VwZXIgTW9kdWxlc1wiIChjb25zdHJ1Y3Rpb24vdXBsb2FkIGVmZmVjdHMpLlxuICogNi4gKipDb25zdHJ1Y3Rpb24gUGFydGljbGVzOioqIFBhcnRpY2xlIGVmZmVjdHMgdmlzdWFsaXppbmcgbWVtb3J5IGFsbG9jYXRpb24gYW5kIG9iamVjdCBhc3NlbWJseS5cbiAqXG4gKiAqKlBlcmZvcm1hbmNlIEFyY2hpdGVjdHVyZSAoWmVyby1BbGxvY2F0aW9uKToqKlxuICogVG8gZW5zdXJlIDYwZnBzIHBlcmZvcm1hbmNlIG9uIGhpZ2gtcmVzb2x1dGlvbiBkaXNwbGF5cywgdGhpcyBjbGFzcyBlbXBsb3lzIGEgc3RyaWN0ICoqWmVyby1BbGxvY2F0aW9uKiogc3RyYXRlZ3k6XG4gKiAxLiAgKipUeXBlZEFycmF5IEJ1ZmZlcnM6KiogQWxsIGVudGl0eSBkYXRhIGlzIHN0b3JlZCBpbiBwcmUtYWxsb2NhdGVkIGBGbG9hdDMyQXJyYXlgIGJ1ZmZlcnMuXG4gKiAyLiAgKipQZXJzaXN0ZW50IE9iamVjdHM6KiogUmV1c2FibGUgb2JqZWN0cyAobGlrZSBgcHJvamVjdGlvblBvaW50YCwgYHByb2plY3Rpb25NYXRyaXhgKSBhcmUgdXNlZFxuICogICAgIGluc3RlYWQgb2YgY3JlYXRpbmcgbmV3IG9iamVjdHMgcGVyIGZyYW1lLlxuICogMy4gICoqSW5saW5lZCBNYXRoOioqIFByb2plY3Rpb24gYW5kIHZlY3RvciBjYWxjdWxhdGlvbnMgYXJlIHBlcmZvcm1lZCBpbi1wbGFjZS5cbiAqXG4gKiAqKk5vZGUgQnVmZmVyIExheW91dCAoRmxvYXQzMkFycmF5KToqKlxuICogLSAwOiBxIChBeGlhbCBDb29yZCBRKVxuICogLSAxOiByIChBeGlhbCBDb29yZCBSKVxuICogLSAyOiB4IChTY3JlZW4gWClcbiAqIC0gMzogeSAoU2NyZWVuIFkpXG4gKiAtIDQ6IHNjYWxlIChWaXN1YWwgc2NhbGUsIDAtMSlcbiAqIC0gNTogZW5lcmd5IChJbnRlcmFjdGlvbiBzdGF0ZSwgMC0xKVxuICogLSA2OiBidWlsZENoYXJnZSAoQWNjdW11bGF0b3IgZm9yIFN1cGVyIEhleCBmb3JtYXRpb24pXG4gKiAtIDc6IGNvbG9ySWR4IChQYWxldHRlIGluZGV4KVxuICpcbiAqICoqUnVubmVyIEJ1ZmZlciBMYXlvdXQgKEZsb2F0MzJBcnJheSk6KipcbiAqIC0gMDogeCAoQ3VycmVudCBYKVxuICogLSAxOiB5IChDdXJyZW50IFkpXG4gKiAtIDI6IHR4IChUYXJnZXQgWClcbiAqIC0gMzogdHkgKFRhcmdldCBZKVxuICogLSA0OiBwcm9ncmVzcyAoQW5pbWF0aW9uIHByb2dyZXNzLCAwLTEpXG4gKiAtIDU6IHNwZWVkIChNb3ZlbWVudCBzcGVlZClcbiAqIC0gNjogY3VycmVudEhleElkeCAoSW5kZXggb2Ygb2NjdXBpZWQgbm9kZSlcbiAqIC0gNzogY29sb3JJZHggKFBhbGV0dGUgaW5kZXgpXG4gKlxuICogQGNsYXNzIFBvcnRhbC5jYW52YXMuU2VydmljZXNDYW52YXNcbiAqIEBleHRlbmRzIFBvcnRhbC5jYW52YXMuQmFzZVxuICogQHNpbmdsZXRvblxuICovXG5jbGFzcyBTZXJ2aWNlc0NhbnZhcyBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb2xvcnMgPSB7XG4gICAgICAgIGRhcmsgOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kICAgICA6IFsncmdiYSgzMCwgMzAsIDM1LCAxKScsICdyZ2JhKDIwLCAyMCwgMjUsIDEpJ10sXG4gICAgICAgICAgICBwYXJ0aWNsZVBhbGV0dGU6IFsnI0UwRTBFMCcsICcjMDBCRkZGJywgJyMzRTYzREQnLCAnIzhCQTZGRiddLCAvLyBXaGl0ZSwgQ3lhbiwgTmVvIEJsdWUsIExpZ2h0IEJsdWVcbiAgICAgICAgICAgIGhleExpbmUgICAgICAgIDogJ3JnYmEoMTM5LCAxNjYsIDI1NSwgMC4xKScsXG4gICAgICAgICAgICBoZXhBY3RpdmUgICAgICA6ICdyZ2JhKDAsIDE5MSwgMjU1LCAwLjE1KScsXG4gICAgICAgICAgICBhY3RpdmVQYWxldHRlICA6IFsnIzAwQkZGRicsICcjNTM2REZFJywgJyMzRTYzREQnLCAnIzAwRTVGRiddLCAvLyBDeWFuLCBJbmRpZ28sIE5lbyBCbHVlLCBUdXJxdW9pc2VcbiAgICAgICAgICAgIGtlcm5lbCAgICAgICAgIDogJ3JnYmEoNjIsIDk5LCAyMjEsIDAuMDgpJyxcbiAgICAgICAgICAgIHJ1bm5lciAgICAgICAgIDogJyMwMEJGRkYnLFxuICAgICAgICAgICAgcnVubmVyUGFsZXR0ZSAgOiBbJyMwMEJGRkYnLCAnIzUzNkRGRScsICcjM0U2M0REJywgJyMwMEU1RkYnXSxcbiAgICAgICAgICAgIGFnZW50SGVhZCAgICAgIDogJyNGRkZGRkYnLFxuICAgICAgICAgICAgc3VwZXJIZXggICAgICAgOiAncmdiYSg2MiwgOTksIDIyMSwgMC4zKScsXG4gICAgICAgICAgICBzdHJhdGEgICAgICAgICA6ICdyZ2JhKDEzOSwgMTY2LCAyNTUsIDAuMDgpJ1xuICAgICAgICB9LFxuICAgICAgICBsaWdodDoge1xuICAgICAgICAgICAgYmFja2dyb3VuZCAgICAgOiBbJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMSknLCAncmdiYSgyNDUsIDI0NywgMjU1LCAxKSddLFxuICAgICAgICAgICAgcGFydGljbGVQYWxldHRlOiBbJyMzRTYzREQnLCAnIzAwQkZGRicsICcjNTM2REZFJywgJyMyODM1OTMnXSwgLy8gTmVvIEJsdWUsIEN5YW4sIEluZGlnbywgRGFyayBCbHVlXG4gICAgICAgICAgICBoZXhMaW5lICAgICAgICA6ICdyZ2JhKDYyLCA5OSwgMjIxLCAwLjI1KScsXG4gICAgICAgICAgICBoZXhBY3RpdmUgICAgICA6ICdyZ2JhKDAsIDE5MSwgMjU1LCAwLjIpJyxcbiAgICAgICAgICAgIGFjdGl2ZVBhbGV0dGUgIDogWycjMDBCRkZGJywgJyM1MzZERkUnLCAnIzNFNjNERCcsICcjMDBFNUZGJ10sXG4gICAgICAgICAgICBrZXJuZWwgICAgICAgICA6ICdyZ2JhKDYyLCA5OSwgMjIxLCAwLjA4KScsXG4gICAgICAgICAgICBydW5uZXIgICAgICAgICA6ICcjMDBCRkZGJyxcbiAgICAgICAgICAgIHJ1bm5lclBhbGV0dGUgIDogWycjMDBCRkZGJywgJyM1MzZERkUnLCAnIzNFNjNERCcsICcjMDBFNUZGJ10sXG4gICAgICAgICAgICBhZ2VudEhlYWQgICAgICA6ICcjM0U2M0REJyxcbiAgICAgICAgICAgIHN1cGVySGV4ICAgICAgIDogJ3JnYmEoNjIsIDk5LCAyMjEsIDAuMyknLFxuICAgICAgICAgICAgc3RyYXRhICAgICAgICAgOiAncmdiYSg2MiwgOTksIDIyMSwgMC4wNSknXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nUG9ydGFsLmNhbnZhcy5TZXJ2aWNlc0NhbnZhcydcbiAgICAgICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAnUG9ydGFsLmNhbnZhcy5TZXJ2aWNlc0NhbnZhcycsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlbW90ZSBtZXRob2QgYWNjZXNzIGZvciB0aGUgQXBwIFdvcmtlci5cbiAgICAgICAgICogQWxsb3dzIHRoZSBVSSAoQ29udHJvbGxlcikgdG8gY29udHJvbCB0aGUgc2ltdWxhdGlvbiBzdGF0ZSBhbmQgaW5wdXQuXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gcmVtb3RlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHJlbW90ZToge1xuICAgICAgICAgICAgYXBwOiBbXG4gICAgICAgICAgICAgICAgJ3VwZGF0ZVNpemUnXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaW5nbGV0b249dHJ1ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzaW5nbGV0b246IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gYW5pbWF0aW9uSWQ9bnVsbFxuICAgICAqL1xuICAgIGFuaW1hdGlvbklkID0gbnVsbFxuICAgIC8qKlxuICAgICAqIElEIG9mIHRoZSBjYW52YXMgZWxlbWVudCBpbiB0aGUgRE9NLlxuICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBjYW52YXNJZD1udWxsXG4gICAgICovXG4gICAgY2FudmFzSWQgPSBudWxsXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBkaW1lbnNpb25zIG9mIHRoZSBjYW52YXMuXG4gICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGNhbnZhc1NpemU9bnVsbFxuICAgICAqL1xuICAgIGNhbnZhc1NpemUgPSBudWxsXG4gICAgLyoqXG4gICAgICogVGhlIDJEIHJlbmRlcmluZyBjb250ZXh0LlxuICAgICAqIEBtZW1iZXIge09mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRHxudWxsfSBjb250ZXh0PW51bGxcbiAgICAgKi9cbiAgICBjb250ZXh0ID0gbnVsbFxuXG4gICAgLyoqXG4gICAgICogQnVmZmVyIGZvciB0aGUgbWFpbiBBcHBsaWNhdGlvbiBMYXR0aWNlIChUaGUgR3JhcGgpLlxuICAgICAqIEBtZW1iZXIge0Zsb2F0MzJBcnJheXxudWxsfSBjZWxsQnVmZmVyXG4gICAgICovXG4gICAgY2VsbEJ1ZmZlciA9IG51bGxcbiAgICAvKipcbiAgICAgKiBCdWZmZXIgZm9yIERhdGEgUnVubmVycyAoSGlnaC1zcGVlZCBwYWNrZXRzKS5cbiAgICAgKiBAbWVtYmVyIHtGbG9hdDMyQXJyYXl8bnVsbH0gcnVubmVyQnVmZmVyXG4gICAgICovXG4gICAgcnVubmVyQnVmZmVyID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEJ1ZmZlciBmb3IgdGhlIEtlcm5lbCBMYXllciAoQmFja2dyb3VuZCBQYXJhbGxheCkuXG4gICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fG51bGx9IGtlcm5lbEJ1ZmZlclxuICAgICAqL1xuICAgIGtlcm5lbEJ1ZmZlciA9IG51bGxcbiAgICAvKipcbiAgICAgKiBCdWZmZXIgZm9yIERhdGEgU3RyYXRhIChNaWQtZ3JvdW5kIENsdXN0ZXJzKS5cbiAgICAgKiBAbWVtYmVyIHtGbG9hdDMyQXJyYXl8bnVsbH0gc3RyYXRhQnVmZmVyXG4gICAgICovXG4gICAgc3RyYXRhQnVmZmVyID0gbnVsbFxuXG4gICAgLyoqXG4gICAgICogQnVmZmVyIGZvciBDb25zdHJ1Y3Rpb24gUGFydGljbGVzLlxuICAgICAqIFN0cmlkZTogW3gsIHksIHosIHZ4LCB2eSwgdnosIGxpZmUsIGNvbG9ySWR4XVxuICAgICAqIEBtZW1iZXIge0Zsb2F0MzJBcnJheXxudWxsfSBwYXJ0aWNsZUJ1ZmZlclxuICAgICAqL1xuICAgIHBhcnRpY2xlQnVmZmVyID0gbnVsbFxuXG4gICAgLyoqXG4gICAgICogUmV1c2FibGUgb2JqZWN0IGZvciBwcm9qZWN0aW9uIGNhbGN1bGF0aW9ucyB0byBhdm9pZCBHQ1xuICAgICAqIEBtZW1iZXIge09iamVjdH0gcHJvamVjdGlvblBvaW50XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHByb2plY3Rpb25Qb2ludCA9IHt4OiAwLCB5OiAwLCBzY2FsZTogMCwgdmlzaWJsZTogZmFsc2V9XG5cbiAgICAvKipcbiAgICAgKiBQcm9qZWN0aW9uIG1hdHJpeCBjYWNoZVxuICAgICAqIEBtZW1iZXIge09iamVjdH0gcHJvamVjdGlvbk1hdHJpeFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwcm9qZWN0aW9uTWF0cml4ID0ge2N4OiAwLCBjeTogMCwgY29zWDogMCwgc2luWDogMCwgY29zWTogMCwgc2luWTogMH1cblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgYWN0aXZlIFwiU3VwZXIgSGV4ZXNcIiAoTWVyZ2VkIGNlbGxzKS5cbiAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gc3VwZXJIZXhlcz1bXVxuICAgICAqL1xuICAgIHN1cGVySGV4ZXMgPSBbXVxuICAgIC8qKlxuICAgICAqIFNjYWxpbmcgZmFjdG9yIHJlbGF0aXZlIHRvIHJlZmVyZW5jZSB2aWV3cG9ydC5cbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHNjYWxlPTFcbiAgICAgKi9cbiAgICBzY2FsZSA9IDFcbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGNhbWVyYSByb3RhdGlvbiBpbiByYWRpYW5zIChQaXRjaCwgWWF3KS5cbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHJvdGF0aW9uPXt4OiAtMC40LCB5OiAwfVxuICAgICAqL1xuICAgIHJvdGF0aW9uID0ge3g6IC0wLjQsIHk6IDB9IC8vIEJhc2UgdGlsdCAocmFkaWFucykgLSBGbG9vciBQZXJzcGVjdGl2ZVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBncmFwaCBzdGF0ZSBhbmQgc3RvcHMgdGhlIHJlbmRlciBsb29wLlxuICAgICAqIFVzZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGRlc3Ryb3llZCBvciB0aGUgcm91dGUgY2hhbmdlcyB0byByZWxlYXNlIG1lbW9yeS5cbiAgICAgKi9cbiAgICBjbGVhckdyYXBoKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuICAgICAgICBzdXBlci5jbGVhckdyYXBoKCk7XG4gICAgICAgIG1lLmNlbGxCdWZmZXIgICA9IG51bGw7XG4gICAgICAgIG1lLnJ1bm5lckJ1ZmZlciA9IG51bGw7XG4gICAgICAgIG1lLmtlcm5lbEJ1ZmZlciA9IG51bGw7XG4gICAgICAgIG1lLnN0cmF0YUJ1ZmZlciA9IG51bGw7XG4gICAgICAgIG1lLnBhcnRpY2xlQnVmZmVyID0gbnVsbDtcbiAgICAgICAgbWUuc3VwZXJIZXhlcyAgID0gW107XG4gICAgICAgIG1lLnNjYWxlICAgICAgICA9IDFcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIb29rIHRvIGluaXRpYWxpemUgbm9kZXMgYW5kIGJ1ZmZlcnMgYWZ0ZXIgY29udGV4dCBpcyByZWFkeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgKi9cbiAgICBvbkdyYXBoTW91bnRlZCh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMudXBkYXRlU2l6ZSh7d2lkdGgsIGhlaWdodH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgYSBzaW5nbGUgSGV4YWdvbiBwcm9qZWN0ZWQgaW50byAzRCBzcGFjZS5cbiAgICAgKiBVc2VzIHRoZSByZXVzZWQgYHByb2plY3Rpb25Qb2ludGAgdG8gYXZvaWQgYWxsb2NhdGlvbnMuXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IFdvcmxkIFhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSBXb3JsZCBZXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHogV29ybGQgWlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzaXplIFJhZGl1cyBpbiBwaXhlbHNcbiAgICAgKi9cbiAgICBkcmF3SGV4KGN0eCwgeCwgeSwgeiwgc2l6ZSkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgZmlyc3QgPSB0cnVlLFxuICAgICAgICAgICAgcDtcblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGFuZ2xlX2RlZyA9IDYwICogaSArIDMwO1xuICAgICAgICAgICAgY29uc3QgYW5nbGVfcmFkID0gTWF0aC5QSSAvIDE4MCAqIGFuZ2xlX2RlZztcblxuICAgICAgICAgICAgY29uc3QgcHggPSB4ICsgc2l6ZSAqIE1hdGguY29zKGFuZ2xlX3JhZCk7XG4gICAgICAgICAgICBjb25zdCBweSA9IHkgKyBzaXplICogTWF0aC5zaW4oYW5nbGVfcmFkKTtcblxuICAgICAgICAgICAgcCA9IG1lLnByb2plY3QocHgsIHB5LCB6KTtcblxuICAgICAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhwLngsIHAueSk7XG4gICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhwLngsIHAueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYXdzIHRoZSBLZXJuZWwgTGF5ZXIgKEJhY2tncm91bmQpLlxuICAgICAqIFRoaXMgbGF5ZXIgbW92ZXMgc2xvd2x5IChQYXJhbGxheCkgdG8gY3JlYXRlIGRlcHRoLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAgICovXG4gICAgZHJhd0tlcm5lbChjdHgsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcbiAgICAgICAgaWYgKCFtZS5rZXJuZWxCdWZmZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBidWZmZXIgICAgICA9IG1lLmtlcm5lbEJ1ZmZlcixcbiAgICAgICAgICAgIGNvdW50ICAgICAgID0gYnVmZmVyLmxlbmd0aCAvIDIsXG4gICAgICAgICAgICBzICAgICAgICAgICA9IG1lLnNjYWxlLFxuICAgICAgICAgICAgc2l6ZSAgICAgICAgPSBLRVJORUxfSEVYX1NJWkUgKiBzLFxuICAgICAgICAgICAgdGhlbWVDb2xvcnMgPSBtZS5jb25zdHJ1Y3Rvci5jb2xvcnNbbWUudGhlbWVdO1xuXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoZW1lQ29sb3JzLmtlcm5lbDtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCAgID0gMiAqIHM7XG4gICAgICAgIGN0eC5saW5lSm9pbiAgICA9ICdyb3VuZCc7XG5cbiAgICAgICAgbGV0IHBhblggPSBNYXRoLnNpbihtZS50aW1lICogMC4yKSAqIDIwICogcyxcbiAgICAgICAgICAgIHBhblkgPSBNYXRoLmNvcyhtZS50aW1lICogMC4yKSAqIDIwICogcztcblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IHggPSBidWZmZXJbaSAqIDJdICsgcGFuWCxcbiAgICAgICAgICAgICAgICB5ID0gYnVmZmVyW2kgKiAyICsgMV0gKyBwYW5ZO1xuICAgICAgICAgICAgbWUuZHJhd0hleChjdHgsIHgsIHksIDQwMCwgc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYXdzIHRoZSBEYXRhIFN0cmF0YSAoTWlkLWdyb3VuZCBmbG9hdGluZyBjbHVzdGVycykuXG4gICAgICogVGhlc2UgZWxlbWVudHMgc2l0IGJldHdlZW4gdGhlIGJhY2tncm91bmQgYW5kIHRoZSBtYWluIGxhdHRpY2UuXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgKi9cbiAgICBkcmF3U3RyYXRhKGN0eCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuICAgICAgICBpZiAoIW1lLnN0cmF0YUJ1ZmZlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIGJ1ZmZlciAgICAgID0gbWUuc3RyYXRhQnVmZmVyLFxuICAgICAgICAgICAgY291bnQgICAgICAgPSBTVFJBVEFfQ09VTlQsXG4gICAgICAgICAgICBzICAgICAgICAgICA9IG1lLnNjYWxlLFxuICAgICAgICAgICAgdGhlbWVDb2xvcnMgPSBtZS5jb25zdHJ1Y3Rvci5jb2xvcnNbbWUudGhlbWVdO1xuXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGVtZUNvbG9ycy5zdHJhdGE7XG5cbiAgICAgICAgbGV0IHBhblggPSBNYXRoLnNpbihtZS50aW1lICogMC4xNSkgKiAzMCAqIHMsXG4gICAgICAgICAgICBwYW5ZID0gTWF0aC5jb3MobWUudGltZSAqIDAuMTUpICogMzAgKiBzO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkeCAgPSBpICogU1RSQVRBX1NUUklERSxcbiAgICAgICAgICAgICAgICB4ICAgID0gYnVmZmVyW2lkeF0gKyBwYW5YLFxuICAgICAgICAgICAgICAgIHkgICAgPSBidWZmZXJbaWR4ICsgMV0gKyBwYW5ZLFxuICAgICAgICAgICAgICAgIHogICAgPSBidWZmZXJbaWR4ICsgMl0sXG4gICAgICAgICAgICAgICAgc2l6ZSA9IGJ1ZmZlcltpZHggKyAzXSAqIHM7XG5cbiAgICAgICAgICAgIG1lLmRyYXdIZXgoY3R4LCB4LCB5LCB6LCBzaXplKTtcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgbWFpbiBBcHBsaWNhdGlvbiBMYXR0aWNlIChGb3JlZ3JvdW5kKS5cbiAgICAgKiBIYW5kbGVzIDMgYmF0Y2hlczpcbiAgICAgKiAxLiAqKklkbGUgSGV4ZXM6KiogRmFpbnQgb3V0bGluZXMuXG4gICAgICogMi4gKipTdXBlciBIZXhlczoqKiBMYXJnZSwgbWVyZ2VkIG1vZHVsZXMgd2l0aCBmaWxsIGFuZCBjZW50ZXIgZ2xvdy5cbiAgICAgKiAzLiAqKkFjdGl2ZSBIZXhlczoqKiBFbmVyZ2l6ZWQgbm9kZXMgd2l0aCBcIkhvbG9ncmFwaGljIFBvcFwiICgzRCBleHRydXNpb24pLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAgICovXG4gICAgZHJhd0dyYXBoKGN0eCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUuY2VsbEJ1ZmZlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIGJ1ZmZlciAgICAgID0gbWUuY2VsbEJ1ZmZlcixcbiAgICAgICAgICAgIGNvdW50ICAgICAgID0gYnVmZmVyLmxlbmd0aCAvIFNUUklERSxcbiAgICAgICAgICAgIHRoZW1lQ29sb3JzID0gbWUuY29uc3RydWN0b3IuY29sb3JzW21lLnRoZW1lXSxcbiAgICAgICAgICAgIHMgICAgICAgICAgID0gbWUuc2NhbGUsXG4gICAgICAgICAgICBiYXNlU2l6ZSAgICA9IEhFWF9TSVpFICogcztcblxuICAgICAgICBjdHgubGluZVdpZHRoID0gMSAqIHM7XG4gICAgICAgIGN0eC5saW5lSm9pbiAgPSAncm91bmQnO1xuXG4gICAgICAgIC8vIEJhdGNoIDE6IElkbGUgSGV4ZXNcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGVtZUNvbG9ycy5oZXhMaW5lO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkeCAgICA9IGkgKiBTVFJJREUsXG4gICAgICAgICAgICAgICAgeCAgICAgID0gYnVmZmVyW2lkeCArIDJdLFxuICAgICAgICAgICAgICAgIHkgICAgICA9IGJ1ZmZlcltpZHggKyAzXSxcbiAgICAgICAgICAgICAgICBzY2FsZSAgPSBidWZmZXJbaWR4ICsgNF0sXG4gICAgICAgICAgICAgICAgZW5lcmd5ID0gYnVmZmVyW2lkeCArIDVdO1xuXG4gICAgICAgICAgICBpZiAoZW5lcmd5IDw9IDAuMDEgJiYgc2NhbGUgPiAwLjEpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2l6ZSA9IGJhc2VTaXplICogMC45NSAqIHNjYWxlO1xuICAgICAgICAgICAgICAgIG1lLmRyYXdIZXgoY3R4LCB4LCB5LCAwLCBzaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgLy8gQmF0Y2ggMjogU3VwZXIgSGV4ZXNcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDIgKiBzO1xuICAgICAgICBmb3IgKGxldCBzaCBvZiBtZS5zdXBlckhleGVzKSB7XG4gICAgICAgICAgICBsZXQgaWR4ICAgICAgPSBzaC5jZW50ZXJJZHgsXG4gICAgICAgICAgICAgICAgeCAgICAgICAgPSBidWZmZXJbaWR4ICsgMl0sXG4gICAgICAgICAgICAgICAgeSAgICAgICAgPSBidWZmZXJbaWR4ICsgM10sXG4gICAgICAgICAgICAgICAgY29sb3JJZHggPSBidWZmZXJbaWR4ICsgN10sXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3MgPSAwO1xuXG4gICAgICAgICAgICBpZiAoc2guc3RhdGUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzcyA9IHNoLmFnZSAvIDMwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzaC5zdGF0ZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHByb2dyZXNzID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3MgPSAxIC0gKHNoLmFnZSAvIDMwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHByb2dyZXNzID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBjb2xvciA9IHRoZW1lQ29sb3JzLmFjdGl2ZVBhbGV0dGVbY29sb3JJZHhdO1xuXG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIG1lLmRyYXdIZXgoY3R4LCB4LCB5LCAwLCBiYXNlU2l6ZSAqIDIuNSAqIHByb2dyZXNzKTtcblxuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuMyAqIHByb2dyZXNzO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGVtZUNvbG9ycy5zdXBlckhleDtcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuXG4gICAgICAgICAgICAgICAgbGV0IHAgPSBtZS5wcm9qZWN0KHgsIHksIDApO1xuXG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5hcmMocC54LCBwLnksIDQgKiBzICogcHJvZ3Jlc3MgKiBwLnNjYWxlLCAwLCBNYXRoLlBJICogMik7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSAgID0gY29sb3I7XG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC44ICogcHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgICBjdHgubGluZVdpZHRoICAgPSAxICogcztcblxuICAgICAgICAvLyBCYXRjaCAzOiBBY3RpdmUgLyBFbmVyZ2l6ZWQgSGV4ZXNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaWR4ICAgICAgPSBpICogU1RSSURFLFxuICAgICAgICAgICAgICAgIHggICAgICAgID0gYnVmZmVyW2lkeCArIDJdLFxuICAgICAgICAgICAgICAgIHkgICAgICAgID0gYnVmZmVyW2lkeCArIDNdLFxuICAgICAgICAgICAgICAgIHNjYWxlICAgID0gYnVmZmVyW2lkeCArIDRdLFxuICAgICAgICAgICAgICAgIGVuZXJneSAgID0gYnVmZmVyW2lkeCArIDVdLFxuICAgICAgICAgICAgICAgIGNvbG9ySWR4ID0gYnVmZmVyW2lkeCArIDddO1xuXG4gICAgICAgICAgICBpZiAoZW5lcmd5ID4gMC4wMSAmJiBzY2FsZSA+IDAuNSkge1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50U2l6ZSA9IGJhc2VTaXplICogKDAuOTUgKyAoZW5lcmd5ICogMC4xKSksXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yICAgICAgID0gdGhlbWVDb2xvcnMuYWN0aXZlUGFsZXR0ZVtjb2xvcklkeF07XG5cbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgbWUuZHJhd0hleChjdHgsIHgsIHksIDAsIGN1cnJlbnRTaXplKTtcblxuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgICA9IHRoZW1lQ29sb3JzLmhleEFjdGl2ZTtcbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBlbmVyZ3kgKiAwLjQ7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcblxuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggICA9ICgxICsgZW5lcmd5KSAqIHM7XG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gZW5lcmd5ICogMC44O1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICAgICAgICAgIC8vIEhvbG9ncmFwaGljIFBvcCAoR2hvc3QgSGV4KVxuICAgICAgICAgICAgICAgIGlmIChlbmVyZ3kgPiAwLjMpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcG9wWiA9IC01MCAqIGVuZXJneTsgLy8gRmxvYXQgdXBcbiAgICAgICAgICAgICAgICAgICAgbWUuZHJhd0hleChjdHgsIHgsIHksIHBvcFosIGN1cnJlbnRTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGVuZXJneSAqIDAuNDtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCAgID0gMSAqIHM7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggICA9IDEgKiBzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgRGF0YSBSdW5uZXJzIChIaWdoLXNwZWVkIFBhY2tldHMpLlxuICAgICAqIFZpc3VhbGl6ZWQgYXMgYSBncmFkaWVudCBsaW5lIChUcmFpbCkgbGVhZGluZyB0byBhIHdoaXRlIGhlYWQuXG4gICAgICogVXNlcyBvcHRpbWl6ZWQgcHJvamVjdGlvbiByZS11c2UuXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqL1xuICAgIGRyYXdSdW5uZXJzKGN0eCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuICAgICAgICBpZiAoIW1lLnJ1bm5lckJ1ZmZlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIGJ1ZmZlciAgICAgID0gbWUucnVubmVyQnVmZmVyLFxuICAgICAgICAgICAgY291bnQgICAgICAgPSBSVU5ORVJfQ09VTlQsXG4gICAgICAgICAgICB0aGVtZUNvbG9ycyA9IG1lLmNvbnN0cnVjdG9yLmNvbG9yc1ttZS50aGVtZV0sXG4gICAgICAgICAgICBzICAgICAgICAgICA9IG1lLnNjYWxlLFxuICAgICAgICAgICAgcHAgICAgICAgICAgPSBtZS5wcm9qZWN0aW9uUG9pbnQ7IC8vIFNob3J0Y3V0XG5cbiAgICAgICAgY3R4LmxpbmVDYXAgPSAncm91bmQnO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkeCAgICAgID0gaSAqIFJVTk5FUl9TVFJJREUsXG4gICAgICAgICAgICAgICAgeCAgICAgICAgPSBidWZmZXJbaWR4XSxcbiAgICAgICAgICAgICAgICB5ICAgICAgICA9IGJ1ZmZlcltpZHggKyAxXSxcbiAgICAgICAgICAgICAgICB0eCAgICAgICA9IGJ1ZmZlcltpZHggKyAyXSxcbiAgICAgICAgICAgICAgICB0eSAgICAgICA9IGJ1ZmZlcltpZHggKyAzXSxcbiAgICAgICAgICAgICAgICBzcCAgICAgICA9IGJ1ZmZlcltpZHggKyA1XSxcbiAgICAgICAgICAgICAgICBjb2xvcklkeCA9IGJ1ZmZlcltpZHggKyA3XSxcbiAgICAgICAgICAgICAgICBzdGF0ZSAgICA9IGJ1ZmZlcltpZHggKyA4XSxcbiAgICAgICAgICAgICAgICBzY2FuVGltZSA9IGJ1ZmZlcltpZHggKyA5XTtcblxuICAgICAgICAgICAgLy8gUHJvamVjdCBIZWFkIChBbHdheXMgbmVlZGVkKVxuICAgICAgICAgICAgbWUucHJvamVjdCh4LCB5LCAwKTtcblxuICAgICAgICAgICAgaWYgKCFwcC52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaGVhZFggPSBwcC54LFxuICAgICAgICAgICAgICAgIGhlYWRZID0gcHAueSxcbiAgICAgICAgICAgICAgICBoZWFkUyA9IHBwLnNjYWxlO1xuXG4gICAgICAgICAgICBsZXQgY29sb3IgPSB0aGVtZUNvbG9ycy5ydW5uZXJQYWxldHRlW2NvbG9ySWR4XTtcblxuICAgICAgICAgICAgLy8gU1RBVEUgMDogTU9WSU5HIChEcmF3IFRyYWlsKVxuICAgICAgICAgICAgaWYgKHN0YXRlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGR4ICAgPSB0eCAtIHgsXG4gICAgICAgICAgICAgICAgICAgIGR5ICAgPSB0eSAtIHksXG4gICAgICAgICAgICAgICAgICAgIGRpc3QgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRpc3QgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0YWlsTGVuID0gc3AgKiAxMiAqIHM7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkaXJYICAgID0gZHggLyBkaXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlyWSAgICA9IGR5IC8gZGlzdDtcblxuICAgICAgICAgICAgICAgICAgICBsZXQgdGFpbFggPSB4IC0gZGlyWCAqIHRhaWxMZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWlsWSA9IHkgLSBkaXJZICogdGFpbExlbjtcblxuICAgICAgICAgICAgICAgICAgICAvLyBQcm9qZWN0IFRhaWxcbiAgICAgICAgICAgICAgICAgICAgbWUucHJvamVjdCh0YWlsWCwgdGFpbFksIDApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcDF4ICAgPSBwcC54LFxuICAgICAgICAgICAgICAgICAgICAgICAgcDF5ICAgPSBwcC55O1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBnID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHAxeCwgcDF5LCBoZWFkWCwgaGVhZFkpO1xuICAgICAgICAgICAgICAgICAgICBnLmFkZENvbG9yU3RvcCgwLCAncmdiYSgwLDAsMCwwKScpO1xuICAgICAgICAgICAgICAgICAgICBnLmFkZENvbG9yU3RvcCgwLjIsIGNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgZy5hZGRDb2xvclN0b3AoMC42LCBjb2xvcik7XG4gICAgICAgICAgICAgICAgICAgIGcuYWRkQ29sb3JTdG9wKDEsIHRoZW1lQ29sb3JzLmFnZW50SGVhZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBnO1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoICAgPSAzICogcyAqIGhlYWRTO1xuICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHAxeCwgcDF5KTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhoZWFkWCwgaGVhZFkpO1xuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU1RBVEUgMTogU0NBTk5JTkcgKERyYXcgUHVsc2UpXG4gICAgICAgICAgICBlbHNlIGlmIChzdGF0ZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGxldCByYWRpdXMgPSAoSEVYX1NJWkUgKiBzICogMS41KSAqIHNjYW5UaW1lICogaGVhZFM7XG5cbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4LmFyYyhoZWFkWCwgaGVhZFksIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggICA9IDIgKiBzICogaGVhZFMgKiAoMSAtIHNjYW5UaW1lKTsgLy8gRmFkZSBvdXRcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBTY2FubmluZyBCZWFtIChWZXJ0aWNhbClcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhoZWFkWCwgaGVhZFkpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oaGVhZFgsIGhlYWRZIC0gKDMwICogcyAqIGhlYWRTICogTWF0aC5zaW4oc2NhblRpbWUgKiBNYXRoLlBJKSkpO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoZW1lQ29sb3JzLmFnZW50SGVhZDtcbiAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoICAgPSAyICogcyAqIGhlYWRTO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRHJhdyBIZWFkIChEaWFtb25kIFNoYXBlKVxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoZW1lQ29sb3JzLmFnZW50SGVhZDtcbiAgICAgICAgICAgIGxldCBocyA9IDQgKiBzICogaGVhZFM7IC8vIEhlYWQgU2l6ZVxuICAgICAgICAgICAgY3R4Lm1vdmVUbyhoZWFkWCwgaGVhZFkgLSBocyk7XG4gICAgICAgICAgICBjdHgubGluZVRvKGhlYWRYICsgaHMsIGhlYWRZKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oaGVhZFgsIGhlYWRZICsgaHMpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhoZWFkWCAtIGhzLCBoZWFkWSk7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuXG4gICAgICAgICAgICAvLyBHbG93XG4gICAgICAgICAgICBjdHguc2hhZG93Qmx1ciAgPSAxMCAqIHM7XG4gICAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSBjb2xvcjtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dCbHVyICA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBjb25zdHJ1Y3Rpb24gcGFydGljbGVzLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKi9cbiAgICBkcmF3UGFydGljbGVzKGN0eCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuICAgICAgICBpZiAoIW1lLnBhcnRpY2xlQnVmZmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdFxuICAgICAgICAgICAgYnVmZmVyICAgICAgPSBtZS5wYXJ0aWNsZUJ1ZmZlcixcbiAgICAgICAgICAgIGNvdW50ICAgICAgID0gUEFSVElDTEVfQ09VTlQsXG4gICAgICAgICAgICB0aGVtZUNvbG9ycyA9IG1lLmNvbnN0cnVjdG9yLmNvbG9yc1ttZS50aGVtZV0sXG4gICAgICAgICAgICBzICAgICAgICAgICA9IG1lLnNjYWxlLFxuICAgICAgICAgICAgcHAgICAgICAgICAgPSBtZS5wcm9qZWN0aW9uUG9pbnQ7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaWR4ICA9IGkgKiBQQVJUSUNMRV9TVFJJREUsXG4gICAgICAgICAgICAgICAgbGlmZSA9IGJ1ZmZlcltpZHggKyA2XTsgLy8gbGlmZSBpcyBub3cgYXQgaW5kZXggNlxuXG4gICAgICAgICAgICBpZiAobGlmZSA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgeCAgICA9IGJ1ZmZlcltpZHhdLFxuICAgICAgICAgICAgICAgICAgICB5ICAgID0gYnVmZmVyW2lkeCArIDFdLFxuICAgICAgICAgICAgICAgICAgICB6ICAgID0gYnVmZmVyW2lkeCArIDJdLFxuICAgICAgICAgICAgICAgICAgICBzaXplID0gMyAqIHMgKiBsaWZlOyAvLyBTaHJpbmsgYXMgaXQgZGllc1xuXG4gICAgICAgICAgICAgICAgbWUucHJvamVjdCh4LCB5LCB6KTtcblxuICAgICAgICAgICAgICAgIGlmIChwcC52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzY2FsZWRTaXplID0gc2l6ZSAqIHBwLnNjYWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JJZHggICA9IGJ1ZmZlcltpZHggKyA3XTsgLy8gY29sb3JJZHggYXQgaW5kZXggN1xuXG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgICA9IHRoZW1lQ29sb3JzLnBhcnRpY2xlUGFsZXR0ZVtjb2xvcklkeF07XG4gICAgICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGxpZmU7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChwcC54IC0gc2NhbGVkU2l6ZSAvIDIsIHBwLnkgLSBzY2FsZWRTaXplIC8gMiwgc2NhbGVkU2l6ZSwgc2NhbGVkU2l6ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxsb2NhdGVzIHRoZSBQYXJ0aWNsZSBCdWZmZXIgKENvbnN0cnVjdGlvbiBFZmZlY3RzKS5cbiAgICAgKi9cbiAgICBpbml0UGFydGljbGVzKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuICAgICAgICBpZiAoIW1lLnBhcnRpY2xlQnVmZmVyKSB7XG4gICAgICAgICAgICBtZS5wYXJ0aWNsZUJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoUEFSVElDTEVfQ09VTlQgKiBQQVJUSUNMRV9TVFJJREUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIEtlcm5lbCBCdWZmZXIgKEJhY2tncm91bmQgR3JpZCkuXG4gICAgICogQ3JlYXRlcyBhIGxhcmdlLXNjYWxlIEhleCBncmlkIHRoYXQgZXh0ZW5kcyBiZXlvbmQgdGhlIHZpZXdwb3J0IGZvciBwYXJhbGxheCBtb3ZlbWVudC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAgICovXG4gICAgaW5pdEtlcm5lbCh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcztcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIHMgICAgICAgPSBtZS5zY2FsZSxcbiAgICAgICAgICAgIHNpemUgICAgPSBLRVJORUxfSEVYX1NJWkUgKiBzLFxuICAgICAgICAgICAgY29sU3RlcCA9IHNpemUgKiAxLjUsXG4gICAgICAgICAgICByb3dTdGVwID0gc2l6ZSAqIE1hdGguc3FydCgzKSxcbiAgICAgICAgICAgIGNvbHMgICAgPSBNYXRoLmNlaWwod2lkdGggLyBjb2xTdGVwKSArIDQsXG4gICAgICAgICAgICByb3dzICAgID0gTWF0aC5jZWlsKGhlaWdodCAvIHJvd1N0ZXApICsgNCxcbiAgICAgICAgICAgIGNvdW50ICAgPSBjb2xzICogcm93cztcblxuICAgICAgICBtZS5rZXJuZWxCdWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KGNvdW50ICogMik7XG5cbiAgICAgICAgbGV0IGkgICAgICA9IDA7XG4gICAgICAgIGxldCBzdGFydFggPSAtKGNvbFN0ZXAgKiAyKSxcbiAgICAgICAgICAgIHN0YXJ0WSA9IC0ocm93U3RlcCAqIDIpO1xuXG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY29sczsgYysrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCByID0gMDsgciA8IHJvd3M7IHIrKykge1xuICAgICAgICAgICAgICAgIGxldCB4ID0gc3RhcnRYICsgYyAqIGNvbFN0ZXA7XG4gICAgICAgICAgICAgICAgbGV0IHkgPSBzdGFydFkgKyByICogcm93U3RlcDtcbiAgICAgICAgICAgICAgICBpZiAoYyAlIDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgeSArPSByb3dTdGVwIC8gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWUua2VybmVsQnVmZmVyW2kgKiAyXSAgICAgPSB4O1xuICAgICAgICAgICAgICAgIG1lLmtlcm5lbEJ1ZmZlcltpICogMiArIDFdID0geTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgTWFpbiBMYXR0aWNlIChBcHBsaWNhdGlvbiBMYXllcikuXG4gICAgICogQ3JlYXRlcyBhIHN0YW5kYXJkIEhleGFnb25hbCBHcmlkIGNvdmVyaW5nIHRoZSBzY3JlZW4gKyBtYXJnaW5zLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgKi9cbiAgICBpbml0Tm9kZXMod2lkdGgsIGhlaWdodCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBzICAgICAgID0gbWUuc2NhbGUsXG4gICAgICAgICAgICBzaXplICAgID0gSEVYX1NJWkUgKiBzLFxuICAgICAgICAgICAgY29sU3RlcCA9IHNpemUgKiAxLjUsXG4gICAgICAgICAgICByb3dTdGVwID0gc2l6ZSAqIE1hdGguc3FydCgzKSxcbiAgICAgICAgICAgIGNvbHMgICAgPSBNYXRoLmNlaWwod2lkdGggLyBjb2xTdGVwKSArIDIsXG4gICAgICAgICAgICAvLyBFeHRlbmQgcm93cyB1cHdhcmRzIGZvciBwZXJzcGVjdGl2ZSAoSG9yaXpvbiBCdWZmZXIpXG4gICAgICAgICAgICByb3dzICAgID0gTWF0aC5jZWlsKGhlaWdodCAvIHJvd1N0ZXApICsgMTIsXG4gICAgICAgICAgICBjb3VudCAgID0gY29scyAqIHJvd3M7XG5cbiAgICAgICAgaWYgKCFtZS5jZWxsQnVmZmVyIHx8IG1lLmNlbGxCdWZmZXIubGVuZ3RoICE9PSBjb3VudCAqIFNUUklERSkge1xuICAgICAgICAgICAgbWUuY2VsbEJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoY291bnQgKiBTVFJJREUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYnVmZmVyID0gbWUuY2VsbEJ1ZmZlcjtcblxuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIC8vIFN0YXJ0IDEwIHJvd3MgaGlnaGVyIHVwIHRvIGZpbGwgdGhlIGRpc3RhbmNlXG4gICAgICAgIGZvciAobGV0IGMgPSAtMTsgYyA8IGNvbHM7IGMrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgciA9IC0xMDsgciA8IHJvd3MgLSAxMDsgcisrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHggPSBjICogY29sU3RlcDtcbiAgICAgICAgICAgICAgICBsZXQgeSA9IHIgKiByb3dTdGVwO1xuICAgICAgICAgICAgICAgIGlmIChjICUgMiA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB5ICs9IHJvd1N0ZXAgLyAyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBpZHggICAgICAgICA9IGkgKiBTVFJJREU7XG4gICAgICAgICAgICAgICAgYnVmZmVyW2lkeF0gICAgID0gYztcbiAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgMV0gPSByO1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltpZHggKyAyXSA9IHg7XG4gICAgICAgICAgICAgICAgYnVmZmVyW2lkeCArIDNdID0geTtcbiAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgNF0gPSAxO1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltpZHggKyA1XSA9IDA7XG4gICAgICAgICAgICAgICAgYnVmZmVyW2lkeCArIDZdID0gMDtcbiAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgN10gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA0KTsgLy8gY29sb3JJZHhcblxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBjb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBEYXRhIFJ1bm5lcnMgKFRyYWZmaWMpLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgKi9cbiAgICBpbml0UnVubmVycyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG4gICAgICAgIGlmICghbWUucnVubmVyQnVmZmVyKSB7XG4gICAgICAgICAgICBtZS5ydW5uZXJCdWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KFJVTk5FUl9DT1VOVCAqIFJVTk5FUl9TVFJJREUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIGJ1ZmZlciA9IG1lLnJ1bm5lckJ1ZmZlcjtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IFJVTk5FUl9DT1VOVDsgaSsrKSB7XG4gICAgICAgICAgICBtZS5yZXNldFJ1bm5lcihpLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIGxldCBpZHggICAgICAgICA9IGkgKiBSVU5ORVJfU1RSSURFO1xuICAgICAgICAgICAgYnVmZmVyW2lkeCArIDRdID0gTWF0aC5yYW5kb20oKTsgLy8gUmFuZG9tIHN0YXJ0IHByb2dyZXNzXG4gICAgICAgICAgICBidWZmZXJbaWR4ICsgOF0gPSAwOyAvLyBTdGF0ZTogTW92aW5nXG4gICAgICAgICAgICBidWZmZXJbaWR4ICsgOV0gPSAwOyAvLyBTY2FuVGltZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgRGF0YSBTdHJhdGEgKEZsb2F0aW5nIE1pZC1ncm91bmQgQ2x1c3RlcnMpLlxuICAgICAqIFJhbmRvbWx5IHBsYWNlZCAzRCBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAgICovXG4gICAgaW5pdFN0cmF0YSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuc3RyYXRhQnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShTVFJBVEFfQ09VTlQgKiBTVFJBVEFfU1RSSURFKTtcbiAgICAgICAgY29uc3QgYnVmZmVyICAgID0gbWUuc3RyYXRhQnVmZmVyO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgU1RSQVRBX0NPVU5UOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpZHggICAgICAgICA9IGkgKiBTVFJBVEFfU1RSSURFO1xuICAgICAgICAgICAgYnVmZmVyW2lkeF0gICAgID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogd2lkdGggKiAyO1xuICAgICAgICAgICAgYnVmZmVyW2lkeCArIDFdID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogaGVpZ2h0ICogMztcbiAgICAgICAgICAgIGJ1ZmZlcltpZHggKyAyXSA9IDE1MCArIE1hdGgucmFuZG9tKCkgKiAxNTA7IC8vIFogZGVwdGggMTUwLTMwMFxuICAgICAgICAgICAgYnVmZmVyW2lkeCArIDNdID0gKEhFWF9TSVpFICogMykgKyBNYXRoLnJhbmRvbSgpICogSEVYX1NJWkUgKiA0OyAvLyBTaXplXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgbmVhcmVzdCBoZXggbm9kZSB0byBhIGdpdmVuIHNjcmVlbiBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge051bWJlcn0gSW5kZXggb2YgdGhlIG5lYXJlc3Qgbm9kZSBvciAtMVxuICAgICAqL1xuICAgIGZpbmROZWFyZXN0Tm9kZSh4LCB5KSB7XG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGJ1ZmZlciAgPSBtZS5jZWxsQnVmZmVyLFxuICAgICAgICAgICAgY291bnQgICA9IGJ1ZmZlci5sZW5ndGggLyBTVFJJREUsXG4gICAgICAgICAgICBtaW5EaXN0ID0gSW5maW5pdHksXG4gICAgICAgICAgICBiZXN0SWR4ID0gLTE7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaWR4ICA9IGkgKiBTVFJJREUsXG4gICAgICAgICAgICAgICAgbnggICA9IGJ1ZmZlcltpZHggKyAyXSxcbiAgICAgICAgICAgICAgICBueSAgID0gYnVmZmVyW2lkeCArIDNdLFxuICAgICAgICAgICAgICAgIGRpc3QgPSAobnggLSB4KSAqKiAyICsgKG55IC0geSkgKiogMjtcblxuICAgICAgICAgICAgaWYgKGRpc3QgPCBtaW5EaXN0KSB7XG4gICAgICAgICAgICAgICAgbWluRGlzdCA9IGRpc3Q7XG4gICAgICAgICAgICAgICAgYmVzdElkeCA9IGlkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmVzdElkeDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgYSBydW5uZXIgdG8gYSByYW5kb20gcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqL1xuICAgIHJlc2V0UnVubmVyKGluZGV4LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgYnVmZmVyICAgID0gbWUucnVubmVyQnVmZmVyLFxuICAgICAgICAgICAgbm9kZXMgICAgID0gbWUuY2VsbEJ1ZmZlcixcbiAgICAgICAgICAgIGlkeCAgICAgICA9IGluZGV4ICogUlVOTkVSX1NUUklERSxcbiAgICAgICAgICAgIG5vZGVDb3VudCA9IG5vZGVzLmxlbmd0aCAvIFNUUklERTtcblxuICAgICAgICBsZXQgbklkeCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG5vZGVDb3VudCkgKiBTVFJJREU7XG5cbiAgICAgICAgYnVmZmVyW2lkeF0gICAgID0gbm9kZXNbbklkeCArIDJdO1xuICAgICAgICBidWZmZXJbaWR4ICsgMV0gPSBub2Rlc1tuSWR4ICsgM107XG5cbiAgICAgICAgYnVmZmVyW2lkeCArIDJdID0gYnVmZmVyW2lkeF07XG4gICAgICAgIGJ1ZmZlcltpZHggKyAzXSA9IGJ1ZmZlcltpZHggKyAxXTtcbiAgICAgICAgYnVmZmVyW2lkeCArIDRdID0gMTtcbiAgICAgICAgYnVmZmVyW2lkeCArIDVdID0gKE1hdGgucmFuZG9tKCkgKiA0ICsgNSkgKiBtZS5zY2FsZTtcbiAgICAgICAgYnVmZmVyW2lkeCArIDZdID0gbklkeDtcbiAgICAgICAgYnVmZmVyW2lkeCArIDddID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNCk7IC8vIGNvbG9ySWR4XG4gICAgICAgIGJ1ZmZlcltpZHggKyA4XSA9IDA7IC8vIFN0YXRlOiBNb3ZpbmdcbiAgICAgICAgYnVmZmVyW2lkeCArIDldID0gMDsgLy8gU2NhblRpbWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTcGF3bnMgY29uc3RydWN0aW9uIHBhcnRpY2xlcy5cbiAgICAgKlxuICAgICAqICoqVmlzdWFsIE1ldGFwaG9yczoqKlxuICAgICAqIC0gKionaW1wbG9kZScqKjogUGFydGljbGVzIGZseSAqaW53YXJkKiBmcm9tIGEgcmFkaXVzIHRvIHRoZSBjZW50ZXIuIFJlcHJlc2VudHMgKipBc3NlbWJseSoqLFxuICAgICAqICAgKipNZW1vcnkgQWxsb2NhdGlvbioqLCBvciAqKkNyeXN0YWxsaXphdGlvbioqLiBVc2VkIHdoZW4gYSBTdXBlciBIZXggaXMgYm9ybi5cbiAgICAgKiAtICoqJ3VwbG9hZCcqKjogUGFydGljbGVzIGZseSAqdXB3YXJkKiAoWi1heGlzKSBhbmQgZmFkZSBvdXQuIFJlcHJlc2VudHMgKipEYXRhIFRyYW5zZmVyKiosXG4gICAgICogICAqKkNsb3VkIFN5bmMqKiwgb3IgKipyZWxlYXNlKiouIFVzZWQgd2hlbiBhIFN1cGVyIEhleCBmaW5pc2hlcyBpdHMgbGlmZWN5Y2xlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggV29ybGQgWFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFdvcmxkIFlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHBhcnRpY2xlcyB0byBzcGF3blxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlICdpbXBsb2RlJyBvciAndXBsb2FkJ1xuICAgICAqL1xuICAgIHNwYXduUGFydGljbGVzKHgsIHksIGNvdW50LCB0eXBlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG4gICAgICAgIGlmICghbWUucGFydGljbGVCdWZmZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBidWZmZXIgPSBtZS5wYXJ0aWNsZUJ1ZmZlcixcbiAgICAgICAgICAgIHRvdGFsICA9IFBBUlRJQ0xFX0NPVU5ULFxuICAgICAgICAgICAgcyAgICAgID0gbWUuc2NhbGU7XG5cbiAgICAgICAgLy8gRmluZCBlbXB0eSBzbG90c1xuICAgICAgICBsZXQgc3Bhd25lZCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWw7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkeCA9IGkgKiBQQVJUSUNMRV9TVFJJREU7XG5cbiAgICAgICAgICAgIC8vIElmIHNsb3QgaXMgZW1wdHkgKGxpZmUgPD0gMClcbiAgICAgICAgICAgIGlmIChidWZmZXJbaWR4ICsgNl0gPD0gMCkge1xuICAgICAgICAgICAgICAgIGxldCBhbmdsZSA9IE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJICogMixcbiAgICAgICAgICAgICAgICAgICAgc3BlZWQgPSAoTWF0aC5yYW5kb20oKSAqIDMgKyAyKSAqIHM7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2ltcGxvZGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IE9VVFNJREUsIG1vdmUgSU5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhZGl1cyAgICAgID0gNjAgKiBzO1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJbaWR4XSAgICAgPSB4ICsgTWF0aC5jb3MoYW5nbGUpICogcmFkaXVzO1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgMV0gPSB5ICsgTWF0aC5zaW4oYW5nbGUpICogcmFkaXVzO1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgMl0gPSAwOyAvLyB6XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltpZHggKyAzXSA9IC1NYXRoLmNvcyhhbmdsZSkgKiBzcGVlZDsgLy8gdnhcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2lkeCArIDRdID0gLU1hdGguc2luKGFuZ2xlKSAqIHNwZWVkOyAvLyB2eVxuICAgICAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgNV0gPSAwOyAvLyB2elxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3VwbG9hZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RhcnQgQ0VOVEVSLCBtb3ZlIFVQIChaLWF4aXMpXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltpZHhdICAgICA9IHggKyAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAyMCAqIHM7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltpZHggKyAxXSA9IHkgKyAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAyMCAqIHM7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltpZHggKyAyXSA9IDA7IC8vIHpcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2lkeCArIDNdID0gMDsgLy8gdnhcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2lkeCArIDRdID0gMDsgLy8gdnlcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2lkeCArIDVdID0gLXNwZWVkICogMS41OyAvLyB2eiAoVXB3YXJkcyBpbiAzRCBzcGFjZSBpcyBuZWdhdGl2ZSBaIGluIG91ciBwcm9qZWN0aW9uIHVzdWFsbHksIG9yIGhhbmRsZSBpbiByZW5kZXIpXG4gICAgICAgICAgICAgICAgICAgIC8vIExldCdzIGFzc3VtZSBuZWdhdGl2ZSBaIGlzICd1cC9hd2F5JyBvciBqdXN0IHVzZSBZIGZvciAndXAnLlxuICAgICAgICAgICAgICAgICAgICAvLyBBY3R1YWxseSwgJ1VwJyBpbiAzRCB3b3JsZCBzcGFjZSAoaWYgWSBpcyBkb3duKSBpcyBuZWdhdGl2ZSBZLlxuICAgICAgICAgICAgICAgICAgICAvLyBCdXQgaGVyZSB3ZSB3YW50IGEgJ0hvbG9ncmFwaGljIFVwbG9hZCcgZWZmZWN0LCB3aGljaCBpbXBsaWVzIFotYXhpcyBsaWZ0LlxuICAgICAgICAgICAgICAgICAgICAvLyBMZXQncyB0cnkgTmVnYXRpdmUgWiAodG93YXJkcyBjYW1lcmE/IG9yIGF3YXk/KS5cbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gZHJhd0hleCwgWiBpcyBkZXB0aC4gTG93ZXIgWiBpcyBjbG9zZXI/XG4gICAgICAgICAgICAgICAgICAgIC8vIExldCdzIG1ha2UgdGhlbSBmbG9hdCAndXAnIGluIFdvcmxkIFkgKC1ZKSBhbmQgJ291dCcgaW4gWiAoLVopLlxuICAgICAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgNF0gPSAtMSAqIHM7IC8vIFNsb3cgcmlzZSBZXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltpZHggKyA1XSA9IC01ICogczsgLy8gRmFzdCByaXNlIFogKHRvd2FyZHMgY2FtZXJhKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgZXhwbG9kZVxuICAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2lkeF0gICAgID0geDtcbiAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltpZHggKyAxXSA9IHk7XG4gICAgICAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgMl0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2lkeCArIDNdID0gTWF0aC5jb3MoYW5nbGUpICogc3BlZWQ7XG4gICAgICAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgNF0gPSBNYXRoLnNpbihhbmdsZSkgKiBzcGVlZDtcbiAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltpZHggKyA1XSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnVmZmVyW2lkeCArIDZdID0gMS4wOyAvLyBMaWZlXG4gICAgICAgICAgICAgICAgYnVmZmVyW2lkeCArIDddID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNCk7IC8vIENvbG9yIEluZGV4XG5cbiAgICAgICAgICAgICAgICBzcGF3bmVkKys7XG4gICAgICAgICAgICAgICAgaWYgKHNwYXduZWQgPj0gY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFpbiBSZW5kZXIgTG9vcC5cbiAgICAgKiBVcGRhdGVzIHBoeXNpY3MsIHByb2plY3RzIGdlb21ldHJ5LCBhbmQgZHJhd3MgYWxsIGxheWVycy5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5jYW5SZW5kZXIpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIGN0eCAgICA9IG1lLmNvbnRleHQsXG4gICAgICAgICAgICB3aWR0aCAgPSBtZS5jYW52YXNTaXplPy53aWR0aCB8fCAxMDAsXG4gICAgICAgICAgICBoZWlnaHQgPSBtZS5jYW52YXNTaXplPy5oZWlnaHQgfHwgNTA7XG5cbiAgICAgICAgbWUudGltZSArPSAwLjAxO1xuXG4gICAgICAgIGlmICghbWUuY2VsbEJ1ZmZlcikge1xuICAgICAgICAgICAgbWUuaW5pdE5vZGVzKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbWUua2VybmVsQnVmZmVyKSB7XG4gICAgICAgICAgICBtZS5pbml0S2VybmVsKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbWUuc3RyYXRhQnVmZmVyKSB7XG4gICAgICAgICAgICBtZS5pbml0U3RyYXRhKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbWUucnVubmVyQnVmZmVyKSB7XG4gICAgICAgICAgICBtZS5pbml0UnVubmVycyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1lLnBhcnRpY2xlQnVmZmVyKSB7XG4gICAgICAgICAgICBtZS5pbml0UGFydGljbGVzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBtZS51cGRhdGVQaHlzaWNzKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBtZS51cGRhdGVSb3RhdGlvbih3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgbWUudXBkYXRlU3VwZXJIZXhlcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgbWUudXBkYXRlUnVubmVycyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgbWUudXBkYXRlUGFydGljbGVzKCk7XG4gICAgICAgIG1lLnVwZGF0ZVByb2plY3Rpb24od2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICBpZiAobWUuZ3JhZGllbnRzLmJnR3JhZGllbnQpIHtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBtZS5ncmFkaWVudHMuYmdHcmFkaWVudDtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KVxuICAgICAgICB9XG5cbiAgICAgICAgbWUuZHJhd0tlcm5lbChjdHgsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBtZS5kcmF3U3RyYXRhKGN0eCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIG1lLmRyYXdHcmFwaChjdHgsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBtZS5kcmF3UnVubmVycyhjdHgpO1xuICAgICAgICBtZS5kcmF3UGFydGljbGVzKGN0eCk7IC8vIFJlbmRlciBwYXJ0aWNsZXMgb24gdG9wXG5cbiAgICAgICAgaWYgKGhhc1JhZikge1xuICAgICAgICAgICAgbWUuYW5pbWF0aW9uSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobWUucmVuZGVyTG9vcClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLmFuaW1hdGlvbklkID0gc2V0VGltZW91dChtZS5yZW5kZXJMb29wLCAxMDAwIC8gNjApXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHBhcnRpY2xlIHBoeXNpY3MgKG1vdmVtZW50LCBkZWNheSkuXG4gICAgICovXG4gICAgdXBkYXRlUGFydGljbGVzKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuICAgICAgICBpZiAoIW1lLnBhcnRpY2xlQnVmZmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBidWZmZXIgPSBtZS5wYXJ0aWNsZUJ1ZmZlcixcbiAgICAgICAgICAgICAgY291bnQgID0gUEFSVElDTEVfQ09VTlQ7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaWR4ID0gaSAqIFBBUlRJQ0xFX1NUUklERTtcbiAgICAgICAgICAgIGlmIChidWZmZXJbaWR4ICsgNl0gPiAwKSB7IC8vIENoZWNrIGxpZmVcbiAgICAgICAgICAgICAgICAvLyBNb3ZlIHgsIHksIHogYnkgdngsIHZ5LCB2elxuICAgICAgICAgICAgICAgIGJ1ZmZlcltpZHhdICAgICArPSBidWZmZXJbaWR4ICsgM107XG4gICAgICAgICAgICAgICAgYnVmZmVyW2lkeCArIDFdICs9IGJ1ZmZlcltpZHggKyA0XTtcbiAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgMl0gKz0gYnVmZmVyW2lkeCArIDVdO1xuXG4gICAgICAgICAgICAgICAgLy8gRGVjYXkgbGlmZVxuICAgICAgICAgICAgICAgIGJ1ZmZlcltpZHggKyA2XSAtPSAwLjAzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFuYWdlcyB0aGUgbGlmZWN5Y2xlIG9mIFN1cGVyIEhleGVzLlxuICAgICAqIERldGVjdHMgaGlnaGx5IGNoYXJnZWQgY2VsbHMsIHRyaWdnZXJzIGltcGxvc2lvbnMgdG8gZm9ybSBTdXBlciBIZXhlcyxcbiAgICAgKiBhbmQgbWFuYWdlcyB0aGVpciBncm93dGggYW5kIGZpbmFsIGV4cGxvc2lvbi5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAgICovXG4gICAgdXBkYXRlU3VwZXJIZXhlcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG4gICAgICAgIGlmICghbWUuY2VsbEJ1ZmZlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lLnN1cGVySGV4ZXMubGVuZ3RoIDwgU1VQRVJfSEVYX01BWCkge1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gbWUuY2VsbEJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgIGNvdW50ICA9IGJ1ZmZlci5sZW5ndGggLyBTVFJJREU7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjA7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBpZHggICAgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjb3VudCkgKiBTVFJJREUsXG4gICAgICAgICAgICAgICAgICAgIGNoYXJnZSA9IGJ1ZmZlcltpZHggKyA2XTtcblxuICAgICAgICAgICAgICAgIGlmIChjaGFyZ2UgPiAzKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnN1cGVySGV4ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXJJZHg6IGlkeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFnZSAgICAgIDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlICAgIDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5laWdoYm9yczogbWUuZmluZE5laWdoYm9ycyhpZHgpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyaWdnZXIgSW1wbG9zaW9uIVxuICAgICAgICAgICAgICAgICAgICBsZXQgeCA9IGJ1ZmZlcltpZHggKyAyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBidWZmZXJbaWR4ICsgM107XG4gICAgICAgICAgICAgICAgICAgIG1lLnNwYXduUGFydGljbGVzKHgsIHksIDEyLCAnaW1wbG9kZScpO1xuXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltpZHggKyA2XSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSBtZS5zdXBlckhleGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgc2ggPSBtZS5zdXBlckhleGVzW2ldO1xuICAgICAgICAgICAgc2guYWdlKys7XG5cbiAgICAgICAgICAgIGlmIChzaC5zdGF0ZSA9PT0gMCAmJiBzaC5hZ2UgPiAzMCkge1xuICAgICAgICAgICAgICAgIHNoLnN0YXRlID0gMTtcbiAgICAgICAgICAgICAgICBzaC5hZ2UgICA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNoLnN0YXRlID09PSAxICYmIHNoLmFnZSA+IDEyMCkge1xuICAgICAgICAgICAgICAgIHNoLnN0YXRlID0gMjtcbiAgICAgICAgICAgICAgICBzaC5hZ2UgICA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNoLnN0YXRlID09PSAyICYmIHNoLmFnZSA+IDMwKSB7XG4gICAgICAgICAgICAgICAgLy8gRG9uZSAtIFRyaWdnZXIgVXBsb2FkXG4gICAgICAgICAgICAgICAgbGV0IGlkeCA9IHNoLmNlbnRlcklkeCxcbiAgICAgICAgICAgICAgICAgICAgeCAgID0gbWUuY2VsbEJ1ZmZlcltpZHggKyAyXSxcbiAgICAgICAgICAgICAgICAgICAgeSAgID0gbWUuY2VsbEJ1ZmZlcltpZHggKyAzXTtcblxuICAgICAgICAgICAgICAgIG1lLnNwYXduUGFydGljbGVzKHgsIHksIDEyLCAndXBsb2FkJyk7XG5cbiAgICAgICAgICAgICAgICBzaC5uZWlnaGJvcnMuZm9yRWFjaChuSWR4ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbWUuY2VsbEJ1ZmZlcltuSWR4ICsgNF0gPSAxO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG1lLnN1cGVySGV4ZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgdGFyZ2V0U2NhbGUgPSAxO1xuICAgICAgICAgICAgaWYgKHNoLnN0YXRlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0U2NhbGUgPSAxIC0gKHNoLmFnZSAvIDMwKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2guc3RhdGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRTY2FsZSA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldFNjYWxlID0gc2guYWdlIC8gMzA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNoLm5laWdoYm9ycy5mb3JFYWNoKG5JZHggPT4ge1xuICAgICAgICAgICAgICAgIG1lLmNlbGxCdWZmZXJbbklkeCArIDRdID0gdGFyZ2V0U2NhbGU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmRzIGltbWVkaWF0ZSBuZWlnaGJvcnMgZm9yIFN1cGVyIEhleCBmb3JtYXRpb24uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNlbnRlcklkeFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJbXX0gQXJyYXkgb2YgbmVpZ2hib3IgaW5kaWNlc1xuICAgICAqL1xuICAgIGZpbmROZWlnaGJvcnMoY2VudGVySWR4KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgYnVmZmVyICAgID0gbWUuY2VsbEJ1ZmZlcixcbiAgICAgICAgICAgIGN4ICAgICAgICA9IGJ1ZmZlcltjZW50ZXJJZHggKyAyXSxcbiAgICAgICAgICAgIGN5ICAgICAgICA9IGJ1ZmZlcltjZW50ZXJJZHggKyAzXSxcbiAgICAgICAgICAgIG5laWdoYm9ycyA9IFtjZW50ZXJJZHhdLFxuICAgICAgICAgICAgY291bnQgICAgID0gYnVmZmVyLmxlbmd0aCAvIFNUUklERSxcbiAgICAgICAgICAgIHMgICAgICAgICA9IG1lLnNjYWxlLFxuICAgICAgICAgICAgcmFkaXVzICAgID0gSEVYX1NJWkUgKiBzICogMi4xO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkeCA9IGkgKiBTVFJJREU7XG4gICAgICAgICAgICBpZiAoaWR4ID09PSBjZW50ZXJJZHgpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHggICAgPSBidWZmZXJbaWR4ICsgMl0sXG4gICAgICAgICAgICAgICAgeSAgICA9IGJ1ZmZlcltpZHggKyAzXSxcbiAgICAgICAgICAgICAgICBkaXN0ID0gTWF0aC5zcXJ0KCh4IC0gY3gpICoqIDIgKyAoeSAtIGN5KSAqKiAyKTtcblxuICAgICAgICAgICAgaWYgKGRpc3QgPCByYWRpdXMpIHtcbiAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChpZHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZWlnaGJvcnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBpbnRlcmFjdGlvbiBwaHlzaWNzIGZvciB0aGUgbWFpbiBsYXR0aWNlLlxuICAgICAqIEhhbmRsZXMgbW91c2UgaG92ZXIgZW5lcmd5IHRyYW5zZmVyIGFuZCBkZWNheS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAgICovXG4gICAgdXBkYXRlUGh5c2ljcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG4gICAgICAgIGlmICghbWUuY2VsbEJ1ZmZlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIGJ1ZmZlciA9IG1lLmNlbGxCdWZmZXIsXG4gICAgICAgICAgICBjb3VudCAgPSBidWZmZXIubGVuZ3RoIC8gU1RSSURFLFxuICAgICAgICAgICAgbXggICAgID0gbWUubW91c2UueCxcbiAgICAgICAgICAgIG15ICAgICA9IG1lLm1vdXNlLnksXG4gICAgICAgICAgICBzICAgICAgPSBtZS5zY2FsZTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpZHggICAgPSBpICogU1RSSURFLFxuICAgICAgICAgICAgICAgIHggICAgICA9IGJ1ZmZlcltpZHggKyAyXSxcbiAgICAgICAgICAgICAgICB5ICAgICAgPSBidWZmZXJbaWR4ICsgM10sXG4gICAgICAgICAgICAgICAgYWN0aXZlID0gMDtcblxuICAgICAgICAgICAgaWYgKG14ICE9PSAtMTAwMCkge1xuICAgICAgICAgICAgICAgIGxldCBkeCAgICAgPSB4IC0gbXgsXG4gICAgICAgICAgICAgICAgICAgIGR5ICAgICA9IHkgLSBteSxcbiAgICAgICAgICAgICAgICAgICAgZGlzdFNxID0gZHggKiBkeCArIGR5ICogZHksXG4gICAgICAgICAgICAgICAgICAgIHJhZGl1cyA9IDI1MCAqIHM7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGlzdFNxIDwgcmFkaXVzICogcmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkaXN0ID0gTWF0aC5zcXJ0KGRpc3RTcSk7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZSAgID0gKHJhZGl1cyAtIGRpc3QpIC8gcmFkaXVzO1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmUgICA9IE1hdGgucG93KGFjdGl2ZSwgMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgY3VycmVudEVuZXJneSA9IGJ1ZmZlcltpZHggKyA1XTtcbiAgICAgICAgICAgIGxldCB0YXJnZXRFbmVyZ3kgID0gYWN0aXZlICogMC44O1xuXG4gICAgICAgICAgICAvLyBTcGVlZCB1cCBob3ZlciByZWFjdGlvbiAoMC4xIC0+IDAuMylcbiAgICAgICAgICAgIGlmIChjdXJyZW50RW5lcmd5ID4gdGFyZ2V0RW5lcmd5KSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyW2lkeCArIDVdICo9IDAuOTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyW2lkeCArIDVdICs9ICh0YXJnZXRFbmVyZ3kgLSBjdXJyZW50RW5lcmd5KSAqIDAuMztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGJ1ZmZlcltpZHggKyA1XSA8IDAuMDAxKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyW2lkeCArIDVdID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGJ1ZmZlcltpZHggKyA2XSA+IDApIHtcbiAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgNl0gLT0gMC4wNTtcbiAgICAgICAgICAgICAgICBpZiAoYnVmZmVyW2lkeCArIDZdIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgNl0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgTmV1cmFsIEFnZW50IGxvZ2ljIChUaGUgXCJJbnRlbGxpZ2VuY2VcIiBMYXllcikuXG4gICAgICpcbiAgICAgKiBJbXBsZW1lbnRzIGEgMi1TdGF0ZSBNYWNoaW5lIGZvciBBZ2VudHM6XG4gICAgICpcbiAgICAgKiAqKlN0YXRlIDA6IE1vdmluZyoqXG4gICAgICogLSBBZ2VudHMgdHJhdmVsIGFsb25nIGdyaWQgZWRnZXMgdG8gYSB0YXJnZXQgbm9kZS5cbiAgICAgKiAtIFVzZXMgXCJNYWduZXRpYyBQYXRoZmluZGluZ1wiIHRvIGJpYXMgbW92ZW1lbnQgdG93YXJkcyB0aGUgbW91c2UgY3Vyc29yLlxuICAgICAqIC0gVXBvbiBhcnJpdmFsLCB0aGVyZSBpcyBhICoqMjAlIGNoYW5jZSoqIHRvIHN3aXRjaCB0byBcIlNjYW5uaW5nXCIuXG4gICAgICpcbiAgICAgKiAqKlN0YXRlIDE6IFNjYW5uaW5nKipcbiAgICAgKiAtIFRoZSBBZ2VudCBsb2NrcyBvbnRvIGEgbm9kZSBhbmQgcGVyZm9ybXMgYSBcIkRlZXAgU2NhblwiICh2aXN1YWxpemVkIGFzIGEgcHVsc2UpLlxuICAgICAqIC0gKipDb25zdHJ1Y3Rpb24gVHJpZ2dlcjoqKiBXaGVuIHRoZSBzY2FuIGNvbXBsZXRlcywgdGhlIEFnZW50IGluamVjdHMgbWFzc2l2ZSBgQnVpbGRDaGFyZ2VgICgrNSlcbiAgICAgKiAgIGludG8gdGhlIG5vZGUuIFRoaXMgZGV0ZXJtaW5pc3RpY2FsbHkgdHJpZ2dlcnMgdGhlIGZvcm1hdGlvbiBvZiBhICoqU3VwZXIgSGV4KiosIGNyZWF0aW5nXG4gICAgICogICBhIGRpcmVjdCBjYXVzZS1hbmQtZWZmZWN0IHJlbGF0aW9uc2hpcCBiZXR3ZWVuIFwiQWdlbnQgV29ya1wiIGFuZCBcIlN0cnVjdHVyZSBDcmVhdGlvblwiLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqL1xuICAgIHVwZGF0ZVJ1bm5lcnMod2lkdGgsIGhlaWdodCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuICAgICAgICBpZiAoIW1lLnJ1bm5lckJ1ZmZlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIHJ1bm5lcnMgPSBtZS5ydW5uZXJCdWZmZXIsXG4gICAgICAgICAgICBub2RlcyAgID0gbWUuY2VsbEJ1ZmZlcixcbiAgICAgICAgICAgIGNvdW50ICAgPSBSVU5ORVJfQ09VTlQsXG4gICAgICAgICAgICBzICAgICAgID0gbWUuc2NhbGU7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaWR4ICAgICAgPSBpICogUlVOTkVSX1NUUklERSxcbiAgICAgICAgICAgICAgICBzdGF0ZSAgICA9IHJ1bm5lcnNbaWR4ICsgOF07XG5cbiAgICAgICAgICAgIC8vIFNUQVRFIDA6IE1PVklOR1xuICAgICAgICAgICAgaWYgKHN0YXRlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByb2dyZXNzID0gcnVubmVyc1tpZHggKyA0XSxcbiAgICAgICAgICAgICAgICAgICAgc3BlZWQgICAgPSBydW5uZXJzW2lkeCArIDVdO1xuXG4gICAgICAgICAgICAgICAgaWYgKHByb2dyZXNzIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeCAgPSBydW5uZXJzW2lkeF0sXG4gICAgICAgICAgICAgICAgICAgICAgICB5ICA9IHJ1bm5lcnNbaWR4ICsgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0eCA9IHJ1bm5lcnNbaWR4ICsgMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0eSA9IHJ1bm5lcnNbaWR4ICsgM107XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGR4ICAgPSB0eCAtIHgsXG4gICAgICAgICAgICAgICAgICAgICAgICBkeSAgID0gdHkgLSB5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzdCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3QgPCBzcGVlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVubmVyc1tpZHhdICAgICA9IHR4O1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVubmVyc1tpZHggKyAxXSA9IHR5O1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVubmVyc1tpZHggKyA0XSA9IDE7IC8vIEFycml2ZWRcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVjaXNpb24gUG9pbnQ6IFNjYW4gb3IgTW92ZT9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDIwJSBDaGFuY2UgdG8gU2NhbiwgYnV0IG9ubHkgaWYgb24gYSB2YWxpZCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZUlkeCA9IG1lLmZpbmROZWFyZXN0Tm9kZSh0eCwgdHkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZUlkeCAhPT0gLTEgJiYgTWF0aC5yYW5kb20oKSA+IDAuOCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5lcnNbaWR4ICsgOF0gPSAxOyAvLyBTd2l0Y2ggdG8gU2Nhbm5pbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydW5uZXJzW2lkeCArIDldID0gMDsgLy8gUmVzZXQgU2NhbiBUaW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVubmVyc1tpZHggKyA2XSA9IG5vZGVJZHg7IC8vIExvY2sgdG8gbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBKdXN0IHBhc3NpbmcgdGhyb3VnaCAtIFN0YW5kYXJkIEVuZXJneSBCb29zdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlSWR4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlc1tub2RlSWR4ICsgNV0gPSAxLjA7IC8vIEZsYXNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzW25vZGVJZHggKyA2XSArPSAwLjU7IC8vIFNtYWxsIGNvbnRyaWJ1dGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlc1tub2RlSWR4ICsgN10gPSBydW5uZXJzW2lkeCArIDddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydW5uZXJzW2lkeCArIDZdICAgPSBub2RlSWR4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5lcnNbaWR4XSAgICAgKz0gKGR4IC8gZGlzdCkgKiBzcGVlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5lcnNbaWR4ICsgMV0gKz0gKGR5IC8gZGlzdCkgKiBzcGVlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBpY2sgTmV4dCBUYXJnZXRcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRIZXhJZHggPSBydW5uZXJzW2lkeCArIDZdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SGV4SWR4ICE9PSB1bmRlZmluZWQgJiYgY3VycmVudEhleElkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hZ25ldGljIExvZ2ljOiBCaWFzIGRpcmVjdGlvbiB0b3dhcmRzIG1vdXNlXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYmVzdERpciAgID0gLTEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdFNjb3JlID0gLUluZmluaXR5O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgd2VpZ2h0cyA9IFsxLCAxLCAxLCAxLCAxLCAxXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lLm1vdXNlLnggIT09IC0xMDAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGN4ID0gcnVubmVyc1tpZHhdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeSA9IHJ1bm5lcnNbaWR4ICsgMV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IDY7IGQrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGVnICA9IDMwICsgKGQgKiA2MCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWQgID0gZGVnICogTWF0aC5QSSAvIDE4MCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGp1bXAgPSBIRVhfU0laRSAqIHMgKiBNYXRoLnNxcnQoMyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eCAgID0gY3ggKyBNYXRoLmNvcyhyYWQpICoganVtcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5ICAgPSBjeSArIE1hdGguc2luKHJhZCkgKiBqdW1wO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkaXN0U3EgPSAodHggLSBtZS5tb3VzZS54KSAqKiAyICsgKHR5IC0gbWUubW91c2UueSkgKiogMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0c1tkXSArPSAoMTAwMDAwIC8gKGRpc3RTcSArIDEwMCkpICogNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0b3RhbFdlaWdodCA9IHdlaWdodHMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZG9tICAgICAgPSBNYXRoLnJhbmRvbSgpICogdG90YWxXZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VtICAgICAgICAgPSAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpciAgICAgICAgID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCA2OyBkKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdW0gKz0gd2VpZ2h0c1tkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmFuZG9tIDw9IHN1bSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXIgPSBkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkZWcgID0gMzAgKyAoZGlyICogNjApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhZCAgPSBkZWcgKiBNYXRoLlBJIC8gMTgwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGp1bXAgPSBIRVhfU0laRSAqIHMgKiBNYXRoLnNxcnQoMyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3ggICA9IHJ1bm5lcnNbaWR4XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeSAgID0gcnVubmVyc1tpZHggKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eCAgID0gY3ggKyBNYXRoLmNvcyhyYWQpICoganVtcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eSAgID0gY3kgKyBNYXRoLnNpbihyYWQpICoganVtcDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4IDwgLTUwIHx8IHR4ID4gd2lkdGggKyA1MCB8fCB0eSA8IC01MDAgfHwgdHkgPiBoZWlnaHQgKyA1MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLnJlc2V0UnVubmVyKGksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBydW5uZXJzW2lkeCArIDJdID0gdHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBydW5uZXJzW2lkeCArIDNdID0gdHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBydW5uZXJzW2lkeCArIDRdID0gMDsgLy8gUmVzZXQgcHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLnJlc2V0UnVubmVyKGksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU1RBVEUgMTogU0NBTk5JTkdcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXRlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gSW5jcmVtZW50IFNjYW4gVGltZVxuICAgICAgICAgICAgICAgIHJ1bm5lcnNbaWR4ICsgOV0gKz0gMC4wMjsgLy8gU2NhbiBzcGVlZFxuXG4gICAgICAgICAgICAgICAgLy8gVmlzdWFsIEVmZmVjdCBvbiBOb2RlIChQdWxzZSlcbiAgICAgICAgICAgICAgICBsZXQgbm9kZUlkeCA9IHJ1bm5lcnNbaWR4ICsgNl07XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVJZHggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICBub2Rlc1tub2RlSWR4ICsgNV0gPSAwLjUgKyAoTWF0aC5zaW4ocnVubmVyc1tpZHggKyA5XSAqIDEwKSAqIDAuNSk7IC8vIFB1bHNlIEVuZXJneVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFNjYW4gQ29tcGxldGU/XG4gICAgICAgICAgICAgICAgaWYgKHJ1bm5lcnNbaWR4ICsgOV0gPj0gMSkge1xuICAgICAgICAgICAgICAgICAgICBydW5uZXJzW2lkeCArIDhdID0gMDsgLy8gUmVzdW1lIE1vdmluZ1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRIRSBQQVlPRkY6IE1hc3NpdmUgQnVpbGRDaGFyZ2UgaW5qZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlSWR4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXNbbm9kZUlkeCArIDZdICs9IDU7IC8vIEluc3RhbnQgU3VwZXIgSGV4IFRyaWdnZXIgKD4zKVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXNbbm9kZUlkeCArIDVdID0gMS4wOyAvLyBNYXggRW5lcmd5XG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlc1tub2RlSWR4ICsgN10gPSBydW5uZXJzW2lkeCArIDddOyAvLyBDb2xvclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBjYW1lcmEgcm90YXRpb24gYmFzZWQgb24gbW91c2UgcG9zaXRpb24uXG4gICAgICogQ3JlYXRlcyBhIFwiRmxvb3IgUGVyc3BlY3RpdmVcIiB0aWx0IGVmZmVjdC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAgICovXG4gICAgdXBkYXRlUm90YXRpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgbXggPSBtZS5tb3VzZS54LFxuICAgICAgICAgICAgbXkgPSBtZS5tb3VzZS55LFxuICAgICAgICAgICAgdHggPSAtMC40LCAvLyBCYXNlIHRpbHQgWCAocGl0Y2gpXG4gICAgICAgICAgICB0eSA9IDA7ICAgLy8gQmFzZSB5YXdcblxuICAgICAgICBpZiAobXggIT09IC0xMDAwKSB7XG4gICAgICAgICAgICAvLyBNYXAgbW91c2UgWCB0byBZYXcgKCsvLSAwLjIgcmFkKVxuICAgICAgICAgICAgdHkgPSAoKG14IC8gd2lkdGgpIC0gMC41KSAqIDAuNDtcbiAgICAgICAgICAgIC8vIE1hcCBtb3VzZSBZIHRvIFBpdGNoICgtMC42IHRvIC0wLjIgcmFkKVxuICAgICAgICAgICAgdHggPSAtMC40ICsgKChteSAvIGhlaWdodCkgLSAwLjUpICogMC40O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU21vb3RoIGludGVycG9sYXRlXG4gICAgICAgIG1lLnJvdGF0aW9uLnggKz0gKHR4IC0gbWUucm90YXRpb24ueCkgKiAwLjA1O1xuICAgICAgICBtZS5yb3RhdGlvbi55ICs9ICh0eSAtIG1lLnJvdGF0aW9uLnkpICogMC4wNTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBwcm9qZWN0aW9uIG1hdHJpeCBiYXNlZCBvbiBjdXJyZW50IHJvdGF0aW9uIGFuZCBzaXplLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgKi9cbiAgICB1cGRhdGVQcm9qZWN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIHBtID0gbWUucHJvamVjdGlvbk1hdHJpeDtcblxuICAgICAgICBwbS5jeCAgID0gd2lkdGggLyAyO1xuICAgICAgICBwbS5jeSAgID0gaGVpZ2h0IC8gMjtcbiAgICAgICAgcG0uY29zWCA9IE1hdGguY29zKG1lLnJvdGF0aW9uLngpO1xuICAgICAgICBwbS5zaW5YID0gTWF0aC5zaW4obWUucm90YXRpb24ueCk7XG4gICAgICAgIHBtLmNvc1kgPSBNYXRoLmNvcyhtZS5yb3RhdGlvbi55KTtcbiAgICAgICAgcG0uc2luWSA9IE1hdGguc2luKG1lLnJvdGF0aW9uLnkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2plY3RzIGEgM0QgcG9pbnQgdG8gMkQgc2NyZWVuIHNwYWNlIHVzaW5nIHRoZSBjYWNoZWQgbWF0cml4LlxuICAgICAqIHdyaXRlcyByZXN1bHQgdG8gdGhpcy5wcm9qZWN0aW9uUG9pbnQgdG8gYXZvaWQgYWxsb2NhdGlvbi5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0aGlzLnByb2plY3Rpb25Qb2ludFxuICAgICAqL1xuICAgIHByb2plY3QoeCwgeSwgeikge1xuICAgICAgICBsZXQgbWUgID0gdGhpcyxcbiAgICAgICAgICAgIHBtICA9IG1lLnByb2plY3Rpb25NYXRyaXgsXG4gICAgICAgICAgICBwcCAgPSBtZS5wcm9qZWN0aW9uUG9pbnQsXG4gICAgICAgICAgICBmb3YgPSAxMDAwLFxuICAgICAgICAgICAgZHggID0geCAtIHBtLmN4LFxuICAgICAgICAgICAgZHkgID0geSAtIHBtLmN5LFxuICAgICAgICAgICAgZHogID0gejtcblxuICAgICAgICAvLyBSb3RhdGUgWVxuICAgICAgICBsZXQgeDEgPSBkeCAqIHBtLmNvc1kgLSBkeiAqIHBtLnNpblk7XG4gICAgICAgIGxldCB6MSA9IGR6ICogcG0uY29zWSArIGR4ICogcG0uc2luWTtcblxuICAgICAgICAvLyBSb3RhdGUgWFxuICAgICAgICBsZXQgeTIgPSBkeSAqIHBtLmNvc1ggLSB6MSAqIHBtLnNpblg7XG4gICAgICAgIGxldCB6MiA9IHoxICogcG0uY29zWCArIGR5ICogcG0uc2luWDtcblxuICAgICAgICAvLyBQcm9qZWN0XG4gICAgICAgIGxldCBzY2FsZSA9IGZvdiAvIChmb3YgKyB6Mik7XG5cbiAgICAgICAgcHAueCAgICAgICA9IHgxICogc2NhbGUgKyBwbS5jeDtcbiAgICAgICAgcHAueSAgICAgICA9IHkyICogc2NhbGUgKyBwbS5jeTtcbiAgICAgICAgcHAuc2NhbGUgICA9IHNjYWxlO1xuICAgICAgICBwcC52aXNpYmxlID0gejIgPiAtZm92OyAvLyBDbGlwIGlmIGJlaGluZCBjYW1lcmFcblxuICAgICAgICByZXR1cm4gcHA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbmQgY2FjaGVzIGdyYWRpZW50cy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAgICovXG4gICAgdXBkYXRlUmVzb3VyY2VzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgbGV0IG1lICA9IHRoaXMsXG4gICAgICAgICAgICBjdHggPSBtZS5jb250ZXh0O1xuXG4gICAgICAgIGlmICghY3R4KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdFxuICAgICAgICAgICAgdGhlbWVDb2xvcnMgPSBtZS5jb25zdHJ1Y3Rvci5jb2xvcnNbbWUudGhlbWVdLFxuICAgICAgICAgICAgZ3JhZGllbnQgICAgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsIHRoZW1lQ29sb3JzLmJhY2tncm91bmRbMF0pO1xuICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgdGhlbWVDb2xvcnMuYmFja2dyb3VuZFsxXSk7XG5cbiAgICAgICAgbWUuZ3JhZGllbnRzLmJnR3JhZGllbnQgPSBncmFkaWVudFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgY2FudmFzIHJlc2l6ZS5cbiAgICAgKiBSZS1jYWxjdWxhdGVzIHNjYWxlIGFuZCByZS1pbml0aWFsaXplcyBidWZmZXJzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzaXplXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNpemUuaGVpZ2h0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNpemUud2lkdGhcbiAgICAgKi9cbiAgICB1cGRhdGVTaXplKHNpemUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXM7XG4gICAgICAgIG1lLmNhbnZhc1NpemUgPSBzaXplO1xuICAgICAgICBtZS5zY2FsZSAgICAgID0gTWF0aC5zcXJ0KChzaXplLndpZHRoICogc2l6ZS5oZWlnaHQpIC8gMjA3MzYwMCk7XG5cbiAgICAgICAgaWYgKG1lLmNvbnRleHQpIHtcbiAgICAgICAgICAgIG1lLmNvbnRleHQuY2FudmFzLndpZHRoICA9IHNpemUud2lkdGg7XG4gICAgICAgICAgICBtZS5jb250ZXh0LmNhbnZhcy5oZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgICAgICAgICAgIG1lLmNlbGxCdWZmZXIgICAgICAgICAgICA9IG51bGw7XG4gICAgICAgICAgICBtZS5ydW5uZXJCdWZmZXIgICAgICAgICAgPSBudWxsO1xuICAgICAgICAgICAgbWUua2VybmVsQnVmZmVyICAgICAgICAgID0gbnVsbDtcbiAgICAgICAgICAgIG1lLnN0cmF0YUJ1ZmZlciAgICAgICAgICA9IG51bGw7XG4gICAgICAgICAgICBtZS5kZWJyaXNCdWZmZXIgICAgICAgICAgPSBudWxsO1xuICAgICAgICAgICAgbWUuaW5pdE5vZGVzKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcbiAgICAgICAgICAgIG1lLnVwZGF0ZVJlc291cmNlcyhzaXplLndpZHRoLCBzaXplLmhlaWdodClcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoU2VydmljZXNDYW52YXMpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==