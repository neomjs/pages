export const __webpack_esm_id__ = "vendors-src_draggable_container_SortZone_mjs";
export const __webpack_esm_ids__ = ["vendors-src_draggable_container_SortZone_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./src/draggable/container/DragZone.mjs"
/*!**********************************************!*\
  !*** ./src/draggable/container/DragZone.mjs ***!
  \**********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _draggable_DragZone_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../draggable/DragZone.mjs */ "./src/draggable/DragZone.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");




/**
 * @class Neo.draggable.container.DragZone
 * @extends Neo.draggable.DragZone
 */
class DragZone extends _draggable_DragZone_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.draggable.container.DragZone'
         * @protected
         */
        className: 'Neo.draggable.container.DragZone',
        /**
         * @member {String} ntype='container-dragzone'
         * @protected
         */
        ntype: 'container-dragzone'
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me      = this,
            {owner} = me,
            opts    = {delegate: '.neo-draggable', scope: me};

        owner.addDomListeners([
            {'drag:end'  : me.onDragEnd,   ...opts},
            {'drag:move' : me.onDragMove,  ...opts},
            {'drag:start': me.onDragStart, ...opts}
        ]);

        owner.on({
            insert      : me.onItemInsert,
            itemsCreated: me.onItemsCreated,
            scope       : me
        });

        // The container items can already be created
        me.adjustItemCls(true);
    }

    /**
     * @param {Boolean} draggable
     */
    adjustItemCls(draggable) {
        let me      = this,
            {owner} = me,
            wrapperCls;

        owner.items.forEach(item => {
            // spacers
            if (typeof item === 'string') {
                return;
            }

            wrapperCls = item.wrapperCls || [];

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].toggle(wrapperCls, 'neo-draggable', draggable);
            item.wrapperCls = wrapperCls;
        });
    }

    /**
     * @param {Object} data
     */
    onDragEnd(data) {
        if (this.owner.draggable) {
            let me           = this,
                proxy        = me.dragProxy,
                cls          = proxy.cls || {},
                rect         = me.dragElementRect,
                wrapperStyle = proxy.wrapperStyle || {};

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-animate');
            proxy.cls = cls;

            // ensure to get into the next animation frame
            me.timeout(30).then(() => {
                wrapperStyle.left = `${rect.left}px`;
                wrapperStyle.top  = `${rect.top}px`;

                proxy.wrapperStyle = wrapperStyle;

                me.timeout(100).then(() => {
                    me.dragEnd();
                });
            });
        }
    }

    /**
     * @param {Object} data
     */
    async onDragStart(data) {
        let me = this;

        if (me.owner.draggable) {
            me.dragElement = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].find(me.owner.vdom, data.path[0].id).vdom;
            await me.dragStart(data);
        }
    }

    /**
     * @param {Object}             data
     * @param {Number}             data.index
     * @param {Neo.component.Base} data.item
     */
    onItemInsert(data) {
        let {item}     = data,
            wrapperCls = item.wrapperCls || [];

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(wrapperCls, 'neo-draggable');
        item.wrapperCls = wrapperCls;
    }

    /**
     * @param {Object}               data
     * @param {String}               data.id
     * @param {Neo.component.Base[]} data.items
     */
    onItemsCreated(data) {
        this.adjustItemCls(true);
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DragZone));


/***/ },

/***/ "./src/draggable/container/SortZone.mjs"
/*!**********************************************!*\
  !*** ./src/draggable/container/SortZone.mjs ***!
  \**********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _DragZone_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DragZone.mjs */ "./src/draggable/container/DragZone.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/Rectangle.mjs */ "./src/util/Rectangle.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");





/**
 * @summary Manages the drag-and-drop reordering of items within a container, with support for window detachment.
 *
 * This class extends `Neo.draggable.container.DragZone` to provide sorting capabilities for `Neo.container.Base` instances.
 * It handles the complex logic of tracking item positions, swapping them during the drag operation, and updating
 * the container's layout upon drop.
 *
 * A key feature of this class is its support for **Window Detachment** (tearing tabs or items out of the main window).
 * When an item is dragged outside the browser window boundaries:
 * 1. The `startWindowDrag` method is triggered.
 * 2. The drag placeholder is hidden.
 * 3. The `calculateExpandedLayout` method dynamically computes a new layout for the remaining items, expanding them
 *    to fill the empty space (animating `width`, `height`, `top`, and `left`).
 * 4. If the drag re-enters the window (`onDragBoundaryEntry`), the original layout snapshot is restored, and the
 *    placeholder reappears, allowing for a seamless return to sorting mode.
 *
 * This class interacts closely with:
 * - `Neo.draggable.DragProxy`: For the visual representation of the dragged item.
 * - `Neo.main.addon.DragDrop`: For communicating drag state across the browser/OS environment.
 *
 * @class Neo.draggable.container.SortZone
 * @extends Neo.draggable.container.DragZone
 * @see Neo.draggable.container.DragZone
 * @see Neo.main.addon.DragDrop
 */
class SortZone extends _DragZone_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.draggable.container.SortZone'
         * @protected
         */
        className: 'Neo.draggable.container.SortZone',
        /**
         * @member {String} ntype='container-sortzone'
         * @protected
         */
        ntype: 'container-sortzone',
        /**
         * Depending on the parent structure using position absolute and relative, it can be needed to subtract
         * the x & y parent rect values from the item rects.
         * @member {Boolean} adjustItemRectsToParent=false
         */
        adjustItemRectsToParent: false,
        /**
         * @member {Boolean} alwaysFireDragMove=true
         */
        alwaysFireDragMove: true,
        /**
         * @member {Number} currentIndex=-1
         * @protected
         */
        currentIndex: -1,
        /**
         * The intersection ratio (0-1) required to detach an item into a new window.
         * Lower values mean the item must be dragged further out.
         * @member {Number} detachThreshold=0.8
         */
        detachThreshold: 0.8,
        /**
         * A CSS selector to identify the drag handle within a component.
         * If specified, the drag is initiated on this element, but the owning component is dragged.
         * @member {String|null} dragHandleSelector=null
         */
        dragHandleSelector: null,
        /**
         * @member {Boolean} enableProxyToPopup=false
         */
        enableProxyToPopup: false,
        /**
         * @member {Object} indexMap=null
         * @protected
         */
        indexMap: null,
        /**
         * @member {Array|null} itemRects=null
         * @protected
         */
        itemRects: null,
        /**
         * @member {Array|null} itemStyles=null
         * @protected
         */
        itemStyles: null,
        /**
         * @member {Number} lastIntersectionRatio=1
         * @protected
         */
        lastIntersectionRatio: 1,
        /**
         * @member {Object} ownerRect=null
         * @protected
         */
        ownerRect: null,
        /**
         * @member {Object} ownerStyle=null
         * @protected
         */
        ownerStyle: null,
        /**
         * The intersection ratio (0-1) required to re-attach a window-dragged item back into the container.
         * Higher values mean the item must be dragged further in.
         * @member {Number} reattachThreshold=0.6
         */
        reattachThreshold: 0.6,
        /**
         * @member {Boolean} alwaysFireDragMove=false
         * @protected
         */
        reversedLayoutDirection: false,
        /**
         * @member {Number} scrollLeft=0
         */
        scrollLeft: 0,
        /**
         * @member {Number} scrollTop=0
         */
        scrollTop: 0,
        /**
         * Internal flag: onDragStart() will set the value to horizontal or vertical, depending on the current layout.
         * @member {String} sortDirection='horizontal'
         * @protected
         */
        sortDirection: 'horizontal',
        /**
         * @member {Number} startIndex=-1
         * @protected
         */
        startIndex: -1
    }

    /**
     * @member {Boolean} isOverDragging=false
     * @protected
     */
    isOverDragging = false
    /**
     * @member {Boolean} isWindowDragging=false
     * @protected
     */
    isWindowDragging = false

    /**
     * Toggles the neo-draggable cls on items inside our owner.
     * @param {Boolean} draggable
     */
    adjustItemCls(draggable) {
        let me = this;

        if (me.dragHandleSelector) {
            const handleCls     = me.dragHandleSelector.startsWith('.') ? me.dragHandleSelector.substring(1) : me.dragHandleSelector;
            const sortableItems = me.owner.items.filter(item =>
                typeof item !== 'string' && _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].find(item.vdom, {cls: handleCls})
            );

            sortableItems.forEach(item => {
                const wrapperCls = item.wrapperCls || [];
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].toggle(wrapperCls, 'neo-draggable', draggable);
                item.wrapperCls = wrapperCls
            });
        } else {
            super.adjustItemCls(draggable)
        }
    }

    /**
     * @param {Object} data
     * @returns {Boolean} true if the method processing should stop
     */
    checkWindowBoundary(data) {
        let me = this,
            {proxyRect} = data;

        if (proxyRect && me.boundaryContainerRect) {
            const
                boundaryRect      = me.boundaryContainerRect,
                intersection      = _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getIntersection(proxyRect, boundaryRect),
                proxyArea         = proxyRect.width * proxyRect.height,
                intersectionArea  = intersection ? intersection.width * intersection.height : 0,
                intersectionRatio = proxyArea > 0 ? intersectionArea / proxyArea : 0,
                isMovingIn        = intersectionRatio > me.lastIntersectionRatio,
                isMovingOut       = intersectionRatio < me.lastIntersectionRatio;

            me.lastIntersectionRatio = intersectionRatio;

            if (!me.isWindowDragging) {
                if (isMovingOut && intersectionRatio < me.detachThreshold) {
                    me.isWindowDragging = true; // Set flag to prevent re-entry

                    me.fire('dragBoundaryExit', {
                        draggedItem: me.dragComponent,
                        proxyRect,
                        sortZone   : me
                    });
                    return true // Stop further processing in onDragMove
                }
            } else if (me.isWindowDragging) {
                if (isMovingIn && intersectionRatio > me.reattachThreshold) {
                    // Restore layout
                    me.dragPlaceholder.wrapperStyle = {
                        ...me.dragPlaceholder.wrapperStyle,
                        visibility: 'visible'
                    };

                    // Re-applying the current state:
                    me.itemRects.forEach((rect, index) => {
                        let mappedIndex = me.indexMap[index];
                        if (mappedIndex !== -1) {
                            let item = me.owner.items[mappedIndex];

                            if (item !== me.dragPlaceholder && item !== me.dragComponent) {
                                item.wrapperStyle = {
                                    ...item.wrapperStyle,
                                    height: `${rect.height}px`,
                                    left  : `${rect.left}px`,
                                    top   : `${rect.top}px`,
                                    width : `${rect.width}px`
                                }
                            }
                        }
                    });

                    me.fire('dragBoundaryEntry', {
                        draggedItem: me.dragComponent,
                        proxyRect,
                        sortZone   : me
                    })
                } else {
                    me.onWindowDragContinue(intersectionRatio, data)
                }
                return true
            }
        }

        return false
    }

    /**
     * Helper method, override as needed
     * @returns {Object}
     */
    getDragProxyConfig() {
        return {...this.dragProxyConfig, cls: [...this.owner.cls]}
    }

    /**
     * Override this method for class extensions (e.g. tab.header.Toolbar)
     * @param {Number} fromIndex
     * @param {Number} toIndex
     */
    moveTo(fromIndex, toIndex) {
        this.owner.moveTo(fromIndex, toIndex);
    }

    /**
     * Handles the completion of the drag operation.
     *
     * This method is responsible for:
     * 1.  **Finalizing the Drop:** If valid, it moves the DOM nodes to their final positions (via `Neo.applyDeltas`).
     * 2.  **Cleanup:** Removes the drag placeholder and resets internal state flags (`isWindowDragging`, `currentIndex`, etc.).
     * 3.  **Layout Restoration:** Resets the styles of all items (clearing the absolute positioning used during the drag)
     *     so they return to the container's natural layout flow.
     * 4.  **State Synchronization:** Calls `owner.moveTo()` to update the container's `items` array to reflect the new order.
     *
     * @param {Object} data - The drag end event data.
     */
    async onDragEnd(data) {
        let me                  = this,
            {itemStyles, owner} = me,
            ownerStyle          = owner.style || {},
            itemStyle;

        await me.timeout(10);

        if (owner.dragResortable) {
            if (me.dragPlaceholder) {
                const
                    component = me.dragComponent,
                    deltas    = [],
                    index     = me.sortableItems.indexOf(me.dragPlaceholder);

                if (component && index > -1) {
                    if (!me.isWindowDragging) {
                        // Only move DOM if not window dragging or if it's a remote drag being finalized locally
                        if (!me.isRemoteDragging || (me.isRemoteDragging && !me.isWindowDragging)) {
                             deltas.push({
                                action  : 'moveNode',
                                id      : component.id,
                                index,    // Visually correct index (where placeholder is)
                                parentId: owner.getVdomItemsRoot().id
                            })
                        }
                    }

                    deltas.push({
                        action: 'removeNode',
                        id    : me.dragPlaceholder.id
                    });

                    // Manual DOM restoration
                    await Neo.applyDeltas(me.windowId, deltas)
                }
            }

            ownerStyle.height   = me.ownerStyle.height    || null;
            ownerStyle.minWidth = me.ownerStyle.minWidth  || null;
            ownerStyle.width    = me.ownerStyle.width     || null;

            owner.style = ownerStyle;

            me.sortableItems?.forEach((item, index) => {
                if (me.isWindowDragging && item === me.dragComponent) {
                    return
                }

                itemStyle = item.wrapperStyle || {};

                Object.assign(itemStyle, {
                    height  : itemStyles[index].height || null,
                    left    : null,
                    margin  : null,
                    position: null,
                    top     : null,
                    width   : itemStyles[index].width || null
                });

                if (index === me.startIndex) {
                    itemStyle.visibility = null
                }

                item.wrapperStyle = itemStyle
            });

            // Restore visibility of the dragged component (it's not in sortableItems if placeholder is used)
            if (me.dragComponent) {
                let style = me.dragComponent.wrapperStyle || {};
                style.visibility = null;
                me.dragComponent.wrapperStyle = style;
            }

            if (!me.isWindowDragging && !me.isRemoteDragging && me.startIndex !== me.currentIndex) {
                let fromIndex, toIndex;

                if (me.dragPlaceholder) {
                    const component = me.dragComponent;
                    fromIndex = me.owner.items.indexOf(component);
                    toIndex   = me.owner.items.indexOf(me.sortableItems[me.currentIndex]);
                } else {
                    fromIndex = me.owner.items.indexOf(me.sortableItems[me.startIndex]);
                    toIndex   = me.owner.items.indexOf(me.sortableItems[me.currentIndex]);
                }

                me.moveTo(fromIndex, toIndex);
            }

            Object.assign(me, {
                currentIndex    : -1,
                indexMap        : null,
                isRemoteDragging: false,
                isWindowDragging: false,
                itemRects       : null,
                itemStyles      : null,
                ownerRect       : null,
                startIndex      : -1,
                sortableItems   : null
            });

            await me.timeout(30);

            me.dragEnd(data) // we do not want to trigger the super class call here
        }
    }

    /**
     * Handles the drag move event. This is the core logic loop for the drag operation.
     *
     * Responsibilities:
     * 1.  **Window Drag Re-entry:** Checks if a window drag has re-entered the original container boundaries.
     *     If so, it restores the original layout snapshot (`itemRects`) and shows the placeholder, effectively
     *     "snapping" the dashboard back to its sortable state.
     * 2.  **Window Drag Exit:** Detects if the drag proxy has left the container boundaries (if `enableProxyToPopup` is true)
     *     and triggers the `dragBoundaryExit` event to potentially start a window drag.
     * 3.  **Standard Sorting:** If not in window-drag mode, it calculates the drag delta and swaps items (`switchItems`)
     *     if the threshold is crossed, updating the `currentIndex`.
     * 4.  **Auto-Scrolling:** Manages auto-scrolling when dragging near the edges of the container.
     *
     * @param {Object} data The drag move event data.
     */
    async onDragMove(data) {
        let me = this;

        // The method can trigger before we got the client rects from the main thread
        if (!me.itemRects || me.isScrolling || !me.boundaryContainerRect) {
            return
        }

        // console.log('SortZone onDragMove', me.dragProxy);

        if (!me.isRemoteDragging && me.dragProxy && me.enableProxyToPopup) {
            if (me.checkWindowBoundary(data)) {
                return
            }
        }

        let {clientX, clientY} = data,
            index              = me.currentIndex,
            {itemRects}        = me,
            maxItems           = itemRects.length - 1,
            ownerX             = me.adjustItemRectsToParent ? me.ownerRect.x : 0,
            ownerY             = me.adjustItemRectsToParent ? me.ownerRect.y : 0,
            reversed           = me.reversedLayoutDirection,
            delta, isOverDragging, isOverDraggingEnd, isOverDraggingStart, itemHeightOrWidth, moveFactor;

        if (me.sortDirection === 'horizontal') {
            delta               = clientX - ownerX + me.scrollLeft - me.offsetX - itemRects[index].left;
            isOverDraggingEnd   = clientX > me.boundaryContainerRect.right;
            isOverDraggingStart = clientX < me.boundaryContainerRect.left;
            itemHeightOrWidth   = 'width'
        } else {
            delta               = clientY - ownerY + me.scrollTop - me.offsetY - itemRects[index].top;
            isOverDraggingEnd   = clientY > me.boundaryContainerRect.bottom;
            isOverDraggingStart = clientY < me.boundaryContainerRect.top;
            itemHeightOrWidth   = 'height'
        }

        isOverDragging = isOverDraggingEnd || isOverDraggingStart;
        moveFactor     = isOverDragging ? 0.02 : 0.55; // We can not use 0.5, since items would jump back & forth

        if (isOverDraggingStart) {
            if (index > 0) {
                me.currentIndex--;
                await me.scrollToIndex();
                me.switchItems(index, me.currentIndex)
            }
        }

        else if (isOverDraggingEnd) {
            if (index < maxItems) {
                me.currentIndex++;
                await me.scrollToIndex();
                me.switchItems(index, me.currentIndex)
            }
        }

        else if (index > 0 && (!reversed && delta < 0 || reversed && delta > 0)) {
            if (Math.abs(delta) > itemRects[index - 1][itemHeightOrWidth] * moveFactor) {
                me.currentIndex--;
                me.switchItems(index, me.currentIndex)
            }
        }

        else if (index < maxItems && (!reversed && delta > 0 || reversed && delta < 0)) {
            if (Math.abs(delta) > itemRects[index + 1][itemHeightOrWidth] * moveFactor) {
                me.currentIndex++;
                me.switchItems(index, me.currentIndex)
            }
        }

        me.isOverDragging = isOverDragging && me.currentIndex !== 0 && me.currentIndex !== maxItems;

        if (me.isOverDragging) {
            await me.timeout(30); // wait for 1 frame

            if (me.isOverDragging) {
                await me.onDragMove(data)
            }
        }
    }

    /**
     * Initializes the drag operation.
     *
     * Key actions:
     * 1.  **Identify Drag Target:** Determines which item is being dragged (handling `dragHandleSelector` if present).
     * 2.  **Snapshot Layout:** Captures the current DOM rectangles (`itemRects`) of all sortable items. This snapshot
     *     is critical for:
     *     - Calculating drag deltas for sorting.
     *     - Restoring the layout after a window drag re-entry.
     *     - Inferring gaps and offsets for `calculateExpandedLayout`.
     * 3.  **Setup Proxy & Placeholder:** Configures the visual drag proxy and inserts the placeholder into the `sortableItems` list.
     * 4.  **Apply Absolute Positioning:** Temporarily switches all items to `position: absolute` based on their captured
     *     coordinates to enable smooth, GPU-accelerated movement during the drag.
     *
     * @param {Object} data - The drag start event data.
     */
    async onDragStart(data) {
        let me         = this,
            {adjustItemRectsToParent, dragHandleSelector, owner} = me,
            itemStyles = me.itemStyles = [],
            {layout}   = owner,
            ownerStyle = owner.style || {},
            draggedItem, index, indexMap, itemStyle, rect, sortableItems;

        if (owner.dragResortable) {
            if (dragHandleSelector) {
                const handleClassName = dragHandleSelector.substring(1);
                const handleNode      = data.path.find(node => node.cls.includes(handleClassName));

                if (!handleNode) {
                    return
                }

                const handleIndex = data.path.indexOf(handleNode);

                for (let i = handleIndex; i < data.path.length; i++) {
                    const potentialItemNode = data.path[i];
                    const component = Neo.getComponent(potentialItemNode.id);

                    if (component && owner.items.includes(component)) {
                        draggedItem = component;
                        break;
                    }
                }

                if (!draggedItem) {
                    return
                }

                sortableItems = owner.items.filter(item => _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].find(item.vdom, {
                    cls: dragHandleSelector.startsWith('.') ? dragHandleSelector.substring(1) : dragHandleSelector
                }));
                index         = sortableItems.indexOf(draggedItem);

                if (index < 0) {
                    return
                }
            } else {
                draggedItem   = Neo.getComponent(data.path[0].id);
                sortableItems = owner.items;
                index         = owner.indexOf(draggedItem.id)
            }

            indexMap = {};

            Object.assign(me, {
                currentIndex           : index,
                dragElement            : _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].find(owner.vdom, draggedItem.id).vdom,
                dragProxyConfig        : me.getDragProxyConfig(),
                indexMap,
                lastIntersectionRatio  : 1,
                ownerStyle             : {height: ownerStyle.height, minWidth: ownerStyle.minWidth, width: ownerStyle.width},
                reversedLayoutDirection: layout.direction === 'column-reverse' || layout.direction === 'row-reverse',
                sortableItems,
                sortDirection          : layout.direction?.includes('column') ? 'vertical' : 'horizontal',
                startIndex             : index
            });

            me.dragComponent = draggedItem;

            sortableItems.forEach((item, i) => {
                indexMap[i] = owner.items.indexOf(item);

                itemStyles.push({
                    height: item.height ? `${item.height}px` :  item.style?.height,
                    width : item.width  ? `${item.width}px`  :  item.style?.width
                })
            });

            const itemRects = await owner.getDomRect([owner.id].concat(sortableItems.map(e => e.id)));

            me.ownerRect = itemRects.shift();

            // Calculate real owner dimensions based on first and last item rects (accounting for padding)
            if (itemRects.length > 0) {
                const firstItemRect = itemRects[0];
                const lastItemRect  = itemRects[itemRects.length - 1];

                if (me.sortDirection === 'horizontal') {
                    if (firstItemRect.x > me.ownerRect.x) {
                        me.ownerRect.x = firstItemRect.x
                    }
                    if (firstItemRect.y > me.ownerRect.y) {
                        me.ownerRect.y = firstItemRect.y
                    }
                    me.ownerRect.width  = (lastItemRect.x + lastItemRect.width)  - me.ownerRect.x;
                    me.ownerRect.height = (lastItemRect.y + lastItemRect.height) - me.ownerRect.y
                } else {
                    if (firstItemRect.x > me.ownerRect.x) {
                        me.ownerRect.x = firstItemRect.x
                    }
                    if (firstItemRect.y > me.ownerRect.y) {
                        me.ownerRect.y = firstItemRect.y
                    }
                    me.ownerRect.width  = (lastItemRect.x + lastItemRect.width)  - me.ownerRect.x;
                    me.ownerRect.height = (lastItemRect.y + lastItemRect.height) - me.ownerRect.y
                }
            }

            owner.style = {
                ...ownerStyle,
                height  : `${me.ownerRect.height}px`,
                minWidth: `${me.ownerRect.width}px`,
                width   : `${me.ownerRect.width}px`
            };

            adjustItemRectsToParent && itemRects.forEach(rect => {
                rect.x -= me.ownerRect.x;
                rect.y -= me.ownerRect.y
            });

            me.itemRects = itemRects;

            await me.dragStart(data);

            if (me.dragPlaceholder) {
                const placeholderIndex = sortableItems.indexOf(draggedItem);
                if (placeholderIndex > -1) {
                    sortableItems[placeholderIndex] = me.dragPlaceholder
                }
                me.dragElement = me.dragPlaceholder.vdom
            }

            sortableItems.forEach((item, i) => {
                itemStyle = item.wrapperStyle || {};
                rect      = me.itemRects[i];

                me.adjustProxyRectToParent?.(rect, me.ownerRect);

                item.wrapperStyle = Object.assign(itemStyle, {
                    height  : `${rect.height}px`,
                    left    : `${rect.left}px`,
                    margin  : '0px',
                    position: 'absolute',
                    top     : `${rect.top}px`,
                    width   : `${rect.width}px`
                })
            });

            await me.timeout(5);

            if (!me.dragPlaceholder) {
                itemStyle = draggedItem.wrapperStyle || {};
                itemStyle.visibility = 'hidden';
                draggedItem.wrapperStyle = itemStyle
            }
        }
    }

    /**
     * @param {Number} intersectionRatio
     * @param {Object} data
     */
    onWindowDragContinue(intersectionRatio, data) {}

    /**
     * @returns {Promise<void>}
     */
    async scrollToIndex() {
        let me = this;

        me.isScrolling = true;
        await me.owner.scrollToIndex?.(me.currentIndex, me.itemRects[me.currentIndex]);
        me.isScrolling = false
    }

    /**
     * Swaps two items in the sort list, updating their layout coordinates and the internal index map.
     *
     * This method handles the physical reordering of items during a drag operation. It performs the following:
     * 1.  **Normalization:** Ensures indices are ordered correctly based on layout direction.
     * 2.  **Geometry Calculation:** Swaps the dimensions (width/height) of the two items and recalculates
     *     their positions (x/y), preserving the original gap between them. This ensures that items of different
     *     sizes swap correctly without breaking the layout structure.
     * 3.  **State Update:** Updates the `indexMap` to reflect the new logical order of items.
     * 4.  **Visual Update:** Calls `updateItem` to apply the new coordinates to the DOM.
     *
     * @param {Number} index1 - The index of the first item to swap.
     * @param {Number} index2 - The index of the second item to swap.
     */
    switchItems(index1, index2) {
        let me       = this,
            reversed = me.reversedLayoutDirection,
            tmp;

        if ((!reversed && index2 < index1) || (reversed && index1 < index2)) {
            tmp    = index1;
            index1 = index2;
            index2 = tmp
        }

        let itemRects = me.itemRects,
            map       = me.indexMap,
            rect1     = itemRects[index1],
            rect2     = itemRects[index2],
            rect1Copy = rect1.clone(),
            rect2Copy = rect2.clone();

        if (me.sortDirection === 'horizontal') {
            const gap = rect2Copy.x - (rect1Copy.x + rect1Copy.width);

            rect1.width = rect2Copy.width;
            rect2.x     = rect1Copy.x + rect2Copy.width + gap;
            rect2.width = rect1Copy.width
        } else {
            const gap = rect2Copy.y - (rect1Copy.y + rect1Copy.height);

            rect1.height = rect2Copy.height;
            rect2.height = rect1Copy.height;
            rect2.y      = rect1Copy.y + rect2Copy.height + gap
        }

        tmp         = map[index1];
        map[index1] = map[index2];
        map[index2] = tmp;

        me.updateItem(index1, rect1);
        me.updateItem(index2, rect2)
    }

    /**
     * @param {Number} index
     * @param {Object} rect
     */
    updateItem(index, rect) {
        let me          = this,
            mappedIndex = me.indexMap[index],
            item;

        if (mappedIndex === -1) {
            if (me.dragPlaceholder) {
                item = me.dragPlaceholder
            } else {
                return
            }
        } else {
            item = me.owner.items[mappedIndex];

            if (me.dragPlaceholder && item === me.dragComponent) {
                item = me.dragPlaceholder
            }
        }

        let {wrapperStyle} = item;

        wrapperStyle.left = `${rect.left}px`;
        wrapperStyle.top  = `${rect.top}px`;

        item.wrapperStyle = wrapperStyle
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(SortZone));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2NhbnZhcy92ZW5kb3JzLXNyY19kcmFnZ2FibGVfY29udGFpbmVyX1NvcnRab25lX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUF3RDtBQUNSO0FBQ0Q7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLCtEQUFZO0FBQ25DO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQix1QkFBdUI7O0FBRXZCO0FBQ0EsYUFBYSxzQ0FBc0M7QUFDbkQsYUFBYSxzQ0FBc0M7QUFDbkQsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsWUFBWSx1REFBUTtBQUNwQjtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7O0FBRUEsWUFBWSx1REFBUTtBQUNwQjs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDLFVBQVU7QUFDakQsdUNBQXVDLFNBQVM7O0FBRWhEOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLHNEQUFRO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFD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QVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLGNBQWM7O0FBRTNCLCtCQUErQixVQUFVO0FBQ3pDLCtCQUErQixTQUFTOztBQUV4QztBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsd0JBQXdCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2RyYWdnYWJsZS9jb250YWluZXIvRHJhZ1pvbmUubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZHJhZ2dhYmxlL2NvbnRhaW5lci9Tb3J0Wm9uZS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2VEcmFnWm9uZSBmcm9tICcuLi8uLi9kcmFnZ2FibGUvRHJhZ1pvbmUubWpzJztcbmltcG9ydCBOZW9BcnJheSAgICAgZnJvbSAnLi4vLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IFZEb21VdGlsICAgICBmcm9tICcuLi8uLi91dGlsL1ZEb20ubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmRyYWdnYWJsZS5jb250YWluZXIuRHJhZ1pvbmVcbiAqIEBleHRlbmRzIE5lby5kcmFnZ2FibGUuRHJhZ1pvbmVcbiAqL1xuY2xhc3MgRHJhZ1pvbmUgZXh0ZW5kcyBCYXNlRHJhZ1pvbmUge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmRyYWdnYWJsZS5jb250YWluZXIuRHJhZ1pvbmUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5kcmFnZ2FibGUuY29udGFpbmVyLkRyYWdab25lJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2NvbnRhaW5lci1kcmFnem9uZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdjb250YWluZXItZHJhZ3pvbmUnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge293bmVyfSA9IG1lLFxuICAgICAgICAgICAgb3B0cyAgICA9IHtkZWxlZ2F0ZTogJy5uZW8tZHJhZ2dhYmxlJywgc2NvcGU6IG1lfTtcblxuICAgICAgICBvd25lci5hZGREb21MaXN0ZW5lcnMoW1xuICAgICAgICAgICAgeydkcmFnOmVuZCcgIDogbWUub25EcmFnRW5kLCAgIC4uLm9wdHN9LFxuICAgICAgICAgICAgeydkcmFnOm1vdmUnIDogbWUub25EcmFnTW92ZSwgIC4uLm9wdHN9LFxuICAgICAgICAgICAgeydkcmFnOnN0YXJ0JzogbWUub25EcmFnU3RhcnQsIC4uLm9wdHN9XG4gICAgICAgIF0pO1xuXG4gICAgICAgIG93bmVyLm9uKHtcbiAgICAgICAgICAgIGluc2VydCAgICAgIDogbWUub25JdGVtSW5zZXJ0LFxuICAgICAgICAgICAgaXRlbXNDcmVhdGVkOiBtZS5vbkl0ZW1zQ3JlYXRlZCxcbiAgICAgICAgICAgIHNjb3BlICAgICAgIDogbWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVGhlIGNvbnRhaW5lciBpdGVtcyBjYW4gYWxyZWFkeSBiZSBjcmVhdGVkXG4gICAgICAgIG1lLmFkanVzdEl0ZW1DbHModHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBkcmFnZ2FibGVcbiAgICAgKi9cbiAgICBhZGp1c3RJdGVtQ2xzKGRyYWdnYWJsZSkge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7b3duZXJ9ID0gbWUsXG4gICAgICAgICAgICB3cmFwcGVyQ2xzO1xuXG4gICAgICAgIG93bmVyLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAvLyBzcGFjZXJzXG4gICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3cmFwcGVyQ2xzID0gaXRlbS53cmFwcGVyQ2xzIHx8IFtdO1xuXG4gICAgICAgICAgICBOZW9BcnJheS50b2dnbGUod3JhcHBlckNscywgJ25lby1kcmFnZ2FibGUnLCBkcmFnZ2FibGUpO1xuICAgICAgICAgICAgaXRlbS53cmFwcGVyQ2xzID0gd3JhcHBlckNscztcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkRyYWdFbmQoZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5vd25lci5kcmFnZ2FibGUpIHtcbiAgICAgICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHByb3h5ICAgICAgICA9IG1lLmRyYWdQcm94eSxcbiAgICAgICAgICAgICAgICBjbHMgICAgICAgICAgPSBwcm94eS5jbHMgfHwge30sXG4gICAgICAgICAgICAgICAgcmVjdCAgICAgICAgID0gbWUuZHJhZ0VsZW1lbnRSZWN0LFxuICAgICAgICAgICAgICAgIHdyYXBwZXJTdHlsZSA9IHByb3h5LndyYXBwZXJTdHlsZSB8fCB7fTtcblxuICAgICAgICAgICAgTmVvQXJyYXkuYWRkKGNscywgJ25lby1hbmltYXRlJyk7XG4gICAgICAgICAgICBwcm94eS5jbHMgPSBjbHM7XG5cbiAgICAgICAgICAgIC8vIGVuc3VyZSB0byBnZXQgaW50byB0aGUgbmV4dCBhbmltYXRpb24gZnJhbWVcbiAgICAgICAgICAgIG1lLnRpbWVvdXQoMzApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHdyYXBwZXJTdHlsZS5sZWZ0ID0gYCR7cmVjdC5sZWZ0fXB4YDtcbiAgICAgICAgICAgICAgICB3cmFwcGVyU3R5bGUudG9wICA9IGAke3JlY3QudG9wfXB4YDtcblxuICAgICAgICAgICAgICAgIHByb3h5LndyYXBwZXJTdHlsZSA9IHdyYXBwZXJTdHlsZTtcblxuICAgICAgICAgICAgICAgIG1lLnRpbWVvdXQoMTAwKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbWUuZHJhZ0VuZCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGFzeW5jIG9uRHJhZ1N0YXJ0KGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUub3duZXIuZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICBtZS5kcmFnRWxlbWVudCA9IFZEb21VdGlsLmZpbmQobWUub3duZXIudmRvbSwgZGF0YS5wYXRoWzBdLmlkKS52ZG9tO1xuICAgICAgICAgICAgYXdhaXQgbWUuZHJhZ1N0YXJ0KGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICAgIGRhdGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gICAgICAgICAgICAgZGF0YS5pbmRleFxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBkYXRhLml0ZW1cbiAgICAgKi9cbiAgICBvbkl0ZW1JbnNlcnQoZGF0YSkge1xuICAgICAgICBsZXQge2l0ZW19ICAgICA9IGRhdGEsXG4gICAgICAgICAgICB3cmFwcGVyQ2xzID0gaXRlbS53cmFwcGVyQ2xzIHx8IFtdO1xuXG4gICAgICAgIE5lb0FycmF5LmFkZCh3cmFwcGVyQ2xzLCAnbmVvLWRyYWdnYWJsZScpO1xuICAgICAgICBpdGVtLndyYXBwZXJDbHMgPSB3cmFwcGVyQ2xzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgICAgIGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICAgICAgICAgICBkYXRhLmlkXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2VbXX0gZGF0YS5pdGVtc1xuICAgICAqL1xuICAgIG9uSXRlbXNDcmVhdGVkKGRhdGEpIHtcbiAgICAgICAgdGhpcy5hZGp1c3RJdGVtQ2xzKHRydWUpO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoRHJhZ1pvbmUpO1xuIiwiaW1wb3J0IERyYWdab25lICBmcm9tICcuL0RyYWdab25lLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgIGZyb20gJy4uLy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBSZWN0YW5nbGUgZnJvbSAnLi4vLi4vdXRpbC9SZWN0YW5nbGUubWpzJztcbmltcG9ydCBWRG9tVXRpbCAgZnJvbSAnLi4vLi4vdXRpbC9WRG9tLm1qcyc7XG5cbi8qKlxuICogQHN1bW1hcnkgTWFuYWdlcyB0aGUgZHJhZy1hbmQtZHJvcCByZW9yZGVyaW5nIG9mIGl0ZW1zIHdpdGhpbiBhIGNvbnRhaW5lciwgd2l0aCBzdXBwb3J0IGZvciB3aW5kb3cgZGV0YWNobWVudC5cbiAqXG4gKiBUaGlzIGNsYXNzIGV4dGVuZHMgYE5lby5kcmFnZ2FibGUuY29udGFpbmVyLkRyYWdab25lYCB0byBwcm92aWRlIHNvcnRpbmcgY2FwYWJpbGl0aWVzIGZvciBgTmVvLmNvbnRhaW5lci5CYXNlYCBpbnN0YW5jZXMuXG4gKiBJdCBoYW5kbGVzIHRoZSBjb21wbGV4IGxvZ2ljIG9mIHRyYWNraW5nIGl0ZW0gcG9zaXRpb25zLCBzd2FwcGluZyB0aGVtIGR1cmluZyB0aGUgZHJhZyBvcGVyYXRpb24sIGFuZCB1cGRhdGluZ1xuICogdGhlIGNvbnRhaW5lcidzIGxheW91dCB1cG9uIGRyb3AuXG4gKlxuICogQSBrZXkgZmVhdHVyZSBvZiB0aGlzIGNsYXNzIGlzIGl0cyBzdXBwb3J0IGZvciAqKldpbmRvdyBEZXRhY2htZW50KiogKHRlYXJpbmcgdGFicyBvciBpdGVtcyBvdXQgb2YgdGhlIG1haW4gd2luZG93KS5cbiAqIFdoZW4gYW4gaXRlbSBpcyBkcmFnZ2VkIG91dHNpZGUgdGhlIGJyb3dzZXIgd2luZG93IGJvdW5kYXJpZXM6XG4gKiAxLiBUaGUgYHN0YXJ0V2luZG93RHJhZ2AgbWV0aG9kIGlzIHRyaWdnZXJlZC5cbiAqIDIuIFRoZSBkcmFnIHBsYWNlaG9sZGVyIGlzIGhpZGRlbi5cbiAqIDMuIFRoZSBgY2FsY3VsYXRlRXhwYW5kZWRMYXlvdXRgIG1ldGhvZCBkeW5hbWljYWxseSBjb21wdXRlcyBhIG5ldyBsYXlvdXQgZm9yIHRoZSByZW1haW5pbmcgaXRlbXMsIGV4cGFuZGluZyB0aGVtXG4gKiAgICB0byBmaWxsIHRoZSBlbXB0eSBzcGFjZSAoYW5pbWF0aW5nIGB3aWR0aGAsIGBoZWlnaHRgLCBgdG9wYCwgYW5kIGBsZWZ0YCkuXG4gKiA0LiBJZiB0aGUgZHJhZyByZS1lbnRlcnMgdGhlIHdpbmRvdyAoYG9uRHJhZ0JvdW5kYXJ5RW50cnlgKSwgdGhlIG9yaWdpbmFsIGxheW91dCBzbmFwc2hvdCBpcyByZXN0b3JlZCwgYW5kIHRoZVxuICogICAgcGxhY2Vob2xkZXIgcmVhcHBlYXJzLCBhbGxvd2luZyBmb3IgYSBzZWFtbGVzcyByZXR1cm4gdG8gc29ydGluZyBtb2RlLlxuICpcbiAqIFRoaXMgY2xhc3MgaW50ZXJhY3RzIGNsb3NlbHkgd2l0aDpcbiAqIC0gYE5lby5kcmFnZ2FibGUuRHJhZ1Byb3h5YDogRm9yIHRoZSB2aXN1YWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIGRyYWdnZWQgaXRlbS5cbiAqIC0gYE5lby5tYWluLmFkZG9uLkRyYWdEcm9wYDogRm9yIGNvbW11bmljYXRpbmcgZHJhZyBzdGF0ZSBhY3Jvc3MgdGhlIGJyb3dzZXIvT1MgZW52aXJvbm1lbnQuXG4gKlxuICogQGNsYXNzIE5lby5kcmFnZ2FibGUuY29udGFpbmVyLlNvcnRab25lXG4gKiBAZXh0ZW5kcyBOZW8uZHJhZ2dhYmxlLmNvbnRhaW5lci5EcmFnWm9uZVxuICogQHNlZSBOZW8uZHJhZ2dhYmxlLmNvbnRhaW5lci5EcmFnWm9uZVxuICogQHNlZSBOZW8ubWFpbi5hZGRvbi5EcmFnRHJvcFxuICovXG5jbGFzcyBTb3J0Wm9uZSBleHRlbmRzIERyYWdab25lIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5kcmFnZ2FibGUuY29udGFpbmVyLlNvcnRab25lJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZHJhZ2dhYmxlLmNvbnRhaW5lci5Tb3J0Wm9uZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdjb250YWluZXItc29ydHpvbmUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnY29udGFpbmVyLXNvcnR6b25lJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlcGVuZGluZyBvbiB0aGUgcGFyZW50IHN0cnVjdHVyZSB1c2luZyBwb3NpdGlvbiBhYnNvbHV0ZSBhbmQgcmVsYXRpdmUsIGl0IGNhbiBiZSBuZWVkZWQgdG8gc3VidHJhY3RcbiAgICAgICAgICogdGhlIHggJiB5IHBhcmVudCByZWN0IHZhbHVlcyBmcm9tIHRoZSBpdGVtIHJlY3RzLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhZGp1c3RJdGVtUmVjdHNUb1BhcmVudD1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgYWRqdXN0SXRlbVJlY3RzVG9QYXJlbnQ6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYWx3YXlzRmlyZURyYWdNb3ZlPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGFsd2F5c0ZpcmVEcmFnTW92ZTogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gY3VycmVudEluZGV4PS0xXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGN1cnJlbnRJbmRleDogLTEsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaW50ZXJzZWN0aW9uIHJhdGlvICgwLTEpIHJlcXVpcmVkIHRvIGRldGFjaCBhbiBpdGVtIGludG8gYSBuZXcgd2luZG93LlxuICAgICAgICAgKiBMb3dlciB2YWx1ZXMgbWVhbiB0aGUgaXRlbSBtdXN0IGJlIGRyYWdnZWQgZnVydGhlciBvdXQuXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gZGV0YWNoVGhyZXNob2xkPTAuOFxuICAgICAgICAgKi9cbiAgICAgICAgZGV0YWNoVGhyZXNob2xkOiAwLjgsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIENTUyBzZWxlY3RvciB0byBpZGVudGlmeSB0aGUgZHJhZyBoYW5kbGUgd2l0aGluIGEgY29tcG9uZW50LlxuICAgICAgICAgKiBJZiBzcGVjaWZpZWQsIHRoZSBkcmFnIGlzIGluaXRpYXRlZCBvbiB0aGlzIGVsZW1lbnQsIGJ1dCB0aGUgb3duaW5nIGNvbXBvbmVudCBpcyBkcmFnZ2VkLlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gZHJhZ0hhbmRsZVNlbGVjdG9yPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdIYW5kbGVTZWxlY3RvcjogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGVuYWJsZVByb3h5VG9Qb3B1cD1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgZW5hYmxlUHJveHlUb1BvcHVwOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gaW5kZXhNYXA9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBpbmRleE1hcDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5fG51bGx9IGl0ZW1SZWN0cz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1SZWN0czogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5fG51bGx9IGl0ZW1TdHlsZXM9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtU3R5bGVzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBsYXN0SW50ZXJzZWN0aW9uUmF0aW89MVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBsYXN0SW50ZXJzZWN0aW9uUmF0aW86IDEsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IG93bmVyUmVjdD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG93bmVyUmVjdDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gb3duZXJTdHlsZT1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG93bmVyU3R5bGU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaW50ZXJzZWN0aW9uIHJhdGlvICgwLTEpIHJlcXVpcmVkIHRvIHJlLWF0dGFjaCBhIHdpbmRvdy1kcmFnZ2VkIGl0ZW0gYmFjayBpbnRvIHRoZSBjb250YWluZXIuXG4gICAgICAgICAqIEhpZ2hlciB2YWx1ZXMgbWVhbiB0aGUgaXRlbSBtdXN0IGJlIGRyYWdnZWQgZnVydGhlciBpbi5cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSByZWF0dGFjaFRocmVzaG9sZD0wLjZcbiAgICAgICAgICovXG4gICAgICAgIHJlYXR0YWNoVGhyZXNob2xkOiAwLjYsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhbHdheXNGaXJlRHJhZ01vdmU9ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcmV2ZXJzZWRMYXlvdXREaXJlY3Rpb246IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBzY3JvbGxMZWZ0PTBcbiAgICAgICAgICovXG4gICAgICAgIHNjcm9sbExlZnQ6IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHNjcm9sbFRvcD0wXG4gICAgICAgICAqL1xuICAgICAgICBzY3JvbGxUb3A6IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBmbGFnOiBvbkRyYWdTdGFydCgpIHdpbGwgc2V0IHRoZSB2YWx1ZSB0byBob3Jpem9udGFsIG9yIHZlcnRpY2FsLCBkZXBlbmRpbmcgb24gdGhlIGN1cnJlbnQgbGF5b3V0LlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHNvcnREaXJlY3Rpb249J2hvcml6b250YWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNvcnREaXJlY3Rpb246ICdob3Jpem9udGFsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gc3RhcnRJbmRleD0tMVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzdGFydEluZGV4OiAtMVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzT3ZlckRyYWdnaW5nPWZhbHNlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGlzT3ZlckRyYWdnaW5nID0gZmFsc2VcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc1dpbmRvd0RyYWdnaW5nPWZhbHNlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGlzV2luZG93RHJhZ2dpbmcgPSBmYWxzZVxuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgbmVvLWRyYWdnYWJsZSBjbHMgb24gaXRlbXMgaW5zaWRlIG91ciBvd25lci5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRyYWdnYWJsZVxuICAgICAqL1xuICAgIGFkanVzdEl0ZW1DbHMoZHJhZ2dhYmxlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmRyYWdIYW5kbGVTZWxlY3Rvcikge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlQ2xzICAgICA9IG1lLmRyYWdIYW5kbGVTZWxlY3Rvci5zdGFydHNXaXRoKCcuJykgPyBtZS5kcmFnSGFuZGxlU2VsZWN0b3Iuc3Vic3RyaW5nKDEpIDogbWUuZHJhZ0hhbmRsZVNlbGVjdG9yO1xuICAgICAgICAgICAgY29uc3Qgc29ydGFibGVJdGVtcyA9IG1lLm93bmVyLml0ZW1zLmZpbHRlcihpdGVtID0+XG4gICAgICAgICAgICAgICAgdHlwZW9mIGl0ZW0gIT09ICdzdHJpbmcnICYmIFZEb21VdGlsLmZpbmQoaXRlbS52ZG9tLCB7Y2xzOiBoYW5kbGVDbHN9KVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgc29ydGFibGVJdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdyYXBwZXJDbHMgPSBpdGVtLndyYXBwZXJDbHMgfHwgW107XG4gICAgICAgICAgICAgICAgTmVvQXJyYXkudG9nZ2xlKHdyYXBwZXJDbHMsICduZW8tZHJhZ2dhYmxlJywgZHJhZ2dhYmxlKTtcbiAgICAgICAgICAgICAgICBpdGVtLndyYXBwZXJDbHMgPSB3cmFwcGVyQ2xzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1cGVyLmFkanVzdEl0ZW1DbHMoZHJhZ2dhYmxlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgbWV0aG9kIHByb2Nlc3Npbmcgc2hvdWxkIHN0b3BcbiAgICAgKi9cbiAgICBjaGVja1dpbmRvd0JvdW5kYXJ5KGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIHtwcm94eVJlY3R9ID0gZGF0YTtcblxuICAgICAgICBpZiAocHJveHlSZWN0ICYmIG1lLmJvdW5kYXJ5Q29udGFpbmVyUmVjdCkge1xuICAgICAgICAgICAgY29uc3RcbiAgICAgICAgICAgICAgICBib3VuZGFyeVJlY3QgICAgICA9IG1lLmJvdW5kYXJ5Q29udGFpbmVyUmVjdCxcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb24gICAgICA9IFJlY3RhbmdsZS5nZXRJbnRlcnNlY3Rpb24ocHJveHlSZWN0LCBib3VuZGFyeVJlY3QpLFxuICAgICAgICAgICAgICAgIHByb3h5QXJlYSAgICAgICAgID0gcHJveHlSZWN0LndpZHRoICogcHJveHlSZWN0LmhlaWdodCxcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb25BcmVhICA9IGludGVyc2VjdGlvbiA/IGludGVyc2VjdGlvbi53aWR0aCAqIGludGVyc2VjdGlvbi5oZWlnaHQgOiAwLFxuICAgICAgICAgICAgICAgIGludGVyc2VjdGlvblJhdGlvID0gcHJveHlBcmVhID4gMCA/IGludGVyc2VjdGlvbkFyZWEgLyBwcm94eUFyZWEgOiAwLFxuICAgICAgICAgICAgICAgIGlzTW92aW5nSW4gICAgICAgID0gaW50ZXJzZWN0aW9uUmF0aW8gPiBtZS5sYXN0SW50ZXJzZWN0aW9uUmF0aW8sXG4gICAgICAgICAgICAgICAgaXNNb3ZpbmdPdXQgICAgICAgPSBpbnRlcnNlY3Rpb25SYXRpbyA8IG1lLmxhc3RJbnRlcnNlY3Rpb25SYXRpbztcblxuICAgICAgICAgICAgbWUubGFzdEludGVyc2VjdGlvblJhdGlvID0gaW50ZXJzZWN0aW9uUmF0aW87XG5cbiAgICAgICAgICAgIGlmICghbWUuaXNXaW5kb3dEcmFnZ2luZykge1xuICAgICAgICAgICAgICAgIGlmIChpc01vdmluZ091dCAmJiBpbnRlcnNlY3Rpb25SYXRpbyA8IG1lLmRldGFjaFRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICAgICBtZS5pc1dpbmRvd0RyYWdnaW5nID0gdHJ1ZTsgLy8gU2V0IGZsYWcgdG8gcHJldmVudCByZS1lbnRyeVxuXG4gICAgICAgICAgICAgICAgICAgIG1lLmZpcmUoJ2RyYWdCb3VuZGFyeUV4aXQnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnZ2VkSXRlbTogbWUuZHJhZ0NvbXBvbmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5UmVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRab25lICAgOiBtZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWUgLy8gU3RvcCBmdXJ0aGVyIHByb2Nlc3NpbmcgaW4gb25EcmFnTW92ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWUuaXNXaW5kb3dEcmFnZ2luZykge1xuICAgICAgICAgICAgICAgIGlmIChpc01vdmluZ0luICYmIGludGVyc2VjdGlvblJhdGlvID4gbWUucmVhdHRhY2hUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSBsYXlvdXRcbiAgICAgICAgICAgICAgICAgICAgbWUuZHJhZ1BsYWNlaG9sZGVyLndyYXBwZXJTdHlsZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLm1lLmRyYWdQbGFjZWhvbGRlci53cmFwcGVyU3R5bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiAndmlzaWJsZSdcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSZS1hcHBseWluZyB0aGUgY3VycmVudCBzdGF0ZTpcbiAgICAgICAgICAgICAgICAgICAgbWUuaXRlbVJlY3RzLmZvckVhY2goKHJlY3QsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWFwcGVkSW5kZXggPSBtZS5pbmRleE1hcFtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFwcGVkSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSBtZS5vd25lci5pdGVtc1ttYXBwZWRJbmRleF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbSAhPT0gbWUuZHJhZ1BsYWNlaG9sZGVyICYmIGl0ZW0gIT09IG1lLmRyYWdDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS53cmFwcGVyU3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5pdGVtLndyYXBwZXJTdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogYCR7cmVjdC5oZWlnaHR9cHhgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCAgOiBgJHtyZWN0LmxlZnR9cHhgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wICAgOiBgJHtyZWN0LnRvcH1weGAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA6IGAke3JlY3Qud2lkdGh9cHhgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIG1lLmZpcmUoJ2RyYWdCb3VuZGFyeUVudHJ5Jywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ2dlZEl0ZW06IG1lLmRyYWdDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm94eVJlY3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3J0Wm9uZSAgIDogbWVcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZS5vbldpbmRvd0RyYWdDb250aW51ZShpbnRlcnNlY3Rpb25SYXRpbywgZGF0YSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QsIG92ZXJyaWRlIGFzIG5lZWRlZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0RHJhZ1Byb3h5Q29uZmlnKCkge1xuICAgICAgICByZXR1cm4gey4uLnRoaXMuZHJhZ1Byb3h5Q29uZmlnLCBjbHM6IFsuLi50aGlzLm93bmVyLmNsc119XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgZm9yIGNsYXNzIGV4dGVuc2lvbnMgKGUuZy4gdGFiLmhlYWRlci5Ub29sYmFyKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmcm9tSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdG9JbmRleFxuICAgICAqL1xuICAgIG1vdmVUbyhmcm9tSW5kZXgsIHRvSW5kZXgpIHtcbiAgICAgICAgdGhpcy5vd25lci5tb3ZlVG8oZnJvbUluZGV4LCB0b0luZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSBjb21wbGV0aW9uIG9mIHRoZSBkcmFnIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHJlc3BvbnNpYmxlIGZvcjpcbiAgICAgKiAxLiAgKipGaW5hbGl6aW5nIHRoZSBEcm9wOioqIElmIHZhbGlkLCBpdCBtb3ZlcyB0aGUgRE9NIG5vZGVzIHRvIHRoZWlyIGZpbmFsIHBvc2l0aW9ucyAodmlhIGBOZW8uYXBwbHlEZWx0YXNgKS5cbiAgICAgKiAyLiAgKipDbGVhbnVwOioqIFJlbW92ZXMgdGhlIGRyYWcgcGxhY2Vob2xkZXIgYW5kIHJlc2V0cyBpbnRlcm5hbCBzdGF0ZSBmbGFncyAoYGlzV2luZG93RHJhZ2dpbmdgLCBgY3VycmVudEluZGV4YCwgZXRjLikuXG4gICAgICogMy4gICoqTGF5b3V0IFJlc3RvcmF0aW9uOioqIFJlc2V0cyB0aGUgc3R5bGVzIG9mIGFsbCBpdGVtcyAoY2xlYXJpbmcgdGhlIGFic29sdXRlIHBvc2l0aW9uaW5nIHVzZWQgZHVyaW5nIHRoZSBkcmFnKVxuICAgICAqICAgICBzbyB0aGV5IHJldHVybiB0byB0aGUgY29udGFpbmVyJ3MgbmF0dXJhbCBsYXlvdXQgZmxvdy5cbiAgICAgKiA0LiAgKipTdGF0ZSBTeW5jaHJvbml6YXRpb246KiogQ2FsbHMgYG93bmVyLm1vdmVUbygpYCB0byB1cGRhdGUgdGhlIGNvbnRhaW5lcidzIGBpdGVtc2AgYXJyYXkgdG8gcmVmbGVjdCB0aGUgbmV3IG9yZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgZHJhZyBlbmQgZXZlbnQgZGF0YS5cbiAgICAgKi9cbiAgICBhc3luYyBvbkRyYWdFbmQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7aXRlbVN0eWxlcywgb3duZXJ9ID0gbWUsXG4gICAgICAgICAgICBvd25lclN0eWxlICAgICAgICAgID0gb3duZXIuc3R5bGUgfHwge30sXG4gICAgICAgICAgICBpdGVtU3R5bGU7XG5cbiAgICAgICAgYXdhaXQgbWUudGltZW91dCgxMCk7XG5cbiAgICAgICAgaWYgKG93bmVyLmRyYWdSZXNvcnRhYmxlKSB7XG4gICAgICAgICAgICBpZiAobWUuZHJhZ1BsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3RcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50ID0gbWUuZHJhZ0NvbXBvbmVudCxcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFzICAgID0gW10sXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICAgICA9IG1lLnNvcnRhYmxlSXRlbXMuaW5kZXhPZihtZS5kcmFnUGxhY2Vob2xkZXIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudCAmJiBpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWUuaXNXaW5kb3dEcmFnZ2luZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBtb3ZlIERPTSBpZiBub3Qgd2luZG93IGRyYWdnaW5nIG9yIGlmIGl0J3MgYSByZW1vdGUgZHJhZyBiZWluZyBmaW5hbGl6ZWQgbG9jYWxseVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtZS5pc1JlbW90ZURyYWdnaW5nIHx8IChtZS5pc1JlbW90ZURyYWdnaW5nICYmICFtZS5pc1dpbmRvd0RyYWdnaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbiAgOiAnbW92ZU5vZGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCAgICAgIDogY29tcG9uZW50LmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCwgICAgLy8gVmlzdWFsbHkgY29ycmVjdCBpbmRleCAod2hlcmUgcGxhY2Vob2xkZXIgaXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudElkOiBvd25lci5nZXRWZG9tSXRlbXNSb290KCkuaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZGVsdGFzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAncmVtb3ZlTm9kZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZCAgICA6IG1lLmRyYWdQbGFjZWhvbGRlci5pZFxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBNYW51YWwgRE9NIHJlc3RvcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IE5lby5hcHBseURlbHRhcyhtZS53aW5kb3dJZCwgZGVsdGFzKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3duZXJTdHlsZS5oZWlnaHQgICA9IG1lLm93bmVyU3R5bGUuaGVpZ2h0ICAgIHx8IG51bGw7XG4gICAgICAgICAgICBvd25lclN0eWxlLm1pbldpZHRoID0gbWUub3duZXJTdHlsZS5taW5XaWR0aCAgfHwgbnVsbDtcbiAgICAgICAgICAgIG93bmVyU3R5bGUud2lkdGggICAgPSBtZS5vd25lclN0eWxlLndpZHRoICAgICB8fCBudWxsO1xuXG4gICAgICAgICAgICBvd25lci5zdHlsZSA9IG93bmVyU3R5bGU7XG5cbiAgICAgICAgICAgIG1lLnNvcnRhYmxlSXRlbXM/LmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG1lLmlzV2luZG93RHJhZ2dpbmcgJiYgaXRlbSA9PT0gbWUuZHJhZ0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpdGVtU3R5bGUgPSBpdGVtLndyYXBwZXJTdHlsZSB8fCB7fTtcblxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaXRlbVN0eWxlLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCAgOiBpdGVtU3R5bGVzW2luZGV4XS5oZWlnaHQgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbGVmdCAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbiAgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgdG9wICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoICAgOiBpdGVtU3R5bGVzW2luZGV4XS53aWR0aCB8fCBudWxsXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IG1lLnN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVN0eWxlLnZpc2liaWxpdHkgPSBudWxsXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaXRlbS53cmFwcGVyU3R5bGUgPSBpdGVtU3R5bGVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBSZXN0b3JlIHZpc2liaWxpdHkgb2YgdGhlIGRyYWdnZWQgY29tcG9uZW50IChpdCdzIG5vdCBpbiBzb3J0YWJsZUl0ZW1zIGlmIHBsYWNlaG9sZGVyIGlzIHVzZWQpXG4gICAgICAgICAgICBpZiAobWUuZHJhZ0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIGxldCBzdHlsZSA9IG1lLmRyYWdDb21wb25lbnQud3JhcHBlclN0eWxlIHx8IHt9O1xuICAgICAgICAgICAgICAgIHN0eWxlLnZpc2liaWxpdHkgPSBudWxsO1xuICAgICAgICAgICAgICAgIG1lLmRyYWdDb21wb25lbnQud3JhcHBlclN0eWxlID0gc3R5bGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghbWUuaXNXaW5kb3dEcmFnZ2luZyAmJiAhbWUuaXNSZW1vdGVEcmFnZ2luZyAmJiBtZS5zdGFydEluZGV4ICE9PSBtZS5jdXJyZW50SW5kZXgpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbUluZGV4LCB0b0luZGV4O1xuXG4gICAgICAgICAgICAgICAgaWYgKG1lLmRyYWdQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSBtZS5kcmFnQ29tcG9uZW50O1xuICAgICAgICAgICAgICAgICAgICBmcm9tSW5kZXggPSBtZS5vd25lci5pdGVtcy5pbmRleE9mKGNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHRvSW5kZXggICA9IG1lLm93bmVyLml0ZW1zLmluZGV4T2YobWUuc29ydGFibGVJdGVtc1ttZS5jdXJyZW50SW5kZXhdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmcm9tSW5kZXggPSBtZS5vd25lci5pdGVtcy5pbmRleE9mKG1lLnNvcnRhYmxlSXRlbXNbbWUuc3RhcnRJbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICB0b0luZGV4ICAgPSBtZS5vd25lci5pdGVtcy5pbmRleE9mKG1lLnNvcnRhYmxlSXRlbXNbbWUuY3VycmVudEluZGV4XSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWUubW92ZVRvKGZyb21JbmRleCwgdG9JbmRleCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obWUsIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50SW5kZXggICAgOiAtMSxcbiAgICAgICAgICAgICAgICBpbmRleE1hcCAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgIGlzUmVtb3RlRHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzV2luZG93RHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGl0ZW1SZWN0cyAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgaXRlbVN0eWxlcyAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICBvd25lclJlY3QgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXggICAgICA6IC0xLFxuICAgICAgICAgICAgICAgIHNvcnRhYmxlSXRlbXMgICA6IG51bGxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBhd2FpdCBtZS50aW1lb3V0KDMwKTtcblxuICAgICAgICAgICAgbWUuZHJhZ0VuZChkYXRhKSAvLyB3ZSBkbyBub3Qgd2FudCB0byB0cmlnZ2VyIHRoZSBzdXBlciBjbGFzcyBjYWxsIGhlcmVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlIGRyYWcgbW92ZSBldmVudC4gVGhpcyBpcyB0aGUgY29yZSBsb2dpYyBsb29wIGZvciB0aGUgZHJhZyBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBSZXNwb25zaWJpbGl0aWVzOlxuICAgICAqIDEuICAqKldpbmRvdyBEcmFnIFJlLWVudHJ5OioqIENoZWNrcyBpZiBhIHdpbmRvdyBkcmFnIGhhcyByZS1lbnRlcmVkIHRoZSBvcmlnaW5hbCBjb250YWluZXIgYm91bmRhcmllcy5cbiAgICAgKiAgICAgSWYgc28sIGl0IHJlc3RvcmVzIHRoZSBvcmlnaW5hbCBsYXlvdXQgc25hcHNob3QgKGBpdGVtUmVjdHNgKSBhbmQgc2hvd3MgdGhlIHBsYWNlaG9sZGVyLCBlZmZlY3RpdmVseVxuICAgICAqICAgICBcInNuYXBwaW5nXCIgdGhlIGRhc2hib2FyZCBiYWNrIHRvIGl0cyBzb3J0YWJsZSBzdGF0ZS5cbiAgICAgKiAyLiAgKipXaW5kb3cgRHJhZyBFeGl0OioqIERldGVjdHMgaWYgdGhlIGRyYWcgcHJveHkgaGFzIGxlZnQgdGhlIGNvbnRhaW5lciBib3VuZGFyaWVzIChpZiBgZW5hYmxlUHJveHlUb1BvcHVwYCBpcyB0cnVlKVxuICAgICAqICAgICBhbmQgdHJpZ2dlcnMgdGhlIGBkcmFnQm91bmRhcnlFeGl0YCBldmVudCB0byBwb3RlbnRpYWxseSBzdGFydCBhIHdpbmRvdyBkcmFnLlxuICAgICAqIDMuICAqKlN0YW5kYXJkIFNvcnRpbmc6KiogSWYgbm90IGluIHdpbmRvdy1kcmFnIG1vZGUsIGl0IGNhbGN1bGF0ZXMgdGhlIGRyYWcgZGVsdGEgYW5kIHN3YXBzIGl0ZW1zIChgc3dpdGNoSXRlbXNgKVxuICAgICAqICAgICBpZiB0aGUgdGhyZXNob2xkIGlzIGNyb3NzZWQsIHVwZGF0aW5nIHRoZSBgY3VycmVudEluZGV4YC5cbiAgICAgKiA0LiAgKipBdXRvLVNjcm9sbGluZzoqKiBNYW5hZ2VzIGF1dG8tc2Nyb2xsaW5nIHdoZW4gZHJhZ2dpbmcgbmVhciB0aGUgZWRnZXMgb2YgdGhlIGNvbnRhaW5lci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBkcmFnIG1vdmUgZXZlbnQgZGF0YS5cbiAgICAgKi9cbiAgICBhc3luYyBvbkRyYWdNb3ZlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvLyBUaGUgbWV0aG9kIGNhbiB0cmlnZ2VyIGJlZm9yZSB3ZSBnb3QgdGhlIGNsaWVudCByZWN0cyBmcm9tIHRoZSBtYWluIHRocmVhZFxuICAgICAgICBpZiAoIW1lLml0ZW1SZWN0cyB8fCBtZS5pc1Njcm9sbGluZyB8fCAhbWUuYm91bmRhcnlDb250YWluZXJSZWN0KSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdTb3J0Wm9uZSBvbkRyYWdNb3ZlJywgbWUuZHJhZ1Byb3h5KTtcblxuICAgICAgICBpZiAoIW1lLmlzUmVtb3RlRHJhZ2dpbmcgJiYgbWUuZHJhZ1Byb3h5ICYmIG1lLmVuYWJsZVByb3h5VG9Qb3B1cCkge1xuICAgICAgICAgICAgaWYgKG1lLmNoZWNrV2luZG93Qm91bmRhcnkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB7Y2xpZW50WCwgY2xpZW50WX0gPSBkYXRhLFxuICAgICAgICAgICAgaW5kZXggICAgICAgICAgICAgID0gbWUuY3VycmVudEluZGV4LFxuICAgICAgICAgICAge2l0ZW1SZWN0c30gICAgICAgID0gbWUsXG4gICAgICAgICAgICBtYXhJdGVtcyAgICAgICAgICAgPSBpdGVtUmVjdHMubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgIG93bmVyWCAgICAgICAgICAgICA9IG1lLmFkanVzdEl0ZW1SZWN0c1RvUGFyZW50ID8gbWUub3duZXJSZWN0LnggOiAwLFxuICAgICAgICAgICAgb3duZXJZICAgICAgICAgICAgID0gbWUuYWRqdXN0SXRlbVJlY3RzVG9QYXJlbnQgPyBtZS5vd25lclJlY3QueSA6IDAsXG4gICAgICAgICAgICByZXZlcnNlZCAgICAgICAgICAgPSBtZS5yZXZlcnNlZExheW91dERpcmVjdGlvbixcbiAgICAgICAgICAgIGRlbHRhLCBpc092ZXJEcmFnZ2luZywgaXNPdmVyRHJhZ2dpbmdFbmQsIGlzT3ZlckRyYWdnaW5nU3RhcnQsIGl0ZW1IZWlnaHRPcldpZHRoLCBtb3ZlRmFjdG9yO1xuXG4gICAgICAgIGlmIChtZS5zb3J0RGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgIGRlbHRhICAgICAgICAgICAgICAgPSBjbGllbnRYIC0gb3duZXJYICsgbWUuc2Nyb2xsTGVmdCAtIG1lLm9mZnNldFggLSBpdGVtUmVjdHNbaW5kZXhdLmxlZnQ7XG4gICAgICAgICAgICBpc092ZXJEcmFnZ2luZ0VuZCAgID0gY2xpZW50WCA+IG1lLmJvdW5kYXJ5Q29udGFpbmVyUmVjdC5yaWdodDtcbiAgICAgICAgICAgIGlzT3ZlckRyYWdnaW5nU3RhcnQgPSBjbGllbnRYIDwgbWUuYm91bmRhcnlDb250YWluZXJSZWN0LmxlZnQ7XG4gICAgICAgICAgICBpdGVtSGVpZ2h0T3JXaWR0aCAgID0gJ3dpZHRoJ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsdGEgICAgICAgICAgICAgICA9IGNsaWVudFkgLSBvd25lclkgKyBtZS5zY3JvbGxUb3AgLSBtZS5vZmZzZXRZIC0gaXRlbVJlY3RzW2luZGV4XS50b3A7XG4gICAgICAgICAgICBpc092ZXJEcmFnZ2luZ0VuZCAgID0gY2xpZW50WSA+IG1lLmJvdW5kYXJ5Q29udGFpbmVyUmVjdC5ib3R0b207XG4gICAgICAgICAgICBpc092ZXJEcmFnZ2luZ1N0YXJ0ID0gY2xpZW50WSA8IG1lLmJvdW5kYXJ5Q29udGFpbmVyUmVjdC50b3A7XG4gICAgICAgICAgICBpdGVtSGVpZ2h0T3JXaWR0aCAgID0gJ2hlaWdodCdcbiAgICAgICAgfVxuXG4gICAgICAgIGlzT3ZlckRyYWdnaW5nID0gaXNPdmVyRHJhZ2dpbmdFbmQgfHwgaXNPdmVyRHJhZ2dpbmdTdGFydDtcbiAgICAgICAgbW92ZUZhY3RvciAgICAgPSBpc092ZXJEcmFnZ2luZyA/IDAuMDIgOiAwLjU1OyAvLyBXZSBjYW4gbm90IHVzZSAwLjUsIHNpbmNlIGl0ZW1zIHdvdWxkIGp1bXAgYmFjayAmIGZvcnRoXG5cbiAgICAgICAgaWYgKGlzT3ZlckRyYWdnaW5nU3RhcnQpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICBtZS5jdXJyZW50SW5kZXgtLTtcbiAgICAgICAgICAgICAgICBhd2FpdCBtZS5zY3JvbGxUb0luZGV4KCk7XG4gICAgICAgICAgICAgICAgbWUuc3dpdGNoSXRlbXMoaW5kZXgsIG1lLmN1cnJlbnRJbmRleClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGVsc2UgaWYgKGlzT3ZlckRyYWdnaW5nRW5kKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPCBtYXhJdGVtcykge1xuICAgICAgICAgICAgICAgIG1lLmN1cnJlbnRJbmRleCsrO1xuICAgICAgICAgICAgICAgIGF3YWl0IG1lLnNjcm9sbFRvSW5kZXgoKTtcbiAgICAgICAgICAgICAgICBtZS5zd2l0Y2hJdGVtcyhpbmRleCwgbWUuY3VycmVudEluZGV4KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSBpZiAoaW5kZXggPiAwICYmICghcmV2ZXJzZWQgJiYgZGVsdGEgPCAwIHx8IHJldmVyc2VkICYmIGRlbHRhID4gMCkpIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkZWx0YSkgPiBpdGVtUmVjdHNbaW5kZXggLSAxXVtpdGVtSGVpZ2h0T3JXaWR0aF0gKiBtb3ZlRmFjdG9yKSB7XG4gICAgICAgICAgICAgICAgbWUuY3VycmVudEluZGV4LS07XG4gICAgICAgICAgICAgICAgbWUuc3dpdGNoSXRlbXMoaW5kZXgsIG1lLmN1cnJlbnRJbmRleClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGVsc2UgaWYgKGluZGV4IDwgbWF4SXRlbXMgJiYgKCFyZXZlcnNlZCAmJiBkZWx0YSA+IDAgfHwgcmV2ZXJzZWQgJiYgZGVsdGEgPCAwKSkge1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGRlbHRhKSA+IGl0ZW1SZWN0c1tpbmRleCArIDFdW2l0ZW1IZWlnaHRPcldpZHRoXSAqIG1vdmVGYWN0b3IpIHtcbiAgICAgICAgICAgICAgICBtZS5jdXJyZW50SW5kZXgrKztcbiAgICAgICAgICAgICAgICBtZS5zd2l0Y2hJdGVtcyhpbmRleCwgbWUuY3VycmVudEluZGV4KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWUuaXNPdmVyRHJhZ2dpbmcgPSBpc092ZXJEcmFnZ2luZyAmJiBtZS5jdXJyZW50SW5kZXggIT09IDAgJiYgbWUuY3VycmVudEluZGV4ICE9PSBtYXhJdGVtcztcblxuICAgICAgICBpZiAobWUuaXNPdmVyRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIGF3YWl0IG1lLnRpbWVvdXQoMzApOyAvLyB3YWl0IGZvciAxIGZyYW1lXG5cbiAgICAgICAgICAgIGlmIChtZS5pc092ZXJEcmFnZ2luZykge1xuICAgICAgICAgICAgICAgIGF3YWl0IG1lLm9uRHJhZ01vdmUoZGF0YSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBkcmFnIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEtleSBhY3Rpb25zOlxuICAgICAqIDEuICAqKklkZW50aWZ5IERyYWcgVGFyZ2V0OioqIERldGVybWluZXMgd2hpY2ggaXRlbSBpcyBiZWluZyBkcmFnZ2VkIChoYW5kbGluZyBgZHJhZ0hhbmRsZVNlbGVjdG9yYCBpZiBwcmVzZW50KS5cbiAgICAgKiAyLiAgKipTbmFwc2hvdCBMYXlvdXQ6KiogQ2FwdHVyZXMgdGhlIGN1cnJlbnQgRE9NIHJlY3RhbmdsZXMgKGBpdGVtUmVjdHNgKSBvZiBhbGwgc29ydGFibGUgaXRlbXMuIFRoaXMgc25hcHNob3RcbiAgICAgKiAgICAgaXMgY3JpdGljYWwgZm9yOlxuICAgICAqICAgICAtIENhbGN1bGF0aW5nIGRyYWcgZGVsdGFzIGZvciBzb3J0aW5nLlxuICAgICAqICAgICAtIFJlc3RvcmluZyB0aGUgbGF5b3V0IGFmdGVyIGEgd2luZG93IGRyYWcgcmUtZW50cnkuXG4gICAgICogICAgIC0gSW5mZXJyaW5nIGdhcHMgYW5kIG9mZnNldHMgZm9yIGBjYWxjdWxhdGVFeHBhbmRlZExheW91dGAuXG4gICAgICogMy4gICoqU2V0dXAgUHJveHkgJiBQbGFjZWhvbGRlcjoqKiBDb25maWd1cmVzIHRoZSB2aXN1YWwgZHJhZyBwcm94eSBhbmQgaW5zZXJ0cyB0aGUgcGxhY2Vob2xkZXIgaW50byB0aGUgYHNvcnRhYmxlSXRlbXNgIGxpc3QuXG4gICAgICogNC4gICoqQXBwbHkgQWJzb2x1dGUgUG9zaXRpb25pbmc6KiogVGVtcG9yYXJpbHkgc3dpdGNoZXMgYWxsIGl0ZW1zIHRvIGBwb3NpdGlvbjogYWJzb2x1dGVgIGJhc2VkIG9uIHRoZWlyIGNhcHR1cmVkXG4gICAgICogICAgIGNvb3JkaW5hdGVzIHRvIGVuYWJsZSBzbW9vdGgsIEdQVS1hY2NlbGVyYXRlZCBtb3ZlbWVudCBkdXJpbmcgdGhlIGRyYWcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFRoZSBkcmFnIHN0YXJ0IGV2ZW50IGRhdGEuXG4gICAgICovXG4gICAgYXN5bmMgb25EcmFnU3RhcnQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7YWRqdXN0SXRlbVJlY3RzVG9QYXJlbnQsIGRyYWdIYW5kbGVTZWxlY3Rvciwgb3duZXJ9ID0gbWUsXG4gICAgICAgICAgICBpdGVtU3R5bGVzID0gbWUuaXRlbVN0eWxlcyA9IFtdLFxuICAgICAgICAgICAge2xheW91dH0gICA9IG93bmVyLFxuICAgICAgICAgICAgb3duZXJTdHlsZSA9IG93bmVyLnN0eWxlIHx8IHt9LFxuICAgICAgICAgICAgZHJhZ2dlZEl0ZW0sIGluZGV4LCBpbmRleE1hcCwgaXRlbVN0eWxlLCByZWN0LCBzb3J0YWJsZUl0ZW1zO1xuXG4gICAgICAgIGlmIChvd25lci5kcmFnUmVzb3J0YWJsZSkge1xuICAgICAgICAgICAgaWYgKGRyYWdIYW5kbGVTZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZUNsYXNzTmFtZSA9IGRyYWdIYW5kbGVTZWxlY3Rvci5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlTm9kZSAgICAgID0gZGF0YS5wYXRoLmZpbmQobm9kZSA9PiBub2RlLmNscy5pbmNsdWRlcyhoYW5kbGVDbGFzc05hbWUpKTtcblxuICAgICAgICAgICAgICAgIGlmICghaGFuZGxlTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVJbmRleCA9IGRhdGEucGF0aC5pbmRleE9mKGhhbmRsZU5vZGUpO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGhhbmRsZUluZGV4OyBpIDwgZGF0YS5wYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvdGVudGlhbEl0ZW1Ob2RlID0gZGF0YS5wYXRoW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSBOZW8uZ2V0Q29tcG9uZW50KHBvdGVudGlhbEl0ZW1Ob2RlLmlkKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50ICYmIG93bmVyLml0ZW1zLmluY2x1ZGVzKGNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdnZWRJdGVtID0gY29tcG9uZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWRyYWdnZWRJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNvcnRhYmxlSXRlbXMgPSBvd25lci5pdGVtcy5maWx0ZXIoaXRlbSA9PiBWRG9tVXRpbC5maW5kKGl0ZW0udmRvbSwge1xuICAgICAgICAgICAgICAgICAgICBjbHM6IGRyYWdIYW5kbGVTZWxlY3Rvci5zdGFydHNXaXRoKCcuJykgPyBkcmFnSGFuZGxlU2VsZWN0b3Iuc3Vic3RyaW5nKDEpIDogZHJhZ0hhbmRsZVNlbGVjdG9yXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGluZGV4ICAgICAgICAgPSBzb3J0YWJsZUl0ZW1zLmluZGV4T2YoZHJhZ2dlZEl0ZW0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRyYWdnZWRJdGVtICAgPSBOZW8uZ2V0Q29tcG9uZW50KGRhdGEucGF0aFswXS5pZCk7XG4gICAgICAgICAgICAgICAgc29ydGFibGVJdGVtcyA9IG93bmVyLml0ZW1zO1xuICAgICAgICAgICAgICAgIGluZGV4ICAgICAgICAgPSBvd25lci5pbmRleE9mKGRyYWdnZWRJdGVtLmlkKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbmRleE1hcCA9IHt9O1xuXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG1lLCB7XG4gICAgICAgICAgICAgICAgY3VycmVudEluZGV4ICAgICAgICAgICA6IGluZGV4LFxuICAgICAgICAgICAgICAgIGRyYWdFbGVtZW50ICAgICAgICAgICAgOiBWRG9tVXRpbC5maW5kKG93bmVyLnZkb20sIGRyYWdnZWRJdGVtLmlkKS52ZG9tLFxuICAgICAgICAgICAgICAgIGRyYWdQcm94eUNvbmZpZyAgICAgICAgOiBtZS5nZXREcmFnUHJveHlDb25maWcoKSxcbiAgICAgICAgICAgICAgICBpbmRleE1hcCxcbiAgICAgICAgICAgICAgICBsYXN0SW50ZXJzZWN0aW9uUmF0aW8gIDogMSxcbiAgICAgICAgICAgICAgICBvd25lclN0eWxlICAgICAgICAgICAgIDoge2hlaWdodDogb3duZXJTdHlsZS5oZWlnaHQsIG1pbldpZHRoOiBvd25lclN0eWxlLm1pbldpZHRoLCB3aWR0aDogb3duZXJTdHlsZS53aWR0aH0sXG4gICAgICAgICAgICAgICAgcmV2ZXJzZWRMYXlvdXREaXJlY3Rpb246IGxheW91dC5kaXJlY3Rpb24gPT09ICdjb2x1bW4tcmV2ZXJzZScgfHwgbGF5b3V0LmRpcmVjdGlvbiA9PT0gJ3Jvdy1yZXZlcnNlJyxcbiAgICAgICAgICAgICAgICBzb3J0YWJsZUl0ZW1zLFxuICAgICAgICAgICAgICAgIHNvcnREaXJlY3Rpb24gICAgICAgICAgOiBsYXlvdXQuZGlyZWN0aW9uPy5pbmNsdWRlcygnY29sdW1uJykgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnLFxuICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXggICAgICAgICAgICAgOiBpbmRleFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLmRyYWdDb21wb25lbnQgPSBkcmFnZ2VkSXRlbTtcblxuICAgICAgICAgICAgc29ydGFibGVJdGVtcy5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgaW5kZXhNYXBbaV0gPSBvd25lci5pdGVtcy5pbmRleE9mKGl0ZW0pO1xuXG4gICAgICAgICAgICAgICAgaXRlbVN0eWxlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBpdGVtLmhlaWdodCA/IGAke2l0ZW0uaGVpZ2h0fXB4YCA6ICBpdGVtLnN0eWxlPy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoIDogaXRlbS53aWR0aCAgPyBgJHtpdGVtLndpZHRofXB4YCAgOiAgaXRlbS5zdHlsZT8ud2lkdGhcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGl0ZW1SZWN0cyA9IGF3YWl0IG93bmVyLmdldERvbVJlY3QoW293bmVyLmlkXS5jb25jYXQoc29ydGFibGVJdGVtcy5tYXAoZSA9PiBlLmlkKSkpO1xuXG4gICAgICAgICAgICBtZS5vd25lclJlY3QgPSBpdGVtUmVjdHMuc2hpZnQoKTtcblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHJlYWwgb3duZXIgZGltZW5zaW9ucyBiYXNlZCBvbiBmaXJzdCBhbmQgbGFzdCBpdGVtIHJlY3RzIChhY2NvdW50aW5nIGZvciBwYWRkaW5nKVxuICAgICAgICAgICAgaWYgKGl0ZW1SZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3RJdGVtUmVjdCA9IGl0ZW1SZWN0c1swXTtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0SXRlbVJlY3QgID0gaXRlbVJlY3RzW2l0ZW1SZWN0cy5sZW5ndGggLSAxXTtcblxuICAgICAgICAgICAgICAgIGlmIChtZS5zb3J0RGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0SXRlbVJlY3QueCA+IG1lLm93bmVyUmVjdC54KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5vd25lclJlY3QueCA9IGZpcnN0SXRlbVJlY3QueFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdEl0ZW1SZWN0LnkgPiBtZS5vd25lclJlY3QueSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUub3duZXJSZWN0LnkgPSBmaXJzdEl0ZW1SZWN0LnlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZS5vd25lclJlY3Qud2lkdGggID0gKGxhc3RJdGVtUmVjdC54ICsgbGFzdEl0ZW1SZWN0LndpZHRoKSAgLSBtZS5vd25lclJlY3QueDtcbiAgICAgICAgICAgICAgICAgICAgbWUub3duZXJSZWN0LmhlaWdodCA9IChsYXN0SXRlbVJlY3QueSArIGxhc3RJdGVtUmVjdC5oZWlnaHQpIC0gbWUub3duZXJSZWN0LnlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RJdGVtUmVjdC54ID4gbWUub3duZXJSZWN0LngpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLm93bmVyUmVjdC54ID0gZmlyc3RJdGVtUmVjdC54XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0SXRlbVJlY3QueSA+IG1lLm93bmVyUmVjdC55KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5vd25lclJlY3QueSA9IGZpcnN0SXRlbVJlY3QueVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lLm93bmVyUmVjdC53aWR0aCAgPSAobGFzdEl0ZW1SZWN0LnggKyBsYXN0SXRlbVJlY3Qud2lkdGgpICAtIG1lLm93bmVyUmVjdC54O1xuICAgICAgICAgICAgICAgICAgICBtZS5vd25lclJlY3QuaGVpZ2h0ID0gKGxhc3RJdGVtUmVjdC55ICsgbGFzdEl0ZW1SZWN0LmhlaWdodCkgLSBtZS5vd25lclJlY3QueVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3duZXIuc3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgLi4ub3duZXJTdHlsZSxcbiAgICAgICAgICAgICAgICBoZWlnaHQgIDogYCR7bWUub3duZXJSZWN0LmhlaWdodH1weGAsXG4gICAgICAgICAgICAgICAgbWluV2lkdGg6IGAke21lLm93bmVyUmVjdC53aWR0aH1weGAsXG4gICAgICAgICAgICAgICAgd2lkdGggICA6IGAke21lLm93bmVyUmVjdC53aWR0aH1weGBcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGFkanVzdEl0ZW1SZWN0c1RvUGFyZW50ICYmIGl0ZW1SZWN0cy5mb3JFYWNoKHJlY3QgPT4ge1xuICAgICAgICAgICAgICAgIHJlY3QueCAtPSBtZS5vd25lclJlY3QueDtcbiAgICAgICAgICAgICAgICByZWN0LnkgLT0gbWUub3duZXJSZWN0LnlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS5pdGVtUmVjdHMgPSBpdGVtUmVjdHM7XG5cbiAgICAgICAgICAgIGF3YWl0IG1lLmRyYWdTdGFydChkYXRhKTtcblxuICAgICAgICAgICAgaWYgKG1lLmRyYWdQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVySW5kZXggPSBzb3J0YWJsZUl0ZW1zLmluZGV4T2YoZHJhZ2dlZEl0ZW0pO1xuICAgICAgICAgICAgICAgIGlmIChwbGFjZWhvbGRlckluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc29ydGFibGVJdGVtc1twbGFjZWhvbGRlckluZGV4XSA9IG1lLmRyYWdQbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZS5kcmFnRWxlbWVudCA9IG1lLmRyYWdQbGFjZWhvbGRlci52ZG9tXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNvcnRhYmxlSXRlbXMuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGl0ZW1TdHlsZSA9IGl0ZW0ud3JhcHBlclN0eWxlIHx8IHt9O1xuICAgICAgICAgICAgICAgIHJlY3QgICAgICA9IG1lLml0ZW1SZWN0c1tpXTtcblxuICAgICAgICAgICAgICAgIG1lLmFkanVzdFByb3h5UmVjdFRvUGFyZW50Py4ocmVjdCwgbWUub3duZXJSZWN0KTtcblxuICAgICAgICAgICAgICAgIGl0ZW0ud3JhcHBlclN0eWxlID0gT2JqZWN0LmFzc2lnbihpdGVtU3R5bGUsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ICA6IGAke3JlY3QuaGVpZ2h0fXB4YCxcbiAgICAgICAgICAgICAgICAgICAgbGVmdCAgICA6IGAke3JlY3QubGVmdH1weGAsXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbiAgOiAnMHB4JyxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgICAgIHRvcCAgICAgOiBgJHtyZWN0LnRvcH1weGAsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoICAgOiBgJHtyZWN0LndpZHRofXB4YFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYXdhaXQgbWUudGltZW91dCg1KTtcblxuICAgICAgICAgICAgaWYgKCFtZS5kcmFnUGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgICBpdGVtU3R5bGUgPSBkcmFnZ2VkSXRlbS53cmFwcGVyU3R5bGUgfHwge307XG4gICAgICAgICAgICAgICAgaXRlbVN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgICAgICAgICBkcmFnZ2VkSXRlbS53cmFwcGVyU3R5bGUgPSBpdGVtU3R5bGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbnRlcnNlY3Rpb25SYXRpb1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25XaW5kb3dEcmFnQ29udGludWUoaW50ZXJzZWN0aW9uUmF0aW8sIGRhdGEpIHt9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBzY3JvbGxUb0luZGV4KCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmlzU2Nyb2xsaW5nID0gdHJ1ZTtcbiAgICAgICAgYXdhaXQgbWUub3duZXIuc2Nyb2xsVG9JbmRleD8uKG1lLmN1cnJlbnRJbmRleCwgbWUuaXRlbVJlY3RzW21lLmN1cnJlbnRJbmRleF0pO1xuICAgICAgICBtZS5pc1Njcm9sbGluZyA9IGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3dhcHMgdHdvIGl0ZW1zIGluIHRoZSBzb3J0IGxpc3QsIHVwZGF0aW5nIHRoZWlyIGxheW91dCBjb29yZGluYXRlcyBhbmQgdGhlIGludGVybmFsIGluZGV4IG1hcC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGhhbmRsZXMgdGhlIHBoeXNpY2FsIHJlb3JkZXJpbmcgb2YgaXRlbXMgZHVyaW5nIGEgZHJhZyBvcGVyYXRpb24uIEl0IHBlcmZvcm1zIHRoZSBmb2xsb3dpbmc6XG4gICAgICogMS4gICoqTm9ybWFsaXphdGlvbjoqKiBFbnN1cmVzIGluZGljZXMgYXJlIG9yZGVyZWQgY29ycmVjdGx5IGJhc2VkIG9uIGxheW91dCBkaXJlY3Rpb24uXG4gICAgICogMi4gICoqR2VvbWV0cnkgQ2FsY3VsYXRpb246KiogU3dhcHMgdGhlIGRpbWVuc2lvbnMgKHdpZHRoL2hlaWdodCkgb2YgdGhlIHR3byBpdGVtcyBhbmQgcmVjYWxjdWxhdGVzXG4gICAgICogICAgIHRoZWlyIHBvc2l0aW9ucyAoeC95KSwgcHJlc2VydmluZyB0aGUgb3JpZ2luYWwgZ2FwIGJldHdlZW4gdGhlbS4gVGhpcyBlbnN1cmVzIHRoYXQgaXRlbXMgb2YgZGlmZmVyZW50XG4gICAgICogICAgIHNpemVzIHN3YXAgY29ycmVjdGx5IHdpdGhvdXQgYnJlYWtpbmcgdGhlIGxheW91dCBzdHJ1Y3R1cmUuXG4gICAgICogMy4gICoqU3RhdGUgVXBkYXRlOioqIFVwZGF0ZXMgdGhlIGBpbmRleE1hcGAgdG8gcmVmbGVjdCB0aGUgbmV3IGxvZ2ljYWwgb3JkZXIgb2YgaXRlbXMuXG4gICAgICogNC4gICoqVmlzdWFsIFVwZGF0ZToqKiBDYWxscyBgdXBkYXRlSXRlbWAgdG8gYXBwbHkgdGhlIG5ldyBjb29yZGluYXRlcyB0byB0aGUgRE9NLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4MSAtIFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgaXRlbSB0byBzd2FwLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleDIgLSBUaGUgaW5kZXggb2YgdGhlIHNlY29uZCBpdGVtIHRvIHN3YXAuXG4gICAgICovXG4gICAgc3dpdGNoSXRlbXMoaW5kZXgxLCBpbmRleDIpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHJldmVyc2VkID0gbWUucmV2ZXJzZWRMYXlvdXREaXJlY3Rpb24sXG4gICAgICAgICAgICB0bXA7XG5cbiAgICAgICAgaWYgKCghcmV2ZXJzZWQgJiYgaW5kZXgyIDwgaW5kZXgxKSB8fCAocmV2ZXJzZWQgJiYgaW5kZXgxIDwgaW5kZXgyKSkge1xuICAgICAgICAgICAgdG1wICAgID0gaW5kZXgxO1xuICAgICAgICAgICAgaW5kZXgxID0gaW5kZXgyO1xuICAgICAgICAgICAgaW5kZXgyID0gdG1wXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaXRlbVJlY3RzID0gbWUuaXRlbVJlY3RzLFxuICAgICAgICAgICAgbWFwICAgICAgID0gbWUuaW5kZXhNYXAsXG4gICAgICAgICAgICByZWN0MSAgICAgPSBpdGVtUmVjdHNbaW5kZXgxXSxcbiAgICAgICAgICAgIHJlY3QyICAgICA9IGl0ZW1SZWN0c1tpbmRleDJdLFxuICAgICAgICAgICAgcmVjdDFDb3B5ID0gcmVjdDEuY2xvbmUoKSxcbiAgICAgICAgICAgIHJlY3QyQ29weSA9IHJlY3QyLmNsb25lKCk7XG5cbiAgICAgICAgaWYgKG1lLnNvcnREaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgY29uc3QgZ2FwID0gcmVjdDJDb3B5LnggLSAocmVjdDFDb3B5LnggKyByZWN0MUNvcHkud2lkdGgpO1xuXG4gICAgICAgICAgICByZWN0MS53aWR0aCA9IHJlY3QyQ29weS53aWR0aDtcbiAgICAgICAgICAgIHJlY3QyLnggICAgID0gcmVjdDFDb3B5LnggKyByZWN0MkNvcHkud2lkdGggKyBnYXA7XG4gICAgICAgICAgICByZWN0Mi53aWR0aCA9IHJlY3QxQ29weS53aWR0aFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZ2FwID0gcmVjdDJDb3B5LnkgLSAocmVjdDFDb3B5LnkgKyByZWN0MUNvcHkuaGVpZ2h0KTtcblxuICAgICAgICAgICAgcmVjdDEuaGVpZ2h0ID0gcmVjdDJDb3B5LmhlaWdodDtcbiAgICAgICAgICAgIHJlY3QyLmhlaWdodCA9IHJlY3QxQ29weS5oZWlnaHQ7XG4gICAgICAgICAgICByZWN0Mi55ICAgICAgPSByZWN0MUNvcHkueSArIHJlY3QyQ29weS5oZWlnaHQgKyBnYXBcbiAgICAgICAgfVxuXG4gICAgICAgIHRtcCAgICAgICAgID0gbWFwW2luZGV4MV07XG4gICAgICAgIG1hcFtpbmRleDFdID0gbWFwW2luZGV4Ml07XG4gICAgICAgIG1hcFtpbmRleDJdID0gdG1wO1xuXG4gICAgICAgIG1lLnVwZGF0ZUl0ZW0oaW5kZXgxLCByZWN0MSk7XG4gICAgICAgIG1lLnVwZGF0ZUl0ZW0oaW5kZXgyLCByZWN0MilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdFxuICAgICAqL1xuICAgIHVwZGF0ZUl0ZW0oaW5kZXgsIHJlY3QpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIG1hcHBlZEluZGV4ID0gbWUuaW5kZXhNYXBbaW5kZXhdLFxuICAgICAgICAgICAgaXRlbTtcblxuICAgICAgICBpZiAobWFwcGVkSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBpZiAobWUuZHJhZ1BsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IG1lLmRyYWdQbGFjZWhvbGRlclxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0gPSBtZS5vd25lci5pdGVtc1ttYXBwZWRJbmRleF07XG5cbiAgICAgICAgICAgIGlmIChtZS5kcmFnUGxhY2Vob2xkZXIgJiYgaXRlbSA9PT0gbWUuZHJhZ0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSBtZS5kcmFnUGxhY2Vob2xkZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB7d3JhcHBlclN0eWxlfSA9IGl0ZW07XG5cbiAgICAgICAgd3JhcHBlclN0eWxlLmxlZnQgPSBgJHtyZWN0LmxlZnR9cHhgO1xuICAgICAgICB3cmFwcGVyU3R5bGUudG9wICA9IGAke3JlY3QudG9wfXB4YDtcblxuICAgICAgICBpdGVtLndyYXBwZXJTdHlsZSA9IHdyYXBwZXJTdHlsZVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoU29ydFpvbmUpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9