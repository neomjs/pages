export const __webpack_esm_id__ = "src_canvas_Base_mjs";
export const __webpack_esm_ids__ = ["src_canvas_Base_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./src/canvas/Base.mjs"
/*!*****************************!*\
  !*** ./src/canvas/Base.mjs ***!
  \*****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @summary Abstract base class for Canvas Renderers.
 *
 * This class serves as the foundation for the specialized canvas visualizations (Header, Home, Services, Ticket)
 * that run within the **Neo.mjs Canvas SharedWorker**.
 *
 * It creates helper singletons that manage their own `OffscreenCanvas` instances, providing a standardized
 * architecture for:
 * - **Lifecycle Management:** Initialization (`initGraph`), destruction (`clearGraph`), and resource cleanup.
 * - **Render Loop Control:** Unified `render` loop with pause/resume capabilities and frame scheduling.
 * - **Context Management:** Robust handling of `OffscreenCanvas` transfer and context acquisition via `waitForCanvas`.
 * - **Shared State:** Common state management for mouse interaction, time, and theming.
 *
 * These renderers operate off the main thread to ensure high-performance, 60fps animations without
 * blocking the UI.
 *
 * @class Neo.canvas.Base
 * @extends Neo.core.Base
 */
class Base extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.canvas.Base'
         * @protected
         */
        className: 'Neo.canvas.Base',
        /**
         * Remote method access
         * @member {Object} remote
         * @protected
         */
        remote: {
            app: [
                'clearGraph',
                'initGraph',
                'pause',
                'resume',
                'setTheme',
                'updateMouseState',
                'updateSize'
            ]
        },
        /**
         * The active color theme ('light' or 'dark').
         * @member {String} theme_='light'
         * @reactive
         */
        theme_: 'light'
    }

    /**
     * @member {Number|null} animationId=null
     */
    animationId = null
    /**
     * @member {String|null} canvasId=null
     */
    canvasId = null
    /**
     * @member {Object|null} canvasSize=null
     */
    canvasSize = null
    /**
     * @member {OffscreenCanvasRenderingContext2D|null} context=null
     */
    context = null
    /**
     * Cache for reusable gradients to prevent GC.
     * @member {Object} gradients={}
     */
    gradients = {}
    /**
     * Flag to pause the render loop.
     * @member {Boolean} isPaused=false
     */
    isPaused = false
    /**
     * Tracked mouse position for interactive physics.
     * Initialize off-screen to prevent startup jitters.
     * @member {Object} mouse={x: -1000, y: -1000}
     */
    mouse = {x: -1000, y: -1000}
    /**
     * Global simulation time.
     * @member {Number} time=0
     */
    time = 0

    /**
     * @member {Function} renderLoop=this.render.bind(this)
     */
    renderLoop = this.render.bind(this)

    /**
     * Triggered after the `theme` config is changed.
     * Updates the resource cache (gradients, colors) to reflect the new theme immediately.
     * @param {String} value
     * @param {String} oldValue
     */
    afterSetTheme(value, oldValue) {
        if (value && this.canvasSize) {
            this.updateResources?.(this.canvasSize.width, this.canvasSize.height)
        }
    }

    /**
     * Checks if the canvas is ready to render.
     * Returns true only if the context exists and the simulation is not paused.
     * Subclasses should call this at the start of their `render` loop.
     * @returns {Boolean}
     */
    get canRender() {
        let me = this;
        return !!(me.context && !me.isPaused)
    }

    /**
     * Clears the graph state and stops the render loop.
     * Use this to cleanup resources when the component is destroyed or unmounted.
     */
    clearGraph() {
        let me = this;
        me.context     = null;
        me.canvasId    = null;
        me.canvasSize  = null;
        me.animationId = null;
        me.isPaused    = false;
        me.gradients   = {};
        me.mouse       = {x: -1000, y: -1000};
        me.time        = 0
    }

    /**
     * Initializes the canvas context.
     * Starts the polling mechanism to wait for the OffscreenCanvas transfer from the Main Thread.
     * @param {Object} opts
     * @param {String} opts.canvasId
     * @param {String} opts.windowId
     */
    initGraph({canvasId, windowId}) {
        let me        = this,
            hasChange = me.canvasId !== canvasId;

        me.canvasId = canvasId;

        me.waitForCanvas(canvasId, windowId, hasChange)
    }

    /**
     * Hook for subclasses to handle mouse clicks.
     * Called by `updateMouseState` when a click event is received.
     * @param {Object} data
     */
    onMouseClick(data) {}

    /**
     * Pauses the simulation.
     * The render loop will exit early while `isPaused` is true.
     */
    pause() {
        this.isPaused = true
    }

    /**
     * Abstract render method.
     * Subclasses must implement this method to draw the frame.
     */
    render() {}

    /**
     * Resumes the simulation.
     * If the simulation was paused, this restarts the render loop.
     */
    resume() {
        let me = this;

        if (me.isPaused) {
            me.isPaused = false;
            me.renderLoop()
        }
    }

    /**
     * Exposed method for Remote Access to trigger the reactive config setter.
     * @param {String} value
     */
    setTheme(value) {
        this.theme = value
    }

    /**
     * Updates the local mouse state from main thread events.
     * Delegates click events to `onMouseClick`.
     * @param {Object} data
     * @param {Boolean} [data.click]
     * @param {Boolean} [data.leave]
     * @param {Number} [data.x]
     * @param {Number} [data.y]
     */
    updateMouseState(data) {
        let me = this;

        if (data.leave) {
            me.mouse.x = -1000;
            me.mouse.y = -1000
        } else {
            if (data.x !== undefined) me.mouse.x = data.x;
            if (data.y !== undefined) me.mouse.y = data.y;

            if (data.click) {
                me.onMouseClick(data)
            }
        }
    }

    /**
     * Updates the canvas size and resizes the internal context.
     * Triggers `updateResources` hook to allow subclasses to regenerate buffers/gradients.
     * @param {Object} size
     * @param {Number} size.height
     * @param {Number} size.width
     */
    updateSize(size) {
        let me = this;

        me.canvasSize = size;

        if (me.context) {
            me.context.canvas.width  = size.width;
            me.context.canvas.height = size.height;
            // Calls the hook to re-generate resources if implemented
            me.updateResources?.(size.width, size.height)
        }
    }

    /**
     * Polls for the OffscreenCanvas until it is available in the Worker's `canvasWindowMap`.
     * Once found, it initializes the context and starts the render loop.
     * @param {String} canvasId
     * @param {String} windowId
     * @param {Boolean} hasChange
     * @protected
     */
    waitForCanvas(canvasId, windowId, hasChange) {
        let me     = this,
            canvas = Neo.currentWorker.canvasWindowMap[canvasId]?.[windowId];

        if (canvas) {
            me.context = canvas.getContext('2d');

            // Standardize size update
            me.updateSize({width: canvas.width, height: canvas.height});

            // Optional hook for subclasses
            me.onGraphMounted?.(canvas.width, canvas.height);

            if (hasChange && !me.animationId) {
                me.renderLoop()
            }
        } else {
            setTimeout(me.waitForCanvas.bind(me, canvasId, windowId, hasChange), 50)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Base));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2NhbnZhcy9zcmNfY2FudmFzX0Jhc2VfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0RBQU87QUFDMUI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdDQUF3QztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRLE9BQU87QUFDL0I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQiwyQ0FBMkM7O0FBRXRFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLG9CQUFvQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jYW52YXMvQmFzZS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE5lb0Jhc2UgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5cbi8qKlxuICogQHN1bW1hcnkgQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgQ2FudmFzIFJlbmRlcmVycy5cbiAqXG4gKiBUaGlzIGNsYXNzIHNlcnZlcyBhcyB0aGUgZm91bmRhdGlvbiBmb3IgdGhlIHNwZWNpYWxpemVkIGNhbnZhcyB2aXN1YWxpemF0aW9ucyAoSGVhZGVyLCBIb21lLCBTZXJ2aWNlcywgVGlja2V0KVxuICogdGhhdCBydW4gd2l0aGluIHRoZSAqKk5lby5tanMgQ2FudmFzIFNoYXJlZFdvcmtlcioqLlxuICpcbiAqIEl0IGNyZWF0ZXMgaGVscGVyIHNpbmdsZXRvbnMgdGhhdCBtYW5hZ2UgdGhlaXIgb3duIGBPZmZzY3JlZW5DYW52YXNgIGluc3RhbmNlcywgcHJvdmlkaW5nIGEgc3RhbmRhcmRpemVkXG4gKiBhcmNoaXRlY3R1cmUgZm9yOlxuICogLSAqKkxpZmVjeWNsZSBNYW5hZ2VtZW50OioqIEluaXRpYWxpemF0aW9uIChgaW5pdEdyYXBoYCksIGRlc3RydWN0aW9uIChgY2xlYXJHcmFwaGApLCBhbmQgcmVzb3VyY2UgY2xlYW51cC5cbiAqIC0gKipSZW5kZXIgTG9vcCBDb250cm9sOioqIFVuaWZpZWQgYHJlbmRlcmAgbG9vcCB3aXRoIHBhdXNlL3Jlc3VtZSBjYXBhYmlsaXRpZXMgYW5kIGZyYW1lIHNjaGVkdWxpbmcuXG4gKiAtICoqQ29udGV4dCBNYW5hZ2VtZW50OioqIFJvYnVzdCBoYW5kbGluZyBvZiBgT2Zmc2NyZWVuQ2FudmFzYCB0cmFuc2ZlciBhbmQgY29udGV4dCBhY3F1aXNpdGlvbiB2aWEgYHdhaXRGb3JDYW52YXNgLlxuICogLSAqKlNoYXJlZCBTdGF0ZToqKiBDb21tb24gc3RhdGUgbWFuYWdlbWVudCBmb3IgbW91c2UgaW50ZXJhY3Rpb24sIHRpbWUsIGFuZCB0aGVtaW5nLlxuICpcbiAqIFRoZXNlIHJlbmRlcmVycyBvcGVyYXRlIG9mZiB0aGUgbWFpbiB0aHJlYWQgdG8gZW5zdXJlIGhpZ2gtcGVyZm9ybWFuY2UsIDYwZnBzIGFuaW1hdGlvbnMgd2l0aG91dFxuICogYmxvY2tpbmcgdGhlIFVJLlxuICpcbiAqIEBjbGFzcyBOZW8uY2FudmFzLkJhc2VcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgQmFzZSBleHRlbmRzIE5lb0Jhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNhbnZhcy5CYXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY2FudmFzLkJhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3RlIG1ldGhvZCBhY2Nlc3NcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSByZW1vdGVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3RlOiB7XG4gICAgICAgICAgICBhcHA6IFtcbiAgICAgICAgICAgICAgICAnY2xlYXJHcmFwaCcsXG4gICAgICAgICAgICAgICAgJ2luaXRHcmFwaCcsXG4gICAgICAgICAgICAgICAgJ3BhdXNlJyxcbiAgICAgICAgICAgICAgICAncmVzdW1lJyxcbiAgICAgICAgICAgICAgICAnc2V0VGhlbWUnLFxuICAgICAgICAgICAgICAgICd1cGRhdGVNb3VzZVN0YXRlJyxcbiAgICAgICAgICAgICAgICAndXBkYXRlU2l6ZSdcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhY3RpdmUgY29sb3IgdGhlbWUgKCdsaWdodCcgb3IgJ2RhcmsnKS5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB0aGVtZV89J2xpZ2h0J1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHRoZW1lXzogJ2xpZ2h0J1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBhbmltYXRpb25JZD1udWxsXG4gICAgICovXG4gICAgYW5pbWF0aW9uSWQgPSBudWxsXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGNhbnZhc0lkPW51bGxcbiAgICAgKi9cbiAgICBjYW52YXNJZCA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gY2FudmFzU2l6ZT1udWxsXG4gICAgICovXG4gICAgY2FudmFzU2l6ZSA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPZmZzY3JlZW5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkR8bnVsbH0gY29udGV4dD1udWxsXG4gICAgICovXG4gICAgY29udGV4dCA9IG51bGxcbiAgICAvKipcbiAgICAgKiBDYWNoZSBmb3IgcmV1c2FibGUgZ3JhZGllbnRzIHRvIHByZXZlbnQgR0MuXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBncmFkaWVudHM9e31cbiAgICAgKi9cbiAgICBncmFkaWVudHMgPSB7fVxuICAgIC8qKlxuICAgICAqIEZsYWcgdG8gcGF1c2UgdGhlIHJlbmRlciBsb29wLlxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzUGF1c2VkPWZhbHNlXG4gICAgICovXG4gICAgaXNQYXVzZWQgPSBmYWxzZVxuICAgIC8qKlxuICAgICAqIFRyYWNrZWQgbW91c2UgcG9zaXRpb24gZm9yIGludGVyYWN0aXZlIHBoeXNpY3MuXG4gICAgICogSW5pdGlhbGl6ZSBvZmYtc2NyZWVuIHRvIHByZXZlbnQgc3RhcnR1cCBqaXR0ZXJzLlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gbW91c2U9e3g6IC0xMDAwLCB5OiAtMTAwMH1cbiAgICAgKi9cbiAgICBtb3VzZSA9IHt4OiAtMTAwMCwgeTogLTEwMDB9XG4gICAgLyoqXG4gICAgICogR2xvYmFsIHNpbXVsYXRpb24gdGltZS5cbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHRpbWU9MFxuICAgICAqL1xuICAgIHRpbWUgPSAwXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gcmVuZGVyTG9vcD10aGlzLnJlbmRlci5iaW5kKHRoaXMpXG4gICAgICovXG4gICAgcmVuZGVyTG9vcCA9IHRoaXMucmVuZGVyLmJpbmQodGhpcylcblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgYHRoZW1lYCBjb25maWcgaXMgY2hhbmdlZC5cbiAgICAgKiBVcGRhdGVzIHRoZSByZXNvdXJjZSBjYWNoZSAoZ3JhZGllbnRzLCBjb2xvcnMpIHRvIHJlZmxlY3QgdGhlIG5ldyB0aGVtZSBpbW1lZGlhdGVseS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhZnRlclNldFRoZW1lKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgJiYgdGhpcy5jYW52YXNTaXplKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVJlc291cmNlcz8uKHRoaXMuY2FudmFzU2l6ZS53aWR0aCwgdGhpcy5jYW52YXNTaXplLmhlaWdodClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgY2FudmFzIGlzIHJlYWR5IHRvIHJlbmRlci5cbiAgICAgKiBSZXR1cm5zIHRydWUgb25seSBpZiB0aGUgY29udGV4dCBleGlzdHMgYW5kIHRoZSBzaW11bGF0aW9uIGlzIG5vdCBwYXVzZWQuXG4gICAgICogU3ViY2xhc3NlcyBzaG91bGQgY2FsbCB0aGlzIGF0IHRoZSBzdGFydCBvZiB0aGVpciBgcmVuZGVyYCBsb29wLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGdldCBjYW5SZW5kZXIoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAhIShtZS5jb250ZXh0ICYmICFtZS5pc1BhdXNlZClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGdyYXBoIHN0YXRlIGFuZCBzdG9wcyB0aGUgcmVuZGVyIGxvb3AuXG4gICAgICogVXNlIHRoaXMgdG8gY2xlYW51cCByZXNvdXJjZXMgd2hlbiB0aGUgY29tcG9uZW50IGlzIGRlc3Ryb3llZCBvciB1bm1vdW50ZWQuXG4gICAgICovXG4gICAgY2xlYXJHcmFwaCgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcbiAgICAgICAgbWUuY29udGV4dCAgICAgPSBudWxsO1xuICAgICAgICBtZS5jYW52YXNJZCAgICA9IG51bGw7XG4gICAgICAgIG1lLmNhbnZhc1NpemUgID0gbnVsbDtcbiAgICAgICAgbWUuYW5pbWF0aW9uSWQgPSBudWxsO1xuICAgICAgICBtZS5pc1BhdXNlZCAgICA9IGZhbHNlO1xuICAgICAgICBtZS5ncmFkaWVudHMgICA9IHt9O1xuICAgICAgICBtZS5tb3VzZSAgICAgICA9IHt4OiAtMTAwMCwgeTogLTEwMDB9O1xuICAgICAgICBtZS50aW1lICAgICAgICA9IDBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgY2FudmFzIGNvbnRleHQuXG4gICAgICogU3RhcnRzIHRoZSBwb2xsaW5nIG1lY2hhbmlzbSB0byB3YWl0IGZvciB0aGUgT2Zmc2NyZWVuQ2FudmFzIHRyYW5zZmVyIGZyb20gdGhlIE1haW4gVGhyZWFkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdHMuY2FudmFzSWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy53aW5kb3dJZFxuICAgICAqL1xuICAgIGluaXRHcmFwaCh7Y2FudmFzSWQsIHdpbmRvd0lkfSkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGhhc0NoYW5nZSA9IG1lLmNhbnZhc0lkICE9PSBjYW52YXNJZDtcblxuICAgICAgICBtZS5jYW52YXNJZCA9IGNhbnZhc0lkO1xuXG4gICAgICAgIG1lLndhaXRGb3JDYW52YXMoY2FudmFzSWQsIHdpbmRvd0lkLCBoYXNDaGFuZ2UpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSG9vayBmb3Igc3ViY2xhc3NlcyB0byBoYW5kbGUgbW91c2UgY2xpY2tzLlxuICAgICAqIENhbGxlZCBieSBgdXBkYXRlTW91c2VTdGF0ZWAgd2hlbiBhIGNsaWNrIGV2ZW50IGlzIHJlY2VpdmVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Nb3VzZUNsaWNrKGRhdGEpIHt9XG5cbiAgICAvKipcbiAgICAgKiBQYXVzZXMgdGhlIHNpbXVsYXRpb24uXG4gICAgICogVGhlIHJlbmRlciBsb29wIHdpbGwgZXhpdCBlYXJseSB3aGlsZSBgaXNQYXVzZWRgIGlzIHRydWUuXG4gICAgICovXG4gICAgcGF1c2UoKSB7XG4gICAgICAgIHRoaXMuaXNQYXVzZWQgPSB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWJzdHJhY3QgcmVuZGVyIG1ldGhvZC5cbiAgICAgKiBTdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvIGRyYXcgdGhlIGZyYW1lLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHt9XG5cbiAgICAvKipcbiAgICAgKiBSZXN1bWVzIHRoZSBzaW11bGF0aW9uLlxuICAgICAqIElmIHRoZSBzaW11bGF0aW9uIHdhcyBwYXVzZWQsIHRoaXMgcmVzdGFydHMgdGhlIHJlbmRlciBsb29wLlxuICAgICAqL1xuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuaXNQYXVzZWQpIHtcbiAgICAgICAgICAgIG1lLmlzUGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICBtZS5yZW5kZXJMb29wKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4cG9zZWQgbWV0aG9kIGZvciBSZW1vdGUgQWNjZXNzIHRvIHRyaWdnZXIgdGhlIHJlYWN0aXZlIGNvbmZpZyBzZXR0ZXIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICovXG4gICAgc2V0VGhlbWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy50aGVtZSA9IHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgbG9jYWwgbW91c2Ugc3RhdGUgZnJvbSBtYWluIHRocmVhZCBldmVudHMuXG4gICAgICogRGVsZWdhdGVzIGNsaWNrIGV2ZW50cyB0byBgb25Nb3VzZUNsaWNrYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2RhdGEuY2xpY2tdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZGF0YS5sZWF2ZV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2RhdGEueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2RhdGEueV1cbiAgICAgKi9cbiAgICB1cGRhdGVNb3VzZVN0YXRlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoZGF0YS5sZWF2ZSkge1xuICAgICAgICAgICAgbWUubW91c2UueCA9IC0xMDAwO1xuICAgICAgICAgICAgbWUubW91c2UueSA9IC0xMDAwXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZGF0YS54ICE9PSB1bmRlZmluZWQpIG1lLm1vdXNlLnggPSBkYXRhLng7XG4gICAgICAgICAgICBpZiAoZGF0YS55ICE9PSB1bmRlZmluZWQpIG1lLm1vdXNlLnkgPSBkYXRhLnk7XG5cbiAgICAgICAgICAgIGlmIChkYXRhLmNsaWNrKSB7XG4gICAgICAgICAgICAgICAgbWUub25Nb3VzZUNsaWNrKGRhdGEpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBjYW52YXMgc2l6ZSBhbmQgcmVzaXplcyB0aGUgaW50ZXJuYWwgY29udGV4dC5cbiAgICAgKiBUcmlnZ2VycyBgdXBkYXRlUmVzb3VyY2VzYCBob29rIHRvIGFsbG93IHN1YmNsYXNzZXMgdG8gcmVnZW5lcmF0ZSBidWZmZXJzL2dyYWRpZW50cy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2l6ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzaXplLmhlaWdodFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzaXplLndpZHRoXG4gICAgICovXG4gICAgdXBkYXRlU2l6ZShzaXplKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuY2FudmFzU2l6ZSA9IHNpemU7XG5cbiAgICAgICAgaWYgKG1lLmNvbnRleHQpIHtcbiAgICAgICAgICAgIG1lLmNvbnRleHQuY2FudmFzLndpZHRoICA9IHNpemUud2lkdGg7XG4gICAgICAgICAgICBtZS5jb250ZXh0LmNhbnZhcy5oZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgICAgICAgICAgIC8vIENhbGxzIHRoZSBob29rIHRvIHJlLWdlbmVyYXRlIHJlc291cmNlcyBpZiBpbXBsZW1lbnRlZFxuICAgICAgICAgICAgbWUudXBkYXRlUmVzb3VyY2VzPy4oc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQb2xscyBmb3IgdGhlIE9mZnNjcmVlbkNhbnZhcyB1bnRpbCBpdCBpcyBhdmFpbGFibGUgaW4gdGhlIFdvcmtlcidzIGBjYW52YXNXaW5kb3dNYXBgLlxuICAgICAqIE9uY2UgZm91bmQsIGl0IGluaXRpYWxpemVzIHRoZSBjb250ZXh0IGFuZCBzdGFydHMgdGhlIHJlbmRlciBsb29wLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjYW52YXNJZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB3aW5kb3dJZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaGFzQ2hhbmdlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHdhaXRGb3JDYW52YXMoY2FudmFzSWQsIHdpbmRvd0lkLCBoYXNDaGFuZ2UpIHtcbiAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjYW52YXMgPSBOZW8uY3VycmVudFdvcmtlci5jYW52YXNXaW5kb3dNYXBbY2FudmFzSWRdPy5bd2luZG93SWRdO1xuXG4gICAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgICAgIG1lLmNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAgICAgLy8gU3RhbmRhcmRpemUgc2l6ZSB1cGRhdGVcbiAgICAgICAgICAgIG1lLnVwZGF0ZVNpemUoe3dpZHRoOiBjYW52YXMud2lkdGgsIGhlaWdodDogY2FudmFzLmhlaWdodH0pO1xuXG4gICAgICAgICAgICAvLyBPcHRpb25hbCBob29rIGZvciBzdWJjbGFzc2VzXG4gICAgICAgICAgICBtZS5vbkdyYXBoTW91bnRlZD8uKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgICAgICAgICAgIGlmIChoYXNDaGFuZ2UgJiYgIW1lLmFuaW1hdGlvbklkKSB7XG4gICAgICAgICAgICAgICAgbWUucmVuZGVyTG9vcCgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KG1lLndhaXRGb3JDYW52YXMuYmluZChtZSwgY2FudmFzSWQsIHdpbmRvd0lkLCBoYXNDaGFuZ2UpLCA1MClcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQmFzZSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=