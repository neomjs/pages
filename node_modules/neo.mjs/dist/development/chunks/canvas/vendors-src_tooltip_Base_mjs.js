export const __webpack_esm_id__ = "vendors-src_tooltip_Base_mjs";
export const __webpack_esm_ids__ = ["vendors-src_tooltip_Base_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./src/tooltip/Base.mjs"
/*!******************************!*\
  !*** ./src/tooltip/Base.mjs ***!
  \******************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _component_Label_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../component/Label.mjs */ "./src/component/Label.mjs");



let singletons = {};

/**
 * Base class for component tooltips
 * @class Neo.tooltip.Base
 * @extends Neo.container.Base
 */
class Tooltip extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.tooltip.Base'
         * @protected
         */
        className: 'Neo.tooltip.Base',
        /**
         * @member {String} ntype='tooltip'
         * @protected
         */
        ntype: 'tooltip',
        /**
         * @member {String[]} baseCls=['neo-tooltip']
         */
        baseCls: ['neo-tooltip'],
        /**
         * A reference to the target component which is supposed to show this tooltip on mouseenter
         * @member {String|null} componentId_=null
         * @reactive
         */
        componentId_: null,
        /**
         * Delegates down to a CSS selector inside the target component
         * @member {String|null} delegate=null
         */
        delegate: null,
        /**
         * The delay in ms before the tooltip gets hidden while hovering the target element.
         * Use null to disable the dismiss logic.
         * @member {Number|null} dismissDelay=10000
         */
        dismissDelay: 10000,
        /**
         * The dismissDelay task id generated by setTimeout()
         * @member {Number|null} dismissDelayTaskId=null
         * @protected
         */
        dismissDelayTaskId: null,
        /**
         * @member {Boolean} floating=true
         */
        floating: true,
        /**
         * The delay in ms before the tooltip gets shown
         * @member {Number|null} hideDelay=400
         */
        hideDelay: 400,
        /**
         * The showDelay task id generated by setTimeout()
         * @member {Number|null} hideDelayTaskId=null
         * @protected
         */
        hideDelayTaskId: null,
        /**
         * The delay in ms before the tooltip gets shown
         * @member {Number|null} showDelay=200
         */
        showDelay: 200,
        /**
         * The showDelay task id generated by setTimeout()
         * @member {Number|null} showDelayTaskId=null
         * @protected
         */
        showDelayTaskId: null,
        /**
         * True prevents the tooltip from hiding while the mouse cursor is above it
         * @member {Boolean|null} stayOnHover_=true
         * @reactive
         */
        stayOnHover_: true
    }

    /**
     * @param {String} id
     * @param {Function} callback
     * @param {Number} delay
     */
    addTimeout(id, callback, delay) {
        id += 'DelayTaskId';

        this.clearTimeout(this[id]);
        this[id] = setTimeout(callback, delay)
    }

    /**
     * Triggered after the componentId config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetComponentId(value, oldValue) {
        if (oldValue) {
            // todo: remove the component domListeners
        }

        if (value) {
            let me = this;

            Neo.getComponent(value).addDomListeners({
                mouseenter: me.onDelegateMouseEnter,
                mouseleave: me.onDelegateMouseLeave,
                delegate  : me.delegate,
                scope     : me
            })
        }
    }

    /**
     * Triggered after the stayOnHover config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetStayOnHover(value, oldValue) {
        if (oldValue) {
            // todo: remove the component domListeners
        }

        if (value) {
            let me = this;

            me.addDomListeners([
                {mouseenter: me.onMouseEnter, scope: me},
                {mouseleave: me.onMouseLeave, scope: me}
            ])
        }
    }

    /**
     * Triggered after the text config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetText(value, oldValue) {
        if (value) {
            let me    = this,
                items = me.items || [],
                item  = items[0];

            if (item?.ntype === 'label') {
                item.text = value
            } else {
                me.add({
                    module: _component_Label_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                    text  : value
                })
            }
        }
    }

    /**
     * Clears one or multiple setTimeout call(s)
     * @param {String[]|String} timers valid values: dismiss, hide, show
     */
    clearTimeout(timers) {
        if (!Array.isArray(timers)) {
            timers = [timers]
        }

        let me = this,
            id;

        timers.forEach(timer => {
            id = timer + 'DelayTaskId';

            if (me[id]) {
                clearTimeout(me[id]);
                me[id] = null
            }
        })
    }

    /**
     * @param {Neo.controller.Application} app
     * @returns {Neo.tooltip.Base}
     */
    static createSingleton(app) {
        if (!singletons[app.name]) {
            singletons[app.name] = Neo.create('Neo.tooltip.Base', {
                appName     : app.name,
                componentId : app.mainView.id,
                delegate    : this.delegateFilter,
                isShared    : true,
                resetCfg    : {},
                windowId    : app.mainView.windowId,
                listeners : {
                    // Reconfigure on over a target
                    targetOver({ target, data }) {
                        let me = this,
                            config, key;

                        // Revert last pointerOver config set to initial setting.
                        me.setSilent(me.resetCfg);
                        me.resetCfg = {};

                        // Use the tooltip config block that the target was configured with
                        // to reconfigure this instance, or if there was none, check the
                        // data-neo-tooltip property for a text string.
                        config = target?._tooltip || {text: data.target.data.neoTooltip};

                        // Cache things we have to reset
                        for (key in config) {
                            me.resetCfg[key] = me[key]
                        }

                        // Set ourself up as the target wants
                        me.set(config)
                    }
                }
            });
        }

        return singletons[app.name]
    }

    // Used as a delegate filter to activate on targets which have a tooltip configuration
    static delegateFilter(path) {
        for (let i = 0, { length } = path; i < length; i++) {
            if (path[i].cls.includes('neo-uses-shared-tooltip') || path[i].data['neoTooltip']) {
                return i
            }
        }
    }

    /**
     * Instantly hides the tooltip
     */
    hide() {
        let me = this;

        me.clearTimeout(['dismiss', 'hide', 'show']);
        me.mounted && me.unmount()
    }

    /**
     * Hides the tooltip using the given hideDelay
     * @param {Object|null} data
     */
    hideDelayed(data) {
        let me = this;

        if (me.hideDelay) {
            me.addTimeout('hide', me.hide.bind(me), me.hideDelay)
        } else {
            me.hide(data)
        }
    }

    /**
     * @param {Object} data
     */
    onDelegateMouseEnter(data) {
        let me              = this,
            {currentTarget} = data;

        // If it's an internal move within the delegate, do nothing
        if (currentTarget !== me.activeTarget?.id) {
            me.activeTarget = Neo.get(currentTarget);

            // Allow listeners (eg the Tooltip singleton) which is shared between all Components
            // listens for this in order to reconfigure itself from the activeTarget.
            // So this event must be fired before the alignment is set up.
            me.fire('targetOver', {
                target : me.activeTarget,
                data
            });

            me.align.target = currentTarget;
            me.align.targetMargin = 10;

            // Still visible, just realign
            if (me.mounted) {
                me.show();
                me.alignTo()
            } else {
                me.showDelayed(data)
            }
        }
    }

    /**
     * @param {Object} data
     */
    onDelegateMouseLeave(data) {
        let me = this;

        // If it's an internal move within the delegate, do nothing
        if (data.currentTarget === me.activeTarget?.id) {
            me.fire('targetOut', {
                target : me.activeTarget,
                data
            });

            me.activeTarget = null;
            me.hideDelayed(data)
        }
    }

    /**
     * mouseenter event listener for the tooltip element
     * @param {Object} data
     */
    onMouseEnter(data) {
        let me       = this,
            targetId = data.path[0].id;

        // only use path[0] based events to ignore mouseenter & leave for child nodes
        me.id === targetId && me.clearTimeout(['dismiss', 'hide'])
    }

    /**
     * mouseleave event listener for the tooltip element
     * @param {Object} data
     */
    onMouseLeave(data) {
        let me       = this,
            targetId = data.path[0].id;

        // only use path[0] based events to ignore mouseenter & leave for child nodes
        me.id === targetId && me.hideDelayed(null)
    }

    /**
     * Instantly shows the tooltip
     * @param {Object} data
     */
    show(data) {
        let me = this;

        me.showDelayTaskId = null;

        me.clearTimeout(['hide', 'dismiss']);

        if (me.dismissDelay) {
            me.addTimeout('dismiss', me.hide.bind(me), me.dismissDelay, data)
        }

        !me.mounted && me.initVnode(true)
    }

    /**
     * Shows the tooltip using the given showDelay
     * @param {Object} data
     */
    showDelayed(data) {
        let me = this;

        if (me.showDelay) {
            me.addTimeout('show', me.show.bind(me), me.showDelay)
        } else {
            me.show(data)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Tooltip));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2NhbnZhcy92ZW5kb3JzLXNyY190b29sdGlwX0Jhc2VfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEM7QUFDQzs7QUFFL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyREFBUztBQUMvQjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLHVDQUF1QztBQUN4RCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSw0QkFBNEIsNERBQUs7QUFDakM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLGVBQWUsNEJBQTRCO0FBQzNDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxjQUFjO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLFNBQVMsUUFBUSxZQUFZO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlOztBQUU1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLHVCQUF1QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy90b29sdGlwL0Jhc2UubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDb250YWluZXIgZnJvbSAnLi4vY29udGFpbmVyL0Jhc2UubWpzJztcbmltcG9ydCBMYWJlbCAgICAgZnJvbSAnLi4vY29tcG9uZW50L0xhYmVsLm1qcyc7XG5cbmxldCBzaW5nbGV0b25zID0ge307XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgY29tcG9uZW50IHRvb2x0aXBzXG4gKiBAY2xhc3MgTmVvLnRvb2x0aXAuQmFzZVxuICogQGV4dGVuZHMgTmVvLmNvbnRhaW5lci5CYXNlXG4gKi9cbmNsYXNzIFRvb2x0aXAgZXh0ZW5kcyBDb250YWluZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnRvb2x0aXAuQmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnRvb2x0aXAuQmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSd0b29sdGlwJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3Rvb2x0aXAnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tdG9vbHRpcCddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby10b29sdGlwJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgdGFyZ2V0IGNvbXBvbmVudCB3aGljaCBpcyBzdXBwb3NlZCB0byBzaG93IHRoaXMgdG9vbHRpcCBvbiBtb3VzZWVudGVyXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBjb21wb25lbnRJZF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGNvbXBvbmVudElkXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlbGVnYXRlcyBkb3duIHRvIGEgQ1NTIHNlbGVjdG9yIGluc2lkZSB0aGUgdGFyZ2V0IGNvbXBvbmVudFxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gZGVsZWdhdGU9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZGVsZWdhdGU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVsYXkgaW4gbXMgYmVmb3JlIHRoZSB0b29sdGlwIGdldHMgaGlkZGVuIHdoaWxlIGhvdmVyaW5nIHRoZSB0YXJnZXQgZWxlbWVudC5cbiAgICAgICAgICogVXNlIG51bGwgdG8gZGlzYWJsZSB0aGUgZGlzbWlzcyBsb2dpYy5cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IGRpc21pc3NEZWxheT0xMDAwMFxuICAgICAgICAgKi9cbiAgICAgICAgZGlzbWlzc0RlbGF5OiAxMDAwMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkaXNtaXNzRGVsYXkgdGFzayBpZCBnZW5lcmF0ZWQgYnkgc2V0VGltZW91dCgpXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBkaXNtaXNzRGVsYXlUYXNrSWQ9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBkaXNtaXNzRGVsYXlUYXNrSWQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBmbG9hdGluZz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBmbG9hdGluZzogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkZWxheSBpbiBtcyBiZWZvcmUgdGhlIHRvb2x0aXAgZ2V0cyBzaG93blxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gaGlkZURlbGF5PTQwMFxuICAgICAgICAgKi9cbiAgICAgICAgaGlkZURlbGF5OiA0MDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2hvd0RlbGF5IHRhc2sgaWQgZ2VuZXJhdGVkIGJ5IHNldFRpbWVvdXQoKVxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gaGlkZURlbGF5VGFza0lkPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaGlkZURlbGF5VGFza0lkOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRlbGF5IGluIG1zIGJlZm9yZSB0aGUgdG9vbHRpcCBnZXRzIHNob3duXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBzaG93RGVsYXk9MjAwXG4gICAgICAgICAqL1xuICAgICAgICBzaG93RGVsYXk6IDIwMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzaG93RGVsYXkgdGFzayBpZCBnZW5lcmF0ZWQgYnkgc2V0VGltZW91dCgpXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBzaG93RGVsYXlUYXNrSWQ9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzaG93RGVsYXlUYXNrSWQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIHByZXZlbnRzIHRoZSB0b29sdGlwIGZyb20gaGlkaW5nIHdoaWxlIHRoZSBtb3VzZSBjdXJzb3IgaXMgYWJvdmUgaXRcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbnxudWxsfSBzdGF5T25Ib3Zlcl89dHJ1ZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHN0YXlPbkhvdmVyXzogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5XG4gICAgICovXG4gICAgYWRkVGltZW91dChpZCwgY2FsbGJhY2ssIGRlbGF5KSB7XG4gICAgICAgIGlkICs9ICdEZWxheVRhc2tJZCc7XG5cbiAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQodGhpc1tpZF0pO1xuICAgICAgICB0aGlzW2lkXSA9IHNldFRpbWVvdXQoY2FsbGJhY2ssIGRlbGF5KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgY29tcG9uZW50SWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Q29tcG9uZW50SWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSkge1xuICAgICAgICAgICAgLy8gdG9kbzogcmVtb3ZlIHRoZSBjb21wb25lbnQgZG9tTGlzdGVuZXJzXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIE5lby5nZXRDb21wb25lbnQodmFsdWUpLmFkZERvbUxpc3RlbmVycyh7XG4gICAgICAgICAgICAgICAgbW91c2VlbnRlcjogbWUub25EZWxlZ2F0ZU1vdXNlRW50ZXIsXG4gICAgICAgICAgICAgICAgbW91c2VsZWF2ZTogbWUub25EZWxlZ2F0ZU1vdXNlTGVhdmUsXG4gICAgICAgICAgICAgICAgZGVsZWdhdGUgIDogbWUuZGVsZWdhdGUsXG4gICAgICAgICAgICAgICAgc2NvcGUgICAgIDogbWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHN0YXlPbkhvdmVyIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U3RheU9uSG92ZXIodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSkge1xuICAgICAgICAgICAgLy8gdG9kbzogcmVtb3ZlIHRoZSBjb21wb25lbnQgZG9tTGlzdGVuZXJzXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIG1lLmFkZERvbUxpc3RlbmVycyhbXG4gICAgICAgICAgICAgICAge21vdXNlZW50ZXI6IG1lLm9uTW91c2VFbnRlciwgc2NvcGU6IG1lfSxcbiAgICAgICAgICAgICAgICB7bW91c2VsZWF2ZTogbWUub25Nb3VzZUxlYXZlLCBzY29wZTogbWV9XG4gICAgICAgICAgICBdKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB0ZXh0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VGV4dCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGl0ZW1zID0gbWUuaXRlbXMgfHwgW10sXG4gICAgICAgICAgICAgICAgaXRlbSAgPSBpdGVtc1swXTtcblxuICAgICAgICAgICAgaWYgKGl0ZW0/Lm50eXBlID09PSAnbGFiZWwnKSB7XG4gICAgICAgICAgICAgICAgaXRlbS50ZXh0ID0gdmFsdWVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWUuYWRkKHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlOiBMYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dCAgOiB2YWx1ZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgb25lIG9yIG11bHRpcGxlIHNldFRpbWVvdXQgY2FsbChzKVxuICAgICAqIEBwYXJhbSB7U3RyaW5nW118U3RyaW5nfSB0aW1lcnMgdmFsaWQgdmFsdWVzOiBkaXNtaXNzLCBoaWRlLCBzaG93XG4gICAgICovXG4gICAgY2xlYXJUaW1lb3V0KHRpbWVycykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGltZXJzKSkge1xuICAgICAgICAgICAgdGltZXJzID0gW3RpbWVyc11cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBpZDtcblxuICAgICAgICB0aW1lcnMuZm9yRWFjaCh0aW1lciA9PiB7XG4gICAgICAgICAgICBpZCA9IHRpbWVyICsgJ0RlbGF5VGFza0lkJztcblxuICAgICAgICAgICAgaWYgKG1lW2lkXSkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChtZVtpZF0pO1xuICAgICAgICAgICAgICAgIG1lW2lkXSA9IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb250cm9sbGVyLkFwcGxpY2F0aW9ufSBhcHBcbiAgICAgKiBAcmV0dXJucyB7TmVvLnRvb2x0aXAuQmFzZX1cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlU2luZ2xldG9uKGFwcCkge1xuICAgICAgICBpZiAoIXNpbmdsZXRvbnNbYXBwLm5hbWVdKSB7XG4gICAgICAgICAgICBzaW5nbGV0b25zW2FwcC5uYW1lXSA9IE5lby5jcmVhdGUoJ05lby50b29sdGlwLkJhc2UnLCB7XG4gICAgICAgICAgICAgICAgYXBwTmFtZSAgICAgOiBhcHAubmFtZSxcbiAgICAgICAgICAgICAgICBjb21wb25lbnRJZCA6IGFwcC5tYWluVmlldy5pZCxcbiAgICAgICAgICAgICAgICBkZWxlZ2F0ZSAgICA6IHRoaXMuZGVsZWdhdGVGaWx0ZXIsXG4gICAgICAgICAgICAgICAgaXNTaGFyZWQgICAgOiB0cnVlLFxuICAgICAgICAgICAgICAgIHJlc2V0Q2ZnICAgIDoge30sXG4gICAgICAgICAgICAgICAgd2luZG93SWQgICAgOiBhcHAubWFpblZpZXcud2luZG93SWQsXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzIDoge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZWNvbmZpZ3VyZSBvbiBvdmVyIGEgdGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldE92ZXIoeyB0YXJnZXQsIGRhdGEgfSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcsIGtleTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2ZXJ0IGxhc3QgcG9pbnRlck92ZXIgY29uZmlnIHNldCB0byBpbml0aWFsIHNldHRpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5zZXRTaWxlbnQobWUucmVzZXRDZmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUucmVzZXRDZmcgPSB7fTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSB0b29sdGlwIGNvbmZpZyBibG9jayB0aGF0IHRoZSB0YXJnZXQgd2FzIGNvbmZpZ3VyZWQgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gcmVjb25maWd1cmUgdGhpcyBpbnN0YW5jZSwgb3IgaWYgdGhlcmUgd2FzIG5vbmUsIGNoZWNrIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGF0YS1uZW8tdG9vbHRpcCBwcm9wZXJ0eSBmb3IgYSB0ZXh0IHN0cmluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZyA9IHRhcmdldD8uX3Rvb2x0aXAgfHwge3RleHQ6IGRhdGEudGFyZ2V0LmRhdGEubmVvVG9vbHRpcH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIHRoaW5ncyB3ZSBoYXZlIHRvIHJlc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBjb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5yZXNldENmZ1trZXldID0gbWVba2V5XVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgb3Vyc2VsZiB1cCBhcyB0aGUgdGFyZ2V0IHdhbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5zZXQoY29uZmlnKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2luZ2xldG9uc1thcHAubmFtZV1cbiAgICB9XG5cbiAgICAvLyBVc2VkIGFzIGEgZGVsZWdhdGUgZmlsdGVyIHRvIGFjdGl2YXRlIG9uIHRhcmdldHMgd2hpY2ggaGF2ZSBhIHRvb2x0aXAgY29uZmlndXJhdGlvblxuICAgIHN0YXRpYyBkZWxlZ2F0ZUZpbHRlcihwYXRoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCB7IGxlbmd0aCB9ID0gcGF0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocGF0aFtpXS5jbHMuaW5jbHVkZXMoJ25lby11c2VzLXNoYXJlZC10b29sdGlwJykgfHwgcGF0aFtpXS5kYXRhWyduZW9Ub29sdGlwJ10pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zdGFudGx5IGhpZGVzIHRoZSB0b29sdGlwXG4gICAgICovXG4gICAgaGlkZSgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5jbGVhclRpbWVvdXQoWydkaXNtaXNzJywgJ2hpZGUnLCAnc2hvdyddKTtcbiAgICAgICAgbWUubW91bnRlZCAmJiBtZS51bm1vdW50KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIaWRlcyB0aGUgdG9vbHRpcCB1c2luZyB0aGUgZ2l2ZW4gaGlkZURlbGF5XG4gICAgICogQHBhcmFtIHtPYmplY3R8bnVsbH0gZGF0YVxuICAgICAqL1xuICAgIGhpZGVEZWxheWVkKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuaGlkZURlbGF5KSB7XG4gICAgICAgICAgICBtZS5hZGRUaW1lb3V0KCdoaWRlJywgbWUuaGlkZS5iaW5kKG1lKSwgbWUuaGlkZURlbGF5KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUuaGlkZShkYXRhKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkRlbGVnYXRlTW91c2VFbnRlcihkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2N1cnJlbnRUYXJnZXR9ID0gZGF0YTtcblxuICAgICAgICAvLyBJZiBpdCdzIGFuIGludGVybmFsIG1vdmUgd2l0aGluIHRoZSBkZWxlZ2F0ZSwgZG8gbm90aGluZ1xuICAgICAgICBpZiAoY3VycmVudFRhcmdldCAhPT0gbWUuYWN0aXZlVGFyZ2V0Py5pZCkge1xuICAgICAgICAgICAgbWUuYWN0aXZlVGFyZ2V0ID0gTmVvLmdldChjdXJyZW50VGFyZ2V0KTtcblxuICAgICAgICAgICAgLy8gQWxsb3cgbGlzdGVuZXJzIChlZyB0aGUgVG9vbHRpcCBzaW5nbGV0b24pIHdoaWNoIGlzIHNoYXJlZCBiZXR3ZWVuIGFsbCBDb21wb25lbnRzXG4gICAgICAgICAgICAvLyBsaXN0ZW5zIGZvciB0aGlzIGluIG9yZGVyIHRvIHJlY29uZmlndXJlIGl0c2VsZiBmcm9tIHRoZSBhY3RpdmVUYXJnZXQuXG4gICAgICAgICAgICAvLyBTbyB0aGlzIGV2ZW50IG11c3QgYmUgZmlyZWQgYmVmb3JlIHRoZSBhbGlnbm1lbnQgaXMgc2V0IHVwLlxuICAgICAgICAgICAgbWUuZmlyZSgndGFyZ2V0T3ZlcicsIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgOiBtZS5hY3RpdmVUYXJnZXQsXG4gICAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLmFsaWduLnRhcmdldCA9IGN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICBtZS5hbGlnbi50YXJnZXRNYXJnaW4gPSAxMDtcblxuICAgICAgICAgICAgLy8gU3RpbGwgdmlzaWJsZSwganVzdCByZWFsaWduXG4gICAgICAgICAgICBpZiAobWUubW91bnRlZCkge1xuICAgICAgICAgICAgICAgIG1lLnNob3coKTtcbiAgICAgICAgICAgICAgICBtZS5hbGlnblRvKClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWUuc2hvd0RlbGF5ZWQoZGF0YSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25EZWxlZ2F0ZU1vdXNlTGVhdmUoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIC8vIElmIGl0J3MgYW4gaW50ZXJuYWwgbW92ZSB3aXRoaW4gdGhlIGRlbGVnYXRlLCBkbyBub3RoaW5nXG4gICAgICAgIGlmIChkYXRhLmN1cnJlbnRUYXJnZXQgPT09IG1lLmFjdGl2ZVRhcmdldD8uaWQpIHtcbiAgICAgICAgICAgIG1lLmZpcmUoJ3RhcmdldE91dCcsIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgOiBtZS5hY3RpdmVUYXJnZXQsXG4gICAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLmFjdGl2ZVRhcmdldCA9IG51bGw7XG4gICAgICAgICAgICBtZS5oaWRlRGVsYXllZChkYXRhKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbW91c2VlbnRlciBldmVudCBsaXN0ZW5lciBmb3IgdGhlIHRvb2x0aXAgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Nb3VzZUVudGVyKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHRhcmdldElkID0gZGF0YS5wYXRoWzBdLmlkO1xuXG4gICAgICAgIC8vIG9ubHkgdXNlIHBhdGhbMF0gYmFzZWQgZXZlbnRzIHRvIGlnbm9yZSBtb3VzZWVudGVyICYgbGVhdmUgZm9yIGNoaWxkIG5vZGVzXG4gICAgICAgIG1lLmlkID09PSB0YXJnZXRJZCAmJiBtZS5jbGVhclRpbWVvdXQoWydkaXNtaXNzJywgJ2hpZGUnXSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtb3VzZWxlYXZlIGV2ZW50IGxpc3RlbmVyIGZvciB0aGUgdG9vbHRpcCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbk1vdXNlTGVhdmUoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgdGFyZ2V0SWQgPSBkYXRhLnBhdGhbMF0uaWQ7XG5cbiAgICAgICAgLy8gb25seSB1c2UgcGF0aFswXSBiYXNlZCBldmVudHMgdG8gaWdub3JlIG1vdXNlZW50ZXIgJiBsZWF2ZSBmb3IgY2hpbGQgbm9kZXNcbiAgICAgICAgbWUuaWQgPT09IHRhcmdldElkICYmIG1lLmhpZGVEZWxheWVkKG51bGwpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zdGFudGx5IHNob3dzIHRoZSB0b29sdGlwXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBzaG93KGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5zaG93RGVsYXlUYXNrSWQgPSBudWxsO1xuXG4gICAgICAgIG1lLmNsZWFyVGltZW91dChbJ2hpZGUnLCAnZGlzbWlzcyddKTtcblxuICAgICAgICBpZiAobWUuZGlzbWlzc0RlbGF5KSB7XG4gICAgICAgICAgICBtZS5hZGRUaW1lb3V0KCdkaXNtaXNzJywgbWUuaGlkZS5iaW5kKG1lKSwgbWUuZGlzbWlzc0RlbGF5LCBkYXRhKVxuICAgICAgICB9XG5cbiAgICAgICAgIW1lLm1vdW50ZWQgJiYgbWUuaW5pdFZub2RlKHRydWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hvd3MgdGhlIHRvb2x0aXAgdXNpbmcgdGhlIGdpdmVuIHNob3dEZWxheVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgc2hvd0RlbGF5ZWQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5zaG93RGVsYXkpIHtcbiAgICAgICAgICAgIG1lLmFkZFRpbWVvdXQoJ3Nob3cnLCBtZS5zaG93LmJpbmQobWUpLCBtZS5zaG93RGVsYXkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5zaG93KGRhdGEpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFRvb2x0aXApO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9