"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-apps_portal_canvas_HeaderCanvas_mjs"],{

/***/ "./apps/portal/canvas/HeaderCanvas.mjs"
/*!*********************************************!*\
  !*** ./apps/portal/canvas/HeaderCanvas.mjs ***!
  \*********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/core/Base.mjs */ "./src/core/Base.mjs");


const
    PRIMARY   = '#3E63DD',
    SECONDARY = '#8BA6FF',
    HIGHLIGHT = '#40C4FF';

/**
 * @summary SharedWorker renderer for the HeaderToolbar overlay.
 *
 * Implements the **"Luminous Flux"** visual theme, an ambient, interactive energy simulation that
 * serves as the backdrop for the Portal header.
 *
 * **Visual Architecture:**
 * 1. **Neo Ether (Background):** A volumetric particle field composed of faint "dust" and larger "nebula" orbs.
 *    This provides atmospheric depth, fluid interactivity (mouse repulsion), and bridges the contrast gap
 *    between the white background and the foreground elements.
 * 2. **Ambient Helix (Midground):** A large-scale, slow-moving sine wave pattern that provides structural
 *    texture to the negative space. Now enhanced with a **volumetric Ribbon fill** to add depth.
 * 3. **Split Stream (Foreground):** Two intertwined energy strands (Helix/DNA) that flow across the canvas.
 *    - **3D Ribbon Effect:** A subtle gradient fills the space between strands, simulating a twisting surface.
  *   - **Neon Tube Effect:** Strands are rendered with a bright white core inside a colored glow, creating a physical light-emitting look.
  *   - **Adaptive Geometry:** The strands flow loosely around text buttons but tighten into a "high-gravity orbit"
  *     around social icons.
  *   - **Energy Surge (Active State):** The segment of the stream passing through the active navigation item
  *     is rendered with a high-intensity white glow and a nervous pulse, semantically highlighting the current view.
  *
  * **Performance Architecture (Zero-Allocation):**
 * To maintain 60fps on high-refresh displays without GC stutters, this class employs a **Zero-Allocation** strategy during the render loop.
 * 1. **TypedArray Buffers:** Wave geometry is stored in pre-allocated `Float32Array` buffers (`waveBuffers`), reused every frame.
 * 2. **Gradient Caching:** CanvasGradients are created only on resize (`updateResources`) and cached, avoiding expensive generator calls per frame.
 * 3. **Reusable Objects:** Physics calculations write directly to buffers instead of returning new Arrays of Objects.
 *
 * @class Portal.canvas.HeaderCanvas
 * @extends Neo.core.Base
 * @singleton
 * @see Portal.view.HeaderCanvas
 */
class HeaderCanvas extends _src_core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.canvas.HeaderCanvas'
         * @protected
         */
        className: 'Portal.canvas.HeaderCanvas',
        /**
         * Remote method access
         * @member {Object} remote
         * @protected
         */
        remote: {
            app: [
                'clearGraph',
                'initGraph',
                'updateActiveId',
                'updateGraphData',
                'updateMouseState',
                'updateNavRects',
                'updateSize'
            ]
        },
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * @member {String|null} activeId=null
     */
    activeId = null
    /**
     * @member {Number|null} animationId=null
     */
    animationId = null
    /**
     * @member {String|null} canvasId=null
     */
    canvasId = null
    /**
     * @member {Object|null} canvasSize=null
     */
    canvasSize = null
    /**
     * @member {Object|null} context=null
     */
    context = null
    /**
     * @member {Object} gradients={}
     */
    gradients = {}
    /**
     * @member {Object} mouse={x: -1000, y: -1000}
     */
    mouse = {x: -1000, y: -1000}
    /**
     * @member {Object[]} navRects=[]
     */
    navRects = []
    /**
     * @member {Object[]} particles=[]
     */
    particles = []
    /**
     * @member {Object[]} shockwaves=[]
     */
    shockwaves = []
    /**
     * @member {Number} time=0
     */
    time = 0
    /**
     * Pre-allocated buffers for wave geometry.
     * Uses `Float32Array` to eliminate Garbage Collection pressure during the render loop.
     * @member {Object} waveBuffers={bgA: null, bgB: null, fgA: null, fgB: null}
     */
    waveBuffers = {bgA: null, bgB: null, fgA: null, fgB: null}

    /**
     * Clears the graph state and stops the render loop.
     */
    clearGraph() {
        let me = this;
        me.context     = null;
        me.canvasId    = null;
        me.canvasSize  = null;
        me.navRects    = [];
        me.particles   = [];
        me.shockwaves  = [];
        me.waveBuffers = {bgA: null, bgB: null, fgA: null, fgB: null};
        me.gradients   = {}
    }

    /**
     * Initializes the canvas context.
     * @param {Object} opts
     * @param {String} opts.canvasId
     * @param {String} opts.windowId
     */
    initGraph({canvasId, windowId}) {
        let me        = this,
            hasChange = me.canvasId !== canvasId;

        me.canvasId = canvasId;

        const checkCanvas = () => {
            const canvas = Neo.currentWorker.canvasWindowMap[canvasId]?.[windowId];

            if (canvas) {
                me.context = canvas.getContext('2d');
                me.initParticles(canvas.width, canvas.height); // Init particles
                me.updateResources(canvas.width, canvas.height); // Init buffers/gradients
                hasChange && me.renderLoop()
            } else {
                setTimeout(checkCanvas, 50)
            }
        };
        checkCanvas()
    }

    /**
     * Initializes the particle system for the "Neo Ether" effect.
     *
     * Creates a mix of large, slow-moving "nebula" particles and smaller, faster "dust" particles
     * to create depth and atmosphere.
     *
     * @param {Number} width
     * @param {Number} height
     */
    initParticles(width, height) {
        let me = this;
        me.particles = [];
        const count = 60;

        for (let i = 0; i < count; i++) {
            let isNebula = Math.random() > 0.8; // 20% are large nebula orbs

            me.particles.push({
                isNebula,
                x        : Math.random() * width,
                y        : Math.random() * height,
                vx       : isNebula ? (Math.random() * 0.2 + 0.05) : (Math.random() * 0.5 + 0.1), // Nebulae move slower
                vy       : (Math.random() - 0.5) * 0.2,
                size     : isNebula ? (Math.random() * 30 + 20) : (Math.random() * 2 + 0.5), // Large vs Small
                alpha    : isNebula ? (Math.random() * 0.15 + 0.2) : (Math.random() * 0.4 + 0.2), // BOOSTED ALPHA
                baseAlpha: isNebula ? (Math.random() * 0.15 + 0.2) : (Math.random() * 0.4 + 0.2)
            })
        }
    }

    /**
     * @member {Function} renderLoop=this.render.bind(this)
     */
    renderLoop = this.render.bind(this)

    /**
     * Main render loop.
     *
     * Orchestrates the rendering of all visual layers:
     * 1. Ambient Background (Ribbon + Helix)
     * 2. Neo Ether (Particles)
     * 3. Split Stream (Foreground Auras)
     * 4. Shockwaves (Interaction)
     *
     * Uses `setTimeout` instead of `requestAnimationFrame` because this runs in a SharedWorker
     * where `rAF` is not available. Targets ~60fps (16ms).
     */
    render() {
        let me = this;

        if (!me.context) {
            return
        }

        const
            ctx    = me.context,
            width  = me.canvasSize?.width  || 100,
            height = me.canvasSize?.height || 50;

        me.time += 0.05;

        // Auto-reinit particles if size changes significantly or empty OR count mismatch (config update)
        if (me.particles.length !== 60) {
            me.initParticles(width, height)
        }

        ctx.clearRect(0, 0, width, height);

        // 1. Draw Ambient Background
        me.drawAmbientBackground(ctx, width, height);

        // 2. Draw Ether Particles (Background Layer)
        me.drawParticles(ctx, width, height);

        // 3. Draw "Auras" (Hover Effects) => 3D Ribbon + Neon Tube
        me.drawAuras(ctx, width, height);

        // 3b. Draw Active Overlay
        me.drawActiveOverlay(ctx, width);

        // 4. Draw "Shockwaves" (Click Effects)
        me.drawShockwaves(ctx, width);

        setTimeout(me.renderLoop, 1000 / 60)
    }

    /**
     * Calculates the points for the two energy strands based on physics and interaction.
     *
     * **Zero-Allocation Contract:**
     * This method writes directly to the pre-allocated `this.waveBuffers` `Float32Array`s.
     * It does **not** allocate new arrays or objects, ensuring zero GC pressure.
     *
     * @param {Number} width
     * @param {Number} height
     * @returns {Object} {shimmerA, shimmerB, count} Metadata for rendering (scalars only)
     */
    calculateStrandGeometry(width, height) {
        let me = this;

        if (!Array.isArray(me.navRects) || !me.waveBuffers.fgA) {
            return null
        }

        const
            bufA    = me.waveBuffers.fgA,
            bufB    = me.waveBuffers.fgB,
            step    = 2,
            count   = Math.ceil(width / step),
            centerY = height / 2,
            padding = 10,
            maxH    = (height - (padding * 2)) / 2,
            // BREATHING: Modulate base amplitude over time (slow pulse)
            breath   = Math.sin(me.time * 0.5) * 2,
            baseAmp  = Math.min(6 + breath, maxH),
            hoverAmp = 4;

        // REF 1: Linked Phase - Shimmer leads Breath by 90deg ("Charging up")
        let baseShimmer = 0.75 + (Math.sin(me.time * 0.5 + Math.PI / 2) * 0.25);

        // REF 2: Independent Strand Shimmer
        let shimmerA = baseShimmer,
            shimmerB = 0.75 + (Math.sin(me.time * 0.5 + Math.PI / 2 + Math.PI / 3) * 0.25);

        for (let i = 0; i < count; i++) {
            let x = i * step,
                {offsetY, intensity, isIconZone} = me.getStreamOffset(x, height);

            // FREQUENCY MODULATION:
            let freqMod   = Math.sin(x * 0.002 + me.time * 0.1) * (20 + (intensity * 10)),
                timeShift = me.time * 2;

            // DAMPING FOR ICONS:
            let localAmp = baseAmp * (1 - (isIconZone * 0.6));

            // Noise Calculation
            // We calculate noise once per frame per point to ensure that the Ribbon Fill and
            // Neon Stroke passes use identical geometry, preventing visual tearing.
            let noiseA = (Math.random() - 0.5) * hoverAmp * intensity,
                noiseB = (Math.random() - 0.5) * hoverAmp * intensity,
                sine   = Math.sin(((x + freqMod) * 0.04) - timeShift) * localAmp,
                sineB  = Math.sin(((x + freqMod) * 0.04) - timeShift + Math.PI) * localAmp; // Inverted

            // SHOCKWAVE PHYSICS (Displacement)
            let shockY = 0;
            if (me.shockwaves.length > 0) {
                me.shockwaves.forEach(wave => {
                    let radius = wave.age * wave.speed,
                        dist   = x - wave.x; // Signed distance

                    // Check if point is near the wave front (e.g. within 50px)
                    if (Math.abs(dist) < radius && Math.abs(dist) > radius - 60) {
                        // Pulse shape: Sine wave based on distance from center relative to radius
                        let pulse = Math.sin((dist / radius) * Math.PI * 10) * (1 - (wave.age / wave.life)) * 20;
                        shockY += pulse
                    }
                })
            }

            // Write Y values to buffers
            bufA[i] = centerY + sine - offsetY + noiseA + shockY;
            bufB[i] = centerY + sineB + offsetY + noiseB + shockY;
        }

        return {shimmerA, shimmerB, count}
    }

    /**
     * Draws the "Ether" particle field to add volumetric depth and interactivity.
     *
     * **Intent:**
     * Creates a living, breathing atmosphere ("Neo Ether") that fills the negative space.
     * This bridges the visual gap between the stark white background and the high-contrast foreground lines.
     *
     * **Physics:**
     * - **Drift:** Particles move with a constant `vx` to simulate data flow or wind.
     * - **Repulsion:** The mouse cursor acts as a "repulsor field," pushing particles away and brightening them
     *   to create a "hole" in the fog.
     * - **Nebulae:** Large, faint particles create a "fog" effect, while small, bright particles act as "dust."
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {Number} width
     * @param {Number} height
     */
    drawParticles(ctx, width, height) {
        let me = this;

        me.particles.forEach(p => {
            // Update Position
            p.x += p.vx;
            p.y += p.vy;

            // Wrap around
            if (p.x > width + p.size) p.x = -p.size;
            if (p.x < -p.size)        p.x = width + p.size;
            if (p.y > height + p.size) p.y = -p.size;
            if (p.y < -p.size)         p.y = height + p.size;

            // Interaction: Mouse Repulsion
            // All particles react to the mouse, but "Nebula" particles have higher calculated mass,
            // resulting in less displacement than the lighter "Dust" particles.
            let dx = p.x - me.mouse.x,
                dy = p.y - me.mouse.y,
                dist = Math.sqrt(dx*dx + dy*dy),
                maxDist = p.isNebula ? 150 : 100;

            if (dist < maxDist && dist > 0) {
                let force = (maxDist - dist) / maxDist;
                // Push away
                let mass = p.isNebula ? 5 : 1;
                p.x += (dx / dist) * force * (2 / mass);
                p.y += (dy / dist) * force * (2 / mass);
                // Brighten slightly
                p.alpha = Math.min(p.baseAlpha + force * (p.isNebula ? 0.05 : 0.5), 0.8);
            }

            // Interaction: Shockwave Repulsion
            if (me.shockwaves.length > 0) {
                me.shockwaves.forEach(wave => {
                    let wx     = p.x - wave.x,
                        wy     = p.y - wave.y,
                        wDist  = Math.sqrt(wx * wx + wy * wy),
                        radius = wave.age * wave.speed;

                    // If particle is near the expanding ring (width 40px)
                    if (wDist < radius && wDist > radius - 40) {
                        let force = (1 - (wave.age / wave.life)) * 2; // Decay force over time
                        // Push outward
                        p.x += (wx / wDist) * force * 5;
                        p.y += (wy / wDist) * force * 5;
                        p.alpha = Math.min(p.alpha + 0.3, 1) // Flash bright
                    }
                })
            }

            // Return to base alpha
            if (p.alpha > p.baseAlpha) {
                p.alpha -= 0.005
            }

            ctx.globalAlpha = p.alpha;
            ctx.beginPath();

            if (p.isNebula) {
                // Nebula Visualization
                // Use a radial gradient to create a soft, cloud-like appearance.
                let g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
                g.addColorStop(0, HIGHLIGHT);
                g.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = g;
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill()
            } else {
                ctx.fillStyle = HIGHLIGHT;
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill()
            }
        });

        ctx.globalAlpha = 1
    }

    /**
     * Draws an additional highlight for the active navigation item.
     * **"Energy Surge" Effect:**
     * Renders a high-intensity pass of the energy strands *only* within the active zone.
     * This makes the lines appear to "power up" or glow white-hot as they pass through the active view,
     * fully integrated with the existing geometry.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {Number} width
     */
    drawActiveOverlay(ctx, width) {
        let me = this;

        if (!me.activeId || !me.waveBuffers.fgA) return;

        const rect = me.navRects.find(r => r.id === me.activeId);
        if (!rect) return;

        const
            step   = 2, // Must match calculateStrandGeometry
            // Add padding to fade the effect in/out smoothly
            pad    = 10,
            startX = Math.max(0, rect.x - pad),
            endX   = Math.min(width, rect.x + rect.width + pad),
            startI = Math.floor(startX / step),
            endI   = Math.ceil(endX / step),
            bufA   = me.waveBuffers.fgA,
            bufB   = me.waveBuffers.fgB;

        ctx.save();
        ctx.lineCap  = 'round';
        ctx.lineJoin = 'round';

        // High-Intensity Glow
        ctx.shadowBlur  = 20;
        ctx.shadowColor = '#FFFFFF'; // White glow
        ctx.strokeStyle = '#FFFFFF'; // White core
        ctx.lineWidth   = 2;

        // Gradient Fade mask (manual alpha)
        // We can't easily gradient-stroke a sub-path, so we rely on globalAlpha
        // combined with the "hot" white color to make it pop.
        ctx.globalAlpha = 0.6 + (Math.sin(me.time * 3) * 0.2); // Fast, nervous pulse

        const drawSegment = (buffer) => {
            ctx.beginPath();
            ctx.moveTo(startI * step, buffer[startI]);
            for (let i = startI + 1; i <= endI; i++) {
                ctx.lineTo(i * step, buffer[i])
            }
            ctx.stroke()
        };

        drawSegment(bufA);
        drawSegment(bufB);

        ctx.restore()
    }

    /**
     * Draws a subtle, large-scale background Helix pattern with a 3D Ribbon effect.
     *
     * **Intent:**
     * Provides a structural backbone to the negative space. Unlike the particle field (which is chaotic),
     * this layer is ordered and rhythmic, reinforcing the "DNA/Helix" theme even in the background.
     *
     * **Visuals:**
     * 1. **Ribbon Fill:** A barely-visible volumetric gradient fills the space between the helices.
     * 2. **Depth of Field:** Uses wide, very low opacity strokes to appear "out of focus" behind the sharp foreground.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {Number} width
     * @param {Number} height
     */
    drawAmbientBackground(ctx, width, height) {
        let me = this;

        // Ensure buffers exist
        if (!me.waveBuffers.bgA) return;

        let t       = me.time * 0.5,
            centerY = height / 2,
            amp     = height * 0.4,
            step    = 10,
            count   = Math.ceil(width / step),
            bufA    = me.waveBuffers.bgA,
            bufB    = me.waveBuffers.bgB;

        // 1. Calculate Points (Direct to Buffer)
        for (let i = 0; i < count; i++) {
            let x = i * step;
            bufA[i] = centerY + Math.sin((x * 0.01) + t) * amp;
            bufB[i] = centerY + Math.sin((x * 0.01) + t + Math.PI) * amp
        }

        // --- 2. RIBBON FILL (Background Surface) ---
        ctx.fillStyle = me.gradients.bgRibbon;
        ctx.beginPath();

        ctx.moveTo(0, bufA[0]);
        for (let i = 1; i < count; i++) {
            ctx.lineTo(i * step, bufA[i])
        }

        for (let i = count - 1; i >= 0; i--) {
            ctx.lineTo(i * step, bufB[i])
        }
        ctx.closePath();
        ctx.fill();

        // --- 3. STROKES ---
        ctx.lineWidth = 15;
        ctx.lineCap   = 'round';
        ctx.lineJoin  = 'round';

        // Use cached gradients
        const drawStroke = (buffer, strokeStyle) => {
            ctx.strokeStyle = strokeStyle;
            ctx.beginPath();
            ctx.moveTo(0, buffer[0]);
            for (let i = 1; i < count; i++) {
                ctx.lineTo(i * step, buffer[i])
            }
            ctx.stroke()
        };

        drawStroke(bufA, me.gradients.bgGrad1);
        drawStroke(bufB, me.gradients.bgGrad2);
    }

    /**
     * Draws the main foreground "Split Stream" energy strands with 3D effects.
     *
     * **3D Architecture:**
     * 1. **Ribbon Fill:** Draws a low-opacity gradient between Strand A and Strand B, creating a twisting surface.
     * 2. **Neon Tube (Outer):** The colored glow of the strands.
     * 3. **Neon Tube (Core):** A bright white inner core to simulate volumetric light.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {Number} width
     * @param {Number} height
     */
    drawAuras(ctx, width, height) {
        let me = this;

        if (!Array.isArray(me.navRects)) return;

        // 1. Calculate Physics (Shared for Ribbon and Strands) - Returns metadata, data is in buffers
        const geometry = me.calculateStrandGeometry(width, height);

        if (!geometry) return;

        const
            {shimmerA, shimmerB, count} = geometry,
            bufA = me.waveBuffers.fgA,
            bufB = me.waveBuffers.fgB,
            step = 2;

        // --- 2. RIBBON FILL (The 3D Surface) ---
        ctx.fillStyle = me.gradients.fgRibbon;
        ctx.beginPath();

        ctx.moveTo(0, bufA[0]);
        for (let i = 1; i < count; i++) {
            ctx.lineTo(i * step, bufA[i]);
        }

        for (let i = count - 1; i >= 0; i--) {
            ctx.lineTo(i * step, bufB[i]);
        }
        ctx.closePath();
        ctx.fill();

        // --- 3. NEON STRANDS (Tube Effect) ---

        ctx.lineCap     = 'round';
        ctx.lineJoin    = 'round';

        // Helper to draw a strand from buffer
        const drawStrand = (buffer, gradient, shimmer, color, isCore) => {
            ctx.beginPath();
            ctx.strokeStyle = isCore ? '#FFFFFF' : gradient;
            ctx.lineWidth   = isCore ? 1 : 3;
            ctx.globalAlpha = isCore ? (shimmer + 0.2) : shimmer;

            if (!isCore) {
                ctx.shadowBlur  = 10;
                ctx.shadowColor = color;
            } else {
                ctx.shadowBlur  = 0;
            }

            ctx.moveTo(0, buffer[0]);
            for (let i = 1; i < count; i++) {
                ctx.lineTo(i * step, buffer[i]);
            }
            ctx.stroke();
        };

        // Draw Glows (Outer Tube)
        drawStrand(bufA, me.gradients.grad1, shimmerA, PRIMARY, false);
        drawStrand(bufB, me.gradients.grad2, shimmerB, SECONDARY, false);

        // Draw Cores (Inner Filament)
        drawStrand(bufA, null, shimmerA, null, true);
        drawStrand(bufB, null, shimmerB, null, true);

        // Cleanup: Reset shadow and alpha to prevent bleeding into the next render pass
        ctx.shadowBlur  = 0;
        ctx.globalAlpha = 1;
    }

    /**
     * Calculates the physics for diverting the stream around UI elements.
     *
     * **Logic:**
     * 1. **Detection:** Iterates through `navRects` to find if the current `x` is near a button.
     * 2. **Adaptive Geometry:**
     *    - **Text Buttons:** Uses a wide Cosine envelope for smooth flow.
     *    - **Icon Buttons:** Uses a sharp Cubed envelope (`Math.pow(x, 3)`) to create a "Tight Orbit" effect.
     * 3. **Vertical Clamping:** Ensures the diversion never pushes the wave off-canvas.
     *
     * @param {Number} x
     * @param {Number} height (Canvas height)
     * @returns {Object} {offsetY, intensity, isIconZone}
     */
    getStreamOffset(x, height) {
        let me        = this,
            offsetY   = 0,
            intensity = 0, // 0 to 1 (Hover magnitude)
            isIconZone = 0; // 0 to 1 (Proximity to an Icon Button)

        const
            verticalPadding = 10,
            maxSafeOffset   = (height / 2) - verticalPadding;

        // Collision Detection
        // Iterate through all navigation items to determine stream diversion.
        // Given the low item count (<20), a simple linear scan is efficient.
        for (const rect of me.navRects) {
            // Buffer zone for smooth transition
            const buffer = 40;

            if (x >= rect.x - buffer && x <= rect.x + rect.width + buffer) {
                // We are inside the influence zone of this button

                // Shape Detection
                // Discriminate between square-ish icons (socials) and wide text buttons
                // to apply different diversion envelopes.
                const
                    ratio   = rect.width / rect.height,
                    isIcon  = ratio < 1.5, // Threshold for "Circle" vs "Rectangle"
                    centerX = rect.x + rect.width / 2,
                    span    = (rect.width / 2) + buffer,
                    distX   = Math.abs(x - centerX);

                if (distX < span) {
                    let envelope;

                    if (isIcon) {
                        // TIGHT ORBIT (Sharper curve for icons)
                        let normDist = distX / span; // 0 to 1
                        envelope = Math.pow((1 + Math.cos(Math.PI * normDist)) / 2, 3); // Cubed for sharper falloff
                        isIconZone = Math.max(isIconZone, envelope); // Track if we are in an icon zone
                    } else {
                        // WIDE FLOW (Standard smooth curve for text)
                        envelope = (1 + Math.cos(Math.PI * distX / span)) / 2;
                    }

                    // Diversion Amplitude
                    // Text buttons require more visual clearance than icons due to their
                    // rectangular nature. Icons allow for a tighter "orbit".
                    let targetH = isIcon ? (rect.height / 2) : ((rect.height / 2) + 4);

                    // Vertical Clamping
                    // Cap the offset to ensure the stream stays within the canvas bounds.
                    let targetOffset = Math.min(targetH, maxSafeOffset);

                    // Add to total offset (using max to handle overlaps cleanly)
                    offsetY = Math.max(offsetY, targetOffset * envelope);

                    // Interaction: Proximity Check
                    // Boost the wave intensity if the mouse is hovering over or near this specific button.

                    // Distance from mouse to button center
                    let dx = me.mouse.x - centerX,
                        dy = me.mouse.y - (rect.y + rect.height/2),
                        distMouse = Math.sqrt(dx*dx + dy*dy);

                    // If mouse is near this button, boost intensity
                    if (distMouse < Math.max(rect.width, rect.height)) {
                        intensity = Math.max(intensity, 1 - (distMouse / 150));
                    }
                }
            }
        }

        // Baseline Separation
        // By returning offsetY=0 in empty space, the strands will naturally cross (Helix effect)
        // driven by the sine wave logic in calculateStrandPoints.
        return {offsetY, intensity, isIconZone};
    }

    /**
     * Draws expanding shockwaves from clicks.
     * @param {CanvasRenderingContext2D} ctx
     * @param {Number} width
     */
    drawShockwaves(ctx, width) {
        let me = this;

        for (let i = me.shockwaves.length - 1; i >= 0; i--) {
            let wave = me.shockwaves[i];

            wave.age += 1;

            let progress = wave.age / wave.life;

            if (progress >= 1) {
                me.shockwaves.splice(i, 1);
                continue
            }

            // Draw two lines propagating out from the click point
            let xLeft    = wave.x - (wave.speed * wave.age),
                xRight   = wave.x + (wave.speed * wave.age),
                alpha    = 1 - progress,
                {height} = me.canvasSize;

            ctx.beginPath();
            ctx.strokeStyle = HIGHLIGHT; // Use constant
            ctx.globalAlpha = alpha;     // Fade out via globalAlpha
            ctx.lineWidth   = 4 * (1 - progress);

            // Left Wave
            if (xLeft > 0) {
                ctx.moveTo(xLeft, 0);
                ctx.quadraticCurveTo(xLeft - 20, height / 2, xLeft, height)
            }

            // Right Wave
            if (xRight < width) {
                ctx.moveTo(xRight, 0);
                ctx.quadraticCurveTo(xRight + 20, height / 2, xRight, height)
            }

            ctx.stroke();
            ctx.globalAlpha = 1 // Reset
        }
    }

    /**
     * @param {Object} data
     * @param {String} [data.id]
     */
    updateActiveId(data) {
        this.activeId = data?.id || null
    }

    /**
     * @param {Object} data
     */
    updateGraphData(data) {
        // Not used yet, but kept for interface consistency
    }

    /**
     * @param {Object} data
     * @param {Boolean} [data.click]
     * @param {Boolean} [data.leave]
     * @param {Number} [data.x]
     * @param {Number} [data.y]
     */
    updateMouseState(data) {
        let me = this;

        if (data.leave) {
            me.mouse.x = -1000;
            me.mouse.y = -1000
        } else {
            if (data.x !== undefined) me.mouse.x = data.x;
            if (data.y !== undefined) me.mouse.y = data.y;

            if (data.click) {
                me.shockwaves.push({
                    x    : data.x,
                    y    : data.y,
                    age  : 0,
                    life : 60, // frames
                    speed: 15  // px per frame
                })
            }
        }
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.rects
     */
    updateNavRects(data) {
        let rects = data?.rects;

        if (Array.isArray(rects)) {
            this.navRects = rects
        } else {
            this.navRects = []
        }
    }

    /**
     * Creates and caches gradients and geometry buffers based on canvas size.
     * This eliminates per-frame allocation of TypedArrays and CanvasGradients.
     *
     * @param {Number} width
     * @param {Number} height
     */
    updateResources(width, height) {
        let me  = this,
            ctx = me.context;

        // 1. Re-allocate Buffers (Float32Array)
        // Background: step = 10
        const bgCount = Math.ceil(width / 10) + 1;
        me.waveBuffers.bgA = new Float32Array(bgCount);
        me.waveBuffers.bgB = new Float32Array(bgCount);

        // Foreground: step = 2
        const fgCount = Math.ceil(width / 2) + 1;
        me.waveBuffers.fgA = new Float32Array(fgCount);
        me.waveBuffers.fgB = new Float32Array(fgCount);

        // 2. Cache Gradients
        if (!ctx) return;

        // Foreground Gradients
        const grad1 = ctx.createLinearGradient(0, 0, width, 0);
        grad1.addColorStop(0,   PRIMARY);
        grad1.addColorStop(0.5, HIGHLIGHT);
        grad1.addColorStop(1,   PRIMARY);
        me.gradients.grad1 = grad1;

        const grad2 = ctx.createLinearGradient(0, 0, width, 0);
        grad2.addColorStop(0,   SECONDARY);
        grad2.addColorStop(0.5, HIGHLIGHT);
        grad2.addColorStop(1,   SECONDARY);
        me.gradients.grad2 = grad2;

        const fgRibbon = ctx.createLinearGradient(0, 0, width, 0);
        fgRibbon.addColorStop(0,   'rgba(62, 99, 221, 0.05)');
        fgRibbon.addColorStop(0.5, 'rgba(64, 196, 255, 0.1)');
        fgRibbon.addColorStop(1,   'rgba(62, 99, 221, 0.05)');
        me.gradients.fgRibbon = fgRibbon;

        // Background Gradients
        const bgGrad1 = ctx.createLinearGradient(0, 0, width, 0);
        bgGrad1.addColorStop(0,   'rgba(62, 99, 221, 0.1)');
        bgGrad1.addColorStop(0.5, 'rgba(64, 196, 255, 0.2)');
        bgGrad1.addColorStop(1,   'rgba(62, 99, 221, 0.1)');
        me.gradients.bgGrad1 = bgGrad1;

        const bgGrad2 = ctx.createLinearGradient(0, 0, width, 0);
        bgGrad2.addColorStop(0,   'rgba(139, 166, 255, 0.1)');
        bgGrad2.addColorStop(0.5, 'rgba(64, 196, 255, 0.2)');
        bgGrad2.addColorStop(1,   'rgba(139, 166, 255, 0.1)');
        me.gradients.bgGrad2 = bgGrad2;

        const bgRibbon = ctx.createLinearGradient(0, 0, width, 0);
        bgRibbon.addColorStop(0,   'rgba(62, 99, 221, 0.02)');
        bgRibbon.addColorStop(0.5, 'rgba(64, 196, 255, 0.05)');
        bgRibbon.addColorStop(1,   'rgba(62, 99, 221, 0.02)');
        me.gradients.bgRibbon = bgRibbon;
    }

    /**
     * @param {Object} size
     * @param {Number} size.height
     * @param {Number} size.width
     */
    updateSize(size) {
        let me = this;

        me.canvasSize = size;

        if (me.context) {
            me.context.canvas.width  = size.width;
            me.context.canvas.height = size.height;
            // Re-init resources on resize
            me.updateResources(size.width, size.height)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(HeaderCanvas));



/***/ }

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2NhbnZhcy92ZW5kb3JzLWFwcHNfcG9ydGFsX2NhbnZhc19IZWFkZXJDYW52YXNfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQThDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwREFBSTtBQUMvQjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVEsT0FBTztBQUMvQjtBQUNBLGFBQWE7QUFDYjtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFB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LFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsNEJBQTRCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9wb3J0YWwvY2FudmFzL0hlYWRlckNhbnZhcy5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2UgZnJvbSAnLi4vLi4vLi4vc3JjL2NvcmUvQmFzZS5tanMnO1xuXG5jb25zdFxuICAgIFBSSU1BUlkgICA9ICcjM0U2M0REJyxcbiAgICBTRUNPTkRBUlkgPSAnIzhCQTZGRicsXG4gICAgSElHSExJR0hUID0gJyM0MEM0RkYnO1xuXG4vKipcbiAqIEBzdW1tYXJ5IFNoYXJlZFdvcmtlciByZW5kZXJlciBmb3IgdGhlIEhlYWRlclRvb2xiYXIgb3ZlcmxheS5cbiAqXG4gKiBJbXBsZW1lbnRzIHRoZSAqKlwiTHVtaW5vdXMgRmx1eFwiKiogdmlzdWFsIHRoZW1lLCBhbiBhbWJpZW50LCBpbnRlcmFjdGl2ZSBlbmVyZ3kgc2ltdWxhdGlvbiB0aGF0XG4gKiBzZXJ2ZXMgYXMgdGhlIGJhY2tkcm9wIGZvciB0aGUgUG9ydGFsIGhlYWRlci5cbiAqXG4gKiAqKlZpc3VhbCBBcmNoaXRlY3R1cmU6KipcbiAqIDEuICoqTmVvIEV0aGVyIChCYWNrZ3JvdW5kKToqKiBBIHZvbHVtZXRyaWMgcGFydGljbGUgZmllbGQgY29tcG9zZWQgb2YgZmFpbnQgXCJkdXN0XCIgYW5kIGxhcmdlciBcIm5lYnVsYVwiIG9yYnMuXG4gKiAgICBUaGlzIHByb3ZpZGVzIGF0bW9zcGhlcmljIGRlcHRoLCBmbHVpZCBpbnRlcmFjdGl2aXR5IChtb3VzZSByZXB1bHNpb24pLCBhbmQgYnJpZGdlcyB0aGUgY29udHJhc3QgZ2FwXG4gKiAgICBiZXR3ZWVuIHRoZSB3aGl0ZSBiYWNrZ3JvdW5kIGFuZCB0aGUgZm9yZWdyb3VuZCBlbGVtZW50cy5cbiAqIDIuICoqQW1iaWVudCBIZWxpeCAoTWlkZ3JvdW5kKToqKiBBIGxhcmdlLXNjYWxlLCBzbG93LW1vdmluZyBzaW5lIHdhdmUgcGF0dGVybiB0aGF0IHByb3ZpZGVzIHN0cnVjdHVyYWxcbiAqICAgIHRleHR1cmUgdG8gdGhlIG5lZ2F0aXZlIHNwYWNlLiBOb3cgZW5oYW5jZWQgd2l0aCBhICoqdm9sdW1ldHJpYyBSaWJib24gZmlsbCoqIHRvIGFkZCBkZXB0aC5cbiAqIDMuICoqU3BsaXQgU3RyZWFtIChGb3JlZ3JvdW5kKToqKiBUd28gaW50ZXJ0d2luZWQgZW5lcmd5IHN0cmFuZHMgKEhlbGl4L0ROQSkgdGhhdCBmbG93IGFjcm9zcyB0aGUgY2FudmFzLlxuICogICAgLSAqKjNEIFJpYmJvbiBFZmZlY3Q6KiogQSBzdWJ0bGUgZ3JhZGllbnQgZmlsbHMgdGhlIHNwYWNlIGJldHdlZW4gc3RyYW5kcywgc2ltdWxhdGluZyBhIHR3aXN0aW5nIHN1cmZhY2UuXG4gICogICAtICoqTmVvbiBUdWJlIEVmZmVjdDoqKiBTdHJhbmRzIGFyZSByZW5kZXJlZCB3aXRoIGEgYnJpZ2h0IHdoaXRlIGNvcmUgaW5zaWRlIGEgY29sb3JlZCBnbG93LCBjcmVhdGluZyBhIHBoeXNpY2FsIGxpZ2h0LWVtaXR0aW5nIGxvb2suXG4gICogICAtICoqQWRhcHRpdmUgR2VvbWV0cnk6KiogVGhlIHN0cmFuZHMgZmxvdyBsb29zZWx5IGFyb3VuZCB0ZXh0IGJ1dHRvbnMgYnV0IHRpZ2h0ZW4gaW50byBhIFwiaGlnaC1ncmF2aXR5IG9yYml0XCJcbiAgKiAgICAgYXJvdW5kIHNvY2lhbCBpY29ucy5cbiAgKiAgIC0gKipFbmVyZ3kgU3VyZ2UgKEFjdGl2ZSBTdGF0ZSk6KiogVGhlIHNlZ21lbnQgb2YgdGhlIHN0cmVhbSBwYXNzaW5nIHRocm91Z2ggdGhlIGFjdGl2ZSBuYXZpZ2F0aW9uIGl0ZW1cbiAgKiAgICAgaXMgcmVuZGVyZWQgd2l0aCBhIGhpZ2gtaW50ZW5zaXR5IHdoaXRlIGdsb3cgYW5kIGEgbmVydm91cyBwdWxzZSwgc2VtYW50aWNhbGx5IGhpZ2hsaWdodGluZyB0aGUgY3VycmVudCB2aWV3LlxuICAqXG4gICogKipQZXJmb3JtYW5jZSBBcmNoaXRlY3R1cmUgKFplcm8tQWxsb2NhdGlvbik6KipcbiAqIFRvIG1haW50YWluIDYwZnBzIG9uIGhpZ2gtcmVmcmVzaCBkaXNwbGF5cyB3aXRob3V0IEdDIHN0dXR0ZXJzLCB0aGlzIGNsYXNzIGVtcGxveXMgYSAqKlplcm8tQWxsb2NhdGlvbioqIHN0cmF0ZWd5IGR1cmluZyB0aGUgcmVuZGVyIGxvb3AuXG4gKiAxLiAqKlR5cGVkQXJyYXkgQnVmZmVyczoqKiBXYXZlIGdlb21ldHJ5IGlzIHN0b3JlZCBpbiBwcmUtYWxsb2NhdGVkIGBGbG9hdDMyQXJyYXlgIGJ1ZmZlcnMgKGB3YXZlQnVmZmVyc2ApLCByZXVzZWQgZXZlcnkgZnJhbWUuXG4gKiAyLiAqKkdyYWRpZW50IENhY2hpbmc6KiogQ2FudmFzR3JhZGllbnRzIGFyZSBjcmVhdGVkIG9ubHkgb24gcmVzaXplIChgdXBkYXRlUmVzb3VyY2VzYCkgYW5kIGNhY2hlZCwgYXZvaWRpbmcgZXhwZW5zaXZlIGdlbmVyYXRvciBjYWxscyBwZXIgZnJhbWUuXG4gKiAzLiAqKlJldXNhYmxlIE9iamVjdHM6KiogUGh5c2ljcyBjYWxjdWxhdGlvbnMgd3JpdGUgZGlyZWN0bHkgdG8gYnVmZmVycyBpbnN0ZWFkIG9mIHJldHVybmluZyBuZXcgQXJyYXlzIG9mIE9iamVjdHMuXG4gKlxuICogQGNsYXNzIFBvcnRhbC5jYW52YXMuSGVhZGVyQ2FudmFzXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKiBAc2luZ2xldG9uXG4gKiBAc2VlIFBvcnRhbC52aWV3LkhlYWRlckNhbnZhc1xuICovXG5jbGFzcyBIZWFkZXJDYW52YXMgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J1BvcnRhbC5jYW52YXMuSGVhZGVyQ2FudmFzJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdQb3J0YWwuY2FudmFzLkhlYWRlckNhbnZhcycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdGUgbWV0aG9kIGFjY2Vzc1xuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHJlbW90ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdGU6IHtcbiAgICAgICAgICAgIGFwcDogW1xuICAgICAgICAgICAgICAgICdjbGVhckdyYXBoJyxcbiAgICAgICAgICAgICAgICAnaW5pdEdyYXBoJyxcbiAgICAgICAgICAgICAgICAndXBkYXRlQWN0aXZlSWQnLFxuICAgICAgICAgICAgICAgICd1cGRhdGVHcmFwaERhdGEnLFxuICAgICAgICAgICAgICAgICd1cGRhdGVNb3VzZVN0YXRlJyxcbiAgICAgICAgICAgICAgICAndXBkYXRlTmF2UmVjdHMnLFxuICAgICAgICAgICAgICAgICd1cGRhdGVTaXplJ1xuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2luZ2xldG9uPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2luZ2xldG9uOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGFjdGl2ZUlkPW51bGxcbiAgICAgKi9cbiAgICBhY3RpdmVJZCA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gYW5pbWF0aW9uSWQ9bnVsbFxuICAgICAqL1xuICAgIGFuaW1hdGlvbklkID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBjYW52YXNJZD1udWxsXG4gICAgICovXG4gICAgY2FudmFzSWQgPSBudWxsXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGNhbnZhc1NpemU9bnVsbFxuICAgICAqL1xuICAgIGNhbnZhc1NpemUgPSBudWxsXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGNvbnRleHQ9bnVsbFxuICAgICAqL1xuICAgIGNvbnRleHQgPSBudWxsXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBncmFkaWVudHM9e31cbiAgICAgKi9cbiAgICBncmFkaWVudHMgPSB7fVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gbW91c2U9e3g6IC0xMDAwLCB5OiAtMTAwMH1cbiAgICAgKi9cbiAgICBtb3VzZSA9IHt4OiAtMTAwMCwgeTogLTEwMDB9XG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0W119IG5hdlJlY3RzPVtdXG4gICAgICovXG4gICAgbmF2UmVjdHMgPSBbXVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdFtdfSBwYXJ0aWNsZXM9W11cbiAgICAgKi9cbiAgICBwYXJ0aWNsZXMgPSBbXVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdFtdfSBzaG9ja3dhdmVzPVtdXG4gICAgICovXG4gICAgc2hvY2t3YXZlcyA9IFtdXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSB0aW1lPTBcbiAgICAgKi9cbiAgICB0aW1lID0gMFxuICAgIC8qKlxuICAgICAqIFByZS1hbGxvY2F0ZWQgYnVmZmVycyBmb3Igd2F2ZSBnZW9tZXRyeS5cbiAgICAgKiBVc2VzIGBGbG9hdDMyQXJyYXlgIHRvIGVsaW1pbmF0ZSBHYXJiYWdlIENvbGxlY3Rpb24gcHJlc3N1cmUgZHVyaW5nIHRoZSByZW5kZXIgbG9vcC5cbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHdhdmVCdWZmZXJzPXtiZ0E6IG51bGwsIGJnQjogbnVsbCwgZmdBOiBudWxsLCBmZ0I6IG51bGx9XG4gICAgICovXG4gICAgd2F2ZUJ1ZmZlcnMgPSB7YmdBOiBudWxsLCBiZ0I6IG51bGwsIGZnQTogbnVsbCwgZmdCOiBudWxsfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBncmFwaCBzdGF0ZSBhbmQgc3RvcHMgdGhlIHJlbmRlciBsb29wLlxuICAgICAqL1xuICAgIGNsZWFyR3JhcGgoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG4gICAgICAgIG1lLmNvbnRleHQgICAgID0gbnVsbDtcbiAgICAgICAgbWUuY2FudmFzSWQgICAgPSBudWxsO1xuICAgICAgICBtZS5jYW52YXNTaXplICA9IG51bGw7XG4gICAgICAgIG1lLm5hdlJlY3RzICAgID0gW107XG4gICAgICAgIG1lLnBhcnRpY2xlcyAgID0gW107XG4gICAgICAgIG1lLnNob2Nrd2F2ZXMgID0gW107XG4gICAgICAgIG1lLndhdmVCdWZmZXJzID0ge2JnQTogbnVsbCwgYmdCOiBudWxsLCBmZ0E6IG51bGwsIGZnQjogbnVsbH07XG4gICAgICAgIG1lLmdyYWRpZW50cyAgID0ge31cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgY2FudmFzIGNvbnRleHQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy5jYW52YXNJZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRzLndpbmRvd0lkXG4gICAgICovXG4gICAgaW5pdEdyYXBoKHtjYW52YXNJZCwgd2luZG93SWR9KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaGFzQ2hhbmdlID0gbWUuY2FudmFzSWQgIT09IGNhbnZhc0lkO1xuXG4gICAgICAgIG1lLmNhbnZhc0lkID0gY2FudmFzSWQ7XG5cbiAgICAgICAgY29uc3QgY2hlY2tDYW52YXMgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjYW52YXMgPSBOZW8uY3VycmVudFdvcmtlci5jYW52YXNXaW5kb3dNYXBbY2FudmFzSWRdPy5bd2luZG93SWRdO1xuXG4gICAgICAgICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgICAgICAgICAgbWUuY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgICAgIG1lLmluaXRQYXJ0aWNsZXMoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTsgLy8gSW5pdCBwYXJ0aWNsZXNcbiAgICAgICAgICAgICAgICBtZS51cGRhdGVSZXNvdXJjZXMoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTsgLy8gSW5pdCBidWZmZXJzL2dyYWRpZW50c1xuICAgICAgICAgICAgICAgIGhhc0NoYW5nZSAmJiBtZS5yZW5kZXJMb29wKClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChjaGVja0NhbnZhcywgNTApXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNoZWNrQ2FudmFzKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgcGFydGljbGUgc3lzdGVtIGZvciB0aGUgXCJOZW8gRXRoZXJcIiBlZmZlY3QuXG4gICAgICpcbiAgICAgKiBDcmVhdGVzIGEgbWl4IG9mIGxhcmdlLCBzbG93LW1vdmluZyBcIm5lYnVsYVwiIHBhcnRpY2xlcyBhbmQgc21hbGxlciwgZmFzdGVyIFwiZHVzdFwiIHBhcnRpY2xlc1xuICAgICAqIHRvIGNyZWF0ZSBkZXB0aCBhbmQgYXRtb3NwaGVyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgKi9cbiAgICBpbml0UGFydGljbGVzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcbiAgICAgICAgbWUucGFydGljbGVzID0gW107XG4gICAgICAgIGNvbnN0IGNvdW50ID0gNjA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaXNOZWJ1bGEgPSBNYXRoLnJhbmRvbSgpID4gMC44OyAvLyAyMCUgYXJlIGxhcmdlIG5lYnVsYSBvcmJzXG5cbiAgICAgICAgICAgIG1lLnBhcnRpY2xlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpc05lYnVsYSxcbiAgICAgICAgICAgICAgICB4ICAgICAgICA6IE1hdGgucmFuZG9tKCkgKiB3aWR0aCxcbiAgICAgICAgICAgICAgICB5ICAgICAgICA6IE1hdGgucmFuZG9tKCkgKiBoZWlnaHQsXG4gICAgICAgICAgICAgICAgdnggICAgICAgOiBpc05lYnVsYSA/IChNYXRoLnJhbmRvbSgpICogMC4yICsgMC4wNSkgOiAoTWF0aC5yYW5kb20oKSAqIDAuNSArIDAuMSksIC8vIE5lYnVsYWUgbW92ZSBzbG93ZXJcbiAgICAgICAgICAgICAgICB2eSAgICAgICA6IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDAuMixcbiAgICAgICAgICAgICAgICBzaXplICAgICA6IGlzTmVidWxhID8gKE1hdGgucmFuZG9tKCkgKiAzMCArIDIwKSA6IChNYXRoLnJhbmRvbSgpICogMiArIDAuNSksIC8vIExhcmdlIHZzIFNtYWxsXG4gICAgICAgICAgICAgICAgYWxwaGEgICAgOiBpc05lYnVsYSA/IChNYXRoLnJhbmRvbSgpICogMC4xNSArIDAuMikgOiAoTWF0aC5yYW5kb20oKSAqIDAuNCArIDAuMiksIC8vIEJPT1NURUQgQUxQSEFcbiAgICAgICAgICAgICAgICBiYXNlQWxwaGE6IGlzTmVidWxhID8gKE1hdGgucmFuZG9tKCkgKiAwLjE1ICsgMC4yKSA6IChNYXRoLnJhbmRvbSgpICogMC40ICsgMC4yKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufSByZW5kZXJMb29wPXRoaXMucmVuZGVyLmJpbmQodGhpcylcbiAgICAgKi9cbiAgICByZW5kZXJMb29wID0gdGhpcy5yZW5kZXIuYmluZCh0aGlzKVxuXG4gICAgLyoqXG4gICAgICogTWFpbiByZW5kZXIgbG9vcC5cbiAgICAgKlxuICAgICAqIE9yY2hlc3RyYXRlcyB0aGUgcmVuZGVyaW5nIG9mIGFsbCB2aXN1YWwgbGF5ZXJzOlxuICAgICAqIDEuIEFtYmllbnQgQmFja2dyb3VuZCAoUmliYm9uICsgSGVsaXgpXG4gICAgICogMi4gTmVvIEV0aGVyIChQYXJ0aWNsZXMpXG4gICAgICogMy4gU3BsaXQgU3RyZWFtIChGb3JlZ3JvdW5kIEF1cmFzKVxuICAgICAqIDQuIFNob2Nrd2F2ZXMgKEludGVyYWN0aW9uKVxuICAgICAqXG4gICAgICogVXNlcyBgc2V0VGltZW91dGAgaW5zdGVhZCBvZiBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBiZWNhdXNlIHRoaXMgcnVucyBpbiBhIFNoYXJlZFdvcmtlclxuICAgICAqIHdoZXJlIGByQUZgIGlzIG5vdCBhdmFpbGFibGUuIFRhcmdldHMgfjYwZnBzICgxNm1zKS5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5jb250ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBjdHggICAgPSBtZS5jb250ZXh0LFxuICAgICAgICAgICAgd2lkdGggID0gbWUuY2FudmFzU2l6ZT8ud2lkdGggIHx8IDEwMCxcbiAgICAgICAgICAgIGhlaWdodCA9IG1lLmNhbnZhc1NpemU/LmhlaWdodCB8fCA1MDtcblxuICAgICAgICBtZS50aW1lICs9IDAuMDU7XG5cbiAgICAgICAgLy8gQXV0by1yZWluaXQgcGFydGljbGVzIGlmIHNpemUgY2hhbmdlcyBzaWduaWZpY2FudGx5IG9yIGVtcHR5IE9SIGNvdW50IG1pc21hdGNoIChjb25maWcgdXBkYXRlKVxuICAgICAgICBpZiAobWUucGFydGljbGVzLmxlbmd0aCAhPT0gNjApIHtcbiAgICAgICAgICAgIG1lLmluaXRQYXJ0aWNsZXMod2lkdGgsIGhlaWdodClcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgLy8gMS4gRHJhdyBBbWJpZW50IEJhY2tncm91bmRcbiAgICAgICAgbWUuZHJhd0FtYmllbnRCYWNrZ3JvdW5kKGN0eCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgLy8gMi4gRHJhdyBFdGhlciBQYXJ0aWNsZXMgKEJhY2tncm91bmQgTGF5ZXIpXG4gICAgICAgIG1lLmRyYXdQYXJ0aWNsZXMoY3R4LCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICAvLyAzLiBEcmF3IFwiQXVyYXNcIiAoSG92ZXIgRWZmZWN0cykgPT4gM0QgUmliYm9uICsgTmVvbiBUdWJlXG4gICAgICAgIG1lLmRyYXdBdXJhcyhjdHgsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIC8vIDNiLiBEcmF3IEFjdGl2ZSBPdmVybGF5XG4gICAgICAgIG1lLmRyYXdBY3RpdmVPdmVybGF5KGN0eCwgd2lkdGgpO1xuXG4gICAgICAgIC8vIDQuIERyYXcgXCJTaG9ja3dhdmVzXCIgKENsaWNrIEVmZmVjdHMpXG4gICAgICAgIG1lLmRyYXdTaG9ja3dhdmVzKGN0eCwgd2lkdGgpO1xuXG4gICAgICAgIHNldFRpbWVvdXQobWUucmVuZGVyTG9vcCwgMTAwMCAvIDYwKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHBvaW50cyBmb3IgdGhlIHR3byBlbmVyZ3kgc3RyYW5kcyBiYXNlZCBvbiBwaHlzaWNzIGFuZCBpbnRlcmFjdGlvbi5cbiAgICAgKlxuICAgICAqICoqWmVyby1BbGxvY2F0aW9uIENvbnRyYWN0OioqXG4gICAgICogVGhpcyBtZXRob2Qgd3JpdGVzIGRpcmVjdGx5IHRvIHRoZSBwcmUtYWxsb2NhdGVkIGB0aGlzLndhdmVCdWZmZXJzYCBgRmxvYXQzMkFycmF5YHMuXG4gICAgICogSXQgZG9lcyAqKm5vdCoqIGFsbG9jYXRlIG5ldyBhcnJheXMgb3Igb2JqZWN0cywgZW5zdXJpbmcgemVybyBHQyBwcmVzc3VyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB7c2hpbW1lckEsIHNoaW1tZXJCLCBjb3VudH0gTWV0YWRhdGEgZm9yIHJlbmRlcmluZyAoc2NhbGFycyBvbmx5KVxuICAgICAqL1xuICAgIGNhbGN1bGF0ZVN0cmFuZEdlb21ldHJ5KHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWUubmF2UmVjdHMpIHx8ICFtZS53YXZlQnVmZmVycy5mZ0EpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdFxuICAgICAgICAgICAgYnVmQSAgICA9IG1lLndhdmVCdWZmZXJzLmZnQSxcbiAgICAgICAgICAgIGJ1ZkIgICAgPSBtZS53YXZlQnVmZmVycy5mZ0IsXG4gICAgICAgICAgICBzdGVwICAgID0gMixcbiAgICAgICAgICAgIGNvdW50ICAgPSBNYXRoLmNlaWwod2lkdGggLyBzdGVwKSxcbiAgICAgICAgICAgIGNlbnRlclkgPSBoZWlnaHQgLyAyLFxuICAgICAgICAgICAgcGFkZGluZyA9IDEwLFxuICAgICAgICAgICAgbWF4SCAgICA9IChoZWlnaHQgLSAocGFkZGluZyAqIDIpKSAvIDIsXG4gICAgICAgICAgICAvLyBCUkVBVEhJTkc6IE1vZHVsYXRlIGJhc2UgYW1wbGl0dWRlIG92ZXIgdGltZSAoc2xvdyBwdWxzZSlcbiAgICAgICAgICAgIGJyZWF0aCAgID0gTWF0aC5zaW4obWUudGltZSAqIDAuNSkgKiAyLFxuICAgICAgICAgICAgYmFzZUFtcCAgPSBNYXRoLm1pbig2ICsgYnJlYXRoLCBtYXhIKSxcbiAgICAgICAgICAgIGhvdmVyQW1wID0gNDtcblxuICAgICAgICAvLyBSRUYgMTogTGlua2VkIFBoYXNlIC0gU2hpbW1lciBsZWFkcyBCcmVhdGggYnkgOTBkZWcgKFwiQ2hhcmdpbmcgdXBcIilcbiAgICAgICAgbGV0IGJhc2VTaGltbWVyID0gMC43NSArIChNYXRoLnNpbihtZS50aW1lICogMC41ICsgTWF0aC5QSSAvIDIpICogMC4yNSk7XG5cbiAgICAgICAgLy8gUkVGIDI6IEluZGVwZW5kZW50IFN0cmFuZCBTaGltbWVyXG4gICAgICAgIGxldCBzaGltbWVyQSA9IGJhc2VTaGltbWVyLFxuICAgICAgICAgICAgc2hpbW1lckIgPSAwLjc1ICsgKE1hdGguc2luKG1lLnRpbWUgKiAwLjUgKyBNYXRoLlBJIC8gMiArIE1hdGguUEkgLyAzKSAqIDAuMjUpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IHggPSBpICogc3RlcCxcbiAgICAgICAgICAgICAgICB7b2Zmc2V0WSwgaW50ZW5zaXR5LCBpc0ljb25ab25lfSA9IG1lLmdldFN0cmVhbU9mZnNldCh4LCBoZWlnaHQpO1xuXG4gICAgICAgICAgICAvLyBGUkVRVUVOQ1kgTU9EVUxBVElPTjpcbiAgICAgICAgICAgIGxldCBmcmVxTW9kICAgPSBNYXRoLnNpbih4ICogMC4wMDIgKyBtZS50aW1lICogMC4xKSAqICgyMCArIChpbnRlbnNpdHkgKiAxMCkpLFxuICAgICAgICAgICAgICAgIHRpbWVTaGlmdCA9IG1lLnRpbWUgKiAyO1xuXG4gICAgICAgICAgICAvLyBEQU1QSU5HIEZPUiBJQ09OUzpcbiAgICAgICAgICAgIGxldCBsb2NhbEFtcCA9IGJhc2VBbXAgKiAoMSAtIChpc0ljb25ab25lICogMC42KSk7XG5cbiAgICAgICAgICAgIC8vIE5vaXNlIENhbGN1bGF0aW9uXG4gICAgICAgICAgICAvLyBXZSBjYWxjdWxhdGUgbm9pc2Ugb25jZSBwZXIgZnJhbWUgcGVyIHBvaW50IHRvIGVuc3VyZSB0aGF0IHRoZSBSaWJib24gRmlsbCBhbmRcbiAgICAgICAgICAgIC8vIE5lb24gU3Ryb2tlIHBhc3NlcyB1c2UgaWRlbnRpY2FsIGdlb21ldHJ5LCBwcmV2ZW50aW5nIHZpc3VhbCB0ZWFyaW5nLlxuICAgICAgICAgICAgbGV0IG5vaXNlQSA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIGhvdmVyQW1wICogaW50ZW5zaXR5LFxuICAgICAgICAgICAgICAgIG5vaXNlQiA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIGhvdmVyQW1wICogaW50ZW5zaXR5LFxuICAgICAgICAgICAgICAgIHNpbmUgICA9IE1hdGguc2luKCgoeCArIGZyZXFNb2QpICogMC4wNCkgLSB0aW1lU2hpZnQpICogbG9jYWxBbXAsXG4gICAgICAgICAgICAgICAgc2luZUIgID0gTWF0aC5zaW4oKCh4ICsgZnJlcU1vZCkgKiAwLjA0KSAtIHRpbWVTaGlmdCArIE1hdGguUEkpICogbG9jYWxBbXA7IC8vIEludmVydGVkXG5cbiAgICAgICAgICAgIC8vIFNIT0NLV0FWRSBQSFlTSUNTIChEaXNwbGFjZW1lbnQpXG4gICAgICAgICAgICBsZXQgc2hvY2tZID0gMDtcbiAgICAgICAgICAgIGlmIChtZS5zaG9ja3dhdmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBtZS5zaG9ja3dhdmVzLmZvckVhY2god2F2ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByYWRpdXMgPSB3YXZlLmFnZSAqIHdhdmUuc3BlZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXN0ICAgPSB4IC0gd2F2ZS54OyAvLyBTaWduZWQgZGlzdGFuY2VcblxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBwb2ludCBpcyBuZWFyIHRoZSB3YXZlIGZyb250IChlLmcuIHdpdGhpbiA1MHB4KVxuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoZGlzdCkgPCByYWRpdXMgJiYgTWF0aC5hYnMoZGlzdCkgPiByYWRpdXMgLSA2MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHVsc2Ugc2hhcGU6IFNpbmUgd2F2ZSBiYXNlZCBvbiBkaXN0YW5jZSBmcm9tIGNlbnRlciByZWxhdGl2ZSB0byByYWRpdXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwdWxzZSA9IE1hdGguc2luKChkaXN0IC8gcmFkaXVzKSAqIE1hdGguUEkgKiAxMCkgKiAoMSAtICh3YXZlLmFnZSAvIHdhdmUubGlmZSkpICogMjA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG9ja1kgKz0gcHVsc2VcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdyaXRlIFkgdmFsdWVzIHRvIGJ1ZmZlcnNcbiAgICAgICAgICAgIGJ1ZkFbaV0gPSBjZW50ZXJZICsgc2luZSAtIG9mZnNldFkgKyBub2lzZUEgKyBzaG9ja1k7XG4gICAgICAgICAgICBidWZCW2ldID0gY2VudGVyWSArIHNpbmVCICsgb2Zmc2V0WSArIG5vaXNlQiArIHNob2NrWTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7c2hpbW1lckEsIHNoaW1tZXJCLCBjb3VudH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgXCJFdGhlclwiIHBhcnRpY2xlIGZpZWxkIHRvIGFkZCB2b2x1bWV0cmljIGRlcHRoIGFuZCBpbnRlcmFjdGl2aXR5LlxuICAgICAqXG4gICAgICogKipJbnRlbnQ6KipcbiAgICAgKiBDcmVhdGVzIGEgbGl2aW5nLCBicmVhdGhpbmcgYXRtb3NwaGVyZSAoXCJOZW8gRXRoZXJcIikgdGhhdCBmaWxscyB0aGUgbmVnYXRpdmUgc3BhY2UuXG4gICAgICogVGhpcyBicmlkZ2VzIHRoZSB2aXN1YWwgZ2FwIGJldHdlZW4gdGhlIHN0YXJrIHdoaXRlIGJhY2tncm91bmQgYW5kIHRoZSBoaWdoLWNvbnRyYXN0IGZvcmVncm91bmQgbGluZXMuXG4gICAgICpcbiAgICAgKiAqKlBoeXNpY3M6KipcbiAgICAgKiAtICoqRHJpZnQ6KiogUGFydGljbGVzIG1vdmUgd2l0aCBhIGNvbnN0YW50IGB2eGAgdG8gc2ltdWxhdGUgZGF0YSBmbG93IG9yIHdpbmQuXG4gICAgICogLSAqKlJlcHVsc2lvbjoqKiBUaGUgbW91c2UgY3Vyc29yIGFjdHMgYXMgYSBcInJlcHVsc29yIGZpZWxkLFwiIHB1c2hpbmcgcGFydGljbGVzIGF3YXkgYW5kIGJyaWdodGVuaW5nIHRoZW1cbiAgICAgKiAgIHRvIGNyZWF0ZSBhIFwiaG9sZVwiIGluIHRoZSBmb2cuXG4gICAgICogLSAqKk5lYnVsYWU6KiogTGFyZ2UsIGZhaW50IHBhcnRpY2xlcyBjcmVhdGUgYSBcImZvZ1wiIGVmZmVjdCwgd2hpbGUgc21hbGwsIGJyaWdodCBwYXJ0aWNsZXMgYWN0IGFzIFwiZHVzdC5cIlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgKi9cbiAgICBkcmF3UGFydGljbGVzKGN0eCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnBhcnRpY2xlcy5mb3JFYWNoKHAgPT4ge1xuICAgICAgICAgICAgLy8gVXBkYXRlIFBvc2l0aW9uXG4gICAgICAgICAgICBwLnggKz0gcC52eDtcbiAgICAgICAgICAgIHAueSArPSBwLnZ5O1xuXG4gICAgICAgICAgICAvLyBXcmFwIGFyb3VuZFxuICAgICAgICAgICAgaWYgKHAueCA+IHdpZHRoICsgcC5zaXplKSBwLnggPSAtcC5zaXplO1xuICAgICAgICAgICAgaWYgKHAueCA8IC1wLnNpemUpICAgICAgICBwLnggPSB3aWR0aCArIHAuc2l6ZTtcbiAgICAgICAgICAgIGlmIChwLnkgPiBoZWlnaHQgKyBwLnNpemUpIHAueSA9IC1wLnNpemU7XG4gICAgICAgICAgICBpZiAocC55IDwgLXAuc2l6ZSkgICAgICAgICBwLnkgPSBoZWlnaHQgKyBwLnNpemU7XG5cbiAgICAgICAgICAgIC8vIEludGVyYWN0aW9uOiBNb3VzZSBSZXB1bHNpb25cbiAgICAgICAgICAgIC8vIEFsbCBwYXJ0aWNsZXMgcmVhY3QgdG8gdGhlIG1vdXNlLCBidXQgXCJOZWJ1bGFcIiBwYXJ0aWNsZXMgaGF2ZSBoaWdoZXIgY2FsY3VsYXRlZCBtYXNzLFxuICAgICAgICAgICAgLy8gcmVzdWx0aW5nIGluIGxlc3MgZGlzcGxhY2VtZW50IHRoYW4gdGhlIGxpZ2h0ZXIgXCJEdXN0XCIgcGFydGljbGVzLlxuICAgICAgICAgICAgbGV0IGR4ID0gcC54IC0gbWUubW91c2UueCxcbiAgICAgICAgICAgICAgICBkeSA9IHAueSAtIG1lLm1vdXNlLnksXG4gICAgICAgICAgICAgICAgZGlzdCA9IE1hdGguc3FydChkeCpkeCArIGR5KmR5KSxcbiAgICAgICAgICAgICAgICBtYXhEaXN0ID0gcC5pc05lYnVsYSA/IDE1MCA6IDEwMDtcblxuICAgICAgICAgICAgaWYgKGRpc3QgPCBtYXhEaXN0ICYmIGRpc3QgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZvcmNlID0gKG1heERpc3QgLSBkaXN0KSAvIG1heERpc3Q7XG4gICAgICAgICAgICAgICAgLy8gUHVzaCBhd2F5XG4gICAgICAgICAgICAgICAgbGV0IG1hc3MgPSBwLmlzTmVidWxhID8gNSA6IDE7XG4gICAgICAgICAgICAgICAgcC54ICs9IChkeCAvIGRpc3QpICogZm9yY2UgKiAoMiAvIG1hc3MpO1xuICAgICAgICAgICAgICAgIHAueSArPSAoZHkgLyBkaXN0KSAqIGZvcmNlICogKDIgLyBtYXNzKTtcbiAgICAgICAgICAgICAgICAvLyBCcmlnaHRlbiBzbGlnaHRseVxuICAgICAgICAgICAgICAgIHAuYWxwaGEgPSBNYXRoLm1pbihwLmJhc2VBbHBoYSArIGZvcmNlICogKHAuaXNOZWJ1bGEgPyAwLjA1IDogMC41KSwgMC44KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSW50ZXJhY3Rpb246IFNob2Nrd2F2ZSBSZXB1bHNpb25cbiAgICAgICAgICAgIGlmIChtZS5zaG9ja3dhdmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBtZS5zaG9ja3dhdmVzLmZvckVhY2god2F2ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB3eCAgICAgPSBwLnggLSB3YXZlLngsXG4gICAgICAgICAgICAgICAgICAgICAgICB3eSAgICAgPSBwLnkgLSB3YXZlLnksXG4gICAgICAgICAgICAgICAgICAgICAgICB3RGlzdCAgPSBNYXRoLnNxcnQod3ggKiB3eCArIHd5ICogd3kpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzID0gd2F2ZS5hZ2UgKiB3YXZlLnNwZWVkO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHBhcnRpY2xlIGlzIG5lYXIgdGhlIGV4cGFuZGluZyByaW5nICh3aWR0aCA0MHB4KVxuICAgICAgICAgICAgICAgICAgICBpZiAod0Rpc3QgPCByYWRpdXMgJiYgd0Rpc3QgPiByYWRpdXMgLSA0MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZvcmNlID0gKDEgLSAod2F2ZS5hZ2UgLyB3YXZlLmxpZmUpKSAqIDI7IC8vIERlY2F5IGZvcmNlIG92ZXIgdGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHVzaCBvdXR3YXJkXG4gICAgICAgICAgICAgICAgICAgICAgICBwLnggKz0gKHd4IC8gd0Rpc3QpICogZm9yY2UgKiA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgcC55ICs9ICh3eSAvIHdEaXN0KSAqIGZvcmNlICogNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuYWxwaGEgPSBNYXRoLm1pbihwLmFscGhhICsgMC4zLCAxKSAvLyBGbGFzaCBicmlnaHRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJldHVybiB0byBiYXNlIGFscGhhXG4gICAgICAgICAgICBpZiAocC5hbHBoYSA+IHAuYmFzZUFscGhhKSB7XG4gICAgICAgICAgICAgICAgcC5hbHBoYSAtPSAwLjAwNVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBwLmFscGhhO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgICAgICBpZiAocC5pc05lYnVsYSkge1xuICAgICAgICAgICAgICAgIC8vIE5lYnVsYSBWaXN1YWxpemF0aW9uXG4gICAgICAgICAgICAgICAgLy8gVXNlIGEgcmFkaWFsIGdyYWRpZW50IHRvIGNyZWF0ZSBhIHNvZnQsIGNsb3VkLWxpa2UgYXBwZWFyYW5jZS5cbiAgICAgICAgICAgICAgICBsZXQgZyA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudChwLngsIHAueSwgMCwgcC54LCBwLnksIHAuc2l6ZSk7XG4gICAgICAgICAgICAgICAgZy5hZGRDb2xvclN0b3AoMCwgSElHSExJR0hUKTtcbiAgICAgICAgICAgICAgICBnLmFkZENvbG9yU3RvcCgxLCAncmdiYSgyNTUsMjU1LDI1NSwwKScpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBnO1xuICAgICAgICAgICAgICAgIGN0eC5hcmMocC54LCBwLnksIHAuc2l6ZSwgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsKClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IEhJR0hMSUdIVDtcbiAgICAgICAgICAgICAgICBjdHguYXJjKHAueCwgcC55LCBwLnNpemUsIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDFcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBhbiBhZGRpdGlvbmFsIGhpZ2hsaWdodCBmb3IgdGhlIGFjdGl2ZSBuYXZpZ2F0aW9uIGl0ZW0uXG4gICAgICogKipcIkVuZXJneSBTdXJnZVwiIEVmZmVjdDoqKlxuICAgICAqIFJlbmRlcnMgYSBoaWdoLWludGVuc2l0eSBwYXNzIG9mIHRoZSBlbmVyZ3kgc3RyYW5kcyAqb25seSogd2l0aGluIHRoZSBhY3RpdmUgem9uZS5cbiAgICAgKiBUaGlzIG1ha2VzIHRoZSBsaW5lcyBhcHBlYXIgdG8gXCJwb3dlciB1cFwiIG9yIGdsb3cgd2hpdGUtaG90IGFzIHRoZXkgcGFzcyB0aHJvdWdoIHRoZSBhY3RpdmUgdmlldyxcbiAgICAgKiBmdWxseSBpbnRlZ3JhdGVkIHdpdGggdGhlIGV4aXN0aW5nIGdlb21ldHJ5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqL1xuICAgIGRyYXdBY3RpdmVPdmVybGF5KGN0eCwgd2lkdGgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIW1lLmFjdGl2ZUlkIHx8ICFtZS53YXZlQnVmZmVycy5mZ0EpIHJldHVybjtcblxuICAgICAgICBjb25zdCByZWN0ID0gbWUubmF2UmVjdHMuZmluZChyID0+IHIuaWQgPT09IG1lLmFjdGl2ZUlkKTtcbiAgICAgICAgaWYgKCFyZWN0KSByZXR1cm47XG5cbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIHN0ZXAgICA9IDIsIC8vIE11c3QgbWF0Y2ggY2FsY3VsYXRlU3RyYW5kR2VvbWV0cnlcbiAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nIHRvIGZhZGUgdGhlIGVmZmVjdCBpbi9vdXQgc21vb3RobHlcbiAgICAgICAgICAgIHBhZCAgICA9IDEwLFxuICAgICAgICAgICAgc3RhcnRYID0gTWF0aC5tYXgoMCwgcmVjdC54IC0gcGFkKSxcbiAgICAgICAgICAgIGVuZFggICA9IE1hdGgubWluKHdpZHRoLCByZWN0LnggKyByZWN0LndpZHRoICsgcGFkKSxcbiAgICAgICAgICAgIHN0YXJ0SSA9IE1hdGguZmxvb3Ioc3RhcnRYIC8gc3RlcCksXG4gICAgICAgICAgICBlbmRJICAgPSBNYXRoLmNlaWwoZW5kWCAvIHN0ZXApLFxuICAgICAgICAgICAgYnVmQSAgID0gbWUud2F2ZUJ1ZmZlcnMuZmdBLFxuICAgICAgICAgICAgYnVmQiAgID0gbWUud2F2ZUJ1ZmZlcnMuZmdCO1xuXG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5saW5lQ2FwICA9ICdyb3VuZCc7XG4gICAgICAgIGN0eC5saW5lSm9pbiA9ICdyb3VuZCc7XG5cbiAgICAgICAgLy8gSGlnaC1JbnRlbnNpdHkgR2xvd1xuICAgICAgICBjdHguc2hhZG93Qmx1ciAgPSAyMDtcbiAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gJyNGRkZGRkYnOyAvLyBXaGl0ZSBnbG93XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjRkZGRkZGJzsgLy8gV2hpdGUgY29yZVxuICAgICAgICBjdHgubGluZVdpZHRoICAgPSAyO1xuXG4gICAgICAgIC8vIEdyYWRpZW50IEZhZGUgbWFzayAobWFudWFsIGFscGhhKVxuICAgICAgICAvLyBXZSBjYW4ndCBlYXNpbHkgZ3JhZGllbnQtc3Ryb2tlIGEgc3ViLXBhdGgsIHNvIHdlIHJlbHkgb24gZ2xvYmFsQWxwaGFcbiAgICAgICAgLy8gY29tYmluZWQgd2l0aCB0aGUgXCJob3RcIiB3aGl0ZSBjb2xvciB0byBtYWtlIGl0IHBvcC5cbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC42ICsgKE1hdGguc2luKG1lLnRpbWUgKiAzKSAqIDAuMik7IC8vIEZhc3QsIG5lcnZvdXMgcHVsc2VcblxuICAgICAgICBjb25zdCBkcmF3U2VnbWVudCA9IChidWZmZXIpID0+IHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oc3RhcnRJICogc3RlcCwgYnVmZmVyW3N0YXJ0SV0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0SSArIDE7IGkgPD0gZW5kSTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhpICogc3RlcCwgYnVmZmVyW2ldKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LnN0cm9rZSgpXG4gICAgICAgIH07XG5cbiAgICAgICAgZHJhd1NlZ21lbnQoYnVmQSk7XG4gICAgICAgIGRyYXdTZWdtZW50KGJ1ZkIpO1xuXG4gICAgICAgIGN0eC5yZXN0b3JlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBhIHN1YnRsZSwgbGFyZ2Utc2NhbGUgYmFja2dyb3VuZCBIZWxpeCBwYXR0ZXJuIHdpdGggYSAzRCBSaWJib24gZWZmZWN0LlxuICAgICAqXG4gICAgICogKipJbnRlbnQ6KipcbiAgICAgKiBQcm92aWRlcyBhIHN0cnVjdHVyYWwgYmFja2JvbmUgdG8gdGhlIG5lZ2F0aXZlIHNwYWNlLiBVbmxpa2UgdGhlIHBhcnRpY2xlIGZpZWxkICh3aGljaCBpcyBjaGFvdGljKSxcbiAgICAgKiB0aGlzIGxheWVyIGlzIG9yZGVyZWQgYW5kIHJoeXRobWljLCByZWluZm9yY2luZyB0aGUgXCJETkEvSGVsaXhcIiB0aGVtZSBldmVuIGluIHRoZSBiYWNrZ3JvdW5kLlxuICAgICAqXG4gICAgICogKipWaXN1YWxzOioqXG4gICAgICogMS4gKipSaWJib24gRmlsbDoqKiBBIGJhcmVseS12aXNpYmxlIHZvbHVtZXRyaWMgZ3JhZGllbnQgZmlsbHMgdGhlIHNwYWNlIGJldHdlZW4gdGhlIGhlbGljZXMuXG4gICAgICogMi4gKipEZXB0aCBvZiBGaWVsZDoqKiBVc2VzIHdpZGUsIHZlcnkgbG93IG9wYWNpdHkgc3Ryb2tlcyB0byBhcHBlYXIgXCJvdXQgb2YgZm9jdXNcIiBiZWhpbmQgdGhlIHNoYXJwIGZvcmVncm91bmQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqL1xuICAgIGRyYXdBbWJpZW50QmFja2dyb3VuZChjdHgsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvLyBFbnN1cmUgYnVmZmVycyBleGlzdFxuICAgICAgICBpZiAoIW1lLndhdmVCdWZmZXJzLmJnQSkgcmV0dXJuO1xuXG4gICAgICAgIGxldCB0ICAgICAgID0gbWUudGltZSAqIDAuNSxcbiAgICAgICAgICAgIGNlbnRlclkgPSBoZWlnaHQgLyAyLFxuICAgICAgICAgICAgYW1wICAgICA9IGhlaWdodCAqIDAuNCxcbiAgICAgICAgICAgIHN0ZXAgICAgPSAxMCxcbiAgICAgICAgICAgIGNvdW50ICAgPSBNYXRoLmNlaWwod2lkdGggLyBzdGVwKSxcbiAgICAgICAgICAgIGJ1ZkEgICAgPSBtZS53YXZlQnVmZmVycy5iZ0EsXG4gICAgICAgICAgICBidWZCICAgID0gbWUud2F2ZUJ1ZmZlcnMuYmdCO1xuXG4gICAgICAgIC8vIDEuIENhbGN1bGF0ZSBQb2ludHMgKERpcmVjdCB0byBCdWZmZXIpXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IHggPSBpICogc3RlcDtcbiAgICAgICAgICAgIGJ1ZkFbaV0gPSBjZW50ZXJZICsgTWF0aC5zaW4oKHggKiAwLjAxKSArIHQpICogYW1wO1xuICAgICAgICAgICAgYnVmQltpXSA9IGNlbnRlclkgKyBNYXRoLnNpbigoeCAqIDAuMDEpICsgdCArIE1hdGguUEkpICogYW1wXG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0gMi4gUklCQk9OIEZJTEwgKEJhY2tncm91bmQgU3VyZmFjZSkgLS0tXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBtZS5ncmFkaWVudHMuYmdSaWJib247XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgICBjdHgubW92ZVRvKDAsIGJ1ZkFbMF0pO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oaSAqIHN0ZXAsIGJ1ZkFbaV0pXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gY291bnQgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhpICogc3RlcCwgYnVmQltpXSlcbiAgICAgICAgfVxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGN0eC5maWxsKCk7XG5cbiAgICAgICAgLy8gLS0tIDMuIFNUUk9LRVMgLS0tXG4gICAgICAgIGN0eC5saW5lV2lkdGggPSAxNTtcbiAgICAgICAgY3R4LmxpbmVDYXAgICA9ICdyb3VuZCc7XG4gICAgICAgIGN0eC5saW5lSm9pbiAgPSAncm91bmQnO1xuXG4gICAgICAgIC8vIFVzZSBjYWNoZWQgZ3JhZGllbnRzXG4gICAgICAgIGNvbnN0IGRyYXdTdHJva2UgPSAoYnVmZmVyLCBzdHJva2VTdHlsZSkgPT4ge1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGU7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKDAsIGJ1ZmZlclswXSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKGkgKiBzdGVwLCBidWZmZXJbaV0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguc3Ryb2tlKClcbiAgICAgICAgfTtcblxuICAgICAgICBkcmF3U3Ryb2tlKGJ1ZkEsIG1lLmdyYWRpZW50cy5iZ0dyYWQxKTtcbiAgICAgICAgZHJhd1N0cm9rZShidWZCLCBtZS5ncmFkaWVudHMuYmdHcmFkMik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIG1haW4gZm9yZWdyb3VuZCBcIlNwbGl0IFN0cmVhbVwiIGVuZXJneSBzdHJhbmRzIHdpdGggM0QgZWZmZWN0cy5cbiAgICAgKlxuICAgICAqICoqM0QgQXJjaGl0ZWN0dXJlOioqXG4gICAgICogMS4gKipSaWJib24gRmlsbDoqKiBEcmF3cyBhIGxvdy1vcGFjaXR5IGdyYWRpZW50IGJldHdlZW4gU3RyYW5kIEEgYW5kIFN0cmFuZCBCLCBjcmVhdGluZyBhIHR3aXN0aW5nIHN1cmZhY2UuXG4gICAgICogMi4gKipOZW9uIFR1YmUgKE91dGVyKToqKiBUaGUgY29sb3JlZCBnbG93IG9mIHRoZSBzdHJhbmRzLlxuICAgICAqIDMuICoqTmVvbiBUdWJlIChDb3JlKToqKiBBIGJyaWdodCB3aGl0ZSBpbm5lciBjb3JlIHRvIHNpbXVsYXRlIHZvbHVtZXRyaWMgbGlnaHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqL1xuICAgIGRyYXdBdXJhcyhjdHgsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWUubmF2UmVjdHMpKSByZXR1cm47XG5cbiAgICAgICAgLy8gMS4gQ2FsY3VsYXRlIFBoeXNpY3MgKFNoYXJlZCBmb3IgUmliYm9uIGFuZCBTdHJhbmRzKSAtIFJldHVybnMgbWV0YWRhdGEsIGRhdGEgaXMgaW4gYnVmZmVyc1xuICAgICAgICBjb25zdCBnZW9tZXRyeSA9IG1lLmNhbGN1bGF0ZVN0cmFuZEdlb21ldHJ5KHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIGlmICghZ2VvbWV0cnkpIHJldHVybjtcblxuICAgICAgICBjb25zdFxuICAgICAgICAgICAge3NoaW1tZXJBLCBzaGltbWVyQiwgY291bnR9ID0gZ2VvbWV0cnksXG4gICAgICAgICAgICBidWZBID0gbWUud2F2ZUJ1ZmZlcnMuZmdBLFxuICAgICAgICAgICAgYnVmQiA9IG1lLndhdmVCdWZmZXJzLmZnQixcbiAgICAgICAgICAgIHN0ZXAgPSAyO1xuXG4gICAgICAgIC8vIC0tLSAyLiBSSUJCT04gRklMTCAoVGhlIDNEIFN1cmZhY2UpIC0tLVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gbWUuZ3JhZGllbnRzLmZnUmliYm9uO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgY3R4Lm1vdmVUbygwLCBidWZBWzBdKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKGkgKiBzdGVwLCBidWZBW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSBjb3VudCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKGkgKiBzdGVwLCBidWZCW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGN0eC5maWxsKCk7XG5cbiAgICAgICAgLy8gLS0tIDMuIE5FT04gU1RSQU5EUyAoVHViZSBFZmZlY3QpIC0tLVxuXG4gICAgICAgIGN0eC5saW5lQ2FwICAgICA9ICdyb3VuZCc7XG4gICAgICAgIGN0eC5saW5lSm9pbiAgICA9ICdyb3VuZCc7XG5cbiAgICAgICAgLy8gSGVscGVyIHRvIGRyYXcgYSBzdHJhbmQgZnJvbSBidWZmZXJcbiAgICAgICAgY29uc3QgZHJhd1N0cmFuZCA9IChidWZmZXIsIGdyYWRpZW50LCBzaGltbWVyLCBjb2xvciwgaXNDb3JlKSA9PiB7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBpc0NvcmUgPyAnI0ZGRkZGRicgOiBncmFkaWVudDtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggICA9IGlzQ29yZSA/IDEgOiAzO1xuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gaXNDb3JlID8gKHNoaW1tZXIgKyAwLjIpIDogc2hpbW1lcjtcblxuICAgICAgICAgICAgaWYgKCFpc0NvcmUpIHtcbiAgICAgICAgICAgICAgICBjdHguc2hhZG93Qmx1ciAgPSAxMDtcbiAgICAgICAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSBjb2xvcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3R4LnNoYWRvd0JsdXIgID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4Lm1vdmVUbygwLCBidWZmZXJbMF0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhpICogc3RlcCwgYnVmZmVyW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBEcmF3IEdsb3dzIChPdXRlciBUdWJlKVxuICAgICAgICBkcmF3U3RyYW5kKGJ1ZkEsIG1lLmdyYWRpZW50cy5ncmFkMSwgc2hpbW1lckEsIFBSSU1BUlksIGZhbHNlKTtcbiAgICAgICAgZHJhd1N0cmFuZChidWZCLCBtZS5ncmFkaWVudHMuZ3JhZDIsIHNoaW1tZXJCLCBTRUNPTkRBUlksIGZhbHNlKTtcblxuICAgICAgICAvLyBEcmF3IENvcmVzIChJbm5lciBGaWxhbWVudClcbiAgICAgICAgZHJhd1N0cmFuZChidWZBLCBudWxsLCBzaGltbWVyQSwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgIGRyYXdTdHJhbmQoYnVmQiwgbnVsbCwgc2hpbW1lckIsIG51bGwsIHRydWUpO1xuXG4gICAgICAgIC8vIENsZWFudXA6IFJlc2V0IHNoYWRvdyBhbmQgYWxwaGEgdG8gcHJldmVudCBibGVlZGluZyBpbnRvIHRoZSBuZXh0IHJlbmRlciBwYXNzXG4gICAgICAgIGN0eC5zaGFkb3dCbHVyICA9IDA7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgcGh5c2ljcyBmb3IgZGl2ZXJ0aW5nIHRoZSBzdHJlYW0gYXJvdW5kIFVJIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogKipMb2dpYzoqKlxuICAgICAqIDEuICoqRGV0ZWN0aW9uOioqIEl0ZXJhdGVzIHRocm91Z2ggYG5hdlJlY3RzYCB0byBmaW5kIGlmIHRoZSBjdXJyZW50IGB4YCBpcyBuZWFyIGEgYnV0dG9uLlxuICAgICAqIDIuICoqQWRhcHRpdmUgR2VvbWV0cnk6KipcbiAgICAgKiAgICAtICoqVGV4dCBCdXR0b25zOioqIFVzZXMgYSB3aWRlIENvc2luZSBlbnZlbG9wZSBmb3Igc21vb3RoIGZsb3cuXG4gICAgICogICAgLSAqKkljb24gQnV0dG9uczoqKiBVc2VzIGEgc2hhcnAgQ3ViZWQgZW52ZWxvcGUgKGBNYXRoLnBvdyh4LCAzKWApIHRvIGNyZWF0ZSBhIFwiVGlnaHQgT3JiaXRcIiBlZmZlY3QuXG4gICAgICogMy4gKipWZXJ0aWNhbCBDbGFtcGluZzoqKiBFbnN1cmVzIHRoZSBkaXZlcnNpb24gbmV2ZXIgcHVzaGVzIHRoZSB3YXZlIG9mZi1jYW52YXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgKENhbnZhcyBoZWlnaHQpXG4gICAgICogQHJldHVybnMge09iamVjdH0ge29mZnNldFksIGludGVuc2l0eSwgaXNJY29uWm9uZX1cbiAgICAgKi9cbiAgICBnZXRTdHJlYW1PZmZzZXQoeCwgaGVpZ2h0KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgb2Zmc2V0WSAgID0gMCxcbiAgICAgICAgICAgIGludGVuc2l0eSA9IDAsIC8vIDAgdG8gMSAoSG92ZXIgbWFnbml0dWRlKVxuICAgICAgICAgICAgaXNJY29uWm9uZSA9IDA7IC8vIDAgdG8gMSAoUHJveGltaXR5IHRvIGFuIEljb24gQnV0dG9uKVxuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICB2ZXJ0aWNhbFBhZGRpbmcgPSAxMCxcbiAgICAgICAgICAgIG1heFNhZmVPZmZzZXQgICA9IChoZWlnaHQgLyAyKSAtIHZlcnRpY2FsUGFkZGluZztcblxuICAgICAgICAvLyBDb2xsaXNpb24gRGV0ZWN0aW9uXG4gICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBhbGwgbmF2aWdhdGlvbiBpdGVtcyB0byBkZXRlcm1pbmUgc3RyZWFtIGRpdmVyc2lvbi5cbiAgICAgICAgLy8gR2l2ZW4gdGhlIGxvdyBpdGVtIGNvdW50ICg8MjApLCBhIHNpbXBsZSBsaW5lYXIgc2NhbiBpcyBlZmZpY2llbnQuXG4gICAgICAgIGZvciAoY29uc3QgcmVjdCBvZiBtZS5uYXZSZWN0cykge1xuICAgICAgICAgICAgLy8gQnVmZmVyIHpvbmUgZm9yIHNtb290aCB0cmFuc2l0aW9uXG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSA0MDtcblxuICAgICAgICAgICAgaWYgKHggPj0gcmVjdC54IC0gYnVmZmVyICYmIHggPD0gcmVjdC54ICsgcmVjdC53aWR0aCArIGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBpbnNpZGUgdGhlIGluZmx1ZW5jZSB6b25lIG9mIHRoaXMgYnV0dG9uXG5cbiAgICAgICAgICAgICAgICAvLyBTaGFwZSBEZXRlY3Rpb25cbiAgICAgICAgICAgICAgICAvLyBEaXNjcmltaW5hdGUgYmV0d2VlbiBzcXVhcmUtaXNoIGljb25zIChzb2NpYWxzKSBhbmQgd2lkZSB0ZXh0IGJ1dHRvbnNcbiAgICAgICAgICAgICAgICAvLyB0byBhcHBseSBkaWZmZXJlbnQgZGl2ZXJzaW9uIGVudmVsb3Blcy5cbiAgICAgICAgICAgICAgICBjb25zdFxuICAgICAgICAgICAgICAgICAgICByYXRpbyAgID0gcmVjdC53aWR0aCAvIHJlY3QuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBpc0ljb24gID0gcmF0aW8gPCAxLjUsIC8vIFRocmVzaG9sZCBmb3IgXCJDaXJjbGVcIiB2cyBcIlJlY3RhbmdsZVwiXG4gICAgICAgICAgICAgICAgICAgIGNlbnRlclggPSByZWN0LnggKyByZWN0LndpZHRoIC8gMixcbiAgICAgICAgICAgICAgICAgICAgc3BhbiAgICA9IChyZWN0LndpZHRoIC8gMikgKyBidWZmZXIsXG4gICAgICAgICAgICAgICAgICAgIGRpc3RYICAgPSBNYXRoLmFicyh4IC0gY2VudGVyWCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGlzdFggPCBzcGFuKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlbnZlbG9wZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNJY29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUSUdIVCBPUkJJVCAoU2hhcnBlciBjdXJ2ZSBmb3IgaWNvbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm9ybURpc3QgPSBkaXN0WCAvIHNwYW47IC8vIDAgdG8gMVxuICAgICAgICAgICAgICAgICAgICAgICAgZW52ZWxvcGUgPSBNYXRoLnBvdygoMSArIE1hdGguY29zKE1hdGguUEkgKiBub3JtRGlzdCkpIC8gMiwgMyk7IC8vIEN1YmVkIGZvciBzaGFycGVyIGZhbGxvZmZcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzSWNvblpvbmUgPSBNYXRoLm1heChpc0ljb25ab25lLCBlbnZlbG9wZSk7IC8vIFRyYWNrIGlmIHdlIGFyZSBpbiBhbiBpY29uIHpvbmVcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdJREUgRkxPVyAoU3RhbmRhcmQgc21vb3RoIGN1cnZlIGZvciB0ZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgZW52ZWxvcGUgPSAoMSArIE1hdGguY29zKE1hdGguUEkgKiBkaXN0WCAvIHNwYW4pKSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBEaXZlcnNpb24gQW1wbGl0dWRlXG4gICAgICAgICAgICAgICAgICAgIC8vIFRleHQgYnV0dG9ucyByZXF1aXJlIG1vcmUgdmlzdWFsIGNsZWFyYW5jZSB0aGFuIGljb25zIGR1ZSB0byB0aGVpclxuICAgICAgICAgICAgICAgICAgICAvLyByZWN0YW5ndWxhciBuYXR1cmUuIEljb25zIGFsbG93IGZvciBhIHRpZ2h0ZXIgXCJvcmJpdFwiLlxuICAgICAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0SCA9IGlzSWNvbiA/IChyZWN0LmhlaWdodCAvIDIpIDogKChyZWN0LmhlaWdodCAvIDIpICsgNCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVmVydGljYWwgQ2xhbXBpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FwIHRoZSBvZmZzZXQgdG8gZW5zdXJlIHRoZSBzdHJlYW0gc3RheXMgd2l0aGluIHRoZSBjYW52YXMgYm91bmRzLlxuICAgICAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0T2Zmc2V0ID0gTWF0aC5taW4odGFyZ2V0SCwgbWF4U2FmZU9mZnNldCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRvIHRvdGFsIG9mZnNldCAodXNpbmcgbWF4IHRvIGhhbmRsZSBvdmVybGFwcyBjbGVhbmx5KVxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRZID0gTWF0aC5tYXgob2Zmc2V0WSwgdGFyZ2V0T2Zmc2V0ICogZW52ZWxvcGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEludGVyYWN0aW9uOiBQcm94aW1pdHkgQ2hlY2tcbiAgICAgICAgICAgICAgICAgICAgLy8gQm9vc3QgdGhlIHdhdmUgaW50ZW5zaXR5IGlmIHRoZSBtb3VzZSBpcyBob3ZlcmluZyBvdmVyIG9yIG5lYXIgdGhpcyBzcGVjaWZpYyBidXR0b24uXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRGlzdGFuY2UgZnJvbSBtb3VzZSB0byBidXR0b24gY2VudGVyXG4gICAgICAgICAgICAgICAgICAgIGxldCBkeCA9IG1lLm1vdXNlLnggLSBjZW50ZXJYLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHkgPSBtZS5tb3VzZS55IC0gKHJlY3QueSArIHJlY3QuaGVpZ2h0LzIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzdE1vdXNlID0gTWF0aC5zcXJ0KGR4KmR4ICsgZHkqZHkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG1vdXNlIGlzIG5lYXIgdGhpcyBidXR0b24sIGJvb3N0IGludGVuc2l0eVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdE1vdXNlIDwgTWF0aC5tYXgocmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlbnNpdHkgPSBNYXRoLm1heChpbnRlbnNpdHksIDEgLSAoZGlzdE1vdXNlIC8gMTUwKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCYXNlbGluZSBTZXBhcmF0aW9uXG4gICAgICAgIC8vIEJ5IHJldHVybmluZyBvZmZzZXRZPTAgaW4gZW1wdHkgc3BhY2UsIHRoZSBzdHJhbmRzIHdpbGwgbmF0dXJhbGx5IGNyb3NzIChIZWxpeCBlZmZlY3QpXG4gICAgICAgIC8vIGRyaXZlbiBieSB0aGUgc2luZSB3YXZlIGxvZ2ljIGluIGNhbGN1bGF0ZVN0cmFuZFBvaW50cy5cbiAgICAgICAgcmV0dXJuIHtvZmZzZXRZLCBpbnRlbnNpdHksIGlzSWNvblpvbmV9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYXdzIGV4cGFuZGluZyBzaG9ja3dhdmVzIGZyb20gY2xpY2tzLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICAgKi9cbiAgICBkcmF3U2hvY2t3YXZlcyhjdHgsIHdpZHRoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IG1lLnNob2Nrd2F2ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB3YXZlID0gbWUuc2hvY2t3YXZlc1tpXTtcblxuICAgICAgICAgICAgd2F2ZS5hZ2UgKz0gMTtcblxuICAgICAgICAgICAgbGV0IHByb2dyZXNzID0gd2F2ZS5hZ2UgLyB3YXZlLmxpZmU7XG5cbiAgICAgICAgICAgIGlmIChwcm9ncmVzcyA+PSAxKSB7XG4gICAgICAgICAgICAgICAgbWUuc2hvY2t3YXZlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRHJhdyB0d28gbGluZXMgcHJvcGFnYXRpbmcgb3V0IGZyb20gdGhlIGNsaWNrIHBvaW50XG4gICAgICAgICAgICBsZXQgeExlZnQgICAgPSB3YXZlLnggLSAod2F2ZS5zcGVlZCAqIHdhdmUuYWdlKSxcbiAgICAgICAgICAgICAgICB4UmlnaHQgICA9IHdhdmUueCArICh3YXZlLnNwZWVkICogd2F2ZS5hZ2UpLFxuICAgICAgICAgICAgICAgIGFscGhhICAgID0gMSAtIHByb2dyZXNzLFxuICAgICAgICAgICAgICAgIHtoZWlnaHR9ID0gbWUuY2FudmFzU2l6ZTtcblxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gSElHSExJR0hUOyAvLyBVc2UgY29uc3RhbnRcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGFscGhhOyAgICAgLy8gRmFkZSBvdXQgdmlhIGdsb2JhbEFscGhhXG4gICAgICAgICAgICBjdHgubGluZVdpZHRoICAgPSA0ICogKDEgLSBwcm9ncmVzcyk7XG5cbiAgICAgICAgICAgIC8vIExlZnQgV2F2ZVxuICAgICAgICAgICAgaWYgKHhMZWZ0ID4gMCkge1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oeExlZnQsIDApO1xuICAgICAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHhMZWZ0IC0gMjAsIGhlaWdodCAvIDIsIHhMZWZ0LCBoZWlnaHQpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJpZ2h0IFdhdmVcbiAgICAgICAgICAgIGlmICh4UmlnaHQgPCB3aWR0aCkge1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oeFJpZ2h0LCAwKTtcbiAgICAgICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4UmlnaHQgKyAyMCwgaGVpZ2h0IC8gMiwgeFJpZ2h0LCBoZWlnaHQpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDEgLy8gUmVzZXRcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtkYXRhLmlkXVxuICAgICAqL1xuICAgIHVwZGF0ZUFjdGl2ZUlkKGRhdGEpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVJZCA9IGRhdGE/LmlkIHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIHVwZGF0ZUdyYXBoRGF0YShkYXRhKSB7XG4gICAgICAgIC8vIE5vdCB1c2VkIHlldCwgYnV0IGtlcHQgZm9yIGludGVyZmFjZSBjb25zaXN0ZW5jeVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZGF0YS5jbGlja11cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkYXRhLmxlYXZlXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZGF0YS54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZGF0YS55XVxuICAgICAqL1xuICAgIHVwZGF0ZU1vdXNlU3RhdGUoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChkYXRhLmxlYXZlKSB7XG4gICAgICAgICAgICBtZS5tb3VzZS54ID0gLTEwMDA7XG4gICAgICAgICAgICBtZS5tb3VzZS55ID0gLTEwMDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChkYXRhLnggIT09IHVuZGVmaW5lZCkgbWUubW91c2UueCA9IGRhdGEueDtcbiAgICAgICAgICAgIGlmIChkYXRhLnkgIT09IHVuZGVmaW5lZCkgbWUubW91c2UueSA9IGRhdGEueTtcblxuICAgICAgICAgICAgaWYgKGRhdGEuY2xpY2spIHtcbiAgICAgICAgICAgICAgICBtZS5zaG9ja3dhdmVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB4ICAgIDogZGF0YS54LFxuICAgICAgICAgICAgICAgICAgICB5ICAgIDogZGF0YS55LFxuICAgICAgICAgICAgICAgICAgICBhZ2UgIDogMCxcbiAgICAgICAgICAgICAgICAgICAgbGlmZSA6IDYwLCAvLyBmcmFtZXNcbiAgICAgICAgICAgICAgICAgICAgc3BlZWQ6IDE1ICAvLyBweCBwZXIgZnJhbWVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLnJlY3RzXG4gICAgICovXG4gICAgdXBkYXRlTmF2UmVjdHMoZGF0YSkge1xuICAgICAgICBsZXQgcmVjdHMgPSBkYXRhPy5yZWN0cztcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZWN0cykpIHtcbiAgICAgICAgICAgIHRoaXMubmF2UmVjdHMgPSByZWN0c1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5uYXZSZWN0cyA9IFtdXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuZCBjYWNoZXMgZ3JhZGllbnRzIGFuZCBnZW9tZXRyeSBidWZmZXJzIGJhc2VkIG9uIGNhbnZhcyBzaXplLlxuICAgICAqIFRoaXMgZWxpbWluYXRlcyBwZXItZnJhbWUgYWxsb2NhdGlvbiBvZiBUeXBlZEFycmF5cyBhbmQgQ2FudmFzR3JhZGllbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqL1xuICAgIHVwZGF0ZVJlc291cmNlcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGxldCBtZSAgPSB0aGlzLFxuICAgICAgICAgICAgY3R4ID0gbWUuY29udGV4dDtcblxuICAgICAgICAvLyAxLiBSZS1hbGxvY2F0ZSBCdWZmZXJzIChGbG9hdDMyQXJyYXkpXG4gICAgICAgIC8vIEJhY2tncm91bmQ6IHN0ZXAgPSAxMFxuICAgICAgICBjb25zdCBiZ0NvdW50ID0gTWF0aC5jZWlsKHdpZHRoIC8gMTApICsgMTtcbiAgICAgICAgbWUud2F2ZUJ1ZmZlcnMuYmdBID0gbmV3IEZsb2F0MzJBcnJheShiZ0NvdW50KTtcbiAgICAgICAgbWUud2F2ZUJ1ZmZlcnMuYmdCID0gbmV3IEZsb2F0MzJBcnJheShiZ0NvdW50KTtcblxuICAgICAgICAvLyBGb3JlZ3JvdW5kOiBzdGVwID0gMlxuICAgICAgICBjb25zdCBmZ0NvdW50ID0gTWF0aC5jZWlsKHdpZHRoIC8gMikgKyAxO1xuICAgICAgICBtZS53YXZlQnVmZmVycy5mZ0EgPSBuZXcgRmxvYXQzMkFycmF5KGZnQ291bnQpO1xuICAgICAgICBtZS53YXZlQnVmZmVycy5mZ0IgPSBuZXcgRmxvYXQzMkFycmF5KGZnQ291bnQpO1xuXG4gICAgICAgIC8vIDIuIENhY2hlIEdyYWRpZW50c1xuICAgICAgICBpZiAoIWN0eCkgcmV0dXJuO1xuXG4gICAgICAgIC8vIEZvcmVncm91bmQgR3JhZGllbnRzXG4gICAgICAgIGNvbnN0IGdyYWQxID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIHdpZHRoLCAwKTtcbiAgICAgICAgZ3JhZDEuYWRkQ29sb3JTdG9wKDAsICAgUFJJTUFSWSk7XG4gICAgICAgIGdyYWQxLmFkZENvbG9yU3RvcCgwLjUsIEhJR0hMSUdIVCk7XG4gICAgICAgIGdyYWQxLmFkZENvbG9yU3RvcCgxLCAgIFBSSU1BUlkpO1xuICAgICAgICBtZS5ncmFkaWVudHMuZ3JhZDEgPSBncmFkMTtcblxuICAgICAgICBjb25zdCBncmFkMiA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCB3aWR0aCwgMCk7XG4gICAgICAgIGdyYWQyLmFkZENvbG9yU3RvcCgwLCAgIFNFQ09OREFSWSk7XG4gICAgICAgIGdyYWQyLmFkZENvbG9yU3RvcCgwLjUsIEhJR0hMSUdIVCk7XG4gICAgICAgIGdyYWQyLmFkZENvbG9yU3RvcCgxLCAgIFNFQ09OREFSWSk7XG4gICAgICAgIG1lLmdyYWRpZW50cy5ncmFkMiA9IGdyYWQyO1xuXG4gICAgICAgIGNvbnN0IGZnUmliYm9uID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIHdpZHRoLCAwKTtcbiAgICAgICAgZmdSaWJib24uYWRkQ29sb3JTdG9wKDAsICAgJ3JnYmEoNjIsIDk5LCAyMjEsIDAuMDUpJyk7XG4gICAgICAgIGZnUmliYm9uLmFkZENvbG9yU3RvcCgwLjUsICdyZ2JhKDY0LCAxOTYsIDI1NSwgMC4xKScpO1xuICAgICAgICBmZ1JpYmJvbi5hZGRDb2xvclN0b3AoMSwgICAncmdiYSg2MiwgOTksIDIyMSwgMC4wNSknKTtcbiAgICAgICAgbWUuZ3JhZGllbnRzLmZnUmliYm9uID0gZmdSaWJib247XG5cbiAgICAgICAgLy8gQmFja2dyb3VuZCBHcmFkaWVudHNcbiAgICAgICAgY29uc3QgYmdHcmFkMSA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCB3aWR0aCwgMCk7XG4gICAgICAgIGJnR3JhZDEuYWRkQ29sb3JTdG9wKDAsICAgJ3JnYmEoNjIsIDk5LCAyMjEsIDAuMSknKTtcbiAgICAgICAgYmdHcmFkMS5hZGRDb2xvclN0b3AoMC41LCAncmdiYSg2NCwgMTk2LCAyNTUsIDAuMiknKTtcbiAgICAgICAgYmdHcmFkMS5hZGRDb2xvclN0b3AoMSwgICAncmdiYSg2MiwgOTksIDIyMSwgMC4xKScpO1xuICAgICAgICBtZS5ncmFkaWVudHMuYmdHcmFkMSA9IGJnR3JhZDE7XG5cbiAgICAgICAgY29uc3QgYmdHcmFkMiA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCB3aWR0aCwgMCk7XG4gICAgICAgIGJnR3JhZDIuYWRkQ29sb3JTdG9wKDAsICAgJ3JnYmEoMTM5LCAxNjYsIDI1NSwgMC4xKScpO1xuICAgICAgICBiZ0dyYWQyLmFkZENvbG9yU3RvcCgwLjUsICdyZ2JhKDY0LCAxOTYsIDI1NSwgMC4yKScpO1xuICAgICAgICBiZ0dyYWQyLmFkZENvbG9yU3RvcCgxLCAgICdyZ2JhKDEzOSwgMTY2LCAyNTUsIDAuMSknKTtcbiAgICAgICAgbWUuZ3JhZGllbnRzLmJnR3JhZDIgPSBiZ0dyYWQyO1xuXG4gICAgICAgIGNvbnN0IGJnUmliYm9uID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIHdpZHRoLCAwKTtcbiAgICAgICAgYmdSaWJib24uYWRkQ29sb3JTdG9wKDAsICAgJ3JnYmEoNjIsIDk5LCAyMjEsIDAuMDIpJyk7XG4gICAgICAgIGJnUmliYm9uLmFkZENvbG9yU3RvcCgwLjUsICdyZ2JhKDY0LCAxOTYsIDI1NSwgMC4wNSknKTtcbiAgICAgICAgYmdSaWJib24uYWRkQ29sb3JTdG9wKDEsICAgJ3JnYmEoNjIsIDk5LCAyMjEsIDAuMDIpJyk7XG4gICAgICAgIG1lLmdyYWRpZW50cy5iZ1JpYmJvbiA9IGJnUmliYm9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzaXplXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNpemUuaGVpZ2h0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNpemUud2lkdGhcbiAgICAgKi9cbiAgICB1cGRhdGVTaXplKHNpemUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5jYW52YXNTaXplID0gc2l6ZTtcblxuICAgICAgICBpZiAobWUuY29udGV4dCkge1xuICAgICAgICAgICAgbWUuY29udGV4dC5jYW52YXMud2lkdGggID0gc2l6ZS53aWR0aDtcbiAgICAgICAgICAgIG1lLmNvbnRleHQuY2FudmFzLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICAgICAgICAgICAgLy8gUmUtaW5pdCByZXNvdXJjZXMgb24gcmVzaXplXG4gICAgICAgICAgICBtZS51cGRhdGVSZXNvdXJjZXMoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEhlYWRlckNhbnZhcyk7XG5cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=