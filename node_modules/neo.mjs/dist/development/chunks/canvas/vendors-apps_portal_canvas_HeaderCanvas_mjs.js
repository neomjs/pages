export const __webpack_esm_id__ = "vendors-apps_portal_canvas_HeaderCanvas_mjs";
export const __webpack_esm_ids__ = ["vendors-apps_portal_canvas_HeaderCanvas_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./apps/portal/canvas/Base.mjs"
/*!*************************************!*\
  !*** ./apps/portal/canvas/Base.mjs ***!
  \*************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @summary Abstract base class for Portal Canvas Renderers.
 *
 * This class serves as the foundation for the specialized canvas visualizations (Header, Home, Services, Ticket)
 * that run within the **Neo.mjs Canvas SharedWorker**.
 *
 * It creates helper singletons that manage their own `OffscreenCanvas` instances, providing a standardized
 * architecture for:
 * - **Lifecycle Management:** Initialization (`initGraph`), destruction (`clearGraph`), and resource cleanup.
 * - **Render Loop Control:** Unified `render` loop with pause/resume capabilities and frame scheduling.
 * - **Context Management:** Robust handling of `OffscreenCanvas` transfer and context acquisition via `waitForCanvas`.
 * - **Shared State:** Common state management for mouse interaction, time, and theming.
 *
 * These renderers operate off the main thread to ensure high-performance, 60fps animations without
 * blocking the UI.
 *
 * @class Portal.canvas.Base
 * @extends Neo.core.Base
 */
class Base extends _src_core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.canvas.Base'
         * @protected
         */
        className: 'Portal.canvas.Base',
        /**
         * Remote method access
         * @member {Object} remote
         * @protected
         */
        remote: {
            app: [
                'clearGraph',
                'initGraph',
                'pause',
                'resume',
                'setTheme',
                'updateMouseState',
                'updateSize'
            ]
        },
        /**
         * The active color theme ('light' or 'dark').
         * @member {String} theme_='light'
         * @reactive
         */
        theme_: 'light'
    }

    /**
     * @member {Number|null} animationId=null
     */
    animationId = null
    /**
     * @member {String|null} canvasId=null
     */
    canvasId = null
    /**
     * @member {Object|null} canvasSize=null
     */
    canvasSize = null
    /**
     * @member {OffscreenCanvasRenderingContext2D|null} context=null
     */
    context = null
    /**
     * Cache for reusable gradients to prevent GC.
     * @member {Object} gradients={}
     */
    gradients = {}
    /**
     * Flag to pause the render loop.
     * @member {Boolean} isPaused=false
     */
    isPaused = false
    /**
     * Tracked mouse position for interactive physics.
     * Initialize off-screen to prevent startup jitters.
     * @member {Object} mouse={x: -1000, y: -1000}
     */
    mouse = {x: -1000, y: -1000}
    /**
     * Global simulation time.
     * @member {Number} time=0
     */
    time = 0

    /**
     * @member {Function} renderLoop=this.render.bind(this)
     */
    renderLoop = this.render.bind(this)

    /**
     * Triggered after the `theme` config is changed.
     * Updates the resource cache (gradients, colors) to reflect the new theme immediately.
     * @param {String} value
     * @param {String} oldValue
     */
    afterSetTheme(value, oldValue) {
        if (value && this.canvasSize) {
            this.updateResources?.(this.canvasSize.width, this.canvasSize.height)
        }
    }

    /**
     * Checks if the canvas is ready to render.
     * Returns true only if the context exists and the simulation is not paused.
     * Subclasses should call this at the start of their `render` loop.
     * @returns {Boolean}
     */
    get canRender() {
        let me = this;
        return !!(me.context && !me.isPaused)
    }

    /**
     * Clears the graph state and stops the render loop.
     * Use this to cleanup resources when the component is destroyed or unmounted.
     */
    clearGraph() {
        let me = this;
        me.context     = null;
        me.canvasId    = null;
        me.canvasSize  = null;
        me.animationId = null;
        me.isPaused    = false;
        me.gradients   = {};
        me.mouse       = {x: -1000, y: -1000};
        me.time        = 0
    }

    /**
     * Initializes the canvas context.
     * Starts the polling mechanism to wait for the OffscreenCanvas transfer from the Main Thread.
     * @param {Object} opts
     * @param {String} opts.canvasId
     * @param {String} opts.windowId
     */
    initGraph({canvasId, windowId}) {
        let me        = this,
            hasChange = me.canvasId !== canvasId;

        me.canvasId = canvasId;

        me.waitForCanvas(canvasId, windowId, hasChange)
    }

    /**
     * Hook for subclasses to handle mouse clicks.
     * Called by `updateMouseState` when a click event is received.
     * @param {Object} data
     */
    onMouseClick(data) {}

    /**
     * Pauses the simulation.
     * The render loop will exit early while `isPaused` is true.
     */
    pause() {
        this.isPaused = true
    }

    /**
     * Abstract render method.
     * Subclasses must implement this method to draw the frame.
     */
    render() {}

    /**
     * Resumes the simulation.
     * If the simulation was paused, this restarts the render loop.
     */
    resume() {
        let me = this;

        if (me.isPaused) {
            me.isPaused = false;
            me.renderLoop()
        }
    }

    /**
     * Exposed method for Remote Access to trigger the reactive config setter.
     * @param {String} value
     */
    setTheme(value) {
        this.theme = value
    }

    /**
     * Updates the local mouse state from main thread events.
     * Delegates click events to `onMouseClick`.
     * @param {Object} data
     * @param {Boolean} [data.click]
     * @param {Boolean} [data.leave]
     * @param {Number} [data.x]
     * @param {Number} [data.y]
     */
    updateMouseState(data) {
        let me = this;

        if (data.leave) {
            me.mouse.x = -1000;
            me.mouse.y = -1000
        } else {
            if (data.x !== undefined) me.mouse.x = data.x;
            if (data.y !== undefined) me.mouse.y = data.y;

            if (data.click) {
                me.onMouseClick(data)
            }
        }
    }

    /**
     * Updates the canvas size and resizes the internal context.
     * Triggers `updateResources` hook to allow subclasses to regenerate buffers/gradients.
     * @param {Object} size
     * @param {Number} size.height
     * @param {Number} size.width
     */
    updateSize(size) {
        let me = this;

        me.canvasSize = size;

        if (me.context) {
            me.context.canvas.width  = size.width;
            me.context.canvas.height = size.height;
            // Calls the hook to re-generate resources if implemented
            me.updateResources?.(size.width, size.height)
        }
    }

    /**
     * Polls for the OffscreenCanvas until it is available in the Worker's `canvasWindowMap`.
     * Once found, it initializes the context and starts the render loop.
     * @param {String} canvasId
     * @param {String} windowId
     * @param {Boolean} hasChange
     * @protected
     */
    waitForCanvas(canvasId, windowId, hasChange) {
        let me     = this,
            canvas = Neo.currentWorker.canvasWindowMap[canvasId]?.[windowId];

        if (canvas) {
            me.context = canvas.getContext('2d');

            // Standardize size update
            me.updateSize({width: canvas.width, height: canvas.height});

            // Optional hook for subclasses
            me.onGraphMounted?.(canvas.width, canvas.height);

            if (hasChange && !me.animationId) {
                me.renderLoop()
            }
        } else {
            setTimeout(me.waitForCanvas.bind(me, canvasId, windowId, hasChange), 50)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Base));


/***/ },

/***/ "./apps/portal/canvas/HeaderCanvas.mjs"
/*!*********************************************!*\
  !*** ./apps/portal/canvas/HeaderCanvas.mjs ***!
  \*********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./apps/portal/canvas/Base.mjs");


const
    hasRaf    = typeof requestAnimationFrame === 'function',
    PRIMARY   = '#3E63DD',
    SECONDARY = '#536DFE',
    HIGHLIGHT = '#00BFFF';

/**
 * @summary SharedWorker renderer for the HeaderToolbar overlay.
 *
 * Implements the **"Luminous Flux"** visual theme, an ambient, interactive energy simulation that
 * serves as the backdrop for the Portal header.
 *
 * **Visual Architecture:**
 * 1. **Neo Ether (Background):** A volumetric particle field composed of faint "dust" and larger "nebula" orbs.
 *    This provides atmospheric depth, fluid interactivity (mouse repulsion), and bridges the contrast gap
 *    between the white background and the foreground elements.
 * 2. **Ambient Helix (Midground):** A large-scale, slow-moving sine wave pattern that provides structural
 *    texture to the negative space. Now enhanced with a **volumetric Ribbon fill** to add depth.
 * 3. **Split Stream (Foreground):** Two intertwined energy strands (Helix/DNA) that flow across the canvas.
 *    - **3D Ribbon Effect:** A subtle gradient fills the space between strands, simulating a twisting surface.
  *   - **Neon Tube Effect:** Strands are rendered with a bright white core inside a colored glow, creating a physical light-emitting look.
  *   - **Adaptive Geometry:** The strands flow loosely around text buttons but tighten into a "high-gravity orbit"
  *     around social icons.
  *   - **Energy Surge (Active State):** The segment of the stream passing through the active navigation item
  *     is rendered with a high-intensity white glow and a nervous pulse, semantically highlighting the current view.
  *   - **Preview Glow (Hover State):** A static, high-contrast glow highlights the item under the cursor,
  *     providing immediate, distinct feedback separate from the active state.
  *
  * **Performance Architecture (Zero-Allocation):**
 * To maintain 60fps on high-refresh displays without GC stutters, this class employs a **Zero-Allocation** strategy during the render loop.
 * 1. **TypedArray Buffers:** Wave geometry is stored in pre-allocated `Float32Array` buffers (`waveBuffers`), reused every frame.
 * 2. **Gradient Caching:** CanvasGradients are created only on resize (`updateResources`) and cached, avoiding expensive generator calls per frame.
 * 3. **Reusable Objects:** Physics calculations write directly to buffers instead of returning new Arrays of Objects.
 *
 * @class Portal.canvas.HeaderCanvas
 * @extends Portal.canvas.Base
 * @singleton
 * @see Portal.view.HeaderCanvas
 */
class HeaderCanvas extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static colors = {
        dark : {
            background   : ['rgba(62, 99, 221, 0.1)', 'rgba(64, 196, 255, 0.2)', 'rgba(62, 99, 221, 0.1)'],
            background2  : ['rgba(139, 166, 255, 0.1)', 'rgba(64, 196, 255, 0.2)', 'rgba(139, 166, 255, 0.1)'],
            bgRibbon     : ['rgba(62, 99, 221, 0.02)', 'rgba(64, 196, 255, 0.05)', 'rgba(62, 99, 221, 0.02)'],
            fgRibbon     : ['rgba(62, 99, 221, 0.025)', 'rgba(64, 196, 255, 0.05)', 'rgba(62, 99, 221, 0.025)'],
            grad1        : [PRIMARY, HIGHLIGHT, PRIMARY],
            grad2        : [SECONDARY, HIGHLIGHT, SECONDARY],
            hover        : HIGHLIGHT,
            particle     : HIGHLIGHT,
            particleAlpha: {nebula: 0.2, dust: 0.2},
            shockwave    : HIGHLIGHT
        },
        light: {
            background   : ['rgba(62, 99, 221, 0.1)', 'rgba(64, 196, 255, 0.2)', 'rgba(62, 99, 221, 0.1)'],
            background2  : ['rgba(139, 166, 255, 0.1)', 'rgba(64, 196, 255, 0.2)', 'rgba(139, 166, 255, 0.1)'],
            bgRibbon     : ['rgba(62, 99, 221, 0.02)', 'rgba(64, 196, 255, 0.05)', 'rgba(62, 99, 221, 0.02)'],
            fgRibbon     : ['rgba(62, 99, 221, 0.05)', 'rgba(64, 196, 255, 0.1)', 'rgba(62, 99, 221, 0.05)'],
            grad1        : [PRIMARY, HIGHLIGHT, PRIMARY],
            grad2        : [SECONDARY, HIGHLIGHT, SECONDARY],
            hover        : PRIMARY,
            particle     : HIGHLIGHT,
            particleAlpha: {nebula: 0.2, dust: 0.2},
            shockwave    : HIGHLIGHT
        }
    }

    static config = {
        /**
         * @member {String} className='Portal.canvas.HeaderCanvas'
         * @protected
         */
        className: 'Portal.canvas.HeaderCanvas',
        /**
         * Remote method access
         * @member {Object} remote
         * @protected
         */
        remote: {
            app: [
                'updateActiveId',
                'updateGraphData',
                'updateHoverId',
                'updateNavRects'
            ]
        },
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * @member {String|null} activeId=null
     */
    activeId = null
    /**
     * @member {String|null} hoverId=null
     */
    hoverId = null
    /**
     * @member {Object[]} navRects=[]
     */
    navRects = []
    /**
     * @member {Object[]} particles=[]
     */
    particles = []
    /**
     * @member {Object[]} shockwaves=[]
     */
    shockwaves = []
    /**
     * Pre-allocated buffers for wave geometry.
     * Uses `Float32Array` to eliminate Garbage Collection pressure during the render loop.
     * @member {Object} waveBuffers={bgA: null, bgB: null, fgA: null, fgB: null}
     */
    waveBuffers = {bgA: null, bgB: null, fgA: null, fgB: null}

    /**
     * Clears the graph state and stops the render loop.
     */
    clearGraph() {
        let me = this;
        super.clearGraph();
        me.navRects    = [];
        me.particles   = [];
        me.shockwaves  = [];
        me.waveBuffers = {bgA: null, bgB: null, fgA: null, fgB: null}
    }

    /**
     * Hook to initialize particles after context is ready
     * @param {Number} width
     * @param {Number} height
     */
    onGraphMounted(width, height) {
        this.initParticles(width, height)
    }

    /**
     * Initializes the particle system for the "Neo Ether" effect.
     *
     * Creates a mix of large, slow-moving "nebula" particles and smaller, faster "dust" particles
     * to create depth and atmosphere.
     *
     * @param {Number} width
     * @param {Number} height
     */
    initParticles(width, height) {
        let me = this;
        me.particles = [];
        const
            count       = 60,
            themeColors = me.constructor.colors[me.theme],
            alphas      = themeColors.particleAlpha;

        for (let i = 0; i < count; i++) {
            let isNebula = Math.random() > 0.8; // 20% are large nebula orbs

            me.particles.push({
                isNebula,
                x        : Math.random() * width,
                y        : Math.random() * height,
                vx       : isNebula ? (Math.random() * 0.2 + 0.05) : (Math.random() * 0.5 + 0.1), // Nebulae move slower
                vy       : (Math.random() - 0.5) * 0.2,
                size     : isNebula ? (Math.random() * 30 + 20) : (Math.random() * 2 + 0.5), // Large vs Small
                alpha    : isNebula ? (Math.random() * 0.15 + alphas.nebula) : (Math.random() * 0.4 + alphas.dust),
                baseAlpha: isNebula ? (Math.random() * 0.15 + alphas.nebula) : (Math.random() * 0.4 + alphas.dust)
            })
        }
    }

    /**
     * Main render loop.
     *
     * Orchestrates the rendering of all visual layers:
     * 1. Ambient Background (Ribbon + Helix)
     * 2. Neo Ether (Particles)
     * 3. Split Stream (Foreground Auras)
     * 4. Shockwaves (Interaction)
     *
     * Uses `setTimeout` instead of `requestAnimationFrame` because this runs in a SharedWorker
     * where `rAF` is not available. Targets ~60fps (16ms).
     */
    render() {
        let me = this;

        if (!me.canRender) {
            return
        }

        const
            ctx    = me.context,
            width  = me.canvasSize?.width  || 100,
            height = me.canvasSize?.height || 50;

        me.time += 0.05;

        // Auto-reinit particles if size changes significantly or empty OR count mismatch (config update)
        if (me.particles.length !== 60) {
            me.initParticles(width, height)
        }

        ctx.clearRect(0, 0, width, height);

        // 1. Draw Ambient Background
        me.drawAmbientBackground(ctx, width, height);

        // 2. Draw Ether Particles (Background Layer)
        me.drawParticles(ctx, width, height);

        // 3. Draw "Auras" (Hover Effects) => 3D Ribbon + Neon Tube
        me.drawAuras(ctx, width, height);

        // 3b. Draw Active Overlay
        me.drawActiveOverlay(ctx, width);

        // 3c. Draw Hover Overlay
        me.drawHoverOverlay(ctx, width);

        // 4. Draw "Shockwaves" (Click Effects)
        me.drawShockwaves(ctx, width);

        if (hasRaf) {
            me.animationId = requestAnimationFrame(me.renderLoop)
        } else {
            me.animationId = setTimeout(me.renderLoop, 1000 / 60)
        }
    }

    /**
     * Calculates the points for the two energy strands based on physics and interaction.
     *
     * **Zero-Allocation Contract:**
     * This method writes directly to the pre-allocated `this.waveBuffers` `Float32Array`s.
     * It does **not** allocate new arrays or objects, ensuring zero GC pressure.
     *
     * @param {Number} width
     * @param {Number} height
     * @returns {Object} {shimmerA, shimmerB, count} Metadata for rendering (scalars only)
     */
    calculateStrandGeometry(width, height) {
        let me = this;

        if (!Array.isArray(me.navRects) || !me.waveBuffers.fgA) {
            return null
        }

        const
            bufA    = me.waveBuffers.fgA,
            bufB    = me.waveBuffers.fgB,
            step    = 2,
            count   = Math.ceil(width / step),
            centerY = height / 2,
            padding = 10,
            maxH    = (height - (padding * 2)) / 2,
            // BREATHING: Modulate base amplitude over time (slow pulse)
            breath   = Math.sin(me.time * 0.5) * 2,
            baseAmp  = Math.min(6 + breath, maxH),
            hoverAmp = 4;

        // REF 1: Linked Phase - Shimmer leads Breath by 90deg ("Charging up")
        let baseShimmer = 0.75 + (Math.sin(me.time * 0.5 + Math.PI / 2) * 0.25);

        // REF 2: Independent Strand Shimmer
        let shimmerA = baseShimmer,
            shimmerB = 0.75 + (Math.sin(me.time * 0.5 + Math.PI / 2 + Math.PI / 3) * 0.25);

        for (let i = 0; i < count; i++) {
            let x = i * step,
                {offsetY, intensity, isIconZone} = me.getStreamOffset(x, height, width);

            // FREQUENCY MODULATION:
            let freqMod   = Math.sin(x * 0.002 + me.time * 0.1) * (20 + (intensity * 10)),
                timeShift = me.time * 2;

            // DAMPING FOR ICONS:
            let localAmp = baseAmp * (1 - (isIconZone * 0.6));

            // Noise Calculation
            // We calculate noise once per frame per point to ensure that the Ribbon Fill and
            // Neon Stroke passes use identical geometry, preventing visual tearing.
            let noiseA = (Math.random() - 0.5) * hoverAmp * intensity,
                noiseB = (Math.random() - 0.5) * hoverAmp * intensity,
                sine   = Math.sin(((x + freqMod) * 0.04) - timeShift) * localAmp,
                sineB  = Math.sin(((x + freqMod) * 0.04) - timeShift + Math.PI) * localAmp; // Inverted

            // SHOCKWAVE PHYSICS (Displacement)
            let shockY = 0;
            if (me.shockwaves.length > 0) {
                me.shockwaves.forEach(wave => {
                    let radius = wave.age * wave.speed,
                        dist   = x - wave.x; // Signed distance

                    // Check if point is near the wave front (e.g. within 50px)
                    if (Math.abs(dist) < radius && Math.abs(dist) > radius - 60) {
                        // Pulse shape: Sine wave based on distance from center relative to radius
                        let pulse = Math.sin((dist / radius) * Math.PI * 10) * (1 - (wave.age / wave.life)) * 20;
                        shockY += pulse
                    }
                })
            }

            // Write Y values to buffers
            bufA[i] = centerY + sine  - offsetY + noiseA + shockY;
            bufB[i] = centerY + sineB + offsetY + noiseB + shockY;
        }

        return {shimmerA, shimmerB, count}
    }

    /**
     * Draws the "Ether" particle field to add volumetric depth and interactivity.
     *
     * **Intent:**
     * Creates a living, breathing atmosphere ("Neo Ether") that fills the negative space.
     * This bridges the visual gap between the stark white background and the high-contrast foreground lines.
     *
     * **Physics:**
     * - **Drift:** Particles move with a constant `vx` to simulate data flow or wind.
     * - **Repulsion:** The mouse cursor acts as a "repulsor field," pushing particles away and brightening them
     *   to create a "hole" in the fog.
     * - **Nebulae:** Large, faint particles create a "fog" effect, while small, bright particles act as "dust."
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {Number} width
     * @param {Number} height
     */
    drawParticles(ctx, width, height) {
        let me = this;

        const
            themeColors = me.constructor.colors[me.theme],
            pColor      = themeColors.particle;

        me.particles.forEach(p => {
            // Update Position
            p.x += p.vx;
            p.y += p.vy;

            // Wrap around
            if (p.x > width + p.size)  p.x = -p.size;
            if (p.x < -p.size)         p.x = width + p.size;
            if (p.y > height + p.size) p.y = -p.size;
            if (p.y < -p.size)         p.y = height + p.size;

            // Interaction: Mouse Repulsion
            // All particles react to the mouse, but "Nebula" particles have higher calculated mass,
            // resulting in less displacement than the lighter "Dust" particles.
            let dx = p.x - me.mouse.x,
                dy = p.y - me.mouse.y,
                dist = Math.sqrt(dx*dx + dy*dy),
                maxDist = p.isNebula ? 150 : 100;

            if (dist < maxDist && dist > 0) {
                let force = (maxDist - dist) / maxDist;
                // Push away
                let mass = p.isNebula ? 5 : 1;
                p.x += (dx / dist) * force * (2 / mass);
                p.y += (dy / dist) * force * (2 / mass);
                // Brighten slightly
                p.alpha = Math.min(p.baseAlpha + force * (p.isNebula ? 0.05 : 0.5), 0.8);
            }

            // Interaction: Shockwave Repulsion
            if (me.shockwaves.length > 0) {
                me.shockwaves.forEach(wave => {
                    let wx     = p.x - wave.x,
                        wy     = p.y - wave.y,
                        wDist  = Math.sqrt(wx * wx + wy * wy),
                        radius = wave.age * wave.speed;

                    // If particle is near the expanding ring (width 40px)
                    if (wDist < radius && wDist > radius - 40) {
                        let force = (1 - (wave.age / wave.life)) * 2; // Decay force over time
                        // Push outward
                        p.x += (wx / wDist) * force * 5;
                        p.y += (wy / wDist) * force * 5;
                        p.alpha = Math.min(p.alpha + 0.3, 1) // Flash bright
                    }
                })
            }

            // Return to base alpha
            if (p.alpha > p.baseAlpha) {
                p.alpha -= 0.005
            }

            ctx.globalAlpha = p.alpha;
            ctx.beginPath();

            if (p.isNebula) {
                // Nebula Visualization
                // Use a radial gradient to create a soft, cloud-like appearance.
                let g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
                g.addColorStop(0, pColor);
                g.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = g;
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill()
            } else {
                ctx.fillStyle = pColor;
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill()
            }
        });

        ctx.globalAlpha = 1
    }

    /**
     * Draws an additional highlight for the active navigation item.
     * **"Energy Surge" Effect:**
     * Renders a high-intensity pass of the energy strands *only* within the active zone.
     * This makes the lines appear to "power up" or glow white-hot as they pass through the active view,
     * fully integrated with the existing geometry.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {Number} width
     */
    drawActiveOverlay(ctx, width) {
        let me = this,
            rect;

        if (!me.activeId || !me.waveBuffers.fgA) return;

        // Zero-Allocation: Use for-loop instead of .find() to avoid closure creation
        for (const r of me.navRects) {
            if (r.id === me.activeId) {
                rect = r;
                break
            }
        }

        if (!rect) return;

        const
            step   = 2, // Must match calculateStrandGeometry
            // Add padding to fade the effect in/out smoothly
            pad    = 10,
            startX = Math.max(0, rect.x - pad),
            endX   = Math.min(width, rect.x + rect.width + pad),
            startI = Math.floor(startX / step),
            endI   = Math.ceil(endX / step),
            bufA   = me.waveBuffers.fgA,
            bufB   = me.waveBuffers.fgB;

        ctx.save();
        ctx.lineCap  = 'round';
        ctx.lineJoin = 'round';

        // High-Intensity Glow
        ctx.shadowBlur  = 20;
        ctx.shadowColor = '#FFFFFF'; // White glow
        ctx.strokeStyle = '#FFFFFF'; // White core
        ctx.lineWidth   = 2;

        // Gradient Fade mask (manual alpha)
        // We can't easily gradient-stroke a sub-path, so we rely on globalAlpha
        // combined with the "hot" white color to make it pop.
        ctx.globalAlpha = 0.6 + (Math.sin(me.time * 3) * 0.2); // Fast, nervous pulse

        // Inline drawing to avoid closure
        ctx.beginPath();
        ctx.moveTo(startI * step, bufA[startI]);
        for (let i = startI + 1; i <= endI; i++) {
            ctx.lineTo(i * step, bufA[i])
        }
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(startI * step, bufB[startI]);
        for (let i = startI + 1; i <= endI; i++) {
            ctx.lineTo(i * step, bufB[i])
        }
        ctx.stroke();

        ctx.restore()
    }

    /**
     * Draws an additional highlight for the hovered navigation item.
     * **"Preview" Effect:**
     * Renders a static intensity pass of the energy strands within the hovered zone.
     * Uses the theme-specific hover color (Cyan/Blue) to distinguish it from the active state (White).
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {Number} width
     */
    drawHoverOverlay(ctx, width) {
        let me = this,
            rect;

        if (!me.hoverId || !me.waveBuffers.fgA) return;

        // Zero-Allocation: Use for-loop instead of .find() to avoid closure creation
        for (const r of me.navRects) {
            if (r.id === me.hoverId) {
                rect = r;
                break
            }
        }

        if (!rect) return;

        const
            step        = 2, // Must match calculateStrandGeometry
            pad         = 10,
            startX      = Math.max(0, rect.x - pad),
            endX        = Math.min(width - 3, rect.x + rect.width + pad),
            startI      = Math.floor(startX / step),
            endI        = Math.ceil(endX / step),
            bufA        = me.waveBuffers.fgA,
            bufB        = me.waveBuffers.fgB,
            themeColors = me.constructor.colors[me.theme];

        ctx.save();
        ctx.lineCap  = 'round';
        ctx.lineJoin = 'round';

        // Hover Effect: Static Glow (No Pulse)
        ctx.shadowBlur  = 15;
        ctx.shadowColor = themeColors.hover;
        ctx.strokeStyle = themeColors.hover;
        ctx.lineWidth   = 2;
        ctx.globalAlpha = 1;

        // Inline drawing to avoid closure
        ctx.beginPath();
        ctx.moveTo(startI * step, bufA[startI]);
        for (let i = startI + 1; i <= endI; i++) {
            ctx.lineTo(i * step, bufA[i])
        }
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(startI * step, bufB[startI]);
        for (let i = startI + 1; i <= endI; i++) {
            ctx.lineTo(i * step, bufB[i])
        }
        ctx.stroke();

        ctx.restore()
    }

    /**
     * Draws a subtle, large-scale background Helix pattern with a 3D Ribbon effect.
     *
     * **Intent:**
     * Provides a structural backbone to the negative space. Unlike the particle field (which is chaotic),
     * this layer is ordered and rhythmic, reinforcing the "DNA/Helix" theme even in the background.
     *
     * **Visuals:**
     * 1. **Ribbon Fill:** A barely-visible volumetric gradient fills the space between the helices.
     * 2. **Depth of Field:** Uses wide, very low opacity strokes to appear "out of focus" behind the sharp foreground.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {Number} width
     * @param {Number} height
     */
    drawAmbientBackground(ctx, width, height) {
        let me = this;

        // Ensure buffers exist
        if (!me.waveBuffers.bgA) return;

        let t       = me.time * 0.5,
            centerY = height / 2,
            amp     = height * 0.4,
            step    = 10,
            count   = Math.ceil(width / step),
            bufA    = me.waveBuffers.bgA,
            bufB    = me.waveBuffers.bgB;

        // 1. Calculate Points (Direct to Buffer)
        for (let i = 0; i < count; i++) {
            let x = i * step;
            bufA[i] = centerY + Math.sin((x * 0.01) + t) * amp;
            bufB[i] = centerY + Math.sin((x * 0.01) + t + Math.PI) * amp
        }

        // --- 2. RIBBON FILL (Background Surface) ---
        ctx.fillStyle = me.gradients.bgRibbon;
        ctx.beginPath();

        ctx.moveTo(0, bufA[0]);
        for (let i = 1; i < count; i++) {
            ctx.lineTo(i * step, bufA[i])
        }

        for (let i = count - 1; i >= 0; i--) {
            ctx.lineTo(i * step, bufB[i])
        }
        ctx.closePath();
        ctx.fill();

        // --- 3. STROKES ---
        ctx.lineWidth = 15;
        ctx.lineCap   = 'round';
        ctx.lineJoin  = 'round';

        // Use cached gradients
        const drawStroke = (buffer, strokeStyle) => {
            ctx.strokeStyle = strokeStyle;
            ctx.beginPath();
            ctx.moveTo(0, buffer[0]);
            for (let i = 1; i < count; i++) {
                ctx.lineTo(i * step, buffer[i])
            }
            ctx.stroke()
        };

        drawStroke(bufA, me.gradients.bgGrad1);
        drawStroke(bufB, me.gradients.bgGrad2);
    }

    /**
     * Draws the main foreground "Split Stream" energy strands with 3D effects.
     *
     * **3D Architecture:**
     * 1. **Ribbon Fill:** Draws a low-opacity gradient between Strand A and Strand B, creating a twisting surface.
     * 2. **Neon Tube (Outer):** The colored glow of the strands.
     * 3. **Neon Tube (Core):** A bright white inner core to simulate volumetric light.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {Number} width
     * @param {Number} height
     */
    drawAuras(ctx, width, height) {
        let me = this;

        if (!Array.isArray(me.navRects)) return;

        // 1. Calculate Physics (Shared for Ribbon and Strands) - Returns metadata, data is in buffers
        const geometry = me.calculateStrandGeometry(width, height);

        if (!geometry) return;

        const
            {shimmerA, shimmerB, count} = geometry,
            bufA        = me.waveBuffers.fgA,
            bufB        = me.waveBuffers.fgB,
            step        = 2,
            themeColors = me.constructor.colors[me.theme];

        // --- 2. RIBBON FILL (The 3D Surface) ---
        ctx.fillStyle = me.gradients.fgRibbon;
        ctx.beginPath();

        ctx.moveTo(0, bufA[0]);
        for (let i = 1; i < count; i++) {
            ctx.lineTo(i * step, bufA[i]);
        }

        for (let i = count - 1; i >= 0; i--) {
            ctx.lineTo(i * step, bufB[i]);
        }
        ctx.closePath();
        ctx.fill();

        // --- 3. NEON STRANDS (Tube Effect) ---

        ctx.lineCap     = 'round';
        ctx.lineJoin    = 'round';

        // Helper to draw a strand from buffer
        const drawStrand = (buffer, gradient, shimmer, color, isCore) => {
            ctx.beginPath();
            ctx.strokeStyle = isCore ? '#FFFFFF' : gradient;
            ctx.lineWidth   = isCore ? 1 : 3;
            ctx.globalAlpha = isCore ? (shimmer + 0.2) : shimmer;

            if (!isCore) {
                ctx.shadowBlur  = 10;
                ctx.shadowColor = color;
            } else {
                ctx.shadowBlur  = 0;
            }

            ctx.moveTo(0, buffer[0]);
            for (let i = 1; i < count; i++) {
                ctx.lineTo(i * step, buffer[i]);
            }
            ctx.stroke();
        };

        // Draw Glows (Outer Tube)
        // Extract base color from gradient array for shadow
        const color1 = themeColors.grad1[0];
        const color2 = themeColors.grad2[0];

        drawStrand(bufA, me.gradients.grad1, shimmerA, color1, false);
        drawStrand(bufB, me.gradients.grad2, shimmerB, color2, false);

        // Draw Cores (Inner Filament)
        drawStrand(bufA, null, shimmerA, null, true);
        drawStrand(bufB, null, shimmerB, null, true);

        // Cleanup: Reset shadow and alpha to prevent bleeding into the next render pass
        ctx.shadowBlur  = 0;
        ctx.globalAlpha = 1;
    }

    /**
     * Calculates the physics for diverting the stream around UI elements.
     *
     * **Logic:**
     * 1. **Detection:** Iterates through `navRects` to find if the current `x` is near a button.
     * 2. **Adaptive Geometry:**
     *    - **Text Buttons:** Uses a wide Cosine envelope for smooth flow.
     *    - **Icon Buttons:** Uses a sharp Cubed envelope (`Math.pow(x, 3)`) to create a "Tight Orbit" effect.
     * 3. **Vertical Clamping:** Ensures the diversion never pushes the wave off-canvas.
     *
     * @param {Number} x
     * @param {Number} height (Canvas height)
     * @param {Number} width (Canvas width)
     * @returns {Object} {offsetY, intensity, isIconZone}
     */
    getStreamOffset(x, height, width) {
        let me        = this,
            offsetY   = 0,
            intensity = 0, // 0 to 1 (Hover magnitude)
            isIconZone = 0; // 0 to 1 (Proximity to an Icon Button)

        const
            verticalPadding = 10,
            maxSafeOffset   = (height / 2) - verticalPadding;

        // Collision Detection
        // Iterate through all navigation items to determine stream diversion.
        // Given the low item count (<20), a simple linear scan is efficient.
        for (const rect of me.navRects) {
            // Buffer zone for smooth transition
            const buffer = 40;

            if (x >= rect.x - buffer && x <= rect.x + rect.width + buffer) {
                // We are inside the influence zone of this button

                // Shape Detection
                // Discriminate between square-ish icons (socials) and wide text buttons
                // to apply different diversion envelopes.
                const
                    ratio   = rect.width / rect.height,
                    isIcon  = ratio < 1.5, // Threshold for "Circle" vs "Rectangle"
                    centerX = rect.x + rect.width / 2,
                    span    = (rect.width / 2) + buffer,
                    distX   = Math.abs(x - centerX);

                if (distX < span) {
                    let envelope;

                    if (isIcon) {
                        // TIGHT ORBIT (Sharper curve for icons)
                        let normDist = distX / span; // 0 to 1
                        envelope = Math.pow((1 + Math.cos(Math.PI * normDist)) / 2, 3); // Cubed for sharper falloff
                        isIconZone = Math.max(isIconZone, envelope); // Track if we are in an icon zone
                    } else {
                        // WIDE FLOW (Standard smooth curve for text)
                        envelope = (1 + Math.cos(Math.PI * distX / span)) / 2;
                    }

                    // Diversion Amplitude
                    // Text buttons require more visual clearance than icons due to their
                    // rectangular nature. Icons allow for a tighter "orbit".
                    let targetH = isIcon ? (rect.height / 2) : ((rect.height / 2) + 4);

                    // Vertical Clamping
                    // Cap the offset to ensure the stream stays within the canvas bounds.
                    let targetOffset = Math.min(targetH, maxSafeOffset);

                    // Add to total offset (using max to handle overlaps cleanly)
                    offsetY = Math.max(offsetY, targetOffset * envelope);

                    // Interaction: Proximity Check
                    // Boost the wave intensity if the mouse is hovering over or near this specific button.

                    // Distance from mouse to button center
                    let dx = me.mouse.x - centerX,
                        dy = me.mouse.y - (rect.y + rect.height/2),
                        distMouse = Math.sqrt(dx*dx + dy*dy);

                    // If mouse is near this button, boost intensity
                    if (distMouse < Math.max(rect.width, rect.height)) {
                        intensity = Math.max(intensity, 1 - (distMouse / 150));
                    }
                }
            }
        }

        // Baseline Separation
        // By returning offsetY=0 in empty space, the strands will naturally cross (Helix effect)
        // driven by the sine wave logic in calculateStrandPoints.
        return {offsetY, intensity, isIconZone};
    }

    /**
     * Draws expanding shockwaves from clicks.
     * @param {CanvasRenderingContext2D} ctx
     * @param {Number} width
     */
    drawShockwaves(ctx, width) {
        let me = this;

        if (me.shockwaves.length === 0) return;

        const themeColors = me.constructor.colors[me.theme];

        for (let i = me.shockwaves.length - 1; i >= 0; i--) {
            let wave = me.shockwaves[i];

            wave.age += 1;

            let progress = wave.age / wave.life;

            if (progress >= 1) {
                me.shockwaves.splice(i, 1);
                continue
            }

            // Draw two lines propagating out from the click point
            let xLeft    = wave.x - (wave.speed * wave.age),
                xRight   = wave.x + (wave.speed * wave.age),
                alpha    = 1 - progress,
                {height} = me.canvasSize;

            ctx.beginPath();
            ctx.strokeStyle = themeColors.shockwave; // Use theme color
            ctx.globalAlpha = alpha;     // Fade out via globalAlpha
            ctx.lineWidth   = 4 * (1 - progress);

            // Left Wave
            if (xLeft > 0) {
                ctx.moveTo(xLeft, 0);
                ctx.quadraticCurveTo(xLeft - 20, height / 2, xLeft, height)
            }

            // Right Wave
            if (xRight < width) {
                ctx.moveTo(xRight, 0);
                ctx.quadraticCurveTo(xRight + 20, height / 2, xRight, height)
            }

            ctx.stroke();
            ctx.globalAlpha = 1 // Reset
        }
    }

    /**
     * @param {Object} data
     * @param {String} [data.id]
     */
    updateActiveId(data) {
        this.activeId = data?.id || null
    }

    /**
     * @param {Object} data
     */
    updateGraphData(data) {
        // Not used yet, but kept for interface consistency
    }

    /**
     * @param {Object} data
     * @param {String} [data.id]
     */
    updateHoverId(data) {
        this.hoverId = data?.id || null
    }

    /**
     * Hook to handle mouse clicks.
     * @param {Object} data
     */
    onMouseClick(data) {
        this.shockwaves.push({
            x    : data.x,
            y    : data.y,
            age  : 0,
            life : 60, // frames
            speed: 15  // px per frame
        })
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.rects
     */
    updateNavRects(data) {
        let rects = data?.rects;

        if (Array.isArray(rects)) {
            this.navRects = rects
        } else {
            this.navRects = []
        }
    }

    /**
     * Creates and caches gradients and geometry buffers based on canvas size.
     * This eliminates per-frame allocation of TypedArrays and CanvasGradients.
     *
     * @param {Number} width
     * @param {Number} height
     */
    updateResources(width, height) {
        let me  = this,
            ctx = me.context;

        // 1. Re-allocate Buffers (Float32Array)
        // Background: step = 10
        const bgCount = Math.ceil(width / 10) + 1;
        me.waveBuffers.bgA = new Float32Array(bgCount);
        me.waveBuffers.bgB = new Float32Array(bgCount);

        // Foreground: step = 2
        const fgCount = Math.ceil(width / 2) + 1;
        me.waveBuffers.fgA = new Float32Array(fgCount);
        me.waveBuffers.fgB = new Float32Array(fgCount);

        // 2. Cache Gradients
        if (!ctx) return;

        const themeColors = me.constructor.colors[me.theme];

        // Foreground Gradients
        const grad1 = ctx.createLinearGradient(0, 0, width, 0);
        grad1.addColorStop(0,   themeColors.grad1[0]);
        grad1.addColorStop(0.5, themeColors.grad1[1]);
        grad1.addColorStop(1,   themeColors.grad1[2]);
        me.gradients.grad1 = grad1;

        const grad2 = ctx.createLinearGradient(0, 0, width, 0);
        grad2.addColorStop(0,   themeColors.grad2[0]);
        grad2.addColorStop(0.5, themeColors.grad2[1]);
        grad2.addColorStop(1,   themeColors.grad2[2]);
        me.gradients.grad2 = grad2;

        const fgRibbon = ctx.createLinearGradient(0, 0, width, 0);
        fgRibbon.addColorStop(0,   themeColors.fgRibbon[0]);
        fgRibbon.addColorStop(0.5, themeColors.fgRibbon[1]);
        fgRibbon.addColorStop(1,   themeColors.fgRibbon[2]);
        me.gradients.fgRibbon = fgRibbon;

        // Background Gradients
        const bgGrad1 = ctx.createLinearGradient(0, 0, width, 0);
        bgGrad1.addColorStop(0,   themeColors.background[0]);
        bgGrad1.addColorStop(0.5, themeColors.background[1]);
        bgGrad1.addColorStop(1,   themeColors.background[2]);
        me.gradients.bgGrad1 = bgGrad1;

        const bgGrad2 = ctx.createLinearGradient(0, 0, width, 0);
        bgGrad2.addColorStop(0,   themeColors.background2[0]);
        bgGrad2.addColorStop(0.5, themeColors.background2[1]);
        bgGrad2.addColorStop(1,   themeColors.background2[2]);
        me.gradients.bgGrad2 = bgGrad2;

        const bgRibbon = ctx.createLinearGradient(0, 0, width, 0);
        bgRibbon.addColorStop(0,   themeColors.bgRibbon[0]);
        bgRibbon.addColorStop(0.5, themeColors.bgRibbon[1]);
        bgRibbon.addColorStop(1,   themeColors.bgRibbon[2]);
        me.gradients.bgRibbon = bgRibbon;
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(HeaderCanvas));



/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2NhbnZhcy92ZW5kb3JzLWFwcHNfcG9ydGFsX2NhbnZhc19IZWFkZXJDYW52YXNfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFpRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMERBQU87QUFDMUI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdDQUF3QztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRLE9BQU87QUFDL0I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQiwyQ0FBMkM7O0FBRXRFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLG9CQUFvQixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDM1FOOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpREFBSTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUSxhQUFhO0FBQ3JDO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixXQUFXO0FBQ25DLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixTQUFTLDJCQUEyQjtBQUNyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBLGlCQUFpQixnQ0FBZ0M7O0FBRWpEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0Rjs7QUFFNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QyxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMscUNBQXFDO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFdBQVc7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsV0FBVztBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QyxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsV0FBVztBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyxXQUFXO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QyxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkM7QUFDQTs7QUFFQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFdBQVc7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QyxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsYUFBYSwyQkFBMkI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkM7QUFDQTs7QUFFQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQsd0ZBQXdGO0FBQ3hGLHFFQUFxRTtBQUNyRSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QyxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLCtDQUErQyxRQUFRO0FBQ3ZEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7O0FBRXpCO0FBQ0EscURBQXFEO0FBQ3JELHlDQUF5QztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsNEJBQTRCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9wb3J0YWwvY2FudmFzL0Jhc2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL3BvcnRhbC9jYW52YXMvSGVhZGVyQ2FudmFzLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTmVvQmFzZSBmcm9tICcuLi8uLi8uLi9zcmMvY29yZS9CYXNlLm1qcyc7XG5cbi8qKlxuICogQHN1bW1hcnkgQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgUG9ydGFsIENhbnZhcyBSZW5kZXJlcnMuXG4gKlxuICogVGhpcyBjbGFzcyBzZXJ2ZXMgYXMgdGhlIGZvdW5kYXRpb24gZm9yIHRoZSBzcGVjaWFsaXplZCBjYW52YXMgdmlzdWFsaXphdGlvbnMgKEhlYWRlciwgSG9tZSwgU2VydmljZXMsIFRpY2tldClcbiAqIHRoYXQgcnVuIHdpdGhpbiB0aGUgKipOZW8ubWpzIENhbnZhcyBTaGFyZWRXb3JrZXIqKi5cbiAqXG4gKiBJdCBjcmVhdGVzIGhlbHBlciBzaW5nbGV0b25zIHRoYXQgbWFuYWdlIHRoZWlyIG93biBgT2Zmc2NyZWVuQ2FudmFzYCBpbnN0YW5jZXMsIHByb3ZpZGluZyBhIHN0YW5kYXJkaXplZFxuICogYXJjaGl0ZWN0dXJlIGZvcjpcbiAqIC0gKipMaWZlY3ljbGUgTWFuYWdlbWVudDoqKiBJbml0aWFsaXphdGlvbiAoYGluaXRHcmFwaGApLCBkZXN0cnVjdGlvbiAoYGNsZWFyR3JhcGhgKSwgYW5kIHJlc291cmNlIGNsZWFudXAuXG4gKiAtICoqUmVuZGVyIExvb3AgQ29udHJvbDoqKiBVbmlmaWVkIGByZW5kZXJgIGxvb3Agd2l0aCBwYXVzZS9yZXN1bWUgY2FwYWJpbGl0aWVzIGFuZCBmcmFtZSBzY2hlZHVsaW5nLlxuICogLSAqKkNvbnRleHQgTWFuYWdlbWVudDoqKiBSb2J1c3QgaGFuZGxpbmcgb2YgYE9mZnNjcmVlbkNhbnZhc2AgdHJhbnNmZXIgYW5kIGNvbnRleHQgYWNxdWlzaXRpb24gdmlhIGB3YWl0Rm9yQ2FudmFzYC5cbiAqIC0gKipTaGFyZWQgU3RhdGU6KiogQ29tbW9uIHN0YXRlIG1hbmFnZW1lbnQgZm9yIG1vdXNlIGludGVyYWN0aW9uLCB0aW1lLCBhbmQgdGhlbWluZy5cbiAqXG4gKiBUaGVzZSByZW5kZXJlcnMgb3BlcmF0ZSBvZmYgdGhlIG1haW4gdGhyZWFkIHRvIGVuc3VyZSBoaWdoLXBlcmZvcm1hbmNlLCA2MGZwcyBhbmltYXRpb25zIHdpdGhvdXRcbiAqIGJsb2NraW5nIHRoZSBVSS5cbiAqXG4gKiBAY2xhc3MgUG9ydGFsLmNhbnZhcy5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIEJhc2UgZXh0ZW5kcyBOZW9CYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J1BvcnRhbC5jYW52YXMuQmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnUG9ydGFsLmNhbnZhcy5CYXNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW90ZSBtZXRob2QgYWNjZXNzXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gcmVtb3RlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHJlbW90ZToge1xuICAgICAgICAgICAgYXBwOiBbXG4gICAgICAgICAgICAgICAgJ2NsZWFyR3JhcGgnLFxuICAgICAgICAgICAgICAgICdpbml0R3JhcGgnLFxuICAgICAgICAgICAgICAgICdwYXVzZScsXG4gICAgICAgICAgICAgICAgJ3Jlc3VtZScsXG4gICAgICAgICAgICAgICAgJ3NldFRoZW1lJyxcbiAgICAgICAgICAgICAgICAndXBkYXRlTW91c2VTdGF0ZScsXG4gICAgICAgICAgICAgICAgJ3VwZGF0ZVNpemUnXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYWN0aXZlIGNvbG9yIHRoZW1lICgnbGlnaHQnIG9yICdkYXJrJykuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gdGhlbWVfPSdsaWdodCdcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB0aGVtZV86ICdsaWdodCdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gYW5pbWF0aW9uSWQ9bnVsbFxuICAgICAqL1xuICAgIGFuaW1hdGlvbklkID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBjYW52YXNJZD1udWxsXG4gICAgICovXG4gICAgY2FudmFzSWQgPSBudWxsXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGNhbnZhc1NpemU9bnVsbFxuICAgICAqL1xuICAgIGNhbnZhc1NpemUgPSBudWxsXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2Zmc2NyZWVuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfG51bGx9IGNvbnRleHQ9bnVsbFxuICAgICAqL1xuICAgIGNvbnRleHQgPSBudWxsXG4gICAgLyoqXG4gICAgICogQ2FjaGUgZm9yIHJldXNhYmxlIGdyYWRpZW50cyB0byBwcmV2ZW50IEdDLlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gZ3JhZGllbnRzPXt9XG4gICAgICovXG4gICAgZ3JhZGllbnRzID0ge31cbiAgICAvKipcbiAgICAgKiBGbGFnIHRvIHBhdXNlIHRoZSByZW5kZXIgbG9vcC5cbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc1BhdXNlZD1mYWxzZVxuICAgICAqL1xuICAgIGlzUGF1c2VkID0gZmFsc2VcbiAgICAvKipcbiAgICAgKiBUcmFja2VkIG1vdXNlIHBvc2l0aW9uIGZvciBpbnRlcmFjdGl2ZSBwaHlzaWNzLlxuICAgICAqIEluaXRpYWxpemUgb2ZmLXNjcmVlbiB0byBwcmV2ZW50IHN0YXJ0dXAgaml0dGVycy5cbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vdXNlPXt4OiAtMTAwMCwgeTogLTEwMDB9XG4gICAgICovXG4gICAgbW91c2UgPSB7eDogLTEwMDAsIHk6IC0xMDAwfVxuICAgIC8qKlxuICAgICAqIEdsb2JhbCBzaW11bGF0aW9uIHRpbWUuXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSB0aW1lPTBcbiAgICAgKi9cbiAgICB0aW1lID0gMFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7RnVuY3Rpb259IHJlbmRlckxvb3A9dGhpcy5yZW5kZXIuYmluZCh0aGlzKVxuICAgICAqL1xuICAgIHJlbmRlckxvb3AgPSB0aGlzLnJlbmRlci5iaW5kKHRoaXMpXG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGB0aGVtZWAgY29uZmlnIGlzIGNoYW5nZWQuXG4gICAgICogVXBkYXRlcyB0aGUgcmVzb3VyY2UgY2FjaGUgKGdyYWRpZW50cywgY29sb3JzKSB0byByZWZsZWN0IHRoZSBuZXcgdGhlbWUgaW1tZWRpYXRlbHkuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICovXG4gICAgYWZ0ZXJTZXRUaGVtZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICYmIHRoaXMuY2FudmFzU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVSZXNvdXJjZXM/Lih0aGlzLmNhbnZhc1NpemUud2lkdGgsIHRoaXMuY2FudmFzU2l6ZS5oZWlnaHQpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGNhbnZhcyBpcyByZWFkeSB0byByZW5kZXIuXG4gICAgICogUmV0dXJucyB0cnVlIG9ubHkgaWYgdGhlIGNvbnRleHQgZXhpc3RzIGFuZCB0aGUgc2ltdWxhdGlvbiBpcyBub3QgcGF1c2VkLlxuICAgICAqIFN1YmNsYXNzZXMgc2hvdWxkIGNhbGwgdGhpcyBhdCB0aGUgc3RhcnQgb2YgdGhlaXIgYHJlbmRlcmAgbG9vcC5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgY2FuUmVuZGVyKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuICAgICAgICByZXR1cm4gISEobWUuY29udGV4dCAmJiAhbWUuaXNQYXVzZWQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBncmFwaCBzdGF0ZSBhbmQgc3RvcHMgdGhlIHJlbmRlciBsb29wLlxuICAgICAqIFVzZSB0aGlzIHRvIGNsZWFudXAgcmVzb3VyY2VzIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgb3IgdW5tb3VudGVkLlxuICAgICAqL1xuICAgIGNsZWFyR3JhcGgoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG4gICAgICAgIG1lLmNvbnRleHQgICAgID0gbnVsbDtcbiAgICAgICAgbWUuY2FudmFzSWQgICAgPSBudWxsO1xuICAgICAgICBtZS5jYW52YXNTaXplICA9IG51bGw7XG4gICAgICAgIG1lLmFuaW1hdGlvbklkID0gbnVsbDtcbiAgICAgICAgbWUuaXNQYXVzZWQgICAgPSBmYWxzZTtcbiAgICAgICAgbWUuZ3JhZGllbnRzICAgPSB7fTtcbiAgICAgICAgbWUubW91c2UgICAgICAgPSB7eDogLTEwMDAsIHk6IC0xMDAwfTtcbiAgICAgICAgbWUudGltZSAgICAgICAgPSAwXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIGNhbnZhcyBjb250ZXh0LlxuICAgICAqIFN0YXJ0cyB0aGUgcG9sbGluZyBtZWNoYW5pc20gdG8gd2FpdCBmb3IgdGhlIE9mZnNjcmVlbkNhbnZhcyB0cmFuc2ZlciBmcm9tIHRoZSBNYWluIFRocmVhZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRzLmNhbnZhc0lkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdHMud2luZG93SWRcbiAgICAgKi9cbiAgICBpbml0R3JhcGgoe2NhbnZhc0lkLCB3aW5kb3dJZH0pIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBoYXNDaGFuZ2UgPSBtZS5jYW52YXNJZCAhPT0gY2FudmFzSWQ7XG5cbiAgICAgICAgbWUuY2FudmFzSWQgPSBjYW52YXNJZDtcblxuICAgICAgICBtZS53YWl0Rm9yQ2FudmFzKGNhbnZhc0lkLCB3aW5kb3dJZCwgaGFzQ2hhbmdlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhvb2sgZm9yIHN1YmNsYXNzZXMgdG8gaGFuZGxlIG1vdXNlIGNsaWNrcy5cbiAgICAgKiBDYWxsZWQgYnkgYHVwZGF0ZU1vdXNlU3RhdGVgIHdoZW4gYSBjbGljayBldmVudCBpcyByZWNlaXZlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uTW91c2VDbGljayhkYXRhKSB7fVxuXG4gICAgLyoqXG4gICAgICogUGF1c2VzIHRoZSBzaW11bGF0aW9uLlxuICAgICAqIFRoZSByZW5kZXIgbG9vcCB3aWxsIGV4aXQgZWFybHkgd2hpbGUgYGlzUGF1c2VkYCBpcyB0cnVlLlxuICAgICAqL1xuICAgIHBhdXNlKCkge1xuICAgICAgICB0aGlzLmlzUGF1c2VkID0gdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFic3RyYWN0IHJlbmRlciBtZXRob2QuXG4gICAgICogU3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byBkcmF3IHRoZSBmcmFtZS5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7fVxuXG4gICAgLyoqXG4gICAgICogUmVzdW1lcyB0aGUgc2ltdWxhdGlvbi5cbiAgICAgKiBJZiB0aGUgc2ltdWxhdGlvbiB3YXMgcGF1c2VkLCB0aGlzIHJlc3RhcnRzIHRoZSByZW5kZXIgbG9vcC5cbiAgICAgKi9cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmlzUGF1c2VkKSB7XG4gICAgICAgICAgICBtZS5pc1BhdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgbWUucmVuZGVyTG9vcCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHBvc2VkIG1ldGhvZCBmb3IgUmVtb3RlIEFjY2VzcyB0byB0cmlnZ2VyIHRoZSByZWFjdGl2ZSBjb25maWcgc2V0dGVyLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIHNldFRoZW1lKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudGhlbWUgPSB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGxvY2FsIG1vdXNlIHN0YXRlIGZyb20gbWFpbiB0aHJlYWQgZXZlbnRzLlxuICAgICAqIERlbGVnYXRlcyBjbGljayBldmVudHMgdG8gYG9uTW91c2VDbGlja2AuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkYXRhLmNsaWNrXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2RhdGEubGVhdmVdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtkYXRhLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtkYXRhLnldXG4gICAgICovXG4gICAgdXBkYXRlTW91c2VTdGF0ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKGRhdGEubGVhdmUpIHtcbiAgICAgICAgICAgIG1lLm1vdXNlLnggPSAtMTAwMDtcbiAgICAgICAgICAgIG1lLm1vdXNlLnkgPSAtMTAwMFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRhdGEueCAhPT0gdW5kZWZpbmVkKSBtZS5tb3VzZS54ID0gZGF0YS54O1xuICAgICAgICAgICAgaWYgKGRhdGEueSAhPT0gdW5kZWZpbmVkKSBtZS5tb3VzZS55ID0gZGF0YS55O1xuXG4gICAgICAgICAgICBpZiAoZGF0YS5jbGljaykge1xuICAgICAgICAgICAgICAgIG1lLm9uTW91c2VDbGljayhkYXRhKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgY2FudmFzIHNpemUgYW5kIHJlc2l6ZXMgdGhlIGludGVybmFsIGNvbnRleHQuXG4gICAgICogVHJpZ2dlcnMgYHVwZGF0ZVJlc291cmNlc2AgaG9vayB0byBhbGxvdyBzdWJjbGFzc2VzIHRvIHJlZ2VuZXJhdGUgYnVmZmVycy9ncmFkaWVudHMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNpemVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2l6ZS5oZWlnaHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2l6ZS53aWR0aFxuICAgICAqL1xuICAgIHVwZGF0ZVNpemUoc2l6ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmNhbnZhc1NpemUgPSBzaXplO1xuXG4gICAgICAgIGlmIChtZS5jb250ZXh0KSB7XG4gICAgICAgICAgICBtZS5jb250ZXh0LmNhbnZhcy53aWR0aCAgPSBzaXplLndpZHRoO1xuICAgICAgICAgICAgbWUuY29udGV4dC5jYW52YXMuaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgICAvLyBDYWxscyB0aGUgaG9vayB0byByZS1nZW5lcmF0ZSByZXNvdXJjZXMgaWYgaW1wbGVtZW50ZWRcbiAgICAgICAgICAgIG1lLnVwZGF0ZVJlc291cmNlcz8uKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUG9sbHMgZm9yIHRoZSBPZmZzY3JlZW5DYW52YXMgdW50aWwgaXQgaXMgYXZhaWxhYmxlIGluIHRoZSBXb3JrZXIncyBgY2FudmFzV2luZG93TWFwYC5cbiAgICAgKiBPbmNlIGZvdW5kLCBpdCBpbml0aWFsaXplcyB0aGUgY29udGV4dCBhbmQgc3RhcnRzIHRoZSByZW5kZXIgbG9vcC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2FudmFzSWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gd2luZG93SWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGhhc0NoYW5nZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB3YWl0Rm9yQ2FudmFzKGNhbnZhc0lkLCB3aW5kb3dJZCwgaGFzQ2hhbmdlKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY2FudmFzID0gTmVvLmN1cnJlbnRXb3JrZXIuY2FudmFzV2luZG93TWFwW2NhbnZhc0lkXT8uW3dpbmRvd0lkXTtcblxuICAgICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgICAgICBtZS5jb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgIC8vIFN0YW5kYXJkaXplIHNpemUgdXBkYXRlXG4gICAgICAgICAgICBtZS51cGRhdGVTaXplKHt3aWR0aDogY2FudmFzLndpZHRoLCBoZWlnaHQ6IGNhbnZhcy5oZWlnaHR9KTtcblxuICAgICAgICAgICAgLy8gT3B0aW9uYWwgaG9vayBmb3Igc3ViY2xhc3Nlc1xuICAgICAgICAgICAgbWUub25HcmFwaE1vdW50ZWQ/LihjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuXG4gICAgICAgICAgICBpZiAoaGFzQ2hhbmdlICYmICFtZS5hbmltYXRpb25JZCkge1xuICAgICAgICAgICAgICAgIG1lLnJlbmRlckxvb3AoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dChtZS53YWl0Rm9yQ2FudmFzLmJpbmQobWUsIGNhbnZhc0lkLCB3aW5kb3dJZCwgaGFzQ2hhbmdlKSwgNTApXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEJhc2UpO1xuIiwiaW1wb3J0IEJhc2UgZnJvbSAnLi9CYXNlLm1qcyc7XG5cbmNvbnN0XG4gICAgaGFzUmFmICAgID0gdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gJ2Z1bmN0aW9uJyxcbiAgICBQUklNQVJZICAgPSAnIzNFNjNERCcsXG4gICAgU0VDT05EQVJZID0gJyM1MzZERkUnLFxuICAgIEhJR0hMSUdIVCA9ICcjMDBCRkZGJztcblxuLyoqXG4gKiBAc3VtbWFyeSBTaGFyZWRXb3JrZXIgcmVuZGVyZXIgZm9yIHRoZSBIZWFkZXJUb29sYmFyIG92ZXJsYXkuXG4gKlxuICogSW1wbGVtZW50cyB0aGUgKipcIkx1bWlub3VzIEZsdXhcIioqIHZpc3VhbCB0aGVtZSwgYW4gYW1iaWVudCwgaW50ZXJhY3RpdmUgZW5lcmd5IHNpbXVsYXRpb24gdGhhdFxuICogc2VydmVzIGFzIHRoZSBiYWNrZHJvcCBmb3IgdGhlIFBvcnRhbCBoZWFkZXIuXG4gKlxuICogKipWaXN1YWwgQXJjaGl0ZWN0dXJlOioqXG4gKiAxLiAqKk5lbyBFdGhlciAoQmFja2dyb3VuZCk6KiogQSB2b2x1bWV0cmljIHBhcnRpY2xlIGZpZWxkIGNvbXBvc2VkIG9mIGZhaW50IFwiZHVzdFwiIGFuZCBsYXJnZXIgXCJuZWJ1bGFcIiBvcmJzLlxuICogICAgVGhpcyBwcm92aWRlcyBhdG1vc3BoZXJpYyBkZXB0aCwgZmx1aWQgaW50ZXJhY3Rpdml0eSAobW91c2UgcmVwdWxzaW9uKSwgYW5kIGJyaWRnZXMgdGhlIGNvbnRyYXN0IGdhcFxuICogICAgYmV0d2VlbiB0aGUgd2hpdGUgYmFja2dyb3VuZCBhbmQgdGhlIGZvcmVncm91bmQgZWxlbWVudHMuXG4gKiAyLiAqKkFtYmllbnQgSGVsaXggKE1pZGdyb3VuZCk6KiogQSBsYXJnZS1zY2FsZSwgc2xvdy1tb3Zpbmcgc2luZSB3YXZlIHBhdHRlcm4gdGhhdCBwcm92aWRlcyBzdHJ1Y3R1cmFsXG4gKiAgICB0ZXh0dXJlIHRvIHRoZSBuZWdhdGl2ZSBzcGFjZS4gTm93IGVuaGFuY2VkIHdpdGggYSAqKnZvbHVtZXRyaWMgUmliYm9uIGZpbGwqKiB0byBhZGQgZGVwdGguXG4gKiAzLiAqKlNwbGl0IFN0cmVhbSAoRm9yZWdyb3VuZCk6KiogVHdvIGludGVydHdpbmVkIGVuZXJneSBzdHJhbmRzIChIZWxpeC9ETkEpIHRoYXQgZmxvdyBhY3Jvc3MgdGhlIGNhbnZhcy5cbiAqICAgIC0gKiozRCBSaWJib24gRWZmZWN0OioqIEEgc3VidGxlIGdyYWRpZW50IGZpbGxzIHRoZSBzcGFjZSBiZXR3ZWVuIHN0cmFuZHMsIHNpbXVsYXRpbmcgYSB0d2lzdGluZyBzdXJmYWNlLlxuICAqICAgLSAqKk5lb24gVHViZSBFZmZlY3Q6KiogU3RyYW5kcyBhcmUgcmVuZGVyZWQgd2l0aCBhIGJyaWdodCB3aGl0ZSBjb3JlIGluc2lkZSBhIGNvbG9yZWQgZ2xvdywgY3JlYXRpbmcgYSBwaHlzaWNhbCBsaWdodC1lbWl0dGluZyBsb29rLlxuICAqICAgLSAqKkFkYXB0aXZlIEdlb21ldHJ5OioqIFRoZSBzdHJhbmRzIGZsb3cgbG9vc2VseSBhcm91bmQgdGV4dCBidXR0b25zIGJ1dCB0aWdodGVuIGludG8gYSBcImhpZ2gtZ3Jhdml0eSBvcmJpdFwiXG4gICogICAgIGFyb3VuZCBzb2NpYWwgaWNvbnMuXG4gICogICAtICoqRW5lcmd5IFN1cmdlIChBY3RpdmUgU3RhdGUpOioqIFRoZSBzZWdtZW50IG9mIHRoZSBzdHJlYW0gcGFzc2luZyB0aHJvdWdoIHRoZSBhY3RpdmUgbmF2aWdhdGlvbiBpdGVtXG4gICogICAgIGlzIHJlbmRlcmVkIHdpdGggYSBoaWdoLWludGVuc2l0eSB3aGl0ZSBnbG93IGFuZCBhIG5lcnZvdXMgcHVsc2UsIHNlbWFudGljYWxseSBoaWdobGlnaHRpbmcgdGhlIGN1cnJlbnQgdmlldy5cbiAgKiAgIC0gKipQcmV2aWV3IEdsb3cgKEhvdmVyIFN0YXRlKToqKiBBIHN0YXRpYywgaGlnaC1jb250cmFzdCBnbG93IGhpZ2hsaWdodHMgdGhlIGl0ZW0gdW5kZXIgdGhlIGN1cnNvcixcbiAgKiAgICAgcHJvdmlkaW5nIGltbWVkaWF0ZSwgZGlzdGluY3QgZmVlZGJhY2sgc2VwYXJhdGUgZnJvbSB0aGUgYWN0aXZlIHN0YXRlLlxuICAqXG4gICogKipQZXJmb3JtYW5jZSBBcmNoaXRlY3R1cmUgKFplcm8tQWxsb2NhdGlvbik6KipcbiAqIFRvIG1haW50YWluIDYwZnBzIG9uIGhpZ2gtcmVmcmVzaCBkaXNwbGF5cyB3aXRob3V0IEdDIHN0dXR0ZXJzLCB0aGlzIGNsYXNzIGVtcGxveXMgYSAqKlplcm8tQWxsb2NhdGlvbioqIHN0cmF0ZWd5IGR1cmluZyB0aGUgcmVuZGVyIGxvb3AuXG4gKiAxLiAqKlR5cGVkQXJyYXkgQnVmZmVyczoqKiBXYXZlIGdlb21ldHJ5IGlzIHN0b3JlZCBpbiBwcmUtYWxsb2NhdGVkIGBGbG9hdDMyQXJyYXlgIGJ1ZmZlcnMgKGB3YXZlQnVmZmVyc2ApLCByZXVzZWQgZXZlcnkgZnJhbWUuXG4gKiAyLiAqKkdyYWRpZW50IENhY2hpbmc6KiogQ2FudmFzR3JhZGllbnRzIGFyZSBjcmVhdGVkIG9ubHkgb24gcmVzaXplIChgdXBkYXRlUmVzb3VyY2VzYCkgYW5kIGNhY2hlZCwgYXZvaWRpbmcgZXhwZW5zaXZlIGdlbmVyYXRvciBjYWxscyBwZXIgZnJhbWUuXG4gKiAzLiAqKlJldXNhYmxlIE9iamVjdHM6KiogUGh5c2ljcyBjYWxjdWxhdGlvbnMgd3JpdGUgZGlyZWN0bHkgdG8gYnVmZmVycyBpbnN0ZWFkIG9mIHJldHVybmluZyBuZXcgQXJyYXlzIG9mIE9iamVjdHMuXG4gKlxuICogQGNsYXNzIFBvcnRhbC5jYW52YXMuSGVhZGVyQ2FudmFzXG4gKiBAZXh0ZW5kcyBQb3J0YWwuY2FudmFzLkJhc2VcbiAqIEBzaW5nbGV0b25cbiAqIEBzZWUgUG9ydGFsLnZpZXcuSGVhZGVyQ2FudmFzXG4gKi9cbmNsYXNzIEhlYWRlckNhbnZhcyBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb2xvcnMgPSB7XG4gICAgICAgIGRhcmsgOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kICAgOiBbJ3JnYmEoNjIsIDk5LCAyMjEsIDAuMSknLCAncmdiYSg2NCwgMTk2LCAyNTUsIDAuMiknLCAncmdiYSg2MiwgOTksIDIyMSwgMC4xKSddLFxuICAgICAgICAgICAgYmFja2dyb3VuZDIgIDogWydyZ2JhKDEzOSwgMTY2LCAyNTUsIDAuMSknLCAncmdiYSg2NCwgMTk2LCAyNTUsIDAuMiknLCAncmdiYSgxMzksIDE2NiwgMjU1LCAwLjEpJ10sXG4gICAgICAgICAgICBiZ1JpYmJvbiAgICAgOiBbJ3JnYmEoNjIsIDk5LCAyMjEsIDAuMDIpJywgJ3JnYmEoNjQsIDE5NiwgMjU1LCAwLjA1KScsICdyZ2JhKDYyLCA5OSwgMjIxLCAwLjAyKSddLFxuICAgICAgICAgICAgZmdSaWJib24gICAgIDogWydyZ2JhKDYyLCA5OSwgMjIxLCAwLjAyNSknLCAncmdiYSg2NCwgMTk2LCAyNTUsIDAuMDUpJywgJ3JnYmEoNjIsIDk5LCAyMjEsIDAuMDI1KSddLFxuICAgICAgICAgICAgZ3JhZDEgICAgICAgIDogW1BSSU1BUlksIEhJR0hMSUdIVCwgUFJJTUFSWV0sXG4gICAgICAgICAgICBncmFkMiAgICAgICAgOiBbU0VDT05EQVJZLCBISUdITElHSFQsIFNFQ09OREFSWV0sXG4gICAgICAgICAgICBob3ZlciAgICAgICAgOiBISUdITElHSFQsXG4gICAgICAgICAgICBwYXJ0aWNsZSAgICAgOiBISUdITElHSFQsXG4gICAgICAgICAgICBwYXJ0aWNsZUFscGhhOiB7bmVidWxhOiAwLjIsIGR1c3Q6IDAuMn0sXG4gICAgICAgICAgICBzaG9ja3dhdmUgICAgOiBISUdITElHSFRcbiAgICAgICAgfSxcbiAgICAgICAgbGlnaHQ6IHtcbiAgICAgICAgICAgIGJhY2tncm91bmQgICA6IFsncmdiYSg2MiwgOTksIDIyMSwgMC4xKScsICdyZ2JhKDY0LCAxOTYsIDI1NSwgMC4yKScsICdyZ2JhKDYyLCA5OSwgMjIxLCAwLjEpJ10sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kMiAgOiBbJ3JnYmEoMTM5LCAxNjYsIDI1NSwgMC4xKScsICdyZ2JhKDY0LCAxOTYsIDI1NSwgMC4yKScsICdyZ2JhKDEzOSwgMTY2LCAyNTUsIDAuMSknXSxcbiAgICAgICAgICAgIGJnUmliYm9uICAgICA6IFsncmdiYSg2MiwgOTksIDIyMSwgMC4wMiknLCAncmdiYSg2NCwgMTk2LCAyNTUsIDAuMDUpJywgJ3JnYmEoNjIsIDk5LCAyMjEsIDAuMDIpJ10sXG4gICAgICAgICAgICBmZ1JpYmJvbiAgICAgOiBbJ3JnYmEoNjIsIDk5LCAyMjEsIDAuMDUpJywgJ3JnYmEoNjQsIDE5NiwgMjU1LCAwLjEpJywgJ3JnYmEoNjIsIDk5LCAyMjEsIDAuMDUpJ10sXG4gICAgICAgICAgICBncmFkMSAgICAgICAgOiBbUFJJTUFSWSwgSElHSExJR0hULCBQUklNQVJZXSxcbiAgICAgICAgICAgIGdyYWQyICAgICAgICA6IFtTRUNPTkRBUlksIEhJR0hMSUdIVCwgU0VDT05EQVJZXSxcbiAgICAgICAgICAgIGhvdmVyICAgICAgICA6IFBSSU1BUlksXG4gICAgICAgICAgICBwYXJ0aWNsZSAgICAgOiBISUdITElHSFQsXG4gICAgICAgICAgICBwYXJ0aWNsZUFscGhhOiB7bmVidWxhOiAwLjIsIGR1c3Q6IDAuMn0sXG4gICAgICAgICAgICBzaG9ja3dhdmUgICAgOiBISUdITElHSFRcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nUG9ydGFsLmNhbnZhcy5IZWFkZXJDYW52YXMnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ1BvcnRhbC5jYW52YXMuSGVhZGVyQ2FudmFzJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW90ZSBtZXRob2QgYWNjZXNzXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gcmVtb3RlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHJlbW90ZToge1xuICAgICAgICAgICAgYXBwOiBbXG4gICAgICAgICAgICAgICAgJ3VwZGF0ZUFjdGl2ZUlkJyxcbiAgICAgICAgICAgICAgICAndXBkYXRlR3JhcGhEYXRhJyxcbiAgICAgICAgICAgICAgICAndXBkYXRlSG92ZXJJZCcsXG4gICAgICAgICAgICAgICAgJ3VwZGF0ZU5hdlJlY3RzJ1xuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2luZ2xldG9uPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2luZ2xldG9uOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGFjdGl2ZUlkPW51bGxcbiAgICAgKi9cbiAgICBhY3RpdmVJZCA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gaG92ZXJJZD1udWxsXG4gICAgICovXG4gICAgaG92ZXJJZCA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gbmF2UmVjdHM9W11cbiAgICAgKi9cbiAgICBuYXZSZWN0cyA9IFtdXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0W119IHBhcnRpY2xlcz1bXVxuICAgICAqL1xuICAgIHBhcnRpY2xlcyA9IFtdXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0W119IHNob2Nrd2F2ZXM9W11cbiAgICAgKi9cbiAgICBzaG9ja3dhdmVzID0gW11cbiAgICAvKipcbiAgICAgKiBQcmUtYWxsb2NhdGVkIGJ1ZmZlcnMgZm9yIHdhdmUgZ2VvbWV0cnkuXG4gICAgICogVXNlcyBgRmxvYXQzMkFycmF5YCB0byBlbGltaW5hdGUgR2FyYmFnZSBDb2xsZWN0aW9uIHByZXNzdXJlIGR1cmluZyB0aGUgcmVuZGVyIGxvb3AuXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSB3YXZlQnVmZmVycz17YmdBOiBudWxsLCBiZ0I6IG51bGwsIGZnQTogbnVsbCwgZmdCOiBudWxsfVxuICAgICAqL1xuICAgIHdhdmVCdWZmZXJzID0ge2JnQTogbnVsbCwgYmdCOiBudWxsLCBmZ0E6IG51bGwsIGZnQjogbnVsbH1cblxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgZ3JhcGggc3RhdGUgYW5kIHN0b3BzIHRoZSByZW5kZXIgbG9vcC5cbiAgICAgKi9cbiAgICBjbGVhckdyYXBoKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuICAgICAgICBzdXBlci5jbGVhckdyYXBoKCk7XG4gICAgICAgIG1lLm5hdlJlY3RzICAgID0gW107XG4gICAgICAgIG1lLnBhcnRpY2xlcyAgID0gW107XG4gICAgICAgIG1lLnNob2Nrd2F2ZXMgID0gW107XG4gICAgICAgIG1lLndhdmVCdWZmZXJzID0ge2JnQTogbnVsbCwgYmdCOiBudWxsLCBmZ0E6IG51bGwsIGZnQjogbnVsbH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIb29rIHRvIGluaXRpYWxpemUgcGFydGljbGVzIGFmdGVyIGNvbnRleHQgaXMgcmVhZHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAgICovXG4gICAgb25HcmFwaE1vdW50ZWQod2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0aGlzLmluaXRQYXJ0aWNsZXMod2lkdGgsIGhlaWdodClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgcGFydGljbGUgc3lzdGVtIGZvciB0aGUgXCJOZW8gRXRoZXJcIiBlZmZlY3QuXG4gICAgICpcbiAgICAgKiBDcmVhdGVzIGEgbWl4IG9mIGxhcmdlLCBzbG93LW1vdmluZyBcIm5lYnVsYVwiIHBhcnRpY2xlcyBhbmQgc21hbGxlciwgZmFzdGVyIFwiZHVzdFwiIHBhcnRpY2xlc1xuICAgICAqIHRvIGNyZWF0ZSBkZXB0aCBhbmQgYXRtb3NwaGVyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgKi9cbiAgICBpbml0UGFydGljbGVzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcbiAgICAgICAgbWUucGFydGljbGVzID0gW107XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBjb3VudCAgICAgICA9IDYwLFxuICAgICAgICAgICAgdGhlbWVDb2xvcnMgPSBtZS5jb25zdHJ1Y3Rvci5jb2xvcnNbbWUudGhlbWVdLFxuICAgICAgICAgICAgYWxwaGFzICAgICAgPSB0aGVtZUNvbG9ycy5wYXJ0aWNsZUFscGhhO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlzTmVidWxhID0gTWF0aC5yYW5kb20oKSA+IDAuODsgLy8gMjAlIGFyZSBsYXJnZSBuZWJ1bGEgb3Jic1xuXG4gICAgICAgICAgICBtZS5wYXJ0aWNsZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgaXNOZWJ1bGEsXG4gICAgICAgICAgICAgICAgeCAgICAgICAgOiBNYXRoLnJhbmRvbSgpICogd2lkdGgsXG4gICAgICAgICAgICAgICAgeSAgICAgICAgOiBNYXRoLnJhbmRvbSgpICogaGVpZ2h0LFxuICAgICAgICAgICAgICAgIHZ4ICAgICAgIDogaXNOZWJ1bGEgPyAoTWF0aC5yYW5kb20oKSAqIDAuMiArIDAuMDUpIDogKE1hdGgucmFuZG9tKCkgKiAwLjUgKyAwLjEpLCAvLyBOZWJ1bGFlIG1vdmUgc2xvd2VyXG4gICAgICAgICAgICAgICAgdnkgICAgICAgOiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAwLjIsXG4gICAgICAgICAgICAgICAgc2l6ZSAgICAgOiBpc05lYnVsYSA/IChNYXRoLnJhbmRvbSgpICogMzAgKyAyMCkgOiAoTWF0aC5yYW5kb20oKSAqIDIgKyAwLjUpLCAvLyBMYXJnZSB2cyBTbWFsbFxuICAgICAgICAgICAgICAgIGFscGhhICAgIDogaXNOZWJ1bGEgPyAoTWF0aC5yYW5kb20oKSAqIDAuMTUgKyBhbHBoYXMubmVidWxhKSA6IChNYXRoLnJhbmRvbSgpICogMC40ICsgYWxwaGFzLmR1c3QpLFxuICAgICAgICAgICAgICAgIGJhc2VBbHBoYTogaXNOZWJ1bGEgPyAoTWF0aC5yYW5kb20oKSAqIDAuMTUgKyBhbHBoYXMubmVidWxhKSA6IChNYXRoLnJhbmRvbSgpICogMC40ICsgYWxwaGFzLmR1c3QpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFpbiByZW5kZXIgbG9vcC5cbiAgICAgKlxuICAgICAqIE9yY2hlc3RyYXRlcyB0aGUgcmVuZGVyaW5nIG9mIGFsbCB2aXN1YWwgbGF5ZXJzOlxuICAgICAqIDEuIEFtYmllbnQgQmFja2dyb3VuZCAoUmliYm9uICsgSGVsaXgpXG4gICAgICogMi4gTmVvIEV0aGVyIChQYXJ0aWNsZXMpXG4gICAgICogMy4gU3BsaXQgU3RyZWFtIChGb3JlZ3JvdW5kIEF1cmFzKVxuICAgICAqIDQuIFNob2Nrd2F2ZXMgKEludGVyYWN0aW9uKVxuICAgICAqXG4gICAgICogVXNlcyBgc2V0VGltZW91dGAgaW5zdGVhZCBvZiBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBiZWNhdXNlIHRoaXMgcnVucyBpbiBhIFNoYXJlZFdvcmtlclxuICAgICAqIHdoZXJlIGByQUZgIGlzIG5vdCBhdmFpbGFibGUuIFRhcmdldHMgfjYwZnBzICgxNm1zKS5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5jYW5SZW5kZXIpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIGN0eCAgICA9IG1lLmNvbnRleHQsXG4gICAgICAgICAgICB3aWR0aCAgPSBtZS5jYW52YXNTaXplPy53aWR0aCAgfHwgMTAwLFxuICAgICAgICAgICAgaGVpZ2h0ID0gbWUuY2FudmFzU2l6ZT8uaGVpZ2h0IHx8IDUwO1xuXG4gICAgICAgIG1lLnRpbWUgKz0gMC4wNTtcblxuICAgICAgICAvLyBBdXRvLXJlaW5pdCBwYXJ0aWNsZXMgaWYgc2l6ZSBjaGFuZ2VzIHNpZ25pZmljYW50bHkgb3IgZW1wdHkgT1IgY291bnQgbWlzbWF0Y2ggKGNvbmZpZyB1cGRhdGUpXG4gICAgICAgIGlmIChtZS5wYXJ0aWNsZXMubGVuZ3RoICE9PSA2MCkge1xuICAgICAgICAgICAgbWUuaW5pdFBhcnRpY2xlcyh3aWR0aCwgaGVpZ2h0KVxuICAgICAgICB9XG5cbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICAvLyAxLiBEcmF3IEFtYmllbnQgQmFja2dyb3VuZFxuICAgICAgICBtZS5kcmF3QW1iaWVudEJhY2tncm91bmQoY3R4LCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICAvLyAyLiBEcmF3IEV0aGVyIFBhcnRpY2xlcyAoQmFja2dyb3VuZCBMYXllcilcbiAgICAgICAgbWUuZHJhd1BhcnRpY2xlcyhjdHgsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIC8vIDMuIERyYXcgXCJBdXJhc1wiIChIb3ZlciBFZmZlY3RzKSA9PiAzRCBSaWJib24gKyBOZW9uIFR1YmVcbiAgICAgICAgbWUuZHJhd0F1cmFzKGN0eCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgLy8gM2IuIERyYXcgQWN0aXZlIE92ZXJsYXlcbiAgICAgICAgbWUuZHJhd0FjdGl2ZU92ZXJsYXkoY3R4LCB3aWR0aCk7XG5cbiAgICAgICAgLy8gM2MuIERyYXcgSG92ZXIgT3ZlcmxheVxuICAgICAgICBtZS5kcmF3SG92ZXJPdmVybGF5KGN0eCwgd2lkdGgpO1xuXG4gICAgICAgIC8vIDQuIERyYXcgXCJTaG9ja3dhdmVzXCIgKENsaWNrIEVmZmVjdHMpXG4gICAgICAgIG1lLmRyYXdTaG9ja3dhdmVzKGN0eCwgd2lkdGgpO1xuXG4gICAgICAgIGlmIChoYXNSYWYpIHtcbiAgICAgICAgICAgIG1lLmFuaW1hdGlvbklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKG1lLnJlbmRlckxvb3ApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5hbmltYXRpb25JZCA9IHNldFRpbWVvdXQobWUucmVuZGVyTG9vcCwgMTAwMCAvIDYwKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgcG9pbnRzIGZvciB0aGUgdHdvIGVuZXJneSBzdHJhbmRzIGJhc2VkIG9uIHBoeXNpY3MgYW5kIGludGVyYWN0aW9uLlxuICAgICAqXG4gICAgICogKipaZXJvLUFsbG9jYXRpb24gQ29udHJhY3Q6KipcbiAgICAgKiBUaGlzIG1ldGhvZCB3cml0ZXMgZGlyZWN0bHkgdG8gdGhlIHByZS1hbGxvY2F0ZWQgYHRoaXMud2F2ZUJ1ZmZlcnNgIGBGbG9hdDMyQXJyYXlgcy5cbiAgICAgKiBJdCBkb2VzICoqbm90KiogYWxsb2NhdGUgbmV3IGFycmF5cyBvciBvYmplY3RzLCBlbnN1cmluZyB6ZXJvIEdDIHByZXNzdXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHtzaGltbWVyQSwgc2hpbW1lckIsIGNvdW50fSBNZXRhZGF0YSBmb3IgcmVuZGVyaW5nIChzY2FsYXJzIG9ubHkpXG4gICAgICovXG4gICAgY2FsY3VsYXRlU3RyYW5kR2VvbWV0cnkod2lkdGgsIGhlaWdodCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZS5uYXZSZWN0cykgfHwgIW1lLndhdmVCdWZmZXJzLmZnQSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBidWZBICAgID0gbWUud2F2ZUJ1ZmZlcnMuZmdBLFxuICAgICAgICAgICAgYnVmQiAgICA9IG1lLndhdmVCdWZmZXJzLmZnQixcbiAgICAgICAgICAgIHN0ZXAgICAgPSAyLFxuICAgICAgICAgICAgY291bnQgICA9IE1hdGguY2VpbCh3aWR0aCAvIHN0ZXApLFxuICAgICAgICAgICAgY2VudGVyWSA9IGhlaWdodCAvIDIsXG4gICAgICAgICAgICBwYWRkaW5nID0gMTAsXG4gICAgICAgICAgICBtYXhIICAgID0gKGhlaWdodCAtIChwYWRkaW5nICogMikpIC8gMixcbiAgICAgICAgICAgIC8vIEJSRUFUSElORzogTW9kdWxhdGUgYmFzZSBhbXBsaXR1ZGUgb3ZlciB0aW1lIChzbG93IHB1bHNlKVxuICAgICAgICAgICAgYnJlYXRoICAgPSBNYXRoLnNpbihtZS50aW1lICogMC41KSAqIDIsXG4gICAgICAgICAgICBiYXNlQW1wICA9IE1hdGgubWluKDYgKyBicmVhdGgsIG1heEgpLFxuICAgICAgICAgICAgaG92ZXJBbXAgPSA0O1xuXG4gICAgICAgIC8vIFJFRiAxOiBMaW5rZWQgUGhhc2UgLSBTaGltbWVyIGxlYWRzIEJyZWF0aCBieSA5MGRlZyAoXCJDaGFyZ2luZyB1cFwiKVxuICAgICAgICBsZXQgYmFzZVNoaW1tZXIgPSAwLjc1ICsgKE1hdGguc2luKG1lLnRpbWUgKiAwLjUgKyBNYXRoLlBJIC8gMikgKiAwLjI1KTtcblxuICAgICAgICAvLyBSRUYgMjogSW5kZXBlbmRlbnQgU3RyYW5kIFNoaW1tZXJcbiAgICAgICAgbGV0IHNoaW1tZXJBID0gYmFzZVNoaW1tZXIsXG4gICAgICAgICAgICBzaGltbWVyQiA9IDAuNzUgKyAoTWF0aC5zaW4obWUudGltZSAqIDAuNSArIE1hdGguUEkgLyAyICsgTWF0aC5QSSAvIDMpICogMC4yNSk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeCA9IGkgKiBzdGVwLFxuICAgICAgICAgICAgICAgIHtvZmZzZXRZLCBpbnRlbnNpdHksIGlzSWNvblpvbmV9ID0gbWUuZ2V0U3RyZWFtT2Zmc2V0KHgsIGhlaWdodCwgd2lkdGgpO1xuXG4gICAgICAgICAgICAvLyBGUkVRVUVOQ1kgTU9EVUxBVElPTjpcbiAgICAgICAgICAgIGxldCBmcmVxTW9kICAgPSBNYXRoLnNpbih4ICogMC4wMDIgKyBtZS50aW1lICogMC4xKSAqICgyMCArIChpbnRlbnNpdHkgKiAxMCkpLFxuICAgICAgICAgICAgICAgIHRpbWVTaGlmdCA9IG1lLnRpbWUgKiAyO1xuXG4gICAgICAgICAgICAvLyBEQU1QSU5HIEZPUiBJQ09OUzpcbiAgICAgICAgICAgIGxldCBsb2NhbEFtcCA9IGJhc2VBbXAgKiAoMSAtIChpc0ljb25ab25lICogMC42KSk7XG5cbiAgICAgICAgICAgIC8vIE5vaXNlIENhbGN1bGF0aW9uXG4gICAgICAgICAgICAvLyBXZSBjYWxjdWxhdGUgbm9pc2Ugb25jZSBwZXIgZnJhbWUgcGVyIHBvaW50IHRvIGVuc3VyZSB0aGF0IHRoZSBSaWJib24gRmlsbCBhbmRcbiAgICAgICAgICAgIC8vIE5lb24gU3Ryb2tlIHBhc3NlcyB1c2UgaWRlbnRpY2FsIGdlb21ldHJ5LCBwcmV2ZW50aW5nIHZpc3VhbCB0ZWFyaW5nLlxuICAgICAgICAgICAgbGV0IG5vaXNlQSA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIGhvdmVyQW1wICogaW50ZW5zaXR5LFxuICAgICAgICAgICAgICAgIG5vaXNlQiA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIGhvdmVyQW1wICogaW50ZW5zaXR5LFxuICAgICAgICAgICAgICAgIHNpbmUgICA9IE1hdGguc2luKCgoeCArIGZyZXFNb2QpICogMC4wNCkgLSB0aW1lU2hpZnQpICogbG9jYWxBbXAsXG4gICAgICAgICAgICAgICAgc2luZUIgID0gTWF0aC5zaW4oKCh4ICsgZnJlcU1vZCkgKiAwLjA0KSAtIHRpbWVTaGlmdCArIE1hdGguUEkpICogbG9jYWxBbXA7IC8vIEludmVydGVkXG5cbiAgICAgICAgICAgIC8vIFNIT0NLV0FWRSBQSFlTSUNTIChEaXNwbGFjZW1lbnQpXG4gICAgICAgICAgICBsZXQgc2hvY2tZID0gMDtcbiAgICAgICAgICAgIGlmIChtZS5zaG9ja3dhdmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBtZS5zaG9ja3dhdmVzLmZvckVhY2god2F2ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByYWRpdXMgPSB3YXZlLmFnZSAqIHdhdmUuc3BlZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXN0ICAgPSB4IC0gd2F2ZS54OyAvLyBTaWduZWQgZGlzdGFuY2VcblxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBwb2ludCBpcyBuZWFyIHRoZSB3YXZlIGZyb250IChlLmcuIHdpdGhpbiA1MHB4KVxuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoZGlzdCkgPCByYWRpdXMgJiYgTWF0aC5hYnMoZGlzdCkgPiByYWRpdXMgLSA2MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHVsc2Ugc2hhcGU6IFNpbmUgd2F2ZSBiYXNlZCBvbiBkaXN0YW5jZSBmcm9tIGNlbnRlciByZWxhdGl2ZSB0byByYWRpdXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwdWxzZSA9IE1hdGguc2luKChkaXN0IC8gcmFkaXVzKSAqIE1hdGguUEkgKiAxMCkgKiAoMSAtICh3YXZlLmFnZSAvIHdhdmUubGlmZSkpICogMjA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG9ja1kgKz0gcHVsc2VcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdyaXRlIFkgdmFsdWVzIHRvIGJ1ZmZlcnNcbiAgICAgICAgICAgIGJ1ZkFbaV0gPSBjZW50ZXJZICsgc2luZSAgLSBvZmZzZXRZICsgbm9pc2VBICsgc2hvY2tZO1xuICAgICAgICAgICAgYnVmQltpXSA9IGNlbnRlclkgKyBzaW5lQiArIG9mZnNldFkgKyBub2lzZUIgKyBzaG9ja1k7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge3NoaW1tZXJBLCBzaGltbWVyQiwgY291bnR9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIFwiRXRoZXJcIiBwYXJ0aWNsZSBmaWVsZCB0byBhZGQgdm9sdW1ldHJpYyBkZXB0aCBhbmQgaW50ZXJhY3Rpdml0eS5cbiAgICAgKlxuICAgICAqICoqSW50ZW50OioqXG4gICAgICogQ3JlYXRlcyBhIGxpdmluZywgYnJlYXRoaW5nIGF0bW9zcGhlcmUgKFwiTmVvIEV0aGVyXCIpIHRoYXQgZmlsbHMgdGhlIG5lZ2F0aXZlIHNwYWNlLlxuICAgICAqIFRoaXMgYnJpZGdlcyB0aGUgdmlzdWFsIGdhcCBiZXR3ZWVuIHRoZSBzdGFyayB3aGl0ZSBiYWNrZ3JvdW5kIGFuZCB0aGUgaGlnaC1jb250cmFzdCBmb3JlZ3JvdW5kIGxpbmVzLlxuICAgICAqXG4gICAgICogKipQaHlzaWNzOioqXG4gICAgICogLSAqKkRyaWZ0OioqIFBhcnRpY2xlcyBtb3ZlIHdpdGggYSBjb25zdGFudCBgdnhgIHRvIHNpbXVsYXRlIGRhdGEgZmxvdyBvciB3aW5kLlxuICAgICAqIC0gKipSZXB1bHNpb246KiogVGhlIG1vdXNlIGN1cnNvciBhY3RzIGFzIGEgXCJyZXB1bHNvciBmaWVsZCxcIiBwdXNoaW5nIHBhcnRpY2xlcyBhd2F5IGFuZCBicmlnaHRlbmluZyB0aGVtXG4gICAgICogICB0byBjcmVhdGUgYSBcImhvbGVcIiBpbiB0aGUgZm9nLlxuICAgICAqIC0gKipOZWJ1bGFlOioqIExhcmdlLCBmYWludCBwYXJ0aWNsZXMgY3JlYXRlIGEgXCJmb2dcIiBlZmZlY3QsIHdoaWxlIHNtYWxsLCBicmlnaHQgcGFydGljbGVzIGFjdCBhcyBcImR1c3QuXCJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAgICovXG4gICAgZHJhd1BhcnRpY2xlcyhjdHgsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBjb25zdFxuICAgICAgICAgICAgdGhlbWVDb2xvcnMgPSBtZS5jb25zdHJ1Y3Rvci5jb2xvcnNbbWUudGhlbWVdLFxuICAgICAgICAgICAgcENvbG9yICAgICAgPSB0aGVtZUNvbG9ycy5wYXJ0aWNsZTtcblxuICAgICAgICBtZS5wYXJ0aWNsZXMuZm9yRWFjaChwID0+IHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBQb3NpdGlvblxuICAgICAgICAgICAgcC54ICs9IHAudng7XG4gICAgICAgICAgICBwLnkgKz0gcC52eTtcblxuICAgICAgICAgICAgLy8gV3JhcCBhcm91bmRcbiAgICAgICAgICAgIGlmIChwLnggPiB3aWR0aCArIHAuc2l6ZSkgIHAueCA9IC1wLnNpemU7XG4gICAgICAgICAgICBpZiAocC54IDwgLXAuc2l6ZSkgICAgICAgICBwLnggPSB3aWR0aCArIHAuc2l6ZTtcbiAgICAgICAgICAgIGlmIChwLnkgPiBoZWlnaHQgKyBwLnNpemUpIHAueSA9IC1wLnNpemU7XG4gICAgICAgICAgICBpZiAocC55IDwgLXAuc2l6ZSkgICAgICAgICBwLnkgPSBoZWlnaHQgKyBwLnNpemU7XG5cbiAgICAgICAgICAgIC8vIEludGVyYWN0aW9uOiBNb3VzZSBSZXB1bHNpb25cbiAgICAgICAgICAgIC8vIEFsbCBwYXJ0aWNsZXMgcmVhY3QgdG8gdGhlIG1vdXNlLCBidXQgXCJOZWJ1bGFcIiBwYXJ0aWNsZXMgaGF2ZSBoaWdoZXIgY2FsY3VsYXRlZCBtYXNzLFxuICAgICAgICAgICAgLy8gcmVzdWx0aW5nIGluIGxlc3MgZGlzcGxhY2VtZW50IHRoYW4gdGhlIGxpZ2h0ZXIgXCJEdXN0XCIgcGFydGljbGVzLlxuICAgICAgICAgICAgbGV0IGR4ID0gcC54IC0gbWUubW91c2UueCxcbiAgICAgICAgICAgICAgICBkeSA9IHAueSAtIG1lLm1vdXNlLnksXG4gICAgICAgICAgICAgICAgZGlzdCA9IE1hdGguc3FydChkeCpkeCArIGR5KmR5KSxcbiAgICAgICAgICAgICAgICBtYXhEaXN0ID0gcC5pc05lYnVsYSA/IDE1MCA6IDEwMDtcblxuICAgICAgICAgICAgaWYgKGRpc3QgPCBtYXhEaXN0ICYmIGRpc3QgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZvcmNlID0gKG1heERpc3QgLSBkaXN0KSAvIG1heERpc3Q7XG4gICAgICAgICAgICAgICAgLy8gUHVzaCBhd2F5XG4gICAgICAgICAgICAgICAgbGV0IG1hc3MgPSBwLmlzTmVidWxhID8gNSA6IDE7XG4gICAgICAgICAgICAgICAgcC54ICs9IChkeCAvIGRpc3QpICogZm9yY2UgKiAoMiAvIG1hc3MpO1xuICAgICAgICAgICAgICAgIHAueSArPSAoZHkgLyBkaXN0KSAqIGZvcmNlICogKDIgLyBtYXNzKTtcbiAgICAgICAgICAgICAgICAvLyBCcmlnaHRlbiBzbGlnaHRseVxuICAgICAgICAgICAgICAgIHAuYWxwaGEgPSBNYXRoLm1pbihwLmJhc2VBbHBoYSArIGZvcmNlICogKHAuaXNOZWJ1bGEgPyAwLjA1IDogMC41KSwgMC44KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSW50ZXJhY3Rpb246IFNob2Nrd2F2ZSBSZXB1bHNpb25cbiAgICAgICAgICAgIGlmIChtZS5zaG9ja3dhdmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBtZS5zaG9ja3dhdmVzLmZvckVhY2god2F2ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB3eCAgICAgPSBwLnggLSB3YXZlLngsXG4gICAgICAgICAgICAgICAgICAgICAgICB3eSAgICAgPSBwLnkgLSB3YXZlLnksXG4gICAgICAgICAgICAgICAgICAgICAgICB3RGlzdCAgPSBNYXRoLnNxcnQod3ggKiB3eCArIHd5ICogd3kpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzID0gd2F2ZS5hZ2UgKiB3YXZlLnNwZWVkO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHBhcnRpY2xlIGlzIG5lYXIgdGhlIGV4cGFuZGluZyByaW5nICh3aWR0aCA0MHB4KVxuICAgICAgICAgICAgICAgICAgICBpZiAod0Rpc3QgPCByYWRpdXMgJiYgd0Rpc3QgPiByYWRpdXMgLSA0MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZvcmNlID0gKDEgLSAod2F2ZS5hZ2UgLyB3YXZlLmxpZmUpKSAqIDI7IC8vIERlY2F5IGZvcmNlIG92ZXIgdGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHVzaCBvdXR3YXJkXG4gICAgICAgICAgICAgICAgICAgICAgICBwLnggKz0gKHd4IC8gd0Rpc3QpICogZm9yY2UgKiA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgcC55ICs9ICh3eSAvIHdEaXN0KSAqIGZvcmNlICogNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuYWxwaGEgPSBNYXRoLm1pbihwLmFscGhhICsgMC4zLCAxKSAvLyBGbGFzaCBicmlnaHRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJldHVybiB0byBiYXNlIGFscGhhXG4gICAgICAgICAgICBpZiAocC5hbHBoYSA+IHAuYmFzZUFscGhhKSB7XG4gICAgICAgICAgICAgICAgcC5hbHBoYSAtPSAwLjAwNVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBwLmFscGhhO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgICAgICBpZiAocC5pc05lYnVsYSkge1xuICAgICAgICAgICAgICAgIC8vIE5lYnVsYSBWaXN1YWxpemF0aW9uXG4gICAgICAgICAgICAgICAgLy8gVXNlIGEgcmFkaWFsIGdyYWRpZW50IHRvIGNyZWF0ZSBhIHNvZnQsIGNsb3VkLWxpa2UgYXBwZWFyYW5jZS5cbiAgICAgICAgICAgICAgICBsZXQgZyA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudChwLngsIHAueSwgMCwgcC54LCBwLnksIHAuc2l6ZSk7XG4gICAgICAgICAgICAgICAgZy5hZGRDb2xvclN0b3AoMCwgcENvbG9yKTtcbiAgICAgICAgICAgICAgICBnLmFkZENvbG9yU3RvcCgxLCAncmdiYSgyNTUsMjU1LDI1NSwwKScpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBnO1xuICAgICAgICAgICAgICAgIGN0eC5hcmMocC54LCBwLnksIHAuc2l6ZSwgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsKClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHBDb2xvcjtcbiAgICAgICAgICAgICAgICBjdHguYXJjKHAueCwgcC55LCBwLnNpemUsIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDFcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBhbiBhZGRpdGlvbmFsIGhpZ2hsaWdodCBmb3IgdGhlIGFjdGl2ZSBuYXZpZ2F0aW9uIGl0ZW0uXG4gICAgICogKipcIkVuZXJneSBTdXJnZVwiIEVmZmVjdDoqKlxuICAgICAqIFJlbmRlcnMgYSBoaWdoLWludGVuc2l0eSBwYXNzIG9mIHRoZSBlbmVyZ3kgc3RyYW5kcyAqb25seSogd2l0aGluIHRoZSBhY3RpdmUgem9uZS5cbiAgICAgKiBUaGlzIG1ha2VzIHRoZSBsaW5lcyBhcHBlYXIgdG8gXCJwb3dlciB1cFwiIG9yIGdsb3cgd2hpdGUtaG90IGFzIHRoZXkgcGFzcyB0aHJvdWdoIHRoZSBhY3RpdmUgdmlldyxcbiAgICAgKiBmdWxseSBpbnRlZ3JhdGVkIHdpdGggdGhlIGV4aXN0aW5nIGdlb21ldHJ5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqL1xuICAgIGRyYXdBY3RpdmVPdmVybGF5KGN0eCwgd2lkdGgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIHJlY3Q7XG5cbiAgICAgICAgaWYgKCFtZS5hY3RpdmVJZCB8fCAhbWUud2F2ZUJ1ZmZlcnMuZmdBKSByZXR1cm47XG5cbiAgICAgICAgLy8gWmVyby1BbGxvY2F0aW9uOiBVc2UgZm9yLWxvb3AgaW5zdGVhZCBvZiAuZmluZCgpIHRvIGF2b2lkIGNsb3N1cmUgY3JlYXRpb25cbiAgICAgICAgZm9yIChjb25zdCByIG9mIG1lLm5hdlJlY3RzKSB7XG4gICAgICAgICAgICBpZiAoci5pZCA9PT0gbWUuYWN0aXZlSWQpIHtcbiAgICAgICAgICAgICAgICByZWN0ID0gcjtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZWN0KSByZXR1cm47XG5cbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIHN0ZXAgICA9IDIsIC8vIE11c3QgbWF0Y2ggY2FsY3VsYXRlU3RyYW5kR2VvbWV0cnlcbiAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nIHRvIGZhZGUgdGhlIGVmZmVjdCBpbi9vdXQgc21vb3RobHlcbiAgICAgICAgICAgIHBhZCAgICA9IDEwLFxuICAgICAgICAgICAgc3RhcnRYID0gTWF0aC5tYXgoMCwgcmVjdC54IC0gcGFkKSxcbiAgICAgICAgICAgIGVuZFggICA9IE1hdGgubWluKHdpZHRoLCByZWN0LnggKyByZWN0LndpZHRoICsgcGFkKSxcbiAgICAgICAgICAgIHN0YXJ0SSA9IE1hdGguZmxvb3Ioc3RhcnRYIC8gc3RlcCksXG4gICAgICAgICAgICBlbmRJICAgPSBNYXRoLmNlaWwoZW5kWCAvIHN0ZXApLFxuICAgICAgICAgICAgYnVmQSAgID0gbWUud2F2ZUJ1ZmZlcnMuZmdBLFxuICAgICAgICAgICAgYnVmQiAgID0gbWUud2F2ZUJ1ZmZlcnMuZmdCO1xuXG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5saW5lQ2FwICA9ICdyb3VuZCc7XG4gICAgICAgIGN0eC5saW5lSm9pbiA9ICdyb3VuZCc7XG5cbiAgICAgICAgLy8gSGlnaC1JbnRlbnNpdHkgR2xvd1xuICAgICAgICBjdHguc2hhZG93Qmx1ciAgPSAyMDtcbiAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gJyNGRkZGRkYnOyAvLyBXaGl0ZSBnbG93XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjRkZGRkZGJzsgLy8gV2hpdGUgY29yZVxuICAgICAgICBjdHgubGluZVdpZHRoICAgPSAyO1xuXG4gICAgICAgIC8vIEdyYWRpZW50IEZhZGUgbWFzayAobWFudWFsIGFscGhhKVxuICAgICAgICAvLyBXZSBjYW4ndCBlYXNpbHkgZ3JhZGllbnQtc3Ryb2tlIGEgc3ViLXBhdGgsIHNvIHdlIHJlbHkgb24gZ2xvYmFsQWxwaGFcbiAgICAgICAgLy8gY29tYmluZWQgd2l0aCB0aGUgXCJob3RcIiB3aGl0ZSBjb2xvciB0byBtYWtlIGl0IHBvcC5cbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC42ICsgKE1hdGguc2luKG1lLnRpbWUgKiAzKSAqIDAuMik7IC8vIEZhc3QsIG5lcnZvdXMgcHVsc2VcblxuICAgICAgICAvLyBJbmxpbmUgZHJhd2luZyB0byBhdm9pZCBjbG9zdXJlXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhzdGFydEkgKiBzdGVwLCBidWZBW3N0YXJ0SV0pO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJICsgMTsgaSA8PSBlbmRJOyBpKyspIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oaSAqIHN0ZXAsIGJ1ZkFbaV0pXG4gICAgICAgIH1cbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhzdGFydEkgKiBzdGVwLCBidWZCW3N0YXJ0SV0pO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJICsgMTsgaSA8PSBlbmRJOyBpKyspIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oaSAqIHN0ZXAsIGJ1ZkJbaV0pXG4gICAgICAgIH1cbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgIGN0eC5yZXN0b3JlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBhbiBhZGRpdGlvbmFsIGhpZ2hsaWdodCBmb3IgdGhlIGhvdmVyZWQgbmF2aWdhdGlvbiBpdGVtLlxuICAgICAqICoqXCJQcmV2aWV3XCIgRWZmZWN0OioqXG4gICAgICogUmVuZGVycyBhIHN0YXRpYyBpbnRlbnNpdHkgcGFzcyBvZiB0aGUgZW5lcmd5IHN0cmFuZHMgd2l0aGluIHRoZSBob3ZlcmVkIHpvbmUuXG4gICAgICogVXNlcyB0aGUgdGhlbWUtc3BlY2lmaWMgaG92ZXIgY29sb3IgKEN5YW4vQmx1ZSkgdG8gZGlzdGluZ3Vpc2ggaXQgZnJvbSB0aGUgYWN0aXZlIHN0YXRlIChXaGl0ZSkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICovXG4gICAgZHJhd0hvdmVyT3ZlcmxheShjdHgsIHdpZHRoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICByZWN0O1xuXG4gICAgICAgIGlmICghbWUuaG92ZXJJZCB8fCAhbWUud2F2ZUJ1ZmZlcnMuZmdBKSByZXR1cm47XG5cbiAgICAgICAgLy8gWmVyby1BbGxvY2F0aW9uOiBVc2UgZm9yLWxvb3AgaW5zdGVhZCBvZiAuZmluZCgpIHRvIGF2b2lkIGNsb3N1cmUgY3JlYXRpb25cbiAgICAgICAgZm9yIChjb25zdCByIG9mIG1lLm5hdlJlY3RzKSB7XG4gICAgICAgICAgICBpZiAoci5pZCA9PT0gbWUuaG92ZXJJZCkge1xuICAgICAgICAgICAgICAgIHJlY3QgPSByO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJlY3QpIHJldHVybjtcblxuICAgICAgICBjb25zdFxuICAgICAgICAgICAgc3RlcCAgICAgICAgPSAyLCAvLyBNdXN0IG1hdGNoIGNhbGN1bGF0ZVN0cmFuZEdlb21ldHJ5XG4gICAgICAgICAgICBwYWQgICAgICAgICA9IDEwLFxuICAgICAgICAgICAgc3RhcnRYICAgICAgPSBNYXRoLm1heCgwLCByZWN0LnggLSBwYWQpLFxuICAgICAgICAgICAgZW5kWCAgICAgICAgPSBNYXRoLm1pbih3aWR0aCAtIDMsIHJlY3QueCArIHJlY3Qud2lkdGggKyBwYWQpLFxuICAgICAgICAgICAgc3RhcnRJICAgICAgPSBNYXRoLmZsb29yKHN0YXJ0WCAvIHN0ZXApLFxuICAgICAgICAgICAgZW5kSSAgICAgICAgPSBNYXRoLmNlaWwoZW5kWCAvIHN0ZXApLFxuICAgICAgICAgICAgYnVmQSAgICAgICAgPSBtZS53YXZlQnVmZmVycy5mZ0EsXG4gICAgICAgICAgICBidWZCICAgICAgICA9IG1lLndhdmVCdWZmZXJzLmZnQixcbiAgICAgICAgICAgIHRoZW1lQ29sb3JzID0gbWUuY29uc3RydWN0b3IuY29sb3JzW21lLnRoZW1lXTtcblxuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHgubGluZUNhcCAgPSAncm91bmQnO1xuICAgICAgICBjdHgubGluZUpvaW4gPSAncm91bmQnO1xuXG4gICAgICAgIC8vIEhvdmVyIEVmZmVjdDogU3RhdGljIEdsb3cgKE5vIFB1bHNlKVxuICAgICAgICBjdHguc2hhZG93Qmx1ciAgPSAxNTtcbiAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gdGhlbWVDb2xvcnMuaG92ZXI7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoZW1lQ29sb3JzLmhvdmVyO1xuICAgICAgICBjdHgubGluZVdpZHRoICAgPSAyO1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuXG4gICAgICAgIC8vIElubGluZSBkcmF3aW5nIHRvIGF2b2lkIGNsb3N1cmVcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKHN0YXJ0SSAqIHN0ZXAsIGJ1ZkFbc3RhcnRJXSk7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydEkgKyAxOyBpIDw9IGVuZEk7IGkrKykge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhpICogc3RlcCwgYnVmQVtpXSlcbiAgICAgICAgfVxuICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKHN0YXJ0SSAqIHN0ZXAsIGJ1ZkJbc3RhcnRJXSk7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydEkgKyAxOyBpIDw9IGVuZEk7IGkrKykge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhpICogc3RlcCwgYnVmQltpXSlcbiAgICAgICAgfVxuICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgY3R4LnJlc3RvcmUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYXdzIGEgc3VidGxlLCBsYXJnZS1zY2FsZSBiYWNrZ3JvdW5kIEhlbGl4IHBhdHRlcm4gd2l0aCBhIDNEIFJpYmJvbiBlZmZlY3QuXG4gICAgICpcbiAgICAgKiAqKkludGVudDoqKlxuICAgICAqIFByb3ZpZGVzIGEgc3RydWN0dXJhbCBiYWNrYm9uZSB0byB0aGUgbmVnYXRpdmUgc3BhY2UuIFVubGlrZSB0aGUgcGFydGljbGUgZmllbGQgKHdoaWNoIGlzIGNoYW90aWMpLFxuICAgICAqIHRoaXMgbGF5ZXIgaXMgb3JkZXJlZCBhbmQgcmh5dGhtaWMsIHJlaW5mb3JjaW5nIHRoZSBcIkROQS9IZWxpeFwiIHRoZW1lIGV2ZW4gaW4gdGhlIGJhY2tncm91bmQuXG4gICAgICpcbiAgICAgKiAqKlZpc3VhbHM6KipcbiAgICAgKiAxLiAqKlJpYmJvbiBGaWxsOioqIEEgYmFyZWx5LXZpc2libGUgdm9sdW1ldHJpYyBncmFkaWVudCBmaWxscyB0aGUgc3BhY2UgYmV0d2VlbiB0aGUgaGVsaWNlcy5cbiAgICAgKiAyLiAqKkRlcHRoIG9mIEZpZWxkOioqIFVzZXMgd2lkZSwgdmVyeSBsb3cgb3BhY2l0eSBzdHJva2VzIHRvIGFwcGVhciBcIm91dCBvZiBmb2N1c1wiIGJlaGluZCB0aGUgc2hhcnAgZm9yZWdyb3VuZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAgICovXG4gICAgZHJhd0FtYmllbnRCYWNrZ3JvdW5kKGN0eCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIC8vIEVuc3VyZSBidWZmZXJzIGV4aXN0XG4gICAgICAgIGlmICghbWUud2F2ZUJ1ZmZlcnMuYmdBKSByZXR1cm47XG5cbiAgICAgICAgbGV0IHQgICAgICAgPSBtZS50aW1lICogMC41LFxuICAgICAgICAgICAgY2VudGVyWSA9IGhlaWdodCAvIDIsXG4gICAgICAgICAgICBhbXAgICAgID0gaGVpZ2h0ICogMC40LFxuICAgICAgICAgICAgc3RlcCAgICA9IDEwLFxuICAgICAgICAgICAgY291bnQgICA9IE1hdGguY2VpbCh3aWR0aCAvIHN0ZXApLFxuICAgICAgICAgICAgYnVmQSAgICA9IG1lLndhdmVCdWZmZXJzLmJnQSxcbiAgICAgICAgICAgIGJ1ZkIgICAgPSBtZS53YXZlQnVmZmVycy5iZ0I7XG5cbiAgICAgICAgLy8gMS4gQ2FsY3VsYXRlIFBvaW50cyAoRGlyZWN0IHRvIEJ1ZmZlcilcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeCA9IGkgKiBzdGVwO1xuICAgICAgICAgICAgYnVmQVtpXSA9IGNlbnRlclkgKyBNYXRoLnNpbigoeCAqIDAuMDEpICsgdCkgKiBhbXA7XG4gICAgICAgICAgICBidWZCW2ldID0gY2VudGVyWSArIE1hdGguc2luKCh4ICogMC4wMSkgKyB0ICsgTWF0aC5QSSkgKiBhbXBcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLSAyLiBSSUJCT04gRklMTCAoQmFja2dyb3VuZCBTdXJmYWNlKSAtLS1cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG1lLmdyYWRpZW50cy5iZ1JpYmJvbjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIGN0eC5tb3ZlVG8oMCwgYnVmQVswXSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhpICogc3RlcCwgYnVmQVtpXSlcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSBjb3VudCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKGkgKiBzdGVwLCBidWZCW2ldKVxuICAgICAgICB9XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcblxuICAgICAgICAvLyAtLS0gMy4gU1RST0tFUyAtLS1cbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE1O1xuICAgICAgICBjdHgubGluZUNhcCAgID0gJ3JvdW5kJztcbiAgICAgICAgY3R4LmxpbmVKb2luICA9ICdyb3VuZCc7XG5cbiAgICAgICAgLy8gVXNlIGNhY2hlZCBncmFkaWVudHNcbiAgICAgICAgY29uc3QgZHJhd1N0cm9rZSA9IChidWZmZXIsIHN0cm9rZVN0eWxlKSA9PiB7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZTtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oMCwgYnVmZmVyWzBdKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oaSAqIHN0ZXAsIGJ1ZmZlcltpXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5zdHJva2UoKVxuICAgICAgICB9O1xuXG4gICAgICAgIGRyYXdTdHJva2UoYnVmQSwgbWUuZ3JhZGllbnRzLmJnR3JhZDEpO1xuICAgICAgICBkcmF3U3Ryb2tlKGJ1ZkIsIG1lLmdyYWRpZW50cy5iZ0dyYWQyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgbWFpbiBmb3JlZ3JvdW5kIFwiU3BsaXQgU3RyZWFtXCIgZW5lcmd5IHN0cmFuZHMgd2l0aCAzRCBlZmZlY3RzLlxuICAgICAqXG4gICAgICogKiozRCBBcmNoaXRlY3R1cmU6KipcbiAgICAgKiAxLiAqKlJpYmJvbiBGaWxsOioqIERyYXdzIGEgbG93LW9wYWNpdHkgZ3JhZGllbnQgYmV0d2VlbiBTdHJhbmQgQSBhbmQgU3RyYW5kIEIsIGNyZWF0aW5nIGEgdHdpc3Rpbmcgc3VyZmFjZS5cbiAgICAgKiAyLiAqKk5lb24gVHViZSAoT3V0ZXIpOioqIFRoZSBjb2xvcmVkIGdsb3cgb2YgdGhlIHN0cmFuZHMuXG4gICAgICogMy4gKipOZW9uIFR1YmUgKENvcmUpOioqIEEgYnJpZ2h0IHdoaXRlIGlubmVyIGNvcmUgdG8gc2ltdWxhdGUgdm9sdW1ldHJpYyBsaWdodC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAgICovXG4gICAgZHJhd0F1cmFzKGN0eCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZS5uYXZSZWN0cykpIHJldHVybjtcblxuICAgICAgICAvLyAxLiBDYWxjdWxhdGUgUGh5c2ljcyAoU2hhcmVkIGZvciBSaWJib24gYW5kIFN0cmFuZHMpIC0gUmV0dXJucyBtZXRhZGF0YSwgZGF0YSBpcyBpbiBidWZmZXJzXG4gICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gbWUuY2FsY3VsYXRlU3RyYW5kR2VvbWV0cnkod2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgaWYgKCFnZW9tZXRyeSkgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICB7c2hpbW1lckEsIHNoaW1tZXJCLCBjb3VudH0gPSBnZW9tZXRyeSxcbiAgICAgICAgICAgIGJ1ZkEgICAgICAgID0gbWUud2F2ZUJ1ZmZlcnMuZmdBLFxuICAgICAgICAgICAgYnVmQiAgICAgICAgPSBtZS53YXZlQnVmZmVycy5mZ0IsXG4gICAgICAgICAgICBzdGVwICAgICAgICA9IDIsXG4gICAgICAgICAgICB0aGVtZUNvbG9ycyA9IG1lLmNvbnN0cnVjdG9yLmNvbG9yc1ttZS50aGVtZV07XG5cbiAgICAgICAgLy8gLS0tIDIuIFJJQkJPTiBGSUxMIChUaGUgM0QgU3VyZmFjZSkgLS0tXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBtZS5ncmFkaWVudHMuZmdSaWJib247XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgICBjdHgubW92ZVRvKDAsIGJ1ZkFbMF0pO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oaSAqIHN0ZXAsIGJ1ZkFbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IGNvdW50IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oaSAqIHN0ZXAsIGJ1ZkJbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcblxuICAgICAgICAvLyAtLS0gMy4gTkVPTiBTVFJBTkRTIChUdWJlIEVmZmVjdCkgLS0tXG5cbiAgICAgICAgY3R4LmxpbmVDYXAgICAgID0gJ3JvdW5kJztcbiAgICAgICAgY3R4LmxpbmVKb2luICAgID0gJ3JvdW5kJztcblxuICAgICAgICAvLyBIZWxwZXIgdG8gZHJhdyBhIHN0cmFuZCBmcm9tIGJ1ZmZlclxuICAgICAgICBjb25zdCBkcmF3U3RyYW5kID0gKGJ1ZmZlciwgZ3JhZGllbnQsIHNoaW1tZXIsIGNvbG9yLCBpc0NvcmUpID0+IHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGlzQ29yZSA/ICcjRkZGRkZGJyA6IGdyYWRpZW50O1xuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCAgID0gaXNDb3JlID8gMSA6IDM7XG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBpc0NvcmUgPyAoc2hpbW1lciArIDAuMikgOiBzaGltbWVyO1xuXG4gICAgICAgICAgICBpZiAoIWlzQ29yZSkge1xuICAgICAgICAgICAgICAgIGN0eC5zaGFkb3dCbHVyICA9IDEwO1xuICAgICAgICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IGNvbG9yO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdHguc2hhZG93Qmx1ciAgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHgubW92ZVRvKDAsIGJ1ZmZlclswXSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKGkgKiBzdGVwLCBidWZmZXJbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIERyYXcgR2xvd3MgKE91dGVyIFR1YmUpXG4gICAgICAgIC8vIEV4dHJhY3QgYmFzZSBjb2xvciBmcm9tIGdyYWRpZW50IGFycmF5IGZvciBzaGFkb3dcbiAgICAgICAgY29uc3QgY29sb3IxID0gdGhlbWVDb2xvcnMuZ3JhZDFbMF07XG4gICAgICAgIGNvbnN0IGNvbG9yMiA9IHRoZW1lQ29sb3JzLmdyYWQyWzBdO1xuXG4gICAgICAgIGRyYXdTdHJhbmQoYnVmQSwgbWUuZ3JhZGllbnRzLmdyYWQxLCBzaGltbWVyQSwgY29sb3IxLCBmYWxzZSk7XG4gICAgICAgIGRyYXdTdHJhbmQoYnVmQiwgbWUuZ3JhZGllbnRzLmdyYWQyLCBzaGltbWVyQiwgY29sb3IyLCBmYWxzZSk7XG5cbiAgICAgICAgLy8gRHJhdyBDb3JlcyAoSW5uZXIgRmlsYW1lbnQpXG4gICAgICAgIGRyYXdTdHJhbmQoYnVmQSwgbnVsbCwgc2hpbW1lckEsIG51bGwsIHRydWUpO1xuICAgICAgICBkcmF3U3RyYW5kKGJ1ZkIsIG51bGwsIHNoaW1tZXJCLCBudWxsLCB0cnVlKTtcblxuICAgICAgICAvLyBDbGVhbnVwOiBSZXNldCBzaGFkb3cgYW5kIGFscGhhIHRvIHByZXZlbnQgYmxlZWRpbmcgaW50byB0aGUgbmV4dCByZW5kZXIgcGFzc1xuICAgICAgICBjdHguc2hhZG93Qmx1ciAgPSAwO1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHBoeXNpY3MgZm9yIGRpdmVydGluZyB0aGUgc3RyZWFtIGFyb3VuZCBVSSBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqICoqTG9naWM6KipcbiAgICAgKiAxLiAqKkRldGVjdGlvbjoqKiBJdGVyYXRlcyB0aHJvdWdoIGBuYXZSZWN0c2AgdG8gZmluZCBpZiB0aGUgY3VycmVudCBgeGAgaXMgbmVhciBhIGJ1dHRvbi5cbiAgICAgKiAyLiAqKkFkYXB0aXZlIEdlb21ldHJ5OioqXG4gICAgICogICAgLSAqKlRleHQgQnV0dG9uczoqKiBVc2VzIGEgd2lkZSBDb3NpbmUgZW52ZWxvcGUgZm9yIHNtb290aCBmbG93LlxuICAgICAqICAgIC0gKipJY29uIEJ1dHRvbnM6KiogVXNlcyBhIHNoYXJwIEN1YmVkIGVudmVsb3BlIChgTWF0aC5wb3coeCwgMylgKSB0byBjcmVhdGUgYSBcIlRpZ2h0IE9yYml0XCIgZWZmZWN0LlxuICAgICAqIDMuICoqVmVydGljYWwgQ2xhbXBpbmc6KiogRW5zdXJlcyB0aGUgZGl2ZXJzaW9uIG5ldmVyIHB1c2hlcyB0aGUgd2F2ZSBvZmYtY2FudmFzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IChDYW52YXMgaGVpZ2h0KVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAoQ2FudmFzIHdpZHRoKVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHtvZmZzZXRZLCBpbnRlbnNpdHksIGlzSWNvblpvbmV9XG4gICAgICovXG4gICAgZ2V0U3RyZWFtT2Zmc2V0KHgsIGhlaWdodCwgd2lkdGgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBvZmZzZXRZICAgPSAwLFxuICAgICAgICAgICAgaW50ZW5zaXR5ID0gMCwgLy8gMCB0byAxIChIb3ZlciBtYWduaXR1ZGUpXG4gICAgICAgICAgICBpc0ljb25ab25lID0gMDsgLy8gMCB0byAxIChQcm94aW1pdHkgdG8gYW4gSWNvbiBCdXR0b24pXG5cbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIHZlcnRpY2FsUGFkZGluZyA9IDEwLFxuICAgICAgICAgICAgbWF4U2FmZU9mZnNldCAgID0gKGhlaWdodCAvIDIpIC0gdmVydGljYWxQYWRkaW5nO1xuXG4gICAgICAgIC8vIENvbGxpc2lvbiBEZXRlY3Rpb25cbiAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGFsbCBuYXZpZ2F0aW9uIGl0ZW1zIHRvIGRldGVybWluZSBzdHJlYW0gZGl2ZXJzaW9uLlxuICAgICAgICAvLyBHaXZlbiB0aGUgbG93IGl0ZW0gY291bnQgKDwyMCksIGEgc2ltcGxlIGxpbmVhciBzY2FuIGlzIGVmZmljaWVudC5cbiAgICAgICAgZm9yIChjb25zdCByZWN0IG9mIG1lLm5hdlJlY3RzKSB7XG4gICAgICAgICAgICAvLyBCdWZmZXIgem9uZSBmb3Igc21vb3RoIHRyYW5zaXRpb25cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IDQwO1xuXG4gICAgICAgICAgICBpZiAoeCA+PSByZWN0LnggLSBidWZmZXIgJiYgeCA8PSByZWN0LnggKyByZWN0LndpZHRoICsgYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgYXJlIGluc2lkZSB0aGUgaW5mbHVlbmNlIHpvbmUgb2YgdGhpcyBidXR0b25cblxuICAgICAgICAgICAgICAgIC8vIFNoYXBlIERldGVjdGlvblxuICAgICAgICAgICAgICAgIC8vIERpc2NyaW1pbmF0ZSBiZXR3ZWVuIHNxdWFyZS1pc2ggaWNvbnMgKHNvY2lhbHMpIGFuZCB3aWRlIHRleHQgYnV0dG9uc1xuICAgICAgICAgICAgICAgIC8vIHRvIGFwcGx5IGRpZmZlcmVudCBkaXZlcnNpb24gZW52ZWxvcGVzLlxuICAgICAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgICAgICAgIHJhdGlvICAgPSByZWN0LndpZHRoIC8gcmVjdC5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIGlzSWNvbiAgPSByYXRpbyA8IDEuNSwgLy8gVGhyZXNob2xkIGZvciBcIkNpcmNsZVwiIHZzIFwiUmVjdGFuZ2xlXCJcbiAgICAgICAgICAgICAgICAgICAgY2VudGVyWCA9IHJlY3QueCArIHJlY3Qud2lkdGggLyAyLFxuICAgICAgICAgICAgICAgICAgICBzcGFuICAgID0gKHJlY3Qud2lkdGggLyAyKSArIGJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgZGlzdFggICA9IE1hdGguYWJzKHggLSBjZW50ZXJYKTtcblxuICAgICAgICAgICAgICAgIGlmIChkaXN0WCA8IHNwYW4pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVudmVsb3BlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0ljb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRJR0hUIE9SQklUIChTaGFycGVyIGN1cnZlIGZvciBpY29ucylcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub3JtRGlzdCA9IGRpc3RYIC8gc3BhbjsgLy8gMCB0byAxXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnZlbG9wZSA9IE1hdGgucG93KCgxICsgTWF0aC5jb3MoTWF0aC5QSSAqIG5vcm1EaXN0KSkgLyAyLCAzKTsgLy8gQ3ViZWQgZm9yIHNoYXJwZXIgZmFsbG9mZlxuICAgICAgICAgICAgICAgICAgICAgICAgaXNJY29uWm9uZSA9IE1hdGgubWF4KGlzSWNvblpvbmUsIGVudmVsb3BlKTsgLy8gVHJhY2sgaWYgd2UgYXJlIGluIGFuIGljb24gem9uZVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV0lERSBGTE9XIChTdGFuZGFyZCBzbW9vdGggY3VydmUgZm9yIHRleHQpXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnZlbG9wZSA9ICgxICsgTWF0aC5jb3MoTWF0aC5QSSAqIGRpc3RYIC8gc3BhbikpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIERpdmVyc2lvbiBBbXBsaXR1ZGVcbiAgICAgICAgICAgICAgICAgICAgLy8gVGV4dCBidXR0b25zIHJlcXVpcmUgbW9yZSB2aXN1YWwgY2xlYXJhbmNlIHRoYW4gaWNvbnMgZHVlIHRvIHRoZWlyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlY3Rhbmd1bGFyIG5hdHVyZS4gSWNvbnMgYWxsb3cgZm9yIGEgdGlnaHRlciBcIm9yYml0XCIuXG4gICAgICAgICAgICAgICAgICAgIGxldCB0YXJnZXRIID0gaXNJY29uID8gKHJlY3QuaGVpZ2h0IC8gMikgOiAoKHJlY3QuaGVpZ2h0IC8gMikgKyA0KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBWZXJ0aWNhbCBDbGFtcGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBDYXAgdGhlIG9mZnNldCB0byBlbnN1cmUgdGhlIHN0cmVhbSBzdGF5cyB3aXRoaW4gdGhlIGNhbnZhcyBib3VuZHMuXG4gICAgICAgICAgICAgICAgICAgIGxldCB0YXJnZXRPZmZzZXQgPSBNYXRoLm1pbih0YXJnZXRILCBtYXhTYWZlT2Zmc2V0KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdG8gdG90YWwgb2Zmc2V0ICh1c2luZyBtYXggdG8gaGFuZGxlIG92ZXJsYXBzIGNsZWFubHkpXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFkgPSBNYXRoLm1heChvZmZzZXRZLCB0YXJnZXRPZmZzZXQgKiBlbnZlbG9wZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSW50ZXJhY3Rpb246IFByb3hpbWl0eSBDaGVja1xuICAgICAgICAgICAgICAgICAgICAvLyBCb29zdCB0aGUgd2F2ZSBpbnRlbnNpdHkgaWYgdGhlIG1vdXNlIGlzIGhvdmVyaW5nIG92ZXIgb3IgbmVhciB0aGlzIHNwZWNpZmljIGJ1dHRvbi5cblxuICAgICAgICAgICAgICAgICAgICAvLyBEaXN0YW5jZSBmcm9tIG1vdXNlIHRvIGJ1dHRvbiBjZW50ZXJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGR4ID0gbWUubW91c2UueCAtIGNlbnRlclgsXG4gICAgICAgICAgICAgICAgICAgICAgICBkeSA9IG1lLm1vdXNlLnkgLSAocmVjdC55ICsgcmVjdC5oZWlnaHQvMiksXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXN0TW91c2UgPSBNYXRoLnNxcnQoZHgqZHggKyBkeSpkeSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgbW91c2UgaXMgbmVhciB0aGlzIGJ1dHRvbiwgYm9vc3QgaW50ZW5zaXR5XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXN0TW91c2UgPCBNYXRoLm1heChyZWN0LndpZHRoLCByZWN0LmhlaWdodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVuc2l0eSA9IE1hdGgubWF4KGludGVuc2l0eSwgMSAtIChkaXN0TW91c2UgLyAxNTApKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJhc2VsaW5lIFNlcGFyYXRpb25cbiAgICAgICAgLy8gQnkgcmV0dXJuaW5nIG9mZnNldFk9MCBpbiBlbXB0eSBzcGFjZSwgdGhlIHN0cmFuZHMgd2lsbCBuYXR1cmFsbHkgY3Jvc3MgKEhlbGl4IGVmZmVjdClcbiAgICAgICAgLy8gZHJpdmVuIGJ5IHRoZSBzaW5lIHdhdmUgbG9naWMgaW4gY2FsY3VsYXRlU3RyYW5kUG9pbnRzLlxuICAgICAgICByZXR1cm4ge29mZnNldFksIGludGVuc2l0eSwgaXNJY29uWm9uZX07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgZXhwYW5kaW5nIHNob2Nrd2F2ZXMgZnJvbSBjbGlja3MuXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqL1xuICAgIGRyYXdTaG9ja3dhdmVzKGN0eCwgd2lkdGgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuc2hvY2t3YXZlcy5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgICAgICBjb25zdCB0aGVtZUNvbG9ycyA9IG1lLmNvbnN0cnVjdG9yLmNvbG9yc1ttZS50aGVtZV07XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IG1lLnNob2Nrd2F2ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB3YXZlID0gbWUuc2hvY2t3YXZlc1tpXTtcblxuICAgICAgICAgICAgd2F2ZS5hZ2UgKz0gMTtcblxuICAgICAgICAgICAgbGV0IHByb2dyZXNzID0gd2F2ZS5hZ2UgLyB3YXZlLmxpZmU7XG5cbiAgICAgICAgICAgIGlmIChwcm9ncmVzcyA+PSAxKSB7XG4gICAgICAgICAgICAgICAgbWUuc2hvY2t3YXZlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRHJhdyB0d28gbGluZXMgcHJvcGFnYXRpbmcgb3V0IGZyb20gdGhlIGNsaWNrIHBvaW50XG4gICAgICAgICAgICBsZXQgeExlZnQgICAgPSB3YXZlLnggLSAod2F2ZS5zcGVlZCAqIHdhdmUuYWdlKSxcbiAgICAgICAgICAgICAgICB4UmlnaHQgICA9IHdhdmUueCArICh3YXZlLnNwZWVkICogd2F2ZS5hZ2UpLFxuICAgICAgICAgICAgICAgIGFscGhhICAgID0gMSAtIHByb2dyZXNzLFxuICAgICAgICAgICAgICAgIHtoZWlnaHR9ID0gbWUuY2FudmFzU2l6ZTtcblxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhlbWVDb2xvcnMuc2hvY2t3YXZlOyAvLyBVc2UgdGhlbWUgY29sb3JcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGFscGhhOyAgICAgLy8gRmFkZSBvdXQgdmlhIGdsb2JhbEFscGhhXG4gICAgICAgICAgICBjdHgubGluZVdpZHRoICAgPSA0ICogKDEgLSBwcm9ncmVzcyk7XG5cbiAgICAgICAgICAgIC8vIExlZnQgV2F2ZVxuICAgICAgICAgICAgaWYgKHhMZWZ0ID4gMCkge1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oeExlZnQsIDApO1xuICAgICAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHhMZWZ0IC0gMjAsIGhlaWdodCAvIDIsIHhMZWZ0LCBoZWlnaHQpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJpZ2h0IFdhdmVcbiAgICAgICAgICAgIGlmICh4UmlnaHQgPCB3aWR0aCkge1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oeFJpZ2h0LCAwKTtcbiAgICAgICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4UmlnaHQgKyAyMCwgaGVpZ2h0IC8gMiwgeFJpZ2h0LCBoZWlnaHQpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDEgLy8gUmVzZXRcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtkYXRhLmlkXVxuICAgICAqL1xuICAgIHVwZGF0ZUFjdGl2ZUlkKGRhdGEpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVJZCA9IGRhdGE/LmlkIHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIHVwZGF0ZUdyYXBoRGF0YShkYXRhKSB7XG4gICAgICAgIC8vIE5vdCB1c2VkIHlldCwgYnV0IGtlcHQgZm9yIGludGVyZmFjZSBjb25zaXN0ZW5jeVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtkYXRhLmlkXVxuICAgICAqL1xuICAgIHVwZGF0ZUhvdmVySWQoZGF0YSkge1xuICAgICAgICB0aGlzLmhvdmVySWQgPSBkYXRhPy5pZCB8fCBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSG9vayB0byBoYW5kbGUgbW91c2UgY2xpY2tzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Nb3VzZUNsaWNrKGRhdGEpIHtcbiAgICAgICAgdGhpcy5zaG9ja3dhdmVzLnB1c2goe1xuICAgICAgICAgICAgeCAgICA6IGRhdGEueCxcbiAgICAgICAgICAgIHkgICAgOiBkYXRhLnksXG4gICAgICAgICAgICBhZ2UgIDogMCxcbiAgICAgICAgICAgIGxpZmUgOiA2MCwgLy8gZnJhbWVzXG4gICAgICAgICAgICBzcGVlZDogMTUgIC8vIHB4IHBlciBmcmFtZVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5yZWN0c1xuICAgICAqL1xuICAgIHVwZGF0ZU5hdlJlY3RzKGRhdGEpIHtcbiAgICAgICAgbGV0IHJlY3RzID0gZGF0YT8ucmVjdHM7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVjdHMpKSB7XG4gICAgICAgICAgICB0aGlzLm5hdlJlY3RzID0gcmVjdHNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubmF2UmVjdHMgPSBbXVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbmQgY2FjaGVzIGdyYWRpZW50cyBhbmQgZ2VvbWV0cnkgYnVmZmVycyBiYXNlZCBvbiBjYW52YXMgc2l6ZS5cbiAgICAgKiBUaGlzIGVsaW1pbmF0ZXMgcGVyLWZyYW1lIGFsbG9jYXRpb24gb2YgVHlwZWRBcnJheXMgYW5kIENhbnZhc0dyYWRpZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgKi9cbiAgICB1cGRhdGVSZXNvdXJjZXMod2lkdGgsIGhlaWdodCkge1xuICAgICAgICBsZXQgbWUgID0gdGhpcyxcbiAgICAgICAgICAgIGN0eCA9IG1lLmNvbnRleHQ7XG5cbiAgICAgICAgLy8gMS4gUmUtYWxsb2NhdGUgQnVmZmVycyAoRmxvYXQzMkFycmF5KVxuICAgICAgICAvLyBCYWNrZ3JvdW5kOiBzdGVwID0gMTBcbiAgICAgICAgY29uc3QgYmdDb3VudCA9IE1hdGguY2VpbCh3aWR0aCAvIDEwKSArIDE7XG4gICAgICAgIG1lLndhdmVCdWZmZXJzLmJnQSA9IG5ldyBGbG9hdDMyQXJyYXkoYmdDb3VudCk7XG4gICAgICAgIG1lLndhdmVCdWZmZXJzLmJnQiA9IG5ldyBGbG9hdDMyQXJyYXkoYmdDb3VudCk7XG5cbiAgICAgICAgLy8gRm9yZWdyb3VuZDogc3RlcCA9IDJcbiAgICAgICAgY29uc3QgZmdDb3VudCA9IE1hdGguY2VpbCh3aWR0aCAvIDIpICsgMTtcbiAgICAgICAgbWUud2F2ZUJ1ZmZlcnMuZmdBID0gbmV3IEZsb2F0MzJBcnJheShmZ0NvdW50KTtcbiAgICAgICAgbWUud2F2ZUJ1ZmZlcnMuZmdCID0gbmV3IEZsb2F0MzJBcnJheShmZ0NvdW50KTtcblxuICAgICAgICAvLyAyLiBDYWNoZSBHcmFkaWVudHNcbiAgICAgICAgaWYgKCFjdHgpIHJldHVybjtcblxuICAgICAgICBjb25zdCB0aGVtZUNvbG9ycyA9IG1lLmNvbnN0cnVjdG9yLmNvbG9yc1ttZS50aGVtZV07XG5cbiAgICAgICAgLy8gRm9yZWdyb3VuZCBHcmFkaWVudHNcbiAgICAgICAgY29uc3QgZ3JhZDEgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgMCwgd2lkdGgsIDApO1xuICAgICAgICBncmFkMS5hZGRDb2xvclN0b3AoMCwgICB0aGVtZUNvbG9ycy5ncmFkMVswXSk7XG4gICAgICAgIGdyYWQxLmFkZENvbG9yU3RvcCgwLjUsIHRoZW1lQ29sb3JzLmdyYWQxWzFdKTtcbiAgICAgICAgZ3JhZDEuYWRkQ29sb3JTdG9wKDEsICAgdGhlbWVDb2xvcnMuZ3JhZDFbMl0pO1xuICAgICAgICBtZS5ncmFkaWVudHMuZ3JhZDEgPSBncmFkMTtcblxuICAgICAgICBjb25zdCBncmFkMiA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCB3aWR0aCwgMCk7XG4gICAgICAgIGdyYWQyLmFkZENvbG9yU3RvcCgwLCAgIHRoZW1lQ29sb3JzLmdyYWQyWzBdKTtcbiAgICAgICAgZ3JhZDIuYWRkQ29sb3JTdG9wKDAuNSwgdGhlbWVDb2xvcnMuZ3JhZDJbMV0pO1xuICAgICAgICBncmFkMi5hZGRDb2xvclN0b3AoMSwgICB0aGVtZUNvbG9ycy5ncmFkMlsyXSk7XG4gICAgICAgIG1lLmdyYWRpZW50cy5ncmFkMiA9IGdyYWQyO1xuXG4gICAgICAgIGNvbnN0IGZnUmliYm9uID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIHdpZHRoLCAwKTtcbiAgICAgICAgZmdSaWJib24uYWRkQ29sb3JTdG9wKDAsICAgdGhlbWVDb2xvcnMuZmdSaWJib25bMF0pO1xuICAgICAgICBmZ1JpYmJvbi5hZGRDb2xvclN0b3AoMC41LCB0aGVtZUNvbG9ycy5mZ1JpYmJvblsxXSk7XG4gICAgICAgIGZnUmliYm9uLmFkZENvbG9yU3RvcCgxLCAgIHRoZW1lQ29sb3JzLmZnUmliYm9uWzJdKTtcbiAgICAgICAgbWUuZ3JhZGllbnRzLmZnUmliYm9uID0gZmdSaWJib247XG5cbiAgICAgICAgLy8gQmFja2dyb3VuZCBHcmFkaWVudHNcbiAgICAgICAgY29uc3QgYmdHcmFkMSA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCB3aWR0aCwgMCk7XG4gICAgICAgIGJnR3JhZDEuYWRkQ29sb3JTdG9wKDAsICAgdGhlbWVDb2xvcnMuYmFja2dyb3VuZFswXSk7XG4gICAgICAgIGJnR3JhZDEuYWRkQ29sb3JTdG9wKDAuNSwgdGhlbWVDb2xvcnMuYmFja2dyb3VuZFsxXSk7XG4gICAgICAgIGJnR3JhZDEuYWRkQ29sb3JTdG9wKDEsICAgdGhlbWVDb2xvcnMuYmFja2dyb3VuZFsyXSk7XG4gICAgICAgIG1lLmdyYWRpZW50cy5iZ0dyYWQxID0gYmdHcmFkMTtcblxuICAgICAgICBjb25zdCBiZ0dyYWQyID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIHdpZHRoLCAwKTtcbiAgICAgICAgYmdHcmFkMi5hZGRDb2xvclN0b3AoMCwgICB0aGVtZUNvbG9ycy5iYWNrZ3JvdW5kMlswXSk7XG4gICAgICAgIGJnR3JhZDIuYWRkQ29sb3JTdG9wKDAuNSwgdGhlbWVDb2xvcnMuYmFja2dyb3VuZDJbMV0pO1xuICAgICAgICBiZ0dyYWQyLmFkZENvbG9yU3RvcCgxLCAgIHRoZW1lQ29sb3JzLmJhY2tncm91bmQyWzJdKTtcbiAgICAgICAgbWUuZ3JhZGllbnRzLmJnR3JhZDIgPSBiZ0dyYWQyO1xuXG4gICAgICAgIGNvbnN0IGJnUmliYm9uID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIHdpZHRoLCAwKTtcbiAgICAgICAgYmdSaWJib24uYWRkQ29sb3JTdG9wKDAsICAgdGhlbWVDb2xvcnMuYmdSaWJib25bMF0pO1xuICAgICAgICBiZ1JpYmJvbi5hZGRDb2xvclN0b3AoMC41LCB0aGVtZUNvbG9ycy5iZ1JpYmJvblsxXSk7XG4gICAgICAgIGJnUmliYm9uLmFkZENvbG9yU3RvcCgxLCAgIHRoZW1lQ29sb3JzLmJnUmliYm9uWzJdKTtcbiAgICAgICAgbWUuZ3JhZGllbnRzLmJnUmliYm9uID0gYmdSaWJib247XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhIZWFkZXJDYW52YXMpO1xuXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9