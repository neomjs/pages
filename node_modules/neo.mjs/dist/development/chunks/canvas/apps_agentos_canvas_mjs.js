export const __webpack_esm_id__ = "apps_agentos_canvas_mjs";
export const __webpack_esm_ids__ = ["apps_agentos_canvas_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./apps/agentos/canvas.mjs"
/*!*********************************!*\
  !*** ./apps/agentos/canvas.mjs ***!
  \*********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   onStart: () => (/* binding */ onStart)
/* harmony export */ });
/* harmony import */ var _canvas_Blackboard_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./canvas/Blackboard.mjs */ "./apps/agentos/canvas/Blackboard.mjs");


const onStart = () => {
    // Blackboard Helper available inside the Canvas worker
};


/***/ },

/***/ "./apps/agentos/canvas/Blackboard.mjs"
/*!********************************************!*\
  !*** ./apps/agentos/canvas/Blackboard.mjs ***!
  \********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class AgentOS.canvas.Blackboard
 * @extends Neo.core.Base
 * @singleton
 */
class Blackboard extends _src_core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='AgentOS.canvas.Blackboard'
         * @protected
         */
        className: 'AgentOS.canvas.Blackboard',
        /**
         * Remote method access
         * @member {Object} remote
         * @protected
         */
        remote: {
            app: [
                'updateGraphData',
                'updateSize',
                'initGraph'
            ]
        },
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * @member {String|null} canvasId=null
     */
    canvasId = null
    /**
     * @member {Object} canvasSize=null
     */
    canvasSize = null
    /**
     * @member {Object} context=null
     */
    context = null
    /**
     * @member {Array} links=[]
     */
    links = []
    /**
     * @member {Array} nodes=[]
     */
    nodes = []

    construct(config) {
        super.construct(config);
        // Seed some dummy data for initial render verification
        this.nodes = [
            {id: 'root', x: 100, y: 100, label: 'Root Agent', color: '#4CAF50'},
            {id: 'task1', x: 200, y: 150, label: 'Task 1', color: '#2196F3'},
            {id: 'task2', x: 300, y: 100, label: 'Task 2', color: '#FFC107'}
        ];
        this.links = [
            {source: 'root', target: 'task1'},
            {source: 'root', target: 'task2'}
        ];
    }

    /**
     * Initialize the graph with a canvas ID
     * @param {Object} opts
     * @param {String} opts.canvasId
     * @param {String} opts.windowId
     */
    initGraph({canvasId, windowId}) {
        let me        = this,
            hasChange = me.canvasId !== canvasId;

        console.log('Blackboard: initGraph', canvasId, hasChange);
        this.canvasId = canvasId;

        // Wait for the canvas to be available in the worker map
        const checkCanvas = () => {
            const canvas = Neo.currentWorker.canvasWindowMap[canvasId]?.[windowId];

            if (canvas) {
                me.context = canvas.getContext('2d');
                hasChange && me.render()
            } else {
                setTimeout(checkCanvas, 50)
            }
        };
        checkCanvas()
    }

    updateGraphData(data) {
        this.nodes = data.nodes || [];
        this.links = data.links || [];
        // Simple layout re-calc could go here
    }

    updateSize(size) {
        let me = this;

        me.canvasSize = size;

        if (me.context) {
            me.context.canvas.width  = size.width;
            me.context.canvas.height = size.height
        }
    }

    render() {
        let me = this;

        if (!me.context) {
            return;
        }

        const ctx    = me.context;
        const width  = me.canvasSize?.width || 800;
        const height = me.canvasSize?.height || 600;

        // Clear
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, width, height);

        // Draw Title
        ctx.fillStyle = '#ffffff';
        ctx.font      = '20px Arial';
        ctx.fillText('Agent Swarm Blackboard (Canvas 2D)', 20, 30);

        // Draw Links
        ctx.strokeStyle = '#666';
        ctx.lineWidth   = 2;
        me.links.forEach(link => {
            const source = me.nodes.find(n => n.id === link.source);
            const target = me.nodes.find(n => n.id === link.target);
            if (source && target) {
                ctx.beginPath();
                ctx.moveTo(source.x, source.y);
                ctx.lineTo(target.x, target.y);
                ctx.stroke();
            }
        });

        // Draw Nodes
        me.nodes.forEach(node => {
            // Node shape
            ctx.beginPath();
            ctx.arc(node.x, node.y, 15, 0, 2 * Math.PI);
            ctx.fillStyle = node.color || '#ccc';
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth   = 2;
            ctx.stroke();

            // Label
            ctx.fillStyle = '#eee';
            ctx.font      = '12px Arial';
            ctx.fillText(node.label || node.id, node.x + 20, node.y + 5);
        });

        // Simple animation loop
        // Just moving the first node slightly to prove it's alive
        if (me.nodes.length > 0) {
            me.nodes[0].x = 100 + Math.sin(Date.now() / 1000) * 20;
        }

        // Loop using setTimeout since requestAnimationFrame support varies in workers
        setTimeout(me.render.bind(me), 1000 / 60);
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Blackboard));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2NhbnZhcy9hcHBzX2FnZW50b3NfY2FudmFzX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBaUQ7O0FBRTFDO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ0o4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwwREFBSTtBQUM3QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtFQUFrRTtBQUMvRSxhQUFhLCtEQUErRDtBQUM1RSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWEsZ0NBQWdDO0FBQzdDLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLDBCQUEwQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvYWdlbnRvcy9jYW52YXMubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL2FnZW50b3MvY2FudmFzL0JsYWNrYm9hcmQubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCbGFja2JvYXJkIGZyb20gJy4vY2FudmFzL0JsYWNrYm9hcmQubWpzJztcblxuZXhwb3J0IGNvbnN0IG9uU3RhcnQgPSAoKSA9PiB7XG4gICAgLy8gQmxhY2tib2FyZCBIZWxwZXIgYXZhaWxhYmxlIGluc2lkZSB0aGUgQ2FudmFzIHdvcmtlclxufTtcbiIsImltcG9ydCBCYXNlIGZyb20gJy4uLy4uLy4uL3NyYy9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgQWdlbnRPUy5jYW52YXMuQmxhY2tib2FyZFxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICogQHNpbmdsZXRvblxuICovXG5jbGFzcyBCbGFja2JvYXJkIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdBZ2VudE9TLmNhbnZhcy5CbGFja2JvYXJkJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdBZ2VudE9TLmNhbnZhcy5CbGFja2JvYXJkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW90ZSBtZXRob2QgYWNjZXNzXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gcmVtb3RlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHJlbW90ZToge1xuICAgICAgICAgICAgYXBwOiBbXG4gICAgICAgICAgICAgICAgJ3VwZGF0ZUdyYXBoRGF0YScsXG4gICAgICAgICAgICAgICAgJ3VwZGF0ZVNpemUnLFxuICAgICAgICAgICAgICAgICdpbml0R3JhcGgnXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaW5nbGV0b249dHJ1ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzaW5nbGV0b246IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gY2FudmFzSWQ9bnVsbFxuICAgICAqL1xuICAgIGNhbnZhc0lkID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gY2FudmFzU2l6ZT1udWxsXG4gICAgICovXG4gICAgY2FudmFzU2l6ZSA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGNvbnRleHQ9bnVsbFxuICAgICAqL1xuICAgIGNvbnRleHQgPSBudWxsXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7QXJyYXl9IGxpbmtzPVtdXG4gICAgICovXG4gICAgbGlua3MgPSBbXVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0FycmF5fSBub2Rlcz1bXVxuICAgICAqL1xuICAgIG5vZGVzID0gW11cblxuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG4gICAgICAgIC8vIFNlZWQgc29tZSBkdW1teSBkYXRhIGZvciBpbml0aWFsIHJlbmRlciB2ZXJpZmljYXRpb25cbiAgICAgICAgdGhpcy5ub2RlcyA9IFtcbiAgICAgICAgICAgIHtpZDogJ3Jvb3QnLCB4OiAxMDAsIHk6IDEwMCwgbGFiZWw6ICdSb290IEFnZW50JywgY29sb3I6ICcjNENBRjUwJ30sXG4gICAgICAgICAgICB7aWQ6ICd0YXNrMScsIHg6IDIwMCwgeTogMTUwLCBsYWJlbDogJ1Rhc2sgMScsIGNvbG9yOiAnIzIxOTZGMyd9LFxuICAgICAgICAgICAge2lkOiAndGFzazInLCB4OiAzMDAsIHk6IDEwMCwgbGFiZWw6ICdUYXNrIDInLCBjb2xvcjogJyNGRkMxMDcnfVxuICAgICAgICBdO1xuICAgICAgICB0aGlzLmxpbmtzID0gW1xuICAgICAgICAgICAge3NvdXJjZTogJ3Jvb3QnLCB0YXJnZXQ6ICd0YXNrMSd9LFxuICAgICAgICAgICAge3NvdXJjZTogJ3Jvb3QnLCB0YXJnZXQ6ICd0YXNrMid9XG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgZ3JhcGggd2l0aCBhIGNhbnZhcyBJRFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdHMuY2FudmFzSWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy53aW5kb3dJZFxuICAgICAqL1xuICAgIGluaXRHcmFwaCh7Y2FudmFzSWQsIHdpbmRvd0lkfSkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGhhc0NoYW5nZSA9IG1lLmNhbnZhc0lkICE9PSBjYW52YXNJZDtcblxuICAgICAgICBjb25zb2xlLmxvZygnQmxhY2tib2FyZDogaW5pdEdyYXBoJywgY2FudmFzSWQsIGhhc0NoYW5nZSk7XG4gICAgICAgIHRoaXMuY2FudmFzSWQgPSBjYW52YXNJZDtcblxuICAgICAgICAvLyBXYWl0IGZvciB0aGUgY2FudmFzIHRvIGJlIGF2YWlsYWJsZSBpbiB0aGUgd29ya2VyIG1hcFxuICAgICAgICBjb25zdCBjaGVja0NhbnZhcyA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNhbnZhcyA9IE5lby5jdXJyZW50V29ya2VyLmNhbnZhc1dpbmRvd01hcFtjYW52YXNJZF0/Llt3aW5kb3dJZF07XG5cbiAgICAgICAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgICAgICAgICBtZS5jb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgaGFzQ2hhbmdlICYmIG1lLnJlbmRlcigpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoY2hlY2tDYW52YXMsIDUwKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjaGVja0NhbnZhcygpXG4gICAgfVxuXG4gICAgdXBkYXRlR3JhcGhEYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy5ub2RlcyA9IGRhdGEubm9kZXMgfHwgW107XG4gICAgICAgIHRoaXMubGlua3MgPSBkYXRhLmxpbmtzIHx8IFtdO1xuICAgICAgICAvLyBTaW1wbGUgbGF5b3V0IHJlLWNhbGMgY291bGQgZ28gaGVyZVxuICAgIH1cblxuICAgIHVwZGF0ZVNpemUoc2l6ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmNhbnZhc1NpemUgPSBzaXplO1xuXG4gICAgICAgIGlmIChtZS5jb250ZXh0KSB7XG4gICAgICAgICAgICBtZS5jb250ZXh0LmNhbnZhcy53aWR0aCAgPSBzaXplLndpZHRoO1xuICAgICAgICAgICAgbWUuY29udGV4dC5jYW52YXMuaGVpZ2h0ID0gc2l6ZS5oZWlnaHRcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIW1lLmNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGN0eCAgICA9IG1lLmNvbnRleHQ7XG4gICAgICAgIGNvbnN0IHdpZHRoICA9IG1lLmNhbnZhc1NpemU/LndpZHRoIHx8IDgwMDtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gbWUuY2FudmFzU2l6ZT8uaGVpZ2h0IHx8IDYwMDtcblxuICAgICAgICAvLyBDbGVhclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gJyMwMDAwMDAnO1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgLy8gRHJhdyBUaXRsZVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gJyNmZmZmZmYnO1xuICAgICAgICBjdHguZm9udCAgICAgID0gJzIwcHggQXJpYWwnO1xuICAgICAgICBjdHguZmlsbFRleHQoJ0FnZW50IFN3YXJtIEJsYWNrYm9hcmQgKENhbnZhcyAyRCknLCAyMCwgMzApO1xuXG4gICAgICAgIC8vIERyYXcgTGlua3NcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJyM2NjYnO1xuICAgICAgICBjdHgubGluZVdpZHRoICAgPSAyO1xuICAgICAgICBtZS5saW5rcy5mb3JFYWNoKGxpbmsgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc291cmNlID0gbWUubm9kZXMuZmluZChuID0+IG4uaWQgPT09IGxpbmsuc291cmNlKTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IG1lLm5vZGVzLmZpbmQobiA9PiBuLmlkID09PSBsaW5rLnRhcmdldCk7XG4gICAgICAgICAgICBpZiAoc291cmNlICYmIHRhcmdldCkge1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHNvdXJjZS54LCBzb3VyY2UueSk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRHJhdyBOb2Rlc1xuICAgICAgICBtZS5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgLy8gTm9kZSBzaGFwZVxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LmFyYyhub2RlLngsIG5vZGUueSwgMTUsIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBub2RlLmNvbG9yIHx8ICcjY2NjJztcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnI2ZmZic7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoICAgPSAyO1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgICAgICAvLyBMYWJlbFxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjZWVlJztcbiAgICAgICAgICAgIGN0eC5mb250ICAgICAgPSAnMTJweCBBcmlhbCc7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQobm9kZS5sYWJlbCB8fCBub2RlLmlkLCBub2RlLnggKyAyMCwgbm9kZS55ICsgNSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNpbXBsZSBhbmltYXRpb24gbG9vcFxuICAgICAgICAvLyBKdXN0IG1vdmluZyB0aGUgZmlyc3Qgbm9kZSBzbGlnaHRseSB0byBwcm92ZSBpdCdzIGFsaXZlXG4gICAgICAgIGlmIChtZS5ub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBtZS5ub2Rlc1swXS54ID0gMTAwICsgTWF0aC5zaW4oRGF0ZS5ub3coKSAvIDEwMDApICogMjA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb29wIHVzaW5nIHNldFRpbWVvdXQgc2luY2UgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHN1cHBvcnQgdmFyaWVzIGluIHdvcmtlcnNcbiAgICAgICAgc2V0VGltZW91dChtZS5yZW5kZXIuYmluZChtZSksIDEwMDAgLyA2MCk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhCbGFja2JvYXJkKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=