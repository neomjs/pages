export const __webpack_esm_id__ = "vendors-apps_portal_canvas_FooterCanvas_mjs";
export const __webpack_esm_ids__ = ["vendors-apps_portal_canvas_FooterCanvas_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./apps/portal/canvas/Base.mjs"
/*!*************************************!*\
  !*** ./apps/portal/canvas/Base.mjs ***!
  \*************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @summary Abstract base class for Portal Canvas Renderers.
 *
 * This class serves as the foundation for the specialized canvas visualizations (Header, Home, Services, Ticket)
 * that run within the **Neo.mjs Canvas SharedWorker**.
 *
 * It creates helper singletons that manage their own `OffscreenCanvas` instances, providing a standardized
 * architecture for:
 * - **Lifecycle Management:** Initialization (`initGraph`), destruction (`clearGraph`), and resource cleanup.
 * - **Render Loop Control:** Unified `render` loop with pause/resume capabilities and frame scheduling.
 * - **Context Management:** Robust handling of `OffscreenCanvas` transfer and context acquisition via `waitForCanvas`.
 * - **Shared State:** Common state management for mouse interaction, time, and theming.
 *
 * These renderers operate off the main thread to ensure high-performance, 60fps animations without
 * blocking the UI.
 *
 * @class Portal.canvas.Base
 * @extends Neo.core.Base
 */
class Base extends _src_core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.canvas.Base'
         * @protected
         */
        className: 'Portal.canvas.Base',
        /**
         * Remote method access
         * @member {Object} remote
         * @protected
         */
        remote: {
            app: [
                'clearGraph',
                'initGraph',
                'pause',
                'resume',
                'setTheme',
                'updateMouseState',
                'updateSize'
            ]
        },
        /**
         * The active color theme ('light' or 'dark').
         * @member {String} theme_='light'
         * @reactive
         */
        theme_: 'light'
    }

    /**
     * @member {Number|null} animationId=null
     */
    animationId = null
    /**
     * @member {String|null} canvasId=null
     */
    canvasId = null
    /**
     * @member {Object|null} canvasSize=null
     */
    canvasSize = null
    /**
     * @member {OffscreenCanvasRenderingContext2D|null} context=null
     */
    context = null
    /**
     * Cache for reusable gradients to prevent GC.
     * @member {Object} gradients={}
     */
    gradients = {}
    /**
     * Flag to pause the render loop.
     * @member {Boolean} isPaused=false
     */
    isPaused = false
    /**
     * Tracked mouse position for interactive physics.
     * Initialize off-screen to prevent startup jitters.
     * @member {Object} mouse={x: -1000, y: -1000}
     */
    mouse = {x: -1000, y: -1000}
    /**
     * Global simulation time.
     * @member {Number} time=0
     */
    time = 0

    /**
     * @member {Function} renderLoop=this.render.bind(this)
     */
    renderLoop = this.render.bind(this)

    /**
     * Triggered after the `theme` config is changed.
     * Updates the resource cache (gradients, colors) to reflect the new theme immediately.
     * @param {String} value
     * @param {String} oldValue
     */
    afterSetTheme(value, oldValue) {
        if (value && this.canvasSize) {
            this.updateResources?.(this.canvasSize.width, this.canvasSize.height)
        }
    }

    /**
     * Checks if the canvas is ready to render.
     * Returns true only if the context exists and the simulation is not paused.
     * Subclasses should call this at the start of their `render` loop.
     * @returns {Boolean}
     */
    get canRender() {
        let me = this;
        return !!(me.context && !me.isPaused)
    }

    /**
     * Clears the graph state and stops the render loop.
     * Use this to cleanup resources when the component is destroyed or unmounted.
     */
    clearGraph() {
        let me = this;
        me.context     = null;
        me.canvasId    = null;
        me.canvasSize  = null;
        me.animationId = null;
        me.isPaused    = false;
        me.gradients   = {};
        me.mouse       = {x: -1000, y: -1000};
        me.time        = 0
    }

    /**
     * Initializes the canvas context.
     * Starts the polling mechanism to wait for the OffscreenCanvas transfer from the Main Thread.
     * @param {Object} opts
     * @param {String} opts.canvasId
     * @param {String} opts.windowId
     */
    initGraph({canvasId, windowId}) {
        let me        = this,
            hasChange = me.canvasId !== canvasId;

        me.canvasId = canvasId;

        me.waitForCanvas(canvasId, windowId, hasChange)
    }

    /**
     * Hook for subclasses to handle mouse clicks.
     * Called by `updateMouseState` when a click event is received.
     * @param {Object} data
     */
    onMouseClick(data) {}

    /**
     * Pauses the simulation.
     * The render loop will exit early while `isPaused` is true.
     */
    pause() {
        this.isPaused = true
    }

    /**
     * Abstract render method.
     * Subclasses must implement this method to draw the frame.
     */
    render() {}

    /**
     * Resumes the simulation.
     * If the simulation was paused, this restarts the render loop.
     */
    resume() {
        let me = this;

        if (me.isPaused) {
            me.isPaused = false;
            me.renderLoop()
        }
    }

    /**
     * Exposed method for Remote Access to trigger the reactive config setter.
     * @param {String} value
     */
    setTheme(value) {
        this.theme = value
    }

    /**
     * Updates the local mouse state from main thread events.
     * Delegates click events to `onMouseClick`.
     * @param {Object} data
     * @param {Boolean} [data.click]
     * @param {Boolean} [data.leave]
     * @param {Number} [data.x]
     * @param {Number} [data.y]
     */
    updateMouseState(data) {
        let me = this;

        if (data.leave) {
            me.mouse.x = -1000;
            me.mouse.y = -1000
        } else {
            if (data.x !== undefined) me.mouse.x = data.x;
            if (data.y !== undefined) me.mouse.y = data.y;

            if (data.click) {
                me.onMouseClick(data)
            }
        }
    }

    /**
     * Updates the canvas size and resizes the internal context.
     * Triggers `updateResources` hook to allow subclasses to regenerate buffers/gradients.
     * @param {Object} size
     * @param {Number} size.height
     * @param {Number} size.width
     */
    updateSize(size) {
        let me = this;

        me.canvasSize = size;

        if (me.context) {
            me.context.canvas.width  = size.width;
            me.context.canvas.height = size.height;
            // Calls the hook to re-generate resources if implemented
            me.updateResources?.(size.width, size.height)
        }
    }

    /**
     * Polls for the OffscreenCanvas until it is available in the Worker's `canvasWindowMap`.
     * Once found, it initializes the context and starts the render loop.
     * @param {String} canvasId
     * @param {String} windowId
     * @param {Boolean} hasChange
     * @protected
     */
    waitForCanvas(canvasId, windowId, hasChange) {
        let me     = this,
            canvas = Neo.currentWorker.canvasWindowMap[canvasId]?.[windowId];

        if (canvas) {
            me.context = canvas.getContext('2d');

            // Standardize size update
            me.updateSize({width: canvas.width, height: canvas.height});

            // Optional hook for subclasses
            me.onGraphMounted?.(canvas.width, canvas.height);

            if (hasChange && !me.animationId) {
                me.renderLoop()
            }
        } else {
            setTimeout(me.waitForCanvas.bind(me, canvasId, windowId, hasChange), 50)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Base));


/***/ },

/***/ "./apps/portal/canvas/FooterCanvas.mjs"
/*!*********************************************!*\
  !*** ./apps/portal/canvas/FooterCanvas.mjs ***!
  \*********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./apps/portal/canvas/Base.mjs");


const
    hasRaf = typeof requestAnimationFrame === 'function',
    PARTICLE_COUNT = 800, // High density for the "Well"
    STRIDE         = 6;   // x, y, angle, radius, speed, size

/**
 * @summary SharedWorker renderer for the Footer "Event Horizon" overlay with Gravity Interaction.
 *
 * Implements the **"Event Horizon"** visual theme: A radial gravity well representing the core engine.
 *
 * **Visual Metaphor:**
 * - **The Source:** A central singularity that draws everything in.
 * - **Data Stream:** Particles spiral inward, accelerating as they approach the event horizon.
 * - **Gravity Interaction:** Hovered buttons become local "Gravity Wells", pulling particles out of the
 *   main stream into temporary orbit.
 *
 * @class Portal.canvas.FooterCanvas
 * @extends Portal.canvas.Base
 * @singleton
 */
class FooterCanvas extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static colors = {
        dark: {
            core  : '#FFFFFF',
            inner : '#00BFFF', // Cyan
            outer : '#3E63DD', // Neo Blue
            void  : 'rgba(0,0,0,0)'
        },
        light: {
            core  : '#3E63DD', // Neo Blue
            inner : '#536DFE', // Indigo
            outer : '#8BA6FF', // Light Blue
            void  : 'rgba(255,255,255,0)'
        }
    }

    static config = {
        /**
         * @member {String} className='Portal.canvas.FooterCanvas'
         * @protected
         */
        className: 'Portal.canvas.FooterCanvas',
        /**
         * Remote method access
         * @member {Object} remote
         * @protected
         */
        remote: {
            app: [
                'updateActiveId',
                'updateHoverId',
                'updateNavRects'
            ]
        },
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * Particle Buffer
     * @member {Float32Array|null} buffer=null
     */
    buffer = null
    /**
     * @member {String|null} hoverId=null
     */
    hoverId = null
    /**
     * @member {Object[]} navRects=[]
     */
    navRects = []
    /**
     * Transient gravity multiplier for snappy interactions.
     * @member {Number} gravityBoost=1
     */
    gravityBoost = 1

    /**
     * Clears the graph state.
     */
    clearGraph() {
        let me = this;
        super.clearGraph();
        me.buffer       = null;
        me.hoverId      = null;
        me.navRects     = [];
        me.gravityBoost = 1
    }

    /**
     * Initializes the grid.
     * @param {Number} width
     * @param {Number} height
     */
    onGraphMounted(width, height) {
        this.initParticles(width, height)
    }

    /**
     * Creates the particle buffer.
     * @param {Number} width
     * @param {Number} height
     */
    initParticles(width, height) {
        let me = this,
            count = PARTICLE_COUNT;

        me.buffer = new Float32Array(count * STRIDE);

        for (let i = 0; i < count; i++) {
            me.resetParticle(i, width, height, true)
        }
    }

    /**
     * Resets a particle to the outer rim.
     * @param {Number} i Index
     * @param {Number} w Width
     * @param {Number} h Height
     * @param {Boolean} randomRad Random radius (for initial fill)
     */
    resetParticle(i, w, h, randomRad=false) {
        let me = this,
            idx = i * STRIDE,
            maxR = Math.max(w, h) * 0.7;

        me.buffer[idx + 2] = Math.random() * Math.PI * 2; // Angle
        me.buffer[idx + 3] = randomRad ? Math.random() * maxR : maxR; // Radius
        me.buffer[idx + 4] = 0.5 + Math.random() * 1.5; // Base Speed
        me.buffer[idx + 5] = Math.random() * 2 + 0.5; // Size
    }

    /**
     * Main render loop.
     */
    render() {
        let me = this;

        if (!me.canRender) return;

        const
            ctx    = me.context,
            width  = me.canvasSize?.width  || 100,
            height = me.canvasSize?.height || 50,
            buffer = me.buffer,
            count  = PARTICLE_COUNT,
            colors = me.constructor.colors[me.theme];

        // Auto-reinit
        if (!buffer) {
            me.initParticles(width, height);
            return
        }

        // Decay Boost
        if (me.gravityBoost > 1) {
            me.gravityBoost *= 0.9;
        }

        ctx.clearRect(0, 0, width, height);

        const
            cx = width / 2,
            cy = height * 0.8; // Center low

        // 1. Draw "The Core" (Glow)
        // Global Engine Rev: Pulse the core radius based on gravityBoost
        let coreRadius = 200 * (1 + (me.gravityBoost - 1) * 0.1);
        let g = ctx.createRadialGradient(cx, cy, 0, cx, cy, coreRadius);
        g.addColorStop(0, colors.inner);
        g.addColorStop(1, colors.void);

        ctx.globalCompositeOperation = 'lighter';
        ctx.fillStyle = g;
        ctx.globalAlpha = 0.2;
        ctx.beginPath();
        ctx.arc(cx, cy, coreRadius, 0, Math.PI * 2);
        ctx.fill();

        // 2. Identify Attractor
        let attractor = null;
        if (me.hoverId && me.navRects.length > 0) {
            // Find rect
            for (const r of me.navRects) {
                if (r.id === me.hoverId) {
                    attractor = {
                        x: r.x + r.width / 2,
                        y: r.y + r.height / 2,
                        r: Math.max(r.width, r.height) / 2
                    };
                    break;
                }
            }
        }

        // 3. Draw Particles
        for (let i = 0; i < count; i++) {
            let idx   = i * STRIDE,
                angle = buffer[idx + 2],
                rad   = buffer[idx + 3],
                spd   = buffer[idx + 4],
                size  = buffer[idx + 5];

            // --- PHYSICS ---

            // Base State: Polar -> Cartesian
            let x = cx + Math.cos(angle) * rad;
            let y = cy + Math.sin(angle) * (rad * 0.4);

            let isCaptured = false;

            // GRAVITY INTERACTION
            if (attractor) {
                let dx = attractor.x - x,
                    dy = attractor.y - y,
                    dist = Math.sqrt(dx*dx + dy*dy);

                // Boosted capture radius
                const captureRadius = 150 * (1 + (me.gravityBoost - 1) * 0.5);

                // Partial Capture: Capture 33% of particles (indices divisible by 3)
                // Balance between maintaining core structure and creating a visible swarm.
                if (dist < captureRadius && i % 3 === 0) {
                    isCaptured = true;
                    // Move towards button center
                    // Boosted pull force
                    let force = (captureRadius - dist) / captureRadius;
                    force *= me.gravityBoost; // Apply boost to velocity

                    x += dx * force * 0.1;
                    y += dy * force * 0.1;
                }
            }

            if (!isCaptured) {
                // Normal Spiral Physics
                let velocity = spd * (1 + (500 / (rad + 10)));
                
                // Global Engine Rev: Accelerate spiral based on gravityBoost
                velocity *= (1 + (me.gravityBoost - 1) * 0.2);

                rad   -= velocity * 0.5;
                angle += velocity * 0.005;

                // Reset
                if (rad < 10) {
                    let maxR = Math.max(width, height) * 0.7;
                    rad = maxR;
                    angle = Math.random() * Math.PI * 2;
                }

                // Update Cartesian from new Polar
                x = cx + Math.cos(angle) * rad;
                y = cy + Math.sin(angle) * (rad * 0.4);
            }

            // Save Polar State
            buffer[idx + 2] = angle;
            buffer[idx + 3] = rad;

            // --- DRAW ---
            let distRatio = rad / (Math.max(width, height) * 0.6);
            let alpha = 1 - distRatio;

            ctx.beginPath();
            // Use 'inner' (Cyan/Indigo) for captured particles instead of 'core' (White)
            if (isCaptured) {
                ctx.fillStyle = colors.inner;
                ctx.globalAlpha = 0.6;
            } else {
                ctx.fillStyle = distRatio < 0.3 ? colors.core : colors.outer;
                ctx.globalAlpha = alpha;
            }

            if (rad < 100 && !isCaptured) {
                // Spaghettification
                let tailX = cx + Math.cos(angle - 0.2) * (rad + 20);
                let tailY = cy + Math.sin(angle - 0.2) * ((rad + 20) * 0.4);

                ctx.strokeStyle = colors.core;
                ctx.lineWidth = size;
                ctx.moveTo(x, y);
                ctx.lineTo(tailX, tailY);
                ctx.stroke();
            } else {
                // No size increase for captured particles
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 1;

        if (hasRaf) {
            me.animationId = requestAnimationFrame(me.renderLoop)
        } else {
            me.animationId = setTimeout(me.renderLoop, 1000 / 60)
        }
    }

    /**
     * @param {Object} data
     */
    updateActiveId(data) {}

    /**
     * @param {Object} data
     * @param {String} [data.id]
     */
    updateHoverId(data) {
        let me = this;
        if (me.hoverId !== data?.id) {
            me.gravityBoost = 5; // Trigger Boost on change
        }
        me.hoverId = data?.id || null
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.rects
     */
    updateNavRects(data) {
        let rects = data?.rects;
        this.navRects = Array.isArray(rects) ? rects : []
    }

    /**
     * Re-init on resize.
     * @param {Number} width
     * @param {Number} height
     */
    updateResources(width, height) {
        this.initParticles(width, height)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(FooterCanvas));

/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2NhbnZhcy92ZW5kb3JzLWFwcHNfcG9ydGFsX2NhbnZhc19Gb290ZXJDYW52YXNfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFpRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMERBQU87QUFDMUI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdDQUF3QztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRLE9BQU87QUFDL0I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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Q0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSw0QkFBNEIsRSIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9hcHBzL3BvcnRhbC9jYW52YXMvQmFzZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvcG9ydGFsL2NhbnZhcy9Gb290ZXJDYW52YXMubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBOZW9CYXNlIGZyb20gJy4uLy4uLy4uL3NyYy9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAc3VtbWFyeSBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBQb3J0YWwgQ2FudmFzIFJlbmRlcmVycy5cbiAqXG4gKiBUaGlzIGNsYXNzIHNlcnZlcyBhcyB0aGUgZm91bmRhdGlvbiBmb3IgdGhlIHNwZWNpYWxpemVkIGNhbnZhcyB2aXN1YWxpemF0aW9ucyAoSGVhZGVyLCBIb21lLCBTZXJ2aWNlcywgVGlja2V0KVxuICogdGhhdCBydW4gd2l0aGluIHRoZSAqKk5lby5tanMgQ2FudmFzIFNoYXJlZFdvcmtlcioqLlxuICpcbiAqIEl0IGNyZWF0ZXMgaGVscGVyIHNpbmdsZXRvbnMgdGhhdCBtYW5hZ2UgdGhlaXIgb3duIGBPZmZzY3JlZW5DYW52YXNgIGluc3RhbmNlcywgcHJvdmlkaW5nIGEgc3RhbmRhcmRpemVkXG4gKiBhcmNoaXRlY3R1cmUgZm9yOlxuICogLSAqKkxpZmVjeWNsZSBNYW5hZ2VtZW50OioqIEluaXRpYWxpemF0aW9uIChgaW5pdEdyYXBoYCksIGRlc3RydWN0aW9uIChgY2xlYXJHcmFwaGApLCBhbmQgcmVzb3VyY2UgY2xlYW51cC5cbiAqIC0gKipSZW5kZXIgTG9vcCBDb250cm9sOioqIFVuaWZpZWQgYHJlbmRlcmAgbG9vcCB3aXRoIHBhdXNlL3Jlc3VtZSBjYXBhYmlsaXRpZXMgYW5kIGZyYW1lIHNjaGVkdWxpbmcuXG4gKiAtICoqQ29udGV4dCBNYW5hZ2VtZW50OioqIFJvYnVzdCBoYW5kbGluZyBvZiBgT2Zmc2NyZWVuQ2FudmFzYCB0cmFuc2ZlciBhbmQgY29udGV4dCBhY3F1aXNpdGlvbiB2aWEgYHdhaXRGb3JDYW52YXNgLlxuICogLSAqKlNoYXJlZCBTdGF0ZToqKiBDb21tb24gc3RhdGUgbWFuYWdlbWVudCBmb3IgbW91c2UgaW50ZXJhY3Rpb24sIHRpbWUsIGFuZCB0aGVtaW5nLlxuICpcbiAqIFRoZXNlIHJlbmRlcmVycyBvcGVyYXRlIG9mZiB0aGUgbWFpbiB0aHJlYWQgdG8gZW5zdXJlIGhpZ2gtcGVyZm9ybWFuY2UsIDYwZnBzIGFuaW1hdGlvbnMgd2l0aG91dFxuICogYmxvY2tpbmcgdGhlIFVJLlxuICpcbiAqIEBjbGFzcyBQb3J0YWwuY2FudmFzLkJhc2VcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgQmFzZSBleHRlbmRzIE5lb0Jhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nUG9ydGFsLmNhbnZhcy5CYXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdQb3J0YWwuY2FudmFzLkJhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3RlIG1ldGhvZCBhY2Nlc3NcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSByZW1vdGVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3RlOiB7XG4gICAgICAgICAgICBhcHA6IFtcbiAgICAgICAgICAgICAgICAnY2xlYXJHcmFwaCcsXG4gICAgICAgICAgICAgICAgJ2luaXRHcmFwaCcsXG4gICAgICAgICAgICAgICAgJ3BhdXNlJyxcbiAgICAgICAgICAgICAgICAncmVzdW1lJyxcbiAgICAgICAgICAgICAgICAnc2V0VGhlbWUnLFxuICAgICAgICAgICAgICAgICd1cGRhdGVNb3VzZVN0YXRlJyxcbiAgICAgICAgICAgICAgICAndXBkYXRlU2l6ZSdcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhY3RpdmUgY29sb3IgdGhlbWUgKCdsaWdodCcgb3IgJ2RhcmsnKS5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB0aGVtZV89J2xpZ2h0J1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHRoZW1lXzogJ2xpZ2h0J1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBhbmltYXRpb25JZD1udWxsXG4gICAgICovXG4gICAgYW5pbWF0aW9uSWQgPSBudWxsXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGNhbnZhc0lkPW51bGxcbiAgICAgKi9cbiAgICBjYW52YXNJZCA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gY2FudmFzU2l6ZT1udWxsXG4gICAgICovXG4gICAgY2FudmFzU2l6ZSA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPZmZzY3JlZW5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkR8bnVsbH0gY29udGV4dD1udWxsXG4gICAgICovXG4gICAgY29udGV4dCA9IG51bGxcbiAgICAvKipcbiAgICAgKiBDYWNoZSBmb3IgcmV1c2FibGUgZ3JhZGllbnRzIHRvIHByZXZlbnQgR0MuXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBncmFkaWVudHM9e31cbiAgICAgKi9cbiAgICBncmFkaWVudHMgPSB7fVxuICAgIC8qKlxuICAgICAqIEZsYWcgdG8gcGF1c2UgdGhlIHJlbmRlciBsb29wLlxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzUGF1c2VkPWZhbHNlXG4gICAgICovXG4gICAgaXNQYXVzZWQgPSBmYWxzZVxuICAgIC8qKlxuICAgICAqIFRyYWNrZWQgbW91c2UgcG9zaXRpb24gZm9yIGludGVyYWN0aXZlIHBoeXNpY3MuXG4gICAgICogSW5pdGlhbGl6ZSBvZmYtc2NyZWVuIHRvIHByZXZlbnQgc3RhcnR1cCBqaXR0ZXJzLlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gbW91c2U9e3g6IC0xMDAwLCB5OiAtMTAwMH1cbiAgICAgKi9cbiAgICBtb3VzZSA9IHt4OiAtMTAwMCwgeTogLTEwMDB9XG4gICAgLyoqXG4gICAgICogR2xvYmFsIHNpbXVsYXRpb24gdGltZS5cbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHRpbWU9MFxuICAgICAqL1xuICAgIHRpbWUgPSAwXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gcmVuZGVyTG9vcD10aGlzLnJlbmRlci5iaW5kKHRoaXMpXG4gICAgICovXG4gICAgcmVuZGVyTG9vcCA9IHRoaXMucmVuZGVyLmJpbmQodGhpcylcblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgYHRoZW1lYCBjb25maWcgaXMgY2hhbmdlZC5cbiAgICAgKiBVcGRhdGVzIHRoZSByZXNvdXJjZSBjYWNoZSAoZ3JhZGllbnRzLCBjb2xvcnMpIHRvIHJlZmxlY3QgdGhlIG5ldyB0aGVtZSBpbW1lZGlhdGVseS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhZnRlclNldFRoZW1lKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgJiYgdGhpcy5jYW52YXNTaXplKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVJlc291cmNlcz8uKHRoaXMuY2FudmFzU2l6ZS53aWR0aCwgdGhpcy5jYW52YXNTaXplLmhlaWdodClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgY2FudmFzIGlzIHJlYWR5IHRvIHJlbmRlci5cbiAgICAgKiBSZXR1cm5zIHRydWUgb25seSBpZiB0aGUgY29udGV4dCBleGlzdHMgYW5kIHRoZSBzaW11bGF0aW9uIGlzIG5vdCBwYXVzZWQuXG4gICAgICogU3ViY2xhc3NlcyBzaG91bGQgY2FsbCB0aGlzIGF0IHRoZSBzdGFydCBvZiB0aGVpciBgcmVuZGVyYCBsb29wLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGdldCBjYW5SZW5kZXIoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAhIShtZS5jb250ZXh0ICYmICFtZS5pc1BhdXNlZClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGdyYXBoIHN0YXRlIGFuZCBzdG9wcyB0aGUgcmVuZGVyIGxvb3AuXG4gICAgICogVXNlIHRoaXMgdG8gY2xlYW51cCByZXNvdXJjZXMgd2hlbiB0aGUgY29tcG9uZW50IGlzIGRlc3Ryb3llZCBvciB1bm1vdW50ZWQuXG4gICAgICovXG4gICAgY2xlYXJHcmFwaCgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcbiAgICAgICAgbWUuY29udGV4dCAgICAgPSBudWxsO1xuICAgICAgICBtZS5jYW52YXNJZCAgICA9IG51bGw7XG4gICAgICAgIG1lLmNhbnZhc1NpemUgID0gbnVsbDtcbiAgICAgICAgbWUuYW5pbWF0aW9uSWQgPSBudWxsO1xuICAgICAgICBtZS5pc1BhdXNlZCAgICA9IGZhbHNlO1xuICAgICAgICBtZS5ncmFkaWVudHMgICA9IHt9O1xuICAgICAgICBtZS5tb3VzZSAgICAgICA9IHt4OiAtMTAwMCwgeTogLTEwMDB9O1xuICAgICAgICBtZS50aW1lICAgICAgICA9IDBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgY2FudmFzIGNvbnRleHQuXG4gICAgICogU3RhcnRzIHRoZSBwb2xsaW5nIG1lY2hhbmlzbSB0byB3YWl0IGZvciB0aGUgT2Zmc2NyZWVuQ2FudmFzIHRyYW5zZmVyIGZyb20gdGhlIE1haW4gVGhyZWFkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdHMuY2FudmFzSWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy53aW5kb3dJZFxuICAgICAqL1xuICAgIGluaXRHcmFwaCh7Y2FudmFzSWQsIHdpbmRvd0lkfSkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGhhc0NoYW5nZSA9IG1lLmNhbnZhc0lkICE9PSBjYW52YXNJZDtcblxuICAgICAgICBtZS5jYW52YXNJZCA9IGNhbnZhc0lkO1xuXG4gICAgICAgIG1lLndhaXRGb3JDYW52YXMoY2FudmFzSWQsIHdpbmRvd0lkLCBoYXNDaGFuZ2UpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSG9vayBmb3Igc3ViY2xhc3NlcyB0byBoYW5kbGUgbW91c2UgY2xpY2tzLlxuICAgICAqIENhbGxlZCBieSBgdXBkYXRlTW91c2VTdGF0ZWAgd2hlbiBhIGNsaWNrIGV2ZW50IGlzIHJlY2VpdmVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Nb3VzZUNsaWNrKGRhdGEpIHt9XG5cbiAgICAvKipcbiAgICAgKiBQYXVzZXMgdGhlIHNpbXVsYXRpb24uXG4gICAgICogVGhlIHJlbmRlciBsb29wIHdpbGwgZXhpdCBlYXJseSB3aGlsZSBgaXNQYXVzZWRgIGlzIHRydWUuXG4gICAgICovXG4gICAgcGF1c2UoKSB7XG4gICAgICAgIHRoaXMuaXNQYXVzZWQgPSB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWJzdHJhY3QgcmVuZGVyIG1ldGhvZC5cbiAgICAgKiBTdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvIGRyYXcgdGhlIGZyYW1lLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHt9XG5cbiAgICAvKipcbiAgICAgKiBSZXN1bWVzIHRoZSBzaW11bGF0aW9uLlxuICAgICAqIElmIHRoZSBzaW11bGF0aW9uIHdhcyBwYXVzZWQsIHRoaXMgcmVzdGFydHMgdGhlIHJlbmRlciBsb29wLlxuICAgICAqL1xuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuaXNQYXVzZWQpIHtcbiAgICAgICAgICAgIG1lLmlzUGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICBtZS5yZW5kZXJMb29wKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4cG9zZWQgbWV0aG9kIGZvciBSZW1vdGUgQWNjZXNzIHRvIHRyaWdnZXIgdGhlIHJlYWN0aXZlIGNvbmZpZyBzZXR0ZXIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICovXG4gICAgc2V0VGhlbWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy50aGVtZSA9IHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgbG9jYWwgbW91c2Ugc3RhdGUgZnJvbSBtYWluIHRocmVhZCBldmVudHMuXG4gICAgICogRGVsZWdhdGVzIGNsaWNrIGV2ZW50cyB0byBgb25Nb3VzZUNsaWNrYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2RhdGEuY2xpY2tdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZGF0YS5sZWF2ZV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2RhdGEueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2RhdGEueV1cbiAgICAgKi9cbiAgICB1cGRhdGVNb3VzZVN0YXRlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoZGF0YS5sZWF2ZSkge1xuICAgICAgICAgICAgbWUubW91c2UueCA9IC0xMDAwO1xuICAgICAgICAgICAgbWUubW91c2UueSA9IC0xMDAwXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZGF0YS54ICE9PSB1bmRlZmluZWQpIG1lLm1vdXNlLnggPSBkYXRhLng7XG4gICAgICAgICAgICBpZiAoZGF0YS55ICE9PSB1bmRlZmluZWQpIG1lLm1vdXNlLnkgPSBkYXRhLnk7XG5cbiAgICAgICAgICAgIGlmIChkYXRhLmNsaWNrKSB7XG4gICAgICAgICAgICAgICAgbWUub25Nb3VzZUNsaWNrKGRhdGEpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBjYW52YXMgc2l6ZSBhbmQgcmVzaXplcyB0aGUgaW50ZXJuYWwgY29udGV4dC5cbiAgICAgKiBUcmlnZ2VycyBgdXBkYXRlUmVzb3VyY2VzYCBob29rIHRvIGFsbG93IHN1YmNsYXNzZXMgdG8gcmVnZW5lcmF0ZSBidWZmZXJzL2dyYWRpZW50cy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2l6ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzaXplLmhlaWdodFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzaXplLndpZHRoXG4gICAgICovXG4gICAgdXBkYXRlU2l6ZShzaXplKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuY2FudmFzU2l6ZSA9IHNpemU7XG5cbiAgICAgICAgaWYgKG1lLmNvbnRleHQpIHtcbiAgICAgICAgICAgIG1lLmNvbnRleHQuY2FudmFzLndpZHRoICA9IHNpemUud2lkdGg7XG4gICAgICAgICAgICBtZS5jb250ZXh0LmNhbnZhcy5oZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgICAgICAgICAgIC8vIENhbGxzIHRoZSBob29rIHRvIHJlLWdlbmVyYXRlIHJlc291cmNlcyBpZiBpbXBsZW1lbnRlZFxuICAgICAgICAgICAgbWUudXBkYXRlUmVzb3VyY2VzPy4oc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQb2xscyBmb3IgdGhlIE9mZnNjcmVlbkNhbnZhcyB1bnRpbCBpdCBpcyBhdmFpbGFibGUgaW4gdGhlIFdvcmtlcidzIGBjYW52YXNXaW5kb3dNYXBgLlxuICAgICAqIE9uY2UgZm91bmQsIGl0IGluaXRpYWxpemVzIHRoZSBjb250ZXh0IGFuZCBzdGFydHMgdGhlIHJlbmRlciBsb29wLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjYW52YXNJZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB3aW5kb3dJZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaGFzQ2hhbmdlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHdhaXRGb3JDYW52YXMoY2FudmFzSWQsIHdpbmRvd0lkLCBoYXNDaGFuZ2UpIHtcbiAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjYW52YXMgPSBOZW8uY3VycmVudFdvcmtlci5jYW52YXNXaW5kb3dNYXBbY2FudmFzSWRdPy5bd2luZG93SWRdO1xuXG4gICAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgICAgIG1lLmNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAgICAgLy8gU3RhbmRhcmRpemUgc2l6ZSB1cGRhdGVcbiAgICAgICAgICAgIG1lLnVwZGF0ZVNpemUoe3dpZHRoOiBjYW52YXMud2lkdGgsIGhlaWdodDogY2FudmFzLmhlaWdodH0pO1xuXG4gICAgICAgICAgICAvLyBPcHRpb25hbCBob29rIGZvciBzdWJjbGFzc2VzXG4gICAgICAgICAgICBtZS5vbkdyYXBoTW91bnRlZD8uKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgICAgICAgICAgIGlmIChoYXNDaGFuZ2UgJiYgIW1lLmFuaW1hdGlvbklkKSB7XG4gICAgICAgICAgICAgICAgbWUucmVuZGVyTG9vcCgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KG1lLndhaXRGb3JDYW52YXMuYmluZChtZSwgY2FudmFzSWQsIHdpbmRvd0lkLCBoYXNDaGFuZ2UpLCA1MClcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQmFzZSk7XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuL0Jhc2UubWpzJztcblxuY29uc3RcbiAgICBoYXNSYWYgPSB0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nLFxuICAgIFBBUlRJQ0xFX0NPVU5UID0gODAwLCAvLyBIaWdoIGRlbnNpdHkgZm9yIHRoZSBcIldlbGxcIlxuICAgIFNUUklERSAgICAgICAgID0gNjsgICAvLyB4LCB5LCBhbmdsZSwgcmFkaXVzLCBzcGVlZCwgc2l6ZVxuXG4vKipcbiAqIEBzdW1tYXJ5IFNoYXJlZFdvcmtlciByZW5kZXJlciBmb3IgdGhlIEZvb3RlciBcIkV2ZW50IEhvcml6b25cIiBvdmVybGF5IHdpdGggR3Jhdml0eSBJbnRlcmFjdGlvbi5cbiAqXG4gKiBJbXBsZW1lbnRzIHRoZSAqKlwiRXZlbnQgSG9yaXpvblwiKiogdmlzdWFsIHRoZW1lOiBBIHJhZGlhbCBncmF2aXR5IHdlbGwgcmVwcmVzZW50aW5nIHRoZSBjb3JlIGVuZ2luZS5cbiAqXG4gKiAqKlZpc3VhbCBNZXRhcGhvcjoqKlxuICogLSAqKlRoZSBTb3VyY2U6KiogQSBjZW50cmFsIHNpbmd1bGFyaXR5IHRoYXQgZHJhd3MgZXZlcnl0aGluZyBpbi5cbiAqIC0gKipEYXRhIFN0cmVhbToqKiBQYXJ0aWNsZXMgc3BpcmFsIGlud2FyZCwgYWNjZWxlcmF0aW5nIGFzIHRoZXkgYXBwcm9hY2ggdGhlIGV2ZW50IGhvcml6b24uXG4gKiAtICoqR3Jhdml0eSBJbnRlcmFjdGlvbjoqKiBIb3ZlcmVkIGJ1dHRvbnMgYmVjb21lIGxvY2FsIFwiR3Jhdml0eSBXZWxsc1wiLCBwdWxsaW5nIHBhcnRpY2xlcyBvdXQgb2YgdGhlXG4gKiAgIG1haW4gc3RyZWFtIGludG8gdGVtcG9yYXJ5IG9yYml0LlxuICpcbiAqIEBjbGFzcyBQb3J0YWwuY2FudmFzLkZvb3RlckNhbnZhc1xuICogQGV4dGVuZHMgUG9ydGFsLmNhbnZhcy5CYXNlXG4gKiBAc2luZ2xldG9uXG4gKi9cbmNsYXNzIEZvb3RlckNhbnZhcyBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb2xvcnMgPSB7XG4gICAgICAgIGRhcms6IHtcbiAgICAgICAgICAgIGNvcmUgIDogJyNGRkZGRkYnLFxuICAgICAgICAgICAgaW5uZXIgOiAnIzAwQkZGRicsIC8vIEN5YW5cbiAgICAgICAgICAgIG91dGVyIDogJyMzRTYzREQnLCAvLyBOZW8gQmx1ZVxuICAgICAgICAgICAgdm9pZCAgOiAncmdiYSgwLDAsMCwwKSdcbiAgICAgICAgfSxcbiAgICAgICAgbGlnaHQ6IHtcbiAgICAgICAgICAgIGNvcmUgIDogJyMzRTYzREQnLCAvLyBOZW8gQmx1ZVxuICAgICAgICAgICAgaW5uZXIgOiAnIzUzNkRGRScsIC8vIEluZGlnb1xuICAgICAgICAgICAgb3V0ZXIgOiAnIzhCQTZGRicsIC8vIExpZ2h0IEJsdWVcbiAgICAgICAgICAgIHZvaWQgIDogJ3JnYmEoMjU1LDI1NSwyNTUsMCknXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J1BvcnRhbC5jYW52YXMuRm9vdGVyQ2FudmFzJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdQb3J0YWwuY2FudmFzLkZvb3RlckNhbnZhcycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdGUgbWV0aG9kIGFjY2Vzc1xuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHJlbW90ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdGU6IHtcbiAgICAgICAgICAgIGFwcDogW1xuICAgICAgICAgICAgICAgICd1cGRhdGVBY3RpdmVJZCcsXG4gICAgICAgICAgICAgICAgJ3VwZGF0ZUhvdmVySWQnLFxuICAgICAgICAgICAgICAgICd1cGRhdGVOYXZSZWN0cydcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZXRvbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZXRvbjogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnRpY2xlIEJ1ZmZlclxuICAgICAqIEBtZW1iZXIge0Zsb2F0MzJBcnJheXxudWxsfSBidWZmZXI9bnVsbFxuICAgICAqL1xuICAgIGJ1ZmZlciA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gaG92ZXJJZD1udWxsXG4gICAgICovXG4gICAgaG92ZXJJZCA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gbmF2UmVjdHM9W11cbiAgICAgKi9cbiAgICBuYXZSZWN0cyA9IFtdXG4gICAgLyoqXG4gICAgICogVHJhbnNpZW50IGdyYXZpdHkgbXVsdGlwbGllciBmb3Igc25hcHB5IGludGVyYWN0aW9ucy5cbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGdyYXZpdHlCb29zdD0xXG4gICAgICovXG4gICAgZ3Jhdml0eUJvb3N0ID0gMVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBncmFwaCBzdGF0ZS5cbiAgICAgKi9cbiAgICBjbGVhckdyYXBoKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuICAgICAgICBzdXBlci5jbGVhckdyYXBoKCk7XG4gICAgICAgIG1lLmJ1ZmZlciAgICAgICA9IG51bGw7XG4gICAgICAgIG1lLmhvdmVySWQgICAgICA9IG51bGw7XG4gICAgICAgIG1lLm5hdlJlY3RzICAgICA9IFtdO1xuICAgICAgICBtZS5ncmF2aXR5Qm9vc3QgPSAxXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIGdyaWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqL1xuICAgIG9uR3JhcGhNb3VudGVkKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5pbml0UGFydGljbGVzKHdpZHRoLCBoZWlnaHQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgcGFydGljbGUgYnVmZmVyLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgKi9cbiAgICBpbml0UGFydGljbGVzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIGNvdW50ID0gUEFSVElDTEVfQ09VTlQ7XG5cbiAgICAgICAgbWUuYnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShjb3VudCAqIFNUUklERSk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBtZS5yZXNldFBhcnRpY2xlKGksIHdpZHRoLCBoZWlnaHQsIHRydWUpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgYSBwYXJ0aWNsZSB0byB0aGUgb3V0ZXIgcmltLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpIEluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHcgV2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaCBIZWlnaHRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJhbmRvbVJhZCBSYW5kb20gcmFkaXVzIChmb3IgaW5pdGlhbCBmaWxsKVxuICAgICAqL1xuICAgIHJlc2V0UGFydGljbGUoaSwgdywgaCwgcmFuZG9tUmFkPWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBpZHggPSBpICogU1RSSURFLFxuICAgICAgICAgICAgbWF4UiA9IE1hdGgubWF4KHcsIGgpICogMC43O1xuXG4gICAgICAgIG1lLmJ1ZmZlcltpZHggKyAyXSA9IE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJICogMjsgLy8gQW5nbGVcbiAgICAgICAgbWUuYnVmZmVyW2lkeCArIDNdID0gcmFuZG9tUmFkID8gTWF0aC5yYW5kb20oKSAqIG1heFIgOiBtYXhSOyAvLyBSYWRpdXNcbiAgICAgICAgbWUuYnVmZmVyW2lkeCArIDRdID0gMC41ICsgTWF0aC5yYW5kb20oKSAqIDEuNTsgLy8gQmFzZSBTcGVlZFxuICAgICAgICBtZS5idWZmZXJbaWR4ICsgNV0gPSBNYXRoLnJhbmRvbSgpICogMiArIDAuNTsgLy8gU2l6ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1haW4gcmVuZGVyIGxvb3AuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUuY2FuUmVuZGVyKSByZXR1cm47XG5cbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIGN0eCAgICA9IG1lLmNvbnRleHQsXG4gICAgICAgICAgICB3aWR0aCAgPSBtZS5jYW52YXNTaXplPy53aWR0aCAgfHwgMTAwLFxuICAgICAgICAgICAgaGVpZ2h0ID0gbWUuY2FudmFzU2l6ZT8uaGVpZ2h0IHx8IDUwLFxuICAgICAgICAgICAgYnVmZmVyID0gbWUuYnVmZmVyLFxuICAgICAgICAgICAgY291bnQgID0gUEFSVElDTEVfQ09VTlQsXG4gICAgICAgICAgICBjb2xvcnMgPSBtZS5jb25zdHJ1Y3Rvci5jb2xvcnNbbWUudGhlbWVdO1xuXG4gICAgICAgIC8vIEF1dG8tcmVpbml0XG4gICAgICAgIGlmICghYnVmZmVyKSB7XG4gICAgICAgICAgICBtZS5pbml0UGFydGljbGVzKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWNheSBCb29zdFxuICAgICAgICBpZiAobWUuZ3Jhdml0eUJvb3N0ID4gMSkge1xuICAgICAgICAgICAgbWUuZ3Jhdml0eUJvb3N0ICo9IDAuOTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIGN4ID0gd2lkdGggLyAyLFxuICAgICAgICAgICAgY3kgPSBoZWlnaHQgKiAwLjg7IC8vIENlbnRlciBsb3dcblxuICAgICAgICAvLyAxLiBEcmF3IFwiVGhlIENvcmVcIiAoR2xvdylcbiAgICAgICAgLy8gR2xvYmFsIEVuZ2luZSBSZXY6IFB1bHNlIHRoZSBjb3JlIHJhZGl1cyBiYXNlZCBvbiBncmF2aXR5Qm9vc3RcbiAgICAgICAgbGV0IGNvcmVSYWRpdXMgPSAyMDAgKiAoMSArIChtZS5ncmF2aXR5Qm9vc3QgLSAxKSAqIDAuMSk7XG4gICAgICAgIGxldCBnID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KGN4LCBjeSwgMCwgY3gsIGN5LCBjb3JlUmFkaXVzKTtcbiAgICAgICAgZy5hZGRDb2xvclN0b3AoMCwgY29sb3JzLmlubmVyKTtcbiAgICAgICAgZy5hZGRDb2xvclN0b3AoMSwgY29sb3JzLnZvaWQpO1xuXG4gICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnbGlnaHRlcic7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBnO1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjI7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LmFyYyhjeCwgY3ksIGNvcmVSYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcblxuICAgICAgICAvLyAyLiBJZGVudGlmeSBBdHRyYWN0b3JcbiAgICAgICAgbGV0IGF0dHJhY3RvciA9IG51bGw7XG4gICAgICAgIGlmIChtZS5ob3ZlcklkICYmIG1lLm5hdlJlY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIEZpbmQgcmVjdFxuICAgICAgICAgICAgZm9yIChjb25zdCByIG9mIG1lLm5hdlJlY3RzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHIuaWQgPT09IG1lLmhvdmVySWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cmFjdG9yID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogci54ICsgci53aWR0aCAvIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiByLnkgKyByLmhlaWdodCAvIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICByOiBNYXRoLm1heChyLndpZHRoLCByLmhlaWdodCkgLyAyXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDMuIERyYXcgUGFydGljbGVzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkeCAgID0gaSAqIFNUUklERSxcbiAgICAgICAgICAgICAgICBhbmdsZSA9IGJ1ZmZlcltpZHggKyAyXSxcbiAgICAgICAgICAgICAgICByYWQgICA9IGJ1ZmZlcltpZHggKyAzXSxcbiAgICAgICAgICAgICAgICBzcGQgICA9IGJ1ZmZlcltpZHggKyA0XSxcbiAgICAgICAgICAgICAgICBzaXplICA9IGJ1ZmZlcltpZHggKyA1XTtcblxuICAgICAgICAgICAgLy8gLS0tIFBIWVNJQ1MgLS0tXG5cbiAgICAgICAgICAgIC8vIEJhc2UgU3RhdGU6IFBvbGFyIC0+IENhcnRlc2lhblxuICAgICAgICAgICAgbGV0IHggPSBjeCArIE1hdGguY29zKGFuZ2xlKSAqIHJhZDtcbiAgICAgICAgICAgIGxldCB5ID0gY3kgKyBNYXRoLnNpbihhbmdsZSkgKiAocmFkICogMC40KTtcblxuICAgICAgICAgICAgbGV0IGlzQ2FwdHVyZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gR1JBVklUWSBJTlRFUkFDVElPTlxuICAgICAgICAgICAgaWYgKGF0dHJhY3Rvcikge1xuICAgICAgICAgICAgICAgIGxldCBkeCA9IGF0dHJhY3Rvci54IC0geCxcbiAgICAgICAgICAgICAgICAgICAgZHkgPSBhdHRyYWN0b3IueSAtIHksXG4gICAgICAgICAgICAgICAgICAgIGRpc3QgPSBNYXRoLnNxcnQoZHgqZHggKyBkeSpkeSk7XG5cbiAgICAgICAgICAgICAgICAvLyBCb29zdGVkIGNhcHR1cmUgcmFkaXVzXG4gICAgICAgICAgICAgICAgY29uc3QgY2FwdHVyZVJhZGl1cyA9IDE1MCAqICgxICsgKG1lLmdyYXZpdHlCb29zdCAtIDEpICogMC41KTtcblxuICAgICAgICAgICAgICAgIC8vIFBhcnRpYWwgQ2FwdHVyZTogQ2FwdHVyZSAzMyUgb2YgcGFydGljbGVzIChpbmRpY2VzIGRpdmlzaWJsZSBieSAzKVxuICAgICAgICAgICAgICAgIC8vIEJhbGFuY2UgYmV0d2VlbiBtYWludGFpbmluZyBjb3JlIHN0cnVjdHVyZSBhbmQgY3JlYXRpbmcgYSB2aXNpYmxlIHN3YXJtLlxuICAgICAgICAgICAgICAgIGlmIChkaXN0IDwgY2FwdHVyZVJhZGl1cyAmJiBpICUgMyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpc0NhcHR1cmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSB0b3dhcmRzIGJ1dHRvbiBjZW50ZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gQm9vc3RlZCBwdWxsIGZvcmNlXG4gICAgICAgICAgICAgICAgICAgIGxldCBmb3JjZSA9IChjYXB0dXJlUmFkaXVzIC0gZGlzdCkgLyBjYXB0dXJlUmFkaXVzO1xuICAgICAgICAgICAgICAgICAgICBmb3JjZSAqPSBtZS5ncmF2aXR5Qm9vc3Q7IC8vIEFwcGx5IGJvb3N0IHRvIHZlbG9jaXR5XG5cbiAgICAgICAgICAgICAgICAgICAgeCArPSBkeCAqIGZvcmNlICogMC4xO1xuICAgICAgICAgICAgICAgICAgICB5ICs9IGR5ICogZm9yY2UgKiAwLjE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWlzQ2FwdHVyZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3JtYWwgU3BpcmFsIFBoeXNpY3NcbiAgICAgICAgICAgICAgICBsZXQgdmVsb2NpdHkgPSBzcGQgKiAoMSArICg1MDAgLyAocmFkICsgMTApKSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gR2xvYmFsIEVuZ2luZSBSZXY6IEFjY2VsZXJhdGUgc3BpcmFsIGJhc2VkIG9uIGdyYXZpdHlCb29zdFxuICAgICAgICAgICAgICAgIHZlbG9jaXR5ICo9ICgxICsgKG1lLmdyYXZpdHlCb29zdCAtIDEpICogMC4yKTtcblxuICAgICAgICAgICAgICAgIHJhZCAgIC09IHZlbG9jaXR5ICogMC41O1xuICAgICAgICAgICAgICAgIGFuZ2xlICs9IHZlbG9jaXR5ICogMC4wMDU7XG5cbiAgICAgICAgICAgICAgICAvLyBSZXNldFxuICAgICAgICAgICAgICAgIGlmIChyYWQgPCAxMCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWF4UiA9IE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpICogMC43O1xuICAgICAgICAgICAgICAgICAgICByYWQgPSBtYXhSO1xuICAgICAgICAgICAgICAgICAgICBhbmdsZSA9IE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJICogMjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgQ2FydGVzaWFuIGZyb20gbmV3IFBvbGFyXG4gICAgICAgICAgICAgICAgeCA9IGN4ICsgTWF0aC5jb3MoYW5nbGUpICogcmFkO1xuICAgICAgICAgICAgICAgIHkgPSBjeSArIE1hdGguc2luKGFuZ2xlKSAqIChyYWQgKiAwLjQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTYXZlIFBvbGFyIFN0YXRlXG4gICAgICAgICAgICBidWZmZXJbaWR4ICsgMl0gPSBhbmdsZTtcbiAgICAgICAgICAgIGJ1ZmZlcltpZHggKyAzXSA9IHJhZDtcblxuICAgICAgICAgICAgLy8gLS0tIERSQVcgLS0tXG4gICAgICAgICAgICBsZXQgZGlzdFJhdGlvID0gcmFkIC8gKE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpICogMC42KTtcbiAgICAgICAgICAgIGxldCBhbHBoYSA9IDEgLSBkaXN0UmF0aW87XG5cbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIC8vIFVzZSAnaW5uZXInIChDeWFuL0luZGlnbykgZm9yIGNhcHR1cmVkIHBhcnRpY2xlcyBpbnN0ZWFkIG9mICdjb3JlJyAoV2hpdGUpXG4gICAgICAgICAgICBpZiAoaXNDYXB0dXJlZCkge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcnMuaW5uZXI7XG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC42O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZGlzdFJhdGlvIDwgMC4zID8gY29sb3JzLmNvcmUgOiBjb2xvcnMub3V0ZXI7XG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gYWxwaGE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyYWQgPCAxMDAgJiYgIWlzQ2FwdHVyZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBTcGFnaGV0dGlmaWNhdGlvblxuICAgICAgICAgICAgICAgIGxldCB0YWlsWCA9IGN4ICsgTWF0aC5jb3MoYW5nbGUgLSAwLjIpICogKHJhZCArIDIwKTtcbiAgICAgICAgICAgICAgICBsZXQgdGFpbFkgPSBjeSArIE1hdGguc2luKGFuZ2xlIC0gMC4yKSAqICgocmFkICsgMjApICogMC40KTtcblxuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9ycy5jb3JlO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBzaXplO1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh0YWlsWCwgdGFpbFkpO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gc2l6ZSBpbmNyZWFzZSBmb3IgY2FwdHVyZWQgcGFydGljbGVzXG4gICAgICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCBzaXplLCAwLCBNYXRoLlBJICogMik7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnc291cmNlLW92ZXInO1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuXG4gICAgICAgIGlmIChoYXNSYWYpIHtcbiAgICAgICAgICAgIG1lLmFuaW1hdGlvbklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKG1lLnJlbmRlckxvb3ApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5hbmltYXRpb25JZCA9IHNldFRpbWVvdXQobWUucmVuZGVyTG9vcCwgMTAwMCAvIDYwKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICB1cGRhdGVBY3RpdmVJZChkYXRhKSB7fVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2RhdGEuaWRdXG4gICAgICovXG4gICAgdXBkYXRlSG92ZXJJZChkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG4gICAgICAgIGlmIChtZS5ob3ZlcklkICE9PSBkYXRhPy5pZCkge1xuICAgICAgICAgICAgbWUuZ3Jhdml0eUJvb3N0ID0gNTsgLy8gVHJpZ2dlciBCb29zdCBvbiBjaGFuZ2VcbiAgICAgICAgfVxuICAgICAgICBtZS5ob3ZlcklkID0gZGF0YT8uaWQgfHwgbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5yZWN0c1xuICAgICAqL1xuICAgIHVwZGF0ZU5hdlJlY3RzKGRhdGEpIHtcbiAgICAgICAgbGV0IHJlY3RzID0gZGF0YT8ucmVjdHM7XG4gICAgICAgIHRoaXMubmF2UmVjdHMgPSBBcnJheS5pc0FycmF5KHJlY3RzKSA/IHJlY3RzIDogW11cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZS1pbml0IG9uIHJlc2l6ZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAgICovXG4gICAgdXBkYXRlUmVzb3VyY2VzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5pbml0UGFydGljbGVzKHdpZHRoLCBoZWlnaHQpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhGb290ZXJDYW52YXMpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=