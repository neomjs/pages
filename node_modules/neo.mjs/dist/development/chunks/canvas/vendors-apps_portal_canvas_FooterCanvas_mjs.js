export const __webpack_esm_id__ = "vendors-apps_portal_canvas_FooterCanvas_mjs";
export const __webpack_esm_ids__ = ["vendors-apps_portal_canvas_FooterCanvas_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./apps/portal/canvas/FooterCanvas.mjs"
/*!*********************************************!*\
  !*** ./apps/portal/canvas/FooterCanvas.mjs ***!
  \*********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_canvas_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/canvas/Base.mjs */ "./src/canvas/Base.mjs");


const
    hasRaf = typeof requestAnimationFrame === 'function',
    PARTICLE_COUNT = 800, // High density for the "Well"
    STRIDE         = 6;   // x, y, angle, radius, speed, size

/**
 * @summary SharedWorker renderer for the Footer "Event Horizon" overlay with Gravity Interaction.
 *
 * Implements the **"Event Horizon"** visual theme: A radial gravity well representing the core engine.
 *
 * **Visual Metaphor:**
 * - **The Source:** A central singularity that draws everything in.
 * - **Data Stream:** Particles spiral inward, accelerating as they approach the event horizon.
 * - **Gravity Interaction:** Hovered buttons become local "Gravity Wells", pulling particles out of the
 *   main stream into temporary orbit.
 *
 * @class Portal.canvas.FooterCanvas
 * @extends Portal.canvas.Base
 * @singleton
 */
class FooterCanvas extends _src_canvas_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static colors = {
        dark: {
            core  : '#FFFFFF',
            inner : '#00BFFF', // Cyan
            outer : '#3E63DD', // Neo Blue
            void  : 'rgba(0,0,0,0)'
        },
        light: {
            core  : '#3E63DD', // Neo Blue
            inner : '#536DFE', // Indigo
            outer : '#8BA6FF', // Light Blue
            void  : 'rgba(255,255,255,0)'
        }
    }

    static config = {
        /**
         * @member {String} className='Portal.canvas.FooterCanvas'
         * @protected
         */
        className: 'Portal.canvas.FooterCanvas',
        /**
         * Remote method access
         * @member {Object} remote
         * @protected
         */
        remote: {
            app: [
                'updateActiveId',
                'updateHoverId',
                'updateNavRects'
            ]
        },
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * Particle Buffer
     * @member {Float32Array|null} buffer=null
     */
    buffer = null
    /**
     * @member {String|null} hoverId=null
     */
    hoverId = null
    /**
     * @member {Object[]} navRects=[]
     */
    navRects = []
    /**
     * Transient gravity multiplier for snappy interactions.
     * @member {Number} gravityBoost=1
     */
    gravityBoost = 1

    /**
     * Clears the graph state.
     */
    clearGraph() {
        let me = this;
        super.clearGraph();
        me.buffer       = null;
        me.hoverId      = null;
        me.navRects     = [];
        me.gravityBoost = 1
    }

    /**
     * Initializes the grid.
     * @param {Number} width
     * @param {Number} height
     */
    onGraphMounted(width, height) {
        this.initParticles(width, height)
    }

    /**
     * Creates the particle buffer.
     * @param {Number} width
     * @param {Number} height
     */
    initParticles(width, height) {
        let me = this,
            count = PARTICLE_COUNT;

        me.buffer = new Float32Array(count * STRIDE);

        for (let i = 0; i < count; i++) {
            me.resetParticle(i, width, height, true)
        }
    }

    /**
     * Resets a particle to the outer rim.
     * @param {Number} i Index
     * @param {Number} w Width
     * @param {Number} h Height
     * @param {Boolean} randomRad Random radius (for initial fill)
     */
    resetParticle(i, w, h, randomRad=false) {
        let me = this,
            idx = i * STRIDE,
            maxR = Math.max(w, h) * 0.7;

        me.buffer[idx + 2] = Math.random() * Math.PI * 2; // Angle
        me.buffer[idx + 3] = randomRad ? Math.random() * maxR : maxR; // Radius
        me.buffer[idx + 4] = 0.5 + Math.random() * 1.5; // Base Speed
        me.buffer[idx + 5] = Math.random() * 2 + 0.5; // Size
    }

    /**
     * Main render loop.
     */
    render() {
        let me = this;

        if (!me.canRender) return;

        const
            ctx    = me.context,
            width  = me.canvasSize?.width  || 100,
            height = me.canvasSize?.height || 50,
            buffer = me.buffer,
            count  = PARTICLE_COUNT,
            colors = me.constructor.colors[me.theme];

        // Auto-reinit
        if (!buffer) {
            me.initParticles(width, height);
            return
        }

        // Decay Boost
        if (me.gravityBoost > 1) {
            me.gravityBoost *= 0.9;
        }

        ctx.clearRect(0, 0, width, height);

        const
            cx = width / 2,
            cy = height * 0.8; // Center low

        // 1. Draw "The Core" (Glow)
        // Global Engine Rev: Pulse the core radius based on gravityBoost
        let coreRadius = 200 * (1 + (me.gravityBoost - 1) * 0.1);
        let g = ctx.createRadialGradient(cx, cy, 0, cx, cy, coreRadius);
        g.addColorStop(0, colors.inner);
        g.addColorStop(1, colors.void);

        ctx.globalCompositeOperation = 'lighter';
        ctx.fillStyle = g;
        ctx.globalAlpha = 0.2;
        ctx.beginPath();
        ctx.arc(cx, cy, coreRadius, 0, Math.PI * 2);
        ctx.fill();

        // 2. Identify Attractor
        let attractor = null;
        if (me.hoverId && me.navRects.length > 0) {
            // Find rect
            for (const r of me.navRects) {
                if (r.id === me.hoverId) {
                    attractor = {
                        x: r.x + r.width / 2,
                        y: r.y + r.height / 2,
                        r: Math.max(r.width, r.height) / 2
                    };
                    break;
                }
            }
        }

        // 3. Draw Particles
        for (let i = 0; i < count; i++) {
            let idx   = i * STRIDE,
                angle = buffer[idx + 2],
                rad   = buffer[idx + 3],
                spd   = buffer[idx + 4],
                size  = buffer[idx + 5];

            // --- PHYSICS ---

            // Base State: Polar -> Cartesian
            let x = cx + Math.cos(angle) * rad;
            let y = cy + Math.sin(angle) * (rad * 0.4);

            let isCaptured = false;

            // GRAVITY INTERACTION
            if (attractor) {
                let dx = attractor.x - x,
                    dy = attractor.y - y,
                    dist = Math.sqrt(dx*dx + dy*dy);

                // Boosted capture radius
                const captureRadius = 150 * (1 + (me.gravityBoost - 1) * 0.5);

                // Partial Capture: Capture 33% of particles (indices divisible by 3)
                // Balance between maintaining core structure and creating a visible swarm.
                if (dist < captureRadius && i % 3 === 0) {
                    isCaptured = true;
                    // Move towards button center
                    // Boosted pull force
                    let force = (captureRadius - dist) / captureRadius;
                    force *= me.gravityBoost; // Apply boost to velocity

                    x += dx * force * 0.1;
                    y += dy * force * 0.1;
                }
            }

            if (!isCaptured) {
                // Normal Spiral Physics
                let velocity = spd * (1 + (500 / (rad + 10)));

                // Global Engine Rev: Accelerate spiral based on gravityBoost
                velocity *= (1 + (me.gravityBoost - 1) * 0.2);

                rad   -= velocity * 0.5;
                angle += velocity * 0.005;

                // Reset
                if (rad < 10) {
                    let maxR = Math.max(width, height) * 0.7;
                    rad = maxR;
                    angle = Math.random() * Math.PI * 2;
                }

                // Update Cartesian from new Polar
                x = cx + Math.cos(angle) * rad;
                y = cy + Math.sin(angle) * (rad * 0.4);
            }

            // Save Polar State
            buffer[idx + 2] = angle;
            buffer[idx + 3] = rad;

            // --- DRAW ---
            let distRatio = rad / (Math.max(width, height) * 0.6);
            let alpha = 1 - distRatio;

            ctx.beginPath();
            // Use 'inner' (Cyan/Indigo) for captured particles instead of 'core' (White)
            if (isCaptured) {
                ctx.fillStyle = colors.inner;
                ctx.globalAlpha = 0.6;
            } else {
                ctx.fillStyle = distRatio < 0.3 ? colors.core : colors.outer;
                ctx.globalAlpha = alpha;
            }

            if (rad < 100 && !isCaptured) {
                // Spaghettification
                let tailX = cx + Math.cos(angle - 0.2) * (rad + 20);
                let tailY = cy + Math.sin(angle - 0.2) * ((rad + 20) * 0.4);

                ctx.strokeStyle = colors.core;
                ctx.lineWidth = size;
                ctx.moveTo(x, y);
                ctx.lineTo(tailX, tailY);
                ctx.stroke();
            } else {
                // No size increase for captured particles
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 1;

        if (hasRaf) {
            me.animationId = requestAnimationFrame(me.renderLoop)
        } else {
            me.animationId = setTimeout(me.renderLoop, 1000 / 60)
        }
    }

    /**
     * @param {Object} data
     */
    updateActiveId(data) {}

    /**
     * @param {Object} data
     * @param {String} [data.id]
     */
    updateHoverId(data) {
        let me = this;
        if (me.hoverId !== data?.id) {
            me.gravityBoost = 5; // Trigger Boost on change
        }
        me.hoverId = data?.id || null
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.rects
     */
    updateNavRects(data) {
        let rects = data?.rects;
        this.navRects = Array.isArray(rects) ? rects : []
    }

    /**
     * Re-init on resize.
     * @param {Number} width
     * @param {Number} height
     */
    updateResources(width, height) {
        this.initParticles(width, height)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(FooterCanvas));


/***/ },

/***/ "./src/canvas/Base.mjs"
/*!*****************************!*\
  !*** ./src/canvas/Base.mjs ***!
  \*****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @summary Abstract base class for Canvas Renderers.
 *
 * This class serves as the foundation for the specialized canvas visualizations (Header, Home, Services, Ticket)
 * that run within the **Neo.mjs Canvas SharedWorker**.
 *
 * It creates helper singletons that manage their own `OffscreenCanvas` instances, providing a standardized
 * architecture for:
 * - **Lifecycle Management:** Initialization (`initGraph`), destruction (`clearGraph`), and resource cleanup.
 * - **Render Loop Control:** Unified `render` loop with pause/resume capabilities and frame scheduling.
 * - **Context Management:** Robust handling of `OffscreenCanvas` transfer and context acquisition via `waitForCanvas`.
 * - **Shared State:** Common state management for mouse interaction, time, and theming.
 *
 * These renderers operate off the main thread to ensure high-performance, 60fps animations without
 * blocking the UI.
 *
 * @class Neo.canvas.Base
 * @extends Neo.core.Base
 */
class Base extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.canvas.Base'
         * @protected
         */
        className: 'Neo.canvas.Base',
        /**
         * Remote method access
         * @member {Object} remote
         * @protected
         */
        remote: {
            app: [
                'clearGraph',
                'initGraph',
                'pause',
                'resume',
                'setTheme',
                'updateMouseState',
                'updateSize'
            ]
        },
        /**
         * The active color theme ('light' or 'dark').
         * @member {String} theme_='light'
         * @reactive
         */
        theme_: 'light'
    }

    /**
     * @member {Number|null} animationId=null
     */
    animationId = null
    /**
     * @member {String|null} canvasId=null
     */
    canvasId = null
    /**
     * @member {Object|null} canvasSize=null
     */
    canvasSize = null
    /**
     * @member {OffscreenCanvasRenderingContext2D|null} context=null
     */
    context = null
    /**
     * Cache for reusable gradients to prevent GC.
     * @member {Object} gradients={}
     */
    gradients = {}
    /**
     * Flag to pause the render loop.
     * @member {Boolean} isPaused=false
     */
    isPaused = false
    /**
     * Tracked mouse position for interactive physics.
     * Initialize off-screen to prevent startup jitters.
     * @member {Object} mouse={x: -1000, y: -1000}
     */
    mouse = {x: -1000, y: -1000}
    /**
     * Global simulation time.
     * @member {Number} time=0
     */
    time = 0

    /**
     * @member {Function} renderLoop=this.render.bind(this)
     */
    renderLoop = this.render.bind(this)

    /**
     * Triggered after the `theme` config is changed.
     * Updates the resource cache (gradients, colors) to reflect the new theme immediately.
     * @param {String} value
     * @param {String} oldValue
     */
    afterSetTheme(value, oldValue) {
        if (value && this.canvasSize) {
            this.updateResources?.(this.canvasSize.width, this.canvasSize.height)
        }
    }

    /**
     * Checks if the canvas is ready to render.
     * Returns true only if the context exists and the simulation is not paused.
     * Subclasses should call this at the start of their `render` loop.
     * @returns {Boolean}
     */
    get canRender() {
        let me = this;
        return !!(me.context && !me.isPaused)
    }

    /**
     * Clears the graph state and stops the render loop.
     * Use this to cleanup resources when the component is destroyed or unmounted.
     */
    clearGraph() {
        let me = this;
        me.context     = null;
        me.canvasId    = null;
        me.canvasSize  = null;
        me.animationId = null;
        me.isPaused    = false;
        me.gradients   = {};
        me.mouse       = {x: -1000, y: -1000};
        me.time        = 0
    }

    /**
     * Initializes the canvas context.
     * Starts the polling mechanism to wait for the OffscreenCanvas transfer from the Main Thread.
     * @param {Object} opts
     * @param {String} opts.canvasId
     * @param {String} opts.windowId
     */
    initGraph({canvasId, windowId}) {
        let me        = this,
            hasChange = me.canvasId !== canvasId;

        me.canvasId = canvasId;

        me.waitForCanvas(canvasId, windowId, hasChange)
    }

    /**
     * Hook for subclasses to handle mouse clicks.
     * Called by `updateMouseState` when a click event is received.
     * @param {Object} data
     */
    onMouseClick(data) {}

    /**
     * Pauses the simulation.
     * The render loop will exit early while `isPaused` is true.
     */
    pause() {
        this.isPaused = true
    }

    /**
     * Abstract render method.
     * Subclasses must implement this method to draw the frame.
     */
    render() {}

    /**
     * Resumes the simulation.
     * If the simulation was paused, this restarts the render loop.
     */
    resume() {
        let me = this;

        if (me.isPaused) {
            me.isPaused = false;
            me.renderLoop()
        }
    }

    /**
     * Exposed method for Remote Access to trigger the reactive config setter.
     * @param {String} value
     */
    setTheme(value) {
        this.theme = value
    }

    /**
     * Updates the local mouse state from main thread events.
     * Delegates click events to `onMouseClick`.
     * @param {Object} data
     * @param {Boolean} [data.click]
     * @param {Boolean} [data.leave]
     * @param {Number} [data.x]
     * @param {Number} [data.y]
     */
    updateMouseState(data) {
        let me = this;

        if (data.leave) {
            me.mouse.x = -1000;
            me.mouse.y = -1000
        } else {
            if (data.x !== undefined) me.mouse.x = data.x;
            if (data.y !== undefined) me.mouse.y = data.y;

            if (data.click) {
                me.onMouseClick(data)
            }
        }
    }

    /**
     * Updates the canvas size and resizes the internal context.
     * Triggers `updateResources` hook to allow subclasses to regenerate buffers/gradients.
     * @param {Object} size
     * @param {Number} size.height
     * @param {Number} size.width
     */
    updateSize(size) {
        let me = this;

        me.canvasSize = size;

        if (me.context) {
            me.context.canvas.width  = size.width;
            me.context.canvas.height = size.height;
            // Calls the hook to re-generate resources if implemented
            me.updateResources?.(size.width, size.height)
        }
    }

    /**
     * Polls for the OffscreenCanvas until it is available in the Worker's `canvasWindowMap`.
     * Once found, it initializes the context and starts the render loop.
     * @param {String} canvasId
     * @param {String} windowId
     * @param {Boolean} hasChange
     * @protected
     */
    waitForCanvas(canvasId, windowId, hasChange) {
        let me     = this,
            canvas = Neo.currentWorker.canvasWindowMap[canvasId]?.[windowId];

        if (canvas) {
            me.context = canvas.getContext('2d');

            // Standardize size update
            me.updateSize({width: canvas.width, height: canvas.height});

            // Optional hook for subclasses
            me.onGraphMounted?.(canvas.width, canvas.height);

            if (hasChange && !me.animationId) {
                me.renderLoop()
            }
        } else {
            setTimeout(me.waitForCanvas.bind(me, canvasId, windowId, hasChange), 50)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Base));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2NhbnZhcy92ZW5kb3JzLWFwcHNfcG9ydGFsX2NhbnZhc19Gb290ZXJDYW52YXNfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNERBQUk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFl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QUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQiwyQ0FBMkM7O0FBRXRFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLG9CQUFvQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvcG9ydGFsL2NhbnZhcy9Gb290ZXJDYW52YXMubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY2FudmFzL0Jhc2UubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCYXNlIGZyb20gJy4uLy4uLy4uL3NyYy9jYW52YXMvQmFzZS5tanMnO1xuXG5jb25zdFxuICAgIGhhc1JhZiA9IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09ICdmdW5jdGlvbicsXG4gICAgUEFSVElDTEVfQ09VTlQgPSA4MDAsIC8vIEhpZ2ggZGVuc2l0eSBmb3IgdGhlIFwiV2VsbFwiXG4gICAgU1RSSURFICAgICAgICAgPSA2OyAgIC8vIHgsIHksIGFuZ2xlLCByYWRpdXMsIHNwZWVkLCBzaXplXG5cbi8qKlxuICogQHN1bW1hcnkgU2hhcmVkV29ya2VyIHJlbmRlcmVyIGZvciB0aGUgRm9vdGVyIFwiRXZlbnQgSG9yaXpvblwiIG92ZXJsYXkgd2l0aCBHcmF2aXR5IEludGVyYWN0aW9uLlxuICpcbiAqIEltcGxlbWVudHMgdGhlICoqXCJFdmVudCBIb3Jpem9uXCIqKiB2aXN1YWwgdGhlbWU6IEEgcmFkaWFsIGdyYXZpdHkgd2VsbCByZXByZXNlbnRpbmcgdGhlIGNvcmUgZW5naW5lLlxuICpcbiAqICoqVmlzdWFsIE1ldGFwaG9yOioqXG4gKiAtICoqVGhlIFNvdXJjZToqKiBBIGNlbnRyYWwgc2luZ3VsYXJpdHkgdGhhdCBkcmF3cyBldmVyeXRoaW5nIGluLlxuICogLSAqKkRhdGEgU3RyZWFtOioqIFBhcnRpY2xlcyBzcGlyYWwgaW53YXJkLCBhY2NlbGVyYXRpbmcgYXMgdGhleSBhcHByb2FjaCB0aGUgZXZlbnQgaG9yaXpvbi5cbiAqIC0gKipHcmF2aXR5IEludGVyYWN0aW9uOioqIEhvdmVyZWQgYnV0dG9ucyBiZWNvbWUgbG9jYWwgXCJHcmF2aXR5IFdlbGxzXCIsIHB1bGxpbmcgcGFydGljbGVzIG91dCBvZiB0aGVcbiAqICAgbWFpbiBzdHJlYW0gaW50byB0ZW1wb3Jhcnkgb3JiaXQuXG4gKlxuICogQGNsYXNzIFBvcnRhbC5jYW52YXMuRm9vdGVyQ2FudmFzXG4gKiBAZXh0ZW5kcyBQb3J0YWwuY2FudmFzLkJhc2VcbiAqIEBzaW5nbGV0b25cbiAqL1xuY2xhc3MgRm9vdGVyQ2FudmFzIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbG9ycyA9IHtcbiAgICAgICAgZGFyazoge1xuICAgICAgICAgICAgY29yZSAgOiAnI0ZGRkZGRicsXG4gICAgICAgICAgICBpbm5lciA6ICcjMDBCRkZGJywgLy8gQ3lhblxuICAgICAgICAgICAgb3V0ZXIgOiAnIzNFNjNERCcsIC8vIE5lbyBCbHVlXG4gICAgICAgICAgICB2b2lkICA6ICdyZ2JhKDAsMCwwLDApJ1xuICAgICAgICB9LFxuICAgICAgICBsaWdodDoge1xuICAgICAgICAgICAgY29yZSAgOiAnIzNFNjNERCcsIC8vIE5lbyBCbHVlXG4gICAgICAgICAgICBpbm5lciA6ICcjNTM2REZFJywgLy8gSW5kaWdvXG4gICAgICAgICAgICBvdXRlciA6ICcjOEJBNkZGJywgLy8gTGlnaHQgQmx1ZVxuICAgICAgICAgICAgdm9pZCAgOiAncmdiYSgyNTUsMjU1LDI1NSwwKSdcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nUG9ydGFsLmNhbnZhcy5Gb290ZXJDYW52YXMnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ1BvcnRhbC5jYW52YXMuRm9vdGVyQ2FudmFzJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW90ZSBtZXRob2QgYWNjZXNzXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gcmVtb3RlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHJlbW90ZToge1xuICAgICAgICAgICAgYXBwOiBbXG4gICAgICAgICAgICAgICAgJ3VwZGF0ZUFjdGl2ZUlkJyxcbiAgICAgICAgICAgICAgICAndXBkYXRlSG92ZXJJZCcsXG4gICAgICAgICAgICAgICAgJ3VwZGF0ZU5hdlJlY3RzJ1xuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2luZ2xldG9uPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2luZ2xldG9uOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFydGljbGUgQnVmZmVyXG4gICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fG51bGx9IGJ1ZmZlcj1udWxsXG4gICAgICovXG4gICAgYnVmZmVyID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBob3ZlcklkPW51bGxcbiAgICAgKi9cbiAgICBob3ZlcklkID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdFtdfSBuYXZSZWN0cz1bXVxuICAgICAqL1xuICAgIG5hdlJlY3RzID0gW11cbiAgICAvKipcbiAgICAgKiBUcmFuc2llbnQgZ3Jhdml0eSBtdWx0aXBsaWVyIGZvciBzbmFwcHkgaW50ZXJhY3Rpb25zLlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gZ3Jhdml0eUJvb3N0PTFcbiAgICAgKi9cbiAgICBncmF2aXR5Qm9vc3QgPSAxXG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGdyYXBoIHN0YXRlLlxuICAgICAqL1xuICAgIGNsZWFyR3JhcGgoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG4gICAgICAgIHN1cGVyLmNsZWFyR3JhcGgoKTtcbiAgICAgICAgbWUuYnVmZmVyICAgICAgID0gbnVsbDtcbiAgICAgICAgbWUuaG92ZXJJZCAgICAgID0gbnVsbDtcbiAgICAgICAgbWUubmF2UmVjdHMgICAgID0gW107XG4gICAgICAgIG1lLmdyYXZpdHlCb29zdCA9IDFcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgZ3JpZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAgICovXG4gICAgb25HcmFwaE1vdW50ZWQod2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0aGlzLmluaXRQYXJ0aWNsZXMod2lkdGgsIGhlaWdodClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBwYXJ0aWNsZSBidWZmZXIuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqL1xuICAgIGluaXRQYXJ0aWNsZXMod2lkdGgsIGhlaWdodCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgY291bnQgPSBQQVJUSUNMRV9DT1VOVDtcblxuICAgICAgICBtZS5idWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KGNvdW50ICogU1RSSURFKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIG1lLnJlc2V0UGFydGljbGUoaSwgd2lkdGgsIGhlaWdodCwgdHJ1ZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyBhIHBhcnRpY2xlIHRvIHRoZSBvdXRlciByaW0uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGkgSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdyBXaWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoIEhlaWdodFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmFuZG9tUmFkIFJhbmRvbSByYWRpdXMgKGZvciBpbml0aWFsIGZpbGwpXG4gICAgICovXG4gICAgcmVzZXRQYXJ0aWNsZShpLCB3LCBoLCByYW5kb21SYWQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIGlkeCA9IGkgKiBTVFJJREUsXG4gICAgICAgICAgICBtYXhSID0gTWF0aC5tYXgodywgaCkgKiAwLjc7XG5cbiAgICAgICAgbWUuYnVmZmVyW2lkeCArIDJdID0gTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyOyAvLyBBbmdsZVxuICAgICAgICBtZS5idWZmZXJbaWR4ICsgM10gPSByYW5kb21SYWQgPyBNYXRoLnJhbmRvbSgpICogbWF4UiA6IG1heFI7IC8vIFJhZGl1c1xuICAgICAgICBtZS5idWZmZXJbaWR4ICsgNF0gPSAwLjUgKyBNYXRoLnJhbmRvbSgpICogMS41OyAvLyBCYXNlIFNwZWVkXG4gICAgICAgIG1lLmJ1ZmZlcltpZHggKyA1XSA9IE1hdGgucmFuZG9tKCkgKiAyICsgMC41OyAvLyBTaXplXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFpbiByZW5kZXIgbG9vcC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5jYW5SZW5kZXIpIHJldHVybjtcblxuICAgICAgICBjb25zdFxuICAgICAgICAgICAgY3R4ICAgID0gbWUuY29udGV4dCxcbiAgICAgICAgICAgIHdpZHRoICA9IG1lLmNhbnZhc1NpemU/LndpZHRoICB8fCAxMDAsXG4gICAgICAgICAgICBoZWlnaHQgPSBtZS5jYW52YXNTaXplPy5oZWlnaHQgfHwgNTAsXG4gICAgICAgICAgICBidWZmZXIgPSBtZS5idWZmZXIsXG4gICAgICAgICAgICBjb3VudCAgPSBQQVJUSUNMRV9DT1VOVCxcbiAgICAgICAgICAgIGNvbG9ycyA9IG1lLmNvbnN0cnVjdG9yLmNvbG9yc1ttZS50aGVtZV07XG5cbiAgICAgICAgLy8gQXV0by1yZWluaXRcbiAgICAgICAgaWYgKCFidWZmZXIpIHtcbiAgICAgICAgICAgIG1lLmluaXRQYXJ0aWNsZXMod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlY2F5IEJvb3N0XG4gICAgICAgIGlmIChtZS5ncmF2aXR5Qm9vc3QgPiAxKSB7XG4gICAgICAgICAgICBtZS5ncmF2aXR5Qm9vc3QgKj0gMC45O1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICBjb25zdFxuICAgICAgICAgICAgY3ggPSB3aWR0aCAvIDIsXG4gICAgICAgICAgICBjeSA9IGhlaWdodCAqIDAuODsgLy8gQ2VudGVyIGxvd1xuXG4gICAgICAgIC8vIDEuIERyYXcgXCJUaGUgQ29yZVwiIChHbG93KVxuICAgICAgICAvLyBHbG9iYWwgRW5naW5lIFJldjogUHVsc2UgdGhlIGNvcmUgcmFkaXVzIGJhc2VkIG9uIGdyYXZpdHlCb29zdFxuICAgICAgICBsZXQgY29yZVJhZGl1cyA9IDIwMCAqICgxICsgKG1lLmdyYXZpdHlCb29zdCAtIDEpICogMC4xKTtcbiAgICAgICAgbGV0IGcgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoY3gsIGN5LCAwLCBjeCwgY3ksIGNvcmVSYWRpdXMpO1xuICAgICAgICBnLmFkZENvbG9yU3RvcCgwLCBjb2xvcnMuaW5uZXIpO1xuICAgICAgICBnLmFkZENvbG9yU3RvcCgxLCBjb2xvcnMudm9pZCk7XG5cbiAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdsaWdodGVyJztcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGc7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuMjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguYXJjKGN4LCBjeSwgY29yZVJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgICBjdHguZmlsbCgpO1xuXG4gICAgICAgIC8vIDIuIElkZW50aWZ5IEF0dHJhY3RvclxuICAgICAgICBsZXQgYXR0cmFjdG9yID0gbnVsbDtcbiAgICAgICAgaWYgKG1lLmhvdmVySWQgJiYgbWUubmF2UmVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gRmluZCByZWN0XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHIgb2YgbWUubmF2UmVjdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoci5pZCA9PT0gbWUuaG92ZXJJZCkge1xuICAgICAgICAgICAgICAgICAgICBhdHRyYWN0b3IgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiByLnggKyByLndpZHRoIC8gMixcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHIueSArIHIuaGVpZ2h0IC8gMixcbiAgICAgICAgICAgICAgICAgICAgICAgIHI6IE1hdGgubWF4KHIud2lkdGgsIHIuaGVpZ2h0KSAvIDJcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gMy4gRHJhdyBQYXJ0aWNsZXNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaWR4ICAgPSBpICogU1RSSURFLFxuICAgICAgICAgICAgICAgIGFuZ2xlID0gYnVmZmVyW2lkeCArIDJdLFxuICAgICAgICAgICAgICAgIHJhZCAgID0gYnVmZmVyW2lkeCArIDNdLFxuICAgICAgICAgICAgICAgIHNwZCAgID0gYnVmZmVyW2lkeCArIDRdLFxuICAgICAgICAgICAgICAgIHNpemUgID0gYnVmZmVyW2lkeCArIDVdO1xuXG4gICAgICAgICAgICAvLyAtLS0gUEhZU0lDUyAtLS1cblxuICAgICAgICAgICAgLy8gQmFzZSBTdGF0ZTogUG9sYXIgLT4gQ2FydGVzaWFuXG4gICAgICAgICAgICBsZXQgeCA9IGN4ICsgTWF0aC5jb3MoYW5nbGUpICogcmFkO1xuICAgICAgICAgICAgbGV0IHkgPSBjeSArIE1hdGguc2luKGFuZ2xlKSAqIChyYWQgKiAwLjQpO1xuXG4gICAgICAgICAgICBsZXQgaXNDYXB0dXJlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBHUkFWSVRZIElOVEVSQUNUSU9OXG4gICAgICAgICAgICBpZiAoYXR0cmFjdG9yKSB7XG4gICAgICAgICAgICAgICAgbGV0IGR4ID0gYXR0cmFjdG9yLnggLSB4LFxuICAgICAgICAgICAgICAgICAgICBkeSA9IGF0dHJhY3Rvci55IC0geSxcbiAgICAgICAgICAgICAgICAgICAgZGlzdCA9IE1hdGguc3FydChkeCpkeCArIGR5KmR5KTtcblxuICAgICAgICAgICAgICAgIC8vIEJvb3N0ZWQgY2FwdHVyZSByYWRpdXNcbiAgICAgICAgICAgICAgICBjb25zdCBjYXB0dXJlUmFkaXVzID0gMTUwICogKDEgKyAobWUuZ3Jhdml0eUJvb3N0IC0gMSkgKiAwLjUpO1xuXG4gICAgICAgICAgICAgICAgLy8gUGFydGlhbCBDYXB0dXJlOiBDYXB0dXJlIDMzJSBvZiBwYXJ0aWNsZXMgKGluZGljZXMgZGl2aXNpYmxlIGJ5IDMpXG4gICAgICAgICAgICAgICAgLy8gQmFsYW5jZSBiZXR3ZWVuIG1haW50YWluaW5nIGNvcmUgc3RydWN0dXJlIGFuZCBjcmVhdGluZyBhIHZpc2libGUgc3dhcm0uXG4gICAgICAgICAgICAgICAgaWYgKGRpc3QgPCBjYXB0dXJlUmFkaXVzICYmIGkgJSAzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzQ2FwdHVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHRvd2FyZHMgYnV0dG9uIGNlbnRlclxuICAgICAgICAgICAgICAgICAgICAvLyBCb29zdGVkIHB1bGwgZm9yY2VcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvcmNlID0gKGNhcHR1cmVSYWRpdXMgLSBkaXN0KSAvIGNhcHR1cmVSYWRpdXM7XG4gICAgICAgICAgICAgICAgICAgIGZvcmNlICo9IG1lLmdyYXZpdHlCb29zdDsgLy8gQXBwbHkgYm9vc3QgdG8gdmVsb2NpdHlcblxuICAgICAgICAgICAgICAgICAgICB4ICs9IGR4ICogZm9yY2UgKiAwLjE7XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gZHkgKiBmb3JjZSAqIDAuMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaXNDYXB0dXJlZCkge1xuICAgICAgICAgICAgICAgIC8vIE5vcm1hbCBTcGlyYWwgUGh5c2ljc1xuICAgICAgICAgICAgICAgIGxldCB2ZWxvY2l0eSA9IHNwZCAqICgxICsgKDUwMCAvIChyYWQgKyAxMCkpKTtcblxuICAgICAgICAgICAgICAgIC8vIEdsb2JhbCBFbmdpbmUgUmV2OiBBY2NlbGVyYXRlIHNwaXJhbCBiYXNlZCBvbiBncmF2aXR5Qm9vc3RcbiAgICAgICAgICAgICAgICB2ZWxvY2l0eSAqPSAoMSArIChtZS5ncmF2aXR5Qm9vc3QgLSAxKSAqIDAuMik7XG5cbiAgICAgICAgICAgICAgICByYWQgICAtPSB2ZWxvY2l0eSAqIDAuNTtcbiAgICAgICAgICAgICAgICBhbmdsZSArPSB2ZWxvY2l0eSAqIDAuMDA1O1xuXG4gICAgICAgICAgICAgICAgLy8gUmVzZXRcbiAgICAgICAgICAgICAgICBpZiAocmFkIDwgMTApIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1heFIgPSBNYXRoLm1heCh3aWR0aCwgaGVpZ2h0KSAqIDAuNztcbiAgICAgICAgICAgICAgICAgICAgcmFkID0gbWF4UjtcbiAgICAgICAgICAgICAgICAgICAgYW5nbGUgPSBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIENhcnRlc2lhbiBmcm9tIG5ldyBQb2xhclxuICAgICAgICAgICAgICAgIHggPSBjeCArIE1hdGguY29zKGFuZ2xlKSAqIHJhZDtcbiAgICAgICAgICAgICAgICB5ID0gY3kgKyBNYXRoLnNpbihhbmdsZSkgKiAocmFkICogMC40KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2F2ZSBQb2xhciBTdGF0ZVxuICAgICAgICAgICAgYnVmZmVyW2lkeCArIDJdID0gYW5nbGU7XG4gICAgICAgICAgICBidWZmZXJbaWR4ICsgM10gPSByYWQ7XG5cbiAgICAgICAgICAgIC8vIC0tLSBEUkFXIC0tLVxuICAgICAgICAgICAgbGV0IGRpc3RSYXRpbyA9IHJhZCAvIChNYXRoLm1heCh3aWR0aCwgaGVpZ2h0KSAqIDAuNik7XG4gICAgICAgICAgICBsZXQgYWxwaGEgPSAxIC0gZGlzdFJhdGlvO1xuXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAvLyBVc2UgJ2lubmVyJyAoQ3lhbi9JbmRpZ28pIGZvciBjYXB0dXJlZCBwYXJ0aWNsZXMgaW5zdGVhZCBvZiAnY29yZScgKFdoaXRlKVxuICAgICAgICAgICAgaWYgKGlzQ2FwdHVyZWQpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gY29sb3JzLmlubmVyO1xuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuNjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGRpc3RSYXRpbyA8IDAuMyA/IGNvbG9ycy5jb3JlIDogY29sb3JzLm91dGVyO1xuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGFscGhhO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmFkIDwgMTAwICYmICFpc0NhcHR1cmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gU3BhZ2hldHRpZmljYXRpb25cbiAgICAgICAgICAgICAgICBsZXQgdGFpbFggPSBjeCArIE1hdGguY29zKGFuZ2xlIC0gMC4yKSAqIChyYWQgKyAyMCk7XG4gICAgICAgICAgICAgICAgbGV0IHRhaWxZID0gY3kgKyBNYXRoLnNpbihhbmdsZSAtIDAuMikgKiAoKHJhZCArIDIwKSAqIDAuNCk7XG5cbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcnMuY29yZTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gc2l6ZTtcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8odGFpbFgsIHRhaWxZKTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5vIHNpemUgaW5jcmVhc2UgZm9yIGNhcHR1cmVkIHBhcnRpY2xlc1xuICAgICAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgc2l6ZSwgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcblxuICAgICAgICBpZiAoaGFzUmFmKSB7XG4gICAgICAgICAgICBtZS5hbmltYXRpb25JZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShtZS5yZW5kZXJMb29wKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUuYW5pbWF0aW9uSWQgPSBzZXRUaW1lb3V0KG1lLnJlbmRlckxvb3AsIDEwMDAgLyA2MClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgdXBkYXRlQWN0aXZlSWQoZGF0YSkge31cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtkYXRhLmlkXVxuICAgICAqL1xuICAgIHVwZGF0ZUhvdmVySWQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuICAgICAgICBpZiAobWUuaG92ZXJJZCAhPT0gZGF0YT8uaWQpIHtcbiAgICAgICAgICAgIG1lLmdyYXZpdHlCb29zdCA9IDU7IC8vIFRyaWdnZXIgQm9vc3Qgb24gY2hhbmdlXG4gICAgICAgIH1cbiAgICAgICAgbWUuaG92ZXJJZCA9IGRhdGE/LmlkIHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGEucmVjdHNcbiAgICAgKi9cbiAgICB1cGRhdGVOYXZSZWN0cyhkYXRhKSB7XG4gICAgICAgIGxldCByZWN0cyA9IGRhdGE/LnJlY3RzO1xuICAgICAgICB0aGlzLm5hdlJlY3RzID0gQXJyYXkuaXNBcnJheShyZWN0cykgPyByZWN0cyA6IFtdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmUtaW5pdCBvbiByZXNpemUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqL1xuICAgIHVwZGF0ZVJlc291cmNlcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuaW5pdFBhcnRpY2xlcyh3aWR0aCwgaGVpZ2h0KVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoRm9vdGVyQ2FudmFzKTtcbiIsImltcG9ydCBOZW9CYXNlIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuXG4vKipcbiAqIEBzdW1tYXJ5IEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIENhbnZhcyBSZW5kZXJlcnMuXG4gKlxuICogVGhpcyBjbGFzcyBzZXJ2ZXMgYXMgdGhlIGZvdW5kYXRpb24gZm9yIHRoZSBzcGVjaWFsaXplZCBjYW52YXMgdmlzdWFsaXphdGlvbnMgKEhlYWRlciwgSG9tZSwgU2VydmljZXMsIFRpY2tldClcbiAqIHRoYXQgcnVuIHdpdGhpbiB0aGUgKipOZW8ubWpzIENhbnZhcyBTaGFyZWRXb3JrZXIqKi5cbiAqXG4gKiBJdCBjcmVhdGVzIGhlbHBlciBzaW5nbGV0b25zIHRoYXQgbWFuYWdlIHRoZWlyIG93biBgT2Zmc2NyZWVuQ2FudmFzYCBpbnN0YW5jZXMsIHByb3ZpZGluZyBhIHN0YW5kYXJkaXplZFxuICogYXJjaGl0ZWN0dXJlIGZvcjpcbiAqIC0gKipMaWZlY3ljbGUgTWFuYWdlbWVudDoqKiBJbml0aWFsaXphdGlvbiAoYGluaXRHcmFwaGApLCBkZXN0cnVjdGlvbiAoYGNsZWFyR3JhcGhgKSwgYW5kIHJlc291cmNlIGNsZWFudXAuXG4gKiAtICoqUmVuZGVyIExvb3AgQ29udHJvbDoqKiBVbmlmaWVkIGByZW5kZXJgIGxvb3Agd2l0aCBwYXVzZS9yZXN1bWUgY2FwYWJpbGl0aWVzIGFuZCBmcmFtZSBzY2hlZHVsaW5nLlxuICogLSAqKkNvbnRleHQgTWFuYWdlbWVudDoqKiBSb2J1c3QgaGFuZGxpbmcgb2YgYE9mZnNjcmVlbkNhbnZhc2AgdHJhbnNmZXIgYW5kIGNvbnRleHQgYWNxdWlzaXRpb24gdmlhIGB3YWl0Rm9yQ2FudmFzYC5cbiAqIC0gKipTaGFyZWQgU3RhdGU6KiogQ29tbW9uIHN0YXRlIG1hbmFnZW1lbnQgZm9yIG1vdXNlIGludGVyYWN0aW9uLCB0aW1lLCBhbmQgdGhlbWluZy5cbiAqXG4gKiBUaGVzZSByZW5kZXJlcnMgb3BlcmF0ZSBvZmYgdGhlIG1haW4gdGhyZWFkIHRvIGVuc3VyZSBoaWdoLXBlcmZvcm1hbmNlLCA2MGZwcyBhbmltYXRpb25zIHdpdGhvdXRcbiAqIGJsb2NraW5nIHRoZSBVSS5cbiAqXG4gKiBAY2xhc3MgTmVvLmNhbnZhcy5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIEJhc2UgZXh0ZW5kcyBOZW9CYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jYW52YXMuQmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNhbnZhcy5CYXNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW90ZSBtZXRob2QgYWNjZXNzXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gcmVtb3RlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHJlbW90ZToge1xuICAgICAgICAgICAgYXBwOiBbXG4gICAgICAgICAgICAgICAgJ2NsZWFyR3JhcGgnLFxuICAgICAgICAgICAgICAgICdpbml0R3JhcGgnLFxuICAgICAgICAgICAgICAgICdwYXVzZScsXG4gICAgICAgICAgICAgICAgJ3Jlc3VtZScsXG4gICAgICAgICAgICAgICAgJ3NldFRoZW1lJyxcbiAgICAgICAgICAgICAgICAndXBkYXRlTW91c2VTdGF0ZScsXG4gICAgICAgICAgICAgICAgJ3VwZGF0ZVNpemUnXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYWN0aXZlIGNvbG9yIHRoZW1lICgnbGlnaHQnIG9yICdkYXJrJykuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gdGhlbWVfPSdsaWdodCdcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB0aGVtZV86ICdsaWdodCdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gYW5pbWF0aW9uSWQ9bnVsbFxuICAgICAqL1xuICAgIGFuaW1hdGlvbklkID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBjYW52YXNJZD1udWxsXG4gICAgICovXG4gICAgY2FudmFzSWQgPSBudWxsXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGNhbnZhc1NpemU9bnVsbFxuICAgICAqL1xuICAgIGNhbnZhc1NpemUgPSBudWxsXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2Zmc2NyZWVuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfG51bGx9IGNvbnRleHQ9bnVsbFxuICAgICAqL1xuICAgIGNvbnRleHQgPSBudWxsXG4gICAgLyoqXG4gICAgICogQ2FjaGUgZm9yIHJldXNhYmxlIGdyYWRpZW50cyB0byBwcmV2ZW50IEdDLlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gZ3JhZGllbnRzPXt9XG4gICAgICovXG4gICAgZ3JhZGllbnRzID0ge31cbiAgICAvKipcbiAgICAgKiBGbGFnIHRvIHBhdXNlIHRoZSByZW5kZXIgbG9vcC5cbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc1BhdXNlZD1mYWxzZVxuICAgICAqL1xuICAgIGlzUGF1c2VkID0gZmFsc2VcbiAgICAvKipcbiAgICAgKiBUcmFja2VkIG1vdXNlIHBvc2l0aW9uIGZvciBpbnRlcmFjdGl2ZSBwaHlzaWNzLlxuICAgICAqIEluaXRpYWxpemUgb2ZmLXNjcmVlbiB0byBwcmV2ZW50IHN0YXJ0dXAgaml0dGVycy5cbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vdXNlPXt4OiAtMTAwMCwgeTogLTEwMDB9XG4gICAgICovXG4gICAgbW91c2UgPSB7eDogLTEwMDAsIHk6IC0xMDAwfVxuICAgIC8qKlxuICAgICAqIEdsb2JhbCBzaW11bGF0aW9uIHRpbWUuXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSB0aW1lPTBcbiAgICAgKi9cbiAgICB0aW1lID0gMFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7RnVuY3Rpb259IHJlbmRlckxvb3A9dGhpcy5yZW5kZXIuYmluZCh0aGlzKVxuICAgICAqL1xuICAgIHJlbmRlckxvb3AgPSB0aGlzLnJlbmRlci5iaW5kKHRoaXMpXG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGB0aGVtZWAgY29uZmlnIGlzIGNoYW5nZWQuXG4gICAgICogVXBkYXRlcyB0aGUgcmVzb3VyY2UgY2FjaGUgKGdyYWRpZW50cywgY29sb3JzKSB0byByZWZsZWN0IHRoZSBuZXcgdGhlbWUgaW1tZWRpYXRlbHkuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICovXG4gICAgYWZ0ZXJTZXRUaGVtZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICYmIHRoaXMuY2FudmFzU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVSZXNvdXJjZXM/Lih0aGlzLmNhbnZhc1NpemUud2lkdGgsIHRoaXMuY2FudmFzU2l6ZS5oZWlnaHQpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGNhbnZhcyBpcyByZWFkeSB0byByZW5kZXIuXG4gICAgICogUmV0dXJucyB0cnVlIG9ubHkgaWYgdGhlIGNvbnRleHQgZXhpc3RzIGFuZCB0aGUgc2ltdWxhdGlvbiBpcyBub3QgcGF1c2VkLlxuICAgICAqIFN1YmNsYXNzZXMgc2hvdWxkIGNhbGwgdGhpcyBhdCB0aGUgc3RhcnQgb2YgdGhlaXIgYHJlbmRlcmAgbG9vcC5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgY2FuUmVuZGVyKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuICAgICAgICByZXR1cm4gISEobWUuY29udGV4dCAmJiAhbWUuaXNQYXVzZWQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBncmFwaCBzdGF0ZSBhbmQgc3RvcHMgdGhlIHJlbmRlciBsb29wLlxuICAgICAqIFVzZSB0aGlzIHRvIGNsZWFudXAgcmVzb3VyY2VzIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgb3IgdW5tb3VudGVkLlxuICAgICAqL1xuICAgIGNsZWFyR3JhcGgoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG4gICAgICAgIG1lLmNvbnRleHQgICAgID0gbnVsbDtcbiAgICAgICAgbWUuY2FudmFzSWQgICAgPSBudWxsO1xuICAgICAgICBtZS5jYW52YXNTaXplICA9IG51bGw7XG4gICAgICAgIG1lLmFuaW1hdGlvbklkID0gbnVsbDtcbiAgICAgICAgbWUuaXNQYXVzZWQgICAgPSBmYWxzZTtcbiAgICAgICAgbWUuZ3JhZGllbnRzICAgPSB7fTtcbiAgICAgICAgbWUubW91c2UgICAgICAgPSB7eDogLTEwMDAsIHk6IC0xMDAwfTtcbiAgICAgICAgbWUudGltZSAgICAgICAgPSAwXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIGNhbnZhcyBjb250ZXh0LlxuICAgICAqIFN0YXJ0cyB0aGUgcG9sbGluZyBtZWNoYW5pc20gdG8gd2FpdCBmb3IgdGhlIE9mZnNjcmVlbkNhbnZhcyB0cmFuc2ZlciBmcm9tIHRoZSBNYWluIFRocmVhZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRzLmNhbnZhc0lkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdHMud2luZG93SWRcbiAgICAgKi9cbiAgICBpbml0R3JhcGgoe2NhbnZhc0lkLCB3aW5kb3dJZH0pIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBoYXNDaGFuZ2UgPSBtZS5jYW52YXNJZCAhPT0gY2FudmFzSWQ7XG5cbiAgICAgICAgbWUuY2FudmFzSWQgPSBjYW52YXNJZDtcblxuICAgICAgICBtZS53YWl0Rm9yQ2FudmFzKGNhbnZhc0lkLCB3aW5kb3dJZCwgaGFzQ2hhbmdlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhvb2sgZm9yIHN1YmNsYXNzZXMgdG8gaGFuZGxlIG1vdXNlIGNsaWNrcy5cbiAgICAgKiBDYWxsZWQgYnkgYHVwZGF0ZU1vdXNlU3RhdGVgIHdoZW4gYSBjbGljayBldmVudCBpcyByZWNlaXZlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uTW91c2VDbGljayhkYXRhKSB7fVxuXG4gICAgLyoqXG4gICAgICogUGF1c2VzIHRoZSBzaW11bGF0aW9uLlxuICAgICAqIFRoZSByZW5kZXIgbG9vcCB3aWxsIGV4aXQgZWFybHkgd2hpbGUgYGlzUGF1c2VkYCBpcyB0cnVlLlxuICAgICAqL1xuICAgIHBhdXNlKCkge1xuICAgICAgICB0aGlzLmlzUGF1c2VkID0gdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFic3RyYWN0IHJlbmRlciBtZXRob2QuXG4gICAgICogU3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byBkcmF3IHRoZSBmcmFtZS5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7fVxuXG4gICAgLyoqXG4gICAgICogUmVzdW1lcyB0aGUgc2ltdWxhdGlvbi5cbiAgICAgKiBJZiB0aGUgc2ltdWxhdGlvbiB3YXMgcGF1c2VkLCB0aGlzIHJlc3RhcnRzIHRoZSByZW5kZXIgbG9vcC5cbiAgICAgKi9cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmlzUGF1c2VkKSB7XG4gICAgICAgICAgICBtZS5pc1BhdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgbWUucmVuZGVyTG9vcCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHBvc2VkIG1ldGhvZCBmb3IgUmVtb3RlIEFjY2VzcyB0byB0cmlnZ2VyIHRoZSByZWFjdGl2ZSBjb25maWcgc2V0dGVyLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIHNldFRoZW1lKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudGhlbWUgPSB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGxvY2FsIG1vdXNlIHN0YXRlIGZyb20gbWFpbiB0aHJlYWQgZXZlbnRzLlxuICAgICAqIERlbGVnYXRlcyBjbGljayBldmVudHMgdG8gYG9uTW91c2VDbGlja2AuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkYXRhLmNsaWNrXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2RhdGEubGVhdmVdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtkYXRhLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtkYXRhLnldXG4gICAgICovXG4gICAgdXBkYXRlTW91c2VTdGF0ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKGRhdGEubGVhdmUpIHtcbiAgICAgICAgICAgIG1lLm1vdXNlLnggPSAtMTAwMDtcbiAgICAgICAgICAgIG1lLm1vdXNlLnkgPSAtMTAwMFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRhdGEueCAhPT0gdW5kZWZpbmVkKSBtZS5tb3VzZS54ID0gZGF0YS54O1xuICAgICAgICAgICAgaWYgKGRhdGEueSAhPT0gdW5kZWZpbmVkKSBtZS5tb3VzZS55ID0gZGF0YS55O1xuXG4gICAgICAgICAgICBpZiAoZGF0YS5jbGljaykge1xuICAgICAgICAgICAgICAgIG1lLm9uTW91c2VDbGljayhkYXRhKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgY2FudmFzIHNpemUgYW5kIHJlc2l6ZXMgdGhlIGludGVybmFsIGNvbnRleHQuXG4gICAgICogVHJpZ2dlcnMgYHVwZGF0ZVJlc291cmNlc2AgaG9vayB0byBhbGxvdyBzdWJjbGFzc2VzIHRvIHJlZ2VuZXJhdGUgYnVmZmVycy9ncmFkaWVudHMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNpemVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2l6ZS5oZWlnaHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2l6ZS53aWR0aFxuICAgICAqL1xuICAgIHVwZGF0ZVNpemUoc2l6ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmNhbnZhc1NpemUgPSBzaXplO1xuXG4gICAgICAgIGlmIChtZS5jb250ZXh0KSB7XG4gICAgICAgICAgICBtZS5jb250ZXh0LmNhbnZhcy53aWR0aCAgPSBzaXplLndpZHRoO1xuICAgICAgICAgICAgbWUuY29udGV4dC5jYW52YXMuaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgICAvLyBDYWxscyB0aGUgaG9vayB0byByZS1nZW5lcmF0ZSByZXNvdXJjZXMgaWYgaW1wbGVtZW50ZWRcbiAgICAgICAgICAgIG1lLnVwZGF0ZVJlc291cmNlcz8uKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUG9sbHMgZm9yIHRoZSBPZmZzY3JlZW5DYW52YXMgdW50aWwgaXQgaXMgYXZhaWxhYmxlIGluIHRoZSBXb3JrZXIncyBgY2FudmFzV2luZG93TWFwYC5cbiAgICAgKiBPbmNlIGZvdW5kLCBpdCBpbml0aWFsaXplcyB0aGUgY29udGV4dCBhbmQgc3RhcnRzIHRoZSByZW5kZXIgbG9vcC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2FudmFzSWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gd2luZG93SWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGhhc0NoYW5nZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB3YWl0Rm9yQ2FudmFzKGNhbnZhc0lkLCB3aW5kb3dJZCwgaGFzQ2hhbmdlKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY2FudmFzID0gTmVvLmN1cnJlbnRXb3JrZXIuY2FudmFzV2luZG93TWFwW2NhbnZhc0lkXT8uW3dpbmRvd0lkXTtcblxuICAgICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgICAgICBtZS5jb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgIC8vIFN0YW5kYXJkaXplIHNpemUgdXBkYXRlXG4gICAgICAgICAgICBtZS51cGRhdGVTaXplKHt3aWR0aDogY2FudmFzLndpZHRoLCBoZWlnaHQ6IGNhbnZhcy5oZWlnaHR9KTtcblxuICAgICAgICAgICAgLy8gT3B0aW9uYWwgaG9vayBmb3Igc3ViY2xhc3Nlc1xuICAgICAgICAgICAgbWUub25HcmFwaE1vdW50ZWQ/LihjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuXG4gICAgICAgICAgICBpZiAoaGFzQ2hhbmdlICYmICFtZS5hbmltYXRpb25JZCkge1xuICAgICAgICAgICAgICAgIG1lLnJlbmRlckxvb3AoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dChtZS53YWl0Rm9yQ2FudmFzLmJpbmQobWUsIGNhbnZhc0lkLCB3aW5kb3dJZCwgaGFzQ2hhbmdlKSwgNTApXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEJhc2UpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9