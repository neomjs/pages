export const __webpack_esm_id__ = "vendors-examples_component_canvas_MainContainer_mjs";
export const __webpack_esm_ids__ = ["vendors-examples_component_canvas_MainContainer_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./examples/ConfigurationViewport.mjs"
/*!********************************************!*\
  !*** ./examples/ConfigurationViewport.mjs ***!
  \********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/button/Base.mjs */ "./src/button/Base.mjs");
/* harmony import */ var _src_container_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _src_container_Panel_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/container/Panel.mjs */ "./src/container/Panel.mjs");
/* harmony import */ var _src_container_Viewport_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/container/Viewport.mjs */ "./src/container/Viewport.mjs");
/* harmony import */ var _src_util_Function_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/util/Function.mjs */ "./src/util/Function.mjs");






// add custom themes here
const themes = [
    {name: 'neo-theme-light',     label: 'Theme Light'},
    {name: 'neo-theme-dark',      label: 'Theme Dark'},
    {name: 'neo-theme-neo-light', label: 'Theme Neo-Light'}
]

/**
 * Base class for example Apps which should be configurable
 * @class Neo.examples.ConfigurationViewport
 * @extends Neo.container.Viewport
 * @abstract
 */
class ConfigurationViewport extends _src_container_Viewport_mjs__WEBPACK_IMPORTED_MODULE_3__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.examples.ConfigurationViewport'
         * @protected
         */
        className: 'Neo.examples.ConfigurationViewport',
        /**
         * @member {String} ntype='configuration-viewport'
         * @protected
         */
        ntype: 'configuration-viewport',
        /**
         * @member {String[]} baseCls=['neo-examples-configuration-viewport','neo-viewport']
         */
        baseCls: ['neo-examples-configuration-viewport', 'neo-viewport'],
        /**
         * @member {Number} configItemLabelWidth=150
         */
        configItemLabelWidth: 150,
        /**
         * @member {Number} configItemWidth=270
         */
        configItemWidth: 270,
        /**
         * @member {Number} configPanelFlex=1
         */
        configPanelFlex: 1,
        /**
         * @member {Number} configPanelMaxWidth=null
         */
        configPanelMaxWidth: null,
        /**
         * @member {Number} configPanelMinWidth=350
         */
        configPanelMinWidth: 350,
        /**
         * @member {Neo.component.Base|null} exampleComponent=null
         */
        exampleComponent: null,
        /**
         * @member {Number} exampleComponentFlex=1
         */
        exampleComponentFlex: 2,
        /**
         * @member {Object} layout={ntype:'hbox', align:'stretch'}
         * @reactive
         */
        layout: {ntype: 'hbox', align: 'stretch'}
    }

    /**
     * Override this method to create the components to show inside the configuration container.
     * The method can optionally be async => Use this for functional components,
     * where you want to subscribe controls to "classic" components inside functional components.
     * @see:Neo.examples.functional.hostComponent.MainContainer
     * @returns {Promise<Object[]>|Object[]|null}
     */
    async createConfigurationComponents() {
        return null
    }

    /**
     * Override this method to create the component to show inside the current example
     * @returns {Object|Neo.component.Base|null}
     */
    createExampleComponent() {
        return null
    }

    /**
     * @param {Object} data
     */
    logInstance(data) {
        console.log(this.exampleComponent)
    }

    /**
     * @param {String} config
     * @param {Object} opts
     */
    onConfigChange(config, opts) {
        this.exampleComponent[config] = opts.value
    }

    /**
     *
     */
    async onConstructed() {
        let me    = this,
            style = me.exampleContainerConfig?.style,
            exampleComponentType, theme;

        if (style) {
            delete me.exampleContainerConfig.style
        }

        me.exampleComponent = me.createExampleComponent();

        exampleComponentType = Neo.typeOf(me.exampleComponent);

        if (exampleComponentType === 'NeoClass' || exampleComponentType === 'Object') {
            me.exampleComponent = Neo.create(me.exampleComponent)
        }

        me.configurationComponents = await me.createConfigurationComponents() || [];

        theme = me.exampleComponent.getTheme?.() || 'neo-theme-light';

        me.items = [{
            module: _src_container_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            cls   : ['neo-example-container'],
            items : [me.exampleComponent],
            flex  : me.exampleComponentFlex,
            layout: 'base',
            style : {overflow: 'auto', padding: '20px', ...style},
            ...me.exampleContainerConfig
        }, {
            module: _src_container_Panel_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            cls   : ['neo-panel', 'neo-container', 'neo-configuration-panel'],
            flex  : me.configPanelFlex,

            style: {
                maxWidth: me.configPanelMaxWidth + 'px',
                margin  : '20px',
                minWidth: me.configPanelMinWidth + 'px'
            },

            headers: [{
                cls  : ['neo-configuration-header-toolbar'],
                dock : 'top',
                items: [{
                    ntype: 'label',
                    text : 'Configuration'
                }, {
                    ntype: 'component',
                    flex : 1
                }, {
                    module : _src_button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                    handler: me.onSwitchTheme.bind(me),
                    id     : me.id + '__' + 'switchThemeButton',
                    text   : theme === 'neo-theme-dark' ? 'Theme Light' : 'Theme Dark'
                }]
            }],

            items: [{
                module: _src_container_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                layout: {ntype: 'vbox', align: null},
                cls   : ['neo-configuration-panel-body'],
                itemDefaults: {
                    clearToOriginalValue: true,
                    labelWidth          : me.configItemLabelWidth,
                    width               : me.configItemWidth
                },

                items: [...me.configurationComponents, {
                    module : _src_button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                    handler: (0,_src_util_Function_mjs__WEBPACK_IMPORTED_MODULE_4__.bindAppend)(me.onSwitchTheme, me, 'cmp'),
                    style  : {marginTop: '20px'},
                    text   : theme === 'neo-theme-dark' ? 'Theme Light' : 'Theme Dark',
                    width  : 130
                }, {
                    module : _src_button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                    handler: me.logInstance.bind(me),
                    text   : 'Log Instance',
                    width  : 130
                }]
            }]
        }];

        super.onConstructed()
    }

    /**
     * @param {String} config
     * @param {String} value
     * @param {Object} opts
     */
    onRadioChange(config, value, opts) {
        if (opts.value === true) { // we only want to listen to check events, not uncheck
            this.exampleComponent[config] = value
        }
    }

    /**
     * @param {Object} data
     * @param {String} target
     */
    onSwitchTheme(data, target) {
        let me          = this,
            button      = data.component,
            countThemes = themes.length,
            futureIndex, newTheme, themeIndex;

        themes.forEach((theme, index) => {
            if (button.text === theme.label) {
                newTheme   = theme.name;
                themeIndex = index;
            }
        });

        futureIndex = (themeIndex + countThemes +1) % countThemes;

        button.text = themes[futureIndex].label;

        if (target === 'cmp') {
            me.exampleComponent.theme = newTheme
        } else {
            me.app.mainView.theme = newTheme
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(ConfigurationViewport));


/***/ },

/***/ "./examples/component/canvas/MainContainer.mjs"
/*!*****************************************************!*\
  !*** ./examples/component/canvas/MainContainer.mjs ***!
  \*****************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_form_field_CheckBox_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/form/field/CheckBox.mjs */ "./src/form/field/CheckBox.mjs");
/* harmony import */ var _src_component_Canvas_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/component/Canvas.mjs */ "./src/component/Canvas.mjs");
/* harmony import */ var _ConfigurationViewport_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../ConfigurationViewport.mjs */ "./examples/ConfigurationViewport.mjs");
/* harmony import */ var _src_form_field_Number_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../src/form/field/Number.mjs */ "./src/form/field/Number.mjs");





/**
 * @class Neo.examples.component.canvas.MainContainer
 * @extends Neo.examples.ConfigurationViewport
 */
class MainContainer extends _ConfigurationViewport_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    static config = {
        className           : 'Neo.examples.component.canvas.MainContainer',
        autoMount           : true,
        configItemLabelWidth: 110,
        configItemWidth     : 230,
        layout              : {ntype: 'hbox', align: 'stretch'}
    }

    createConfigurationComponents() {
        let me = this;

        return [{
            module   : _src_form_field_CheckBox_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
            checked  : me.exampleComponent.offscreen,
            labelText: 'offscreen',
            listeners: {change: me.onConfigChange.bind(me, 'offscreen')}
        }, {
            module    :  _src_form_field_Number_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
            clearable : true,
            labelText : 'height',
            listeners : {change: me.onConfigChange.bind(me, 'height')},
            maxValue  : 800,
            minValue  : 100,
            stepSize  : 5,
            style     : {marginTop: '10px'},
            value     : me.exampleComponent.height
        }, {
            module    :  _src_form_field_Number_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
            clearable : true,
            labelText : 'width',
            listeners : {change: me.onConfigChange.bind(me, 'width')},
            maxValue  : 800,
            minValue  : 100,
            stepSize  : 5,
            value     : me.exampleComponent.width
        }];
    }

    createExampleComponent() {
        return Neo.create({
            module   : _src_component_Canvas_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            height   : 400,
            offscreen: true,
            width    : 400
        });
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MainContainer));


/***/ },

/***/ "./src/button/Base.mjs"
/*!*****************************!*\
  !*** ./src/button/Base.mjs ***!
  \*****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");




/**
 * @summary The default button component for the Neo.mjs framework.
 *
 * This class extends `Neo.component.Base` and offers comprehensive configurations for
 * text, icons, badges, and event handling. It supports advanced features like
 * internal routing, external URL redirection, and optional ripple effects on click.
 * This class serves as the foundation for other specialized button types like
 * SplitButton, TabHeaderButton, and GridHeaderButton.
 *
 * @class Neo.button.Base
 * @extends Neo.component.Base
 * @see Neo.examples.button.base.MainContainer
 */
class Button extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for badgePosition
     * @member {String[]} badgePositions=['bottom-left','bottom-right','top-left','top-right']
     * @protected
     * @static
     */
    static badgePositions = ['bottom-left', 'bottom-right', 'top-left', 'top-right']
    /**
     * Valid values for iconPosition
     * @member {String[]} iconPositions=['top','right','bottom','left']
     * @protected
     * @static
     */
    static iconPositions = ['top', 'right', 'bottom', 'left']

    static config = {
        /**
         * @member {String} className='Neo.button.Base'
         * @protected
         */
        className: 'Neo.button.Base',
        /**
         * @member {String} ntype='button'
         * @protected
         */
        ntype: 'button',
        /**
         * @member {String} badgePosition_='top-right'
         * @reactive
         */
        badgePosition_: 'top-right',
        /**
         * @member {String|null} badgeText_=null
         * @reactive
         */
        badgeText_: null,
        /**
         * @member {String[]} baseCls=['neo-button']
         */
        baseCls: ['neo-button'],
        /**
         * false calls Neo.Main.setRoute()
         * @member {Boolean} editRoute=true
         */
        editRoute: true,
        /**
         * Shortcut for domListeners={click:handler}.
         * A string-based value assumes that the handlerFn lives inside a controller.Component.
         *
         * This config uses a custom `isEqual` function to ensure proper reactivity.
         * When the handler is a function, it's often a closure that changes on each render
         * (e.g., in recycled components like grid cells). The default deep comparison
         * (`Neo.isEqual`) would incorrectly treat structurally identical functions as unchanged,
         * preventing updates. The custom `isEqual` forces an update for new function instances,
         * while performing a standard equality check for string-based handlers.
         * @member {Function|String|null} handler_
         * @reactive
         */
        handler_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_2__.isDescriptor]: true,
            value         : null,

            isEqual: (a, b) => {
                if (Neo.isFunction(a) && Neo.isFunction(b)) {
                    return false
                }
                return a === b
            }
        },
        /**
         * The scope (this pointer) inside the handler function.
         * Points to the button instance by default.
         * You can use 'this' as a string for convenience reasons
         * @member {Object|String|null} handlerScope=null
         */
        handlerScope: null,
        /**
         * The CSS class to use for an icon, e.g. 'fa fa-home'
         * @member {String|null} [iconCls_=null]
         * @reactive
         */
        iconCls_: null,
        /**
         * The color to use for an icon, e.g. '#ff0000' [optional]
         * @member {String|null} iconColor_=null
         * @reactive
         */
        iconColor_: null,
        /**
         * The position of the icon in case iconCls has a value.
         * Valid values are: 'top', 'right', 'bottom', 'left'
         * @member {String} iconPosition_='left'
         * @reactive
         */
        iconPosition_: 'left',
        /**
         * An array representing the configuration of the menu items.
         *
         * Or a configuration object which adds custom configuration to the menu to be
         * created and includes an `items` property to define the menu items.
         * @member {Object|Object[]|null} menu_=null
         * @reactive
         */
        menu_: null,
        /**
         * The pressed state of the Button
         * @member {Boolean} pressed_=false
         * @reactive
         */
        pressed_: false,
        /**
         * Change the browser hash value on click.
         * Use route for internal navigation and url for external links. Do not use both on the same instance.
         * Transforms the button tag into an a tag [optional]
         * @member {String|null} route_=null
         * @reactive
         */
        route_: null,
        /**
         * The text displayed on the button [optional]
         * You can either pass a string, or a vdom cn array.
         * @example
         *  text: [{tag: 'span', style: {color: '#bbbbbb'}, text: 'â—'}, {vtype: 'text', text: ' Cases'}]
         * @member {Object[]|String|null} text=null
         * @reactive
         */
        text: null,
        /**
         * Transforms the button tag into an a tag [optional]
         * @member {String|null} url_=null
         * @reactive
         */
        url_: null,
        /**
         * If url is set, applies the target attribute on the top level vdom node [optional]
         * @member {String} urlTarget_='_blank'
         * @reactive
         */
        urlTarget_: '_blank',
        /**
         * True adds an expanding circle on click
         * @member {Boolean} useRippleEffect_=true
         * @reactive
         */
        useRippleEffect_: true,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {tag: 'button', type: 'button', cn: [
            {tag: 'span', cls: ['neo-button-glyph']},
            {tag: 'span', cls: ['neo-button-text']},
            {cls: ['neo-button-badge']},
            {cls: ['neo-button-ripple-wrapper'], cn: [
                {cls: ['neo-button-ripple']}
            ]}
        ]}
    }

    /**
     * @member {Object} rippleWrapper
     */
    get badgeNode() {
        return this.getVdomRoot().cn[2]
    }
    /**
     * @member {Object} rippleWrapper
     */
    get iconNode() {
        return this.getVdomRoot().cn[0]
    }
    /**
     * Time in ms for the ripple effect when clicking on the button.
     * Only active if useRippleEffect is set to true.
     * @member {Number} rippleEffectDuration=400
     */
    rippleEffectDuration = 400
    /**
     * Internal flag to store the last setTimeout() id for ripple effect remove node callbacks
     * @member {Number} #rippleTimeoutId=null
     * @private
     */
    #rippleTimeoutId = null
    /**
     * @member {Object} rippleWrapper
     */
    get rippleWrapper() {
        return this.getVdomRoot().cn[3]
    }
    /**
     * @member {Object} textNode
     */
    get textNode() {
        return this.getVdomRoot().cn[1]
    }

    /**
     * @param {Object} config The configuration object for the button instance.
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.addDomListeners({
            click: me.onClick,
            scope: me
        })
    }



    /**
     * Triggered after the badgePosition config got changed
     * @param {String} value    The new value of the badgePosition config.
     * @param {String} oldValue The old value of the badgePosition config.
     * @protected
     */
    afterSetBadgePosition(value, oldValue) {
        let me          = this,
            {badgeNode} = me,
            cls         = badgeNode.cls || [];

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, 'neo-' + oldValue);
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-' + value);

        badgeNode.cls = cls;

        me.update()
    }

    /**
     * Triggered after the badgeText config got changed
     * @param {String|null} value    The new value of the badgeText config.
     * @param {String|null} oldValue The old value of the badgeText config.
     * @protected
     */
    afterSetBadgeText(value, oldValue) {
        let {badgeNode} = this;

        badgeNode.removeDom = !Boolean(value);
        badgeNode.text      = value;

        this.update()
    }

    /**
     * Triggered after the iconCls config got changed
     * @param {String} value    The new value of the iconCls config.
     * @param {String} oldValue The old value of the iconCls config.
     * @protected
     */
    afterSetIconCls(value, oldValue) {
        let {iconNode} = this;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(iconNode.cls, oldValue);
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(   iconNode.cls, value);

        iconNode.removeDom = !value || value === '';
        this.update()
    }

    /**
     * Triggered after the iconColor config got changed
     * @param {String|null} value    The new value of the iconColor config.
     * @param {String|null} oldValue The old value of the iconColor config.
     * @protected
     */
    afterSetIconColor(value, oldValue) {
        let {iconNode} = this;

        if (!iconNode.style) {
            iconNode.style = {};
        }

        if (value === '') {
            value = null
        }

        iconNode.style.color = value;
        this.update()
    }

    /**
     * Triggered after the iconPosition config got changed
     * @param {String} value    The new value of the iconPosition config.
     * @param {String} oldValue The old value of the iconPosition config.
     * @protected
     */
    afterSetIconPosition(value, oldValue) {
        let cls = this.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, 'icon-' + oldValue);
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'icon-' + value);

        this.cls = cls
    }

    /**
     * Triggered after the menu config got changed
     * @param {Object|Object[]|null} value    The new value of the menu config.
     * @param {Object|Object[]|null} oldValue The old value of the menu config.
     * @protected
     */
    afterSetMenu(value, oldValue) {
        if (value) {
            __webpack_require__.e(/*! import() */ "vendors-src_menu_List_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ../menu/List.mjs */ "./src/menu/List.mjs")).then(module => {
                let me            = this,
                    isArray       = Array.isArray(value),
                    items         = isArray ? value : value.items,
                    menuConfig    = isArray ? {} : value,
                    stateProvider = me.getStateProvider(),
                    {appName, theme, windowId} = me,

                    config = Neo.merge({
                        module         : module.default,
                        align          : {edgeAlign: 't0-b0', target: me.id},
                        appName,
                        displayField   : 'text',
                        floating       : true,
                        hidden         : true,
                        parentComponent: me,
                        theme,
                        windowId
                    }, menuConfig);

                if (items) {
                    config.items = items
                }

                if (stateProvider) {
                    config.stateProvider = {parent: stateProvider}
                }

                me.menuList = Neo.create(config)
            })
        }
    }

    /**
     * Triggered after the pressed config got changed
     * @param {Boolean} value    The new value of the pressed config.
     * @param {Boolean} oldValue The old value of the pressed config.
     * @protected
     */
    afterSetPressed(value, oldValue) {
        let cls = this.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].toggle(cls, 'pressed', value === true);
        this.cls = cls
    }

    /**
     * Triggered after the route config got changed
     * @param {String|null} value    The new value of the route config.
     * @param {String|null} oldValue The old value of the route config.
     * @protected
     */
    afterSetRoute(value, oldValue) {
        !this.editRoute && this.updateTag()
    }

    /**
     * Triggered after the theme config got changed
     * @param {String|null} value    The new value of the theme config.
     * @param {String|null} oldValue The old value of the theme config.
     * @protected
     */
    afterSetTheme(value, oldValue) {
        super.afterSetTheme(value, oldValue);

        let {menuList} = this;

        if (menuList) {
            menuList.theme = value
        }
    }

    /**
     * Triggered after the text config got changed
     * @param {Object[]|String|null} value    The new value of the text config.
     * @param {Object[]|String|null} oldValue The old value of the text config.
     * @protected
     */
    afterSetText(value, oldValue) {
        let me         = this,
            isEmpty    = !value || value === '',
            vdomRoot   = me.getVdomRoot(),
            {textNode} = me;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].toggle(me._cls,      'no-text', isEmpty);
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].toggle(vdomRoot.cls, 'no-text', isEmpty);
        textNode.removeDom = isEmpty;

        if (!isEmpty) {
            if (Neo.isArray(value)) {
                textNode.cn = value;
                delete textNode.text
            } else {
                textNode.text = value;
                delete textNode.cn
            }
        }

        me.update()
    }

    /**
     * Triggered after the url config got changed
     * @param {String|null} value    The new value of the url config.
     * @param {String|null} oldValue The old value of the url config.
     * @protected
     */
    afterSetUrl(value, oldValue) {
        this.updateTag()
    }

    /**
     * Triggered after the useRippleEffect config got changed
     * @param {Boolean} value    The new value of the useRippleEffect config.
     * @param {Boolean} oldValue The old value of the useRippleEffect config.
     * @protected
     */
    afterSetUseRippleEffect(value, oldValue) {
        // setting the config to false ends running ripple animations
        this.rippleWrapper.removeDom = true;
        this.update()
    }

    /**
     * Triggered after the urlTarget config got changed
     * @param {String} value    The new value of the urlTarget config.
     * @param {String} oldValue The old value of the urlTarget config.
     * @protected
     */
    afterSetUrlTarget(value, oldValue) {
        let me       = this,
            vdomRoot = me.getVdomRoot();

        if (me.url) {
            vdomRoot.target = value
        } else {
            delete vdomRoot.target
        }

        me.update()
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value    The new value of the windowId config.
     * @param {Number|null} oldValue The old value of the windowId config.
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        super.afterSetWindowId(value, oldValue);

        let {menuList} = this;

        if (menuList) {
            menuList.windowId = value
        }
    }

    /**
     * Converts the iconCls array into a string on beforeGet
     * @returns {String}
     * @protected
     */
    beforeGetIconCls() {
        let iconCls = this._iconCls;

        if (Array.isArray(iconCls)) {
            return iconCls.join(' ')
        }

        return iconCls
    }

    /**
     * Triggered before the badgePosition config gets changed
     * @param {String} value    The new value of the badgePosition config.
     * @param {String} oldValue The old value of the badgePosition config.
     * @returns {String}
     * @protected
     */
    beforeSetBadgePosition(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'badgePosition')
    }

    /**
     * Triggered before the iconCls config gets changed. Converts the string into an array if needed.
     * @param {Array|String|null} value    The new value of the iconCls config.
     * @param {Array|String|null} oldValue The old value of the iconCls config.
     * @returns {Array}
     * @protected
     */
    beforeSetIconCls(value, oldValue) {
        if (value && !Array.isArray(value)) {
            value = value.split(' ').filter(Boolean)
        }

        return value
    }

    /**
     * Triggered before the iconPosition config gets changed
     * @param {String} value    The new value of the iconPosition config.
     * @param {String} oldValue The old value of the iconPosition config.
     * @protected
     */
    beforeSetIconPosition(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'iconPosition')
    }

    /**
     * Changes the application's route based on the button's route config.
     * @protected
     */
    changeRoute() {
        this.editRoute && Neo.Main.editRoute(this.route)
    }

    /**
     * Destroys the button instance, its menu (if present), and calls the superclass destroy method.
     * @param {...*} args Arguments to pass to the superclass destroy method.
     */
    destroy(...args) {
        this.menuList?.destroy(true, false);
        super.destroy(...args)
    }

    /**
     * Handles the click event on the button.
     * Triggers the configured handler, toggles the menu, updates the route, and shows the ripple effect if applicable.
     * @param {Object} data The click event data object.
     */
    onClick(data) {
        let me = this;

        me.bindCallback(me.handler, 'handler', me.handlerScope || me);
        me.handler?.(data);

        me.menu            && me.toggleMenu();
        me.route           && me.changeRoute(); // only relevant for editRoute=true
        me.useRippleEffect && me.showRipple(data)
    }

    /**
     * Displays a ripple animation effect on the button.
     * @param {Object} data The click event data object used to calculate the ripple position.
     */
    async showRipple(data) {
        let me                   = this,
            buttonRect           = data.path[0].rect,
            diameter             = Math.max(buttonRect.height, buttonRect.width),
            radius               = diameter / 2,
            rippleEffectDuration = me.rippleEffectDuration,
            {rippleWrapper}      = me,
            rippleEl             = rippleWrapper.cn[0],
            rippleTimeoutId;

        rippleEl.style = Object.assign(rippleEl.style || {}, {
            animation: 'none',
            height   : `${diameter}px`,
            left     : `${data.clientX - buttonRect.left - radius}px`,
            top      : `${data.clientY - buttonRect.top  - radius}px`,
            width    : `${diameter}px`
        });

        delete rippleWrapper.removeDom;
        me.update();

        await me.timeout(1);

        rippleEl.style.animation = `ripple ${rippleEffectDuration}ms linear`;
        me.update();

        me.#rippleTimeoutId = rippleTimeoutId = setTimeout(() => {
            // we do not want to break animations when clicking multiple times
            if (me.#rippleTimeoutId === rippleTimeoutId) {
                me.#rippleTimeoutId = null;

                rippleWrapper.removeDom = true;
                me.update()
            }
        }, rippleEffectDuration)
    }

    /**
     * Toggles the visibility of the button's menu, if one is configured.
     */
    async toggleMenu() {
        let {menuList} = this,
            hidden     = !menuList.hidden;

        menuList.hidden = hidden;

        if (!hidden) {
            await this.timeout(50)
        }
    }

    /**
     * Serializes the button into a JSON-compatible object.
     * @returns {Object}
     */
    toJSON() {
        let me      = this,
            handler = me.handler;

        return {
            ...super.toJSON(),
            badgePosition: me.badgePosition,
            badgeText    : me.badgeText,
            handler      : Neo.isString(handler) ? handler : (Neo.isFunction(handler) ? 'function' : null),
            iconCls      : me.iconCls,
            iconColor    : me.iconColor,
            iconPosition : me.iconPosition,
            pressed      : me.pressed,
            route        : me.route,
            text         : me.text,
            url          : me.url,
            urlTarget    : me.urlTarget
        }
    }

    /**
     * Updates the VDOM tag of the button (e.g., switching between 'button' and 'a' tags) based on the current configuration.
     */
    updateTag() {
        let me                      = this,
            {editRoute, route, url} = me,
            link                    = !editRoute && route || url,
            vdomRoot                = me.getVdomRoot();

        if (!editRoute && route?.startsWith('#') === false) {
            link = '#' + link
        }

        if (link) {
            vdomRoot.href = link;
            vdomRoot.tag  = 'a'
        } else {
            delete vdomRoot.href;
            vdomRoot.tag = 'button'
        }

        me.update()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Button));


/***/ },

/***/ "./src/component/Abstract.mjs"
/*!************************************!*\
  !*** ./src/component/Abstract.mjs ***!
  \************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../manager/Component.mjs */ "./src/manager/Component.mjs");
/* harmony import */ var _mixin_DomEvents_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../mixin/DomEvents.mjs */ "./src/mixin/DomEvents.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _mixin_VdomLifecycle_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../mixin/VdomLifecycle.mjs */ "./src/mixin/VdomLifecycle.mjs");
/* harmony import */ var _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../manager/VDomUpdate.mjs */ "./src/manager/VDomUpdate.mjs");
/* harmony import */ var _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../util/VNode.mjs */ "./src/util/VNode.mjs");
/* harmony import */ var _core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../core/ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");










const
    closestController   = Symbol.for('closestController'),
    closestProvider     = Symbol.for('closestProvider'),
    twoWayBindingSymbol = Symbol.for('twoWayBinding');

/**
 * @class Neo.component.Abstract
 * @extends Neo.core.Base
 * @mixes Neo.component.mixin.DomEvents
 * @mixes Neo.core.Observable
 * @mixes Neo.component.mixin.VdomLifecycle
 */
class Abstract extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.Abstract'
         * @protected
         */
        className: 'Neo.component.Abstract',
        /**
         * @member {String} ntype='abstract-component'
         * @protected
         */
        ntype: 'abstract-component',
        /**
         * Additional namespaces to load theme files for.
         * @member {String[]|null} additionalThemeFiles=null
         * @example ['AgentOSStrategy.view.Viewport']
         */
        additionalThemeFiles: null,
        /**
         * The name of the App this component belongs to
         * @member {String|null} appName_=null
         * @reactive
         */
        appName_: null,
        /**
         * Bind configs to state.Provider data properties.
         * @member {Object|null} bind_={[isDescriptor]:true,merge:'deep',value:null}
         * @reactive
         */
        bind_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_8__.isDescriptor]: true,
            merge         : 'deep',
            value         : null
        },
        /**
         * Custom CSS selectors to apply to the root level node of this component
         * @member {String[]} cls_=null
         * @reactive
         */
        cls_: null,
        /**
         * Convenience shortcut to access the data config of the closest state.Provider.
         * Read only.
         * @member {Object} data_=null
         * @protected
         * @reactive
         */
        data_: null,
        /**
         * Disabled components will get the neo-disabled cls applied and won't receive DOM events
         * @member {Boolean} disabled_=false
         * @reactive
         */
        disabled_: false,
        /**
         * @member {Neo.core.Base[]} mixins=[DomEvents, Observable, VdomLifecycle]
         */
        mixins: [_mixin_DomEvents_mjs__WEBPACK_IMPORTED_MODULE_3__["default"], _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_4__["default"], _mixin_VdomLifecycle_mjs__WEBPACK_IMPORTED_MODULE_5__["default"]],
        /**
         * Override specific stateProvider data properties.
         * This will merge the content.
         * @member {Object|null} modelData=null
         */
        modelData: null,
        /**
         * True after the component initVnode() method was called. Also fires the rendered event.
         * @member {Boolean} mounted_=false
         * @protected
         * @reactive
         */
        mounted_: false,
        /**
         * If the parentId does not match a neo component id, you can manually set this value for finding
         * view controllers or state providers.
         * Use case: manually dropping components into a vdom structure
         * @member {Neo.component.Base|null} parentComponent_=null
         * @protected
         * @reactive
         */
        parentComponent_: null,
        /**
         * The parent component id or document.body
         * @member {String} parentId_='document.body'
         * @reactive
         */
        parentId_: 'document.body',
        /**
         * @member {Boolean} saveScrollPosition=true
         */
        saveScrollPosition: true,
        /**
         * Optionally add a state.Provider to share state data with child components
         * @member {Object|null} stateProvider_=null
         * @reactive
         */
        stateProvider_: null,
        /**
         * A map of config names and values to reset to when the component unmounts.
         * @member {Object|null} unmountConfigs_={[isDescriptor]:true,merge:'deep',value:null}
         * @example {activeIndex: null, value: ''}
         * @reactive
         */
        unmountConfigs_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_8__.isDescriptor]: true,
            merge         : 'deep',
            value         : null
        },
        /**
         * The custom windowIs (timestamp) this component belongs to
         * @member {Number|null} windowId_=null
         * @reactive
         */
        windowId_: null
    }

    /**
     * Internal flag which will get set to true while a component is waiting for its mountedPromise
     * @member {Boolean} isAwaitingMount=false
     * @protected
     */
    isAwaitingMount = false

    /**
     * Convenience shortcut to access the App this component belongs to
     * @returns {Neo.controller.Application|null}
     */
    get app() {
        // We need Neo.appsByName as a fallback for Playwright-based unit testing
        return Neo.apps[this.windowId] || Neo.appsByName[this.appName]?.[0] || null
    }

    /**
     * A Promise that resolves when the component is mounted to the DOM.
     * This provides a convenient way to wait for the component to be fully
     * available and interactive before executing subsequent logic.
     *
     * It also handles unmounting by resetting the promise, so it can be safely
     * awaited again if the component is remounted.
     * @returns {Promise<Neo.component.Base>}
     */
    get mountedPromise() {
        let me = this;

        if (!me._mountedPromise) {
            me._mountedPromise = new Promise(resolve => {
                if (me.mounted) {
                    resolve(me);
                } else {
                    me.mountedPromiseResolve = resolve
                }
            })
        }

        return me._mountedPromise
    }

    /**
     * Convenience method to access the parent component
     * @returns {Neo.component.Base|null}
     */
    get parent() {
        let me = this;

        return me.parentComponent || (me.parentId === 'document.body' ? null : Neo.getComponent(me.parentId))
    }

    /**
     * Triggered after any config got changed
     * @param {String} key
     * @param {*} value
     * @param {*} oldValue
     * @protected
     */
    afterSetConfig(key, value, oldValue) {
        let me = this;

        if (Neo.isUsingStateProviders && me[twoWayBindingSymbol]) {
            // When a component config is updated by its state provider, this flag is set to the config's key.
            // This prevents circular updates in two-way data bindings by skipping the push back to the state provider.
            if (me._skipTwoWayPush === key) {
                return;
            }
            let binding = me.bind?.[key];

            if (binding?.twoWay) {
                this.getStateProvider()?.setData(binding.key, value)
            }
        }
    }

    /**
     * Triggered after the id config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetId(value, oldValue) {
        super.afterSetId(value, oldValue);

        oldValue && _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].unregister(oldValue);
        value    && _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].register(this)
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        if (oldValue !== undefined) {
            const me = this;

            if (value) { // mount
                me.initDomEvents?.();
                me.mountedPromiseResolve?.(this);
                delete me.mountedPromiseResolve;

                // When a component becomes mounted, it might have pending VDOM update promises
                // (e.g. from a set() call that was deferred because the component wasn't mounted yet).
                // If the mount happened because a Parent component updated (implicitly covering this component),
                // this component's own pending update cycle might be skipped or not yet triggered.
                // We explicitly execute the callbacks here to ensure those pending promises are resolved immediately
                // upon mount, preventing deadlocks where code awaits a VDOM update that effectively already happened.
                _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].executeCallbacks(me.id, {
                    deltas: [],
                    vnode : me.vnode
                })
            } else { // unmount
                delete me._mountedPromise;

                me.resetMountedDomEvents?.();

                if (me.unmountConfigs) {
                    me.set(me.unmountConfigs)
                }
            }
        }
    }

    /**
     * Triggered after the parentId config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetParentId(value, oldValue) {
        _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].onParentIdChange(this, oldValue)
    }

    /**
     * Triggered after the stateProvider config got changed
     * @param {Neo.state.Provider} value
     * @param {Object|Neo.state.Provider|null} oldValue
     * @protected
     */
    afterSetStateProvider(value, oldValue) {
        value?.createBindings(this)
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        const me = this;

        if (value) {
            me.controller    && (me.controller.windowId    = value);
            me.stateProvider && (me.stateProvider.windowId = value);

            Neo.currentWorker.insertThemeFiles(value, me.__proto__)
        }

        // If a component gets moved into a different window, an update cycle might still be running.
        // Since the update might no longer get mapped, we want to re-enable this instance for future updates.
        if (oldValue) {
            me.isVdomUpdating = false
        }
    }

    /**
     * Triggered when accessing the data config
     * Convenience shortcut which is expensive to use, since it will generate a merged parent state providers data map.
     * @param {Object} value
     * @protected
     */
    beforeGetData(value) {
        return this.getStateProvider()?.getHierarchyData()
    }

    /**
     * Triggered before the stateProvider config gets changed.
     * Creates a state.Provider instance if needed.
     * @param {Object} value
     * @param {Object} oldValue
     * @returns {Neo.state.Provider}
     * @protected
     */
    beforeSetStateProvider(value, oldValue) {
        oldValue?.destroy();

        if (value) {
            let me            = this,
                defaultValues = {component: me, windowId: me.windowId};

            if (me.modelData) {
                defaultValues.data = me.modelData
            }

            return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, 'Neo.state.Provider', defaultValues)
        }

        return null
    }

    /**
     *
     */
    destroy() {
        this.removeDomEvents();
        _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].unregister(this);
        this.stateProvider = null; // triggers destroy()
        super.destroy()
    }

    /**
     * Find an instance stored inside a config via optionally passing a ntype.
     * Returns this[configName] or the closest parent component with a match.
     * Used by getController() & getStateProvider()
     * @param {String} configName
     * @param {String} [ntype]
     * @returns {Neo.core.Base|null}
     */
    getConfigInstanceByNtype(configName, ntype) {
        let me                = this,
            config            = me[configName],
            {parentComponent} = me;

        if (config && (!ntype || ntype === config.ntype)) {
            return config
        }

        if (!parentComponent && me.parentId) {
            parentComponent = me.parent || Neo.get(me.parentId);
        }

        if (parentComponent) {
            if (parentComponent === me) {
                console.error('Circular parent reference detected', me.id);
                return null
            }

            // todo: We need ?. until functional.component.Base supports controllers
            return parentComponent.getConfigInstanceByNtype?.(configName, ntype)
        }

        return null
    }

    /**
     * Convenience shortcut
     * @param args
     * @returns {*}
     */
    getState(...args) {
        return this.getStateProvider().getData(...args)
    }

    /**
     * Returns this.stateProvider or the closest parent stateProvider
     * @param {String} [ntype]
     * @returns {Neo.state.Provider|null}
     */
    getStateProvider(ntype) {
        if (!Neo.isUsingStateProviders) {
            return null
        }

        let me = this,
            provider;

        if (!ntype) {
            provider = me[closestProvider];

            if (provider) {
                return provider
            }
        }

        provider = me.getConfigInstanceByNtype('stateProvider', ntype);

        if (!ntype) {
            me[closestProvider] = provider
        }

        return provider
    }

    /**
     * @param args
     */
    initConfig(...args) {
        super.initConfig(...args);
        this.getStateProvider()?.createBindings(this)
    }

    /**
     * @param {Object} data
     */
    onScrollCapture(data) {
        let me    = this,
            vnode;

        if (me.vnode) {
            vnode = _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_7__["default"].getById(me.vnode, data.target.id);

            if (vnode) {
                // Directly updating the persistent vnode state (plain object).
                // This does not trigger a VDOM update, but ensures the state is preserved
                // for future re-renders (e.g. unmount/remount).
                vnode.scrollTop  = data.scrollTop;
                vnode.scrollLeft = data.scrollLeft
            }
        }
    }

    /**
     * Change multiple configs at once, ensuring that all afterSet methods get all new assigned values
     * @param {Object} values={}
     * @param {Boolean} silent=false
     * @returns {Promise<*>}
     */
    set(values={}, silent=false) {
        const
            me        = this,
            wasHidden = me.hidden;

        me.setSilent(values);

        if (!silent && me.needsVdomUpdate) {
            if (wasHidden && !me.hidden) {
                me.show?.(); // show() is not part of the abstract base class
                return Promise.resolve()
            }

            return me.promiseUpdate()
        }

        return Promise.resolve()
    }

    /**
     * A silent version of set(), which does not trigger a vdom update at the end.
     * Useful for batching multiple config changes.
     * @param {Object} values={}
     */
    setSilent(values={}) {
        this.silentVdomUpdate = true;
        super.set(values);
        this.silentVdomUpdate = false
    }

    /**
     * Convenience shortcut
     * @param args
     */
    setState(...args) {
        this.getStateProvider().setData(...args)
    }

    /**
     * Serializes the component into a JSON-compatible object.
     * Extends the core.Base serialization with component-specific properties.
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            appName      : me.appName,
            bind         : me.bind ? Object.keys(me.bind) : null,
            mounted      : me.mounted,
            parentId     : me.parentId,
            stateProvider: me.stateProvider?.toJSON(),
            windowId     : me.windowId
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Abstract));


/***/ },

/***/ "./src/component/Base.mjs"
/*!********************************!*\
  !*** ./src/component/Base.mjs ***!
  \********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Abstract_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Abstract.mjs */ "./src/component/Abstract.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../manager/Component.mjs */ "./src/manager/Component.mjs");
/* harmony import */ var _util_KeyNavigation_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/KeyNavigation.mjs */ "./src/util/KeyNavigation.mjs");
/* harmony import */ var _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Logger.mjs */ "./src/util/Logger.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/Rectangle.mjs */ "./src/util/Rectangle.mjs");
/* harmony import */ var _util_Style_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../util/Style.mjs */ "./src/util/Style.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/VDom.mjs */ "./src/util/VDom.mjs");
/* harmony import */ var _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../util/VNode.mjs */ "./src/util/VNode.mjs");
/* harmony import */ var _core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../core/ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");












const
    addUnits          = value => value == null ? value : isNaN(value) ? value : `${value}px`,
    closestController = Symbol.for('closestController'),
    lengthRE          = /^\d+\w+$/;

/**
 * Base class for all Components which have a DOM representation
 * @class Neo.component.Base
 * @extends Neo.component.Abstract
 */
class Component extends _Abstract_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for hideMode
     * @member {String[]} hideModes=['removeDom','visibility']
     * @protected
     * @static
     */
    static hideModes = ['removeDom', 'visibility']

    static config = {
        /**
         * @member {String} className='Neo.component.Base'
         * @protected
         */
        className: 'Neo.component.Base',
        /**
         * @member {String} ntype='component'
         * @protected
         */
        ntype: 'component',
        /**
         * The default alignment specification to position this Component relative to some other
         * Component, or Element or Rectangle. Only applies in case floating = true.
         * @member {Object|String} align_={[isDescriptor]: true, merge: 'deep', value: {edgeAlign: 't-b',constrainTo: 'document.body'}}
         * @reactive
         */
        align_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_10__.isDescriptor]: true,
            merge         : 'deep',
            value: {
                edgeAlign  : 't-b',
                constrainTo: 'document.body'
            }
        },
        /**
         * CSS selectors to apply to the root level node of this component
         * @member {String[]} baseCls=[]
         */
        baseCls: [],
        /**
         * manager.Focus will change this flag on focusin & out dom events
         * @member {Boolean} containsFocus_=false
         * @protected
         * @reactive
         */
        containsFocus_: false,
        /**
         * Assign a component controller to this component (pass an imported module or the string based class name)
         * @member {Neo.controller.Component|String} controller_=null
         * @reactive
         */
        controller_: null,
        /**
         * Set this config to true to dynamically import a DropZone module & create an instance
         * @member {Boolean} droppable_=false
         * @reactive
         */
        droppable_: false,
        /**
         * @member {Neo.draggable.DropZone|null} dropZone=null
         */
        dropZone: null,
        /**
         * @member {Object} dropZoneConfig=null
         */
        dropZoneConfig: null,
        /**
         * True to mount this component into the viewport outside of the document flow
         * @member {Boolean} floating
         */
        floating: false,
        /**
         * Internal flag which will get set to true on mount
         * @member {Boolean} hasBeenMounted=false
         * @protected
         */
        hasBeenMounted: false,
        /**
         * Shortcut for style.height, defaults to px
         * @member {Number|String|null} height_=null
         * @reactive
         */
        height_: null,
        /**
         * Initial setting to hide or show the component and
         * you can use either hide()/show() or change this config directly to change the hidden state
         * @member {Boolean} hidden_=false
         * @reactive
         */
        hidden_: false,
        /**
         * Used for hide and show and defines if the component
         * should use css visibility:'hidden' or vdom:removeDom
         * @member {String} hideMode_='removeDom'
         * @reactive
         */
        hideMode_: 'removeDom',
        /**
         * The top level innerHTML of the component
         * @member {String|null} html_=null
         * @reactive
         */
        html_: null,
        /**
         * Set to `true` to show a spinner centered in the component.
         * Set to a string to show a message next to a spinner centered in the component.
         * @member {Boolean|String} isLoading=false
         */
        isLoading_: false,
        /**
         * Using the keys config will create an instance of Neo.util.KeyNavigation.
         * @see {@link Neo.util.KeyNavigation KeyNavigation}
         * @member {Object} keys_=null
         * @reactive
         */
        keys_: null,
        /**
         * Gets used inside afterSetIsLoading() to define the CSS for the loading spinner icon
         * @member {String[]} loadingSpinnerCls_=['fa','fa-spinner','fa-spin']
         * @reactive
         */
        loadingSpinnerCls_: ['fa', 'fa-spinner', 'fa-spin'],
        /**
         * Shortcut for style.maxHeight, defaults to px
         * @member {Number|String|null} maxHeight_=null
         * @reactive
         */
        maxHeight_: null,
        /**
         * Shortcut for style.maxWidth, defaults to px
         * @member {Number|String|null} maxWidth_=null
         * @reactive
         */
        maxWidth_: null,
        /**
         * Shortcut for style.minHeight, defaults to px
         * @member {Number|String|null} minHeight_=null
         * @reactive
         */
        minHeight_: null,
        /**
         * Shortcut for style.minWidth, defaults to px
         * @member {Number|String|null} minWidth_=null
         * @reactive
         */
        minWidth_: null,
        /**
         * Array of Plugin Modules and / or config objects
         * @member {Array|null} plugins_=null
         * @protected
         * @reactive
         */
        plugins_: null,
        /**
         * Set a reference for accessing the component inside view controllers.
         * References will also get mapped into the vdom root (data-ref: value).
         * @member {String|null} reference_=null
         * @protected
         * @reactive
         */
        reference_: null,
        /**
         * Make the view Responsive by adding alternative configs.
         * The definition happens via responsiveCfg
         * @member {Object} responsive=null
         * @protected
         */
        responsive_: null,
        /**
         * Specify a role tag attribute for the vdom root.
         * See: https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles
         * @member {String|null} role_=null
         * @reactive
         */
        role_: null,
        /**
         * Set this to true for style 'overflow:auto'.
         * Set this to 'x' or 'y' to add style 'overflow-x' or 'overflow-y' to 'auto'
         * Other than false this will add cls 'neo-scrollable'.
         * @member {Boolean|"x"|"y"} scrollable_=false
         * @reactive
         */
        scrollable_: false,
        /**
         * Style attributes added to this vdom root. see: getVdomRoot()
         *
         * **Important:** When `vdom === vdomRoot` (single node component), the `wrapperStyle` mechanism
         * creates a persistent state loop to support runtime VDOM mutations.
         * This means that to *remove* a style property you previously set, you MUST set it to `null`.
         * Using `delete` or setting `undefined` will revert to the "previous state", which unfortunately
         * includes the very value you are trying to remove if it has leaked into `wrapperStyle`.
         *
         * @member {Object} style={[isDescriptor]: true, merge: 'shallow', value: null}
         */
        style_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_10__.isDescriptor]: true,
            merge         : 'shallow',
            value         : null
        },
        /**
         * You can pass a used theme directly to any component,
         * to style specific component trees differently from your main view.
         * @member {String|null} theme_=null
         * @reactive
         */
        theme_: null,
        /**
         * While it is recommended to define tags inside the vdom of classes,
         * this shortcut enables us to change the vdom root tag on instance level.
         * Use cases: switch a Toolbar to a "nav" tag, switch a SideNav to an "aside" tag.
         * @member {String|null} tag_=null
         * @reactive
         */
        tag_: null,
        /**
         * The top level textContent of the component
         * @member {String|null} text_=null
         * @reactive
         */
        text_: null,
        /**
         * Add tooltip config object or a string containing the display text
         * See tooltip/Base.mjs
         *
         * By default, a single, shared Tooltip instance is used for all widgets that request
         * a tooltip. It reconfigures itself from the widget's definition just before showing.
         *
         * If a widget needs its own instance for any reason, include the property `ownInstance: true`
         * in the tooltip config object.
         * @member {Object|String} tooltip_=null
         * @reactive
         */
        tooltip_: null,
        /**
         * Add 'primary' and other attributes to make it an outstanding design
         * @member {String|null} ui_=null
         * @reactive
         */
        ui_: null,
        /**
         * Shortcut for style.width, defaults to px
         * @member {Number|String|null} width_=null
         * @reactive
         */
        width_: null,
        /**
         * @member {String[]|null} wrapperCls_=null
         * @reactive
         */
        wrapperCls_: null,
        /**
         * Top level style attributes. Useful in case getVdomRoot() does not point to the top level DOM node.
         *
         * **Note:** The getter for this config reads `vdom.style` as a default value to support runtime mutations.
         * This creates the persistent state loop described in the `style_` config documentation.
         *
         * @member {Object|null} wrapperStyle_={[isDescriptor]: true, merge: 'shallow', value: null}
         * @reactive
         */
        wrapperStyle_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_10__.isDescriptor]: true,
            merge         : 'shallow',
            value         : null
        },
        /**
         * The vdom markup for this component.
         * @member {Object} _vdom={}
         */
        _vdom: {}
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        let me = this;

        if (!Object.hasOwn(me, '_vdom') && me._vdom) {
            me._vdom = Neo.clone(me._vdom, true)
        }

        super.construct(config)
    }

    /**
     * Returns true if this Component is fully visible, that is it is not hidden and has no hidden ancestors
     */
    get isVisible() {
        return this.mounted && !this.hidden && (!this.parent || this.parent.isVisible);
    }

    /**
     * The setter will handle vdom updates automatically
     * @member {Object} vdom=this._vdom
     */
    get vdom() {
        return this._vdom
    }
    set vdom(value) {
        this.afterSetVdom(value, value)
    }

    /**
     * Add a new cls to the vdomRoot
     * @param {String} value
     */
    addCls(value) {
        let {cls} = this;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].add(cls, value);
        this.cls = cls
    }

    /**
     * Either a string like 'color: red; background-color: blue;'
     * or an object containing style attributes
     * @param {String|Object} value
     * @returns {Object} all styles of this.el
     */
    addStyle(value) {
        if (Neo.isString(value)) {
            value =  Neo.createStyleObject(value)
        }

        // todo: add a check if something has changed

        return this.style = Object.assign(this.style, value)
    }

    /**
     * Add a new wrapperCls to the top level node
     * @param {String} value
     */
    addWrapperCls(value) {
        let {wrapperCls} = this;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].add(wrapperCls, value);
        this.wrapperCls = wrapperCls
    }

    /**
     * Triggered after the appName config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetAppName(value, oldValue) {

    }

    /**
     * Triggered after the cls config got changed
     * @param {String[]|null} value
     * @param {String[]|null} oldValue
     * @protected
     */
    afterSetCls(value, oldValue) {
        oldValue = oldValue || [];

        let me       = this,
            vdom     = me.vdom,
            vdomRoot = me.getVdomRoot(),
            cls;

        if (vdom !== vdomRoot) {
            // we are using a wrapper node
            vdomRoot.cls = [...value]
        } else {
            // we need to merge changes
            cls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].union(me.wrapperCls, value);
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].remove(cls, _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].difference(oldValue, value));
            vdom.cls = cls
        }

        me.update()
    }

    /**
     * Triggered after the disabled config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetDisabled(value, oldValue) {
        let cls = this.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"][value ? 'add' : 'remove'](cls, 'neo-disabled');
        this.cls = cls
    }



    /**
     * Triggered after the droppable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetDroppable(value, oldValue) {
        let me = this;

        if (value && !me.dropZone) {
            __webpack_require__.e(/*! import() */ "src_draggable_DropZone_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ../draggable/DropZone.mjs */ "./src/draggable/DropZone.mjs")).then(module => {
                me.dropZone = Neo.create({
                    module  : module.default,
                    appName : me.appName,
                    owner   : me,
                    windowId: me.windowId,
                    ...me.dropZoneConfig
                })
            })
        }
    }

    /**
     * Triggered after the height config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @protected
     */
    afterSetHeight(value, oldValue) {
        this.configuredHeight = addUnits(value);
        this.changeVdomRootKey('height', value)
    }

    /**
     * Triggered after the hidden config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetHidden(value, oldValue) {
        let me    = this,
            state = value ? 'hide' : 'show';

        if (value && oldValue === undefined && me.hideMode === 'removeDom') {
            me.vdom.removeDom = true
        } else if (value || oldValue !== undefined) {
            me[state]()
        }

        if (!value) {
            me.revertFocus();
        }

        me.fire(state, {id: me.id});
        me.fire('hiddenChange', {id: me.id, oldValue, value})
    }

    /**
     * Triggered after the html config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetHtml(value, oldValue) {
        this.changeVdomRootKey('html', value)
    }

    /**
     * Triggered after the id config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetId(value, oldValue) {
        super.afterSetId(value, oldValue);

        let me = this;

        if (me.configsApplied) {
            me.ensureStableIds();
            me.update()
        }
    }

    /**
     * Triggered after the isLoading config got changed
     * @param {Boolean|String} value
     * @param {Boolean|String} oldValue
     * @protected
     */
    afterSetIsLoading(value, oldValue) {
        if (value || oldValue !== undefined) {
            let me                 = this,
                {wrapperCls, vdom} = me,
                maskIndex;

            if (oldValue !== undefined && vdom.cn) {
                maskIndex = vdom.cn.findLastIndex(c => c.cls?.includes('neo-load-mask'));

                // Remove the load mask
                if (maskIndex !== -1) {
                    vdom.cn.splice(maskIndex, 1)
                }
            }

            if (value) {
                if (!vdom.cn) {
                    vdom.cn = []
                }

                vdom.cn.push(me.createLoadingMask(value))
            }

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].toggle(wrapperCls, 'neo-masked', value);
            me.set({vdom, wrapperCls})
        }
    }

    /**
     * Triggered after the maxHeight config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @protected
     */
    afterSetMaxHeight(value, oldValue) {
        this.configuredMaxHeight = addUnits(value);
        this.changeVdomRootKey('maxHeight', value)
    }

    /**
     * Triggered after the maxWidth config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @protected
     */
    afterSetMaxWidth(value, oldValue) {
        this.configuredMaxWidth = addUnits(value);
        this.changeVdomRootKey('maxWidth', value)
    }

    /**
     * Triggered after the minHeight config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @protected
     */
    afterSetMinHeight(value, oldValue) {
        this.configuredMinHeight = addUnits(value);
        this.changeVdomRootKey('minHeight', value)
    }

    /**
     * Triggered after the minWidth config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @protected
     */
    afterSetMinWidth(value, oldValue) {
        this.configuredMinWidth = addUnits(value);
        this.changeVdomRootKey('minWidth', value)
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        if (oldValue !== undefined) {
            let me = this;

            if (value) { // mount
                me.hasBeenMounted = true;

                if (me.floating) {
                    me.alignTo();

                    // Focus will be pushed into the first input field or other focusable item
                    me.focus(me.id, true)
                }

                me.fire('mounted', me.id);
            } else { // unmount
                me.revertFocus()
            }
        }
    }

    /**
     * Triggered after the reference config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetReference(value, oldValue) {
        value && this.changeVdomRootKey('data-ref', value)
    }

    /**
     * Triggered after the responsive config got changed
     * @param {Object} value
     * @param {Object} oldValue
     * @protected
     */
    async afterSetResponsive(value, oldValue) {
        if (value && !this.getPlugin('responsive')) {
            let me      = this,
                module  = await __webpack_require__.e(/*! import() */ "src_plugin_Responsive_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ../../src/plugin/Responsive.mjs */ "./src/plugin/Responsive.mjs")),
                plugins = me.plugins || [];

            plugins.push({
                module : module.default,
                appName: me.appName,
                value
            });

            me.plugins = plugins
        }
    }

    /**
     * Triggered after the role config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetRole(value, oldValue) {
        this.changeVdomRootKey('role', value)
    }

    /**
     * Triggered after the scrollable config got changed
     * @param {String|Boolean} value
     * @param {String|Boolean|null} oldValue
     * @protected
     */
    afterSetScrollable(value, oldValue) {
        if (oldValue === undefined && !value) {
            return
        }

        let me = this;

        if (oldValue) {
            let oldOverflowKey = 'overflow';

            if (!Neo.isBoolean(oldValue)) {
                oldOverflowKey += Neo.capitalize(oldValue)
            }

            me.removeStyle([oldOverflowKey])
        }

        if (!Neo.isEmpty(value)) {
            let overflowKey = 'overflow';

            if (value && !Neo.isBoolean(value)) {
                overflowKey += Neo.capitalize(value)
            }

            if (value) {
                me.addStyle(overflowKey + ':auto');
                me.addCls('neo-scrollable')
            } else {
                me.removeCls('neo-scrollable')
            }
        }
    }

    /**
     * Triggered after the style config got changed
     * @param {Object} value
     * @param {Object} oldValue
     * @protected
     */
    afterSetStyle(value, oldValue) {
        if (!(!value && oldValue === undefined)) {
            this.updateStyle()
        }
    }

    /**
     * Triggered after the tag config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetTag(value, oldValue) {
        value && this.changeVdomRootKey('tag', value)
    }

    /**
     * Triggered after the theme config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetTheme(value, oldValue) {
        if (value || oldValue !== undefined) {
            let me          = this,
                {cls}       = me,
                needsUpdate = false;

            if (oldValue && cls.includes(oldValue)) {
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].remove(cls, oldValue);
                needsUpdate = true
            }

            // We do not need to add a DOM based CSS selector, in case the theme is already inherited
            if (value !== me.parent?.theme) {
                value && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].add(cls, value);
                needsUpdate = true
            }

            if (needsUpdate) {
                me.cls = cls
            }
        }
    }

    /**
     * Triggered after the text config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetText(value, oldValue) {
        this.changeVdomRootKey('text', value)
    }

    /**
     * Triggered after the tooltip config got changed
     * @param {Object|String} value
     * @param {Object|String} oldValue
     * @protected
     */
    afterSetTooltip(value, oldValue) {
        oldValue?.destroy?.();

        if (value) {
            if (Neo.ns('Neo.tooltip.Base')) {
                this.createTooltip(value)
            } else {
                __webpack_require__.e(/*! import() */ "vendors-src_tooltip_Base_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ../tooltip/Base.mjs */ "./src/tooltip/Base.mjs")).then(() => {
                    this.createTooltip(value)
                })
            }
        }
    }

    /**
     * For styling purposes only.
     * To define button styles or component styles,
     * this will add a css class: neo-ntype-value
     * @param {String|null} value
     * @param {String|null} oldValue
     */
    afterSetUi(value, oldValue) {
        let me  = this,
            cls = me.cls;

        if (oldValue) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].remove(cls, `neo-${me.ntype}-${oldValue}`)
        }

        if (value && value !== '') {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].add(cls, `neo-${me.ntype}-${value}`)
        }

        me.cls = cls
    }

    /**
     * Triggered after the width config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @protected
     */
    afterSetWidth(value, oldValue) {
        this.configuredWidth = addUnits(value);
        this.changeVdomRootKey('width', value)
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        super.afterSetWindowId(value, oldValue);

        let controller = this.controller;

        if (controller) {
            controller.windowId = value
        }
    }

    /**
     * Triggered after the wrapperCls config got changed
     * @param {String[]|null} value
     * @param {String[]|null} oldValue
     * @protected
     */
    afterSetWrapperCls(value, oldValue) {
        oldValue = oldValue || [];
        value    = value    || [];

        let me       = this,
            {vdom}   = me,
            vdomRoot = me.getVdomRoot(),
            cls      = vdom.cls || [];

        if (vdom === vdomRoot) {
            // we need to merge changes
            cls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].union(cls, value);
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].remove(cls, _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].difference(oldValue, value));
            vdom.cls = cls
        } else {
            // we are not using a wrapper => cls & wrapperCls share the same node
            value = value ? value : [];

            oldValue && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].remove(cls, oldValue);
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].add(cls, value);

            vdom.cls = cls
        }

        me.update()
    }

    /**
     * Triggered after the wrapperStyle config got changed
     * @param {Object} value
     * @param {Object} oldValue
     * @protected
     */
    afterSetWrapperStyle(value, oldValue) {
        if (!(!value && oldValue === undefined)) {
            this.updateStyle()
        }
    }

    /**
     * Aligns the top level node inside the main thread
     * @param {Object} spec={}
     * @returns {Promise<void>}
     */
    async alignTo(spec={}) {
        const
            me    = this,
            align = {
                ...me.align,
                ...spec,
                id                 : me.id,
                configuredFlex     : me.configuredFlex,
                configuredWidth    : me.configuredWidth,
                configuredHeight   : me.configuredHeight,
                configuredMinWidth : me.configuredMinWidth,
                configuredMinHeight: me.configuredMinHeight,
                configuredMaxWidth : me.configuredMaxWidth,
                configuredMaxHeight: me.configuredMaxHeight,
                windowId           : me.windowId
            };

        if (align.target) {
            await Neo.main.DomAccess.align(align)
        }
    }

    /**
     * Triggered when accessing the cls config
     * @param {String[]|null} value
     * @protected
     */
    beforeGetCls(value) {
        return value ? [...value] : []
    }

    /**
     * Triggered when accessing the style config
     * @param {Object} value
     * @protected
     */
    beforeGetStyle(value) {
        return {...value}
    }

    /**
     * Triggered when accessing the wrapperCls config
     * @param {String[]|null} value
     * @protected
     */
    beforeGetWrapperCls(value) {
        return value ? [...value] : []
    }

    /**
     * Triggered when accessing the wrapperStyle config.
     *
     * It merges the current `vdom.style` into the result to ensure that runtime style mutations
     * (hacks) or initial VDOM styles are preserved and not overwritten by the config value.
     *
     * **Warning:** This creates the persistent state loop described in the `style_` config.
     * Reading the output (`vdom.style`) as the default for the input (`wrapperStyle`) means
     * merged styles become permanent unless explicitly cleared with `null`.
     *
     * @param {Object} value
     * @protected
     */
    beforeGetWrapperStyle(value) {
        return {...Object.assign(this.vdom.style || {}, value)}
    }

    /**
     * Triggered before the align config gets changed.
     * @param {Object|String} value
     * @param {Object} oldValue
     * @returns {Object}
     * @protected
     */
    beforeSetAlign(value, oldValue) {
        let me = this;

        // Just a simple 't-b'
        if (typeof value === 'string') {
            value = {
                edgeAlign: value
            }
        }

        return value
    }

    /**
     * Triggered before the cls config gets changed.
     * @param {String[]} value
     * @param {String[]} oldValue
     * @returns {String[]}
     * @protected
     */
    beforeSetCls(value, oldValue) {
        return _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].union(value || [], this.baseCls, this.getBaseClass());
    }

    /**
     * Triggered before the controller config gets changed.
     * Creates a controller.Component instance if needed.
     * @param {Neo.controller.Component|Object} value
     * @param {Neo.controller.Component|null} oldValue
     * @returns {Neo.controller.Component}
     * @protected
     */
    beforeSetController(value, oldValue) {
        oldValue?.destroy();

        if (value) {
            return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, 'Neo.controller.Component', {
                component: this,
                windowId : this.windowId
            })
        }

        return value
    }

    /**
     * Triggered before the domListeners config gets changed.
     * @param {Object|Object[]} value
     * @param {Object[]} oldValue
     * @returns {Object[]}
     * @protected
     */
    beforeSetDomListeners(value, oldValue) {
        if (Neo.isObject(value)) {
            value = [value]
        }

        return value || []
    }

    /**
     * Triggered before the hideMode config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @returns {String}
     * @protected
     */
    beforeSetHideMode(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'hideMode')
    }

    /**
     * Triggered before the keys config gets changed.
     * Creates a KeyNavigation instance if needed.
     * @param {Object} value
     * @param {Object} oldValue
     * @returns {Neo.util.KeyNavigation|null}
     * @protected
     */
    beforeSetKeys(value, oldValue) {
        oldValue?.destroy();

        if (value) {
            value = _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, _util_KeyNavigation_mjs__WEBPACK_IMPORTED_MODULE_3__["default"], {
                keyDownEventBubble: true,
                keys              : value
            })
        }

        return value
    }

    /**
     * Triggered before the plugins config gets changed.
     * @param {Object[]} value
     * @param {Object[]} oldValue
     * @returns {Neo.plugin.Base[]}
     * @protected
     */
    beforeSetPlugins(value, oldValue) {
        if (Array.isArray(value)) {
            value.forEach((item, index) => {
                value[index] = _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(item, null, {
                    owner: this
                })
            })
        }

        return value
    }

    /**
     * Triggered before the silentVdomUpdate config gets changed.
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @returns {Number}
     * @protected
     */
    beforeSetSilentVdomUpdate(value, oldValue) {
        if (value === true) {
            return Neo.isNumber(oldValue) ? (oldValue + 1) : 1
        }

        return (Neo.isNumber(oldValue) && oldValue > 0) ? (oldValue - 1) : 0
    }

    /**
     * Triggered before the updateDepth config gets changed.
     * @param {Number} value
     * @param {Number} oldValue
     * @returns {Number}
     * @protected
     */
    beforeSetUpdateDepth(value, oldValue) {
        if (oldValue === undefined) {
            return value
        }

        return oldValue === -1 || value === -1 ? -1 : Math.max(value, oldValue)
    }

    /**
     * Changes the value of a vdom object attribute or removes it in case it has no value
     * @param {String} key
     * @param {Array|Number|Object|String|null} value
     */
    changeVdomRootKey(key, value) {
        let me   = this,
            root = me.getVdomRoot();

        if (value) {
            root[key] = value
        } else {
            delete root[key]
        }

        me.update()
    }

    /**
     * Override this method in case you need different mask markups.
     * The removal logic relies on the top level node having the cls 'neo-load-mask'
     * @param {Boolean|String} loadingMessage
     * @returns {Object} vdom
     */
    createLoadingMask(loadingMessage) {
        return {
            cls: ['neo-load-mask'],
            cn : [{
                cls: ['neo-load-mask-body'],
                cn : [{
                    cls: this.loadingSpinnerCls
                }, {
                    cls      : ['neo-loading-message'],
                    removeDom: !Neo.isString(loadingMessage),
                    text     : loadingMessage
                }]
            }]
        }
    }

    /**
     * Creates the tooltip instances
     * @param {Object|String} value
     * @protected
     */
    createTooltip(value) {
        if (typeof value === 'string') {
            value = {
                text: value
            }
        }

        let me = this;

        if (value.ownInstance) {
            me._tooltip = Neo.create('Neo.tooltip.Base', {
                ...value,
                appName    : me.appName,
                componentId: me.id,
                windowId   : me.windowId
            })
        } else {
            me._tooltip = value;
            Neo.tooltip.Base.createSingleton(me.app);
            me.addCls('neo-uses-shared-tooltip');
            me.update()
        }
    }

    /**
     * Unregister this instance from the ComponentManager
     * @param {Boolean} updateParentVdom=false true to remove the component from the parent vdom => real dom
     * @param {Boolean} silent=false true to update the vdom silently (useful for destroying multiple child items in a row)
     * todo: unregister events
     */
    destroy(updateParentVdom=false, silent=false) {
        let me                 = this,
            {parent, parentId} = me,
            parentVdom;

        me.revertFocus();

        me.controller = null; // triggers destroy()

        me.reference && me.getController()?.removeReference(me); // remove own reference from parent controllers

        me.plugins?.forEach(plugin => {
            plugin.destroy()
        });

        if (updateParentVdom && parentId) {
            if (parentId === 'document.body') {
                Neo.applyDeltas(me.windowId, {action: 'removeNode', id: me.vdom.id})
            } else {
                parentVdom = parent.vdom;

                _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_8__["default"].removeVdomChild(parentVdom, me.vdom.id);
                parent[silent ? '_vdom' : 'vdom'] = parentVdom
            }
        }

        super.destroy();

        // We do want to prevent delayed calls after a component instance got destroyed.
        me.onFocusLeave = Neo.emptyFn;
        me.unmount      = Neo.emptyFn
    }

    /**
     * Convenience shortcut for Neo.manager.Component.down
     * @param {Object|String} config
     * @param {Boolean} returnFirstMatch=true
     * @returns {Neo.component.Base|null} The matching instance or null
     */
    down(config, returnFirstMatch=true) {
        return _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].down(this, config, returnFirstMatch)
    }

    /**
     * Calls focus() on the top level DOM node of this component or on a given node via id
     * @param {String} id=this.id
     * @param {Boolean} children=false
     * @param {Boolean} preventScroll
     */
    focus(id=this.id, children=false, preventScroll) {
        Neo.main.DomAccess.focus({children, id, preventScroll, windowId: this.windowId})
    }

    /**
     * Override this method to add dynamic values into this.cls
     * @returns {String[]}
     */
    getBaseClass() {
        const result = [];

        if (this.floating) {
            result.push('neo-floating')
        }

        return result
    }

    /**
     * Returns this.controller or the closest parent controller
     * @param {String} [ntype]
     * @returns {Neo.controller.Component|null}
     */
    getController(ntype) {
        let me = this,
            controller;

        if (!ntype) {
            controller = me[closestController];

            if (controller) {
                return controller
            }
        }

        controller = me.getConfigInstanceByNtype('controller', ntype);

        if (!ntype) {
            me[closestController] = controller
        }

        return controller
    }

    /**
     * Convenience shortcut
     * @param {String[]|String} id=this.id
     * @param {String} windowId=this.windowId
     * @returns {Promise<Neo.util.Rectangle|Neo.util.Rectangle[]>}
     */
    async getDomRect(id=this.id, windowId=this.windowId) {
        let result = await this.trap(Neo.main.DomAccess.getBoundingClientRect({id, windowId}));

        if (Array.isArray(result)) {
            return result.map(rect => _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].clone(rect))
        }

        return _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].clone(result)
    }

    /**
     * Get the parent components as an array
     * @returns {Neo.component.Base[]}
     */
    getParents() {
        return _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getParents(this)
    }

    /**
     * @param {Object|String} opts
     * @returns {Neo.plugin.Base|null}
     */
    getPlugin(opts) {
        if (Neo.isString(opts)) {
            if (!opts.startsWith('plugin-')) {
                opts = 'plugin-' + opts
            }

            opts = {ntype: opts}
        }

        let me = this,
            hasMatch;

        for (const plugin of me.plugins || []) {
            hasMatch = true;

            for (const key in opts) {
                if (plugin[key] !== opts[key]) {
                    hasMatch = false;
                    break
                }
            }

            if (hasMatch) {
                return plugin
            }
        }

        return null
    }

    /**
     * convenience shortcut
     * @param {String} value
     * @returns {Neo.component.Base|null}
     */
    getReference(value) {
        return this.down({reference: value})
    }

    /**
     * Walks up the vdom tree and returns the closest theme found
     * @returns {String}
     */
    getTheme() {
        let me         = this,
            themeMatch = 'neo-theme-',
            mainView, parentNodes;

        for (const item of me.cls || []) {
            if (item.startsWith(themeMatch)) {
                return item
            }
        }

        mainView = me.app?.mainView;

        if (mainView) {
            parentNodes = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_8__["default"].getParentNodes(mainView.vdom, me.id);

            for (const node of parentNodes || []) {
                for (const item of node.cls || []) {
                    if (item.startsWith(themeMatch)) {
                        return item
                    }
                }
            }
        }

        return Neo.config.themes?.[0]
    }

    /**
     * Hide the component.
     * hideMode: 'removeDom'  uses vdom removeDom.
     * hideMode: 'visibility' uses css visibility.
     * If hideMode === 'removeDom' you can pass a timeout for custom css class hiding.
     * @param {Number} timeout
     */
    hide(timeout) {
        let me = this;

        if (me.hideMode !== 'visibility') {
            let removeFn = function () {
                if (me.parentId !== 'document.body') {
                    me.vdom.removeDom = true;
                    me.parent.updateDepth = 2;
                    me.parent.update()
                } else {
                    me.unmount()
                }
            }

            if (timeout) {
                me.timeout(timeout).then(removeFn)
            } else {
                removeFn()
            }
        } else {
            let style = me.style;
            style.visibility = 'hidden';
            me.style = style
        }

        me._hidden = true
    }

    /**
     *
     */
    init() {
        this.autoInitVnode && this.initVnode()
    }

    /**
     * Check if this component or any of its parents is floating
     * @returns {Boolean}
     */
    isFloating() {
        let me = this;

        if (me.floating) {
            return true
        }

        if (!me.parent) {
            return false
        }

        return  me.parent.floating
    }

    /**
     * @param {Number|String} value
     * @returns {Promise<number>}
     */
    async measure(value) {
        if (value != null) {
            if (value.endsWith('px')) {
                value = parseFloat(value)
            } else if (lengthRE.test(value)) {
                let {id, windowId} = this;
                value = await this.trap(Neo.main.DomAccess.measure({id, value, windowId}))
            } else if (!isNaN(value)) {
                value = parseFloat(value)
            }
        }

        return value
    }

    /**
     * Override this method to change the order configs are applied to this instance.
     * @param {Object} config
     * @param {Boolean} [preventOriginalConfig] True prevents the instance from getting an originalConfig property
     * @returns {Object} config
     */
    mergeConfig(...args) {
        let config = super.mergeConfig(...args),
            vdom   = config.vdom || config._vdom || {};

        // It should be possible to modify root level vdom attributes on instance level.
        // Note that vdom is not a real config, but implemented via get() & set().
        this._vdom = Neo.clone({...vdom, ...this._vdom || {}}, true);

        this.ensureStableIds();

        delete config._vdom;
        delete config.vdom;

        return config
    }

    /**
     * Can get called after the component got vnodeInitialized. See the autoMount config as well.
     * We have decided to always force a new initVnode(true) call here.
     * Rationale:
     * 1. The overhead of tracking hasUnmountedVdomChanges on every vdom update is removed.
     * 2. The edge case of mounting a pre-calculated but untouched vnode tree is < 1%.
     * 3. The cost of re-generating the vnode tree is low enough to justify the robustness and simplicity.
     * 4. This ensures that the DOM is always mounted with the most up-to-date vdom state.
     */
    async mount() {
        return this.initVnode(true)
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();
        this.keys?.register(this)
    }

    /**
     * @param {Object} data
     */
    onScrollCapture(data) {
        super.onScrollCapture(data);

        let me = this;

        if (me._vdom) {
            let vdomNode = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_8__["default"].getById(me._vdom, data.target.id);

            if (vdomNode) {
                vdomNode.scrollTop  = data.scrollTop;
                vdomNode.scrollLeft = data.scrollLeft
            }
        }
    }

    /**
     * @param {Object} data
     */
    onFocusEnter(data) {
        // If we are hidden, or unmounted while we still contain focus, we have to revert
        // focus to where it came from if possible
        this.focusEnterData = data
    }

    /**
     * @param {Object} data
     */
    onFocusLeave(data) {
        this.focusEnterData = null
    }

    /**
     * Triggered by manager.Focus
     * @name onFocusEnter
     * @function
     * @param {Array} path dom element ids upwards
     */

    /**
     * Triggered by manager.Focus
     * @name onFocusLeave
     * @function
     * @param {Array} path dom element ids upwards
     */

    /**
     * Triggered by manager.Focus
     * @name onFocusMove
     * @function
     * @param {Object} opts
     * @param {Array}  opts.newPath dom element ids upwards
     * @param {Array}  opts.oldPath dom element ids upwards
     */

    /**
     * Remove a cls from the vdomRoot
     * @param {String} value
     */
    removeCls(value) {
        let cls = this.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].remove(cls, value);
        this.cls = cls
    }



    /**
     * Either a string like 'color' or an array containing style attributes to remove
     * @param {String|Array} value camelCase only
     * @returns {Object} all styles of this.el
     */
    removeStyle(value) {
        if (!Array.isArray(value)) {
            value = [value]
        }

        let {style}  = this,
            doUpdate = false;

        Object.keys(style).forEach(key => {
            if (value.indexOf(key) > -1) {
                delete style[key];
                doUpdate = true
            }
        });

        if (doUpdate) {
            this.style = style
        }

        return style
    }

    /**
     *
     */
    revertFocus() {
        let relatedTarget = this.focusEnterData?.relatedTarget;

        if (this.containsFocus && relatedTarget) {
            Neo.getComponent(relatedTarget.id)?.focus()
        }
    }

    /**
     * Show the component.
     * hideMode: 'removeDom'  uses vdom removeDom.
     * hideMode: 'visibility' uses css visibility.
     */
    show() {
        let me = this;

        if (me.hideMode !== 'visibility') {
            delete me.vdom.removeDom;

            if (me.silentVdomUpdate) {
                me.needsVdomUpdate = true
            } else if (me.parentId !== 'document.body') {
                me.parent.updateDepth = -1;
                me.parent.update()
            } else {
                !me.mounted && me.initVnode(true)
            }
        } else {
            let style = me.style;
            // We need to set null, since the style might be inside wrapperStyle,
            // which would get re-applied in case we just delete the property.
            style.visibility = null;
            me.style = style
        }

        me._hidden = false
    }

    /**
     * Toggle a cls inside the vdomRoot of the component
     * @param {String} value
     * @param {Boolean} [add] Use this param to enforce an add() or remove() operation.
     */
    toggleCls(value, add) {
        let cls = this.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].toggle(cls, value, add);
        this.cls = cls
    }

    /**
     * Removes the component DOM
     */
    unmount() {
        let me = this;

        me.vdom.removeDom = true;

        me._hidden = true; // silent update
        me.mounted = false;

        Neo.applyDeltas(me.windowId, {action: 'removeNode', id: me.vdom.id})
    }

    /**
     * Convenience shortcut for Neo.manager.Component.up
     * @param {Object|String} config
     * @returns {Neo.component.Base|null} The matching instance or null
     */
    up(config) {
        return _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].up(this.id, config)
    }

    /**
     * Serializes the component into a JSON-compatible object.
     * Extends the core.Base serialization with component-specific properties.
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            align       : me.align,
            cls         : me.cls,
            controller  : me.controller?.toJSON(),
            disabled    : me.disabled,
            height      : me.height,
            hidden      : me.hidden,
            keys        : me.keys?.toJSON(),
            reference   : me.reference,
            role        : me.role,
            style       : me.style,
            theme       : me.theme,
            ui          : me.ui,
            vdom        : me.vdom,
            vnode       : me.vnode,
            width       : me.width,
            wrapperCls  : me.wrapperCls,
            wrapperStyle: me.wrapperStyle
        }
    }

    /**
     *
     */
    updateStyle() {
        let me       = this,
            {vdom}   = me,
            vdomRoot = me.getVdomRoot();

        if (vdom !== vdomRoot) {
            vdom    .style = me.wrapperStyle;
            vdomRoot.style = me.style
        } else {
            vdom.style = {...me.wrapperStyle, ...me.style}
        }

        me.update()
    }

    /**
     * In case you are sure a DOMRect exists, use getDomRect()
     * Otherwise you can wait for it using this method.
     * @example:
     *     await this.initVnode(true);
     *     await this.waitForDomRect();
     * @param {Object}          opts
     * @param {Number}          opts.attempts=10 Reruns in case the rect height or width equals 0
     * @param {Number}          opts.delay=50    Time in ms before checking again
     * @param {String[]|String} opts.id=this.id
     * @param {String}          opts.windowId=this.windowId
     * @returns {Promise<Neo.util.Rectangle|Neo.util.Rectangle[]>}
     */
    async waitForDomRect({attempts=10, delay=50, id=this.id, windowId=this.windowId} = {}) {
        let me     = this,
            result = await me.getDomRect(id),
            reRun  = false;

        if (Array.isArray(result)) {
            result.forEach(rect => {
                if (rect.height < 1 || rect.width < 1) {
                    reRun = true
                }
            })
        } else if (result.height < 1 || result.width < 1) {
            reRun = true
        }

        if (reRun && attempts > 0) {
            await me.timeout(delay);
            return await me.waitForDomRect({attempts: attempts-1, delay, id, windowId})
        }

        return result
    }
}

/**
 * manager.Focus fires the event after focusEnter, focusLeave or focusMove
 * @event focusChange
 * @param {Object} data
 * @param {Object[]} [data.path] dom element ids upwards
 * @param {Object[]} [data.oldPath] dom element ids upwards
 */

/**
 * manager.Focus fires the event when the component id is included inside the dom id path
 * @event focusEnter
 * @param {Object} data
 * @param {Object[]} data.path dom element ids upwards
 */

/**
 * manager.Focus fires the event when the component id is not included inside the dom id path
 * @event focusLeave
 * @param {Object} data
 * @param {Object[]} data.oldPath dom element ids upwards
 */

/**
 * manager.Focus fires the event when the component id is included inside the dom id path, but the path itself changed
 * @event focusMove
 * @param {Object} data
 * @param {Object[]} data.path dom element ids upwards
 * @param {Object[]} data.oldPath dom element ids upwards
 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Component));


/***/ },

/***/ "./src/component/Canvas.mjs"
/*!**********************************!*\
  !*** ./src/component/Canvas.mjs ***!
  \**********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/component/Base.mjs");


/**
 * @class Neo.component.Canvas
 * @extends Neo.component.Base
 */
class Canvas extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.Canvas'
         * @protected
         */
        className: 'Neo.component.Canvas',
        /**
         * @member {String} ntype='canvas'
         * @protected
         */
        ntype: 'canvas',
        /**
         * true applies a main.addon.ResizeObserver and fires a custom resize event
         * which other instances can subscribe to.
         * @member {Boolean} monitorSize_=true
         * @reactive
         */
        monitorSize_: true,
        /**
         * @member {Boolean} offscreen=true
         */
        offscreen: true,
        /**
         * Only applicable if offscreen === true.
         * true once the ownership of the canvas node got transferred to worker.Canvas.
         * @member {Boolean} offscreenRegistered_=false
         * @reactive
         */
        offscreenRegistered_: false,
        /**
         * @member {Object} _vdom={tag: 'canvas'}
         */
        _vdom:
        {tag: 'canvas'}
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    async afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        let me                    = this,
            id                    = me.getCanvasId(),
            {offscreen, windowId} = me;

        if (value) {
            await me.timeout(30); // next rAF tick

            if (me.monitorSize) {
                me.addDomListeners([{
                    delegate: `#${me.getMonitorTargetId()}`,
                    resize  : me.onDomResize,
                    scope   : me
                }])
            }

            if (offscreen) {
                let data,
                    delay = 50;

                while (me.mounted && !me.offscreenRegistered && !me.isDestroyed) {
                    data = await Neo.main.DomAccess.getOffscreenCanvas({
                        nodeId: id,
                        windowId
                    });

                    if (data.offscreen) {
                        await Neo.worker.Canvas.registerCanvas({
                            node  : data.offscreen,
                            nodeId: id,
                            windowId
                        }, [data.offscreen]);

                        me.offscreenRegistered = true;
                        break
                    } else if (data.transferred) {
                        if (Neo.config.useSharedWorkers) {
                            let retrieveData = await Neo.worker.Canvas.retrieveCanvas({
                                nodeId: id,
                                windowId
                            });

                            if (retrieveData.hasCanvas) {
                                me.offscreenRegistered = true;
                                break
                            }
                        }
                    }

                    await me.timeout(delay);

                    if (delay < 1000) {
                        delay *= 2
                    }
                }
            }
        } else if (offscreen) {
            if (me.offscreenRegistered) {
                Neo.worker.Canvas.unregisterCanvas({
                    nodeId: id
                })
            }

            me.offscreenRegistered = false
        }
    }


    /**
     * Triggered after the windowId config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        super.afterSetWindowId(value, oldValue);

        if (oldValue) {
            this.offscreenRegistered = false
        }
    }

    /**
     * @param {...*} args
     */
    destroy(...args) {
        if (this.offscreenRegistered) {
            Neo.worker.Canvas.unregisterCanvas({
                nodeId: this.id
            })
        }

        super.destroy(...args)
    }

    /**
     * Override this method when using wrappers (e.g. D3)
     * @returns {String}
     */
    getCanvasId() {
        return this.id
    }

    /**
     * The DOM node ID that should trigger the canvas resize updates.
     * By default, this is the component's top-level wrapper ID.
     * Subclasses can override this to observe a different node (e.g. a parent container).
     * @returns {String}
     */
    getMonitorTargetId() {
        return this.vdom.id
    }

    /**
     * @param {Object} data
     */
    onDomResize(data) {
        this.fire('resize', data)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Canvas));


/***/ },

/***/ "./src/component/Label.mjs"
/*!*********************************!*\
  !*** ./src/component/Label.mjs ***!
  \*********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/component/Base.mjs");


/**
 * Convenience class to render a label with a text
 * @class Neo.component.Label
 * @extends Neo.component.Base
 */
class Label extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.Label'
         * @protected
         */
        className: 'Neo.component.Label',
        /**
         * @member {String} ntype='label'
         * @protected
         */
        ntype: 'label',
        /**
         * @member {String[]} baseCls=['neo-label']
         */
        baseCls: ['neo-label'],
        /**
         * @member {String} tag='label'
         * @protected
         * @reactive
         */
        tag: 'label'
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Label));


/***/ },

/***/ "./src/container/Base.mjs"
/*!********************************!*\
  !*** ./src/container/Base.mjs ***!
  \********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _layout_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../layout/Base.mjs */ "./src/layout/Base.mjs");
/* harmony import */ var _layout_Card_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../layout/Card.mjs */ "./src/layout/Card.mjs");
/* harmony import */ var _layout_Fit_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../layout/Fit.mjs */ "./src/layout/Fit.mjs");
/* harmony import */ var _layout_Grid_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../layout/Grid.mjs */ "./src/layout/Grid.mjs");
/* harmony import */ var _layout_HBox_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../layout/HBox.mjs */ "./src/layout/HBox.mjs");
/* harmony import */ var _layout_VBox_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../layout/VBox.mjs */ "./src/layout/VBox.mjs");
/* harmony import */ var _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../util/Logger.mjs */ "./src/util/Logger.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../core/ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");











const byWeight = ({ weight : lhs = 0 }, { weight : rhs = 0 }) => lhs - rhs;

/**
 * @class Neo.container.Base
 * @extends Neo.component.Base
 */
class Container extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.container.Base'
         * @protected
         */
        className: 'Neo.container.Base',
        /**
         * @member {String} ntype='container'
         * @protected
         */
        ntype: 'container',
        /**
         * @member {String[]} baseCls=['neo-container']
         */
        baseCls: ['neo-container'],
        /**
         * @member {Boolean} dragResortable_=false
         * @reactive
         */
        dragResortable_: false,
        /**
         * Default configuration for child items within this container.
         * This config uses a descriptor to enable deep merging with instance based itemDefaults.
         * @member {Object} itemDefaults_={[isDescriptor]: true, merge: 'deep', value: null}
         * @reactive
         */
        itemDefaults_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_9__.isDescriptor]: true,
            merge         : 'deep',
            value         : null
        },
        /**
         * An array or an object of config objects|instances|modules for each child component
         * @member {Object[]} items_=[]
         * @example
         * import Button      from '../button/Base.mjs';
         * import Toolbar     from '../toolbar/Base.mjs';
         *
         * let myButton = Neo.create(Button, {
         *     text: 'Button1'
         * });
         *
         * Neo.create(Toolbar, {
         *     //...
         *     items: {
         *         buttonRef : {
         *             ntype: 'button',   // by ntype
         *             text : 'Button 2'
         *         },
         *         secondRef : {
         *             module: Button,    // by imported module
         *             text  : 'Button 3'
         *         }
         *     }
         * });
         *
         * or
         * @example
         * import Button      from '../button/Base.mjs';
         * import MyRedButton from 'myapp/MyRedButton.mjs';
         * import Toolbar     from '../toolbar/Base.mjs';
         *
         * let myButton = Neo.create(Button, {
         *     text: 'Button1'
         * });
         *
         * Neo.create(Toolbar, {
         *     //...
         *     items: [
         *         myButton,              // passed instance
         *         {
         *             ntype: 'button',   // by ntype
         *             text : 'Button 2'
         *         },
         *         {
         *             module: Button,    // by imported module
         *             text  : 'Button 3'
         *         },
         *         MyRedButton            // you can drop imported modules directly into the items array
         *     ]
         * });
         * @reactive
         */
        items_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_9__.isDescriptor]: true,
            clone         : 'shallow',
            cloneOnGet    : 'none',
            isEqual       : () => false,
            value         : []
        },
        /**
         * @member {Object|String|null} layout_={ntype: 'vbox', align: 'stretch'}
         * @reactive
         */
        layout_: {
            ntype: 'vbox',
            align: 'stretch'
        },
        /**
         * @member {Neo.draggable.container.SortZone|null} sortZone=null
         */
        sortZone: null,
        /**
         * @member {String} sortZoneCls='Neo.draggable.container.SortZone'
         */
        sortZoneCls: 'Neo.draggable.container.SortZone',
        /**
         * @member {Object} sortZoneConfig=null
         */
        sortZoneConfig: null,
        /**
         * @member {Object} _vdom={cn: []}
         */
        _vdom:
        {cn: []}
    }

    /**
     * Inserts an item or array of items at the last index
     * @param {Object|Array} item
     * @param {Boolean} [silent=false]
     * @param {Boolean} [removeFromPreviousParent=true]
     * @returns {Neo.component.Base|Neo.component.Base[]}
     */
    add(item, silent=false, removeFromPreviousParent=true) {
        let me = this;
        return me.insert(me.items ? me.items.length : 0, item, silent, removeFromPreviousParent)
    }

    /**
     * Triggered after the appName config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetAppName(value, oldValue) {
        let me = this;

        super.afterSetAppName(value, oldValue);

        if (value && me.items) {
            me.items.forEach(item => {
                if (!Neo.isString(item)) {
                    item.appName = value
                }
            })
        }

        if (value && me.layout) {
            me.layout.appName = value
        }

        if (me.sortZone) {
            me.sortZone.appName = value
        }
    }

    /**
     * @param {Neo.layout.Base|null} value
     * @param {Neo.layout.Base|null} oldValue
     * @protected
     */
    afterSetLayout(value, oldValue) {
        let me = this;

        if (me.vnodeInitialized) {
            oldValue?.removeRenderAttributes();
            value?.applyRenderAttributes();

            me.items.forEach((item, index) => {
                oldValue?.removeChildAttributes(item, index);
                value?.applyChildAttributes(item, index)
            })
        }

        oldValue?.destroy?.()
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        if (oldValue !== undefined) {
            super.afterSetMounted(value, oldValue);

            for (let i = 0, {items} = this, {length} = items; i < length; i++) {
                if (!items[i].vdom.removeDom) {
                    items[i].mounted = value
                }
            }
        }
    }

    /**
     * Triggered after the needsVdomUpdate config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetNeedsVdomUpdate(value, oldValue) {
        if (!value) {
            this.items?.forEach(item => {
                // check for e.g. Toolbar items like '->'
                if (typeof item !== 'string') {
                    // we can not set the config directly => it could already be false,
                    // and we still want to pass it further into subtrees
                    item._needsVdomUpdate = false;
                    item.afterSetNeedsVdomUpdate?.(false, true)
                }
            })
        }
    }

    /**
     * Triggered after the vnodeInitializing config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetIsVnodeInitializing(value, oldValue) {
        if (oldValue !== undefined) {
            let {items} = this,
                i       = 0,
                len     = items.length;

            for (; i < len; i++) {
                if (!items[i].vdom.removeDom) {
                    items[i].isVnodeInitializing = value
                }
            }
        }
    }

    /**
     * Triggered after the dragResortable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    async afterSetDragResortable(value, oldValue) {
        let me = this,
            module;

        if (value && !me.sortZone) {
            if (me.sortZoneConfig?.module) {
                module = me.sortZoneConfig.module;

                if (!me.isConstructed) {
                    await Promise.resolve()
                }
            } else {
                module = await me.loadSortZoneModule();
                module = module.default
            }

            me.createSortZone(Neo.merge({
                module,
                appName            : me.appName,
                boundaryContainerId: me.id,
                owner              : me,
                windowId           : me.windowId
            }, me.sortZoneConfig))
        }
    }

    /**
     * Triggered after the theme config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetTheme(value, oldValue) {
        super.afterSetTheme(value, oldValue);

        value && this.items?.forEach(item => {
            if (!Neo.isString(item)) {
                item.theme = value
            }
        })
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        super.afterSetWindowId(value, oldValue);

        let me       = this,
            {layout} = me;

        value && me.items?.forEach(item => {
            if (!Neo.isString(item)) {
                item.windowId = value
            }
        })

        if (value && layout && !Neo.isString(layout)) {
            layout.windowId = value
        }

        if (me.sortZone) {
            me.sortZone.windowId = value
        }
    }

    /**
     * Convert items object to an array for onward storage as _items
     * @param {Object|Object[]} value
     * @param {Object|Object[]} oldValue
     * @returns {Object[]}
     * @protected
     */
     beforeSetItems(value, oldValue) {
        if (Neo.typeOf(value) === 'Object') {
            let result = [],
                hasWeight, item;

            for (const ref in value) {
                item = value[ref]

                item.reference = ref;
                result.push(item);
                hasWeight ||= ('weight' in item)
            }

            if (hasWeight) {
                result.sort(byWeight)
            }

            value = result
        }

        return value
    }

    /**
     * @param {Object|String} value
     * @param {Object|String|Neo.layout.Base} oldValue
     * @returns {Neo.layout.Base}
     * @protected
     */
    beforeSetLayout(value, oldValue) {
        return this.createLayout(value)
    }

    /**
     * @param {*} item
     * @param {Number} index
     * @param {Boolean} [removeFromPreviousParent=true]
     * @returns {Neo.component.Base|Object} Object for lazy loaded items
     */
    createItem(item, index, removeFromPreviousParent=true) {
        let me       = this,
            config   = {appName: me.appName, parentId: me.id, parentIndex: index, windowId: me.windowId},
            defaults = {...me.itemDefaults},
            lazyLoadItem, module, parent;

        if (defaults) {
            if (item.module) {
                delete defaults.ntype;
            }

            if (item.ntype) {
                delete defaults.module;
            }
        }

        switch (Neo.typeOf(item)) {
            case 'NeoClass': {
                item = Neo.create({
                    theme: item.config.theme || me.theme,
                    ...defaults,
                    module: item,
                    ...config
                });
                break
            }

            case 'NeoInstance': {
                parent = item.parent;

                if (parent && parent !== me) {
                    if (removeFromPreviousParent) {
                        parent.remove?.(item, false);
                        delete item.vdom.removeDom
                    }

                    if (parent.windowId !== me.windowId) {
                        // In case we are duplicating vdom into a different browser window, we need a silent
                        // _mounted update to ensure that afterSetMounted() still gets triggered.
                        item[removeFromPreviousParent ? 'mounted' : '_mounted'] = false
                    }

                    // Convenience logic, especially for moving components into different browser windows:
                    // A component might rely on references & handler methods inside the previous controller realm
                    // todo: We need ?. until functional.component.Base supports controllers
                    if (!item.controller && !me.getController() && parent.getController?.()) {
                        item.controller = {parent: parent.getController()}
                    }
                }

                item.set(config);
                item.getStateProvider?.()?.createBindings(item);
                break
            }

            case 'Object': {
                if (defaults) {
                    Neo.assignDefaults(item, defaults)
                }

                if (!item.module && !item.ntype && !item.className) {
                    item.module = _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]
                }

                module = item.module;

                lazyLoadItem = module && !module.isClass && Neo.isFunction(module);

                if (module && !lazyLoadItem) {
                    item.className = module.prototype.className;
                    item.theme     = defaults.theme || module.config.theme || me.theme
                }

                if (item.handlerScope === 'this') {
                    item.handlerScope = me;

                    if (Neo.typeOf(item.handler) === 'String' && Neo.typeOf(me[item.handler]) === 'Function') {
                        item.handler = me[item.handler]
                    }
                }

                Object.assign(item, config);

                if (!lazyLoadItem) {
                    item = Neo[item.className ? 'create' : 'ntype'](item)
                } else {
                    item.vdom = Object.assign(item.vdom || {}, {removeDom: true})
                }

                break
            }

            case 'String': {
                item = Neo.create({
                    module: _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                    vdom  : {text: item},
                    ...config
                });

                break
            }
        }

        return item
    }

    /**
     * @protected
     */
    createItems() {
        let me        = this,
            items     = me._items,
            itemsRoot = me.getVdomItemsRoot(),
            {layout}  = me,
            vdom;

        itemsRoot.cn = [];

        items.forEach((item, index) => {
            items[index] = item = me.createItem(item, index);

            if (item instanceof Neo.core.Base) {
                layout?.applyChildAttributes(item, index);
                vdom = item.createVdomReference()
            } else {
                vdom = item.vdom
            }

            itemsRoot.cn.push(vdom)
        });

        // We need to add items into the vdom
        me.updateDepth = -1;
        me.isConstructed && me.update();

        me.fire('itemsCreated', {id: me.id, items})
    }

    /**
     * @param {Object|String|Neo.layout.Base} value
     * @protected
     * @returns {Neo.layout.Base}
     */
    createLayout(value) {
        if (value) {
            let me                      = this,
                {appName, id, windowId} = me;

            if (value instanceof _layout_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] && value.isLayout) {
                Object.assign(value, {appName, containerId: id, windowId})
            } else {
                value = me.parseLayoutClass(value);
                Object.assign(value, {appName, containerId: id, windowId});
                value = Neo.ntype(value)
            }
        }

        return value
    }

    /**
     * @param {Object} config
     */
    createSortZone(config) {
        this.sortZone = Neo.create(config)
    }

    /**
     * Destroys all components inside this.items before the super() call.
     * @param {Boolean} [updateParentVdom=false] true to remove the component from the parent vdom => real dom
     * @param {Boolean} [silent=false] true to update the vdom silently (useful for destroying multiple child items in a row)
     */
    destroy(updateParentVdom=false, silent=false) {
        this.layout?.destroy();

        this.items?.forEach(item => {
            item.destroy?.(false, true)
        });

        super.destroy(updateParentVdom, silent)
    }

    /**
     * An alternative for `getReference()` which is useful before a component tree got created.
     * `getReference()` relies on child items being registered inside `manager.Component`,
     * while this method simply walks down the items array.
     *
     * However, classes / modules inside the items tree can not get parsed further.
     * @param {String} reference
     * @param {Object[]} items=this.items
     * @returns {Object|Neo.component.Base|null}
     */
    getItem(reference, items=this.items) {
        let i   = 0,
            len = items.length,
            childItem, item;

        for (; i < len; i++) {
            item = items[i];
            if (item.reference === reference) {
                return item
            } else if (item.items) {
                childItem = this.getItem(reference, item.items);

                if (childItem) {
                    return childItem
                }
            }
        }

        return null
    }

    /**
     * Specify a different vdom items root if needed (useful in case this container uses a wrapper node).
     * @returns {Object} The new vdom items root
     */
    getVdomItemsRoot() {
        return this.getVdomRoot()
    }

    /**
     * Finds the index of a direct child component inside this.items.
     * @param {Neo.component.Base|String} itemId Either the item reference or the item id
     * @returns {Number} -1 in case no match was found
     */
    indexOf(itemId) {
        let me  = this,
            i   = 0,
            len = me.items?.length || 0;

        if (!Neo.isString(itemId)) {
            itemId = itemId.id;
        }

        for (; i < len; i++) {
            if (me.items[i].id === itemId) {
                return i
            }
        }

        return -1
    }

    /**
     * Inserts an item or array of items at a specific index.
     *
     * **Atomic Moves:**
     * If the `item` is an existing `Neo.component.Base` instance that already has a parent container
     * within the same browser window, this method performs an **atomic move**.
     * 1. The item is silently removed from its old parent (without triggering a DOM removal).
     * 2. The item is inserted into this container.
     * 3. This container updates, sending an `insertNode` delta.
     * 4. The `DeltaUpdates` system detects the existing DOM node and moves it physically, preserving
     *    DOM state such as focus, input values, and iframe content.
     *
     * @param {Number} index
     * @param {Array|Object|Neo.component.Base} item
     * @param {Boolean} [silent=false]
     * @param {Boolean} [removeFromPreviousParent=true]
     * @returns {Neo.component.Base|Neo.component.Base[]}
     */
    insert(index, item, silent=false, removeFromPreviousParent=true) {
        let me          = this,
            {items}     = me,
            lca         = null,
            i, itemParent, itemType, len, oldParent, parentsA, parentsB, returnArray;

        if (Array.isArray(item)) {
            i           = 0;
            len         = item.length;
            returnArray = [];

            for (; i < len; i++) {
                // insert the array backwards
                returnArray.unshift(me.insert(index, item[len - 1 - i], true, removeFromPreviousParent))
            }

            item = returnArray
        } else {
            itemType = Neo.typeOf(item);

            if (itemType === 'NeoInstance') {
                itemParent = item.parent;

                if (itemParent === me && items.indexOf(item) === index) {
                    return item
                }

                if (itemParent && itemParent !== me && removeFromPreviousParent) {
                    oldParent = itemParent;

                    if (oldParent.windowId === me.windowId) {
                        parentsA = [me,        ...me.getParents()];
                        parentsB = [oldParent, ...oldParent.getParents()];

                        lca = parentsA.find(p => parentsB.includes(p))
                    }

                    if (lca) {
                        oldParent.remove(item, false, true, true);
                        removeFromPreviousParent = false
                    }
                }
            }

            item = me.createItem(item, index, removeFromPreviousParent);

            // added the true param => for card layouts, we do not want a dynamically inserted cmp to get removed right away
            // since it will most likely get activated right away
            me.layout?.applyChildAttributes(item, index, true);

            items.splice(index, 0, item);

            me.items = items;

            me.getVdomItemsRoot().cn.splice(index, 0, item.createVdomReference())
        }

        if (!silent) {
            (lca || me).updateDepth = -1; // pass the full vdom tree to honor new nested component trees

            (lca || me).promiseUpdate().then(() => {
                me.fire('insert', {index, item})
            })
        }

        return item;
    }

    /**
     * Load items from a remote endpoint.
     * See: https://github.com/neomjs/neo/tree/dev/examples/serverside
     * The response should return a JSON file in the following format:
     * {"modules": [], "items": []}
     * See: https://github.com/neomjs/neo/blob/dev/examples/serverside/gridContainer/resources/data/grid-container.json
     * It is important to add modules which are not already imported inside your app yet.
     * @param {Object} data
     * @param {Object} [data.options={}]
     * @param {String} data.url
     * @returns {Promise<Object[]>}
     */
    async loadItems({options={}, url}) {
        let me         = this,
            response   = await me.trap(fetch(url, options)),
            remoteData = await me.trap(response.json());

        if (remoteData.modules?.length > 0) {
            await me.trap(Promise.all(remoteData.modules.map(modulePath => {
                // Adjust relative URLs
                if (!modulePath.startsWith('http')) {
                    modulePath = (Neo.config.environment === 'development' ? '../../' : '../../../../') + modulePath
                }

                return import(/* webpackIgnore: true */ modulePath)
            })))
        }

        return remoteData.items
    }

    /**
     * @returns {Promise<any>}
     */
    loadSortZoneModule() {
        return Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("vendors-src_draggable_container_SortZone_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ../draggable/container/SortZone.mjs */ "./src/draggable/container/SortZone.mjs"))
    }

    /**
     *
     */
    mergeConfig(...args) {
        let me     = this,
            config = super.mergeConfig(...args),
            ctorItems;

        // Avoid any interference on prototype level
        // Does not clone existing Neo instances
        if (config.items) {
            ctorItems = me.constructor.config.items;

            // If we are passed an object, merge the class's own items object into it
            if (Neo.typeOf(config.items) === 'Object') {
                if (Neo.isArray(ctorItems)) {
                    me.items = Neo.clone(config.items, true, true)
                } else {
                    me.items = Neo.merge(Neo.clone(ctorItems), config.items)
                }
            } else {
                me._items = Neo.clone(config.items, true, true)
            }
            delete config.items
        }

        return config
    }

    /**
     * Moves an existing item to a new index
     * @param {Number} fromIndex
     * @param {Number} toIndex
     * @returns {Neo.component.Base}
     */
    moveTo(fromIndex, toIndex) {
        let me   = this,
            item = me.items[fromIndex];

        fromIndex !== toIndex && me.switchItems(toIndex, fromIndex);

        return item
    }

    /**
     *
     */
    onConstructed() {
        let me           = this,
            layoutConfig = me.layout;

        // If the layout is a config object (not an instance), deep clone it
        // to prevent prototype pollution.
        if (layoutConfig && !(layoutConfig instanceof _layout_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"])) {
            layoutConfig = Neo.clone(layoutConfig, true)
        }

        // in case the Container does not have a layout config, the setter won't trigger
        me._layout = me.createLayout(layoutConfig);
        me._layout?.applyRenderAttributes();

        super.onConstructed();

        me.parseItemConfigs(me._items);
        me.createItems()
    }

    /**
     * @param {Object|String} config
     * @protected
     * @returns {Object} layoutConfig
     */
    parseLayoutClass(config) {
        if (Neo.isObject(config)) {
            if (!config.ntype.startsWith('layout-')) {
                config.ntype = `layout-${config.ntype}`
            }
        } else {
            config = {
                ntype: config.startsWith('layout-') ? config : `layout-${config}`
            }
        }

        return config
    }

    /**
     * Removes a container item by reference
     * @param {Neo.component.Base} component
     * @param {Boolean} [destroyItem=true]
     * @param {Boolean} [silent=false]
     * @param {Boolean} [keepMounted=false]
     * @returns {Neo.component.Base|null}
     */
    remove(component, destroyItem=true, silent=false, keepMounted=false) {
        let items = [...this.items],
            i     = 0,
            len   = items.length;

        for (; i < len; i++) {
            if (items[i].id === component.id) {
                return this.removeAt(i, destroyItem, silent, keepMounted)
            }
        }
    }

    /**
     * Clears the item array
     * @param {Boolean} destroyItems=true
     * @param {Boolean} silent=false
     */
    removeAll(destroyItems=true, silent=false) {
        let me = this;

        me.items.forEach(item => {
            if (destroyItems) {
                item.destroy(true, true)
            } else {
                item.mounted = false
            }
        });

        me.items = [];

        me.getVdomItemsRoot().cn = [];

        if (!silent || destroyItems) {
            me.update()
        }
    }

    /**
     * Removes a container item at a given index.
     *
     * @param {Number} index
     * @param {Boolean} destroyItem=true
     * @param {Boolean} silent=false
     * @param {Boolean} keepMounted=false Set to `true` to keep the item's `mounted` state as `true`.
     * This is critical for **Atomic Moves**, where the item is removed from one container and immediately added
     * to another, and we do not want to trigger unmount lifecycle hooks in between.
     * @returns {Neo.component.Base|null}
     */
    removeAt(index, destroyItem=true, silent=false, keepMounted=false) {
        let me      = this,
            {items} = me,
            item;

        if (index >= items.length) {
            Neo.warn('Container.removeAt: index >= items.length. ' + me.id)
        } else {
            item = items[index];

            items.splice(index, 1);

            me.getVdomItemsRoot().cn.splice(index, 1);

            // the next update cycle needs to include direct children
            me.updateDepth = 2;

            !silent && me.update();

            if (destroyItem) {
                item.destroy(true, silent);
                return null
            } else {
                me.layout?.removeChildAttributes(item);
                if (!keepMounted) {
                    item.mounted = false
                }
                return item
            }
        }
    }

    /**
     * Removes the container item at the last index
     * @param {Boolean} [destroyItem=true]
     * @param {Boolean} [silent=false]
     */
    removeLast(destroyItem=true, silent=false) {
        this.removeAt(this.items.length - 1, destroyItem, silent)
    }

    /**
     * Replaces a container item at a given index
     * @param {Number} index
     * @param {Neo.component.Base} item
     * @param {Boolean} destroyItem=true
     * @param {Boolean} silent=false
     */
    replaceAt(index, item, destroyItem=true, silent=false) {
        this.removeAt(index, destroyItem, true);
        this.insert(index, item, silent)
    }

    /**
     * Switches the position of 2 direct child items
     * You can either pass an index (Number) or id (String)
     * @param {Number|String} item1id
     * @param {Number|String} item2id
     */
    switchItems(item1id, item2id) {
        let me         = this,
            item1Index = Neo.isNumber(item1id) ? item1id : me.indexOf(item1id),
            item2Index = Neo.isNumber(item2id) ? item2id : me.indexOf(item2id);

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_8__["default"].move(me.items,                 item2Index, item1Index);
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_8__["default"].move(me.getVdomItemsRoot().cn, item2Index, item1Index);

        // the next update cycle needs to include direct children
        me.updateDepth = 2;

        me.update()
    }

    /**
     * Serializes the container into a JSON-compatible object.
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            dragResortable: me.dragResortable,
            itemCount     : me.items?.length || 0,
            itemDefaults  : me.itemDefaults,
            items         : me.items?.map(item => {
                const itemType = Neo.typeOf(item);

                if (itemType === 'NeoInstance') {
                    return item.id
                }

                if (itemType === 'Object') {
                    if (Neo.isFunction(item.module) && !item.module.isClass) {
                        return {
                            ...item,
                            module: item.module.toString()
                        }
                    }
                }

                return me.serializeConfig(item)
            }),
            layout: me.layout?.toJSON()
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Container));


/***/ },

/***/ "./src/container/Panel.mjs"
/*!*********************************!*\
  !*** ./src/container/Panel.mjs ***!
  \*********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toolbar/Base.mjs */ "./src/toolbar/Base.mjs");



/**
 * An extended Container supporting multiple docked header toolbars
 * @class Neo.container.Panel
 * @extends Neo.container.Base
 */
class Panel extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.container.Panel'
         * @protected
         */
        className: 'Neo.container.Panel',
        /**
         * @member {String} ntype='panel'
         * @protected
         */
        ntype: 'panel',
        /**
         * @member {String[]} baseCls=['neo-panel','neo-container']
         */
        baseCls: ['neo-panel', 'neo-container'],
        /**
         * @member {Object} containerConfig=null
         */
        containerConfig: null,
        /**
         * @member {Object} headerDefaults=null
         */
        headerDefaults: null,
        /**
         * @member {Array} headers=null
         */
        headers: null,
        /**
         * @member {Object} items={ntype: 'vbox', align: 'stretch'}
         * @reactive
         */
        _layout: {
            ntype: 'vbox',
            align: 'stretch'
        },
        /**
         * @member {Boolean} verticalHeadersFirst=false
         */
        verticalHeadersFirst: false
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        if (me.hasHeaders() && me.verticalHeadersFirst === true) {
            me.layout = {
                ntype: 'hbox',
                align: 'stretch'
            };
        }
    }

    /**
     * @param {Object} header the header config
     * @returns {Object}
     */
    static createHeaderConfig(header) {
        if (Neo.typeOf(header) === 'NeoInstance') {
            return header;
        }

        let config = {
            flex: '0 1 auto'
        };

        if (!header.module && !header.ntype) {
            config.cls   = ['neo-panel-header-toolbar', 'neo-toolbar'];
            config.ntype = 'toolbar';
        }

        if (header.text) {
            config.items = [{
                ntype: 'label',
                cls  : ['neo-panel-header-text', 'neo-label'],
                text : header.text
            }];

            delete header.text;
        }

        // assuming all labels inside a Panel Header are meant to be titles -> look the same way
        if (Array.isArray(header.items)) {
            header.items.forEach(item => {
                if (item.ntype === 'label') {
                    item.cls = ['neo-panel-header-text', 'neo-label'];
                }
            });
        }

        return {...config, ...header}
    }

    /**
     *
     */
    createItems() {
        let me              = this,
            containerConfig = me.containerConfig;

        if (!me.hasHeaders()) {
            containerConfig && me.set(containerConfig);
            super.createItems();
        } else {
            let hf                   = me.verticalHeadersFirst === false,
                headers              = me.headers || [],
                bottomHeaders        = headers.filter(header => {return header.dock === (hf ?'bottom': 'right')}),
                leftHeaders          = headers.filter(header => {return header.dock === (hf ?'left'  : 'top')}),
                rightHeaders         = headers.filter(header => {return header.dock === (hf ?'right' : 'bottom')}),
                topHeaders           = headers.filter(header => {return header.dock === (hf ?'top'   : 'left')}),
                hasHorizontalHeaders = bottomHeaders.length > 0 || topHeaders  .length > 0,
                hasVerticalHeaders   = leftHeaders  .length > 0 || rightHeaders.length > 0,
                {items}              = me,
                horizontalItems      = [],
                verticalItems        = [],
                config;

            topHeaders.forEach(header => {
                verticalItems.push(Panel.createHeaderConfig(header))
            });

            if (hasVerticalHeaders && (hf && hasHorizontalHeaders || !hf && hasHorizontalHeaders)) {
                leftHeaders.forEach(header => {
                    horizontalItems.push(Panel.createHeaderConfig(header))
                });

                config = {
                    ntype       : 'container',
                    flex        : 1,
                    items,
                    itemDefaults: me.itemDefaults,
                    ...containerConfig
                };

                horizontalItems.push({...me.headerDefaults, ...config});

                rightHeaders.forEach(header => {
                    horizontalItems.push(Panel.createHeaderConfig(header))
                });

                verticalItems.push({
                    ntype    : 'container',
                    items    : horizontalItems,
                    layout   : {ntype: (hf ? 'hbox' : 'vbox'), align: 'stretch'},
                    reference: 'bodyContainer'
                });
            } else {
                config = {
                    ntype       : 'container',
                    flex        : 1,
                    items,
                    itemDefaults: me.itemDefaults,
                    reference   : 'bodyContainer',
                    ...containerConfig
                };

                verticalItems.push({...me.headerDefaults, ...config})
            }

            bottomHeaders.forEach(header => {
                verticalItems.push(Panel.createHeaderConfig(header))
            });

            me.items = verticalItems;

            me.itemDefaults = null;

            super.createItems()
        }
    }

    /**
     * @returns {Boolean}
     */
    hasHeaders() {
        return Array.isArray(this.headers) && this.headers.length > 0
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Panel));


/***/ },

/***/ "./src/container/Viewport.mjs"
/*!************************************!*\
  !*** ./src/container/Viewport.mjs ***!
  \************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/container/Base.mjs");


/**
 * @class Neo.container.Viewport
 * @extends Neo.container.Base
 */
class Viewport extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.container.Viewport'
         * @protected
         */
        className: 'Neo.container.Viewport',
        /**
         * @member {String} ntype='viewport'
         * @protected
         */
        ntype: 'viewport',
        /**
         * true applies 'neo-body-viewport' to the document.body
         * @member {Boolean} applyBodyCls=true
         */
        applyBodyCls: true,
        /**
         * Assuming that a Viewport is the top level view of your app, and you want to mount it right away.
         * Could be without any items. Use false otherwise.
         * @member {Boolean} autoMount=true
         */
        autoMount: true,
        /**
         * @member {String[]} baseCls=['neo-viewport']
         */
        baseCls: ['neo-viewport'],
        /**
         * true applies a main.addon.ResizeObserver and fires a custom resize event
         * which other instances can subscribe to.
         * @member {Boolean} monitorSize_=false
         * @reactive
         */
        monitorSize_: false
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        let me = this;

        if (value && me.monitorSize) {
            me.addDomListeners([{resize: me.onDomResize, scope: me}])
        }
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let {windowId} = this;

        this.applyBodyCls && Neo.main.DomAccess.applyBodyCls({
            cls: ['neo-body-viewport'],
            windowId
        })
    }

    /**
     * @param {Object} data
     */
    onDomResize(data) {
        this.fire('resize', data)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Viewport));


/***/ },

/***/ "./src/form/field/Base.mjs"
/*!*********************************!*\
  !*** ./src/form/field/Base.mjs ***!
  \*********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_Function_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/Function.mjs */ "./src/util/Function.mjs");
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../manager/Component.mjs */ "./src/manager/Component.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");





/**
 * Abstract base class for form fields
 * @class Neo.form.field.Base
 * @extends Neo.component.Base
 */
class Field extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    /**
     * Valid values for isTouchedEvent
     * @member {String[]} isTouchedEvents=['focusEnter','focusLeave']
     * @protected
     * @static
     */
    static isTouchedEvents = ['focusEnter', 'focusLeave']

    static config = {
        /**
         * @member {String} className='Neo.form.field.Base'
         * @protected
         */
        className: 'Neo.form.field.Base',
        /**
         * @member {String} ntype='basefield'
         * @protected
         */
        ntype: 'basefield',
        /**
         * Form groups can get set on any parent component level.
         * An alternative way for using dots in field names.
         * @member {String|null} formGroup_=null
         * @reactive
         */
        formGroup_: null,
        /**
         * @member {Object|null} keys={}
         * @reactive
         */
        keys: {},
        /**
         * True indicates that a user has interacted with the form field
         * @member {Boolean} isTouched_=false
         * @reactive
         */
        isTouched_: false,
        /**
         * Event name which sets isTouched to true. Valid options are 'focusEnter' & 'focusLeave'
         * @member {String} isTouched_=false
         * @reactive
         */
        isTouchedEvent_: 'focusLeave',
        /**
         * @member {String|null} name_=null
         * @reactive
         */
        name_: null,
        /**
         * Neo itself does not need field names to get mapped to the DOM (input nodes),
         * except for CheckBoxes & Radios to work. It can be useful for testing tools
         * & accessibility though, so the default got set to true.
         * Feel free to change it to false to keep the DOM minimal.
         * @member {Boolean} renderName_=true
         * @reactive
         */
        renderName_: true,
        /**
         * In case renderName is set to true, you can optionally render the combination
         * of all formGroup(s) & the field name into the DOM => input node
         * @member {Boolean} renderPath=true
         */
        renderPath: true,
        /**
         * @member {*} value_=null
         * @reactive
         */
        value_: null
    }

    /**
     * An internal cache for formGroups of all parent levels
     * @member {String|null} formGroupString=null
     */
    formGroupString = null
    /**
     * Base implementation to check if the fields value has changed.
     * Can get overridden in superclasses.
     * @returns {Boolean}
     */
    get isDirty() {
        return !Neo.isEqual(this.getSubmitValue(), this.originalConfig.value)
    }
    /**
     * An internal cache for formGroup(s) and the field name
     * @member {String|null} path=null
     */
    path = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_0__.createSequence)(me, 'afterSetValue', (value, oldValue) => {
            oldValue !== undefined && me.fireChangeEvent(value, oldValue)
        }, me)
    }

    /**
     * Triggered after the name isTouched got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     */
    afterSetIsTouched(value, oldValue) {
        let {cls} = this;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].toggle(cls, 'neo-is-touched', value);
        this.cls = cls
    }

    /**
     * Triggered after the name config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     */
    afterSetName(value, oldValue) {
        let me = this;

        me.renderName && me.changeInputElKey('name', me.renderPath ? me.getPath() : value)
    }

    /**
     * Triggered after the role config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetRole(value, oldValue) {
        this.getInputEl().role = value;
        this.update()
    }

    /**
     * Triggered after the value config got changed
     * @param {*} value
     * @param {*} oldValue
     */
    afterSetValue(value, oldValue) {

    }

    /**
     * Triggered when accessing the formGroup config
     * @param {String|null} value
     * @returns {String|null} parents
     * @protected
     */
    beforeGetFormGroup(value) {
        let me    = this,
            group = [],
            returnValue;

        if (me.formGroupString) {
            return me.formGroupString
        }

        value && group.push(value);

        _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getParents(me).forEach(parent => {
            parent.formGroup && group.unshift(parent.formGroup)
        });

        returnValue = group.join('.');

        me.formGroupString = returnValue;

        return returnValue
    }

    /**
     * Triggered before the isTouchedEvent config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetIsTouchedEvent(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'isTouchedEvent')
    }

    /**
     * Changes the value of a inputEl vdom object attribute or removes it in case it has no value
     * @param {String} key
     * @param {Array|Number|Object|String|null} value
     * @param {Boolean} silent=false
     */
    changeInputElKey(key, value, silent=false) {
        let me = this;

        if (value || Neo.isBoolean(value) || value === 0) {
            me.getInputEl()[key] = value
        } else {
            delete me.getInputEl()[key]
        }

        !silent && me.update()
    }

    /**
     * Override this method as needed
     * @param {*}      value
     * @param {*}      oldValue
     * @param {String} eventName
     */
    doFireChangeEvent(value, oldValue, eventName) {
        let me            = this,
            FormContainer = Neo.form?.Container,
            formEvent     = 'field' + Neo.capitalize(eventName),
            opts          = {component: me, oldValue, value};

        if (Neo.isFunction(me.getGroupValue)) {
            opts.groupValue = me.getGroupValue()
        }

        me.fire(eventName, opts);

        if (!me.suspendEvents) {
            _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getParents(me).forEach(parent => {
                if (FormContainer && parent instanceof FormContainer) {
                    parent.fire(formEvent, opts)
                }
            })
        }
    }

    /**
     * Override this method as needed
     * @param {*} value
     * @param {*} oldValue
     */
    fireChangeEvent(value, oldValue) {
        this.doFireChangeEvent(value, oldValue, 'change')
    }

    /**
     * Override this method as needed
     * @param {*} value
     * @param {*} oldValue
     */
    fireUserChangeEvent(value, oldValue) {
        this.doFireChangeEvent(value, oldValue, 'userChange')
    }

    /**
     * Forms in neo can be nested. This method will return the closest parent which is a form.Container or null.
     * @returns {Neo.form.Container|null}
     */
    getClosestForm() {
        let me            = this,
            FormContainer = Neo.form?.Container,
            parent;

        for (parent of _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getParents(me)) {
            if (FormContainer && parent instanceof FormContainer) {
                return parent
            }
        }

        return null
    }

    /**
     * Override this method as needed
     * @returns {Object|null}
     */
    getInputEl() {
        return this.vdom
    }

    /**
     * Returns the combination of the field formGroup(s) & name
     * @returns {String|null}
     */
    getPath() {
        let me = this,
            path;

        // fields could have formGroups, but no name.
        // returning the namespace can confuse form.Container.adjustTreeLeaves(),
        // since namespaces could be considered as field instances.
        if (!me.name) {
            return null
        }

        if (!me.path) {
            path = me.formGroup ? me.formGroup.split('.') : [];

            me.name && path.push(me.name);

            if (path.length < 1) {
                return null
            }

            me.path = path.join('.');
        }

        if (!me.path) {
            me.path = 'none'
        }

        return me.path === 'none' ? null: me.path
    }

    /**
     * @returns {*}
     */
    getSubmitValue() {
        return this.value
    }

    /**
     * @deprecated in v7.x
     * @returns {*}
     */
    getValue() {
        return this.getSubmitValue()
    }

    /**
     * @returns {Boolean}
     */
    isValid() {
        return true
    }

    /**
     * @param {Object} data
     */
    onFocusEnter(data) {
        super.onFocusLeave(data);

        if (this.isTouchedEvent === 'focusEnter') {
            this.isTouched = true
        }
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.oldPath
     * @protected
     */
    onFocusLeave(data) {
        super.onFocusLeave(data);

        let me            = this,
            FormContainer = Neo.form?.Container,
            opts          = {...data, component: me, value: me.getSubmitValue()};

        if (me.isTouchedEvent === 'focusLeave') {
            me.isTouched = true
        }

        if (Neo.isFunction(me.getGroupValue)) {
            opts.groupValue = me.getGroupValue()
        }

        if (!me.suspendEvents) {
            _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getParents(me).forEach(parent => {
                if (FormContainer && parent instanceof FormContainer) {
                    parent.fire('fieldFocusLeave', opts)
                }
            })
        }
    }

    /**
     * Resets the field to a new value or null
     * @param {*} value=null
     */
    reset(value=null) {
        this.originalConfig.value = value;
        this.value = value
    }

    /**
     * Checks for client-side field errors
     * @param {Boolean} silent=true
     * @returns {Boolean} Returns true in case there are no client-side errors
     */
    validate(silent=true) {
        return true
    }
    /**
     * Serializes the field into a JSON-compatible object.
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            formGroup: me.formGroup,
            isDirty  : me.isDirty,
            isTouched: me.isTouched,
            isValid  : me.isValid(),
            name     : me.name,
            value    : me.value
        }
    }
}

/**
 * The change event fires after the value config gets changed
 * @event change
 * @param {*} value
 * @param {*} oldValue
 * @returns {Object}
 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Field));


/***/ },

/***/ "./src/form/field/CheckBox.mjs"
/*!*************************************!*\
  !*** ./src/form/field/CheckBox.mjs ***!
  \*************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../manager/Component.mjs */ "./src/manager/Component.mjs");
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Base.mjs */ "./src/form/field/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");




/**
 * @class Neo.form.field.CheckBox
 * @extends Neo.form.field.Base
 */
class CheckBox extends _Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    /**
     * Valid values for labelPosition
     * @member {String[]} labelPositions=['left','top']
     * @protected
     * @static
     */
    static labelPositions = ['left', 'top']

    static config = {
        /**
         * @member {String} className='Neo.form.field.CheckBox'
         * @protected
         */
        className: 'Neo.form.field.CheckBox',
        /**
         * @member {String} ntype='checkboxfield'
         * @protected
         */
        ntype: 'checkboxfield',
        /**
         * @member {String[]} baseCls=['neo-checkboxfield']
         */
        baseCls: ['neo-checkboxfield'],
        /**
         * @member {Boolean} checked_=false
         * @reactive
         */
        checked_: false,
        /**
         * @member {String|null} error_=null
         * @reactive
         */
        error_: null,
        /**
         * Useful for fields inside a css grid where errors should live outside the layout
         * @member {Boolean} errorPositionAbsolute_=false
         * @reactive
         */
        errorPositionAbsolute_: false,
        /**
         * @member {Function} errorTextGroupRequired='Required'
         */
        errorTextGroupRequired: data => `Please check at least one item of the group: ${data.name}`,
        /**
         * @member {String} errorTextRequired='Required'
         */
        errorTextRequired: 'Required',
        /**
         * @member {Boolean} groupRequired_=false
         * @reactive
         */
        groupRequired_: false,
        /**
         * @member {Boolean} hideLabel_=false
         * @reactive
         */
        hideLabel_: false,
        /**
         * @member {String[]} iconCls=['far','fa-square']
         */
        iconCls: ['far', 'fa-square'],
        /**
         * @member {String[]} iconClsChecked=['fas','fa-check']
         */
        iconClsChecked: ['fas', 'fa-check'],
        /**
         * @member {String} inputType_='checkbox'
         * @reactive
         */
        inputType_: 'checkbox',
        /**
         * @member {String[]} labelBaseCls=['neo-checkbox-label']
         */
        labelBaseCls: ['neo-checkbox-label'],
        /**
         * @member {String[]} labelCls_=[]
         * @reactive
         */
        labelCls_: [],
        /**
         * Edge-case config in case we want to render leading content with their own selectors like:
         * <span class="my-label-id-cls">E10</span> Â· Firstname
         * @member {String|null} labelId_=null
         * @reactive
         */
        labelId_: null,
        /**
         * CSS rules for labelId
         * @member {String[]} labelIdCls_=[]
         * @reactive
         */
        labelIdCls_: [],
        /**
         * Separator between labelId & labelText
         * @member {String} labelIdSeparator_=' Â· '
         * @reactive
         */
        labelIdSeparator_: ' Â· ',
        /**
         * Valid values: 'left', 'top'
         * @member {String} labelPosition_='left'
         * @reactive
         */
        labelPosition_: 'left',
        /**
         * The label text or VDOM.
         * Supports:
         * - String: Renders as safe text (textContent).
         * - Object: A single VDOM object.
         * - Object[]: An array of VDOM objects.
         * @member {Object|Object[]|String} labelText_='LabelText'
         * @reactive
         */
        labelText_: 'LabelText',
        /**
         * defaults to px
         * @member {Number|String} labelWidth_=150
         * @reactive
         */
        labelWidth_: 150,
        /**
         * @member {Boolean} required_=false
         * @reactive
         */
        required_: false,
        /**
         * Use case: Set this config to false for all but one item with the same name.
         * @member {Boolean} showErrorTexts_=true
         * @reactive
         */
        showErrorTexts_: true,
        /**
         * In case the CheckBox does not belong to a group (multiple fields with the same name),
         * you can pass a custom value for the unchecked state.
         * @member {*} uncheckedValue=false
         */
        uncheckedValue: false,
        /**
         * Using the alert state will display an empty but required field in orange instead of red.
         * Intended to get combined with form.Container: getFormState().
         * See apps/form as an example.
         * @member {Boolean} useAlertState_=false
         * @reactive
         */
        useAlertState_: false,
        /**
         * @member {Boolean|Number|String|null} value=true
         * @reactive
         */
        value: true,
        /**
         * The label text or VDOM to display next to the checkbox.
         * Supports:
         * - String: Renders as safe text (textContent).
         * - Object: A single VDOM object (e.g. {tag: 'i', cls: 'fa fa-check'}).
         * - Object[]: An array of VDOM objects.
         * @member {Object|Object[]|String|null} valueLabel_=null
         * @reactive
         */
        valueLabel_: null,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {cn: [
            {tag: 'label', cls: ['neo-checkbox-label'], cn: [
                {tag: 'span',  cls: []},
                {tag: 'input', cls: ['neo-checkbox-input']},
                {tag: 'i',     cls: ['neo-checkbox-icon']},
                {tag: 'span',  cls: ['neo-checkbox-value-label']}
            ]},
            {cls: ['neo-error-wrapper'], removeDom: true, cn: [
                {cls: ['neo-error']}
            ]}
        ]}
    }

    /**
     * Set this value to false, in case a field should display errors up front.
     * Otherwise, errors will stay hidden on mounting, unless you trigger validate(false).
     * @member {Boolean} clean=true
     */
    clean = true

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.addDomListeners(
            {change: me.onInputValueChange, scope: me}
        )
    }

    /**
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetChecked(value, oldValue) {
        let me      = this,
            labelEl = me.vdom.cn[0],
            iconCls = labelEl.cn[2].cls,
            newCls  = value ? me.iconClsChecked : me.iconCls,
            oldCls  = value ? me.iconCls : me.iconClsChecked;

        if (oldValue) {
            me.clean = false
        }

        me.validate(); // silent

        labelEl.cn[1].checked = value;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].removeAdd(iconCls, oldCls, newCls);

        me.update();

        if (oldValue !== undefined) {
            me.fireChangeEvent(me.getSubmitValue(), me.getOldSubmitValue())
        }
    }

    /**
     * Triggered after the error config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetError(value, oldValue) {
        this.updateError(value)
    }

    /**
     * Triggered after the errorPositionAbsolute config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetErrorPositionAbsolute(value, oldValue) {
        let me  = this,
            cls = me.vdom.cn[1].cn[0].cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"][value ? 'add' : 'remove'](cls, 'neo-absolute');

        me.update()
    }

    /**
     * Triggered after the required groupRequired got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetGroupRequired(value, oldValue) {
        oldValue !== undefined && this.validate(false)
    }

    /**
     * Triggered after the hideLabel config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetHideLabel(value, oldValue) {
        this.getLabelEl().removeDom = value;
        this.update()
    }

    /**
     * @protected
     */
    ensureStableIds() {
        super.ensureStableIds();

        let me      = this,
            labelEl = me.vdom.cn[0];

        labelEl.cn[0].id = me.getLabelId();
        labelEl.cn[1].id = me.getInputElId();
        labelEl.cn[2].id = me.getIconElId();
        labelEl.cn[3].id = me.getValueLabelId()
    }

    /**
     * Triggered after the inputType config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetInputType(value, oldValue) {
        this.changeInputElKey('type', value)
    }

    /**
     * Triggered after the labelCls config got changed
     * @param {String[]} value
     * @param {String[]} oldValue
     * @protected
     */
    afterSetLabelCls(value, oldValue) {
        let me  = this,
            cls = me.getLabelEl().cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].remove(cls, oldValue);
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].add(cls, value);

        me.update()
    }

    /**
     * Triggered after the labelPosition config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetLabelPosition(value, oldValue) {
        let me    = this,
            {cls} = me;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].remove(cls, 'neo-label-' + oldValue);
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].add(   cls, 'neo-label-' + value);
        me.cls = cls
    }

    /**
     * Triggered after the labelText config got changed
     * @param {Object|Object[]|String} value
     * @param {Object|Object[]|String} oldValue
     * @protected
     */
    afterSetLabelText(value, oldValue) {
        let me      = this,
            labelEl = me.getLabelEl();

        if (me.labelId) {
            value = [{
                tag : 'span',
                cls : me.labelIdCls,
                text: me.labelId
            }, {
                tag : 'span',
                text: me.labelIdSeparator
            }, ...(Array.isArray(value) ? value : (Neo.isString(value) ? [{text: value}] : [value]))];

            labelEl.cn = value;
            delete labelEl.text
        } else {
            if (Neo.isString(value)) {
                labelEl.text = value;
                delete labelEl.cn
            } else {
                labelEl.cn = Array.isArray(value) ? value : [value];
                delete labelEl.text
            }
        }

        me.update()
    }

    /**
     * Triggered after the labelWidth config got changed
     * @param {Number|String} value
     * @param {Number|String} oldValue
     * @protected
     */
    afterSetLabelWidth(value, oldValue) {
        let me = this;

        if (!me.hideLabel) {
            me.getLabelEl().width = value;
            me.update()
        }
    }

    /**
     * Triggered after the required config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetRequired(value, oldValue) {
        oldValue !== undefined && this.validate(false)
    }

    /**
     * Triggered after the showErrorTexts config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowErrorTexts(value, oldValue) {
        oldValue !== undefined && this.validate(false)
    }

    /**
     * Triggered after the useAlertState groupRequired got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetUseAlertState(value, oldValue) {
        let {cls} = this;
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].toggle(cls, 'neo-use-alert-state', value);
        this.cls = cls
    }

    /**
     * Triggered after the value config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetValue(value, oldValue) {
        this.changeInputElKey('value', value)
    }

    /**
     * Triggered after the valueLabel config got changed
     * @param {Object|Object[]|String|null} value
     * @param {Object|Object[]|String|null} oldValue
     * @protected
     */
    afterSetValueLabel(value, oldValue) {
        let me         = this,
            valueLabel = me.vdom.cn[0].cn[3],
            showLabel  = !!value; // hide the label, in case value === null || value === ''

        if (showLabel) {
            if (Neo.isString(value)) {
                valueLabel.text = value;
                delete valueLabel.cn
            } else {
                valueLabel.cn = Array.isArray(value) ? value : [value];
                delete valueLabel.text
            }
        }

        valueLabel.removeDom = !showLabel;
        me.update()
    }

    /**
     * Triggered before the groupRequired config gets changed.
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    beforeSetGroupRequired(value, oldValue) {
        if (value && this.required) {
            console.warn('Do not use groupRequired & required at the same time. Switching to required.', this);
            return false
        }

        return value
    }

    /**
     * Triggered before the labelCls config gets changed.
     * @param {String[]} value
     * @param {String[]} oldValue
     * @protected
     */
    beforeSetLabelCls(value, oldValue) {
        return _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].union(value || [], this.labelBaseCls)
    }

    /**
     * Triggered before the labelPosition config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     * @returns {String}
     */
    beforeSetLabelPosition(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'labelPosition')
    }

    /**
     * Triggered before the renderName config gets changed.
     * CheckBoxes & radios rely on this flag being set to true
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    beforeSetRenderName(value, oldValue) {
        return true
    }

    /**
     * @returns {String[]}
     */
    getGroupValue() {
        let form   = this.getClosestForm(),
            path   = this.getPath(),
            value  = [],
            fields;

        if (path) {
            fields = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].find({path});

            fields.forEach(field => {
                if (field.checked && field.getClosestForm() === form) {
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].add(value, field.value)
                }
            })
        }

        return value
    }

    /**
     * @returns {String}
     */
    getIconElId() {
        return `${this.id}__icon`
    }

    /**
     * @returns {Object|null}
     */
    getInputEl() {
        return this.vdom.cn[0].cn[1]
    }

    /**
     * @returns {String}
     */
    getInputElId() {
        return `${this.id}__input`
    }

    /**
     * @returns {Object|null}
     */
    getLabelEl() {
        return this.vdom.cn[0].cn[0]
    }

    /**
     * @returns {String}
     */
    getLabelId() {
        return `${this.id}__label`
    }

    /**
     * Counterpart to getSubmitValue(), returning the uncheckedValue if checked
     * @returns {String|null}
     */
    getOldSubmitValue() {
        let me = this;

        return me.checked ? me.uncheckedValue : me.value
    }

    /**
     * @deprecated in v7.x
     * @returns {String|null}
     */
    getOldValue() {
        return this.getOldSubmitValue()
    }

    /**
     * Returns this.value if checked, otherwise this.uncheckedValue
     * @returns {String|null}
     */
    getSubmitValue() {
        let me = this;

        return me.checked ? me.value : me.uncheckedValue
    }

    /**
     * @returns {String}
     */
    getValueLabelId() {
        return `${this.id}__value-label`
    }

    /**
     * @returns {Boolean}
     */
    isEmptyAndRequired() {
        // Assuming that checkboxes & radios can only validate false in case they are empty & required
        return !this.validate(false)
    }

    /**
     * @returns {Boolean}
     */
    isValid() {
        this.validate(true); // silent

        return this.error ? false : super.isValid()
    }

    /**
     * Gets triggered when a user checks a checkbox input.
     * @param {Object} data
     */
    onInputValueChange(data) {
        let me      = this,
            checked = data.target.checked;

        // keep the vdom & vnode in sync for future updates
        me.vnode.childNodes[0].childNodes[me.hideLabel ? 0 : 1].attributes.checked = `${checked}`;

        me.checked = checked;

        me.fireUserChangeEvent(me.getSubmitValue(), me.getOldSubmitValue())
    }

    /**
     @param {String|null} value
     @param {Boolean} silent=false
     */
    updateError(value, silent=false) {
        let me        = this,
            {cls}     = me,
            showError = value && me.showErrorTexts,
            errorNode, errorWrapper;

        if (!(me.clean && !me.mounted)) {
            me._error = value; // silent update

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].toggle(cls, 'neo-invalid', value);
            me.cls = cls;

            errorWrapper = me.vdom.cn[1];
            errorNode    = errorWrapper.cn[0];

            if (showError) {
                errorNode.text = value
            } else {
                delete errorNode.text
            }

            errorWrapper.removeDom = !showError;

            !silent && me.update()
        }
    }

    /**
     * Checks for client-side field errors
     * @param {Boolean} silent=true
     * @returns {Boolean} Returns true in case there are no client-side errors
     */
    validate(silent=true) {
        let me          = this,
            {name}      = me,
            returnValue = true,
            checkBox, checkBoxes;

        if (!silent) {
            // in case we manually call validate(false) on a form or field before it is mounted, we do want to see errors.
            me.clean = false;
        }

        if (me.groupRequired) {
            returnValue = false;

            // discuss: we could limit this to checkBoxes / radios inside the same form, IF a top level form is used
            checkBoxes = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].find({
                ntype: me.ntype,
                name
            });

            // get the group validity state first
            for (checkBox of checkBoxes) {
                if (checkBox.checked) {
                    returnValue = true;
                    break
                }
            }

            // update all group items
            for (checkBox of checkBoxes) {
                if (checkBox.id !== me.id) {
                    if (!me.clean) {
                        checkBox.clean = false;
                    }

                    checkBox[me.clean ? '_error' : 'error'] = returnValue ? null : checkBox.errorTextGroupRequired({name})
                }
            }

            if (!returnValue) {
                me._error = me.errorTextGroupRequired({name})
            }
        } else if (me.required && !me.checked) {
            me._error = me.errorTextRequired;
            returnValue = false
        }

        if (returnValue) {
            me._error = null
        }

        !me.clean && me.updateError(me._error, silent);

        return !returnValue ? false : super.validate(silent)
    }
    /**
     * Serializes the field into a JSON-compatible object.
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            checked      : me.checked,
            hideLabel    : me.hideLabel,
            inputType    : me.inputType,
            labelPosition: me.labelPosition,
            labelText    : me.labelText,
            valueLabel   : me.valueLabel
        }
    }
    /**
     * Serializes the field into a JSON-compatible object.
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            checked       : me.checked,
            error         : me.error,
            groupRequired : me.groupRequired,
            hideLabel     : me.hideLabel,
            iconCls       : me.iconCls,
            iconClsChecked: me.iconClsChecked,
            inputType     : me.inputType,
            labelPosition : me.labelPosition,
            labelText     : me.labelText,
            labelWidth    : me.labelWidth,
            required      : me.required,
            uncheckedValue: me.uncheckedValue,
            valueLabel    : me.valueLabel
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(CheckBox));


/***/ },

/***/ "./src/form/field/Number.mjs"
/*!***********************************!*\
  !*** ./src/form/field/Number.mjs ***!
  \***********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _trigger_SpinDown_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./trigger/SpinDown.mjs */ "./src/form/field/trigger/SpinDown.mjs");
/* harmony import */ var _trigger_SpinUp_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./trigger/SpinUp.mjs */ "./src/form/field/trigger/SpinUp.mjs");
/* harmony import */ var _trigger_SpinUpDown_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./trigger/SpinUpDown.mjs */ "./src/form/field/trigger/SpinUpDown.mjs");
/* harmony import */ var _Text_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Text.mjs */ "./src/form/field/Text.mjs");





/**
 * Uses an input type number and optionally provides custom spin buttons for up and down
 * @class Neo.form.field.Number
 * @extends Neo.form.field.Text
 */
class Number extends _Text_mjs__WEBPACK_IMPORTED_MODULE_3__["default"] {
    /**
     * Valid values for triggerPosition
     * @member {String[]} triggerPositions=['right', 'sides']
     * @protected
     * @static
     */
    static triggerPositions = ['right', 'sides']

    static config = {
        /**
         * @member {String} className='Neo.form.field.Number'
         * @protected
         */
        className: 'Neo.form.field.Number',
        /**
         * @member {String} ntype='numberfield'
         * @protected
         */
        ntype: 'numberfield',
        /**
         * @member {String[]} baseCls=['neo-numberfield','neo-textfield']
         */
        baseCls: ['neo-numberfield', 'neo-textfield'],
        /**
         * Prevent users from typing specific characters.
         * @member {String[]|null} disabledChars=['e','E']
         * @reactive
         */
        disabledChars: ['e', 'E'],
        /**
         * data passes maxLength, minLength & valueLength properties
         * @member {Function} errorTextMaxValue=data=>`Max value violation: ${data.value} / ${data.maxValue}`
         */
        errorTextMaxValue: data => `Max value violation: ${data.value} / ${data.maxValue}`,
        /**
         * data passes maxLength, minLength & valueLength properties
         * @member {Function} errorTextMinValue=data=>`Min value violation: ${data.value} / ${data.minValue}`
         */
        errorTextMinValue: data => `Min value violation: ${data.value} / ${data.minValue}`,
        /**
         * @member {String} errorTextStepSize='Required'
         */
        errorTextStepSize: data => `step-size violation: ${data.value} / ${data.stepSize}`,
        /**
         * @member {Number[]|null} excluded=null
         */
        excludedValues: null,
        /**
         * false only allows changing the field using the spin buttons
         * @member {Boolean} inputEditable_=true
         * @reactive
         */
        inputEditable_: true,
        /**
         * Value for the inputType_ textfield config
         * @member {String} inputType='number'
         * @reactive
         */
        inputType: 'number',
        /**
         * @member {Number} maxValue_=100
         * @reactive
         */
        maxValue_: 100,
        /**
         * @member {Number} minValue_=0
         * @reactive
         */
        minValue_: 0,
        /**
         * @member {Number} stepSize_=1
         * @reactive
         */
        stepSize_: 1,
        /**
         * Valid values: 'right', 'sides'
         * @member {String} triggerPosition='right'
         */
        triggerPosition_: 'right',
        /**
         * @member {Boolean} useSpinButtons_=true
         * @reactive
         */
        useSpinButtons_: true
    }

    /**
     * @member {Number|null} stepSizeDigits=null
     */
    stepSizeDigits = null

    /**
     * Triggered after the inputEditable config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetInputEditable(value, oldValue) {
        let me      = this,
            inputEl = me.getInputEl(),
            style   = inputEl.style || {};

        if (value) {
            delete style.pointerEvents
        } else {
            style.pointerEvents = 'none'
        }

        me.update()
    }

    /**
     * Triggered after the maxValue config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetMaxValue(value, oldValue) {
        this.validate(); // silent
        this.changeInputElKey('max', value)
    }

    /**
     * Triggered after the minValue config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetMinValue(value, oldValue) {
        this.validate(); // silent
        this.changeInputElKey('min', value)
    }

    /**
     * Triggered after the stepSize config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetStepSize(value, oldValue) {
        let me  = this,
            val = me.value,
            modulo, stepSizeString;

        me.changeInputElKey('step', value);

        stepSizeString = String(value);

        me.stepSizeDigits = stepSizeString.includes('.') ? stepSizeString.split('.')[1].length : 0;

        if (val !== null) {
            modulo = (val - me.minValue) % value;

            if (modulo !== 0) { // find the closest valid value
                if (modulo / value > 0.5) {
                    if (val + value - modulo < me.maxValue) {
                        me.value = val + value - modulo
                    } else if (val - modulo > me.minValue) {
                        me.value = val - modulo
                    }
                } else {
                    if (val - modulo > me.minValue) {
                        me.value = val - modulo
                    } else if (val + value - modulo < me.maxValue) {
                        me.value = val + value - modulo
                    }
                }
            }
        }
    }

    /**
     * Triggered after the triggerPosition config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetTriggerPosition(value, oldValue) {
        oldValue && this.updateTriggers()
    }

    /**
     * Triggered after the useSpinButtons config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetUseSpinButtons(value, oldValue) {
        if (Neo.isBoolean(oldValue)) {
            this.updateTriggers()
        }
    }

    /**
     * Triggered before the maxLength config gets changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    beforeSetMaxLength(value, oldValue) {
        if (value !== null) {
            console.warn('input type number does not support maxLength. use maxValue instead.', this)
        }

        return null
    }

    /**
     * Triggered before the minLength config gets changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    beforeSetMinLength(value, oldValue) {
        if (value !== null) {
            console.warn('input type number does not support minLength. use minValue instead.', this)
        }

        return null
    }

    /**
     * Triggered before the triggerPosition config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetTriggerPosition(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'triggerPosition')
    }

    /**
     * Triggered before the value config gets changed
     * @param {Number|String} value
     * @param {Number} oldValue
     * @protected
     */
    beforeSetValue(value, oldValue) {
        if (value === null || value === '') {
            return null
        }

        if (!Neo.isNumber(value)) {
            value = +value
        }

        if (this.stepSizeDigits > 0) {
            value = +value.toFixed(this.stepSizeDigits)
        }

        return value
    }

    /**
     * @param {Number|null} value
     * @returns {Boolean}
     */
    fitsStepSize(value) {
        if (value === null) {
            return true
        }

        return (parseInt(value.toString().replace('.', '')) * (1 / this.stepSize)) % 1 === 0
    }

    /**
     * @returns {Boolean}
     */
    isValid() {
        let me                          = this,
            {maxValue, minValue, value} = me,
            isNumber                    = Neo.isNumber(value);

        if (Neo.isNumber(maxValue) && isNumber && value > maxValue) {
            return false
        }

        if (Neo.isNumber(minValue) && isNumber && value < minValue) {
            return false
        }

        if (!me.fitsStepSize(value)) {
            return false
        }

        return super.isValid()
    }

    /**
     *
     */
    onConstructed() {
        this.updateTriggers();
        super.onConstructed()
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.oldPath
     * @protected
     */
    onFocusLeave(data) {
        let me      = this,
            {value} = me;

        if (value !== null) {
            value = me.stepSizeDigits > 0 ? parseFloat(value) : parseInt(value);
            value = Math.max(me.minValue, value);
            value = Math.min(me.maxValue, value);

            if (me.value !== value) {
                me.value = value
            } else {
                me.getInputEl().value = me.inputValueRenderer(value)
            }
        }

        super.onFocusLeave(data)
    }

    /**
     * @protected
     */
    onSpinButtonDownClick() {
        let me         = this,
            {stepSize} = me,
            oldValue   = Neo.isNumber(me.value) ? me.value : me.minValue,
            value      = (oldValue - stepSize) < me.minValue ? me.maxValue : (oldValue - stepSize);

        if (me.excludedValues) {
            while (me.excludedValues.includes(value)) {
                value = Math.max(me.minValue, value - stepSize)
            }
        }

        if (oldValue !== value) {
            me.value = value
        }
    }

    /**
     * @protected
     */
    onSpinButtonUpClick() {
        let me         = this,
            {stepSize} = me,
            oldValue   = Neo.isNumber(me.value) ? me.value : me.maxValue,
            value      = (oldValue + stepSize) > me.maxValue ? me.minValue : (oldValue + stepSize);

        if (me.excludedValues) {
            while (me.excludedValues.includes(value)) {
                value = Math.min(me.maxValue, value + stepSize)
            }
        }

        if (oldValue !== value) {
            me.value = value
        }
    }

    /**
     *
     */
    updateTriggers() {
        let me       = this,
            triggers = me.triggers || [];

        if (me.useSpinButtons) {
            if (me.triggerPosition === 'right') {
                if (!me.hasTrigger('spinupdown')) {
                    triggers.push(_trigger_SpinUpDown_mjs__WEBPACK_IMPORTED_MODULE_2__["default"])
                }

                me.removeTrigger('spindown', true, triggers);
                me.removeTrigger('spinup', true, triggers)
            } else {
                if (!me.hasTrigger('spindown')) {
                    triggers.push(_trigger_SpinDown_mjs__WEBPACK_IMPORTED_MODULE_0__["default"])
                }

                if (!me.hasTrigger('spinup')) {
                    triggers.push(_trigger_SpinUp_mjs__WEBPACK_IMPORTED_MODULE_1__["default"])
                }

                me.removeTrigger('spinupdown', true, triggers)
            }
        } else {
            me.removeTrigger('spindown', true, triggers);
            me.removeTrigger('spinup', true, triggers);
            me.removeTrigger('spinupdown', true, triggers)
        }

        me.triggers = triggers
    }

    /**
     * Checks for client-side field errors
     * @param {Boolean} silent=true
     * @returns {Boolean} Returns true in case there are no client-side errors
     */
    validate(silent=true) {
        let me          = this,
            {maxValue, minValue, stepSize, value} = me,
            isNumber    = Neo.isNumber(value),
            returnValue = super.validate(silent),
            errorParam  = {maxValue, minValue, stepSize, value};

        if (returnValue) {
            if (Neo.isNumber(maxValue) && isNumber && value > maxValue) {
                me._error = me.errorTextMaxValue(errorParam);
                returnValue = false
            } else if (Neo.isNumber(minValue) && isNumber && value < minValue) {
                me._error = me.errorTextMinValue(errorParam);
                returnValue = false
            } else if (!me.fitsStepSize(value)) {
                me._error = me.errorTextStepSize(errorParam);
                returnValue = false
            }
        }

        !returnValue && !me.clean && me.updateError(me._error, silent);

        return returnValue
    }
    /**
     * Serializes the field into a JSON-compatible object.
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            maxValue      : me.maxValue,
            minValue      : me.minValue,
            stepSize      : me.stepSize,
            useSpinButtons: me.useSpinButtons
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Number));


/***/ },

/***/ "./src/form/field/Text.mjs"
/*!*********************************!*\
  !*** ./src/form/field/Text.mjs ***!
  \*********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _trigger_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./trigger/Base.mjs */ "./src/form/field/trigger/Base.mjs");
/* harmony import */ var _trigger_Clear_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./trigger/Clear.mjs */ "./src/form/field/trigger/Clear.mjs");
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Base.mjs */ "./src/form/field/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_String_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/String.mjs */ "./src/util/String.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");
/* harmony import */ var _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/VNode.mjs */ "./src/util/VNode.mjs");








/**
 * @class Neo.form.field.Text
 * @extends Neo.form.field.Base
 */
class Text extends _Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    /**
     * Valid values for autoCapitalize
     * @member {String[]} autoCapitalizeValues=['characters','none','on','off','sentences','words']
     * @protected
     * @static
     */
    static autoCapitalizeValues = ['characters', 'none', 'on', 'off', 'sentences', 'words']
    /**
     * Valid values for labelPosition
     * @member {String[]} labelPositions=['bottom','inline','left','right','top']
     * @protected
     * @static
     */
    static labelPositions = ['bottom', 'inline', 'left', 'right', 'top']

    static config = {
        /**
         * @member {String} className='Neo.form.field.Text'
         * @protected
         */
        className: 'Neo.form.field.Text',
        /**
         * @member {String} ntype='textfield'
         * @protected
         */
        ntype: 'textfield',
        /**
         * An enumerated attribute that controls whether and how text input is automatically capitalized as it is
         * entered/edited by the user.
         * Valid values: 'characters', 'none', 'on', 'off', 'sentences', 'words'
         * @member {String} autoCapitalize=off'
         */
        autoCapitalize_: 'off',
        /**
         * @member {Boolean} autoComplete_=false
         * @reactive
         */
        autoComplete_: false,
        /**
         * @member {String[]} baseCls=['neo-textfield']
         */
        baseCls: ['neo-textfield'],
        /**
         * Internal variable to store the actual width for the label centerBorderEl
         * (only needed for labelPosition: 'inline')
         * @member {Number|null} centerBorderElWidth=null
         * @protected
         */
        centerBorderElWidth: null,
        /**
         * True shows a clear trigger in case the field has a non-empty value.
         * @member {Boolean} clearable_=true
         * @reactive
         */
        clearable_: true,
        /**
         * True will reset the field to its initial value config.
         * Recommended for fields with required: true
         * @member {Boolean} clearToOriginalValue_=false
         * @reactive
         */
        clearToOriginalValue_: false,
        /**
         * Prevent users from typing specific characters.
         * E.g. disabling +-e for NumberFields
         * @member {String[]|null} disabledChars_=null
         * @reactive
         */
        disabledChars_: null,
        /**
         * Setting `editable` to `false` means that the input field will be read-only
         * but the field is still workable and may have its value changed by user interaction.
         *
         * For example picker fields such as `Date` and `Select` may still have their
         * values changed by selecting from the picker using keyboard or pointer.
         * @member {Boolean} editable_=true
         * @reactive
         */
        editable_: true,
        /**
         * Configure the value of empty fields. null or an empty string is recommended.
         * @member {String|null} emptyValue=null
         */
        emptyValue: null,
        /**
         * @member {String|null} error_=null
         * @reactive
         */
        error_: null,
        /**
         * Useful for fields inside a css grid where errors should live outside the layout
         * @member {Boolean} errorPositionAbsolute_=false
         * @reactive
         */
        errorPositionAbsolute_: false,
        /**
         * data passes inputPattern, maxLength, minLength & valueLength properties
         * @member {Function} errorTextInputPattern=data=>`Input pattern violation: ${data.inputPattern}`
         */
        errorTextInputPattern: data => `Input pattern violation: ${data.inputPattern}`,
        /**
         * data passes inputPattern, maxLength, minLength & valueLength properties
         * @member {Function} errorTextMaxLength=data=>`Max length violation: ${valueLength} / ${maxLength}`
         */
        errorTextMaxLength: data => `Max length violation: ${data.valueLength} / ${data.maxLength}`,
        /**
         * data passes inputPattern, maxLength, minLength & valueLength properties
         * @member {Function} errorTextMinLength=data=>`Min length violation: ${data.valueLength} / ${data.minLength}`
         */
        errorTextMinLength: data => `Min length violation: ${data.valueLength} / ${data.minLength}`,
        /**
         * @member {String} errorTextRequired='Required'
         */
        errorTextRequired: 'Required',
        /**
         * @member {Boolean} hideLabel_=false
         * @reactive
         */
        hideLabel_: false,
        /**
         * @member {RegExp|null} inputPattern_=null
         * @reactive
         */
        inputPattern_: null,
        /**
         * If false, the inputPattern will only get validated via JavaScript, but not getting applied on DOM level.
         * The regex support for input based patterns is not fully there yet, so feel free to disable this feature
         * if needed (E.g. form.field.Phone).
         * @member {Boolean} inputPatternDOM_=true
         * @reactive
         */
        inputPatternDOM_: true,
        /**
         * @member {String} inputType_='text'
         * @reactive
         */
        inputType_: 'text',
        /**
         * @member {String|null} inputValue_=null
         * @reactive
         */
        inputValue_: null,
        /**
         * @member {String[]} labelBaseCls=['neo-textfield-label']
         */
        labelBaseCls: ['neo-textfield-label'],
        /**
         * @member {String[]} labelCls_=[]
         * @reactive
         */
        labelCls_: [],
        /**
         * Edge-case config in case we want to render leading content with their own selectors like:
         * <span class="my-label-id-cls">E10</span> â€¢ Firstname
         * @member {String|null} labelId_=null
         * @reactive
         */
        labelId_: null,
        /**
         * CSS rules for labelId
         * @member {String[]} labelIdCls_=[]
         * @reactive
         */
        labelIdCls_: [],
        /**
         * Separator between labelId & labelText
         * @member {String} labelIdSeparator_=' Â· '
         * @reactive
         */
        labelIdSeparator_: ' Â· ',
        /**
         * @member {String} labelOptionalText_=' (Optional)'
         * @reactive
         */
        labelOptionalText_: ' (Optional)',
        /**
         * Valid values: 'bottom', 'inline', 'left', 'right', 'top'
         * @member {String} labelPosition_='left'
         * @reactive
         */
        labelPosition_: 'left',
        /**
         * The label text or VDOM.
         * Supports:
         * - String: Renders as safe text (textContent).
         * - Object: A single VDOM object.
         * - Object[]: An array of VDOM objects.
         * @member {Object|Object[]|String} labelText_='LabelText'
         * @reactive
         */
        labelText_: 'LabelText',
        /**
         * defaults to px
         * @member {Number|String} labelWidth_=150
         * @reactive
         */
        labelWidth_: 150,
        /**
         * The maximum amount of chars which you can enter into this field
         * @member {Number|null} maxLength_=null
         * @reactive
         */
        maxLength_: null,
        /**
         * The minimum amount of chars which you can enter into this field
         * @member {Number|null} minLength_=null
         * @reactive
         */
        minLength_: null,
        /**
         * @member {String|null} placeholderText_=null
         * @reactive
         */
        placeholderText_: null,
        /**
         * Setting `readOnly` means that the field may not be changed by user interaction.
         *
         * The input field will be read-only and other ways of changing the field's value
         * (such as by operating pickers) will be disabled.
         * @member {Boolean} readOnly_=false
         * @reactive
         */
        readOnly_: false,
        /**
         * @member {Boolean} required_=false
         * @reactive
         */
        required_: false,
        /**
         * @member {Boolean} showOptionalText_=false
         * @reactive
         */
        showOptionalText_: false,
        /**
         * null => Follow the element's default behavior for spell checking
         * @member {Boolean|null} spellCheck_=false
         * @reactive
         */
        spellCheck_: false,
        /**
         * @member {String[]} subLabelBaseCls=['neo-textfield-sublabel']
         */
        subLabelBaseCls: ['neo-textfield-sublabel'],
        /**
         * @member {String[]} subLabelCls_=[]
         * @reactive
         */
        subLabelCls_: [],
        /**
         * @member {String} subLabelText_=null
         * @reactive
         */
        subLabelText_: null,
        /**
         * @member {Object|Object[]|null} triggers_=null
         * @reactive
         */
        triggers_: null,
        /**
         * Using the alert state will display an empty but required field in orange instead of red.
         * Intended to get combined with form.Container: getFormState().
         * See apps/form as an example.
         * @member {Boolean} useAlertState_=false
         * @reactive
         */
        useAlertState_: false,
        /**
         * A string based value will get resolved into the closest controller which implements it
         * @member {Function|String|null} validator=null
         */
        validator: null,
        /**
         * get value can be xssProtected and values are escaped
         * @member {Boolean} xssProtected_=false
         * @reactive
         */
        xssProtected_: false,
        /**
         * @member {Object} _vdom
         */
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {cn: [
            {tag: 'label', cls: [], style: {}},
            {tag: 'label', cls: []},
            {tag: 'input', cls: ['neo-textfield-input'], flag: 'neo-real-input', style: {}},
            {cls: ['neo-textfield-error-wrapper'], removeDom: true, cn: [
                {cls: ['neo-textfield-error']}
            ]}
        ]}
    }

    /**
     * Set this value to false, in case a field should display errors up front.
     * Otherwise, errors will stay hidden on mounting, unless you trigger validate(false).
     * @member {Boolean} clean=true
     */
    clean = true

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.addDomListeners([
            {input     : me.onInputValueChange, scope: me},
            {mouseenter: me.onMouseEnter,       scope: me},
            {mouseleave: me.onMouseLeave,       scope: me}
        ])
    }

    /**
     * Triggered after the appName config got changed
     * @param {String} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetAppName(value, oldValue) {
        super.afterSetAppName(value, oldValue);

        value && this.triggers?.forEach(item => {
            item.appName = value
        })
    }

    /**
     * Triggered after the autoCapitalize config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetAutoCapitalize(value, oldValue) {
        this.changeInputElKey('autocapitalize', value === 'off' || value === 'none' ? null : value)
    }

    /**
     * Triggered after the autoComplete config got changed
     * Chrome ignores a value of "off", so we stick to a different value instead
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetAutoComplete(value, oldValue) {
        // while "off" is the correct value, browser vendors ignore it. Arbitrary strings do the trick.
        this.changeInputElKey('autocomplete', value ? null : 'no')
    }

    /**
     * Triggered after the clearable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetClearable(value, oldValue) {
        let me = this,
            triggers;

        if (value) {
            triggers = me.triggers || [];
            triggers.unshift(_trigger_Clear_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]);
            me.triggers = triggers
        } else {
            me.removeTrigger('clear')
        }
    }

    /**
     * Triggered after the clearToOriginalValue config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetClearToOriginalValue(value, oldValue) {
        this.fire('changeClearToOriginalValue', {
            oldValue,
            value
        })
    }

    /**
     * Triggered after the disabledChars config got changed
     * @param {String[]|null} value
     * @param {String[]|null} oldValue
     * @protected
     */
    afterSetDisabledChars(value, oldValue) {
        if (value) {
            let me = this;

            Neo.main.DomEvents.registerDisabledInputChars({
                chars   : value,
                id      : me.getInputEl().id,
                windowId: me.windowId
            })
        }
    }

    /**
     * Triggered after the editable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetEditable(value, oldValue) {
        let me      = this,
            {cls} = me;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].toggle(cls, 'neo-not-editable', !value);
        me.cls = cls;

        me.updateReadOnlyState()
    }

    /**
     * Triggered after the error config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetError(value, oldValue) {
        this.updateError(value)
    }

    /**
     * Triggered after the errorPositionAbsolute config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetErrorPositionAbsolute(value, oldValue) {
        let me  = this,
            cls = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].find(me.vdom, {cls: 'neo-textfield-error'}).vdom.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"][value ? 'add' : 'remove'](cls, 'neo-absolute');

        me.update()
    }

    /**
     * Triggered after the hideLabel config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetHideLabel(value, oldValue) {
        let me   = this,
            node = me.labelPosition === 'inline' ? me.getCenterBorderEl() : me.vdom.cn[0];

        node.removeDom = value;
        me.updateInputWidth()
    }

    /**
     * @protected
     */
    ensureStableIds() {
        super.ensureStableIds();

        let me        = this,
            inputEl   = me.getInputEl(),
            inputElId = me.getInputElId(),
            labelEl   = me.getLabelEl();

        inputEl.id  = inputElId;
        labelEl.id  = me.getLabelId();
        labelEl.for = inputElId
    }

    /**
     * Triggered after the inputPattern config got changed
     * @param {RegExp|null} value
     * @param {RegExp|null} oldValue
     * @protected
     */
    afterSetInputPattern(value, oldValue) {
        if (this.inputPatternDOM) {
            if (value) {
                value = value.toString();
                value = value.substring(1, value.length - 1)
            }

            this.changeInputElKey('pattern', value)
        }
    }

    /**
     * Triggered after the inputType config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetInputType(value, oldValue) {
        this.changeInputElKey('type', value)
    }

    /**
     * Triggered after the inputValue config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetInputValue(value, oldValue) {
        let me    = this,
            {cls} = me;

        me.getInputEl().value = me.containsFocus ? value : me.inputValueRenderer(value);

        me.useAlertState && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].toggle(cls, 'neo-empty-required', me.isEmpty() && me.required);

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].toggle(cls, 'neo-has-content', me.hasContent());
        me.cls = cls;

        me.updateValueFromInputValue(value)
    }

    /**
     * Triggered after the labelCls config got changed
     * @param {String[]} value
     * @param {String[]} oldValue
     * @protected
     */
    afterSetLabelCls(value, oldValue) {
        let me  = this,
            cls = me.getLabelEl().cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].remove(cls, oldValue);
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(cls, value);

        me.update()
    }

    /**
     * Triggered after the labelOptionalText config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetLabelOptionalText(value, oldValue) {
        this.labelText = this.labelText // triggers a vdom update
    }

    /**
     * Triggered after the labelPosition config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetLabelPosition(value, oldValue) {
        let me          = this,
            {cls, vdom} = me,
            centerBorderElCls, isEmpty;

        vdom.cn[1].removeDom = value !== 'top' ? true : !Boolean(me.subLabelText);

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].remove(cls, 'label-' + oldValue);
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(cls, 'label-' + value);
        me.cls = cls; // todo: silent update if needed

        if (oldValue === 'inline') {
            vdom.cn[0] = me.getLabelEl(); // remove the wrapper

            vdom.cn[0].removeDom = me.hideLabel;
            vdom.cn[0].width     = me.labelWidth;
            me.updateInputWidth()
        } else if (value === 'inline') {
            centerBorderElCls = ['neo-center-border'];
            isEmpty           = me.isEmpty();
            vdom              = me.vdom;

            !isEmpty && centerBorderElCls.push('neo-float-above');

            delete vdom.cn[0].width;

            vdom.cn[0] = {
                cls: ['neo-label-wrapper'],
                cn : [{
                    cls: ['neo-left-border']
                }, {
                    cls      : centerBorderElCls,
                    cn       : [vdom.cn[0]],
                    removeDom: me.hideLabel
                }, {
                    cls: ['neo-right-border']
                }]
            };

            me.updateInputWidth();

            !isEmpty && me.timeout(20).then(() => {
                me.updateCenterBorderElWidth(false)
            })
        } else {
            // changes from e.g. left to top
            me.updateInputWidth()
        }
    }

    /**
     * Triggered after the labelText config got changed
     * @param {Object|Object[]|String} value
     * @param {Object|Object[]|String} oldValue
     * @protected
     */
    afterSetLabelText(value, oldValue) {
        let me      = this,
            isEmpty = me.isEmpty(),
            labelEl = me.getLabelEl();

        if (me.labelId) {
            value = [{
                tag : 'span',
                cls : me.labelIdCls,
                text: me.labelId
            }, {
                tag : 'span',
                text: me.labelIdSeparator
            }, ...(Array.isArray(value) ? value : (Neo.isString(value) ? [{text: value}] : [value]))];

            labelEl.cn = value;
            delete labelEl.text
        } else {
            if (Neo.isString(value)) {
                labelEl.text = value;
                delete labelEl.cn
            } else {
                labelEl.cn = Array.isArray(value) ? value : [value];
                delete labelEl.text
            }
        }

        if (!me.hideLabel) {
            if (me.labelPosition === 'inline') {
                if (!isEmpty) {
                    delete me.getCenterBorderEl()?.width
                }

                me.promiseUpdate().then(() => {
                    me.updateCenterBorderElWidth(isEmpty)
                })
            } else {
                me.update()
            }
        }
    }

    /**
     * Triggered after the labelWidth config got changed
     * @param {Number|String} value
     * @param {Number|String} oldValue
     * @protected
     */
    afterSetLabelWidth(value, oldValue) {
        if (this.labelPosition !== 'inline') {
            let me    = this,
                label = me.vdom.cn[0];

            label.width = value;
            !me.hideLabel && me.updateInputWidth()
        }
    }

    /**
     * Triggered after the maxLength config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetMaxLength(value, oldValue) {
        this.validate(); // silent
        this.changeInputElKey('maxlength', value)
    }

    /**
     * Triggered after the minLength config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetMinLength(value, oldValue) {
        this.validate(); // silent
        this.changeInputElKey('minlength', value)
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        let me = this;

        if (oldValue !== undefined) {
            let triggers = me.triggers || [],
                i        = 0,
                len      = triggers.length;

            for (; i < len; i++) {
                if (!triggers[i].vdom.removeDom) {
                    triggers[i].mounted = value
                }
            }

            if (me.labelPosition === 'inline') {
                if (value) {
                    me.updateCenterBorderElWidth()
                } else {
                    delete me.getCenterBorderEl().width
                }
            }
        }
    }

    /**
     * Triggered after the placeholderText config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetPlaceholderText(value, oldValue) {
        let me    = this,
            {cls} = me;

        me.changeInputElKey('placeholder', value === '' ? null : value);

        // a non-empty placeholder needs to keep the 'neo-has-content' rule
        // => labelPosition: 'inline' should keep the label at the top
        if (Neo.isEmpty(value) !== Neo.isEmpty(oldValue)) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"][value !== null && value.toString().length > 0 ? 'add' : 'remove'](cls, 'neo-has-content');
            me.cls = cls
        }
    }

    /**
     * Triggered after the readOnly config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetReadOnly(value, oldValue) {
        let me    = this,
            {cls} = me;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"][value ? 'add' : 'remove'](cls, 'neo-readonly');
        me.cls = cls;

        me.updateReadOnlyState();

        me.triggers?.forEach(trigger => {
            trigger.hidden = value ? true : trigger.getHiddenState?.() || false
        })
    }

    /**
     * Triggered after the required config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetRequired(value, oldValue) {
        let me = this;

        me.silentVdomUpdate = true;

        oldValue !== undefined && me.validate(me.clean);
        me.changeInputElKey('required', value ? value : null);
        me.labelText = me.labelText; // apply the optional text if needed

        me.silentVdomUpdate = false;

        me.update()
    }

    /**
     * Triggered after the showOptionalText config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowOptionalText(value, oldValue) {
        this.labelText = this.labelText // triggers a vdom update
    }

    /**
     * Triggered after the spellCheck config got changed
     * @param {Boolean|null} value
     * @param {Boolean|null} oldValue
     * @protected
     */
    afterSetSpellCheck(value, oldValue) {
        this.changeInputElKey('spellcheck', Neo.isBoolean(value) ? value : null)
    }

    /**
     * Triggered after the subLabelCls config got changed
     * @param {String[]} value
     * @param {String[]} oldValue
     * @protected
     */
    afterSetSubLabelCls(value, oldValue) {
        let me    = this,
            {cls} = me.vdom.cn[1];

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].remove(cls, oldValue);
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(cls, value);

        me.update()
    }

    /**
     * Triggered after the subLabelText config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetSubLabelText(value, oldValue) {
        let me        = this,
            showLabel = me.labelPosition === 'top',
            subLabel  = me.vdom.cn[1];

        subLabel.removeDom = !showLabel;
        subLabel.text      = value;

        me.update()
    }

    /**
     * Triggered after the triggers config got changed
     * @param {Object[]} value
     * @param {Object[]} oldValue
     * @protected
     */
    afterSetTriggers(value, oldValue) {
        let me           = this,
            {vdom}       = me,
            inputEl      = vdom.cn[2], // inputEl or inputWrapperEl
            preTriggers  = [],
            postTriggers = [],
            width;

        oldValue?.forEach(item => {
            if (!me.getTrigger(item.type)) {
                item.destroy()
            }
        });

        if (value.length > 0) {
            value.forEach(item => {
                if (item.align === 'start') {
                    preTriggers.push(item);
                } else {
                    postTriggers.push(item);
                }
            });

            postTriggers.sort((a, b) => b.weight - a.weight); // DESC
            preTriggers.sort( (a, b) => a.weight - b.weight); // ASC

            postTriggers = postTriggers.map(trigger => trigger.createVdomReference());
            preTriggers  = preTriggers.map( trigger => trigger.createVdomReference());

            if (inputEl.tag === 'input') {
                // wrap the input tag
                vdom.cn[2] = {
                    cls  : ['neo-input-wrapper'],
                    cn   : [...preTriggers, inputEl, ...postTriggers],
                    id   : me.getInputWrapperId(),
                    width: inputEl.width
                };

                delete inputEl.width
            } else {
                inputEl.cn = [...preTriggers, me.getInputEl(), ...postTriggers]
            }
        } else {
            if (inputEl.tag !== 'input') {
                // replacing the input wrapper div with the input tag
                width            = inputEl.width;
                vdom.cn[2]       = me.getInputEl();
                vdom.cn[2].width = width;
            }
        }

        me.promiseUpdate().then(() => {
            me.updateTriggerVnodes()
        })
    }

    /**
     * Triggered after the value config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetValue(value, oldValue) {
        let me = this,
            cls;

        me.silentVdomUpdate = true;

        me.updateInputValueFromValue(value);

        me.validate(); // silent

        cls = me.cls;
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].toggle(cls, 'neo-is-dirty', me.isDirty);
        me.cls = cls;

        me.silentVdomUpdate = false;

        me.update();

        super.afterSetValue(value, oldValue) // fires the change event
    }

    /**
     * Triggered after the width config got changed
     * @param {Number|String} value
     * @param {Number|String} oldValue
     * @protected
     */
    afterSetWidth(value, oldValue) {
        super.afterSetWidth(value, oldValue);
        this.updateInputWidth()
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        super.afterSetWindowId(value, oldValue);

        value && this.triggers?.forEach(item => {
            item.windowId = value
        })
    }

    /**
     * Return a shallow copy of the triggers config
     * @param {Array|null} value
     * @protected
     */
    beforeGetTriggers(value) {
        if (Array.isArray(value)) {
            return [...value]
        }

        return value
    }

    /**
     * Triggered before the autoCapitalize config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     * @returns {String}
     */
    beforeSetAutoCapitalize(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'autoCapitalize', 'autoCapitalizeValues')
    }

    /**
     * Triggered before the labelCls config gets changed.
     * @param {String[]} value
     * @param {String[]} oldValue
     * @protected
     */
    beforeSetLabelCls(value, oldValue) {
        return _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].union(value || [], this.labelBaseCls)
    }

    /**
     * Triggered before the labelPosition config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     * @returns {String}
     */
    beforeSetLabelPosition(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'labelPosition')
    }

    /**
     * Triggered before the labelText config gets changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     * @returns {String}
     */
    beforeSetLabelText(value, oldValue) {
        let me                = this,
            labelOptionalText = me.labelOptionalText,
            hasOptionalText   = value.endsWith(labelOptionalText);

        if (me.showOptionalText && !me.required) {
            if (!hasOptionalText) {
                value += labelOptionalText
            }
        } else if (value && hasOptionalText) {
            value = value.replace(labelOptionalText, '')
        }

        return value
    }

    /**
     * Triggered before the subLabelCls config gets changed
     * @param {String[]} value
     * @param {String[]} oldValue
     * @returns {String[]}
     * @protected
     */
    beforeSetSubLabelCls(value, oldValue) {
        return _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].union(value || [], this.subLabelBaseCls)
    }

    /**
     * Triggered before the triggers config gets changed
     * @param {Object|Object[]} value
     * @param {Object[]} oldValue
     * @returns {Object[]} the parsed triggers config
     * @protected
     * @returns {Object|Object[]}
     */
    beforeSetTriggers(value, oldValue) {
        if (!value) {
            value = [];
        } else if (!Array.isArray(value)) {
            value = [value]
        }

        let me                  = this,
            {appName, windowId} = me;

        value.forEach((item, index) => {
            if (item.isClass) {
                value[index] = Neo.create(item, {
                    appName,
                    id   : me.getTriggerId(item.prototype.type),
                    field: me,
                    windowId
                })
            } else if (!(item instanceof _trigger_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"])) {
                if (!item.module && !item.ntype) {
                    item.ntype = 'trigger'
                }

                if (item.module) {
                    item.className = item.module.prototype.className;
                    item.id        = me.getTriggerId(item.module.prototype.type)
                }

                value[index] = Neo[item.className ? 'create' : 'ntype']({
                    ...item,
                    appName,
                    field: me,
                    windowId
                })
            }
        });

        return value
    }

    /**
     * Triggered before the value config gets changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @returns {String|null}
     * @protected
     */
    beforeSetValue(value, oldValue) {
        if (value === null || value === '') {
            return this.emptyValue
        }

        return value
    }

    /**
     * Resets the field to its original value or null depending on the clearToOriginalValue config
     */
    clear() {
        let me = this;

        me.value = me.clearToOriginalValue ? me.originalConfig.value : null;
        me.fire('clear')
    }

    /**
     *
     * @param args
     */
    destroy(...args) {
        let me = this;

        if (me.disabledChars) {
            Neo.main.DomEvents.unregisterDisabledInputChars({
                id      : me.getInputEl().id,
                windowId: me.windowId
            })
        }

        me.triggers?.forEach(trigger => {
            trigger.destroy()
        });

        super.destroy(...args)
    }

    /**
     * Calls focus() on the inputEl node instead
     * @param {String} id
     * @override
     */
    focus(id) {
        super.focus(this.getInputElId())
    }

    /**
     * @returns {Object|null}
     */
    getCenterBorderEl() {
        return _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].find(this.vdom, {cls: 'neo-center-border'})?.vdom || null
    }

    /**
     * @returns {Object|null}
     */
    getInputEl() {
        return _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].find(this.vdom, {flag: 'neo-real-input'})?.vdom || null
    }

    /**
     * @returns {String}
     */
    getInputElId() {
        return `${this.id}__input`
    }

    /**
     * Calculates the new inputWidth based on the labelWidth & total width
     * @returns {Number|null} null in case this.width is unknown
     */
    getInputWidth() {
        let me          = this,
            ignoreLabel = me.hideLabel || me.labelPosition === 'bottom' || me.labelPosition === 'inline' || me.labelPosition === 'top',
            labelWidth  = ignoreLabel ? 0 : me.labelWidth,
            {width}     = me;

        if (labelWidth && width) {
            return parseInt(width) - parseInt(labelWidth)
        } else if (width) {
            return width
        }

        return null
    }

    /**
     * @returns {String}
     */
    getInputWrapperId() {
        return `${this.id}__input-wrapper`
    }

    /**
     * @returns {Object|null}
     */
    getLabelEl() {
        return _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].find(this.vdom, {tag: 'label'})?.vdom || null
    }

    /**
     * @returns {String}
     */
    getLabelId() {
        return `${this.id}__label`
    }

    /**
     * @returns {*}
     */
    getSubmitValue() {
        let superSubmitValue = super.getSubmitValue();

        return this.xssProtected ? _util_String_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].escapeHtml(superSubmitValue) : superSubmitValue
    }

    /**
     * @param {String} type
     * @returns {Neo.form.field.trigger.Base|null}
     */
    getTrigger(type) {
        let me       = this,
            triggers = me.triggers || [],
            i        = 0,
            len      = triggers.length;

        for (; i < len; i++) {
            if (triggers[i].type === type) {
                return triggers[i]
            }
        }

        return null
    }

    /**
     * @param {String} id
     * @returns {Neo.form.field.trigger.Base|null}
     */
    getTriggerById(id) {
        let me       = this,
            triggers = me.triggers || [],
            i        = 0,
            len      = triggers.length;

        for (; i < len; i++) {
            if (triggers[i].id === id) {
                return triggers[i]
            }
        }

        return null
    }

    /**
     * @param {String} type
     * @protected
     * @returns {String} The trigger node id
     */
    getTriggerId(type) {
        return this.id + '-trigger-' + type
    }

    /**
     * @returns {Boolean}
     */
    hasContent() {
        let value = this.inputValue;

        return this.placeholderText?.length > 0 || value !== null && value.toString().length > 0
    }

    /**
     * Finds a trigger by a given type config
     * @param {String} type
     * @returns {Boolean}
     */
    hasTrigger(type) {
        let triggers = this.triggers || [],
            i        = 0,
            len      = triggers.length;

        for (; i < len; i++) {
            if (triggers[i].type === type) {
                return true
            }
        }

        return false
    }

    /**
     * Transform an input node value before applied to this.value.
     * Override as needed
     * @param {*} value
     * @returns {*}
     */
    inputValueAdjustor(value) {
        return value
    }

    /**
     * Transform a value before getting rendered.
     * Override as needed
     * @param {*} value
     * @returns {*}
     */
    inputValueRenderer(value) {
        return value
    }

    /**
     * @returns {Boolean}
     */
    isEmpty() {
        return !(this.value?.toString().length > 0)
    }

    /**
     * @returns {Boolean}
     */
    isEmptyAndRequired() {
        return this.isEmpty() && this.required
    }

    /**
     * @returns {Boolean}
     */
    isValid() {
        this.validate(true); // silent

        return this.error ? false : super.isValid()
    }

    /**
     * @param args
     * @returns {Object} config
     */
    mergeConfig(...args) {
        let me       = this,
            config   = super.mergeConfig(...args),
            triggers = config.triggers || me.triggers;

        me[triggers ? 'triggers' : '_triggers'] = triggers;

        delete config.triggers;
        return config
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.path
     * @protected
     */
    onFocusEnter(data) {
        super.onFocusEnter(data);

        let me    = this,
            {cls} = me;

        if (!me.readOnly) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(cls, 'neo-focus');
            me.cls = cls;

            if (me.labelPosition === 'inline') {
                if (me.centerBorderElWidth) {
                    me.getCenterBorderEl().width = me.centerBorderElWidth;
                    me.update()
                } else {
                    me.updateCenterBorderElWidth(false)
                }
            }
        }
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.oldPath
     * @protected
     */
    onFocusLeave(data) {
        let me             = this,
            centerBorderEl = me.getCenterBorderEl(), // labelPosition: 'inline'
            cls;

        if (!me.readOnly) {
            me.validate(false);

            cls = me.cls; // has to get set after validate()

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].remove(cls, 'neo-focus');
            me.cls = cls;

            if (centerBorderEl && me.isEmpty()) {
                delete centerBorderEl.width
            }
        }

        if (Neo.isString(me.value)) {
            me.value = me.value.trim()
        }

        me.update();

        super.onFocusLeave(data)
    }

    /**
     * Gets triggered by the 'input' DOM event.
     * @param {Object} data
     * @protected
     */
    onInputValueChange(data) {
        let me         = this,
            oldValue   = me.value,
            inputValue = data.value;

        // Find the VNode for the real input element within the component's vnode tree.
        const {vnode: inputVNode} = _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].find(me.vnode, {nodeName: 'input'}) || {};

        if (inputVNode) {
            // This is the critical synchronization step. The user's input has changed the
            // real DOM on the Main Thread. We must manually update our "last known state"
            // (this.vnode) to match this reality *before* the next diffing cycle runs.
            // This prevents the framework from sending a redundant delta update that could
            // overwrite the user's input or cause cursor jumps.
            // Required e.g. for validation -> revert a wrong user input
            inputVNode.attributes.value = inputValue
        }

        if (Neo.isString(inputValue)) {
            inputValue = inputValue.trim()
        }

        me.clean      = false;
        me.inputValue = me.inputValueAdjustor(inputValue); // updates this.value

        me.fireUserChangeEvent(me.value, oldValue)
    }

    /**
     * @param {Object} data
     */
    onMouseEnter(data) {
        let me    = this,
            {cls} = me;

        if (!me.readOnly) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(cls, 'neo-hovered');
            me.cls = cls
        }
    }

    /**
     * @param {Object} data
     */
    onMouseLeave(data) {
        let me    = this,
            {cls} = me;

        if (!me.readOnly) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].remove(cls, 'neo-hovered');
            me.cls = cls
        }
    }

    /**
     * Removes all triggers of a given type
     * @param {String} type
     * @param {Boolean} [silent=false] true prevents a vdom update
     * @param {Array} [triggerSource] pass a shallow copy of this.triggers
     * @returns {Boolean} true in case a trigger was found & removed
     */
    removeTrigger(type, silent = false, triggerSource) {
        let me       = this,
            hasMatch = false,
            triggers = triggerSource || me.triggers || [],
            i        = 0,
            len      = triggers.length,
            trigger;

        for (; i < len; i++) {
            trigger = triggers[i];

            if (trigger.type === type) {
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].remove(triggers, trigger);
                len--;
                hasMatch = true
            }
        }

        if (hasMatch && !silent) {
            me.triggers = triggers
        }

        return hasMatch
    }

    /**
     * Resets the field to its original value or null depending on the clearToOriginalValue config
     * You can optionally pass a new value, which will adjust the originalConfig.value if needed.
     * @param {String|null} [value=null]
     */
    reset(value = null) {
        let me = this;

        if (me.clearToOriginalValue) {
            if (value) {
                me.originalConfig.value = value
            } else {
                value = me.originalConfig.value
            }
        }

        super.reset(value);

        if (value === null && me.clean) {
            me.updateError(null)
        }
    }

    /**
     * Used for labelPosition: 'inline' to adjust the top border matching to the length of the label
     * @param {Boolean} [silent=false] true to get the value, but not apply it to the DOM
     * @protected
     */
    updateCenterBorderElWidth(silent = false) {
        let me = this;

        me.mounted && me.getDomRect(me.getCenterBorderEl().id).then(data => {
            me.centerBorderElWidth = Math.round(data.width * .7) + 8;

            if (!silent) {
                me.getCenterBorderEl().width = me.centerBorderElWidth;
                me.update()
            }
        })
    }

    /**
     @param {String|null} value
     @param {Boolean} silent=false
     */
    updateError(value, silent = false) {
        let me    = this,
            {cls} = me,
            errorNode, errorWrapper;

        if (!(me.clean && !me.mounted)) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"][value ? 'add' : 'remove'](cls, 'neo-invalid');
            me.cls = cls;

            errorWrapper = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].find(me.vdom, {cls: 'neo-textfield-error-wrapper'}).vdom;
            errorNode    = errorWrapper.cn[0];

            if (value) {
                errorNode.text = value
            } else {
                delete errorNode.text
            }

            errorWrapper.removeDom = !value;

            !silent && me.update()
        }
    }

    /**
     * Override this method as needed inside class extensions.
     * @param {*} value
     * @protected
     */
    updateInputValueFromValue(value) {
        this.inputValue = value
    }

    /**
     * Calculates the new inputWidth based on the labelWidth & total width
     * @protected
     */
    updateInputWidth() {
        let me         = this,
            inputWidth = me.getInputWidth();

        if (inputWidth !== null && inputWidth !== me.width) {
            me.vdom.cn[1].width = inputWidth
        } else {
            delete me.vdom.cn[1].width
        }

        me.update()
    }

    /**
     * The DOM based readonly attribute needs to honor the editable & readOnly configs
     */
    updateReadOnlyState() {
        let me = this;

        me.changeInputElKey('readonly', !me.editable || me.readOnly || null)
    }

    /**
     * Since triggers do not get vnodeInitialized, assign the relevant props
     */
    updateTriggerVnodes() {
        let me          = this,
            triggerRoot = me.vnode?.childNodes[1],
            childNodes  = triggerRoot?.childNodes || [],
            trigger;

        childNodes.forEach(vnode => {
            trigger = me.getTriggerById(vnode.id);

            trigger && Object.assign(trigger, {
                vnode,
                _mounted         : true,
                _vnodeInitialized: true
            })
        })
    }

    /**
     * Override this method as needed inside class extensions.
     * @param {String} inputValue
     * @protected
     */
    updateValueFromInputValue(inputValue) {
        this.value = inputValue
    }

    /**
     * Checks for client-side field errors
     * @param {Boolean} silent=true
     * @returns {Boolean} Returns true in case there are no client-side errors
     */
    validate(silent=true) {
        let me          = this,
            {inputPattern, maxLength, minLength, required, value} = me,
            returnValue = true,
            valueLength = value?.toString().length,
            isEmpty     = value !== 0 && (!value || valueLength < 1),
            errorParam  = {inputPattern, maxLength, minLength, valueLength},
            errorText;

        if (!silent) {
            // in case we manually call validate(false) on a form or field before it is mounted, we do want to see errors.
            me.clean = false
        }

        if (isEmpty) {
            if (required) {
                me._error   = me.errorTextRequired;
                returnValue = false
            }
        } else {
            if (Neo.isNumber(maxLength) && valueLength > maxLength) {
                me._error   = me.errorTextMaxLength(errorParam);
                returnValue = false
            } else if (Neo.isNumber(minLength) && valueLength < minLength) {
                me._error   = me.errorTextMinLength(errorParam);
                returnValue = false
            } else if (inputPattern && !inputPattern.test(value)) {
                me._error   = me.errorTextInputPattern(errorParam);
                returnValue = false
            } else if (me.validator) {
                me.bindCallback(me.validator, 'validator');

                errorText = me.validator(me);

                if (errorText !== true) {
                    me._error   = errorText;
                    returnValue = false
                }
            }
        }

        if (returnValue) {
            me._error = null
        }

        !me.clean && me.updateError(me._error, silent);

        return !returnValue ? false : super.validate(silent)
    }
    /**
     * Serializes the field into a JSON-compatible object.
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            autoCapitalize : me.autoCapitalize,
            autoComplete   : me.autoComplete,
            clearable      : me.clearable,
            editable       : me.editable,
            hideLabel      : me.hideLabel,
            inputPattern   : me.inputPattern?.toString(),
            inputType      : me.inputType,
            inputValue     : me.inputValue,
            labelPosition  : me.labelPosition,
            labelText      : me.labelText,
            maxLength      : me.maxLength,
            minLength      : me.minLength,
            placeholderText: me.placeholderText,
            readOnly       : me.readOnly,
            required       : me.required,
            triggers       : me.triggers?.map(trigger => trigger.toJSON())
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Text));


/***/ },

/***/ "./src/form/field/trigger/Base.mjs"
/*!*****************************************!*\
  !*** ./src/form/field/trigger/Base.mjs ***!
  \*****************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * Base class for form field Triggers
 * @class Neo.form.field.trigger.Base
 * @extends Neo.component.Base
 */
class Base extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for align
     * @member {String[]} alignValues=['end', 'start']
     * @protected
     * @static
     */
    static alignValues = ['end', 'start']

    static config = {
        /**
         * @member {String} className='Neo.form.field.trigger.Base'
         * @protected
         */
        className: 'Neo.form.field.trigger.Base',
        /**
         * @member {String} ntype='trigger'
         * @protected
         */
        ntype: 'trigger',
        /**
         * @member {String} align_='end'
         * @reactive
         */
        align: 'end',
        /**
         * @member {String[]} baseCls=['neo-field-trigger']
         */
        baseCls: ['neo-field-trigger'],
        /**
         * @member {Neo.form.field.Base|null} field=null
         */
        field_: null,
        /**
         * @member {String|null} iconCls_=null
         * @reactive
         */
        iconCls_: null,
        /**
         * @member {Boolean} isHovered=false
         * @protected
         */
        isHovered: false,
        /**
         * The scope of the trigger handler
         * @member {Neo.core.Base|null} scope=null
         */
        scope: null,
        /**
         * @member {Boolean} showOnHover=false
         */
        showOnHover: false,
        /**
         * Internal flag used by field.getTrigger()
         * @member {String} type='base'
         * @protected
         */
        type: 'base',
        /**
         * @member {Number} weight_=10
         * @reactive
         */
        weight_: 10
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.addDomListeners(
            {click: me.onTriggerClick, scope: me}
        );

        if (me.showOnHover) {
            me.hidden = true;

            me.field.on('constructed', () => {
                me.field.addDomListeners([
                    {mouseenter: me.onMouseEnter, scope: me},
                    {mouseleave: me.onMouseLeave, scope: me}
                ])
            }, me)
        }
    }

    /**
     * Triggered after the align config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetAlign(value, oldValue) {
        let cls = this.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"][value === 'start' ? 'add' : 'remove'](cls, 'neo-align-start');
        this.cls = cls
    }

    /**
     * Triggered after the field config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetField(value, oldValue) {
        (this.vdom.data || (this.vdom.data = {})).focus = value?.getInputElId()
    }

    /**
     * Triggered after the hidden config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetHidden(value, oldValue) {
        let {style} = this;

        style.display = value ? 'none' : 'inherit';
        this.style = style
    }

    /**
     * Triggered after the iconCls config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetIconCls(value, oldValue) {
        let {cls} = this;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, oldValue?.split(' '));

        if (value && value !== '') {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, value?.split(' '))
        }

        this.cls = cls
    }

    /**
     * Triggered before the align config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetAlign(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'align', 'alignValues')
    }

    /**
     * @param {Boolean} updateParentVdom
     * @param {Boolean} silent
     */
    destroy(updateParentVdom, silent) {
        let me = this;

        me.removeDomListeners(
            {click: me.onTriggerClick, scope: me}
        );

        delete me.field;

        super.destroy(updateParentVdom, silent)
    }

    /**
     *
     */
    onMouseEnter() {
        this.isHovered = true;
        this.hidden    = false
    }

    /**
     *
     */
    onMouseLeave() {
        this.isHovered = false;
        this.hidden    = true
    }

    /**
     * click domEvent listener
     * @param {Object} data
     * @protected
     */
    onTriggerClick(data) {
        let me    = this,
            scope = me.scope || me;

        if (me.handler) {
            scope[me.handler].call(scope)
        }
    }

    /**
     * Serializes the trigger into a JSON-compatible object.
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            iconCls    : me.iconCls,
            showOnHover: me.showOnHover,
            type       : me.type,
            weight     : me.weight
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Base));


/***/ },

/***/ "./src/form/field/trigger/Clear.mjs"
/*!******************************************!*\
  !*** ./src/form/field/trigger/Clear.mjs ***!
  \******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/form/field/trigger/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * Clear Trigger to remove the input value of TextFields or subclasses
 * @class Neo.form.field.trigger.Clear
 * @extends Neo.form.field.trigger.Base
 */
class Clear extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.form.field.trigger.Clear'
         * @protected
         */
        className: 'Neo.form.field.trigger.Clear',
        /**
         * @member {String} ntype='trigger-clear'
         * @protected
         */
        ntype: 'trigger-clear',
        /**
         * @member {String[]} baseCls=['neo-field-trigger','neo-trigger-clear']
         */
        baseCls: ['neo-field-trigger', 'neo-trigger-clear'],
        /**
         * @member {String|null} iconCls='fa fa-times'
         * @reactive
         */
        iconCls: 'fa fa-times',
        /**
         * Internal flag used by field.getTrigger()
         * @member {String} type='clear'
         * @protected
         */
        type: 'clear',
        /**
         * @member {Number} weight_=20
         * @reactive
         */
        weight: 20
    }

    /**
     * Triggered after the hidden config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetHidden(value, oldValue) {
        let {cls} = this;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"][value ? 'add' : 'remove'](cls, 'neo-is-hidden');
        this.cls = cls;
    }

    /**
     * Triggered before the hidden config gets changed.
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    beforeSetHidden(value, oldValue) {
        if (this.showOnHover && !this.isHovered) {
            return true
        }

        return value
    }

    /**
     *
     */
    destroy(...args) {
        let me = this;

        me.field.un({
            change                    : me.onFieldChange,
            changeClearToOriginalValue: me.onFieldChange,
            scope                     : me
        });

        super.destroy(...args)
    }

    /**
     * @returns {Boolean} true in case the trigger should be hidden
     */
    getHiddenState() {
        let me      = this,
            {field} = me,
            {value} = field;

        if (field.clearToOriginalValue) {
            return value === field.originalConfig.value;
        } else {
            if (value === 0) {
                value = '0'
            }

            return !field.value || value.toString().length < 1
        }
    }

    /**
     * @param {Object} opts
     */
    onFieldChange(opts) {
        this.hidden = this.getHiddenState()
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me = this;

        me.field.on({
            change                    : me.onFieldChange,
            changeClearToOriginalValue: me.onFieldChange,
            scope                     : me
        });

        me.hidden = me.getHiddenState()
    }

    /**
     * @override
     */
    onMouseEnter() {
        let me = this;

        me.isHovered = true;
        me.hidden    = me.getHiddenState()
    }

    /**
     * @param {Object} data
     */
    onTriggerClick(data) {
        this.field.clear()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Clear));


/***/ },

/***/ "./src/form/field/trigger/SpinDown.mjs"
/*!*********************************************!*\
  !*** ./src/form/field/trigger/SpinDown.mjs ***!
  \*********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/form/field/trigger/Base.mjs");


/**
 * Decreases the value of a NumberField
 * @class Neo.form.field.trigger.SpinDown
 * @extends Neo.form.field.trigger.Base
 */
class SpinDown extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.form.field.trigger.SpinUp'
         * @protected
         */
        className: 'Neo.form.field.trigger.SpinDown',
        /**
         * @member {String} ntype='trigger-spindown'
         * @protected
         */
        ntype: 'trigger-spindown',
        /**
         * @member {String} align_='start'
         * @reactive
         */
        align: 'start',
        /**
         * @member {String|null} iconCls='fa fa-chevron-left'
         * @reactive
         */
        iconCls: 'fa fa-chevron-left',
        /**
         * Internal flag used by field.getTrigger()
         * @member {String} type='spindown'
         * @protected
         */
        type: 'spindown'
    }

    /**
     * @param {Object} data
     */
    onTriggerClick(data) {
        this.field.onSpinButtonDownClick()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(SpinDown));


/***/ },

/***/ "./src/form/field/trigger/SpinUp.mjs"
/*!*******************************************!*\
  !*** ./src/form/field/trigger/SpinUp.mjs ***!
  \*******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/form/field/trigger/Base.mjs");


/**
 * Increases the value of a NumberField
 * @class Neo.form.field.trigger.SpinUp
 * @extends Neo.form.field.trigger.Base
 */
class SpinUp extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.form.field.trigger.SpinUp'
         * @protected
         */
        className: 'Neo.form.field.trigger.SpinUp',
        /**
         * @member {String} ntype='trigger-spinup'
         * @protected
         */
        ntype: 'trigger-spinup',
        /**
         * @member {String|null} iconCls='fa fa-chevron-right'
         * @reactive
         */
        iconCls: 'fa fa-chevron-right',
        /**
         * Internal flag used by field.getTrigger()
         * @member {String} type='spinup'
         * @protected
         */
        type: 'spinup'
    }

    /**
     * @param {Object} data
     */
    onTriggerClick(data) {
        this.field.onSpinButtonUpClick()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(SpinUp));


/***/ },

/***/ "./src/form/field/trigger/SpinUpDown.mjs"
/*!***********************************************!*\
  !*** ./src/form/field/trigger/SpinUpDown.mjs ***!
  \***********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/form/field/trigger/Base.mjs");


/**
 * Combines spin up & down inside one trigger
 * @class Neo.form.field.trigger.SpinUpDown
 * @extends Neo.form.field.trigger.Base
 */
class SpinUpDown extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.form.field.trigger.SpinUpDown'
         * @protected
         */
        className: 'Neo.form.field.trigger.SpinUpDown',
        /**
         * @member {String} ntype='trigger-spinupdown'
         * @protected
         */
        ntype: 'trigger-spinupdown',
        /**
         * @member {String[]} baseCls=['neo-field-trigger','neo-spin-buttons']
         */
        baseCls: ['neo-field-trigger', 'neo-spin-buttons'],
        /**
         * @member {String} spinButtonDownIconCls='fa fa-chevron-down'
         */
        spinButtonDownIconCls: 'fa fa-chevron-down',
        /**
         * @member {String} spinButtonUpIconCls='fa fa-chevron-up'
         */
        spinButtonUpIconCls: 'fa fa-chevron-up',
        /**
         * Internal flag used by field.getTrigger()
         * @member {String} type='spinupdown'
         * @protected
         */
        type: 'spinupdown'
    }

    /**
     *
     */
    onConstructed() {
        let me = this;

        me.vdom.cn = [
            {cls: ['neo-spin-button', 'neo-up',   ...me.spinButtonUpIconCls  .split(' ')]},
            {cls: ['neo-spin-button', 'neo-down', ...me.spinButtonDownIconCls.split(' ')]}
        ];

        me.update();

        super.onConstructed()
    }

    /**
     * @param {Object} data
     */
    onTriggerClick(data) {
        let me     = this,
            target = data.path[0],
            cls    = target.cls.join(' ');

        if (cls.includes('neo-down')) {
            me.field.onSpinButtonDownClick()
        } else if (cls.includes('neo-up')) {
            me.field.onSpinButtonUpClick()
        }
    }

    /**
     * Serializes the trigger into a JSON-compatible object.
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            spinButtonDownIconCls: me.spinButtonDownIconCls,
            spinButtonUpIconCls  : me.spinButtonUpIconCls
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(SpinUpDown));


/***/ },

/***/ "./src/layout/Base.mjs"
/*!*****************************!*\
  !*** ./src/layout/Base.mjs ***!
  \*****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * The base class for all other layouts.
 * Use it directly in case you want to create a container without a layout.
 * @class Neo.layout.Base
 * @extends Neo.core.Base
 */
class Layout extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.layout.Base'
         * @protected
         */
        className: 'Neo.layout.Base',
        /**
         * @member {String} ntype='layout-base'
         * @protected
         */
        ntype: 'layout-base',
        /**
         * The name of the App this layout belongs to
         * @member {String|null} appName_=null
         * @reactive
         */
        appName_: null,
        /**
         * The id of the Container instance this layout is bound to
         * @member {?String} containerId=null
         * @protected
         */
        containerId: null,
        /**
         * A layout specific CSS selector which gets added to Container the layout is bound to.
         * @member {String|null} containerCls_=null
         * @protected
         * @reactive
         */
        containerCls_: null,
        /**
         * Identifier for all classes that extend layout.Base
         * @member {Boolean} isLayout=true
         * @protected
         */
        isLayout: true,
        /**
         * @member {Number|null} windowId_=null
         * @reactive
         */
        windowId_: null
    }

    /**
     * @returns {Neo.container.Base|null}
     */
    get container() {
        let {containerId} = this;

        // the instance might not be registered yet
        return Neo.getComponent(containerId) || Neo.get(containerId)
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        value && Neo.currentWorker.insertThemeFiles(value, this.__proto__)
    }

    /**
     * Placeholder method
     * @param {Neo.component.Base} item
     * @param {Number} index
     * @protected
     */
    applyChildAttributes(item, index) {}

    /**
     * @param {Boolean} silent=false
     * @protected
     */
    applyRenderAttributes(silent=false) {
        let me                        = this,
            {container, containerCls} = me,
            {wrapperCls}              = container;

        if (containerCls) {
            if (!container) {
                Neo.logError(me.className + ': applyRenderAttributes -> container not yet created', me.containerId)
            }

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(wrapperCls, containerCls);

            container[silent ? 'setSilent' :  'set']({wrapperCls})
        }
    }

    /**
     *
     */
    destroy() {
        let me = this;

        me.bind && me.getStateProvider()?.removeBindings(me.id);

        super.destroy()
    }

    /**
     * Returns the container stateProvider or its closest parent stateProvider
     * @param {String} [ntype]
     * @returns {Neo.state.Provider|null}
     */
    getStateProvider(ntype) {
        return this.container.getStateProvider(ntype)
    }

    /**
     * Applies all class configs to this instance
     * @param {Object} config
     * @param {Boolean} [preventOriginalConfig] True prevents the instance from getting an originalConfig property
     */
    initConfig(config, preventOriginalConfig) {
        super.initConfig(config, preventOriginalConfig);

        let me = this;

        me.bind && me.container.getStateProvider()?.createBindings(me)
    }

    /**
     * Placeholder method
     * @param {Neo.component.Base} item
     * @param {Number} index
     * @protected
     */
    removeChildAttributes(item, index) {}

    /**
     * @protected
     */
    removeRenderAttributes() {
        let me                        = this,
            {container, containerCls} = me,
            {wrapperCls}              = container;

        if (containerCls) {
            if (!container) {
                Neo.logError(me.className + ': removeRenderAttributes -> container not yet created', me.containerId)
            }

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(wrapperCls, containerCls);

            container.wrapperCls = wrapperCls
        }
    }

    /**
     * Change multiple configs at once, ensuring that all afterSet methods get all new assigned values
     * @param {Object} values={}
     * @param {Boolean} silent=false
     * @returns {Promise<*>}
     */
    set(values={}, silent=false) {
        let me          = this,
            {container} = me;

        container.silentVdomUpdate = true;

        super.set(values);

        container.silentVdomUpdate = false;

        if (silent || !container.needsVdomUpdate) {
            return Promise.resolve()
        } else {
            return container.promiseUpdate()
        }
    }

    /**
     * Convenience shortcut calling set() with the silent flag
     * @param {Object} values={}
     */
    setSilent(values={}) {
        return this.set(values, true)
    }

    /**
     * Serializes the instance into a JSON-compatible object for the Neural Link.
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            appName     : me.appName,
            containerCls: me.containerCls,
            containerId : me.containerId,
            windowId    : me.windowId
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Layout));


/***/ },

/***/ "./src/layout/Card.mjs"
/*!*****************************!*\
  !*** ./src/layout/Card.mjs ***!
  \*****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/layout/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @class Neo.layout.Card
 * @extends Neo.layout.Base
 */
class Card extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /*
     * The name of the CSS class for an active item inside the card layout
     * @member {String} activeItemCls='neo-active-item'
     * @static
     */
    static activeItemCls = 'neo-active-item'
    /*
     * The name of the CSS class for an inactive item inside the card layout
     * @member {String} inactiveItemCls='neo-inactive-item'
     * @static
     */
    static inactiveItemCls = 'neo-inactive-item'
    /*
     * The name of the CSS class for an item inside the card layout
     * @member itemCls
     * @static
     */
    static itemCls = 'neo-layout-card-item'
    /**
     * Valid values for slideDirection
     * @member {String[]} iconPositions=['horizontal','vertical',null]
     * @protected
     * @static
     */
    static slideDirections = ['horizontal', 'vertical', null]

    static config = {
        /**
         * @member {String} className='Neo.layout.Card'
         * @protected
         */
        className: 'Neo.layout.Card',
        /**
         * @member {String} ntype='layout-card'
         * @protected
         */
        ntype: 'layout-card',
        /*
         * The item index of the card, which is currently active.
         * Change this value to activate a different card.
         * @member {Number} activeIndex_=0
         */
        activeIndex_: 0,
        /**
         * @member {String|null} containerCls='neo-layout-card'
         * @protected
         * @reactive
         */
        containerCls: 'neo-layout-card',
        /*
         * Remove the DOM of inactive cards.
         * This will keep the instances & vdom trees
         * @member {Boolean} removeInactiveCards=true
         */
        removeInactiveCards: true,
        /*
         * Valid values: 'horizontal', 'vertical', null
         * @member {String|null} slideDirection_=null
         */
        slideDirection_: null
    }

    /**
     * Modifies the CSS classes of the container items this layout is bound to.
     * Automatically gets triggered after changing the value of activeIndex.
     * Lazy loads items which use a module config containing a function.
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    async afterSetActiveIndex(value, oldValue) {
        let me              = this,
            {container, removeInactiveCards} = me,
            sCfg            = me.constructor,
            needsTransition = me.slideDirection && oldValue !== undefined,
            needsUpdate     = false,
            i, isActiveIndex, item, items, len, module, wrapperCls;

        if (Neo.isNumber(value) && container) {
            items = container.items;
            len   = items.length;

            if (!items[value]) {
                Neo.error('Trying to activate a non existing card', value, items)
            }

            // we need to run the loop twice, since lazy loading a module at a higher index does affect lower indexes
            for (i=0; i < len; i++) {
                module = items[i].module;

                if (i === value && Neo.typeOf(module) === 'Function') {
                    needsUpdate = true;
                    break
                }
            }

            for (i=0; i < len; i++) {
                isActiveIndex = i === value;
                item          = items[i];
                module        = item.module;

                if (isActiveIndex && Neo.typeOf(module) === 'Function') {
                    item = await me.loadModule(item, i)
                }

                if (item instanceof Neo.component.Base) {
                    wrapperCls = item.wrapperCls;

                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(wrapperCls, isActiveIndex ? sCfg.inactiveItemCls : sCfg.activeItemCls);
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(   wrapperCls, isActiveIndex ? sCfg.activeItemCls   : sCfg.inactiveItemCls);

                    if (removeInactiveCards || needsUpdate) {
                        if (isActiveIndex) {
                            delete item.vdom.removeDom;
                            !needsTransition && item.activate?.()
                        } else if (removeInactiveCards) {
                            item.mounted        = false;
                            item.vdom.removeDom = true
                        }
                    }

                    item.wrapperCls = wrapperCls
                }
            }

            if (needsTransition) {
                await me.slideCards(value, oldValue)
            } else if (removeInactiveCards || needsUpdate) {
                container.updateDepth = -1; // include the full tree to honor new or changed inactive cards
                container.update()
            }
        }
    }

    /**
     * Initially sets the CSS classes of the container items this layout is bound to.
     * @param {Neo.component.Base} item
     * @param {Number} index
     * @param {Boolean} [keepInDom=false]
     */
    applyChildAttributes(item, index, keepInDom=false) {
        let me            = this,
            isActiveIndex = me.activeIndex === index,
            sCfg          = me.constructor,
            childCls      = item.wrapperCls || [],
            {vdom}        = item;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(childCls, sCfg.itemCls);
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(childCls, isActiveIndex ? sCfg.activeItemCls : sCfg.inactiveItemCls);

        if (!keepInDom && me.removeInactiveCards) {
            vdom.removeDom  = !isActiveIndex;
            item.wrapperCls = childCls;
            item.update?.() // can get called for an item config
        } else {
            item.wrapperCls = childCls
        }
    }

    /**
     * Triggered before the slideDirection config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @returns {String}
     * @protected
     */
    beforeSetSlideDirection(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'slideDirection')
    }

    /**
     * Loads a component.Base module which is defined via module: () => import('...')
     * @param {Object} item
     * @param {Number} [index]
     * @returns {Neo.component.Base}
     */
    async loadModule(item, index) {
        let me          = this,
            {container} = me,
            items       = container.items,
            {module}    = item,
            proto;

        if (!Neo.isNumber(index)) {
            index = items.indexOf(item)
        }

        item.isLoading = true; // prevent the item from getting queued multiple times inside form.Container

        module = await module();
        module = module.default;
        proto  = module.prototype;

        item.className = proto.className;
        item.module    = module;

        delete item.isLoading;
        delete item.vdom;

        items[index] = item = Neo.create(item);

        me.applyChildAttributes(item, index);

        container.getVdomItemsRoot().cn[index] = item.createVdomReference();

        container.fire('cardLoaded', {item});

        return item
    }

    /**
     * @param {Number} index
     * @param {Number} oldIndex
     */
    async slideCards(index, oldIndex) {
        let me            = this,
            {container}   = me,
            slideVertical = me.slideDirection === 'vertical',
            {items, vdom} = container,
            card          = items[index],
            oldCard       = items[oldIndex],
            slideIn       = index > oldIndex,
            rect          = await container.getDomRect(container.id),
            animationWrapper, style, x, y;

        delete oldCard.vdom.removeDom;

        if (slideVertical) {
            y = slideIn ? 0 : -rect.height;

            style = {
                flexDirection: 'column',
                height       : `${2 * rect.height}px`,
                transform    : `translateY(${y}px)`,
                width        : `${rect.width}px`
            }
        } else {
            x = slideIn ? 0 : -rect.width;

            style = {
                height   : `${rect.height}px`,
                transform: `translateX(${x}px)`,
                width    : `${2 * rect.width}px`
            }
        }

        vdom.cn = [
            {cls: ['neo-relative'], cn: [
                {cls: ['neo-animation-wrapper'], style, cn: [card.createVdomReference()]}
            ]}
        ];

        animationWrapper = vdom.cn[0].cn[0];

        animationWrapper.cn[slideIn ? 'unshift' : 'push'](oldCard.createVdomReference());

        container.updateDepth = -1;

        await container.promiseUpdate();

        animationWrapper.style.transform = slideVertical ?
            `translateY(${slideIn ? -rect.height : 0}px)` :
            `translateX(${slideIn ? -rect.width  : 0}px)`;

        await container.promiseUpdate();

        await me.timeout(300); // transition duration defined via CSS for now

        vdom.cn = [];

        container.items.forEach(item => {
            vdom.cn.push(item.createVdomReference())
        });

        oldCard.vdom.removeDom = true;

        container.updateDepth = -1;

        await container.promiseUpdate()
    }

    /**
     * Serializes the instance into a JSON-compatible object for the Neural Link.
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            activeIndex        : me.activeIndex,
            containerCls       : me.containerCls,
            removeInactiveCards: me.removeInactiveCards,
            slideDirection     : me.slideDirection
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Card));


/***/ },

/***/ "./src/layout/Fit.mjs"
/*!****************************!*\
  !*** ./src/layout/Fit.mjs ***!
  \****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/layout/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @class Neo.layout.Fit
 * @extends Neo.layout.Base
 */
class Fit extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.layout.Fit'
         * @protected
         */
        className: 'Neo.layout.Fit',
        /**
         * @member {String} ntype='layout-fit'
         * @protected
         */
        ntype: 'layout-fit',
        /**
         * @member {String|null} containerCls='neo-layout-fit'
         * @protected
         * @reactive
         */
        containerCls: 'neo-layout-fit'
    }

    /**
     * Initially sets the CSS classes of the container items this layout is bound to.
     * @param {Neo.component.Base} item
     * @param {Number} index
     */
    applyChildAttributes(item, index) {
        if (!item.ignoreLayout) {
            item.wrapperCls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].union(item.wrapperCls, 'neo-layout-fit-item')
        }
    }

    /**
     * Removes all CSS rules from a container item this layout is bound to.
     * Gets called when switching to a different layout.
     * @param {Neo.component.Base} item
     * @param {Number} index
     */
    removeChildAttributes(item, index) {
        if (!item.ignoreLayout) {
            let {wrapperCls} = item;

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(wrapperCls, 'neo-layout-fit-item');
            item.wrapperCls = wrapperCls
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Fit));


/***/ },

/***/ "./src/layout/Flexbox.mjs"
/*!********************************!*\
  !*** ./src/layout/Flexbox.mjs ***!
  \********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/layout/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @class Neo.layout.Flexbox
 * @extends Neo.layout.Base
 */
class Flexbox extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for align
     * @member {String[]} alignValues=['center','end','start','stretch',null]
     * @protected
     * @static
     */
    static alignValues = ['center', 'end', 'start', 'stretch', null]
    /**
     * Valid values for direction
     * @member {String[]} directionValues=['column','column-reverse','row','row-reverse',null]
     * @protected
     * @static
     */
    static directionValues = ['column', 'column-reverse', 'row', 'row-reverse', null]
    /**
     * Valid values for pack
     * @member {String[]} packValues=['center','end','start',null]
     * @protected
     * @static
     */
    static packValues = ['center', 'end', 'start', null]
    /**
     * Valid values for wrap
     * @member {String[]} wrapValues=['nowrap','wrap','wrap-reverse']
     * @protected
     * @static
     */
    static wrapValues = ['nowrap', 'wrap', 'wrap-reverse']

    static config = {
        /**
         * @member {String} className='Neo.layout.Flexbox'
         * @protected
         */
        className: 'Neo.layout.Flexbox',
        /**
         * @member {String} ntype='layout-flexbox'
         * @protected
         */
        ntype: 'layout-flexbox',
        /**
         * Valid values: 'center', 'end', 'start', 'stretch', null
         * @member {String|null} align_=null
         * @reactive
         */
        align_: null,
        /**
         * Valid values: 'column', 'column-reverse', 'row', 'row-reverse', null
         * @member {String|null} direction_=null
         * @reactive
         */
        direction_: null,
        /**
         * flex css allows gap. This adds it to the component style
         * @member {String} gap_=null
         * @reactive
         */
        gap_: null,
        /**
         * Valid values: 'center', 'end', 'start', null
         * @member {String|null} pack_=null
         * @reactive
         */
        pack_: null,
        /**
         * CSS className prefix
         * @member {String} prefix='neo-flex-'
         */
        prefix: 'neo-flex-',
        /**
         * Valid values: nowrap, wrap, wrapreverse
         * @member {String} wrap_='nowrap'
         * @reactive
         */
        wrap_: 'nowrap'
    }

    /**
     * Updates the Container CSS cls after "align" gets changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetAlign(value, oldValue) {
        oldValue && this.updateInputValue(value, oldValue, 'align')
    }

    /**
     * Updates the Container CSS cls after "direction" gets changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetDirection(value, oldValue) {
        oldValue && this.updateInputValue(value, oldValue, 'direction')
    }

    /**
     * Updates the Container style to add a gap to display:flex
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetGap(value, oldValue) {
        if (!value && !oldValue) return;

        let {container}    = this,
            {wrapperStyle} = container;

        wrapperStyle.gap = value;

        container.wrapperStyle = wrapperStyle
    }

    /**
     * Updates the Container CSS cls after "pack" gets changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetPack(value, oldValue) {
        oldValue && this.updateInputValue(value, oldValue, 'pack')
    }

    /**
     * Updates the Container CSS cls after "wrap" gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetWrap(value, oldValue) {
        oldValue && this.updateInputValue(value, oldValue, 'wrap')
    }

    /**
     * Applies the flex value to an item of the container this layout is bound to
     * @param {Neo.component.Base} item
     * @param {Number} index
     */
    applyChildAttributes(item, index) {
        if (!item.wrapperStyle) return;

        let style = item.wrapperStyle,
            flex  = style.flex || item.flex || (this.align === 'stretch' ? 1 : '0 1 auto');

        if (Neo.isNumber(flex)) {
            flex = `${flex} 1 0%`
        }

        style.flex = flex;
        item.wrapperStyle = style
    }

    /**
     * Applies CSS classes to the container this layout is bound to
     */
    applyRenderAttributes() {
        let me                  = this,
            {container, prefix} = me,
            {wrapperCls}        = container;

        if (!container) {
            Neo.logError('layout.Flexbox: applyRenderAttributes -> container not yet created', me.containerId)
        }

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(wrapperCls, prefix + 'container');

        me.align     && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(wrapperCls, prefix + 'align-'     + me.align);
        me.direction && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(wrapperCls, prefix + 'direction-' + me.direction);
        me.pack      && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(wrapperCls, prefix + 'pack-'      + me.pack);
        me.wrap      && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(wrapperCls, prefix + 'wrap-'      + me.wrap);

        container.wrapperCls = wrapperCls
    }

    /**
     * Checks if the new value for "align" is valid
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     * @returns {String|null} value
     */
    beforeSetAlign(value, oldValue) {
        return this.testInputValue(value, oldValue, 'alignValues', 'align')
    }

    /**
     * Checks if the new value for "direction" is valid
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     * @returns {String|null} value
     */
    beforeSetDirection(value, oldValue) {
        return this.testInputValue(value, oldValue, 'directionValues', 'direction')
    }

    /**
     * Checks if the new value for "pack" is valid
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     * @returns {String|null} value
     */
    beforeSetPack(value, oldValue) {
        return this.testInputValue(value, oldValue, 'packValues', 'pack')
    }

    /**
     * Checks if the new value for "wrap" is valid
     * @param {String} value
     * @param {String} oldValue
     * @protected
     * @returns {String} value
     */
    beforeSetWrap(value, oldValue) {
        return this.testInputValue(value, oldValue, 'wrapValues', 'wrap')
    }

    /**
     * Removes all CSS rules from a container item this layout is bound to.
     * Gets called when switching to a different layout.
     * @param {Neo.component.Base} item
     * @param {Number} index
     * @protected
     */
    removeChildAttributes(item, index) {
        let style = item.wrapperStyle || {};

        style.flex = item.flex || null;
        item.wrapperStyle = style
    }

    /**
     * Removes all CSS rules from the container this layout is bound to.
     * Gets called when switching to a different layout.
     * @protected
     */
    removeRenderAttributes() {
        let me                  = this,
            {container, prefix} = me,
            {wrapperCls}        = container;

        if (!container) {
            Neo.logError('layout.Flexbox: removeRenderAttributes -> container not yet created', me.containerId)
        }

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(wrapperCls, prefix + 'container');

        me.align     && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(wrapperCls, prefix + 'align-'     + me.align);
        me.direction && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(wrapperCls, prefix + 'direction-' + me.direction);
        me.pack      && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(wrapperCls, prefix + 'pack-'      + me.pack);
        me.wrap      && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(wrapperCls, prefix + 'wrap-'      + me.wrap);

        container.wrapperCls = wrapperCls
    }

    /**
     * Checks if the new value for propertyName is valid
     * @param {String|null} value
     * @param {String|null} oldValue
     * @param {String} validValuesName
     * @param {String} propertyName
     * @protected
     * @returns {String|null} value
     */
    testInputValue(value, oldValue, validValuesName, propertyName) {
        let validValues = this.getStaticConfig(validValuesName);

        if (!_util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].hasItem(validValues, value)) {
            Neo.logError(this.containerId, '-> layout: supported values for "' + propertyName + '" are' , validValues);
            return oldValue
        }

        return value;
    }

    /**
     * Serializes the instance into a JSON-compatible object for the Neural Link.
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            align    : me.align,
            direction: me.direction,
            gap      : me.gap,
            pack     : me.pack,
            prefix   : me.prefix,
            wrap     : me.wrap
        }
    }

    /**
     * Updates the Container CSS wrapperCls
     * @param {String|null} value
     * @param {String|null} oldValue
     * @param {String} propertyName
     * @protected
     */
    updateInputValue(value, oldValue, propertyName) {
        let me                  = this,
            {container, prefix} = me,
            {wrapperCls}        = container;

        if (container?.vnodeInitialized) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(wrapperCls, prefix + propertyName + '-' + oldValue);

            if (value !== null) {
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(wrapperCls, prefix + propertyName + '-' + value)
            }

            container.wrapperCls = wrapperCls
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Flexbox));


/***/ },

/***/ "./src/layout/Grid.mjs"
/*!*****************************!*\
  !*** ./src/layout/Grid.mjs ***!
  \*****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/layout/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @class Neo.layout.Grid
 * @extends Neo.layout.Base
 */
class Grid extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.layout.Grid'
         * @protected
         */
        className: 'Neo.layout.Grid',
        /**
         * @member {String} ntype='layout-hbox'
         * @protected
         */
        ntype: 'layout-grid',
        /**
         * @member {String|null} containerCls='neo-layout-fit'
         * @protected
         * @reactive
         */
        containerCls: 'neo-layout-grid'
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Grid));


/***/ },

/***/ "./src/layout/HBox.mjs"
/*!*****************************!*\
  !*** ./src/layout/HBox.mjs ***!
  \*****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Flexbox_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Flexbox.mjs */ "./src/layout/Flexbox.mjs");


/**
 * The HBox layout allows you to arrange components horizontally in a container.
 * @class Neo.layout.HBox
 * @extends Neo.layout.Flexbox
 */
class HBox extends _Flexbox_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.layout.HBox'
         * @protected
         */
        className: 'Neo.layout.HBox',
        /**
         * @member {String} ntype='layout-hbox'
         * @protected
         */
        ntype: 'layout-hbox',
        /**
         * @member {String} direction='row'
         * @protected
         * @reactive
         */
        direction: 'row'
    }

    /**
     * Applies the flex value to an item of the container this layout is bound to
     * @param {Neo.component.Base} item
     * @param {Number} index
     */
    applyChildAttributes(item, index) {
        // Do not apply flex if fixed width
        !item.width && super.applyChildAttributes(item, index)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(HBox));


/***/ },

/***/ "./src/layout/VBox.mjs"
/*!*****************************!*\
  !*** ./src/layout/VBox.mjs ***!
  \*****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Flexbox_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Flexbox.mjs */ "./src/layout/Flexbox.mjs");


/**
 * The VBox layout allows you to arrange components vertically in a container.
 * @class Neo.layout.VBox
 * @extends Neo.layout.Flexbox
 */
class VBox extends _Flexbox_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.layout.VBox'
         * @protected
         */
        className: 'Neo.layout.VBox',
        /**
         * @member {String} ntype='layout-vbox'
         * @protected
         */
        ntype: 'layout-vbox',
        /**
         * @member {String} direction='column'
         * @protected
         * @reactive
         */
        direction: 'column'
    }

    /**
     * Applies the flex value to an item of the container this layout is bound to
     * @param {Neo.component.Base} item
     * @param {Number} index
     */
    applyChildAttributes(item, index) {
        // Do not apply flex if fixed height
        !item.height && super.applyChildAttributes(item, index)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(VBox));


/***/ },

/***/ "./src/manager/Component.mjs"
/*!***********************************!*\
  !*** ./src/manager/Component.mjs ***!
  \***********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/manager/Base.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/VDom.mjs */ "./src/util/VDom.mjs");
/* harmony import */ var _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/VNode.mjs */ "./src/util/VNode.mjs");




/**
 * @class Neo.manager.Component
 * @extends Neo.manager.Base
 * @singleton
 */
class Component extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.Component'
         * @protected
         */
        className: 'Neo.manager.Component',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * A reverse map to track direct children for each component.
     * Keys are parent component IDs, values are Sets of child component IDs.
     * This enables O(1) retrieval of direct children, optimizing VDOM syncing and destruction logic.
     * @member {Map<String, Set<String>>} childMap=new Map()
     */
    childMap = new Map()

    /**
     * @member {Map} wrapperNodes=new Map()
     */
    wrapperNodes = new Map()

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        Neo.first        = me.getFirst.bind(me); // alias
        Neo.getComponent = me.get     .bind(me)  // alias
    }

    /**
     * Flattens a given vnode tree by replacing component based subtrees with componentId based references
     * @param {Object} vnode
     * @param {String} ownerId We do not want to replace the own id => wrapped items
     * @returns {Object}
     */
    addVnodeComponentReferences(vnode, ownerId) {
        vnode = {...vnode}; // shallow copy

        let me         = this,
            childNodes = vnode?.childNodes ? [...vnode.childNodes] : [],
            childNodeId, component, componentId, parentRef, referenceNode;

        vnode.childNodes = childNodes;

        childNodes.forEach((childNode, index) => {
            childNodeId = childNode.id;

            if (!childNode.componentId && childNodeId !== ownerId) {
                component = me.get(childNodeId);

                if (!component) {
                    // searching for wrapped components as a fallback
                    component = me.wrapperNodes.get(childNodeId);

                    if (component) {
                        // update the parent component reference => assign the wrapper id
                        componentId = component.id;
                        parentRef   = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].find(component.parent.vdom, {componentId}, false);

                        if (parentRef) {
                            parentRef.vdom.id = childNodeId
                        }
                    }
                }

                if (component) {
                    componentId   = component.id;
                    referenceNode = {componentId, id: childNodeId}
                }
            }

            childNodes[index] = component ? referenceNode : me.addVnodeComponentReferences(childNode, ownerId)
        });

        return vnode
    }

    /**
     * Returns the first component which matches the config-selector moving down the component items tree.
     * Use returnFirstMatch=false to get an array of all matching items instead.
     * If no match is found, returns null in case returnFirstMatch === true, otherwise an empty Array.
     * @param {Neo.component.Base|String} component
     * @param {Object|String|null} config
     * @param {Boolean} returnFirstMatch=true
     * @returns {Neo.component.Base|Neo.component.Base[]|null}
     */
    down(component, config, returnFirstMatch=true) {
        if (Neo.isString(component)) {
            component = this.getById(component);
        }

        let me          = this,
            matchArray  = [],
            returnValue = null,
            i           = 0,
            returnArray = [],
            childItems, configArray, configLength, len;

        if (Neo.isString(config)) {
            config = {
                ntype: config
            }
        } else if (!config) {
            config = {}
        }

        configArray  = Object.entries(config);
        configLength = configArray.length;

        configArray.forEach(([key, value]) => {
            if ((component[key] === value)
                || (key === 'ntype' && me.hasPrototypePropertyValue(component, key, value)))
            {
                matchArray.push(true)
            }
        });

        if (matchArray.length === configLength) {
            if (returnFirstMatch) {
                return component
            }

            returnArray.push(component)
        }

        childItems = me.getDirectChildren(component.id);
        len        = childItems.length;

        for (; i < len; i++) {
            returnValue = me.down(childItems[i], config, returnFirstMatch);

            if (returnFirstMatch) {
                if (returnValue !== null) {
                    return returnValue
                }
            } else if (returnValue.length > 0) {
                returnArray.push(...returnValue)
            }
        }

        return returnFirstMatch ? null: returnArray
    }

    /**
     * @param {Object[]} path
     * @returns {String|null} the component id in case there is a match
     */
    findParentComponent(path) {
        let me  = this,
            i   = 0,
            len = path?.length || 0,
            id;

        for (; i < len; i++) {
            id = path[i];

            if (id && me.has(id)) {
                return id
            }
        }

        return null
    }

    /**
     * Returns the object associated to the key, or null if there is none.
     * @param {Number|String} key
     * @param {Boolean}       [includeWrapperNodes=true]
     * @returns {Neo.component.Base|null}
     */
    get(key, includeWrapperNodes=true) {
        if (includeWrapperNodes) {
            let wrapperNode = this.wrapperNodes.get(key);

            if (wrapperNode) {
                return wrapperNode
            }
        }

        return super.get(key)
    }

    /**
     * Returns all child components which are recursively matched via their parentId
     * @param {Neo.component.Base} component
     * @returns {Neo.component.Base[]} childComponents
     */
    getChildComponents(component) {
        let me             = this,
            directChildren = me.getDirectChildren(component.id),
            components     = [],
            childComponents;

        directChildren.forEach(item => {
            components.push(item);

            childComponents = me.getChildComponents(item);

            childComponents && components.push(...childComponents)
        });

        return components
    }

    /**
     * todo: replace all calls of this method to calls using the util.VNode class
     * Get the ids of all child nodes of the given vnode
     * @param {Object} vnode
     * @param {String[]} childIds=[]
     * @returns {String[]} childIds
     */
    getChildIds(vnode, childIds=[]) {
        return _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getChildIds(vnode, childIds)
    }

    /**
     * Returns all child components found inside the vnode tree
     * @param {Neo.component.Base} component
     * @returns {Neo.component.Base[]} childComponents
     */
    getChildren(component) {
        let childComponents = [],
            childNodes      = _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getChildIds(component.vnode),
            childComponent;

        childNodes.forEach(node => {
            childComponent = this.get(node);

            if (childComponent) {
                childComponents.push(childComponent)
            }
        });

        return childComponents
    }

    /**
     * Returns an array of direct child components for a given parentId.
     * Uses the optimized `childMap` for O(1) lookup performance, avoiding the need to iterate
     * over all components in the manager.
     * @param {String} parentId
     * @returns {Neo.component.Base[]}
     */
    getDirectChildren(parentId) {
        if (!parentId) return [];

        let me   = this,
            ids  = me.childMap.get(parentId),
            children;

        if (!ids) return [];

        children = [];

        ids.forEach(id => {
            let component = me.get(id);
            if (component) {
                children.push(component)
            } else {
                // Cleanup dead references if any (should typically be handled by unregister)
                ids.delete(id)
            }
        });

        return children
    }

    /**
     * Returns the distance between a child and a parent component
     * @param {String} childId
     * @param {String} parentId
     * @returns {Number} -1 if not found
     */
    getDistance(childId, parentId) {
        let child    = this.get(childId),
            distance = 0;

        while (child?.parentId) {
            distance++;

            if (child.parentId === parentId) {
                return distance
            }
            child = this.get(child.parentId)
        }

        return -1
    }

    /**
     * !! For debugging purposes only !!
     *
     * Get the first component based on the ntype or other properties
     *
     * @param {String|Object|Array} componentDescription
     * @param {Boolean} returnFirstMatch=true
     * @returns {Neo.component.Base|null|Neo.component.Base[]}
     *
     * @example
     // as String: ntype[comma separated propterties]
     Neo.first('toolbar button[text=Try me,icon=people]')
     // as Object: Add properties. ntype is optional
     Neo.first({
                icon: 'people'
            })
     // as Array: An Array of Objects. No Strings allowed
     Neo.first([{
                ntype: 'toolbar'
            },{
                ntype: 'button', text: 'Try me', icon: 'people
            }])

     * The returnFirstMatch flag allows to return all items and
     * not stop after the first result.
     *
     * @example
     Neo.first('button', false) // => [Button, Button, Button]
     */
    getFirst(componentDescription, returnFirstMatch=true) {
        let objects = [],
            app     = Object.values(Neo.apps)[0],
            root    = app.mainView;

        /* create an array of objects from string */
        if (Neo.isString(componentDescription)) {
            const regex = /(\w*)(\[[^\]]*\])|(\w*)/g;
            let match;

            /* generate objects which contain the information */
            while (match = regex.exec(componentDescription)) {
                let [, ntype, pairs, ntypeOnly] = match, obj;

                ntype = ntype || ntypeOnly;
                obj = {ntype};

                if (pairs) {
                    const pairsRegex = /\[(.*?)\]/,
                          pairsMatch = pairs.match(pairsRegex);

                    if (pairsMatch) {
                        const pairs = pairsMatch[1].split(',');
                        pairs.forEach((pair) => {
                            const [key, value] = pair.split('=');
                            obj[key] = value.replace(/"/g, '')
                        });
                    }
                }
                objects.push(obj);

                regex.lastIndex++
            }
        } else if (Neo.isObject(componentDescription)){
            objects.push(componentDescription)
        } else if (Neo.isArray(componentDescription)) {
            objects = componentDescription
        }

        /* find the correct child using down() */
        const result = objects.reduce((acc, key) => {
            if (acc) {
                let child = acc.down(key, returnFirstMatch);

                if (!!child) {
                    return child
                }
            }

            return null
        }, root);

        return result
    }

    /**
     * Returns an Array containing the ids of all parent components for a given component
     * @param {Neo.component.Base} component
     * @returns {String[]} parentIds
     */
    getParentIds(component) {
        let parentIds = [];

        while (component?.parentId) {
            component = this.get(component.parentId);

            if (component) {
                parentIds.push(component.id)
            }
        }

        return parentIds
    }

    /**
     * @param {Array} path
     * @returns {Array}
     */
    getParentPath(path) {
        let me            = this,
            componentPath = [],
            i             = 0,
            len           = path?.length || 0,
            component, id;

        for (; i < len; i++) {
            id = path[i];

            if (me.has(id) || me.wrapperNodes.get(id)) {
                component = me.get(id);

                while (component) {
                    componentPath.push(component.id);
                    component = component.parent
                }

                break
            }
        }

        return componentPath
    }

    /**
     * Returns an Array containing all parent components for a given component or component id
     * @param {Neo.component.Base|String} component
     * @returns {Neo.component.Base[]} parents
     */
    getParents(component) {
        if (Neo.isString(component)) {
            component = this.get(component)
        }

        let parents = [];

        while (component?.parentId) {
            component = this.get(component.parentId);

            if (component) {
                parents.push(component)
            }
        }

        return parents
    }

    /**
     * Checks if a component is a descendant of another component
     * @param {String} childId
     * @param {String} parentId
     * @returns {Boolean}
     */
    hasParent(childId, parentId) {
        let child = this.get(childId);

        while (child?.parentId) {
            if (child.parentId === parentId) {
                return true
            }
            child = this.get(child.parentId)
        }

        return false
    }

    /**
     * Check if the component had a property of any value somewhere in the Prototype chain
     *
     * @param {Neo.component.Base} component
     * @param {String} property
     * @param {*} value
     * @returns {boolean}
     */
    hasPrototypePropertyValue(component, property, value) {
        while (component !== null) {
            if (component.hasOwnProperty(property) && component[property] === value) {
                return true
            }

            component = component.__proto__
        }

        return false
    }

    /**
     * Updates the `childMap` when a component's `parentId` config changes.
     * Maintains the integrity of the reverse parent-child index.
     * @param {Neo.component.Base} component
     * @param {String|null} oldParentId
     */
    onParentIdChange(component, oldParentId) {
        let me          = this,
            newParentId = component.parentId,
            set;

        // Remove from old parent's set
        if (oldParentId) {
            set = me.childMap.get(oldParentId);
            if (set) {
                set.delete(component.id);
                if (set.size === 0) {
                    me.childMap.delete(oldParentId)
                }
            }
        }

        // Add to new parent's set
        if (newParentId) {
            set = me.childMap.get(newParentId);
            if (!set) {
                set = new Set();
                me.childMap.set(newParentId, set)
            }
            set.add(component.id)
        }
    }

    /**
     * Registers a component and adds it to the `childMap` if it has a parentId.
     * @param {Object} item
     */
    register(item) {
        super.register(item);

        const {id, parentId} = item;

        if (parentId) {
            let me  = this,
                set = me.childMap.get(parentId);

            if (!set) {
                set = new Set();
                me.childMap.set(parentId, set)
            }
            set.add(id)
        }
    }

    /**
     * @param {String} wrapperId
     * @param {Neo.component.Base} component
     */
    registerWrapperNode(wrapperId, component) {
        this.wrapperNodes.set(wrapperId, component)
    }

    /**
     * Unregisters a component, cleaning up wrapper nodes and `childMap` references.
     * @param {Neo.component.Base|String} item
     */
    unregister(item) {
        let me        = this,
            component = item;

        if (item) {
            if (Neo.isString(item)) {
                me.wrapperNodes.delete(item);
                component = me.get(item)
            }

            if (component) {
                const {id, parentId, vdom} = component;

                if (vdom && id !== vdom.id) {
                    me.wrapperNodes.delete(vdom.id)
                }

                if (parentId) {
                    let set = me.childMap.get(parentId);

                    if (set) {
                        set.delete(id);

                        if (set.size === 0) {
                            me.childMap.delete(parentId)
                        }
                    }
                }
            }
        }

        super.unregister(item)
    }

    /**
     * Returns the first component which matches the config-selector.
     * Use returnFirstMatch=false to get an array of all matching items instead.
     * If no match is found, returns null in case returnFirstMatch === true, otherwise an empty Array.
     * @param {String} componentId
     * @param {Object|String|null} config
     * @param {Boolean} returnFirstMatch=true
     * @returns {Neo.component.Base|Neo.component.Base[]|null}
     */
    up(componentId, config, returnFirstMatch=true) {
        let component   = this.get(componentId),
            returnArray = [],
            configArray, configLength, matchArray;

        if (Neo.isString(config)) {
            config = {
                ntype: config
            }
        } else if (!config) {
            config = {}
        }

        configArray  = Object.entries(config);
        configLength = configArray.length;

        while (component?.parentId) {
            component = this.get(component.parentId);

            if (!component) {
                return returnFirstMatch ? null : returnArray
            }

            matchArray = [];

            configArray.forEach(([key, value]) => {
                if (component[key] === value) {
                    matchArray.push(true)
                }
            });

            if (matchArray.length === configLength) {
                if (returnFirstMatch) {
                    return component
                }

                returnArray.push(component)
            }
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Component));


/***/ },

/***/ "./src/manager/DomEvent.mjs"
/*!**********************************!*\
  !*** ./src/manager/DomEvent.mjs ***!
  \**********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Component.mjs */ "./src/manager/Component.mjs");
/* harmony import */ var _Focus_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Focus.mjs */ "./src/manager/Focus.mjs");
/* harmony import */ var _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Logger.mjs */ "./src/util/Logger.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/VDom.mjs */ "./src/util/VDom.mjs");
/* harmony import */ var _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/VNode.mjs */ "./src/util/VNode.mjs");








const eventConfigKeys = [
    'bubble',
    'delegate',
    'local',
    'scope',
    'vnodeId'
];

const handlerMap = {
    change     : 'onChange',
    click      : 'onClick',
    contextmenu: 'onContextMenu',
    dblclick   : 'onDoubleClick',
    focusin    : 'onFocusIn',
    focusout   : 'onFocusOut',
    input      : 'onChange',
    keydown    : 'onKeyDown',
    keyup      : 'onKeyUp',
    mousedown  : 'onMouseDown',
    mouseenter : 'onMouseEnter',
    mouseleave : 'onMouseLeave',
    mousemove  : 'onMouseMove',
    mouseup    : 'onMouseUp',
    scroll     : 'onScroll',
    wheel      : 'onWheel'
};

const globalDomEvents = [
    'change',
    'click',
    'contextmenu',
    'dblclick',
    'drag:end',
    'drag:move',
    'drag:start',
    'focusin',
    'focusout',
    'input',
    'intersect',
    'keydown',
    'keyup',
    'mousedown',
    'mouseenter',
    'mouseleave',
    'mouseup',
    'neonavigate',
    'scroll',
    'selectionchange',
    'touchmove',
    'wheel'
];

/**
 * The DomEvent Manager is responsible for distributing DOM events to the matching components.
 * It supports event delegation and "Logical Component Bubbling", allowing events to bubble up
 * the logical component hierarchy (e.g. `component.parent`) even if the DOM hierarchy is
 * disconnected (e.g. Portals, DragProxies, Multi-Window setups).
 *
 * @class Neo.manager.DomEvent
 * @extends Neo.core.Base
 * @singleton
 */
class DomEvent extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.DomEvent'
         * @protected
         */
        className: 'Neo.manager.DomEvent',
        /**
         * @member {Object} items={}
         * @protected
         */
        items: {},
        /**
         * @member {Object} map={}
         * @protected
         */
        map: {},
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * @member {Object} mountTimeouts={}
     * @private
     */
    mountTimeouts = {}

    /**
     * Registers a native ResizeObserver for a specific component listener.
     *
     * **Architectural Note on Delegation:**
     * Unlike standard DOM events (click, mouseenter) which support full CSS-selector delegation
     * (e.g., `delegate: '.my-class'`), `resize` event delegation is strictly limited to exact Node IDs
     * (e.g., `delegate: '#my-id'`).
     *
     * **The Intent:**
     * A native `ResizeObserver` must be attached to a specific, existing physical DOM node. If we allowed
     * CSS selectors, the manager would have to recursively scan the DOM on every mutation to find new
     * matching nodes and dynamically attach/detach observers. For highly permutable DOM structures
     * (like virtualized grids or dynamic lists), this continuous polling and observer thrashing
     * would destroy performance. Therefore, observing dynamic children requires manual iteration
     * and explicit ID registration by the parent component.
     *
     * @param {Neo.component.Base} component
     * @param {Object} event
     */
    async addResizeObserver(component, event) {
        let {windowId}     = component,
            targetId       = component.id,
            ResizeObserver = await Neo.currentWorker.getAddon('ResizeObserver', windowId);

        // ResizeObservers need to get registered to a specific target id
        if (event.delegate?.startsWith('#')) {
            targetId = event.delegate.substring(1)
        }

        ResizeObserver.register({componentId: component.id, id: targetId, windowId})
    }

    /**
     * Iterates the event path to find matching listeners on components.
     * It utilizes `ComponentManager.getParentPath()` to construct a logical component path,
     * ensuring events bubble to logical ancestors (like a Dashboard owning a DragProxy)
     * even if they are not physical ancestors in the DOM.
     *
     * @param {Object} event
     * @protected
     */
    fire(event) {
        let me          = this,
            bubble      = true,
            data        = event.data || {},
            {eventName} = event;

        // Bypass standard bubbling for explicitly mapped resize events from the Main Thread registry
        if (eventName === 'resize' && Array.isArray(data.componentIds)) {
            data.componentIds.forEach(cmpId => {
                let component = Neo.getComponent(cmpId),
                    listeners = me.items[cmpId]?.[eventName];

                if (component && listeners) {
                    listeners.forEach(listener => {
                        let eventData = Neo.clone(data, true, true);
                        eventData.component = component;
                        eventData.currentTarget = data.id;

                        if (Neo.isString(listener.fn)) {
                            me.bindCallback(listener.fn, 'fn', listener.scope, listener)
                        }
                        listener.fn.apply(listener.scope || globalThis, [eventData]);
                    });
                }
            });
            return
        }

        let i           = 0,
            listeners   = null,
            pathIds     = data.path ? data.path.map(e => e.id) : [],
            path        = _Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getParentPath(pathIds),
            len         = path.length,
            component, delegationTargetId, id, preventFire;

        for (; i < len; i++) {
            id        = path[i];
            component = Neo.getComponent(id);

            if (!component || (eventName !== 'resize' && component.disabled)) {
                break
            }

            if (eventName === 'scroll') {
                if (component.saveScrollPosition && typeof component.onScrollCapture === 'function') {
                    component.onScrollCapture(data)
                }
            }

            listeners = me.items[id]?.[eventName];

            if (listeners) {
                if (Array.isArray(listeners)) {
                    // Stop iteration if a handler returns false
                    listeners.every(listener => {
                        let result;

                        if (listener && listener.fn) {
                            delegationTargetId = me.verifyDelegationPath(listener, data.path, path);

                            if (delegationTargetId !== false) {
                                preventFire = false;

                                // we only want mouseenter & leave to fire on their top level nodes, not for children
                                if (eventName === 'mouseenter' || eventName === 'mouseleave') {
                                    preventFire = !DomEvent.verifyMouseEnterLeave(component, data, delegationTargetId, eventName)
                                }

                                if (!preventFire) {
                                    // multiple listeners would change the reference of data.component
                                    data = Neo.clone(data, true, true);

                                    data.component = component;

                                    // Handler needs to know which actual target matched the delegate
                                    data.currentTarget = delegationTargetId;

                                    if (Neo.isString(listener.fn)) {
                                        me.bindCallback(listener.fn, 'fn', listener.scope, listener)
                                    }

                                    result = listener.fn.apply(listener.scope || globalThis, [data]);

                                    if (!listener.bubble) {
                                        bubble = false
                                    }
                                }
                            }
                        }
                        // If a listener returns false, we stop iterating the listeners
                        return result !== false
                    })
                }
            }

            // we do want to trigger the FocusManager after normal domListeners on these events got executed
            if (eventName === 'focusin' || eventName === 'focusout') {
                _Focus_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]['on' + Neo.capitalize(eventName)]({
                    componentPath: path,
                    data
                });

                break
            }

            // Honor the Event cancelBubble property
            if (!bubble || data.cancelBubble) {
                break
            }
        }

        if (eventName === 'contextmenu' && data.ctrlKey) {
            Neo.util?.Logger?.onContextMenu(data)
        } else if (eventName.startsWith('drag:') || eventName.startsWith('drop')) {
            let dragZone = data.dragZoneId && Neo.get(data.dragZoneId);

            if (dragZone) {
                // drag:move & drag:end
                if (eventName.startsWith('drag:')) {
                    dragZone[eventName === 'drag:move' ? 'onDragMove' : 'onDragEnd']?.(data)
                } else {
                    dragZone.fire(eventName, data);
                    dragZone[{
                        'drop'      : 'onDrop',
                        'drop:enter': 'onDropEnter',
                        'drop:leave': 'onDropLeave',
                    }[eventName]].call(dragZone, data)
                }
            }
        }
    }

    /**
     * @param config
     * @param scope
     * @returns {Object}
     */
    generateListenerConfig(config, scope) {
        return {
            bubble   : config.bubble,
            delegate : config.delegate,
            eventName: config.eventName,
            id       : scope.id,
            opts     : config,
            priority : config.priority,
            scope    : config.scope   || scope,
            vnodeId  : config.vnodeId || scope.vdom.id
        };
    }

    getEventName(config) {
        let eventName = null;

        if (Neo.isObject(config)) {
            Object.keys(config).forEach(key => {
                if (!eventConfigKeys.includes(key)) {
                    eventName = key
                }
            })
        }

        return eventName
    }

    /**
     * @param {Object} config
     * @param {Boolean} config.bubble
     * @param {String} config.delegate
     * @param {String} config.eventName
     * @param {String} config.id
     * @param {Object} config.opts
     * @param {Object} config.scope
     * @param {String} config.vnodeId
     * @returns {Object}
     */
    getListener(config) {
        let listeners = this.items,
            event;

        if (listeners?.[config.id]) {
            event = listeners[config.id][config.eventName];

            return event || null
        }
    }

    /**
     * Mounts local domEvent listeners for a given component
     * @param {Neo.component.Base} component
     * @protected
     */
    mountDomListeners(component) {
        let me          = this,
            listeners   = me.items[component.id],
            localEvents = [];

        if (listeners) {
            Object.entries(listeners).forEach(([eventName, value]) => {
                value.forEach(event => {
                    eventName = event.eventName;

                    if (eventName === 'resize') {
                        me.addResizeObserver(component, event)
                    } else if (eventName && !event.mounted && (event.local || !globalDomEvents.includes(eventName))) {
                        event.mounted = true;

                        let options = {};

                        if (event.opts) {
                            if (Object.hasOwn(event.opts, 'capture')) {
                                options.capture = event.opts.capture
                            }
                            if (Object.hasOwn(event.opts, 'once')) {
                                options.once = event.opts.once
                            }
                            if (Object.hasOwn(event.opts, 'passive')) {
                                options.passive = event.opts.passive
                            }
                        }

                        localEvents.push({
                            name   : eventName,
                            handler: handlerMap[eventName] || 'domEventListener',
                            options,
                            vnodeId: event.vnodeId
                        })
                    }
                })
            });

            if (localEvents.length > 0) {
                Neo.worker.App.promiseMessage(component.windowId, {
                    action : 'addDomListener',
                    appName: component.appName,
                    events : localEvents
                }).then(data => {
                    // console.log('added domListener', data);
                }).catch(err => {
                    console.log('App: Got error attempting to add a domListener', err)
                })
            }
        }
    }

    /**
     * @param {Object}  config
     * @param {Boolean} config.bubble
     * @param {String}  config.delegate
     * @param {String}  config.eventName
     * @param {String}  config.id
     * @param {Boolean} config.local
     * @param {Number}  config.opts
     * @param {Number}  config.originalConfig
     * @param {String}  config.ownerId
     * @param {Number}  config.priority=1
     * @param {Object}  config.scope
     * @param {String}  config.vnodeId
     * @returns {Boolean} true if the listener got registered successfully (false in case it was already there)
     */
    register(config) {
        let me                           = this,
            alreadyRegistered            = false,
            {eventName, id, opts, scope} = config,
            listeners                    = me.items,
            fnType                       = typeof opts,
            fn, listener, listenerConfig, listenerId;

        // Ensure we register the listener under the component ID, even if it is a wrapper node
        if (config.ownerId) {
            id = config.ownerId
        }

        if (fnType === 'function' || fnType === 'string') {
            fn = opts
        } else {
            fn    = opts.fn;
            scope = opts.scope || scope
        }

        if (!listeners[id]) {
            listeners[id] = {}
        }

        if (listeners[id][eventName]) {
            listener = listeners[id][eventName];

            Object.keys(listener).forEach(key => {
                if (
                    listener[key].fn.toString() === fn.toString() && // todo: add a better check
                    listener[key].scope         === scope &&
                    listener[key].delegate      === config.delegate
                ) {
                    alreadyRegistered = true
                }
            })
        } else {
            listeners[id][eventName] = []
        }

        if (alreadyRegistered === true) {
            return false
        }

        listenerId = Neo.getId('dom-event');

        config.listenerId = listenerId;

        let local = config.local || (Neo.isObject(opts) && opts.local) || false;

        listenerConfig = {
            bubble        : config.hasOwnProperty('bubble') ? config.bubble : opts.hasOwnProperty('bubble') ? opts.bubble : true,
            delegate      : config.delegate,
            eventName,
            fn,
            id            : listenerId,
            local,
            mounted       : !local && globalDomEvents.includes(eventName),
            originalConfig: config.originalConfig,
            ownerId       : config.ownerId,
            priority      : config.priority || opts.priority || 1,
            scope,
            vnodeId       : config.vnodeId
        };

        me.map[listenerId] = listenerConfig;

        listeners[id][eventName].push(listenerConfig);

        listeners[id][eventName].sort((a, b) => b.priority - a.priority);

        return true
    }

    /**
     * Resets the mounted flag for local domEvent listeners
     * @param {Neo.component.Base} component
     * @protected
     */
    resetMountedDomListeners(component) {
        let me        = this,
            listeners = me.items[component.id];

        if (listeners) {
            Object.entries(listeners).forEach(([eventName, value]) => {
                value.forEach(event => {
                    eventName = event.eventName;

                    if (eventName !== 'resize' && eventName && (event.local || !globalDomEvents.includes(eventName))) {
                        event.mounted = false
                    }
                })
            })
        }
    }

    /**
     * @param {Object} config
     * @param {Boolean} config.bubble
     * @param {String} config.eventName
     * @param {String} config.id
     * @param {Object} config.opts
     * @param {Object} config.scope
     * @param {String} config.vnodeId
     * @param {Object} scope
     * @returns {Boolean} true in case the listener did exist and got removed
     */
    unregister(config, scope) {
        // todo
        console.log('unregister', config);
        console.log(this.generateListenerConfig(config, scope));
        return;

        // removed by dead control flow


        // removed by dead control flow

    }

    /**
     * @param {Neo.component.Base} component
     * @param {Object[]} domListeners
     * @param {Object[]} oldDomListeners
     */
    updateDomListeners(component, domListeners, oldDomListeners) {
        let me                  = this,
            registeredListeners = me.items[component.id] || {},
            i, len, listeners;

        if (Array.isArray(domListeners)) {
            if (Array.isArray(oldDomListeners)) {
                oldDomListeners.forEach(oldDomListener => {
                    // find & remove no longer existing listeners
                    if (!domListeners.includes(oldDomListener)) {
                        listeners = registeredListeners[me.getEventName(oldDomListener)] || [];
                        i         = 0;
                        len       = listeners.length;

                        for (; i < len; i++) {
                            if (listeners[i].originalConfig === oldDomListener) {
                                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].remove(listeners, listeners[i]);
                                break
                            }
                        }
                    }
                })
            }

            // add new listeners
            domListeners.forEach(domListener => {
                Object.entries(domListener).forEach(([key, value]) => {
                    if (!eventConfigKeys.includes(key)) {
                        me.register({
                            bubble        : domListener.bubble   || value.bubble,
                            delegate      : domListener.delegate || value.delegate || '#' + (component.vdom.id || component.id),
                            eventName     : key,
                            id            : component.vdom.id || component.id, // honor wrapper nodes
                            opts          : value,
                            originalConfig: domListener,
                            ownerId       : component.id,
                            priority      : domListener.priority || value.priority || 1,
                            scope         : domListener.scope    || component,
                            vnodeId       : domListener.vnodeId  || value.vnodeId  || component.vdom.id
                        })
                    }
                })
            });

            if (component.mounted && domListeners?.length > 0) {
                if (me.mountTimeouts[component.id]) {
                    clearTimeout(me.mountTimeouts[component.id])
                }

                me.mountTimeouts[component.id] = setTimeout(() => {
                    me.mountDomListeners(component);
                    delete me.mountTimeouts[component.id]
                }, 50)
            }
        } else {
            _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].logError('Component.domListeners have to be an array', component)
        }
    }

    /**
     * Verifies if the event target (or a delegate matching node) is a descendant of the listener's component.
     * This check supports two modes:
     * 1. **DOM Ancestry (Standard):** Checks if the target is physically inside the listener's DOM node.
     * 2. **Logical Ancestry (Fallback):** If the DOM check fails, it checks the `componentPath` to see if the
     *    target belongs to a component that is logically a descendant of the listener component.
     *    This is crucial for handling events from detached components (Portals/Proxies).
     *
     * @param {Object} listener
     * @param {Array} path            The raw DOM path from the event
     * @param {Array} [componentPath] The logical component ID path
     * @returns {Boolean|String} true/targetId in case the delegation string matches the event path
     */
    verifyDelegationPath(listener, path, componentPath) {
        let {delegate} = listener,
            j          = 0,
            pathLen    = path.length,
            targetId;

        if (typeof delegate === 'function') {
            j = delegate(path);

            if (j != null) {
                targetId = path[j].id
            }
        } else {
            let delegationArray = delegate.split(' '),
                len             = delegationArray.length,
                hasMatch, i, item, isId;

            for (i=len-1; i >= 0; i--) {
                hasMatch = false;
                item     = delegationArray[i];
                isId     = item.startsWith('#');

                if (isId || item.startsWith('.')) {
                    item = item.substring(1)
                }

                for (; j < pathLen; j++) {
                    if (
                        (isId && path[j].id === item) ||
                        path[j].cls.includes(item)
                    ) {
                        hasMatch = true;
                        targetId = path[j].id;
                        break
                    }
                }

                if (!hasMatch) {
                    return false
                }
            }
        }

        // Phase 1: Physical Boundary Check (The Fast Path)
        // Ensure the delegation path is a child of the owner component's root node in the physical DOM.
        // This covers standard inline components and is O(N).
        for (let k = j; k < pathLen; k++) {
            if (path[k].id === listener.vnodeId) {
                return targetId
            }
        }

        // Phase 2: Physical Anchor Verification (The Logical Fallback)
        // If the physical check fails (listener not in path), we check the logical `componentPath`.
        // The `componentPath` starts with the "Anchor Component" - the first component found in the physical path.
        // We must verify that our `targetId` is physically inside this Anchor Component.
        // If it is, and the Anchor is logically below the Listener (guaranteed if we are here), then the delegation is valid.
        //
        // This handles:
        // - Portals: Anchor is the Portal Child. Target is inside Portal Child. Anchor -> Parent (Listener). Valid.
        // - Menus: Anchor is SubMenu. Target is inside SubMenu. Anchor -> Menu (Listener). Valid.
        // - Multi-Window: Anchor is ViewB. Target is inside ViewB. Anchor -> ViewA (Listener). Valid.
        if (componentPath?.length > 0) {
            let anchorId = componentPath[0];

            // Verify target is physically inside the Anchor
            for (let k = j; k < pathLen; k++) {
                if (path[k].id === anchorId) {
                    return targetId
                }
            }
        }

        return false
    }

    /**
     * @param {Neo.component.Base} component
     * @param {Object} data
     * @param {String} delegationTargetId
     * @param {String} eventName
     * @returns {Boolean}
     */
    static verifyMouseEnterLeave(component, data, delegationTargetId, eventName) {
        let targetId = eventName === 'mouseenter' ? data.fromElementId : data.toElementId,
            delegationVdom;

        if (targetId && targetId !== delegationTargetId) {
            delegationVdom = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].find(component.vdom, delegationTargetId);

            // delegationVdom can be undefined when dragging a proxy over the node.
            // see issues/1137 for details.
            if (!delegationVdom || delegationVdom.vdom && _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].find(delegationVdom.vdom, targetId)) {
                return false
            }
        }

        return true
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DomEvent));


/***/ },

/***/ "./src/manager/Focus.mjs"
/*!*******************************!*\
  !*** ./src/manager/Focus.mjs ***!
  \*******************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @class Neo.manager.Focus
 * @extends Neo.core.Base
 * @singleton
 */
class Focus extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.Focus'
         * @protected
         */
        className: 'Neo.manager.Focus',
        /**
         * An array containing opts objects.
         * opts.componentPath
         * opts.data
         * @member {Object[]} history=[]
         */
        history: [],
        /**
         * The Date object when the last focusin event has occurred
         * @member {Date|null} lastFocusInDate=null
         * @protected
         */
        lastFocusInDate: null,
        /**
         * The Date object when the last focusout event has occurred
         * @member {Date|null} lastFocusInDate=null
         * @protected
         */
        lastFocusOutDate: null,
        /**
         * The amount of time for a focusIn to occur after the last focusOut
         * to get combined into a focusmove event.
         * @member {Number} maxFocusInOutGap=50
         */
        maxFocusInOutGap: 50,
        /**
         * The maximum amount of items stored inside the history array
         * @member {Number} maxHistoryLength=20
         */
        maxHistoryLength: 20,
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * @param {Object} opts
     * @param {Array}  opts.componentPath Component ids upwards
     * @param {Object} opts.data dom event infos
     * @protected
     */
    addToHistory(opts) {
        let history = this.history;

        history.unshift(opts);
        history.length >= this.maxHistoryLength && history.pop()
    }

    /**
     * @param {Object} opts
     * @param {Array}  opts.componentPath Component ids upwards
     * @param {Object} opts.data dom event infos
     * @protected
     */
    focusEnter(opts) {
        this.setComponentFocus(opts, true);
        this.addToHistory(opts)
    }

    /**
     * @param {Object} opts
     * @param {Array}  opts.componentPath Component ids upwards
     * @param {Object} opts.data dom event infos
     * @protected
     */
    focusLeave(opts) {
        this.setComponentFocus(opts, false)
    }

    /**
     * @param {Object} opts
     * @param {Array}  opts.componentPath Component ids upwards
     * @param {Object} opts.data dom event infos
     * @protected
     */
    focusMove(opts) {
        let me               = this,
            {history}        = me,
            newComponentPath = opts.componentPath,
            oldComponentPath = history[0].componentPath,
            focusEnter       = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].difference(newComponentPath, oldComponentPath),
            focusLeave       = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].difference(oldComponentPath, newComponentPath),
            focusMove        = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].intersection(newComponentPath, oldComponentPath),
            component, data;

        me.setComponentFocus({componentPath: focusLeave, data: opts.data}, false);
        me.setComponentFocus({componentPath: focusEnter, data: opts.data}, true);

        focusMove.forEach(id => {
            component = Neo.getComponent(id);

            if (component) {
                data = {
                    component,
                    path   : opts.data.path,
                    oldPath: history[0].data.path
                };

                component.onFocusMove?.(data);
                component.fire('focusMove', data);

                component.onFocusChange?.(data);
                component.fire('focusChange', data)
            }
        });

        me.addToHistory(opts)
    }

    /**
     * @param {Object} opts
     * @param {Array}  opts.componentPath Component ids upwards
     * @param {Object} opts.data dom event infos
     * @protected
     */
    onFocusin(opts) {
        let me = this;

        me.lastFocusInDate = new Date();

        if (me.lastFocusOutDate && me.lastFocusInDate - me.lastFocusOutDate < me.maxFocusInOutGap) {
            me.focusMove(opts)
        } else {
            me.focusEnter(opts)
        }
    }

    /**
     * @param {Object} opts
     * @param {Array}  opts.componentPath Component ids upwards
     * @param {Object} opts.data dom event infos
     * @protected
     */
    onFocusout(opts) {
        let me = this;

        me.lastFocusOutDate = new Date();

        me.timeout(me.maxFocusInOutGap).then(() => {
            if (me.lastFocusOutDate > me.lastFocusInDate) {
                me.focusLeave(opts)
            }
        })
    }

    /**
     * @param {Object} opts
     * @param {Array}  opts.componentPath Component ids upwards
     * @param {Object} opts.data dom event infos
     * @param {Boolean} containsFocus
     * @protected
     */
    setComponentFocus(opts, containsFocus) {
        let data = {
                relatedTarget: opts.data.relatedTarget
            },
            components = opts.componentPath.map(id => Neo.getComponent(id)),
            handler;

        components.forEach(component => {
            if (component) {
                component.containsFocus = containsFocus
            }
        });

        components.forEach(component => {
            if (component) {
                data.component = component;

                data[containsFocus ? 'path' : 'oldPath'] = opts.data.path

                handler = containsFocus ? 'onFocusEnter' : 'onFocusLeave';
                component[handler]?.(data);

                component.fire(containsFocus ? 'focusEnter' : 'focusLeave', data);

                component.onFocusChange?.(data);
                component.fire('focusChange', data)
            }
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Focus));


/***/ },

/***/ "./src/manager/VDomUpdate.mjs"
/*!************************************!*\
  !*** ./src/manager/VDomUpdate.mjs ***!
  \************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../collection/Base.mjs */ "./src/collection/Base.mjs");


/**
 * The VDomUpdate manager is a singleton responsible for orchestrating and optimizing
 * component VDOM updates within the Neo.mjs framework. It acts as a central coordinator
 * to optimize the VDOM update process. Its primary goal is to reduce the amount of
 * message roundtrips between the application and VDOM workers by aggregating multiple
 * component updates into a single, optimized VDOM tree.
 *
 * Key Responsibilities:
 * 1. **Update Merging & Aggregation:** Allows a parent component to absorb the update
 *    requests of its children. Instead of each child triggering a separate VDOM update
 *    message to the VDOM worker, the parent sends a single, aggregated VDOM tree. This
 *    significantly reduces the overhead of worker communication and can result in smaller,
 *    more focused data for the VDOM worker to process. While the amount of final DOM
 *    modifications remains the same, this aggregation is key to performance.
 *
 *    **Teleportation (Disjoint Updates):** The manager now supports processing multiple
 *    disjoint components in a single "Teleportation" batch. This allows deep descendants
 *    to update in parallel with their ancestors without requiring the ancestor to "bridge"
 *    the gap, eliminating O(N) overhead for deep updates.
 *
 * 2. **Asynchronous Flow Control:** Manages the asynchronous nature of VDOM updates, which
 *    are often processed in a worker thread. It ensures that code awaiting an update
 *    (e.g., via a returned Promise) is correctly notified upon completion.
 *
 * 3. **Dependency Chaining:** Provides a "post-update" queue, allowing one component's
 *    update to be declaratively chained to another's, ensuring a predictable order of
 *    operations.
 *
 * 4. **State Tracking:** Keeps track of updates that are "in-flight" (i.e., currently
 *    being processed), which helps to avoid race conditions and redundant work.
 *
 * By centralizing these concerns, VDomUpdate plays a critical role in the framework's
 * performance and rendering efficiency.
 *
 * @class Neo.manager.VDomUpdate
 * @extends Neo.collection.Base
 * @singleton
 */
class VDomUpdate extends _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.VDomUpdate'
         * @protected
         */
        className: 'Neo.manager.VDomUpdate',
        /**
         * A collection that maps a parent component's ID (`ownerId`) to the set of child
         * components whose VDOM updates have been merged into that parent's update cycle.
         *
         * The structure for each entry is:
         * `{ ownerId: 'parent-id', children: Map<'child-id', {childUpdateDepth, distance}> }`
         *
         * - `ownerId`: The `id` of the parent component taking responsibility for the update.
         * - `children`: A Map where keys are the `id`s of the merged children and values
         *   are objects containing metadata needed to calculate the total update scope.
         *
         * @member {Neo.collection.Base|null} mergedCallbackMap=null
         * @protected
         */
        mergedCallbackMap: null,
        /**
         * A collection that queues components that need to be updated immediately after
         * another component's update cycle completes. This is used to handle rendering
         * dependencies.
         *
         * The structure for each entry is:
         * `{ ownerId: 'component-id', children: [{childId, resolve}] }`
         *
         * - `ownerId`: The `id` of the component whose update completion will trigger the queued updates.
         * - `children`: An array of objects, where `childId` is the component to update and
         *   `resolve` is the Promise resolver to call after that subsequent update is done.
         *
         * @member {Neo.collection.Base|null} postUpdateQueueMap=null
         * @protected
         */
        postUpdateQueueMap: null,
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * A Map that tracks the in-flight update status of descendants for each component.
     * This "Reverse Lookup" map allows ancestor components to check if any of their
     * descendants are currently updating in O(1) time, without walking the tree downwards.
     *
     * Key: ancestorId, Value: Map<descendantId, true>
     *
     * This is crucial for the `VdomLifecycle.isChildUpdating` guard, which prevents
     * race conditions where a parent update might clobber a concurrent child update.
     *
     * @member {Map<String, Map<String, Boolean>>} descendantInFlightMap=new Map()
     * @protected
     */
    descendantInFlightMap = new Map()
    /**
     * A Map that tracks VDOM updates that have been dispatched to the VDOM worker but
     * have not yet completed. This prevents redundant updates for the same component.
     *
     * The structure is: `Map<'component-id', updateDepth>`
     *
     * @member {Map|null} inFlightUpdateMap=null
     * @protected
     */
    inFlightUpdateMap = null;
    /**
     * A Map that stores callbacks to be executed immediately after a component's VDOM update
     * finishes, but BEFORE the `needsVdomUpdate` check for the next cycle.
     *
     * Key: componentId, Value: callback Function
     *
     * @member {Map<String, Function>} preUpdateMap=new Map()
     * @protected
     */
    preUpdateMap = new Map()
    /**
     * A Map that stores Promise `resolve` functions associated with a component's update.
     * When a component's VDOM update is finalized, the callbacks for its ID are executed,
     * resolving the Promise returned by the component's `update()` method.
     *
     * The structure is: `Map<'component-id', [callback1, callback2, ...]>`
     *
     * @member {Map|null} promiseCallbackMap=null
     * @protected
     */
    promiseCallbackMap = null;

    /**
     * Initializes the manager's internal collections and maps.
     * This is called automatically when the singleton instance is created.
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        const me = this;

        me.inFlightUpdateMap  = new Map();
        me.mergedCallbackMap  = Neo.create(_collection_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"], {keyProperty: 'ownerId'});
        me.postUpdateQueueMap = Neo.create(_collection_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"], {keyProperty: 'ownerId'});
        me.promiseCallbackMap = new Map();
    }

    /**
     * Registers a callback function to be executed when a specific component's
     * VDOM update completes. This is the mechanism that resolves the Promise
     * returned by `Component#update()`.
     * @param {String}   ownerId  The `id` of the component owning the update.
     * @param {Function} callback The function to execute upon completion.
     */
    addPromiseCallback(ownerId, callback) {
        let me = this;

        if (!me.promiseCallbackMap.has(ownerId)) {
            me.promiseCallbackMap.set(ownerId, [])
        }

        me.promiseCallbackMap.get(ownerId).push(callback)
    }

    /**
     * Executes all callbacks associated with a completed VDOM update for a given `ownerId`.
     * This method first processes callbacks for any children that were merged into this
     * update cycle, then executes the callbacks for the `ownerId` itself.
     *
     * **Teleportation / Batch Support:**
     * The `processedChildIds` argument is crucial for Disjoint Updates. It ensures we only
     * execute callbacks for children that were *actually* included in the VDOM payload.
     * Children that were filtered out (e.g. due to collisions with a parent update) will
     * NOT have their callbacks executed here; they will be handled by the covering parent's callback.
     *
     * @param {String} ownerId The `id` of the component whose update has just completed.
     * @param {Object} [data]  Optional data to pass to the callbacks.
     * @param {Set<String>|null} [processedChildIds] IDs of children actually included in this update.
     */
    executeCallbacks(ownerId, data, processedChildIds) {
        let me           = this,
            item         = me.mergedCallbackMap.get(ownerId),
            callbackData = data ? [data] : [];

        if (item && processedChildIds) {
            for (const childId of processedChildIds) {
                if (item.children.has(childId)) {
                    me.executePromiseCallbacks(childId, ...callbackData);
                    item.children.delete(childId)
                }
            }

            if (item.children.size === 0) {
                me.mergedCallbackMap.remove(ownerId)
            }
        }

        me.executePromiseCallbacks(ownerId, ...callbackData)
    }

    /**
     * Retrieves and executes the registered Pre-Update callback for a component.
     * This is called by VdomLifecycle just before checking `needsVdomUpdate`.
     * @param {String} id The component ID.
     */
    executePreUpdates(id) {
        let callback = this.preUpdateMap.get(id);

        if (callback) {
            this.preUpdateMap.delete(id);
            callback()
        }
    }

    /**
     * A helper method that invokes all registered promise callbacks for a given
     * component ID and then clears them from the queue.
     * @param {String} ownerId The `id` of the component.
     * @param {Object} [data]  Optional data to pass to the callbacks.
     */
    executePromiseCallbacks(ownerId, data) {
        let me        = this,
            callbacks = me.promiseCallbackMap.get(ownerId);

        if (callbacks) {
            for (let i = 0, len = callbacks.length; i < len; i++) {
                callbacks[i](data)
            }
            me.promiseCallbackMap.delete(ownerId);
        }
    }

    /**
     * Calculates the required `updateDepth` for a parent component based on its own
     * needs and the needs of all child components whose updates have been merged into it.
     * The final depth is the maximum required depth to ensure all changes are rendered.
     *
     * For example, if a parent needs to update its direct content (`updateDepth: 1`) but
     * a merged child 3 levels down needs a full subtree update (`childUpdateDepth: -1`),
     * this method will return -1, signaling a full recursive update from the parent.
     *
     * This method is called by the parent component right before it dispatches its VDOM update.
     * @param {String} ownerId The `id` of the parent component.
     * @returns {Number|null} The adjusted update depth, or `null` if no merged children exist.
     */
    getAdjustedUpdateDepth(ownerId) {
        let me       = this,
            owner    = Neo.getComponent(ownerId),
            item     = me.mergedCallbackMap.get(ownerId),
            maxDepth = owner?.updateDepth ?? 1,
            newDepth;

        if (item) {
            for (const value of item.children.values()) {
                if (value.childUpdateDepth === -1) {
                    newDepth = -1
                } else {
                    // The new depth is the distance to the child plus the child's own required update depth.
                    newDepth = value.distance + value.childUpdateDepth
                }

                if (newDepth === -1) {
                    maxDepth = -1
                } else if (maxDepth !== -1) {
                    maxDepth = Math.max(maxDepth, newDepth)
                }
            }

            return maxDepth
        }

        return null
    }

    /**
     * Checks if a component has any descendants currently undergoing a VDOM update.
     * This method is used by `VdomLifecycle` to detect potential race conditions
     * before starting a parent update.
     * @param {String} ownerId The component ID to check.
     * @returns {Boolean} True if any descendant is in-flight.
     */
    hasInFlightDescendants(ownerId) {
        return this.descendantInFlightMap.has(ownerId)
    }

    /**
     * Retrieves the `updateDepth` for a component's update that is currently in-flight.
     * @param {String} ownerId The `id` of the component owning the update.
     * @returns {Number|undefined} The update depth, or `undefined` if no update is in-flight.
     */
    getInFlightUpdateDepth(ownerId) {
        return this.inFlightUpdateMap.get(ownerId)
    }

    /**
     * Returns a Set of child component IDs that have been merged into a parent's update cycle,
     * PLUS all intermediate "Bridge" components (ancestors) required to reach them.
     *
     * This set serves as an "AllowList" for TreeBuilder. When a parent updates with depth > 1,
     * TreeBuilder will use this set to perform **Sparse Tree Generation**:
     * 1. Components in this set are expanded (traversed).
     * 2. Components NOT in this set are pruned (sent as placeholders), even if the depth allows expansion.
     *
     * This optimization allows clean siblings to be skipped, reducing payload size and enabling parallelism.
     *
     * @param {String} ownerId The `id` of the parent component.
     * @returns {Set<String>|null} A Set containing IDs of merged children AND bridge ancestors, or `null`.
     */
    getMergedChildIds(ownerId) {
        const item = this.mergedCallbackMap.get(ownerId);

        if (item) {
            const ids = new Set(item.children.keys());

            // Add Bridge Paths: Walk up from each merged child to the owner
            for (const [childId, meta] of item.children) {
                if (meta.distance > 1) {
                    let component = Neo.getComponent(childId);

                    while (component && component.parentId && component.parentId !== ownerId) {
                        component = Neo.getComponent(component.parentId);
                        if (component) {
                            ids.add(component.id)
                        }
                    }
                }
            }

            return ids
        }

        return null
    }

    /**
     * Marks a component's VDOM update as "in-flight," meaning it has been sent to the
     * worker for processing.
     * @param {String} ownerId     The `id` of the component owning the update.
     * @param {Number} updateDepth The depth of the in-flight update.
     */
    registerInFlightUpdate(ownerId, updateDepth) {
        this.inFlightUpdateMap.set(ownerId, updateDepth);

        // Register this component as an in-flight descendant for all its parents
        const parentIds = Neo.manager.Component.getParentIds(Neo.getComponent(ownerId));

        for (let i = 0, len = parentIds.length; i < len; i++) {
            let parentId = parentIds[i],
                map      = this.descendantInFlightMap.get(parentId);

            if (!map) {
                map = new Map();
                this.descendantInFlightMap.set(parentId, map)
            }

            map.set(ownerId, true)
        }
    }

    /**
     * Registers a child's update request to be merged into its parent's update cycle.
     * This is called by a child component when it determines it can delegate its update
     * to an ancestor (see `VdomLifecycle.mergeIntoParentUpdate`).
     *
     * **Merging Logic:**
     * Merging reduces VDOM worker traffic by bundling multiple component updates into
     * a single message. The child effectively "cancels" its own standalone update and
     * piggybacks on the parent's pending update.
     *
     * @param {String} ownerId          The `id` of the parent component that will own the merged update.
     * @param {String} childId          The `id` of the child component requesting the merge.
     * @param {Number} childUpdateDepth The update depth required by the child.
     * @param {Number} distance         The component tree distance (number of levels) between the parent and child.
     */
    registerMerged(ownerId, childId, childUpdateDepth, distance) {
        let me   = this,
            item = me.mergedCallbackMap.get(ownerId);

        if (!item) {
            item = {ownerId, children: new Map()};
            me.mergedCallbackMap.add(item)
        }

        item.children.set(childId, {childUpdateDepth, distance})
    }

    /**
     * Queues a component update to be executed after another component's update is complete.
     * @param {String} ownerId     The `id` of the component to wait for.
     * @param {String} childId     The `id` of the component to update afterward.
     * @param {Function} [resolve] The Promise resolver to be called when the `childId`'s subsequent update finishes.
     */
    registerPostUpdate(ownerId, childId, resolve) {
        let me   = this,
            item = me.postUpdateQueueMap.get(ownerId);

        if (!item) {
            item = {ownerId, children: []};
            me.postUpdateQueueMap.add(item)
        }

        item.children.push({childId, resolve})
    }

    /**
     * Registers a callback to be executed for a component immediately after its current
     * VDOM update finishes, but before the next update cycle begins.
     * @param {String} id The component ID.
     * @param {Function} callback
     */
    registerPreUpdate(id, callback) {
        this.preUpdateMap.set(id, callback)
    }

    /**
     * Triggers all pending updates that were queued to run after the specified `ownerId`'s
     * update has completed.
     * @param {String} ownerId The `id` of the component whose update has just finished.
     */
    triggerPostUpdates(ownerId) {
        let me   = this,
            item = me.postUpdateQueueMap.get(ownerId),
            component;

        if (item) {
            for (let i = 0, len = item.children.length; i < len; i++) {
                let entry = item.children[i];
                component = Neo.getComponent(entry.childId);

                if (component) {
                    entry.resolve && me.addPromiseCallback(component.id, entry.resolve);
                    component.update()
                }
            }

            me.postUpdateQueueMap.remove(item)
        }
    }

    /**
     * Removes a component's update from the "in-flight" registry. This is called after
     * the VDOM worker confirms the update has been processed.
     * @param {String} ownerId The `id` of the component owning the update.
     */
    unregisterInFlightUpdate(ownerId) {
        this.inFlightUpdateMap.delete(ownerId);

        // Remove this component from the in-flight descendant maps of all its parents
        // We need to iterate all registered ancestors to ensure we catch cases where
        // the component moved (re-parented) during the update.
        for (const [parentId, map] of this.descendantInFlightMap) {
            if (map.has(ownerId)) {
                map.delete(ownerId);

                if (map.size === 0) {
                    this.descendantInFlightMap.delete(parentId)
                }
            }
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(VDomUpdate));


/***/ },

/***/ "./src/mixin/DomEvents.mjs"
/*!*********************************!*\
  !*** ./src/mixin/DomEvents.mjs ***!
  \*********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _manager_DomEvent_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../manager/DomEvent.mjs */ "./src/manager/DomEvent.mjs");



/**
 * A mixin providing DOM event handling capabilities to components.
 * This mixin is consumed by both Neo.component.Base and Neo.functional.component.Base
 * to enable consistent management of DOM event listeners across different component types.
 * @class Neo.mixin.DomEvents
 * @extends Neo.core.Base
 */
class DomEvents extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.mixin.DomEvents'
         * @protected
         */
        className: 'Neo.mixin.DomEvents',
        /**
         * An array of domListener configs
         * @member {Object[]|null} domListeners_=null
         * @example
         * afterSetStayOnHover(value, oldValue) {
         *     if (value) {
         *         let me = this;
         *
         *         me.addDomListeners(
         *             {mouseenter: me.onMouseEnter, scope: me},
         *             {mouseleave: me.onMouseLeave, scope: me}
         *         )
         *    }
         *}
         * @reactive
         */
        domListeners_: null
    }

    /**
     * Convenience shortcut to add additional dom listeners
     * @param {Object|Object[]} value
     */
    addDomListeners(value) {
        if (!Array.isArray(value)) {
            value = [value]
        }

        let domListeners = this.domListeners;

        domListeners.push(...value);

        this.domListeners = domListeners
    }

    /**
     * Registers the domListeners inside the Neo.manager.DomEvent
     * @param {Object[]} value
     * @param {Object[]} oldValue
     * @protected
     */
    afterSetDomListeners(value, oldValue) {
        let me = this;

        if (value?.[0] || oldValue?.[0]) {
            _manager_DomEvent_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].updateDomListeners(me, value, oldValue)
        }
    }

    /**
     * Triggered before the domListeners config gets changed.
     * @param {Object|Object[]} value
     * @param {Object[]} oldValue
     * @returns {Object[]}
     * @protected
     */
    beforeSetDomListeners(value, oldValue) {
        if (Neo.isObject(value)) {
            value = [value]
        }

        return value || []
    }

    /**
     * Initializes DOM event listeners.
     */
    initDomEvents() {
        let me = this;
        if (me.domListeners?.length > 0) {
            // todo: the main thread reply of mount arrives after pushing the task into the queue which does not ensure the dom is mounted
            me.timeout(150).then(() => {
                _manager_DomEvent_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].mountDomListeners(me)
            }).catch(err => {
                if (err !== Neo.isDestroyed) {
                    throw err
                }
            })
        }
    }

    /**
     * Resets the mounted flag for local domEvent listeners
     */
    resetMountedDomEvents() {
        _manager_DomEvent_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].resetMountedDomListeners(this)
    }

    /**
     * Destroys DOM event listeners.
     */
    removeDomEvents() {
        this.domListeners = []
    }

    /**
     * @param {Array|Object} value
     */
    removeDomListeners(value) {
        if (!Array.isArray(value)) {
            value = [value];
        }

        let me             = this,
            {domListeners} = me,
            i, len;

        value.forEach(item => {
            i = 0;
            len = domListeners.length;

            for (; i < len; i++) {
                if (Neo.isEqual(item, domListeners[i])) {
                    domListeners.splice(i, 1);
                    break
                }
            }
        });

        me.domListeners = domListeners
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DomEvents));


/***/ },

/***/ "./src/mixin/VdomLifecycle.mjs"
/*!*************************************!*\
  !*** ./src/mixin/VdomLifecycle.mjs ***!
  \*************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../manager/Component.mjs */ "./src/manager/Component.mjs");
/* harmony import */ var _util_vdom_TreeBuilder_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/vdom/TreeBuilder.mjs */ "./src/util/vdom/TreeBuilder.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/VDom.mjs */ "./src/util/VDom.mjs");
/* harmony import */ var _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../manager/VDomUpdate.mjs */ "./src/manager/VDomUpdate.mjs");
/* harmony import */ var _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/VNode.mjs */ "./src/util/VNode.mjs");
/* harmony import */ var _core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");








const {currentWorker} = Neo;

/**
 * @class Neo.mixin.VdomLifecycle
 * @extends Neo.core.Base
 */
class VdomLifecycle extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.mixin.VdomLifecycle'
         * @protected
         */
        className: 'Neo.mixin.VdomLifecycle',
        /**
         * True automatically initializes the vnode of a component after being created inside the init call.
         * Recommended for dialogs & drag-proxies.
         * Top level views should definitely use false.
         * @member {Boolean} autoInitVnode=false
         */
        autoInitVnode: false,
        /**
         * True automatically mounts a component after being rendered.
         * Use this for the top level component of your app.
         * @member {Boolean} autoMount=false
         */
        autoMount: false,
        /**
         * Internal flag which will get set to true while an update request (worker messages) is in progress
         * @member {Boolean} isVdomUpdating_=false
         * @protected
         * @reactive
         */
        isVdomUpdating_: false,
        /**
         * True in case the component is initializing the vnode
         * @member {Boolean} isVnodeInitializing_=false
         * @protected
         * @reactive
         */
        isVnodeInitializing_: false,
        /**
         * True in case the component is mounted to the DOM
         * @member {Boolean} mounted_=false
         * @protected
         * @reactive
         */
        mounted_: false,
        /**
         * Internal flag which will get set to true in case an update call arrives while another update is running
         * @member {Boolean} needsVdomUpdate_=false
         * @protected
         * @reactive
         */
        needsVdomUpdate_: false,
        /**
         * Set this to true for bulk updates. Ensure to set it back to false afterwards.
         * Internally the value will get saved as a number to ensure that child methods won't stop the silent mode too early.
         * @member {Boolean} silentVdomUpdate_=false
         * @reactive
         */
        silentVdomUpdate_: false,
        /**
         * Defines the depth of the vdom tree for the next update cycle.
         * - The value 1 will only send the current vdom structure as it is
         * - The value of 2 will include the vdom of direct children
         * - The value of 3 will include the vdom of grandchildren
         * - The value of -1 will include the full tree of any depth
         * @member {Number} updateDepth_=1
         * @reactive
         */
        updateDepth_: 1,
        /**
         * The component vnode tree. Available after the component got vnodeInitialized.
         * @member {Object} vnode_=={[isDescriptor]: true, value: null, isEqual: (a, b) => a === b,}
         * @protected
         * @reactive
         */
        vnode_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_6__.isDescriptor]: true,
            clone         : 'none',
            cloneOnGet    : 'none',
            isEqual       : (a, b) => a === b, // vnode trees can be huge, and will get compared by the vdom worker.
            value         : null,
        },
        /**
         * True after the component initVnode() method was called. Also fires the vnodeInitialized event.
         * @member {Boolean} vnodeInitialized_=false
         * @protected
         * @reactive
         */
        vnodeInitialized_: false
    }

    /**
     * Triggered after the vdom pseudo-config got changed
     * @param {Object} value
     * @param {Object|null} oldValue
     * @protected
     */
    afterSetVdom(value, oldValue) {
        this.updateVdom()
    }

    /**
     * Triggered after the vnode config got changed
     * @param {Object} value
     * @param {Object|null} oldValue
     * @protected
     */
    afterSetVnode(value, oldValue) {
        value && this.syncVnodeTree()
    }

    /**
     * Triggered after the vnodeInitialized config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetVnodeInitialized(value, oldValue) {
        let me = this;

        if (value) {
            me.fire('vnodeInitialized', me.id);

            if (me.needsVdomUpdate) {
                me.update()
            }
        }
    }

    /**
     * Creates a lightweight, serializable placeholder for this component, intended for injection
     * into the VDOM of other components.
     *
     * This is the **only recommended way** to nest a component within another component's VDOM tree.
     * Directly embedding one component's full `vdom` object into another's is an anti-pattern
     * that violates the principle of scoped VDOM, leading to unpredictable rendering behavior
     * and making updates inefficient.
     *
     * At its core, the returned object contains a `componentId` that uniquely identifies the
     * component instance. In cases where a component's structure is wrapped by another element
     * (e.g., a Button in a Table Header being wrapped by a `<td>`), the reference will also
     * include the wrapper's `id`. This happens when a component uses `getVdomRoot()` to
     * designate a deeper node as its logical root, causing the component's `id` and its
     * VDOM root's `id` to differ. The framework uses this dual-ID reference to correctly
     * assemble the final VDOM tree.
     *
     * @returns {{componentId: String, id: String|undefined}} The VDOM reference object.
     */
    createVdomReference() {
        let me        = this,
            reference = {componentId: me.id},
            vdomId    = me.vdom.id;

        if (vdomId && me.id !== vdomId) {
            reference.id = vdomId
        }

        return reference
    }

    /**
     * Ensures that the root VDOM node and its wrapper (if any) have stable, unique IDs
     * derived from the component instance ID. This prevents auto-generated ID collisions
     * in `ComponentManager.wrapperNodes`.
     * @protected
     */
    ensureStableIds() {
        const
            me       = this,
            vdom     = me.vdom,
            vdomRoot = me.getVdomRoot();

        if (vdomRoot) {
            vdomRoot.id = me.id;

            if (vdom !== vdomRoot) {
                vdom.id = me.id + '__wrapper'
            }
        }
    }

    /**
     * Internal method to send update requests to the vdom worker.
     *
     * **Teleportation / Batched Disjoint Updates:**
     * This method implements the core logic for "Teleportation". Instead of merging child updates
     * into the parent's VDOM tree (which requires expanding the parent's tree to reach the child),
     * we collect all merged child updates and send them as a **batch of disjoint payloads**.
     *
     * 1. **Recursive Collection:** We recursively collect all `mergedChildIds` from the component
     *    and its descendants.
     * 2. **Disjoint Payloads:** For each component in the batch, we generate a "self-only" VDOM
     *    payload (`updateDepth: 1`). This allows the VDOM engine to update the child directly
     *    without needing the parent to "bridge" to it.
     * 3. **Collision Filtering:** We filter out child updates that are already covered by a
     *    parent update in the same batch (e.g., if the parent is doing a full tree update).
     *
     * @param {function} [resolve] used by promiseUpdate()
     * @param {function} [reject] used by promiseUpdate()
     * @private
     */
    async executeVdomUpdate(resolve, reject) {
        let me = this;

        resolve && _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].addPromiseCallback(me.id, resolve);

        me.isVdomUpdating = true;
        // Centralize in-flight state
        _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].registerInFlightUpdate(me.id, me.updateDepth);

        try {
            // We need to ensure that the task queue is empty before collecting payloads.
            // This is critical for cases where a component state change (triggering update)
            // is followed immediately by a structural change (e.g. remove) in the same tick.
            // Using setTimeout forces a Macrotask yield, ensuring all sync operations complete.
            await new Promise(resolve => setTimeout(resolve, 1));

            const
                updates                 = {},
                depths                  = new Map(),
                processed               = new Set(), // Prevent duplicates and cycles
                componentMergedChildren = new Map(); // Snapshot of merged children processed in this batch

            const collectPayloads = (componentId) => {
                if (processed.has(componentId)) return;
                processed.add(componentId);

                const component = Neo.getComponent(componentId);
                if (!component || component.isDestroyed) return;

                // Skip unmounted components. They will be expanded by the Parent's TreeBuilder
                // and handled via the Parent's resolveVdomUpdate -> syncVnodeTree.
                if (!component.vnode) return;

                // IMPORTANT: In a multi-window SharedWorker environment, we must NOT batch
                // updates from components that have moved to a different window.
                // Doing so would cause deltas meant for Window B to be sent to Window A.
                if (component.windowId !== me.windowId) return;

                // For every component, we check its own merged children
                const mergedChildIds = _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].getMergedChildIds(componentId);

                // Track depth for collision filtering
                depths.set(componentId, component.updateDepth);

                // Snapshot the merged children we are about to process.
                // This prevents race conditions where a child merges *after* collection but *before* resolution,
                // causing it to be acknowledged/cleared without actually being updated.
                if (mergedChildIds) {
                    componentMergedChildren.set(componentId, mergedChildIds);
                }

                // Generate payload for this component.
                // - Depth 1 (Teleportation): Pass ids=null to force disjoint/pruned payload.
                // - Depth > 1 (Hybrid): Pass ids=mergedChildIds to enable Sparse Tree generation (pruning clean siblings).
                //   Note: Depth -1 (Full Tree) ignores ids and is always Dense.
                const ids = component.updateDepth !== 1 ? mergedChildIds : null;

                // We pass null as the second arg to respect the component's configured updateDepth.
                updates[componentId] = component.getVdomUpdatePayload(ids, null);

                // Recursively collect merged children
                if (mergedChildIds) {
                    for (const childId of mergedChildIds) {
                        collectPayloads(childId)
                    }
                }
            };

            // Start collection from the root of the update (me)
            collectPayloads(me.id);

            // Collision Filtering:
            // If a parent update covers this child, remove the child from the disjoint batch
            for (const id in updates) {
                if (Object.hasOwn(updates, id)) {
                    let parent   = Neo.getComponent(id)?.parent,
                        distance = 1;

                    while (parent) {
                        if (updates[parent.id]) {
                            const parentDepth = depths.get(parent.id);
                            // If parent covers this child, remove the child from the disjoint batch
                            if (parentDepth === -1 || parentDepth > distance) {
                                delete updates[id];
                                break; // exit the while loop
                            }
                        }
                        parent   = parent.parent;
                        distance++
                    }
                }
            }

            const batchData = {updates};

            // CRITICAL: SharedWorker Context Injection
            // This block MUST NOT be removed or simplified.
            // In a SharedWorker environment, the VDOM worker needs to know WHICH window
            // initiated the update to route the reply and DOM deltas correctly.
            // Without `windowId` and `appName`, `RemoteMethodAccess` cannot determine the target,
            // causing cross-window operations (like dragging a component to a new window) to fail silently.
            if (currentWorker?.isSharedWorker) {
                batchData.appName  = me.appName;
                batchData.windowId = me.windowId
            }

            const response = await Promise.resolve(Neo.vdom.Helper.updateBatch(batchData));

            // Component could be destroyed while the update is running
            if (me.id) {
                // When not using a VdomWorker, we need to apply the deltas inside the App worker
                if (!Neo.config.useVdomWorker && response.deltas?.length > 0) {
                    await Neo.applyDeltas(me.windowId, response.deltas)
                }

                // Distribute results back to ALL components in the batch
                for (const id in response.vnodes) {
                    if (Object.hasOwn(response.vnodes, id)) {
                        const vnode = response.vnodes[id];
                        const component = Neo.getComponent(id);

                        if (component && !component.isDestroyed) {
                            component.vnode = vnode;

                            // Resolve the update for this component and its merged children
                            // Note: response.deltas contains the aggregated deltas for the whole batch
                            component.resolveVdomUpdate({
                                deltas: response.deltas,
                                vnode
                            }, componentMergedChildren.get(id));
                        }
                    }
                }
            }
        } catch (err) {
            me.isVdomUpdating = false;
            // Ensure state is cleaned up on error
            _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].unregisterInFlightUpdate(me.id);
            reject?.(err)
        }
    }

    /**
     * Honors different item roots for mount / render OPs
     * @returns {String}
     */
    getMountedParentId() {
        let parentId  = this.parentId,
            parent    = Neo.getComponent(parentId),
            itemsRoot = parent?.getVdomItemsRoot?.();

        return itemsRoot ? itemsRoot.id : parentId
    }

    /**
     * Calculate the real parentIndex inside the DOM
     * @returns {Number|undefined}
     */
    getMountedParentIndex() {
        let parent = this.parent,
            items  = parent?.items || [],
            i      = 0,
            index  = 0,
            len    = items.length,
            item;

        for (; i < len; i++) {
            item = items[i];

            if (item === this) {
                return index
            }

            if (!item.hidden && item.hideMode === 'removeDom') {
                index++
            }
        }
    }

    /**
     * Generates the update payload for this component.
     * @param {Set<String>|null} mergedChildIds
     * @param {Number} [depth] Override the update depth
     * @returns {Object} opts
     */
    getVdomUpdatePayload(mergedChildIds, depth) {
        let me = this,
            updateDepth = depth ?? me.updateDepth,
            {vdom, vnode} = me,
            opts = {
                vdom : _util_vdom_TreeBuilder_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getVdomTree(vdom,   updateDepth, mergedChildIds),
                vnode: _util_vdom_TreeBuilder_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getVnodeTree(vnode, updateDepth, mergedChildIds)
            };

        if (currentWorker?.isSharedWorker) {
            opts.appName  = me.appName;
            opts.windowId = me.windowId
        }

        // We cannot set the config directly => it could already be false,
        // and we still want to pass it further into subtrees
        me._needsVdomUpdate = false;
        me.afterSetNeedsVdomUpdate?.(false, true);

        // Reset the updateDepth to the default value for the next update cycle
        me._updateDepth = me.constructor.config.updateDepth;

        return opts
    }

    /**
     * Search a vdom child node by id for a given vdom tree
     * @param {String} id
     * @param {Object} vdom=this.vdom
     * @returns {Object}
     */
    getVdomChild(id, vdom=this.vdom) {
        return _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].find(vdom, id)?.vdom
    }

    /**
     * Specify a different vdom root if needed to apply the top level style attributes on a different level.
     * Make sure to use getVnodeRoot() as well, to keep the vdom & vnode trees in sync.
     * @returns {Object} The new vdom root
     */
    getVdomRoot() {
        return this.vdom
    }

    /**
     * Specify a different vnode root if needed to apply the top level style attributes on a different level.
     * Make sure to use getVdomRoot() as well, to keep the vdom & vnode trees in sync.
     * @returns {Object} The new vnode root
     */
    getVnodeRoot() {
        return this.vnode
    }

    /**
     * Checks if a child update can be merged into a parent update.
     *
     * **Merge Strategy (Optimization):**
     * We allow merging regardless of distance (Teleportation).
     * The `executeVdomUpdate` logic will distinguish between Connected (merged into tree)
     * and Disjoint (batched separately) updates.
     *
     * @param {Number} updateDepth
     * @param {Number} distance
     * @returns {Boolean}
     */
    canMergeUpdate(updateDepth, distance) {
        return true
    }

    /**
     * Checks if a given updateDepth & distance would result in an update collision.
     * The check must use `<` because `updateDepth` is 1-based.
     *
     * **Scoped VDOM Update Rationale:**
     * - `updateDepth: 1` means the update is scoped to the component itself.
     * - The Parent's VDOM payload naturally contains only its own structure and **reference nodes**
     *   (placeholders) for its children (e.g. `{componentId: '...'}`).
     * - At Depth 1, these references are **not expanded** into the children's full VDOM trees.
     * - Therefore, a Parent (Depth 1) update and a Child update operate on **disjoint** sets of DOM nodes.
     * - They **do not collide** and **should not merge**. They should run as independent, parallel updates.
     *
     * - A direct child is at `distance: 1`.
     * Therefore, an update with depth 1 should NOT collide with a child at distance 1 (1 < 1 is false).
     *
     * @param {Number} updateDepth
     * @param {Number} distance
     * @returns {Boolean}
     */
    hasUpdateCollision(updateDepth, distance) {
        return updateDepth === -1 ? true : distance < updateDepth
    }

    /**
     * Creates the vnode tree for this component and mounts the component in case
     * - you pass true for the mount param
     * - or the autoMount config is set to true
     * @param {Boolean} [mount] Mount the DOM after the vnode got created
     * @returns {Promise<any>} If getting there, we return the data from vdom.Helper: create(), containing the vnode.
     */
    async initVnode(mount) {
        let me        = this,
            autoMount = mount || me.autoMount,
            {app}     = me,
            {allowVdomUpdatesInTests, unitTestMode, useVdomWorker} = Neo.config;

        if (unitTestMode && !allowVdomUpdatesInTests) return;

        // Verify that the critical rendering path => CSS files for the new tree is in place
        if (!unitTestMode && autoMount && currentWorker.countLoadingThemeFiles !== 0) {
            currentWorker.on('themeFilesLoaded', function() {
                !me.mounted && me.initVnode(mount)
            }, me, {once: true});

            return
        }

        me.isVnodeInitializing = true;

        if (!app.vnodeInitialized) {
            app.isVnodeInitializing = true
        }

        try {
            if (me.vdom) {
                me.isVdomUpdating = true;

                me.ensureStableIds();

                // Ensure child components do not trigger updates while the vnode generation is in progress
                _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].registerInFlightUpdate(me.id, -1);

                delete me.vdom.removeDom;

                me._needsVdomUpdate = false;
                me.afterSetNeedsVdomUpdate?.(false, true);

                const data = await Promise.resolve(Neo.vdom.Helper.create({
                    appName    : me.appName,
                    autoMount,
                    parentId   : autoMount ? me.getMountedParentId()    : undefined,
                    parentIndex: autoMount ? me.getMountedParentIndex() : undefined,
                    vdom       : _util_vdom_TreeBuilder_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getVdomTree(me.vdom, -1),
                    windowId   : me.windowId
                }));

                me.onInitVnode(data.vnode, useVdomWorker ? autoMount : false);

                if (autoMount && !useVdomWorker) {
                    // When running without a VdomWorker, Helper.create is local and returns a plain object.
                    // We must manually send the insertNode delta to the main thread.
                    await Neo.applyDeltas(me.windowId, [{
                        action   : 'insertNode',
                        id       : me.id,
                        index    : me.getMountedParentIndex(),
                        outerHTML: data.outerHTML,
                        parentId : me.getMountedParentId(),
                        vnode    : data.vnode
                    }]);

                    me.mounted = true
                }

                if (!data.deltas) {
                    data.deltas = []
                }

                me.resolveVdomUpdate(data);

                return data
            }
        } catch (err) {
            console.error('initVnode error', err, me.id);
            throw err
        }
    }

    /**
     * Synchronization Guard: Checks if any descendant component is currently updating its VDOM.
     *
     * If a descendant is in-flight, this method registers a post-update callback on the
     * blocking descendant and returns `true`, signaling the caller (`updateVdom`) to yield.
     * This prevents the Parent from starting an update that might overwrite or conflict
     * with the Child's concurrent work, effectively serializing the updates.
     *
     * @param {Function} [resolve] Gets passed by updateVdom() to be called after the blocking update finishes.
     * @returns {Boolean} True if a child update conflict exists (Parent should yield).
     */
    isChildUpdating(resolve) {
        let me = this;

        if (_manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].hasInFlightDescendants(me.id)) {
            let map          = _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].descendantInFlightMap.get(me.id),
                descendantId = map.keys().next().value;

            if (Neo.config.logVdomUpdateCollisions) {
                console.warn('vdom child update conflict with:', descendantId, 'for:', me)
            }

            _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].registerPostUpdate(descendantId, me.id, resolve);
            return true
        }

        return false
    }

    /**
     * Checks for vdom updates inside the parent chain and if found.
     * Registers the component for a vdom update once done.
     * @param {String} parentId=this.parentId
     * @param {Function} [resolve] Gets passed by updateVdom()
     * @param {Number} distance=1 Distance inside the component tree
     * @returns {Boolean}
     */
    isParentUpdating(parentId=this.parentId, resolve, distance=1) {
        if (parentId !== 'document.body') {
            let me     = this,
                parent = Neo.getComponent(parentId);

            if (parent) {
                if (parent.isVdomUpdating) {
                    // Get the in-flight update depth from the central manager
                    const parentUpdateDepth = _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].getInFlightUpdateDepth(parent.id);

                    if (me.hasUpdateCollision(parentUpdateDepth, distance)) {
                        if (Neo.config.logVdomUpdateCollisions) {
                            console.warn('vdom parent update conflict with:', parent, 'for:', me)
                        }

                        _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].registerPostUpdate(parent.id, me.id, resolve);
                        return true
                    }

                    // If an update is running and does not have a collision, we do not need to check further parents
                    return false
                }

                return me.isParentUpdating(parent.parentId, resolve, distance+1)
            }
        }

        return false
    }

    /**
     * Traverses the parent chain to find an ancestor that is pending a VDOM update.
     * If found, and if the update scope allows (see `canMergeUpdate`), this component's
     * update is merged into the ancestor's cycle.
     *
     * **Recursive Traversal:**
     * This method recursively walks up the component tree (`distance + 1`). This enables
     * transitive merging (Grandchild -> Child -> Parent) and merging into ancestors even
     * if intermediate parents are not updating.
     *
     * @param {String} parentId=this.parentId
     * @param {Function} [resolve] gets passed by updateVdom()
     * @param {Number} distance=1 Distance inside the component tree
     * @returns {Boolean} True if the update was successfully merged.
     */
    mergeIntoParentUpdate(parentId=this.parentId, distance=1) {
        if (parentId !== 'document.body') {
            let me     = this,
                parent = Neo.getComponent(parentId);

            if (parent) {
                // We are checking for parent.updateDepth, since we care about the depth of the next update cycle
                if (parent.needsVdomUpdate && me.canMergeUpdate(parent.updateDepth, distance)) {
                    _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].registerMerged(parent.id, me.id, me.updateDepth, distance);
                    return true
                }

                return me.mergeIntoParentUpdate(parent.parentId, distance+1)
            }
        }

        return false
    }

    /**
     * Gets called from the initVnode() promise success handler
     * @param {Object} vnode
     * @param {Boolean} autoMount Mount the DOM after the vnode got created
     * @protected
     */
    onInitVnode(vnode, autoMount) {
        let me    = this,
            {app} = me;

        me.isVnodeInitializing = false;

        // if app is a check to see if the Component got destroyed while vnodeInitialising => before onInitVnode got triggered
        if (app) {
            if (!app.vnodeInitialized) {
                app.isVnodeInitializing = false;
                app.vnodeInitialized = true;
                app.fire('vnodeInitialized')
            }

            me.vnode = vnode;

            let childIds = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getChildIds(vnode),
                i        = 0,
                len      = childIds.length,
                child;

            for (; i < len; i++) {
                child = Neo.getComponent(childIds[i]);

                if (child) {
                    child.vnodeInitialized = true
                }
            }

            me.vnodeInitialized = true;

            if (autoMount) {
                me.mounted = true;

                if (!app.mounted) {
                    app.mounted = true;
                    app.fire('mounted')
                }
            }
        }
    }

    /**
     * @returns {Promise<any>}
     */
    promiseUpdate() {
        let me = this;

        return new Promise((resolve, reject) => {
            const id = Symbol();

            me.registerAsync(id, reject);

            me.updateVdom(
                (val) => {me.unregisterAsync(id); resolve(val)},
                (err) => {me.unregisterAsync(id); reject(err)}
            )
        })
    }

    /**
     * Internal helper fn to resolve the Promise for updateVdom()
     * @param {Object} [data] The return value of vdom.Helper.update()
     * @param {Set<String>|null} [mergedChildIds] IDs of children included in this update
     * @protected
     */
    resolveVdomUpdate(data, mergedChildIds) {
        let me = this;

        me.isVdomUpdating = false;

        // Execute callbacks for merged updates
        _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].executeCallbacks(me.id, data, mergedChildIds);

        // The update is no longer in-flight
        _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].unregisterInFlightUpdate(me.id);

        // Trigger updates for components that were in-flight
        _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].triggerPostUpdates(me.id);

        // Execute callbacks which wanted to run before the next update cycle
        _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].executePreUpdates(me.id);

        if (me.needsVdomUpdate) {
            // any new promise callbacks will get picked up by the next update cycle
            me.update()
        }
    }

    /**
     * Placeholder method for util.VDom.syncVdomState to allow overriding (disabling) it
     * @param {Neo.vdom.VNode} [vnode=this.vnode]
     * @param {Object} [vdom=this.vdom]
     * @param {Boolean} force=false
     */
    syncVdomState(vnode=this.vnode, vdom=this.vdom, force=false) {
        _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].syncVdomState(vnode, vdom, force)
    }

    /**
     * In case a component receives a new vnode, we want to do:
     * - sync the vdom ids
     * - setting vnodeInitialized to true for child components
     * - updating the parent component to ensure that the vnode tree stays persistent
     *
     * **Implementation Detail:**
     * This method uses a two-pass strategy to handle child updates:
     * 1. **Update Visible Children:** We iterate over children found directly in the new VNode structure
     *    (via `ComponentManager.getChildren`). This preserves the baseline behavior where fully expanded
     *    VNode trees (e.g., from `Helper.create`) are synced without unnecessary "downgrading" to references.
     * 2. **Unmount Missing Children:** We iterate over ALL logical children (via `ComponentManager.find`)
     *    to detect any that are absent from the new VNode tree (e.g., `removeDom: true`).
     *    Crucially, we use `VNodeUtil.find` to distinguish between a "Placeholder" (valid, do nothing)
     *    and a "Removal" (invalid, unmount).
     *
     * @param {Neo.vdom.VNode} [vnode=this.vnode]
     */
    syncVnodeTree(vnode=this.vnode) {
        let me              = this,
            childComponents = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getChildren(me),
            debug           = false,
            map             = {},
            childVnode, start;

        if (debug) {
            start = performance.now()
        }

        me.syncVdomState();

        if (vnode && me.id !== vnode.id) {
            _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].registerWrapperNode(vnode.id, me)
        }

        // we need one separate iteration first to ensure all wrapper nodes get registered
        for (let i = 0, len = childComponents.length; i < len; i++) {
            let component = childComponents[i];
            childVnode = _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].find(me.vnode, component.vdom.id)?.vnode;

            if (childVnode) {
                map[component.id] = childVnode;

                if (component.id !== childVnode.id) {
                    _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].registerWrapperNode(childVnode.id, component)
                }
            }
        }

        // delegate the latest node updates to all possible child components found inside the vnode tree
        for (let i = 0, len = childComponents.length; i < len; i++) {
            let component = childComponents[i];
            childVnode = map[component.id];

            if (childVnode) {
                // silent update
                component._vnode = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].addVnodeComponentReferences(childVnode, component.id);

                component.vnodeInitialized = true;
                component.mounted          = true
            } else {
                console.warn('syncVnodeTree: Could not replace the child vnode for', component.id)
            }
        }

        // New logic to handle unmounting of removed children
        let directChildren = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getDirectChildren(me.id);
        for (let i = 0, len = directChildren.length; i < len; i++) {
            let component = directChildren[i];
            if (!childComponents.includes(component)) {
                childVnode = null;

                // Check if it exists in the tree (as placeholder)
                // We use VNodeUtil.find which resolves placeholders
                if (me.vnode) {
                    childVnode = _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].find(me.vnode, component.vdom.id)?.vnode
                }

                if (!childVnode && !component.floating) {
                    component._vnode = null;
                    component.mounted = false
                }
            }
        }

        // silent update
        me._vnode = vnode ? _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].addVnodeComponentReferences(vnode, me.id) : null;

        debug && console.log('syncVnodeTree', me.id, performance.now() - start)
    }

    /**
     *
     */
    update() {
        this.afterSetVdom(this.vdom, null)
    }

    /**
     * Gets called after the vdom config gets changed in case the component is already mounted (delta updates).
     * @param {function} [resolve] used by promiseUpdate()
     * @param {function} [reject] used by promiseUpdate()
     * @protected
     */
    updateVdom(resolve, reject) {
        if (!this.isConstructed) {
            resolve?.();
            return
        }

        let me                         = this,
            {mounted, parentId, vnode} = me,
            {config}                   = Neo;

        if (config.unitTestMode && !config.allowVdomUpdatesInTests) {
            reject?.();
            return
        }

        me.ensureStableIds();

        // If there's a promise, register it against this component's ID immediately.
        // The manager will ensure it's called when the appropriate update cycle completes.
        resolve && _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].addPromiseCallback(me.id, resolve);

        // Attempt to merge into a parent's update cycle.
        // We do this even if silent, to ensure we catch the bus if a parent is departing.
        if (me.mergeIntoParentUpdate(parentId)) {
            me.needsVdomUpdate = true;
            return
        }

        if (me.isVdomUpdating || !me.vnodeInitialized || me.silentVdomUpdate) {
            me.needsVdomUpdate = true
        } else {
            // If an update is triggered on an unmounted component, we must wait for it to be mounted.
            if (!mounted) {
                // Use a flag to prevent setting up multiple `then` listeners for subsequent updates
                // that might arrive before the component is mounted.
                if (!me.isAwaitingMount) {
                    me.isAwaitingMount = true;
                    me.mountedPromise.then(() => {
                        me.isAwaitingMount = false;
                        // After mounting, re-trigger the update cycle. The cached callbacks will be picked up.
                        me.vnode && me.update();
                    });
                }
            }
            else {
                if (
                    !me.isParentUpdating(parentId, resolve)
                    && !me.isChildUpdating(resolve)
                    && vnode
                ) {
                    // Check for merged child updates and adjust the update depth accordingly
                    // let adjustedDepth = VDomUpdate.getAdjustedUpdateDepth(me.id);
                    //
                    // if (adjustedDepth !== null) {
                    //     me.updateDepth = adjustedDepth;
                    // }

                    // Verify that the critical rendering path => CSS files for the new tree is in place
                    if (!config.isMiddleware && !config.unitTestMode && currentWorker.countLoadingThemeFiles !== 0) {
                        currentWorker.on('themeFilesLoaded', function() {
                            me.updateVdom(resolve, reject)
                        }, me, {once: true})
                    } else {
                        me.executeVdomUpdate(null, reject)
                    }
                }
            }
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(VdomLifecycle));


/***/ },

/***/ "./src/toolbar/Base.mjs"
/*!******************************!*\
  !*** ./src/toolbar/Base.mjs ***!
  \******************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../button/Base.mjs */ "./src/button/Base.mjs");
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _component_Label_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../component/Label.mjs */ "./src/component/Label.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");






/**
 * @class Neo.toolbar.Base
 * @extends Neo.container.Base
 */
class Toolbar extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    /**
     * Valid values for dock
     * @member {String[]} dockPositions=['top','right','bottom','left', null]
     * @static
     */
    static dockPositions = ['top', 'right', 'bottom', 'left', null]

    static config = {
        /**
         * @member {String} className='Neo.toolbar.Base'
         * @protected
         */
        className: 'Neo.toolbar.Base',
        /**
         * @member {String} ntype='toolbar'
         * @protected
         */
        ntype: 'toolbar',
        /**
         * @member {String[]} baseCls=['neo-toolbar']
         */
        baseCls: ['neo-toolbar'],
        /**
         * @member {String|null} dock_=null
         * @reactive
         */
        dock_: null,
        /**
         * @member {Object} itemDefaults={ntype:'button'}
         * @reactive
         */
        itemDefaults: {
            ntype: 'button'
        },
        /**
         * @member {Object} layout={ntype:'flexbox',align:'center',direction: 'row', pack:'start'}
         * @reactive
         */
        layout: {
            ntype    : 'flexbox',
            align    : 'center',
            direction: 'row',
            pack     : 'start'
        }
    }

    /**
     * Triggered after the dock config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetDock(value, oldValue) {
        if (!value && !oldValue) {
            return
        }

        let me            = this,
            {cls}         = me,
            dockPositions = me.getStaticConfig('dockPositions'),
            layoutConfig  = me.getLayoutConfig();

        dockPositions.forEach(key => {
            key !== null && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].toggle(cls, 'neo-dock-' + key, key === value)
        });

        if (!me.layout) {
            layoutConfig.ntype = 'flexbox';
            me.set({cls, layout: layoutConfig})
        } else {
            me.layout.set(layoutConfig);
            me.cls = cls;
        }
    }

    /**
     * Checks if the new dock position matches a value of the static dockPositions config
     * @param {String} value
     * @param {String} oldValue
     * @returns {String} value
     * @protected
     */
    beforeSetDock(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'dock', 'dockPositions')
    }

    /**
     *
     */
    createItems() {
        let items = this._items;

        if (Array.isArray(items)) {
            this._items = items.map(item => this.replaceSpacer(item))
        }

        return super.createItems()
    }

    /**
     * Creates a layout config depending on this.dock
     * @returns {Object} layoutConfig
     */
    getLayoutConfig() {
        let me = this,
            layoutConfig;

        if (me.dock) {
            switch (me.dock) {
                case 'bottom':
                case 'top':
                    layoutConfig = {
                        align    : 'center',
                        direction: 'row',
                        pack     : 'start'
                    };
                    break
                case 'left':
                    layoutConfig = {
                        align    : 'center',
                        direction: 'column-reverse',
                        pack     : 'start'
                    };
                    break
                case 'right':
                    layoutConfig = {
                        align    : 'center',
                        direction: 'column',
                        pack     : 'start'
                    };
                    break
            }
        }

        return layoutConfig || me.layout
    }

    /**
     * Inserts an item or array of items at a specific index
     * @param {Number} index
     * @param {Array|Object} item
     * @param {Boolean} [silent=false]
     * @returns {Neo.component.Base|Neo.component.Base[]}
     */
    insert(index, item, silent=false) {
        if (Array.isArray(item)) {
            item = item.map(item => this.replaceSpacer(item))
        } else {
            item = this.replaceSpacer(item)
        }

        return super.insert(index, item, silent)
    }

    /**
     * @param {Array|Object|String} item
     * @returns {Array|Object}
     */
    replaceSpacer(item) {
        return item === '->' ? {module: _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"], flex: 1} : item
    }

    /**
     * @returns {Object}
     */
    toJSON() {
        return {
            ...super.toJSON(),
            dock: this.dock
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Toolbar));


/***/ },

/***/ "./src/util/ClassSystem.mjs"
/*!**********************************!*\
  !*** ./src/util/ClassSystem.mjs ***!
  \**********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.util.ClassSystem
 * @extends Neo.core.Base
 */
class ClassSystem extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.ClassSystem'
         * @protected
         */
        className: 'Neo.util.ClassSystem'
    }

    /**
     * can get used inside beforeSet methods in case you want to create instances like stores
     * @param {Object|Neo.core.Base|null} config
     * @param {Neo.core.Base|String} [DefaultClass=null]
     * @param {Object} [defaultValues={}]
     * @returns {Neo.core.Base} instance
     */
    static beforeSetInstance(config, DefaultClass=null, defaultValues={}) {
        let configType = Neo.typeOf(config);

        if (Neo.isString(DefaultClass)) {
            DefaultClass = Neo.ns(DefaultClass)
        }

        if (!config && DefaultClass) {
            config = Neo.create(DefaultClass, defaultValues)
        } else if (configType === 'NeoClass') {
            config = Neo.create(config, defaultValues)
        } else if (configType === 'Object') {
            if (config.ntype) {
                config = Neo.ntype({
                    ...defaultValues,
                    ...config
                })
            } else {
                let newConfig = {};

                if (DefaultClass) {
                    newConfig.module = DefaultClass
                }

                Object.assign(newConfig, {
                    ...defaultValues,
                    ...config
                });

                config = Neo.create(newConfig)
            }
        } else if (configType === 'NeoInstance') {
            if (defaultValues?.listeners) {
                config.on(defaultValues.listeners)
            }
        }

        return config
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(ClassSystem));


/***/ },

/***/ "./src/util/KeyNavigation.mjs"
/*!************************************!*\
  !*** ./src/util/KeyNavigation.mjs ***!
  \************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @class Neo.util.KeyNavigation
 * @extends Neo.core.Base
 */
class KeyNavigation extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.KeyNavigation'
         * @protected
         */
        className: 'Neo.util.KeyNavigation',
        /**
         * @member {String} ntype='keynav'
         * @protected
         */
        ntype: 'keynav',
        /**
         * Internally stores the component id inside _component
         * @member {Neo.component.Base|null} component_=null
         * @reactive
         */
        component_: null,
        /**
         * Set this to true in case the keydown event is supposed to bubble upwards inside the component tree
         * @member {Boolean} keyDownEventBubble=false
         */
        keyDownEventBubble: false,
        /**
         * @member {Array|null} keys_=null
         * @reactive
         */
        keys_: null
    }

    add(value) {
        this._keys.push(...this.parseKeys(value))
    }

    /**
     * @protected
     * @returns {Neo.component.Base}
     */
    beforeGetComponent() {
        return Neo.getComponent(this._component)
    }

    /**
     * @param {Neo.component.Base} value
     * @protected
     * @returns {String} the component id
     */
    beforeSetComponent(value) {
        return value?.id
    }

    /**
     *
     */
    destroy() {
        this.unregister();
        super.destroy()
    }

    /**
     * @param {Object} data
     */
    onKeyDown(data) {
        // Using the chrome auto-fill feature does trigger a keydown event, not containing a key. See: #64
        if (data.key) {
            let me           = this,
                upperCaseKey = data.key.toUpperCase(),
                scope;

            upperCaseKey = me.parseUpperCaseKey(upperCaseKey);

            me.keys.forEach(key => {
                scope = Neo.isString(key.scope) ? Neo.get(key.scope) : key.scope;

                if (key.key.toUpperCase() === upperCaseKey) {
                    if (Neo.isFunction(key.fn)) {
                        key.fn.apply(scope, [data, me.component])
                    } else {
                        scope[key.fn]?.apply(scope, [data, me.component])
                    }
                }
            })
        }
    }

    /**
     * @param {Object} value
     * @returns {Object}
     */
    parseKeys(value) {
        if (!Array.isArray(value)) {
            let componentId = this._component,
                keyArray    = [];

            if (componentId) {
                Object.entries(value).forEach(([key, val]) => {
                    if (key !== 'scope') {
                        keyArray.push({
                            fn   : val,
                            key,
                            scope: value.scope || componentId // todo: support VCs later on
                        })
                    }
                });

                value = keyArray
            }
        }

        return value
    }

    /**
     * Replaces specific key names, e.g. " " => SPACE
     * @param {String} key
     * @protected
     * @returns {String}
     */
    parseUpperCaseKey(key) {
        switch (key) {
            case ' ':
                key = 'SPACE';
                break
            case 'ARROWDOWN':
                key = 'DOWN';
                break
            case 'ARROWLEFT':
                key = 'LEFT';
                break
            case 'ARROWRIGHT':
                key = 'RIGHT';
                break
            case 'ARROWUP':
                key = 'UP';
                break
        }

        return key
    }

    /**
     * @param {Neo.component.Base} component
     */
    register(component) {
        let me = this;

        me.component = component;
        me.keys      = me.parseKeys(me.keys);

        component.addDomListeners({
            keydown: {
                bubble: me.keyDownEventBubble,
                fn    : me.onKeyDown,
                scope : me
            }
        })
    }

    /**
     * Remove a key listener using the same config used when creating it
     * @param {Object} config
     */
    removeKey(config) {
        let me   = this,
            keys = me._keys,
            i    = 0,
            len  = keys.length,
            key;

        for (; i < len; i++) {
            key = keys[i];

            if (Neo.isEqual(key, config)) {
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(keys, key);
                break
            }
        }
    }

    /**
     * Remove multiple key listeners passing an array of config items
     * @param {Array} items
     */
    removeKeys(items) {
        Array.isArray(items) && items.forEach(item => this.removeKey(item))
    }

    /**
     *
     */
    unregister() {
        // todo: remove the dom listener from the owner component
    }

    /**
     * Serializes the KeyNavigation into a JSON-compatible object.
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            component: me.serializeConfig(me.component),
            keys     : me.serializeConfig(me.keys)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(KeyNavigation));


/***/ },

/***/ "./src/util/Rectangle.mjs"
/*!********************************!*\
  !*** ./src/util/Rectangle.mjs ***!
  \********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Rectangle)
/* harmony export */ });
/**
 * The class contains utility methods for working with DOMRect Objects
 * @class Neo.util.Rectangle
 * @extends DOMRect
 */

const
    emptyArray = Object.freeze([]),
    // Convert edge array values into the [T,R,B,L] form.
    parseEdgeValue = (e = 0) => {
        if (!Array.isArray(e)) {
            e = [e];
        }
        switch (e.length) {
            case 1:
                e.length = 4;
                return e.fill(e[0], 1, 4);
            case 2:// top&bottom, left&right
                return [e[0], e[1], e[0], e[1]];
            case 3:// top, left&right, bottom
                return [e[0], e[1], e[2], e[1]];
        }
        return e;
    },
    parseEdgeAlign = edgeAlign => {
        const
            edgeParts     = edgeAlignRE.exec(edgeAlign),
            ourEdgeZone   = edgeZone[edgeParts[1]],
            theirEdgeZone = edgeZone[edgeParts[4]];

        return {
            ourEdge         : edgeParts[1],
            ourEdgeOffset   : parseInt(edgeParts[2] || 50),
            ourEdgeUnit     : edgeParts[3] || '%',
            ourEdgeZone,
            theirEdge       : edgeParts[4],
            theirEdgeOffset : parseInt(edgeParts[5] || 50),
            theirEdgeUnit   : edgeParts[6] || '%',
            theirEdgeZone,

            // Aligned to an edge, *outside* of the target.
            // A normal align as a combo dropdown might request
            edgeAligned     : (ourEdgeZone & 1) === (theirEdgeZone & 1) && ourEdgeZone !== theirEdgeZone
        }
    },
    // The opposite of parseEdgeAlign, and it has to flip the edges
    createReversedEdgeAlign = edges => {
        const
            ourEdge   = oppositeEdge[edges.ourEdge],
            theirEdge = oppositeEdge[edges.theirEdge];

        // reconstitute a rule string with the edges flipped to the opposite sides
        return `${ourEdge}${edges.ourEdgeOffset}${edges.ourEdgeUnit}-${theirEdge}${edges.theirEdgeOffset}${edges.theirEdgeUnit}`

    },
    getElRect = el => {
        const r = el instanceof DOMRect ? el : (el?.nodeType === 1 ? el : typeof el === 'string' ? document.getElementById(el) : null)?.getBoundingClientRect();

        // Convert DOMRect into Rectangle
        return r && new Rectangle(r.x, r.y, r.width, r.height);
    },
    oppositeEdge = {
        t : 'b',
        r : 'l',
        b : 't',
        l : 'r'
    },
    edgeZone = {
        t : 0,
        r : 1,
        b : 2,
        l : 3
    },
    zoneNames = ['top', 'right', 'bottom', 'left'],
    zoneEdges = ['t', 'r', 'b', 'l'],
    zoneDimension = ['width', 'height'],
    zoneCoord = [0, 1, 0, 1],
    zeroMargins = [0, 0, 0, 0],
    edgeAlignRE = /^([trblc])(\d*)(%|px)?-([trblc])(\d*)(%|px)?$/;

class Rectangle extends DOMRect {
    static config = {
        /**
         * @member {String} className='Neo.util.Rectangle'
         * @protected
         */
        className: 'Neo.util.Rectangle'
    }

    /**
     * @member {Number|null} minHeight=null
     */
    minHeight = null
    /**
     * @member {Number|null} minWidth=null
     */
    minWidth = null

    /**
     * Checks if rect1 does not have an intersection with rect2
     * !includes() is true for intersections as well
     * @param {Object} rect1
     * @param {Object} rect2
     * @returns {Boolean}
     */
    static excludes(rect1, rect2) {
        return rect1.bottom < rect2.top     // rect2 is below rect1
            || rect1.left   > rect2.right   // rect2 is left of rect1
            || rect1.right  < rect2.left    // rect2 is right of rect1
            || rect1.top    > rect2.bottom; // rect2 is above rect1
    }

    /**
     * Returns the overlapping area of rect1 & rect2 as a new Rectangle
     * @param {DOMRect|Neo.util.Rectangle} rect1
     * @param {DOMRect|Neo.util.Rectangle} rect2
     * @returns {Neo.util.Rectangle|null} The intersecting rect
     */
    static getIntersection(rect1, rect2) {
        let x      = Math.max(rect1.x,      rect2.x),
            y      = Math.max(rect1.y,      rect2.y),
            right  = Math.min(rect1.right,  rect2.right),
            bottom = Math.min(rect1.bottom, rect2.bottom),
            width  = Math.max(0, right  - x),
            height = Math.max(0, bottom - y);

        if (height < 1 || width < 1) {
            return null
        }

        return new Rectangle(x, y, width, height)
    }

    /**
     * Checks if rect2 is fully contained inside rect1
     * @param {Object} rect1
     * @param {Object} rect2
     * @returns {Boolean}
     */
    static includes(rect1, rect2) {
        return rect1.bottom >= rect2.bottom
            && rect1.left   <= rect2.left
            && rect1.right  >= rect2.right
            && rect1.top    <= rect2.top;
    }

    /**
     * Checks if rect2 is not contained inside rect1.
     * This could be an intersection or being fully excluded.
     * @param {Object} rect1
     * @param {Object} rect2
     * @param {String} side bottom, left, right or top
     * @returns {Boolean}
     */
    static leavesSide(rect1, rect2, side) {
        if (Rectangle.includes(rect1, rect2)) {
            return false;
        }

        if (side === 'bottom') {
            return rect1.bottom < rect2.bottom;
        }

        if (side === 'left') {
            return rect1.left > rect2.left;
        }

        if (side === 'right') {
            return rect1.right < rect2.right;
        }

        if (side === 'top') {
            return rect1.top > rect2.top;
        }
    }

    /**
     * Adjusts a DOMRect object to a new position
     * @param {Object} rect
     * @param {Number|null} [x=null]
     * @param {Number|null} [y=null]
     * @returns {Object} movedRect
     */
    static moveBy(rect, x=null, y=null) {
        let movedRect = {...rect};

        if (Neo.isNumber(x)) {
            movedRect.left  += x;
            movedRect.right += x;
            movedRect.x     += x;
        }

        if (Neo.isNumber(y)) {
            movedRect.bottom += y;
            movedRect.top    += y;
            movedRect.y      += y;
        }

        return movedRect;
    }

    /**
     * Adjusts a DOMRect object to a new position
     * @param {Object} rect
     * @param {Number|null} [x=null]
     * @param {Number|null} [y=null]
     * @returns {Object} movedRect
     */
    static moveTo(rect, x=null, y=null) {
        let movedRect = {...rect};

        if (Neo.isNumber(x)) {
            movedRect.left  = x;
            movedRect.right = x + movedRect.width;
            movedRect.x     = x;
        }

        if (Neo.isNumber(y)) {
            movedRect.bottom = y + movedRect.height;
            movedRect.top    = y;
            movedRect.y      = y;
        }

        return movedRect;
    }

    set bottom(b) {
        this.height += b - this.bottom;
    }
    get bottom() {
        return super.bottom;
    }

    set right(r) {
        this.width += r - this.right;
    }
    get right() {
        return super.right;
    }

    // Change the x without moving the Rectangle. The left side moves and the right side doesn't
    changeX(x) {
        const widthDelta = this.x - x;

        this.x = x;
        this.width += widthDelta;
    }

    // Change the y without moving the Rectangle. The top side moves and the bottom side doesn't
    changeY(y) {
        const heightDelta = this.y - y;

        this.y = y;
        this.height += heightDelta;
    }

    clone() {
        return Rectangle.clone(this);
    }

    static clone(r) {
        const result = new Rectangle(r.x, r.y, r.width, r.height);

        result.minWidth = r.minWidth;
        result.minHeight = r.minHeight;

        return result;
    }

    intersects(other) {
        const me = this;

        if (other.height && other.width) {
            const
                left   = Math.max(me.x, other.x),
                top    = Math.max(me.y, other.y),
                right  = Math.min(me.x + me.width, other.x + other.width),
                bottom = Math.min(me.y + me.height, other.y + other.height);

            if (left >= right || top >= bottom) {
                return false;
            }

            return new Rectangle(left, top, right - left, bottom - top);
        }
        // We're dealing with a point here - zero dimensions
        else {
            return (other.x >= me.x && other.y >= me.y && other.right <= me.right && other.bottom <= me.bottom);
        }
    }


    /**
     * Returns a clone of this Rectangle expanded according to the edges array.
     * @param {Number[]} edges
     * @returns {Rectangle}
     */
    expand(edges) {
        edges = parseEdgeValue(edges);

        return new this.constructor(this.x - edges[3], this.y - edges[0], this.width + edges[1] + edges[3], this.height + edges[0] + edges[2]);
    }

    moveBy(x = 0, y = 0) {
        const result = this.clone();

        if (Array.isArray(x)) {
            y = x[1];
            x = x[0];
        }
        result.x += x;
        result.y += y;
        return result;
    }

    /**
     * Returns `true` if this Rectangle completely contains the other Rectangle
     * @param {Rectangle} other
     */
    contains(other) {
        return Rectangle.includes(this, other)
    }

    /**
     * Returns a copy of this Rectangle constrained to fit within the passed Rectangle
     * @param {Rectangle} constrainTo
     * @returns {Rectangle|Boolean} A new Rectangle constrained to te passed Rectangle, or false if it could not be constrained.
     */
    constrainTo(constrainTo) {
        const
            me        = this,
            minWidth  = me.minWidth  || me.width,
            minHeight = me.minHeight || me.height;

        // Not possible, even when shrunk to minima
        if (minHeight > constrainTo.height || minWidth > constrainTo.width) {
            return false;
        }

        // We do not mutate this Rectangle, but return a constrained version
        const result = me.clone();

        // Translate result so that the top and left are visible
        result.x = Math.max(me.x + Math.min(constrainTo.right  - result.right,  0), constrainTo.x);
        result.y = Math.max(me.y + Math.min(constrainTo.bottom - result.bottom, 0), constrainTo.y);

        // Pull in any resulting overflow
        result.bottom = Math.min(result.bottom, constrainTo.bottom);
        result.right = Math.min(result.right, constrainTo.right);

        return result;
    }

    alignTo(align) {
        const
            me             = this,
            {
                constrainTo,    // Element or Rectangle result must fit into
                target,         // Element or Rectangle to align to
                edgeAlign,      // t50-b50 type string
                axisLock,       // true for flip, 'flexible' for flip, then try the other edges
                offset,         // Final [x, y] vector to move the result by.
                matchSize
            }              = align,
            targetMargin   = align.targetMargin ? parseEdgeValue(align.targetMargin) : zeroMargins,
            targetRect     = getElRect(target),
            constrainRect  = getElRect(constrainTo),
            edges          = parseEdgeAlign(edgeAlign),
            matchDimension = zoneDimension[edges.theirEdgeZone & 1];

        let result = me.clone();

        if (matchSize) {
            result[matchDimension] = targetRect[matchDimension];
        }

        // Must do the calculations after the aligned side has been matched in size if requested.
        const
            myPoint     = result.getAnchorPoint(edges.ourEdgeZone, edges.ourEdgeOffset, edges.ourEdgeUnit),
            targetPoint = targetRect.getAnchorPoint(edges.theirEdgeZone, edges.theirEdgeOffset, edges.theirEdgeUnit, targetMargin),
            vector      = [targetPoint[0] - myPoint[0], targetPoint[1] - myPoint[1]];

        result = result.moveBy(vector);

        // A useful property in the resulting rectangle which specifies which zone of the target
        // It is being places in, T,R,B or L - 0, 1, 2, 3
        // Some code may want to treat DOM elements differently depending on the zone
        result.zone = edges.theirEdgeZone;
        result.position = zoneNames[result.zone];

        // Now we create the four Rectangles around the target, into which we may be constrained
        // Zones T,R,B,L 0 9, 1, 2, 3:
        // +-----------------------------------------------------------------------------------+
        // | +-------------------------+------------------------+----------------------------+ |
        // | |          ^              |                        |             ^              | |
        // | |          |              |                        |             |              | |
        // | |  <-------+--------------+---------Zone 0---------+-------------+---------->   | |
        // | |          |              |                        |             |              | |
        // | |          |              |                        |             |              | |
        // | +----------+--------------+------------------------+-------------+--------------+ |
        // | |          |              | +--------------------+ |             |              | |
        // | |          |              | |                    | |             |              | |
        // | |          |              | |                    | |             |              | |
        // | |       Zone 3            | |                    | |          Zone 1            | |
        // | |          |              | |                    | |             |              | |
        // | |          |              | |                    | |             |              | |
        // | |          |              | +--------------------+ |             |              | |
        // | ++---------+--------------+------------------------+-------------+--------------+ |
        // | |          |              |                        |             |              | |
        // | |          |              |                        |             |              | |
        // | |          |              |                        |             |              | |
        // | |  <-------+--------------+--------Zone 2----------+-------------+------------> | |
        // | |          |              |                        |             |              | |
        // | |          v              |                        |             v              | |
        // | ++------------------------+------------------------+----------------------------+ |
        // +-----------------------------------------------------------------------------------+
        if (constrainRect && !constrainRect.contains(result)) {
            // They asked to overlap the target, for example t0-t0
            // In these cases, we just return the result
            if (targetRect.intersects(result)) {
                return result;
            }

            // This is the zone we try to fit into first, the one that was asked for
            let zone = edges.theirEdgeZone;

            // We create an array of four rectangles into which we try to fit with appropriate align specs.
            // We must start with the requested zone, whatever that is.
            const zonesToTry = [{
                zone,
                edgeAlign
            }];

            if (axisLock) {
                // Flip to the opposite side for the second try.
                // The alignment string has to be reversed
                // so r20-l30 has to become l20-r30.
                // The other two zones revert to centered so are easier
                zonesToTry[1] = {
                    zone      : zone = (zone + 2) % 4,
                    edgeAlign : createReversedEdgeAlign(edges)
                }

                // Fall back to the other two zones.
                zonesToTry.push({
                    zone      : zone = (edges.theirEdgeZone + 1) % 4,
                    edgeAlign : `${oppositeEdge[zoneEdges[zone]]}-${zoneEdges[zone]}`
                });
                zonesToTry.push({
                    zone      : zone = (edges.theirEdgeZone + 3) % 4,
                    edgeAlign : `${oppositeEdge[zoneEdges[zone]]}-${zoneEdges[zone]}`
                });
            }
            else {
                // go through the other zones in order
                for (let i = 1; i < 4; i++) {
                    zonesToTry.push({
                        zone      : zone = (zone + 1) % 4,
                        edgeAlign : `${oppositeEdge[zoneEdges[zone]]}-${zoneEdges[zone]}`
                    });
                }
            }

            // Calculate the constraint Rectangle for each zone
            for (let i = 0; i < zonesToTry.length; i++) {
                // We clone the outer constraining rectangle
                // and move it into position
                const c = constrainRect.clone();

                switch (zonesToTry[i].zone) {
                    case 0:
                        // The zone i2 above the target - zone 0/T
                        c.bottom = targetRect.y - targetMargin[0];
                        break;
                    case 1:
                        // The zone is to the right of the target - zone 1/R
                        c.changeX(targetRect.right + targetMargin[1]);
                        break;
                    case 2:
                        // The zone is below the target - zone 2/B
                        c.changeY(targetRect.bottom + targetMargin[2]);
                        break;
                    case 3:
                        // The zone is to the left of the target - zone 3/L
                        c.right = targetRect.x - targetMargin[3];
                        break;
                }
                zonesToTry[i].constrainRect = c;
            }

            // Now try to constrain our result into each zone's constraintZone
            for (let i = 0; i < zonesToTry.length; i++) {
                const
                    {
                        zone,
                        edgeAlign,
                        constrainRect
                    }    = zonesToTry[i],
                    edge = zoneEdges[zone];

                if (matchSize) {
                    // If we are aligning to the requested edge, or it's opposite edge then
                    // match that edge size, else revert it to our own size
                    result[matchDimension] = edge === edges.theirEdge || edge == oppositeEdge[edges.theirEdge] ? targetRect[matchDimension] : me[matchDimension];
                }

                // Do a simple align to the current edge
                result = result.alignTo({
                    target : targetRect,
                    edgeAlign,
                    targetMargin
                });

                let solution = result.constrainTo(constrainRect);

                // As soon as we find a zone into which the result is willing to be constrained. return it
                if (solution) {
                    solution.zone = zone;
                    solution.position = zoneNames[zone];
                    return solution;
                }
            }
        }

        // Add the configurable finishing touch.
        if (offset) {
            result.moveBy(offset);
        }

        return result;
    }

    getAnchorPoint(edgeZone, edgeOffset, edgeUnit, margin = emptyArray) {
        const me = this;

        let result;

        // Edge zones go top, right, bottom, left
        // Each one calculates the start point of that edge then moves along it by
        // the edgeOffset, then moves *away* from it by the margin for that edge if there's a margin.
        switch (edgeZone) {
            case 0:
                result = [me.x, me.y - (margin[0] || 0), me.width, 0];
                break;
            case 1:
                result = [me.x + me.width + (margin[1] || 0), me.y, me.height, 1];
                break;
            case 2:
                result = [me.x, me.y + me.height + (margin[2] || 0), me.width, 0];
                break;
            case 3:
                result = [me.x - (margin[3] || 0), me.y, me.height, 1];
        }
        result[result[3]] += edgeUnit === '%' ? result[2] / 100 * edgeOffset : edgeOffset;
        result.length = 2;
        return result;
    }

    equals(other) {
        return other instanceof DOMRect &&
            other.x === this.x &&
            other.y === this.y &&
            other.height === this.height &&
            other.width === this.width;
    }

    // For debugging purposes only
    show(color = 'red') {
        const div = document.createElement('div');

        div.style = `
            position:absolute;
            transform:translate3d(${this.x}px, ${this.y}px, 0);
            height:${this.height}px;
            width:${this.width}px;
            background-color:${color}
        `;
        document.body.appendChild(div);
        setTimeout(() => div.remove(), 30000);
        return div;
    }

    /**
     * When using JSON.stringify(this), we want to add minHeight & minWidth to the output.
     * @returns {Object}
     */
    toJSON() {
        const {bottom, height, left, minHeight, minWidth, right, top, width, x, y} = this;
        return {bottom, height, left, minHeight, minWidth, right, top, width, x, y}
    }
}


/***/ },

/***/ "./src/util/String.mjs"
/*!*****************************!*\
  !*** ./src/util/String.mjs ***!
  \*****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.util.String
 * @extends Neo.core.Base
 */
class StringUtil extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @member {Object} charEntityMap
     * @static
     */
    static charEntityMap = {
        '&' : '&amp;',
        '<' : '&lt;',
        '>' : '&gt;',
        '"' : '&quot;',
        '\'': '&apos;',
        '$' : '&dollar;',
        '\\': '&bsol;',
        '/' : '&sol;'
    }
    /**
     * @member {RegExp} charPattern
     * @static
     */
    static charPattern = /[&<>"'$\\]/g
    /**
     * @member {RegExp} entityPattern
     * @static
     */
    static entityPattern = /(&amp;)|(&lt;)|(&gt;)|(&quot;)|(&apos;)|(&dollar;)|(&bsol;)|(&sol;)/g

    static config = {
        /**
         * @member {String} className='Neo.util.String'
         * @protected
         */
        className: 'Neo.util.String'
    }

    /**
     * Escape HTML special characters
     * @param {String} value
     */
    static escapeHtml(value) {
        let me = this; // inside a static method, we are pointing to the class prototype

        if (!Neo.isString(value)) {
            return value
        }

        return value.replace(me.charPattern, me.getEntityFromChar.bind(me))
    }

    /**
     * Get char equivalent of a mapped entity
     * @param {String} entity
     */
    static getCharFromEntity(entity) {
        let mappedChar = Object.keys(this.charEntityMap).find(key => this.charEntityMap[key] === entity);
        return mappedChar || entity
    }

    /**
     * Get entity equivalent of a mapped char
     * @param {String} char
     */
    static getEntityFromChar(char) {
        return this.charEntityMap[char] || char
    }

    /**
     * Unescape HTML special characters
     * @param {String} value
     */
    static unescapeHtml(value) {
        let me = this; // inside a static method, we are pointing to the class prototype

        if (!Neo.isString(value)) {
            return value
        }

        return value.replace(me.entityPattern, me.getCharFromEntity.bind(me))
    }

    /**
     * Returns the passed string with the first letter uncapitalized.
     * @param {String} value
     * @returns  {String}
     */
    static uncapitalize(value) {
        return value && value[0].toLowerCase() + value.substring(1)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(StringUtil));


/***/ },

/***/ "./src/util/Style.mjs"
/*!****************************!*\
  !*** ./src/util/Style.mjs ***!
  \****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.util.Style
 * @extends Neo.core.Base
 */
class Style extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.Style'
         * @protected
         */
        className: 'Neo.util.Style'
    }

    /**
     * Creates an delta object, containing the styles of newStyle which are not included or different than in oldStyle
     * Styles included in oldStyle but missing in newStyle will get a value of null
     * see: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style
     * @param {Object|String} newStyle
     * @param {Object|String} oldStyle
     * @returns {Object} style delta
     */
    static compareStyles(newStyle, oldStyle) {
        let styles = {};

        if (Neo.isString(newStyle)) {
            newStyle = Neo.createStyleObject(newStyle)
        }

        if (Neo.isString(oldStyle)) {
            oldStyle = Neo.createStyleObject(oldStyle)
        }

        if (!newStyle && !oldStyle) {
            return null
        } else if (!oldStyle) {
            return Neo.clone(newStyle)
        } else {
            newStyle && Object.keys(newStyle).forEach(style => {
                if (!oldStyle.hasOwnProperty(style) || oldStyle[style] !== newStyle[style]) {
                    styles[style] = newStyle[style]
                }
            });

            Object.keys(oldStyle).forEach(style => {
                if (!newStyle  || !newStyle.hasOwnProperty(style)) {
                    styles[style] = null
                }
            });

            if (Object.keys(styles).length > 0) {
                return styles
            }

            return null
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Style));


/***/ },

/***/ "./src/util/VDom.mjs"
/*!***************************!*\
  !*** ./src/util/VDom.mjs ***!
  \***************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../manager/Component.mjs */ "./src/manager/Component.mjs");



/**
 * @class Neo.util.VDom
 * @extends Neo.core.Base
 */
class VDom extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.VDom'
         * @protected
         */
        className: 'Neo.util.VDom'
    }

    /**
     * @param {Object} vdom
     * @param {Boolean} removeIds=true
     * @returns {Object} cloned vdom
     */
    static clone(vdom, removeIds=true) {
        let clone = Neo.clone(vdom, true);

        if (removeIds) {
            delete clone.id
        }

        if (clone.cn) {
            clone.cn.forEach((item, index) => {
                clone.cn[index] = VDom.clone(item, removeIds)
            })
        }

        return clone
    }

    /**
     * Search vdom child nodes by id or opts object for a given vdom tree
     * @param {Object} vdom
     * @param {Object|String} opts Either an object containing vdom node attributes or a string based id
     * @param {Boolean} replaceComponentRefs=true
     * @param {Number} [index] Internal flag, do not use it
     * @param {Object} [parentNode] Internal flag, do not use it
     * @returns {Object}
     *     {Number} index
     *     {String} parentId
     *     {Object} vdom
     */
    static find(vdom, opts, replaceComponentRefs=true, index, parentNode) {
        index = index || 0;
        opts  = !Neo.isString(opts) ? opts : {id: opts};

        if (replaceComponentRefs) {
            vdom = VDom.getVdom(vdom)
        }

        let child      = null,
            matchArray = [],
            styleMatch = true,
            i          = 0,
            len        = vdom.cn?.length,
            optsArray  = Object.entries(opts),
            optsLength = optsArray.length,
            subChild;

        optsArray.forEach(([key, value]) => {
            if (vdom.hasOwnProperty(key)) {
                switch (key) {
                    case 'cls':
                        if (typeof value === 'string' && Neo.isArray(vdom[key])) {
                            if (vdom[key].includes(value)) {
                                matchArray.push(true)
                            }
                        } else if (typeof value === 'string' && typeof vdom[key] === 'string') {
                            if (vdom[key] === value) {
                                matchArray.push(true)
                            }
                        } else if (Neo.isArray(value) && Neo.isArray(vdom[key])) {
                            // todo: either search the vdom array for all keys or compare if the arrays are equal.
                            throw new Error('find: cls matching not supported for target & source types of Arrays')
                        }
                        break
                    case 'style':
                        if (typeof value === 'string' && typeof vdom[key] === 'string') {
                            if (vdom[key] === value) {
                                matchArray.push(true)
                            }
                        } else if (Neo.isObject(value) && Neo.isObject(vdom[key])) {
                            Object.entries(value).forEach(([styleKey, styleValue]) => {
                                if (!(vdom[key].hasOwnProperty(styleKey) && vdom[key][styleKey] === styleValue)) {
                                    styleMatch = false
                                }
                            });

                            if (styleMatch) {
                                matchArray.push(true)
                            }
                        } else {
                            throw new Error('find: style matching not supported for mixed target & source types (Object VS String)')
                        }
                        break
                    default:
                        if (vdom[key] === value) {
                            matchArray.push(true)
                        }
                        break
                }
            }
        });

        if (matchArray.length === optsLength) {
            return {index, parentNode, vdom}
        }

        if (vdom.cn) {
            for (; i < len; i++) {
                if (vdom.cn[i]) {
                    subChild = VDom.find(vdom.cn[i], opts, replaceComponentRefs, i, vdom);

                    if (subChild) {
                        child = {
                            index     : subChild.index,
                            parentNode: subChild.parentNode,
                            vdom      : subChild.vdom
                        };
                        break
                    }
                }
            }
        }

        return child
    }

    /**
     * Convenience shortcut for find(vdom, {flag: flag});
     * @param {Object} vdom
     * @param {String} flag The flag reference specified on the target vdom child node
     * @returns {Object} vdom
     */
    static getByFlag(vdom, flag) {
        return VDom.find(vdom, {flag})?.vdom
    }

    /**
     * Finds a child vdom node inside a vdom tree by a given id
     * @param {Object} vdom
     * @param {String|null} id
     * @returns {Object|null} child vdom node or null
     */
    static getById(vdom, id) {
        vdom = VDom.getVdom(vdom);

        if (!vdom) {
            return null
        }

        let childNodes = vdom.cn || [],
            i          = 0,
            len        = childNodes.length,
            childNode;

        if (vdom.id === id) {
            return vdom
        }

        for (; i < len; i++) {
            childNode = VDom.getVdom(childNodes[i]);

            if (childNode) {
                if (childNode.id === id) {
                    return childNode
                }

                childNode = VDom.getById(childNode, id);

                if (childNode) {
                    return childNode
                }
            }
        }

        return null
    }

    /**
     * Get the ids of all child nodes of the given vdom tree
     * @param vdom
     * @param [childIds=[]]
     * @returns {Array} childIds
     */
    static getChildIds(vdom, childIds=[]) {
        vdom = VDom.getVdom(vdom);

        let childNodes = vdom?.cn || [];

        childNodes.forEach(childNode => {
            if (childNode.id) {
                childIds.push(childNode.id)
            }

            childIds = VDom.getChildIds(childNode, childIds)
        });

        return childIds
    }

    /**
     * @param {Object} vdom
     * @param {Number} index
     * @returns {Array}
     */
    static getColumnNodes(vdom, index) {
        vdom = VDom.getVdom(vdom);

        let columnNodes = [];

        vdom.cn?.forEach(row => {
            if (row.cn?.[index]) {
                columnNodes.push(row.cn[index])
            }
        })

        return columnNodes
    }

    /**
     * @param {Object} vdom
     * @param {Number} index
     * @returns {Array}
     */
    static getColumnNodesIds(vdom, index) {
        return VDom.getColumnNodes(vdom, index).map(e => e.id)
    }

    /**
     * @param {Object} vdom
     * @param {String} flag
     * @param {Array} [matchArray]
     * @returns {Array} an array of vdom nodes which match the flag
     */
    static getFlags(vdom, flag, matchArray) {
        vdom = VDom.getVdom(vdom);

        if (!matchArray) {
            matchArray = [];

            if (vdom.flag === flag) {
                matchArray.push(vdom)
            }
        }

        (vdom?.cn || []).forEach(childNode => {
            if (childNode.flag === flag) {
                matchArray.push(childNode)
            }

            matchArray = VDom.getFlags(childNode, flag, matchArray)
        });

        return matchArray
    }

    /**
     * @param {Object} vdom
     * @param {String} id
     * @param {Boolean} topLevel=true Internal flag, do not use it
     * @returns {Array}
     */
    static getParentNodes(vdom, id, topLevel=true) {
        vdom = VDom.getVdom(vdom);

        let parents = null,
            i       = 0,
            len     = vdom.cn?.length || 0;

        if (vdom.id === id) {
            return []
        }

        for (; i < len; i++) {
            parents = VDom.getParentNodes(vdom.cn[i], id, false);

            if (parents) {
                parents.push(vdom.cn[i]);
                break
            }
        }

        if (topLevel && parents) {
            parents.push(vdom)
        }

        return parents
    }

    /**
     * Convenience shortcut using manager.Component to replace vdom references if needed
     * @param {Object} vdom
     * @returns {Object}
     */
    static getVdom(vdom) {
        if (vdom.componentId) {
            const component = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].get(vdom.componentId);

            if (!component) {
                throw new Error(`util.VDom.getVdom: Component not found for id: ${vdom.componentId}`)
            }

            vdom = component.vdom
        }

        return vdom
    }

    /**
     * Insert a given nodeToInsert after a targetNode inside a given vdom tree
     * @param {Object} vdom The vdom tree containing the targetNode
     * @param {Object} nodeToInsert The new vdom to insert
     * @param {Object|String} targetNodeId Either a vdom node or a vdom node id
     * @returns {Boolean}
     */
    static insertAfterNode(vdom, nodeToInsert, targetNodeId) {
        return VDom.insertNode(vdom, nodeToInsert, targetNodeId, false)
    }

    /**
     * Insert a given nodeToInsert before a targetNode inside a given vdom tree
     * @param {Object} vdom The vdom tree containing the targetNode
     * @param {Object} nodeToInsert The new vdom to insert
     * @param {Object|String} targetNodeId Either a vdom node or a vdom node id
     * @returns {Boolean}
     */
    static insertBeforeNode(vdom, nodeToInsert, targetNodeId) {
        return VDom.insertNode(vdom, nodeToInsert, targetNodeId, true)
    }

    /**
     * Insert a given nodeToInsert before a targetNode inside a given vdom tree
     * @param {Object} vdom The vdom tree containing the targetNode
     * @param {Object} nodeToInsert The new vdom to insert
     * @param {Object|String} targetNodeId Either a vdom node or a vdom node id
     * @param {Boolean} insertBefore true inserts the new node at the same index, index+1 otherwise
     * @returns {Boolean}
     */
    static insertNode(vdom, nodeToInsert, targetNodeId, insertBefore) {
        if (Neo.isObject(targetNodeId)) {
            targetNodeId = targetNodeId.id
        }

        let targetNode = VDom.find(vdom, targetNodeId),
            index;

        if (targetNode) {
            index = insertBefore ? targetNode.index : targetNode.index + 1;
            targetNode.parentNode.cn.splice(index, 0, nodeToInsert);
            return true
        }

        return false
    }

    /**
     * Search vdom child nodes by id or opts object for a given vdom tree
     * @param {Object} [vdom]
     * @param {Object|String} opts Either an object containing vdom node attributes or a string based id
     * @returns {Boolean} true in case the node was found & removed
     */
    static removeVdomChild(vdom, opts) {
        let child = VDom.find(vdom, opts);

        if (child) {
            child.parentNode.cn.splice(child.index, 1);
            return true
        }

        return false
    }

    /**
     * Replaces a child node inside a vdom tree by a given id
     * @param {Object} vdom
     * @param {String} id
     * @param {Object} newChildNode
     * @returns {Boolean} true in case the node was found and replaced
     */
    static replaceVdomChild(vdom, id, newChildNode) {
        vdom = VDom.getVdom(vdom);

        let cn  = vdom.cn || [],
            i   = 0,
            len = cn.length,
            childNode;

        if (vdom.id === id) {
            throw new Error('replaceVdomChild: target id matches the root vnode id: ' + id)
        }

        for (; i < len; i++) {
            childNode = cn[i];

            if (childNode.id === id) {
                cn[i] = newChildNode;
                return true
            }

            if (VDom.replaceVdomChild(childNode, id, newChildNode)) {
                return true
            }
        }

        return false;
    }

    /**
     * Synchronizes state between the live VDOM (blueprint) and the incoming VNode (worker response).
     *
     * 1. **ID Synchronization (VNode -> VDOM):**
     *    `Neo.vdom.Helper` automatically assigns dynamic IDs to any VNode that lacks one, as the
     *    delta update engine requires unique IDs to target DOM nodes. These generated IDs are
     *    synced back into the VDOM to ensure stability and persistent referencing for future updates.
     *
     * 2. **Scroll State Synchronization (Bidirectional):**
     *    - **Preservation (VDOM -> VNode):** Ensures that the latest scroll position captured on the
     *      Main Thread (stored in VDOM) overrides potentially stale state returning from the Worker.
     *    - **Rehydration (VNode -> VDOM):** Ensures that new VDOM trees (e.g., from Functional Components)
     *      inherit the persistent scroll state from the existing VNode.
     *
     * @param {Neo.vdom.VNode} vnode
     * @param {Object} vdom
     * @param {Boolean} force=false The force param will enforce overwriting different ids
     */
    static syncVdomState(vnode, vdom, force=false) {
        if (vnode && vdom) {
            vdom = VDom.getVdom(vdom);

            let childNodes = vdom.cn,
                cn, i, len;

            // Preservation (vdom -> vnode)
            // Used by Classic Components (vdom is source of truth via capture)
            if (Neo.isNumber(vdom.scrollTop)) {
                vnode.scrollTop = vdom.scrollTop
            }
            if (Neo.isNumber(vdom.scrollLeft)) {
                vnode.scrollLeft = vdom.scrollLeft
            }

            if (childNodes) {
                cn  = childNodes.map(item => VDom.getVdom(item));
                // The vnode.childNodes array is already filtered by the worker.
                // We must filter the component's vdom.cn array identically to ensure
                // both arrays are structurally aligned for the sync loop.
                // The boolean check `item &&` is critical to remove falsy values
                // from conditional rendering and prevent runtime errors.
                cn  = cn.filter(item => item && item.removeDom !== true);
                i   = 0;
                len = cn?.length || 0;

                if (vnode.childNodes && vnode.childNodes.length !== len) {
                    return
                }

                for (; i < len; i++) {
                    if (vnode.childNodes) {
                        VDom.syncVdomState(vnode.childNodes[i], cn[i], force)
                    }
                }
            }
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(VDom));


/***/ },

/***/ "./src/util/VNode.mjs"
/*!****************************!*\
  !*** ./src/util/VNode.mjs ***!
  \****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../manager/Component.mjs */ "./src/manager/Component.mjs");



/**
 * @class Neo.util.VNode
 * @extends Neo.core.Base
 */
class VNode extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.VNode'
         * @protected
         */
        className: 'Neo.util.VNode'
    }

    /**
     * Search vnode child nodes by id or opts object for a given vdom tree
     * @param {Object} vnode
     * @param {Object|String} opts Either an object containing vdom node attributes or a string based id
     * @param {Number} [index] Internal flag, do not use it
     * @param {Object} [parentNode] Internal flag, do not use it
     * @returns {Object}
     *     {Number} index
     *     {String} parentId
     *     {Object} vnode
     */
    static find(vnode, opts, index, parentNode) {
        vnode = VNode.getVnode(vnode);

        index = index || 0;
        opts  = typeof opts !== 'string' ? opts : {id: opts};

        let attrMatch  = true,
            matchArray = [],
            styleMatch = true,
            i          = 0,
            len        = vnode.childNodes?.length || 0,
            optsArray, optsLength, subChild;

        optsArray  = Object.entries(opts);
        optsLength = optsArray.length;

        optsArray.forEach(([key, value]) => {
            if (vnode.hasOwnProperty(key)) {
                switch (key) {
                    case 'attributes':
                        if (Neo.isObject(value) && Neo.isObject(vnode[key])) {
                            Object.entries(value).forEach(([attrKey, attrValue]) => {
                                if (!(vnode[key].hasOwnProperty(attrKey) && vnode[key][attrKey] === attrValue)) {
                                    attrMatch = false
                                }
                            });

                            if (attrMatch) {
                                matchArray.push(true)
                            }
                        }
                        break
                    case 'className':
                        if (typeof value === 'string' && Neo.isArray(vnode[key])) {
                            if (vnode[key].includes(value)) {
                                matchArray.push(true)
                            }
                        } else if (typeof value === 'string' && typeof vnode[key] === 'string') {
                            if (vnode[key] === value) {
                                matchArray.push(true)
                            }
                        } else if (Neo.isArray(value) && Neo.isArray(vnode[key])) {
                            // todo: either search the vnode array for all keys or compare if the arrays are equal.
                            throw new Error('find: cls matching not supported for target & source types of Arrays')
                        }
                        break
                    case 'style':
                        if (Neo.isObject(value) && Neo.isObject(vnode[key])) {
                            Object.entries(value).forEach(([styleKey, styleValue]) => {
                                if (!(vnode[key].hasOwnProperty(styleKey) && vnode[key][styleKey] === styleValue)) {
                                    styleMatch = false
                                }
                            });

                            if (styleMatch) {
                                matchArray.push(true)
                            }
                        }
                        break
                    default:
                        if (vnode[key] === value) {
                            matchArray.push(true)
                        }
                        break
                }
            }
        });

        if (matchArray.length === optsLength) {
            return {index, parentNode, vnode}
        }

        for (; i < len; i++) {
            subChild = VNode.find(vnode.childNodes[i], opts, i, vnode);

            if (subChild) {
                return subChild
            }
        }

        return null
    }

    /**
     * Finds a child vnode inside a vnode tree by a given id
     * @param {Object} vnode
     * @param {String|null} id
     * @returns {Object|null} child vnode or null
     */
    static getById(vnode, id) {
        vnode = VNode.getVnode(vnode);

        if (!vnode) {
            return null
        }

        let childNodes = vnode.childNodes || [],
            i          = 0,
            len        = childNodes.length,
            childNode;

        if (vnode.id === id) {
            return vnode
        }

        for (; i < len; i++) {
            childNode = VNode.getVnode(childNodes[i]);

            if (childNode) {
                if (childNode.id === id) {
                    return childNode
                }

                childNode = VNode.getById(childNode, id);

                if (childNode) {
                    return childNode
                }
            }
        }

        return null
    }

    /**
     * Get the ids of all child nodes of the given vnode, excluding component references
     * @param {Object} vnode
     * @param {String[]} childIds=[]
     * @returns {String[]} childIds
     */
    static getChildIds(vnode, childIds=[]) {
        vnode?.childNodes?.forEach(childNode => {
            if (childNode.id && !childNode.componentId) {
                childIds.push(childNode.id)
            }

            VNode.getChildIds(childNode, childIds)
        });

        return childIds
    }

    /**
     * Convenience shortcut using manager.Component to replace vnode references if needed
     * @param {Object} vnode
     * @returns {Object}
     */
    static getVnode(vnode) {
        if (vnode?.componentId) {
            const component = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].get(vnode.componentId);

            if (!component) {
                throw new Error(`util.VNode.getVnode: Component not found for id: ${vnode.componentId}`)
            }

            vnode = component.vnode
        }

        return vnode
    }

    /**
     * Removes a child vnode inside a vnode tree by a given id
     * @param {Object} vnode
     * @param {String} id
     * @returns {Boolean} true in case the node was found and removed
     */
    static removeChildVnode(vnode, id) {
        vnode = VNode.getVnode(vnode);

        let childNodes = vnode.childNodes || [],
            i          = 0,
            len        = childNodes.length,
            childNode;

        if (vnode.id === id) {
            throw new Error('removeChildVnode: target id matches the root vnode id: ' + id)
        }

        for (; i < len; i++) {
            childNode = VNode.getVnode(childNodes[i]);

            if (childNode.id === id) {
                childNodes.splice(i, 1);
                return true
            }

            if (VNode.removeChildVnode(childNode, id)) {
                return true
            }
        }

        return false
    }

    /**
     * Replaces a child vnode inside a vnode tree by a given id
     * @param {Object} vnode
     * @param {String} id
     * @param {Object} newChildVnode
     * @returns {Boolean} true in case the node was found and replaced
     */
    static replaceChildVnode(vnode, id, newChildVnode) {
        vnode = VNode.getVnode(vnode);

        let childNodes = vnode.childNodes || [],
            i          = 0,
            len        = childNodes.length,
            childNode;

        if (vnode.id === id) {
            throw new Error('replaceChildVnode: target id matches the root vnode id: ' + id)
        }

        for (; i < len; i++) {
            childNode = VNode.getVnode(childNodes[i]);

            if (childNode.id === id) {
                childNodes[i] = newChildVnode;
                return true
            }

            if (VNode.replaceChildVnode(childNode, id, newChildVnode)) {
                return true
            }
        }

        return false
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(VNode));


/***/ },

/***/ "./src/util/vdom/TreeBuilder.mjs"
/*!***************************************!*\
  !*** ./src/util/vdom/TreeBuilder.mjs ***!
  \***************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../manager/Component.mjs */ "./src/manager/Component.mjs");



/**
 * A singleton utility class responsible for recursively building VDOM and VNode trees.
 * It can expand component references within a tree structure into their full VDOM/VNode representations,
 * supporting selective (asymmetric) tree expansion for optimized updates.
 * @class Neo.util.vdom.TreeBuilder
 * @extends Neo.core.Base
 * @singleton
 */
class TreeBuilder extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.vdom.TreeBuilder'
         * @protected
         */
        className: 'Neo.util.vdom.TreeBuilder',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * Private helper to recursively build a tree, abstracting the child node key.
     * @param {Object} node The vdom or vnode to process.
     * @param {Number} depth The current recursion depth.
     * @param {Set<String>|null} mergedChildIds A set of component IDs to selectively expand.
     * @param {String} childKey The property name for child nodes ('cn' or 'childNodes').
     * @returns {Object}
     * @private
     */
    #buildTree(node, depth, mergedChildIds, childKey) {
        // We can not use Neo.isObject() here, since inside unit-test scenarios, we will import vdom.Helper into main threads.
        // Inside this scenario, Neo.isObject() returns false for VNode instances
        if (typeof node !== 'object' || node === null) {
            return node
        }

        // JIT ID Generation (App Authority)
        // If we are processing a VDOM tree (childKey === 'cn') and the node has no ID,
        // we must generate one now to ensure deterministic identity before the VDOM leaves the App Worker.
        if (childKey === 'cn' && !node.id) {
            node.id = Neo.getId(node.vtype === 'text' ? 'vtext' : 'vnode')
        }

        let output = {...node}; // Shallow copy

        if (node[childKey]) {
            output[childKey] = [];

            for (let i = 0, len = node[childKey].length; i < len; i++) {
                let item        = node[childKey][i],
                    currentItem = item,
                    childDepth;

                if (currentItem.componentId) {
                    const component = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].get(currentItem.componentId);

                    // Sparse Tree Generation & Scoped Updates
                    // We prune the branch (send a placeholder) if:
                    // 1. We are at the depth boundary (depth === 1) AND it's not a merged update.
                    // 2. We are in a Merged Update (mergedChildIds exists) AND this component is not in the AllowList (not dirty/bridge).
                    // Exception: We never prune if depth is -1 (Full Tree) or if the component is not mounted yet.
                    if (depth !== -1 && component?.vnode) {
                        const isExpandable = mergedChildIds?.has(currentItem.componentId);

                        if ((depth === 1 && !isExpandable) || (mergedChildIds && !isExpandable)) {
                            output[childKey].push({...currentItem, neoIgnore: true});
                            continue // Stop processing this branch, move to next item
                        }
                    }

                    // Expand the branch if it's part of a merged update, or if the depth requires it, OR if the vnode is missing
                    if (depth > 1 || depth === -1 || mergedChildIds?.has(currentItem.componentId) || !component?.vnode) {
                        // Use the correct tree type based on the childKey
                        const componentTree = childKey === 'cn' ? component?.vdom : component?.vnode;
                        if (componentTree) {
                            currentItem = componentTree
                        }
                    }
                }

                if (item.componentId) {
                    childDepth = (depth === -1) ? -1 : Math.max(0, depth - 1)
                } else {
                    childDepth = depth
                }

                output[childKey].push(this.#buildTree(currentItem, childDepth, mergedChildIds, childKey))
            }
        }

        return output
    }


    /**
     * Copies a given vdom tree and replaces child component references with their vdom.
     * @param {Object} vdom
     * @param {Number} [depth=-1]
     * @param {Set<String>|null} [mergedChildIds=null]
     * @returns {Object}
     */
    getVdomTree(vdom, depth=-1, mergedChildIds=null) {
        return this.#buildTree(vdom, depth, mergedChildIds, 'cn')
    }

    /**
     * Copies a given vnode tree and replaces child component references with their vnode.
     * @param {Object} vnode
     * @param {Number} [depth=-1]
     * @param {Set<String>|null} [mergedChildIds=null]
     * @returns {Object}
     */
    getVnodeTree(vnode, depth=-1, mergedChildIds=null) {
        return this.#buildTree(vnode, depth, mergedChildIds, 'childNodes')
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TreeBuilder));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2NhbnZhcy92ZW5kb3JzLWV4YW1wbGVzX2NvbXBvbmVudF9jYW52YXNfTWFpbkNvbnRhaW5lcl9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFrRDtBQUNHO0FBQ0M7QUFDRztBQUNMOztBQUVwRDtBQUNBO0FBQ0EsS0FBSyxrREFBa0Q7QUFDdkQsS0FBSyxpREFBaUQ7QUFDdEQsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxtRUFBUTtBQUM1QztBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVEsUUFBUTtBQUNwQztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQiwrREFBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0Q0FBNEM7QUFDakU7QUFDQSxTQUFTO0FBQ1Qsb0JBQW9CLGdFQUFLO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLDZCQUE2Qiw0REFBTTtBQUNuQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTs7QUFFYjtBQUNBLHdCQUF3QiwrREFBUztBQUNqQyx5QkFBeUIsMkJBQTJCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0EsNkJBQTZCLDREQUFNO0FBQ25DLDZCQUE2QixrRUFBVTtBQUN2Qyw4QkFBOEIsa0JBQWtCO0FBQ2hEO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsNkJBQTZCLDREQUFNO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLHFDQUFxQyxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeE9vQjtBQUNIO0FBQ0Y7QUFDRzs7QUFFdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0VBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixvRUFBUTtBQUMvQjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLFNBQVM7QUFDVCx5QkFBeUIsa0VBQVc7QUFDcEM7QUFDQTtBQUNBLHlCQUF5Qiw2Q0FBNkM7QUFDdEU7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtCQUFrQjtBQUMzQztBQUNBLFNBQVM7QUFDVCx5QkFBeUIsa0VBQVc7QUFDcEM7QUFDQTtBQUNBLHlCQUF5Qiw0Q0FBNEM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixpRUFBTTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSxpRUFBZSw2QkFBNkIsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMURNO0FBQ0o7QUFDUTs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkRBQVM7QUFDOUI7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGNBQWM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpRUFBWTtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQixpQkFBaUIsWUFBWSxHQUFHLDhCQUE4QjtBQUN2RyxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBLFNBQVM7QUFDVCxhQUFhLHVDQUF1QztBQUNwRCxhQUFhLHNDQUFzQztBQUNuRCxhQUFhLDBCQUEwQjtBQUN2QyxhQUFhO0FBQ2IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7OztBQUlBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCOztBQUVBLFFBQVEsdURBQVE7QUFDaEIsUUFBUSx1REFBUTs7QUFFaEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7O0FBRXhCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7O0FBRXZCLFFBQVEsdURBQVE7QUFDaEIsUUFBUSx1REFBUTs7QUFFaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTs7QUFFdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSx1REFBUTtBQUNoQixRQUFRLHVEQUFROztBQUVoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQyxlQUFlLHNCQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUtBQTBCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBLHFCQUFxQiwwQkFBMEI7O0FBRS9DO0FBQ0E7QUFDQSwwQ0FBMEMsa0NBQWtDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7QUFDNUM7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLHVEQUFRO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLFVBQVU7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQyxlQUFlLHNCQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7O0FBRXZCLFFBQVEsdURBQVE7QUFDaEIsUUFBUSx1REFBUTtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLFVBQVU7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDLGVBQWUsbUJBQW1CO0FBQ2xDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTs7QUFFQSwyREFBMkQ7QUFDM0Q7QUFDQSwwQkFBMEIsU0FBUztBQUNuQywwQkFBMEIsd0NBQXdDO0FBQ2xFLDBCQUEwQix3Q0FBd0M7QUFDbEUsMEJBQTBCLFNBQVM7QUFDbkMsU0FBUzs7QUFFVDtBQUNBOztBQUVBOztBQUVBLDZDQUE2QyxxQkFBcUI7QUFDbEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxzQkFBc0IsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOXBCVTtBQUNPO0FBQ0M7QUFDRjtBQUNBO0FBQ0k7QUFDRDtBQUNSO0FBQ1E7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNEQUFJO0FBQzNCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhLE9BQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpRUFBWTtBQUN6QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQSxpQkFBaUIsNERBQVMsRUFBRSw0REFBVSxFQUFFLGdFQUFhO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYSxpQkFBaUI7QUFDbEQscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUVBQVk7QUFDekI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQiw4REFBZ0I7QUFDcEMsb0JBQW9CLDhEQUFnQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtEQUFVO0FBQzFCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYyxPQUFPO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxRQUFRLDhEQUFnQjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxnQ0FBZ0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBOztBQUVBLG1CQUFtQiw2REFBZTtBQUNsQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDhEQUFnQjtBQUN4QixtQ0FBbUM7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsdURBQVM7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSx3QkFBd0IsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuZ0JNO0FBQ1M7QUFDQztBQUNDO0FBQ1A7QUFDRDtBQUNJO0FBQ0o7QUFDRDtBQUNDO0FBQ1E7O0FBRXpEO0FBQ0EsbUZBQW1GLE1BQU07QUFDekY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFEQUFRO0FBQ2hDO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZSxRQUFRLDZDQUE2QztBQUN4RjtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtFQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlDQUFpQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVEsT0FBTztBQUNuQztBQUNBO0FBQ0EsYUFBYSxrRUFBWTtBQUN6QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhLGVBQWU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrRUFBWTtBQUN6QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsYUFBYSxLQUFLOztBQUVsQixRQUFRLHVEQUFRO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUMsdUJBQXVCO0FBQ2hFO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxhQUFhLFlBQVk7O0FBRXpCLFFBQVEsdURBQVE7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0Esa0JBQWtCLHVEQUFRO0FBQzFCLFlBQVksdURBQVEsYUFBYSx1REFBUTtBQUN6QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSx1REFBUTtBQUNoQjtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLHdMQUFtQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLFVBQVU7QUFDbEMsaUNBQWlDLDJCQUEyQjtBQUM1RDs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFlBQVksdURBQVE7QUFDcEIsb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDRMQUF5QztBQUN6RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUscUJBQXFCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsV0FBVztBQUM1Qjs7QUFFQTtBQUNBLGdCQUFnQix1REFBUTtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsdURBQVE7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGdCQUFnQiw4S0FBNkI7QUFDN0M7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksdURBQVEsb0JBQW9CLFNBQVMsR0FBRyxTQUFTO0FBQzdEOztBQUVBO0FBQ0EsWUFBWSx1REFBUSxpQkFBaUIsU0FBUyxHQUFHLE1BQU07QUFDdkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLHVEQUFRO0FBQzFCLFlBQVksdURBQVEsYUFBYSx1REFBUTtBQUN6QztBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBLHdCQUF3Qix1REFBUTtBQUNoQyxZQUFZLHVEQUFROztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNDQUFzQztBQUN0RDs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdURBQVE7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQ0FBaUM7QUFDaEQsZUFBZSwrQkFBK0I7QUFDOUMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLDZEQUFlO0FBQ2xDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEMsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQiw2REFBZSwwQkFBMEIsK0RBQWE7QUFDMUU7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDZEQUFlO0FBQzlDO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGlDQUFpQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjs7QUFFQTs7QUFFQSw4QkFBOEI7O0FBRTlCLGlFQUFpRTs7QUFFakU7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLDhDQUE4QyxxQ0FBcUM7QUFDbkYsY0FBYztBQUNkOztBQUVBLGdCQUFnQixzREFBUTtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBO0FBQ0EsZUFBZSw4REFBZ0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQSxrQ0FBa0MscURBQXFEO0FBQ3ZGOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLCtFQUErRSxhQUFhOztBQUU1RjtBQUNBLHNDQUFzQywyREFBUztBQUMvQzs7QUFFQSxlQUFlLDJEQUFTO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGVBQWUsOERBQWdCO0FBQy9COztBQUVBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDBCQUEwQixzREFBUTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxxQkFBcUIsY0FBYztBQUNuQyxvRUFBb0Usb0JBQW9CO0FBQ3hGLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLDZCQUE2Qjs7QUFFN0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwyQkFBMkIsc0RBQVE7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLHVEQUFRO0FBQ2hCO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7O0FBRUEsUUFBUSx1REFBUTtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMkJBQTJCO0FBQzNCOztBQUVBLHNDQUFzQyxxQ0FBcUM7QUFDM0U7O0FBRUE7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ0E7QUFDQSxlQUFlLDhEQUFnQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLGlCQUFpQjtBQUNoQyxpQkFBaUI7QUFDakI7QUFDQSwwQkFBMEIsMkRBQTJELElBQUk7QUFDekY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QywwQ0FBMEM7QUFDdEY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQjs7QUFFQSxpRUFBZSx5QkFBeUIsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQzd0RE47O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlEQUFTO0FBQzlCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVEsT0FBTztBQUNuQztBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLHFCQUFxQjs7QUFFbEM7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQSxrQ0FBa0Msd0JBQXdCO0FBQzFEO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLHNCQUFzQixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDNUtIOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlEQUFTO0FBQzdCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLHFCQUFxQixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaENjO0FBQ0g7QUFDQTtBQUNEO0FBQ0M7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNROztBQUV2RCxvQkFBb0Isa0JBQWtCLElBQUksa0JBQWtCOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyREFBUztBQUNqQztBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpRUFBWTtBQUN6QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlFQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0JBQW9CLG9CQUFvQixTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsdUNBQXVDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRLE9BQU87QUFDbkM7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQyxlQUFlLHNCQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsT0FBTyxTQUFTLFFBQVEsU0FBUyxZQUFZO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7O0FBRUEsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDLGVBQWUsaUJBQWlCO0FBQ2hDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsK0JBQStCO0FBQzlDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLDJCQUEyQjtBQUM1QztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0ZBQWdGO0FBQ3hHLHdCQUF3QixtQkFBbUI7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLDJEQUFTO0FBQzNDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiw2REFBNkQsR0FBRyxnQkFBZ0I7QUFDaEY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLDJEQUFTO0FBQ3JDLDZCQUE2QixXQUFXO0FBQ3hDO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0Qjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLGlCQUFpQjtBQUNsRDs7QUFFQTtBQUNBLGVBQWUsK0JBQStCO0FBQzlDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHVCQUF1Qjs7QUFFeEMsaUNBQWlDLHdEQUFVO0FBQzNDLHNDQUFzQyxtQ0FBbUM7QUFDekUsY0FBYztBQUNkO0FBQ0Esc0NBQXNDLG1DQUFtQztBQUN6RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSwyQkFBMkI7QUFDMUMsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsaUNBQWlDO0FBQ2hELGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQSxtQ0FBbUMsWUFBWTtBQUMvQyxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUSxnQkFBZ0I7QUFDdkMsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBLHFCQUFxQixVQUFVLE1BQU07QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxlQUFlLHlTQUE2QztBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzREFBc0Qsd0RBQVU7QUFDaEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsYUFBYTtBQUN0RDtBQUNBLFVBQVU7QUFDVjtBQUNBLHlFQUF5RSxPQUFPO0FBQ2hGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLHVEQUFRO0FBQ2hCLFFBQVEsdURBQVE7O0FBRWhCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSx5QkFBeUIsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqK0JOO0FBQ1M7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaURBQVM7QUFDN0I7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUSxPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsaUVBQWlFLCtDQUErQztBQUNoSCxpRUFBaUUsNkNBQTZDO0FBQzlHLGlFQUFpRSxnREFBZ0Q7QUFDakgsaUVBQWlFLDhDQUE4QztBQUMvRztBQUNBO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsZ0NBQWdDOztBQUV0RTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0RBQWdEO0FBQ2hGO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxnQ0FBZ0M7QUFDcEU7O0FBRUE7QUFDQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUscUJBQXFCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoTUY7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlEQUFTO0FBQ2hDO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsaUNBQWlDLGtDQUFrQztBQUNuRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxVQUFVOztBQUV2QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSx3QkFBd0IsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hGaUI7QUFDRDtBQUNHO0FBQ1A7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkRBQVM7QUFDN0I7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixHQUFHO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBLFFBQVEsa0VBQWM7QUFDdEI7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBLGFBQWEsS0FBSzs7QUFFbEIsUUFBUSx1REFBUTtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsR0FBRztBQUNsQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxRQUFRLDhEQUFnQjtBQUN4QjtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxpQ0FBaUM7QUFDaEQsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsWUFBWSw4REFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixlQUFlLEdBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixlQUFlLEdBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qiw4REFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLDhEQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsYUFBYTtBQUNiOztBQUVBLGlFQUFlLHFCQUFxQixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2YXNCO0FBQ2pCO0FBQ1U7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlEQUFLO0FBQzVCO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQSx3RkFBd0YsVUFBVTtBQUNsRztBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixHQUFHO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCw2QkFBNkI7QUFDOUU7QUFDQSxvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBLFNBQVM7QUFDVCxhQUFhO0FBQ2IsaUJBQWlCLHNCQUFzQjtBQUN2QyxpQkFBaUIsMENBQTBDO0FBQzNELGlCQUFpQix5Q0FBeUM7QUFDMUQsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZCxhQUFhO0FBQ2IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7O0FBRXZCOztBQUVBLFFBQVEsdURBQVE7O0FBRWhCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLHVEQUFROztBQUVoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLHVEQUFRO0FBQ2hCLFFBQVEsdURBQVE7O0FBRWhCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7O0FBRWxCLFFBQVEsdURBQVE7QUFDaEIsUUFBUSx1REFBUTtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLHdCQUF3QjtBQUN2QyxlQUFlLHdCQUF3QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWEsOERBQThELFlBQVk7O0FBRXZGO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCLFFBQVEsdURBQVE7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLDZCQUE2QjtBQUM1QyxlQUFlLDZCQUE2QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVEQUFRO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsOERBQWdCLE9BQU8sS0FBSzs7QUFFakQ7QUFDQTtBQUNBLG9CQUFvQix1REFBUTtBQUM1QjtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdGQUF3RixRQUFROztBQUVoRzs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTs7QUFFQTtBQUNBLCtCQUErQjs7QUFFL0IsWUFBWSx1REFBUTtBQUNwQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLDhEQUFnQjtBQUN6QztBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0hBQW9ILEtBQUs7QUFDekg7QUFDQTs7QUFFQTtBQUNBLHVEQUF1RCxLQUFLO0FBQzVEO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLHdCQUF3QixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeHZCZTtBQUNGO0FBQ0k7QUFDZDs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpREFBSTtBQUN6QjtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVSxnREFBZ0QsWUFBWSxJQUFJLGNBQWM7QUFDNUc7QUFDQSwyREFBMkQsWUFBWSxJQUFJLGNBQWM7QUFDekY7QUFDQTtBQUNBLG9CQUFvQixVQUFVLGdEQUFnRCxZQUFZLElBQUksY0FBYztBQUM1RztBQUNBLDJEQUEyRCxZQUFZLElBQUksY0FBYztBQUN6RjtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0EsMkRBQTJELFlBQVksSUFBSSxjQUFjO0FBQ3pGO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYSwyQkFBMkI7QUFDeEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87O0FBRXBCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywrREFBaUI7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGtDQUFrQyw2REFBZTtBQUNqRDs7QUFFQTtBQUNBLGtDQUFrQywyREFBYTtBQUMvQzs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFDQUFxQztBQUNsRDtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsc0JBQXNCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwY1E7QUFDQztBQUNUO0FBQ1U7QUFDQztBQUNGO0FBQ0M7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlEQUFLO0FBQ3hCO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVSx3REFBd0Qsa0JBQWtCO0FBQ3hHO0FBQ0EsbUVBQW1FLGtCQUFrQjtBQUNyRjtBQUNBO0FBQ0Esb0JBQW9CLFVBQVUsa0RBQWtELGFBQWEsSUFBSSxVQUFVO0FBQzNHO0FBQ0EsNkRBQTZELGtCQUFrQixJQUFJLGVBQWU7QUFDbEc7QUFDQTtBQUNBLG9CQUFvQixVQUFVLGtEQUFrRCxrQkFBa0IsSUFBSSxlQUFlO0FBQ3JIO0FBQ0EsNkRBQTZELGtCQUFrQixJQUFJLGVBQWU7QUFDbEc7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBLFNBQVM7QUFDVCxhQUFhLGlDQUFpQztBQUM5QyxhQUFhLHNCQUFzQjtBQUNuQyxhQUFhLDhFQUE4RTtBQUMzRixhQUFhO0FBQ2IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWEsNkNBQTZDO0FBQzFELGFBQWEsNkNBQTZDO0FBQzFELGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIsMERBQVk7QUFDekM7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7O0FBRWxCLFFBQVEsdURBQVE7QUFDaEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNEQUFRLGdCQUFnQiwyQkFBMkI7O0FBRXJFLFFBQVEsdURBQVE7O0FBRWhCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLOztBQUVsQjs7QUFFQSw0QkFBNEIsdURBQVE7O0FBRXBDLFFBQVEsdURBQVE7QUFDaEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsdURBQVE7QUFDaEIsUUFBUSx1REFBUTs7QUFFaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCOztBQUVBOztBQUVBLFFBQVEsdURBQVE7QUFDaEIsUUFBUSx1REFBUTtBQUNoQixzQkFBc0I7O0FBRXRCO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSx3QkFBd0I7QUFDdkMsZUFBZSx3QkFBd0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWEsOERBQThELFlBQVk7O0FBRXZGO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLOztBQUVsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVEQUFRO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSzs7QUFFbEIsUUFBUSx1REFBUTtBQUNoQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUM7O0FBRXJDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLOztBQUVsQixRQUFRLHVEQUFRO0FBQ2hCLFFBQVEsdURBQVE7O0FBRWhCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGFBQWE7O0FBRWIsOERBQThEO0FBQzlELDhEQUE4RDs7QUFFOUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHVCQUF1Qjs7QUFFdkI7QUFDQSxRQUFRLHVEQUFRO0FBQ2hCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVEQUFRO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVEQUFRO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLGFBQWEsbUJBQW1COztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixjQUFjLDJCQUEyQix5REFBVztBQUNwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxlQUFlLHNEQUFRLGtCQUFrQix5QkFBeUI7QUFDbEU7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGVBQWUsc0RBQVEsa0JBQWtCLHVCQUF1QjtBQUNoRTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7O0FBRXhCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsZUFBZSxzREFBUSxrQkFBa0IsYUFBYTtBQUN0RDs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyx3REFBVTtBQUM3Qzs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLEtBQUs7O0FBRWxCO0FBQ0EsWUFBWSx1REFBUTtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCLFlBQVksdURBQVE7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLG1CQUFtQixFQUFFLHVEQUFTLGlCQUFpQixrQkFBa0I7O0FBRWhGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyREFBMkQ7O0FBRTNEO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLOztBQUVsQjtBQUNBLFlBQVksdURBQVE7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSzs7QUFFbEI7QUFDQSxZQUFZLHVEQUFRO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLFNBQVM7QUFDeEI7O0FBRUE7QUFDQSxnQkFBZ0IsdURBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCOztBQUVBO0FBQ0EsWUFBWSx1REFBUTtBQUNwQjs7QUFFQSwyQkFBMkIsc0RBQVEsZ0JBQWdCLG1DQUFtQztBQUN0Rjs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFEQUFxRDtBQUNsRTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0RBQWdEO0FBQzNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsb0JBQW9CLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOXFEZ0I7QUFDSjs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyREFBUztBQUM1QjtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQix1Q0FBdUM7QUFDNUQscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSx1REFBUTtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQzs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87O0FBRXBCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7O0FBRWxCLFFBQVEsdURBQVE7O0FBRWhCO0FBQ0EsWUFBWSx1REFBUTtBQUNwQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsb0JBQW9CLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaE9GO0FBQ2E7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaURBQUk7QUFDeEI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7O0FBRWxCLFFBQVEsdURBQVE7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTzs7QUFFcEI7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxxQkFBcUIsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ2pKUDs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpREFBSTtBQUMzQjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsd0JBQXdCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3Q1Y7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaURBQUk7QUFDekI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxzQkFBc0IsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ3hDUjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpREFBSTtBQUM3QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsNkVBQTZFO0FBQzFGLGFBQWE7QUFDYjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsMEJBQTBCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckZGO0FBQ0M7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzREFBSTtBQUN6QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhLGFBQWE7O0FBRTFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEMsYUFBYSx5QkFBeUI7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksdURBQVE7O0FBRXBCLHNEQUFzRCxXQUFXO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHlCQUF5QjtBQUN0QyxhQUFhLHlCQUF5Qjs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSx1REFBUTs7QUFFcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWEsV0FBVzs7QUFFeEI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxzQkFBc0IsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqTko7QUFDTzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaURBQUk7QUFDdkI7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdDQUFnQztBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLHVEQUFRO0FBQzVCLG9CQUFvQix1REFBUTs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTs7QUFFMUIsUUFBUSx1REFBUTtBQUNoQixRQUFRLHVEQUFROztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBLGFBQWEsV0FBVztBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyxLQUFLOztBQUUzQztBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MsZ0JBQWdCO0FBQ2xELDZDQUE2QyxFQUFFO0FBQy9DLGtDQUFrQyxXQUFXO0FBQzdDO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0EsOEJBQThCLFlBQVk7QUFDMUMseUNBQXlDLEVBQUU7QUFDM0MsOEJBQThCLGVBQWU7QUFDN0M7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYixpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLDBCQUEwQiwyQkFBMkI7QUFDckQsMEJBQTBCLDJCQUEyQjs7QUFFckQ7O0FBRUEsK0JBQStCOztBQUUvQjs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxvQkFBb0IsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsVEY7QUFDTzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaURBQUk7QUFDdEI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHVEQUFRO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZOztBQUU3QixZQUFZLHVEQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLG1CQUFtQixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3RERDtBQUNPOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpREFBSTtBQUMxQjtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLGNBQWM7QUFDM0IsYUFBYSxjQUFjOztBQUUzQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLE1BQU07QUFDNUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQyxhQUFhLG1CQUFtQjs7QUFFaEM7QUFDQTtBQUNBOztBQUVBLFFBQVEsdURBQVE7O0FBRWhCLHdCQUF3Qix1REFBUTtBQUNoQyx3QkFBd0IsdURBQVE7QUFDaEMsd0JBQXdCLHVEQUFRO0FBQ2hDLHdCQUF3Qix1REFBUTs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QjtBQUNBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUI7QUFDQSxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQyxhQUFhLG1CQUFtQjs7QUFFaEM7QUFDQTtBQUNBOztBQUVBLFFBQVEsdURBQVE7O0FBRWhCLHdCQUF3Qix1REFBUTtBQUNoQyx3QkFBd0IsdURBQVE7QUFDaEMsd0JBQXdCLHVEQUFRO0FBQ2hDLHdCQUF3Qix1REFBUTs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBOztBQUVBLGFBQWEsdURBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEMsYUFBYSxtQkFBbUI7O0FBRWhDO0FBQ0EsWUFBWSx1REFBUTs7QUFFcEI7QUFDQSxnQkFBZ0IsdURBQVE7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsdUJBQXVCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdlVMO0FBQ087O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlEQUFJO0FBQ3ZCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLG9CQUFvQixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDNUJBOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9EQUFPO0FBQzFCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxvQkFBb0IsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ3RDQTs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvREFBTztBQUMxQjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsb0JBQW9CLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RDRDtBQUNNO0FBQ0M7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaURBQU87QUFDL0I7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMEJBQTBCO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsS0FBSztBQUNyQjtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpREFBaUQ7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQixXQUFXOztBQUU1QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0RBQVEsOEJBQThCLFlBQVk7O0FBRXhGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyQkFBMkI7QUFDMUMsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZUFBZSxTQUFTO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLFNBQVM7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQSxlQUFlLHVEQUFTO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQyxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix1REFBUztBQUN2Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDLGVBQWUsU0FBUztBQUN4QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsU0FBUztBQUN4Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLDJCQUEyQjtBQUMxQyxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsR0FBRztBQUNsQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLGNBQWM7O0FBRTdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSwyQkFBMkI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixvQkFBb0I7O0FBRTNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLFNBQVM7QUFDeEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLHlCQUF5QixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN29CTztBQUNEO0FBQ0o7QUFDTztBQUNEO0FBQ0Q7QUFDQzs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzREFBSTtBQUMzQjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsa0RBQWtEO0FBQ25GOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLGFBQWEsV0FBVzs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNEQUFnQjtBQUMxQztBQUNBOztBQUVBLGVBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixrREFBWTtBQUM1QjtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw0QkFBNEI7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRO0FBQXdDOztBQUVoRCxRQUFRO0FBRUM7QUFDVDs7QUFFQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLFNBQVM7QUFDeEM7QUFDQSxnQ0FBZ0MsdURBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsVUFBVTtBQUNWLFlBQVksd0RBQU07QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsYUFBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsYUFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsc0RBQVE7O0FBRXJDO0FBQ0E7QUFDQSwwREFBMEQsc0RBQVE7QUFDbEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSx3QkFBd0IsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxckJBO0FBQ0M7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0RBQVE7QUFDNUI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQSwrQkFBK0IsdURBQVE7QUFDdkMsK0JBQStCLHVEQUFRO0FBQ3ZDLCtCQUErQix1REFBUTtBQUN2Qzs7QUFFQSw4QkFBOEIsMkNBQTJDO0FBQ3pFLDhCQUE4QiwyQ0FBMkM7O0FBRXpFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLGlFQUFlLHFCQUFxQixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDeE1XOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDREQUFVO0FBQ25DO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpREFBaUQsMkJBQTJCLEdBQUc7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxQ0FBcUMsaUJBQWlCLEdBQUc7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQ0FBbUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVCQUF1QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMkNBQTJDLDREQUFVLEdBQUcsdUJBQXVCO0FBQy9FLDJDQUEyQyw0REFBVSxHQUFHLHVCQUF1QjtBQUMvRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLGtCQUFrQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvREFBb0QsU0FBUztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdEQUFnRCxTQUFTO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUEsb0NBQW9DLDJCQUEyQjtBQUMvRDs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQSw0QkFBNEIsaUJBQWlCO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0QsU0FBUztBQUNqRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLDBCQUEwQixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQzljSztBQUNPOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzREFBSTtBQUM1QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1Q0FBdUM7QUFDL0Qsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLDZEQUFlO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDLGVBQWUsVUFBVTtBQUN6QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2REFBZTtBQUMvQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDZEQUFlO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUseUJBQXlCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1SU87QUFDUTtBQUNJO0FBQ1o7QUFDUztBQUNSO0FBQ1E7O0FBRXpELE9BQU8sZUFBZTs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0RBQUk7QUFDaEM7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVEsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUVBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRDQUE0QztBQUM5RDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbUJBQW1CO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsK0RBQVU7O0FBRTdCO0FBQ0E7QUFDQSxRQUFRLCtEQUFVOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLHFEQUFxRDs7QUFFckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDLCtEQUFVOztBQUVqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZLCtEQUFVO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxTQUFTO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQyxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQSx1QkFBdUIsa0VBQVc7QUFDbEMsdUJBQXVCLGtFQUFXO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGVBQWUsc0RBQVE7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELG1CQUFtQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixjQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsc0RBQXNEOztBQUVuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTyxXQUFXOztBQUUvQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQkFBZ0IsK0RBQVU7O0FBRTFCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrRUFBVztBQUM1QztBQUNBLGlCQUFpQjs7QUFFakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7O0FBRUEsWUFBWSwrREFBVTtBQUN0QiwrQkFBK0IsK0RBQVU7QUFDekM7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFlBQVksK0RBQVU7QUFDdEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QywrREFBVTs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLCtEQUFVO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0RBQVU7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSzs7QUFFbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMkJBQTJCLDhEQUFnQjtBQUMzQztBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLFNBQVM7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDBCQUEwQix3QkFBd0IsYUFBYTtBQUMvRCwwQkFBMEIsd0JBQXdCO0FBQ2xEO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxRQUFRLCtEQUFVOztBQUVsQjtBQUNBLFFBQVEsK0RBQVU7O0FBRWxCO0FBQ0EsUUFBUSwrREFBVTs7QUFFbEI7QUFDQSxRQUFRLCtEQUFVOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQSxRQUFRLHNEQUFRO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDhEQUFnQjtBQUM5QztBQUNBLGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxZQUFZLDhEQUFnQjtBQUM1Qjs7QUFFQTtBQUNBLHNEQUFzRCxTQUFTO0FBQy9EO0FBQ0EseUJBQXlCLHVEQUFTOztBQUVsQztBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLDhEQUFnQjtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0QsU0FBUztBQUMvRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsOERBQWdCOztBQUVuRDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2Qiw4REFBZ0I7QUFDN0MscURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx1REFBUztBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsOERBQWdCOztBQUU1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsMEJBQTBCO0FBQ3ZDLGFBQWEsMEJBQTBCOztBQUV2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLCtEQUFVOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU8sV0FBVztBQUMzQyxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsNkJBQTZCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDejdCRjtBQUNHO0FBQ0E7QUFDQztBQUNMOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyREFBUztBQUMvQjtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUSxjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0JBQW9CLFFBQVEsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsdURBQVE7QUFDcEMsU0FBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGdDQUFnQyxRQUFRLDJEQUFTLFdBQVc7QUFDNUQ7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSx1QkFBdUIsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ3hMSDs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0RBQUk7QUFDOUI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLDJCQUEyQjtBQUMxQyxlQUFlLHNCQUFzQjtBQUNyQyxlQUFlLFFBQVEsaUJBQWlCO0FBQ3hDLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0Esd0VBQXdFO0FBQ3hFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSwyQkFBMkIsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvREg7QUFDQzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0RBQUk7QUFDaEM7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxTQUFTO0FBQ3hCOztBQUVBO0FBQ0EsZ0JBQWdCLHVEQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLDZCQUE2QixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7QUN4TjdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFFBQVEsRUFBRSxvQkFBb0IsRUFBRSxrQkFBa0IsR0FBRyxVQUFVLEVBQUUsc0JBQXNCLEVBQUUsb0JBQW9COztBQUUvSCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWU7QUFDZjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7O0FBRUE7QUFDQTtBQUNBLGVBQWUsNEJBQTRCO0FBQzNDLGVBQWUsNEJBQTRCO0FBQzNDLGlCQUFpQix5QkFBeUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw4QkFBOEIsR0FBRyxnQkFBZ0I7QUFDcEYsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxtQ0FBbUMsOEJBQThCLEdBQUcsZ0JBQWdCO0FBQ3BGLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0EsdUNBQXVDLDhCQUE4QixHQUFHLGdCQUFnQjtBQUN4RixxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU8sTUFBTSxPQUFPO0FBQ3hELHFCQUFxQixZQUFZO0FBQ2pDLG9CQUFvQixXQUFXO0FBQy9CLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGVBQWUsb0VBQW9FO0FBQ25GLGdCQUFnQjtBQUNoQjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDOWtCb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNEQUFJO0FBQzdCO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQix1QkFBdUI7QUFDdkIscUJBQXFCO0FBQ3JCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0Esa0NBQWtDLE9BQU8sT0FBTyxTQUFTLFNBQVMsV0FBVyxTQUFTLFFBQVE7O0FBRTlGO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSwwQkFBMEIsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQy9GTjs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0RBQUk7QUFDeEI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLHFCQUFxQixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQzVEVztBQUNROztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzREFBSTtBQUN2QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGVBQWU7QUFDOUIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qzs7QUFFOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsV0FBVztBQUN2RCxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQSxnQ0FBZ0MsS0FBSztBQUNyQzs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsYUFBYTtBQUM1QixpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLFNBQVM7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLFNBQVM7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsOERBQWdCOztBQUU5QztBQUNBLGtGQUFrRixpQkFBaUI7QUFDbkc7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsZUFBZTtBQUM5QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxlQUFlO0FBQzlCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLGVBQWU7QUFDOUIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxlQUFlO0FBQzlCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGVBQWUsU0FBUztBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxvQkFBb0IsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxZFk7QUFDUTs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0RBQUk7QUFDeEI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxlQUFlO0FBQzlCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRDs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUEsZUFBZSxTQUFTO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGFBQWE7QUFDNUIsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxTQUFTO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDhEQUFnQjs7QUFFOUM7QUFDQSxvRkFBb0Ysa0JBQWtCO0FBQ3RHOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGVBQWUsU0FBUztBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGVBQWUsU0FBUztBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUscUJBQXFCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbFFjO0FBQ1E7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0RBQUk7QUFDOUI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxrQkFBa0I7QUFDakMsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsVUFBVTs7QUFFaEM7QUFDQTs7QUFFQSx5REFBeUQsU0FBUztBQUNsRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsOERBQWdCOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRCxnQ0FBZ0M7QUFDbkY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsa0JBQWtCO0FBQ2pDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLGtCQUFrQjtBQUNqQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSwyQkFBMkIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9leGFtcGxlcy9Db25maWd1cmF0aW9uVmlld3BvcnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9leGFtcGxlcy9jb21wb25lbnQvY2FudmFzL01haW5Db250YWluZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvYnV0dG9uL0Jhc2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29tcG9uZW50L0Fic3RyYWN0Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbXBvbmVudC9CYXNlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbXBvbmVudC9DYW52YXMubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29tcG9uZW50L0xhYmVsLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbnRhaW5lci9CYXNlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbnRhaW5lci9QYW5lbC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb250YWluZXIvVmlld3BvcnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZm9ybS9maWVsZC9CYXNlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2Zvcm0vZmllbGQvQ2hlY2tCb3gubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZm9ybS9maWVsZC9OdW1iZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZm9ybS9maWVsZC9UZXh0Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2Zvcm0vZmllbGQvdHJpZ2dlci9CYXNlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2Zvcm0vZmllbGQvdHJpZ2dlci9DbGVhci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9mb3JtL2ZpZWxkL3RyaWdnZXIvU3BpbkRvd24ubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZm9ybS9maWVsZC90cmlnZ2VyL1NwaW5VcC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9mb3JtL2ZpZWxkL3RyaWdnZXIvU3BpblVwRG93bi5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9sYXlvdXQvQmFzZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9sYXlvdXQvQ2FyZC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9sYXlvdXQvRml0Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2xheW91dC9GbGV4Ym94Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2xheW91dC9HcmlkLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2xheW91dC9IQm94Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2xheW91dC9WQm94Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL21hbmFnZXIvQ29tcG9uZW50Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL21hbmFnZXIvRG9tRXZlbnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvbWFuYWdlci9Gb2N1cy5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9tYW5hZ2VyL1ZEb21VcGRhdGUubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvbWl4aW4vRG9tRXZlbnRzLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL21peGluL1Zkb21MaWZlY3ljbGUubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdG9vbGJhci9CYXNlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3V0aWwvQ2xhc3NTeXN0ZW0ubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdXRpbC9LZXlOYXZpZ2F0aW9uLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3V0aWwvUmVjdGFuZ2xlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3V0aWwvU3RyaW5nLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3V0aWwvU3R5bGUubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdXRpbC9WRG9tLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3V0aWwvVk5vZGUubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdXRpbC92ZG9tL1RyZWVCdWlsZGVyLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQnV0dG9uICAgICAgIGZyb20gJy4uL3NyYy9idXR0b24vQmFzZS5tanMnO1xuaW1wb3J0IENvbnRhaW5lciAgICBmcm9tICcuLi9zcmMvY29udGFpbmVyL0Jhc2UubWpzJztcbmltcG9ydCBQYW5lbCAgICAgICAgZnJvbSAnLi4vc3JjL2NvbnRhaW5lci9QYW5lbC5tanMnO1xuaW1wb3J0IFZpZXdwb3J0ICAgICBmcm9tICcuLi9zcmMvY29udGFpbmVyL1ZpZXdwb3J0Lm1qcyc7XG5pbXBvcnQge2JpbmRBcHBlbmR9IGZyb20gJy4uL3NyYy91dGlsL0Z1bmN0aW9uLm1qcyc7XG5cbi8vIGFkZCBjdXN0b20gdGhlbWVzIGhlcmVcbmNvbnN0IHRoZW1lcyA9IFtcbiAgICB7bmFtZTogJ25lby10aGVtZS1saWdodCcsICAgICBsYWJlbDogJ1RoZW1lIExpZ2h0J30sXG4gICAge25hbWU6ICduZW8tdGhlbWUtZGFyaycsICAgICAgbGFiZWw6ICdUaGVtZSBEYXJrJ30sXG4gICAge25hbWU6ICduZW8tdGhlbWUtbmVvLWxpZ2h0JywgbGFiZWw6ICdUaGVtZSBOZW8tTGlnaHQnfVxuXVxuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGV4YW1wbGUgQXBwcyB3aGljaCBzaG91bGQgYmUgY29uZmlndXJhYmxlXG4gKiBAY2xhc3MgTmVvLmV4YW1wbGVzLkNvbmZpZ3VyYXRpb25WaWV3cG9ydFxuICogQGV4dGVuZHMgTmVvLmNvbnRhaW5lci5WaWV3cG9ydFxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIENvbmZpZ3VyYXRpb25WaWV3cG9ydCBleHRlbmRzIFZpZXdwb3J0IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5leGFtcGxlcy5Db25maWd1cmF0aW9uVmlld3BvcnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5leGFtcGxlcy5Db25maWd1cmF0aW9uVmlld3BvcnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nY29uZmlndXJhdGlvbi12aWV3cG9ydCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdjb25maWd1cmF0aW9uLXZpZXdwb3J0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWV4YW1wbGVzLWNvbmZpZ3VyYXRpb24tdmlld3BvcnQnLCduZW8tdmlld3BvcnQnXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tZXhhbXBsZXMtY29uZmlndXJhdGlvbi12aWV3cG9ydCcsICduZW8tdmlld3BvcnQnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gY29uZmlnSXRlbUxhYmVsV2lkdGg9MTUwXG4gICAgICAgICAqL1xuICAgICAgICBjb25maWdJdGVtTGFiZWxXaWR0aDogMTUwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBjb25maWdJdGVtV2lkdGg9MjcwXG4gICAgICAgICAqL1xuICAgICAgICBjb25maWdJdGVtV2lkdGg6IDI3MCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gY29uZmlnUGFuZWxGbGV4PTFcbiAgICAgICAgICovXG4gICAgICAgIGNvbmZpZ1BhbmVsRmxleDogMSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gY29uZmlnUGFuZWxNYXhXaWR0aD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBjb25maWdQYW5lbE1heFdpZHRoOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBjb25maWdQYW5lbE1pbldpZHRoPTM1MFxuICAgICAgICAgKi9cbiAgICAgICAgY29uZmlnUGFuZWxNaW5XaWR0aDogMzUwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9IGV4YW1wbGVDb21wb25lbnQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZXhhbXBsZUNvbXBvbmVudDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gZXhhbXBsZUNvbXBvbmVudEZsZXg9MVxuICAgICAgICAgKi9cbiAgICAgICAgZXhhbXBsZUNvbXBvbmVudEZsZXg6IDIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGxheW91dD17bnR5cGU6J2hib3gnLCBhbGlnbjonc3RyZXRjaCd9XG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbGF5b3V0OiB7bnR5cGU6ICdoYm94JywgYWxpZ246ICdzdHJldGNoJ31cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBjcmVhdGUgdGhlIGNvbXBvbmVudHMgdG8gc2hvdyBpbnNpZGUgdGhlIGNvbmZpZ3VyYXRpb24gY29udGFpbmVyLlxuICAgICAqIFRoZSBtZXRob2QgY2FuIG9wdGlvbmFsbHkgYmUgYXN5bmMgPT4gVXNlIHRoaXMgZm9yIGZ1bmN0aW9uYWwgY29tcG9uZW50cyxcbiAgICAgKiB3aGVyZSB5b3Ugd2FudCB0byBzdWJzY3JpYmUgY29udHJvbHMgdG8gXCJjbGFzc2ljXCIgY29tcG9uZW50cyBpbnNpZGUgZnVuY3Rpb25hbCBjb21wb25lbnRzLlxuICAgICAqIEBzZWU6TmVvLmV4YW1wbGVzLmZ1bmN0aW9uYWwuaG9zdENvbXBvbmVudC5NYWluQ29udGFpbmVyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0W10+fE9iamVjdFtdfG51bGx9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudHMoKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gY3JlYXRlIHRoZSBjb21wb25lbnQgdG8gc2hvdyBpbnNpZGUgdGhlIGN1cnJlbnQgZXhhbXBsZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9XG4gICAgICovXG4gICAgY3JlYXRlRXhhbXBsZUNvbXBvbmVudCgpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGxvZ0luc3RhbmNlKGRhdGEpIHtcbiAgICAgICAgY29uc29sZS5sb2codGhpcy5leGFtcGxlQ29tcG9uZW50KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqL1xuICAgIG9uQ29uZmlnQ2hhbmdlKGNvbmZpZywgb3B0cykge1xuICAgICAgICB0aGlzLmV4YW1wbGVDb21wb25lbnRbY29uZmlnXSA9IG9wdHMudmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIG9uQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICBzdHlsZSA9IG1lLmV4YW1wbGVDb250YWluZXJDb25maWc/LnN0eWxlLFxuICAgICAgICAgICAgZXhhbXBsZUNvbXBvbmVudFR5cGUsIHRoZW1lO1xuXG4gICAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICAgICAgZGVsZXRlIG1lLmV4YW1wbGVDb250YWluZXJDb25maWcuc3R5bGVcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmV4YW1wbGVDb21wb25lbnQgPSBtZS5jcmVhdGVFeGFtcGxlQ29tcG9uZW50KCk7XG5cbiAgICAgICAgZXhhbXBsZUNvbXBvbmVudFR5cGUgPSBOZW8udHlwZU9mKG1lLmV4YW1wbGVDb21wb25lbnQpO1xuXG4gICAgICAgIGlmIChleGFtcGxlQ29tcG9uZW50VHlwZSA9PT0gJ05lb0NsYXNzJyB8fCBleGFtcGxlQ29tcG9uZW50VHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICAgICAgICAgIG1lLmV4YW1wbGVDb21wb25lbnQgPSBOZW8uY3JlYXRlKG1lLmV4YW1wbGVDb21wb25lbnQpXG4gICAgICAgIH1cblxuICAgICAgICBtZS5jb25maWd1cmF0aW9uQ29tcG9uZW50cyA9IGF3YWl0IG1lLmNyZWF0ZUNvbmZpZ3VyYXRpb25Db21wb25lbnRzKCkgfHwgW107XG5cbiAgICAgICAgdGhlbWUgPSBtZS5leGFtcGxlQ29tcG9uZW50LmdldFRoZW1lPy4oKSB8fCAnbmVvLXRoZW1lLWxpZ2h0JztcblxuICAgICAgICBtZS5pdGVtcyA9IFt7XG4gICAgICAgICAgICBtb2R1bGU6IENvbnRhaW5lcixcbiAgICAgICAgICAgIGNscyAgIDogWyduZW8tZXhhbXBsZS1jb250YWluZXInXSxcbiAgICAgICAgICAgIGl0ZW1zIDogW21lLmV4YW1wbGVDb21wb25lbnRdLFxuICAgICAgICAgICAgZmxleCAgOiBtZS5leGFtcGxlQ29tcG9uZW50RmxleCxcbiAgICAgICAgICAgIGxheW91dDogJ2Jhc2UnLFxuICAgICAgICAgICAgc3R5bGUgOiB7b3ZlcmZsb3c6ICdhdXRvJywgcGFkZGluZzogJzIwcHgnLCAuLi5zdHlsZX0sXG4gICAgICAgICAgICAuLi5tZS5leGFtcGxlQ29udGFpbmVyQ29uZmlnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1vZHVsZTogUGFuZWwsXG4gICAgICAgICAgICBjbHMgICA6IFsnbmVvLXBhbmVsJywgJ25lby1jb250YWluZXInLCAnbmVvLWNvbmZpZ3VyYXRpb24tcGFuZWwnXSxcbiAgICAgICAgICAgIGZsZXggIDogbWUuY29uZmlnUGFuZWxGbGV4LFxuXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIG1heFdpZHRoOiBtZS5jb25maWdQYW5lbE1heFdpZHRoICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBtYXJnaW4gIDogJzIwcHgnLFxuICAgICAgICAgICAgICAgIG1pbldpZHRoOiBtZS5jb25maWdQYW5lbE1pbldpZHRoICsgJ3B4J1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaGVhZGVyczogW3tcbiAgICAgICAgICAgICAgICBjbHMgIDogWyduZW8tY29uZmlndXJhdGlvbi1oZWFkZXItdG9vbGJhciddLFxuICAgICAgICAgICAgICAgIGRvY2sgOiAndG9wJyxcbiAgICAgICAgICAgICAgICBpdGVtczogW3tcbiAgICAgICAgICAgICAgICAgICAgbnR5cGU6ICdsYWJlbCcsXG4gICAgICAgICAgICAgICAgICAgIHRleHQgOiAnQ29uZmlndXJhdGlvbidcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIG50eXBlOiAnY29tcG9uZW50JyxcbiAgICAgICAgICAgICAgICAgICAgZmxleCA6IDFcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZSA6IEJ1dHRvbixcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcjogbWUub25Td2l0Y2hUaGVtZS5iaW5kKG1lKSxcbiAgICAgICAgICAgICAgICAgICAgaWQgICAgIDogbWUuaWQgKyAnX18nICsgJ3N3aXRjaFRoZW1lQnV0dG9uJyxcbiAgICAgICAgICAgICAgICAgICAgdGV4dCAgIDogdGhlbWUgPT09ICduZW8tdGhlbWUtZGFyaycgPyAnVGhlbWUgTGlnaHQnIDogJ1RoZW1lIERhcmsnXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH1dLFxuXG4gICAgICAgICAgICBpdGVtczogW3tcbiAgICAgICAgICAgICAgICBtb2R1bGU6IENvbnRhaW5lcixcbiAgICAgICAgICAgICAgICBsYXlvdXQ6IHtudHlwZTogJ3Zib3gnLCBhbGlnbjogbnVsbH0sXG4gICAgICAgICAgICAgICAgY2xzICAgOiBbJ25lby1jb25maWd1cmF0aW9uLXBhbmVsLWJvZHknXSxcbiAgICAgICAgICAgICAgICBpdGVtRGVmYXVsdHM6IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUb09yaWdpbmFsVmFsdWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsV2lkdGggICAgICAgICAgOiBtZS5jb25maWdJdGVtTGFiZWxXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggICAgICAgICAgICAgICA6IG1lLmNvbmZpZ0l0ZW1XaWR0aFxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBpdGVtczogWy4uLm1lLmNvbmZpZ3VyYXRpb25Db21wb25lbnRzLCB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZSA6IEJ1dHRvbixcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcjogYmluZEFwcGVuZChtZS5vblN3aXRjaFRoZW1lLCBtZSwgJ2NtcCcpLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZSAgOiB7bWFyZ2luVG9wOiAnMjBweCd9LFxuICAgICAgICAgICAgICAgICAgICB0ZXh0ICAgOiB0aGVtZSA9PT0gJ25lby10aGVtZS1kYXJrJyA/ICdUaGVtZSBMaWdodCcgOiAnVGhlbWUgRGFyaycsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoICA6IDEzMFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlIDogQnV0dG9uLFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyOiBtZS5sb2dJbnN0YW5jZS5iaW5kKG1lKSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dCAgIDogJ0xvZyBJbnN0YW5jZScsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoICA6IDEzMFxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9XVxuICAgICAgICB9XTtcblxuICAgICAgICBzdXBlci5vbkNvbnN0cnVjdGVkKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKi9cbiAgICBvblJhZGlvQ2hhbmdlKGNvbmZpZywgdmFsdWUsIG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMudmFsdWUgPT09IHRydWUpIHsgLy8gd2Ugb25seSB3YW50IHRvIGxpc3RlbiB0byBjaGVjayBldmVudHMsIG5vdCB1bmNoZWNrXG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVDb21wb25lbnRbY29uZmlnXSA9IHZhbHVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0YXJnZXRcbiAgICAgKi9cbiAgICBvblN3aXRjaFRoZW1lKGRhdGEsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgYnV0dG9uICAgICAgPSBkYXRhLmNvbXBvbmVudCxcbiAgICAgICAgICAgIGNvdW50VGhlbWVzID0gdGhlbWVzLmxlbmd0aCxcbiAgICAgICAgICAgIGZ1dHVyZUluZGV4LCBuZXdUaGVtZSwgdGhlbWVJbmRleDtcblxuICAgICAgICB0aGVtZXMuZm9yRWFjaCgodGhlbWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoYnV0dG9uLnRleHQgPT09IHRoZW1lLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgbmV3VGhlbWUgICA9IHRoZW1lLm5hbWU7XG4gICAgICAgICAgICAgICAgdGhlbWVJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBmdXR1cmVJbmRleCA9ICh0aGVtZUluZGV4ICsgY291bnRUaGVtZXMgKzEpICUgY291bnRUaGVtZXM7XG5cbiAgICAgICAgYnV0dG9uLnRleHQgPSB0aGVtZXNbZnV0dXJlSW5kZXhdLmxhYmVsO1xuXG4gICAgICAgIGlmICh0YXJnZXQgPT09ICdjbXAnKSB7XG4gICAgICAgICAgICBtZS5leGFtcGxlQ29tcG9uZW50LnRoZW1lID0gbmV3VGhlbWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLmFwcC5tYWluVmlldy50aGVtZSA9IG5ld1RoZW1lXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKENvbmZpZ3VyYXRpb25WaWV3cG9ydCk7XG4iLCJpbXBvcnQgQ2hlY2tCb3ggICAgICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3NyYy9mb3JtL2ZpZWxkL0NoZWNrQm94Lm1qcyc7XG5pbXBvcnQgQ2FudmFzICAgICAgICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3NyYy9jb21wb25lbnQvQ2FudmFzLm1qcyc7XG5pbXBvcnQgQ29uZmlndXJhdGlvblZpZXdwb3J0IGZyb20gJy4uLy4uL0NvbmZpZ3VyYXRpb25WaWV3cG9ydC5tanMnO1xuaW1wb3J0IE51bWJlckZpZWxkICAgICAgICAgICBmcm9tICcuLi8uLi8uLi9zcmMvZm9ybS9maWVsZC9OdW1iZXIubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmV4YW1wbGVzLmNvbXBvbmVudC5jYW52YXMuTWFpbkNvbnRhaW5lclxuICogQGV4dGVuZHMgTmVvLmV4YW1wbGVzLkNvbmZpZ3VyYXRpb25WaWV3cG9ydFxuICovXG5jbGFzcyBNYWluQ29udGFpbmVyIGV4dGVuZHMgQ29uZmlndXJhdGlvblZpZXdwb3J0IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICBjbGFzc05hbWUgICAgICAgICAgIDogJ05lby5leGFtcGxlcy5jb21wb25lbnQuY2FudmFzLk1haW5Db250YWluZXInLFxuICAgICAgICBhdXRvTW91bnQgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgY29uZmlnSXRlbUxhYmVsV2lkdGg6IDExMCxcbiAgICAgICAgY29uZmlnSXRlbVdpZHRoICAgICA6IDIzMCxcbiAgICAgICAgbGF5b3V0ICAgICAgICAgICAgICA6IHtudHlwZTogJ2hib3gnLCBhbGlnbjogJ3N0cmV0Y2gnfVxuICAgIH1cblxuICAgIGNyZWF0ZUNvbmZpZ3VyYXRpb25Db21wb25lbnRzKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgbW9kdWxlICAgOiBDaGVja0JveCxcbiAgICAgICAgICAgIGNoZWNrZWQgIDogbWUuZXhhbXBsZUNvbXBvbmVudC5vZmZzY3JlZW4sXG4gICAgICAgICAgICBsYWJlbFRleHQ6ICdvZmZzY3JlZW4nLFxuICAgICAgICAgICAgbGlzdGVuZXJzOiB7Y2hhbmdlOiBtZS5vbkNvbmZpZ0NoYW5nZS5iaW5kKG1lLCAnb2Zmc2NyZWVuJyl9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1vZHVsZSAgICA6ICBOdW1iZXJGaWVsZCxcbiAgICAgICAgICAgIGNsZWFyYWJsZSA6IHRydWUsXG4gICAgICAgICAgICBsYWJlbFRleHQgOiAnaGVpZ2h0JyxcbiAgICAgICAgICAgIGxpc3RlbmVycyA6IHtjaGFuZ2U6IG1lLm9uQ29uZmlnQ2hhbmdlLmJpbmQobWUsICdoZWlnaHQnKX0sXG4gICAgICAgICAgICBtYXhWYWx1ZSAgOiA4MDAsXG4gICAgICAgICAgICBtaW5WYWx1ZSAgOiAxMDAsXG4gICAgICAgICAgICBzdGVwU2l6ZSAgOiA1LFxuICAgICAgICAgICAgc3R5bGUgICAgIDoge21hcmdpblRvcDogJzEwcHgnfSxcbiAgICAgICAgICAgIHZhbHVlICAgICA6IG1lLmV4YW1wbGVDb21wb25lbnQuaGVpZ2h0XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1vZHVsZSAgICA6ICBOdW1iZXJGaWVsZCxcbiAgICAgICAgICAgIGNsZWFyYWJsZSA6IHRydWUsXG4gICAgICAgICAgICBsYWJlbFRleHQgOiAnd2lkdGgnLFxuICAgICAgICAgICAgbGlzdGVuZXJzIDoge2NoYW5nZTogbWUub25Db25maWdDaGFuZ2UuYmluZChtZSwgJ3dpZHRoJyl9LFxuICAgICAgICAgICAgbWF4VmFsdWUgIDogODAwLFxuICAgICAgICAgICAgbWluVmFsdWUgIDogMTAwLFxuICAgICAgICAgICAgc3RlcFNpemUgIDogNSxcbiAgICAgICAgICAgIHZhbHVlICAgICA6IG1lLmV4YW1wbGVDb21wb25lbnQud2lkdGhcbiAgICAgICAgfV07XG4gICAgfVxuXG4gICAgY3JlYXRlRXhhbXBsZUNvbXBvbmVudCgpIHtcbiAgICAgICAgcmV0dXJuIE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgbW9kdWxlICAgOiBDYW52YXMsXG4gICAgICAgICAgICBoZWlnaHQgICA6IDQwMCxcbiAgICAgICAgICAgIG9mZnNjcmVlbjogdHJ1ZSxcbiAgICAgICAgICAgIHdpZHRoICAgIDogNDAwXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoTWFpbkNvbnRhaW5lcik7XG4iLCJpbXBvcnQgQ29tcG9uZW50ICAgICAgZnJvbSAnLi4vY29tcG9uZW50L0Jhc2UubWpzJztcbmltcG9ydCBOZW9BcnJheSAgICAgICBmcm9tICcuLi91dGlsL0FycmF5Lm1qcyc7XG5pbXBvcnQge2lzRGVzY3JpcHRvcn0gZnJvbSAnLi4vY29yZS9Db25maWdTeW1ib2xzLm1qcyc7XG5cbi8qKlxuICogQHN1bW1hcnkgVGhlIGRlZmF1bHQgYnV0dG9uIGNvbXBvbmVudCBmb3IgdGhlIE5lby5tanMgZnJhbWV3b3JrLlxuICpcbiAqIFRoaXMgY2xhc3MgZXh0ZW5kcyBgTmVvLmNvbXBvbmVudC5CYXNlYCBhbmQgb2ZmZXJzIGNvbXByZWhlbnNpdmUgY29uZmlndXJhdGlvbnMgZm9yXG4gKiB0ZXh0LCBpY29ucywgYmFkZ2VzLCBhbmQgZXZlbnQgaGFuZGxpbmcuIEl0IHN1cHBvcnRzIGFkdmFuY2VkIGZlYXR1cmVzIGxpa2VcbiAqIGludGVybmFsIHJvdXRpbmcsIGV4dGVybmFsIFVSTCByZWRpcmVjdGlvbiwgYW5kIG9wdGlvbmFsIHJpcHBsZSBlZmZlY3RzIG9uIGNsaWNrLlxuICogVGhpcyBjbGFzcyBzZXJ2ZXMgYXMgdGhlIGZvdW5kYXRpb24gZm9yIG90aGVyIHNwZWNpYWxpemVkIGJ1dHRvbiB0eXBlcyBsaWtlXG4gKiBTcGxpdEJ1dHRvbiwgVGFiSGVhZGVyQnV0dG9uLCBhbmQgR3JpZEhlYWRlckJ1dHRvbi5cbiAqXG4gKiBAY2xhc3MgTmVvLmJ1dHRvbi5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqIEBzZWUgTmVvLmV4YW1wbGVzLmJ1dHRvbi5iYXNlLk1haW5Db250YWluZXJcbiAqL1xuY2xhc3MgQnV0dG9uIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBWYWxpZCB2YWx1ZXMgZm9yIGJhZGdlUG9zaXRpb25cbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFkZ2VQb3NpdGlvbnM9Wydib3R0b20tbGVmdCcsJ2JvdHRvbS1yaWdodCcsJ3RvcC1sZWZ0JywndG9wLXJpZ2h0J11cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBiYWRnZVBvc2l0aW9ucyA9IFsnYm90dG9tLWxlZnQnLCAnYm90dG9tLXJpZ2h0JywgJ3RvcC1sZWZ0JywgJ3RvcC1yaWdodCddXG4gICAgLyoqXG4gICAgICogVmFsaWQgdmFsdWVzIGZvciBpY29uUG9zaXRpb25cbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gaWNvblBvc2l0aW9ucz1bJ3RvcCcsJ3JpZ2h0JywnYm90dG9tJywnbGVmdCddXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgaWNvblBvc2l0aW9ucyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J11cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmJ1dHRvbi5CYXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uYnV0dG9uLkJhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nYnV0dG9uJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2J1dHRvbicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGJhZGdlUG9zaXRpb25fPSd0b3AtcmlnaHQnXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgYmFkZ2VQb3NpdGlvbl86ICd0b3AtcmlnaHQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGJhZGdlVGV4dF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGJhZGdlVGV4dF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1idXR0b24nXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tYnV0dG9uJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBmYWxzZSBjYWxscyBOZW8uTWFpbi5zZXRSb3V0ZSgpXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGVkaXRSb3V0ZT10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBlZGl0Um91dGU6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG9ydGN1dCBmb3IgZG9tTGlzdGVuZXJzPXtjbGljazpoYW5kbGVyfS5cbiAgICAgICAgICogQSBzdHJpbmctYmFzZWQgdmFsdWUgYXNzdW1lcyB0aGF0IHRoZSBoYW5kbGVyRm4gbGl2ZXMgaW5zaWRlIGEgY29udHJvbGxlci5Db21wb25lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgY29uZmlnIHVzZXMgYSBjdXN0b20gYGlzRXF1YWxgIGZ1bmN0aW9uIHRvIGVuc3VyZSBwcm9wZXIgcmVhY3Rpdml0eS5cbiAgICAgICAgICogV2hlbiB0aGUgaGFuZGxlciBpcyBhIGZ1bmN0aW9uLCBpdCdzIG9mdGVuIGEgY2xvc3VyZSB0aGF0IGNoYW5nZXMgb24gZWFjaCByZW5kZXJcbiAgICAgICAgICogKGUuZy4sIGluIHJlY3ljbGVkIGNvbXBvbmVudHMgbGlrZSBncmlkIGNlbGxzKS4gVGhlIGRlZmF1bHQgZGVlcCBjb21wYXJpc29uXG4gICAgICAgICAqIChgTmVvLmlzRXF1YWxgKSB3b3VsZCBpbmNvcnJlY3RseSB0cmVhdCBzdHJ1Y3R1cmFsbHkgaWRlbnRpY2FsIGZ1bmN0aW9ucyBhcyB1bmNoYW5nZWQsXG4gICAgICAgICAqIHByZXZlbnRpbmcgdXBkYXRlcy4gVGhlIGN1c3RvbSBgaXNFcXVhbGAgZm9yY2VzIGFuIHVwZGF0ZSBmb3IgbmV3IGZ1bmN0aW9uIGluc3RhbmNlcyxcbiAgICAgICAgICogd2hpbGUgcGVyZm9ybWluZyBhIHN0YW5kYXJkIGVxdWFsaXR5IGNoZWNrIGZvciBzdHJpbmctYmFzZWQgaGFuZGxlcnMuXG4gICAgICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufFN0cmluZ3xudWxsfSBoYW5kbGVyX1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGhhbmRsZXJfOiB7XG4gICAgICAgICAgICBbaXNEZXNjcmlwdG9yXTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlICAgICAgICAgOiBudWxsLFxuXG4gICAgICAgICAgICBpc0VxdWFsOiAoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChOZW8uaXNGdW5jdGlvbihhKSAmJiBOZW8uaXNGdW5jdGlvbihiKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgPT09IGJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzY29wZSAodGhpcyBwb2ludGVyKSBpbnNpZGUgdGhlIGhhbmRsZXIgZnVuY3Rpb24uXG4gICAgICAgICAqIFBvaW50cyB0byB0aGUgYnV0dG9uIGluc3RhbmNlIGJ5IGRlZmF1bHQuXG4gICAgICAgICAqIFlvdSBjYW4gdXNlICd0aGlzJyBhcyBhIHN0cmluZyBmb3IgY29udmVuaWVuY2UgcmVhc29uc1xuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8U3RyaW5nfG51bGx9IGhhbmRsZXJTY29wZT1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBoYW5kbGVyU2NvcGU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgQ1NTIGNsYXNzIHRvIHVzZSBmb3IgYW4gaWNvbiwgZS5nLiAnZmEgZmEtaG9tZSdcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IFtpY29uQ2xzXz1udWxsXVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGljb25DbHNfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvbG9yIHRvIHVzZSBmb3IgYW4gaWNvbiwgZS5nLiAnI2ZmMDAwMCcgW29wdGlvbmFsXVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gaWNvbkNvbG9yXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgaWNvbkNvbG9yXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwb3NpdGlvbiBvZiB0aGUgaWNvbiBpbiBjYXNlIGljb25DbHMgaGFzIGEgdmFsdWUuXG4gICAgICAgICAqIFZhbGlkIHZhbHVlcyBhcmU6ICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gaWNvblBvc2l0aW9uXz0nbGVmdCdcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBpY29uUG9zaXRpb25fOiAnbGVmdCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSByZXByZXNlbnRpbmcgdGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIG1lbnUgaXRlbXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIE9yIGEgY29uZmlndXJhdGlvbiBvYmplY3Qgd2hpY2ggYWRkcyBjdXN0b20gY29uZmlndXJhdGlvbiB0byB0aGUgbWVudSB0byBiZVxuICAgICAgICAgKiBjcmVhdGVkIGFuZCBpbmNsdWRlcyBhbiBgaXRlbXNgIHByb3BlcnR5IHRvIGRlZmluZSB0aGUgbWVudSBpdGVtcy5cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fE9iamVjdFtdfG51bGx9IG1lbnVfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBtZW51XzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwcmVzc2VkIHN0YXRlIG9mIHRoZSBCdXR0b25cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gcHJlc3NlZF89ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBwcmVzc2VkXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGFuZ2UgdGhlIGJyb3dzZXIgaGFzaCB2YWx1ZSBvbiBjbGljay5cbiAgICAgICAgICogVXNlIHJvdXRlIGZvciBpbnRlcm5hbCBuYXZpZ2F0aW9uIGFuZCB1cmwgZm9yIGV4dGVybmFsIGxpbmtzLiBEbyBub3QgdXNlIGJvdGggb24gdGhlIHNhbWUgaW5zdGFuY2UuXG4gICAgICAgICAqIFRyYW5zZm9ybXMgdGhlIGJ1dHRvbiB0YWcgaW50byBhbiBhIHRhZyBbb3B0aW9uYWxdXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSByb3V0ZV89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHJvdXRlXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0ZXh0IGRpc3BsYXllZCBvbiB0aGUgYnV0dG9uIFtvcHRpb25hbF1cbiAgICAgICAgICogWW91IGNhbiBlaXRoZXIgcGFzcyBhIHN0cmluZywgb3IgYSB2ZG9tIGNuIGFycmF5LlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAgdGV4dDogW3t0YWc6ICdzcGFuJywgc3R5bGU6IHtjb2xvcjogJyNiYmJiYmInfSwgdGV4dDogJ+KXjyd9LCB7dnR5cGU6ICd0ZXh0JywgdGV4dDogJyBDYXNlcyd9XVxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3RbXXxTdHJpbmd8bnVsbH0gdGV4dD1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYW5zZm9ybXMgdGhlIGJ1dHRvbiB0YWcgaW50byBhbiBhIHRhZyBbb3B0aW9uYWxdXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSB1cmxfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB1cmxfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdXJsIGlzIHNldCwgYXBwbGllcyB0aGUgdGFyZ2V0IGF0dHJpYnV0ZSBvbiB0aGUgdG9wIGxldmVsIHZkb20gbm9kZSBbb3B0aW9uYWxdXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gdXJsVGFyZ2V0Xz0nX2JsYW5rJ1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHVybFRhcmdldF86ICdfYmxhbmsnLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSBhZGRzIGFuIGV4cGFuZGluZyBjaXJjbGUgb24gY2xpY2tcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gdXNlUmlwcGxlRWZmZWN0Xz10cnVlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdXNlUmlwcGxlRWZmZWN0XzogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gX3Zkb21cbiAgICAgICAgICovXG4gICAgICAgIF92ZG9tOlxuICAgICAgICB7dGFnOiAnYnV0dG9uJywgdHlwZTogJ2J1dHRvbicsIGNuOiBbXG4gICAgICAgICAgICB7dGFnOiAnc3BhbicsIGNsczogWyduZW8tYnV0dG9uLWdseXBoJ119LFxuICAgICAgICAgICAge3RhZzogJ3NwYW4nLCBjbHM6IFsnbmVvLWJ1dHRvbi10ZXh0J119LFxuICAgICAgICAgICAge2NsczogWyduZW8tYnV0dG9uLWJhZGdlJ119LFxuICAgICAgICAgICAge2NsczogWyduZW8tYnV0dG9uLXJpcHBsZS13cmFwcGVyJ10sIGNuOiBbXG4gICAgICAgICAgICAgICAge2NsczogWyduZW8tYnV0dG9uLXJpcHBsZSddfVxuICAgICAgICAgICAgXX1cbiAgICAgICAgXX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHJpcHBsZVdyYXBwZXJcbiAgICAgKi9cbiAgICBnZXQgYmFkZ2VOb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRWZG9tUm9vdCgpLmNuWzJdXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gcmlwcGxlV3JhcHBlclxuICAgICAqL1xuICAgIGdldCBpY29uTm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmRvbVJvb3QoKS5jblswXVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaW1lIGluIG1zIGZvciB0aGUgcmlwcGxlIGVmZmVjdCB3aGVuIGNsaWNraW5nIG9uIHRoZSBidXR0b24uXG4gICAgICogT25seSBhY3RpdmUgaWYgdXNlUmlwcGxlRWZmZWN0IGlzIHNldCB0byB0cnVlLlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gcmlwcGxlRWZmZWN0RHVyYXRpb249NDAwXG4gICAgICovXG4gICAgcmlwcGxlRWZmZWN0RHVyYXRpb24gPSA0MDBcbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBmbGFnIHRvIHN0b3JlIHRoZSBsYXN0IHNldFRpbWVvdXQoKSBpZCBmb3IgcmlwcGxlIGVmZmVjdCByZW1vdmUgbm9kZSBjYWxsYmFja3NcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9ICNyaXBwbGVUaW1lb3V0SWQ9bnVsbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgI3JpcHBsZVRpbWVvdXRJZCA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHJpcHBsZVdyYXBwZXJcbiAgICAgKi9cbiAgICBnZXQgcmlwcGxlV3JhcHBlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmRvbVJvb3QoKS5jblszXVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHRleHROb2RlXG4gICAgICovXG4gICAgZ2V0IHRleHROb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRWZG9tUm9vdCgpLmNuWzFdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHRoZSBidXR0b24gaW5zdGFuY2UuXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmFkZERvbUxpc3RlbmVycyh7XG4gICAgICAgICAgICBjbGljazogbWUub25DbGljayxcbiAgICAgICAgICAgIHNjb3BlOiBtZVxuICAgICAgICB9KVxuICAgIH1cblxuXG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGJhZGdlUG9zaXRpb24gY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlICAgIFRoZSBuZXcgdmFsdWUgb2YgdGhlIGJhZGdlUG9zaXRpb24gY29uZmlnLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZSBUaGUgb2xkIHZhbHVlIG9mIHRoZSBiYWRnZVBvc2l0aW9uIGNvbmZpZy5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRCYWRnZVBvc2l0aW9uKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2JhZGdlTm9kZX0gPSBtZSxcbiAgICAgICAgICAgIGNscyAgICAgICAgID0gYmFkZ2VOb2RlLmNscyB8fCBbXTtcblxuICAgICAgICBOZW9BcnJheS5yZW1vdmUoY2xzLCAnbmVvLScgKyBvbGRWYWx1ZSk7XG4gICAgICAgIE5lb0FycmF5LmFkZChjbHMsICduZW8tJyArIHZhbHVlKTtcblxuICAgICAgICBiYWRnZU5vZGUuY2xzID0gY2xzO1xuXG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBiYWRnZVRleHQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWUgICAgVGhlIG5ldyB2YWx1ZSBvZiB0aGUgYmFkZ2VUZXh0IGNvbmZpZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZSBUaGUgb2xkIHZhbHVlIG9mIHRoZSBiYWRnZVRleHQgY29uZmlnLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEJhZGdlVGV4dCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IHtiYWRnZU5vZGV9ID0gdGhpcztcblxuICAgICAgICBiYWRnZU5vZGUucmVtb3ZlRG9tID0gIUJvb2xlYW4odmFsdWUpO1xuICAgICAgICBiYWRnZU5vZGUudGV4dCAgICAgID0gdmFsdWU7XG5cbiAgICAgICAgdGhpcy51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaWNvbkNscyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgICAgVGhlIG5ldyB2YWx1ZSBvZiB0aGUgaWNvbkNscyBjb25maWcuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlIFRoZSBvbGQgdmFsdWUgb2YgdGhlIGljb25DbHMgY29uZmlnLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEljb25DbHModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCB7aWNvbk5vZGV9ID0gdGhpcztcblxuICAgICAgICBOZW9BcnJheS5yZW1vdmUoaWNvbk5vZGUuY2xzLCBvbGRWYWx1ZSk7XG4gICAgICAgIE5lb0FycmF5LmFkZCggICBpY29uTm9kZS5jbHMsIHZhbHVlKTtcblxuICAgICAgICBpY29uTm9kZS5yZW1vdmVEb20gPSAhdmFsdWUgfHwgdmFsdWUgPT09ICcnO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBpY29uQ29sb3IgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWUgICAgVGhlIG5ldyB2YWx1ZSBvZiB0aGUgaWNvbkNvbG9yIGNvbmZpZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZSBUaGUgb2xkIHZhbHVlIG9mIHRoZSBpY29uQ29sb3IgY29uZmlnLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEljb25Db2xvcih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IHtpY29uTm9kZX0gPSB0aGlzO1xuXG4gICAgICAgIGlmICghaWNvbk5vZGUuc3R5bGUpIHtcbiAgICAgICAgICAgIGljb25Ob2RlLnN0eWxlID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIGljb25Ob2RlLnN0eWxlLmNvbG9yID0gdmFsdWU7XG4gICAgICAgIHRoaXMudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGljb25Qb3NpdGlvbiBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgICAgVGhlIG5ldyB2YWx1ZSBvZiB0aGUgaWNvblBvc2l0aW9uIGNvbmZpZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWUgVGhlIG9sZCB2YWx1ZSBvZiB0aGUgaWNvblBvc2l0aW9uIGNvbmZpZy5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRJY29uUG9zaXRpb24odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBjbHMgPSB0aGlzLmNscztcblxuICAgICAgICBOZW9BcnJheS5yZW1vdmUoY2xzLCAnaWNvbi0nICsgb2xkVmFsdWUpO1xuICAgICAgICBOZW9BcnJheS5hZGQoY2xzLCAnaWNvbi0nICsgdmFsdWUpO1xuXG4gICAgICAgIHRoaXMuY2xzID0gY2xzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtZW51IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fE9iamVjdFtdfG51bGx9IHZhbHVlICAgIFRoZSBuZXcgdmFsdWUgb2YgdGhlIG1lbnUgY29uZmlnLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fE9iamVjdFtdfG51bGx9IG9sZFZhbHVlIFRoZSBvbGQgdmFsdWUgb2YgdGhlIG1lbnUgY29uZmlnLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1lbnUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgaW1wb3J0KCcuLi9tZW51L0xpc3QubWpzJykudGhlbihtb2R1bGUgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgaXNBcnJheSAgICAgICA9IEFycmF5LmlzQXJyYXkodmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICBpdGVtcyAgICAgICAgID0gaXNBcnJheSA/IHZhbHVlIDogdmFsdWUuaXRlbXMsXG4gICAgICAgICAgICAgICAgICAgIG1lbnVDb25maWcgICAgPSBpc0FycmF5ID8ge30gOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVQcm92aWRlciA9IG1lLmdldFN0YXRlUHJvdmlkZXIoKSxcbiAgICAgICAgICAgICAgICAgICAge2FwcE5hbWUsIHRoZW1lLCB3aW5kb3dJZH0gPSBtZSxcblxuICAgICAgICAgICAgICAgICAgICBjb25maWcgPSBOZW8ubWVyZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlICAgICAgICAgOiBtb2R1bGUuZGVmYXVsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduICAgICAgICAgIDoge2VkZ2VBbGlnbjogJ3QwLWIwJywgdGFyZ2V0OiBtZS5pZH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheUZpZWxkICAgOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdGluZyAgICAgICA6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRkZW4gICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRDb21wb25lbnQ6IG1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhlbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3dJZFxuICAgICAgICAgICAgICAgICAgICB9LCBtZW51Q29uZmlnKTtcblxuICAgICAgICAgICAgICAgIGlmIChpdGVtcykge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuaXRlbXMgPSBpdGVtc1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZVByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5zdGF0ZVByb3ZpZGVyID0ge3BhcmVudDogc3RhdGVQcm92aWRlcn1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZS5tZW51TGlzdCA9IE5lby5jcmVhdGUoY29uZmlnKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcHJlc3NlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlICAgIFRoZSBuZXcgdmFsdWUgb2YgdGhlIHByZXNzZWQgY29uZmlnLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWUgVGhlIG9sZCB2YWx1ZSBvZiB0aGUgcHJlc3NlZCBjb25maWcuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0UHJlc3NlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IGNscyA9IHRoaXMuY2xzO1xuXG4gICAgICAgIE5lb0FycmF5LnRvZ2dsZShjbHMsICdwcmVzc2VkJywgdmFsdWUgPT09IHRydWUpO1xuICAgICAgICB0aGlzLmNscyA9IGNsc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcm91dGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWUgICAgVGhlIG5ldyB2YWx1ZSBvZiB0aGUgcm91dGUgY29uZmlnLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlIFRoZSBvbGQgdmFsdWUgb2YgdGhlIHJvdXRlIGNvbmZpZy5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRSb3V0ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgIXRoaXMuZWRpdFJvdXRlICYmIHRoaXMudXBkYXRlVGFnKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHRoZW1lIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlICAgIFRoZSBuZXcgdmFsdWUgb2YgdGhlIHRoZW1lIGNvbmZpZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZSBUaGUgb2xkIHZhbHVlIG9mIHRoZSB0aGVtZSBjb25maWcuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VGhlbWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0VGhlbWUodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBsZXQge21lbnVMaXN0fSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lbnVMaXN0KSB7XG4gICAgICAgICAgICBtZW51TGlzdC50aGVtZSA9IHZhbHVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHRleHQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtPYmplY3RbXXxTdHJpbmd8bnVsbH0gdmFsdWUgICAgVGhlIG5ldyB2YWx1ZSBvZiB0aGUgdGV4dCBjb25maWcuXG4gICAgICogQHBhcmFtIHtPYmplY3RbXXxTdHJpbmd8bnVsbH0gb2xkVmFsdWUgVGhlIG9sZCB2YWx1ZSBvZiB0aGUgdGV4dCBjb25maWcuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VGV4dCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaXNFbXB0eSAgICA9ICF2YWx1ZSB8fCB2YWx1ZSA9PT0gJycsXG4gICAgICAgICAgICB2ZG9tUm9vdCAgID0gbWUuZ2V0VmRvbVJvb3QoKSxcbiAgICAgICAgICAgIHt0ZXh0Tm9kZX0gPSBtZTtcblxuICAgICAgICBOZW9BcnJheS50b2dnbGUobWUuX2NscywgICAgICAnbm8tdGV4dCcsIGlzRW1wdHkpO1xuICAgICAgICBOZW9BcnJheS50b2dnbGUodmRvbVJvb3QuY2xzLCAnbm8tdGV4dCcsIGlzRW1wdHkpO1xuICAgICAgICB0ZXh0Tm9kZS5yZW1vdmVEb20gPSBpc0VtcHR5O1xuXG4gICAgICAgIGlmICghaXNFbXB0eSkge1xuICAgICAgICAgICAgaWYgKE5lby5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRleHROb2RlLmNuID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRleHROb2RlLnRleHRcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGV4dE5vZGUudGV4dCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0ZXh0Tm9kZS5jblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHVybCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZSAgICBUaGUgbmV3IHZhbHVlIG9mIHRoZSB1cmwgY29uZmlnLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlIFRoZSBvbGQgdmFsdWUgb2YgdGhlIHVybCBjb25maWcuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VXJsKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZVRhZygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB1c2VSaXBwbGVFZmZlY3QgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSAgICBUaGUgbmV3IHZhbHVlIG9mIHRoZSB1c2VSaXBwbGVFZmZlY3QgY29uZmlnLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWUgVGhlIG9sZCB2YWx1ZSBvZiB0aGUgdXNlUmlwcGxlRWZmZWN0IGNvbmZpZy5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRVc2VSaXBwbGVFZmZlY3QodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIC8vIHNldHRpbmcgdGhlIGNvbmZpZyB0byBmYWxzZSBlbmRzIHJ1bm5pbmcgcmlwcGxlIGFuaW1hdGlvbnNcbiAgICAgICAgdGhpcy5yaXBwbGVXcmFwcGVyLnJlbW92ZURvbSA9IHRydWU7XG4gICAgICAgIHRoaXMudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHVybFRhcmdldCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgICAgVGhlIG5ldyB2YWx1ZSBvZiB0aGUgdXJsVGFyZ2V0IGNvbmZpZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWUgVGhlIG9sZCB2YWx1ZSBvZiB0aGUgdXJsVGFyZ2V0IGNvbmZpZy5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRVcmxUYXJnZXQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB2ZG9tUm9vdCA9IG1lLmdldFZkb21Sb290KCk7XG5cbiAgICAgICAgaWYgKG1lLnVybCkge1xuICAgICAgICAgICAgdmRvbVJvb3QudGFyZ2V0ID0gdmFsdWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSB2ZG9tUm9vdC50YXJnZXRcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB3aW5kb3dJZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSB2YWx1ZSAgICBUaGUgbmV3IHZhbHVlIG9mIHRoZSB3aW5kb3dJZCBjb25maWcuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gb2xkVmFsdWUgVGhlIG9sZCB2YWx1ZSBvZiB0aGUgd2luZG93SWQgY29uZmlnLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFdpbmRvd0lkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldFdpbmRvd0lkKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgbGV0IHttZW51TGlzdH0gPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZW51TGlzdCkge1xuICAgICAgICAgICAgbWVudUxpc3Qud2luZG93SWQgPSB2YWx1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGljb25DbHMgYXJyYXkgaW50byBhIHN0cmluZyBvbiBiZWZvcmVHZXRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVHZXRJY29uQ2xzKCkge1xuICAgICAgICBsZXQgaWNvbkNscyA9IHRoaXMuX2ljb25DbHM7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaWNvbkNscykpIHtcbiAgICAgICAgICAgIHJldHVybiBpY29uQ2xzLmpvaW4oJyAnKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGljb25DbHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBiYWRnZVBvc2l0aW9uIGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgICAgVGhlIG5ldyB2YWx1ZSBvZiB0aGUgYmFkZ2VQb3NpdGlvbiBjb25maWcuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlIFRoZSBvbGQgdmFsdWUgb2YgdGhlIGJhZGdlUG9zaXRpb24gY29uZmlnLlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldEJhZGdlUG9zaXRpb24odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlZm9yZVNldEVudW1WYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICdiYWRnZVBvc2l0aW9uJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBpY29uQ2xzIGNvbmZpZyBnZXRzIGNoYW5nZWQuIENvbnZlcnRzIHRoZSBzdHJpbmcgaW50byBhbiBhcnJheSBpZiBuZWVkZWQuXG4gICAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd8bnVsbH0gdmFsdWUgICAgVGhlIG5ldyB2YWx1ZSBvZiB0aGUgaWNvbkNscyBjb25maWcuXG4gICAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd8bnVsbH0gb2xkVmFsdWUgVGhlIG9sZCB2YWx1ZSBvZiB0aGUgaWNvbkNscyBjb25maWcuXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRJY29uQ2xzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNwbGl0KCcgJykuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBpY29uUG9zaXRpb24gY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSAgICBUaGUgbmV3IHZhbHVlIG9mIHRoZSBpY29uUG9zaXRpb24gY29uZmlnLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZSBUaGUgb2xkIHZhbHVlIG9mIHRoZSBpY29uUG9zaXRpb24gY29uZmlnLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRJY29uUG9zaXRpb24odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlZm9yZVNldEVudW1WYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICdpY29uUG9zaXRpb24nKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIGFwcGxpY2F0aW9uJ3Mgcm91dGUgYmFzZWQgb24gdGhlIGJ1dHRvbidzIHJvdXRlIGNvbmZpZy5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY2hhbmdlUm91dGUoKSB7XG4gICAgICAgIHRoaXMuZWRpdFJvdXRlICYmIE5lby5NYWluLmVkaXRSb3V0ZSh0aGlzLnJvdXRlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBidXR0b24gaW5zdGFuY2UsIGl0cyBtZW51IChpZiBwcmVzZW50KSwgYW5kIGNhbGxzIHRoZSBzdXBlcmNsYXNzIGRlc3Ryb3kgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgc3VwZXJjbGFzcyBkZXN0cm95IG1ldGhvZC5cbiAgICAgKi9cbiAgICBkZXN0cm95KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5tZW51TGlzdD8uZGVzdHJveSh0cnVlLCBmYWxzZSk7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koLi4uYXJncylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSBjbGljayBldmVudCBvbiB0aGUgYnV0dG9uLlxuICAgICAqIFRyaWdnZXJzIHRoZSBjb25maWd1cmVkIGhhbmRsZXIsIHRvZ2dsZXMgdGhlIG1lbnUsIHVwZGF0ZXMgdGhlIHJvdXRlLCBhbmQgc2hvd3MgdGhlIHJpcHBsZSBlZmZlY3QgaWYgYXBwbGljYWJsZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgY2xpY2sgZXZlbnQgZGF0YSBvYmplY3QuXG4gICAgICovXG4gICAgb25DbGljayhkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuYmluZENhbGxiYWNrKG1lLmhhbmRsZXIsICdoYW5kbGVyJywgbWUuaGFuZGxlclNjb3BlIHx8IG1lKTtcbiAgICAgICAgbWUuaGFuZGxlcj8uKGRhdGEpO1xuXG4gICAgICAgIG1lLm1lbnUgICAgICAgICAgICAmJiBtZS50b2dnbGVNZW51KCk7XG4gICAgICAgIG1lLnJvdXRlICAgICAgICAgICAmJiBtZS5jaGFuZ2VSb3V0ZSgpOyAvLyBvbmx5IHJlbGV2YW50IGZvciBlZGl0Um91dGU9dHJ1ZVxuICAgICAgICBtZS51c2VSaXBwbGVFZmZlY3QgJiYgbWUuc2hvd1JpcHBsZShkYXRhKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc3BsYXlzIGEgcmlwcGxlIGFuaW1hdGlvbiBlZmZlY3Qgb24gdGhlIGJ1dHRvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgY2xpY2sgZXZlbnQgZGF0YSBvYmplY3QgdXNlZCB0byBjYWxjdWxhdGUgdGhlIHJpcHBsZSBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBzaG93UmlwcGxlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGJ1dHRvblJlY3QgICAgICAgICAgID0gZGF0YS5wYXRoWzBdLnJlY3QsXG4gICAgICAgICAgICBkaWFtZXRlciAgICAgICAgICAgICA9IE1hdGgubWF4KGJ1dHRvblJlY3QuaGVpZ2h0LCBidXR0b25SZWN0LndpZHRoKSxcbiAgICAgICAgICAgIHJhZGl1cyAgICAgICAgICAgICAgID0gZGlhbWV0ZXIgLyAyLFxuICAgICAgICAgICAgcmlwcGxlRWZmZWN0RHVyYXRpb24gPSBtZS5yaXBwbGVFZmZlY3REdXJhdGlvbixcbiAgICAgICAgICAgIHtyaXBwbGVXcmFwcGVyfSAgICAgID0gbWUsXG4gICAgICAgICAgICByaXBwbGVFbCAgICAgICAgICAgICA9IHJpcHBsZVdyYXBwZXIuY25bMF0sXG4gICAgICAgICAgICByaXBwbGVUaW1lb3V0SWQ7XG5cbiAgICAgICAgcmlwcGxlRWwuc3R5bGUgPSBPYmplY3QuYXNzaWduKHJpcHBsZUVsLnN0eWxlIHx8IHt9LCB7XG4gICAgICAgICAgICBhbmltYXRpb246ICdub25lJyxcbiAgICAgICAgICAgIGhlaWdodCAgIDogYCR7ZGlhbWV0ZXJ9cHhgLFxuICAgICAgICAgICAgbGVmdCAgICAgOiBgJHtkYXRhLmNsaWVudFggLSBidXR0b25SZWN0LmxlZnQgLSByYWRpdXN9cHhgLFxuICAgICAgICAgICAgdG9wICAgICAgOiBgJHtkYXRhLmNsaWVudFkgLSBidXR0b25SZWN0LnRvcCAgLSByYWRpdXN9cHhgLFxuICAgICAgICAgICAgd2lkdGggICAgOiBgJHtkaWFtZXRlcn1weGBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGVsZXRlIHJpcHBsZVdyYXBwZXIucmVtb3ZlRG9tO1xuICAgICAgICBtZS51cGRhdGUoKTtcblxuICAgICAgICBhd2FpdCBtZS50aW1lb3V0KDEpO1xuXG4gICAgICAgIHJpcHBsZUVsLnN0eWxlLmFuaW1hdGlvbiA9IGByaXBwbGUgJHtyaXBwbGVFZmZlY3REdXJhdGlvbn1tcyBsaW5lYXJgO1xuICAgICAgICBtZS51cGRhdGUoKTtcblxuICAgICAgICBtZS4jcmlwcGxlVGltZW91dElkID0gcmlwcGxlVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBicmVhayBhbmltYXRpb25zIHdoZW4gY2xpY2tpbmcgbXVsdGlwbGUgdGltZXNcbiAgICAgICAgICAgIGlmIChtZS4jcmlwcGxlVGltZW91dElkID09PSByaXBwbGVUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgICAgICBtZS4jcmlwcGxlVGltZW91dElkID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIHJpcHBsZVdyYXBwZXIucmVtb3ZlRG9tID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBtZS51cGRhdGUoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCByaXBwbGVFZmZlY3REdXJhdGlvbilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBidXR0b24ncyBtZW51LCBpZiBvbmUgaXMgY29uZmlndXJlZC5cbiAgICAgKi9cbiAgICBhc3luYyB0b2dnbGVNZW51KCkge1xuICAgICAgICBsZXQge21lbnVMaXN0fSA9IHRoaXMsXG4gICAgICAgICAgICBoaWRkZW4gICAgID0gIW1lbnVMaXN0LmhpZGRlbjtcblxuICAgICAgICBtZW51TGlzdC5oaWRkZW4gPSBoaWRkZW47XG5cbiAgICAgICAgaWYgKCFoaWRkZW4pIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudGltZW91dCg1MClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIGJ1dHRvbiBpbnRvIGEgSlNPTi1jb21wYXRpYmxlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaGFuZGxlciA9IG1lLmhhbmRsZXI7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLnRvSlNPTigpLFxuICAgICAgICAgICAgYmFkZ2VQb3NpdGlvbjogbWUuYmFkZ2VQb3NpdGlvbixcbiAgICAgICAgICAgIGJhZGdlVGV4dCAgICA6IG1lLmJhZGdlVGV4dCxcbiAgICAgICAgICAgIGhhbmRsZXIgICAgICA6IE5lby5pc1N0cmluZyhoYW5kbGVyKSA/IGhhbmRsZXIgOiAoTmVvLmlzRnVuY3Rpb24oaGFuZGxlcikgPyAnZnVuY3Rpb24nIDogbnVsbCksXG4gICAgICAgICAgICBpY29uQ2xzICAgICAgOiBtZS5pY29uQ2xzLFxuICAgICAgICAgICAgaWNvbkNvbG9yICAgIDogbWUuaWNvbkNvbG9yLFxuICAgICAgICAgICAgaWNvblBvc2l0aW9uIDogbWUuaWNvblBvc2l0aW9uLFxuICAgICAgICAgICAgcHJlc3NlZCAgICAgIDogbWUucHJlc3NlZCxcbiAgICAgICAgICAgIHJvdXRlICAgICAgICA6IG1lLnJvdXRlLFxuICAgICAgICAgICAgdGV4dCAgICAgICAgIDogbWUudGV4dCxcbiAgICAgICAgICAgIHVybCAgICAgICAgICA6IG1lLnVybCxcbiAgICAgICAgICAgIHVybFRhcmdldCAgICA6IG1lLnVybFRhcmdldFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgVkRPTSB0YWcgb2YgdGhlIGJ1dHRvbiAoZS5nLiwgc3dpdGNoaW5nIGJldHdlZW4gJ2J1dHRvbicgYW5kICdhJyB0YWdzKSBiYXNlZCBvbiB0aGUgY3VycmVudCBjb25maWd1cmF0aW9uLlxuICAgICAqL1xuICAgIHVwZGF0ZVRhZygpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtlZGl0Um91dGUsIHJvdXRlLCB1cmx9ID0gbWUsXG4gICAgICAgICAgICBsaW5rICAgICAgICAgICAgICAgICAgICA9ICFlZGl0Um91dGUgJiYgcm91dGUgfHwgdXJsLFxuICAgICAgICAgICAgdmRvbVJvb3QgICAgICAgICAgICAgICAgPSBtZS5nZXRWZG9tUm9vdCgpO1xuXG4gICAgICAgIGlmICghZWRpdFJvdXRlICYmIHJvdXRlPy5zdGFydHNXaXRoKCcjJykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBsaW5rID0gJyMnICsgbGlua1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgICAgIHZkb21Sb290LmhyZWYgPSBsaW5rO1xuICAgICAgICAgICAgdmRvbVJvb3QudGFnICA9ICdhJ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHZkb21Sb290LmhyZWY7XG4gICAgICAgICAgICB2ZG9tUm9vdC50YWcgPSAnYnV0dG9uJ1xuICAgICAgICB9XG5cbiAgICAgICAgbWUudXBkYXRlKClcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEJ1dHRvbik7XG4iLCJpbXBvcnQgQmFzZSAgICAgICAgICAgICBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBDbGFzc1N5c3RlbVV0aWwgIGZyb20gJy4uL3V0aWwvQ2xhc3NTeXN0ZW0ubWpzJztcbmltcG9ydCBDb21wb25lbnRNYW5hZ2VyIGZyb20gJy4uL21hbmFnZXIvQ29tcG9uZW50Lm1qcyc7XG5pbXBvcnQgRG9tRXZlbnRzICAgICAgICBmcm9tICcuLi9taXhpbi9Eb21FdmVudHMubWpzJztcbmltcG9ydCBPYnNlcnZhYmxlICAgICAgIGZyb20gJy4uL2NvcmUvT2JzZXJ2YWJsZS5tanMnO1xuaW1wb3J0IFZkb21MaWZlY3ljbGUgICAgZnJvbSAnLi4vbWl4aW4vVmRvbUxpZmVjeWNsZS5tanMnO1xuaW1wb3J0IFZEb21VcGRhdGUgICAgICAgZnJvbSAnLi4vbWFuYWdlci9WRG9tVXBkYXRlLm1qcyc7XG5pbXBvcnQgVk5vZGVVdGlsICAgICAgICBmcm9tICcuLi91dGlsL1ZOb2RlLm1qcyc7XG5pbXBvcnQge2lzRGVzY3JpcHRvcn0gICBmcm9tICcuLi9jb3JlL0NvbmZpZ1N5bWJvbHMubWpzJztcblxuY29uc3RcbiAgICBjbG9zZXN0Q29udHJvbGxlciAgID0gU3ltYm9sLmZvcignY2xvc2VzdENvbnRyb2xsZXInKSxcbiAgICBjbG9zZXN0UHJvdmlkZXIgICAgID0gU3ltYm9sLmZvcignY2xvc2VzdFByb3ZpZGVyJyksXG4gICAgdHdvV2F5QmluZGluZ1N5bWJvbCA9IFN5bWJvbC5mb3IoJ3R3b1dheUJpbmRpbmcnKTtcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNvbXBvbmVudC5BYnN0cmFjdFxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICogQG1peGVzIE5lby5jb21wb25lbnQubWl4aW4uRG9tRXZlbnRzXG4gKiBAbWl4ZXMgTmVvLmNvcmUuT2JzZXJ2YWJsZVxuICogQG1peGVzIE5lby5jb21wb25lbnQubWl4aW4uVmRvbUxpZmVjeWNsZVxuICovXG5jbGFzcyBBYnN0cmFjdCBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbXBvbmVudC5BYnN0cmFjdCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbXBvbmVudC5BYnN0cmFjdCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdhYnN0cmFjdC1jb21wb25lbnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnYWJzdHJhY3QtY29tcG9uZW50JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZGl0aW9uYWwgbmFtZXNwYWNlcyB0byBsb2FkIHRoZW1lIGZpbGVzIGZvci5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW118bnVsbH0gYWRkaXRpb25hbFRoZW1lRmlsZXM9bnVsbFxuICAgICAgICAgKiBAZXhhbXBsZSBbJ0FnZW50T1NTdHJhdGVneS52aWV3LlZpZXdwb3J0J11cbiAgICAgICAgICovXG4gICAgICAgIGFkZGl0aW9uYWxUaGVtZUZpbGVzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG5hbWUgb2YgdGhlIEFwcCB0aGlzIGNvbXBvbmVudCBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBhcHBOYW1lXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXBwTmFtZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCaW5kIGNvbmZpZ3MgdG8gc3RhdGUuUHJvdmlkZXIgZGF0YSBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gYmluZF89e1tpc0Rlc2NyaXB0b3JdOnRydWUsbWVyZ2U6J2RlZXAnLHZhbHVlOm51bGx9XG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgYmluZF86IHtcbiAgICAgICAgICAgIFtpc0Rlc2NyaXB0b3JdOiB0cnVlLFxuICAgICAgICAgICAgbWVyZ2UgICAgICAgICA6ICdkZWVwJyxcbiAgICAgICAgICAgIHZhbHVlICAgICAgICAgOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDdXN0b20gQ1NTIHNlbGVjdG9ycyB0byBhcHBseSB0byB0aGUgcm9vdCBsZXZlbCBub2RlIG9mIHRoaXMgY29tcG9uZW50XG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBjbHNfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBjbHNfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXQgdG8gYWNjZXNzIHRoZSBkYXRhIGNvbmZpZyBvZiB0aGUgY2xvc2VzdCBzdGF0ZS5Qcm92aWRlci5cbiAgICAgICAgICogUmVhZCBvbmx5LlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGRhdGFfPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGRhdGFfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzYWJsZWQgY29tcG9uZW50cyB3aWxsIGdldCB0aGUgbmVvLWRpc2FibGVkIGNscyBhcHBsaWVkIGFuZCB3b24ndCByZWNlaXZlIERPTSBldmVudHNcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZGlzYWJsZWRfPWZhbHNlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZWRfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb3JlLkJhc2VbXX0gbWl4aW5zPVtEb21FdmVudHMsIE9ic2VydmFibGUsIFZkb21MaWZlY3ljbGVdXG4gICAgICAgICAqL1xuICAgICAgICBtaXhpbnM6IFtEb21FdmVudHMsIE9ic2VydmFibGUsIFZkb21MaWZlY3ljbGVdLFxuICAgICAgICAvKipcbiAgICAgICAgICogT3ZlcnJpZGUgc3BlY2lmaWMgc3RhdGVQcm92aWRlciBkYXRhIHByb3BlcnRpZXMuXG4gICAgICAgICAqIFRoaXMgd2lsbCBtZXJnZSB0aGUgY29udGVudC5cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IG1vZGVsRGF0YT1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBtb2RlbERhdGE6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIGFmdGVyIHRoZSBjb21wb25lbnQgaW5pdFZub2RlKCkgbWV0aG9kIHdhcyBjYWxsZWQuIEFsc28gZmlyZXMgdGhlIHJlbmRlcmVkIGV2ZW50LlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBtb3VudGVkXz1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbW91bnRlZF86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIHBhcmVudElkIGRvZXMgbm90IG1hdGNoIGEgbmVvIGNvbXBvbmVudCBpZCwgeW91IGNhbiBtYW51YWxseSBzZXQgdGhpcyB2YWx1ZSBmb3IgZmluZGluZ1xuICAgICAgICAgKiB2aWV3IGNvbnRyb2xsZXJzIG9yIHN0YXRlIHByb3ZpZGVycy5cbiAgICAgICAgICogVXNlIGNhc2U6IG1hbnVhbGx5IGRyb3BwaW5nIGNvbXBvbmVudHMgaW50byBhIHZkb20gc3RydWN0dXJlXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb21wb25lbnQuQmFzZXxudWxsfSBwYXJlbnRDb21wb25lbnRfPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHBhcmVudENvbXBvbmVudF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGFyZW50IGNvbXBvbmVudCBpZCBvciBkb2N1bWVudC5ib2R5XG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gcGFyZW50SWRfPSdkb2N1bWVudC5ib2R5J1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHBhcmVudElkXzogJ2RvY3VtZW50LmJvZHknLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2F2ZVNjcm9sbFBvc2l0aW9uPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIHNhdmVTY3JvbGxQb3NpdGlvbjogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wdGlvbmFsbHkgYWRkIGEgc3RhdGUuUHJvdmlkZXIgdG8gc2hhcmUgc3RhdGUgZGF0YSB3aXRoIGNoaWxkIGNvbXBvbmVudHNcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IHN0YXRlUHJvdmlkZXJfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0ZVByb3ZpZGVyXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbWFwIG9mIGNvbmZpZyBuYW1lcyBhbmQgdmFsdWVzIHRvIHJlc2V0IHRvIHdoZW4gdGhlIGNvbXBvbmVudCB1bm1vdW50cy5cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IHVubW91bnRDb25maWdzXz17W2lzRGVzY3JpcHRvcl06dHJ1ZSxtZXJnZTonZGVlcCcsdmFsdWU6bnVsbH1cbiAgICAgICAgICogQGV4YW1wbGUge2FjdGl2ZUluZGV4OiBudWxsLCB2YWx1ZTogJyd9XG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdW5tb3VudENvbmZpZ3NfOiB7XG4gICAgICAgICAgICBbaXNEZXNjcmlwdG9yXTogdHJ1ZSxcbiAgICAgICAgICAgIG1lcmdlICAgICAgICAgOiAnZGVlcCcsXG4gICAgICAgICAgICB2YWx1ZSAgICAgICAgIDogbnVsbFxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1c3RvbSB3aW5kb3dJcyAodGltZXN0YW1wKSB0aGlzIGNvbXBvbmVudCBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSB3aW5kb3dJZF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHdpbmRvd0lkXzogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGZsYWcgd2hpY2ggd2lsbCBnZXQgc2V0IHRvIHRydWUgd2hpbGUgYSBjb21wb25lbnQgaXMgd2FpdGluZyBmb3IgaXRzIG1vdW50ZWRQcm9taXNlXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNBd2FpdGluZ01vdW50PWZhbHNlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGlzQXdhaXRpbmdNb3VudCA9IGZhbHNlXG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dCB0byBhY2Nlc3MgdGhlIEFwcCB0aGlzIGNvbXBvbmVudCBiZWxvbmdzIHRvXG4gICAgICogQHJldHVybnMge05lby5jb250cm9sbGVyLkFwcGxpY2F0aW9ufG51bGx9XG4gICAgICovXG4gICAgZ2V0IGFwcCgpIHtcbiAgICAgICAgLy8gV2UgbmVlZCBOZW8uYXBwc0J5TmFtZSBhcyBhIGZhbGxiYWNrIGZvciBQbGF5d3JpZ2h0LWJhc2VkIHVuaXQgdGVzdGluZ1xuICAgICAgICByZXR1cm4gTmVvLmFwcHNbdGhpcy53aW5kb3dJZF0gfHwgTmVvLmFwcHNCeU5hbWVbdGhpcy5hcHBOYW1lXT8uWzBdIHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZCB0byB0aGUgRE9NLlxuICAgICAqIFRoaXMgcHJvdmlkZXMgYSBjb252ZW5pZW50IHdheSB0byB3YWl0IGZvciB0aGUgY29tcG9uZW50IHRvIGJlIGZ1bGx5XG4gICAgICogYXZhaWxhYmxlIGFuZCBpbnRlcmFjdGl2ZSBiZWZvcmUgZXhlY3V0aW5nIHN1YnNlcXVlbnQgbG9naWMuXG4gICAgICpcbiAgICAgKiBJdCBhbHNvIGhhbmRsZXMgdW5tb3VudGluZyBieSByZXNldHRpbmcgdGhlIHByb21pc2UsIHNvIGl0IGNhbiBiZSBzYWZlbHlcbiAgICAgKiBhd2FpdGVkIGFnYWluIGlmIHRoZSBjb21wb25lbnQgaXMgcmVtb3VudGVkLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE5lby5jb21wb25lbnQuQmFzZT59XG4gICAgICovXG4gICAgZ2V0IG1vdW50ZWRQcm9taXNlKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUuX21vdW50ZWRQcm9taXNlKSB7XG4gICAgICAgICAgICBtZS5fbW91bnRlZFByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobWUubW91bnRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG1lKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZS5tb3VudGVkUHJvbWlzZVJlc29sdmUgPSByZXNvbHZlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZS5fbW91bnRlZFByb21pc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gYWNjZXNzIHRoZSBwYXJlbnQgY29tcG9uZW50XG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZXxudWxsfVxuICAgICAqL1xuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIG1lLnBhcmVudENvbXBvbmVudCB8fCAobWUucGFyZW50SWQgPT09ICdkb2N1bWVudC5ib2R5JyA/IG51bGwgOiBOZW8uZ2V0Q29tcG9uZW50KG1lLnBhcmVudElkKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgYW55IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHBhcmFtIHsqfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldENvbmZpZyhrZXksIHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChOZW8uaXNVc2luZ1N0YXRlUHJvdmlkZXJzICYmIG1lW3R3b1dheUJpbmRpbmdTeW1ib2xdKSB7XG4gICAgICAgICAgICAvLyBXaGVuIGEgY29tcG9uZW50IGNvbmZpZyBpcyB1cGRhdGVkIGJ5IGl0cyBzdGF0ZSBwcm92aWRlciwgdGhpcyBmbGFnIGlzIHNldCB0byB0aGUgY29uZmlnJ3Mga2V5LlxuICAgICAgICAgICAgLy8gVGhpcyBwcmV2ZW50cyBjaXJjdWxhciB1cGRhdGVzIGluIHR3by13YXkgZGF0YSBiaW5kaW5ncyBieSBza2lwcGluZyB0aGUgcHVzaCBiYWNrIHRvIHRoZSBzdGF0ZSBwcm92aWRlci5cbiAgICAgICAgICAgIGlmIChtZS5fc2tpcFR3b1dheVB1c2ggPT09IGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBiaW5kaW5nID0gbWUuYmluZD8uW2tleV07XG5cbiAgICAgICAgICAgIGlmIChiaW5kaW5nPy50d29XYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldFN0YXRlUHJvdmlkZXIoKT8uc2V0RGF0YShiaW5kaW5nLmtleSwgdmFsdWUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGlkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRJZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRJZCh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIG9sZFZhbHVlICYmIENvbXBvbmVudE1hbmFnZXIudW5yZWdpc3RlcihvbGRWYWx1ZSk7XG4gICAgICAgIHZhbHVlICAgICYmIENvbXBvbmVudE1hbmFnZXIucmVnaXN0ZXIodGhpcylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1vdW50ZWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUpIHsgLy8gbW91bnRcbiAgICAgICAgICAgICAgICBtZS5pbml0RG9tRXZlbnRzPy4oKTtcbiAgICAgICAgICAgICAgICBtZS5tb3VudGVkUHJvbWlzZVJlc29sdmU/Lih0aGlzKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgbWUubW91bnRlZFByb21pc2VSZXNvbHZlO1xuXG4gICAgICAgICAgICAgICAgLy8gV2hlbiBhIGNvbXBvbmVudCBiZWNvbWVzIG1vdW50ZWQsIGl0IG1pZ2h0IGhhdmUgcGVuZGluZyBWRE9NIHVwZGF0ZSBwcm9taXNlc1xuICAgICAgICAgICAgICAgIC8vIChlLmcuIGZyb20gYSBzZXQoKSBjYWxsIHRoYXQgd2FzIGRlZmVycmVkIGJlY2F1c2UgdGhlIGNvbXBvbmVudCB3YXNuJ3QgbW91bnRlZCB5ZXQpLlxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBtb3VudCBoYXBwZW5lZCBiZWNhdXNlIGEgUGFyZW50IGNvbXBvbmVudCB1cGRhdGVkIChpbXBsaWNpdGx5IGNvdmVyaW5nIHRoaXMgY29tcG9uZW50KSxcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNvbXBvbmVudCdzIG93biBwZW5kaW5nIHVwZGF0ZSBjeWNsZSBtaWdodCBiZSBza2lwcGVkIG9yIG5vdCB5ZXQgdHJpZ2dlcmVkLlxuICAgICAgICAgICAgICAgIC8vIFdlIGV4cGxpY2l0bHkgZXhlY3V0ZSB0aGUgY2FsbGJhY2tzIGhlcmUgdG8gZW5zdXJlIHRob3NlIHBlbmRpbmcgcHJvbWlzZXMgYXJlIHJlc29sdmVkIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgLy8gdXBvbiBtb3VudCwgcHJldmVudGluZyBkZWFkbG9ja3Mgd2hlcmUgY29kZSBhd2FpdHMgYSBWRE9NIHVwZGF0ZSB0aGF0IGVmZmVjdGl2ZWx5IGFscmVhZHkgaGFwcGVuZWQuXG4gICAgICAgICAgICAgICAgVkRvbVVwZGF0ZS5leGVjdXRlQ2FsbGJhY2tzKG1lLmlkLCB7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhczogW10sXG4gICAgICAgICAgICAgICAgICAgIHZub2RlIDogbWUudm5vZGVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSBlbHNlIHsgLy8gdW5tb3VudFxuICAgICAgICAgICAgICAgIGRlbGV0ZSBtZS5fbW91bnRlZFByb21pc2U7XG5cbiAgICAgICAgICAgICAgICBtZS5yZXNldE1vdW50ZWREb21FdmVudHM/LigpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1lLnVubW91bnRDb25maWdzKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnNldChtZS51bm1vdW50Q29uZmlncylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHBhcmVudElkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRQYXJlbnRJZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgQ29tcG9uZW50TWFuYWdlci5vblBhcmVudElkQ2hhbmdlKHRoaXMsIG9sZFZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc3RhdGVQcm92aWRlciBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge05lby5zdGF0ZS5Qcm92aWRlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxOZW8uc3RhdGUuUHJvdmlkZXJ8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTdGF0ZVByb3ZpZGVyKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB2YWx1ZT8uY3JlYXRlQmluZGluZ3ModGhpcylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHdpbmRvd0lkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRXaW5kb3dJZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgbWUuY29udHJvbGxlciAgICAmJiAobWUuY29udHJvbGxlci53aW5kb3dJZCAgICA9IHZhbHVlKTtcbiAgICAgICAgICAgIG1lLnN0YXRlUHJvdmlkZXIgJiYgKG1lLnN0YXRlUHJvdmlkZXIud2luZG93SWQgPSB2YWx1ZSk7XG5cbiAgICAgICAgICAgIE5lby5jdXJyZW50V29ya2VyLmluc2VydFRoZW1lRmlsZXModmFsdWUsIG1lLl9fcHJvdG9fXylcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGEgY29tcG9uZW50IGdldHMgbW92ZWQgaW50byBhIGRpZmZlcmVudCB3aW5kb3csIGFuIHVwZGF0ZSBjeWNsZSBtaWdodCBzdGlsbCBiZSBydW5uaW5nLlxuICAgICAgICAvLyBTaW5jZSB0aGUgdXBkYXRlIG1pZ2h0IG5vIGxvbmdlciBnZXQgbWFwcGVkLCB3ZSB3YW50IHRvIHJlLWVuYWJsZSB0aGlzIGluc3RhbmNlIGZvciBmdXR1cmUgdXBkYXRlcy5cbiAgICAgICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAgICAgICBtZS5pc1Zkb21VcGRhdGluZyA9IGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhY2Nlc3NpbmcgdGhlIGRhdGEgY29uZmlnXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXQgd2hpY2ggaXMgZXhwZW5zaXZlIHRvIHVzZSwgc2luY2UgaXQgd2lsbCBnZW5lcmF0ZSBhIG1lcmdlZCBwYXJlbnQgc3RhdGUgcHJvdmlkZXJzIGRhdGEgbWFwLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVHZXREYXRhKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0YXRlUHJvdmlkZXIoKT8uZ2V0SGllcmFyY2h5RGF0YSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgc3RhdGVQcm92aWRlciBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIENyZWF0ZXMgYSBzdGF0ZS5Qcm92aWRlciBpbnN0YW5jZSBpZiBuZWVkZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge05lby5zdGF0ZS5Qcm92aWRlcn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0U3RhdGVQcm92aWRlcih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWU/LmRlc3Ryb3koKTtcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWVzID0ge2NvbXBvbmVudDogbWUsIHdpbmRvd0lkOiBtZS53aW5kb3dJZH07XG5cbiAgICAgICAgICAgIGlmIChtZS5tb2RlbERhdGEpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWVzLmRhdGEgPSBtZS5tb2RlbERhdGFcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIENsYXNzU3lzdGVtVXRpbC5iZWZvcmVTZXRJbnN0YW5jZSh2YWx1ZSwgJ05lby5zdGF0ZS5Qcm92aWRlcicsIGRlZmF1bHRWYWx1ZXMpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVEb21FdmVudHMoKTtcbiAgICAgICAgQ29tcG9uZW50TWFuYWdlci51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICB0aGlzLnN0YXRlUHJvdmlkZXIgPSBudWxsOyAvLyB0cmlnZ2VycyBkZXN0cm95KClcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZCBhbiBpbnN0YW5jZSBzdG9yZWQgaW5zaWRlIGEgY29uZmlnIHZpYSBvcHRpb25hbGx5IHBhc3NpbmcgYSBudHlwZS5cbiAgICAgKiBSZXR1cm5zIHRoaXNbY29uZmlnTmFtZV0gb3IgdGhlIGNsb3Nlc3QgcGFyZW50IGNvbXBvbmVudCB3aXRoIGEgbWF0Y2guXG4gICAgICogVXNlZCBieSBnZXRDb250cm9sbGVyKCkgJiBnZXRTdGF0ZVByb3ZpZGVyKClcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnTmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbbnR5cGVdXG4gICAgICogQHJldHVybnMge05lby5jb3JlLkJhc2V8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRDb25maWdJbnN0YW5jZUJ5TnR5cGUoY29uZmlnTmFtZSwgbnR5cGUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyAgICAgICAgICAgID0gbWVbY29uZmlnTmFtZV0sXG4gICAgICAgICAgICB7cGFyZW50Q29tcG9uZW50fSA9IG1lO1xuXG4gICAgICAgIGlmIChjb25maWcgJiYgKCFudHlwZSB8fCBudHlwZSA9PT0gY29uZmlnLm50eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZ1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwYXJlbnRDb21wb25lbnQgJiYgbWUucGFyZW50SWQpIHtcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCA9IG1lLnBhcmVudCB8fCBOZW8uZ2V0KG1lLnBhcmVudElkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJlbnRDb21wb25lbnQpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnRDb21wb25lbnQgPT09IG1lKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignQ2lyY3VsYXIgcGFyZW50IHJlZmVyZW5jZSBkZXRlY3RlZCcsIG1lLmlkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0b2RvOiBXZSBuZWVkID8uIHVudGlsIGZ1bmN0aW9uYWwuY29tcG9uZW50LkJhc2Ugc3VwcG9ydHMgY29udHJvbGxlcnNcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRDb21wb25lbnQuZ2V0Q29uZmlnSW5zdGFuY2VCeU50eXBlPy4oY29uZmlnTmFtZSwgbnR5cGUpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIHNob3J0Y3V0XG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRTdGF0ZSguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0YXRlUHJvdmlkZXIoKS5nZXREYXRhKC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGlzLnN0YXRlUHJvdmlkZXIgb3IgdGhlIGNsb3Nlc3QgcGFyZW50IHN0YXRlUHJvdmlkZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW250eXBlXVxuICAgICAqIEByZXR1cm5zIHtOZW8uc3RhdGUuUHJvdmlkZXJ8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRTdGF0ZVByb3ZpZGVyKG50eXBlKSB7XG4gICAgICAgIGlmICghTmVvLmlzVXNpbmdTdGF0ZVByb3ZpZGVycykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBwcm92aWRlcjtcblxuICAgICAgICBpZiAoIW50eXBlKSB7XG4gICAgICAgICAgICBwcm92aWRlciA9IG1lW2Nsb3Nlc3RQcm92aWRlcl07XG5cbiAgICAgICAgICAgIGlmIChwcm92aWRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm92aWRlclxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcHJvdmlkZXIgPSBtZS5nZXRDb25maWdJbnN0YW5jZUJ5TnR5cGUoJ3N0YXRlUHJvdmlkZXInLCBudHlwZSk7XG5cbiAgICAgICAgaWYgKCFudHlwZSkge1xuICAgICAgICAgICAgbWVbY2xvc2VzdFByb3ZpZGVyXSA9IHByb3ZpZGVyXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJvdmlkZXJcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqL1xuICAgIGluaXRDb25maWcoLi4uYXJncykge1xuICAgICAgICBzdXBlci5pbml0Q29uZmlnKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLmdldFN0YXRlUHJvdmlkZXIoKT8uY3JlYXRlQmluZGluZ3ModGhpcylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uU2Nyb2xsQ2FwdHVyZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICB2bm9kZTtcblxuICAgICAgICBpZiAobWUudm5vZGUpIHtcbiAgICAgICAgICAgIHZub2RlID0gVk5vZGVVdGlsLmdldEJ5SWQobWUudm5vZGUsIGRhdGEudGFyZ2V0LmlkKTtcblxuICAgICAgICAgICAgaWYgKHZub2RlKSB7XG4gICAgICAgICAgICAgICAgLy8gRGlyZWN0bHkgdXBkYXRpbmcgdGhlIHBlcnNpc3RlbnQgdm5vZGUgc3RhdGUgKHBsYWluIG9iamVjdCkuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBkb2VzIG5vdCB0cmlnZ2VyIGEgVkRPTSB1cGRhdGUsIGJ1dCBlbnN1cmVzIHRoZSBzdGF0ZSBpcyBwcmVzZXJ2ZWRcbiAgICAgICAgICAgICAgICAvLyBmb3IgZnV0dXJlIHJlLXJlbmRlcnMgKGUuZy4gdW5tb3VudC9yZW1vdW50KS5cbiAgICAgICAgICAgICAgICB2bm9kZS5zY3JvbGxUb3AgID0gZGF0YS5zY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgdm5vZGUuc2Nyb2xsTGVmdCA9IGRhdGEuc2Nyb2xsTGVmdFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIG11bHRpcGxlIGNvbmZpZ3MgYXQgb25jZSwgZW5zdXJpbmcgdGhhdCBhbGwgYWZ0ZXJTZXQgbWV0aG9kcyBnZXQgYWxsIG5ldyBhc3NpZ25lZCB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzPXt9XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaWxlbnQ9ZmFsc2VcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTwqPn1cbiAgICAgKi9cbiAgICBzZXQodmFsdWVzPXt9LCBzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB3YXNIaWRkZW4gPSBtZS5oaWRkZW47XG5cbiAgICAgICAgbWUuc2V0U2lsZW50KHZhbHVlcyk7XG5cbiAgICAgICAgaWYgKCFzaWxlbnQgJiYgbWUubmVlZHNWZG9tVXBkYXRlKSB7XG4gICAgICAgICAgICBpZiAod2FzSGlkZGVuICYmICFtZS5oaWRkZW4pIHtcbiAgICAgICAgICAgICAgICBtZS5zaG93Py4oKTsgLy8gc2hvdygpIGlzIG5vdCBwYXJ0IG9mIHRoZSBhYnN0cmFjdCBiYXNlIGNsYXNzXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBtZS5wcm9taXNlVXBkYXRlKClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc2lsZW50IHZlcnNpb24gb2Ygc2V0KCksIHdoaWNoIGRvZXMgbm90IHRyaWdnZXIgYSB2ZG9tIHVwZGF0ZSBhdCB0aGUgZW5kLlxuICAgICAqIFVzZWZ1bCBmb3IgYmF0Y2hpbmcgbXVsdGlwbGUgY29uZmlnIGNoYW5nZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlcz17fVxuICAgICAqL1xuICAgIHNldFNpbGVudCh2YWx1ZXM9e30pIHtcbiAgICAgICAgdGhpcy5zaWxlbnRWZG9tVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgc3VwZXIuc2V0KHZhbHVlcyk7XG4gICAgICAgIHRoaXMuc2lsZW50VmRvbVVwZGF0ZSA9IGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXRcbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqL1xuICAgIHNldFN0YXRlKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5nZXRTdGF0ZVByb3ZpZGVyKCkuc2V0RGF0YSguLi5hcmdzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIGNvbXBvbmVudCBpbnRvIGEgSlNPTi1jb21wYXRpYmxlIG9iamVjdC5cbiAgICAgKiBFeHRlbmRzIHRoZSBjb3JlLkJhc2Ugc2VyaWFsaXphdGlvbiB3aXRoIGNvbXBvbmVudC1zcGVjaWZpYyBwcm9wZXJ0aWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcbiAgICAgICAgICAgIGFwcE5hbWUgICAgICA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICBiaW5kICAgICAgICAgOiBtZS5iaW5kID8gT2JqZWN0LmtleXMobWUuYmluZCkgOiBudWxsLFxuICAgICAgICAgICAgbW91bnRlZCAgICAgIDogbWUubW91bnRlZCxcbiAgICAgICAgICAgIHBhcmVudElkICAgICA6IG1lLnBhcmVudElkLFxuICAgICAgICAgICAgc3RhdGVQcm92aWRlcjogbWUuc3RhdGVQcm92aWRlcj8udG9KU09OKCksXG4gICAgICAgICAgICB3aW5kb3dJZCAgICAgOiBtZS53aW5kb3dJZFxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhBYnN0cmFjdCk7XG4iLCJpbXBvcnQgQWJzdHJhY3QgICAgICAgICBmcm9tICcuL0Fic3RyYWN0Lm1qcyc7XG5pbXBvcnQgQ2xhc3NTeXN0ZW1VdGlsICBmcm9tICcuLi91dGlsL0NsYXNzU3lzdGVtLm1qcyc7XG5pbXBvcnQgQ29tcG9uZW50TWFuYWdlciBmcm9tICcuLi9tYW5hZ2VyL0NvbXBvbmVudC5tanMnO1xuaW1wb3J0IEtleU5hdmlnYXRpb24gICAgZnJvbSAnLi4vdXRpbC9LZXlOYXZpZ2F0aW9uLm1qcyc7XG5pbXBvcnQgTG9nZ2VyICAgICAgICAgICBmcm9tICcuLi91dGlsL0xvZ2dlci5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICAgICAgICAgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IFJlY3RhbmdsZSAgICAgICAgZnJvbSAnLi4vdXRpbC9SZWN0YW5nbGUubWpzJztcbmltcG9ydCBTdHlsZSAgICAgICAgICAgIGZyb20gJy4uL3V0aWwvU3R5bGUubWpzJztcbmltcG9ydCBWRG9tVXRpbCAgICAgICAgIGZyb20gJy4uL3V0aWwvVkRvbS5tanMnO1xuaW1wb3J0IFZOb2RlVXRpbCAgICAgICAgZnJvbSAnLi4vdXRpbC9WTm9kZS5tanMnO1xuaW1wb3J0IHtpc0Rlc2NyaXB0b3J9ICAgZnJvbSAnLi4vY29yZS9Db25maWdTeW1ib2xzLm1qcyc7XG5cbmNvbnN0XG4gICAgYWRkVW5pdHMgICAgICAgICAgPSB2YWx1ZSA9PiB2YWx1ZSA9PSBudWxsID8gdmFsdWUgOiBpc05hTih2YWx1ZSkgPyB2YWx1ZSA6IGAke3ZhbHVlfXB4YCxcbiAgICBjbG9zZXN0Q29udHJvbGxlciA9IFN5bWJvbC5mb3IoJ2Nsb3Nlc3RDb250cm9sbGVyJyksXG4gICAgbGVuZ3RoUkUgICAgICAgICAgPSAvXlxcZCtcXHcrJC87XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYWxsIENvbXBvbmVudHMgd2hpY2ggaGF2ZSBhIERPTSByZXByZXNlbnRhdGlvblxuICogQGNsYXNzIE5lby5jb21wb25lbnQuQmFzZVxuICogQGV4dGVuZHMgTmVvLmNvbXBvbmVudC5BYnN0cmFjdFxuICovXG5jbGFzcyBDb21wb25lbnQgZXh0ZW5kcyBBYnN0cmFjdCB7XG4gICAgLyoqXG4gICAgICogVmFsaWQgdmFsdWVzIGZvciBoaWRlTW9kZVxuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBoaWRlTW9kZXM9WydyZW1vdmVEb20nLCd2aXNpYmlsaXR5J11cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBoaWRlTW9kZXMgPSBbJ3JlbW92ZURvbScsICd2aXNpYmlsaXR5J11cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbXBvbmVudC5CYXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29tcG9uZW50LkJhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nY29tcG9uZW50J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2NvbXBvbmVudCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBhbGlnbm1lbnQgc3BlY2lmaWNhdGlvbiB0byBwb3NpdGlvbiB0aGlzIENvbXBvbmVudCByZWxhdGl2ZSB0byBzb21lIG90aGVyXG4gICAgICAgICAqIENvbXBvbmVudCwgb3IgRWxlbWVudCBvciBSZWN0YW5nbGUuIE9ubHkgYXBwbGllcyBpbiBjYXNlIGZsb2F0aW5nID0gdHJ1ZS5cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fFN0cmluZ30gYWxpZ25fPXtbaXNEZXNjcmlwdG9yXTogdHJ1ZSwgbWVyZ2U6ICdkZWVwJywgdmFsdWU6IHtlZGdlQWxpZ246ICd0LWInLGNvbnN0cmFpblRvOiAnZG9jdW1lbnQuYm9keSd9fVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGFsaWduXzoge1xuICAgICAgICAgICAgW2lzRGVzY3JpcHRvcl06IHRydWUsXG4gICAgICAgICAgICBtZXJnZSAgICAgICAgIDogJ2RlZXAnLFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBlZGdlQWxpZ24gIDogJ3QtYicsXG4gICAgICAgICAgICAgICAgY29uc3RyYWluVG86ICdkb2N1bWVudC5ib2R5J1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ1NTIHNlbGVjdG9ycyB0byBhcHBseSB0byB0aGUgcm9vdCBsZXZlbCBub2RlIG9mIHRoaXMgY29tcG9uZW50XG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVtdXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1hbmFnZXIuRm9jdXMgd2lsbCBjaGFuZ2UgdGhpcyBmbGFnIG9uIGZvY3VzaW4gJiBvdXQgZG9tIGV2ZW50c1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBjb250YWluc0ZvY3VzXz1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpbnNGb2N1c186IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQXNzaWduIGEgY29tcG9uZW50IGNvbnRyb2xsZXIgdG8gdGhpcyBjb21wb25lbnQgKHBhc3MgYW4gaW1wb3J0ZWQgbW9kdWxlIG9yIHRoZSBzdHJpbmcgYmFzZWQgY2xhc3MgbmFtZSlcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fFN0cmluZ30gY29udHJvbGxlcl89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGNvbnRyb2xsZXJfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoaXMgY29uZmlnIHRvIHRydWUgdG8gZHluYW1pY2FsbHkgaW1wb3J0IGEgRHJvcFpvbmUgbW9kdWxlICYgY3JlYXRlIGFuIGluc3RhbmNlXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGRyb3BwYWJsZV89ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBkcm9wcGFibGVfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5kcmFnZ2FibGUuRHJvcFpvbmV8bnVsbH0gZHJvcFpvbmU9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZHJvcFpvbmU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGRyb3Bab25lQ29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRyb3Bab25lQ29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSB0byBtb3VudCB0aGlzIGNvbXBvbmVudCBpbnRvIHRoZSB2aWV3cG9ydCBvdXRzaWRlIG9mIHRoZSBkb2N1bWVudCBmbG93XG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGZsb2F0aW5nXG4gICAgICAgICAqL1xuICAgICAgICBmbG9hdGluZzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBmbGFnIHdoaWNoIHdpbGwgZ2V0IHNldCB0byB0cnVlIG9uIG1vdW50XG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGhhc0JlZW5Nb3VudGVkPWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGhhc0JlZW5Nb3VudGVkOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3J0Y3V0IGZvciBzdHlsZS5oZWlnaHQsIGRlZmF1bHRzIHRvIHB4XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxTdHJpbmd8bnVsbH0gaGVpZ2h0Xz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgaGVpZ2h0XzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXRpYWwgc2V0dGluZyB0byBoaWRlIG9yIHNob3cgdGhlIGNvbXBvbmVudCBhbmRcbiAgICAgICAgICogeW91IGNhbiB1c2UgZWl0aGVyIGhpZGUoKS9zaG93KCkgb3IgY2hhbmdlIHRoaXMgY29uZmlnIGRpcmVjdGx5IHRvIGNoYW5nZSB0aGUgaGlkZGVuIHN0YXRlXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGhpZGRlbl89ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBoaWRkZW5fOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZWQgZm9yIGhpZGUgYW5kIHNob3cgYW5kIGRlZmluZXMgaWYgdGhlIGNvbXBvbmVudFxuICAgICAgICAgKiBzaG91bGQgdXNlIGNzcyB2aXNpYmlsaXR5OidoaWRkZW4nIG9yIHZkb206cmVtb3ZlRG9tXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gaGlkZU1vZGVfPSdyZW1vdmVEb20nXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgaGlkZU1vZGVfOiAncmVtb3ZlRG9tJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0b3AgbGV2ZWwgaW5uZXJIVE1MIG9mIHRoZSBjb21wb25lbnRcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGh0bWxfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBodG1sXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0byBgdHJ1ZWAgdG8gc2hvdyBhIHNwaW5uZXIgY2VudGVyZWQgaW4gdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICogU2V0IHRvIGEgc3RyaW5nIHRvIHNob3cgYSBtZXNzYWdlIG5leHQgdG8gYSBzcGlubmVyIGNlbnRlcmVkIGluIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW58U3RyaW5nfSBpc0xvYWRpbmc9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGlzTG9hZGluZ186IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVXNpbmcgdGhlIGtleXMgY29uZmlnIHdpbGwgY3JlYXRlIGFuIGluc3RhbmNlIG9mIE5lby51dGlsLktleU5hdmlnYXRpb24uXG4gICAgICAgICAqIEBzZWUge0BsaW5rIE5lby51dGlsLktleU5hdmlnYXRpb24gS2V5TmF2aWdhdGlvbn1cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBrZXlzXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAga2V5c186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHVzZWQgaW5zaWRlIGFmdGVyU2V0SXNMb2FkaW5nKCkgdG8gZGVmaW5lIHRoZSBDU1MgZm9yIHRoZSBsb2FkaW5nIHNwaW5uZXIgaWNvblxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gbG9hZGluZ1NwaW5uZXJDbHNfPVsnZmEnLCdmYS1zcGlubmVyJywnZmEtc3BpbiddXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbG9hZGluZ1NwaW5uZXJDbHNfOiBbJ2ZhJywgJ2ZhLXNwaW5uZXInLCAnZmEtc3BpbiddLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvcnRjdXQgZm9yIHN0eWxlLm1heEhlaWdodCwgZGVmYXVsdHMgdG8gcHhcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfFN0cmluZ3xudWxsfSBtYXhIZWlnaHRfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBtYXhIZWlnaHRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvcnRjdXQgZm9yIHN0eWxlLm1heFdpZHRoLCBkZWZhdWx0cyB0byBweFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8U3RyaW5nfG51bGx9IG1heFdpZHRoXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbWF4V2lkdGhfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvcnRjdXQgZm9yIHN0eWxlLm1pbkhlaWdodCwgZGVmYXVsdHMgdG8gcHhcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfFN0cmluZ3xudWxsfSBtaW5IZWlnaHRfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBtaW5IZWlnaHRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvcnRjdXQgZm9yIHN0eWxlLm1pbldpZHRoLCBkZWZhdWx0cyB0byBweFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8U3RyaW5nfG51bGx9IG1pbldpZHRoXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbWluV2lkdGhfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQXJyYXkgb2YgUGx1Z2luIE1vZHVsZXMgYW5kIC8gb3IgY29uZmlnIG9iamVjdHNcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl8bnVsbH0gcGx1Z2luc189bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgcGx1Z2luc186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgYSByZWZlcmVuY2UgZm9yIGFjY2Vzc2luZyB0aGUgY29tcG9uZW50IGluc2lkZSB2aWV3IGNvbnRyb2xsZXJzLlxuICAgICAgICAgKiBSZWZlcmVuY2VzIHdpbGwgYWxzbyBnZXQgbWFwcGVkIGludG8gdGhlIHZkb20gcm9vdCAoZGF0YS1yZWY6IHZhbHVlKS5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IHJlZmVyZW5jZV89bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVmZXJlbmNlXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ha2UgdGhlIHZpZXcgUmVzcG9uc2l2ZSBieSBhZGRpbmcgYWx0ZXJuYXRpdmUgY29uZmlncy5cbiAgICAgICAgICogVGhlIGRlZmluaXRpb24gaGFwcGVucyB2aWEgcmVzcG9uc2l2ZUNmZ1xuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHJlc3BvbnNpdmU9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICByZXNwb25zaXZlXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZnkgYSByb2xlIHRhZyBhdHRyaWJ1dGUgZm9yIHRoZSB2ZG9tIHJvb3QuXG4gICAgICAgICAqIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQWNjZXNzaWJpbGl0eS9BUklBL1JvbGVzXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSByb2xlXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgcm9sZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhpcyB0byB0cnVlIGZvciBzdHlsZSAnb3ZlcmZsb3c6YXV0bycuXG4gICAgICAgICAqIFNldCB0aGlzIHRvICd4JyBvciAneScgdG8gYWRkIHN0eWxlICdvdmVyZmxvdy14JyBvciAnb3ZlcmZsb3cteScgdG8gJ2F1dG8nXG4gICAgICAgICAqIE90aGVyIHRoYW4gZmFsc2UgdGhpcyB3aWxsIGFkZCBjbHMgJ25lby1zY3JvbGxhYmxlJy5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbnxcInhcInxcInlcIn0gc2Nyb2xsYWJsZV89ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzY3JvbGxhYmxlXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdHlsZSBhdHRyaWJ1dGVzIGFkZGVkIHRvIHRoaXMgdmRvbSByb290LiBzZWU6IGdldFZkb21Sb290KClcbiAgICAgICAgICpcbiAgICAgICAgICogKipJbXBvcnRhbnQ6KiogV2hlbiBgdmRvbSA9PT0gdmRvbVJvb3RgIChzaW5nbGUgbm9kZSBjb21wb25lbnQpLCB0aGUgYHdyYXBwZXJTdHlsZWAgbWVjaGFuaXNtXG4gICAgICAgICAqIGNyZWF0ZXMgYSBwZXJzaXN0ZW50IHN0YXRlIGxvb3AgdG8gc3VwcG9ydCBydW50aW1lIFZET00gbXV0YXRpb25zLlxuICAgICAgICAgKiBUaGlzIG1lYW5zIHRoYXQgdG8gKnJlbW92ZSogYSBzdHlsZSBwcm9wZXJ0eSB5b3UgcHJldmlvdXNseSBzZXQsIHlvdSBNVVNUIHNldCBpdCB0byBgbnVsbGAuXG4gICAgICAgICAqIFVzaW5nIGBkZWxldGVgIG9yIHNldHRpbmcgYHVuZGVmaW5lZGAgd2lsbCByZXZlcnQgdG8gdGhlIFwicHJldmlvdXMgc3RhdGVcIiwgd2hpY2ggdW5mb3J0dW5hdGVseVxuICAgICAgICAgKiBpbmNsdWRlcyB0aGUgdmVyeSB2YWx1ZSB5b3UgYXJlIHRyeWluZyB0byByZW1vdmUgaWYgaXQgaGFzIGxlYWtlZCBpbnRvIGB3cmFwcGVyU3R5bGVgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHN0eWxlPXtbaXNEZXNjcmlwdG9yXTogdHJ1ZSwgbWVyZ2U6ICdzaGFsbG93JywgdmFsdWU6IG51bGx9XG4gICAgICAgICAqL1xuICAgICAgICBzdHlsZV86IHtcbiAgICAgICAgICAgIFtpc0Rlc2NyaXB0b3JdOiB0cnVlLFxuICAgICAgICAgICAgbWVyZ2UgICAgICAgICA6ICdzaGFsbG93JyxcbiAgICAgICAgICAgIHZhbHVlICAgICAgICAgOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBZb3UgY2FuIHBhc3MgYSB1c2VkIHRoZW1lIGRpcmVjdGx5IHRvIGFueSBjb21wb25lbnQsXG4gICAgICAgICAqIHRvIHN0eWxlIHNwZWNpZmljIGNvbXBvbmVudCB0cmVlcyBkaWZmZXJlbnRseSBmcm9tIHlvdXIgbWFpbiB2aWV3LlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gdGhlbWVfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB0aGVtZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGlsZSBpdCBpcyByZWNvbW1lbmRlZCB0byBkZWZpbmUgdGFncyBpbnNpZGUgdGhlIHZkb20gb2YgY2xhc3NlcyxcbiAgICAgICAgICogdGhpcyBzaG9ydGN1dCBlbmFibGVzIHVzIHRvIGNoYW5nZSB0aGUgdmRvbSByb290IHRhZyBvbiBpbnN0YW5jZSBsZXZlbC5cbiAgICAgICAgICogVXNlIGNhc2VzOiBzd2l0Y2ggYSBUb29sYmFyIHRvIGEgXCJuYXZcIiB0YWcsIHN3aXRjaCBhIFNpZGVOYXYgdG8gYW4gXCJhc2lkZVwiIHRhZy5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IHRhZ189bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHRhZ186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdG9wIGxldmVsIHRleHRDb250ZW50IG9mIHRoZSBjb21wb25lbnRcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IHRleHRfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0XzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCB0b29sdGlwIGNvbmZpZyBvYmplY3Qgb3IgYSBzdHJpbmcgY29udGFpbmluZyB0aGUgZGlzcGxheSB0ZXh0XG4gICAgICAgICAqIFNlZSB0b29sdGlwL0Jhc2UubWpzXG4gICAgICAgICAqXG4gICAgICAgICAqIEJ5IGRlZmF1bHQsIGEgc2luZ2xlLCBzaGFyZWQgVG9vbHRpcCBpbnN0YW5jZSBpcyB1c2VkIGZvciBhbGwgd2lkZ2V0cyB0aGF0IHJlcXVlc3RcbiAgICAgICAgICogYSB0b29sdGlwLiBJdCByZWNvbmZpZ3VyZXMgaXRzZWxmIGZyb20gdGhlIHdpZGdldCdzIGRlZmluaXRpb24ganVzdCBiZWZvcmUgc2hvd2luZy5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYSB3aWRnZXQgbmVlZHMgaXRzIG93biBpbnN0YW5jZSBmb3IgYW55IHJlYXNvbiwgaW5jbHVkZSB0aGUgcHJvcGVydHkgYG93bkluc3RhbmNlOiB0cnVlYFxuICAgICAgICAgKiBpbiB0aGUgdG9vbHRpcCBjb25maWcgb2JqZWN0LlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8U3RyaW5nfSB0b29sdGlwXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdG9vbHRpcF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgJ3ByaW1hcnknIGFuZCBvdGhlciBhdHRyaWJ1dGVzIHRvIG1ha2UgaXQgYW4gb3V0c3RhbmRpbmcgZGVzaWduXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSB1aV89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHVpXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3J0Y3V0IGZvciBzdHlsZS53aWR0aCwgZGVmYXVsdHMgdG8gcHhcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfFN0cmluZ3xudWxsfSB3aWR0aF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHdpZHRoXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfG51bGx9IHdyYXBwZXJDbHNfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB3cmFwcGVyQ2xzXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRvcCBsZXZlbCBzdHlsZSBhdHRyaWJ1dGVzLiBVc2VmdWwgaW4gY2FzZSBnZXRWZG9tUm9vdCgpIGRvZXMgbm90IHBvaW50IHRvIHRoZSB0b3AgbGV2ZWwgRE9NIG5vZGUuXG4gICAgICAgICAqXG4gICAgICAgICAqICoqTm90ZToqKiBUaGUgZ2V0dGVyIGZvciB0aGlzIGNvbmZpZyByZWFkcyBgdmRvbS5zdHlsZWAgYXMgYSBkZWZhdWx0IHZhbHVlIHRvIHN1cHBvcnQgcnVudGltZSBtdXRhdGlvbnMuXG4gICAgICAgICAqIFRoaXMgY3JlYXRlcyB0aGUgcGVyc2lzdGVudCBzdGF0ZSBsb29wIGRlc2NyaWJlZCBpbiB0aGUgYHN0eWxlX2AgY29uZmlnIGRvY3VtZW50YXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSB3cmFwcGVyU3R5bGVfPXtbaXNEZXNjcmlwdG9yXTogdHJ1ZSwgbWVyZ2U6ICdzaGFsbG93JywgdmFsdWU6IG51bGx9XG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgd3JhcHBlclN0eWxlXzoge1xuICAgICAgICAgICAgW2lzRGVzY3JpcHRvcl06IHRydWUsXG4gICAgICAgICAgICBtZXJnZSAgICAgICAgIDogJ3NoYWxsb3cnLFxuICAgICAgICAgICAgdmFsdWUgICAgICAgICA6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB2ZG9tIG1hcmt1cCBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gX3Zkb209e31cbiAgICAgICAgICovXG4gICAgICAgIF92ZG9tOiB7fVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFPYmplY3QuaGFzT3duKG1lLCAnX3Zkb20nKSAmJiBtZS5fdmRvbSkge1xuICAgICAgICAgICAgbWUuX3Zkb20gPSBOZW8uY2xvbmUobWUuX3Zkb20sIHRydWUpXG4gICAgICAgIH1cblxuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIENvbXBvbmVudCBpcyBmdWxseSB2aXNpYmxlLCB0aGF0IGlzIGl0IGlzIG5vdCBoaWRkZW4gYW5kIGhhcyBubyBoaWRkZW4gYW5jZXN0b3JzXG4gICAgICovXG4gICAgZ2V0IGlzVmlzaWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW91bnRlZCAmJiAhdGhpcy5oaWRkZW4gJiYgKCF0aGlzLnBhcmVudCB8fCB0aGlzLnBhcmVudC5pc1Zpc2libGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBzZXR0ZXIgd2lsbCBoYW5kbGUgdmRvbSB1cGRhdGVzIGF1dG9tYXRpY2FsbHlcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHZkb209dGhpcy5fdmRvbVxuICAgICAqL1xuICAgIGdldCB2ZG9tKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmRvbVxuICAgIH1cbiAgICBzZXQgdmRvbSh2YWx1ZSkge1xuICAgICAgICB0aGlzLmFmdGVyU2V0VmRvbSh2YWx1ZSwgdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgbmV3IGNscyB0byB0aGUgdmRvbVJvb3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cbiAgICBhZGRDbHModmFsdWUpIHtcbiAgICAgICAgbGV0IHtjbHN9ID0gdGhpcztcblxuICAgICAgICBOZW9BcnJheS5hZGQoY2xzLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuY2xzID0gY2xzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRWl0aGVyIGEgc3RyaW5nIGxpa2UgJ2NvbG9yOiByZWQ7IGJhY2tncm91bmQtY29sb3I6IGJsdWU7J1xuICAgICAqIG9yIGFuIG9iamVjdCBjb250YWluaW5nIHN0eWxlIGF0dHJpYnV0ZXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHZhbHVlXG4gICAgICogQHJldHVybnMge09iamVjdH0gYWxsIHN0eWxlcyBvZiB0aGlzLmVsXG4gICAgICovXG4gICAgYWRkU3R5bGUodmFsdWUpIHtcbiAgICAgICAgaWYgKE5lby5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gIE5lby5jcmVhdGVTdHlsZU9iamVjdCh2YWx1ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRvZG86IGFkZCBhIGNoZWNrIGlmIHNvbWV0aGluZyBoYXMgY2hhbmdlZFxuXG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlID0gT2JqZWN0LmFzc2lnbih0aGlzLnN0eWxlLCB2YWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBuZXcgd3JhcHBlckNscyB0byB0aGUgdG9wIGxldmVsIG5vZGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cbiAgICBhZGRXcmFwcGVyQ2xzKHZhbHVlKSB7XG4gICAgICAgIGxldCB7d3JhcHBlckNsc30gPSB0aGlzO1xuXG4gICAgICAgIE5lb0FycmF5LmFkZCh3cmFwcGVyQ2xzLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMud3JhcHBlckNscyA9IHdyYXBwZXJDbHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGFwcE5hbWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEFwcE5hbWUodmFsdWUsIG9sZFZhbHVlKSB7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGNscyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXXxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldENscyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWUgPSBvbGRWYWx1ZSB8fCBbXTtcblxuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgdmRvbSAgICAgPSBtZS52ZG9tLFxuICAgICAgICAgICAgdmRvbVJvb3QgPSBtZS5nZXRWZG9tUm9vdCgpLFxuICAgICAgICAgICAgY2xzO1xuXG4gICAgICAgIGlmICh2ZG9tICE9PSB2ZG9tUm9vdCkge1xuICAgICAgICAgICAgLy8gd2UgYXJlIHVzaW5nIGEgd3JhcHBlciBub2RlXG4gICAgICAgICAgICB2ZG9tUm9vdC5jbHMgPSBbLi4udmFsdWVdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIG1lcmdlIGNoYW5nZXNcbiAgICAgICAgICAgIGNscyA9IE5lb0FycmF5LnVuaW9uKG1lLndyYXBwZXJDbHMsIHZhbHVlKTtcbiAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZShjbHMsIE5lb0FycmF5LmRpZmZlcmVuY2Uob2xkVmFsdWUsIHZhbHVlKSk7XG4gICAgICAgICAgICB2ZG9tLmNscyA9IGNsc1xuICAgICAgICB9XG5cbiAgICAgICAgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGRpc2FibGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RGlzYWJsZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBjbHMgPSB0aGlzLmNscztcblxuICAgICAgICBOZW9BcnJheVt2YWx1ZSA/ICdhZGQnIDogJ3JlbW92ZSddKGNscywgJ25lby1kaXNhYmxlZCcpO1xuICAgICAgICB0aGlzLmNscyA9IGNsc1xuICAgIH1cblxuXG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGRyb3BwYWJsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldERyb3BwYWJsZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAodmFsdWUgJiYgIW1lLmRyb3Bab25lKSB7XG4gICAgICAgICAgICBpbXBvcnQoJy4uL2RyYWdnYWJsZS9Ecm9wWm9uZS5tanMnKS50aGVuKG1vZHVsZSA9PiB7XG4gICAgICAgICAgICAgICAgbWUuZHJvcFpvbmUgPSBOZW8uY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlICA6IG1vZHVsZS5kZWZhdWx0LFxuICAgICAgICAgICAgICAgICAgICBhcHBOYW1lIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgb3duZXIgICA6IG1lLFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3dJZDogbWUud2luZG93SWQsXG4gICAgICAgICAgICAgICAgICAgIC4uLm1lLmRyb3Bab25lQ29uZmlnXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGhlaWdodCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRIZWlnaHQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJlZEhlaWdodCA9IGFkZFVuaXRzKHZhbHVlKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VWZG9tUm9vdEtleSgnaGVpZ2h0JywgdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBoaWRkZW4gY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRIaWRkZW4odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICBzdGF0ZSA9IHZhbHVlID8gJ2hpZGUnIDogJ3Nob3cnO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiBvbGRWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIG1lLmhpZGVNb2RlID09PSAncmVtb3ZlRG9tJykge1xuICAgICAgICAgICAgbWUudmRvbS5yZW1vdmVEb20gPSB0cnVlXG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgfHwgb2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbWVbc3RhdGVdKClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIG1lLnJldmVydEZvY3VzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBtZS5maXJlKHN0YXRlLCB7aWQ6IG1lLmlkfSk7XG4gICAgICAgIG1lLmZpcmUoJ2hpZGRlbkNoYW5nZScsIHtpZDogbWUuaWQsIG9sZFZhbHVlLCB2YWx1ZX0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBodG1sIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRIdG1sKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmNoYW5nZVZkb21Sb290S2V5KCdodG1sJywgdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBpZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0SWQodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5jb25maWdzQXBwbGllZCkge1xuICAgICAgICAgICAgbWUuZW5zdXJlU3RhYmxlSWRzKCk7XG4gICAgICAgICAgICBtZS51cGRhdGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBpc0xvYWRpbmcgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldElzTG9hZGluZyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIHx8IG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHt3cmFwcGVyQ2xzLCB2ZG9tfSA9IG1lLFxuICAgICAgICAgICAgICAgIG1hc2tJbmRleDtcblxuICAgICAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmRvbS5jbikge1xuICAgICAgICAgICAgICAgIG1hc2tJbmRleCA9IHZkb20uY24uZmluZExhc3RJbmRleChjID0+IGMuY2xzPy5pbmNsdWRlcygnbmVvLWxvYWQtbWFzaycpKTtcblxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbG9hZCBtYXNrXG4gICAgICAgICAgICAgICAgaWYgKG1hc2tJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmRvbS5jbi5zcGxpY2UobWFza0luZGV4LCAxKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2ZG9tLmNuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZkb20uY24gPSBbXVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZkb20uY24ucHVzaChtZS5jcmVhdGVMb2FkaW5nTWFzayh2YWx1ZSkpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE5lb0FycmF5LnRvZ2dsZSh3cmFwcGVyQ2xzLCAnbmVvLW1hc2tlZCcsIHZhbHVlKTtcbiAgICAgICAgICAgIG1lLnNldCh7dmRvbSwgd3JhcHBlckNsc30pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1heEhlaWdodCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNYXhIZWlnaHQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJlZE1heEhlaWdodCA9IGFkZFVuaXRzKHZhbHVlKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VWZG9tUm9vdEtleSgnbWF4SGVpZ2h0JywgdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtYXhXaWR0aCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNYXhXaWR0aCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmVkTWF4V2lkdGggPSBhZGRVbml0cyh2YWx1ZSk7XG4gICAgICAgIHRoaXMuY2hhbmdlVmRvbVJvb3RLZXkoJ21heFdpZHRoJywgdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtaW5IZWlnaHQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TWluSGVpZ2h0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyZWRNaW5IZWlnaHQgPSBhZGRVbml0cyh2YWx1ZSk7XG4gICAgICAgIHRoaXMuY2hhbmdlVmRvbVJvb3RLZXkoJ21pbkhlaWdodCcsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbWluV2lkdGggY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TWluV2lkdGgodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJlZE1pbldpZHRoID0gYWRkVW5pdHModmFsdWUpO1xuICAgICAgICB0aGlzLmNoYW5nZVZkb21Sb290S2V5KCdtaW5XaWR0aCcsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbW91bnRlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUpIHsgLy8gbW91bnRcbiAgICAgICAgICAgICAgICBtZS5oYXNCZWVuTW91bnRlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBpZiAobWUuZmxvYXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuYWxpZ25UbygpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvY3VzIHdpbGwgYmUgcHVzaGVkIGludG8gdGhlIGZpcnN0IGlucHV0IGZpZWxkIG9yIG90aGVyIGZvY3VzYWJsZSBpdGVtXG4gICAgICAgICAgICAgICAgICAgIG1lLmZvY3VzKG1lLmlkLCB0cnVlKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1lLmZpcmUoJ21vdW50ZWQnLCBtZS5pZCk7XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyB1bm1vdW50XG4gICAgICAgICAgICAgICAgbWUucmV2ZXJ0Rm9jdXMoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSByZWZlcmVuY2UgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFJlZmVyZW5jZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdmFsdWUgJiYgdGhpcy5jaGFuZ2VWZG9tUm9vdEtleSgnZGF0YS1yZWYnLCB2YWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHJlc3BvbnNpdmUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIGFmdGVyU2V0UmVzcG9uc2l2ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICYmICF0aGlzLmdldFBsdWdpbigncmVzcG9uc2l2ZScpKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgbW9kdWxlICA9IGF3YWl0IGltcG9ydChgLi4vLi4vc3JjL3BsdWdpbi9SZXNwb25zaXZlLm1qc2ApLFxuICAgICAgICAgICAgICAgIHBsdWdpbnMgPSBtZS5wbHVnaW5zIHx8IFtdO1xuXG4gICAgICAgICAgICBwbHVnaW5zLnB1c2goe1xuICAgICAgICAgICAgICAgIG1vZHVsZSA6IG1vZHVsZS5kZWZhdWx0LFxuICAgICAgICAgICAgICAgIGFwcE5hbWU6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS5wbHVnaW5zID0gcGx1Z2luc1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSByb2xlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRSb2xlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmNoYW5nZVZkb21Sb290S2V5KCdyb2xlJywgdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzY3JvbGxhYmxlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEJvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8Qm9vbGVhbnxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNjcm9sbGFibGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICF2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChvbGRWYWx1ZSkge1xuICAgICAgICAgICAgbGV0IG9sZE92ZXJmbG93S2V5ID0gJ292ZXJmbG93JztcblxuICAgICAgICAgICAgaWYgKCFOZW8uaXNCb29sZWFuKG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG9sZE92ZXJmbG93S2V5ICs9IE5lby5jYXBpdGFsaXplKG9sZFZhbHVlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5yZW1vdmVTdHlsZShbb2xkT3ZlcmZsb3dLZXldKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFOZW8uaXNFbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGxldCBvdmVyZmxvd0tleSA9ICdvdmVyZmxvdyc7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiAhTmVvLmlzQm9vbGVhbih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvd0tleSArPSBOZW8uY2FwaXRhbGl6ZSh2YWx1ZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbWUuYWRkU3R5bGUob3ZlcmZsb3dLZXkgKyAnOmF1dG8nKTtcbiAgICAgICAgICAgICAgICBtZS5hZGRDbHMoJ25lby1zY3JvbGxhYmxlJylcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWUucmVtb3ZlQ2xzKCduZW8tc2Nyb2xsYWJsZScpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHN0eWxlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFN0eWxlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAoISghdmFsdWUgJiYgb2xkVmFsdWUgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3R5bGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB0YWcgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFRhZyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdmFsdWUgJiYgdGhpcy5jaGFuZ2VWZG9tUm9vdEtleSgndGFnJywgdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB0aGVtZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VGhlbWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSB8fCBvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHtjbHN9ICAgICAgID0gbWUsXG4gICAgICAgICAgICAgICAgbmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKG9sZFZhbHVlICYmIGNscy5pbmNsdWRlcyhvbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUoY2xzLCBvbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgbmVlZHNVcGRhdGUgPSB0cnVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdlIGRvIG5vdCBuZWVkIHRvIGFkZCBhIERPTSBiYXNlZCBDU1Mgc2VsZWN0b3IsIGluIGNhc2UgdGhlIHRoZW1lIGlzIGFscmVhZHkgaW5oZXJpdGVkXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IG1lLnBhcmVudD8udGhlbWUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSAmJiBOZW9BcnJheS5hZGQoY2xzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgbmVlZHNVcGRhdGUgPSB0cnVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuZWVkc1VwZGF0ZSkge1xuICAgICAgICAgICAgICAgIG1lLmNscyA9IGNsc1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB0ZXh0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRUZXh0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmNoYW5nZVZkb21Sb290S2V5KCd0ZXh0JywgdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB0b29sdGlwIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VG9vbHRpcCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWU/LmRlc3Ryb3k/LigpO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKE5lby5ucygnTmVvLnRvb2x0aXAuQmFzZScpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVUb29sdGlwKHZhbHVlKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbXBvcnQoJy4uL3Rvb2x0aXAvQmFzZS5tanMnKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVUb29sdGlwKHZhbHVlKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3Igc3R5bGluZyBwdXJwb3NlcyBvbmx5LlxuICAgICAqIFRvIGRlZmluZSBidXR0b24gc3R5bGVzIG9yIGNvbXBvbmVudCBzdHlsZXMsXG4gICAgICogdGhpcyB3aWxsIGFkZCBhIGNzcyBjbGFzczogbmVvLW50eXBlLXZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIGFmdGVyU2V0VWkodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgPSB0aGlzLFxuICAgICAgICAgICAgY2xzID0gbWUuY2xzO1xuXG4gICAgICAgIGlmIChvbGRWYWx1ZSkge1xuICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgYG5lby0ke21lLm50eXBlfS0ke29sZFZhbHVlfWApXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgICBOZW9BcnJheS5hZGQoY2xzLCBgbmVvLSR7bWUubnR5cGV9LSR7dmFsdWV9YClcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmNscyA9IGNsc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgd2lkdGggY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0V2lkdGgodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJlZFdpZHRoID0gYWRkVW5pdHModmFsdWUpO1xuICAgICAgICB0aGlzLmNoYW5nZVZkb21Sb290S2V5KCd3aWR0aCcsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgd2luZG93SWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFdpbmRvd0lkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldFdpbmRvd0lkKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgbGV0IGNvbnRyb2xsZXIgPSB0aGlzLmNvbnRyb2xsZXI7XG5cbiAgICAgICAgaWYgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIud2luZG93SWQgPSB2YWx1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB3cmFwcGVyQ2xzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nW118bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0V3JhcHBlckNscyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWUgPSBvbGRWYWx1ZSB8fCBbXTtcbiAgICAgICAgdmFsdWUgICAgPSB2YWx1ZSAgICB8fCBbXTtcblxuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3Zkb219ICAgPSBtZSxcbiAgICAgICAgICAgIHZkb21Sb290ID0gbWUuZ2V0VmRvbVJvb3QoKSxcbiAgICAgICAgICAgIGNscyAgICAgID0gdmRvbS5jbHMgfHwgW107XG5cbiAgICAgICAgaWYgKHZkb20gPT09IHZkb21Sb290KSB7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIG1lcmdlIGNoYW5nZXNcbiAgICAgICAgICAgIGNscyA9IE5lb0FycmF5LnVuaW9uKGNscywgdmFsdWUpO1xuICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgTmVvQXJyYXkuZGlmZmVyZW5jZShvbGRWYWx1ZSwgdmFsdWUpKTtcbiAgICAgICAgICAgIHZkb20uY2xzID0gY2xzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB3ZSBhcmUgbm90IHVzaW5nIGEgd3JhcHBlciA9PiBjbHMgJiB3cmFwcGVyQ2xzIHNoYXJlIHRoZSBzYW1lIG5vZGVcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgPyB2YWx1ZSA6IFtdO1xuXG4gICAgICAgICAgICBvbGRWYWx1ZSAmJiBOZW9BcnJheS5yZW1vdmUoY2xzLCBvbGRWYWx1ZSk7XG4gICAgICAgICAgICBOZW9BcnJheS5hZGQoY2xzLCB2YWx1ZSk7XG5cbiAgICAgICAgICAgIHZkb20uY2xzID0gY2xzXG4gICAgICAgIH1cblxuICAgICAgICBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgd3JhcHBlclN0eWxlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFdyYXBwZXJTdHlsZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKCEoIXZhbHVlICYmIG9sZFZhbHVlID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0eWxlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsaWducyB0aGUgdG9wIGxldmVsIG5vZGUgaW5zaWRlIHRoZSBtYWluIHRocmVhZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcGVjPXt9XG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYXN5bmMgYWxpZ25UbyhzcGVjPXt9KSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICBhbGlnbiA9IHtcbiAgICAgICAgICAgICAgICAuLi5tZS5hbGlnbixcbiAgICAgICAgICAgICAgICAuLi5zcGVjLFxuICAgICAgICAgICAgICAgIGlkICAgICAgICAgICAgICAgICA6IG1lLmlkLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyZWRGbGV4ICAgICA6IG1lLmNvbmZpZ3VyZWRGbGV4LFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyZWRXaWR0aCAgICA6IG1lLmNvbmZpZ3VyZWRXaWR0aCxcbiAgICAgICAgICAgICAgICBjb25maWd1cmVkSGVpZ2h0ICAgOiBtZS5jb25maWd1cmVkSGVpZ2h0LFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyZWRNaW5XaWR0aCA6IG1lLmNvbmZpZ3VyZWRNaW5XaWR0aCxcbiAgICAgICAgICAgICAgICBjb25maWd1cmVkTWluSGVpZ2h0OiBtZS5jb25maWd1cmVkTWluSGVpZ2h0LFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyZWRNYXhXaWR0aCA6IG1lLmNvbmZpZ3VyZWRNYXhXaWR0aCxcbiAgICAgICAgICAgICAgICBjb25maWd1cmVkTWF4SGVpZ2h0OiBtZS5jb25maWd1cmVkTWF4SGVpZ2h0LFxuICAgICAgICAgICAgICAgIHdpbmRvd0lkICAgICAgICAgICA6IG1lLndpbmRvd0lkXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGlmIChhbGlnbi50YXJnZXQpIHtcbiAgICAgICAgICAgIGF3YWl0IE5lby5tYWluLkRvbUFjY2Vzcy5hbGlnbihhbGlnbilcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIGFjY2Vzc2luZyB0aGUgY2xzIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nW118bnVsbH0gdmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlR2V0Q2xzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA/IFsuLi52YWx1ZV0gOiBbXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIGFjY2Vzc2luZyB0aGUgc3R5bGUgY29uZmlnXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZUdldFN0eWxlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7Li4udmFsdWV9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gYWNjZXNzaW5nIHRoZSB3cmFwcGVyQ2xzIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nW118bnVsbH0gdmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlR2V0V3JhcHBlckNscyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPyBbLi4udmFsdWVdIDogW11cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhY2Nlc3NpbmcgdGhlIHdyYXBwZXJTdHlsZSBjb25maWcuXG4gICAgICpcbiAgICAgKiBJdCBtZXJnZXMgdGhlIGN1cnJlbnQgYHZkb20uc3R5bGVgIGludG8gdGhlIHJlc3VsdCB0byBlbnN1cmUgdGhhdCBydW50aW1lIHN0eWxlIG11dGF0aW9uc1xuICAgICAqIChoYWNrcykgb3IgaW5pdGlhbCBWRE9NIHN0eWxlcyBhcmUgcHJlc2VydmVkIGFuZCBub3Qgb3ZlcndyaXR0ZW4gYnkgdGhlIGNvbmZpZyB2YWx1ZS5cbiAgICAgKlxuICAgICAqICoqV2FybmluZzoqKiBUaGlzIGNyZWF0ZXMgdGhlIHBlcnNpc3RlbnQgc3RhdGUgbG9vcCBkZXNjcmliZWQgaW4gdGhlIGBzdHlsZV9gIGNvbmZpZy5cbiAgICAgKiBSZWFkaW5nIHRoZSBvdXRwdXQgKGB2ZG9tLnN0eWxlYCkgYXMgdGhlIGRlZmF1bHQgZm9yIHRoZSBpbnB1dCAoYHdyYXBwZXJTdHlsZWApIG1lYW5zXG4gICAgICogbWVyZ2VkIHN0eWxlcyBiZWNvbWUgcGVybWFuZW50IHVubGVzcyBleHBsaWNpdGx5IGNsZWFyZWQgd2l0aCBgbnVsbGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlR2V0V3JhcHBlclN0eWxlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7Li4uT2JqZWN0LmFzc2lnbih0aGlzLnZkb20uc3R5bGUgfHwge30sIHZhbHVlKX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBhbGlnbiBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRBbGlnbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvLyBKdXN0IGEgc2ltcGxlICd0LWInXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHtcbiAgICAgICAgICAgICAgICBlZGdlQWxpZ246IHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBjbHMgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge1N0cmluZ1tdfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRDbHModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiBOZW9BcnJheS51bmlvbih2YWx1ZSB8fCBbXSwgdGhpcy5iYXNlQ2xzLCB0aGlzLmdldEJhc2VDbGFzcygpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBjb250cm9sbGVyIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQ3JlYXRlcyBhIGNvbnRyb2xsZXIuQ29tcG9uZW50IGluc3RhbmNlIGlmIG5lZWRlZC5cbiAgICAgKiBAcGFyYW0ge05lby5jb250cm9sbGVyLkNvbXBvbmVudHxPYmplY3R9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRDb250cm9sbGVyKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZT8uZGVzdHJveSgpO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIENsYXNzU3lzdGVtVXRpbC5iZWZvcmVTZXRJbnN0YW5jZSh2YWx1ZSwgJ05lby5jb250cm9sbGVyLkNvbXBvbmVudCcsIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgd2luZG93SWQgOiB0aGlzLndpbmRvd0lkXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgZG9tTGlzdGVuZXJzIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R8T2JqZWN0W119IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0W119XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldERvbUxpc3RlbmVycyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKE5lby5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gW3ZhbHVlXVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlIHx8IFtdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgaGlkZU1vZGUgY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldEhpZGVNb2RlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnaGlkZU1vZGUnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGtleXMgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBDcmVhdGVzIGEgS2V5TmF2aWdhdGlvbiBpbnN0YW5jZSBpZiBuZWVkZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge05lby51dGlsLktleU5hdmlnYXRpb258bnVsbH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0S2V5cyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWU/LmRlc3Ryb3koKTtcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gQ2xhc3NTeXN0ZW1VdGlsLmJlZm9yZVNldEluc3RhbmNlKHZhbHVlLCBLZXlOYXZpZ2F0aW9uLCB7XG4gICAgICAgICAgICAgICAga2V5RG93bkV2ZW50QnViYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGtleXMgICAgICAgICAgICAgIDogdmFsdWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBwbHVnaW5zIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtOZW8ucGx1Z2luLkJhc2VbXX1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0UGx1Z2lucyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhbHVlW2luZGV4XSA9IENsYXNzU3lzdGVtVXRpbC5iZWZvcmVTZXRJbnN0YW5jZShpdGVtLCBudWxsLCB7XG4gICAgICAgICAgICAgICAgICAgIG93bmVyOiB0aGlzXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBzaWxlbnRWZG9tVXBkYXRlIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRTaWxlbnRWZG9tVXBkYXRlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiBOZW8uaXNOdW1iZXIob2xkVmFsdWUpID8gKG9sZFZhbHVlICsgMSkgOiAxXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKE5lby5pc051bWJlcihvbGRWYWx1ZSkgJiYgb2xkVmFsdWUgPiAwKSA/IChvbGRWYWx1ZSAtIDEpIDogMFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHVwZGF0ZURlcHRoIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0VXBkYXRlRGVwdGgodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvbGRWYWx1ZSA9PT0gLTEgfHwgdmFsdWUgPT09IC0xID8gLTEgOiBNYXRoLm1heCh2YWx1ZSwgb2xkVmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgdmFsdWUgb2YgYSB2ZG9tIG9iamVjdCBhdHRyaWJ1dGUgb3IgcmVtb3ZlcyBpdCBpbiBjYXNlIGl0IGhhcyBubyB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fE51bWJlcnxPYmplY3R8U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICovXG4gICAgY2hhbmdlVmRvbVJvb3RLZXkoa2V5LCB2YWx1ZSkge1xuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICByb290ID0gbWUuZ2V0VmRvbVJvb3QoKTtcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJvb3Rba2V5XSA9IHZhbHVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgcm9vdFtrZXldXG4gICAgICAgIH1cblxuICAgICAgICBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGluIGNhc2UgeW91IG5lZWQgZGlmZmVyZW50IG1hc2sgbWFya3Vwcy5cbiAgICAgKiBUaGUgcmVtb3ZhbCBsb2dpYyByZWxpZXMgb24gdGhlIHRvcCBsZXZlbCBub2RlIGhhdmluZyB0aGUgY2xzICduZW8tbG9hZC1tYXNrJ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbnxTdHJpbmd9IGxvYWRpbmdNZXNzYWdlXG4gICAgICogQHJldHVybnMge09iamVjdH0gdmRvbVxuICAgICAqL1xuICAgIGNyZWF0ZUxvYWRpbmdNYXNrKGxvYWRpbmdNZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjbHM6IFsnbmVvLWxvYWQtbWFzayddLFxuICAgICAgICAgICAgY24gOiBbe1xuICAgICAgICAgICAgICAgIGNsczogWyduZW8tbG9hZC1tYXNrLWJvZHknXSxcbiAgICAgICAgICAgICAgICBjbiA6IFt7XG4gICAgICAgICAgICAgICAgICAgIGNsczogdGhpcy5sb2FkaW5nU3Bpbm5lckNsc1xuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgY2xzICAgICAgOiBbJ25lby1sb2FkaW5nLW1lc3NhZ2UnXSxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRG9tOiAhTmVvLmlzU3RyaW5nKGxvYWRpbmdNZXNzYWdlKSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dCAgICAgOiBsb2FkaW5nTWVzc2FnZVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9XVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgdG9vbHRpcCBpbnN0YW5jZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNyZWF0ZVRvb2x0aXAodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbHVlID0ge1xuICAgICAgICAgICAgICAgIHRleHQ6IHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZS5vd25JbnN0YW5jZSkge1xuICAgICAgICAgICAgbWUuX3Rvb2x0aXAgPSBOZW8uY3JlYXRlKCdOZW8udG9vbHRpcC5CYXNlJywge1xuICAgICAgICAgICAgICAgIC4uLnZhbHVlLFxuICAgICAgICAgICAgICAgIGFwcE5hbWUgICAgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudElkOiBtZS5pZCxcbiAgICAgICAgICAgICAgICB3aW5kb3dJZCAgIDogbWUud2luZG93SWRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5fdG9vbHRpcCA9IHZhbHVlO1xuICAgICAgICAgICAgTmVvLnRvb2x0aXAuQmFzZS5jcmVhdGVTaW5nbGV0b24obWUuYXBwKTtcbiAgICAgICAgICAgIG1lLmFkZENscygnbmVvLXVzZXMtc2hhcmVkLXRvb2x0aXAnKTtcbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVbnJlZ2lzdGVyIHRoaXMgaW5zdGFuY2UgZnJvbSB0aGUgQ29tcG9uZW50TWFuYWdlclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdXBkYXRlUGFyZW50VmRvbT1mYWxzZSB0cnVlIHRvIHJlbW92ZSB0aGUgY29tcG9uZW50IGZyb20gdGhlIHBhcmVudCB2ZG9tID0+IHJlYWwgZG9tXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaWxlbnQ9ZmFsc2UgdHJ1ZSB0byB1cGRhdGUgdGhlIHZkb20gc2lsZW50bHkgKHVzZWZ1bCBmb3IgZGVzdHJveWluZyBtdWx0aXBsZSBjaGlsZCBpdGVtcyBpbiBhIHJvdylcbiAgICAgKiB0b2RvOiB1bnJlZ2lzdGVyIGV2ZW50c1xuICAgICAqL1xuICAgIGRlc3Ryb3kodXBkYXRlUGFyZW50VmRvbT1mYWxzZSwgc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3BhcmVudCwgcGFyZW50SWR9ID0gbWUsXG4gICAgICAgICAgICBwYXJlbnRWZG9tO1xuXG4gICAgICAgIG1lLnJldmVydEZvY3VzKCk7XG5cbiAgICAgICAgbWUuY29udHJvbGxlciA9IG51bGw7IC8vIHRyaWdnZXJzIGRlc3Ryb3koKVxuXG4gICAgICAgIG1lLnJlZmVyZW5jZSAmJiBtZS5nZXRDb250cm9sbGVyKCk/LnJlbW92ZVJlZmVyZW5jZShtZSk7IC8vIHJlbW92ZSBvd24gcmVmZXJlbmNlIGZyb20gcGFyZW50IGNvbnRyb2xsZXJzXG5cbiAgICAgICAgbWUucGx1Z2lucz8uZm9yRWFjaChwbHVnaW4gPT4ge1xuICAgICAgICAgICAgcGx1Z2luLmRlc3Ryb3koKVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodXBkYXRlUGFyZW50VmRvbSAmJiBwYXJlbnRJZCkge1xuICAgICAgICAgICAgaWYgKHBhcmVudElkID09PSAnZG9jdW1lbnQuYm9keScpIHtcbiAgICAgICAgICAgICAgICBOZW8uYXBwbHlEZWx0YXMobWUud2luZG93SWQsIHthY3Rpb246ICdyZW1vdmVOb2RlJywgaWQ6IG1lLnZkb20uaWR9KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRWZG9tID0gcGFyZW50LnZkb207XG5cbiAgICAgICAgICAgICAgICBWRG9tVXRpbC5yZW1vdmVWZG9tQ2hpbGQocGFyZW50VmRvbSwgbWUudmRvbS5pZCk7XG4gICAgICAgICAgICAgICAgcGFyZW50W3NpbGVudCA/ICdfdmRvbScgOiAndmRvbSddID0gcGFyZW50VmRvbVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuXG4gICAgICAgIC8vIFdlIGRvIHdhbnQgdG8gcHJldmVudCBkZWxheWVkIGNhbGxzIGFmdGVyIGEgY29tcG9uZW50IGluc3RhbmNlIGdvdCBkZXN0cm95ZWQuXG4gICAgICAgIG1lLm9uRm9jdXNMZWF2ZSA9IE5lby5lbXB0eUZuO1xuICAgICAgICBtZS51bm1vdW50ICAgICAgPSBOZW8uZW1wdHlGblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIHNob3J0Y3V0IGZvciBOZW8ubWFuYWdlci5Db21wb25lbnQuZG93blxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gY29uZmlnXG4gICAgICogQHBhcmFtIHtCb29sZWFufSByZXR1cm5GaXJzdE1hdGNoPXRydWVcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9IFRoZSBtYXRjaGluZyBpbnN0YW5jZSBvciBudWxsXG4gICAgICovXG4gICAgZG93bihjb25maWcsIHJldHVybkZpcnN0TWF0Y2g9dHJ1ZSkge1xuICAgICAgICByZXR1cm4gQ29tcG9uZW50TWFuYWdlci5kb3duKHRoaXMsIGNvbmZpZywgcmV0dXJuRmlyc3RNYXRjaClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxscyBmb2N1cygpIG9uIHRoZSB0b3AgbGV2ZWwgRE9NIG5vZGUgb2YgdGhpcyBjb21wb25lbnQgb3Igb24gYSBnaXZlbiBub2RlIHZpYSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZD10aGlzLmlkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjaGlsZHJlbj1mYWxzZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJldmVudFNjcm9sbFxuICAgICAqL1xuICAgIGZvY3VzKGlkPXRoaXMuaWQsIGNoaWxkcmVuPWZhbHNlLCBwcmV2ZW50U2Nyb2xsKSB7XG4gICAgICAgIE5lby5tYWluLkRvbUFjY2Vzcy5mb2N1cyh7Y2hpbGRyZW4sIGlkLCBwcmV2ZW50U2Nyb2xsLCB3aW5kb3dJZDogdGhpcy53aW5kb3dJZH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gYWRkIGR5bmFtaWMgdmFsdWVzIGludG8gdGhpcy5jbHNcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nW119XG4gICAgICovXG4gICAgZ2V0QmFzZUNsYXNzKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcblxuICAgICAgICBpZiAodGhpcy5mbG9hdGluZykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goJ25lby1mbG9hdGluZycpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGlzLmNvbnRyb2xsZXIgb3IgdGhlIGNsb3Nlc3QgcGFyZW50IGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW250eXBlXVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRDb250cm9sbGVyKG50eXBlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBjb250cm9sbGVyO1xuXG4gICAgICAgIGlmICghbnR5cGUpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIgPSBtZVtjbG9zZXN0Q29udHJvbGxlcl07XG5cbiAgICAgICAgICAgIGlmIChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRyb2xsZXIgPSBtZS5nZXRDb25maWdJbnN0YW5jZUJ5TnR5cGUoJ2NvbnRyb2xsZXInLCBudHlwZSk7XG5cbiAgICAgICAgaWYgKCFudHlwZSkge1xuICAgICAgICAgICAgbWVbY2xvc2VzdENvbnRyb2xsZXJdID0gY29udHJvbGxlclxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXJcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nW118U3RyaW5nfSBpZD10aGlzLmlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHdpbmRvd0lkPXRoaXMud2luZG93SWRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxOZW8udXRpbC5SZWN0YW5nbGV8TmVvLnV0aWwuUmVjdGFuZ2xlW10+fVxuICAgICAqL1xuICAgIGFzeW5jIGdldERvbVJlY3QoaWQ9dGhpcy5pZCwgd2luZG93SWQ9dGhpcy53aW5kb3dJZCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgdGhpcy50cmFwKE5lby5tYWluLkRvbUFjY2Vzcy5nZXRCb3VuZGluZ0NsaWVudFJlY3Qoe2lkLCB3aW5kb3dJZH0pKTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0Lm1hcChyZWN0ID0+IFJlY3RhbmdsZS5jbG9uZShyZWN0KSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBSZWN0YW5nbGUuY2xvbmUocmVzdWx0KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcGFyZW50IGNvbXBvbmVudHMgYXMgYW4gYXJyYXlcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlW119XG4gICAgICovXG4gICAgZ2V0UGFyZW50cygpIHtcbiAgICAgICAgcmV0dXJuIENvbXBvbmVudE1hbmFnZXIuZ2V0UGFyZW50cyh0aGlzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gb3B0c1xuICAgICAqIEByZXR1cm5zIHtOZW8ucGx1Z2luLkJhc2V8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRQbHVnaW4ob3B0cykge1xuICAgICAgICBpZiAoTmVvLmlzU3RyaW5nKG9wdHMpKSB7XG4gICAgICAgICAgICBpZiAoIW9wdHMuc3RhcnRzV2l0aCgncGx1Z2luLScpKSB7XG4gICAgICAgICAgICAgICAgb3B0cyA9ICdwbHVnaW4tJyArIG9wdHNcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3B0cyA9IHtudHlwZTogb3B0c31cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBoYXNNYXRjaDtcblxuICAgICAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBtZS5wbHVnaW5zIHx8IFtdKSB7XG4gICAgICAgICAgICBoYXNNYXRjaCA9IHRydWU7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9wdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luW2tleV0gIT09IG9wdHNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBoYXNNYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGhhc01hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjb252ZW5pZW5jZSBzaG9ydGN1dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRSZWZlcmVuY2UodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG93bih7cmVmZXJlbmNlOiB2YWx1ZX0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2Fsa3MgdXAgdGhlIHZkb20gdHJlZSBhbmQgcmV0dXJucyB0aGUgY2xvc2VzdCB0aGVtZSBmb3VuZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0VGhlbWUoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHRoZW1lTWF0Y2ggPSAnbmVvLXRoZW1lLScsXG4gICAgICAgICAgICBtYWluVmlldywgcGFyZW50Tm9kZXM7XG5cbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIG1lLmNscyB8fCBbXSkge1xuICAgICAgICAgICAgaWYgKGl0ZW0uc3RhcnRzV2l0aCh0aGVtZU1hdGNoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtYWluVmlldyA9IG1lLmFwcD8ubWFpblZpZXc7XG5cbiAgICAgICAgaWYgKG1haW5WaWV3KSB7XG4gICAgICAgICAgICBwYXJlbnROb2RlcyA9IFZEb21VdGlsLmdldFBhcmVudE5vZGVzKG1haW5WaWV3LnZkb20sIG1lLmlkKTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIHBhcmVudE5vZGVzIHx8IFtdKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIG5vZGUuY2xzIHx8IFtdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnN0YXJ0c1dpdGgodGhlbWVNYXRjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTmVvLmNvbmZpZy50aGVtZXM/LlswXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhpZGUgdGhlIGNvbXBvbmVudC5cbiAgICAgKiBoaWRlTW9kZTogJ3JlbW92ZURvbScgIHVzZXMgdmRvbSByZW1vdmVEb20uXG4gICAgICogaGlkZU1vZGU6ICd2aXNpYmlsaXR5JyB1c2VzIGNzcyB2aXNpYmlsaXR5LlxuICAgICAqIElmIGhpZGVNb2RlID09PSAncmVtb3ZlRG9tJyB5b3UgY2FuIHBhc3MgYSB0aW1lb3V0IGZvciBjdXN0b20gY3NzIGNsYXNzIGhpZGluZy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGltZW91dFxuICAgICAqL1xuICAgIGhpZGUodGltZW91dCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5oaWRlTW9kZSAhPT0gJ3Zpc2liaWxpdHknKSB7XG4gICAgICAgICAgICBsZXQgcmVtb3ZlRm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lLnBhcmVudElkICE9PSAnZG9jdW1lbnQuYm9keScpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUudmRvbS5yZW1vdmVEb20gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBtZS5wYXJlbnQudXBkYXRlRGVwdGggPSAyO1xuICAgICAgICAgICAgICAgICAgICBtZS5wYXJlbnQudXBkYXRlKClcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZS51bm1vdW50KClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgbWUudGltZW91dCh0aW1lb3V0KS50aGVuKHJlbW92ZUZuKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZW1vdmVGbigpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgc3R5bGUgPSBtZS5zdHlsZTtcbiAgICAgICAgICAgIHN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIG1lLnN0eWxlID0gc3R5bGVcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLl9oaWRkZW4gPSB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBpbml0KCkge1xuICAgICAgICB0aGlzLmF1dG9Jbml0Vm5vZGUgJiYgdGhpcy5pbml0Vm5vZGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoaXMgY29tcG9uZW50IG9yIGFueSBvZiBpdHMgcGFyZW50cyBpcyBmbG9hdGluZ1xuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzRmxvYXRpbmcoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmZsb2F0aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtZS5wYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICBtZS5wYXJlbnQuZmxvYXRpbmdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHZhbHVlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyPn1cbiAgICAgKi9cbiAgICBhc3luYyBtZWFzdXJlKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUuZW5kc1dpdGgoJ3B4JykpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxlbmd0aFJFLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHtpZCwgd2luZG93SWR9ID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGF3YWl0IHRoaXMudHJhcChOZW8ubWFpbi5Eb21BY2Nlc3MubWVhc3VyZSh7aWQsIHZhbHVlLCB3aW5kb3dJZH0pKVxuICAgICAgICAgICAgfSBlbHNlIGlmICghaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gY2hhbmdlIHRoZSBvcmRlciBjb25maWdzIGFyZSBhcHBsaWVkIHRvIHRoaXMgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3ByZXZlbnRPcmlnaW5hbENvbmZpZ10gVHJ1ZSBwcmV2ZW50cyB0aGUgaW5zdGFuY2UgZnJvbSBnZXR0aW5nIGFuIG9yaWdpbmFsQ29uZmlnIHByb3BlcnR5XG4gICAgICogQHJldHVybnMge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgbWVyZ2VDb25maWcoLi4uYXJncykge1xuICAgICAgICBsZXQgY29uZmlnID0gc3VwZXIubWVyZ2VDb25maWcoLi4uYXJncyksXG4gICAgICAgICAgICB2ZG9tICAgPSBjb25maWcudmRvbSB8fCBjb25maWcuX3Zkb20gfHwge307XG5cbiAgICAgICAgLy8gSXQgc2hvdWxkIGJlIHBvc3NpYmxlIHRvIG1vZGlmeSByb290IGxldmVsIHZkb20gYXR0cmlidXRlcyBvbiBpbnN0YW5jZSBsZXZlbC5cbiAgICAgICAgLy8gTm90ZSB0aGF0IHZkb20gaXMgbm90IGEgcmVhbCBjb25maWcsIGJ1dCBpbXBsZW1lbnRlZCB2aWEgZ2V0KCkgJiBzZXQoKS5cbiAgICAgICAgdGhpcy5fdmRvbSA9IE5lby5jbG9uZSh7Li4udmRvbSwgLi4udGhpcy5fdmRvbSB8fCB7fX0sIHRydWUpO1xuXG4gICAgICAgIHRoaXMuZW5zdXJlU3RhYmxlSWRzKCk7XG5cbiAgICAgICAgZGVsZXRlIGNvbmZpZy5fdmRvbTtcbiAgICAgICAgZGVsZXRlIGNvbmZpZy52ZG9tO1xuXG4gICAgICAgIHJldHVybiBjb25maWdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYW4gZ2V0IGNhbGxlZCBhZnRlciB0aGUgY29tcG9uZW50IGdvdCB2bm9kZUluaXRpYWxpemVkLiBTZWUgdGhlIGF1dG9Nb3VudCBjb25maWcgYXMgd2VsbC5cbiAgICAgKiBXZSBoYXZlIGRlY2lkZWQgdG8gYWx3YXlzIGZvcmNlIGEgbmV3IGluaXRWbm9kZSh0cnVlKSBjYWxsIGhlcmUuXG4gICAgICogUmF0aW9uYWxlOlxuICAgICAqIDEuIFRoZSBvdmVyaGVhZCBvZiB0cmFja2luZyBoYXNVbm1vdW50ZWRWZG9tQ2hhbmdlcyBvbiBldmVyeSB2ZG9tIHVwZGF0ZSBpcyByZW1vdmVkLlxuICAgICAqIDIuIFRoZSBlZGdlIGNhc2Ugb2YgbW91bnRpbmcgYSBwcmUtY2FsY3VsYXRlZCBidXQgdW50b3VjaGVkIHZub2RlIHRyZWUgaXMgPCAxJS5cbiAgICAgKiAzLiBUaGUgY29zdCBvZiByZS1nZW5lcmF0aW5nIHRoZSB2bm9kZSB0cmVlIGlzIGxvdyBlbm91Z2ggdG8ganVzdGlmeSB0aGUgcm9idXN0bmVzcyBhbmQgc2ltcGxpY2l0eS5cbiAgICAgKiA0LiBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgRE9NIGlzIGFsd2F5cyBtb3VudGVkIHdpdGggdGhlIG1vc3QgdXAtdG8tZGF0ZSB2ZG9tIHN0YXRlLlxuICAgICAqL1xuICAgIGFzeW5jIG1vdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbml0Vm5vZGUodHJ1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIHN1cGVyLm9uQ29uc3RydWN0ZWQoKTtcbiAgICAgICAgdGhpcy5rZXlzPy5yZWdpc3Rlcih0aGlzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25TY3JvbGxDYXB0dXJlKGRhdGEpIHtcbiAgICAgICAgc3VwZXIub25TY3JvbGxDYXB0dXJlKGRhdGEpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLl92ZG9tKSB7XG4gICAgICAgICAgICBsZXQgdmRvbU5vZGUgPSBWRG9tVXRpbC5nZXRCeUlkKG1lLl92ZG9tLCBkYXRhLnRhcmdldC5pZCk7XG5cbiAgICAgICAgICAgIGlmICh2ZG9tTm9kZSkge1xuICAgICAgICAgICAgICAgIHZkb21Ob2RlLnNjcm9sbFRvcCAgPSBkYXRhLnNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICB2ZG9tTm9kZS5zY3JvbGxMZWZ0ID0gZGF0YS5zY3JvbGxMZWZ0XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRm9jdXNFbnRlcihkYXRhKSB7XG4gICAgICAgIC8vIElmIHdlIGFyZSBoaWRkZW4sIG9yIHVubW91bnRlZCB3aGlsZSB3ZSBzdGlsbCBjb250YWluIGZvY3VzLCB3ZSBoYXZlIHRvIHJldmVydFxuICAgICAgICAvLyBmb2N1cyB0byB3aGVyZSBpdCBjYW1lIGZyb20gaWYgcG9zc2libGVcbiAgICAgICAgdGhpcy5mb2N1c0VudGVyRGF0YSA9IGRhdGFcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRm9jdXNMZWF2ZShkYXRhKSB7XG4gICAgICAgIHRoaXMuZm9jdXNFbnRlckRhdGEgPSBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJ5IG1hbmFnZXIuRm9jdXNcbiAgICAgKiBAbmFtZSBvbkZvY3VzRW50ZXJcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoIGRvbSBlbGVtZW50IGlkcyB1cHdhcmRzXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYnkgbWFuYWdlci5Gb2N1c1xuICAgICAqIEBuYW1lIG9uRm9jdXNMZWF2ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggZG9tIGVsZW1lbnQgaWRzIHVwd2FyZHNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBieSBtYW5hZ2VyLkZvY3VzXG4gICAgICogQG5hbWUgb25Gb2N1c01vdmVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9ICBvcHRzLm5ld1BhdGggZG9tIGVsZW1lbnQgaWRzIHVwd2FyZHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgb3B0cy5vbGRQYXRoIGRvbSBlbGVtZW50IGlkcyB1cHdhcmRzXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBjbHMgZnJvbSB0aGUgdmRvbVJvb3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cbiAgICByZW1vdmVDbHModmFsdWUpIHtcbiAgICAgICAgbGV0IGNscyA9IHRoaXMuY2xzO1xuXG4gICAgICAgIE5lb0FycmF5LnJlbW92ZShjbHMsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5jbHMgPSBjbHNcbiAgICB9XG5cblxuXG4gICAgLyoqXG4gICAgICogRWl0aGVyIGEgc3RyaW5nIGxpa2UgJ2NvbG9yJyBvciBhbiBhcnJheSBjb250YWluaW5nIHN0eWxlIGF0dHJpYnV0ZXMgdG8gcmVtb3ZlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHZhbHVlIGNhbWVsQ2FzZSBvbmx5XG4gICAgICogQHJldHVybnMge09iamVjdH0gYWxsIHN0eWxlcyBvZiB0aGlzLmVsXG4gICAgICovXG4gICAgcmVtb3ZlU3R5bGUodmFsdWUpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBbdmFsdWVdXG4gICAgICAgIH1cblxuICAgICAgICBsZXQge3N0eWxlfSAgPSB0aGlzLFxuICAgICAgICAgICAgZG9VcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICBPYmplY3Qua2V5cyhzdHlsZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlLmluZGV4T2Yoa2V5KSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHN0eWxlW2tleV07XG4gICAgICAgICAgICAgICAgZG9VcGRhdGUgPSB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChkb1VwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5zdHlsZSA9IHN0eWxlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3R5bGVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHJldmVydEZvY3VzKCkge1xuICAgICAgICBsZXQgcmVsYXRlZFRhcmdldCA9IHRoaXMuZm9jdXNFbnRlckRhdGE/LnJlbGF0ZWRUYXJnZXQ7XG5cbiAgICAgICAgaWYgKHRoaXMuY29udGFpbnNGb2N1cyAmJiByZWxhdGVkVGFyZ2V0KSB7XG4gICAgICAgICAgICBOZW8uZ2V0Q29tcG9uZW50KHJlbGF0ZWRUYXJnZXQuaWQpPy5mb2N1cygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaG93IHRoZSBjb21wb25lbnQuXG4gICAgICogaGlkZU1vZGU6ICdyZW1vdmVEb20nICB1c2VzIHZkb20gcmVtb3ZlRG9tLlxuICAgICAqIGhpZGVNb2RlOiAndmlzaWJpbGl0eScgdXNlcyBjc3MgdmlzaWJpbGl0eS5cbiAgICAgKi9cbiAgICBzaG93KCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5oaWRlTW9kZSAhPT0gJ3Zpc2liaWxpdHknKSB7XG4gICAgICAgICAgICBkZWxldGUgbWUudmRvbS5yZW1vdmVEb207XG5cbiAgICAgICAgICAgIGlmIChtZS5zaWxlbnRWZG9tVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgbWUubmVlZHNWZG9tVXBkYXRlID0gdHJ1ZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChtZS5wYXJlbnRJZCAhPT0gJ2RvY3VtZW50LmJvZHknKSB7XG4gICAgICAgICAgICAgICAgbWUucGFyZW50LnVwZGF0ZURlcHRoID0gLTE7XG4gICAgICAgICAgICAgICAgbWUucGFyZW50LnVwZGF0ZSgpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICFtZS5tb3VudGVkICYmIG1lLmluaXRWbm9kZSh0cnVlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHN0eWxlID0gbWUuc3R5bGU7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHNldCBudWxsLCBzaW5jZSB0aGUgc3R5bGUgbWlnaHQgYmUgaW5zaWRlIHdyYXBwZXJTdHlsZSxcbiAgICAgICAgICAgIC8vIHdoaWNoIHdvdWxkIGdldCByZS1hcHBsaWVkIGluIGNhc2Ugd2UganVzdCBkZWxldGUgdGhlIHByb3BlcnR5LlxuICAgICAgICAgICAgc3R5bGUudmlzaWJpbGl0eSA9IG51bGw7XG4gICAgICAgICAgICBtZS5zdHlsZSA9IHN0eWxlXG4gICAgICAgIH1cblxuICAgICAgICBtZS5faGlkZGVuID0gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGUgYSBjbHMgaW5zaWRlIHRoZSB2ZG9tUm9vdCBvZiB0aGUgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYWRkXSBVc2UgdGhpcyBwYXJhbSB0byBlbmZvcmNlIGFuIGFkZCgpIG9yIHJlbW92ZSgpIG9wZXJhdGlvbi5cbiAgICAgKi9cbiAgICB0b2dnbGVDbHModmFsdWUsIGFkZCkge1xuICAgICAgICBsZXQgY2xzID0gdGhpcy5jbHM7XG5cbiAgICAgICAgTmVvQXJyYXkudG9nZ2xlKGNscywgdmFsdWUsIGFkZCk7XG4gICAgICAgIHRoaXMuY2xzID0gY2xzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgY29tcG9uZW50IERPTVxuICAgICAqL1xuICAgIHVubW91bnQoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUudmRvbS5yZW1vdmVEb20gPSB0cnVlO1xuXG4gICAgICAgIG1lLl9oaWRkZW4gPSB0cnVlOyAvLyBzaWxlbnQgdXBkYXRlXG4gICAgICAgIG1lLm1vdW50ZWQgPSBmYWxzZTtcblxuICAgICAgICBOZW8uYXBwbHlEZWx0YXMobWUud2luZG93SWQsIHthY3Rpb246ICdyZW1vdmVOb2RlJywgaWQ6IG1lLnZkb20uaWR9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIHNob3J0Y3V0IGZvciBOZW8ubWFuYWdlci5Db21wb25lbnQudXBcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGNvbmZpZ1xuICAgICAqIEByZXR1cm5zIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH0gVGhlIG1hdGNoaW5nIGluc3RhbmNlIG9yIG51bGxcbiAgICAgKi9cbiAgICB1cChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIENvbXBvbmVudE1hbmFnZXIudXAodGhpcy5pZCwgY29uZmlnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIGNvbXBvbmVudCBpbnRvIGEgSlNPTi1jb21wYXRpYmxlIG9iamVjdC5cbiAgICAgKiBFeHRlbmRzIHRoZSBjb3JlLkJhc2Ugc2VyaWFsaXphdGlvbiB3aXRoIGNvbXBvbmVudC1zcGVjaWZpYyBwcm9wZXJ0aWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcbiAgICAgICAgICAgIGFsaWduICAgICAgIDogbWUuYWxpZ24sXG4gICAgICAgICAgICBjbHMgICAgICAgICA6IG1lLmNscyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXIgIDogbWUuY29udHJvbGxlcj8udG9KU09OKCksXG4gICAgICAgICAgICBkaXNhYmxlZCAgICA6IG1lLmRpc2FibGVkLFxuICAgICAgICAgICAgaGVpZ2h0ICAgICAgOiBtZS5oZWlnaHQsXG4gICAgICAgICAgICBoaWRkZW4gICAgICA6IG1lLmhpZGRlbixcbiAgICAgICAgICAgIGtleXMgICAgICAgIDogbWUua2V5cz8udG9KU09OKCksXG4gICAgICAgICAgICByZWZlcmVuY2UgICA6IG1lLnJlZmVyZW5jZSxcbiAgICAgICAgICAgIHJvbGUgICAgICAgIDogbWUucm9sZSxcbiAgICAgICAgICAgIHN0eWxlICAgICAgIDogbWUuc3R5bGUsXG4gICAgICAgICAgICB0aGVtZSAgICAgICA6IG1lLnRoZW1lLFxuICAgICAgICAgICAgdWkgICAgICAgICAgOiBtZS51aSxcbiAgICAgICAgICAgIHZkb20gICAgICAgIDogbWUudmRvbSxcbiAgICAgICAgICAgIHZub2RlICAgICAgIDogbWUudm5vZGUsXG4gICAgICAgICAgICB3aWR0aCAgICAgICA6IG1lLndpZHRoLFxuICAgICAgICAgICAgd3JhcHBlckNscyAgOiBtZS53cmFwcGVyQ2xzLFxuICAgICAgICAgICAgd3JhcHBlclN0eWxlOiBtZS53cmFwcGVyU3R5bGVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgdXBkYXRlU3R5bGUoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7dmRvbX0gICA9IG1lLFxuICAgICAgICAgICAgdmRvbVJvb3QgPSBtZS5nZXRWZG9tUm9vdCgpO1xuXG4gICAgICAgIGlmICh2ZG9tICE9PSB2ZG9tUm9vdCkge1xuICAgICAgICAgICAgdmRvbSAgICAuc3R5bGUgPSBtZS53cmFwcGVyU3R5bGU7XG4gICAgICAgICAgICB2ZG9tUm9vdC5zdHlsZSA9IG1lLnN0eWxlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2ZG9tLnN0eWxlID0gey4uLm1lLndyYXBwZXJTdHlsZSwgLi4ubWUuc3R5bGV9XG4gICAgICAgIH1cblxuICAgICAgICBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluIGNhc2UgeW91IGFyZSBzdXJlIGEgRE9NUmVjdCBleGlzdHMsIHVzZSBnZXREb21SZWN0KClcbiAgICAgKiBPdGhlcndpc2UgeW91IGNhbiB3YWl0IGZvciBpdCB1c2luZyB0aGlzIG1ldGhvZC5cbiAgICAgKiBAZXhhbXBsZTpcbiAgICAgKiAgICAgYXdhaXQgdGhpcy5pbml0Vm5vZGUodHJ1ZSk7XG4gICAgICogICAgIGF3YWl0IHRoaXMud2FpdEZvckRvbVJlY3QoKTtcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgb3B0c1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgICAgICAgICBvcHRzLmF0dGVtcHRzPTEwIFJlcnVucyBpbiBjYXNlIHRoZSByZWN0IGhlaWdodCBvciB3aWR0aCBlcXVhbHMgMFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgICAgICAgICBvcHRzLmRlbGF5PTUwICAgIFRpbWUgaW4gbXMgYmVmb3JlIGNoZWNraW5nIGFnYWluXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXXxTdHJpbmd9IG9wdHMuaWQ9dGhpcy5pZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgICAgICBvcHRzLndpbmRvd0lkPXRoaXMud2luZG93SWRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxOZW8udXRpbC5SZWN0YW5nbGV8TmVvLnV0aWwuUmVjdGFuZ2xlW10+fVxuICAgICAqL1xuICAgIGFzeW5jIHdhaXRGb3JEb21SZWN0KHthdHRlbXB0cz0xMCwgZGVsYXk9NTAsIGlkPXRoaXMuaWQsIHdpbmRvd0lkPXRoaXMud2luZG93SWR9ID0ge30pIHtcbiAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICByZXN1bHQgPSBhd2FpdCBtZS5nZXREb21SZWN0KGlkKSxcbiAgICAgICAgICAgIHJlUnVuICA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5mb3JFYWNoKHJlY3QgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZWN0LmhlaWdodCA8IDEgfHwgcmVjdC53aWR0aCA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVSdW4gPSB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQuaGVpZ2h0IDwgMSB8fCByZXN1bHQud2lkdGggPCAxKSB7XG4gICAgICAgICAgICByZVJ1biA9IHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZVJ1biAmJiBhdHRlbXB0cyA+IDApIHtcbiAgICAgICAgICAgIGF3YWl0IG1lLnRpbWVvdXQoZGVsYXkpO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IG1lLndhaXRGb3JEb21SZWN0KHthdHRlbXB0czogYXR0ZW1wdHMtMSwgZGVsYXksIGlkLCB3aW5kb3dJZH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxufVxuXG4vKipcbiAqIG1hbmFnZXIuRm9jdXMgZmlyZXMgdGhlIGV2ZW50IGFmdGVyIGZvY3VzRW50ZXIsIGZvY3VzTGVhdmUgb3IgZm9jdXNNb3ZlXG4gKiBAZXZlbnQgZm9jdXNDaGFuZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge09iamVjdFtdfSBbZGF0YS5wYXRoXSBkb20gZWxlbWVudCBpZHMgdXB3YXJkc1xuICogQHBhcmFtIHtPYmplY3RbXX0gW2RhdGEub2xkUGF0aF0gZG9tIGVsZW1lbnQgaWRzIHVwd2FyZHNcbiAqL1xuXG4vKipcbiAqIG1hbmFnZXIuRm9jdXMgZmlyZXMgdGhlIGV2ZW50IHdoZW4gdGhlIGNvbXBvbmVudCBpZCBpcyBpbmNsdWRlZCBpbnNpZGUgdGhlIGRvbSBpZCBwYXRoXG4gKiBAZXZlbnQgZm9jdXNFbnRlclxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGEucGF0aCBkb20gZWxlbWVudCBpZHMgdXB3YXJkc1xuICovXG5cbi8qKlxuICogbWFuYWdlci5Gb2N1cyBmaXJlcyB0aGUgZXZlbnQgd2hlbiB0aGUgY29tcG9uZW50IGlkIGlzIG5vdCBpbmNsdWRlZCBpbnNpZGUgdGhlIGRvbSBpZCBwYXRoXG4gKiBAZXZlbnQgZm9jdXNMZWF2ZVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGEub2xkUGF0aCBkb20gZWxlbWVudCBpZHMgdXB3YXJkc1xuICovXG5cbi8qKlxuICogbWFuYWdlci5Gb2N1cyBmaXJlcyB0aGUgZXZlbnQgd2hlbiB0aGUgY29tcG9uZW50IGlkIGlzIGluY2x1ZGVkIGluc2lkZSB0aGUgZG9tIGlkIHBhdGgsIGJ1dCB0aGUgcGF0aCBpdHNlbGYgY2hhbmdlZFxuICogQGV2ZW50IGZvY3VzTW92ZVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGEucGF0aCBkb20gZWxlbWVudCBpZHMgdXB3YXJkc1xuICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5vbGRQYXRoIGRvbSBlbGVtZW50IGlkcyB1cHdhcmRzXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ29tcG9uZW50KTtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jb21wb25lbnQuQ2FudmFzXG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqL1xuY2xhc3MgQ2FudmFzIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb21wb25lbnQuQ2FudmFzJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29tcG9uZW50LkNhbnZhcycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdjYW52YXMnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnY2FudmFzJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRydWUgYXBwbGllcyBhIG1haW4uYWRkb24uUmVzaXplT2JzZXJ2ZXIgYW5kIGZpcmVzIGEgY3VzdG9tIHJlc2l6ZSBldmVudFxuICAgICAgICAgKiB3aGljaCBvdGhlciBpbnN0YW5jZXMgY2FuIHN1YnNjcmliZSB0by5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbW9uaXRvclNpemVfPXRydWVcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBtb25pdG9yU2l6ZV86IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBvZmZzY3JlZW49dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgb2Zmc2NyZWVuOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogT25seSBhcHBsaWNhYmxlIGlmIG9mZnNjcmVlbiA9PT0gdHJ1ZS5cbiAgICAgICAgICogdHJ1ZSBvbmNlIHRoZSBvd25lcnNoaXAgb2YgdGhlIGNhbnZhcyBub2RlIGdvdCB0cmFuc2ZlcnJlZCB0byB3b3JrZXIuQ2FudmFzLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBvZmZzY3JlZW5SZWdpc3RlcmVkXz1mYWxzZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIG9mZnNjcmVlblJlZ2lzdGVyZWRfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gX3Zkb209e3RhZzogJ2NhbnZhcyd9XG4gICAgICAgICAqL1xuICAgICAgICBfdmRvbTpcbiAgICAgICAge3RhZzogJ2NhbnZhcyd9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtb3VudGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIGFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpZCAgICAgICAgICAgICAgICAgICAgPSBtZS5nZXRDYW52YXNJZCgpLFxuICAgICAgICAgICAge29mZnNjcmVlbiwgd2luZG93SWR9ID0gbWU7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBhd2FpdCBtZS50aW1lb3V0KDMwKTsgLy8gbmV4dCByQUYgdGlja1xuXG4gICAgICAgICAgICBpZiAobWUubW9uaXRvclNpemUpIHtcbiAgICAgICAgICAgICAgICBtZS5hZGREb21MaXN0ZW5lcnMoW3tcbiAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGU6IGAjJHttZS5nZXRNb25pdG9yVGFyZ2V0SWQoKX1gLFxuICAgICAgICAgICAgICAgICAgICByZXNpemUgIDogbWUub25Eb21SZXNpemUsXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlICAgOiBtZVxuICAgICAgICAgICAgICAgIH1dKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob2Zmc2NyZWVuKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGRlbGF5ID0gNTA7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAobWUubW91bnRlZCAmJiAhbWUub2Zmc2NyZWVuUmVnaXN0ZXJlZCAmJiAhbWUuaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGF3YWl0IE5lby5tYWluLkRvbUFjY2Vzcy5nZXRPZmZzY3JlZW5DYW52YXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvd0lkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLm9mZnNjcmVlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgTmVvLndvcmtlci5DYW52YXMucmVnaXN0ZXJDYW52YXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgIDogZGF0YS5vZmZzY3JlZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3dJZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW2RhdGEub2Zmc2NyZWVuXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLm9mZnNjcmVlblJlZ2lzdGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhLnRyYW5zZmVycmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTmVvLmNvbmZpZy51c2VTaGFyZWRXb3JrZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJldHJpZXZlRGF0YSA9IGF3YWl0IE5lby53b3JrZXIuQ2FudmFzLnJldHJpZXZlQ2FudmFzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93SWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXRyaWV2ZURhdGEuaGFzQ2FudmFzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLm9mZnNjcmVlblJlZ2lzdGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IG1lLnRpbWVvdXQoZGVsYXkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWxheSA8IDEwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGF5ICo9IDJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvZmZzY3JlZW4pIHtcbiAgICAgICAgICAgIGlmIChtZS5vZmZzY3JlZW5SZWdpc3RlcmVkKSB7XG4gICAgICAgICAgICAgICAgTmVvLndvcmtlci5DYW52YXMudW5yZWdpc3RlckNhbnZhcyh7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVJZDogaWRcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5vZmZzY3JlZW5SZWdpc3RlcmVkID0gZmFsc2VcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB3aW5kb3dJZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0V2luZG93SWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0V2luZG93SWQodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMub2Zmc2NyZWVuUmVnaXN0ZXJlZCA9IGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcbiAgICAgKi9cbiAgICBkZXN0cm95KC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMub2Zmc2NyZWVuUmVnaXN0ZXJlZCkge1xuICAgICAgICAgICAgTmVvLndvcmtlci5DYW52YXMudW5yZWdpc3RlckNhbnZhcyh7XG4gICAgICAgICAgICAgICAgbm9kZUlkOiB0aGlzLmlkXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgc3VwZXIuZGVzdHJveSguLi5hcmdzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHdoZW4gdXNpbmcgd3JhcHBlcnMgKGUuZy4gRDMpXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRDYW52YXNJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgRE9NIG5vZGUgSUQgdGhhdCBzaG91bGQgdHJpZ2dlciB0aGUgY2FudmFzIHJlc2l6ZSB1cGRhdGVzLlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoaXMgaXMgdGhlIGNvbXBvbmVudCdzIHRvcC1sZXZlbCB3cmFwcGVyIElELlxuICAgICAqIFN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlIHRoaXMgdG8gb2JzZXJ2ZSBhIGRpZmZlcmVudCBub2RlIChlLmcuIGEgcGFyZW50IGNvbnRhaW5lcikuXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRNb25pdG9yVGFyZ2V0SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZkb20uaWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRG9tUmVzaXplKGRhdGEpIHtcbiAgICAgICAgdGhpcy5maXJlKCdyZXNpemUnLCBkYXRhKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ2FudmFzKTtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi9CYXNlLm1qcyc7XG5cbi8qKlxuICogQ29udmVuaWVuY2UgY2xhc3MgdG8gcmVuZGVyIGEgbGFiZWwgd2l0aCBhIHRleHRcbiAqIEBjbGFzcyBOZW8uY29tcG9uZW50LkxhYmVsXG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqL1xuY2xhc3MgTGFiZWwgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbXBvbmVudC5MYWJlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbXBvbmVudC5MYWJlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdsYWJlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdsYWJlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1sYWJlbCddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1sYWJlbCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB0YWc9J2xhYmVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGFnOiAnbGFiZWwnXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhMYWJlbCk7XG4iLCJpbXBvcnQgQ29tcG9uZW50ICAgICAgZnJvbSAnLi4vY29tcG9uZW50L0Jhc2UubWpzJztcbmltcG9ydCBMYXlvdXRCYXNlICAgICBmcm9tICcuLi9sYXlvdXQvQmFzZS5tanMnO1xuaW1wb3J0IExheW91dENhcmQgICAgIGZyb20gJy4uL2xheW91dC9DYXJkLm1qcyc7XG5pbXBvcnQgTGF5b3V0Rml0ICAgICAgZnJvbSAnLi4vbGF5b3V0L0ZpdC5tanMnO1xuaW1wb3J0IExheW91dEdyaWQgICAgIGZyb20gJy4uL2xheW91dC9HcmlkLm1qcyc7XG5pbXBvcnQgTGF5b3V0SGJveCAgICAgZnJvbSAnLi4vbGF5b3V0L0hCb3gubWpzJztcbmltcG9ydCBMYXlvdXRWQm94ICAgICBmcm9tICcuLi9sYXlvdXQvVkJveC5tanMnO1xuaW1wb3J0IExvZ2dlciAgICAgICAgIGZyb20gJy4uL3V0aWwvTG9nZ2VyLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgICAgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IHtpc0Rlc2NyaXB0b3J9IGZyb20gJy4uL2NvcmUvQ29uZmlnU3ltYm9scy5tanMnO1xuXG5jb25zdCBieVdlaWdodCA9ICh7IHdlaWdodCA6IGxocyA9IDAgfSwgeyB3ZWlnaHQgOiByaHMgPSAwIH0pID0+IGxocyAtIHJocztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNvbnRhaW5lci5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqL1xuY2xhc3MgQ29udGFpbmVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb250YWluZXIuQmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbnRhaW5lci5CYXNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2NvbnRhaW5lcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdjb250YWluZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tY29udGFpbmVyJ11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWNvbnRhaW5lciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZHJhZ1Jlc29ydGFibGVfPWZhbHNlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ1Jlc29ydGFibGVfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmF1bHQgY29uZmlndXJhdGlvbiBmb3IgY2hpbGQgaXRlbXMgd2l0aGluIHRoaXMgY29udGFpbmVyLlxuICAgICAgICAgKiBUaGlzIGNvbmZpZyB1c2VzIGEgZGVzY3JpcHRvciB0byBlbmFibGUgZGVlcCBtZXJnaW5nIHdpdGggaW5zdGFuY2UgYmFzZWQgaXRlbURlZmF1bHRzLlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGl0ZW1EZWZhdWx0c189e1tpc0Rlc2NyaXB0b3JdOiB0cnVlLCBtZXJnZTogJ2RlZXAnLCB2YWx1ZTogbnVsbH1cbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtRGVmYXVsdHNfOiB7XG4gICAgICAgICAgICBbaXNEZXNjcmlwdG9yXTogdHJ1ZSxcbiAgICAgICAgICAgIG1lcmdlICAgICAgICAgOiAnZGVlcCcsXG4gICAgICAgICAgICB2YWx1ZSAgICAgICAgIDogbnVsbFxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgb3IgYW4gb2JqZWN0IG9mIGNvbmZpZyBvYmplY3RzfGluc3RhbmNlc3xtb2R1bGVzIGZvciBlYWNoIGNoaWxkIGNvbXBvbmVudFxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gaXRlbXNfPVtdXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGltcG9ydCBCdXR0b24gICAgICBmcm9tICcuLi9idXR0b24vQmFzZS5tanMnO1xuICAgICAgICAgKiBpbXBvcnQgVG9vbGJhciAgICAgZnJvbSAnLi4vdG9vbGJhci9CYXNlLm1qcyc7XG4gICAgICAgICAqXG4gICAgICAgICAqIGxldCBteUJ1dHRvbiA9IE5lby5jcmVhdGUoQnV0dG9uLCB7XG4gICAgICAgICAqICAgICB0ZXh0OiAnQnV0dG9uMSdcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIE5lby5jcmVhdGUoVG9vbGJhciwge1xuICAgICAgICAgKiAgICAgLy8uLi5cbiAgICAgICAgICogICAgIGl0ZW1zOiB7XG4gICAgICAgICAqICAgICAgICAgYnV0dG9uUmVmIDoge1xuICAgICAgICAgKiAgICAgICAgICAgICBudHlwZTogJ2J1dHRvbicsICAgLy8gYnkgbnR5cGVcbiAgICAgICAgICogICAgICAgICAgICAgdGV4dCA6ICdCdXR0b24gMidcbiAgICAgICAgICogICAgICAgICB9LFxuICAgICAgICAgKiAgICAgICAgIHNlY29uZFJlZiA6IHtcbiAgICAgICAgICogICAgICAgICAgICAgbW9kdWxlOiBCdXR0b24sICAgIC8vIGJ5IGltcG9ydGVkIG1vZHVsZVxuICAgICAgICAgKiAgICAgICAgICAgICB0ZXh0ICA6ICdCdXR0b24gMydcbiAgICAgICAgICogICAgICAgICB9XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBvclxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBpbXBvcnQgQnV0dG9uICAgICAgZnJvbSAnLi4vYnV0dG9uL0Jhc2UubWpzJztcbiAgICAgICAgICogaW1wb3J0IE15UmVkQnV0dG9uIGZyb20gJ215YXBwL015UmVkQnV0dG9uLm1qcyc7XG4gICAgICAgICAqIGltcG9ydCBUb29sYmFyICAgICBmcm9tICcuLi90b29sYmFyL0Jhc2UubWpzJztcbiAgICAgICAgICpcbiAgICAgICAgICogbGV0IG15QnV0dG9uID0gTmVvLmNyZWF0ZShCdXR0b24sIHtcbiAgICAgICAgICogICAgIHRleHQ6ICdCdXR0b24xJ1xuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogTmVvLmNyZWF0ZShUb29sYmFyLCB7XG4gICAgICAgICAqICAgICAvLy4uLlxuICAgICAgICAgKiAgICAgaXRlbXM6IFtcbiAgICAgICAgICogICAgICAgICBteUJ1dHRvbiwgICAgICAgICAgICAgIC8vIHBhc3NlZCBpbnN0YW5jZVxuICAgICAgICAgKiAgICAgICAgIHtcbiAgICAgICAgICogICAgICAgICAgICAgbnR5cGU6ICdidXR0b24nLCAgIC8vIGJ5IG50eXBlXG4gICAgICAgICAqICAgICAgICAgICAgIHRleHQgOiAnQnV0dG9uIDInXG4gICAgICAgICAqICAgICAgICAgfSxcbiAgICAgICAgICogICAgICAgICB7XG4gICAgICAgICAqICAgICAgICAgICAgIG1vZHVsZTogQnV0dG9uLCAgICAvLyBieSBpbXBvcnRlZCBtb2R1bGVcbiAgICAgICAgICogICAgICAgICAgICAgdGV4dCAgOiAnQnV0dG9uIDMnXG4gICAgICAgICAqICAgICAgICAgfSxcbiAgICAgICAgICogICAgICAgICBNeVJlZEJ1dHRvbiAgICAgICAgICAgIC8vIHlvdSBjYW4gZHJvcCBpbXBvcnRlZCBtb2R1bGVzIGRpcmVjdGx5IGludG8gdGhlIGl0ZW1zIGFycmF5XG4gICAgICAgICAqICAgICBdXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1zXzoge1xuICAgICAgICAgICAgW2lzRGVzY3JpcHRvcl06IHRydWUsXG4gICAgICAgICAgICBjbG9uZSAgICAgICAgIDogJ3NoYWxsb3cnLFxuICAgICAgICAgICAgY2xvbmVPbkdldCAgICA6ICdub25lJyxcbiAgICAgICAgICAgIGlzRXF1YWwgICAgICAgOiAoKSA9PiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlICAgICAgICAgOiBbXVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fFN0cmluZ3xudWxsfSBsYXlvdXRfPXtudHlwZTogJ3Zib3gnLCBhbGlnbjogJ3N0cmV0Y2gnfVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGxheW91dF86IHtcbiAgICAgICAgICAgIG50eXBlOiAndmJveCcsXG4gICAgICAgICAgICBhbGlnbjogJ3N0cmV0Y2gnXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZHJhZ2dhYmxlLmNvbnRhaW5lci5Tb3J0Wm9uZXxudWxsfSBzb3J0Wm9uZT1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBzb3J0Wm9uZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gc29ydFpvbmVDbHM9J05lby5kcmFnZ2FibGUuY29udGFpbmVyLlNvcnRab25lJ1xuICAgICAgICAgKi9cbiAgICAgICAgc29ydFpvbmVDbHM6ICdOZW8uZHJhZ2dhYmxlLmNvbnRhaW5lci5Tb3J0Wm9uZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHNvcnRab25lQ29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHNvcnRab25lQ29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbT17Y246IFtdfVxuICAgICAgICAgKi9cbiAgICAgICAgX3Zkb206XG4gICAgICAgIHtjbjogW119XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhbiBpdGVtIG9yIGFycmF5IG9mIGl0ZW1zIGF0IHRoZSBsYXN0IGluZGV4XG4gICAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGl0ZW1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcmVtb3ZlRnJvbVByZXZpb3VzUGFyZW50PXRydWVdXG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZXxOZW8uY29tcG9uZW50LkJhc2VbXX1cbiAgICAgKi9cbiAgICBhZGQoaXRlbSwgc2lsZW50PWZhbHNlLCByZW1vdmVGcm9tUHJldmlvdXNQYXJlbnQ9dHJ1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbWUuaW5zZXJ0KG1lLml0ZW1zID8gbWUuaXRlbXMubGVuZ3RoIDogMCwgaXRlbSwgc2lsZW50LCByZW1vdmVGcm9tUHJldmlvdXNQYXJlbnQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBhcHBOYW1lIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRBcHBOYW1lKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHN1cGVyLmFmdGVyU2V0QXBwTmFtZSh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiBtZS5pdGVtcykge1xuICAgICAgICAgICAgbWUuaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIU5lby5pc1N0cmluZyhpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmFwcE5hbWUgPSB2YWx1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgJiYgbWUubGF5b3V0KSB7XG4gICAgICAgICAgICBtZS5sYXlvdXQuYXBwTmFtZSA9IHZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWUuc29ydFpvbmUpIHtcbiAgICAgICAgICAgIG1lLnNvcnRab25lLmFwcE5hbWUgPSB2YWx1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8ubGF5b3V0LkJhc2V8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5sYXlvdXQuQmFzZXxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldExheW91dCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUudm5vZGVJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgb2xkVmFsdWU/LnJlbW92ZVJlbmRlckF0dHJpYnV0ZXMoKTtcbiAgICAgICAgICAgIHZhbHVlPy5hcHBseVJlbmRlckF0dHJpYnV0ZXMoKTtcblxuICAgICAgICAgICAgbWUuaXRlbXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZT8ucmVtb3ZlQ2hpbGRBdHRyaWJ1dGVzKGl0ZW0sIGluZGV4KTtcbiAgICAgICAgICAgICAgICB2YWx1ZT8uYXBwbHlDaGlsZEF0dHJpYnV0ZXMoaXRlbSwgaW5kZXgpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgb2xkVmFsdWU/LmRlc3Ryb3k/LigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtb3VudGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN1cGVyLmFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwge2l0ZW1zfSA9IHRoaXMsIHtsZW5ndGh9ID0gaXRlbXM7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghaXRlbXNbaV0udmRvbS5yZW1vdmVEb20pIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbXNbaV0ubW91bnRlZCA9IHZhbHVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBuZWVkc1Zkb21VcGRhdGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXROZWVkc1Zkb21VcGRhdGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbXM/LmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGUuZy4gVG9vbGJhciBpdGVtcyBsaWtlICctPidcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGNhbiBub3Qgc2V0IHRoZSBjb25maWcgZGlyZWN0bHkgPT4gaXQgY291bGQgYWxyZWFkeSBiZSBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHdlIHN0aWxsIHdhbnQgdG8gcGFzcyBpdCBmdXJ0aGVyIGludG8gc3VidHJlZXNcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5fbmVlZHNWZG9tVXBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uYWZ0ZXJTZXROZWVkc1Zkb21VcGRhdGU/LihmYWxzZSwgdHJ1ZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB2bm9kZUluaXRpYWxpemluZyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldElzVm5vZGVJbml0aWFsaXppbmcodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQge2l0ZW1zfSA9IHRoaXMsXG4gICAgICAgICAgICAgICAgaSAgICAgICA9IDAsXG4gICAgICAgICAgICAgICAgbGVuICAgICA9IGl0ZW1zLmxlbmd0aDtcblxuICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghaXRlbXNbaV0udmRvbS5yZW1vdmVEb20pIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbXNbaV0uaXNWbm9kZUluaXRpYWxpemluZyA9IHZhbHVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBkcmFnUmVzb3J0YWJsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBhZnRlclNldERyYWdSZXNvcnRhYmxlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgbW9kdWxlO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiAhbWUuc29ydFpvbmUpIHtcbiAgICAgICAgICAgIGlmIChtZS5zb3J0Wm9uZUNvbmZpZz8ubW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlID0gbWUuc29ydFpvbmVDb25maWcubW9kdWxlO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFtZS5pc0NvbnN0cnVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUgPSBhd2FpdCBtZS5sb2FkU29ydFpvbmVNb2R1bGUoKTtcbiAgICAgICAgICAgICAgICBtb2R1bGUgPSBtb2R1bGUuZGVmYXVsdFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5jcmVhdGVTb3J0Wm9uZShOZW8ubWVyZ2Uoe1xuICAgICAgICAgICAgICAgIG1vZHVsZSxcbiAgICAgICAgICAgICAgICBhcHBOYW1lICAgICAgICAgICAgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgICAgIGJvdW5kYXJ5Q29udGFpbmVySWQ6IG1lLmlkLFxuICAgICAgICAgICAgICAgIG93bmVyICAgICAgICAgICAgICA6IG1lLFxuICAgICAgICAgICAgICAgIHdpbmRvd0lkICAgICAgICAgICA6IG1lLndpbmRvd0lkXG4gICAgICAgICAgICB9LCBtZS5zb3J0Wm9uZUNvbmZpZykpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHRoZW1lIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRUaGVtZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRUaGVtZSh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIHZhbHVlICYmIHRoaXMuaXRlbXM/LmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpZiAoIU5lby5pc1N0cmluZyhpdGVtKSkge1xuICAgICAgICAgICAgICAgIGl0ZW0udGhlbWUgPSB2YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgd2luZG93SWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFdpbmRvd0lkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldFdpbmRvd0lkKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtsYXlvdXR9ID0gbWU7XG5cbiAgICAgICAgdmFsdWUgJiYgbWUuaXRlbXM/LmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpZiAoIU5lby5pc1N0cmluZyhpdGVtKSkge1xuICAgICAgICAgICAgICAgIGl0ZW0ud2luZG93SWQgPSB2YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIGlmICh2YWx1ZSAmJiBsYXlvdXQgJiYgIU5lby5pc1N0cmluZyhsYXlvdXQpKSB7XG4gICAgICAgICAgICBsYXlvdXQud2luZG93SWQgPSB2YWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lLnNvcnRab25lKSB7XG4gICAgICAgICAgICBtZS5zb3J0Wm9uZS53aW5kb3dJZCA9IHZhbHVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGl0ZW1zIG9iamVjdCB0byBhbiBhcnJheSBmb3Igb253YXJkIHN0b3JhZ2UgYXMgX2l0ZW1zXG4gICAgICogQHBhcmFtIHtPYmplY3R8T2JqZWN0W119IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R8T2JqZWN0W119IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge09iamVjdFtdfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICAgYmVmb3JlU2V0SXRlbXModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChOZW8udHlwZU9mKHZhbHVlKSA9PT0gJ09iamVjdCcpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBbXSxcbiAgICAgICAgICAgICAgICBoYXNXZWlnaHQsIGl0ZW07XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVmIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IHZhbHVlW3JlZl1cblxuICAgICAgICAgICAgICAgIGl0ZW0ucmVmZXJlbmNlID0gcmVmO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIGhhc1dlaWdodCB8fD0gKCd3ZWlnaHQnIGluIGl0ZW0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChoYXNXZWlnaHQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuc29ydChieVdlaWdodClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWUgPSByZXN1bHRcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd8TmVvLmxheW91dC5CYXNlfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtOZW8ubGF5b3V0LkJhc2V9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldExheW91dCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTGF5b3V0KHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Kn0gaXRlbVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3JlbW92ZUZyb21QcmV2aW91c1BhcmVudD10cnVlXVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29tcG9uZW50LkJhc2V8T2JqZWN0fSBPYmplY3QgZm9yIGxhenkgbG9hZGVkIGl0ZW1zXG4gICAgICovXG4gICAgY3JlYXRlSXRlbShpdGVtLCBpbmRleCwgcmVtb3ZlRnJvbVByZXZpb3VzUGFyZW50PXRydWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyAgID0ge2FwcE5hbWU6IG1lLmFwcE5hbWUsIHBhcmVudElkOiBtZS5pZCwgcGFyZW50SW5kZXg6IGluZGV4LCB3aW5kb3dJZDogbWUud2luZG93SWR9LFxuICAgICAgICAgICAgZGVmYXVsdHMgPSB7Li4ubWUuaXRlbURlZmF1bHRzfSxcbiAgICAgICAgICAgIGxhenlMb2FkSXRlbSwgbW9kdWxlLCBwYXJlbnQ7XG5cbiAgICAgICAgaWYgKGRlZmF1bHRzKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5tb2R1bGUpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZGVmYXVsdHMubnR5cGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpdGVtLm50eXBlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGRlZmF1bHRzLm1vZHVsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoTmVvLnR5cGVPZihpdGVtKSkge1xuICAgICAgICAgICAgY2FzZSAnTmVvQ2xhc3MnOiB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICB0aGVtZTogaXRlbS5jb25maWcudGhlbWUgfHwgbWUudGhlbWUsXG4gICAgICAgICAgICAgICAgICAgIC4uLmRlZmF1bHRzLFxuICAgICAgICAgICAgICAgICAgICBtb2R1bGU6IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgIC4uLmNvbmZpZ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ05lb0luc3RhbmNlJzoge1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IGl0ZW0ucGFyZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQgIT09IG1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZW1vdmVGcm9tUHJldmlvdXNQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5yZW1vdmU/LihpdGVtLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgaXRlbS52ZG9tLnJlbW92ZURvbVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudC53aW5kb3dJZCAhPT0gbWUud2luZG93SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluIGNhc2Ugd2UgYXJlIGR1cGxpY2F0aW5nIHZkb20gaW50byBhIGRpZmZlcmVudCBicm93c2VyIHdpbmRvdywgd2UgbmVlZCBhIHNpbGVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gX21vdW50ZWQgdXBkYXRlIHRvIGVuc3VyZSB0aGF0IGFmdGVyU2V0TW91bnRlZCgpIHN0aWxsIGdldHMgdHJpZ2dlcmVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbVtyZW1vdmVGcm9tUHJldmlvdXNQYXJlbnQgPyAnbW91bnRlZCcgOiAnX21vdW50ZWQnXSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBDb252ZW5pZW5jZSBsb2dpYywgZXNwZWNpYWxseSBmb3IgbW92aW5nIGNvbXBvbmVudHMgaW50byBkaWZmZXJlbnQgYnJvd3NlciB3aW5kb3dzOlxuICAgICAgICAgICAgICAgICAgICAvLyBBIGNvbXBvbmVudCBtaWdodCByZWx5IG9uIHJlZmVyZW5jZXMgJiBoYW5kbGVyIG1ldGhvZHMgaW5zaWRlIHRoZSBwcmV2aW91cyBjb250cm9sbGVyIHJlYWxtXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvZG86IFdlIG5lZWQgPy4gdW50aWwgZnVuY3Rpb25hbC5jb21wb25lbnQuQmFzZSBzdXBwb3J0cyBjb250cm9sbGVyc1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0ZW0uY29udHJvbGxlciAmJiAhbWUuZ2V0Q29udHJvbGxlcigpICYmIHBhcmVudC5nZXRDb250cm9sbGVyPy4oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5jb250cm9sbGVyID0ge3BhcmVudDogcGFyZW50LmdldENvbnRyb2xsZXIoKX1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGl0ZW0uc2V0KGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgaXRlbS5nZXRTdGF0ZVByb3ZpZGVyPy4oKT8uY3JlYXRlQmluZGluZ3MoaXRlbSk7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnT2JqZWN0Jzoge1xuICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0cykge1xuICAgICAgICAgICAgICAgICAgICBOZW8uYXNzaWduRGVmYXVsdHMoaXRlbSwgZGVmYXVsdHMpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtLm1vZHVsZSAmJiAhaXRlbS5udHlwZSAmJiAhaXRlbS5jbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5tb2R1bGUgPSBDb21wb25lbnRcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUgPSBpdGVtLm1vZHVsZTtcblxuICAgICAgICAgICAgICAgIGxhenlMb2FkSXRlbSA9IG1vZHVsZSAmJiAhbW9kdWxlLmlzQ2xhc3MgJiYgTmVvLmlzRnVuY3Rpb24obW9kdWxlKTtcblxuICAgICAgICAgICAgICAgIGlmIChtb2R1bGUgJiYgIWxhenlMb2FkSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmNsYXNzTmFtZSA9IG1vZHVsZS5wcm90b3R5cGUuY2xhc3NOYW1lO1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnRoZW1lICAgICA9IGRlZmF1bHRzLnRoZW1lIHx8IG1vZHVsZS5jb25maWcudGhlbWUgfHwgbWUudGhlbWVcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5oYW5kbGVyU2NvcGUgPT09ICd0aGlzJykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmhhbmRsZXJTY29wZSA9IG1lO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChOZW8udHlwZU9mKGl0ZW0uaGFuZGxlcikgPT09ICdTdHJpbmcnICYmIE5lby50eXBlT2YobWVbaXRlbS5oYW5kbGVyXSkgPT09ICdGdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uaGFuZGxlciA9IG1lW2l0ZW0uaGFuZGxlcl1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaXRlbSwgY29uZmlnKTtcblxuICAgICAgICAgICAgICAgIGlmICghbGF6eUxvYWRJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBOZW9baXRlbS5jbGFzc05hbWUgPyAnY3JlYXRlJyA6ICdudHlwZSddKGl0ZW0pXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS52ZG9tID0gT2JqZWN0LmFzc2lnbihpdGVtLnZkb20gfHwge30sIHtyZW1vdmVEb206IHRydWV9KVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ1N0cmluZyc6IHtcbiAgICAgICAgICAgICAgICBpdGVtID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZTogQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICB2ZG9tICA6IHt0ZXh0OiBpdGVtfSxcbiAgICAgICAgICAgICAgICAgICAgLi4uY29uZmlnXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGl0ZW1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY3JlYXRlSXRlbXMoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbXMgICAgID0gbWUuX2l0ZW1zLFxuICAgICAgICAgICAgaXRlbXNSb290ID0gbWUuZ2V0VmRvbUl0ZW1zUm9vdCgpLFxuICAgICAgICAgICAge2xheW91dH0gID0gbWUsXG4gICAgICAgICAgICB2ZG9tO1xuXG4gICAgICAgIGl0ZW1zUm9vdC5jbiA9IFtdO1xuXG4gICAgICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpdGVtc1tpbmRleF0gPSBpdGVtID0gbWUuY3JlYXRlSXRlbShpdGVtLCBpbmRleCk7XG5cbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgTmVvLmNvcmUuQmFzZSkge1xuICAgICAgICAgICAgICAgIGxheW91dD8uYXBwbHlDaGlsZEF0dHJpYnV0ZXMoaXRlbSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIHZkb20gPSBpdGVtLmNyZWF0ZVZkb21SZWZlcmVuY2UoKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2ZG9tID0gaXRlbS52ZG9tXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGl0ZW1zUm9vdC5jbi5wdXNoKHZkb20pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gYWRkIGl0ZW1zIGludG8gdGhlIHZkb21cbiAgICAgICAgbWUudXBkYXRlRGVwdGggPSAtMTtcbiAgICAgICAgbWUuaXNDb25zdHJ1Y3RlZCAmJiBtZS51cGRhdGUoKTtcblxuICAgICAgICBtZS5maXJlKCdpdGVtc0NyZWF0ZWQnLCB7aWQ6IG1lLmlkLCBpdGVtc30pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfE5lby5sYXlvdXQuQmFzZX0gdmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybnMge05lby5sYXlvdXQuQmFzZX1cbiAgICAgKi9cbiAgICBjcmVhdGVMYXlvdXQodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHthcHBOYW1lLCBpZCwgd2luZG93SWR9ID0gbWU7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExheW91dEJhc2UgJiYgdmFsdWUuaXNMYXlvdXQpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHZhbHVlLCB7YXBwTmFtZSwgY29udGFpbmVySWQ6IGlkLCB3aW5kb3dJZH0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbWUucGFyc2VMYXlvdXRDbGFzcyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih2YWx1ZSwge2FwcE5hbWUsIGNvbnRhaW5lcklkOiBpZCwgd2luZG93SWR9KTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IE5lby5udHlwZSh2YWx1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjcmVhdGVTb3J0Wm9uZShjb25maWcpIHtcbiAgICAgICAgdGhpcy5zb3J0Wm9uZSA9IE5lby5jcmVhdGUoY29uZmlnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIGFsbCBjb21wb25lbnRzIGluc2lkZSB0aGlzLml0ZW1zIGJlZm9yZSB0aGUgc3VwZXIoKSBjYWxsLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3VwZGF0ZVBhcmVudFZkb209ZmFsc2VdIHRydWUgdG8gcmVtb3ZlIHRoZSBjb21wb25lbnQgZnJvbSB0aGUgcGFyZW50IHZkb20gPT4gcmVhbCBkb21cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdIHRydWUgdG8gdXBkYXRlIHRoZSB2ZG9tIHNpbGVudGx5ICh1c2VmdWwgZm9yIGRlc3Ryb3lpbmcgbXVsdGlwbGUgY2hpbGQgaXRlbXMgaW4gYSByb3cpXG4gICAgICovXG4gICAgZGVzdHJveSh1cGRhdGVQYXJlbnRWZG9tPWZhbHNlLCBzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgdGhpcy5sYXlvdXQ/LmRlc3Ryb3koKTtcblxuICAgICAgICB0aGlzLml0ZW1zPy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaXRlbS5kZXN0cm95Py4oZmFsc2UsIHRydWUpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHN1cGVyLmRlc3Ryb3kodXBkYXRlUGFyZW50VmRvbSwgc2lsZW50KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIGFsdGVybmF0aXZlIGZvciBgZ2V0UmVmZXJlbmNlKClgIHdoaWNoIGlzIHVzZWZ1bCBiZWZvcmUgYSBjb21wb25lbnQgdHJlZSBnb3QgY3JlYXRlZC5cbiAgICAgKiBgZ2V0UmVmZXJlbmNlKClgIHJlbGllcyBvbiBjaGlsZCBpdGVtcyBiZWluZyByZWdpc3RlcmVkIGluc2lkZSBgbWFuYWdlci5Db21wb25lbnRgLFxuICAgICAqIHdoaWxlIHRoaXMgbWV0aG9kIHNpbXBseSB3YWxrcyBkb3duIHRoZSBpdGVtcyBhcnJheS5cbiAgICAgKlxuICAgICAqIEhvd2V2ZXIsIGNsYXNzZXMgLyBtb2R1bGVzIGluc2lkZSB0aGUgaXRlbXMgdHJlZSBjYW4gbm90IGdldCBwYXJzZWQgZnVydGhlci5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcmVmZXJlbmNlXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gaXRlbXM9dGhpcy5pdGVtc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R8TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9XG4gICAgICovXG4gICAgZ2V0SXRlbShyZWZlcmVuY2UsIGl0ZW1zPXRoaXMuaXRlbXMpIHtcbiAgICAgICAgbGV0IGkgICA9IDAsXG4gICAgICAgICAgICBsZW4gPSBpdGVtcy5sZW5ndGgsXG4gICAgICAgICAgICBjaGlsZEl0ZW0sIGl0ZW07XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0ucmVmZXJlbmNlID09PSByZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRJdGVtID0gdGhpcy5nZXRJdGVtKHJlZmVyZW5jZSwgaXRlbS5pdGVtcyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZEl0ZW1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgYSBkaWZmZXJlbnQgdmRvbSBpdGVtcyByb290IGlmIG5lZWRlZCAodXNlZnVsIGluIGNhc2UgdGhpcyBjb250YWluZXIgdXNlcyBhIHdyYXBwZXIgbm9kZSkuXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIG5ldyB2ZG9tIGl0ZW1zIHJvb3RcbiAgICAgKi9cbiAgICBnZXRWZG9tSXRlbXNSb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRWZG9tUm9vdCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGluZGV4IG9mIGEgZGlyZWN0IGNoaWxkIGNvbXBvbmVudCBpbnNpZGUgdGhpcy5pdGVtcy5cbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZXxTdHJpbmd9IGl0ZW1JZCBFaXRoZXIgdGhlIGl0ZW0gcmVmZXJlbmNlIG9yIHRoZSBpdGVtIGlkXG4gICAgICogQHJldHVybnMge051bWJlcn0gLTEgaW4gY2FzZSBubyBtYXRjaCB3YXMgZm91bmRcbiAgICAgKi9cbiAgICBpbmRleE9mKGl0ZW1JZCkge1xuICAgICAgICBsZXQgbWUgID0gdGhpcyxcbiAgICAgICAgICAgIGkgICA9IDAsXG4gICAgICAgICAgICBsZW4gPSBtZS5pdGVtcz8ubGVuZ3RoIHx8IDA7XG5cbiAgICAgICAgaWYgKCFOZW8uaXNTdHJpbmcoaXRlbUlkKSkge1xuICAgICAgICAgICAgaXRlbUlkID0gaXRlbUlkLmlkO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKG1lLml0ZW1zW2ldLmlkID09PSBpdGVtSWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC0xXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhbiBpdGVtIG9yIGFycmF5IG9mIGl0ZW1zIGF0IGEgc3BlY2lmaWMgaW5kZXguXG4gICAgICpcbiAgICAgKiAqKkF0b21pYyBNb3ZlczoqKlxuICAgICAqIElmIHRoZSBgaXRlbWAgaXMgYW4gZXhpc3RpbmcgYE5lby5jb21wb25lbnQuQmFzZWAgaW5zdGFuY2UgdGhhdCBhbHJlYWR5IGhhcyBhIHBhcmVudCBjb250YWluZXJcbiAgICAgKiB3aXRoaW4gdGhlIHNhbWUgYnJvd3NlciB3aW5kb3csIHRoaXMgbWV0aG9kIHBlcmZvcm1zIGFuICoqYXRvbWljIG1vdmUqKi5cbiAgICAgKiAxLiBUaGUgaXRlbSBpcyBzaWxlbnRseSByZW1vdmVkIGZyb20gaXRzIG9sZCBwYXJlbnQgKHdpdGhvdXQgdHJpZ2dlcmluZyBhIERPTSByZW1vdmFsKS5cbiAgICAgKiAyLiBUaGUgaXRlbSBpcyBpbnNlcnRlZCBpbnRvIHRoaXMgY29udGFpbmVyLlxuICAgICAqIDMuIFRoaXMgY29udGFpbmVyIHVwZGF0ZXMsIHNlbmRpbmcgYW4gYGluc2VydE5vZGVgIGRlbHRhLlxuICAgICAqIDQuIFRoZSBgRGVsdGFVcGRhdGVzYCBzeXN0ZW0gZGV0ZWN0cyB0aGUgZXhpc3RpbmcgRE9NIG5vZGUgYW5kIG1vdmVzIGl0IHBoeXNpY2FsbHksIHByZXNlcnZpbmdcbiAgICAgKiAgICBET00gc3RhdGUgc3VjaCBhcyBmb2N1cywgaW5wdXQgdmFsdWVzLCBhbmQgaWZyYW1lIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxOZW8uY29tcG9uZW50LkJhc2V9IGl0ZW1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcmVtb3ZlRnJvbVByZXZpb3VzUGFyZW50PXRydWVdXG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZXxOZW8uY29tcG9uZW50LkJhc2VbXX1cbiAgICAgKi9cbiAgICBpbnNlcnQoaW5kZXgsIGl0ZW0sIHNpbGVudD1mYWxzZSwgcmVtb3ZlRnJvbVByZXZpb3VzUGFyZW50PXRydWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtpdGVtc30gICAgID0gbWUsXG4gICAgICAgICAgICBsY2EgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICBpLCBpdGVtUGFyZW50LCBpdGVtVHlwZSwgbGVuLCBvbGRQYXJlbnQsIHBhcmVudHNBLCBwYXJlbnRzQiwgcmV0dXJuQXJyYXk7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgIGkgICAgICAgICAgID0gMDtcbiAgICAgICAgICAgIGxlbiAgICAgICAgID0gaXRlbS5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm5BcnJheSA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gaW5zZXJ0IHRoZSBhcnJheSBiYWNrd2FyZHNcbiAgICAgICAgICAgICAgICByZXR1cm5BcnJheS51bnNoaWZ0KG1lLmluc2VydChpbmRleCwgaXRlbVtsZW4gLSAxIC0gaV0sIHRydWUsIHJlbW92ZUZyb21QcmV2aW91c1BhcmVudCkpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGl0ZW0gPSByZXR1cm5BcnJheVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlbVR5cGUgPSBOZW8udHlwZU9mKGl0ZW0pO1xuXG4gICAgICAgICAgICBpZiAoaXRlbVR5cGUgPT09ICdOZW9JbnN0YW5jZScpIHtcbiAgICAgICAgICAgICAgICBpdGVtUGFyZW50ID0gaXRlbS5wYXJlbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbVBhcmVudCA9PT0gbWUgJiYgaXRlbXMuaW5kZXhPZihpdGVtKSA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbVBhcmVudCAmJiBpdGVtUGFyZW50ICE9PSBtZSAmJiByZW1vdmVGcm9tUHJldmlvdXNQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkUGFyZW50ID0gaXRlbVBhcmVudDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAob2xkUGFyZW50LndpbmRvd0lkID09PSBtZS53aW5kb3dJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50c0EgPSBbbWUsICAgICAgICAuLi5tZS5nZXRQYXJlbnRzKCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50c0IgPSBbb2xkUGFyZW50LCAuLi5vbGRQYXJlbnQuZ2V0UGFyZW50cygpXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbGNhID0gcGFyZW50c0EuZmluZChwID0+IHBhcmVudHNCLmluY2x1ZGVzKHApKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxjYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2xkUGFyZW50LnJlbW92ZShpdGVtLCBmYWxzZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVGcm9tUHJldmlvdXNQYXJlbnQgPSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpdGVtID0gbWUuY3JlYXRlSXRlbShpdGVtLCBpbmRleCwgcmVtb3ZlRnJvbVByZXZpb3VzUGFyZW50KTtcblxuICAgICAgICAgICAgLy8gYWRkZWQgdGhlIHRydWUgcGFyYW0gPT4gZm9yIGNhcmQgbGF5b3V0cywgd2UgZG8gbm90IHdhbnQgYSBkeW5hbWljYWxseSBpbnNlcnRlZCBjbXAgdG8gZ2V0IHJlbW92ZWQgcmlnaHQgYXdheVxuICAgICAgICAgICAgLy8gc2luY2UgaXQgd2lsbCBtb3N0IGxpa2VseSBnZXQgYWN0aXZhdGVkIHJpZ2h0IGF3YXlcbiAgICAgICAgICAgIG1lLmxheW91dD8uYXBwbHlDaGlsZEF0dHJpYnV0ZXMoaXRlbSwgaW5kZXgsIHRydWUpO1xuXG4gICAgICAgICAgICBpdGVtcy5zcGxpY2UoaW5kZXgsIDAsIGl0ZW0pO1xuXG4gICAgICAgICAgICBtZS5pdGVtcyA9IGl0ZW1zO1xuXG4gICAgICAgICAgICBtZS5nZXRWZG9tSXRlbXNSb290KCkuY24uc3BsaWNlKGluZGV4LCAwLCBpdGVtLmNyZWF0ZVZkb21SZWZlcmVuY2UoKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgICAobGNhIHx8IG1lKS51cGRhdGVEZXB0aCA9IC0xOyAvLyBwYXNzIHRoZSBmdWxsIHZkb20gdHJlZSB0byBob25vciBuZXcgbmVzdGVkIGNvbXBvbmVudCB0cmVlc1xuXG4gICAgICAgICAgICAobGNhIHx8IG1lKS5wcm9taXNlVXBkYXRlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgbWUuZmlyZSgnaW5zZXJ0Jywge2luZGV4LCBpdGVtfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkIGl0ZW1zIGZyb20gYSByZW1vdGUgZW5kcG9pbnQuXG4gICAgICogU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbmVvbWpzL25lby90cmVlL2Rldi9leGFtcGxlcy9zZXJ2ZXJzaWRlXG4gICAgICogVGhlIHJlc3BvbnNlIHNob3VsZCByZXR1cm4gYSBKU09OIGZpbGUgaW4gdGhlIGZvbGxvd2luZyBmb3JtYXQ6XG4gICAgICoge1wibW9kdWxlc1wiOiBbXSwgXCJpdGVtc1wiOiBbXX1cbiAgICAgKiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9uZW9tanMvbmVvL2Jsb2IvZGV2L2V4YW1wbGVzL3NlcnZlcnNpZGUvZ3JpZENvbnRhaW5lci9yZXNvdXJjZXMvZGF0YS9ncmlkLWNvbnRhaW5lci5qc29uXG4gICAgICogSXQgaXMgaW1wb3J0YW50IHRvIGFkZCBtb2R1bGVzIHdoaWNoIGFyZSBub3QgYWxyZWFkeSBpbXBvcnRlZCBpbnNpZGUgeW91ciBhcHAgeWV0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtkYXRhLm9wdGlvbnM9e31dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEudXJsXG4gICAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0W10+fVxuICAgICAqL1xuICAgIGFzeW5jIGxvYWRJdGVtcyh7b3B0aW9ucz17fSwgdXJsfSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICByZXNwb25zZSAgID0gYXdhaXQgbWUudHJhcChmZXRjaCh1cmwsIG9wdGlvbnMpKSxcbiAgICAgICAgICAgIHJlbW90ZURhdGEgPSBhd2FpdCBtZS50cmFwKHJlc3BvbnNlLmpzb24oKSk7XG5cbiAgICAgICAgaWYgKHJlbW90ZURhdGEubW9kdWxlcz8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgYXdhaXQgbWUudHJhcChQcm9taXNlLmFsbChyZW1vdGVEYXRhLm1vZHVsZXMubWFwKG1vZHVsZVBhdGggPT4ge1xuICAgICAgICAgICAgICAgIC8vIEFkanVzdCByZWxhdGl2ZSBVUkxzXG4gICAgICAgICAgICAgICAgaWYgKCFtb2R1bGVQYXRoLnN0YXJ0c1dpdGgoJ2h0dHAnKSkge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVQYXRoID0gKE5lby5jb25maWcuZW52aXJvbm1lbnQgPT09ICdkZXZlbG9wbWVudCcgPyAnLi4vLi4vJyA6ICcuLi8uLi8uLi8uLi8nKSArIG1vZHVsZVBhdGhcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW1wb3J0KC8qIHdlYnBhY2tJZ25vcmU6IHRydWUgKi8gbW9kdWxlUGF0aClcbiAgICAgICAgICAgIH0pKSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZW1vdGVEYXRhLml0ZW1zXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBsb2FkU29ydFpvbmVNb2R1bGUoKSB7XG4gICAgICAgIHJldHVybiBpbXBvcnQoJy4uL2RyYWdnYWJsZS9jb250YWluZXIvU29ydFpvbmUubWpzJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG1lcmdlQ29uZmlnKC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb25maWcgPSBzdXBlci5tZXJnZUNvbmZpZyguLi5hcmdzKSxcbiAgICAgICAgICAgIGN0b3JJdGVtcztcblxuICAgICAgICAvLyBBdm9pZCBhbnkgaW50ZXJmZXJlbmNlIG9uIHByb3RvdHlwZSBsZXZlbFxuICAgICAgICAvLyBEb2VzIG5vdCBjbG9uZSBleGlzdGluZyBOZW8gaW5zdGFuY2VzXG4gICAgICAgIGlmIChjb25maWcuaXRlbXMpIHtcbiAgICAgICAgICAgIGN0b3JJdGVtcyA9IG1lLmNvbnN0cnVjdG9yLmNvbmZpZy5pdGVtcztcblxuICAgICAgICAgICAgLy8gSWYgd2UgYXJlIHBhc3NlZCBhbiBvYmplY3QsIG1lcmdlIHRoZSBjbGFzcydzIG93biBpdGVtcyBvYmplY3QgaW50byBpdFxuICAgICAgICAgICAgaWYgKE5lby50eXBlT2YoY29uZmlnLml0ZW1zKSA9PT0gJ09iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoTmVvLmlzQXJyYXkoY3Rvckl0ZW1zKSkge1xuICAgICAgICAgICAgICAgICAgICBtZS5pdGVtcyA9IE5lby5jbG9uZShjb25maWcuaXRlbXMsIHRydWUsIHRydWUpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuaXRlbXMgPSBOZW8ubWVyZ2UoTmVvLmNsb25lKGN0b3JJdGVtcyksIGNvbmZpZy5pdGVtcylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lLl9pdGVtcyA9IE5lby5jbG9uZShjb25maWcuaXRlbXMsIHRydWUsIHRydWUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgY29uZmlnLml0ZW1zXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uZmlnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgYW4gZXhpc3RpbmcgaXRlbSB0byBhIG5ldyBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmcm9tSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdG9JbmRleFxuICAgICAqIEByZXR1cm5zIHtOZW8uY29tcG9uZW50LkJhc2V9XG4gICAgICovXG4gICAgbW92ZVRvKGZyb21JbmRleCwgdG9JbmRleCkge1xuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtID0gbWUuaXRlbXNbZnJvbUluZGV4XTtcblxuICAgICAgICBmcm9tSW5kZXggIT09IHRvSW5kZXggJiYgbWUuc3dpdGNoSXRlbXModG9JbmRleCwgZnJvbUluZGV4KTtcblxuICAgICAgICByZXR1cm4gaXRlbVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25Db25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBsYXlvdXRDb25maWcgPSBtZS5sYXlvdXQ7XG5cbiAgICAgICAgLy8gSWYgdGhlIGxheW91dCBpcyBhIGNvbmZpZyBvYmplY3QgKG5vdCBhbiBpbnN0YW5jZSksIGRlZXAgY2xvbmUgaXRcbiAgICAgICAgLy8gdG8gcHJldmVudCBwcm90b3R5cGUgcG9sbHV0aW9uLlxuICAgICAgICBpZiAobGF5b3V0Q29uZmlnICYmICEobGF5b3V0Q29uZmlnIGluc3RhbmNlb2YgTGF5b3V0QmFzZSkpIHtcbiAgICAgICAgICAgIGxheW91dENvbmZpZyA9IE5lby5jbG9uZShsYXlvdXRDb25maWcsIHRydWUpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbiBjYXNlIHRoZSBDb250YWluZXIgZG9lcyBub3QgaGF2ZSBhIGxheW91dCBjb25maWcsIHRoZSBzZXR0ZXIgd29uJ3QgdHJpZ2dlclxuICAgICAgICBtZS5fbGF5b3V0ID0gbWUuY3JlYXRlTGF5b3V0KGxheW91dENvbmZpZyk7XG4gICAgICAgIG1lLl9sYXlvdXQ/LmFwcGx5UmVuZGVyQXR0cmlidXRlcygpO1xuXG4gICAgICAgIHN1cGVyLm9uQ29uc3RydWN0ZWQoKTtcblxuICAgICAgICBtZS5wYXJzZUl0ZW1Db25maWdzKG1lLl9pdGVtcyk7XG4gICAgICAgIG1lLmNyZWF0ZUl0ZW1zKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGNvbmZpZ1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBsYXlvdXRDb25maWdcbiAgICAgKi9cbiAgICBwYXJzZUxheW91dENsYXNzKGNvbmZpZykge1xuICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KGNvbmZpZykpIHtcbiAgICAgICAgICAgIGlmICghY29uZmlnLm50eXBlLnN0YXJ0c1dpdGgoJ2xheW91dC0nKSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5udHlwZSA9IGBsYXlvdXQtJHtjb25maWcubnR5cGV9YFxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnID0ge1xuICAgICAgICAgICAgICAgIG50eXBlOiBjb25maWcuc3RhcnRzV2l0aCgnbGF5b3V0LScpID8gY29uZmlnIDogYGxheW91dC0ke2NvbmZpZ31gXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uZmlnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGNvbnRhaW5lciBpdGVtIGJ5IHJlZmVyZW5jZVxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkZXN0cm95SXRlbT10cnVlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbGVudD1mYWxzZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtrZWVwTW91bnRlZD1mYWxzZV1cbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9XG4gICAgICovXG4gICAgcmVtb3ZlKGNvbXBvbmVudCwgZGVzdHJveUl0ZW09dHJ1ZSwgc2lsZW50PWZhbHNlLCBrZWVwTW91bnRlZD1mYWxzZSkge1xuICAgICAgICBsZXQgaXRlbXMgPSBbLi4udGhpcy5pdGVtc10sXG4gICAgICAgICAgICBpICAgICA9IDAsXG4gICAgICAgICAgICBsZW4gICA9IGl0ZW1zLmxlbmd0aDtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaXRlbXNbaV0uaWQgPT09IGNvbXBvbmVudC5pZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUF0KGksIGRlc3Ryb3lJdGVtLCBzaWxlbnQsIGtlZXBNb3VudGVkKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBpdGVtIGFycmF5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBkZXN0cm95SXRlbXM9dHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50PWZhbHNlXG4gICAgICovXG4gICAgcmVtb3ZlQWxsKGRlc3Ryb3lJdGVtcz10cnVlLCBzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5pdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaWYgKGRlc3Ryb3lJdGVtcykge1xuICAgICAgICAgICAgICAgIGl0ZW0uZGVzdHJveSh0cnVlLCB0cnVlKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVtLm1vdW50ZWQgPSBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBtZS5pdGVtcyA9IFtdO1xuXG4gICAgICAgIG1lLmdldFZkb21JdGVtc1Jvb3QoKS5jbiA9IFtdO1xuXG4gICAgICAgIGlmICghc2lsZW50IHx8IGRlc3Ryb3lJdGVtcykge1xuICAgICAgICAgICAgbWUudXBkYXRlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBjb250YWluZXIgaXRlbSBhdCBhIGdpdmVuIGluZGV4LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBkZXN0cm95SXRlbT10cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaWxlbnQ9ZmFsc2VcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGtlZXBNb3VudGVkPWZhbHNlIFNldCB0byBgdHJ1ZWAgdG8ga2VlcCB0aGUgaXRlbSdzIGBtb3VudGVkYCBzdGF0ZSBhcyBgdHJ1ZWAuXG4gICAgICogVGhpcyBpcyBjcml0aWNhbCBmb3IgKipBdG9taWMgTW92ZXMqKiwgd2hlcmUgdGhlIGl0ZW0gaXMgcmVtb3ZlZCBmcm9tIG9uZSBjb250YWluZXIgYW5kIGltbWVkaWF0ZWx5IGFkZGVkXG4gICAgICogdG8gYW5vdGhlciwgYW5kIHdlIGRvIG5vdCB3YW50IHRvIHRyaWdnZXIgdW5tb3VudCBsaWZlY3ljbGUgaG9va3MgaW4gYmV0d2Vlbi5cbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9XG4gICAgICovXG4gICAgcmVtb3ZlQXQoaW5kZXgsIGRlc3Ryb3lJdGVtPXRydWUsIHNpbGVudD1mYWxzZSwga2VlcE1vdW50ZWQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2l0ZW1zfSA9IG1lLFxuICAgICAgICAgICAgaXRlbTtcblxuICAgICAgICBpZiAoaW5kZXggPj0gaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBOZW8ud2FybignQ29udGFpbmVyLnJlbW92ZUF0OiBpbmRleCA+PSBpdGVtcy5sZW5ndGguICcgKyBtZS5pZClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0gPSBpdGVtc1tpbmRleF07XG5cbiAgICAgICAgICAgIGl0ZW1zLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAgICAgICAgIG1lLmdldFZkb21JdGVtc1Jvb3QoKS5jbi5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICAgICAgICAvLyB0aGUgbmV4dCB1cGRhdGUgY3ljbGUgbmVlZHMgdG8gaW5jbHVkZSBkaXJlY3QgY2hpbGRyZW5cbiAgICAgICAgICAgIG1lLnVwZGF0ZURlcHRoID0gMjtcblxuICAgICAgICAgICAgIXNpbGVudCAmJiBtZS51cGRhdGUoKTtcblxuICAgICAgICAgICAgaWYgKGRlc3Ryb3lJdGVtKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5kZXN0cm95KHRydWUsIHNpbGVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWUubGF5b3V0Py5yZW1vdmVDaGlsZEF0dHJpYnV0ZXMoaXRlbSk7XG4gICAgICAgICAgICAgICAgaWYgKCFrZWVwTW91bnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLm1vdW50ZWQgPSBmYWxzZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgY29udGFpbmVyIGl0ZW0gYXQgdGhlIGxhc3QgaW5kZXhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkZXN0cm95SXRlbT10cnVlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbGVudD1mYWxzZV1cbiAgICAgKi9cbiAgICByZW1vdmVMYXN0KGRlc3Ryb3lJdGVtPXRydWUsIHNpbGVudD1mYWxzZSkge1xuICAgICAgICB0aGlzLnJlbW92ZUF0KHRoaXMuaXRlbXMubGVuZ3RoIC0gMSwgZGVzdHJveUl0ZW0sIHNpbGVudClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBhIGNvbnRhaW5lciBpdGVtIGF0IGEgZ2l2ZW4gaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gaXRlbVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGVzdHJveUl0ZW09dHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50PWZhbHNlXG4gICAgICovXG4gICAgcmVwbGFjZUF0KGluZGV4LCBpdGVtLCBkZXN0cm95SXRlbT10cnVlLCBzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVBdChpbmRleCwgZGVzdHJveUl0ZW0sIHRydWUpO1xuICAgICAgICB0aGlzLmluc2VydChpbmRleCwgaXRlbSwgc2lsZW50KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN3aXRjaGVzIHRoZSBwb3NpdGlvbiBvZiAyIGRpcmVjdCBjaGlsZCBpdGVtc1xuICAgICAqIFlvdSBjYW4gZWl0aGVyIHBhc3MgYW4gaW5kZXggKE51bWJlcikgb3IgaWQgKFN0cmluZylcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGl0ZW0xaWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGl0ZW0yaWRcbiAgICAgKi9cbiAgICBzd2l0Y2hJdGVtcyhpdGVtMWlkLCBpdGVtMmlkKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW0xSW5kZXggPSBOZW8uaXNOdW1iZXIoaXRlbTFpZCkgPyBpdGVtMWlkIDogbWUuaW5kZXhPZihpdGVtMWlkKSxcbiAgICAgICAgICAgIGl0ZW0ySW5kZXggPSBOZW8uaXNOdW1iZXIoaXRlbTJpZCkgPyBpdGVtMmlkIDogbWUuaW5kZXhPZihpdGVtMmlkKTtcblxuICAgICAgICBOZW9BcnJheS5tb3ZlKG1lLml0ZW1zLCAgICAgICAgICAgICAgICAgaXRlbTJJbmRleCwgaXRlbTFJbmRleCk7XG4gICAgICAgIE5lb0FycmF5Lm1vdmUobWUuZ2V0VmRvbUl0ZW1zUm9vdCgpLmNuLCBpdGVtMkluZGV4LCBpdGVtMUluZGV4KTtcblxuICAgICAgICAvLyB0aGUgbmV4dCB1cGRhdGUgY3ljbGUgbmVlZHMgdG8gaW5jbHVkZSBkaXJlY3QgY2hpbGRyZW5cbiAgICAgICAgbWUudXBkYXRlRGVwdGggPSAyO1xuXG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0aGUgY29udGFpbmVyIGludG8gYSBKU09OLWNvbXBhdGlibGUgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcbiAgICAgICAgICAgIGRyYWdSZXNvcnRhYmxlOiBtZS5kcmFnUmVzb3J0YWJsZSxcbiAgICAgICAgICAgIGl0ZW1Db3VudCAgICAgOiBtZS5pdGVtcz8ubGVuZ3RoIHx8IDAsXG4gICAgICAgICAgICBpdGVtRGVmYXVsdHMgIDogbWUuaXRlbURlZmF1bHRzLFxuICAgICAgICAgICAgaXRlbXMgICAgICAgICA6IG1lLml0ZW1zPy5tYXAoaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbVR5cGUgPSBOZW8udHlwZU9mKGl0ZW0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1UeXBlID09PSAnTmVvSW5zdGFuY2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLmlkXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1UeXBlID09PSAnT2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoTmVvLmlzRnVuY3Rpb24oaXRlbS5tb2R1bGUpICYmICFpdGVtLm1vZHVsZS5pc0NsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLml0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlOiBpdGVtLm1vZHVsZS50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbWUuc2VyaWFsaXplQ29uZmlnKGl0ZW0pXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGxheW91dDogbWUubGF5b3V0Py50b0pTT04oKVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhDb250YWluZXIpO1xuIiwiaW1wb3J0IENvbnRhaW5lciBmcm9tICcuL0Jhc2UubWpzJztcbmltcG9ydCBUb29sYmFyICAgZnJvbSAnLi4vdG9vbGJhci9CYXNlLm1qcyc7XG5cbi8qKlxuICogQW4gZXh0ZW5kZWQgQ29udGFpbmVyIHN1cHBvcnRpbmcgbXVsdGlwbGUgZG9ja2VkIGhlYWRlciB0b29sYmFyc1xuICogQGNsYXNzIE5lby5jb250YWluZXIuUGFuZWxcbiAqIEBleHRlbmRzIE5lby5jb250YWluZXIuQmFzZVxuICovXG5jbGFzcyBQYW5lbCBleHRlbmRzIENvbnRhaW5lciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29udGFpbmVyLlBhbmVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29udGFpbmVyLlBhbmVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3BhbmVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3BhbmVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLXBhbmVsJywnbmVvLWNvbnRhaW5lciddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1wYW5lbCcsICduZW8tY29udGFpbmVyJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGNvbnRhaW5lckNvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluZXJDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGhlYWRlckRlZmF1bHRzPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGhlYWRlckRlZmF1bHRzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl9IGhlYWRlcnM9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgaGVhZGVyczogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gaXRlbXM9e250eXBlOiAndmJveCcsIGFsaWduOiAnc3RyZXRjaCd9XG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgX2xheW91dDoge1xuICAgICAgICAgICAgbnR5cGU6ICd2Ym94JyxcbiAgICAgICAgICAgIGFsaWduOiAnc3RyZXRjaCdcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHZlcnRpY2FsSGVhZGVyc0ZpcnN0PWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB2ZXJ0aWNhbEhlYWRlcnNGaXJzdDogZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5oYXNIZWFkZXJzKCkgJiYgbWUudmVydGljYWxIZWFkZXJzRmlyc3QgPT09IHRydWUpIHtcbiAgICAgICAgICAgIG1lLmxheW91dCA9IHtcbiAgICAgICAgICAgICAgICBudHlwZTogJ2hib3gnLFxuICAgICAgICAgICAgICAgIGFsaWduOiAnc3RyZXRjaCdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaGVhZGVyIHRoZSBoZWFkZXIgY29uZmlnXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlSGVhZGVyQ29uZmlnKGhlYWRlcikge1xuICAgICAgICBpZiAoTmVvLnR5cGVPZihoZWFkZXIpID09PSAnTmVvSW5zdGFuY2UnKSB7XG4gICAgICAgICAgICByZXR1cm4gaGVhZGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgIGZsZXg6ICcwIDEgYXV0bydcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIWhlYWRlci5tb2R1bGUgJiYgIWhlYWRlci5udHlwZSkge1xuICAgICAgICAgICAgY29uZmlnLmNscyAgID0gWyduZW8tcGFuZWwtaGVhZGVyLXRvb2xiYXInLCAnbmVvLXRvb2xiYXInXTtcbiAgICAgICAgICAgIGNvbmZpZy5udHlwZSA9ICd0b29sYmFyJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoZWFkZXIudGV4dCkge1xuICAgICAgICAgICAgY29uZmlnLml0ZW1zID0gW3tcbiAgICAgICAgICAgICAgICBudHlwZTogJ2xhYmVsJyxcbiAgICAgICAgICAgICAgICBjbHMgIDogWyduZW8tcGFuZWwtaGVhZGVyLXRleHQnLCAnbmVvLWxhYmVsJ10sXG4gICAgICAgICAgICAgICAgdGV4dCA6IGhlYWRlci50ZXh0XG4gICAgICAgICAgICB9XTtcblxuICAgICAgICAgICAgZGVsZXRlIGhlYWRlci50ZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXNzdW1pbmcgYWxsIGxhYmVscyBpbnNpZGUgYSBQYW5lbCBIZWFkZXIgYXJlIG1lYW50IHRvIGJlIHRpdGxlcyAtPiBsb29rIHRoZSBzYW1lIHdheVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXIuaXRlbXMpKSB7XG4gICAgICAgICAgICBoZWFkZXIuaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5udHlwZSA9PT0gJ2xhYmVsJykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmNscyA9IFsnbmVvLXBhbmVsLWhlYWRlci10ZXh0JywgJ25lby1sYWJlbCddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsuLi5jb25maWcsIC4uLmhlYWRlcn1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGNyZWF0ZUl0ZW1zKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbnRhaW5lckNvbmZpZyA9IG1lLmNvbnRhaW5lckNvbmZpZztcblxuICAgICAgICBpZiAoIW1lLmhhc0hlYWRlcnMoKSkge1xuICAgICAgICAgICAgY29udGFpbmVyQ29uZmlnICYmIG1lLnNldChjb250YWluZXJDb25maWcpO1xuICAgICAgICAgICAgc3VwZXIuY3JlYXRlSXRlbXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBoZiAgICAgICAgICAgICAgICAgICA9IG1lLnZlcnRpY2FsSGVhZGVyc0ZpcnN0ID09PSBmYWxzZSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzICAgICAgICAgICAgICA9IG1lLmhlYWRlcnMgfHwgW10sXG4gICAgICAgICAgICAgICAgYm90dG9tSGVhZGVycyAgICAgICAgPSBoZWFkZXJzLmZpbHRlcihoZWFkZXIgPT4ge3JldHVybiBoZWFkZXIuZG9jayA9PT0gKGhmID8nYm90dG9tJzogJ3JpZ2h0Jyl9KSxcbiAgICAgICAgICAgICAgICBsZWZ0SGVhZGVycyAgICAgICAgICA9IGhlYWRlcnMuZmlsdGVyKGhlYWRlciA9PiB7cmV0dXJuIGhlYWRlci5kb2NrID09PSAoaGYgPydsZWZ0JyAgOiAndG9wJyl9KSxcbiAgICAgICAgICAgICAgICByaWdodEhlYWRlcnMgICAgICAgICA9IGhlYWRlcnMuZmlsdGVyKGhlYWRlciA9PiB7cmV0dXJuIGhlYWRlci5kb2NrID09PSAoaGYgPydyaWdodCcgOiAnYm90dG9tJyl9KSxcbiAgICAgICAgICAgICAgICB0b3BIZWFkZXJzICAgICAgICAgICA9IGhlYWRlcnMuZmlsdGVyKGhlYWRlciA9PiB7cmV0dXJuIGhlYWRlci5kb2NrID09PSAoaGYgPyd0b3AnICAgOiAnbGVmdCcpfSksXG4gICAgICAgICAgICAgICAgaGFzSG9yaXpvbnRhbEhlYWRlcnMgPSBib3R0b21IZWFkZXJzLmxlbmd0aCA+IDAgfHwgdG9wSGVhZGVycyAgLmxlbmd0aCA+IDAsXG4gICAgICAgICAgICAgICAgaGFzVmVydGljYWxIZWFkZXJzICAgPSBsZWZ0SGVhZGVycyAgLmxlbmd0aCA+IDAgfHwgcmlnaHRIZWFkZXJzLmxlbmd0aCA+IDAsXG4gICAgICAgICAgICAgICAge2l0ZW1zfSAgICAgICAgICAgICAgPSBtZSxcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsSXRlbXMgICAgICA9IFtdLFxuICAgICAgICAgICAgICAgIHZlcnRpY2FsSXRlbXMgICAgICAgID0gW10sXG4gICAgICAgICAgICAgICAgY29uZmlnO1xuXG4gICAgICAgICAgICB0b3BIZWFkZXJzLmZvckVhY2goaGVhZGVyID0+IHtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEl0ZW1zLnB1c2goUGFuZWwuY3JlYXRlSGVhZGVyQ29uZmlnKGhlYWRlcikpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGhhc1ZlcnRpY2FsSGVhZGVycyAmJiAoaGYgJiYgaGFzSG9yaXpvbnRhbEhlYWRlcnMgfHwgIWhmICYmIGhhc0hvcml6b250YWxIZWFkZXJzKSkge1xuICAgICAgICAgICAgICAgIGxlZnRIZWFkZXJzLmZvckVhY2goaGVhZGVyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaG9yaXpvbnRhbEl0ZW1zLnB1c2goUGFuZWwuY3JlYXRlSGVhZGVyQ29uZmlnKGhlYWRlcikpXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBjb25maWcgPSB7XG4gICAgICAgICAgICAgICAgICAgIG50eXBlICAgICAgIDogJ2NvbnRhaW5lcicsXG4gICAgICAgICAgICAgICAgICAgIGZsZXggICAgICAgIDogMSxcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1EZWZhdWx0czogbWUuaXRlbURlZmF1bHRzLFxuICAgICAgICAgICAgICAgICAgICAuLi5jb250YWluZXJDb25maWdcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbEl0ZW1zLnB1c2goey4uLm1lLmhlYWRlckRlZmF1bHRzLCAuLi5jb25maWd9KTtcblxuICAgICAgICAgICAgICAgIHJpZ2h0SGVhZGVycy5mb3JFYWNoKGhlYWRlciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGhvcml6b250YWxJdGVtcy5wdXNoKFBhbmVsLmNyZWF0ZUhlYWRlckNvbmZpZyhoZWFkZXIpKVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdmVydGljYWxJdGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbnR5cGUgICAgOiAnY29udGFpbmVyJyxcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMgICAgOiBob3Jpem9udGFsSXRlbXMsXG4gICAgICAgICAgICAgICAgICAgIGxheW91dCAgIDoge250eXBlOiAoaGYgPyAnaGJveCcgOiAndmJveCcpLCBhbGlnbjogJ3N0cmV0Y2gnfSxcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlOiAnYm9keUNvbnRhaW5lcidcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uZmlnID0ge1xuICAgICAgICAgICAgICAgICAgICBudHlwZSAgICAgICA6ICdjb250YWluZXInLFxuICAgICAgICAgICAgICAgICAgICBmbGV4ICAgICAgICA6IDEsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zLFxuICAgICAgICAgICAgICAgICAgICBpdGVtRGVmYXVsdHM6IG1lLml0ZW1EZWZhdWx0cyxcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlICAgOiAnYm9keUNvbnRhaW5lcicsXG4gICAgICAgICAgICAgICAgICAgIC4uLmNvbnRhaW5lckNvbmZpZ1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEl0ZW1zLnB1c2goey4uLm1lLmhlYWRlckRlZmF1bHRzLCAuLi5jb25maWd9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBib3R0b21IZWFkZXJzLmZvckVhY2goaGVhZGVyID0+IHtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEl0ZW1zLnB1c2goUGFuZWwuY3JlYXRlSGVhZGVyQ29uZmlnKGhlYWRlcikpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbWUuaXRlbXMgPSB2ZXJ0aWNhbEl0ZW1zO1xuXG4gICAgICAgICAgICBtZS5pdGVtRGVmYXVsdHMgPSBudWxsO1xuXG4gICAgICAgICAgICBzdXBlci5jcmVhdGVJdGVtcygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNIZWFkZXJzKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0aGlzLmhlYWRlcnMpICYmIHRoaXMuaGVhZGVycy5sZW5ndGggPiAwXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhQYW5lbCk7XG4iLCJpbXBvcnQgQ29udGFpbmVyIGZyb20gJy4vQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uY29udGFpbmVyLlZpZXdwb3J0XG4gKiBAZXh0ZW5kcyBOZW8uY29udGFpbmVyLkJhc2VcbiAqL1xuY2xhc3MgVmlld3BvcnQgZXh0ZW5kcyBDb250YWluZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbnRhaW5lci5WaWV3cG9ydCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbnRhaW5lci5WaWV3cG9ydCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSd2aWV3cG9ydCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICd2aWV3cG9ydCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0cnVlIGFwcGxpZXMgJ25lby1ib2R5LXZpZXdwb3J0JyB0byB0aGUgZG9jdW1lbnQuYm9keVxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhcHBseUJvZHlDbHM9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXBwbHlCb2R5Q2xzOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQXNzdW1pbmcgdGhhdCBhIFZpZXdwb3J0IGlzIHRoZSB0b3AgbGV2ZWwgdmlldyBvZiB5b3VyIGFwcCwgYW5kIHlvdSB3YW50IHRvIG1vdW50IGl0IHJpZ2h0IGF3YXkuXG4gICAgICAgICAqIENvdWxkIGJlIHdpdGhvdXQgYW55IGl0ZW1zLiBVc2UgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhdXRvTW91bnQ9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXV0b01vdW50OiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tdmlld3BvcnQnXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tdmlld3BvcnQnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRydWUgYXBwbGllcyBhIG1haW4uYWRkb24uUmVzaXplT2JzZXJ2ZXIgYW5kIGZpcmVzIGEgY3VzdG9tIHJlc2l6ZSBldmVudFxuICAgICAgICAgKiB3aGljaCBvdGhlciBpbnN0YW5jZXMgY2FuIHN1YnNjcmliZSB0by5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbW9uaXRvclNpemVfPWZhbHNlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbW9uaXRvclNpemVfOiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbW91bnRlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHZhbHVlICYmIG1lLm1vbml0b3JTaXplKSB7XG4gICAgICAgICAgICBtZS5hZGREb21MaXN0ZW5lcnMoW3tyZXNpemU6IG1lLm9uRG9tUmVzaXplLCBzY29wZTogbWV9XSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25Db25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgc3VwZXIub25Db25zdHJ1Y3RlZCgpO1xuXG4gICAgICAgIGxldCB7d2luZG93SWR9ID0gdGhpcztcblxuICAgICAgICB0aGlzLmFwcGx5Qm9keUNscyAmJiBOZW8ubWFpbi5Eb21BY2Nlc3MuYXBwbHlCb2R5Q2xzKHtcbiAgICAgICAgICAgIGNsczogWyduZW8tYm9keS12aWV3cG9ydCddLFxuICAgICAgICAgICAgd2luZG93SWRcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRG9tUmVzaXplKGRhdGEpIHtcbiAgICAgICAgdGhpcy5maXJlKCdyZXNpemUnLCBkYXRhKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVmlld3BvcnQpO1xuIiwiaW1wb3J0IHsgY3JlYXRlU2VxdWVuY2UgfSBmcm9tICcuLi8uLi91dGlsL0Z1bmN0aW9uLm1qcyc7XG5pbXBvcnQgQ29tcG9uZW50ICAgICAgICBmcm9tICcuLi8uLi9jb21wb25lbnQvQmFzZS5tanMnO1xuaW1wb3J0IENvbXBvbmVudE1hbmFnZXIgZnJvbSAnLi4vLi4vbWFuYWdlci9Db21wb25lbnQubWpzJztcbmltcG9ydCBOZW9BcnJheSAgICAgICAgIGZyb20gJy4uLy4uL3V0aWwvQXJyYXkubWpzJztcblxuLyoqXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBmb3JtIGZpZWxkc1xuICogQGNsYXNzIE5lby5mb3JtLmZpZWxkLkJhc2VcbiAqIEBleHRlbmRzIE5lby5jb21wb25lbnQuQmFzZVxuICovXG5jbGFzcyBGaWVsZCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogVmFsaWQgdmFsdWVzIGZvciBpc1RvdWNoZWRFdmVudFxuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBpc1RvdWNoZWRFdmVudHM9Wydmb2N1c0VudGVyJywnZm9jdXNMZWF2ZSddXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgaXNUb3VjaGVkRXZlbnRzID0gWydmb2N1c0VudGVyJywgJ2ZvY3VzTGVhdmUnXVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZm9ybS5maWVsZC5CYXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZm9ybS5maWVsZC5CYXNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2Jhc2VmaWVsZCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdiYXNlZmllbGQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogRm9ybSBncm91cHMgY2FuIGdldCBzZXQgb24gYW55IHBhcmVudCBjb21wb25lbnQgbGV2ZWwuXG4gICAgICAgICAqIEFuIGFsdGVybmF0aXZlIHdheSBmb3IgdXNpbmcgZG90cyBpbiBmaWVsZCBuYW1lcy5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGZvcm1Hcm91cF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGZvcm1Hcm91cF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0ga2V5cz17fVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGtleXM6IHt9LFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSBpbmRpY2F0ZXMgdGhhdCBhIHVzZXIgaGFzIGludGVyYWN0ZWQgd2l0aCB0aGUgZm9ybSBmaWVsZFxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc1RvdWNoZWRfPWZhbHNlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgaXNUb3VjaGVkXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBuYW1lIHdoaWNoIHNldHMgaXNUb3VjaGVkIHRvIHRydWUuIFZhbGlkIG9wdGlvbnMgYXJlICdmb2N1c0VudGVyJyAmICdmb2N1c0xlYXZlJ1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGlzVG91Y2hlZF89ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBpc1RvdWNoZWRFdmVudF86ICdmb2N1c0xlYXZlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBuYW1lXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbmFtZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOZW8gaXRzZWxmIGRvZXMgbm90IG5lZWQgZmllbGQgbmFtZXMgdG8gZ2V0IG1hcHBlZCB0byB0aGUgRE9NIChpbnB1dCBub2RlcyksXG4gICAgICAgICAqIGV4Y2VwdCBmb3IgQ2hlY2tCb3hlcyAmIFJhZGlvcyB0byB3b3JrLiBJdCBjYW4gYmUgdXNlZnVsIGZvciB0ZXN0aW5nIHRvb2xzXG4gICAgICAgICAqICYgYWNjZXNzaWJpbGl0eSB0aG91Z2gsIHNvIHRoZSBkZWZhdWx0IGdvdCBzZXQgdG8gdHJ1ZS5cbiAgICAgICAgICogRmVlbCBmcmVlIHRvIGNoYW5nZSBpdCB0byBmYWxzZSB0byBrZWVwIHRoZSBET00gbWluaW1hbC5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gcmVuZGVyTmFtZV89dHJ1ZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHJlbmRlck5hbWVfOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW4gY2FzZSByZW5kZXJOYW1lIGlzIHNldCB0byB0cnVlLCB5b3UgY2FuIG9wdGlvbmFsbHkgcmVuZGVyIHRoZSBjb21iaW5hdGlvblxuICAgICAgICAgKiBvZiBhbGwgZm9ybUdyb3VwKHMpICYgdGhlIGZpZWxkIG5hbWUgaW50byB0aGUgRE9NID0+IGlucHV0IG5vZGVcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gcmVuZGVyUGF0aD10cnVlXG4gICAgICAgICAqL1xuICAgICAgICByZW5kZXJQYXRoOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Kn0gdmFsdWVfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZV86IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBpbnRlcm5hbCBjYWNoZSBmb3IgZm9ybUdyb3VwcyBvZiBhbGwgcGFyZW50IGxldmVsc1xuICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBmb3JtR3JvdXBTdHJpbmc9bnVsbFxuICAgICAqL1xuICAgIGZvcm1Hcm91cFN0cmluZyA9IG51bGxcbiAgICAvKipcbiAgICAgKiBCYXNlIGltcGxlbWVudGF0aW9uIHRvIGNoZWNrIGlmIHRoZSBmaWVsZHMgdmFsdWUgaGFzIGNoYW5nZWQuXG4gICAgICogQ2FuIGdldCBvdmVycmlkZGVuIGluIHN1cGVyY2xhc3Nlcy5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgaXNEaXJ0eSgpIHtcbiAgICAgICAgcmV0dXJuICFOZW8uaXNFcXVhbCh0aGlzLmdldFN1Ym1pdFZhbHVlKCksIHRoaXMub3JpZ2luYWxDb25maWcudmFsdWUpXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFuIGludGVybmFsIGNhY2hlIGZvciBmb3JtR3JvdXAocykgYW5kIHRoZSBmaWVsZCBuYW1lXG4gICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IHBhdGg9bnVsbFxuICAgICAqL1xuICAgIHBhdGggPSBudWxsXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGNyZWF0ZVNlcXVlbmNlKG1lLCAnYWZ0ZXJTZXRWYWx1ZScsICh2YWx1ZSwgb2xkVmFsdWUpID0+IHtcbiAgICAgICAgICAgIG9sZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgbWUuZmlyZUNoYW5nZUV2ZW50KHZhbHVlLCBvbGRWYWx1ZSlcbiAgICAgICAgfSwgbWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBuYW1lIGlzVG91Y2hlZCBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhZnRlclNldElzVG91Y2hlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IHtjbHN9ID0gdGhpcztcblxuICAgICAgICBOZW9BcnJheS50b2dnbGUoY2xzLCAnbmVvLWlzLXRvdWNoZWQnLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuY2xzID0gY2xzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBuYW1lIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhZnRlclNldE5hbWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUucmVuZGVyTmFtZSAmJiBtZS5jaGFuZ2VJbnB1dEVsS2V5KCduYW1lJywgbWUucmVuZGVyUGF0aCA/IG1lLmdldFBhdGgoKSA6IHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcm9sZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Um9sZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5nZXRJbnB1dEVsKCkucm9sZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB2YWx1ZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHBhcmFtIHsqfSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIGFmdGVyU2V0VmFsdWUodmFsdWUsIG9sZFZhbHVlKSB7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhY2Nlc3NpbmcgdGhlIGZvcm1Hcm91cCBjb25maWdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8bnVsbH0gcGFyZW50c1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVHZXRGb3JtR3JvdXAodmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIGdyb3VwID0gW10sXG4gICAgICAgICAgICByZXR1cm5WYWx1ZTtcblxuICAgICAgICBpZiAobWUuZm9ybUdyb3VwU3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbWUuZm9ybUdyb3VwU3RyaW5nXG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSAmJiBncm91cC5wdXNoKHZhbHVlKTtcblxuICAgICAgICBDb21wb25lbnRNYW5hZ2VyLmdldFBhcmVudHMobWUpLmZvckVhY2gocGFyZW50ID0+IHtcbiAgICAgICAgICAgIHBhcmVudC5mb3JtR3JvdXAgJiYgZ3JvdXAudW5zaGlmdChwYXJlbnQuZm9ybUdyb3VwKVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm5WYWx1ZSA9IGdyb3VwLmpvaW4oJy4nKTtcblxuICAgICAgICBtZS5mb3JtR3JvdXBTdHJpbmcgPSByZXR1cm5WYWx1ZTtcblxuICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBpc1RvdWNoZWRFdmVudCBjb25maWcgZ2V0cyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldElzVG91Y2hlZEV2ZW50KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnaXNUb3VjaGVkRXZlbnQnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIHZhbHVlIG9mIGEgaW5wdXRFbCB2ZG9tIG9iamVjdCBhdHRyaWJ1dGUgb3IgcmVtb3ZlcyBpdCBpbiBjYXNlIGl0IGhhcyBubyB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fE51bWJlcnxPYmplY3R8U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaWxlbnQ9ZmFsc2VcbiAgICAgKi9cbiAgICBjaGFuZ2VJbnB1dEVsS2V5KGtleSwgdmFsdWUsIHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSB8fCBOZW8uaXNCb29sZWFuKHZhbHVlKSB8fCB2YWx1ZSA9PT0gMCkge1xuICAgICAgICAgICAgbWUuZ2V0SW5wdXRFbCgpW2tleV0gPSB2YWx1ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIG1lLmdldElucHV0RWwoKVtrZXldXG4gICAgICAgIH1cblxuICAgICAgICAhc2lsZW50ICYmIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgYXMgbmVlZGVkXG4gICAgICogQHBhcmFtIHsqfSAgICAgIHZhbHVlXG4gICAgICogQHBhcmFtIHsqfSAgICAgIG9sZFZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICAgICAqL1xuICAgIGRvRmlyZUNoYW5nZUV2ZW50KHZhbHVlLCBvbGRWYWx1ZSwgZXZlbnROYW1lKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIEZvcm1Db250YWluZXIgPSBOZW8uZm9ybT8uQ29udGFpbmVyLFxuICAgICAgICAgICAgZm9ybUV2ZW50ICAgICA9ICdmaWVsZCcgKyBOZW8uY2FwaXRhbGl6ZShldmVudE5hbWUpLFxuICAgICAgICAgICAgb3B0cyAgICAgICAgICA9IHtjb21wb25lbnQ6IG1lLCBvbGRWYWx1ZSwgdmFsdWV9O1xuXG4gICAgICAgIGlmIChOZW8uaXNGdW5jdGlvbihtZS5nZXRHcm91cFZhbHVlKSkge1xuICAgICAgICAgICAgb3B0cy5ncm91cFZhbHVlID0gbWUuZ2V0R3JvdXBWYWx1ZSgpXG4gICAgICAgIH1cblxuICAgICAgICBtZS5maXJlKGV2ZW50TmFtZSwgb3B0cyk7XG5cbiAgICAgICAgaWYgKCFtZS5zdXNwZW5kRXZlbnRzKSB7XG4gICAgICAgICAgICBDb21wb25lbnRNYW5hZ2VyLmdldFBhcmVudHMobWUpLmZvckVhY2gocGFyZW50ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoRm9ybUNvbnRhaW5lciAmJiBwYXJlbnQgaW5zdGFuY2VvZiBGb3JtQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5maXJlKGZvcm1FdmVudCwgb3B0cylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgYXMgbmVlZGVkXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBmaXJlQ2hhbmdlRXZlbnQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMuZG9GaXJlQ2hhbmdlRXZlbnQodmFsdWUsIG9sZFZhbHVlLCAnY2hhbmdlJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBhcyBuZWVkZWRcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHBhcmFtIHsqfSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIGZpcmVVc2VyQ2hhbmdlRXZlbnQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMuZG9GaXJlQ2hhbmdlRXZlbnQodmFsdWUsIG9sZFZhbHVlLCAndXNlckNoYW5nZScpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9ybXMgaW4gbmVvIGNhbiBiZSBuZXN0ZWQuIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIHRoZSBjbG9zZXN0IHBhcmVudCB3aGljaCBpcyBhIGZvcm0uQ29udGFpbmVyIG9yIG51bGwuXG4gICAgICogQHJldHVybnMge05lby5mb3JtLkNvbnRhaW5lcnxudWxsfVxuICAgICAqL1xuICAgIGdldENsb3Nlc3RGb3JtKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBGb3JtQ29udGFpbmVyID0gTmVvLmZvcm0/LkNvbnRhaW5lcixcbiAgICAgICAgICAgIHBhcmVudDtcblxuICAgICAgICBmb3IgKHBhcmVudCBvZiBDb21wb25lbnRNYW5hZ2VyLmdldFBhcmVudHMobWUpKSB7XG4gICAgICAgICAgICBpZiAoRm9ybUNvbnRhaW5lciAmJiBwYXJlbnQgaW5zdGFuY2VvZiBGb3JtQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBhcyBuZWVkZWRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgZ2V0SW5wdXRFbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmRvbVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbWJpbmF0aW9uIG9mIHRoZSBmaWVsZCBmb3JtR3JvdXAocykgJiBuYW1lXG4gICAgICogQHJldHVybnMge1N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIGdldFBhdGgoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBwYXRoO1xuXG4gICAgICAgIC8vIGZpZWxkcyBjb3VsZCBoYXZlIGZvcm1Hcm91cHMsIGJ1dCBubyBuYW1lLlxuICAgICAgICAvLyByZXR1cm5pbmcgdGhlIG5hbWVzcGFjZSBjYW4gY29uZnVzZSBmb3JtLkNvbnRhaW5lci5hZGp1c3RUcmVlTGVhdmVzKCksXG4gICAgICAgIC8vIHNpbmNlIG5hbWVzcGFjZXMgY291bGQgYmUgY29uc2lkZXJlZCBhcyBmaWVsZCBpbnN0YW5jZXMuXG4gICAgICAgIGlmICghbWUubmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbWUucGF0aCkge1xuICAgICAgICAgICAgcGF0aCA9IG1lLmZvcm1Hcm91cCA/IG1lLmZvcm1Hcm91cC5zcGxpdCgnLicpIDogW107XG5cbiAgICAgICAgICAgIG1lLm5hbWUgJiYgcGF0aC5wdXNoKG1lLm5hbWUpO1xuXG4gICAgICAgICAgICBpZiAocGF0aC5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUucGF0aCA9IHBhdGguam9pbignLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtZS5wYXRoKSB7XG4gICAgICAgICAgICBtZS5wYXRoID0gJ25vbmUnXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWUucGF0aCA9PT0gJ25vbmUnID8gbnVsbDogbWUucGF0aFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFN1Ym1pdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIGluIHY3LnhcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3VibWl0VmFsdWUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzVmFsaWQoKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkZvY3VzRW50ZXIoZGF0YSkge1xuICAgICAgICBzdXBlci5vbkZvY3VzTGVhdmUoZGF0YSk7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNUb3VjaGVkRXZlbnQgPT09ICdmb2N1c0VudGVyJykge1xuICAgICAgICAgICAgdGhpcy5pc1RvdWNoZWQgPSB0cnVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGEub2xkUGF0aFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbkZvY3VzTGVhdmUoZGF0YSkge1xuICAgICAgICBzdXBlci5vbkZvY3VzTGVhdmUoZGF0YSk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgRm9ybUNvbnRhaW5lciA9IE5lby5mb3JtPy5Db250YWluZXIsXG4gICAgICAgICAgICBvcHRzICAgICAgICAgID0gey4uLmRhdGEsIGNvbXBvbmVudDogbWUsIHZhbHVlOiBtZS5nZXRTdWJtaXRWYWx1ZSgpfTtcblxuICAgICAgICBpZiAobWUuaXNUb3VjaGVkRXZlbnQgPT09ICdmb2N1c0xlYXZlJykge1xuICAgICAgICAgICAgbWUuaXNUb3VjaGVkID0gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE5lby5pc0Z1bmN0aW9uKG1lLmdldEdyb3VwVmFsdWUpKSB7XG4gICAgICAgICAgICBvcHRzLmdyb3VwVmFsdWUgPSBtZS5nZXRHcm91cFZhbHVlKClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbWUuc3VzcGVuZEV2ZW50cykge1xuICAgICAgICAgICAgQ29tcG9uZW50TWFuYWdlci5nZXRQYXJlbnRzKG1lKS5mb3JFYWNoKHBhcmVudCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKEZvcm1Db250YWluZXIgJiYgcGFyZW50IGluc3RhbmNlb2YgRm9ybUNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuZmlyZSgnZmllbGRGb2N1c0xlYXZlJywgb3B0cylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBmaWVsZCB0byBhIG5ldyB2YWx1ZSBvciBudWxsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZT1udWxsXG4gICAgICovXG4gICAgcmVzZXQodmFsdWU9bnVsbCkge1xuICAgICAgICB0aGlzLm9yaWdpbmFsQ29uZmlnLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBmb3IgY2xpZW50LXNpZGUgZmllbGQgZXJyb3JzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaWxlbnQ9dHJ1ZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaW4gY2FzZSB0aGVyZSBhcmUgbm8gY2xpZW50LXNpZGUgZXJyb3JzXG4gICAgICovXG4gICAgdmFsaWRhdGUoc2lsZW50PXRydWUpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0aGUgZmllbGQgaW50byBhIEpTT04tY29tcGF0aWJsZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLnRvSlNPTigpLFxuICAgICAgICAgICAgZm9ybUdyb3VwOiBtZS5mb3JtR3JvdXAsXG4gICAgICAgICAgICBpc0RpcnR5ICA6IG1lLmlzRGlydHksXG4gICAgICAgICAgICBpc1RvdWNoZWQ6IG1lLmlzVG91Y2hlZCxcbiAgICAgICAgICAgIGlzVmFsaWQgIDogbWUuaXNWYWxpZCgpLFxuICAgICAgICAgICAgbmFtZSAgICAgOiBtZS5uYW1lLFxuICAgICAgICAgICAgdmFsdWUgICAgOiBtZS52YWx1ZVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBjaGFuZ2UgZXZlbnQgZmlyZXMgYWZ0ZXIgdGhlIHZhbHVlIGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAqIEBldmVudCBjaGFuZ2VcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7Kn0gb2xkVmFsdWVcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoRmllbGQpO1xuIiwiaW1wb3J0IENvbXBvbmVudE1hbmFnZXIgZnJvbSAnLi4vLi4vbWFuYWdlci9Db21wb25lbnQubWpzJztcbmltcG9ydCBGaWVsZCAgICAgICAgICAgIGZyb20gJy4vQmFzZS5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICAgICAgICAgZnJvbSAnLi4vLi4vdXRpbC9BcnJheS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZm9ybS5maWVsZC5DaGVja0JveFxuICogQGV4dGVuZHMgTmVvLmZvcm0uZmllbGQuQmFzZVxuICovXG5jbGFzcyBDaGVja0JveCBleHRlbmRzIEZpZWxkIHtcbiAgICAvKipcbiAgICAgKiBWYWxpZCB2YWx1ZXMgZm9yIGxhYmVsUG9zaXRpb25cbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gbGFiZWxQb3NpdGlvbnM9WydsZWZ0JywndG9wJ11cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBsYWJlbFBvc2l0aW9ucyA9IFsnbGVmdCcsICd0b3AnXVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZm9ybS5maWVsZC5DaGVja0JveCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmZvcm0uZmllbGQuQ2hlY2tCb3gnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nY2hlY2tib3hmaWVsZCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdjaGVja2JveGZpZWxkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWNoZWNrYm94ZmllbGQnXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tY2hlY2tib3hmaWVsZCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gY2hlY2tlZF89ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBjaGVja2VkXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gZXJyb3JfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBlcnJvcl86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VmdWwgZm9yIGZpZWxkcyBpbnNpZGUgYSBjc3MgZ3JpZCB3aGVyZSBlcnJvcnMgc2hvdWxkIGxpdmUgb3V0c2lkZSB0aGUgbGF5b3V0XG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGVycm9yUG9zaXRpb25BYnNvbHV0ZV89ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBlcnJvclBvc2l0aW9uQWJzb2x1dGVfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBlcnJvclRleHRHcm91cFJlcXVpcmVkPSdSZXF1aXJlZCdcbiAgICAgICAgICovXG4gICAgICAgIGVycm9yVGV4dEdyb3VwUmVxdWlyZWQ6IGRhdGEgPT4gYFBsZWFzZSBjaGVjayBhdCBsZWFzdCBvbmUgaXRlbSBvZiB0aGUgZ3JvdXA6ICR7ZGF0YS5uYW1lfWAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGVycm9yVGV4dFJlcXVpcmVkPSdSZXF1aXJlZCdcbiAgICAgICAgICovXG4gICAgICAgIGVycm9yVGV4dFJlcXVpcmVkOiAnUmVxdWlyZWQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZ3JvdXBSZXF1aXJlZF89ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBncm91cFJlcXVpcmVkXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBoaWRlTGFiZWxfPWZhbHNlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgaGlkZUxhYmVsXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gaWNvbkNscz1bJ2ZhcicsJ2ZhLXNxdWFyZSddXG4gICAgICAgICAqL1xuICAgICAgICBpY29uQ2xzOiBbJ2ZhcicsICdmYS1zcXVhcmUnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBpY29uQ2xzQ2hlY2tlZD1bJ2ZhcycsJ2ZhLWNoZWNrJ11cbiAgICAgICAgICovXG4gICAgICAgIGljb25DbHNDaGVja2VkOiBbJ2ZhcycsICdmYS1jaGVjayddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBpbnB1dFR5cGVfPSdjaGVja2JveCdcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBpbnB1dFR5cGVfOiAnY2hlY2tib3gnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGxhYmVsQmFzZUNscz1bJ25lby1jaGVja2JveC1sYWJlbCddXG4gICAgICAgICAqL1xuICAgICAgICBsYWJlbEJhc2VDbHM6IFsnbmVvLWNoZWNrYm94LWxhYmVsJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gbGFiZWxDbHNfPVtdXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWxDbHNfOiBbXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVkZ2UtY2FzZSBjb25maWcgaW4gY2FzZSB3ZSB3YW50IHRvIHJlbmRlciBsZWFkaW5nIGNvbnRlbnQgd2l0aCB0aGVpciBvd24gc2VsZWN0b3JzIGxpa2U6XG4gICAgICAgICAqIDxzcGFuIGNsYXNzPVwibXktbGFiZWwtaWQtY2xzXCI+RTEwPC9zcGFuPiDCtyBGaXJzdG5hbWVcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGxhYmVsSWRfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBsYWJlbElkXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENTUyBydWxlcyBmb3IgbGFiZWxJZFxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gbGFiZWxJZENsc189W11cbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBsYWJlbElkQ2xzXzogW10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXBhcmF0b3IgYmV0d2VlbiBsYWJlbElkICYgbGFiZWxUZXh0XG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbGFiZWxJZFNlcGFyYXRvcl89JyDCtyAnXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWxJZFNlcGFyYXRvcl86ICcgwrcgJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhbGlkIHZhbHVlczogJ2xlZnQnLCAndG9wJ1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGxhYmVsUG9zaXRpb25fPSdsZWZ0J1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGxhYmVsUG9zaXRpb25fOiAnbGVmdCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGFiZWwgdGV4dCBvciBWRE9NLlxuICAgICAgICAgKiBTdXBwb3J0czpcbiAgICAgICAgICogLSBTdHJpbmc6IFJlbmRlcnMgYXMgc2FmZSB0ZXh0ICh0ZXh0Q29udGVudCkuXG4gICAgICAgICAqIC0gT2JqZWN0OiBBIHNpbmdsZSBWRE9NIG9iamVjdC5cbiAgICAgICAgICogLSBPYmplY3RbXTogQW4gYXJyYXkgb2YgVkRPTSBvYmplY3RzLlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8T2JqZWN0W118U3RyaW5nfSBsYWJlbFRleHRfPSdMYWJlbFRleHQnXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWxUZXh0XzogJ0xhYmVsVGV4dCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkZWZhdWx0cyB0byBweFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8U3RyaW5nfSBsYWJlbFdpZHRoXz0xNTBcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBsYWJlbFdpZHRoXzogMTUwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gcmVxdWlyZWRfPWZhbHNlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVxdWlyZWRfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZSBjYXNlOiBTZXQgdGhpcyBjb25maWcgdG8gZmFsc2UgZm9yIGFsbCBidXQgb25lIGl0ZW0gd2l0aCB0aGUgc2FtZSBuYW1lLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaG93RXJyb3JUZXh0c189dHJ1ZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHNob3dFcnJvclRleHRzXzogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluIGNhc2UgdGhlIENoZWNrQm94IGRvZXMgbm90IGJlbG9uZyB0byBhIGdyb3VwIChtdWx0aXBsZSBmaWVsZHMgd2l0aCB0aGUgc2FtZSBuYW1lKSxcbiAgICAgICAgICogeW91IGNhbiBwYXNzIGEgY3VzdG9tIHZhbHVlIGZvciB0aGUgdW5jaGVja2VkIHN0YXRlLlxuICAgICAgICAgKiBAbWVtYmVyIHsqfSB1bmNoZWNrZWRWYWx1ZT1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdW5jaGVja2VkVmFsdWU6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVXNpbmcgdGhlIGFsZXJ0IHN0YXRlIHdpbGwgZGlzcGxheSBhbiBlbXB0eSBidXQgcmVxdWlyZWQgZmllbGQgaW4gb3JhbmdlIGluc3RlYWQgb2YgcmVkLlxuICAgICAgICAgKiBJbnRlbmRlZCB0byBnZXQgY29tYmluZWQgd2l0aCBmb3JtLkNvbnRhaW5lcjogZ2V0Rm9ybVN0YXRlKCkuXG4gICAgICAgICAqIFNlZSBhcHBzL2Zvcm0gYXMgYW4gZXhhbXBsZS5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gdXNlQWxlcnRTdGF0ZV89ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB1c2VBbGVydFN0YXRlXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufE51bWJlcnxTdHJpbmd8bnVsbH0gdmFsdWU9dHJ1ZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxhYmVsIHRleHQgb3IgVkRPTSB0byBkaXNwbGF5IG5leHQgdG8gdGhlIGNoZWNrYm94LlxuICAgICAgICAgKiBTdXBwb3J0czpcbiAgICAgICAgICogLSBTdHJpbmc6IFJlbmRlcnMgYXMgc2FmZSB0ZXh0ICh0ZXh0Q29udGVudCkuXG4gICAgICAgICAqIC0gT2JqZWN0OiBBIHNpbmdsZSBWRE9NIG9iamVjdCAoZS5nLiB7dGFnOiAnaScsIGNsczogJ2ZhIGZhLWNoZWNrJ30pLlxuICAgICAgICAgKiAtIE9iamVjdFtdOiBBbiBhcnJheSBvZiBWRE9NIG9iamVjdHMuXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxPYmplY3RbXXxTdHJpbmd8bnVsbH0gdmFsdWVMYWJlbF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlTGFiZWxfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbVxuICAgICAgICAgKi9cbiAgICAgICAgX3Zkb206XG4gICAgICAgIHtjbjogW1xuICAgICAgICAgICAge3RhZzogJ2xhYmVsJywgY2xzOiBbJ25lby1jaGVja2JveC1sYWJlbCddLCBjbjogW1xuICAgICAgICAgICAgICAgIHt0YWc6ICdzcGFuJywgIGNsczogW119LFxuICAgICAgICAgICAgICAgIHt0YWc6ICdpbnB1dCcsIGNsczogWyduZW8tY2hlY2tib3gtaW5wdXQnXX0sXG4gICAgICAgICAgICAgICAge3RhZzogJ2knLCAgICAgY2xzOiBbJ25lby1jaGVja2JveC1pY29uJ119LFxuICAgICAgICAgICAgICAgIHt0YWc6ICdzcGFuJywgIGNsczogWyduZW8tY2hlY2tib3gtdmFsdWUtbGFiZWwnXX1cbiAgICAgICAgICAgIF19LFxuICAgICAgICAgICAge2NsczogWyduZW8tZXJyb3Itd3JhcHBlciddLCByZW1vdmVEb206IHRydWUsIGNuOiBbXG4gICAgICAgICAgICAgICAge2NsczogWyduZW8tZXJyb3InXX1cbiAgICAgICAgICAgIF19XG4gICAgICAgIF19XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoaXMgdmFsdWUgdG8gZmFsc2UsIGluIGNhc2UgYSBmaWVsZCBzaG91bGQgZGlzcGxheSBlcnJvcnMgdXAgZnJvbnQuXG4gICAgICogT3RoZXJ3aXNlLCBlcnJvcnMgd2lsbCBzdGF5IGhpZGRlbiBvbiBtb3VudGluZywgdW5sZXNzIHlvdSB0cmlnZ2VyIHZhbGlkYXRlKGZhbHNlKS5cbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBjbGVhbj10cnVlXG4gICAgICovXG4gICAgY2xlYW4gPSB0cnVlXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmFkZERvbUxpc3RlbmVycyhcbiAgICAgICAgICAgIHtjaGFuZ2U6IG1lLm9uSW5wdXRWYWx1ZUNoYW5nZSwgc2NvcGU6IG1lfVxuICAgICAgICApXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRDaGVja2VkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBsYWJlbEVsID0gbWUudmRvbS5jblswXSxcbiAgICAgICAgICAgIGljb25DbHMgPSBsYWJlbEVsLmNuWzJdLmNscyxcbiAgICAgICAgICAgIG5ld0NscyAgPSB2YWx1ZSA/IG1lLmljb25DbHNDaGVja2VkIDogbWUuaWNvbkNscyxcbiAgICAgICAgICAgIG9sZENscyAgPSB2YWx1ZSA/IG1lLmljb25DbHMgOiBtZS5pY29uQ2xzQ2hlY2tlZDtcblxuICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgIG1lLmNsZWFuID0gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnZhbGlkYXRlKCk7IC8vIHNpbGVudFxuXG4gICAgICAgIGxhYmVsRWwuY25bMV0uY2hlY2tlZCA9IHZhbHVlO1xuXG4gICAgICAgIE5lb0FycmF5LnJlbW92ZUFkZChpY29uQ2xzLCBvbGRDbHMsIG5ld0Nscyk7XG5cbiAgICAgICAgbWUudXBkYXRlKCk7XG5cbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1lLmZpcmVDaGFuZ2VFdmVudChtZS5nZXRTdWJtaXRWYWx1ZSgpLCBtZS5nZXRPbGRTdWJtaXRWYWx1ZSgpKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBlcnJvciBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RXJyb3IodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRXJyb3IodmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBlcnJvclBvc2l0aW9uQWJzb2x1dGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRFcnJvclBvc2l0aW9uQWJzb2x1dGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgPSB0aGlzLFxuICAgICAgICAgICAgY2xzID0gbWUudmRvbS5jblsxXS5jblswXS5jbHM7XG5cbiAgICAgICAgTmVvQXJyYXlbdmFsdWUgPyAnYWRkJyA6ICdyZW1vdmUnXShjbHMsICduZW8tYWJzb2x1dGUnKTtcblxuICAgICAgICBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcmVxdWlyZWQgZ3JvdXBSZXF1aXJlZCBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0R3JvdXBSZXF1aXJlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnZhbGlkYXRlKGZhbHNlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaGlkZUxhYmVsIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEhpZGVMYWJlbCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5nZXRMYWJlbEVsKCkucmVtb3ZlRG9tID0gdmFsdWU7XG4gICAgICAgIHRoaXMudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZW5zdXJlU3RhYmxlSWRzKCkge1xuICAgICAgICBzdXBlci5lbnN1cmVTdGFibGVJZHMoKTtcblxuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBsYWJlbEVsID0gbWUudmRvbS5jblswXTtcblxuICAgICAgICBsYWJlbEVsLmNuWzBdLmlkID0gbWUuZ2V0TGFiZWxJZCgpO1xuICAgICAgICBsYWJlbEVsLmNuWzFdLmlkID0gbWUuZ2V0SW5wdXRFbElkKCk7XG4gICAgICAgIGxhYmVsRWwuY25bMl0uaWQgPSBtZS5nZXRJY29uRWxJZCgpO1xuICAgICAgICBsYWJlbEVsLmNuWzNdLmlkID0gbWUuZ2V0VmFsdWVMYWJlbElkKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGlucHV0VHlwZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRJbnB1dFR5cGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlSW5wdXRFbEtleSgndHlwZScsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbGFiZWxDbHMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldExhYmVsQ2xzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgID0gdGhpcyxcbiAgICAgICAgICAgIGNscyA9IG1lLmdldExhYmVsRWwoKS5jbHM7XG5cbiAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgb2xkVmFsdWUpO1xuICAgICAgICBOZW9BcnJheS5hZGQoY2xzLCB2YWx1ZSk7XG5cbiAgICAgICAgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGxhYmVsUG9zaXRpb24gY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TGFiZWxQb3NpdGlvbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjbHN9ID0gbWU7XG5cbiAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgJ25lby1sYWJlbC0nICsgb2xkVmFsdWUpO1xuICAgICAgICBOZW9BcnJheS5hZGQoICAgY2xzLCAnbmVvLWxhYmVsLScgKyB2YWx1ZSk7XG4gICAgICAgIG1lLmNscyA9IGNsc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbGFiZWxUZXh0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fE9iamVjdFtdfFN0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxPYmplY3RbXXxTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TGFiZWxUZXh0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBsYWJlbEVsID0gbWUuZ2V0TGFiZWxFbCgpO1xuXG4gICAgICAgIGlmIChtZS5sYWJlbElkKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IFt7XG4gICAgICAgICAgICAgICAgdGFnIDogJ3NwYW4nLFxuICAgICAgICAgICAgICAgIGNscyA6IG1lLmxhYmVsSWRDbHMsXG4gICAgICAgICAgICAgICAgdGV4dDogbWUubGFiZWxJZFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHRhZyA6ICdzcGFuJyxcbiAgICAgICAgICAgICAgICB0ZXh0OiBtZS5sYWJlbElkU2VwYXJhdG9yXG4gICAgICAgICAgICB9LCAuLi4oQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IChOZW8uaXNTdHJpbmcodmFsdWUpID8gW3t0ZXh0OiB2YWx1ZX1dIDogW3ZhbHVlXSkpXTtcblxuICAgICAgICAgICAgbGFiZWxFbC5jbiA9IHZhbHVlO1xuICAgICAgICAgICAgZGVsZXRlIGxhYmVsRWwudGV4dFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKE5lby5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBsYWJlbEVsLnRleHQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBkZWxldGUgbGFiZWxFbC5jblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsYWJlbEVsLmNuID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG4gICAgICAgICAgICAgICAgZGVsZXRlIGxhYmVsRWwudGV4dFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGxhYmVsV2lkdGggY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRMYWJlbFdpZHRoKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUuaGlkZUxhYmVsKSB7XG4gICAgICAgICAgICBtZS5nZXRMYWJlbEVsKCkud2lkdGggPSB2YWx1ZTtcbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHJlcXVpcmVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0UmVxdWlyZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgdGhpcy52YWxpZGF0ZShmYWxzZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNob3dFcnJvclRleHRzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U2hvd0Vycm9yVGV4dHModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgdGhpcy52YWxpZGF0ZShmYWxzZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHVzZUFsZXJ0U3RhdGUgZ3JvdXBSZXF1aXJlZCBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VXNlQWxlcnRTdGF0ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IHtjbHN9ID0gdGhpcztcbiAgICAgICAgTmVvQXJyYXkudG9nZ2xlKGNscywgJ25lby11c2UtYWxlcnQtc3RhdGUnLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuY2xzID0gY2xzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB2YWx1ZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VJbnB1dEVsS2V5KCd2YWx1ZScsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdmFsdWVMYWJlbCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdHxPYmplY3RbXXxTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxPYmplY3RbXXxTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRWYWx1ZUxhYmVsKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB2YWx1ZUxhYmVsID0gbWUudmRvbS5jblswXS5jblszXSxcbiAgICAgICAgICAgIHNob3dMYWJlbCAgPSAhIXZhbHVlOyAvLyBoaWRlIHRoZSBsYWJlbCwgaW4gY2FzZSB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gJydcblxuICAgICAgICBpZiAoc2hvd0xhYmVsKSB7XG4gICAgICAgICAgICBpZiAoTmVvLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlTGFiZWwudGV4dCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZUxhYmVsLmNuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlTGFiZWwuY24gPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVMYWJlbC50ZXh0XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZUxhYmVsLnJlbW92ZURvbSA9ICFzaG93TGFiZWw7XG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgZ3JvdXBSZXF1aXJlZCBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldEdyb3VwUmVxdWlyZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0aGlzLnJlcXVpcmVkKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RvIG5vdCB1c2UgZ3JvdXBSZXF1aXJlZCAmIHJlcXVpcmVkIGF0IHRoZSBzYW1lIHRpbWUuIFN3aXRjaGluZyB0byByZXF1aXJlZC4nLCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgbGFiZWxDbHMgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldExhYmVsQ2xzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gTmVvQXJyYXkudW5pb24odmFsdWUgfHwgW10sIHRoaXMubGFiZWxCYXNlQ2xzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGxhYmVsUG9zaXRpb24gY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGJlZm9yZVNldExhYmVsUG9zaXRpb24odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlZm9yZVNldEVudW1WYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICdsYWJlbFBvc2l0aW9uJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSByZW5kZXJOYW1lIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQ2hlY2tCb3hlcyAmIHJhZGlvcyByZWx5IG9uIHRoaXMgZmxhZyBiZWluZyBzZXQgdG8gdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFJlbmRlck5hbWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1N0cmluZ1tdfVxuICAgICAqL1xuICAgIGdldEdyb3VwVmFsdWUoKSB7XG4gICAgICAgIGxldCBmb3JtICAgPSB0aGlzLmdldENsb3Nlc3RGb3JtKCksXG4gICAgICAgICAgICBwYXRoICAgPSB0aGlzLmdldFBhdGgoKSxcbiAgICAgICAgICAgIHZhbHVlICA9IFtdLFxuICAgICAgICAgICAgZmllbGRzO1xuXG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICBmaWVsZHMgPSBDb21wb25lbnRNYW5hZ2VyLmZpbmQoe3BhdGh9KTtcblxuICAgICAgICAgICAgZmllbGRzLmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZC5jaGVja2VkICYmIGZpZWxkLmdldENsb3Nlc3RGb3JtKCkgPT09IGZvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgTmVvQXJyYXkuYWRkKHZhbHVlLCBmaWVsZC52YWx1ZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRJY29uRWxJZCgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWR9X19pY29uYFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRJbnB1dEVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZG9tLmNuWzBdLmNuWzFdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRJbnB1dEVsSWQoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmlkfV9faW5wdXRgXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge09iamVjdHxudWxsfVxuICAgICAqL1xuICAgIGdldExhYmVsRWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZkb20uY25bMF0uY25bMF1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldExhYmVsSWQoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmlkfV9fbGFiZWxgXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ291bnRlcnBhcnQgdG8gZ2V0U3VibWl0VmFsdWUoKSwgcmV0dXJuaW5nIHRoZSB1bmNoZWNrZWRWYWx1ZSBpZiBjaGVja2VkXG4gICAgICogQHJldHVybnMge1N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIGdldE9sZFN1Ym1pdFZhbHVlKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBtZS5jaGVja2VkID8gbWUudW5jaGVja2VkVmFsdWUgOiBtZS52YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIGluIHY3LnhcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgZ2V0T2xkVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9sZFN1Ym1pdFZhbHVlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoaXMudmFsdWUgaWYgY2hlY2tlZCwgb3RoZXJ3aXNlIHRoaXMudW5jaGVja2VkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgZ2V0U3VibWl0VmFsdWUoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIG1lLmNoZWNrZWQgPyBtZS52YWx1ZSA6IG1lLnVuY2hlY2tlZFZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRWYWx1ZUxhYmVsSWQoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmlkfV9fdmFsdWUtbGFiZWxgXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNFbXB0eUFuZFJlcXVpcmVkKCkge1xuICAgICAgICAvLyBBc3N1bWluZyB0aGF0IGNoZWNrYm94ZXMgJiByYWRpb3MgY2FuIG9ubHkgdmFsaWRhdGUgZmFsc2UgaW4gY2FzZSB0aGV5IGFyZSBlbXB0eSAmIHJlcXVpcmVkXG4gICAgICAgIHJldHVybiAhdGhpcy52YWxpZGF0ZShmYWxzZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1ZhbGlkKCkge1xuICAgICAgICB0aGlzLnZhbGlkYXRlKHRydWUpOyAvLyBzaWxlbnRcblxuICAgICAgICByZXR1cm4gdGhpcy5lcnJvciA/IGZhbHNlIDogc3VwZXIuaXNWYWxpZCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0cmlnZ2VyZWQgd2hlbiBhIHVzZXIgY2hlY2tzIGEgY2hlY2tib3ggaW5wdXQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbklucHV0VmFsdWVDaGFuZ2UoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjaGVja2VkID0gZGF0YS50YXJnZXQuY2hlY2tlZDtcblxuICAgICAgICAvLyBrZWVwIHRoZSB2ZG9tICYgdm5vZGUgaW4gc3luYyBmb3IgZnV0dXJlIHVwZGF0ZXNcbiAgICAgICAgbWUudm5vZGUuY2hpbGROb2Rlc1swXS5jaGlsZE5vZGVzW21lLmhpZGVMYWJlbCA/IDAgOiAxXS5hdHRyaWJ1dGVzLmNoZWNrZWQgPSBgJHtjaGVja2VkfWA7XG5cbiAgICAgICAgbWUuY2hlY2tlZCA9IGNoZWNrZWQ7XG5cbiAgICAgICAgbWUuZmlyZVVzZXJDaGFuZ2VFdmVudChtZS5nZXRTdWJtaXRWYWx1ZSgpLCBtZS5nZXRPbGRTdWJtaXRWYWx1ZSgpKVxuICAgIH1cblxuICAgIC8qKlxuICAgICBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICBAcGFyYW0ge0Jvb2xlYW59IHNpbGVudD1mYWxzZVxuICAgICAqL1xuICAgIHVwZGF0ZUVycm9yKHZhbHVlLCBzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2xzfSAgICAgPSBtZSxcbiAgICAgICAgICAgIHNob3dFcnJvciA9IHZhbHVlICYmIG1lLnNob3dFcnJvclRleHRzLFxuICAgICAgICAgICAgZXJyb3JOb2RlLCBlcnJvcldyYXBwZXI7XG5cbiAgICAgICAgaWYgKCEobWUuY2xlYW4gJiYgIW1lLm1vdW50ZWQpKSB7XG4gICAgICAgICAgICBtZS5fZXJyb3IgPSB2YWx1ZTsgLy8gc2lsZW50IHVwZGF0ZVxuXG4gICAgICAgICAgICBOZW9BcnJheS50b2dnbGUoY2xzLCAnbmVvLWludmFsaWQnLCB2YWx1ZSk7XG4gICAgICAgICAgICBtZS5jbHMgPSBjbHM7XG5cbiAgICAgICAgICAgIGVycm9yV3JhcHBlciA9IG1lLnZkb20uY25bMV07XG4gICAgICAgICAgICBlcnJvck5vZGUgICAgPSBlcnJvcldyYXBwZXIuY25bMF07XG5cbiAgICAgICAgICAgIGlmIChzaG93RXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvck5vZGUudGV4dCA9IHZhbHVlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBlcnJvck5vZGUudGV4dFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlcnJvcldyYXBwZXIucmVtb3ZlRG9tID0gIXNob3dFcnJvcjtcblxuICAgICAgICAgICAgIXNpbGVudCAmJiBtZS51cGRhdGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGZvciBjbGllbnQtc2lkZSBmaWVsZCBlcnJvcnNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNpbGVudD10cnVlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpbiBjYXNlIHRoZXJlIGFyZSBubyBjbGllbnQtc2lkZSBlcnJvcnNcbiAgICAgKi9cbiAgICB2YWxpZGF0ZShzaWxlbnQ9dHJ1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge25hbWV9ICAgICAgPSBtZSxcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gdHJ1ZSxcbiAgICAgICAgICAgIGNoZWNrQm94LCBjaGVja0JveGVzO1xuXG4gICAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgICAvLyBpbiBjYXNlIHdlIG1hbnVhbGx5IGNhbGwgdmFsaWRhdGUoZmFsc2UpIG9uIGEgZm9ybSBvciBmaWVsZCBiZWZvcmUgaXQgaXMgbW91bnRlZCwgd2UgZG8gd2FudCB0byBzZWUgZXJyb3JzLlxuICAgICAgICAgICAgbWUuY2xlYW4gPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZS5ncm91cFJlcXVpcmVkKSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBkaXNjdXNzOiB3ZSBjb3VsZCBsaW1pdCB0aGlzIHRvIGNoZWNrQm94ZXMgLyByYWRpb3MgaW5zaWRlIHRoZSBzYW1lIGZvcm0sIElGIGEgdG9wIGxldmVsIGZvcm0gaXMgdXNlZFxuICAgICAgICAgICAgY2hlY2tCb3hlcyA9IENvbXBvbmVudE1hbmFnZXIuZmluZCh7XG4gICAgICAgICAgICAgICAgbnR5cGU6IG1lLm50eXBlLFxuICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBnZXQgdGhlIGdyb3VwIHZhbGlkaXR5IHN0YXRlIGZpcnN0XG4gICAgICAgICAgICBmb3IgKGNoZWNrQm94IG9mIGNoZWNrQm94ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tCb3guY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB1cGRhdGUgYWxsIGdyb3VwIGl0ZW1zXG4gICAgICAgICAgICBmb3IgKGNoZWNrQm94IG9mIGNoZWNrQm94ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tCb3guaWQgIT09IG1lLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWUuY2xlYW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrQm94LmNsZWFuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjaGVja0JveFttZS5jbGVhbiA/ICdfZXJyb3InIDogJ2Vycm9yJ10gPSByZXR1cm5WYWx1ZSA/IG51bGwgOiBjaGVja0JveC5lcnJvclRleHRHcm91cFJlcXVpcmVkKHtuYW1lfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghcmV0dXJuVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBtZS5fZXJyb3IgPSBtZS5lcnJvclRleHRHcm91cFJlcXVpcmVkKHtuYW1lfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtZS5yZXF1aXJlZCAmJiAhbWUuY2hlY2tlZCkge1xuICAgICAgICAgICAgbWUuX2Vycm9yID0gbWUuZXJyb3JUZXh0UmVxdWlyZWQ7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmV0dXJuVmFsdWUpIHtcbiAgICAgICAgICAgIG1lLl9lcnJvciA9IG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgICFtZS5jbGVhbiAmJiBtZS51cGRhdGVFcnJvcihtZS5fZXJyb3IsIHNpbGVudCk7XG5cbiAgICAgICAgcmV0dXJuICFyZXR1cm5WYWx1ZSA/IGZhbHNlIDogc3VwZXIudmFsaWRhdGUoc2lsZW50KVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIHRoZSBmaWVsZCBpbnRvIGEgSlNPTi1jb21wYXRpYmxlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXG4gICAgICAgICAgICBjaGVja2VkICAgICAgOiBtZS5jaGVja2VkLFxuICAgICAgICAgICAgaGlkZUxhYmVsICAgIDogbWUuaGlkZUxhYmVsLFxuICAgICAgICAgICAgaW5wdXRUeXBlICAgIDogbWUuaW5wdXRUeXBlLFxuICAgICAgICAgICAgbGFiZWxQb3NpdGlvbjogbWUubGFiZWxQb3NpdGlvbixcbiAgICAgICAgICAgIGxhYmVsVGV4dCAgICA6IG1lLmxhYmVsVGV4dCxcbiAgICAgICAgICAgIHZhbHVlTGFiZWwgICA6IG1lLnZhbHVlTGFiZWxcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIHRoZSBmaWVsZCBpbnRvIGEgSlNPTi1jb21wYXRpYmxlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXG4gICAgICAgICAgICBjaGVja2VkICAgICAgIDogbWUuY2hlY2tlZCxcbiAgICAgICAgICAgIGVycm9yICAgICAgICAgOiBtZS5lcnJvcixcbiAgICAgICAgICAgIGdyb3VwUmVxdWlyZWQgOiBtZS5ncm91cFJlcXVpcmVkLFxuICAgICAgICAgICAgaGlkZUxhYmVsICAgICA6IG1lLmhpZGVMYWJlbCxcbiAgICAgICAgICAgIGljb25DbHMgICAgICAgOiBtZS5pY29uQ2xzLFxuICAgICAgICAgICAgaWNvbkNsc0NoZWNrZWQ6IG1lLmljb25DbHNDaGVja2VkLFxuICAgICAgICAgICAgaW5wdXRUeXBlICAgICA6IG1lLmlucHV0VHlwZSxcbiAgICAgICAgICAgIGxhYmVsUG9zaXRpb24gOiBtZS5sYWJlbFBvc2l0aW9uLFxuICAgICAgICAgICAgbGFiZWxUZXh0ICAgICA6IG1lLmxhYmVsVGV4dCxcbiAgICAgICAgICAgIGxhYmVsV2lkdGggICAgOiBtZS5sYWJlbFdpZHRoLFxuICAgICAgICAgICAgcmVxdWlyZWQgICAgICA6IG1lLnJlcXVpcmVkLFxuICAgICAgICAgICAgdW5jaGVja2VkVmFsdWU6IG1lLnVuY2hlY2tlZFZhbHVlLFxuICAgICAgICAgICAgdmFsdWVMYWJlbCAgICA6IG1lLnZhbHVlTGFiZWxcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ2hlY2tCb3gpO1xuIiwiaW1wb3J0IFNwaW5Eb3duVHJpZ2dlciAgIGZyb20gJy4vdHJpZ2dlci9TcGluRG93bi5tanMnO1xuaW1wb3J0IFNwaW5VcFRyaWdnZXIgICAgIGZyb20gJy4vdHJpZ2dlci9TcGluVXAubWpzJztcbmltcG9ydCBTcGluVXBEb3duVHJpZ2dlciBmcm9tICcuL3RyaWdnZXIvU3BpblVwRG93bi5tanMnO1xuaW1wb3J0IFRleHQgICAgICAgICAgICAgIGZyb20gJy4vVGV4dC5tanMnO1xuXG4vKipcbiAqIFVzZXMgYW4gaW5wdXQgdHlwZSBudW1iZXIgYW5kIG9wdGlvbmFsbHkgcHJvdmlkZXMgY3VzdG9tIHNwaW4gYnV0dG9ucyBmb3IgdXAgYW5kIGRvd25cbiAqIEBjbGFzcyBOZW8uZm9ybS5maWVsZC5OdW1iZXJcbiAqIEBleHRlbmRzIE5lby5mb3JtLmZpZWxkLlRleHRcbiAqL1xuY2xhc3MgTnVtYmVyIGV4dGVuZHMgVGV4dCB7XG4gICAgLyoqXG4gICAgICogVmFsaWQgdmFsdWVzIGZvciB0cmlnZ2VyUG9zaXRpb25cbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gdHJpZ2dlclBvc2l0aW9ucz1bJ3JpZ2h0JywgJ3NpZGVzJ11cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyB0cmlnZ2VyUG9zaXRpb25zID0gWydyaWdodCcsICdzaWRlcyddXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5mb3JtLmZpZWxkLk51bWJlcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmZvcm0uZmllbGQuTnVtYmVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J251bWJlcmZpZWxkJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ251bWJlcmZpZWxkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLW51bWJlcmZpZWxkJywnbmVvLXRleHRmaWVsZCddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1udW1iZXJmaWVsZCcsICduZW8tdGV4dGZpZWxkJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcmV2ZW50IHVzZXJzIGZyb20gdHlwaW5nIHNwZWNpZmljIGNoYXJhY3RlcnMuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfG51bGx9IGRpc2FibGVkQ2hhcnM9WydlJywnRSddXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZWRDaGFyczogWydlJywgJ0UnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRhdGEgcGFzc2VzIG1heExlbmd0aCwgbWluTGVuZ3RoICYgdmFsdWVMZW5ndGggcHJvcGVydGllc1xuICAgICAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gZXJyb3JUZXh0TWF4VmFsdWU9ZGF0YT0+YE1heCB2YWx1ZSB2aW9sYXRpb246ICR7ZGF0YS52YWx1ZX0gLyAke2RhdGEubWF4VmFsdWV9YFxuICAgICAgICAgKi9cbiAgICAgICAgZXJyb3JUZXh0TWF4VmFsdWU6IGRhdGEgPT4gYE1heCB2YWx1ZSB2aW9sYXRpb246ICR7ZGF0YS52YWx1ZX0gLyAke2RhdGEubWF4VmFsdWV9YCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRhdGEgcGFzc2VzIG1heExlbmd0aCwgbWluTGVuZ3RoICYgdmFsdWVMZW5ndGggcHJvcGVydGllc1xuICAgICAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gZXJyb3JUZXh0TWluVmFsdWU9ZGF0YT0+YE1pbiB2YWx1ZSB2aW9sYXRpb246ICR7ZGF0YS52YWx1ZX0gLyAke2RhdGEubWluVmFsdWV9YFxuICAgICAgICAgKi9cbiAgICAgICAgZXJyb3JUZXh0TWluVmFsdWU6IGRhdGEgPT4gYE1pbiB2YWx1ZSB2aW9sYXRpb246ICR7ZGF0YS52YWx1ZX0gLyAke2RhdGEubWluVmFsdWV9YCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gZXJyb3JUZXh0U3RlcFNpemU9J1JlcXVpcmVkJ1xuICAgICAgICAgKi9cbiAgICAgICAgZXJyb3JUZXh0U3RlcFNpemU6IGRhdGEgPT4gYHN0ZXAtc2l6ZSB2aW9sYXRpb246ICR7ZGF0YS52YWx1ZX0gLyAke2RhdGEuc3RlcFNpemV9YCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcltdfG51bGx9IGV4Y2x1ZGVkPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGV4Y2x1ZGVkVmFsdWVzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogZmFsc2Ugb25seSBhbGxvd3MgY2hhbmdpbmcgdGhlIGZpZWxkIHVzaW5nIHRoZSBzcGluIGJ1dHRvbnNcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaW5wdXRFZGl0YWJsZV89dHJ1ZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGlucHV0RWRpdGFibGVfOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVmFsdWUgZm9yIHRoZSBpbnB1dFR5cGVfIHRleHRmaWVsZCBjb25maWdcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBpbnB1dFR5cGU9J251bWJlcidcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBpbnB1dFR5cGU6ICdudW1iZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBtYXhWYWx1ZV89MTAwXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbWF4VmFsdWVfOiAxMDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IG1pblZhbHVlXz0wXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbWluVmFsdWVfOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBzdGVwU2l6ZV89MVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHN0ZXBTaXplXzogMSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhbGlkIHZhbHVlczogJ3JpZ2h0JywgJ3NpZGVzJ1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHRyaWdnZXJQb3NpdGlvbj0ncmlnaHQnXG4gICAgICAgICAqL1xuICAgICAgICB0cmlnZ2VyUG9zaXRpb25fOiAncmlnaHQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gdXNlU3BpbkJ1dHRvbnNfPXRydWVcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB1c2VTcGluQnV0dG9uc186IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gc3RlcFNpemVEaWdpdHM9bnVsbFxuICAgICAqL1xuICAgIHN0ZXBTaXplRGlnaXRzID0gbnVsbFxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBpbnB1dEVkaXRhYmxlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldElucHV0RWRpdGFibGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGlucHV0RWwgPSBtZS5nZXRJbnB1dEVsKCksXG4gICAgICAgICAgICBzdHlsZSAgID0gaW5wdXRFbC5zdHlsZSB8fCB7fTtcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzdHlsZS5wb2ludGVyRXZlbnRzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnXG4gICAgICAgIH1cblxuICAgICAgICBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbWF4VmFsdWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TWF4VmFsdWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGUoKTsgLy8gc2lsZW50XG4gICAgICAgIHRoaXMuY2hhbmdlSW5wdXRFbEtleSgnbWF4JywgdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtaW5WYWx1ZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNaW5WYWx1ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0ZSgpOyAvLyBzaWxlbnRcbiAgICAgICAgdGhpcy5jaGFuZ2VJbnB1dEVsS2V5KCdtaW4nLCB2YWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHN0ZXBTaXplIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFN0ZXBTaXplKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgID0gdGhpcyxcbiAgICAgICAgICAgIHZhbCA9IG1lLnZhbHVlLFxuICAgICAgICAgICAgbW9kdWxvLCBzdGVwU2l6ZVN0cmluZztcblxuICAgICAgICBtZS5jaGFuZ2VJbnB1dEVsS2V5KCdzdGVwJywgdmFsdWUpO1xuXG4gICAgICAgIHN0ZXBTaXplU3RyaW5nID0gU3RyaW5nKHZhbHVlKTtcblxuICAgICAgICBtZS5zdGVwU2l6ZURpZ2l0cyA9IHN0ZXBTaXplU3RyaW5nLmluY2x1ZGVzKCcuJykgPyBzdGVwU2l6ZVN0cmluZy5zcGxpdCgnLicpWzFdLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgaWYgKHZhbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbW9kdWxvID0gKHZhbCAtIG1lLm1pblZhbHVlKSAlIHZhbHVlO1xuXG4gICAgICAgICAgICBpZiAobW9kdWxvICE9PSAwKSB7IC8vIGZpbmQgdGhlIGNsb3Nlc3QgdmFsaWQgdmFsdWVcbiAgICAgICAgICAgICAgICBpZiAobW9kdWxvIC8gdmFsdWUgPiAwLjUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCArIHZhbHVlIC0gbW9kdWxvIDwgbWUubWF4VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLnZhbHVlID0gdmFsICsgdmFsdWUgLSBtb2R1bG9cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWwgLSBtb2R1bG8gPiBtZS5taW5WYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUudmFsdWUgPSB2YWwgLSBtb2R1bG9cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwgLSBtb2R1bG8gPiBtZS5taW5WYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUudmFsdWUgPSB2YWwgLSBtb2R1bG9cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWwgKyB2YWx1ZSAtIG1vZHVsbyA8IG1lLm1heFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS52YWx1ZSA9IHZhbCArIHZhbHVlIC0gbW9kdWxvXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHRyaWdnZXJQb3NpdGlvbiBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRUcmlnZ2VyUG9zaXRpb24odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlICYmIHRoaXMudXBkYXRlVHJpZ2dlcnMoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdXNlU3BpbkJ1dHRvbnMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRVc2VTcGluQnV0dG9ucyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKE5lby5pc0Jvb2xlYW4ob2xkVmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRyaWdnZXJzKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIG1heExlbmd0aCBjb25maWcgZ2V0cyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRNYXhMZW5ndGgodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdpbnB1dCB0eXBlIG51bWJlciBkb2VzIG5vdCBzdXBwb3J0IG1heExlbmd0aC4gdXNlIG1heFZhbHVlIGluc3RlYWQuJywgdGhpcylcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgbWluTGVuZ3RoIGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldE1pbkxlbmd0aCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2lucHV0IHR5cGUgbnVtYmVyIGRvZXMgbm90IHN1cHBvcnQgbWluTGVuZ3RoLiB1c2UgbWluVmFsdWUgaW5zdGVhZC4nLCB0aGlzKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSB0cmlnZ2VyUG9zaXRpb24gY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRUcmlnZ2VyUG9zaXRpb24odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlZm9yZVNldEVudW1WYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICd0cmlnZ2VyUG9zaXRpb24nKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHZhbHVlIGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFZhbHVlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFOZW8uaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICt2YWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc3RlcFNpemVEaWdpdHMgPiAwKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICt2YWx1ZS50b0ZpeGVkKHRoaXMuc3RlcFNpemVEaWdpdHMpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGZpdHNTdGVwU2l6ZSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKHBhcnNlSW50KHZhbHVlLnRvU3RyaW5nKCkucmVwbGFjZSgnLicsICcnKSkgKiAoMSAvIHRoaXMuc3RlcFNpemUpKSAlIDEgPT09IDBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1ZhbGlkKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHttYXhWYWx1ZSwgbWluVmFsdWUsIHZhbHVlfSA9IG1lLFxuICAgICAgICAgICAgaXNOdW1iZXIgICAgICAgICAgICAgICAgICAgID0gTmVvLmlzTnVtYmVyKHZhbHVlKTtcblxuICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKG1heFZhbHVlKSAmJiBpc051bWJlciAmJiB2YWx1ZSA+IG1heFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChOZW8uaXNOdW1iZXIobWluVmFsdWUpICYmIGlzTnVtYmVyICYmIHZhbHVlIDwgbWluVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtZS5maXRzU3RlcFNpemUodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdXBlci5pc1ZhbGlkKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVHJpZ2dlcnMoKTtcbiAgICAgICAgc3VwZXIub25Db25zdHJ1Y3RlZCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLm9sZFBhdGhcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25Gb2N1c0xlYXZlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3ZhbHVlfSA9IG1lO1xuXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFsdWUgPSBtZS5zdGVwU2l6ZURpZ2l0cyA+IDAgPyBwYXJzZUZsb2F0KHZhbHVlKSA6IHBhcnNlSW50KHZhbHVlKTtcbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC5tYXgobWUubWluVmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC5taW4obWUubWF4VmFsdWUsIHZhbHVlKTtcblxuICAgICAgICAgICAgaWYgKG1lLnZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIG1lLnZhbHVlID0gdmFsdWVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWUuZ2V0SW5wdXRFbCgpLnZhbHVlID0gbWUuaW5wdXRWYWx1ZVJlbmRlcmVyKHZhbHVlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3VwZXIub25Gb2N1c0xlYXZlKGRhdGEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uU3BpbkJ1dHRvbkRvd25DbGljaygpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3N0ZXBTaXplfSA9IG1lLFxuICAgICAgICAgICAgb2xkVmFsdWUgICA9IE5lby5pc051bWJlcihtZS52YWx1ZSkgPyBtZS52YWx1ZSA6IG1lLm1pblZhbHVlLFxuICAgICAgICAgICAgdmFsdWUgICAgICA9IChvbGRWYWx1ZSAtIHN0ZXBTaXplKSA8IG1lLm1pblZhbHVlID8gbWUubWF4VmFsdWUgOiAob2xkVmFsdWUgLSBzdGVwU2l6ZSk7XG5cbiAgICAgICAgaWYgKG1lLmV4Y2x1ZGVkVmFsdWVzKSB7XG4gICAgICAgICAgICB3aGlsZSAobWUuZXhjbHVkZWRWYWx1ZXMuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBNYXRoLm1heChtZS5taW5WYWx1ZSwgdmFsdWUgLSBzdGVwU2l6ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIG1lLnZhbHVlID0gdmFsdWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvblNwaW5CdXR0b25VcENsaWNrKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7c3RlcFNpemV9ID0gbWUsXG4gICAgICAgICAgICBvbGRWYWx1ZSAgID0gTmVvLmlzTnVtYmVyKG1lLnZhbHVlKSA/IG1lLnZhbHVlIDogbWUubWF4VmFsdWUsXG4gICAgICAgICAgICB2YWx1ZSAgICAgID0gKG9sZFZhbHVlICsgc3RlcFNpemUpID4gbWUubWF4VmFsdWUgPyBtZS5taW5WYWx1ZSA6IChvbGRWYWx1ZSArIHN0ZXBTaXplKTtcblxuICAgICAgICBpZiAobWUuZXhjbHVkZWRWYWx1ZXMpIHtcbiAgICAgICAgICAgIHdoaWxlIChtZS5leGNsdWRlZFZhbHVlcy5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IE1hdGgubWluKG1lLm1heFZhbHVlLCB2YWx1ZSArIHN0ZXBTaXplKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgbWUudmFsdWUgPSB2YWx1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICB1cGRhdGVUcmlnZ2VycygpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHRyaWdnZXJzID0gbWUudHJpZ2dlcnMgfHwgW107XG5cbiAgICAgICAgaWYgKG1lLnVzZVNwaW5CdXR0b25zKSB7XG4gICAgICAgICAgICBpZiAobWUudHJpZ2dlclBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtZS5oYXNUcmlnZ2VyKCdzcGludXBkb3duJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcnMucHVzaChTcGluVXBEb3duVHJpZ2dlcilcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZS5yZW1vdmVUcmlnZ2VyKCdzcGluZG93bicsIHRydWUsIHRyaWdnZXJzKTtcbiAgICAgICAgICAgICAgICBtZS5yZW1vdmVUcmlnZ2VyKCdzcGludXAnLCB0cnVlLCB0cmlnZ2VycylcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtZS5oYXNUcmlnZ2VyKCdzcGluZG93bicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJzLnB1c2goU3BpbkRvd25UcmlnZ2VyKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghbWUuaGFzVHJpZ2dlcignc3BpbnVwJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcnMucHVzaChTcGluVXBUcmlnZ2VyKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1lLnJlbW92ZVRyaWdnZXIoJ3NwaW51cGRvd24nLCB0cnVlLCB0cmlnZ2VycylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLnJlbW92ZVRyaWdnZXIoJ3NwaW5kb3duJywgdHJ1ZSwgdHJpZ2dlcnMpO1xuICAgICAgICAgICAgbWUucmVtb3ZlVHJpZ2dlcignc3BpbnVwJywgdHJ1ZSwgdHJpZ2dlcnMpO1xuICAgICAgICAgICAgbWUucmVtb3ZlVHJpZ2dlcignc3BpbnVwZG93bicsIHRydWUsIHRyaWdnZXJzKVxuICAgICAgICB9XG5cbiAgICAgICAgbWUudHJpZ2dlcnMgPSB0cmlnZ2Vyc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBmb3IgY2xpZW50LXNpZGUgZmllbGQgZXJyb3JzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaWxlbnQ9dHJ1ZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaW4gY2FzZSB0aGVyZSBhcmUgbm8gY2xpZW50LXNpZGUgZXJyb3JzXG4gICAgICovXG4gICAgdmFsaWRhdGUoc2lsZW50PXRydWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHttYXhWYWx1ZSwgbWluVmFsdWUsIHN0ZXBTaXplLCB2YWx1ZX0gPSBtZSxcbiAgICAgICAgICAgIGlzTnVtYmVyICAgID0gTmVvLmlzTnVtYmVyKHZhbHVlKSxcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gc3VwZXIudmFsaWRhdGUoc2lsZW50KSxcbiAgICAgICAgICAgIGVycm9yUGFyYW0gID0ge21heFZhbHVlLCBtaW5WYWx1ZSwgc3RlcFNpemUsIHZhbHVlfTtcblxuICAgICAgICBpZiAocmV0dXJuVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChOZW8uaXNOdW1iZXIobWF4VmFsdWUpICYmIGlzTnVtYmVyICYmIHZhbHVlID4gbWF4VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBtZS5fZXJyb3IgPSBtZS5lcnJvclRleHRNYXhWYWx1ZShlcnJvclBhcmFtKTtcbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IGZhbHNlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKE5lby5pc051bWJlcihtaW5WYWx1ZSkgJiYgaXNOdW1iZXIgJiYgdmFsdWUgPCBtaW5WYWx1ZSkge1xuICAgICAgICAgICAgICAgIG1lLl9lcnJvciA9IG1lLmVycm9yVGV4dE1pblZhbHVlKGVycm9yUGFyYW0pO1xuICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gZmFsc2VcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIW1lLmZpdHNTdGVwU2l6ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBtZS5fZXJyb3IgPSBtZS5lcnJvclRleHRTdGVwU2l6ZShlcnJvclBhcmFtKTtcbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAhcmV0dXJuVmFsdWUgJiYgIW1lLmNsZWFuICYmIG1lLnVwZGF0ZUVycm9yKG1lLl9lcnJvciwgc2lsZW50KTtcblxuICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWVcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0aGUgZmllbGQgaW50byBhIEpTT04tY29tcGF0aWJsZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLnRvSlNPTigpLFxuICAgICAgICAgICAgbWF4VmFsdWUgICAgICA6IG1lLm1heFZhbHVlLFxuICAgICAgICAgICAgbWluVmFsdWUgICAgICA6IG1lLm1pblZhbHVlLFxuICAgICAgICAgICAgc3RlcFNpemUgICAgICA6IG1lLnN0ZXBTaXplLFxuICAgICAgICAgICAgdXNlU3BpbkJ1dHRvbnM6IG1lLnVzZVNwaW5CdXR0b25zXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKE51bWJlcik7XG4iLCJpbXBvcnQgQmFzZVRyaWdnZXIgIGZyb20gJy4vdHJpZ2dlci9CYXNlLm1qcyc7XG5pbXBvcnQgQ2xlYXJUcmlnZ2VyIGZyb20gJy4vdHJpZ2dlci9DbGVhci5tanMnO1xuaW1wb3J0IEZpZWxkICAgICAgICBmcm9tICcuL0Jhc2UubWpzJztcbmltcG9ydCBOZW9BcnJheSAgICAgZnJvbSAnLi4vLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IFN0cmluZ1V0aWwgICBmcm9tICcuLi8uLi91dGlsL1N0cmluZy5tanMnO1xuaW1wb3J0IFZEb21VdGlsICAgICBmcm9tICcuLi8uLi91dGlsL1ZEb20ubWpzJztcbmltcG9ydCBWTm9kZVV0aWwgICAgZnJvbSAnLi4vLi4vdXRpbC9WTm9kZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZm9ybS5maWVsZC5UZXh0XG4gKiBAZXh0ZW5kcyBOZW8uZm9ybS5maWVsZC5CYXNlXG4gKi9cbmNsYXNzIFRleHQgZXh0ZW5kcyBGaWVsZCB7XG4gICAgLyoqXG4gICAgICogVmFsaWQgdmFsdWVzIGZvciBhdXRvQ2FwaXRhbGl6ZVxuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBhdXRvQ2FwaXRhbGl6ZVZhbHVlcz1bJ2NoYXJhY3RlcnMnLCdub25lJywnb24nLCdvZmYnLCdzZW50ZW5jZXMnLCd3b3JkcyddXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgYXV0b0NhcGl0YWxpemVWYWx1ZXMgPSBbJ2NoYXJhY3RlcnMnLCAnbm9uZScsICdvbicsICdvZmYnLCAnc2VudGVuY2VzJywgJ3dvcmRzJ11cbiAgICAvKipcbiAgICAgKiBWYWxpZCB2YWx1ZXMgZm9yIGxhYmVsUG9zaXRpb25cbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gbGFiZWxQb3NpdGlvbnM9Wydib3R0b20nLCdpbmxpbmUnLCdsZWZ0JywncmlnaHQnLCd0b3AnXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGxhYmVsUG9zaXRpb25zID0gWydib3R0b20nLCAnaW5saW5lJywgJ2xlZnQnLCAncmlnaHQnLCAndG9wJ11cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmZvcm0uZmllbGQuVGV4dCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmZvcm0uZmllbGQuVGV4dCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSd0ZXh0ZmllbGQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAndGV4dGZpZWxkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGVudW1lcmF0ZWQgYXR0cmlidXRlIHRoYXQgY29udHJvbHMgd2hldGhlciBhbmQgaG93IHRleHQgaW5wdXQgaXMgYXV0b21hdGljYWxseSBjYXBpdGFsaXplZCBhcyBpdCBpc1xuICAgICAgICAgKiBlbnRlcmVkL2VkaXRlZCBieSB0aGUgdXNlci5cbiAgICAgICAgICogVmFsaWQgdmFsdWVzOiAnY2hhcmFjdGVycycsICdub25lJywgJ29uJywgJ29mZicsICdzZW50ZW5jZXMnLCAnd29yZHMnXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gYXV0b0NhcGl0YWxpemU9b2ZmJ1xuICAgICAgICAgKi9cbiAgICAgICAgYXV0b0NhcGl0YWxpemVfOiAnb2ZmJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGF1dG9Db21wbGV0ZV89ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBhdXRvQ29tcGxldGVfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLXRleHRmaWVsZCddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby10ZXh0ZmllbGQnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIHZhcmlhYmxlIHRvIHN0b3JlIHRoZSBhY3R1YWwgd2lkdGggZm9yIHRoZSBsYWJlbCBjZW50ZXJCb3JkZXJFbFxuICAgICAgICAgKiAob25seSBuZWVkZWQgZm9yIGxhYmVsUG9zaXRpb246ICdpbmxpbmUnKVxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gY2VudGVyQm9yZGVyRWxXaWR0aD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNlbnRlckJvcmRlckVsV2lkdGg6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIHNob3dzIGEgY2xlYXIgdHJpZ2dlciBpbiBjYXNlIHRoZSBmaWVsZCBoYXMgYSBub24tZW1wdHkgdmFsdWUuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGNsZWFyYWJsZV89dHJ1ZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyYWJsZV86IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIHdpbGwgcmVzZXQgdGhlIGZpZWxkIHRvIGl0cyBpbml0aWFsIHZhbHVlIGNvbmZpZy5cbiAgICAgICAgICogUmVjb21tZW5kZWQgZm9yIGZpZWxkcyB3aXRoIHJlcXVpcmVkOiB0cnVlXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGNsZWFyVG9PcmlnaW5hbFZhbHVlXz1mYWxzZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyVG9PcmlnaW5hbFZhbHVlXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcmV2ZW50IHVzZXJzIGZyb20gdHlwaW5nIHNwZWNpZmljIGNoYXJhY3RlcnMuXG4gICAgICAgICAqIEUuZy4gZGlzYWJsaW5nICstZSBmb3IgTnVtYmVyRmllbGRzXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfG51bGx9IGRpc2FibGVkQ2hhcnNfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBkaXNhYmxlZENoYXJzXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHRpbmcgYGVkaXRhYmxlYCB0byBgZmFsc2VgIG1lYW5zIHRoYXQgdGhlIGlucHV0IGZpZWxkIHdpbGwgYmUgcmVhZC1vbmx5XG4gICAgICAgICAqIGJ1dCB0aGUgZmllbGQgaXMgc3RpbGwgd29ya2FibGUgYW5kIG1heSBoYXZlIGl0cyB2YWx1ZSBjaGFuZ2VkIGJ5IHVzZXIgaW50ZXJhY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBleGFtcGxlIHBpY2tlciBmaWVsZHMgc3VjaCBhcyBgRGF0ZWAgYW5kIGBTZWxlY3RgIG1heSBzdGlsbCBoYXZlIHRoZWlyXG4gICAgICAgICAqIHZhbHVlcyBjaGFuZ2VkIGJ5IHNlbGVjdGluZyBmcm9tIHRoZSBwaWNrZXIgdXNpbmcga2V5Ym9hcmQgb3IgcG9pbnRlci5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZWRpdGFibGVfPXRydWVcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBlZGl0YWJsZV86IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25maWd1cmUgdGhlIHZhbHVlIG9mIGVtcHR5IGZpZWxkcy4gbnVsbCBvciBhbiBlbXB0eSBzdHJpbmcgaXMgcmVjb21tZW5kZWQuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBlbXB0eVZhbHVlPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGVtcHR5VmFsdWU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gZXJyb3JfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBlcnJvcl86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VmdWwgZm9yIGZpZWxkcyBpbnNpZGUgYSBjc3MgZ3JpZCB3aGVyZSBlcnJvcnMgc2hvdWxkIGxpdmUgb3V0c2lkZSB0aGUgbGF5b3V0XG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGVycm9yUG9zaXRpb25BYnNvbHV0ZV89ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBlcnJvclBvc2l0aW9uQWJzb2x1dGVfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRhdGEgcGFzc2VzIGlucHV0UGF0dGVybiwgbWF4TGVuZ3RoLCBtaW5MZW5ndGggJiB2YWx1ZUxlbmd0aCBwcm9wZXJ0aWVzXG4gICAgICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBlcnJvclRleHRJbnB1dFBhdHRlcm49ZGF0YT0+YElucHV0IHBhdHRlcm4gdmlvbGF0aW9uOiAke2RhdGEuaW5wdXRQYXR0ZXJufWBcbiAgICAgICAgICovXG4gICAgICAgIGVycm9yVGV4dElucHV0UGF0dGVybjogZGF0YSA9PiBgSW5wdXQgcGF0dGVybiB2aW9sYXRpb246ICR7ZGF0YS5pbnB1dFBhdHRlcm59YCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRhdGEgcGFzc2VzIGlucHV0UGF0dGVybiwgbWF4TGVuZ3RoLCBtaW5MZW5ndGggJiB2YWx1ZUxlbmd0aCBwcm9wZXJ0aWVzXG4gICAgICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBlcnJvclRleHRNYXhMZW5ndGg9ZGF0YT0+YE1heCBsZW5ndGggdmlvbGF0aW9uOiAke3ZhbHVlTGVuZ3RofSAvICR7bWF4TGVuZ3RofWBcbiAgICAgICAgICovXG4gICAgICAgIGVycm9yVGV4dE1heExlbmd0aDogZGF0YSA9PiBgTWF4IGxlbmd0aCB2aW9sYXRpb246ICR7ZGF0YS52YWx1ZUxlbmd0aH0gLyAke2RhdGEubWF4TGVuZ3RofWAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkYXRhIHBhc3NlcyBpbnB1dFBhdHRlcm4sIG1heExlbmd0aCwgbWluTGVuZ3RoICYgdmFsdWVMZW5ndGggcHJvcGVydGllc1xuICAgICAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gZXJyb3JUZXh0TWluTGVuZ3RoPWRhdGE9PmBNaW4gbGVuZ3RoIHZpb2xhdGlvbjogJHtkYXRhLnZhbHVlTGVuZ3RofSAvICR7ZGF0YS5taW5MZW5ndGh9YFxuICAgICAgICAgKi9cbiAgICAgICAgZXJyb3JUZXh0TWluTGVuZ3RoOiBkYXRhID0+IGBNaW4gbGVuZ3RoIHZpb2xhdGlvbjogJHtkYXRhLnZhbHVlTGVuZ3RofSAvICR7ZGF0YS5taW5MZW5ndGh9YCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gZXJyb3JUZXh0UmVxdWlyZWQ9J1JlcXVpcmVkJ1xuICAgICAgICAgKi9cbiAgICAgICAgZXJyb3JUZXh0UmVxdWlyZWQ6ICdSZXF1aXJlZCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBoaWRlTGFiZWxfPWZhbHNlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgaGlkZUxhYmVsXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtSZWdFeHB8bnVsbH0gaW5wdXRQYXR0ZXJuXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgaW5wdXRQYXR0ZXJuXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGZhbHNlLCB0aGUgaW5wdXRQYXR0ZXJuIHdpbGwgb25seSBnZXQgdmFsaWRhdGVkIHZpYSBKYXZhU2NyaXB0LCBidXQgbm90IGdldHRpbmcgYXBwbGllZCBvbiBET00gbGV2ZWwuXG4gICAgICAgICAqIFRoZSByZWdleCBzdXBwb3J0IGZvciBpbnB1dCBiYXNlZCBwYXR0ZXJucyBpcyBub3QgZnVsbHkgdGhlcmUgeWV0LCBzbyBmZWVsIGZyZWUgdG8gZGlzYWJsZSB0aGlzIGZlYXR1cmVcbiAgICAgICAgICogaWYgbmVlZGVkIChFLmcuIGZvcm0uZmllbGQuUGhvbmUpLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpbnB1dFBhdHRlcm5ET01fPXRydWVcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBpbnB1dFBhdHRlcm5ET01fOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBpbnB1dFR5cGVfPSd0ZXh0J1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGlucHV0VHlwZV86ICd0ZXh0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBpbnB1dFZhbHVlXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgaW5wdXRWYWx1ZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gbGFiZWxCYXNlQ2xzPVsnbmVvLXRleHRmaWVsZC1sYWJlbCddXG4gICAgICAgICAqL1xuICAgICAgICBsYWJlbEJhc2VDbHM6IFsnbmVvLXRleHRmaWVsZC1sYWJlbCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGxhYmVsQ2xzXz1bXVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGxhYmVsQ2xzXzogW10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFZGdlLWNhc2UgY29uZmlnIGluIGNhc2Ugd2Ugd2FudCB0byByZW5kZXIgbGVhZGluZyBjb250ZW50IHdpdGggdGhlaXIgb3duIHNlbGVjdG9ycyBsaWtlOlxuICAgICAgICAgKiA8c3BhbiBjbGFzcz1cIm15LWxhYmVsLWlkLWNsc1wiPkUxMDwvc3Bhbj4g4oCiIEZpcnN0bmFtZVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gbGFiZWxJZF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGxhYmVsSWRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQ1NTIHJ1bGVzIGZvciBsYWJlbElkXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBsYWJlbElkQ2xzXz1bXVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGxhYmVsSWRDbHNfOiBbXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlcGFyYXRvciBiZXR3ZWVuIGxhYmVsSWQgJiBsYWJlbFRleHRcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBsYWJlbElkU2VwYXJhdG9yXz0nIMK3ICdcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBsYWJlbElkU2VwYXJhdG9yXzogJyDCtyAnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBsYWJlbE9wdGlvbmFsVGV4dF89JyAoT3B0aW9uYWwpJ1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGxhYmVsT3B0aW9uYWxUZXh0XzogJyAoT3B0aW9uYWwpJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhbGlkIHZhbHVlczogJ2JvdHRvbScsICdpbmxpbmUnLCAnbGVmdCcsICdyaWdodCcsICd0b3AnXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbGFiZWxQb3NpdGlvbl89J2xlZnQnXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWxQb3NpdGlvbl86ICdsZWZ0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsYWJlbCB0ZXh0IG9yIFZET00uXG4gICAgICAgICAqIFN1cHBvcnRzOlxuICAgICAgICAgKiAtIFN0cmluZzogUmVuZGVycyBhcyBzYWZlIHRleHQgKHRleHRDb250ZW50KS5cbiAgICAgICAgICogLSBPYmplY3Q6IEEgc2luZ2xlIFZET00gb2JqZWN0LlxuICAgICAgICAgKiAtIE9iamVjdFtdOiBBbiBhcnJheSBvZiBWRE9NIG9iamVjdHMuXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxPYmplY3RbXXxTdHJpbmd9IGxhYmVsVGV4dF89J0xhYmVsVGV4dCdcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBsYWJlbFRleHRfOiAnTGFiZWxUZXh0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRlZmF1bHRzIHRvIHB4XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxTdHJpbmd9IGxhYmVsV2lkdGhfPTE1MFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGxhYmVsV2lkdGhfOiAxNTAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWF4aW11bSBhbW91bnQgb2YgY2hhcnMgd2hpY2ggeW91IGNhbiBlbnRlciBpbnRvIHRoaXMgZmllbGRcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IG1heExlbmd0aF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIG1heExlbmd0aF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWluaW11bSBhbW91bnQgb2YgY2hhcnMgd2hpY2ggeW91IGNhbiBlbnRlciBpbnRvIHRoaXMgZmllbGRcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IG1pbkxlbmd0aF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIG1pbkxlbmd0aF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gcGxhY2Vob2xkZXJUZXh0Xz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgcGxhY2Vob2xkZXJUZXh0XzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHRpbmcgYHJlYWRPbmx5YCBtZWFucyB0aGF0IHRoZSBmaWVsZCBtYXkgbm90IGJlIGNoYW5nZWQgYnkgdXNlciBpbnRlcmFjdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGlucHV0IGZpZWxkIHdpbGwgYmUgcmVhZC1vbmx5IGFuZCBvdGhlciB3YXlzIG9mIGNoYW5naW5nIHRoZSBmaWVsZCdzIHZhbHVlXG4gICAgICAgICAqIChzdWNoIGFzIGJ5IG9wZXJhdGluZyBwaWNrZXJzKSB3aWxsIGJlIGRpc2FibGVkLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSByZWFkT25seV89ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICByZWFkT25seV86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gcmVxdWlyZWRfPWZhbHNlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVxdWlyZWRfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNob3dPcHRpb25hbFRleHRfPWZhbHNlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2hvd09wdGlvbmFsVGV4dF86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogbnVsbCA9PiBGb2xsb3cgdGhlIGVsZW1lbnQncyBkZWZhdWx0IGJlaGF2aW9yIGZvciBzcGVsbCBjaGVja2luZ1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufG51bGx9IHNwZWxsQ2hlY2tfPWZhbHNlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgc3BlbGxDaGVja186IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IHN1YkxhYmVsQmFzZUNscz1bJ25lby10ZXh0ZmllbGQtc3VibGFiZWwnXVxuICAgICAgICAgKi9cbiAgICAgICAgc3ViTGFiZWxCYXNlQ2xzOiBbJ25lby10ZXh0ZmllbGQtc3VibGFiZWwnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBzdWJMYWJlbENsc189W11cbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzdWJMYWJlbENsc186IFtdLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBzdWJMYWJlbFRleHRfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzdWJMYWJlbFRleHRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fE9iamVjdFtdfG51bGx9IHRyaWdnZXJzXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdHJpZ2dlcnNfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVXNpbmcgdGhlIGFsZXJ0IHN0YXRlIHdpbGwgZGlzcGxheSBhbiBlbXB0eSBidXQgcmVxdWlyZWQgZmllbGQgaW4gb3JhbmdlIGluc3RlYWQgb2YgcmVkLlxuICAgICAgICAgKiBJbnRlbmRlZCB0byBnZXQgY29tYmluZWQgd2l0aCBmb3JtLkNvbnRhaW5lcjogZ2V0Rm9ybVN0YXRlKCkuXG4gICAgICAgICAqIFNlZSBhcHBzL2Zvcm0gYXMgYW4gZXhhbXBsZS5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gdXNlQWxlcnRTdGF0ZV89ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB1c2VBbGVydFN0YXRlXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHN0cmluZyBiYXNlZCB2YWx1ZSB3aWxsIGdldCByZXNvbHZlZCBpbnRvIHRoZSBjbG9zZXN0IGNvbnRyb2xsZXIgd2hpY2ggaW1wbGVtZW50cyBpdFxuICAgICAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbnxTdHJpbmd8bnVsbH0gdmFsaWRhdG9yPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHZhbGlkYXRvcjogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCB2YWx1ZSBjYW4gYmUgeHNzUHJvdGVjdGVkIGFuZCB2YWx1ZXMgYXJlIGVzY2FwZWRcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0geHNzUHJvdGVjdGVkXz1mYWxzZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHhzc1Byb3RlY3RlZF86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbVxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gX3Zkb21cbiAgICAgICAgICovXG4gICAgICAgIF92ZG9tOlxuICAgICAgICB7Y246IFtcbiAgICAgICAgICAgIHt0YWc6ICdsYWJlbCcsIGNsczogW10sIHN0eWxlOiB7fX0sXG4gICAgICAgICAgICB7dGFnOiAnbGFiZWwnLCBjbHM6IFtdfSxcbiAgICAgICAgICAgIHt0YWc6ICdpbnB1dCcsIGNsczogWyduZW8tdGV4dGZpZWxkLWlucHV0J10sIGZsYWc6ICduZW8tcmVhbC1pbnB1dCcsIHN0eWxlOiB7fX0sXG4gICAgICAgICAgICB7Y2xzOiBbJ25lby10ZXh0ZmllbGQtZXJyb3Itd3JhcHBlciddLCByZW1vdmVEb206IHRydWUsIGNuOiBbXG4gICAgICAgICAgICAgICAge2NsczogWyduZW8tdGV4dGZpZWxkLWVycm9yJ119XG4gICAgICAgICAgICBdfVxuICAgICAgICBdfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGlzIHZhbHVlIHRvIGZhbHNlLCBpbiBjYXNlIGEgZmllbGQgc2hvdWxkIGRpc3BsYXkgZXJyb3JzIHVwIGZyb250LlxuICAgICAqIE90aGVyd2lzZSwgZXJyb3JzIHdpbGwgc3RheSBoaWRkZW4gb24gbW91bnRpbmcsIHVubGVzcyB5b3UgdHJpZ2dlciB2YWxpZGF0ZShmYWxzZSkuXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gY2xlYW49dHJ1ZVxuICAgICAqL1xuICAgIGNsZWFuID0gdHJ1ZVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5hZGREb21MaXN0ZW5lcnMoW1xuICAgICAgICAgICAge2lucHV0ICAgICA6IG1lLm9uSW5wdXRWYWx1ZUNoYW5nZSwgc2NvcGU6IG1lfSxcbiAgICAgICAgICAgIHttb3VzZWVudGVyOiBtZS5vbk1vdXNlRW50ZXIsICAgICAgIHNjb3BlOiBtZX0sXG4gICAgICAgICAgICB7bW91c2VsZWF2ZTogbWUub25Nb3VzZUxlYXZlLCAgICAgICBzY29wZTogbWV9XG4gICAgICAgIF0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBhcHBOYW1lIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0QXBwTmFtZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRBcHBOYW1lKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgdmFsdWUgJiYgdGhpcy50cmlnZ2Vycz8uZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGl0ZW0uYXBwTmFtZSA9IHZhbHVlXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBhdXRvQ2FwaXRhbGl6ZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRBdXRvQ2FwaXRhbGl6ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VJbnB1dEVsS2V5KCdhdXRvY2FwaXRhbGl6ZScsIHZhbHVlID09PSAnb2ZmJyB8fCB2YWx1ZSA9PT0gJ25vbmUnID8gbnVsbCA6IHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgYXV0b0NvbXBsZXRlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIENocm9tZSBpZ25vcmVzIGEgdmFsdWUgb2YgXCJvZmZcIiwgc28gd2Ugc3RpY2sgdG8gYSBkaWZmZXJlbnQgdmFsdWUgaW5zdGVhZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0QXV0b0NvbXBsZXRlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICAvLyB3aGlsZSBcIm9mZlwiIGlzIHRoZSBjb3JyZWN0IHZhbHVlLCBicm93c2VyIHZlbmRvcnMgaWdub3JlIGl0LiBBcmJpdHJhcnkgc3RyaW5ncyBkbyB0aGUgdHJpY2suXG4gICAgICAgIHRoaXMuY2hhbmdlSW5wdXRFbEtleSgnYXV0b2NvbXBsZXRlJywgdmFsdWUgPyBudWxsIDogJ25vJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGNsZWFyYWJsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldENsZWFyYWJsZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIHRyaWdnZXJzO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdHJpZ2dlcnMgPSBtZS50cmlnZ2VycyB8fCBbXTtcbiAgICAgICAgICAgIHRyaWdnZXJzLnVuc2hpZnQoQ2xlYXJUcmlnZ2VyKTtcbiAgICAgICAgICAgIG1lLnRyaWdnZXJzID0gdHJpZ2dlcnNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLnJlbW92ZVRyaWdnZXIoJ2NsZWFyJylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgY2xlYXJUb09yaWdpbmFsVmFsdWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRDbGVhclRvT3JpZ2luYWxWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5maXJlKCdjaGFuZ2VDbGVhclRvT3JpZ2luYWxWYWx1ZScsIHtcbiAgICAgICAgICAgIG9sZFZhbHVlLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGRpc2FibGVkQ2hhcnMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXXxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nW118bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXREaXNhYmxlZENoYXJzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIE5lby5tYWluLkRvbUV2ZW50cy5yZWdpc3RlckRpc2FibGVkSW5wdXRDaGFycyh7XG4gICAgICAgICAgICAgICAgY2hhcnMgICA6IHZhbHVlLFxuICAgICAgICAgICAgICAgIGlkICAgICAgOiBtZS5nZXRJbnB1dEVsKCkuaWQsXG4gICAgICAgICAgICAgICAgd2luZG93SWQ6IG1lLndpbmRvd0lkXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBlZGl0YWJsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEVkaXRhYmxlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2xzfSA9IG1lO1xuXG4gICAgICAgIE5lb0FycmF5LnRvZ2dsZShjbHMsICduZW8tbm90LWVkaXRhYmxlJywgIXZhbHVlKTtcbiAgICAgICAgbWUuY2xzID0gY2xzO1xuXG4gICAgICAgIG1lLnVwZGF0ZVJlYWRPbmx5U3RhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZXJyb3IgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEVycm9yKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZUVycm9yKHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZXJyb3JQb3NpdGlvbkFic29sdXRlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RXJyb3JQb3NpdGlvbkFic29sdXRlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgID0gdGhpcyxcbiAgICAgICAgICAgIGNscyA9IFZEb21VdGlsLmZpbmQobWUudmRvbSwge2NsczogJ25lby10ZXh0ZmllbGQtZXJyb3InfSkudmRvbS5jbHM7XG5cbiAgICAgICAgTmVvQXJyYXlbdmFsdWUgPyAnYWRkJyA6ICdyZW1vdmUnXShjbHMsICduZW8tYWJzb2x1dGUnKTtcblxuICAgICAgICBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaGlkZUxhYmVsIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SGlkZUxhYmVsKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICBub2RlID0gbWUubGFiZWxQb3NpdGlvbiA9PT0gJ2lubGluZScgPyBtZS5nZXRDZW50ZXJCb3JkZXJFbCgpIDogbWUudmRvbS5jblswXTtcblxuICAgICAgICBub2RlLnJlbW92ZURvbSA9IHZhbHVlO1xuICAgICAgICBtZS51cGRhdGVJbnB1dFdpZHRoKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZW5zdXJlU3RhYmxlSWRzKCkge1xuICAgICAgICBzdXBlci5lbnN1cmVTdGFibGVJZHMoKTtcblxuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGlucHV0RWwgICA9IG1lLmdldElucHV0RWwoKSxcbiAgICAgICAgICAgIGlucHV0RWxJZCA9IG1lLmdldElucHV0RWxJZCgpLFxuICAgICAgICAgICAgbGFiZWxFbCAgID0gbWUuZ2V0TGFiZWxFbCgpO1xuXG4gICAgICAgIGlucHV0RWwuaWQgID0gaW5wdXRFbElkO1xuICAgICAgICBsYWJlbEVsLmlkICA9IG1lLmdldExhYmVsSWQoKTtcbiAgICAgICAgbGFiZWxFbC5mb3IgPSBpbnB1dEVsSWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGlucHV0UGF0dGVybiBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7UmVnRXhwfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SW5wdXRQYXR0ZXJuKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5pbnB1dFBhdHRlcm5ET00pIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygxLCB2YWx1ZS5sZW5ndGggLSAxKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNoYW5nZUlucHV0RWxLZXkoJ3BhdHRlcm4nLCB2YWx1ZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaW5wdXRUeXBlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldElucHV0VHlwZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VJbnB1dEVsS2V5KCd0eXBlJywgdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBpbnB1dFZhbHVlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRJbnB1dFZhbHVlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAge2Nsc30gPSBtZTtcblxuICAgICAgICBtZS5nZXRJbnB1dEVsKCkudmFsdWUgPSBtZS5jb250YWluc0ZvY3VzID8gdmFsdWUgOiBtZS5pbnB1dFZhbHVlUmVuZGVyZXIodmFsdWUpO1xuXG4gICAgICAgIG1lLnVzZUFsZXJ0U3RhdGUgJiYgTmVvQXJyYXkudG9nZ2xlKGNscywgJ25lby1lbXB0eS1yZXF1aXJlZCcsIG1lLmlzRW1wdHkoKSAmJiBtZS5yZXF1aXJlZCk7XG5cbiAgICAgICAgTmVvQXJyYXkudG9nZ2xlKGNscywgJ25lby1oYXMtY29udGVudCcsIG1lLmhhc0NvbnRlbnQoKSk7XG4gICAgICAgIG1lLmNscyA9IGNscztcblxuICAgICAgICBtZS51cGRhdGVWYWx1ZUZyb21JbnB1dFZhbHVlKHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbGFiZWxDbHMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldExhYmVsQ2xzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgID0gdGhpcyxcbiAgICAgICAgICAgIGNscyA9IG1lLmdldExhYmVsRWwoKS5jbHM7XG5cbiAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgb2xkVmFsdWUpO1xuICAgICAgICBOZW9BcnJheS5hZGQoY2xzLCB2YWx1ZSk7XG5cbiAgICAgICAgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGxhYmVsT3B0aW9uYWxUZXh0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldExhYmVsT3B0aW9uYWxUZXh0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmxhYmVsVGV4dCA9IHRoaXMubGFiZWxUZXh0IC8vIHRyaWdnZXJzIGEgdmRvbSB1cGRhdGVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGxhYmVsUG9zaXRpb24gY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TGFiZWxQb3NpdGlvbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjbHMsIHZkb219ID0gbWUsXG4gICAgICAgICAgICBjZW50ZXJCb3JkZXJFbENscywgaXNFbXB0eTtcblxuICAgICAgICB2ZG9tLmNuWzFdLnJlbW92ZURvbSA9IHZhbHVlICE9PSAndG9wJyA/IHRydWUgOiAhQm9vbGVhbihtZS5zdWJMYWJlbFRleHQpO1xuXG4gICAgICAgIE5lb0FycmF5LnJlbW92ZShjbHMsICdsYWJlbC0nICsgb2xkVmFsdWUpO1xuICAgICAgICBOZW9BcnJheS5hZGQoY2xzLCAnbGFiZWwtJyArIHZhbHVlKTtcbiAgICAgICAgbWUuY2xzID0gY2xzOyAvLyB0b2RvOiBzaWxlbnQgdXBkYXRlIGlmIG5lZWRlZFxuXG4gICAgICAgIGlmIChvbGRWYWx1ZSA9PT0gJ2lubGluZScpIHtcbiAgICAgICAgICAgIHZkb20uY25bMF0gPSBtZS5nZXRMYWJlbEVsKCk7IC8vIHJlbW92ZSB0aGUgd3JhcHBlclxuXG4gICAgICAgICAgICB2ZG9tLmNuWzBdLnJlbW92ZURvbSA9IG1lLmhpZGVMYWJlbDtcbiAgICAgICAgICAgIHZkb20uY25bMF0ud2lkdGggICAgID0gbWUubGFiZWxXaWR0aDtcbiAgICAgICAgICAgIG1lLnVwZGF0ZUlucHV0V2lkdGgoKVxuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnaW5saW5lJykge1xuICAgICAgICAgICAgY2VudGVyQm9yZGVyRWxDbHMgPSBbJ25lby1jZW50ZXItYm9yZGVyJ107XG4gICAgICAgICAgICBpc0VtcHR5ICAgICAgICAgICA9IG1lLmlzRW1wdHkoKTtcbiAgICAgICAgICAgIHZkb20gICAgICAgICAgICAgID0gbWUudmRvbTtcblxuICAgICAgICAgICAgIWlzRW1wdHkgJiYgY2VudGVyQm9yZGVyRWxDbHMucHVzaCgnbmVvLWZsb2F0LWFib3ZlJyk7XG5cbiAgICAgICAgICAgIGRlbGV0ZSB2ZG9tLmNuWzBdLndpZHRoO1xuXG4gICAgICAgICAgICB2ZG9tLmNuWzBdID0ge1xuICAgICAgICAgICAgICAgIGNsczogWyduZW8tbGFiZWwtd3JhcHBlciddLFxuICAgICAgICAgICAgICAgIGNuIDogW3tcbiAgICAgICAgICAgICAgICAgICAgY2xzOiBbJ25lby1sZWZ0LWJvcmRlciddXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBjbHMgICAgICA6IGNlbnRlckJvcmRlckVsQ2xzLFxuICAgICAgICAgICAgICAgICAgICBjbiAgICAgICA6IFt2ZG9tLmNuWzBdXSxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRG9tOiBtZS5oaWRlTGFiZWxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIGNsczogWyduZW8tcmlnaHQtYm9yZGVyJ11cbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgbWUudXBkYXRlSW5wdXRXaWR0aCgpO1xuXG4gICAgICAgICAgICAhaXNFbXB0eSAmJiBtZS50aW1lb3V0KDIwKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBtZS51cGRhdGVDZW50ZXJCb3JkZXJFbFdpZHRoKGZhbHNlKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNoYW5nZXMgZnJvbSBlLmcuIGxlZnQgdG8gdG9wXG4gICAgICAgICAgICBtZS51cGRhdGVJbnB1dFdpZHRoKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbGFiZWxUZXh0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fE9iamVjdFtdfFN0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxPYmplY3RbXXxTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TGFiZWxUZXh0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpc0VtcHR5ID0gbWUuaXNFbXB0eSgpLFxuICAgICAgICAgICAgbGFiZWxFbCA9IG1lLmdldExhYmVsRWwoKTtcblxuICAgICAgICBpZiAobWUubGFiZWxJZCkge1xuICAgICAgICAgICAgdmFsdWUgPSBbe1xuICAgICAgICAgICAgICAgIHRhZyA6ICdzcGFuJyxcbiAgICAgICAgICAgICAgICBjbHMgOiBtZS5sYWJlbElkQ2xzLFxuICAgICAgICAgICAgICAgIHRleHQ6IG1lLmxhYmVsSWRcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB0YWcgOiAnc3BhbicsXG4gICAgICAgICAgICAgICAgdGV4dDogbWUubGFiZWxJZFNlcGFyYXRvclxuICAgICAgICAgICAgfSwgLi4uKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiAoTmVvLmlzU3RyaW5nKHZhbHVlKSA/IFt7dGV4dDogdmFsdWV9XSA6IFt2YWx1ZV0pKV07XG5cbiAgICAgICAgICAgIGxhYmVsRWwuY24gPSB2YWx1ZTtcbiAgICAgICAgICAgIGRlbGV0ZSBsYWJlbEVsLnRleHRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChOZW8uaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgbGFiZWxFbC50ZXh0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGxhYmVsRWwuY25cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGFiZWxFbC5jbiA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBsYWJlbEVsLnRleHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbWUuaGlkZUxhYmVsKSB7XG4gICAgICAgICAgICBpZiAobWUubGFiZWxQb3NpdGlvbiA9PT0gJ2lubGluZScpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG1lLmdldENlbnRlckJvcmRlckVsKCk/LndpZHRoXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWUucHJvbWlzZVVwZGF0ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBtZS51cGRhdGVDZW50ZXJCb3JkZXJFbFdpZHRoKGlzRW1wdHkpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWUudXBkYXRlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbGFiZWxXaWR0aCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldExhYmVsV2lkdGgodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmxhYmVsUG9zaXRpb24gIT09ICdpbmxpbmUnKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGxhYmVsID0gbWUudmRvbS5jblswXTtcblxuICAgICAgICAgICAgbGFiZWwud2lkdGggPSB2YWx1ZTtcbiAgICAgICAgICAgICFtZS5oaWRlTGFiZWwgJiYgbWUudXBkYXRlSW5wdXRXaWR0aCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1heExlbmd0aCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TWF4TGVuZ3RoKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnZhbGlkYXRlKCk7IC8vIHNpbGVudFxuICAgICAgICB0aGlzLmNoYW5nZUlucHV0RWxLZXkoJ21heGxlbmd0aCcsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbWluTGVuZ3RoIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNaW5MZW5ndGgodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGUoKTsgLy8gc2lsZW50XG4gICAgICAgIHRoaXMuY2hhbmdlSW5wdXRFbEtleSgnbWlubGVuZ3RoJywgdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtb3VudGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IHRyaWdnZXJzID0gbWUudHJpZ2dlcnMgfHwgW10sXG4gICAgICAgICAgICAgICAgaSAgICAgICAgPSAwLFxuICAgICAgICAgICAgICAgIGxlbiAgICAgID0gdHJpZ2dlcnMubGVuZ3RoO1xuXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0cmlnZ2Vyc1tpXS52ZG9tLnJlbW92ZURvbSkge1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2Vyc1tpXS5tb3VudGVkID0gdmFsdWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtZS5sYWJlbFBvc2l0aW9uID09PSAnaW5saW5lJykge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBtZS51cGRhdGVDZW50ZXJCb3JkZXJFbFdpZHRoKClcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbWUuZ2V0Q2VudGVyQm9yZGVyRWwoKS53aWR0aFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcGxhY2Vob2xkZXJUZXh0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRQbGFjZWhvbGRlclRleHQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2xzfSA9IG1lO1xuXG4gICAgICAgIG1lLmNoYW5nZUlucHV0RWxLZXkoJ3BsYWNlaG9sZGVyJywgdmFsdWUgPT09ICcnID8gbnVsbCA6IHZhbHVlKTtcblxuICAgICAgICAvLyBhIG5vbi1lbXB0eSBwbGFjZWhvbGRlciBuZWVkcyB0byBrZWVwIHRoZSAnbmVvLWhhcy1jb250ZW50JyBydWxlXG4gICAgICAgIC8vID0+IGxhYmVsUG9zaXRpb246ICdpbmxpbmUnIHNob3VsZCBrZWVwIHRoZSBsYWJlbCBhdCB0aGUgdG9wXG4gICAgICAgIGlmIChOZW8uaXNFbXB0eSh2YWx1ZSkgIT09IE5lby5pc0VtcHR5KG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgTmVvQXJyYXlbdmFsdWUgIT09IG51bGwgJiYgdmFsdWUudG9TdHJpbmcoKS5sZW5ndGggPiAwID8gJ2FkZCcgOiAncmVtb3ZlJ10oY2xzLCAnbmVvLWhhcy1jb250ZW50Jyk7XG4gICAgICAgICAgICBtZS5jbHMgPSBjbHNcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcmVhZE9ubHkgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRSZWFkT25seSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjbHN9ID0gbWU7XG5cbiAgICAgICAgTmVvQXJyYXlbdmFsdWUgPyAnYWRkJyA6ICdyZW1vdmUnXShjbHMsICduZW8tcmVhZG9ubHknKTtcbiAgICAgICAgbWUuY2xzID0gY2xzO1xuXG4gICAgICAgIG1lLnVwZGF0ZVJlYWRPbmx5U3RhdGUoKTtcblxuICAgICAgICBtZS50cmlnZ2Vycz8uZm9yRWFjaCh0cmlnZ2VyID0+IHtcbiAgICAgICAgICAgIHRyaWdnZXIuaGlkZGVuID0gdmFsdWUgPyB0cnVlIDogdHJpZ2dlci5nZXRIaWRkZW5TdGF0ZT8uKCkgfHwgZmFsc2VcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHJlcXVpcmVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0UmVxdWlyZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuc2lsZW50VmRvbVVwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgb2xkVmFsdWUgIT09IHVuZGVmaW5lZCAmJiBtZS52YWxpZGF0ZShtZS5jbGVhbik7XG4gICAgICAgIG1lLmNoYW5nZUlucHV0RWxLZXkoJ3JlcXVpcmVkJywgdmFsdWUgPyB2YWx1ZSA6IG51bGwpO1xuICAgICAgICBtZS5sYWJlbFRleHQgPSBtZS5sYWJlbFRleHQ7IC8vIGFwcGx5IHRoZSBvcHRpb25hbCB0ZXh0IGlmIG5lZWRlZFxuXG4gICAgICAgIG1lLnNpbGVudFZkb21VcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc2hvd09wdGlvbmFsVGV4dCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNob3dPcHRpb25hbFRleHQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMubGFiZWxUZXh0ID0gdGhpcy5sYWJlbFRleHQgLy8gdHJpZ2dlcnMgYSB2ZG9tIHVwZGF0ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc3BlbGxDaGVjayBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW58bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW58bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTcGVsbENoZWNrKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmNoYW5nZUlucHV0RWxLZXkoJ3NwZWxsY2hlY2snLCBOZW8uaXNCb29sZWFuKHZhbHVlKSA/IHZhbHVlIDogbnVsbClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHN1YkxhYmVsQ2xzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTdWJMYWJlbENscyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjbHN9ID0gbWUudmRvbS5jblsxXTtcblxuICAgICAgICBOZW9BcnJheS5yZW1vdmUoY2xzLCBvbGRWYWx1ZSk7XG4gICAgICAgIE5lb0FycmF5LmFkZChjbHMsIHZhbHVlKTtcblxuICAgICAgICBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc3ViTGFiZWxUZXh0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTdWJMYWJlbFRleHQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgc2hvd0xhYmVsID0gbWUubGFiZWxQb3NpdGlvbiA9PT0gJ3RvcCcsXG4gICAgICAgICAgICBzdWJMYWJlbCAgPSBtZS52ZG9tLmNuWzFdO1xuXG4gICAgICAgIHN1YkxhYmVsLnJlbW92ZURvbSA9ICFzaG93TGFiZWw7XG4gICAgICAgIHN1YkxhYmVsLnRleHQgICAgICA9IHZhbHVlO1xuXG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB0cmlnZ2VycyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VHJpZ2dlcnModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3Zkb219ICAgICAgID0gbWUsXG4gICAgICAgICAgICBpbnB1dEVsICAgICAgPSB2ZG9tLmNuWzJdLCAvLyBpbnB1dEVsIG9yIGlucHV0V3JhcHBlckVsXG4gICAgICAgICAgICBwcmVUcmlnZ2VycyAgPSBbXSxcbiAgICAgICAgICAgIHBvc3RUcmlnZ2VycyA9IFtdLFxuICAgICAgICAgICAgd2lkdGg7XG5cbiAgICAgICAgb2xkVmFsdWU/LmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpZiAoIW1lLmdldFRyaWdnZXIoaXRlbS50eXBlKSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uZGVzdHJveSgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZVRyaWdnZXJzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zdFRyaWdnZXJzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHBvc3RUcmlnZ2Vycy5zb3J0KChhLCBiKSA9PiBiLndlaWdodCAtIGEud2VpZ2h0KTsgLy8gREVTQ1xuICAgICAgICAgICAgcHJlVHJpZ2dlcnMuc29ydCggKGEsIGIpID0+IGEud2VpZ2h0IC0gYi53ZWlnaHQpOyAvLyBBU0NcblxuICAgICAgICAgICAgcG9zdFRyaWdnZXJzID0gcG9zdFRyaWdnZXJzLm1hcCh0cmlnZ2VyID0+IHRyaWdnZXIuY3JlYXRlVmRvbVJlZmVyZW5jZSgpKTtcbiAgICAgICAgICAgIHByZVRyaWdnZXJzICA9IHByZVRyaWdnZXJzLm1hcCggdHJpZ2dlciA9PiB0cmlnZ2VyLmNyZWF0ZVZkb21SZWZlcmVuY2UoKSk7XG5cbiAgICAgICAgICAgIGlmIChpbnB1dEVsLnRhZyA9PT0gJ2lucHV0Jykge1xuICAgICAgICAgICAgICAgIC8vIHdyYXAgdGhlIGlucHV0IHRhZ1xuICAgICAgICAgICAgICAgIHZkb20uY25bMl0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGNscyAgOiBbJ25lby1pbnB1dC13cmFwcGVyJ10sXG4gICAgICAgICAgICAgICAgICAgIGNuICAgOiBbLi4ucHJlVHJpZ2dlcnMsIGlucHV0RWwsIC4uLnBvc3RUcmlnZ2Vyc10sXG4gICAgICAgICAgICAgICAgICAgIGlkICAgOiBtZS5nZXRJbnB1dFdyYXBwZXJJZCgpLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogaW5wdXRFbC53aWR0aFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBkZWxldGUgaW5wdXRFbC53aWR0aFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnB1dEVsLmNuID0gWy4uLnByZVRyaWdnZXJzLCBtZS5nZXRJbnB1dEVsKCksIC4uLnBvc3RUcmlnZ2Vyc11cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpbnB1dEVsLnRhZyAhPT0gJ2lucHV0Jykge1xuICAgICAgICAgICAgICAgIC8vIHJlcGxhY2luZyB0aGUgaW5wdXQgd3JhcHBlciBkaXYgd2l0aCB0aGUgaW5wdXQgdGFnXG4gICAgICAgICAgICAgICAgd2lkdGggICAgICAgICAgICA9IGlucHV0RWwud2lkdGg7XG4gICAgICAgICAgICAgICAgdmRvbS5jblsyXSAgICAgICA9IG1lLmdldElucHV0RWwoKTtcbiAgICAgICAgICAgICAgICB2ZG9tLmNuWzJdLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtZS5wcm9taXNlVXBkYXRlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBtZS51cGRhdGVUcmlnZ2VyVm5vZGVzKClcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHZhbHVlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFZhbHVlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgY2xzO1xuXG4gICAgICAgIG1lLnNpbGVudFZkb21VcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgIG1lLnVwZGF0ZUlucHV0VmFsdWVGcm9tVmFsdWUodmFsdWUpO1xuXG4gICAgICAgIG1lLnZhbGlkYXRlKCk7IC8vIHNpbGVudFxuXG4gICAgICAgIGNscyA9IG1lLmNscztcbiAgICAgICAgTmVvQXJyYXkudG9nZ2xlKGNscywgJ25lby1pcy1kaXJ0eScsIG1lLmlzRGlydHkpO1xuICAgICAgICBtZS5jbHMgPSBjbHM7XG5cbiAgICAgICAgbWUuc2lsZW50VmRvbVVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgICAgIG1lLnVwZGF0ZSgpO1xuXG4gICAgICAgIHN1cGVyLmFmdGVyU2V0VmFsdWUodmFsdWUsIG9sZFZhbHVlKSAvLyBmaXJlcyB0aGUgY2hhbmdlIGV2ZW50XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB3aWR0aCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFdpZHRoKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldFdpZHRoKHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIHRoaXMudXBkYXRlSW5wdXRXaWR0aCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB3aW5kb3dJZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFdpbmRvd0lkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldFdpbmRvd0lkKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgdmFsdWUgJiYgdGhpcy50cmlnZ2Vycz8uZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGl0ZW0ud2luZG93SWQgPSB2YWx1ZVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHNoYWxsb3cgY29weSBvZiB0aGUgdHJpZ2dlcnMgY29uZmlnXG4gICAgICogQHBhcmFtIHtBcnJheXxudWxsfSB2YWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVHZXRUcmlnZ2Vycyh2YWx1ZSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbLi4udmFsdWVdXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBhdXRvQ2FwaXRhbGl6ZSBjb25maWcgZ2V0cyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgYmVmb3JlU2V0QXV0b0NhcGl0YWxpemUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlZm9yZVNldEVudW1WYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICdhdXRvQ2FwaXRhbGl6ZScsICdhdXRvQ2FwaXRhbGl6ZVZhbHVlcycpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgbGFiZWxDbHMgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldExhYmVsQ2xzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gTmVvQXJyYXkudW5pb24odmFsdWUgfHwgW10sIHRoaXMubGFiZWxCYXNlQ2xzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGxhYmVsUG9zaXRpb24gY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGJlZm9yZVNldExhYmVsUG9zaXRpb24odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlZm9yZVNldEVudW1WYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICdsYWJlbFBvc2l0aW9uJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBsYWJlbFRleHQgY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBiZWZvcmVTZXRMYWJlbFRleHQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBsYWJlbE9wdGlvbmFsVGV4dCA9IG1lLmxhYmVsT3B0aW9uYWxUZXh0LFxuICAgICAgICAgICAgaGFzT3B0aW9uYWxUZXh0ICAgPSB2YWx1ZS5lbmRzV2l0aChsYWJlbE9wdGlvbmFsVGV4dCk7XG5cbiAgICAgICAgaWYgKG1lLnNob3dPcHRpb25hbFRleHQgJiYgIW1lLnJlcXVpcmVkKSB7XG4gICAgICAgICAgICBpZiAoIWhhc09wdGlvbmFsVGV4dCkge1xuICAgICAgICAgICAgICAgIHZhbHVlICs9IGxhYmVsT3B0aW9uYWxUZXh0XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgJiYgaGFzT3B0aW9uYWxUZXh0KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UobGFiZWxPcHRpb25hbFRleHQsICcnKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgc3ViTGFiZWxDbHMgY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nW119XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFN1YkxhYmVsQ2xzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gTmVvQXJyYXkudW5pb24odmFsdWUgfHwgW10sIHRoaXMuc3ViTGFiZWxCYXNlQ2xzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHRyaWdnZXJzIGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdHxPYmplY3RbXX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3RbXX0gdGhlIHBhcnNlZCB0cmlnZ2VycyBjb25maWdcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybnMge09iamVjdHxPYmplY3RbXX1cbiAgICAgKi9cbiAgICBiZWZvcmVTZXRUcmlnZ2Vycyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBbXTtcbiAgICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gW3ZhbHVlXVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2FwcE5hbWUsIHdpbmRvd0lkfSA9IG1lO1xuXG4gICAgICAgIHZhbHVlLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoaXRlbS5pc0NsYXNzKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVbaW5kZXhdID0gTmVvLmNyZWF0ZShpdGVtLCB7XG4gICAgICAgICAgICAgICAgICAgIGFwcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGlkICAgOiBtZS5nZXRUcmlnZ2VySWQoaXRlbS5wcm90b3R5cGUudHlwZSksXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBtZSxcbiAgICAgICAgICAgICAgICAgICAgd2luZG93SWRcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSBlbHNlIGlmICghKGl0ZW0gaW5zdGFuY2VvZiBCYXNlVHJpZ2dlcikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0ubW9kdWxlICYmICFpdGVtLm50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0ubnR5cGUgPSAndHJpZ2dlcidcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5tb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5jbGFzc05hbWUgPSBpdGVtLm1vZHVsZS5wcm90b3R5cGUuY2xhc3NOYW1lO1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmlkICAgICAgICA9IG1lLmdldFRyaWdnZXJJZChpdGVtLm1vZHVsZS5wcm90b3R5cGUudHlwZSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YWx1ZVtpbmRleF0gPSBOZW9baXRlbS5jbGFzc05hbWUgPyAnY3JlYXRlJyA6ICdudHlwZSddKHtcbiAgICAgICAgICAgICAgICAgICAgLi4uaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgYXBwTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IG1lLFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3dJZFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHZhbHVlIGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge1N0cmluZ3xudWxsfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1wdHlWYWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBmaWVsZCB0byBpdHMgb3JpZ2luYWwgdmFsdWUgb3IgbnVsbCBkZXBlbmRpbmcgb24gdGhlIGNsZWFyVG9PcmlnaW5hbFZhbHVlIGNvbmZpZ1xuICAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnZhbHVlID0gbWUuY2xlYXJUb09yaWdpbmFsVmFsdWUgPyBtZS5vcmlnaW5hbENvbmZpZy52YWx1ZSA6IG51bGw7XG4gICAgICAgIG1lLmZpcmUoJ2NsZWFyJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICovXG4gICAgZGVzdHJveSguLi5hcmdzKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmRpc2FibGVkQ2hhcnMpIHtcbiAgICAgICAgICAgIE5lby5tYWluLkRvbUV2ZW50cy51bnJlZ2lzdGVyRGlzYWJsZWRJbnB1dENoYXJzKHtcbiAgICAgICAgICAgICAgICBpZCAgICAgIDogbWUuZ2V0SW5wdXRFbCgpLmlkLFxuICAgICAgICAgICAgICAgIHdpbmRvd0lkOiBtZS53aW5kb3dJZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnRyaWdnZXJzPy5mb3JFYWNoKHRyaWdnZXIgPT4ge1xuICAgICAgICAgICAgdHJpZ2dlci5kZXN0cm95KClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc3VwZXIuZGVzdHJveSguLi5hcmdzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxzIGZvY3VzKCkgb24gdGhlIGlucHV0RWwgbm9kZSBpbnN0ZWFkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgZm9jdXMoaWQpIHtcbiAgICAgICAgc3VwZXIuZm9jdXModGhpcy5nZXRJbnB1dEVsSWQoKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgZ2V0Q2VudGVyQm9yZGVyRWwoKSB7XG4gICAgICAgIHJldHVybiBWRG9tVXRpbC5maW5kKHRoaXMudmRvbSwge2NsczogJ25lby1jZW50ZXItYm9yZGVyJ30pPy52ZG9tIHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgZ2V0SW5wdXRFbCgpIHtcbiAgICAgICAgcmV0dXJuIFZEb21VdGlsLmZpbmQodGhpcy52ZG9tLCB7ZmxhZzogJ25lby1yZWFsLWlucHV0J30pPy52ZG9tIHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldElucHV0RWxJZCgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWR9X19pbnB1dGBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBuZXcgaW5wdXRXaWR0aCBiYXNlZCBvbiB0aGUgbGFiZWxXaWR0aCAmIHRvdGFsIHdpZHRoXG4gICAgICogQHJldHVybnMge051bWJlcnxudWxsfSBudWxsIGluIGNhc2UgdGhpcy53aWR0aCBpcyB1bmtub3duXG4gICAgICovXG4gICAgZ2V0SW5wdXRXaWR0aCgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGlnbm9yZUxhYmVsID0gbWUuaGlkZUxhYmVsIHx8IG1lLmxhYmVsUG9zaXRpb24gPT09ICdib3R0b20nIHx8IG1lLmxhYmVsUG9zaXRpb24gPT09ICdpbmxpbmUnIHx8IG1lLmxhYmVsUG9zaXRpb24gPT09ICd0b3AnLFxuICAgICAgICAgICAgbGFiZWxXaWR0aCAgPSBpZ25vcmVMYWJlbCA/IDAgOiBtZS5sYWJlbFdpZHRoLFxuICAgICAgICAgICAge3dpZHRofSAgICAgPSBtZTtcblxuICAgICAgICBpZiAobGFiZWxXaWR0aCAmJiB3aWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHdpZHRoKSAtIHBhcnNlSW50KGxhYmVsV2lkdGgpXG4gICAgICAgIH0gZWxzZSBpZiAod2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiB3aWR0aFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldElucHV0V3JhcHBlcklkKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5pZH1fX2lucHV0LXdyYXBwZXJgXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge09iamVjdHxudWxsfVxuICAgICAqL1xuICAgIGdldExhYmVsRWwoKSB7XG4gICAgICAgIHJldHVybiBWRG9tVXRpbC5maW5kKHRoaXMudmRvbSwge3RhZzogJ2xhYmVsJ30pPy52ZG9tIHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldExhYmVsSWQoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmlkfV9fbGFiZWxgXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0U3VibWl0VmFsdWUoKSB7XG4gICAgICAgIGxldCBzdXBlclN1Ym1pdFZhbHVlID0gc3VwZXIuZ2V0U3VibWl0VmFsdWUoKTtcblxuICAgICAgICByZXR1cm4gdGhpcy54c3NQcm90ZWN0ZWQgPyBTdHJpbmdVdGlsLmVzY2FwZUh0bWwoc3VwZXJTdWJtaXRWYWx1ZSkgOiBzdXBlclN1Ym1pdFZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAcmV0dXJucyB7TmVvLmZvcm0uZmllbGQudHJpZ2dlci5CYXNlfG51bGx9XG4gICAgICovXG4gICAgZ2V0VHJpZ2dlcih0eXBlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB0cmlnZ2VycyA9IG1lLnRyaWdnZXJzIHx8IFtdLFxuICAgICAgICAgICAgaSAgICAgICAgPSAwLFxuICAgICAgICAgICAgbGVuICAgICAgPSB0cmlnZ2Vycy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKHRyaWdnZXJzW2ldLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJpZ2dlcnNbaV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gICAgICogQHJldHVybnMge05lby5mb3JtLmZpZWxkLnRyaWdnZXIuQmFzZXxudWxsfVxuICAgICAqL1xuICAgIGdldFRyaWdnZXJCeUlkKGlkKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB0cmlnZ2VycyA9IG1lLnRyaWdnZXJzIHx8IFtdLFxuICAgICAgICAgICAgaSAgICAgICAgPSAwLFxuICAgICAgICAgICAgbGVuICAgICAgPSB0cmlnZ2Vycy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKHRyaWdnZXJzW2ldLmlkID09PSBpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmlnZ2Vyc1tpXVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgdHJpZ2dlciBub2RlIGlkXG4gICAgICovXG4gICAgZ2V0VHJpZ2dlcklkKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWQgKyAnLXRyaWdnZXItJyArIHR5cGVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNDb250ZW50KCkge1xuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmlucHV0VmFsdWU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucGxhY2Vob2xkZXJUZXh0Py5sZW5ndGggPiAwIHx8IHZhbHVlICE9PSBudWxsICYmIHZhbHVlLnRvU3RyaW5nKCkubGVuZ3RoID4gMFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmRzIGEgdHJpZ2dlciBieSBhIGdpdmVuIHR5cGUgY29uZmlnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNUcmlnZ2VyKHR5cGUpIHtcbiAgICAgICAgbGV0IHRyaWdnZXJzID0gdGhpcy50cmlnZ2VycyB8fCBbXSxcbiAgICAgICAgICAgIGkgICAgICAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgICAgID0gdHJpZ2dlcnMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0cmlnZ2Vyc1tpXS50eXBlID09PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSBhbiBpbnB1dCBub2RlIHZhbHVlIGJlZm9yZSBhcHBsaWVkIHRvIHRoaXMudmFsdWUuXG4gICAgICogT3ZlcnJpZGUgYXMgbmVlZGVkXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGlucHV0VmFsdWVBZGp1c3Rvcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm0gYSB2YWx1ZSBiZWZvcmUgZ2V0dGluZyByZW5kZXJlZC5cbiAgICAgKiBPdmVycmlkZSBhcyBuZWVkZWRcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgaW5wdXRWYWx1ZVJlbmRlcmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiAhKHRoaXMudmFsdWU/LnRvU3RyaW5nKCkubGVuZ3RoID4gMClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0VtcHR5QW5kUmVxdWlyZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzRW1wdHkoKSAmJiB0aGlzLnJlcXVpcmVkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNWYWxpZCgpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0ZSh0cnVlKTsgLy8gc2lsZW50XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IgPyBmYWxzZSA6IHN1cGVyLmlzVmFsaWQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICogQHJldHVybnMge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgbWVyZ2VDb25maWcoLi4uYXJncykge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnICAgPSBzdXBlci5tZXJnZUNvbmZpZyguLi5hcmdzKSxcbiAgICAgICAgICAgIHRyaWdnZXJzID0gY29uZmlnLnRyaWdnZXJzIHx8IG1lLnRyaWdnZXJzO1xuXG4gICAgICAgIG1lW3RyaWdnZXJzID8gJ3RyaWdnZXJzJyA6ICdfdHJpZ2dlcnMnXSA9IHRyaWdnZXJzO1xuXG4gICAgICAgIGRlbGV0ZSBjb25maWcudHJpZ2dlcnM7XG4gICAgICAgIHJldHVybiBjb25maWdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGEucGF0aFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbkZvY3VzRW50ZXIoZGF0YSkge1xuICAgICAgICBzdXBlci5vbkZvY3VzRW50ZXIoZGF0YSk7XG5cbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjbHN9ID0gbWU7XG5cbiAgICAgICAgaWYgKCFtZS5yZWFkT25seSkge1xuICAgICAgICAgICAgTmVvQXJyYXkuYWRkKGNscywgJ25lby1mb2N1cycpO1xuICAgICAgICAgICAgbWUuY2xzID0gY2xzO1xuXG4gICAgICAgICAgICBpZiAobWUubGFiZWxQb3NpdGlvbiA9PT0gJ2lubGluZScpIHtcbiAgICAgICAgICAgICAgICBpZiAobWUuY2VudGVyQm9yZGVyRWxXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBtZS5nZXRDZW50ZXJCb3JkZXJFbCgpLndpZHRoID0gbWUuY2VudGVyQm9yZGVyRWxXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgbWUudXBkYXRlKClcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZS51cGRhdGVDZW50ZXJCb3JkZXJFbFdpZHRoKGZhbHNlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5vbGRQYXRoXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uRm9jdXNMZWF2ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjZW50ZXJCb3JkZXJFbCA9IG1lLmdldENlbnRlckJvcmRlckVsKCksIC8vIGxhYmVsUG9zaXRpb246ICdpbmxpbmUnXG4gICAgICAgICAgICBjbHM7XG5cbiAgICAgICAgaWYgKCFtZS5yZWFkT25seSkge1xuICAgICAgICAgICAgbWUudmFsaWRhdGUoZmFsc2UpO1xuXG4gICAgICAgICAgICBjbHMgPSBtZS5jbHM7IC8vIGhhcyB0byBnZXQgc2V0IGFmdGVyIHZhbGlkYXRlKClcblxuICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgJ25lby1mb2N1cycpO1xuICAgICAgICAgICAgbWUuY2xzID0gY2xzO1xuXG4gICAgICAgICAgICBpZiAoY2VudGVyQm9yZGVyRWwgJiYgbWUuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNlbnRlckJvcmRlckVsLndpZHRoXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoTmVvLmlzU3RyaW5nKG1lLnZhbHVlKSkge1xuICAgICAgICAgICAgbWUudmFsdWUgPSBtZS52YWx1ZS50cmltKClcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnVwZGF0ZSgpO1xuXG4gICAgICAgIHN1cGVyLm9uRm9jdXNMZWF2ZShkYXRhKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdHJpZ2dlcmVkIGJ5IHRoZSAnaW5wdXQnIERPTSBldmVudC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbklucHV0VmFsdWVDaGFuZ2UoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBvbGRWYWx1ZSAgID0gbWUudmFsdWUsXG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gZGF0YS52YWx1ZTtcblxuICAgICAgICAvLyBGaW5kIHRoZSBWTm9kZSBmb3IgdGhlIHJlYWwgaW5wdXQgZWxlbWVudCB3aXRoaW4gdGhlIGNvbXBvbmVudCdzIHZub2RlIHRyZWUuXG4gICAgICAgIGNvbnN0IHt2bm9kZTogaW5wdXRWTm9kZX0gPSBWTm9kZVV0aWwuZmluZChtZS52bm9kZSwge25vZGVOYW1lOiAnaW5wdXQnfSkgfHwge307XG5cbiAgICAgICAgaWYgKGlucHV0Vk5vZGUpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGNyaXRpY2FsIHN5bmNocm9uaXphdGlvbiBzdGVwLiBUaGUgdXNlcidzIGlucHV0IGhhcyBjaGFuZ2VkIHRoZVxuICAgICAgICAgICAgLy8gcmVhbCBET00gb24gdGhlIE1haW4gVGhyZWFkLiBXZSBtdXN0IG1hbnVhbGx5IHVwZGF0ZSBvdXIgXCJsYXN0IGtub3duIHN0YXRlXCJcbiAgICAgICAgICAgIC8vICh0aGlzLnZub2RlKSB0byBtYXRjaCB0aGlzIHJlYWxpdHkgKmJlZm9yZSogdGhlIG5leHQgZGlmZmluZyBjeWNsZSBydW5zLlxuICAgICAgICAgICAgLy8gVGhpcyBwcmV2ZW50cyB0aGUgZnJhbWV3b3JrIGZyb20gc2VuZGluZyBhIHJlZHVuZGFudCBkZWx0YSB1cGRhdGUgdGhhdCBjb3VsZFxuICAgICAgICAgICAgLy8gb3ZlcndyaXRlIHRoZSB1c2VyJ3MgaW5wdXQgb3IgY2F1c2UgY3Vyc29yIGp1bXBzLlxuICAgICAgICAgICAgLy8gUmVxdWlyZWQgZS5nLiBmb3IgdmFsaWRhdGlvbiAtPiByZXZlcnQgYSB3cm9uZyB1c2VyIGlucHV0XG4gICAgICAgICAgICBpbnB1dFZOb2RlLmF0dHJpYnV0ZXMudmFsdWUgPSBpbnB1dFZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoTmVvLmlzU3RyaW5nKGlucHV0VmFsdWUpKSB7XG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gaW5wdXRWYWx1ZS50cmltKClcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmNsZWFuICAgICAgPSBmYWxzZTtcbiAgICAgICAgbWUuaW5wdXRWYWx1ZSA9IG1lLmlucHV0VmFsdWVBZGp1c3RvcihpbnB1dFZhbHVlKTsgLy8gdXBkYXRlcyB0aGlzLnZhbHVlXG5cbiAgICAgICAgbWUuZmlyZVVzZXJDaGFuZ2VFdmVudChtZS52YWx1ZSwgb2xkVmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbk1vdXNlRW50ZXIoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAge2Nsc30gPSBtZTtcblxuICAgICAgICBpZiAoIW1lLnJlYWRPbmx5KSB7XG4gICAgICAgICAgICBOZW9BcnJheS5hZGQoY2xzLCAnbmVvLWhvdmVyZWQnKTtcbiAgICAgICAgICAgIG1lLmNscyA9IGNsc1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbk1vdXNlTGVhdmUoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAge2Nsc30gPSBtZTtcblxuICAgICAgICBpZiAoIW1lLnJlYWRPbmx5KSB7XG4gICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUoY2xzLCAnbmVvLWhvdmVyZWQnKTtcbiAgICAgICAgICAgIG1lLmNscyA9IGNsc1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgdHJpZ2dlcnMgb2YgYSBnaXZlbiB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdIHRydWUgcHJldmVudHMgYSB2ZG9tIHVwZGF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt0cmlnZ2VyU291cmNlXSBwYXNzIGEgc2hhbGxvdyBjb3B5IG9mIHRoaXMudHJpZ2dlcnNcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpbiBjYXNlIGEgdHJpZ2dlciB3YXMgZm91bmQgJiByZW1vdmVkXG4gICAgICovXG4gICAgcmVtb3ZlVHJpZ2dlcih0eXBlLCBzaWxlbnQgPSBmYWxzZSwgdHJpZ2dlclNvdXJjZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaGFzTWF0Y2ggPSBmYWxzZSxcbiAgICAgICAgICAgIHRyaWdnZXJzID0gdHJpZ2dlclNvdXJjZSB8fCBtZS50cmlnZ2VycyB8fCBbXSxcbiAgICAgICAgICAgIGkgICAgICAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgICAgID0gdHJpZ2dlcnMubGVuZ3RoLFxuICAgICAgICAgICAgdHJpZ2dlcjtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0cmlnZ2VyID0gdHJpZ2dlcnNbaV07XG5cbiAgICAgICAgICAgIGlmICh0cmlnZ2VyLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUodHJpZ2dlcnMsIHRyaWdnZXIpO1xuICAgICAgICAgICAgICAgIGxlbi0tO1xuICAgICAgICAgICAgICAgIGhhc01hdGNoID0gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc01hdGNoICYmICFzaWxlbnQpIHtcbiAgICAgICAgICAgIG1lLnRyaWdnZXJzID0gdHJpZ2dlcnNcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoYXNNYXRjaFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgZmllbGQgdG8gaXRzIG9yaWdpbmFsIHZhbHVlIG9yIG51bGwgZGVwZW5kaW5nIG9uIHRoZSBjbGVhclRvT3JpZ2luYWxWYWx1ZSBjb25maWdcbiAgICAgKiBZb3UgY2FuIG9wdGlvbmFsbHkgcGFzcyBhIG5ldyB2YWx1ZSwgd2hpY2ggd2lsbCBhZGp1c3QgdGhlIG9yaWdpbmFsQ29uZmlnLnZhbHVlIGlmIG5lZWRlZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBbdmFsdWU9bnVsbF1cbiAgICAgKi9cbiAgICByZXNldCh2YWx1ZSA9IG51bGwpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuY2xlYXJUb09yaWdpbmFsVmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIG1lLm9yaWdpbmFsQ29uZmlnLnZhbHVlID0gdmFsdWVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBtZS5vcmlnaW5hbENvbmZpZy52YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3VwZXIucmVzZXQodmFsdWUpO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCAmJiBtZS5jbGVhbikge1xuICAgICAgICAgICAgbWUudXBkYXRlRXJyb3IobnVsbClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIGxhYmVsUG9zaXRpb246ICdpbmxpbmUnIHRvIGFkanVzdCB0aGUgdG9wIGJvcmRlciBtYXRjaGluZyB0byB0aGUgbGVuZ3RoIG9mIHRoZSBsYWJlbFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbGVudD1mYWxzZV0gdHJ1ZSB0byBnZXQgdGhlIHZhbHVlLCBidXQgbm90IGFwcGx5IGl0IHRvIHRoZSBET01cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdXBkYXRlQ2VudGVyQm9yZGVyRWxXaWR0aChzaWxlbnQgPSBmYWxzZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLm1vdW50ZWQgJiYgbWUuZ2V0RG9tUmVjdChtZS5nZXRDZW50ZXJCb3JkZXJFbCgpLmlkKS50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgbWUuY2VudGVyQm9yZGVyRWxXaWR0aCA9IE1hdGgucm91bmQoZGF0YS53aWR0aCAqIC43KSArIDg7XG5cbiAgICAgICAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgbWUuZ2V0Q2VudGVyQm9yZGVyRWwoKS53aWR0aCA9IG1lLmNlbnRlckJvcmRlckVsV2lkdGg7XG4gICAgICAgICAgICAgICAgbWUudXBkYXRlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgQHBhcmFtIHtCb29sZWFufSBzaWxlbnQ9ZmFsc2VcbiAgICAgKi9cbiAgICB1cGRhdGVFcnJvcih2YWx1ZSwgc2lsZW50ID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjbHN9ID0gbWUsXG4gICAgICAgICAgICBlcnJvck5vZGUsIGVycm9yV3JhcHBlcjtcblxuICAgICAgICBpZiAoIShtZS5jbGVhbiAmJiAhbWUubW91bnRlZCkpIHtcbiAgICAgICAgICAgIE5lb0FycmF5W3ZhbHVlID8gJ2FkZCcgOiAncmVtb3ZlJ10oY2xzLCAnbmVvLWludmFsaWQnKTtcbiAgICAgICAgICAgIG1lLmNscyA9IGNscztcblxuICAgICAgICAgICAgZXJyb3JXcmFwcGVyID0gVkRvbVV0aWwuZmluZChtZS52ZG9tLCB7Y2xzOiAnbmVvLXRleHRmaWVsZC1lcnJvci13cmFwcGVyJ30pLnZkb207XG4gICAgICAgICAgICBlcnJvck5vZGUgICAgPSBlcnJvcldyYXBwZXIuY25bMF07XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGVycm9yTm9kZS50ZXh0ID0gdmFsdWVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGVycm9yTm9kZS50ZXh0XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVycm9yV3JhcHBlci5yZW1vdmVEb20gPSAhdmFsdWU7XG5cbiAgICAgICAgICAgICFzaWxlbnQgJiYgbWUudXBkYXRlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGFzIG5lZWRlZCBpbnNpZGUgY2xhc3MgZXh0ZW5zaW9ucy5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHVwZGF0ZUlucHV0VmFsdWVGcm9tVmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5pbnB1dFZhbHVlID0gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBuZXcgaW5wdXRXaWR0aCBiYXNlZCBvbiB0aGUgbGFiZWxXaWR0aCAmIHRvdGFsIHdpZHRoXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHVwZGF0ZUlucHV0V2lkdGgoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGlucHV0V2lkdGggPSBtZS5nZXRJbnB1dFdpZHRoKCk7XG5cbiAgICAgICAgaWYgKGlucHV0V2lkdGggIT09IG51bGwgJiYgaW5wdXRXaWR0aCAhPT0gbWUud2lkdGgpIHtcbiAgICAgICAgICAgIG1lLnZkb20uY25bMV0ud2lkdGggPSBpbnB1dFdpZHRoXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgbWUudmRvbS5jblsxXS53aWR0aFxuICAgICAgICB9XG5cbiAgICAgICAgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgRE9NIGJhc2VkIHJlYWRvbmx5IGF0dHJpYnV0ZSBuZWVkcyB0byBob25vciB0aGUgZWRpdGFibGUgJiByZWFkT25seSBjb25maWdzXG4gICAgICovXG4gICAgdXBkYXRlUmVhZE9ubHlTdGF0ZSgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5jaGFuZ2VJbnB1dEVsS2V5KCdyZWFkb25seScsICFtZS5lZGl0YWJsZSB8fCBtZS5yZWFkT25seSB8fCBudWxsKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNpbmNlIHRyaWdnZXJzIGRvIG5vdCBnZXQgdm5vZGVJbml0aWFsaXplZCwgYXNzaWduIHRoZSByZWxldmFudCBwcm9wc1xuICAgICAqL1xuICAgIHVwZGF0ZVRyaWdnZXJWbm9kZXMoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB0cmlnZ2VyUm9vdCA9IG1lLnZub2RlPy5jaGlsZE5vZGVzWzFdLFxuICAgICAgICAgICAgY2hpbGROb2RlcyAgPSB0cmlnZ2VyUm9vdD8uY2hpbGROb2RlcyB8fCBbXSxcbiAgICAgICAgICAgIHRyaWdnZXI7XG5cbiAgICAgICAgY2hpbGROb2Rlcy5mb3JFYWNoKHZub2RlID0+IHtcbiAgICAgICAgICAgIHRyaWdnZXIgPSBtZS5nZXRUcmlnZ2VyQnlJZCh2bm9kZS5pZCk7XG5cbiAgICAgICAgICAgIHRyaWdnZXIgJiYgT2JqZWN0LmFzc2lnbih0cmlnZ2VyLCB7XG4gICAgICAgICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgICAgICAgX21vdW50ZWQgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICAgICAgX3Zub2RlSW5pdGlhbGl6ZWQ6IHRydWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgYXMgbmVlZGVkIGluc2lkZSBjbGFzcyBleHRlbnNpb25zLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHVwZGF0ZVZhbHVlRnJvbUlucHV0VmFsdWUoaW5wdXRWYWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gaW5wdXRWYWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBmb3IgY2xpZW50LXNpZGUgZmllbGQgZXJyb3JzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaWxlbnQ9dHJ1ZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaW4gY2FzZSB0aGVyZSBhcmUgbm8gY2xpZW50LXNpZGUgZXJyb3JzXG4gICAgICovXG4gICAgdmFsaWRhdGUoc2lsZW50PXRydWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtpbnB1dFBhdHRlcm4sIG1heExlbmd0aCwgbWluTGVuZ3RoLCByZXF1aXJlZCwgdmFsdWV9ID0gbWUsXG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHRydWUsXG4gICAgICAgICAgICB2YWx1ZUxlbmd0aCA9IHZhbHVlPy50b1N0cmluZygpLmxlbmd0aCxcbiAgICAgICAgICAgIGlzRW1wdHkgICAgID0gdmFsdWUgIT09IDAgJiYgKCF2YWx1ZSB8fCB2YWx1ZUxlbmd0aCA8IDEpLFxuICAgICAgICAgICAgZXJyb3JQYXJhbSAgPSB7aW5wdXRQYXR0ZXJuLCBtYXhMZW5ndGgsIG1pbkxlbmd0aCwgdmFsdWVMZW5ndGh9LFxuICAgICAgICAgICAgZXJyb3JUZXh0O1xuXG4gICAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgICAvLyBpbiBjYXNlIHdlIG1hbnVhbGx5IGNhbGwgdmFsaWRhdGUoZmFsc2UpIG9uIGEgZm9ybSBvciBmaWVsZCBiZWZvcmUgaXQgaXMgbW91bnRlZCwgd2UgZG8gd2FudCB0byBzZWUgZXJyb3JzLlxuICAgICAgICAgICAgbWUuY2xlYW4gPSBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRW1wdHkpIHtcbiAgICAgICAgICAgIGlmIChyZXF1aXJlZCkge1xuICAgICAgICAgICAgICAgIG1lLl9lcnJvciAgID0gbWUuZXJyb3JUZXh0UmVxdWlyZWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKE5lby5pc051bWJlcihtYXhMZW5ndGgpICYmIHZhbHVlTGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbWUuX2Vycm9yICAgPSBtZS5lcnJvclRleHRNYXhMZW5ndGgoZXJyb3JQYXJhbSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBmYWxzZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChOZW8uaXNOdW1iZXIobWluTGVuZ3RoKSAmJiB2YWx1ZUxlbmd0aCA8IG1pbkxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG1lLl9lcnJvciAgID0gbWUuZXJyb3JUZXh0TWluTGVuZ3RoKGVycm9yUGFyYW0pO1xuICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gZmFsc2VcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXRQYXR0ZXJuICYmICFpbnB1dFBhdHRlcm4udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBtZS5fZXJyb3IgICA9IG1lLmVycm9yVGV4dElucHV0UGF0dGVybihlcnJvclBhcmFtKTtcbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IGZhbHNlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lLnZhbGlkYXRvcikge1xuICAgICAgICAgICAgICAgIG1lLmJpbmRDYWxsYmFjayhtZS52YWxpZGF0b3IsICd2YWxpZGF0b3InKTtcblxuICAgICAgICAgICAgICAgIGVycm9yVGV4dCA9IG1lLnZhbGlkYXRvcihtZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JUZXh0ICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLl9lcnJvciAgID0gZXJyb3JUZXh0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJldHVyblZhbHVlKSB7XG4gICAgICAgICAgICBtZS5fZXJyb3IgPSBudWxsXG4gICAgICAgIH1cblxuICAgICAgICAhbWUuY2xlYW4gJiYgbWUudXBkYXRlRXJyb3IobWUuX2Vycm9yLCBzaWxlbnQpO1xuXG4gICAgICAgIHJldHVybiAhcmV0dXJuVmFsdWUgPyBmYWxzZSA6IHN1cGVyLnZhbGlkYXRlKHNpbGVudClcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0aGUgZmllbGQgaW50byBhIEpTT04tY29tcGF0aWJsZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLnRvSlNPTigpLFxuICAgICAgICAgICAgYXV0b0NhcGl0YWxpemUgOiBtZS5hdXRvQ2FwaXRhbGl6ZSxcbiAgICAgICAgICAgIGF1dG9Db21wbGV0ZSAgIDogbWUuYXV0b0NvbXBsZXRlLFxuICAgICAgICAgICAgY2xlYXJhYmxlICAgICAgOiBtZS5jbGVhcmFibGUsXG4gICAgICAgICAgICBlZGl0YWJsZSAgICAgICA6IG1lLmVkaXRhYmxlLFxuICAgICAgICAgICAgaGlkZUxhYmVsICAgICAgOiBtZS5oaWRlTGFiZWwsXG4gICAgICAgICAgICBpbnB1dFBhdHRlcm4gICA6IG1lLmlucHV0UGF0dGVybj8udG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGlucHV0VHlwZSAgICAgIDogbWUuaW5wdXRUeXBlLFxuICAgICAgICAgICAgaW5wdXRWYWx1ZSAgICAgOiBtZS5pbnB1dFZhbHVlLFxuICAgICAgICAgICAgbGFiZWxQb3NpdGlvbiAgOiBtZS5sYWJlbFBvc2l0aW9uLFxuICAgICAgICAgICAgbGFiZWxUZXh0ICAgICAgOiBtZS5sYWJlbFRleHQsXG4gICAgICAgICAgICBtYXhMZW5ndGggICAgICA6IG1lLm1heExlbmd0aCxcbiAgICAgICAgICAgIG1pbkxlbmd0aCAgICAgIDogbWUubWluTGVuZ3RoLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXJUZXh0OiBtZS5wbGFjZWhvbGRlclRleHQsXG4gICAgICAgICAgICByZWFkT25seSAgICAgICA6IG1lLnJlYWRPbmx5LFxuICAgICAgICAgICAgcmVxdWlyZWQgICAgICAgOiBtZS5yZXF1aXJlZCxcbiAgICAgICAgICAgIHRyaWdnZXJzICAgICAgIDogbWUudHJpZ2dlcnM/Lm1hcCh0cmlnZ2VyID0+IHRyaWdnZXIudG9KU09OKCkpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFRleHQpO1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi8uLi8uLi9jb21wb25lbnQvQmFzZS5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICBmcm9tICcuLi8uLi8uLi91dGlsL0FycmF5Lm1qcyc7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgZm9ybSBmaWVsZCBUcmlnZ2Vyc1xuICogQGNsYXNzIE5lby5mb3JtLmZpZWxkLnRyaWdnZXIuQmFzZVxuICogQGV4dGVuZHMgTmVvLmNvbXBvbmVudC5CYXNlXG4gKi9cbmNsYXNzIEJhc2UgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIFZhbGlkIHZhbHVlcyBmb3IgYWxpZ25cbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYWxpZ25WYWx1ZXM9WydlbmQnLCAnc3RhcnQnXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGFsaWduVmFsdWVzID0gWydlbmQnLCAnc3RhcnQnXVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZm9ybS5maWVsZC50cmlnZ2VyLkJhc2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5mb3JtLmZpZWxkLnRyaWdnZXIuQmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSd0cmlnZ2VyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3RyaWdnZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBhbGlnbl89J2VuZCdcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBhbGlnbjogJ2VuZCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1maWVsZC10cmlnZ2VyJ11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWZpZWxkLXRyaWdnZXInXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5mb3JtLmZpZWxkLkJhc2V8bnVsbH0gZmllbGQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZmllbGRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGljb25DbHNfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBpY29uQ2xzXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzSG92ZXJlZD1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBpc0hvdmVyZWQ6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNjb3BlIG9mIHRoZSB0cmlnZ2VyIGhhbmRsZXJcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvcmUuQmFzZXxudWxsfSBzY29wZT1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBzY29wZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNob3dPbkhvdmVyPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBzaG93T25Ib3ZlcjogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBmbGFnIHVzZWQgYnkgZmllbGQuZ2V0VHJpZ2dlcigpXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gdHlwZT0nYmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdHlwZTogJ2Jhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSB3ZWlnaHRfPTEwXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgd2VpZ2h0XzogMTBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmFkZERvbUxpc3RlbmVycyhcbiAgICAgICAgICAgIHtjbGljazogbWUub25UcmlnZ2VyQ2xpY2ssIHNjb3BlOiBtZX1cbiAgICAgICAgKTtcblxuICAgICAgICBpZiAobWUuc2hvd09uSG92ZXIpIHtcbiAgICAgICAgICAgIG1lLmhpZGRlbiA9IHRydWU7XG5cbiAgICAgICAgICAgIG1lLmZpZWxkLm9uKCdjb25zdHJ1Y3RlZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBtZS5maWVsZC5hZGREb21MaXN0ZW5lcnMoW1xuICAgICAgICAgICAgICAgICAgICB7bW91c2VlbnRlcjogbWUub25Nb3VzZUVudGVyLCBzY29wZTogbWV9LFxuICAgICAgICAgICAgICAgICAgICB7bW91c2VsZWF2ZTogbWUub25Nb3VzZUxlYXZlLCBzY29wZTogbWV9XG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIH0sIG1lKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBhbGlnbiBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRBbGlnbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IGNscyA9IHRoaXMuY2xzO1xuXG4gICAgICAgIE5lb0FycmF5W3ZhbHVlID09PSAnc3RhcnQnID8gJ2FkZCcgOiAncmVtb3ZlJ10oY2xzLCAnbmVvLWFsaWduLXN0YXJ0Jyk7XG4gICAgICAgIHRoaXMuY2xzID0gY2xzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBmaWVsZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRGaWVsZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgKHRoaXMudmRvbS5kYXRhIHx8ICh0aGlzLnZkb20uZGF0YSA9IHt9KSkuZm9jdXMgPSB2YWx1ZT8uZ2V0SW5wdXRFbElkKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGhpZGRlbiBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEhpZGRlbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IHtzdHlsZX0gPSB0aGlzO1xuXG4gICAgICAgIHN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/ICdub25lJyA6ICdpbmhlcml0JztcbiAgICAgICAgdGhpcy5zdHlsZSA9IHN0eWxlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBpY29uQ2xzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEljb25DbHModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCB7Y2xzfSA9IHRoaXM7XG5cbiAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgb2xkVmFsdWU/LnNwbGl0KCcgJykpO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgICAgIE5lb0FycmF5LmFkZChjbHMsIHZhbHVlPy5zcGxpdCgnICcpKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jbHMgPSBjbHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBhbGlnbiBjb25maWcgZ2V0cyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldEFsaWduKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnYWxpZ24nLCAnYWxpZ25WYWx1ZXMnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdXBkYXRlUGFyZW50VmRvbVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50XG4gICAgICovXG4gICAgZGVzdHJveSh1cGRhdGVQYXJlbnRWZG9tLCBzaWxlbnQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5yZW1vdmVEb21MaXN0ZW5lcnMoXG4gICAgICAgICAgICB7Y2xpY2s6IG1lLm9uVHJpZ2dlckNsaWNrLCBzY29wZTogbWV9XG4gICAgICAgICk7XG5cbiAgICAgICAgZGVsZXRlIG1lLmZpZWxkO1xuXG4gICAgICAgIHN1cGVyLmRlc3Ryb3kodXBkYXRlUGFyZW50VmRvbSwgc2lsZW50KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25Nb3VzZUVudGVyKCkge1xuICAgICAgICB0aGlzLmlzSG92ZXJlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaGlkZGVuICAgID0gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uTW91c2VMZWF2ZSgpIHtcbiAgICAgICAgdGhpcy5pc0hvdmVyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oaWRkZW4gICAgPSB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2xpY2sgZG9tRXZlbnQgbGlzdGVuZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvblRyaWdnZXJDbGljayhkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICBzY29wZSA9IG1lLnNjb3BlIHx8IG1lO1xuXG4gICAgICAgIGlmIChtZS5oYW5kbGVyKSB7XG4gICAgICAgICAgICBzY29wZVttZS5oYW5kbGVyXS5jYWxsKHNjb3BlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0aGUgdHJpZ2dlciBpbnRvIGEgSlNPTi1jb21wYXRpYmxlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXG4gICAgICAgICAgICBpY29uQ2xzICAgIDogbWUuaWNvbkNscyxcbiAgICAgICAgICAgIHNob3dPbkhvdmVyOiBtZS5zaG93T25Ib3ZlcixcbiAgICAgICAgICAgIHR5cGUgICAgICAgOiBtZS50eXBlLFxuICAgICAgICAgICAgd2VpZ2h0ICAgICA6IG1lLndlaWdodFxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhCYXNlKTtcbiIsImltcG9ydCBCYXNlICAgICBmcm9tICcuL0Jhc2UubWpzJztcbmltcG9ydCBOZW9BcnJheSBmcm9tICcuLi8uLi8uLi91dGlsL0FycmF5Lm1qcyc7XG5cbi8qKlxuICogQ2xlYXIgVHJpZ2dlciB0byByZW1vdmUgdGhlIGlucHV0IHZhbHVlIG9mIFRleHRGaWVsZHMgb3Igc3ViY2xhc3Nlc1xuICogQGNsYXNzIE5lby5mb3JtLmZpZWxkLnRyaWdnZXIuQ2xlYXJcbiAqIEBleHRlbmRzIE5lby5mb3JtLmZpZWxkLnRyaWdnZXIuQmFzZVxuICovXG5jbGFzcyBDbGVhciBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmZvcm0uZmllbGQudHJpZ2dlci5DbGVhcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmZvcm0uZmllbGQudHJpZ2dlci5DbGVhcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSd0cmlnZ2VyLWNsZWFyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3RyaWdnZXItY2xlYXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tZmllbGQtdHJpZ2dlcicsJ25lby10cmlnZ2VyLWNsZWFyJ11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWZpZWxkLXRyaWdnZXInLCAnbmVvLXRyaWdnZXItY2xlYXInXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBpY29uQ2xzPSdmYSBmYS10aW1lcydcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBpY29uQ2xzOiAnZmEgZmEtdGltZXMnLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgZmxhZyB1c2VkIGJ5IGZpZWxkLmdldFRyaWdnZXIoKVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHR5cGU9J2NsZWFyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0eXBlOiAnY2xlYXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSB3ZWlnaHRfPTIwXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgd2VpZ2h0OiAyMFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaGlkZGVuIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SGlkZGVuKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQge2Nsc30gPSB0aGlzO1xuXG4gICAgICAgIE5lb0FycmF5W3ZhbHVlID8gJ2FkZCcgOiAncmVtb3ZlJ10oY2xzLCAnbmVvLWlzLWhpZGRlbicpO1xuICAgICAgICB0aGlzLmNscyA9IGNscztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBoaWRkZW4gY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRIaWRkZW4odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnNob3dPbkhvdmVyICYmICF0aGlzLmlzSG92ZXJlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZGVzdHJveSguLi5hcmdzKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuZmllbGQudW4oe1xuICAgICAgICAgICAgY2hhbmdlICAgICAgICAgICAgICAgICAgICA6IG1lLm9uRmllbGRDaGFuZ2UsXG4gICAgICAgICAgICBjaGFuZ2VDbGVhclRvT3JpZ2luYWxWYWx1ZTogbWUub25GaWVsZENoYW5nZSxcbiAgICAgICAgICAgIHNjb3BlICAgICAgICAgICAgICAgICAgICAgOiBtZVxuICAgICAgICB9KTtcblxuICAgICAgICBzdXBlci5kZXN0cm95KC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaW4gY2FzZSB0aGUgdHJpZ2dlciBzaG91bGQgYmUgaGlkZGVuXG4gICAgICovXG4gICAgZ2V0SGlkZGVuU3RhdGUoKSB7XG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtmaWVsZH0gPSBtZSxcbiAgICAgICAgICAgIHt2YWx1ZX0gPSBmaWVsZDtcblxuICAgICAgICBpZiAoZmllbGQuY2xlYXJUb09yaWdpbmFsVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gZmllbGQub3JpZ2luYWxDb25maWcudmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICcwJ1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gIWZpZWxkLnZhbHVlIHx8IHZhbHVlLnRvU3RyaW5nKCkubGVuZ3RoIDwgMVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKi9cbiAgICBvbkZpZWxkQ2hhbmdlKG9wdHMpIHtcbiAgICAgICAgdGhpcy5oaWRkZW4gPSB0aGlzLmdldEhpZGRlblN0YXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIHN1cGVyLm9uQ29uc3RydWN0ZWQoKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmZpZWxkLm9uKHtcbiAgICAgICAgICAgIGNoYW5nZSAgICAgICAgICAgICAgICAgICAgOiBtZS5vbkZpZWxkQ2hhbmdlLFxuICAgICAgICAgICAgY2hhbmdlQ2xlYXJUb09yaWdpbmFsVmFsdWU6IG1lLm9uRmllbGRDaGFuZ2UsXG4gICAgICAgICAgICBzY29wZSAgICAgICAgICAgICAgICAgICAgIDogbWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUuaGlkZGVuID0gbWUuZ2V0SGlkZGVuU3RhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIG9uTW91c2VFbnRlcigpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5pc0hvdmVyZWQgPSB0cnVlO1xuICAgICAgICBtZS5oaWRkZW4gICAgPSBtZS5nZXRIaWRkZW5TdGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvblRyaWdnZXJDbGljayhkYXRhKSB7XG4gICAgICAgIHRoaXMuZmllbGQuY2xlYXIoKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ2xlYXIpO1xuIiwiaW1wb3J0IEJhc2UgZnJvbSAnLi9CYXNlLm1qcyc7XG5cbi8qKlxuICogRGVjcmVhc2VzIHRoZSB2YWx1ZSBvZiBhIE51bWJlckZpZWxkXG4gKiBAY2xhc3MgTmVvLmZvcm0uZmllbGQudHJpZ2dlci5TcGluRG93blxuICogQGV4dGVuZHMgTmVvLmZvcm0uZmllbGQudHJpZ2dlci5CYXNlXG4gKi9cbmNsYXNzIFNwaW5Eb3duIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZm9ybS5maWVsZC50cmlnZ2VyLlNwaW5VcCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmZvcm0uZmllbGQudHJpZ2dlci5TcGluRG93bicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSd0cmlnZ2VyLXNwaW5kb3duJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3RyaWdnZXItc3BpbmRvd24nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBhbGlnbl89J3N0YXJ0J1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGFsaWduOiAnc3RhcnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGljb25DbHM9J2ZhIGZhLWNoZXZyb24tbGVmdCdcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBpY29uQ2xzOiAnZmEgZmEtY2hldnJvbi1sZWZ0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGZsYWcgdXNlZCBieSBmaWVsZC5nZXRUcmlnZ2VyKClcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB0eXBlPSdzcGluZG93bidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdHlwZTogJ3NwaW5kb3duJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25UcmlnZ2VyQ2xpY2soZGF0YSkge1xuICAgICAgICB0aGlzLmZpZWxkLm9uU3BpbkJ1dHRvbkRvd25DbGljaygpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhTcGluRG93bik7XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuL0Jhc2UubWpzJztcblxuLyoqXG4gKiBJbmNyZWFzZXMgdGhlIHZhbHVlIG9mIGEgTnVtYmVyRmllbGRcbiAqIEBjbGFzcyBOZW8uZm9ybS5maWVsZC50cmlnZ2VyLlNwaW5VcFxuICogQGV4dGVuZHMgTmVvLmZvcm0uZmllbGQudHJpZ2dlci5CYXNlXG4gKi9cbmNsYXNzIFNwaW5VcCBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmZvcm0uZmllbGQudHJpZ2dlci5TcGluVXAnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5mb3JtLmZpZWxkLnRyaWdnZXIuU3BpblVwJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3RyaWdnZXItc3BpbnVwJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3RyaWdnZXItc3BpbnVwJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBpY29uQ2xzPSdmYSBmYS1jaGV2cm9uLXJpZ2h0J1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGljb25DbHM6ICdmYSBmYS1jaGV2cm9uLXJpZ2h0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGZsYWcgdXNlZCBieSBmaWVsZC5nZXRUcmlnZ2VyKClcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB0eXBlPSdzcGludXAnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHR5cGU6ICdzcGludXAnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvblRyaWdnZXJDbGljayhkYXRhKSB7XG4gICAgICAgIHRoaXMuZmllbGQub25TcGluQnV0dG9uVXBDbGljaygpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhTcGluVXApO1xuIiwiaW1wb3J0IEJhc2UgZnJvbSAnLi9CYXNlLm1qcyc7XG5cbi8qKlxuICogQ29tYmluZXMgc3BpbiB1cCAmIGRvd24gaW5zaWRlIG9uZSB0cmlnZ2VyXG4gKiBAY2xhc3MgTmVvLmZvcm0uZmllbGQudHJpZ2dlci5TcGluVXBEb3duXG4gKiBAZXh0ZW5kcyBOZW8uZm9ybS5maWVsZC50cmlnZ2VyLkJhc2VcbiAqL1xuY2xhc3MgU3BpblVwRG93biBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmZvcm0uZmllbGQudHJpZ2dlci5TcGluVXBEb3duJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZm9ybS5maWVsZC50cmlnZ2VyLlNwaW5VcERvd24nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ndHJpZ2dlci1zcGludXBkb3duJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3RyaWdnZXItc3BpbnVwZG93bicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1maWVsZC10cmlnZ2VyJywnbmVvLXNwaW4tYnV0dG9ucyddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1maWVsZC10cmlnZ2VyJywgJ25lby1zcGluLWJ1dHRvbnMnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gc3BpbkJ1dHRvbkRvd25JY29uQ2xzPSdmYSBmYS1jaGV2cm9uLWRvd24nXG4gICAgICAgICAqL1xuICAgICAgICBzcGluQnV0dG9uRG93bkljb25DbHM6ICdmYSBmYS1jaGV2cm9uLWRvd24nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBzcGluQnV0dG9uVXBJY29uQ2xzPSdmYSBmYS1jaGV2cm9uLXVwJ1xuICAgICAgICAgKi9cbiAgICAgICAgc3BpbkJ1dHRvblVwSWNvbkNsczogJ2ZhIGZhLWNoZXZyb24tdXAnLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgZmxhZyB1c2VkIGJ5IGZpZWxkLmdldFRyaWdnZXIoKVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHR5cGU9J3NwaW51cGRvd24nXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHR5cGU6ICdzcGludXBkb3duJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25Db25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS52ZG9tLmNuID0gW1xuICAgICAgICAgICAge2NsczogWyduZW8tc3Bpbi1idXR0b24nLCAnbmVvLXVwJywgICAuLi5tZS5zcGluQnV0dG9uVXBJY29uQ2xzICAuc3BsaXQoJyAnKV19LFxuICAgICAgICAgICAge2NsczogWyduZW8tc3Bpbi1idXR0b24nLCAnbmVvLWRvd24nLCAuLi5tZS5zcGluQnV0dG9uRG93bkljb25DbHMuc3BsaXQoJyAnKV19XG4gICAgICAgIF07XG5cbiAgICAgICAgbWUudXBkYXRlKCk7XG5cbiAgICAgICAgc3VwZXIub25Db25zdHJ1Y3RlZCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvblRyaWdnZXJDbGljayhkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgdGFyZ2V0ID0gZGF0YS5wYXRoWzBdLFxuICAgICAgICAgICAgY2xzICAgID0gdGFyZ2V0LmNscy5qb2luKCcgJyk7XG5cbiAgICAgICAgaWYgKGNscy5pbmNsdWRlcygnbmVvLWRvd24nKSkge1xuICAgICAgICAgICAgbWUuZmllbGQub25TcGluQnV0dG9uRG93bkNsaWNrKClcbiAgICAgICAgfSBlbHNlIGlmIChjbHMuaW5jbHVkZXMoJ25lby11cCcpKSB7XG4gICAgICAgICAgICBtZS5maWVsZC5vblNwaW5CdXR0b25VcENsaWNrKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIHRyaWdnZXIgaW50byBhIEpTT04tY29tcGF0aWJsZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLnRvSlNPTigpLFxuICAgICAgICAgICAgc3BpbkJ1dHRvbkRvd25JY29uQ2xzOiBtZS5zcGluQnV0dG9uRG93bkljb25DbHMsXG4gICAgICAgICAgICBzcGluQnV0dG9uVXBJY29uQ2xzICA6IG1lLnNwaW5CdXR0b25VcEljb25DbHNcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoU3BpblVwRG93bik7XG4iLCJpbXBvcnQgQmFzZSAgICAgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGNsYXNzIGZvciBhbGwgb3RoZXIgbGF5b3V0cy5cbiAqIFVzZSBpdCBkaXJlY3RseSBpbiBjYXNlIHlvdSB3YW50IHRvIGNyZWF0ZSBhIGNvbnRhaW5lciB3aXRob3V0IGEgbGF5b3V0LlxuICogQGNsYXNzIE5lby5sYXlvdXQuQmFzZVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBMYXlvdXQgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5sYXlvdXQuQmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmxheW91dC5CYXNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2xheW91dC1iYXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2xheW91dC1iYXNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSBBcHAgdGhpcyBsYXlvdXQgYmVsb25ncyB0b1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gYXBwTmFtZV89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGFwcE5hbWVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGlkIG9mIHRoZSBDb250YWluZXIgaW5zdGFuY2UgdGhpcyBsYXlvdXQgaXMgYm91bmQgdG9cbiAgICAgICAgICogQG1lbWJlciB7P1N0cmluZ30gY29udGFpbmVySWQ9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluZXJJZDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGF5b3V0IHNwZWNpZmljIENTUyBzZWxlY3RvciB3aGljaCBnZXRzIGFkZGVkIHRvIENvbnRhaW5lciB0aGUgbGF5b3V0IGlzIGJvdW5kIHRvLlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gY29udGFpbmVyQ2xzXz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluZXJDbHNfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogSWRlbnRpZmllciBmb3IgYWxsIGNsYXNzZXMgdGhhdCBleHRlbmQgbGF5b3V0LkJhc2VcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNMYXlvdXQ9dHJ1ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBpc0xheW91dDogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSB3aW5kb3dJZF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHdpbmRvd0lkXzogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOZW8uY29udGFpbmVyLkJhc2V8bnVsbH1cbiAgICAgKi9cbiAgICBnZXQgY29udGFpbmVyKCkge1xuICAgICAgICBsZXQge2NvbnRhaW5lcklkfSA9IHRoaXM7XG5cbiAgICAgICAgLy8gdGhlIGluc3RhbmNlIG1pZ2h0IG5vdCBiZSByZWdpc3RlcmVkIHlldFxuICAgICAgICByZXR1cm4gTmVvLmdldENvbXBvbmVudChjb250YWluZXJJZCkgfHwgTmVvLmdldChjb250YWluZXJJZClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHdpbmRvd0lkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0V2luZG93SWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHZhbHVlICYmIE5lby5jdXJyZW50V29ya2VyLmluc2VydFRoZW1lRmlsZXModmFsdWUsIHRoaXMuX19wcm90b19fKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBsYWNlaG9sZGVyIG1ldGhvZFxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBpdGVtXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFwcGx5Q2hpbGRBdHRyaWJ1dGVzKGl0ZW0sIGluZGV4KSB7fVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaWxlbnQ9ZmFsc2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYXBwbHlSZW5kZXJBdHRyaWJ1dGVzKHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y29udGFpbmVyLCBjb250YWluZXJDbHN9ID0gbWUsXG4gICAgICAgICAgICB7d3JhcHBlckNsc30gICAgICAgICAgICAgID0gY29udGFpbmVyO1xuXG4gICAgICAgIGlmIChjb250YWluZXJDbHMpIHtcbiAgICAgICAgICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgTmVvLmxvZ0Vycm9yKG1lLmNsYXNzTmFtZSArICc6IGFwcGx5UmVuZGVyQXR0cmlidXRlcyAtPiBjb250YWluZXIgbm90IHlldCBjcmVhdGVkJywgbWUuY29udGFpbmVySWQpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE5lb0FycmF5LmFkZCh3cmFwcGVyQ2xzLCBjb250YWluZXJDbHMpO1xuXG4gICAgICAgICAgICBjb250YWluZXJbc2lsZW50ID8gJ3NldFNpbGVudCcgOiAgJ3NldCddKHt3cmFwcGVyQ2xzfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5iaW5kICYmIG1lLmdldFN0YXRlUHJvdmlkZXIoKT8ucmVtb3ZlQmluZGluZ3MobWUuaWQpO1xuXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbnRhaW5lciBzdGF0ZVByb3ZpZGVyIG9yIGl0cyBjbG9zZXN0IHBhcmVudCBzdGF0ZVByb3ZpZGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtudHlwZV1cbiAgICAgKiBAcmV0dXJucyB7TmVvLnN0YXRlLlByb3ZpZGVyfG51bGx9XG4gICAgICovXG4gICAgZ2V0U3RhdGVQcm92aWRlcihudHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXIuZ2V0U3RhdGVQcm92aWRlcihudHlwZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGFsbCBjbGFzcyBjb25maWdzIHRvIHRoaXMgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcHJldmVudE9yaWdpbmFsQ29uZmlnXSBUcnVlIHByZXZlbnRzIHRoZSBpbnN0YW5jZSBmcm9tIGdldHRpbmcgYW4gb3JpZ2luYWxDb25maWcgcHJvcGVydHlcbiAgICAgKi9cbiAgICBpbml0Q29uZmlnKGNvbmZpZywgcHJldmVudE9yaWdpbmFsQ29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmluaXRDb25maWcoY29uZmlnLCBwcmV2ZW50T3JpZ2luYWxDb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuYmluZCAmJiBtZS5jb250YWluZXIuZ2V0U3RhdGVQcm92aWRlcigpPy5jcmVhdGVCaW5kaW5ncyhtZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQbGFjZWhvbGRlciBtZXRob2RcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gaXRlbVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICByZW1vdmVDaGlsZEF0dHJpYnV0ZXMoaXRlbSwgaW5kZXgpIHt9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcmVtb3ZlUmVuZGVyQXR0cmlidXRlcygpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2NvbnRhaW5lciwgY29udGFpbmVyQ2xzfSA9IG1lLFxuICAgICAgICAgICAge3dyYXBwZXJDbHN9ICAgICAgICAgICAgICA9IGNvbnRhaW5lcjtcblxuICAgICAgICBpZiAoY29udGFpbmVyQ2xzKSB7XG4gICAgICAgICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIE5lby5sb2dFcnJvcihtZS5jbGFzc05hbWUgKyAnOiByZW1vdmVSZW5kZXJBdHRyaWJ1dGVzIC0+IGNvbnRhaW5lciBub3QgeWV0IGNyZWF0ZWQnLCBtZS5jb250YWluZXJJZClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKHdyYXBwZXJDbHMsIGNvbnRhaW5lckNscyk7XG5cbiAgICAgICAgICAgIGNvbnRhaW5lci53cmFwcGVyQ2xzID0gd3JhcHBlckNsc1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIG11bHRpcGxlIGNvbmZpZ3MgYXQgb25jZSwgZW5zdXJpbmcgdGhhdCBhbGwgYWZ0ZXJTZXQgbWV0aG9kcyBnZXQgYWxsIG5ldyBhc3NpZ25lZCB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzPXt9XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaWxlbnQ9ZmFsc2VcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTwqPn1cbiAgICAgKi9cbiAgICBzZXQodmFsdWVzPXt9LCBzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjb250YWluZXJ9ID0gbWU7XG5cbiAgICAgICAgY29udGFpbmVyLnNpbGVudFZkb21VcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgIHN1cGVyLnNldCh2YWx1ZXMpO1xuXG4gICAgICAgIGNvbnRhaW5lci5zaWxlbnRWZG9tVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHNpbGVudCB8fCAhY29udGFpbmVyLm5lZWRzVmRvbVVwZGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGFpbmVyLnByb21pc2VVcGRhdGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXQgY2FsbGluZyBzZXQoKSB3aXRoIHRoZSBzaWxlbnQgZmxhZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXM9e31cbiAgICAgKi9cbiAgICBzZXRTaWxlbnQodmFsdWVzPXt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldCh2YWx1ZXMsIHRydWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0aGUgaW5zdGFuY2UgaW50byBhIEpTT04tY29tcGF0aWJsZSBvYmplY3QgZm9yIHRoZSBOZXVyYWwgTGluay5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXG4gICAgICAgICAgICBhcHBOYW1lICAgICA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICBjb250YWluZXJDbHM6IG1lLmNvbnRhaW5lckNscyxcbiAgICAgICAgICAgIGNvbnRhaW5lcklkIDogbWUuY29udGFpbmVySWQsXG4gICAgICAgICAgICB3aW5kb3dJZCAgICA6IG1lLndpbmRvd0lkXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKExheW91dCk7XG4iLCJpbXBvcnQgQmFzZSAgICAgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8ubGF5b3V0LkNhcmRcbiAqIEBleHRlbmRzIE5lby5sYXlvdXQuQmFzZVxuICovXG5jbGFzcyBDYXJkIGV4dGVuZHMgQmFzZSB7XG4gICAgLypcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgQ1NTIGNsYXNzIGZvciBhbiBhY3RpdmUgaXRlbSBpbnNpZGUgdGhlIGNhcmQgbGF5b3V0XG4gICAgICogQG1lbWJlciB7U3RyaW5nfSBhY3RpdmVJdGVtQ2xzPSduZW8tYWN0aXZlLWl0ZW0nXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBhY3RpdmVJdGVtQ2xzID0gJ25lby1hY3RpdmUtaXRlbSdcbiAgICAvKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBDU1MgY2xhc3MgZm9yIGFuIGluYWN0aXZlIGl0ZW0gaW5zaWRlIHRoZSBjYXJkIGxheW91dFxuICAgICAqIEBtZW1iZXIge1N0cmluZ30gaW5hY3RpdmVJdGVtQ2xzPSduZW8taW5hY3RpdmUtaXRlbSdcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGluYWN0aXZlSXRlbUNscyA9ICduZW8taW5hY3RpdmUtaXRlbSdcbiAgICAvKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBDU1MgY2xhc3MgZm9yIGFuIGl0ZW0gaW5zaWRlIHRoZSBjYXJkIGxheW91dFxuICAgICAqIEBtZW1iZXIgaXRlbUNsc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgaXRlbUNscyA9ICduZW8tbGF5b3V0LWNhcmQtaXRlbSdcbiAgICAvKipcbiAgICAgKiBWYWxpZCB2YWx1ZXMgZm9yIHNsaWRlRGlyZWN0aW9uXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IGljb25Qb3NpdGlvbnM9Wydob3Jpem9udGFsJywndmVydGljYWwnLG51bGxdXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgc2xpZGVEaXJlY3Rpb25zID0gWydob3Jpem9udGFsJywgJ3ZlcnRpY2FsJywgbnVsbF1cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmxheW91dC5DYXJkJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ubGF5b3V0LkNhcmQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nbGF5b3V0LWNhcmQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnbGF5b3V0LWNhcmQnLFxuICAgICAgICAvKlxuICAgICAgICAgKiBUaGUgaXRlbSBpbmRleCBvZiB0aGUgY2FyZCwgd2hpY2ggaXMgY3VycmVudGx5IGFjdGl2ZS5cbiAgICAgICAgICogQ2hhbmdlIHRoaXMgdmFsdWUgdG8gYWN0aXZhdGUgYSBkaWZmZXJlbnQgY2FyZC5cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBhY3RpdmVJbmRleF89MFxuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZlSW5kZXhfOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGNvbnRhaW5lckNscz0nbmVvLWxheW91dC1jYXJkJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpbmVyQ2xzOiAnbmVvLWxheW91dC1jYXJkJyxcbiAgICAgICAgLypcbiAgICAgICAgICogUmVtb3ZlIHRoZSBET00gb2YgaW5hY3RpdmUgY2FyZHMuXG4gICAgICAgICAqIFRoaXMgd2lsbCBrZWVwIHRoZSBpbnN0YW5jZXMgJiB2ZG9tIHRyZWVzXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHJlbW92ZUluYWN0aXZlQ2FyZHM9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlSW5hY3RpdmVDYXJkczogdHJ1ZSxcbiAgICAgICAgLypcbiAgICAgICAgICogVmFsaWQgdmFsdWVzOiAnaG9yaXpvbnRhbCcsICd2ZXJ0aWNhbCcsIG51bGxcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IHNsaWRlRGlyZWN0aW9uXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBzbGlkZURpcmVjdGlvbl86IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb2RpZmllcyB0aGUgQ1NTIGNsYXNzZXMgb2YgdGhlIGNvbnRhaW5lciBpdGVtcyB0aGlzIGxheW91dCBpcyBib3VuZCB0by5cbiAgICAgKiBBdXRvbWF0aWNhbGx5IGdldHMgdHJpZ2dlcmVkIGFmdGVyIGNoYW5naW5nIHRoZSB2YWx1ZSBvZiBhY3RpdmVJbmRleC5cbiAgICAgKiBMYXp5IGxvYWRzIGl0ZW1zIHdoaWNoIHVzZSBhIG1vZHVsZSBjb25maWcgY29udGFpbmluZyBhIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBhZnRlclNldEFjdGl2ZUluZGV4KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjb250YWluZXIsIHJlbW92ZUluYWN0aXZlQ2FyZHN9ID0gbWUsXG4gICAgICAgICAgICBzQ2ZnICAgICAgICAgICAgPSBtZS5jb25zdHJ1Y3RvcixcbiAgICAgICAgICAgIG5lZWRzVHJhbnNpdGlvbiA9IG1lLnNsaWRlRGlyZWN0aW9uICYmIG9sZFZhbHVlICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgICBuZWVkc1VwZGF0ZSAgICAgPSBmYWxzZSxcbiAgICAgICAgICAgIGksIGlzQWN0aXZlSW5kZXgsIGl0ZW0sIGl0ZW1zLCBsZW4sIG1vZHVsZSwgd3JhcHBlckNscztcblxuICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKHZhbHVlKSAmJiBjb250YWluZXIpIHtcbiAgICAgICAgICAgIGl0ZW1zID0gY29udGFpbmVyLml0ZW1zO1xuICAgICAgICAgICAgbGVuICAgPSBpdGVtcy5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmICghaXRlbXNbdmFsdWVdKSB7XG4gICAgICAgICAgICAgICAgTmVvLmVycm9yKCdUcnlpbmcgdG8gYWN0aXZhdGUgYSBub24gZXhpc3RpbmcgY2FyZCcsIHZhbHVlLCBpdGVtcylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBydW4gdGhlIGxvb3AgdHdpY2UsIHNpbmNlIGxhenkgbG9hZGluZyBhIG1vZHVsZSBhdCBhIGhpZ2hlciBpbmRleCBkb2VzIGFmZmVjdCBsb3dlciBpbmRleGVzXG4gICAgICAgICAgICBmb3IgKGk9MDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlID0gaXRlbXNbaV0ubW9kdWxlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IHZhbHVlICYmIE5lby50eXBlT2YobW9kdWxlKSA9PT0gJ0Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBuZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGk9MDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaXNBY3RpdmVJbmRleCA9IGkgPT09IHZhbHVlO1xuICAgICAgICAgICAgICAgIGl0ZW0gICAgICAgICAgPSBpdGVtc1tpXTtcbiAgICAgICAgICAgICAgICBtb2R1bGUgICAgICAgID0gaXRlbS5tb2R1bGU7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNBY3RpdmVJbmRleCAmJiBOZW8udHlwZU9mKG1vZHVsZSkgPT09ICdGdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IGF3YWl0IG1lLmxvYWRNb2R1bGUoaXRlbSwgaSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIE5lby5jb21wb25lbnQuQmFzZSkge1xuICAgICAgICAgICAgICAgICAgICB3cmFwcGVyQ2xzID0gaXRlbS53cmFwcGVyQ2xzO1xuXG4gICAgICAgICAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZSh3cmFwcGVyQ2xzLCBpc0FjdGl2ZUluZGV4ID8gc0NmZy5pbmFjdGl2ZUl0ZW1DbHMgOiBzQ2ZnLmFjdGl2ZUl0ZW1DbHMpO1xuICAgICAgICAgICAgICAgICAgICBOZW9BcnJheS5hZGQoICAgd3JhcHBlckNscywgaXNBY3RpdmVJbmRleCA/IHNDZmcuYWN0aXZlSXRlbUNscyAgIDogc0NmZy5pbmFjdGl2ZUl0ZW1DbHMpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZW1vdmVJbmFjdGl2ZUNhcmRzIHx8IG5lZWRzVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNBY3RpdmVJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBpdGVtLnZkb20ucmVtb3ZlRG9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFuZWVkc1RyYW5zaXRpb24gJiYgaXRlbS5hY3RpdmF0ZT8uKClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVtb3ZlSW5hY3RpdmVDYXJkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ubW91bnRlZCAgICAgICAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnZkb20ucmVtb3ZlRG9tID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaXRlbS53cmFwcGVyQ2xzID0gd3JhcHBlckNsc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5lZWRzVHJhbnNpdGlvbikge1xuICAgICAgICAgICAgICAgIGF3YWl0IG1lLnNsaWRlQ2FyZHModmFsdWUsIG9sZFZhbHVlKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChyZW1vdmVJbmFjdGl2ZUNhcmRzIHx8IG5lZWRzVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnVwZGF0ZURlcHRoID0gLTE7IC8vIGluY2x1ZGUgdGhlIGZ1bGwgdHJlZSB0byBob25vciBuZXcgb3IgY2hhbmdlZCBpbmFjdGl2ZSBjYXJkc1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci51cGRhdGUoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGx5IHNldHMgdGhlIENTUyBjbGFzc2VzIG9mIHRoZSBjb250YWluZXIgaXRlbXMgdGhpcyBsYXlvdXQgaXMgYm91bmQgdG8uXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGl0ZW1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtrZWVwSW5Eb209ZmFsc2VdXG4gICAgICovXG4gICAgYXBwbHlDaGlsZEF0dHJpYnV0ZXMoaXRlbSwgaW5kZXgsIGtlZXBJbkRvbT1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpc0FjdGl2ZUluZGV4ID0gbWUuYWN0aXZlSW5kZXggPT09IGluZGV4LFxuICAgICAgICAgICAgc0NmZyAgICAgICAgICA9IG1lLmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgY2hpbGRDbHMgICAgICA9IGl0ZW0ud3JhcHBlckNscyB8fCBbXSxcbiAgICAgICAgICAgIHt2ZG9tfSAgICAgICAgPSBpdGVtO1xuXG4gICAgICAgIE5lb0FycmF5LmFkZChjaGlsZENscywgc0NmZy5pdGVtQ2xzKTtcbiAgICAgICAgTmVvQXJyYXkuYWRkKGNoaWxkQ2xzLCBpc0FjdGl2ZUluZGV4ID8gc0NmZy5hY3RpdmVJdGVtQ2xzIDogc0NmZy5pbmFjdGl2ZUl0ZW1DbHMpO1xuXG4gICAgICAgIGlmICgha2VlcEluRG9tICYmIG1lLnJlbW92ZUluYWN0aXZlQ2FyZHMpIHtcbiAgICAgICAgICAgIHZkb20ucmVtb3ZlRG9tICA9ICFpc0FjdGl2ZUluZGV4O1xuICAgICAgICAgICAgaXRlbS53cmFwcGVyQ2xzID0gY2hpbGRDbHM7XG4gICAgICAgICAgICBpdGVtLnVwZGF0ZT8uKCkgLy8gY2FuIGdldCBjYWxsZWQgZm9yIGFuIGl0ZW0gY29uZmlnXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVtLndyYXBwZXJDbHMgPSBjaGlsZENsc1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgc2xpZGVEaXJlY3Rpb24gY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFNsaWRlRGlyZWN0aW9uKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnc2xpZGVEaXJlY3Rpb24nKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWRzIGEgY29tcG9uZW50LkJhc2UgbW9kdWxlIHdoaWNoIGlzIGRlZmluZWQgdmlhIG1vZHVsZTogKCkgPT4gaW1wb3J0KCcuLi4nKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtpbmRleF1cbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxvYWRNb2R1bGUoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjb250YWluZXJ9ID0gbWUsXG4gICAgICAgICAgICBpdGVtcyAgICAgICA9IGNvbnRhaW5lci5pdGVtcyxcbiAgICAgICAgICAgIHttb2R1bGV9ICAgID0gaXRlbSxcbiAgICAgICAgICAgIHByb3RvO1xuXG4gICAgICAgIGlmICghTmVvLmlzTnVtYmVyKGluZGV4KSkge1xuICAgICAgICAgICAgaW5kZXggPSBpdGVtcy5pbmRleE9mKGl0ZW0pXG4gICAgICAgIH1cblxuICAgICAgICBpdGVtLmlzTG9hZGluZyA9IHRydWU7IC8vIHByZXZlbnQgdGhlIGl0ZW0gZnJvbSBnZXR0aW5nIHF1ZXVlZCBtdWx0aXBsZSB0aW1lcyBpbnNpZGUgZm9ybS5Db250YWluZXJcblxuICAgICAgICBtb2R1bGUgPSBhd2FpdCBtb2R1bGUoKTtcbiAgICAgICAgbW9kdWxlID0gbW9kdWxlLmRlZmF1bHQ7XG4gICAgICAgIHByb3RvICA9IG1vZHVsZS5wcm90b3R5cGU7XG5cbiAgICAgICAgaXRlbS5jbGFzc05hbWUgPSBwcm90by5jbGFzc05hbWU7XG4gICAgICAgIGl0ZW0ubW9kdWxlICAgID0gbW9kdWxlO1xuXG4gICAgICAgIGRlbGV0ZSBpdGVtLmlzTG9hZGluZztcbiAgICAgICAgZGVsZXRlIGl0ZW0udmRvbTtcblxuICAgICAgICBpdGVtc1tpbmRleF0gPSBpdGVtID0gTmVvLmNyZWF0ZShpdGVtKTtcblxuICAgICAgICBtZS5hcHBseUNoaWxkQXR0cmlidXRlcyhpdGVtLCBpbmRleCk7XG5cbiAgICAgICAgY29udGFpbmVyLmdldFZkb21JdGVtc1Jvb3QoKS5jbltpbmRleF0gPSBpdGVtLmNyZWF0ZVZkb21SZWZlcmVuY2UoKTtcblxuICAgICAgICBjb250YWluZXIuZmlyZSgnY2FyZExvYWRlZCcsIHtpdGVtfSk7XG5cbiAgICAgICAgcmV0dXJuIGl0ZW1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkSW5kZXhcbiAgICAgKi9cbiAgICBhc3luYyBzbGlkZUNhcmRzKGluZGV4LCBvbGRJbmRleCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y29udGFpbmVyfSAgID0gbWUsXG4gICAgICAgICAgICBzbGlkZVZlcnRpY2FsID0gbWUuc2xpZGVEaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcsXG4gICAgICAgICAgICB7aXRlbXMsIHZkb219ID0gY29udGFpbmVyLFxuICAgICAgICAgICAgY2FyZCAgICAgICAgICA9IGl0ZW1zW2luZGV4XSxcbiAgICAgICAgICAgIG9sZENhcmQgICAgICAgPSBpdGVtc1tvbGRJbmRleF0sXG4gICAgICAgICAgICBzbGlkZUluICAgICAgID0gaW5kZXggPiBvbGRJbmRleCxcbiAgICAgICAgICAgIHJlY3QgICAgICAgICAgPSBhd2FpdCBjb250YWluZXIuZ2V0RG9tUmVjdChjb250YWluZXIuaWQpLFxuICAgICAgICAgICAgYW5pbWF0aW9uV3JhcHBlciwgc3R5bGUsIHgsIHk7XG5cbiAgICAgICAgZGVsZXRlIG9sZENhcmQudmRvbS5yZW1vdmVEb207XG5cbiAgICAgICAgaWYgKHNsaWRlVmVydGljYWwpIHtcbiAgICAgICAgICAgIHkgPSBzbGlkZUluID8gMCA6IC1yZWN0LmhlaWdodDtcblxuICAgICAgICAgICAgc3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgICAgICAgICAgICAgaGVpZ2h0ICAgICAgIDogYCR7MiAqIHJlY3QuaGVpZ2h0fXB4YCxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0gICAgOiBgdHJhbnNsYXRlWSgke3l9cHgpYCxcbiAgICAgICAgICAgICAgICB3aWR0aCAgICAgICAgOiBgJHtyZWN0LndpZHRofXB4YFxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeCA9IHNsaWRlSW4gPyAwIDogLXJlY3Qud2lkdGg7XG5cbiAgICAgICAgICAgIHN0eWxlID0ge1xuICAgICAgICAgICAgICAgIGhlaWdodCAgIDogYCR7cmVjdC5oZWlnaHR9cHhgLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoJHt4fXB4KWAsXG4gICAgICAgICAgICAgICAgd2lkdGggICAgOiBgJHsyICogcmVjdC53aWR0aH1weGBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZkb20uY24gPSBbXG4gICAgICAgICAgICB7Y2xzOiBbJ25lby1yZWxhdGl2ZSddLCBjbjogW1xuICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLWFuaW1hdGlvbi13cmFwcGVyJ10sIHN0eWxlLCBjbjogW2NhcmQuY3JlYXRlVmRvbVJlZmVyZW5jZSgpXX1cbiAgICAgICAgICAgIF19XG4gICAgICAgIF07XG5cbiAgICAgICAgYW5pbWF0aW9uV3JhcHBlciA9IHZkb20uY25bMF0uY25bMF07XG5cbiAgICAgICAgYW5pbWF0aW9uV3JhcHBlci5jbltzbGlkZUluID8gJ3Vuc2hpZnQnIDogJ3B1c2gnXShvbGRDYXJkLmNyZWF0ZVZkb21SZWZlcmVuY2UoKSk7XG5cbiAgICAgICAgY29udGFpbmVyLnVwZGF0ZURlcHRoID0gLTE7XG5cbiAgICAgICAgYXdhaXQgY29udGFpbmVyLnByb21pc2VVcGRhdGUoKTtcblxuICAgICAgICBhbmltYXRpb25XcmFwcGVyLnN0eWxlLnRyYW5zZm9ybSA9IHNsaWRlVmVydGljYWwgP1xuICAgICAgICAgICAgYHRyYW5zbGF0ZVkoJHtzbGlkZUluID8gLXJlY3QuaGVpZ2h0IDogMH1weClgIDpcbiAgICAgICAgICAgIGB0cmFuc2xhdGVYKCR7c2xpZGVJbiA/IC1yZWN0LndpZHRoICA6IDB9cHgpYDtcblxuICAgICAgICBhd2FpdCBjb250YWluZXIucHJvbWlzZVVwZGF0ZSgpO1xuXG4gICAgICAgIGF3YWl0IG1lLnRpbWVvdXQoMzAwKTsgLy8gdHJhbnNpdGlvbiBkdXJhdGlvbiBkZWZpbmVkIHZpYSBDU1MgZm9yIG5vd1xuXG4gICAgICAgIHZkb20uY24gPSBbXTtcblxuICAgICAgICBjb250YWluZXIuaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIHZkb20uY24ucHVzaChpdGVtLmNyZWF0ZVZkb21SZWZlcmVuY2UoKSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb2xkQ2FyZC52ZG9tLnJlbW92ZURvbSA9IHRydWU7XG5cbiAgICAgICAgY29udGFpbmVyLnVwZGF0ZURlcHRoID0gLTE7XG5cbiAgICAgICAgYXdhaXQgY29udGFpbmVyLnByb21pc2VVcGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIGluc3RhbmNlIGludG8gYSBKU09OLWNvbXBhdGlibGUgb2JqZWN0IGZvciB0aGUgTmV1cmFsIExpbmsuXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLnRvSlNPTigpLFxuICAgICAgICAgICAgYWN0aXZlSW5kZXggICAgICAgIDogbWUuYWN0aXZlSW5kZXgsXG4gICAgICAgICAgICBjb250YWluZXJDbHMgICAgICAgOiBtZS5jb250YWluZXJDbHMsXG4gICAgICAgICAgICByZW1vdmVJbmFjdGl2ZUNhcmRzOiBtZS5yZW1vdmVJbmFjdGl2ZUNhcmRzLFxuICAgICAgICAgICAgc2xpZGVEaXJlY3Rpb24gICAgIDogbWUuc2xpZGVEaXJlY3Rpb25cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ2FyZCk7XG4iLCJpbXBvcnQgQmFzZSAgICAgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8ubGF5b3V0LkZpdFxuICogQGV4dGVuZHMgTmVvLmxheW91dC5CYXNlXG4gKi9cbmNsYXNzIEZpdCBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmxheW91dC5GaXQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5sYXlvdXQuRml0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2xheW91dC1maXQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnbGF5b3V0LWZpdCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gY29udGFpbmVyQ2xzPSduZW8tbGF5b3V0LWZpdCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGNvbnRhaW5lckNsczogJ25lby1sYXlvdXQtZml0J1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxseSBzZXRzIHRoZSBDU1MgY2xhc3NlcyBvZiB0aGUgY29udGFpbmVyIGl0ZW1zIHRoaXMgbGF5b3V0IGlzIGJvdW5kIHRvLlxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBpdGVtXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICovXG4gICAgYXBwbHlDaGlsZEF0dHJpYnV0ZXMoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgaWYgKCFpdGVtLmlnbm9yZUxheW91dCkge1xuICAgICAgICAgICAgaXRlbS53cmFwcGVyQ2xzID0gTmVvQXJyYXkudW5pb24oaXRlbS53cmFwcGVyQ2xzLCAnbmVvLWxheW91dC1maXQtaXRlbScpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBDU1MgcnVsZXMgZnJvbSBhIGNvbnRhaW5lciBpdGVtIHRoaXMgbGF5b3V0IGlzIGJvdW5kIHRvLlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gc3dpdGNoaW5nIHRvIGEgZGlmZmVyZW50IGxheW91dC5cbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gaXRlbVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqL1xuICAgIHJlbW92ZUNoaWxkQXR0cmlidXRlcyhpdGVtLCBpbmRleCkge1xuICAgICAgICBpZiAoIWl0ZW0uaWdub3JlTGF5b3V0KSB7XG4gICAgICAgICAgICBsZXQge3dyYXBwZXJDbHN9ID0gaXRlbTtcblxuICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKHdyYXBwZXJDbHMsICduZW8tbGF5b3V0LWZpdC1pdGVtJyk7XG4gICAgICAgICAgICBpdGVtLndyYXBwZXJDbHMgPSB3cmFwcGVyQ2xzXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEZpdCk7XG4iLCJpbXBvcnQgQmFzZSAgICAgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8ubGF5b3V0LkZsZXhib3hcbiAqIEBleHRlbmRzIE5lby5sYXlvdXQuQmFzZVxuICovXG5jbGFzcyBGbGV4Ym94IGV4dGVuZHMgQmFzZSB7XG4gICAgLyoqXG4gICAgICogVmFsaWQgdmFsdWVzIGZvciBhbGlnblxuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBhbGlnblZhbHVlcz1bJ2NlbnRlcicsJ2VuZCcsJ3N0YXJ0Jywnc3RyZXRjaCcsbnVsbF1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBhbGlnblZhbHVlcyA9IFsnY2VudGVyJywgJ2VuZCcsICdzdGFydCcsICdzdHJldGNoJywgbnVsbF1cbiAgICAvKipcbiAgICAgKiBWYWxpZCB2YWx1ZXMgZm9yIGRpcmVjdGlvblxuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBkaXJlY3Rpb25WYWx1ZXM9Wydjb2x1bW4nLCdjb2x1bW4tcmV2ZXJzZScsJ3JvdycsJ3Jvdy1yZXZlcnNlJyxudWxsXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGRpcmVjdGlvblZhbHVlcyA9IFsnY29sdW1uJywgJ2NvbHVtbi1yZXZlcnNlJywgJ3JvdycsICdyb3ctcmV2ZXJzZScsIG51bGxdXG4gICAgLyoqXG4gICAgICogVmFsaWQgdmFsdWVzIGZvciBwYWNrXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IHBhY2tWYWx1ZXM9WydjZW50ZXInLCdlbmQnLCdzdGFydCcsbnVsbF1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBwYWNrVmFsdWVzID0gWydjZW50ZXInLCAnZW5kJywgJ3N0YXJ0JywgbnVsbF1cbiAgICAvKipcbiAgICAgKiBWYWxpZCB2YWx1ZXMgZm9yIHdyYXBcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gd3JhcFZhbHVlcz1bJ25vd3JhcCcsJ3dyYXAnLCd3cmFwLXJldmVyc2UnXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIHdyYXBWYWx1ZXMgPSBbJ25vd3JhcCcsICd3cmFwJywgJ3dyYXAtcmV2ZXJzZSddXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5sYXlvdXQuRmxleGJveCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmxheW91dC5GbGV4Ym94JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2xheW91dC1mbGV4Ym94J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2xheW91dC1mbGV4Ym94JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhbGlkIHZhbHVlczogJ2NlbnRlcicsICdlbmQnLCAnc3RhcnQnLCAnc3RyZXRjaCcsIG51bGxcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGFsaWduXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgYWxpZ25fOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWQgdmFsdWVzOiAnY29sdW1uJywgJ2NvbHVtbi1yZXZlcnNlJywgJ3JvdycsICdyb3ctcmV2ZXJzZScsIG51bGxcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGRpcmVjdGlvbl89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGRpcmVjdGlvbl86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBmbGV4IGNzcyBhbGxvd3MgZ2FwLiBUaGlzIGFkZHMgaXQgdG8gdGhlIGNvbXBvbmVudCBzdHlsZVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGdhcF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGdhcF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWxpZCB2YWx1ZXM6ICdjZW50ZXInLCAnZW5kJywgJ3N0YXJ0JywgbnVsbFxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gcGFja189bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHBhY2tfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQ1NTIGNsYXNzTmFtZSBwcmVmaXhcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBwcmVmaXg9J25lby1mbGV4LSdcbiAgICAgICAgICovXG4gICAgICAgIHByZWZpeDogJ25lby1mbGV4LScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWxpZCB2YWx1ZXM6IG5vd3JhcCwgd3JhcCwgd3JhcHJldmVyc2VcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB3cmFwXz0nbm93cmFwJ1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHdyYXBfOiAnbm93cmFwJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIENvbnRhaW5lciBDU1MgY2xzIGFmdGVyIFwiYWxpZ25cIiBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0QWxpZ24odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlICYmIHRoaXMudXBkYXRlSW5wdXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICdhbGlnbicpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgQ29udGFpbmVyIENTUyBjbHMgYWZ0ZXIgXCJkaXJlY3Rpb25cIiBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RGlyZWN0aW9uKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZSAmJiB0aGlzLnVwZGF0ZUlucHV0VmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnZGlyZWN0aW9uJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBDb250YWluZXIgc3R5bGUgdG8gYWRkIGEgZ2FwIHRvIGRpc3BsYXk6ZmxleFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRHYXAodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUgJiYgIW9sZFZhbHVlKSByZXR1cm47XG5cbiAgICAgICAgbGV0IHtjb250YWluZXJ9ICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt3cmFwcGVyU3R5bGV9ID0gY29udGFpbmVyO1xuXG4gICAgICAgIHdyYXBwZXJTdHlsZS5nYXAgPSB2YWx1ZTtcblxuICAgICAgICBjb250YWluZXIud3JhcHBlclN0eWxlID0gd3JhcHBlclN0eWxlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgQ29udGFpbmVyIENTUyBjbHMgYWZ0ZXIgXCJwYWNrXCIgZ2V0cyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFBhY2sodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlICYmIHRoaXMudXBkYXRlSW5wdXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICdwYWNrJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBDb250YWluZXIgQ1NTIGNscyBhZnRlciBcIndyYXBcIiBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRXcmFwKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZSAmJiB0aGlzLnVwZGF0ZUlucHV0VmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnd3JhcCcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGUgZmxleCB2YWx1ZSB0byBhbiBpdGVtIG9mIHRoZSBjb250YWluZXIgdGhpcyBsYXlvdXQgaXMgYm91bmQgdG9cbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gaXRlbVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqL1xuICAgIGFwcGx5Q2hpbGRBdHRyaWJ1dGVzKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIGlmICghaXRlbS53cmFwcGVyU3R5bGUpIHJldHVybjtcblxuICAgICAgICBsZXQgc3R5bGUgPSBpdGVtLndyYXBwZXJTdHlsZSxcbiAgICAgICAgICAgIGZsZXggID0gc3R5bGUuZmxleCB8fCBpdGVtLmZsZXggfHwgKHRoaXMuYWxpZ24gPT09ICdzdHJldGNoJyA/IDEgOiAnMCAxIGF1dG8nKTtcblxuICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKGZsZXgpKSB7XG4gICAgICAgICAgICBmbGV4ID0gYCR7ZmxleH0gMSAwJWBcbiAgICAgICAgfVxuXG4gICAgICAgIHN0eWxlLmZsZXggPSBmbGV4O1xuICAgICAgICBpdGVtLndyYXBwZXJTdHlsZSA9IHN0eWxlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBDU1MgY2xhc3NlcyB0byB0aGUgY29udGFpbmVyIHRoaXMgbGF5b3V0IGlzIGJvdW5kIHRvXG4gICAgICovXG4gICAgYXBwbHlSZW5kZXJBdHRyaWJ1dGVzKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y29udGFpbmVyLCBwcmVmaXh9ID0gbWUsXG4gICAgICAgICAgICB7d3JhcHBlckNsc30gICAgICAgID0gY29udGFpbmVyO1xuXG4gICAgICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgICAgICBOZW8ubG9nRXJyb3IoJ2xheW91dC5GbGV4Ym94OiBhcHBseVJlbmRlckF0dHJpYnV0ZXMgLT4gY29udGFpbmVyIG5vdCB5ZXQgY3JlYXRlZCcsIG1lLmNvbnRhaW5lcklkKVxuICAgICAgICB9XG5cbiAgICAgICAgTmVvQXJyYXkuYWRkKHdyYXBwZXJDbHMsIHByZWZpeCArICdjb250YWluZXInKTtcblxuICAgICAgICBtZS5hbGlnbiAgICAgJiYgTmVvQXJyYXkuYWRkKHdyYXBwZXJDbHMsIHByZWZpeCArICdhbGlnbi0nICAgICArIG1lLmFsaWduKTtcbiAgICAgICAgbWUuZGlyZWN0aW9uICYmIE5lb0FycmF5LmFkZCh3cmFwcGVyQ2xzLCBwcmVmaXggKyAnZGlyZWN0aW9uLScgKyBtZS5kaXJlY3Rpb24pO1xuICAgICAgICBtZS5wYWNrICAgICAgJiYgTmVvQXJyYXkuYWRkKHdyYXBwZXJDbHMsIHByZWZpeCArICdwYWNrLScgICAgICArIG1lLnBhY2spO1xuICAgICAgICBtZS53cmFwICAgICAgJiYgTmVvQXJyYXkuYWRkKHdyYXBwZXJDbHMsIHByZWZpeCArICd3cmFwLScgICAgICArIG1lLndyYXApO1xuXG4gICAgICAgIGNvbnRhaW5lci53cmFwcGVyQ2xzID0gd3JhcHBlckNsc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgbmV3IHZhbHVlIGZvciBcImFsaWduXCIgaXMgdmFsaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRBbGlnbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGVzdElucHV0VmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnYWxpZ25WYWx1ZXMnLCAnYWxpZ24nKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgbmV3IHZhbHVlIGZvciBcImRpcmVjdGlvblwiIGlzIHZhbGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICovXG4gICAgYmVmb3JlU2V0RGlyZWN0aW9uKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXN0SW5wdXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICdkaXJlY3Rpb25WYWx1ZXMnLCAnZGlyZWN0aW9uJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIG5ldyB2YWx1ZSBmb3IgXCJwYWNrXCIgaXMgdmFsaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRQYWNrKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXN0SW5wdXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICdwYWNrVmFsdWVzJywgJ3BhY2snKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgbmV3IHZhbHVlIGZvciBcIndyYXBcIiBpcyB2YWxpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIGJlZm9yZVNldFdyYXAodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRlc3RJbnB1dFZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ3dyYXBWYWx1ZXMnLCAnd3JhcCcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgQ1NTIHJ1bGVzIGZyb20gYSBjb250YWluZXIgaXRlbSB0aGlzIGxheW91dCBpcyBib3VuZCB0by5cbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHN3aXRjaGluZyB0byBhIGRpZmZlcmVudCBsYXlvdXQuXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGl0ZW1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcmVtb3ZlQ2hpbGRBdHRyaWJ1dGVzKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIGxldCBzdHlsZSA9IGl0ZW0ud3JhcHBlclN0eWxlIHx8IHt9O1xuXG4gICAgICAgIHN0eWxlLmZsZXggPSBpdGVtLmZsZXggfHwgbnVsbDtcbiAgICAgICAgaXRlbS53cmFwcGVyU3R5bGUgPSBzdHlsZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIENTUyBydWxlcyBmcm9tIHRoZSBjb250YWluZXIgdGhpcyBsYXlvdXQgaXMgYm91bmQgdG8uXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiBzd2l0Y2hpbmcgdG8gYSBkaWZmZXJlbnQgbGF5b3V0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICByZW1vdmVSZW5kZXJBdHRyaWJ1dGVzKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y29udGFpbmVyLCBwcmVmaXh9ID0gbWUsXG4gICAgICAgICAgICB7d3JhcHBlckNsc30gICAgICAgID0gY29udGFpbmVyO1xuXG4gICAgICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgICAgICBOZW8ubG9nRXJyb3IoJ2xheW91dC5GbGV4Ym94OiByZW1vdmVSZW5kZXJBdHRyaWJ1dGVzIC0+IGNvbnRhaW5lciBub3QgeWV0IGNyZWF0ZWQnLCBtZS5jb250YWluZXJJZClcbiAgICAgICAgfVxuXG4gICAgICAgIE5lb0FycmF5LnJlbW92ZSh3cmFwcGVyQ2xzLCBwcmVmaXggKyAnY29udGFpbmVyJyk7XG5cbiAgICAgICAgbWUuYWxpZ24gICAgICYmIE5lb0FycmF5LnJlbW92ZSh3cmFwcGVyQ2xzLCBwcmVmaXggKyAnYWxpZ24tJyAgICAgKyBtZS5hbGlnbik7XG4gICAgICAgIG1lLmRpcmVjdGlvbiAmJiBOZW9BcnJheS5yZW1vdmUod3JhcHBlckNscywgcHJlZml4ICsgJ2RpcmVjdGlvbi0nICsgbWUuZGlyZWN0aW9uKTtcbiAgICAgICAgbWUucGFjayAgICAgICYmIE5lb0FycmF5LnJlbW92ZSh3cmFwcGVyQ2xzLCBwcmVmaXggKyAncGFjay0nICAgICAgKyBtZS5wYWNrKTtcbiAgICAgICAgbWUud3JhcCAgICAgICYmIE5lb0FycmF5LnJlbW92ZSh3cmFwcGVyQ2xzLCBwcmVmaXggKyAnd3JhcC0nICAgICAgKyBtZS53cmFwKTtcblxuICAgICAgICBjb250YWluZXIud3JhcHBlckNscyA9IHdyYXBwZXJDbHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIG5ldyB2YWx1ZSBmb3IgcHJvcGVydHlOYW1lIGlzIHZhbGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWxpZFZhbHVlc05hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlOYW1lXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKi9cbiAgICB0ZXN0SW5wdXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsIHZhbGlkVmFsdWVzTmFtZSwgcHJvcGVydHlOYW1lKSB7XG4gICAgICAgIGxldCB2YWxpZFZhbHVlcyA9IHRoaXMuZ2V0U3RhdGljQ29uZmlnKHZhbGlkVmFsdWVzTmFtZSk7XG5cbiAgICAgICAgaWYgKCFOZW9BcnJheS5oYXNJdGVtKHZhbGlkVmFsdWVzLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIE5lby5sb2dFcnJvcih0aGlzLmNvbnRhaW5lcklkLCAnLT4gbGF5b3V0OiBzdXBwb3J0ZWQgdmFsdWVzIGZvciBcIicgKyBwcm9wZXJ0eU5hbWUgKyAnXCIgYXJlJyAsIHZhbGlkVmFsdWVzKTtcbiAgICAgICAgICAgIHJldHVybiBvbGRWYWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIGluc3RhbmNlIGludG8gYSBKU09OLWNvbXBhdGlibGUgb2JqZWN0IGZvciB0aGUgTmV1cmFsIExpbmsuXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLnRvSlNPTigpLFxuICAgICAgICAgICAgYWxpZ24gICAgOiBtZS5hbGlnbixcbiAgICAgICAgICAgIGRpcmVjdGlvbjogbWUuZGlyZWN0aW9uLFxuICAgICAgICAgICAgZ2FwICAgICAgOiBtZS5nYXAsXG4gICAgICAgICAgICBwYWNrICAgICA6IG1lLnBhY2ssXG4gICAgICAgICAgICBwcmVmaXggICA6IG1lLnByZWZpeCxcbiAgICAgICAgICAgIHdyYXAgICAgIDogbWUud3JhcFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgQ29udGFpbmVyIENTUyB3cmFwcGVyQ2xzXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eU5hbWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdXBkYXRlSW5wdXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsIHByb3BlcnR5TmFtZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y29udGFpbmVyLCBwcmVmaXh9ID0gbWUsXG4gICAgICAgICAgICB7d3JhcHBlckNsc30gICAgICAgID0gY29udGFpbmVyO1xuXG4gICAgICAgIGlmIChjb250YWluZXI/LnZub2RlSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZSh3cmFwcGVyQ2xzLCBwcmVmaXggKyBwcm9wZXJ0eU5hbWUgKyAnLScgKyBvbGRWYWx1ZSk7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIE5lb0FycmF5LmFkZCh3cmFwcGVyQ2xzLCBwcmVmaXggKyBwcm9wZXJ0eU5hbWUgKyAnLScgKyB2YWx1ZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGFpbmVyLndyYXBwZXJDbHMgPSB3cmFwcGVyQ2xzXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEZsZXhib3gpO1xuIiwiaW1wb3J0IEJhc2UgICAgIGZyb20gJy4vQmFzZS5tanMnO1xuaW1wb3J0IE5lb0FycmF5IGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmxheW91dC5HcmlkXG4gKiBAZXh0ZW5kcyBOZW8ubGF5b3V0LkJhc2VcbiAqL1xuY2xhc3MgR3JpZCBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmxheW91dC5HcmlkJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ubGF5b3V0LkdyaWQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nbGF5b3V0LWhib3gnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnbGF5b3V0LWdyaWQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGNvbnRhaW5lckNscz0nbmVvLWxheW91dC1maXQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluZXJDbHM6ICduZW8tbGF5b3V0LWdyaWQnXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhHcmlkKTtcbiIsImltcG9ydCBGbGV4Ym94IGZyb20gJy4vRmxleGJveC5tanMnO1xuXG4vKipcbiAqIFRoZSBIQm94IGxheW91dCBhbGxvd3MgeW91IHRvIGFycmFuZ2UgY29tcG9uZW50cyBob3Jpem9udGFsbHkgaW4gYSBjb250YWluZXIuXG4gKiBAY2xhc3MgTmVvLmxheW91dC5IQm94XG4gKiBAZXh0ZW5kcyBOZW8ubGF5b3V0LkZsZXhib3hcbiAqL1xuY2xhc3MgSEJveCBleHRlbmRzIEZsZXhib3gge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmxheW91dC5IQm94J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ubGF5b3V0LkhCb3gnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nbGF5b3V0LWhib3gnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnbGF5b3V0LWhib3gnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBkaXJlY3Rpb249J3JvdydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGRpcmVjdGlvbjogJ3JvdydcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoZSBmbGV4IHZhbHVlIHRvIGFuIGl0ZW0gb2YgdGhlIGNvbnRhaW5lciB0aGlzIGxheW91dCBpcyBib3VuZCB0b1xuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBpdGVtXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICovXG4gICAgYXBwbHlDaGlsZEF0dHJpYnV0ZXMoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgLy8gRG8gbm90IGFwcGx5IGZsZXggaWYgZml4ZWQgd2lkdGhcbiAgICAgICAgIWl0ZW0ud2lkdGggJiYgc3VwZXIuYXBwbHlDaGlsZEF0dHJpYnV0ZXMoaXRlbSwgaW5kZXgpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhIQm94KTtcbiIsImltcG9ydCBGbGV4Ym94IGZyb20gJy4vRmxleGJveC5tanMnO1xuXG4vKipcbiAqIFRoZSBWQm94IGxheW91dCBhbGxvd3MgeW91IHRvIGFycmFuZ2UgY29tcG9uZW50cyB2ZXJ0aWNhbGx5IGluIGEgY29udGFpbmVyLlxuICogQGNsYXNzIE5lby5sYXlvdXQuVkJveFxuICogQGV4dGVuZHMgTmVvLmxheW91dC5GbGV4Ym94XG4gKi9cbmNsYXNzIFZCb3ggZXh0ZW5kcyBGbGV4Ym94IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5sYXlvdXQuVkJveCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmxheW91dC5WQm94JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2xheW91dC12Ym94J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2xheW91dC12Ym94JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gZGlyZWN0aW9uPSdjb2x1bW4nXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBkaXJlY3Rpb246ICdjb2x1bW4nXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGUgZmxleCB2YWx1ZSB0byBhbiBpdGVtIG9mIHRoZSBjb250YWluZXIgdGhpcyBsYXlvdXQgaXMgYm91bmQgdG9cbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gaXRlbVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqL1xuICAgIGFwcGx5Q2hpbGRBdHRyaWJ1dGVzKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIC8vIERvIG5vdCBhcHBseSBmbGV4IGlmIGZpeGVkIGhlaWdodFxuICAgICAgICAhaXRlbS5oZWlnaHQgJiYgc3VwZXIuYXBwbHlDaGlsZEF0dHJpYnV0ZXMoaXRlbSwgaW5kZXgpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhWQm94KTtcbiIsImltcG9ydCBNYW5hZ2VyICAgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQgVkRvbVV0aWwgIGZyb20gJy4uL3V0aWwvVkRvbS5tanMnO1xuaW1wb3J0IFZOb2RlVXRpbCBmcm9tICcuLi91dGlsL1ZOb2RlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5tYW5hZ2VyLkNvbXBvbmVudFxuICogQGV4dGVuZHMgTmVvLm1hbmFnZXIuQmFzZVxuICogQHNpbmdsZXRvblxuICovXG5jbGFzcyBDb21wb25lbnQgZXh0ZW5kcyBNYW5hZ2VyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5tYW5hZ2VyLkNvbXBvbmVudCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLm1hbmFnZXIuQ29tcG9uZW50JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZXRvbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZXRvbjogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgcmV2ZXJzZSBtYXAgdG8gdHJhY2sgZGlyZWN0IGNoaWxkcmVuIGZvciBlYWNoIGNvbXBvbmVudC5cbiAgICAgKiBLZXlzIGFyZSBwYXJlbnQgY29tcG9uZW50IElEcywgdmFsdWVzIGFyZSBTZXRzIG9mIGNoaWxkIGNvbXBvbmVudCBJRHMuXG4gICAgICogVGhpcyBlbmFibGVzIE8oMSkgcmV0cmlldmFsIG9mIGRpcmVjdCBjaGlsZHJlbiwgb3B0aW1pemluZyBWRE9NIHN5bmNpbmcgYW5kIGRlc3RydWN0aW9uIGxvZ2ljLlxuICAgICAqIEBtZW1iZXIge01hcDxTdHJpbmcsIFNldDxTdHJpbmc+Pn0gY2hpbGRNYXA9bmV3IE1hcCgpXG4gICAgICovXG4gICAgY2hpbGRNYXAgPSBuZXcgTWFwKClcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge01hcH0gd3JhcHBlck5vZGVzPW5ldyBNYXAoKVxuICAgICAqL1xuICAgIHdyYXBwZXJOb2RlcyA9IG5ldyBNYXAoKVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBOZW8uZmlyc3QgICAgICAgID0gbWUuZ2V0Rmlyc3QuYmluZChtZSk7IC8vIGFsaWFzXG4gICAgICAgIE5lby5nZXRDb21wb25lbnQgPSBtZS5nZXQgICAgIC5iaW5kKG1lKSAgLy8gYWxpYXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGbGF0dGVucyBhIGdpdmVuIHZub2RlIHRyZWUgYnkgcmVwbGFjaW5nIGNvbXBvbmVudCBiYXNlZCBzdWJ0cmVlcyB3aXRoIGNvbXBvbmVudElkIGJhc2VkIHJlZmVyZW5jZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdm5vZGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3duZXJJZCBXZSBkbyBub3Qgd2FudCB0byByZXBsYWNlIHRoZSBvd24gaWQgPT4gd3JhcHBlZCBpdGVtc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgYWRkVm5vZGVDb21wb25lbnRSZWZlcmVuY2VzKHZub2RlLCBvd25lcklkKSB7XG4gICAgICAgIHZub2RlID0gey4uLnZub2RlfTsgLy8gc2hhbGxvdyBjb3B5XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY2hpbGROb2RlcyA9IHZub2RlPy5jaGlsZE5vZGVzID8gWy4uLnZub2RlLmNoaWxkTm9kZXNdIDogW10sXG4gICAgICAgICAgICBjaGlsZE5vZGVJZCwgY29tcG9uZW50LCBjb21wb25lbnRJZCwgcGFyZW50UmVmLCByZWZlcmVuY2VOb2RlO1xuXG4gICAgICAgIHZub2RlLmNoaWxkTm9kZXMgPSBjaGlsZE5vZGVzO1xuXG4gICAgICAgIGNoaWxkTm9kZXMuZm9yRWFjaCgoY2hpbGROb2RlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY2hpbGROb2RlSWQgPSBjaGlsZE5vZGUuaWQ7XG5cbiAgICAgICAgICAgIGlmICghY2hpbGROb2RlLmNvbXBvbmVudElkICYmIGNoaWxkTm9kZUlkICE9PSBvd25lcklkKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50ID0gbWUuZ2V0KGNoaWxkTm9kZUlkKTtcblxuICAgICAgICAgICAgICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNlYXJjaGluZyBmb3Igd3JhcHBlZCBjb21wb25lbnRzIGFzIGEgZmFsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50ID0gbWUud3JhcHBlck5vZGVzLmdldChjaGlsZE5vZGVJZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBwYXJlbnQgY29tcG9uZW50IHJlZmVyZW5jZSA9PiBhc3NpZ24gdGhlIHdyYXBwZXIgaWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudElkID0gY29tcG9uZW50LmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50UmVmICAgPSBWRG9tVXRpbC5maW5kKGNvbXBvbmVudC5wYXJlbnQudmRvbSwge2NvbXBvbmVudElkfSwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50UmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50UmVmLnZkb20uaWQgPSBjaGlsZE5vZGVJZFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRJZCAgID0gY29tcG9uZW50LmlkO1xuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VOb2RlID0ge2NvbXBvbmVudElkLCBpZDogY2hpbGROb2RlSWR9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGlsZE5vZGVzW2luZGV4XSA9IGNvbXBvbmVudCA/IHJlZmVyZW5jZU5vZGUgOiBtZS5hZGRWbm9kZUNvbXBvbmVudFJlZmVyZW5jZXMoY2hpbGROb2RlLCBvd25lcklkKVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdm5vZGVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBjb21wb25lbnQgd2hpY2ggbWF0Y2hlcyB0aGUgY29uZmlnLXNlbGVjdG9yIG1vdmluZyBkb3duIHRoZSBjb21wb25lbnQgaXRlbXMgdHJlZS5cbiAgICAgKiBVc2UgcmV0dXJuRmlyc3RNYXRjaD1mYWxzZSB0byBnZXQgYW4gYXJyYXkgb2YgYWxsIG1hdGNoaW5nIGl0ZW1zIGluc3RlYWQuXG4gICAgICogSWYgbm8gbWF0Y2ggaXMgZm91bmQsIHJldHVybnMgbnVsbCBpbiBjYXNlIHJldHVybkZpcnN0TWF0Y2ggPT09IHRydWUsIG90aGVyd2lzZSBhbiBlbXB0eSBBcnJheS5cbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZXxTdHJpbmd9IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xudWxsfSBjb25maWdcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJldHVybkZpcnN0TWF0Y2g9dHJ1ZVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29tcG9uZW50LkJhc2V8TmVvLmNvbXBvbmVudC5CYXNlW118bnVsbH1cbiAgICAgKi9cbiAgICBkb3duKGNvbXBvbmVudCwgY29uZmlnLCByZXR1cm5GaXJzdE1hdGNoPXRydWUpIHtcbiAgICAgICAgaWYgKE5lby5pc1N0cmluZyhjb21wb25lbnQpKSB7XG4gICAgICAgICAgICBjb21wb25lbnQgPSB0aGlzLmdldEJ5SWQoY29tcG9uZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtZSAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBtYXRjaEFycmF5ICA9IFtdLFxuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBudWxsLFxuICAgICAgICAgICAgaSAgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgcmV0dXJuQXJyYXkgPSBbXSxcbiAgICAgICAgICAgIGNoaWxkSXRlbXMsIGNvbmZpZ0FycmF5LCBjb25maWdMZW5ndGgsIGxlbjtcblxuICAgICAgICBpZiAoTmVvLmlzU3RyaW5nKGNvbmZpZykpIHtcbiAgICAgICAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICBudHlwZTogY29uZmlnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWNvbmZpZykge1xuICAgICAgICAgICAgY29uZmlnID0ge31cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZ0FycmF5ICA9IE9iamVjdC5lbnRyaWVzKGNvbmZpZyk7XG4gICAgICAgIGNvbmZpZ0xlbmd0aCA9IGNvbmZpZ0FycmF5Lmxlbmd0aDtcblxuICAgICAgICBjb25maWdBcnJheS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmICgoY29tcG9uZW50W2tleV0gPT09IHZhbHVlKVxuICAgICAgICAgICAgICAgIHx8IChrZXkgPT09ICdudHlwZScgJiYgbWUuaGFzUHJvdG90eXBlUHJvcGVydHlWYWx1ZShjb21wb25lbnQsIGtleSwgdmFsdWUpKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtYXRjaEFycmF5LnB1c2godHJ1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG1hdGNoQXJyYXkubGVuZ3RoID09PSBjb25maWdMZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChyZXR1cm5GaXJzdE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm5BcnJheS5wdXNoKGNvbXBvbmVudClcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkSXRlbXMgPSBtZS5nZXREaXJlY3RDaGlsZHJlbihjb21wb25lbnQuaWQpO1xuICAgICAgICBsZW4gICAgICAgID0gY2hpbGRJdGVtcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBtZS5kb3duKGNoaWxkSXRlbXNbaV0sIGNvbmZpZywgcmV0dXJuRmlyc3RNYXRjaCk7XG5cbiAgICAgICAgICAgIGlmIChyZXR1cm5GaXJzdE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJldHVyblZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmV0dXJuVmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybkFycmF5LnB1c2goLi4ucmV0dXJuVmFsdWUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0dXJuRmlyc3RNYXRjaCA/IG51bGw6IHJldHVybkFycmF5XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gcGF0aFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8bnVsbH0gdGhlIGNvbXBvbmVudCBpZCBpbiBjYXNlIHRoZXJlIGlzIGEgbWF0Y2hcbiAgICAgKi9cbiAgICBmaW5kUGFyZW50Q29tcG9uZW50KHBhdGgpIHtcbiAgICAgICAgbGV0IG1lICA9IHRoaXMsXG4gICAgICAgICAgICBpICAgPSAwLFxuICAgICAgICAgICAgbGVuID0gcGF0aD8ubGVuZ3RoIHx8IDAsXG4gICAgICAgICAgICBpZDtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZCA9IHBhdGhbaV07XG5cbiAgICAgICAgICAgIGlmIChpZCAmJiBtZS5oYXMoaWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG9iamVjdCBhc3NvY2lhdGVkIHRvIHRoZSBrZXksIG9yIG51bGwgaWYgdGhlcmUgaXMgbm9uZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgW2luY2x1ZGVXcmFwcGVyTm9kZXM9dHJ1ZV1cbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9XG4gICAgICovXG4gICAgZ2V0KGtleSwgaW5jbHVkZVdyYXBwZXJOb2Rlcz10cnVlKSB7XG4gICAgICAgIGlmIChpbmNsdWRlV3JhcHBlck5vZGVzKSB7XG4gICAgICAgICAgICBsZXQgd3JhcHBlck5vZGUgPSB0aGlzLndyYXBwZXJOb2Rlcy5nZXQoa2V5KTtcblxuICAgICAgICAgICAgaWYgKHdyYXBwZXJOb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZXJOb2RlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VwZXIuZ2V0KGtleSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBjaGlsZCBjb21wb25lbnRzIHdoaWNoIGFyZSByZWN1cnNpdmVseSBtYXRjaGVkIHZpYSB0aGVpciBwYXJlbnRJZFxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBjb21wb25lbnRcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlW119IGNoaWxkQ29tcG9uZW50c1xuICAgICAqL1xuICAgIGdldENoaWxkQ29tcG9uZW50cyhjb21wb25lbnQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGRpcmVjdENoaWxkcmVuID0gbWUuZ2V0RGlyZWN0Q2hpbGRyZW4oY29tcG9uZW50LmlkKSxcbiAgICAgICAgICAgIGNvbXBvbmVudHMgICAgID0gW10sXG4gICAgICAgICAgICBjaGlsZENvbXBvbmVudHM7XG5cbiAgICAgICAgZGlyZWN0Q2hpbGRyZW4uZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaChpdGVtKTtcblxuICAgICAgICAgICAgY2hpbGRDb21wb25lbnRzID0gbWUuZ2V0Q2hpbGRDb21wb25lbnRzKGl0ZW0pO1xuXG4gICAgICAgICAgICBjaGlsZENvbXBvbmVudHMgJiYgY29tcG9uZW50cy5wdXNoKC4uLmNoaWxkQ29tcG9uZW50cylcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0b2RvOiByZXBsYWNlIGFsbCBjYWxscyBvZiB0aGlzIG1ldGhvZCB0byBjYWxscyB1c2luZyB0aGUgdXRpbC5WTm9kZSBjbGFzc1xuICAgICAqIEdldCB0aGUgaWRzIG9mIGFsbCBjaGlsZCBub2RlcyBvZiB0aGUgZ2l2ZW4gdm5vZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdm5vZGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBjaGlsZElkcz1bXVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmdbXX0gY2hpbGRJZHNcbiAgICAgKi9cbiAgICBnZXRDaGlsZElkcyh2bm9kZSwgY2hpbGRJZHM9W10pIHtcbiAgICAgICAgcmV0dXJuIFZOb2RlVXRpbC5nZXRDaGlsZElkcyh2bm9kZSwgY2hpbGRJZHMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgY2hpbGQgY29tcG9uZW50cyBmb3VuZCBpbnNpZGUgdGhlIHZub2RlIHRyZWVcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50XG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZVtdfSBjaGlsZENvbXBvbmVudHNcbiAgICAgKi9cbiAgICBnZXRDaGlsZHJlbihjb21wb25lbnQpIHtcbiAgICAgICAgbGV0IGNoaWxkQ29tcG9uZW50cyA9IFtdLFxuICAgICAgICAgICAgY2hpbGROb2RlcyAgICAgID0gVk5vZGVVdGlsLmdldENoaWxkSWRzKGNvbXBvbmVudC52bm9kZSksXG4gICAgICAgICAgICBjaGlsZENvbXBvbmVudDtcblxuICAgICAgICBjaGlsZE5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICBjaGlsZENvbXBvbmVudCA9IHRoaXMuZ2V0KG5vZGUpO1xuXG4gICAgICAgICAgICBpZiAoY2hpbGRDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZENvbXBvbmVudHMucHVzaChjaGlsZENvbXBvbmVudClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkQ29tcG9uZW50c1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgZGlyZWN0IGNoaWxkIGNvbXBvbmVudHMgZm9yIGEgZ2l2ZW4gcGFyZW50SWQuXG4gICAgICogVXNlcyB0aGUgb3B0aW1pemVkIGBjaGlsZE1hcGAgZm9yIE8oMSkgbG9va3VwIHBlcmZvcm1hbmNlLCBhdm9pZGluZyB0aGUgbmVlZCB0byBpdGVyYXRlXG4gICAgICogb3ZlciBhbGwgY29tcG9uZW50cyBpbiB0aGUgbWFuYWdlci5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyZW50SWRcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlW119XG4gICAgICovXG4gICAgZ2V0RGlyZWN0Q2hpbGRyZW4ocGFyZW50SWQpIHtcbiAgICAgICAgaWYgKCFwYXJlbnRJZCkgcmV0dXJuIFtdO1xuXG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIGlkcyAgPSBtZS5jaGlsZE1hcC5nZXQocGFyZW50SWQpLFxuICAgICAgICAgICAgY2hpbGRyZW47XG5cbiAgICAgICAgaWYgKCFpZHMpIHJldHVybiBbXTtcblxuICAgICAgICBjaGlsZHJlbiA9IFtdO1xuXG4gICAgICAgIGlkcy5mb3JFYWNoKGlkID0+IHtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnQgPSBtZS5nZXQoaWQpO1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goY29tcG9uZW50KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDbGVhbnVwIGRlYWQgcmVmZXJlbmNlcyBpZiBhbnkgKHNob3VsZCB0eXBpY2FsbHkgYmUgaGFuZGxlZCBieSB1bnJlZ2lzdGVyKVxuICAgICAgICAgICAgICAgIGlkcy5kZWxldGUoaWQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjaGlsZHJlblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gYSBjaGlsZCBhbmQgYSBwYXJlbnQgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNoaWxkSWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyZW50SWRcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSAtMSBpZiBub3QgZm91bmRcbiAgICAgKi9cbiAgICBnZXREaXN0YW5jZShjaGlsZElkLCBwYXJlbnRJZCkge1xuICAgICAgICBsZXQgY2hpbGQgICAgPSB0aGlzLmdldChjaGlsZElkKSxcbiAgICAgICAgICAgIGRpc3RhbmNlID0gMDtcblxuICAgICAgICB3aGlsZSAoY2hpbGQ/LnBhcmVudElkKSB7XG4gICAgICAgICAgICBkaXN0YW5jZSsrO1xuXG4gICAgICAgICAgICBpZiAoY2hpbGQucGFyZW50SWQgPT09IHBhcmVudElkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpc3RhbmNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZCA9IHRoaXMuZ2V0KGNoaWxkLnBhcmVudElkKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC0xXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogISEgRm9yIGRlYnVnZ2luZyBwdXJwb3NlcyBvbmx5ICEhXG4gICAgICpcbiAgICAgKiBHZXQgdGhlIGZpcnN0IGNvbXBvbmVudCBiYXNlZCBvbiB0aGUgbnR5cGUgb3Igb3RoZXIgcHJvcGVydGllc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fEFycmF5fSBjb21wb25lbnREZXNjcmlwdGlvblxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmV0dXJuRmlyc3RNYXRjaD10cnVlXG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZXxudWxsfE5lby5jb21wb25lbnQuQmFzZVtdfVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgLy8gYXMgU3RyaW5nOiBudHlwZVtjb21tYSBzZXBhcmF0ZWQgcHJvcHRlcnRpZXNdXG4gICAgIE5lby5maXJzdCgndG9vbGJhciBidXR0b25bdGV4dD1UcnkgbWUsaWNvbj1wZW9wbGVdJylcbiAgICAgLy8gYXMgT2JqZWN0OiBBZGQgcHJvcGVydGllcy4gbnR5cGUgaXMgb3B0aW9uYWxcbiAgICAgTmVvLmZpcnN0KHtcbiAgICAgICAgICAgICAgICBpY29uOiAncGVvcGxlJ1xuICAgICAgICAgICAgfSlcbiAgICAgLy8gYXMgQXJyYXk6IEFuIEFycmF5IG9mIE9iamVjdHMuIE5vIFN0cmluZ3MgYWxsb3dlZFxuICAgICBOZW8uZmlyc3QoW3tcbiAgICAgICAgICAgICAgICBudHlwZTogJ3Rvb2xiYXInXG4gICAgICAgICAgICB9LHtcbiAgICAgICAgICAgICAgICBudHlwZTogJ2J1dHRvbicsIHRleHQ6ICdUcnkgbWUnLCBpY29uOiAncGVvcGxlXG4gICAgICAgICAgICB9XSlcblxuICAgICAqIFRoZSByZXR1cm5GaXJzdE1hdGNoIGZsYWcgYWxsb3dzIHRvIHJldHVybiBhbGwgaXRlbXMgYW5kXG4gICAgICogbm90IHN0b3AgYWZ0ZXIgdGhlIGZpcnN0IHJlc3VsdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgIE5lby5maXJzdCgnYnV0dG9uJywgZmFsc2UpIC8vID0+IFtCdXR0b24sIEJ1dHRvbiwgQnV0dG9uXVxuICAgICAqL1xuICAgIGdldEZpcnN0KGNvbXBvbmVudERlc2NyaXB0aW9uLCByZXR1cm5GaXJzdE1hdGNoPXRydWUpIHtcbiAgICAgICAgbGV0IG9iamVjdHMgPSBbXSxcbiAgICAgICAgICAgIGFwcCAgICAgPSBPYmplY3QudmFsdWVzKE5lby5hcHBzKVswXSxcbiAgICAgICAgICAgIHJvb3QgICAgPSBhcHAubWFpblZpZXc7XG5cbiAgICAgICAgLyogY3JlYXRlIGFuIGFycmF5IG9mIG9iamVjdHMgZnJvbSBzdHJpbmcgKi9cbiAgICAgICAgaWYgKE5lby5pc1N0cmluZyhjb21wb25lbnREZXNjcmlwdGlvbikpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gLyhcXHcqKShcXFtbXlxcXV0qXFxdKXwoXFx3KikvZztcbiAgICAgICAgICAgIGxldCBtYXRjaDtcblxuICAgICAgICAgICAgLyogZ2VuZXJhdGUgb2JqZWN0cyB3aGljaCBjb250YWluIHRoZSBpbmZvcm1hdGlvbiAqL1xuICAgICAgICAgICAgd2hpbGUgKG1hdGNoID0gcmVnZXguZXhlYyhjb21wb25lbnREZXNjcmlwdGlvbikpIHtcbiAgICAgICAgICAgICAgICBsZXQgWywgbnR5cGUsIHBhaXJzLCBudHlwZU9ubHldID0gbWF0Y2gsIG9iajtcblxuICAgICAgICAgICAgICAgIG50eXBlID0gbnR5cGUgfHwgbnR5cGVPbmx5O1xuICAgICAgICAgICAgICAgIG9iaiA9IHtudHlwZX07XG5cbiAgICAgICAgICAgICAgICBpZiAocGFpcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFpcnNSZWdleCA9IC9cXFsoLio/KVxcXS8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBhaXJzTWF0Y2ggPSBwYWlycy5tYXRjaChwYWlyc1JlZ2V4KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocGFpcnNNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFpcnMgPSBwYWlyc01hdGNoWzFdLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYWlycy5mb3JFYWNoKChwYWlyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gcGFpci5zcGxpdCgnPScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWUucmVwbGFjZSgvXCIvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmplY3RzLnB1c2gob2JqKTtcblxuICAgICAgICAgICAgICAgIHJlZ2V4Lmxhc3RJbmRleCsrXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoTmVvLmlzT2JqZWN0KGNvbXBvbmVudERlc2NyaXB0aW9uKSl7XG4gICAgICAgICAgICBvYmplY3RzLnB1c2goY29tcG9uZW50RGVzY3JpcHRpb24pXG4gICAgICAgIH0gZWxzZSBpZiAoTmVvLmlzQXJyYXkoY29tcG9uZW50RGVzY3JpcHRpb24pKSB7XG4gICAgICAgICAgICBvYmplY3RzID0gY29tcG9uZW50RGVzY3JpcHRpb25cbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGZpbmQgdGhlIGNvcnJlY3QgY2hpbGQgdXNpbmcgZG93bigpICovXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG9iamVjdHMucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKGFjYykge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IGFjYy5kb3duKGtleSwgcmV0dXJuRmlyc3RNYXRjaCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoISFjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH0sIHJvb3QpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIEFycmF5IGNvbnRhaW5pbmcgdGhlIGlkcyBvZiBhbGwgcGFyZW50IGNvbXBvbmVudHMgZm9yIGEgZ2l2ZW4gY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmdbXX0gcGFyZW50SWRzXG4gICAgICovXG4gICAgZ2V0UGFyZW50SWRzKGNvbXBvbmVudCkge1xuICAgICAgICBsZXQgcGFyZW50SWRzID0gW107XG5cbiAgICAgICAgd2hpbGUgKGNvbXBvbmVudD8ucGFyZW50SWQpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudCA9IHRoaXMuZ2V0KGNvbXBvbmVudC5wYXJlbnRJZCk7XG5cbiAgICAgICAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRJZHMucHVzaChjb21wb25lbnQuaWQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyZW50SWRzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBnZXRQYXJlbnRQYXRoKHBhdGgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY29tcG9uZW50UGF0aCA9IFtdLFxuICAgICAgICAgICAgaSAgICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICBsZW4gICAgICAgICAgID0gcGF0aD8ubGVuZ3RoIHx8IDAsXG4gICAgICAgICAgICBjb21wb25lbnQsIGlkO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlkID0gcGF0aFtpXTtcblxuICAgICAgICAgICAgaWYgKG1lLmhhcyhpZCkgfHwgbWUud3JhcHBlck5vZGVzLmdldChpZCkpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQgPSBtZS5nZXQoaWQpO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRQYXRoLnB1c2goY29tcG9uZW50LmlkKTtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50LnBhcmVudFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tcG9uZW50UGF0aFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gQXJyYXkgY29udGFpbmluZyBhbGwgcGFyZW50IGNvbXBvbmVudHMgZm9yIGEgZ2l2ZW4gY29tcG9uZW50IG9yIGNvbXBvbmVudCBpZFxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfFN0cmluZ30gY29tcG9uZW50XG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZVtdfSBwYXJlbnRzXG4gICAgICovXG4gICAgZ2V0UGFyZW50cyhjb21wb25lbnQpIHtcbiAgICAgICAgaWYgKE5lby5pc1N0cmluZyhjb21wb25lbnQpKSB7XG4gICAgICAgICAgICBjb21wb25lbnQgPSB0aGlzLmdldChjb21wb25lbnQpXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcGFyZW50cyA9IFtdO1xuXG4gICAgICAgIHdoaWxlIChjb21wb25lbnQ/LnBhcmVudElkKSB7XG4gICAgICAgICAgICBjb21wb25lbnQgPSB0aGlzLmdldChjb21wb25lbnQucGFyZW50SWQpO1xuXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgcGFyZW50cy5wdXNoKGNvbXBvbmVudClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJlbnRzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgY29tcG9uZW50IGlzIGEgZGVzY2VuZGFudCBvZiBhbm90aGVyIGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjaGlsZElkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmVudElkXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzUGFyZW50KGNoaWxkSWQsIHBhcmVudElkKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IHRoaXMuZ2V0KGNoaWxkSWQpO1xuXG4gICAgICAgIHdoaWxlIChjaGlsZD8ucGFyZW50SWQpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5wYXJlbnRJZCA9PT0gcGFyZW50SWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGQgPSB0aGlzLmdldChjaGlsZC5wYXJlbnRJZClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBjb21wb25lbnQgaGFkIGEgcHJvcGVydHkgb2YgYW55IHZhbHVlIHNvbWV3aGVyZSBpbiB0aGUgUHJvdG90eXBlIGNoYWluXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc1Byb3RvdHlwZVByb3BlcnR5VmFsdWUoY29tcG9uZW50LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgICAgd2hpbGUgKGNvbXBvbmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkgJiYgY29tcG9uZW50W3Byb3BlcnR5XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb21wb25lbnQgPSBjb21wb25lbnQuX19wcm90b19fXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBgY2hpbGRNYXBgIHdoZW4gYSBjb21wb25lbnQncyBgcGFyZW50SWRgIGNvbmZpZyBjaGFuZ2VzLlxuICAgICAqIE1haW50YWlucyB0aGUgaW50ZWdyaXR5IG9mIHRoZSByZXZlcnNlIHBhcmVudC1jaGlsZCBpbmRleC5cbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkUGFyZW50SWRcbiAgICAgKi9cbiAgICBvblBhcmVudElkQ2hhbmdlKGNvbXBvbmVudCwgb2xkUGFyZW50SWQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIG5ld1BhcmVudElkID0gY29tcG9uZW50LnBhcmVudElkLFxuICAgICAgICAgICAgc2V0O1xuXG4gICAgICAgIC8vIFJlbW92ZSBmcm9tIG9sZCBwYXJlbnQncyBzZXRcbiAgICAgICAgaWYgKG9sZFBhcmVudElkKSB7XG4gICAgICAgICAgICBzZXQgPSBtZS5jaGlsZE1hcC5nZXQob2xkUGFyZW50SWQpO1xuICAgICAgICAgICAgaWYgKHNldCkge1xuICAgICAgICAgICAgICAgIHNldC5kZWxldGUoY29tcG9uZW50LmlkKTtcbiAgICAgICAgICAgICAgICBpZiAoc2V0LnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuY2hpbGRNYXAuZGVsZXRlKG9sZFBhcmVudElkKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCB0byBuZXcgcGFyZW50J3Mgc2V0XG4gICAgICAgIGlmIChuZXdQYXJlbnRJZCkge1xuICAgICAgICAgICAgc2V0ID0gbWUuY2hpbGRNYXAuZ2V0KG5ld1BhcmVudElkKTtcbiAgICAgICAgICAgIGlmICghc2V0KSB7XG4gICAgICAgICAgICAgICAgc2V0ID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgIG1lLmNoaWxkTWFwLnNldChuZXdQYXJlbnRJZCwgc2V0KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0LmFkZChjb21wb25lbnQuaWQpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBjb21wb25lbnQgYW5kIGFkZHMgaXQgdG8gdGhlIGBjaGlsZE1hcGAgaWYgaXQgaGFzIGEgcGFyZW50SWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cbiAgICAgKi9cbiAgICByZWdpc3RlcihpdGVtKSB7XG4gICAgICAgIHN1cGVyLnJlZ2lzdGVyKGl0ZW0pO1xuXG4gICAgICAgIGNvbnN0IHtpZCwgcGFyZW50SWR9ID0gaXRlbTtcblxuICAgICAgICBpZiAocGFyZW50SWQpIHtcbiAgICAgICAgICAgIGxldCBtZSAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHNldCA9IG1lLmNoaWxkTWFwLmdldChwYXJlbnRJZCk7XG5cbiAgICAgICAgICAgIGlmICghc2V0KSB7XG4gICAgICAgICAgICAgICAgc2V0ID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgIG1lLmNoaWxkTWFwLnNldChwYXJlbnRJZCwgc2V0KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0LmFkZChpZClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB3cmFwcGVySWRcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50XG4gICAgICovXG4gICAgcmVnaXN0ZXJXcmFwcGVyTm9kZSh3cmFwcGVySWQsIGNvbXBvbmVudCkge1xuICAgICAgICB0aGlzLndyYXBwZXJOb2Rlcy5zZXQod3JhcHBlcklkLCBjb21wb25lbnQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5yZWdpc3RlcnMgYSBjb21wb25lbnQsIGNsZWFuaW5nIHVwIHdyYXBwZXIgbm9kZXMgYW5kIGBjaGlsZE1hcGAgcmVmZXJlbmNlcy5cbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZXxTdHJpbmd9IGl0ZW1cbiAgICAgKi9cbiAgICB1bnJlZ2lzdGVyKGl0ZW0pIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb21wb25lbnQgPSBpdGVtO1xuXG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICBpZiAoTmVvLmlzU3RyaW5nKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgbWUud3JhcHBlck5vZGVzLmRlbGV0ZShpdGVtKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQgPSBtZS5nZXQoaXRlbSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHtpZCwgcGFyZW50SWQsIHZkb219ID0gY29tcG9uZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKHZkb20gJiYgaWQgIT09IHZkb20uaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUud3JhcHBlck5vZGVzLmRlbGV0ZSh2ZG9tLmlkKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRJZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2V0ID0gbWUuY2hpbGRNYXAuZ2V0KHBhcmVudElkKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQuZGVsZXRlKGlkKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldC5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUuY2hpbGRNYXAuZGVsZXRlKHBhcmVudElkKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3VwZXIudW5yZWdpc3RlcihpdGVtKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGNvbXBvbmVudCB3aGljaCBtYXRjaGVzIHRoZSBjb25maWctc2VsZWN0b3IuXG4gICAgICogVXNlIHJldHVybkZpcnN0TWF0Y2g9ZmFsc2UgdG8gZ2V0IGFuIGFycmF5IG9mIGFsbCBtYXRjaGluZyBpdGVtcyBpbnN0ZWFkLlxuICAgICAqIElmIG5vIG1hdGNoIGlzIGZvdW5kLCByZXR1cm5zIG51bGwgaW4gY2FzZSByZXR1cm5GaXJzdE1hdGNoID09PSB0cnVlLCBvdGhlcndpc2UgYW4gZW1wdHkgQXJyYXkuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudElkXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfG51bGx9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmV0dXJuRmlyc3RNYXRjaD10cnVlXG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZXxOZW8uY29tcG9uZW50LkJhc2VbXXxudWxsfVxuICAgICAqL1xuICAgIHVwKGNvbXBvbmVudElkLCBjb25maWcsIHJldHVybkZpcnN0TWF0Y2g9dHJ1ZSkge1xuICAgICAgICBsZXQgY29tcG9uZW50ICAgPSB0aGlzLmdldChjb21wb25lbnRJZCksXG4gICAgICAgICAgICByZXR1cm5BcnJheSA9IFtdLFxuICAgICAgICAgICAgY29uZmlnQXJyYXksIGNvbmZpZ0xlbmd0aCwgbWF0Y2hBcnJheTtcblxuICAgICAgICBpZiAoTmVvLmlzU3RyaW5nKGNvbmZpZykpIHtcbiAgICAgICAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICBudHlwZTogY29uZmlnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWNvbmZpZykge1xuICAgICAgICAgICAgY29uZmlnID0ge31cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZ0FycmF5ICA9IE9iamVjdC5lbnRyaWVzKGNvbmZpZyk7XG4gICAgICAgIGNvbmZpZ0xlbmd0aCA9IGNvbmZpZ0FycmF5Lmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoY29tcG9uZW50Py5wYXJlbnRJZCkge1xuICAgICAgICAgICAgY29tcG9uZW50ID0gdGhpcy5nZXQoY29tcG9uZW50LnBhcmVudElkKTtcblxuICAgICAgICAgICAgaWYgKCFjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuRmlyc3RNYXRjaCA/IG51bGwgOiByZXR1cm5BcnJheVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtYXRjaEFycmF5ID0gW107XG5cbiAgICAgICAgICAgIGNvbmZpZ0FycmF5LmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnRba2V5XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hBcnJheS5wdXNoKHRydWUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChtYXRjaEFycmF5Lmxlbmd0aCA9PT0gY29uZmlnTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJldHVybkZpcnN0TWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybkFycmF5LnB1c2goY29tcG9uZW50KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhDb21wb25lbnQpO1xuIiwiaW1wb3J0IEJhc2UgICAgICAgICAgICAgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQgQ29tcG9uZW50TWFuYWdlciBmcm9tICcuL0NvbXBvbmVudC5tanMnO1xuaW1wb3J0IEZvY3VzTWFuYWdlciAgICAgZnJvbSAnLi9Gb2N1cy5tanMnO1xuaW1wb3J0IExvZ2dlciAgICAgICAgICAgZnJvbSAnLi4vdXRpbC9Mb2dnZXIubWpzJztcbmltcG9ydCBOZW9BcnJheSAgICAgICAgIGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBWRG9tVXRpbCAgICAgICAgIGZyb20gJy4uL3V0aWwvVkRvbS5tanMnO1xuaW1wb3J0IFZOb2RlVXRpbCAgICAgICAgZnJvbSAnLi4vdXRpbC9WTm9kZS5tanMnO1xuXG5jb25zdCBldmVudENvbmZpZ0tleXMgPSBbXG4gICAgJ2J1YmJsZScsXG4gICAgJ2RlbGVnYXRlJyxcbiAgICAnbG9jYWwnLFxuICAgICdzY29wZScsXG4gICAgJ3Zub2RlSWQnXG5dO1xuXG5jb25zdCBoYW5kbGVyTWFwID0ge1xuICAgIGNoYW5nZSAgICAgOiAnb25DaGFuZ2UnLFxuICAgIGNsaWNrICAgICAgOiAnb25DbGljaycsXG4gICAgY29udGV4dG1lbnU6ICdvbkNvbnRleHRNZW51JyxcbiAgICBkYmxjbGljayAgIDogJ29uRG91YmxlQ2xpY2snLFxuICAgIGZvY3VzaW4gICAgOiAnb25Gb2N1c0luJyxcbiAgICBmb2N1c291dCAgIDogJ29uRm9jdXNPdXQnLFxuICAgIGlucHV0ICAgICAgOiAnb25DaGFuZ2UnLFxuICAgIGtleWRvd24gICAgOiAnb25LZXlEb3duJyxcbiAgICBrZXl1cCAgICAgIDogJ29uS2V5VXAnLFxuICAgIG1vdXNlZG93biAgOiAnb25Nb3VzZURvd24nLFxuICAgIG1vdXNlZW50ZXIgOiAnb25Nb3VzZUVudGVyJyxcbiAgICBtb3VzZWxlYXZlIDogJ29uTW91c2VMZWF2ZScsXG4gICAgbW91c2Vtb3ZlICA6ICdvbk1vdXNlTW92ZScsXG4gICAgbW91c2V1cCAgICA6ICdvbk1vdXNlVXAnLFxuICAgIHNjcm9sbCAgICAgOiAnb25TY3JvbGwnLFxuICAgIHdoZWVsICAgICAgOiAnb25XaGVlbCdcbn07XG5cbmNvbnN0IGdsb2JhbERvbUV2ZW50cyA9IFtcbiAgICAnY2hhbmdlJyxcbiAgICAnY2xpY2snLFxuICAgICdjb250ZXh0bWVudScsXG4gICAgJ2RibGNsaWNrJyxcbiAgICAnZHJhZzplbmQnLFxuICAgICdkcmFnOm1vdmUnLFxuICAgICdkcmFnOnN0YXJ0JyxcbiAgICAnZm9jdXNpbicsXG4gICAgJ2ZvY3Vzb3V0JyxcbiAgICAnaW5wdXQnLFxuICAgICdpbnRlcnNlY3QnLFxuICAgICdrZXlkb3duJyxcbiAgICAna2V5dXAnLFxuICAgICdtb3VzZWRvd24nLFxuICAgICdtb3VzZWVudGVyJyxcbiAgICAnbW91c2VsZWF2ZScsXG4gICAgJ21vdXNldXAnLFxuICAgICduZW9uYXZpZ2F0ZScsXG4gICAgJ3Njcm9sbCcsXG4gICAgJ3NlbGVjdGlvbmNoYW5nZScsXG4gICAgJ3RvdWNobW92ZScsXG4gICAgJ3doZWVsJ1xuXTtcblxuLyoqXG4gKiBUaGUgRG9tRXZlbnQgTWFuYWdlciBpcyByZXNwb25zaWJsZSBmb3IgZGlzdHJpYnV0aW5nIERPTSBldmVudHMgdG8gdGhlIG1hdGNoaW5nIGNvbXBvbmVudHMuXG4gKiBJdCBzdXBwb3J0cyBldmVudCBkZWxlZ2F0aW9uIGFuZCBcIkxvZ2ljYWwgQ29tcG9uZW50IEJ1YmJsaW5nXCIsIGFsbG93aW5nIGV2ZW50cyB0byBidWJibGUgdXBcbiAqIHRoZSBsb2dpY2FsIGNvbXBvbmVudCBoaWVyYXJjaHkgKGUuZy4gYGNvbXBvbmVudC5wYXJlbnRgKSBldmVuIGlmIHRoZSBET00gaGllcmFyY2h5IGlzXG4gKiBkaXNjb25uZWN0ZWQgKGUuZy4gUG9ydGFscywgRHJhZ1Byb3hpZXMsIE11bHRpLVdpbmRvdyBzZXR1cHMpLlxuICpcbiAqIEBjbGFzcyBOZW8ubWFuYWdlci5Eb21FdmVudFxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICogQHNpbmdsZXRvblxuICovXG5jbGFzcyBEb21FdmVudCBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLm1hbmFnZXIuRG9tRXZlbnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5tYW5hZ2VyLkRvbUV2ZW50JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gaXRlbXM9e31cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbXM6IHt9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBtYXA9e31cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbWFwOiB7fSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZXRvbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZXRvbjogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gbW91bnRUaW1lb3V0cz17fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbW91bnRUaW1lb3V0cyA9IHt9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBuYXRpdmUgUmVzaXplT2JzZXJ2ZXIgZm9yIGEgc3BlY2lmaWMgY29tcG9uZW50IGxpc3RlbmVyLlxuICAgICAqXG4gICAgICogKipBcmNoaXRlY3R1cmFsIE5vdGUgb24gRGVsZWdhdGlvbjoqKlxuICAgICAqIFVubGlrZSBzdGFuZGFyZCBET00gZXZlbnRzIChjbGljaywgbW91c2VlbnRlcikgd2hpY2ggc3VwcG9ydCBmdWxsIENTUy1zZWxlY3RvciBkZWxlZ2F0aW9uXG4gICAgICogKGUuZy4sIGBkZWxlZ2F0ZTogJy5teS1jbGFzcydgKSwgYHJlc2l6ZWAgZXZlbnQgZGVsZWdhdGlvbiBpcyBzdHJpY3RseSBsaW1pdGVkIHRvIGV4YWN0IE5vZGUgSURzXG4gICAgICogKGUuZy4sIGBkZWxlZ2F0ZTogJyNteS1pZCdgKS5cbiAgICAgKlxuICAgICAqICoqVGhlIEludGVudDoqKlxuICAgICAqIEEgbmF0aXZlIGBSZXNpemVPYnNlcnZlcmAgbXVzdCBiZSBhdHRhY2hlZCB0byBhIHNwZWNpZmljLCBleGlzdGluZyBwaHlzaWNhbCBET00gbm9kZS4gSWYgd2UgYWxsb3dlZFxuICAgICAqIENTUyBzZWxlY3RvcnMsIHRoZSBtYW5hZ2VyIHdvdWxkIGhhdmUgdG8gcmVjdXJzaXZlbHkgc2NhbiB0aGUgRE9NIG9uIGV2ZXJ5IG11dGF0aW9uIHRvIGZpbmQgbmV3XG4gICAgICogbWF0Y2hpbmcgbm9kZXMgYW5kIGR5bmFtaWNhbGx5IGF0dGFjaC9kZXRhY2ggb2JzZXJ2ZXJzLiBGb3IgaGlnaGx5IHBlcm11dGFibGUgRE9NIHN0cnVjdHVyZXNcbiAgICAgKiAobGlrZSB2aXJ0dWFsaXplZCBncmlkcyBvciBkeW5hbWljIGxpc3RzKSwgdGhpcyBjb250aW51b3VzIHBvbGxpbmcgYW5kIG9ic2VydmVyIHRocmFzaGluZ1xuICAgICAqIHdvdWxkIGRlc3Ryb3kgcGVyZm9ybWFuY2UuIFRoZXJlZm9yZSwgb2JzZXJ2aW5nIGR5bmFtaWMgY2hpbGRyZW4gcmVxdWlyZXMgbWFudWFsIGl0ZXJhdGlvblxuICAgICAqIGFuZCBleHBsaWNpdCBJRCByZWdpc3RyYXRpb24gYnkgdGhlIHBhcmVudCBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAgICovXG4gICAgYXN5bmMgYWRkUmVzaXplT2JzZXJ2ZXIoY29tcG9uZW50LCBldmVudCkge1xuICAgICAgICBsZXQge3dpbmRvd0lkfSAgICAgPSBjb21wb25lbnQsXG4gICAgICAgICAgICB0YXJnZXRJZCAgICAgICA9IGNvbXBvbmVudC5pZCxcbiAgICAgICAgICAgIFJlc2l6ZU9ic2VydmVyID0gYXdhaXQgTmVvLmN1cnJlbnRXb3JrZXIuZ2V0QWRkb24oJ1Jlc2l6ZU9ic2VydmVyJywgd2luZG93SWQpO1xuXG4gICAgICAgIC8vIFJlc2l6ZU9ic2VydmVycyBuZWVkIHRvIGdldCByZWdpc3RlcmVkIHRvIGEgc3BlY2lmaWMgdGFyZ2V0IGlkXG4gICAgICAgIGlmIChldmVudC5kZWxlZ2F0ZT8uc3RhcnRzV2l0aCgnIycpKSB7XG4gICAgICAgICAgICB0YXJnZXRJZCA9IGV2ZW50LmRlbGVnYXRlLnN1YnN0cmluZygxKVxuICAgICAgICB9XG5cbiAgICAgICAgUmVzaXplT2JzZXJ2ZXIucmVnaXN0ZXIoe2NvbXBvbmVudElkOiBjb21wb25lbnQuaWQsIGlkOiB0YXJnZXRJZCwgd2luZG93SWR9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIHRoZSBldmVudCBwYXRoIHRvIGZpbmQgbWF0Y2hpbmcgbGlzdGVuZXJzIG9uIGNvbXBvbmVudHMuXG4gICAgICogSXQgdXRpbGl6ZXMgYENvbXBvbmVudE1hbmFnZXIuZ2V0UGFyZW50UGF0aCgpYCB0byBjb25zdHJ1Y3QgYSBsb2dpY2FsIGNvbXBvbmVudCBwYXRoLFxuICAgICAqIGVuc3VyaW5nIGV2ZW50cyBidWJibGUgdG8gbG9naWNhbCBhbmNlc3RvcnMgKGxpa2UgYSBEYXNoYm9hcmQgb3duaW5nIGEgRHJhZ1Byb3h5KVxuICAgICAqIGV2ZW4gaWYgdGhleSBhcmUgbm90IHBoeXNpY2FsIGFuY2VzdG9ycyBpbiB0aGUgRE9NLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGZpcmUoZXZlbnQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGJ1YmJsZSAgICAgID0gdHJ1ZSxcbiAgICAgICAgICAgIGRhdGEgICAgICAgID0gZXZlbnQuZGF0YSB8fCB7fSxcbiAgICAgICAgICAgIHtldmVudE5hbWV9ID0gZXZlbnQ7XG5cbiAgICAgICAgLy8gQnlwYXNzIHN0YW5kYXJkIGJ1YmJsaW5nIGZvciBleHBsaWNpdGx5IG1hcHBlZCByZXNpemUgZXZlbnRzIGZyb20gdGhlIE1haW4gVGhyZWFkIHJlZ2lzdHJ5XG4gICAgICAgIGlmIChldmVudE5hbWUgPT09ICdyZXNpemUnICYmIEFycmF5LmlzQXJyYXkoZGF0YS5jb21wb25lbnRJZHMpKSB7XG4gICAgICAgICAgICBkYXRhLmNvbXBvbmVudElkcy5mb3JFYWNoKGNtcElkID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgY29tcG9uZW50ID0gTmVvLmdldENvbXBvbmVudChjbXBJZCksXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycyA9IG1lLml0ZW1zW2NtcElkXT8uW2V2ZW50TmFtZV07XG5cbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50ICYmIGxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXZlbnREYXRhID0gTmVvLmNsb25lKGRhdGEsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnREYXRhLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50RGF0YS5jdXJyZW50VGFyZ2V0ID0gZGF0YS5pZDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE5lby5pc1N0cmluZyhsaXN0ZW5lci5mbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5iaW5kQ2FsbGJhY2sobGlzdGVuZXIuZm4sICdmbicsIGxpc3RlbmVyLnNjb3BlLCBsaXN0ZW5lcilcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmZuLmFwcGx5KGxpc3RlbmVyLnNjb3BlIHx8IGdsb2JhbFRoaXMsIFtldmVudERhdGFdKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICBsaXN0ZW5lcnMgICA9IG51bGwsXG4gICAgICAgICAgICBwYXRoSWRzICAgICA9IGRhdGEucGF0aCA/IGRhdGEucGF0aC5tYXAoZSA9PiBlLmlkKSA6IFtdLFxuICAgICAgICAgICAgcGF0aCAgICAgICAgPSBDb21wb25lbnRNYW5hZ2VyLmdldFBhcmVudFBhdGgocGF0aElkcyksXG4gICAgICAgICAgICBsZW4gICAgICAgICA9IHBhdGgubGVuZ3RoLFxuICAgICAgICAgICAgY29tcG9uZW50LCBkZWxlZ2F0aW9uVGFyZ2V0SWQsIGlkLCBwcmV2ZW50RmlyZTtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZCAgICAgICAgPSBwYXRoW2ldO1xuICAgICAgICAgICAgY29tcG9uZW50ID0gTmVvLmdldENvbXBvbmVudChpZCk7XG5cbiAgICAgICAgICAgIGlmICghY29tcG9uZW50IHx8IChldmVudE5hbWUgIT09ICdyZXNpemUnICYmIGNvbXBvbmVudC5kaXNhYmxlZCkpIHtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSAnc2Nyb2xsJykge1xuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQuc2F2ZVNjcm9sbFBvc2l0aW9uICYmIHR5cGVvZiBjb21wb25lbnQub25TY3JvbGxDYXB0dXJlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5vblNjcm9sbENhcHR1cmUoZGF0YSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxpc3RlbmVycyA9IG1lLml0ZW1zW2lkXT8uW2V2ZW50TmFtZV07XG5cbiAgICAgICAgICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShsaXN0ZW5lcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3AgaXRlcmF0aW9uIGlmIGEgaGFuZGxlciByZXR1cm5zIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5ldmVyeShsaXN0ZW5lciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXIgJiYgbGlzdGVuZXIuZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0aW9uVGFyZ2V0SWQgPSBtZS52ZXJpZnlEZWxlZ2F0aW9uUGF0aChsaXN0ZW5lciwgZGF0YS5wYXRoLCBwYXRoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWxlZ2F0aW9uVGFyZ2V0SWQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZlbnRGaXJlID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2Ugb25seSB3YW50IG1vdXNlZW50ZXIgJiBsZWF2ZSB0byBmaXJlIG9uIHRoZWlyIHRvcCBsZXZlbCBub2Rlcywgbm90IGZvciBjaGlsZHJlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSAnbW91c2VlbnRlcicgfHwgZXZlbnROYW1lID09PSAnbW91c2VsZWF2ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZlbnRGaXJlID0gIURvbUV2ZW50LnZlcmlmeU1vdXNlRW50ZXJMZWF2ZShjb21wb25lbnQsIGRhdGEsIGRlbGVnYXRpb25UYXJnZXRJZCwgZXZlbnROYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmV2ZW50RmlyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbXVsdGlwbGUgbGlzdGVuZXJzIHdvdWxkIGNoYW5nZSB0aGUgcmVmZXJlbmNlIG9mIGRhdGEuY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gTmVvLmNsb25lKGRhdGEsIHRydWUsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlciBuZWVkcyB0byBrbm93IHdoaWNoIGFjdHVhbCB0YXJnZXQgbWF0Y2hlZCB0aGUgZGVsZWdhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuY3VycmVudFRhcmdldCA9IGRlbGVnYXRpb25UYXJnZXRJZDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE5lby5pc1N0cmluZyhsaXN0ZW5lci5mbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5iaW5kQ2FsbGJhY2sobGlzdGVuZXIuZm4sICdmbicsIGxpc3RlbmVyLnNjb3BlLCBsaXN0ZW5lcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbGlzdGVuZXIuZm4uYXBwbHkobGlzdGVuZXIuc2NvcGUgfHwgZ2xvYmFsVGhpcywgW2RhdGFdKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsaXN0ZW5lci5idWJibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWJibGUgPSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBsaXN0ZW5lciByZXR1cm5zIGZhbHNlLCB3ZSBzdG9wIGl0ZXJhdGluZyB0aGUgbGlzdGVuZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICE9PSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gd2UgZG8gd2FudCB0byB0cmlnZ2VyIHRoZSBGb2N1c01hbmFnZXIgYWZ0ZXIgbm9ybWFsIGRvbUxpc3RlbmVycyBvbiB0aGVzZSBldmVudHMgZ290IGV4ZWN1dGVkXG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSAnZm9jdXNpbicgfHwgZXZlbnROYW1lID09PSAnZm9jdXNvdXQnKSB7XG4gICAgICAgICAgICAgICAgRm9jdXNNYW5hZ2VyWydvbicgKyBOZW8uY2FwaXRhbGl6ZShldmVudE5hbWUpXSh7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEhvbm9yIHRoZSBFdmVudCBjYW5jZWxCdWJibGUgcHJvcGVydHlcbiAgICAgICAgICAgIGlmICghYnViYmxlIHx8IGRhdGEuY2FuY2VsQnViYmxlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudE5hbWUgPT09ICdjb250ZXh0bWVudScgJiYgZGF0YS5jdHJsS2V5KSB7XG4gICAgICAgICAgICBOZW8udXRpbD8uTG9nZ2VyPy5vbkNvbnRleHRNZW51KGRhdGEpXG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnROYW1lLnN0YXJ0c1dpdGgoJ2RyYWc6JykgfHwgZXZlbnROYW1lLnN0YXJ0c1dpdGgoJ2Ryb3AnKSkge1xuICAgICAgICAgICAgbGV0IGRyYWdab25lID0gZGF0YS5kcmFnWm9uZUlkICYmIE5lby5nZXQoZGF0YS5kcmFnWm9uZUlkKTtcblxuICAgICAgICAgICAgaWYgKGRyYWdab25lKSB7XG4gICAgICAgICAgICAgICAgLy8gZHJhZzptb3ZlICYgZHJhZzplbmRcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnROYW1lLnN0YXJ0c1dpdGgoJ2RyYWc6JykpIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ1pvbmVbZXZlbnROYW1lID09PSAnZHJhZzptb3ZlJyA/ICdvbkRyYWdNb3ZlJyA6ICdvbkRyYWdFbmQnXT8uKGRhdGEpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ1pvbmUuZmlyZShldmVudE5hbWUsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBkcmFnWm9uZVt7XG4gICAgICAgICAgICAgICAgICAgICAgICAnZHJvcCcgICAgICA6ICdvbkRyb3AnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Ryb3A6ZW50ZXInOiAnb25Ecm9wRW50ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Ryb3A6bGVhdmUnOiAnb25Ecm9wTGVhdmUnLFxuICAgICAgICAgICAgICAgICAgICB9W2V2ZW50TmFtZV1dLmNhbGwoZHJhZ1pvbmUsIGRhdGEpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGNvbmZpZ1xuICAgICAqIEBwYXJhbSBzY29wZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2VuZXJhdGVMaXN0ZW5lckNvbmZpZyhjb25maWcsIHNjb3BlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBidWJibGUgICA6IGNvbmZpZy5idWJibGUsXG4gICAgICAgICAgICBkZWxlZ2F0ZSA6IGNvbmZpZy5kZWxlZ2F0ZSxcbiAgICAgICAgICAgIGV2ZW50TmFtZTogY29uZmlnLmV2ZW50TmFtZSxcbiAgICAgICAgICAgIGlkICAgICAgIDogc2NvcGUuaWQsXG4gICAgICAgICAgICBvcHRzICAgICA6IGNvbmZpZyxcbiAgICAgICAgICAgIHByaW9yaXR5IDogY29uZmlnLnByaW9yaXR5LFxuICAgICAgICAgICAgc2NvcGUgICAgOiBjb25maWcuc2NvcGUgICB8fCBzY29wZSxcbiAgICAgICAgICAgIHZub2RlSWQgIDogY29uZmlnLnZub2RlSWQgfHwgc2NvcGUudmRvbS5pZFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGdldEV2ZW50TmFtZShjb25maWcpIHtcbiAgICAgICAgbGV0IGV2ZW50TmFtZSA9IG51bGw7XG5cbiAgICAgICAgaWYgKE5lby5pc09iamVjdChjb25maWcpKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhjb25maWcpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWV2ZW50Q29uZmlnS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZSA9IGtleVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXZlbnROYW1lXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY29uZmlnLmJ1YmJsZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcuZGVsZWdhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLmV2ZW50TmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcuaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnLm9wdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnLnNjb3BlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy52bm9kZUlkXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRMaXN0ZW5lcihjb25maWcpIHtcbiAgICAgICAgbGV0IGxpc3RlbmVycyA9IHRoaXMuaXRlbXMsXG4gICAgICAgICAgICBldmVudDtcblxuICAgICAgICBpZiAobGlzdGVuZXJzPy5bY29uZmlnLmlkXSkge1xuICAgICAgICAgICAgZXZlbnQgPSBsaXN0ZW5lcnNbY29uZmlnLmlkXVtjb25maWcuZXZlbnROYW1lXTtcblxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50IHx8IG51bGxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdW50cyBsb2NhbCBkb21FdmVudCBsaXN0ZW5lcnMgZm9yIGEgZ2l2ZW4gY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBtb3VudERvbUxpc3RlbmVycyhjb21wb25lbnQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGxpc3RlbmVycyAgID0gbWUuaXRlbXNbY29tcG9uZW50LmlkXSxcbiAgICAgICAgICAgIGxvY2FsRXZlbnRzID0gW107XG5cbiAgICAgICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMobGlzdGVuZXJzKS5mb3JFYWNoKChbZXZlbnROYW1lLCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnROYW1lID0gZXZlbnQuZXZlbnROYW1lO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09ICdyZXNpemUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5hZGRSZXNpemVPYnNlcnZlcihjb21wb25lbnQsIGV2ZW50KVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50TmFtZSAmJiAhZXZlbnQubW91bnRlZCAmJiAoZXZlbnQubG9jYWwgfHwgIWdsb2JhbERvbUV2ZW50cy5pbmNsdWRlcyhldmVudE5hbWUpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQubW91bnRlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvcHRpb25zID0ge307XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5vcHRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oZXZlbnQub3B0cywgJ2NhcHR1cmUnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmNhcHR1cmUgPSBldmVudC5vcHRzLmNhcHR1cmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oZXZlbnQub3B0cywgJ29uY2UnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uY2UgPSBldmVudC5vcHRzLm9uY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oZXZlbnQub3B0cywgJ3Bhc3NpdmUnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBhc3NpdmUgPSBldmVudC5vcHRzLnBhc3NpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsRXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgICA6IGV2ZW50TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyTWFwW2V2ZW50TmFtZV0gfHwgJ2RvbUV2ZW50TGlzdGVuZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdm5vZGVJZDogZXZlbnQudm5vZGVJZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGxvY2FsRXZlbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBOZW8ud29ya2VyLkFwcC5wcm9taXNlTWVzc2FnZShjb21wb25lbnQud2luZG93SWQsIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uIDogJ2FkZERvbUxpc3RlbmVyJyxcbiAgICAgICAgICAgICAgICAgICAgYXBwTmFtZTogY29tcG9uZW50LmFwcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50cyA6IGxvY2FsRXZlbnRzXG4gICAgICAgICAgICAgICAgfSkudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2FkZGVkIGRvbUxpc3RlbmVyJywgZGF0YSk7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0FwcDogR290IGVycm9yIGF0dGVtcHRpbmcgdG8gYWRkIGEgZG9tTGlzdGVuZXInLCBlcnIpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgY29uZmlnXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjb25maWcuYnViYmxlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICBjb25maWcuZGVsZWdhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gIGNvbmZpZy5ldmVudE5hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gIGNvbmZpZy5pZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY29uZmlnLmxvY2FsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICBjb25maWcub3B0c1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgY29uZmlnLm9yaWdpbmFsQ29uZmlnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICBjb25maWcub3duZXJJZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgY29uZmlnLnByaW9yaXR5PTFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gIGNvbmZpZy5zY29wZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgY29uZmlnLnZub2RlSWRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgbGlzdGVuZXIgZ290IHJlZ2lzdGVyZWQgc3VjY2Vzc2Z1bGx5IChmYWxzZSBpbiBjYXNlIGl0IHdhcyBhbHJlYWR5IHRoZXJlKVxuICAgICAqL1xuICAgIHJlZ2lzdGVyKGNvbmZpZykge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBhbHJlYWR5UmVnaXN0ZXJlZCAgICAgICAgICAgID0gZmFsc2UsXG4gICAgICAgICAgICB7ZXZlbnROYW1lLCBpZCwgb3B0cywgc2NvcGV9ID0gY29uZmlnLFxuICAgICAgICAgICAgbGlzdGVuZXJzICAgICAgICAgICAgICAgICAgICA9IG1lLml0ZW1zLFxuICAgICAgICAgICAgZm5UeXBlICAgICAgICAgICAgICAgICAgICAgICA9IHR5cGVvZiBvcHRzLFxuICAgICAgICAgICAgZm4sIGxpc3RlbmVyLCBsaXN0ZW5lckNvbmZpZywgbGlzdGVuZXJJZDtcblxuICAgICAgICAvLyBFbnN1cmUgd2UgcmVnaXN0ZXIgdGhlIGxpc3RlbmVyIHVuZGVyIHRoZSBjb21wb25lbnQgSUQsIGV2ZW4gaWYgaXQgaXMgYSB3cmFwcGVyIG5vZGVcbiAgICAgICAgaWYgKGNvbmZpZy5vd25lcklkKSB7XG4gICAgICAgICAgICBpZCA9IGNvbmZpZy5vd25lcklkXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm5UeXBlID09PSAnZnVuY3Rpb24nIHx8IGZuVHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGZuID0gb3B0c1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm4gICAgPSBvcHRzLmZuO1xuICAgICAgICAgICAgc2NvcGUgPSBvcHRzLnNjb3BlIHx8IHNjb3BlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWxpc3RlbmVyc1tpZF0pIHtcbiAgICAgICAgICAgIGxpc3RlbmVyc1tpZF0gPSB7fVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3RlbmVyc1tpZF1bZXZlbnROYW1lXSkge1xuICAgICAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaWRdW2V2ZW50TmFtZV07XG5cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGxpc3RlbmVyKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcltrZXldLmZuLnRvU3RyaW5nKCkgPT09IGZuLnRvU3RyaW5nKCkgJiYgLy8gdG9kbzogYWRkIGEgYmV0dGVyIGNoZWNrXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyW2tleV0uc2NvcGUgICAgICAgICA9PT0gc2NvcGUgJiZcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJba2V5XS5kZWxlZ2F0ZSAgICAgID09PSBjb25maWcuZGVsZWdhdGVcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgYWxyZWFkeVJlZ2lzdGVyZWQgPSB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpc3RlbmVyc1tpZF1bZXZlbnROYW1lXSA9IFtdXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWxyZWFkeVJlZ2lzdGVyZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgbGlzdGVuZXJJZCA9IE5lby5nZXRJZCgnZG9tLWV2ZW50Jyk7XG5cbiAgICAgICAgY29uZmlnLmxpc3RlbmVySWQgPSBsaXN0ZW5lcklkO1xuXG4gICAgICAgIGxldCBsb2NhbCA9IGNvbmZpZy5sb2NhbCB8fCAoTmVvLmlzT2JqZWN0KG9wdHMpICYmIG9wdHMubG9jYWwpIHx8IGZhbHNlO1xuXG4gICAgICAgIGxpc3RlbmVyQ29uZmlnID0ge1xuICAgICAgICAgICAgYnViYmxlICAgICAgICA6IGNvbmZpZy5oYXNPd25Qcm9wZXJ0eSgnYnViYmxlJykgPyBjb25maWcuYnViYmxlIDogb3B0cy5oYXNPd25Qcm9wZXJ0eSgnYnViYmxlJykgPyBvcHRzLmJ1YmJsZSA6IHRydWUsXG4gICAgICAgICAgICBkZWxlZ2F0ZSAgICAgIDogY29uZmlnLmRlbGVnYXRlLFxuICAgICAgICAgICAgZXZlbnROYW1lLFxuICAgICAgICAgICAgZm4sXG4gICAgICAgICAgICBpZCAgICAgICAgICAgIDogbGlzdGVuZXJJZCxcbiAgICAgICAgICAgIGxvY2FsLFxuICAgICAgICAgICAgbW91bnRlZCAgICAgICA6ICFsb2NhbCAmJiBnbG9iYWxEb21FdmVudHMuaW5jbHVkZXMoZXZlbnROYW1lKSxcbiAgICAgICAgICAgIG9yaWdpbmFsQ29uZmlnOiBjb25maWcub3JpZ2luYWxDb25maWcsXG4gICAgICAgICAgICBvd25lcklkICAgICAgIDogY29uZmlnLm93bmVySWQsXG4gICAgICAgICAgICBwcmlvcml0eSAgICAgIDogY29uZmlnLnByaW9yaXR5IHx8IG9wdHMucHJpb3JpdHkgfHwgMSxcbiAgICAgICAgICAgIHNjb3BlLFxuICAgICAgICAgICAgdm5vZGVJZCAgICAgICA6IGNvbmZpZy52bm9kZUlkXG4gICAgICAgIH07XG5cbiAgICAgICAgbWUubWFwW2xpc3RlbmVySWRdID0gbGlzdGVuZXJDb25maWc7XG5cbiAgICAgICAgbGlzdGVuZXJzW2lkXVtldmVudE5hbWVdLnB1c2gobGlzdGVuZXJDb25maWcpO1xuXG4gICAgICAgIGxpc3RlbmVyc1tpZF1bZXZlbnROYW1lXS5zb3J0KChhLCBiKSA9PiBiLnByaW9yaXR5IC0gYS5wcmlvcml0eSk7XG5cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIG1vdW50ZWQgZmxhZyBmb3IgbG9jYWwgZG9tRXZlbnQgbGlzdGVuZXJzXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICByZXNldE1vdW50ZWREb21MaXN0ZW5lcnMoY29tcG9uZW50KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgbGlzdGVuZXJzID0gbWUuaXRlbXNbY29tcG9uZW50LmlkXTtcblxuICAgICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhsaXN0ZW5lcnMpLmZvckVhY2goKFtldmVudE5hbWUsIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIHZhbHVlLmZvckVhY2goZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBldmVudE5hbWUgPSBldmVudC5ldmVudE5hbWU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSAhPT0gJ3Jlc2l6ZScgJiYgZXZlbnROYW1lICYmIChldmVudC5sb2NhbCB8fCAhZ2xvYmFsRG9tRXZlbnRzLmluY2x1ZGVzKGV2ZW50TmFtZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5tb3VudGVkID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY29uZmlnLmJ1YmJsZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcuZXZlbnROYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy5pZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcub3B0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcuc2NvcGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLnZub2RlSWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2NvcGVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpbiBjYXNlIHRoZSBsaXN0ZW5lciBkaWQgZXhpc3QgYW5kIGdvdCByZW1vdmVkXG4gICAgICovXG4gICAgdW5yZWdpc3Rlcihjb25maWcsIHNjb3BlKSB7XG4gICAgICAgIC8vIHRvZG9cbiAgICAgICAgY29uc29sZS5sb2coJ3VucmVnaXN0ZXInLCBjb25maWcpO1xuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmdlbmVyYXRlTGlzdGVuZXJDb25maWcoY29uZmlnLCBzY29wZSkpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgICAgbGV0IGxpc3RlbmVyID0gdGhpcy5nZXRMaXN0ZW5lcihjb25maWcpO1xuXG4gICAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2xpc3RlbmVyIGZvdW5kJywgbGlzdGVuZXIpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZG9tTGlzdGVuZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gb2xkRG9tTGlzdGVuZXJzXG4gICAgICovXG4gICAgdXBkYXRlRG9tTGlzdGVuZXJzKGNvbXBvbmVudCwgZG9tTGlzdGVuZXJzLCBvbGREb21MaXN0ZW5lcnMpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgcmVnaXN0ZXJlZExpc3RlbmVycyA9IG1lLml0ZW1zW2NvbXBvbmVudC5pZF0gfHwge30sXG4gICAgICAgICAgICBpLCBsZW4sIGxpc3RlbmVycztcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkb21MaXN0ZW5lcnMpKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvbGREb21MaXN0ZW5lcnMpKSB7XG4gICAgICAgICAgICAgICAgb2xkRG9tTGlzdGVuZXJzLmZvckVhY2gob2xkRG9tTGlzdGVuZXIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBmaW5kICYgcmVtb3ZlIG5vIGxvbmdlciBleGlzdGluZyBsaXN0ZW5lcnNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkb21MaXN0ZW5lcnMuaW5jbHVkZXMob2xkRG9tTGlzdGVuZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMgPSByZWdpc3RlcmVkTGlzdGVuZXJzW21lLmdldEV2ZW50TmFtZShvbGREb21MaXN0ZW5lcildIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSAgICAgICAgID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbiAgICAgICA9IGxpc3RlbmVycy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzW2ldLm9yaWdpbmFsQ29uZmlnID09PSBvbGREb21MaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUobGlzdGVuZXJzLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFkZCBuZXcgbGlzdGVuZXJzXG4gICAgICAgICAgICBkb21MaXN0ZW5lcnMuZm9yRWFjaChkb21MaXN0ZW5lciA9PiB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoZG9tTGlzdGVuZXIpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV2ZW50Q29uZmlnS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5yZWdpc3Rlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnViYmxlICAgICAgICA6IGRvbUxpc3RlbmVyLmJ1YmJsZSAgIHx8IHZhbHVlLmJ1YmJsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZSAgICAgIDogZG9tTGlzdGVuZXIuZGVsZWdhdGUgfHwgdmFsdWUuZGVsZWdhdGUgfHwgJyMnICsgKGNvbXBvbmVudC52ZG9tLmlkIHx8IGNvbXBvbmVudC5pZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnROYW1lICAgICA6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCAgICAgICAgICAgIDogY29tcG9uZW50LnZkb20uaWQgfHwgY29tcG9uZW50LmlkLCAvLyBob25vciB3cmFwcGVyIG5vZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0cyAgICAgICAgICA6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsQ29uZmlnOiBkb21MaXN0ZW5lcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvd25lcklkICAgICAgIDogY29tcG9uZW50LmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5ICAgICAgOiBkb21MaXN0ZW5lci5wcmlvcml0eSB8fCB2YWx1ZS5wcmlvcml0eSB8fCAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlICAgICAgICAgOiBkb21MaXN0ZW5lci5zY29wZSAgICB8fCBjb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdm5vZGVJZCAgICAgICA6IGRvbUxpc3RlbmVyLnZub2RlSWQgIHx8IHZhbHVlLnZub2RlSWQgIHx8IGNvbXBvbmVudC52ZG9tLmlkXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50Lm1vdW50ZWQgJiYgZG9tTGlzdGVuZXJzPy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lLm1vdW50VGltZW91dHNbY29tcG9uZW50LmlkXSkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQobWUubW91bnRUaW1lb3V0c1tjb21wb25lbnQuaWRdKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1lLm1vdW50VGltZW91dHNbY29tcG9uZW50LmlkXSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBtZS5tb3VudERvbUxpc3RlbmVycyhjb21wb25lbnQpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbWUubW91bnRUaW1lb3V0c1tjb21wb25lbnQuaWRdXG4gICAgICAgICAgICAgICAgfSwgNTApXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBMb2dnZXIubG9nRXJyb3IoJ0NvbXBvbmVudC5kb21MaXN0ZW5lcnMgaGF2ZSB0byBiZSBhbiBhcnJheScsIGNvbXBvbmVudClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIGlmIHRoZSBldmVudCB0YXJnZXQgKG9yIGEgZGVsZWdhdGUgbWF0Y2hpbmcgbm9kZSkgaXMgYSBkZXNjZW5kYW50IG9mIHRoZSBsaXN0ZW5lcidzIGNvbXBvbmVudC5cbiAgICAgKiBUaGlzIGNoZWNrIHN1cHBvcnRzIHR3byBtb2RlczpcbiAgICAgKiAxLiAqKkRPTSBBbmNlc3RyeSAoU3RhbmRhcmQpOioqIENoZWNrcyBpZiB0aGUgdGFyZ2V0IGlzIHBoeXNpY2FsbHkgaW5zaWRlIHRoZSBsaXN0ZW5lcidzIERPTSBub2RlLlxuICAgICAqIDIuICoqTG9naWNhbCBBbmNlc3RyeSAoRmFsbGJhY2spOioqIElmIHRoZSBET00gY2hlY2sgZmFpbHMsIGl0IGNoZWNrcyB0aGUgYGNvbXBvbmVudFBhdGhgIHRvIHNlZSBpZiB0aGVcbiAgICAgKiAgICB0YXJnZXQgYmVsb25ncyB0byBhIGNvbXBvbmVudCB0aGF0IGlzIGxvZ2ljYWxseSBhIGRlc2NlbmRhbnQgb2YgdGhlIGxpc3RlbmVyIGNvbXBvbmVudC5cbiAgICAgKiAgICBUaGlzIGlzIGNydWNpYWwgZm9yIGhhbmRsaW5nIGV2ZW50cyBmcm9tIGRldGFjaGVkIGNvbXBvbmVudHMgKFBvcnRhbHMvUHJveGllcykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbGlzdGVuZXJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoICAgICAgICAgICAgVGhlIHJhdyBET00gcGF0aCBmcm9tIHRoZSBldmVudFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb21wb25lbnRQYXRoXSBUaGUgbG9naWNhbCBjb21wb25lbnQgSUQgcGF0aFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufFN0cmluZ30gdHJ1ZS90YXJnZXRJZCBpbiBjYXNlIHRoZSBkZWxlZ2F0aW9uIHN0cmluZyBtYXRjaGVzIHRoZSBldmVudCBwYXRoXG4gICAgICovXG4gICAgdmVyaWZ5RGVsZWdhdGlvblBhdGgobGlzdGVuZXIsIHBhdGgsIGNvbXBvbmVudFBhdGgpIHtcbiAgICAgICAgbGV0IHtkZWxlZ2F0ZX0gPSBsaXN0ZW5lcixcbiAgICAgICAgICAgIGogICAgICAgICAgPSAwLFxuICAgICAgICAgICAgcGF0aExlbiAgICA9IHBhdGgubGVuZ3RoLFxuICAgICAgICAgICAgdGFyZ2V0SWQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkZWxlZ2F0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaiA9IGRlbGVnYXRlKHBhdGgpO1xuXG4gICAgICAgICAgICBpZiAoaiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0SWQgPSBwYXRoW2pdLmlkXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgZGVsZWdhdGlvbkFycmF5ID0gZGVsZWdhdGUuc3BsaXQoJyAnKSxcbiAgICAgICAgICAgICAgICBsZW4gICAgICAgICAgICAgPSBkZWxlZ2F0aW9uQXJyYXkubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGhhc01hdGNoLCBpLCBpdGVtLCBpc0lkO1xuXG4gICAgICAgICAgICBmb3IgKGk9bGVuLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgaGFzTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpdGVtICAgICA9IGRlbGVnYXRpb25BcnJheVtpXTtcbiAgICAgICAgICAgICAgICBpc0lkICAgICA9IGl0ZW0uc3RhcnRzV2l0aCgnIycpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzSWQgfHwgaXRlbS5zdGFydHNXaXRoKCcuJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IGl0ZW0uc3Vic3RyaW5nKDEpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICg7IGogPCBwYXRoTGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgKGlzSWQgJiYgcGF0aFtqXS5pZCA9PT0gaXRlbSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhbal0uY2xzLmluY2x1ZGVzKGl0ZW0pXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0SWQgPSBwYXRoW2pdLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghaGFzTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUGhhc2UgMTogUGh5c2ljYWwgQm91bmRhcnkgQ2hlY2sgKFRoZSBGYXN0IFBhdGgpXG4gICAgICAgIC8vIEVuc3VyZSB0aGUgZGVsZWdhdGlvbiBwYXRoIGlzIGEgY2hpbGQgb2YgdGhlIG93bmVyIGNvbXBvbmVudCdzIHJvb3Qgbm9kZSBpbiB0aGUgcGh5c2ljYWwgRE9NLlxuICAgICAgICAvLyBUaGlzIGNvdmVycyBzdGFuZGFyZCBpbmxpbmUgY29tcG9uZW50cyBhbmQgaXMgTyhOKS5cbiAgICAgICAgZm9yIChsZXQgayA9IGo7IGsgPCBwYXRoTGVuOyBrKyspIHtcbiAgICAgICAgICAgIGlmIChwYXRoW2tdLmlkID09PSBsaXN0ZW5lci52bm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldElkXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQaGFzZSAyOiBQaHlzaWNhbCBBbmNob3IgVmVyaWZpY2F0aW9uIChUaGUgTG9naWNhbCBGYWxsYmFjaylcbiAgICAgICAgLy8gSWYgdGhlIHBoeXNpY2FsIGNoZWNrIGZhaWxzIChsaXN0ZW5lciBub3QgaW4gcGF0aCksIHdlIGNoZWNrIHRoZSBsb2dpY2FsIGBjb21wb25lbnRQYXRoYC5cbiAgICAgICAgLy8gVGhlIGBjb21wb25lbnRQYXRoYCBzdGFydHMgd2l0aCB0aGUgXCJBbmNob3IgQ29tcG9uZW50XCIgLSB0aGUgZmlyc3QgY29tcG9uZW50IGZvdW5kIGluIHRoZSBwaHlzaWNhbCBwYXRoLlxuICAgICAgICAvLyBXZSBtdXN0IHZlcmlmeSB0aGF0IG91ciBgdGFyZ2V0SWRgIGlzIHBoeXNpY2FsbHkgaW5zaWRlIHRoaXMgQW5jaG9yIENvbXBvbmVudC5cbiAgICAgICAgLy8gSWYgaXQgaXMsIGFuZCB0aGUgQW5jaG9yIGlzIGxvZ2ljYWxseSBiZWxvdyB0aGUgTGlzdGVuZXIgKGd1YXJhbnRlZWQgaWYgd2UgYXJlIGhlcmUpLCB0aGVuIHRoZSBkZWxlZ2F0aW9uIGlzIHZhbGlkLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGlzIGhhbmRsZXM6XG4gICAgICAgIC8vIC0gUG9ydGFsczogQW5jaG9yIGlzIHRoZSBQb3J0YWwgQ2hpbGQuIFRhcmdldCBpcyBpbnNpZGUgUG9ydGFsIENoaWxkLiBBbmNob3IgLT4gUGFyZW50IChMaXN0ZW5lcikuIFZhbGlkLlxuICAgICAgICAvLyAtIE1lbnVzOiBBbmNob3IgaXMgU3ViTWVudS4gVGFyZ2V0IGlzIGluc2lkZSBTdWJNZW51LiBBbmNob3IgLT4gTWVudSAoTGlzdGVuZXIpLiBWYWxpZC5cbiAgICAgICAgLy8gLSBNdWx0aS1XaW5kb3c6IEFuY2hvciBpcyBWaWV3Qi4gVGFyZ2V0IGlzIGluc2lkZSBWaWV3Qi4gQW5jaG9yIC0+IFZpZXdBIChMaXN0ZW5lcikuIFZhbGlkLlxuICAgICAgICBpZiAoY29tcG9uZW50UGF0aD8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IGFuY2hvcklkID0gY29tcG9uZW50UGF0aFswXTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IHRhcmdldCBpcyBwaHlzaWNhbGx5IGluc2lkZSB0aGUgQW5jaG9yXG4gICAgICAgICAgICBmb3IgKGxldCBrID0gajsgayA8IHBhdGhMZW47IGsrKykge1xuICAgICAgICAgICAgICAgIGlmIChwYXRoW2tdLmlkID09PSBhbmNob3JJZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0SWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVsZWdhdGlvblRhcmdldElkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyB2ZXJpZnlNb3VzZUVudGVyTGVhdmUoY29tcG9uZW50LCBkYXRhLCBkZWxlZ2F0aW9uVGFyZ2V0SWQsIGV2ZW50TmFtZSkge1xuICAgICAgICBsZXQgdGFyZ2V0SWQgPSBldmVudE5hbWUgPT09ICdtb3VzZWVudGVyJyA/IGRhdGEuZnJvbUVsZW1lbnRJZCA6IGRhdGEudG9FbGVtZW50SWQsXG4gICAgICAgICAgICBkZWxlZ2F0aW9uVmRvbTtcblxuICAgICAgICBpZiAodGFyZ2V0SWQgJiYgdGFyZ2V0SWQgIT09IGRlbGVnYXRpb25UYXJnZXRJZCkge1xuICAgICAgICAgICAgZGVsZWdhdGlvblZkb20gPSBWRG9tVXRpbC5maW5kKGNvbXBvbmVudC52ZG9tLCBkZWxlZ2F0aW9uVGFyZ2V0SWQpO1xuXG4gICAgICAgICAgICAvLyBkZWxlZ2F0aW9uVmRvbSBjYW4gYmUgdW5kZWZpbmVkIHdoZW4gZHJhZ2dpbmcgYSBwcm94eSBvdmVyIHRoZSBub2RlLlxuICAgICAgICAgICAgLy8gc2VlIGlzc3Vlcy8xMTM3IGZvciBkZXRhaWxzLlxuICAgICAgICAgICAgaWYgKCFkZWxlZ2F0aW9uVmRvbSB8fCBkZWxlZ2F0aW9uVmRvbS52ZG9tICYmIFZEb21VdGlsLmZpbmQoZGVsZWdhdGlvblZkb20udmRvbSwgdGFyZ2V0SWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoRG9tRXZlbnQpO1xuIiwiaW1wb3J0IENvcmVCYXNlIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuaW1wb3J0IE5lb0FycmF5IGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLm1hbmFnZXIuRm9jdXNcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqIEBzaW5nbGV0b25cbiAqL1xuY2xhc3MgRm9jdXMgZXh0ZW5kcyBDb3JlQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ubWFuYWdlci5Gb2N1cydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLm1hbmFnZXIuRm9jdXMnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgY29udGFpbmluZyBvcHRzIG9iamVjdHMuXG4gICAgICAgICAqIG9wdHMuY29tcG9uZW50UGF0aFxuICAgICAgICAgKiBvcHRzLmRhdGFcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0W119IGhpc3Rvcnk9W11cbiAgICAgICAgICovXG4gICAgICAgIGhpc3Rvcnk6IFtdLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIERhdGUgb2JqZWN0IHdoZW4gdGhlIGxhc3QgZm9jdXNpbiBldmVudCBoYXMgb2NjdXJyZWRcbiAgICAgICAgICogQG1lbWJlciB7RGF0ZXxudWxsfSBsYXN0Rm9jdXNJbkRhdGU9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBsYXN0Rm9jdXNJbkRhdGU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgRGF0ZSBvYmplY3Qgd2hlbiB0aGUgbGFzdCBmb2N1c291dCBldmVudCBoYXMgb2NjdXJyZWRcbiAgICAgICAgICogQG1lbWJlciB7RGF0ZXxudWxsfSBsYXN0Rm9jdXNJbkRhdGU9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBsYXN0Rm9jdXNPdXREYXRlOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFtb3VudCBvZiB0aW1lIGZvciBhIGZvY3VzSW4gdG8gb2NjdXIgYWZ0ZXIgdGhlIGxhc3QgZm9jdXNPdXRcbiAgICAgICAgICogdG8gZ2V0IGNvbWJpbmVkIGludG8gYSBmb2N1c21vdmUgZXZlbnQuXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gbWF4Rm9jdXNJbk91dEdhcD01MFxuICAgICAgICAgKi9cbiAgICAgICAgbWF4Rm9jdXNJbk91dEdhcDogNTAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWF4aW11bSBhbW91bnQgb2YgaXRlbXMgc3RvcmVkIGluc2lkZSB0aGUgaGlzdG9yeSBhcnJheVxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IG1heEhpc3RvcnlMZW5ndGg9MjBcbiAgICAgICAgICovXG4gICAgICAgIG1heEhpc3RvcnlMZW5ndGg6IDIwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2luZ2xldG9uPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2luZ2xldG9uOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgb3B0cy5jb21wb25lbnRQYXRoIENvbXBvbmVudCBpZHMgdXB3YXJkc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmRhdGEgZG9tIGV2ZW50IGluZm9zXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFkZFRvSGlzdG9yeShvcHRzKSB7XG4gICAgICAgIGxldCBoaXN0b3J5ID0gdGhpcy5oaXN0b3J5O1xuXG4gICAgICAgIGhpc3RvcnkudW5zaGlmdChvcHRzKTtcbiAgICAgICAgaGlzdG9yeS5sZW5ndGggPj0gdGhpcy5tYXhIaXN0b3J5TGVuZ3RoICYmIGhpc3RvcnkucG9wKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9ICBvcHRzLmNvbXBvbmVudFBhdGggQ29tcG9uZW50IGlkcyB1cHdhcmRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuZGF0YSBkb20gZXZlbnQgaW5mb3NcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZm9jdXNFbnRlcihvcHRzKSB7XG4gICAgICAgIHRoaXMuc2V0Q29tcG9uZW50Rm9jdXMob3B0cywgdHJ1ZSk7XG4gICAgICAgIHRoaXMuYWRkVG9IaXN0b3J5KG9wdHMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgb3B0cy5jb21wb25lbnRQYXRoIENvbXBvbmVudCBpZHMgdXB3YXJkc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmRhdGEgZG9tIGV2ZW50IGluZm9zXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGZvY3VzTGVhdmUob3B0cykge1xuICAgICAgICB0aGlzLnNldENvbXBvbmVudEZvY3VzKG9wdHMsIGZhbHNlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtBcnJheX0gIG9wdHMuY29tcG9uZW50UGF0aCBDb21wb25lbnQgaWRzIHVwd2FyZHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5kYXRhIGRvbSBldmVudCBpbmZvc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBmb2N1c01vdmUob3B0cykge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7aGlzdG9yeX0gICAgICAgID0gbWUsXG4gICAgICAgICAgICBuZXdDb21wb25lbnRQYXRoID0gb3B0cy5jb21wb25lbnRQYXRoLFxuICAgICAgICAgICAgb2xkQ29tcG9uZW50UGF0aCA9IGhpc3RvcnlbMF0uY29tcG9uZW50UGF0aCxcbiAgICAgICAgICAgIGZvY3VzRW50ZXIgICAgICAgPSBOZW9BcnJheS5kaWZmZXJlbmNlKG5ld0NvbXBvbmVudFBhdGgsIG9sZENvbXBvbmVudFBhdGgpLFxuICAgICAgICAgICAgZm9jdXNMZWF2ZSAgICAgICA9IE5lb0FycmF5LmRpZmZlcmVuY2Uob2xkQ29tcG9uZW50UGF0aCwgbmV3Q29tcG9uZW50UGF0aCksXG4gICAgICAgICAgICBmb2N1c01vdmUgICAgICAgID0gTmVvQXJyYXkuaW50ZXJzZWN0aW9uKG5ld0NvbXBvbmVudFBhdGgsIG9sZENvbXBvbmVudFBhdGgpLFxuICAgICAgICAgICAgY29tcG9uZW50LCBkYXRhO1xuXG4gICAgICAgIG1lLnNldENvbXBvbmVudEZvY3VzKHtjb21wb25lbnRQYXRoOiBmb2N1c0xlYXZlLCBkYXRhOiBvcHRzLmRhdGF9LCBmYWxzZSk7XG4gICAgICAgIG1lLnNldENvbXBvbmVudEZvY3VzKHtjb21wb25lbnRQYXRoOiBmb2N1c0VudGVyLCBkYXRhOiBvcHRzLmRhdGF9LCB0cnVlKTtcblxuICAgICAgICBmb2N1c01vdmUuZm9yRWFjaChpZCA9PiB7XG4gICAgICAgICAgICBjb21wb25lbnQgPSBOZW8uZ2V0Q29tcG9uZW50KGlkKTtcblxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICAgICAgcGF0aCAgIDogb3B0cy5kYXRhLnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIG9sZFBhdGg6IGhpc3RvcnlbMF0uZGF0YS5wYXRoXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5vbkZvY3VzTW92ZT8uKGRhdGEpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5maXJlKCdmb2N1c01vdmUnLCBkYXRhKTtcblxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5vbkZvY3VzQ2hhbmdlPy4oZGF0YSk7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LmZpcmUoJ2ZvY3VzQ2hhbmdlJywgZGF0YSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUuYWRkVG9IaXN0b3J5KG9wdHMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgb3B0cy5jb21wb25lbnRQYXRoIENvbXBvbmVudCBpZHMgdXB3YXJkc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmRhdGEgZG9tIGV2ZW50IGluZm9zXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uRm9jdXNpbihvcHRzKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUubGFzdEZvY3VzSW5EYXRlID0gbmV3IERhdGUoKTtcblxuICAgICAgICBpZiAobWUubGFzdEZvY3VzT3V0RGF0ZSAmJiBtZS5sYXN0Rm9jdXNJbkRhdGUgLSBtZS5sYXN0Rm9jdXNPdXREYXRlIDwgbWUubWF4Rm9jdXNJbk91dEdhcCkge1xuICAgICAgICAgICAgbWUuZm9jdXNNb3ZlKG9wdHMpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5mb2N1c0VudGVyKG9wdHMpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9ICBvcHRzLmNvbXBvbmVudFBhdGggQ29tcG9uZW50IGlkcyB1cHdhcmRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuZGF0YSBkb20gZXZlbnQgaW5mb3NcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25Gb2N1c291dChvcHRzKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUubGFzdEZvY3VzT3V0RGF0ZSA9IG5ldyBEYXRlKCk7XG5cbiAgICAgICAgbWUudGltZW91dChtZS5tYXhGb2N1c0luT3V0R2FwKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChtZS5sYXN0Rm9jdXNPdXREYXRlID4gbWUubGFzdEZvY3VzSW5EYXRlKSB7XG4gICAgICAgICAgICAgICAgbWUuZm9jdXNMZWF2ZShvcHRzKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtBcnJheX0gIG9wdHMuY29tcG9uZW50UGF0aCBDb21wb25lbnQgaWRzIHVwd2FyZHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5kYXRhIGRvbSBldmVudCBpbmZvc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY29udGFpbnNGb2N1c1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZXRDb21wb25lbnRGb2N1cyhvcHRzLCBjb250YWluc0ZvY3VzKSB7XG4gICAgICAgIGxldCBkYXRhID0ge1xuICAgICAgICAgICAgICAgIHJlbGF0ZWRUYXJnZXQ6IG9wdHMuZGF0YS5yZWxhdGVkVGFyZ2V0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29tcG9uZW50cyA9IG9wdHMuY29tcG9uZW50UGF0aC5tYXAoaWQgPT4gTmVvLmdldENvbXBvbmVudChpZCkpLFxuICAgICAgICAgICAgaGFuZGxlcjtcblxuICAgICAgICBjb21wb25lbnRzLmZvckVhY2goY29tcG9uZW50ID0+IHtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuY29udGFpbnNGb2N1cyA9IGNvbnRhaW5zRm9jdXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29tcG9uZW50cy5mb3JFYWNoKGNvbXBvbmVudCA9PiB7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgZGF0YS5jb21wb25lbnQgPSBjb21wb25lbnQ7XG5cbiAgICAgICAgICAgICAgICBkYXRhW2NvbnRhaW5zRm9jdXMgPyAncGF0aCcgOiAnb2xkUGF0aCddID0gb3B0cy5kYXRhLnBhdGhcblxuICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBjb250YWluc0ZvY3VzID8gJ29uRm9jdXNFbnRlcicgOiAnb25Gb2N1c0xlYXZlJztcbiAgICAgICAgICAgICAgICBjb21wb25lbnRbaGFuZGxlcl0/LihkYXRhKTtcblxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5maXJlKGNvbnRhaW5zRm9jdXMgPyAnZm9jdXNFbnRlcicgOiAnZm9jdXNMZWF2ZScsIGRhdGEpO1xuXG4gICAgICAgICAgICAgICAgY29tcG9uZW50Lm9uRm9jdXNDaGFuZ2U/LihkYXRhKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuZmlyZSgnZm9jdXNDaGFuZ2UnLCBkYXRhKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoRm9jdXMpO1xuIiwiaW1wb3J0IENvbGxlY3Rpb24gZnJvbSAnLi4vY29sbGVjdGlvbi9CYXNlLm1qcyc7XG5cbi8qKlxuICogVGhlIFZEb21VcGRhdGUgbWFuYWdlciBpcyBhIHNpbmdsZXRvbiByZXNwb25zaWJsZSBmb3Igb3JjaGVzdHJhdGluZyBhbmQgb3B0aW1pemluZ1xuICogY29tcG9uZW50IFZET00gdXBkYXRlcyB3aXRoaW4gdGhlIE5lby5tanMgZnJhbWV3b3JrLiBJdCBhY3RzIGFzIGEgY2VudHJhbCBjb29yZGluYXRvclxuICogdG8gb3B0aW1pemUgdGhlIFZET00gdXBkYXRlIHByb2Nlc3MuIEl0cyBwcmltYXJ5IGdvYWwgaXMgdG8gcmVkdWNlIHRoZSBhbW91bnQgb2ZcbiAqIG1lc3NhZ2Ugcm91bmR0cmlwcyBiZXR3ZWVuIHRoZSBhcHBsaWNhdGlvbiBhbmQgVkRPTSB3b3JrZXJzIGJ5IGFnZ3JlZ2F0aW5nIG11bHRpcGxlXG4gKiBjb21wb25lbnQgdXBkYXRlcyBpbnRvIGEgc2luZ2xlLCBvcHRpbWl6ZWQgVkRPTSB0cmVlLlxuICpcbiAqIEtleSBSZXNwb25zaWJpbGl0aWVzOlxuICogMS4gKipVcGRhdGUgTWVyZ2luZyAmIEFnZ3JlZ2F0aW9uOioqIEFsbG93cyBhIHBhcmVudCBjb21wb25lbnQgdG8gYWJzb3JiIHRoZSB1cGRhdGVcbiAqICAgIHJlcXVlc3RzIG9mIGl0cyBjaGlsZHJlbi4gSW5zdGVhZCBvZiBlYWNoIGNoaWxkIHRyaWdnZXJpbmcgYSBzZXBhcmF0ZSBWRE9NIHVwZGF0ZVxuICogICAgbWVzc2FnZSB0byB0aGUgVkRPTSB3b3JrZXIsIHRoZSBwYXJlbnQgc2VuZHMgYSBzaW5nbGUsIGFnZ3JlZ2F0ZWQgVkRPTSB0cmVlLiBUaGlzXG4gKiAgICBzaWduaWZpY2FudGx5IHJlZHVjZXMgdGhlIG92ZXJoZWFkIG9mIHdvcmtlciBjb21tdW5pY2F0aW9uIGFuZCBjYW4gcmVzdWx0IGluIHNtYWxsZXIsXG4gKiAgICBtb3JlIGZvY3VzZWQgZGF0YSBmb3IgdGhlIFZET00gd29ya2VyIHRvIHByb2Nlc3MuIFdoaWxlIHRoZSBhbW91bnQgb2YgZmluYWwgRE9NXG4gKiAgICBtb2RpZmljYXRpb25zIHJlbWFpbnMgdGhlIHNhbWUsIHRoaXMgYWdncmVnYXRpb24gaXMga2V5IHRvIHBlcmZvcm1hbmNlLlxuICpcbiAqICAgICoqVGVsZXBvcnRhdGlvbiAoRGlzam9pbnQgVXBkYXRlcyk6KiogVGhlIG1hbmFnZXIgbm93IHN1cHBvcnRzIHByb2Nlc3NpbmcgbXVsdGlwbGVcbiAqICAgIGRpc2pvaW50IGNvbXBvbmVudHMgaW4gYSBzaW5nbGUgXCJUZWxlcG9ydGF0aW9uXCIgYmF0Y2guIFRoaXMgYWxsb3dzIGRlZXAgZGVzY2VuZGFudHNcbiAqICAgIHRvIHVwZGF0ZSBpbiBwYXJhbGxlbCB3aXRoIHRoZWlyIGFuY2VzdG9ycyB3aXRob3V0IHJlcXVpcmluZyB0aGUgYW5jZXN0b3IgdG8gXCJicmlkZ2VcIlxuICogICAgdGhlIGdhcCwgZWxpbWluYXRpbmcgTyhOKSBvdmVyaGVhZCBmb3IgZGVlcCB1cGRhdGVzLlxuICpcbiAqIDIuICoqQXN5bmNocm9ub3VzIEZsb3cgQ29udHJvbDoqKiBNYW5hZ2VzIHRoZSBhc3luY2hyb25vdXMgbmF0dXJlIG9mIFZET00gdXBkYXRlcywgd2hpY2hcbiAqICAgIGFyZSBvZnRlbiBwcm9jZXNzZWQgaW4gYSB3b3JrZXIgdGhyZWFkLiBJdCBlbnN1cmVzIHRoYXQgY29kZSBhd2FpdGluZyBhbiB1cGRhdGVcbiAqICAgIChlLmcuLCB2aWEgYSByZXR1cm5lZCBQcm9taXNlKSBpcyBjb3JyZWN0bHkgbm90aWZpZWQgdXBvbiBjb21wbGV0aW9uLlxuICpcbiAqIDMuICoqRGVwZW5kZW5jeSBDaGFpbmluZzoqKiBQcm92aWRlcyBhIFwicG9zdC11cGRhdGVcIiBxdWV1ZSwgYWxsb3dpbmcgb25lIGNvbXBvbmVudCdzXG4gKiAgICB1cGRhdGUgdG8gYmUgZGVjbGFyYXRpdmVseSBjaGFpbmVkIHRvIGFub3RoZXIncywgZW5zdXJpbmcgYSBwcmVkaWN0YWJsZSBvcmRlciBvZlxuICogICAgb3BlcmF0aW9ucy5cbiAqXG4gKiA0LiAqKlN0YXRlIFRyYWNraW5nOioqIEtlZXBzIHRyYWNrIG9mIHVwZGF0ZXMgdGhhdCBhcmUgXCJpbi1mbGlnaHRcIiAoaS5lLiwgY3VycmVudGx5XG4gKiAgICBiZWluZyBwcm9jZXNzZWQpLCB3aGljaCBoZWxwcyB0byBhdm9pZCByYWNlIGNvbmRpdGlvbnMgYW5kIHJlZHVuZGFudCB3b3JrLlxuICpcbiAqIEJ5IGNlbnRyYWxpemluZyB0aGVzZSBjb25jZXJucywgVkRvbVVwZGF0ZSBwbGF5cyBhIGNyaXRpY2FsIHJvbGUgaW4gdGhlIGZyYW1ld29yaydzXG4gKiBwZXJmb3JtYW5jZSBhbmQgcmVuZGVyaW5nIGVmZmljaWVuY3kuXG4gKlxuICogQGNsYXNzIE5lby5tYW5hZ2VyLlZEb21VcGRhdGVcbiAqIEBleHRlbmRzIE5lby5jb2xsZWN0aW9uLkJhc2VcbiAqIEBzaW5nbGV0b25cbiAqL1xuY2xhc3MgVkRvbVVwZGF0ZSBleHRlbmRzIENvbGxlY3Rpb24ge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLm1hbmFnZXIuVkRvbVVwZGF0ZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLm1hbmFnZXIuVkRvbVVwZGF0ZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGNvbGxlY3Rpb24gdGhhdCBtYXBzIGEgcGFyZW50IGNvbXBvbmVudCdzIElEIChgb3duZXJJZGApIHRvIHRoZSBzZXQgb2YgY2hpbGRcbiAgICAgICAgICogY29tcG9uZW50cyB3aG9zZSBWRE9NIHVwZGF0ZXMgaGF2ZSBiZWVuIG1lcmdlZCBpbnRvIHRoYXQgcGFyZW50J3MgdXBkYXRlIGN5Y2xlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgc3RydWN0dXJlIGZvciBlYWNoIGVudHJ5IGlzOlxuICAgICAgICAgKiBgeyBvd25lcklkOiAncGFyZW50LWlkJywgY2hpbGRyZW46IE1hcDwnY2hpbGQtaWQnLCB7Y2hpbGRVcGRhdGVEZXB0aCwgZGlzdGFuY2V9PiB9YFxuICAgICAgICAgKlxuICAgICAgICAgKiAtIGBvd25lcklkYDogVGhlIGBpZGAgb2YgdGhlIHBhcmVudCBjb21wb25lbnQgdGFraW5nIHJlc3BvbnNpYmlsaXR5IGZvciB0aGUgdXBkYXRlLlxuICAgICAgICAgKiAtIGBjaGlsZHJlbmA6IEEgTWFwIHdoZXJlIGtleXMgYXJlIHRoZSBgaWRgcyBvZiB0aGUgbWVyZ2VkIGNoaWxkcmVuIGFuZCB2YWx1ZXNcbiAgICAgICAgICogICBhcmUgb2JqZWN0cyBjb250YWluaW5nIG1ldGFkYXRhIG5lZWRlZCB0byBjYWxjdWxhdGUgdGhlIHRvdGFsIHVwZGF0ZSBzY29wZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbGxlY3Rpb24uQmFzZXxudWxsfSBtZXJnZWRDYWxsYmFja01hcD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG1lcmdlZENhbGxiYWNrTWFwOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQSBjb2xsZWN0aW9uIHRoYXQgcXVldWVzIGNvbXBvbmVudHMgdGhhdCBuZWVkIHRvIGJlIHVwZGF0ZWQgaW1tZWRpYXRlbHkgYWZ0ZXJcbiAgICAgICAgICogYW5vdGhlciBjb21wb25lbnQncyB1cGRhdGUgY3ljbGUgY29tcGxldGVzLiBUaGlzIGlzIHVzZWQgdG8gaGFuZGxlIHJlbmRlcmluZ1xuICAgICAgICAgKiBkZXBlbmRlbmNpZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBzdHJ1Y3R1cmUgZm9yIGVhY2ggZW50cnkgaXM6XG4gICAgICAgICAqIGB7IG93bmVySWQ6ICdjb21wb25lbnQtaWQnLCBjaGlsZHJlbjogW3tjaGlsZElkLCByZXNvbHZlfV0gfWBcbiAgICAgICAgICpcbiAgICAgICAgICogLSBgb3duZXJJZGA6IFRoZSBgaWRgIG9mIHRoZSBjb21wb25lbnQgd2hvc2UgdXBkYXRlIGNvbXBsZXRpb24gd2lsbCB0cmlnZ2VyIHRoZSBxdWV1ZWQgdXBkYXRlcy5cbiAgICAgICAgICogLSBgY2hpbGRyZW5gOiBBbiBhcnJheSBvZiBvYmplY3RzLCB3aGVyZSBgY2hpbGRJZGAgaXMgdGhlIGNvbXBvbmVudCB0byB1cGRhdGUgYW5kXG4gICAgICAgICAqICAgYHJlc29sdmVgIGlzIHRoZSBQcm9taXNlIHJlc29sdmVyIHRvIGNhbGwgYWZ0ZXIgdGhhdCBzdWJzZXF1ZW50IHVwZGF0ZSBpcyBkb25lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29sbGVjdGlvbi5CYXNlfG51bGx9IHBvc3RVcGRhdGVRdWV1ZU1hcD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHBvc3RVcGRhdGVRdWV1ZU1hcDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZXRvbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZXRvbjogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgTWFwIHRoYXQgdHJhY2tzIHRoZSBpbi1mbGlnaHQgdXBkYXRlIHN0YXR1cyBvZiBkZXNjZW5kYW50cyBmb3IgZWFjaCBjb21wb25lbnQuXG4gICAgICogVGhpcyBcIlJldmVyc2UgTG9va3VwXCIgbWFwIGFsbG93cyBhbmNlc3RvciBjb21wb25lbnRzIHRvIGNoZWNrIGlmIGFueSBvZiB0aGVpclxuICAgICAqIGRlc2NlbmRhbnRzIGFyZSBjdXJyZW50bHkgdXBkYXRpbmcgaW4gTygxKSB0aW1lLCB3aXRob3V0IHdhbGtpbmcgdGhlIHRyZWUgZG93bndhcmRzLlxuICAgICAqXG4gICAgICogS2V5OiBhbmNlc3RvcklkLCBWYWx1ZTogTWFwPGRlc2NlbmRhbnRJZCwgdHJ1ZT5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgY3J1Y2lhbCBmb3IgdGhlIGBWZG9tTGlmZWN5Y2xlLmlzQ2hpbGRVcGRhdGluZ2AgZ3VhcmQsIHdoaWNoIHByZXZlbnRzXG4gICAgICogcmFjZSBjb25kaXRpb25zIHdoZXJlIGEgcGFyZW50IHVwZGF0ZSBtaWdodCBjbG9iYmVyIGEgY29uY3VycmVudCBjaGlsZCB1cGRhdGUuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtNYXA8U3RyaW5nLCBNYXA8U3RyaW5nLCBCb29sZWFuPj59IGRlc2NlbmRhbnRJbkZsaWdodE1hcD1uZXcgTWFwKClcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZGVzY2VuZGFudEluRmxpZ2h0TWFwID0gbmV3IE1hcCgpXG4gICAgLyoqXG4gICAgICogQSBNYXAgdGhhdCB0cmFja3MgVkRPTSB1cGRhdGVzIHRoYXQgaGF2ZSBiZWVuIGRpc3BhdGNoZWQgdG8gdGhlIFZET00gd29ya2VyIGJ1dFxuICAgICAqIGhhdmUgbm90IHlldCBjb21wbGV0ZWQuIFRoaXMgcHJldmVudHMgcmVkdW5kYW50IHVwZGF0ZXMgZm9yIHRoZSBzYW1lIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIFRoZSBzdHJ1Y3R1cmUgaXM6IGBNYXA8J2NvbXBvbmVudC1pZCcsIHVwZGF0ZURlcHRoPmBcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge01hcHxudWxsfSBpbkZsaWdodFVwZGF0ZU1hcD1udWxsXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGluRmxpZ2h0VXBkYXRlTWFwID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBBIE1hcCB0aGF0IHN0b3JlcyBjYWxsYmFja3MgdG8gYmUgZXhlY3V0ZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgYSBjb21wb25lbnQncyBWRE9NIHVwZGF0ZVxuICAgICAqIGZpbmlzaGVzLCBidXQgQkVGT1JFIHRoZSBgbmVlZHNWZG9tVXBkYXRlYCBjaGVjayBmb3IgdGhlIG5leHQgY3ljbGUuXG4gICAgICpcbiAgICAgKiBLZXk6IGNvbXBvbmVudElkLCBWYWx1ZTogY2FsbGJhY2sgRnVuY3Rpb25cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge01hcDxTdHJpbmcsIEZ1bmN0aW9uPn0gcHJlVXBkYXRlTWFwPW5ldyBNYXAoKVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwcmVVcGRhdGVNYXAgPSBuZXcgTWFwKClcbiAgICAvKipcbiAgICAgKiBBIE1hcCB0aGF0IHN0b3JlcyBQcm9taXNlIGByZXNvbHZlYCBmdW5jdGlvbnMgYXNzb2NpYXRlZCB3aXRoIGEgY29tcG9uZW50J3MgdXBkYXRlLlxuICAgICAqIFdoZW4gYSBjb21wb25lbnQncyBWRE9NIHVwZGF0ZSBpcyBmaW5hbGl6ZWQsIHRoZSBjYWxsYmFja3MgZm9yIGl0cyBJRCBhcmUgZXhlY3V0ZWQsXG4gICAgICogcmVzb2x2aW5nIHRoZSBQcm9taXNlIHJldHVybmVkIGJ5IHRoZSBjb21wb25lbnQncyBgdXBkYXRlKClgIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIFRoZSBzdHJ1Y3R1cmUgaXM6IGBNYXA8J2NvbXBvbmVudC1pZCcsIFtjYWxsYmFjazEsIGNhbGxiYWNrMiwgLi4uXT5gXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtNYXB8bnVsbH0gcHJvbWlzZUNhbGxiYWNrTWFwPW51bGxcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcHJvbWlzZUNhbGxiYWNrTWFwID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBtYW5hZ2VyJ3MgaW50ZXJuYWwgY29sbGVjdGlvbnMgYW5kIG1hcHMuXG4gICAgICogVGhpcyBpcyBjYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIHRoZSBzaW5nbGV0b24gaW5zdGFuY2UgaXMgY3JlYXRlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuaW5GbGlnaHRVcGRhdGVNYXAgID0gbmV3IE1hcCgpO1xuICAgICAgICBtZS5tZXJnZWRDYWxsYmFja01hcCAgPSBOZW8uY3JlYXRlKENvbGxlY3Rpb24sIHtrZXlQcm9wZXJ0eTogJ293bmVySWQnfSk7XG4gICAgICAgIG1lLnBvc3RVcGRhdGVRdWV1ZU1hcCA9IE5lby5jcmVhdGUoQ29sbGVjdGlvbiwge2tleVByb3BlcnR5OiAnb3duZXJJZCd9KTtcbiAgICAgICAgbWUucHJvbWlzZUNhbGxiYWNrTWFwID0gbmV3IE1hcCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIHdoZW4gYSBzcGVjaWZpYyBjb21wb25lbnQnc1xuICAgICAqIFZET00gdXBkYXRlIGNvbXBsZXRlcy4gVGhpcyBpcyB0aGUgbWVjaGFuaXNtIHRoYXQgcmVzb2x2ZXMgdGhlIFByb21pc2VcbiAgICAgKiByZXR1cm5lZCBieSBgQ29tcG9uZW50I3VwZGF0ZSgpYC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICBvd25lcklkICBUaGUgYGlkYCBvZiB0aGUgY29tcG9uZW50IG93bmluZyB0aGUgdXBkYXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBleGVjdXRlIHVwb24gY29tcGxldGlvbi5cbiAgICAgKi9cbiAgICBhZGRQcm9taXNlQ2FsbGJhY2sob3duZXJJZCwgY2FsbGJhY2spIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIW1lLnByb21pc2VDYWxsYmFja01hcC5oYXMob3duZXJJZCkpIHtcbiAgICAgICAgICAgIG1lLnByb21pc2VDYWxsYmFja01hcC5zZXQob3duZXJJZCwgW10pXG4gICAgICAgIH1cblxuICAgICAgICBtZS5wcm9taXNlQ2FsbGJhY2tNYXAuZ2V0KG93bmVySWQpLnB1c2goY2FsbGJhY2spXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgYWxsIGNhbGxiYWNrcyBhc3NvY2lhdGVkIHdpdGggYSBjb21wbGV0ZWQgVkRPTSB1cGRhdGUgZm9yIGEgZ2l2ZW4gYG93bmVySWRgLlxuICAgICAqIFRoaXMgbWV0aG9kIGZpcnN0IHByb2Nlc3NlcyBjYWxsYmFja3MgZm9yIGFueSBjaGlsZHJlbiB0aGF0IHdlcmUgbWVyZ2VkIGludG8gdGhpc1xuICAgICAqIHVwZGF0ZSBjeWNsZSwgdGhlbiBleGVjdXRlcyB0aGUgY2FsbGJhY2tzIGZvciB0aGUgYG93bmVySWRgIGl0c2VsZi5cbiAgICAgKlxuICAgICAqICoqVGVsZXBvcnRhdGlvbiAvIEJhdGNoIFN1cHBvcnQ6KipcbiAgICAgKiBUaGUgYHByb2Nlc3NlZENoaWxkSWRzYCBhcmd1bWVudCBpcyBjcnVjaWFsIGZvciBEaXNqb2ludCBVcGRhdGVzLiBJdCBlbnN1cmVzIHdlIG9ubHlcbiAgICAgKiBleGVjdXRlIGNhbGxiYWNrcyBmb3IgY2hpbGRyZW4gdGhhdCB3ZXJlICphY3R1YWxseSogaW5jbHVkZWQgaW4gdGhlIFZET00gcGF5bG9hZC5cbiAgICAgKiBDaGlsZHJlbiB0aGF0IHdlcmUgZmlsdGVyZWQgb3V0IChlLmcuIGR1ZSB0byBjb2xsaXNpb25zIHdpdGggYSBwYXJlbnQgdXBkYXRlKSB3aWxsXG4gICAgICogTk9UIGhhdmUgdGhlaXIgY2FsbGJhY2tzIGV4ZWN1dGVkIGhlcmU7IHRoZXkgd2lsbCBiZSBoYW5kbGVkIGJ5IHRoZSBjb3ZlcmluZyBwYXJlbnQncyBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvd25lcklkIFRoZSBgaWRgIG9mIHRoZSBjb21wb25lbnQgd2hvc2UgdXBkYXRlIGhhcyBqdXN0IGNvbXBsZXRlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2RhdGFdICBPcHRpb25hbCBkYXRhIHRvIHBhc3MgdG8gdGhlIGNhbGxiYWNrcy5cbiAgICAgKiBAcGFyYW0ge1NldDxTdHJpbmc+fG51bGx9IFtwcm9jZXNzZWRDaGlsZElkc10gSURzIG9mIGNoaWxkcmVuIGFjdHVhbGx5IGluY2x1ZGVkIGluIHRoaXMgdXBkYXRlLlxuICAgICAqL1xuICAgIGV4ZWN1dGVDYWxsYmFja3Mob3duZXJJZCwgZGF0YSwgcHJvY2Vzc2VkQ2hpbGRJZHMpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtICAgICAgICAgPSBtZS5tZXJnZWRDYWxsYmFja01hcC5nZXQob3duZXJJZCksXG4gICAgICAgICAgICBjYWxsYmFja0RhdGEgPSBkYXRhID8gW2RhdGFdIDogW107XG5cbiAgICAgICAgaWYgKGl0ZW0gJiYgcHJvY2Vzc2VkQ2hpbGRJZHMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGRJZCBvZiBwcm9jZXNzZWRDaGlsZElkcykge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmNoaWxkcmVuLmhhcyhjaGlsZElkKSkge1xuICAgICAgICAgICAgICAgICAgICBtZS5leGVjdXRlUHJvbWlzZUNhbGxiYWNrcyhjaGlsZElkLCAuLi5jYWxsYmFja0RhdGEpO1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmNoaWxkcmVuLmRlbGV0ZShjaGlsZElkKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGl0ZW0uY2hpbGRyZW4uc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG1lLm1lcmdlZENhbGxiYWNrTWFwLnJlbW92ZShvd25lcklkKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWUuZXhlY3V0ZVByb21pc2VDYWxsYmFja3Mob3duZXJJZCwgLi4uY2FsbGJhY2tEYXRhKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhbmQgZXhlY3V0ZXMgdGhlIHJlZ2lzdGVyZWQgUHJlLVVwZGF0ZSBjYWxsYmFjayBmb3IgYSBjb21wb25lbnQuXG4gICAgICogVGhpcyBpcyBjYWxsZWQgYnkgVmRvbUxpZmVjeWNsZSBqdXN0IGJlZm9yZSBjaGVja2luZyBgbmVlZHNWZG9tVXBkYXRlYC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgVGhlIGNvbXBvbmVudCBJRC5cbiAgICAgKi9cbiAgICBleGVjdXRlUHJlVXBkYXRlcyhpZCkge1xuICAgICAgICBsZXQgY2FsbGJhY2sgPSB0aGlzLnByZVVwZGF0ZU1hcC5nZXQoaWQpO1xuXG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5wcmVVcGRhdGVNYXAuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgaGVscGVyIG1ldGhvZCB0aGF0IGludm9rZXMgYWxsIHJlZ2lzdGVyZWQgcHJvbWlzZSBjYWxsYmFja3MgZm9yIGEgZ2l2ZW5cbiAgICAgKiBjb21wb25lbnQgSUQgYW5kIHRoZW4gY2xlYXJzIHRoZW0gZnJvbSB0aGUgcXVldWUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG93bmVySWQgVGhlIGBpZGAgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2RhdGFdICBPcHRpb25hbCBkYXRhIHRvIHBhc3MgdG8gdGhlIGNhbGxiYWNrcy5cbiAgICAgKi9cbiAgICBleGVjdXRlUHJvbWlzZUNhbGxiYWNrcyhvd25lcklkLCBkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY2FsbGJhY2tzID0gbWUucHJvbWlzZUNhbGxiYWNrTWFwLmdldChvd25lcklkKTtcblxuICAgICAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzW2ldKGRhdGEpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZS5wcm9taXNlQ2FsbGJhY2tNYXAuZGVsZXRlKG93bmVySWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgcmVxdWlyZWQgYHVwZGF0ZURlcHRoYCBmb3IgYSBwYXJlbnQgY29tcG9uZW50IGJhc2VkIG9uIGl0cyBvd25cbiAgICAgKiBuZWVkcyBhbmQgdGhlIG5lZWRzIG9mIGFsbCBjaGlsZCBjb21wb25lbnRzIHdob3NlIHVwZGF0ZXMgaGF2ZSBiZWVuIG1lcmdlZCBpbnRvIGl0LlxuICAgICAqIFRoZSBmaW5hbCBkZXB0aCBpcyB0aGUgbWF4aW11bSByZXF1aXJlZCBkZXB0aCB0byBlbnN1cmUgYWxsIGNoYW5nZXMgYXJlIHJlbmRlcmVkLlxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGUsIGlmIGEgcGFyZW50IG5lZWRzIHRvIHVwZGF0ZSBpdHMgZGlyZWN0IGNvbnRlbnQgKGB1cGRhdGVEZXB0aDogMWApIGJ1dFxuICAgICAqIGEgbWVyZ2VkIGNoaWxkIDMgbGV2ZWxzIGRvd24gbmVlZHMgYSBmdWxsIHN1YnRyZWUgdXBkYXRlIChgY2hpbGRVcGRhdGVEZXB0aDogLTFgKSxcbiAgICAgKiB0aGlzIG1ldGhvZCB3aWxsIHJldHVybiAtMSwgc2lnbmFsaW5nIGEgZnVsbCByZWN1cnNpdmUgdXBkYXRlIGZyb20gdGhlIHBhcmVudC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSB0aGUgcGFyZW50IGNvbXBvbmVudCByaWdodCBiZWZvcmUgaXQgZGlzcGF0Y2hlcyBpdHMgVkRPTSB1cGRhdGUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG93bmVySWQgVGhlIGBpZGAgb2YgdGhlIHBhcmVudCBjb21wb25lbnQuXG4gICAgICogQHJldHVybnMge051bWJlcnxudWxsfSBUaGUgYWRqdXN0ZWQgdXBkYXRlIGRlcHRoLCBvciBgbnVsbGAgaWYgbm8gbWVyZ2VkIGNoaWxkcmVuIGV4aXN0LlxuICAgICAqL1xuICAgIGdldEFkanVzdGVkVXBkYXRlRGVwdGgob3duZXJJZCkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgb3duZXIgICAgPSBOZW8uZ2V0Q29tcG9uZW50KG93bmVySWQpLFxuICAgICAgICAgICAgaXRlbSAgICAgPSBtZS5tZXJnZWRDYWxsYmFja01hcC5nZXQob3duZXJJZCksXG4gICAgICAgICAgICBtYXhEZXB0aCA9IG93bmVyPy51cGRhdGVEZXB0aCA/PyAxLFxuICAgICAgICAgICAgbmV3RGVwdGg7XG5cbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgaXRlbS5jaGlsZHJlbi52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5jaGlsZFVwZGF0ZURlcHRoID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdEZXB0aCA9IC0xXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG5ldyBkZXB0aCBpcyB0aGUgZGlzdGFuY2UgdG8gdGhlIGNoaWxkIHBsdXMgdGhlIGNoaWxkJ3Mgb3duIHJlcXVpcmVkIHVwZGF0ZSBkZXB0aC5cbiAgICAgICAgICAgICAgICAgICAgbmV3RGVwdGggPSB2YWx1ZS5kaXN0YW5jZSArIHZhbHVlLmNoaWxkVXBkYXRlRGVwdGhcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobmV3RGVwdGggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heERlcHRoID0gLTFcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1heERlcHRoICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBtYXhEZXB0aCA9IE1hdGgubWF4KG1heERlcHRoLCBuZXdEZXB0aClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBtYXhEZXB0aFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBjb21wb25lbnQgaGFzIGFueSBkZXNjZW5kYW50cyBjdXJyZW50bHkgdW5kZXJnb2luZyBhIFZET00gdXBkYXRlLlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgYnkgYFZkb21MaWZlY3ljbGVgIHRvIGRldGVjdCBwb3RlbnRpYWwgcmFjZSBjb25kaXRpb25zXG4gICAgICogYmVmb3JlIHN0YXJ0aW5nIGEgcGFyZW50IHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3duZXJJZCBUaGUgY29tcG9uZW50IElEIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIGFueSBkZXNjZW5kYW50IGlzIGluLWZsaWdodC5cbiAgICAgKi9cbiAgICBoYXNJbkZsaWdodERlc2NlbmRhbnRzKG93bmVySWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVzY2VuZGFudEluRmxpZ2h0TWFwLmhhcyhvd25lcklkKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgYHVwZGF0ZURlcHRoYCBmb3IgYSBjb21wb25lbnQncyB1cGRhdGUgdGhhdCBpcyBjdXJyZW50bHkgaW4tZmxpZ2h0LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvd25lcklkIFRoZSBgaWRgIG9mIHRoZSBjb21wb25lbnQgb3duaW5nIHRoZSB1cGRhdGUuXG4gICAgICogQHJldHVybnMge051bWJlcnx1bmRlZmluZWR9IFRoZSB1cGRhdGUgZGVwdGgsIG9yIGB1bmRlZmluZWRgIGlmIG5vIHVwZGF0ZSBpcyBpbi1mbGlnaHQuXG4gICAgICovXG4gICAgZ2V0SW5GbGlnaHRVcGRhdGVEZXB0aChvd25lcklkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluRmxpZ2h0VXBkYXRlTWFwLmdldChvd25lcklkKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBTZXQgb2YgY2hpbGQgY29tcG9uZW50IElEcyB0aGF0IGhhdmUgYmVlbiBtZXJnZWQgaW50byBhIHBhcmVudCdzIHVwZGF0ZSBjeWNsZSxcbiAgICAgKiBQTFVTIGFsbCBpbnRlcm1lZGlhdGUgXCJCcmlkZ2VcIiBjb21wb25lbnRzIChhbmNlc3RvcnMpIHJlcXVpcmVkIHRvIHJlYWNoIHRoZW0uXG4gICAgICpcbiAgICAgKiBUaGlzIHNldCBzZXJ2ZXMgYXMgYW4gXCJBbGxvd0xpc3RcIiBmb3IgVHJlZUJ1aWxkZXIuIFdoZW4gYSBwYXJlbnQgdXBkYXRlcyB3aXRoIGRlcHRoID4gMSxcbiAgICAgKiBUcmVlQnVpbGRlciB3aWxsIHVzZSB0aGlzIHNldCB0byBwZXJmb3JtICoqU3BhcnNlIFRyZWUgR2VuZXJhdGlvbioqOlxuICAgICAqIDEuIENvbXBvbmVudHMgaW4gdGhpcyBzZXQgYXJlIGV4cGFuZGVkICh0cmF2ZXJzZWQpLlxuICAgICAqIDIuIENvbXBvbmVudHMgTk9UIGluIHRoaXMgc2V0IGFyZSBwcnVuZWQgKHNlbnQgYXMgcGxhY2Vob2xkZXJzKSwgZXZlbiBpZiB0aGUgZGVwdGggYWxsb3dzIGV4cGFuc2lvbi5cbiAgICAgKlxuICAgICAqIFRoaXMgb3B0aW1pemF0aW9uIGFsbG93cyBjbGVhbiBzaWJsaW5ncyB0byBiZSBza2lwcGVkLCByZWR1Y2luZyBwYXlsb2FkIHNpemUgYW5kIGVuYWJsaW5nIHBhcmFsbGVsaXNtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG93bmVySWQgVGhlIGBpZGAgb2YgdGhlIHBhcmVudCBjb21wb25lbnQuXG4gICAgICogQHJldHVybnMge1NldDxTdHJpbmc+fG51bGx9IEEgU2V0IGNvbnRhaW5pbmcgSURzIG9mIG1lcmdlZCBjaGlsZHJlbiBBTkQgYnJpZGdlIGFuY2VzdG9ycywgb3IgYG51bGxgLlxuICAgICAqL1xuICAgIGdldE1lcmdlZENoaWxkSWRzKG93bmVySWQpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMubWVyZ2VkQ2FsbGJhY2tNYXAuZ2V0KG93bmVySWQpO1xuXG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICBjb25zdCBpZHMgPSBuZXcgU2V0KGl0ZW0uY2hpbGRyZW4ua2V5cygpKTtcblxuICAgICAgICAgICAgLy8gQWRkIEJyaWRnZSBQYXRoczogV2FsayB1cCBmcm9tIGVhY2ggbWVyZ2VkIGNoaWxkIHRvIHRoZSBvd25lclxuICAgICAgICAgICAgZm9yIChjb25zdCBbY2hpbGRJZCwgbWV0YV0gb2YgaXRlbS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGlmIChtZXRhLmRpc3RhbmNlID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29tcG9uZW50ID0gTmVvLmdldENvbXBvbmVudChjaGlsZElkKTtcblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY29tcG9uZW50ICYmIGNvbXBvbmVudC5wYXJlbnRJZCAmJiBjb21wb25lbnQucGFyZW50SWQgIT09IG93bmVySWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudCA9IE5lby5nZXRDb21wb25lbnQoY29tcG9uZW50LnBhcmVudElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHMuYWRkKGNvbXBvbmVudC5pZClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGlkc1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYXJrcyBhIGNvbXBvbmVudCdzIFZET00gdXBkYXRlIGFzIFwiaW4tZmxpZ2h0LFwiIG1lYW5pbmcgaXQgaGFzIGJlZW4gc2VudCB0byB0aGVcbiAgICAgKiB3b3JrZXIgZm9yIHByb2Nlc3NpbmcuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG93bmVySWQgICAgIFRoZSBgaWRgIG9mIHRoZSBjb21wb25lbnQgb3duaW5nIHRoZSB1cGRhdGUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHVwZGF0ZURlcHRoIFRoZSBkZXB0aCBvZiB0aGUgaW4tZmxpZ2h0IHVwZGF0ZS5cbiAgICAgKi9cbiAgICByZWdpc3RlckluRmxpZ2h0VXBkYXRlKG93bmVySWQsIHVwZGF0ZURlcHRoKSB7XG4gICAgICAgIHRoaXMuaW5GbGlnaHRVcGRhdGVNYXAuc2V0KG93bmVySWQsIHVwZGF0ZURlcHRoKTtcblxuICAgICAgICAvLyBSZWdpc3RlciB0aGlzIGNvbXBvbmVudCBhcyBhbiBpbi1mbGlnaHQgZGVzY2VuZGFudCBmb3IgYWxsIGl0cyBwYXJlbnRzXG4gICAgICAgIGNvbnN0IHBhcmVudElkcyA9IE5lby5tYW5hZ2VyLkNvbXBvbmVudC5nZXRQYXJlbnRJZHMoTmVvLmdldENvbXBvbmVudChvd25lcklkKSk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBhcmVudElkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgbGV0IHBhcmVudElkID0gcGFyZW50SWRzW2ldLFxuICAgICAgICAgICAgICAgIG1hcCAgICAgID0gdGhpcy5kZXNjZW5kYW50SW5GbGlnaHRNYXAuZ2V0KHBhcmVudElkKTtcblxuICAgICAgICAgICAgaWYgKCFtYXApIHtcbiAgICAgICAgICAgICAgICBtYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXNjZW5kYW50SW5GbGlnaHRNYXAuc2V0KHBhcmVudElkLCBtYXApXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1hcC5zZXQob3duZXJJZCwgdHJ1ZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGNoaWxkJ3MgdXBkYXRlIHJlcXVlc3QgdG8gYmUgbWVyZ2VkIGludG8gaXRzIHBhcmVudCdzIHVwZGF0ZSBjeWNsZS5cbiAgICAgKiBUaGlzIGlzIGNhbGxlZCBieSBhIGNoaWxkIGNvbXBvbmVudCB3aGVuIGl0IGRldGVybWluZXMgaXQgY2FuIGRlbGVnYXRlIGl0cyB1cGRhdGVcbiAgICAgKiB0byBhbiBhbmNlc3RvciAoc2VlIGBWZG9tTGlmZWN5Y2xlLm1lcmdlSW50b1BhcmVudFVwZGF0ZWApLlxuICAgICAqXG4gICAgICogKipNZXJnaW5nIExvZ2ljOioqXG4gICAgICogTWVyZ2luZyByZWR1Y2VzIFZET00gd29ya2VyIHRyYWZmaWMgYnkgYnVuZGxpbmcgbXVsdGlwbGUgY29tcG9uZW50IHVwZGF0ZXMgaW50b1xuICAgICAqIGEgc2luZ2xlIG1lc3NhZ2UuIFRoZSBjaGlsZCBlZmZlY3RpdmVseSBcImNhbmNlbHNcIiBpdHMgb3duIHN0YW5kYWxvbmUgdXBkYXRlIGFuZFxuICAgICAqIHBpZ2d5YmFja3Mgb24gdGhlIHBhcmVudCdzIHBlbmRpbmcgdXBkYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG93bmVySWQgICAgICAgICAgVGhlIGBpZGAgb2YgdGhlIHBhcmVudCBjb21wb25lbnQgdGhhdCB3aWxsIG93biB0aGUgbWVyZ2VkIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2hpbGRJZCAgICAgICAgICBUaGUgYGlkYCBvZiB0aGUgY2hpbGQgY29tcG9uZW50IHJlcXVlc3RpbmcgdGhlIG1lcmdlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGlsZFVwZGF0ZURlcHRoIFRoZSB1cGRhdGUgZGVwdGggcmVxdWlyZWQgYnkgdGhlIGNoaWxkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkaXN0YW5jZSAgICAgICAgIFRoZSBjb21wb25lbnQgdHJlZSBkaXN0YW5jZSAobnVtYmVyIG9mIGxldmVscykgYmV0d2VlbiB0aGUgcGFyZW50IGFuZCBjaGlsZC5cbiAgICAgKi9cbiAgICByZWdpc3Rlck1lcmdlZChvd25lcklkLCBjaGlsZElkLCBjaGlsZFVwZGF0ZURlcHRoLCBkaXN0YW5jZSkge1xuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtID0gbWUubWVyZ2VkQ2FsbGJhY2tNYXAuZ2V0KG93bmVySWQpO1xuXG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgaXRlbSA9IHtvd25lcklkLCBjaGlsZHJlbjogbmV3IE1hcCgpfTtcbiAgICAgICAgICAgIG1lLm1lcmdlZENhbGxiYWNrTWFwLmFkZChpdGVtKVxuICAgICAgICB9XG5cbiAgICAgICAgaXRlbS5jaGlsZHJlbi5zZXQoY2hpbGRJZCwge2NoaWxkVXBkYXRlRGVwdGgsIGRpc3RhbmNlfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBRdWV1ZXMgYSBjb21wb25lbnQgdXBkYXRlIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIGFub3RoZXIgY29tcG9uZW50J3MgdXBkYXRlIGlzIGNvbXBsZXRlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvd25lcklkICAgICBUaGUgYGlkYCBvZiB0aGUgY29tcG9uZW50IHRvIHdhaXQgZm9yLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjaGlsZElkICAgICBUaGUgYGlkYCBvZiB0aGUgY29tcG9uZW50IHRvIHVwZGF0ZSBhZnRlcndhcmQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVdIFRoZSBQcm9taXNlIHJlc29sdmVyIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBgY2hpbGRJZGAncyBzdWJzZXF1ZW50IHVwZGF0ZSBmaW5pc2hlcy5cbiAgICAgKi9cbiAgICByZWdpc3RlclBvc3RVcGRhdGUob3duZXJJZCwgY2hpbGRJZCwgcmVzb2x2ZSkge1xuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtID0gbWUucG9zdFVwZGF0ZVF1ZXVlTWFwLmdldChvd25lcklkKTtcblxuICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgIGl0ZW0gPSB7b3duZXJJZCwgY2hpbGRyZW46IFtdfTtcbiAgICAgICAgICAgIG1lLnBvc3RVcGRhdGVRdWV1ZU1hcC5hZGQoaXRlbSlcbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZW0uY2hpbGRyZW4ucHVzaCh7Y2hpbGRJZCwgcmVzb2x2ZX0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWQgZm9yIGEgY29tcG9uZW50IGltbWVkaWF0ZWx5IGFmdGVyIGl0cyBjdXJyZW50XG4gICAgICogVkRPTSB1cGRhdGUgZmluaXNoZXMsIGJ1dCBiZWZvcmUgdGhlIG5leHQgdXBkYXRlIGN5Y2xlIGJlZ2lucy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgVGhlIGNvbXBvbmVudCBJRC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuICAgIHJlZ2lzdGVyUHJlVXBkYXRlKGlkLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLnByZVVwZGF0ZU1hcC5zZXQoaWQsIGNhbGxiYWNrKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJzIGFsbCBwZW5kaW5nIHVwZGF0ZXMgdGhhdCB3ZXJlIHF1ZXVlZCB0byBydW4gYWZ0ZXIgdGhlIHNwZWNpZmllZCBgb3duZXJJZGAnc1xuICAgICAqIHVwZGF0ZSBoYXMgY29tcGxldGVkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvd25lcklkIFRoZSBgaWRgIG9mIHRoZSBjb21wb25lbnQgd2hvc2UgdXBkYXRlIGhhcyBqdXN0IGZpbmlzaGVkLlxuICAgICAqL1xuICAgIHRyaWdnZXJQb3N0VXBkYXRlcyhvd25lcklkKSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW0gPSBtZS5wb3N0VXBkYXRlUXVldWVNYXAuZ2V0KG93bmVySWQpLFxuICAgICAgICAgICAgY29tcG9uZW50O1xuXG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gaXRlbS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBlbnRyeSA9IGl0ZW0uY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgY29tcG9uZW50ID0gTmVvLmdldENvbXBvbmVudChlbnRyeS5jaGlsZElkKTtcblxuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZW50cnkucmVzb2x2ZSAmJiBtZS5hZGRQcm9taXNlQ2FsbGJhY2soY29tcG9uZW50LmlkLCBlbnRyeS5yZXNvbHZlKTtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LnVwZGF0ZSgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5wb3N0VXBkYXRlUXVldWVNYXAucmVtb3ZlKGl0ZW0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgY29tcG9uZW50J3MgdXBkYXRlIGZyb20gdGhlIFwiaW4tZmxpZ2h0XCIgcmVnaXN0cnkuIFRoaXMgaXMgY2FsbGVkIGFmdGVyXG4gICAgICogdGhlIFZET00gd29ya2VyIGNvbmZpcm1zIHRoZSB1cGRhdGUgaGFzIGJlZW4gcHJvY2Vzc2VkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvd25lcklkIFRoZSBgaWRgIG9mIHRoZSBjb21wb25lbnQgb3duaW5nIHRoZSB1cGRhdGUuXG4gICAgICovXG4gICAgdW5yZWdpc3RlckluRmxpZ2h0VXBkYXRlKG93bmVySWQpIHtcbiAgICAgICAgdGhpcy5pbkZsaWdodFVwZGF0ZU1hcC5kZWxldGUob3duZXJJZCk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoaXMgY29tcG9uZW50IGZyb20gdGhlIGluLWZsaWdodCBkZXNjZW5kYW50IG1hcHMgb2YgYWxsIGl0cyBwYXJlbnRzXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gaXRlcmF0ZSBhbGwgcmVnaXN0ZXJlZCBhbmNlc3RvcnMgdG8gZW5zdXJlIHdlIGNhdGNoIGNhc2VzIHdoZXJlXG4gICAgICAgIC8vIHRoZSBjb21wb25lbnQgbW92ZWQgKHJlLXBhcmVudGVkKSBkdXJpbmcgdGhlIHVwZGF0ZS5cbiAgICAgICAgZm9yIChjb25zdCBbcGFyZW50SWQsIG1hcF0gb2YgdGhpcy5kZXNjZW5kYW50SW5GbGlnaHRNYXApIHtcbiAgICAgICAgICAgIGlmIChtYXAuaGFzKG93bmVySWQpKSB7XG4gICAgICAgICAgICAgICAgbWFwLmRlbGV0ZShvd25lcklkKTtcblxuICAgICAgICAgICAgICAgIGlmIChtYXAuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc2NlbmRhbnRJbkZsaWdodE1hcC5kZWxldGUocGFyZW50SWQpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhWRG9tVXBkYXRlKTtcbiIsImltcG9ydCBCYXNlICAgICAgICAgICAgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQgRG9tRXZlbnRNYW5hZ2VyIGZyb20gJy4uL21hbmFnZXIvRG9tRXZlbnQubWpzJztcblxuLyoqXG4gKiBBIG1peGluIHByb3ZpZGluZyBET00gZXZlbnQgaGFuZGxpbmcgY2FwYWJpbGl0aWVzIHRvIGNvbXBvbmVudHMuXG4gKiBUaGlzIG1peGluIGlzIGNvbnN1bWVkIGJ5IGJvdGggTmVvLmNvbXBvbmVudC5CYXNlIGFuZCBOZW8uZnVuY3Rpb25hbC5jb21wb25lbnQuQmFzZVxuICogdG8gZW5hYmxlIGNvbnNpc3RlbnQgbWFuYWdlbWVudCBvZiBET00gZXZlbnQgbGlzdGVuZXJzIGFjcm9zcyBkaWZmZXJlbnQgY29tcG9uZW50IHR5cGVzLlxuICogQGNsYXNzIE5lby5taXhpbi5Eb21FdmVudHNcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgRG9tRXZlbnRzIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ubWl4aW4uRG9tRXZlbnRzJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ubWl4aW4uRG9tRXZlbnRzJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFycmF5IG9mIGRvbUxpc3RlbmVyIGNvbmZpZ3NcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0W118bnVsbH0gZG9tTGlzdGVuZXJzXz1udWxsXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGFmdGVyU2V0U3RheU9uSG92ZXIodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgICAqICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICogICAgICAgICBsZXQgbWUgPSB0aGlzO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgIG1lLmFkZERvbUxpc3RlbmVycyhcbiAgICAgICAgICogICAgICAgICAgICAge21vdXNlZW50ZXI6IG1lLm9uTW91c2VFbnRlciwgc2NvcGU6IG1lfSxcbiAgICAgICAgICogICAgICAgICAgICAge21vdXNlbGVhdmU6IG1lLm9uTW91c2VMZWF2ZSwgc2NvcGU6IG1lfVxuICAgICAgICAgKiAgICAgICAgIClcbiAgICAgICAgICogICAgfVxuICAgICAgICAgKn1cbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBkb21MaXN0ZW5lcnNfOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXQgdG8gYWRkIGFkZGl0aW9uYWwgZG9tIGxpc3RlbmVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fE9iamVjdFtdfSB2YWx1ZVxuICAgICAqL1xuICAgIGFkZERvbUxpc3RlbmVycyh2YWx1ZSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBkb21MaXN0ZW5lcnMgPSB0aGlzLmRvbUxpc3RlbmVycztcblxuICAgICAgICBkb21MaXN0ZW5lcnMucHVzaCguLi52YWx1ZSk7XG5cbiAgICAgICAgdGhpcy5kb21MaXN0ZW5lcnMgPSBkb21MaXN0ZW5lcnNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgdGhlIGRvbUxpc3RlbmVycyBpbnNpZGUgdGhlIE5lby5tYW5hZ2VyLkRvbUV2ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldERvbUxpc3RlbmVycyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAodmFsdWU/LlswXSB8fCBvbGRWYWx1ZT8uWzBdKSB7XG4gICAgICAgICAgICBEb21FdmVudE1hbmFnZXIudXBkYXRlRG9tTGlzdGVuZXJzKG1lLCB2YWx1ZSwgb2xkVmFsdWUpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBkb21MaXN0ZW5lcnMgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxPYmplY3RbXX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3RbXX1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0RG9tTGlzdGVuZXJzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBbdmFsdWVdXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWUgfHwgW11cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBET00gZXZlbnQgbGlzdGVuZXJzLlxuICAgICAqL1xuICAgIGluaXREb21FdmVudHMoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG4gICAgICAgIGlmIChtZS5kb21MaXN0ZW5lcnM/Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIHRvZG86IHRoZSBtYWluIHRocmVhZCByZXBseSBvZiBtb3VudCBhcnJpdmVzIGFmdGVyIHB1c2hpbmcgdGhlIHRhc2sgaW50byB0aGUgcXVldWUgd2hpY2ggZG9lcyBub3QgZW5zdXJlIHRoZSBkb20gaXMgbW91bnRlZFxuICAgICAgICAgICAgbWUudGltZW91dCgxNTApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIERvbUV2ZW50TWFuYWdlci5tb3VudERvbUxpc3RlbmVycyhtZSlcbiAgICAgICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVyciAhPT0gTmVvLmlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVyclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIG1vdW50ZWQgZmxhZyBmb3IgbG9jYWwgZG9tRXZlbnQgbGlzdGVuZXJzXG4gICAgICovXG4gICAgcmVzZXRNb3VudGVkRG9tRXZlbnRzKCkge1xuICAgICAgICBEb21FdmVudE1hbmFnZXIucmVzZXRNb3VudGVkRG9tTGlzdGVuZXJzKHRoaXMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgRE9NIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgKi9cbiAgICByZW1vdmVEb21FdmVudHMoKSB7XG4gICAgICAgIHRoaXMuZG9tTGlzdGVuZXJzID0gW11cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gdmFsdWVcbiAgICAgKi9cbiAgICByZW1vdmVEb21MaXN0ZW5lcnModmFsdWUpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBbdmFsdWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtkb21MaXN0ZW5lcnN9ID0gbWUsXG4gICAgICAgICAgICBpLCBsZW47XG5cbiAgICAgICAgdmFsdWUuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgbGVuID0gZG9tTGlzdGVuZXJzLmxlbmd0aDtcblxuICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChOZW8uaXNFcXVhbChpdGVtLCBkb21MaXN0ZW5lcnNbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbUxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBtZS5kb21MaXN0ZW5lcnMgPSBkb21MaXN0ZW5lcnNcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKERvbUV2ZW50cyk7XG4iLCJpbXBvcnQgQmFzZSAgICAgICAgICAgICBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBDb21wb25lbnRNYW5hZ2VyIGZyb20gJy4uL21hbmFnZXIvQ29tcG9uZW50Lm1qcyc7XG5pbXBvcnQgVHJlZUJ1aWxkZXIgICAgICBmcm9tICcuLi91dGlsL3Zkb20vVHJlZUJ1aWxkZXIubWpzJztcbmltcG9ydCBWRG9tVXRpbCAgICAgICAgIGZyb20gJy4uL3V0aWwvVkRvbS5tanMnO1xuaW1wb3J0IFZEb21VcGRhdGUgICAgICAgZnJvbSAnLi4vbWFuYWdlci9WRG9tVXBkYXRlLm1qcyc7XG5pbXBvcnQgVk5vZGVVdGlsICAgICAgICBmcm9tICcuLi91dGlsL1ZOb2RlLm1qcyc7XG5pbXBvcnQge2lzRGVzY3JpcHRvcn0gICBmcm9tICcuLi9jb3JlL0NvbmZpZ1N5bWJvbHMubWpzJztcblxuY29uc3Qge2N1cnJlbnRXb3JrZXJ9ID0gTmVvO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8ubWl4aW4uVmRvbUxpZmVjeWNsZVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBWZG9tTGlmZWN5Y2xlIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ubWl4aW4uVmRvbUxpZmVjeWNsZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLm1peGluLlZkb21MaWZlY3ljbGUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSBhdXRvbWF0aWNhbGx5IGluaXRpYWxpemVzIHRoZSB2bm9kZSBvZiBhIGNvbXBvbmVudCBhZnRlciBiZWluZyBjcmVhdGVkIGluc2lkZSB0aGUgaW5pdCBjYWxsLlxuICAgICAgICAgKiBSZWNvbW1lbmRlZCBmb3IgZGlhbG9ncyAmIGRyYWctcHJveGllcy5cbiAgICAgICAgICogVG9wIGxldmVsIHZpZXdzIHNob3VsZCBkZWZpbml0ZWx5IHVzZSBmYWxzZS5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXV0b0luaXRWbm9kZT1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgYXV0b0luaXRWbm9kZTogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIGF1dG9tYXRpY2FsbHkgbW91bnRzIGEgY29tcG9uZW50IGFmdGVyIGJlaW5nIHJlbmRlcmVkLlxuICAgICAgICAgKiBVc2UgdGhpcyBmb3IgdGhlIHRvcCBsZXZlbCBjb21wb25lbnQgb2YgeW91ciBhcHAuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGF1dG9Nb3VudD1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgYXV0b01vdW50OiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGZsYWcgd2hpY2ggd2lsbCBnZXQgc2V0IHRvIHRydWUgd2hpbGUgYW4gdXBkYXRlIHJlcXVlc3QgKHdvcmtlciBtZXNzYWdlcykgaXMgaW4gcHJvZ3Jlc3NcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNWZG9tVXBkYXRpbmdfPWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBpc1Zkb21VcGRhdGluZ186IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSBpbiBjYXNlIHRoZSBjb21wb25lbnQgaXMgaW5pdGlhbGl6aW5nIHRoZSB2bm9kZVxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc1Zub2RlSW5pdGlhbGl6aW5nXz1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgaXNWbm9kZUluaXRpYWxpemluZ186IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSBpbiBjYXNlIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZCB0byB0aGUgRE9NXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG1vdW50ZWRfPWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBtb3VudGVkXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBmbGFnIHdoaWNoIHdpbGwgZ2V0IHNldCB0byB0cnVlIGluIGNhc2UgYW4gdXBkYXRlIGNhbGwgYXJyaXZlcyB3aGlsZSBhbm90aGVyIHVwZGF0ZSBpcyBydW5uaW5nXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG5lZWRzVmRvbVVwZGF0ZV89ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIG5lZWRzVmRvbVVwZGF0ZV86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoaXMgdG8gdHJ1ZSBmb3IgYnVsayB1cGRhdGVzLiBFbnN1cmUgdG8gc2V0IGl0IGJhY2sgdG8gZmFsc2UgYWZ0ZXJ3YXJkcy5cbiAgICAgICAgICogSW50ZXJuYWxseSB0aGUgdmFsdWUgd2lsbCBnZXQgc2F2ZWQgYXMgYSBudW1iZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGQgbWV0aG9kcyB3b24ndCBzdG9wIHRoZSBzaWxlbnQgbW9kZSB0b28gZWFybHkuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbGVudFZkb21VcGRhdGVfPWZhbHNlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2lsZW50VmRvbVVwZGF0ZV86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lcyB0aGUgZGVwdGggb2YgdGhlIHZkb20gdHJlZSBmb3IgdGhlIG5leHQgdXBkYXRlIGN5Y2xlLlxuICAgICAgICAgKiAtIFRoZSB2YWx1ZSAxIHdpbGwgb25seSBzZW5kIHRoZSBjdXJyZW50IHZkb20gc3RydWN0dXJlIGFzIGl0IGlzXG4gICAgICAgICAqIC0gVGhlIHZhbHVlIG9mIDIgd2lsbCBpbmNsdWRlIHRoZSB2ZG9tIG9mIGRpcmVjdCBjaGlsZHJlblxuICAgICAgICAgKiAtIFRoZSB2YWx1ZSBvZiAzIHdpbGwgaW5jbHVkZSB0aGUgdmRvbSBvZiBncmFuZGNoaWxkcmVuXG4gICAgICAgICAqIC0gVGhlIHZhbHVlIG9mIC0xIHdpbGwgaW5jbHVkZSB0aGUgZnVsbCB0cmVlIG9mIGFueSBkZXB0aFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHVwZGF0ZURlcHRoXz0xXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlRGVwdGhfOiAxLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvbXBvbmVudCB2bm9kZSB0cmVlLiBBdmFpbGFibGUgYWZ0ZXIgdGhlIGNvbXBvbmVudCBnb3Qgdm5vZGVJbml0aWFsaXplZC5cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSB2bm9kZV89PXtbaXNEZXNjcmlwdG9yXTogdHJ1ZSwgdmFsdWU6IG51bGwsIGlzRXF1YWw6IChhLCBiKSA9PiBhID09PSBiLH1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHZub2RlXzoge1xuICAgICAgICAgICAgW2lzRGVzY3JpcHRvcl06IHRydWUsXG4gICAgICAgICAgICBjbG9uZSAgICAgICAgIDogJ25vbmUnLFxuICAgICAgICAgICAgY2xvbmVPbkdldCAgICA6ICdub25lJyxcbiAgICAgICAgICAgIGlzRXF1YWwgICAgICAgOiAoYSwgYikgPT4gYSA9PT0gYiwgLy8gdm5vZGUgdHJlZXMgY2FuIGJlIGh1Z2UsIGFuZCB3aWxsIGdldCBjb21wYXJlZCBieSB0aGUgdmRvbSB3b3JrZXIuXG4gICAgICAgICAgICB2YWx1ZSAgICAgICAgIDogbnVsbCxcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgYWZ0ZXIgdGhlIGNvbXBvbmVudCBpbml0Vm5vZGUoKSBtZXRob2Qgd2FzIGNhbGxlZC4gQWxzbyBmaXJlcyB0aGUgdm5vZGVJbml0aWFsaXplZCBldmVudC5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gdm5vZGVJbml0aWFsaXplZF89ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHZub2RlSW5pdGlhbGl6ZWRfOiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdmRvbSBwc2V1ZG8tY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRWZG9tKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZVZkb20oKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdm5vZGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRWbm9kZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdmFsdWUgJiYgdGhpcy5zeW5jVm5vZGVUcmVlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHZub2RlSW5pdGlhbGl6ZWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRWbm9kZUluaXRpYWxpemVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgbWUuZmlyZSgndm5vZGVJbml0aWFsaXplZCcsIG1lLmlkKTtcblxuICAgICAgICAgICAgaWYgKG1lLm5lZWRzVmRvbVVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbGlnaHR3ZWlnaHQsIHNlcmlhbGl6YWJsZSBwbGFjZWhvbGRlciBmb3IgdGhpcyBjb21wb25lbnQsIGludGVuZGVkIGZvciBpbmplY3Rpb25cbiAgICAgKiBpbnRvIHRoZSBWRE9NIG9mIG90aGVyIGNvbXBvbmVudHMuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHRoZSAqKm9ubHkgcmVjb21tZW5kZWQgd2F5KiogdG8gbmVzdCBhIGNvbXBvbmVudCB3aXRoaW4gYW5vdGhlciBjb21wb25lbnQncyBWRE9NIHRyZWUuXG4gICAgICogRGlyZWN0bHkgZW1iZWRkaW5nIG9uZSBjb21wb25lbnQncyBmdWxsIGB2ZG9tYCBvYmplY3QgaW50byBhbm90aGVyJ3MgaXMgYW4gYW50aS1wYXR0ZXJuXG4gICAgICogdGhhdCB2aW9sYXRlcyB0aGUgcHJpbmNpcGxlIG9mIHNjb3BlZCBWRE9NLCBsZWFkaW5nIHRvIHVucHJlZGljdGFibGUgcmVuZGVyaW5nIGJlaGF2aW9yXG4gICAgICogYW5kIG1ha2luZyB1cGRhdGVzIGluZWZmaWNpZW50LlxuICAgICAqXG4gICAgICogQXQgaXRzIGNvcmUsIHRoZSByZXR1cm5lZCBvYmplY3QgY29udGFpbnMgYSBgY29tcG9uZW50SWRgIHRoYXQgdW5pcXVlbHkgaWRlbnRpZmllcyB0aGVcbiAgICAgKiBjb21wb25lbnQgaW5zdGFuY2UuIEluIGNhc2VzIHdoZXJlIGEgY29tcG9uZW50J3Mgc3RydWN0dXJlIGlzIHdyYXBwZWQgYnkgYW5vdGhlciBlbGVtZW50XG4gICAgICogKGUuZy4sIGEgQnV0dG9uIGluIGEgVGFibGUgSGVhZGVyIGJlaW5nIHdyYXBwZWQgYnkgYSBgPHRkPmApLCB0aGUgcmVmZXJlbmNlIHdpbGwgYWxzb1xuICAgICAqIGluY2x1ZGUgdGhlIHdyYXBwZXIncyBgaWRgLiBUaGlzIGhhcHBlbnMgd2hlbiBhIGNvbXBvbmVudCB1c2VzIGBnZXRWZG9tUm9vdCgpYCB0b1xuICAgICAqIGRlc2lnbmF0ZSBhIGRlZXBlciBub2RlIGFzIGl0cyBsb2dpY2FsIHJvb3QsIGNhdXNpbmcgdGhlIGNvbXBvbmVudCdzIGBpZGAgYW5kIGl0c1xuICAgICAqIFZET00gcm9vdCdzIGBpZGAgdG8gZGlmZmVyLiBUaGUgZnJhbWV3b3JrIHVzZXMgdGhpcyBkdWFsLUlEIHJlZmVyZW5jZSB0byBjb3JyZWN0bHlcbiAgICAgKiBhc3NlbWJsZSB0aGUgZmluYWwgVkRPTSB0cmVlLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3tjb21wb25lbnRJZDogU3RyaW5nLCBpZDogU3RyaW5nfHVuZGVmaW5lZH19IFRoZSBWRE9NIHJlZmVyZW5jZSBvYmplY3QuXG4gICAgICovXG4gICAgY3JlYXRlVmRvbVJlZmVyZW5jZSgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICByZWZlcmVuY2UgPSB7Y29tcG9uZW50SWQ6IG1lLmlkfSxcbiAgICAgICAgICAgIHZkb21JZCAgICA9IG1lLnZkb20uaWQ7XG5cbiAgICAgICAgaWYgKHZkb21JZCAmJiBtZS5pZCAhPT0gdmRvbUlkKSB7XG4gICAgICAgICAgICByZWZlcmVuY2UuaWQgPSB2ZG9tSWRcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWZlcmVuY2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbnN1cmVzIHRoYXQgdGhlIHJvb3QgVkRPTSBub2RlIGFuZCBpdHMgd3JhcHBlciAoaWYgYW55KSBoYXZlIHN0YWJsZSwgdW5pcXVlIElEc1xuICAgICAqIGRlcml2ZWQgZnJvbSB0aGUgY29tcG9uZW50IGluc3RhbmNlIElELiBUaGlzIHByZXZlbnRzIGF1dG8tZ2VuZXJhdGVkIElEIGNvbGxpc2lvbnNcbiAgICAgKiBpbiBgQ29tcG9uZW50TWFuYWdlci53cmFwcGVyTm9kZXNgLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBlbnN1cmVTdGFibGVJZHMoKSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB2ZG9tICAgICA9IG1lLnZkb20sXG4gICAgICAgICAgICB2ZG9tUm9vdCA9IG1lLmdldFZkb21Sb290KCk7XG5cbiAgICAgICAgaWYgKHZkb21Sb290KSB7XG4gICAgICAgICAgICB2ZG9tUm9vdC5pZCA9IG1lLmlkO1xuXG4gICAgICAgICAgICBpZiAodmRvbSAhPT0gdmRvbVJvb3QpIHtcbiAgICAgICAgICAgICAgICB2ZG9tLmlkID0gbWUuaWQgKyAnX193cmFwcGVyJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbWV0aG9kIHRvIHNlbmQgdXBkYXRlIHJlcXVlc3RzIHRvIHRoZSB2ZG9tIHdvcmtlci5cbiAgICAgKlxuICAgICAqICoqVGVsZXBvcnRhdGlvbiAvIEJhdGNoZWQgRGlzam9pbnQgVXBkYXRlczoqKlxuICAgICAqIFRoaXMgbWV0aG9kIGltcGxlbWVudHMgdGhlIGNvcmUgbG9naWMgZm9yIFwiVGVsZXBvcnRhdGlvblwiLiBJbnN0ZWFkIG9mIG1lcmdpbmcgY2hpbGQgdXBkYXRlc1xuICAgICAqIGludG8gdGhlIHBhcmVudCdzIFZET00gdHJlZSAod2hpY2ggcmVxdWlyZXMgZXhwYW5kaW5nIHRoZSBwYXJlbnQncyB0cmVlIHRvIHJlYWNoIHRoZSBjaGlsZCksXG4gICAgICogd2UgY29sbGVjdCBhbGwgbWVyZ2VkIGNoaWxkIHVwZGF0ZXMgYW5kIHNlbmQgdGhlbSBhcyBhICoqYmF0Y2ggb2YgZGlzam9pbnQgcGF5bG9hZHMqKi5cbiAgICAgKlxuICAgICAqIDEuICoqUmVjdXJzaXZlIENvbGxlY3Rpb246KiogV2UgcmVjdXJzaXZlbHkgY29sbGVjdCBhbGwgYG1lcmdlZENoaWxkSWRzYCBmcm9tIHRoZSBjb21wb25lbnRcbiAgICAgKiAgICBhbmQgaXRzIGRlc2NlbmRhbnRzLlxuICAgICAqIDIuICoqRGlzam9pbnQgUGF5bG9hZHM6KiogRm9yIGVhY2ggY29tcG9uZW50IGluIHRoZSBiYXRjaCwgd2UgZ2VuZXJhdGUgYSBcInNlbGYtb25seVwiIFZET01cbiAgICAgKiAgICBwYXlsb2FkIChgdXBkYXRlRGVwdGg6IDFgKS4gVGhpcyBhbGxvd3MgdGhlIFZET00gZW5naW5lIHRvIHVwZGF0ZSB0aGUgY2hpbGQgZGlyZWN0bHlcbiAgICAgKiAgICB3aXRob3V0IG5lZWRpbmcgdGhlIHBhcmVudCB0byBcImJyaWRnZVwiIHRvIGl0LlxuICAgICAqIDMuICoqQ29sbGlzaW9uIEZpbHRlcmluZzoqKiBXZSBmaWx0ZXIgb3V0IGNoaWxkIHVwZGF0ZXMgdGhhdCBhcmUgYWxyZWFkeSBjb3ZlcmVkIGJ5IGFcbiAgICAgKiAgICBwYXJlbnQgdXBkYXRlIGluIHRoZSBzYW1lIGJhdGNoIChlLmcuLCBpZiB0aGUgcGFyZW50IGlzIGRvaW5nIGEgZnVsbCB0cmVlIHVwZGF0ZSkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcmVzb2x2ZV0gdXNlZCBieSBwcm9taXNlVXBkYXRlKClcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcmVqZWN0XSB1c2VkIGJ5IHByb21pc2VVcGRhdGUoKVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYXN5bmMgZXhlY3V0ZVZkb21VcGRhdGUocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmVzb2x2ZSAmJiBWRG9tVXBkYXRlLmFkZFByb21pc2VDYWxsYmFjayhtZS5pZCwgcmVzb2x2ZSk7XG5cbiAgICAgICAgbWUuaXNWZG9tVXBkYXRpbmcgPSB0cnVlO1xuICAgICAgICAvLyBDZW50cmFsaXplIGluLWZsaWdodCBzdGF0ZVxuICAgICAgICBWRG9tVXBkYXRlLnJlZ2lzdGVySW5GbGlnaHRVcGRhdGUobWUuaWQsIG1lLnVwZGF0ZURlcHRoKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBlbnN1cmUgdGhhdCB0aGUgdGFzayBxdWV1ZSBpcyBlbXB0eSBiZWZvcmUgY29sbGVjdGluZyBwYXlsb2Fkcy5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgY3JpdGljYWwgZm9yIGNhc2VzIHdoZXJlIGEgY29tcG9uZW50IHN0YXRlIGNoYW5nZSAodHJpZ2dlcmluZyB1cGRhdGUpXG4gICAgICAgICAgICAvLyBpcyBmb2xsb3dlZCBpbW1lZGlhdGVseSBieSBhIHN0cnVjdHVyYWwgY2hhbmdlIChlLmcuIHJlbW92ZSkgaW4gdGhlIHNhbWUgdGljay5cbiAgICAgICAgICAgIC8vIFVzaW5nIHNldFRpbWVvdXQgZm9yY2VzIGEgTWFjcm90YXNrIHlpZWxkLCBlbnN1cmluZyBhbGwgc3luYyBvcGVyYXRpb25zIGNvbXBsZXRlLlxuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEpKTtcblxuICAgICAgICAgICAgY29uc3RcbiAgICAgICAgICAgICAgICB1cGRhdGVzICAgICAgICAgICAgICAgICA9IHt9LFxuICAgICAgICAgICAgICAgIGRlcHRocyAgICAgICAgICAgICAgICAgID0gbmV3IE1hcCgpLFxuICAgICAgICAgICAgICAgIHByb2Nlc3NlZCAgICAgICAgICAgICAgID0gbmV3IFNldCgpLCAvLyBQcmV2ZW50IGR1cGxpY2F0ZXMgYW5kIGN5Y2xlc1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudE1lcmdlZENoaWxkcmVuID0gbmV3IE1hcCgpOyAvLyBTbmFwc2hvdCBvZiBtZXJnZWQgY2hpbGRyZW4gcHJvY2Vzc2VkIGluIHRoaXMgYmF0Y2hcblxuICAgICAgICAgICAgY29uc3QgY29sbGVjdFBheWxvYWRzID0gKGNvbXBvbmVudElkKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3NlZC5oYXMoY29tcG9uZW50SWQpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkLmFkZChjb21wb25lbnRJZCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSBOZW8uZ2V0Q29tcG9uZW50KGNvbXBvbmVudElkKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBvbmVudCB8fCBjb21wb25lbnQuaXNEZXN0cm95ZWQpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIC8vIFNraXAgdW5tb3VudGVkIGNvbXBvbmVudHMuIFRoZXkgd2lsbCBiZSBleHBhbmRlZCBieSB0aGUgUGFyZW50J3MgVHJlZUJ1aWxkZXJcbiAgICAgICAgICAgICAgICAvLyBhbmQgaGFuZGxlZCB2aWEgdGhlIFBhcmVudCdzIHJlc29sdmVWZG9tVXBkYXRlIC0+IHN5bmNWbm9kZVRyZWUuXG4gICAgICAgICAgICAgICAgaWYgKCFjb21wb25lbnQudm5vZGUpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIC8vIElNUE9SVEFOVDogSW4gYSBtdWx0aS13aW5kb3cgU2hhcmVkV29ya2VyIGVudmlyb25tZW50LCB3ZSBtdXN0IE5PVCBiYXRjaFxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZXMgZnJvbSBjb21wb25lbnRzIHRoYXQgaGF2ZSBtb3ZlZCB0byBhIGRpZmZlcmVudCB3aW5kb3cuXG4gICAgICAgICAgICAgICAgLy8gRG9pbmcgc28gd291bGQgY2F1c2UgZGVsdGFzIG1lYW50IGZvciBXaW5kb3cgQiB0byBiZSBzZW50IHRvIFdpbmRvdyBBLlxuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQud2luZG93SWQgIT09IG1lLndpbmRvd0lkKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAvLyBGb3IgZXZlcnkgY29tcG9uZW50LCB3ZSBjaGVjayBpdHMgb3duIG1lcmdlZCBjaGlsZHJlblxuICAgICAgICAgICAgICAgIGNvbnN0IG1lcmdlZENoaWxkSWRzID0gVkRvbVVwZGF0ZS5nZXRNZXJnZWRDaGlsZElkcyhjb21wb25lbnRJZCk7XG5cbiAgICAgICAgICAgICAgICAvLyBUcmFjayBkZXB0aCBmb3IgY29sbGlzaW9uIGZpbHRlcmluZ1xuICAgICAgICAgICAgICAgIGRlcHRocy5zZXQoY29tcG9uZW50SWQsIGNvbXBvbmVudC51cGRhdGVEZXB0aCk7XG5cbiAgICAgICAgICAgICAgICAvLyBTbmFwc2hvdCB0aGUgbWVyZ2VkIGNoaWxkcmVuIHdlIGFyZSBhYm91dCB0byBwcm9jZXNzLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgcHJldmVudHMgcmFjZSBjb25kaXRpb25zIHdoZXJlIGEgY2hpbGQgbWVyZ2VzICphZnRlciogY29sbGVjdGlvbiBidXQgKmJlZm9yZSogcmVzb2x1dGlvbixcbiAgICAgICAgICAgICAgICAvLyBjYXVzaW5nIGl0IHRvIGJlIGFja25vd2xlZGdlZC9jbGVhcmVkIHdpdGhvdXQgYWN0dWFsbHkgYmVpbmcgdXBkYXRlZC5cbiAgICAgICAgICAgICAgICBpZiAobWVyZ2VkQ2hpbGRJZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50TWVyZ2VkQ2hpbGRyZW4uc2V0KGNvbXBvbmVudElkLCBtZXJnZWRDaGlsZElkcyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgcGF5bG9hZCBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgLy8gLSBEZXB0aCAxIChUZWxlcG9ydGF0aW9uKTogUGFzcyBpZHM9bnVsbCB0byBmb3JjZSBkaXNqb2ludC9wcnVuZWQgcGF5bG9hZC5cbiAgICAgICAgICAgICAgICAvLyAtIERlcHRoID4gMSAoSHlicmlkKTogUGFzcyBpZHM9bWVyZ2VkQ2hpbGRJZHMgdG8gZW5hYmxlIFNwYXJzZSBUcmVlIGdlbmVyYXRpb24gKHBydW5pbmcgY2xlYW4gc2libGluZ3MpLlxuICAgICAgICAgICAgICAgIC8vICAgTm90ZTogRGVwdGggLTEgKEZ1bGwgVHJlZSkgaWdub3JlcyBpZHMgYW5kIGlzIGFsd2F5cyBEZW5zZS5cbiAgICAgICAgICAgICAgICBjb25zdCBpZHMgPSBjb21wb25lbnQudXBkYXRlRGVwdGggIT09IDEgPyBtZXJnZWRDaGlsZElkcyA6IG51bGw7XG5cbiAgICAgICAgICAgICAgICAvLyBXZSBwYXNzIG51bGwgYXMgdGhlIHNlY29uZCBhcmcgdG8gcmVzcGVjdCB0aGUgY29tcG9uZW50J3MgY29uZmlndXJlZCB1cGRhdGVEZXB0aC5cbiAgICAgICAgICAgICAgICB1cGRhdGVzW2NvbXBvbmVudElkXSA9IGNvbXBvbmVudC5nZXRWZG9tVXBkYXRlUGF5bG9hZChpZHMsIG51bGwpO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29sbGVjdCBtZXJnZWQgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICBpZiAobWVyZ2VkQ2hpbGRJZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZElkIG9mIG1lcmdlZENoaWxkSWRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0UGF5bG9hZHMoY2hpbGRJZClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIFN0YXJ0IGNvbGxlY3Rpb24gZnJvbSB0aGUgcm9vdCBvZiB0aGUgdXBkYXRlIChtZSlcbiAgICAgICAgICAgIGNvbGxlY3RQYXlsb2FkcyhtZS5pZCk7XG5cbiAgICAgICAgICAgIC8vIENvbGxpc2lvbiBGaWx0ZXJpbmc6XG4gICAgICAgICAgICAvLyBJZiBhIHBhcmVudCB1cGRhdGUgY292ZXJzIHRoaXMgY2hpbGQsIHJlbW92ZSB0aGUgY2hpbGQgZnJvbSB0aGUgZGlzam9pbnQgYmF0Y2hcbiAgICAgICAgICAgIGZvciAoY29uc3QgaWQgaW4gdXBkYXRlcykge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKHVwZGF0ZXMsIGlkKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGFyZW50ICAgPSBOZW8uZ2V0Q29tcG9uZW50KGlkKT8ucGFyZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2UgPSAxO1xuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1cGRhdGVzW3BhcmVudC5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnREZXB0aCA9IGRlcHRocy5nZXQocGFyZW50LmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBwYXJlbnQgY292ZXJzIHRoaXMgY2hpbGQsIHJlbW92ZSB0aGUgY2hpbGQgZnJvbSB0aGUgZGlzam9pbnQgYmF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50RGVwdGggPT09IC0xIHx8IHBhcmVudERlcHRoID4gZGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHVwZGF0ZXNbaWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gZXhpdCB0aGUgd2hpbGUgbG9vcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudCAgID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlKytcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgYmF0Y2hEYXRhID0ge3VwZGF0ZXN9O1xuXG4gICAgICAgICAgICAvLyBDUklUSUNBTDogU2hhcmVkV29ya2VyIENvbnRleHQgSW5qZWN0aW9uXG4gICAgICAgICAgICAvLyBUaGlzIGJsb2NrIE1VU1QgTk9UIGJlIHJlbW92ZWQgb3Igc2ltcGxpZmllZC5cbiAgICAgICAgICAgIC8vIEluIGEgU2hhcmVkV29ya2VyIGVudmlyb25tZW50LCB0aGUgVkRPTSB3b3JrZXIgbmVlZHMgdG8ga25vdyBXSElDSCB3aW5kb3dcbiAgICAgICAgICAgIC8vIGluaXRpYXRlZCB0aGUgdXBkYXRlIHRvIHJvdXRlIHRoZSByZXBseSBhbmQgRE9NIGRlbHRhcyBjb3JyZWN0bHkuXG4gICAgICAgICAgICAvLyBXaXRob3V0IGB3aW5kb3dJZGAgYW5kIGBhcHBOYW1lYCwgYFJlbW90ZU1ldGhvZEFjY2Vzc2AgY2Fubm90IGRldGVybWluZSB0aGUgdGFyZ2V0LFxuICAgICAgICAgICAgLy8gY2F1c2luZyBjcm9zcy13aW5kb3cgb3BlcmF0aW9ucyAobGlrZSBkcmFnZ2luZyBhIGNvbXBvbmVudCB0byBhIG5ldyB3aW5kb3cpIHRvIGZhaWwgc2lsZW50bHkuXG4gICAgICAgICAgICBpZiAoY3VycmVudFdvcmtlcj8uaXNTaGFyZWRXb3JrZXIpIHtcbiAgICAgICAgICAgICAgICBiYXRjaERhdGEuYXBwTmFtZSAgPSBtZS5hcHBOYW1lO1xuICAgICAgICAgICAgICAgIGJhdGNoRGF0YS53aW5kb3dJZCA9IG1lLndpbmRvd0lkXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKE5lby52ZG9tLkhlbHBlci51cGRhdGVCYXRjaChiYXRjaERhdGEpKTtcblxuICAgICAgICAgICAgLy8gQ29tcG9uZW50IGNvdWxkIGJlIGRlc3Ryb3llZCB3aGlsZSB0aGUgdXBkYXRlIGlzIHJ1bm5pbmdcbiAgICAgICAgICAgIGlmIChtZS5pZCkge1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gbm90IHVzaW5nIGEgVmRvbVdvcmtlciwgd2UgbmVlZCB0byBhcHBseSB0aGUgZGVsdGFzIGluc2lkZSB0aGUgQXBwIHdvcmtlclxuICAgICAgICAgICAgICAgIGlmICghTmVvLmNvbmZpZy51c2VWZG9tV29ya2VyICYmIHJlc3BvbnNlLmRlbHRhcz8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBOZW8uYXBwbHlEZWx0YXMobWUud2luZG93SWQsIHJlc3BvbnNlLmRlbHRhcylcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBEaXN0cmlidXRlIHJlc3VsdHMgYmFjayB0byBBTEwgY29tcG9uZW50cyBpbiB0aGUgYmF0Y2hcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGlkIGluIHJlc3BvbnNlLnZub2Rlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihyZXNwb25zZS52bm9kZXMsIGlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgdm5vZGUgPSByZXNwb25zZS52bm9kZXNbaWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gTmVvLmdldENvbXBvbmVudChpZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQgJiYgIWNvbXBvbmVudC5pc0Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC52bm9kZSA9IHZub2RlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzb2x2ZSB0aGUgdXBkYXRlIGZvciB0aGlzIGNvbXBvbmVudCBhbmQgaXRzIG1lcmdlZCBjaGlsZHJlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IHJlc3BvbnNlLmRlbHRhcyBjb250YWlucyB0aGUgYWdncmVnYXRlZCBkZWx0YXMgZm9yIHRoZSB3aG9sZSBiYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5yZXNvbHZlVmRvbVVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhczogcmVzcG9uc2UuZGVsdGFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2bm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNvbXBvbmVudE1lcmdlZENoaWxkcmVuLmdldChpZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIG1lLmlzVmRvbVVwZGF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBFbnN1cmUgc3RhdGUgaXMgY2xlYW5lZCB1cCBvbiBlcnJvclxuICAgICAgICAgICAgVkRvbVVwZGF0ZS51bnJlZ2lzdGVySW5GbGlnaHRVcGRhdGUobWUuaWQpO1xuICAgICAgICAgICAgcmVqZWN0Py4oZXJyKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSG9ub3JzIGRpZmZlcmVudCBpdGVtIHJvb3RzIGZvciBtb3VudCAvIHJlbmRlciBPUHNcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldE1vdW50ZWRQYXJlbnRJZCgpIHtcbiAgICAgICAgbGV0IHBhcmVudElkICA9IHRoaXMucGFyZW50SWQsXG4gICAgICAgICAgICBwYXJlbnQgICAgPSBOZW8uZ2V0Q29tcG9uZW50KHBhcmVudElkKSxcbiAgICAgICAgICAgIGl0ZW1zUm9vdCA9IHBhcmVudD8uZ2V0VmRvbUl0ZW1zUm9vdD8uKCk7XG5cbiAgICAgICAgcmV0dXJuIGl0ZW1zUm9vdCA/IGl0ZW1zUm9vdC5pZCA6IHBhcmVudElkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSByZWFsIHBhcmVudEluZGV4IGluc2lkZSB0aGUgRE9NXG4gICAgICogQHJldHVybnMge051bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0TW91bnRlZFBhcmVudEluZGV4KCkge1xuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5wYXJlbnQsXG4gICAgICAgICAgICBpdGVtcyAgPSBwYXJlbnQ/Lml0ZW1zIHx8IFtdLFxuICAgICAgICAgICAgaSAgICAgID0gMCxcbiAgICAgICAgICAgIGluZGV4ICA9IDAsXG4gICAgICAgICAgICBsZW4gICAgPSBpdGVtcy5sZW5ndGgsXG4gICAgICAgICAgICBpdGVtO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcblxuICAgICAgICAgICAgaWYgKGl0ZW0gPT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXhcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpdGVtLmhpZGRlbiAmJiBpdGVtLmhpZGVNb2RlID09PSAncmVtb3ZlRG9tJykge1xuICAgICAgICAgICAgICAgIGluZGV4KytcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyB0aGUgdXBkYXRlIHBheWxvYWQgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSB7U2V0PFN0cmluZz58bnVsbH0gbWVyZ2VkQ2hpbGRJZHNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2RlcHRoXSBPdmVycmlkZSB0aGUgdXBkYXRlIGRlcHRoXG4gICAgICogQHJldHVybnMge09iamVjdH0gb3B0c1xuICAgICAqL1xuICAgIGdldFZkb21VcGRhdGVQYXlsb2FkKG1lcmdlZENoaWxkSWRzLCBkZXB0aCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgdXBkYXRlRGVwdGggPSBkZXB0aCA/PyBtZS51cGRhdGVEZXB0aCxcbiAgICAgICAgICAgIHt2ZG9tLCB2bm9kZX0gPSBtZSxcbiAgICAgICAgICAgIG9wdHMgPSB7XG4gICAgICAgICAgICAgICAgdmRvbSA6IFRyZWVCdWlsZGVyLmdldFZkb21UcmVlKHZkb20sICAgdXBkYXRlRGVwdGgsIG1lcmdlZENoaWxkSWRzKSxcbiAgICAgICAgICAgICAgICB2bm9kZTogVHJlZUJ1aWxkZXIuZ2V0Vm5vZGVUcmVlKHZub2RlLCB1cGRhdGVEZXB0aCwgbWVyZ2VkQ2hpbGRJZHMpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGlmIChjdXJyZW50V29ya2VyPy5pc1NoYXJlZFdvcmtlcikge1xuICAgICAgICAgICAgb3B0cy5hcHBOYW1lICA9IG1lLmFwcE5hbWU7XG4gICAgICAgICAgICBvcHRzLndpbmRvd0lkID0gbWUud2luZG93SWRcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIGNhbm5vdCBzZXQgdGhlIGNvbmZpZyBkaXJlY3RseSA9PiBpdCBjb3VsZCBhbHJlYWR5IGJlIGZhbHNlLFxuICAgICAgICAvLyBhbmQgd2Ugc3RpbGwgd2FudCB0byBwYXNzIGl0IGZ1cnRoZXIgaW50byBzdWJ0cmVlc1xuICAgICAgICBtZS5fbmVlZHNWZG9tVXBkYXRlID0gZmFsc2U7XG4gICAgICAgIG1lLmFmdGVyU2V0TmVlZHNWZG9tVXBkYXRlPy4oZmFsc2UsIHRydWUpO1xuXG4gICAgICAgIC8vIFJlc2V0IHRoZSB1cGRhdGVEZXB0aCB0byB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIG5leHQgdXBkYXRlIGN5Y2xlXG4gICAgICAgIG1lLl91cGRhdGVEZXB0aCA9IG1lLmNvbnN0cnVjdG9yLmNvbmZpZy51cGRhdGVEZXB0aDtcblxuICAgICAgICByZXR1cm4gb3B0c1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlYXJjaCBhIHZkb20gY2hpbGQgbm9kZSBieSBpZCBmb3IgYSBnaXZlbiB2ZG9tIHRyZWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmRvbT10aGlzLnZkb21cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldFZkb21DaGlsZChpZCwgdmRvbT10aGlzLnZkb20pIHtcbiAgICAgICAgcmV0dXJuIFZEb21VdGlsLmZpbmQodmRvbSwgaWQpPy52ZG9tXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3BlY2lmeSBhIGRpZmZlcmVudCB2ZG9tIHJvb3QgaWYgbmVlZGVkIHRvIGFwcGx5IHRoZSB0b3AgbGV2ZWwgc3R5bGUgYXR0cmlidXRlcyBvbiBhIGRpZmZlcmVudCBsZXZlbC5cbiAgICAgKiBNYWtlIHN1cmUgdG8gdXNlIGdldFZub2RlUm9vdCgpIGFzIHdlbGwsIHRvIGtlZXAgdGhlIHZkb20gJiB2bm9kZSB0cmVlcyBpbiBzeW5jLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBuZXcgdmRvbSByb290XG4gICAgICovXG4gICAgZ2V0VmRvbVJvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZkb21cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IGEgZGlmZmVyZW50IHZub2RlIHJvb3QgaWYgbmVlZGVkIHRvIGFwcGx5IHRoZSB0b3AgbGV2ZWwgc3R5bGUgYXR0cmlidXRlcyBvbiBhIGRpZmZlcmVudCBsZXZlbC5cbiAgICAgKiBNYWtlIHN1cmUgdG8gdXNlIGdldFZkb21Sb290KCkgYXMgd2VsbCwgdG8ga2VlcCB0aGUgdmRvbSAmIHZub2RlIHRyZWVzIGluIHN5bmMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIG5ldyB2bm9kZSByb290XG4gICAgICovXG4gICAgZ2V0Vm5vZGVSb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52bm9kZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIGNoaWxkIHVwZGF0ZSBjYW4gYmUgbWVyZ2VkIGludG8gYSBwYXJlbnQgdXBkYXRlLlxuICAgICAqXG4gICAgICogKipNZXJnZSBTdHJhdGVneSAoT3B0aW1pemF0aW9uKToqKlxuICAgICAqIFdlIGFsbG93IG1lcmdpbmcgcmVnYXJkbGVzcyBvZiBkaXN0YW5jZSAoVGVsZXBvcnRhdGlvbikuXG4gICAgICogVGhlIGBleGVjdXRlVmRvbVVwZGF0ZWAgbG9naWMgd2lsbCBkaXN0aW5ndWlzaCBiZXR3ZWVuIENvbm5lY3RlZCAobWVyZ2VkIGludG8gdHJlZSlcbiAgICAgKiBhbmQgRGlzam9pbnQgKGJhdGNoZWQgc2VwYXJhdGVseSkgdXBkYXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB1cGRhdGVEZXB0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkaXN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGNhbk1lcmdlVXBkYXRlKHVwZGF0ZURlcHRoLCBkaXN0YW5jZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIGdpdmVuIHVwZGF0ZURlcHRoICYgZGlzdGFuY2Ugd291bGQgcmVzdWx0IGluIGFuIHVwZGF0ZSBjb2xsaXNpb24uXG4gICAgICogVGhlIGNoZWNrIG11c3QgdXNlIGA8YCBiZWNhdXNlIGB1cGRhdGVEZXB0aGAgaXMgMS1iYXNlZC5cbiAgICAgKlxuICAgICAqICoqU2NvcGVkIFZET00gVXBkYXRlIFJhdGlvbmFsZToqKlxuICAgICAqIC0gYHVwZGF0ZURlcHRoOiAxYCBtZWFucyB0aGUgdXBkYXRlIGlzIHNjb3BlZCB0byB0aGUgY29tcG9uZW50IGl0c2VsZi5cbiAgICAgKiAtIFRoZSBQYXJlbnQncyBWRE9NIHBheWxvYWQgbmF0dXJhbGx5IGNvbnRhaW5zIG9ubHkgaXRzIG93biBzdHJ1Y3R1cmUgYW5kICoqcmVmZXJlbmNlIG5vZGVzKipcbiAgICAgKiAgIChwbGFjZWhvbGRlcnMpIGZvciBpdHMgY2hpbGRyZW4gKGUuZy4gYHtjb21wb25lbnRJZDogJy4uLid9YCkuXG4gICAgICogLSBBdCBEZXB0aCAxLCB0aGVzZSByZWZlcmVuY2VzIGFyZSAqKm5vdCBleHBhbmRlZCoqIGludG8gdGhlIGNoaWxkcmVuJ3MgZnVsbCBWRE9NIHRyZWVzLlxuICAgICAqIC0gVGhlcmVmb3JlLCBhIFBhcmVudCAoRGVwdGggMSkgdXBkYXRlIGFuZCBhIENoaWxkIHVwZGF0ZSBvcGVyYXRlIG9uICoqZGlzam9pbnQqKiBzZXRzIG9mIERPTSBub2Rlcy5cbiAgICAgKiAtIFRoZXkgKipkbyBub3QgY29sbGlkZSoqIGFuZCAqKnNob3VsZCBub3QgbWVyZ2UqKi4gVGhleSBzaG91bGQgcnVuIGFzIGluZGVwZW5kZW50LCBwYXJhbGxlbCB1cGRhdGVzLlxuICAgICAqXG4gICAgICogLSBBIGRpcmVjdCBjaGlsZCBpcyBhdCBgZGlzdGFuY2U6IDFgLlxuICAgICAqIFRoZXJlZm9yZSwgYW4gdXBkYXRlIHdpdGggZGVwdGggMSBzaG91bGQgTk9UIGNvbGxpZGUgd2l0aCBhIGNoaWxkIGF0IGRpc3RhbmNlIDEgKDEgPCAxIGlzIGZhbHNlKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB1cGRhdGVEZXB0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkaXN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGhhc1VwZGF0ZUNvbGxpc2lvbih1cGRhdGVEZXB0aCwgZGlzdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZURlcHRoID09PSAtMSA/IHRydWUgOiBkaXN0YW5jZSA8IHVwZGF0ZURlcHRoXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgdm5vZGUgdHJlZSBmb3IgdGhpcyBjb21wb25lbnQgYW5kIG1vdW50cyB0aGUgY29tcG9uZW50IGluIGNhc2VcbiAgICAgKiAtIHlvdSBwYXNzIHRydWUgZm9yIHRoZSBtb3VudCBwYXJhbVxuICAgICAqIC0gb3IgdGhlIGF1dG9Nb3VudCBjb25maWcgaXMgc2V0IHRvIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttb3VudF0gTW91bnQgdGhlIERPTSBhZnRlciB0aGUgdm5vZGUgZ290IGNyZWF0ZWRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBJZiBnZXR0aW5nIHRoZXJlLCB3ZSByZXR1cm4gdGhlIGRhdGEgZnJvbSB2ZG9tLkhlbHBlcjogY3JlYXRlKCksIGNvbnRhaW5pbmcgdGhlIHZub2RlLlxuICAgICAqL1xuICAgIGFzeW5jIGluaXRWbm9kZShtb3VudCkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGF1dG9Nb3VudCA9IG1vdW50IHx8IG1lLmF1dG9Nb3VudCxcbiAgICAgICAgICAgIHthcHB9ICAgICA9IG1lLFxuICAgICAgICAgICAge2FsbG93VmRvbVVwZGF0ZXNJblRlc3RzLCB1bml0VGVzdE1vZGUsIHVzZVZkb21Xb3JrZXJ9ID0gTmVvLmNvbmZpZztcblxuICAgICAgICBpZiAodW5pdFRlc3RNb2RlICYmICFhbGxvd1Zkb21VcGRhdGVzSW5UZXN0cykgcmV0dXJuO1xuXG4gICAgICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBjcml0aWNhbCByZW5kZXJpbmcgcGF0aCA9PiBDU1MgZmlsZXMgZm9yIHRoZSBuZXcgdHJlZSBpcyBpbiBwbGFjZVxuICAgICAgICBpZiAoIXVuaXRUZXN0TW9kZSAmJiBhdXRvTW91bnQgJiYgY3VycmVudFdvcmtlci5jb3VudExvYWRpbmdUaGVtZUZpbGVzICE9PSAwKSB7XG4gICAgICAgICAgICBjdXJyZW50V29ya2VyLm9uKCd0aGVtZUZpbGVzTG9hZGVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgIW1lLm1vdW50ZWQgJiYgbWUuaW5pdFZub2RlKG1vdW50KVxuICAgICAgICAgICAgfSwgbWUsIHtvbmNlOiB0cnVlfSk7XG5cbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgbWUuaXNWbm9kZUluaXRpYWxpemluZyA9IHRydWU7XG5cbiAgICAgICAgaWYgKCFhcHAudm5vZGVJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgYXBwLmlzVm5vZGVJbml0aWFsaXppbmcgPSB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKG1lLnZkb20pIHtcbiAgICAgICAgICAgICAgICBtZS5pc1Zkb21VcGRhdGluZyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBtZS5lbnN1cmVTdGFibGVJZHMoKTtcblxuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBjaGlsZCBjb21wb25lbnRzIGRvIG5vdCB0cmlnZ2VyIHVwZGF0ZXMgd2hpbGUgdGhlIHZub2RlIGdlbmVyYXRpb24gaXMgaW4gcHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICBWRG9tVXBkYXRlLnJlZ2lzdGVySW5GbGlnaHRVcGRhdGUobWUuaWQsIC0xKTtcblxuICAgICAgICAgICAgICAgIGRlbGV0ZSBtZS52ZG9tLnJlbW92ZURvbTtcblxuICAgICAgICAgICAgICAgIG1lLl9uZWVkc1Zkb21VcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBtZS5hZnRlclNldE5lZWRzVmRvbVVwZGF0ZT8uKGZhbHNlLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBQcm9taXNlLnJlc29sdmUoTmVvLnZkb20uSGVscGVyLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGFwcE5hbWUgICAgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgICAgICAgICBhdXRvTW91bnQsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudElkICAgOiBhdXRvTW91bnQgPyBtZS5nZXRNb3VudGVkUGFyZW50SWQoKSAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50SW5kZXg6IGF1dG9Nb3VudCA/IG1lLmdldE1vdW50ZWRQYXJlbnRJbmRleCgpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB2ZG9tICAgICAgIDogVHJlZUJ1aWxkZXIuZ2V0VmRvbVRyZWUobWUudmRvbSwgLTEpLFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3dJZCAgIDogbWUud2luZG93SWRcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICBtZS5vbkluaXRWbm9kZShkYXRhLnZub2RlLCB1c2VWZG9tV29ya2VyID8gYXV0b01vdW50IDogZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGF1dG9Nb3VudCAmJiAhdXNlVmRvbVdvcmtlcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHJ1bm5pbmcgd2l0aG91dCBhIFZkb21Xb3JrZXIsIEhlbHBlci5jcmVhdGUgaXMgbG9jYWwgYW5kIHJldHVybnMgYSBwbGFpbiBvYmplY3QuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG11c3QgbWFudWFsbHkgc2VuZCB0aGUgaW5zZXJ0Tm9kZSBkZWx0YSB0byB0aGUgbWFpbiB0aHJlYWQuXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IE5lby5hcHBseURlbHRhcyhtZS53aW5kb3dJZCwgW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbiAgIDogJ2luc2VydE5vZGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQgICAgICAgOiBtZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ICAgIDogbWUuZ2V0TW91bnRlZFBhcmVudEluZGV4KCksXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRlckhUTUw6IGRhdGEub3V0ZXJIVE1MLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQgOiBtZS5nZXRNb3VudGVkUGFyZW50SWQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZub2RlICAgIDogZGF0YS52bm9kZVxuICAgICAgICAgICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgICAgICAgICAgbWUubW91bnRlZCA9IHRydWVcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWRhdGEuZGVsdGFzKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZGVsdGFzID0gW11cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZS5yZXNvbHZlVmRvbVVwZGF0ZShkYXRhKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignaW5pdFZub2RlIGVycm9yJywgZXJyLCBtZS5pZCk7XG4gICAgICAgICAgICB0aHJvdyBlcnJcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN5bmNocm9uaXphdGlvbiBHdWFyZDogQ2hlY2tzIGlmIGFueSBkZXNjZW5kYW50IGNvbXBvbmVudCBpcyBjdXJyZW50bHkgdXBkYXRpbmcgaXRzIFZET00uXG4gICAgICpcbiAgICAgKiBJZiBhIGRlc2NlbmRhbnQgaXMgaW4tZmxpZ2h0LCB0aGlzIG1ldGhvZCByZWdpc3RlcnMgYSBwb3N0LXVwZGF0ZSBjYWxsYmFjayBvbiB0aGVcbiAgICAgKiBibG9ja2luZyBkZXNjZW5kYW50IGFuZCByZXR1cm5zIGB0cnVlYCwgc2lnbmFsaW5nIHRoZSBjYWxsZXIgKGB1cGRhdGVWZG9tYCkgdG8geWllbGQuXG4gICAgICogVGhpcyBwcmV2ZW50cyB0aGUgUGFyZW50IGZyb20gc3RhcnRpbmcgYW4gdXBkYXRlIHRoYXQgbWlnaHQgb3ZlcndyaXRlIG9yIGNvbmZsaWN0XG4gICAgICogd2l0aCB0aGUgQ2hpbGQncyBjb25jdXJyZW50IHdvcmssIGVmZmVjdGl2ZWx5IHNlcmlhbGl6aW5nIHRoZSB1cGRhdGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVdIEdldHMgcGFzc2VkIGJ5IHVwZGF0ZVZkb20oKSB0byBiZSBjYWxsZWQgYWZ0ZXIgdGhlIGJsb2NraW5nIHVwZGF0ZSBmaW5pc2hlcy5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiBhIGNoaWxkIHVwZGF0ZSBjb25mbGljdCBleGlzdHMgKFBhcmVudCBzaG91bGQgeWllbGQpLlxuICAgICAqL1xuICAgIGlzQ2hpbGRVcGRhdGluZyhyZXNvbHZlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKFZEb21VcGRhdGUuaGFzSW5GbGlnaHREZXNjZW5kYW50cyhtZS5pZCkpIHtcbiAgICAgICAgICAgIGxldCBtYXAgICAgICAgICAgPSBWRG9tVXBkYXRlLmRlc2NlbmRhbnRJbkZsaWdodE1hcC5nZXQobWUuaWQpLFxuICAgICAgICAgICAgICAgIGRlc2NlbmRhbnRJZCA9IG1hcC5rZXlzKCkubmV4dCgpLnZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoTmVvLmNvbmZpZy5sb2dWZG9tVXBkYXRlQ29sbGlzaW9ucykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybigndmRvbSBjaGlsZCB1cGRhdGUgY29uZmxpY3Qgd2l0aDonLCBkZXNjZW5kYW50SWQsICdmb3I6JywgbWUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFZEb21VcGRhdGUucmVnaXN0ZXJQb3N0VXBkYXRlKGRlc2NlbmRhbnRJZCwgbWUuaWQsIHJlc29sdmUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBmb3IgdmRvbSB1cGRhdGVzIGluc2lkZSB0aGUgcGFyZW50IGNoYWluIGFuZCBpZiBmb3VuZC5cbiAgICAgKiBSZWdpc3RlcnMgdGhlIGNvbXBvbmVudCBmb3IgYSB2ZG9tIHVwZGF0ZSBvbmNlIGRvbmUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmVudElkPXRoaXMucGFyZW50SWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZV0gR2V0cyBwYXNzZWQgYnkgdXBkYXRlVmRvbSgpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRpc3RhbmNlPTEgRGlzdGFuY2UgaW5zaWRlIHRoZSBjb21wb25lbnQgdHJlZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzUGFyZW50VXBkYXRpbmcocGFyZW50SWQ9dGhpcy5wYXJlbnRJZCwgcmVzb2x2ZSwgZGlzdGFuY2U9MSkge1xuICAgICAgICBpZiAocGFyZW50SWQgIT09ICdkb2N1bWVudC5ib2R5Jykge1xuICAgICAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gTmVvLmdldENvbXBvbmVudChwYXJlbnRJZCk7XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50LmlzVmRvbVVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgaW4tZmxpZ2h0IHVwZGF0ZSBkZXB0aCBmcm9tIHRoZSBjZW50cmFsIG1hbmFnZXJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50VXBkYXRlRGVwdGggPSBWRG9tVXBkYXRlLmdldEluRmxpZ2h0VXBkYXRlRGVwdGgocGFyZW50LmlkKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobWUuaGFzVXBkYXRlQ29sbGlzaW9uKHBhcmVudFVwZGF0ZURlcHRoLCBkaXN0YW5jZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChOZW8uY29uZmlnLmxvZ1Zkb21VcGRhdGVDb2xsaXNpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCd2ZG9tIHBhcmVudCB1cGRhdGUgY29uZmxpY3Qgd2l0aDonLCBwYXJlbnQsICdmb3I6JywgbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIFZEb21VcGRhdGUucmVnaXN0ZXJQb3N0VXBkYXRlKHBhcmVudC5pZCwgbWUuaWQsIHJlc29sdmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGFuIHVwZGF0ZSBpcyBydW5uaW5nIGFuZCBkb2VzIG5vdCBoYXZlIGEgY29sbGlzaW9uLCB3ZSBkbyBub3QgbmVlZCB0byBjaGVjayBmdXJ0aGVyIHBhcmVudHNcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lLmlzUGFyZW50VXBkYXRpbmcocGFyZW50LnBhcmVudElkLCByZXNvbHZlLCBkaXN0YW5jZSsxKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhdmVyc2VzIHRoZSBwYXJlbnQgY2hhaW4gdG8gZmluZCBhbiBhbmNlc3RvciB0aGF0IGlzIHBlbmRpbmcgYSBWRE9NIHVwZGF0ZS5cbiAgICAgKiBJZiBmb3VuZCwgYW5kIGlmIHRoZSB1cGRhdGUgc2NvcGUgYWxsb3dzIChzZWUgYGNhbk1lcmdlVXBkYXRlYCksIHRoaXMgY29tcG9uZW50J3NcbiAgICAgKiB1cGRhdGUgaXMgbWVyZ2VkIGludG8gdGhlIGFuY2VzdG9yJ3MgY3ljbGUuXG4gICAgICpcbiAgICAgKiAqKlJlY3Vyc2l2ZSBUcmF2ZXJzYWw6KipcbiAgICAgKiBUaGlzIG1ldGhvZCByZWN1cnNpdmVseSB3YWxrcyB1cCB0aGUgY29tcG9uZW50IHRyZWUgKGBkaXN0YW5jZSArIDFgKS4gVGhpcyBlbmFibGVzXG4gICAgICogdHJhbnNpdGl2ZSBtZXJnaW5nIChHcmFuZGNoaWxkIC0+IENoaWxkIC0+IFBhcmVudCkgYW5kIG1lcmdpbmcgaW50byBhbmNlc3RvcnMgZXZlblxuICAgICAqIGlmIGludGVybWVkaWF0ZSBwYXJlbnRzIGFyZSBub3QgdXBkYXRpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyZW50SWQ9dGhpcy5wYXJlbnRJZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlXSBnZXRzIHBhc3NlZCBieSB1cGRhdGVWZG9tKClcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGlzdGFuY2U9MSBEaXN0YW5jZSBpbnNpZGUgdGhlIGNvbXBvbmVudCB0cmVlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHVwZGF0ZSB3YXMgc3VjY2Vzc2Z1bGx5IG1lcmdlZC5cbiAgICAgKi9cbiAgICBtZXJnZUludG9QYXJlbnRVcGRhdGUocGFyZW50SWQ9dGhpcy5wYXJlbnRJZCwgZGlzdGFuY2U9MSkge1xuICAgICAgICBpZiAocGFyZW50SWQgIT09ICdkb2N1bWVudC5ib2R5Jykge1xuICAgICAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gTmVvLmdldENvbXBvbmVudChwYXJlbnRJZCk7XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgY2hlY2tpbmcgZm9yIHBhcmVudC51cGRhdGVEZXB0aCwgc2luY2Ugd2UgY2FyZSBhYm91dCB0aGUgZGVwdGggb2YgdGhlIG5leHQgdXBkYXRlIGN5Y2xlXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC5uZWVkc1Zkb21VcGRhdGUgJiYgbWUuY2FuTWVyZ2VVcGRhdGUocGFyZW50LnVwZGF0ZURlcHRoLCBkaXN0YW5jZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgVkRvbVVwZGF0ZS5yZWdpc3Rlck1lcmdlZChwYXJlbnQuaWQsIG1lLmlkLCBtZS51cGRhdGVEZXB0aCwgZGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBtZS5tZXJnZUludG9QYXJlbnRVcGRhdGUocGFyZW50LnBhcmVudElkLCBkaXN0YW5jZSsxKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgZnJvbSB0aGUgaW5pdFZub2RlKCkgcHJvbWlzZSBzdWNjZXNzIGhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdm5vZGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGF1dG9Nb3VudCBNb3VudCB0aGUgRE9NIGFmdGVyIHRoZSB2bm9kZSBnb3QgY3JlYXRlZFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbkluaXRWbm9kZSh2bm9kZSwgYXV0b01vdW50KSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICB7YXBwfSA9IG1lO1xuXG4gICAgICAgIG1lLmlzVm5vZGVJbml0aWFsaXppbmcgPSBmYWxzZTtcblxuICAgICAgICAvLyBpZiBhcHAgaXMgYSBjaGVjayB0byBzZWUgaWYgdGhlIENvbXBvbmVudCBnb3QgZGVzdHJveWVkIHdoaWxlIHZub2RlSW5pdGlhbGlzaW5nID0+IGJlZm9yZSBvbkluaXRWbm9kZSBnb3QgdHJpZ2dlcmVkXG4gICAgICAgIGlmIChhcHApIHtcbiAgICAgICAgICAgIGlmICghYXBwLnZub2RlSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICBhcHAuaXNWbm9kZUluaXRpYWxpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGFwcC52bm9kZUluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhcHAuZmlyZSgndm5vZGVJbml0aWFsaXplZCcpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLnZub2RlID0gdm5vZGU7XG5cbiAgICAgICAgICAgIGxldCBjaGlsZElkcyA9IENvbXBvbmVudE1hbmFnZXIuZ2V0Q2hpbGRJZHModm5vZGUpLFxuICAgICAgICAgICAgICAgIGkgICAgICAgID0gMCxcbiAgICAgICAgICAgICAgICBsZW4gICAgICA9IGNoaWxkSWRzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBjaGlsZDtcblxuICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gTmVvLmdldENvbXBvbmVudChjaGlsZElkc1tpXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQudm5vZGVJbml0aWFsaXplZCA9IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLnZub2RlSW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAoYXV0b01vdW50KSB7XG4gICAgICAgICAgICAgICAgbWUubW91bnRlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWFwcC5tb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcC5tb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYXBwLmZpcmUoJ21vdW50ZWQnKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgcHJvbWlzZVVwZGF0ZSgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaWQgPSBTeW1ib2woKTtcblxuICAgICAgICAgICAgbWUucmVnaXN0ZXJBc3luYyhpZCwgcmVqZWN0KTtcblxuICAgICAgICAgICAgbWUudXBkYXRlVmRvbShcbiAgICAgICAgICAgICAgICAodmFsKSA9PiB7bWUudW5yZWdpc3RlckFzeW5jKGlkKTsgcmVzb2x2ZSh2YWwpfSxcbiAgICAgICAgICAgICAgICAoZXJyKSA9PiB7bWUudW5yZWdpc3RlckFzeW5jKGlkKTsgcmVqZWN0KGVycil9XG4gICAgICAgICAgICApXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgaGVscGVyIGZuIHRvIHJlc29sdmUgdGhlIFByb21pc2UgZm9yIHVwZGF0ZVZkb20oKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZGF0YV0gVGhlIHJldHVybiB2YWx1ZSBvZiB2ZG9tLkhlbHBlci51cGRhdGUoKVxuICAgICAqIEBwYXJhbSB7U2V0PFN0cmluZz58bnVsbH0gW21lcmdlZENoaWxkSWRzXSBJRHMgb2YgY2hpbGRyZW4gaW5jbHVkZWQgaW4gdGhpcyB1cGRhdGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcmVzb2x2ZVZkb21VcGRhdGUoZGF0YSwgbWVyZ2VkQ2hpbGRJZHMpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5pc1Zkb21VcGRhdGluZyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEV4ZWN1dGUgY2FsbGJhY2tzIGZvciBtZXJnZWQgdXBkYXRlc1xuICAgICAgICBWRG9tVXBkYXRlLmV4ZWN1dGVDYWxsYmFja3MobWUuaWQsIGRhdGEsIG1lcmdlZENoaWxkSWRzKTtcblxuICAgICAgICAvLyBUaGUgdXBkYXRlIGlzIG5vIGxvbmdlciBpbi1mbGlnaHRcbiAgICAgICAgVkRvbVVwZGF0ZS51bnJlZ2lzdGVySW5GbGlnaHRVcGRhdGUobWUuaWQpO1xuXG4gICAgICAgIC8vIFRyaWdnZXIgdXBkYXRlcyBmb3IgY29tcG9uZW50cyB0aGF0IHdlcmUgaW4tZmxpZ2h0XG4gICAgICAgIFZEb21VcGRhdGUudHJpZ2dlclBvc3RVcGRhdGVzKG1lLmlkKTtcblxuICAgICAgICAvLyBFeGVjdXRlIGNhbGxiYWNrcyB3aGljaCB3YW50ZWQgdG8gcnVuIGJlZm9yZSB0aGUgbmV4dCB1cGRhdGUgY3ljbGVcbiAgICAgICAgVkRvbVVwZGF0ZS5leGVjdXRlUHJlVXBkYXRlcyhtZS5pZCk7XG5cbiAgICAgICAgaWYgKG1lLm5lZWRzVmRvbVVwZGF0ZSkge1xuICAgICAgICAgICAgLy8gYW55IG5ldyBwcm9taXNlIGNhbGxiYWNrcyB3aWxsIGdldCBwaWNrZWQgdXAgYnkgdGhlIG5leHQgdXBkYXRlIGN5Y2xlXG4gICAgICAgICAgICBtZS51cGRhdGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGxhY2Vob2xkZXIgbWV0aG9kIGZvciB1dGlsLlZEb20uc3luY1Zkb21TdGF0ZSB0byBhbGxvdyBvdmVycmlkaW5nIChkaXNhYmxpbmcpIGl0XG4gICAgICogQHBhcmFtIHtOZW8udmRvbS5WTm9kZX0gW3Zub2RlPXRoaXMudm5vZGVdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFt2ZG9tPXRoaXMudmRvbV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZvcmNlPWZhbHNlXG4gICAgICovXG4gICAgc3luY1Zkb21TdGF0ZSh2bm9kZT10aGlzLnZub2RlLCB2ZG9tPXRoaXMudmRvbSwgZm9yY2U9ZmFsc2UpIHtcbiAgICAgICAgVkRvbVV0aWwuc3luY1Zkb21TdGF0ZSh2bm9kZSwgdmRvbSwgZm9yY2UpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW4gY2FzZSBhIGNvbXBvbmVudCByZWNlaXZlcyBhIG5ldyB2bm9kZSwgd2Ugd2FudCB0byBkbzpcbiAgICAgKiAtIHN5bmMgdGhlIHZkb20gaWRzXG4gICAgICogLSBzZXR0aW5nIHZub2RlSW5pdGlhbGl6ZWQgdG8gdHJ1ZSBmb3IgY2hpbGQgY29tcG9uZW50c1xuICAgICAqIC0gdXBkYXRpbmcgdGhlIHBhcmVudCBjb21wb25lbnQgdG8gZW5zdXJlIHRoYXQgdGhlIHZub2RlIHRyZWUgc3RheXMgcGVyc2lzdGVudFxuICAgICAqXG4gICAgICogKipJbXBsZW1lbnRhdGlvbiBEZXRhaWw6KipcbiAgICAgKiBUaGlzIG1ldGhvZCB1c2VzIGEgdHdvLXBhc3Mgc3RyYXRlZ3kgdG8gaGFuZGxlIGNoaWxkIHVwZGF0ZXM6XG4gICAgICogMS4gKipVcGRhdGUgVmlzaWJsZSBDaGlsZHJlbjoqKiBXZSBpdGVyYXRlIG92ZXIgY2hpbGRyZW4gZm91bmQgZGlyZWN0bHkgaW4gdGhlIG5ldyBWTm9kZSBzdHJ1Y3R1cmVcbiAgICAgKiAgICAodmlhIGBDb21wb25lbnRNYW5hZ2VyLmdldENoaWxkcmVuYCkuIFRoaXMgcHJlc2VydmVzIHRoZSBiYXNlbGluZSBiZWhhdmlvciB3aGVyZSBmdWxseSBleHBhbmRlZFxuICAgICAqICAgIFZOb2RlIHRyZWVzIChlLmcuLCBmcm9tIGBIZWxwZXIuY3JlYXRlYCkgYXJlIHN5bmNlZCB3aXRob3V0IHVubmVjZXNzYXJ5IFwiZG93bmdyYWRpbmdcIiB0byByZWZlcmVuY2VzLlxuICAgICAqIDIuICoqVW5tb3VudCBNaXNzaW5nIENoaWxkcmVuOioqIFdlIGl0ZXJhdGUgb3ZlciBBTEwgbG9naWNhbCBjaGlsZHJlbiAodmlhIGBDb21wb25lbnRNYW5hZ2VyLmZpbmRgKVxuICAgICAqICAgIHRvIGRldGVjdCBhbnkgdGhhdCBhcmUgYWJzZW50IGZyb20gdGhlIG5ldyBWTm9kZSB0cmVlIChlLmcuLCBgcmVtb3ZlRG9tOiB0cnVlYCkuXG4gICAgICogICAgQ3J1Y2lhbGx5LCB3ZSB1c2UgYFZOb2RlVXRpbC5maW5kYCB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIGEgXCJQbGFjZWhvbGRlclwiICh2YWxpZCwgZG8gbm90aGluZylcbiAgICAgKiAgICBhbmQgYSBcIlJlbW92YWxcIiAoaW52YWxpZCwgdW5tb3VudCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05lby52ZG9tLlZOb2RlfSBbdm5vZGU9dGhpcy52bm9kZV1cbiAgICAgKi9cbiAgICBzeW5jVm5vZGVUcmVlKHZub2RlPXRoaXMudm5vZGUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjaGlsZENvbXBvbmVudHMgPSBDb21wb25lbnRNYW5hZ2VyLmdldENoaWxkcmVuKG1lKSxcbiAgICAgICAgICAgIGRlYnVnICAgICAgICAgICA9IGZhbHNlLFxuICAgICAgICAgICAgbWFwICAgICAgICAgICAgID0ge30sXG4gICAgICAgICAgICBjaGlsZFZub2RlLCBzdGFydDtcblxuICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnN5bmNWZG9tU3RhdGUoKTtcblxuICAgICAgICBpZiAodm5vZGUgJiYgbWUuaWQgIT09IHZub2RlLmlkKSB7XG4gICAgICAgICAgICBDb21wb25lbnRNYW5hZ2VyLnJlZ2lzdGVyV3JhcHBlck5vZGUodm5vZGUuaWQsIG1lKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2UgbmVlZCBvbmUgc2VwYXJhdGUgaXRlcmF0aW9uIGZpcnN0IHRvIGVuc3VyZSBhbGwgd3JhcHBlciBub2RlcyBnZXQgcmVnaXN0ZXJlZFxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gY2hpbGRDb21wb25lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50ID0gY2hpbGRDb21wb25lbnRzW2ldO1xuICAgICAgICAgICAgY2hpbGRWbm9kZSA9IFZOb2RlVXRpbC5maW5kKG1lLnZub2RlLCBjb21wb25lbnQudmRvbS5pZCk/LnZub2RlO1xuXG4gICAgICAgICAgICBpZiAoY2hpbGRWbm9kZSkge1xuICAgICAgICAgICAgICAgIG1hcFtjb21wb25lbnQuaWRdID0gY2hpbGRWbm9kZTtcblxuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQuaWQgIT09IGNoaWxkVm5vZGUuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgQ29tcG9uZW50TWFuYWdlci5yZWdpc3RlcldyYXBwZXJOb2RlKGNoaWxkVm5vZGUuaWQsIGNvbXBvbmVudClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkZWxlZ2F0ZSB0aGUgbGF0ZXN0IG5vZGUgdXBkYXRlcyB0byBhbGwgcG9zc2libGUgY2hpbGQgY29tcG9uZW50cyBmb3VuZCBpbnNpZGUgdGhlIHZub2RlIHRyZWVcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGNoaWxkQ29tcG9uZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudCA9IGNoaWxkQ29tcG9uZW50c1tpXTtcbiAgICAgICAgICAgIGNoaWxkVm5vZGUgPSBtYXBbY29tcG9uZW50LmlkXTtcblxuICAgICAgICAgICAgaWYgKGNoaWxkVm5vZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBzaWxlbnQgdXBkYXRlXG4gICAgICAgICAgICAgICAgY29tcG9uZW50Ll92bm9kZSA9IENvbXBvbmVudE1hbmFnZXIuYWRkVm5vZGVDb21wb25lbnRSZWZlcmVuY2VzKGNoaWxkVm5vZGUsIGNvbXBvbmVudC5pZCk7XG5cbiAgICAgICAgICAgICAgICBjb21wb25lbnQudm5vZGVJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50Lm1vdW50ZWQgICAgICAgICAgPSB0cnVlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybignc3luY1Zub2RlVHJlZTogQ291bGQgbm90IHJlcGxhY2UgdGhlIGNoaWxkIHZub2RlIGZvcicsIGNvbXBvbmVudC5pZClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5ldyBsb2dpYyB0byBoYW5kbGUgdW5tb3VudGluZyBvZiByZW1vdmVkIGNoaWxkcmVuXG4gICAgICAgIGxldCBkaXJlY3RDaGlsZHJlbiA9IENvbXBvbmVudE1hbmFnZXIuZ2V0RGlyZWN0Q2hpbGRyZW4obWUuaWQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gZGlyZWN0Q2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnQgPSBkaXJlY3RDaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmICghY2hpbGRDb21wb25lbnRzLmluY2x1ZGVzKGNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgICBjaGlsZFZub2RlID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGl0IGV4aXN0cyBpbiB0aGUgdHJlZSAoYXMgcGxhY2Vob2xkZXIpXG4gICAgICAgICAgICAgICAgLy8gV2UgdXNlIFZOb2RlVXRpbC5maW5kIHdoaWNoIHJlc29sdmVzIHBsYWNlaG9sZGVyc1xuICAgICAgICAgICAgICAgIGlmIChtZS52bm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZFZub2RlID0gVk5vZGVVdGlsLmZpbmQobWUudm5vZGUsIGNvbXBvbmVudC52ZG9tLmlkKT8udm5vZGVcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWNoaWxkVm5vZGUgJiYgIWNvbXBvbmVudC5mbG9hdGluZykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuX3Zub2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50Lm1vdW50ZWQgPSBmYWxzZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNpbGVudCB1cGRhdGVcbiAgICAgICAgbWUuX3Zub2RlID0gdm5vZGUgPyBDb21wb25lbnRNYW5hZ2VyLmFkZFZub2RlQ29tcG9uZW50UmVmZXJlbmNlcyh2bm9kZSwgbWUuaWQpIDogbnVsbDtcblxuICAgICAgICBkZWJ1ZyAmJiBjb25zb2xlLmxvZygnc3luY1Zub2RlVHJlZScsIG1lLmlkLCBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgdXBkYXRlKCkge1xuICAgICAgICB0aGlzLmFmdGVyU2V0VmRvbSh0aGlzLnZkb20sIG51bGwpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgYWZ0ZXIgdGhlIHZkb20gY29uZmlnIGdldHMgY2hhbmdlZCBpbiBjYXNlIHRoZSBjb21wb25lbnQgaXMgYWxyZWFkeSBtb3VudGVkIChkZWx0YSB1cGRhdGVzKS5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcmVzb2x2ZV0gdXNlZCBieSBwcm9taXNlVXBkYXRlKClcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcmVqZWN0XSB1c2VkIGJ5IHByb21pc2VVcGRhdGUoKVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB1cGRhdGVWZG9tKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNDb25zdHJ1Y3RlZCkge1xuICAgICAgICAgICAgcmVzb2x2ZT8uKCk7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7bW91bnRlZCwgcGFyZW50SWQsIHZub2RlfSA9IG1lLFxuICAgICAgICAgICAge2NvbmZpZ30gICAgICAgICAgICAgICAgICAgPSBOZW87XG5cbiAgICAgICAgaWYgKGNvbmZpZy51bml0VGVzdE1vZGUgJiYgIWNvbmZpZy5hbGxvd1Zkb21VcGRhdGVzSW5UZXN0cykge1xuICAgICAgICAgICAgcmVqZWN0Py4oKTtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgbWUuZW5zdXJlU3RhYmxlSWRzKCk7XG5cbiAgICAgICAgLy8gSWYgdGhlcmUncyBhIHByb21pc2UsIHJlZ2lzdGVyIGl0IGFnYWluc3QgdGhpcyBjb21wb25lbnQncyBJRCBpbW1lZGlhdGVseS5cbiAgICAgICAgLy8gVGhlIG1hbmFnZXIgd2lsbCBlbnN1cmUgaXQncyBjYWxsZWQgd2hlbiB0aGUgYXBwcm9wcmlhdGUgdXBkYXRlIGN5Y2xlIGNvbXBsZXRlcy5cbiAgICAgICAgcmVzb2x2ZSAmJiBWRG9tVXBkYXRlLmFkZFByb21pc2VDYWxsYmFjayhtZS5pZCwgcmVzb2x2ZSk7XG5cbiAgICAgICAgLy8gQXR0ZW1wdCB0byBtZXJnZSBpbnRvIGEgcGFyZW50J3MgdXBkYXRlIGN5Y2xlLlxuICAgICAgICAvLyBXZSBkbyB0aGlzIGV2ZW4gaWYgc2lsZW50LCB0byBlbnN1cmUgd2UgY2F0Y2ggdGhlIGJ1cyBpZiBhIHBhcmVudCBpcyBkZXBhcnRpbmcuXG4gICAgICAgIGlmIChtZS5tZXJnZUludG9QYXJlbnRVcGRhdGUocGFyZW50SWQpKSB7XG4gICAgICAgICAgICBtZS5uZWVkc1Zkb21VcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWUuaXNWZG9tVXBkYXRpbmcgfHwgIW1lLnZub2RlSW5pdGlhbGl6ZWQgfHwgbWUuc2lsZW50VmRvbVVwZGF0ZSkge1xuICAgICAgICAgICAgbWUubmVlZHNWZG9tVXBkYXRlID0gdHJ1ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgYW4gdXBkYXRlIGlzIHRyaWdnZXJlZCBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LCB3ZSBtdXN0IHdhaXQgZm9yIGl0IHRvIGJlIG1vdW50ZWQuXG4gICAgICAgICAgICBpZiAoIW1vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgYSBmbGFnIHRvIHByZXZlbnQgc2V0dGluZyB1cCBtdWx0aXBsZSBgdGhlbmAgbGlzdGVuZXJzIGZvciBzdWJzZXF1ZW50IHVwZGF0ZXNcbiAgICAgICAgICAgICAgICAvLyB0aGF0IG1pZ2h0IGFycml2ZSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgICAgICAgICAgICAgIGlmICghbWUuaXNBd2FpdGluZ01vdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmlzQXdhaXRpbmdNb3VudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG1lLm1vdW50ZWRQcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUuaXNBd2FpdGluZ01vdW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZnRlciBtb3VudGluZywgcmUtdHJpZ2dlciB0aGUgdXBkYXRlIGN5Y2xlLiBUaGUgY2FjaGVkIGNhbGxiYWNrcyB3aWxsIGJlIHBpY2tlZCB1cC5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLnZub2RlICYmIG1lLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICFtZS5pc1BhcmVudFVwZGF0aW5nKHBhcmVudElkLCByZXNvbHZlKVxuICAgICAgICAgICAgICAgICAgICAmJiAhbWUuaXNDaGlsZFVwZGF0aW5nKHJlc29sdmUpXG4gICAgICAgICAgICAgICAgICAgICYmIHZub2RlXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBtZXJnZWQgY2hpbGQgdXBkYXRlcyBhbmQgYWRqdXN0IHRoZSB1cGRhdGUgZGVwdGggYWNjb3JkaW5nbHlcbiAgICAgICAgICAgICAgICAgICAgLy8gbGV0IGFkanVzdGVkRGVwdGggPSBWRG9tVXBkYXRlLmdldEFkanVzdGVkVXBkYXRlRGVwdGgobWUuaWQpO1xuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiAoYWRqdXN0ZWREZXB0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgbWUudXBkYXRlRGVwdGggPSBhZGp1c3RlZERlcHRoO1xuICAgICAgICAgICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVmVyaWZ5IHRoYXQgdGhlIGNyaXRpY2FsIHJlbmRlcmluZyBwYXRoID0+IENTUyBmaWxlcyBmb3IgdGhlIG5ldyB0cmVlIGlzIGluIHBsYWNlXG4gICAgICAgICAgICAgICAgICAgIGlmICghY29uZmlnLmlzTWlkZGxld2FyZSAmJiAhY29uZmlnLnVuaXRUZXN0TW9kZSAmJiBjdXJyZW50V29ya2VyLmNvdW50TG9hZGluZ1RoZW1lRmlsZXMgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRXb3JrZXIub24oJ3RoZW1lRmlsZXNMb2FkZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS51cGRhdGVWZG9tKHJlc29sdmUsIHJlamVjdClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIG1lLCB7b25jZTogdHJ1ZX0pXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5leGVjdXRlVmRvbVVwZGF0ZShudWxsLCByZWplY3QpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFZkb21MaWZlY3ljbGUpO1xuIiwiaW1wb3J0IEJ1dHRvbiAgICBmcm9tICcuLi9idXR0b24vQmFzZS5tanMnO1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQvQmFzZS5tanMnO1xuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuLi9jb250YWluZXIvQmFzZS5tanMnO1xuaW1wb3J0IExhYmVsICAgICBmcm9tICcuLi9jb21wb25lbnQvTGFiZWwubWpzJztcbmltcG9ydCBOZW9BcnJheSAgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8udG9vbGJhci5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29udGFpbmVyLkJhc2VcbiAqL1xuY2xhc3MgVG9vbGJhciBleHRlbmRzIENvbnRhaW5lciB7XG4gICAgLyoqXG4gICAgICogVmFsaWQgdmFsdWVzIGZvciBkb2NrXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IGRvY2tQb3NpdGlvbnM9Wyd0b3AnLCdyaWdodCcsJ2JvdHRvbScsJ2xlZnQnLCBudWxsXVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgZG9ja1Bvc2l0aW9ucyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0JywgbnVsbF1cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnRvb2xiYXIuQmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnRvb2xiYXIuQmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSd0b29sYmFyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3Rvb2xiYXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tdG9vbGJhciddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby10b29sYmFyJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gZG9ja189bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGRvY2tfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBpdGVtRGVmYXVsdHM9e250eXBlOididXR0b24nfVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1EZWZhdWx0czoge1xuICAgICAgICAgICAgbnR5cGU6ICdidXR0b24nXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGxheW91dD17bnR5cGU6J2ZsZXhib3gnLGFsaWduOidjZW50ZXInLGRpcmVjdGlvbjogJ3JvdycsIHBhY2s6J3N0YXJ0J31cbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBsYXlvdXQ6IHtcbiAgICAgICAgICAgIG50eXBlICAgIDogJ2ZsZXhib3gnLFxuICAgICAgICAgICAgYWxpZ24gICAgOiAnY2VudGVyJyxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogJ3JvdycsXG4gICAgICAgICAgICBwYWNrICAgICA6ICdzdGFydCdcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZG9jayBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXREb2NrKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlICYmICFvbGRWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2xzfSAgICAgICAgID0gbWUsXG4gICAgICAgICAgICBkb2NrUG9zaXRpb25zID0gbWUuZ2V0U3RhdGljQ29uZmlnKCdkb2NrUG9zaXRpb25zJyksXG4gICAgICAgICAgICBsYXlvdXRDb25maWcgID0gbWUuZ2V0TGF5b3V0Q29uZmlnKCk7XG5cbiAgICAgICAgZG9ja1Bvc2l0aW9ucy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBrZXkgIT09IG51bGwgJiYgTmVvQXJyYXkudG9nZ2xlKGNscywgJ25lby1kb2NrLScgKyBrZXksIGtleSA9PT0gdmFsdWUpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghbWUubGF5b3V0KSB7XG4gICAgICAgICAgICBsYXlvdXRDb25maWcubnR5cGUgPSAnZmxleGJveCc7XG4gICAgICAgICAgICBtZS5zZXQoe2NscywgbGF5b3V0OiBsYXlvdXRDb25maWd9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUubGF5b3V0LnNldChsYXlvdXRDb25maWcpO1xuICAgICAgICAgICAgbWUuY2xzID0gY2xzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBuZXcgZG9jayBwb3NpdGlvbiBtYXRjaGVzIGEgdmFsdWUgb2YgdGhlIHN0YXRpYyBkb2NrUG9zaXRpb25zIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldERvY2sodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlZm9yZVNldEVudW1WYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICdkb2NrJywgJ2RvY2tQb3NpdGlvbnMnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgY3JlYXRlSXRlbXMoKSB7XG4gICAgICAgIGxldCBpdGVtcyA9IHRoaXMuX2l0ZW1zO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICAgICAgdGhpcy5faXRlbXMgPSBpdGVtcy5tYXAoaXRlbSA9PiB0aGlzLnJlcGxhY2VTcGFjZXIoaXRlbSkpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VwZXIuY3JlYXRlSXRlbXMoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBsYXlvdXQgY29uZmlnIGRlcGVuZGluZyBvbiB0aGlzLmRvY2tcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBsYXlvdXRDb25maWdcbiAgICAgKi9cbiAgICBnZXRMYXlvdXRDb25maWcoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBsYXlvdXRDb25maWc7XG5cbiAgICAgICAgaWYgKG1lLmRvY2spIHtcbiAgICAgICAgICAgIHN3aXRjaCAobWUuZG9jaykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0Q29uZmlnID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ24gICAgOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ3JvdycsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWNrICAgICA6ICdzdGFydCdcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0Q29uZmlnID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ24gICAgOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2NvbHVtbi1yZXZlcnNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhY2sgICAgIDogJ3N0YXJ0J1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0Q29uZmlnID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ24gICAgOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWNrICAgICA6ICdzdGFydCdcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsYXlvdXRDb25maWcgfHwgbWUubGF5b3V0XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhbiBpdGVtIG9yIGFycmF5IG9mIGl0ZW1zIGF0IGEgc3BlY2lmaWMgaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gaXRlbVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbGVudD1mYWxzZV1cbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlfE5lby5jb21wb25lbnQuQmFzZVtdfVxuICAgICAqL1xuICAgIGluc2VydChpbmRleCwgaXRlbSwgc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgICAgICBpdGVtID0gaXRlbS5tYXAoaXRlbSA9PiB0aGlzLnJlcGxhY2VTcGFjZXIoaXRlbSkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVtID0gdGhpcy5yZXBsYWNlU3BhY2VyKGl0ZW0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VwZXIuaW5zZXJ0KGluZGV4LCBpdGVtLCBzaWxlbnQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8U3RyaW5nfSBpdGVtXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH1cbiAgICAgKi9cbiAgICByZXBsYWNlU3BhY2VyKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gPT09ICctPicgPyB7bW9kdWxlOiBDb21wb25lbnQsIGZsZXg6IDF9IDogaXRlbVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXG4gICAgICAgICAgICBkb2NrOiB0aGlzLmRvY2tcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVG9vbGJhcik7XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnV0aWwuQ2xhc3NTeXN0ZW1cbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgQ2xhc3NTeXN0ZW0gZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby51dGlsLkNsYXNzU3lzdGVtJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8udXRpbC5DbGFzc1N5c3RlbSdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjYW4gZ2V0IHVzZWQgaW5zaWRlIGJlZm9yZVNldCBtZXRob2RzIGluIGNhc2UgeW91IHdhbnQgdG8gY3JlYXRlIGluc3RhbmNlcyBsaWtlIHN0b3Jlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fE5lby5jb3JlLkJhc2V8bnVsbH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtOZW8uY29yZS5CYXNlfFN0cmluZ30gW0RlZmF1bHRDbGFzcz1udWxsXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZGVmYXVsdFZhbHVlcz17fV1cbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvcmUuQmFzZX0gaW5zdGFuY2VcbiAgICAgKi9cbiAgICBzdGF0aWMgYmVmb3JlU2V0SW5zdGFuY2UoY29uZmlnLCBEZWZhdWx0Q2xhc3M9bnVsbCwgZGVmYXVsdFZhbHVlcz17fSkge1xuICAgICAgICBsZXQgY29uZmlnVHlwZSA9IE5lby50eXBlT2YoY29uZmlnKTtcblxuICAgICAgICBpZiAoTmVvLmlzU3RyaW5nKERlZmF1bHRDbGFzcykpIHtcbiAgICAgICAgICAgIERlZmF1bHRDbGFzcyA9IE5lby5ucyhEZWZhdWx0Q2xhc3MpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNvbmZpZyAmJiBEZWZhdWx0Q2xhc3MpIHtcbiAgICAgICAgICAgIGNvbmZpZyA9IE5lby5jcmVhdGUoRGVmYXVsdENsYXNzLCBkZWZhdWx0VmFsdWVzKVxuICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZ1R5cGUgPT09ICdOZW9DbGFzcycpIHtcbiAgICAgICAgICAgIGNvbmZpZyA9IE5lby5jcmVhdGUoY29uZmlnLCBkZWZhdWx0VmFsdWVzKVxuICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZ1R5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAoY29uZmlnLm50eXBlKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnID0gTmVvLm50eXBlKHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZGVmYXVsdFZhbHVlcyxcbiAgICAgICAgICAgICAgICAgICAgLi4uY29uZmlnXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld0NvbmZpZyA9IHt9O1xuXG4gICAgICAgICAgICAgICAgaWYgKERlZmF1bHRDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICBuZXdDb25maWcubW9kdWxlID0gRGVmYXVsdENsYXNzXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihuZXdDb25maWcsIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZGVmYXVsdFZhbHVlcyxcbiAgICAgICAgICAgICAgICAgICAgLi4uY29uZmlnXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBjb25maWcgPSBOZW8uY3JlYXRlKG5ld0NvbmZpZylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjb25maWdUeXBlID09PSAnTmVvSW5zdGFuY2UnKSB7XG4gICAgICAgICAgICBpZiAoZGVmYXVsdFZhbHVlcz8ubGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLm9uKGRlZmF1bHRWYWx1ZXMubGlzdGVuZXJzKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbmZpZ1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ2xhc3NTeXN0ZW0pO1xuIiwiaW1wb3J0IEJhc2UgICAgIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuaW1wb3J0IE5lb0FycmF5IGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnV0aWwuS2V5TmF2aWdhdGlvblxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBLZXlOYXZpZ2F0aW9uIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8udXRpbC5LZXlOYXZpZ2F0aW9uJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8udXRpbC5LZXlOYXZpZ2F0aW9uJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2tleW5hdidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdrZXluYXYnLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWxseSBzdG9yZXMgdGhlIGNvbXBvbmVudCBpZCBpbnNpZGUgX2NvbXBvbmVudFxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH0gY29tcG9uZW50Xz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgY29tcG9uZW50XzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGlzIHRvIHRydWUgaW4gY2FzZSB0aGUga2V5ZG93biBldmVudCBpcyBzdXBwb3NlZCB0byBidWJibGUgdXB3YXJkcyBpbnNpZGUgdGhlIGNvbXBvbmVudCB0cmVlXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGtleURvd25FdmVudEJ1YmJsZT1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAga2V5RG93bkV2ZW50QnViYmxlOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5fG51bGx9IGtleXNfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBrZXlzXzogbnVsbFxuICAgIH1cblxuICAgIGFkZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9rZXlzLnB1c2goLi4udGhpcy5wYXJzZUtleXModmFsdWUpKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlfVxuICAgICAqL1xuICAgIGJlZm9yZUdldENvbXBvbmVudCgpIHtcbiAgICAgICAgcmV0dXJuIE5lby5nZXRDb21wb25lbnQodGhpcy5fY29tcG9uZW50KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSB2YWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB0aGUgY29tcG9uZW50IGlkXG4gICAgICovXG4gICAgYmVmb3JlU2V0Q29tcG9uZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZT8uaWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMudW5yZWdpc3RlcigpO1xuICAgICAgICBzdXBlci5kZXN0cm95KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uS2V5RG93bihkYXRhKSB7XG4gICAgICAgIC8vIFVzaW5nIHRoZSBjaHJvbWUgYXV0by1maWxsIGZlYXR1cmUgZG9lcyB0cmlnZ2VyIGEga2V5ZG93biBldmVudCwgbm90IGNvbnRhaW5pbmcgYSBrZXkuIFNlZTogIzY0XG4gICAgICAgIGlmIChkYXRhLmtleSkge1xuICAgICAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgdXBwZXJDYXNlS2V5ID0gZGF0YS5rZXkudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgICAgICBzY29wZTtcblxuICAgICAgICAgICAgdXBwZXJDYXNlS2V5ID0gbWUucGFyc2VVcHBlckNhc2VLZXkodXBwZXJDYXNlS2V5KTtcblxuICAgICAgICAgICAgbWUua2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgc2NvcGUgPSBOZW8uaXNTdHJpbmcoa2V5LnNjb3BlKSA/IE5lby5nZXQoa2V5LnNjb3BlKSA6IGtleS5zY29wZTtcblxuICAgICAgICAgICAgICAgIGlmIChrZXkua2V5LnRvVXBwZXJDYXNlKCkgPT09IHVwcGVyQ2FzZUtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoTmVvLmlzRnVuY3Rpb24oa2V5LmZuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LmZuLmFwcGx5KHNjb3BlLCBbZGF0YSwgbWUuY29tcG9uZW50XSlcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlW2tleS5mbl0/LmFwcGx5KHNjb3BlLCBbZGF0YSwgbWUuY29tcG9uZW50XSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHBhcnNlS2V5cyh2YWx1ZSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50SWQgPSB0aGlzLl9jb21wb25lbnQsXG4gICAgICAgICAgICAgICAga2V5QXJyYXkgICAgPSBbXTtcblxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudElkKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXModmFsdWUpLmZvckVhY2goKFtrZXksIHZhbF0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gJ3Njb3BlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5QXJyYXkucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4gICA6IHZhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGU6IHZhbHVlLnNjb3BlIHx8IGNvbXBvbmVudElkIC8vIHRvZG86IHN1cHBvcnQgVkNzIGxhdGVyIG9uXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGtleUFycmF5XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBzcGVjaWZpYyBrZXkgbmFtZXMsIGUuZy4gXCIgXCIgPT4gU1BBQ0VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgcGFyc2VVcHBlckNhc2VLZXkoa2V5KSB7XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgICAgICAgICBrZXkgPSAnU1BBQ0UnO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlICdBUlJPV0RPV04nOlxuICAgICAgICAgICAgICAgIGtleSA9ICdET1dOJztcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSAnQVJST1dMRUZUJzpcbiAgICAgICAgICAgICAgICBrZXkgPSAnTEVGVCc7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgJ0FSUk9XUklHSFQnOlxuICAgICAgICAgICAgICAgIGtleSA9ICdSSUdIVCc7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgJ0FSUk9XVVAnOlxuICAgICAgICAgICAgICAgIGtleSA9ICdVUCc7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBrZXlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50XG4gICAgICovXG4gICAgcmVnaXN0ZXIoY29tcG9uZW50KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICBtZS5rZXlzICAgICAgPSBtZS5wYXJzZUtleXMobWUua2V5cyk7XG5cbiAgICAgICAgY29tcG9uZW50LmFkZERvbUxpc3RlbmVycyh7XG4gICAgICAgICAgICBrZXlkb3duOiB7XG4gICAgICAgICAgICAgICAgYnViYmxlOiBtZS5rZXlEb3duRXZlbnRCdWJibGUsXG4gICAgICAgICAgICAgICAgZm4gICAgOiBtZS5vbktleURvd24sXG4gICAgICAgICAgICAgICAgc2NvcGUgOiBtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGtleSBsaXN0ZW5lciB1c2luZyB0aGUgc2FtZSBjb25maWcgdXNlZCB3aGVuIGNyZWF0aW5nIGl0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIHJlbW92ZUtleShjb25maWcpIHtcbiAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAga2V5cyA9IG1lLl9rZXlzLFxuICAgICAgICAgICAgaSAgICA9IDAsXG4gICAgICAgICAgICBsZW4gID0ga2V5cy5sZW5ndGgsXG4gICAgICAgICAgICBrZXk7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICAgICAgaWYgKE5lby5pc0VxdWFsKGtleSwgY29uZmlnKSkge1xuICAgICAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZShrZXlzLCBrZXkpO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgbXVsdGlwbGUga2V5IGxpc3RlbmVycyBwYXNzaW5nIGFuIGFycmF5IG9mIGNvbmZpZyBpdGVtc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGl0ZW1zXG4gICAgICovXG4gICAgcmVtb3ZlS2V5cyhpdGVtcykge1xuICAgICAgICBBcnJheS5pc0FycmF5KGl0ZW1zKSAmJiBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4gdGhpcy5yZW1vdmVLZXkoaXRlbSkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICB1bnJlZ2lzdGVyKCkge1xuICAgICAgICAvLyB0b2RvOiByZW1vdmUgdGhlIGRvbSBsaXN0ZW5lciBmcm9tIHRoZSBvd25lciBjb21wb25lbnRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIHRoZSBLZXlOYXZpZ2F0aW9uIGludG8gYSBKU09OLWNvbXBhdGlibGUgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcbiAgICAgICAgICAgIGNvbXBvbmVudDogbWUuc2VyaWFsaXplQ29uZmlnKG1lLmNvbXBvbmVudCksXG4gICAgICAgICAgICBrZXlzICAgICA6IG1lLnNlcmlhbGl6ZUNvbmZpZyhtZS5rZXlzKVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhLZXlOYXZpZ2F0aW9uKTtcbiIsIi8qKlxuICogVGhlIGNsYXNzIGNvbnRhaW5zIHV0aWxpdHkgbWV0aG9kcyBmb3Igd29ya2luZyB3aXRoIERPTVJlY3QgT2JqZWN0c1xuICogQGNsYXNzIE5lby51dGlsLlJlY3RhbmdsZVxuICogQGV4dGVuZHMgRE9NUmVjdFxuICovXG5cbmNvbnN0XG4gICAgZW1wdHlBcnJheSA9IE9iamVjdC5mcmVlemUoW10pLFxuICAgIC8vIENvbnZlcnQgZWRnZSBhcnJheSB2YWx1ZXMgaW50byB0aGUgW1QsUixCLExdIGZvcm0uXG4gICAgcGFyc2VFZGdlVmFsdWUgPSAoZSA9IDApID0+IHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICAgICAgICBlID0gW2VdO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBlLmxlbmd0aCA9IDQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUuZmlsbChlWzBdLCAxLCA0KTtcbiAgICAgICAgICAgIGNhc2UgMjovLyB0b3AmYm90dG9tLCBsZWZ0JnJpZ2h0XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtlWzBdLCBlWzFdLCBlWzBdLCBlWzFdXTtcbiAgICAgICAgICAgIGNhc2UgMzovLyB0b3AsIGxlZnQmcmlnaHQsIGJvdHRvbVxuICAgICAgICAgICAgICAgIHJldHVybiBbZVswXSwgZVsxXSwgZVsyXSwgZVsxXV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfSxcbiAgICBwYXJzZUVkZ2VBbGlnbiA9IGVkZ2VBbGlnbiA9PiB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBlZGdlUGFydHMgICAgID0gZWRnZUFsaWduUkUuZXhlYyhlZGdlQWxpZ24pLFxuICAgICAgICAgICAgb3VyRWRnZVpvbmUgICA9IGVkZ2Vab25lW2VkZ2VQYXJ0c1sxXV0sXG4gICAgICAgICAgICB0aGVpckVkZ2Vab25lID0gZWRnZVpvbmVbZWRnZVBhcnRzWzRdXTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3VyRWRnZSAgICAgICAgIDogZWRnZVBhcnRzWzFdLFxuICAgICAgICAgICAgb3VyRWRnZU9mZnNldCAgIDogcGFyc2VJbnQoZWRnZVBhcnRzWzJdIHx8IDUwKSxcbiAgICAgICAgICAgIG91ckVkZ2VVbml0ICAgICA6IGVkZ2VQYXJ0c1szXSB8fCAnJScsXG4gICAgICAgICAgICBvdXJFZGdlWm9uZSxcbiAgICAgICAgICAgIHRoZWlyRWRnZSAgICAgICA6IGVkZ2VQYXJ0c1s0XSxcbiAgICAgICAgICAgIHRoZWlyRWRnZU9mZnNldCA6IHBhcnNlSW50KGVkZ2VQYXJ0c1s1XSB8fCA1MCksXG4gICAgICAgICAgICB0aGVpckVkZ2VVbml0ICAgOiBlZGdlUGFydHNbNl0gfHwgJyUnLFxuICAgICAgICAgICAgdGhlaXJFZGdlWm9uZSxcblxuICAgICAgICAgICAgLy8gQWxpZ25lZCB0byBhbiBlZGdlLCAqb3V0c2lkZSogb2YgdGhlIHRhcmdldC5cbiAgICAgICAgICAgIC8vIEEgbm9ybWFsIGFsaWduIGFzIGEgY29tYm8gZHJvcGRvd24gbWlnaHQgcmVxdWVzdFxuICAgICAgICAgICAgZWRnZUFsaWduZWQgICAgIDogKG91ckVkZ2Vab25lICYgMSkgPT09ICh0aGVpckVkZ2Vab25lICYgMSkgJiYgb3VyRWRnZVpvbmUgIT09IHRoZWlyRWRnZVpvbmVcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLy8gVGhlIG9wcG9zaXRlIG9mIHBhcnNlRWRnZUFsaWduLCBhbmQgaXQgaGFzIHRvIGZsaXAgdGhlIGVkZ2VzXG4gICAgY3JlYXRlUmV2ZXJzZWRFZGdlQWxpZ24gPSBlZGdlcyA9PiB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBvdXJFZGdlICAgPSBvcHBvc2l0ZUVkZ2VbZWRnZXMub3VyRWRnZV0sXG4gICAgICAgICAgICB0aGVpckVkZ2UgPSBvcHBvc2l0ZUVkZ2VbZWRnZXMudGhlaXJFZGdlXTtcblxuICAgICAgICAvLyByZWNvbnN0aXR1dGUgYSBydWxlIHN0cmluZyB3aXRoIHRoZSBlZGdlcyBmbGlwcGVkIHRvIHRoZSBvcHBvc2l0ZSBzaWRlc1xuICAgICAgICByZXR1cm4gYCR7b3VyRWRnZX0ke2VkZ2VzLm91ckVkZ2VPZmZzZXR9JHtlZGdlcy5vdXJFZGdlVW5pdH0tJHt0aGVpckVkZ2V9JHtlZGdlcy50aGVpckVkZ2VPZmZzZXR9JHtlZGdlcy50aGVpckVkZ2VVbml0fWBcblxuICAgIH0sXG4gICAgZ2V0RWxSZWN0ID0gZWwgPT4ge1xuICAgICAgICBjb25zdCByID0gZWwgaW5zdGFuY2VvZiBET01SZWN0ID8gZWwgOiAoZWw/Lm5vZGVUeXBlID09PSAxID8gZWwgOiB0eXBlb2YgZWwgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWwpIDogbnVsbCk/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIC8vIENvbnZlcnQgRE9NUmVjdCBpbnRvIFJlY3RhbmdsZVxuICAgICAgICByZXR1cm4gciAmJiBuZXcgUmVjdGFuZ2xlKHIueCwgci55LCByLndpZHRoLCByLmhlaWdodCk7XG4gICAgfSxcbiAgICBvcHBvc2l0ZUVkZ2UgPSB7XG4gICAgICAgIHQgOiAnYicsXG4gICAgICAgIHIgOiAnbCcsXG4gICAgICAgIGIgOiAndCcsXG4gICAgICAgIGwgOiAncidcbiAgICB9LFxuICAgIGVkZ2Vab25lID0ge1xuICAgICAgICB0IDogMCxcbiAgICAgICAgciA6IDEsXG4gICAgICAgIGIgOiAyLFxuICAgICAgICBsIDogM1xuICAgIH0sXG4gICAgem9uZU5hbWVzID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXSxcbiAgICB6b25lRWRnZXMgPSBbJ3QnLCAncicsICdiJywgJ2wnXSxcbiAgICB6b25lRGltZW5zaW9uID0gWyd3aWR0aCcsICdoZWlnaHQnXSxcbiAgICB6b25lQ29vcmQgPSBbMCwgMSwgMCwgMV0sXG4gICAgemVyb01hcmdpbnMgPSBbMCwgMCwgMCwgMF0sXG4gICAgZWRnZUFsaWduUkUgPSAvXihbdHJibGNdKShcXGQqKSglfHB4KT8tKFt0cmJsY10pKFxcZCopKCV8cHgpPyQvO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWN0YW5nbGUgZXh0ZW5kcyBET01SZWN0IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby51dGlsLlJlY3RhbmdsZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnV0aWwuUmVjdGFuZ2xlJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBtaW5IZWlnaHQ9bnVsbFxuICAgICAqL1xuICAgIG1pbkhlaWdodCA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gbWluV2lkdGg9bnVsbFxuICAgICAqL1xuICAgIG1pbldpZHRoID0gbnVsbFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHJlY3QxIGRvZXMgbm90IGhhdmUgYW4gaW50ZXJzZWN0aW9uIHdpdGggcmVjdDJcbiAgICAgKiAhaW5jbHVkZXMoKSBpcyB0cnVlIGZvciBpbnRlcnNlY3Rpb25zIGFzIHdlbGxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdDJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgZXhjbHVkZXMocmVjdDEsIHJlY3QyKSB7XG4gICAgICAgIHJldHVybiByZWN0MS5ib3R0b20gPCByZWN0Mi50b3AgICAgIC8vIHJlY3QyIGlzIGJlbG93IHJlY3QxXG4gICAgICAgICAgICB8fCByZWN0MS5sZWZ0ICAgPiByZWN0Mi5yaWdodCAgIC8vIHJlY3QyIGlzIGxlZnQgb2YgcmVjdDFcbiAgICAgICAgICAgIHx8IHJlY3QxLnJpZ2h0ICA8IHJlY3QyLmxlZnQgICAgLy8gcmVjdDIgaXMgcmlnaHQgb2YgcmVjdDFcbiAgICAgICAgICAgIHx8IHJlY3QxLnRvcCAgICA+IHJlY3QyLmJvdHRvbTsgLy8gcmVjdDIgaXMgYWJvdmUgcmVjdDFcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBvdmVybGFwcGluZyBhcmVhIG9mIHJlY3QxICYgcmVjdDIgYXMgYSBuZXcgUmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtET01SZWN0fE5lby51dGlsLlJlY3RhbmdsZX0gcmVjdDFcbiAgICAgKiBAcGFyYW0ge0RPTVJlY3R8TmVvLnV0aWwuUmVjdGFuZ2xlfSByZWN0MlxuICAgICAqIEByZXR1cm5zIHtOZW8udXRpbC5SZWN0YW5nbGV8bnVsbH0gVGhlIGludGVyc2VjdGluZyByZWN0XG4gICAgICovXG4gICAgc3RhdGljIGdldEludGVyc2VjdGlvbihyZWN0MSwgcmVjdDIpIHtcbiAgICAgICAgbGV0IHggICAgICA9IE1hdGgubWF4KHJlY3QxLngsICAgICAgcmVjdDIueCksXG4gICAgICAgICAgICB5ICAgICAgPSBNYXRoLm1heChyZWN0MS55LCAgICAgIHJlY3QyLnkpLFxuICAgICAgICAgICAgcmlnaHQgID0gTWF0aC5taW4ocmVjdDEucmlnaHQsICByZWN0Mi5yaWdodCksXG4gICAgICAgICAgICBib3R0b20gPSBNYXRoLm1pbihyZWN0MS5ib3R0b20sIHJlY3QyLmJvdHRvbSksXG4gICAgICAgICAgICB3aWR0aCAgPSBNYXRoLm1heCgwLCByaWdodCAgLSB4KSxcbiAgICAgICAgICAgIGhlaWdodCA9IE1hdGgubWF4KDAsIGJvdHRvbSAtIHkpO1xuXG4gICAgICAgIGlmIChoZWlnaHQgPCAxIHx8IHdpZHRoIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHJlY3QyIGlzIGZ1bGx5IGNvbnRhaW5lZCBpbnNpZGUgcmVjdDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdDJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgaW5jbHVkZXMocmVjdDEsIHJlY3QyKSB7XG4gICAgICAgIHJldHVybiByZWN0MS5ib3R0b20gPj0gcmVjdDIuYm90dG9tXG4gICAgICAgICAgICAmJiByZWN0MS5sZWZ0ICAgPD0gcmVjdDIubGVmdFxuICAgICAgICAgICAgJiYgcmVjdDEucmlnaHQgID49IHJlY3QyLnJpZ2h0XG4gICAgICAgICAgICAmJiByZWN0MS50b3AgICAgPD0gcmVjdDIudG9wO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiByZWN0MiBpcyBub3QgY29udGFpbmVkIGluc2lkZSByZWN0MS5cbiAgICAgKiBUaGlzIGNvdWxkIGJlIGFuIGludGVyc2VjdGlvbiBvciBiZWluZyBmdWxseSBleGNsdWRlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdDJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2lkZSBib3R0b20sIGxlZnQsIHJpZ2h0IG9yIHRvcFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBsZWF2ZXNTaWRlKHJlY3QxLCByZWN0Miwgc2lkZSkge1xuICAgICAgICBpZiAoUmVjdGFuZ2xlLmluY2x1ZGVzKHJlY3QxLCByZWN0MikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaWRlID09PSAnYm90dG9tJykge1xuICAgICAgICAgICAgcmV0dXJuIHJlY3QxLmJvdHRvbSA8IHJlY3QyLmJvdHRvbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaWRlID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgIHJldHVybiByZWN0MS5sZWZ0ID4gcmVjdDIubGVmdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaWRlID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjdDEucmlnaHQgPCByZWN0Mi5yaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaWRlID09PSAndG9wJykge1xuICAgICAgICAgICAgcmV0dXJuIHJlY3QxLnRvcCA+IHJlY3QyLnRvcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkanVzdHMgYSBET01SZWN0IG9iamVjdCB0byBhIG5ldyBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gW3g9bnVsbF1cbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBbeT1udWxsXVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IG1vdmVkUmVjdFxuICAgICAqL1xuICAgIHN0YXRpYyBtb3ZlQnkocmVjdCwgeD1udWxsLCB5PW51bGwpIHtcbiAgICAgICAgbGV0IG1vdmVkUmVjdCA9IHsuLi5yZWN0fTtcblxuICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKHgpKSB7XG4gICAgICAgICAgICBtb3ZlZFJlY3QubGVmdCAgKz0geDtcbiAgICAgICAgICAgIG1vdmVkUmVjdC5yaWdodCArPSB4O1xuICAgICAgICAgICAgbW92ZWRSZWN0LnggICAgICs9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKHkpKSB7XG4gICAgICAgICAgICBtb3ZlZFJlY3QuYm90dG9tICs9IHk7XG4gICAgICAgICAgICBtb3ZlZFJlY3QudG9wICAgICs9IHk7XG4gICAgICAgICAgICBtb3ZlZFJlY3QueSAgICAgICs9IHk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbW92ZWRSZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkanVzdHMgYSBET01SZWN0IG9iamVjdCB0byBhIG5ldyBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gW3g9bnVsbF1cbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBbeT1udWxsXVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IG1vdmVkUmVjdFxuICAgICAqL1xuICAgIHN0YXRpYyBtb3ZlVG8ocmVjdCwgeD1udWxsLCB5PW51bGwpIHtcbiAgICAgICAgbGV0IG1vdmVkUmVjdCA9IHsuLi5yZWN0fTtcblxuICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKHgpKSB7XG4gICAgICAgICAgICBtb3ZlZFJlY3QubGVmdCAgPSB4O1xuICAgICAgICAgICAgbW92ZWRSZWN0LnJpZ2h0ID0geCArIG1vdmVkUmVjdC53aWR0aDtcbiAgICAgICAgICAgIG1vdmVkUmVjdC54ICAgICA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKHkpKSB7XG4gICAgICAgICAgICBtb3ZlZFJlY3QuYm90dG9tID0geSArIG1vdmVkUmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICBtb3ZlZFJlY3QudG9wICAgID0geTtcbiAgICAgICAgICAgIG1vdmVkUmVjdC55ICAgICAgPSB5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1vdmVkUmVjdDtcbiAgICB9XG5cbiAgICBzZXQgYm90dG9tKGIpIHtcbiAgICAgICAgdGhpcy5oZWlnaHQgKz0gYiAtIHRoaXMuYm90dG9tO1xuICAgIH1cbiAgICBnZXQgYm90dG9tKCkge1xuICAgICAgICByZXR1cm4gc3VwZXIuYm90dG9tO1xuICAgIH1cblxuICAgIHNldCByaWdodChyKSB7XG4gICAgICAgIHRoaXMud2lkdGggKz0gciAtIHRoaXMucmlnaHQ7XG4gICAgfVxuICAgIGdldCByaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnJpZ2h0O1xuICAgIH1cblxuICAgIC8vIENoYW5nZSB0aGUgeCB3aXRob3V0IG1vdmluZyB0aGUgUmVjdGFuZ2xlLiBUaGUgbGVmdCBzaWRlIG1vdmVzIGFuZCB0aGUgcmlnaHQgc2lkZSBkb2Vzbid0XG4gICAgY2hhbmdlWCh4KSB7XG4gICAgICAgIGNvbnN0IHdpZHRoRGVsdGEgPSB0aGlzLnggLSB4O1xuXG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMud2lkdGggKz0gd2lkdGhEZWx0YTtcbiAgICB9XG5cbiAgICAvLyBDaGFuZ2UgdGhlIHkgd2l0aG91dCBtb3ZpbmcgdGhlIFJlY3RhbmdsZS4gVGhlIHRvcCBzaWRlIG1vdmVzIGFuZCB0aGUgYm90dG9tIHNpZGUgZG9lc24ndFxuICAgIGNoYW5nZVkoeSkge1xuICAgICAgICBjb25zdCBoZWlnaHREZWx0YSA9IHRoaXMueSAtIHk7XG5cbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy5oZWlnaHQgKz0gaGVpZ2h0RGVsdGE7XG4gICAgfVxuXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBSZWN0YW5nbGUuY2xvbmUodGhpcyk7XG4gICAgfVxuXG4gICAgc3RhdGljIGNsb25lKHIpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFJlY3RhbmdsZShyLngsIHIueSwgci53aWR0aCwgci5oZWlnaHQpO1xuXG4gICAgICAgIHJlc3VsdC5taW5XaWR0aCA9IHIubWluV2lkdGg7XG4gICAgICAgIHJlc3VsdC5taW5IZWlnaHQgPSByLm1pbkhlaWdodDtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGludGVyc2VjdHMob3RoZXIpIHtcbiAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChvdGhlci5oZWlnaHQgJiYgb3RoZXIud2lkdGgpIHtcbiAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgICAgbGVmdCAgID0gTWF0aC5tYXgobWUueCwgb3RoZXIueCksXG4gICAgICAgICAgICAgICAgdG9wICAgID0gTWF0aC5tYXgobWUueSwgb3RoZXIueSksXG4gICAgICAgICAgICAgICAgcmlnaHQgID0gTWF0aC5taW4obWUueCArIG1lLndpZHRoLCBvdGhlci54ICsgb3RoZXIud2lkdGgpLFxuICAgICAgICAgICAgICAgIGJvdHRvbSA9IE1hdGgubWluKG1lLnkgKyBtZS5oZWlnaHQsIG90aGVyLnkgKyBvdGhlci5oZWlnaHQpO1xuXG4gICAgICAgICAgICBpZiAobGVmdCA+PSByaWdodCB8fCB0b3AgPj0gYm90dG9tKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZShsZWZ0LCB0b3AsIHJpZ2h0IC0gbGVmdCwgYm90dG9tIC0gdG9wKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSdyZSBkZWFsaW5nIHdpdGggYSBwb2ludCBoZXJlIC0gemVybyBkaW1lbnNpb25zXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIChvdGhlci54ID49IG1lLnggJiYgb3RoZXIueSA+PSBtZS55ICYmIG90aGVyLnJpZ2h0IDw9IG1lLnJpZ2h0ICYmIG90aGVyLmJvdHRvbSA8PSBtZS5ib3R0b20pO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhpcyBSZWN0YW5nbGUgZXhwYW5kZWQgYWNjb3JkaW5nIHRvIHRoZSBlZGdlcyBhcnJheS5cbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSBlZGdlc1xuICAgICAqIEByZXR1cm5zIHtSZWN0YW5nbGV9XG4gICAgICovXG4gICAgZXhwYW5kKGVkZ2VzKSB7XG4gICAgICAgIGVkZ2VzID0gcGFyc2VFZGdlVmFsdWUoZWRnZXMpO1xuXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLnggLSBlZGdlc1szXSwgdGhpcy55IC0gZWRnZXNbMF0sIHRoaXMud2lkdGggKyBlZGdlc1sxXSArIGVkZ2VzWzNdLCB0aGlzLmhlaWdodCArIGVkZ2VzWzBdICsgZWRnZXNbMl0pO1xuICAgIH1cblxuICAgIG1vdmVCeSh4ID0gMCwgeSA9IDApIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHgpKSB7XG4gICAgICAgICAgICB5ID0geFsxXTtcbiAgICAgICAgICAgIHggPSB4WzBdO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC54ICs9IHg7XG4gICAgICAgIHJlc3VsdC55ICs9IHk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhpcyBSZWN0YW5nbGUgY29tcGxldGVseSBjb250YWlucyB0aGUgb3RoZXIgUmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IG90aGVyXG4gICAgICovXG4gICAgY29udGFpbnMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIFJlY3RhbmdsZS5pbmNsdWRlcyh0aGlzLCBvdGhlcilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGlzIFJlY3RhbmdsZSBjb25zdHJhaW5lZCB0byBmaXQgd2l0aGluIHRoZSBwYXNzZWQgUmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IGNvbnN0cmFpblRvXG4gICAgICogQHJldHVybnMge1JlY3RhbmdsZXxCb29sZWFufSBBIG5ldyBSZWN0YW5nbGUgY29uc3RyYWluZWQgdG8gdGUgcGFzc2VkIFJlY3RhbmdsZSwgb3IgZmFsc2UgaWYgaXQgY291bGQgbm90IGJlIGNvbnN0cmFpbmVkLlxuICAgICAqL1xuICAgIGNvbnN0cmFpblRvKGNvbnN0cmFpblRvKSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgbWluV2lkdGggID0gbWUubWluV2lkdGggIHx8IG1lLndpZHRoLFxuICAgICAgICAgICAgbWluSGVpZ2h0ID0gbWUubWluSGVpZ2h0IHx8IG1lLmhlaWdodDtcblxuICAgICAgICAvLyBOb3QgcG9zc2libGUsIGV2ZW4gd2hlbiBzaHJ1bmsgdG8gbWluaW1hXG4gICAgICAgIGlmIChtaW5IZWlnaHQgPiBjb25zdHJhaW5Uby5oZWlnaHQgfHwgbWluV2lkdGggPiBjb25zdHJhaW5Uby53aWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2UgZG8gbm90IG11dGF0ZSB0aGlzIFJlY3RhbmdsZSwgYnV0IHJldHVybiBhIGNvbnN0cmFpbmVkIHZlcnNpb25cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbWUuY2xvbmUoKTtcblxuICAgICAgICAvLyBUcmFuc2xhdGUgcmVzdWx0IHNvIHRoYXQgdGhlIHRvcCBhbmQgbGVmdCBhcmUgdmlzaWJsZVxuICAgICAgICByZXN1bHQueCA9IE1hdGgubWF4KG1lLnggKyBNYXRoLm1pbihjb25zdHJhaW5Uby5yaWdodCAgLSByZXN1bHQucmlnaHQsICAwKSwgY29uc3RyYWluVG8ueCk7XG4gICAgICAgIHJlc3VsdC55ID0gTWF0aC5tYXgobWUueSArIE1hdGgubWluKGNvbnN0cmFpblRvLmJvdHRvbSAtIHJlc3VsdC5ib3R0b20sIDApLCBjb25zdHJhaW5Uby55KTtcblxuICAgICAgICAvLyBQdWxsIGluIGFueSByZXN1bHRpbmcgb3ZlcmZsb3dcbiAgICAgICAgcmVzdWx0LmJvdHRvbSA9IE1hdGgubWluKHJlc3VsdC5ib3R0b20sIGNvbnN0cmFpblRvLmJvdHRvbSk7XG4gICAgICAgIHJlc3VsdC5yaWdodCA9IE1hdGgubWluKHJlc3VsdC5yaWdodCwgY29uc3RyYWluVG8ucmlnaHQpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYWxpZ25UbyhhbGlnbikge1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAgbWUgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0cmFpblRvLCAgICAvLyBFbGVtZW50IG9yIFJlY3RhbmdsZSByZXN1bHQgbXVzdCBmaXQgaW50b1xuICAgICAgICAgICAgICAgIHRhcmdldCwgICAgICAgICAvLyBFbGVtZW50IG9yIFJlY3RhbmdsZSB0byBhbGlnbiB0b1xuICAgICAgICAgICAgICAgIGVkZ2VBbGlnbiwgICAgICAvLyB0NTAtYjUwIHR5cGUgc3RyaW5nXG4gICAgICAgICAgICAgICAgYXhpc0xvY2ssICAgICAgIC8vIHRydWUgZm9yIGZsaXAsICdmbGV4aWJsZScgZm9yIGZsaXAsIHRoZW4gdHJ5IHRoZSBvdGhlciBlZGdlc1xuICAgICAgICAgICAgICAgIG9mZnNldCwgICAgICAgICAvLyBGaW5hbCBbeCwgeV0gdmVjdG9yIHRvIG1vdmUgdGhlIHJlc3VsdCBieS5cbiAgICAgICAgICAgICAgICBtYXRjaFNpemVcbiAgICAgICAgICAgIH0gICAgICAgICAgICAgID0gYWxpZ24sXG4gICAgICAgICAgICB0YXJnZXRNYXJnaW4gICA9IGFsaWduLnRhcmdldE1hcmdpbiA/IHBhcnNlRWRnZVZhbHVlKGFsaWduLnRhcmdldE1hcmdpbikgOiB6ZXJvTWFyZ2lucyxcbiAgICAgICAgICAgIHRhcmdldFJlY3QgICAgID0gZ2V0RWxSZWN0KHRhcmdldCksXG4gICAgICAgICAgICBjb25zdHJhaW5SZWN0ICA9IGdldEVsUmVjdChjb25zdHJhaW5UbyksXG4gICAgICAgICAgICBlZGdlcyAgICAgICAgICA9IHBhcnNlRWRnZUFsaWduKGVkZ2VBbGlnbiksXG4gICAgICAgICAgICBtYXRjaERpbWVuc2lvbiA9IHpvbmVEaW1lbnNpb25bZWRnZXMudGhlaXJFZGdlWm9uZSAmIDFdO1xuXG4gICAgICAgIGxldCByZXN1bHQgPSBtZS5jbG9uZSgpO1xuXG4gICAgICAgIGlmIChtYXRjaFNpemUpIHtcbiAgICAgICAgICAgIHJlc3VsdFttYXRjaERpbWVuc2lvbl0gPSB0YXJnZXRSZWN0W21hdGNoRGltZW5zaW9uXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE11c3QgZG8gdGhlIGNhbGN1bGF0aW9ucyBhZnRlciB0aGUgYWxpZ25lZCBzaWRlIGhhcyBiZWVuIG1hdGNoZWQgaW4gc2l6ZSBpZiByZXF1ZXN0ZWQuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBteVBvaW50ICAgICA9IHJlc3VsdC5nZXRBbmNob3JQb2ludChlZGdlcy5vdXJFZGdlWm9uZSwgZWRnZXMub3VyRWRnZU9mZnNldCwgZWRnZXMub3VyRWRnZVVuaXQpLFxuICAgICAgICAgICAgdGFyZ2V0UG9pbnQgPSB0YXJnZXRSZWN0LmdldEFuY2hvclBvaW50KGVkZ2VzLnRoZWlyRWRnZVpvbmUsIGVkZ2VzLnRoZWlyRWRnZU9mZnNldCwgZWRnZXMudGhlaXJFZGdlVW5pdCwgdGFyZ2V0TWFyZ2luKSxcbiAgICAgICAgICAgIHZlY3RvciAgICAgID0gW3RhcmdldFBvaW50WzBdIC0gbXlQb2ludFswXSwgdGFyZ2V0UG9pbnRbMV0gLSBteVBvaW50WzFdXTtcblxuICAgICAgICByZXN1bHQgPSByZXN1bHQubW92ZUJ5KHZlY3Rvcik7XG5cbiAgICAgICAgLy8gQSB1c2VmdWwgcHJvcGVydHkgaW4gdGhlIHJlc3VsdGluZyByZWN0YW5nbGUgd2hpY2ggc3BlY2lmaWVzIHdoaWNoIHpvbmUgb2YgdGhlIHRhcmdldFxuICAgICAgICAvLyBJdCBpcyBiZWluZyBwbGFjZXMgaW4sIFQsUixCIG9yIEwgLSAwLCAxLCAyLCAzXG4gICAgICAgIC8vIFNvbWUgY29kZSBtYXkgd2FudCB0byB0cmVhdCBET00gZWxlbWVudHMgZGlmZmVyZW50bHkgZGVwZW5kaW5nIG9uIHRoZSB6b25lXG4gICAgICAgIHJlc3VsdC56b25lID0gZWRnZXMudGhlaXJFZGdlWm9uZTtcbiAgICAgICAgcmVzdWx0LnBvc2l0aW9uID0gem9uZU5hbWVzW3Jlc3VsdC56b25lXTtcblxuICAgICAgICAvLyBOb3cgd2UgY3JlYXRlIHRoZSBmb3VyIFJlY3RhbmdsZXMgYXJvdW5kIHRoZSB0YXJnZXQsIGludG8gd2hpY2ggd2UgbWF5IGJlIGNvbnN0cmFpbmVkXG4gICAgICAgIC8vIFpvbmVzIFQsUixCLEwgMCA5LCAxLCAyLCAzOlxuICAgICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgIC8vIHwgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rIHxcbiAgICAgICAgLy8gfCB8ICAgICAgICAgIF4gICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgIF4gICAgICAgICAgICAgIHwgfFxuICAgICAgICAvLyB8IHwgICAgICAgICAgfCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCB8XG4gICAgICAgIC8vIHwgfCAgPC0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tWm9uZSAwLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLT4gICB8IHxcbiAgICAgICAgLy8gfCB8ICAgICAgICAgIHwgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHwgfFxuICAgICAgICAvLyB8IHwgICAgICAgICAgfCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCB8XG4gICAgICAgIC8vIHwgKy0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rIHxcbiAgICAgICAgLy8gfCB8ICAgICAgICAgIHwgICAgICAgICAgICAgIHwgKy0tLS0tLS0tLS0tLS0tLS0tLS0tKyB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHwgfFxuICAgICAgICAvLyB8IHwgICAgICAgICAgfCAgICAgICAgICAgICAgfCB8ICAgICAgICAgICAgICAgICAgICB8IHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCB8XG4gICAgICAgIC8vIHwgfCAgICAgICAgICB8ICAgICAgICAgICAgICB8IHwgICAgICAgICAgICAgICAgICAgIHwgfCAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8IHxcbiAgICAgICAgLy8gfCB8ICAgICAgIFpvbmUgMyAgICAgICAgICAgIHwgfCAgICAgICAgICAgICAgICAgICAgfCB8ICAgICAgICAgIFpvbmUgMSAgICAgICAgICAgIHwgfFxuICAgICAgICAvLyB8IHwgICAgICAgICAgfCAgICAgICAgICAgICAgfCB8ICAgICAgICAgICAgICAgICAgICB8IHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCB8XG4gICAgICAgIC8vIHwgfCAgICAgICAgICB8ICAgICAgICAgICAgICB8IHwgICAgICAgICAgICAgICAgICAgIHwgfCAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8IHxcbiAgICAgICAgLy8gfCB8ICAgICAgICAgIHwgICAgICAgICAgICAgIHwgKy0tLS0tLS0tLS0tLS0tLS0tLS0tKyB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHwgfFxuICAgICAgICAvLyB8ICsrLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tKyB8XG4gICAgICAgIC8vIHwgfCAgICAgICAgICB8ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8IHxcbiAgICAgICAgLy8gfCB8ICAgICAgICAgIHwgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHwgfFxuICAgICAgICAvLyB8IHwgICAgICAgICAgfCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCB8XG4gICAgICAgIC8vIHwgfCAgPC0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS1ab25lIDItLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tPiB8IHxcbiAgICAgICAgLy8gfCB8ICAgICAgICAgIHwgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHwgfFxuICAgICAgICAvLyB8IHwgICAgICAgICAgdiAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgdiAgICAgICAgICAgICAgfCB8XG4gICAgICAgIC8vIHwgKystLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rIHxcbiAgICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICBpZiAoY29uc3RyYWluUmVjdCAmJiAhY29uc3RyYWluUmVjdC5jb250YWlucyhyZXN1bHQpKSB7XG4gICAgICAgICAgICAvLyBUaGV5IGFza2VkIHRvIG92ZXJsYXAgdGhlIHRhcmdldCwgZm9yIGV4YW1wbGUgdDAtdDBcbiAgICAgICAgICAgIC8vIEluIHRoZXNlIGNhc2VzLCB3ZSBqdXN0IHJldHVybiB0aGUgcmVzdWx0XG4gICAgICAgICAgICBpZiAodGFyZ2V0UmVjdC5pbnRlcnNlY3RzKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSB6b25lIHdlIHRyeSB0byBmaXQgaW50byBmaXJzdCwgdGhlIG9uZSB0aGF0IHdhcyBhc2tlZCBmb3JcbiAgICAgICAgICAgIGxldCB6b25lID0gZWRnZXMudGhlaXJFZGdlWm9uZTtcblxuICAgICAgICAgICAgLy8gV2UgY3JlYXRlIGFuIGFycmF5IG9mIGZvdXIgcmVjdGFuZ2xlcyBpbnRvIHdoaWNoIHdlIHRyeSB0byBmaXQgd2l0aCBhcHByb3ByaWF0ZSBhbGlnbiBzcGVjcy5cbiAgICAgICAgICAgIC8vIFdlIG11c3Qgc3RhcnQgd2l0aCB0aGUgcmVxdWVzdGVkIHpvbmUsIHdoYXRldmVyIHRoYXQgaXMuXG4gICAgICAgICAgICBjb25zdCB6b25lc1RvVHJ5ID0gW3tcbiAgICAgICAgICAgICAgICB6b25lLFxuICAgICAgICAgICAgICAgIGVkZ2VBbGlnblxuICAgICAgICAgICAgfV07XG5cbiAgICAgICAgICAgIGlmIChheGlzTG9jaykge1xuICAgICAgICAgICAgICAgIC8vIEZsaXAgdG8gdGhlIG9wcG9zaXRlIHNpZGUgZm9yIHRoZSBzZWNvbmQgdHJ5LlxuICAgICAgICAgICAgICAgIC8vIFRoZSBhbGlnbm1lbnQgc3RyaW5nIGhhcyB0byBiZSByZXZlcnNlZFxuICAgICAgICAgICAgICAgIC8vIHNvIHIyMC1sMzAgaGFzIHRvIGJlY29tZSBsMjAtcjMwLlxuICAgICAgICAgICAgICAgIC8vIFRoZSBvdGhlciB0d28gem9uZXMgcmV2ZXJ0IHRvIGNlbnRlcmVkIHNvIGFyZSBlYXNpZXJcbiAgICAgICAgICAgICAgICB6b25lc1RvVHJ5WzFdID0ge1xuICAgICAgICAgICAgICAgICAgICB6b25lICAgICAgOiB6b25lID0gKHpvbmUgKyAyKSAlIDQsXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VBbGlnbiA6IGNyZWF0ZVJldmVyc2VkRWRnZUFsaWduKGVkZ2VzKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEZhbGwgYmFjayB0byB0aGUgb3RoZXIgdHdvIHpvbmVzLlxuICAgICAgICAgICAgICAgIHpvbmVzVG9UcnkucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHpvbmUgICAgICA6IHpvbmUgPSAoZWRnZXMudGhlaXJFZGdlWm9uZSArIDEpICUgNCxcbiAgICAgICAgICAgICAgICAgICAgZWRnZUFsaWduIDogYCR7b3Bwb3NpdGVFZGdlW3pvbmVFZGdlc1t6b25lXV19LSR7em9uZUVkZ2VzW3pvbmVdfWBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB6b25lc1RvVHJ5LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB6b25lICAgICAgOiB6b25lID0gKGVkZ2VzLnRoZWlyRWRnZVpvbmUgKyAzKSAlIDQsXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VBbGlnbiA6IGAke29wcG9zaXRlRWRnZVt6b25lRWRnZXNbem9uZV1dfS0ke3pvbmVFZGdlc1t6b25lXX1gXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBnbyB0aHJvdWdoIHRoZSBvdGhlciB6b25lcyBpbiBvcmRlclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHpvbmVzVG9UcnkucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB6b25lICAgICAgOiB6b25lID0gKHpvbmUgKyAxKSAlIDQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGdlQWxpZ24gOiBgJHtvcHBvc2l0ZUVkZ2Vbem9uZUVkZ2VzW3pvbmVdXX0tJHt6b25lRWRnZXNbem9uZV19YFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgY29uc3RyYWludCBSZWN0YW5nbGUgZm9yIGVhY2ggem9uZVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB6b25lc1RvVHJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgY2xvbmUgdGhlIG91dGVyIGNvbnN0cmFpbmluZyByZWN0YW5nbGVcbiAgICAgICAgICAgICAgICAvLyBhbmQgbW92ZSBpdCBpbnRvIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IGNvbnN0cmFpblJlY3QuY2xvbmUoKTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoem9uZXNUb1RyeVtpXS56b25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB6b25lIGkyIGFib3ZlIHRoZSB0YXJnZXQgLSB6b25lIDAvVFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5ib3R0b20gPSB0YXJnZXRSZWN0LnkgLSB0YXJnZXRNYXJnaW5bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHpvbmUgaXMgdG8gdGhlIHJpZ2h0IG9mIHRoZSB0YXJnZXQgLSB6b25lIDEvUlxuICAgICAgICAgICAgICAgICAgICAgICAgYy5jaGFuZ2VYKHRhcmdldFJlY3QucmlnaHQgKyB0YXJnZXRNYXJnaW5bMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB6b25lIGlzIGJlbG93IHRoZSB0YXJnZXQgLSB6b25lIDIvQlxuICAgICAgICAgICAgICAgICAgICAgICAgYy5jaGFuZ2VZKHRhcmdldFJlY3QuYm90dG9tICsgdGFyZ2V0TWFyZ2luWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgem9uZSBpcyB0byB0aGUgbGVmdCBvZiB0aGUgdGFyZ2V0IC0gem9uZSAzL0xcbiAgICAgICAgICAgICAgICAgICAgICAgIGMucmlnaHQgPSB0YXJnZXRSZWN0LnggLSB0YXJnZXRNYXJnaW5bM107XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgem9uZXNUb1RyeVtpXS5jb25zdHJhaW5SZWN0ID0gYztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTm93IHRyeSB0byBjb25zdHJhaW4gb3VyIHJlc3VsdCBpbnRvIGVhY2ggem9uZSdzIGNvbnN0cmFpbnRab25lXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHpvbmVzVG9UcnkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB6b25lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWRnZUFsaWduLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWluUmVjdFxuICAgICAgICAgICAgICAgICAgICB9ICAgID0gem9uZXNUb1RyeVtpXSxcbiAgICAgICAgICAgICAgICAgICAgZWRnZSA9IHpvbmVFZGdlc1t6b25lXTtcblxuICAgICAgICAgICAgICAgIGlmIChtYXRjaFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGFsaWduaW5nIHRvIHRoZSByZXF1ZXN0ZWQgZWRnZSwgb3IgaXQncyBvcHBvc2l0ZSBlZGdlIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2ggdGhhdCBlZGdlIHNpemUsIGVsc2UgcmV2ZXJ0IGl0IHRvIG91ciBvd24gc2l6ZVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbbWF0Y2hEaW1lbnNpb25dID0gZWRnZSA9PT0gZWRnZXMudGhlaXJFZGdlIHx8IGVkZ2UgPT0gb3Bwb3NpdGVFZGdlW2VkZ2VzLnRoZWlyRWRnZV0gPyB0YXJnZXRSZWN0W21hdGNoRGltZW5zaW9uXSA6IG1lW21hdGNoRGltZW5zaW9uXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBEbyBhIHNpbXBsZSBhbGlnbiB0byB0aGUgY3VycmVudCBlZGdlXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmFsaWduVG8oe1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgOiB0YXJnZXRSZWN0LFxuICAgICAgICAgICAgICAgICAgICBlZGdlQWxpZ24sXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldE1hcmdpblxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgbGV0IHNvbHV0aW9uID0gcmVzdWx0LmNvbnN0cmFpblRvKGNvbnN0cmFpblJlY3QpO1xuXG4gICAgICAgICAgICAgICAgLy8gQXMgc29vbiBhcyB3ZSBmaW5kIGEgem9uZSBpbnRvIHdoaWNoIHRoZSByZXN1bHQgaXMgd2lsbGluZyB0byBiZSBjb25zdHJhaW5lZC4gcmV0dXJuIGl0XG4gICAgICAgICAgICAgICAgaWYgKHNvbHV0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvbHV0aW9uLnpvbmUgPSB6b25lO1xuICAgICAgICAgICAgICAgICAgICBzb2x1dGlvbi5wb3NpdGlvbiA9IHpvbmVOYW1lc1t6b25lXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvbHV0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCB0aGUgY29uZmlndXJhYmxlIGZpbmlzaGluZyB0b3VjaC5cbiAgICAgICAgaWYgKG9mZnNldCkge1xuICAgICAgICAgICAgcmVzdWx0Lm1vdmVCeShvZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBnZXRBbmNob3JQb2ludChlZGdlWm9uZSwgZWRnZU9mZnNldCwgZWRnZVVuaXQsIG1hcmdpbiA9IGVtcHR5QXJyYXkpIHtcbiAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuXG4gICAgICAgIGxldCByZXN1bHQ7XG5cbiAgICAgICAgLy8gRWRnZSB6b25lcyBnbyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRcbiAgICAgICAgLy8gRWFjaCBvbmUgY2FsY3VsYXRlcyB0aGUgc3RhcnQgcG9pbnQgb2YgdGhhdCBlZGdlIHRoZW4gbW92ZXMgYWxvbmcgaXQgYnlcbiAgICAgICAgLy8gdGhlIGVkZ2VPZmZzZXQsIHRoZW4gbW92ZXMgKmF3YXkqIGZyb20gaXQgYnkgdGhlIG1hcmdpbiBmb3IgdGhhdCBlZGdlIGlmIHRoZXJlJ3MgYSBtYXJnaW4uXG4gICAgICAgIHN3aXRjaCAoZWRnZVpvbmUpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbbWUueCwgbWUueSAtIChtYXJnaW5bMF0gfHwgMCksIG1lLndpZHRoLCAwXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbbWUueCArIG1lLndpZHRoICsgKG1hcmdpblsxXSB8fCAwKSwgbWUueSwgbWUuaGVpZ2h0LCAxXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbbWUueCwgbWUueSArIG1lLmhlaWdodCArIChtYXJnaW5bMl0gfHwgMCksIG1lLndpZHRoLCAwXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbbWUueCAtIChtYXJnaW5bM10gfHwgMCksIG1lLnksIG1lLmhlaWdodCwgMV07XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W3Jlc3VsdFszXV0gKz0gZWRnZVVuaXQgPT09ICclJyA/IHJlc3VsdFsyXSAvIDEwMCAqIGVkZ2VPZmZzZXQgOiBlZGdlT2Zmc2V0O1xuICAgICAgICByZXN1bHQubGVuZ3RoID0gMjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgRE9NUmVjdCAmJlxuICAgICAgICAgICAgb3RoZXIueCA9PT0gdGhpcy54ICYmXG4gICAgICAgICAgICBvdGhlci55ID09PSB0aGlzLnkgJiZcbiAgICAgICAgICAgIG90aGVyLmhlaWdodCA9PT0gdGhpcy5oZWlnaHQgJiZcbiAgICAgICAgICAgIG90aGVyLndpZHRoID09PSB0aGlzLndpZHRoO1xuICAgIH1cblxuICAgIC8vIEZvciBkZWJ1Z2dpbmcgcHVycG9zZXMgb25seVxuICAgIHNob3coY29sb3IgPSAncmVkJykge1xuICAgICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgICBkaXYuc3R5bGUgPSBgXG4gICAgICAgICAgICBwb3NpdGlvbjphYnNvbHV0ZTtcbiAgICAgICAgICAgIHRyYW5zZm9ybTp0cmFuc2xhdGUzZCgke3RoaXMueH1weCwgJHt0aGlzLnl9cHgsIDApO1xuICAgICAgICAgICAgaGVpZ2h0OiR7dGhpcy5oZWlnaHR9cHg7XG4gICAgICAgICAgICB3aWR0aDoke3RoaXMud2lkdGh9cHg7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiR7Y29sb3J9XG4gICAgICAgIGA7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBkaXYucmVtb3ZlKCksIDMwMDAwKTtcbiAgICAgICAgcmV0dXJuIGRpdjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHVzaW5nIEpTT04uc3RyaW5naWZ5KHRoaXMpLCB3ZSB3YW50IHRvIGFkZCBtaW5IZWlnaHQgJiBtaW5XaWR0aCB0byB0aGUgb3V0cHV0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCB7Ym90dG9tLCBoZWlnaHQsIGxlZnQsIG1pbkhlaWdodCwgbWluV2lkdGgsIHJpZ2h0LCB0b3AsIHdpZHRoLCB4LCB5fSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7Ym90dG9tLCBoZWlnaHQsIGxlZnQsIG1pbkhlaWdodCwgbWluV2lkdGgsIHJpZ2h0LCB0b3AsIHdpZHRoLCB4LCB5fVxuICAgIH1cbn1cbiIsImltcG9ydCBCYXNlIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8udXRpbC5TdHJpbmdcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgU3RyaW5nVXRpbCBleHRlbmRzIEJhc2Uge1xuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gY2hhckVudGl0eU1hcFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgY2hhckVudGl0eU1hcCA9IHtcbiAgICAgICAgJyYnIDogJyZhbXA7JyxcbiAgICAgICAgJzwnIDogJyZsdDsnLFxuICAgICAgICAnPicgOiAnJmd0OycsXG4gICAgICAgICdcIicgOiAnJnF1b3Q7JyxcbiAgICAgICAgJ1xcJyc6ICcmYXBvczsnLFxuICAgICAgICAnJCcgOiAnJmRvbGxhcjsnLFxuICAgICAgICAnXFxcXCc6ICcmYnNvbDsnLFxuICAgICAgICAnLycgOiAnJnNvbDsnXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge1JlZ0V4cH0gY2hhclBhdHRlcm5cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGNoYXJQYXR0ZXJuID0gL1smPD5cIickXFxcXF0vZ1xuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge1JlZ0V4cH0gZW50aXR5UGF0dGVyblxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgZW50aXR5UGF0dGVybiA9IC8oJmFtcDspfCgmbHQ7KXwoJmd0Oyl8KCZxdW90Oyl8KCZhcG9zOyl8KCZkb2xsYXI7KXwoJmJzb2w7KXwoJnNvbDspL2dcblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnV0aWwuU3RyaW5nJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8udXRpbC5TdHJpbmcnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXNjYXBlIEhUTUwgc3BlY2lhbCBjaGFyYWN0ZXJzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICovXG4gICAgc3RhdGljIGVzY2FwZUh0bWwodmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpczsgLy8gaW5zaWRlIGEgc3RhdGljIG1ldGhvZCwgd2UgYXJlIHBvaW50aW5nIHRvIHRoZSBjbGFzcyBwcm90b3R5cGVcblxuICAgICAgICBpZiAoIU5lby5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UobWUuY2hhclBhdHRlcm4sIG1lLmdldEVudGl0eUZyb21DaGFyLmJpbmQobWUpKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBjaGFyIGVxdWl2YWxlbnQgb2YgYSBtYXBwZWQgZW50aXR5XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGVudGl0eVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRDaGFyRnJvbUVudGl0eShlbnRpdHkpIHtcbiAgICAgICAgbGV0IG1hcHBlZENoYXIgPSBPYmplY3Qua2V5cyh0aGlzLmNoYXJFbnRpdHlNYXApLmZpbmQoa2V5ID0+IHRoaXMuY2hhckVudGl0eU1hcFtrZXldID09PSBlbnRpdHkpO1xuICAgICAgICByZXR1cm4gbWFwcGVkQ2hhciB8fCBlbnRpdHlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZW50aXR5IGVxdWl2YWxlbnQgb2YgYSBtYXBwZWQgY2hhclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjaGFyXG4gICAgICovXG4gICAgc3RhdGljIGdldEVudGl0eUZyb21DaGFyKGNoYXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhckVudGl0eU1hcFtjaGFyXSB8fCBjaGFyXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5lc2NhcGUgSFRNTCBzcGVjaWFsIGNoYXJhY3RlcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cbiAgICBzdGF0aWMgdW5lc2NhcGVIdG1sKHZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7IC8vIGluc2lkZSBhIHN0YXRpYyBtZXRob2QsIHdlIGFyZSBwb2ludGluZyB0byB0aGUgY2xhc3MgcHJvdG90eXBlXG5cbiAgICAgICAgaWYgKCFOZW8uaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKG1lLmVudGl0eVBhdHRlcm4sIG1lLmdldENoYXJGcm9tRW50aXR5LmJpbmQobWUpKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBhc3NlZCBzdHJpbmcgd2l0aCB0aGUgZmlyc3QgbGV0dGVyIHVuY2FwaXRhbGl6ZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHJldHVybnMgIHtTdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIHVuY2FwaXRhbGl6ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWVbMF0udG9Mb3dlckNhc2UoKSArIHZhbHVlLnN1YnN0cmluZygxKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoU3RyaW5nVXRpbCk7XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnV0aWwuU3R5bGVcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgU3R5bGUgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby51dGlsLlN0eWxlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8udXRpbC5TdHlsZSdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGRlbHRhIG9iamVjdCwgY29udGFpbmluZyB0aGUgc3R5bGVzIG9mIG5ld1N0eWxlIHdoaWNoIGFyZSBub3QgaW5jbHVkZWQgb3IgZGlmZmVyZW50IHRoYW4gaW4gb2xkU3R5bGVcbiAgICAgKiBTdHlsZXMgaW5jbHVkZWQgaW4gb2xkU3R5bGUgYnV0IG1pc3NpbmcgaW4gbmV3U3R5bGUgd2lsbCBnZXQgYSB2YWx1ZSBvZiBudWxsXG4gICAgICogc2VlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTEVsZW1lbnQvc3R5bGVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IG5ld1N0eWxlXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBvbGRTdHlsZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHN0eWxlIGRlbHRhXG4gICAgICovXG4gICAgc3RhdGljIGNvbXBhcmVTdHlsZXMobmV3U3R5bGUsIG9sZFN0eWxlKSB7XG4gICAgICAgIGxldCBzdHlsZXMgPSB7fTtcblxuICAgICAgICBpZiAoTmVvLmlzU3RyaW5nKG5ld1N0eWxlKSkge1xuICAgICAgICAgICAgbmV3U3R5bGUgPSBOZW8uY3JlYXRlU3R5bGVPYmplY3QobmV3U3R5bGUpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoTmVvLmlzU3RyaW5nKG9sZFN0eWxlKSkge1xuICAgICAgICAgICAgb2xkU3R5bGUgPSBOZW8uY3JlYXRlU3R5bGVPYmplY3Qob2xkU3R5bGUpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW5ld1N0eWxlICYmICFvbGRTdHlsZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfSBlbHNlIGlmICghb2xkU3R5bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBOZW8uY2xvbmUobmV3U3R5bGUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdTdHlsZSAmJiBPYmplY3Qua2V5cyhuZXdTdHlsZSkuZm9yRWFjaChzdHlsZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFvbGRTdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZSkgfHwgb2xkU3R5bGVbc3R5bGVdICE9PSBuZXdTdHlsZVtzdHlsZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzW3N0eWxlXSA9IG5ld1N0eWxlW3N0eWxlXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhvbGRTdHlsZSkuZm9yRWFjaChzdHlsZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFuZXdTdHlsZSAgfHwgIW5ld1N0eWxlLmhhc093blByb3BlcnR5KHN0eWxlKSkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZXNbc3R5bGVdID0gbnVsbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoc3R5bGVzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0eWxlc1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhTdHlsZSk7XG4iLCJpbXBvcnQgQmFzZSAgICAgICAgICAgICBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBDb21wb25lbnRNYW5hZ2VyIGZyb20gJy4uL21hbmFnZXIvQ29tcG9uZW50Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby51dGlsLlZEb21cbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgVkRvbSBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnV0aWwuVkRvbSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnV0aWwuVkRvbSdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmRvbVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVtb3ZlSWRzPXRydWVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBjbG9uZWQgdmRvbVxuICAgICAqL1xuICAgIHN0YXRpYyBjbG9uZSh2ZG9tLCByZW1vdmVJZHM9dHJ1ZSkge1xuICAgICAgICBsZXQgY2xvbmUgPSBOZW8uY2xvbmUodmRvbSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKHJlbW92ZUlkcykge1xuICAgICAgICAgICAgZGVsZXRlIGNsb25lLmlkXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2xvbmUuY24pIHtcbiAgICAgICAgICAgIGNsb25lLmNuLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY2xvbmUuY25baW5kZXhdID0gVkRvbS5jbG9uZShpdGVtLCByZW1vdmVJZHMpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNsb25lXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VhcmNoIHZkb20gY2hpbGQgbm9kZXMgYnkgaWQgb3Igb3B0cyBvYmplY3QgZm9yIGEgZ2l2ZW4gdmRvbSB0cmVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZkb21cbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IG9wdHMgRWl0aGVyIGFuIG9iamVjdCBjb250YWluaW5nIHZkb20gbm9kZSBhdHRyaWJ1dGVzIG9yIGEgc3RyaW5nIGJhc2VkIGlkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSByZXBsYWNlQ29tcG9uZW50UmVmcz10cnVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtpbmRleF0gSW50ZXJuYWwgZmxhZywgZG8gbm90IHVzZSBpdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyZW50Tm9kZV0gSW50ZXJuYWwgZmxhZywgZG8gbm90IHVzZSBpdFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogICAgIHtOdW1iZXJ9IGluZGV4XG4gICAgICogICAgIHtTdHJpbmd9IHBhcmVudElkXG4gICAgICogICAgIHtPYmplY3R9IHZkb21cbiAgICAgKi9cbiAgICBzdGF0aWMgZmluZCh2ZG9tLCBvcHRzLCByZXBsYWNlQ29tcG9uZW50UmVmcz10cnVlLCBpbmRleCwgcGFyZW50Tm9kZSkge1xuICAgICAgICBpbmRleCA9IGluZGV4IHx8IDA7XG4gICAgICAgIG9wdHMgID0gIU5lby5pc1N0cmluZyhvcHRzKSA/IG9wdHMgOiB7aWQ6IG9wdHN9O1xuXG4gICAgICAgIGlmIChyZXBsYWNlQ29tcG9uZW50UmVmcykge1xuICAgICAgICAgICAgdmRvbSA9IFZEb20uZ2V0VmRvbSh2ZG9tKVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNoaWxkICAgICAgPSBudWxsLFxuICAgICAgICAgICAgbWF0Y2hBcnJheSA9IFtdLFxuICAgICAgICAgICAgc3R5bGVNYXRjaCA9IHRydWUsXG4gICAgICAgICAgICBpICAgICAgICAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgICAgICAgPSB2ZG9tLmNuPy5sZW5ndGgsXG4gICAgICAgICAgICBvcHRzQXJyYXkgID0gT2JqZWN0LmVudHJpZXMob3B0cyksXG4gICAgICAgICAgICBvcHRzTGVuZ3RoID0gb3B0c0FycmF5Lmxlbmd0aCxcbiAgICAgICAgICAgIHN1YkNoaWxkO1xuXG4gICAgICAgIG9wdHNBcnJheS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmICh2ZG9tLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjbHMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgTmVvLmlzQXJyYXkodmRvbVtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ZG9tW2tleV0uaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoQXJyYXkucHVzaCh0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmRvbVtrZXldID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ZG9tW2tleV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoQXJyYXkucHVzaCh0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoTmVvLmlzQXJyYXkodmFsdWUpICYmIE5lby5pc0FycmF5KHZkb21ba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0b2RvOiBlaXRoZXIgc2VhcmNoIHRoZSB2ZG9tIGFycmF5IGZvciBhbGwga2V5cyBvciBjb21wYXJlIGlmIHRoZSBhcnJheXMgYXJlIGVxdWFsLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmluZDogY2xzIG1hdGNoaW5nIG5vdCBzdXBwb3J0ZWQgZm9yIHRhcmdldCAmIHNvdXJjZSB0eXBlcyBvZiBBcnJheXMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3R5bGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHZkb21ba2V5XSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmRvbVtrZXldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEFycmF5LnB1c2godHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKE5lby5pc09iamVjdCh2YWx1ZSkgJiYgTmVvLmlzT2JqZWN0KHZkb21ba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZW50cmllcyh2YWx1ZSkuZm9yRWFjaCgoW3N0eWxlS2V5LCBzdHlsZVZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh2ZG9tW2tleV0uaGFzT3duUHJvcGVydHkoc3R5bGVLZXkpICYmIHZkb21ba2V5XVtzdHlsZUtleV0gPT09IHN0eWxlVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZU1hdGNoID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hBcnJheS5wdXNoKHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpbmQ6IHN0eWxlIG1hdGNoaW5nIG5vdCBzdXBwb3J0ZWQgZm9yIG1peGVkIHRhcmdldCAmIHNvdXJjZSB0eXBlcyAoT2JqZWN0IFZTIFN0cmluZyknKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ZG9tW2tleV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hBcnJheS5wdXNoKHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG1hdGNoQXJyYXkubGVuZ3RoID09PSBvcHRzTGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4ge2luZGV4LCBwYXJlbnROb2RlLCB2ZG9tfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZkb20uY24pIHtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodmRvbS5jbltpXSkge1xuICAgICAgICAgICAgICAgICAgICBzdWJDaGlsZCA9IFZEb20uZmluZCh2ZG9tLmNuW2ldLCBvcHRzLCByZXBsYWNlQ29tcG9uZW50UmVmcywgaSwgdmRvbSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YkNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCAgICAgOiBzdWJDaGlsZC5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlOiBzdWJDaGlsZC5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZkb20gICAgICA6IHN1YkNoaWxkLnZkb21cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXQgZm9yIGZpbmQodmRvbSwge2ZsYWc6IGZsYWd9KTtcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmRvbVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmbGFnIFRoZSBmbGFnIHJlZmVyZW5jZSBzcGVjaWZpZWQgb24gdGhlIHRhcmdldCB2ZG9tIGNoaWxkIG5vZGVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB2ZG9tXG4gICAgICovXG4gICAgc3RhdGljIGdldEJ5RmxhZyh2ZG9tLCBmbGFnKSB7XG4gICAgICAgIHJldHVybiBWRG9tLmZpbmQodmRvbSwge2ZsYWd9KT8udmRvbVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmRzIGEgY2hpbGQgdmRvbSBub2RlIGluc2lkZSBhIHZkb20gdHJlZSBieSBhIGdpdmVuIGlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZkb21cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBpZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH0gY2hpbGQgdmRvbSBub2RlIG9yIG51bGxcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0QnlJZCh2ZG9tLCBpZCkge1xuICAgICAgICB2ZG9tID0gVkRvbS5nZXRWZG9tKHZkb20pO1xuXG4gICAgICAgIGlmICghdmRvbSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjaGlsZE5vZGVzID0gdmRvbS5jbiB8fCBbXSxcbiAgICAgICAgICAgIGkgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgbGVuICAgICAgICA9IGNoaWxkTm9kZXMubGVuZ3RoLFxuICAgICAgICAgICAgY2hpbGROb2RlO1xuXG4gICAgICAgIGlmICh2ZG9tLmlkID09PSBpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHZkb21cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNoaWxkTm9kZSA9IFZEb20uZ2V0VmRvbShjaGlsZE5vZGVzW2ldKTtcblxuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGUuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZE5vZGVcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBWRG9tLmdldEJ5SWQoY2hpbGROb2RlLCBpZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZE5vZGVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaWRzIG9mIGFsbCBjaGlsZCBub2RlcyBvZiB0aGUgZ2l2ZW4gdmRvbSB0cmVlXG4gICAgICogQHBhcmFtIHZkb21cbiAgICAgKiBAcGFyYW0gW2NoaWxkSWRzPVtdXVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gY2hpbGRJZHNcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q2hpbGRJZHModmRvbSwgY2hpbGRJZHM9W10pIHtcbiAgICAgICAgdmRvbSA9IFZEb20uZ2V0VmRvbSh2ZG9tKTtcblxuICAgICAgICBsZXQgY2hpbGROb2RlcyA9IHZkb20/LmNuIHx8IFtdO1xuXG4gICAgICAgIGNoaWxkTm9kZXMuZm9yRWFjaChjaGlsZE5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5pZCkge1xuICAgICAgICAgICAgICAgIGNoaWxkSWRzLnB1c2goY2hpbGROb2RlLmlkKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGlsZElkcyA9IFZEb20uZ2V0Q2hpbGRJZHMoY2hpbGROb2RlLCBjaGlsZElkcylcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkSWRzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZkb21cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgc3RhdGljIGdldENvbHVtbk5vZGVzKHZkb20sIGluZGV4KSB7XG4gICAgICAgIHZkb20gPSBWRG9tLmdldFZkb20odmRvbSk7XG5cbiAgICAgICAgbGV0IGNvbHVtbk5vZGVzID0gW107XG5cbiAgICAgICAgdmRvbS5jbj8uZm9yRWFjaChyb3cgPT4ge1xuICAgICAgICAgICAgaWYgKHJvdy5jbj8uW2luZGV4XSkge1xuICAgICAgICAgICAgICAgIGNvbHVtbk5vZGVzLnB1c2gocm93LmNuW2luZGV4XSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICByZXR1cm4gY29sdW1uTm9kZXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmRvbVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q29sdW1uTm9kZXNJZHModmRvbSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIFZEb20uZ2V0Q29sdW1uTm9kZXModmRvbSwgaW5kZXgpLm1hcChlID0+IGUuaWQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZkb21cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmxhZ1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IFttYXRjaEFycmF5XVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gYW4gYXJyYXkgb2YgdmRvbSBub2RlcyB3aGljaCBtYXRjaCB0aGUgZmxhZ1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXRGbGFncyh2ZG9tLCBmbGFnLCBtYXRjaEFycmF5KSB7XG4gICAgICAgIHZkb20gPSBWRG9tLmdldFZkb20odmRvbSk7XG5cbiAgICAgICAgaWYgKCFtYXRjaEFycmF5KSB7XG4gICAgICAgICAgICBtYXRjaEFycmF5ID0gW107XG5cbiAgICAgICAgICAgIGlmICh2ZG9tLmZsYWcgPT09IGZsYWcpIHtcbiAgICAgICAgICAgICAgICBtYXRjaEFycmF5LnB1c2godmRvbSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICh2ZG9tPy5jbiB8fCBbXSkuZm9yRWFjaChjaGlsZE5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5mbGFnID09PSBmbGFnKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hBcnJheS5wdXNoKGNoaWxkTm9kZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWF0Y2hBcnJheSA9IFZEb20uZ2V0RmxhZ3MoY2hpbGROb2RlLCBmbGFnLCBtYXRjaEFycmF5KVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbWF0Y2hBcnJheVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2ZG9tXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB0b3BMZXZlbD10cnVlIEludGVybmFsIGZsYWcsIGRvIG5vdCB1c2UgaXRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgc3RhdGljIGdldFBhcmVudE5vZGVzKHZkb20sIGlkLCB0b3BMZXZlbD10cnVlKSB7XG4gICAgICAgIHZkb20gPSBWRG9tLmdldFZkb20odmRvbSk7XG5cbiAgICAgICAgbGV0IHBhcmVudHMgPSBudWxsLFxuICAgICAgICAgICAgaSAgICAgICA9IDAsXG4gICAgICAgICAgICBsZW4gICAgID0gdmRvbS5jbj8ubGVuZ3RoIHx8IDA7XG5cbiAgICAgICAgaWYgKHZkb20uaWQgPT09IGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gW11cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHBhcmVudHMgPSBWRG9tLmdldFBhcmVudE5vZGVzKHZkb20uY25baV0sIGlkLCBmYWxzZSk7XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnRzKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50cy5wdXNoKHZkb20uY25baV0pO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9wTGV2ZWwgJiYgcGFyZW50cykge1xuICAgICAgICAgICAgcGFyZW50cy5wdXNoKHZkb20pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyZW50c1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIHNob3J0Y3V0IHVzaW5nIG1hbmFnZXIuQ29tcG9uZW50IHRvIHJlcGxhY2UgdmRvbSByZWZlcmVuY2VzIGlmIG5lZWRlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2ZG9tXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0VmRvbSh2ZG9tKSB7XG4gICAgICAgIGlmICh2ZG9tLmNvbXBvbmVudElkKSB7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSBDb21wb25lbnRNYW5hZ2VyLmdldCh2ZG9tLmNvbXBvbmVudElkKTtcblxuICAgICAgICAgICAgaWYgKCFjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHV0aWwuVkRvbS5nZXRWZG9tOiBDb21wb25lbnQgbm90IGZvdW5kIGZvciBpZDogJHt2ZG9tLmNvbXBvbmVudElkfWApXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZkb20gPSBjb21wb25lbnQudmRvbVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZkb21cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnQgYSBnaXZlbiBub2RlVG9JbnNlcnQgYWZ0ZXIgYSB0YXJnZXROb2RlIGluc2lkZSBhIGdpdmVuIHZkb20gdHJlZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2ZG9tIFRoZSB2ZG9tIHRyZWUgY29udGFpbmluZyB0aGUgdGFyZ2V0Tm9kZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlVG9JbnNlcnQgVGhlIG5ldyB2ZG9tIHRvIGluc2VydFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gdGFyZ2V0Tm9kZUlkIEVpdGhlciBhIHZkb20gbm9kZSBvciBhIHZkb20gbm9kZSBpZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpbnNlcnRBZnRlck5vZGUodmRvbSwgbm9kZVRvSW5zZXJ0LCB0YXJnZXROb2RlSWQpIHtcbiAgICAgICAgcmV0dXJuIFZEb20uaW5zZXJ0Tm9kZSh2ZG9tLCBub2RlVG9JbnNlcnQsIHRhcmdldE5vZGVJZCwgZmFsc2UpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGEgZ2l2ZW4gbm9kZVRvSW5zZXJ0IGJlZm9yZSBhIHRhcmdldE5vZGUgaW5zaWRlIGEgZ2l2ZW4gdmRvbSB0cmVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZkb20gVGhlIHZkb20gdHJlZSBjb250YWluaW5nIHRoZSB0YXJnZXROb2RlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGVUb0luc2VydCBUaGUgbmV3IHZkb20gdG8gaW5zZXJ0XG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSB0YXJnZXROb2RlSWQgRWl0aGVyIGEgdmRvbSBub2RlIG9yIGEgdmRvbSBub2RlIGlkXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGluc2VydEJlZm9yZU5vZGUodmRvbSwgbm9kZVRvSW5zZXJ0LCB0YXJnZXROb2RlSWQpIHtcbiAgICAgICAgcmV0dXJuIFZEb20uaW5zZXJ0Tm9kZSh2ZG9tLCBub2RlVG9JbnNlcnQsIHRhcmdldE5vZGVJZCwgdHJ1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnQgYSBnaXZlbiBub2RlVG9JbnNlcnQgYmVmb3JlIGEgdGFyZ2V0Tm9kZSBpbnNpZGUgYSBnaXZlbiB2ZG9tIHRyZWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmRvbSBUaGUgdmRvbSB0cmVlIGNvbnRhaW5pbmcgdGhlIHRhcmdldE5vZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVRvSW5zZXJ0IFRoZSBuZXcgdmRvbSB0byBpbnNlcnRcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHRhcmdldE5vZGVJZCBFaXRoZXIgYSB2ZG9tIG5vZGUgb3IgYSB2ZG9tIG5vZGUgaWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGluc2VydEJlZm9yZSB0cnVlIGluc2VydHMgdGhlIG5ldyBub2RlIGF0IHRoZSBzYW1lIGluZGV4LCBpbmRleCsxIG90aGVyd2lzZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpbnNlcnROb2RlKHZkb20sIG5vZGVUb0luc2VydCwgdGFyZ2V0Tm9kZUlkLCBpbnNlcnRCZWZvcmUpIHtcbiAgICAgICAgaWYgKE5lby5pc09iamVjdCh0YXJnZXROb2RlSWQpKSB7XG4gICAgICAgICAgICB0YXJnZXROb2RlSWQgPSB0YXJnZXROb2RlSWQuaWRcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0YXJnZXROb2RlID0gVkRvbS5maW5kKHZkb20sIHRhcmdldE5vZGVJZCksXG4gICAgICAgICAgICBpbmRleDtcblxuICAgICAgICBpZiAodGFyZ2V0Tm9kZSkge1xuICAgICAgICAgICAgaW5kZXggPSBpbnNlcnRCZWZvcmUgPyB0YXJnZXROb2RlLmluZGV4IDogdGFyZ2V0Tm9kZS5pbmRleCArIDE7XG4gICAgICAgICAgICB0YXJnZXROb2RlLnBhcmVudE5vZGUuY24uc3BsaWNlKGluZGV4LCAwLCBub2RlVG9JbnNlcnQpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlYXJjaCB2ZG9tIGNoaWxkIG5vZGVzIGJ5IGlkIG9yIG9wdHMgb2JqZWN0IGZvciBhIGdpdmVuIHZkb20gdHJlZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbdmRvbV1cbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IG9wdHMgRWl0aGVyIGFuIG9iamVjdCBjb250YWluaW5nIHZkb20gbm9kZSBhdHRyaWJ1dGVzIG9yIGEgc3RyaW5nIGJhc2VkIGlkXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaW4gY2FzZSB0aGUgbm9kZSB3YXMgZm91bmQgJiByZW1vdmVkXG4gICAgICovXG4gICAgc3RhdGljIHJlbW92ZVZkb21DaGlsZCh2ZG9tLCBvcHRzKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IFZEb20uZmluZCh2ZG9tLCBvcHRzKTtcblxuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudE5vZGUuY24uc3BsaWNlKGNoaWxkLmluZGV4LCAxKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBhIGNoaWxkIG5vZGUgaW5zaWRlIGEgdmRvbSB0cmVlIGJ5IGEgZ2l2ZW4gaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmRvbVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdDaGlsZE5vZGVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpbiBjYXNlIHRoZSBub2RlIHdhcyBmb3VuZCBhbmQgcmVwbGFjZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgcmVwbGFjZVZkb21DaGlsZCh2ZG9tLCBpZCwgbmV3Q2hpbGROb2RlKSB7XG4gICAgICAgIHZkb20gPSBWRG9tLmdldFZkb20odmRvbSk7XG5cbiAgICAgICAgbGV0IGNuICA9IHZkb20uY24gfHwgW10sXG4gICAgICAgICAgICBpICAgPSAwLFxuICAgICAgICAgICAgbGVuID0gY24ubGVuZ3RoLFxuICAgICAgICAgICAgY2hpbGROb2RlO1xuXG4gICAgICAgIGlmICh2ZG9tLmlkID09PSBpZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXBsYWNlVmRvbUNoaWxkOiB0YXJnZXQgaWQgbWF0Y2hlcyB0aGUgcm9vdCB2bm9kZSBpZDogJyArIGlkKVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY2hpbGROb2RlID0gY25baV07XG5cbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGUuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgY25baV0gPSBuZXdDaGlsZE5vZGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFZEb20ucmVwbGFjZVZkb21DaGlsZChjaGlsZE5vZGUsIGlkLCBuZXdDaGlsZE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTeW5jaHJvbml6ZXMgc3RhdGUgYmV0d2VlbiB0aGUgbGl2ZSBWRE9NIChibHVlcHJpbnQpIGFuZCB0aGUgaW5jb21pbmcgVk5vZGUgKHdvcmtlciByZXNwb25zZSkuXG4gICAgICpcbiAgICAgKiAxLiAqKklEIFN5bmNocm9uaXphdGlvbiAoVk5vZGUgLT4gVkRPTSk6KipcbiAgICAgKiAgICBgTmVvLnZkb20uSGVscGVyYCBhdXRvbWF0aWNhbGx5IGFzc2lnbnMgZHluYW1pYyBJRHMgdG8gYW55IFZOb2RlIHRoYXQgbGFja3Mgb25lLCBhcyB0aGVcbiAgICAgKiAgICBkZWx0YSB1cGRhdGUgZW5naW5lIHJlcXVpcmVzIHVuaXF1ZSBJRHMgdG8gdGFyZ2V0IERPTSBub2Rlcy4gVGhlc2UgZ2VuZXJhdGVkIElEcyBhcmVcbiAgICAgKiAgICBzeW5jZWQgYmFjayBpbnRvIHRoZSBWRE9NIHRvIGVuc3VyZSBzdGFiaWxpdHkgYW5kIHBlcnNpc3RlbnQgcmVmZXJlbmNpbmcgZm9yIGZ1dHVyZSB1cGRhdGVzLlxuICAgICAqXG4gICAgICogMi4gKipTY3JvbGwgU3RhdGUgU3luY2hyb25pemF0aW9uIChCaWRpcmVjdGlvbmFsKToqKlxuICAgICAqICAgIC0gKipQcmVzZXJ2YXRpb24gKFZET00gLT4gVk5vZGUpOioqIEVuc3VyZXMgdGhhdCB0aGUgbGF0ZXN0IHNjcm9sbCBwb3NpdGlvbiBjYXB0dXJlZCBvbiB0aGVcbiAgICAgKiAgICAgIE1haW4gVGhyZWFkIChzdG9yZWQgaW4gVkRPTSkgb3ZlcnJpZGVzIHBvdGVudGlhbGx5IHN0YWxlIHN0YXRlIHJldHVybmluZyBmcm9tIHRoZSBXb3JrZXIuXG4gICAgICogICAgLSAqKlJlaHlkcmF0aW9uIChWTm9kZSAtPiBWRE9NKToqKiBFbnN1cmVzIHRoYXQgbmV3IFZET00gdHJlZXMgKGUuZy4sIGZyb20gRnVuY3Rpb25hbCBDb21wb25lbnRzKVxuICAgICAqICAgICAgaW5oZXJpdCB0aGUgcGVyc2lzdGVudCBzY3JvbGwgc3RhdGUgZnJvbSB0aGUgZXhpc3RpbmcgVk5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05lby52ZG9tLlZOb2RlfSB2bm9kZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2ZG9tXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBmb3JjZT1mYWxzZSBUaGUgZm9yY2UgcGFyYW0gd2lsbCBlbmZvcmNlIG92ZXJ3cml0aW5nIGRpZmZlcmVudCBpZHNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3luY1Zkb21TdGF0ZSh2bm9kZSwgdmRvbSwgZm9yY2U9ZmFsc2UpIHtcbiAgICAgICAgaWYgKHZub2RlICYmIHZkb20pIHtcbiAgICAgICAgICAgIHZkb20gPSBWRG9tLmdldFZkb20odmRvbSk7XG5cbiAgICAgICAgICAgIGxldCBjaGlsZE5vZGVzID0gdmRvbS5jbixcbiAgICAgICAgICAgICAgICBjbiwgaSwgbGVuO1xuXG4gICAgICAgICAgICAvLyBQcmVzZXJ2YXRpb24gKHZkb20gLT4gdm5vZGUpXG4gICAgICAgICAgICAvLyBVc2VkIGJ5IENsYXNzaWMgQ29tcG9uZW50cyAodmRvbSBpcyBzb3VyY2Ugb2YgdHJ1dGggdmlhIGNhcHR1cmUpXG4gICAgICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKHZkb20uc2Nyb2xsVG9wKSkge1xuICAgICAgICAgICAgICAgIHZub2RlLnNjcm9sbFRvcCA9IHZkb20uc2Nyb2xsVG9wXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKHZkb20uc2Nyb2xsTGVmdCkpIHtcbiAgICAgICAgICAgICAgICB2bm9kZS5zY3JvbGxMZWZ0ID0gdmRvbS5zY3JvbGxMZWZ0XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgY24gID0gY2hpbGROb2Rlcy5tYXAoaXRlbSA9PiBWRG9tLmdldFZkb20oaXRlbSkpO1xuICAgICAgICAgICAgICAgIC8vIFRoZSB2bm9kZS5jaGlsZE5vZGVzIGFycmF5IGlzIGFscmVhZHkgZmlsdGVyZWQgYnkgdGhlIHdvcmtlci5cbiAgICAgICAgICAgICAgICAvLyBXZSBtdXN0IGZpbHRlciB0aGUgY29tcG9uZW50J3MgdmRvbS5jbiBhcnJheSBpZGVudGljYWxseSB0byBlbnN1cmVcbiAgICAgICAgICAgICAgICAvLyBib3RoIGFycmF5cyBhcmUgc3RydWN0dXJhbGx5IGFsaWduZWQgZm9yIHRoZSBzeW5jIGxvb3AuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGJvb2xlYW4gY2hlY2sgYGl0ZW0gJiZgIGlzIGNyaXRpY2FsIHRvIHJlbW92ZSBmYWxzeSB2YWx1ZXNcbiAgICAgICAgICAgICAgICAvLyBmcm9tIGNvbmRpdGlvbmFsIHJlbmRlcmluZyBhbmQgcHJldmVudCBydW50aW1lIGVycm9ycy5cbiAgICAgICAgICAgICAgICBjbiAgPSBjbi5maWx0ZXIoaXRlbSA9PiBpdGVtICYmIGl0ZW0ucmVtb3ZlRG9tICE9PSB0cnVlKTtcbiAgICAgICAgICAgICAgICBpICAgPSAwO1xuICAgICAgICAgICAgICAgIGxlbiA9IGNuPy5sZW5ndGggfHwgMDtcblxuICAgICAgICAgICAgICAgIGlmICh2bm9kZS5jaGlsZE5vZGVzICYmIHZub2RlLmNoaWxkTm9kZXMubGVuZ3RoICE9PSBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodm5vZGUuY2hpbGROb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgVkRvbS5zeW5jVmRvbVN0YXRlKHZub2RlLmNoaWxkTm9kZXNbaV0sIGNuW2ldLCBmb3JjZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVkRvbSk7XG4iLCJpbXBvcnQgQmFzZSAgICAgICAgICAgICBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBDb21wb25lbnRNYW5hZ2VyIGZyb20gJy4uL21hbmFnZXIvQ29tcG9uZW50Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby51dGlsLlZOb2RlXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIFZOb2RlIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8udXRpbC5WTm9kZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnV0aWwuVk5vZGUnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VhcmNoIHZub2RlIGNoaWxkIG5vZGVzIGJ5IGlkIG9yIG9wdHMgb2JqZWN0IGZvciBhIGdpdmVuIHZkb20gdHJlZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2bm9kZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gb3B0cyBFaXRoZXIgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdmRvbSBub2RlIGF0dHJpYnV0ZXMgb3IgYSBzdHJpbmcgYmFzZWQgaWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2luZGV4XSBJbnRlcm5hbCBmbGFnLCBkbyBub3QgdXNlIGl0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJlbnROb2RlXSBJbnRlcm5hbCBmbGFnLCBkbyBub3QgdXNlIGl0XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiAgICAge051bWJlcn0gaW5kZXhcbiAgICAgKiAgICAge1N0cmluZ30gcGFyZW50SWRcbiAgICAgKiAgICAge09iamVjdH0gdm5vZGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZmluZCh2bm9kZSwgb3B0cywgaW5kZXgsIHBhcmVudE5vZGUpIHtcbiAgICAgICAgdm5vZGUgPSBWTm9kZS5nZXRWbm9kZSh2bm9kZSk7XG5cbiAgICAgICAgaW5kZXggPSBpbmRleCB8fCAwO1xuICAgICAgICBvcHRzICA9IHR5cGVvZiBvcHRzICE9PSAnc3RyaW5nJyA/IG9wdHMgOiB7aWQ6IG9wdHN9O1xuXG4gICAgICAgIGxldCBhdHRyTWF0Y2ggID0gdHJ1ZSxcbiAgICAgICAgICAgIG1hdGNoQXJyYXkgPSBbXSxcbiAgICAgICAgICAgIHN0eWxlTWF0Y2ggPSB0cnVlLFxuICAgICAgICAgICAgaSAgICAgICAgICA9IDAsXG4gICAgICAgICAgICBsZW4gICAgICAgID0gdm5vZGUuY2hpbGROb2Rlcz8ubGVuZ3RoIHx8IDAsXG4gICAgICAgICAgICBvcHRzQXJyYXksIG9wdHNMZW5ndGgsIHN1YkNoaWxkO1xuXG4gICAgICAgIG9wdHNBcnJheSAgPSBPYmplY3QuZW50cmllcyhvcHRzKTtcbiAgICAgICAgb3B0c0xlbmd0aCA9IG9wdHNBcnJheS5sZW5ndGg7XG5cbiAgICAgICAgb3B0c0FycmF5LmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZub2RlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdhdHRyaWJ1dGVzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChOZW8uaXNPYmplY3QodmFsdWUpICYmIE5lby5pc09iamVjdCh2bm9kZVtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5mb3JFYWNoKChbYXR0cktleSwgYXR0clZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh2bm9kZVtrZXldLmhhc093blByb3BlcnR5KGF0dHJLZXkpICYmIHZub2RlW2tleV1bYXR0cktleV0gPT09IGF0dHJWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJNYXRjaCA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRyTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hBcnJheS5wdXNoKHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2xhc3NOYW1lJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIE5lby5pc0FycmF5KHZub2RlW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZub2RlW2tleV0uaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoQXJyYXkucHVzaCh0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB0eXBlb2Ygdm5vZGVba2V5XSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodm5vZGVba2V5XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hBcnJheS5wdXNoKHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChOZW8uaXNBcnJheSh2YWx1ZSkgJiYgTmVvLmlzQXJyYXkodm5vZGVba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0b2RvOiBlaXRoZXIgc2VhcmNoIHRoZSB2bm9kZSBhcnJheSBmb3IgYWxsIGtleXMgb3IgY29tcGFyZSBpZiB0aGUgYXJyYXlzIGFyZSBlcXVhbC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpbmQ6IGNscyBtYXRjaGluZyBub3Qgc3VwcG9ydGVkIGZvciB0YXJnZXQgJiBzb3VyY2UgdHlwZXMgb2YgQXJyYXlzJylcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N0eWxlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChOZW8uaXNPYmplY3QodmFsdWUpICYmIE5lby5pc09iamVjdCh2bm9kZVtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5mb3JFYWNoKChbc3R5bGVLZXksIHN0eWxlVmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHZub2RlW2tleV0uaGFzT3duUHJvcGVydHkoc3R5bGVLZXkpICYmIHZub2RlW2tleV1bc3R5bGVLZXldID09PSBzdHlsZVZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVNYXRjaCA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoQXJyYXkucHVzaCh0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodm5vZGVba2V5XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEFycmF5LnB1c2godHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobWF0Y2hBcnJheS5sZW5ndGggPT09IG9wdHNMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB7aW5kZXgsIHBhcmVudE5vZGUsIHZub2RlfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgc3ViQ2hpbGQgPSBWTm9kZS5maW5kKHZub2RlLmNoaWxkTm9kZXNbaV0sIG9wdHMsIGksIHZub2RlKTtcblxuICAgICAgICAgICAgaWYgKHN1YkNoaWxkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YkNoaWxkXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmRzIGEgY2hpbGQgdm5vZGUgaW5zaWRlIGEgdm5vZGUgdHJlZSBieSBhIGdpdmVuIGlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZub2RlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gaWRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9IGNoaWxkIHZub2RlIG9yIG51bGxcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0QnlJZCh2bm9kZSwgaWQpIHtcbiAgICAgICAgdm5vZGUgPSBWTm9kZS5nZXRWbm9kZSh2bm9kZSk7XG5cbiAgICAgICAgaWYgKCF2bm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjaGlsZE5vZGVzID0gdm5vZGUuY2hpbGROb2RlcyB8fCBbXSxcbiAgICAgICAgICAgIGkgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgbGVuICAgICAgICA9IGNoaWxkTm9kZXMubGVuZ3RoLFxuICAgICAgICAgICAgY2hpbGROb2RlO1xuXG4gICAgICAgIGlmICh2bm9kZS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgIHJldHVybiB2bm9kZVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY2hpbGROb2RlID0gVk5vZGUuZ2V0Vm5vZGUoY2hpbGROb2Rlc1tpXSk7XG5cbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlLmlkID09PSBpZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGROb2RlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlID0gVk5vZGUuZ2V0QnlJZChjaGlsZE5vZGUsIGlkKTtcblxuICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkTm9kZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpZHMgb2YgYWxsIGNoaWxkIG5vZGVzIG9mIHRoZSBnaXZlbiB2bm9kZSwgZXhjbHVkaW5nIGNvbXBvbmVudCByZWZlcmVuY2VzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZub2RlXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gY2hpbGRJZHM9W11cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nW119IGNoaWxkSWRzXG4gICAgICovXG4gICAgc3RhdGljIGdldENoaWxkSWRzKHZub2RlLCBjaGlsZElkcz1bXSkge1xuICAgICAgICB2bm9kZT8uY2hpbGROb2Rlcz8uZm9yRWFjaChjaGlsZE5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5pZCAmJiAhY2hpbGROb2RlLmNvbXBvbmVudElkKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRJZHMucHVzaChjaGlsZE5vZGUuaWQpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFZOb2RlLmdldENoaWxkSWRzKGNoaWxkTm9kZSwgY2hpbGRJZHMpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjaGlsZElkc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIHNob3J0Y3V0IHVzaW5nIG1hbmFnZXIuQ29tcG9uZW50IHRvIHJlcGxhY2Ugdm5vZGUgcmVmZXJlbmNlcyBpZiBuZWVkZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdm5vZGVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRWbm9kZSh2bm9kZSkge1xuICAgICAgICBpZiAodm5vZGU/LmNvbXBvbmVudElkKSB7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSBDb21wb25lbnRNYW5hZ2VyLmdldCh2bm9kZS5jb21wb25lbnRJZCk7XG5cbiAgICAgICAgICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1dGlsLlZOb2RlLmdldFZub2RlOiBDb21wb25lbnQgbm90IGZvdW5kIGZvciBpZDogJHt2bm9kZS5jb21wb25lbnRJZH1gKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2bm9kZSA9IGNvbXBvbmVudC52bm9kZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZub2RlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGNoaWxkIHZub2RlIGluc2lkZSBhIHZub2RlIHRyZWUgYnkgYSBnaXZlbiBpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2bm9kZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGluIGNhc2UgdGhlIG5vZGUgd2FzIGZvdW5kIGFuZCByZW1vdmVkXG4gICAgICovXG4gICAgc3RhdGljIHJlbW92ZUNoaWxkVm5vZGUodm5vZGUsIGlkKSB7XG4gICAgICAgIHZub2RlID0gVk5vZGUuZ2V0Vm5vZGUodm5vZGUpO1xuXG4gICAgICAgIGxldCBjaGlsZE5vZGVzID0gdm5vZGUuY2hpbGROb2RlcyB8fCBbXSxcbiAgICAgICAgICAgIGkgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgbGVuICAgICAgICA9IGNoaWxkTm9kZXMubGVuZ3RoLFxuICAgICAgICAgICAgY2hpbGROb2RlO1xuXG4gICAgICAgIGlmICh2bm9kZS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVtb3ZlQ2hpbGRWbm9kZTogdGFyZ2V0IGlkIG1hdGNoZXMgdGhlIHJvb3Qgdm5vZGUgaWQ6ICcgKyBpZClcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNoaWxkTm9kZSA9IFZOb2RlLmdldFZub2RlKGNoaWxkTm9kZXNbaV0pO1xuXG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlLmlkID09PSBpZCkge1xuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChWTm9kZS5yZW1vdmVDaGlsZFZub2RlKGNoaWxkTm9kZSwgaWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIGEgY2hpbGQgdm5vZGUgaW5zaWRlIGEgdm5vZGUgdHJlZSBieSBhIGdpdmVuIGlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZub2RlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5ld0NoaWxkVm5vZGVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpbiBjYXNlIHRoZSBub2RlIHdhcyBmb3VuZCBhbmQgcmVwbGFjZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgcmVwbGFjZUNoaWxkVm5vZGUodm5vZGUsIGlkLCBuZXdDaGlsZFZub2RlKSB7XG4gICAgICAgIHZub2RlID0gVk5vZGUuZ2V0Vm5vZGUodm5vZGUpO1xuXG4gICAgICAgIGxldCBjaGlsZE5vZGVzID0gdm5vZGUuY2hpbGROb2RlcyB8fCBbXSxcbiAgICAgICAgICAgIGkgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgbGVuICAgICAgICA9IGNoaWxkTm9kZXMubGVuZ3RoLFxuICAgICAgICAgICAgY2hpbGROb2RlO1xuXG4gICAgICAgIGlmICh2bm9kZS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVwbGFjZUNoaWxkVm5vZGU6IHRhcmdldCBpZCBtYXRjaGVzIHRoZSByb290IHZub2RlIGlkOiAnICsgaWQpXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjaGlsZE5vZGUgPSBWTm9kZS5nZXRWbm9kZShjaGlsZE5vZGVzW2ldKTtcblxuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVzW2ldID0gbmV3Q2hpbGRWbm9kZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoVk5vZGUucmVwbGFjZUNoaWxkVm5vZGUoY2hpbGROb2RlLCBpZCwgbmV3Q2hpbGRWbm9kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhWTm9kZSk7XG4iLCJpbXBvcnQgQmFzZSAgICAgICAgICAgICBmcm9tICcuLi8uLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBDb21wb25lbnRNYW5hZ2VyIGZyb20gJy4uLy4uL21hbmFnZXIvQ29tcG9uZW50Lm1qcyc7XG5cbi8qKlxuICogQSBzaW5nbGV0b24gdXRpbGl0eSBjbGFzcyByZXNwb25zaWJsZSBmb3IgcmVjdXJzaXZlbHkgYnVpbGRpbmcgVkRPTSBhbmQgVk5vZGUgdHJlZXMuXG4gKiBJdCBjYW4gZXhwYW5kIGNvbXBvbmVudCByZWZlcmVuY2VzIHdpdGhpbiBhIHRyZWUgc3RydWN0dXJlIGludG8gdGhlaXIgZnVsbCBWRE9NL1ZOb2RlIHJlcHJlc2VudGF0aW9ucyxcbiAqIHN1cHBvcnRpbmcgc2VsZWN0aXZlIChhc3ltbWV0cmljKSB0cmVlIGV4cGFuc2lvbiBmb3Igb3B0aW1pemVkIHVwZGF0ZXMuXG4gKiBAY2xhc3MgTmVvLnV0aWwudmRvbS5UcmVlQnVpbGRlclxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICogQHNpbmdsZXRvblxuICovXG5jbGFzcyBUcmVlQnVpbGRlciBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnV0aWwudmRvbS5UcmVlQnVpbGRlcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnV0aWwudmRvbS5UcmVlQnVpbGRlcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaW5nbGV0b249dHJ1ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzaW5nbGV0b246IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcml2YXRlIGhlbHBlciB0byByZWN1cnNpdmVseSBidWlsZCBhIHRyZWUsIGFic3RyYWN0aW5nIHRoZSBjaGlsZCBub2RlIGtleS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSBUaGUgdmRvbSBvciB2bm9kZSB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZXB0aCBUaGUgY3VycmVudCByZWN1cnNpb24gZGVwdGguXG4gICAgICogQHBhcmFtIHtTZXQ8U3RyaW5nPnxudWxsfSBtZXJnZWRDaGlsZElkcyBBIHNldCBvZiBjb21wb25lbnQgSURzIHRvIHNlbGVjdGl2ZWx5IGV4cGFuZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2hpbGRLZXkgVGhlIHByb3BlcnR5IG5hbWUgZm9yIGNoaWxkIG5vZGVzICgnY24nIG9yICdjaGlsZE5vZGVzJykuXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgICNidWlsZFRyZWUobm9kZSwgZGVwdGgsIG1lcmdlZENoaWxkSWRzLCBjaGlsZEtleSkge1xuICAgICAgICAvLyBXZSBjYW4gbm90IHVzZSBOZW8uaXNPYmplY3QoKSBoZXJlLCBzaW5jZSBpbnNpZGUgdW5pdC10ZXN0IHNjZW5hcmlvcywgd2Ugd2lsbCBpbXBvcnQgdmRvbS5IZWxwZXIgaW50byBtYWluIHRocmVhZHMuXG4gICAgICAgIC8vIEluc2lkZSB0aGlzIHNjZW5hcmlvLCBOZW8uaXNPYmplY3QoKSByZXR1cm5zIGZhbHNlIGZvciBWTm9kZSBpbnN0YW5jZXNcbiAgICAgICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCBub2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSklUIElEIEdlbmVyYXRpb24gKEFwcCBBdXRob3JpdHkpXG4gICAgICAgIC8vIElmIHdlIGFyZSBwcm9jZXNzaW5nIGEgVkRPTSB0cmVlIChjaGlsZEtleSA9PT0gJ2NuJykgYW5kIHRoZSBub2RlIGhhcyBubyBJRCxcbiAgICAgICAgLy8gd2UgbXVzdCBnZW5lcmF0ZSBvbmUgbm93IHRvIGVuc3VyZSBkZXRlcm1pbmlzdGljIGlkZW50aXR5IGJlZm9yZSB0aGUgVkRPTSBsZWF2ZXMgdGhlIEFwcCBXb3JrZXIuXG4gICAgICAgIGlmIChjaGlsZEtleSA9PT0gJ2NuJyAmJiAhbm9kZS5pZCkge1xuICAgICAgICAgICAgbm9kZS5pZCA9IE5lby5nZXRJZChub2RlLnZ0eXBlID09PSAndGV4dCcgPyAndnRleHQnIDogJ3Zub2RlJylcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBvdXRwdXQgPSB7Li4ubm9kZX07IC8vIFNoYWxsb3cgY29weVxuXG4gICAgICAgIGlmIChub2RlW2NoaWxkS2V5XSkge1xuICAgICAgICAgICAgb3V0cHV0W2NoaWxkS2V5XSA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbm9kZVtjaGlsZEtleV0ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgaXRlbSAgICAgICAgPSBub2RlW2NoaWxkS2V5XVtpXSxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEl0ZW0gPSBpdGVtLFxuICAgICAgICAgICAgICAgICAgICBjaGlsZERlcHRoO1xuXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRJdGVtLmNvbXBvbmVudElkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IENvbXBvbmVudE1hbmFnZXIuZ2V0KGN1cnJlbnRJdGVtLmNvbXBvbmVudElkKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTcGFyc2UgVHJlZSBHZW5lcmF0aW9uICYgU2NvcGVkIFVwZGF0ZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgcHJ1bmUgdGhlIGJyYW5jaCAoc2VuZCBhIHBsYWNlaG9sZGVyKSBpZjpcbiAgICAgICAgICAgICAgICAgICAgLy8gMS4gV2UgYXJlIGF0IHRoZSBkZXB0aCBib3VuZGFyeSAoZGVwdGggPT09IDEpIEFORCBpdCdzIG5vdCBhIG1lcmdlZCB1cGRhdGUuXG4gICAgICAgICAgICAgICAgICAgIC8vIDIuIFdlIGFyZSBpbiBhIE1lcmdlZCBVcGRhdGUgKG1lcmdlZENoaWxkSWRzIGV4aXN0cykgQU5EIHRoaXMgY29tcG9uZW50IGlzIG5vdCBpbiB0aGUgQWxsb3dMaXN0IChub3QgZGlydHkvYnJpZGdlKS5cbiAgICAgICAgICAgICAgICAgICAgLy8gRXhjZXB0aW9uOiBXZSBuZXZlciBwcnVuZSBpZiBkZXB0aCBpcyAtMSAoRnVsbCBUcmVlKSBvciBpZiB0aGUgY29tcG9uZW50IGlzIG5vdCBtb3VudGVkIHlldC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlcHRoICE9PSAtMSAmJiBjb21wb25lbnQ/LnZub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0V4cGFuZGFibGUgPSBtZXJnZWRDaGlsZElkcz8uaGFzKGN1cnJlbnRJdGVtLmNvbXBvbmVudElkKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChkZXB0aCA9PT0gMSAmJiAhaXNFeHBhbmRhYmxlKSB8fCAobWVyZ2VkQ2hpbGRJZHMgJiYgIWlzRXhwYW5kYWJsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbY2hpbGRLZXldLnB1c2goey4uLmN1cnJlbnRJdGVtLCBuZW9JZ25vcmU6IHRydWV9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSAvLyBTdG9wIHByb2Nlc3NpbmcgdGhpcyBicmFuY2gsIG1vdmUgdG8gbmV4dCBpdGVtXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBFeHBhbmQgdGhlIGJyYW5jaCBpZiBpdCdzIHBhcnQgb2YgYSBtZXJnZWQgdXBkYXRlLCBvciBpZiB0aGUgZGVwdGggcmVxdWlyZXMgaXQsIE9SIGlmIHRoZSB2bm9kZSBpcyBtaXNzaW5nXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aCA+IDEgfHwgZGVwdGggPT09IC0xIHx8IG1lcmdlZENoaWxkSWRzPy5oYXMoY3VycmVudEl0ZW0uY29tcG9uZW50SWQpIHx8ICFjb21wb25lbnQ/LnZub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGNvcnJlY3QgdHJlZSB0eXBlIGJhc2VkIG9uIHRoZSBjaGlsZEtleVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tcG9uZW50VHJlZSA9IGNoaWxkS2V5ID09PSAnY24nID8gY29tcG9uZW50Py52ZG9tIDogY29tcG9uZW50Py52bm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnRUcmVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEl0ZW0gPSBjb21wb25lbnRUcmVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5jb21wb25lbnRJZCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZERlcHRoID0gKGRlcHRoID09PSAtMSkgPyAtMSA6IE1hdGgubWF4KDAsIGRlcHRoIC0gMSlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZERlcHRoID0gZGVwdGhcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvdXRwdXRbY2hpbGRLZXldLnB1c2godGhpcy4jYnVpbGRUcmVlKGN1cnJlbnRJdGVtLCBjaGlsZERlcHRoLCBtZXJnZWRDaGlsZElkcywgY2hpbGRLZXkpKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIGEgZ2l2ZW4gdmRvbSB0cmVlIGFuZCByZXBsYWNlcyBjaGlsZCBjb21wb25lbnQgcmVmZXJlbmNlcyB3aXRoIHRoZWlyIHZkb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZkb21cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2RlcHRoPS0xXVxuICAgICAqIEBwYXJhbSB7U2V0PFN0cmluZz58bnVsbH0gW21lcmdlZENoaWxkSWRzPW51bGxdXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRWZG9tVHJlZSh2ZG9tLCBkZXB0aD0tMSwgbWVyZ2VkQ2hpbGRJZHM9bnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jYnVpbGRUcmVlKHZkb20sIGRlcHRoLCBtZXJnZWRDaGlsZElkcywgJ2NuJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgYSBnaXZlbiB2bm9kZSB0cmVlIGFuZCByZXBsYWNlcyBjaGlsZCBjb21wb25lbnQgcmVmZXJlbmNlcyB3aXRoIHRoZWlyIHZub2RlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2bm9kZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVwdGg9LTFdXG4gICAgICogQHBhcmFtIHtTZXQ8U3RyaW5nPnxudWxsfSBbbWVyZ2VkQ2hpbGRJZHM9bnVsbF1cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldFZub2RlVHJlZSh2bm9kZSwgZGVwdGg9LTEsIG1lcmdlZENoaWxkSWRzPW51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2J1aWxkVHJlZSh2bm9kZSwgZGVwdGgsIG1lcmdlZENoaWxkSWRzLCAnY2hpbGROb2RlcycpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhUcmVlQnVpbGRlcik7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=