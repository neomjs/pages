export const __webpack_esm_id__ = "vendors-src_menu_List_mjs";
export const __webpack_esm_ids__ = ["vendors-src_menu_List_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./src/data/Model.mjs"
/*!****************************!*\
  !*** ./src/data/Model.mjs ***!
  \****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RecordFactory.mjs */ "./src/data/RecordFactory.mjs");
/* harmony import */ var _core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");




/**
 * @class Neo.data.Model
 * @extends Neo.core.Base
 *
 * @summary Defines the schema and data processing logic for records in a Store.
 *
 * Models define the `fields` array, which maps raw data keys to canonical field names, handles
 * data conversion, and defines computed values.
 *
 * ### Calculated Fields & Dependencies
 *
 * Fields can dynamically compute their values using a `calculate` function. 
 * If a calculated field relies on other calculated fields, you **MUST** declare them in the `depends` array.
 *
 * This is critical for performance when the Store operates in "Turbo Mode" (`autoInitRecords: false`).
 * In Turbo Mode, the Store performs "Soft Hydration" on raw JSON objects. Declaring `depends` ensures
 * the Store recursively resolves and caches the dependencies before executing your calculate function,
 * preventing massive performance bottlenecks (like redundant array reductions).
 *
 * @example
 * fields: [{
 *     name: 'total',
 *     type: 'Integer',
 *     calculate: data => data.a + data.b
 * }, {
 *     name: 'ratio',
 *     type: 'Float',
 *     depends: ['total'], // Crucial for Turbo Mode performance!
 *     calculate: data => data.total === 0 ? 0 : data.a / data.total
 * }]
 */
class Model extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.data.Model'
         * @protected
         */
        className: 'Neo.data.Model',
        /**
         * @member {String} ntype='model'
         * @protected
         */
        ntype: 'model',
        /**
         * @member {Object[]|null} fields_
         * @reactive
         */
        fields_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_2__.isDescriptor]: true,
            merge         : 'deepArrays',
            value         : null
        },
        /**
         * @member {String} keyProperty_='id'
         * @reactive
         */
        keyProperty_: 'id',
        /**
         * @member {String|null} storeId=null
         * @protected
         */
        storeId: null,
        /**
         * Set this config to true in case you want to track modified fields.
         * Be aware that this will double the amount of data inside each record,
         * since each field will get an original value flag.
         * @member {Boolean} trackModifiedFields=false
         */
        trackModifiedFields: false
    }

    /**
     * Internally storing all fields, which have a calculate property
     * @member {Map} calculatedFieldsMap=new Map()
     * @protected
     */
    calculatedFieldsMap = new Map()
    /**
     * Internally storing all fields inside a flat map => nested fields included
     * @member {Map} fieldsMap=new Map()
     * @protected
     */
    fieldsMap = new Map()
    /**
     * @member {Boolean} hasComplexFields=false
     * @protected
     */
    hasComplexFields = false
    /**
     * @member {Boolean} hasNestedFields=false
     * @protected
     */
    hasNestedFields = false

    /**
     Triggered after the fields config got changed
     * @param {Object[]|null} value
     * @param {Object[]|null} oldValue
     * @protected
     */
    afterSetFields(value, oldValue) {
        if (value) {
            let me = this;

            me.updateFieldsMap(value);

            // Fields can get changed multiple times before the model instance is getting constructed.
            // We only need the latest state before construction & honor run-time changes.
            if (me.isConstructed) {
                _RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].createRecordClass(me, true)
            }
        }
    }

    /**
     * Finds a field config by a given field name
     * @param {String} name
     * @returns {Object|null} The field config object or null if no match was found
     */
    getField(name) {
        return this.fieldsMap.get(name) || null
    }

    /**
     * Finds a field type by a given field name
     * @param {String} name
     * @returns {String|null} The lowercase field type or null if no match was found
     */
    getFieldType(name) {
        return this.getField(name)?.type?.toLowerCase() || null
    }

    /**
     * Serializes the instance into a JSON-compatible object for the Neural Link.
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            fields             : me.serializeConfig(me.fields),
            keyProperty        : me.keyProperty,
            storeId            : me.storeId,
            trackModifiedFields: me.trackModifiedFields
        }
    }

    /**
     * @param {Object[]} fields
     * @param {Boolean} isRoot=true
     * @param {String} path=''
     */
    updateFieldsMap(fields, isRoot=true, path='') {
        let me = this,
            {calculatedFieldsMap, fieldsMap} = me,
            fieldName;

        if (isRoot) {
            calculatedFieldsMap.clear();
            fieldsMap.clear();
            me.hasComplexFields = false; // Reset flag
            me.hasNestedFields  = false
        }

        fields.forEach(field => {
            fieldName = path + field.name

            if (field.fields) {
                me.hasNestedFields = true;
                me.updateFieldsMap(field.fields, false, field.name + '.')
            } else {
                fieldsMap.set(fieldName, field);

                if (field.calculate) {
                    calculatedFieldsMap.set(fieldName, field)
                }

                // Check for complex fields (Soft Hydration Optimization)
                if (field.calculate || field.convert || field.mapping) {
                    me.hasComplexFields = true
                }
            }
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Model));


/***/ },

/***/ "./src/data/RecordFactory.mjs"
/*!************************************!*\
  !*** ./src/data/RecordFactory.mjs ***!
  \************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _Model_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Model.mjs */ "./src/data/Model.mjs");




const
    dataSymbol         = Symbol.for('data'),
    initialIndexSymbol = Symbol.for('initialIndex'),
    isModifiedSymbol   = Symbol.for('isModified'),
    originalDataSymbol = Symbol.for('originalData'),
    versionSymbol      = Symbol.for('version');

let instance;

/**
 * @class Neo.data.RecordFactory
 * @extends Neo.core.Base
 * @singleton
 */
class RecordFactory extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.data.RecordFactory'
         * @protected
         */
        className: 'Neo.data.RecordFactory',
        /**
         * @member {String} recordNamespace='Neo.data.record'
         */
        recordNamespace: 'Neo.data.record',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * Assigns model-based default values to a data object
     * @param {Object}         data
     * @param {Neo.data.Model} model
     * @returns {Object}
     */
    assignDefaultValues(data, model) {
        model.fieldsMap.forEach((field, fieldName) => {
            if (field.virtual) return;

            if (field.mapping && !Object.hasOwn(data, fieldName)) {
                let ns  = field.mapping.split('.'),
                    key = ns.pop(),
                    source;

                if (ns.length > 0) {
                    source = Neo.ns(ns, false, data)
                } else {
                    source = data
                }

                if (source && Object.hasOwn(source, key)) {
                    data[fieldName] = source[key]
                }
            }

            if (Object.hasOwn(field, 'defaultValue')) {
                const defaultValue = Neo.isFunction(field.defaultValue) ? field.defaultValue() : field.defaultValue;

                // We could always use Neo.assignToNs() => the check is just for improving the performance
                if (model.hasNestedFields) {
                    Neo.assignToNs(fieldName, defaultValue, data, false)
                } else if (data[fieldName] === undefined) {
                    data[fieldName] = defaultValue
                }
            }
        });

        return data
    }

    /**
     * @param {Object} data
     * @param {Object} data.field
     * @param {Neo.data.Model} data.model
     * @param {String} data.path=''
     * @param {Object} data.proto
     */
    createField({field, model, path='', proto}) {
        let fieldName = field.name,
            fieldPath = path === '' ? fieldName : `${path}.${fieldName}`,
            properties;

        if (field.fields) {
            field.fields.forEach(childField => {
                this.createField({field: childField, model, path: fieldPath, proto})
            })
        } else {
            if (field.virtual) {
                properties = {
                    [fieldPath]: {
                        configurable: true,
                        enumerable  : true,
                        get() {
                            return field.calculate(this[dataSymbol], this)
                        }
                    }
                }
            } else {
                properties = {
                    [fieldPath]: {
                        configurable: true,
                        enumerable  : true,
                        get() {
                            if (model.hasNestedFields) {
                                return Neo.ns(fieldPath, false, this[dataSymbol])
                            }

                            return this[dataSymbol][fieldName]
                        },
                        set(value) {
                            this.notifyChange({
                                fields: {[fieldPath]: instance.parseRecordValue({record: this, field, value})},
                                model,
                                record: this
                            })
                        }
                    }
                }
            }

            Object.defineProperties(proto, properties)
        }
    }

    /**
     * @param {Neo.data.Model} model
     * @param {Object} config
     * @returns {Object}
     */
    createRecord(model, config) {
        let recordClass = Neo.ns(`${this.recordNamespace}.${model.className}.${model.id}`);

        if (!recordClass) {
            recordClass = this.createRecordClass(model)
        }

        return new recordClass(config)
    }

    /**
     * @param {Neo.data.Model} model
     * @param {Boolean} overwrite=false
     * @returns {Object}
     */
    createRecordClass(model, overwrite=false) {
        if (model instanceof _Model_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]) {
            let className = `${this.recordNamespace}.${model.className}.${model.id}`,
                ns        = Neo.ns(className),
                key, nsArray, cls;

            if (!ns || overwrite) {
                nsArray = className.split('.');
                key     = nsArray.pop();
                ns      = Neo.ns(nsArray, true);
                cls     = ns[key] = class Record {
                    // We do not want to minify the ctor class name in dist/production
                    static name = 'Record';

                    [dataSymbol]         = {};
                    [initialIndexSymbol] = null;
                    /**
                     * The current version of the record. Increments on every modification.
                     * Used for change tracking and optimization (e.g. short-circuiting grid rendering).
                     * @member {Number} [versionSymbol]=0
                     */
                    [versionSymbol] = 0;

                    /**
                     * The stable, globally unique internal ID for this record instance.
                     * @member {String} internalId
                     */
                    [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_0__.internalId] = Neo.getId('record');

                    get isModified() {
                        let me = this;

                        if (model.trackModifiedFields) {
                            return !Neo.isEqual(me[dataSymbol], me[originalDataSymbol])
                        }

                        return me[isModifiedSymbol]
                    }

                    /**
                     * Returns the current version of the record.
                     * @returns {Number}
                     */
                    get version() {
                        return this[versionSymbol]
                    }

                    /**
                     * @param {Object} config
                     */
                    constructor(config) {
                        let me = this;

                        if (Object.hasOwn(config, initialIndexSymbol)) {
                            me[initialIndexSymbol] = config[initialIndexSymbol];
                            delete config[initialIndexSymbol]
                        }

                        config = instance.assignDefaultValues(config, model);

                        if (model.trackModifiedFields) {
                            me[originalDataSymbol] = {};
                            me.setOriginal(config)
                        } else {
                            me[isModifiedSymbol] = false
                        }

                        me.setSilent(config) // We do not want to fire change events when constructing
                    }

                    /**
                     * @param {String} field
                     * @returns {*}
                     */
                    get(field) {
                        if (model.getField(field)) {
                            return this[field]
                        }

                        if (field.includes('.')) {
                            return Neo.ns(field, false, this[dataSymbol])
                        }

                        return this[dataSymbol][field]
                    }

                    /**
                     * @param {String} fieldName
                     * @returns {Boolean|null} null in case the model does not use trackModifiedFields, true in case a change was found
                     */
                    isModifiedField(fieldName) {
                        let me = this;

                        if (model.trackModifiedFields) {
                            let dataScope, originalDataScope;

                            if (model.hasNestedFields && fieldName?.includes('.')) {
                                let nsArray = fieldName.split('.');

                                fieldName         = nsArray.pop();
                                dataScope         = Neo.ns(nsArray, false, me[dataSymbol]);
                                originalDataScope = Neo.ns(nsArray, false, me[originalDataSymbol])
                            } else {
                                dataScope         = me[dataSymbol];
                                originalDataScope = me[originalDataSymbol]
                            }

                            // Check if the field exists
                            if (
                                !model.getField(fieldName) &&        // Check for leaf fields (could be excluded inside the real data)
                                !Object.hasOwn(dataScope, fieldName) // Check the data tree
                            ) {
                                console.error('The record does not contain the field', fieldName, me)
                            }

                            return !Neo.isEqual(dataScope[fieldName], originalDataScope[fieldName])
                        }

                        return null
                    }

                    /**
                     * The single source of truth for record field changes.
                     * Executes instance.setRecordFields(), and can get used via:
                     * - Neo.util.Function:createSequence()
                     * - Neo.util.Function:intercept(),
                     * to "listen" to field changes
                     * @param {Object}         data
                     * @param {Object}         data.fields
                     * @param {Neo.data.Model} data.model
                     * @param {Object}         data.record
                     * @param {Boolean}        silent=false
                     * @returns {Object}
                     */
                    notifyChange(data, silent=false) {
                        const param = {...data, silent}
                        instance.setRecordFields(param);
                        return param
                    }

                    /**
                     * Bulk-update multiple record fields at once
                     * @param {Object} fields
                     */
                    reset(fields) {
                        this.setOriginal(fields);
                        this.set(fields)
                    }

                    /**
                     * Bulk-update multiple record fields at once
                     * @param {Object} fields
                     */
                    set(fields) {
                        this.notifyChange({fields, model, record: this})
                    }

                    /**
                     * If the model uses trackModifiedFields, we will store the original data
                     * for tracking the dirty state (changed fields)
                     * @param {Object} fields
                     * @protected
                     */
                    setOriginal(fields) {
                        instance.setRecordFields({fields, model, record: this, silent: true, useOriginalData: true})
                    }

                    /**
                     * Bulk-update multiple record fields at once without triggering a change event
                     * @param {Object} fields
                     */
                    setSilent(fields) {
                        this.notifyChange({fields, model, record: this}, true)
                    }

                    /**
                     * When using JSON.stringify(this), we want to get the raw data
                     * @returns {Object}
                     */
                    toJSON() {
                        return structuredClone(this[dataSymbol])
                    }
                };

                if (Array.isArray(model.fields)) {
                    model.fields.forEach(field => {
                        instance.createField({field, model, proto: cls.prototype})
                    })
                }

                Object.defineProperty(cls.prototype, 'isRecord', {value: true});
                Object.defineProperty(cls, 'isClass', {value: true});

                return ns[key]
            }

            return ns
        }
    }

    /**
     * Tests if a given object is an instance of a class created by this factory
     * @param {Object} record
     * @returns {Boolean}
     */
    isRecord(record) {
        return record?.isRecord || false
    }

    /**
     * Gets triggered after changing the value of a record field.
     * E.g. myRecord.foo = 'bar';
     * @param {Object} opts
     * @param {Object[]} opts.fields Each field object contains the keys: name, oldValue, value
     * @param {Neo.data.Model} opts.model The model instance of the changed record
     * @param {Object} opts.record
     */
    onRecordChange(opts) {
        Neo.get(opts.model.storeId)?.onRecordChange(opts)
    }

    /**
     * @param {Object}  data
     * @param {Object}  data.record
     * @param {Object}  data.field
     * @param {*}       [data.value=null]
     * @param {Object}  [data.recordConfig=null]
     * @param {Boolean} [data.useOriginalData=false]
     * @returns {*}
     */
    parseRecordValue({record, field, value=null, recordConfig=null, useOriginalData=false}) {
        if (field.calculate) {
            return field.calculate(record[useOriginalData ? originalDataSymbol : dataSymbol], field)
        }

        if (field.convert) {
            value = field.convert(value, record)
        }

        let fieldName = field.name,
            {mapping, maxLength, minLength, nullable} = field,
            oldValue  = recordConfig?.[fieldName] || record[fieldName],
            type      = field.type?.toLowerCase();

        // only trigger mappings for initial values
        // dynamic changes of a field will not pass the recordConfig
        if (mapping && recordConfig) {
            let ns  = mapping.split('.'),
                key = ns.pop();

            ns    = Neo.ns(ns, true, recordConfig);
            value = ns[key]
        }

        if (Object.hasOwn(field, 'maxLength')) {
            if (value?.toString().length > maxLength) {
                console.warn(`Setting record field: ${fieldName} value: ${value} conflicts with maxLength: ${maxLength}`);
                return oldValue
            }
        }

        if (Object.hasOwn(field, 'minLength')) {
            if (value?.toString().length < minLength) {
                console.warn(`Setting record field: ${fieldName} value: ${value} conflicts with minLength: ${minLength}`);
                return oldValue
            }
        }

        if (Object.hasOwn(field, 'nullable')) {
            if (nullable === false && value === null) {
                console.warn(`Setting record field: ${fieldName} value: ${value} conflicts with nullable: ${nullable}`);
                return oldValue
            }
        }

        if (type === 'date' && Neo.typeOf(value) !== 'Date') {
            return new Date(value)
        }

        else if (type === 'float' && value) {
            value = parseFloat(value)
        }

        else if (type === 'html' && value) {
            value = value + ''
        }

        else if ((type === 'int' || type === 'integer') && value) {
            value = parseInt(value)
        }

        else if (type === 'string' && value) {
            value = value + '';
            value =  value.replace(/(<([^>]+)>)/ig, '')
        }

        return value
    }

    /**
     * @param {Object}         data
     * @param {String}         data.fieldName
     * @param {Neo.data.Model} data.model
     * @param {Record}         data.record
     * @param {Boolean}        data.useOriginalData=false true will apply changes to the originalData symbol
     * @param {*}              data.value
     * @protected
     */
    setRecordData({fieldName, model, record, useOriginalData=false, value}) {
        if (useOriginalData && !model.trackModifiedFields) {
            return
        }

        let scope = useOriginalData ? originalDataSymbol : dataSymbol;

        if (model.hasNestedFields && fieldName.includes('.')) {
            let ns, nsArray;

            nsArray   = fieldName.split('.');
            fieldName = nsArray.pop();
            ns        = Neo.ns(nsArray, true, record[scope]);

            ns[fieldName] = value
        } else {
            record[scope][fieldName] = value
        }
    }

    /**
     * @param {Object}         data
     * @param {Object[]}       data.changedFields=[] Internal flag
     * @param {Object}         data.fields
     * @param {Neo.data.Model} data.model
     * @param {Object}         data.record
     * @param {Boolean}        data.silent=false
     * @param {Boolean}        data.useOriginalData=false true will apply changes to the originalData symbol
     */
    setRecordFields({changedFields=[], fields, model, record, silent=false, useOriginalData=false}) {
        let me = this,
            {calculatedFieldsMap, fieldsMap, trackModifiedFields} = model,
            fieldExists, hasChangedFields, oldValue;

        if (!trackModifiedFields && useOriginalData) {
            return
        }

        Object.entries(fields).forEach(([key, value]) => {
            fieldExists = fieldsMap.has(key);

            if (Neo.isObject(value) && !fieldExists) {
                Object.entries(value).forEach(([childKey, childValue]) => {
                    me.setRecordFields({
                        changedFields,
                        fields: {[`${key}.${childKey}`]: childValue},
                        model,
                        record,
                        silent: true,
                        useOriginalData
                    })
                })
            } else if (fieldExists) {
                oldValue = record[key];
                value    = me.parseRecordValue({record, field: model.getField(key), value});

                if (!Neo.isEqual(oldValue, value)) {
                    me.setRecordData({fieldName: key, model, record, useOriginalData, value});

                    if (!trackModifiedFields && !useOriginalData) {
                        record[isModifiedSymbol] = true
                    }

                    changedFields.push({name: key, oldValue, value})
                }
            }
        });

        hasChangedFields = Object.keys(changedFields).length > 0;

        if (hasChangedFields) {
            record[versionSymbol]++;

            calculatedFieldsMap.forEach((value, key) => {
                if (value.virtual) return;

                oldValue = record[key];
                value    = me.parseRecordValue({record, field: model.getField(key), useOriginalData});

                if (!Neo.isEqual(oldValue, value)) {
                    me.setRecordData({fieldName: key, model, record, useOriginalData, value});

                    changedFields.push({name: key, oldValue, value})
                }
            })
        }

        if (!silent && !useOriginalData && hasChangedFields) {
            me.onRecordChange({fields: changedFields, model, record})
        }
    }
}

instance = Neo.setupClass(RecordFactory);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (instance);


/***/ },

/***/ "./src/data/Store.mjs"
/*!****************************!*\
  !*** ./src/data/Store.mjs ***!
  \****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../collection/Base.mjs */ "./src/collection/Base.mjs");
/* harmony import */ var _Model_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Model.mjs */ "./src/data/Model.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./RecordFactory.mjs */ "./src/data/RecordFactory.mjs");
/* harmony import */ var _manager_Store_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../manager/Store.mjs */ "./src/manager/Store.mjs");








const initialIndexSymbol = Symbol.for('initialIndex');

/**
 * @class Neo.data.Store
 * @extends Neo.collection.Base
 * @mixes Neo.core.Observable
 *
 * @summary A powerful, observable collection that manages a set of data records.
 *
 * Neo.data.Store is the central data management class in the framework. It handles the lifecycle of
 * data records, including loading, filtering, sorting, and synchronization with backend APIs.
 *
 * ### Record Instantiation Strategies: Eager vs. Lazy ("Turbo Mode")
 *
 * The Store supports two distinct strategies for handling record creation, controlled by the `autoInitRecords` config
 * (which defaults to `true`) and the `init` parameter in methods like `add()` and `insert()`.
 *
 * **1. Eager Instantiation (Default: `autoInitRecords: true`)**
 *    - **Behavior**: Raw data objects are immediately converted into `Neo.data.Model` instances.
 *    - **Use Case**: Standard operations, adding single items, interactive edits.
 *    - **Pros**: Returns usable Record instances immediately. High Developer Experience (DX).
 *    - **Cons**: Can be slow for massive datasets (10k+ records).
 *
 * **2. Lazy Instantiation ("Turbo Mode")**
 *    - **Behavior**: Raw data objects are stored directly. `Neo.data.Model` instances are created
 *      "just-in-time" only when they are accessed via `get()`, `getAt()`, or iteration.
 *    - **Use Case**: Bulk loading large datasets (e.g., grids, charts with thousands of points).
 *    - **Pros**: Massive performance gains for initial data load. Enables internal "chunking" to prevent UI freezes.
 *    - **Cons**: `add()` returns a count instead of records. Records are not available until accessed.
 *    - **How to enable**:
 *      - **Global**: Set `autoInitRecords: false` on the Store config.
 *      - **Per-call**: Pass `false` as the second argument to `add()` or `insert()`.
 *      ```javascript
 *      // Global setting
 *      Neo.create(Store, {
 *          autoInitRecords: false,
 *          data: hugeArrayOfData
 *      });
 *
 *      // Per-call override
 *      store.add(hugeArrayOfData, false);
 *      ```
 *
 * ### Soft Hydration & Field Dependencies
 *
 * When operating in Turbo Mode (`autoInitRecords: false`), the Store sorts and filters using raw JSON objects.
 * If a sort or filter operation requires a calculated field that isn't present on the raw object, the Store
 * performs **Soft Hydration** via `resolveField()`. It dynamically calculates the field value and auto-caches
 * it on the raw object.
 *
 * If a calculated field relies on other calculated fields, the Model definition must declare a `depends: []` array.
 * The Store uses this array to recursively resolve and cache all dependencies before executing the main calculation,
 * preventing severe performance bottlenecks (like redundant array reductions).
 *
 * ### Progressive Loading (Streaming)
 *
 * When using a `proxy` (e.g., {@link Neo.data.proxy.Stream}), the Store supports **Progressive Loading**.
 * Instead of waiting for the entire dataset to load, the Store updates itself incrementally as chunks of data arrive.
 *
 * - **Events:** The `load` event fires multiple times (once per chunk) with the cumulative `total`.
 * - **UI Integration:** Components like `Neo.grid.Container` listen to these events to update their scrollbars and render rows immediately.
 */
class Store extends _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.data.Store'
         * @protected
         */
        className: 'Neo.data.Store',
        /**
         * @member {String} ntype='store'
         * @protected
         */
        ntype: 'store',
        /**
         * Instead of setting an url, you can define the RPC BE API methods.
         * In case the 4 methods are using the same service and this service is using the CRUD based fn-names,
         * you can switch to a string based shortcut.
         * The following 2 examples are equivalent.
         * @example
         * api: {
         *    create : 'MyApp.backend.UserService.create',
         *    destroy: 'MyApp.backend.UserService.destroy',
         *    read   : 'MyApp.backend.UserService.read',
         *    update : 'MyApp.backend.UserService.update'
         * }
         * @example
         * api: 'MyApp.backend.UserService'
         * @member {Object|String|null} api_=null
         * @reactive
         */
        api_: null,
        /**
         * True to automatically create record instances when adding items.
         * Set to false to enable "Turbo Mode" (Lazy Instantiation) globally for this store.
         * @member {Boolean} autoInitRecords=true
         */
        autoInitRecords: true,
        /**
         * @member {Boolean} autoLoad=false
         */
        autoLoad: false,
        /**
         * @member {Number} currentPage_=1
         * @reactive
         */
        currentPage_: 1,
        /**
         * @member {Array|null} data_=null
         * @reactive
         */
        data_: null,
        /**
         * The initial chunk size for adding large datasets. Set to 0 to disable chunking.
         * @member {Number} initialChunkSize=0
         */
        initialChunkSize: 0,
        /**
         * @member {Boolean} isGrouped=false
         */
        isGrouped: false,
        /**
         * @member {Boolean} isLoaded=false
         */
        isLoaded: false,
        /**
         * @member {Boolean} isLoading=false
         */
        isLoading: false,
        /**
         * @member {Neo.data.Model} model_=null
         * @reactive
         */
        model_: null,
        /**
         * Use a value of 0 to not limit the pageSize
         * @member {Number} pageSize_=0
         * @reactive
         */
        pageSize_: 0,
        /**
         * @member {Object|Neo.data.proxy.Base|null} proxy_=null
         * @reactive
         */
        proxy_: null,
        /**
         * True to let the backend handle the filtering.
         * Useful for buffered stores
         * @member {Boolean} remoteFilter=false
         */
        remoteFilter: false,
        /**
         * True to let the backend handle the sorting.
         * Useful for buffered stores
         * @member {Boolean} remoteSort=false
         */
        remoteSort: false,
        /**
         * Add a path to the root of your data.
         * If the responseRoot is 'data' this is optional.
         * @member {String} responseRoot='data'
         */
        responseRoot: 'data',
        /**
         * @member {Number} totalCount=0
         */
        totalCount: 0,
        /**
         * True to track internalIds in a separate map for O(1) lookup
         * @member {Boolean} trackInternalId=true
         */
        trackInternalId: true,
        /**
         * Url for Ajax requests
         * @member {String|null} url=null
         */
        url: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        config = config || {};
        config.itemFactory = this.assignInternalId.bind(this);

        super.construct(config);

        let me = this;

        // todo
        me.on({
            mutate: me.onCollectionMutate,
            sort  : me.onCollectionSort,
            scope : me
        });

        _manager_Store_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].register(me)
    }

    /**
     *
     */
    destroy() {
        _manager_Store_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].unregister(this);

        super.destroy()
    }

    /**
     * Identity Provider Hook.
     * Assigns a stable, globally unique 'internalId' to items (Records or Raw Objects).
     * This ensures DOM stability and security by decoupling the DOM ID from the data ID.
     * @param {Object} item
     */
    assignInternalId(item) {
        if (!item[_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_0__.internalId]) {
            item[_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_0__.internalId] = Neo.getId('record')
        }
    }

    /**
     * Aborts the current proxy operation if the proxy supports it.
     */
    abort() {
        this.proxy?.abort?.()
    }

    /**
     * Overrides collection.Base: add() to convert items into records if needed.
     *
     * **1. Eager Mode (`init=true` - Default):**
     * Immediately converts raw data into `Neo.data.Model` instances.
     * Returns an `Array` of the created records.
     *
     * **2. Lazy Mode (`init=false`):**
     * Adds raw data directly for maximum performance. Instantiates records only on access.
     *
     * - **Chunking Active**: If `initialChunkSize > 0` and `items.length > threshold`:
     *   Adds items in chunks to prevent blocking the App Worker (Main Actor).
     *   Returns the new collection `count` (Number).
     *
     * - **No Chunking**: If `initialChunkSize === 0` or `items.length <= threshold`:
     *   Adds raw items directly.
     *   Returns an `Array` of the added raw data objects.
     *
     * @example
     * // 1. Default: Get records immediately
     * const [newRecord] = store.add({name: 'New Item'});
     *
     * @example
     * // 2. Turbo Mode (No Chunking): Get raw objects
     * const [rawObject] = store.add({name: 'Item'}, false);
     *
     * @example
     * // 3. Turbo Mode (Chunking): Get new count
     * store.initialChunkSize = 1000;
     * const newCount = store.add(hugeDataArray, false);
     *
     * @param {Array|Object} item The item(s) to add
     * @param {Boolean} [init=this.autoInitRecords] True to return the created records, false for "Turbo Mode"
     * @returns {Number|Object[]|Neo.data.Model[]} The collection count, raw items, or created records
     */
    add(item, init=this.autoInitRecords) {
        let me        = this,
            items     = Array.isArray(item) ? item : [item],
            threshold = me.initialChunkSize;

        if (init) {
            super.add(items);

            me.isLoaded = true;

            return items.map(i => me.get(me.getKey(i)))
        }

        if (threshold > 0 && items.length > threshold) {
            const total = me.count + items.length,
                  chunk = items.splice(0, threshold);

            me.chunkingTotal = total;

            // 1. Add the first chunk. This fires 'mutate' -> 'load' (via onCollectionMutate)
            //    and triggers the initial grid render. The 'load' event will contain the final total count.
            super.add(chunk); // Pass raw chunk directly

            // 2. Suspend events to prevent the next 'add' from firing 'load'.
            me.suspendEvents = true;

            // 3. Add the rest of the items silently.
            super.add(items); // Pass raw items directly

            // 4. Resume events.
            me.suspendEvents = false;

            // 5. Manually fire a final 'load' event to update the grid's scrollbar and notify other listeners.
            me.fire('load', {items: me.items, postChunkLoad: true, total: me.chunkingTotal});

            delete me.chunkingTotal;

            return me.count
        }

        const returnValue = super.add(items);

        // If we use add() initially instead of setting `data`, we need to set the loaded flag here.
        me.isLoaded = true;

        return returnValue // Pass raw item directly
    }

    /**
     * Triggered after the currentPage config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetCurrentPage(value, oldValue) {
        oldValue && this.load()
    }

    /**
     * @param value
     * @param oldValue
     * @protected
     */
    afterSetData(value, oldValue) {
        let me = this;

        if (me.configsApplied) {
            if (value) {
                if (oldValue) {
                    me.clear()
                }

                me.isLoading = false;

                me.add(value, me.autoInitRecords)
            }
        }
    }

    /**
     * @param {Object[]} value
     * @param {Object[]} oldValue
     * @protected
     */
    afterSetFilters(value, oldValue) {
        super.afterSetFilters(value, oldValue);

        let me = this;

        me._currentPage = 1; // silent update

        oldValue && me.remoteFilter && me.load()
    }

    /**
     * @param value
     * @param oldValue
     * @protected
     */
    afterSetModel(value, oldValue) {
        if (value) {
            value.storeId = this.id
        }
    }

    /**
     * Triggered after the pageSize config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetPageSize(value, oldValue) {
        if (oldValue) {
            this._currentPage = 1; // silent update
            this.load()
        }
    }

    /**
     * @param {Object[]} value
     * @param {Object[]} oldValue
     * @protected
     */
    afterSetSorters(value, oldValue) {
        super.afterSetSorters(value, oldValue);

        let me = this;

        me._currentPage = 1; // silent update

        oldValue && me.remoteSort && me.load()
    }

    /**
     * @param {Object|String|null} value
     * @param {Object|String|null} oldValue
     * @protected
     * @returns {Object|null}
     */
    beforeSetApi(value, oldValue) {
        if (Neo.typeOf(value) === 'String') {
            value = {
                create : value + '.create',
                destroy: value + '.destroy',
                read   : value + '.read',
                update : value + '.update'
            }
        }

        return value
    }

    /**
     * @param {Object|Neo.data.proxy.Base} value
     * @param {Object|Neo.data.proxy.Base} oldValue
     * @protected
     * @returns {Neo.data.proxy.Base}
     */
    beforeSetProxy(value, oldValue) {
        if (oldValue) {
            oldValue.destroy();
        }

        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, null, {
            store: this
        });
    }

    /**
     * @param {Object[]|Neo.data.Model[]} value
     * @param {Object[]|Neo.data.Model[]} oldValue
     * @protected
     * @returns {Object[]|Neo.data.Model[]}
     */
    beforeSetData(value, oldValue) {
        if (value) {
            this.isLoading = true
        }

        return value
    }



    /**
     * @param {Neo.data.Model|Object} value
     * @param {Neo.data.Model|Object} oldValue
     * @protected
     * @returns {Neo.data.Model}
     */
    beforeSetModel(value, oldValue) {
        oldValue?.destroy();

        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, _Model_mjs__WEBPACK_IMPORTED_MODULE_3__["default"])
    }

    /**
     * Overrides collection.Base to prevent the allItems collection from auto-loading
     * @param {Object} config
     * @returns {Neo.collection.Base}
     * @protected
     */
    createAllItems(config) {
        config.autoLoad = false;
        return super.createAllItems(config)
    }

    /**
     * Converts an object or array of objects into records
     * @param {Object|Object[]} config
     * @returns {Object|Object[]} Array in case an array was passed
     */
    createRecord(config) {
        let isArray = true;

        if (config) {
            if (!Array.isArray(config)) {
                isArray = false;
                config  = [config]
            }

            let me  = this,
                i   = 0,
                len = config.length,
                item;

            for (; i < len; i++) {
                item = config[i]

                if (!_RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].isRecord(item)) {
                    config[i] = _RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].createRecord(me.model, item)
                }
            }
        }

        return isArray ? config : config[0]
    }

    /**
     * Overrides collection.Base:find() to ensure the returned item(s) are Record instances.
     * @param {Object|String} property
     * @param {String|Number} [value] Only required in case the first param is a string
     * @param {Boolean} returnFirstMatch=false
     * @returns {Object|Object[]|null}
     */
    find(property, value, returnFirstMatch=false) {
        const result = super.find(property, value, returnFirstMatch);

        if (returnFirstMatch) {
            return result ? this.get(this.getKey(result)) : null;
        } else {
            return result.map(item => this.get(this.getKey(item)));
        }
    }

    /**
     * Overrides collection.Base:findBy() to ensure the returned item(s) are Record instances.
     * @param {function} fn The function to run for each item inside the start-end range. Return true for a match.
     * @param {Object} scope=this The scope in which the passed function gets executed
     * @param {Number} start=0 The start index
     * @param {Number} end=this.count The end index (up to, last value excluded)
     * @returns {Array}
     */
    findBy(fn, scope=this, start=0, end=this.count) {
        const result = super.findBy(fn, scope, start, end);
        return result.map(item => this.get(this.getKey(item)));
    }

    /**
     * Overrides collection.Base:forEach() to ensure the iterated item is a Record instance.
     * @param {Function} fn The function to execute for each record.
     * @param {Object} [scope] Value to use as `this` when executing `fn`.
     */
    forEach(fn, scope) {
        const me = this;
        for (let i = 0; i < me.count; i++) {
            fn.call(scope || me, me.getAt(i), i, me.items);
        }
    }

    /**
     * Overrides collection.Base:get() to ensure the returned item is a Record instance.
     * @param {Number|String} key
     * @returns {Object|null}
     */
    get(key) {
        let me   = this,
            item = super.get(key); // Get item from Collection.Base (could be raw data)

        if (item && !_RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].isRecord(item)) {
            const record = _RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].createRecord(me.model, item);
            const index  = me.indexOf(item);
            const pk     = record[me.keyProperty]; // Use the actual PK from the record

            // Replace the raw data with the record instance in the current (filtered) collection
            me.map.set(pk, record);

            if (index !== -1) {
                me._items[index] = record
            }

            // If we are tracking internalIds, we need to update the map to point to the new record
            // instead of the raw object
            if (me.trackInternalId) {
                const internalKey = me.getInternalKey(record);
                if (internalKey) {
                    me.internalIdMap.set(internalKey, record)
                }
            }

            // If this collection is filtered, we must also update the master 'allItems' collection
            if (me.allItems) {
                const masterIndex = me.allItems.indexOf(item);
                if (masterIndex !== -1) {
                    me.allItems.map.set(pk, record);
                    me.allItems._items[masterIndex] = record;

                    if (me.allItems.trackInternalId) {
                        const internalKey = me.getInternalKey(record);
                        if (internalKey) {
                            me.allItems.internalIdMap.set(internalKey, record)
                        }
                    }
                }
            }
            return record
        }
        return item // Already a record or null
    }

    /**
     * Overrides collection.Base:getAt() to ensure the returned item is a Record instance.
     * @param {Number} index
     * @returns {Object|undefined}
     */
    getAt(index) {
        let me   = this,
            item = super.getAt(index); // Get item from Collection.Base (could be raw data)

        if (item && !_RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].isRecord(item)) {
            const record = _RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].createRecord(me.model, item);

            // Replace the raw data with the record instance in the current (filtered) collection
            me.map.set(record[me.keyProperty], record);
            me._items[index] = record;

            // If we are tracking internalIds, we need to update the map to point to the new record
            // instead of the raw object
            if (me.trackInternalId) {
                const internalKey = me.getInternalKey(record);
                if (internalKey) {
                    me.internalIdMap.set(internalKey, record)
                }
            }

            // If this collection is filtered, we must also update the master 'allItems' collection
            if (me.allItems) {
                const masterIndex = me.allItems.indexOf(item);
                if (masterIndex !== -1) {
                    me.allItems.map.set(record[me.keyProperty], record);
                    me.allItems._items[masterIndex] = record;

                    if (me.allItems.trackInternalId) {
                        const internalKey = me.getInternalKey(record);
                        if (internalKey) {
                            me.allItems.internalIdMap.set(internalKey, record)
                        }
                    }
                }
            }
            return record
        }
        return item // Already a record or undefined
    }

    /**
     * Retrieves the stable internal ID of an item.
     * @param {Object|Neo.data.Record} item
     * @returns {String} e.g. 'neo-record-1'
     */
    getInternalId(item) {
        if (!item[_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_0__.internalId]) {
            item[_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_0__.internalId] = Neo.getId('record')
        }

        return item[_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_0__.internalId]
    }

    /**
     * Hook to get the internal key of an item.
     * @param {Object} item
     * @returns {String|Number|null}
     */
    getInternalKey(item) {
        return item[_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_0__.internalId]
    }

    /**
     * @returns {String}
     */
    getKeyProperty() {
        return this.keyProperty || this.model.keyProperty
    }

    /**
     * Convenience shortcut to check for int based keyProperties
     * @returns {String|null} lowercase value of the model field type
     */
    getKeyType() {
        let me       = this,
            {model}  = me,
            keyField = model?.getField(me.getKeyProperty());

        return keyField?.type?.toLowerCase() || null
    }

    /**
     * Converts a data object into a Record instance or returns it if it is already one.
     * This method is called by add() and insert() when init=true (default).
     * @param {Object} data The data object or Record instance
     * @returns {Object} The Record instance
     */
    initRecord(data) {
        if (_RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].isRecord(data)) {
            return data
        }

        return this.get(this.getKey(data))
    }

    /**
     * Overrides collection.Base: insert() to convert items into records if needed.
     *
     * **Eager Mode (`init=true` - Default):**
     * Immediately converts raw data into `Neo.data.Model` instances.
     * Returns an `Array` of the created records.
     *
     * **Lazy Mode (`init=false`):**
     * Inserts raw data directly. Instantiates records only on access.
     * Returns an `Array` of the inserted raw data objects.
     *
     * @param {Number} index The index to insert at
     * @param {Array|Object} item The item(s) to add
     * @param {Boolean} [init=this.autoInitRecords] True to return the created records
     * @returns {Object[]|Neo.data.Model[]} The inserted raw items or created records
     */
    insert(index, item, init=this.autoInitRecords) {
        let me    = this,
            items = super.insert(index, item);

        if (init) {
            return items.map(i => me.get(me.getKey(i)))
        }

        return items
    }

    /**
     * @param {Object} opts={}
     * @param {Object} opts.data
     * @param {Object} opts.headers
     * @param {String} opts.method DELETE, GET, POST, PUT
     * @param {Object} opts.params
     * @param {String} opts.responseType
     * @param {Object} opts.scope
     * @param {String} opts.url
     * @returns {Promise<Object|Object[]>}
     * @protected
     */
    async load(opts={}) {
        let me     = this,
            params = {page: me.currentPage, pageSize: me.pageSize, ...opts.params};

        if (me.remoteFilter) {
            params.filters = me.exportFilters()
        }

        if (me.remoteSort) {
            params.sorters = me.exportSorters()
        }

        if (me.api) {
            let apiArray = me.api.read.split('.'),
                fn       = apiArray.pop(),
                service  = Neo.ns(apiArray.join('.'));

            if (!service) {
                console.error('Api is not defined', this)
            } else {
                const response = await me.trap(service[fn](params));

                if (response.success) {
                    me.totalCount = response.totalCount;
                    me.data       = Neo.ns(me.responseRoot, false, response); // fires the load event
                    me.isLoaded   = true;

                    return me.data
                }

                return null
            }
        } else if (me.proxy) {
            if (me.items.length > 0 && !opts.append) {
                me.clear();
            }

            me.isLoading = true;

            const onData = (data) => {
                me.add(data);

                // Progressive Rendering:
                // As soon as we have data, we want the grid to render.
                if (me.isLoading) {
                    me.isLoading = false
                }

                // We do not need to fire a load event here, since onCollectionMutate will handle this.
            };

            const onProgress = (data) => {
                me.fire('progress', data)
            };

            me.proxy.on({
                data    : onData,
                progress: onProgress
            });

            try {
                // params.url can override proxy url
                if (opts.url) {
                    params.url = opts.url;
                }

                const response = await me.proxy.read(params);

                me.proxy.un({
                    data    : onData,
                    progress: onProgress
                });

                if (response.success) {
                    me.totalCount = response.totalCount || me.count;
                    me.isLoaded   = true;
                    me.isLoading  = false; // Ensure it's false at the end
                    me.fire('load', {
                        isLoading    : false,
                        items        : me.items,
                        postChunkLoad: me.proxy?.ntype === 'proxy-stream',
                        total        : me.totalCount
                    });
                    return me.items
                } else {
                    me.isLoading = false;
                    return null
                }
            } catch (e) {
                me.proxy.un({
                    data    : onData,
                    progress: onProgress
                });
                me.isLoading = false;
                throw e
            }
        } else {
            opts.url ??= me.url;

            try {
                let data;

                // Fallback for non-browser based envs like nodejs
                if (globalThis.process?.release) {
                    const { readFile } = await import(/* webpackIgnore: true */ 'fs/promises');
                    const content = await me.trap(readFile(opts.url, 'utf-8'));
                    data = {json: JSON.parse(content)};
                } else {
                    data = await me.trap(Neo.Xhr.promiseJson(opts));
                }

                if (data) {
                    me.data = Neo.ns(me.responseRoot, false, data.json) || data.json // fires the load event
                }

                me.isLoaded = true;

                return data?.json || null
            } catch(err) {
                if (err === Neo.isDestroyed) {
                    throw err
                }

                console.error('Error for Neo.Xhr.request', {id: me.id, error: err, url: opts.url});
                return null
            }
        }
    }

    /**
     * @param {Object} opts
     */
    onCollectionMutate(opts) {
        let me = this;

        if (me.isConstructed && !me.isLoading) {
            const isFirstChunk = opts.addedItems && me.count === opts.addedItems.length;

            me.fire('load', {
                isLoading    : !!me.isStreaming,
                items        : me.items,
                postChunkLoad: !!me.isStreaming && !isFirstChunk,
                total        : me.chunkingTotal
            });
        }
    }

    /**
     *
     */
    onCollectionSort() {
        let me = this;

        if (me.isConstructed) {
            me.fire('load', {items: me.items})
        }
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me = this;

        if (me.data) {
            me.afterSetData(me.data)
        }

        // Being constructed does not mean that related afterSetStore() methods got executed
        // => break the sync flow to ensure potential listeners got applied
        Promise.resolve().then(() => {
            if (me.isLoaded) {
                me.fire('load', {items: me.items})
            } else if (me.autoLoad) {
                me.load()
            }
        })
    }

    /**
     * @param {Object} opts
     * @protected
     */
    onFilterChange(opts) {
        let me = this;

        if (me.remoteFilter) {
            me._currentPage = 1; // silent update
            me.load()
        } else {
            super.onFilterChange(opts)
        }
    }

    /**
     * Gets triggered after changing the value of a record field.
     * E.g. myRecord.foo = 'bar';
     * @param {Object} data
     * @param {Object[]} data.fields Each field object contains the keys: name, oldValue, value
     * @param {Neo.data.Model} data.model The model instance of the changed record
     * @param {Object} data.record
     */
    onRecordChange(data) {
        this.fire('recordChange', {
            ...data,
            index: this.indexOf(data.record)
        })
    }

    /**
     * @param {Object} opts={}
     * @param {String} opts.direction
     * @param {String} opts.property
     */
    sort(opts={}) {
        let me = this;

        me._currentPage = 1; // silent update

        if (me.configsApplied) {
            if (opts.direction) {
                me.sorters = [{
                    direction: opts.direction,
                    property : opts.property
                }]
            } else {
                if (!me.remoteSort) {
                    me.sorters = [{
                        direction: 'ASC',
                        property : initialIndexSymbol
                    }]
                }
            }
        }
    }

    /**
     * Overrides collection.Base:doSort() to handle "Turbo Mode" (autoInitRecords: false).
     * In this mode, items are raw objects which may lack the canonical field names used by Sorters.
     * This method "soft hydrates" the raw items by resolving and caching the sort values.
     * @param {Object[]} items
     * @param {Boolean} silent
     * @protected
     */
    doSort(items=this._items, silent=false) {
        let me = this;

        if (!me.autoInitRecords && me.model?.hasComplexFields && me.sorters.length > 0) {
            const
                sortProperties = me.sorters.map(s => s.property),
                len            = sortProperties.length;

            items.forEach(item => {
                // Ensure item is not already a Record (mixed mode safety)
                if (!_RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].isRecord(item)) {
                    for (let i = 0; i < len; i++) {
                        const property = sortProperties[i];

                        // Only resolve if the property is missing on the raw object
                        if (!Object.hasOwn(item, property)) {
                            item[property] = me.resolveField(item, property)
                        }
                    }
                }
            })
        }

        super.doSort(items, silent)
    }

    /**
     * Overrides collection.Base:filter() to handle "Turbo Mode" (autoInitRecords: false).
     * In this mode, items are raw objects which may lack the canonical field names used by Filters.
     * This method "soft hydrates" the raw items by resolving and caching the filter values.
     * @protected
     */
    filter() {
        let me = this;

        if (!me.autoInitRecords && me.model?.hasComplexFields && me.filters.length > 0) {
            const
                activeFilters    = me.filters.filter(f => !f.disabled && f.value !== null),
                filterProperties = activeFilters.map(f => f.property),
                len              = filterProperties.length;

            if (len > 0) {
                // We iterate over allItems (unfiltered source) or current items depending on state,
                // but Collection.filter() uses allItems if it exists. Ideally we hydrate the source.
                // Since we can't easily know which source Collection.filter will use without duplicating logic,
                // we will hydrate both if they exist, or just the active one.
                // Safest bet: Hydrate the source that filter() will use.
                // Collection.filter uses: items = me.allItems?._items || me._items
                const itemsToHydrate = me.allItems ? me.allItems._items : me._items;

                itemsToHydrate.forEach(item => {
                    if (!_RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].isRecord(item)) {
                        for (let i = 0; i < len; i++) {
                            const property = filterProperties[i];

                            if (!Object.hasOwn(item, property)) {
                                item[property] = me.resolveField(item, property)
                            }
                        }
                    }
                })
            }
        }

        super.filter()
    }

    /**
     * Overrides collection.Base:isFilteredItem() to handle "Turbo Mode" (autoInitRecords: false).
     * In this mode, items are raw objects which may lack the canonical field names used by Filters.
     * This method "soft hydrates" the raw item by resolving and caching the filter values.
     * @param {Object} item
     * @returns {boolean}
     * @protected
     */
    isFilteredItem(item) {
        let me = this;

        if (!me.autoInitRecords && !_RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].isRecord(item) && me.filters.length > 0) {
            me.filters.forEach(filter => {
                if (!filter.disabled && filter.value !== null && !Object.hasOwn(item, filter.property)) {
                    item[filter.property] = me.resolveField(item, filter.property)
                }
            })
        }

        return super.isFilteredItem(item)
    }

    /**
     * Helper to resolve a field value from a raw data object using the Model definition.
     * Handles mapping, calculate, and convert.
     *
     * **Limitations & "Turbo-Safe" Requirement:**
     * This method resolves a *single* field in isolation. It does **not** recursively resolve dependencies.
     *
     * If Field A relies on Field B (e.g., via `calculate` or `convert`), and Field B is also a mapped/calculated field:
     * - **On a Record:** Field B is accessible via its getter.
     * - **On a Raw Object:** Field B is `undefined`.
     *
     * Therefore, Model logic (calculate/convert functions) MUST be written to be "Turbo-Safe" / "Polymorphic".
     * They must check for both the canonical field name (for Records) AND the raw data key (for Turbo Mode).
     *
     * @example
     * calculate: data => (data.mappedName || data.rawKey) + 1
     *
     * @param {Object} item The raw data object
     * @param {String} fieldName The canonical field name
     * @returns {*} The resolved value
     * @protected
     */
    resolveField(item, fieldName) {
        let me    = this,
            field = me.model.getField(fieldName),
            value;

        if (!field) return undefined;

        if (!_RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].isRecord(item) && field.depends) {
            let deps = field.depends,
                i    = 0,
                len  = deps.length,
                dep;

            for (; i < len; i++) {
                dep = deps[i];
                if (item[dep] === undefined) {
                    item[dep] = me.resolveField(item, dep);
                }
            }
        }

        if (field.calculate) {
            value = field.calculate(item)
        } else {
            // Handle Mapping
            if (field.mapping) {
                let ns     = field.mapping.split('.'),
                    key    = ns.pop(),
                    source = ns.length > 0 ? Neo.ns(ns, false, item) : item;

                if (source && Object.hasOwn(source, key)) {
                    value = source[key]
                }
            } else {
                value = item[fieldName]
            }

            // Handle Convert
            if (field.convert) {
                value = field.convert(value, item)
            }

            // Handle Default Value
            if (value === undefined && Object.hasOwn(field, 'defaultValue')) {
                value = Neo.isFunction(field.defaultValue) ? field.defaultValue() : field.defaultValue
            }
        }

        if (!_RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].isRecord(item)) {
            item[fieldName] = value;
        }

        return value
    }

    /**
     * Resolves the key of a given item, supporting both raw data objects and Record instances.
     * This handles the edge case where `keyProperty` refers to a mapped source key (e.g. 'l')
     * which exists on the raw object but not on the Record instance (where it is mapped to e.g. 'login').
     * @param {Object|Neo.data.Record} item
     * @returns {String|Number}
     */
    getKey(item) {
        let me          = this,
            keyProperty = me.getKeyProperty(),
            value;

        if (_RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].isRecord(item)) {
            return item.get(keyProperty)
        }

        if (keyProperty.includes('.')) {
            value = Neo.ns(keyProperty, false, item)
        } else {
            value = item[keyProperty]
        }

        // If direct access failed, check for mapping (Reverse Lookup)
        if (value === undefined && me.model) {
            let field = me.model.getField(keyProperty);
            if (field?.mapping) {
                let mapping = field.mapping;
                if (mapping.includes('.')) {
                    value = Neo.ns(mapping, false, item)
                } else {
                    value = item[mapping]
                }
            }
        }

        return value
    }

    /**
     * Serializes the instance into a JSON-compatible object for the Neural Link.
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            autoInitRecords : me.autoInitRecords,
            autoLoad        : me.autoLoad,
            currentPage     : me.currentPage,
            initialChunkSize: me.initialChunkSize,
            isGrouped       : me.isGrouped,
            isLoaded        : me.isLoaded,
            isLoading       : me.isLoading,
            model           : me.model?.toJSON(),
            pageSize        : me.pageSize,
            remoteFilter    : me.remoteFilter,
            remoteSort      : me.remoteSort,
            totalCount      : me.totalCount,
            url             : me.url
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Store));


/***/ },

/***/ "./src/list/Base.mjs"
/*!***************************!*\
  !*** ./src/list/Base.mjs ***!
  \***************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _selection_ListModel_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../selection/ListModel.mjs */ "./src/selection/ListModel.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _data_Store_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../data/Store.mjs */ "./src/data/Store.mjs");






/**
 * @class Neo.list.Base
 * @extends Neo.component.Base
 */
class List extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.list.Base'
         * @protected
         */
        className: 'Neo.list.Base',
        /**
         * @member {String} ntype='list'
         * @protected
         */
        ntype: 'list',
        /**
         * @member {Boolean} animate_=false
         * @reactive
         */
        animate_: false,
        /**
         * True will destroy the used collection / store when the component gets destroyed
         * @member {Boolean} autoDestroyStore=true
         */
        autoDestroyStore: true,
        /**
         * @member {String[]} baseCls=['neo-list']
         */
        baseCls: ['neo-list'],
        /**
         * An optional record field to make items non-clickable and visually greyed out.
         * The field expects the Boolean type.
         * @member {String} disabledField='disabled'
         */
        disabledField: 'disabled',
        /**
         * @member {Boolean} disableSelection_=false
         * @reactive
         */
        disableSelection_: false,
        /**
         * @member {String} displayField='name'
         */
        displayField: 'name',
        /**
         * @member {Boolean} draggable_=false
         * @reactive
         */
        draggable_: false,
        /**
         * @member {Neo.draggable.list.DragZone|null} dragZone=null
         */
        dragZone: null,
        /**
         * @member {Object} dragZoneConfig=null
         */
        dragZoneConfig: null,
        /**
         * Keeps track of the focussed item index and allows bindings and programmatic changes.
         * You can either pass the index or the related record
         * @member {Number|Object|null} focusIndex_=null
         * @reactive
         */
        focusIndex_: null,
        /**
         * In case we are using list item headers and want to bind list item indexes to e.g. a card layout
         * for e.g. a sidenav, this config comes in handy.
         * @member {Number|null} headerlessSelectedIndex_=null
         * @reactive
         */
        headerlessSelectedIndex_: null,
        /**
         * @member {Boolean} highlightFilterValue=true
         */
        highlightFilterValue: true,
        /**
         * @member {String} itemCls='neo-list-item'
         */
        itemCls: 'neo-list-item',
        /**
         * Defaults to px
         * @member {Number|null} itemHeight_=null
         * @reactive
         */
        itemHeight_: null,
        /**
         * The type of the node / tag for each list item
         * @member {String} itemTagName='li'
         */
        itemTagName: 'li',
        /**
         * Defaults to px
         * @member {Number|null} itemWidth_=null
         * @reactive
         */
        itemWidth_: null,
        /**
         * @member {Boolean} itemsFocusable=true
         */
        itemsFocusable: true,
        /**
         * The config will get passed to the navigator main thread addon.
         * E.g. for ComboBoxes, which shall preserve their focussed list item when filtering the store, use true.
         * @member {Boolean} keepFocusIndex=false
         */
        keepFocusIndex: false,
        /**
         * Additional used keys for the selection model
         * @member {Object} keys
         */
        keys: {},
        /**
         * config values for Neo.list.plugin.Animate
         * @member {Object} pluginAnimateConfig=null
         */
        pluginAnimateConfig: null,
        /**
         * Keeps track of the selected item index and allows bindings and programmatic changes
         * @member {Number|null} selectedIndex_=null
         * @reactive
         */
        selectedIndex_: null,
        /**
         * Either pass a selection.Model module, an instance or a config object
         * @member {Object|Neo.selection.Model} selectionModel_=null
         * @reactive
         */
        selectionModel_: null,
        /**
         * Set this to true in case a keyboard navigation should immediately select the focussed item
         * @member {Boolean} selectOnFocus=false
         */
        selectOnFocus: false,
        /**
         * Set this to true in case a select event should only update _vdom (e.g. when used inside a form.field.ComboBox
         * @member {Boolean} silentSelect=false
         */
        silentSelect: false,
        /**
         * @member {Neo.data.Store|null} store_=null
         * @reactive
         */
        store_: null,
        /**
         * True will add a checkbox in front of each list item
         * @member {Boolean} stacked_=true
         * @reactive
         */
        useCheckBoxes_: false,
        /**
         * @member {Boolean} useInternalId=true
         */
        useInternalId: true,
        /**
         * Setting this config to true will switch to dl, dt & dd tags instead of using ul & li.
         * Use the {Boolean} model field isHeader.
         * @member {Boolean} useHeaders_=false
         * @reactive
         */
        useHeaders_: false,
        /**
         * @member {Boolean} useWrapperNode_=false
         * @reactive
         */
        useWrapperNode_: false,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {tag: 'ul', cn: []}
    }

    /**
     * @member {String|null} itemRole=null
     */
    itemRole = null
    /**
     * An object to help configure the navigation. Used to pass to {@link Neo.main.addon.Navigator#subscribe}.
     * @member {Object} navigator={}
     */
    navigator = {}
    /**
     * Defaults to false in case useHeaders is set to true
     * @member {Boolean} scrollIntoViewOnFocus=true
     */
    scrollIntoViewOnFocus = true

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        if (me.useHeaders) {
            me.scrollIntoViewOnFocus = false
        }

        me.addDomListeners({
            click: me.onClick,
            scope: me
        })
    }

    /**
     * Triggered after the animate config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetAnimate(value, oldValue) {
        if (value && !this.getPlugin('list-animate')) {
            __webpack_require__.e(/*! import() */ "vendors-src_list_plugin_Animate_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./plugin/Animate.mjs */ "./src/list/plugin/Animate.mjs")).then(module => {
                let me      = this,
                    plugins = me.plugins || [];

                plugins.push({
                    module: module.default,
                    ...me.pluginAnimateConfig
                });

                me.plugins = plugins
            })
        }
    }

    /**
     * Triggered after the disableSelection config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetDisableSelection(value, oldValue) {
        value && this.vnodeInitialized && this.selectionModel?.deselectAll()
    }

    /**
     * Triggered after the draggable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetDraggable(value, oldValue) {
        let me = this;

        if (value && !me.dragZone) {
            Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("src_draggable_list_DragZone_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ../draggable/list/DragZone.mjs */ "./src/draggable/list/DragZone.mjs")).then(module => {
                me.dragZone = Neo.create({
                    module  : module.default,
                    appName : me.appName,
                    owner   : me,
                    windowId: me.windowId,
                    ...me.dragZoneConfig
                })
            })
        }
    }

    /**
     * Triggered after the focusIndex config got changed
     * @param {Number|Object|null} value
     * @param {Number|Object|null} oldValue
     * @protected
     */
    afterSetFocusIndex(value, oldValue) {
        value !== null && this.updateItemFocus(value)
    }

    /**
     * Triggered after the headerlessSelectedIndex config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetHeaderlessSelectedIndex(value, oldValue) {
        let me = this;

        if (Neo.isNumber(value)) {
            me.selectedIndex = me.store.getCount() ? me.getSelectedIndex(value) : null
        } else if (Neo.isNumber(oldValue)) {
            me.selectedIndex = null
        }
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        let me = this;

        // Tear down navigation before we lose the element
        if (!value && me.hasNavigator) {
            Neo.main.addon.Navigator.unsubscribe(me.navigator);

            me.hasNavigator  = false;
            me.selectedIndex = null
        }

        if (value) {
            // Set up item navigation in the list
            if (!me.hasNavigator) {
                me.navigator = Neo.merge({
                    appName       : me.appName,
                    autoClick     : me.selectOnFocus,
                    id            : me.id,
                    keepFocusIndex: me.keepFocusIndex,
                    selector      : `.${me.itemCls}:not(.neo-disabled,.neo-list-header)`,
                    windowId      : me.windowId
                }, me.navigator);

                me.hasNavigator = true
            }

            Neo.main.addon.Navigator.subscribe(me.navigator)
        }

        super.afterSetMounted(value, oldValue)
    }

    /**
     * Triggered after the selectedIndex config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetSelectedIndex(value, oldValue) {
        let me               = this,
            {selectionModel} = me;

        if (Neo.isNumber(value)) {
            selectionModel?.selectAt(value);
            me.headerlessSelectedIndex = me.getHeaderlessIndex(value)
        } else if (Neo.isNumber(oldValue)) {
            selectionModel.deselectAll();
            me.headerlessSelectedIndex = null
        }
    }

    /**
     * Triggered after the selectionModel config got changed
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @protected
     */
    afterSetSelectionModel(value, oldValue) {
        this.vnodeInitialized && value.register(this)
    }

    /**
     * Triggered after the store config got changed
     * @param {Neo.data.Store} value
     * @param {Neo.data.Store} oldValue
     * @protected
     */
    afterSetStore(value, oldValue) {
        let me = this;

        value?.on({
            filter      : 'onStoreFilter',
            load        : 'onStoreLoad',
            recordChange: 'onStoreRecordChange',
            sort        : 'onStoreSort',
            scope       : me
        });

        value?.getCount() > 0 && me.onStoreLoad()
    }

    /**
     * Triggered after the useCheckBoxes config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetUseCheckBoxes(value, oldValue) {
        let me    = this,
            {cls} = me;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].toggle(cls, 'neo-use-checkicons', !!value);
        me.cls = cls
    }

    /**
     * Triggered after the useHeaders config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetUseHeaders(value, oldValue) {
        if (value) {
            let me = this;

            me.vdom.tag = 'dl';
            me.itemTagName = 'dd'
        }
    }

    /**
     * Triggered after the useWrapperNode config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetUseWrapperNode(value, oldValue) {
        let me                = this,
            {cls, wrapperCls} = me;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"][value ? 'add' : 'remove'](cls, 'neo-use-wrapper-node');
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"][value ? 'add' : 'remove'](wrapperCls, 'neo-list-wrapper');

        me.wrapperCls = wrapperCls;
        me.cls        = cls
    }

    /**
     * Triggered after the windowId config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        super.afterSetWindowId(value, oldValue);

        let {navigator} = this;

        if (value && navigator) {
            navigator.windowId = value
        }
    }

    /**
     * Triggered before the selectionModel config gets changed.
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @returns {Neo.selection.Model}
     * @protected
     */
    beforeSetSelectionModel(value, oldValue) {
        oldValue?.destroy();
        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].beforeSetInstance(value, _selection_ListModel_mjs__WEBPACK_IMPORTED_MODULE_2__["default"])
    }

    /**
     * Triggered before the store config gets changed.
     * @param {Object|Neo.data.Store} value
     * @param {Object|Neo.data.Store} oldValue
     * @returns {Neo.data.Store}
     * @protected
     */
    beforeSetStore(value, oldValue) {
        oldValue?.destroy();
        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].beforeSetInstance(value, _data_Store_mjs__WEBPACK_IMPORTED_MODULE_4__["default"])
    }

    /**
     * Override this method for custom list items
     * @param {Object} record
     * @param {Number} index
     * @returns {Object} The list item vdom object
     */
    createItem(record, index) {
        let me               = this,
            cls              = [me.itemCls],
            hasItemHeight    = me.itemHeight !== null,
            hasItemWidth     = me.itemWidth !== null,
            isHeader         = me.useHeaders && record.isHeader,
            itemContent      = me.createItemContent(record, index),
            itemId           = me.getItemId(me.getRecordId(record)),
            {selectionModel} = me,
            isSelected       = !me.disableSelection && selectionModel?.isSelected(itemId),
            item, removeDom;

        isHeader && cls.push('neo-list-header');

        if (isSelected){
            cls.push(selectionModel.selectedCls)
        }

        if (record.cls) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(cls, record.cls)
        }

        if (record[me.disabledField]) {
            cls.push('neo-disabled')
        }

        item = {
            id  : itemId,
            tag : isHeader ? 'dt' : me.itemTagName,
            'aria-selected' : isSelected,
            cls
        };

        if (me.itemsFocusable) {
            item.tabIndex = -1
        }

        if (record.hidden || itemContent.removeDom) {
            item.removeDom = true
        }

        if (me.itemRole) {
            item.role = me.itemRole
        }

        switch (Neo.typeOf(itemContent)) {
            case null: {
                return null
            }

            case 'Array': {
                item.cn = itemContent;

                removeDom = true;

                itemContent.forEach(item => {
                    if (!item.removeDom) {
                        removeDom = false
                    }
                })

                if (removeDom) {
                    item.removeDom = true
                }

                break
            }

            case 'Object': {
                // We want a merge for custom cls rules
                if (itemContent.cls) {
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(item.cls, itemContent.cls);
                    delete itemContent.cls
                }

                Object.assign(item, itemContent);
                break
            }

            case 'Number':
            case 'String': {
                item.html = itemContent;
                break
            }
        }

        if (hasItemHeight || hasItemWidth) {
            item.style = item.style || {};

            if (hasItemHeight && !item.hasOwnProperty('height')) {
                item.style.height = `${me.itemHeight}px`
            }

            if (hasItemWidth && !item.hasOwnProperty('width')) {
                item.style.width = `${me.itemWidth}px`
            }
        }

        return item
    }

    /**
     * Override this method for custom renderers
     * @param {Object} record
     * @param {Number} index
     * @returns {Object|Object[]|String} Either a config object to assign to the item, a vdom cn array or a html string
     */
    createItemContent(record, index) {
        let me       = this,
            itemText = record[me.displayField],
            filter;

        if (me.highlightFilterValue) {
            filter = me.store.getFilter(me.displayField);

            if (filter && filter.value !== null && filter.value !== '') {
                itemText = itemText.replace(new RegExp(filter.value, 'gi'), function(match) {
                    return '<span class="neo-highlight-search">' + match + '</span>'
                })
            }
        }

        return itemText
    }

    /**
     * @param {Boolean} silent=false
     */
    createItems(silent=false) {
        let me                        = this,
            {headerlessSelectedIndex} = me,
            vdom                      = me.getVdomRoot(),
            listItem;

        // in case we set headerlessSelectedIndex before the store was loaded, selectedIndex can be null
        // and the wanted selection is not initially there
        if (Neo.isNumber(headerlessSelectedIndex) && !Neo.isNumber(me.selectedIndex)) {
            me.afterSetHeaderlessSelectedIndex(headerlessSelectedIndex, null)
        }

        if (!(me.animate && !me.getPlugin('list-animate'))) {
            vdom.cn = [];

            me.store.forEach((item, index) => {
                listItem = me.createItem(item, index);
                listItem && vdom.cn.push(listItem)
            });

            !silent && me.promiseUpdate().then(() => {
                me.fire('createItems')
            })
        }
    }

    /**
     * @param args
     */
    destroy(...args) {
        let me = this;

        me.selectionModel?.destroy();

        me.autoDestroyStore && me.store?.destroy();

        super.destroy(...args)
    }

    /**
     * Calls focus() on the top level DOM node of this component or on a given node via id
     * @param {String} [id=this.id]
     */
    focus(id=this.id) {
        this.mounted && Neo.main.addon.Navigator.navigateTo({
            data    : this.navigator,
            target  : id,
            windowId: this.windowId
        })
    }

    /**
     * @param {Object} record
     * @returns {String|Number}
     */
    getRecordId(record) {
        return this.useInternalId ? this.store.getInternalId(record) : this.store.getKey(record)
    }

    /**
     * Transforms an index excluding list item headers into the real store index
     * @param {Number} headerlessSelectedIndex
     * @returns {Number}
     */
    getSelectedIndex(headerlessSelectedIndex) {
        let delta   = 0,
            i       = 0,
            records = this.store.items,
            len     = headerlessSelectedIndex;

        if (records.length < 1) {
            return null
        }

        for (; i <= len; i++) {
            if (records[i].isHeader) {
                delta++;
                len++
            }
        }

        return headerlessSelectedIndex + delta
    }

    /**
     * Returns the index of a list item excluding item headers
     * @param {Number} index
     * @returns {Number}
     */
    getHeaderlessIndex(index) {
        let headerlessIndex = 0,
            i               = 0,
            records         = this.store.items;

        for (; i < index; i++) {
            if (!records[i].isHeader) {
                headerlessIndex++
            }
        }

        return headerlessIndex
    }

    /**
     * @param {Number|String|object} recordOrId
     * @returns {String}
     */
    getItemId(recordOrId) {
        let id = recordOrId;

        if (recordOrId.isRecord) {
            id = this.getRecordId(recordOrId)
        }

        return `${this.id}__${id}`
    }

    /**
     * @param {String} vnodeId
     * @returns {String|Number} itemId
     */
    getItemRecordId(vnodeId) {
        let itemId = vnodeId.split('__')[1];

        if (!this.useInternalId && this.store.getKeyType()?.includes('int')) {
            itemId = parseInt(itemId)
        }

        return itemId
    }

    /**
     * Support collections & stores
     * @returns {String}
     */
    getKeyProperty() {
        return this.store.keyProperty || this.store.model.keyProperty
    }

    /**
     * @param {Object} data
     */
    onClick(data) {
        let me = this,
            item;

        if (data.path[0].id === me.id) {
            me.onContainerClick(data)
        } else {
            for (item of data.path) {
                if (item.cls.includes(me.itemCls)) {
                    me.onItemClick(item, data);
                    break
                }
            }
        }
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        this.selectionModel?.register(this)
    }

    /**
     * @param {Object} data
     */
    onContainerClick(data) {
        /**
         * The containerClick event fires when a click occurs on the component, but not on a list item
         * @event containerClick
         * @param {String[]} cls the classList of the target node (converted to an array)
         * @param {String} id the target dom id
         * @param {String[]} path the event path
         * @returns {Object}
         */
        this.fire('containerClick', data)
    }

    /**
     * @param {Object} node
     * @param {Object} data
     */
    onItemClick(node, data) {
        let me     = this,
            record = me.store.get(me.getItemRecordId(node.id));

        // pass the record to class extensions
        data.record = record;

        /**
         * The itemClick event fires when a click occurs on a list item
         * @event itemClick
         * @param {String} id the record matching the list item
         * @returns {Object}
         */
        me.fire('itemClick', {
            record
        })
    }

    /**
     *
     */
    onStoreFilter() {
        this.createItems()
    }

    /**
     *
     */
    onStoreLoad() {
        let me = this;

        if (!me.mounted && me.isVnodeInitializing) {
            me.on('mounted', () => {
                me.createItems()
            }, me, {once: true});
        } else {
            me.createItems()
        }
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.fields Each field object contains the keys: name, oldValue, value
     * @param {Number} data.index
     * @param {Neo.data.Model} data.model
     * @param {Object} data.record
     */
    onStoreRecordChange(data) {
        let me      = this,
            {index} = data;

        // ignore changes for records which have not been added to the list yet
        if (index > -1) {
            me.vdom.cn[index] = me.createItem(data.record, index);
            me.update()
        }
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.items
     * @param {Object[]} data.previousItems
     * @param {Neo.data.Store} data.scope
     */
    onStoreSort(data) {
        this.createItems()
    }

    /**
     * Convenience shortcut
     * @param {Number|String} item
     */
    selectItem(item) {
        let me = this;

        if (!me.disableSelection) {
            // Selecting index
            if (Neo.isNumber(item)) {
                me.selectionModel?.selectAt(item)
            }
            // Selecting record
            else if (item) {
                me.selectionModel?.selectAt(me.store.indexOf(item))
            }
        }
    }

    /**
     *
     * @param {Number|Object} value
     * @returns {Promise<void>}
     */
    async updateItemFocus(value) {
        let me           = this,
            {navigateTo} = Neo.main.addon.Navigator;

        if (me.mounted) {
            if (Neo.isNumber(value)) {
                navigateTo({
                    data    : me.navigator,
                    target  : me.getHeaderlessIndex(value),
                    windowId: me.windowId
                })
            } else if (value) {
                navigateTo({
                    data    : me.navigator,
                    target  : me.getItemId(me.getRecordId(value)),
                    windowId: me.windowId
                })
            }
        } else {
            me.on('mounted', () => {
                // We could subscribe multiple times before getting mounted,
                // so only trigger the callback for the last focusIndex
                if (value === me.focusIndex) {
                    me.updateItemFocus(me.focusIndex)
                }
            }, me, {once: true})
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(List));


/***/ },

/***/ "./src/manager/Store.mjs"
/*!*******************************!*\
  !*** ./src/manager/Store.mjs ***!
  \*******************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/manager/Base.mjs");


/**
 * @class Neo.manager.Store
 * @extends Neo.manager.Base
 * @singleton
 */
class Store extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.Store'
         * @protected
         */
        className: 'Neo.manager.Store',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);
        
        // Alias Neo.getStore to this manager?
        // Neo.getStore = this.get.bind(this);
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Store));


/***/ },

/***/ "./src/menu/List.mjs"
/*!***************************!*\
  !*** ./src/menu/List.mjs ***!
  \***************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _list_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../list/Base.mjs */ "./src/list/Base.mjs");
/* harmony import */ var _selection_menu_ListModel_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selection/menu/ListModel.mjs */ "./src/selection/menu/ListModel.mjs");
/* harmony import */ var _Store_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Store.mjs */ "./src/menu/Store.mjs");




/**
 * @class Neo.menu.List
 * @extends Neo.list.Base
 */
class List extends _list_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.menu.List'
         * @protected
         */
        className: 'Neo.menu.List',
        /**
         * @member {String} ntype='menu-list'
         * @protected
         */
        ntype: 'menu-list',
        /**
         * Read only. We are storing the currently visible subMenu instance.
         * @member {Neo.menu.List|Neo.menu.Panel|null} activeSubMenu=null
         */
        activeSubMenu: null,
        /**
         * @member {String[]} baseCls=['neo-menu-list','neo-list']
         */
        baseCls: ['neo-menu-list', 'neo-list'],
        /**
         * setTimeout() id after a focus-leave event.
         * @member {Number|null} focusTimeoutId=null
         * @protected
         */
        focusTimeoutId: null,
        /**
         * Hides a floating list on leaf item click, in case it has a parentComponent
         * @member {Boolean} hideOnLeafItemClick=true
         */
        hideOnLeafItemClick: true,
        /**
         * Optionally pass menu.Store data directly
         * @member {Object[]|null} items_=null
         * @reactive
         */
        items_: null,
        /**
         * Internal flag.
         * Sub-menus will bubble focus changes to the top level.
         * @member {Boolean} menuFocus_=false
         * @protected
         * @reactive
         */
        menuFocus_: false,
        /**
         * Internal flag.
         * True for a top level menu, false for sub-menus.
         * @member {Boolean} isRoot=true
         * @protected
         */
        isRoot: true,
        /**
         * Storing the list item index of the parent menu in case it exists.
         * @member {Number} parentIndex=0
         * @protected
         */
        parentIndex: 0,
        /**
         * Storing a reference to the parent menu in case it exists.
         * @member {Neo.menu.List|Neo.menu.Panel|null} parentMenu=null
         * @protected
         */
        parentMenu: null,
        /**
         * Value for the list.Base selectionModel_ config
         * @member {Neo.selection.menu.ListModel} selectionModel=ListModel
         * @reactive
         */
        selectionModel: _selection_menu_ListModel_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
        /**
         * Value for the list.Base store_ config
         * @member {Neo.menu.Store} store=Store
         * @reactive
         */
        store: _Store_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
        /**
         * The distance in px between a menu and a child menu
         * See: https://github.com/neomjs/neo/issues/2569
         * @member {Number} subMenuGap=0
         */
        subMenuGap: 0,
        /**
         * Storing childMenus by record keyProperty
         * @member {Object} subMenuMap=null
         * @protected
         */
        subMenuMap: null,
        /**
         * We are applying a z-index style which is 1 number higher to each sub-menu
         * @member {Number} zIndex_=100
         * @reactive
         */
        zIndex_: 100,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {tag: 'ul', cn: []}
    }

    /**
     * If the menu is floating, it will anchor itself to the parentRect
     * @member {Neo.component.Base|null} parentComponent=null
     * @reactive
     */
    parentComponent = null

    /**
     * Triggered after the items config got changed
     * @param {Object[]} value
     * @param {Object[]} oldValue
     * @protected
     */
    afterSetItems(value, oldValue) {
        let {store} = this;

        oldValue && store.clear(); // we can not use remove() here, since items are no records => often no id
        value    && store.add(value)
    }

    /**
     * Triggered after the menuFocus config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMenuFocus(value, oldValue) {
        if (oldValue !== undefined) {
            let me = this;

            if (me.isRoot) {
                if (!value) {
                    me.focusTimeoutId = setTimeout(() => {
                        me[me.floating ? 'unmount' : 'hideSubMenu']()
                    }, 20)
                } else {
                    clearTimeout(me.focusTimeoutId);
                    me.focusTimeoutId = null
                }
            } else {
                // bubble the focus change upwards
                me.parentMenu.menuFocus = value
            }
        }
    }

    /**
     * Triggered after the theme config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetTheme(value, oldValue) {
        super.afterSetTheme(value, oldValue);

        Object.values(this.subMenuMap || {}).forEach(menu => {
            menu.theme = value
        })
    }

    /**
     * Triggered after the zIndex config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetZIndex(value, oldValue) {
        this.style = {...this.style, zIndex: value}
    }

    /**
     * Override this method for custom renderers
     * @param {Object} record
     * @param {Number} index
     * @returns {Object|Object[]|String} Either a config object to assign to the item, a vdom cn array or a html string
     */
    createItemContent(record, index) {
        let me        = this,
            {iconCls} = record,
            id        = me.store.getKey(record),
            vdomCn    = [{tag: 'span', cls: ['neo-content'], text: record[me.displayField]}];

        if (iconCls && iconCls !== '') {
            vdomCn.unshift({tag: 'i', cls: ['neo-menu-icon', 'neo-icon', iconCls], id: me.getIconId(id)})
        }

        if (me.hasChildren(record)) {
            vdomCn.push({tag: 'i', cls: ['neo-arrow-icon', 'neo-icon', 'fas fa-chevron-right'], id: me.getArrowIconId(id)})
        }

        return vdomCn
    }

    /**
     *
     */
    destroy(...args) {
        let me              = this,
            {activeSubMenu} = me,
            subMenuMap      = me.subMenuMap || {};

        activeSubMenu?.unmount();

        Object.entries(subMenuMap).forEach(([key, value]) => {
            value.destroy();
            subMenuMap[key] = null
        });

        super.destroy(...args)
    }

    /**
     * @param {Number|String} recordId
     * @returns {String}
     */
    getArrowIconId(recordId) {
        return `${this.id}__arrow_icon__${recordId}`
    }

    /**
     * @param {Number|String} recordId
     * @returns {String}
     */
    getIconId(recordId) {
        return `${this.id}__icon__${recordId}`
    }

    /**
     * recordIds can be Numbers, so we do need a prefix
     * @param {Number|String} recordId
     * @returns {String}
     */
    getMenuMapId(recordId) {
        return `menu__${recordId}`
    }

    /**
     * Checks if a record has items
     * @param {Object} record
     * @returns {Boolean}
     */
    hasChildren(record) {
        return Array.isArray(record.items) && record.items.length > 0
    }

    /**
     *
     */
    hideSubMenu() {
        let {activeSubMenu} = this;

        if (activeSubMenu) {
            activeSubMenu.unmount();
            this.activeSubMenu = null
        }
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.path
     */
    onFocusEnter(data) {
        super.onFocusEnter(data);
        this.menuFocus = true
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.oldPath
     */
    onFocusLeave(data) {
        super.onFocusLeave(data);

        let insideParent = false,
            parentId     = this.parentComponent?.id,
            item;

        if (parentId) {
            for (item of data.oldPath) {
                if (item.id === parentId) {
                    insideParent = true;
                    break
                }
            }
        }

        if (!insideParent) {
            this.menuFocus = false
        }
    }

    /**
     * @param {Object} node
     * @param {Object} data
     */
    onItemClick(node, data) {
        super.onItemClick(node, data);

        this.onKeyDownEnter(node.id)
    }

    /**
     * @param {String} nodeId
     */
    onKeyDownEnter(nodeId) {
        if (nodeId) {
            let me       = this,
                recordId = me.getItemRecordId(nodeId),
                record   = me.store.get(recordId),
                submenu;

            me.callback(record.handler, me, [record]);

            record.route && Neo.Main.setRoute({
                appName: me.appName,
                value  : record.route
            });

            me.hideOnLeafItemClick && !record.items && me.unmount();

            if (record.items) {
                submenu = me.subMenuMap?.[me.getMenuMapId(recordId)];

                if (submenu) {
                    me.toggleSubMenu(nodeId, record)
                }
            }
        }
    }

    /**
     * @param {Object} data
     */
    onKeyDownEscape(data) {
        this.floating && this.unmount()
    }

    /**
     * @param {String[]} items
     */
    onSelect(items) {
        let me       = this,
            nodeId   = items[0],
            recordId = me.getItemRecordId(nodeId),
            record   = me.store.get(recordId);

        if (me.activeSubMenu !== me.subMenuMap?.[me.getMenuMapId(recordId)]) {
            me.hideSubMenu();
            me.hasChildren(record) && me.showSubMenu(nodeId, record)
        }
    }

    /**
     * @param {String} nodeId
     * @param {Object} record
     */
    showSubMenu(nodeId, record) {
        const
            me           = this,
            {store}      = me,
            recordId     = store.getKey(record),
            subMenuMap   = me.subMenuMap || (me.subMenuMap = {}),
            subMenuMapId = me.getMenuMapId(recordId),
            subMenu      = subMenuMap[subMenuMapId] || (subMenuMap[subMenuMapId] = Neo.create({
                module         : List,
                align          : {
                    target       : nodeId,
                    edgeAlign    : 'l0-r0',
                    axisLock     : true,
                    targetMargin : me.subMenuGap
                },
                appName        : me.appName,
                displayField   : me.displayField,
                floating       : true,
                items          : record.items,
                isRoot         : false,
                parentComponent: me.parentComponent,
                parentId       : me.app.mainView.id,
                parentIndex    : store.indexOf(record),
                parentMenu     : me,
                theme          : me.theme,
                zIndex         : me.zIndex + 1
            }));

        if (me.activeSubMenu !== subMenu) {
            me.activeSubMenu = subMenu;
            subMenu.initVnode(true)
        }
    }

    /**
     * @param {String} nodeId
     * @param {Object} record
     */
    toggleSubMenu(nodeId, record) {
        let me       = this,
            recordId = me.store.getKey(record),
            submenu  = me.subMenuMap?.[me.getMenuMapId(recordId)];

        if (!submenu?.mounted) {
            me.showSubMenu(nodeId, record)
        } else {
            me.hideSubMenu()
        }
    }

    /**
     *
     */
    unmount() {
        this.selectionModel?.deselectAll(true); // silent update
        this.hideSubMenu();

        super.unmount()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(List));


/***/ },

/***/ "./src/menu/Model.mjs"
/*!****************************!*\
  !*** ./src/menu/Model.mjs ***!
  \****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_data_Model_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/data/Model.mjs */ "./src/data/Model.mjs");


/**
 * @class Neo.menu.Model
 * @extends Neo.data.Model
 */
class Model extends _src_data_Model_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.menu.Model'
         * @protected
         */
        className: 'Neo.menu.Model',
        /**
         * @member {String} keyProperty='id'
         * @reactive
         */
        keyProperty: 'id',
        /**
         * @member {Object[]} fields
         */
        fields: [{
            name: 'cls',
            type: 'Array'
        }, {
            name: 'handler',
            type: 'Function'
        }, {
            name: 'hidden',
            type: 'Boolean'
        }, {
            name: 'iconCls',
            type: 'String'
        }, {
            name: 'id',
            type: 'Integer'
        }, {
            name: 'items', // optional
            type: 'Array'
        }, {
            name: 'route',
            type: 'String'
        }, {
            name: 'text',
            type: 'String'
        }]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Model));


/***/ },

/***/ "./src/menu/Store.mjs"
/*!****************************!*\
  !*** ./src/menu/Store.mjs ***!
  \****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Model_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Model.mjs */ "./src/menu/Model.mjs");
/* harmony import */ var _src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../src/data/Store.mjs */ "./src/data/Store.mjs");



/**
 * @class Neo.menu.Store
 * @extends Neo.data.Store
 */
class Store extends _src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.menu.Store'
         * @protected
         */
        className: 'Neo.menu.Store',
        /**
         * @member {Neo.menu.Model} model=Model
         * @reactive
         */
        model: _Model_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Store));


/***/ },

/***/ "./src/selection/ListModel.mjs"
/*!*************************************!*\
  !*** ./src/selection/ListModel.mjs ***!
  \*************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Model_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Model.mjs */ "./src/selection/Model.mjs");


/**
 * @class Neo.selection.ListModel
 * @extends Neo.selection.Model
 */
class ListModel extends _Model_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.selection.ListModel'
         * @protected
         */
        className: 'Neo.selection.ListModel',
        /**
         * @member {String} ntype='selection-listmodel'
         * @protected
         */
        ntype: 'selection-listmodel'
    }

    /**
     * Placeholder method to get overridden by class extension list menu.ListModel
     * @param {Object} data
     */
    onKeyDownEscape(data) {}

    /**
     * Placeholder method to get overridden by class extension list menu.ListModel
     * @param {Object} data
     */
    onKeyDownDown(data) {}

    /**
     * Placeholder method to get overridden by class extension list menu.ListModel
     * @param {Object} data
     */
    onKeyDownEnter(data) {}

    /**
     * Placeholder method to get overridden by class extension list menu.ListModel
     * @param {Object} data
     */
    onKeyDownLeft(data) {}

    /**
     * Placeholder method to get overridden by class extension list menu.ListModel
     * @param {Object} data
     */
    onKeyDownRight(data) {}

    /**
     * Placeholder method to get overridden by class extension list menu.ListModel
     * @param {Object} data
     */
    onKeyDownUp(data) {}

    /**
     * @param {Object} data
     */
    onListClick({currentTarget}) {
        let {view} = this,
            id     = view.getItemRecordId(currentTarget),
            record = view.store.get(id);

        if (!view.disableSelection) {
            record && this.select(record)
        }
    }

    /**
     * @param {Object} data
     */
    onListNavigate(data) {
        let {view}  = this,
            {store} = view,
            record, recordId;

        if (data.activeItem) {
            recordId = view.getItemRecordId(data.activeItem);
            record   = store.get(recordId);
        }

        if (!record) {
            record = store.getAt(Math.min(data.activeIndex, store.getCount()))
        }

        data.record      = record;
        view._focusIndex = store.indexOf(record); // silent update, no need to refocus

        view.fire('itemNavigate', data)
    }

    /**
     * @param {Neo.component.Base} component
     */
    register(component) {
        super.register(component);

        let me         = this,
            {id, view} = me;

        view.addDomListeners([{
            click: me.onListClick,
            scope: me,

            // Should be `.${view.itemCls}:not(.neo-disabled,.neo-list-header)`
            // TODO parse delegate selectors
            delegate: path => {
                for (let i = 0, { length } = path; i < length; i++) {
                    const { cls } = path[i];

                    if (cls.includes(view.itemCls) && !cls.includes('neo-disabled') && !cls.includes('neo-list-header')) {
                        return i;
                    }
                }
            }
        }, {
            neonavigate : me.onListNavigate,
            scope       : me
        }]);

        view.keys?._keys.push(
            {fn: 'onKeyDownDown'   ,key: 'Down'   ,scope: id},
            {fn: 'onKeyDownEnter'  ,key: 'Enter'  ,scope: id},
            {fn: 'onKeyDownEscape' ,key: 'Escape' ,scope: id},
            {fn: 'onKeyDownLeft'   ,key: 'Left'   ,scope: id},
            {fn: 'onKeyDownRight'  ,key: 'Right'  ,scope: id},
            {fn: 'onKeyDownUp'     ,key: 'Up'     ,scope: id}
        )
    }

    /**
     * @param {Number} index
     */
    selectAt(index) {
        let {view} = this,
            record = view?.store.getAt(index),
            itemId = record && view.getItemId(view.getRecordId(record));

        itemId && this.select(itemId)
    }

    /**
     *
     */
    unregister() {
        let me         = this,
            {id, view} = me;

        view.keys?.removeKeys([
            {fn: 'onKeyDownDown'   ,key: 'Down'   ,scope: id},
            {fn: 'onKeyDownEnter'  ,key: 'Enter'  ,scope: id},
            {fn: 'onKeyDownEscape' ,key: 'Escape' ,scope: id},
            {fn: 'onKeyDownLeft'   ,key: 'Left'   ,scope: id},
            {fn: 'onKeyDownRight'  ,key: 'Right'  ,scope: id},
            {fn: 'onKeyDownUp'     ,key: 'Up'     ,scope: id}
        ]);

        super.unregister()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(ListModel));


/***/ },

/***/ "./src/selection/Model.mjs"
/*!*********************************!*\
  !*** ./src/selection/Model.mjs ***!
  \*********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");





/**
 * @class Neo.selection.Model
 * @extends Neo.core.Base
 * @mixes Neo.core.Observable
 */
class Model extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.selection.Model'
         * @protected
         */
        className: 'Neo.selection.Model',
        /**
         * @member {String} ntype='selection-model'
         * @protected
         */
        ntype: 'selection-model',
        /**
         * Placeholder for extended classes to add a custom css rule to this owner component
         * @member {String|null} cls=null
         * @protected
         */
        cls: null,
        /**
         * @member {Array} items_
         * @protected
         * @reactive
         */
        items_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_3__.isDescriptor]: true,
            clone         : 'shallow',
            cloneOnGet    : 'none',
            isEqual       : () => false,
            value         : []
        },
        /**
         * @member {String} selectedCls='selected'
         */
        selectedCls: 'neo-selected',
        /**
         * @member {Boolean} singleSelect=true
         */
        singleSelect: true,
        /**
         * Internally saves the view id, but the getter will return the matching instance
         * @member {Object} view_=null
         * @protected
         * @reactive
         */
        view_: null
    }

    /**
     * Gets triggered before getting the value of the view config
     * @param {String} value
     * @returns {Neo.component.Base}
     */
    beforeGetView(value) {
        return Neo.getComponent(this._view)
    }

    /**
     * Gets triggered before setting the value of the view config
     * @returns {String} the view id
     */
    beforeSetView(value) {
        return value && value.id
    }

    /**
     *
     */
    addDomListener() {}

    /**
     * @param {Object} item
     * @param {Boolean} [silent] true to prevent a vdom update
     * @param {Object[]|String[]} itemCollection=this.items
     * @param {String} [selectedCls]
     */
    deselect(item, silent, itemCollection=this.items, selectedCls) {
        let me     = this,
            {view} = me,
            node;

        // We hold vdom ids for now, so all incoming selections must be converted.
        item = item.isRecord ? view.getItemId(item) : Neo.isObject(item) ? item.id : item;

        if (itemCollection.includes(item)) {
            node = view.getVdomChild(item);

            if (node) {
                node.cls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(node.cls || [], selectedCls || me.selectedCls);
                delete node['aria-selected']
            }

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(itemCollection, item);

            if (!silent) {
                view.update();

                view.parent?.onDeselect?.(); // grid.Container & table.Container
                view.onDeselect?.();

                me.fire('selectionChange', {
                    selection: itemCollection
                })
            }
        } else if (!silent) {
            me.fire('noChange')
        }
    }

    /**
     * @param {Boolean} [silent] true to prevent a vdom update
     * @param {Object[]|String[]} itemCollection=this.items
     */
    deselectAll(silent, itemCollection=this.items) {
        let me     = this,
            items  = [...itemCollection],
            {view} = me;

        if (items.length) {
            items.forEach(item => {
                me.deselect(item, true)
            });

            if (!silent && items.length > 0) {
                view.update()
            }

            me.fire('selectionChange', {
                selection: this.items
            })
        } else if (!silent) {
            me.fire('noChange')
        }
    }

    /**
     *
     */
    destroy(...args) {
        this.unregister();
        super.destroy(...args)
    }

    /**
     * Important for mapping listeners to view controllers
     * @returns {Neo.controller.Component|null}
     */
    getController() {
        return this.view.getController()
    }

    /**
     * @returns {Array} this.items
     */
    getSelection() {
        return this.items
    }

    /**
     * @returns {Boolean}
     */
    hasSelection() {
        return this.items.length > 0
    }

    /**
     * @param {String} id
     * @returns {Boolean} true in case the item is selected
     */
    isSelected(id) {
        return this.items.includes(id)
    }

    /**
     * @param {Neo.component.Base} component
     */
    register(component) {
        let me  = this,
            cls = component.wrapperCls || [];

        if (me.cls && !cls.includes(me.cls)) {
            cls.push(me.cls);
            component.wrapperCls = cls
        }

        me.view = component;
        me.addDomListener();

        component.fire('selectionModelChange', {
            value: me
        })
    }

    /**
     *
     */
    removeDomListeners() {
        let me           = this,
            component    = me.view,
            domListeners = [...component.domListeners];

        component.domListeners.forEach(listener => {
            if (listener.scope === me) {
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(domListeners, listener)
            }
        });

        component.domListeners = domListeners
    }

    /**
     * @param {Object|Object[]|String[]} items
     * @param {Object[]|String[]} itemCollection=this.items
     * @param {String} [selectedCls]
     */
    select(items, itemCollection=this.items, selectedCls) {
        if (!Array.isArray(items)) {
            items = [items]
        }

        let me      = this,
            {view}  = me,
            records = items.map(item => {
                if (item.isRecord) return item;

                const recordId = view.getItemRecordId?.(item);

                return recordId && view.store?.get(recordId) || item
            });

        // We hold vdom ids for now, so all incoming selections must be converted.
        items = items.map(item => item.isRecord ? view.getItemId(item) : Neo.isObject(item) ? item.id : item);

        if (!Neo.isEqual(itemCollection, items)) {
            if (me.singleSelect && itemCollection === me.items) {
                me.deselectAll(true, itemCollection)
            }

            items.forEach(node => {
                node = view.getVdomChild(node);

                if (node) {
                    node.cls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(node.cls || [], selectedCls || me.selectedCls);
                    node['aria-selected'] = true
                }
            });

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(itemCollection, items);

            if (!view.silentSelect) {
                view.update()
            }

            view.parent?.onSelect?.(items); // grid.Container & table.Container
            view.onSelect?.(items);

            view.fire('select', {
                records,
                selection: itemCollection
            });

            me.fire('selectionChange', {
                records,
                selection: itemCollection
            })
        }
        else {
            me.fire('noChange')
        }
    }

    /**
     * @param {Object} item
     */
    toggleSelection(item) {
        let me = this;

        if (me.isSelected(item)) {
            me.deselect(item)
        } else {
            me.select(item)
        }
    }

    /**
     * @returns {Object}
     */
    toJSON() {
        const
            me    = this,
            items = (me.items || []).map(item => {
                if (Neo.isRecord(item)) {
                    return item.toJSON()
                }

                return item
            });

        return {
            ...super.toJSON(),
            items,
            selectedCls : me.selectedCls,
            singleSelect: me.singleSelect
        }
    }

    /**
     *
     */
    unregister() {
        let me     = this,
            {view} = me;

        if (!view.isDestroying) {
            let cls = view.wrapperCls || [];

            if (me.cls && cls.includes(me.cls)) {
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, me.cls);
                view.wrapperCls = cls
            }

            me.deselectAll();

            me.removeDomListeners()
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Model));


/***/ },

/***/ "./src/selection/menu/ListModel.mjs"
/*!******************************************!*\
  !*** ./src/selection/menu/ListModel.mjs ***!
  \******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ListModel_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ListModel.mjs */ "./src/selection/ListModel.mjs");


/**
 * @class Neo.selection.menu.ListModel
 * @extends Neo.selection.ListModel
 */
class ListModel extends _ListModel_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.selection.menu.ListModel'
         * @protected
         */
        className: 'Neo.selection.menu.ListModel',
        /**
         * @member {String} ntype='selection-menu-listmodel'
         * @protected
         */
        ntype: 'selection-menu-listmodel'
    }

    /**
     * @param {Object} data
     */
    onKeyDownEscape(data) {
        this.view.onKeyDownEscape(data)
    }

    /**
     * @param {Object} data
     */
    onKeyDownLeft(data) {
        let {view}       = this,
            {parentMenu} = view;

        if (parentMenu) {
            view.hideSubMenu();
            view.selectionModel.deselectAll();
            parentMenu.selectionModel.selectAt(view.parentIndex)
        }
    }

    /**
     * @param {Object} data
     */
    onKeyDownRight(data) {
        this.view.activeSubMenu?.selectionModel.selectAt(0)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(ListModel));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2NhbnZhcy92ZW5kb3JzLXNyY19tZW51X0xpc3RfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQThDO0FBQ0c7QUFDTTs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esb0JBQW9CLHNEQUFJO0FBQ3hCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpRUFBWTtBQUN6QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMERBQWE7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIs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QUVBLGlFQUFlLHlCQUF5QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9kYXRhL01vZGVsLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2RhdGEvUmVjb3JkRmFjdG9yeS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9kYXRhL1N0b3JlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2xpc3QvQmFzZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9tYW5hZ2VyL1N0b3JlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL21lbnUvTGlzdC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9tZW51L01vZGVsLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL21lbnUvU3RvcmUubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvc2VsZWN0aW9uL0xpc3RNb2RlbC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9zZWxlY3Rpb24vTW9kZWwubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvc2VsZWN0aW9uL21lbnUvTGlzdE1vZGVsLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZSAgICAgICAgICAgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQgUmVjb3JkRmFjdG9yeSAgZnJvbSAnLi9SZWNvcmRGYWN0b3J5Lm1qcyc7XG5pbXBvcnQge2lzRGVzY3JpcHRvcn0gZnJvbSAnLi4vY29yZS9Db25maWdTeW1ib2xzLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5kYXRhLk1vZGVsXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKlxuICogQHN1bW1hcnkgRGVmaW5lcyB0aGUgc2NoZW1hIGFuZCBkYXRhIHByb2Nlc3NpbmcgbG9naWMgZm9yIHJlY29yZHMgaW4gYSBTdG9yZS5cbiAqXG4gKiBNb2RlbHMgZGVmaW5lIHRoZSBgZmllbGRzYCBhcnJheSwgd2hpY2ggbWFwcyByYXcgZGF0YSBrZXlzIHRvIGNhbm9uaWNhbCBmaWVsZCBuYW1lcywgaGFuZGxlc1xuICogZGF0YSBjb252ZXJzaW9uLCBhbmQgZGVmaW5lcyBjb21wdXRlZCB2YWx1ZXMuXG4gKlxuICogIyMjIENhbGN1bGF0ZWQgRmllbGRzICYgRGVwZW5kZW5jaWVzXG4gKlxuICogRmllbGRzIGNhbiBkeW5hbWljYWxseSBjb21wdXRlIHRoZWlyIHZhbHVlcyB1c2luZyBhIGBjYWxjdWxhdGVgIGZ1bmN0aW9uLiBcbiAqIElmIGEgY2FsY3VsYXRlZCBmaWVsZCByZWxpZXMgb24gb3RoZXIgY2FsY3VsYXRlZCBmaWVsZHMsIHlvdSAqKk1VU1QqKiBkZWNsYXJlIHRoZW0gaW4gdGhlIGBkZXBlbmRzYCBhcnJheS5cbiAqXG4gKiBUaGlzIGlzIGNyaXRpY2FsIGZvciBwZXJmb3JtYW5jZSB3aGVuIHRoZSBTdG9yZSBvcGVyYXRlcyBpbiBcIlR1cmJvIE1vZGVcIiAoYGF1dG9Jbml0UmVjb3JkczogZmFsc2VgKS5cbiAqIEluIFR1cmJvIE1vZGUsIHRoZSBTdG9yZSBwZXJmb3JtcyBcIlNvZnQgSHlkcmF0aW9uXCIgb24gcmF3IEpTT04gb2JqZWN0cy4gRGVjbGFyaW5nIGBkZXBlbmRzYCBlbnN1cmVzXG4gKiB0aGUgU3RvcmUgcmVjdXJzaXZlbHkgcmVzb2x2ZXMgYW5kIGNhY2hlcyB0aGUgZGVwZW5kZW5jaWVzIGJlZm9yZSBleGVjdXRpbmcgeW91ciBjYWxjdWxhdGUgZnVuY3Rpb24sXG4gKiBwcmV2ZW50aW5nIG1hc3NpdmUgcGVyZm9ybWFuY2UgYm90dGxlbmVja3MgKGxpa2UgcmVkdW5kYW50IGFycmF5IHJlZHVjdGlvbnMpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBmaWVsZHM6IFt7XG4gKiAgICAgbmFtZTogJ3RvdGFsJyxcbiAqICAgICB0eXBlOiAnSW50ZWdlcicsXG4gKiAgICAgY2FsY3VsYXRlOiBkYXRhID0+IGRhdGEuYSArIGRhdGEuYlxuICogfSwge1xuICogICAgIG5hbWU6ICdyYXRpbycsXG4gKiAgICAgdHlwZTogJ0Zsb2F0JyxcbiAqICAgICBkZXBlbmRzOiBbJ3RvdGFsJ10sIC8vIENydWNpYWwgZm9yIFR1cmJvIE1vZGUgcGVyZm9ybWFuY2UhXG4gKiAgICAgY2FsY3VsYXRlOiBkYXRhID0+IGRhdGEudG90YWwgPT09IDAgPyAwIDogZGF0YS5hIC8gZGF0YS50b3RhbFxuICogfV1cbiAqL1xuY2xhc3MgTW9kZWwgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5kYXRhLk1vZGVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZGF0YS5Nb2RlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdtb2RlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdtb2RlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3RbXXxudWxsfSBmaWVsZHNfXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgZmllbGRzXzoge1xuICAgICAgICAgICAgW2lzRGVzY3JpcHRvcl06IHRydWUsXG4gICAgICAgICAgICBtZXJnZSAgICAgICAgIDogJ2RlZXBBcnJheXMnLFxuICAgICAgICAgICAgdmFsdWUgICAgICAgICA6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30ga2V5UHJvcGVydHlfPSdpZCdcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBrZXlQcm9wZXJ0eV86ICdpZCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gc3RvcmVJZD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHN0b3JlSWQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhpcyBjb25maWcgdG8gdHJ1ZSBpbiBjYXNlIHlvdSB3YW50IHRvIHRyYWNrIG1vZGlmaWVkIGZpZWxkcy5cbiAgICAgICAgICogQmUgYXdhcmUgdGhhdCB0aGlzIHdpbGwgZG91YmxlIHRoZSBhbW91bnQgb2YgZGF0YSBpbnNpZGUgZWFjaCByZWNvcmQsXG4gICAgICAgICAqIHNpbmNlIGVhY2ggZmllbGQgd2lsbCBnZXQgYW4gb3JpZ2luYWwgdmFsdWUgZmxhZy5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gdHJhY2tNb2RpZmllZEZpZWxkcz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdHJhY2tNb2RpZmllZEZpZWxkczogZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbGx5IHN0b3JpbmcgYWxsIGZpZWxkcywgd2hpY2ggaGF2ZSBhIGNhbGN1bGF0ZSBwcm9wZXJ0eVxuICAgICAqIEBtZW1iZXIge01hcH0gY2FsY3VsYXRlZEZpZWxkc01hcD1uZXcgTWFwKClcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY2FsY3VsYXRlZEZpZWxkc01hcCA9IG5ldyBNYXAoKVxuICAgIC8qKlxuICAgICAqIEludGVybmFsbHkgc3RvcmluZyBhbGwgZmllbGRzIGluc2lkZSBhIGZsYXQgbWFwID0+IG5lc3RlZCBmaWVsZHMgaW5jbHVkZWRcbiAgICAgKiBAbWVtYmVyIHtNYXB9IGZpZWxkc01hcD1uZXcgTWFwKClcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZmllbGRzTWFwID0gbmV3IE1hcCgpXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaGFzQ29tcGxleEZpZWxkcz1mYWxzZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBoYXNDb21wbGV4RmllbGRzID0gZmFsc2VcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBoYXNOZXN0ZWRGaWVsZHM9ZmFsc2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaGFzTmVzdGVkRmllbGRzID0gZmFsc2VcblxuICAgIC8qKlxuICAgICBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGZpZWxkcyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3RbXXxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEZpZWxkcyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgICAgICBtZS51cGRhdGVGaWVsZHNNYXAodmFsdWUpO1xuXG4gICAgICAgICAgICAvLyBGaWVsZHMgY2FuIGdldCBjaGFuZ2VkIG11bHRpcGxlIHRpbWVzIGJlZm9yZSB0aGUgbW9kZWwgaW5zdGFuY2UgaXMgZ2V0dGluZyBjb25zdHJ1Y3RlZC5cbiAgICAgICAgICAgIC8vIFdlIG9ubHkgbmVlZCB0aGUgbGF0ZXN0IHN0YXRlIGJlZm9yZSBjb25zdHJ1Y3Rpb24gJiBob25vciBydW4tdGltZSBjaGFuZ2VzLlxuICAgICAgICAgICAgaWYgKG1lLmlzQ29uc3RydWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBSZWNvcmRGYWN0b3J5LmNyZWF0ZVJlY29yZENsYXNzKG1lLCB0cnVlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZHMgYSBmaWVsZCBjb25maWcgYnkgYSBnaXZlbiBmaWVsZCBuYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9IFRoZSBmaWVsZCBjb25maWcgb2JqZWN0IG9yIG51bGwgaWYgbm8gbWF0Y2ggd2FzIGZvdW5kXG4gICAgICovXG4gICAgZ2V0RmllbGQobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZHNNYXAuZ2V0KG5hbWUpIHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyBhIGZpZWxkIHR5cGUgYnkgYSBnaXZlbiBmaWVsZCBuYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9IFRoZSBsb3dlcmNhc2UgZmllbGQgdHlwZSBvciBudWxsIGlmIG5vIG1hdGNoIHdhcyBmb3VuZFxuICAgICAqL1xuICAgIGdldEZpZWxkVHlwZShuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEZpZWxkKG5hbWUpPy50eXBlPy50b0xvd2VyQ2FzZSgpIHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIHRoZSBpbnN0YW5jZSBpbnRvIGEgSlNPTi1jb21wYXRpYmxlIG9iamVjdCBmb3IgdGhlIE5ldXJhbCBMaW5rLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcbiAgICAgICAgICAgIGZpZWxkcyAgICAgICAgICAgICA6IG1lLnNlcmlhbGl6ZUNvbmZpZyhtZS5maWVsZHMpLFxuICAgICAgICAgICAga2V5UHJvcGVydHkgICAgICAgIDogbWUua2V5UHJvcGVydHksXG4gICAgICAgICAgICBzdG9yZUlkICAgICAgICAgICAgOiBtZS5zdG9yZUlkLFxuICAgICAgICAgICAgdHJhY2tNb2RpZmllZEZpZWxkczogbWUudHJhY2tNb2RpZmllZEZpZWxkc1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZmllbGRzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpc1Jvb3Q9dHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoPScnXG4gICAgICovXG4gICAgdXBkYXRlRmllbGRzTWFwKGZpZWxkcywgaXNSb290PXRydWUsIHBhdGg9JycpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIHtjYWxjdWxhdGVkRmllbGRzTWFwLCBmaWVsZHNNYXB9ID0gbWUsXG4gICAgICAgICAgICBmaWVsZE5hbWU7XG5cbiAgICAgICAgaWYgKGlzUm9vdCkge1xuICAgICAgICAgICAgY2FsY3VsYXRlZEZpZWxkc01hcC5jbGVhcigpO1xuICAgICAgICAgICAgZmllbGRzTWFwLmNsZWFyKCk7XG4gICAgICAgICAgICBtZS5oYXNDb21wbGV4RmllbGRzID0gZmFsc2U7IC8vIFJlc2V0IGZsYWdcbiAgICAgICAgICAgIG1lLmhhc05lc3RlZEZpZWxkcyAgPSBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgZmllbGRzLmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgICAgICAgZmllbGROYW1lID0gcGF0aCArIGZpZWxkLm5hbWVcblxuICAgICAgICAgICAgaWYgKGZpZWxkLmZpZWxkcykge1xuICAgICAgICAgICAgICAgIG1lLmhhc05lc3RlZEZpZWxkcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgbWUudXBkYXRlRmllbGRzTWFwKGZpZWxkLmZpZWxkcywgZmFsc2UsIGZpZWxkLm5hbWUgKyAnLicpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpZWxkc01hcC5zZXQoZmllbGROYW1lLCBmaWVsZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZmllbGQuY2FsY3VsYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRGaWVsZHNNYXAuc2V0KGZpZWxkTmFtZSwgZmllbGQpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGNvbXBsZXggZmllbGRzIChTb2Z0IEh5ZHJhdGlvbiBPcHRpbWl6YXRpb24pXG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkLmNhbGN1bGF0ZSB8fCBmaWVsZC5jb252ZXJ0IHx8IGZpZWxkLm1hcHBpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuaGFzQ29tcGxleEZpZWxkcyA9IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhNb2RlbCk7XG4iLCJpbXBvcnQge2ludGVybmFsSWR9IGZyb20gJy4uL2NvcmUvQ29uZmlnU3ltYm9scy5tanMnO1xuaW1wb3J0IEJhc2UgICAgICAgICBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBNb2RlbCAgICAgICAgZnJvbSAnLi9Nb2RlbC5tanMnO1xuXG5jb25zdFxuICAgIGRhdGFTeW1ib2wgICAgICAgICA9IFN5bWJvbC5mb3IoJ2RhdGEnKSxcbiAgICBpbml0aWFsSW5kZXhTeW1ib2wgPSBTeW1ib2wuZm9yKCdpbml0aWFsSW5kZXgnKSxcbiAgICBpc01vZGlmaWVkU3ltYm9sICAgPSBTeW1ib2wuZm9yKCdpc01vZGlmaWVkJyksXG4gICAgb3JpZ2luYWxEYXRhU3ltYm9sID0gU3ltYm9sLmZvcignb3JpZ2luYWxEYXRhJyksXG4gICAgdmVyc2lvblN5bWJvbCAgICAgID0gU3ltYm9sLmZvcigndmVyc2lvbicpO1xuXG5sZXQgaW5zdGFuY2U7XG5cbi8qKlxuICogQGNsYXNzIE5lby5kYXRhLlJlY29yZEZhY3RvcnlcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqIEBzaW5nbGV0b25cbiAqL1xuY2xhc3MgUmVjb3JkRmFjdG9yeSBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmRhdGEuUmVjb3JkRmFjdG9yeSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmRhdGEuUmVjb3JkRmFjdG9yeScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHJlY29yZE5hbWVzcGFjZT0nTmVvLmRhdGEucmVjb3JkJ1xuICAgICAgICAgKi9cbiAgICAgICAgcmVjb3JkTmFtZXNwYWNlOiAnTmVvLmRhdGEucmVjb3JkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZXRvbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZXRvbjogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgbW9kZWwtYmFzZWQgZGVmYXVsdCB2YWx1ZXMgdG8gYSBkYXRhIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgIGRhdGFcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLk1vZGVsfSBtb2RlbFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgYXNzaWduRGVmYXVsdFZhbHVlcyhkYXRhLCBtb2RlbCkge1xuICAgICAgICBtb2RlbC5maWVsZHNNYXAuZm9yRWFjaCgoZmllbGQsIGZpZWxkTmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGZpZWxkLnZpcnR1YWwpIHJldHVybjtcblxuICAgICAgICAgICAgaWYgKGZpZWxkLm1hcHBpbmcgJiYgIU9iamVjdC5oYXNPd24oZGF0YSwgZmllbGROYW1lKSkge1xuICAgICAgICAgICAgICAgIGxldCBucyAgPSBmaWVsZC5tYXBwaW5nLnNwbGl0KCcuJyksXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IG5zLnBvcCgpLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U7XG5cbiAgICAgICAgICAgICAgICBpZiAobnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSBOZW8ubnMobnMsIGZhbHNlLCBkYXRhKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IGRhdGFcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlICYmIE9iamVjdC5oYXNPd24oc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbZmllbGROYW1lXSA9IHNvdXJjZVtrZXldXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihmaWVsZCwgJ2RlZmF1bHRWYWx1ZScpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gTmVvLmlzRnVuY3Rpb24oZmllbGQuZGVmYXVsdFZhbHVlKSA/IGZpZWxkLmRlZmF1bHRWYWx1ZSgpIDogZmllbGQuZGVmYXVsdFZhbHVlO1xuXG4gICAgICAgICAgICAgICAgLy8gV2UgY291bGQgYWx3YXlzIHVzZSBOZW8uYXNzaWduVG9OcygpID0+IHRoZSBjaGVjayBpcyBqdXN0IGZvciBpbXByb3ZpbmcgdGhlIHBlcmZvcm1hbmNlXG4gICAgICAgICAgICAgICAgaWYgKG1vZGVsLmhhc05lc3RlZEZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICBOZW8uYXNzaWduVG9OcyhmaWVsZE5hbWUsIGRlZmF1bHRWYWx1ZSwgZGF0YSwgZmFsc2UpXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhW2ZpZWxkTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2ZpZWxkTmFtZV0gPSBkZWZhdWx0VmFsdWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBkYXRhXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YS5maWVsZFxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuTW9kZWx9IGRhdGEubW9kZWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5wYXRoPScnXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEucHJvdG9cbiAgICAgKi9cbiAgICBjcmVhdGVGaWVsZCh7ZmllbGQsIG1vZGVsLCBwYXRoPScnLCBwcm90b30pIHtcbiAgICAgICAgbGV0IGZpZWxkTmFtZSA9IGZpZWxkLm5hbWUsXG4gICAgICAgICAgICBmaWVsZFBhdGggPSBwYXRoID09PSAnJyA/IGZpZWxkTmFtZSA6IGAke3BhdGh9LiR7ZmllbGROYW1lfWAsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzO1xuXG4gICAgICAgIGlmIChmaWVsZC5maWVsZHMpIHtcbiAgICAgICAgICAgIGZpZWxkLmZpZWxkcy5mb3JFYWNoKGNoaWxkRmllbGQgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlRmllbGQoe2ZpZWxkOiBjaGlsZEZpZWxkLCBtb2RlbCwgcGF0aDogZmllbGRQYXRoLCBwcm90b30pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZpZWxkLnZpcnR1YWwpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgICAgICAgICBbZmllbGRQYXRoXToge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZSAgOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZC5jYWxjdWxhdGUodGhpc1tkYXRhU3ltYm9sXSwgdGhpcylcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgW2ZpZWxkUGF0aF06IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGUgIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwuaGFzTmVzdGVkRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOZW8ubnMoZmllbGRQYXRoLCBmYWxzZSwgdGhpc1tkYXRhU3ltYm9sXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tkYXRhU3ltYm9sXVtmaWVsZE5hbWVdXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlDaGFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZHM6IHtbZmllbGRQYXRoXTogaW5zdGFuY2UucGFyc2VSZWNvcmRWYWx1ZSh7cmVjb3JkOiB0aGlzLCBmaWVsZCwgdmFsdWV9KX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvcmQ6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhwcm90bywgcHJvcGVydGllcylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuTW9kZWx9IG1vZGVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgY3JlYXRlUmVjb3JkKG1vZGVsLCBjb25maWcpIHtcbiAgICAgICAgbGV0IHJlY29yZENsYXNzID0gTmVvLm5zKGAke3RoaXMucmVjb3JkTmFtZXNwYWNlfS4ke21vZGVsLmNsYXNzTmFtZX0uJHttb2RlbC5pZH1gKTtcblxuICAgICAgICBpZiAoIXJlY29yZENsYXNzKSB7XG4gICAgICAgICAgICByZWNvcmRDbGFzcyA9IHRoaXMuY3JlYXRlUmVjb3JkQ2xhc3MobW9kZWwpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IHJlY29yZENsYXNzKGNvbmZpZylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLk1vZGVsfSBtb2RlbFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3ZlcndyaXRlPWZhbHNlXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBjcmVhdGVSZWNvcmRDbGFzcyhtb2RlbCwgb3ZlcndyaXRlPWZhbHNlKSB7XG4gICAgICAgIGlmIChtb2RlbCBpbnN0YW5jZW9mIE1vZGVsKSB7XG4gICAgICAgICAgICBsZXQgY2xhc3NOYW1lID0gYCR7dGhpcy5yZWNvcmROYW1lc3BhY2V9LiR7bW9kZWwuY2xhc3NOYW1lfS4ke21vZGVsLmlkfWAsXG4gICAgICAgICAgICAgICAgbnMgICAgICAgID0gTmVvLm5zKGNsYXNzTmFtZSksXG4gICAgICAgICAgICAgICAga2V5LCBuc0FycmF5LCBjbHM7XG5cbiAgICAgICAgICAgIGlmICghbnMgfHwgb3ZlcndyaXRlKSB7XG4gICAgICAgICAgICAgICAgbnNBcnJheSA9IGNsYXNzTmFtZS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgICAgIGtleSAgICAgPSBuc0FycmF5LnBvcCgpO1xuICAgICAgICAgICAgICAgIG5zICAgICAgPSBOZW8ubnMobnNBcnJheSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY2xzICAgICA9IG5zW2tleV0gPSBjbGFzcyBSZWNvcmQge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBkbyBub3Qgd2FudCB0byBtaW5pZnkgdGhlIGN0b3IgY2xhc3MgbmFtZSBpbiBkaXN0L3Byb2R1Y3Rpb25cbiAgICAgICAgICAgICAgICAgICAgc3RhdGljIG5hbWUgPSAnUmVjb3JkJztcblxuICAgICAgICAgICAgICAgICAgICBbZGF0YVN5bWJvbF0gICAgICAgICA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBbaW5pdGlhbEluZGV4U3ltYm9sXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIHRoZSByZWNvcmQuIEluY3JlbWVudHMgb24gZXZlcnkgbW9kaWZpY2F0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgKiBVc2VkIGZvciBjaGFuZ2UgdHJhY2tpbmcgYW5kIG9wdGltaXphdGlvbiAoZS5nLiBzaG9ydC1jaXJjdWl0aW5nIGdyaWQgcmVuZGVyaW5nKS5cbiAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBbdmVyc2lvblN5bWJvbF09MFxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgW3ZlcnNpb25TeW1ib2xdID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogVGhlIHN0YWJsZSwgZ2xvYmFsbHkgdW5pcXVlIGludGVybmFsIElEIGZvciB0aGlzIHJlY29yZCBpbnN0YW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBpbnRlcm5hbElkXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBbaW50ZXJuYWxJZF0gPSBOZW8uZ2V0SWQoJ3JlY29yZCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIGdldCBpc01vZGlmaWVkKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLnRyYWNrTW9kaWZpZWRGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIU5lby5pc0VxdWFsKG1lW2RhdGFTeW1ib2xdLCBtZVtvcmlnaW5hbERhdGFTeW1ib2xdKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVbaXNNb2RpZmllZFN5bWJvbF1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHZlcnNpb24gb2YgdGhlIHJlY29yZC5cbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGdldCB2ZXJzaW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbdmVyc2lvblN5bWJvbF1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKGNvbmZpZywgaW5pdGlhbEluZGV4U3ltYm9sKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lW2luaXRpYWxJbmRleFN5bWJvbF0gPSBjb25maWdbaW5pdGlhbEluZGV4U3ltYm9sXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgY29uZmlnW2luaXRpYWxJbmRleFN5bWJvbF1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnID0gaW5zdGFuY2UuYXNzaWduRGVmYXVsdFZhbHVlcyhjb25maWcsIG1vZGVsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLnRyYWNrTW9kaWZpZWRGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZVtvcmlnaW5hbERhdGFTeW1ib2xdID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUuc2V0T3JpZ2luYWwoY29uZmlnKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZVtpc01vZGlmaWVkU3ltYm9sXSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLnNldFNpbGVudChjb25maWcpIC8vIFdlIGRvIG5vdCB3YW50IHRvIGZpcmUgY2hhbmdlIGV2ZW50cyB3aGVuIGNvbnN0cnVjdGluZ1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGdldChmaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLmdldEZpZWxkKGZpZWxkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2ZpZWxkXVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOZW8ubnMoZmllbGQsIGZhbHNlLCB0aGlzW2RhdGFTeW1ib2xdKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tkYXRhU3ltYm9sXVtmaWVsZF1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmllbGROYW1lXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufG51bGx9IG51bGwgaW4gY2FzZSB0aGUgbW9kZWwgZG9lcyBub3QgdXNlIHRyYWNrTW9kaWZpZWRGaWVsZHMsIHRydWUgaW4gY2FzZSBhIGNoYW5nZSB3YXMgZm91bmRcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGlzTW9kaWZpZWRGaWVsZChmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC50cmFja01vZGlmaWVkRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGFTY29wZSwgb3JpZ2luYWxEYXRhU2NvcGU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwuaGFzTmVzdGVkRmllbGRzICYmIGZpZWxkTmFtZT8uaW5jbHVkZXMoJy4nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbnNBcnJheSA9IGZpZWxkTmFtZS5zcGxpdCgnLicpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkTmFtZSAgICAgICAgID0gbnNBcnJheS5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVNjb3BlICAgICAgICAgPSBOZW8ubnMobnNBcnJheSwgZmFsc2UsIG1lW2RhdGFTeW1ib2xdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxEYXRhU2NvcGUgPSBOZW8ubnMobnNBcnJheSwgZmFsc2UsIG1lW29yaWdpbmFsRGF0YVN5bWJvbF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVNjb3BlICAgICAgICAgPSBtZVtkYXRhU3ltYm9sXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxEYXRhU2NvcGUgPSBtZVtvcmlnaW5hbERhdGFTeW1ib2xdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGZpZWxkIGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIW1vZGVsLmdldEZpZWxkKGZpZWxkTmFtZSkgJiYgICAgICAgIC8vIENoZWNrIGZvciBsZWFmIGZpZWxkcyAoY291bGQgYmUgZXhjbHVkZWQgaW5zaWRlIHRoZSByZWFsIGRhdGEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFPYmplY3QuaGFzT3duKGRhdGFTY29wZSwgZmllbGROYW1lKSAvLyBDaGVjayB0aGUgZGF0YSB0cmVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RoZSByZWNvcmQgZG9lcyBub3QgY29udGFpbiB0aGUgZmllbGQnLCBmaWVsZE5hbWUsIG1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhTmVvLmlzRXF1YWwoZGF0YVNjb3BlW2ZpZWxkTmFtZV0sIG9yaWdpbmFsRGF0YVNjb3BlW2ZpZWxkTmFtZV0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogVGhlIHNpbmdsZSBzb3VyY2Ugb2YgdHJ1dGggZm9yIHJlY29yZCBmaWVsZCBjaGFuZ2VzLlxuICAgICAgICAgICAgICAgICAgICAgKiBFeGVjdXRlcyBpbnN0YW5jZS5zZXRSZWNvcmRGaWVsZHMoKSwgYW5kIGNhbiBnZXQgdXNlZCB2aWE6XG4gICAgICAgICAgICAgICAgICAgICAqIC0gTmVvLnV0aWwuRnVuY3Rpb246Y3JlYXRlU2VxdWVuY2UoKVxuICAgICAgICAgICAgICAgICAgICAgKiAtIE5lby51dGlsLkZ1bmN0aW9uOmludGVyY2VwdCgpLFxuICAgICAgICAgICAgICAgICAgICAgKiB0byBcImxpc3RlblwiIHRvIGZpZWxkIGNoYW5nZXNcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICBkYXRhLmZpZWxkc1xuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge05lby5kYXRhLk1vZGVsfSBkYXRhLm1vZGVsXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgIGRhdGEucmVjb3JkXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgIHNpbGVudD1mYWxzZVxuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgbm90aWZ5Q2hhbmdlKGRhdGEsIHNpbGVudD1mYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyYW0gPSB7Li4uZGF0YSwgc2lsZW50fVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2Uuc2V0UmVjb3JkRmllbGRzKHBhcmFtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIEJ1bGstdXBkYXRlIG11bHRpcGxlIHJlY29yZCBmaWVsZHMgYXQgb25jZVxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZmllbGRzXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICByZXNldChmaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0T3JpZ2luYWwoZmllbGRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KGZpZWxkcylcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBCdWxrLXVwZGF0ZSBtdWx0aXBsZSByZWNvcmQgZmllbGRzIGF0IG9uY2VcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGZpZWxkc1xuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgc2V0KGZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlDaGFuZ2Uoe2ZpZWxkcywgbW9kZWwsIHJlY29yZDogdGhpc30pXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogSWYgdGhlIG1vZGVsIHVzZXMgdHJhY2tNb2RpZmllZEZpZWxkcywgd2Ugd2lsbCBzdG9yZSB0aGUgb3JpZ2luYWwgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgKiBmb3IgdHJhY2tpbmcgdGhlIGRpcnR5IHN0YXRlIChjaGFuZ2VkIGZpZWxkcylcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGZpZWxkc1xuICAgICAgICAgICAgICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBzZXRPcmlnaW5hbChmaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnNldFJlY29yZEZpZWxkcyh7ZmllbGRzLCBtb2RlbCwgcmVjb3JkOiB0aGlzLCBzaWxlbnQ6IHRydWUsIHVzZU9yaWdpbmFsRGF0YTogdHJ1ZX0pXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogQnVsay11cGRhdGUgbXVsdGlwbGUgcmVjb3JkIGZpZWxkcyBhdCBvbmNlIHdpdGhvdXQgdHJpZ2dlcmluZyBhIGNoYW5nZSBldmVudFxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZmllbGRzXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBzZXRTaWxlbnQoZmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeUNoYW5nZSh7ZmllbGRzLCBtb2RlbCwgcmVjb3JkOiB0aGlzfSwgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBXaGVuIHVzaW5nIEpTT04uc3RyaW5naWZ5KHRoaXMpLCB3ZSB3YW50IHRvIGdldCB0aGUgcmF3IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHRvSlNPTigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJ1Y3R1cmVkQ2xvbmUodGhpc1tkYXRhU3ltYm9sXSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtb2RlbC5maWVsZHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmZpZWxkcy5mb3JFYWNoKGZpZWxkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmNyZWF0ZUZpZWxkKHtmaWVsZCwgbW9kZWwsIHByb3RvOiBjbHMucHJvdG90eXBlfSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xzLnByb3RvdHlwZSwgJ2lzUmVjb3JkJywge3ZhbHVlOiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNscywgJ2lzQ2xhc3MnLCB7dmFsdWU6IHRydWV9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBuc1trZXldXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuc1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgYSBnaXZlbiBvYmplY3QgaXMgYW4gaW5zdGFuY2Ugb2YgYSBjbGFzcyBjcmVhdGVkIGJ5IHRoaXMgZmFjdG9yeVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1JlY29yZChyZWNvcmQpIHtcbiAgICAgICAgcmV0dXJuIHJlY29yZD8uaXNSZWNvcmQgfHwgZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCBhZnRlciBjaGFuZ2luZyB0aGUgdmFsdWUgb2YgYSByZWNvcmQgZmllbGQuXG4gICAgICogRS5nLiBteVJlY29yZC5mb28gPSAnYmFyJztcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IG9wdHMuZmllbGRzIEVhY2ggZmllbGQgb2JqZWN0IGNvbnRhaW5zIHRoZSBrZXlzOiBuYW1lLCBvbGRWYWx1ZSwgdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLk1vZGVsfSBvcHRzLm1vZGVsIFRoZSBtb2RlbCBpbnN0YW5jZSBvZiB0aGUgY2hhbmdlZCByZWNvcmRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5yZWNvcmRcbiAgICAgKi9cbiAgICBvblJlY29yZENoYW5nZShvcHRzKSB7XG4gICAgICAgIE5lby5nZXQob3B0cy5tb2RlbC5zdG9yZUlkKT8ub25SZWNvcmRDaGFuZ2Uob3B0cylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gIGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gIGRhdGEucmVjb3JkXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICBkYXRhLmZpZWxkXG4gICAgICogQHBhcmFtIHsqfSAgICAgICBbZGF0YS52YWx1ZT1udWxsXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgW2RhdGEucmVjb3JkQ29uZmlnPW51bGxdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZGF0YS51c2VPcmlnaW5hbERhdGE9ZmFsc2VdXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgcGFyc2VSZWNvcmRWYWx1ZSh7cmVjb3JkLCBmaWVsZCwgdmFsdWU9bnVsbCwgcmVjb3JkQ29uZmlnPW51bGwsIHVzZU9yaWdpbmFsRGF0YT1mYWxzZX0pIHtcbiAgICAgICAgaWYgKGZpZWxkLmNhbGN1bGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkLmNhbGN1bGF0ZShyZWNvcmRbdXNlT3JpZ2luYWxEYXRhID8gb3JpZ2luYWxEYXRhU3ltYm9sIDogZGF0YVN5bWJvbF0sIGZpZWxkKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpZWxkLmNvbnZlcnQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZmllbGQuY29udmVydCh2YWx1ZSwgcmVjb3JkKVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGZpZWxkTmFtZSA9IGZpZWxkLm5hbWUsXG4gICAgICAgICAgICB7bWFwcGluZywgbWF4TGVuZ3RoLCBtaW5MZW5ndGgsIG51bGxhYmxlfSA9IGZpZWxkLFxuICAgICAgICAgICAgb2xkVmFsdWUgID0gcmVjb3JkQ29uZmlnPy5bZmllbGROYW1lXSB8fCByZWNvcmRbZmllbGROYW1lXSxcbiAgICAgICAgICAgIHR5cGUgICAgICA9IGZpZWxkLnR5cGU/LnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgLy8gb25seSB0cmlnZ2VyIG1hcHBpbmdzIGZvciBpbml0aWFsIHZhbHVlc1xuICAgICAgICAvLyBkeW5hbWljIGNoYW5nZXMgb2YgYSBmaWVsZCB3aWxsIG5vdCBwYXNzIHRoZSByZWNvcmRDb25maWdcbiAgICAgICAgaWYgKG1hcHBpbmcgJiYgcmVjb3JkQ29uZmlnKSB7XG4gICAgICAgICAgICBsZXQgbnMgID0gbWFwcGluZy5zcGxpdCgnLicpLFxuICAgICAgICAgICAgICAgIGtleSA9IG5zLnBvcCgpO1xuXG4gICAgICAgICAgICBucyAgICA9IE5lby5ucyhucywgdHJ1ZSwgcmVjb3JkQ29uZmlnKTtcbiAgICAgICAgICAgIHZhbHVlID0gbnNba2V5XVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oZmllbGQsICdtYXhMZW5ndGgnKSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlPy50b1N0cmluZygpLmxlbmd0aCA+IG1heExlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgU2V0dGluZyByZWNvcmQgZmllbGQ6ICR7ZmllbGROYW1lfSB2YWx1ZTogJHt2YWx1ZX0gY29uZmxpY3RzIHdpdGggbWF4TGVuZ3RoOiAke21heExlbmd0aH1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2xkVmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duKGZpZWxkLCAnbWluTGVuZ3RoJykpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZT8udG9TdHJpbmcoKS5sZW5ndGggPCBtaW5MZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFNldHRpbmcgcmVjb3JkIGZpZWxkOiAke2ZpZWxkTmFtZX0gdmFsdWU6ICR7dmFsdWV9IGNvbmZsaWN0cyB3aXRoIG1pbkxlbmd0aDogJHttaW5MZW5ndGh9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9sZFZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihmaWVsZCwgJ251bGxhYmxlJykpIHtcbiAgICAgICAgICAgIGlmIChudWxsYWJsZSA9PT0gZmFsc2UgJiYgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFNldHRpbmcgcmVjb3JkIGZpZWxkOiAke2ZpZWxkTmFtZX0gdmFsdWU6ICR7dmFsdWV9IGNvbmZsaWN0cyB3aXRoIG51bGxhYmxlOiAke251bGxhYmxlfWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBvbGRWYWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdkYXRlJyAmJiBOZW8udHlwZU9mKHZhbHVlKSAhPT0gJ0RhdGUnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUpXG4gICAgICAgIH1cblxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnZmxvYXQnICYmIHZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpXG4gICAgICAgIH1cblxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnaHRtbCcgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgKyAnJ1xuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSBpZiAoKHR5cGUgPT09ICdpbnQnIHx8IHR5cGUgPT09ICdpbnRlZ2VyJykgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VJbnQodmFsdWUpXG4gICAgICAgIH1cblxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSArICcnO1xuICAgICAgICAgICAgdmFsdWUgPSAgdmFsdWUucmVwbGFjZSgvKDwoW14+XSspPikvaWcsICcnKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgICAgIGRhdGEuZmllbGROYW1lXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5Nb2RlbH0gZGF0YS5tb2RlbFxuICAgICAqIEBwYXJhbSB7UmVjb3JkfSAgICAgICAgIGRhdGEucmVjb3JkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICAgZGF0YS51c2VPcmlnaW5hbERhdGE9ZmFsc2UgdHJ1ZSB3aWxsIGFwcGx5IGNoYW5nZXMgdG8gdGhlIG9yaWdpbmFsRGF0YSBzeW1ib2xcbiAgICAgKiBAcGFyYW0geyp9ICAgICAgICAgICAgICBkYXRhLnZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNldFJlY29yZERhdGEoe2ZpZWxkTmFtZSwgbW9kZWwsIHJlY29yZCwgdXNlT3JpZ2luYWxEYXRhPWZhbHNlLCB2YWx1ZX0pIHtcbiAgICAgICAgaWYgKHVzZU9yaWdpbmFsRGF0YSAmJiAhbW9kZWwudHJhY2tNb2RpZmllZEZpZWxkcykge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc2NvcGUgPSB1c2VPcmlnaW5hbERhdGEgPyBvcmlnaW5hbERhdGFTeW1ib2wgOiBkYXRhU3ltYm9sO1xuXG4gICAgICAgIGlmIChtb2RlbC5oYXNOZXN0ZWRGaWVsZHMgJiYgZmllbGROYW1lLmluY2x1ZGVzKCcuJykpIHtcbiAgICAgICAgICAgIGxldCBucywgbnNBcnJheTtcblxuICAgICAgICAgICAgbnNBcnJheSAgID0gZmllbGROYW1lLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICBmaWVsZE5hbWUgPSBuc0FycmF5LnBvcCgpO1xuICAgICAgICAgICAgbnMgICAgICAgID0gTmVvLm5zKG5zQXJyYXksIHRydWUsIHJlY29yZFtzY29wZV0pO1xuXG4gICAgICAgICAgICBuc1tmaWVsZE5hbWVdID0gdmFsdWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlY29yZFtzY29wZV1bZmllbGROYW1lXSA9IHZhbHVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gICAgICAgZGF0YS5jaGFuZ2VkRmllbGRzPVtdIEludGVybmFsIGZsYWdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICBkYXRhLmZpZWxkc1xuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuTW9kZWx9IGRhdGEubW9kZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICBkYXRhLnJlY29yZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgIGRhdGEuc2lsZW50PWZhbHNlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICAgZGF0YS51c2VPcmlnaW5hbERhdGE9ZmFsc2UgdHJ1ZSB3aWxsIGFwcGx5IGNoYW5nZXMgdG8gdGhlIG9yaWdpbmFsRGF0YSBzeW1ib2xcbiAgICAgKi9cbiAgICBzZXRSZWNvcmRGaWVsZHMoe2NoYW5nZWRGaWVsZHM9W10sIGZpZWxkcywgbW9kZWwsIHJlY29yZCwgc2lsZW50PWZhbHNlLCB1c2VPcmlnaW5hbERhdGE9ZmFsc2V9KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICB7Y2FsY3VsYXRlZEZpZWxkc01hcCwgZmllbGRzTWFwLCB0cmFja01vZGlmaWVkRmllbGRzfSA9IG1vZGVsLFxuICAgICAgICAgICAgZmllbGRFeGlzdHMsIGhhc0NoYW5nZWRGaWVsZHMsIG9sZFZhbHVlO1xuXG4gICAgICAgIGlmICghdHJhY2tNb2RpZmllZEZpZWxkcyAmJiB1c2VPcmlnaW5hbERhdGEpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmVudHJpZXMoZmllbGRzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGZpZWxkRXhpc3RzID0gZmllbGRzTWFwLmhhcyhrZXkpO1xuXG4gICAgICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KHZhbHVlKSAmJiAhZmllbGRFeGlzdHMpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZW50cmllcyh2YWx1ZSkuZm9yRWFjaCgoW2NoaWxkS2V5LCBjaGlsZFZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBtZS5zZXRSZWNvcmRGaWVsZHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlZEZpZWxkcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkczoge1tgJHtrZXl9LiR7Y2hpbGRLZXl9YF06IGNoaWxkVmFsdWV9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VPcmlnaW5hbERhdGFcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSBlbHNlIGlmIChmaWVsZEV4aXN0cykge1xuICAgICAgICAgICAgICAgIG9sZFZhbHVlID0gcmVjb3JkW2tleV07XG4gICAgICAgICAgICAgICAgdmFsdWUgICAgPSBtZS5wYXJzZVJlY29yZFZhbHVlKHtyZWNvcmQsIGZpZWxkOiBtb2RlbC5nZXRGaWVsZChrZXkpLCB2YWx1ZX0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFOZW8uaXNFcXVhbChvbGRWYWx1ZSwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnNldFJlY29yZERhdGEoe2ZpZWxkTmFtZToga2V5LCBtb2RlbCwgcmVjb3JkLCB1c2VPcmlnaW5hbERhdGEsIHZhbHVlfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0cmFja01vZGlmaWVkRmllbGRzICYmICF1c2VPcmlnaW5hbERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZFtpc01vZGlmaWVkU3ltYm9sXSA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWRGaWVsZHMucHVzaCh7bmFtZToga2V5LCBvbGRWYWx1ZSwgdmFsdWV9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaGFzQ2hhbmdlZEZpZWxkcyA9IE9iamVjdC5rZXlzKGNoYW5nZWRGaWVsZHMpLmxlbmd0aCA+IDA7XG5cbiAgICAgICAgaWYgKGhhc0NoYW5nZWRGaWVsZHMpIHtcbiAgICAgICAgICAgIHJlY29yZFt2ZXJzaW9uU3ltYm9sXSsrO1xuXG4gICAgICAgICAgICBjYWxjdWxhdGVkRmllbGRzTWFwLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUudmlydHVhbCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgb2xkVmFsdWUgPSByZWNvcmRba2V5XTtcbiAgICAgICAgICAgICAgICB2YWx1ZSAgICA9IG1lLnBhcnNlUmVjb3JkVmFsdWUoe3JlY29yZCwgZmllbGQ6IG1vZGVsLmdldEZpZWxkKGtleSksIHVzZU9yaWdpbmFsRGF0YX0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFOZW8uaXNFcXVhbChvbGRWYWx1ZSwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnNldFJlY29yZERhdGEoe2ZpZWxkTmFtZToga2V5LCBtb2RlbCwgcmVjb3JkLCB1c2VPcmlnaW5hbERhdGEsIHZhbHVlfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZEZpZWxkcy5wdXNoKHtuYW1lOiBrZXksIG9sZFZhbHVlLCB2YWx1ZX0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2lsZW50ICYmICF1c2VPcmlnaW5hbERhdGEgJiYgaGFzQ2hhbmdlZEZpZWxkcykge1xuICAgICAgICAgICAgbWUub25SZWNvcmRDaGFuZ2Uoe2ZpZWxkczogY2hhbmdlZEZpZWxkcywgbW9kZWwsIHJlY29yZH0pXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmluc3RhbmNlID0gTmVvLnNldHVwQ2xhc3MoUmVjb3JkRmFjdG9yeSk7XG5cbmV4cG9ydCBkZWZhdWx0IGluc3RhbmNlO1xuIiwiaW1wb3J0IHtpbnRlcm5hbElkfSAgICBmcm9tICcuLi9jb3JlL0NvbmZpZ1N5bWJvbHMubWpzJztcbmltcG9ydCBDbGFzc1N5c3RlbVV0aWwgZnJvbSAnLi4vdXRpbC9DbGFzc1N5c3RlbS5tanMnO1xuaW1wb3J0IENvbGxlY3Rpb24gICAgICBmcm9tICcuLi9jb2xsZWN0aW9uL0Jhc2UubWpzJztcbmltcG9ydCBNb2RlbCAgICAgICAgICAgZnJvbSAnLi9Nb2RlbC5tanMnO1xuaW1wb3J0IE9ic2VydmFibGUgICAgICBmcm9tICcuLi9jb3JlL09ic2VydmFibGUubWpzJztcbmltcG9ydCBSZWNvcmRGYWN0b3J5ICAgZnJvbSAnLi9SZWNvcmRGYWN0b3J5Lm1qcyc7XG5pbXBvcnQgU3RvcmVNYW5hZ2VyICAgIGZyb20gJy4uL21hbmFnZXIvU3RvcmUubWpzJztcblxuY29uc3QgaW5pdGlhbEluZGV4U3ltYm9sID0gU3ltYm9sLmZvcignaW5pdGlhbEluZGV4Jyk7XG5cbi8qKlxuICogQGNsYXNzIE5lby5kYXRhLlN0b3JlXG4gKiBAZXh0ZW5kcyBOZW8uY29sbGVjdGlvbi5CYXNlXG4gKiBAbWl4ZXMgTmVvLmNvcmUuT2JzZXJ2YWJsZVxuICpcbiAqIEBzdW1tYXJ5IEEgcG93ZXJmdWwsIG9ic2VydmFibGUgY29sbGVjdGlvbiB0aGF0IG1hbmFnZXMgYSBzZXQgb2YgZGF0YSByZWNvcmRzLlxuICpcbiAqIE5lby5kYXRhLlN0b3JlIGlzIHRoZSBjZW50cmFsIGRhdGEgbWFuYWdlbWVudCBjbGFzcyBpbiB0aGUgZnJhbWV3b3JrLiBJdCBoYW5kbGVzIHRoZSBsaWZlY3ljbGUgb2ZcbiAqIGRhdGEgcmVjb3JkcywgaW5jbHVkaW5nIGxvYWRpbmcsIGZpbHRlcmluZywgc29ydGluZywgYW5kIHN5bmNocm9uaXphdGlvbiB3aXRoIGJhY2tlbmQgQVBJcy5cbiAqXG4gKiAjIyMgUmVjb3JkIEluc3RhbnRpYXRpb24gU3RyYXRlZ2llczogRWFnZXIgdnMuIExhenkgKFwiVHVyYm8gTW9kZVwiKVxuICpcbiAqIFRoZSBTdG9yZSBzdXBwb3J0cyB0d28gZGlzdGluY3Qgc3RyYXRlZ2llcyBmb3IgaGFuZGxpbmcgcmVjb3JkIGNyZWF0aW9uLCBjb250cm9sbGVkIGJ5IHRoZSBgYXV0b0luaXRSZWNvcmRzYCBjb25maWdcbiAqICh3aGljaCBkZWZhdWx0cyB0byBgdHJ1ZWApIGFuZCB0aGUgYGluaXRgIHBhcmFtZXRlciBpbiBtZXRob2RzIGxpa2UgYGFkZCgpYCBhbmQgYGluc2VydCgpYC5cbiAqXG4gKiAqKjEuIEVhZ2VyIEluc3RhbnRpYXRpb24gKERlZmF1bHQ6IGBhdXRvSW5pdFJlY29yZHM6IHRydWVgKSoqXG4gKiAgICAtICoqQmVoYXZpb3IqKjogUmF3IGRhdGEgb2JqZWN0cyBhcmUgaW1tZWRpYXRlbHkgY29udmVydGVkIGludG8gYE5lby5kYXRhLk1vZGVsYCBpbnN0YW5jZXMuXG4gKiAgICAtICoqVXNlIENhc2UqKjogU3RhbmRhcmQgb3BlcmF0aW9ucywgYWRkaW5nIHNpbmdsZSBpdGVtcywgaW50ZXJhY3RpdmUgZWRpdHMuXG4gKiAgICAtICoqUHJvcyoqOiBSZXR1cm5zIHVzYWJsZSBSZWNvcmQgaW5zdGFuY2VzIGltbWVkaWF0ZWx5LiBIaWdoIERldmVsb3BlciBFeHBlcmllbmNlIChEWCkuXG4gKiAgICAtICoqQ29ucyoqOiBDYW4gYmUgc2xvdyBmb3IgbWFzc2l2ZSBkYXRhc2V0cyAoMTBrKyByZWNvcmRzKS5cbiAqXG4gKiAqKjIuIExhenkgSW5zdGFudGlhdGlvbiAoXCJUdXJibyBNb2RlXCIpKipcbiAqICAgIC0gKipCZWhhdmlvcioqOiBSYXcgZGF0YSBvYmplY3RzIGFyZSBzdG9yZWQgZGlyZWN0bHkuIGBOZW8uZGF0YS5Nb2RlbGAgaW5zdGFuY2VzIGFyZSBjcmVhdGVkXG4gKiAgICAgIFwianVzdC1pbi10aW1lXCIgb25seSB3aGVuIHRoZXkgYXJlIGFjY2Vzc2VkIHZpYSBgZ2V0KClgLCBgZ2V0QXQoKWAsIG9yIGl0ZXJhdGlvbi5cbiAqICAgIC0gKipVc2UgQ2FzZSoqOiBCdWxrIGxvYWRpbmcgbGFyZ2UgZGF0YXNldHMgKGUuZy4sIGdyaWRzLCBjaGFydHMgd2l0aCB0aG91c2FuZHMgb2YgcG9pbnRzKS5cbiAqICAgIC0gKipQcm9zKio6IE1hc3NpdmUgcGVyZm9ybWFuY2UgZ2FpbnMgZm9yIGluaXRpYWwgZGF0YSBsb2FkLiBFbmFibGVzIGludGVybmFsIFwiY2h1bmtpbmdcIiB0byBwcmV2ZW50IFVJIGZyZWV6ZXMuXG4gKiAgICAtICoqQ29ucyoqOiBgYWRkKClgIHJldHVybnMgYSBjb3VudCBpbnN0ZWFkIG9mIHJlY29yZHMuIFJlY29yZHMgYXJlIG5vdCBhdmFpbGFibGUgdW50aWwgYWNjZXNzZWQuXG4gKiAgICAtICoqSG93IHRvIGVuYWJsZSoqOlxuICogICAgICAtICoqR2xvYmFsKio6IFNldCBgYXV0b0luaXRSZWNvcmRzOiBmYWxzZWAgb24gdGhlIFN0b3JlIGNvbmZpZy5cbiAqICAgICAgLSAqKlBlci1jYWxsKio6IFBhc3MgYGZhbHNlYCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBhZGQoKWAgb3IgYGluc2VydCgpYC5cbiAqICAgICAgYGBgamF2YXNjcmlwdFxuICogICAgICAvLyBHbG9iYWwgc2V0dGluZ1xuICogICAgICBOZW8uY3JlYXRlKFN0b3JlLCB7XG4gKiAgICAgICAgICBhdXRvSW5pdFJlY29yZHM6IGZhbHNlLFxuICogICAgICAgICAgZGF0YTogaHVnZUFycmF5T2ZEYXRhXG4gKiAgICAgIH0pO1xuICpcbiAqICAgICAgLy8gUGVyLWNhbGwgb3ZlcnJpZGVcbiAqICAgICAgc3RvcmUuYWRkKGh1Z2VBcnJheU9mRGF0YSwgZmFsc2UpO1xuICogICAgICBgYGBcbiAqXG4gKiAjIyMgU29mdCBIeWRyYXRpb24gJiBGaWVsZCBEZXBlbmRlbmNpZXNcbiAqXG4gKiBXaGVuIG9wZXJhdGluZyBpbiBUdXJibyBNb2RlIChgYXV0b0luaXRSZWNvcmRzOiBmYWxzZWApLCB0aGUgU3RvcmUgc29ydHMgYW5kIGZpbHRlcnMgdXNpbmcgcmF3IEpTT04gb2JqZWN0cy5cbiAqIElmIGEgc29ydCBvciBmaWx0ZXIgb3BlcmF0aW9uIHJlcXVpcmVzIGEgY2FsY3VsYXRlZCBmaWVsZCB0aGF0IGlzbid0IHByZXNlbnQgb24gdGhlIHJhdyBvYmplY3QsIHRoZSBTdG9yZVxuICogcGVyZm9ybXMgKipTb2Z0IEh5ZHJhdGlvbioqIHZpYSBgcmVzb2x2ZUZpZWxkKClgLiBJdCBkeW5hbWljYWxseSBjYWxjdWxhdGVzIHRoZSBmaWVsZCB2YWx1ZSBhbmQgYXV0by1jYWNoZXNcbiAqIGl0IG9uIHRoZSByYXcgb2JqZWN0LlxuICpcbiAqIElmIGEgY2FsY3VsYXRlZCBmaWVsZCByZWxpZXMgb24gb3RoZXIgY2FsY3VsYXRlZCBmaWVsZHMsIHRoZSBNb2RlbCBkZWZpbml0aW9uIG11c3QgZGVjbGFyZSBhIGBkZXBlbmRzOiBbXWAgYXJyYXkuXG4gKiBUaGUgU3RvcmUgdXNlcyB0aGlzIGFycmF5IHRvIHJlY3Vyc2l2ZWx5IHJlc29sdmUgYW5kIGNhY2hlIGFsbCBkZXBlbmRlbmNpZXMgYmVmb3JlIGV4ZWN1dGluZyB0aGUgbWFpbiBjYWxjdWxhdGlvbixcbiAqIHByZXZlbnRpbmcgc2V2ZXJlIHBlcmZvcm1hbmNlIGJvdHRsZW5lY2tzIChsaWtlIHJlZHVuZGFudCBhcnJheSByZWR1Y3Rpb25zKS5cbiAqXG4gKiAjIyMgUHJvZ3Jlc3NpdmUgTG9hZGluZyAoU3RyZWFtaW5nKVxuICpcbiAqIFdoZW4gdXNpbmcgYSBgcHJveHlgIChlLmcuLCB7QGxpbmsgTmVvLmRhdGEucHJveHkuU3RyZWFtfSksIHRoZSBTdG9yZSBzdXBwb3J0cyAqKlByb2dyZXNzaXZlIExvYWRpbmcqKi5cbiAqIEluc3RlYWQgb2Ygd2FpdGluZyBmb3IgdGhlIGVudGlyZSBkYXRhc2V0IHRvIGxvYWQsIHRoZSBTdG9yZSB1cGRhdGVzIGl0c2VsZiBpbmNyZW1lbnRhbGx5IGFzIGNodW5rcyBvZiBkYXRhIGFycml2ZS5cbiAqXG4gKiAtICoqRXZlbnRzOioqIFRoZSBgbG9hZGAgZXZlbnQgZmlyZXMgbXVsdGlwbGUgdGltZXMgKG9uY2UgcGVyIGNodW5rKSB3aXRoIHRoZSBjdW11bGF0aXZlIGB0b3RhbGAuXG4gKiAtICoqVUkgSW50ZWdyYXRpb246KiogQ29tcG9uZW50cyBsaWtlIGBOZW8uZ3JpZC5Db250YWluZXJgIGxpc3RlbiB0byB0aGVzZSBldmVudHMgdG8gdXBkYXRlIHRoZWlyIHNjcm9sbGJhcnMgYW5kIHJlbmRlciByb3dzIGltbWVkaWF0ZWx5LlxuICovXG5jbGFzcyBTdG9yZSBleHRlbmRzIENvbGxlY3Rpb24ge1xuICAgIC8qKlxuICAgICAqIFRydWUgYXV0b21hdGljYWxseSBhcHBsaWVzIHRoZSBjb3JlLk9ic2VydmFibGUgbWl4aW5cbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBvYnNlcnZhYmxlPXRydWVcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIG9ic2VydmFibGUgPSB0cnVlXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5kYXRhLlN0b3JlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZGF0YS5TdG9yZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdzdG9yZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdzdG9yZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnN0ZWFkIG9mIHNldHRpbmcgYW4gdXJsLCB5b3UgY2FuIGRlZmluZSB0aGUgUlBDIEJFIEFQSSBtZXRob2RzLlxuICAgICAgICAgKiBJbiBjYXNlIHRoZSA0IG1ldGhvZHMgYXJlIHVzaW5nIHRoZSBzYW1lIHNlcnZpY2UgYW5kIHRoaXMgc2VydmljZSBpcyB1c2luZyB0aGUgQ1JVRCBiYXNlZCBmbi1uYW1lcyxcbiAgICAgICAgICogeW91IGNhbiBzd2l0Y2ggdG8gYSBzdHJpbmcgYmFzZWQgc2hvcnRjdXQuXG4gICAgICAgICAqIFRoZSBmb2xsb3dpbmcgMiBleGFtcGxlcyBhcmUgZXF1aXZhbGVudC5cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYXBpOiB7XG4gICAgICAgICAqICAgIGNyZWF0ZSA6ICdNeUFwcC5iYWNrZW5kLlVzZXJTZXJ2aWNlLmNyZWF0ZScsXG4gICAgICAgICAqICAgIGRlc3Ryb3k6ICdNeUFwcC5iYWNrZW5kLlVzZXJTZXJ2aWNlLmRlc3Ryb3knLFxuICAgICAgICAgKiAgICByZWFkICAgOiAnTXlBcHAuYmFja2VuZC5Vc2VyU2VydmljZS5yZWFkJyxcbiAgICAgICAgICogICAgdXBkYXRlIDogJ015QXBwLmJhY2tlbmQuVXNlclNlcnZpY2UudXBkYXRlJ1xuICAgICAgICAgKiB9XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGFwaTogJ015QXBwLmJhY2tlbmQuVXNlclNlcnZpY2UnXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxTdHJpbmd8bnVsbH0gYXBpXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXBpXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgdG8gYXV0b21hdGljYWxseSBjcmVhdGUgcmVjb3JkIGluc3RhbmNlcyB3aGVuIGFkZGluZyBpdGVtcy5cbiAgICAgICAgICogU2V0IHRvIGZhbHNlIHRvIGVuYWJsZSBcIlR1cmJvIE1vZGVcIiAoTGF6eSBJbnN0YW50aWF0aW9uKSBnbG9iYWxseSBmb3IgdGhpcyBzdG9yZS5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXV0b0luaXRSZWNvcmRzPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9Jbml0UmVjb3JkczogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGF1dG9Mb2FkPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBhdXRvTG9hZDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGN1cnJlbnRQYWdlXz0xXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgY3VycmVudFBhZ2VfOiAxLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl8bnVsbH0gZGF0YV89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGRhdGFfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGluaXRpYWwgY2h1bmsgc2l6ZSBmb3IgYWRkaW5nIGxhcmdlIGRhdGFzZXRzLiBTZXQgdG8gMCB0byBkaXNhYmxlIGNodW5raW5nLlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGluaXRpYWxDaHVua1NpemU9MFxuICAgICAgICAgKi9cbiAgICAgICAgaW5pdGlhbENodW5rU2l6ZTogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzR3JvdXBlZD1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgaXNHcm91cGVkOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzTG9hZGVkPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBpc0xvYWRlZDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc0xvYWRpbmc9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZGF0YS5Nb2RlbH0gbW9kZWxfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBtb2RlbF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2UgYSB2YWx1ZSBvZiAwIHRvIG5vdCBsaW1pdCB0aGUgcGFnZVNpemVcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBwYWdlU2l6ZV89MFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHBhZ2VTaXplXzogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxOZW8uZGF0YS5wcm94eS5CYXNlfG51bGx9IHByb3h5Xz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgcHJveHlfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSB0byBsZXQgdGhlIGJhY2tlbmQgaGFuZGxlIHRoZSBmaWx0ZXJpbmcuXG4gICAgICAgICAqIFVzZWZ1bCBmb3IgYnVmZmVyZWQgc3RvcmVzXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHJlbW90ZUZpbHRlcj1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3RlRmlsdGVyOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgdG8gbGV0IHRoZSBiYWNrZW5kIGhhbmRsZSB0aGUgc29ydGluZy5cbiAgICAgICAgICogVXNlZnVsIGZvciBidWZmZXJlZCBzdG9yZXNcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gcmVtb3RlU29ydD1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3RlU29ydDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgYSBwYXRoIHRvIHRoZSByb290IG9mIHlvdXIgZGF0YS5cbiAgICAgICAgICogSWYgdGhlIHJlc3BvbnNlUm9vdCBpcyAnZGF0YScgdGhpcyBpcyBvcHRpb25hbC5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSByZXNwb25zZVJvb3Q9J2RhdGEnXG4gICAgICAgICAqL1xuICAgICAgICByZXNwb25zZVJvb3Q6ICdkYXRhJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gdG90YWxDb3VudD0wXG4gICAgICAgICAqL1xuICAgICAgICB0b3RhbENvdW50OiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSB0byB0cmFjayBpbnRlcm5hbElkcyBpbiBhIHNlcGFyYXRlIG1hcCBmb3IgTygxKSBsb29rdXBcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gdHJhY2tJbnRlcm5hbElkPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIHRyYWNrSW50ZXJuYWxJZDogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVybCBmb3IgQWpheCByZXF1ZXN0c1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gdXJsPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHVybDogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICAgICAgY29uZmlnLml0ZW1GYWN0b3J5ID0gdGhpcy5hc3NpZ25JbnRlcm5hbElkLmJpbmQodGhpcyk7XG5cbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvLyB0b2RvXG4gICAgICAgIG1lLm9uKHtcbiAgICAgICAgICAgIG11dGF0ZTogbWUub25Db2xsZWN0aW9uTXV0YXRlLFxuICAgICAgICAgICAgc29ydCAgOiBtZS5vbkNvbGxlY3Rpb25Tb3J0LFxuICAgICAgICAgICAgc2NvcGUgOiBtZVxuICAgICAgICB9KTtcblxuICAgICAgICBTdG9yZU1hbmFnZXIucmVnaXN0ZXIobWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBTdG9yZU1hbmFnZXIudW5yZWdpc3Rlcih0aGlzKTtcblxuICAgICAgICBzdXBlci5kZXN0cm95KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZGVudGl0eSBQcm92aWRlciBIb29rLlxuICAgICAqIEFzc2lnbnMgYSBzdGFibGUsIGdsb2JhbGx5IHVuaXF1ZSAnaW50ZXJuYWxJZCcgdG8gaXRlbXMgKFJlY29yZHMgb3IgUmF3IE9iamVjdHMpLlxuICAgICAqIFRoaXMgZW5zdXJlcyBET00gc3RhYmlsaXR5IGFuZCBzZWN1cml0eSBieSBkZWNvdXBsaW5nIHRoZSBET00gSUQgZnJvbSB0aGUgZGF0YSBJRC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuICAgICAqL1xuICAgIGFzc2lnbkludGVybmFsSWQoaXRlbSkge1xuICAgICAgICBpZiAoIWl0ZW1baW50ZXJuYWxJZF0pIHtcbiAgICAgICAgICAgIGl0ZW1baW50ZXJuYWxJZF0gPSBOZW8uZ2V0SWQoJ3JlY29yZCcpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBYm9ydHMgdGhlIGN1cnJlbnQgcHJveHkgb3BlcmF0aW9uIGlmIHRoZSBwcm94eSBzdXBwb3J0cyBpdC5cbiAgICAgKi9cbiAgICBhYm9ydCgpIHtcbiAgICAgICAgdGhpcy5wcm94eT8uYWJvcnQ/LigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGNvbGxlY3Rpb24uQmFzZTogYWRkKCkgdG8gY29udmVydCBpdGVtcyBpbnRvIHJlY29yZHMgaWYgbmVlZGVkLlxuICAgICAqXG4gICAgICogKioxLiBFYWdlciBNb2RlIChgaW5pdD10cnVlYCAtIERlZmF1bHQpOioqXG4gICAgICogSW1tZWRpYXRlbHkgY29udmVydHMgcmF3IGRhdGEgaW50byBgTmVvLmRhdGEuTW9kZWxgIGluc3RhbmNlcy5cbiAgICAgKiBSZXR1cm5zIGFuIGBBcnJheWAgb2YgdGhlIGNyZWF0ZWQgcmVjb3Jkcy5cbiAgICAgKlxuICAgICAqICoqMi4gTGF6eSBNb2RlIChgaW5pdD1mYWxzZWApOioqXG4gICAgICogQWRkcyByYXcgZGF0YSBkaXJlY3RseSBmb3IgbWF4aW11bSBwZXJmb3JtYW5jZS4gSW5zdGFudGlhdGVzIHJlY29yZHMgb25seSBvbiBhY2Nlc3MuXG4gICAgICpcbiAgICAgKiAtICoqQ2h1bmtpbmcgQWN0aXZlKio6IElmIGBpbml0aWFsQ2h1bmtTaXplID4gMGAgYW5kIGBpdGVtcy5sZW5ndGggPiB0aHJlc2hvbGRgOlxuICAgICAqICAgQWRkcyBpdGVtcyBpbiBjaHVua3MgdG8gcHJldmVudCBibG9ja2luZyB0aGUgQXBwIFdvcmtlciAoTWFpbiBBY3RvcikuXG4gICAgICogICBSZXR1cm5zIHRoZSBuZXcgY29sbGVjdGlvbiBgY291bnRgIChOdW1iZXIpLlxuICAgICAqXG4gICAgICogLSAqKk5vIENodW5raW5nKio6IElmIGBpbml0aWFsQ2h1bmtTaXplID09PSAwYCBvciBgaXRlbXMubGVuZ3RoIDw9IHRocmVzaG9sZGA6XG4gICAgICogICBBZGRzIHJhdyBpdGVtcyBkaXJlY3RseS5cbiAgICAgKiAgIFJldHVybnMgYW4gYEFycmF5YCBvZiB0aGUgYWRkZWQgcmF3IGRhdGEgb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gMS4gRGVmYXVsdDogR2V0IHJlY29yZHMgaW1tZWRpYXRlbHlcbiAgICAgKiBjb25zdCBbbmV3UmVjb3JkXSA9IHN0b3JlLmFkZCh7bmFtZTogJ05ldyBJdGVtJ30pO1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyAyLiBUdXJibyBNb2RlIChObyBDaHVua2luZyk6IEdldCByYXcgb2JqZWN0c1xuICAgICAqIGNvbnN0IFtyYXdPYmplY3RdID0gc3RvcmUuYWRkKHtuYW1lOiAnSXRlbSd9LCBmYWxzZSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIDMuIFR1cmJvIE1vZGUgKENodW5raW5nKTogR2V0IG5ldyBjb3VudFxuICAgICAqIHN0b3JlLmluaXRpYWxDaHVua1NpemUgPSAxMDAwO1xuICAgICAqIGNvbnN0IG5ld0NvdW50ID0gc3RvcmUuYWRkKGh1Z2VEYXRhQXJyYXksIGZhbHNlKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBpdGVtIFRoZSBpdGVtKHMpIHRvIGFkZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2luaXQ9dGhpcy5hdXRvSW5pdFJlY29yZHNdIFRydWUgdG8gcmV0dXJuIHRoZSBjcmVhdGVkIHJlY29yZHMsIGZhbHNlIGZvciBcIlR1cmJvIE1vZGVcIlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8T2JqZWN0W118TmVvLmRhdGEuTW9kZWxbXX0gVGhlIGNvbGxlY3Rpb24gY291bnQsIHJhdyBpdGVtcywgb3IgY3JlYXRlZCByZWNvcmRzXG4gICAgICovXG4gICAgYWRkKGl0ZW0sIGluaXQ9dGhpcy5hdXRvSW5pdFJlY29yZHMpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtcyAgICAgPSBBcnJheS5pc0FycmF5KGl0ZW0pID8gaXRlbSA6IFtpdGVtXSxcbiAgICAgICAgICAgIHRocmVzaG9sZCA9IG1lLmluaXRpYWxDaHVua1NpemU7XG5cbiAgICAgICAgaWYgKGluaXQpIHtcbiAgICAgICAgICAgIHN1cGVyLmFkZChpdGVtcyk7XG5cbiAgICAgICAgICAgIG1lLmlzTG9hZGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgcmV0dXJuIGl0ZW1zLm1hcChpID0+IG1lLmdldChtZS5nZXRLZXkoaSkpKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRocmVzaG9sZCA+IDAgJiYgaXRlbXMubGVuZ3RoID4gdGhyZXNob2xkKSB7XG4gICAgICAgICAgICBjb25zdCB0b3RhbCA9IG1lLmNvdW50ICsgaXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgY2h1bmsgPSBpdGVtcy5zcGxpY2UoMCwgdGhyZXNob2xkKTtcblxuICAgICAgICAgICAgbWUuY2h1bmtpbmdUb3RhbCA9IHRvdGFsO1xuXG4gICAgICAgICAgICAvLyAxLiBBZGQgdGhlIGZpcnN0IGNodW5rLiBUaGlzIGZpcmVzICdtdXRhdGUnIC0+ICdsb2FkJyAodmlhIG9uQ29sbGVjdGlvbk11dGF0ZSlcbiAgICAgICAgICAgIC8vICAgIGFuZCB0cmlnZ2VycyB0aGUgaW5pdGlhbCBncmlkIHJlbmRlci4gVGhlICdsb2FkJyBldmVudCB3aWxsIGNvbnRhaW4gdGhlIGZpbmFsIHRvdGFsIGNvdW50LlxuICAgICAgICAgICAgc3VwZXIuYWRkKGNodW5rKTsgLy8gUGFzcyByYXcgY2h1bmsgZGlyZWN0bHlcblxuICAgICAgICAgICAgLy8gMi4gU3VzcGVuZCBldmVudHMgdG8gcHJldmVudCB0aGUgbmV4dCAnYWRkJyBmcm9tIGZpcmluZyAnbG9hZCcuXG4gICAgICAgICAgICBtZS5zdXNwZW5kRXZlbnRzID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gMy4gQWRkIHRoZSByZXN0IG9mIHRoZSBpdGVtcyBzaWxlbnRseS5cbiAgICAgICAgICAgIHN1cGVyLmFkZChpdGVtcyk7IC8vIFBhc3MgcmF3IGl0ZW1zIGRpcmVjdGx5XG5cbiAgICAgICAgICAgIC8vIDQuIFJlc3VtZSBldmVudHMuXG4gICAgICAgICAgICBtZS5zdXNwZW5kRXZlbnRzID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIDUuIE1hbnVhbGx5IGZpcmUgYSBmaW5hbCAnbG9hZCcgZXZlbnQgdG8gdXBkYXRlIHRoZSBncmlkJ3Mgc2Nyb2xsYmFyIGFuZCBub3RpZnkgb3RoZXIgbGlzdGVuZXJzLlxuICAgICAgICAgICAgbWUuZmlyZSgnbG9hZCcsIHtpdGVtczogbWUuaXRlbXMsIHBvc3RDaHVua0xvYWQ6IHRydWUsIHRvdGFsOiBtZS5jaHVua2luZ1RvdGFsfSk7XG5cbiAgICAgICAgICAgIGRlbGV0ZSBtZS5jaHVua2luZ1RvdGFsO1xuXG4gICAgICAgICAgICByZXR1cm4gbWUuY291bnRcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJldHVyblZhbHVlID0gc3VwZXIuYWRkKGl0ZW1zKTtcblxuICAgICAgICAvLyBJZiB3ZSB1c2UgYWRkKCkgaW5pdGlhbGx5IGluc3RlYWQgb2Ygc2V0dGluZyBgZGF0YWAsIHdlIG5lZWQgdG8gc2V0IHRoZSBsb2FkZWQgZmxhZyBoZXJlLlxuICAgICAgICBtZS5pc0xvYWRlZCA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlIC8vIFBhc3MgcmF3IGl0ZW0gZGlyZWN0bHlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGN1cnJlbnRQYWdlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEN1cnJlbnRQYWdlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZSAmJiB0aGlzLmxvYWQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEBwYXJhbSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldERhdGEodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmNvbmZpZ3NBcHBsaWVkKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuY2xlYXIoKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1lLmlzTG9hZGluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgbWUuYWRkKHZhbHVlLCBtZS5hdXRvSW5pdFJlY29yZHMpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RmlsdGVycyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRGaWx0ZXJzKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5fY3VycmVudFBhZ2UgPSAxOyAvLyBzaWxlbnQgdXBkYXRlXG5cbiAgICAgICAgb2xkVmFsdWUgJiYgbWUucmVtb3RlRmlsdGVyICYmIG1lLmxvYWQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEBwYXJhbSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vZGVsKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlLnN0b3JlSWQgPSB0aGlzLmlkXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHBhZ2VTaXplIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFBhZ2VTaXplKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRQYWdlID0gMTsgLy8gc2lsZW50IHVwZGF0ZVxuICAgICAgICAgICAgdGhpcy5sb2FkKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTb3J0ZXJzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldFNvcnRlcnModmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLl9jdXJyZW50UGFnZSA9IDE7IC8vIHNpbGVudCB1cGRhdGVcblxuICAgICAgICBvbGRWYWx1ZSAmJiBtZS5yZW1vdGVTb3J0ICYmIG1lLmxvYWQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgYmVmb3JlU2V0QXBpKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAoTmVvLnR5cGVPZih2YWx1ZSkgPT09ICdTdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHtcbiAgICAgICAgICAgICAgICBjcmVhdGUgOiB2YWx1ZSArICcuY3JlYXRlJyxcbiAgICAgICAgICAgICAgICBkZXN0cm95OiB2YWx1ZSArICcuZGVzdHJveScsXG4gICAgICAgICAgICAgICAgcmVhZCAgIDogdmFsdWUgKyAnLnJlYWQnLFxuICAgICAgICAgICAgICAgIHVwZGF0ZSA6IHZhbHVlICsgJy51cGRhdGUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdHxOZW8uZGF0YS5wcm94eS5CYXNlfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fE5lby5kYXRhLnByb3h5LkJhc2V9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm5zIHtOZW8uZGF0YS5wcm94eS5CYXNlfVxuICAgICAqL1xuICAgIGJlZm9yZVNldFByb3h5KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgIG9sZFZhbHVlLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBDbGFzc1N5c3RlbVV0aWwuYmVmb3JlU2V0SW5zdGFuY2UodmFsdWUsIG51bGwsIHtcbiAgICAgICAgICAgIHN0b3JlOiB0aGlzXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W118TmVvLmRhdGEuTW9kZWxbXX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfE5lby5kYXRhLk1vZGVsW119IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3RbXXxOZW8uZGF0YS5Nb2RlbFtdfVxuICAgICAqL1xuICAgIGJlZm9yZVNldERhdGEodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cblxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5Nb2RlbHxPYmplY3R9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5Nb2RlbHxPYmplY3R9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm5zIHtOZW8uZGF0YS5Nb2RlbH1cbiAgICAgKi9cbiAgICBiZWZvcmVTZXRNb2RlbCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWU/LmRlc3Ryb3koKTtcblxuICAgICAgICByZXR1cm4gQ2xhc3NTeXN0ZW1VdGlsLmJlZm9yZVNldEluc3RhbmNlKHZhbHVlLCBNb2RlbClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgY29sbGVjdGlvbi5CYXNlIHRvIHByZXZlbnQgdGhlIGFsbEl0ZW1zIGNvbGxlY3Rpb24gZnJvbSBhdXRvLWxvYWRpbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHJldHVybnMge05lby5jb2xsZWN0aW9uLkJhc2V9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNyZWF0ZUFsbEl0ZW1zKGNvbmZpZykge1xuICAgICAgICBjb25maWcuYXV0b0xvYWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmNyZWF0ZUFsbEl0ZW1zKGNvbmZpZylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBvYmplY3Qgb3IgYXJyYXkgb2Ygb2JqZWN0cyBpbnRvIHJlY29yZHNcbiAgICAgKiBAcGFyYW0ge09iamVjdHxPYmplY3RbXX0gY29uZmlnXG4gICAgICogQHJldHVybnMge09iamVjdHxPYmplY3RbXX0gQXJyYXkgaW4gY2FzZSBhbiBhcnJheSB3YXMgcGFzc2VkXG4gICAgICovXG4gICAgY3JlYXRlUmVjb3JkKGNvbmZpZykge1xuICAgICAgICBsZXQgaXNBcnJheSA9IHRydWU7XG5cbiAgICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICBpc0FycmF5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29uZmlnICA9IFtjb25maWddXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBtZSAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGkgICA9IDAsXG4gICAgICAgICAgICAgICAgbGVuID0gY29uZmlnLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpdGVtO1xuXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IGNvbmZpZ1tpXVxuXG4gICAgICAgICAgICAgICAgaWYgKCFSZWNvcmRGYWN0b3J5LmlzUmVjb3JkKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ1tpXSA9IFJlY29yZEZhY3RvcnkuY3JlYXRlUmVjb3JkKG1lLm1vZGVsLCBpdGVtKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpc0FycmF5ID8gY29uZmlnIDogY29uZmlnWzBdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGNvbGxlY3Rpb24uQmFzZTpmaW5kKCkgdG8gZW5zdXJlIHRoZSByZXR1cm5lZCBpdGVtKHMpIGFyZSBSZWNvcmQgaW5zdGFuY2VzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IFt2YWx1ZV0gT25seSByZXF1aXJlZCBpbiBjYXNlIHRoZSBmaXJzdCBwYXJhbSBpcyBhIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmV0dXJuRmlyc3RNYXRjaD1mYWxzZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8T2JqZWN0W118bnVsbH1cbiAgICAgKi9cbiAgICBmaW5kKHByb3BlcnR5LCB2YWx1ZSwgcmV0dXJuRmlyc3RNYXRjaD1mYWxzZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBlci5maW5kKHByb3BlcnR5LCB2YWx1ZSwgcmV0dXJuRmlyc3RNYXRjaCk7XG5cbiAgICAgICAgaWYgKHJldHVybkZpcnN0TWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgPyB0aGlzLmdldCh0aGlzLmdldEtleShyZXN1bHQpKSA6IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0Lm1hcChpdGVtID0+IHRoaXMuZ2V0KHRoaXMuZ2V0S2V5KGl0ZW0pKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgY29sbGVjdGlvbi5CYXNlOmZpbmRCeSgpIHRvIGVuc3VyZSB0aGUgcmV0dXJuZWQgaXRlbShzKSBhcmUgUmVjb3JkIGluc3RhbmNlcy5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gcnVuIGZvciBlYWNoIGl0ZW0gaW5zaWRlIHRoZSBzdGFydC1lbmQgcmFuZ2UuIFJldHVybiB0cnVlIGZvciBhIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZT10aGlzIFRoZSBzY29wZSBpbiB3aGljaCB0aGUgcGFzc2VkIGZ1bmN0aW9uIGdldHMgZXhlY3V0ZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQ9MCBUaGUgc3RhcnQgaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZW5kPXRoaXMuY291bnQgVGhlIGVuZCBpbmRleCAodXAgdG8sIGxhc3QgdmFsdWUgZXhjbHVkZWQpXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIGZpbmRCeShmbiwgc2NvcGU9dGhpcywgc3RhcnQ9MCwgZW5kPXRoaXMuY291bnQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc3VwZXIuZmluZEJ5KGZuLCBzY29wZSwgc3RhcnQsIGVuZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQubWFwKGl0ZW0gPT4gdGhpcy5nZXQodGhpcy5nZXRLZXkoaXRlbSkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgY29sbGVjdGlvbi5CYXNlOmZvckVhY2goKSB0byBlbnN1cmUgdGhlIGl0ZXJhdGVkIGl0ZW0gaXMgYSBSZWNvcmQgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgZm9yIGVhY2ggcmVjb3JkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdIFZhbHVlIHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgYGZuYC5cbiAgICAgKi9cbiAgICBmb3JFYWNoKGZuLCBzY29wZSkge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWUuY291bnQ7IGkrKykge1xuICAgICAgICAgICAgZm4uY2FsbChzY29wZSB8fCBtZSwgbWUuZ2V0QXQoaSksIGksIG1lLml0ZW1zKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBjb2xsZWN0aW9uLkJhc2U6Z2V0KCkgdG8gZW5zdXJlIHRoZSByZXR1cm5lZCBpdGVtIGlzIGEgUmVjb3JkIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30ga2V5XG4gICAgICogQHJldHVybnMge09iamVjdHxudWxsfVxuICAgICAqL1xuICAgIGdldChrZXkpIHtcbiAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbSA9IHN1cGVyLmdldChrZXkpOyAvLyBHZXQgaXRlbSBmcm9tIENvbGxlY3Rpb24uQmFzZSAoY291bGQgYmUgcmF3IGRhdGEpXG5cbiAgICAgICAgaWYgKGl0ZW0gJiYgIVJlY29yZEZhY3RvcnkuaXNSZWNvcmQoaXRlbSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlY29yZCA9IFJlY29yZEZhY3RvcnkuY3JlYXRlUmVjb3JkKG1lLm1vZGVsLCBpdGVtKTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ICA9IG1lLmluZGV4T2YoaXRlbSk7XG4gICAgICAgICAgICBjb25zdCBwayAgICAgPSByZWNvcmRbbWUua2V5UHJvcGVydHldOyAvLyBVc2UgdGhlIGFjdHVhbCBQSyBmcm9tIHRoZSByZWNvcmRcblxuICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgcmF3IGRhdGEgd2l0aCB0aGUgcmVjb3JkIGluc3RhbmNlIGluIHRoZSBjdXJyZW50IChmaWx0ZXJlZCkgY29sbGVjdGlvblxuICAgICAgICAgICAgbWUubWFwLnNldChwaywgcmVjb3JkKTtcblxuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIG1lLl9pdGVtc1tpbmRleF0gPSByZWNvcmRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgd2UgYXJlIHRyYWNraW5nIGludGVybmFsSWRzLCB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgbWFwIHRvIHBvaW50IHRvIHRoZSBuZXcgcmVjb3JkXG4gICAgICAgICAgICAvLyBpbnN0ZWFkIG9mIHRoZSByYXcgb2JqZWN0XG4gICAgICAgICAgICBpZiAobWUudHJhY2tJbnRlcm5hbElkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW50ZXJuYWxLZXkgPSBtZS5nZXRJbnRlcm5hbEtleShyZWNvcmQpO1xuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbEtleSkge1xuICAgICAgICAgICAgICAgICAgICBtZS5pbnRlcm5hbElkTWFwLnNldChpbnRlcm5hbEtleSwgcmVjb3JkKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhpcyBjb2xsZWN0aW9uIGlzIGZpbHRlcmVkLCB3ZSBtdXN0IGFsc28gdXBkYXRlIHRoZSBtYXN0ZXIgJ2FsbEl0ZW1zJyBjb2xsZWN0aW9uXG4gICAgICAgICAgICBpZiAobWUuYWxsSXRlbXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXN0ZXJJbmRleCA9IG1lLmFsbEl0ZW1zLmluZGV4T2YoaXRlbSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hc3RlckluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBtZS5hbGxJdGVtcy5tYXAuc2V0KHBrLCByZWNvcmQpO1xuICAgICAgICAgICAgICAgICAgICBtZS5hbGxJdGVtcy5faXRlbXNbbWFzdGVySW5kZXhdID0gcmVjb3JkO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZS5hbGxJdGVtcy50cmFja0ludGVybmFsSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGludGVybmFsS2V5ID0gbWUuZ2V0SW50ZXJuYWxLZXkocmVjb3JkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbEtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLmFsbEl0ZW1zLmludGVybmFsSWRNYXAuc2V0KGludGVybmFsS2V5LCByZWNvcmQpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVjb3JkXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW0gLy8gQWxyZWFkeSBhIHJlY29yZCBvciBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGNvbGxlY3Rpb24uQmFzZTpnZXRBdCgpIHRvIGVuc3VyZSB0aGUgcmV0dXJuZWQgaXRlbSBpcyBhIFJlY29yZCBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXRBdChpbmRleCkge1xuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtID0gc3VwZXIuZ2V0QXQoaW5kZXgpOyAvLyBHZXQgaXRlbSBmcm9tIENvbGxlY3Rpb24uQmFzZSAoY291bGQgYmUgcmF3IGRhdGEpXG5cbiAgICAgICAgaWYgKGl0ZW0gJiYgIVJlY29yZEZhY3RvcnkuaXNSZWNvcmQoaXRlbSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlY29yZCA9IFJlY29yZEZhY3RvcnkuY3JlYXRlUmVjb3JkKG1lLm1vZGVsLCBpdGVtKTtcblxuICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgcmF3IGRhdGEgd2l0aCB0aGUgcmVjb3JkIGluc3RhbmNlIGluIHRoZSBjdXJyZW50IChmaWx0ZXJlZCkgY29sbGVjdGlvblxuICAgICAgICAgICAgbWUubWFwLnNldChyZWNvcmRbbWUua2V5UHJvcGVydHldLCByZWNvcmQpO1xuICAgICAgICAgICAgbWUuX2l0ZW1zW2luZGV4XSA9IHJlY29yZDtcblxuICAgICAgICAgICAgLy8gSWYgd2UgYXJlIHRyYWNraW5nIGludGVybmFsSWRzLCB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgbWFwIHRvIHBvaW50IHRvIHRoZSBuZXcgcmVjb3JkXG4gICAgICAgICAgICAvLyBpbnN0ZWFkIG9mIHRoZSByYXcgb2JqZWN0XG4gICAgICAgICAgICBpZiAobWUudHJhY2tJbnRlcm5hbElkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW50ZXJuYWxLZXkgPSBtZS5nZXRJbnRlcm5hbEtleShyZWNvcmQpO1xuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbEtleSkge1xuICAgICAgICAgICAgICAgICAgICBtZS5pbnRlcm5hbElkTWFwLnNldChpbnRlcm5hbEtleSwgcmVjb3JkKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhpcyBjb2xsZWN0aW9uIGlzIGZpbHRlcmVkLCB3ZSBtdXN0IGFsc28gdXBkYXRlIHRoZSBtYXN0ZXIgJ2FsbEl0ZW1zJyBjb2xsZWN0aW9uXG4gICAgICAgICAgICBpZiAobWUuYWxsSXRlbXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXN0ZXJJbmRleCA9IG1lLmFsbEl0ZW1zLmluZGV4T2YoaXRlbSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hc3RlckluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBtZS5hbGxJdGVtcy5tYXAuc2V0KHJlY29yZFttZS5rZXlQcm9wZXJ0eV0sIHJlY29yZCk7XG4gICAgICAgICAgICAgICAgICAgIG1lLmFsbEl0ZW1zLl9pdGVtc1ttYXN0ZXJJbmRleF0gPSByZWNvcmQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lLmFsbEl0ZW1zLnRyYWNrSW50ZXJuYWxJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW50ZXJuYWxLZXkgPSBtZS5nZXRJbnRlcm5hbEtleShyZWNvcmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGludGVybmFsS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUuYWxsSXRlbXMuaW50ZXJuYWxJZE1hcC5zZXQoaW50ZXJuYWxLZXksIHJlY29yZClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWNvcmRcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbSAvLyBBbHJlYWR5IGEgcmVjb3JkIG9yIHVuZGVmaW5lZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgc3RhYmxlIGludGVybmFsIElEIG9mIGFuIGl0ZW0uXG4gICAgICogQHBhcmFtIHtPYmplY3R8TmVvLmRhdGEuUmVjb3JkfSBpdGVtXG4gICAgICogQHJldHVybnMge1N0cmluZ30gZS5nLiAnbmVvLXJlY29yZC0xJ1xuICAgICAqL1xuICAgIGdldEludGVybmFsSWQoaXRlbSkge1xuICAgICAgICBpZiAoIWl0ZW1baW50ZXJuYWxJZF0pIHtcbiAgICAgICAgICAgIGl0ZW1baW50ZXJuYWxJZF0gPSBOZW8uZ2V0SWQoJ3JlY29yZCcpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlbVtpbnRlcm5hbElkXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhvb2sgdG8gZ2V0IHRoZSBpbnRlcm5hbCBrZXkgb2YgYW4gaXRlbS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8TnVtYmVyfG51bGx9XG4gICAgICovXG4gICAgZ2V0SW50ZXJuYWxLZXkoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbVtpbnRlcm5hbElkXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0S2V5UHJvcGVydHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleVByb3BlcnR5IHx8IHRoaXMubW9kZWwua2V5UHJvcGVydHlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dCB0byBjaGVjayBmb3IgaW50IGJhc2VkIGtleVByb3BlcnRpZXNcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9IGxvd2VyY2FzZSB2YWx1ZSBvZiB0aGUgbW9kZWwgZmllbGQgdHlwZVxuICAgICAqL1xuICAgIGdldEtleVR5cGUoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7bW9kZWx9ICA9IG1lLFxuICAgICAgICAgICAga2V5RmllbGQgPSBtb2RlbD8uZ2V0RmllbGQobWUuZ2V0S2V5UHJvcGVydHkoKSk7XG5cbiAgICAgICAgcmV0dXJuIGtleUZpZWxkPy50eXBlPy50b0xvd2VyQ2FzZSgpIHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIGRhdGEgb2JqZWN0IGludG8gYSBSZWNvcmQgaW5zdGFuY2Ugb3IgcmV0dXJucyBpdCBpZiBpdCBpcyBhbHJlYWR5IG9uZS5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgYWRkKCkgYW5kIGluc2VydCgpIHdoZW4gaW5pdD10cnVlIChkZWZhdWx0KS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZGF0YSBvYmplY3Qgb3IgUmVjb3JkIGluc3RhbmNlXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIFJlY29yZCBpbnN0YW5jZVxuICAgICAqL1xuICAgIGluaXRSZWNvcmQoZGF0YSkge1xuICAgICAgICBpZiAoUmVjb3JkRmFjdG9yeS5pc1JlY29yZChkYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmdldCh0aGlzLmdldEtleShkYXRhKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgY29sbGVjdGlvbi5CYXNlOiBpbnNlcnQoKSB0byBjb252ZXJ0IGl0ZW1zIGludG8gcmVjb3JkcyBpZiBuZWVkZWQuXG4gICAgICpcbiAgICAgKiAqKkVhZ2VyIE1vZGUgKGBpbml0PXRydWVgIC0gRGVmYXVsdCk6KipcbiAgICAgKiBJbW1lZGlhdGVseSBjb252ZXJ0cyByYXcgZGF0YSBpbnRvIGBOZW8uZGF0YS5Nb2RlbGAgaW5zdGFuY2VzLlxuICAgICAqIFJldHVybnMgYW4gYEFycmF5YCBvZiB0aGUgY3JlYXRlZCByZWNvcmRzLlxuICAgICAqXG4gICAgICogKipMYXp5IE1vZGUgKGBpbml0PWZhbHNlYCk6KipcbiAgICAgKiBJbnNlcnRzIHJhdyBkYXRhIGRpcmVjdGx5LiBJbnN0YW50aWF0ZXMgcmVjb3JkcyBvbmx5IG9uIGFjY2Vzcy5cbiAgICAgKiBSZXR1cm5zIGFuIGBBcnJheWAgb2YgdGhlIGluc2VydGVkIHJhdyBkYXRhIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggVGhlIGluZGV4IHRvIGluc2VydCBhdFxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBpdGVtIFRoZSBpdGVtKHMpIHRvIGFkZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2luaXQ9dGhpcy5hdXRvSW5pdFJlY29yZHNdIFRydWUgdG8gcmV0dXJuIHRoZSBjcmVhdGVkIHJlY29yZHNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0W118TmVvLmRhdGEuTW9kZWxbXX0gVGhlIGluc2VydGVkIHJhdyBpdGVtcyBvciBjcmVhdGVkIHJlY29yZHNcbiAgICAgKi9cbiAgICBpbnNlcnQoaW5kZXgsIGl0ZW0sIGluaXQ9dGhpcy5hdXRvSW5pdFJlY29yZHMpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW1zID0gc3VwZXIuaW5zZXJ0KGluZGV4LCBpdGVtKTtcblxuICAgICAgICBpZiAoaW5pdCkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1zLm1hcChpID0+IG1lLmdldChtZS5nZXRLZXkoaSkpKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGl0ZW1zXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHM9e31cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5kYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuaGVhZGVyc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRzLm1ldGhvZCBERUxFVEUsIEdFVCwgUE9TVCwgUFVUXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMucGFyYW1zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdHMucmVzcG9uc2VUeXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuc2NvcGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy51cmxcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3R8T2JqZWN0W10+fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBsb2FkKG9wdHM9e30pIHtcbiAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICBwYXJhbXMgPSB7cGFnZTogbWUuY3VycmVudFBhZ2UsIHBhZ2VTaXplOiBtZS5wYWdlU2l6ZSwgLi4ub3B0cy5wYXJhbXN9O1xuXG4gICAgICAgIGlmIChtZS5yZW1vdGVGaWx0ZXIpIHtcbiAgICAgICAgICAgIHBhcmFtcy5maWx0ZXJzID0gbWUuZXhwb3J0RmlsdGVycygpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWUucmVtb3RlU29ydCkge1xuICAgICAgICAgICAgcGFyYW1zLnNvcnRlcnMgPSBtZS5leHBvcnRTb3J0ZXJzKClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZS5hcGkpIHtcbiAgICAgICAgICAgIGxldCBhcGlBcnJheSA9IG1lLmFwaS5yZWFkLnNwbGl0KCcuJyksXG4gICAgICAgICAgICAgICAgZm4gICAgICAgPSBhcGlBcnJheS5wb3AoKSxcbiAgICAgICAgICAgICAgICBzZXJ2aWNlICA9IE5lby5ucyhhcGlBcnJheS5qb2luKCcuJykpO1xuXG4gICAgICAgICAgICBpZiAoIXNlcnZpY2UpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdBcGkgaXMgbm90IGRlZmluZWQnLCB0aGlzKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG1lLnRyYXAoc2VydmljZVtmbl0ocGFyYW1zKSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICBtZS50b3RhbENvdW50ID0gcmVzcG9uc2UudG90YWxDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgbWUuZGF0YSAgICAgICA9IE5lby5ucyhtZS5yZXNwb25zZVJvb3QsIGZhbHNlLCByZXNwb25zZSk7IC8vIGZpcmVzIHRoZSBsb2FkIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIG1lLmlzTG9hZGVkICAgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZS5kYXRhXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtZS5wcm94eSkge1xuICAgICAgICAgICAgaWYgKG1lLml0ZW1zLmxlbmd0aCA+IDAgJiYgIW9wdHMuYXBwZW5kKSB7XG4gICAgICAgICAgICAgICAgbWUuY2xlYXIoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUuaXNMb2FkaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgY29uc3Qgb25EYXRhID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBtZS5hZGQoZGF0YSk7XG5cbiAgICAgICAgICAgICAgICAvLyBQcm9ncmVzc2l2ZSBSZW5kZXJpbmc6XG4gICAgICAgICAgICAgICAgLy8gQXMgc29vbiBhcyB3ZSBoYXZlIGRhdGEsIHdlIHdhbnQgdGhlIGdyaWQgdG8gcmVuZGVyLlxuICAgICAgICAgICAgICAgIGlmIChtZS5pc0xvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuaXNMb2FkaW5nID0gZmFsc2VcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBXZSBkbyBub3QgbmVlZCB0byBmaXJlIGEgbG9hZCBldmVudCBoZXJlLCBzaW5jZSBvbkNvbGxlY3Rpb25NdXRhdGUgd2lsbCBoYW5kbGUgdGhpcy5cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNvbnN0IG9uUHJvZ3Jlc3MgPSAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIG1lLmZpcmUoJ3Byb2dyZXNzJywgZGF0YSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG1lLnByb3h5Lm9uKHtcbiAgICAgICAgICAgICAgICBkYXRhICAgIDogb25EYXRhLFxuICAgICAgICAgICAgICAgIHByb2dyZXNzOiBvblByb2dyZXNzXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBwYXJhbXMudXJsIGNhbiBvdmVycmlkZSBwcm94eSB1cmxcbiAgICAgICAgICAgICAgICBpZiAob3B0cy51cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnVybCA9IG9wdHMudXJsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbWUucHJveHkucmVhZChwYXJhbXMpO1xuXG4gICAgICAgICAgICAgICAgbWUucHJveHkudW4oe1xuICAgICAgICAgICAgICAgICAgICBkYXRhICAgIDogb25EYXRhLFxuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzczogb25Qcm9ncmVzc1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUudG90YWxDb3VudCA9IHJlc3BvbnNlLnRvdGFsQ291bnQgfHwgbWUuY291bnQ7XG4gICAgICAgICAgICAgICAgICAgIG1lLmlzTG9hZGVkICAgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBtZS5pc0xvYWRpbmcgID0gZmFsc2U7IC8vIEVuc3VyZSBpdCdzIGZhbHNlIGF0IHRoZSBlbmRcbiAgICAgICAgICAgICAgICAgICAgbWUuZmlyZSgnbG9hZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzTG9hZGluZyAgICA6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMgICAgICAgIDogbWUuaXRlbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3N0Q2h1bmtMb2FkOiBtZS5wcm94eT8ubnR5cGUgPT09ICdwcm94eS1zdHJlYW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWwgICAgICAgIDogbWUudG90YWxDb3VudFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lLml0ZW1zXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuaXNMb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIG1lLnByb3h5LnVuKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSAgICA6IG9uRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IG9uUHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBtZS5pc0xvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRzLnVybCA/Pz0gbWUudXJsO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCBkYXRhO1xuXG4gICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgZm9yIG5vbi1icm93c2VyIGJhc2VkIGVudnMgbGlrZSBub2RlanNcbiAgICAgICAgICAgICAgICBpZiAoZ2xvYmFsVGhpcy5wcm9jZXNzPy5yZWxlYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVhZEZpbGUgfSA9IGF3YWl0IGltcG9ydCgvKiB3ZWJwYWNrSWdub3JlOiB0cnVlICovICdmcy9wcm9taXNlcycpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgbWUudHJhcChyZWFkRmlsZShvcHRzLnVybCwgJ3V0Zi04JykpO1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0ge2pzb246IEpTT04ucGFyc2UoY29udGVudCl9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBhd2FpdCBtZS50cmFwKE5lby5YaHIucHJvbWlzZUpzb24ob3B0cykpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmRhdGEgPSBOZW8ubnMobWUucmVzcG9uc2VSb290LCBmYWxzZSwgZGF0YS5qc29uKSB8fCBkYXRhLmpzb24gLy8gZmlyZXMgdGhlIGxvYWQgZXZlbnRcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZS5pc0xvYWRlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YT8uanNvbiB8fCBudWxsXG4gICAgICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIgPT09IE5lby5pc0Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmb3IgTmVvLlhoci5yZXF1ZXN0Jywge2lkOiBtZS5pZCwgZXJyb3I6IGVyciwgdXJsOiBvcHRzLnVybH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqL1xuICAgIG9uQ29sbGVjdGlvbk11dGF0ZShvcHRzKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmlzQ29uc3RydWN0ZWQgJiYgIW1lLmlzTG9hZGluZykge1xuICAgICAgICAgICAgY29uc3QgaXNGaXJzdENodW5rID0gb3B0cy5hZGRlZEl0ZW1zICYmIG1lLmNvdW50ID09PSBvcHRzLmFkZGVkSXRlbXMubGVuZ3RoO1xuXG4gICAgICAgICAgICBtZS5maXJlKCdsb2FkJywge1xuICAgICAgICAgICAgICAgIGlzTG9hZGluZyAgICA6ICEhbWUuaXNTdHJlYW1pbmcsXG4gICAgICAgICAgICAgICAgaXRlbXMgICAgICAgIDogbWUuaXRlbXMsXG4gICAgICAgICAgICAgICAgcG9zdENodW5rTG9hZDogISFtZS5pc1N0cmVhbWluZyAmJiAhaXNGaXJzdENodW5rLFxuICAgICAgICAgICAgICAgIHRvdGFsICAgICAgICA6IG1lLmNodW5raW5nVG90YWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNvbGxlY3Rpb25Tb3J0KCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5pc0NvbnN0cnVjdGVkKSB7XG4gICAgICAgICAgICBtZS5maXJlKCdsb2FkJywge2l0ZW1zOiBtZS5pdGVtc30pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIHN1cGVyLm9uQ29uc3RydWN0ZWQoKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5kYXRhKSB7XG4gICAgICAgICAgICBtZS5hZnRlclNldERhdGEobWUuZGF0YSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlaW5nIGNvbnN0cnVjdGVkIGRvZXMgbm90IG1lYW4gdGhhdCByZWxhdGVkIGFmdGVyU2V0U3RvcmUoKSBtZXRob2RzIGdvdCBleGVjdXRlZFxuICAgICAgICAvLyA9PiBicmVhayB0aGUgc3luYyBmbG93IHRvIGVuc3VyZSBwb3RlbnRpYWwgbGlzdGVuZXJzIGdvdCBhcHBsaWVkXG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKG1lLmlzTG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgbWUuZmlyZSgnbG9hZCcsIHtpdGVtczogbWUuaXRlbXN9KVxuICAgICAgICAgICAgfSBlbHNlIGlmIChtZS5hdXRvTG9hZCkge1xuICAgICAgICAgICAgICAgIG1lLmxvYWQoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uRmlsdGVyQ2hhbmdlKG9wdHMpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUucmVtb3RlRmlsdGVyKSB7XG4gICAgICAgICAgICBtZS5fY3VycmVudFBhZ2UgPSAxOyAvLyBzaWxlbnQgdXBkYXRlXG4gICAgICAgICAgICBtZS5sb2FkKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1cGVyLm9uRmlsdGVyQ2hhbmdlKG9wdHMpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCBhZnRlciBjaGFuZ2luZyB0aGUgdmFsdWUgb2YgYSByZWNvcmQgZmllbGQuXG4gICAgICogRS5nLiBteVJlY29yZC5mb28gPSAnYmFyJztcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGEuZmllbGRzIEVhY2ggZmllbGQgb2JqZWN0IGNvbnRhaW5zIHRoZSBrZXlzOiBuYW1lLCBvbGRWYWx1ZSwgdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLk1vZGVsfSBkYXRhLm1vZGVsIFRoZSBtb2RlbCBpbnN0YW5jZSBvZiB0aGUgY2hhbmdlZCByZWNvcmRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YS5yZWNvcmRcbiAgICAgKi9cbiAgICBvblJlY29yZENoYW5nZShkYXRhKSB7XG4gICAgICAgIHRoaXMuZmlyZSgncmVjb3JkQ2hhbmdlJywge1xuICAgICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICAgIGluZGV4OiB0aGlzLmluZGV4T2YoZGF0YS5yZWNvcmQpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHM9e31cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy5kaXJlY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy5wcm9wZXJ0eVxuICAgICAqL1xuICAgIHNvcnQob3B0cz17fSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLl9jdXJyZW50UGFnZSA9IDE7IC8vIHNpbGVudCB1cGRhdGVcblxuICAgICAgICBpZiAobWUuY29uZmlnc0FwcGxpZWQpIHtcbiAgICAgICAgICAgIGlmIChvcHRzLmRpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgIG1lLnNvcnRlcnMgPSBbe1xuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246IG9wdHMuZGlyZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSA6IG9wdHMucHJvcGVydHlcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1lLnJlbW90ZVNvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuc29ydGVycyA9IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdBU0MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkgOiBpbml0aWFsSW5kZXhTeW1ib2xcbiAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgY29sbGVjdGlvbi5CYXNlOmRvU29ydCgpIHRvIGhhbmRsZSBcIlR1cmJvIE1vZGVcIiAoYXV0b0luaXRSZWNvcmRzOiBmYWxzZSkuXG4gICAgICogSW4gdGhpcyBtb2RlLCBpdGVtcyBhcmUgcmF3IG9iamVjdHMgd2hpY2ggbWF5IGxhY2sgdGhlIGNhbm9uaWNhbCBmaWVsZCBuYW1lcyB1c2VkIGJ5IFNvcnRlcnMuXG4gICAgICogVGhpcyBtZXRob2QgXCJzb2Z0IGh5ZHJhdGVzXCIgdGhlIHJhdyBpdGVtcyBieSByZXNvbHZpbmcgYW5kIGNhY2hpbmcgdGhlIHNvcnQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGl0ZW1zXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaWxlbnRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZG9Tb3J0KGl0ZW1zPXRoaXMuX2l0ZW1zLCBzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIW1lLmF1dG9Jbml0UmVjb3JkcyAmJiBtZS5tb2RlbD8uaGFzQ29tcGxleEZpZWxkcyAmJiBtZS5zb3J0ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgICAgc29ydFByb3BlcnRpZXMgPSBtZS5zb3J0ZXJzLm1hcChzID0+IHMucHJvcGVydHkpLFxuICAgICAgICAgICAgICAgIGxlbiAgICAgICAgICAgID0gc29ydFByb3BlcnRpZXMubGVuZ3RoO1xuXG4gICAgICAgICAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBpdGVtIGlzIG5vdCBhbHJlYWR5IGEgUmVjb3JkIChtaXhlZCBtb2RlIHNhZmV0eSlcbiAgICAgICAgICAgICAgICBpZiAoIVJlY29yZEZhY3RvcnkuaXNSZWNvcmQoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcGVydHkgPSBzb3J0UHJvcGVydGllc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSByZXNvbHZlIGlmIHRoZSBwcm9wZXJ0eSBpcyBtaXNzaW5nIG9uIHRoZSByYXcgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5oYXNPd24oaXRlbSwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbVtwcm9wZXJ0eV0gPSBtZS5yZXNvbHZlRmllbGQoaXRlbSwgcHJvcGVydHkpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgc3VwZXIuZG9Tb3J0KGl0ZW1zLCBzaWxlbnQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGNvbGxlY3Rpb24uQmFzZTpmaWx0ZXIoKSB0byBoYW5kbGUgXCJUdXJibyBNb2RlXCIgKGF1dG9Jbml0UmVjb3JkczogZmFsc2UpLlxuICAgICAqIEluIHRoaXMgbW9kZSwgaXRlbXMgYXJlIHJhdyBvYmplY3RzIHdoaWNoIG1heSBsYWNrIHRoZSBjYW5vbmljYWwgZmllbGQgbmFtZXMgdXNlZCBieSBGaWx0ZXJzLlxuICAgICAqIFRoaXMgbWV0aG9kIFwic29mdCBoeWRyYXRlc1wiIHRoZSByYXcgaXRlbXMgYnkgcmVzb2x2aW5nIGFuZCBjYWNoaW5nIHRoZSBmaWx0ZXIgdmFsdWVzLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBmaWx0ZXIoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5hdXRvSW5pdFJlY29yZHMgJiYgbWUubW9kZWw/Lmhhc0NvbXBsZXhGaWVsZHMgJiYgbWUuZmlsdGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdFxuICAgICAgICAgICAgICAgIGFjdGl2ZUZpbHRlcnMgICAgPSBtZS5maWx0ZXJzLmZpbHRlcihmID0+ICFmLmRpc2FibGVkICYmIGYudmFsdWUgIT09IG51bGwpLFxuICAgICAgICAgICAgICAgIGZpbHRlclByb3BlcnRpZXMgPSBhY3RpdmVGaWx0ZXJzLm1hcChmID0+IGYucHJvcGVydHkpLFxuICAgICAgICAgICAgICAgIGxlbiAgICAgICAgICAgICAgPSBmaWx0ZXJQcm9wZXJ0aWVzLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBpdGVyYXRlIG92ZXIgYWxsSXRlbXMgKHVuZmlsdGVyZWQgc291cmNlKSBvciBjdXJyZW50IGl0ZW1zIGRlcGVuZGluZyBvbiBzdGF0ZSxcbiAgICAgICAgICAgICAgICAvLyBidXQgQ29sbGVjdGlvbi5maWx0ZXIoKSB1c2VzIGFsbEl0ZW1zIGlmIGl0IGV4aXN0cy4gSWRlYWxseSB3ZSBoeWRyYXRlIHRoZSBzb3VyY2UuXG4gICAgICAgICAgICAgICAgLy8gU2luY2Ugd2UgY2FuJ3QgZWFzaWx5IGtub3cgd2hpY2ggc291cmNlIENvbGxlY3Rpb24uZmlsdGVyIHdpbGwgdXNlIHdpdGhvdXQgZHVwbGljYXRpbmcgbG9naWMsXG4gICAgICAgICAgICAgICAgLy8gd2Ugd2lsbCBoeWRyYXRlIGJvdGggaWYgdGhleSBleGlzdCwgb3IganVzdCB0aGUgYWN0aXZlIG9uZS5cbiAgICAgICAgICAgICAgICAvLyBTYWZlc3QgYmV0OiBIeWRyYXRlIHRoZSBzb3VyY2UgdGhhdCBmaWx0ZXIoKSB3aWxsIHVzZS5cbiAgICAgICAgICAgICAgICAvLyBDb2xsZWN0aW9uLmZpbHRlciB1c2VzOiBpdGVtcyA9IG1lLmFsbEl0ZW1zPy5faXRlbXMgfHwgbWUuX2l0ZW1zXG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbXNUb0h5ZHJhdGUgPSBtZS5hbGxJdGVtcyA/IG1lLmFsbEl0ZW1zLl9pdGVtcyA6IG1lLl9pdGVtcztcblxuICAgICAgICAgICAgICAgIGl0ZW1zVG9IeWRyYXRlLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghUmVjb3JkRmFjdG9yeS5pc1JlY29yZChpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5ID0gZmlsdGVyUHJvcGVydGllc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghT2JqZWN0Lmhhc093bihpdGVtLCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbVtwcm9wZXJ0eV0gPSBtZS5yZXNvbHZlRmllbGQoaXRlbSwgcHJvcGVydHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN1cGVyLmZpbHRlcigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGNvbGxlY3Rpb24uQmFzZTppc0ZpbHRlcmVkSXRlbSgpIHRvIGhhbmRsZSBcIlR1cmJvIE1vZGVcIiAoYXV0b0luaXRSZWNvcmRzOiBmYWxzZSkuXG4gICAgICogSW4gdGhpcyBtb2RlLCBpdGVtcyBhcmUgcmF3IG9iamVjdHMgd2hpY2ggbWF5IGxhY2sgdGhlIGNhbm9uaWNhbCBmaWVsZCBuYW1lcyB1c2VkIGJ5IEZpbHRlcnMuXG4gICAgICogVGhpcyBtZXRob2QgXCJzb2Z0IGh5ZHJhdGVzXCIgdGhlIHJhdyBpdGVtIGJ5IHJlc29sdmluZyBhbmQgY2FjaGluZyB0aGUgZmlsdGVyIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpc0ZpbHRlcmVkSXRlbShpdGVtKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5hdXRvSW5pdFJlY29yZHMgJiYgIVJlY29yZEZhY3RvcnkuaXNSZWNvcmQoaXRlbSkgJiYgbWUuZmlsdGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBtZS5maWx0ZXJzLmZvckVhY2goZmlsdGVyID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWZpbHRlci5kaXNhYmxlZCAmJiBmaWx0ZXIudmFsdWUgIT09IG51bGwgJiYgIU9iamVjdC5oYXNPd24oaXRlbSwgZmlsdGVyLnByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtW2ZpbHRlci5wcm9wZXJ0eV0gPSBtZS5yZXNvbHZlRmllbGQoaXRlbSwgZmlsdGVyLnByb3BlcnR5KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VwZXIuaXNGaWx0ZXJlZEl0ZW0oaXRlbSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgdG8gcmVzb2x2ZSBhIGZpZWxkIHZhbHVlIGZyb20gYSByYXcgZGF0YSBvYmplY3QgdXNpbmcgdGhlIE1vZGVsIGRlZmluaXRpb24uXG4gICAgICogSGFuZGxlcyBtYXBwaW5nLCBjYWxjdWxhdGUsIGFuZCBjb252ZXJ0LlxuICAgICAqXG4gICAgICogKipMaW1pdGF0aW9ucyAmIFwiVHVyYm8tU2FmZVwiIFJlcXVpcmVtZW50OioqXG4gICAgICogVGhpcyBtZXRob2QgcmVzb2x2ZXMgYSAqc2luZ2xlKiBmaWVsZCBpbiBpc29sYXRpb24uIEl0IGRvZXMgKipub3QqKiByZWN1cnNpdmVseSByZXNvbHZlIGRlcGVuZGVuY2llcy5cbiAgICAgKlxuICAgICAqIElmIEZpZWxkIEEgcmVsaWVzIG9uIEZpZWxkIEIgKGUuZy4sIHZpYSBgY2FsY3VsYXRlYCBvciBgY29udmVydGApLCBhbmQgRmllbGQgQiBpcyBhbHNvIGEgbWFwcGVkL2NhbGN1bGF0ZWQgZmllbGQ6XG4gICAgICogLSAqKk9uIGEgUmVjb3JkOioqIEZpZWxkIEIgaXMgYWNjZXNzaWJsZSB2aWEgaXRzIGdldHRlci5cbiAgICAgKiAtICoqT24gYSBSYXcgT2JqZWN0OioqIEZpZWxkIEIgaXMgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBUaGVyZWZvcmUsIE1vZGVsIGxvZ2ljIChjYWxjdWxhdGUvY29udmVydCBmdW5jdGlvbnMpIE1VU1QgYmUgd3JpdHRlbiB0byBiZSBcIlR1cmJvLVNhZmVcIiAvIFwiUG9seW1vcnBoaWNcIi5cbiAgICAgKiBUaGV5IG11c3QgY2hlY2sgZm9yIGJvdGggdGhlIGNhbm9uaWNhbCBmaWVsZCBuYW1lIChmb3IgUmVjb3JkcykgQU5EIHRoZSByYXcgZGF0YSBrZXkgKGZvciBUdXJibyBNb2RlKS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2FsY3VsYXRlOiBkYXRhID0+IChkYXRhLm1hcHBlZE5hbWUgfHwgZGF0YS5yYXdLZXkpICsgMVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gVGhlIHJhdyBkYXRhIG9iamVjdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZE5hbWUgVGhlIGNhbm9uaWNhbCBmaWVsZCBuYW1lXG4gICAgICogQHJldHVybnMgeyp9IFRoZSByZXNvbHZlZCB2YWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICByZXNvbHZlRmllbGQoaXRlbSwgZmllbGROYW1lKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICBmaWVsZCA9IG1lLm1vZGVsLmdldEZpZWxkKGZpZWxkTmFtZSksXG4gICAgICAgICAgICB2YWx1ZTtcblxuICAgICAgICBpZiAoIWZpZWxkKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmICghUmVjb3JkRmFjdG9yeS5pc1JlY29yZChpdGVtKSAmJiBmaWVsZC5kZXBlbmRzKSB7XG4gICAgICAgICAgICBsZXQgZGVwcyA9IGZpZWxkLmRlcGVuZHMsXG4gICAgICAgICAgICAgICAgaSAgICA9IDAsXG4gICAgICAgICAgICAgICAgbGVuICA9IGRlcHMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGRlcDtcblxuICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGRlcCA9IGRlcHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1bZGVwXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1bZGVwXSA9IG1lLnJlc29sdmVGaWVsZChpdGVtLCBkZXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaWVsZC5jYWxjdWxhdGUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZmllbGQuY2FsY3VsYXRlKGl0ZW0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgTWFwcGluZ1xuICAgICAgICAgICAgaWYgKGZpZWxkLm1hcHBpbmcpIHtcbiAgICAgICAgICAgICAgICBsZXQgbnMgICAgID0gZmllbGQubWFwcGluZy5zcGxpdCgnLicpLFxuICAgICAgICAgICAgICAgICAgICBrZXkgICAgPSBucy5wb3AoKSxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlID0gbnMubGVuZ3RoID4gMCA/IE5lby5ucyhucywgZmFsc2UsIGl0ZW0pIDogaXRlbTtcblxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UgJiYgT2JqZWN0Lmhhc093bihzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzb3VyY2Vba2V5XVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBpdGVtW2ZpZWxkTmFtZV1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSGFuZGxlIENvbnZlcnRcbiAgICAgICAgICAgIGlmIChmaWVsZC5jb252ZXJ0KSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBmaWVsZC5jb252ZXJ0KHZhbHVlLCBpdGVtKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBIYW5kbGUgRGVmYXVsdCBWYWx1ZVxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgT2JqZWN0Lmhhc093bihmaWVsZCwgJ2RlZmF1bHRWYWx1ZScpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBOZW8uaXNGdW5jdGlvbihmaWVsZC5kZWZhdWx0VmFsdWUpID8gZmllbGQuZGVmYXVsdFZhbHVlKCkgOiBmaWVsZC5kZWZhdWx0VmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghUmVjb3JkRmFjdG9yeS5pc1JlY29yZChpdGVtKSkge1xuICAgICAgICAgICAgaXRlbVtmaWVsZE5hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyB0aGUga2V5IG9mIGEgZ2l2ZW4gaXRlbSwgc3VwcG9ydGluZyBib3RoIHJhdyBkYXRhIG9iamVjdHMgYW5kIFJlY29yZCBpbnN0YW5jZXMuXG4gICAgICogVGhpcyBoYW5kbGVzIHRoZSBlZGdlIGNhc2Ugd2hlcmUgYGtleVByb3BlcnR5YCByZWZlcnMgdG8gYSBtYXBwZWQgc291cmNlIGtleSAoZS5nLiAnbCcpXG4gICAgICogd2hpY2ggZXhpc3RzIG9uIHRoZSByYXcgb2JqZWN0IGJ1dCBub3Qgb24gdGhlIFJlY29yZCBpbnN0YW5jZSAod2hlcmUgaXQgaXMgbWFwcGVkIHRvIGUuZy4gJ2xvZ2luJykuXG4gICAgICogQHBhcmFtIHtPYmplY3R8TmVvLmRhdGEuUmVjb3JkfSBpdGVtXG4gICAgICogQHJldHVybnMge1N0cmluZ3xOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0S2V5KGl0ZW0pIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGtleVByb3BlcnR5ID0gbWUuZ2V0S2V5UHJvcGVydHkoKSxcbiAgICAgICAgICAgIHZhbHVlO1xuXG4gICAgICAgIGlmIChSZWNvcmRGYWN0b3J5LmlzUmVjb3JkKGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5nZXQoa2V5UHJvcGVydHkpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5UHJvcGVydHkuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBOZW8ubnMoa2V5UHJvcGVydHksIGZhbHNlLCBpdGVtKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBpdGVtW2tleVByb3BlcnR5XVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgZGlyZWN0IGFjY2VzcyBmYWlsZWQsIGNoZWNrIGZvciBtYXBwaW5nIChSZXZlcnNlIExvb2t1cClcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgbWUubW9kZWwpIHtcbiAgICAgICAgICAgIGxldCBmaWVsZCA9IG1lLm1vZGVsLmdldEZpZWxkKGtleVByb3BlcnR5KTtcbiAgICAgICAgICAgIGlmIChmaWVsZD8ubWFwcGluZykge1xuICAgICAgICAgICAgICAgIGxldCBtYXBwaW5nID0gZmllbGQubWFwcGluZztcbiAgICAgICAgICAgICAgICBpZiAobWFwcGluZy5pbmNsdWRlcygnLicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gTmVvLm5zKG1hcHBpbmcsIGZhbHNlLCBpdGVtKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaXRlbVttYXBwaW5nXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIGluc3RhbmNlIGludG8gYSBKU09OLWNvbXBhdGlibGUgb2JqZWN0IGZvciB0aGUgTmV1cmFsIExpbmsuXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLnRvSlNPTigpLFxuICAgICAgICAgICAgYXV0b0luaXRSZWNvcmRzIDogbWUuYXV0b0luaXRSZWNvcmRzLFxuICAgICAgICAgICAgYXV0b0xvYWQgICAgICAgIDogbWUuYXV0b0xvYWQsXG4gICAgICAgICAgICBjdXJyZW50UGFnZSAgICAgOiBtZS5jdXJyZW50UGFnZSxcbiAgICAgICAgICAgIGluaXRpYWxDaHVua1NpemU6IG1lLmluaXRpYWxDaHVua1NpemUsXG4gICAgICAgICAgICBpc0dyb3VwZWQgICAgICAgOiBtZS5pc0dyb3VwZWQsXG4gICAgICAgICAgICBpc0xvYWRlZCAgICAgICAgOiBtZS5pc0xvYWRlZCxcbiAgICAgICAgICAgIGlzTG9hZGluZyAgICAgICA6IG1lLmlzTG9hZGluZyxcbiAgICAgICAgICAgIG1vZGVsICAgICAgICAgICA6IG1lLm1vZGVsPy50b0pTT04oKSxcbiAgICAgICAgICAgIHBhZ2VTaXplICAgICAgICA6IG1lLnBhZ2VTaXplLFxuICAgICAgICAgICAgcmVtb3RlRmlsdGVyICAgIDogbWUucmVtb3RlRmlsdGVyLFxuICAgICAgICAgICAgcmVtb3RlU29ydCAgICAgIDogbWUucmVtb3RlU29ydCxcbiAgICAgICAgICAgIHRvdGFsQ291bnQgICAgICA6IG1lLnRvdGFsQ291bnQsXG4gICAgICAgICAgICB1cmwgICAgICAgICAgICAgOiBtZS51cmxcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoU3RvcmUpO1xuIiwiaW1wb3J0IENsYXNzU3lzdGVtVXRpbCBmcm9tICcuLi91dGlsL0NsYXNzU3lzdGVtLm1qcyc7XG5pbXBvcnQgQ29tcG9uZW50ICAgICAgIGZyb20gJy4uL2NvbXBvbmVudC9CYXNlLm1qcyc7XG5pbXBvcnQgTGlzdE1vZGVsICAgICAgIGZyb20gJy4uL3NlbGVjdGlvbi9MaXN0TW9kZWwubWpzJztcbmltcG9ydCBOZW9BcnJheSAgICAgICAgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IFN0b3JlICAgICAgICAgICBmcm9tICcuLi9kYXRhL1N0b3JlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5saXN0LkJhc2VcbiAqIEBleHRlbmRzIE5lby5jb21wb25lbnQuQmFzZVxuICovXG5jbGFzcyBMaXN0IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5saXN0LkJhc2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5saXN0LkJhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nbGlzdCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdsaXN0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGFuaW1hdGVfPWZhbHNlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgYW5pbWF0ZV86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSB3aWxsIGRlc3Ryb3kgdGhlIHVzZWQgY29sbGVjdGlvbiAvIHN0b3JlIHdoZW4gdGhlIGNvbXBvbmVudCBnZXRzIGRlc3Ryb3llZFxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhdXRvRGVzdHJveVN0b3JlPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9EZXN0cm95U3RvcmU6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1saXN0J11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWxpc3QnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIG9wdGlvbmFsIHJlY29yZCBmaWVsZCB0byBtYWtlIGl0ZW1zIG5vbi1jbGlja2FibGUgYW5kIHZpc3VhbGx5IGdyZXllZCBvdXQuXG4gICAgICAgICAqIFRoZSBmaWVsZCBleHBlY3RzIHRoZSBCb29sZWFuIHR5cGUuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gZGlzYWJsZWRGaWVsZD0nZGlzYWJsZWQnXG4gICAgICAgICAqL1xuICAgICAgICBkaXNhYmxlZEZpZWxkOiAnZGlzYWJsZWQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZGlzYWJsZVNlbGVjdGlvbl89ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBkaXNhYmxlU2VsZWN0aW9uXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGRpc3BsYXlGaWVsZD0nbmFtZSdcbiAgICAgICAgICovXG4gICAgICAgIGRpc3BsYXlGaWVsZDogJ25hbWUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZHJhZ2dhYmxlXz1mYWxzZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdnYWJsZV86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmRyYWdnYWJsZS5saXN0LkRyYWdab25lfG51bGx9IGRyYWdab25lPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdab25lOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBkcmFnWm9uZUNvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnWm9uZUNvbmZpZzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBmb2N1c3NlZCBpdGVtIGluZGV4IGFuZCBhbGxvd3MgYmluZGluZ3MgYW5kIHByb2dyYW1tYXRpYyBjaGFuZ2VzLlxuICAgICAgICAgKiBZb3UgY2FuIGVpdGhlciBwYXNzIHRoZSBpbmRleCBvciB0aGUgcmVsYXRlZCByZWNvcmRcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfE9iamVjdHxudWxsfSBmb2N1c0luZGV4Xz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgZm9jdXNJbmRleF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbiBjYXNlIHdlIGFyZSB1c2luZyBsaXN0IGl0ZW0gaGVhZGVycyBhbmQgd2FudCB0byBiaW5kIGxpc3QgaXRlbSBpbmRleGVzIHRvIGUuZy4gYSBjYXJkIGxheW91dFxuICAgICAgICAgKiBmb3IgZS5nLiBhIHNpZGVuYXYsIHRoaXMgY29uZmlnIGNvbWVzIGluIGhhbmR5LlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gaGVhZGVybGVzc1NlbGVjdGVkSW5kZXhfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBoZWFkZXJsZXNzU2VsZWN0ZWRJbmRleF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBoaWdobGlnaHRGaWx0ZXJWYWx1ZT10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBoaWdobGlnaHRGaWx0ZXJWYWx1ZTogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gaXRlbUNscz0nbmVvLWxpc3QtaXRlbSdcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1DbHM6ICduZW8tbGlzdC1pdGVtJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmF1bHRzIHRvIHB4XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBpdGVtSGVpZ2h0Xz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbUhlaWdodF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBvZiB0aGUgbm9kZSAvIHRhZyBmb3IgZWFjaCBsaXN0IGl0ZW1cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBpdGVtVGFnTmFtZT0nbGknXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtVGFnTmFtZTogJ2xpJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmF1bHRzIHRvIHB4XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBpdGVtV2lkdGhfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtV2lkdGhfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXRlbXNGb2N1c2FibGU9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbXNGb2N1c2FibGU6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY29uZmlnIHdpbGwgZ2V0IHBhc3NlZCB0byB0aGUgbmF2aWdhdG9yIG1haW4gdGhyZWFkIGFkZG9uLlxuICAgICAgICAgKiBFLmcuIGZvciBDb21ib0JveGVzLCB3aGljaCBzaGFsbCBwcmVzZXJ2ZSB0aGVpciBmb2N1c3NlZCBsaXN0IGl0ZW0gd2hlbiBmaWx0ZXJpbmcgdGhlIHN0b3JlLCB1c2UgdHJ1ZS5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0ga2VlcEZvY3VzSW5kZXg9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGtlZXBGb2N1c0luZGV4OiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZGl0aW9uYWwgdXNlZCBrZXlzIGZvciB0aGUgc2VsZWN0aW9uIG1vZGVsXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0ga2V5c1xuICAgICAgICAgKi9cbiAgICAgICAga2V5czoge30sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjb25maWcgdmFsdWVzIGZvciBOZW8ubGlzdC5wbHVnaW4uQW5pbWF0ZVxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHBsdWdpbkFuaW1hdGVDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgcGx1Z2luQW5pbWF0ZUNvbmZpZzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBzZWxlY3RlZCBpdGVtIGluZGV4IGFuZCBhbGxvd3MgYmluZGluZ3MgYW5kIHByb2dyYW1tYXRpYyBjaGFuZ2VzXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBzZWxlY3RlZEluZGV4Xz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZWN0ZWRJbmRleF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFaXRoZXIgcGFzcyBhIHNlbGVjdGlvbi5Nb2RlbCBtb2R1bGUsIGFuIGluc3RhbmNlIG9yIGEgY29uZmlnIG9iamVjdFxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8TmVvLnNlbGVjdGlvbi5Nb2RlbH0gc2VsZWN0aW9uTW9kZWxfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzZWxlY3Rpb25Nb2RlbF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhpcyB0byB0cnVlIGluIGNhc2UgYSBrZXlib2FyZCBuYXZpZ2F0aW9uIHNob3VsZCBpbW1lZGlhdGVseSBzZWxlY3QgdGhlIGZvY3Vzc2VkIGl0ZW1cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2VsZWN0T25Gb2N1cz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZWN0T25Gb2N1czogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhpcyB0byB0cnVlIGluIGNhc2UgYSBzZWxlY3QgZXZlbnQgc2hvdWxkIG9ubHkgdXBkYXRlIF92ZG9tIChlLmcuIHdoZW4gdXNlZCBpbnNpZGUgYSBmb3JtLmZpZWxkLkNvbWJvQm94XG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbGVudFNlbGVjdD1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgc2lsZW50U2VsZWN0OiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5kYXRhLlN0b3JlfG51bGx9IHN0b3JlXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgc3RvcmVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSB3aWxsIGFkZCBhIGNoZWNrYm94IGluIGZyb250IG9mIGVhY2ggbGlzdCBpdGVtXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHN0YWNrZWRfPXRydWVcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB1c2VDaGVja0JveGVzXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB1c2VJbnRlcm5hbElkPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIHVzZUludGVybmFsSWQ6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXR0aW5nIHRoaXMgY29uZmlnIHRvIHRydWUgd2lsbCBzd2l0Y2ggdG8gZGwsIGR0ICYgZGQgdGFncyBpbnN0ZWFkIG9mIHVzaW5nIHVsICYgbGkuXG4gICAgICAgICAqIFVzZSB0aGUge0Jvb2xlYW59IG1vZGVsIGZpZWxkIGlzSGVhZGVyLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB1c2VIZWFkZXJzXz1mYWxzZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHVzZUhlYWRlcnNfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHVzZVdyYXBwZXJOb2RlXz1mYWxzZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHVzZVdyYXBwZXJOb2RlXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IF92ZG9tXG4gICAgICAgICAqL1xuICAgICAgICBfdmRvbTpcbiAgICAgICAge3RhZzogJ3VsJywgY246IFtdfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBpdGVtUm9sZT1udWxsXG4gICAgICovXG4gICAgaXRlbVJvbGUgPSBudWxsXG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IHRvIGhlbHAgY29uZmlndXJlIHRoZSBuYXZpZ2F0aW9uLiBVc2VkIHRvIHBhc3MgdG8ge0BsaW5rIE5lby5tYWluLmFkZG9uLk5hdmlnYXRvciNzdWJzY3JpYmV9LlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gbmF2aWdhdG9yPXt9XG4gICAgICovXG4gICAgbmF2aWdhdG9yID0ge31cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0cyB0byBmYWxzZSBpbiBjYXNlIHVzZUhlYWRlcnMgaXMgc2V0IHRvIHRydWVcbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzY3JvbGxJbnRvVmlld09uRm9jdXM9dHJ1ZVxuICAgICAqL1xuICAgIHNjcm9sbEludG9WaWV3T25Gb2N1cyA9IHRydWVcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLnVzZUhlYWRlcnMpIHtcbiAgICAgICAgICAgIG1lLnNjcm9sbEludG9WaWV3T25Gb2N1cyA9IGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBtZS5hZGREb21MaXN0ZW5lcnMoe1xuICAgICAgICAgICAgY2xpY2s6IG1lLm9uQ2xpY2ssXG4gICAgICAgICAgICBzY29wZTogbWVcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGFuaW1hdGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRBbmltYXRlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgJiYgIXRoaXMuZ2V0UGx1Z2luKCdsaXN0LWFuaW1hdGUnKSkge1xuICAgICAgICAgICAgaW1wb3J0KCcuL3BsdWdpbi9BbmltYXRlLm1qcycpLnRoZW4obW9kdWxlID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbnMgPSBtZS5wbHVnaW5zIHx8IFtdO1xuXG4gICAgICAgICAgICAgICAgcGx1Z2lucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlOiBtb2R1bGUuZGVmYXVsdCxcbiAgICAgICAgICAgICAgICAgICAgLi4ubWUucGx1Z2luQW5pbWF0ZUNvbmZpZ1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgbWUucGx1Z2lucyA9IHBsdWdpbnNcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGRpc2FibGVTZWxlY3Rpb24gY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXREaXNhYmxlU2VsZWN0aW9uKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB2YWx1ZSAmJiB0aGlzLnZub2RlSW5pdGlhbGl6ZWQgJiYgdGhpcy5zZWxlY3Rpb25Nb2RlbD8uZGVzZWxlY3RBbGwoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZHJhZ2dhYmxlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RHJhZ2dhYmxlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiAhbWUuZHJhZ1pvbmUpIHtcbiAgICAgICAgICAgIGltcG9ydCgnLi4vZHJhZ2dhYmxlL2xpc3QvRHJhZ1pvbmUubWpzJykudGhlbihtb2R1bGUgPT4ge1xuICAgICAgICAgICAgICAgIG1lLmRyYWdab25lID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZSAgOiBtb2R1bGUuZGVmYXVsdCxcbiAgICAgICAgICAgICAgICAgICAgYXBwTmFtZSA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG93bmVyICAgOiBtZSxcbiAgICAgICAgICAgICAgICAgICAgd2luZG93SWQ6IG1lLndpbmRvd0lkLFxuICAgICAgICAgICAgICAgICAgICAuLi5tZS5kcmFnWm9uZUNvbmZpZ1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBmb2N1c0luZGV4IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdHxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdHxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEZvY3VzSW5kZXgodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHZhbHVlICE9PSBudWxsICYmIHRoaXMudXBkYXRlSXRlbUZvY3VzKHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaGVhZGVybGVzc1NlbGVjdGVkSW5kZXggY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SGVhZGVybGVzc1NlbGVjdGVkSW5kZXgodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKE5lby5pc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIG1lLnNlbGVjdGVkSW5kZXggPSBtZS5zdG9yZS5nZXRDb3VudCgpID8gbWUuZ2V0U2VsZWN0ZWRJbmRleCh2YWx1ZSkgOiBudWxsXG4gICAgICAgIH0gZWxzZSBpZiAoTmVvLmlzTnVtYmVyKG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgbWUuc2VsZWN0ZWRJbmRleCA9IG51bGxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbW91bnRlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgLy8gVGVhciBkb3duIG5hdmlnYXRpb24gYmVmb3JlIHdlIGxvc2UgdGhlIGVsZW1lbnRcbiAgICAgICAgaWYgKCF2YWx1ZSAmJiBtZS5oYXNOYXZpZ2F0b3IpIHtcbiAgICAgICAgICAgIE5lby5tYWluLmFkZG9uLk5hdmlnYXRvci51bnN1YnNjcmliZShtZS5uYXZpZ2F0b3IpO1xuXG4gICAgICAgICAgICBtZS5oYXNOYXZpZ2F0b3IgID0gZmFsc2U7XG4gICAgICAgICAgICBtZS5zZWxlY3RlZEluZGV4ID0gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBTZXQgdXAgaXRlbSBuYXZpZ2F0aW9uIGluIHRoZSBsaXN0XG4gICAgICAgICAgICBpZiAoIW1lLmhhc05hdmlnYXRvcikge1xuICAgICAgICAgICAgICAgIG1lLm5hdmlnYXRvciA9IE5lby5tZXJnZSh7XG4gICAgICAgICAgICAgICAgICAgIGFwcE5hbWUgICAgICAgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgICAgICAgICBhdXRvQ2xpY2sgICAgIDogbWUuc2VsZWN0T25Gb2N1cyxcbiAgICAgICAgICAgICAgICAgICAgaWQgICAgICAgICAgICA6IG1lLmlkLFxuICAgICAgICAgICAgICAgICAgICBrZWVwRm9jdXNJbmRleDogbWUua2VlcEZvY3VzSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yICAgICAgOiBgLiR7bWUuaXRlbUNsc306bm90KC5uZW8tZGlzYWJsZWQsLm5lby1saXN0LWhlYWRlcilgLFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3dJZCAgICAgIDogbWUud2luZG93SWRcbiAgICAgICAgICAgICAgICB9LCBtZS5uYXZpZ2F0b3IpO1xuXG4gICAgICAgICAgICAgICAgbWUuaGFzTmF2aWdhdG9yID0gdHJ1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBOZW8ubWFpbi5hZGRvbi5OYXZpZ2F0b3Iuc3Vic2NyaWJlKG1lLm5hdmlnYXRvcilcbiAgICAgICAgfVxuXG4gICAgICAgIHN1cGVyLmFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzZWxlY3RlZEluZGV4IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTZWxlY3RlZEluZGV4KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7c2VsZWN0aW9uTW9kZWx9ID0gbWU7XG5cbiAgICAgICAgaWYgKE5lby5pc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbk1vZGVsPy5zZWxlY3RBdCh2YWx1ZSk7XG4gICAgICAgICAgICBtZS5oZWFkZXJsZXNzU2VsZWN0ZWRJbmRleCA9IG1lLmdldEhlYWRlcmxlc3NJbmRleCh2YWx1ZSlcbiAgICAgICAgfSBlbHNlIGlmIChOZW8uaXNOdW1iZXIob2xkVmFsdWUpKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25Nb2RlbC5kZXNlbGVjdEFsbCgpO1xuICAgICAgICAgICAgbWUuaGVhZGVybGVzc1NlbGVjdGVkSW5kZXggPSBudWxsXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNlbGVjdGlvbk1vZGVsIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TmVvLnNlbGVjdGlvbi5Nb2RlbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5zZWxlY3Rpb24uTW9kZWx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U2VsZWN0aW9uTW9kZWwodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMudm5vZGVJbml0aWFsaXplZCAmJiB2YWx1ZS5yZWdpc3Rlcih0aGlzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc3RvcmUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5TdG9yZX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLlN0b3JlfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFN0b3JlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHZhbHVlPy5vbih7XG4gICAgICAgICAgICBmaWx0ZXIgICAgICA6ICdvblN0b3JlRmlsdGVyJyxcbiAgICAgICAgICAgIGxvYWQgICAgICAgIDogJ29uU3RvcmVMb2FkJyxcbiAgICAgICAgICAgIHJlY29yZENoYW5nZTogJ29uU3RvcmVSZWNvcmRDaGFuZ2UnLFxuICAgICAgICAgICAgc29ydCAgICAgICAgOiAnb25TdG9yZVNvcnQnLFxuICAgICAgICAgICAgc2NvcGUgICAgICAgOiBtZVxuICAgICAgICB9KTtcblxuICAgICAgICB2YWx1ZT8uZ2V0Q291bnQoKSA+IDAgJiYgbWUub25TdG9yZUxvYWQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdXNlQ2hlY2tCb3hlcyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFVzZUNoZWNrQm94ZXModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2xzfSA9IG1lO1xuXG4gICAgICAgIE5lb0FycmF5LnRvZ2dsZShjbHMsICduZW8tdXNlLWNoZWNraWNvbnMnLCAhIXZhbHVlKTtcbiAgICAgICAgbWUuY2xzID0gY2xzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB1c2VIZWFkZXJzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VXNlSGVhZGVycyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgICAgICBtZS52ZG9tLnRhZyA9ICdkbCc7XG4gICAgICAgICAgICBtZS5pdGVtVGFnTmFtZSA9ICdkZCdcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdXNlV3JhcHBlck5vZGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRVc2VXcmFwcGVyTm9kZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjbHMsIHdyYXBwZXJDbHN9ID0gbWU7XG5cbiAgICAgICAgTmVvQXJyYXlbdmFsdWUgPyAnYWRkJyA6ICdyZW1vdmUnXShjbHMsICduZW8tdXNlLXdyYXBwZXItbm9kZScpO1xuICAgICAgICBOZW9BcnJheVt2YWx1ZSA/ICdhZGQnIDogJ3JlbW92ZSddKHdyYXBwZXJDbHMsICduZW8tbGlzdC13cmFwcGVyJyk7XG5cbiAgICAgICAgbWUud3JhcHBlckNscyA9IHdyYXBwZXJDbHM7XG4gICAgICAgIG1lLmNscyAgICAgICAgPSBjbHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHdpbmRvd0lkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFdpbmRvd0lkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldFdpbmRvd0lkKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgbGV0IHtuYXZpZ2F0b3J9ID0gdGhpcztcblxuICAgICAgICBpZiAodmFsdWUgJiYgbmF2aWdhdG9yKSB7XG4gICAgICAgICAgICBuYXZpZ2F0b3Iud2luZG93SWQgPSB2YWx1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgc2VsZWN0aW9uTW9kZWwgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge05lby5zZWxlY3Rpb24uTW9kZWx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uc2VsZWN0aW9uLk1vZGVsfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtOZW8uc2VsZWN0aW9uLk1vZGVsfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRTZWxlY3Rpb25Nb2RlbCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWU/LmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIENsYXNzU3lzdGVtVXRpbC5iZWZvcmVTZXRJbnN0YW5jZSh2YWx1ZSwgTGlzdE1vZGVsKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHN0b3JlIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R8TmVvLmRhdGEuU3RvcmV9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R8TmVvLmRhdGEuU3RvcmV9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge05lby5kYXRhLlN0b3JlfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRTdG9yZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWU/LmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIENsYXNzU3lzdGVtVXRpbC5iZWZvcmVTZXRJbnN0YW5jZSh2YWx1ZSwgU3RvcmUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgZm9yIGN1c3RvbSBsaXN0IGl0ZW1zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBsaXN0IGl0ZW0gdmRvbSBvYmplY3RcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtKHJlY29yZCwgaW5kZXgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY2xzICAgICAgICAgICAgICA9IFttZS5pdGVtQ2xzXSxcbiAgICAgICAgICAgIGhhc0l0ZW1IZWlnaHQgICAgPSBtZS5pdGVtSGVpZ2h0ICE9PSBudWxsLFxuICAgICAgICAgICAgaGFzSXRlbVdpZHRoICAgICA9IG1lLml0ZW1XaWR0aCAhPT0gbnVsbCxcbiAgICAgICAgICAgIGlzSGVhZGVyICAgICAgICAgPSBtZS51c2VIZWFkZXJzICYmIHJlY29yZC5pc0hlYWRlcixcbiAgICAgICAgICAgIGl0ZW1Db250ZW50ICAgICAgPSBtZS5jcmVhdGVJdGVtQ29udGVudChyZWNvcmQsIGluZGV4KSxcbiAgICAgICAgICAgIGl0ZW1JZCAgICAgICAgICAgPSBtZS5nZXRJdGVtSWQobWUuZ2V0UmVjb3JkSWQocmVjb3JkKSksXG4gICAgICAgICAgICB7c2VsZWN0aW9uTW9kZWx9ID0gbWUsXG4gICAgICAgICAgICBpc1NlbGVjdGVkICAgICAgID0gIW1lLmRpc2FibGVTZWxlY3Rpb24gJiYgc2VsZWN0aW9uTW9kZWw/LmlzU2VsZWN0ZWQoaXRlbUlkKSxcbiAgICAgICAgICAgIGl0ZW0sIHJlbW92ZURvbTtcblxuICAgICAgICBpc0hlYWRlciAmJiBjbHMucHVzaCgnbmVvLWxpc3QtaGVhZGVyJyk7XG5cbiAgICAgICAgaWYgKGlzU2VsZWN0ZWQpe1xuICAgICAgICAgICAgY2xzLnB1c2goc2VsZWN0aW9uTW9kZWwuc2VsZWN0ZWRDbHMpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVjb3JkLmNscykge1xuICAgICAgICAgICAgTmVvQXJyYXkuYWRkKGNscywgcmVjb3JkLmNscylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWNvcmRbbWUuZGlzYWJsZWRGaWVsZF0pIHtcbiAgICAgICAgICAgIGNscy5wdXNoKCduZW8tZGlzYWJsZWQnKVxuICAgICAgICB9XG5cbiAgICAgICAgaXRlbSA9IHtcbiAgICAgICAgICAgIGlkICA6IGl0ZW1JZCxcbiAgICAgICAgICAgIHRhZyA6IGlzSGVhZGVyID8gJ2R0JyA6IG1lLml0ZW1UYWdOYW1lLFxuICAgICAgICAgICAgJ2FyaWEtc2VsZWN0ZWQnIDogaXNTZWxlY3RlZCxcbiAgICAgICAgICAgIGNsc1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChtZS5pdGVtc0ZvY3VzYWJsZSkge1xuICAgICAgICAgICAgaXRlbS50YWJJbmRleCA9IC0xXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVjb3JkLmhpZGRlbiB8fCBpdGVtQ29udGVudC5yZW1vdmVEb20pIHtcbiAgICAgICAgICAgIGl0ZW0ucmVtb3ZlRG9tID0gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lLml0ZW1Sb2xlKSB7XG4gICAgICAgICAgICBpdGVtLnJvbGUgPSBtZS5pdGVtUm9sZVxuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChOZW8udHlwZU9mKGl0ZW1Db250ZW50KSkge1xuICAgICAgICAgICAgY2FzZSBudWxsOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnQXJyYXknOiB7XG4gICAgICAgICAgICAgICAgaXRlbS5jbiA9IGl0ZW1Db250ZW50O1xuXG4gICAgICAgICAgICAgICAgcmVtb3ZlRG9tID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIGl0ZW1Db250ZW50LmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXRlbS5yZW1vdmVEb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZURvbSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZURvbSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnJlbW92ZURvbSA9IHRydWVcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdPYmplY3QnOiB7XG4gICAgICAgICAgICAgICAgLy8gV2Ugd2FudCBhIG1lcmdlIGZvciBjdXN0b20gY2xzIHJ1bGVzXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1Db250ZW50LmNscykge1xuICAgICAgICAgICAgICAgICAgICBOZW9BcnJheS5hZGQoaXRlbS5jbHMsIGl0ZW1Db250ZW50LmNscyk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBpdGVtQ29udGVudC5jbHNcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGl0ZW0sIGl0ZW1Db250ZW50KTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgICAgICAgY2FzZSAnU3RyaW5nJzoge1xuICAgICAgICAgICAgICAgIGl0ZW0uaHRtbCA9IGl0ZW1Db250ZW50O1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzSXRlbUhlaWdodCB8fCBoYXNJdGVtV2lkdGgpIHtcbiAgICAgICAgICAgIGl0ZW0uc3R5bGUgPSBpdGVtLnN0eWxlIHx8IHt9O1xuXG4gICAgICAgICAgICBpZiAoaGFzSXRlbUhlaWdodCAmJiAhaXRlbS5oYXNPd25Qcm9wZXJ0eSgnaGVpZ2h0JykpIHtcbiAgICAgICAgICAgICAgICBpdGVtLnN0eWxlLmhlaWdodCA9IGAke21lLml0ZW1IZWlnaHR9cHhgXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChoYXNJdGVtV2lkdGggJiYgIWl0ZW0uaGFzT3duUHJvcGVydHkoJ3dpZHRoJykpIHtcbiAgICAgICAgICAgICAgICBpdGVtLnN0eWxlLndpZHRoID0gYCR7bWUuaXRlbVdpZHRofXB4YFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGl0ZW1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBmb3IgY3VzdG9tIHJlbmRlcmVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fE9iamVjdFtdfFN0cmluZ30gRWl0aGVyIGEgY29uZmlnIG9iamVjdCB0byBhc3NpZ24gdG8gdGhlIGl0ZW0sIGEgdmRvbSBjbiBhcnJheSBvciBhIGh0bWwgc3RyaW5nXG4gICAgICovXG4gICAgY3JlYXRlSXRlbUNvbnRlbnQocmVjb3JkLCBpbmRleCkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbVRleHQgPSByZWNvcmRbbWUuZGlzcGxheUZpZWxkXSxcbiAgICAgICAgICAgIGZpbHRlcjtcblxuICAgICAgICBpZiAobWUuaGlnaGxpZ2h0RmlsdGVyVmFsdWUpIHtcbiAgICAgICAgICAgIGZpbHRlciA9IG1lLnN0b3JlLmdldEZpbHRlcihtZS5kaXNwbGF5RmllbGQpO1xuXG4gICAgICAgICAgICBpZiAoZmlsdGVyICYmIGZpbHRlci52YWx1ZSAhPT0gbnVsbCAmJiBmaWx0ZXIudmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgaXRlbVRleHQgPSBpdGVtVGV4dC5yZXBsYWNlKG5ldyBSZWdFeHAoZmlsdGVyLnZhbHVlLCAnZ2knKSwgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICc8c3BhbiBjbGFzcz1cIm5lby1oaWdobGlnaHQtc2VhcmNoXCI+JyArIG1hdGNoICsgJzwvc3Bhbj4nXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpdGVtVGV4dFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50PWZhbHNlXG4gICAgICovXG4gICAgY3JlYXRlSXRlbXMoc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtoZWFkZXJsZXNzU2VsZWN0ZWRJbmRleH0gPSBtZSxcbiAgICAgICAgICAgIHZkb20gICAgICAgICAgICAgICAgICAgICAgPSBtZS5nZXRWZG9tUm9vdCgpLFxuICAgICAgICAgICAgbGlzdEl0ZW07XG5cbiAgICAgICAgLy8gaW4gY2FzZSB3ZSBzZXQgaGVhZGVybGVzc1NlbGVjdGVkSW5kZXggYmVmb3JlIHRoZSBzdG9yZSB3YXMgbG9hZGVkLCBzZWxlY3RlZEluZGV4IGNhbiBiZSBudWxsXG4gICAgICAgIC8vIGFuZCB0aGUgd2FudGVkIHNlbGVjdGlvbiBpcyBub3QgaW5pdGlhbGx5IHRoZXJlXG4gICAgICAgIGlmIChOZW8uaXNOdW1iZXIoaGVhZGVybGVzc1NlbGVjdGVkSW5kZXgpICYmICFOZW8uaXNOdW1iZXIobWUuc2VsZWN0ZWRJbmRleCkpIHtcbiAgICAgICAgICAgIG1lLmFmdGVyU2V0SGVhZGVybGVzc1NlbGVjdGVkSW5kZXgoaGVhZGVybGVzc1NlbGVjdGVkSW5kZXgsIG51bGwpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIShtZS5hbmltYXRlICYmICFtZS5nZXRQbHVnaW4oJ2xpc3QtYW5pbWF0ZScpKSkge1xuICAgICAgICAgICAgdmRvbS5jbiA9IFtdO1xuXG4gICAgICAgICAgICBtZS5zdG9yZS5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGxpc3RJdGVtID0gbWUuY3JlYXRlSXRlbShpdGVtLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgbGlzdEl0ZW0gJiYgdmRvbS5jbi5wdXNoKGxpc3RJdGVtKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICFzaWxlbnQgJiYgbWUucHJvbWlzZVVwZGF0ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1lLmZpcmUoJ2NyZWF0ZUl0ZW1zJylcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqL1xuICAgIGRlc3Ryb3koLi4uYXJncykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnNlbGVjdGlvbk1vZGVsPy5kZXN0cm95KCk7XG5cbiAgICAgICAgbWUuYXV0b0Rlc3Ryb3lTdG9yZSAmJiBtZS5zdG9yZT8uZGVzdHJveSgpO1xuXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koLi4uYXJncylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxscyBmb2N1cygpIG9uIHRoZSB0b3AgbGV2ZWwgRE9NIG5vZGUgb2YgdGhpcyBjb21wb25lbnQgb3Igb24gYSBnaXZlbiBub2RlIHZpYSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbaWQ9dGhpcy5pZF1cbiAgICAgKi9cbiAgICBmb2N1cyhpZD10aGlzLmlkKSB7XG4gICAgICAgIHRoaXMubW91bnRlZCAmJiBOZW8ubWFpbi5hZGRvbi5OYXZpZ2F0b3IubmF2aWdhdGVUbyh7XG4gICAgICAgICAgICBkYXRhICAgIDogdGhpcy5uYXZpZ2F0b3IsXG4gICAgICAgICAgICB0YXJnZXQgIDogaWQsXG4gICAgICAgICAgICB3aW5kb3dJZDogdGhpcy53aW5kb3dJZFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfE51bWJlcn1cbiAgICAgKi9cbiAgICBnZXRSZWNvcmRJZChyZWNvcmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXNlSW50ZXJuYWxJZCA/IHRoaXMuc3RvcmUuZ2V0SW50ZXJuYWxJZChyZWNvcmQpIDogdGhpcy5zdG9yZS5nZXRLZXkocmVjb3JkKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgYW4gaW5kZXggZXhjbHVkaW5nIGxpc3QgaXRlbSBoZWFkZXJzIGludG8gdGhlIHJlYWwgc3RvcmUgaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVhZGVybGVzc1NlbGVjdGVkSW5kZXhcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldFNlbGVjdGVkSW5kZXgoaGVhZGVybGVzc1NlbGVjdGVkSW5kZXgpIHtcbiAgICAgICAgbGV0IGRlbHRhICAgPSAwLFxuICAgICAgICAgICAgaSAgICAgICA9IDAsXG4gICAgICAgICAgICByZWNvcmRzID0gdGhpcy5zdG9yZS5pdGVtcyxcbiAgICAgICAgICAgIGxlbiAgICAgPSBoZWFkZXJsZXNzU2VsZWN0ZWRJbmRleDtcblxuICAgICAgICBpZiAocmVjb3Jkcy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICg7IGkgPD0gbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChyZWNvcmRzW2ldLmlzSGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgZGVsdGErKztcbiAgICAgICAgICAgICAgICBsZW4rK1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhlYWRlcmxlc3NTZWxlY3RlZEluZGV4ICsgZGVsdGFcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiBhIGxpc3QgaXRlbSBleGNsdWRpbmcgaXRlbSBoZWFkZXJzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRIZWFkZXJsZXNzSW5kZXgoaW5kZXgpIHtcbiAgICAgICAgbGV0IGhlYWRlcmxlc3NJbmRleCA9IDAsXG4gICAgICAgICAgICBpICAgICAgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgcmVjb3JkcyAgICAgICAgID0gdGhpcy5zdG9yZS5pdGVtcztcblxuICAgICAgICBmb3IgKDsgaSA8IGluZGV4OyBpKyspIHtcbiAgICAgICAgICAgIGlmICghcmVjb3Jkc1tpXS5pc0hlYWRlcikge1xuICAgICAgICAgICAgICAgIGhlYWRlcmxlc3NJbmRleCsrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaGVhZGVybGVzc0luZGV4XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG9iamVjdH0gcmVjb3JkT3JJZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0SXRlbUlkKHJlY29yZE9ySWQpIHtcbiAgICAgICAgbGV0IGlkID0gcmVjb3JkT3JJZDtcblxuICAgICAgICBpZiAocmVjb3JkT3JJZC5pc1JlY29yZCkge1xuICAgICAgICAgICAgaWQgPSB0aGlzLmdldFJlY29yZElkKHJlY29yZE9ySWQpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYCR7dGhpcy5pZH1fXyR7aWR9YFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2bm9kZUlkXG4gICAgICogQHJldHVybnMge1N0cmluZ3xOdW1iZXJ9IGl0ZW1JZFxuICAgICAqL1xuICAgIGdldEl0ZW1SZWNvcmRJZCh2bm9kZUlkKSB7XG4gICAgICAgIGxldCBpdGVtSWQgPSB2bm9kZUlkLnNwbGl0KCdfXycpWzFdO1xuXG4gICAgICAgIGlmICghdGhpcy51c2VJbnRlcm5hbElkICYmIHRoaXMuc3RvcmUuZ2V0S2V5VHlwZSgpPy5pbmNsdWRlcygnaW50JykpIHtcbiAgICAgICAgICAgIGl0ZW1JZCA9IHBhcnNlSW50KGl0ZW1JZClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpdGVtSWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdXBwb3J0IGNvbGxlY3Rpb25zICYgc3RvcmVzXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRLZXlQcm9wZXJ0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmUua2V5UHJvcGVydHkgfHwgdGhpcy5zdG9yZS5tb2RlbC5rZXlQcm9wZXJ0eVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25DbGljayhkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtO1xuXG4gICAgICAgIGlmIChkYXRhLnBhdGhbMF0uaWQgPT09IG1lLmlkKSB7XG4gICAgICAgICAgICBtZS5vbkNvbnRhaW5lckNsaWNrKGRhdGEpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGl0ZW0gb2YgZGF0YS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uY2xzLmluY2x1ZGVzKG1lLml0ZW1DbHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLm9uSXRlbUNsaWNrKGl0ZW0sIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25Db25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgc3VwZXIub25Db25zdHJ1Y3RlZCgpO1xuXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZWw/LnJlZ2lzdGVyKHRoaXMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkNvbnRhaW5lckNsaWNrKGRhdGEpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjb250YWluZXJDbGljayBldmVudCBmaXJlcyB3aGVuIGEgY2xpY2sgb2NjdXJzIG9uIHRoZSBjb21wb25lbnQsIGJ1dCBub3Qgb24gYSBsaXN0IGl0ZW1cbiAgICAgICAgICogQGV2ZW50IGNvbnRhaW5lckNsaWNrXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nW119IGNscyB0aGUgY2xhc3NMaXN0IG9mIHRoZSB0YXJnZXQgbm9kZSAoY29udmVydGVkIHRvIGFuIGFycmF5KVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgdGhlIHRhcmdldCBkb20gaWRcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmdbXX0gcGF0aCB0aGUgZXZlbnQgcGF0aFxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maXJlKCdjb250YWluZXJDbGljaycsIGRhdGEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uSXRlbUNsaWNrKG5vZGUsIGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICByZWNvcmQgPSBtZS5zdG9yZS5nZXQobWUuZ2V0SXRlbVJlY29yZElkKG5vZGUuaWQpKTtcblxuICAgICAgICAvLyBwYXNzIHRoZSByZWNvcmQgdG8gY2xhc3MgZXh0ZW5zaW9uc1xuICAgICAgICBkYXRhLnJlY29yZCA9IHJlY29yZDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGl0ZW1DbGljayBldmVudCBmaXJlcyB3aGVuIGEgY2xpY2sgb2NjdXJzIG9uIGEgbGlzdCBpdGVtXG4gICAgICAgICAqIEBldmVudCBpdGVtQ2xpY2tcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGlkIHRoZSByZWNvcmQgbWF0Y2hpbmcgdGhlIGxpc3QgaXRlbVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgbWUuZmlyZSgnaXRlbUNsaWNrJywge1xuICAgICAgICAgICAgcmVjb3JkXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvblN0b3JlRmlsdGVyKCkge1xuICAgICAgICB0aGlzLmNyZWF0ZUl0ZW1zKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uU3RvcmVMb2FkKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUubW91bnRlZCAmJiBtZS5pc1Zub2RlSW5pdGlhbGl6aW5nKSB7XG4gICAgICAgICAgICBtZS5vbignbW91bnRlZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBtZS5jcmVhdGVJdGVtcygpXG4gICAgICAgICAgICB9LCBtZSwge29uY2U6IHRydWV9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLmNyZWF0ZUl0ZW1zKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5maWVsZHMgRWFjaCBmaWVsZCBvYmplY3QgY29udGFpbnMgdGhlIGtleXM6IG5hbWUsIG9sZFZhbHVlLCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLmluZGV4XG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5Nb2RlbH0gZGF0YS5tb2RlbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhLnJlY29yZFxuICAgICAqL1xuICAgIG9uU3RvcmVSZWNvcmRDaGFuZ2UoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7aW5kZXh9ID0gZGF0YTtcblxuICAgICAgICAvLyBpZ25vcmUgY2hhbmdlcyBmb3IgcmVjb3JkcyB3aGljaCBoYXZlIG5vdCBiZWVuIGFkZGVkIHRvIHRoZSBsaXN0IHlldFxuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgbWUudmRvbS5jbltpbmRleF0gPSBtZS5jcmVhdGVJdGVtKGRhdGEucmVjb3JkLCBpbmRleCk7XG4gICAgICAgICAgICBtZS51cGRhdGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLml0ZW1zXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5wcmV2aW91c0l0ZW1zXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5TdG9yZX0gZGF0YS5zY29wZVxuICAgICAqL1xuICAgIG9uU3RvcmVTb3J0KGRhdGEpIHtcbiAgICAgICAgdGhpcy5jcmVhdGVJdGVtcygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGl0ZW1cbiAgICAgKi9cbiAgICBzZWxlY3RJdGVtKGl0ZW0pIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIW1lLmRpc2FibGVTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIC8vIFNlbGVjdGluZyBpbmRleFxuICAgICAgICAgICAgaWYgKE5lby5pc051bWJlcihpdGVtKSkge1xuICAgICAgICAgICAgICAgIG1lLnNlbGVjdGlvbk1vZGVsPy5zZWxlY3RBdChpdGVtKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2VsZWN0aW5nIHJlY29yZFxuICAgICAgICAgICAgZWxzZSBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIG1lLnNlbGVjdGlvbk1vZGVsPy5zZWxlY3RBdChtZS5zdG9yZS5pbmRleE9mKGl0ZW0pKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IHZhbHVlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlSXRlbUZvY3VzKHZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge25hdmlnYXRlVG99ID0gTmVvLm1haW4uYWRkb24uTmF2aWdhdG9yO1xuXG4gICAgICAgIGlmIChtZS5tb3VudGVkKSB7XG4gICAgICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG5hdmlnYXRlVG8oe1xuICAgICAgICAgICAgICAgICAgICBkYXRhICAgIDogbWUubmF2aWdhdG9yLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgIDogbWUuZ2V0SGVhZGVybGVzc0luZGV4KHZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgd2luZG93SWQ6IG1lLndpbmRvd0lkXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSAgICA6IG1lLm5hdmlnYXRvcixcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ICA6IG1lLmdldEl0ZW1JZChtZS5nZXRSZWNvcmRJZCh2YWx1ZSkpLFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3dJZDogbWUud2luZG93SWRcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUub24oJ21vdW50ZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gV2UgY291bGQgc3Vic2NyaWJlIG11bHRpcGxlIHRpbWVzIGJlZm9yZSBnZXR0aW5nIG1vdW50ZWQsXG4gICAgICAgICAgICAgICAgLy8gc28gb25seSB0cmlnZ2VyIHRoZSBjYWxsYmFjayBmb3IgdGhlIGxhc3QgZm9jdXNJbmRleFxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbWUuZm9jdXNJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBtZS51cGRhdGVJdGVtRm9jdXMobWUuZm9jdXNJbmRleClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBtZSwge29uY2U6IHRydWV9KVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhMaXN0KTtcbiIsImltcG9ydCBNYW5hZ2VyIGZyb20gJy4vQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8ubWFuYWdlci5TdG9yZVxuICogQGV4dGVuZHMgTmVvLm1hbmFnZXIuQmFzZVxuICogQHNpbmdsZXRvblxuICovXG5jbGFzcyBTdG9yZSBleHRlbmRzIE1hbmFnZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLm1hbmFnZXIuU3RvcmUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5tYW5hZ2VyLlN0b3JlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZXRvbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZXRvbjogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuICAgICAgICBcbiAgICAgICAgLy8gQWxpYXMgTmVvLmdldFN0b3JlIHRvIHRoaXMgbWFuYWdlcj9cbiAgICAgICAgLy8gTmVvLmdldFN0b3JlID0gdGhpcy5nZXQuYmluZCh0aGlzKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFN0b3JlKTtcbiIsImltcG9ydCBCYXNlTGlzdCAgZnJvbSAnLi4vbGlzdC9CYXNlLm1qcyc7XG5pbXBvcnQgTGlzdE1vZGVsIGZyb20gJy4uL3NlbGVjdGlvbi9tZW51L0xpc3RNb2RlbC5tanMnO1xuaW1wb3J0IFN0b3JlICAgICBmcm9tICcuL1N0b3JlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5tZW51Lkxpc3RcbiAqIEBleHRlbmRzIE5lby5saXN0LkJhc2VcbiAqL1xuY2xhc3MgTGlzdCBleHRlbmRzIEJhc2VMaXN0IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5tZW51Lkxpc3QnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5tZW51Lkxpc3QnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nbWVudS1saXN0J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ21lbnUtbGlzdCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWFkIG9ubHkuIFdlIGFyZSBzdG9yaW5nIHRoZSBjdXJyZW50bHkgdmlzaWJsZSBzdWJNZW51IGluc3RhbmNlLlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8ubWVudS5MaXN0fE5lby5tZW51LlBhbmVsfG51bGx9IGFjdGl2ZVN1Yk1lbnU9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZlU3ViTWVudTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLW1lbnUtbGlzdCcsJ25lby1saXN0J11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLW1lbnUtbGlzdCcsICduZW8tbGlzdCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogc2V0VGltZW91dCgpIGlkIGFmdGVyIGEgZm9jdXMtbGVhdmUgZXZlbnQuXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBmb2N1c1RpbWVvdXRJZD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGZvY3VzVGltZW91dElkOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogSGlkZXMgYSBmbG9hdGluZyBsaXN0IG9uIGxlYWYgaXRlbSBjbGljaywgaW4gY2FzZSBpdCBoYXMgYSBwYXJlbnRDb21wb25lbnRcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaGlkZU9uTGVhZkl0ZW1DbGljaz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBoaWRlT25MZWFmSXRlbUNsaWNrOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogT3B0aW9uYWxseSBwYXNzIG1lbnUuU3RvcmUgZGF0YSBkaXJlY3RseVxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3RbXXxudWxsfSBpdGVtc189bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1zXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGZsYWcuXG4gICAgICAgICAqIFN1Yi1tZW51cyB3aWxsIGJ1YmJsZSBmb2N1cyBjaGFuZ2VzIHRvIHRoZSB0b3AgbGV2ZWwuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG1lbnVGb2N1c189ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIG1lbnVGb2N1c186IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgZmxhZy5cbiAgICAgICAgICogVHJ1ZSBmb3IgYSB0b3AgbGV2ZWwgbWVudSwgZmFsc2UgZm9yIHN1Yi1tZW51cy5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNSb290PXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaXNSb290OiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcmluZyB0aGUgbGlzdCBpdGVtIGluZGV4IG9mIHRoZSBwYXJlbnQgbWVudSBpbiBjYXNlIGl0IGV4aXN0cy5cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBwYXJlbnRJbmRleD0wXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHBhcmVudEluZGV4OiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcmluZyBhIHJlZmVyZW5jZSB0byB0aGUgcGFyZW50IG1lbnUgaW4gY2FzZSBpdCBleGlzdHMuXG4gICAgICAgICAqIEBtZW1iZXIge05lby5tZW51Lkxpc3R8TmVvLm1lbnUuUGFuZWx8bnVsbH0gcGFyZW50TWVudT1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHBhcmVudE1lbnU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWx1ZSBmb3IgdGhlIGxpc3QuQmFzZSBzZWxlY3Rpb25Nb2RlbF8gY29uZmlnXG4gICAgICAgICAqIEBtZW1iZXIge05lby5zZWxlY3Rpb24ubWVudS5MaXN0TW9kZWx9IHNlbGVjdGlvbk1vZGVsPUxpc3RNb2RlbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHNlbGVjdGlvbk1vZGVsOiBMaXN0TW9kZWwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWx1ZSBmb3IgdGhlIGxpc3QuQmFzZSBzdG9yZV8gY29uZmlnXG4gICAgICAgICAqIEBtZW1iZXIge05lby5tZW51LlN0b3JlfSBzdG9yZT1TdG9yZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHN0b3JlOiBTdG9yZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkaXN0YW5jZSBpbiBweCBiZXR3ZWVuIGEgbWVudSBhbmQgYSBjaGlsZCBtZW51XG4gICAgICAgICAqIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL25lb21qcy9uZW8vaXNzdWVzLzI1NjlcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBzdWJNZW51R2FwPTBcbiAgICAgICAgICovXG4gICAgICAgIHN1Yk1lbnVHYXA6IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9yaW5nIGNoaWxkTWVudXMgYnkgcmVjb3JkIGtleVByb3BlcnR5XG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gc3ViTWVudU1hcD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHN1Yk1lbnVNYXA6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZSBhcmUgYXBwbHlpbmcgYSB6LWluZGV4IHN0eWxlIHdoaWNoIGlzIDEgbnVtYmVyIGhpZ2hlciB0byBlYWNoIHN1Yi1tZW51XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gekluZGV4Xz0xMDBcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB6SW5kZXhfOiAxMDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IF92ZG9tXG4gICAgICAgICAqL1xuICAgICAgICBfdmRvbTpcbiAgICAgICAge3RhZzogJ3VsJywgY246IFtdfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBtZW51IGlzIGZsb2F0aW5nLCBpdCB3aWxsIGFuY2hvciBpdHNlbGYgdG8gdGhlIHBhcmVudFJlY3RcbiAgICAgKiBAbWVtYmVyIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH0gcGFyZW50Q29tcG9uZW50PW51bGxcbiAgICAgKiBAcmVhY3RpdmVcbiAgICAgKi9cbiAgICBwYXJlbnRDb21wb25lbnQgPSBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGl0ZW1zIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRJdGVtcyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IHtzdG9yZX0gPSB0aGlzO1xuXG4gICAgICAgIG9sZFZhbHVlICYmIHN0b3JlLmNsZWFyKCk7IC8vIHdlIGNhbiBub3QgdXNlIHJlbW92ZSgpIGhlcmUsIHNpbmNlIGl0ZW1zIGFyZSBubyByZWNvcmRzID0+IG9mdGVuIG5vIGlkXG4gICAgICAgIHZhbHVlICAgICYmIHN0b3JlLmFkZCh2YWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1lbnVGb2N1cyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1lbnVGb2N1cyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIGlmIChtZS5pc1Jvb3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmZvY3VzVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZVttZS5mbG9hdGluZyA/ICd1bm1vdW50JyA6ICdoaWRlU3ViTWVudSddKClcbiAgICAgICAgICAgICAgICAgICAgfSwgMjApXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KG1lLmZvY3VzVGltZW91dElkKTtcbiAgICAgICAgICAgICAgICAgICAgbWUuZm9jdXNUaW1lb3V0SWQgPSBudWxsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBidWJibGUgdGhlIGZvY3VzIGNoYW5nZSB1cHdhcmRzXG4gICAgICAgICAgICAgICAgbWUucGFyZW50TWVudS5tZW51Rm9jdXMgPSB2YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB0aGVtZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VGhlbWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0VGhlbWUodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBPYmplY3QudmFsdWVzKHRoaXMuc3ViTWVudU1hcCB8fCB7fSkuZm9yRWFjaChtZW51ID0+IHtcbiAgICAgICAgICAgIG1lbnUudGhlbWUgPSB2YWx1ZVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgekluZGV4IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFpJbmRleCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdHlsZSA9IHsuLi50aGlzLnN0eWxlLCB6SW5kZXg6IHZhbHVlfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGZvciBjdXN0b20gcmVuZGVyZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8T2JqZWN0W118U3RyaW5nfSBFaXRoZXIgYSBjb25maWcgb2JqZWN0IHRvIGFzc2lnbiB0byB0aGUgaXRlbSwgYSB2ZG9tIGNuIGFycmF5IG9yIGEgaHRtbCBzdHJpbmdcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtQ29udGVudChyZWNvcmQsIGluZGV4KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2ljb25DbHN9ID0gcmVjb3JkLFxuICAgICAgICAgICAgaWQgICAgICAgID0gbWUuc3RvcmUuZ2V0S2V5KHJlY29yZCksXG4gICAgICAgICAgICB2ZG9tQ24gICAgPSBbe3RhZzogJ3NwYW4nLCBjbHM6IFsnbmVvLWNvbnRlbnQnXSwgdGV4dDogcmVjb3JkW21lLmRpc3BsYXlGaWVsZF19XTtcblxuICAgICAgICBpZiAoaWNvbkNscyAmJiBpY29uQ2xzICE9PSAnJykge1xuICAgICAgICAgICAgdmRvbUNuLnVuc2hpZnQoe3RhZzogJ2knLCBjbHM6IFsnbmVvLW1lbnUtaWNvbicsICduZW8taWNvbicsIGljb25DbHNdLCBpZDogbWUuZ2V0SWNvbklkKGlkKX0pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWUuaGFzQ2hpbGRyZW4ocmVjb3JkKSkge1xuICAgICAgICAgICAgdmRvbUNuLnB1c2goe3RhZzogJ2knLCBjbHM6IFsnbmVvLWFycm93LWljb24nLCAnbmVvLWljb24nLCAnZmFzIGZhLWNoZXZyb24tcmlnaHQnXSwgaWQ6IG1lLmdldEFycm93SWNvbklkKGlkKX0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmRvbUNuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBkZXN0cm95KC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7YWN0aXZlU3ViTWVudX0gPSBtZSxcbiAgICAgICAgICAgIHN1Yk1lbnVNYXAgICAgICA9IG1lLnN1Yk1lbnVNYXAgfHwge307XG5cbiAgICAgICAgYWN0aXZlU3ViTWVudT8udW5tb3VudCgpO1xuXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHN1Yk1lbnVNYXApLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgdmFsdWUuZGVzdHJveSgpO1xuICAgICAgICAgICAgc3ViTWVudU1hcFtrZXldID0gbnVsbFxuICAgICAgICB9KTtcblxuICAgICAgICBzdXBlci5kZXN0cm95KC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSByZWNvcmRJZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0QXJyb3dJY29uSWQocmVjb3JkSWQpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWR9X19hcnJvd19pY29uX18ke3JlY29yZElkfWBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHJlY29yZElkXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRJY29uSWQocmVjb3JkSWQpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWR9X19pY29uX18ke3JlY29yZElkfWBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZWNvcmRJZHMgY2FuIGJlIE51bWJlcnMsIHNvIHdlIGRvIG5lZWQgYSBwcmVmaXhcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHJlY29yZElkXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRNZW51TWFwSWQocmVjb3JkSWQpIHtcbiAgICAgICAgcmV0dXJuIGBtZW51X18ke3JlY29yZElkfWBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSByZWNvcmQgaGFzIGl0ZW1zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGhhc0NoaWxkcmVuKHJlY29yZCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShyZWNvcmQuaXRlbXMpICYmIHJlY29yZC5pdGVtcy5sZW5ndGggPiAwXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBoaWRlU3ViTWVudSgpIHtcbiAgICAgICAgbGV0IHthY3RpdmVTdWJNZW51fSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKGFjdGl2ZVN1Yk1lbnUpIHtcbiAgICAgICAgICAgIGFjdGl2ZVN1Yk1lbnUudW5tb3VudCgpO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVTdWJNZW51ID0gbnVsbFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLnBhdGhcbiAgICAgKi9cbiAgICBvbkZvY3VzRW50ZXIoZGF0YSkge1xuICAgICAgICBzdXBlci5vbkZvY3VzRW50ZXIoZGF0YSk7XG4gICAgICAgIHRoaXMubWVudUZvY3VzID0gdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5vbGRQYXRoXG4gICAgICovXG4gICAgb25Gb2N1c0xlYXZlKGRhdGEpIHtcbiAgICAgICAgc3VwZXIub25Gb2N1c0xlYXZlKGRhdGEpO1xuXG4gICAgICAgIGxldCBpbnNpZGVQYXJlbnQgPSBmYWxzZSxcbiAgICAgICAgICAgIHBhcmVudElkICAgICA9IHRoaXMucGFyZW50Q29tcG9uZW50Py5pZCxcbiAgICAgICAgICAgIGl0ZW07XG5cbiAgICAgICAgaWYgKHBhcmVudElkKSB7XG4gICAgICAgICAgICBmb3IgKGl0ZW0gb2YgZGF0YS5vbGRQYXRoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uaWQgPT09IHBhcmVudElkKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc2lkZVBhcmVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpbnNpZGVQYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMubWVudUZvY3VzID0gZmFsc2VcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkl0ZW1DbGljayhub2RlLCBkYXRhKSB7XG4gICAgICAgIHN1cGVyLm9uSXRlbUNsaWNrKG5vZGUsIGRhdGEpO1xuXG4gICAgICAgIHRoaXMub25LZXlEb3duRW50ZXIobm9kZS5pZClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbm9kZUlkXG4gICAgICovXG4gICAgb25LZXlEb3duRW50ZXIobm9kZUlkKSB7XG4gICAgICAgIGlmIChub2RlSWQpIHtcbiAgICAgICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgcmVjb3JkSWQgPSBtZS5nZXRJdGVtUmVjb3JkSWQobm9kZUlkKSxcbiAgICAgICAgICAgICAgICByZWNvcmQgICA9IG1lLnN0b3JlLmdldChyZWNvcmRJZCksXG4gICAgICAgICAgICAgICAgc3VibWVudTtcblxuICAgICAgICAgICAgbWUuY2FsbGJhY2socmVjb3JkLmhhbmRsZXIsIG1lLCBbcmVjb3JkXSk7XG5cbiAgICAgICAgICAgIHJlY29yZC5yb3V0ZSAmJiBOZW8uTWFpbi5zZXRSb3V0ZSh7XG4gICAgICAgICAgICAgICAgYXBwTmFtZTogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZSAgOiByZWNvcmQucm91dGVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS5oaWRlT25MZWFmSXRlbUNsaWNrICYmICFyZWNvcmQuaXRlbXMgJiYgbWUudW5tb3VudCgpO1xuXG4gICAgICAgICAgICBpZiAocmVjb3JkLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgc3VibWVudSA9IG1lLnN1Yk1lbnVNYXA/LlttZS5nZXRNZW51TWFwSWQocmVjb3JkSWQpXTtcblxuICAgICAgICAgICAgICAgIGlmIChzdWJtZW51KSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnRvZ2dsZVN1Yk1lbnUobm9kZUlkLCByZWNvcmQpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbktleURvd25Fc2NhcGUoZGF0YSkge1xuICAgICAgICB0aGlzLmZsb2F0aW5nICYmIHRoaXMudW5tb3VudCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gaXRlbXNcbiAgICAgKi9cbiAgICBvblNlbGVjdChpdGVtcykge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgbm9kZUlkICAgPSBpdGVtc1swXSxcbiAgICAgICAgICAgIHJlY29yZElkID0gbWUuZ2V0SXRlbVJlY29yZElkKG5vZGVJZCksXG4gICAgICAgICAgICByZWNvcmQgICA9IG1lLnN0b3JlLmdldChyZWNvcmRJZCk7XG5cbiAgICAgICAgaWYgKG1lLmFjdGl2ZVN1Yk1lbnUgIT09IG1lLnN1Yk1lbnVNYXA/LlttZS5nZXRNZW51TWFwSWQocmVjb3JkSWQpXSkge1xuICAgICAgICAgICAgbWUuaGlkZVN1Yk1lbnUoKTtcbiAgICAgICAgICAgIG1lLmhhc0NoaWxkcmVuKHJlY29yZCkgJiYgbWUuc2hvd1N1Yk1lbnUobm9kZUlkLCByZWNvcmQpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbm9kZUlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqL1xuICAgIHNob3dTdWJNZW51KG5vZGVJZCwgcmVjb3JkKSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3N0b3JlfSAgICAgID0gbWUsXG4gICAgICAgICAgICByZWNvcmRJZCAgICAgPSBzdG9yZS5nZXRLZXkocmVjb3JkKSxcbiAgICAgICAgICAgIHN1Yk1lbnVNYXAgICA9IG1lLnN1Yk1lbnVNYXAgfHwgKG1lLnN1Yk1lbnVNYXAgPSB7fSksXG4gICAgICAgICAgICBzdWJNZW51TWFwSWQgPSBtZS5nZXRNZW51TWFwSWQocmVjb3JkSWQpLFxuICAgICAgICAgICAgc3ViTWVudSAgICAgID0gc3ViTWVudU1hcFtzdWJNZW51TWFwSWRdIHx8IChzdWJNZW51TWFwW3N1Yk1lbnVNYXBJZF0gPSBOZW8uY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBtb2R1bGUgICAgICAgICA6IExpc3QsXG4gICAgICAgICAgICAgICAgYWxpZ24gICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCAgICAgICA6IG5vZGVJZCxcbiAgICAgICAgICAgICAgICAgICAgZWRnZUFsaWduICAgIDogJ2wwLXIwJyxcbiAgICAgICAgICAgICAgICAgICAgYXhpc0xvY2sgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0TWFyZ2luIDogbWUuc3ViTWVudUdhcFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYXBwTmFtZSAgICAgICAgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgICAgIGRpc3BsYXlGaWVsZCAgIDogbWUuZGlzcGxheUZpZWxkLFxuICAgICAgICAgICAgICAgIGZsb2F0aW5nICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpdGVtcyAgICAgICAgICA6IHJlY29yZC5pdGVtcyxcbiAgICAgICAgICAgICAgICBpc1Jvb3QgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHBhcmVudENvbXBvbmVudDogbWUucGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgICAgIHBhcmVudElkICAgICAgIDogbWUuYXBwLm1haW5WaWV3LmlkLFxuICAgICAgICAgICAgICAgIHBhcmVudEluZGV4ICAgIDogc3RvcmUuaW5kZXhPZihyZWNvcmQpLFxuICAgICAgICAgICAgICAgIHBhcmVudE1lbnUgICAgIDogbWUsXG4gICAgICAgICAgICAgICAgdGhlbWUgICAgICAgICAgOiBtZS50aGVtZSxcbiAgICAgICAgICAgICAgICB6SW5kZXggICAgICAgICA6IG1lLnpJbmRleCArIDFcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICBpZiAobWUuYWN0aXZlU3ViTWVudSAhPT0gc3ViTWVudSkge1xuICAgICAgICAgICAgbWUuYWN0aXZlU3ViTWVudSA9IHN1Yk1lbnU7XG4gICAgICAgICAgICBzdWJNZW51LmluaXRWbm9kZSh0cnVlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5vZGVJZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAgICAgKi9cbiAgICB0b2dnbGVTdWJNZW51KG5vZGVJZCwgcmVjb3JkKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICByZWNvcmRJZCA9IG1lLnN0b3JlLmdldEtleShyZWNvcmQpLFxuICAgICAgICAgICAgc3VibWVudSAgPSBtZS5zdWJNZW51TWFwPy5bbWUuZ2V0TWVudU1hcElkKHJlY29yZElkKV07XG5cbiAgICAgICAgaWYgKCFzdWJtZW51Py5tb3VudGVkKSB7XG4gICAgICAgICAgICBtZS5zaG93U3ViTWVudShub2RlSWQsIHJlY29yZClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLmhpZGVTdWJNZW51KClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgdW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbD8uZGVzZWxlY3RBbGwodHJ1ZSk7IC8vIHNpbGVudCB1cGRhdGVcbiAgICAgICAgdGhpcy5oaWRlU3ViTWVudSgpO1xuXG4gICAgICAgIHN1cGVyLnVubW91bnQoKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoTGlzdCk7XG4iLCJpbXBvcnQgQmFzZU1vZGVsIGZyb20gJy4uLy4uL3NyYy9kYXRhL01vZGVsLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5tZW51Lk1vZGVsXG4gKiBAZXh0ZW5kcyBOZW8uZGF0YS5Nb2RlbFxuICovXG5jbGFzcyBNb2RlbCBleHRlbmRzIEJhc2VNb2RlbCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ubWVudS5Nb2RlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLm1lbnUuTW9kZWwnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBrZXlQcm9wZXJ0eT0naWQnXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAga2V5UHJvcGVydHk6ICdpZCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gZmllbGRzXG4gICAgICAgICAqL1xuICAgICAgICBmaWVsZHM6IFt7XG4gICAgICAgICAgICBuYW1lOiAnY2xzJyxcbiAgICAgICAgICAgIHR5cGU6ICdBcnJheSdcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ2hhbmRsZXInLFxuICAgICAgICAgICAgdHlwZTogJ0Z1bmN0aW9uJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiAnaGlkZGVuJyxcbiAgICAgICAgICAgIHR5cGU6ICdCb29sZWFuJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiAnaWNvbkNscycsXG4gICAgICAgICAgICB0eXBlOiAnU3RyaW5nJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiAnaWQnLFxuICAgICAgICAgICAgdHlwZTogJ0ludGVnZXInXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6ICdpdGVtcycsIC8vIG9wdGlvbmFsXG4gICAgICAgICAgICB0eXBlOiAnQXJyYXknXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6ICdyb3V0ZScsXG4gICAgICAgICAgICB0eXBlOiAnU3RyaW5nJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiAndGV4dCcsXG4gICAgICAgICAgICB0eXBlOiAnU3RyaW5nJ1xuICAgICAgICB9XVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoTW9kZWwpO1xuIiwiaW1wb3J0IE1vZGVsICAgICBmcm9tICcuL01vZGVsLm1qcyc7XG5pbXBvcnQgQmFzZVN0b3JlIGZyb20gJy4uLy4uL3NyYy9kYXRhL1N0b3JlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5tZW51LlN0b3JlXG4gKiBAZXh0ZW5kcyBOZW8uZGF0YS5TdG9yZVxuICovXG5jbGFzcyBTdG9yZSBleHRlbmRzIEJhc2VTdG9yZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ubWVudS5TdG9yZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLm1lbnUuU3RvcmUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLm1lbnUuTW9kZWx9IG1vZGVsPU1vZGVsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbW9kZWw6IE1vZGVsXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhTdG9yZSk7XG4iLCJpbXBvcnQgTW9kZWwgZnJvbSAnLi9Nb2RlbC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uc2VsZWN0aW9uLkxpc3RNb2RlbFxuICogQGV4dGVuZHMgTmVvLnNlbGVjdGlvbi5Nb2RlbFxuICovXG5jbGFzcyBMaXN0TW9kZWwgZXh0ZW5kcyBNb2RlbCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uc2VsZWN0aW9uLkxpc3RNb2RlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnNlbGVjdGlvbi5MaXN0TW9kZWwnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nc2VsZWN0aW9uLWxpc3Rtb2RlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdzZWxlY3Rpb24tbGlzdG1vZGVsJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBsYWNlaG9sZGVyIG1ldGhvZCB0byBnZXQgb3ZlcnJpZGRlbiBieSBjbGFzcyBleHRlbnNpb24gbGlzdCBtZW51Lkxpc3RNb2RlbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25LZXlEb3duRXNjYXBlKGRhdGEpIHt9XG5cbiAgICAvKipcbiAgICAgKiBQbGFjZWhvbGRlciBtZXRob2QgdG8gZ2V0IG92ZXJyaWRkZW4gYnkgY2xhc3MgZXh0ZW5zaW9uIGxpc3QgbWVudS5MaXN0TW9kZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uS2V5RG93bkRvd24oZGF0YSkge31cblxuICAgIC8qKlxuICAgICAqIFBsYWNlaG9sZGVyIG1ldGhvZCB0byBnZXQgb3ZlcnJpZGRlbiBieSBjbGFzcyBleHRlbnNpb24gbGlzdCBtZW51Lkxpc3RNb2RlbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25LZXlEb3duRW50ZXIoZGF0YSkge31cblxuICAgIC8qKlxuICAgICAqIFBsYWNlaG9sZGVyIG1ldGhvZCB0byBnZXQgb3ZlcnJpZGRlbiBieSBjbGFzcyBleHRlbnNpb24gbGlzdCBtZW51Lkxpc3RNb2RlbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25LZXlEb3duTGVmdChkYXRhKSB7fVxuXG4gICAgLyoqXG4gICAgICogUGxhY2Vob2xkZXIgbWV0aG9kIHRvIGdldCBvdmVycmlkZGVuIGJ5IGNsYXNzIGV4dGVuc2lvbiBsaXN0IG1lbnUuTGlzdE1vZGVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbktleURvd25SaWdodChkYXRhKSB7fVxuXG4gICAgLyoqXG4gICAgICogUGxhY2Vob2xkZXIgbWV0aG9kIHRvIGdldCBvdmVycmlkZGVuIGJ5IGNsYXNzIGV4dGVuc2lvbiBsaXN0IG1lbnUuTGlzdE1vZGVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbktleURvd25VcChkYXRhKSB7fVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkxpc3RDbGljayh7Y3VycmVudFRhcmdldH0pIHtcbiAgICAgICAgbGV0IHt2aWV3fSA9IHRoaXMsXG4gICAgICAgICAgICBpZCAgICAgPSB2aWV3LmdldEl0ZW1SZWNvcmRJZChjdXJyZW50VGFyZ2V0KSxcbiAgICAgICAgICAgIHJlY29yZCA9IHZpZXcuc3RvcmUuZ2V0KGlkKTtcblxuICAgICAgICBpZiAoIXZpZXcuZGlzYWJsZVNlbGVjdGlvbikge1xuICAgICAgICAgICAgcmVjb3JkICYmIHRoaXMuc2VsZWN0KHJlY29yZClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25MaXN0TmF2aWdhdGUoZGF0YSkge1xuICAgICAgICBsZXQge3ZpZXd9ICA9IHRoaXMsXG4gICAgICAgICAgICB7c3RvcmV9ID0gdmlldyxcbiAgICAgICAgICAgIHJlY29yZCwgcmVjb3JkSWQ7XG5cbiAgICAgICAgaWYgKGRhdGEuYWN0aXZlSXRlbSkge1xuICAgICAgICAgICAgcmVjb3JkSWQgPSB2aWV3LmdldEl0ZW1SZWNvcmRJZChkYXRhLmFjdGl2ZUl0ZW0pO1xuICAgICAgICAgICAgcmVjb3JkICAgPSBzdG9yZS5nZXQocmVjb3JkSWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZWNvcmQpIHtcbiAgICAgICAgICAgIHJlY29yZCA9IHN0b3JlLmdldEF0KE1hdGgubWluKGRhdGEuYWN0aXZlSW5kZXgsIHN0b3JlLmdldENvdW50KCkpKVxuICAgICAgICB9XG5cbiAgICAgICAgZGF0YS5yZWNvcmQgICAgICA9IHJlY29yZDtcbiAgICAgICAgdmlldy5fZm9jdXNJbmRleCA9IHN0b3JlLmluZGV4T2YocmVjb3JkKTsgLy8gc2lsZW50IHVwZGF0ZSwgbm8gbmVlZCB0byByZWZvY3VzXG5cbiAgICAgICAgdmlldy5maXJlKCdpdGVtTmF2aWdhdGUnLCBkYXRhKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBjb21wb25lbnRcbiAgICAgKi9cbiAgICByZWdpc3Rlcihjb21wb25lbnQpIHtcbiAgICAgICAgc3VwZXIucmVnaXN0ZXIoY29tcG9uZW50KTtcblxuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7aWQsIHZpZXd9ID0gbWU7XG5cbiAgICAgICAgdmlldy5hZGREb21MaXN0ZW5lcnMoW3tcbiAgICAgICAgICAgIGNsaWNrOiBtZS5vbkxpc3RDbGljayxcbiAgICAgICAgICAgIHNjb3BlOiBtZSxcblxuICAgICAgICAgICAgLy8gU2hvdWxkIGJlIGAuJHt2aWV3Lml0ZW1DbHN9Om5vdCgubmVvLWRpc2FibGVkLC5uZW8tbGlzdC1oZWFkZXIpYFxuICAgICAgICAgICAgLy8gVE9ETyBwYXJzZSBkZWxlZ2F0ZSBzZWxlY3RvcnNcbiAgICAgICAgICAgIGRlbGVnYXRlOiBwYXRoID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgeyBsZW5ndGggfSA9IHBhdGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGNscyB9ID0gcGF0aFtpXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY2xzLmluY2x1ZGVzKHZpZXcuaXRlbUNscykgJiYgIWNscy5pbmNsdWRlcygnbmVvLWRpc2FibGVkJykgJiYgIWNscy5pbmNsdWRlcygnbmVvLWxpc3QtaGVhZGVyJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuZW9uYXZpZ2F0ZSA6IG1lLm9uTGlzdE5hdmlnYXRlLFxuICAgICAgICAgICAgc2NvcGUgICAgICAgOiBtZVxuICAgICAgICB9XSk7XG5cbiAgICAgICAgdmlldy5rZXlzPy5fa2V5cy5wdXNoKFxuICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duRG93bicgICAsa2V5OiAnRG93bicgICAsc2NvcGU6IGlkfSxcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93bkVudGVyJyAgLGtleTogJ0VudGVyJyAgLHNjb3BlOiBpZH0sXG4gICAgICAgICAgICB7Zm46ICdvbktleURvd25Fc2NhcGUnICxrZXk6ICdFc2NhcGUnICxzY29wZTogaWR9LFxuICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duTGVmdCcgICAsa2V5OiAnTGVmdCcgICAsc2NvcGU6IGlkfSxcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93blJpZ2h0JyAgLGtleTogJ1JpZ2h0JyAgLHNjb3BlOiBpZH0sXG4gICAgICAgICAgICB7Zm46ICdvbktleURvd25VcCcgICAgICxrZXk6ICdVcCcgICAgICxzY29wZTogaWR9XG4gICAgICAgIClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKi9cbiAgICBzZWxlY3RBdChpbmRleCkge1xuICAgICAgICBsZXQge3ZpZXd9ID0gdGhpcyxcbiAgICAgICAgICAgIHJlY29yZCA9IHZpZXc/LnN0b3JlLmdldEF0KGluZGV4KSxcbiAgICAgICAgICAgIGl0ZW1JZCA9IHJlY29yZCAmJiB2aWV3LmdldEl0ZW1JZCh2aWV3LmdldFJlY29yZElkKHJlY29yZCkpO1xuXG4gICAgICAgIGl0ZW1JZCAmJiB0aGlzLnNlbGVjdChpdGVtSWQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICB1bnJlZ2lzdGVyKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7aWQsIHZpZXd9ID0gbWU7XG5cbiAgICAgICAgdmlldy5rZXlzPy5yZW1vdmVLZXlzKFtcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93bkRvd24nICAgLGtleTogJ0Rvd24nICAgLHNjb3BlOiBpZH0sXG4gICAgICAgICAgICB7Zm46ICdvbktleURvd25FbnRlcicgICxrZXk6ICdFbnRlcicgICxzY29wZTogaWR9LFxuICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duRXNjYXBlJyAsa2V5OiAnRXNjYXBlJyAsc2NvcGU6IGlkfSxcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93bkxlZnQnICAgLGtleTogJ0xlZnQnICAgLHNjb3BlOiBpZH0sXG4gICAgICAgICAgICB7Zm46ICdvbktleURvd25SaWdodCcgICxrZXk6ICdSaWdodCcgICxzY29wZTogaWR9LFxuICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duVXAnICAgICAsa2V5OiAnVXAnICAgICAsc2NvcGU6IGlkfVxuICAgICAgICBdKTtcblxuICAgICAgICBzdXBlci51bnJlZ2lzdGVyKClcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKExpc3RNb2RlbCk7XG4iLCJpbXBvcnQgQmFzZSAgICAgICAgICAgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgICAgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IE9ic2VydmFibGUgICAgIGZyb20gJy4uL2NvcmUvT2JzZXJ2YWJsZS5tanMnO1xuaW1wb3J0IHtpc0Rlc2NyaXB0b3J9IGZyb20gJy4uL2NvcmUvQ29uZmlnU3ltYm9scy5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uc2VsZWN0aW9uLk1vZGVsXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKiBAbWl4ZXMgTmVvLmNvcmUuT2JzZXJ2YWJsZVxuICovXG5jbGFzcyBNb2RlbCBleHRlbmRzIEJhc2Uge1xuICAgIC8qKlxuICAgICAqIFRydWUgYXV0b21hdGljYWxseSBhcHBsaWVzIHRoZSBjb3JlLk9ic2VydmFibGUgbWl4aW5cbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBvYnNlcnZhYmxlPXRydWVcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIG9ic2VydmFibGUgPSB0cnVlXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5zZWxlY3Rpb24uTW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5zZWxlY3Rpb24uTW9kZWwnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nc2VsZWN0aW9uLW1vZGVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3NlbGVjdGlvbi1tb2RlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQbGFjZWhvbGRlciBmb3IgZXh0ZW5kZWQgY2xhc3NlcyB0byBhZGQgYSBjdXN0b20gY3NzIHJ1bGUgdG8gdGhpcyBvd25lciBjb21wb25lbnRcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGNscz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsczogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5fSBpdGVtc19cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1zXzoge1xuICAgICAgICAgICAgW2lzRGVzY3JpcHRvcl06IHRydWUsXG4gICAgICAgICAgICBjbG9uZSAgICAgICAgIDogJ3NoYWxsb3cnLFxuICAgICAgICAgICAgY2xvbmVPbkdldCAgICA6ICdub25lJyxcbiAgICAgICAgICAgIGlzRXF1YWwgICAgICAgOiAoKSA9PiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlICAgICAgICAgOiBbXVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBzZWxlY3RlZENscz0nc2VsZWN0ZWQnXG4gICAgICAgICAqL1xuICAgICAgICBzZWxlY3RlZENsczogJ25lby1zZWxlY3RlZCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaW5nbGVTZWxlY3Q9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2luZ2xlU2VsZWN0OiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWxseSBzYXZlcyB0aGUgdmlldyBpZCwgYnV0IHRoZSBnZXR0ZXIgd2lsbCByZXR1cm4gdGhlIG1hdGNoaW5nIGluc3RhbmNlXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gdmlld189bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdmlld186IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCBiZWZvcmUgZ2V0dGluZyB0aGUgdmFsdWUgb2YgdGhlIHZpZXcgY29uZmlnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZX1cbiAgICAgKi9cbiAgICBiZWZvcmVHZXRWaWV3KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBOZW8uZ2V0Q29tcG9uZW50KHRoaXMuX3ZpZXcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0cmlnZ2VyZWQgYmVmb3JlIHNldHRpbmcgdGhlIHZhbHVlIG9mIHRoZSB2aWV3IGNvbmZpZ1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSB2aWV3IGlkXG4gICAgICovXG4gICAgYmVmb3JlU2V0Vmlldyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWUuaWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGFkZERvbUxpc3RlbmVyKCkge31cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2lsZW50XSB0cnVlIHRvIHByZXZlbnQgYSB2ZG9tIHVwZGF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W118U3RyaW5nW119IGl0ZW1Db2xsZWN0aW9uPXRoaXMuaXRlbXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NlbGVjdGVkQ2xzXVxuICAgICAqL1xuICAgIGRlc2VsZWN0KGl0ZW0sIHNpbGVudCwgaXRlbUNvbGxlY3Rpb249dGhpcy5pdGVtcywgc2VsZWN0ZWRDbHMpIHtcbiAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7dmlld30gPSBtZSxcbiAgICAgICAgICAgIG5vZGU7XG5cbiAgICAgICAgLy8gV2UgaG9sZCB2ZG9tIGlkcyBmb3Igbm93LCBzbyBhbGwgaW5jb21pbmcgc2VsZWN0aW9ucyBtdXN0IGJlIGNvbnZlcnRlZC5cbiAgICAgICAgaXRlbSA9IGl0ZW0uaXNSZWNvcmQgPyB2aWV3LmdldEl0ZW1JZChpdGVtKSA6IE5lby5pc09iamVjdChpdGVtKSA/IGl0ZW0uaWQgOiBpdGVtO1xuXG4gICAgICAgIGlmIChpdGVtQ29sbGVjdGlvbi5pbmNsdWRlcyhpdGVtKSkge1xuICAgICAgICAgICAgbm9kZSA9IHZpZXcuZ2V0VmRvbUNoaWxkKGl0ZW0pO1xuXG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGUuY2xzID0gTmVvQXJyYXkucmVtb3ZlKG5vZGUuY2xzIHx8IFtdLCBzZWxlY3RlZENscyB8fCBtZS5zZWxlY3RlZENscyk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5vZGVbJ2FyaWEtc2VsZWN0ZWQnXVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUoaXRlbUNvbGxlY3Rpb24sIGl0ZW0pO1xuXG4gICAgICAgICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAgICAgICAgIHZpZXcudXBkYXRlKCk7XG5cbiAgICAgICAgICAgICAgICB2aWV3LnBhcmVudD8ub25EZXNlbGVjdD8uKCk7IC8vIGdyaWQuQ29udGFpbmVyICYgdGFibGUuQ29udGFpbmVyXG4gICAgICAgICAgICAgICAgdmlldy5vbkRlc2VsZWN0Py4oKTtcblxuICAgICAgICAgICAgICAgIG1lLmZpcmUoJ3NlbGVjdGlvbkNoYW5nZScsIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBpdGVtQ29sbGVjdGlvblxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIXNpbGVudCkge1xuICAgICAgICAgICAgbWUuZmlyZSgnbm9DaGFuZ2UnKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2lsZW50XSB0cnVlIHRvIHByZXZlbnQgYSB2ZG9tIHVwZGF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W118U3RyaW5nW119IGl0ZW1Db2xsZWN0aW9uPXRoaXMuaXRlbXNcbiAgICAgKi9cbiAgICBkZXNlbGVjdEFsbChzaWxlbnQsIGl0ZW1Db2xsZWN0aW9uPXRoaXMuaXRlbXMpIHtcbiAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtcyAgPSBbLi4uaXRlbUNvbGxlY3Rpb25dLFxuICAgICAgICAgICAge3ZpZXd9ID0gbWU7XG5cbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBtZS5kZXNlbGVjdChpdGVtLCB0cnVlKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghc2lsZW50ICYmIGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2aWV3LnVwZGF0ZSgpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLmZpcmUoJ3NlbGVjdGlvbkNoYW5nZScsIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb246IHRoaXMuaXRlbXNcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSBpZiAoIXNpbGVudCkge1xuICAgICAgICAgICAgbWUuZmlyZSgnbm9DaGFuZ2UnKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBkZXN0cm95KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy51bnJlZ2lzdGVyKCk7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koLi4uYXJncylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbXBvcnRhbnQgZm9yIG1hcHBpbmcgbGlzdGVuZXJzIHRvIHZpZXcgY29udHJvbGxlcnNcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fG51bGx9XG4gICAgICovXG4gICAgZ2V0Q29udHJvbGxlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5nZXRDb250cm9sbGVyKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IHRoaXMuaXRlbXNcbiAgICAgKi9cbiAgICBnZXRTZWxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzU2VsZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5sZW5ndGggPiAwXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaW4gY2FzZSB0aGUgaXRlbSBpcyBzZWxlY3RlZFxuICAgICAqL1xuICAgIGlzU2VsZWN0ZWQoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMuaW5jbHVkZXMoaWQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudFxuICAgICAqL1xuICAgIHJlZ2lzdGVyKGNvbXBvbmVudCkge1xuICAgICAgICBsZXQgbWUgID0gdGhpcyxcbiAgICAgICAgICAgIGNscyA9IGNvbXBvbmVudC53cmFwcGVyQ2xzIHx8IFtdO1xuXG4gICAgICAgIGlmIChtZS5jbHMgJiYgIWNscy5pbmNsdWRlcyhtZS5jbHMpKSB7XG4gICAgICAgICAgICBjbHMucHVzaChtZS5jbHMpO1xuICAgICAgICAgICAgY29tcG9uZW50LndyYXBwZXJDbHMgPSBjbHNcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnZpZXcgPSBjb21wb25lbnQ7XG4gICAgICAgIG1lLmFkZERvbUxpc3RlbmVyKCk7XG5cbiAgICAgICAgY29tcG9uZW50LmZpcmUoJ3NlbGVjdGlvbk1vZGVsQ2hhbmdlJywge1xuICAgICAgICAgICAgdmFsdWU6IG1lXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICByZW1vdmVEb21MaXN0ZW5lcnMoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY29tcG9uZW50ICAgID0gbWUudmlldyxcbiAgICAgICAgICAgIGRvbUxpc3RlbmVycyA9IFsuLi5jb21wb25lbnQuZG9tTGlzdGVuZXJzXTtcblxuICAgICAgICBjb21wb25lbnQuZG9tTGlzdGVuZXJzLmZvckVhY2gobGlzdGVuZXIgPT4ge1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVyLnNjb3BlID09PSBtZSkge1xuICAgICAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZShkb21MaXN0ZW5lcnMsIGxpc3RlbmVyKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjb21wb25lbnQuZG9tTGlzdGVuZXJzID0gZG9tTGlzdGVuZXJzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R8T2JqZWN0W118U3RyaW5nW119IGl0ZW1zXG4gICAgICogQHBhcmFtIHtPYmplY3RbXXxTdHJpbmdbXX0gaXRlbUNvbGxlY3Rpb249dGhpcy5pdGVtc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2VsZWN0ZWRDbHNdXG4gICAgICovXG4gICAgc2VsZWN0KGl0ZW1zLCBpdGVtQ29sbGVjdGlvbj10aGlzLml0ZW1zLCBzZWxlY3RlZENscykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgICAgICBpdGVtcyA9IFtpdGVtc11cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt2aWV3fSAgPSBtZSxcbiAgICAgICAgICAgIHJlY29yZHMgPSBpdGVtcy5tYXAoaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uaXNSZWNvcmQpIHJldHVybiBpdGVtO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcmVjb3JkSWQgPSB2aWV3LmdldEl0ZW1SZWNvcmRJZD8uKGl0ZW0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY29yZElkICYmIHZpZXcuc3RvcmU/LmdldChyZWNvcmRJZCkgfHwgaXRlbVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gV2UgaG9sZCB2ZG9tIGlkcyBmb3Igbm93LCBzbyBhbGwgaW5jb21pbmcgc2VsZWN0aW9ucyBtdXN0IGJlIGNvbnZlcnRlZC5cbiAgICAgICAgaXRlbXMgPSBpdGVtcy5tYXAoaXRlbSA9PiBpdGVtLmlzUmVjb3JkID8gdmlldy5nZXRJdGVtSWQoaXRlbSkgOiBOZW8uaXNPYmplY3QoaXRlbSkgPyBpdGVtLmlkIDogaXRlbSk7XG5cbiAgICAgICAgaWYgKCFOZW8uaXNFcXVhbChpdGVtQ29sbGVjdGlvbiwgaXRlbXMpKSB7XG4gICAgICAgICAgICBpZiAobWUuc2luZ2xlU2VsZWN0ICYmIGl0ZW1Db2xsZWN0aW9uID09PSBtZS5pdGVtcykge1xuICAgICAgICAgICAgICAgIG1lLmRlc2VsZWN0QWxsKHRydWUsIGl0ZW1Db2xsZWN0aW9uKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpdGVtcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgIG5vZGUgPSB2aWV3LmdldFZkb21DaGlsZChub2RlKTtcblxuICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuY2xzID0gTmVvQXJyYXkuYWRkKG5vZGUuY2xzIHx8IFtdLCBzZWxlY3RlZENscyB8fCBtZS5zZWxlY3RlZENscyk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVbJ2FyaWEtc2VsZWN0ZWQnXSA9IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgTmVvQXJyYXkuYWRkKGl0ZW1Db2xsZWN0aW9uLCBpdGVtcyk7XG5cbiAgICAgICAgICAgIGlmICghdmlldy5zaWxlbnRTZWxlY3QpIHtcbiAgICAgICAgICAgICAgICB2aWV3LnVwZGF0ZSgpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZpZXcucGFyZW50Py5vblNlbGVjdD8uKGl0ZW1zKTsgLy8gZ3JpZC5Db250YWluZXIgJiB0YWJsZS5Db250YWluZXJcbiAgICAgICAgICAgIHZpZXcub25TZWxlY3Q/LihpdGVtcyk7XG5cbiAgICAgICAgICAgIHZpZXcuZmlyZSgnc2VsZWN0Jywge1xuICAgICAgICAgICAgICAgIHJlY29yZHMsXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBpdGVtQ29sbGVjdGlvblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLmZpcmUoJ3NlbGVjdGlvbkNoYW5nZScsIHtcbiAgICAgICAgICAgICAgICByZWNvcmRzLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogaXRlbUNvbGxlY3Rpb25cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZS5maXJlKCdub0NoYW5nZScpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuICAgICAqL1xuICAgIHRvZ2dsZVNlbGVjdGlvbihpdGVtKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmlzU2VsZWN0ZWQoaXRlbSkpIHtcbiAgICAgICAgICAgIG1lLmRlc2VsZWN0KGl0ZW0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5zZWxlY3QoaXRlbSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbXMgPSAobWUuaXRlbXMgfHwgW10pLm1hcChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoTmVvLmlzUmVjb3JkKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLnRvSlNPTigpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcbiAgICAgICAgICAgIGl0ZW1zLFxuICAgICAgICAgICAgc2VsZWN0ZWRDbHMgOiBtZS5zZWxlY3RlZENscyxcbiAgICAgICAgICAgIHNpbmdsZVNlbGVjdDogbWUuc2luZ2xlU2VsZWN0XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHVucmVnaXN0ZXIoKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3ZpZXd9ID0gbWU7XG5cbiAgICAgICAgaWYgKCF2aWV3LmlzRGVzdHJveWluZykge1xuICAgICAgICAgICAgbGV0IGNscyA9IHZpZXcud3JhcHBlckNscyB8fCBbXTtcblxuICAgICAgICAgICAgaWYgKG1lLmNscyAmJiBjbHMuaW5jbHVkZXMobWUuY2xzKSkge1xuICAgICAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZShjbHMsIG1lLmNscyk7XG4gICAgICAgICAgICAgICAgdmlldy53cmFwcGVyQ2xzID0gY2xzXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLmRlc2VsZWN0QWxsKCk7XG5cbiAgICAgICAgICAgIG1lLnJlbW92ZURvbUxpc3RlbmVycygpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKE1vZGVsKTtcbiIsImltcG9ydCBCYXNlTGlzdE1vZGVsIGZyb20gJy4uL0xpc3RNb2RlbC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uc2VsZWN0aW9uLm1lbnUuTGlzdE1vZGVsXG4gKiBAZXh0ZW5kcyBOZW8uc2VsZWN0aW9uLkxpc3RNb2RlbFxuICovXG5jbGFzcyBMaXN0TW9kZWwgZXh0ZW5kcyBCYXNlTGlzdE1vZGVsIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5zZWxlY3Rpb24ubWVudS5MaXN0TW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5zZWxlY3Rpb24ubWVudS5MaXN0TW9kZWwnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nc2VsZWN0aW9uLW1lbnUtbGlzdG1vZGVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3NlbGVjdGlvbi1tZW51LWxpc3Rtb2RlbCdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uS2V5RG93bkVzY2FwZShkYXRhKSB7XG4gICAgICAgIHRoaXMudmlldy5vbktleURvd25Fc2NhcGUoZGF0YSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uS2V5RG93bkxlZnQoZGF0YSkge1xuICAgICAgICBsZXQge3ZpZXd9ICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtwYXJlbnRNZW51fSA9IHZpZXc7XG5cbiAgICAgICAgaWYgKHBhcmVudE1lbnUpIHtcbiAgICAgICAgICAgIHZpZXcuaGlkZVN1Yk1lbnUoKTtcbiAgICAgICAgICAgIHZpZXcuc2VsZWN0aW9uTW9kZWwuZGVzZWxlY3RBbGwoKTtcbiAgICAgICAgICAgIHBhcmVudE1lbnUuc2VsZWN0aW9uTW9kZWwuc2VsZWN0QXQodmlldy5wYXJlbnRJbmRleClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25LZXlEb3duUmlnaHQoZGF0YSkge1xuICAgICAgICB0aGlzLnZpZXcuYWN0aXZlU3ViTWVudT8uc2VsZWN0aW9uTW9kZWwuc2VsZWN0QXQoMClcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKExpc3RNb2RlbCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=