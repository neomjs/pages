export const __webpack_esm_id__ = "vendors-apps_portal_canvas_TicketCanvas_mjs";
export const __webpack_esm_ids__ = ["vendors-apps_portal_canvas_TicketCanvas_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./apps/portal/canvas/Base.mjs"
/*!*************************************!*\
  !*** ./apps/portal/canvas/Base.mjs ***!
  \*************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @summary Abstract base class for Portal Canvas Renderers.
 *
 * This class serves as the foundation for the specialized canvas visualizations (Header, Home, Services, Ticket)
 * that run within the **Neo.mjs Canvas SharedWorker**.
 *
 * It creates helper singletons that manage their own `OffscreenCanvas` instances, providing a standardized
 * architecture for:
 * - **Lifecycle Management:** Initialization (`initGraph`), destruction (`clearGraph`), and resource cleanup.
 * - **Render Loop Control:** Unified `render` loop with pause/resume capabilities and frame scheduling.
 * - **Context Management:** Robust handling of `OffscreenCanvas` transfer and context acquisition via `waitForCanvas`.
 * - **Shared State:** Common state management for mouse interaction, time, and theming.
 *
 * These renderers operate off the main thread to ensure high-performance, 60fps animations without
 * blocking the UI.
 *
 * @class Portal.canvas.Base
 * @extends Neo.core.Base
 */
class Base extends _src_core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.canvas.Base'
         * @protected
         */
        className: 'Portal.canvas.Base',
        /**
         * Remote method access
         * @member {Object} remote
         * @protected
         */
        remote: {
            app: [
                'clearGraph',
                'initGraph',
                'pause',
                'resume',
                'setTheme',
                'updateMouseState',
                'updateSize'
            ]
        },
        /**
         * The active color theme ('light' or 'dark').
         * @member {String} theme_='light'
         * @reactive
         */
        theme_: 'light'
    }

    /**
     * @member {Number|null} animationId=null
     */
    animationId = null
    /**
     * @member {String|null} canvasId=null
     */
    canvasId = null
    /**
     * @member {Object|null} canvasSize=null
     */
    canvasSize = null
    /**
     * @member {OffscreenCanvasRenderingContext2D|null} context=null
     */
    context = null
    /**
     * Cache for reusable gradients to prevent GC.
     * @member {Object} gradients={}
     */
    gradients = {}
    /**
     * Flag to pause the render loop.
     * @member {Boolean} isPaused=false
     */
    isPaused = false
    /**
     * Tracked mouse position for interactive physics.
     * Initialize off-screen to prevent startup jitters.
     * @member {Object} mouse={x: -1000, y: -1000}
     */
    mouse = {x: -1000, y: -1000}
    /**
     * Global simulation time.
     * @member {Number} time=0
     */
    time = 0

    /**
     * @member {Function} renderLoop=this.render.bind(this)
     */
    renderLoop = this.render.bind(this)

    /**
     * Triggered after the `theme` config is changed.
     * Updates the resource cache (gradients, colors) to reflect the new theme immediately.
     * @param {String} value
     * @param {String} oldValue
     */
    afterSetTheme(value, oldValue) {
        if (value && this.canvasSize) {
            this.updateResources?.(this.canvasSize.width, this.canvasSize.height)
        }
    }

    /**
     * Checks if the canvas is ready to render.
     * Returns true only if the context exists and the simulation is not paused.
     * Subclasses should call this at the start of their `render` loop.
     * @returns {Boolean}
     */
    get canRender() {
        let me = this;
        return !!(me.context && !me.isPaused)
    }

    /**
     * Clears the graph state and stops the render loop.
     * Use this to cleanup resources when the component is destroyed or unmounted.
     */
    clearGraph() {
        let me = this;
        me.context     = null;
        me.canvasId    = null;
        me.canvasSize  = null;
        me.animationId = null;
        me.isPaused    = false;
        me.gradients   = {};
        me.mouse       = {x: -1000, y: -1000};
        me.time        = 0
    }

    /**
     * Initializes the canvas context.
     * Starts the polling mechanism to wait for the OffscreenCanvas transfer from the Main Thread.
     * @param {Object} opts
     * @param {String} opts.canvasId
     * @param {String} opts.windowId
     */
    initGraph({canvasId, windowId}) {
        let me        = this,
            hasChange = me.canvasId !== canvasId;

        me.canvasId = canvasId;

        me.waitForCanvas(canvasId, windowId, hasChange)
    }

    /**
     * Hook for subclasses to handle mouse clicks.
     * Called by `updateMouseState` when a click event is received.
     * @param {Object} data
     */
    onMouseClick(data) {}

    /**
     * Pauses the simulation.
     * The render loop will exit early while `isPaused` is true.
     */
    pause() {
        this.isPaused = true
    }

    /**
     * Abstract render method.
     * Subclasses must implement this method to draw the frame.
     */
    render() {}

    /**
     * Resumes the simulation.
     * If the simulation was paused, this restarts the render loop.
     */
    resume() {
        let me = this;

        if (me.isPaused) {
            me.isPaused = false;
            me.renderLoop()
        }
    }

    /**
     * Exposed method for Remote Access to trigger the reactive config setter.
     * @param {String} value
     */
    setTheme(value) {
        this.theme = value
    }

    /**
     * Updates the local mouse state from main thread events.
     * Delegates click events to `onMouseClick`.
     * @param {Object} data
     * @param {Boolean} [data.click]
     * @param {Boolean} [data.leave]
     * @param {Number} [data.x]
     * @param {Number} [data.y]
     */
    updateMouseState(data) {
        let me = this;

        if (data.leave) {
            me.mouse.x = -1000;
            me.mouse.y = -1000
        } else {
            if (data.x !== undefined) me.mouse.x = data.x;
            if (data.y !== undefined) me.mouse.y = data.y;

            if (data.click) {
                me.onMouseClick(data)
            }
        }
    }

    /**
     * Updates the canvas size and resizes the internal context.
     * Triggers `updateResources` hook to allow subclasses to regenerate buffers/gradients.
     * @param {Object} size
     * @param {Number} size.height
     * @param {Number} size.width
     */
    updateSize(size) {
        let me = this;

        me.canvasSize = size;

        if (me.context) {
            me.context.canvas.width  = size.width;
            me.context.canvas.height = size.height;
            // Calls the hook to re-generate resources if implemented
            me.updateResources?.(size.width, size.height)
        }
    }

    /**
     * Polls for the OffscreenCanvas until it is available in the Worker's `canvasWindowMap`.
     * Once found, it initializes the context and starts the render loop.
     * @param {String} canvasId
     * @param {String} windowId
     * @param {Boolean} hasChange
     * @protected
     */
    waitForCanvas(canvasId, windowId, hasChange) {
        let me     = this,
            canvas = Neo.currentWorker.canvasWindowMap[canvasId]?.[windowId];

        if (canvas) {
            me.context = canvas.getContext('2d');

            // Standardize size update
            me.updateSize({width: canvas.width, height: canvas.height});

            // Optional hook for subclasses
            me.onGraphMounted?.(canvas.width, canvas.height);

            if (hasChange && !me.animationId) {
                me.renderLoop()
            }
        } else {
            setTimeout(me.waitForCanvas.bind(me, canvasId, windowId, hasChange), 50)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Base));


/***/ },

/***/ "./apps/portal/canvas/TicketCanvas.mjs"
/*!*********************************************!*\
  !*** ./apps/portal/canvas/TicketCanvas.mjs ***!
  \*********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./apps/portal/canvas/Base.mjs");


const
    hasRaf         = typeof requestAnimationFrame === 'function',
    // Matches full hex codes (e.g., "#0033FF" or "0033FF")
    hexToRgbRegex  = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,
    // Matches shorthand hex codes (e.g., "#03F" or "03F") for expansion
    shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;

const BASE_COLOR = {r: 64, g: 196, b: 255}; // Neo Blue

const PHYSICS = {
    influenceRange: 150,
    minMod        : 0.2,
    maxMod        : 1.5,
    pulseBounds   : -200
};

/**
 * @summary Renders the "Neural Timeline" visualization for the Portal's Ticket view.
 *
 * This class runs inside a SharedWorker (via `CanvasWorker`) to provide a high-performance,
 * main-thread-blocking-free animation. It visualizes the flow of time and activity connecting
 * timeline nodes (tickets/events).
 *
 * Key Visual Concepts:
 * 1. **The Spine**: A continuous, gradient-stroked line connecting all nodes.
 * 2. **The Pulse**: A "data packet" that travels along the spine.
 * 3. **Dual-Point Physics**: The pulse Head and Tail are simulated as independent particles moving through the
 *    speed field. This creates organic "Squash and Stretch" behavior: compressing when entering a node (Head slows, Tail fast)
 *    and stretching when leaving (Head fast, Tail slow), without requiring complex constraints or causing visual artifacts.
 * 4. **Chameleon Effect**: The pulse dynamically changes its color to match the semantic color of the
 *    nearest node (e.g., Red for Bugs, Green for Features) as it passes by.
 *
 * @class Portal.canvas.TicketCanvas
 * @extends Portal.canvas.Base
 * @singleton
 */
class TicketCanvas extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static colors = {
        dark : {
            spine: ['rgba(62, 99, 221, 0.2)', 'rgba(64, 196, 255, 0.4)', 'rgba(62, 99, 221, 0.2)']
        },
        light: {
            spine: ['rgba(150, 150, 150, 0.1)', 'rgba(150, 150, 150, 0.3)', 'rgba(150, 150, 150, 0.1)']
        }
    }

    static config = {
        /**
         * @member {String} className='Portal.canvas.TicketCanvas'
         * @protected
         */
        className: 'Portal.canvas.TicketCanvas',
        /**
         * Remote method access
         * @member {Object} remote
         * @protected
         */
        remote: {
            app: [
                'clearGraph',
                'initGraph',
                'setTheme',
                'updateGraphData',
                'updateSize'
            ]
        },
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true,
        /**
         * @member {String} theme='light'
         */
        theme: 'light'
    }

    /**
     * @member {Number} baseSpeed=0.5
     */
    baseSpeed = 0.5
    /**
     * @member {Number} lastFrameTime=0
     */
    lastFrameTime = 0
    /**
     * @member {Array} nodes=[]
     */
    nodes = []
    /**
     * @member {Number} pulseY=0
     */
    pulseY = 0
    /**
     * @member {Number} pulseBottom=100
     */
    pulseBottom = 100
    /**
     * @member {Number} startY=0
     */
    startY = 0

    /**
     * Clears the graph state and stops the render loop.
     * This is called when the view unmounts to prevent "Zombie Loops".
     */
    clearGraph() {
        let me = this;
        super.clearGraph();
        me.nodes         = [];
        me.lastFrameTime = 0;
        me.pulseBottom   = 0
    }

    /**
     * Calculates the horizontal (X) position on the spine for a given vertical (Y) position.
     *
     * Since the nodes are not vertically aligned (they weave left/right), the spine is a polyline.
     * This method performs linear interpolation between the two nearest nodes to ensure the
     * "Pulse" stays perfectly centered on the spine path as it travels.
     *
     * @param {Number} y - The vertical position
     * @returns {Number} x - The calculated horizontal position on the spine
     */
    getXAtY(y) {
        let me = this;

        if (me.nodes.length < 2) return me.nodes[0]?.x || 38;
        if (y < me.nodes[0].y)   return me.nodes[0].x;

        for (let i = 0; i < me.nodes.length - 1; i++) {
            let curr = me.nodes[i],
                next = me.nodes[i+1];

            if (y >= curr.y && y <= next.y) {
                let ratio = (y - curr.y) / (next.y - curr.y);
                return curr.x + (next.x - curr.x) * ratio;
            }
        }

        return me.nodes[me.nodes.length - 1].x
    }

    /**
     * Calculates the physics state (speed, nearest node) for a given Y position.
     * This acts as the "Traffic Model" engine, determining the local speed limit based on proximity
     * to nodes. Particles slow down near nodes (observation) and accelerate in empty space (travel).
     *
     * @param {Number} y
     * @returns {Object} {speedModifier, nearNode, minDist}
     */
    getPhysics(y) {
        let me       = this,
            minDist  = Infinity,
            nearNode = null;

        me.nodes.forEach(node => {
            let dist = Math.abs(y - node.y);
            if (dist < minDist) {
                minDist  = dist;
                nearNode = node;
            }
        });

        const {influenceRange, minMod, maxMod} = PHYSICS;
        let speedModifier = maxMod;

        if (minDist < influenceRange) {
            let ratio = minDist / influenceRange;
            speedModifier = minMod + (maxMod - minMod) * (ratio * ratio);
        }

        return {speedModifier, nearNode, minDist}
    }

    /**
     * Helper to parse hex to rgb
     * @param {String} hex
     * @returns {Object} {r,g,b}
     */
    hexToRgb(hex) {
        hex = hex.replace(shorthandRegex, function(m, r, g, b) {
            return r + r + g + g + b + b;
        });

        const result = hexToRgbRegex.exec(hex);

        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : null
    }

    /**
     * Updates the graph with new timeline nodes.
     * When `reset` is true, it hard-resets the physics simulation (positions and time) to prevent
     * visual artifacts (jumping/flashing) when switching between different ticket contexts.
     *
     * @param {Object} data
     * @param {Array}  data.nodes
     * @param {Boolean} [data.reset]
     * @param {Number} [data.startY]
     */
    updateGraphData(data) {
        let me = this;
        me.nodes = data.nodes || [];
        if (data.startY !== undefined) {
            me.startY = data.startY;
        }

        if (data.reset) {
            me.pulseY      = PHYSICS.pulseBounds;
            me.pulseBottom = PHYSICS.pulseBounds + 100;
            me.lastFrameTime = 0
        }

        // Ensure animation loop is running if we have data
        if (me.nodes.length > 0 && !me.animationId && me.context) {
            me.renderLoop()
        }
    }

    /**
     * The Main Animation Loop (60fps).
     *
     * This method is responsible for:
     * 1. **Physics Calculation**: Determining the pulse's speed based on proximity to nodes ("Traffic Model").
     * 2. **State Updates**: Updating the pulse's position (`pulseY`) and color (`Chameleon Effect`).
     * 3. **Drawing**: Rendering the spine, the pulse, and the node glows to the `OffscreenCanvas`.
     *
     * It uses `setTimeout` instead of `requestAnimationFrame` because SharedWorkers do not generally support rAF.
     */
    render() {
        let me = this;

        if (!me.canRender) {
            return
        }

        const
            ctx    = me.context,
            width  = me.canvasSize?.width  || 800,
            height = me.canvasSize?.height || 600,
            now    = Date.now();

        // Calculate the bottom-most boundary (last item's Y or default height)
        let maxY = height;

        if (me.nodes.length > 0) {
            maxY = me.nodes[me.nodes.length - 1].y
        }

        // Time delta in ms
        let dt = now - (me.lastFrameTime || now);
        me.lastFrameTime = now;

        // Cap dt to prevent huge jumps
        if (dt > 100) dt = 16;

        // 1. Calculate Physics
        // "Dual-Point Physics": We simulate the Head and Tail of the pulse as independent particles
        // moving through the "Traffic Model" speed field.
        // - When Head hits a node (slow zone), it slows down. Tail (in fast zone) catches up. -> Squash.
        // - When Head leaves a node, it speeds up. Tail (in slow zone) lags behind. -> Stretch.
        // This creates organic, physically correct deformation without "retraction" glitches or artificial stalls.

        const
            physicsTop    = me.getPhysics(me.pulseY),
            physicsBottom = me.getPhysics(me.pulseBottom),
            {nearNode, minDist} = physicsTop; // Use Top for color/proximity logic to match original feel

        // Apply Independent Velocities
        me.pulseY      += me.baseSpeed * physicsTop.speedModifier    * dt;
        me.pulseBottom += me.baseSpeed * physicsBottom.speedModifier * dt;

        // Constraint: Minimum Length (e.g. 15px).
        // While Dual-Point Physics naturally handles compression, extreme deceleration can theoretically
        // cause the Head to move slower than the Tail for too long, inverting the pulse.
        // This hard constraint preserves physical plausibility (matter cannot have negative length).
        if (me.pulseBottom < me.pulseY + 15) {
            me.pulseBottom = me.pulseY + 15
        }

        // Wrap Around
        if (me.pulseY > maxY - PHYSICS.pulseBounds) {
            me.pulseY      = PHYSICS.pulseBounds;
            me.pulseBottom = PHYSICS.pulseBounds + 100 // Reset length on loop
        }

        const pulseLength = me.pulseBottom - me.pulseY;

        // Color Interpolation (Chameleon Effect)
        // The pulse "absorbs" the color of the node it is currently passing.
        let {r, g, b} = BASE_COLOR;

        // If near a colored node (within 100px), interpolate to its color
        if (nearNode && nearNode.color && minDist < 100) {
            let target = me.hexToRgb(nearNode.color);
            if (target) {
                let mix = 1 - (minDist / 100);
                r = r + (target.r - r) * mix;
                g = g + (target.g - g) * mix;
                b = b + (target.b - b) * mix
            }
        }

        const pulseColorStr = `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}`; // leaves alpha open

        // 2. Clear
        ctx.clearRect(0, 0, width, height);

        // 3. Draw Neural Connections (The "Spine")
        const
            themeColors = me.constructor.colors[me.theme],
            gradient    = ctx.createLinearGradient(0, 0, 0, height);

        gradient.addColorStop(0,   themeColors.spine[0]);
        gradient.addColorStop(0.5, themeColors.spine[1]);
        gradient.addColorStop(1,   themeColors.spine[2]);

        ctx.strokeStyle = gradient;
        ctx.lineWidth   = 2;
        ctx.beginPath();

        if (me.nodes.length > 0) {
            let first = me.nodes[0];
            ctx.moveTo(first.x, first.y);

            for (let i = 1; i < me.nodes.length; i++) {
                let node = me.nodes[i];
                ctx.lineTo(node.x, node.y)
            }
        }
        ctx.stroke();

        // 4. Draw "Pulse" Effect
        const pulseY = me.pulseY;

        if (me.nodes.length > 0 && pulseY > me.nodes[0].y - pulseLength && pulseY < maxY) {
            const pulseGrad = ctx.createLinearGradient(0, pulseY, 0, pulseY + pulseLength);
            pulseGrad.addColorStop(0,   `${pulseColorStr}, 0)`);
            pulseGrad.addColorStop(0.5, `${pulseColorStr}, 1)`);
            pulseGrad.addColorStop(1,   `${pulseColorStr}, 0)`);

            ctx.strokeStyle = pulseGrad;
            ctx.lineWidth   = 4;
            ctx.beginPath();

            let pulseX = me.getXAtY(pulseY);
            ctx.moveTo(pulseX, pulseY);
            ctx.lineTo(me.getXAtY(pulseY + pulseLength), Math.min(pulseY + pulseLength, maxY));
            ctx.stroke()
        }

        // 5. "The Gap"
        ctx.globalCompositeOperation = 'destination-out';
        ctx.fillStyle                = '#000';

        me.nodes.forEach(node => {
            if (node.radius) {
                ctx.beginPath();
                ctx.arc(node.x, node.y, node.radius, 0, 2 * Math.PI);
                ctx.fill()
            }
        });

        // 5. Draw Orbit/Glow Effects
        ctx.globalCompositeOperation = 'source-over';

        me.nodes.forEach(node => {
            const
                radius  = node.radius || 20,
                x       = node.x,
                y       = node.y,
                pTop    = pulseY,
                pBottom = pulseY + pulseLength,
                nTop    = y - radius,
                nBottom = y + radius;

            if (pBottom > nTop && pTop < nBottom) {
                const getAngle = (val) => {
                    let dy = val - y;
                    // Clamp to radius to avoid NaN in asin
                    dy = Math.max(-radius, Math.min(radius, dy));
                    return Math.asin(dy / radius)
                };

                const
                    angleTail = getAngle(pTop),
                    angleHead = getAngle(pBottom);

                // Use the DYNAMIC color here too!
                ctx.strokeStyle = `${pulseColorStr}, 1)`;
                ctx.lineWidth   = 2;

                // Right Arc
                ctx.beginPath();
                ctx.arc(x, y, radius + 2, angleTail, angleHead, false);
                ctx.stroke();

                // Left Arc
                const
                    leftTail = Math.PI - angleTail,
                    leftHead = Math.PI - angleHead;

                ctx.beginPath();
                ctx.arc(x, y, radius + 2, leftTail, leftHead, true);
                ctx.stroke()
            }
        });

        if (hasRaf) {
            me.animationId = requestAnimationFrame(me.renderLoop)
        } else {
            me.animationId = setTimeout(me.renderLoop, 1000 / 60)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TicketCanvas));

/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2NhbnZhcy92ZW5kb3JzLWFwcHNfcG9ydGFsX2NhbnZhc19UaWNrZXRDYW52YXNfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFpRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMERBQU87QUFDMUI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdDQUF3QztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRLE9BQU87QUFDL0I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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QUNBOztBQUVBLHNDQUFzQyxjQUFjLElBQUksY0FBYyxJQUFJLGNBQWMsR0FBRzs7QUFFM0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLGNBQWM7QUFDekQsMkNBQTJDLGNBQWM7QUFDekQsMkNBQTJDLGNBQWM7O0FBRXpEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyxjQUFjO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLDRCQUE0QixFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvcG9ydGFsL2NhbnZhcy9CYXNlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9wb3J0YWwvY2FudmFzL1RpY2tldENhbnZhcy5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE5lb0Jhc2UgZnJvbSAnLi4vLi4vLi4vc3JjL2NvcmUvQmFzZS5tanMnO1xuXG4vKipcbiAqIEBzdW1tYXJ5IEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIFBvcnRhbCBDYW52YXMgUmVuZGVyZXJzLlxuICpcbiAqIFRoaXMgY2xhc3Mgc2VydmVzIGFzIHRoZSBmb3VuZGF0aW9uIGZvciB0aGUgc3BlY2lhbGl6ZWQgY2FudmFzIHZpc3VhbGl6YXRpb25zIChIZWFkZXIsIEhvbWUsIFNlcnZpY2VzLCBUaWNrZXQpXG4gKiB0aGF0IHJ1biB3aXRoaW4gdGhlICoqTmVvLm1qcyBDYW52YXMgU2hhcmVkV29ya2VyKiouXG4gKlxuICogSXQgY3JlYXRlcyBoZWxwZXIgc2luZ2xldG9ucyB0aGF0IG1hbmFnZSB0aGVpciBvd24gYE9mZnNjcmVlbkNhbnZhc2AgaW5zdGFuY2VzLCBwcm92aWRpbmcgYSBzdGFuZGFyZGl6ZWRcbiAqIGFyY2hpdGVjdHVyZSBmb3I6XG4gKiAtICoqTGlmZWN5Y2xlIE1hbmFnZW1lbnQ6KiogSW5pdGlhbGl6YXRpb24gKGBpbml0R3JhcGhgKSwgZGVzdHJ1Y3Rpb24gKGBjbGVhckdyYXBoYCksIGFuZCByZXNvdXJjZSBjbGVhbnVwLlxuICogLSAqKlJlbmRlciBMb29wIENvbnRyb2w6KiogVW5pZmllZCBgcmVuZGVyYCBsb29wIHdpdGggcGF1c2UvcmVzdW1lIGNhcGFiaWxpdGllcyBhbmQgZnJhbWUgc2NoZWR1bGluZy5cbiAqIC0gKipDb250ZXh0IE1hbmFnZW1lbnQ6KiogUm9idXN0IGhhbmRsaW5nIG9mIGBPZmZzY3JlZW5DYW52YXNgIHRyYW5zZmVyIGFuZCBjb250ZXh0IGFjcXVpc2l0aW9uIHZpYSBgd2FpdEZvckNhbnZhc2AuXG4gKiAtICoqU2hhcmVkIFN0YXRlOioqIENvbW1vbiBzdGF0ZSBtYW5hZ2VtZW50IGZvciBtb3VzZSBpbnRlcmFjdGlvbiwgdGltZSwgYW5kIHRoZW1pbmcuXG4gKlxuICogVGhlc2UgcmVuZGVyZXJzIG9wZXJhdGUgb2ZmIHRoZSBtYWluIHRocmVhZCB0byBlbnN1cmUgaGlnaC1wZXJmb3JtYW5jZSwgNjBmcHMgYW5pbWF0aW9ucyB3aXRob3V0XG4gKiBibG9ja2luZyB0aGUgVUkuXG4gKlxuICogQGNsYXNzIFBvcnRhbC5jYW52YXMuQmFzZVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBCYXNlIGV4dGVuZHMgTmVvQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdQb3J0YWwuY2FudmFzLkJhc2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ1BvcnRhbC5jYW52YXMuQmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdGUgbWV0aG9kIGFjY2Vzc1xuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHJlbW90ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdGU6IHtcbiAgICAgICAgICAgIGFwcDogW1xuICAgICAgICAgICAgICAgICdjbGVhckdyYXBoJyxcbiAgICAgICAgICAgICAgICAnaW5pdEdyYXBoJyxcbiAgICAgICAgICAgICAgICAncGF1c2UnLFxuICAgICAgICAgICAgICAgICdyZXN1bWUnLFxuICAgICAgICAgICAgICAgICdzZXRUaGVtZScsXG4gICAgICAgICAgICAgICAgJ3VwZGF0ZU1vdXNlU3RhdGUnLFxuICAgICAgICAgICAgICAgICd1cGRhdGVTaXplJ1xuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFjdGl2ZSBjb2xvciB0aGVtZSAoJ2xpZ2h0JyBvciAnZGFyaycpLlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHRoZW1lXz0nbGlnaHQnXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhlbWVfOiAnbGlnaHQnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IGFuaW1hdGlvbklkPW51bGxcbiAgICAgKi9cbiAgICBhbmltYXRpb25JZCA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gY2FudmFzSWQ9bnVsbFxuICAgICAqL1xuICAgIGNhbnZhc0lkID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBjYW52YXNTaXplPW51bGxcbiAgICAgKi9cbiAgICBjYW52YXNTaXplID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRHxudWxsfSBjb250ZXh0PW51bGxcbiAgICAgKi9cbiAgICBjb250ZXh0ID0gbnVsbFxuICAgIC8qKlxuICAgICAqIENhY2hlIGZvciByZXVzYWJsZSBncmFkaWVudHMgdG8gcHJldmVudCBHQy5cbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGdyYWRpZW50cz17fVxuICAgICAqL1xuICAgIGdyYWRpZW50cyA9IHt9XG4gICAgLyoqXG4gICAgICogRmxhZyB0byBwYXVzZSB0aGUgcmVuZGVyIGxvb3AuXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNQYXVzZWQ9ZmFsc2VcbiAgICAgKi9cbiAgICBpc1BhdXNlZCA9IGZhbHNlXG4gICAgLyoqXG4gICAgICogVHJhY2tlZCBtb3VzZSBwb3NpdGlvbiBmb3IgaW50ZXJhY3RpdmUgcGh5c2ljcy5cbiAgICAgKiBJbml0aWFsaXplIG9mZi1zY3JlZW4gdG8gcHJldmVudCBzdGFydHVwIGppdHRlcnMuXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBtb3VzZT17eDogLTEwMDAsIHk6IC0xMDAwfVxuICAgICAqL1xuICAgIG1vdXNlID0ge3g6IC0xMDAwLCB5OiAtMTAwMH1cbiAgICAvKipcbiAgICAgKiBHbG9iYWwgc2ltdWxhdGlvbiB0aW1lLlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gdGltZT0wXG4gICAgICovXG4gICAgdGltZSA9IDBcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufSByZW5kZXJMb29wPXRoaXMucmVuZGVyLmJpbmQodGhpcylcbiAgICAgKi9cbiAgICByZW5kZXJMb29wID0gdGhpcy5yZW5kZXIuYmluZCh0aGlzKVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBgdGhlbWVgIGNvbmZpZyBpcyBjaGFuZ2VkLlxuICAgICAqIFVwZGF0ZXMgdGhlIHJlc291cmNlIGNhY2hlIChncmFkaWVudHMsIGNvbG9ycykgdG8gcmVmbGVjdCB0aGUgbmV3IHRoZW1lIGltbWVkaWF0ZWx5LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIGFmdGVyU2V0VGhlbWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0aGlzLmNhbnZhc1NpemUpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUmVzb3VyY2VzPy4odGhpcy5jYW52YXNTaXplLndpZHRoLCB0aGlzLmNhbnZhc1NpemUuaGVpZ2h0KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBjYW52YXMgaXMgcmVhZHkgdG8gcmVuZGVyLlxuICAgICAqIFJldHVybnMgdHJ1ZSBvbmx5IGlmIHRoZSBjb250ZXh0IGV4aXN0cyBhbmQgdGhlIHNpbXVsYXRpb24gaXMgbm90IHBhdXNlZC5cbiAgICAgKiBTdWJjbGFzc2VzIHNob3VsZCBjYWxsIHRoaXMgYXQgdGhlIHN0YXJ0IG9mIHRoZWlyIGByZW5kZXJgIGxvb3AuXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGNhblJlbmRlcigpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcbiAgICAgICAgcmV0dXJuICEhKG1lLmNvbnRleHQgJiYgIW1lLmlzUGF1c2VkKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgZ3JhcGggc3RhdGUgYW5kIHN0b3BzIHRoZSByZW5kZXIgbG9vcC5cbiAgICAgKiBVc2UgdGhpcyB0byBjbGVhbnVwIHJlc291cmNlcyB3aGVuIHRoZSBjb21wb25lbnQgaXMgZGVzdHJveWVkIG9yIHVubW91bnRlZC5cbiAgICAgKi9cbiAgICBjbGVhckdyYXBoKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuICAgICAgICBtZS5jb250ZXh0ICAgICA9IG51bGw7XG4gICAgICAgIG1lLmNhbnZhc0lkICAgID0gbnVsbDtcbiAgICAgICAgbWUuY2FudmFzU2l6ZSAgPSBudWxsO1xuICAgICAgICBtZS5hbmltYXRpb25JZCA9IG51bGw7XG4gICAgICAgIG1lLmlzUGF1c2VkICAgID0gZmFsc2U7XG4gICAgICAgIG1lLmdyYWRpZW50cyAgID0ge307XG4gICAgICAgIG1lLm1vdXNlICAgICAgID0ge3g6IC0xMDAwLCB5OiAtMTAwMH07XG4gICAgICAgIG1lLnRpbWUgICAgICAgID0gMFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBjYW52YXMgY29udGV4dC5cbiAgICAgKiBTdGFydHMgdGhlIHBvbGxpbmcgbWVjaGFuaXNtIHRvIHdhaXQgZm9yIHRoZSBPZmZzY3JlZW5DYW52YXMgdHJhbnNmZXIgZnJvbSB0aGUgTWFpbiBUaHJlYWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy5jYW52YXNJZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRzLndpbmRvd0lkXG4gICAgICovXG4gICAgaW5pdEdyYXBoKHtjYW52YXNJZCwgd2luZG93SWR9KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaGFzQ2hhbmdlID0gbWUuY2FudmFzSWQgIT09IGNhbnZhc0lkO1xuXG4gICAgICAgIG1lLmNhbnZhc0lkID0gY2FudmFzSWQ7XG5cbiAgICAgICAgbWUud2FpdEZvckNhbnZhcyhjYW52YXNJZCwgd2luZG93SWQsIGhhc0NoYW5nZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIb29rIGZvciBzdWJjbGFzc2VzIHRvIGhhbmRsZSBtb3VzZSBjbGlja3MuXG4gICAgICogQ2FsbGVkIGJ5IGB1cGRhdGVNb3VzZVN0YXRlYCB3aGVuIGEgY2xpY2sgZXZlbnQgaXMgcmVjZWl2ZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbk1vdXNlQ2xpY2soZGF0YSkge31cblxuICAgIC8qKlxuICAgICAqIFBhdXNlcyB0aGUgc2ltdWxhdGlvbi5cbiAgICAgKiBUaGUgcmVuZGVyIGxvb3Agd2lsbCBleGl0IGVhcmx5IHdoaWxlIGBpc1BhdXNlZGAgaXMgdHJ1ZS5cbiAgICAgKi9cbiAgICBwYXVzZSgpIHtcbiAgICAgICAgdGhpcy5pc1BhdXNlZCA9IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBYnN0cmFjdCByZW5kZXIgbWV0aG9kLlxuICAgICAqIFN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gZHJhdyB0aGUgZnJhbWUuXG4gICAgICovXG4gICAgcmVuZGVyKCkge31cblxuICAgIC8qKlxuICAgICAqIFJlc3VtZXMgdGhlIHNpbXVsYXRpb24uXG4gICAgICogSWYgdGhlIHNpbXVsYXRpb24gd2FzIHBhdXNlZCwgdGhpcyByZXN0YXJ0cyB0aGUgcmVuZGVyIGxvb3AuXG4gICAgICovXG4gICAgcmVzdW1lKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5pc1BhdXNlZCkge1xuICAgICAgICAgICAgbWUuaXNQYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIG1lLnJlbmRlckxvb3AoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhwb3NlZCBtZXRob2QgZm9yIFJlbW90ZSBBY2Nlc3MgdG8gdHJpZ2dlciB0aGUgcmVhY3RpdmUgY29uZmlnIHNldHRlci5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cbiAgICBzZXRUaGVtZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnRoZW1lID0gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBsb2NhbCBtb3VzZSBzdGF0ZSBmcm9tIG1haW4gdGhyZWFkIGV2ZW50cy5cbiAgICAgKiBEZWxlZ2F0ZXMgY2xpY2sgZXZlbnRzIHRvIGBvbk1vdXNlQ2xpY2tgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZGF0YS5jbGlja11cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkYXRhLmxlYXZlXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZGF0YS54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZGF0YS55XVxuICAgICAqL1xuICAgIHVwZGF0ZU1vdXNlU3RhdGUoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChkYXRhLmxlYXZlKSB7XG4gICAgICAgICAgICBtZS5tb3VzZS54ID0gLTEwMDA7XG4gICAgICAgICAgICBtZS5tb3VzZS55ID0gLTEwMDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChkYXRhLnggIT09IHVuZGVmaW5lZCkgbWUubW91c2UueCA9IGRhdGEueDtcbiAgICAgICAgICAgIGlmIChkYXRhLnkgIT09IHVuZGVmaW5lZCkgbWUubW91c2UueSA9IGRhdGEueTtcblxuICAgICAgICAgICAgaWYgKGRhdGEuY2xpY2spIHtcbiAgICAgICAgICAgICAgICBtZS5vbk1vdXNlQ2xpY2soZGF0YSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGNhbnZhcyBzaXplIGFuZCByZXNpemVzIHRoZSBpbnRlcm5hbCBjb250ZXh0LlxuICAgICAqIFRyaWdnZXJzIGB1cGRhdGVSZXNvdXJjZXNgIGhvb2sgdG8gYWxsb3cgc3ViY2xhc3NlcyB0byByZWdlbmVyYXRlIGJ1ZmZlcnMvZ3JhZGllbnRzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzaXplXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNpemUuaGVpZ2h0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNpemUud2lkdGhcbiAgICAgKi9cbiAgICB1cGRhdGVTaXplKHNpemUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5jYW52YXNTaXplID0gc2l6ZTtcblxuICAgICAgICBpZiAobWUuY29udGV4dCkge1xuICAgICAgICAgICAgbWUuY29udGV4dC5jYW52YXMud2lkdGggID0gc2l6ZS53aWR0aDtcbiAgICAgICAgICAgIG1lLmNvbnRleHQuY2FudmFzLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICAgICAgICAgICAgLy8gQ2FsbHMgdGhlIGhvb2sgdG8gcmUtZ2VuZXJhdGUgcmVzb3VyY2VzIGlmIGltcGxlbWVudGVkXG4gICAgICAgICAgICBtZS51cGRhdGVSZXNvdXJjZXM/LihzaXplLndpZHRoLCBzaXplLmhlaWdodClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBvbGxzIGZvciB0aGUgT2Zmc2NyZWVuQ2FudmFzIHVudGlsIGl0IGlzIGF2YWlsYWJsZSBpbiB0aGUgV29ya2VyJ3MgYGNhbnZhc1dpbmRvd01hcGAuXG4gICAgICogT25jZSBmb3VuZCwgaXQgaW5pdGlhbGl6ZXMgdGhlIGNvbnRleHQgYW5kIHN0YXJ0cyB0aGUgcmVuZGVyIGxvb3AuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNhbnZhc0lkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHdpbmRvd0lkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBoYXNDaGFuZ2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgd2FpdEZvckNhbnZhcyhjYW52YXNJZCwgd2luZG93SWQsIGhhc0NoYW5nZSkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNhbnZhcyA9IE5lby5jdXJyZW50V29ya2VyLmNhbnZhc1dpbmRvd01hcFtjYW52YXNJZF0/Llt3aW5kb3dJZF07XG5cbiAgICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICAgICAgbWUuY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgICAgICAvLyBTdGFuZGFyZGl6ZSBzaXplIHVwZGF0ZVxuICAgICAgICAgICAgbWUudXBkYXRlU2l6ZSh7d2lkdGg6IGNhbnZhcy53aWR0aCwgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0fSk7XG5cbiAgICAgICAgICAgIC8vIE9wdGlvbmFsIGhvb2sgZm9yIHN1YmNsYXNzZXNcbiAgICAgICAgICAgIG1lLm9uR3JhcGhNb3VudGVkPy4oY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICAgICAgICAgICAgaWYgKGhhc0NoYW5nZSAmJiAhbWUuYW5pbWF0aW9uSWQpIHtcbiAgICAgICAgICAgICAgICBtZS5yZW5kZXJMb29wKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQobWUud2FpdEZvckNhbnZhcy5iaW5kKG1lLCBjYW52YXNJZCwgd2luZG93SWQsIGhhc0NoYW5nZSksIDUwKVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhCYXNlKTtcbiIsImltcG9ydCBCYXNlIGZyb20gJy4vQmFzZS5tanMnO1xuXG5jb25zdFxuICAgIGhhc1JhZiAgICAgICAgID0gdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAvLyBNYXRjaGVzIGZ1bGwgaGV4IGNvZGVzIChlLmcuLCBcIiMwMDMzRkZcIiBvciBcIjAwMzNGRlwiKVxuICAgIGhleFRvUmdiUmVnZXggID0gL14jPyhbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KSQvaSxcbiAgICAvLyBNYXRjaGVzIHNob3J0aGFuZCBoZXggY29kZXMgKGUuZy4sIFwiIzAzRlwiIG9yIFwiMDNGXCIpIGZvciBleHBhbnNpb25cbiAgICBzaG9ydGhhbmRSZWdleCA9IC9eIz8oW2EtZlxcZF0pKFthLWZcXGRdKShbYS1mXFxkXSkkL2k7XG5cbmNvbnN0IEJBU0VfQ09MT1IgPSB7cjogNjQsIGc6IDE5NiwgYjogMjU1fTsgLy8gTmVvIEJsdWVcblxuY29uc3QgUEhZU0lDUyA9IHtcbiAgICBpbmZsdWVuY2VSYW5nZTogMTUwLFxuICAgIG1pbk1vZCAgICAgICAgOiAwLjIsXG4gICAgbWF4TW9kICAgICAgICA6IDEuNSxcbiAgICBwdWxzZUJvdW5kcyAgIDogLTIwMFxufTtcblxuLyoqXG4gKiBAc3VtbWFyeSBSZW5kZXJzIHRoZSBcIk5ldXJhbCBUaW1lbGluZVwiIHZpc3VhbGl6YXRpb24gZm9yIHRoZSBQb3J0YWwncyBUaWNrZXQgdmlldy5cbiAqXG4gKiBUaGlzIGNsYXNzIHJ1bnMgaW5zaWRlIGEgU2hhcmVkV29ya2VyICh2aWEgYENhbnZhc1dvcmtlcmApIHRvIHByb3ZpZGUgYSBoaWdoLXBlcmZvcm1hbmNlLFxuICogbWFpbi10aHJlYWQtYmxvY2tpbmctZnJlZSBhbmltYXRpb24uIEl0IHZpc3VhbGl6ZXMgdGhlIGZsb3cgb2YgdGltZSBhbmQgYWN0aXZpdHkgY29ubmVjdGluZ1xuICogdGltZWxpbmUgbm9kZXMgKHRpY2tldHMvZXZlbnRzKS5cbiAqXG4gKiBLZXkgVmlzdWFsIENvbmNlcHRzOlxuICogMS4gKipUaGUgU3BpbmUqKjogQSBjb250aW51b3VzLCBncmFkaWVudC1zdHJva2VkIGxpbmUgY29ubmVjdGluZyBhbGwgbm9kZXMuXG4gKiAyLiAqKlRoZSBQdWxzZSoqOiBBIFwiZGF0YSBwYWNrZXRcIiB0aGF0IHRyYXZlbHMgYWxvbmcgdGhlIHNwaW5lLlxuICogMy4gKipEdWFsLVBvaW50IFBoeXNpY3MqKjogVGhlIHB1bHNlIEhlYWQgYW5kIFRhaWwgYXJlIHNpbXVsYXRlZCBhcyBpbmRlcGVuZGVudCBwYXJ0aWNsZXMgbW92aW5nIHRocm91Z2ggdGhlXG4gKiAgICBzcGVlZCBmaWVsZC4gVGhpcyBjcmVhdGVzIG9yZ2FuaWMgXCJTcXVhc2ggYW5kIFN0cmV0Y2hcIiBiZWhhdmlvcjogY29tcHJlc3Npbmcgd2hlbiBlbnRlcmluZyBhIG5vZGUgKEhlYWQgc2xvd3MsIFRhaWwgZmFzdClcbiAqICAgIGFuZCBzdHJldGNoaW5nIHdoZW4gbGVhdmluZyAoSGVhZCBmYXN0LCBUYWlsIHNsb3cpLCB3aXRob3V0IHJlcXVpcmluZyBjb21wbGV4IGNvbnN0cmFpbnRzIG9yIGNhdXNpbmcgdmlzdWFsIGFydGlmYWN0cy5cbiAqIDQuICoqQ2hhbWVsZW9uIEVmZmVjdCoqOiBUaGUgcHVsc2UgZHluYW1pY2FsbHkgY2hhbmdlcyBpdHMgY29sb3IgdG8gbWF0Y2ggdGhlIHNlbWFudGljIGNvbG9yIG9mIHRoZVxuICogICAgbmVhcmVzdCBub2RlIChlLmcuLCBSZWQgZm9yIEJ1Z3MsIEdyZWVuIGZvciBGZWF0dXJlcykgYXMgaXQgcGFzc2VzIGJ5LlxuICpcbiAqIEBjbGFzcyBQb3J0YWwuY2FudmFzLlRpY2tldENhbnZhc1xuICogQGV4dGVuZHMgUG9ydGFsLmNhbnZhcy5CYXNlXG4gKiBAc2luZ2xldG9uXG4gKi9cbmNsYXNzIFRpY2tldENhbnZhcyBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb2xvcnMgPSB7XG4gICAgICAgIGRhcmsgOiB7XG4gICAgICAgICAgICBzcGluZTogWydyZ2JhKDYyLCA5OSwgMjIxLCAwLjIpJywgJ3JnYmEoNjQsIDE5NiwgMjU1LCAwLjQpJywgJ3JnYmEoNjIsIDk5LCAyMjEsIDAuMiknXVxuICAgICAgICB9LFxuICAgICAgICBsaWdodDoge1xuICAgICAgICAgICAgc3BpbmU6IFsncmdiYSgxNTAsIDE1MCwgMTUwLCAwLjEpJywgJ3JnYmEoMTUwLCAxNTAsIDE1MCwgMC4zKScsICdyZ2JhKDE1MCwgMTUwLCAxNTAsIDAuMSknXVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdQb3J0YWwuY2FudmFzLlRpY2tldENhbnZhcydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnUG9ydGFsLmNhbnZhcy5UaWNrZXRDYW52YXMnLFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3RlIG1ldGhvZCBhY2Nlc3NcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSByZW1vdGVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3RlOiB7XG4gICAgICAgICAgICBhcHA6IFtcbiAgICAgICAgICAgICAgICAnY2xlYXJHcmFwaCcsXG4gICAgICAgICAgICAgICAgJ2luaXRHcmFwaCcsXG4gICAgICAgICAgICAgICAgJ3NldFRoZW1lJyxcbiAgICAgICAgICAgICAgICAndXBkYXRlR3JhcGhEYXRhJyxcbiAgICAgICAgICAgICAgICAndXBkYXRlU2l6ZSdcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZXRvbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZXRvbjogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gdGhlbWU9J2xpZ2h0J1xuICAgICAgICAgKi9cbiAgICAgICAgdGhlbWU6ICdsaWdodCdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGJhc2VTcGVlZD0wLjVcbiAgICAgKi9cbiAgICBiYXNlU3BlZWQgPSAwLjVcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGxhc3RGcmFtZVRpbWU9MFxuICAgICAqL1xuICAgIGxhc3RGcmFtZVRpbWUgPSAwXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7QXJyYXl9IG5vZGVzPVtdXG4gICAgICovXG4gICAgbm9kZXMgPSBbXVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gcHVsc2VZPTBcbiAgICAgKi9cbiAgICBwdWxzZVkgPSAwXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSBwdWxzZUJvdHRvbT0xMDBcbiAgICAgKi9cbiAgICBwdWxzZUJvdHRvbSA9IDEwMFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gc3RhcnRZPTBcbiAgICAgKi9cbiAgICBzdGFydFkgPSAwXG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGdyYXBoIHN0YXRlIGFuZCBzdG9wcyB0aGUgcmVuZGVyIGxvb3AuXG4gICAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGUgdmlldyB1bm1vdW50cyB0byBwcmV2ZW50IFwiWm9tYmllIExvb3BzXCIuXG4gICAgICovXG4gICAgY2xlYXJHcmFwaCgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcbiAgICAgICAgc3VwZXIuY2xlYXJHcmFwaCgpO1xuICAgICAgICBtZS5ub2RlcyAgICAgICAgID0gW107XG4gICAgICAgIG1lLmxhc3RGcmFtZVRpbWUgPSAwO1xuICAgICAgICBtZS5wdWxzZUJvdHRvbSAgID0gMFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGhvcml6b250YWwgKFgpIHBvc2l0aW9uIG9uIHRoZSBzcGluZSBmb3IgYSBnaXZlbiB2ZXJ0aWNhbCAoWSkgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBTaW5jZSB0aGUgbm9kZXMgYXJlIG5vdCB2ZXJ0aWNhbGx5IGFsaWduZWQgKHRoZXkgd2VhdmUgbGVmdC9yaWdodCksIHRoZSBzcGluZSBpcyBhIHBvbHlsaW5lLlxuICAgICAqIFRoaXMgbWV0aG9kIHBlcmZvcm1zIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdGhlIHR3byBuZWFyZXN0IG5vZGVzIHRvIGVuc3VyZSB0aGVcbiAgICAgKiBcIlB1bHNlXCIgc3RheXMgcGVyZmVjdGx5IGNlbnRlcmVkIG9uIHRoZSBzcGluZSBwYXRoIGFzIGl0IHRyYXZlbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSAtIFRoZSB2ZXJ0aWNhbCBwb3NpdGlvblxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IHggLSBUaGUgY2FsY3VsYXRlZCBob3Jpem9udGFsIHBvc2l0aW9uIG9uIHRoZSBzcGluZVxuICAgICAqL1xuICAgIGdldFhBdFkoeSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5ub2Rlcy5sZW5ndGggPCAyKSByZXR1cm4gbWUubm9kZXNbMF0/LnggfHwgMzg7XG4gICAgICAgIGlmICh5IDwgbWUubm9kZXNbMF0ueSkgICByZXR1cm4gbWUubm9kZXNbMF0ueDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lLm5vZGVzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1cnIgPSBtZS5ub2Rlc1tpXSxcbiAgICAgICAgICAgICAgICBuZXh0ID0gbWUubm9kZXNbaSsxXTtcblxuICAgICAgICAgICAgaWYgKHkgPj0gY3Vyci55ICYmIHkgPD0gbmV4dC55KSB7XG4gICAgICAgICAgICAgICAgbGV0IHJhdGlvID0gKHkgLSBjdXJyLnkpIC8gKG5leHQueSAtIGN1cnIueSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnIueCArIChuZXh0LnggLSBjdXJyLngpICogcmF0aW87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWUubm9kZXNbbWUubm9kZXMubGVuZ3RoIC0gMV0ueFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHBoeXNpY3Mgc3RhdGUgKHNwZWVkLCBuZWFyZXN0IG5vZGUpIGZvciBhIGdpdmVuIFkgcG9zaXRpb24uXG4gICAgICogVGhpcyBhY3RzIGFzIHRoZSBcIlRyYWZmaWMgTW9kZWxcIiBlbmdpbmUsIGRldGVybWluaW5nIHRoZSBsb2NhbCBzcGVlZCBsaW1pdCBiYXNlZCBvbiBwcm94aW1pdHlcbiAgICAgKiB0byBub2Rlcy4gUGFydGljbGVzIHNsb3cgZG93biBuZWFyIG5vZGVzIChvYnNlcnZhdGlvbikgYW5kIGFjY2VsZXJhdGUgaW4gZW1wdHkgc3BhY2UgKHRyYXZlbCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHtzcGVlZE1vZGlmaWVyLCBuZWFyTm9kZSwgbWluRGlzdH1cbiAgICAgKi9cbiAgICBnZXRQaHlzaWNzKHkpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIG1pbkRpc3QgID0gSW5maW5pdHksXG4gICAgICAgICAgICBuZWFyTm9kZSA9IG51bGw7XG5cbiAgICAgICAgbWUubm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgIGxldCBkaXN0ID0gTWF0aC5hYnMoeSAtIG5vZGUueSk7XG4gICAgICAgICAgICBpZiAoZGlzdCA8IG1pbkRpc3QpIHtcbiAgICAgICAgICAgICAgICBtaW5EaXN0ICA9IGRpc3Q7XG4gICAgICAgICAgICAgICAgbmVhck5vZGUgPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB7aW5mbHVlbmNlUmFuZ2UsIG1pbk1vZCwgbWF4TW9kfSA9IFBIWVNJQ1M7XG4gICAgICAgIGxldCBzcGVlZE1vZGlmaWVyID0gbWF4TW9kO1xuXG4gICAgICAgIGlmIChtaW5EaXN0IDwgaW5mbHVlbmNlUmFuZ2UpIHtcbiAgICAgICAgICAgIGxldCByYXRpbyA9IG1pbkRpc3QgLyBpbmZsdWVuY2VSYW5nZTtcbiAgICAgICAgICAgIHNwZWVkTW9kaWZpZXIgPSBtaW5Nb2QgKyAobWF4TW9kIC0gbWluTW9kKSAqIChyYXRpbyAqIHJhdGlvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7c3BlZWRNb2RpZmllciwgbmVhck5vZGUsIG1pbkRpc3R9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIHRvIHBhcnNlIGhleCB0byByZ2JcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaGV4XG4gICAgICogQHJldHVybnMge09iamVjdH0ge3IsZyxifVxuICAgICAqL1xuICAgIGhleFRvUmdiKGhleCkge1xuICAgICAgICBoZXggPSBoZXgucmVwbGFjZShzaG9ydGhhbmRSZWdleCwgZnVuY3Rpb24obSwgciwgZywgYikge1xuICAgICAgICAgICAgcmV0dXJuIHIgKyByICsgZyArIGcgKyBiICsgYjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaGV4VG9SZ2JSZWdleC5leGVjKGhleCk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdCA/IHtcbiAgICAgICAgICAgIHI6IHBhcnNlSW50KHJlc3VsdFsxXSwgMTYpLFxuICAgICAgICAgICAgZzogcGFyc2VJbnQocmVzdWx0WzJdLCAxNiksXG4gICAgICAgICAgICBiOiBwYXJzZUludChyZXN1bHRbM10sIDE2KVxuICAgICAgICB9IDogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGdyYXBoIHdpdGggbmV3IHRpbWVsaW5lIG5vZGVzLlxuICAgICAqIFdoZW4gYHJlc2V0YCBpcyB0cnVlLCBpdCBoYXJkLXJlc2V0cyB0aGUgcGh5c2ljcyBzaW11bGF0aW9uIChwb3NpdGlvbnMgYW5kIHRpbWUpIHRvIHByZXZlbnRcbiAgICAgKiB2aXN1YWwgYXJ0aWZhY3RzIChqdW1waW5nL2ZsYXNoaW5nKSB3aGVuIHN3aXRjaGluZyBiZXR3ZWVuIGRpZmZlcmVudCB0aWNrZXQgY29udGV4dHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7QXJyYXl9ICBkYXRhLm5vZGVzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZGF0YS5yZXNldF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2RhdGEuc3RhcnRZXVxuICAgICAqL1xuICAgIHVwZGF0ZUdyYXBoRGF0YShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG4gICAgICAgIG1lLm5vZGVzID0gZGF0YS5ub2RlcyB8fCBbXTtcbiAgICAgICAgaWYgKGRhdGEuc3RhcnRZICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1lLnN0YXJ0WSA9IGRhdGEuc3RhcnRZO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGEucmVzZXQpIHtcbiAgICAgICAgICAgIG1lLnB1bHNlWSAgICAgID0gUEhZU0lDUy5wdWxzZUJvdW5kcztcbiAgICAgICAgICAgIG1lLnB1bHNlQm90dG9tID0gUEhZU0lDUy5wdWxzZUJvdW5kcyArIDEwMDtcbiAgICAgICAgICAgIG1lLmxhc3RGcmFtZVRpbWUgPSAwXG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbnN1cmUgYW5pbWF0aW9uIGxvb3AgaXMgcnVubmluZyBpZiB3ZSBoYXZlIGRhdGFcbiAgICAgICAgaWYgKG1lLm5vZGVzLmxlbmd0aCA+IDAgJiYgIW1lLmFuaW1hdGlvbklkICYmIG1lLmNvbnRleHQpIHtcbiAgICAgICAgICAgIG1lLnJlbmRlckxvb3AoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIE1haW4gQW5pbWF0aW9uIExvb3AgKDYwZnBzKS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHJlc3BvbnNpYmxlIGZvcjpcbiAgICAgKiAxLiAqKlBoeXNpY3MgQ2FsY3VsYXRpb24qKjogRGV0ZXJtaW5pbmcgdGhlIHB1bHNlJ3Mgc3BlZWQgYmFzZWQgb24gcHJveGltaXR5IHRvIG5vZGVzIChcIlRyYWZmaWMgTW9kZWxcIikuXG4gICAgICogMi4gKipTdGF0ZSBVcGRhdGVzKio6IFVwZGF0aW5nIHRoZSBwdWxzZSdzIHBvc2l0aW9uIChgcHVsc2VZYCkgYW5kIGNvbG9yIChgQ2hhbWVsZW9uIEVmZmVjdGApLlxuICAgICAqIDMuICoqRHJhd2luZyoqOiBSZW5kZXJpbmcgdGhlIHNwaW5lLCB0aGUgcHVsc2UsIGFuZCB0aGUgbm9kZSBnbG93cyB0byB0aGUgYE9mZnNjcmVlbkNhbnZhc2AuXG4gICAgICpcbiAgICAgKiBJdCB1c2VzIGBzZXRUaW1lb3V0YCBpbnN0ZWFkIG9mIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIGJlY2F1c2UgU2hhcmVkV29ya2VycyBkbyBub3QgZ2VuZXJhbGx5IHN1cHBvcnQgckFGLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIW1lLmNhblJlbmRlcikge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdFxuICAgICAgICAgICAgY3R4ICAgID0gbWUuY29udGV4dCxcbiAgICAgICAgICAgIHdpZHRoICA9IG1lLmNhbnZhc1NpemU/LndpZHRoICB8fCA4MDAsXG4gICAgICAgICAgICBoZWlnaHQgPSBtZS5jYW52YXNTaXplPy5oZWlnaHQgfHwgNjAwLFxuICAgICAgICAgICAgbm93ICAgID0gRGF0ZS5ub3coKTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGJvdHRvbS1tb3N0IGJvdW5kYXJ5IChsYXN0IGl0ZW0ncyBZIG9yIGRlZmF1bHQgaGVpZ2h0KVxuICAgICAgICBsZXQgbWF4WSA9IGhlaWdodDtcblxuICAgICAgICBpZiAobWUubm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbWF4WSA9IG1lLm5vZGVzW21lLm5vZGVzLmxlbmd0aCAtIDFdLnlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRpbWUgZGVsdGEgaW4gbXNcbiAgICAgICAgbGV0IGR0ID0gbm93IC0gKG1lLmxhc3RGcmFtZVRpbWUgfHwgbm93KTtcbiAgICAgICAgbWUubGFzdEZyYW1lVGltZSA9IG5vdztcblxuICAgICAgICAvLyBDYXAgZHQgdG8gcHJldmVudCBodWdlIGp1bXBzXG4gICAgICAgIGlmIChkdCA+IDEwMCkgZHQgPSAxNjtcblxuICAgICAgICAvLyAxLiBDYWxjdWxhdGUgUGh5c2ljc1xuICAgICAgICAvLyBcIkR1YWwtUG9pbnQgUGh5c2ljc1wiOiBXZSBzaW11bGF0ZSB0aGUgSGVhZCBhbmQgVGFpbCBvZiB0aGUgcHVsc2UgYXMgaW5kZXBlbmRlbnQgcGFydGljbGVzXG4gICAgICAgIC8vIG1vdmluZyB0aHJvdWdoIHRoZSBcIlRyYWZmaWMgTW9kZWxcIiBzcGVlZCBmaWVsZC5cbiAgICAgICAgLy8gLSBXaGVuIEhlYWQgaGl0cyBhIG5vZGUgKHNsb3cgem9uZSksIGl0IHNsb3dzIGRvd24uIFRhaWwgKGluIGZhc3Qgem9uZSkgY2F0Y2hlcyB1cC4gLT4gU3F1YXNoLlxuICAgICAgICAvLyAtIFdoZW4gSGVhZCBsZWF2ZXMgYSBub2RlLCBpdCBzcGVlZHMgdXAuIFRhaWwgKGluIHNsb3cgem9uZSkgbGFncyBiZWhpbmQuIC0+IFN0cmV0Y2guXG4gICAgICAgIC8vIFRoaXMgY3JlYXRlcyBvcmdhbmljLCBwaHlzaWNhbGx5IGNvcnJlY3QgZGVmb3JtYXRpb24gd2l0aG91dCBcInJldHJhY3Rpb25cIiBnbGl0Y2hlcyBvciBhcnRpZmljaWFsIHN0YWxscy5cblxuICAgICAgICBjb25zdFxuICAgICAgICAgICAgcGh5c2ljc1RvcCAgICA9IG1lLmdldFBoeXNpY3MobWUucHVsc2VZKSxcbiAgICAgICAgICAgIHBoeXNpY3NCb3R0b20gPSBtZS5nZXRQaHlzaWNzKG1lLnB1bHNlQm90dG9tKSxcbiAgICAgICAgICAgIHtuZWFyTm9kZSwgbWluRGlzdH0gPSBwaHlzaWNzVG9wOyAvLyBVc2UgVG9wIGZvciBjb2xvci9wcm94aW1pdHkgbG9naWMgdG8gbWF0Y2ggb3JpZ2luYWwgZmVlbFxuXG4gICAgICAgIC8vIEFwcGx5IEluZGVwZW5kZW50IFZlbG9jaXRpZXNcbiAgICAgICAgbWUucHVsc2VZICAgICAgKz0gbWUuYmFzZVNwZWVkICogcGh5c2ljc1RvcC5zcGVlZE1vZGlmaWVyICAgICogZHQ7XG4gICAgICAgIG1lLnB1bHNlQm90dG9tICs9IG1lLmJhc2VTcGVlZCAqIHBoeXNpY3NCb3R0b20uc3BlZWRNb2RpZmllciAqIGR0O1xuXG4gICAgICAgIC8vIENvbnN0cmFpbnQ6IE1pbmltdW0gTGVuZ3RoIChlLmcuIDE1cHgpLlxuICAgICAgICAvLyBXaGlsZSBEdWFsLVBvaW50IFBoeXNpY3MgbmF0dXJhbGx5IGhhbmRsZXMgY29tcHJlc3Npb24sIGV4dHJlbWUgZGVjZWxlcmF0aW9uIGNhbiB0aGVvcmV0aWNhbGx5XG4gICAgICAgIC8vIGNhdXNlIHRoZSBIZWFkIHRvIG1vdmUgc2xvd2VyIHRoYW4gdGhlIFRhaWwgZm9yIHRvbyBsb25nLCBpbnZlcnRpbmcgdGhlIHB1bHNlLlxuICAgICAgICAvLyBUaGlzIGhhcmQgY29uc3RyYWludCBwcmVzZXJ2ZXMgcGh5c2ljYWwgcGxhdXNpYmlsaXR5IChtYXR0ZXIgY2Fubm90IGhhdmUgbmVnYXRpdmUgbGVuZ3RoKS5cbiAgICAgICAgaWYgKG1lLnB1bHNlQm90dG9tIDwgbWUucHVsc2VZICsgMTUpIHtcbiAgICAgICAgICAgIG1lLnB1bHNlQm90dG9tID0gbWUucHVsc2VZICsgMTVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdyYXAgQXJvdW5kXG4gICAgICAgIGlmIChtZS5wdWxzZVkgPiBtYXhZIC0gUEhZU0lDUy5wdWxzZUJvdW5kcykge1xuICAgICAgICAgICAgbWUucHVsc2VZICAgICAgPSBQSFlTSUNTLnB1bHNlQm91bmRzO1xuICAgICAgICAgICAgbWUucHVsc2VCb3R0b20gPSBQSFlTSUNTLnB1bHNlQm91bmRzICsgMTAwIC8vIFJlc2V0IGxlbmd0aCBvbiBsb29wXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwdWxzZUxlbmd0aCA9IG1lLnB1bHNlQm90dG9tIC0gbWUucHVsc2VZO1xuXG4gICAgICAgIC8vIENvbG9yIEludGVycG9sYXRpb24gKENoYW1lbGVvbiBFZmZlY3QpXG4gICAgICAgIC8vIFRoZSBwdWxzZSBcImFic29yYnNcIiB0aGUgY29sb3Igb2YgdGhlIG5vZGUgaXQgaXMgY3VycmVudGx5IHBhc3NpbmcuXG4gICAgICAgIGxldCB7ciwgZywgYn0gPSBCQVNFX0NPTE9SO1xuXG4gICAgICAgIC8vIElmIG5lYXIgYSBjb2xvcmVkIG5vZGUgKHdpdGhpbiAxMDBweCksIGludGVycG9sYXRlIHRvIGl0cyBjb2xvclxuICAgICAgICBpZiAobmVhck5vZGUgJiYgbmVhck5vZGUuY29sb3IgJiYgbWluRGlzdCA8IDEwMCkge1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IG1lLmhleFRvUmdiKG5lYXJOb2RlLmNvbG9yKTtcbiAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWl4ID0gMSAtIChtaW5EaXN0IC8gMTAwKTtcbiAgICAgICAgICAgICAgICByID0gciArICh0YXJnZXQuciAtIHIpICogbWl4O1xuICAgICAgICAgICAgICAgIGcgPSBnICsgKHRhcmdldC5nIC0gZykgKiBtaXg7XG4gICAgICAgICAgICAgICAgYiA9IGIgKyAodGFyZ2V0LmIgLSBiKSAqIG1peFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcHVsc2VDb2xvclN0ciA9IGByZ2JhKCR7TWF0aC5yb3VuZChyKX0sICR7TWF0aC5yb3VuZChnKX0sICR7TWF0aC5yb3VuZChiKX1gOyAvLyBsZWF2ZXMgYWxwaGEgb3BlblxuXG4gICAgICAgIC8vIDIuIENsZWFyXG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgLy8gMy4gRHJhdyBOZXVyYWwgQ29ubmVjdGlvbnMgKFRoZSBcIlNwaW5lXCIpXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICB0aGVtZUNvbG9ycyA9IG1lLmNvbnN0cnVjdG9yLmNvbG9yc1ttZS50aGVtZV0sXG4gICAgICAgICAgICBncmFkaWVudCAgICA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCAwLCBoZWlnaHQpO1xuXG4gICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCAgIHRoZW1lQ29sb3JzLnNwaW5lWzBdKTtcbiAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAuNSwgdGhlbWVDb2xvcnMuc3BpbmVbMV0pO1xuICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgICB0aGVtZUNvbG9ycy5zcGluZVsyXSk7XG5cbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gZ3JhZGllbnQ7XG4gICAgICAgIGN0eC5saW5lV2lkdGggICA9IDI7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgICBpZiAobWUubm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gbWUubm9kZXNbMF07XG4gICAgICAgICAgICBjdHgubW92ZVRvKGZpcnN0LngsIGZpcnN0LnkpO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG1lLm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBtZS5ub2Rlc1tpXTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKG5vZGUueCwgbm9kZS55KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICAvLyA0LiBEcmF3IFwiUHVsc2VcIiBFZmZlY3RcbiAgICAgICAgY29uc3QgcHVsc2VZID0gbWUucHVsc2VZO1xuXG4gICAgICAgIGlmIChtZS5ub2Rlcy5sZW5ndGggPiAwICYmIHB1bHNlWSA+IG1lLm5vZGVzWzBdLnkgLSBwdWxzZUxlbmd0aCAmJiBwdWxzZVkgPCBtYXhZKSB7XG4gICAgICAgICAgICBjb25zdCBwdWxzZUdyYWQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgcHVsc2VZLCAwLCBwdWxzZVkgKyBwdWxzZUxlbmd0aCk7XG4gICAgICAgICAgICBwdWxzZUdyYWQuYWRkQ29sb3JTdG9wKDAsICAgYCR7cHVsc2VDb2xvclN0cn0sIDApYCk7XG4gICAgICAgICAgICBwdWxzZUdyYWQuYWRkQ29sb3JTdG9wKDAuNSwgYCR7cHVsc2VDb2xvclN0cn0sIDEpYCk7XG4gICAgICAgICAgICBwdWxzZUdyYWQuYWRkQ29sb3JTdG9wKDEsICAgYCR7cHVsc2VDb2xvclN0cn0sIDApYCk7XG5cbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHB1bHNlR3JhZDtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggICA9IDQ7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgICAgIGxldCBwdWxzZVggPSBtZS5nZXRYQXRZKHB1bHNlWSk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHB1bHNlWCwgcHVsc2VZKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8obWUuZ2V0WEF0WShwdWxzZVkgKyBwdWxzZUxlbmd0aCksIE1hdGgubWluKHB1bHNlWSArIHB1bHNlTGVuZ3RoLCBtYXhZKSk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDUuIFwiVGhlIEdhcFwiXG4gICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3V0JztcbiAgICAgICAgY3R4LmZpbGxTdHlsZSAgICAgICAgICAgICAgICA9ICcjMDAwJztcblxuICAgICAgICBtZS5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUucmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5hcmMobm9kZS54LCBub2RlLnksIG5vZGUucmFkaXVzLCAwLCAyICogTWF0aC5QSSk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyA1LiBEcmF3IE9yYml0L0dsb3cgRWZmZWN0c1xuICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1vdmVyJztcblxuICAgICAgICBtZS5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgY29uc3RcbiAgICAgICAgICAgICAgICByYWRpdXMgID0gbm9kZS5yYWRpdXMgfHwgMjAsXG4gICAgICAgICAgICAgICAgeCAgICAgICA9IG5vZGUueCxcbiAgICAgICAgICAgICAgICB5ICAgICAgID0gbm9kZS55LFxuICAgICAgICAgICAgICAgIHBUb3AgICAgPSBwdWxzZVksXG4gICAgICAgICAgICAgICAgcEJvdHRvbSA9IHB1bHNlWSArIHB1bHNlTGVuZ3RoLFxuICAgICAgICAgICAgICAgIG5Ub3AgICAgPSB5IC0gcmFkaXVzLFxuICAgICAgICAgICAgICAgIG5Cb3R0b20gPSB5ICsgcmFkaXVzO1xuXG4gICAgICAgICAgICBpZiAocEJvdHRvbSA+IG5Ub3AgJiYgcFRvcCA8IG5Cb3R0b20pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBnZXRBbmdsZSA9ICh2YWwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGR5ID0gdmFsIC0geTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xhbXAgdG8gcmFkaXVzIHRvIGF2b2lkIE5hTiBpbiBhc2luXG4gICAgICAgICAgICAgICAgICAgIGR5ID0gTWF0aC5tYXgoLXJhZGl1cywgTWF0aC5taW4ocmFkaXVzLCBkeSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5hc2luKGR5IC8gcmFkaXVzKVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBjb25zdFxuICAgICAgICAgICAgICAgICAgICBhbmdsZVRhaWwgPSBnZXRBbmdsZShwVG9wKSxcbiAgICAgICAgICAgICAgICAgICAgYW5nbGVIZWFkID0gZ2V0QW5nbGUocEJvdHRvbSk7XG5cbiAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIERZTkFNSUMgY29sb3IgaGVyZSB0b28hXG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gYCR7cHVsc2VDb2xvclN0cn0sIDEpYDtcbiAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoICAgPSAyO1xuXG4gICAgICAgICAgICAgICAgLy8gUmlnaHQgQXJjXG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzICsgMiwgYW5nbGVUYWlsLCBhbmdsZUhlYWQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBMZWZ0IEFyY1xuICAgICAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgICAgICAgIGxlZnRUYWlsID0gTWF0aC5QSSAtIGFuZ2xlVGFpbCxcbiAgICAgICAgICAgICAgICAgICAgbGVmdEhlYWQgPSBNYXRoLlBJIC0gYW5nbGVIZWFkO1xuXG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzICsgMiwgbGVmdFRhaWwsIGxlZnRIZWFkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGhhc1JhZikge1xuICAgICAgICAgICAgbWUuYW5pbWF0aW9uSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobWUucmVuZGVyTG9vcClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLmFuaW1hdGlvbklkID0gc2V0VGltZW91dChtZS5yZW5kZXJMb29wLCAxMDAwIC8gNjApXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFRpY2tldENhbnZhcyk7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==