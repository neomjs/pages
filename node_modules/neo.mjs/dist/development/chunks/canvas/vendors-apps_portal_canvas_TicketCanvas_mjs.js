export const __webpack_esm_id__ = "vendors-apps_portal_canvas_TicketCanvas_mjs";
export const __webpack_esm_ids__ = ["vendors-apps_portal_canvas_TicketCanvas_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./apps/portal/canvas/TicketCanvas.mjs"
/*!*********************************************!*\
  !*** ./apps/portal/canvas/TicketCanvas.mjs ***!
  \*********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_canvas_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/canvas/Base.mjs */ "./src/canvas/Base.mjs");


const
    hasRaf         = typeof requestAnimationFrame === 'function',
    // Matches full hex codes (e.g., "#0033FF" or "0033FF")
    hexToRgbRegex  = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,
    // Matches shorthand hex codes (e.g., "#03F" or "03F") for expansion
    shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;

const BASE_COLOR = {r: 64, g: 196, b: 255}; // Neo Blue

const PHYSICS = {
    influenceRange: 150,
    minMod        : 0.2,
    maxMod        : 1.5,
    pulseBounds   : -200
};

/**
 * @summary Renders the "Neural Timeline" visualization for the Portal's Ticket view.
 *
 * This class runs inside a SharedWorker (via `CanvasWorker`) to provide a high-performance,
 * main-thread-blocking-free animation. It visualizes the flow of time and activity connecting
 * timeline nodes (tickets/events).
 *
 * Key Visual Concepts:
 * 1. **The Spine**: A continuous, gradient-stroked line connecting all nodes.
 * 2. **The Pulse**: A "data packet" that travels along the spine.
 * 3. **Dual-Point Physics**: The pulse Head and Tail are simulated as independent particles moving through the
 *    speed field. This creates organic "Squash and Stretch" behavior: compressing when entering a node (Head slows, Tail fast)
 *    and stretching when leaving (Head fast, Tail slow), without requiring complex constraints or causing visual artifacts.
 * 4. **Chameleon Effect**: The pulse dynamically changes its color to match the semantic color of the
 *    nearest node (e.g., Red for Bugs, Green for Features) as it passes by.
 *
 * @class Portal.canvas.TicketCanvas
 * @extends Portal.canvas.Base
 * @singleton
 */
class TicketCanvas extends _src_canvas_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static colors = {
        dark : {
            spine: ['rgba(62, 99, 221, 0.2)', 'rgba(64, 196, 255, 0.4)', 'rgba(62, 99, 221, 0.2)']
        },
        light: {
            spine: ['rgba(150, 150, 150, 0.1)', 'rgba(150, 150, 150, 0.3)', 'rgba(150, 150, 150, 0.1)']
        }
    }

    static config = {
        /**
         * @member {String} className='Portal.canvas.TicketCanvas'
         * @protected
         */
        className: 'Portal.canvas.TicketCanvas',
        /**
         * Remote method access
         * @member {Object} remote
         * @protected
         */
        remote: {
            app: [
                'clearGraph',
                'initGraph',
                'setTheme',
                'updateGraphData',
                'updateSize'
            ]
        },
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true,
        /**
         * @member {String} theme='light'
         */
        theme: 'light'
    }

    /**
     * @member {Number} baseSpeed=0.5
     */
    baseSpeed = 0.5
    /**
     * @member {Number} lastFrameTime=0
     */
    lastFrameTime = 0
    /**
     * @member {Array} nodes=[]
     */
    nodes = []
    /**
     * @member {Number} pulseY=0
     */
    pulseY = 0
    /**
     * @member {Number} pulseBottom=100
     */
    pulseBottom = 100
    /**
     * @member {Number} startY=0
     */
    startY = 0

    /**
     * Clears the graph state and stops the render loop.
     * This is called when the view unmounts to prevent "Zombie Loops".
     */
    clearGraph() {
        let me = this;
        super.clearGraph();
        me.nodes         = [];
        me.lastFrameTime = 0;
        me.pulseBottom   = 0
    }

    /**
     * Calculates the horizontal (X) position on the spine for a given vertical (Y) position.
     *
     * Since the nodes are not vertically aligned (they weave left/right), the spine is a polyline.
     * This method performs linear interpolation between the two nearest nodes to ensure the
     * "Pulse" stays perfectly centered on the spine path as it travels.
     *
     * @param {Number} y - The vertical position
     * @returns {Number} x - The calculated horizontal position on the spine
     */
    getXAtY(y) {
        let me = this;

        if (me.nodes.length < 2) return me.nodes[0]?.x || 38;
        if (y < me.nodes[0].y)   return me.nodes[0].x;

        for (let i = 0; i < me.nodes.length - 1; i++) {
            let curr = me.nodes[i],
                next = me.nodes[i+1];

            if (y >= curr.y && y <= next.y) {
                let ratio = (y - curr.y) / (next.y - curr.y);
                return curr.x + (next.x - curr.x) * ratio;
            }
        }

        return me.nodes[me.nodes.length - 1].x
    }

    /**
     * Calculates the physics state (speed, nearest node) for a given Y position.
     * This acts as the "Traffic Model" engine, determining the local speed limit based on proximity
     * to nodes. Particles slow down near nodes (observation) and accelerate in empty space (travel).
     *
     * @param {Number} y
     * @returns {Object} {speedModifier, nearNode, minDist}
     */
    getPhysics(y) {
        let me       = this,
            minDist  = Infinity,
            nearNode = null;

        me.nodes.forEach(node => {
            let dist = Math.abs(y - node.y);
            if (dist < minDist) {
                minDist  = dist;
                nearNode = node;
            }
        });

        const {influenceRange, minMod, maxMod} = PHYSICS;
        let speedModifier = maxMod;

        if (minDist < influenceRange) {
            let ratio = minDist / influenceRange;
            speedModifier = minMod + (maxMod - minMod) * (ratio * ratio);
        }

        return {speedModifier, nearNode, minDist}
    }

    /**
     * Helper to parse hex to rgb
     * @param {String} hex
     * @returns {Object} {r,g,b}
     */
    hexToRgb(hex) {
        hex = hex.replace(shorthandRegex, function(m, r, g, b) {
            return r + r + g + g + b + b;
        });

        const result = hexToRgbRegex.exec(hex);

        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : null
    }

    /**
     * Updates the graph with new timeline nodes.
     * When `reset` is true, it hard-resets the physics simulation (positions and time) to prevent
     * visual artifacts (jumping/flashing) when switching between different ticket contexts.
     *
     * @param {Object} data
     * @param {Array}  data.nodes
     * @param {Boolean} [data.reset]
     * @param {Number} [data.startY]
     */
    updateGraphData(data) {
        let me = this;
        me.nodes = data.nodes || [];
        if (data.startY !== undefined) {
            me.startY = data.startY;
        }

        if (data.reset) {
            me.pulseY      = PHYSICS.pulseBounds;
            me.pulseBottom = PHYSICS.pulseBounds + 100;
            me.lastFrameTime = 0
        }

        // Ensure animation loop is running if we have data
        if (me.nodes.length > 0 && !me.animationId && me.context) {
            me.renderLoop()
        }
    }

    /**
     * The Main Animation Loop (60fps).
     *
     * This method is responsible for:
     * 1. **Physics Calculation**: Determining the pulse's speed based on proximity to nodes ("Traffic Model").
     * 2. **State Updates**: Updating the pulse's position (`pulseY`) and color (`Chameleon Effect`).
     * 3. **Drawing**: Rendering the spine, the pulse, and the node glows to the `OffscreenCanvas`.
     *
     * It uses `setTimeout` instead of `requestAnimationFrame` because SharedWorkers do not generally support rAF.
     */
    render() {
        let me = this;

        if (!me.canRender) {
            return
        }

        const
            ctx    = me.context,
            width  = me.canvasSize?.width  || 800,
            height = me.canvasSize?.height || 600,
            now    = Date.now();

        // Calculate the bottom-most boundary (last item's Y or default height)
        let maxY = height;

        if (me.nodes.length > 0) {
            maxY = me.nodes[me.nodes.length - 1].y
        }

        // Time delta in ms
        let dt = now - (me.lastFrameTime || now);
        me.lastFrameTime = now;

        // Cap dt to prevent huge jumps
        if (dt > 100) dt = 16;

        // 1. Calculate Physics
        // "Dual-Point Physics": We simulate the Head and Tail of the pulse as independent particles
        // moving through the "Traffic Model" speed field.
        // - When Head hits a node (slow zone), it slows down. Tail (in fast zone) catches up. -> Squash.
        // - When Head leaves a node, it speeds up. Tail (in slow zone) lags behind. -> Stretch.
        // This creates organic, physically correct deformation without "retraction" glitches or artificial stalls.

        const
            physicsTop    = me.getPhysics(me.pulseY),
            physicsBottom = me.getPhysics(me.pulseBottom),
            {nearNode, minDist} = physicsTop; // Use Top for color/proximity logic to match original feel

        // Apply Independent Velocities
        me.pulseY      += me.baseSpeed * physicsTop.speedModifier    * dt;
        me.pulseBottom += me.baseSpeed * physicsBottom.speedModifier * dt;

        // Constraint: Minimum Length (e.g. 15px).
        // While Dual-Point Physics naturally handles compression, extreme deceleration can theoretically
        // cause the Head to move slower than the Tail for too long, inverting the pulse.
        // This hard constraint preserves physical plausibility (matter cannot have negative length).
        if (me.pulseBottom < me.pulseY + 15) {
            me.pulseBottom = me.pulseY + 15
        }

        // Wrap Around
        if (me.pulseY > maxY - PHYSICS.pulseBounds) {
            me.pulseY      = PHYSICS.pulseBounds;
            me.pulseBottom = PHYSICS.pulseBounds + 100 // Reset length on loop
        }

        const pulseLength = me.pulseBottom - me.pulseY;

        // Color Interpolation (Chameleon Effect)
        // The pulse "absorbs" the color of the node it is currently passing.
        let {r, g, b} = BASE_COLOR;

        // If near a colored node (within 100px), interpolate to its color
        if (nearNode && nearNode.color && minDist < 100) {
            let target = me.hexToRgb(nearNode.color);
            if (target) {
                let mix = 1 - (minDist / 100);
                r = r + (target.r - r) * mix;
                g = g + (target.g - g) * mix;
                b = b + (target.b - b) * mix
            }
        }

        const pulseColorStr = `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}`; // leaves alpha open

        // 2. Clear
        ctx.clearRect(0, 0, width, height);

        // 3. Draw Neural Connections (The "Spine")
        const
            themeColors = me.constructor.colors[me.theme],
            gradient    = ctx.createLinearGradient(0, 0, 0, height);

        gradient.addColorStop(0,   themeColors.spine[0]);
        gradient.addColorStop(0.5, themeColors.spine[1]);
        gradient.addColorStop(1,   themeColors.spine[2]);

        ctx.strokeStyle = gradient;
        ctx.lineWidth   = 2;
        ctx.beginPath();

        if (me.nodes.length > 0) {
            let first = me.nodes[0];
            ctx.moveTo(first.x, first.y);

            for (let i = 1; i < me.nodes.length; i++) {
                let node = me.nodes[i];
                ctx.lineTo(node.x, node.y)
            }
        }
        ctx.stroke();

        // 4. Draw "Pulse" Effect
        const pulseY = me.pulseY;

        if (me.nodes.length > 0 && pulseY > me.nodes[0].y - pulseLength && pulseY < maxY) {
            const pulseGrad = ctx.createLinearGradient(0, pulseY, 0, pulseY + pulseLength);
            pulseGrad.addColorStop(0,   `${pulseColorStr}, 0)`);
            pulseGrad.addColorStop(0.5, `${pulseColorStr}, 1)`);
            pulseGrad.addColorStop(1,   `${pulseColorStr}, 0)`);

            ctx.strokeStyle = pulseGrad;
            ctx.lineWidth   = 4;
            ctx.beginPath();

            let pulseX = me.getXAtY(pulseY);
            ctx.moveTo(pulseX, pulseY);
            ctx.lineTo(me.getXAtY(pulseY + pulseLength), Math.min(pulseY + pulseLength, maxY));
            ctx.stroke()
        }

        // 5. "The Gap"
        ctx.globalCompositeOperation = 'destination-out';
        ctx.fillStyle                = '#000';

        me.nodes.forEach(node => {
            if (node.radius) {
                ctx.beginPath();
                ctx.arc(node.x, node.y, node.radius, 0, 2 * Math.PI);
                ctx.fill()
            }
        });

        // 5. Draw Orbit/Glow Effects
        ctx.globalCompositeOperation = 'source-over';

        me.nodes.forEach(node => {
            const
                radius  = node.radius || 20,
                x       = node.x,
                y       = node.y,
                pTop    = pulseY,
                pBottom = pulseY + pulseLength,
                nTop    = y - radius,
                nBottom = y + radius;

            if (pBottom > nTop && pTop < nBottom) {
                const getAngle = (val) => {
                    let dy = val - y;
                    // Clamp to radius to avoid NaN in asin
                    dy = Math.max(-radius, Math.min(radius, dy));
                    return Math.asin(dy / radius)
                };

                const
                    angleTail = getAngle(pTop),
                    angleHead = getAngle(pBottom);

                // Use the DYNAMIC color here too!
                ctx.strokeStyle = `${pulseColorStr}, 1)`;
                ctx.lineWidth   = 2;

                // Right Arc
                ctx.beginPath();
                ctx.arc(x, y, radius + 2, angleTail, angleHead, false);
                ctx.stroke();

                // Left Arc
                const
                    leftTail = Math.PI - angleTail,
                    leftHead = Math.PI - angleHead;

                ctx.beginPath();
                ctx.arc(x, y, radius + 2, leftTail, leftHead, true);
                ctx.stroke()
            }
        });

        if (hasRaf) {
            me.animationId = requestAnimationFrame(me.renderLoop)
        } else {
            me.animationId = setTimeout(me.renderLoop, 1000 / 60)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TicketCanvas));

/***/ },

/***/ "./src/canvas/Base.mjs"
/*!*****************************!*\
  !*** ./src/canvas/Base.mjs ***!
  \*****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @summary Abstract base class for Canvas Renderers.
 *
 * This class serves as the foundation for the specialized canvas visualizations (Header, Home, Services, Ticket)
 * that run within the **Neo.mjs Canvas SharedWorker**.
 *
 * It creates helper singletons that manage their own `OffscreenCanvas` instances, providing a standardized
 * architecture for:
 * - **Lifecycle Management:** Initialization (`initGraph`), destruction (`clearGraph`), and resource cleanup.
 * - **Render Loop Control:** Unified `render` loop with pause/resume capabilities and frame scheduling.
 * - **Context Management:** Robust handling of `OffscreenCanvas` transfer and context acquisition via `waitForCanvas`.
 * - **Shared State:** Common state management for mouse interaction, time, and theming.
 *
 * These renderers operate off the main thread to ensure high-performance, 60fps animations without
 * blocking the UI.
 *
 * @class Neo.canvas.Base
 * @extends Neo.core.Base
 */
class Base extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.canvas.Base'
         * @protected
         */
        className: 'Neo.canvas.Base',
        /**
         * Remote method access
         * @member {Object} remote
         * @protected
         */
        remote: {
            app: [
                'clearGraph',
                'initGraph',
                'pause',
                'resume',
                'setTheme',
                'updateMouseState',
                'updateSize'
            ]
        },
        /**
         * The active color theme ('light' or 'dark').
         * @member {String} theme_='light'
         * @reactive
         */
        theme_: 'light'
    }

    /**
     * @member {Number|null} animationId=null
     */
    animationId = null
    /**
     * @member {String|null} canvasId=null
     */
    canvasId = null
    /**
     * @member {Object|null} canvasSize=null
     */
    canvasSize = null
    /**
     * @member {OffscreenCanvasRenderingContext2D|null} context=null
     */
    context = null
    /**
     * Cache for reusable gradients to prevent GC.
     * @member {Object} gradients={}
     */
    gradients = {}
    /**
     * Flag to pause the render loop.
     * @member {Boolean} isPaused=false
     */
    isPaused = false
    /**
     * Tracked mouse position for interactive physics.
     * Initialize off-screen to prevent startup jitters.
     * @member {Object} mouse={x: -1000, y: -1000}
     */
    mouse = {x: -1000, y: -1000}
    /**
     * Global simulation time.
     * @member {Number} time=0
     */
    time = 0

    /**
     * @member {Function} renderLoop=this.render.bind(this)
     */
    renderLoop = this.render.bind(this)

    /**
     * Triggered after the `theme` config is changed.
     * Updates the resource cache (gradients, colors) to reflect the new theme immediately.
     * @param {String} value
     * @param {String} oldValue
     */
    afterSetTheme(value, oldValue) {
        if (value && this.canvasSize) {
            this.updateResources?.(this.canvasSize.width, this.canvasSize.height)
        }
    }

    /**
     * Checks if the canvas is ready to render.
     * Returns true only if the context exists and the simulation is not paused.
     * Subclasses should call this at the start of their `render` loop.
     * @returns {Boolean}
     */
    get canRender() {
        let me = this;
        return !!(me.context && !me.isPaused)
    }

    /**
     * Clears the graph state and stops the render loop.
     * Use this to cleanup resources when the component is destroyed or unmounted.
     */
    clearGraph() {
        let me = this;
        me.context     = null;
        me.canvasId    = null;
        me.canvasSize  = null;
        me.animationId = null;
        me.isPaused    = false;
        me.gradients   = {};
        me.mouse       = {x: -1000, y: -1000};
        me.time        = 0
    }

    /**
     * Initializes the canvas context.
     * Starts the polling mechanism to wait for the OffscreenCanvas transfer from the Main Thread.
     * @param {Object} opts
     * @param {String} opts.canvasId
     * @param {String} opts.windowId
     */
    initGraph({canvasId, windowId}) {
        let me        = this,
            hasChange = me.canvasId !== canvasId;

        me.canvasId = canvasId;

        me.waitForCanvas(canvasId, windowId, hasChange)
    }

    /**
     * Hook for subclasses to handle mouse clicks.
     * Called by `updateMouseState` when a click event is received.
     * @param {Object} data
     */
    onMouseClick(data) {}

    /**
     * Pauses the simulation.
     * The render loop will exit early while `isPaused` is true.
     */
    pause() {
        this.isPaused = true
    }

    /**
     * Abstract render method.
     * Subclasses must implement this method to draw the frame.
     */
    render() {}

    /**
     * Resumes the simulation.
     * If the simulation was paused, this restarts the render loop.
     */
    resume() {
        let me = this;

        if (me.isPaused) {
            me.isPaused = false;
            me.renderLoop()
        }
    }

    /**
     * Exposed method for Remote Access to trigger the reactive config setter.
     * @param {String} value
     */
    setTheme(value) {
        this.theme = value
    }

    /**
     * Updates the local mouse state from main thread events.
     * Delegates click events to `onMouseClick`.
     * @param {Object} data
     * @param {Boolean} [data.click]
     * @param {Boolean} [data.leave]
     * @param {Number} [data.x]
     * @param {Number} [data.y]
     */
    updateMouseState(data) {
        let me = this;

        if (data.leave) {
            me.mouse.x = -1000;
            me.mouse.y = -1000
        } else {
            if (data.x !== undefined) me.mouse.x = data.x;
            if (data.y !== undefined) me.mouse.y = data.y;

            if (data.click) {
                me.onMouseClick(data)
            }
        }
    }

    /**
     * Updates the canvas size and resizes the internal context.
     * Triggers `updateResources` hook to allow subclasses to regenerate buffers/gradients.
     * @param {Object} size
     * @param {Number} size.height
     * @param {Number} size.width
     */
    updateSize(size) {
        let me = this;

        me.canvasSize = size;

        if (me.context) {
            me.context.canvas.width  = size.width;
            me.context.canvas.height = size.height;
            // Calls the hook to re-generate resources if implemented
            me.updateResources?.(size.width, size.height)
        }
    }

    /**
     * Polls for the OffscreenCanvas until it is available in the Worker's `canvasWindowMap`.
     * Once found, it initializes the context and starts the render loop.
     * @param {String} canvasId
     * @param {String} windowId
     * @param {Boolean} hasChange
     * @protected
     */
    waitForCanvas(canvasId, windowId, hasChange) {
        let me     = this,
            canvas = Neo.currentWorker.canvasWindowMap[canvasId]?.[windowId];

        if (canvas) {
            me.context = canvas.getContext('2d');

            // Standardize size update
            me.updateSize({width: canvas.width, height: canvas.height});

            // Optional hook for subclasses
            me.onGraphMounted?.(canvas.width, canvas.height);

            if (hasChange && !me.animationId) {
                me.renderLoop()
            }
        } else {
            setTimeout(me.waitForCanvas.bind(me, canvasId, windowId, hasChange), 50)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Base));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2NhbnZhcy92ZW5kb3JzLWFwcHNfcG9ydGFsX2NhbnZhc19UaWNrZXRDYW52YXNfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRTtBQUM1RDtBQUNBOztBQUVBLG9CQUFvQix3QkFBd0I7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDREQUFJO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLDJDQUEyQzs7QUFFdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsb0JBQW9CLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9wb3J0YWwvY2FudmFzL1RpY2tldENhbnZhcy5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jYW52YXMvQmFzZS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2UgZnJvbSAnLi4vLi4vLi4vc3JjL2NhbnZhcy9CYXNlLm1qcyc7XG5cbmNvbnN0XG4gICAgaGFzUmFmICAgICAgICAgPSB0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nLFxuICAgIC8vIE1hdGNoZXMgZnVsbCBoZXggY29kZXMgKGUuZy4sIFwiIzAwMzNGRlwiIG9yIFwiMDAzM0ZGXCIpXG4gICAgaGV4VG9SZ2JSZWdleCAgPSAvXiM/KFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pJC9pLFxuICAgIC8vIE1hdGNoZXMgc2hvcnRoYW5kIGhleCBjb2RlcyAoZS5nLiwgXCIjMDNGXCIgb3IgXCIwM0ZcIikgZm9yIGV4cGFuc2lvblxuICAgIHNob3J0aGFuZFJlZ2V4ID0gL14jPyhbYS1mXFxkXSkoW2EtZlxcZF0pKFthLWZcXGRdKSQvaTtcblxuY29uc3QgQkFTRV9DT0xPUiA9IHtyOiA2NCwgZzogMTk2LCBiOiAyNTV9OyAvLyBOZW8gQmx1ZVxuXG5jb25zdCBQSFlTSUNTID0ge1xuICAgIGluZmx1ZW5jZVJhbmdlOiAxNTAsXG4gICAgbWluTW9kICAgICAgICA6IDAuMixcbiAgICBtYXhNb2QgICAgICAgIDogMS41LFxuICAgIHB1bHNlQm91bmRzICAgOiAtMjAwXG59O1xuXG4vKipcbiAqIEBzdW1tYXJ5IFJlbmRlcnMgdGhlIFwiTmV1cmFsIFRpbWVsaW5lXCIgdmlzdWFsaXphdGlvbiBmb3IgdGhlIFBvcnRhbCdzIFRpY2tldCB2aWV3LlxuICpcbiAqIFRoaXMgY2xhc3MgcnVucyBpbnNpZGUgYSBTaGFyZWRXb3JrZXIgKHZpYSBgQ2FudmFzV29ya2VyYCkgdG8gcHJvdmlkZSBhIGhpZ2gtcGVyZm9ybWFuY2UsXG4gKiBtYWluLXRocmVhZC1ibG9ja2luZy1mcmVlIGFuaW1hdGlvbi4gSXQgdmlzdWFsaXplcyB0aGUgZmxvdyBvZiB0aW1lIGFuZCBhY3Rpdml0eSBjb25uZWN0aW5nXG4gKiB0aW1lbGluZSBub2RlcyAodGlja2V0cy9ldmVudHMpLlxuICpcbiAqIEtleSBWaXN1YWwgQ29uY2VwdHM6XG4gKiAxLiAqKlRoZSBTcGluZSoqOiBBIGNvbnRpbnVvdXMsIGdyYWRpZW50LXN0cm9rZWQgbGluZSBjb25uZWN0aW5nIGFsbCBub2Rlcy5cbiAqIDIuICoqVGhlIFB1bHNlKio6IEEgXCJkYXRhIHBhY2tldFwiIHRoYXQgdHJhdmVscyBhbG9uZyB0aGUgc3BpbmUuXG4gKiAzLiAqKkR1YWwtUG9pbnQgUGh5c2ljcyoqOiBUaGUgcHVsc2UgSGVhZCBhbmQgVGFpbCBhcmUgc2ltdWxhdGVkIGFzIGluZGVwZW5kZW50IHBhcnRpY2xlcyBtb3ZpbmcgdGhyb3VnaCB0aGVcbiAqICAgIHNwZWVkIGZpZWxkLiBUaGlzIGNyZWF0ZXMgb3JnYW5pYyBcIlNxdWFzaCBhbmQgU3RyZXRjaFwiIGJlaGF2aW9yOiBjb21wcmVzc2luZyB3aGVuIGVudGVyaW5nIGEgbm9kZSAoSGVhZCBzbG93cywgVGFpbCBmYXN0KVxuICogICAgYW5kIHN0cmV0Y2hpbmcgd2hlbiBsZWF2aW5nIChIZWFkIGZhc3QsIFRhaWwgc2xvdyksIHdpdGhvdXQgcmVxdWlyaW5nIGNvbXBsZXggY29uc3RyYWludHMgb3IgY2F1c2luZyB2aXN1YWwgYXJ0aWZhY3RzLlxuICogNC4gKipDaGFtZWxlb24gRWZmZWN0Kio6IFRoZSBwdWxzZSBkeW5hbWljYWxseSBjaGFuZ2VzIGl0cyBjb2xvciB0byBtYXRjaCB0aGUgc2VtYW50aWMgY29sb3Igb2YgdGhlXG4gKiAgICBuZWFyZXN0IG5vZGUgKGUuZy4sIFJlZCBmb3IgQnVncywgR3JlZW4gZm9yIEZlYXR1cmVzKSBhcyBpdCBwYXNzZXMgYnkuXG4gKlxuICogQGNsYXNzIFBvcnRhbC5jYW52YXMuVGlja2V0Q2FudmFzXG4gKiBAZXh0ZW5kcyBQb3J0YWwuY2FudmFzLkJhc2VcbiAqIEBzaW5nbGV0b25cbiAqL1xuY2xhc3MgVGlja2V0Q2FudmFzIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbG9ycyA9IHtcbiAgICAgICAgZGFyayA6IHtcbiAgICAgICAgICAgIHNwaW5lOiBbJ3JnYmEoNjIsIDk5LCAyMjEsIDAuMiknLCAncmdiYSg2NCwgMTk2LCAyNTUsIDAuNCknLCAncmdiYSg2MiwgOTksIDIyMSwgMC4yKSddXG4gICAgICAgIH0sXG4gICAgICAgIGxpZ2h0OiB7XG4gICAgICAgICAgICBzcGluZTogWydyZ2JhKDE1MCwgMTUwLCAxNTAsIDAuMSknLCAncmdiYSgxNTAsIDE1MCwgMTUwLCAwLjMpJywgJ3JnYmEoMTUwLCAxNTAsIDE1MCwgMC4xKSddXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J1BvcnRhbC5jYW52YXMuVGlja2V0Q2FudmFzJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdQb3J0YWwuY2FudmFzLlRpY2tldENhbnZhcycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdGUgbWV0aG9kIGFjY2Vzc1xuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHJlbW90ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdGU6IHtcbiAgICAgICAgICAgIGFwcDogW1xuICAgICAgICAgICAgICAgICdjbGVhckdyYXBoJyxcbiAgICAgICAgICAgICAgICAnaW5pdEdyYXBoJyxcbiAgICAgICAgICAgICAgICAnc2V0VGhlbWUnLFxuICAgICAgICAgICAgICAgICd1cGRhdGVHcmFwaERhdGEnLFxuICAgICAgICAgICAgICAgICd1cGRhdGVTaXplJ1xuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2luZ2xldG9uPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2luZ2xldG9uOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB0aGVtZT0nbGlnaHQnXG4gICAgICAgICAqL1xuICAgICAgICB0aGVtZTogJ2xpZ2h0J1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gYmFzZVNwZWVkPTAuNVxuICAgICAqL1xuICAgIGJhc2VTcGVlZCA9IDAuNVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gbGFzdEZyYW1lVGltZT0wXG4gICAgICovXG4gICAgbGFzdEZyYW1lVGltZSA9IDBcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtBcnJheX0gbm9kZXM9W11cbiAgICAgKi9cbiAgICBub2RlcyA9IFtdXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSBwdWxzZVk9MFxuICAgICAqL1xuICAgIHB1bHNlWSA9IDBcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHB1bHNlQm90dG9tPTEwMFxuICAgICAqL1xuICAgIHB1bHNlQm90dG9tID0gMTAwXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSBzdGFydFk9MFxuICAgICAqL1xuICAgIHN0YXJ0WSA9IDBcblxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgZ3JhcGggc3RhdGUgYW5kIHN0b3BzIHRoZSByZW5kZXIgbG9vcC5cbiAgICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoZSB2aWV3IHVubW91bnRzIHRvIHByZXZlbnQgXCJab21iaWUgTG9vcHNcIi5cbiAgICAgKi9cbiAgICBjbGVhckdyYXBoKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuICAgICAgICBzdXBlci5jbGVhckdyYXBoKCk7XG4gICAgICAgIG1lLm5vZGVzICAgICAgICAgPSBbXTtcbiAgICAgICAgbWUubGFzdEZyYW1lVGltZSA9IDA7XG4gICAgICAgIG1lLnB1bHNlQm90dG9tICAgPSAwXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgaG9yaXpvbnRhbCAoWCkgcG9zaXRpb24gb24gdGhlIHNwaW5lIGZvciBhIGdpdmVuIHZlcnRpY2FsIChZKSBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIFNpbmNlIHRoZSBub2RlcyBhcmUgbm90IHZlcnRpY2FsbHkgYWxpZ25lZCAodGhleSB3ZWF2ZSBsZWZ0L3JpZ2h0KSwgdGhlIHNwaW5lIGlzIGEgcG9seWxpbmUuXG4gICAgICogVGhpcyBtZXRob2QgcGVyZm9ybXMgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0aGUgdHdvIG5lYXJlc3Qgbm9kZXMgdG8gZW5zdXJlIHRoZVxuICAgICAqIFwiUHVsc2VcIiBzdGF5cyBwZXJmZWN0bHkgY2VudGVyZWQgb24gdGhlIHNwaW5lIHBhdGggYXMgaXQgdHJhdmVscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IC0gVGhlIHZlcnRpY2FsIHBvc2l0aW9uXG4gICAgICogQHJldHVybnMge051bWJlcn0geCAtIFRoZSBjYWxjdWxhdGVkIGhvcml6b250YWwgcG9zaXRpb24gb24gdGhlIHNwaW5lXG4gICAgICovXG4gICAgZ2V0WEF0WSh5KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLm5vZGVzLmxlbmd0aCA8IDIpIHJldHVybiBtZS5ub2Rlc1swXT8ueCB8fCAzODtcbiAgICAgICAgaWYgKHkgPCBtZS5ub2Rlc1swXS55KSAgIHJldHVybiBtZS5ub2Rlc1swXS54O1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWUubm9kZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY3VyciA9IG1lLm5vZGVzW2ldLFxuICAgICAgICAgICAgICAgIG5leHQgPSBtZS5ub2Rlc1tpKzFdO1xuXG4gICAgICAgICAgICBpZiAoeSA+PSBjdXJyLnkgJiYgeSA8PSBuZXh0LnkpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmF0aW8gPSAoeSAtIGN1cnIueSkgLyAobmV4dC55IC0gY3Vyci55KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3Vyci54ICsgKG5leHQueCAtIGN1cnIueCkgKiByYXRpbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZS5ub2Rlc1ttZS5ub2Rlcy5sZW5ndGggLSAxXS54XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgcGh5c2ljcyBzdGF0ZSAoc3BlZWQsIG5lYXJlc3Qgbm9kZSkgZm9yIGEgZ2l2ZW4gWSBwb3NpdGlvbi5cbiAgICAgKiBUaGlzIGFjdHMgYXMgdGhlIFwiVHJhZmZpYyBNb2RlbFwiIGVuZ2luZSwgZGV0ZXJtaW5pbmcgdGhlIGxvY2FsIHNwZWVkIGxpbWl0IGJhc2VkIG9uIHByb3hpbWl0eVxuICAgICAqIHRvIG5vZGVzLiBQYXJ0aWNsZXMgc2xvdyBkb3duIG5lYXIgbm9kZXMgKG9ic2VydmF0aW9uKSBhbmQgYWNjZWxlcmF0ZSBpbiBlbXB0eSBzcGFjZSAodHJhdmVsKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge09iamVjdH0ge3NwZWVkTW9kaWZpZXIsIG5lYXJOb2RlLCBtaW5EaXN0fVxuICAgICAqL1xuICAgIGdldFBoeXNpY3MoeSkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgbWluRGlzdCAgPSBJbmZpbml0eSxcbiAgICAgICAgICAgIG5lYXJOb2RlID0gbnVsbDtcblxuICAgICAgICBtZS5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgbGV0IGRpc3QgPSBNYXRoLmFicyh5IC0gbm9kZS55KTtcbiAgICAgICAgICAgIGlmIChkaXN0IDwgbWluRGlzdCkge1xuICAgICAgICAgICAgICAgIG1pbkRpc3QgID0gZGlzdDtcbiAgICAgICAgICAgICAgICBuZWFyTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHtpbmZsdWVuY2VSYW5nZSwgbWluTW9kLCBtYXhNb2R9ID0gUEhZU0lDUztcbiAgICAgICAgbGV0IHNwZWVkTW9kaWZpZXIgPSBtYXhNb2Q7XG5cbiAgICAgICAgaWYgKG1pbkRpc3QgPCBpbmZsdWVuY2VSYW5nZSkge1xuICAgICAgICAgICAgbGV0IHJhdGlvID0gbWluRGlzdCAvIGluZmx1ZW5jZVJhbmdlO1xuICAgICAgICAgICAgc3BlZWRNb2RpZmllciA9IG1pbk1vZCArIChtYXhNb2QgLSBtaW5Nb2QpICogKHJhdGlvICogcmF0aW8pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtzcGVlZE1vZGlmaWVyLCBuZWFyTm9kZSwgbWluRGlzdH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgdG8gcGFyc2UgaGV4IHRvIHJnYlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBoZXhcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB7cixnLGJ9XG4gICAgICovXG4gICAgaGV4VG9SZ2IoaGV4KSB7XG4gICAgICAgIGhleCA9IGhleC5yZXBsYWNlKHNob3J0aGFuZFJlZ2V4LCBmdW5jdGlvbihtLCByLCBnLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gciArIHIgKyBnICsgZyArIGIgKyBiO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBoZXhUb1JnYlJlZ2V4LmV4ZWMoaGV4KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0ID8ge1xuICAgICAgICAgICAgcjogcGFyc2VJbnQocmVzdWx0WzFdLCAxNiksXG4gICAgICAgICAgICBnOiBwYXJzZUludChyZXN1bHRbMl0sIDE2KSxcbiAgICAgICAgICAgIGI6IHBhcnNlSW50KHJlc3VsdFszXSwgMTYpXG4gICAgICAgIH0gOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgZ3JhcGggd2l0aCBuZXcgdGltZWxpbmUgbm9kZXMuXG4gICAgICogV2hlbiBgcmVzZXRgIGlzIHRydWUsIGl0IGhhcmQtcmVzZXRzIHRoZSBwaHlzaWNzIHNpbXVsYXRpb24gKHBvc2l0aW9ucyBhbmQgdGltZSkgdG8gcHJldmVudFxuICAgICAqIHZpc3VhbCBhcnRpZmFjdHMgKGp1bXBpbmcvZmxhc2hpbmcpIHdoZW4gc3dpdGNoaW5nIGJldHdlZW4gZGlmZmVyZW50IHRpY2tldCBjb250ZXh0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtBcnJheX0gIGRhdGEubm9kZXNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkYXRhLnJlc2V0XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZGF0YS5zdGFydFldXG4gICAgICovXG4gICAgdXBkYXRlR3JhcGhEYXRhKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcbiAgICAgICAgbWUubm9kZXMgPSBkYXRhLm5vZGVzIHx8IFtdO1xuICAgICAgICBpZiAoZGF0YS5zdGFydFkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbWUuc3RhcnRZID0gZGF0YS5zdGFydFk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YS5yZXNldCkge1xuICAgICAgICAgICAgbWUucHVsc2VZICAgICAgPSBQSFlTSUNTLnB1bHNlQm91bmRzO1xuICAgICAgICAgICAgbWUucHVsc2VCb3R0b20gPSBQSFlTSUNTLnB1bHNlQm91bmRzICsgMTAwO1xuICAgICAgICAgICAgbWUubGFzdEZyYW1lVGltZSA9IDBcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuc3VyZSBhbmltYXRpb24gbG9vcCBpcyBydW5uaW5nIGlmIHdlIGhhdmUgZGF0YVxuICAgICAgICBpZiAobWUubm9kZXMubGVuZ3RoID4gMCAmJiAhbWUuYW5pbWF0aW9uSWQgJiYgbWUuY29udGV4dCkge1xuICAgICAgICAgICAgbWUucmVuZGVyTG9vcCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgTWFpbiBBbmltYXRpb24gTG9vcCAoNjBmcHMpLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgcmVzcG9uc2libGUgZm9yOlxuICAgICAqIDEuICoqUGh5c2ljcyBDYWxjdWxhdGlvbioqOiBEZXRlcm1pbmluZyB0aGUgcHVsc2UncyBzcGVlZCBiYXNlZCBvbiBwcm94aW1pdHkgdG8gbm9kZXMgKFwiVHJhZmZpYyBNb2RlbFwiKS5cbiAgICAgKiAyLiAqKlN0YXRlIFVwZGF0ZXMqKjogVXBkYXRpbmcgdGhlIHB1bHNlJ3MgcG9zaXRpb24gKGBwdWxzZVlgKSBhbmQgY29sb3IgKGBDaGFtZWxlb24gRWZmZWN0YCkuXG4gICAgICogMy4gKipEcmF3aW5nKio6IFJlbmRlcmluZyB0aGUgc3BpbmUsIHRoZSBwdWxzZSwgYW5kIHRoZSBub2RlIGdsb3dzIHRvIHRoZSBgT2Zmc2NyZWVuQ2FudmFzYC5cbiAgICAgKlxuICAgICAqIEl0IHVzZXMgYHNldFRpbWVvdXRgIGluc3RlYWQgb2YgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgYmVjYXVzZSBTaGFyZWRXb3JrZXJzIGRvIG5vdCBnZW5lcmFsbHkgc3VwcG9ydCByQUYuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUuY2FuUmVuZGVyKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBjdHggICAgPSBtZS5jb250ZXh0LFxuICAgICAgICAgICAgd2lkdGggID0gbWUuY2FudmFzU2l6ZT8ud2lkdGggIHx8IDgwMCxcbiAgICAgICAgICAgIGhlaWdodCA9IG1lLmNhbnZhc1NpemU/LmhlaWdodCB8fCA2MDAsXG4gICAgICAgICAgICBub3cgICAgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgYm90dG9tLW1vc3QgYm91bmRhcnkgKGxhc3QgaXRlbSdzIFkgb3IgZGVmYXVsdCBoZWlnaHQpXG4gICAgICAgIGxldCBtYXhZID0gaGVpZ2h0O1xuXG4gICAgICAgIGlmIChtZS5ub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBtYXhZID0gbWUubm9kZXNbbWUubm9kZXMubGVuZ3RoIC0gMV0ueVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGltZSBkZWx0YSBpbiBtc1xuICAgICAgICBsZXQgZHQgPSBub3cgLSAobWUubGFzdEZyYW1lVGltZSB8fCBub3cpO1xuICAgICAgICBtZS5sYXN0RnJhbWVUaW1lID0gbm93O1xuXG4gICAgICAgIC8vIENhcCBkdCB0byBwcmV2ZW50IGh1Z2UganVtcHNcbiAgICAgICAgaWYgKGR0ID4gMTAwKSBkdCA9IDE2O1xuXG4gICAgICAgIC8vIDEuIENhbGN1bGF0ZSBQaHlzaWNzXG4gICAgICAgIC8vIFwiRHVhbC1Qb2ludCBQaHlzaWNzXCI6IFdlIHNpbXVsYXRlIHRoZSBIZWFkIGFuZCBUYWlsIG9mIHRoZSBwdWxzZSBhcyBpbmRlcGVuZGVudCBwYXJ0aWNsZXNcbiAgICAgICAgLy8gbW92aW5nIHRocm91Z2ggdGhlIFwiVHJhZmZpYyBNb2RlbFwiIHNwZWVkIGZpZWxkLlxuICAgICAgICAvLyAtIFdoZW4gSGVhZCBoaXRzIGEgbm9kZSAoc2xvdyB6b25lKSwgaXQgc2xvd3MgZG93bi4gVGFpbCAoaW4gZmFzdCB6b25lKSBjYXRjaGVzIHVwLiAtPiBTcXVhc2guXG4gICAgICAgIC8vIC0gV2hlbiBIZWFkIGxlYXZlcyBhIG5vZGUsIGl0IHNwZWVkcyB1cC4gVGFpbCAoaW4gc2xvdyB6b25lKSBsYWdzIGJlaGluZC4gLT4gU3RyZXRjaC5cbiAgICAgICAgLy8gVGhpcyBjcmVhdGVzIG9yZ2FuaWMsIHBoeXNpY2FsbHkgY29ycmVjdCBkZWZvcm1hdGlvbiB3aXRob3V0IFwicmV0cmFjdGlvblwiIGdsaXRjaGVzIG9yIGFydGlmaWNpYWwgc3RhbGxzLlxuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBwaHlzaWNzVG9wICAgID0gbWUuZ2V0UGh5c2ljcyhtZS5wdWxzZVkpLFxuICAgICAgICAgICAgcGh5c2ljc0JvdHRvbSA9IG1lLmdldFBoeXNpY3MobWUucHVsc2VCb3R0b20pLFxuICAgICAgICAgICAge25lYXJOb2RlLCBtaW5EaXN0fSA9IHBoeXNpY3NUb3A7IC8vIFVzZSBUb3AgZm9yIGNvbG9yL3Byb3hpbWl0eSBsb2dpYyB0byBtYXRjaCBvcmlnaW5hbCBmZWVsXG5cbiAgICAgICAgLy8gQXBwbHkgSW5kZXBlbmRlbnQgVmVsb2NpdGllc1xuICAgICAgICBtZS5wdWxzZVkgICAgICArPSBtZS5iYXNlU3BlZWQgKiBwaHlzaWNzVG9wLnNwZWVkTW9kaWZpZXIgICAgKiBkdDtcbiAgICAgICAgbWUucHVsc2VCb3R0b20gKz0gbWUuYmFzZVNwZWVkICogcGh5c2ljc0JvdHRvbS5zcGVlZE1vZGlmaWVyICogZHQ7XG5cbiAgICAgICAgLy8gQ29uc3RyYWludDogTWluaW11bSBMZW5ndGggKGUuZy4gMTVweCkuXG4gICAgICAgIC8vIFdoaWxlIER1YWwtUG9pbnQgUGh5c2ljcyBuYXR1cmFsbHkgaGFuZGxlcyBjb21wcmVzc2lvbiwgZXh0cmVtZSBkZWNlbGVyYXRpb24gY2FuIHRoZW9yZXRpY2FsbHlcbiAgICAgICAgLy8gY2F1c2UgdGhlIEhlYWQgdG8gbW92ZSBzbG93ZXIgdGhhbiB0aGUgVGFpbCBmb3IgdG9vIGxvbmcsIGludmVydGluZyB0aGUgcHVsc2UuXG4gICAgICAgIC8vIFRoaXMgaGFyZCBjb25zdHJhaW50IHByZXNlcnZlcyBwaHlzaWNhbCBwbGF1c2liaWxpdHkgKG1hdHRlciBjYW5ub3QgaGF2ZSBuZWdhdGl2ZSBsZW5ndGgpLlxuICAgICAgICBpZiAobWUucHVsc2VCb3R0b20gPCBtZS5wdWxzZVkgKyAxNSkge1xuICAgICAgICAgICAgbWUucHVsc2VCb3R0b20gPSBtZS5wdWxzZVkgKyAxNVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gV3JhcCBBcm91bmRcbiAgICAgICAgaWYgKG1lLnB1bHNlWSA+IG1heFkgLSBQSFlTSUNTLnB1bHNlQm91bmRzKSB7XG4gICAgICAgICAgICBtZS5wdWxzZVkgICAgICA9IFBIWVNJQ1MucHVsc2VCb3VuZHM7XG4gICAgICAgICAgICBtZS5wdWxzZUJvdHRvbSA9IFBIWVNJQ1MucHVsc2VCb3VuZHMgKyAxMDAgLy8gUmVzZXQgbGVuZ3RoIG9uIGxvb3BcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHB1bHNlTGVuZ3RoID0gbWUucHVsc2VCb3R0b20gLSBtZS5wdWxzZVk7XG5cbiAgICAgICAgLy8gQ29sb3IgSW50ZXJwb2xhdGlvbiAoQ2hhbWVsZW9uIEVmZmVjdClcbiAgICAgICAgLy8gVGhlIHB1bHNlIFwiYWJzb3Jic1wiIHRoZSBjb2xvciBvZiB0aGUgbm9kZSBpdCBpcyBjdXJyZW50bHkgcGFzc2luZy5cbiAgICAgICAgbGV0IHtyLCBnLCBifSA9IEJBU0VfQ09MT1I7XG5cbiAgICAgICAgLy8gSWYgbmVhciBhIGNvbG9yZWQgbm9kZSAod2l0aGluIDEwMHB4KSwgaW50ZXJwb2xhdGUgdG8gaXRzIGNvbG9yXG4gICAgICAgIGlmIChuZWFyTm9kZSAmJiBuZWFyTm9kZS5jb2xvciAmJiBtaW5EaXN0IDwgMTAwKSB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gbWUuaGV4VG9SZ2IobmVhck5vZGUuY29sb3IpO1xuICAgICAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIGxldCBtaXggPSAxIC0gKG1pbkRpc3QgLyAxMDApO1xuICAgICAgICAgICAgICAgIHIgPSByICsgKHRhcmdldC5yIC0gcikgKiBtaXg7XG4gICAgICAgICAgICAgICAgZyA9IGcgKyAodGFyZ2V0LmcgLSBnKSAqIG1peDtcbiAgICAgICAgICAgICAgICBiID0gYiArICh0YXJnZXQuYiAtIGIpICogbWl4XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwdWxzZUNvbG9yU3RyID0gYHJnYmEoJHtNYXRoLnJvdW5kKHIpfSwgJHtNYXRoLnJvdW5kKGcpfSwgJHtNYXRoLnJvdW5kKGIpfWA7IC8vIGxlYXZlcyBhbHBoYSBvcGVuXG5cbiAgICAgICAgLy8gMi4gQ2xlYXJcbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICAvLyAzLiBEcmF3IE5ldXJhbCBDb25uZWN0aW9ucyAoVGhlIFwiU3BpbmVcIilcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIHRoZW1lQ29sb3JzID0gbWUuY29uc3RydWN0b3IuY29sb3JzW21lLnRoZW1lXSxcbiAgICAgICAgICAgIGdyYWRpZW50ICAgID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIDAsIGhlaWdodCk7XG5cbiAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsICAgdGhlbWVDb2xvcnMuc3BpbmVbMF0pO1xuICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMC41LCB0aGVtZUNvbG9ycy5zcGluZVsxXSk7XG4gICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCAgIHRoZW1lQ29sb3JzLnNwaW5lWzJdKTtcblxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBncmFkaWVudDtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCAgID0gMjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIGlmIChtZS5ub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSBtZS5ub2Rlc1swXTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oZmlyc3QueCwgZmlyc3QueSk7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbWUubm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IG1lLm5vZGVzW2ldO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8obm9kZS54LCBub2RlLnkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgIC8vIDQuIERyYXcgXCJQdWxzZVwiIEVmZmVjdFxuICAgICAgICBjb25zdCBwdWxzZVkgPSBtZS5wdWxzZVk7XG5cbiAgICAgICAgaWYgKG1lLm5vZGVzLmxlbmd0aCA+IDAgJiYgcHVsc2VZID4gbWUubm9kZXNbMF0ueSAtIHB1bHNlTGVuZ3RoICYmIHB1bHNlWSA8IG1heFkpIHtcbiAgICAgICAgICAgIGNvbnN0IHB1bHNlR3JhZCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCBwdWxzZVksIDAsIHB1bHNlWSArIHB1bHNlTGVuZ3RoKTtcbiAgICAgICAgICAgIHB1bHNlR3JhZC5hZGRDb2xvclN0b3AoMCwgICBgJHtwdWxzZUNvbG9yU3RyfSwgMClgKTtcbiAgICAgICAgICAgIHB1bHNlR3JhZC5hZGRDb2xvclN0b3AoMC41LCBgJHtwdWxzZUNvbG9yU3RyfSwgMSlgKTtcbiAgICAgICAgICAgIHB1bHNlR3JhZC5hZGRDb2xvclN0b3AoMSwgICBgJHtwdWxzZUNvbG9yU3RyfSwgMClgKTtcblxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gcHVsc2VHcmFkO1xuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCAgID0gNDtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgICAgICAgbGV0IHB1bHNlWCA9IG1lLmdldFhBdFkocHVsc2VZKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8ocHVsc2VYLCBwdWxzZVkpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhtZS5nZXRYQXRZKHB1bHNlWSArIHB1bHNlTGVuZ3RoKSwgTWF0aC5taW4ocHVsc2VZICsgcHVsc2VMZW5ndGgsIG1heFkpKTtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gNS4gXCJUaGUgR2FwXCJcbiAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdXQnO1xuICAgICAgICBjdHguZmlsbFN0eWxlICAgICAgICAgICAgICAgID0gJyMwMDAnO1xuXG4gICAgICAgIG1lLm5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZS5yYWRpdXMpIHtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4LmFyYyhub2RlLngsIG5vZGUueSwgbm9kZS5yYWRpdXMsIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIDUuIERyYXcgT3JiaXQvR2xvdyBFZmZlY3RzXG4gICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnc291cmNlLW92ZXInO1xuXG4gICAgICAgIG1lLm5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICBjb25zdFxuICAgICAgICAgICAgICAgIHJhZGl1cyAgPSBub2RlLnJhZGl1cyB8fCAyMCxcbiAgICAgICAgICAgICAgICB4ICAgICAgID0gbm9kZS54LFxuICAgICAgICAgICAgICAgIHkgICAgICAgPSBub2RlLnksXG4gICAgICAgICAgICAgICAgcFRvcCAgICA9IHB1bHNlWSxcbiAgICAgICAgICAgICAgICBwQm90dG9tID0gcHVsc2VZICsgcHVsc2VMZW5ndGgsXG4gICAgICAgICAgICAgICAgblRvcCAgICA9IHkgLSByYWRpdXMsXG4gICAgICAgICAgICAgICAgbkJvdHRvbSA9IHkgKyByYWRpdXM7XG5cbiAgICAgICAgICAgIGlmIChwQm90dG9tID4gblRvcCAmJiBwVG9wIDwgbkJvdHRvbSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdldEFuZ2xlID0gKHZhbCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZHkgPSB2YWwgLSB5O1xuICAgICAgICAgICAgICAgICAgICAvLyBDbGFtcCB0byByYWRpdXMgdG8gYXZvaWQgTmFOIGluIGFzaW5cbiAgICAgICAgICAgICAgICAgICAgZHkgPSBNYXRoLm1heCgtcmFkaXVzLCBNYXRoLm1pbihyYWRpdXMsIGR5KSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmFzaW4oZHkgLyByYWRpdXMpXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlVGFpbCA9IGdldEFuZ2xlKHBUb3ApLFxuICAgICAgICAgICAgICAgICAgICBhbmdsZUhlYWQgPSBnZXRBbmdsZShwQm90dG9tKTtcblxuICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgRFlOQU1JQyBjb2xvciBoZXJlIHRvbyFcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBgJHtwdWxzZUNvbG9yU3RyfSwgMSlgO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggICA9IDI7XG5cbiAgICAgICAgICAgICAgICAvLyBSaWdodCBBcmNcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCByYWRpdXMgKyAyLCBhbmdsZVRhaWwsIGFuZ2xlSGVhZCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICAgICAgICAgIC8vIExlZnQgQXJjXG4gICAgICAgICAgICAgICAgY29uc3RcbiAgICAgICAgICAgICAgICAgICAgbGVmdFRhaWwgPSBNYXRoLlBJIC0gYW5nbGVUYWlsLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0SGVhZCA9IE1hdGguUEkgLSBhbmdsZUhlYWQ7XG5cbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCByYWRpdXMgKyAyLCBsZWZ0VGFpbCwgbGVmdEhlYWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoaGFzUmFmKSB7XG4gICAgICAgICAgICBtZS5hbmltYXRpb25JZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShtZS5yZW5kZXJMb29wKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUuYW5pbWF0aW9uSWQgPSBzZXRUaW1lb3V0KG1lLnJlbmRlckxvb3AsIDEwMDAgLyA2MClcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVGlja2V0Q2FudmFzKTsiLCJpbXBvcnQgTmVvQmFzZSBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAc3VtbWFyeSBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBDYW52YXMgUmVuZGVyZXJzLlxuICpcbiAqIFRoaXMgY2xhc3Mgc2VydmVzIGFzIHRoZSBmb3VuZGF0aW9uIGZvciB0aGUgc3BlY2lhbGl6ZWQgY2FudmFzIHZpc3VhbGl6YXRpb25zIChIZWFkZXIsIEhvbWUsIFNlcnZpY2VzLCBUaWNrZXQpXG4gKiB0aGF0IHJ1biB3aXRoaW4gdGhlICoqTmVvLm1qcyBDYW52YXMgU2hhcmVkV29ya2VyKiouXG4gKlxuICogSXQgY3JlYXRlcyBoZWxwZXIgc2luZ2xldG9ucyB0aGF0IG1hbmFnZSB0aGVpciBvd24gYE9mZnNjcmVlbkNhbnZhc2AgaW5zdGFuY2VzLCBwcm92aWRpbmcgYSBzdGFuZGFyZGl6ZWRcbiAqIGFyY2hpdGVjdHVyZSBmb3I6XG4gKiAtICoqTGlmZWN5Y2xlIE1hbmFnZW1lbnQ6KiogSW5pdGlhbGl6YXRpb24gKGBpbml0R3JhcGhgKSwgZGVzdHJ1Y3Rpb24gKGBjbGVhckdyYXBoYCksIGFuZCByZXNvdXJjZSBjbGVhbnVwLlxuICogLSAqKlJlbmRlciBMb29wIENvbnRyb2w6KiogVW5pZmllZCBgcmVuZGVyYCBsb29wIHdpdGggcGF1c2UvcmVzdW1lIGNhcGFiaWxpdGllcyBhbmQgZnJhbWUgc2NoZWR1bGluZy5cbiAqIC0gKipDb250ZXh0IE1hbmFnZW1lbnQ6KiogUm9idXN0IGhhbmRsaW5nIG9mIGBPZmZzY3JlZW5DYW52YXNgIHRyYW5zZmVyIGFuZCBjb250ZXh0IGFjcXVpc2l0aW9uIHZpYSBgd2FpdEZvckNhbnZhc2AuXG4gKiAtICoqU2hhcmVkIFN0YXRlOioqIENvbW1vbiBzdGF0ZSBtYW5hZ2VtZW50IGZvciBtb3VzZSBpbnRlcmFjdGlvbiwgdGltZSwgYW5kIHRoZW1pbmcuXG4gKlxuICogVGhlc2UgcmVuZGVyZXJzIG9wZXJhdGUgb2ZmIHRoZSBtYWluIHRocmVhZCB0byBlbnN1cmUgaGlnaC1wZXJmb3JtYW5jZSwgNjBmcHMgYW5pbWF0aW9ucyB3aXRob3V0XG4gKiBibG9ja2luZyB0aGUgVUkuXG4gKlxuICogQGNsYXNzIE5lby5jYW52YXMuQmFzZVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBCYXNlIGV4dGVuZHMgTmVvQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY2FudmFzLkJhc2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jYW52YXMuQmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdGUgbWV0aG9kIGFjY2Vzc1xuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHJlbW90ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdGU6IHtcbiAgICAgICAgICAgIGFwcDogW1xuICAgICAgICAgICAgICAgICdjbGVhckdyYXBoJyxcbiAgICAgICAgICAgICAgICAnaW5pdEdyYXBoJyxcbiAgICAgICAgICAgICAgICAncGF1c2UnLFxuICAgICAgICAgICAgICAgICdyZXN1bWUnLFxuICAgICAgICAgICAgICAgICdzZXRUaGVtZScsXG4gICAgICAgICAgICAgICAgJ3VwZGF0ZU1vdXNlU3RhdGUnLFxuICAgICAgICAgICAgICAgICd1cGRhdGVTaXplJ1xuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFjdGl2ZSBjb2xvciB0aGVtZSAoJ2xpZ2h0JyBvciAnZGFyaycpLlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHRoZW1lXz0nbGlnaHQnXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhlbWVfOiAnbGlnaHQnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IGFuaW1hdGlvbklkPW51bGxcbiAgICAgKi9cbiAgICBhbmltYXRpb25JZCA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gY2FudmFzSWQ9bnVsbFxuICAgICAqL1xuICAgIGNhbnZhc0lkID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBjYW52YXNTaXplPW51bGxcbiAgICAgKi9cbiAgICBjYW52YXNTaXplID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRHxudWxsfSBjb250ZXh0PW51bGxcbiAgICAgKi9cbiAgICBjb250ZXh0ID0gbnVsbFxuICAgIC8qKlxuICAgICAqIENhY2hlIGZvciByZXVzYWJsZSBncmFkaWVudHMgdG8gcHJldmVudCBHQy5cbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGdyYWRpZW50cz17fVxuICAgICAqL1xuICAgIGdyYWRpZW50cyA9IHt9XG4gICAgLyoqXG4gICAgICogRmxhZyB0byBwYXVzZSB0aGUgcmVuZGVyIGxvb3AuXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNQYXVzZWQ9ZmFsc2VcbiAgICAgKi9cbiAgICBpc1BhdXNlZCA9IGZhbHNlXG4gICAgLyoqXG4gICAgICogVHJhY2tlZCBtb3VzZSBwb3NpdGlvbiBmb3IgaW50ZXJhY3RpdmUgcGh5c2ljcy5cbiAgICAgKiBJbml0aWFsaXplIG9mZi1zY3JlZW4gdG8gcHJldmVudCBzdGFydHVwIGppdHRlcnMuXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBtb3VzZT17eDogLTEwMDAsIHk6IC0xMDAwfVxuICAgICAqL1xuICAgIG1vdXNlID0ge3g6IC0xMDAwLCB5OiAtMTAwMH1cbiAgICAvKipcbiAgICAgKiBHbG9iYWwgc2ltdWxhdGlvbiB0aW1lLlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gdGltZT0wXG4gICAgICovXG4gICAgdGltZSA9IDBcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufSByZW5kZXJMb29wPXRoaXMucmVuZGVyLmJpbmQodGhpcylcbiAgICAgKi9cbiAgICByZW5kZXJMb29wID0gdGhpcy5yZW5kZXIuYmluZCh0aGlzKVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBgdGhlbWVgIGNvbmZpZyBpcyBjaGFuZ2VkLlxuICAgICAqIFVwZGF0ZXMgdGhlIHJlc291cmNlIGNhY2hlIChncmFkaWVudHMsIGNvbG9ycykgdG8gcmVmbGVjdCB0aGUgbmV3IHRoZW1lIGltbWVkaWF0ZWx5LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIGFmdGVyU2V0VGhlbWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0aGlzLmNhbnZhc1NpemUpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUmVzb3VyY2VzPy4odGhpcy5jYW52YXNTaXplLndpZHRoLCB0aGlzLmNhbnZhc1NpemUuaGVpZ2h0KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBjYW52YXMgaXMgcmVhZHkgdG8gcmVuZGVyLlxuICAgICAqIFJldHVybnMgdHJ1ZSBvbmx5IGlmIHRoZSBjb250ZXh0IGV4aXN0cyBhbmQgdGhlIHNpbXVsYXRpb24gaXMgbm90IHBhdXNlZC5cbiAgICAgKiBTdWJjbGFzc2VzIHNob3VsZCBjYWxsIHRoaXMgYXQgdGhlIHN0YXJ0IG9mIHRoZWlyIGByZW5kZXJgIGxvb3AuXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGNhblJlbmRlcigpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcbiAgICAgICAgcmV0dXJuICEhKG1lLmNvbnRleHQgJiYgIW1lLmlzUGF1c2VkKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgZ3JhcGggc3RhdGUgYW5kIHN0b3BzIHRoZSByZW5kZXIgbG9vcC5cbiAgICAgKiBVc2UgdGhpcyB0byBjbGVhbnVwIHJlc291cmNlcyB3aGVuIHRoZSBjb21wb25lbnQgaXMgZGVzdHJveWVkIG9yIHVubW91bnRlZC5cbiAgICAgKi9cbiAgICBjbGVhckdyYXBoKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuICAgICAgICBtZS5jb250ZXh0ICAgICA9IG51bGw7XG4gICAgICAgIG1lLmNhbnZhc0lkICAgID0gbnVsbDtcbiAgICAgICAgbWUuY2FudmFzU2l6ZSAgPSBudWxsO1xuICAgICAgICBtZS5hbmltYXRpb25JZCA9IG51bGw7XG4gICAgICAgIG1lLmlzUGF1c2VkICAgID0gZmFsc2U7XG4gICAgICAgIG1lLmdyYWRpZW50cyAgID0ge307XG4gICAgICAgIG1lLm1vdXNlICAgICAgID0ge3g6IC0xMDAwLCB5OiAtMTAwMH07XG4gICAgICAgIG1lLnRpbWUgICAgICAgID0gMFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBjYW52YXMgY29udGV4dC5cbiAgICAgKiBTdGFydHMgdGhlIHBvbGxpbmcgbWVjaGFuaXNtIHRvIHdhaXQgZm9yIHRoZSBPZmZzY3JlZW5DYW52YXMgdHJhbnNmZXIgZnJvbSB0aGUgTWFpbiBUaHJlYWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy5jYW52YXNJZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRzLndpbmRvd0lkXG4gICAgICovXG4gICAgaW5pdEdyYXBoKHtjYW52YXNJZCwgd2luZG93SWR9KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaGFzQ2hhbmdlID0gbWUuY2FudmFzSWQgIT09IGNhbnZhc0lkO1xuXG4gICAgICAgIG1lLmNhbnZhc0lkID0gY2FudmFzSWQ7XG5cbiAgICAgICAgbWUud2FpdEZvckNhbnZhcyhjYW52YXNJZCwgd2luZG93SWQsIGhhc0NoYW5nZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIb29rIGZvciBzdWJjbGFzc2VzIHRvIGhhbmRsZSBtb3VzZSBjbGlja3MuXG4gICAgICogQ2FsbGVkIGJ5IGB1cGRhdGVNb3VzZVN0YXRlYCB3aGVuIGEgY2xpY2sgZXZlbnQgaXMgcmVjZWl2ZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbk1vdXNlQ2xpY2soZGF0YSkge31cblxuICAgIC8qKlxuICAgICAqIFBhdXNlcyB0aGUgc2ltdWxhdGlvbi5cbiAgICAgKiBUaGUgcmVuZGVyIGxvb3Agd2lsbCBleGl0IGVhcmx5IHdoaWxlIGBpc1BhdXNlZGAgaXMgdHJ1ZS5cbiAgICAgKi9cbiAgICBwYXVzZSgpIHtcbiAgICAgICAgdGhpcy5pc1BhdXNlZCA9IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBYnN0cmFjdCByZW5kZXIgbWV0aG9kLlxuICAgICAqIFN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gZHJhdyB0aGUgZnJhbWUuXG4gICAgICovXG4gICAgcmVuZGVyKCkge31cblxuICAgIC8qKlxuICAgICAqIFJlc3VtZXMgdGhlIHNpbXVsYXRpb24uXG4gICAgICogSWYgdGhlIHNpbXVsYXRpb24gd2FzIHBhdXNlZCwgdGhpcyByZXN0YXJ0cyB0aGUgcmVuZGVyIGxvb3AuXG4gICAgICovXG4gICAgcmVzdW1lKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5pc1BhdXNlZCkge1xuICAgICAgICAgICAgbWUuaXNQYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIG1lLnJlbmRlckxvb3AoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhwb3NlZCBtZXRob2QgZm9yIFJlbW90ZSBBY2Nlc3MgdG8gdHJpZ2dlciB0aGUgcmVhY3RpdmUgY29uZmlnIHNldHRlci5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cbiAgICBzZXRUaGVtZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnRoZW1lID0gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBsb2NhbCBtb3VzZSBzdGF0ZSBmcm9tIG1haW4gdGhyZWFkIGV2ZW50cy5cbiAgICAgKiBEZWxlZ2F0ZXMgY2xpY2sgZXZlbnRzIHRvIGBvbk1vdXNlQ2xpY2tgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZGF0YS5jbGlja11cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkYXRhLmxlYXZlXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZGF0YS54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZGF0YS55XVxuICAgICAqL1xuICAgIHVwZGF0ZU1vdXNlU3RhdGUoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChkYXRhLmxlYXZlKSB7XG4gICAgICAgICAgICBtZS5tb3VzZS54ID0gLTEwMDA7XG4gICAgICAgICAgICBtZS5tb3VzZS55ID0gLTEwMDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChkYXRhLnggIT09IHVuZGVmaW5lZCkgbWUubW91c2UueCA9IGRhdGEueDtcbiAgICAgICAgICAgIGlmIChkYXRhLnkgIT09IHVuZGVmaW5lZCkgbWUubW91c2UueSA9IGRhdGEueTtcblxuICAgICAgICAgICAgaWYgKGRhdGEuY2xpY2spIHtcbiAgICAgICAgICAgICAgICBtZS5vbk1vdXNlQ2xpY2soZGF0YSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGNhbnZhcyBzaXplIGFuZCByZXNpemVzIHRoZSBpbnRlcm5hbCBjb250ZXh0LlxuICAgICAqIFRyaWdnZXJzIGB1cGRhdGVSZXNvdXJjZXNgIGhvb2sgdG8gYWxsb3cgc3ViY2xhc3NlcyB0byByZWdlbmVyYXRlIGJ1ZmZlcnMvZ3JhZGllbnRzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzaXplXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNpemUuaGVpZ2h0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNpemUud2lkdGhcbiAgICAgKi9cbiAgICB1cGRhdGVTaXplKHNpemUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5jYW52YXNTaXplID0gc2l6ZTtcblxuICAgICAgICBpZiAobWUuY29udGV4dCkge1xuICAgICAgICAgICAgbWUuY29udGV4dC5jYW52YXMud2lkdGggID0gc2l6ZS53aWR0aDtcbiAgICAgICAgICAgIG1lLmNvbnRleHQuY2FudmFzLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICAgICAgICAgICAgLy8gQ2FsbHMgdGhlIGhvb2sgdG8gcmUtZ2VuZXJhdGUgcmVzb3VyY2VzIGlmIGltcGxlbWVudGVkXG4gICAgICAgICAgICBtZS51cGRhdGVSZXNvdXJjZXM/LihzaXplLndpZHRoLCBzaXplLmhlaWdodClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBvbGxzIGZvciB0aGUgT2Zmc2NyZWVuQ2FudmFzIHVudGlsIGl0IGlzIGF2YWlsYWJsZSBpbiB0aGUgV29ya2VyJ3MgYGNhbnZhc1dpbmRvd01hcGAuXG4gICAgICogT25jZSBmb3VuZCwgaXQgaW5pdGlhbGl6ZXMgdGhlIGNvbnRleHQgYW5kIHN0YXJ0cyB0aGUgcmVuZGVyIGxvb3AuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNhbnZhc0lkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHdpbmRvd0lkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBoYXNDaGFuZ2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgd2FpdEZvckNhbnZhcyhjYW52YXNJZCwgd2luZG93SWQsIGhhc0NoYW5nZSkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNhbnZhcyA9IE5lby5jdXJyZW50V29ya2VyLmNhbnZhc1dpbmRvd01hcFtjYW52YXNJZF0/Llt3aW5kb3dJZF07XG5cbiAgICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICAgICAgbWUuY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgICAgICAvLyBTdGFuZGFyZGl6ZSBzaXplIHVwZGF0ZVxuICAgICAgICAgICAgbWUudXBkYXRlU2l6ZSh7d2lkdGg6IGNhbnZhcy53aWR0aCwgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0fSk7XG5cbiAgICAgICAgICAgIC8vIE9wdGlvbmFsIGhvb2sgZm9yIHN1YmNsYXNzZXNcbiAgICAgICAgICAgIG1lLm9uR3JhcGhNb3VudGVkPy4oY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICAgICAgICAgICAgaWYgKGhhc0NoYW5nZSAmJiAhbWUuYW5pbWF0aW9uSWQpIHtcbiAgICAgICAgICAgICAgICBtZS5yZW5kZXJMb29wKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQobWUud2FpdEZvckNhbnZhcy5iaW5kKG1lLCBjYW52YXNJZCwgd2luZG93SWQsIGhhc0NoYW5nZSksIDUwKVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhCYXNlKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==