"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-apps_portal_canvas_TicketCanvas_mjs"],{

/***/ "./apps/portal/canvas/TicketCanvas.mjs"
/*!*********************************************!*\
  !*** ./apps/portal/canvas/TicketCanvas.mjs ***!
  \*********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/core/Base.mjs */ "./src/core/Base.mjs");


const
    // Matches full hex codes (e.g., "#0033FF" or "0033FF")
    hexToRgbRegex  = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,
    // Matches shorthand hex codes (e.g., "#03F" or "03F") for expansion
    shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;

const BASE_COLOR = {r: 64, g: 196, b: 255}; // Neo Blue

const PHYSICS = {
    influenceRange: 150,
    minMod        : 0.2,
    maxMod        : 1.5,
    pulseBounds   : -200
};

/**
 * @summary Renders the "Neural Timeline" visualization for the Portal's Ticket view.
 *
 * This class runs inside a SharedWorker (via `CanvasWorker`) to provide a high-performance,
 * main-thread-blocking-free animation. It visualizes the flow of time and activity connecting
 * timeline nodes (tickets/events).
 *
 * Key Visual Concepts:
 * 1. **The Spine**: A continuous, gradient-stroked line connecting all nodes.
 * 2. **The Pulse**: A "data packet" that travels along the spine.
 * 3. **Traffic Model Physics**: The pulse does not move at constant speed. It accelerates in empty space
 *    and decelerates when approaching nodes ("interest points"), creating a sense of "observing" the data.
 * 4. **Chameleon Effect**: The pulse dynamically changes its color to match the semantic color of the
 *    nearest node (e.g., Red for Bugs, Green for Features) as it passes by.
 *
 * @class Portal.canvas.TicketCanvas
 * @extends Neo.core.Base
 * @singleton
 */
class TicketCanvas extends _src_core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.canvas.TicketCanvas'
         * @protected
         */
        className: 'Portal.canvas.TicketCanvas',
        /**
         * Remote method access
         * @member {Object} remote
         * @protected
         */
        remote: {
            app: [
                'clearGraph',
                'initGraph',
                'updateGraphData',
                'updateSize'
            ]
        },
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * @member {Number} animationId=null
     */
    animationId = null
    /**
     * @member {Number} baseSpeed=0.5
     */
    baseSpeed = 0.5
    /**
     * @member {String|null} canvasId=null
     */
    canvasId = null
    /**
     * @member {Object} canvasSize=null
     */
    canvasSize = null
    /**
     * @member {Object} context=null
     */
    context = null
    /**
     * @member {Number} lastFrameTime=0
     */
    lastFrameTime = 0
    /**
     * @member {Array} nodes=[]
     */
    nodes = []
    /**
     * @member {Number} pulseY=0
     */
    pulseY = 0
    /**
     * @member {Function} renderLoop=this.render.bind(this)
     */
    renderLoop = this.render.bind(this)
    /**
     * @member {Number} startY=0
     */
    startY = 0

    /**
     * Clears the graph state and stops the render loop.
     * This is called when the view unmounts to prevent "Zombie Loops".
     */
    clearGraph() {
        let me = this;
        me.nodes      = [];
        me.context    = null; // This stops the render loop (see render() check)
        me.canvasId   = null;
        me.canvasSize = null
    }

    /**
     * Calculates the horizontal (X) position on the spine for a given vertical (Y) position.
     *
     * Since the nodes are not vertically aligned (they weave left/right), the spine is a polyline.
     * This method performs linear interpolation between the two nearest nodes to ensure the
     * "Pulse" stays perfectly centered on the spine path as it travels.
     *
     * @param {Number} y - The vertical position
     * @returns {Number} x - The calculated horizontal position on the spine
     */
    getXAtY(y) {
        let me = this;

        if (me.nodes.length < 2) return me.nodes[0]?.x || 38;
        if (y < me.nodes[0].y)   return me.nodes[0].x;

        for (let i = 0; i < me.nodes.length - 1; i++) {
            let curr = me.nodes[i],
                next = me.nodes[i+1];

            if (y >= curr.y && y <= next.y) {
                let ratio = (y - curr.y) / (next.y - curr.y);
                return curr.x + (next.x - curr.x) * ratio;
            }
        }

        return me.nodes[me.nodes.length - 1].x
    }

    /**
     * Helper to parse hex to rgb
     * @param {String} hex
     * @returns {Object} {r,g,b}
     */
    hexToRgb(hex) {
        hex = hex.replace(shorthandRegex, function(m, r, g, b) {
            return r + r + g + g + b + b;
        });

        const result = hexToRgbRegex.exec(hex);

        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : null
    }

    /**
     * Initializes the canvas context for the graph.
     *
     * **Async Initialization Pattern:**
     * The `OffscreenCanvas` is transferred from the main thread to the `CanvasWorker` asynchronously.
     * We cannot guarantee it exists in `Neo.currentWorker.canvasWindowMap` at the moment this method is called.
     * Therefore, we use a polling mechanism (`checkCanvas`) to wait for the transfer to complete before
     * starting the render loop.
     *
     * @param {Object} opts
     * @param {String} opts.canvasId
     * @param {String} opts.windowId
     */
    initGraph({canvasId, windowId}) {
        let me        = this,
            hasChange = me.canvasId !== canvasId;

        me.canvasId = canvasId;

        // Wait for the canvas to be available in the worker map.
        // The OffscreenCanvas is transferred asynchronously to the CanvasWorker,
        // so we need to poll until it arrives.
        const checkCanvas = () => {
            const canvas = Neo.currentWorker.canvasWindowMap[canvasId]?.[windowId];

            if (canvas) {
                me.context = canvas.getContext('2d');
                hasChange && me.renderLoop()
            } else {
                setTimeout(checkCanvas, 50)
            }
        };
        checkCanvas()
    }

    /**
     * @param {Object} data
     * @param {Array}  data.nodes
     * @param {Boolean} [data.reset]
     * @param {Number} [data.startY]
     */
    updateGraphData(data) {
        let me = this;
        me.nodes = data.nodes || [];
        if (data.startY !== undefined) {
            me.startY = data.startY;
        }

        if (data.reset) {
            me.pulseY = PHYSICS.pulseBounds
        }

        // Ensure animation loop is running if we have data
        if (me.nodes.length > 0 && !me.animationId && me.context) {
            me.renderLoop()
        }
    }

    /**
     * @param {Object} size
     * @param {Number} size.height
     * @param {Number} size.width
     */
    updateSize(size) {
        let me = this;

        me.canvasSize = size;

        if (me.context) {
            me.context.canvas.width  = size.width;
            me.context.canvas.height = size.height
        }
    }

    /**
     * The Main Animation Loop (60fps).
     *
     * This method is responsible for:
     * 1. **Physics Calculation**: Determining the pulse's speed based on proximity to nodes ("Traffic Model").
     * 2. **State Updates**: Updating the pulse's position (`pulseY`) and color (`Chameleon Effect`).
     * 3. **Drawing**: Rendering the spine, the pulse, and the node glows to the `OffscreenCanvas`.
     *
     * It uses `setTimeout` instead of `requestAnimationFrame` because SharedWorkers do not generally support rAF.
     */
    render() {
        let me = this;

        if (!me.context) {
            return
        }

        const
            ctx    = me.context,
            width  = me.canvasSize?.width  || 800,
            height = me.canvasSize?.height || 600,
            now    = Date.now();

        // Calculate the bottom-most boundary (last item's Y or default height)
        let maxY = height;

        if (me.nodes.length > 0) {
            maxY = me.nodes[me.nodes.length - 1].y
        }

        // Time delta in ms
        let dt = now - (me.lastFrameTime || now);
        me.lastFrameTime = now;

        // Cap dt to prevent huge jumps
        if (dt > 100) dt = 16;

        // 1. Calculate Physics
        // "Traffic Model": We want the pulse to slow down when it passes "interesting" things (nodes)
        // so the user has time to see the connection. It accelerates in the empty space between nodes.
        let minDist   = Infinity,
            nearNode  = null;

        me.nodes.forEach(node => {
            let dist = Math.abs(me.pulseY - node.y);
            if (dist < minDist) {
                minDist  = dist;
                nearNode = node;
            }
        });

        // Speed Modifier logic
        const {influenceRange, minMod, maxMod, pulseBounds} = PHYSICS;

        let speedModifier = maxMod;

        if (minDist < influenceRange) {
            // Parabolic easing for smooth deceleration/acceleration
            let ratio = minDist / influenceRange;
            speedModifier = minMod + (maxMod - minMod) * (ratio * ratio);
        }

        // Color Interpolation (Chameleon Effect)
        // The pulse "absorbs" the color of the node it is currently passing.
        let {r, g, b} = BASE_COLOR;

        // If near a colored node (within 100px), interpolate to its color
        if (nearNode && nearNode.color && minDist < 100) {
            let target = me.hexToRgb(nearNode.color);
            if (target) {
                let mix = 1 - (minDist / 100);
                r = r + (target.r - r) * mix;
                g = g + (target.g - g) * mix;
                b = b + (target.b - b) * mix
            }
        }

        const pulseColorStr = `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}`; // leaves alpha open

        // Apply Velocity
        me.pulseY += me.baseSpeed * speedModifier * dt;
        if (me.pulseY > maxY - pulseBounds) {
            me.pulseY = pulseBounds; // Restart above
        }

        // Dynamic Pulse Length
        const
            baseLength  = 100,
            pulseLength = baseLength * (speedModifier * 0.8);

        // 2. Clear
        ctx.clearRect(0, 0, width, height);

        // 3. Draw Neural Connections (The "Spine")
        const gradient = ctx.createLinearGradient(0, 0, 0, height);
        gradient.addColorStop(0,   'rgba(150, 150, 150, 0.1)');
        gradient.addColorStop(0.5, 'rgba(150, 150, 150, 0.3)');
        gradient.addColorStop(1,   'rgba(150, 150, 150, 0.1)');

        ctx.strokeStyle = gradient;
        ctx.lineWidth   = 2;
        ctx.beginPath();

        if (me.nodes.length > 0) {
            let first = me.nodes[0];
            ctx.moveTo(first.x, first.y);

            for (let i = 1; i < me.nodes.length; i++) {
                let node = me.nodes[i];
                ctx.lineTo(node.x, node.y)
            }
        }
        ctx.stroke();

        // 4. Draw "Pulse" Effect
        const pulseY = me.pulseY;

        if (me.nodes.length > 0 && pulseY > me.nodes[0].y - pulseLength && pulseY < maxY) {
            const pulseGrad = ctx.createLinearGradient(0, pulseY, 0, pulseY + pulseLength);
            pulseGrad.addColorStop(0,   `${pulseColorStr}, 0)`);
            pulseGrad.addColorStop(0.5, `${pulseColorStr}, 1)`);
            pulseGrad.addColorStop(1,   `${pulseColorStr}, 0)`);

            ctx.strokeStyle = pulseGrad;
            ctx.lineWidth   = 4;
            ctx.beginPath();

            let pulseX = me.getXAtY(pulseY);
            ctx.moveTo(pulseX, pulseY);
            ctx.lineTo(me.getXAtY(pulseY + pulseLength), Math.min(pulseY + pulseLength, maxY));
            ctx.stroke()
        }

        // 5. "The Gap"
        ctx.globalCompositeOperation = 'destination-out';
        ctx.fillStyle                = '#000';

        me.nodes.forEach(node => {
            if (node.radius) {
                ctx.beginPath();
                ctx.arc(node.x, node.y, node.radius, 0, 2 * Math.PI);
                ctx.fill()
            }
        });

        // 5. Draw Orbit/Glow Effects
        ctx.globalCompositeOperation = 'source-over';

        me.nodes.forEach(node => {
            const
                radius  = node.radius || 20,
                x       = node.x,
                y       = node.y,
                pTop    = pulseY,
                pBottom = pulseY + pulseLength,
                nTop    = y - radius,
                nBottom = y + radius;

            if (pBottom > nTop && pTop < nBottom) {
                const getProgress = (val) => {
                    return Math.max(0, Math.min(1, (val - nTop) / (2 * radius)))
                };

                const
                    startP    = getProgress(pTop),
                    endP      = getProgress(pBottom),
                    angleTail = -Math.PI / 2 + (startP * Math.PI),
                    angleHead = -Math.PI / 2 + (endP * Math.PI);

                // Use the DYNAMIC color here too!
                ctx.strokeStyle = `${pulseColorStr}, 1)`;
                ctx.lineWidth   = 2;

                // Right Arc
                ctx.beginPath();
                ctx.arc(x, y, radius + 2, angleTail, angleHead, false);
                ctx.stroke();

                // Left Arc
                const
                    leftTail = -Math.PI/2 - (startP * Math.PI),
                    leftHead = -Math.PI/2 - (endP * Math.PI);

                ctx.beginPath();
                ctx.arc(x, y, radius + 2, leftTail, leftHead, true);
                ctx.stroke()
            }
        });

        // Loop using setTimeout (SharedWorkers do not support rAF)
        setTimeout(me.renderLoop, 1000 / 60)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TicketCanvas));


/***/ }

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2NhbnZhcy92ZW5kb3JzLWFwcHNfcG9ydGFsX2NhbnZhc19UaWNrZXRDYW52YXNfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQThDOztBQUU5QztBQUNBO0FBQ0Esa0NBQWtDLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRTtBQUM1RDtBQUNBOztBQUVBLG9CQUFvQix3QkFBd0I7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwREFBSTtBQUMvQjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNB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dENhbnZhcy5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2UgZnJvbSAnLi4vLi4vLi4vc3JjL2NvcmUvQmFzZS5tanMnO1xuXG5jb25zdFxuICAgIC8vIE1hdGNoZXMgZnVsbCBoZXggY29kZXMgKGUuZy4sIFwiIzAwMzNGRlwiIG9yIFwiMDAzM0ZGXCIpXG4gICAgaGV4VG9SZ2JSZWdleCAgPSAvXiM/KFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pJC9pLFxuICAgIC8vIE1hdGNoZXMgc2hvcnRoYW5kIGhleCBjb2RlcyAoZS5nLiwgXCIjMDNGXCIgb3IgXCIwM0ZcIikgZm9yIGV4cGFuc2lvblxuICAgIHNob3J0aGFuZFJlZ2V4ID0gL14jPyhbYS1mXFxkXSkoW2EtZlxcZF0pKFthLWZcXGRdKSQvaTtcblxuY29uc3QgQkFTRV9DT0xPUiA9IHtyOiA2NCwgZzogMTk2LCBiOiAyNTV9OyAvLyBOZW8gQmx1ZVxuXG5jb25zdCBQSFlTSUNTID0ge1xuICAgIGluZmx1ZW5jZVJhbmdlOiAxNTAsXG4gICAgbWluTW9kICAgICAgICA6IDAuMixcbiAgICBtYXhNb2QgICAgICAgIDogMS41LFxuICAgIHB1bHNlQm91bmRzICAgOiAtMjAwXG59O1xuXG4vKipcbiAqIEBzdW1tYXJ5IFJlbmRlcnMgdGhlIFwiTmV1cmFsIFRpbWVsaW5lXCIgdmlzdWFsaXphdGlvbiBmb3IgdGhlIFBvcnRhbCdzIFRpY2tldCB2aWV3LlxuICpcbiAqIFRoaXMgY2xhc3MgcnVucyBpbnNpZGUgYSBTaGFyZWRXb3JrZXIgKHZpYSBgQ2FudmFzV29ya2VyYCkgdG8gcHJvdmlkZSBhIGhpZ2gtcGVyZm9ybWFuY2UsXG4gKiBtYWluLXRocmVhZC1ibG9ja2luZy1mcmVlIGFuaW1hdGlvbi4gSXQgdmlzdWFsaXplcyB0aGUgZmxvdyBvZiB0aW1lIGFuZCBhY3Rpdml0eSBjb25uZWN0aW5nXG4gKiB0aW1lbGluZSBub2RlcyAodGlja2V0cy9ldmVudHMpLlxuICpcbiAqIEtleSBWaXN1YWwgQ29uY2VwdHM6XG4gKiAxLiAqKlRoZSBTcGluZSoqOiBBIGNvbnRpbnVvdXMsIGdyYWRpZW50LXN0cm9rZWQgbGluZSBjb25uZWN0aW5nIGFsbCBub2Rlcy5cbiAqIDIuICoqVGhlIFB1bHNlKio6IEEgXCJkYXRhIHBhY2tldFwiIHRoYXQgdHJhdmVscyBhbG9uZyB0aGUgc3BpbmUuXG4gKiAzLiAqKlRyYWZmaWMgTW9kZWwgUGh5c2ljcyoqOiBUaGUgcHVsc2UgZG9lcyBub3QgbW92ZSBhdCBjb25zdGFudCBzcGVlZC4gSXQgYWNjZWxlcmF0ZXMgaW4gZW1wdHkgc3BhY2VcbiAqICAgIGFuZCBkZWNlbGVyYXRlcyB3aGVuIGFwcHJvYWNoaW5nIG5vZGVzIChcImludGVyZXN0IHBvaW50c1wiKSwgY3JlYXRpbmcgYSBzZW5zZSBvZiBcIm9ic2VydmluZ1wiIHRoZSBkYXRhLlxuICogNC4gKipDaGFtZWxlb24gRWZmZWN0Kio6IFRoZSBwdWxzZSBkeW5hbWljYWxseSBjaGFuZ2VzIGl0cyBjb2xvciB0byBtYXRjaCB0aGUgc2VtYW50aWMgY29sb3Igb2YgdGhlXG4gKiAgICBuZWFyZXN0IG5vZGUgKGUuZy4sIFJlZCBmb3IgQnVncywgR3JlZW4gZm9yIEZlYXR1cmVzKSBhcyBpdCBwYXNzZXMgYnkuXG4gKlxuICogQGNsYXNzIFBvcnRhbC5jYW52YXMuVGlja2V0Q2FudmFzXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKiBAc2luZ2xldG9uXG4gKi9cbmNsYXNzIFRpY2tldENhbnZhcyBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nUG9ydGFsLmNhbnZhcy5UaWNrZXRDYW52YXMnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ1BvcnRhbC5jYW52YXMuVGlja2V0Q2FudmFzJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW90ZSBtZXRob2QgYWNjZXNzXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gcmVtb3RlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHJlbW90ZToge1xuICAgICAgICAgICAgYXBwOiBbXG4gICAgICAgICAgICAgICAgJ2NsZWFyR3JhcGgnLFxuICAgICAgICAgICAgICAgICdpbml0R3JhcGgnLFxuICAgICAgICAgICAgICAgICd1cGRhdGVHcmFwaERhdGEnLFxuICAgICAgICAgICAgICAgICd1cGRhdGVTaXplJ1xuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2luZ2xldG9uPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2luZ2xldG9uOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSBhbmltYXRpb25JZD1udWxsXG4gICAgICovXG4gICAgYW5pbWF0aW9uSWQgPSBudWxsXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSBiYXNlU3BlZWQ9MC41XG4gICAgICovXG4gICAgYmFzZVNwZWVkID0gMC41XG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGNhbnZhc0lkPW51bGxcbiAgICAgKi9cbiAgICBjYW52YXNJZCA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGNhbnZhc1NpemU9bnVsbFxuICAgICAqL1xuICAgIGNhbnZhc1NpemUgPSBudWxsXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBjb250ZXh0PW51bGxcbiAgICAgKi9cbiAgICBjb250ZXh0ID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gbGFzdEZyYW1lVGltZT0wXG4gICAgICovXG4gICAgbGFzdEZyYW1lVGltZSA9IDBcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtBcnJheX0gbm9kZXM9W11cbiAgICAgKi9cbiAgICBub2RlcyA9IFtdXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSBwdWxzZVk9MFxuICAgICAqL1xuICAgIHB1bHNlWSA9IDBcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gcmVuZGVyTG9vcD10aGlzLnJlbmRlci5iaW5kKHRoaXMpXG4gICAgICovXG4gICAgcmVuZGVyTG9vcCA9IHRoaXMucmVuZGVyLmJpbmQodGhpcylcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHN0YXJ0WT0wXG4gICAgICovXG4gICAgc3RhcnRZID0gMFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBncmFwaCBzdGF0ZSBhbmQgc3RvcHMgdGhlIHJlbmRlciBsb29wLlxuICAgICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhlIHZpZXcgdW5tb3VudHMgdG8gcHJldmVudCBcIlpvbWJpZSBMb29wc1wiLlxuICAgICAqL1xuICAgIGNsZWFyR3JhcGgoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG4gICAgICAgIG1lLm5vZGVzICAgICAgPSBbXTtcbiAgICAgICAgbWUuY29udGV4dCAgICA9IG51bGw7IC8vIFRoaXMgc3RvcHMgdGhlIHJlbmRlciBsb29wIChzZWUgcmVuZGVyKCkgY2hlY2spXG4gICAgICAgIG1lLmNhbnZhc0lkICAgPSBudWxsO1xuICAgICAgICBtZS5jYW52YXNTaXplID0gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGhvcml6b250YWwgKFgpIHBvc2l0aW9uIG9uIHRoZSBzcGluZSBmb3IgYSBnaXZlbiB2ZXJ0aWNhbCAoWSkgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBTaW5jZSB0aGUgbm9kZXMgYXJlIG5vdCB2ZXJ0aWNhbGx5IGFsaWduZWQgKHRoZXkgd2VhdmUgbGVmdC9yaWdodCksIHRoZSBzcGluZSBpcyBhIHBvbHlsaW5lLlxuICAgICAqIFRoaXMgbWV0aG9kIHBlcmZvcm1zIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdGhlIHR3byBuZWFyZXN0IG5vZGVzIHRvIGVuc3VyZSB0aGVcbiAgICAgKiBcIlB1bHNlXCIgc3RheXMgcGVyZmVjdGx5IGNlbnRlcmVkIG9uIHRoZSBzcGluZSBwYXRoIGFzIGl0IHRyYXZlbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSAtIFRoZSB2ZXJ0aWNhbCBwb3NpdGlvblxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IHggLSBUaGUgY2FsY3VsYXRlZCBob3Jpem9udGFsIHBvc2l0aW9uIG9uIHRoZSBzcGluZVxuICAgICAqL1xuICAgIGdldFhBdFkoeSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5ub2Rlcy5sZW5ndGggPCAyKSByZXR1cm4gbWUubm9kZXNbMF0/LnggfHwgMzg7XG4gICAgICAgIGlmICh5IDwgbWUubm9kZXNbMF0ueSkgICByZXR1cm4gbWUubm9kZXNbMF0ueDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lLm5vZGVzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1cnIgPSBtZS5ub2Rlc1tpXSxcbiAgICAgICAgICAgICAgICBuZXh0ID0gbWUubm9kZXNbaSsxXTtcblxuICAgICAgICAgICAgaWYgKHkgPj0gY3Vyci55ICYmIHkgPD0gbmV4dC55KSB7XG4gICAgICAgICAgICAgICAgbGV0IHJhdGlvID0gKHkgLSBjdXJyLnkpIC8gKG5leHQueSAtIGN1cnIueSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnIueCArIChuZXh0LnggLSBjdXJyLngpICogcmF0aW87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWUubm9kZXNbbWUubm9kZXMubGVuZ3RoIC0gMV0ueFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciB0byBwYXJzZSBoZXggdG8gcmdiXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGhleFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHtyLGcsYn1cbiAgICAgKi9cbiAgICBoZXhUb1JnYihoZXgpIHtcbiAgICAgICAgaGV4ID0gaGV4LnJlcGxhY2Uoc2hvcnRoYW5kUmVnZXgsIGZ1bmN0aW9uKG0sIHIsIGcsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiByICsgciArIGcgKyBnICsgYiArIGI7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGhleFRvUmdiUmVnZXguZXhlYyhoZXgpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQgPyB7XG4gICAgICAgICAgICByOiBwYXJzZUludChyZXN1bHRbMV0sIDE2KSxcbiAgICAgICAgICAgIGc6IHBhcnNlSW50KHJlc3VsdFsyXSwgMTYpLFxuICAgICAgICAgICAgYjogcGFyc2VJbnQocmVzdWx0WzNdLCAxNilcbiAgICAgICAgfSA6IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgY2FudmFzIGNvbnRleHQgZm9yIHRoZSBncmFwaC5cbiAgICAgKlxuICAgICAqICoqQXN5bmMgSW5pdGlhbGl6YXRpb24gUGF0dGVybjoqKlxuICAgICAqIFRoZSBgT2Zmc2NyZWVuQ2FudmFzYCBpcyB0cmFuc2ZlcnJlZCBmcm9tIHRoZSBtYWluIHRocmVhZCB0byB0aGUgYENhbnZhc1dvcmtlcmAgYXN5bmNocm9ub3VzbHkuXG4gICAgICogV2UgY2Fubm90IGd1YXJhbnRlZSBpdCBleGlzdHMgaW4gYE5lby5jdXJyZW50V29ya2VyLmNhbnZhc1dpbmRvd01hcGAgYXQgdGhlIG1vbWVudCB0aGlzIG1ldGhvZCBpcyBjYWxsZWQuXG4gICAgICogVGhlcmVmb3JlLCB3ZSB1c2UgYSBwb2xsaW5nIG1lY2hhbmlzbSAoYGNoZWNrQ2FudmFzYCkgdG8gd2FpdCBmb3IgdGhlIHRyYW5zZmVyIHRvIGNvbXBsZXRlIGJlZm9yZVxuICAgICAqIHN0YXJ0aW5nIHRoZSByZW5kZXIgbG9vcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdHMuY2FudmFzSWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy53aW5kb3dJZFxuICAgICAqL1xuICAgIGluaXRHcmFwaCh7Y2FudmFzSWQsIHdpbmRvd0lkfSkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGhhc0NoYW5nZSA9IG1lLmNhbnZhc0lkICE9PSBjYW52YXNJZDtcblxuICAgICAgICBtZS5jYW52YXNJZCA9IGNhbnZhc0lkO1xuXG4gICAgICAgIC8vIFdhaXQgZm9yIHRoZSBjYW52YXMgdG8gYmUgYXZhaWxhYmxlIGluIHRoZSB3b3JrZXIgbWFwLlxuICAgICAgICAvLyBUaGUgT2Zmc2NyZWVuQ2FudmFzIGlzIHRyYW5zZmVycmVkIGFzeW5jaHJvbm91c2x5IHRvIHRoZSBDYW52YXNXb3JrZXIsXG4gICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gcG9sbCB1bnRpbCBpdCBhcnJpdmVzLlxuICAgICAgICBjb25zdCBjaGVja0NhbnZhcyA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNhbnZhcyA9IE5lby5jdXJyZW50V29ya2VyLmNhbnZhc1dpbmRvd01hcFtjYW52YXNJZF0/Llt3aW5kb3dJZF07XG5cbiAgICAgICAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgICAgICAgICBtZS5jb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgaGFzQ2hhbmdlICYmIG1lLnJlbmRlckxvb3AoKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNoZWNrQ2FudmFzLCA1MClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY2hlY2tDYW52YXMoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtBcnJheX0gIGRhdGEubm9kZXNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkYXRhLnJlc2V0XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZGF0YS5zdGFydFldXG4gICAgICovXG4gICAgdXBkYXRlR3JhcGhEYXRhKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcbiAgICAgICAgbWUubm9kZXMgPSBkYXRhLm5vZGVzIHx8IFtdO1xuICAgICAgICBpZiAoZGF0YS5zdGFydFkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbWUuc3RhcnRZID0gZGF0YS5zdGFydFk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YS5yZXNldCkge1xuICAgICAgICAgICAgbWUucHVsc2VZID0gUEhZU0lDUy5wdWxzZUJvdW5kc1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW5zdXJlIGFuaW1hdGlvbiBsb29wIGlzIHJ1bm5pbmcgaWYgd2UgaGF2ZSBkYXRhXG4gICAgICAgIGlmIChtZS5ub2Rlcy5sZW5ndGggPiAwICYmICFtZS5hbmltYXRpb25JZCAmJiBtZS5jb250ZXh0KSB7XG4gICAgICAgICAgICBtZS5yZW5kZXJMb29wKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzaXplXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNpemUuaGVpZ2h0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNpemUud2lkdGhcbiAgICAgKi9cbiAgICB1cGRhdGVTaXplKHNpemUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5jYW52YXNTaXplID0gc2l6ZTtcblxuICAgICAgICBpZiAobWUuY29udGV4dCkge1xuICAgICAgICAgICAgbWUuY29udGV4dC5jYW52YXMud2lkdGggID0gc2l6ZS53aWR0aDtcbiAgICAgICAgICAgIG1lLmNvbnRleHQuY2FudmFzLmhlaWdodCA9IHNpemUuaGVpZ2h0XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgTWFpbiBBbmltYXRpb24gTG9vcCAoNjBmcHMpLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgcmVzcG9uc2libGUgZm9yOlxuICAgICAqIDEuICoqUGh5c2ljcyBDYWxjdWxhdGlvbioqOiBEZXRlcm1pbmluZyB0aGUgcHVsc2UncyBzcGVlZCBiYXNlZCBvbiBwcm94aW1pdHkgdG8gbm9kZXMgKFwiVHJhZmZpYyBNb2RlbFwiKS5cbiAgICAgKiAyLiAqKlN0YXRlIFVwZGF0ZXMqKjogVXBkYXRpbmcgdGhlIHB1bHNlJ3MgcG9zaXRpb24gKGBwdWxzZVlgKSBhbmQgY29sb3IgKGBDaGFtZWxlb24gRWZmZWN0YCkuXG4gICAgICogMy4gKipEcmF3aW5nKio6IFJlbmRlcmluZyB0aGUgc3BpbmUsIHRoZSBwdWxzZSwgYW5kIHRoZSBub2RlIGdsb3dzIHRvIHRoZSBgT2Zmc2NyZWVuQ2FudmFzYC5cbiAgICAgKlxuICAgICAqIEl0IHVzZXMgYHNldFRpbWVvdXRgIGluc3RlYWQgb2YgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgYmVjYXVzZSBTaGFyZWRXb3JrZXJzIGRvIG5vdCBnZW5lcmFsbHkgc3VwcG9ydCByQUYuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUuY29udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdFxuICAgICAgICAgICAgY3R4ICAgID0gbWUuY29udGV4dCxcbiAgICAgICAgICAgIHdpZHRoICA9IG1lLmNhbnZhc1NpemU/LndpZHRoICB8fCA4MDAsXG4gICAgICAgICAgICBoZWlnaHQgPSBtZS5jYW52YXNTaXplPy5oZWlnaHQgfHwgNjAwLFxuICAgICAgICAgICAgbm93ICAgID0gRGF0ZS5ub3coKTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGJvdHRvbS1tb3N0IGJvdW5kYXJ5IChsYXN0IGl0ZW0ncyBZIG9yIGRlZmF1bHQgaGVpZ2h0KVxuICAgICAgICBsZXQgbWF4WSA9IGhlaWdodDtcblxuICAgICAgICBpZiAobWUubm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbWF4WSA9IG1lLm5vZGVzW21lLm5vZGVzLmxlbmd0aCAtIDFdLnlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRpbWUgZGVsdGEgaW4gbXNcbiAgICAgICAgbGV0IGR0ID0gbm93IC0gKG1lLmxhc3RGcmFtZVRpbWUgfHwgbm93KTtcbiAgICAgICAgbWUubGFzdEZyYW1lVGltZSA9IG5vdztcblxuICAgICAgICAvLyBDYXAgZHQgdG8gcHJldmVudCBodWdlIGp1bXBzXG4gICAgICAgIGlmIChkdCA+IDEwMCkgZHQgPSAxNjtcblxuICAgICAgICAvLyAxLiBDYWxjdWxhdGUgUGh5c2ljc1xuICAgICAgICAvLyBcIlRyYWZmaWMgTW9kZWxcIjogV2Ugd2FudCB0aGUgcHVsc2UgdG8gc2xvdyBkb3duIHdoZW4gaXQgcGFzc2VzIFwiaW50ZXJlc3RpbmdcIiB0aGluZ3MgKG5vZGVzKVxuICAgICAgICAvLyBzbyB0aGUgdXNlciBoYXMgdGltZSB0byBzZWUgdGhlIGNvbm5lY3Rpb24uIEl0IGFjY2VsZXJhdGVzIGluIHRoZSBlbXB0eSBzcGFjZSBiZXR3ZWVuIG5vZGVzLlxuICAgICAgICBsZXQgbWluRGlzdCAgID0gSW5maW5pdHksXG4gICAgICAgICAgICBuZWFyTm9kZSAgPSBudWxsO1xuXG4gICAgICAgIG1lLm5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICBsZXQgZGlzdCA9IE1hdGguYWJzKG1lLnB1bHNlWSAtIG5vZGUueSk7XG4gICAgICAgICAgICBpZiAoZGlzdCA8IG1pbkRpc3QpIHtcbiAgICAgICAgICAgICAgICBtaW5EaXN0ICA9IGRpc3Q7XG4gICAgICAgICAgICAgICAgbmVhck5vZGUgPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBTcGVlZCBNb2RpZmllciBsb2dpY1xuICAgICAgICBjb25zdCB7aW5mbHVlbmNlUmFuZ2UsIG1pbk1vZCwgbWF4TW9kLCBwdWxzZUJvdW5kc30gPSBQSFlTSUNTO1xuXG4gICAgICAgIGxldCBzcGVlZE1vZGlmaWVyID0gbWF4TW9kO1xuXG4gICAgICAgIGlmIChtaW5EaXN0IDwgaW5mbHVlbmNlUmFuZ2UpIHtcbiAgICAgICAgICAgIC8vIFBhcmFib2xpYyBlYXNpbmcgZm9yIHNtb290aCBkZWNlbGVyYXRpb24vYWNjZWxlcmF0aW9uXG4gICAgICAgICAgICBsZXQgcmF0aW8gPSBtaW5EaXN0IC8gaW5mbHVlbmNlUmFuZ2U7XG4gICAgICAgICAgICBzcGVlZE1vZGlmaWVyID0gbWluTW9kICsgKG1heE1vZCAtIG1pbk1vZCkgKiAocmF0aW8gKiByYXRpbyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb2xvciBJbnRlcnBvbGF0aW9uIChDaGFtZWxlb24gRWZmZWN0KVxuICAgICAgICAvLyBUaGUgcHVsc2UgXCJhYnNvcmJzXCIgdGhlIGNvbG9yIG9mIHRoZSBub2RlIGl0IGlzIGN1cnJlbnRseSBwYXNzaW5nLlxuICAgICAgICBsZXQge3IsIGcsIGJ9ID0gQkFTRV9DT0xPUjtcblxuICAgICAgICAvLyBJZiBuZWFyIGEgY29sb3JlZCBub2RlICh3aXRoaW4gMTAwcHgpLCBpbnRlcnBvbGF0ZSB0byBpdHMgY29sb3JcbiAgICAgICAgaWYgKG5lYXJOb2RlICYmIG5lYXJOb2RlLmNvbG9yICYmIG1pbkRpc3QgPCAxMDApIHtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBtZS5oZXhUb1JnYihuZWFyTm9kZS5jb2xvcik7XG4gICAgICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgbGV0IG1peCA9IDEgLSAobWluRGlzdCAvIDEwMCk7XG4gICAgICAgICAgICAgICAgciA9IHIgKyAodGFyZ2V0LnIgLSByKSAqIG1peDtcbiAgICAgICAgICAgICAgICBnID0gZyArICh0YXJnZXQuZyAtIGcpICogbWl4O1xuICAgICAgICAgICAgICAgIGIgPSBiICsgKHRhcmdldC5iIC0gYikgKiBtaXhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHB1bHNlQ29sb3JTdHIgPSBgcmdiYSgke01hdGgucm91bmQocil9LCAke01hdGgucm91bmQoZyl9LCAke01hdGgucm91bmQoYil9YDsgLy8gbGVhdmVzIGFscGhhIG9wZW5cblxuICAgICAgICAvLyBBcHBseSBWZWxvY2l0eVxuICAgICAgICBtZS5wdWxzZVkgKz0gbWUuYmFzZVNwZWVkICogc3BlZWRNb2RpZmllciAqIGR0O1xuICAgICAgICBpZiAobWUucHVsc2VZID4gbWF4WSAtIHB1bHNlQm91bmRzKSB7XG4gICAgICAgICAgICBtZS5wdWxzZVkgPSBwdWxzZUJvdW5kczsgLy8gUmVzdGFydCBhYm92ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRHluYW1pYyBQdWxzZSBMZW5ndGhcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIGJhc2VMZW5ndGggID0gMTAwLFxuICAgICAgICAgICAgcHVsc2VMZW5ndGggPSBiYXNlTGVuZ3RoICogKHNwZWVkTW9kaWZpZXIgKiAwLjgpO1xuXG4gICAgICAgIC8vIDIuIENsZWFyXG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgLy8gMy4gRHJhdyBOZXVyYWwgQ29ubmVjdGlvbnMgKFRoZSBcIlNwaW5lXCIpXG4gICAgICAgIGNvbnN0IGdyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIDAsIGhlaWdodCk7XG4gICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCAgICdyZ2JhKDE1MCwgMTUwLCAxNTAsIDAuMSknKTtcbiAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAuNSwgJ3JnYmEoMTUwLCAxNTAsIDE1MCwgMC4zKScpO1xuICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgICAncmdiYSgxNTAsIDE1MCwgMTUwLCAwLjEpJyk7XG5cbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gZ3JhZGllbnQ7XG4gICAgICAgIGN0eC5saW5lV2lkdGggICA9IDI7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgICBpZiAobWUubm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gbWUubm9kZXNbMF07XG4gICAgICAgICAgICBjdHgubW92ZVRvKGZpcnN0LngsIGZpcnN0LnkpO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG1lLm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBtZS5ub2Rlc1tpXTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKG5vZGUueCwgbm9kZS55KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICAvLyA0LiBEcmF3IFwiUHVsc2VcIiBFZmZlY3RcbiAgICAgICAgY29uc3QgcHVsc2VZID0gbWUucHVsc2VZO1xuXG4gICAgICAgIGlmIChtZS5ub2Rlcy5sZW5ndGggPiAwICYmIHB1bHNlWSA+IG1lLm5vZGVzWzBdLnkgLSBwdWxzZUxlbmd0aCAmJiBwdWxzZVkgPCBtYXhZKSB7XG4gICAgICAgICAgICBjb25zdCBwdWxzZUdyYWQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgcHVsc2VZLCAwLCBwdWxzZVkgKyBwdWxzZUxlbmd0aCk7XG4gICAgICAgICAgICBwdWxzZUdyYWQuYWRkQ29sb3JTdG9wKDAsICAgYCR7cHVsc2VDb2xvclN0cn0sIDApYCk7XG4gICAgICAgICAgICBwdWxzZUdyYWQuYWRkQ29sb3JTdG9wKDAuNSwgYCR7cHVsc2VDb2xvclN0cn0sIDEpYCk7XG4gICAgICAgICAgICBwdWxzZUdyYWQuYWRkQ29sb3JTdG9wKDEsICAgYCR7cHVsc2VDb2xvclN0cn0sIDApYCk7XG5cbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHB1bHNlR3JhZDtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggICA9IDQ7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgICAgIGxldCBwdWxzZVggPSBtZS5nZXRYQXRZKHB1bHNlWSk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHB1bHNlWCwgcHVsc2VZKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8obWUuZ2V0WEF0WShwdWxzZVkgKyBwdWxzZUxlbmd0aCksIE1hdGgubWluKHB1bHNlWSArIHB1bHNlTGVuZ3RoLCBtYXhZKSk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDUuIFwiVGhlIEdhcFwiXG4gICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3V0JztcbiAgICAgICAgY3R4LmZpbGxTdHlsZSAgICAgICAgICAgICAgICA9ICcjMDAwJztcblxuICAgICAgICBtZS5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUucmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5hcmMobm9kZS54LCBub2RlLnksIG5vZGUucmFkaXVzLCAwLCAyICogTWF0aC5QSSk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyA1LiBEcmF3IE9yYml0L0dsb3cgRWZmZWN0c1xuICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1vdmVyJztcblxuICAgICAgICBtZS5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgY29uc3RcbiAgICAgICAgICAgICAgICByYWRpdXMgID0gbm9kZS5yYWRpdXMgfHwgMjAsXG4gICAgICAgICAgICAgICAgeCAgICAgICA9IG5vZGUueCxcbiAgICAgICAgICAgICAgICB5ICAgICAgID0gbm9kZS55LFxuICAgICAgICAgICAgICAgIHBUb3AgICAgPSBwdWxzZVksXG4gICAgICAgICAgICAgICAgcEJvdHRvbSA9IHB1bHNlWSArIHB1bHNlTGVuZ3RoLFxuICAgICAgICAgICAgICAgIG5Ub3AgICAgPSB5IC0gcmFkaXVzLFxuICAgICAgICAgICAgICAgIG5Cb3R0b20gPSB5ICsgcmFkaXVzO1xuXG4gICAgICAgICAgICBpZiAocEJvdHRvbSA+IG5Ub3AgJiYgcFRvcCA8IG5Cb3R0b20pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBnZXRQcm9ncmVzcyA9ICh2YWwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKDEsICh2YWwgLSBuVG9wKSAvICgyICogcmFkaXVzKSkpXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0UCAgICA9IGdldFByb2dyZXNzKHBUb3ApLFxuICAgICAgICAgICAgICAgICAgICBlbmRQICAgICAgPSBnZXRQcm9ncmVzcyhwQm90dG9tKSxcbiAgICAgICAgICAgICAgICAgICAgYW5nbGVUYWlsID0gLU1hdGguUEkgLyAyICsgKHN0YXJ0UCAqIE1hdGguUEkpLFxuICAgICAgICAgICAgICAgICAgICBhbmdsZUhlYWQgPSAtTWF0aC5QSSAvIDIgKyAoZW5kUCAqIE1hdGguUEkpO1xuXG4gICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBEWU5BTUlDIGNvbG9yIGhlcmUgdG9vIVxuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGAke3B1bHNlQ29sb3JTdHJ9LCAxKWA7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCAgID0gMjtcblxuICAgICAgICAgICAgICAgIC8vIFJpZ2h0IEFyY1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHguYXJjKHgsIHksIHJhZGl1cyArIDIsIGFuZ2xlVGFpbCwgYW5nbGVIZWFkLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgICAgICAgICAgLy8gTGVmdCBBcmNcbiAgICAgICAgICAgICAgICBjb25zdFxuICAgICAgICAgICAgICAgICAgICBsZWZ0VGFpbCA9IC1NYXRoLlBJLzIgLSAoc3RhcnRQICogTWF0aC5QSSksXG4gICAgICAgICAgICAgICAgICAgIGxlZnRIZWFkID0gLU1hdGguUEkvMiAtIChlbmRQICogTWF0aC5QSSk7XG5cbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCByYWRpdXMgKyAyLCBsZWZ0VGFpbCwgbGVmdEhlYWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBMb29wIHVzaW5nIHNldFRpbWVvdXQgKFNoYXJlZFdvcmtlcnMgZG8gbm90IHN1cHBvcnQgckFGKVxuICAgICAgICBzZXRUaW1lb3V0KG1lLnJlbmRlckxvb3AsIDEwMDAgLyA2MClcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFRpY2tldENhbnZhcyk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9