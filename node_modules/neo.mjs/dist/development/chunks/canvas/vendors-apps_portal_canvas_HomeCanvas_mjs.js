"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-apps_portal_canvas_HomeCanvas_mjs"],{

/***/ "./apps/portal/canvas/HomeCanvas.mjs"
/*!*******************************************!*\
  !*** ./apps/portal/canvas/HomeCanvas.mjs ***!
  \*******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/core/Base.mjs */ "./src/core/Base.mjs");


const
    PRIMARY          = '#3E63DD',
    SECONDARY        = '#8BA6FF',
    HIGHLIGHT        = '#00BFFF', // Deep Sky Blue (High Contrast)
    SPARK_COLOR      = '#4B0082', // Indigo
    CONNECTION_COLOR = '#808080',
    NODE_COUNT       = 150,
    NODE_STRIDE      = 9, // x, y, vx, vy, radius, layer, parentId, phase, energy
    AGENT_COUNT      = 20,
    AGENT_STRIDE     = 6, // x, y, vx, vy, targetIdx, state
    PACKET_COUNT     = 20,
    PACKET_STRIDE    = 5; // x, y, vx, vy, life (0-1)

/**
 * @summary SharedWorker renderer for the Portal Home "Neural Swarm" background.
 *
 * Implements the **"Neural Swarm"** visual theme, a dynamic, mutable network simulation that
 * visualizes the Neo.mjs Application Engine as a living ecosystem.
 *
 * **Visual Architecture:**
 * 1. **Living Topology (The Graph):** Nodes are not static; they form hierarchical clusters representing
 *    Components within Containers. The topology is mutable, with sub-clusters occasionally detaching,
 * *    drifting, and re-parenting (Visualizing "Atomic Moves").
 * 2. **Autonomous Agents (The Neural Link):** "Seeker Drones" roam the graph using Boid behavior
 *    (Separation, Alignment, Cohesion). They "scan" nodes, transferring energy and triggering
 *    visual highlights, representing the active intelligence of the framework.
 * 3. **Data Flow (Signal Packets):** Pulses of light travel along connections from child to parent,
 *    visualizing the flow of events and data upstream.
 * 4. **Atmosphere (Parallax):** A multi-layered depth system creates a volumetric feel, distinguishing
 *    foreground "active" nodes from background "context" nodes.
 *
 * **Performance Architecture (Zero-Allocation):**
 * To maintain 60fps on high-refresh displays without GC stutters, this class employs a **Zero-Allocation** strategy during the render loop.
 * 1. **TypedArray Buffers:** All entity data (Nodes, Agents, Packets) is stored in pre-allocated `Float32Array` buffers.
 * 2. **Inlined Physics:** Vector calculations are performed inline without creating temporary Objects.
 * 3. **Gradient Caching:** CanvasGradients are created only on resize (`updateResources`) and cached.
 *
 * **Node Buffer Layout (Float32Array):**
 * - 0: x (Position X)
 * - 1: y (Position Y)
 * - 2: vx (Velocity X)
 * - 3: vy (Velocity Y)
 * - 4: radius (Visual size)
 * - 5: layer (Parallax depth: 0=back, 1=mid, 2=front)
 * - 6: parentId (Index of parent node, -1 if parent, -2 if drifting)
 * - 7: phase (Animation offset for breathing)
 * - 8: energy (Interaction state, 0-1)
 *
 * **Agent Buffer Layout (Float32Array):**
 * - 0: x
 * - 1: y
 * - 2: vx
 * - 3: vy
 * - 4: targetIdx (Index of target node, -1 if wandering)
 * - 5: state (0=moving, 1=scanning)
 *
 * **Packet Buffer Layout (Float32Array):**
 * - 0: x
 * - 1: y
 * - 2: vx
 * - 3: vy
 * - 4: life (Frames remaining, 0-1 normalized for alpha)
 *
 * @class Portal.canvas.HomeCanvas
 * @extends Neo.core.Base
 * @singleton
 */
class HomeCanvas extends _src_core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.canvas.HomeCanvas'
         * @protected
         */
        className: 'Portal.canvas.HomeCanvas',
        /**
         * Remote method access for the App Worker.
         * Allows the UI to control the simulation state and input.
         * @member {Object} remote
         * @protected
         */
        remote: {
            app: [
                'clearGraph',
                'initGraph',
                'pause',
                'resume',
                'updateMouseState',
                'updateSize'
            ]
        },
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * Pre-allocated buffer for agent data (Seeker Drones).
     * @member {Float32Array|null} agentBuffer=null
     */
    agentBuffer = null
    /**
     * ID of the canvas element in the DOM.
     * @member {String|null} canvasId=null
     */
    canvasId = null
    /**
     * Current dimensions of the canvas.
     * @member {Object|null} canvasSize=null
     */
    canvasSize = null
    /**
     * The 2D rendering context.
     * @member {OffscreenCanvasRenderingContext2D|null} context=null
     */
    context = null
    /**
     * Cache for reusable gradients to prevent GC.
     * @member {Object} gradients={}
     */
    gradients = {}
    /**
     * Flag to pause the render loop.
     * @member {Boolean} isPaused=false
     */
    isPaused = false
    /**
     * Tracked mouse position for interactive physics.
     * Initialize off-screen to prevent startup jitters.
     * @member {Object} mouse={x: -1000, y: -1000}
     */
    mouse = {x: -1000, y: -1000}
    /**
     * Pre-allocated buffer for node data (The Graph).
     * @member {Float32Array|null} nodeBuffer=null
     */
    nodeBuffer = null
    /**
     * Pre-allocated buffer for data packets (Signal Pulses).
     * @member {Float32Array|null} packetBuffer=null
     */
    packetBuffer = null
    /**
     * Active shockwave effects.
     * @member {Object[]} shockwaves=[]
     */
    shockwaves = []
    /**
     * Active spark particles (Data Debris).
     * @member {Object[]} sparks=[]
     */
    sparks = []
    /**
     * Global simulation time, used for procedural animations.
     * @member {Number} time=0
     */
    time = 0

    /**
     * Clears the graph state and stops the render loop.
     * Used when the component is destroyed or the route changes.
     */
    clearGraph() {
        let me = this;
        me.context      = null;
        me.canvasId     = null;
        me.canvasSize   = null;
        me.nodeBuffer   = null;
        me.agentBuffer  = null;
        me.packetBuffer = null;
        me.shockwaves   = [];
        me.sparks       = [];
        me.isPaused     = false;
        me.gradients    = {}
    }

    /**
     * Draws the autonomous agents (Seeker Drones).
     *
     * **Visuals:**
     * - **Head:** A solid circle indicating current position.
     * - **Trail:** A fading line drawn opposite to velocity, simulating motion blur.
     * - **Scan Effect:** A pulsing ring when the agent reaches a node (state=1).
     *
     * @param {CanvasRenderingContext2D} ctx
     */
    drawAgents(ctx) {
        let me = this;

        if (!me.agentBuffer) return;

        const
            buffer = me.agentBuffer,
            count  = AGENT_COUNT;

        ctx.strokeStyle = HIGHLIGHT;
        ctx.fillStyle   = '#FFFFFF';
        ctx.lineCap     = 'round';

        for (let i = 0; i < count; i++) {
            let idx   = i * AGENT_STRIDE,
                x     = buffer[idx],
                y     = buffer[idx + 1],
                vx    = buffer[idx + 2],
                vy    = buffer[idx + 3],
                state = buffer[idx + 5];

            // 1. Draw Trail (Motion Blur)
            let speed = Math.sqrt(vx*vx + vy*vy);

            if (speed > 0.1) {
                ctx.beginPath();
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.6;
                ctx.moveTo(x, y);
                ctx.lineTo(x - vx * 4, y - vy * 4);
                ctx.stroke()
            }

            // 2. Draw Head
            ctx.beginPath();
            ctx.globalAlpha = state === 1 ? 1 : 0.8;
            let radius = state === 1 ? 3 : 2;
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();

            // 3. Scan Effect
            if (state === 1) {
                ctx.beginPath();
                ctx.lineWidth = 1;
                ctx.globalAlpha = 0.3;
                ctx.arc(x, y, 8 + Math.sin(me.time * 10) * 2, 0, Math.PI * 2);
                ctx.stroke()
            }
        }

        ctx.globalAlpha = 1
    }

    /**
     * Draws the neural network (nodes and connections).
     *
     * **Intent:**
     * Visualizes the "Application Graph".
     * - **Parallax:** Applies depth-based displacement based on mouse position.
     * - **Connections:** Lines are drawn only between related nodes (Parent-Child or Siblings).
     *   Lines thicken and brighten when near the mouse.
     * - **Nodes:** Circles breathing in size. Colors indicate depth (Layer) and energy state.
     *
     * **Optimization:**
     * Uses inlined math for parallax calculations to avoid allocating thousands of `{x,y}` objects per frame.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {Number} width
     * @param {Number} height
     */
    drawNetwork(ctx, width, height) {
        let me = this;

        if (!me.nodeBuffer) return;

        const
            buffer = me.nodeBuffer,
            count  = NODE_COUNT,
            mx     = me.mouse.x,
            my     = me.mouse.y,
            cx     = width / 2,
            cy     = height / 2;

        ctx.lineWidth = 1;

        // 1. Draw Connections
        // Iterates all unique pairs to draw lines between connected nodes.
        // Connections are drawn if nodes share a parent (siblings) or are parent-child.
        for (let i = 0; i < count; i++) {
            let idx  = i * NODE_STRIDE,
                l1   = buffer[idx + 5],
                pid1 = buffer[idx + 6],
                // Inline getPos logic for p1 to avoid GC
                f1   = l1 === 2 ? 0.05 : (l1 === 1 ? 0.02 : 0.01),
                dx1  = (mx !== -1000 ? mx - cx : 0) * f1,
                dy1  = (my !== -1000 ? my - cy : 0) * f1,
                p1x  = buffer[idx] + dx1,
                p1y  = buffer[idx + 1] + dy1;

            for (let j = i + 1; j < count; j++) {
                let idx2 = j * NODE_STRIDE,
                    l2   = buffer[idx2 + 5],
                    pid2 = buffer[idx2 + 6];

                const
                    sameCluster   = pid1 === pid2 && pid1 !== -1,
                    isParentChild = (pid1 === j) || (pid2 === i),
                    isClusterLink = (pid1 === -1 && pid2 === -1);

                if (!sameCluster && !isParentChild && !isClusterLink) continue;

                let f2   = l2 === 2 ? 0.05 : (l2 === 1 ? 0.02 : 0.01),
                    dx2  = (mx !== -1000 ? mx - cx : 0) * f2,
                    dy2  = (my !== -1000 ? my - cy : 0) * f2,
                    p2x  = buffer[idx2] + dx2,
                    p2y  = buffer[idx2 + 1] + dy2,
                    dx   = p1x - p2x,
                    dy   = p1y - p2y,
                    distSq = dx*dx + dy*dy;

                // Culling: Only draw connections within a certain distance
                if (distSq < 40000) {
                    let dist  = Math.sqrt(distSq),
                        alpha = 1 - (dist / 200);

                    alpha *= (0.2 + (l1 * 0.1));

                    let mDx = (p1x + p2x)/2 - mx,
                        mDy = (p1y + p2y)/2 - my,
                        mDistSq = mDx*mDx + mDy*mDy;

                    // Mouse Interaction: Highlight connections near cursor
                    if (mDistSq < 10000) {
                        alpha = Math.min(alpha + 0.5, 1);
                        ctx.strokeStyle = HIGHLIGHT;
                        ctx.lineWidth   = 1.5
                    } else {
                        ctx.strokeStyle = l1 === 2 ? PRIMARY : SECONDARY;
                        // Elasticity: Thicker when closer (Tension/Slack visualization)
                        ctx.lineWidth = 0.5 + (1 - (dist / 200))
                    }

                    ctx.beginPath();
                    ctx.globalAlpha = alpha * 0.5;
                    ctx.moveTo(p1x, p1y);
                    ctx.lineTo(p2x, p2y);
                    ctx.stroke()
                }
            }
        }

        // 2. Draw Nodes
        for (let i = 0; i < count; i++) {
            let idx      = i * NODE_STRIDE,
                radius   = buffer[idx + 4],
                layer    = buffer[idx + 5],
                parentId = buffer[idx + 6],
                phase    = buffer[idx + 7],
                energy   = buffer[idx + 8],
                // Inline getPos logic for pos
                f        = layer === 2 ? 0.05 : (layer === 1 ? 0.02 : 0.01),
                pDx      = (mx !== -1000 ? mx - cx : 0) * f,
                pDy      = (my !== -1000 ? my - cy : 0) * f,
                posX     = buffer[idx] + pDx,
                posY     = buffer[idx + 1] + pDy,
                dx       = posX - mx,
                dy       = posY - my,
                dist     = Math.sqrt(dx * dx + dy * dy),
                isHover  = dist < 50;

            // Shockwave Interaction
            if (me.shockwaves.length > 0) {
                me.shockwaves.forEach(wave => {
                    let wDist = Math.sqrt((posX - wave.x)**2 + (posY - wave.y)**2),
                        wRad  = wave.age * wave.speed;
                    if (Math.abs(wDist - wRad) < 20) {
                        isHover = true;
                    }
                });
            }

            ctx.beginPath();
            let r = parentId === -1 ? radius * 1.5 : radius;

            // Breathing + Energy
            r *= 1 + Math.sin(me.time * 2 + phase) * 0.15 + energy;

            if (isHover) {
                r *= 1.5;
            }

            ctx.arc(posX, posY, r, 0, Math.PI * 2);

            if (energy > 0.1) {
                // Energetic Node (Agent Scanned)
                ctx.fillStyle = HIGHLIGHT;
                ctx.globalAlpha = Math.min(1, 0.5 + energy)
            } else if (layer === 2) {
                ctx.fillStyle = isHover ? '#FFFFFF' : PRIMARY;
                ctx.globalAlpha = isHover ? 1 : 0.8
            } else if (parentId === -2) {
                // Drifting Node Visual
                ctx.fillStyle = HIGHLIGHT;
                ctx.globalAlpha = 0.6 + Math.sin(me.time * 10 + phase) * 0.3
            } else if (layer === 1) {
                ctx.fillStyle = isHover ? HIGHLIGHT : SECONDARY;
                ctx.globalAlpha = 0.5
            } else {
                ctx.fillStyle = CONNECTION_COLOR;
                ctx.globalAlpha = 0.2
            }

            ctx.fill();
        }

        ctx.globalAlpha = 1
    }

    /**
     * Draws the data packets traveling along connections.
     * Packets represent signal flow between nodes.
     * @param {OffscreenCanvasRenderingContext2D} ctx
     */
    drawPackets(ctx) {
        let me = this;

        if (!me.packetBuffer) return;

        const
            buffer = me.packetBuffer,
            count  = PACKET_COUNT;

        ctx.fillStyle   = '#FFFFFF';
        ctx.shadowBlur  = 5;
        ctx.shadowColor = HIGHLIGHT;

        for (let i = 0; i < count; i++) {
            let idx  = i * PACKET_STRIDE,
                life = buffer[idx + 4];

            if (life > 0) {
                let x = buffer[idx],
                    y = buffer[idx + 1];

                ctx.beginPath();
                ctx.globalAlpha = Math.min(life * 2, 1); // Fade out at end
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fill()
            }
        }

        ctx.shadowBlur  = 0;
        ctx.globalAlpha = 1
    }

    /**
     * Draws expanding shockwaves from clicks with Chromatic Aberration and Composite Rings.
     * Uses optimized RGBA composition to reduce GC pressure.
     * @param {OffscreenCanvasRenderingContext2D} ctx
     */
    drawShockwaves(ctx) {
        let me = this;

        if (me.shockwaves.length === 0) return;

        ctx.lineCap = 'round';

        for (let i = me.shockwaves.length - 1; i >= 0; i--) {
            let wave = me.shockwaves[i];
            wave.age++;

            let progress = wave.age / wave.maxAge;

            if (progress >= 1) {
                me.shockwaves.splice(i, 1);
                continue;
            }

            // Non-Linear Expansion (Explosive start, slow finish)
            let eased = 1 - Math.pow(1 - progress, 3),
                radius = eased * wave.maxRadius,
                alpha  = 1 - progress;

            // Chromatic Aberration (Shifted to Neon Blue/Cyan theme)

            // 1. Cyan Channel (Lagging Fringe) - Replaces Red
            ctx.beginPath();
            ctx.strokeStyle = HIGHLIGHT;
            ctx.globalAlpha = alpha * 0.8;
            ctx.lineWidth   = 4 * (1 - progress);
            ctx.shadowBlur  = 10;
            ctx.shadowColor = HIGHLIGHT;
            ctx.arc(wave.x, wave.y, radius * 0.99, 0, Math.PI * 2);
            ctx.stroke();

            // 2. Blue Channel (Leading Fringe)
            ctx.beginPath();
            ctx.strokeStyle = PRIMARY;
            ctx.globalAlpha = alpha * 0.8;
            ctx.lineWidth   = 4 * (1 - progress);
            ctx.shadowBlur  = 10;
            ctx.shadowColor = PRIMARY;
            ctx.arc(wave.x, wave.y, radius * 1.01, 0, Math.PI * 2);
            ctx.stroke();

            // 3. Primary Wave (White Hot Center)
            ctx.beginPath();
            ctx.strokeStyle = '#FFFFFF';
            ctx.globalAlpha = alpha;
            ctx.lineWidth   = 6 * (1 - progress);
            ctx.shadowBlur  = 20;
            ctx.shadowColor = '#FFFFFF';
            ctx.arc(wave.x, wave.y, radius, 0, Math.PI * 2);
            ctx.stroke();

            // 4. Pressure Fill (Refraction Fake)
            ctx.fillStyle = PRIMARY;
            ctx.globalAlpha = alpha * 0.05;
            ctx.fill();
        }

        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1
    }

    /**
     * Draws temporary spark particles (Data Debris).
     * @param {OffscreenCanvasRenderingContext2D} ctx
     */
    drawSparks(ctx) {
        let me = this;

        if (me.sparks.length === 0) return;

        ctx.strokeStyle = SPARK_COLOR;
        ctx.shadowBlur = 0; // Crisp lines on white
        ctx.lineWidth = 2;

        for (let s of me.sparks) {
            ctx.globalAlpha = s.life;
            ctx.beginPath();
            // Draw Trail based on velocity
            ctx.moveTo(s.x, s.y);
            ctx.lineTo(s.x - s.vx * 2, s.y - s.vy * 2);
            ctx.stroke()
        }

        ctx.globalAlpha = 1
    }

    /**
     * Initializes the autonomous agents.
     * Agents start at random positions with random high-velocity vectors.
     * @param {Number} width
     * @param {Number} height
     */
    initAgents(width, height) {
        let me = this;

        if (!me.agentBuffer) {
            me.agentBuffer = new Float32Array(AGENT_COUNT * AGENT_STRIDE);
        }

        const buffer = me.agentBuffer;

        for (let i = 0; i < AGENT_COUNT; i++) {
            let idx = i * AGENT_STRIDE;

            buffer[idx]     = Math.random() * width;  // x
            buffer[idx + 1] = Math.random() * height; // y
            buffer[idx + 2] = (Math.random() - 0.5) * 4; // vx (Fast!)
            buffer[idx + 3] = (Math.random() - 0.5) * 4; // vy
            buffer[idx + 4] = -1; // targetIdx (none)
            buffer[idx + 5] = 0   // state (moving)
        }
    }

    /**
     * Initializes the canvas context.
     * Connects to the OffscreenCanvas transferred from the main thread.
     * @param {Object} opts
     * @param {String} opts.canvasId
     * @param {String} opts.windowId
     */
    initGraph({canvasId, windowId}) {
        let me        = this,
            hasChange = me.canvasId !== canvasId;

        me.canvasId = canvasId;

        const checkCanvas = () => {
            const canvas = Neo.currentWorker.canvasWindowMap[canvasId]?.[windowId];

            if (canvas) {
                me.context = canvas.getContext('2d');
                me.updateSize({width: canvas.width, height: canvas.height});
                hasChange && me.renderLoop()
            } else {
                setTimeout(checkCanvas, 50)
            }
        };
        checkCanvas()
    }

    /**
     * Initializes the node buffer using **Golden Spiral** distribution.
     * This ensures a uniform but organic-looking distribution of nodes across the screen,
     * preventing the "clumping" seen with random placement.
     * @param {Number} width
     * @param {Number} height
     */
    initNodes(width, height) {
        let me = this;

        if (!me.nodeBuffer) {
            me.nodeBuffer = new Float32Array(NODE_COUNT * NODE_STRIDE);
        }

        const
            buffer        = me.nodeBuffer,
            cx            = width / 2,
            cy            = height / 2,
            phi           = (1 + Math.sqrt(5)) / 2,
            scale         = Math.sqrt(width * height / NODE_COUNT) * 0.8,
            parentCount   = Math.floor(NODE_COUNT * 0.1);
        let parentIndices = [];

        for (let i = 0; i < NODE_COUNT; i++) {
            let idx = i * NODE_STRIDE,
                isParent = i < parentCount;

            if (isParent) parentIndices.push(i);

            let theta = i * 2 * Math.PI * phi,
                r     = Math.sqrt(i) * scale;

            // Simple wrap to keep initial spiral inside reasonable bounds
            let x = cx + r * Math.cos(theta),
                y = cy + r * Math.sin(theta);

            // If the spiral is larger than screen, wrap it
            x = ((x % width) + width) % width;
            y = ((y % height) + height) % height;

            buffer[idx]     = x;
            buffer[idx + 1] = y;
            buffer[idx + 2] = (Math.random() - 0.5) * 0.2;
            buffer[idx + 3] = (Math.random() - 0.5) * 0.2;

            let layer = Math.floor(Math.random() * 3);
            buffer[idx + 5] = layer; // layer

            // Radius based on layer & role
            buffer[idx + 4] = isParent ? 4 + (layer * 2) : 2 + (layer * 1.5);

            // Parent ID (-1 for parents, assigned later for children)
            buffer[idx + 6] = isParent ? -1 : -2;

            // Phase (Breathing offset)
            buffer[idx + 7] = Math.random() * Math.PI * 2;

            // Energy
            buffer[idx + 8] = 0;
        }

        // 2. Assign Children to nearest Parent
        for (let i = parentCount; i < NODE_COUNT; i++) {
            let idx        = i * NODE_STRIDE,
                x          = buffer[idx],
                y          = buffer[idx + 1],
                bestDist   = Infinity,
                bestParent = -1;

            for (let pid of parentIndices) {
                let pIdx = pid * NODE_STRIDE,
                    px   = buffer[pIdx],
                    py   = buffer[pIdx + 1],
                    dx   = x - px,
                    dy   = y - py,
                    dSq  = dx*dx + dy*dy;

                if (dSq < bestDist) {
                    bestDist = dSq;
                    bestParent = pid;
                }
            }

            buffer[idx + 6] = bestParent
        }
    }

    /**
     * Initializes the packet buffer.
     */
    initPackets() {
        let me = this;
        if (!me.packetBuffer) {
            me.packetBuffer = new Float32Array(PACKET_COUNT * PACKET_STRIDE)
        }
    }

    /**
     * Pauses the simulation.
     */
    pause() {
        this.isPaused = true
    }

    /**
     * Resumes the simulation.
     */
    resume() {
        let me = this;

        if (me.isPaused) {
            me.isPaused = false;
            me.renderLoop()
        }
    }

    /**
     * @member {Function} renderLoop=this.render.bind(this)
     */
    renderLoop = this.render.bind(this)

    /**
     * Main simulation and render loop.
     * Executed ~60 times per second.
     */
    render() {
        let me = this;

        if (!me.context || me.isPaused) {
            return
        }

        const
            ctx    = me.context,
            width  = me.canvasSize?.width  || 100,
            height = me.canvasSize?.height || 50;

        me.time += 0.01;

        if (!me.nodeBuffer) me.initNodes(width, height);
        if (!me.agentBuffer) me.initAgents(width, height);
        if (!me.packetBuffer) me.initPackets();

        // Physics Update Steps
        me.updatePhysics(width, height);
        me.updateAgents(width, height);
        me.updatePackets();
        me.updateSparks();

        // Rendering Steps
        ctx.clearRect(0, 0, width, height);

        if (me.gradients.bgGradient) {
            ctx.fillStyle = me.gradients.bgGradient;
            ctx.fillRect(0, 0, width, height)
        }

        me.drawNetwork(ctx, width, height);
        me.drawPackets(ctx);
        me.drawAgents(ctx);
        me.drawShockwaves(ctx);
        me.drawSparks(ctx);

        setTimeout(me.renderLoop, 1000 / 60)
    }

    /**
     * Updates the local mouse state from main thread events.
     * Triggers shockwaves on click.
     * @param {Object} data
     * @param {Boolean} [data.click]
     * @param {Boolean} [data.leave]
     * @param {Number} [data.x]
     * @param {Number} [data.y]
     */
    updateMouseState(data) {
        let me = this;

        if (data.leave) {
            me.mouse.x = -1000;
            me.mouse.y = -1000
        } else {
            if (data.x !== undefined) me.mouse.x = data.x;
            if (data.y !== undefined) me.mouse.y = data.y;

            if (data.click) {
                me.shockwaves.push({
                    x        : data.x,
                    y        : data.y,
                    age      : 0,
                    maxAge   : 40, // Faster, punchier wave
                    maxRadius: 300
                });

                // Spawn Sparks (Data Debris)
                for(let i=0; i<40; i++) {
                    let angle = Math.random() * Math.PI * 2,
                        speed = Math.random() * 15 + 5; // Fast burst
                    me.sparks.push({
                        x    : data.x,
                        y    : data.y,
                        vx   : Math.cos(angle) * speed,
                        vy   : Math.sin(angle) * speed,
                        life : 1.0,
                        decay: 0.02 + Math.random() * 0.03
                    })
                }
            }
        }
    }

    /**
     * Updates packet logic (Data Flow).
     * Packets spawn randomly at child nodes and travel to their parent nodes,
     * representing data reporting upstream.
     */
    updatePackets() {
        let me = this;
        if (!me.packetBuffer || !me.nodeBuffer) return;

        const
            packets = me.packetBuffer,
            nodes   = me.nodeBuffer,
            pCount  = PACKET_COUNT,
            nCount  = NODE_COUNT;

        for (let i = 0; i < pCount; i++) {
            let idx = i * PACKET_STRIDE,
                life = packets[idx + 4];

            if (life <= 0) {
                // Spawn new packet? (Random chance)
                if (Math.random() < 0.02) {
                    // Pick random node (source)
                    let n1 = Math.floor(Math.random() * nCount),
                        idx1 = n1 * NODE_STRIDE,
                        pid = nodes[idx1 + 6]; // Parent ID

                    // Valid targets: Parent (if child), or Child (if parent)
                    // Simplified: Just go Child -> Parent for now (Data reporting)
                    if (pid !== -1) { // If it's a child
                        let idx2 = pid * NODE_STRIDE,
                            x1   = nodes[idx1], y1 = nodes[idx1 + 1],
                            x2   = nodes[idx2], y2 = nodes[idx2 + 1],
                            dx   = x2 - x1,
                            dy   = y2 - y1,
                            dist = Math.sqrt(dx * dx + dy * dy);

                        // Only spawn if connected and close
                        if (dist < 200) {
                            packets[idx]     = x1;
                            packets[idx + 1] = y1;
                            let speed        = 4;
                            packets[idx + 2] = (dx / dist) * speed;
                            packets[idx + 3] = (dy / dist) * speed;
                            packets[idx + 4] = dist / speed // Life = frames to reach target
                        }
                    }
                }
            } else {
                // Move
                packets[idx]     += packets[idx + 2];
                packets[idx + 1] += packets[idx + 3];
                packets[idx + 4]-- // Decrease life
            }
        }
    }

    /**
     * Updates spark particles with friction and decay.
     */
    updateSparks() {
        let me = this;
        for (let i = me.sparks.length - 1; i >= 0; i--) {
            let s = me.sparks[i];
            s.x += s.vx;
            s.y += s.vy;
            // Friction (Drag)
            s.vx *= 0.9;
            s.vy *= 0.9;
            s.life -= s.decay;
            if (s.life <= 0) {
                me.sparks.splice(i, 1)
            }
        }
    }

    /**
     * Updates agent positions using **Boid** logic (Seek, Separate).
     * Agents randomly pick a target node, seek it, scan it (transferring energy),
     * and then pick a new target. They also avoid the mouse cursor.
     * @param {Number} width
     * @param {Number} height
     */
    updateAgents(width, height) {
        let me = this;

        if (!me.agentBuffer || !me.nodeBuffer) return;

        const
            agents = me.agentBuffer,
            nodes  = me.nodeBuffer,
            count  = AGENT_COUNT,
            mx     = me.mouse.x,
            my     = me.mouse.y;

        for (let i = 0; i < count; i++) {
            let idx = i * AGENT_STRIDE,
                targetIdx = agents[idx + 4],
                state = agents[idx + 5];

            // Behavior 1: Pick a Target
            if (targetIdx === -1 || Math.random() < 0.005) {
                const parentCount = Math.floor(NODE_COUNT * 0.1);
                agents[idx + 4] = Math.floor(Math.random() * parentCount);
                targetIdx = agents[idx + 4];
                agents[idx + 5] = 0;
            }

            // Behavior 2: Seek Target
            if (targetIdx !== -1 && state === 0) {
                let nIdx = targetIdx * NODE_STRIDE,
                    tx   = nodes[nIdx],
                    ty   = nodes[nIdx + 1],
                    dx   = tx - agents[idx],
                    dy   = ty - agents[idx + 1],
                    dist = Math.sqrt(dx*dx + dy*dy);

                if (dist < 10) {
                    // Arrived! Scan.
                    agents[idx + 5] = 1; // Scan state
                    agents[idx + 2] *= 0.1; // Slow down
                    agents[idx + 3] *= 0.1;

                    // Transfer Energy to Node
                    nodes[nIdx + 8] = 1.0;
                } else {
                    // Steer towards target
                    let force = 0.05;
                    agents[idx + 2] += (dx / dist) * force;
                    agents[idx + 3] += (dy / dist) * force;
                }
            } else if (state === 1) {
                if (Math.random() < 0.02) {
                    agents[idx + 4] = -1;
                    agents[idx + 5] = 0;
                    agents[idx + 2] += (Math.random() - 0.5) * 4;
                    agents[idx + 3] += (Math.random() - 0.5) * 4;
                }
            }

            // Behavior 3: Mouse Repulsion
            if (mx !== -1000) {
                let dx = agents[idx] - mx,
                    dy = agents[idx + 1] - my,
                    distSq = dx*dx + dy*dy;

                if (distSq < 10000) {
                    let dist  = Math.sqrt(distSq),
                        force = (100 - dist) / 100;
                    agents[idx + 2] += (dx / dist) * force * 1.5;
                    agents[idx + 3] += (dy / dist) * force * 1.5;
                    agents[idx + 5] = 0
                }
            }

            // Speed Limit & Move
            let speed = Math.sqrt(agents[idx + 2]**2 + agents[idx + 3]**2);
            if (speed > 4) {
                agents[idx + 2] *= 4 / speed;
                agents[idx + 3] *= 4 / speed
            }

            agents[idx]     += agents[idx + 2];
            agents[idx + 1] += agents[idx + 3];

            if (agents[idx] < 0) agents[idx] = width;
            if (agents[idx] > width) agents[idx] = 0;
            if (agents[idx + 1] < 0) agents[idx + 1] = height;
            if (agents[idx + 1] > height) agents[idx + 1] = 0;
        }
    }

    /**
     * Updates node positions using **Cluster Physics**.
     * Handles:
     * 1.  **Cohesion:** Children stick to parents.
     * 2.  **Flow Fields:** Parents drift in organic patterns.
     * 3.  **Topology Mutation:** Nodes can detach and re-parent.
     * 4.  **Interaction:** Mouse repulsion and shockwave explosion.
     * @param {Number} width
     * @param {Number} height
     */
    updatePhysics(width, height) {
        let me = this;

        if (!me.nodeBuffer) return;

        const
            buffer      = me.nodeBuffer,
            mx          = me.mouse.x,
            my          = me.mouse.y,
            parentCount = Math.floor(NODE_COUNT * 0.1);

        for (let i = 0; i < NODE_COUNT; i++) {
            let idx = i * NODE_STRIDE,
                parentId = buffer[idx + 6],
                isParent = parentId === -1;

            // --- MUTATION LOGIC (Re-Parenting) ---
            if (!isParent) {
                // 1. Chance to detach (becomes Drifting: -2)
                if (parentId !== -2 && Math.random() < 0.0005) { // Rare event
                    buffer[idx + 6] = -2;
                    // Boost velocity to escape
                    buffer[idx + 2] += (Math.random() - 0.5) * 2;
                    buffer[idx + 3] += (Math.random() - 0.5) * 2
                }

                // 2. Re-attach Logic (if Drifting)
                if (parentId === -2) {
                    // Wander behavior
                    buffer[idx + 2] += (Math.random() - 0.5) * 0.1;
                    buffer[idx + 3] += (Math.random() - 0.5) * 0.1;

                    // Check for new parent
                    for (let p = 0; p < parentCount; p++) {
                        let pIdx = p * NODE_STRIDE,
                            px   = buffer[pIdx],
                            py   = buffer[pIdx + 1],
                            dist = Math.sqrt((px - buffer[idx])**2 + (py - buffer[idx + 1])**2);

                        if (dist < 60) {
                            buffer[idx + 6] = p; // Snap to new parent
                            break
                        }
                    }
                }
            }

            // 1. Cluster Cohesion (Children stick to Parent)
            if (!isParent && buffer[idx + 6] !== -2) { // Normal Child
                let pIdx = parentId * NODE_STRIDE,
                    px   = buffer[pIdx],
                    py   = buffer[pIdx + 1],
                    dx   = px - buffer[idx],
                    dy   = py - buffer[idx + 1],
                    dist = Math.sqrt(dx*dx + dy*dy);

                // Spring force towards parent
                if (dist > 50) { // Ideal distance
                    let force = (dist - 50) * 0.0005;
                    buffer[idx + 2] += dx * force;
                    buffer[idx + 3] += dy * force
                }
            }

            // 2. Mouse Repulsion (All nodes)
            if (mx !== -1000) {
                let dx     = buffer[idx] - mx,
                    dy     = buffer[idx + 1] - my,
                    distSq = dx * dx + dy * dy;

                if (distSq < 22500) {
                    let dist  = Math.sqrt(distSq),
                        force = (150 - dist) / 150;
                    buffer[idx + 2] += (dx / dist) * force * 0.5;
                    buffer[idx + 3] += (dy / dist) * force * 0.5
                }
            }

            // 3. Shockwave Repulsion (Explosive Force)
            if (me.shockwaves.length > 0) {
                me.shockwaves.forEach(wave => {
                    let progress = wave.age / wave.maxAge;

                    if (progress < 1) {
                        let eased = 1 - Math.pow(1 - progress, 3),
                            wRad  = eased * wave.maxRadius,
                            dx    = buffer[idx] - wave.x,
                            dy    = buffer[idx + 1] - wave.y,
                            dist  = Math.sqrt(dx*dx + dy*dy);

                        // Hit the "Wave Front" (Width matches visual ring ~20px)
                        if (Math.abs(dist - wRad) < 20) {
                            let force = (1 - progress);
                            // Massive Impulse (Throwing)
                            buffer[idx + 2] += (dx / dist) * force * 10;
                            buffer[idx + 3] += (dy / dist) * force * 10
                        }
                    }
                });
            }

            // 4. Physics
            buffer[idx + 2] *= 0.95; // Friction
            buffer[idx + 3] *= 0.95;

            // Energy Decay
            buffer[idx + 8] *= 0.99;

            let drift = isParent ? 0.02 : 0.01;

            // 4. Ambient Drift / Flow Field
            if (isParent) {
                // FLOW FIELD for Parents: Create organic currents
                // Combine Sine/Cosine based on position and time
                let angle = (Math.cos(buffer[idx]     * 0.002 + me.time * 0.5) +
                             Math.sin(buffer[idx + 1] * 0.002 + me.time * 0.5)) * Math.PI;

                // Accelerate in flow direction
                buffer[idx + 2] += Math.cos(angle) * 0.05;
                buffer[idx + 3] += Math.sin(angle) * 0.05;

                // CONTAINMENT FIELD (Fix for Drift Bias)
                // Gently push nodes back to center if they wander too far
                let cx    = width / 2,
                    cy    = height / 2,
                    dx    = cx - buffer[idx],
                    dy    = cy - buffer[idx + 1],
                    dist  = Math.sqrt(dx * dx + dy * dy),
                    limit = Math.min(width, height) * 0.4; // Keep within 80% of screen center

                if (dist > limit) {
                    let force = (dist - limit) * 0.001; // Soft spring
                    buffer[idx + 2] += (dx / dist) * force;
                    buffer[idx + 3] += (dy / dist) * force
                }
            } else {
                // Random wander for children
                if (Math.abs(buffer[idx + 2]) < 0.2) buffer[idx + 2] += (Math.random() - 0.5) * 0.02;
                if (Math.abs(buffer[idx + 3]) < 0.2) buffer[idx + 3] += (Math.random() - 0.5) * 0.02
            }

            buffer[idx]     += buffer[idx + 2];
            buffer[idx + 1] += buffer[idx + 3];

            // Bounce
            const pad = 20;
            if (buffer[idx] < pad)              { buffer[idx] = pad; buffer[idx + 2] *= -1; }
            if (buffer[idx] > width - pad)      { buffer[idx] = width - pad; buffer[idx + 2] *= -1; }
            if (buffer[idx + 1] < pad)          { buffer[idx + 1] = pad; buffer[idx + 3] *= -1; }
            if (buffer[idx + 1] > height - pad) { buffer[idx + 1] = height - pad; buffer[idx + 3] *= -1; }
        }
    }

    /**
     * Creates and caches gradients.
     * @param {Number} width
     * @param {Number} height
     */
    updateResources(width, height) {
        let me  = this,
            ctx = me.context;

        if (!ctx) return;

        const gradient = ctx.createLinearGradient(0, 0, width, height);
        gradient.addColorStop(0, 'rgba(62, 99, 221, 0.05)'); // PRIMARY low alpha
        gradient.addColorStop(1, 'rgba(139, 166, 255, 0.05)'); // SECONDARY low alpha

        me.gradients.bgGradient = gradient
    }

    /**
     * @param {Object} size
     * @param {Number} size.height
     * @param {Number} size.width
     */
    updateSize(size) {
        let me = this;

        me.canvasSize = size;

        if (me.context) {
            me.context.canvas.width  = size.width;
            me.context.canvas.height = size.height;
            // FIX: Always re-init nodes on resize to fix "top-left blob" issue
            me.initNodes(size.width, size.height);
            me.initAgents(size.width, size.height);
            me.updateResources(size.width, size.height)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(HomeCanvas));


/***/ }

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2NhbnZhcy92ZW5kb3JzLWFwcHNfcG9ydGFsX2NhbnZhc19Ib21lQ2FudmFzX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUE4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMERBQUk7QUFDN0I7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0NBQXdDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FB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QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw2REFBNkQ7QUFDN0QsK0RBQStEOztBQUUvRDtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLDBCQUEwQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvcG9ydGFsL2NhbnZhcy9Ib21lQ2FudmFzLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZSBmcm9tICcuLi8uLi8uLi9zcmMvY29yZS9CYXNlLm1qcyc7XG5cbmNvbnN0XG4gICAgUFJJTUFSWSAgICAgICAgICA9ICcjM0U2M0REJyxcbiAgICBTRUNPTkRBUlkgICAgICAgID0gJyM4QkE2RkYnLFxuICAgIEhJR0hMSUdIVCAgICAgICAgPSAnIzAwQkZGRicsIC8vIERlZXAgU2t5IEJsdWUgKEhpZ2ggQ29udHJhc3QpXG4gICAgU1BBUktfQ09MT1IgICAgICA9ICcjNEIwMDgyJywgLy8gSW5kaWdvXG4gICAgQ09OTkVDVElPTl9DT0xPUiA9ICcjODA4MDgwJyxcbiAgICBOT0RFX0NPVU5UICAgICAgID0gMTUwLFxuICAgIE5PREVfU1RSSURFICAgICAgPSA5LCAvLyB4LCB5LCB2eCwgdnksIHJhZGl1cywgbGF5ZXIsIHBhcmVudElkLCBwaGFzZSwgZW5lcmd5XG4gICAgQUdFTlRfQ09VTlQgICAgICA9IDIwLFxuICAgIEFHRU5UX1NUUklERSAgICAgPSA2LCAvLyB4LCB5LCB2eCwgdnksIHRhcmdldElkeCwgc3RhdGVcbiAgICBQQUNLRVRfQ09VTlQgICAgID0gMjAsXG4gICAgUEFDS0VUX1NUUklERSAgICA9IDU7IC8vIHgsIHksIHZ4LCB2eSwgbGlmZSAoMC0xKVxuXG4vKipcbiAqIEBzdW1tYXJ5IFNoYXJlZFdvcmtlciByZW5kZXJlciBmb3IgdGhlIFBvcnRhbCBIb21lIFwiTmV1cmFsIFN3YXJtXCIgYmFja2dyb3VuZC5cbiAqXG4gKiBJbXBsZW1lbnRzIHRoZSAqKlwiTmV1cmFsIFN3YXJtXCIqKiB2aXN1YWwgdGhlbWUsIGEgZHluYW1pYywgbXV0YWJsZSBuZXR3b3JrIHNpbXVsYXRpb24gdGhhdFxuICogdmlzdWFsaXplcyB0aGUgTmVvLm1qcyBBcHBsaWNhdGlvbiBFbmdpbmUgYXMgYSBsaXZpbmcgZWNvc3lzdGVtLlxuICpcbiAqICoqVmlzdWFsIEFyY2hpdGVjdHVyZToqKlxuICogMS4gKipMaXZpbmcgVG9wb2xvZ3kgKFRoZSBHcmFwaCk6KiogTm9kZXMgYXJlIG5vdCBzdGF0aWM7IHRoZXkgZm9ybSBoaWVyYXJjaGljYWwgY2x1c3RlcnMgcmVwcmVzZW50aW5nXG4gKiAgICBDb21wb25lbnRzIHdpdGhpbiBDb250YWluZXJzLiBUaGUgdG9wb2xvZ3kgaXMgbXV0YWJsZSwgd2l0aCBzdWItY2x1c3RlcnMgb2NjYXNpb25hbGx5IGRldGFjaGluZyxcbiAqICogICAgZHJpZnRpbmcsIGFuZCByZS1wYXJlbnRpbmcgKFZpc3VhbGl6aW5nIFwiQXRvbWljIE1vdmVzXCIpLlxuICogMi4gKipBdXRvbm9tb3VzIEFnZW50cyAoVGhlIE5ldXJhbCBMaW5rKToqKiBcIlNlZWtlciBEcm9uZXNcIiByb2FtIHRoZSBncmFwaCB1c2luZyBCb2lkIGJlaGF2aW9yXG4gKiAgICAoU2VwYXJhdGlvbiwgQWxpZ25tZW50LCBDb2hlc2lvbikuIFRoZXkgXCJzY2FuXCIgbm9kZXMsIHRyYW5zZmVycmluZyBlbmVyZ3kgYW5kIHRyaWdnZXJpbmdcbiAqICAgIHZpc3VhbCBoaWdobGlnaHRzLCByZXByZXNlbnRpbmcgdGhlIGFjdGl2ZSBpbnRlbGxpZ2VuY2Ugb2YgdGhlIGZyYW1ld29yay5cbiAqIDMuICoqRGF0YSBGbG93IChTaWduYWwgUGFja2V0cyk6KiogUHVsc2VzIG9mIGxpZ2h0IHRyYXZlbCBhbG9uZyBjb25uZWN0aW9ucyBmcm9tIGNoaWxkIHRvIHBhcmVudCxcbiAqICAgIHZpc3VhbGl6aW5nIHRoZSBmbG93IG9mIGV2ZW50cyBhbmQgZGF0YSB1cHN0cmVhbS5cbiAqIDQuICoqQXRtb3NwaGVyZSAoUGFyYWxsYXgpOioqIEEgbXVsdGktbGF5ZXJlZCBkZXB0aCBzeXN0ZW0gY3JlYXRlcyBhIHZvbHVtZXRyaWMgZmVlbCwgZGlzdGluZ3Vpc2hpbmdcbiAqICAgIGZvcmVncm91bmQgXCJhY3RpdmVcIiBub2RlcyBmcm9tIGJhY2tncm91bmQgXCJjb250ZXh0XCIgbm9kZXMuXG4gKlxuICogKipQZXJmb3JtYW5jZSBBcmNoaXRlY3R1cmUgKFplcm8tQWxsb2NhdGlvbik6KipcbiAqIFRvIG1haW50YWluIDYwZnBzIG9uIGhpZ2gtcmVmcmVzaCBkaXNwbGF5cyB3aXRob3V0IEdDIHN0dXR0ZXJzLCB0aGlzIGNsYXNzIGVtcGxveXMgYSAqKlplcm8tQWxsb2NhdGlvbioqIHN0cmF0ZWd5IGR1cmluZyB0aGUgcmVuZGVyIGxvb3AuXG4gKiAxLiAqKlR5cGVkQXJyYXkgQnVmZmVyczoqKiBBbGwgZW50aXR5IGRhdGEgKE5vZGVzLCBBZ2VudHMsIFBhY2tldHMpIGlzIHN0b3JlZCBpbiBwcmUtYWxsb2NhdGVkIGBGbG9hdDMyQXJyYXlgIGJ1ZmZlcnMuXG4gKiAyLiAqKklubGluZWQgUGh5c2ljczoqKiBWZWN0b3IgY2FsY3VsYXRpb25zIGFyZSBwZXJmb3JtZWQgaW5saW5lIHdpdGhvdXQgY3JlYXRpbmcgdGVtcG9yYXJ5IE9iamVjdHMuXG4gKiAzLiAqKkdyYWRpZW50IENhY2hpbmc6KiogQ2FudmFzR3JhZGllbnRzIGFyZSBjcmVhdGVkIG9ubHkgb24gcmVzaXplIChgdXBkYXRlUmVzb3VyY2VzYCkgYW5kIGNhY2hlZC5cbiAqXG4gKiAqKk5vZGUgQnVmZmVyIExheW91dCAoRmxvYXQzMkFycmF5KToqKlxuICogLSAwOiB4IChQb3NpdGlvbiBYKVxuICogLSAxOiB5IChQb3NpdGlvbiBZKVxuICogLSAyOiB2eCAoVmVsb2NpdHkgWClcbiAqIC0gMzogdnkgKFZlbG9jaXR5IFkpXG4gKiAtIDQ6IHJhZGl1cyAoVmlzdWFsIHNpemUpXG4gKiAtIDU6IGxheWVyIChQYXJhbGxheCBkZXB0aDogMD1iYWNrLCAxPW1pZCwgMj1mcm9udClcbiAqIC0gNjogcGFyZW50SWQgKEluZGV4IG9mIHBhcmVudCBub2RlLCAtMSBpZiBwYXJlbnQsIC0yIGlmIGRyaWZ0aW5nKVxuICogLSA3OiBwaGFzZSAoQW5pbWF0aW9uIG9mZnNldCBmb3IgYnJlYXRoaW5nKVxuICogLSA4OiBlbmVyZ3kgKEludGVyYWN0aW9uIHN0YXRlLCAwLTEpXG4gKlxuICogKipBZ2VudCBCdWZmZXIgTGF5b3V0IChGbG9hdDMyQXJyYXkpOioqXG4gKiAtIDA6IHhcbiAqIC0gMTogeVxuICogLSAyOiB2eFxuICogLSAzOiB2eVxuICogLSA0OiB0YXJnZXRJZHggKEluZGV4IG9mIHRhcmdldCBub2RlLCAtMSBpZiB3YW5kZXJpbmcpXG4gKiAtIDU6IHN0YXRlICgwPW1vdmluZywgMT1zY2FubmluZylcbiAqXG4gKiAqKlBhY2tldCBCdWZmZXIgTGF5b3V0IChGbG9hdDMyQXJyYXkpOioqXG4gKiAtIDA6IHhcbiAqIC0gMTogeVxuICogLSAyOiB2eFxuICogLSAzOiB2eVxuICogLSA0OiBsaWZlIChGcmFtZXMgcmVtYWluaW5nLCAwLTEgbm9ybWFsaXplZCBmb3IgYWxwaGEpXG4gKlxuICogQGNsYXNzIFBvcnRhbC5jYW52YXMuSG9tZUNhbnZhc1xuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICogQHNpbmdsZXRvblxuICovXG5jbGFzcyBIb21lQ2FudmFzIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdQb3J0YWwuY2FudmFzLkhvbWVDYW52YXMnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ1BvcnRhbC5jYW52YXMuSG9tZUNhbnZhcycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdGUgbWV0aG9kIGFjY2VzcyBmb3IgdGhlIEFwcCBXb3JrZXIuXG4gICAgICAgICAqIEFsbG93cyB0aGUgVUkgdG8gY29udHJvbCB0aGUgc2ltdWxhdGlvbiBzdGF0ZSBhbmQgaW5wdXQuXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gcmVtb3RlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHJlbW90ZToge1xuICAgICAgICAgICAgYXBwOiBbXG4gICAgICAgICAgICAgICAgJ2NsZWFyR3JhcGgnLFxuICAgICAgICAgICAgICAgICdpbml0R3JhcGgnLFxuICAgICAgICAgICAgICAgICdwYXVzZScsXG4gICAgICAgICAgICAgICAgJ3Jlc3VtZScsXG4gICAgICAgICAgICAgICAgJ3VwZGF0ZU1vdXNlU3RhdGUnLFxuICAgICAgICAgICAgICAgICd1cGRhdGVTaXplJ1xuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2luZ2xldG9uPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2luZ2xldG9uOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJlLWFsbG9jYXRlZCBidWZmZXIgZm9yIGFnZW50IGRhdGEgKFNlZWtlciBEcm9uZXMpLlxuICAgICAqIEBtZW1iZXIge0Zsb2F0MzJBcnJheXxudWxsfSBhZ2VudEJ1ZmZlcj1udWxsXG4gICAgICovXG4gICAgYWdlbnRCdWZmZXIgPSBudWxsXG4gICAgLyoqXG4gICAgICogSUQgb2YgdGhlIGNhbnZhcyBlbGVtZW50IGluIHRoZSBET00uXG4gICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGNhbnZhc0lkPW51bGxcbiAgICAgKi9cbiAgICBjYW52YXNJZCA9IG51bGxcbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGRpbWVuc2lvbnMgb2YgdGhlIGNhbnZhcy5cbiAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gY2FudmFzU2l6ZT1udWxsXG4gICAgICovXG4gICAgY2FudmFzU2l6ZSA9IG51bGxcbiAgICAvKipcbiAgICAgKiBUaGUgMkQgcmVuZGVyaW5nIGNvbnRleHQuXG4gICAgICogQG1lbWJlciB7T2Zmc2NyZWVuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfG51bGx9IGNvbnRleHQ9bnVsbFxuICAgICAqL1xuICAgIGNvbnRleHQgPSBudWxsXG4gICAgLyoqXG4gICAgICogQ2FjaGUgZm9yIHJldXNhYmxlIGdyYWRpZW50cyB0byBwcmV2ZW50IEdDLlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gZ3JhZGllbnRzPXt9XG4gICAgICovXG4gICAgZ3JhZGllbnRzID0ge31cbiAgICAvKipcbiAgICAgKiBGbGFnIHRvIHBhdXNlIHRoZSByZW5kZXIgbG9vcC5cbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc1BhdXNlZD1mYWxzZVxuICAgICAqL1xuICAgIGlzUGF1c2VkID0gZmFsc2VcbiAgICAvKipcbiAgICAgKiBUcmFja2VkIG1vdXNlIHBvc2l0aW9uIGZvciBpbnRlcmFjdGl2ZSBwaHlzaWNzLlxuICAgICAqIEluaXRpYWxpemUgb2ZmLXNjcmVlbiB0byBwcmV2ZW50IHN0YXJ0dXAgaml0dGVycy5cbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vdXNlPXt4OiAtMTAwMCwgeTogLTEwMDB9XG4gICAgICovXG4gICAgbW91c2UgPSB7eDogLTEwMDAsIHk6IC0xMDAwfVxuICAgIC8qKlxuICAgICAqIFByZS1hbGxvY2F0ZWQgYnVmZmVyIGZvciBub2RlIGRhdGEgKFRoZSBHcmFwaCkuXG4gICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fG51bGx9IG5vZGVCdWZmZXI9bnVsbFxuICAgICAqL1xuICAgIG5vZGVCdWZmZXIgPSBudWxsXG4gICAgLyoqXG4gICAgICogUHJlLWFsbG9jYXRlZCBidWZmZXIgZm9yIGRhdGEgcGFja2V0cyAoU2lnbmFsIFB1bHNlcykuXG4gICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fG51bGx9IHBhY2tldEJ1ZmZlcj1udWxsXG4gICAgICovXG4gICAgcGFja2V0QnVmZmVyID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEFjdGl2ZSBzaG9ja3dhdmUgZWZmZWN0cy5cbiAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gc2hvY2t3YXZlcz1bXVxuICAgICAqL1xuICAgIHNob2Nrd2F2ZXMgPSBbXVxuICAgIC8qKlxuICAgICAqIEFjdGl2ZSBzcGFyayBwYXJ0aWNsZXMgKERhdGEgRGVicmlzKS5cbiAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gc3BhcmtzPVtdXG4gICAgICovXG4gICAgc3BhcmtzID0gW11cbiAgICAvKipcbiAgICAgKiBHbG9iYWwgc2ltdWxhdGlvbiB0aW1lLCB1c2VkIGZvciBwcm9jZWR1cmFsIGFuaW1hdGlvbnMuXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSB0aW1lPTBcbiAgICAgKi9cbiAgICB0aW1lID0gMFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBncmFwaCBzdGF0ZSBhbmQgc3RvcHMgdGhlIHJlbmRlciBsb29wLlxuICAgICAqIFVzZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGRlc3Ryb3llZCBvciB0aGUgcm91dGUgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBjbGVhckdyYXBoKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuICAgICAgICBtZS5jb250ZXh0ICAgICAgPSBudWxsO1xuICAgICAgICBtZS5jYW52YXNJZCAgICAgPSBudWxsO1xuICAgICAgICBtZS5jYW52YXNTaXplICAgPSBudWxsO1xuICAgICAgICBtZS5ub2RlQnVmZmVyICAgPSBudWxsO1xuICAgICAgICBtZS5hZ2VudEJ1ZmZlciAgPSBudWxsO1xuICAgICAgICBtZS5wYWNrZXRCdWZmZXIgPSBudWxsO1xuICAgICAgICBtZS5zaG9ja3dhdmVzICAgPSBbXTtcbiAgICAgICAgbWUuc3BhcmtzICAgICAgID0gW107XG4gICAgICAgIG1lLmlzUGF1c2VkICAgICA9IGZhbHNlO1xuICAgICAgICBtZS5ncmFkaWVudHMgICAgPSB7fVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYXdzIHRoZSBhdXRvbm9tb3VzIGFnZW50cyAoU2Vla2VyIERyb25lcykuXG4gICAgICpcbiAgICAgKiAqKlZpc3VhbHM6KipcbiAgICAgKiAtICoqSGVhZDoqKiBBIHNvbGlkIGNpcmNsZSBpbmRpY2F0aW5nIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICogLSAqKlRyYWlsOioqIEEgZmFkaW5nIGxpbmUgZHJhd24gb3Bwb3NpdGUgdG8gdmVsb2NpdHksIHNpbXVsYXRpbmcgbW90aW9uIGJsdXIuXG4gICAgICogLSAqKlNjYW4gRWZmZWN0OioqIEEgcHVsc2luZyByaW5nIHdoZW4gdGhlIGFnZW50IHJlYWNoZXMgYSBub2RlIChzdGF0ZT0xKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKi9cbiAgICBkcmF3QWdlbnRzKGN0eCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUuYWdlbnRCdWZmZXIpIHJldHVybjtcblxuICAgICAgICBjb25zdFxuICAgICAgICAgICAgYnVmZmVyID0gbWUuYWdlbnRCdWZmZXIsXG4gICAgICAgICAgICBjb3VudCAgPSBBR0VOVF9DT1VOVDtcblxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBISUdITElHSFQ7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgICA9ICcjRkZGRkZGJztcbiAgICAgICAgY3R4LmxpbmVDYXAgICAgID0gJ3JvdW5kJztcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpZHggICA9IGkgKiBBR0VOVF9TVFJJREUsXG4gICAgICAgICAgICAgICAgeCAgICAgPSBidWZmZXJbaWR4XSxcbiAgICAgICAgICAgICAgICB5ICAgICA9IGJ1ZmZlcltpZHggKyAxXSxcbiAgICAgICAgICAgICAgICB2eCAgICA9IGJ1ZmZlcltpZHggKyAyXSxcbiAgICAgICAgICAgICAgICB2eSAgICA9IGJ1ZmZlcltpZHggKyAzXSxcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IGJ1ZmZlcltpZHggKyA1XTtcblxuICAgICAgICAgICAgLy8gMS4gRHJhdyBUcmFpbCAoTW90aW9uIEJsdXIpXG4gICAgICAgICAgICBsZXQgc3BlZWQgPSBNYXRoLnNxcnQodngqdnggKyB2eSp2eSk7XG5cbiAgICAgICAgICAgIGlmIChzcGVlZCA+IDAuMSkge1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMjtcbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjY7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHggLSB2eCAqIDQsIHkgLSB2eSAqIDQpO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAyLiBEcmF3IEhlYWRcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHN0YXRlID09PSAxID8gMSA6IDAuODtcbiAgICAgICAgICAgIGxldCByYWRpdXMgPSBzdGF0ZSA9PT0gMSA/IDMgOiAyO1xuICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG5cbiAgICAgICAgICAgIC8vIDMuIFNjYW4gRWZmZWN0XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC4zO1xuICAgICAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgOCArIE1hdGguc2luKG1lLnRpbWUgKiAxMCkgKiAyLCAwLCBNYXRoLlBJICogMik7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIG5ldXJhbCBuZXR3b3JrIChub2RlcyBhbmQgY29ubmVjdGlvbnMpLlxuICAgICAqXG4gICAgICogKipJbnRlbnQ6KipcbiAgICAgKiBWaXN1YWxpemVzIHRoZSBcIkFwcGxpY2F0aW9uIEdyYXBoXCIuXG4gICAgICogLSAqKlBhcmFsbGF4OioqIEFwcGxpZXMgZGVwdGgtYmFzZWQgZGlzcGxhY2VtZW50IGJhc2VkIG9uIG1vdXNlIHBvc2l0aW9uLlxuICAgICAqIC0gKipDb25uZWN0aW9uczoqKiBMaW5lcyBhcmUgZHJhd24gb25seSBiZXR3ZWVuIHJlbGF0ZWQgbm9kZXMgKFBhcmVudC1DaGlsZCBvciBTaWJsaW5ncykuXG4gICAgICogICBMaW5lcyB0aGlja2VuIGFuZCBicmlnaHRlbiB3aGVuIG5lYXIgdGhlIG1vdXNlLlxuICAgICAqIC0gKipOb2RlczoqKiBDaXJjbGVzIGJyZWF0aGluZyBpbiBzaXplLiBDb2xvcnMgaW5kaWNhdGUgZGVwdGggKExheWVyKSBhbmQgZW5lcmd5IHN0YXRlLlxuICAgICAqXG4gICAgICogKipPcHRpbWl6YXRpb246KipcbiAgICAgKiBVc2VzIGlubGluZWQgbWF0aCBmb3IgcGFyYWxsYXggY2FsY3VsYXRpb25zIHRvIGF2b2lkIGFsbG9jYXRpbmcgdGhvdXNhbmRzIG9mIGB7eCx5fWAgb2JqZWN0cyBwZXIgZnJhbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqL1xuICAgIGRyYXdOZXR3b3JrKGN0eCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUubm9kZUJ1ZmZlcikgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBidWZmZXIgPSBtZS5ub2RlQnVmZmVyLFxuICAgICAgICAgICAgY291bnQgID0gTk9ERV9DT1VOVCxcbiAgICAgICAgICAgIG14ICAgICA9IG1lLm1vdXNlLngsXG4gICAgICAgICAgICBteSAgICAgPSBtZS5tb3VzZS55LFxuICAgICAgICAgICAgY3ggICAgID0gd2lkdGggLyAyLFxuICAgICAgICAgICAgY3kgICAgID0gaGVpZ2h0IC8gMjtcblxuICAgICAgICBjdHgubGluZVdpZHRoID0gMTtcblxuICAgICAgICAvLyAxLiBEcmF3IENvbm5lY3Rpb25zXG4gICAgICAgIC8vIEl0ZXJhdGVzIGFsbCB1bmlxdWUgcGFpcnMgdG8gZHJhdyBsaW5lcyBiZXR3ZWVuIGNvbm5lY3RlZCBub2Rlcy5cbiAgICAgICAgLy8gQ29ubmVjdGlvbnMgYXJlIGRyYXduIGlmIG5vZGVzIHNoYXJlIGEgcGFyZW50IChzaWJsaW5ncykgb3IgYXJlIHBhcmVudC1jaGlsZC5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaWR4ICA9IGkgKiBOT0RFX1NUUklERSxcbiAgICAgICAgICAgICAgICBsMSAgID0gYnVmZmVyW2lkeCArIDVdLFxuICAgICAgICAgICAgICAgIHBpZDEgPSBidWZmZXJbaWR4ICsgNl0sXG4gICAgICAgICAgICAgICAgLy8gSW5saW5lIGdldFBvcyBsb2dpYyBmb3IgcDEgdG8gYXZvaWQgR0NcbiAgICAgICAgICAgICAgICBmMSAgID0gbDEgPT09IDIgPyAwLjA1IDogKGwxID09PSAxID8gMC4wMiA6IDAuMDEpLFxuICAgICAgICAgICAgICAgIGR4MSAgPSAobXggIT09IC0xMDAwID8gbXggLSBjeCA6IDApICogZjEsXG4gICAgICAgICAgICAgICAgZHkxICA9IChteSAhPT0gLTEwMDAgPyBteSAtIGN5IDogMCkgKiBmMSxcbiAgICAgICAgICAgICAgICBwMXggID0gYnVmZmVyW2lkeF0gKyBkeDEsXG4gICAgICAgICAgICAgICAgcDF5ICA9IGJ1ZmZlcltpZHggKyAxXSArIGR5MTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgY291bnQ7IGorKykge1xuICAgICAgICAgICAgICAgIGxldCBpZHgyID0gaiAqIE5PREVfU1RSSURFLFxuICAgICAgICAgICAgICAgICAgICBsMiAgID0gYnVmZmVyW2lkeDIgKyA1XSxcbiAgICAgICAgICAgICAgICAgICAgcGlkMiA9IGJ1ZmZlcltpZHgyICsgNl07XG5cbiAgICAgICAgICAgICAgICBjb25zdFxuICAgICAgICAgICAgICAgICAgICBzYW1lQ2x1c3RlciAgID0gcGlkMSA9PT0gcGlkMiAmJiBwaWQxICE9PSAtMSxcbiAgICAgICAgICAgICAgICAgICAgaXNQYXJlbnRDaGlsZCA9IChwaWQxID09PSBqKSB8fCAocGlkMiA9PT0gaSksXG4gICAgICAgICAgICAgICAgICAgIGlzQ2x1c3RlckxpbmsgPSAocGlkMSA9PT0gLTEgJiYgcGlkMiA9PT0gLTEpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFzYW1lQ2x1c3RlciAmJiAhaXNQYXJlbnRDaGlsZCAmJiAhaXNDbHVzdGVyTGluaykgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICBsZXQgZjIgICA9IGwyID09PSAyID8gMC4wNSA6IChsMiA9PT0gMSA/IDAuMDIgOiAwLjAxKSxcbiAgICAgICAgICAgICAgICAgICAgZHgyICA9IChteCAhPT0gLTEwMDAgPyBteCAtIGN4IDogMCkgKiBmMixcbiAgICAgICAgICAgICAgICAgICAgZHkyICA9IChteSAhPT0gLTEwMDAgPyBteSAtIGN5IDogMCkgKiBmMixcbiAgICAgICAgICAgICAgICAgICAgcDJ4ICA9IGJ1ZmZlcltpZHgyXSArIGR4MixcbiAgICAgICAgICAgICAgICAgICAgcDJ5ICA9IGJ1ZmZlcltpZHgyICsgMV0gKyBkeTIsXG4gICAgICAgICAgICAgICAgICAgIGR4ICAgPSBwMXggLSBwMngsXG4gICAgICAgICAgICAgICAgICAgIGR5ICAgPSBwMXkgLSBwMnksXG4gICAgICAgICAgICAgICAgICAgIGRpc3RTcSA9IGR4KmR4ICsgZHkqZHk7XG5cbiAgICAgICAgICAgICAgICAvLyBDdWxsaW5nOiBPbmx5IGRyYXcgY29ubmVjdGlvbnMgd2l0aGluIGEgY2VydGFpbiBkaXN0YW5jZVxuICAgICAgICAgICAgICAgIGlmIChkaXN0U3EgPCA0MDAwMCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGlzdCAgPSBNYXRoLnNxcnQoZGlzdFNxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhID0gMSAtIChkaXN0IC8gMjAwKTtcblxuICAgICAgICAgICAgICAgICAgICBhbHBoYSAqPSAoMC4yICsgKGwxICogMC4xKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IG1EeCA9IChwMXggKyBwMngpLzIgLSBteCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1EeSA9IChwMXkgKyBwMnkpLzIgLSBteSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1EaXN0U3EgPSBtRHgqbUR4ICsgbUR5Km1EeTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBNb3VzZSBJbnRlcmFjdGlvbjogSGlnaGxpZ2h0IGNvbm5lY3Rpb25zIG5lYXIgY3Vyc29yXG4gICAgICAgICAgICAgICAgICAgIGlmIChtRGlzdFNxIDwgMTAwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhID0gTWF0aC5taW4oYWxwaGEgKyAwLjUsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gSElHSExJR0hUO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCAgID0gMS41XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsMSA9PT0gMiA/IFBSSU1BUlkgOiBTRUNPTkRBUlk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbGFzdGljaXR5OiBUaGlja2VyIHdoZW4gY2xvc2VyIChUZW5zaW9uL1NsYWNrIHZpc3VhbGl6YXRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMC41ICsgKDEgLSAoZGlzdCAvIDIwMCkpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGFscGhhICogMC41O1xuICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHAxeCwgcDF5KTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhwMngsIHAyeSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDIuIERyYXcgTm9kZXNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaWR4ICAgICAgPSBpICogTk9ERV9TVFJJREUsXG4gICAgICAgICAgICAgICAgcmFkaXVzICAgPSBidWZmZXJbaWR4ICsgNF0sXG4gICAgICAgICAgICAgICAgbGF5ZXIgICAgPSBidWZmZXJbaWR4ICsgNV0sXG4gICAgICAgICAgICAgICAgcGFyZW50SWQgPSBidWZmZXJbaWR4ICsgNl0sXG4gICAgICAgICAgICAgICAgcGhhc2UgICAgPSBidWZmZXJbaWR4ICsgN10sXG4gICAgICAgICAgICAgICAgZW5lcmd5ICAgPSBidWZmZXJbaWR4ICsgOF0sXG4gICAgICAgICAgICAgICAgLy8gSW5saW5lIGdldFBvcyBsb2dpYyBmb3IgcG9zXG4gICAgICAgICAgICAgICAgZiAgICAgICAgPSBsYXllciA9PT0gMiA/IDAuMDUgOiAobGF5ZXIgPT09IDEgPyAwLjAyIDogMC4wMSksXG4gICAgICAgICAgICAgICAgcER4ICAgICAgPSAobXggIT09IC0xMDAwID8gbXggLSBjeCA6IDApICogZixcbiAgICAgICAgICAgICAgICBwRHkgICAgICA9IChteSAhPT0gLTEwMDAgPyBteSAtIGN5IDogMCkgKiBmLFxuICAgICAgICAgICAgICAgIHBvc1ggICAgID0gYnVmZmVyW2lkeF0gKyBwRHgsXG4gICAgICAgICAgICAgICAgcG9zWSAgICAgPSBidWZmZXJbaWR4ICsgMV0gKyBwRHksXG4gICAgICAgICAgICAgICAgZHggICAgICAgPSBwb3NYIC0gbXgsXG4gICAgICAgICAgICAgICAgZHkgICAgICAgPSBwb3NZIC0gbXksXG4gICAgICAgICAgICAgICAgZGlzdCAgICAgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpLFxuICAgICAgICAgICAgICAgIGlzSG92ZXIgID0gZGlzdCA8IDUwO1xuXG4gICAgICAgICAgICAvLyBTaG9ja3dhdmUgSW50ZXJhY3Rpb25cbiAgICAgICAgICAgIGlmIChtZS5zaG9ja3dhdmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBtZS5zaG9ja3dhdmVzLmZvckVhY2god2F2ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB3RGlzdCA9IE1hdGguc3FydCgocG9zWCAtIHdhdmUueCkqKjIgKyAocG9zWSAtIHdhdmUueSkqKjIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgd1JhZCAgPSB3YXZlLmFnZSAqIHdhdmUuc3BlZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyh3RGlzdCAtIHdSYWQpIDwgMjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzSG92ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGxldCByID0gcGFyZW50SWQgPT09IC0xID8gcmFkaXVzICogMS41IDogcmFkaXVzO1xuXG4gICAgICAgICAgICAvLyBCcmVhdGhpbmcgKyBFbmVyZ3lcbiAgICAgICAgICAgIHIgKj0gMSArIE1hdGguc2luKG1lLnRpbWUgKiAyICsgcGhhc2UpICogMC4xNSArIGVuZXJneTtcblxuICAgICAgICAgICAgaWYgKGlzSG92ZXIpIHtcbiAgICAgICAgICAgICAgICByICo9IDEuNTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4LmFyYyhwb3NYLCBwb3NZLCByLCAwLCBNYXRoLlBJICogMik7XG5cbiAgICAgICAgICAgIGlmIChlbmVyZ3kgPiAwLjEpIHtcbiAgICAgICAgICAgICAgICAvLyBFbmVyZ2V0aWMgTm9kZSAoQWdlbnQgU2Nhbm5lZClcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gSElHSExJR0hUO1xuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IE1hdGgubWluKDEsIDAuNSArIGVuZXJneSlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGF5ZXIgPT09IDIpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gaXNIb3ZlciA/ICcjRkZGRkZGJyA6IFBSSU1BUlk7XG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gaXNIb3ZlciA/IDEgOiAwLjhcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyZW50SWQgPT09IC0yKSB7XG4gICAgICAgICAgICAgICAgLy8gRHJpZnRpbmcgTm9kZSBWaXN1YWxcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gSElHSExJR0hUO1xuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuNiArIE1hdGguc2luKG1lLnRpbWUgKiAxMCArIHBoYXNlKSAqIDAuM1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsYXllciA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBpc0hvdmVyID8gSElHSExJR0hUIDogU0VDT05EQVJZO1xuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuNVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gQ09OTkVDVElPTl9DT0xPUjtcbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjJcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDFcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgZGF0YSBwYWNrZXRzIHRyYXZlbGluZyBhbG9uZyBjb25uZWN0aW9ucy5cbiAgICAgKiBQYWNrZXRzIHJlcHJlc2VudCBzaWduYWwgZmxvdyBiZXR3ZWVuIG5vZGVzLlxuICAgICAqIEBwYXJhbSB7T2Zmc2NyZWVuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKi9cbiAgICBkcmF3UGFja2V0cyhjdHgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIW1lLnBhY2tldEJ1ZmZlcikgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBidWZmZXIgPSBtZS5wYWNrZXRCdWZmZXIsXG4gICAgICAgICAgICBjb3VudCAgPSBQQUNLRVRfQ09VTlQ7XG5cbiAgICAgICAgY3R4LmZpbGxTdHlsZSAgID0gJyNGRkZGRkYnO1xuICAgICAgICBjdHguc2hhZG93Qmx1ciAgPSA1O1xuICAgICAgICBjdHguc2hhZG93Q29sb3IgPSBISUdITElHSFQ7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaWR4ICA9IGkgKiBQQUNLRVRfU1RSSURFLFxuICAgICAgICAgICAgICAgIGxpZmUgPSBidWZmZXJbaWR4ICsgNF07XG5cbiAgICAgICAgICAgIGlmIChsaWZlID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCB4ID0gYnVmZmVyW2lkeF0sXG4gICAgICAgICAgICAgICAgICAgIHkgPSBidWZmZXJbaWR4ICsgMV07XG5cbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gTWF0aC5taW4obGlmZSAqIDIsIDEpOyAvLyBGYWRlIG91dCBhdCBlbmRcbiAgICAgICAgICAgICAgICBjdHguYXJjKHgsIHksIDIsIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjdHguc2hhZG93Qmx1ciAgPSAwO1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgZXhwYW5kaW5nIHNob2Nrd2F2ZXMgZnJvbSBjbGlja3Mgd2l0aCBDaHJvbWF0aWMgQWJlcnJhdGlvbiBhbmQgQ29tcG9zaXRlIFJpbmdzLlxuICAgICAqIFVzZXMgb3B0aW1pemVkIFJHQkEgY29tcG9zaXRpb24gdG8gcmVkdWNlIEdDIHByZXNzdXJlLlxuICAgICAqIEBwYXJhbSB7T2Zmc2NyZWVuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKi9cbiAgICBkcmF3U2hvY2t3YXZlcyhjdHgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuc2hvY2t3YXZlcy5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgICAgICBjdHgubGluZUNhcCA9ICdyb3VuZCc7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IG1lLnNob2Nrd2F2ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB3YXZlID0gbWUuc2hvY2t3YXZlc1tpXTtcbiAgICAgICAgICAgIHdhdmUuYWdlKys7XG5cbiAgICAgICAgICAgIGxldCBwcm9ncmVzcyA9IHdhdmUuYWdlIC8gd2F2ZS5tYXhBZ2U7XG5cbiAgICAgICAgICAgIGlmIChwcm9ncmVzcyA+PSAxKSB7XG4gICAgICAgICAgICAgICAgbWUuc2hvY2t3YXZlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE5vbi1MaW5lYXIgRXhwYW5zaW9uIChFeHBsb3NpdmUgc3RhcnQsIHNsb3cgZmluaXNoKVxuICAgICAgICAgICAgbGV0IGVhc2VkID0gMSAtIE1hdGgucG93KDEgLSBwcm9ncmVzcywgMyksXG4gICAgICAgICAgICAgICAgcmFkaXVzID0gZWFzZWQgKiB3YXZlLm1heFJhZGl1cyxcbiAgICAgICAgICAgICAgICBhbHBoYSAgPSAxIC0gcHJvZ3Jlc3M7XG5cbiAgICAgICAgICAgIC8vIENocm9tYXRpYyBBYmVycmF0aW9uIChTaGlmdGVkIHRvIE5lb24gQmx1ZS9DeWFuIHRoZW1lKVxuXG4gICAgICAgICAgICAvLyAxLiBDeWFuIENoYW5uZWwgKExhZ2dpbmcgRnJpbmdlKSAtIFJlcGxhY2VzIFJlZFxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gSElHSExJR0hUO1xuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gYWxwaGEgKiAwLjg7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoICAgPSA0ICogKDEgLSBwcm9ncmVzcyk7XG4gICAgICAgICAgICBjdHguc2hhZG93Qmx1ciAgPSAxMDtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IEhJR0hMSUdIVDtcbiAgICAgICAgICAgIGN0eC5hcmMod2F2ZS54LCB3YXZlLnksIHJhZGl1cyAqIDAuOTksIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICAgICAgLy8gMi4gQmx1ZSBDaGFubmVsIChMZWFkaW5nIEZyaW5nZSlcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFBSSU1BUlk7XG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBhbHBoYSAqIDAuODtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggICA9IDQgKiAoMSAtIHByb2dyZXNzKTtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dCbHVyICA9IDEwO1xuICAgICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gUFJJTUFSWTtcbiAgICAgICAgICAgIGN0eC5hcmMod2F2ZS54LCB3YXZlLnksIHJhZGl1cyAqIDEuMDEsIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICAgICAgLy8gMy4gUHJpbWFyeSBXYXZlIChXaGl0ZSBIb3QgQ2VudGVyKVxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJyNGRkZGRkYnO1xuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gYWxwaGE7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoICAgPSA2ICogKDEgLSBwcm9ncmVzcyk7XG4gICAgICAgICAgICBjdHguc2hhZG93Qmx1ciAgPSAyMDtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9ICcjRkZGRkZGJztcbiAgICAgICAgICAgIGN0eC5hcmMod2F2ZS54LCB3YXZlLnksIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgICAgICAvLyA0LiBQcmVzc3VyZSBGaWxsIChSZWZyYWN0aW9uIEZha2UpXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gUFJJTUFSWTtcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGFscGhhICogMC4wNTtcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHguc2hhZG93Qmx1ciA9IDA7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDFcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0ZW1wb3Jhcnkgc3BhcmsgcGFydGljbGVzIChEYXRhIERlYnJpcykuXG4gICAgICogQHBhcmFtIHtPZmZzY3JlZW5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqL1xuICAgIGRyYXdTcGFya3MoY3R4KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLnNwYXJrcy5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBTUEFSS19DT0xPUjtcbiAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSAwOyAvLyBDcmlzcCBsaW5lcyBvbiB3aGl0ZVxuICAgICAgICBjdHgubGluZVdpZHRoID0gMjtcblxuICAgICAgICBmb3IgKGxldCBzIG9mIG1lLnNwYXJrcykge1xuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gcy5saWZlO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgLy8gRHJhdyBUcmFpbCBiYXNlZCBvbiB2ZWxvY2l0eVxuICAgICAgICAgICAgY3R4Lm1vdmVUbyhzLngsIHMueSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHMueCAtIHMudnggKiAyLCBzLnkgLSBzLnZ5ICogMik7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKClcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDFcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgYXV0b25vbW91cyBhZ2VudHMuXG4gICAgICogQWdlbnRzIHN0YXJ0IGF0IHJhbmRvbSBwb3NpdGlvbnMgd2l0aCByYW5kb20gaGlnaC12ZWxvY2l0eSB2ZWN0b3JzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgKi9cbiAgICBpbml0QWdlbnRzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIW1lLmFnZW50QnVmZmVyKSB7XG4gICAgICAgICAgICBtZS5hZ2VudEJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoQUdFTlRfQ09VTlQgKiBBR0VOVF9TVFJJREUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYnVmZmVyID0gbWUuYWdlbnRCdWZmZXI7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBBR0VOVF9DT1VOVDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaWR4ID0gaSAqIEFHRU5UX1NUUklERTtcblxuICAgICAgICAgICAgYnVmZmVyW2lkeF0gICAgID0gTWF0aC5yYW5kb20oKSAqIHdpZHRoOyAgLy8geFxuICAgICAgICAgICAgYnVmZmVyW2lkeCArIDFdID0gTWF0aC5yYW5kb20oKSAqIGhlaWdodDsgLy8geVxuICAgICAgICAgICAgYnVmZmVyW2lkeCArIDJdID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogNDsgLy8gdnggKEZhc3QhKVxuICAgICAgICAgICAgYnVmZmVyW2lkeCArIDNdID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogNDsgLy8gdnlcbiAgICAgICAgICAgIGJ1ZmZlcltpZHggKyA0XSA9IC0xOyAvLyB0YXJnZXRJZHggKG5vbmUpXG4gICAgICAgICAgICBidWZmZXJbaWR4ICsgNV0gPSAwICAgLy8gc3RhdGUgKG1vdmluZylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBjYW52YXMgY29udGV4dC5cbiAgICAgKiBDb25uZWN0cyB0byB0aGUgT2Zmc2NyZWVuQ2FudmFzIHRyYW5zZmVycmVkIGZyb20gdGhlIG1haW4gdGhyZWFkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdHMuY2FudmFzSWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy53aW5kb3dJZFxuICAgICAqL1xuICAgIGluaXRHcmFwaCh7Y2FudmFzSWQsIHdpbmRvd0lkfSkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGhhc0NoYW5nZSA9IG1lLmNhbnZhc0lkICE9PSBjYW52YXNJZDtcblxuICAgICAgICBtZS5jYW52YXNJZCA9IGNhbnZhc0lkO1xuXG4gICAgICAgIGNvbnN0IGNoZWNrQ2FudmFzID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2FudmFzID0gTmVvLmN1cnJlbnRXb3JrZXIuY2FudmFzV2luZG93TWFwW2NhbnZhc0lkXT8uW3dpbmRvd0lkXTtcblxuICAgICAgICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICAgICAgICAgIG1lLmNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgICAgICBtZS51cGRhdGVTaXplKHt3aWR0aDogY2FudmFzLndpZHRoLCBoZWlnaHQ6IGNhbnZhcy5oZWlnaHR9KTtcbiAgICAgICAgICAgICAgICBoYXNDaGFuZ2UgJiYgbWUucmVuZGVyTG9vcCgpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoY2hlY2tDYW52YXMsIDUwKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjaGVja0NhbnZhcygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIG5vZGUgYnVmZmVyIHVzaW5nICoqR29sZGVuIFNwaXJhbCoqIGRpc3RyaWJ1dGlvbi5cbiAgICAgKiBUaGlzIGVuc3VyZXMgYSB1bmlmb3JtIGJ1dCBvcmdhbmljLWxvb2tpbmcgZGlzdHJpYnV0aW9uIG9mIG5vZGVzIGFjcm9zcyB0aGUgc2NyZWVuLFxuICAgICAqIHByZXZlbnRpbmcgdGhlIFwiY2x1bXBpbmdcIiBzZWVuIHdpdGggcmFuZG9tIHBsYWNlbWVudC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAgICovXG4gICAgaW5pdE5vZGVzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIW1lLm5vZGVCdWZmZXIpIHtcbiAgICAgICAgICAgIG1lLm5vZGVCdWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KE5PREVfQ09VTlQgKiBOT0RFX1NUUklERSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdFxuICAgICAgICAgICAgYnVmZmVyICAgICAgICA9IG1lLm5vZGVCdWZmZXIsXG4gICAgICAgICAgICBjeCAgICAgICAgICAgID0gd2lkdGggLyAyLFxuICAgICAgICAgICAgY3kgICAgICAgICAgICA9IGhlaWdodCAvIDIsXG4gICAgICAgICAgICBwaGkgICAgICAgICAgID0gKDEgKyBNYXRoLnNxcnQoNSkpIC8gMixcbiAgICAgICAgICAgIHNjYWxlICAgICAgICAgPSBNYXRoLnNxcnQod2lkdGggKiBoZWlnaHQgLyBOT0RFX0NPVU5UKSAqIDAuOCxcbiAgICAgICAgICAgIHBhcmVudENvdW50ICAgPSBNYXRoLmZsb29yKE5PREVfQ09VTlQgKiAwLjEpO1xuICAgICAgICBsZXQgcGFyZW50SW5kaWNlcyA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTk9ERV9DT1VOVDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaWR4ID0gaSAqIE5PREVfU1RSSURFLFxuICAgICAgICAgICAgICAgIGlzUGFyZW50ID0gaSA8IHBhcmVudENvdW50O1xuXG4gICAgICAgICAgICBpZiAoaXNQYXJlbnQpIHBhcmVudEluZGljZXMucHVzaChpKTtcblxuICAgICAgICAgICAgbGV0IHRoZXRhID0gaSAqIDIgKiBNYXRoLlBJICogcGhpLFxuICAgICAgICAgICAgICAgIHIgICAgID0gTWF0aC5zcXJ0KGkpICogc2NhbGU7XG5cbiAgICAgICAgICAgIC8vIFNpbXBsZSB3cmFwIHRvIGtlZXAgaW5pdGlhbCBzcGlyYWwgaW5zaWRlIHJlYXNvbmFibGUgYm91bmRzXG4gICAgICAgICAgICBsZXQgeCA9IGN4ICsgciAqIE1hdGguY29zKHRoZXRhKSxcbiAgICAgICAgICAgICAgICB5ID0gY3kgKyByICogTWF0aC5zaW4odGhldGEpO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgc3BpcmFsIGlzIGxhcmdlciB0aGFuIHNjcmVlbiwgd3JhcCBpdFxuICAgICAgICAgICAgeCA9ICgoeCAlIHdpZHRoKSArIHdpZHRoKSAlIHdpZHRoO1xuICAgICAgICAgICAgeSA9ICgoeSAlIGhlaWdodCkgKyBoZWlnaHQpICUgaGVpZ2h0O1xuXG4gICAgICAgICAgICBidWZmZXJbaWR4XSAgICAgPSB4O1xuICAgICAgICAgICAgYnVmZmVyW2lkeCArIDFdID0geTtcbiAgICAgICAgICAgIGJ1ZmZlcltpZHggKyAyXSA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDAuMjtcbiAgICAgICAgICAgIGJ1ZmZlcltpZHggKyAzXSA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDAuMjtcblxuICAgICAgICAgICAgbGV0IGxheWVyID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMyk7XG4gICAgICAgICAgICBidWZmZXJbaWR4ICsgNV0gPSBsYXllcjsgLy8gbGF5ZXJcblxuICAgICAgICAgICAgLy8gUmFkaXVzIGJhc2VkIG9uIGxheWVyICYgcm9sZVxuICAgICAgICAgICAgYnVmZmVyW2lkeCArIDRdID0gaXNQYXJlbnQgPyA0ICsgKGxheWVyICogMikgOiAyICsgKGxheWVyICogMS41KTtcblxuICAgICAgICAgICAgLy8gUGFyZW50IElEICgtMSBmb3IgcGFyZW50cywgYXNzaWduZWQgbGF0ZXIgZm9yIGNoaWxkcmVuKVxuICAgICAgICAgICAgYnVmZmVyW2lkeCArIDZdID0gaXNQYXJlbnQgPyAtMSA6IC0yO1xuXG4gICAgICAgICAgICAvLyBQaGFzZSAoQnJlYXRoaW5nIG9mZnNldClcbiAgICAgICAgICAgIGJ1ZmZlcltpZHggKyA3XSA9IE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJICogMjtcblxuICAgICAgICAgICAgLy8gRW5lcmd5XG4gICAgICAgICAgICBidWZmZXJbaWR4ICsgOF0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gMi4gQXNzaWduIENoaWxkcmVuIHRvIG5lYXJlc3QgUGFyZW50XG4gICAgICAgIGZvciAobGV0IGkgPSBwYXJlbnRDb3VudDsgaSA8IE5PREVfQ09VTlQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkeCAgICAgICAgPSBpICogTk9ERV9TVFJJREUsXG4gICAgICAgICAgICAgICAgeCAgICAgICAgICA9IGJ1ZmZlcltpZHhdLFxuICAgICAgICAgICAgICAgIHkgICAgICAgICAgPSBidWZmZXJbaWR4ICsgMV0sXG4gICAgICAgICAgICAgICAgYmVzdERpc3QgICA9IEluZmluaXR5LFxuICAgICAgICAgICAgICAgIGJlc3RQYXJlbnQgPSAtMTtcblxuICAgICAgICAgICAgZm9yIChsZXQgcGlkIG9mIHBhcmVudEluZGljZXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgcElkeCA9IHBpZCAqIE5PREVfU1RSSURFLFxuICAgICAgICAgICAgICAgICAgICBweCAgID0gYnVmZmVyW3BJZHhdLFxuICAgICAgICAgICAgICAgICAgICBweSAgID0gYnVmZmVyW3BJZHggKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgZHggICA9IHggLSBweCxcbiAgICAgICAgICAgICAgICAgICAgZHkgICA9IHkgLSBweSxcbiAgICAgICAgICAgICAgICAgICAgZFNxICA9IGR4KmR4ICsgZHkqZHk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZFNxIDwgYmVzdERpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVzdERpc3QgPSBkU3E7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RQYXJlbnQgPSBwaWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBidWZmZXJbaWR4ICsgNl0gPSBiZXN0UGFyZW50XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgcGFja2V0IGJ1ZmZlci5cbiAgICAgKi9cbiAgICBpbml0UGFja2V0cygpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcbiAgICAgICAgaWYgKCFtZS5wYWNrZXRCdWZmZXIpIHtcbiAgICAgICAgICAgIG1lLnBhY2tldEJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoUEFDS0VUX0NPVU5UICogUEFDS0VUX1NUUklERSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhdXNlcyB0aGUgc2ltdWxhdGlvbi5cbiAgICAgKi9cbiAgICBwYXVzZSgpIHtcbiAgICAgICAgdGhpcy5pc1BhdXNlZCA9IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXN1bWVzIHRoZSBzaW11bGF0aW9uLlxuICAgICAqL1xuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuaXNQYXVzZWQpIHtcbiAgICAgICAgICAgIG1lLmlzUGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICBtZS5yZW5kZXJMb29wKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufSByZW5kZXJMb29wPXRoaXMucmVuZGVyLmJpbmQodGhpcylcbiAgICAgKi9cbiAgICByZW5kZXJMb29wID0gdGhpcy5yZW5kZXIuYmluZCh0aGlzKVxuXG4gICAgLyoqXG4gICAgICogTWFpbiBzaW11bGF0aW9uIGFuZCByZW5kZXIgbG9vcC5cbiAgICAgKiBFeGVjdXRlZCB+NjAgdGltZXMgcGVyIHNlY29uZC5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5jb250ZXh0IHx8IG1lLmlzUGF1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBjdHggICAgPSBtZS5jb250ZXh0LFxuICAgICAgICAgICAgd2lkdGggID0gbWUuY2FudmFzU2l6ZT8ud2lkdGggIHx8IDEwMCxcbiAgICAgICAgICAgIGhlaWdodCA9IG1lLmNhbnZhc1NpemU/LmhlaWdodCB8fCA1MDtcblxuICAgICAgICBtZS50aW1lICs9IDAuMDE7XG5cbiAgICAgICAgaWYgKCFtZS5ub2RlQnVmZmVyKSBtZS5pbml0Tm9kZXMod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGlmICghbWUuYWdlbnRCdWZmZXIpIG1lLmluaXRBZ2VudHMod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGlmICghbWUucGFja2V0QnVmZmVyKSBtZS5pbml0UGFja2V0cygpO1xuXG4gICAgICAgIC8vIFBoeXNpY3MgVXBkYXRlIFN0ZXBzXG4gICAgICAgIG1lLnVwZGF0ZVBoeXNpY3Mod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIG1lLnVwZGF0ZUFnZW50cyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgbWUudXBkYXRlUGFja2V0cygpO1xuICAgICAgICBtZS51cGRhdGVTcGFya3MoKTtcblxuICAgICAgICAvLyBSZW5kZXJpbmcgU3RlcHNcbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICBpZiAobWUuZ3JhZGllbnRzLmJnR3JhZGllbnQpIHtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBtZS5ncmFkaWVudHMuYmdHcmFkaWVudDtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KVxuICAgICAgICB9XG5cbiAgICAgICAgbWUuZHJhd05ldHdvcmsoY3R4LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgbWUuZHJhd1BhY2tldHMoY3R4KTtcbiAgICAgICAgbWUuZHJhd0FnZW50cyhjdHgpO1xuICAgICAgICBtZS5kcmF3U2hvY2t3YXZlcyhjdHgpO1xuICAgICAgICBtZS5kcmF3U3BhcmtzKGN0eCk7XG5cbiAgICAgICAgc2V0VGltZW91dChtZS5yZW5kZXJMb29wLCAxMDAwIC8gNjApXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgbG9jYWwgbW91c2Ugc3RhdGUgZnJvbSBtYWluIHRocmVhZCBldmVudHMuXG4gICAgICogVHJpZ2dlcnMgc2hvY2t3YXZlcyBvbiBjbGljay5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2RhdGEuY2xpY2tdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZGF0YS5sZWF2ZV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2RhdGEueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2RhdGEueV1cbiAgICAgKi9cbiAgICB1cGRhdGVNb3VzZVN0YXRlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoZGF0YS5sZWF2ZSkge1xuICAgICAgICAgICAgbWUubW91c2UueCA9IC0xMDAwO1xuICAgICAgICAgICAgbWUubW91c2UueSA9IC0xMDAwXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZGF0YS54ICE9PSB1bmRlZmluZWQpIG1lLm1vdXNlLnggPSBkYXRhLng7XG4gICAgICAgICAgICBpZiAoZGF0YS55ICE9PSB1bmRlZmluZWQpIG1lLm1vdXNlLnkgPSBkYXRhLnk7XG5cbiAgICAgICAgICAgIGlmIChkYXRhLmNsaWNrKSB7XG4gICAgICAgICAgICAgICAgbWUuc2hvY2t3YXZlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgeCAgICAgICAgOiBkYXRhLngsXG4gICAgICAgICAgICAgICAgICAgIHkgICAgICAgIDogZGF0YS55LFxuICAgICAgICAgICAgICAgICAgICBhZ2UgICAgICA6IDAsXG4gICAgICAgICAgICAgICAgICAgIG1heEFnZSAgIDogNDAsIC8vIEZhc3RlciwgcHVuY2hpZXIgd2F2ZVxuICAgICAgICAgICAgICAgICAgICBtYXhSYWRpdXM6IDMwMFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gU3Bhd24gU3BhcmtzIChEYXRhIERlYnJpcylcbiAgICAgICAgICAgICAgICBmb3IobGV0IGk9MDsgaTw0MDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhbmdsZSA9IE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJICogMixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwZWVkID0gTWF0aC5yYW5kb20oKSAqIDE1ICsgNTsgLy8gRmFzdCBidXJzdFxuICAgICAgICAgICAgICAgICAgICBtZS5zcGFya3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ICAgIDogZGF0YS54LFxuICAgICAgICAgICAgICAgICAgICAgICAgeSAgICA6IGRhdGEueSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZ4ICAgOiBNYXRoLmNvcyhhbmdsZSkgKiBzcGVlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZ5ICAgOiBNYXRoLnNpbihhbmdsZSkgKiBzcGVlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpZmUgOiAxLjAsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNheTogMC4wMiArIE1hdGgucmFuZG9tKCkgKiAwLjAzXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBwYWNrZXQgbG9naWMgKERhdGEgRmxvdykuXG4gICAgICogUGFja2V0cyBzcGF3biByYW5kb21seSBhdCBjaGlsZCBub2RlcyBhbmQgdHJhdmVsIHRvIHRoZWlyIHBhcmVudCBub2RlcyxcbiAgICAgKiByZXByZXNlbnRpbmcgZGF0YSByZXBvcnRpbmcgdXBzdHJlYW0uXG4gICAgICovXG4gICAgdXBkYXRlUGFja2V0cygpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcbiAgICAgICAgaWYgKCFtZS5wYWNrZXRCdWZmZXIgfHwgIW1lLm5vZGVCdWZmZXIpIHJldHVybjtcblxuICAgICAgICBjb25zdFxuICAgICAgICAgICAgcGFja2V0cyA9IG1lLnBhY2tldEJ1ZmZlcixcbiAgICAgICAgICAgIG5vZGVzICAgPSBtZS5ub2RlQnVmZmVyLFxuICAgICAgICAgICAgcENvdW50ICA9IFBBQ0tFVF9DT1VOVCxcbiAgICAgICAgICAgIG5Db3VudCAgPSBOT0RFX0NPVU5UO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpZHggPSBpICogUEFDS0VUX1NUUklERSxcbiAgICAgICAgICAgICAgICBsaWZlID0gcGFja2V0c1tpZHggKyA0XTtcblxuICAgICAgICAgICAgaWYgKGxpZmUgPD0gMCkge1xuICAgICAgICAgICAgICAgIC8vIFNwYXduIG5ldyBwYWNrZXQ/IChSYW5kb20gY2hhbmNlKVxuICAgICAgICAgICAgICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgMC4wMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBQaWNrIHJhbmRvbSBub2RlIChzb3VyY2UpXG4gICAgICAgICAgICAgICAgICAgIGxldCBuMSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG5Db3VudCksXG4gICAgICAgICAgICAgICAgICAgICAgICBpZHgxID0gbjEgKiBOT0RFX1NUUklERSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpZCA9IG5vZGVzW2lkeDEgKyA2XTsgLy8gUGFyZW50IElEXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVmFsaWQgdGFyZ2V0czogUGFyZW50IChpZiBjaGlsZCksIG9yIENoaWxkIChpZiBwYXJlbnQpXG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbXBsaWZpZWQ6IEp1c3QgZ28gQ2hpbGQgLT4gUGFyZW50IGZvciBub3cgKERhdGEgcmVwb3J0aW5nKVxuICAgICAgICAgICAgICAgICAgICBpZiAocGlkICE9PSAtMSkgeyAvLyBJZiBpdCdzIGEgY2hpbGRcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpZHgyID0gcGlkICogTk9ERV9TVFJJREUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDEgICA9IG5vZGVzW2lkeDFdLCB5MSA9IG5vZGVzW2lkeDEgKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MiAgID0gbm9kZXNbaWR4Ml0sIHkyID0gbm9kZXNbaWR4MiArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR4ICAgPSB4MiAtIHgxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR5ICAgPSB5MiAtIHkxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3QgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHNwYXduIGlmIGNvbm5lY3RlZCBhbmQgY2xvc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXN0IDwgMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFja2V0c1tpZHhdICAgICA9IHgxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhY2tldHNbaWR4ICsgMV0gPSB5MTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3BlZWQgICAgICAgID0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWNrZXRzW2lkeCArIDJdID0gKGR4IC8gZGlzdCkgKiBzcGVlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWNrZXRzW2lkeCArIDNdID0gKGR5IC8gZGlzdCkgKiBzcGVlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWNrZXRzW2lkeCArIDRdID0gZGlzdCAvIHNwZWVkIC8vIExpZmUgPSBmcmFtZXMgdG8gcmVhY2ggdGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE1vdmVcbiAgICAgICAgICAgICAgICBwYWNrZXRzW2lkeF0gICAgICs9IHBhY2tldHNbaWR4ICsgMl07XG4gICAgICAgICAgICAgICAgcGFja2V0c1tpZHggKyAxXSArPSBwYWNrZXRzW2lkeCArIDNdO1xuICAgICAgICAgICAgICAgIHBhY2tldHNbaWR4ICsgNF0tLSAvLyBEZWNyZWFzZSBsaWZlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHNwYXJrIHBhcnRpY2xlcyB3aXRoIGZyaWN0aW9uIGFuZCBkZWNheS5cbiAgICAgKi9cbiAgICB1cGRhdGVTcGFya3MoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSBtZS5zcGFya3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBzID0gbWUuc3BhcmtzW2ldO1xuICAgICAgICAgICAgcy54ICs9IHMudng7XG4gICAgICAgICAgICBzLnkgKz0gcy52eTtcbiAgICAgICAgICAgIC8vIEZyaWN0aW9uIChEcmFnKVxuICAgICAgICAgICAgcy52eCAqPSAwLjk7XG4gICAgICAgICAgICBzLnZ5ICo9IDAuOTtcbiAgICAgICAgICAgIHMubGlmZSAtPSBzLmRlY2F5O1xuICAgICAgICAgICAgaWYgKHMubGlmZSA8PSAwKSB7XG4gICAgICAgICAgICAgICAgbWUuc3BhcmtzLnNwbGljZShpLCAxKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBhZ2VudCBwb3NpdGlvbnMgdXNpbmcgKipCb2lkKiogbG9naWMgKFNlZWssIFNlcGFyYXRlKS5cbiAgICAgKiBBZ2VudHMgcmFuZG9tbHkgcGljayBhIHRhcmdldCBub2RlLCBzZWVrIGl0LCBzY2FuIGl0ICh0cmFuc2ZlcnJpbmcgZW5lcmd5KSxcbiAgICAgKiBhbmQgdGhlbiBwaWNrIGEgbmV3IHRhcmdldC4gVGhleSBhbHNvIGF2b2lkIHRoZSBtb3VzZSBjdXJzb3IuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqL1xuICAgIHVwZGF0ZUFnZW50cyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5hZ2VudEJ1ZmZlciB8fCAhbWUubm9kZUJ1ZmZlcikgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBhZ2VudHMgPSBtZS5hZ2VudEJ1ZmZlcixcbiAgICAgICAgICAgIG5vZGVzICA9IG1lLm5vZGVCdWZmZXIsXG4gICAgICAgICAgICBjb3VudCAgPSBBR0VOVF9DT1VOVCxcbiAgICAgICAgICAgIG14ICAgICA9IG1lLm1vdXNlLngsXG4gICAgICAgICAgICBteSAgICAgPSBtZS5tb3VzZS55O1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkeCA9IGkgKiBBR0VOVF9TVFJJREUsXG4gICAgICAgICAgICAgICAgdGFyZ2V0SWR4ID0gYWdlbnRzW2lkeCArIDRdLFxuICAgICAgICAgICAgICAgIHN0YXRlID0gYWdlbnRzW2lkeCArIDVdO1xuXG4gICAgICAgICAgICAvLyBCZWhhdmlvciAxOiBQaWNrIGEgVGFyZ2V0XG4gICAgICAgICAgICBpZiAodGFyZ2V0SWR4ID09PSAtMSB8fCBNYXRoLnJhbmRvbSgpIDwgMC4wMDUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRDb3VudCA9IE1hdGguZmxvb3IoTk9ERV9DT1VOVCAqIDAuMSk7XG4gICAgICAgICAgICAgICAgYWdlbnRzW2lkeCArIDRdID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcGFyZW50Q291bnQpO1xuICAgICAgICAgICAgICAgIHRhcmdldElkeCA9IGFnZW50c1tpZHggKyA0XTtcbiAgICAgICAgICAgICAgICBhZ2VudHNbaWR4ICsgNV0gPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBCZWhhdmlvciAyOiBTZWVrIFRhcmdldFxuICAgICAgICAgICAgaWYgKHRhcmdldElkeCAhPT0gLTEgJiYgc3RhdGUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgbklkeCA9IHRhcmdldElkeCAqIE5PREVfU1RSSURFLFxuICAgICAgICAgICAgICAgICAgICB0eCAgID0gbm9kZXNbbklkeF0sXG4gICAgICAgICAgICAgICAgICAgIHR5ICAgPSBub2Rlc1tuSWR4ICsgMV0sXG4gICAgICAgICAgICAgICAgICAgIGR4ICAgPSB0eCAtIGFnZW50c1tpZHhdLFxuICAgICAgICAgICAgICAgICAgICBkeSAgID0gdHkgLSBhZ2VudHNbaWR4ICsgMV0sXG4gICAgICAgICAgICAgICAgICAgIGRpc3QgPSBNYXRoLnNxcnQoZHgqZHggKyBkeSpkeSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGlzdCA8IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFycml2ZWQhIFNjYW4uXG4gICAgICAgICAgICAgICAgICAgIGFnZW50c1tpZHggKyA1XSA9IDE7IC8vIFNjYW4gc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgYWdlbnRzW2lkeCArIDJdICo9IDAuMTsgLy8gU2xvdyBkb3duXG4gICAgICAgICAgICAgICAgICAgIGFnZW50c1tpZHggKyAzXSAqPSAwLjE7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVHJhbnNmZXIgRW5lcmd5IHRvIE5vZGVcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNbbklkeCArIDhdID0gMS4wO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0ZWVyIHRvd2FyZHMgdGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgIGxldCBmb3JjZSA9IDAuMDU7XG4gICAgICAgICAgICAgICAgICAgIGFnZW50c1tpZHggKyAyXSArPSAoZHggLyBkaXN0KSAqIGZvcmNlO1xuICAgICAgICAgICAgICAgICAgICBhZ2VudHNbaWR4ICsgM10gKz0gKGR5IC8gZGlzdCkgKiBmb3JjZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPCAwLjAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGFnZW50c1tpZHggKyA0XSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICBhZ2VudHNbaWR4ICsgNV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBhZ2VudHNbaWR4ICsgMl0gKz0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogNDtcbiAgICAgICAgICAgICAgICAgICAgYWdlbnRzW2lkeCArIDNdICs9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBCZWhhdmlvciAzOiBNb3VzZSBSZXB1bHNpb25cbiAgICAgICAgICAgIGlmIChteCAhPT0gLTEwMDApIHtcbiAgICAgICAgICAgICAgICBsZXQgZHggPSBhZ2VudHNbaWR4XSAtIG14LFxuICAgICAgICAgICAgICAgICAgICBkeSA9IGFnZW50c1tpZHggKyAxXSAtIG15LFxuICAgICAgICAgICAgICAgICAgICBkaXN0U3EgPSBkeCpkeCArIGR5KmR5O1xuXG4gICAgICAgICAgICAgICAgaWYgKGRpc3RTcSA8IDEwMDAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkaXN0ICA9IE1hdGguc3FydChkaXN0U3EpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2UgPSAoMTAwIC0gZGlzdCkgLyAxMDA7XG4gICAgICAgICAgICAgICAgICAgIGFnZW50c1tpZHggKyAyXSArPSAoZHggLyBkaXN0KSAqIGZvcmNlICogMS41O1xuICAgICAgICAgICAgICAgICAgICBhZ2VudHNbaWR4ICsgM10gKz0gKGR5IC8gZGlzdCkgKiBmb3JjZSAqIDEuNTtcbiAgICAgICAgICAgICAgICAgICAgYWdlbnRzW2lkeCArIDVdID0gMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3BlZWQgTGltaXQgJiBNb3ZlXG4gICAgICAgICAgICBsZXQgc3BlZWQgPSBNYXRoLnNxcnQoYWdlbnRzW2lkeCArIDJdKioyICsgYWdlbnRzW2lkeCArIDNdKioyKTtcbiAgICAgICAgICAgIGlmIChzcGVlZCA+IDQpIHtcbiAgICAgICAgICAgICAgICBhZ2VudHNbaWR4ICsgMl0gKj0gNCAvIHNwZWVkO1xuICAgICAgICAgICAgICAgIGFnZW50c1tpZHggKyAzXSAqPSA0IC8gc3BlZWRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYWdlbnRzW2lkeF0gICAgICs9IGFnZW50c1tpZHggKyAyXTtcbiAgICAgICAgICAgIGFnZW50c1tpZHggKyAxXSArPSBhZ2VudHNbaWR4ICsgM107XG5cbiAgICAgICAgICAgIGlmIChhZ2VudHNbaWR4XSA8IDApIGFnZW50c1tpZHhdID0gd2lkdGg7XG4gICAgICAgICAgICBpZiAoYWdlbnRzW2lkeF0gPiB3aWR0aCkgYWdlbnRzW2lkeF0gPSAwO1xuICAgICAgICAgICAgaWYgKGFnZW50c1tpZHggKyAxXSA8IDApIGFnZW50c1tpZHggKyAxXSA9IGhlaWdodDtcbiAgICAgICAgICAgIGlmIChhZ2VudHNbaWR4ICsgMV0gPiBoZWlnaHQpIGFnZW50c1tpZHggKyAxXSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIG5vZGUgcG9zaXRpb25zIHVzaW5nICoqQ2x1c3RlciBQaHlzaWNzKiouXG4gICAgICogSGFuZGxlczpcbiAgICAgKiAxLiAgKipDb2hlc2lvbjoqKiBDaGlsZHJlbiBzdGljayB0byBwYXJlbnRzLlxuICAgICAqIDIuICAqKkZsb3cgRmllbGRzOioqIFBhcmVudHMgZHJpZnQgaW4gb3JnYW5pYyBwYXR0ZXJucy5cbiAgICAgKiAzLiAgKipUb3BvbG9neSBNdXRhdGlvbjoqKiBOb2RlcyBjYW4gZGV0YWNoIGFuZCByZS1wYXJlbnQuXG4gICAgICogNC4gICoqSW50ZXJhY3Rpb246KiogTW91c2UgcmVwdWxzaW9uIGFuZCBzaG9ja3dhdmUgZXhwbG9zaW9uLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgKi9cbiAgICB1cGRhdGVQaHlzaWNzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIW1lLm5vZGVCdWZmZXIpIHJldHVybjtcblxuICAgICAgICBjb25zdFxuICAgICAgICAgICAgYnVmZmVyICAgICAgPSBtZS5ub2RlQnVmZmVyLFxuICAgICAgICAgICAgbXggICAgICAgICAgPSBtZS5tb3VzZS54LFxuICAgICAgICAgICAgbXkgICAgICAgICAgPSBtZS5tb3VzZS55LFxuICAgICAgICAgICAgcGFyZW50Q291bnQgPSBNYXRoLmZsb29yKE5PREVfQ09VTlQgKiAwLjEpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTk9ERV9DT1VOVDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaWR4ID0gaSAqIE5PREVfU1RSSURFLFxuICAgICAgICAgICAgICAgIHBhcmVudElkID0gYnVmZmVyW2lkeCArIDZdLFxuICAgICAgICAgICAgICAgIGlzUGFyZW50ID0gcGFyZW50SWQgPT09IC0xO1xuXG4gICAgICAgICAgICAvLyAtLS0gTVVUQVRJT04gTE9HSUMgKFJlLVBhcmVudGluZykgLS0tXG4gICAgICAgICAgICBpZiAoIWlzUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gMS4gQ2hhbmNlIHRvIGRldGFjaCAoYmVjb21lcyBEcmlmdGluZzogLTIpXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudElkICE9PSAtMiAmJiBNYXRoLnJhbmRvbSgpIDwgMC4wMDA1KSB7IC8vIFJhcmUgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2lkeCArIDZdID0gLTI7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJvb3N0IHZlbG9jaXR5IHRvIGVzY2FwZVxuICAgICAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgMl0gKz0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMjtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2lkeCArIDNdICs9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDJcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyAyLiBSZS1hdHRhY2ggTG9naWMgKGlmIERyaWZ0aW5nKVxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRJZCA9PT0gLTIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2FuZGVyIGJlaGF2aW9yXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltpZHggKyAyXSArPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAwLjE7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltpZHggKyAzXSArPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAwLjE7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIG5ldyBwYXJlbnRcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBwYXJlbnRDb3VudDsgcCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcElkeCA9IHAgKiBOT0RFX1NUUklERSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBweCAgID0gYnVmZmVyW3BJZHhdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB5ICAgPSBidWZmZXJbcElkeCArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3QgPSBNYXRoLnNxcnQoKHB4IC0gYnVmZmVyW2lkeF0pKioyICsgKHB5IC0gYnVmZmVyW2lkeCArIDFdKSoqMik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXN0IDwgNjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgNl0gPSBwOyAvLyBTbmFwIHRvIG5ldyBwYXJlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAxLiBDbHVzdGVyIENvaGVzaW9uIChDaGlsZHJlbiBzdGljayB0byBQYXJlbnQpXG4gICAgICAgICAgICBpZiAoIWlzUGFyZW50ICYmIGJ1ZmZlcltpZHggKyA2XSAhPT0gLTIpIHsgLy8gTm9ybWFsIENoaWxkXG4gICAgICAgICAgICAgICAgbGV0IHBJZHggPSBwYXJlbnRJZCAqIE5PREVfU1RSSURFLFxuICAgICAgICAgICAgICAgICAgICBweCAgID0gYnVmZmVyW3BJZHhdLFxuICAgICAgICAgICAgICAgICAgICBweSAgID0gYnVmZmVyW3BJZHggKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgZHggICA9IHB4IC0gYnVmZmVyW2lkeF0sXG4gICAgICAgICAgICAgICAgICAgIGR5ICAgPSBweSAtIGJ1ZmZlcltpZHggKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgZGlzdCA9IE1hdGguc3FydChkeCpkeCArIGR5KmR5KTtcblxuICAgICAgICAgICAgICAgIC8vIFNwcmluZyBmb3JjZSB0b3dhcmRzIHBhcmVudFxuICAgICAgICAgICAgICAgIGlmIChkaXN0ID4gNTApIHsgLy8gSWRlYWwgZGlzdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvcmNlID0gKGRpc3QgLSA1MCkgKiAwLjAwMDU7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltpZHggKyAyXSArPSBkeCAqIGZvcmNlO1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgM10gKz0gZHkgKiBmb3JjZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gMi4gTW91c2UgUmVwdWxzaW9uIChBbGwgbm9kZXMpXG4gICAgICAgICAgICBpZiAobXggIT09IC0xMDAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGR4ICAgICA9IGJ1ZmZlcltpZHhdIC0gbXgsXG4gICAgICAgICAgICAgICAgICAgIGR5ICAgICA9IGJ1ZmZlcltpZHggKyAxXSAtIG15LFxuICAgICAgICAgICAgICAgICAgICBkaXN0U3EgPSBkeCAqIGR4ICsgZHkgKiBkeTtcblxuICAgICAgICAgICAgICAgIGlmIChkaXN0U3EgPCAyMjUwMCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGlzdCAgPSBNYXRoLnNxcnQoZGlzdFNxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlID0gKDE1MCAtIGRpc3QpIC8gMTUwO1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgMl0gKz0gKGR4IC8gZGlzdCkgKiBmb3JjZSAqIDAuNTtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2lkeCArIDNdICs9IChkeSAvIGRpc3QpICogZm9yY2UgKiAwLjVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIDMuIFNob2Nrd2F2ZSBSZXB1bHNpb24gKEV4cGxvc2l2ZSBGb3JjZSlcbiAgICAgICAgICAgIGlmIChtZS5zaG9ja3dhdmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBtZS5zaG9ja3dhdmVzLmZvckVhY2god2F2ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwcm9ncmVzcyA9IHdhdmUuYWdlIC8gd2F2ZS5tYXhBZ2U7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2dyZXNzIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVhc2VkID0gMSAtIE1hdGgucG93KDEgLSBwcm9ncmVzcywgMyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd1JhZCAgPSBlYXNlZCAqIHdhdmUubWF4UmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR4ICAgID0gYnVmZmVyW2lkeF0gLSB3YXZlLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHkgICAgPSBidWZmZXJbaWR4ICsgMV0gLSB3YXZlLnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzdCAgPSBNYXRoLnNxcnQoZHgqZHggKyBkeSpkeSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhpdCB0aGUgXCJXYXZlIEZyb250XCIgKFdpZHRoIG1hdGNoZXMgdmlzdWFsIHJpbmcgfjIwcHgpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoZGlzdCAtIHdSYWQpIDwgMjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZm9yY2UgPSAoMSAtIHByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXNzaXZlIEltcHVsc2UgKFRocm93aW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltpZHggKyAyXSArPSAoZHggLyBkaXN0KSAqIGZvcmNlICogMTA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2lkeCArIDNdICs9IChkeSAvIGRpc3QpICogZm9yY2UgKiAxMFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIDQuIFBoeXNpY3NcbiAgICAgICAgICAgIGJ1ZmZlcltpZHggKyAyXSAqPSAwLjk1OyAvLyBGcmljdGlvblxuICAgICAgICAgICAgYnVmZmVyW2lkeCArIDNdICo9IDAuOTU7XG5cbiAgICAgICAgICAgIC8vIEVuZXJneSBEZWNheVxuICAgICAgICAgICAgYnVmZmVyW2lkeCArIDhdICo9IDAuOTk7XG5cbiAgICAgICAgICAgIGxldCBkcmlmdCA9IGlzUGFyZW50ID8gMC4wMiA6IDAuMDE7XG5cbiAgICAgICAgICAgIC8vIDQuIEFtYmllbnQgRHJpZnQgLyBGbG93IEZpZWxkXG4gICAgICAgICAgICBpZiAoaXNQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBGTE9XIEZJRUxEIGZvciBQYXJlbnRzOiBDcmVhdGUgb3JnYW5pYyBjdXJyZW50c1xuICAgICAgICAgICAgICAgIC8vIENvbWJpbmUgU2luZS9Db3NpbmUgYmFzZWQgb24gcG9zaXRpb24gYW5kIHRpbWVcbiAgICAgICAgICAgICAgICBsZXQgYW5nbGUgPSAoTWF0aC5jb3MoYnVmZmVyW2lkeF0gICAgICogMC4wMDIgKyBtZS50aW1lICogMC41KSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguc2luKGJ1ZmZlcltpZHggKyAxXSAqIDAuMDAyICsgbWUudGltZSAqIDAuNSkpICogTWF0aC5QSTtcblxuICAgICAgICAgICAgICAgIC8vIEFjY2VsZXJhdGUgaW4gZmxvdyBkaXJlY3Rpb25cbiAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgMl0gKz0gTWF0aC5jb3MoYW5nbGUpICogMC4wNTtcbiAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgM10gKz0gTWF0aC5zaW4oYW5nbGUpICogMC4wNTtcblxuICAgICAgICAgICAgICAgIC8vIENPTlRBSU5NRU5UIEZJRUxEIChGaXggZm9yIERyaWZ0IEJpYXMpXG4gICAgICAgICAgICAgICAgLy8gR2VudGx5IHB1c2ggbm9kZXMgYmFjayB0byBjZW50ZXIgaWYgdGhleSB3YW5kZXIgdG9vIGZhclxuICAgICAgICAgICAgICAgIGxldCBjeCAgICA9IHdpZHRoIC8gMixcbiAgICAgICAgICAgICAgICAgICAgY3kgICAgPSBoZWlnaHQgLyAyLFxuICAgICAgICAgICAgICAgICAgICBkeCAgICA9IGN4IC0gYnVmZmVyW2lkeF0sXG4gICAgICAgICAgICAgICAgICAgIGR5ICAgID0gY3kgLSBidWZmZXJbaWR4ICsgMV0sXG4gICAgICAgICAgICAgICAgICAgIGRpc3QgID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KSxcbiAgICAgICAgICAgICAgICAgICAgbGltaXQgPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KSAqIDAuNDsgLy8gS2VlcCB3aXRoaW4gODAlIG9mIHNjcmVlbiBjZW50ZXJcblxuICAgICAgICAgICAgICAgIGlmIChkaXN0ID4gbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvcmNlID0gKGRpc3QgLSBsaW1pdCkgKiAwLjAwMTsgLy8gU29mdCBzcHJpbmdcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2lkeCArIDJdICs9IChkeCAvIGRpc3QpICogZm9yY2U7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltpZHggKyAzXSArPSAoZHkgLyBkaXN0KSAqIGZvcmNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBSYW5kb20gd2FuZGVyIGZvciBjaGlsZHJlblxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhidWZmZXJbaWR4ICsgMl0pIDwgMC4yKSBidWZmZXJbaWR4ICsgMl0gKz0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMC4wMjtcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoYnVmZmVyW2lkeCArIDNdKSA8IDAuMikgYnVmZmVyW2lkeCArIDNdICs9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDAuMDJcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnVmZmVyW2lkeF0gICAgICs9IGJ1ZmZlcltpZHggKyAyXTtcbiAgICAgICAgICAgIGJ1ZmZlcltpZHggKyAxXSArPSBidWZmZXJbaWR4ICsgM107XG5cbiAgICAgICAgICAgIC8vIEJvdW5jZVxuICAgICAgICAgICAgY29uc3QgcGFkID0gMjA7XG4gICAgICAgICAgICBpZiAoYnVmZmVyW2lkeF0gPCBwYWQpICAgICAgICAgICAgICB7IGJ1ZmZlcltpZHhdID0gcGFkOyBidWZmZXJbaWR4ICsgMl0gKj0gLTE7IH1cbiAgICAgICAgICAgIGlmIChidWZmZXJbaWR4XSA+IHdpZHRoIC0gcGFkKSAgICAgIHsgYnVmZmVyW2lkeF0gPSB3aWR0aCAtIHBhZDsgYnVmZmVyW2lkeCArIDJdICo9IC0xOyB9XG4gICAgICAgICAgICBpZiAoYnVmZmVyW2lkeCArIDFdIDwgcGFkKSAgICAgICAgICB7IGJ1ZmZlcltpZHggKyAxXSA9IHBhZDsgYnVmZmVyW2lkeCArIDNdICo9IC0xOyB9XG4gICAgICAgICAgICBpZiAoYnVmZmVyW2lkeCArIDFdID4gaGVpZ2h0IC0gcGFkKSB7IGJ1ZmZlcltpZHggKyAxXSA9IGhlaWdodCAtIHBhZDsgYnVmZmVyW2lkeCArIDNdICo9IC0xOyB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuZCBjYWNoZXMgZ3JhZGllbnRzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgKi9cbiAgICB1cGRhdGVSZXNvdXJjZXMod2lkdGgsIGhlaWdodCkge1xuICAgICAgICBsZXQgbWUgID0gdGhpcyxcbiAgICAgICAgICAgIGN0eCA9IG1lLmNvbnRleHQ7XG5cbiAgICAgICAgaWYgKCFjdHgpIHJldHVybjtcblxuICAgICAgICBjb25zdCBncmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsICdyZ2JhKDYyLCA5OSwgMjIxLCAwLjA1KScpOyAvLyBQUklNQVJZIGxvdyBhbHBoYVxuICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgJ3JnYmEoMTM5LCAxNjYsIDI1NSwgMC4wNSknKTsgLy8gU0VDT05EQVJZIGxvdyBhbHBoYVxuXG4gICAgICAgIG1lLmdyYWRpZW50cy5iZ0dyYWRpZW50ID0gZ3JhZGllbnRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2l6ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzaXplLmhlaWdodFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzaXplLndpZHRoXG4gICAgICovXG4gICAgdXBkYXRlU2l6ZShzaXplKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuY2FudmFzU2l6ZSA9IHNpemU7XG5cbiAgICAgICAgaWYgKG1lLmNvbnRleHQpIHtcbiAgICAgICAgICAgIG1lLmNvbnRleHQuY2FudmFzLndpZHRoICA9IHNpemUud2lkdGg7XG4gICAgICAgICAgICBtZS5jb250ZXh0LmNhbnZhcy5oZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgICAgICAgICAgIC8vIEZJWDogQWx3YXlzIHJlLWluaXQgbm9kZXMgb24gcmVzaXplIHRvIGZpeCBcInRvcC1sZWZ0IGJsb2JcIiBpc3N1ZVxuICAgICAgICAgICAgbWUuaW5pdE5vZGVzKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcbiAgICAgICAgICAgIG1lLmluaXRBZ2VudHMoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuICAgICAgICAgICAgbWUudXBkYXRlUmVzb3VyY2VzKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhIb21lQ2FudmFzKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=