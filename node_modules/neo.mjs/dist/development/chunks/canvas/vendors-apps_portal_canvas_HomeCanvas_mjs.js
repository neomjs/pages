export const __webpack_esm_id__ = "vendors-apps_portal_canvas_HomeCanvas_mjs";
export const __webpack_esm_ids__ = ["vendors-apps_portal_canvas_HomeCanvas_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./apps/portal/canvas/Base.mjs"
/*!*************************************!*\
  !*** ./apps/portal/canvas/Base.mjs ***!
  \*************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @summary Abstract base class for Portal Canvas Renderers.
 *
 * This class serves as the foundation for the specialized canvas visualizations (Header, Home, Services, Ticket)
 * that run within the **Neo.mjs Canvas SharedWorker**.
 *
 * It creates helper singletons that manage their own `OffscreenCanvas` instances, providing a standardized
 * architecture for:
 * - **Lifecycle Management:** Initialization (`initGraph`), destruction (`clearGraph`), and resource cleanup.
 * - **Render Loop Control:** Unified `render` loop with pause/resume capabilities and frame scheduling.
 * - **Context Management:** Robust handling of `OffscreenCanvas` transfer and context acquisition via `waitForCanvas`.
 * - **Shared State:** Common state management for mouse interaction, time, and theming.
 *
 * These renderers operate off the main thread to ensure high-performance, 60fps animations without
 * blocking the UI.
 *
 * @class Portal.canvas.Base
 * @extends Neo.core.Base
 */
class Base extends _src_core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.canvas.Base'
         * @protected
         */
        className: 'Portal.canvas.Base',
        /**
         * Remote method access
         * @member {Object} remote
         * @protected
         */
        remote: {
            app: [
                'clearGraph',
                'initGraph',
                'pause',
                'resume',
                'setTheme',
                'updateMouseState',
                'updateSize'
            ]
        },
        /**
         * The active color theme ('light' or 'dark').
         * @member {String} theme_='light'
         * @reactive
         */
        theme_: 'light'
    }

    /**
     * @member {Number|null} animationId=null
     */
    animationId = null
    /**
     * @member {String|null} canvasId=null
     */
    canvasId = null
    /**
     * @member {Object|null} canvasSize=null
     */
    canvasSize = null
    /**
     * @member {OffscreenCanvasRenderingContext2D|null} context=null
     */
    context = null
    /**
     * Cache for reusable gradients to prevent GC.
     * @member {Object} gradients={}
     */
    gradients = {}
    /**
     * Flag to pause the render loop.
     * @member {Boolean} isPaused=false
     */
    isPaused = false
    /**
     * Tracked mouse position for interactive physics.
     * Initialize off-screen to prevent startup jitters.
     * @member {Object} mouse={x: -1000, y: -1000}
     */
    mouse = {x: -1000, y: -1000}
    /**
     * Global simulation time.
     * @member {Number} time=0
     */
    time = 0

    /**
     * @member {Function} renderLoop=this.render.bind(this)
     */
    renderLoop = this.render.bind(this)

    /**
     * Triggered after the `theme` config is changed.
     * Updates the resource cache (gradients, colors) to reflect the new theme immediately.
     * @param {String} value
     * @param {String} oldValue
     */
    afterSetTheme(value, oldValue) {
        if (value && this.canvasSize) {
            this.updateResources?.(this.canvasSize.width, this.canvasSize.height)
        }
    }

    /**
     * Checks if the canvas is ready to render.
     * Returns true only if the context exists and the simulation is not paused.
     * Subclasses should call this at the start of their `render` loop.
     * @returns {Boolean}
     */
    get canRender() {
        let me = this;
        return !!(me.context && !me.isPaused)
    }

    /**
     * Clears the graph state and stops the render loop.
     * Use this to cleanup resources when the component is destroyed or unmounted.
     */
    clearGraph() {
        let me = this;
        me.context     = null;
        me.canvasId    = null;
        me.canvasSize  = null;
        me.animationId = null;
        me.isPaused    = false;
        me.gradients   = {};
        me.mouse       = {x: -1000, y: -1000};
        me.time        = 0
    }

    /**
     * Initializes the canvas context.
     * Starts the polling mechanism to wait for the OffscreenCanvas transfer from the Main Thread.
     * @param {Object} opts
     * @param {String} opts.canvasId
     * @param {String} opts.windowId
     */
    initGraph({canvasId, windowId}) {
        let me        = this,
            hasChange = me.canvasId !== canvasId;

        me.canvasId = canvasId;

        me.waitForCanvas(canvasId, windowId, hasChange)
    }

    /**
     * Hook for subclasses to handle mouse clicks.
     * Called by `updateMouseState` when a click event is received.
     * @param {Object} data
     */
    onMouseClick(data) {}

    /**
     * Pauses the simulation.
     * The render loop will exit early while `isPaused` is true.
     */
    pause() {
        this.isPaused = true
    }

    /**
     * Abstract render method.
     * Subclasses must implement this method to draw the frame.
     */
    render() {}

    /**
     * Resumes the simulation.
     * If the simulation was paused, this restarts the render loop.
     */
    resume() {
        let me = this;

        if (me.isPaused) {
            me.isPaused = false;
            me.renderLoop()
        }
    }

    /**
     * Exposed method for Remote Access to trigger the reactive config setter.
     * @param {String} value
     */
    setTheme(value) {
        this.theme = value
    }

    /**
     * Updates the local mouse state from main thread events.
     * Delegates click events to `onMouseClick`.
     * @param {Object} data
     * @param {Boolean} [data.click]
     * @param {Boolean} [data.leave]
     * @param {Number} [data.x]
     * @param {Number} [data.y]
     */
    updateMouseState(data) {
        let me = this;

        if (data.leave) {
            me.mouse.x = -1000;
            me.mouse.y = -1000
        } else {
            if (data.x !== undefined) me.mouse.x = data.x;
            if (data.y !== undefined) me.mouse.y = data.y;

            if (data.click) {
                me.onMouseClick(data)
            }
        }
    }

    /**
     * Updates the canvas size and resizes the internal context.
     * Triggers `updateResources` hook to allow subclasses to regenerate buffers/gradients.
     * @param {Object} size
     * @param {Number} size.height
     * @param {Number} size.width
     */
    updateSize(size) {
        let me = this;

        me.canvasSize = size;

        if (me.context) {
            me.context.canvas.width  = size.width;
            me.context.canvas.height = size.height;
            // Calls the hook to re-generate resources if implemented
            me.updateResources?.(size.width, size.height)
        }
    }

    /**
     * Polls for the OffscreenCanvas until it is available in the Worker's `canvasWindowMap`.
     * Once found, it initializes the context and starts the render loop.
     * @param {String} canvasId
     * @param {String} windowId
     * @param {Boolean} hasChange
     * @protected
     */
    waitForCanvas(canvasId, windowId, hasChange) {
        let me     = this,
            canvas = Neo.currentWorker.canvasWindowMap[canvasId]?.[windowId];

        if (canvas) {
            me.context = canvas.getContext('2d');

            // Standardize size update
            me.updateSize({width: canvas.width, height: canvas.height});

            // Optional hook for subclasses
            me.onGraphMounted?.(canvas.width, canvas.height);

            if (hasChange && !me.animationId) {
                me.renderLoop()
            }
        } else {
            setTimeout(me.waitForCanvas.bind(me, canvasId, windowId, hasChange), 50)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Base));


/***/ },

/***/ "./apps/portal/canvas/HomeCanvas.mjs"
/*!*******************************************!*\
  !*** ./apps/portal/canvas/HomeCanvas.mjs ***!
  \*******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./apps/portal/canvas/Base.mjs");


const
    hasRaf           = typeof requestAnimationFrame === 'function',
    PRIMARY          = '#3E63DD',
    SECONDARY        = '#536DFE',
    HIGHLIGHT        = '#00BFFF', // Deep Sky Blue (High Contrast)
    CONNECTION_COLOR = '#808080',
    NODE_COUNT       = 150,
    NODE_STRIDE      = 9, // x, y, vx, vy, radius, layer, parentId, phase, energy
    AGENT_COUNT      = 20,
    AGENT_STRIDE     = 6, // x, y, vx, vy, targetIdx, state
    PACKET_COUNT     = 20,
    PACKET_STRIDE    = 5; // x, y, vx, vy, life (0-1)

/**
 * @summary SharedWorker renderer for the Portal Home "Neural Swarm" background.
 *
 * Implements the **"Neural Swarm"** visual theme, a dynamic, mutable network simulation that
 * visualizes the Neo.mjs Application Engine as a living ecosystem.
 *
 * **Visual Architecture:**
 * 1. **Living Topology (The Graph):** Nodes are not static; they form hierarchical clusters representing
 *    Components within Containers. The topology is mutable, with sub-clusters occasionally detaching,
 * *    drifting, and re-parenting (Visualizing "Atomic Moves").
 * 2. **Autonomous Agents (The Neural Link):** "Seeker Drones" roam the graph using Boid behavior
 *    (Separation, Alignment, Cohesion). They "scan" nodes, transferring energy and triggering
 *    visual highlights, representing the active intelligence of the framework.
 * 3. **Data Flow (Signal Packets):** Pulses of light travel along connections from child to parent,
 *    visualizing the flow of events and data upstream.
 * 4. **Atmosphere (Parallax):** A multi-layered depth system creates a volumetric feel, distinguishing
 *    foreground "active" nodes from background "context" nodes.
 *
 * **Responsive Architecture (Reference Viewport):**
 * To ensure a consistent experience across devices (from Mobile to 4K), the simulation uses a **Reference Viewport Strategy**.
 * - **Baseline:** 1920x1080 is defined as scale `1.0`.
 * - **Dynamic Scaling:** On resize, a `scale` factor is calculated: `sqrt((width * height) / (1920 * 1080))`.
 * - **Normalization:** All physics constants (velocity, force), spatial dimensions (distances, radii), and
 *   visual properties (stroke width) are multiplied by this `scale`.
 * - **Density Control:** On small screens (`scale < 0.5`), the background layer is culled to prevent visual noise.
 *
 * **Theme System:**
 * Supports dynamic `light` and `dark` modes via the `theme` config.
 * - **Palette:** A static `colors` map defines semantic color slots (agentHead, spark, etc.) for each mode.
 * - **Hot-Swapping:** Changing the `theme` config triggers `updateResources` to regenerate gradients and
 *   immediately alters rendering colors in the next frame without re-initializing buffers.
 *
 * **Performance Architecture (Zero-Allocation):**
 * To maintain 60fps on high-refresh displays without GC stutters, this class employs a **Zero-Allocation** strategy during the render loop.
 * 1. **TypedArray Buffers:** All entity data (Nodes, Agents, Packets) is stored in pre-allocated `Float32Array` buffers.
 * 2. **Inlined Physics:** Vector calculations are performed inline without creating temporary Objects.
 * 3. **Gradient Caching:** CanvasGradients are created only on resize (`updateResources`) and cached.
 *
 * **Node Buffer Layout (Float32Array):**
 * - 0: x (Position X)
 * - 1: y (Position Y)
 * - 2: vx (Velocity X)
 * - 3: vy (Velocity Y)
 * - 4: radius (Visual size)
 * - 5: layer (Parallax depth: 0=back, 1=mid, 2=front)
 * - 6: parentId (Index of parent node, -1 if parent, -2 if drifting)
 * - 7: phase (Animation offset for breathing)
 * - 8: energy (Interaction state, 0-1)
 *
 * **Agent Buffer Layout (Float32Array):**
 * - 0: x
 * - 1: y
 * - 2: vx
 * - 3: vy
 * - 4: targetIdx (Index of target node, -1 if wandering)
 * - 5: state (0=moving, 1=scanning)
 *
 * **Packet Buffer Layout (Float32Array):**
 * - 0: x
 * - 1: y
 * - 2: vx
 * - 3: vy
 * - 4: life (Frames remaining, 0-1 normalized for alpha)
 *
 * @class Portal.canvas.HomeCanvas
 * @extends Portal.canvas.Base
 * @singleton
 */
class HomeCanvas extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static colors = {
        dark: {
            agentHead : '#FFFFFF',
            background: ['rgba(62, 99, 221, 0.15)', 'rgba(139, 166, 255, 0.15)'],
            nodeHigh  : '#FFFFFF',
            packet    : '#FFFFFF',
            shockwave : '#FFFFFF',
            spark     : '#4B0082'
        },
        light: {
            agentHead : '#3E63DD', // PRIMARY
            background: ['rgba(62, 99, 221, 0.05)', 'rgba(139, 166, 255, 0.05)'],
            nodeHigh  : '#3E63DD', // PRIMARY
            packet    : '#3E63DD', // PRIMARY
            shockwave : '#3E63DD', // PRIMARY
            spark     : '#4B0082'
        }
    }

    static config = {
        /**
         * @member {String} className='Portal.canvas.HomeCanvas'
         * @protected
         */
        className: 'Portal.canvas.HomeCanvas',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * Pre-allocated buffer for agent data (Seeker Drones).
     * @member {Float32Array|null} agentBuffer=null
     */
    agentBuffer = null
    /**
     * Pre-allocated buffer for node data (The Graph).
     * @member {Float32Array|null} nodeBuffer=null
     */
    nodeBuffer = null
    /**
     * Pre-allocated buffer for data packets (Signal Pulses).
     * @member {Float32Array|null} packetBuffer=null
     */
    packetBuffer = null
    /**
     * Active shockwave effects.
     * @member {Object[]} shockwaves=[]
     */
    shockwaves = []
    /**
     * Active spark particles (Data Debris).
     * @member {Object[]} sparks=[]
     */
    sparks = []
    /**
     * Scaling factor relative to a 1920x1080 reference viewport.
     * Used to ensure consistent physics and visuals across resolutions.
     * @member {Number} scale=1
     */
    scale = 1

    /**
     * Clears the graph state and stops the render loop.
     * Used when the component is destroyed or the route changes.
     */
    clearGraph() {
        let me = this;
        super.clearGraph();
        me.nodeBuffer   = null;
        me.agentBuffer  = null;
        me.packetBuffer = null;
        me.shockwaves   = [];
        me.sparks       = [];
        me.scale        = 1
    }

    /**
     * Hook to initialize nodes and agents after context is ready
     * @param {Number} width
     * @param {Number} height
     */
    onGraphMounted(width, height) {
        this.updateSize({width, height})
    }

    /**
     * Draws the autonomous agents (Seeker Drones).
     *
     * **Visuals:**
     * - **Head:** A solid circle indicating current position.
     * - **Trail:** A fading line drawn opposite to velocity, simulating motion blur.
     * - **Scan Effect:** A pulsing ring when the agent reaches a node (state=1).
     *
     * @param {CanvasRenderingContext2D} ctx
     */
    drawAgents(ctx) {
        let me = this;

        if (!me.agentBuffer) return;

        const
            buffer      = me.agentBuffer,
            count       = AGENT_COUNT,
            themeColors = me.constructor.colors[me.theme],
            s           = me.scale; // Get scale factor

        ctx.strokeStyle = HIGHLIGHT;
        ctx.fillStyle   = themeColors.agentHead;
        ctx.lineCap     = 'round';

        for (let i = 0; i < count; i++) {
            let idx   = i * AGENT_STRIDE,
                x     = buffer[idx],
                y     = buffer[idx + 1],
                vx    = buffer[idx + 2],
                vy    = buffer[idx + 3],
                state = buffer[idx + 5];

            // 1. Draw Trail (Motion Blur)
            let speed = Math.sqrt(vx*vx + vy*vy);

            if (speed > 0.1 * s) { // Scaled threshold
                ctx.beginPath();
                ctx.lineWidth = 2 * s; // Scaled line width
                ctx.globalAlpha = 0.6;
                ctx.moveTo(x, y);
                ctx.lineTo(x - vx * 4, y - vy * 4);
                ctx.stroke()
            }

            // 2. Draw Head
            ctx.beginPath();
            ctx.globalAlpha = state === 1 ? 1 : 0.8;
            let radius = (state === 1 ? 3 : 2) * s; // Scaled radius
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();

            // 3. Scan Effect
            if (state === 1) {
                ctx.beginPath();
                ctx.lineWidth = 1 * s; // Scaled width
                ctx.globalAlpha = 0.3;
                // Scaled ring radius
                ctx.arc(x, y, (8 + Math.sin(me.time * 10) * 2) * s, 0, Math.PI * 2);
                ctx.stroke()
            }
        }

        ctx.globalAlpha = 1
    }

    /**
     * Draws the neural network (nodes and connections).
     *
     * **Intent:**
     * Visualizes the "Application Graph".
     * - **Parallax:** Applies depth-based displacement based on mouse position.
     * - **Connections:** Lines are drawn only between related nodes (Parent-Child or Siblings).
     *   Lines thicken and brighten when near the mouse.
     * - **Nodes:** Circles breathing in size. Colors indicate depth (Layer) and energy state.
     *
     * **Optimization:**
     * Uses inlined math for parallax calculations to avoid allocating thousands of `{x,y}` objects per frame.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {Number} width
     * @param {Number} height
     */
    drawNetwork(ctx, width, height) {
        let me = this;

        if (!me.nodeBuffer) return;

        const
            buffer      = me.nodeBuffer,
            count       = NODE_COUNT,
            mx          = me.mouse.x,
            my          = me.mouse.y,
            cx          = width / 2,
            cy          = height / 2,
            themeColors = me.constructor.colors[me.theme],
            s           = me.scale; // Get scale factor

        ctx.lineWidth = 1 * s; // Scaled line width

        // 1. Draw Connections
        // Iterates all unique pairs to draw lines between connected nodes.
        // Connections are drawn if nodes share a parent (siblings) or are parent-child.
        for (let i = 0; i < count; i++) {
            let idx  = i * NODE_STRIDE,
                l1   = buffer[idx + 5],
                pid1 = buffer[idx + 6],
                // Inline getPos logic for p1 to avoid GC
                f1   = l1 === 2 ? 0.05 : (l1 === 1 ? 0.02 : 0.01),
                dx1  = (mx !== -1000 ? mx - cx : 0) * f1,
                dy1  = (my !== -1000 ? my - cy : 0) * f1,
                p1x  = buffer[idx] + dx1,
                p1y  = buffer[idx + 1] + dy1;

            for (let j = i + 1; j < count; j++) {
                let idx2 = j * NODE_STRIDE,
                    l2   = buffer[idx2 + 5],
                    pid2 = buffer[idx2 + 6];

                const
                    sameCluster   = pid1 === pid2 && pid1 !== -1,
                    isParentChild = (pid1 === j) || (pid2 === i),
                    isClusterLink = (pid1 === -1 && pid2 === -1);

                if (!sameCluster && !isParentChild && !isClusterLink) continue;

                let f2   = l2 === 2 ? 0.05 : (l2 === 1 ? 0.02 : 0.01),
                    dx2  = (mx !== -1000 ? mx - cx : 0) * f2,
                    dy2  = (my !== -1000 ? my - cy : 0) * f2,
                    p2x  = buffer[idx2] + dx2,
                    p2y  = buffer[idx2 + 1] + dy2,
                    dx   = p1x - p2x,
                    dy   = p1y - p2y,
                    distSq = dx*dx + dy*dy;

                // Culling: Only draw connections within a certain distance
                if (distSq < 40000 * s * s) { // Scaled distance squared
                    let dist  = Math.sqrt(distSq),
                        alpha = 1 - (dist / (200 * s)); // Scaled distance factor

                    alpha *= (0.2 + (l1 * 0.1));

                    let mDx = (p1x + p2x)/2 - mx,
                        mDy = (p1y + p2y)/2 - my,
                        mDistSq = mDx*mDx + mDy*mDy;

                    // Mouse Interaction: Highlight connections near cursor
                    if (mDistSq < 10000 * s * s) { // Scaled mouse distance
                        alpha = Math.min(alpha + 0.5, 1);
                        ctx.strokeStyle = HIGHLIGHT;
                        ctx.lineWidth   = 1.5 * s // Scaled
                    } else {
                        ctx.strokeStyle = l1 === 2 ? PRIMARY : SECONDARY;
                        // Elasticity: Thicker when closer (Tension/Slack visualization)
                        ctx.lineWidth = (0.5 + (1 - (dist / (200 * s)))) * s // Scaled
                    }

                    ctx.beginPath();
                    ctx.globalAlpha = alpha * 0.5;
                    ctx.moveTo(p1x, p1y);
                    ctx.lineTo(p2x, p2y);
                    ctx.stroke()
                }
            }
        }

        // 2. Draw Nodes
        for (let i = 0; i < count; i++) {
            let idx      = i * NODE_STRIDE,
                radius   = buffer[idx + 4],
                layer    = buffer[idx + 5],
                parentId = buffer[idx + 6],
                phase    = buffer[idx + 7],
                energy   = buffer[idx + 8];

            // Culling: Skip background layer on very small screens to reduce noise
            if (s < 0.5 && layer === 0) continue;

            let
                // Inline getPos logic for pos
                f        = layer === 2 ? 0.05 : (layer === 1 ? 0.02 : 0.01),
                pDx      = (mx !== -1000 ? mx - cx : 0) * f,
                pDy      = (my !== -1000 ? my - cy : 0) * f,
                posX     = buffer[idx] + pDx,
                posY     = buffer[idx + 1] + pDy,
                dx       = posX - mx,
                dy       = posY - my,
                dist     = Math.sqrt(dx * dx + dy * dy),
                isHover  = dist < 50 * s; // Scaled hover distance

            // Shockwave Interaction
            if (me.shockwaves.length > 0) {
                me.shockwaves.forEach(wave => {
                    let wDist = Math.sqrt((posX - wave.x)**2 + (posY - wave.y)**2),
                        wRad  = wave.age * wave.speed;
                    if (Math.abs(wDist - wRad) < 20 * s) { // Scaled wave width
                        isHover = true;
                    }
                });
            }

            ctx.beginPath();
            let r = parentId === -1 ? radius * 1.5 : radius;

            // Breathing + Energy
            r *= 1 + Math.sin(me.time * 2 + phase) * 0.15 + energy;

            if (isHover) {
                r *= 1.5;
            }

            ctx.arc(posX, posY, r, 0, Math.PI * 2);

            if (energy > 0.1) {
                // Energetic Node (Agent Scanned)
                ctx.fillStyle = HIGHLIGHT;
                ctx.globalAlpha = Math.min(1, 0.5 + energy)
            } else if (layer === 2) {
                ctx.fillStyle = isHover ? themeColors.nodeHigh : PRIMARY;
                ctx.globalAlpha = isHover ? 1 : 0.8
            } else if (parentId === -2) {
                // Drifting Node Visual
                ctx.fillStyle = HIGHLIGHT;
                ctx.globalAlpha = 0.6 + Math.sin(me.time * 10 + phase) * 0.3
            } else if (layer === 1) {
                ctx.fillStyle = isHover ? HIGHLIGHT : SECONDARY;
                ctx.globalAlpha = 0.5
            } else {
                ctx.fillStyle = CONNECTION_COLOR;
                ctx.globalAlpha = 0.2
            }

            ctx.fill();
        }

        ctx.globalAlpha = 1
    }

    /**
     * Draws the data packets traveling along connections.
     * Packets represent signal flow between nodes.
     * @param {OffscreenCanvasRenderingContext2D} ctx
     */
    drawPackets(ctx) {
        let me = this;

        if (!me.packetBuffer) return;

        const
            buffer      = me.packetBuffer,
            count       = PACKET_COUNT,
            themeColors = me.constructor.colors[me.theme];

        ctx.fillStyle   = themeColors.packet;
        ctx.shadowBlur  = 5;
        ctx.shadowColor = HIGHLIGHT;

        for (let i = 0; i < count; i++) {
            let idx  = i * PACKET_STRIDE,
                life = buffer[idx + 4];

            if (life > 0) {
                let x = buffer[idx],
                    y = buffer[idx + 1];

                ctx.beginPath();
                ctx.globalAlpha = Math.min(life * 2, 1); // Fade out at end
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fill()
            }
        }

        ctx.shadowBlur  = 0;
        ctx.globalAlpha = 1
    }

    /**
     * Draws expanding shockwaves from clicks with Chromatic Aberration and Composite Rings.
     * Uses optimized RGBA composition to reduce GC pressure.
     * @param {OffscreenCanvasRenderingContext2D} ctx
     */
    drawShockwaves(ctx) {
        let me = this;

        if (me.shockwaves.length === 0) return;

        const
            themeColors = me.constructor.colors[me.theme],
            s           = me.scale;

        ctx.lineCap = 'round';

        for (let i = me.shockwaves.length - 1; i >= 0; i--) {
            let wave = me.shockwaves[i];
            wave.age++;

            let progress = wave.age / wave.maxAge;

            if (progress >= 1) {
                me.shockwaves.splice(i, 1);
                continue;
            }

            // Non-Linear Expansion (Explosive start, slow finish)
            let eased = 1 - Math.pow(1 - progress, 3),
                radius = eased * wave.maxRadius,
                alpha  = 1 - progress;

            // Chromatic Aberration (Shifted to Neon Blue/Cyan theme)

            // 1. Cyan Channel (Lagging Fringe) - Replaces Red
            ctx.beginPath();
            ctx.strokeStyle = HIGHLIGHT;
            ctx.globalAlpha = alpha * 0.8;
            ctx.lineWidth   = 4 * (1 - progress) * s; // Scaled
            ctx.shadowBlur  = 10 * s; // Scaled
            ctx.shadowColor = HIGHLIGHT;
            ctx.arc(wave.x, wave.y, radius * 0.99, 0, Math.PI * 2);
            ctx.stroke();

            // 2. Blue Channel (Leading Fringe)
            ctx.beginPath();
            ctx.strokeStyle = PRIMARY;
            ctx.globalAlpha = alpha * 0.8;
            ctx.lineWidth   = 4 * (1 - progress) * s; // Scaled
            ctx.shadowBlur  = 10 * s; // Scaled
            ctx.shadowColor = PRIMARY;
            ctx.arc(wave.x, wave.y, radius * 1.01, 0, Math.PI * 2);
            ctx.stroke();

            // 3. Primary Wave (White Hot Center)
            ctx.beginPath();
            ctx.strokeStyle = themeColors.shockwave;
            ctx.globalAlpha = alpha;
            ctx.lineWidth   = 6 * (1 - progress) * s; // Scaled
            ctx.shadowBlur  = 20 * s; // Scaled
            ctx.shadowColor = themeColors.shockwave;
            ctx.arc(wave.x, wave.y, radius, 0, Math.PI * 2);
            ctx.stroke();

            // 4. Pressure Fill (Refraction Fake)
            ctx.fillStyle = PRIMARY;
            ctx.globalAlpha = alpha * 0.05;
            ctx.fill();
        }

        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1
    }

    /**
     * Draws temporary spark particles (Data Debris).
     * @param {OffscreenCanvasRenderingContext2D} ctx
     */
    drawSparks(ctx) {
        let me = this;

        if (me.sparks.length === 0) return;

        const
            themeColors = me.constructor.colors[me.theme],
            s           = me.scale;

        ctx.strokeStyle = themeColors.spark;
        ctx.shadowBlur = 0; // Crisp lines on white
        ctx.lineWidth = 2 * s; // Scaled width

        for (let s of me.sparks) {
            ctx.globalAlpha = s.life;
            ctx.beginPath();
            // Draw Trail based on velocity
            ctx.moveTo(s.x, s.y);
            ctx.lineTo(s.x - s.vx * 2, s.y - s.vy * 2);
            ctx.stroke()
        }

        ctx.globalAlpha = 1
    }

    /**
     * Initializes the autonomous agents.
     * Agents start at random positions with random high-velocity vectors.
     * @param {Number} width
     * @param {Number} height
     */
    initAgents(width, height) {
        let me = this;

        if (!me.agentBuffer) {
            me.agentBuffer = new Float32Array(AGENT_COUNT * AGENT_STRIDE);
        }

        const
            buffer = me.agentBuffer,
            s      = me.scale;

        for (let i = 0; i < AGENT_COUNT; i++) {
            let idx = i * AGENT_STRIDE;

            buffer[idx]     = Math.random() * width;  // x
            buffer[idx + 1] = Math.random() * height; // y
            buffer[idx + 2] = (Math.random() - 0.5) * 4 * s; // vx (Fast!)
            buffer[idx + 3] = (Math.random() - 0.5) * 4 * s; // vy
            buffer[idx + 4] = -1; // targetIdx (none)
            buffer[idx + 5] = 0   // state (moving)
        }
    }

    /**
     * Initializes the node buffer using **Golden Spiral** distribution.
     * This ensures a uniform but organic-looking distribution of nodes across the screen,
     * preventing the "clumping" seen with random placement.
     * @param {Number} width
     * @param {Number} height
     */
    initNodes(width, height) {
        let me = this;

        if (!me.nodeBuffer) {
            me.nodeBuffer = new Float32Array(NODE_COUNT * NODE_STRIDE);
        }

        const
            buffer        = me.nodeBuffer,
            cx            = width / 2,
            cy            = height / 2,
            phi           = (1 + Math.sqrt(5)) / 2,
            scale         = Math.sqrt(width * height / NODE_COUNT) * 0.8,
            parentCount   = Math.floor(NODE_COUNT * 0.1),
            s             = me.scale; // Use the calculated scale factor

        let parentIndices = [];

        for (let i = 0; i < NODE_COUNT; i++) {
            let idx = i * NODE_STRIDE,
                isParent = i < parentCount;

            if (isParent) parentIndices.push(i);

            let theta = i * 2 * Math.PI * phi,
                r     = Math.sqrt(i) * scale;

            // Simple wrap to keep initial spiral inside reasonable bounds
            let x = cx + r * Math.cos(theta),
                y = cy + r * Math.sin(theta);

            // If the spiral is larger than screen, wrap it
            x = ((x % width) + width) % width;
            y = ((y % height) + height) % height;

            buffer[idx]     = x;
            buffer[idx + 1] = y;
            buffer[idx + 2] = (Math.random() - 0.5) * 0.2 * s; // Scale velocity
            buffer[idx + 3] = (Math.random() - 0.5) * 0.2 * s;

            let layer = Math.floor(Math.random() * 3);
            buffer[idx + 5] = layer; // layer

            // Radius based on layer & role (Scaled)
            buffer[idx + 4] = (isParent ? 4 + (layer * 2) : 2 + (layer * 1.5)) * s;

            // Parent ID (-1 for parents, assigned later for children)
            buffer[idx + 6] = isParent ? -1 : -2;

            // Phase (Breathing offset)
            buffer[idx + 7] = Math.random() * Math.PI * 2;

            // Energy
            buffer[idx + 8] = 0;
        }

        // 2. Assign Children to nearest Parent
        for (let i = parentCount; i < NODE_COUNT; i++) {
            let idx        = i * NODE_STRIDE,
                x          = buffer[idx],
                y          = buffer[idx + 1],
                bestDist   = Infinity,
                bestParent = -1;

            for (let pid of parentIndices) {
                let pIdx = pid * NODE_STRIDE,
                    px   = buffer[pIdx],
                    py   = buffer[pIdx + 1],
                    dx   = x - px,
                    dy   = y - py,
                    dSq  = dx*dx + dy*dy;

                if (dSq < bestDist) {
                    bestDist = dSq;
                    bestParent = pid;
                }
            }

            buffer[idx + 6] = bestParent
        }
    }

    /**
     * Initializes the packet buffer.
     */
    initPackets() {
        let me = this;
        if (!me.packetBuffer) {
            me.packetBuffer = new Float32Array(PACKET_COUNT * PACKET_STRIDE)
        }
    }

    /**
     * @member {Function} renderLoop=this.render.bind(this)
     */
    renderLoop = this.render.bind(this)

    /**
     * Main simulation and render loop.
     * Executed ~60 times per second.
     */
    render() {
        let me = this;

        if (!me.canRender) {
            return
        }

        const
            ctx    = me.context,
            width  = me.canvasSize?.width  || 100,
            height = me.canvasSize?.height || 50;

        me.time += 0.01;

        if (!me.nodeBuffer) me.initNodes(width, height);
        if (!me.agentBuffer) me.initAgents(width, height);
        if (!me.packetBuffer) me.initPackets();

        // Physics Update Steps
        me.updatePhysics(width, height);
        me.updateAgents(width, height);
        me.updatePackets();
        me.updateSparks();

        // Rendering Steps
        ctx.clearRect(0, 0, width, height);

        if (me.gradients.bgGradient) {
            ctx.fillStyle = me.gradients.bgGradient;
            ctx.fillRect(0, 0, width, height)
        }

        me.drawNetwork(ctx, width, height);
        me.drawPackets(ctx);
        me.drawAgents(ctx);
        me.drawShockwaves(ctx);
        me.drawSparks(ctx);

        if (hasRaf) {
            me.animationId = requestAnimationFrame(me.renderLoop)
        } else {
            me.animationId = setTimeout(me.renderLoop, 1000 / 60)
        }
    }

    /**
     * Triggers shockwaves on click.
     * @param {Object} data
     */
    onMouseClick(data) {
        let me = this,
            s  = me.scale;

        me.shockwaves.push({
            x        : data.x,
            y        : data.y,
            age      : 0,
            maxAge   : 40, // Faster, punchier wave
            maxRadius: 300 * s // Scaled radius
        });

        // Spawn Sparks (Data Debris)
        for(let i=0; i<40; i++) {
            let angle = Math.random() * Math.PI * 2,
                speed = (Math.random() * 15 + 5) * s; // Scaled speed
            me.sparks.push({
                x    : data.x,
                y    : data.y,
                vx   : Math.cos(angle) * speed,
                vy   : Math.sin(angle) * speed,
                life : 1.0,
                decay: 0.02 + Math.random() * 0.03
            })
        }
    }

    /**
     * Updates packet logic (Data Flow).
     * Packets spawn randomly at child nodes and travel to their parent nodes,
     * representing data reporting upstream.
     */
    updatePackets() {
        let me = this;
        if (!me.packetBuffer || !me.nodeBuffer) return;

        const
            packets = me.packetBuffer,
            nodes   = me.nodeBuffer,
            pCount  = PACKET_COUNT,
            nCount  = NODE_COUNT,
            s       = me.scale; // Get scale factor

        for (let i = 0; i < pCount; i++) {
            let idx = i * PACKET_STRIDE,
                life = packets[idx + 4];

            if (life <= 0) {
                // Spawn new packet? (Random chance)
                if (Math.random() < 0.02) {
                    // Pick random node (source)
                    let n1 = Math.floor(Math.random() * nCount),
                        idx1 = n1 * NODE_STRIDE,
                        pid = nodes[idx1 + 6]; // Parent ID

                    // Valid targets: Parent (if child), or Child (if parent)
                    // Simplified: Just go Child -> Parent for now (Data reporting)
                    if (pid !== -1) { // If it's a child
                        let idx2 = pid * NODE_STRIDE,
                            x1   = nodes[idx1], y1 = nodes[idx1 + 1],
                            x2   = nodes[idx2], y2 = nodes[idx2 + 1],
                            dx   = x2 - x1,
                            dy   = y2 - y1,
                            dist = Math.sqrt(dx * dx + dy * dy);

                        // Only spawn if connected and close
                        if (dist < 200 * s) { // Scaled distance check
                            packets[idx]     = x1;
                            packets[idx + 1] = y1;
                            let speed        = 4 * s; // Scaled speed
                            packets[idx + 2] = (dx / dist) * speed;
                            packets[idx + 3] = (dy / dist) * speed;
                            packets[idx + 4] = dist / speed // Life = frames to reach target (stays same)
                        }
                    }
                }
            } else {
                // Move
                packets[idx]     += packets[idx + 2];
                packets[idx + 1] += packets[idx + 3];
                packets[idx + 4]-- // Decrease life
            }
        }
    }

    /**
     * Updates spark particles with friction and decay.
     */
    updateSparks() {
        let me = this;
        for (let i = me.sparks.length - 1; i >= 0; i--) {
            let s = me.sparks[i];
            s.x += s.vx;
            s.y += s.vy;
            // Friction (Drag)
            s.vx *= 0.9;
            s.vy *= 0.9;
            s.life -= s.decay;
            if (s.life <= 0) {
                me.sparks.splice(i, 1)
            }
        }
    }

    /**
     * Updates agent positions using **Boid** logic (Seek, Separate).
     * Agents randomly pick a target node, seek it, scan it (transferring energy),
     * and then pick a new target. They also avoid the mouse cursor.
     * @param {Number} width
     * @param {Number} height
     */
    updateAgents(width, height) {
        let me = this;

        if (!me.agentBuffer || !me.nodeBuffer) return;

        const
            agents = me.agentBuffer,
            nodes  = me.nodeBuffer,
            count  = AGENT_COUNT,
            mx     = me.mouse.x,
            my     = me.mouse.y,
            s      = me.scale; // Get scale factor

        for (let i = 0; i < count; i++) {
            let idx = i * AGENT_STRIDE,
                targetIdx = agents[idx + 4],
                state = agents[idx + 5];

            // Behavior 1: Pick a Target
            if (targetIdx === -1 || Math.random() < 0.005) {
                const parentCount = Math.floor(NODE_COUNT * 0.1);
                agents[idx + 4] = Math.floor(Math.random() * parentCount);
                targetIdx = agents[idx + 4];
                agents[idx + 5] = 0;
            }

            // Behavior 2: Seek Target
            if (targetIdx !== -1 && state === 0) {
                let nIdx = targetIdx * NODE_STRIDE,
                    tx   = nodes[nIdx],
                    ty   = nodes[nIdx + 1],
                    dx   = tx - agents[idx],
                    dy   = ty - agents[idx + 1],
                    dist = Math.sqrt(dx*dx + dy*dy);

                if (dist < 10 * s) { // Scaled arrival distance
                    // Arrived! Scan.
                    agents[idx + 5] = 1; // Scan state
                    agents[idx + 2] *= 0.1; // Slow down
                    agents[idx + 3] *= 0.1;

                    // Transfer Energy to Node
                    nodes[nIdx + 8] = 1.0;
                } else {
                    // Steer towards target
                    let force = 0.05 * s; // Scaled steering force
                    agents[idx + 2] += (dx / dist) * force;
                    agents[idx + 3] += (dy / dist) * force;
                }
            } else if (state === 1) {
                if (Math.random() < 0.02) {
                    agents[idx + 4] = -1;
                    agents[idx + 5] = 0;
                    agents[idx + 2] += (Math.random() - 0.5) * 4 * s; // Scaled random burst
                    agents[idx + 3] += (Math.random() - 0.5) * 4 * s;
                }
            }

            // Behavior 3: Mouse Repulsion
            if (mx !== -1000) {
                let dx = agents[idx] - mx,
                    dy = agents[idx + 1] - my,
                    distSq = dx*dx + dy*dy;

                if (distSq < 10000 * s * s) { // Scaled interaction radius squared
                    let dist  = Math.sqrt(distSq),
                        force = (100 * s - dist) / (100 * s); // Scaled force calculation
                    agents[idx + 2] += (dx / dist) * force * 1.5 * s;
                    agents[idx + 3] += (dy / dist) * force * 1.5 * s;
                    agents[idx + 5] = 0
                }
            }

            // Speed Limit & Move
            let speed = Math.sqrt(agents[idx + 2]**2 + agents[idx + 3]**2);
            if (speed > 4 * s) { // Scaled speed limit
                agents[idx + 2] *= (4 * s) / speed;
                agents[idx + 3] *= (4 * s) / speed
            }

            agents[idx]     += agents[idx + 2];
            agents[idx + 1] += agents[idx + 3];

            if (agents[idx] < 0) agents[idx] = width;
            if (agents[idx] > width) agents[idx] = 0;
            if (agents[idx + 1] < 0) agents[idx + 1] = height;
            if (agents[idx + 1] > height) agents[idx + 1] = 0;
        }
    }

    /**
     * Updates node positions using **Cluster Physics**.
     * Handles:
     * 1.  **Cohesion:** Children stick to parents.
     * 2.  **Flow Fields:** Parents drift in organic patterns.
     * 3.  **Topology Mutation:** Nodes can detach and re-parent.
     * 4.  **Interaction:** Mouse repulsion and shockwave explosion.
     * @param {Number} width
     * @param {Number} height
     */
    updatePhysics(width, height) {
        let me = this;

        if (!me.nodeBuffer) return;

        const
            buffer      = me.nodeBuffer,
            mx          = me.mouse.x,
            my          = me.mouse.y,
            parentCount = Math.floor(NODE_COUNT * 0.1),
            s           = me.scale; // Get scale factor

        for (let i = 0; i < NODE_COUNT; i++) {
            let idx = i * NODE_STRIDE,
                parentId = buffer[idx + 6],
                isParent = parentId === -1;

            // --- MUTATION LOGIC (Re-Parenting) ---
            if (!isParent) {
                // 1. Chance to detach (becomes Drifting: -2)
                if (parentId !== -2 && Math.random() < 0.0005) { // Rare event
                    buffer[idx + 6] = -2;
                    // Boost velocity to escape
                    buffer[idx + 2] += (Math.random() - 0.5) * 2 * s;
                    buffer[idx + 3] += (Math.random() - 0.5) * 2 * s
                }

                // 2. Re-attach Logic (if Drifting)
                if (parentId === -2) {
                    // Wander behavior
                    buffer[idx + 2] += (Math.random() - 0.5) * 0.1 * s;
                    buffer[idx + 3] += (Math.random() - 0.5) * 0.1 * s;

                    // Check for new parent
                    for (let p = 0; p < parentCount; p++) {
                        let pIdx = p * NODE_STRIDE,
                            px   = buffer[pIdx],
                            py   = buffer[pIdx + 1],
                            dist = Math.sqrt((px - buffer[idx])**2 + (py - buffer[idx + 1])**2);

                        if (dist < 60 * s) {
                            buffer[idx + 6] = p; // Snap to new parent
                            break
                        }
                    }
                }
            }

            // 1. Cluster Cohesion (Children stick to Parent)
            if (!isParent && buffer[idx + 6] !== -2) { // Normal Child
                let pIdx = parentId * NODE_STRIDE,
                    px   = buffer[pIdx],
                    py   = buffer[pIdx + 1],
                    dx   = px - buffer[idx],
                    dy   = py - buffer[idx + 1],
                    dist = Math.sqrt(dx*dx + dy*dy);

                // Spring force towards parent
                if (dist > 50 * s) { // Ideal distance
                    let force = (dist - 50 * s) * 0.0005; // Constant spring factor is fine
                    buffer[idx + 2] += dx * force;
                    buffer[idx + 3] += dy * force
                }
            }

            // 2. Mouse Repulsion (All nodes)
            if (mx !== -1000) {
                let dx     = buffer[idx] - mx,
                    dy     = buffer[idx + 1] - my,
                    distSq = dx * dx + dy * dy;

                if (distSq < 22500 * s * s) { // 150*s squared
                    let dist  = Math.sqrt(distSq),
                        force = (150 * s - dist) / (150 * s);
                    buffer[idx + 2] += (dx / dist) * force * 0.5 * s;
                    buffer[idx + 3] += (dy / dist) * force * 0.5 * s
                }
            }

            // 3. Shockwave Repulsion (Explosive Force)
            if (me.shockwaves.length > 0) {
                me.shockwaves.forEach(wave => {
                    let progress = wave.age / wave.maxAge;

                    if (progress < 1) {
                        let eased = 1 - Math.pow(1 - progress, 3),
                            wRad  = eased * wave.maxRadius,
                            dx    = buffer[idx] - wave.x,
                            dy    = buffer[idx + 1] - wave.y,
                            dist  = Math.sqrt(dx*dx + dy*dy);

                        // Hit the "Wave Front" (Width matches visual ring ~20px * scale)
                        if (Math.abs(dist - wRad) < 20 * s) {
                            let force = (1 - progress);
                            // Massive Impulse (Throwing)
                            buffer[idx + 2] += (dx / dist) * force * 10 * s;
                            buffer[idx + 3] += (dy / dist) * force * 10 * s
                        }
                    }
                });
            }

            // 4. Physics
            buffer[idx + 2] *= 0.95; // Friction
            buffer[idx + 3] *= 0.95;

            // Energy Decay
            buffer[idx + 8] *= 0.99;

            let drift = isParent ? 0.02 : 0.01;

            // 4. Ambient Drift / Flow Field
            if (isParent) {
                // FLOW FIELD for Parents: Create organic currents
                // Combine Sine/Cosine based on position and time
                let angle = (Math.cos(buffer[idx]     * 0.002 / s + me.time * 0.5) +
                             Math.sin(buffer[idx + 1] * 0.002 / s + me.time * 0.5)) * Math.PI;

                // Accelerate in flow direction
                buffer[idx + 2] += Math.cos(angle) * 0.05 * s;
                buffer[idx + 3] += Math.sin(angle) * 0.05 * s;

                // CONTAINMENT FIELD (Fix for Drift Bias)
                // Gently push nodes back to center if they wander too far
                let cx    = width / 2,
                    cy    = height / 2,
                    dx    = cx - buffer[idx],
                    dy    = cy - buffer[idx + 1],
                    dist  = Math.sqrt(dx * dx + dy * dy),
                    limit = Math.min(width, height) * 0.4; // Keep within 80% of screen center

                if (dist > limit) {
                    let force = (dist - limit) * 0.001; // Soft spring
                    buffer[idx + 2] += (dx / dist) * force;
                    buffer[idx + 3] += (dy / dist) * force
                }
            } else {
                // Random wander for children
                if (Math.abs(buffer[idx + 2]) < 0.2 * s) buffer[idx + 2] += (Math.random() - 0.5) * 0.02 * s;
                if (Math.abs(buffer[idx + 3]) < 0.2 * s) buffer[idx + 3] += (Math.random() - 0.5) * 0.02 * s
            }

            buffer[idx]     += buffer[idx + 2];
            buffer[idx + 1] += buffer[idx + 3];

            // Bounce
            const pad = 20 * s;
            if (buffer[idx] < pad)              { buffer[idx] = pad; buffer[idx + 2] *= -1; }
            if (buffer[idx] > width - pad)      { buffer[idx] = width - pad; buffer[idx + 2] *= -1; }
            if (buffer[idx + 1] < pad)          { buffer[idx + 1] = pad; buffer[idx + 3] *= -1; }
            if (buffer[idx + 1] > height - pad) { buffer[idx + 1] = height - pad; buffer[idx + 3] *= -1; }
        }
    }

    /**
     * Creates and caches gradients.
     * @param {Number} width
     * @param {Number} height
     */
    updateResources(width, height) {
        let me  = this,
            ctx = me.context;

        if (!ctx) return;

        const
            themeColors = me.constructor.colors[me.theme],
            gradient    = ctx.createLinearGradient(0, 0, width, height);

        gradient.addColorStop(0, themeColors.background[0]);
        gradient.addColorStop(1, themeColors.background[1]);

        me.gradients.bgGradient = gradient
    }

    /**
     * @param {Object} size
     * @param {Number} size.height
     * @param {Number} size.width
     */
    updateSize(size) {
        let me = this;

        me.canvasSize = size;
        // Reference resolution: 1920x1080.
        // Square root of area ratio gives a balanced linear scale factor.
        me.scale = Math.sqrt((size.width * size.height) / 2073600);

        if (me.context) {
            me.context.canvas.width  = size.width;
            me.context.canvas.height = size.height;
            // FIX: Always re-init nodes on resize to fix "top-left blob" issue
            me.initNodes(size.width, size.height);
            me.initAgents(size.width, size.height);
            me.updateResources(size.width, size.height)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(HomeCanvas));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2NhbnZhcy92ZW5kb3JzLWFwcHNfcG9ydGFsX2NhbnZhc19Ib21lQ2FudmFzX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBEQUFPO0FBQzFCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3Q0FBd0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUSxPQUFPO0FBQy9CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSwwQkFBMEIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9hcHBzL3BvcnRhbC9jYW52YXMvQmFzZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvcG9ydGFsL2NhbnZhcy9Ib21lQ2FudmFzLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTmVvQmFzZSBmcm9tICcuLi8uLi8uLi9zcmMvY29yZS9CYXNlLm1qcyc7XG5cbi8qKlxuICogQHN1bW1hcnkgQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgUG9ydGFsIENhbnZhcyBSZW5kZXJlcnMuXG4gKlxuICogVGhpcyBjbGFzcyBzZXJ2ZXMgYXMgdGhlIGZvdW5kYXRpb24gZm9yIHRoZSBzcGVjaWFsaXplZCBjYW52YXMgdmlzdWFsaXphdGlvbnMgKEhlYWRlciwgSG9tZSwgU2VydmljZXMsIFRpY2tldClcbiAqIHRoYXQgcnVuIHdpdGhpbiB0aGUgKipOZW8ubWpzIENhbnZhcyBTaGFyZWRXb3JrZXIqKi5cbiAqXG4gKiBJdCBjcmVhdGVzIGhlbHBlciBzaW5nbGV0b25zIHRoYXQgbWFuYWdlIHRoZWlyIG93biBgT2Zmc2NyZWVuQ2FudmFzYCBpbnN0YW5jZXMsIHByb3ZpZGluZyBhIHN0YW5kYXJkaXplZFxuICogYXJjaGl0ZWN0dXJlIGZvcjpcbiAqIC0gKipMaWZlY3ljbGUgTWFuYWdlbWVudDoqKiBJbml0aWFsaXphdGlvbiAoYGluaXRHcmFwaGApLCBkZXN0cnVjdGlvbiAoYGNsZWFyR3JhcGhgKSwgYW5kIHJlc291cmNlIGNsZWFudXAuXG4gKiAtICoqUmVuZGVyIExvb3AgQ29udHJvbDoqKiBVbmlmaWVkIGByZW5kZXJgIGxvb3Agd2l0aCBwYXVzZS9yZXN1bWUgY2FwYWJpbGl0aWVzIGFuZCBmcmFtZSBzY2hlZHVsaW5nLlxuICogLSAqKkNvbnRleHQgTWFuYWdlbWVudDoqKiBSb2J1c3QgaGFuZGxpbmcgb2YgYE9mZnNjcmVlbkNhbnZhc2AgdHJhbnNmZXIgYW5kIGNvbnRleHQgYWNxdWlzaXRpb24gdmlhIGB3YWl0Rm9yQ2FudmFzYC5cbiAqIC0gKipTaGFyZWQgU3RhdGU6KiogQ29tbW9uIHN0YXRlIG1hbmFnZW1lbnQgZm9yIG1vdXNlIGludGVyYWN0aW9uLCB0aW1lLCBhbmQgdGhlbWluZy5cbiAqXG4gKiBUaGVzZSByZW5kZXJlcnMgb3BlcmF0ZSBvZmYgdGhlIG1haW4gdGhyZWFkIHRvIGVuc3VyZSBoaWdoLXBlcmZvcm1hbmNlLCA2MGZwcyBhbmltYXRpb25zIHdpdGhvdXRcbiAqIGJsb2NraW5nIHRoZSBVSS5cbiAqXG4gKiBAY2xhc3MgUG9ydGFsLmNhbnZhcy5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIEJhc2UgZXh0ZW5kcyBOZW9CYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J1BvcnRhbC5jYW52YXMuQmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnUG9ydGFsLmNhbnZhcy5CYXNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW90ZSBtZXRob2QgYWNjZXNzXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gcmVtb3RlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHJlbW90ZToge1xuICAgICAgICAgICAgYXBwOiBbXG4gICAgICAgICAgICAgICAgJ2NsZWFyR3JhcGgnLFxuICAgICAgICAgICAgICAgICdpbml0R3JhcGgnLFxuICAgICAgICAgICAgICAgICdwYXVzZScsXG4gICAgICAgICAgICAgICAgJ3Jlc3VtZScsXG4gICAgICAgICAgICAgICAgJ3NldFRoZW1lJyxcbiAgICAgICAgICAgICAgICAndXBkYXRlTW91c2VTdGF0ZScsXG4gICAgICAgICAgICAgICAgJ3VwZGF0ZVNpemUnXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYWN0aXZlIGNvbG9yIHRoZW1lICgnbGlnaHQnIG9yICdkYXJrJykuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gdGhlbWVfPSdsaWdodCdcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB0aGVtZV86ICdsaWdodCdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gYW5pbWF0aW9uSWQ9bnVsbFxuICAgICAqL1xuICAgIGFuaW1hdGlvbklkID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBjYW52YXNJZD1udWxsXG4gICAgICovXG4gICAgY2FudmFzSWQgPSBudWxsXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGNhbnZhc1NpemU9bnVsbFxuICAgICAqL1xuICAgIGNhbnZhc1NpemUgPSBudWxsXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2Zmc2NyZWVuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfG51bGx9IGNvbnRleHQ9bnVsbFxuICAgICAqL1xuICAgIGNvbnRleHQgPSBudWxsXG4gICAgLyoqXG4gICAgICogQ2FjaGUgZm9yIHJldXNhYmxlIGdyYWRpZW50cyB0byBwcmV2ZW50IEdDLlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gZ3JhZGllbnRzPXt9XG4gICAgICovXG4gICAgZ3JhZGllbnRzID0ge31cbiAgICAvKipcbiAgICAgKiBGbGFnIHRvIHBhdXNlIHRoZSByZW5kZXIgbG9vcC5cbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc1BhdXNlZD1mYWxzZVxuICAgICAqL1xuICAgIGlzUGF1c2VkID0gZmFsc2VcbiAgICAvKipcbiAgICAgKiBUcmFja2VkIG1vdXNlIHBvc2l0aW9uIGZvciBpbnRlcmFjdGl2ZSBwaHlzaWNzLlxuICAgICAqIEluaXRpYWxpemUgb2ZmLXNjcmVlbiB0byBwcmV2ZW50IHN0YXJ0dXAgaml0dGVycy5cbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vdXNlPXt4OiAtMTAwMCwgeTogLTEwMDB9XG4gICAgICovXG4gICAgbW91c2UgPSB7eDogLTEwMDAsIHk6IC0xMDAwfVxuICAgIC8qKlxuICAgICAqIEdsb2JhbCBzaW11bGF0aW9uIHRpbWUuXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSB0aW1lPTBcbiAgICAgKi9cbiAgICB0aW1lID0gMFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7RnVuY3Rpb259IHJlbmRlckxvb3A9dGhpcy5yZW5kZXIuYmluZCh0aGlzKVxuICAgICAqL1xuICAgIHJlbmRlckxvb3AgPSB0aGlzLnJlbmRlci5iaW5kKHRoaXMpXG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGB0aGVtZWAgY29uZmlnIGlzIGNoYW5nZWQuXG4gICAgICogVXBkYXRlcyB0aGUgcmVzb3VyY2UgY2FjaGUgKGdyYWRpZW50cywgY29sb3JzKSB0byByZWZsZWN0IHRoZSBuZXcgdGhlbWUgaW1tZWRpYXRlbHkuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICovXG4gICAgYWZ0ZXJTZXRUaGVtZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICYmIHRoaXMuY2FudmFzU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVSZXNvdXJjZXM/Lih0aGlzLmNhbnZhc1NpemUud2lkdGgsIHRoaXMuY2FudmFzU2l6ZS5oZWlnaHQpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGNhbnZhcyBpcyByZWFkeSB0byByZW5kZXIuXG4gICAgICogUmV0dXJucyB0cnVlIG9ubHkgaWYgdGhlIGNvbnRleHQgZXhpc3RzIGFuZCB0aGUgc2ltdWxhdGlvbiBpcyBub3QgcGF1c2VkLlxuICAgICAqIFN1YmNsYXNzZXMgc2hvdWxkIGNhbGwgdGhpcyBhdCB0aGUgc3RhcnQgb2YgdGhlaXIgYHJlbmRlcmAgbG9vcC5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgY2FuUmVuZGVyKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuICAgICAgICByZXR1cm4gISEobWUuY29udGV4dCAmJiAhbWUuaXNQYXVzZWQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBncmFwaCBzdGF0ZSBhbmQgc3RvcHMgdGhlIHJlbmRlciBsb29wLlxuICAgICAqIFVzZSB0aGlzIHRvIGNsZWFudXAgcmVzb3VyY2VzIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgb3IgdW5tb3VudGVkLlxuICAgICAqL1xuICAgIGNsZWFyR3JhcGgoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG4gICAgICAgIG1lLmNvbnRleHQgICAgID0gbnVsbDtcbiAgICAgICAgbWUuY2FudmFzSWQgICAgPSBudWxsO1xuICAgICAgICBtZS5jYW52YXNTaXplICA9IG51bGw7XG4gICAgICAgIG1lLmFuaW1hdGlvbklkID0gbnVsbDtcbiAgICAgICAgbWUuaXNQYXVzZWQgICAgPSBmYWxzZTtcbiAgICAgICAgbWUuZ3JhZGllbnRzICAgPSB7fTtcbiAgICAgICAgbWUubW91c2UgICAgICAgPSB7eDogLTEwMDAsIHk6IC0xMDAwfTtcbiAgICAgICAgbWUudGltZSAgICAgICAgPSAwXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIGNhbnZhcyBjb250ZXh0LlxuICAgICAqIFN0YXJ0cyB0aGUgcG9sbGluZyBtZWNoYW5pc20gdG8gd2FpdCBmb3IgdGhlIE9mZnNjcmVlbkNhbnZhcyB0cmFuc2ZlciBmcm9tIHRoZSBNYWluIFRocmVhZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRzLmNhbnZhc0lkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdHMud2luZG93SWRcbiAgICAgKi9cbiAgICBpbml0R3JhcGgoe2NhbnZhc0lkLCB3aW5kb3dJZH0pIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBoYXNDaGFuZ2UgPSBtZS5jYW52YXNJZCAhPT0gY2FudmFzSWQ7XG5cbiAgICAgICAgbWUuY2FudmFzSWQgPSBjYW52YXNJZDtcblxuICAgICAgICBtZS53YWl0Rm9yQ2FudmFzKGNhbnZhc0lkLCB3aW5kb3dJZCwgaGFzQ2hhbmdlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhvb2sgZm9yIHN1YmNsYXNzZXMgdG8gaGFuZGxlIG1vdXNlIGNsaWNrcy5cbiAgICAgKiBDYWxsZWQgYnkgYHVwZGF0ZU1vdXNlU3RhdGVgIHdoZW4gYSBjbGljayBldmVudCBpcyByZWNlaXZlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uTW91c2VDbGljayhkYXRhKSB7fVxuXG4gICAgLyoqXG4gICAgICogUGF1c2VzIHRoZSBzaW11bGF0aW9uLlxuICAgICAqIFRoZSByZW5kZXIgbG9vcCB3aWxsIGV4aXQgZWFybHkgd2hpbGUgYGlzUGF1c2VkYCBpcyB0cnVlLlxuICAgICAqL1xuICAgIHBhdXNlKCkge1xuICAgICAgICB0aGlzLmlzUGF1c2VkID0gdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFic3RyYWN0IHJlbmRlciBtZXRob2QuXG4gICAgICogU3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byBkcmF3IHRoZSBmcmFtZS5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7fVxuXG4gICAgLyoqXG4gICAgICogUmVzdW1lcyB0aGUgc2ltdWxhdGlvbi5cbiAgICAgKiBJZiB0aGUgc2ltdWxhdGlvbiB3YXMgcGF1c2VkLCB0aGlzIHJlc3RhcnRzIHRoZSByZW5kZXIgbG9vcC5cbiAgICAgKi9cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmlzUGF1c2VkKSB7XG4gICAgICAgICAgICBtZS5pc1BhdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgbWUucmVuZGVyTG9vcCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHBvc2VkIG1ldGhvZCBmb3IgUmVtb3RlIEFjY2VzcyB0byB0cmlnZ2VyIHRoZSByZWFjdGl2ZSBjb25maWcgc2V0dGVyLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIHNldFRoZW1lKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudGhlbWUgPSB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGxvY2FsIG1vdXNlIHN0YXRlIGZyb20gbWFpbiB0aHJlYWQgZXZlbnRzLlxuICAgICAqIERlbGVnYXRlcyBjbGljayBldmVudHMgdG8gYG9uTW91c2VDbGlja2AuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkYXRhLmNsaWNrXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2RhdGEubGVhdmVdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtkYXRhLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtkYXRhLnldXG4gICAgICovXG4gICAgdXBkYXRlTW91c2VTdGF0ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKGRhdGEubGVhdmUpIHtcbiAgICAgICAgICAgIG1lLm1vdXNlLnggPSAtMTAwMDtcbiAgICAgICAgICAgIG1lLm1vdXNlLnkgPSAtMTAwMFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRhdGEueCAhPT0gdW5kZWZpbmVkKSBtZS5tb3VzZS54ID0gZGF0YS54O1xuICAgICAgICAgICAgaWYgKGRhdGEueSAhPT0gdW5kZWZpbmVkKSBtZS5tb3VzZS55ID0gZGF0YS55O1xuXG4gICAgICAgICAgICBpZiAoZGF0YS5jbGljaykge1xuICAgICAgICAgICAgICAgIG1lLm9uTW91c2VDbGljayhkYXRhKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgY2FudmFzIHNpemUgYW5kIHJlc2l6ZXMgdGhlIGludGVybmFsIGNvbnRleHQuXG4gICAgICogVHJpZ2dlcnMgYHVwZGF0ZVJlc291cmNlc2AgaG9vayB0byBhbGxvdyBzdWJjbGFzc2VzIHRvIHJlZ2VuZXJhdGUgYnVmZmVycy9ncmFkaWVudHMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNpemVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2l6ZS5oZWlnaHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2l6ZS53aWR0aFxuICAgICAqL1xuICAgIHVwZGF0ZVNpemUoc2l6ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmNhbnZhc1NpemUgPSBzaXplO1xuXG4gICAgICAgIGlmIChtZS5jb250ZXh0KSB7XG4gICAgICAgICAgICBtZS5jb250ZXh0LmNhbnZhcy53aWR0aCAgPSBzaXplLndpZHRoO1xuICAgICAgICAgICAgbWUuY29udGV4dC5jYW52YXMuaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgICAvLyBDYWxscyB0aGUgaG9vayB0byByZS1nZW5lcmF0ZSByZXNvdXJjZXMgaWYgaW1wbGVtZW50ZWRcbiAgICAgICAgICAgIG1lLnVwZGF0ZVJlc291cmNlcz8uKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUG9sbHMgZm9yIHRoZSBPZmZzY3JlZW5DYW52YXMgdW50aWwgaXQgaXMgYXZhaWxhYmxlIGluIHRoZSBXb3JrZXIncyBgY2FudmFzV2luZG93TWFwYC5cbiAgICAgKiBPbmNlIGZvdW5kLCBpdCBpbml0aWFsaXplcyB0aGUgY29udGV4dCBhbmQgc3RhcnRzIHRoZSByZW5kZXIgbG9vcC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2FudmFzSWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gd2luZG93SWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGhhc0NoYW5nZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB3YWl0Rm9yQ2FudmFzKGNhbnZhc0lkLCB3aW5kb3dJZCwgaGFzQ2hhbmdlKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY2FudmFzID0gTmVvLmN1cnJlbnRXb3JrZXIuY2FudmFzV2luZG93TWFwW2NhbnZhc0lkXT8uW3dpbmRvd0lkXTtcblxuICAgICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgICAgICBtZS5jb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgIC8vIFN0YW5kYXJkaXplIHNpemUgdXBkYXRlXG4gICAgICAgICAgICBtZS51cGRhdGVTaXplKHt3aWR0aDogY2FudmFzLndpZHRoLCBoZWlnaHQ6IGNhbnZhcy5oZWlnaHR9KTtcblxuICAgICAgICAgICAgLy8gT3B0aW9uYWwgaG9vayBmb3Igc3ViY2xhc3Nlc1xuICAgICAgICAgICAgbWUub25HcmFwaE1vdW50ZWQ/LihjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuXG4gICAgICAgICAgICBpZiAoaGFzQ2hhbmdlICYmICFtZS5hbmltYXRpb25JZCkge1xuICAgICAgICAgICAgICAgIG1lLnJlbmRlckxvb3AoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dChtZS53YWl0Rm9yQ2FudmFzLmJpbmQobWUsIGNhbnZhc0lkLCB3aW5kb3dJZCwgaGFzQ2hhbmdlKSwgNTApXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEJhc2UpO1xuIiwiaW1wb3J0IEJhc2UgZnJvbSAnLi9CYXNlLm1qcyc7XG5cbmNvbnN0XG4gICAgaGFzUmFmICAgICAgICAgICA9IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09ICdmdW5jdGlvbicsXG4gICAgUFJJTUFSWSAgICAgICAgICA9ICcjM0U2M0REJyxcbiAgICBTRUNPTkRBUlkgICAgICAgID0gJyM1MzZERkUnLFxuICAgIEhJR0hMSUdIVCAgICAgICAgPSAnIzAwQkZGRicsIC8vIERlZXAgU2t5IEJsdWUgKEhpZ2ggQ29udHJhc3QpXG4gICAgQ09OTkVDVElPTl9DT0xPUiA9ICcjODA4MDgwJyxcbiAgICBOT0RFX0NPVU5UICAgICAgID0gMTUwLFxuICAgIE5PREVfU1RSSURFICAgICAgPSA5LCAvLyB4LCB5LCB2eCwgdnksIHJhZGl1cywgbGF5ZXIsIHBhcmVudElkLCBwaGFzZSwgZW5lcmd5XG4gICAgQUdFTlRfQ09VTlQgICAgICA9IDIwLFxuICAgIEFHRU5UX1NUUklERSAgICAgPSA2LCAvLyB4LCB5LCB2eCwgdnksIHRhcmdldElkeCwgc3RhdGVcbiAgICBQQUNLRVRfQ09VTlQgICAgID0gMjAsXG4gICAgUEFDS0VUX1NUUklERSAgICA9IDU7IC8vIHgsIHksIHZ4LCB2eSwgbGlmZSAoMC0xKVxuXG4vKipcbiAqIEBzdW1tYXJ5IFNoYXJlZFdvcmtlciByZW5kZXJlciBmb3IgdGhlIFBvcnRhbCBIb21lIFwiTmV1cmFsIFN3YXJtXCIgYmFja2dyb3VuZC5cbiAqXG4gKiBJbXBsZW1lbnRzIHRoZSAqKlwiTmV1cmFsIFN3YXJtXCIqKiB2aXN1YWwgdGhlbWUsIGEgZHluYW1pYywgbXV0YWJsZSBuZXR3b3JrIHNpbXVsYXRpb24gdGhhdFxuICogdmlzdWFsaXplcyB0aGUgTmVvLm1qcyBBcHBsaWNhdGlvbiBFbmdpbmUgYXMgYSBsaXZpbmcgZWNvc3lzdGVtLlxuICpcbiAqICoqVmlzdWFsIEFyY2hpdGVjdHVyZToqKlxuICogMS4gKipMaXZpbmcgVG9wb2xvZ3kgKFRoZSBHcmFwaCk6KiogTm9kZXMgYXJlIG5vdCBzdGF0aWM7IHRoZXkgZm9ybSBoaWVyYXJjaGljYWwgY2x1c3RlcnMgcmVwcmVzZW50aW5nXG4gKiAgICBDb21wb25lbnRzIHdpdGhpbiBDb250YWluZXJzLiBUaGUgdG9wb2xvZ3kgaXMgbXV0YWJsZSwgd2l0aCBzdWItY2x1c3RlcnMgb2NjYXNpb25hbGx5IGRldGFjaGluZyxcbiAqICogICAgZHJpZnRpbmcsIGFuZCByZS1wYXJlbnRpbmcgKFZpc3VhbGl6aW5nIFwiQXRvbWljIE1vdmVzXCIpLlxuICogMi4gKipBdXRvbm9tb3VzIEFnZW50cyAoVGhlIE5ldXJhbCBMaW5rKToqKiBcIlNlZWtlciBEcm9uZXNcIiByb2FtIHRoZSBncmFwaCB1c2luZyBCb2lkIGJlaGF2aW9yXG4gKiAgICAoU2VwYXJhdGlvbiwgQWxpZ25tZW50LCBDb2hlc2lvbikuIFRoZXkgXCJzY2FuXCIgbm9kZXMsIHRyYW5zZmVycmluZyBlbmVyZ3kgYW5kIHRyaWdnZXJpbmdcbiAqICAgIHZpc3VhbCBoaWdobGlnaHRzLCByZXByZXNlbnRpbmcgdGhlIGFjdGl2ZSBpbnRlbGxpZ2VuY2Ugb2YgdGhlIGZyYW1ld29yay5cbiAqIDMuICoqRGF0YSBGbG93IChTaWduYWwgUGFja2V0cyk6KiogUHVsc2VzIG9mIGxpZ2h0IHRyYXZlbCBhbG9uZyBjb25uZWN0aW9ucyBmcm9tIGNoaWxkIHRvIHBhcmVudCxcbiAqICAgIHZpc3VhbGl6aW5nIHRoZSBmbG93IG9mIGV2ZW50cyBhbmQgZGF0YSB1cHN0cmVhbS5cbiAqIDQuICoqQXRtb3NwaGVyZSAoUGFyYWxsYXgpOioqIEEgbXVsdGktbGF5ZXJlZCBkZXB0aCBzeXN0ZW0gY3JlYXRlcyBhIHZvbHVtZXRyaWMgZmVlbCwgZGlzdGluZ3Vpc2hpbmdcbiAqICAgIGZvcmVncm91bmQgXCJhY3RpdmVcIiBub2RlcyBmcm9tIGJhY2tncm91bmQgXCJjb250ZXh0XCIgbm9kZXMuXG4gKlxuICogKipSZXNwb25zaXZlIEFyY2hpdGVjdHVyZSAoUmVmZXJlbmNlIFZpZXdwb3J0KToqKlxuICogVG8gZW5zdXJlIGEgY29uc2lzdGVudCBleHBlcmllbmNlIGFjcm9zcyBkZXZpY2VzIChmcm9tIE1vYmlsZSB0byA0SyksIHRoZSBzaW11bGF0aW9uIHVzZXMgYSAqKlJlZmVyZW5jZSBWaWV3cG9ydCBTdHJhdGVneSoqLlxuICogLSAqKkJhc2VsaW5lOioqIDE5MjB4MTA4MCBpcyBkZWZpbmVkIGFzIHNjYWxlIGAxLjBgLlxuICogLSAqKkR5bmFtaWMgU2NhbGluZzoqKiBPbiByZXNpemUsIGEgYHNjYWxlYCBmYWN0b3IgaXMgY2FsY3VsYXRlZDogYHNxcnQoKHdpZHRoICogaGVpZ2h0KSAvICgxOTIwICogMTA4MCkpYC5cbiAqIC0gKipOb3JtYWxpemF0aW9uOioqIEFsbCBwaHlzaWNzIGNvbnN0YW50cyAodmVsb2NpdHksIGZvcmNlKSwgc3BhdGlhbCBkaW1lbnNpb25zIChkaXN0YW5jZXMsIHJhZGlpKSwgYW5kXG4gKiAgIHZpc3VhbCBwcm9wZXJ0aWVzIChzdHJva2Ugd2lkdGgpIGFyZSBtdWx0aXBsaWVkIGJ5IHRoaXMgYHNjYWxlYC5cbiAqIC0gKipEZW5zaXR5IENvbnRyb2w6KiogT24gc21hbGwgc2NyZWVucyAoYHNjYWxlIDwgMC41YCksIHRoZSBiYWNrZ3JvdW5kIGxheWVyIGlzIGN1bGxlZCB0byBwcmV2ZW50IHZpc3VhbCBub2lzZS5cbiAqXG4gKiAqKlRoZW1lIFN5c3RlbToqKlxuICogU3VwcG9ydHMgZHluYW1pYyBgbGlnaHRgIGFuZCBgZGFya2AgbW9kZXMgdmlhIHRoZSBgdGhlbWVgIGNvbmZpZy5cbiAqIC0gKipQYWxldHRlOioqIEEgc3RhdGljIGBjb2xvcnNgIG1hcCBkZWZpbmVzIHNlbWFudGljIGNvbG9yIHNsb3RzIChhZ2VudEhlYWQsIHNwYXJrLCBldGMuKSBmb3IgZWFjaCBtb2RlLlxuICogLSAqKkhvdC1Td2FwcGluZzoqKiBDaGFuZ2luZyB0aGUgYHRoZW1lYCBjb25maWcgdHJpZ2dlcnMgYHVwZGF0ZVJlc291cmNlc2AgdG8gcmVnZW5lcmF0ZSBncmFkaWVudHMgYW5kXG4gKiAgIGltbWVkaWF0ZWx5IGFsdGVycyByZW5kZXJpbmcgY29sb3JzIGluIHRoZSBuZXh0IGZyYW1lIHdpdGhvdXQgcmUtaW5pdGlhbGl6aW5nIGJ1ZmZlcnMuXG4gKlxuICogKipQZXJmb3JtYW5jZSBBcmNoaXRlY3R1cmUgKFplcm8tQWxsb2NhdGlvbik6KipcbiAqIFRvIG1haW50YWluIDYwZnBzIG9uIGhpZ2gtcmVmcmVzaCBkaXNwbGF5cyB3aXRob3V0IEdDIHN0dXR0ZXJzLCB0aGlzIGNsYXNzIGVtcGxveXMgYSAqKlplcm8tQWxsb2NhdGlvbioqIHN0cmF0ZWd5IGR1cmluZyB0aGUgcmVuZGVyIGxvb3AuXG4gKiAxLiAqKlR5cGVkQXJyYXkgQnVmZmVyczoqKiBBbGwgZW50aXR5IGRhdGEgKE5vZGVzLCBBZ2VudHMsIFBhY2tldHMpIGlzIHN0b3JlZCBpbiBwcmUtYWxsb2NhdGVkIGBGbG9hdDMyQXJyYXlgIGJ1ZmZlcnMuXG4gKiAyLiAqKklubGluZWQgUGh5c2ljczoqKiBWZWN0b3IgY2FsY3VsYXRpb25zIGFyZSBwZXJmb3JtZWQgaW5saW5lIHdpdGhvdXQgY3JlYXRpbmcgdGVtcG9yYXJ5IE9iamVjdHMuXG4gKiAzLiAqKkdyYWRpZW50IENhY2hpbmc6KiogQ2FudmFzR3JhZGllbnRzIGFyZSBjcmVhdGVkIG9ubHkgb24gcmVzaXplIChgdXBkYXRlUmVzb3VyY2VzYCkgYW5kIGNhY2hlZC5cbiAqXG4gKiAqKk5vZGUgQnVmZmVyIExheW91dCAoRmxvYXQzMkFycmF5KToqKlxuICogLSAwOiB4IChQb3NpdGlvbiBYKVxuICogLSAxOiB5IChQb3NpdGlvbiBZKVxuICogLSAyOiB2eCAoVmVsb2NpdHkgWClcbiAqIC0gMzogdnkgKFZlbG9jaXR5IFkpXG4gKiAtIDQ6IHJhZGl1cyAoVmlzdWFsIHNpemUpXG4gKiAtIDU6IGxheWVyIChQYXJhbGxheCBkZXB0aDogMD1iYWNrLCAxPW1pZCwgMj1mcm9udClcbiAqIC0gNjogcGFyZW50SWQgKEluZGV4IG9mIHBhcmVudCBub2RlLCAtMSBpZiBwYXJlbnQsIC0yIGlmIGRyaWZ0aW5nKVxuICogLSA3OiBwaGFzZSAoQW5pbWF0aW9uIG9mZnNldCBmb3IgYnJlYXRoaW5nKVxuICogLSA4OiBlbmVyZ3kgKEludGVyYWN0aW9uIHN0YXRlLCAwLTEpXG4gKlxuICogKipBZ2VudCBCdWZmZXIgTGF5b3V0IChGbG9hdDMyQXJyYXkpOioqXG4gKiAtIDA6IHhcbiAqIC0gMTogeVxuICogLSAyOiB2eFxuICogLSAzOiB2eVxuICogLSA0OiB0YXJnZXRJZHggKEluZGV4IG9mIHRhcmdldCBub2RlLCAtMSBpZiB3YW5kZXJpbmcpXG4gKiAtIDU6IHN0YXRlICgwPW1vdmluZywgMT1zY2FubmluZylcbiAqXG4gKiAqKlBhY2tldCBCdWZmZXIgTGF5b3V0IChGbG9hdDMyQXJyYXkpOioqXG4gKiAtIDA6IHhcbiAqIC0gMTogeVxuICogLSAyOiB2eFxuICogLSAzOiB2eVxuICogLSA0OiBsaWZlIChGcmFtZXMgcmVtYWluaW5nLCAwLTEgbm9ybWFsaXplZCBmb3IgYWxwaGEpXG4gKlxuICogQGNsYXNzIFBvcnRhbC5jYW52YXMuSG9tZUNhbnZhc1xuICogQGV4dGVuZHMgUG9ydGFsLmNhbnZhcy5CYXNlXG4gKiBAc2luZ2xldG9uXG4gKi9cbmNsYXNzIEhvbWVDYW52YXMgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29sb3JzID0ge1xuICAgICAgICBkYXJrOiB7XG4gICAgICAgICAgICBhZ2VudEhlYWQgOiAnI0ZGRkZGRicsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiBbJ3JnYmEoNjIsIDk5LCAyMjEsIDAuMTUpJywgJ3JnYmEoMTM5LCAxNjYsIDI1NSwgMC4xNSknXSxcbiAgICAgICAgICAgIG5vZGVIaWdoICA6ICcjRkZGRkZGJyxcbiAgICAgICAgICAgIHBhY2tldCAgICA6ICcjRkZGRkZGJyxcbiAgICAgICAgICAgIHNob2Nrd2F2ZSA6ICcjRkZGRkZGJyxcbiAgICAgICAgICAgIHNwYXJrICAgICA6ICcjNEIwMDgyJ1xuICAgICAgICB9LFxuICAgICAgICBsaWdodDoge1xuICAgICAgICAgICAgYWdlbnRIZWFkIDogJyMzRTYzREQnLCAvLyBQUklNQVJZXG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiBbJ3JnYmEoNjIsIDk5LCAyMjEsIDAuMDUpJywgJ3JnYmEoMTM5LCAxNjYsIDI1NSwgMC4wNSknXSxcbiAgICAgICAgICAgIG5vZGVIaWdoICA6ICcjM0U2M0REJywgLy8gUFJJTUFSWVxuICAgICAgICAgICAgcGFja2V0ICAgIDogJyMzRTYzREQnLCAvLyBQUklNQVJZXG4gICAgICAgICAgICBzaG9ja3dhdmUgOiAnIzNFNjNERCcsIC8vIFBSSU1BUllcbiAgICAgICAgICAgIHNwYXJrICAgICA6ICcjNEIwMDgyJ1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdQb3J0YWwuY2FudmFzLkhvbWVDYW52YXMnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ1BvcnRhbC5jYW52YXMuSG9tZUNhbnZhcycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaW5nbGV0b249dHJ1ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzaW5nbGV0b246IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcmUtYWxsb2NhdGVkIGJ1ZmZlciBmb3IgYWdlbnQgZGF0YSAoU2Vla2VyIERyb25lcykuXG4gICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fG51bGx9IGFnZW50QnVmZmVyPW51bGxcbiAgICAgKi9cbiAgICBhZ2VudEJ1ZmZlciA9IG51bGxcbiAgICAvKipcbiAgICAgKiBQcmUtYWxsb2NhdGVkIGJ1ZmZlciBmb3Igbm9kZSBkYXRhIChUaGUgR3JhcGgpLlxuICAgICAqIEBtZW1iZXIge0Zsb2F0MzJBcnJheXxudWxsfSBub2RlQnVmZmVyPW51bGxcbiAgICAgKi9cbiAgICBub2RlQnVmZmVyID0gbnVsbFxuICAgIC8qKlxuICAgICAqIFByZS1hbGxvY2F0ZWQgYnVmZmVyIGZvciBkYXRhIHBhY2tldHMgKFNpZ25hbCBQdWxzZXMpLlxuICAgICAqIEBtZW1iZXIge0Zsb2F0MzJBcnJheXxudWxsfSBwYWNrZXRCdWZmZXI9bnVsbFxuICAgICAqL1xuICAgIHBhY2tldEJ1ZmZlciA9IG51bGxcbiAgICAvKipcbiAgICAgKiBBY3RpdmUgc2hvY2t3YXZlIGVmZmVjdHMuXG4gICAgICogQG1lbWJlciB7T2JqZWN0W119IHNob2Nrd2F2ZXM9W11cbiAgICAgKi9cbiAgICBzaG9ja3dhdmVzID0gW11cbiAgICAvKipcbiAgICAgKiBBY3RpdmUgc3BhcmsgcGFydGljbGVzIChEYXRhIERlYnJpcykuXG4gICAgICogQG1lbWJlciB7T2JqZWN0W119IHNwYXJrcz1bXVxuICAgICAqL1xuICAgIHNwYXJrcyA9IFtdXG4gICAgLyoqXG4gICAgICogU2NhbGluZyBmYWN0b3IgcmVsYXRpdmUgdG8gYSAxOTIweDEwODAgcmVmZXJlbmNlIHZpZXdwb3J0LlxuICAgICAqIFVzZWQgdG8gZW5zdXJlIGNvbnNpc3RlbnQgcGh5c2ljcyBhbmQgdmlzdWFscyBhY3Jvc3MgcmVzb2x1dGlvbnMuXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSBzY2FsZT0xXG4gICAgICovXG4gICAgc2NhbGUgPSAxXG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGdyYXBoIHN0YXRlIGFuZCBzdG9wcyB0aGUgcmVuZGVyIGxvb3AuXG4gICAgICogVXNlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgZGVzdHJveWVkIG9yIHRoZSByb3V0ZSBjaGFuZ2VzLlxuICAgICAqL1xuICAgIGNsZWFyR3JhcGgoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG4gICAgICAgIHN1cGVyLmNsZWFyR3JhcGgoKTtcbiAgICAgICAgbWUubm9kZUJ1ZmZlciAgID0gbnVsbDtcbiAgICAgICAgbWUuYWdlbnRCdWZmZXIgID0gbnVsbDtcbiAgICAgICAgbWUucGFja2V0QnVmZmVyID0gbnVsbDtcbiAgICAgICAgbWUuc2hvY2t3YXZlcyAgID0gW107XG4gICAgICAgIG1lLnNwYXJrcyAgICAgICA9IFtdO1xuICAgICAgICBtZS5zY2FsZSAgICAgICAgPSAxXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSG9vayB0byBpbml0aWFsaXplIG5vZGVzIGFuZCBhZ2VudHMgYWZ0ZXIgY29udGV4dCBpcyByZWFkeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgKi9cbiAgICBvbkdyYXBoTW91bnRlZCh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMudXBkYXRlU2l6ZSh7d2lkdGgsIGhlaWdodH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIGF1dG9ub21vdXMgYWdlbnRzIChTZWVrZXIgRHJvbmVzKS5cbiAgICAgKlxuICAgICAqICoqVmlzdWFsczoqKlxuICAgICAqIC0gKipIZWFkOioqIEEgc29saWQgY2lyY2xlIGluZGljYXRpbmcgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgKiAtICoqVHJhaWw6KiogQSBmYWRpbmcgbGluZSBkcmF3biBvcHBvc2l0ZSB0byB2ZWxvY2l0eSwgc2ltdWxhdGluZyBtb3Rpb24gYmx1ci5cbiAgICAgKiAtICoqU2NhbiBFZmZlY3Q6KiogQSBwdWxzaW5nIHJpbmcgd2hlbiB0aGUgYWdlbnQgcmVhY2hlcyBhIG5vZGUgKHN0YXRlPTEpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqL1xuICAgIGRyYXdBZ2VudHMoY3R4KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5hZ2VudEJ1ZmZlcikgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBidWZmZXIgICAgICA9IG1lLmFnZW50QnVmZmVyLFxuICAgICAgICAgICAgY291bnQgICAgICAgPSBBR0VOVF9DT1VOVCxcbiAgICAgICAgICAgIHRoZW1lQ29sb3JzID0gbWUuY29uc3RydWN0b3IuY29sb3JzW21lLnRoZW1lXSxcbiAgICAgICAgICAgIHMgICAgICAgICAgID0gbWUuc2NhbGU7IC8vIEdldCBzY2FsZSBmYWN0b3JcblxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBISUdITElHSFQ7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgICA9IHRoZW1lQ29sb3JzLmFnZW50SGVhZDtcbiAgICAgICAgY3R4LmxpbmVDYXAgICAgID0gJ3JvdW5kJztcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpZHggICA9IGkgKiBBR0VOVF9TVFJJREUsXG4gICAgICAgICAgICAgICAgeCAgICAgPSBidWZmZXJbaWR4XSxcbiAgICAgICAgICAgICAgICB5ICAgICA9IGJ1ZmZlcltpZHggKyAxXSxcbiAgICAgICAgICAgICAgICB2eCAgICA9IGJ1ZmZlcltpZHggKyAyXSxcbiAgICAgICAgICAgICAgICB2eSAgICA9IGJ1ZmZlcltpZHggKyAzXSxcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IGJ1ZmZlcltpZHggKyA1XTtcblxuICAgICAgICAgICAgLy8gMS4gRHJhdyBUcmFpbCAoTW90aW9uIEJsdXIpXG4gICAgICAgICAgICBsZXQgc3BlZWQgPSBNYXRoLnNxcnQodngqdnggKyB2eSp2eSk7XG5cbiAgICAgICAgICAgIGlmIChzcGVlZCA+IDAuMSAqIHMpIHsgLy8gU2NhbGVkIHRocmVzaG9sZFxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMiAqIHM7IC8vIFNjYWxlZCBsaW5lIHdpZHRoXG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC42O1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4IC0gdnggKiA0LCB5IC0gdnkgKiA0KTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gMi4gRHJhdyBIZWFkXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBzdGF0ZSA9PT0gMSA/IDEgOiAwLjg7XG4gICAgICAgICAgICBsZXQgcmFkaXVzID0gKHN0YXRlID09PSAxID8gMyA6IDIpICogczsgLy8gU2NhbGVkIHJhZGl1c1xuICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG5cbiAgICAgICAgICAgIC8vIDMuIFNjYW4gRWZmZWN0XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDEgKiBzOyAvLyBTY2FsZWQgd2lkdGhcbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjM7XG4gICAgICAgICAgICAgICAgLy8gU2NhbGVkIHJpbmcgcmFkaXVzXG4gICAgICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCAoOCArIE1hdGguc2luKG1lLnRpbWUgKiAxMCkgKiAyKSAqIHMsIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDFcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgbmV1cmFsIG5ldHdvcmsgKG5vZGVzIGFuZCBjb25uZWN0aW9ucykuXG4gICAgICpcbiAgICAgKiAqKkludGVudDoqKlxuICAgICAqIFZpc3VhbGl6ZXMgdGhlIFwiQXBwbGljYXRpb24gR3JhcGhcIi5cbiAgICAgKiAtICoqUGFyYWxsYXg6KiogQXBwbGllcyBkZXB0aC1iYXNlZCBkaXNwbGFjZW1lbnQgYmFzZWQgb24gbW91c2UgcG9zaXRpb24uXG4gICAgICogLSAqKkNvbm5lY3Rpb25zOioqIExpbmVzIGFyZSBkcmF3biBvbmx5IGJldHdlZW4gcmVsYXRlZCBub2RlcyAoUGFyZW50LUNoaWxkIG9yIFNpYmxpbmdzKS5cbiAgICAgKiAgIExpbmVzIHRoaWNrZW4gYW5kIGJyaWdodGVuIHdoZW4gbmVhciB0aGUgbW91c2UuXG4gICAgICogLSAqKk5vZGVzOioqIENpcmNsZXMgYnJlYXRoaW5nIGluIHNpemUuIENvbG9ycyBpbmRpY2F0ZSBkZXB0aCAoTGF5ZXIpIGFuZCBlbmVyZ3kgc3RhdGUuXG4gICAgICpcbiAgICAgKiAqKk9wdGltaXphdGlvbjoqKlxuICAgICAqIFVzZXMgaW5saW5lZCBtYXRoIGZvciBwYXJhbGxheCBjYWxjdWxhdGlvbnMgdG8gYXZvaWQgYWxsb2NhdGluZyB0aG91c2FuZHMgb2YgYHt4LHl9YCBvYmplY3RzIHBlciBmcmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAgICovXG4gICAgZHJhd05ldHdvcmsoY3R4LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5ub2RlQnVmZmVyKSByZXR1cm47XG5cbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIGJ1ZmZlciAgICAgID0gbWUubm9kZUJ1ZmZlcixcbiAgICAgICAgICAgIGNvdW50ICAgICAgID0gTk9ERV9DT1VOVCxcbiAgICAgICAgICAgIG14ICAgICAgICAgID0gbWUubW91c2UueCxcbiAgICAgICAgICAgIG15ICAgICAgICAgID0gbWUubW91c2UueSxcbiAgICAgICAgICAgIGN4ICAgICAgICAgID0gd2lkdGggLyAyLFxuICAgICAgICAgICAgY3kgICAgICAgICAgPSBoZWlnaHQgLyAyLFxuICAgICAgICAgICAgdGhlbWVDb2xvcnMgPSBtZS5jb25zdHJ1Y3Rvci5jb2xvcnNbbWUudGhlbWVdLFxuICAgICAgICAgICAgcyAgICAgICAgICAgPSBtZS5zY2FsZTsgLy8gR2V0IHNjYWxlIGZhY3RvclxuXG4gICAgICAgIGN0eC5saW5lV2lkdGggPSAxICogczsgLy8gU2NhbGVkIGxpbmUgd2lkdGhcblxuICAgICAgICAvLyAxLiBEcmF3IENvbm5lY3Rpb25zXG4gICAgICAgIC8vIEl0ZXJhdGVzIGFsbCB1bmlxdWUgcGFpcnMgdG8gZHJhdyBsaW5lcyBiZXR3ZWVuIGNvbm5lY3RlZCBub2Rlcy5cbiAgICAgICAgLy8gQ29ubmVjdGlvbnMgYXJlIGRyYXduIGlmIG5vZGVzIHNoYXJlIGEgcGFyZW50IChzaWJsaW5ncykgb3IgYXJlIHBhcmVudC1jaGlsZC5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaWR4ICA9IGkgKiBOT0RFX1NUUklERSxcbiAgICAgICAgICAgICAgICBsMSAgID0gYnVmZmVyW2lkeCArIDVdLFxuICAgICAgICAgICAgICAgIHBpZDEgPSBidWZmZXJbaWR4ICsgNl0sXG4gICAgICAgICAgICAgICAgLy8gSW5saW5lIGdldFBvcyBsb2dpYyBmb3IgcDEgdG8gYXZvaWQgR0NcbiAgICAgICAgICAgICAgICBmMSAgID0gbDEgPT09IDIgPyAwLjA1IDogKGwxID09PSAxID8gMC4wMiA6IDAuMDEpLFxuICAgICAgICAgICAgICAgIGR4MSAgPSAobXggIT09IC0xMDAwID8gbXggLSBjeCA6IDApICogZjEsXG4gICAgICAgICAgICAgICAgZHkxICA9IChteSAhPT0gLTEwMDAgPyBteSAtIGN5IDogMCkgKiBmMSxcbiAgICAgICAgICAgICAgICBwMXggID0gYnVmZmVyW2lkeF0gKyBkeDEsXG4gICAgICAgICAgICAgICAgcDF5ICA9IGJ1ZmZlcltpZHggKyAxXSArIGR5MTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgY291bnQ7IGorKykge1xuICAgICAgICAgICAgICAgIGxldCBpZHgyID0gaiAqIE5PREVfU1RSSURFLFxuICAgICAgICAgICAgICAgICAgICBsMiAgID0gYnVmZmVyW2lkeDIgKyA1XSxcbiAgICAgICAgICAgICAgICAgICAgcGlkMiA9IGJ1ZmZlcltpZHgyICsgNl07XG5cbiAgICAgICAgICAgICAgICBjb25zdFxuICAgICAgICAgICAgICAgICAgICBzYW1lQ2x1c3RlciAgID0gcGlkMSA9PT0gcGlkMiAmJiBwaWQxICE9PSAtMSxcbiAgICAgICAgICAgICAgICAgICAgaXNQYXJlbnRDaGlsZCA9IChwaWQxID09PSBqKSB8fCAocGlkMiA9PT0gaSksXG4gICAgICAgICAgICAgICAgICAgIGlzQ2x1c3RlckxpbmsgPSAocGlkMSA9PT0gLTEgJiYgcGlkMiA9PT0gLTEpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFzYW1lQ2x1c3RlciAmJiAhaXNQYXJlbnRDaGlsZCAmJiAhaXNDbHVzdGVyTGluaykgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICBsZXQgZjIgICA9IGwyID09PSAyID8gMC4wNSA6IChsMiA9PT0gMSA/IDAuMDIgOiAwLjAxKSxcbiAgICAgICAgICAgICAgICAgICAgZHgyICA9IChteCAhPT0gLTEwMDAgPyBteCAtIGN4IDogMCkgKiBmMixcbiAgICAgICAgICAgICAgICAgICAgZHkyICA9IChteSAhPT0gLTEwMDAgPyBteSAtIGN5IDogMCkgKiBmMixcbiAgICAgICAgICAgICAgICAgICAgcDJ4ICA9IGJ1ZmZlcltpZHgyXSArIGR4MixcbiAgICAgICAgICAgICAgICAgICAgcDJ5ICA9IGJ1ZmZlcltpZHgyICsgMV0gKyBkeTIsXG4gICAgICAgICAgICAgICAgICAgIGR4ICAgPSBwMXggLSBwMngsXG4gICAgICAgICAgICAgICAgICAgIGR5ICAgPSBwMXkgLSBwMnksXG4gICAgICAgICAgICAgICAgICAgIGRpc3RTcSA9IGR4KmR4ICsgZHkqZHk7XG5cbiAgICAgICAgICAgICAgICAvLyBDdWxsaW5nOiBPbmx5IGRyYXcgY29ubmVjdGlvbnMgd2l0aGluIGEgY2VydGFpbiBkaXN0YW5jZVxuICAgICAgICAgICAgICAgIGlmIChkaXN0U3EgPCA0MDAwMCAqIHMgKiBzKSB7IC8vIFNjYWxlZCBkaXN0YW5jZSBzcXVhcmVkXG4gICAgICAgICAgICAgICAgICAgIGxldCBkaXN0ICA9IE1hdGguc3FydChkaXN0U3EpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGEgPSAxIC0gKGRpc3QgLyAoMjAwICogcykpOyAvLyBTY2FsZWQgZGlzdGFuY2UgZmFjdG9yXG5cbiAgICAgICAgICAgICAgICAgICAgYWxwaGEgKj0gKDAuMiArIChsMSAqIDAuMSkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBtRHggPSAocDF4ICsgcDJ4KS8yIC0gbXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBtRHkgPSAocDF5ICsgcDJ5KS8yIC0gbXksXG4gICAgICAgICAgICAgICAgICAgICAgICBtRGlzdFNxID0gbUR4Km1EeCArIG1EeSptRHk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTW91c2UgSW50ZXJhY3Rpb246IEhpZ2hsaWdodCBjb25uZWN0aW9ucyBuZWFyIGN1cnNvclxuICAgICAgICAgICAgICAgICAgICBpZiAobURpc3RTcSA8IDEwMDAwICogcyAqIHMpIHsgLy8gU2NhbGVkIG1vdXNlIGRpc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYSA9IE1hdGgubWluKGFscGhhICsgMC41LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IEhJR0hMSUdIVDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggICA9IDEuNSAqIHMgLy8gU2NhbGVkXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsMSA9PT0gMiA/IFBSSU1BUlkgOiBTRUNPTkRBUlk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbGFzdGljaXR5OiBUaGlja2VyIHdoZW4gY2xvc2VyIChUZW5zaW9uL1NsYWNrIHZpc3VhbGl6YXRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gKDAuNSArICgxIC0gKGRpc3QgLyAoMjAwICogcykpKSkgKiBzIC8vIFNjYWxlZFxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBhbHBoYSAqIDAuNTtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhwMXgsIHAxeSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8ocDJ4LCBwMnkpO1xuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyAyLiBEcmF3IE5vZGVzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkeCAgICAgID0gaSAqIE5PREVfU1RSSURFLFxuICAgICAgICAgICAgICAgIHJhZGl1cyAgID0gYnVmZmVyW2lkeCArIDRdLFxuICAgICAgICAgICAgICAgIGxheWVyICAgID0gYnVmZmVyW2lkeCArIDVdLFxuICAgICAgICAgICAgICAgIHBhcmVudElkID0gYnVmZmVyW2lkeCArIDZdLFxuICAgICAgICAgICAgICAgIHBoYXNlICAgID0gYnVmZmVyW2lkeCArIDddLFxuICAgICAgICAgICAgICAgIGVuZXJneSAgID0gYnVmZmVyW2lkeCArIDhdO1xuXG4gICAgICAgICAgICAvLyBDdWxsaW5nOiBTa2lwIGJhY2tncm91bmQgbGF5ZXIgb24gdmVyeSBzbWFsbCBzY3JlZW5zIHRvIHJlZHVjZSBub2lzZVxuICAgICAgICAgICAgaWYgKHMgPCAwLjUgJiYgbGF5ZXIgPT09IDApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBsZXRcbiAgICAgICAgICAgICAgICAvLyBJbmxpbmUgZ2V0UG9zIGxvZ2ljIGZvciBwb3NcbiAgICAgICAgICAgICAgICBmICAgICAgICA9IGxheWVyID09PSAyID8gMC4wNSA6IChsYXllciA9PT0gMSA/IDAuMDIgOiAwLjAxKSxcbiAgICAgICAgICAgICAgICBwRHggICAgICA9IChteCAhPT0gLTEwMDAgPyBteCAtIGN4IDogMCkgKiBmLFxuICAgICAgICAgICAgICAgIHBEeSAgICAgID0gKG15ICE9PSAtMTAwMCA/IG15IC0gY3kgOiAwKSAqIGYsXG4gICAgICAgICAgICAgICAgcG9zWCAgICAgPSBidWZmZXJbaWR4XSArIHBEeCxcbiAgICAgICAgICAgICAgICBwb3NZICAgICA9IGJ1ZmZlcltpZHggKyAxXSArIHBEeSxcbiAgICAgICAgICAgICAgICBkeCAgICAgICA9IHBvc1ggLSBteCxcbiAgICAgICAgICAgICAgICBkeSAgICAgICA9IHBvc1kgLSBteSxcbiAgICAgICAgICAgICAgICBkaXN0ICAgICA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSksXG4gICAgICAgICAgICAgICAgaXNIb3ZlciAgPSBkaXN0IDwgNTAgKiBzOyAvLyBTY2FsZWQgaG92ZXIgZGlzdGFuY2VcblxuICAgICAgICAgICAgLy8gU2hvY2t3YXZlIEludGVyYWN0aW9uXG4gICAgICAgICAgICBpZiAobWUuc2hvY2t3YXZlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbWUuc2hvY2t3YXZlcy5mb3JFYWNoKHdhdmUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgd0Rpc3QgPSBNYXRoLnNxcnQoKHBvc1ggLSB3YXZlLngpKioyICsgKHBvc1kgLSB3YXZlLnkpKioyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdSYWQgID0gd2F2ZS5hZ2UgKiB3YXZlLnNwZWVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMod0Rpc3QgLSB3UmFkKSA8IDIwICogcykgeyAvLyBTY2FsZWQgd2F2ZSB3aWR0aFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNIb3ZlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgbGV0IHIgPSBwYXJlbnRJZCA9PT0gLTEgPyByYWRpdXMgKiAxLjUgOiByYWRpdXM7XG5cbiAgICAgICAgICAgIC8vIEJyZWF0aGluZyArIEVuZXJneVxuICAgICAgICAgICAgciAqPSAxICsgTWF0aC5zaW4obWUudGltZSAqIDIgKyBwaGFzZSkgKiAwLjE1ICsgZW5lcmd5O1xuXG4gICAgICAgICAgICBpZiAoaXNIb3Zlcikge1xuICAgICAgICAgICAgICAgIHIgKj0gMS41O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHguYXJjKHBvc1gsIHBvc1ksIHIsIDAsIE1hdGguUEkgKiAyKTtcblxuICAgICAgICAgICAgaWYgKGVuZXJneSA+IDAuMSkge1xuICAgICAgICAgICAgICAgIC8vIEVuZXJnZXRpYyBOb2RlIChBZ2VudCBTY2FubmVkKVxuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBISUdITElHSFQ7XG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gTWF0aC5taW4oMSwgMC41ICsgZW5lcmd5KVxuICAgICAgICAgICAgfSBlbHNlIGlmIChsYXllciA9PT0gMikge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBpc0hvdmVyID8gdGhlbWVDb2xvcnMubm9kZUhpZ2ggOiBQUklNQVJZO1xuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGlzSG92ZXIgPyAxIDogMC44XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmVudElkID09PSAtMikge1xuICAgICAgICAgICAgICAgIC8vIERyaWZ0aW5nIE5vZGUgVmlzdWFsXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IEhJR0hMSUdIVDtcbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjYgKyBNYXRoLnNpbihtZS50aW1lICogMTAgKyBwaGFzZSkgKiAwLjNcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGF5ZXIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gaXNIb3ZlciA/IEhJR0hMSUdIVCA6IFNFQ09OREFSWTtcbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IENPTk5FQ1RJT05fQ09MT1I7XG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC4yXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIGRhdGEgcGFja2V0cyB0cmF2ZWxpbmcgYWxvbmcgY29ubmVjdGlvbnMuXG4gICAgICogUGFja2V0cyByZXByZXNlbnQgc2lnbmFsIGZsb3cgYmV0d2VlbiBub2Rlcy5cbiAgICAgKiBAcGFyYW0ge09mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICovXG4gICAgZHJhd1BhY2tldHMoY3R4KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5wYWNrZXRCdWZmZXIpIHJldHVybjtcblxuICAgICAgICBjb25zdFxuICAgICAgICAgICAgYnVmZmVyICAgICAgPSBtZS5wYWNrZXRCdWZmZXIsXG4gICAgICAgICAgICBjb3VudCAgICAgICA9IFBBQ0tFVF9DT1VOVCxcbiAgICAgICAgICAgIHRoZW1lQ29sb3JzID0gbWUuY29uc3RydWN0b3IuY29sb3JzW21lLnRoZW1lXTtcblxuICAgICAgICBjdHguZmlsbFN0eWxlICAgPSB0aGVtZUNvbG9ycy5wYWNrZXQ7XG4gICAgICAgIGN0eC5zaGFkb3dCbHVyICA9IDU7XG4gICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IEhJR0hMSUdIVDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpZHggID0gaSAqIFBBQ0tFVF9TVFJJREUsXG4gICAgICAgICAgICAgICAgbGlmZSA9IGJ1ZmZlcltpZHggKyA0XTtcblxuICAgICAgICAgICAgaWYgKGxpZmUgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHggPSBidWZmZXJbaWR4XSxcbiAgICAgICAgICAgICAgICAgICAgeSA9IGJ1ZmZlcltpZHggKyAxXTtcblxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBNYXRoLm1pbihsaWZlICogMiwgMSk7IC8vIEZhZGUgb3V0IGF0IGVuZFxuICAgICAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgMiwgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5zaGFkb3dCbHVyICA9IDA7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDFcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBleHBhbmRpbmcgc2hvY2t3YXZlcyBmcm9tIGNsaWNrcyB3aXRoIENocm9tYXRpYyBBYmVycmF0aW9uIGFuZCBDb21wb3NpdGUgUmluZ3MuXG4gICAgICogVXNlcyBvcHRpbWl6ZWQgUkdCQSBjb21wb3NpdGlvbiB0byByZWR1Y2UgR0MgcHJlc3N1cmUuXG4gICAgICogQHBhcmFtIHtPZmZzY3JlZW5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqL1xuICAgIGRyYXdTaG9ja3dhdmVzKGN0eCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5zaG9ja3dhdmVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICB0aGVtZUNvbG9ycyA9IG1lLmNvbnN0cnVjdG9yLmNvbG9yc1ttZS50aGVtZV0sXG4gICAgICAgICAgICBzICAgICAgICAgICA9IG1lLnNjYWxlO1xuXG4gICAgICAgIGN0eC5saW5lQ2FwID0gJ3JvdW5kJztcblxuICAgICAgICBmb3IgKGxldCBpID0gbWUuc2hvY2t3YXZlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHdhdmUgPSBtZS5zaG9ja3dhdmVzW2ldO1xuICAgICAgICAgICAgd2F2ZS5hZ2UrKztcblxuICAgICAgICAgICAgbGV0IHByb2dyZXNzID0gd2F2ZS5hZ2UgLyB3YXZlLm1heEFnZTtcblxuICAgICAgICAgICAgaWYgKHByb2dyZXNzID49IDEpIHtcbiAgICAgICAgICAgICAgICBtZS5zaG9ja3dhdmVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTm9uLUxpbmVhciBFeHBhbnNpb24gKEV4cGxvc2l2ZSBzdGFydCwgc2xvdyBmaW5pc2gpXG4gICAgICAgICAgICBsZXQgZWFzZWQgPSAxIC0gTWF0aC5wb3coMSAtIHByb2dyZXNzLCAzKSxcbiAgICAgICAgICAgICAgICByYWRpdXMgPSBlYXNlZCAqIHdhdmUubWF4UmFkaXVzLFxuICAgICAgICAgICAgICAgIGFscGhhICA9IDEgLSBwcm9ncmVzcztcblxuICAgICAgICAgICAgLy8gQ2hyb21hdGljIEFiZXJyYXRpb24gKFNoaWZ0ZWQgdG8gTmVvbiBCbHVlL0N5YW4gdGhlbWUpXG5cbiAgICAgICAgICAgIC8vIDEuIEN5YW4gQ2hhbm5lbCAoTGFnZ2luZyBGcmluZ2UpIC0gUmVwbGFjZXMgUmVkXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBISUdITElHSFQ7XG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBhbHBoYSAqIDAuODtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggICA9IDQgKiAoMSAtIHByb2dyZXNzKSAqIHM7IC8vIFNjYWxlZFxuICAgICAgICAgICAgY3R4LnNoYWRvd0JsdXIgID0gMTAgKiBzOyAvLyBTY2FsZWRcbiAgICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IEhJR0hMSUdIVDtcbiAgICAgICAgICAgIGN0eC5hcmMod2F2ZS54LCB3YXZlLnksIHJhZGl1cyAqIDAuOTksIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICAgICAgLy8gMi4gQmx1ZSBDaGFubmVsIChMZWFkaW5nIEZyaW5nZSlcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFBSSU1BUlk7XG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBhbHBoYSAqIDAuODtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggICA9IDQgKiAoMSAtIHByb2dyZXNzKSAqIHM7IC8vIFNjYWxlZFxuICAgICAgICAgICAgY3R4LnNoYWRvd0JsdXIgID0gMTAgKiBzOyAvLyBTY2FsZWRcbiAgICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IFBSSU1BUlk7XG4gICAgICAgICAgICBjdHguYXJjKHdhdmUueCwgd2F2ZS55LCByYWRpdXMgKiAxLjAxLCAwLCBNYXRoLlBJICogMik7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgICAgIC8vIDMuIFByaW1hcnkgV2F2ZSAoV2hpdGUgSG90IENlbnRlcilcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoZW1lQ29sb3JzLnNob2Nrd2F2ZTtcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGFscGhhO1xuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCAgID0gNiAqICgxIC0gcHJvZ3Jlc3MpICogczsgLy8gU2NhbGVkXG4gICAgICAgICAgICBjdHguc2hhZG93Qmx1ciAgPSAyMCAqIHM7IC8vIFNjYWxlZFxuICAgICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gdGhlbWVDb2xvcnMuc2hvY2t3YXZlO1xuICAgICAgICAgICAgY3R4LmFyYyh3YXZlLngsIHdhdmUueSwgcmFkaXVzLCAwLCBNYXRoLlBJICogMik7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgICAgIC8vIDQuIFByZXNzdXJlIEZpbGwgKFJlZnJhY3Rpb24gRmFrZSlcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBQUklNQVJZO1xuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gYWxwaGEgKiAwLjA1O1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5zaGFkb3dCbHVyID0gMDtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYXdzIHRlbXBvcmFyeSBzcGFyayBwYXJ0aWNsZXMgKERhdGEgRGVicmlzKS5cbiAgICAgKiBAcGFyYW0ge09mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICovXG4gICAgZHJhd1NwYXJrcyhjdHgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuc3BhcmtzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICB0aGVtZUNvbG9ycyA9IG1lLmNvbnN0cnVjdG9yLmNvbG9yc1ttZS50aGVtZV0sXG4gICAgICAgICAgICBzICAgICAgICAgICA9IG1lLnNjYWxlO1xuXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoZW1lQ29sb3JzLnNwYXJrO1xuICAgICAgICBjdHguc2hhZG93Qmx1ciA9IDA7IC8vIENyaXNwIGxpbmVzIG9uIHdoaXRlXG4gICAgICAgIGN0eC5saW5lV2lkdGggPSAyICogczsgLy8gU2NhbGVkIHdpZHRoXG5cbiAgICAgICAgZm9yIChsZXQgcyBvZiBtZS5zcGFya3MpIHtcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHMubGlmZTtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIC8vIERyYXcgVHJhaWwgYmFzZWQgb24gdmVsb2NpdHlcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8ocy54LCBzLnkpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhzLnggLSBzLnZ4ICogMiwgcy55IC0gcy52eSAqIDIpO1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpXG4gICAgICAgIH1cblxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIGF1dG9ub21vdXMgYWdlbnRzLlxuICAgICAqIEFnZW50cyBzdGFydCBhdCByYW5kb20gcG9zaXRpb25zIHdpdGggcmFuZG9tIGhpZ2gtdmVsb2NpdHkgdmVjdG9ycy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAgICovXG4gICAgaW5pdEFnZW50cyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5hZ2VudEJ1ZmZlcikge1xuICAgICAgICAgICAgbWUuYWdlbnRCdWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KEFHRU5UX0NPVU5UICogQUdFTlRfU1RSSURFKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBidWZmZXIgPSBtZS5hZ2VudEJ1ZmZlcixcbiAgICAgICAgICAgIHMgICAgICA9IG1lLnNjYWxlO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQUdFTlRfQ09VTlQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkeCA9IGkgKiBBR0VOVF9TVFJJREU7XG5cbiAgICAgICAgICAgIGJ1ZmZlcltpZHhdICAgICA9IE1hdGgucmFuZG9tKCkgKiB3aWR0aDsgIC8vIHhcbiAgICAgICAgICAgIGJ1ZmZlcltpZHggKyAxXSA9IE1hdGgucmFuZG9tKCkgKiBoZWlnaHQ7IC8vIHlcbiAgICAgICAgICAgIGJ1ZmZlcltpZHggKyAyXSA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDQgKiBzOyAvLyB2eCAoRmFzdCEpXG4gICAgICAgICAgICBidWZmZXJbaWR4ICsgM10gPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiA0ICogczsgLy8gdnlcbiAgICAgICAgICAgIGJ1ZmZlcltpZHggKyA0XSA9IC0xOyAvLyB0YXJnZXRJZHggKG5vbmUpXG4gICAgICAgICAgICBidWZmZXJbaWR4ICsgNV0gPSAwICAgLy8gc3RhdGUgKG1vdmluZylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBub2RlIGJ1ZmZlciB1c2luZyAqKkdvbGRlbiBTcGlyYWwqKiBkaXN0cmlidXRpb24uXG4gICAgICogVGhpcyBlbnN1cmVzIGEgdW5pZm9ybSBidXQgb3JnYW5pYy1sb29raW5nIGRpc3RyaWJ1dGlvbiBvZiBub2RlcyBhY3Jvc3MgdGhlIHNjcmVlbixcbiAgICAgKiBwcmV2ZW50aW5nIHRoZSBcImNsdW1waW5nXCIgc2VlbiB3aXRoIHJhbmRvbSBwbGFjZW1lbnQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqL1xuICAgIGluaXROb2Rlcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5ub2RlQnVmZmVyKSB7XG4gICAgICAgICAgICBtZS5ub2RlQnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShOT0RFX0NPVU5UICogTk9ERV9TVFJJREUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIGJ1ZmZlciAgICAgICAgPSBtZS5ub2RlQnVmZmVyLFxuICAgICAgICAgICAgY3ggICAgICAgICAgICA9IHdpZHRoIC8gMixcbiAgICAgICAgICAgIGN5ICAgICAgICAgICAgPSBoZWlnaHQgLyAyLFxuICAgICAgICAgICAgcGhpICAgICAgICAgICA9ICgxICsgTWF0aC5zcXJ0KDUpKSAvIDIsXG4gICAgICAgICAgICBzY2FsZSAgICAgICAgID0gTWF0aC5zcXJ0KHdpZHRoICogaGVpZ2h0IC8gTk9ERV9DT1VOVCkgKiAwLjgsXG4gICAgICAgICAgICBwYXJlbnRDb3VudCAgID0gTWF0aC5mbG9vcihOT0RFX0NPVU5UICogMC4xKSxcbiAgICAgICAgICAgIHMgICAgICAgICAgICAgPSBtZS5zY2FsZTsgLy8gVXNlIHRoZSBjYWxjdWxhdGVkIHNjYWxlIGZhY3RvclxuXG4gICAgICAgIGxldCBwYXJlbnRJbmRpY2VzID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOT0RFX0NPVU5UOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpZHggPSBpICogTk9ERV9TVFJJREUsXG4gICAgICAgICAgICAgICAgaXNQYXJlbnQgPSBpIDwgcGFyZW50Q291bnQ7XG5cbiAgICAgICAgICAgIGlmIChpc1BhcmVudCkgcGFyZW50SW5kaWNlcy5wdXNoKGkpO1xuXG4gICAgICAgICAgICBsZXQgdGhldGEgPSBpICogMiAqIE1hdGguUEkgKiBwaGksXG4gICAgICAgICAgICAgICAgciAgICAgPSBNYXRoLnNxcnQoaSkgKiBzY2FsZTtcblxuICAgICAgICAgICAgLy8gU2ltcGxlIHdyYXAgdG8ga2VlcCBpbml0aWFsIHNwaXJhbCBpbnNpZGUgcmVhc29uYWJsZSBib3VuZHNcbiAgICAgICAgICAgIGxldCB4ID0gY3ggKyByICogTWF0aC5jb3ModGhldGEpLFxuICAgICAgICAgICAgICAgIHkgPSBjeSArIHIgKiBNYXRoLnNpbih0aGV0YSk7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBzcGlyYWwgaXMgbGFyZ2VyIHRoYW4gc2NyZWVuLCB3cmFwIGl0XG4gICAgICAgICAgICB4ID0gKCh4ICUgd2lkdGgpICsgd2lkdGgpICUgd2lkdGg7XG4gICAgICAgICAgICB5ID0gKCh5ICUgaGVpZ2h0KSArIGhlaWdodCkgJSBoZWlnaHQ7XG5cbiAgICAgICAgICAgIGJ1ZmZlcltpZHhdICAgICA9IHg7XG4gICAgICAgICAgICBidWZmZXJbaWR4ICsgMV0gPSB5O1xuICAgICAgICAgICAgYnVmZmVyW2lkeCArIDJdID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMC4yICogczsgLy8gU2NhbGUgdmVsb2NpdHlcbiAgICAgICAgICAgIGJ1ZmZlcltpZHggKyAzXSA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDAuMiAqIHM7XG5cbiAgICAgICAgICAgIGxldCBsYXllciA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDMpO1xuICAgICAgICAgICAgYnVmZmVyW2lkeCArIDVdID0gbGF5ZXI7IC8vIGxheWVyXG5cbiAgICAgICAgICAgIC8vIFJhZGl1cyBiYXNlZCBvbiBsYXllciAmIHJvbGUgKFNjYWxlZClcbiAgICAgICAgICAgIGJ1ZmZlcltpZHggKyA0XSA9IChpc1BhcmVudCA/IDQgKyAobGF5ZXIgKiAyKSA6IDIgKyAobGF5ZXIgKiAxLjUpKSAqIHM7XG5cbiAgICAgICAgICAgIC8vIFBhcmVudCBJRCAoLTEgZm9yIHBhcmVudHMsIGFzc2lnbmVkIGxhdGVyIGZvciBjaGlsZHJlbilcbiAgICAgICAgICAgIGJ1ZmZlcltpZHggKyA2XSA9IGlzUGFyZW50ID8gLTEgOiAtMjtcblxuICAgICAgICAgICAgLy8gUGhhc2UgKEJyZWF0aGluZyBvZmZzZXQpXG4gICAgICAgICAgICBidWZmZXJbaWR4ICsgN10gPSBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDI7XG5cbiAgICAgICAgICAgIC8vIEVuZXJneVxuICAgICAgICAgICAgYnVmZmVyW2lkeCArIDhdID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDIuIEFzc2lnbiBDaGlsZHJlbiB0byBuZWFyZXN0IFBhcmVudFxuICAgICAgICBmb3IgKGxldCBpID0gcGFyZW50Q291bnQ7IGkgPCBOT0RFX0NPVU5UOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpZHggICAgICAgID0gaSAqIE5PREVfU1RSSURFLFxuICAgICAgICAgICAgICAgIHggICAgICAgICAgPSBidWZmZXJbaWR4XSxcbiAgICAgICAgICAgICAgICB5ICAgICAgICAgID0gYnVmZmVyW2lkeCArIDFdLFxuICAgICAgICAgICAgICAgIGJlc3REaXN0ICAgPSBJbmZpbml0eSxcbiAgICAgICAgICAgICAgICBiZXN0UGFyZW50ID0gLTE7XG5cbiAgICAgICAgICAgIGZvciAobGV0IHBpZCBvZiBwYXJlbnRJbmRpY2VzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBJZHggPSBwaWQgKiBOT0RFX1NUUklERSxcbiAgICAgICAgICAgICAgICAgICAgcHggICA9IGJ1ZmZlcltwSWR4XSxcbiAgICAgICAgICAgICAgICAgICAgcHkgICA9IGJ1ZmZlcltwSWR4ICsgMV0sXG4gICAgICAgICAgICAgICAgICAgIGR4ICAgPSB4IC0gcHgsXG4gICAgICAgICAgICAgICAgICAgIGR5ICAgPSB5IC0gcHksXG4gICAgICAgICAgICAgICAgICAgIGRTcSAgPSBkeCpkeCArIGR5KmR5O1xuXG4gICAgICAgICAgICAgICAgaWYgKGRTcSA8IGJlc3REaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3REaXN0ID0gZFNxO1xuICAgICAgICAgICAgICAgICAgICBiZXN0UGFyZW50ID0gcGlkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnVmZmVyW2lkeCArIDZdID0gYmVzdFBhcmVudFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIHBhY2tldCBidWZmZXIuXG4gICAgICovXG4gICAgaW5pdFBhY2tldHMoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG4gICAgICAgIGlmICghbWUucGFja2V0QnVmZmVyKSB7XG4gICAgICAgICAgICBtZS5wYWNrZXRCdWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KFBBQ0tFVF9DT1VOVCAqIFBBQ0tFVF9TVFJJREUpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gcmVuZGVyTG9vcD10aGlzLnJlbmRlci5iaW5kKHRoaXMpXG4gICAgICovXG4gICAgcmVuZGVyTG9vcCA9IHRoaXMucmVuZGVyLmJpbmQodGhpcylcblxuICAgIC8qKlxuICAgICAqIE1haW4gc2ltdWxhdGlvbiBhbmQgcmVuZGVyIGxvb3AuXG4gICAgICogRXhlY3V0ZWQgfjYwIHRpbWVzIHBlciBzZWNvbmQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUuY2FuUmVuZGVyKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBjdHggICAgPSBtZS5jb250ZXh0LFxuICAgICAgICAgICAgd2lkdGggID0gbWUuY2FudmFzU2l6ZT8ud2lkdGggIHx8IDEwMCxcbiAgICAgICAgICAgIGhlaWdodCA9IG1lLmNhbnZhc1NpemU/LmhlaWdodCB8fCA1MDtcblxuICAgICAgICBtZS50aW1lICs9IDAuMDE7XG5cbiAgICAgICAgaWYgKCFtZS5ub2RlQnVmZmVyKSBtZS5pbml0Tm9kZXMod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGlmICghbWUuYWdlbnRCdWZmZXIpIG1lLmluaXRBZ2VudHMod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGlmICghbWUucGFja2V0QnVmZmVyKSBtZS5pbml0UGFja2V0cygpO1xuXG4gICAgICAgIC8vIFBoeXNpY3MgVXBkYXRlIFN0ZXBzXG4gICAgICAgIG1lLnVwZGF0ZVBoeXNpY3Mod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIG1lLnVwZGF0ZUFnZW50cyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgbWUudXBkYXRlUGFja2V0cygpO1xuICAgICAgICBtZS51cGRhdGVTcGFya3MoKTtcblxuICAgICAgICAvLyBSZW5kZXJpbmcgU3RlcHNcbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICBpZiAobWUuZ3JhZGllbnRzLmJnR3JhZGllbnQpIHtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBtZS5ncmFkaWVudHMuYmdHcmFkaWVudDtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KVxuICAgICAgICB9XG5cbiAgICAgICAgbWUuZHJhd05ldHdvcmsoY3R4LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgbWUuZHJhd1BhY2tldHMoY3R4KTtcbiAgICAgICAgbWUuZHJhd0FnZW50cyhjdHgpO1xuICAgICAgICBtZS5kcmF3U2hvY2t3YXZlcyhjdHgpO1xuICAgICAgICBtZS5kcmF3U3BhcmtzKGN0eCk7XG5cbiAgICAgICAgaWYgKGhhc1JhZikge1xuICAgICAgICAgICAgbWUuYW5pbWF0aW9uSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobWUucmVuZGVyTG9vcClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLmFuaW1hdGlvbklkID0gc2V0VGltZW91dChtZS5yZW5kZXJMb29wLCAxMDAwIC8gNjApXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyBzaG9ja3dhdmVzIG9uIGNsaWNrLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Nb3VzZUNsaWNrKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIHMgID0gbWUuc2NhbGU7XG5cbiAgICAgICAgbWUuc2hvY2t3YXZlcy5wdXNoKHtcbiAgICAgICAgICAgIHggICAgICAgIDogZGF0YS54LFxuICAgICAgICAgICAgeSAgICAgICAgOiBkYXRhLnksXG4gICAgICAgICAgICBhZ2UgICAgICA6IDAsXG4gICAgICAgICAgICBtYXhBZ2UgICA6IDQwLCAvLyBGYXN0ZXIsIHB1bmNoaWVyIHdhdmVcbiAgICAgICAgICAgIG1heFJhZGl1czogMzAwICogcyAvLyBTY2FsZWQgcmFkaXVzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNwYXduIFNwYXJrcyAoRGF0YSBEZWJyaXMpXG4gICAgICAgIGZvcihsZXQgaT0wOyBpPDQwOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBhbmdsZSA9IE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJICogMixcbiAgICAgICAgICAgICAgICBzcGVlZCA9IChNYXRoLnJhbmRvbSgpICogMTUgKyA1KSAqIHM7IC8vIFNjYWxlZCBzcGVlZFxuICAgICAgICAgICAgbWUuc3BhcmtzLnB1c2goe1xuICAgICAgICAgICAgICAgIHggICAgOiBkYXRhLngsXG4gICAgICAgICAgICAgICAgeSAgICA6IGRhdGEueSxcbiAgICAgICAgICAgICAgICB2eCAgIDogTWF0aC5jb3MoYW5nbGUpICogc3BlZWQsXG4gICAgICAgICAgICAgICAgdnkgICA6IE1hdGguc2luKGFuZ2xlKSAqIHNwZWVkLFxuICAgICAgICAgICAgICAgIGxpZmUgOiAxLjAsXG4gICAgICAgICAgICAgICAgZGVjYXk6IDAuMDIgKyBNYXRoLnJhbmRvbSgpICogMC4wM1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgcGFja2V0IGxvZ2ljIChEYXRhIEZsb3cpLlxuICAgICAqIFBhY2tldHMgc3Bhd24gcmFuZG9tbHkgYXQgY2hpbGQgbm9kZXMgYW5kIHRyYXZlbCB0byB0aGVpciBwYXJlbnQgbm9kZXMsXG4gICAgICogcmVwcmVzZW50aW5nIGRhdGEgcmVwb3J0aW5nIHVwc3RyZWFtLlxuICAgICAqL1xuICAgIHVwZGF0ZVBhY2tldHMoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG4gICAgICAgIGlmICghbWUucGFja2V0QnVmZmVyIHx8ICFtZS5ub2RlQnVmZmVyKSByZXR1cm47XG5cbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIHBhY2tldHMgPSBtZS5wYWNrZXRCdWZmZXIsXG4gICAgICAgICAgICBub2RlcyAgID0gbWUubm9kZUJ1ZmZlcixcbiAgICAgICAgICAgIHBDb3VudCAgPSBQQUNLRVRfQ09VTlQsXG4gICAgICAgICAgICBuQ291bnQgID0gTk9ERV9DT1VOVCxcbiAgICAgICAgICAgIHMgICAgICAgPSBtZS5zY2FsZTsgLy8gR2V0IHNjYWxlIGZhY3RvclxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpZHggPSBpICogUEFDS0VUX1NUUklERSxcbiAgICAgICAgICAgICAgICBsaWZlID0gcGFja2V0c1tpZHggKyA0XTtcblxuICAgICAgICAgICAgaWYgKGxpZmUgPD0gMCkge1xuICAgICAgICAgICAgICAgIC8vIFNwYXduIG5ldyBwYWNrZXQ/IChSYW5kb20gY2hhbmNlKVxuICAgICAgICAgICAgICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgMC4wMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBQaWNrIHJhbmRvbSBub2RlIChzb3VyY2UpXG4gICAgICAgICAgICAgICAgICAgIGxldCBuMSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG5Db3VudCksXG4gICAgICAgICAgICAgICAgICAgICAgICBpZHgxID0gbjEgKiBOT0RFX1NUUklERSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpZCA9IG5vZGVzW2lkeDEgKyA2XTsgLy8gUGFyZW50IElEXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVmFsaWQgdGFyZ2V0czogUGFyZW50IChpZiBjaGlsZCksIG9yIENoaWxkIChpZiBwYXJlbnQpXG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbXBsaWZpZWQ6IEp1c3QgZ28gQ2hpbGQgLT4gUGFyZW50IGZvciBub3cgKERhdGEgcmVwb3J0aW5nKVxuICAgICAgICAgICAgICAgICAgICBpZiAocGlkICE9PSAtMSkgeyAvLyBJZiBpdCdzIGEgY2hpbGRcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpZHgyID0gcGlkICogTk9ERV9TVFJJREUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDEgICA9IG5vZGVzW2lkeDFdLCB5MSA9IG5vZGVzW2lkeDEgKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MiAgID0gbm9kZXNbaWR4Ml0sIHkyID0gbm9kZXNbaWR4MiArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR4ICAgPSB4MiAtIHgxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR5ICAgPSB5MiAtIHkxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3QgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHNwYXduIGlmIGNvbm5lY3RlZCBhbmQgY2xvc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXN0IDwgMjAwICogcykgeyAvLyBTY2FsZWQgZGlzdGFuY2UgY2hlY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWNrZXRzW2lkeF0gICAgID0geDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFja2V0c1tpZHggKyAxXSA9IHkxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzcGVlZCAgICAgICAgPSA0ICogczsgLy8gU2NhbGVkIHNwZWVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFja2V0c1tpZHggKyAyXSA9IChkeCAvIGRpc3QpICogc3BlZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFja2V0c1tpZHggKyAzXSA9IChkeSAvIGRpc3QpICogc3BlZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFja2V0c1tpZHggKyA0XSA9IGRpc3QgLyBzcGVlZCAvLyBMaWZlID0gZnJhbWVzIHRvIHJlYWNoIHRhcmdldCAoc3RheXMgc2FtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTW92ZVxuICAgICAgICAgICAgICAgIHBhY2tldHNbaWR4XSAgICAgKz0gcGFja2V0c1tpZHggKyAyXTtcbiAgICAgICAgICAgICAgICBwYWNrZXRzW2lkeCArIDFdICs9IHBhY2tldHNbaWR4ICsgM107XG4gICAgICAgICAgICAgICAgcGFja2V0c1tpZHggKyA0XS0tIC8vIERlY3JlYXNlIGxpZmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgc3BhcmsgcGFydGljbGVzIHdpdGggZnJpY3Rpb24gYW5kIGRlY2F5LlxuICAgICAqL1xuICAgIHVwZGF0ZVNwYXJrcygpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaSA9IG1lLnNwYXJrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHMgPSBtZS5zcGFya3NbaV07XG4gICAgICAgICAgICBzLnggKz0gcy52eDtcbiAgICAgICAgICAgIHMueSArPSBzLnZ5O1xuICAgICAgICAgICAgLy8gRnJpY3Rpb24gKERyYWcpXG4gICAgICAgICAgICBzLnZ4ICo9IDAuOTtcbiAgICAgICAgICAgIHMudnkgKj0gMC45O1xuICAgICAgICAgICAgcy5saWZlIC09IHMuZGVjYXk7XG4gICAgICAgICAgICBpZiAocy5saWZlIDw9IDApIHtcbiAgICAgICAgICAgICAgICBtZS5zcGFya3Muc3BsaWNlKGksIDEpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGFnZW50IHBvc2l0aW9ucyB1c2luZyAqKkJvaWQqKiBsb2dpYyAoU2VlaywgU2VwYXJhdGUpLlxuICAgICAqIEFnZW50cyByYW5kb21seSBwaWNrIGEgdGFyZ2V0IG5vZGUsIHNlZWsgaXQsIHNjYW4gaXQgKHRyYW5zZmVycmluZyBlbmVyZ3kpLFxuICAgICAqIGFuZCB0aGVuIHBpY2sgYSBuZXcgdGFyZ2V0LiBUaGV5IGFsc28gYXZvaWQgdGhlIG1vdXNlIGN1cnNvci5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAgICovXG4gICAgdXBkYXRlQWdlbnRzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIW1lLmFnZW50QnVmZmVyIHx8ICFtZS5ub2RlQnVmZmVyKSByZXR1cm47XG5cbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIGFnZW50cyA9IG1lLmFnZW50QnVmZmVyLFxuICAgICAgICAgICAgbm9kZXMgID0gbWUubm9kZUJ1ZmZlcixcbiAgICAgICAgICAgIGNvdW50ICA9IEFHRU5UX0NPVU5ULFxuICAgICAgICAgICAgbXggICAgID0gbWUubW91c2UueCxcbiAgICAgICAgICAgIG15ICAgICA9IG1lLm1vdXNlLnksXG4gICAgICAgICAgICBzICAgICAgPSBtZS5zY2FsZTsgLy8gR2V0IHNjYWxlIGZhY3RvclxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkeCA9IGkgKiBBR0VOVF9TVFJJREUsXG4gICAgICAgICAgICAgICAgdGFyZ2V0SWR4ID0gYWdlbnRzW2lkeCArIDRdLFxuICAgICAgICAgICAgICAgIHN0YXRlID0gYWdlbnRzW2lkeCArIDVdO1xuXG4gICAgICAgICAgICAvLyBCZWhhdmlvciAxOiBQaWNrIGEgVGFyZ2V0XG4gICAgICAgICAgICBpZiAodGFyZ2V0SWR4ID09PSAtMSB8fCBNYXRoLnJhbmRvbSgpIDwgMC4wMDUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRDb3VudCA9IE1hdGguZmxvb3IoTk9ERV9DT1VOVCAqIDAuMSk7XG4gICAgICAgICAgICAgICAgYWdlbnRzW2lkeCArIDRdID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcGFyZW50Q291bnQpO1xuICAgICAgICAgICAgICAgIHRhcmdldElkeCA9IGFnZW50c1tpZHggKyA0XTtcbiAgICAgICAgICAgICAgICBhZ2VudHNbaWR4ICsgNV0gPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBCZWhhdmlvciAyOiBTZWVrIFRhcmdldFxuICAgICAgICAgICAgaWYgKHRhcmdldElkeCAhPT0gLTEgJiYgc3RhdGUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgbklkeCA9IHRhcmdldElkeCAqIE5PREVfU1RSSURFLFxuICAgICAgICAgICAgICAgICAgICB0eCAgID0gbm9kZXNbbklkeF0sXG4gICAgICAgICAgICAgICAgICAgIHR5ICAgPSBub2Rlc1tuSWR4ICsgMV0sXG4gICAgICAgICAgICAgICAgICAgIGR4ICAgPSB0eCAtIGFnZW50c1tpZHhdLFxuICAgICAgICAgICAgICAgICAgICBkeSAgID0gdHkgLSBhZ2VudHNbaWR4ICsgMV0sXG4gICAgICAgICAgICAgICAgICAgIGRpc3QgPSBNYXRoLnNxcnQoZHgqZHggKyBkeSpkeSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGlzdCA8IDEwICogcykgeyAvLyBTY2FsZWQgYXJyaXZhbCBkaXN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAvLyBBcnJpdmVkISBTY2FuLlxuICAgICAgICAgICAgICAgICAgICBhZ2VudHNbaWR4ICsgNV0gPSAxOyAvLyBTY2FuIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgIGFnZW50c1tpZHggKyAyXSAqPSAwLjE7IC8vIFNsb3cgZG93blxuICAgICAgICAgICAgICAgICAgICBhZ2VudHNbaWR4ICsgM10gKj0gMC4xO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyYW5zZmVyIEVuZXJneSB0byBOb2RlXG4gICAgICAgICAgICAgICAgICAgIG5vZGVzW25JZHggKyA4XSA9IDEuMDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdGVlciB0b3dhcmRzIHRhcmdldFxuICAgICAgICAgICAgICAgICAgICBsZXQgZm9yY2UgPSAwLjA1ICogczsgLy8gU2NhbGVkIHN0ZWVyaW5nIGZvcmNlXG4gICAgICAgICAgICAgICAgICAgIGFnZW50c1tpZHggKyAyXSArPSAoZHggLyBkaXN0KSAqIGZvcmNlO1xuICAgICAgICAgICAgICAgICAgICBhZ2VudHNbaWR4ICsgM10gKz0gKGR5IC8gZGlzdCkgKiBmb3JjZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPCAwLjAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGFnZW50c1tpZHggKyA0XSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICBhZ2VudHNbaWR4ICsgNV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBhZ2VudHNbaWR4ICsgMl0gKz0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogNCAqIHM7IC8vIFNjYWxlZCByYW5kb20gYnVyc3RcbiAgICAgICAgICAgICAgICAgICAgYWdlbnRzW2lkeCArIDNdICs9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDQgKiBzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQmVoYXZpb3IgMzogTW91c2UgUmVwdWxzaW9uXG4gICAgICAgICAgICBpZiAobXggIT09IC0xMDAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGR4ID0gYWdlbnRzW2lkeF0gLSBteCxcbiAgICAgICAgICAgICAgICAgICAgZHkgPSBhZ2VudHNbaWR4ICsgMV0gLSBteSxcbiAgICAgICAgICAgICAgICAgICAgZGlzdFNxID0gZHgqZHggKyBkeSpkeTtcblxuICAgICAgICAgICAgICAgIGlmIChkaXN0U3EgPCAxMDAwMCAqIHMgKiBzKSB7IC8vIFNjYWxlZCBpbnRlcmFjdGlvbiByYWRpdXMgc3F1YXJlZFxuICAgICAgICAgICAgICAgICAgICBsZXQgZGlzdCAgPSBNYXRoLnNxcnQoZGlzdFNxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlID0gKDEwMCAqIHMgLSBkaXN0KSAvICgxMDAgKiBzKTsgLy8gU2NhbGVkIGZvcmNlIGNhbGN1bGF0aW9uXG4gICAgICAgICAgICAgICAgICAgIGFnZW50c1tpZHggKyAyXSArPSAoZHggLyBkaXN0KSAqIGZvcmNlICogMS41ICogcztcbiAgICAgICAgICAgICAgICAgICAgYWdlbnRzW2lkeCArIDNdICs9IChkeSAvIGRpc3QpICogZm9yY2UgKiAxLjUgKiBzO1xuICAgICAgICAgICAgICAgICAgICBhZ2VudHNbaWR4ICsgNV0gPSAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTcGVlZCBMaW1pdCAmIE1vdmVcbiAgICAgICAgICAgIGxldCBzcGVlZCA9IE1hdGguc3FydChhZ2VudHNbaWR4ICsgMl0qKjIgKyBhZ2VudHNbaWR4ICsgM10qKjIpO1xuICAgICAgICAgICAgaWYgKHNwZWVkID4gNCAqIHMpIHsgLy8gU2NhbGVkIHNwZWVkIGxpbWl0XG4gICAgICAgICAgICAgICAgYWdlbnRzW2lkeCArIDJdICo9ICg0ICogcykgLyBzcGVlZDtcbiAgICAgICAgICAgICAgICBhZ2VudHNbaWR4ICsgM10gKj0gKDQgKiBzKSAvIHNwZWVkXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFnZW50c1tpZHhdICAgICArPSBhZ2VudHNbaWR4ICsgMl07XG4gICAgICAgICAgICBhZ2VudHNbaWR4ICsgMV0gKz0gYWdlbnRzW2lkeCArIDNdO1xuXG4gICAgICAgICAgICBpZiAoYWdlbnRzW2lkeF0gPCAwKSBhZ2VudHNbaWR4XSA9IHdpZHRoO1xuICAgICAgICAgICAgaWYgKGFnZW50c1tpZHhdID4gd2lkdGgpIGFnZW50c1tpZHhdID0gMDtcbiAgICAgICAgICAgIGlmIChhZ2VudHNbaWR4ICsgMV0gPCAwKSBhZ2VudHNbaWR4ICsgMV0gPSBoZWlnaHQ7XG4gICAgICAgICAgICBpZiAoYWdlbnRzW2lkeCArIDFdID4gaGVpZ2h0KSBhZ2VudHNbaWR4ICsgMV0gPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBub2RlIHBvc2l0aW9ucyB1c2luZyAqKkNsdXN0ZXIgUGh5c2ljcyoqLlxuICAgICAqIEhhbmRsZXM6XG4gICAgICogMS4gICoqQ29oZXNpb246KiogQ2hpbGRyZW4gc3RpY2sgdG8gcGFyZW50cy5cbiAgICAgKiAyLiAgKipGbG93IEZpZWxkczoqKiBQYXJlbnRzIGRyaWZ0IGluIG9yZ2FuaWMgcGF0dGVybnMuXG4gICAgICogMy4gICoqVG9wb2xvZ3kgTXV0YXRpb246KiogTm9kZXMgY2FuIGRldGFjaCBhbmQgcmUtcGFyZW50LlxuICAgICAqIDQuICAqKkludGVyYWN0aW9uOioqIE1vdXNlIHJlcHVsc2lvbiBhbmQgc2hvY2t3YXZlIGV4cGxvc2lvbi5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAgICovXG4gICAgdXBkYXRlUGh5c2ljcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5ub2RlQnVmZmVyKSByZXR1cm47XG5cbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIGJ1ZmZlciAgICAgID0gbWUubm9kZUJ1ZmZlcixcbiAgICAgICAgICAgIG14ICAgICAgICAgID0gbWUubW91c2UueCxcbiAgICAgICAgICAgIG15ICAgICAgICAgID0gbWUubW91c2UueSxcbiAgICAgICAgICAgIHBhcmVudENvdW50ID0gTWF0aC5mbG9vcihOT0RFX0NPVU5UICogMC4xKSxcbiAgICAgICAgICAgIHMgICAgICAgICAgID0gbWUuc2NhbGU7IC8vIEdldCBzY2FsZSBmYWN0b3JcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5PREVfQ09VTlQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkeCA9IGkgKiBOT0RFX1NUUklERSxcbiAgICAgICAgICAgICAgICBwYXJlbnRJZCA9IGJ1ZmZlcltpZHggKyA2XSxcbiAgICAgICAgICAgICAgICBpc1BhcmVudCA9IHBhcmVudElkID09PSAtMTtcblxuICAgICAgICAgICAgLy8gLS0tIE1VVEFUSU9OIExPR0lDIChSZS1QYXJlbnRpbmcpIC0tLVxuICAgICAgICAgICAgaWYgKCFpc1BhcmVudCkge1xuICAgICAgICAgICAgICAgIC8vIDEuIENoYW5jZSB0byBkZXRhY2ggKGJlY29tZXMgRHJpZnRpbmc6IC0yKVxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRJZCAhPT0gLTIgJiYgTWF0aC5yYW5kb20oKSA8IDAuMDAwNSkgeyAvLyBSYXJlIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltpZHggKyA2XSA9IC0yO1xuICAgICAgICAgICAgICAgICAgICAvLyBCb29zdCB2ZWxvY2l0eSB0byBlc2NhcGVcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2lkeCArIDJdICs9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDIgKiBzO1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgM10gKz0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMiAqIHNcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyAyLiBSZS1hdHRhY2ggTG9naWMgKGlmIERyaWZ0aW5nKVxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRJZCA9PT0gLTIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2FuZGVyIGJlaGF2aW9yXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltpZHggKyAyXSArPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAwLjEgKiBzO1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgM10gKz0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMC4xICogcztcblxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgbmV3IHBhcmVudFxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IHBhcmVudENvdW50OyBwKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwSWR4ID0gcCAqIE5PREVfU1RSSURFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB4ICAgPSBidWZmZXJbcElkeF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHkgICA9IGJ1ZmZlcltwSWR4ICsgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzdCA9IE1hdGguc3FydCgocHggLSBidWZmZXJbaWR4XSkqKjIgKyAocHkgLSBidWZmZXJbaWR4ICsgMV0pKioyKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3QgPCA2MCAqIHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgNl0gPSBwOyAvLyBTbmFwIHRvIG5ldyBwYXJlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAxLiBDbHVzdGVyIENvaGVzaW9uIChDaGlsZHJlbiBzdGljayB0byBQYXJlbnQpXG4gICAgICAgICAgICBpZiAoIWlzUGFyZW50ICYmIGJ1ZmZlcltpZHggKyA2XSAhPT0gLTIpIHsgLy8gTm9ybWFsIENoaWxkXG4gICAgICAgICAgICAgICAgbGV0IHBJZHggPSBwYXJlbnRJZCAqIE5PREVfU1RSSURFLFxuICAgICAgICAgICAgICAgICAgICBweCAgID0gYnVmZmVyW3BJZHhdLFxuICAgICAgICAgICAgICAgICAgICBweSAgID0gYnVmZmVyW3BJZHggKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgZHggICA9IHB4IC0gYnVmZmVyW2lkeF0sXG4gICAgICAgICAgICAgICAgICAgIGR5ICAgPSBweSAtIGJ1ZmZlcltpZHggKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgZGlzdCA9IE1hdGguc3FydChkeCpkeCArIGR5KmR5KTtcblxuICAgICAgICAgICAgICAgIC8vIFNwcmluZyBmb3JjZSB0b3dhcmRzIHBhcmVudFxuICAgICAgICAgICAgICAgIGlmIChkaXN0ID4gNTAgKiBzKSB7IC8vIElkZWFsIGRpc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgIGxldCBmb3JjZSA9IChkaXN0IC0gNTAgKiBzKSAqIDAuMDAwNTsgLy8gQ29uc3RhbnQgc3ByaW5nIGZhY3RvciBpcyBmaW5lXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltpZHggKyAyXSArPSBkeCAqIGZvcmNlO1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgM10gKz0gZHkgKiBmb3JjZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gMi4gTW91c2UgUmVwdWxzaW9uIChBbGwgbm9kZXMpXG4gICAgICAgICAgICBpZiAobXggIT09IC0xMDAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGR4ICAgICA9IGJ1ZmZlcltpZHhdIC0gbXgsXG4gICAgICAgICAgICAgICAgICAgIGR5ICAgICA9IGJ1ZmZlcltpZHggKyAxXSAtIG15LFxuICAgICAgICAgICAgICAgICAgICBkaXN0U3EgPSBkeCAqIGR4ICsgZHkgKiBkeTtcblxuICAgICAgICAgICAgICAgIGlmIChkaXN0U3EgPCAyMjUwMCAqIHMgKiBzKSB7IC8vIDE1MCpzIHNxdWFyZWRcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRpc3QgID0gTWF0aC5zcXJ0KGRpc3RTcSksXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JjZSA9ICgxNTAgKiBzIC0gZGlzdCkgLyAoMTUwICogcyk7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltpZHggKyAyXSArPSAoZHggLyBkaXN0KSAqIGZvcmNlICogMC41ICogcztcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2lkeCArIDNdICs9IChkeSAvIGRpc3QpICogZm9yY2UgKiAwLjUgKiBzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAzLiBTaG9ja3dhdmUgUmVwdWxzaW9uIChFeHBsb3NpdmUgRm9yY2UpXG4gICAgICAgICAgICBpZiAobWUuc2hvY2t3YXZlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbWUuc2hvY2t3YXZlcy5mb3JFYWNoKHdhdmUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHJvZ3Jlc3MgPSB3YXZlLmFnZSAvIHdhdmUubWF4QWdlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9ncmVzcyA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlYXNlZCA9IDEgLSBNYXRoLnBvdygxIC0gcHJvZ3Jlc3MsIDMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdSYWQgID0gZWFzZWQgKiB3YXZlLm1heFJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkeCAgICA9IGJ1ZmZlcltpZHhdIC0gd2F2ZS54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR5ICAgID0gYnVmZmVyW2lkeCArIDFdIC0gd2F2ZS55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3QgID0gTWF0aC5zcXJ0KGR4KmR4ICsgZHkqZHkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIaXQgdGhlIFwiV2F2ZSBGcm9udFwiIChXaWR0aCBtYXRjaGVzIHZpc3VhbCByaW5nIH4yMHB4ICogc2NhbGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoZGlzdCAtIHdSYWQpIDwgMjAgKiBzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZvcmNlID0gKDEgLSBwcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFzc2l2ZSBJbXB1bHNlIChUaHJvd2luZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgMl0gKz0gKGR4IC8gZGlzdCkgKiBmb3JjZSAqIDEwICogcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgM10gKz0gKGR5IC8gZGlzdCkgKiBmb3JjZSAqIDEwICogc1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIDQuIFBoeXNpY3NcbiAgICAgICAgICAgIGJ1ZmZlcltpZHggKyAyXSAqPSAwLjk1OyAvLyBGcmljdGlvblxuICAgICAgICAgICAgYnVmZmVyW2lkeCArIDNdICo9IDAuOTU7XG5cbiAgICAgICAgICAgIC8vIEVuZXJneSBEZWNheVxuICAgICAgICAgICAgYnVmZmVyW2lkeCArIDhdICo9IDAuOTk7XG5cbiAgICAgICAgICAgIGxldCBkcmlmdCA9IGlzUGFyZW50ID8gMC4wMiA6IDAuMDE7XG5cbiAgICAgICAgICAgIC8vIDQuIEFtYmllbnQgRHJpZnQgLyBGbG93IEZpZWxkXG4gICAgICAgICAgICBpZiAoaXNQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBGTE9XIEZJRUxEIGZvciBQYXJlbnRzOiBDcmVhdGUgb3JnYW5pYyBjdXJyZW50c1xuICAgICAgICAgICAgICAgIC8vIENvbWJpbmUgU2luZS9Db3NpbmUgYmFzZWQgb24gcG9zaXRpb24gYW5kIHRpbWVcbiAgICAgICAgICAgICAgICBsZXQgYW5nbGUgPSAoTWF0aC5jb3MoYnVmZmVyW2lkeF0gICAgICogMC4wMDIgLyBzICsgbWUudGltZSAqIDAuNSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnNpbihidWZmZXJbaWR4ICsgMV0gKiAwLjAwMiAvIHMgKyBtZS50aW1lICogMC41KSkgKiBNYXRoLlBJO1xuXG4gICAgICAgICAgICAgICAgLy8gQWNjZWxlcmF0ZSBpbiBmbG93IGRpcmVjdGlvblxuICAgICAgICAgICAgICAgIGJ1ZmZlcltpZHggKyAyXSArPSBNYXRoLmNvcyhhbmdsZSkgKiAwLjA1ICogcztcbiAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgM10gKz0gTWF0aC5zaW4oYW5nbGUpICogMC4wNSAqIHM7XG5cbiAgICAgICAgICAgICAgICAvLyBDT05UQUlOTUVOVCBGSUVMRCAoRml4IGZvciBEcmlmdCBCaWFzKVxuICAgICAgICAgICAgICAgIC8vIEdlbnRseSBwdXNoIG5vZGVzIGJhY2sgdG8gY2VudGVyIGlmIHRoZXkgd2FuZGVyIHRvbyBmYXJcbiAgICAgICAgICAgICAgICBsZXQgY3ggICAgPSB3aWR0aCAvIDIsXG4gICAgICAgICAgICAgICAgICAgIGN5ICAgID0gaGVpZ2h0IC8gMixcbiAgICAgICAgICAgICAgICAgICAgZHggICAgPSBjeCAtIGJ1ZmZlcltpZHhdLFxuICAgICAgICAgICAgICAgICAgICBkeSAgICA9IGN5IC0gYnVmZmVyW2lkeCArIDFdLFxuICAgICAgICAgICAgICAgICAgICBkaXN0ICA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSksXG4gICAgICAgICAgICAgICAgICAgIGxpbWl0ID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCkgKiAwLjQ7IC8vIEtlZXAgd2l0aGluIDgwJSBvZiBzY3JlZW4gY2VudGVyXG5cbiAgICAgICAgICAgICAgICBpZiAoZGlzdCA+IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmb3JjZSA9IChkaXN0IC0gbGltaXQpICogMC4wMDE7IC8vIFNvZnQgc3ByaW5nXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltpZHggKyAyXSArPSAoZHggLyBkaXN0KSAqIGZvcmNlO1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgM10gKz0gKGR5IC8gZGlzdCkgKiBmb3JjZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUmFuZG9tIHdhbmRlciBmb3IgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoYnVmZmVyW2lkeCArIDJdKSA8IDAuMiAqIHMpIGJ1ZmZlcltpZHggKyAyXSArPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAwLjAyICogcztcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoYnVmZmVyW2lkeCArIDNdKSA8IDAuMiAqIHMpIGJ1ZmZlcltpZHggKyAzXSArPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAwLjAyICogc1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBidWZmZXJbaWR4XSAgICAgKz0gYnVmZmVyW2lkeCArIDJdO1xuICAgICAgICAgICAgYnVmZmVyW2lkeCArIDFdICs9IGJ1ZmZlcltpZHggKyAzXTtcblxuICAgICAgICAgICAgLy8gQm91bmNlXG4gICAgICAgICAgICBjb25zdCBwYWQgPSAyMCAqIHM7XG4gICAgICAgICAgICBpZiAoYnVmZmVyW2lkeF0gPCBwYWQpICAgICAgICAgICAgICB7IGJ1ZmZlcltpZHhdID0gcGFkOyBidWZmZXJbaWR4ICsgMl0gKj0gLTE7IH1cbiAgICAgICAgICAgIGlmIChidWZmZXJbaWR4XSA+IHdpZHRoIC0gcGFkKSAgICAgIHsgYnVmZmVyW2lkeF0gPSB3aWR0aCAtIHBhZDsgYnVmZmVyW2lkeCArIDJdICo9IC0xOyB9XG4gICAgICAgICAgICBpZiAoYnVmZmVyW2lkeCArIDFdIDwgcGFkKSAgICAgICAgICB7IGJ1ZmZlcltpZHggKyAxXSA9IHBhZDsgYnVmZmVyW2lkeCArIDNdICo9IC0xOyB9XG4gICAgICAgICAgICBpZiAoYnVmZmVyW2lkeCArIDFdID4gaGVpZ2h0IC0gcGFkKSB7IGJ1ZmZlcltpZHggKyAxXSA9IGhlaWdodCAtIHBhZDsgYnVmZmVyW2lkeCArIDNdICo9IC0xOyB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuZCBjYWNoZXMgZ3JhZGllbnRzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgKi9cbiAgICB1cGRhdGVSZXNvdXJjZXMod2lkdGgsIGhlaWdodCkge1xuICAgICAgICBsZXQgbWUgID0gdGhpcyxcbiAgICAgICAgICAgIGN0eCA9IG1lLmNvbnRleHQ7XG5cbiAgICAgICAgaWYgKCFjdHgpIHJldHVybjtcblxuICAgICAgICBjb25zdFxuICAgICAgICAgICAgdGhlbWVDb2xvcnMgPSBtZS5jb25zdHJ1Y3Rvci5jb2xvcnNbbWUudGhlbWVdLFxuICAgICAgICAgICAgZ3JhZGllbnQgICAgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsIHRoZW1lQ29sb3JzLmJhY2tncm91bmRbMF0pO1xuICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgdGhlbWVDb2xvcnMuYmFja2dyb3VuZFsxXSk7XG5cbiAgICAgICAgbWUuZ3JhZGllbnRzLmJnR3JhZGllbnQgPSBncmFkaWVudFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzaXplXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNpemUuaGVpZ2h0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNpemUud2lkdGhcbiAgICAgKi9cbiAgICB1cGRhdGVTaXplKHNpemUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5jYW52YXNTaXplID0gc2l6ZTtcbiAgICAgICAgLy8gUmVmZXJlbmNlIHJlc29sdXRpb246IDE5MjB4MTA4MC5cbiAgICAgICAgLy8gU3F1YXJlIHJvb3Qgb2YgYXJlYSByYXRpbyBnaXZlcyBhIGJhbGFuY2VkIGxpbmVhciBzY2FsZSBmYWN0b3IuXG4gICAgICAgIG1lLnNjYWxlID0gTWF0aC5zcXJ0KChzaXplLndpZHRoICogc2l6ZS5oZWlnaHQpIC8gMjA3MzYwMCk7XG5cbiAgICAgICAgaWYgKG1lLmNvbnRleHQpIHtcbiAgICAgICAgICAgIG1lLmNvbnRleHQuY2FudmFzLndpZHRoICA9IHNpemUud2lkdGg7XG4gICAgICAgICAgICBtZS5jb250ZXh0LmNhbnZhcy5oZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgICAgICAgICAgIC8vIEZJWDogQWx3YXlzIHJlLWluaXQgbm9kZXMgb24gcmVzaXplIHRvIGZpeCBcInRvcC1sZWZ0IGJsb2JcIiBpc3N1ZVxuICAgICAgICAgICAgbWUuaW5pdE5vZGVzKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcbiAgICAgICAgICAgIG1lLmluaXRBZ2VudHMoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuICAgICAgICAgICAgbWUudXBkYXRlUmVzb3VyY2VzKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhIb21lQ2FudmFzKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=