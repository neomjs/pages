export const __webpack_esm_id__ = "vendors-apps_portal_canvas_HomeCanvas_mjs";
export const __webpack_esm_ids__ = ["vendors-apps_portal_canvas_HomeCanvas_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./apps/portal/canvas/HomeCanvas.mjs"
/*!*******************************************!*\
  !*** ./apps/portal/canvas/HomeCanvas.mjs ***!
  \*******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_canvas_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/canvas/Base.mjs */ "./src/canvas/Base.mjs");


const
    hasRaf           = typeof requestAnimationFrame === 'function',
    PRIMARY          = '#3E63DD',
    SECONDARY        = '#536DFE',
    HIGHLIGHT        = '#00BFFF', // Deep Sky Blue (High Contrast)
    CONNECTION_COLOR = '#808080',
    NODE_COUNT       = 150,
    NODE_STRIDE      = 9, // x, y, vx, vy, radius, layer, parentId, phase, energy
    AGENT_COUNT      = 20,
    AGENT_STRIDE     = 6, // x, y, vx, vy, targetIdx, state
    PACKET_COUNT     = 20,
    PACKET_STRIDE    = 5; // x, y, vx, vy, life (0-1)

/**
 * @summary SharedWorker renderer for the Portal Home "Neural Swarm" background.
 *
 * Implements the **"Neural Swarm"** visual theme, a dynamic, mutable network simulation that
 * visualizes the Neo.mjs Application Engine as a living ecosystem.
 *
 * **Visual Architecture:**
 * 1. **Living Topology (The Graph):** Nodes are not static; they form hierarchical clusters representing
 *    Components within Containers. The topology is mutable, with sub-clusters occasionally detaching,
 * *    drifting, and re-parenting (Visualizing "Atomic Moves").
 * 2. **Autonomous Agents (The Neural Link):** "Seeker Drones" roam the graph using Boid behavior
 *    (Separation, Alignment, Cohesion). They "scan" nodes, transferring energy and triggering
 *    visual highlights, representing the active intelligence of the framework.
 * 3. **Data Flow (Signal Packets):** Pulses of light travel along connections from child to parent,
 *    visualizing the flow of events and data upstream.
 * 4. **Atmosphere (Parallax):** A multi-layered depth system creates a volumetric feel, distinguishing
 *    foreground "active" nodes from background "context" nodes.
 *
 * **Responsive Architecture (Reference Viewport):**
 * To ensure a consistent experience across devices (from Mobile to 4K), the simulation uses a **Reference Viewport Strategy**.
 * - **Baseline:** 1920x1080 is defined as scale `1.0`.
 * - **Dynamic Scaling:** On resize, a `scale` factor is calculated: `sqrt((width * height) / (1920 * 1080))`.
 * - **Normalization:** All physics constants (velocity, force), spatial dimensions (distances, radii), and
 *   visual properties (stroke width) are multiplied by this `scale`.
 * - **Density Control:** On small screens (`scale < 0.5`), the background layer is culled to prevent visual noise.
 *
 * **Theme System:**
 * Supports dynamic `light` and `dark` modes via the `theme` config.
 * - **Palette:** A static `colors` map defines semantic color slots (agentHead, spark, etc.) for each mode.
 * - **Hot-Swapping:** Changing the `theme` config triggers `updateResources` to regenerate gradients and
 *   immediately alters rendering colors in the next frame without re-initializing buffers.
 *
 * **Performance Architecture (Zero-Allocation):**
 * To maintain 60fps on high-refresh displays without GC stutters, this class employs a **Zero-Allocation** strategy during the render loop.
 * 1. **TypedArray Buffers:** All entity data (Nodes, Agents, Packets) is stored in pre-allocated `Float32Array` buffers.
 * 2. **Inlined Physics:** Vector calculations are performed inline without creating temporary Objects.
 * 3. **Gradient Caching:** CanvasGradients are created only on resize (`updateResources`) and cached.
 *
 * **Node Buffer Layout (Float32Array):**
 * - 0: x (Position X)
 * - 1: y (Position Y)
 * - 2: vx (Velocity X)
 * - 3: vy (Velocity Y)
 * - 4: radius (Visual size)
 * - 5: layer (Parallax depth: 0=back, 1=mid, 2=front)
 * - 6: parentId (Index of parent node, -1 if parent, -2 if drifting)
 * - 7: phase (Animation offset for breathing)
 * - 8: energy (Interaction state, 0-1)
 *
 * **Agent Buffer Layout (Float32Array):**
 * - 0: x
 * - 1: y
 * - 2: vx
 * - 3: vy
 * - 4: targetIdx (Index of target node, -1 if wandering)
 * - 5: state (0=moving, 1=scanning)
 *
 * **Packet Buffer Layout (Float32Array):**
 * - 0: x
 * - 1: y
 * - 2: vx
 * - 3: vy
 * - 4: life (Frames remaining, 0-1 normalized for alpha)
 *
 * @class Portal.canvas.HomeCanvas
 * @extends Portal.canvas.Base
 * @singleton
 */
class HomeCanvas extends _src_canvas_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static colors = {
        dark: {
            agentHead : '#FFFFFF',
            background: ['rgba(62, 99, 221, 0.15)', 'rgba(139, 166, 255, 0.15)'],
            nodeHigh  : '#FFFFFF',
            packet    : '#FFFFFF',
            shockwave : '#FFFFFF',
            spark     : '#4B0082'
        },
        light: {
            agentHead : '#3E63DD', // PRIMARY
            background: ['rgba(62, 99, 221, 0.05)', 'rgba(139, 166, 255, 0.05)'],
            nodeHigh  : '#3E63DD', // PRIMARY
            packet    : '#3E63DD', // PRIMARY
            shockwave : '#3E63DD', // PRIMARY
            spark     : '#4B0082'
        }
    }

    static config = {
        /**
         * @member {String} className='Portal.canvas.HomeCanvas'
         * @protected
         */
        className: 'Portal.canvas.HomeCanvas',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * Pre-allocated buffer for agent data (Seeker Drones).
     * @member {Float32Array|null} agentBuffer=null
     */
    agentBuffer = null
    /**
     * Pre-allocated buffer for node data (The Graph).
     * @member {Float32Array|null} nodeBuffer=null
     */
    nodeBuffer = null
    /**
     * Pre-allocated buffer for data packets (Signal Pulses).
     * @member {Float32Array|null} packetBuffer=null
     */
    packetBuffer = null
    /**
     * Active shockwave effects.
     * @member {Object[]} shockwaves=[]
     */
    shockwaves = []
    /**
     * Active spark particles (Data Debris).
     * @member {Object[]} sparks=[]
     */
    sparks = []
    /**
     * Scaling factor relative to a 1920x1080 reference viewport.
     * Used to ensure consistent physics and visuals across resolutions.
     * @member {Number} scale=1
     */
    scale = 1

    /**
     * Clears the graph state and stops the render loop.
     * Used when the component is destroyed or the route changes.
     */
    clearGraph() {
        let me = this;
        super.clearGraph();
        me.nodeBuffer   = null;
        me.agentBuffer  = null;
        me.packetBuffer = null;
        me.shockwaves   = [];
        me.sparks       = [];
        me.scale        = 1
    }

    /**
     * Hook to initialize nodes and agents after context is ready
     * @param {Number} width
     * @param {Number} height
     */
    onGraphMounted(width, height) {
        this.updateSize({width, height})
    }

    /**
     * Draws the autonomous agents (Seeker Drones).
     *
     * **Visuals:**
     * - **Head:** A solid circle indicating current position.
     * - **Trail:** A fading line drawn opposite to velocity, simulating motion blur.
     * - **Scan Effect:** A pulsing ring when the agent reaches a node (state=1).
     *
     * @param {CanvasRenderingContext2D} ctx
     */
    drawAgents(ctx) {
        let me = this;

        if (!me.agentBuffer) return;

        const
            buffer      = me.agentBuffer,
            count       = AGENT_COUNT,
            themeColors = me.constructor.colors[me.theme],
            s           = me.scale; // Get scale factor

        ctx.strokeStyle = HIGHLIGHT;
        ctx.fillStyle   = themeColors.agentHead;
        ctx.lineCap     = 'round';

        for (let i = 0; i < count; i++) {
            let idx   = i * AGENT_STRIDE,
                x     = buffer[idx],
                y     = buffer[idx + 1],
                vx    = buffer[idx + 2],
                vy    = buffer[idx + 3],
                state = buffer[idx + 5];

            // 1. Draw Trail (Motion Blur)
            let speed = Math.sqrt(vx*vx + vy*vy);

            if (speed > 0.1 * s) { // Scaled threshold
                ctx.beginPath();
                ctx.lineWidth = 2 * s; // Scaled line width
                ctx.globalAlpha = 0.6;
                ctx.moveTo(x, y);
                ctx.lineTo(x - vx * 4, y - vy * 4);
                ctx.stroke()
            }

            // 2. Draw Head
            ctx.beginPath();
            ctx.globalAlpha = state === 1 ? 1 : 0.8;
            let radius = (state === 1 ? 3 : 2) * s; // Scaled radius
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();

            // 3. Scan Effect
            if (state === 1) {
                ctx.beginPath();
                ctx.lineWidth = 1 * s; // Scaled width
                ctx.globalAlpha = 0.3;
                // Scaled ring radius
                ctx.arc(x, y, (8 + Math.sin(me.time * 10) * 2) * s, 0, Math.PI * 2);
                ctx.stroke()
            }
        }

        ctx.globalAlpha = 1
    }

    /**
     * Draws the neural network (nodes and connections).
     *
     * **Intent:**
     * Visualizes the "Application Graph".
     * - **Parallax:** Applies depth-based displacement based on mouse position.
     * - **Connections:** Lines are drawn only between related nodes (Parent-Child or Siblings).
     *   Lines thicken and brighten when near the mouse.
     * - **Nodes:** Circles breathing in size. Colors indicate depth (Layer) and energy state.
     *
     * **Optimization:**
     * Uses inlined math for parallax calculations to avoid allocating thousands of `{x,y}` objects per frame.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {Number} width
     * @param {Number} height
     */
    drawNetwork(ctx, width, height) {
        let me = this;

        if (!me.nodeBuffer) return;

        const
            buffer      = me.nodeBuffer,
            count       = NODE_COUNT,
            mx          = me.mouse.x,
            my          = me.mouse.y,
            cx          = width / 2,
            cy          = height / 2,
            themeColors = me.constructor.colors[me.theme],
            s           = me.scale; // Get scale factor

        ctx.lineWidth = 1 * s; // Scaled line width

        // 1. Draw Connections
        // Iterates all unique pairs to draw lines between connected nodes.
        // Connections are drawn if nodes share a parent (siblings) or are parent-child.
        for (let i = 0; i < count; i++) {
            let idx  = i * NODE_STRIDE,
                l1   = buffer[idx + 5],
                pid1 = buffer[idx + 6],
                // Inline getPos logic for p1 to avoid GC
                f1   = l1 === 2 ? 0.05 : (l1 === 1 ? 0.02 : 0.01),
                dx1  = (mx !== -1000 ? mx - cx : 0) * f1,
                dy1  = (my !== -1000 ? my - cy : 0) * f1,
                p1x  = buffer[idx] + dx1,
                p1y  = buffer[idx + 1] + dy1;

            for (let j = i + 1; j < count; j++) {
                let idx2 = j * NODE_STRIDE,
                    l2   = buffer[idx2 + 5],
                    pid2 = buffer[idx2 + 6];

                const
                    sameCluster   = pid1 === pid2 && pid1 !== -1,
                    isParentChild = (pid1 === j) || (pid2 === i),
                    isClusterLink = (pid1 === -1 && pid2 === -1);

                if (!sameCluster && !isParentChild && !isClusterLink) continue;

                let f2   = l2 === 2 ? 0.05 : (l2 === 1 ? 0.02 : 0.01),
                    dx2  = (mx !== -1000 ? mx - cx : 0) * f2,
                    dy2  = (my !== -1000 ? my - cy : 0) * f2,
                    p2x  = buffer[idx2] + dx2,
                    p2y  = buffer[idx2 + 1] + dy2,
                    dx   = p1x - p2x,
                    dy   = p1y - p2y,
                    distSq = dx*dx + dy*dy;

                // Culling: Only draw connections within a certain distance
                if (distSq < 40000 * s * s) { // Scaled distance squared
                    let dist  = Math.sqrt(distSq),
                        alpha = 1 - (dist / (200 * s)); // Scaled distance factor

                    alpha *= (0.2 + (l1 * 0.1));

                    let mDx = (p1x + p2x)/2 - mx,
                        mDy = (p1y + p2y)/2 - my,
                        mDistSq = mDx*mDx + mDy*mDy;

                    // Mouse Interaction: Highlight connections near cursor
                    if (mDistSq < 10000 * s * s) { // Scaled mouse distance
                        alpha = Math.min(alpha + 0.5, 1);
                        ctx.strokeStyle = HIGHLIGHT;
                        ctx.lineWidth   = 1.5 * s // Scaled
                    } else {
                        ctx.strokeStyle = l1 === 2 ? PRIMARY : SECONDARY;
                        // Elasticity: Thicker when closer (Tension/Slack visualization)
                        ctx.lineWidth = (0.5 + (1 - (dist / (200 * s)))) * s // Scaled
                    }

                    ctx.beginPath();
                    ctx.globalAlpha = alpha * 0.5;
                    ctx.moveTo(p1x, p1y);
                    ctx.lineTo(p2x, p2y);
                    ctx.stroke()
                }
            }
        }

        // 2. Draw Nodes
        for (let i = 0; i < count; i++) {
            let idx      = i * NODE_STRIDE,
                radius   = buffer[idx + 4],
                layer    = buffer[idx + 5],
                parentId = buffer[idx + 6],
                phase    = buffer[idx + 7],
                energy   = buffer[idx + 8];

            // Culling: Skip background layer on very small screens to reduce noise
            if (s < 0.5 && layer === 0) continue;

            let
                // Inline getPos logic for pos
                f        = layer === 2 ? 0.05 : (layer === 1 ? 0.02 : 0.01),
                pDx      = (mx !== -1000 ? mx - cx : 0) * f,
                pDy      = (my !== -1000 ? my - cy : 0) * f,
                posX     = buffer[idx] + pDx,
                posY     = buffer[idx + 1] + pDy,
                dx       = posX - mx,
                dy       = posY - my,
                dist     = Math.sqrt(dx * dx + dy * dy),
                isHover  = dist < 50 * s; // Scaled hover distance

            // Shockwave Interaction
            if (me.shockwaves.length > 0) {
                me.shockwaves.forEach(wave => {
                    let wDist = Math.sqrt((posX - wave.x)**2 + (posY - wave.y)**2),
                        wRad  = wave.age * wave.speed;
                    if (Math.abs(wDist - wRad) < 20 * s) { // Scaled wave width
                        isHover = true;
                    }
                });
            }

            ctx.beginPath();
            let r = parentId === -1 ? radius * 1.5 : radius;

            // Breathing + Energy
            r *= 1 + Math.sin(me.time * 2 + phase) * 0.15 + energy;

            if (isHover) {
                r *= 1.5;
            }

            ctx.arc(posX, posY, r, 0, Math.PI * 2);

            if (energy > 0.1) {
                // Energetic Node (Agent Scanned)
                ctx.fillStyle = HIGHLIGHT;
                ctx.globalAlpha = Math.min(1, 0.5 + energy)
            } else if (layer === 2) {
                ctx.fillStyle = isHover ? themeColors.nodeHigh : PRIMARY;
                ctx.globalAlpha = isHover ? 1 : 0.8
            } else if (parentId === -2) {
                // Drifting Node Visual
                ctx.fillStyle = HIGHLIGHT;
                ctx.globalAlpha = 0.6 + Math.sin(me.time * 10 + phase) * 0.3
            } else if (layer === 1) {
                ctx.fillStyle = isHover ? HIGHLIGHT : SECONDARY;
                ctx.globalAlpha = 0.5
            } else {
                ctx.fillStyle = CONNECTION_COLOR;
                ctx.globalAlpha = 0.2
            }

            ctx.fill();
        }

        ctx.globalAlpha = 1
    }

    /**
     * Draws the data packets traveling along connections.
     * Packets represent signal flow between nodes.
     * @param {OffscreenCanvasRenderingContext2D} ctx
     */
    drawPackets(ctx) {
        let me = this;

        if (!me.packetBuffer) return;

        const
            buffer      = me.packetBuffer,
            count       = PACKET_COUNT,
            themeColors = me.constructor.colors[me.theme];

        ctx.fillStyle   = themeColors.packet;
        ctx.shadowBlur  = 5;
        ctx.shadowColor = HIGHLIGHT;

        for (let i = 0; i < count; i++) {
            let idx  = i * PACKET_STRIDE,
                life = buffer[idx + 4];

            if (life > 0) {
                let x = buffer[idx],
                    y = buffer[idx + 1];

                ctx.beginPath();
                ctx.globalAlpha = Math.min(life * 2, 1); // Fade out at end
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fill()
            }
        }

        ctx.shadowBlur  = 0;
        ctx.globalAlpha = 1
    }

    /**
     * Draws expanding shockwaves from clicks with Chromatic Aberration and Composite Rings.
     * Uses optimized RGBA composition to reduce GC pressure.
     * @param {OffscreenCanvasRenderingContext2D} ctx
     */
    drawShockwaves(ctx) {
        let me = this;

        if (me.shockwaves.length === 0) return;

        const
            themeColors = me.constructor.colors[me.theme],
            s           = me.scale;

        ctx.lineCap = 'round';

        for (let i = me.shockwaves.length - 1; i >= 0; i--) {
            let wave = me.shockwaves[i];
            wave.age++;

            let progress = wave.age / wave.maxAge;

            if (progress >= 1) {
                me.shockwaves.splice(i, 1);
                continue;
            }

            // Non-Linear Expansion (Explosive start, slow finish)
            let eased = 1 - Math.pow(1 - progress, 3),
                radius = eased * wave.maxRadius,
                alpha  = 1 - progress;

            // Chromatic Aberration (Shifted to Neon Blue/Cyan theme)

            // 1. Cyan Channel (Lagging Fringe) - Replaces Red
            ctx.beginPath();
            ctx.strokeStyle = HIGHLIGHT;
            ctx.globalAlpha = alpha * 0.8;
            ctx.lineWidth   = 4 * (1 - progress) * s; // Scaled
            ctx.shadowBlur  = 10 * s; // Scaled
            ctx.shadowColor = HIGHLIGHT;
            ctx.arc(wave.x, wave.y, radius * 0.99, 0, Math.PI * 2);
            ctx.stroke();

            // 2. Blue Channel (Leading Fringe)
            ctx.beginPath();
            ctx.strokeStyle = PRIMARY;
            ctx.globalAlpha = alpha * 0.8;
            ctx.lineWidth   = 4 * (1 - progress) * s; // Scaled
            ctx.shadowBlur  = 10 * s; // Scaled
            ctx.shadowColor = PRIMARY;
            ctx.arc(wave.x, wave.y, radius * 1.01, 0, Math.PI * 2);
            ctx.stroke();

            // 3. Primary Wave (White Hot Center)
            ctx.beginPath();
            ctx.strokeStyle = themeColors.shockwave;
            ctx.globalAlpha = alpha;
            ctx.lineWidth   = 6 * (1 - progress) * s; // Scaled
            ctx.shadowBlur  = 20 * s; // Scaled
            ctx.shadowColor = themeColors.shockwave;
            ctx.arc(wave.x, wave.y, radius, 0, Math.PI * 2);
            ctx.stroke();

            // 4. Pressure Fill (Refraction Fake)
            ctx.fillStyle = PRIMARY;
            ctx.globalAlpha = alpha * 0.05;
            ctx.fill();
        }

        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1
    }

    /**
     * Draws temporary spark particles (Data Debris).
     * @param {OffscreenCanvasRenderingContext2D} ctx
     */
    drawSparks(ctx) {
        let me = this;

        if (me.sparks.length === 0) return;

        const
            themeColors = me.constructor.colors[me.theme],
            s           = me.scale;

        ctx.strokeStyle = themeColors.spark;
        ctx.shadowBlur = 0; // Crisp lines on white
        ctx.lineWidth = 2 * s; // Scaled width

        for (let s of me.sparks) {
            ctx.globalAlpha = s.life;
            ctx.beginPath();
            // Draw Trail based on velocity
            ctx.moveTo(s.x, s.y);
            ctx.lineTo(s.x - s.vx * 2, s.y - s.vy * 2);
            ctx.stroke()
        }

        ctx.globalAlpha = 1
    }

    /**
     * Initializes the autonomous agents.
     * Agents start at random positions with random high-velocity vectors.
     * @param {Number} width
     * @param {Number} height
     */
    initAgents(width, height) {
        let me = this;

        if (!me.agentBuffer) {
            me.agentBuffer = new Float32Array(AGENT_COUNT * AGENT_STRIDE);
        }

        const
            buffer = me.agentBuffer,
            s      = me.scale;

        for (let i = 0; i < AGENT_COUNT; i++) {
            let idx = i * AGENT_STRIDE;

            buffer[idx]     = Math.random() * width;  // x
            buffer[idx + 1] = Math.random() * height; // y
            buffer[idx + 2] = (Math.random() - 0.5) * 4 * s; // vx (Fast!)
            buffer[idx + 3] = (Math.random() - 0.5) * 4 * s; // vy
            buffer[idx + 4] = -1; // targetIdx (none)
            buffer[idx + 5] = 0   // state (moving)
        }
    }

    /**
     * Initializes the node buffer using **Golden Spiral** distribution.
     * This ensures a uniform but organic-looking distribution of nodes across the screen,
     * preventing the "clumping" seen with random placement.
     * @param {Number} width
     * @param {Number} height
     */
    initNodes(width, height) {
        let me = this;

        if (!me.nodeBuffer) {
            me.nodeBuffer = new Float32Array(NODE_COUNT * NODE_STRIDE);
        }

        const
            buffer        = me.nodeBuffer,
            cx            = width / 2,
            cy            = height / 2,
            phi           = (1 + Math.sqrt(5)) / 2,
            scale         = Math.sqrt(width * height / NODE_COUNT) * 0.8,
            parentCount   = Math.floor(NODE_COUNT * 0.1),
            s             = me.scale; // Use the calculated scale factor

        let parentIndices = [];

        for (let i = 0; i < NODE_COUNT; i++) {
            let idx = i * NODE_STRIDE,
                isParent = i < parentCount;

            if (isParent) parentIndices.push(i);

            let theta = i * 2 * Math.PI * phi,
                r     = Math.sqrt(i) * scale;

            // Simple wrap to keep initial spiral inside reasonable bounds
            let x = cx + r * Math.cos(theta),
                y = cy + r * Math.sin(theta);

            // If the spiral is larger than screen, wrap it
            x = ((x % width) + width) % width;
            y = ((y % height) + height) % height;

            buffer[idx]     = x;
            buffer[idx + 1] = y;
            buffer[idx + 2] = (Math.random() - 0.5) * 0.2 * s; // Scale velocity
            buffer[idx + 3] = (Math.random() - 0.5) * 0.2 * s;

            let layer = Math.floor(Math.random() * 3);
            buffer[idx + 5] = layer; // layer

            // Radius based on layer & role (Scaled)
            buffer[idx + 4] = (isParent ? 4 + (layer * 2) : 2 + (layer * 1.5)) * s;

            // Parent ID (-1 for parents, assigned later for children)
            buffer[idx + 6] = isParent ? -1 : -2;

            // Phase (Breathing offset)
            buffer[idx + 7] = Math.random() * Math.PI * 2;

            // Energy
            buffer[idx + 8] = 0;
        }

        // 2. Assign Children to nearest Parent
        for (let i = parentCount; i < NODE_COUNT; i++) {
            let idx        = i * NODE_STRIDE,
                x          = buffer[idx],
                y          = buffer[idx + 1],
                bestDist   = Infinity,
                bestParent = -1;

            for (let pid of parentIndices) {
                let pIdx = pid * NODE_STRIDE,
                    px   = buffer[pIdx],
                    py   = buffer[pIdx + 1],
                    dx   = x - px,
                    dy   = y - py,
                    dSq  = dx*dx + dy*dy;

                if (dSq < bestDist) {
                    bestDist = dSq;
                    bestParent = pid;
                }
            }

            buffer[idx + 6] = bestParent
        }
    }

    /**
     * Initializes the packet buffer.
     */
    initPackets() {
        let me = this;
        if (!me.packetBuffer) {
            me.packetBuffer = new Float32Array(PACKET_COUNT * PACKET_STRIDE)
        }
    }

    /**
     * @member {Function} renderLoop=this.render.bind(this)
     */
    renderLoop = this.render.bind(this)

    /**
     * Main simulation and render loop.
     * Executed ~60 times per second.
     */
    render() {
        let me = this;

        if (!me.canRender) {
            return
        }

        const
            ctx    = me.context,
            width  = me.canvasSize?.width  || 100,
            height = me.canvasSize?.height || 50;

        me.time += 0.01;

        if (!me.nodeBuffer) me.initNodes(width, height);
        if (!me.agentBuffer) me.initAgents(width, height);
        if (!me.packetBuffer) me.initPackets();

        // Physics Update Steps
        me.updatePhysics(width, height);
        me.updateAgents(width, height);
        me.updatePackets();
        me.updateSparks();

        // Rendering Steps
        ctx.clearRect(0, 0, width, height);

        if (me.gradients.bgGradient) {
            ctx.fillStyle = me.gradients.bgGradient;
            ctx.fillRect(0, 0, width, height)
        }

        me.drawNetwork(ctx, width, height);
        me.drawPackets(ctx);
        me.drawAgents(ctx);
        me.drawShockwaves(ctx);
        me.drawSparks(ctx);

        if (hasRaf) {
            me.animationId = requestAnimationFrame(me.renderLoop)
        } else {
            me.animationId = setTimeout(me.renderLoop, 1000 / 60)
        }
    }

    /**
     * Triggers shockwaves on click.
     * @param {Object} data
     */
    onMouseClick(data) {
        let me = this,
            s  = me.scale;

        me.shockwaves.push({
            x        : data.x,
            y        : data.y,
            age      : 0,
            maxAge   : 40, // Faster, punchier wave
            maxRadius: 300 * s // Scaled radius
        });

        // Spawn Sparks (Data Debris)
        for(let i=0; i<40; i++) {
            let angle = Math.random() * Math.PI * 2,
                speed = (Math.random() * 15 + 5) * s; // Scaled speed
            me.sparks.push({
                x    : data.x,
                y    : data.y,
                vx   : Math.cos(angle) * speed,
                vy   : Math.sin(angle) * speed,
                life : 1.0,
                decay: 0.02 + Math.random() * 0.03
            })
        }
    }

    /**
     * Updates packet logic (Data Flow).
     * Packets spawn randomly at child nodes and travel to their parent nodes,
     * representing data reporting upstream.
     */
    updatePackets() {
        let me = this;
        if (!me.packetBuffer || !me.nodeBuffer) return;

        const
            packets = me.packetBuffer,
            nodes   = me.nodeBuffer,
            pCount  = PACKET_COUNT,
            nCount  = NODE_COUNT,
            s       = me.scale; // Get scale factor

        for (let i = 0; i < pCount; i++) {
            let idx = i * PACKET_STRIDE,
                life = packets[idx + 4];

            if (life <= 0) {
                // Spawn new packet? (Random chance)
                if (Math.random() < 0.02) {
                    // Pick random node (source)
                    let n1 = Math.floor(Math.random() * nCount),
                        idx1 = n1 * NODE_STRIDE,
                        pid = nodes[idx1 + 6]; // Parent ID

                    // Valid targets: Parent (if child), or Child (if parent)
                    // Simplified: Just go Child -> Parent for now (Data reporting)
                    if (pid !== -1) { // If it's a child
                        let idx2 = pid * NODE_STRIDE,
                            x1   = nodes[idx1], y1 = nodes[idx1 + 1],
                            x2   = nodes[idx2], y2 = nodes[idx2 + 1],
                            dx   = x2 - x1,
                            dy   = y2 - y1,
                            dist = Math.sqrt(dx * dx + dy * dy);

                        // Only spawn if connected and close
                        if (dist < 200 * s) { // Scaled distance check
                            packets[idx]     = x1;
                            packets[idx + 1] = y1;
                            let speed        = 4 * s; // Scaled speed
                            packets[idx + 2] = (dx / dist) * speed;
                            packets[idx + 3] = (dy / dist) * speed;
                            packets[idx + 4] = dist / speed // Life = frames to reach target (stays same)
                        }
                    }
                }
            } else {
                // Move
                packets[idx]     += packets[idx + 2];
                packets[idx + 1] += packets[idx + 3];
                packets[idx + 4]-- // Decrease life
            }
        }
    }

    /**
     * Updates spark particles with friction and decay.
     */
    updateSparks() {
        let me = this;
        for (let i = me.sparks.length - 1; i >= 0; i--) {
            let s = me.sparks[i];
            s.x += s.vx;
            s.y += s.vy;
            // Friction (Drag)
            s.vx *= 0.9;
            s.vy *= 0.9;
            s.life -= s.decay;
            if (s.life <= 0) {
                me.sparks.splice(i, 1)
            }
        }
    }

    /**
     * Updates agent positions using **Boid** logic (Seek, Separate).
     * Agents randomly pick a target node, seek it, scan it (transferring energy),
     * and then pick a new target. They also avoid the mouse cursor.
     * @param {Number} width
     * @param {Number} height
     */
    updateAgents(width, height) {
        let me = this;

        if (!me.agentBuffer || !me.nodeBuffer) return;

        const
            agents = me.agentBuffer,
            nodes  = me.nodeBuffer,
            count  = AGENT_COUNT,
            mx     = me.mouse.x,
            my     = me.mouse.y,
            s      = me.scale; // Get scale factor

        for (let i = 0; i < count; i++) {
            let idx = i * AGENT_STRIDE,
                targetIdx = agents[idx + 4],
                state = agents[idx + 5];

            // Behavior 1: Pick a Target
            if (targetIdx === -1 || Math.random() < 0.005) {
                const parentCount = Math.floor(NODE_COUNT * 0.1);
                agents[idx + 4] = Math.floor(Math.random() * parentCount);
                targetIdx = agents[idx + 4];
                agents[idx + 5] = 0;
            }

            // Behavior 2: Seek Target
            if (targetIdx !== -1 && state === 0) {
                let nIdx = targetIdx * NODE_STRIDE,
                    tx   = nodes[nIdx],
                    ty   = nodes[nIdx + 1],
                    dx   = tx - agents[idx],
                    dy   = ty - agents[idx + 1],
                    dist = Math.sqrt(dx*dx + dy*dy);

                if (dist < 10 * s) { // Scaled arrival distance
                    // Arrived! Scan.
                    agents[idx + 5] = 1; // Scan state
                    agents[idx + 2] *= 0.1; // Slow down
                    agents[idx + 3] *= 0.1;

                    // Transfer Energy to Node
                    nodes[nIdx + 8] = 1.0;
                } else {
                    // Steer towards target
                    let force = 0.05 * s; // Scaled steering force
                    agents[idx + 2] += (dx / dist) * force;
                    agents[idx + 3] += (dy / dist) * force;
                }
            } else if (state === 1) {
                if (Math.random() < 0.02) {
                    agents[idx + 4] = -1;
                    agents[idx + 5] = 0;
                    agents[idx + 2] += (Math.random() - 0.5) * 4 * s; // Scaled random burst
                    agents[idx + 3] += (Math.random() - 0.5) * 4 * s;
                }
            }

            // Behavior 3: Mouse Repulsion
            if (mx !== -1000) {
                let dx = agents[idx] - mx,
                    dy = agents[idx + 1] - my,
                    distSq = dx*dx + dy*dy;

                if (distSq < 10000 * s * s) { // Scaled interaction radius squared
                    let dist  = Math.sqrt(distSq),
                        force = (100 * s - dist) / (100 * s); // Scaled force calculation
                    agents[idx + 2] += (dx / dist) * force * 1.5 * s;
                    agents[idx + 3] += (dy / dist) * force * 1.5 * s;
                    agents[idx + 5] = 0
                }
            }

            // Speed Limit & Move
            let speed = Math.sqrt(agents[idx + 2]**2 + agents[idx + 3]**2);
            if (speed > 4 * s) { // Scaled speed limit
                agents[idx + 2] *= (4 * s) / speed;
                agents[idx + 3] *= (4 * s) / speed
            }

            agents[idx]     += agents[idx + 2];
            agents[idx + 1] += agents[idx + 3];

            if (agents[idx] < 0) agents[idx] = width;
            if (agents[idx] > width) agents[idx] = 0;
            if (agents[idx + 1] < 0) agents[idx + 1] = height;
            if (agents[idx + 1] > height) agents[idx + 1] = 0;
        }
    }

    /**
     * Updates node positions using **Cluster Physics**.
     * Handles:
     * 1.  **Cohesion:** Children stick to parents.
     * 2.  **Flow Fields:** Parents drift in organic patterns.
     * 3.  **Topology Mutation:** Nodes can detach and re-parent.
     * 4.  **Interaction:** Mouse repulsion and shockwave explosion.
     * @param {Number} width
     * @param {Number} height
     */
    updatePhysics(width, height) {
        let me = this;

        if (!me.nodeBuffer) return;

        const
            buffer      = me.nodeBuffer,
            mx          = me.mouse.x,
            my          = me.mouse.y,
            parentCount = Math.floor(NODE_COUNT * 0.1),
            s           = me.scale; // Get scale factor

        for (let i = 0; i < NODE_COUNT; i++) {
            let idx = i * NODE_STRIDE,
                parentId = buffer[idx + 6],
                isParent = parentId === -1;

            // --- MUTATION LOGIC (Re-Parenting) ---
            if (!isParent) {
                // 1. Chance to detach (becomes Drifting: -2)
                if (parentId !== -2 && Math.random() < 0.0005) { // Rare event
                    buffer[idx + 6] = -2;
                    // Boost velocity to escape
                    buffer[idx + 2] += (Math.random() - 0.5) * 2 * s;
                    buffer[idx + 3] += (Math.random() - 0.5) * 2 * s
                }

                // 2. Re-attach Logic (if Drifting)
                if (parentId === -2) {
                    // Wander behavior
                    buffer[idx + 2] += (Math.random() - 0.5) * 0.1 * s;
                    buffer[idx + 3] += (Math.random() - 0.5) * 0.1 * s;

                    // Check for new parent
                    for (let p = 0; p < parentCount; p++) {
                        let pIdx = p * NODE_STRIDE,
                            px   = buffer[pIdx],
                            py   = buffer[pIdx + 1],
                            dist = Math.sqrt((px - buffer[idx])**2 + (py - buffer[idx + 1])**2);

                        if (dist < 60 * s) {
                            buffer[idx + 6] = p; // Snap to new parent
                            break
                        }
                    }
                }
            }

            // 1. Cluster Cohesion (Children stick to Parent)
            if (!isParent && buffer[idx + 6] !== -2) { // Normal Child
                let pIdx = parentId * NODE_STRIDE,
                    px   = buffer[pIdx],
                    py   = buffer[pIdx + 1],
                    dx   = px - buffer[idx],
                    dy   = py - buffer[idx + 1],
                    dist = Math.sqrt(dx*dx + dy*dy);

                // Spring force towards parent
                if (dist > 50 * s) { // Ideal distance
                    let force = (dist - 50 * s) * 0.0005; // Constant spring factor is fine
                    buffer[idx + 2] += dx * force;
                    buffer[idx + 3] += dy * force
                }
            }

            // 2. Mouse Repulsion (All nodes)
            if (mx !== -1000) {
                let dx     = buffer[idx] - mx,
                    dy     = buffer[idx + 1] - my,
                    distSq = dx * dx + dy * dy;

                if (distSq < 22500 * s * s) { // 150*s squared
                    let dist  = Math.sqrt(distSq),
                        force = (150 * s - dist) / (150 * s);
                    buffer[idx + 2] += (dx / dist) * force * 0.5 * s;
                    buffer[idx + 3] += (dy / dist) * force * 0.5 * s
                }
            }

            // 3. Shockwave Repulsion (Explosive Force)
            if (me.shockwaves.length > 0) {
                me.shockwaves.forEach(wave => {
                    let progress = wave.age / wave.maxAge;

                    if (progress < 1) {
                        let eased = 1 - Math.pow(1 - progress, 3),
                            wRad  = eased * wave.maxRadius,
                            dx    = buffer[idx] - wave.x,
                            dy    = buffer[idx + 1] - wave.y,
                            dist  = Math.sqrt(dx*dx + dy*dy);

                        // Hit the "Wave Front" (Width matches visual ring ~20px * scale)
                        if (Math.abs(dist - wRad) < 20 * s) {
                            let force = (1 - progress);
                            // Massive Impulse (Throwing)
                            buffer[idx + 2] += (dx / dist) * force * 10 * s;
                            buffer[idx + 3] += (dy / dist) * force * 10 * s
                        }
                    }
                });
            }

            // 4. Physics
            buffer[idx + 2] *= 0.95; // Friction
            buffer[idx + 3] *= 0.95;

            // Energy Decay
            buffer[idx + 8] *= 0.99;

            let drift = isParent ? 0.02 : 0.01;

            // 4. Ambient Drift / Flow Field
            if (isParent) {
                // FLOW FIELD for Parents: Create organic currents
                // Combine Sine/Cosine based on position and time
                let angle = (Math.cos(buffer[idx]     * 0.002 / s + me.time * 0.5) +
                             Math.sin(buffer[idx + 1] * 0.002 / s + me.time * 0.5)) * Math.PI;

                // Accelerate in flow direction
                buffer[idx + 2] += Math.cos(angle) * 0.05 * s;
                buffer[idx + 3] += Math.sin(angle) * 0.05 * s;

                // CONTAINMENT FIELD (Fix for Drift Bias)
                // Gently push nodes back to center if they wander too far
                let cx    = width / 2,
                    cy    = height / 2,
                    dx    = cx - buffer[idx],
                    dy    = cy - buffer[idx + 1],
                    dist  = Math.sqrt(dx * dx + dy * dy),
                    limit = Math.min(width, height) * 0.4; // Keep within 80% of screen center

                if (dist > limit) {
                    let force = (dist - limit) * 0.001; // Soft spring
                    buffer[idx + 2] += (dx / dist) * force;
                    buffer[idx + 3] += (dy / dist) * force
                }
            } else {
                // Random wander for children
                if (Math.abs(buffer[idx + 2]) < 0.2 * s) buffer[idx + 2] += (Math.random() - 0.5) * 0.02 * s;
                if (Math.abs(buffer[idx + 3]) < 0.2 * s) buffer[idx + 3] += (Math.random() - 0.5) * 0.02 * s
            }

            buffer[idx]     += buffer[idx + 2];
            buffer[idx + 1] += buffer[idx + 3];

            // Bounce
            const pad = 20 * s;
            if (buffer[idx] < pad)              { buffer[idx] = pad; buffer[idx + 2] *= -1; }
            if (buffer[idx] > width - pad)      { buffer[idx] = width - pad; buffer[idx + 2] *= -1; }
            if (buffer[idx + 1] < pad)          { buffer[idx + 1] = pad; buffer[idx + 3] *= -1; }
            if (buffer[idx + 1] > height - pad) { buffer[idx + 1] = height - pad; buffer[idx + 3] *= -1; }
        }
    }

    /**
     * Creates and caches gradients.
     * @param {Number} width
     * @param {Number} height
     */
    updateResources(width, height) {
        let me  = this,
            ctx = me.context;

        if (!ctx) return;

        const
            themeColors = me.constructor.colors[me.theme],
            gradient    = ctx.createLinearGradient(0, 0, width, height);

        gradient.addColorStop(0, themeColors.background[0]);
        gradient.addColorStop(1, themeColors.background[1]);

        me.gradients.bgGradient = gradient
    }

    /**
     * @param {Object} size
     * @param {Number} size.height
     * @param {Number} size.width
     */
    updateSize(size) {
        let me = this;

        me.canvasSize = size;
        // Reference resolution: 1920x1080.
        // Square root of area ratio gives a balanced linear scale factor.
        me.scale = Math.sqrt((size.width * size.height) / 2073600);

        if (me.context) {
            me.context.canvas.width  = size.width;
            me.context.canvas.height = size.height;
            // FIX: Always re-init nodes on resize to fix "top-left blob" issue
            me.initNodes(size.width, size.height);
            me.initAgents(size.width, size.height);
            me.updateResources(size.width, size.height)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(HomeCanvas));


/***/ },

/***/ "./src/canvas/Base.mjs"
/*!*****************************!*\
  !*** ./src/canvas/Base.mjs ***!
  \*****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @summary Abstract base class for Canvas Renderers.
 *
 * This class serves as the foundation for the specialized canvas visualizations (Header, Home, Services, Ticket)
 * that run within the **Neo.mjs Canvas SharedWorker**.
 *
 * It creates helper singletons that manage their own `OffscreenCanvas` instances, providing a standardized
 * architecture for:
 * - **Lifecycle Management:** Initialization (`initGraph`), destruction (`clearGraph`), and resource cleanup.
 * - **Render Loop Control:** Unified `render` loop with pause/resume capabilities and frame scheduling.
 * - **Context Management:** Robust handling of `OffscreenCanvas` transfer and context acquisition via `waitForCanvas`.
 * - **Shared State:** Common state management for mouse interaction, time, and theming.
 *
 * These renderers operate off the main thread to ensure high-performance, 60fps animations without
 * blocking the UI.
 *
 * @class Neo.canvas.Base
 * @extends Neo.core.Base
 */
class Base extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.canvas.Base'
         * @protected
         */
        className: 'Neo.canvas.Base',
        /**
         * Remote method access
         * @member {Object} remote
         * @protected
         */
        remote: {
            app: [
                'clearGraph',
                'initGraph',
                'pause',
                'resume',
                'setTheme',
                'updateMouseState',
                'updateSize'
            ]
        },
        /**
         * The active color theme ('light' or 'dark').
         * @member {String} theme_='light'
         * @reactive
         */
        theme_: 'light'
    }

    /**
     * @member {Number|null} animationId=null
     */
    animationId = null
    /**
     * @member {String|null} canvasId=null
     */
    canvasId = null
    /**
     * @member {Object|null} canvasSize=null
     */
    canvasSize = null
    /**
     * @member {OffscreenCanvasRenderingContext2D|null} context=null
     */
    context = null
    /**
     * Cache for reusable gradients to prevent GC.
     * @member {Object} gradients={}
     */
    gradients = {}
    /**
     * Flag to pause the render loop.
     * @member {Boolean} isPaused=false
     */
    isPaused = false
    /**
     * Tracked mouse position for interactive physics.
     * Initialize off-screen to prevent startup jitters.
     * @member {Object} mouse={x: -1000, y: -1000}
     */
    mouse = {x: -1000, y: -1000}
    /**
     * Global simulation time.
     * @member {Number} time=0
     */
    time = 0

    /**
     * @member {Function} renderLoop=this.render.bind(this)
     */
    renderLoop = this.render.bind(this)

    /**
     * Triggered after the `theme` config is changed.
     * Updates the resource cache (gradients, colors) to reflect the new theme immediately.
     * @param {String} value
     * @param {String} oldValue
     */
    afterSetTheme(value, oldValue) {
        if (value && this.canvasSize) {
            this.updateResources?.(this.canvasSize.width, this.canvasSize.height)
        }
    }

    /**
     * Checks if the canvas is ready to render.
     * Returns true only if the context exists and the simulation is not paused.
     * Subclasses should call this at the start of their `render` loop.
     * @returns {Boolean}
     */
    get canRender() {
        let me = this;
        return !!(me.context && !me.isPaused)
    }

    /**
     * Clears the graph state and stops the render loop.
     * Use this to cleanup resources when the component is destroyed or unmounted.
     */
    clearGraph() {
        let me = this;
        me.context     = null;
        me.canvasId    = null;
        me.canvasSize  = null;
        me.animationId = null;
        me.isPaused    = false;
        me.gradients   = {};
        me.mouse       = {x: -1000, y: -1000};
        me.time        = 0
    }

    /**
     * Initializes the canvas context.
     * Starts the polling mechanism to wait for the OffscreenCanvas transfer from the Main Thread.
     * @param {Object} opts
     * @param {String} opts.canvasId
     * @param {String} opts.windowId
     */
    initGraph({canvasId, windowId}) {
        let me        = this,
            hasChange = me.canvasId !== canvasId;

        me.canvasId = canvasId;

        me.waitForCanvas(canvasId, windowId, hasChange)
    }

    /**
     * Hook for subclasses to handle mouse clicks.
     * Called by `updateMouseState` when a click event is received.
     * @param {Object} data
     */
    onMouseClick(data) {}

    /**
     * Pauses the simulation.
     * The render loop will exit early while `isPaused` is true.
     */
    pause() {
        this.isPaused = true
    }

    /**
     * Abstract render method.
     * Subclasses must implement this method to draw the frame.
     */
    render() {}

    /**
     * Resumes the simulation.
     * If the simulation was paused, this restarts the render loop.
     */
    resume() {
        let me = this;

        if (me.isPaused) {
            me.isPaused = false;
            me.renderLoop()
        }
    }

    /**
     * Exposed method for Remote Access to trigger the reactive config setter.
     * @param {String} value
     */
    setTheme(value) {
        this.theme = value
    }

    /**
     * Updates the local mouse state from main thread events.
     * Delegates click events to `onMouseClick`.
     * @param {Object} data
     * @param {Boolean} [data.click]
     * @param {Boolean} [data.leave]
     * @param {Number} [data.x]
     * @param {Number} [data.y]
     */
    updateMouseState(data) {
        let me = this;

        if (data.leave) {
            me.mouse.x = -1000;
            me.mouse.y = -1000
        } else {
            if (data.x !== undefined) me.mouse.x = data.x;
            if (data.y !== undefined) me.mouse.y = data.y;

            if (data.click) {
                me.onMouseClick(data)
            }
        }
    }

    /**
     * Updates the canvas size and resizes the internal context.
     * Triggers `updateResources` hook to allow subclasses to regenerate buffers/gradients.
     * @param {Object} size
     * @param {Number} size.height
     * @param {Number} size.width
     */
    updateSize(size) {
        let me = this;

        me.canvasSize = size;

        if (me.context) {
            me.context.canvas.width  = size.width;
            me.context.canvas.height = size.height;
            // Calls the hook to re-generate resources if implemented
            me.updateResources?.(size.width, size.height)
        }
    }

    /**
     * Polls for the OffscreenCanvas until it is available in the Worker's `canvasWindowMap`.
     * Once found, it initializes the context and starts the render loop.
     * @param {String} canvasId
     * @param {String} windowId
     * @param {Boolean} hasChange
     * @protected
     */
    waitForCanvas(canvasId, windowId, hasChange) {
        let me     = this,
            canvas = Neo.currentWorker.canvasWindowMap[canvasId]?.[windowId];

        if (canvas) {
            me.context = canvas.getContext('2d');

            // Standardize size update
            me.updateSize({width: canvas.width, height: canvas.height});

            // Optional hook for subclasses
            me.onGraphMounted?.(canvas.width, canvas.height);

            if (hasChange && !me.animationId) {
                me.renderLoop()
            }
        } else {
            setTimeout(me.waitForCanvas.bind(me, canvasId, windowId, hasChange), 50)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Base));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2NhbnZhcy92ZW5kb3JzLWFwcHNfcG9ydGFsX2NhbnZhc19Ib21lQ2FudmFzX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0REFBSTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FB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Q0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsb0JBQW9CLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9wb3J0YWwvY2FudmFzL0hvbWVDYW52YXMubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY2FudmFzL0Jhc2UubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCYXNlIGZyb20gJy4uLy4uLy4uL3NyYy9jYW52YXMvQmFzZS5tanMnO1xuXG5jb25zdFxuICAgIGhhc1JhZiAgICAgICAgICAgPSB0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nLFxuICAgIFBSSU1BUlkgICAgICAgICAgPSAnIzNFNjNERCcsXG4gICAgU0VDT05EQVJZICAgICAgICA9ICcjNTM2REZFJyxcbiAgICBISUdITElHSFQgICAgICAgID0gJyMwMEJGRkYnLCAvLyBEZWVwIFNreSBCbHVlIChIaWdoIENvbnRyYXN0KVxuICAgIENPTk5FQ1RJT05fQ09MT1IgPSAnIzgwODA4MCcsXG4gICAgTk9ERV9DT1VOVCAgICAgICA9IDE1MCxcbiAgICBOT0RFX1NUUklERSAgICAgID0gOSwgLy8geCwgeSwgdngsIHZ5LCByYWRpdXMsIGxheWVyLCBwYXJlbnRJZCwgcGhhc2UsIGVuZXJneVxuICAgIEFHRU5UX0NPVU5UICAgICAgPSAyMCxcbiAgICBBR0VOVF9TVFJJREUgICAgID0gNiwgLy8geCwgeSwgdngsIHZ5LCB0YXJnZXRJZHgsIHN0YXRlXG4gICAgUEFDS0VUX0NPVU5UICAgICA9IDIwLFxuICAgIFBBQ0tFVF9TVFJJREUgICAgPSA1OyAvLyB4LCB5LCB2eCwgdnksIGxpZmUgKDAtMSlcblxuLyoqXG4gKiBAc3VtbWFyeSBTaGFyZWRXb3JrZXIgcmVuZGVyZXIgZm9yIHRoZSBQb3J0YWwgSG9tZSBcIk5ldXJhbCBTd2FybVwiIGJhY2tncm91bmQuXG4gKlxuICogSW1wbGVtZW50cyB0aGUgKipcIk5ldXJhbCBTd2FybVwiKiogdmlzdWFsIHRoZW1lLCBhIGR5bmFtaWMsIG11dGFibGUgbmV0d29yayBzaW11bGF0aW9uIHRoYXRcbiAqIHZpc3VhbGl6ZXMgdGhlIE5lby5tanMgQXBwbGljYXRpb24gRW5naW5lIGFzIGEgbGl2aW5nIGVjb3N5c3RlbS5cbiAqXG4gKiAqKlZpc3VhbCBBcmNoaXRlY3R1cmU6KipcbiAqIDEuICoqTGl2aW5nIFRvcG9sb2d5IChUaGUgR3JhcGgpOioqIE5vZGVzIGFyZSBub3Qgc3RhdGljOyB0aGV5IGZvcm0gaGllcmFyY2hpY2FsIGNsdXN0ZXJzIHJlcHJlc2VudGluZ1xuICogICAgQ29tcG9uZW50cyB3aXRoaW4gQ29udGFpbmVycy4gVGhlIHRvcG9sb2d5IGlzIG11dGFibGUsIHdpdGggc3ViLWNsdXN0ZXJzIG9jY2FzaW9uYWxseSBkZXRhY2hpbmcsXG4gKiAqICAgIGRyaWZ0aW5nLCBhbmQgcmUtcGFyZW50aW5nIChWaXN1YWxpemluZyBcIkF0b21pYyBNb3Zlc1wiKS5cbiAqIDIuICoqQXV0b25vbW91cyBBZ2VudHMgKFRoZSBOZXVyYWwgTGluayk6KiogXCJTZWVrZXIgRHJvbmVzXCIgcm9hbSB0aGUgZ3JhcGggdXNpbmcgQm9pZCBiZWhhdmlvclxuICogICAgKFNlcGFyYXRpb24sIEFsaWdubWVudCwgQ29oZXNpb24pLiBUaGV5IFwic2NhblwiIG5vZGVzLCB0cmFuc2ZlcnJpbmcgZW5lcmd5IGFuZCB0cmlnZ2VyaW5nXG4gKiAgICB2aXN1YWwgaGlnaGxpZ2h0cywgcmVwcmVzZW50aW5nIHRoZSBhY3RpdmUgaW50ZWxsaWdlbmNlIG9mIHRoZSBmcmFtZXdvcmsuXG4gKiAzLiAqKkRhdGEgRmxvdyAoU2lnbmFsIFBhY2tldHMpOioqIFB1bHNlcyBvZiBsaWdodCB0cmF2ZWwgYWxvbmcgY29ubmVjdGlvbnMgZnJvbSBjaGlsZCB0byBwYXJlbnQsXG4gKiAgICB2aXN1YWxpemluZyB0aGUgZmxvdyBvZiBldmVudHMgYW5kIGRhdGEgdXBzdHJlYW0uXG4gKiA0LiAqKkF0bW9zcGhlcmUgKFBhcmFsbGF4KToqKiBBIG11bHRpLWxheWVyZWQgZGVwdGggc3lzdGVtIGNyZWF0ZXMgYSB2b2x1bWV0cmljIGZlZWwsIGRpc3Rpbmd1aXNoaW5nXG4gKiAgICBmb3JlZ3JvdW5kIFwiYWN0aXZlXCIgbm9kZXMgZnJvbSBiYWNrZ3JvdW5kIFwiY29udGV4dFwiIG5vZGVzLlxuICpcbiAqICoqUmVzcG9uc2l2ZSBBcmNoaXRlY3R1cmUgKFJlZmVyZW5jZSBWaWV3cG9ydCk6KipcbiAqIFRvIGVuc3VyZSBhIGNvbnNpc3RlbnQgZXhwZXJpZW5jZSBhY3Jvc3MgZGV2aWNlcyAoZnJvbSBNb2JpbGUgdG8gNEspLCB0aGUgc2ltdWxhdGlvbiB1c2VzIGEgKipSZWZlcmVuY2UgVmlld3BvcnQgU3RyYXRlZ3kqKi5cbiAqIC0gKipCYXNlbGluZToqKiAxOTIweDEwODAgaXMgZGVmaW5lZCBhcyBzY2FsZSBgMS4wYC5cbiAqIC0gKipEeW5hbWljIFNjYWxpbmc6KiogT24gcmVzaXplLCBhIGBzY2FsZWAgZmFjdG9yIGlzIGNhbGN1bGF0ZWQ6IGBzcXJ0KCh3aWR0aCAqIGhlaWdodCkgLyAoMTkyMCAqIDEwODApKWAuXG4gKiAtICoqTm9ybWFsaXphdGlvbjoqKiBBbGwgcGh5c2ljcyBjb25zdGFudHMgKHZlbG9jaXR5LCBmb3JjZSksIHNwYXRpYWwgZGltZW5zaW9ucyAoZGlzdGFuY2VzLCByYWRpaSksIGFuZFxuICogICB2aXN1YWwgcHJvcGVydGllcyAoc3Ryb2tlIHdpZHRoKSBhcmUgbXVsdGlwbGllZCBieSB0aGlzIGBzY2FsZWAuXG4gKiAtICoqRGVuc2l0eSBDb250cm9sOioqIE9uIHNtYWxsIHNjcmVlbnMgKGBzY2FsZSA8IDAuNWApLCB0aGUgYmFja2dyb3VuZCBsYXllciBpcyBjdWxsZWQgdG8gcHJldmVudCB2aXN1YWwgbm9pc2UuXG4gKlxuICogKipUaGVtZSBTeXN0ZW06KipcbiAqIFN1cHBvcnRzIGR5bmFtaWMgYGxpZ2h0YCBhbmQgYGRhcmtgIG1vZGVzIHZpYSB0aGUgYHRoZW1lYCBjb25maWcuXG4gKiAtICoqUGFsZXR0ZToqKiBBIHN0YXRpYyBgY29sb3JzYCBtYXAgZGVmaW5lcyBzZW1hbnRpYyBjb2xvciBzbG90cyAoYWdlbnRIZWFkLCBzcGFyaywgZXRjLikgZm9yIGVhY2ggbW9kZS5cbiAqIC0gKipIb3QtU3dhcHBpbmc6KiogQ2hhbmdpbmcgdGhlIGB0aGVtZWAgY29uZmlnIHRyaWdnZXJzIGB1cGRhdGVSZXNvdXJjZXNgIHRvIHJlZ2VuZXJhdGUgZ3JhZGllbnRzIGFuZFxuICogICBpbW1lZGlhdGVseSBhbHRlcnMgcmVuZGVyaW5nIGNvbG9ycyBpbiB0aGUgbmV4dCBmcmFtZSB3aXRob3V0IHJlLWluaXRpYWxpemluZyBidWZmZXJzLlxuICpcbiAqICoqUGVyZm9ybWFuY2UgQXJjaGl0ZWN0dXJlIChaZXJvLUFsbG9jYXRpb24pOioqXG4gKiBUbyBtYWludGFpbiA2MGZwcyBvbiBoaWdoLXJlZnJlc2ggZGlzcGxheXMgd2l0aG91dCBHQyBzdHV0dGVycywgdGhpcyBjbGFzcyBlbXBsb3lzIGEgKipaZXJvLUFsbG9jYXRpb24qKiBzdHJhdGVneSBkdXJpbmcgdGhlIHJlbmRlciBsb29wLlxuICogMS4gKipUeXBlZEFycmF5IEJ1ZmZlcnM6KiogQWxsIGVudGl0eSBkYXRhIChOb2RlcywgQWdlbnRzLCBQYWNrZXRzKSBpcyBzdG9yZWQgaW4gcHJlLWFsbG9jYXRlZCBgRmxvYXQzMkFycmF5YCBidWZmZXJzLlxuICogMi4gKipJbmxpbmVkIFBoeXNpY3M6KiogVmVjdG9yIGNhbGN1bGF0aW9ucyBhcmUgcGVyZm9ybWVkIGlubGluZSB3aXRob3V0IGNyZWF0aW5nIHRlbXBvcmFyeSBPYmplY3RzLlxuICogMy4gKipHcmFkaWVudCBDYWNoaW5nOioqIENhbnZhc0dyYWRpZW50cyBhcmUgY3JlYXRlZCBvbmx5IG9uIHJlc2l6ZSAoYHVwZGF0ZVJlc291cmNlc2ApIGFuZCBjYWNoZWQuXG4gKlxuICogKipOb2RlIEJ1ZmZlciBMYXlvdXQgKEZsb2F0MzJBcnJheSk6KipcbiAqIC0gMDogeCAoUG9zaXRpb24gWClcbiAqIC0gMTogeSAoUG9zaXRpb24gWSlcbiAqIC0gMjogdnggKFZlbG9jaXR5IFgpXG4gKiAtIDM6IHZ5IChWZWxvY2l0eSBZKVxuICogLSA0OiByYWRpdXMgKFZpc3VhbCBzaXplKVxuICogLSA1OiBsYXllciAoUGFyYWxsYXggZGVwdGg6IDA9YmFjaywgMT1taWQsIDI9ZnJvbnQpXG4gKiAtIDY6IHBhcmVudElkIChJbmRleCBvZiBwYXJlbnQgbm9kZSwgLTEgaWYgcGFyZW50LCAtMiBpZiBkcmlmdGluZylcbiAqIC0gNzogcGhhc2UgKEFuaW1hdGlvbiBvZmZzZXQgZm9yIGJyZWF0aGluZylcbiAqIC0gODogZW5lcmd5IChJbnRlcmFjdGlvbiBzdGF0ZSwgMC0xKVxuICpcbiAqICoqQWdlbnQgQnVmZmVyIExheW91dCAoRmxvYXQzMkFycmF5KToqKlxuICogLSAwOiB4XG4gKiAtIDE6IHlcbiAqIC0gMjogdnhcbiAqIC0gMzogdnlcbiAqIC0gNDogdGFyZ2V0SWR4IChJbmRleCBvZiB0YXJnZXQgbm9kZSwgLTEgaWYgd2FuZGVyaW5nKVxuICogLSA1OiBzdGF0ZSAoMD1tb3ZpbmcsIDE9c2Nhbm5pbmcpXG4gKlxuICogKipQYWNrZXQgQnVmZmVyIExheW91dCAoRmxvYXQzMkFycmF5KToqKlxuICogLSAwOiB4XG4gKiAtIDE6IHlcbiAqIC0gMjogdnhcbiAqIC0gMzogdnlcbiAqIC0gNDogbGlmZSAoRnJhbWVzIHJlbWFpbmluZywgMC0xIG5vcm1hbGl6ZWQgZm9yIGFscGhhKVxuICpcbiAqIEBjbGFzcyBQb3J0YWwuY2FudmFzLkhvbWVDYW52YXNcbiAqIEBleHRlbmRzIFBvcnRhbC5jYW52YXMuQmFzZVxuICogQHNpbmdsZXRvblxuICovXG5jbGFzcyBIb21lQ2FudmFzIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbG9ycyA9IHtcbiAgICAgICAgZGFyazoge1xuICAgICAgICAgICAgYWdlbnRIZWFkIDogJyNGRkZGRkYnLFxuICAgICAgICAgICAgYmFja2dyb3VuZDogWydyZ2JhKDYyLCA5OSwgMjIxLCAwLjE1KScsICdyZ2JhKDEzOSwgMTY2LCAyNTUsIDAuMTUpJ10sXG4gICAgICAgICAgICBub2RlSGlnaCAgOiAnI0ZGRkZGRicsXG4gICAgICAgICAgICBwYWNrZXQgICAgOiAnI0ZGRkZGRicsXG4gICAgICAgICAgICBzaG9ja3dhdmUgOiAnI0ZGRkZGRicsXG4gICAgICAgICAgICBzcGFyayAgICAgOiAnIzRCMDA4MidcbiAgICAgICAgfSxcbiAgICAgICAgbGlnaHQ6IHtcbiAgICAgICAgICAgIGFnZW50SGVhZCA6ICcjM0U2M0REJywgLy8gUFJJTUFSWVxuICAgICAgICAgICAgYmFja2dyb3VuZDogWydyZ2JhKDYyLCA5OSwgMjIxLCAwLjA1KScsICdyZ2JhKDEzOSwgMTY2LCAyNTUsIDAuMDUpJ10sXG4gICAgICAgICAgICBub2RlSGlnaCAgOiAnIzNFNjNERCcsIC8vIFBSSU1BUllcbiAgICAgICAgICAgIHBhY2tldCAgICA6ICcjM0U2M0REJywgLy8gUFJJTUFSWVxuICAgICAgICAgICAgc2hvY2t3YXZlIDogJyMzRTYzREQnLCAvLyBQUklNQVJZXG4gICAgICAgICAgICBzcGFyayAgICAgOiAnIzRCMDA4MidcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nUG9ydGFsLmNhbnZhcy5Ib21lQ2FudmFzJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdQb3J0YWwuY2FudmFzLkhvbWVDYW52YXMnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2luZ2xldG9uPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2luZ2xldG9uOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJlLWFsbG9jYXRlZCBidWZmZXIgZm9yIGFnZW50IGRhdGEgKFNlZWtlciBEcm9uZXMpLlxuICAgICAqIEBtZW1iZXIge0Zsb2F0MzJBcnJheXxudWxsfSBhZ2VudEJ1ZmZlcj1udWxsXG4gICAgICovXG4gICAgYWdlbnRCdWZmZXIgPSBudWxsXG4gICAgLyoqXG4gICAgICogUHJlLWFsbG9jYXRlZCBidWZmZXIgZm9yIG5vZGUgZGF0YSAoVGhlIEdyYXBoKS5cbiAgICAgKiBAbWVtYmVyIHtGbG9hdDMyQXJyYXl8bnVsbH0gbm9kZUJ1ZmZlcj1udWxsXG4gICAgICovXG4gICAgbm9kZUJ1ZmZlciA9IG51bGxcbiAgICAvKipcbiAgICAgKiBQcmUtYWxsb2NhdGVkIGJ1ZmZlciBmb3IgZGF0YSBwYWNrZXRzIChTaWduYWwgUHVsc2VzKS5cbiAgICAgKiBAbWVtYmVyIHtGbG9hdDMyQXJyYXl8bnVsbH0gcGFja2V0QnVmZmVyPW51bGxcbiAgICAgKi9cbiAgICBwYWNrZXRCdWZmZXIgPSBudWxsXG4gICAgLyoqXG4gICAgICogQWN0aXZlIHNob2Nrd2F2ZSBlZmZlY3RzLlxuICAgICAqIEBtZW1iZXIge09iamVjdFtdfSBzaG9ja3dhdmVzPVtdXG4gICAgICovXG4gICAgc2hvY2t3YXZlcyA9IFtdXG4gICAgLyoqXG4gICAgICogQWN0aXZlIHNwYXJrIHBhcnRpY2xlcyAoRGF0YSBEZWJyaXMpLlxuICAgICAqIEBtZW1iZXIge09iamVjdFtdfSBzcGFya3M9W11cbiAgICAgKi9cbiAgICBzcGFya3MgPSBbXVxuICAgIC8qKlxuICAgICAqIFNjYWxpbmcgZmFjdG9yIHJlbGF0aXZlIHRvIGEgMTkyMHgxMDgwIHJlZmVyZW5jZSB2aWV3cG9ydC5cbiAgICAgKiBVc2VkIHRvIGVuc3VyZSBjb25zaXN0ZW50IHBoeXNpY3MgYW5kIHZpc3VhbHMgYWNyb3NzIHJlc29sdXRpb25zLlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gc2NhbGU9MVxuICAgICAqL1xuICAgIHNjYWxlID0gMVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBncmFwaCBzdGF0ZSBhbmQgc3RvcHMgdGhlIHJlbmRlciBsb29wLlxuICAgICAqIFVzZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGRlc3Ryb3llZCBvciB0aGUgcm91dGUgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBjbGVhckdyYXBoKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuICAgICAgICBzdXBlci5jbGVhckdyYXBoKCk7XG4gICAgICAgIG1lLm5vZGVCdWZmZXIgICA9IG51bGw7XG4gICAgICAgIG1lLmFnZW50QnVmZmVyICA9IG51bGw7XG4gICAgICAgIG1lLnBhY2tldEJ1ZmZlciA9IG51bGw7XG4gICAgICAgIG1lLnNob2Nrd2F2ZXMgICA9IFtdO1xuICAgICAgICBtZS5zcGFya3MgICAgICAgPSBbXTtcbiAgICAgICAgbWUuc2NhbGUgICAgICAgID0gMVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhvb2sgdG8gaW5pdGlhbGl6ZSBub2RlcyBhbmQgYWdlbnRzIGFmdGVyIGNvbnRleHQgaXMgcmVhZHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAgICovXG4gICAgb25HcmFwaE1vdW50ZWQod2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVNpemUoe3dpZHRoLCBoZWlnaHR9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYXdzIHRoZSBhdXRvbm9tb3VzIGFnZW50cyAoU2Vla2VyIERyb25lcykuXG4gICAgICpcbiAgICAgKiAqKlZpc3VhbHM6KipcbiAgICAgKiAtICoqSGVhZDoqKiBBIHNvbGlkIGNpcmNsZSBpbmRpY2F0aW5nIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICogLSAqKlRyYWlsOioqIEEgZmFkaW5nIGxpbmUgZHJhd24gb3Bwb3NpdGUgdG8gdmVsb2NpdHksIHNpbXVsYXRpbmcgbW90aW9uIGJsdXIuXG4gICAgICogLSAqKlNjYW4gRWZmZWN0OioqIEEgcHVsc2luZyByaW5nIHdoZW4gdGhlIGFnZW50IHJlYWNoZXMgYSBub2RlIChzdGF0ZT0xKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKi9cbiAgICBkcmF3QWdlbnRzKGN0eCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUuYWdlbnRCdWZmZXIpIHJldHVybjtcblxuICAgICAgICBjb25zdFxuICAgICAgICAgICAgYnVmZmVyICAgICAgPSBtZS5hZ2VudEJ1ZmZlcixcbiAgICAgICAgICAgIGNvdW50ICAgICAgID0gQUdFTlRfQ09VTlQsXG4gICAgICAgICAgICB0aGVtZUNvbG9ycyA9IG1lLmNvbnN0cnVjdG9yLmNvbG9yc1ttZS50aGVtZV0sXG4gICAgICAgICAgICBzICAgICAgICAgICA9IG1lLnNjYWxlOyAvLyBHZXQgc2NhbGUgZmFjdG9yXG5cbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gSElHSExJR0hUO1xuICAgICAgICBjdHguZmlsbFN0eWxlICAgPSB0aGVtZUNvbG9ycy5hZ2VudEhlYWQ7XG4gICAgICAgIGN0eC5saW5lQ2FwICAgICA9ICdyb3VuZCc7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaWR4ICAgPSBpICogQUdFTlRfU1RSSURFLFxuICAgICAgICAgICAgICAgIHggICAgID0gYnVmZmVyW2lkeF0sXG4gICAgICAgICAgICAgICAgeSAgICAgPSBidWZmZXJbaWR4ICsgMV0sXG4gICAgICAgICAgICAgICAgdnggICAgPSBidWZmZXJbaWR4ICsgMl0sXG4gICAgICAgICAgICAgICAgdnkgICAgPSBidWZmZXJbaWR4ICsgM10sXG4gICAgICAgICAgICAgICAgc3RhdGUgPSBidWZmZXJbaWR4ICsgNV07XG5cbiAgICAgICAgICAgIC8vIDEuIERyYXcgVHJhaWwgKE1vdGlvbiBCbHVyKVxuICAgICAgICAgICAgbGV0IHNwZWVkID0gTWF0aC5zcXJ0KHZ4KnZ4ICsgdnkqdnkpO1xuXG4gICAgICAgICAgICBpZiAoc3BlZWQgPiAwLjEgKiBzKSB7IC8vIFNjYWxlZCB0aHJlc2hvbGRcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDIgKiBzOyAvLyBTY2FsZWQgbGluZSB3aWR0aFxuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuNjtcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCAtIHZ4ICogNCwgeSAtIHZ5ICogNCk7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIDIuIERyYXcgSGVhZFxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gc3RhdGUgPT09IDEgPyAxIDogMC44O1xuICAgICAgICAgICAgbGV0IHJhZGl1cyA9IChzdGF0ZSA9PT0gMSA/IDMgOiAyKSAqIHM7IC8vIFNjYWxlZCByYWRpdXNcbiAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzLCAwLCBNYXRoLlBJICogMik7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuXG4gICAgICAgICAgICAvLyAzLiBTY2FuIEVmZmVjdFxuICAgICAgICAgICAgaWYgKHN0YXRlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAxICogczsgLy8gU2NhbGVkIHdpZHRoXG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC4zO1xuICAgICAgICAgICAgICAgIC8vIFNjYWxlZCByaW5nIHJhZGl1c1xuICAgICAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgKDggKyBNYXRoLnNpbihtZS50aW1lICogMTApICogMikgKiBzLCAwLCBNYXRoLlBJICogMik7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIG5ldXJhbCBuZXR3b3JrIChub2RlcyBhbmQgY29ubmVjdGlvbnMpLlxuICAgICAqXG4gICAgICogKipJbnRlbnQ6KipcbiAgICAgKiBWaXN1YWxpemVzIHRoZSBcIkFwcGxpY2F0aW9uIEdyYXBoXCIuXG4gICAgICogLSAqKlBhcmFsbGF4OioqIEFwcGxpZXMgZGVwdGgtYmFzZWQgZGlzcGxhY2VtZW50IGJhc2VkIG9uIG1vdXNlIHBvc2l0aW9uLlxuICAgICAqIC0gKipDb25uZWN0aW9uczoqKiBMaW5lcyBhcmUgZHJhd24gb25seSBiZXR3ZWVuIHJlbGF0ZWQgbm9kZXMgKFBhcmVudC1DaGlsZCBvciBTaWJsaW5ncykuXG4gICAgICogICBMaW5lcyB0aGlja2VuIGFuZCBicmlnaHRlbiB3aGVuIG5lYXIgdGhlIG1vdXNlLlxuICAgICAqIC0gKipOb2RlczoqKiBDaXJjbGVzIGJyZWF0aGluZyBpbiBzaXplLiBDb2xvcnMgaW5kaWNhdGUgZGVwdGggKExheWVyKSBhbmQgZW5lcmd5IHN0YXRlLlxuICAgICAqXG4gICAgICogKipPcHRpbWl6YXRpb246KipcbiAgICAgKiBVc2VzIGlubGluZWQgbWF0aCBmb3IgcGFyYWxsYXggY2FsY3VsYXRpb25zIHRvIGF2b2lkIGFsbG9jYXRpbmcgdGhvdXNhbmRzIG9mIGB7eCx5fWAgb2JqZWN0cyBwZXIgZnJhbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqL1xuICAgIGRyYXdOZXR3b3JrKGN0eCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUubm9kZUJ1ZmZlcikgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBidWZmZXIgICAgICA9IG1lLm5vZGVCdWZmZXIsXG4gICAgICAgICAgICBjb3VudCAgICAgICA9IE5PREVfQ09VTlQsXG4gICAgICAgICAgICBteCAgICAgICAgICA9IG1lLm1vdXNlLngsXG4gICAgICAgICAgICBteSAgICAgICAgICA9IG1lLm1vdXNlLnksXG4gICAgICAgICAgICBjeCAgICAgICAgICA9IHdpZHRoIC8gMixcbiAgICAgICAgICAgIGN5ICAgICAgICAgID0gaGVpZ2h0IC8gMixcbiAgICAgICAgICAgIHRoZW1lQ29sb3JzID0gbWUuY29uc3RydWN0b3IuY29sb3JzW21lLnRoZW1lXSxcbiAgICAgICAgICAgIHMgICAgICAgICAgID0gbWUuc2NhbGU7IC8vIEdldCBzY2FsZSBmYWN0b3JcblxuICAgICAgICBjdHgubGluZVdpZHRoID0gMSAqIHM7IC8vIFNjYWxlZCBsaW5lIHdpZHRoXG5cbiAgICAgICAgLy8gMS4gRHJhdyBDb25uZWN0aW9uc1xuICAgICAgICAvLyBJdGVyYXRlcyBhbGwgdW5pcXVlIHBhaXJzIHRvIGRyYXcgbGluZXMgYmV0d2VlbiBjb25uZWN0ZWQgbm9kZXMuXG4gICAgICAgIC8vIENvbm5lY3Rpb25zIGFyZSBkcmF3biBpZiBub2RlcyBzaGFyZSBhIHBhcmVudCAoc2libGluZ3MpIG9yIGFyZSBwYXJlbnQtY2hpbGQuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkeCAgPSBpICogTk9ERV9TVFJJREUsXG4gICAgICAgICAgICAgICAgbDEgICA9IGJ1ZmZlcltpZHggKyA1XSxcbiAgICAgICAgICAgICAgICBwaWQxID0gYnVmZmVyW2lkeCArIDZdLFxuICAgICAgICAgICAgICAgIC8vIElubGluZSBnZXRQb3MgbG9naWMgZm9yIHAxIHRvIGF2b2lkIEdDXG4gICAgICAgICAgICAgICAgZjEgICA9IGwxID09PSAyID8gMC4wNSA6IChsMSA9PT0gMSA/IDAuMDIgOiAwLjAxKSxcbiAgICAgICAgICAgICAgICBkeDEgID0gKG14ICE9PSAtMTAwMCA/IG14IC0gY3ggOiAwKSAqIGYxLFxuICAgICAgICAgICAgICAgIGR5MSAgPSAobXkgIT09IC0xMDAwID8gbXkgLSBjeSA6IDApICogZjEsXG4gICAgICAgICAgICAgICAgcDF4ICA9IGJ1ZmZlcltpZHhdICsgZHgxLFxuICAgICAgICAgICAgICAgIHAxeSAgPSBidWZmZXJbaWR4ICsgMV0gKyBkeTE7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGNvdW50OyBqKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgaWR4MiA9IGogKiBOT0RFX1NUUklERSxcbiAgICAgICAgICAgICAgICAgICAgbDIgICA9IGJ1ZmZlcltpZHgyICsgNV0sXG4gICAgICAgICAgICAgICAgICAgIHBpZDIgPSBidWZmZXJbaWR4MiArIDZdO1xuXG4gICAgICAgICAgICAgICAgY29uc3RcbiAgICAgICAgICAgICAgICAgICAgc2FtZUNsdXN0ZXIgICA9IHBpZDEgPT09IHBpZDIgJiYgcGlkMSAhPT0gLTEsXG4gICAgICAgICAgICAgICAgICAgIGlzUGFyZW50Q2hpbGQgPSAocGlkMSA9PT0gaikgfHwgKHBpZDIgPT09IGkpLFxuICAgICAgICAgICAgICAgICAgICBpc0NsdXN0ZXJMaW5rID0gKHBpZDEgPT09IC0xICYmIHBpZDIgPT09IC0xKTtcblxuICAgICAgICAgICAgICAgIGlmICghc2FtZUNsdXN0ZXIgJiYgIWlzUGFyZW50Q2hpbGQgJiYgIWlzQ2x1c3RlckxpbmspIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgbGV0IGYyICAgPSBsMiA9PT0gMiA/IDAuMDUgOiAobDIgPT09IDEgPyAwLjAyIDogMC4wMSksXG4gICAgICAgICAgICAgICAgICAgIGR4MiAgPSAobXggIT09IC0xMDAwID8gbXggLSBjeCA6IDApICogZjIsXG4gICAgICAgICAgICAgICAgICAgIGR5MiAgPSAobXkgIT09IC0xMDAwID8gbXkgLSBjeSA6IDApICogZjIsXG4gICAgICAgICAgICAgICAgICAgIHAyeCAgPSBidWZmZXJbaWR4Ml0gKyBkeDIsXG4gICAgICAgICAgICAgICAgICAgIHAyeSAgPSBidWZmZXJbaWR4MiArIDFdICsgZHkyLFxuICAgICAgICAgICAgICAgICAgICBkeCAgID0gcDF4IC0gcDJ4LFxuICAgICAgICAgICAgICAgICAgICBkeSAgID0gcDF5IC0gcDJ5LFxuICAgICAgICAgICAgICAgICAgICBkaXN0U3EgPSBkeCpkeCArIGR5KmR5O1xuXG4gICAgICAgICAgICAgICAgLy8gQ3VsbGluZzogT25seSBkcmF3IGNvbm5lY3Rpb25zIHdpdGhpbiBhIGNlcnRhaW4gZGlzdGFuY2VcbiAgICAgICAgICAgICAgICBpZiAoZGlzdFNxIDwgNDAwMDAgKiBzICogcykgeyAvLyBTY2FsZWQgZGlzdGFuY2Ugc3F1YXJlZFxuICAgICAgICAgICAgICAgICAgICBsZXQgZGlzdCAgPSBNYXRoLnNxcnQoZGlzdFNxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhID0gMSAtIChkaXN0IC8gKDIwMCAqIHMpKTsgLy8gU2NhbGVkIGRpc3RhbmNlIGZhY3RvclxuXG4gICAgICAgICAgICAgICAgICAgIGFscGhhICo9ICgwLjIgKyAobDEgKiAwLjEpKTtcblxuICAgICAgICAgICAgICAgICAgICBsZXQgbUR4ID0gKHAxeCArIHAyeCkvMiAtIG14LFxuICAgICAgICAgICAgICAgICAgICAgICAgbUR5ID0gKHAxeSArIHAyeSkvMiAtIG15LFxuICAgICAgICAgICAgICAgICAgICAgICAgbURpc3RTcSA9IG1EeCptRHggKyBtRHkqbUR5O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE1vdXNlIEludGVyYWN0aW9uOiBIaWdobGlnaHQgY29ubmVjdGlvbnMgbmVhciBjdXJzb3JcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1EaXN0U3EgPCAxMDAwMCAqIHMgKiBzKSB7IC8vIFNjYWxlZCBtb3VzZSBkaXN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGEgPSBNYXRoLm1pbihhbHBoYSArIDAuNSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBISUdITElHSFQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoICAgPSAxLjUgKiBzIC8vIFNjYWxlZFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbDEgPT09IDIgPyBQUklNQVJZIDogU0VDT05EQVJZO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRWxhc3RpY2l0eTogVGhpY2tlciB3aGVuIGNsb3NlciAoVGVuc2lvbi9TbGFjayB2aXN1YWxpemF0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9ICgwLjUgKyAoMSAtIChkaXN0IC8gKDIwMCAqIHMpKSkpICogcyAvLyBTY2FsZWRcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gYWxwaGEgKiAwLjU7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8ocDF4LCBwMXkpO1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHAyeCwgcDJ5KTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gMi4gRHJhdyBOb2Rlc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpZHggICAgICA9IGkgKiBOT0RFX1NUUklERSxcbiAgICAgICAgICAgICAgICByYWRpdXMgICA9IGJ1ZmZlcltpZHggKyA0XSxcbiAgICAgICAgICAgICAgICBsYXllciAgICA9IGJ1ZmZlcltpZHggKyA1XSxcbiAgICAgICAgICAgICAgICBwYXJlbnRJZCA9IGJ1ZmZlcltpZHggKyA2XSxcbiAgICAgICAgICAgICAgICBwaGFzZSAgICA9IGJ1ZmZlcltpZHggKyA3XSxcbiAgICAgICAgICAgICAgICBlbmVyZ3kgICA9IGJ1ZmZlcltpZHggKyA4XTtcblxuICAgICAgICAgICAgLy8gQ3VsbGluZzogU2tpcCBiYWNrZ3JvdW5kIGxheWVyIG9uIHZlcnkgc21hbGwgc2NyZWVucyB0byByZWR1Y2Ugbm9pc2VcbiAgICAgICAgICAgIGlmIChzIDwgMC41ICYmIGxheWVyID09PSAwKSBjb250aW51ZTtcblxuICAgICAgICAgICAgbGV0XG4gICAgICAgICAgICAgICAgLy8gSW5saW5lIGdldFBvcyBsb2dpYyBmb3IgcG9zXG4gICAgICAgICAgICAgICAgZiAgICAgICAgPSBsYXllciA9PT0gMiA/IDAuMDUgOiAobGF5ZXIgPT09IDEgPyAwLjAyIDogMC4wMSksXG4gICAgICAgICAgICAgICAgcER4ICAgICAgPSAobXggIT09IC0xMDAwID8gbXggLSBjeCA6IDApICogZixcbiAgICAgICAgICAgICAgICBwRHkgICAgICA9IChteSAhPT0gLTEwMDAgPyBteSAtIGN5IDogMCkgKiBmLFxuICAgICAgICAgICAgICAgIHBvc1ggICAgID0gYnVmZmVyW2lkeF0gKyBwRHgsXG4gICAgICAgICAgICAgICAgcG9zWSAgICAgPSBidWZmZXJbaWR4ICsgMV0gKyBwRHksXG4gICAgICAgICAgICAgICAgZHggICAgICAgPSBwb3NYIC0gbXgsXG4gICAgICAgICAgICAgICAgZHkgICAgICAgPSBwb3NZIC0gbXksXG4gICAgICAgICAgICAgICAgZGlzdCAgICAgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpLFxuICAgICAgICAgICAgICAgIGlzSG92ZXIgID0gZGlzdCA8IDUwICogczsgLy8gU2NhbGVkIGhvdmVyIGRpc3RhbmNlXG5cbiAgICAgICAgICAgIC8vIFNob2Nrd2F2ZSBJbnRlcmFjdGlvblxuICAgICAgICAgICAgaWYgKG1lLnNob2Nrd2F2ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG1lLnNob2Nrd2F2ZXMuZm9yRWFjaCh3YXZlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHdEaXN0ID0gTWF0aC5zcXJ0KChwb3NYIC0gd2F2ZS54KSoqMiArIChwb3NZIC0gd2F2ZS55KSoqMiksXG4gICAgICAgICAgICAgICAgICAgICAgICB3UmFkICA9IHdhdmUuYWdlICogd2F2ZS5zcGVlZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHdEaXN0IC0gd1JhZCkgPCAyMCAqIHMpIHsgLy8gU2NhbGVkIHdhdmUgd2lkdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzSG92ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGxldCByID0gcGFyZW50SWQgPT09IC0xID8gcmFkaXVzICogMS41IDogcmFkaXVzO1xuXG4gICAgICAgICAgICAvLyBCcmVhdGhpbmcgKyBFbmVyZ3lcbiAgICAgICAgICAgIHIgKj0gMSArIE1hdGguc2luKG1lLnRpbWUgKiAyICsgcGhhc2UpICogMC4xNSArIGVuZXJneTtcblxuICAgICAgICAgICAgaWYgKGlzSG92ZXIpIHtcbiAgICAgICAgICAgICAgICByICo9IDEuNTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4LmFyYyhwb3NYLCBwb3NZLCByLCAwLCBNYXRoLlBJICogMik7XG5cbiAgICAgICAgICAgIGlmIChlbmVyZ3kgPiAwLjEpIHtcbiAgICAgICAgICAgICAgICAvLyBFbmVyZ2V0aWMgTm9kZSAoQWdlbnQgU2Nhbm5lZClcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gSElHSExJR0hUO1xuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IE1hdGgubWluKDEsIDAuNSArIGVuZXJneSlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGF5ZXIgPT09IDIpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gaXNIb3ZlciA/IHRoZW1lQ29sb3JzLm5vZGVIaWdoIDogUFJJTUFSWTtcbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBpc0hvdmVyID8gMSA6IDAuOFxuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJlbnRJZCA9PT0gLTIpIHtcbiAgICAgICAgICAgICAgICAvLyBEcmlmdGluZyBOb2RlIFZpc3VhbFxuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBISUdITElHSFQ7XG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC42ICsgTWF0aC5zaW4obWUudGltZSAqIDEwICsgcGhhc2UpICogMC4zXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxheWVyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGlzSG92ZXIgPyBISUdITElHSFQgOiBTRUNPTkRBUlk7XG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC41XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBDT05ORUNUSU9OX0NPTE9SO1xuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuMlxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYXdzIHRoZSBkYXRhIHBhY2tldHMgdHJhdmVsaW5nIGFsb25nIGNvbm5lY3Rpb25zLlxuICAgICAqIFBhY2tldHMgcmVwcmVzZW50IHNpZ25hbCBmbG93IGJldHdlZW4gbm9kZXMuXG4gICAgICogQHBhcmFtIHtPZmZzY3JlZW5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqL1xuICAgIGRyYXdQYWNrZXRzKGN0eCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUucGFja2V0QnVmZmVyKSByZXR1cm47XG5cbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIGJ1ZmZlciAgICAgID0gbWUucGFja2V0QnVmZmVyLFxuICAgICAgICAgICAgY291bnQgICAgICAgPSBQQUNLRVRfQ09VTlQsXG4gICAgICAgICAgICB0aGVtZUNvbG9ycyA9IG1lLmNvbnN0cnVjdG9yLmNvbG9yc1ttZS50aGVtZV07XG5cbiAgICAgICAgY3R4LmZpbGxTdHlsZSAgID0gdGhlbWVDb2xvcnMucGFja2V0O1xuICAgICAgICBjdHguc2hhZG93Qmx1ciAgPSA1O1xuICAgICAgICBjdHguc2hhZG93Q29sb3IgPSBISUdITElHSFQ7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaWR4ICA9IGkgKiBQQUNLRVRfU1RSSURFLFxuICAgICAgICAgICAgICAgIGxpZmUgPSBidWZmZXJbaWR4ICsgNF07XG5cbiAgICAgICAgICAgIGlmIChsaWZlID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCB4ID0gYnVmZmVyW2lkeF0sXG4gICAgICAgICAgICAgICAgICAgIHkgPSBidWZmZXJbaWR4ICsgMV07XG5cbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gTWF0aC5taW4obGlmZSAqIDIsIDEpOyAvLyBGYWRlIG91dCBhdCBlbmRcbiAgICAgICAgICAgICAgICBjdHguYXJjKHgsIHksIDIsIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjdHguc2hhZG93Qmx1ciAgPSAwO1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgZXhwYW5kaW5nIHNob2Nrd2F2ZXMgZnJvbSBjbGlja3Mgd2l0aCBDaHJvbWF0aWMgQWJlcnJhdGlvbiBhbmQgQ29tcG9zaXRlIFJpbmdzLlxuICAgICAqIFVzZXMgb3B0aW1pemVkIFJHQkEgY29tcG9zaXRpb24gdG8gcmVkdWNlIEdDIHByZXNzdXJlLlxuICAgICAqIEBwYXJhbSB7T2Zmc2NyZWVuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKi9cbiAgICBkcmF3U2hvY2t3YXZlcyhjdHgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuc2hvY2t3YXZlcy5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgICAgICBjb25zdFxuICAgICAgICAgICAgdGhlbWVDb2xvcnMgPSBtZS5jb25zdHJ1Y3Rvci5jb2xvcnNbbWUudGhlbWVdLFxuICAgICAgICAgICAgcyAgICAgICAgICAgPSBtZS5zY2FsZTtcblxuICAgICAgICBjdHgubGluZUNhcCA9ICdyb3VuZCc7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IG1lLnNob2Nrd2F2ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB3YXZlID0gbWUuc2hvY2t3YXZlc1tpXTtcbiAgICAgICAgICAgIHdhdmUuYWdlKys7XG5cbiAgICAgICAgICAgIGxldCBwcm9ncmVzcyA9IHdhdmUuYWdlIC8gd2F2ZS5tYXhBZ2U7XG5cbiAgICAgICAgICAgIGlmIChwcm9ncmVzcyA+PSAxKSB7XG4gICAgICAgICAgICAgICAgbWUuc2hvY2t3YXZlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE5vbi1MaW5lYXIgRXhwYW5zaW9uIChFeHBsb3NpdmUgc3RhcnQsIHNsb3cgZmluaXNoKVxuICAgICAgICAgICAgbGV0IGVhc2VkID0gMSAtIE1hdGgucG93KDEgLSBwcm9ncmVzcywgMyksXG4gICAgICAgICAgICAgICAgcmFkaXVzID0gZWFzZWQgKiB3YXZlLm1heFJhZGl1cyxcbiAgICAgICAgICAgICAgICBhbHBoYSAgPSAxIC0gcHJvZ3Jlc3M7XG5cbiAgICAgICAgICAgIC8vIENocm9tYXRpYyBBYmVycmF0aW9uIChTaGlmdGVkIHRvIE5lb24gQmx1ZS9DeWFuIHRoZW1lKVxuXG4gICAgICAgICAgICAvLyAxLiBDeWFuIENoYW5uZWwgKExhZ2dpbmcgRnJpbmdlKSAtIFJlcGxhY2VzIFJlZFxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gSElHSExJR0hUO1xuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gYWxwaGEgKiAwLjg7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoICAgPSA0ICogKDEgLSBwcm9ncmVzcykgKiBzOyAvLyBTY2FsZWRcbiAgICAgICAgICAgIGN0eC5zaGFkb3dCbHVyICA9IDEwICogczsgLy8gU2NhbGVkXG4gICAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSBISUdITElHSFQ7XG4gICAgICAgICAgICBjdHguYXJjKHdhdmUueCwgd2F2ZS55LCByYWRpdXMgKiAwLjk5LCAwLCBNYXRoLlBJICogMik7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgICAgIC8vIDIuIEJsdWUgQ2hhbm5lbCAoTGVhZGluZyBGcmluZ2UpXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBQUklNQVJZO1xuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gYWxwaGEgKiAwLjg7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoICAgPSA0ICogKDEgLSBwcm9ncmVzcykgKiBzOyAvLyBTY2FsZWRcbiAgICAgICAgICAgIGN0eC5zaGFkb3dCbHVyICA9IDEwICogczsgLy8gU2NhbGVkXG4gICAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSBQUklNQVJZO1xuICAgICAgICAgICAgY3R4LmFyYyh3YXZlLngsIHdhdmUueSwgcmFkaXVzICogMS4wMSwgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgICAgICAvLyAzLiBQcmltYXJ5IFdhdmUgKFdoaXRlIEhvdCBDZW50ZXIpXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGVtZUNvbG9ycy5zaG9ja3dhdmU7XG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBhbHBoYTtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggICA9IDYgKiAoMSAtIHByb2dyZXNzKSAqIHM7IC8vIFNjYWxlZFxuICAgICAgICAgICAgY3R4LnNoYWRvd0JsdXIgID0gMjAgKiBzOyAvLyBTY2FsZWRcbiAgICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IHRoZW1lQ29sb3JzLnNob2Nrd2F2ZTtcbiAgICAgICAgICAgIGN0eC5hcmMod2F2ZS54LCB3YXZlLnksIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgICAgICAvLyA0LiBQcmVzc3VyZSBGaWxsIChSZWZyYWN0aW9uIEZha2UpXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gUFJJTUFSWTtcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGFscGhhICogMC4wNTtcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHguc2hhZG93Qmx1ciA9IDA7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDFcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0ZW1wb3Jhcnkgc3BhcmsgcGFydGljbGVzIChEYXRhIERlYnJpcykuXG4gICAgICogQHBhcmFtIHtPZmZzY3JlZW5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqL1xuICAgIGRyYXdTcGFya3MoY3R4KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLnNwYXJrcy5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgICAgICBjb25zdFxuICAgICAgICAgICAgdGhlbWVDb2xvcnMgPSBtZS5jb25zdHJ1Y3Rvci5jb2xvcnNbbWUudGhlbWVdLFxuICAgICAgICAgICAgcyAgICAgICAgICAgPSBtZS5zY2FsZTtcblxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGVtZUNvbG9ycy5zcGFyaztcbiAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSAwOyAvLyBDcmlzcCBsaW5lcyBvbiB3aGl0ZVxuICAgICAgICBjdHgubGluZVdpZHRoID0gMiAqIHM7IC8vIFNjYWxlZCB3aWR0aFxuXG4gICAgICAgIGZvciAobGV0IHMgb2YgbWUuc3BhcmtzKSB7XG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBzLmxpZmU7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAvLyBEcmF3IFRyYWlsIGJhc2VkIG9uIHZlbG9jaXR5XG4gICAgICAgICAgICBjdHgubW92ZVRvKHMueCwgcy55KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8ocy54IC0gcy52eCAqIDIsIHMueSAtIHMudnkgKiAyKTtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKVxuICAgICAgICB9XG5cbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBhdXRvbm9tb3VzIGFnZW50cy5cbiAgICAgKiBBZ2VudHMgc3RhcnQgYXQgcmFuZG9tIHBvc2l0aW9ucyB3aXRoIHJhbmRvbSBoaWdoLXZlbG9jaXR5IHZlY3RvcnMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqL1xuICAgIGluaXRBZ2VudHMod2lkdGgsIGhlaWdodCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUuYWdlbnRCdWZmZXIpIHtcbiAgICAgICAgICAgIG1lLmFnZW50QnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShBR0VOVF9DT1VOVCAqIEFHRU5UX1NUUklERSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdFxuICAgICAgICAgICAgYnVmZmVyID0gbWUuYWdlbnRCdWZmZXIsXG4gICAgICAgICAgICBzICAgICAgPSBtZS5zY2FsZTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEFHRU5UX0NPVU5UOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpZHggPSBpICogQUdFTlRfU1RSSURFO1xuXG4gICAgICAgICAgICBidWZmZXJbaWR4XSAgICAgPSBNYXRoLnJhbmRvbSgpICogd2lkdGg7ICAvLyB4XG4gICAgICAgICAgICBidWZmZXJbaWR4ICsgMV0gPSBNYXRoLnJhbmRvbSgpICogaGVpZ2h0OyAvLyB5XG4gICAgICAgICAgICBidWZmZXJbaWR4ICsgMl0gPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiA0ICogczsgLy8gdnggKEZhc3QhKVxuICAgICAgICAgICAgYnVmZmVyW2lkeCArIDNdID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogNCAqIHM7IC8vIHZ5XG4gICAgICAgICAgICBidWZmZXJbaWR4ICsgNF0gPSAtMTsgLy8gdGFyZ2V0SWR4IChub25lKVxuICAgICAgICAgICAgYnVmZmVyW2lkeCArIDVdID0gMCAgIC8vIHN0YXRlIChtb3ZpbmcpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgbm9kZSBidWZmZXIgdXNpbmcgKipHb2xkZW4gU3BpcmFsKiogZGlzdHJpYnV0aW9uLlxuICAgICAqIFRoaXMgZW5zdXJlcyBhIHVuaWZvcm0gYnV0IG9yZ2FuaWMtbG9va2luZyBkaXN0cmlidXRpb24gb2Ygbm9kZXMgYWNyb3NzIHRoZSBzY3JlZW4sXG4gICAgICogcHJldmVudGluZyB0aGUgXCJjbHVtcGluZ1wiIHNlZW4gd2l0aCByYW5kb20gcGxhY2VtZW50LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgKi9cbiAgICBpbml0Tm9kZXMod2lkdGgsIGhlaWdodCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUubm9kZUJ1ZmZlcikge1xuICAgICAgICAgICAgbWUubm9kZUJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoTk9ERV9DT1VOVCAqIE5PREVfU1RSSURFKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBidWZmZXIgICAgICAgID0gbWUubm9kZUJ1ZmZlcixcbiAgICAgICAgICAgIGN4ICAgICAgICAgICAgPSB3aWR0aCAvIDIsXG4gICAgICAgICAgICBjeSAgICAgICAgICAgID0gaGVpZ2h0IC8gMixcbiAgICAgICAgICAgIHBoaSAgICAgICAgICAgPSAoMSArIE1hdGguc3FydCg1KSkgLyAyLFxuICAgICAgICAgICAgc2NhbGUgICAgICAgICA9IE1hdGguc3FydCh3aWR0aCAqIGhlaWdodCAvIE5PREVfQ09VTlQpICogMC44LFxuICAgICAgICAgICAgcGFyZW50Q291bnQgICA9IE1hdGguZmxvb3IoTk9ERV9DT1VOVCAqIDAuMSksXG4gICAgICAgICAgICBzICAgICAgICAgICAgID0gbWUuc2NhbGU7IC8vIFVzZSB0aGUgY2FsY3VsYXRlZCBzY2FsZSBmYWN0b3JcblxuICAgICAgICBsZXQgcGFyZW50SW5kaWNlcyA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTk9ERV9DT1VOVDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaWR4ID0gaSAqIE5PREVfU1RSSURFLFxuICAgICAgICAgICAgICAgIGlzUGFyZW50ID0gaSA8IHBhcmVudENvdW50O1xuXG4gICAgICAgICAgICBpZiAoaXNQYXJlbnQpIHBhcmVudEluZGljZXMucHVzaChpKTtcblxuICAgICAgICAgICAgbGV0IHRoZXRhID0gaSAqIDIgKiBNYXRoLlBJICogcGhpLFxuICAgICAgICAgICAgICAgIHIgICAgID0gTWF0aC5zcXJ0KGkpICogc2NhbGU7XG5cbiAgICAgICAgICAgIC8vIFNpbXBsZSB3cmFwIHRvIGtlZXAgaW5pdGlhbCBzcGlyYWwgaW5zaWRlIHJlYXNvbmFibGUgYm91bmRzXG4gICAgICAgICAgICBsZXQgeCA9IGN4ICsgciAqIE1hdGguY29zKHRoZXRhKSxcbiAgICAgICAgICAgICAgICB5ID0gY3kgKyByICogTWF0aC5zaW4odGhldGEpO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgc3BpcmFsIGlzIGxhcmdlciB0aGFuIHNjcmVlbiwgd3JhcCBpdFxuICAgICAgICAgICAgeCA9ICgoeCAlIHdpZHRoKSArIHdpZHRoKSAlIHdpZHRoO1xuICAgICAgICAgICAgeSA9ICgoeSAlIGhlaWdodCkgKyBoZWlnaHQpICUgaGVpZ2h0O1xuXG4gICAgICAgICAgICBidWZmZXJbaWR4XSAgICAgPSB4O1xuICAgICAgICAgICAgYnVmZmVyW2lkeCArIDFdID0geTtcbiAgICAgICAgICAgIGJ1ZmZlcltpZHggKyAyXSA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDAuMiAqIHM7IC8vIFNjYWxlIHZlbG9jaXR5XG4gICAgICAgICAgICBidWZmZXJbaWR4ICsgM10gPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAwLjIgKiBzO1xuXG4gICAgICAgICAgICBsZXQgbGF5ZXIgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAzKTtcbiAgICAgICAgICAgIGJ1ZmZlcltpZHggKyA1XSA9IGxheWVyOyAvLyBsYXllclxuXG4gICAgICAgICAgICAvLyBSYWRpdXMgYmFzZWQgb24gbGF5ZXIgJiByb2xlIChTY2FsZWQpXG4gICAgICAgICAgICBidWZmZXJbaWR4ICsgNF0gPSAoaXNQYXJlbnQgPyA0ICsgKGxheWVyICogMikgOiAyICsgKGxheWVyICogMS41KSkgKiBzO1xuXG4gICAgICAgICAgICAvLyBQYXJlbnQgSUQgKC0xIGZvciBwYXJlbnRzLCBhc3NpZ25lZCBsYXRlciBmb3IgY2hpbGRyZW4pXG4gICAgICAgICAgICBidWZmZXJbaWR4ICsgNl0gPSBpc1BhcmVudCA/IC0xIDogLTI7XG5cbiAgICAgICAgICAgIC8vIFBoYXNlIChCcmVhdGhpbmcgb2Zmc2V0KVxuICAgICAgICAgICAgYnVmZmVyW2lkeCArIDddID0gTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyO1xuXG4gICAgICAgICAgICAvLyBFbmVyZ3lcbiAgICAgICAgICAgIGJ1ZmZlcltpZHggKyA4XSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAyLiBBc3NpZ24gQ2hpbGRyZW4gdG8gbmVhcmVzdCBQYXJlbnRcbiAgICAgICAgZm9yIChsZXQgaSA9IHBhcmVudENvdW50OyBpIDwgTk9ERV9DT1VOVDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaWR4ICAgICAgICA9IGkgKiBOT0RFX1NUUklERSxcbiAgICAgICAgICAgICAgICB4ICAgICAgICAgID0gYnVmZmVyW2lkeF0sXG4gICAgICAgICAgICAgICAgeSAgICAgICAgICA9IGJ1ZmZlcltpZHggKyAxXSxcbiAgICAgICAgICAgICAgICBiZXN0RGlzdCAgID0gSW5maW5pdHksXG4gICAgICAgICAgICAgICAgYmVzdFBhcmVudCA9IC0xO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBwaWQgb2YgcGFyZW50SW5kaWNlcykge1xuICAgICAgICAgICAgICAgIGxldCBwSWR4ID0gcGlkICogTk9ERV9TVFJJREUsXG4gICAgICAgICAgICAgICAgICAgIHB4ICAgPSBidWZmZXJbcElkeF0sXG4gICAgICAgICAgICAgICAgICAgIHB5ICAgPSBidWZmZXJbcElkeCArIDFdLFxuICAgICAgICAgICAgICAgICAgICBkeCAgID0geCAtIHB4LFxuICAgICAgICAgICAgICAgICAgICBkeSAgID0geSAtIHB5LFxuICAgICAgICAgICAgICAgICAgICBkU3EgID0gZHgqZHggKyBkeSpkeTtcblxuICAgICAgICAgICAgICAgIGlmIChkU3EgPCBiZXN0RGlzdCkge1xuICAgICAgICAgICAgICAgICAgICBiZXN0RGlzdCA9IGRTcTtcbiAgICAgICAgICAgICAgICAgICAgYmVzdFBhcmVudCA9IHBpZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJ1ZmZlcltpZHggKyA2XSA9IGJlc3RQYXJlbnRcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBwYWNrZXQgYnVmZmVyLlxuICAgICAqL1xuICAgIGluaXRQYWNrZXRzKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuICAgICAgICBpZiAoIW1lLnBhY2tldEJ1ZmZlcikge1xuICAgICAgICAgICAgbWUucGFja2V0QnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShQQUNLRVRfQ09VTlQgKiBQQUNLRVRfU1RSSURFKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7RnVuY3Rpb259IHJlbmRlckxvb3A9dGhpcy5yZW5kZXIuYmluZCh0aGlzKVxuICAgICAqL1xuICAgIHJlbmRlckxvb3AgPSB0aGlzLnJlbmRlci5iaW5kKHRoaXMpXG5cbiAgICAvKipcbiAgICAgKiBNYWluIHNpbXVsYXRpb24gYW5kIHJlbmRlciBsb29wLlxuICAgICAqIEV4ZWN1dGVkIH42MCB0aW1lcyBwZXIgc2Vjb25kLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIW1lLmNhblJlbmRlcikge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdFxuICAgICAgICAgICAgY3R4ICAgID0gbWUuY29udGV4dCxcbiAgICAgICAgICAgIHdpZHRoICA9IG1lLmNhbnZhc1NpemU/LndpZHRoICB8fCAxMDAsXG4gICAgICAgICAgICBoZWlnaHQgPSBtZS5jYW52YXNTaXplPy5oZWlnaHQgfHwgNTA7XG5cbiAgICAgICAgbWUudGltZSArPSAwLjAxO1xuXG4gICAgICAgIGlmICghbWUubm9kZUJ1ZmZlcikgbWUuaW5pdE5vZGVzKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBpZiAoIW1lLmFnZW50QnVmZmVyKSBtZS5pbml0QWdlbnRzKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBpZiAoIW1lLnBhY2tldEJ1ZmZlcikgbWUuaW5pdFBhY2tldHMoKTtcblxuICAgICAgICAvLyBQaHlzaWNzIFVwZGF0ZSBTdGVwc1xuICAgICAgICBtZS51cGRhdGVQaHlzaWNzKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBtZS51cGRhdGVBZ2VudHMod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIG1lLnVwZGF0ZVBhY2tldHMoKTtcbiAgICAgICAgbWUudXBkYXRlU3BhcmtzKCk7XG5cbiAgICAgICAgLy8gUmVuZGVyaW5nIFN0ZXBzXG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgaWYgKG1lLmdyYWRpZW50cy5iZ0dyYWRpZW50KSB7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gbWUuZ3JhZGllbnRzLmJnR3JhZGllbnQ7XG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodClcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmRyYXdOZXR3b3JrKGN0eCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIG1lLmRyYXdQYWNrZXRzKGN0eCk7XG4gICAgICAgIG1lLmRyYXdBZ2VudHMoY3R4KTtcbiAgICAgICAgbWUuZHJhd1Nob2Nrd2F2ZXMoY3R4KTtcbiAgICAgICAgbWUuZHJhd1NwYXJrcyhjdHgpO1xuXG4gICAgICAgIGlmIChoYXNSYWYpIHtcbiAgICAgICAgICAgIG1lLmFuaW1hdGlvbklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKG1lLnJlbmRlckxvb3ApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5hbmltYXRpb25JZCA9IHNldFRpbWVvdXQobWUucmVuZGVyTG9vcCwgMTAwMCAvIDYwKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcnMgc2hvY2t3YXZlcyBvbiBjbGljay5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uTW91c2VDbGljayhkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBzICA9IG1lLnNjYWxlO1xuXG4gICAgICAgIG1lLnNob2Nrd2F2ZXMucHVzaCh7XG4gICAgICAgICAgICB4ICAgICAgICA6IGRhdGEueCxcbiAgICAgICAgICAgIHkgICAgICAgIDogZGF0YS55LFxuICAgICAgICAgICAgYWdlICAgICAgOiAwLFxuICAgICAgICAgICAgbWF4QWdlICAgOiA0MCwgLy8gRmFzdGVyLCBwdW5jaGllciB3YXZlXG4gICAgICAgICAgICBtYXhSYWRpdXM6IDMwMCAqIHMgLy8gU2NhbGVkIHJhZGl1c1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBTcGF3biBTcGFya3MgKERhdGEgRGVicmlzKVxuICAgICAgICBmb3IobGV0IGk9MDsgaTw0MDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgYW5nbGUgPSBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDIsXG4gICAgICAgICAgICAgICAgc3BlZWQgPSAoTWF0aC5yYW5kb20oKSAqIDE1ICsgNSkgKiBzOyAvLyBTY2FsZWQgc3BlZWRcbiAgICAgICAgICAgIG1lLnNwYXJrcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB4ICAgIDogZGF0YS54LFxuICAgICAgICAgICAgICAgIHkgICAgOiBkYXRhLnksXG4gICAgICAgICAgICAgICAgdnggICA6IE1hdGguY29zKGFuZ2xlKSAqIHNwZWVkLFxuICAgICAgICAgICAgICAgIHZ5ICAgOiBNYXRoLnNpbihhbmdsZSkgKiBzcGVlZCxcbiAgICAgICAgICAgICAgICBsaWZlIDogMS4wLFxuICAgICAgICAgICAgICAgIGRlY2F5OiAwLjAyICsgTWF0aC5yYW5kb20oKSAqIDAuMDNcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHBhY2tldCBsb2dpYyAoRGF0YSBGbG93KS5cbiAgICAgKiBQYWNrZXRzIHNwYXduIHJhbmRvbWx5IGF0IGNoaWxkIG5vZGVzIGFuZCB0cmF2ZWwgdG8gdGhlaXIgcGFyZW50IG5vZGVzLFxuICAgICAqIHJlcHJlc2VudGluZyBkYXRhIHJlcG9ydGluZyB1cHN0cmVhbS5cbiAgICAgKi9cbiAgICB1cGRhdGVQYWNrZXRzKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuICAgICAgICBpZiAoIW1lLnBhY2tldEJ1ZmZlciB8fCAhbWUubm9kZUJ1ZmZlcikgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBwYWNrZXRzID0gbWUucGFja2V0QnVmZmVyLFxuICAgICAgICAgICAgbm9kZXMgICA9IG1lLm5vZGVCdWZmZXIsXG4gICAgICAgICAgICBwQ291bnQgID0gUEFDS0VUX0NPVU5ULFxuICAgICAgICAgICAgbkNvdW50ICA9IE5PREVfQ09VTlQsXG4gICAgICAgICAgICBzICAgICAgID0gbWUuc2NhbGU7IC8vIEdldCBzY2FsZSBmYWN0b3JcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaWR4ID0gaSAqIFBBQ0tFVF9TVFJJREUsXG4gICAgICAgICAgICAgICAgbGlmZSA9IHBhY2tldHNbaWR4ICsgNF07XG5cbiAgICAgICAgICAgIGlmIChsaWZlIDw9IDApIHtcbiAgICAgICAgICAgICAgICAvLyBTcGF3biBuZXcgcGFja2V0PyAoUmFuZG9tIGNoYW5jZSlcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5yYW5kb20oKSA8IDAuMDIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGljayByYW5kb20gbm9kZSAoc291cmNlKVxuICAgICAgICAgICAgICAgICAgICBsZXQgbjEgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBuQ291bnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWR4MSA9IG4xICogTk9ERV9TVFJJREUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwaWQgPSBub2Rlc1tpZHgxICsgNl07IC8vIFBhcmVudCBJRFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFZhbGlkIHRhcmdldHM6IFBhcmVudCAoaWYgY2hpbGQpLCBvciBDaGlsZCAoaWYgcGFyZW50KVxuICAgICAgICAgICAgICAgICAgICAvLyBTaW1wbGlmaWVkOiBKdXN0IGdvIENoaWxkIC0+IFBhcmVudCBmb3Igbm93IChEYXRhIHJlcG9ydGluZylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBpZCAhPT0gLTEpIHsgLy8gSWYgaXQncyBhIGNoaWxkXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaWR4MiA9IHBpZCAqIE5PREVfU1RSSURFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgxICAgPSBub2Rlc1tpZHgxXSwgeTEgPSBub2Rlc1tpZHgxICsgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDIgICA9IG5vZGVzW2lkeDJdLCB5MiA9IG5vZGVzW2lkeDIgKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkeCAgID0geDIgLSB4MSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkeSAgID0geTIgLSB5MSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXN0ID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBzcGF3biBpZiBjb25uZWN0ZWQgYW5kIGNsb3NlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdCA8IDIwMCAqIHMpIHsgLy8gU2NhbGVkIGRpc3RhbmNlIGNoZWNrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFja2V0c1tpZHhdICAgICA9IHgxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhY2tldHNbaWR4ICsgMV0gPSB5MTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3BlZWQgICAgICAgID0gNCAqIHM7IC8vIFNjYWxlZCBzcGVlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhY2tldHNbaWR4ICsgMl0gPSAoZHggLyBkaXN0KSAqIHNwZWVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhY2tldHNbaWR4ICsgM10gPSAoZHkgLyBkaXN0KSAqIHNwZWVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhY2tldHNbaWR4ICsgNF0gPSBkaXN0IC8gc3BlZWQgLy8gTGlmZSA9IGZyYW1lcyB0byByZWFjaCB0YXJnZXQgKHN0YXlzIHNhbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE1vdmVcbiAgICAgICAgICAgICAgICBwYWNrZXRzW2lkeF0gICAgICs9IHBhY2tldHNbaWR4ICsgMl07XG4gICAgICAgICAgICAgICAgcGFja2V0c1tpZHggKyAxXSArPSBwYWNrZXRzW2lkeCArIDNdO1xuICAgICAgICAgICAgICAgIHBhY2tldHNbaWR4ICsgNF0tLSAvLyBEZWNyZWFzZSBsaWZlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHNwYXJrIHBhcnRpY2xlcyB3aXRoIGZyaWN0aW9uIGFuZCBkZWNheS5cbiAgICAgKi9cbiAgICB1cGRhdGVTcGFya3MoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSBtZS5zcGFya3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBzID0gbWUuc3BhcmtzW2ldO1xuICAgICAgICAgICAgcy54ICs9IHMudng7XG4gICAgICAgICAgICBzLnkgKz0gcy52eTtcbiAgICAgICAgICAgIC8vIEZyaWN0aW9uIChEcmFnKVxuICAgICAgICAgICAgcy52eCAqPSAwLjk7XG4gICAgICAgICAgICBzLnZ5ICo9IDAuOTtcbiAgICAgICAgICAgIHMubGlmZSAtPSBzLmRlY2F5O1xuICAgICAgICAgICAgaWYgKHMubGlmZSA8PSAwKSB7XG4gICAgICAgICAgICAgICAgbWUuc3BhcmtzLnNwbGljZShpLCAxKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBhZ2VudCBwb3NpdGlvbnMgdXNpbmcgKipCb2lkKiogbG9naWMgKFNlZWssIFNlcGFyYXRlKS5cbiAgICAgKiBBZ2VudHMgcmFuZG9tbHkgcGljayBhIHRhcmdldCBub2RlLCBzZWVrIGl0LCBzY2FuIGl0ICh0cmFuc2ZlcnJpbmcgZW5lcmd5KSxcbiAgICAgKiBhbmQgdGhlbiBwaWNrIGEgbmV3IHRhcmdldC4gVGhleSBhbHNvIGF2b2lkIHRoZSBtb3VzZSBjdXJzb3IuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqL1xuICAgIHVwZGF0ZUFnZW50cyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5hZ2VudEJ1ZmZlciB8fCAhbWUubm9kZUJ1ZmZlcikgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBhZ2VudHMgPSBtZS5hZ2VudEJ1ZmZlcixcbiAgICAgICAgICAgIG5vZGVzICA9IG1lLm5vZGVCdWZmZXIsXG4gICAgICAgICAgICBjb3VudCAgPSBBR0VOVF9DT1VOVCxcbiAgICAgICAgICAgIG14ICAgICA9IG1lLm1vdXNlLngsXG4gICAgICAgICAgICBteSAgICAgPSBtZS5tb3VzZS55LFxuICAgICAgICAgICAgcyAgICAgID0gbWUuc2NhbGU7IC8vIEdldCBzY2FsZSBmYWN0b3JcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpZHggPSBpICogQUdFTlRfU1RSSURFLFxuICAgICAgICAgICAgICAgIHRhcmdldElkeCA9IGFnZW50c1tpZHggKyA0XSxcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IGFnZW50c1tpZHggKyA1XTtcblxuICAgICAgICAgICAgLy8gQmVoYXZpb3IgMTogUGljayBhIFRhcmdldFxuICAgICAgICAgICAgaWYgKHRhcmdldElkeCA9PT0gLTEgfHwgTWF0aC5yYW5kb20oKSA8IDAuMDA1KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50Q291bnQgPSBNYXRoLmZsb29yKE5PREVfQ09VTlQgKiAwLjEpO1xuICAgICAgICAgICAgICAgIGFnZW50c1tpZHggKyA0XSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBhcmVudENvdW50KTtcbiAgICAgICAgICAgICAgICB0YXJnZXRJZHggPSBhZ2VudHNbaWR4ICsgNF07XG4gICAgICAgICAgICAgICAgYWdlbnRzW2lkeCArIDVdID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQmVoYXZpb3IgMjogU2VlayBUYXJnZXRcbiAgICAgICAgICAgIGlmICh0YXJnZXRJZHggIT09IC0xICYmIHN0YXRlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5JZHggPSB0YXJnZXRJZHggKiBOT0RFX1NUUklERSxcbiAgICAgICAgICAgICAgICAgICAgdHggICA9IG5vZGVzW25JZHhdLFxuICAgICAgICAgICAgICAgICAgICB0eSAgID0gbm9kZXNbbklkeCArIDFdLFxuICAgICAgICAgICAgICAgICAgICBkeCAgID0gdHggLSBhZ2VudHNbaWR4XSxcbiAgICAgICAgICAgICAgICAgICAgZHkgICA9IHR5IC0gYWdlbnRzW2lkeCArIDFdLFxuICAgICAgICAgICAgICAgICAgICBkaXN0ID0gTWF0aC5zcXJ0KGR4KmR4ICsgZHkqZHkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRpc3QgPCAxMCAqIHMpIHsgLy8gU2NhbGVkIGFycml2YWwgZGlzdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgLy8gQXJyaXZlZCEgU2Nhbi5cbiAgICAgICAgICAgICAgICAgICAgYWdlbnRzW2lkeCArIDVdID0gMTsgLy8gU2NhbiBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICBhZ2VudHNbaWR4ICsgMl0gKj0gMC4xOyAvLyBTbG93IGRvd25cbiAgICAgICAgICAgICAgICAgICAgYWdlbnRzW2lkeCArIDNdICo9IDAuMTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUcmFuc2ZlciBFbmVyZ3kgdG8gTm9kZVxuICAgICAgICAgICAgICAgICAgICBub2Rlc1tuSWR4ICsgOF0gPSAxLjA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RlZXIgdG93YXJkcyB0YXJnZXRcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvcmNlID0gMC4wNSAqIHM7IC8vIFNjYWxlZCBzdGVlcmluZyBmb3JjZVxuICAgICAgICAgICAgICAgICAgICBhZ2VudHNbaWR4ICsgMl0gKz0gKGR4IC8gZGlzdCkgKiBmb3JjZTtcbiAgICAgICAgICAgICAgICAgICAgYWdlbnRzW2lkeCArIDNdICs9IChkeSAvIGRpc3QpICogZm9yY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgMC4wMikge1xuICAgICAgICAgICAgICAgICAgICBhZ2VudHNbaWR4ICsgNF0gPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgYWdlbnRzW2lkeCArIDVdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYWdlbnRzW2lkeCArIDJdICs9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDQgKiBzOyAvLyBTY2FsZWQgcmFuZG9tIGJ1cnN0XG4gICAgICAgICAgICAgICAgICAgIGFnZW50c1tpZHggKyAzXSArPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiA0ICogcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEJlaGF2aW9yIDM6IE1vdXNlIFJlcHVsc2lvblxuICAgICAgICAgICAgaWYgKG14ICE9PSAtMTAwMCkge1xuICAgICAgICAgICAgICAgIGxldCBkeCA9IGFnZW50c1tpZHhdIC0gbXgsXG4gICAgICAgICAgICAgICAgICAgIGR5ID0gYWdlbnRzW2lkeCArIDFdIC0gbXksXG4gICAgICAgICAgICAgICAgICAgIGRpc3RTcSA9IGR4KmR4ICsgZHkqZHk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGlzdFNxIDwgMTAwMDAgKiBzICogcykgeyAvLyBTY2FsZWQgaW50ZXJhY3Rpb24gcmFkaXVzIHNxdWFyZWRcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRpc3QgID0gTWF0aC5zcXJ0KGRpc3RTcSksXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JjZSA9ICgxMDAgKiBzIC0gZGlzdCkgLyAoMTAwICogcyk7IC8vIFNjYWxlZCBmb3JjZSBjYWxjdWxhdGlvblxuICAgICAgICAgICAgICAgICAgICBhZ2VudHNbaWR4ICsgMl0gKz0gKGR4IC8gZGlzdCkgKiBmb3JjZSAqIDEuNSAqIHM7XG4gICAgICAgICAgICAgICAgICAgIGFnZW50c1tpZHggKyAzXSArPSAoZHkgLyBkaXN0KSAqIGZvcmNlICogMS41ICogcztcbiAgICAgICAgICAgICAgICAgICAgYWdlbnRzW2lkeCArIDVdID0gMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3BlZWQgTGltaXQgJiBNb3ZlXG4gICAgICAgICAgICBsZXQgc3BlZWQgPSBNYXRoLnNxcnQoYWdlbnRzW2lkeCArIDJdKioyICsgYWdlbnRzW2lkeCArIDNdKioyKTtcbiAgICAgICAgICAgIGlmIChzcGVlZCA+IDQgKiBzKSB7IC8vIFNjYWxlZCBzcGVlZCBsaW1pdFxuICAgICAgICAgICAgICAgIGFnZW50c1tpZHggKyAyXSAqPSAoNCAqIHMpIC8gc3BlZWQ7XG4gICAgICAgICAgICAgICAgYWdlbnRzW2lkeCArIDNdICo9ICg0ICogcykgLyBzcGVlZFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhZ2VudHNbaWR4XSAgICAgKz0gYWdlbnRzW2lkeCArIDJdO1xuICAgICAgICAgICAgYWdlbnRzW2lkeCArIDFdICs9IGFnZW50c1tpZHggKyAzXTtcblxuICAgICAgICAgICAgaWYgKGFnZW50c1tpZHhdIDwgMCkgYWdlbnRzW2lkeF0gPSB3aWR0aDtcbiAgICAgICAgICAgIGlmIChhZ2VudHNbaWR4XSA+IHdpZHRoKSBhZ2VudHNbaWR4XSA9IDA7XG4gICAgICAgICAgICBpZiAoYWdlbnRzW2lkeCArIDFdIDwgMCkgYWdlbnRzW2lkeCArIDFdID0gaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKGFnZW50c1tpZHggKyAxXSA+IGhlaWdodCkgYWdlbnRzW2lkeCArIDFdID0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgbm9kZSBwb3NpdGlvbnMgdXNpbmcgKipDbHVzdGVyIFBoeXNpY3MqKi5cbiAgICAgKiBIYW5kbGVzOlxuICAgICAqIDEuICAqKkNvaGVzaW9uOioqIENoaWxkcmVuIHN0aWNrIHRvIHBhcmVudHMuXG4gICAgICogMi4gICoqRmxvdyBGaWVsZHM6KiogUGFyZW50cyBkcmlmdCBpbiBvcmdhbmljIHBhdHRlcm5zLlxuICAgICAqIDMuICAqKlRvcG9sb2d5IE11dGF0aW9uOioqIE5vZGVzIGNhbiBkZXRhY2ggYW5kIHJlLXBhcmVudC5cbiAgICAgKiA0LiAgKipJbnRlcmFjdGlvbjoqKiBNb3VzZSByZXB1bHNpb24gYW5kIHNob2Nrd2F2ZSBleHBsb3Npb24uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqL1xuICAgIHVwZGF0ZVBoeXNpY3Mod2lkdGgsIGhlaWdodCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUubm9kZUJ1ZmZlcikgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBidWZmZXIgICAgICA9IG1lLm5vZGVCdWZmZXIsXG4gICAgICAgICAgICBteCAgICAgICAgICA9IG1lLm1vdXNlLngsXG4gICAgICAgICAgICBteSAgICAgICAgICA9IG1lLm1vdXNlLnksXG4gICAgICAgICAgICBwYXJlbnRDb3VudCA9IE1hdGguZmxvb3IoTk9ERV9DT1VOVCAqIDAuMSksXG4gICAgICAgICAgICBzICAgICAgICAgICA9IG1lLnNjYWxlOyAvLyBHZXQgc2NhbGUgZmFjdG9yXG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOT0RFX0NPVU5UOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpZHggPSBpICogTk9ERV9TVFJJREUsXG4gICAgICAgICAgICAgICAgcGFyZW50SWQgPSBidWZmZXJbaWR4ICsgNl0sXG4gICAgICAgICAgICAgICAgaXNQYXJlbnQgPSBwYXJlbnRJZCA9PT0gLTE7XG5cbiAgICAgICAgICAgIC8vIC0tLSBNVVRBVElPTiBMT0dJQyAoUmUtUGFyZW50aW5nKSAtLS1cbiAgICAgICAgICAgIGlmICghaXNQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyAxLiBDaGFuY2UgdG8gZGV0YWNoIChiZWNvbWVzIERyaWZ0aW5nOiAtMilcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50SWQgIT09IC0yICYmIE1hdGgucmFuZG9tKCkgPCAwLjAwMDUpIHsgLy8gUmFyZSBldmVudFxuICAgICAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgNl0gPSAtMjtcbiAgICAgICAgICAgICAgICAgICAgLy8gQm9vc3QgdmVsb2NpdHkgdG8gZXNjYXBlXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltpZHggKyAyXSArPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAyICogcztcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2lkeCArIDNdICs9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDIgKiBzXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gMi4gUmUtYXR0YWNoIExvZ2ljIChpZiBEcmlmdGluZylcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50SWQgPT09IC0yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdhbmRlciBiZWhhdmlvclxuICAgICAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgMl0gKz0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMC4xICogcztcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2lkeCArIDNdICs9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDAuMSAqIHM7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIG5ldyBwYXJlbnRcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBwYXJlbnRDb3VudDsgcCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcElkeCA9IHAgKiBOT0RFX1NUUklERSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBweCAgID0gYnVmZmVyW3BJZHhdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB5ICAgPSBidWZmZXJbcElkeCArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3QgPSBNYXRoLnNxcnQoKHB4IC0gYnVmZmVyW2lkeF0pKioyICsgKHB5IC0gYnVmZmVyW2lkeCArIDFdKSoqMik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXN0IDwgNjAgKiBzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2lkeCArIDZdID0gcDsgLy8gU25hcCB0byBuZXcgcGFyZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gMS4gQ2x1c3RlciBDb2hlc2lvbiAoQ2hpbGRyZW4gc3RpY2sgdG8gUGFyZW50KVxuICAgICAgICAgICAgaWYgKCFpc1BhcmVudCAmJiBidWZmZXJbaWR4ICsgNl0gIT09IC0yKSB7IC8vIE5vcm1hbCBDaGlsZFxuICAgICAgICAgICAgICAgIGxldCBwSWR4ID0gcGFyZW50SWQgKiBOT0RFX1NUUklERSxcbiAgICAgICAgICAgICAgICAgICAgcHggICA9IGJ1ZmZlcltwSWR4XSxcbiAgICAgICAgICAgICAgICAgICAgcHkgICA9IGJ1ZmZlcltwSWR4ICsgMV0sXG4gICAgICAgICAgICAgICAgICAgIGR4ICAgPSBweCAtIGJ1ZmZlcltpZHhdLFxuICAgICAgICAgICAgICAgICAgICBkeSAgID0gcHkgLSBidWZmZXJbaWR4ICsgMV0sXG4gICAgICAgICAgICAgICAgICAgIGRpc3QgPSBNYXRoLnNxcnQoZHgqZHggKyBkeSpkeSk7XG5cbiAgICAgICAgICAgICAgICAvLyBTcHJpbmcgZm9yY2UgdG93YXJkcyBwYXJlbnRcbiAgICAgICAgICAgICAgICBpZiAoZGlzdCA+IDUwICogcykgeyAvLyBJZGVhbCBkaXN0YW5jZVxuICAgICAgICAgICAgICAgICAgICBsZXQgZm9yY2UgPSAoZGlzdCAtIDUwICogcykgKiAwLjAwMDU7IC8vIENvbnN0YW50IHNwcmluZyBmYWN0b3IgaXMgZmluZVxuICAgICAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgMl0gKz0gZHggKiBmb3JjZTtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2lkeCArIDNdICs9IGR5ICogZm9yY2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIDIuIE1vdXNlIFJlcHVsc2lvbiAoQWxsIG5vZGVzKVxuICAgICAgICAgICAgaWYgKG14ICE9PSAtMTAwMCkge1xuICAgICAgICAgICAgICAgIGxldCBkeCAgICAgPSBidWZmZXJbaWR4XSAtIG14LFxuICAgICAgICAgICAgICAgICAgICBkeSAgICAgPSBidWZmZXJbaWR4ICsgMV0gLSBteSxcbiAgICAgICAgICAgICAgICAgICAgZGlzdFNxID0gZHggKiBkeCArIGR5ICogZHk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGlzdFNxIDwgMjI1MDAgKiBzICogcykgeyAvLyAxNTAqcyBzcXVhcmVkXG4gICAgICAgICAgICAgICAgICAgIGxldCBkaXN0ICA9IE1hdGguc3FydChkaXN0U3EpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2UgPSAoMTUwICogcyAtIGRpc3QpIC8gKDE1MCAqIHMpO1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgMl0gKz0gKGR4IC8gZGlzdCkgKiBmb3JjZSAqIDAuNSAqIHM7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltpZHggKyAzXSArPSAoZHkgLyBkaXN0KSAqIGZvcmNlICogMC41ICogc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gMy4gU2hvY2t3YXZlIFJlcHVsc2lvbiAoRXhwbG9zaXZlIEZvcmNlKVxuICAgICAgICAgICAgaWYgKG1lLnNob2Nrd2F2ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG1lLnNob2Nrd2F2ZXMuZm9yRWFjaCh3YXZlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByb2dyZXNzID0gd2F2ZS5hZ2UgLyB3YXZlLm1heEFnZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvZ3Jlc3MgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZWFzZWQgPSAxIC0gTWF0aC5wb3coMSAtIHByb2dyZXNzLCAzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3UmFkICA9IGVhc2VkICogd2F2ZS5tYXhSYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHggICAgPSBidWZmZXJbaWR4XSAtIHdhdmUueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkeSAgICA9IGJ1ZmZlcltpZHggKyAxXSAtIHdhdmUueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXN0ICA9IE1hdGguc3FydChkeCpkeCArIGR5KmR5KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGl0IHRoZSBcIldhdmUgRnJvbnRcIiAoV2lkdGggbWF0Y2hlcyB2aXN1YWwgcmluZyB+MjBweCAqIHNjYWxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGRpc3QgLSB3UmFkKSA8IDIwICogcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmb3JjZSA9ICgxIC0gcHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hc3NpdmUgSW1wdWxzZSAoVGhyb3dpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2lkeCArIDJdICs9IChkeCAvIGRpc3QpICogZm9yY2UgKiAxMCAqIHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2lkeCArIDNdICs9IChkeSAvIGRpc3QpICogZm9yY2UgKiAxMCAqIHNcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyA0LiBQaHlzaWNzXG4gICAgICAgICAgICBidWZmZXJbaWR4ICsgMl0gKj0gMC45NTsgLy8gRnJpY3Rpb25cbiAgICAgICAgICAgIGJ1ZmZlcltpZHggKyAzXSAqPSAwLjk1O1xuXG4gICAgICAgICAgICAvLyBFbmVyZ3kgRGVjYXlcbiAgICAgICAgICAgIGJ1ZmZlcltpZHggKyA4XSAqPSAwLjk5O1xuXG4gICAgICAgICAgICBsZXQgZHJpZnQgPSBpc1BhcmVudCA/IDAuMDIgOiAwLjAxO1xuXG4gICAgICAgICAgICAvLyA0LiBBbWJpZW50IERyaWZ0IC8gRmxvdyBGaWVsZFxuICAgICAgICAgICAgaWYgKGlzUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gRkxPVyBGSUVMRCBmb3IgUGFyZW50czogQ3JlYXRlIG9yZ2FuaWMgY3VycmVudHNcbiAgICAgICAgICAgICAgICAvLyBDb21iaW5lIFNpbmUvQ29zaW5lIGJhc2VkIG9uIHBvc2l0aW9uIGFuZCB0aW1lXG4gICAgICAgICAgICAgICAgbGV0IGFuZ2xlID0gKE1hdGguY29zKGJ1ZmZlcltpZHhdICAgICAqIDAuMDAyIC8gcyArIG1lLnRpbWUgKiAwLjUpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5zaW4oYnVmZmVyW2lkeCArIDFdICogMC4wMDIgLyBzICsgbWUudGltZSAqIDAuNSkpICogTWF0aC5QSTtcblxuICAgICAgICAgICAgICAgIC8vIEFjY2VsZXJhdGUgaW4gZmxvdyBkaXJlY3Rpb25cbiAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgMl0gKz0gTWF0aC5jb3MoYW5nbGUpICogMC4wNSAqIHM7XG4gICAgICAgICAgICAgICAgYnVmZmVyW2lkeCArIDNdICs9IE1hdGguc2luKGFuZ2xlKSAqIDAuMDUgKiBzO1xuXG4gICAgICAgICAgICAgICAgLy8gQ09OVEFJTk1FTlQgRklFTEQgKEZpeCBmb3IgRHJpZnQgQmlhcylcbiAgICAgICAgICAgICAgICAvLyBHZW50bHkgcHVzaCBub2RlcyBiYWNrIHRvIGNlbnRlciBpZiB0aGV5IHdhbmRlciB0b28gZmFyXG4gICAgICAgICAgICAgICAgbGV0IGN4ICAgID0gd2lkdGggLyAyLFxuICAgICAgICAgICAgICAgICAgICBjeSAgICA9IGhlaWdodCAvIDIsXG4gICAgICAgICAgICAgICAgICAgIGR4ICAgID0gY3ggLSBidWZmZXJbaWR4XSxcbiAgICAgICAgICAgICAgICAgICAgZHkgICAgPSBjeSAtIGJ1ZmZlcltpZHggKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgZGlzdCAgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpLFxuICAgICAgICAgICAgICAgICAgICBsaW1pdCA9IE1hdGgubWluKHdpZHRoLCBoZWlnaHQpICogMC40OyAvLyBLZWVwIHdpdGhpbiA4MCUgb2Ygc2NyZWVuIGNlbnRlclxuXG4gICAgICAgICAgICAgICAgaWYgKGRpc3QgPiBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm9yY2UgPSAoZGlzdCAtIGxpbWl0KSAqIDAuMDAxOyAvLyBTb2Z0IHNwcmluZ1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJbaWR4ICsgMl0gKz0gKGR4IC8gZGlzdCkgKiBmb3JjZTtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2lkeCArIDNdICs9IChkeSAvIGRpc3QpICogZm9yY2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFJhbmRvbSB3YW5kZXIgZm9yIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGJ1ZmZlcltpZHggKyAyXSkgPCAwLjIgKiBzKSBidWZmZXJbaWR4ICsgMl0gKz0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMC4wMiAqIHM7XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGJ1ZmZlcltpZHggKyAzXSkgPCAwLjIgKiBzKSBidWZmZXJbaWR4ICsgM10gKz0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMC4wMiAqIHNcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnVmZmVyW2lkeF0gICAgICs9IGJ1ZmZlcltpZHggKyAyXTtcbiAgICAgICAgICAgIGJ1ZmZlcltpZHggKyAxXSArPSBidWZmZXJbaWR4ICsgM107XG5cbiAgICAgICAgICAgIC8vIEJvdW5jZVxuICAgICAgICAgICAgY29uc3QgcGFkID0gMjAgKiBzO1xuICAgICAgICAgICAgaWYgKGJ1ZmZlcltpZHhdIDwgcGFkKSAgICAgICAgICAgICAgeyBidWZmZXJbaWR4XSA9IHBhZDsgYnVmZmVyW2lkeCArIDJdICo9IC0xOyB9XG4gICAgICAgICAgICBpZiAoYnVmZmVyW2lkeF0gPiB3aWR0aCAtIHBhZCkgICAgICB7IGJ1ZmZlcltpZHhdID0gd2lkdGggLSBwYWQ7IGJ1ZmZlcltpZHggKyAyXSAqPSAtMTsgfVxuICAgICAgICAgICAgaWYgKGJ1ZmZlcltpZHggKyAxXSA8IHBhZCkgICAgICAgICAgeyBidWZmZXJbaWR4ICsgMV0gPSBwYWQ7IGJ1ZmZlcltpZHggKyAzXSAqPSAtMTsgfVxuICAgICAgICAgICAgaWYgKGJ1ZmZlcltpZHggKyAxXSA+IGhlaWdodCAtIHBhZCkgeyBidWZmZXJbaWR4ICsgMV0gPSBoZWlnaHQgLSBwYWQ7IGJ1ZmZlcltpZHggKyAzXSAqPSAtMTsgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbmQgY2FjaGVzIGdyYWRpZW50cy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAgICovXG4gICAgdXBkYXRlUmVzb3VyY2VzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgbGV0IG1lICA9IHRoaXMsXG4gICAgICAgICAgICBjdHggPSBtZS5jb250ZXh0O1xuXG4gICAgICAgIGlmICghY3R4KSByZXR1cm47XG5cbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIHRoZW1lQ29sb3JzID0gbWUuY29uc3RydWN0b3IuY29sb3JzW21lLnRoZW1lXSxcbiAgICAgICAgICAgIGdyYWRpZW50ICAgID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCB0aGVtZUNvbG9ycy5iYWNrZ3JvdW5kWzBdKTtcbiAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsIHRoZW1lQ29sb3JzLmJhY2tncm91bmRbMV0pO1xuXG4gICAgICAgIG1lLmdyYWRpZW50cy5iZ0dyYWRpZW50ID0gZ3JhZGllbnRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2l6ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzaXplLmhlaWdodFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzaXplLndpZHRoXG4gICAgICovXG4gICAgdXBkYXRlU2l6ZShzaXplKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuY2FudmFzU2l6ZSA9IHNpemU7XG4gICAgICAgIC8vIFJlZmVyZW5jZSByZXNvbHV0aW9uOiAxOTIweDEwODAuXG4gICAgICAgIC8vIFNxdWFyZSByb290IG9mIGFyZWEgcmF0aW8gZ2l2ZXMgYSBiYWxhbmNlZCBsaW5lYXIgc2NhbGUgZmFjdG9yLlxuICAgICAgICBtZS5zY2FsZSA9IE1hdGguc3FydCgoc2l6ZS53aWR0aCAqIHNpemUuaGVpZ2h0KSAvIDIwNzM2MDApO1xuXG4gICAgICAgIGlmIChtZS5jb250ZXh0KSB7XG4gICAgICAgICAgICBtZS5jb250ZXh0LmNhbnZhcy53aWR0aCAgPSBzaXplLndpZHRoO1xuICAgICAgICAgICAgbWUuY29udGV4dC5jYW52YXMuaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgICAvLyBGSVg6IEFsd2F5cyByZS1pbml0IG5vZGVzIG9uIHJlc2l6ZSB0byBmaXggXCJ0b3AtbGVmdCBibG9iXCIgaXNzdWVcbiAgICAgICAgICAgIG1lLmluaXROb2RlcyhzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG4gICAgICAgICAgICBtZS5pbml0QWdlbnRzKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcbiAgICAgICAgICAgIG1lLnVwZGF0ZVJlc291cmNlcyhzaXplLndpZHRoLCBzaXplLmhlaWdodClcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoSG9tZUNhbnZhcyk7XG4iLCJpbXBvcnQgTmVvQmFzZSBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAc3VtbWFyeSBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBDYW52YXMgUmVuZGVyZXJzLlxuICpcbiAqIFRoaXMgY2xhc3Mgc2VydmVzIGFzIHRoZSBmb3VuZGF0aW9uIGZvciB0aGUgc3BlY2lhbGl6ZWQgY2FudmFzIHZpc3VhbGl6YXRpb25zIChIZWFkZXIsIEhvbWUsIFNlcnZpY2VzLCBUaWNrZXQpXG4gKiB0aGF0IHJ1biB3aXRoaW4gdGhlICoqTmVvLm1qcyBDYW52YXMgU2hhcmVkV29ya2VyKiouXG4gKlxuICogSXQgY3JlYXRlcyBoZWxwZXIgc2luZ2xldG9ucyB0aGF0IG1hbmFnZSB0aGVpciBvd24gYE9mZnNjcmVlbkNhbnZhc2AgaW5zdGFuY2VzLCBwcm92aWRpbmcgYSBzdGFuZGFyZGl6ZWRcbiAqIGFyY2hpdGVjdHVyZSBmb3I6XG4gKiAtICoqTGlmZWN5Y2xlIE1hbmFnZW1lbnQ6KiogSW5pdGlhbGl6YXRpb24gKGBpbml0R3JhcGhgKSwgZGVzdHJ1Y3Rpb24gKGBjbGVhckdyYXBoYCksIGFuZCByZXNvdXJjZSBjbGVhbnVwLlxuICogLSAqKlJlbmRlciBMb29wIENvbnRyb2w6KiogVW5pZmllZCBgcmVuZGVyYCBsb29wIHdpdGggcGF1c2UvcmVzdW1lIGNhcGFiaWxpdGllcyBhbmQgZnJhbWUgc2NoZWR1bGluZy5cbiAqIC0gKipDb250ZXh0IE1hbmFnZW1lbnQ6KiogUm9idXN0IGhhbmRsaW5nIG9mIGBPZmZzY3JlZW5DYW52YXNgIHRyYW5zZmVyIGFuZCBjb250ZXh0IGFjcXVpc2l0aW9uIHZpYSBgd2FpdEZvckNhbnZhc2AuXG4gKiAtICoqU2hhcmVkIFN0YXRlOioqIENvbW1vbiBzdGF0ZSBtYW5hZ2VtZW50IGZvciBtb3VzZSBpbnRlcmFjdGlvbiwgdGltZSwgYW5kIHRoZW1pbmcuXG4gKlxuICogVGhlc2UgcmVuZGVyZXJzIG9wZXJhdGUgb2ZmIHRoZSBtYWluIHRocmVhZCB0byBlbnN1cmUgaGlnaC1wZXJmb3JtYW5jZSwgNjBmcHMgYW5pbWF0aW9ucyB3aXRob3V0XG4gKiBibG9ja2luZyB0aGUgVUkuXG4gKlxuICogQGNsYXNzIE5lby5jYW52YXMuQmFzZVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBCYXNlIGV4dGVuZHMgTmVvQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY2FudmFzLkJhc2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jYW52YXMuQmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdGUgbWV0aG9kIGFjY2Vzc1xuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHJlbW90ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdGU6IHtcbiAgICAgICAgICAgIGFwcDogW1xuICAgICAgICAgICAgICAgICdjbGVhckdyYXBoJyxcbiAgICAgICAgICAgICAgICAnaW5pdEdyYXBoJyxcbiAgICAgICAgICAgICAgICAncGF1c2UnLFxuICAgICAgICAgICAgICAgICdyZXN1bWUnLFxuICAgICAgICAgICAgICAgICdzZXRUaGVtZScsXG4gICAgICAgICAgICAgICAgJ3VwZGF0ZU1vdXNlU3RhdGUnLFxuICAgICAgICAgICAgICAgICd1cGRhdGVTaXplJ1xuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFjdGl2ZSBjb2xvciB0aGVtZSAoJ2xpZ2h0JyBvciAnZGFyaycpLlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHRoZW1lXz0nbGlnaHQnXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhlbWVfOiAnbGlnaHQnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IGFuaW1hdGlvbklkPW51bGxcbiAgICAgKi9cbiAgICBhbmltYXRpb25JZCA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gY2FudmFzSWQ9bnVsbFxuICAgICAqL1xuICAgIGNhbnZhc0lkID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBjYW52YXNTaXplPW51bGxcbiAgICAgKi9cbiAgICBjYW52YXNTaXplID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRHxudWxsfSBjb250ZXh0PW51bGxcbiAgICAgKi9cbiAgICBjb250ZXh0ID0gbnVsbFxuICAgIC8qKlxuICAgICAqIENhY2hlIGZvciByZXVzYWJsZSBncmFkaWVudHMgdG8gcHJldmVudCBHQy5cbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGdyYWRpZW50cz17fVxuICAgICAqL1xuICAgIGdyYWRpZW50cyA9IHt9XG4gICAgLyoqXG4gICAgICogRmxhZyB0byBwYXVzZSB0aGUgcmVuZGVyIGxvb3AuXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNQYXVzZWQ9ZmFsc2VcbiAgICAgKi9cbiAgICBpc1BhdXNlZCA9IGZhbHNlXG4gICAgLyoqXG4gICAgICogVHJhY2tlZCBtb3VzZSBwb3NpdGlvbiBmb3IgaW50ZXJhY3RpdmUgcGh5c2ljcy5cbiAgICAgKiBJbml0aWFsaXplIG9mZi1zY3JlZW4gdG8gcHJldmVudCBzdGFydHVwIGppdHRlcnMuXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBtb3VzZT17eDogLTEwMDAsIHk6IC0xMDAwfVxuICAgICAqL1xuICAgIG1vdXNlID0ge3g6IC0xMDAwLCB5OiAtMTAwMH1cbiAgICAvKipcbiAgICAgKiBHbG9iYWwgc2ltdWxhdGlvbiB0aW1lLlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gdGltZT0wXG4gICAgICovXG4gICAgdGltZSA9IDBcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufSByZW5kZXJMb29wPXRoaXMucmVuZGVyLmJpbmQodGhpcylcbiAgICAgKi9cbiAgICByZW5kZXJMb29wID0gdGhpcy5yZW5kZXIuYmluZCh0aGlzKVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBgdGhlbWVgIGNvbmZpZyBpcyBjaGFuZ2VkLlxuICAgICAqIFVwZGF0ZXMgdGhlIHJlc291cmNlIGNhY2hlIChncmFkaWVudHMsIGNvbG9ycykgdG8gcmVmbGVjdCB0aGUgbmV3IHRoZW1lIGltbWVkaWF0ZWx5LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIGFmdGVyU2V0VGhlbWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0aGlzLmNhbnZhc1NpemUpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUmVzb3VyY2VzPy4odGhpcy5jYW52YXNTaXplLndpZHRoLCB0aGlzLmNhbnZhc1NpemUuaGVpZ2h0KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBjYW52YXMgaXMgcmVhZHkgdG8gcmVuZGVyLlxuICAgICAqIFJldHVybnMgdHJ1ZSBvbmx5IGlmIHRoZSBjb250ZXh0IGV4aXN0cyBhbmQgdGhlIHNpbXVsYXRpb24gaXMgbm90IHBhdXNlZC5cbiAgICAgKiBTdWJjbGFzc2VzIHNob3VsZCBjYWxsIHRoaXMgYXQgdGhlIHN0YXJ0IG9mIHRoZWlyIGByZW5kZXJgIGxvb3AuXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGNhblJlbmRlcigpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcbiAgICAgICAgcmV0dXJuICEhKG1lLmNvbnRleHQgJiYgIW1lLmlzUGF1c2VkKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgZ3JhcGggc3RhdGUgYW5kIHN0b3BzIHRoZSByZW5kZXIgbG9vcC5cbiAgICAgKiBVc2UgdGhpcyB0byBjbGVhbnVwIHJlc291cmNlcyB3aGVuIHRoZSBjb21wb25lbnQgaXMgZGVzdHJveWVkIG9yIHVubW91bnRlZC5cbiAgICAgKi9cbiAgICBjbGVhckdyYXBoKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuICAgICAgICBtZS5jb250ZXh0ICAgICA9IG51bGw7XG4gICAgICAgIG1lLmNhbnZhc0lkICAgID0gbnVsbDtcbiAgICAgICAgbWUuY2FudmFzU2l6ZSAgPSBudWxsO1xuICAgICAgICBtZS5hbmltYXRpb25JZCA9IG51bGw7XG4gICAgICAgIG1lLmlzUGF1c2VkICAgID0gZmFsc2U7XG4gICAgICAgIG1lLmdyYWRpZW50cyAgID0ge307XG4gICAgICAgIG1lLm1vdXNlICAgICAgID0ge3g6IC0xMDAwLCB5OiAtMTAwMH07XG4gICAgICAgIG1lLnRpbWUgICAgICAgID0gMFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBjYW52YXMgY29udGV4dC5cbiAgICAgKiBTdGFydHMgdGhlIHBvbGxpbmcgbWVjaGFuaXNtIHRvIHdhaXQgZm9yIHRoZSBPZmZzY3JlZW5DYW52YXMgdHJhbnNmZXIgZnJvbSB0aGUgTWFpbiBUaHJlYWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy5jYW52YXNJZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRzLndpbmRvd0lkXG4gICAgICovXG4gICAgaW5pdEdyYXBoKHtjYW52YXNJZCwgd2luZG93SWR9KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaGFzQ2hhbmdlID0gbWUuY2FudmFzSWQgIT09IGNhbnZhc0lkO1xuXG4gICAgICAgIG1lLmNhbnZhc0lkID0gY2FudmFzSWQ7XG5cbiAgICAgICAgbWUud2FpdEZvckNhbnZhcyhjYW52YXNJZCwgd2luZG93SWQsIGhhc0NoYW5nZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIb29rIGZvciBzdWJjbGFzc2VzIHRvIGhhbmRsZSBtb3VzZSBjbGlja3MuXG4gICAgICogQ2FsbGVkIGJ5IGB1cGRhdGVNb3VzZVN0YXRlYCB3aGVuIGEgY2xpY2sgZXZlbnQgaXMgcmVjZWl2ZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbk1vdXNlQ2xpY2soZGF0YSkge31cblxuICAgIC8qKlxuICAgICAqIFBhdXNlcyB0aGUgc2ltdWxhdGlvbi5cbiAgICAgKiBUaGUgcmVuZGVyIGxvb3Agd2lsbCBleGl0IGVhcmx5IHdoaWxlIGBpc1BhdXNlZGAgaXMgdHJ1ZS5cbiAgICAgKi9cbiAgICBwYXVzZSgpIHtcbiAgICAgICAgdGhpcy5pc1BhdXNlZCA9IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBYnN0cmFjdCByZW5kZXIgbWV0aG9kLlxuICAgICAqIFN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gZHJhdyB0aGUgZnJhbWUuXG4gICAgICovXG4gICAgcmVuZGVyKCkge31cblxuICAgIC8qKlxuICAgICAqIFJlc3VtZXMgdGhlIHNpbXVsYXRpb24uXG4gICAgICogSWYgdGhlIHNpbXVsYXRpb24gd2FzIHBhdXNlZCwgdGhpcyByZXN0YXJ0cyB0aGUgcmVuZGVyIGxvb3AuXG4gICAgICovXG4gICAgcmVzdW1lKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5pc1BhdXNlZCkge1xuICAgICAgICAgICAgbWUuaXNQYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIG1lLnJlbmRlckxvb3AoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhwb3NlZCBtZXRob2QgZm9yIFJlbW90ZSBBY2Nlc3MgdG8gdHJpZ2dlciB0aGUgcmVhY3RpdmUgY29uZmlnIHNldHRlci5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cbiAgICBzZXRUaGVtZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnRoZW1lID0gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBsb2NhbCBtb3VzZSBzdGF0ZSBmcm9tIG1haW4gdGhyZWFkIGV2ZW50cy5cbiAgICAgKiBEZWxlZ2F0ZXMgY2xpY2sgZXZlbnRzIHRvIGBvbk1vdXNlQ2xpY2tgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZGF0YS5jbGlja11cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkYXRhLmxlYXZlXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZGF0YS54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZGF0YS55XVxuICAgICAqL1xuICAgIHVwZGF0ZU1vdXNlU3RhdGUoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChkYXRhLmxlYXZlKSB7XG4gICAgICAgICAgICBtZS5tb3VzZS54ID0gLTEwMDA7XG4gICAgICAgICAgICBtZS5tb3VzZS55ID0gLTEwMDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChkYXRhLnggIT09IHVuZGVmaW5lZCkgbWUubW91c2UueCA9IGRhdGEueDtcbiAgICAgICAgICAgIGlmIChkYXRhLnkgIT09IHVuZGVmaW5lZCkgbWUubW91c2UueSA9IGRhdGEueTtcblxuICAgICAgICAgICAgaWYgKGRhdGEuY2xpY2spIHtcbiAgICAgICAgICAgICAgICBtZS5vbk1vdXNlQ2xpY2soZGF0YSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGNhbnZhcyBzaXplIGFuZCByZXNpemVzIHRoZSBpbnRlcm5hbCBjb250ZXh0LlxuICAgICAqIFRyaWdnZXJzIGB1cGRhdGVSZXNvdXJjZXNgIGhvb2sgdG8gYWxsb3cgc3ViY2xhc3NlcyB0byByZWdlbmVyYXRlIGJ1ZmZlcnMvZ3JhZGllbnRzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzaXplXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNpemUuaGVpZ2h0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNpemUud2lkdGhcbiAgICAgKi9cbiAgICB1cGRhdGVTaXplKHNpemUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5jYW52YXNTaXplID0gc2l6ZTtcblxuICAgICAgICBpZiAobWUuY29udGV4dCkge1xuICAgICAgICAgICAgbWUuY29udGV4dC5jYW52YXMud2lkdGggID0gc2l6ZS53aWR0aDtcbiAgICAgICAgICAgIG1lLmNvbnRleHQuY2FudmFzLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICAgICAgICAgICAgLy8gQ2FsbHMgdGhlIGhvb2sgdG8gcmUtZ2VuZXJhdGUgcmVzb3VyY2VzIGlmIGltcGxlbWVudGVkXG4gICAgICAgICAgICBtZS51cGRhdGVSZXNvdXJjZXM/LihzaXplLndpZHRoLCBzaXplLmhlaWdodClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBvbGxzIGZvciB0aGUgT2Zmc2NyZWVuQ2FudmFzIHVudGlsIGl0IGlzIGF2YWlsYWJsZSBpbiB0aGUgV29ya2VyJ3MgYGNhbnZhc1dpbmRvd01hcGAuXG4gICAgICogT25jZSBmb3VuZCwgaXQgaW5pdGlhbGl6ZXMgdGhlIGNvbnRleHQgYW5kIHN0YXJ0cyB0aGUgcmVuZGVyIGxvb3AuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNhbnZhc0lkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHdpbmRvd0lkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBoYXNDaGFuZ2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgd2FpdEZvckNhbnZhcyhjYW52YXNJZCwgd2luZG93SWQsIGhhc0NoYW5nZSkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNhbnZhcyA9IE5lby5jdXJyZW50V29ya2VyLmNhbnZhc1dpbmRvd01hcFtjYW52YXNJZF0/Llt3aW5kb3dJZF07XG5cbiAgICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICAgICAgbWUuY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgICAgICAvLyBTdGFuZGFyZGl6ZSBzaXplIHVwZGF0ZVxuICAgICAgICAgICAgbWUudXBkYXRlU2l6ZSh7d2lkdGg6IGNhbnZhcy53aWR0aCwgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0fSk7XG5cbiAgICAgICAgICAgIC8vIE9wdGlvbmFsIGhvb2sgZm9yIHN1YmNsYXNzZXNcbiAgICAgICAgICAgIG1lLm9uR3JhcGhNb3VudGVkPy4oY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICAgICAgICAgICAgaWYgKGhhc0NoYW5nZSAmJiAhbWUuYW5pbWF0aW9uSWQpIHtcbiAgICAgICAgICAgICAgICBtZS5yZW5kZXJMb29wKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQobWUud2FpdEZvckNhbnZhcy5iaW5kKG1lLCBjYW52YXNJZCwgd2luZG93SWQsIGhhc0NoYW5nZSksIDUwKVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhCYXNlKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==