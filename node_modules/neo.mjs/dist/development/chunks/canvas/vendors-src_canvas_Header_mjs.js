export const __webpack_esm_id__ = "vendors-src_canvas_Header_mjs";
export const __webpack_esm_ids__ = ["vendors-src_canvas_Header_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./src/canvas/Base.mjs"
/*!*****************************!*\
  !*** ./src/canvas/Base.mjs ***!
  \*****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @summary Abstract base class for Canvas Renderers.
 *
 * This class serves as the foundation for the specialized canvas visualizations (Header, Home, Services, Ticket)
 * that run within the **Neo.mjs Canvas SharedWorker**.
 *
 * It creates helper singletons that manage their own `OffscreenCanvas` instances, providing a standardized
 * architecture for:
 * - **Lifecycle Management:** Initialization (`initGraph`), destruction (`clearGraph`), and resource cleanup.
 * - **Render Loop Control:** Unified `render` loop with pause/resume capabilities and frame scheduling.
 * - **Context Management:** Robust handling of `OffscreenCanvas` transfer and context acquisition via `waitForCanvas`.
 * - **Shared State:** Common state management for mouse interaction, time, and theming.
 *
 * These renderers operate off the main thread to ensure high-performance, 60fps animations without
 * blocking the UI.
 *
 * @class Neo.canvas.Base
 * @extends Neo.core.Base
 */
class Base extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.canvas.Base'
         * @protected
         */
        className: 'Neo.canvas.Base',
        /**
         * Remote method access
         * @member {Object} remote
         * @protected
         */
        remote: {
            app: [
                'clearGraph',
                'initGraph',
                'pause',
                'resume',
                'setTheme',
                'updateMouseState',
                'updateSize'
            ]
        },
        /**
         * The active color theme ('light' or 'dark').
         * @member {String} theme_='light'
         * @reactive
         */
        theme_: 'light'
    }

    /**
     * @member {Number|null} animationId=null
     */
    animationId = null
    /**
     * @member {String|null} canvasId=null
     */
    canvasId = null
    /**
     * @member {Object|null} canvasSize=null
     */
    canvasSize = null
    /**
     * @member {OffscreenCanvasRenderingContext2D|null} context=null
     */
    context = null
    /**
     * Cache for reusable gradients to prevent GC.
     * @member {Object} gradients={}
     */
    gradients = {}
    /**
     * Flag to pause the render loop.
     * @member {Boolean} isPaused=false
     */
    isPaused = false
    /**
     * Tracked mouse position for interactive physics.
     * Initialize off-screen to prevent startup jitters.
     * @member {Object} mouse={x: -1000, y: -1000}
     */
    mouse = {x: -1000, y: -1000}
    /**
     * Global simulation time.
     * @member {Number} time=0
     */
    time = 0

    /**
     * @member {Function} renderLoop=this.render.bind(this)
     */
    renderLoop = this.render.bind(this)

    /**
     * Triggered after the `theme` config is changed.
     * Updates the resource cache (gradients, colors) to reflect the new theme immediately.
     * @param {String} value
     * @param {String} oldValue
     */
    afterSetTheme(value, oldValue) {
        if (value && this.canvasSize) {
            this.updateResources?.(this.canvasSize.width, this.canvasSize.height)
        }
    }

    /**
     * Checks if the canvas is ready to render.
     * Returns true only if the context exists and the simulation is not paused.
     * Subclasses should call this at the start of their `render` loop.
     * @returns {Boolean}
     */
    get canRender() {
        let me = this;
        return !!(me.context && !me.isPaused)
    }

    /**
     * Clears the graph state and stops the render loop.
     * Use this to cleanup resources when the component is destroyed or unmounted.
     */
    clearGraph() {
        let me = this;
        me.context     = null;
        me.canvasId    = null;
        me.canvasSize  = null;
        me.animationId = null;
        me.isPaused    = false;
        me.gradients   = {};
        me.mouse       = {x: -1000, y: -1000};
        me.time        = 0
    }

    /**
     * Initializes the canvas context.
     * Starts the polling mechanism to wait for the OffscreenCanvas transfer from the Main Thread.
     * @param {Object} opts
     * @param {String} opts.canvasId
     * @param {String} opts.windowId
     */
    initGraph({canvasId, windowId}) {
        let me        = this,
            hasChange = me.canvasId !== canvasId;

        me.canvasId = canvasId;

        me.waitForCanvas(canvasId, windowId, hasChange)
    }

    /**
     * Hook for subclasses to handle mouse clicks.
     * Called by `updateMouseState` when a click event is received.
     * @param {Object} data
     */
    onMouseClick(data) {}

    /**
     * Pauses the simulation.
     * The render loop will exit early while `isPaused` is true.
     */
    pause() {
        this.isPaused = true
    }

    /**
     * Abstract render method.
     * Subclasses must implement this method to draw the frame.
     */
    render() {}

    /**
     * Resumes the simulation.
     * If the simulation was paused, this restarts the render loop.
     */
    resume() {
        let me = this;

        if (me.isPaused) {
            me.isPaused = false;
            me.renderLoop()
        }
    }

    /**
     * Exposed method for Remote Access to trigger the reactive config setter.
     * @param {String} value
     */
    setTheme(value) {
        this.theme = value
    }

    /**
     * Updates the local mouse state from main thread events.
     * Delegates click events to `onMouseClick`.
     * @param {Object} data
     * @param {Boolean} [data.click]
     * @param {Boolean} [data.leave]
     * @param {Number} [data.x]
     * @param {Number} [data.y]
     */
    updateMouseState(data) {
        let me = this;

        if (data.leave) {
            me.mouse.x = -1000;
            me.mouse.y = -1000
        } else {
            if (data.x !== undefined) me.mouse.x = data.x;
            if (data.y !== undefined) me.mouse.y = data.y;

            if (data.click) {
                me.onMouseClick(data)
            }
        }
    }

    /**
     * Updates the canvas size and resizes the internal context.
     * Triggers `updateResources` hook to allow subclasses to regenerate buffers/gradients.
     * @param {Object} size
     * @param {Number} size.height
     * @param {Number} size.width
     */
    updateSize(size) {
        let me = this;

        me.canvasSize = size;

        if (me.context) {
            me.context.canvas.width  = size.width;
            me.context.canvas.height = size.height;
            // Calls the hook to re-generate resources if implemented
            me.updateResources?.(size.width, size.height)
        }
    }

    /**
     * Polls for the OffscreenCanvas until it is available in the Worker's `canvasWindowMap`.
     * Once found, it initializes the context and starts the render loop.
     * @param {String} canvasId
     * @param {String} windowId
     * @param {Boolean} hasChange
     * @protected
     */
    waitForCanvas(canvasId, windowId, hasChange) {
        let me     = this,
            canvas = Neo.currentWorker.canvasWindowMap[canvasId]?.[windowId];

        if (canvas) {
            me.context = canvas.getContext('2d');

            // Standardize size update
            me.updateSize({width: canvas.width, height: canvas.height});

            // Optional hook for subclasses
            me.onGraphMounted?.(canvas.width, canvas.height);

            if (hasChange && !me.animationId) {
                me.renderLoop()
            }
        } else {
            setTimeout(me.waitForCanvas.bind(me, canvasId, windowId, hasChange), 50)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Base));


/***/ },

/***/ "./src/canvas/Header.mjs"
/*!*******************************!*\
  !*** ./src/canvas/Header.mjs ***!
  \*******************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/canvas/Base.mjs");


const
    hasRaf    = typeof requestAnimationFrame === 'function',
    PRIMARY   = '#3E63DD',
    SECONDARY = '#536DFE',
    HIGHLIGHT = '#00BFFF';

/**
 * @summary SharedWorker renderer for the HeaderToolbar overlay.
 *
 * Implements the **"Luminous Flux"** visual theme, an ambient, interactive energy simulation that
 * serves as the backdrop for the Portal header.
 *
 * **Visual Architecture:**
 * 1. **Neo Ether (Background):** A volumetric particle field composed of faint "dust" and larger "nebula" orbs.
 *    This provides atmospheric depth, fluid interactivity (mouse repulsion), and bridges the contrast gap
 *    between the white background and the foreground elements.
 * 2. **Ambient Helix (Midground):** A large-scale, slow-moving sine wave pattern that provides structural
 *    texture to the negative space. Now enhanced with a **volumetric Ribbon fill** to add depth.
 * 3. **Split Stream (Foreground):** Two intertwined energy strands (Helix/DNA) that flow across the canvas.
 *    - **3D Ribbon Effect:** A subtle gradient fills the space between strands, simulating a twisting surface.
  *   - **Neon Tube Effect:** Strands are rendered with a bright white core inside a colored glow, creating a physical light-emitting look.
  *   - **Adaptive Geometry:** The strands flow loosely around text buttons but tighten into a "high-gravity orbit"
  *     around social icons.
  *   - **Energy Surge (Active State):** The segment of the stream passing through the active navigation item
  *     is rendered with a high-intensity white glow and a nervous pulse, semantically highlighting the current view.
  *   - **Preview Glow (Hover State):** A static, high-contrast glow highlights the item under the cursor,
  *     providing immediate, distinct feedback separate from the active state.
  *
  * **Performance Architecture (Zero-Allocation):**
 * To maintain 60fps on high-refresh displays without GC stutters, this class employs a **Zero-Allocation** strategy during the render loop.
 * 1. **TypedArray Buffers:** Wave geometry is stored in pre-allocated `Float32Array` buffers (`waveBuffers`), reused every frame.
 * 2. **Gradient Caching:** CanvasGradients are created only on resize (`updateResources`) and cached, avoiding expensive generator calls per frame.
 * 3. **Reusable Objects:** Physics calculations write directly to buffers instead of returning new Arrays of Objects.
 *
 * @class Neo.canvas.Header
 * @extends Neo.canvas.Base
 * @singleton
 * @see Portal.view.HeaderCanvas
 */
class Header extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static colors = {
        dark : {
            background   : ['rgba(62, 99, 221, 0.1)', 'rgba(64, 196, 255, 0.2)', 'rgba(62, 99, 221, 0.1)'],
            background2  : ['rgba(139, 166, 255, 0.1)', 'rgba(64, 196, 255, 0.2)', 'rgba(139, 166, 255, 0.1)'],
            bgRibbon     : ['rgba(62, 99, 221, 0.02)', 'rgba(64, 196, 255, 0.05)', 'rgba(62, 99, 221, 0.02)'],
            fgRibbon     : ['rgba(62, 99, 221, 0.025)', 'rgba(64, 196, 255, 0.05)', 'rgba(62, 99, 221, 0.025)'],
            grad1        : [PRIMARY, HIGHLIGHT, PRIMARY],
            grad1Hot     : [HIGHLIGHT, '#FFFFFF', HIGHLIGHT],
            grad2        : [SECONDARY, HIGHLIGHT, SECONDARY],
            grad2Hot     : [HIGHLIGHT, '#FFFFFF', HIGHLIGHT],
            hover        : HIGHLIGHT,
            particle     : HIGHLIGHT,
            particleAlpha: {nebula: 0.2, dust: 0.2},
            shockwave    : HIGHLIGHT
        },
        light: {
            background   : ['rgba(62, 99, 221, 0.1)', 'rgba(64, 196, 255, 0.2)', 'rgba(62, 99, 221, 0.1)'],
            background2  : ['rgba(139, 166, 255, 0.1)', 'rgba(64, 196, 255, 0.2)', 'rgba(139, 166, 255, 0.1)'],
            bgRibbon     : ['rgba(62, 99, 221, 0.02)', 'rgba(64, 196, 255, 0.05)', 'rgba(62, 99, 221, 0.02)'],
            fgRibbon     : ['rgba(62, 99, 221, 0.05)', 'rgba(64, 196, 255, 0.1)', 'rgba(62, 99, 221, 0.05)'],
            grad1        : [PRIMARY, HIGHLIGHT, PRIMARY],
            grad1Hot     : [HIGHLIGHT, '#FFFFFF', HIGHLIGHT],
            grad2        : [SECONDARY, HIGHLIGHT, SECONDARY],
            grad2Hot     : [HIGHLIGHT, '#FFFFFF', HIGHLIGHT],
            hover        : PRIMARY,
            particle     : HIGHLIGHT,
            particleAlpha: {nebula: 0.2, dust: 0.2},
            shockwave    : HIGHLIGHT
        }
    }

    static config = {
        /**
         * @member {String} className='Neo.canvas.Header'
         * @protected
         */
        className: 'Neo.canvas.Header',
        /**
         * Remote method access
         * @member {Object} remote
         * @protected
         */
        remote: {
            app: [
                'updateActiveId',
                'updateConfig',
                'updateGraphData',
                'updateHoverId',
                'updateNavRects',
                'updateTimeScale'
            ]
        },
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * @member {String|null} activeId=null
     */
    activeId = null
    /**
     * @member {Number} avgFrameTime=16
     */
    avgFrameTime = 16
    /**
     * @member {String|null} hoverId=null
     */
    hoverId = null
    /**
     * @member {Number} lastFrameTime=0
     */
    lastFrameTime = 0
    /**
     * @member {Object[]} navRects=[]
     */
    navRects = []
    /**
     * @member {Object[]} particles=[]
     */
    particles = []
    /**
     * @member {Object[]} shockwaves=[]
     */
    shockwaves = []
    /**
     * @member {Number} targetTimeScale=1
     */
    targetTimeScale = 1
    /**
     * @member {Number} timeScale=1
     */
    timeScale = 1
    /**
     * @member {Boolean} usePulse=true
     */
    usePulse = true
    /**
     * Pre-allocated buffers for wave geometry.
     * Uses `Float32Array` to eliminate Garbage Collection pressure during the render loop.
     * @member {Object} waveBuffers={bgA: null, bgB: null, fgA: null, fgB: null}
     */
    waveBuffers = {bgA: null, bgB: null, fgA: null, fgB: null}

    /**
     * Clears the graph state and stops the render loop.
     */
    clearGraph() {
        let me = this;
        super.clearGraph();
        me.navRects    = [];
        me.particles   = [];
        me.shockwaves  = [];
        me.waveBuffers = {bgA: null, bgB: null, fgA: null, fgB: null}
    }

    /**
     * Hook to initialize particles after context is ready
     * @param {Number} width
     * @param {Number} height
     */
    onGraphMounted(width, height) {
        this.initParticles(width, height)
    }

    /**
     * Initializes the particle system for the "Neo Ether" effect.
     *
     * Creates a mix of large, slow-moving "nebula" particles and smaller, faster "dust" particles
     * to create depth and atmosphere.
     *
     * @param {Number} width
     * @param {Number} height
     */
    initParticles(width, height) {
        let me = this;
        me.particles = [];
        const
            count       = 60,
            themeColors = me.constructor.colors[me.theme],
            alphas      = themeColors.particleAlpha;

        for (let i = 0; i < count; i++) {
            let isNebula = Math.random() > 0.8; // 20% are large nebula orbs

            me.particles.push({
                isNebula,
                x        : Math.random() * width,
                y        : Math.random() * height,
                vx       : isNebula ? (Math.random() * 0.2 + 0.05) : (Math.random() * 0.5 + 0.1), // Nebulae move slower
                vy       : (Math.random() - 0.5) * 0.2,
                size     : isNebula ? (Math.random() * 30 + 20) : (Math.random() * 2 + 0.5), // Large vs Small
                alpha    : isNebula ? (Math.random() * 0.15 + alphas.nebula) : (Math.random() * 0.4 + alphas.dust),
                baseAlpha: isNebula ? (Math.random() * 0.15 + alphas.nebula) : (Math.random() * 0.4 + alphas.dust)
            })
        }
    }

    /**
     * Main render loop.
     *
     * Orchestrates the rendering of all visual layers:
     * 1. Ambient Background (Ribbon + Helix)
     * 2. Neo Ether (Particles)
     * 3. Split Stream (Foreground Auras)
     * 4. Shockwaves (Interaction)
     *
     * Uses `setTimeout` instead of `requestAnimationFrame` because this runs in a SharedWorker
     * where `rAF` is not available. Targets ~60fps (16ms).
     */
    render() {
        let me = this;

        if (!me.canRender) {
            return
        }

        const
            ctx    = me.context,
            width  = me.canvasSize?.width  || 100,
            height = me.canvasSize?.height || 50,
            now    = performance.now();

        // 0. Performance Monitoring (Adaptive Backpressure)
        if (me.lastFrameTime > 0) {
            let delta = now - me.lastFrameTime;

            // Only update average if delta is sanity-checked (ignore tab suspension pauses)
            if (delta < 500) {
                // Exponential Moving Average (alpha = 0.05 for smooth stability)
                me.avgFrameTime = (me.avgFrameTime * 0.95) + (delta * 0.05);
            }
        }
        me.lastFrameTime = now;

        // Smooth transition for timeScale
        if (me.timeScale !== me.targetTimeScale) {
            let diff = me.targetTimeScale - me.timeScale;
            if (Math.abs(diff) < 0.01) {
                me.timeScale = me.targetTimeScale
            } else {
                me.timeScale += diff * 0.05 // Ease-out
            }
        }

        // If animations are enabled, use dynamic timeScale (1x to 2x).
        // If disabled, use a fixed "Reduced Motion" drift (0.2x).
        let speed = me.usePulse ? me.timeScale : 0.2;

        me.time += 0.05 * speed;

        // Auto-reinit particles if size changes significantly or empty OR count mismatch (config update)
        if (me.particles.length !== 60) {
            me.initParticles(width, height)
        }

        ctx.clearRect(0, 0, width, height);

        // 1. Draw Ambient Background
        me.drawAmbientBackground(ctx, width, height);

        // 2. Draw Ether Particles (Background Layer)
        me.drawParticles(ctx, width, height);

        // 3. Draw "Auras" (Hover Effects) => 3D Ribbon + Neon Tube
        // Backpressure: If we are dropping frames (> 32ms), disable the hot overlay
        const isStressed = me.avgFrameTime > 32;
        me.drawAuras(ctx, width, height, isStressed);

        // 3b. Draw Active Overlay
        me.drawActiveOverlay(ctx, width);

        // 3c. Draw Hover Overlay
        me.drawHoverOverlay(ctx, width);

        // 4. Draw "Shockwaves" (Click Effects)
        me.drawShockwaves(ctx, width);

        if (hasRaf) {
            me.animationId = requestAnimationFrame(me.renderLoop)
        } else {
            me.animationId = setTimeout(me.renderLoop, 1000 / 60)
        }
    }

    /**
     * @param {Object} data
     * @param {Number} data.value
     */
    updateTimeScale(data) {
        this.targetTimeScale = data.value
    }

    /**
     * Calculates the points for the two energy strands based on physics and interaction.
     *
     * **Zero-Allocation Contract:**
     * This method writes directly to the pre-allocated `this.waveBuffers` `Float32Array`s.
     * It does **not** allocate new arrays or objects, ensuring zero GC pressure.
     *
     * @param {Number} width
     * @param {Number} height
     * @returns {Object} {shimmerA, shimmerB, count} Metadata for rendering (scalars only)
     */
    calculateStrandGeometry(width, height) {
        let me = this;

        if (!Array.isArray(me.navRects) || !me.waveBuffers.fgA) {
            return null
        }

        const
            bufA    = me.waveBuffers.fgA,
            bufB    = me.waveBuffers.fgB,
            step    = 2,
            count   = Math.ceil(width / step),
            centerY = height / 2,
            padding = 10,
            maxH    = (height - (padding * 2)) / 2,
            // BREATHING: Modulate base amplitude over time (slow pulse)
            breath   = Math.sin(me.time * 0.5) * 2,
            baseAmp  = Math.min(6 + breath, maxH),
            hoverAmp = 4;

        // REF 1: Linked Phase - Shimmer leads Breath by 90deg ("Charging up")
        let baseShimmer = 0.75 + (Math.sin(me.time * 0.5 + Math.PI / 2) * 0.25);

        // REF 2: Independent Strand Shimmer
        let shimmerA = baseShimmer,
            shimmerB = 0.75 + (Math.sin(me.time * 0.5 + Math.PI / 2 + Math.PI / 3) * 0.25);

        for (let i = 0; i < count; i++) {
            let x = i * step,
                {offsetY, intensity, isIconZone} = me.getStreamOffset(x, height, width);

            // FREQUENCY MODULATION:
            let freqMod   = Math.sin(x * 0.002 + me.time * 0.1) * (20 + (intensity * 10)),
                timeShift = me.time * 2;

            // DAMPING FOR ICONS:
            let localAmp = baseAmp * (1 - (isIconZone * 0.6));

            // Noise Calculation
            // We calculate noise once per frame per point to ensure that the Ribbon Fill and
            // Neon Stroke passes use identical geometry, preventing visual tearing.
            let noiseA = (Math.random() - 0.5) * hoverAmp * intensity,
                noiseB = (Math.random() - 0.5) * hoverAmp * intensity,
                sine   = Math.sin(((x + freqMod) * 0.04) - timeShift) * localAmp,
                sineB  = Math.sin(((x + freqMod) * 0.04) - timeShift + Math.PI) * localAmp; // Inverted

            // SHOCKWAVE PHYSICS (Displacement)
            let shockY = 0;
            if (me.shockwaves.length > 0) {
                me.shockwaves.forEach(wave => {
                    let radius = wave.age * wave.speed,
                        dist   = x - wave.x; // Signed distance

                    // Check if point is near the wave front (e.g. within 50px)
                    if (Math.abs(dist) < radius && Math.abs(dist) > radius - 60) {
                        // Pulse shape: Sine wave based on distance from center relative to radius
                        let pulse = Math.sin((dist / radius) * Math.PI * 10) * (1 - (wave.age / wave.life)) * 20;
                        shockY += pulse
                    }
                })
            }

            // Write Y values to buffers
            bufA[i] = centerY + sine  - offsetY + noiseA + shockY;
            bufB[i] = centerY + sineB + offsetY + noiseB + shockY;
        }

        return {shimmerA, shimmerB, count}
    }

    /**
     * Draws the "Ether" particle field to add volumetric depth and interactivity.
     *
     * **Intent:**
     * Creates a living, breathing atmosphere ("Neo Ether") that fills the negative space.
     * This bridges the visual gap between the stark white background and the high-contrast foreground lines.
     *
     * **Physics:**
     * - **Drift:** Particles move with a constant `vx` to simulate data flow or wind.
     * - **Repulsion:** The mouse cursor acts as a "repulsor field," pushing particles away and brightening them
     *   to create a "hole" in the fog.
     * - **Nebulae:** Large, faint particles create a "fog" effect, while small, bright particles act as "dust."
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {Number} width
     * @param {Number} height
     */
    drawParticles(ctx, width, height) {
        let me = this;

        const
            themeColors = me.constructor.colors[me.theme],
            pColor      = themeColors.particle;

        me.particles.forEach(p => {
            // Update Position
            p.x += p.vx;
            p.y += p.vy;

            // Wrap around
            if (p.x > width + p.size)  p.x = -p.size;
            if (p.x < -p.size)         p.x = width + p.size;
            if (p.y > height + p.size) p.y = -p.size;
            if (p.y < -p.size)         p.y = height + p.size;

            // Interaction: Mouse Repulsion
            // All particles react to the mouse, but "Nebula" particles have higher calculated mass,
            // resulting in less displacement than the lighter "Dust" particles.
            let dx = p.x - me.mouse.x,
                dy = p.y - me.mouse.y,
                dist = Math.sqrt(dx*dx + dy*dy),
                maxDist = p.isNebula ? 150 : 100;

            if (dist < maxDist && dist > 0) {
                let force = (maxDist - dist) / maxDist;
                // Push away
                let mass = p.isNebula ? 5 : 1;
                p.x += (dx / dist) * force * (2 / mass);
                p.y += (dy / dist) * force * (2 / mass);
                // Brighten slightly
                p.alpha = Math.min(p.baseAlpha + force * (p.isNebula ? 0.05 : 0.5), 0.8);
            }

            // Interaction: Shockwave Repulsion
            if (me.shockwaves.length > 0) {
                me.shockwaves.forEach(wave => {
                    let wx     = p.x - wave.x,
                        wy     = p.y - wave.y,
                        wDist  = Math.sqrt(wx * wx + wy * wy),
                        radius = wave.age * wave.speed;

                    // If particle is near the expanding ring (width 40px)
                    if (wDist < radius && wDist > radius - 40) {
                        let force = (1 - (wave.age / wave.life)) * 2; // Decay force over time
                        // Push outward
                        p.x += (wx / wDist) * force * 5;
                        p.y += (wy / wDist) * force * 5;
                        p.alpha = Math.min(p.alpha + 0.3, 1) // Flash bright
                    }
                })
            }

            // Return to base alpha
            if (p.alpha > p.baseAlpha) {
                p.alpha -= 0.005
            }

            ctx.globalAlpha = p.alpha;
            ctx.beginPath();

            if (p.isNebula) {
                // Nebula Visualization
                // Use a radial gradient to create a soft, cloud-like appearance.
                let g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
                g.addColorStop(0, pColor);
                g.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = g;
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill()
            } else {
                ctx.fillStyle = pColor;
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill()
            }
        });

        ctx.globalAlpha = 1
    }

    /**
     * Draws an additional highlight for the active navigation item.
     * **"Energy Surge" Effect:**
     * Renders a high-intensity pass of the energy strands *only* within the active zone.
     * This makes the lines appear to "power up" or glow white-hot as they pass through the active view,
     * fully integrated with the existing geometry.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {Number} width
     */
    drawActiveOverlay(ctx, width) {
        let me = this,
            rect;

        if (!me.activeId || !me.waveBuffers.fgA) return;

        // Zero-Allocation: Use for-loop instead of .find() to avoid closure creation
        for (const r of me.navRects) {
            if (r.id === me.activeId) {
                rect = r;
                break
            }
        }

        if (!rect) return;

        const
            step   = 2, // Must match calculateStrandGeometry
            // Add padding to fade the effect in/out smoothly
            pad    = 10,
            startX = Math.max(0, rect.x - pad),
            endX   = Math.min(width, rect.x + rect.width + pad),
            startI = Math.floor(startX / step),
            endI   = Math.ceil(endX / step),
            bufA   = me.waveBuffers.fgA,
            bufB   = me.waveBuffers.fgB;

        ctx.save();
        ctx.lineCap  = 'round';
        ctx.lineJoin = 'round';

        // High-Intensity Glow
        ctx.shadowBlur  = 20;
        ctx.shadowColor = '#FFFFFF'; // White glow
        ctx.strokeStyle = '#FFFFFF'; // White core
        ctx.lineWidth   = 2;

        // Gradient Fade mask (manual alpha)
        // We can't easily gradient-stroke a sub-path, so we rely on globalAlpha
        // combined with the "hot" white color to make it pop.
        ctx.globalAlpha = 0.6 + (Math.sin(me.time * 3) * 0.2); // Fast, nervous pulse

        // Inline drawing to avoid closure
        ctx.beginPath();
        ctx.moveTo(startI * step, bufA[startI]);
        for (let i = startI + 1; i <= endI; i++) {
            ctx.lineTo(i * step, bufA[i])
        }
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(startI * step, bufB[startI]);
        for (let i = startI + 1; i <= endI; i++) {
            ctx.lineTo(i * step, bufB[i])
        }
        ctx.stroke();

        ctx.restore()
    }

    /**
     * Draws an additional highlight for the hovered navigation item.
     * **"Preview" Effect:**
     * Renders a static intensity pass of the energy strands within the hovered zone.
     * Uses the theme-specific hover color (Cyan/Blue) to distinguish it from the active state (White).
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {Number} width
     */
    drawHoverOverlay(ctx, width) {
        let me = this,
            rect;

        if (!me.hoverId || !me.waveBuffers.fgA) return;

        // Zero-Allocation: Use for-loop instead of .find() to avoid closure creation
        for (const r of me.navRects) {
            if (r.id === me.hoverId) {
                rect = r;
                break
            }
        }

        if (!rect) return;

        const
            step        = 2, // Must match calculateStrandGeometry
            pad         = 10,
            startX      = Math.max(0, rect.x - pad),
            endX        = Math.min(width - 3, rect.x + rect.width + pad),
            startI      = Math.floor(startX / step),
            endI        = Math.ceil(endX / step),
            bufA        = me.waveBuffers.fgA,
            bufB        = me.waveBuffers.fgB,
            themeColors = me.constructor.colors[me.theme];

        ctx.save();
        ctx.lineCap  = 'round';
        ctx.lineJoin = 'round';

        // Hover Effect: Static Glow (No Pulse)
        ctx.shadowBlur  = 15;
        ctx.shadowColor = themeColors.hover;
        ctx.strokeStyle = themeColors.hover;
        ctx.lineWidth   = 2;
        ctx.globalAlpha = 1;

        // Inline drawing to avoid closure
        ctx.beginPath();
        ctx.moveTo(startI * step, bufA[startI]);
        for (let i = startI + 1; i <= endI; i++) {
            ctx.lineTo(i * step, bufA[i])
        }
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(startI * step, bufB[startI]);
        for (let i = startI + 1; i <= endI; i++) {
            ctx.lineTo(i * step, bufB[i])
        }
        ctx.stroke();

        ctx.restore()
    }

    /**
     * Draws a subtle, large-scale background Helix pattern with a 3D Ribbon effect.
     *
     * **Intent:**
     * Provides a structural backbone to the negative space. Unlike the particle field (which is chaotic),
     * this layer is ordered and rhythmic, reinforcing the "DNA/Helix" theme even in the background.
     *
     * **Visuals:**
     * 1. **Ribbon Fill:** A barely-visible volumetric gradient fills the space between the helices.
     * 2. **Depth of Field:** Uses wide, very low opacity strokes to appear "out of focus" behind the sharp foreground.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {Number} width
     * @param {Number} height
     */
    drawAmbientBackground(ctx, width, height) {
        let me = this;

        // Ensure buffers exist
        if (!me.waveBuffers.bgA) return;

        let t       = me.time * 0.5,
            centerY = height / 2,
            amp     = height * 0.4,
            step    = 10,
            count   = Math.ceil(width / step),
            bufA    = me.waveBuffers.bgA,
            bufB    = me.waveBuffers.bgB;

        // 1. Calculate Points (Direct to Buffer)
        for (let i = 0; i < count; i++) {
            let x = i * step;
            bufA[i] = centerY + Math.sin((x * 0.01) + t) * amp;
            bufB[i] = centerY + Math.sin((x * 0.01) + t + Math.PI) * amp
        }

        // --- 2. RIBBON FILL (Background Surface) ---
        ctx.fillStyle = me.gradients.bgRibbon;
        ctx.beginPath();

        ctx.moveTo(0, bufA[0]);
        for (let i = 1; i < count; i++) {
            ctx.lineTo(i * step, bufA[i])
        }

        for (let i = count - 1; i >= 0; i--) {
            ctx.lineTo(i * step, bufB[i])
        }
        ctx.closePath();
        ctx.fill();

        // --- 3. STROKES ---
        ctx.lineWidth = 15;
        ctx.lineCap   = 'round';
        ctx.lineJoin  = 'round';

        // Use cached gradients
        const drawStroke = (buffer, strokeStyle) => {
            ctx.strokeStyle = strokeStyle;
            ctx.beginPath();
            ctx.moveTo(0, buffer[0]);
            for (let i = 1; i < count; i++) {
                ctx.lineTo(i * step, buffer[i])
            }
            ctx.stroke()
        };

        drawStroke(bufA, me.gradients.bgGrad1);
        drawStroke(bufB, me.gradients.bgGrad2);
    }

    /**
     * Draws the main foreground "Split Stream" energy strands with 3D effects.
     *
     * **3D Architecture:**
     * 1. **Ribbon Fill:** Draws a low-opacity gradient between Strand A and Strand B, creating a twisting surface.
     * 2. **Neon Tube (Outer):** The colored glow of the strands.
     * 3. **Neon Tube (Core):** A bright white inner core to simulate volumetric light.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {Number} width
     * @param {Number} height
     * @param {Boolean} [isStressed=false]
     */
    drawAuras(ctx, width, height, isStressed=false) {
        let me = this;

        if (!Array.isArray(me.navRects)) return;

        // 1. Calculate Physics (Shared for Ribbon and Strands) - Returns metadata, data is in buffers
        const geometry = me.calculateStrandGeometry(width, height);

        if (!geometry) return;

        const
            {shimmerA, shimmerB, count} = geometry,
            bufA        = me.waveBuffers.fgA,
            bufB        = me.waveBuffers.fgB,
            step        = 2,
            themeColors = me.constructor.colors[me.theme];

        // --- 2. RIBBON FILL (The 3D Surface) ---
        ctx.fillStyle = me.gradients.fgRibbon;
        ctx.beginPath();

        ctx.moveTo(0, bufA[0]);
        for (let i = 1; i < count; i++) {
            ctx.lineTo(i * step, bufA[i]);
        }

        for (let i = count - 1; i >= 0; i--) {
            ctx.lineTo(i * step, bufB[i]);
        }
        ctx.closePath();
        ctx.fill();

        // --- 3. NEON STRANDS (Tube Effect) ---

        ctx.lineCap     = 'round';
        ctx.lineJoin    = 'round';

        // Helper to draw a strand from buffer
        const drawStrand = (buffer, gradient, shimmer, color, isCore, overlayGradient, heat) => {
            ctx.beginPath();
            ctx.strokeStyle = isCore ? '#FFFFFF' : gradient;
            ctx.lineWidth   = isCore ? 1 : 3;
            ctx.globalAlpha = isCore ? (shimmer + 0.2) : shimmer;

            if (!isCore) {
                ctx.shadowBlur  = 10;
                ctx.shadowColor = color;
            } else {
                ctx.shadowBlur  = 0;
            }

            ctx.moveTo(0, buffer[0]);
            for (let i = 1; i < count; i++) {
                ctx.lineTo(i * step, buffer[i]);
            }
            ctx.stroke();

            // Hot Overlay Pass
            if (!isCore && heat > 0.05 && overlayGradient) {
                ctx.beginPath();
                ctx.strokeStyle = overlayGradient;
                ctx.lineWidth   = 3;
                ctx.globalAlpha = heat; // Fade in based on scroll speed
                ctx.shadowBlur  = 20;   // Hotter glow
                ctx.shadowColor = '#FFFFFF';

                ctx.moveTo(0, buffer[0]);
                for (let i = 1; i < count; i++) {
                    ctx.lineTo(i * step, buffer[i]);
                }
                ctx.stroke();
            }
        };

        // Draw Glows (Outer Tube)
        // Extract base color from gradient array for shadow
        const color1 = themeColors.grad1[0];
        const color2 = themeColors.grad2[0];
        // Disable heat if stressed OR if animations are globally disabled
        const heat   = (isStressed || !me.usePulse) ? 0 : Math.max(0, me.timeScale - 1);

        drawStrand(bufA, me.gradients.grad1, shimmerA, color1, false, me.gradients.grad1Hot, heat);
        drawStrand(bufB, me.gradients.grad2, shimmerB, color2, false, me.gradients.grad2Hot, heat);

        // Draw Cores (Inner Filament)
        drawStrand(bufA, null, shimmerA, null, true);
        drawStrand(bufB, null, shimmerB, null, true);

        // Cleanup: Reset shadow and alpha to prevent bleeding into the next render pass
        ctx.shadowBlur  = 0;
        ctx.globalAlpha = 1;
    }

    /**
     * Calculates the physics for diverting the stream around UI elements.
     *
     * **Logic:**
     * 1. **Detection:** Iterates through `navRects` to find if the current `x` is near a button.
     * 2. **Adaptive Geometry:**
     *    - **Text Buttons:** Uses a wide Cosine envelope for smooth flow.
     *    - **Icon Buttons:** Uses a sharp Cubed envelope (`Math.pow(x, 3)`) to create a "Tight Orbit" effect.
     * 3. **Vertical Clamping:** Ensures the diversion never pushes the wave off-canvas.
     *
     * @param {Number} x
     * @param {Number} height (Canvas height)
     * @param {Number} width (Canvas width)
     * @returns {Object} {offsetY, intensity, isIconZone}
     */
    getStreamOffset(x, height, width) {
        let me        = this,
            offsetY   = 0,
            intensity = 0, // 0 to 1 (Hover magnitude)
            isIconZone = 0; // 0 to 1 (Proximity to an Icon Button)

        const
            verticalPadding = 10,
            maxSafeOffset   = (height / 2) - verticalPadding;

        // Collision Detection
        // Iterate through all navigation items to determine stream diversion.
        // Given the low item count (<20), a simple linear scan is efficient.
        for (const rect of me.navRects) {
            // Buffer zone for smooth transition
            const buffer = 40;

            if (x >= rect.x - buffer && x <= rect.x + rect.width + buffer) {
                // We are inside the influence zone of this button

                // Shape Detection
                // Discriminate between square-ish icons (socials) and wide text buttons
                // to apply different diversion envelopes.
                const
                    ratio   = rect.width / rect.height,
                    isIcon  = ratio < 1.5, // Threshold for "Circle" vs "Rectangle"
                    centerX = rect.x + rect.width / 2,
                    span    = (rect.width / 2) + buffer,
                    distX   = Math.abs(x - centerX);

                if (distX < span) {
                    let envelope;

                    if (isIcon) {
                        // TIGHT ORBIT (Sharper curve for icons)
                        let normDist = distX / span; // 0 to 1
                        envelope = Math.pow((1 + Math.cos(Math.PI * normDist)) / 2, 3); // Cubed for sharper falloff
                        isIconZone = Math.max(isIconZone, envelope); // Track if we are in an icon zone
                    } else {
                        // WIDE FLOW (Standard smooth curve for text)
                        envelope = (1 + Math.cos(Math.PI * distX / span)) / 2;
                    }

                    // Diversion Amplitude
                    // Text buttons require more visual clearance than icons due to their
                    // rectangular nature. Icons allow for a tighter "orbit".
                    let targetH = isIcon ? (rect.height / 2) : ((rect.height / 2) + 4);

                    // Vertical Clamping
                    // Cap the offset to ensure the stream stays within the canvas bounds.
                    let targetOffset = Math.min(targetH, maxSafeOffset);

                    // Add to total offset (using max to handle overlaps cleanly)
                    offsetY = Math.max(offsetY, targetOffset * envelope);

                    // Interaction: Proximity Check
                    // Boost the wave intensity if the mouse is hovering over or near this specific button.

                    // Distance from mouse to button center
                    let dx = me.mouse.x - centerX,
                        dy = me.mouse.y - (rect.y + rect.height/2),
                        distMouse = Math.sqrt(dx*dx + dy*dy);

                    // If mouse is near this button, boost intensity
                    if (distMouse < Math.max(rect.width, rect.height)) {
                        intensity = Math.max(intensity, 1 - (distMouse / 150));
                    }
                }
            }
        }

        // Baseline Separation
        // By returning offsetY=0 in empty space, the strands will naturally cross (Helix effect)
        // driven by the sine wave logic in calculateStrandPoints.
        return {offsetY, intensity, isIconZone};
    }

    /**
     * Draws expanding shockwaves from clicks.
     * @param {CanvasRenderingContext2D} ctx
     * @param {Number} width
     */
    drawShockwaves(ctx, width) {
        let me = this;

        if (me.shockwaves.length === 0) return;

        const themeColors = me.constructor.colors[me.theme];

        for (let i = me.shockwaves.length - 1; i >= 0; i--) {
            let wave = me.shockwaves[i];

            wave.age += 1;

            let progress = wave.age / wave.life;

            if (progress >= 1) {
                me.shockwaves.splice(i, 1);
                continue
            }

            // Draw two lines propagating out from the click point
            let xLeft    = wave.x - (wave.speed * wave.age),
                xRight   = wave.x + (wave.speed * wave.age),
                alpha    = 1 - progress,
                {height} = me.canvasSize;

            ctx.beginPath();
            ctx.strokeStyle = themeColors.shockwave; // Use theme color
            ctx.globalAlpha = alpha;     // Fade out via globalAlpha
            ctx.lineWidth   = 4 * (1 - progress);

            // Left Wave
            if (xLeft > 0) {
                ctx.moveTo(xLeft, 0);
                ctx.quadraticCurveTo(xLeft - 20, height / 2, xLeft, height)
            }

            // Right Wave
            if (xRight < width) {
                ctx.moveTo(xRight, 0);
                ctx.quadraticCurveTo(xRight + 20, height / 2, xRight, height)
            }

            ctx.stroke();
            ctx.globalAlpha = 1 // Reset
        }
    }

    /**
     * @param {Object} data
     * @param {String} [data.id]
     */
    updateActiveId(data) {
        this.activeId = data?.id || null
    }

    /**
     * @param {Object} data
     */
    updateGraphData(data) {
        // Not used yet, but kept for interface consistency
    }

    /**
     * @param {Object} data
     * @param {String} [data.id]
     */
    updateHoverId(data) {
        this.hoverId = data?.id || null
    }

    /**
     * Hook to handle mouse clicks.
     * @param {Object} data
     */
    onMouseClick(data) {
        this.shockwaves.push({
            x    : data.x,
            y    : data.y,
            age  : 0,
            life : 60, // frames
            speed: 15  // px per frame
        })
    }

    /**
     * @param {Object} data
     */
    updateConfig(data) {
        this.set(data)
    }

    /**
     * @param {Object} data
     * @param {Number} [data.height]
     * @param {Object[]} data.rects
     * @param {Number} [data.width]
     */
    updateNavRects(data) {
        let rects = data?.rects;

        if (data.width !== undefined && data.height !== undefined) {
            this.updateSize(data)
        }

        if (Array.isArray(rects)) {
            this.navRects = rects
        } else {
            this.navRects = []
        }
    }

    /**
     * Creates and caches gradients and geometry buffers based on canvas size.
     * This eliminates per-frame allocation of TypedArrays and CanvasGradients.
     *
     * @param {Number} width
     * @param {Number} height
     */
    updateResources(width, height) {
        let me  = this,
            ctx = me.context;

        // 1. Re-allocate Buffers (Float32Array)
        // Background: step = 10
        const bgCount = Math.ceil(width / 10) + 1;
        me.waveBuffers.bgA = new Float32Array(bgCount);
        me.waveBuffers.bgB = new Float32Array(bgCount);

        // Foreground: step = 2
        const fgCount = Math.ceil(width / 2) + 1;
        me.waveBuffers.fgA = new Float32Array(fgCount);
        me.waveBuffers.fgB = new Float32Array(fgCount);

        // 2. Cache Gradients
        if (!ctx) return;

        const themeColors = me.constructor.colors[me.theme];

        // Foreground Gradients
        const grad1 = ctx.createLinearGradient(0, 0, width, 0);
        grad1.addColorStop(0,   themeColors.grad1[0]);
        grad1.addColorStop(0.5, themeColors.grad1[1]);
        grad1.addColorStop(1,   themeColors.grad1[2]);
        me.gradients.grad1 = grad1;

        const grad2 = ctx.createLinearGradient(0, 0, width, 0);
        grad2.addColorStop(0,   themeColors.grad2[0]);
        grad2.addColorStop(0.5, themeColors.grad2[1]);
        grad2.addColorStop(1,   themeColors.grad2[2]);
        me.gradients.grad2 = grad2;

        const grad1Hot = ctx.createLinearGradient(0, 0, width, 0);
        grad1Hot.addColorStop(0,   themeColors.grad1Hot[0]);
        grad1Hot.addColorStop(0.5, themeColors.grad1Hot[1]);
        grad1Hot.addColorStop(1,   themeColors.grad1Hot[2]);
        me.gradients.grad1Hot = grad1Hot;

        const grad2Hot = ctx.createLinearGradient(0, 0, width, 0);
        grad2Hot.addColorStop(0,   themeColors.grad2Hot[0]);
        grad2Hot.addColorStop(0.5, themeColors.grad2Hot[1]);
        grad2Hot.addColorStop(1,   themeColors.grad2Hot[2]);
        me.gradients.grad2Hot = grad2Hot;

        const fgRibbon = ctx.createLinearGradient(0, 0, width, 0);
        fgRibbon.addColorStop(0,   themeColors.fgRibbon[0]);
        fgRibbon.addColorStop(0.5, themeColors.fgRibbon[1]);
        fgRibbon.addColorStop(1,   themeColors.fgRibbon[2]);
        me.gradients.fgRibbon = fgRibbon;

        // Background Gradients
        const bgGrad1 = ctx.createLinearGradient(0, 0, width, 0);
        bgGrad1.addColorStop(0,   themeColors.background[0]);
        bgGrad1.addColorStop(0.5, themeColors.background[1]);
        bgGrad1.addColorStop(1,   themeColors.background[2]);
        me.gradients.bgGrad1 = bgGrad1;

        const bgGrad2 = ctx.createLinearGradient(0, 0, width, 0);
        bgGrad2.addColorStop(0,   themeColors.background2[0]);
        bgGrad2.addColorStop(0.5, themeColors.background2[1]);
        bgGrad2.addColorStop(1,   themeColors.background2[2]);
        me.gradients.bgGrad2 = bgGrad2;

        const bgRibbon = ctx.createLinearGradient(0, 0, width, 0);
        bgRibbon.addColorStop(0,   themeColors.bgRibbon[0]);
        bgRibbon.addColorStop(0.5, themeColors.bgRibbon[1]);
        bgRibbon.addColorStop(1,   themeColors.bgRibbon[2]);
        me.gradients.bgRibbon = bgRibbon;
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Header));



/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2NhbnZhcy92ZW5kb3JzLXNyY19jYW52YXNfSGVhZGVyX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNEQUFPO0FBQzFCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3Q0FBd0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUSxPQUFPO0FBQy9CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsc0JBQXNCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NhbnZhcy9CYXNlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NhbnZhcy9IZWFkZXIubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBOZW9CYXNlIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuXG4vKipcbiAqIEBzdW1tYXJ5IEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIENhbnZhcyBSZW5kZXJlcnMuXG4gKlxuICogVGhpcyBjbGFzcyBzZXJ2ZXMgYXMgdGhlIGZvdW5kYXRpb24gZm9yIHRoZSBzcGVjaWFsaXplZCBjYW52YXMgdmlzdWFsaXphdGlvbnMgKEhlYWRlciwgSG9tZSwgU2VydmljZXMsIFRpY2tldClcbiAqIHRoYXQgcnVuIHdpdGhpbiB0aGUgKipOZW8ubWpzIENhbnZhcyBTaGFyZWRXb3JrZXIqKi5cbiAqXG4gKiBJdCBjcmVhdGVzIGhlbHBlciBzaW5nbGV0b25zIHRoYXQgbWFuYWdlIHRoZWlyIG93biBgT2Zmc2NyZWVuQ2FudmFzYCBpbnN0YW5jZXMsIHByb3ZpZGluZyBhIHN0YW5kYXJkaXplZFxuICogYXJjaGl0ZWN0dXJlIGZvcjpcbiAqIC0gKipMaWZlY3ljbGUgTWFuYWdlbWVudDoqKiBJbml0aWFsaXphdGlvbiAoYGluaXRHcmFwaGApLCBkZXN0cnVjdGlvbiAoYGNsZWFyR3JhcGhgKSwgYW5kIHJlc291cmNlIGNsZWFudXAuXG4gKiAtICoqUmVuZGVyIExvb3AgQ29udHJvbDoqKiBVbmlmaWVkIGByZW5kZXJgIGxvb3Agd2l0aCBwYXVzZS9yZXN1bWUgY2FwYWJpbGl0aWVzIGFuZCBmcmFtZSBzY2hlZHVsaW5nLlxuICogLSAqKkNvbnRleHQgTWFuYWdlbWVudDoqKiBSb2J1c3QgaGFuZGxpbmcgb2YgYE9mZnNjcmVlbkNhbnZhc2AgdHJhbnNmZXIgYW5kIGNvbnRleHQgYWNxdWlzaXRpb24gdmlhIGB3YWl0Rm9yQ2FudmFzYC5cbiAqIC0gKipTaGFyZWQgU3RhdGU6KiogQ29tbW9uIHN0YXRlIG1hbmFnZW1lbnQgZm9yIG1vdXNlIGludGVyYWN0aW9uLCB0aW1lLCBhbmQgdGhlbWluZy5cbiAqXG4gKiBUaGVzZSByZW5kZXJlcnMgb3BlcmF0ZSBvZmYgdGhlIG1haW4gdGhyZWFkIHRvIGVuc3VyZSBoaWdoLXBlcmZvcm1hbmNlLCA2MGZwcyBhbmltYXRpb25zIHdpdGhvdXRcbiAqIGJsb2NraW5nIHRoZSBVSS5cbiAqXG4gKiBAY2xhc3MgTmVvLmNhbnZhcy5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIEJhc2UgZXh0ZW5kcyBOZW9CYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jYW52YXMuQmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNhbnZhcy5CYXNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW90ZSBtZXRob2QgYWNjZXNzXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gcmVtb3RlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHJlbW90ZToge1xuICAgICAgICAgICAgYXBwOiBbXG4gICAgICAgICAgICAgICAgJ2NsZWFyR3JhcGgnLFxuICAgICAgICAgICAgICAgICdpbml0R3JhcGgnLFxuICAgICAgICAgICAgICAgICdwYXVzZScsXG4gICAgICAgICAgICAgICAgJ3Jlc3VtZScsXG4gICAgICAgICAgICAgICAgJ3NldFRoZW1lJyxcbiAgICAgICAgICAgICAgICAndXBkYXRlTW91c2VTdGF0ZScsXG4gICAgICAgICAgICAgICAgJ3VwZGF0ZVNpemUnXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYWN0aXZlIGNvbG9yIHRoZW1lICgnbGlnaHQnIG9yICdkYXJrJykuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gdGhlbWVfPSdsaWdodCdcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB0aGVtZV86ICdsaWdodCdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gYW5pbWF0aW9uSWQ9bnVsbFxuICAgICAqL1xuICAgIGFuaW1hdGlvbklkID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBjYW52YXNJZD1udWxsXG4gICAgICovXG4gICAgY2FudmFzSWQgPSBudWxsXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGNhbnZhc1NpemU9bnVsbFxuICAgICAqL1xuICAgIGNhbnZhc1NpemUgPSBudWxsXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2Zmc2NyZWVuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfG51bGx9IGNvbnRleHQ9bnVsbFxuICAgICAqL1xuICAgIGNvbnRleHQgPSBudWxsXG4gICAgLyoqXG4gICAgICogQ2FjaGUgZm9yIHJldXNhYmxlIGdyYWRpZW50cyB0byBwcmV2ZW50IEdDLlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gZ3JhZGllbnRzPXt9XG4gICAgICovXG4gICAgZ3JhZGllbnRzID0ge31cbiAgICAvKipcbiAgICAgKiBGbGFnIHRvIHBhdXNlIHRoZSByZW5kZXIgbG9vcC5cbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc1BhdXNlZD1mYWxzZVxuICAgICAqL1xuICAgIGlzUGF1c2VkID0gZmFsc2VcbiAgICAvKipcbiAgICAgKiBUcmFja2VkIG1vdXNlIHBvc2l0aW9uIGZvciBpbnRlcmFjdGl2ZSBwaHlzaWNzLlxuICAgICAqIEluaXRpYWxpemUgb2ZmLXNjcmVlbiB0byBwcmV2ZW50IHN0YXJ0dXAgaml0dGVycy5cbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vdXNlPXt4OiAtMTAwMCwgeTogLTEwMDB9XG4gICAgICovXG4gICAgbW91c2UgPSB7eDogLTEwMDAsIHk6IC0xMDAwfVxuICAgIC8qKlxuICAgICAqIEdsb2JhbCBzaW11bGF0aW9uIHRpbWUuXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSB0aW1lPTBcbiAgICAgKi9cbiAgICB0aW1lID0gMFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7RnVuY3Rpb259IHJlbmRlckxvb3A9dGhpcy5yZW5kZXIuYmluZCh0aGlzKVxuICAgICAqL1xuICAgIHJlbmRlckxvb3AgPSB0aGlzLnJlbmRlci5iaW5kKHRoaXMpXG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGB0aGVtZWAgY29uZmlnIGlzIGNoYW5nZWQuXG4gICAgICogVXBkYXRlcyB0aGUgcmVzb3VyY2UgY2FjaGUgKGdyYWRpZW50cywgY29sb3JzKSB0byByZWZsZWN0IHRoZSBuZXcgdGhlbWUgaW1tZWRpYXRlbHkuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICovXG4gICAgYWZ0ZXJTZXRUaGVtZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICYmIHRoaXMuY2FudmFzU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVSZXNvdXJjZXM/Lih0aGlzLmNhbnZhc1NpemUud2lkdGgsIHRoaXMuY2FudmFzU2l6ZS5oZWlnaHQpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGNhbnZhcyBpcyByZWFkeSB0byByZW5kZXIuXG4gICAgICogUmV0dXJucyB0cnVlIG9ubHkgaWYgdGhlIGNvbnRleHQgZXhpc3RzIGFuZCB0aGUgc2ltdWxhdGlvbiBpcyBub3QgcGF1c2VkLlxuICAgICAqIFN1YmNsYXNzZXMgc2hvdWxkIGNhbGwgdGhpcyBhdCB0aGUgc3RhcnQgb2YgdGhlaXIgYHJlbmRlcmAgbG9vcC5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgY2FuUmVuZGVyKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuICAgICAgICByZXR1cm4gISEobWUuY29udGV4dCAmJiAhbWUuaXNQYXVzZWQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBncmFwaCBzdGF0ZSBhbmQgc3RvcHMgdGhlIHJlbmRlciBsb29wLlxuICAgICAqIFVzZSB0aGlzIHRvIGNsZWFudXAgcmVzb3VyY2VzIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgb3IgdW5tb3VudGVkLlxuICAgICAqL1xuICAgIGNsZWFyR3JhcGgoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG4gICAgICAgIG1lLmNvbnRleHQgICAgID0gbnVsbDtcbiAgICAgICAgbWUuY2FudmFzSWQgICAgPSBudWxsO1xuICAgICAgICBtZS5jYW52YXNTaXplICA9IG51bGw7XG4gICAgICAgIG1lLmFuaW1hdGlvbklkID0gbnVsbDtcbiAgICAgICAgbWUuaXNQYXVzZWQgICAgPSBmYWxzZTtcbiAgICAgICAgbWUuZ3JhZGllbnRzICAgPSB7fTtcbiAgICAgICAgbWUubW91c2UgICAgICAgPSB7eDogLTEwMDAsIHk6IC0xMDAwfTtcbiAgICAgICAgbWUudGltZSAgICAgICAgPSAwXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIGNhbnZhcyBjb250ZXh0LlxuICAgICAqIFN0YXJ0cyB0aGUgcG9sbGluZyBtZWNoYW5pc20gdG8gd2FpdCBmb3IgdGhlIE9mZnNjcmVlbkNhbnZhcyB0cmFuc2ZlciBmcm9tIHRoZSBNYWluIFRocmVhZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRzLmNhbnZhc0lkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdHMud2luZG93SWRcbiAgICAgKi9cbiAgICBpbml0R3JhcGgoe2NhbnZhc0lkLCB3aW5kb3dJZH0pIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBoYXNDaGFuZ2UgPSBtZS5jYW52YXNJZCAhPT0gY2FudmFzSWQ7XG5cbiAgICAgICAgbWUuY2FudmFzSWQgPSBjYW52YXNJZDtcblxuICAgICAgICBtZS53YWl0Rm9yQ2FudmFzKGNhbnZhc0lkLCB3aW5kb3dJZCwgaGFzQ2hhbmdlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhvb2sgZm9yIHN1YmNsYXNzZXMgdG8gaGFuZGxlIG1vdXNlIGNsaWNrcy5cbiAgICAgKiBDYWxsZWQgYnkgYHVwZGF0ZU1vdXNlU3RhdGVgIHdoZW4gYSBjbGljayBldmVudCBpcyByZWNlaXZlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uTW91c2VDbGljayhkYXRhKSB7fVxuXG4gICAgLyoqXG4gICAgICogUGF1c2VzIHRoZSBzaW11bGF0aW9uLlxuICAgICAqIFRoZSByZW5kZXIgbG9vcCB3aWxsIGV4aXQgZWFybHkgd2hpbGUgYGlzUGF1c2VkYCBpcyB0cnVlLlxuICAgICAqL1xuICAgIHBhdXNlKCkge1xuICAgICAgICB0aGlzLmlzUGF1c2VkID0gdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFic3RyYWN0IHJlbmRlciBtZXRob2QuXG4gICAgICogU3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byBkcmF3IHRoZSBmcmFtZS5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7fVxuXG4gICAgLyoqXG4gICAgICogUmVzdW1lcyB0aGUgc2ltdWxhdGlvbi5cbiAgICAgKiBJZiB0aGUgc2ltdWxhdGlvbiB3YXMgcGF1c2VkLCB0aGlzIHJlc3RhcnRzIHRoZSByZW5kZXIgbG9vcC5cbiAgICAgKi9cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmlzUGF1c2VkKSB7XG4gICAgICAgICAgICBtZS5pc1BhdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgbWUucmVuZGVyTG9vcCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHBvc2VkIG1ldGhvZCBmb3IgUmVtb3RlIEFjY2VzcyB0byB0cmlnZ2VyIHRoZSByZWFjdGl2ZSBjb25maWcgc2V0dGVyLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIHNldFRoZW1lKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudGhlbWUgPSB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGxvY2FsIG1vdXNlIHN0YXRlIGZyb20gbWFpbiB0aHJlYWQgZXZlbnRzLlxuICAgICAqIERlbGVnYXRlcyBjbGljayBldmVudHMgdG8gYG9uTW91c2VDbGlja2AuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkYXRhLmNsaWNrXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2RhdGEubGVhdmVdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtkYXRhLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtkYXRhLnldXG4gICAgICovXG4gICAgdXBkYXRlTW91c2VTdGF0ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKGRhdGEubGVhdmUpIHtcbiAgICAgICAgICAgIG1lLm1vdXNlLnggPSAtMTAwMDtcbiAgICAgICAgICAgIG1lLm1vdXNlLnkgPSAtMTAwMFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRhdGEueCAhPT0gdW5kZWZpbmVkKSBtZS5tb3VzZS54ID0gZGF0YS54O1xuICAgICAgICAgICAgaWYgKGRhdGEueSAhPT0gdW5kZWZpbmVkKSBtZS5tb3VzZS55ID0gZGF0YS55O1xuXG4gICAgICAgICAgICBpZiAoZGF0YS5jbGljaykge1xuICAgICAgICAgICAgICAgIG1lLm9uTW91c2VDbGljayhkYXRhKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgY2FudmFzIHNpemUgYW5kIHJlc2l6ZXMgdGhlIGludGVybmFsIGNvbnRleHQuXG4gICAgICogVHJpZ2dlcnMgYHVwZGF0ZVJlc291cmNlc2AgaG9vayB0byBhbGxvdyBzdWJjbGFzc2VzIHRvIHJlZ2VuZXJhdGUgYnVmZmVycy9ncmFkaWVudHMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNpemVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2l6ZS5oZWlnaHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2l6ZS53aWR0aFxuICAgICAqL1xuICAgIHVwZGF0ZVNpemUoc2l6ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmNhbnZhc1NpemUgPSBzaXplO1xuXG4gICAgICAgIGlmIChtZS5jb250ZXh0KSB7XG4gICAgICAgICAgICBtZS5jb250ZXh0LmNhbnZhcy53aWR0aCAgPSBzaXplLndpZHRoO1xuICAgICAgICAgICAgbWUuY29udGV4dC5jYW52YXMuaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgICAvLyBDYWxscyB0aGUgaG9vayB0byByZS1nZW5lcmF0ZSByZXNvdXJjZXMgaWYgaW1wbGVtZW50ZWRcbiAgICAgICAgICAgIG1lLnVwZGF0ZVJlc291cmNlcz8uKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUG9sbHMgZm9yIHRoZSBPZmZzY3JlZW5DYW52YXMgdW50aWwgaXQgaXMgYXZhaWxhYmxlIGluIHRoZSBXb3JrZXIncyBgY2FudmFzV2luZG93TWFwYC5cbiAgICAgKiBPbmNlIGZvdW5kLCBpdCBpbml0aWFsaXplcyB0aGUgY29udGV4dCBhbmQgc3RhcnRzIHRoZSByZW5kZXIgbG9vcC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2FudmFzSWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gd2luZG93SWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGhhc0NoYW5nZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB3YWl0Rm9yQ2FudmFzKGNhbnZhc0lkLCB3aW5kb3dJZCwgaGFzQ2hhbmdlKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY2FudmFzID0gTmVvLmN1cnJlbnRXb3JrZXIuY2FudmFzV2luZG93TWFwW2NhbnZhc0lkXT8uW3dpbmRvd0lkXTtcblxuICAgICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgICAgICBtZS5jb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgIC8vIFN0YW5kYXJkaXplIHNpemUgdXBkYXRlXG4gICAgICAgICAgICBtZS51cGRhdGVTaXplKHt3aWR0aDogY2FudmFzLndpZHRoLCBoZWlnaHQ6IGNhbnZhcy5oZWlnaHR9KTtcblxuICAgICAgICAgICAgLy8gT3B0aW9uYWwgaG9vayBmb3Igc3ViY2xhc3Nlc1xuICAgICAgICAgICAgbWUub25HcmFwaE1vdW50ZWQ/LihjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuXG4gICAgICAgICAgICBpZiAoaGFzQ2hhbmdlICYmICFtZS5hbmltYXRpb25JZCkge1xuICAgICAgICAgICAgICAgIG1lLnJlbmRlckxvb3AoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dChtZS53YWl0Rm9yQ2FudmFzLmJpbmQobWUsIGNhbnZhc0lkLCB3aW5kb3dJZCwgaGFzQ2hhbmdlKSwgNTApXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEJhc2UpO1xuIiwiaW1wb3J0IEJhc2UgZnJvbSAnLi9CYXNlLm1qcyc7XG5cbmNvbnN0XG4gICAgaGFzUmFmICAgID0gdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gJ2Z1bmN0aW9uJyxcbiAgICBQUklNQVJZICAgPSAnIzNFNjNERCcsXG4gICAgU0VDT05EQVJZID0gJyM1MzZERkUnLFxuICAgIEhJR0hMSUdIVCA9ICcjMDBCRkZGJztcblxuLyoqXG4gKiBAc3VtbWFyeSBTaGFyZWRXb3JrZXIgcmVuZGVyZXIgZm9yIHRoZSBIZWFkZXJUb29sYmFyIG92ZXJsYXkuXG4gKlxuICogSW1wbGVtZW50cyB0aGUgKipcIkx1bWlub3VzIEZsdXhcIioqIHZpc3VhbCB0aGVtZSwgYW4gYW1iaWVudCwgaW50ZXJhY3RpdmUgZW5lcmd5IHNpbXVsYXRpb24gdGhhdFxuICogc2VydmVzIGFzIHRoZSBiYWNrZHJvcCBmb3IgdGhlIFBvcnRhbCBoZWFkZXIuXG4gKlxuICogKipWaXN1YWwgQXJjaGl0ZWN0dXJlOioqXG4gKiAxLiAqKk5lbyBFdGhlciAoQmFja2dyb3VuZCk6KiogQSB2b2x1bWV0cmljIHBhcnRpY2xlIGZpZWxkIGNvbXBvc2VkIG9mIGZhaW50IFwiZHVzdFwiIGFuZCBsYXJnZXIgXCJuZWJ1bGFcIiBvcmJzLlxuICogICAgVGhpcyBwcm92aWRlcyBhdG1vc3BoZXJpYyBkZXB0aCwgZmx1aWQgaW50ZXJhY3Rpdml0eSAobW91c2UgcmVwdWxzaW9uKSwgYW5kIGJyaWRnZXMgdGhlIGNvbnRyYXN0IGdhcFxuICogICAgYmV0d2VlbiB0aGUgd2hpdGUgYmFja2dyb3VuZCBhbmQgdGhlIGZvcmVncm91bmQgZWxlbWVudHMuXG4gKiAyLiAqKkFtYmllbnQgSGVsaXggKE1pZGdyb3VuZCk6KiogQSBsYXJnZS1zY2FsZSwgc2xvdy1tb3Zpbmcgc2luZSB3YXZlIHBhdHRlcm4gdGhhdCBwcm92aWRlcyBzdHJ1Y3R1cmFsXG4gKiAgICB0ZXh0dXJlIHRvIHRoZSBuZWdhdGl2ZSBzcGFjZS4gTm93IGVuaGFuY2VkIHdpdGggYSAqKnZvbHVtZXRyaWMgUmliYm9uIGZpbGwqKiB0byBhZGQgZGVwdGguXG4gKiAzLiAqKlNwbGl0IFN0cmVhbSAoRm9yZWdyb3VuZCk6KiogVHdvIGludGVydHdpbmVkIGVuZXJneSBzdHJhbmRzIChIZWxpeC9ETkEpIHRoYXQgZmxvdyBhY3Jvc3MgdGhlIGNhbnZhcy5cbiAqICAgIC0gKiozRCBSaWJib24gRWZmZWN0OioqIEEgc3VidGxlIGdyYWRpZW50IGZpbGxzIHRoZSBzcGFjZSBiZXR3ZWVuIHN0cmFuZHMsIHNpbXVsYXRpbmcgYSB0d2lzdGluZyBzdXJmYWNlLlxuICAqICAgLSAqKk5lb24gVHViZSBFZmZlY3Q6KiogU3RyYW5kcyBhcmUgcmVuZGVyZWQgd2l0aCBhIGJyaWdodCB3aGl0ZSBjb3JlIGluc2lkZSBhIGNvbG9yZWQgZ2xvdywgY3JlYXRpbmcgYSBwaHlzaWNhbCBsaWdodC1lbWl0dGluZyBsb29rLlxuICAqICAgLSAqKkFkYXB0aXZlIEdlb21ldHJ5OioqIFRoZSBzdHJhbmRzIGZsb3cgbG9vc2VseSBhcm91bmQgdGV4dCBidXR0b25zIGJ1dCB0aWdodGVuIGludG8gYSBcImhpZ2gtZ3Jhdml0eSBvcmJpdFwiXG4gICogICAgIGFyb3VuZCBzb2NpYWwgaWNvbnMuXG4gICogICAtICoqRW5lcmd5IFN1cmdlIChBY3RpdmUgU3RhdGUpOioqIFRoZSBzZWdtZW50IG9mIHRoZSBzdHJlYW0gcGFzc2luZyB0aHJvdWdoIHRoZSBhY3RpdmUgbmF2aWdhdGlvbiBpdGVtXG4gICogICAgIGlzIHJlbmRlcmVkIHdpdGggYSBoaWdoLWludGVuc2l0eSB3aGl0ZSBnbG93IGFuZCBhIG5lcnZvdXMgcHVsc2UsIHNlbWFudGljYWxseSBoaWdobGlnaHRpbmcgdGhlIGN1cnJlbnQgdmlldy5cbiAgKiAgIC0gKipQcmV2aWV3IEdsb3cgKEhvdmVyIFN0YXRlKToqKiBBIHN0YXRpYywgaGlnaC1jb250cmFzdCBnbG93IGhpZ2hsaWdodHMgdGhlIGl0ZW0gdW5kZXIgdGhlIGN1cnNvcixcbiAgKiAgICAgcHJvdmlkaW5nIGltbWVkaWF0ZSwgZGlzdGluY3QgZmVlZGJhY2sgc2VwYXJhdGUgZnJvbSB0aGUgYWN0aXZlIHN0YXRlLlxuICAqXG4gICogKipQZXJmb3JtYW5jZSBBcmNoaXRlY3R1cmUgKFplcm8tQWxsb2NhdGlvbik6KipcbiAqIFRvIG1haW50YWluIDYwZnBzIG9uIGhpZ2gtcmVmcmVzaCBkaXNwbGF5cyB3aXRob3V0IEdDIHN0dXR0ZXJzLCB0aGlzIGNsYXNzIGVtcGxveXMgYSAqKlplcm8tQWxsb2NhdGlvbioqIHN0cmF0ZWd5IGR1cmluZyB0aGUgcmVuZGVyIGxvb3AuXG4gKiAxLiAqKlR5cGVkQXJyYXkgQnVmZmVyczoqKiBXYXZlIGdlb21ldHJ5IGlzIHN0b3JlZCBpbiBwcmUtYWxsb2NhdGVkIGBGbG9hdDMyQXJyYXlgIGJ1ZmZlcnMgKGB3YXZlQnVmZmVyc2ApLCByZXVzZWQgZXZlcnkgZnJhbWUuXG4gKiAyLiAqKkdyYWRpZW50IENhY2hpbmc6KiogQ2FudmFzR3JhZGllbnRzIGFyZSBjcmVhdGVkIG9ubHkgb24gcmVzaXplIChgdXBkYXRlUmVzb3VyY2VzYCkgYW5kIGNhY2hlZCwgYXZvaWRpbmcgZXhwZW5zaXZlIGdlbmVyYXRvciBjYWxscyBwZXIgZnJhbWUuXG4gKiAzLiAqKlJldXNhYmxlIE9iamVjdHM6KiogUGh5c2ljcyBjYWxjdWxhdGlvbnMgd3JpdGUgZGlyZWN0bHkgdG8gYnVmZmVycyBpbnN0ZWFkIG9mIHJldHVybmluZyBuZXcgQXJyYXlzIG9mIE9iamVjdHMuXG4gKlxuICogQGNsYXNzIE5lby5jYW52YXMuSGVhZGVyXG4gKiBAZXh0ZW5kcyBOZW8uY2FudmFzLkJhc2VcbiAqIEBzaW5nbGV0b25cbiAqIEBzZWUgUG9ydGFsLnZpZXcuSGVhZGVyQ2FudmFzXG4gKi9cbmNsYXNzIEhlYWRlciBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb2xvcnMgPSB7XG4gICAgICAgIGRhcmsgOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kICAgOiBbJ3JnYmEoNjIsIDk5LCAyMjEsIDAuMSknLCAncmdiYSg2NCwgMTk2LCAyNTUsIDAuMiknLCAncmdiYSg2MiwgOTksIDIyMSwgMC4xKSddLFxuICAgICAgICAgICAgYmFja2dyb3VuZDIgIDogWydyZ2JhKDEzOSwgMTY2LCAyNTUsIDAuMSknLCAncmdiYSg2NCwgMTk2LCAyNTUsIDAuMiknLCAncmdiYSgxMzksIDE2NiwgMjU1LCAwLjEpJ10sXG4gICAgICAgICAgICBiZ1JpYmJvbiAgICAgOiBbJ3JnYmEoNjIsIDk5LCAyMjEsIDAuMDIpJywgJ3JnYmEoNjQsIDE5NiwgMjU1LCAwLjA1KScsICdyZ2JhKDYyLCA5OSwgMjIxLCAwLjAyKSddLFxuICAgICAgICAgICAgZmdSaWJib24gICAgIDogWydyZ2JhKDYyLCA5OSwgMjIxLCAwLjAyNSknLCAncmdiYSg2NCwgMTk2LCAyNTUsIDAuMDUpJywgJ3JnYmEoNjIsIDk5LCAyMjEsIDAuMDI1KSddLFxuICAgICAgICAgICAgZ3JhZDEgICAgICAgIDogW1BSSU1BUlksIEhJR0hMSUdIVCwgUFJJTUFSWV0sXG4gICAgICAgICAgICBncmFkMUhvdCAgICAgOiBbSElHSExJR0hULCAnI0ZGRkZGRicsIEhJR0hMSUdIVF0sXG4gICAgICAgICAgICBncmFkMiAgICAgICAgOiBbU0VDT05EQVJZLCBISUdITElHSFQsIFNFQ09OREFSWV0sXG4gICAgICAgICAgICBncmFkMkhvdCAgICAgOiBbSElHSExJR0hULCAnI0ZGRkZGRicsIEhJR0hMSUdIVF0sXG4gICAgICAgICAgICBob3ZlciAgICAgICAgOiBISUdITElHSFQsXG4gICAgICAgICAgICBwYXJ0aWNsZSAgICAgOiBISUdITElHSFQsXG4gICAgICAgICAgICBwYXJ0aWNsZUFscGhhOiB7bmVidWxhOiAwLjIsIGR1c3Q6IDAuMn0sXG4gICAgICAgICAgICBzaG9ja3dhdmUgICAgOiBISUdITElHSFRcbiAgICAgICAgfSxcbiAgICAgICAgbGlnaHQ6IHtcbiAgICAgICAgICAgIGJhY2tncm91bmQgICA6IFsncmdiYSg2MiwgOTksIDIyMSwgMC4xKScsICdyZ2JhKDY0LCAxOTYsIDI1NSwgMC4yKScsICdyZ2JhKDYyLCA5OSwgMjIxLCAwLjEpJ10sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kMiAgOiBbJ3JnYmEoMTM5LCAxNjYsIDI1NSwgMC4xKScsICdyZ2JhKDY0LCAxOTYsIDI1NSwgMC4yKScsICdyZ2JhKDEzOSwgMTY2LCAyNTUsIDAuMSknXSxcbiAgICAgICAgICAgIGJnUmliYm9uICAgICA6IFsncmdiYSg2MiwgOTksIDIyMSwgMC4wMiknLCAncmdiYSg2NCwgMTk2LCAyNTUsIDAuMDUpJywgJ3JnYmEoNjIsIDk5LCAyMjEsIDAuMDIpJ10sXG4gICAgICAgICAgICBmZ1JpYmJvbiAgICAgOiBbJ3JnYmEoNjIsIDk5LCAyMjEsIDAuMDUpJywgJ3JnYmEoNjQsIDE5NiwgMjU1LCAwLjEpJywgJ3JnYmEoNjIsIDk5LCAyMjEsIDAuMDUpJ10sXG4gICAgICAgICAgICBncmFkMSAgICAgICAgOiBbUFJJTUFSWSwgSElHSExJR0hULCBQUklNQVJZXSxcbiAgICAgICAgICAgIGdyYWQxSG90ICAgICA6IFtISUdITElHSFQsICcjRkZGRkZGJywgSElHSExJR0hUXSxcbiAgICAgICAgICAgIGdyYWQyICAgICAgICA6IFtTRUNPTkRBUlksIEhJR0hMSUdIVCwgU0VDT05EQVJZXSxcbiAgICAgICAgICAgIGdyYWQySG90ICAgICA6IFtISUdITElHSFQsICcjRkZGRkZGJywgSElHSExJR0hUXSxcbiAgICAgICAgICAgIGhvdmVyICAgICAgICA6IFBSSU1BUlksXG4gICAgICAgICAgICBwYXJ0aWNsZSAgICAgOiBISUdITElHSFQsXG4gICAgICAgICAgICBwYXJ0aWNsZUFscGhhOiB7bmVidWxhOiAwLjIsIGR1c3Q6IDAuMn0sXG4gICAgICAgICAgICBzaG9ja3dhdmUgICAgOiBISUdITElHSFRcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNhbnZhcy5IZWFkZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jYW52YXMuSGVhZGVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW90ZSBtZXRob2QgYWNjZXNzXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gcmVtb3RlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHJlbW90ZToge1xuICAgICAgICAgICAgYXBwOiBbXG4gICAgICAgICAgICAgICAgJ3VwZGF0ZUFjdGl2ZUlkJyxcbiAgICAgICAgICAgICAgICAndXBkYXRlQ29uZmlnJyxcbiAgICAgICAgICAgICAgICAndXBkYXRlR3JhcGhEYXRhJyxcbiAgICAgICAgICAgICAgICAndXBkYXRlSG92ZXJJZCcsXG4gICAgICAgICAgICAgICAgJ3VwZGF0ZU5hdlJlY3RzJyxcbiAgICAgICAgICAgICAgICAndXBkYXRlVGltZVNjYWxlJ1xuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2luZ2xldG9uPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2luZ2xldG9uOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGFjdGl2ZUlkPW51bGxcbiAgICAgKi9cbiAgICBhY3RpdmVJZCA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGF2Z0ZyYW1lVGltZT0xNlxuICAgICAqL1xuICAgIGF2Z0ZyYW1lVGltZSA9IDE2XG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGhvdmVySWQ9bnVsbFxuICAgICAqL1xuICAgIGhvdmVySWQgPSBudWxsXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSBsYXN0RnJhbWVUaW1lPTBcbiAgICAgKi9cbiAgICBsYXN0RnJhbWVUaW1lID0gMFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdFtdfSBuYXZSZWN0cz1bXVxuICAgICAqL1xuICAgIG5hdlJlY3RzID0gW11cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gcGFydGljbGVzPVtdXG4gICAgICovXG4gICAgcGFydGljbGVzID0gW11cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gc2hvY2t3YXZlcz1bXVxuICAgICAqL1xuICAgIHNob2Nrd2F2ZXMgPSBbXVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gdGFyZ2V0VGltZVNjYWxlPTFcbiAgICAgKi9cbiAgICB0YXJnZXRUaW1lU2NhbGUgPSAxXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSB0aW1lU2NhbGU9MVxuICAgICAqL1xuICAgIHRpbWVTY2FsZSA9IDFcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB1c2VQdWxzZT10cnVlXG4gICAgICovXG4gICAgdXNlUHVsc2UgPSB0cnVlXG4gICAgLyoqXG4gICAgICogUHJlLWFsbG9jYXRlZCBidWZmZXJzIGZvciB3YXZlIGdlb21ldHJ5LlxuICAgICAqIFVzZXMgYEZsb2F0MzJBcnJheWAgdG8gZWxpbWluYXRlIEdhcmJhZ2UgQ29sbGVjdGlvbiBwcmVzc3VyZSBkdXJpbmcgdGhlIHJlbmRlciBsb29wLlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gd2F2ZUJ1ZmZlcnM9e2JnQTogbnVsbCwgYmdCOiBudWxsLCBmZ0E6IG51bGwsIGZnQjogbnVsbH1cbiAgICAgKi9cbiAgICB3YXZlQnVmZmVycyA9IHtiZ0E6IG51bGwsIGJnQjogbnVsbCwgZmdBOiBudWxsLCBmZ0I6IG51bGx9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGdyYXBoIHN0YXRlIGFuZCBzdG9wcyB0aGUgcmVuZGVyIGxvb3AuXG4gICAgICovXG4gICAgY2xlYXJHcmFwaCgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcbiAgICAgICAgc3VwZXIuY2xlYXJHcmFwaCgpO1xuICAgICAgICBtZS5uYXZSZWN0cyAgICA9IFtdO1xuICAgICAgICBtZS5wYXJ0aWNsZXMgICA9IFtdO1xuICAgICAgICBtZS5zaG9ja3dhdmVzICA9IFtdO1xuICAgICAgICBtZS53YXZlQnVmZmVycyA9IHtiZ0E6IG51bGwsIGJnQjogbnVsbCwgZmdBOiBudWxsLCBmZ0I6IG51bGx9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSG9vayB0byBpbml0aWFsaXplIHBhcnRpY2xlcyBhZnRlciBjb250ZXh0IGlzIHJlYWR5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqL1xuICAgIG9uR3JhcGhNb3VudGVkKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5pbml0UGFydGljbGVzKHdpZHRoLCBoZWlnaHQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIHBhcnRpY2xlIHN5c3RlbSBmb3IgdGhlIFwiTmVvIEV0aGVyXCIgZWZmZWN0LlxuICAgICAqXG4gICAgICogQ3JlYXRlcyBhIG1peCBvZiBsYXJnZSwgc2xvdy1tb3ZpbmcgXCJuZWJ1bGFcIiBwYXJ0aWNsZXMgYW5kIHNtYWxsZXIsIGZhc3RlciBcImR1c3RcIiBwYXJ0aWNsZXNcbiAgICAgKiB0byBjcmVhdGUgZGVwdGggYW5kIGF0bW9zcGhlcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAgICovXG4gICAgaW5pdFBhcnRpY2xlcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG4gICAgICAgIG1lLnBhcnRpY2xlcyA9IFtdO1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAgY291bnQgICAgICAgPSA2MCxcbiAgICAgICAgICAgIHRoZW1lQ29sb3JzID0gbWUuY29uc3RydWN0b3IuY29sb3JzW21lLnRoZW1lXSxcbiAgICAgICAgICAgIGFscGhhcyAgICAgID0gdGhlbWVDb2xvcnMucGFydGljbGVBbHBoYTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpc05lYnVsYSA9IE1hdGgucmFuZG9tKCkgPiAwLjg7IC8vIDIwJSBhcmUgbGFyZ2UgbmVidWxhIG9yYnNcblxuICAgICAgICAgICAgbWUucGFydGljbGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlzTmVidWxhLFxuICAgICAgICAgICAgICAgIHggICAgICAgIDogTWF0aC5yYW5kb20oKSAqIHdpZHRoLFxuICAgICAgICAgICAgICAgIHkgICAgICAgIDogTWF0aC5yYW5kb20oKSAqIGhlaWdodCxcbiAgICAgICAgICAgICAgICB2eCAgICAgICA6IGlzTmVidWxhID8gKE1hdGgucmFuZG9tKCkgKiAwLjIgKyAwLjA1KSA6IChNYXRoLnJhbmRvbSgpICogMC41ICsgMC4xKSwgLy8gTmVidWxhZSBtb3ZlIHNsb3dlclxuICAgICAgICAgICAgICAgIHZ5ICAgICAgIDogKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMC4yLFxuICAgICAgICAgICAgICAgIHNpemUgICAgIDogaXNOZWJ1bGEgPyAoTWF0aC5yYW5kb20oKSAqIDMwICsgMjApIDogKE1hdGgucmFuZG9tKCkgKiAyICsgMC41KSwgLy8gTGFyZ2UgdnMgU21hbGxcbiAgICAgICAgICAgICAgICBhbHBoYSAgICA6IGlzTmVidWxhID8gKE1hdGgucmFuZG9tKCkgKiAwLjE1ICsgYWxwaGFzLm5lYnVsYSkgOiAoTWF0aC5yYW5kb20oKSAqIDAuNCArIGFscGhhcy5kdXN0KSxcbiAgICAgICAgICAgICAgICBiYXNlQWxwaGE6IGlzTmVidWxhID8gKE1hdGgucmFuZG9tKCkgKiAwLjE1ICsgYWxwaGFzLm5lYnVsYSkgOiAoTWF0aC5yYW5kb20oKSAqIDAuNCArIGFscGhhcy5kdXN0KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1haW4gcmVuZGVyIGxvb3AuXG4gICAgICpcbiAgICAgKiBPcmNoZXN0cmF0ZXMgdGhlIHJlbmRlcmluZyBvZiBhbGwgdmlzdWFsIGxheWVyczpcbiAgICAgKiAxLiBBbWJpZW50IEJhY2tncm91bmQgKFJpYmJvbiArIEhlbGl4KVxuICAgICAqIDIuIE5lbyBFdGhlciAoUGFydGljbGVzKVxuICAgICAqIDMuIFNwbGl0IFN0cmVhbSAoRm9yZWdyb3VuZCBBdXJhcylcbiAgICAgKiA0LiBTaG9ja3dhdmVzIChJbnRlcmFjdGlvbilcbiAgICAgKlxuICAgICAqIFVzZXMgYHNldFRpbWVvdXRgIGluc3RlYWQgb2YgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgYmVjYXVzZSB0aGlzIHJ1bnMgaW4gYSBTaGFyZWRXb3JrZXJcbiAgICAgKiB3aGVyZSBgckFGYCBpcyBub3QgYXZhaWxhYmxlLiBUYXJnZXRzIH42MGZwcyAoMTZtcykuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUuY2FuUmVuZGVyKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBjdHggICAgPSBtZS5jb250ZXh0LFxuICAgICAgICAgICAgd2lkdGggID0gbWUuY2FudmFzU2l6ZT8ud2lkdGggIHx8IDEwMCxcbiAgICAgICAgICAgIGhlaWdodCA9IG1lLmNhbnZhc1NpemU/LmhlaWdodCB8fCA1MCxcbiAgICAgICAgICAgIG5vdyAgICA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgICAgIC8vIDAuIFBlcmZvcm1hbmNlIE1vbml0b3JpbmcgKEFkYXB0aXZlIEJhY2twcmVzc3VyZSlcbiAgICAgICAgaWYgKG1lLmxhc3RGcmFtZVRpbWUgPiAwKSB7XG4gICAgICAgICAgICBsZXQgZGVsdGEgPSBub3cgLSBtZS5sYXN0RnJhbWVUaW1lO1xuXG4gICAgICAgICAgICAvLyBPbmx5IHVwZGF0ZSBhdmVyYWdlIGlmIGRlbHRhIGlzIHNhbml0eS1jaGVja2VkIChpZ25vcmUgdGFiIHN1c3BlbnNpb24gcGF1c2VzKVxuICAgICAgICAgICAgaWYgKGRlbHRhIDwgNTAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRXhwb25lbnRpYWwgTW92aW5nIEF2ZXJhZ2UgKGFscGhhID0gMC4wNSBmb3Igc21vb3RoIHN0YWJpbGl0eSlcbiAgICAgICAgICAgICAgICBtZS5hdmdGcmFtZVRpbWUgPSAobWUuYXZnRnJhbWVUaW1lICogMC45NSkgKyAoZGVsdGEgKiAwLjA1KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtZS5sYXN0RnJhbWVUaW1lID0gbm93O1xuXG4gICAgICAgIC8vIFNtb290aCB0cmFuc2l0aW9uIGZvciB0aW1lU2NhbGVcbiAgICAgICAgaWYgKG1lLnRpbWVTY2FsZSAhPT0gbWUudGFyZ2V0VGltZVNjYWxlKSB7XG4gICAgICAgICAgICBsZXQgZGlmZiA9IG1lLnRhcmdldFRpbWVTY2FsZSAtIG1lLnRpbWVTY2FsZTtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkaWZmKSA8IDAuMDEpIHtcbiAgICAgICAgICAgICAgICBtZS50aW1lU2NhbGUgPSBtZS50YXJnZXRUaW1lU2NhbGVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWUudGltZVNjYWxlICs9IGRpZmYgKiAwLjA1IC8vIEVhc2Utb3V0XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBhbmltYXRpb25zIGFyZSBlbmFibGVkLCB1c2UgZHluYW1pYyB0aW1lU2NhbGUgKDF4IHRvIDJ4KS5cbiAgICAgICAgLy8gSWYgZGlzYWJsZWQsIHVzZSBhIGZpeGVkIFwiUmVkdWNlZCBNb3Rpb25cIiBkcmlmdCAoMC4yeCkuXG4gICAgICAgIGxldCBzcGVlZCA9IG1lLnVzZVB1bHNlID8gbWUudGltZVNjYWxlIDogMC4yO1xuXG4gICAgICAgIG1lLnRpbWUgKz0gMC4wNSAqIHNwZWVkO1xuXG4gICAgICAgIC8vIEF1dG8tcmVpbml0IHBhcnRpY2xlcyBpZiBzaXplIGNoYW5nZXMgc2lnbmlmaWNhbnRseSBvciBlbXB0eSBPUiBjb3VudCBtaXNtYXRjaCAoY29uZmlnIHVwZGF0ZSlcbiAgICAgICAgaWYgKG1lLnBhcnRpY2xlcy5sZW5ndGggIT09IDYwKSB7XG4gICAgICAgICAgICBtZS5pbml0UGFydGljbGVzKHdpZHRoLCBoZWlnaHQpXG4gICAgICAgIH1cblxuICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIC8vIDEuIERyYXcgQW1iaWVudCBCYWNrZ3JvdW5kXG4gICAgICAgIG1lLmRyYXdBbWJpZW50QmFja2dyb3VuZChjdHgsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIC8vIDIuIERyYXcgRXRoZXIgUGFydGljbGVzIChCYWNrZ3JvdW5kIExheWVyKVxuICAgICAgICBtZS5kcmF3UGFydGljbGVzKGN0eCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgLy8gMy4gRHJhdyBcIkF1cmFzXCIgKEhvdmVyIEVmZmVjdHMpID0+IDNEIFJpYmJvbiArIE5lb24gVHViZVxuICAgICAgICAvLyBCYWNrcHJlc3N1cmU6IElmIHdlIGFyZSBkcm9wcGluZyBmcmFtZXMgKD4gMzJtcyksIGRpc2FibGUgdGhlIGhvdCBvdmVybGF5XG4gICAgICAgIGNvbnN0IGlzU3RyZXNzZWQgPSBtZS5hdmdGcmFtZVRpbWUgPiAzMjtcbiAgICAgICAgbWUuZHJhd0F1cmFzKGN0eCwgd2lkdGgsIGhlaWdodCwgaXNTdHJlc3NlZCk7XG5cbiAgICAgICAgLy8gM2IuIERyYXcgQWN0aXZlIE92ZXJsYXlcbiAgICAgICAgbWUuZHJhd0FjdGl2ZU92ZXJsYXkoY3R4LCB3aWR0aCk7XG5cbiAgICAgICAgLy8gM2MuIERyYXcgSG92ZXIgT3ZlcmxheVxuICAgICAgICBtZS5kcmF3SG92ZXJPdmVybGF5KGN0eCwgd2lkdGgpO1xuXG4gICAgICAgIC8vIDQuIERyYXcgXCJTaG9ja3dhdmVzXCIgKENsaWNrIEVmZmVjdHMpXG4gICAgICAgIG1lLmRyYXdTaG9ja3dhdmVzKGN0eCwgd2lkdGgpO1xuXG4gICAgICAgIGlmIChoYXNSYWYpIHtcbiAgICAgICAgICAgIG1lLmFuaW1hdGlvbklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKG1lLnJlbmRlckxvb3ApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5hbmltYXRpb25JZCA9IHNldFRpbWVvdXQobWUucmVuZGVyTG9vcCwgMTAwMCAvIDYwKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS52YWx1ZVxuICAgICAqL1xuICAgIHVwZGF0ZVRpbWVTY2FsZShkYXRhKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0VGltZVNjYWxlID0gZGF0YS52YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHBvaW50cyBmb3IgdGhlIHR3byBlbmVyZ3kgc3RyYW5kcyBiYXNlZCBvbiBwaHlzaWNzIGFuZCBpbnRlcmFjdGlvbi5cbiAgICAgKlxuICAgICAqICoqWmVyby1BbGxvY2F0aW9uIENvbnRyYWN0OioqXG4gICAgICogVGhpcyBtZXRob2Qgd3JpdGVzIGRpcmVjdGx5IHRvIHRoZSBwcmUtYWxsb2NhdGVkIGB0aGlzLndhdmVCdWZmZXJzYCBgRmxvYXQzMkFycmF5YHMuXG4gICAgICogSXQgZG9lcyAqKm5vdCoqIGFsbG9jYXRlIG5ldyBhcnJheXMgb3Igb2JqZWN0cywgZW5zdXJpbmcgemVybyBHQyBwcmVzc3VyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB7c2hpbW1lckEsIHNoaW1tZXJCLCBjb3VudH0gTWV0YWRhdGEgZm9yIHJlbmRlcmluZyAoc2NhbGFycyBvbmx5KVxuICAgICAqL1xuICAgIGNhbGN1bGF0ZVN0cmFuZEdlb21ldHJ5KHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWUubmF2UmVjdHMpIHx8ICFtZS53YXZlQnVmZmVycy5mZ0EpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdFxuICAgICAgICAgICAgYnVmQSAgICA9IG1lLndhdmVCdWZmZXJzLmZnQSxcbiAgICAgICAgICAgIGJ1ZkIgICAgPSBtZS53YXZlQnVmZmVycy5mZ0IsXG4gICAgICAgICAgICBzdGVwICAgID0gMixcbiAgICAgICAgICAgIGNvdW50ICAgPSBNYXRoLmNlaWwod2lkdGggLyBzdGVwKSxcbiAgICAgICAgICAgIGNlbnRlclkgPSBoZWlnaHQgLyAyLFxuICAgICAgICAgICAgcGFkZGluZyA9IDEwLFxuICAgICAgICAgICAgbWF4SCAgICA9IChoZWlnaHQgLSAocGFkZGluZyAqIDIpKSAvIDIsXG4gICAgICAgICAgICAvLyBCUkVBVEhJTkc6IE1vZHVsYXRlIGJhc2UgYW1wbGl0dWRlIG92ZXIgdGltZSAoc2xvdyBwdWxzZSlcbiAgICAgICAgICAgIGJyZWF0aCAgID0gTWF0aC5zaW4obWUudGltZSAqIDAuNSkgKiAyLFxuICAgICAgICAgICAgYmFzZUFtcCAgPSBNYXRoLm1pbig2ICsgYnJlYXRoLCBtYXhIKSxcbiAgICAgICAgICAgIGhvdmVyQW1wID0gNDtcblxuICAgICAgICAvLyBSRUYgMTogTGlua2VkIFBoYXNlIC0gU2hpbW1lciBsZWFkcyBCcmVhdGggYnkgOTBkZWcgKFwiQ2hhcmdpbmcgdXBcIilcbiAgICAgICAgbGV0IGJhc2VTaGltbWVyID0gMC43NSArIChNYXRoLnNpbihtZS50aW1lICogMC41ICsgTWF0aC5QSSAvIDIpICogMC4yNSk7XG5cbiAgICAgICAgLy8gUkVGIDI6IEluZGVwZW5kZW50IFN0cmFuZCBTaGltbWVyXG4gICAgICAgIGxldCBzaGltbWVyQSA9IGJhc2VTaGltbWVyLFxuICAgICAgICAgICAgc2hpbW1lckIgPSAwLjc1ICsgKE1hdGguc2luKG1lLnRpbWUgKiAwLjUgKyBNYXRoLlBJIC8gMiArIE1hdGguUEkgLyAzKSAqIDAuMjUpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IHggPSBpICogc3RlcCxcbiAgICAgICAgICAgICAgICB7b2Zmc2V0WSwgaW50ZW5zaXR5LCBpc0ljb25ab25lfSA9IG1lLmdldFN0cmVhbU9mZnNldCh4LCBoZWlnaHQsIHdpZHRoKTtcblxuICAgICAgICAgICAgLy8gRlJFUVVFTkNZIE1PRFVMQVRJT046XG4gICAgICAgICAgICBsZXQgZnJlcU1vZCAgID0gTWF0aC5zaW4oeCAqIDAuMDAyICsgbWUudGltZSAqIDAuMSkgKiAoMjAgKyAoaW50ZW5zaXR5ICogMTApKSxcbiAgICAgICAgICAgICAgICB0aW1lU2hpZnQgPSBtZS50aW1lICogMjtcblxuICAgICAgICAgICAgLy8gREFNUElORyBGT1IgSUNPTlM6XG4gICAgICAgICAgICBsZXQgbG9jYWxBbXAgPSBiYXNlQW1wICogKDEgLSAoaXNJY29uWm9uZSAqIDAuNikpO1xuXG4gICAgICAgICAgICAvLyBOb2lzZSBDYWxjdWxhdGlvblxuICAgICAgICAgICAgLy8gV2UgY2FsY3VsYXRlIG5vaXNlIG9uY2UgcGVyIGZyYW1lIHBlciBwb2ludCB0byBlbnN1cmUgdGhhdCB0aGUgUmliYm9uIEZpbGwgYW5kXG4gICAgICAgICAgICAvLyBOZW9uIFN0cm9rZSBwYXNzZXMgdXNlIGlkZW50aWNhbCBnZW9tZXRyeSwgcHJldmVudGluZyB2aXN1YWwgdGVhcmluZy5cbiAgICAgICAgICAgIGxldCBub2lzZUEgPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiBob3ZlckFtcCAqIGludGVuc2l0eSxcbiAgICAgICAgICAgICAgICBub2lzZUIgPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiBob3ZlckFtcCAqIGludGVuc2l0eSxcbiAgICAgICAgICAgICAgICBzaW5lICAgPSBNYXRoLnNpbigoKHggKyBmcmVxTW9kKSAqIDAuMDQpIC0gdGltZVNoaWZ0KSAqIGxvY2FsQW1wLFxuICAgICAgICAgICAgICAgIHNpbmVCICA9IE1hdGguc2luKCgoeCArIGZyZXFNb2QpICogMC4wNCkgLSB0aW1lU2hpZnQgKyBNYXRoLlBJKSAqIGxvY2FsQW1wOyAvLyBJbnZlcnRlZFxuXG4gICAgICAgICAgICAvLyBTSE9DS1dBVkUgUEhZU0lDUyAoRGlzcGxhY2VtZW50KVxuICAgICAgICAgICAgbGV0IHNob2NrWSA9IDA7XG4gICAgICAgICAgICBpZiAobWUuc2hvY2t3YXZlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbWUuc2hvY2t3YXZlcy5mb3JFYWNoKHdhdmUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmFkaXVzID0gd2F2ZS5hZ2UgKiB3YXZlLnNwZWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzdCAgID0geCAtIHdhdmUueDsgLy8gU2lnbmVkIGRpc3RhbmNlXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgcG9pbnQgaXMgbmVhciB0aGUgd2F2ZSBmcm9udCAoZS5nLiB3aXRoaW4gNTBweClcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGRpc3QpIDwgcmFkaXVzICYmIE1hdGguYWJzKGRpc3QpID4gcmFkaXVzIC0gNjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFB1bHNlIHNoYXBlOiBTaW5lIHdhdmUgYmFzZWQgb24gZGlzdGFuY2UgZnJvbSBjZW50ZXIgcmVsYXRpdmUgdG8gcmFkaXVzXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcHVsc2UgPSBNYXRoLnNpbigoZGlzdCAvIHJhZGl1cykgKiBNYXRoLlBJICogMTApICogKDEgLSAod2F2ZS5hZ2UgLyB3YXZlLmxpZmUpKSAqIDIwO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvY2tZICs9IHB1bHNlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXcml0ZSBZIHZhbHVlcyB0byBidWZmZXJzXG4gICAgICAgICAgICBidWZBW2ldID0gY2VudGVyWSArIHNpbmUgIC0gb2Zmc2V0WSArIG5vaXNlQSArIHNob2NrWTtcbiAgICAgICAgICAgIGJ1ZkJbaV0gPSBjZW50ZXJZICsgc2luZUIgKyBvZmZzZXRZICsgbm9pc2VCICsgc2hvY2tZO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtzaGltbWVyQSwgc2hpbW1lckIsIGNvdW50fVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYXdzIHRoZSBcIkV0aGVyXCIgcGFydGljbGUgZmllbGQgdG8gYWRkIHZvbHVtZXRyaWMgZGVwdGggYW5kIGludGVyYWN0aXZpdHkuXG4gICAgICpcbiAgICAgKiAqKkludGVudDoqKlxuICAgICAqIENyZWF0ZXMgYSBsaXZpbmcsIGJyZWF0aGluZyBhdG1vc3BoZXJlIChcIk5lbyBFdGhlclwiKSB0aGF0IGZpbGxzIHRoZSBuZWdhdGl2ZSBzcGFjZS5cbiAgICAgKiBUaGlzIGJyaWRnZXMgdGhlIHZpc3VhbCBnYXAgYmV0d2VlbiB0aGUgc3Rhcmsgd2hpdGUgYmFja2dyb3VuZCBhbmQgdGhlIGhpZ2gtY29udHJhc3QgZm9yZWdyb3VuZCBsaW5lcy5cbiAgICAgKlxuICAgICAqICoqUGh5c2ljczoqKlxuICAgICAqIC0gKipEcmlmdDoqKiBQYXJ0aWNsZXMgbW92ZSB3aXRoIGEgY29uc3RhbnQgYHZ4YCB0byBzaW11bGF0ZSBkYXRhIGZsb3cgb3Igd2luZC5cbiAgICAgKiAtICoqUmVwdWxzaW9uOioqIFRoZSBtb3VzZSBjdXJzb3IgYWN0cyBhcyBhIFwicmVwdWxzb3IgZmllbGQsXCIgcHVzaGluZyBwYXJ0aWNsZXMgYXdheSBhbmQgYnJpZ2h0ZW5pbmcgdGhlbVxuICAgICAqICAgdG8gY3JlYXRlIGEgXCJob2xlXCIgaW4gdGhlIGZvZy5cbiAgICAgKiAtICoqTmVidWxhZToqKiBMYXJnZSwgZmFpbnQgcGFydGljbGVzIGNyZWF0ZSBhIFwiZm9nXCIgZWZmZWN0LCB3aGlsZSBzbWFsbCwgYnJpZ2h0IHBhcnRpY2xlcyBhY3QgYXMgXCJkdXN0LlwiXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqL1xuICAgIGRyYXdQYXJ0aWNsZXMoY3R4LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIHRoZW1lQ29sb3JzID0gbWUuY29uc3RydWN0b3IuY29sb3JzW21lLnRoZW1lXSxcbiAgICAgICAgICAgIHBDb2xvciAgICAgID0gdGhlbWVDb2xvcnMucGFydGljbGU7XG5cbiAgICAgICAgbWUucGFydGljbGVzLmZvckVhY2gocCA9PiB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgUG9zaXRpb25cbiAgICAgICAgICAgIHAueCArPSBwLnZ4O1xuICAgICAgICAgICAgcC55ICs9IHAudnk7XG5cbiAgICAgICAgICAgIC8vIFdyYXAgYXJvdW5kXG4gICAgICAgICAgICBpZiAocC54ID4gd2lkdGggKyBwLnNpemUpICBwLnggPSAtcC5zaXplO1xuICAgICAgICAgICAgaWYgKHAueCA8IC1wLnNpemUpICAgICAgICAgcC54ID0gd2lkdGggKyBwLnNpemU7XG4gICAgICAgICAgICBpZiAocC55ID4gaGVpZ2h0ICsgcC5zaXplKSBwLnkgPSAtcC5zaXplO1xuICAgICAgICAgICAgaWYgKHAueSA8IC1wLnNpemUpICAgICAgICAgcC55ID0gaGVpZ2h0ICsgcC5zaXplO1xuXG4gICAgICAgICAgICAvLyBJbnRlcmFjdGlvbjogTW91c2UgUmVwdWxzaW9uXG4gICAgICAgICAgICAvLyBBbGwgcGFydGljbGVzIHJlYWN0IHRvIHRoZSBtb3VzZSwgYnV0IFwiTmVidWxhXCIgcGFydGljbGVzIGhhdmUgaGlnaGVyIGNhbGN1bGF0ZWQgbWFzcyxcbiAgICAgICAgICAgIC8vIHJlc3VsdGluZyBpbiBsZXNzIGRpc3BsYWNlbWVudCB0aGFuIHRoZSBsaWdodGVyIFwiRHVzdFwiIHBhcnRpY2xlcy5cbiAgICAgICAgICAgIGxldCBkeCA9IHAueCAtIG1lLm1vdXNlLngsXG4gICAgICAgICAgICAgICAgZHkgPSBwLnkgLSBtZS5tb3VzZS55LFxuICAgICAgICAgICAgICAgIGRpc3QgPSBNYXRoLnNxcnQoZHgqZHggKyBkeSpkeSksXG4gICAgICAgICAgICAgICAgbWF4RGlzdCA9IHAuaXNOZWJ1bGEgPyAxNTAgOiAxMDA7XG5cbiAgICAgICAgICAgIGlmIChkaXN0IDwgbWF4RGlzdCAmJiBkaXN0ID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBmb3JjZSA9IChtYXhEaXN0IC0gZGlzdCkgLyBtYXhEaXN0O1xuICAgICAgICAgICAgICAgIC8vIFB1c2ggYXdheVxuICAgICAgICAgICAgICAgIGxldCBtYXNzID0gcC5pc05lYnVsYSA/IDUgOiAxO1xuICAgICAgICAgICAgICAgIHAueCArPSAoZHggLyBkaXN0KSAqIGZvcmNlICogKDIgLyBtYXNzKTtcbiAgICAgICAgICAgICAgICBwLnkgKz0gKGR5IC8gZGlzdCkgKiBmb3JjZSAqICgyIC8gbWFzcyk7XG4gICAgICAgICAgICAgICAgLy8gQnJpZ2h0ZW4gc2xpZ2h0bHlcbiAgICAgICAgICAgICAgICBwLmFscGhhID0gTWF0aC5taW4ocC5iYXNlQWxwaGEgKyBmb3JjZSAqIChwLmlzTmVidWxhID8gMC4wNSA6IDAuNSksIDAuOCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEludGVyYWN0aW9uOiBTaG9ja3dhdmUgUmVwdWxzaW9uXG4gICAgICAgICAgICBpZiAobWUuc2hvY2t3YXZlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbWUuc2hvY2t3YXZlcy5mb3JFYWNoKHdhdmUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgd3ggICAgID0gcC54IC0gd2F2ZS54LFxuICAgICAgICAgICAgICAgICAgICAgICAgd3kgICAgID0gcC55IC0gd2F2ZS55LFxuICAgICAgICAgICAgICAgICAgICAgICAgd0Rpc3QgID0gTWF0aC5zcXJ0KHd4ICogd3ggKyB3eSAqIHd5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhZGl1cyA9IHdhdmUuYWdlICogd2F2ZS5zcGVlZDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBwYXJ0aWNsZSBpcyBuZWFyIHRoZSBleHBhbmRpbmcgcmluZyAod2lkdGggNDBweClcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdEaXN0IDwgcmFkaXVzICYmIHdEaXN0ID4gcmFkaXVzIC0gNDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmb3JjZSA9ICgxIC0gKHdhdmUuYWdlIC8gd2F2ZS5saWZlKSkgKiAyOyAvLyBEZWNheSBmb3JjZSBvdmVyIHRpbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFB1c2ggb3V0d2FyZFxuICAgICAgICAgICAgICAgICAgICAgICAgcC54ICs9ICh3eCAvIHdEaXN0KSAqIGZvcmNlICogNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAueSArPSAod3kgLyB3RGlzdCkgKiBmb3JjZSAqIDU7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmFscGhhID0gTWF0aC5taW4ocC5hbHBoYSArIDAuMywgMSkgLy8gRmxhc2ggYnJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXR1cm4gdG8gYmFzZSBhbHBoYVxuICAgICAgICAgICAgaWYgKHAuYWxwaGEgPiBwLmJhc2VBbHBoYSkge1xuICAgICAgICAgICAgICAgIHAuYWxwaGEgLT0gMC4wMDVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gcC5hbHBoYTtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgICAgICAgaWYgKHAuaXNOZWJ1bGEpIHtcbiAgICAgICAgICAgICAgICAvLyBOZWJ1bGEgVmlzdWFsaXphdGlvblxuICAgICAgICAgICAgICAgIC8vIFVzZSBhIHJhZGlhbCBncmFkaWVudCB0byBjcmVhdGUgYSBzb2Z0LCBjbG91ZC1saWtlIGFwcGVhcmFuY2UuXG4gICAgICAgICAgICAgICAgbGV0IGcgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQocC54LCBwLnksIDAsIHAueCwgcC55LCBwLnNpemUpO1xuICAgICAgICAgICAgICAgIGcuYWRkQ29sb3JTdG9wKDAsIHBDb2xvcik7XG4gICAgICAgICAgICAgICAgZy5hZGRDb2xvclN0b3AoMSwgJ3JnYmEoMjU1LDI1NSwyNTUsMCknKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZztcbiAgICAgICAgICAgICAgICBjdHguYXJjKHAueCwgcC55LCBwLnNpemUsIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBwQ29sb3I7XG4gICAgICAgICAgICAgICAgY3R4LmFyYyhwLngsIHAueSwgcC5zaXplLCAwLCBNYXRoLlBJICogMik7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgYW4gYWRkaXRpb25hbCBoaWdobGlnaHQgZm9yIHRoZSBhY3RpdmUgbmF2aWdhdGlvbiBpdGVtLlxuICAgICAqICoqXCJFbmVyZ3kgU3VyZ2VcIiBFZmZlY3Q6KipcbiAgICAgKiBSZW5kZXJzIGEgaGlnaC1pbnRlbnNpdHkgcGFzcyBvZiB0aGUgZW5lcmd5IHN0cmFuZHMgKm9ubHkqIHdpdGhpbiB0aGUgYWN0aXZlIHpvbmUuXG4gICAgICogVGhpcyBtYWtlcyB0aGUgbGluZXMgYXBwZWFyIHRvIFwicG93ZXIgdXBcIiBvciBnbG93IHdoaXRlLWhvdCBhcyB0aGV5IHBhc3MgdGhyb3VnaCB0aGUgYWN0aXZlIHZpZXcsXG4gICAgICogZnVsbHkgaW50ZWdyYXRlZCB3aXRoIHRoZSBleGlzdGluZyBnZW9tZXRyeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICAgKi9cbiAgICBkcmF3QWN0aXZlT3ZlcmxheShjdHgsIHdpZHRoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICByZWN0O1xuXG4gICAgICAgIGlmICghbWUuYWN0aXZlSWQgfHwgIW1lLndhdmVCdWZmZXJzLmZnQSkgcmV0dXJuO1xuXG4gICAgICAgIC8vIFplcm8tQWxsb2NhdGlvbjogVXNlIGZvci1sb29wIGluc3RlYWQgb2YgLmZpbmQoKSB0byBhdm9pZCBjbG9zdXJlIGNyZWF0aW9uXG4gICAgICAgIGZvciAoY29uc3QgciBvZiBtZS5uYXZSZWN0cykge1xuICAgICAgICAgICAgaWYgKHIuaWQgPT09IG1lLmFjdGl2ZUlkKSB7XG4gICAgICAgICAgICAgICAgcmVjdCA9IHI7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVjdCkgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBzdGVwICAgPSAyLCAvLyBNdXN0IG1hdGNoIGNhbGN1bGF0ZVN0cmFuZEdlb21ldHJ5XG4gICAgICAgICAgICAvLyBBZGQgcGFkZGluZyB0byBmYWRlIHRoZSBlZmZlY3QgaW4vb3V0IHNtb290aGx5XG4gICAgICAgICAgICBwYWQgICAgPSAxMCxcbiAgICAgICAgICAgIHN0YXJ0WCA9IE1hdGgubWF4KDAsIHJlY3QueCAtIHBhZCksXG4gICAgICAgICAgICBlbmRYICAgPSBNYXRoLm1pbih3aWR0aCwgcmVjdC54ICsgcmVjdC53aWR0aCArIHBhZCksXG4gICAgICAgICAgICBzdGFydEkgPSBNYXRoLmZsb29yKHN0YXJ0WCAvIHN0ZXApLFxuICAgICAgICAgICAgZW5kSSAgID0gTWF0aC5jZWlsKGVuZFggLyBzdGVwKSxcbiAgICAgICAgICAgIGJ1ZkEgICA9IG1lLndhdmVCdWZmZXJzLmZnQSxcbiAgICAgICAgICAgIGJ1ZkIgICA9IG1lLndhdmVCdWZmZXJzLmZnQjtcblxuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHgubGluZUNhcCAgPSAncm91bmQnO1xuICAgICAgICBjdHgubGluZUpvaW4gPSAncm91bmQnO1xuXG4gICAgICAgIC8vIEhpZ2gtSW50ZW5zaXR5IEdsb3dcbiAgICAgICAgY3R4LnNoYWRvd0JsdXIgID0gMjA7XG4gICAgICAgIGN0eC5zaGFkb3dDb2xvciA9ICcjRkZGRkZGJzsgLy8gV2hpdGUgZ2xvd1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnI0ZGRkZGRic7IC8vIFdoaXRlIGNvcmVcbiAgICAgICAgY3R4LmxpbmVXaWR0aCAgID0gMjtcblxuICAgICAgICAvLyBHcmFkaWVudCBGYWRlIG1hc2sgKG1hbnVhbCBhbHBoYSlcbiAgICAgICAgLy8gV2UgY2FuJ3QgZWFzaWx5IGdyYWRpZW50LXN0cm9rZSBhIHN1Yi1wYXRoLCBzbyB3ZSByZWx5IG9uIGdsb2JhbEFscGhhXG4gICAgICAgIC8vIGNvbWJpbmVkIHdpdGggdGhlIFwiaG90XCIgd2hpdGUgY29sb3IgdG8gbWFrZSBpdCBwb3AuXG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuNiArIChNYXRoLnNpbihtZS50aW1lICogMykgKiAwLjIpOyAvLyBGYXN0LCBuZXJ2b3VzIHB1bHNlXG5cbiAgICAgICAgLy8gSW5saW5lIGRyYXdpbmcgdG8gYXZvaWQgY2xvc3VyZVxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8oc3RhcnRJICogc3RlcCwgYnVmQVtzdGFydEldKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0SSArIDE7IGkgPD0gZW5kSTsgaSsrKSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKGkgKiBzdGVwLCBidWZBW2ldKVxuICAgICAgICB9XG4gICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8oc3RhcnRJICogc3RlcCwgYnVmQltzdGFydEldKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0SSArIDE7IGkgPD0gZW5kSTsgaSsrKSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKGkgKiBzdGVwLCBidWZCW2ldKVxuICAgICAgICB9XG4gICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICBjdHgucmVzdG9yZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgYW4gYWRkaXRpb25hbCBoaWdobGlnaHQgZm9yIHRoZSBob3ZlcmVkIG5hdmlnYXRpb24gaXRlbS5cbiAgICAgKiAqKlwiUHJldmlld1wiIEVmZmVjdDoqKlxuICAgICAqIFJlbmRlcnMgYSBzdGF0aWMgaW50ZW5zaXR5IHBhc3Mgb2YgdGhlIGVuZXJneSBzdHJhbmRzIHdpdGhpbiB0aGUgaG92ZXJlZCB6b25lLlxuICAgICAqIFVzZXMgdGhlIHRoZW1lLXNwZWNpZmljIGhvdmVyIGNvbG9yIChDeWFuL0JsdWUpIHRvIGRpc3Rpbmd1aXNoIGl0IGZyb20gdGhlIGFjdGl2ZSBzdGF0ZSAoV2hpdGUpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqL1xuICAgIGRyYXdIb3Zlck92ZXJsYXkoY3R4LCB3aWR0aCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgcmVjdDtcblxuICAgICAgICBpZiAoIW1lLmhvdmVySWQgfHwgIW1lLndhdmVCdWZmZXJzLmZnQSkgcmV0dXJuO1xuXG4gICAgICAgIC8vIFplcm8tQWxsb2NhdGlvbjogVXNlIGZvci1sb29wIGluc3RlYWQgb2YgLmZpbmQoKSB0byBhdm9pZCBjbG9zdXJlIGNyZWF0aW9uXG4gICAgICAgIGZvciAoY29uc3QgciBvZiBtZS5uYXZSZWN0cykge1xuICAgICAgICAgICAgaWYgKHIuaWQgPT09IG1lLmhvdmVySWQpIHtcbiAgICAgICAgICAgICAgICByZWN0ID0gcjtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZWN0KSByZXR1cm47XG5cbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIHN0ZXAgICAgICAgID0gMiwgLy8gTXVzdCBtYXRjaCBjYWxjdWxhdGVTdHJhbmRHZW9tZXRyeVxuICAgICAgICAgICAgcGFkICAgICAgICAgPSAxMCxcbiAgICAgICAgICAgIHN0YXJ0WCAgICAgID0gTWF0aC5tYXgoMCwgcmVjdC54IC0gcGFkKSxcbiAgICAgICAgICAgIGVuZFggICAgICAgID0gTWF0aC5taW4od2lkdGggLSAzLCByZWN0LnggKyByZWN0LndpZHRoICsgcGFkKSxcbiAgICAgICAgICAgIHN0YXJ0SSAgICAgID0gTWF0aC5mbG9vcihzdGFydFggLyBzdGVwKSxcbiAgICAgICAgICAgIGVuZEkgICAgICAgID0gTWF0aC5jZWlsKGVuZFggLyBzdGVwKSxcbiAgICAgICAgICAgIGJ1ZkEgICAgICAgID0gbWUud2F2ZUJ1ZmZlcnMuZmdBLFxuICAgICAgICAgICAgYnVmQiAgICAgICAgPSBtZS53YXZlQnVmZmVycy5mZ0IsXG4gICAgICAgICAgICB0aGVtZUNvbG9ycyA9IG1lLmNvbnN0cnVjdG9yLmNvbG9yc1ttZS50aGVtZV07XG5cbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LmxpbmVDYXAgID0gJ3JvdW5kJztcbiAgICAgICAgY3R4LmxpbmVKb2luID0gJ3JvdW5kJztcblxuICAgICAgICAvLyBIb3ZlciBFZmZlY3Q6IFN0YXRpYyBHbG93IChObyBQdWxzZSlcbiAgICAgICAgY3R4LnNoYWRvd0JsdXIgID0gMTU7XG4gICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IHRoZW1lQ29sb3JzLmhvdmVyO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGVtZUNvbG9ycy5ob3ZlcjtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCAgID0gMjtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcblxuICAgICAgICAvLyBJbmxpbmUgZHJhd2luZyB0byBhdm9pZCBjbG9zdXJlXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhzdGFydEkgKiBzdGVwLCBidWZBW3N0YXJ0SV0pO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJICsgMTsgaSA8PSBlbmRJOyBpKyspIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oaSAqIHN0ZXAsIGJ1ZkFbaV0pXG4gICAgICAgIH1cbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhzdGFydEkgKiBzdGVwLCBidWZCW3N0YXJ0SV0pO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJICsgMTsgaSA8PSBlbmRJOyBpKyspIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oaSAqIHN0ZXAsIGJ1ZkJbaV0pXG4gICAgICAgIH1cbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgIGN0eC5yZXN0b3JlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBhIHN1YnRsZSwgbGFyZ2Utc2NhbGUgYmFja2dyb3VuZCBIZWxpeCBwYXR0ZXJuIHdpdGggYSAzRCBSaWJib24gZWZmZWN0LlxuICAgICAqXG4gICAgICogKipJbnRlbnQ6KipcbiAgICAgKiBQcm92aWRlcyBhIHN0cnVjdHVyYWwgYmFja2JvbmUgdG8gdGhlIG5lZ2F0aXZlIHNwYWNlLiBVbmxpa2UgdGhlIHBhcnRpY2xlIGZpZWxkICh3aGljaCBpcyBjaGFvdGljKSxcbiAgICAgKiB0aGlzIGxheWVyIGlzIG9yZGVyZWQgYW5kIHJoeXRobWljLCByZWluZm9yY2luZyB0aGUgXCJETkEvSGVsaXhcIiB0aGVtZSBldmVuIGluIHRoZSBiYWNrZ3JvdW5kLlxuICAgICAqXG4gICAgICogKipWaXN1YWxzOioqXG4gICAgICogMS4gKipSaWJib24gRmlsbDoqKiBBIGJhcmVseS12aXNpYmxlIHZvbHVtZXRyaWMgZ3JhZGllbnQgZmlsbHMgdGhlIHNwYWNlIGJldHdlZW4gdGhlIGhlbGljZXMuXG4gICAgICogMi4gKipEZXB0aCBvZiBGaWVsZDoqKiBVc2VzIHdpZGUsIHZlcnkgbG93IG9wYWNpdHkgc3Ryb2tlcyB0byBhcHBlYXIgXCJvdXQgb2YgZm9jdXNcIiBiZWhpbmQgdGhlIHNoYXJwIGZvcmVncm91bmQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqL1xuICAgIGRyYXdBbWJpZW50QmFja2dyb3VuZChjdHgsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvLyBFbnN1cmUgYnVmZmVycyBleGlzdFxuICAgICAgICBpZiAoIW1lLndhdmVCdWZmZXJzLmJnQSkgcmV0dXJuO1xuXG4gICAgICAgIGxldCB0ICAgICAgID0gbWUudGltZSAqIDAuNSxcbiAgICAgICAgICAgIGNlbnRlclkgPSBoZWlnaHQgLyAyLFxuICAgICAgICAgICAgYW1wICAgICA9IGhlaWdodCAqIDAuNCxcbiAgICAgICAgICAgIHN0ZXAgICAgPSAxMCxcbiAgICAgICAgICAgIGNvdW50ICAgPSBNYXRoLmNlaWwod2lkdGggLyBzdGVwKSxcbiAgICAgICAgICAgIGJ1ZkEgICAgPSBtZS53YXZlQnVmZmVycy5iZ0EsXG4gICAgICAgICAgICBidWZCICAgID0gbWUud2F2ZUJ1ZmZlcnMuYmdCO1xuXG4gICAgICAgIC8vIDEuIENhbGN1bGF0ZSBQb2ludHMgKERpcmVjdCB0byBCdWZmZXIpXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IHggPSBpICogc3RlcDtcbiAgICAgICAgICAgIGJ1ZkFbaV0gPSBjZW50ZXJZICsgTWF0aC5zaW4oKHggKiAwLjAxKSArIHQpICogYW1wO1xuICAgICAgICAgICAgYnVmQltpXSA9IGNlbnRlclkgKyBNYXRoLnNpbigoeCAqIDAuMDEpICsgdCArIE1hdGguUEkpICogYW1wXG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0gMi4gUklCQk9OIEZJTEwgKEJhY2tncm91bmQgU3VyZmFjZSkgLS0tXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBtZS5ncmFkaWVudHMuYmdSaWJib247XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgICBjdHgubW92ZVRvKDAsIGJ1ZkFbMF0pO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oaSAqIHN0ZXAsIGJ1ZkFbaV0pXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gY291bnQgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhpICogc3RlcCwgYnVmQltpXSlcbiAgICAgICAgfVxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGN0eC5maWxsKCk7XG5cbiAgICAgICAgLy8gLS0tIDMuIFNUUk9LRVMgLS0tXG4gICAgICAgIGN0eC5saW5lV2lkdGggPSAxNTtcbiAgICAgICAgY3R4LmxpbmVDYXAgICA9ICdyb3VuZCc7XG4gICAgICAgIGN0eC5saW5lSm9pbiAgPSAncm91bmQnO1xuXG4gICAgICAgIC8vIFVzZSBjYWNoZWQgZ3JhZGllbnRzXG4gICAgICAgIGNvbnN0IGRyYXdTdHJva2UgPSAoYnVmZmVyLCBzdHJva2VTdHlsZSkgPT4ge1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGU7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKDAsIGJ1ZmZlclswXSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKGkgKiBzdGVwLCBidWZmZXJbaV0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguc3Ryb2tlKClcbiAgICAgICAgfTtcblxuICAgICAgICBkcmF3U3Ryb2tlKGJ1ZkEsIG1lLmdyYWRpZW50cy5iZ0dyYWQxKTtcbiAgICAgICAgZHJhd1N0cm9rZShidWZCLCBtZS5ncmFkaWVudHMuYmdHcmFkMik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIG1haW4gZm9yZWdyb3VuZCBcIlNwbGl0IFN0cmVhbVwiIGVuZXJneSBzdHJhbmRzIHdpdGggM0QgZWZmZWN0cy5cbiAgICAgKlxuICAgICAqICoqM0QgQXJjaGl0ZWN0dXJlOioqXG4gICAgICogMS4gKipSaWJib24gRmlsbDoqKiBEcmF3cyBhIGxvdy1vcGFjaXR5IGdyYWRpZW50IGJldHdlZW4gU3RyYW5kIEEgYW5kIFN0cmFuZCBCLCBjcmVhdGluZyBhIHR3aXN0aW5nIHN1cmZhY2UuXG4gICAgICogMi4gKipOZW9uIFR1YmUgKE91dGVyKToqKiBUaGUgY29sb3JlZCBnbG93IG9mIHRoZSBzdHJhbmRzLlxuICAgICAqIDMuICoqTmVvbiBUdWJlIChDb3JlKToqKiBBIGJyaWdodCB3aGl0ZSBpbm5lciBjb3JlIHRvIHNpbXVsYXRlIHZvbHVtZXRyaWMgbGlnaHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzU3RyZXNzZWQ9ZmFsc2VdXG4gICAgICovXG4gICAgZHJhd0F1cmFzKGN0eCwgd2lkdGgsIGhlaWdodCwgaXNTdHJlc3NlZD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZS5uYXZSZWN0cykpIHJldHVybjtcblxuICAgICAgICAvLyAxLiBDYWxjdWxhdGUgUGh5c2ljcyAoU2hhcmVkIGZvciBSaWJib24gYW5kIFN0cmFuZHMpIC0gUmV0dXJucyBtZXRhZGF0YSwgZGF0YSBpcyBpbiBidWZmZXJzXG4gICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gbWUuY2FsY3VsYXRlU3RyYW5kR2VvbWV0cnkod2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgaWYgKCFnZW9tZXRyeSkgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICB7c2hpbW1lckEsIHNoaW1tZXJCLCBjb3VudH0gPSBnZW9tZXRyeSxcbiAgICAgICAgICAgIGJ1ZkEgICAgICAgID0gbWUud2F2ZUJ1ZmZlcnMuZmdBLFxuICAgICAgICAgICAgYnVmQiAgICAgICAgPSBtZS53YXZlQnVmZmVycy5mZ0IsXG4gICAgICAgICAgICBzdGVwICAgICAgICA9IDIsXG4gICAgICAgICAgICB0aGVtZUNvbG9ycyA9IG1lLmNvbnN0cnVjdG9yLmNvbG9yc1ttZS50aGVtZV07XG5cbiAgICAgICAgLy8gLS0tIDIuIFJJQkJPTiBGSUxMIChUaGUgM0QgU3VyZmFjZSkgLS0tXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBtZS5ncmFkaWVudHMuZmdSaWJib247XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgICBjdHgubW92ZVRvKDAsIGJ1ZkFbMF0pO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oaSAqIHN0ZXAsIGJ1ZkFbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IGNvdW50IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oaSAqIHN0ZXAsIGJ1ZkJbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcblxuICAgICAgICAvLyAtLS0gMy4gTkVPTiBTVFJBTkRTIChUdWJlIEVmZmVjdCkgLS0tXG5cbiAgICAgICAgY3R4LmxpbmVDYXAgICAgID0gJ3JvdW5kJztcbiAgICAgICAgY3R4LmxpbmVKb2luICAgID0gJ3JvdW5kJztcblxuICAgICAgICAvLyBIZWxwZXIgdG8gZHJhdyBhIHN0cmFuZCBmcm9tIGJ1ZmZlclxuICAgICAgICBjb25zdCBkcmF3U3RyYW5kID0gKGJ1ZmZlciwgZ3JhZGllbnQsIHNoaW1tZXIsIGNvbG9yLCBpc0NvcmUsIG92ZXJsYXlHcmFkaWVudCwgaGVhdCkgPT4ge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gaXNDb3JlID8gJyNGRkZGRkYnIDogZ3JhZGllbnQ7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoICAgPSBpc0NvcmUgPyAxIDogMztcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGlzQ29yZSA/IChzaGltbWVyICsgMC4yKSA6IHNoaW1tZXI7XG5cbiAgICAgICAgICAgIGlmICghaXNDb3JlKSB7XG4gICAgICAgICAgICAgICAgY3R4LnNoYWRvd0JsdXIgID0gMTA7XG4gICAgICAgICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gY29sb3I7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN0eC5zaGFkb3dCbHVyICA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oMCwgYnVmZmVyWzBdKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oaSAqIHN0ZXAsIGJ1ZmZlcltpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgICAgIC8vIEhvdCBPdmVybGF5IFBhc3NcbiAgICAgICAgICAgIGlmICghaXNDb3JlICYmIGhlYXQgPiAwLjA1ICYmIG92ZXJsYXlHcmFkaWVudCkge1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBvdmVybGF5R3JhZGllbnQ7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCAgID0gMztcbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBoZWF0OyAvLyBGYWRlIGluIGJhc2VkIG9uIHNjcm9sbCBzcGVlZFxuICAgICAgICAgICAgICAgIGN0eC5zaGFkb3dCbHVyICA9IDIwOyAgIC8vIEhvdHRlciBnbG93XG4gICAgICAgICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gJyNGRkZGRkYnO1xuXG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbygwLCBidWZmZXJbMF0pO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKGkgKiBzdGVwLCBidWZmZXJbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRHJhdyBHbG93cyAoT3V0ZXIgVHViZSlcbiAgICAgICAgLy8gRXh0cmFjdCBiYXNlIGNvbG9yIGZyb20gZ3JhZGllbnQgYXJyYXkgZm9yIHNoYWRvd1xuICAgICAgICBjb25zdCBjb2xvcjEgPSB0aGVtZUNvbG9ycy5ncmFkMVswXTtcbiAgICAgICAgY29uc3QgY29sb3IyID0gdGhlbWVDb2xvcnMuZ3JhZDJbMF07XG4gICAgICAgIC8vIERpc2FibGUgaGVhdCBpZiBzdHJlc3NlZCBPUiBpZiBhbmltYXRpb25zIGFyZSBnbG9iYWxseSBkaXNhYmxlZFxuICAgICAgICBjb25zdCBoZWF0ICAgPSAoaXNTdHJlc3NlZCB8fCAhbWUudXNlUHVsc2UpID8gMCA6IE1hdGgubWF4KDAsIG1lLnRpbWVTY2FsZSAtIDEpO1xuXG4gICAgICAgIGRyYXdTdHJhbmQoYnVmQSwgbWUuZ3JhZGllbnRzLmdyYWQxLCBzaGltbWVyQSwgY29sb3IxLCBmYWxzZSwgbWUuZ3JhZGllbnRzLmdyYWQxSG90LCBoZWF0KTtcbiAgICAgICAgZHJhd1N0cmFuZChidWZCLCBtZS5ncmFkaWVudHMuZ3JhZDIsIHNoaW1tZXJCLCBjb2xvcjIsIGZhbHNlLCBtZS5ncmFkaWVudHMuZ3JhZDJIb3QsIGhlYXQpO1xuXG4gICAgICAgIC8vIERyYXcgQ29yZXMgKElubmVyIEZpbGFtZW50KVxuICAgICAgICBkcmF3U3RyYW5kKGJ1ZkEsIG51bGwsIHNoaW1tZXJBLCBudWxsLCB0cnVlKTtcbiAgICAgICAgZHJhd1N0cmFuZChidWZCLCBudWxsLCBzaGltbWVyQiwgbnVsbCwgdHJ1ZSk7XG5cbiAgICAgICAgLy8gQ2xlYW51cDogUmVzZXQgc2hhZG93IGFuZCBhbHBoYSB0byBwcmV2ZW50IGJsZWVkaW5nIGludG8gdGhlIG5leHQgcmVuZGVyIHBhc3NcbiAgICAgICAgY3R4LnNoYWRvd0JsdXIgID0gMDtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBwaHlzaWNzIGZvciBkaXZlcnRpbmcgdGhlIHN0cmVhbSBhcm91bmQgVUkgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiAqKkxvZ2ljOioqXG4gICAgICogMS4gKipEZXRlY3Rpb246KiogSXRlcmF0ZXMgdGhyb3VnaCBgbmF2UmVjdHNgIHRvIGZpbmQgaWYgdGhlIGN1cnJlbnQgYHhgIGlzIG5lYXIgYSBidXR0b24uXG4gICAgICogMi4gKipBZGFwdGl2ZSBHZW9tZXRyeToqKlxuICAgICAqICAgIC0gKipUZXh0IEJ1dHRvbnM6KiogVXNlcyBhIHdpZGUgQ29zaW5lIGVudmVsb3BlIGZvciBzbW9vdGggZmxvdy5cbiAgICAgKiAgICAtICoqSWNvbiBCdXR0b25zOioqIFVzZXMgYSBzaGFycCBDdWJlZCBlbnZlbG9wZSAoYE1hdGgucG93KHgsIDMpYCkgdG8gY3JlYXRlIGEgXCJUaWdodCBPcmJpdFwiIGVmZmVjdC5cbiAgICAgKiAzLiAqKlZlcnRpY2FsIENsYW1waW5nOioqIEVuc3VyZXMgdGhlIGRpdmVyc2lvbiBuZXZlciBwdXNoZXMgdGhlIHdhdmUgb2ZmLWNhbnZhcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAoQ2FudmFzIGhlaWdodClcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggKENhbnZhcyB3aWR0aClcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB7b2Zmc2V0WSwgaW50ZW5zaXR5LCBpc0ljb25ab25lfVxuICAgICAqL1xuICAgIGdldFN0cmVhbU9mZnNldCh4LCBoZWlnaHQsIHdpZHRoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgb2Zmc2V0WSAgID0gMCxcbiAgICAgICAgICAgIGludGVuc2l0eSA9IDAsIC8vIDAgdG8gMSAoSG92ZXIgbWFnbml0dWRlKVxuICAgICAgICAgICAgaXNJY29uWm9uZSA9IDA7IC8vIDAgdG8gMSAoUHJveGltaXR5IHRvIGFuIEljb24gQnV0dG9uKVxuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICB2ZXJ0aWNhbFBhZGRpbmcgPSAxMCxcbiAgICAgICAgICAgIG1heFNhZmVPZmZzZXQgICA9IChoZWlnaHQgLyAyKSAtIHZlcnRpY2FsUGFkZGluZztcblxuICAgICAgICAvLyBDb2xsaXNpb24gRGV0ZWN0aW9uXG4gICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBhbGwgbmF2aWdhdGlvbiBpdGVtcyB0byBkZXRlcm1pbmUgc3RyZWFtIGRpdmVyc2lvbi5cbiAgICAgICAgLy8gR2l2ZW4gdGhlIGxvdyBpdGVtIGNvdW50ICg8MjApLCBhIHNpbXBsZSBsaW5lYXIgc2NhbiBpcyBlZmZpY2llbnQuXG4gICAgICAgIGZvciAoY29uc3QgcmVjdCBvZiBtZS5uYXZSZWN0cykge1xuICAgICAgICAgICAgLy8gQnVmZmVyIHpvbmUgZm9yIHNtb290aCB0cmFuc2l0aW9uXG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSA0MDtcblxuICAgICAgICAgICAgaWYgKHggPj0gcmVjdC54IC0gYnVmZmVyICYmIHggPD0gcmVjdC54ICsgcmVjdC53aWR0aCArIGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBpbnNpZGUgdGhlIGluZmx1ZW5jZSB6b25lIG9mIHRoaXMgYnV0dG9uXG5cbiAgICAgICAgICAgICAgICAvLyBTaGFwZSBEZXRlY3Rpb25cbiAgICAgICAgICAgICAgICAvLyBEaXNjcmltaW5hdGUgYmV0d2VlbiBzcXVhcmUtaXNoIGljb25zIChzb2NpYWxzKSBhbmQgd2lkZSB0ZXh0IGJ1dHRvbnNcbiAgICAgICAgICAgICAgICAvLyB0byBhcHBseSBkaWZmZXJlbnQgZGl2ZXJzaW9uIGVudmVsb3Blcy5cbiAgICAgICAgICAgICAgICBjb25zdFxuICAgICAgICAgICAgICAgICAgICByYXRpbyAgID0gcmVjdC53aWR0aCAvIHJlY3QuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBpc0ljb24gID0gcmF0aW8gPCAxLjUsIC8vIFRocmVzaG9sZCBmb3IgXCJDaXJjbGVcIiB2cyBcIlJlY3RhbmdsZVwiXG4gICAgICAgICAgICAgICAgICAgIGNlbnRlclggPSByZWN0LnggKyByZWN0LndpZHRoIC8gMixcbiAgICAgICAgICAgICAgICAgICAgc3BhbiAgICA9IChyZWN0LndpZHRoIC8gMikgKyBidWZmZXIsXG4gICAgICAgICAgICAgICAgICAgIGRpc3RYICAgPSBNYXRoLmFicyh4IC0gY2VudGVyWCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGlzdFggPCBzcGFuKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlbnZlbG9wZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNJY29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUSUdIVCBPUkJJVCAoU2hhcnBlciBjdXJ2ZSBmb3IgaWNvbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm9ybURpc3QgPSBkaXN0WCAvIHNwYW47IC8vIDAgdG8gMVxuICAgICAgICAgICAgICAgICAgICAgICAgZW52ZWxvcGUgPSBNYXRoLnBvdygoMSArIE1hdGguY29zKE1hdGguUEkgKiBub3JtRGlzdCkpIC8gMiwgMyk7IC8vIEN1YmVkIGZvciBzaGFycGVyIGZhbGxvZmZcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzSWNvblpvbmUgPSBNYXRoLm1heChpc0ljb25ab25lLCBlbnZlbG9wZSk7IC8vIFRyYWNrIGlmIHdlIGFyZSBpbiBhbiBpY29uIHpvbmVcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdJREUgRkxPVyAoU3RhbmRhcmQgc21vb3RoIGN1cnZlIGZvciB0ZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgZW52ZWxvcGUgPSAoMSArIE1hdGguY29zKE1hdGguUEkgKiBkaXN0WCAvIHNwYW4pKSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBEaXZlcnNpb24gQW1wbGl0dWRlXG4gICAgICAgICAgICAgICAgICAgIC8vIFRleHQgYnV0dG9ucyByZXF1aXJlIG1vcmUgdmlzdWFsIGNsZWFyYW5jZSB0aGFuIGljb25zIGR1ZSB0byB0aGVpclxuICAgICAgICAgICAgICAgICAgICAvLyByZWN0YW5ndWxhciBuYXR1cmUuIEljb25zIGFsbG93IGZvciBhIHRpZ2h0ZXIgXCJvcmJpdFwiLlxuICAgICAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0SCA9IGlzSWNvbiA/IChyZWN0LmhlaWdodCAvIDIpIDogKChyZWN0LmhlaWdodCAvIDIpICsgNCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVmVydGljYWwgQ2xhbXBpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FwIHRoZSBvZmZzZXQgdG8gZW5zdXJlIHRoZSBzdHJlYW0gc3RheXMgd2l0aGluIHRoZSBjYW52YXMgYm91bmRzLlxuICAgICAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0T2Zmc2V0ID0gTWF0aC5taW4odGFyZ2V0SCwgbWF4U2FmZU9mZnNldCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRvIHRvdGFsIG9mZnNldCAodXNpbmcgbWF4IHRvIGhhbmRsZSBvdmVybGFwcyBjbGVhbmx5KVxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRZID0gTWF0aC5tYXgob2Zmc2V0WSwgdGFyZ2V0T2Zmc2V0ICogZW52ZWxvcGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEludGVyYWN0aW9uOiBQcm94aW1pdHkgQ2hlY2tcbiAgICAgICAgICAgICAgICAgICAgLy8gQm9vc3QgdGhlIHdhdmUgaW50ZW5zaXR5IGlmIHRoZSBtb3VzZSBpcyBob3ZlcmluZyBvdmVyIG9yIG5lYXIgdGhpcyBzcGVjaWZpYyBidXR0b24uXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRGlzdGFuY2UgZnJvbSBtb3VzZSB0byBidXR0b24gY2VudGVyXG4gICAgICAgICAgICAgICAgICAgIGxldCBkeCA9IG1lLm1vdXNlLnggLSBjZW50ZXJYLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHkgPSBtZS5tb3VzZS55IC0gKHJlY3QueSArIHJlY3QuaGVpZ2h0LzIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzdE1vdXNlID0gTWF0aC5zcXJ0KGR4KmR4ICsgZHkqZHkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG1vdXNlIGlzIG5lYXIgdGhpcyBidXR0b24sIGJvb3N0IGludGVuc2l0eVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdE1vdXNlIDwgTWF0aC5tYXgocmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlbnNpdHkgPSBNYXRoLm1heChpbnRlbnNpdHksIDEgLSAoZGlzdE1vdXNlIC8gMTUwKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCYXNlbGluZSBTZXBhcmF0aW9uXG4gICAgICAgIC8vIEJ5IHJldHVybmluZyBvZmZzZXRZPTAgaW4gZW1wdHkgc3BhY2UsIHRoZSBzdHJhbmRzIHdpbGwgbmF0dXJhbGx5IGNyb3NzIChIZWxpeCBlZmZlY3QpXG4gICAgICAgIC8vIGRyaXZlbiBieSB0aGUgc2luZSB3YXZlIGxvZ2ljIGluIGNhbGN1bGF0ZVN0cmFuZFBvaW50cy5cbiAgICAgICAgcmV0dXJuIHtvZmZzZXRZLCBpbnRlbnNpdHksIGlzSWNvblpvbmV9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYXdzIGV4cGFuZGluZyBzaG9ja3dhdmVzIGZyb20gY2xpY2tzLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICAgKi9cbiAgICBkcmF3U2hvY2t3YXZlcyhjdHgsIHdpZHRoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLnNob2Nrd2F2ZXMubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICAgICAgY29uc3QgdGhlbWVDb2xvcnMgPSBtZS5jb25zdHJ1Y3Rvci5jb2xvcnNbbWUudGhlbWVdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBtZS5zaG9ja3dhdmVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgd2F2ZSA9IG1lLnNob2Nrd2F2ZXNbaV07XG5cbiAgICAgICAgICAgIHdhdmUuYWdlICs9IDE7XG5cbiAgICAgICAgICAgIGxldCBwcm9ncmVzcyA9IHdhdmUuYWdlIC8gd2F2ZS5saWZlO1xuXG4gICAgICAgICAgICBpZiAocHJvZ3Jlc3MgPj0gMSkge1xuICAgICAgICAgICAgICAgIG1lLnNob2Nrd2F2ZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERyYXcgdHdvIGxpbmVzIHByb3BhZ2F0aW5nIG91dCBmcm9tIHRoZSBjbGljayBwb2ludFxuICAgICAgICAgICAgbGV0IHhMZWZ0ICAgID0gd2F2ZS54IC0gKHdhdmUuc3BlZWQgKiB3YXZlLmFnZSksXG4gICAgICAgICAgICAgICAgeFJpZ2h0ICAgPSB3YXZlLnggKyAod2F2ZS5zcGVlZCAqIHdhdmUuYWdlKSxcbiAgICAgICAgICAgICAgICBhbHBoYSAgICA9IDEgLSBwcm9ncmVzcyxcbiAgICAgICAgICAgICAgICB7aGVpZ2h0fSA9IG1lLmNhbnZhc1NpemU7XG5cbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoZW1lQ29sb3JzLnNob2Nrd2F2ZTsgLy8gVXNlIHRoZW1lIGNvbG9yXG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBhbHBoYTsgICAgIC8vIEZhZGUgb3V0IHZpYSBnbG9iYWxBbHBoYVxuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCAgID0gNCAqICgxIC0gcHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgICAvLyBMZWZ0IFdhdmVcbiAgICAgICAgICAgIGlmICh4TGVmdCA+IDApIHtcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHhMZWZ0LCAwKTtcbiAgICAgICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4TGVmdCAtIDIwLCBoZWlnaHQgLyAyLCB4TGVmdCwgaGVpZ2h0KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSaWdodCBXYXZlXG4gICAgICAgICAgICBpZiAoeFJpZ2h0IDwgd2lkdGgpIHtcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHhSaWdodCwgMCk7XG4gICAgICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeFJpZ2h0ICsgMjAsIGhlaWdodCAvIDIsIHhSaWdodCwgaGVpZ2h0KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxIC8vIFJlc2V0XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZGF0YS5pZF1cbiAgICAgKi9cbiAgICB1cGRhdGVBY3RpdmVJZChkYXRhKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlSWQgPSBkYXRhPy5pZCB8fCBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICB1cGRhdGVHcmFwaERhdGEoZGF0YSkge1xuICAgICAgICAvLyBOb3QgdXNlZCB5ZXQsIGJ1dCBrZXB0IGZvciBpbnRlcmZhY2UgY29uc2lzdGVuY3lcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZGF0YS5pZF1cbiAgICAgKi9cbiAgICB1cGRhdGVIb3ZlcklkKGRhdGEpIHtcbiAgICAgICAgdGhpcy5ob3ZlcklkID0gZGF0YT8uaWQgfHwgbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhvb2sgdG8gaGFuZGxlIG1vdXNlIGNsaWNrcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uTW91c2VDbGljayhkYXRhKSB7XG4gICAgICAgIHRoaXMuc2hvY2t3YXZlcy5wdXNoKHtcbiAgICAgICAgICAgIHggICAgOiBkYXRhLngsXG4gICAgICAgICAgICB5ICAgIDogZGF0YS55LFxuICAgICAgICAgICAgYWdlICA6IDAsXG4gICAgICAgICAgICBsaWZlIDogNjAsIC8vIGZyYW1lc1xuICAgICAgICAgICAgc3BlZWQ6IDE1ICAvLyBweCBwZXIgZnJhbWVcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIHVwZGF0ZUNvbmZpZyhkYXRhKSB7XG4gICAgICAgIHRoaXMuc2V0KGRhdGEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2RhdGEuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGEucmVjdHNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2RhdGEud2lkdGhdXG4gICAgICovXG4gICAgdXBkYXRlTmF2UmVjdHMoZGF0YSkge1xuICAgICAgICBsZXQgcmVjdHMgPSBkYXRhPy5yZWN0cztcblxuICAgICAgICBpZiAoZGF0YS53aWR0aCAhPT0gdW5kZWZpbmVkICYmIGRhdGEuaGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2l6ZShkYXRhKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVjdHMpKSB7XG4gICAgICAgICAgICB0aGlzLm5hdlJlY3RzID0gcmVjdHNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubmF2UmVjdHMgPSBbXVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbmQgY2FjaGVzIGdyYWRpZW50cyBhbmQgZ2VvbWV0cnkgYnVmZmVycyBiYXNlZCBvbiBjYW52YXMgc2l6ZS5cbiAgICAgKiBUaGlzIGVsaW1pbmF0ZXMgcGVyLWZyYW1lIGFsbG9jYXRpb24gb2YgVHlwZWRBcnJheXMgYW5kIENhbnZhc0dyYWRpZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgKi9cbiAgICB1cGRhdGVSZXNvdXJjZXMod2lkdGgsIGhlaWdodCkge1xuICAgICAgICBsZXQgbWUgID0gdGhpcyxcbiAgICAgICAgICAgIGN0eCA9IG1lLmNvbnRleHQ7XG5cbiAgICAgICAgLy8gMS4gUmUtYWxsb2NhdGUgQnVmZmVycyAoRmxvYXQzMkFycmF5KVxuICAgICAgICAvLyBCYWNrZ3JvdW5kOiBzdGVwID0gMTBcbiAgICAgICAgY29uc3QgYmdDb3VudCA9IE1hdGguY2VpbCh3aWR0aCAvIDEwKSArIDE7XG4gICAgICAgIG1lLndhdmVCdWZmZXJzLmJnQSA9IG5ldyBGbG9hdDMyQXJyYXkoYmdDb3VudCk7XG4gICAgICAgIG1lLndhdmVCdWZmZXJzLmJnQiA9IG5ldyBGbG9hdDMyQXJyYXkoYmdDb3VudCk7XG5cbiAgICAgICAgLy8gRm9yZWdyb3VuZDogc3RlcCA9IDJcbiAgICAgICAgY29uc3QgZmdDb3VudCA9IE1hdGguY2VpbCh3aWR0aCAvIDIpICsgMTtcbiAgICAgICAgbWUud2F2ZUJ1ZmZlcnMuZmdBID0gbmV3IEZsb2F0MzJBcnJheShmZ0NvdW50KTtcbiAgICAgICAgbWUud2F2ZUJ1ZmZlcnMuZmdCID0gbmV3IEZsb2F0MzJBcnJheShmZ0NvdW50KTtcblxuICAgICAgICAvLyAyLiBDYWNoZSBHcmFkaWVudHNcbiAgICAgICAgaWYgKCFjdHgpIHJldHVybjtcblxuICAgICAgICBjb25zdCB0aGVtZUNvbG9ycyA9IG1lLmNvbnN0cnVjdG9yLmNvbG9yc1ttZS50aGVtZV07XG5cbiAgICAgICAgLy8gRm9yZWdyb3VuZCBHcmFkaWVudHNcbiAgICAgICAgY29uc3QgZ3JhZDEgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgMCwgd2lkdGgsIDApO1xuICAgICAgICBncmFkMS5hZGRDb2xvclN0b3AoMCwgICB0aGVtZUNvbG9ycy5ncmFkMVswXSk7XG4gICAgICAgIGdyYWQxLmFkZENvbG9yU3RvcCgwLjUsIHRoZW1lQ29sb3JzLmdyYWQxWzFdKTtcbiAgICAgICAgZ3JhZDEuYWRkQ29sb3JTdG9wKDEsICAgdGhlbWVDb2xvcnMuZ3JhZDFbMl0pO1xuICAgICAgICBtZS5ncmFkaWVudHMuZ3JhZDEgPSBncmFkMTtcblxuICAgICAgICBjb25zdCBncmFkMiA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCB3aWR0aCwgMCk7XG4gICAgICAgIGdyYWQyLmFkZENvbG9yU3RvcCgwLCAgIHRoZW1lQ29sb3JzLmdyYWQyWzBdKTtcbiAgICAgICAgZ3JhZDIuYWRkQ29sb3JTdG9wKDAuNSwgdGhlbWVDb2xvcnMuZ3JhZDJbMV0pO1xuICAgICAgICBncmFkMi5hZGRDb2xvclN0b3AoMSwgICB0aGVtZUNvbG9ycy5ncmFkMlsyXSk7XG4gICAgICAgIG1lLmdyYWRpZW50cy5ncmFkMiA9IGdyYWQyO1xuXG4gICAgICAgIGNvbnN0IGdyYWQxSG90ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIHdpZHRoLCAwKTtcbiAgICAgICAgZ3JhZDFIb3QuYWRkQ29sb3JTdG9wKDAsICAgdGhlbWVDb2xvcnMuZ3JhZDFIb3RbMF0pO1xuICAgICAgICBncmFkMUhvdC5hZGRDb2xvclN0b3AoMC41LCB0aGVtZUNvbG9ycy5ncmFkMUhvdFsxXSk7XG4gICAgICAgIGdyYWQxSG90LmFkZENvbG9yU3RvcCgxLCAgIHRoZW1lQ29sb3JzLmdyYWQxSG90WzJdKTtcbiAgICAgICAgbWUuZ3JhZGllbnRzLmdyYWQxSG90ID0gZ3JhZDFIb3Q7XG5cbiAgICAgICAgY29uc3QgZ3JhZDJIb3QgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgMCwgd2lkdGgsIDApO1xuICAgICAgICBncmFkMkhvdC5hZGRDb2xvclN0b3AoMCwgICB0aGVtZUNvbG9ycy5ncmFkMkhvdFswXSk7XG4gICAgICAgIGdyYWQySG90LmFkZENvbG9yU3RvcCgwLjUsIHRoZW1lQ29sb3JzLmdyYWQySG90WzFdKTtcbiAgICAgICAgZ3JhZDJIb3QuYWRkQ29sb3JTdG9wKDEsICAgdGhlbWVDb2xvcnMuZ3JhZDJIb3RbMl0pO1xuICAgICAgICBtZS5ncmFkaWVudHMuZ3JhZDJIb3QgPSBncmFkMkhvdDtcblxuICAgICAgICBjb25zdCBmZ1JpYmJvbiA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCB3aWR0aCwgMCk7XG4gICAgICAgIGZnUmliYm9uLmFkZENvbG9yU3RvcCgwLCAgIHRoZW1lQ29sb3JzLmZnUmliYm9uWzBdKTtcbiAgICAgICAgZmdSaWJib24uYWRkQ29sb3JTdG9wKDAuNSwgdGhlbWVDb2xvcnMuZmdSaWJib25bMV0pO1xuICAgICAgICBmZ1JpYmJvbi5hZGRDb2xvclN0b3AoMSwgICB0aGVtZUNvbG9ycy5mZ1JpYmJvblsyXSk7XG4gICAgICAgIG1lLmdyYWRpZW50cy5mZ1JpYmJvbiA9IGZnUmliYm9uO1xuXG4gICAgICAgIC8vIEJhY2tncm91bmQgR3JhZGllbnRzXG4gICAgICAgIGNvbnN0IGJnR3JhZDEgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgMCwgd2lkdGgsIDApO1xuICAgICAgICBiZ0dyYWQxLmFkZENvbG9yU3RvcCgwLCAgIHRoZW1lQ29sb3JzLmJhY2tncm91bmRbMF0pO1xuICAgICAgICBiZ0dyYWQxLmFkZENvbG9yU3RvcCgwLjUsIHRoZW1lQ29sb3JzLmJhY2tncm91bmRbMV0pO1xuICAgICAgICBiZ0dyYWQxLmFkZENvbG9yU3RvcCgxLCAgIHRoZW1lQ29sb3JzLmJhY2tncm91bmRbMl0pO1xuICAgICAgICBtZS5ncmFkaWVudHMuYmdHcmFkMSA9IGJnR3JhZDE7XG5cbiAgICAgICAgY29uc3QgYmdHcmFkMiA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCB3aWR0aCwgMCk7XG4gICAgICAgIGJnR3JhZDIuYWRkQ29sb3JTdG9wKDAsICAgdGhlbWVDb2xvcnMuYmFja2dyb3VuZDJbMF0pO1xuICAgICAgICBiZ0dyYWQyLmFkZENvbG9yU3RvcCgwLjUsIHRoZW1lQ29sb3JzLmJhY2tncm91bmQyWzFdKTtcbiAgICAgICAgYmdHcmFkMi5hZGRDb2xvclN0b3AoMSwgICB0aGVtZUNvbG9ycy5iYWNrZ3JvdW5kMlsyXSk7XG4gICAgICAgIG1lLmdyYWRpZW50cy5iZ0dyYWQyID0gYmdHcmFkMjtcblxuICAgICAgICBjb25zdCBiZ1JpYmJvbiA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCB3aWR0aCwgMCk7XG4gICAgICAgIGJnUmliYm9uLmFkZENvbG9yU3RvcCgwLCAgIHRoZW1lQ29sb3JzLmJnUmliYm9uWzBdKTtcbiAgICAgICAgYmdSaWJib24uYWRkQ29sb3JTdG9wKDAuNSwgdGhlbWVDb2xvcnMuYmdSaWJib25bMV0pO1xuICAgICAgICBiZ1JpYmJvbi5hZGRDb2xvclN0b3AoMSwgICB0aGVtZUNvbG9ycy5iZ1JpYmJvblsyXSk7XG4gICAgICAgIG1lLmdyYWRpZW50cy5iZ1JpYmJvbiA9IGJnUmliYm9uO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoSGVhZGVyKTtcblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9