"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["src_main_addon_IntersectionObserver_mjs"],{

/***/ "./src/main/addon/Base.mjs":
/*!*********************************!*\
  !*** ./src/main/addon/Base.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * Base class for main thread addons
 * @class Neo.main.addon.Base
 * @extends Neo.core.Base
 */
class Base extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.main.addon.Base'
         * @protected
         */
        className: 'Neo.main.addon.Base',
        /**
         * An identifier for core.Base to get handled like singletons for remote method access
         * @member {Boolean} isMainThreadAddon=true
         * @protected
         */
        isMainThreadAddon: true,
        /**
         * Will get set to true once all addon related files got loaded (if there is a need to load)
         * @member {Boolean} isReady_=false
         * @protected
         */
        isReady_: false,
        /**
         * Amount in ms to delay the loading of library files, unless remote method access happens
         * Change the value to false in case you don't want an automated preloading
         * @member {Boolean|Number} preloadFilesDelay=5000
         * @protected
         */
        preloadFilesDelay: 5000,
    }

    /**
     * @member {Object[]} cache=[]
     */
    cache = []
    /**
     * Will get set to true once we start loading Monaco related files
     * @member {Boolean} isLoading=false
     */
    isLoading = false
    /**
     * Internal flag to store the setTimeout() id for loading external files
     * @member {Number|null} loadingTimeoutId=null
     */
    loadingTimeoutId = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        if (me.loadFiles) {
            if (me.preloadFilesDelay === 0) {
                me.loadFiles()
            } else if (Neo.isNumber(me.preloadFilesDelay)) {
                me.loadingTimeoutId = setTimeout(() => {
                    me.loadFiles()
                }, me.preloadFilesDelay)
            }
        }
    }

    /**
     * Triggered after the isReady config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetIsReady(value, oldValue) {
        if (value) {
            let me = this,
                returnValue;

            me.cache.forEach(item => {
                returnValue = me[item.fn](item.data);
                item.resolve(returnValue)
            });

            me.cache = []
        }
    }

    /**
     * Internally caches call when isReady===false
     * Loads the library files in case this is not already happening
     * @param item
     * @returns {Promise<unknown>}
     */
    cacheMethodCall(item) {
        let me = this;

        if (!me.isLoading) {
            me.loadingTimeoutId && clearTimeout(me.loadingTimeoutId);
            me.loadingTimeoutId = null;
            me.loadFiles()
        }

        return new Promise((resolve, reject) => {
            me.cache.push({...item, resolve})
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Base));


/***/ }),

/***/ "./src/main/addon/IntersectionObserver.mjs":
/*!*************************************************!*\
  !*** ./src/main/addon/IntersectionObserver.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/main/addon/Base.mjs");
/* harmony import */ var _DomEvents_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../DomEvents.mjs */ "./src/main/DomEvents.mjs");



/**
 * Creating IntersectionObservers to get infos about DOM node visibility.
 * See: https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
 * @class Neo.main.addon.IntersectionObserver
 * @extends Neo.main.addon.Base
 */
class NeoIntersectionObserver extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.main.addon.IntersectionObserver'
         * @protected
         */
        className: 'Neo.main.addon.IntersectionObserver',
        /**
         * Remote method access for other workers
         * @member {Object} remote
         * @protected
         */
        remote: {
            app: [
                'disconnect',
                'observe',
                'register'
            ]
        }
    }

    /**
     * Storing data from observe() calls which arrived prior to register()
     * @member {Object} map={}
     * @protected
     */
    cache = {}
    /**
     * Storing component ids and their IntersectionObservers
     * @member {Object} map={}
     * @protected
     */
    map = {}

    /**
     * @param {Object} data
     * @param {String} data.id
     */
    disconnect(data) {
        this.map[data.id]?.disconnect()
    }

    /**
     * @param {IntersectionObserverEntry[]} entries
     * @param {IntersectionObserver} observer
     */
    findTopmostItem(entries, observer) {
        let me = this,
            data, path, rect, target;

        entries.forEach(entry => {
            target = entry.target;
            data   = target.dataset && {...target.dataset} || null;
            path   = _DomEvents_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getPathFromElement(entry.target).map(e => _DomEvents_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getTargetData(e));
            rect   = target.getBoundingClientRect();

            // 200 is just a random number to ignore intersection changes at the bottom of the view
            if (rect.y < 200) {
                // scroll in from top => direct match
                if (entry.isIntersecting) {
                    me.sendMessage({data, id: observer.rootId, isIntersecting: true, path, targetId: target.id})
                } else {
                    // scroll out from top
                    // not perfect since the node is already outside the view
                    me.sendMessage({data, id: observer.rootId, isIntersecting: true, path, targetId: target.id})
                }
            }
        })
    }

    /**
     * @param {IntersectionObserverEntry[]} entries
     * @param {IntersectionObserver} observer
     */
    isVisible(entries, observer) {
        let me = this,
            data, path, target;

        entries.forEach(entry => {
            target = entry.target;
            data   = target.dataset && {...target.dataset} || null;
            path   = _DomEvents_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getPathFromElement(entry.target).map(e => _DomEvents_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getTargetData(e));

            if (entry.isIntersecting) {
                me.sendMessage({data, id: observer.rootId, isIntersecting: true, path, targetId: target.id})
            }
        })
    }

    /**
     * Add more or new items into an existing observer instance
     * @param {Object} data
     * @param {Boolean} [data.disconnect=false] true removes all currently observed targets
     * @param {String} data.id
     * @param {String|String[]} data.observe The querySelector to match elements
     * @returns {Object} opts
     *     {Boolean} opts.cached      : true in case the observer is not registered yet
     *     {Number}  opts.countTargets: amount of found target nodes inside the DOM
     */
    observe(data) {
        let me            = this,
            cache         = me.cache,
            cached        = false,
            {id, observe} = data,
            observer      = me.map[data.id],
            targets       = [];

        if (!Neo.isArray(observe)) {
            observe = [observe]
        }

        observe.forEach(item => {
            targets.push(...document.querySelectorAll(item))
        })

        if (observer) {
            data.disconnect && observer.disconnect();

            targets.forEach(target => {
                observer.observe(target)
            })
        } else {
            cached = true;

            if (!cache[id]) {
                cache[id] = []
            }

            cache[id].push(data);
        }

        return {
            cached,
            countTargets: targets.length
        }
    }

    /**
     * @param {Object} data
     * @param {String} data.callback
     * @param {String} data.id
     * @param {String|String[]} [data.observe] The querySelector to match elements
     * @param {String} data.root
     * @param {String} data.rootMargin='0px'
     * @param {Number|Number[]} data.threshold=0.0
     * @returns {Boolean}
     *     if data.observe is passed: true in case there is at least one found target node inside the DOM
     *     if data.observe is not passed: true
     */
    register(data) {
        let me            = this,
            {cache}       = me,
            {id, observe} = data,
            returnValue   = true,
            observer;

        me.map[id] = observer = new IntersectionObserver(me[data.callback].bind(me), {
            root      : document.querySelector(data.root),
            rootMargin: data.rootMargin || '0px',
            threshold : data.threshold  || 0.0
        });

        observer.rootId = data.id; // storing the component id

        if (observe) {
            returnValue = me.observe({id, observe})
        }

        if (cache[id]) {
            cache[id].forEach(item => me.observe(item));
            delete cache[id]
        }

        return returnValue
    }

    /**
     * @param {Object} data
     */
    sendMessage(data) {
        Neo.worker.Manager.sendMessage('app', {
            action   : 'domEvent',
            eventName: 'intersect',
            data
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(NeoIntersectionObserver));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL21haW4vc3JjX21haW5fYWRkb25fSW50ZXJzZWN0aW9uT2JzZXJ2ZXJfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQTJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNEQUFRO0FBQzNCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUMsU0FBUztBQUNUO0FBQ0E7O0FBRUEsaUVBQWUsb0JBQW9CLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOUdEO0FBQ007O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxpREFBSTtBQUMxQztBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsNkJBQTZCO0FBQzVDLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsbUJBQW1CO0FBQzNELHFCQUFxQixzREFBUywyQ0FBMkMsc0RBQVM7QUFDbEY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsMkVBQTJFO0FBQy9HLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esb0NBQW9DLDJFQUEyRTtBQUMvRztBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsZUFBZSw2QkFBNkI7QUFDNUMsZUFBZSxzQkFBc0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxtQkFBbUI7QUFDM0QscUJBQXFCLHNEQUFTLDJDQUEyQyxzREFBUzs7QUFFbEY7QUFDQSxnQ0FBZ0MsMkVBQTJFO0FBQzNHO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QixlQUFlLGlCQUFpQjtBQUNoQyxpQkFBaUIsUUFBUTtBQUN6QixZQUFZLFNBQVM7QUFDckIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxpQkFBaUI7QUFDaEMsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLGlCQUFpQjtBQUNoQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLGFBQWE7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQsbUNBQW1DOztBQUVuQztBQUNBLHNDQUFzQyxZQUFZO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsaUVBQWUsdUNBQXVDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL21haW4vYWRkb24vQmFzZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9tYWluL2FkZG9uL0ludGVyc2VjdGlvbk9ic2VydmVyLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ29yZUJhc2UgZnJvbSAnLi4vLi4vY29yZS9CYXNlLm1qcyc7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgbWFpbiB0aHJlYWQgYWRkb25zXG4gKiBAY2xhc3MgTmVvLm1haW4uYWRkb24uQmFzZVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBCYXNlIGV4dGVuZHMgQ29yZUJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLm1haW4uYWRkb24uQmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLm1haW4uYWRkb24uQmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBpZGVudGlmaWVyIGZvciBjb3JlLkJhc2UgdG8gZ2V0IGhhbmRsZWQgbGlrZSBzaW5nbGV0b25zIGZvciByZW1vdGUgbWV0aG9kIGFjY2Vzc1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc01haW5UaHJlYWRBZGRvbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGlzTWFpblRocmVhZEFkZG9uOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogV2lsbCBnZXQgc2V0IHRvIHRydWUgb25jZSBhbGwgYWRkb24gcmVsYXRlZCBmaWxlcyBnb3QgbG9hZGVkIChpZiB0aGVyZSBpcyBhIG5lZWQgdG8gbG9hZClcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNSZWFkeV89ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaXNSZWFkeV86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQW1vdW50IGluIG1zIHRvIGRlbGF5IHRoZSBsb2FkaW5nIG9mIGxpYnJhcnkgZmlsZXMsIHVubGVzcyByZW1vdGUgbWV0aG9kIGFjY2VzcyBoYXBwZW5zXG4gICAgICAgICAqIENoYW5nZSB0aGUgdmFsdWUgdG8gZmFsc2UgaW4gY2FzZSB5b3UgZG9uJ3Qgd2FudCBhbiBhdXRvbWF0ZWQgcHJlbG9hZGluZ1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufE51bWJlcn0gcHJlbG9hZEZpbGVzRGVsYXk9NTAwMFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBwcmVsb2FkRmlsZXNEZWxheTogNTAwMCxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gY2FjaGU9W11cbiAgICAgKi9cbiAgICBjYWNoZSA9IFtdXG4gICAgLyoqXG4gICAgICogV2lsbCBnZXQgc2V0IHRvIHRydWUgb25jZSB3ZSBzdGFydCBsb2FkaW5nIE1vbmFjbyByZWxhdGVkIGZpbGVzXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNMb2FkaW5nPWZhbHNlXG4gICAgICovXG4gICAgaXNMb2FkaW5nID0gZmFsc2VcbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBmbGFnIHRvIHN0b3JlIHRoZSBzZXRUaW1lb3V0KCkgaWQgZm9yIGxvYWRpbmcgZXh0ZXJuYWwgZmlsZXNcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gbG9hZGluZ1RpbWVvdXRJZD1udWxsXG4gICAgICovXG4gICAgbG9hZGluZ1RpbWVvdXRJZCA9IG51bGxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmxvYWRGaWxlcykge1xuICAgICAgICAgICAgaWYgKG1lLnByZWxvYWRGaWxlc0RlbGF5ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbWUubG9hZEZpbGVzKClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTmVvLmlzTnVtYmVyKG1lLnByZWxvYWRGaWxlc0RlbGF5KSkge1xuICAgICAgICAgICAgICAgIG1lLmxvYWRpbmdUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbWUubG9hZEZpbGVzKClcbiAgICAgICAgICAgICAgICB9LCBtZS5wcmVsb2FkRmlsZXNEZWxheSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaXNSZWFkeSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldElzUmVhZHkodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZTtcblxuICAgICAgICAgICAgbWUuY2FjaGUuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IG1lW2l0ZW0uZm5dKGl0ZW0uZGF0YSk7XG4gICAgICAgICAgICAgICAgaXRlbS5yZXNvbHZlKHJldHVyblZhbHVlKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLmNhY2hlID0gW11cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsbHkgY2FjaGVzIGNhbGwgd2hlbiBpc1JlYWR5PT09ZmFsc2VcbiAgICAgKiBMb2FkcyB0aGUgbGlicmFyeSBmaWxlcyBpbiBjYXNlIHRoaXMgaXMgbm90IGFscmVhZHkgaGFwcGVuaW5nXG4gICAgICogQHBhcmFtIGl0ZW1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx1bmtub3duPn1cbiAgICAgKi9cbiAgICBjYWNoZU1ldGhvZENhbGwoaXRlbSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUuaXNMb2FkaW5nKSB7XG4gICAgICAgICAgICBtZS5sb2FkaW5nVGltZW91dElkICYmIGNsZWFyVGltZW91dChtZS5sb2FkaW5nVGltZW91dElkKTtcbiAgICAgICAgICAgIG1lLmxvYWRpbmdUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICAgICAgbWUubG9hZEZpbGVzKClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBtZS5jYWNoZS5wdXNoKHsuLi5pdGVtLCByZXNvbHZlfSlcbiAgICAgICAgfSlcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEJhc2UpO1xuIiwiaW1wb3J0IEJhc2UgICAgICBmcm9tICcuL0Jhc2UubWpzJztcbmltcG9ydCBEb21FdmVudHMgZnJvbSAnLi4vRG9tRXZlbnRzLm1qcyc7XG5cbi8qKlxuICogQ3JlYXRpbmcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXJzIHRvIGdldCBpbmZvcyBhYm91dCBET00gbm9kZSB2aXNpYmlsaXR5LlxuICogU2VlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSW50ZXJzZWN0aW9uX09ic2VydmVyX0FQSVxuICogQGNsYXNzIE5lby5tYWluLmFkZG9uLkludGVyc2VjdGlvbk9ic2VydmVyXG4gKiBAZXh0ZW5kcyBOZW8ubWFpbi5hZGRvbi5CYXNlXG4gKi9cbmNsYXNzIE5lb0ludGVyc2VjdGlvbk9ic2VydmVyIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ubWFpbi5hZGRvbi5JbnRlcnNlY3Rpb25PYnNlcnZlcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLm1haW4uYWRkb24uSW50ZXJzZWN0aW9uT2JzZXJ2ZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3RlIG1ldGhvZCBhY2Nlc3MgZm9yIG90aGVyIHdvcmtlcnNcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSByZW1vdGVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3RlOiB7XG4gICAgICAgICAgICBhcHA6IFtcbiAgICAgICAgICAgICAgICAnZGlzY29ubmVjdCcsXG4gICAgICAgICAgICAgICAgJ29ic2VydmUnLFxuICAgICAgICAgICAgICAgICdyZWdpc3RlcidcbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3JpbmcgZGF0YSBmcm9tIG9ic2VydmUoKSBjYWxscyB3aGljaCBhcnJpdmVkIHByaW9yIHRvIHJlZ2lzdGVyKClcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IG1hcD17fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjYWNoZSA9IHt9XG4gICAgLyoqXG4gICAgICogU3RvcmluZyBjb21wb25lbnQgaWRzIGFuZCB0aGVpciBJbnRlcnNlY3Rpb25PYnNlcnZlcnNcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IG1hcD17fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBtYXAgPSB7fVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5pZFxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3QoZGF0YSkge1xuICAgICAgICB0aGlzLm1hcFtkYXRhLmlkXT8uZGlzY29ubmVjdCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5W119IGVudHJpZXNcbiAgICAgKiBAcGFyYW0ge0ludGVyc2VjdGlvbk9ic2VydmVyfSBvYnNlcnZlclxuICAgICAqL1xuICAgIGZpbmRUb3Btb3N0SXRlbShlbnRyaWVzLCBvYnNlcnZlcikge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgZGF0YSwgcGF0aCwgcmVjdCwgdGFyZ2V0O1xuXG4gICAgICAgIGVudHJpZXMuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgICAgICAgICB0YXJnZXQgPSBlbnRyeS50YXJnZXQ7XG4gICAgICAgICAgICBkYXRhICAgPSB0YXJnZXQuZGF0YXNldCAmJiB7Li4udGFyZ2V0LmRhdGFzZXR9IHx8IG51bGw7XG4gICAgICAgICAgICBwYXRoICAgPSBEb21FdmVudHMuZ2V0UGF0aEZyb21FbGVtZW50KGVudHJ5LnRhcmdldCkubWFwKGUgPT4gRG9tRXZlbnRzLmdldFRhcmdldERhdGEoZSkpO1xuICAgICAgICAgICAgcmVjdCAgID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgICAgICAvLyAyMDAgaXMganVzdCBhIHJhbmRvbSBudW1iZXIgdG8gaWdub3JlIGludGVyc2VjdGlvbiBjaGFuZ2VzIGF0IHRoZSBib3R0b20gb2YgdGhlIHZpZXdcbiAgICAgICAgICAgIGlmIChyZWN0LnkgPCAyMDApIHtcbiAgICAgICAgICAgICAgICAvLyBzY3JvbGwgaW4gZnJvbSB0b3AgPT4gZGlyZWN0IG1hdGNoXG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5LmlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnNlbmRNZXNzYWdlKHtkYXRhLCBpZDogb2JzZXJ2ZXIucm9vdElkLCBpc0ludGVyc2VjdGluZzogdHJ1ZSwgcGF0aCwgdGFyZ2V0SWQ6IHRhcmdldC5pZH0pXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2Nyb2xsIG91dCBmcm9tIHRvcFxuICAgICAgICAgICAgICAgICAgICAvLyBub3QgcGVyZmVjdCBzaW5jZSB0aGUgbm9kZSBpcyBhbHJlYWR5IG91dHNpZGUgdGhlIHZpZXdcbiAgICAgICAgICAgICAgICAgICAgbWUuc2VuZE1lc3NhZ2Uoe2RhdGEsIGlkOiBvYnNlcnZlci5yb290SWQsIGlzSW50ZXJzZWN0aW5nOiB0cnVlLCBwYXRoLCB0YXJnZXRJZDogdGFyZ2V0LmlkfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5W119IGVudHJpZXNcbiAgICAgKiBAcGFyYW0ge0ludGVyc2VjdGlvbk9ic2VydmVyfSBvYnNlcnZlclxuICAgICAqL1xuICAgIGlzVmlzaWJsZShlbnRyaWVzLCBvYnNlcnZlcikge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgZGF0YSwgcGF0aCwgdGFyZ2V0O1xuXG4gICAgICAgIGVudHJpZXMuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgICAgICAgICB0YXJnZXQgPSBlbnRyeS50YXJnZXQ7XG4gICAgICAgICAgICBkYXRhICAgPSB0YXJnZXQuZGF0YXNldCAmJiB7Li4udGFyZ2V0LmRhdGFzZXR9IHx8IG51bGw7XG4gICAgICAgICAgICBwYXRoICAgPSBEb21FdmVudHMuZ2V0UGF0aEZyb21FbGVtZW50KGVudHJ5LnRhcmdldCkubWFwKGUgPT4gRG9tRXZlbnRzLmdldFRhcmdldERhdGEoZSkpO1xuXG4gICAgICAgICAgICBpZiAoZW50cnkuaXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgICAgICAgICBtZS5zZW5kTWVzc2FnZSh7ZGF0YSwgaWQ6IG9ic2VydmVyLnJvb3RJZCwgaXNJbnRlcnNlY3Rpbmc6IHRydWUsIHBhdGgsIHRhcmdldElkOiB0YXJnZXQuaWR9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBtb3JlIG9yIG5ldyBpdGVtcyBpbnRvIGFuIGV4aXN0aW5nIG9ic2VydmVyIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkYXRhLmRpc2Nvbm5lY3Q9ZmFsc2VdIHRydWUgcmVtb3ZlcyBhbGwgY3VycmVudGx5IG9ic2VydmVkIHRhcmdldHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5pZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfFN0cmluZ1tdfSBkYXRhLm9ic2VydmUgVGhlIHF1ZXJ5U2VsZWN0b3IgdG8gbWF0Y2ggZWxlbWVudHNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBvcHRzXG4gICAgICogICAgIHtCb29sZWFufSBvcHRzLmNhY2hlZCAgICAgIDogdHJ1ZSBpbiBjYXNlIHRoZSBvYnNlcnZlciBpcyBub3QgcmVnaXN0ZXJlZCB5ZXRcbiAgICAgKiAgICAge051bWJlcn0gIG9wdHMuY291bnRUYXJnZXRzOiBhbW91bnQgb2YgZm91bmQgdGFyZ2V0IG5vZGVzIGluc2lkZSB0aGUgRE9NXG4gICAgICovXG4gICAgb2JzZXJ2ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNhY2hlICAgICAgICAgPSBtZS5jYWNoZSxcbiAgICAgICAgICAgIGNhY2hlZCAgICAgICAgPSBmYWxzZSxcbiAgICAgICAgICAgIHtpZCwgb2JzZXJ2ZX0gPSBkYXRhLFxuICAgICAgICAgICAgb2JzZXJ2ZXIgICAgICA9IG1lLm1hcFtkYXRhLmlkXSxcbiAgICAgICAgICAgIHRhcmdldHMgICAgICAgPSBbXTtcblxuICAgICAgICBpZiAoIU5lby5pc0FycmF5KG9ic2VydmUpKSB7XG4gICAgICAgICAgICBvYnNlcnZlID0gW29ic2VydmVdXG4gICAgICAgIH1cblxuICAgICAgICBvYnNlcnZlLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICB0YXJnZXRzLnB1c2goLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChpdGVtKSlcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIGRhdGEuZGlzY29ubmVjdCAmJiBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG5cbiAgICAgICAgICAgIHRhcmdldHMuZm9yRWFjaCh0YXJnZXQgPT4ge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUodGFyZ2V0KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmICghY2FjaGVbaWRdKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVbaWRdID0gW11cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FjaGVbaWRdLnB1c2goZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2FjaGVkLFxuICAgICAgICAgICAgY291bnRUYXJnZXRzOiB0YXJnZXRzLmxlbmd0aFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5jYWxsYmFja1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8U3RyaW5nW119IFtkYXRhLm9ic2VydmVdIFRoZSBxdWVyeVNlbGVjdG9yIHRvIG1hdGNoIGVsZW1lbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEucm9vdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLnJvb3RNYXJnaW49JzBweCdcbiAgICAgKiBAcGFyYW0ge051bWJlcnxOdW1iZXJbXX0gZGF0YS50aHJlc2hvbGQ9MC4wXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICogICAgIGlmIGRhdGEub2JzZXJ2ZSBpcyBwYXNzZWQ6IHRydWUgaW4gY2FzZSB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgZm91bmQgdGFyZ2V0IG5vZGUgaW5zaWRlIHRoZSBET01cbiAgICAgKiAgICAgaWYgZGF0YS5vYnNlcnZlIGlzIG5vdCBwYXNzZWQ6IHRydWVcbiAgICAgKi9cbiAgICByZWdpc3RlcihkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjYWNoZX0gICAgICAgPSBtZSxcbiAgICAgICAgICAgIHtpZCwgb2JzZXJ2ZX0gPSBkYXRhLFxuICAgICAgICAgICAgcmV0dXJuVmFsdWUgICA9IHRydWUsXG4gICAgICAgICAgICBvYnNlcnZlcjtcblxuICAgICAgICBtZS5tYXBbaWRdID0gb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIobWVbZGF0YS5jYWxsYmFja10uYmluZChtZSksIHtcbiAgICAgICAgICAgIHJvb3QgICAgICA6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZGF0YS5yb290KSxcbiAgICAgICAgICAgIHJvb3RNYXJnaW46IGRhdGEucm9vdE1hcmdpbiB8fCAnMHB4JyxcbiAgICAgICAgICAgIHRocmVzaG9sZCA6IGRhdGEudGhyZXNob2xkICB8fCAwLjBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb2JzZXJ2ZXIucm9vdElkID0gZGF0YS5pZDsgLy8gc3RvcmluZyB0aGUgY29tcG9uZW50IGlkXG5cbiAgICAgICAgaWYgKG9ic2VydmUpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gbWUub2JzZXJ2ZSh7aWQsIG9ic2VydmV9KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNhY2hlW2lkXSkge1xuICAgICAgICAgICAgY2FjaGVbaWRdLmZvckVhY2goaXRlbSA9PiBtZS5vYnNlcnZlKGl0ZW0pKTtcbiAgICAgICAgICAgIGRlbGV0ZSBjYWNoZVtpZF1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXR1cm5WYWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgc2VuZE1lc3NhZ2UoZGF0YSkge1xuICAgICAgICBOZW8ud29ya2VyLk1hbmFnZXIuc2VuZE1lc3NhZ2UoJ2FwcCcsIHtcbiAgICAgICAgICAgIGFjdGlvbiAgIDogJ2RvbUV2ZW50JyxcbiAgICAgICAgICAgIGV2ZW50TmFtZTogJ2ludGVyc2VjdCcsXG4gICAgICAgICAgICBkYXRhXG4gICAgICAgIH0pXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhOZW9JbnRlcnNlY3Rpb25PYnNlcnZlcik7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=