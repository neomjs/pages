"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["src_main_render_StringBasedRenderer_mjs"],{

/***/ "./src/main/render/StringBasedRenderer.mjs"
/*!*************************************************!*\
  !*** ./src/main/render/StringBasedRenderer.mjs ***!
  \*************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DomAccess.mjs */ "./src/main/DomAccess.mjs");


const StringBasedRenderer = {
    /**
     * @param {String} html representing a single element
     * @returns {DocumentFragment}
     */
    htmlStringToElement(html) {
        const template = document.createElement('template');
        template.innerHTML = html;
        return template.content
    },

    /**
     * Handles string-based insertion of a new node into the DOM.
     * This method is called by `insertNode()` when `NeoConfig.useDomApiRenderer` is false.
     *
     * @param {Object}      data
     * @param {Boolean}     data.hasLeadingTextChildren Flag to honor leading comments.
     * @param {Number}      data.index                  The index at which to insert the new node.
     * @param {String}      data.outerHTML              The HTML string of the node to insert.
     * @param {HTMLElement} data.parentNode             The parent DOM node to insert into.
     * @param {Object[]}    [data.postMountUpdates]     Array of post-mount updates (e.g. scroll state).
     * @private
     */
    insertNodeAsString({hasLeadingTextChildren, index, outerHTML, parentNode, postMountUpdates}) {
        let me = this;

        // If comments detected, parse HTML string to a node and use insertBefore/appendChild on childNodes.
        if (hasLeadingTextChildren) {
            let node = me.htmlStringToElement(outerHTML);

            if (index < parentNode.childNodes.length) {
                parentNode.insertBefore(node, parentNode.childNodes[index])
            } else {
                parentNode.appendChild(node)
            }
        }
        // If no comments detected, use insertAdjacentHTML for element nodes.
        else {
            let countChildren = parentNode.children.length; // Use `children` for `insertAdjacentHTML` context

            if (index > 0 && index >= countChildren) {
                parentNode.insertAdjacentHTML('beforeend', outerHTML);
            } else if (countChildren > 0 && countChildren > index) {
                parentNode.children[index].insertAdjacentHTML('beforebegin', outerHTML)
            } else if (countChildren > 0) {
                parentNode.children[countChildren - 1].insertAdjacentHTML('afterend', outerHTML)
            } else {
                parentNode.insertAdjacentHTML('beforeend', outerHTML)
            }
        }

        if (postMountUpdates?.length > 0) {
            let node;

            postMountUpdates.forEach(update => {
                node = _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getElement(update.id);

                if (node) {
                    if (update.scrollLeft) {node.scrollLeft = update.scrollLeft}
                    if (update.scrollTop)  {node.scrollTop  = update.scrollTop}
                }
            })
        }
    }
};

const ns = Neo.ns('Neo.main.render', true);
ns.StringBasedRenderer = StringBasedRenderer;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StringBasedRenderer);


/***/ }

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL21haW4vc3JjX21haW5fcmVuZGVyX1N0cmluZ0Jhc2VkUmVuZGVyZXJfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQXlDOztBQUV6QztBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQSx3QkFBd0IsdUVBQXVFO0FBQy9GOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7O0FBRTVEO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsc0RBQVM7O0FBRWhDO0FBQ0EsNENBQTRDO0FBQzVDLDRDQUE0QztBQUM1QztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpRUFBZSxtQkFBbUIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvbWFpbi9yZW5kZXIvU3RyaW5nQmFzZWRSZW5kZXJlci5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IERvbUFjY2VzcyBmcm9tICcuLi9Eb21BY2Nlc3MubWpzJztcblxuY29uc3QgU3RyaW5nQmFzZWRSZW5kZXJlciA9IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaHRtbCByZXByZXNlbnRpbmcgYSBzaW5nbGUgZWxlbWVudFxuICAgICAqIEByZXR1cm5zIHtEb2N1bWVudEZyYWdtZW50fVxuICAgICAqL1xuICAgIGh0bWxTdHJpbmdUb0VsZW1lbnQoaHRtbCkge1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZS5jb250ZW50XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgc3RyaW5nLWJhc2VkIGluc2VydGlvbiBvZiBhIG5ldyBub2RlIGludG8gdGhlIERPTS5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgYGluc2VydE5vZGUoKWAgd2hlbiBgTmVvQ29uZmlnLnVzZURvbUFwaVJlbmRlcmVyYCBpcyBmYWxzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgIGRhdGFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICBkYXRhLmhhc0xlYWRpbmdUZXh0Q2hpbGRyZW4gRmxhZyB0byBob25vciBsZWFkaW5nIGNvbW1lbnRzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgICAgIGRhdGEuaW5kZXggICAgICAgICAgICAgICAgICBUaGUgaW5kZXggYXQgd2hpY2ggdG8gaW5zZXJ0IHRoZSBuZXcgbm9kZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICBkYXRhLm91dGVySFRNTCAgICAgICAgICAgICAgVGhlIEhUTUwgc3RyaW5nIG9mIHRoZSBub2RlIHRvIGluc2VydC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkYXRhLnBhcmVudE5vZGUgICAgICAgICAgICAgVGhlIHBhcmVudCBET00gbm9kZSB0byBpbnNlcnQgaW50by5cbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSAgICBbZGF0YS5wb3N0TW91bnRVcGRhdGVzXSAgICAgQXJyYXkgb2YgcG9zdC1tb3VudCB1cGRhdGVzIChlLmcuIHNjcm9sbCBzdGF0ZSkuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpbnNlcnROb2RlQXNTdHJpbmcoe2hhc0xlYWRpbmdUZXh0Q2hpbGRyZW4sIGluZGV4LCBvdXRlckhUTUwsIHBhcmVudE5vZGUsIHBvc3RNb3VudFVwZGF0ZXN9KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgLy8gSWYgY29tbWVudHMgZGV0ZWN0ZWQsIHBhcnNlIEhUTUwgc3RyaW5nIHRvIGEgbm9kZSBhbmQgdXNlIGluc2VydEJlZm9yZS9hcHBlbmRDaGlsZCBvbiBjaGlsZE5vZGVzLlxuICAgICAgICBpZiAoaGFzTGVhZGluZ1RleHRDaGlsZHJlbikge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBtZS5odG1sU3RyaW5nVG9FbGVtZW50KG91dGVySFRNTCk7XG5cbiAgICAgICAgICAgIGlmIChpbmRleCA8IHBhcmVudE5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCBwYXJlbnROb2RlLmNoaWxkTm9kZXNbaW5kZXhdKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmFwcGVuZENoaWxkKG5vZGUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbm8gY29tbWVudHMgZGV0ZWN0ZWQsIHVzZSBpbnNlcnRBZGphY2VudEhUTUwgZm9yIGVsZW1lbnQgbm9kZXMuXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGNvdW50Q2hpbGRyZW4gPSBwYXJlbnROb2RlLmNoaWxkcmVuLmxlbmd0aDsgLy8gVXNlIGBjaGlsZHJlbmAgZm9yIGBpbnNlcnRBZGphY2VudEhUTUxgIGNvbnRleHRcblxuICAgICAgICAgICAgaWYgKGluZGV4ID4gMCAmJiBpbmRleCA+PSBjb3VudENoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsIG91dGVySFRNTCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvdW50Q2hpbGRyZW4gPiAwICYmIGNvdW50Q2hpbGRyZW4gPiBpbmRleCkge1xuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuY2hpbGRyZW5baW5kZXhdLmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlYmVnaW4nLCBvdXRlckhUTUwpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvdW50Q2hpbGRyZW4gPiAwKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5jaGlsZHJlbltjb3VudENoaWxkcmVuIC0gMV0uaW5zZXJ0QWRqYWNlbnRIVE1MKCdhZnRlcmVuZCcsIG91dGVySFRNTClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsIG91dGVySFRNTClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3N0TW91bnRVcGRhdGVzPy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgbm9kZTtcblxuICAgICAgICAgICAgcG9zdE1vdW50VXBkYXRlcy5mb3JFYWNoKHVwZGF0ZSA9PiB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IERvbUFjY2Vzcy5nZXRFbGVtZW50KHVwZGF0ZS5pZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlLnNjcm9sbExlZnQpIHtub2RlLnNjcm9sbExlZnQgPSB1cGRhdGUuc2Nyb2xsTGVmdH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHVwZGF0ZS5zY3JvbGxUb3ApICB7bm9kZS5zY3JvbGxUb3AgID0gdXBkYXRlLnNjcm9sbFRvcH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxufTtcblxuY29uc3QgbnMgPSBOZW8ubnMoJ05lby5tYWluLnJlbmRlcicsIHRydWUpO1xubnMuU3RyaW5nQmFzZWRSZW5kZXJlciA9IFN0cmluZ0Jhc2VkUmVuZGVyZXI7XG5cbmV4cG9ydCBkZWZhdWx0IFN0cmluZ0Jhc2VkUmVuZGVyZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9