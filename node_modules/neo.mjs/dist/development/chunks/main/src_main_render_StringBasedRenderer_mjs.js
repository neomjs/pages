"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["src_main_render_StringBasedRenderer_mjs"],{

/***/ "./src/main/render/StringBasedRenderer.mjs":
/*!*************************************************!*\
  !*** ./src/main/render/StringBasedRenderer.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const StringBasedRenderer = {
    /**
     * @param {String} html representing a single element
     * @returns {DocumentFragment}
     */
    htmlStringToElement(html) {
        const template = document.createElement('template');
        template.innerHTML = html;
        return template.content
    },

    /**
     * Handles string-based insertion of a new node into the DOM.
     * This method is called by `insertNode()` when `NeoConfig.useDomApiRenderer` is false.
     *
     * @param {Object}      data
     * @param {Boolean}     data.hasLeadingTextChildren Flag to honor leading comments.
     * @param {Number}      data.index                  The index at which to insert the new node.
     * @param {String}      data.outerHTML              The HTML string of the node to insert.
     * @param {HTMLElement} data.parentNode             The parent DOM node to insert into.
     * @private
     */
    insertNodeAsString({hasLeadingTextChildren, index, outerHTML, parentNode}) {
        let me = this;

        // If comments detected, parse HTML string to a node and use insertBefore/appendChild on childNodes.
        if (hasLeadingTextChildren) {
            let node = me.htmlStringToElement(outerHTML);

            if (index < parentNode.childNodes.length) {
                parentNode.insertBefore(node, parentNode.childNodes[index])
            } else {
                parentNode.appendChild(node)
            }
        }
        // If no comments detected, use insertAdjacentHTML for element nodes.
        else {
            let countChildren = parentNode.children.length; // Use `children` for `insertAdjacentHTML` context

            if (index > 0 && index >= countChildren) {
                parentNode.insertAdjacentHTML('beforeend', outerHTML);
                return
            }
            if (countChildren > 0 && countChildren > index) {
                parentNode.children[index].insertAdjacentHTML('beforebegin', outerHTML)
            } else if (countChildren > 0) {
                parentNode.children[countChildren - 1].insertAdjacentHTML('afterend', outerHTML)
            } else {
                parentNode.insertAdjacentHTML('beforeend', outerHTML)
            }
        }
    }
};

const ns = Neo.ns('Neo.main.render', true);
ns.StringBasedRenderer = StringBasedRenderer;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StringBasedRenderer);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL21haW4vc3JjX21haW5fcmVuZGVyX1N0cmluZ0Jhc2VkUmVuZGVyZXJfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBLHdCQUF3QixxREFBcUQ7QUFDN0U7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpRUFBZSxtQkFBbUIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvbWFpbi9yZW5kZXIvU3RyaW5nQmFzZWRSZW5kZXJlci5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgU3RyaW5nQmFzZWRSZW5kZXJlciA9IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaHRtbCByZXByZXNlbnRpbmcgYSBzaW5nbGUgZWxlbWVudFxuICAgICAqIEByZXR1cm5zIHtEb2N1bWVudEZyYWdtZW50fVxuICAgICAqL1xuICAgIGh0bWxTdHJpbmdUb0VsZW1lbnQoaHRtbCkge1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZS5jb250ZW50XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgc3RyaW5nLWJhc2VkIGluc2VydGlvbiBvZiBhIG5ldyBub2RlIGludG8gdGhlIERPTS5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgYGluc2VydE5vZGUoKWAgd2hlbiBgTmVvQ29uZmlnLnVzZURvbUFwaVJlbmRlcmVyYCBpcyBmYWxzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgIGRhdGFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICBkYXRhLmhhc0xlYWRpbmdUZXh0Q2hpbGRyZW4gRmxhZyB0byBob25vciBsZWFkaW5nIGNvbW1lbnRzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgICAgIGRhdGEuaW5kZXggICAgICAgICAgICAgICAgICBUaGUgaW5kZXggYXQgd2hpY2ggdG8gaW5zZXJ0IHRoZSBuZXcgbm9kZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICBkYXRhLm91dGVySFRNTCAgICAgICAgICAgICAgVGhlIEhUTUwgc3RyaW5nIG9mIHRoZSBub2RlIHRvIGluc2VydC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkYXRhLnBhcmVudE5vZGUgICAgICAgICAgICAgVGhlIHBhcmVudCBET00gbm9kZSB0byBpbnNlcnQgaW50by5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGluc2VydE5vZGVBc1N0cmluZyh7aGFzTGVhZGluZ1RleHRDaGlsZHJlbiwgaW5kZXgsIG91dGVySFRNTCwgcGFyZW50Tm9kZX0pIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvLyBJZiBjb21tZW50cyBkZXRlY3RlZCwgcGFyc2UgSFRNTCBzdHJpbmcgdG8gYSBub2RlIGFuZCB1c2UgaW5zZXJ0QmVmb3JlL2FwcGVuZENoaWxkIG9uIGNoaWxkTm9kZXMuXG4gICAgICAgIGlmIChoYXNMZWFkaW5nVGV4dENoaWxkcmVuKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IG1lLmh0bWxTdHJpbmdUb0VsZW1lbnQob3V0ZXJIVE1MKTtcblxuICAgICAgICAgICAgaWYgKGluZGV4IDwgcGFyZW50Tm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIHBhcmVudE5vZGUuY2hpbGROb2Rlc1tpbmRleF0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQobm9kZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBubyBjb21tZW50cyBkZXRlY3RlZCwgdXNlIGluc2VydEFkamFjZW50SFRNTCBmb3IgZWxlbWVudCBub2Rlcy5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgY291bnRDaGlsZHJlbiA9IHBhcmVudE5vZGUuY2hpbGRyZW4ubGVuZ3RoOyAvLyBVc2UgYGNoaWxkcmVuYCBmb3IgYGluc2VydEFkamFjZW50SFRNTGAgY29udGV4dFxuXG4gICAgICAgICAgICBpZiAoaW5kZXggPiAwICYmIGluZGV4ID49IGNvdW50Q2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJywgb3V0ZXJIVE1MKTtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb3VudENoaWxkcmVuID4gMCAmJiBjb3VudENoaWxkcmVuID4gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmNoaWxkcmVuW2luZGV4XS5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWJlZ2luJywgb3V0ZXJIVE1MKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjb3VudENoaWxkcmVuID4gMCkge1xuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuY2hpbGRyZW5bY291bnRDaGlsZHJlbiAtIDFdLmluc2VydEFkamFjZW50SFRNTCgnYWZ0ZXJlbmQnLCBvdXRlckhUTUwpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCBvdXRlckhUTUwpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5jb25zdCBucyA9IE5lby5ucygnTmVvLm1haW4ucmVuZGVyJywgdHJ1ZSk7XG5ucy5TdHJpbmdCYXNlZFJlbmRlcmVyID0gU3RyaW5nQmFzZWRSZW5kZXJlcjtcblxuZXhwb3J0IGRlZmF1bHQgU3RyaW5nQmFzZWRSZW5kZXJlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=