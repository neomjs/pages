"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["src_main_render_StringBasedRenderer_mjs"],{

/***/ "./src/main/render/StringBasedRenderer.mjs":
/*!*************************************************!*\
  !*** ./src/main/render/StringBasedRenderer.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const StringBasedRenderer = {
    /**
     * @param {String} html representing a single element
     * @returns {DocumentFragment}
     */
    htmlStringToElement(html) {
        const template = document.createElement('template');
        template.innerHTML = html;
        return template.content
    },

    /**
     * Handles string-based insertion of a new node into the DOM.
     * This method is called by `insertNode()` when `NeoConfig.useStringBasedMounting` is true.
     *
     * @param {Object}      data
     * @param {Boolean}     data.hasLeadingTextChildren Flag to honor leading comments.
     * @param {Number}      data.index                  The index at which to insert the new node.
     * @param {String}      data.outerHTML              The HTML string of the node to insert.
     * @param {HTMLElement} data.parentNode             The parent DOM node to insert into.
     * @private
     */
    insertNodeAsString({hasLeadingTextChildren, index, outerHTML, parentNode}) {
        let me = this;

        // If comments detected, parse HTML string to a node and use insertBefore/appendChild on childNodes.
        if (hasLeadingTextChildren) {
            let node = me.htmlStringToElement(outerHTML);

            if (index < parentNode.childNodes.length) {
                parentNode.insertBefore(node, parentNode.childNodes[index])
            } else {
                parentNode.appendChild(node)
            }
        }
        // If no comments detected, use insertAdjacentHTML for element nodes.
        else {
            let countChildren = parentNode.children.length; // Use `children` for `insertAdjacentHTML` context

            if (index > 0 && index >= countChildren) {
                parentNode.insertAdjacentHTML('beforeend', outerHTML);
                return
            }
            if (countChildren > 0 && countChildren > index) {
                parentNode.children[index].insertAdjacentHTML('beforebegin', outerHTML)
            } else if (countChildren > 0) {
                parentNode.children[countChildren - 1].insertAdjacentHTML('afterend', outerHTML)
            } else {
                parentNode.insertAdjacentHTML('beforeend', outerHTML)
            }
        }
    }
};

const ns = Neo.ns('Neo.main.render', true);
ns.StringBasedRenderer = StringBasedRenderer;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StringBasedRenderer);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL21haW4vc3JjX21haW5fcmVuZGVyX1N0cmluZ0Jhc2VkUmVuZGVyZXJfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBLHdCQUF3QixxREFBcUQ7QUFDN0U7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpRUFBZSxtQkFBbUIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvbWFpbi9yZW5kZXIvU3RyaW5nQmFzZWRSZW5kZXJlci5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgU3RyaW5nQmFzZWRSZW5kZXJlciA9IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaHRtbCByZXByZXNlbnRpbmcgYSBzaW5nbGUgZWxlbWVudFxuICAgICAqIEByZXR1cm5zIHtEb2N1bWVudEZyYWdtZW50fVxuICAgICAqL1xuICAgIGh0bWxTdHJpbmdUb0VsZW1lbnQoaHRtbCkge1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZS5jb250ZW50XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgc3RyaW5nLWJhc2VkIGluc2VydGlvbiBvZiBhIG5ldyBub2RlIGludG8gdGhlIERPTS5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgYGluc2VydE5vZGUoKWAgd2hlbiBgTmVvQ29uZmlnLnVzZVN0cmluZ0Jhc2VkTW91bnRpbmdgIGlzIHRydWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICBkYXRhXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgZGF0YS5oYXNMZWFkaW5nVGV4dENoaWxkcmVuIEZsYWcgdG8gaG9ub3IgbGVhZGluZyBjb21tZW50cy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gICAgICBkYXRhLmluZGV4ICAgICAgICAgICAgICAgICAgVGhlIGluZGV4IGF0IHdoaWNoIHRvIGluc2VydCB0aGUgbmV3IG5vZGUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgICAgZGF0YS5vdXRlckhUTUwgICAgICAgICAgICAgIFRoZSBIVE1MIHN0cmluZyBvZiB0aGUgbm9kZSB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZGF0YS5wYXJlbnROb2RlICAgICAgICAgICAgIFRoZSBwYXJlbnQgRE9NIG5vZGUgdG8gaW5zZXJ0IGludG8uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpbnNlcnROb2RlQXNTdHJpbmcoe2hhc0xlYWRpbmdUZXh0Q2hpbGRyZW4sIGluZGV4LCBvdXRlckhUTUwsIHBhcmVudE5vZGV9KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgLy8gSWYgY29tbWVudHMgZGV0ZWN0ZWQsIHBhcnNlIEhUTUwgc3RyaW5nIHRvIGEgbm9kZSBhbmQgdXNlIGluc2VydEJlZm9yZS9hcHBlbmRDaGlsZCBvbiBjaGlsZE5vZGVzLlxuICAgICAgICBpZiAoaGFzTGVhZGluZ1RleHRDaGlsZHJlbikge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBtZS5odG1sU3RyaW5nVG9FbGVtZW50KG91dGVySFRNTCk7XG5cbiAgICAgICAgICAgIGlmIChpbmRleCA8IHBhcmVudE5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCBwYXJlbnROb2RlLmNoaWxkTm9kZXNbaW5kZXhdKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmFwcGVuZENoaWxkKG5vZGUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbm8gY29tbWVudHMgZGV0ZWN0ZWQsIHVzZSBpbnNlcnRBZGphY2VudEhUTUwgZm9yIGVsZW1lbnQgbm9kZXMuXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGNvdW50Q2hpbGRyZW4gPSBwYXJlbnROb2RlLmNoaWxkcmVuLmxlbmd0aDsgLy8gVXNlIGBjaGlsZHJlbmAgZm9yIGBpbnNlcnRBZGphY2VudEhUTUxgIGNvbnRleHRcblxuICAgICAgICAgICAgaWYgKGluZGV4ID4gMCAmJiBpbmRleCA+PSBjb3VudENoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsIG91dGVySFRNTCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY291bnRDaGlsZHJlbiA+IDAgJiYgY291bnRDaGlsZHJlbiA+IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5jaGlsZHJlbltpbmRleF0uaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmViZWdpbicsIG91dGVySFRNTClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY291bnRDaGlsZHJlbiA+IDApIHtcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmNoaWxkcmVuW2NvdW50Q2hpbGRyZW4gLSAxXS5pbnNlcnRBZGphY2VudEhUTUwoJ2FmdGVyZW5kJywgb3V0ZXJIVE1MKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJywgb3V0ZXJIVE1MKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuY29uc3QgbnMgPSBOZW8ubnMoJ05lby5tYWluLnJlbmRlcicsIHRydWUpO1xubnMuU3RyaW5nQmFzZWRSZW5kZXJlciA9IFN0cmluZ0Jhc2VkUmVuZGVyZXI7XG5cbmV4cG9ydCBkZWZhdWx0IFN0cmluZ0Jhc2VkUmVuZGVyZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=