"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_main_addon_Stylesheet_mjs"],{

/***/ "./src/main/addon/Base.mjs":
/*!*********************************!*\
  !*** ./src/main/addon/Base.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * Base class for main thread addons
 * @class Neo.main.addon.Base
 * @extends Neo.core.Base
 */
class Base extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.main.addon.Base'
         * @protected
         */
        className: 'Neo.main.addon.Base',
        /**
         * An identifier for core.Base to get handled like singletons for remote method access
         * @member {Boolean} isMainThreadAddon=true
         * @protected
         */
        isMainThreadAddon: true,
        /**
         * Will get set to true once all addon related files got loaded (if there is a need to load)
         * @member {Boolean} isReady_=false
         * @protected
         */
        isReady_: false,
        /**
         * Amount in ms to delay the loading of library files, unless remote method access happens
         * Change the value to false in case you don't want an automated preloading
         * @member {Boolean|Number} preloadFilesDelay=5000
         * @protected
         */
        preloadFilesDelay: 5000,
    }

    /**
     * @member {Object[]} cache=[]
     */
    cache = []
    /**
     * Will get set to true once we start loading Monaco related files
     * @member {Boolean} isLoading=false
     */
    isLoading = false
    /**
     * Internal flag to store the setTimeout() id for loading external files
     * @member {Number|null} loadingTimeoutId=null
     */
    loadingTimeoutId = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        if (me.loadFiles) {
            if (me.preloadFilesDelay === 0) {
                me.loadFiles()
            } else if (Neo.isNumber(me.preloadFilesDelay)) {
                me.loadingTimeoutId = setTimeout(() => {
                    me.loadFiles()
                }, me.preloadFilesDelay)
            }
        }
    }

    /**
     * Triggered after the isReady config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetIsReady(value, oldValue) {
        if (value) {
            let me = this,
                returnValue;

            me.cache.forEach(item => {
                returnValue = me[item.fn](item.data);
                item.resolve(returnValue)
            });

            me.cache = []
        }
    }

    /**
     * Internally caches call when isReady===false
     * Loads the library files in case this is not already happening
     * @param item
     * @returns {Promise<unknown>}
     */
    cacheMethodCall(item) {
        let me = this;

        if (!me.isLoading) {
            me.loadingTimeoutId && clearTimeout(me.loadingTimeoutId);
            me.loadingTimeoutId = null;
            me.loadFiles()
        }

        return new Promise((resolve, reject) => {
            me.cache.push({...item, resolve})
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Base));


/***/ }),

/***/ "./src/main/addon/Stylesheet.mjs":
/*!***************************************!*\
  !*** ./src/main/addon/Stylesheet.mjs ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/main/addon/Base.mjs");


/**
 * Logic to work with stylesheets, e.g. apply & switch Neo based themes
 * main.addon.HighlightJS requires this file
 * @class Neo.main.addon.Stylesheet
 * @extends Neo.main.addon.Base
 */
class Stylesheet extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @member {String} dynamicStyleSheetId='neo-dynamic-stylesheet'
     * @protected
     */
    dynamicStyleSheetId = 'neo-dynamic-stylesheet';

    static config = {
        /**
         * @member {String} className='Neo.main.addon.Stylesheet'
         * @protected
         */
        className: 'Neo.main.addon.Stylesheet',
        /**
         * Remote method access for other workers
         * @member {Object} remote={app: [//...]}
         * @protected
         */
        remote: {
            app: [
                'addThemeFiles',
                'createStyleSheet',
                'deleteCssRules',
                'insertCssRules',
                'setCssVariable',
                'swapStyleSheet'
            ]
        }
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let neoConfig = Neo.config,
            faPath;

        if (neoConfig.useFontAwesome) {
            if (neoConfig.environment === 'development') {
                faPath = neoConfig.basePath + 'node_modules/@fortawesome/fontawesome-free/css/all.min.css'
            } else {
                faPath = neoConfig.basePath.substr(6) + 'resources/fontawesome-free/css/all.min.css'
            }

            this.createStyleSheet(null, null, faPath)
        }

        if (neoConfig.themes.length > 0 && neoConfig.themes[0] !== '') {
            this.addGlobalCss()
        }
    }

    /**
     *
     */
    addGlobalCss() {
        let {config} = Neo,
            {themes} = config,
            folders  = ['src', ...themes],
            env      = config.environment,
            path      = env.startsWith('dist/') ? '' : config.appPath.includes('docs') ? `../dist/${env}/` : `../../dist/${env}/`,
            rootPath = config.basePath.substring(6);

        document.body.classList.add(themes[0]);

        folders.forEach(folder => {
            if (folder.startsWith('neo-')) {
                folder = folder.substring(4)
            }

            this.createStyleSheet(
                null,
                null,
                `${rootPath}${path}css/${folder}/Global.css`
            )
        })
    }

    /**
     * @param {Object} data
     * @param {String} data.appName
     * @param {String} data.className
     * @param {String[]} data.folders
     */
    async addThemeFiles(data) {
        let {className} = data,
            {config}    = Neo,
            env         = config.environment,
            path        = env.startsWith('dist/') ? '' : config.appPath.includes('docs') ? `../dist/${env}/` : `../../dist/${env}/`,
            promises    = [],
            rootPath    = config.basePath.substring(6);

        if (className.startsWith('Neo.')) {
            className = className.substring(4)
        }

        className = className.split('.').join('/');

        data.folders.forEach(folder => {
            if (folder === 'src' || folder.includes('theme-') && config.themes.includes(`neo-${folder}`)) {
                promises.push(this.createStyleSheet(
                    null,
                    null,
                    `${rootPath}${path}css/${folder}/${className}.css`
                ))
            }
        });

        await Promise.all(promises)
    }

    /**
     * Use either name for a neo theme (e.g. 'neo-theme-dark.css') or pass a href
     * @param {String} [name]
     * @param {String} [id]
     * @param {String} [href]
     * @returns {Promise<void>}
     */
    async createStyleSheet(name, id, href) {
        if (!name && !href) {
            throw new Error('createStyleSheet: you need to either pass a name or a href')
        }

        return new Promise((resolve, reject) => {
            let link = document.createElement('link'),
                env  = Neo.config.environment,
                path = env.startsWith('dist/') ? env : ('dist/' + env),
                url  = href ? href : Neo.config.basePath + path + '/' + name;

            Object.assign(link, {
                href: url,
                rel : 'stylesheet',
                type: 'text/css'
            });

            if (id) {
                link.id = id
            }

            link.addEventListener('error', function() {reject()})
            link.addEventListener('load',  function() {resolve()})

            document.head.appendChild(link)
        })
    }

    /**
     * @param {Object} data
     * @param {Array} data.rules
     * @protected
     */
    deleteCssRules(data) {
        let styleEl    = document.getElementById(this.dynamicStyleSheetId),
            styleSheet = styleEl.sheet,
            {cssRules} = styleSheet,
            i          = 0,
            len        = data.rules.length,
            j, rulesLen;

        for (; i < len; i++) {
            j        = 0;
            rulesLen = cssRules.length;

            for (; j < rulesLen; j++) {
                if (cssRules[j].selectorText === data.rules[i]) {
                    styleSheet.deleteRule(j);
                    break
                }
            }
        }
    }

    /**
     * @param {String} token
     * @returns {Boolean}
     */
    hasStyleSheet(token) {
        let i   = 0,
            len = document.styleSheets.length,
            sheet;

        for (; i < len; i++) {
            sheet = document.styleSheets[i];
            if (sheet.href?.includes(token)) {
                return true
            }
        }

        return false
    }

    /**
     * @param {Object} data
     * @param {Array} data.rules
     * @protected
     */
    insertCssRules(data) {
        let styleEl = document.getElementById(this.dynamicStyleSheetId),
            i     = 0,
            len   = data.rules.length,
            styleSheet;

        if (!styleEl) {
            styleEl = document.createElement('style');

            styleEl.id = this.dynamicStyleSheetId;
            document.head.appendChild(styleEl)
        }

        styleSheet = styleEl.sheet;

        for (; i < len; i++) {
            styleSheet.insertRule(data.rules[i], styleSheet.cssRules.length)
        }
    }

    /**
     * @param {Object} opts
     * @param {String[]} opts.included
     * @param {String[]} opts.excluded
     */
    removeStyleSheets(opts) {
        let i        = 0,
            len      = document.styleSheets.length,
            included = opts.included || [],
            excluded = opts.included || [],
            sheet, removeSheet;

        for (; i < len; i++) {
            sheet = document.styleSheets[i];

            removeSheet = true;

            if (sheet.href) {
                excluded.forEach(name => {
                    if (sheet.href.includes(name)) {
                        removeSheet = false
                    }
                });

                if (removeSheet) {
                    included.forEach(name => {
                        if (!sheet.href.includes(name)) {
                            removeSheet = false
                        }
                    });

                    if (removeSheet) {
                        sheet.ownerNode.parentNode.removeChild(sheet.ownerNode)
                    }
                }
            }
        }
    }

    /**
     * @param {Object} data
     * @param {String} data.key
     * @param {String} [data.priority] optionally pass 'important'
     * @param {String} data.theme
     * @param {String} data.value
     */
    setCssVariable(data) {
        let {key} = data,
            rule, sheet;

        if (!key.startsWith('--')) {
            key = '--' + key
        }

        for (sheet of document.styleSheets) {
            if (sheet.href.includes(data.theme)) {
                for (rule of sheet.cssRules) {
                    if (Neo.typeOf(rule) === 'CSSStyleRule') {
                        if (rule.style.getPropertyValue(key) !== '') {
                            rule.style.setProperty(key, data.value, data.priority);
                            return true
                        }
                    }
                }
            }
        }

        return false
    }

    /**
     * @param {Object} data
     * @param {String} data.href
     * @param {String} data.id
     */
    swapStyleSheet(data) {
        document.getElementById(data.id).setAttribute('href', data.href)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Stylesheet));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL21haW4vdmVuZG9ycy1zcmNfbWFpbl9hZGRvbl9TdHlsZXNoZWV0X21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUEyQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzREFBUTtBQUMzQjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDLFNBQVM7QUFDVDtBQUNBOztBQUVBLGlFQUFlLG9CQUFvQixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDOUdOOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaURBQUk7QUFDN0I7QUFDQSxnQkFB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsMEJBQTBCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL21haW4vYWRkb24vQmFzZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9tYWluL2FkZG9uL1N0eWxlc2hlZXQubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDb3JlQmFzZSBmcm9tICcuLi8uLi9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBtYWluIHRocmVhZCBhZGRvbnNcbiAqIEBjbGFzcyBOZW8ubWFpbi5hZGRvbi5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIEJhc2UgZXh0ZW5kcyBDb3JlQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ubWFpbi5hZGRvbi5CYXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ubWFpbi5hZGRvbi5CYXNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGlkZW50aWZpZXIgZm9yIGNvcmUuQmFzZSB0byBnZXQgaGFuZGxlZCBsaWtlIHNpbmdsZXRvbnMgZm9yIHJlbW90ZSBtZXRob2QgYWNjZXNzXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzTWFpblRocmVhZEFkZG9uPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaXNNYWluVGhyZWFkQWRkb246IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaWxsIGdldCBzZXQgdG8gdHJ1ZSBvbmNlIGFsbCBhZGRvbiByZWxhdGVkIGZpbGVzIGdvdCBsb2FkZWQgKGlmIHRoZXJlIGlzIGEgbmVlZCB0byBsb2FkKVxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc1JlYWR5Xz1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBpc1JlYWR5XzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbW91bnQgaW4gbXMgdG8gZGVsYXkgdGhlIGxvYWRpbmcgb2YgbGlicmFyeSBmaWxlcywgdW5sZXNzIHJlbW90ZSBtZXRob2QgYWNjZXNzIGhhcHBlbnNcbiAgICAgICAgICogQ2hhbmdlIHRoZSB2YWx1ZSB0byBmYWxzZSBpbiBjYXNlIHlvdSBkb24ndCB3YW50IGFuIGF1dG9tYXRlZCBwcmVsb2FkaW5nXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW58TnVtYmVyfSBwcmVsb2FkRmlsZXNEZWxheT01MDAwXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHByZWxvYWRGaWxlc0RlbGF5OiA1MDAwLFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdFtdfSBjYWNoZT1bXVxuICAgICAqL1xuICAgIGNhY2hlID0gW11cbiAgICAvKipcbiAgICAgKiBXaWxsIGdldCBzZXQgdG8gdHJ1ZSBvbmNlIHdlIHN0YXJ0IGxvYWRpbmcgTW9uYWNvIHJlbGF0ZWQgZmlsZXNcbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc0xvYWRpbmc9ZmFsc2VcbiAgICAgKi9cbiAgICBpc0xvYWRpbmcgPSBmYWxzZVxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGZsYWcgdG8gc3RvcmUgdGhlIHNldFRpbWVvdXQoKSBpZCBmb3IgbG9hZGluZyBleHRlcm5hbCBmaWxlc1xuICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBsb2FkaW5nVGltZW91dElkPW51bGxcbiAgICAgKi9cbiAgICBsb2FkaW5nVGltZW91dElkID0gbnVsbFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUubG9hZEZpbGVzKSB7XG4gICAgICAgICAgICBpZiAobWUucHJlbG9hZEZpbGVzRGVsYXkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBtZS5sb2FkRmlsZXMoKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChOZW8uaXNOdW1iZXIobWUucHJlbG9hZEZpbGVzRGVsYXkpKSB7XG4gICAgICAgICAgICAgICAgbWUubG9hZGluZ1RpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBtZS5sb2FkRmlsZXMoKVxuICAgICAgICAgICAgICAgIH0sIG1lLnByZWxvYWRGaWxlc0RlbGF5KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBpc1JlYWR5IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SXNSZWFkeSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHJldHVyblZhbHVlO1xuXG4gICAgICAgICAgICBtZS5jYWNoZS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gbWVbaXRlbS5mbl0oaXRlbS5kYXRhKTtcbiAgICAgICAgICAgICAgICBpdGVtLnJlc29sdmUocmV0dXJuVmFsdWUpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbWUuY2FjaGUgPSBbXVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWxseSBjYWNoZXMgY2FsbCB3aGVuIGlzUmVhZHk9PT1mYWxzZVxuICAgICAqIExvYWRzIHRoZSBsaWJyYXJ5IGZpbGVzIGluIGNhc2UgdGhpcyBpcyBub3QgYWxyZWFkeSBoYXBwZW5pbmdcbiAgICAgKiBAcGFyYW0gaXRlbVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHVua25vd24+fVxuICAgICAqL1xuICAgIGNhY2hlTWV0aG9kQ2FsbChpdGVtKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5pc0xvYWRpbmcpIHtcbiAgICAgICAgICAgIG1lLmxvYWRpbmdUaW1lb3V0SWQgJiYgY2xlYXJUaW1lb3V0KG1lLmxvYWRpbmdUaW1lb3V0SWQpO1xuICAgICAgICAgICAgbWUubG9hZGluZ1RpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgICAgICBtZS5sb2FkRmlsZXMoKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIG1lLmNhY2hlLnB1c2goey4uLml0ZW0sIHJlc29sdmV9KVxuICAgICAgICB9KVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQmFzZSk7XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuL0Jhc2UubWpzJztcblxuLyoqXG4gKiBMb2dpYyB0byB3b3JrIHdpdGggc3R5bGVzaGVldHMsIGUuZy4gYXBwbHkgJiBzd2l0Y2ggTmVvIGJhc2VkIHRoZW1lc1xuICogbWFpbi5hZGRvbi5IaWdobGlnaHRKUyByZXF1aXJlcyB0aGlzIGZpbGVcbiAqIEBjbGFzcyBOZW8ubWFpbi5hZGRvbi5TdHlsZXNoZWV0XG4gKiBAZXh0ZW5kcyBOZW8ubWFpbi5hZGRvbi5CYXNlXG4gKi9cbmNsYXNzIFN0eWxlc2hlZXQgZXh0ZW5kcyBCYXNlIHtcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGR5bmFtaWNTdHlsZVNoZWV0SWQ9J25lby1keW5hbWljLXN0eWxlc2hlZXQnXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGR5bmFtaWNTdHlsZVNoZWV0SWQgPSAnbmVvLWR5bmFtaWMtc3R5bGVzaGVldCc7XG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5tYWluLmFkZG9uLlN0eWxlc2hlZXQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5tYWluLmFkZG9uLlN0eWxlc2hlZXQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3RlIG1ldGhvZCBhY2Nlc3MgZm9yIG90aGVyIHdvcmtlcnNcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSByZW1vdGU9e2FwcDogWy8vLi4uXX1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3RlOiB7XG4gICAgICAgICAgICBhcHA6IFtcbiAgICAgICAgICAgICAgICAnYWRkVGhlbWVGaWxlcycsXG4gICAgICAgICAgICAgICAgJ2NyZWF0ZVN0eWxlU2hlZXQnLFxuICAgICAgICAgICAgICAgICdkZWxldGVDc3NSdWxlcycsXG4gICAgICAgICAgICAgICAgJ2luc2VydENzc1J1bGVzJyxcbiAgICAgICAgICAgICAgICAnc2V0Q3NzVmFyaWFibGUnLFxuICAgICAgICAgICAgICAgICdzd2FwU3R5bGVTaGVldCdcbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBuZW9Db25maWcgPSBOZW8uY29uZmlnLFxuICAgICAgICAgICAgZmFQYXRoO1xuXG4gICAgICAgIGlmIChuZW9Db25maWcudXNlRm9udEF3ZXNvbWUpIHtcbiAgICAgICAgICAgIGlmIChuZW9Db25maWcuZW52aXJvbm1lbnQgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgICAgICBmYVBhdGggPSBuZW9Db25maWcuYmFzZVBhdGggKyAnbm9kZV9tb2R1bGVzL0Bmb3J0YXdlc29tZS9mb250YXdlc29tZS1mcmVlL2Nzcy9hbGwubWluLmNzcydcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmFQYXRoID0gbmVvQ29uZmlnLmJhc2VQYXRoLnN1YnN0cig2KSArICdyZXNvdXJjZXMvZm9udGF3ZXNvbWUtZnJlZS9jc3MvYWxsLm1pbi5jc3MnXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY3JlYXRlU3R5bGVTaGVldChudWxsLCBudWxsLCBmYVBhdGgpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmVvQ29uZmlnLnRoZW1lcy5sZW5ndGggPiAwICYmIG5lb0NvbmZpZy50aGVtZXNbMF0gIT09ICcnKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEdsb2JhbENzcygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGFkZEdsb2JhbENzcygpIHtcbiAgICAgICAgbGV0IHtjb25maWd9ID0gTmVvLFxuICAgICAgICAgICAge3RoZW1lc30gPSBjb25maWcsXG4gICAgICAgICAgICBmb2xkZXJzICA9IFsnc3JjJywgLi4udGhlbWVzXSxcbiAgICAgICAgICAgIGVudiAgICAgID0gY29uZmlnLmVudmlyb25tZW50LFxuICAgICAgICAgICAgcGF0aCAgICAgID0gZW52LnN0YXJ0c1dpdGgoJ2Rpc3QvJykgPyAnJyA6IGNvbmZpZy5hcHBQYXRoLmluY2x1ZGVzKCdkb2NzJykgPyBgLi4vZGlzdC8ke2Vudn0vYCA6IGAuLi8uLi9kaXN0LyR7ZW52fS9gLFxuICAgICAgICAgICAgcm9vdFBhdGggPSBjb25maWcuYmFzZVBhdGguc3Vic3RyaW5nKDYpO1xuXG4gICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCh0aGVtZXNbMF0pO1xuXG4gICAgICAgIGZvbGRlcnMuZm9yRWFjaChmb2xkZXIgPT4ge1xuICAgICAgICAgICAgaWYgKGZvbGRlci5zdGFydHNXaXRoKCduZW8tJykpIHtcbiAgICAgICAgICAgICAgICBmb2xkZXIgPSBmb2xkZXIuc3Vic3RyaW5nKDQpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY3JlYXRlU3R5bGVTaGVldChcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgYCR7cm9vdFBhdGh9JHtwYXRofWNzcy8ke2ZvbGRlcn0vR2xvYmFsLmNzc2BcbiAgICAgICAgICAgIClcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmFwcE5hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5jbGFzc05hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBkYXRhLmZvbGRlcnNcbiAgICAgKi9cbiAgICBhc3luYyBhZGRUaGVtZUZpbGVzKGRhdGEpIHtcbiAgICAgICAgbGV0IHtjbGFzc05hbWV9ID0gZGF0YSxcbiAgICAgICAgICAgIHtjb25maWd9ICAgID0gTmVvLFxuICAgICAgICAgICAgZW52ICAgICAgICAgPSBjb25maWcuZW52aXJvbm1lbnQsXG4gICAgICAgICAgICBwYXRoICAgICAgICA9IGVudi5zdGFydHNXaXRoKCdkaXN0LycpID8gJycgOiBjb25maWcuYXBwUGF0aC5pbmNsdWRlcygnZG9jcycpID8gYC4uL2Rpc3QvJHtlbnZ9L2AgOiBgLi4vLi4vZGlzdC8ke2Vudn0vYCxcbiAgICAgICAgICAgIHByb21pc2VzICAgID0gW10sXG4gICAgICAgICAgICByb290UGF0aCAgICA9IGNvbmZpZy5iYXNlUGF0aC5zdWJzdHJpbmcoNik7XG5cbiAgICAgICAgaWYgKGNsYXNzTmFtZS5zdGFydHNXaXRoKCdOZW8uJykpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZS5zdWJzdHJpbmcoNClcbiAgICAgICAgfVxuXG4gICAgICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZS5zcGxpdCgnLicpLmpvaW4oJy8nKTtcblxuICAgICAgICBkYXRhLmZvbGRlcnMuZm9yRWFjaChmb2xkZXIgPT4ge1xuICAgICAgICAgICAgaWYgKGZvbGRlciA9PT0gJ3NyYycgfHwgZm9sZGVyLmluY2x1ZGVzKCd0aGVtZS0nKSAmJiBjb25maWcudGhlbWVzLmluY2x1ZGVzKGBuZW8tJHtmb2xkZXJ9YCkpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuY3JlYXRlU3R5bGVTaGVldChcbiAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgYCR7cm9vdFBhdGh9JHtwYXRofWNzcy8ke2ZvbGRlcn0vJHtjbGFzc05hbWV9LmNzc2BcbiAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgZWl0aGVyIG5hbWUgZm9yIGEgbmVvIHRoZW1lIChlLmcuICduZW8tdGhlbWUtZGFyay5jc3MnKSBvciBwYXNzIGEgaHJlZlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbbmFtZV1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2lkXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbaHJlZl1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVTdHlsZVNoZWV0KG5hbWUsIGlkLCBocmVmKSB7XG4gICAgICAgIGlmICghbmFtZSAmJiAhaHJlZikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcmVhdGVTdHlsZVNoZWV0OiB5b3UgbmVlZCB0byBlaXRoZXIgcGFzcyBhIG5hbWUgb3IgYSBocmVmJylcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKSxcbiAgICAgICAgICAgICAgICBlbnYgID0gTmVvLmNvbmZpZy5lbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICBwYXRoID0gZW52LnN0YXJ0c1dpdGgoJ2Rpc3QvJykgPyBlbnYgOiAoJ2Rpc3QvJyArIGVudiksXG4gICAgICAgICAgICAgICAgdXJsICA9IGhyZWYgPyBocmVmIDogTmVvLmNvbmZpZy5iYXNlUGF0aCArIHBhdGggKyAnLycgKyBuYW1lO1xuXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGxpbmssIHtcbiAgICAgICAgICAgICAgICBocmVmOiB1cmwsXG4gICAgICAgICAgICAgICAgcmVsIDogJ3N0eWxlc2hlZXQnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0L2NzcydcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgICAgICBsaW5rLmlkID0gaWRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGluay5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uKCkge3JlamVjdCgpfSlcbiAgICAgICAgICAgIGxpbmsuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICBmdW5jdGlvbigpIHtyZXNvbHZlKCl9KVxuXG4gICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGxpbmspXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhLnJ1bGVzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGRlbGV0ZUNzc1J1bGVzKGRhdGEpIHtcbiAgICAgICAgbGV0IHN0eWxlRWwgICAgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmR5bmFtaWNTdHlsZVNoZWV0SWQpLFxuICAgICAgICAgICAgc3R5bGVTaGVldCA9IHN0eWxlRWwuc2hlZXQsXG4gICAgICAgICAgICB7Y3NzUnVsZXN9ID0gc3R5bGVTaGVldCxcbiAgICAgICAgICAgIGkgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgbGVuICAgICAgICA9IGRhdGEucnVsZXMubGVuZ3RoLFxuICAgICAgICAgICAgaiwgcnVsZXNMZW47XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaiAgICAgICAgPSAwO1xuICAgICAgICAgICAgcnVsZXNMZW4gPSBjc3NSdWxlcy5sZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAoOyBqIDwgcnVsZXNMZW47IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChjc3NSdWxlc1tqXS5zZWxlY3RvclRleHQgPT09IGRhdGEucnVsZXNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVTaGVldC5kZWxldGVSdWxlKGopO1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0b2tlblxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGhhc1N0eWxlU2hlZXQodG9rZW4pIHtcbiAgICAgICAgbGV0IGkgICA9IDAsXG4gICAgICAgICAgICBsZW4gPSBkb2N1bWVudC5zdHlsZVNoZWV0cy5sZW5ndGgsXG4gICAgICAgICAgICBzaGVldDtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBzaGVldCA9IGRvY3VtZW50LnN0eWxlU2hlZXRzW2ldO1xuICAgICAgICAgICAgaWYgKHNoZWV0LmhyZWY/LmluY2x1ZGVzKHRva2VuKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGRhdGEucnVsZXNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaW5zZXJ0Q3NzUnVsZXMoZGF0YSkge1xuICAgICAgICBsZXQgc3R5bGVFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuZHluYW1pY1N0eWxlU2hlZXRJZCksXG4gICAgICAgICAgICBpICAgICA9IDAsXG4gICAgICAgICAgICBsZW4gICA9IGRhdGEucnVsZXMubGVuZ3RoLFxuICAgICAgICAgICAgc3R5bGVTaGVldDtcblxuICAgICAgICBpZiAoIXN0eWxlRWwpIHtcbiAgICAgICAgICAgIHN0eWxlRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuXG4gICAgICAgICAgICBzdHlsZUVsLmlkID0gdGhpcy5keW5hbWljU3R5bGVTaGVldElkO1xuICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsKVxuICAgICAgICB9XG5cbiAgICAgICAgc3R5bGVTaGVldCA9IHN0eWxlRWwuc2hlZXQ7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgc3R5bGVTaGVldC5pbnNlcnRSdWxlKGRhdGEucnVsZXNbaV0sIHN0eWxlU2hlZXQuY3NzUnVsZXMubGVuZ3RoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBvcHRzLmluY2x1ZGVkXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gb3B0cy5leGNsdWRlZFxuICAgICAqL1xuICAgIHJlbW92ZVN0eWxlU2hlZXRzKG9wdHMpIHtcbiAgICAgICAgbGV0IGkgICAgICAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgICAgID0gZG9jdW1lbnQuc3R5bGVTaGVldHMubGVuZ3RoLFxuICAgICAgICAgICAgaW5jbHVkZWQgPSBvcHRzLmluY2x1ZGVkIHx8IFtdLFxuICAgICAgICAgICAgZXhjbHVkZWQgPSBvcHRzLmluY2x1ZGVkIHx8IFtdLFxuICAgICAgICAgICAgc2hlZXQsIHJlbW92ZVNoZWV0O1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHNoZWV0ID0gZG9jdW1lbnQuc3R5bGVTaGVldHNbaV07XG5cbiAgICAgICAgICAgIHJlbW92ZVNoZWV0ID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKHNoZWV0LmhyZWYpIHtcbiAgICAgICAgICAgICAgICBleGNsdWRlZC5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hlZXQuaHJlZi5pbmNsdWRlcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlU2hlZXQgPSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZlU2hlZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVkZWQuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2hlZXQuaHJlZi5pbmNsdWRlcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZVNoZWV0ID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW92ZVNoZWV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGVldC5vd25lck5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzaGVldC5vd25lck5vZGUpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmtleVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZGF0YS5wcmlvcml0eV0gb3B0aW9uYWxseSBwYXNzICdpbXBvcnRhbnQnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEudGhlbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS52YWx1ZVxuICAgICAqL1xuICAgIHNldENzc1ZhcmlhYmxlKGRhdGEpIHtcbiAgICAgICAgbGV0IHtrZXl9ID0gZGF0YSxcbiAgICAgICAgICAgIHJ1bGUsIHNoZWV0O1xuXG4gICAgICAgIGlmICgha2V5LnN0YXJ0c1dpdGgoJy0tJykpIHtcbiAgICAgICAgICAgIGtleSA9ICctLScgKyBrZXlcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoc2hlZXQgb2YgZG9jdW1lbnQuc3R5bGVTaGVldHMpIHtcbiAgICAgICAgICAgIGlmIChzaGVldC5ocmVmLmluY2x1ZGVzKGRhdGEudGhlbWUpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChydWxlIG9mIHNoZWV0LmNzc1J1bGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChOZW8udHlwZU9mKHJ1bGUpID09PSAnQ1NTU3R5bGVSdWxlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGUuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShrZXkpICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuc3R5bGUuc2V0UHJvcGVydHkoa2V5LCBkYXRhLnZhbHVlLCBkYXRhLnByaW9yaXR5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5ocmVmXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuaWRcbiAgICAgKi9cbiAgICBzd2FwU3R5bGVTaGVldChkYXRhKSB7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRhdGEuaWQpLnNldEF0dHJpYnV0ZSgnaHJlZicsIGRhdGEuaHJlZilcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFN0eWxlc2hlZXQpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9