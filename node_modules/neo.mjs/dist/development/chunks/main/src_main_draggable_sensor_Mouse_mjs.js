"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["src_main_draggable_sensor_Mouse_mjs"],{

/***/ "./src/main/draggable/sensor/Base.mjs":
/*!********************************************!*\
  !*** ./src/main/draggable/sensor/Base.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Base)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * Abstract base class for other sensors
 * @class Neo.main.draggable.sensor.Base
 * @extends Neo.core.Base
 */
class Base extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static getConfig() {return {
        /**
         * @member {String} className='Neo.main.draggable.sensor.Base'
         * @protected
         */
        className: 'Neo.main.draggable.sensor.Base',
        /**
         * @member {HTMLElement|null} currentElement=null
         * @protected
         */
        currentElement: null,
        /**
         * @member {String[]} dragTargetClasses=['neo-draggable','neo-resizable']
         */
        dragTargetClasses: ['neo-draggable', 'neo-resizable'],
        /**
         * @member {Boolean} isDragging=false
         * @protected
         */
        isDragging: false,
        /**
         * @member {Event|null} lastEvent=null
         * @protected
         */
        lastEvent: null,
        /**
         * @member {Event|null} startEvent=null
         * @protected
         */
        startEvent: null
    }}

    /**
     * Attaches sensors event listeners to the DOM
     */
    attach() {}

    /**
     * Detaches sensors event listeners from the DOM
     */
    detach() {}

    /**
     *
     */
    onConstructed() {
        this.attach();
        super.onConstructed();
    }

    /**
     * Triggers a custom event on the target element
     * @param {HTMLElement} element - Element to trigger event on
     * @param {Object} sensorEvent - Sensor event to trigger
     * @returns {Event}
     */
    trigger(element, sensorEvent) {
        const event = document.createEvent('Event');
        event.detail = sensorEvent;
        event.initEvent(sensorEvent.type, true, true);
        element.dispatchEvent(event);
        this.lastEvent = sensorEvent;

        return sensorEvent;
    }
}

Neo.applyClassConfig(Base);




/***/ }),

/***/ "./src/main/draggable/sensor/Mouse.mjs":
/*!*********************************************!*\
  !*** ./src/main/draggable/sensor/Mouse.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Mouse)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/main/draggable/sensor/Base.mjs");
/* harmony import */ var _DomEvents_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../DomEvents.mjs */ "./src/main/DomEvents.mjs");



/**
 * @class Neo.main.draggable.sensor.Mouse
 * @extends Neo.main.draggable.sensor.Base
 */
class Mouse extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static getConfig() {return {
        /**
         * @member {String} className='Neo.main.draggable.sensor.Mouse'
         * @protected
         */
        className: 'Neo.main.draggable.sensor.Mouse',
        /**
         * @member {Number} delay=0
         */
        delay: 0,
        /**
         * @member {Number} minDistance=1
         */
        minDistance: 1,
        /**
         * @member {Number} mouseDownTime=0
         */
        mouseDownTime: 0,
        /**
         * @member {Number|null} mouseDownTimeout=null
         */
        mouseDownTimeout: null,
        /**
         * @member {Number|null} pageX=null
         * @protected
         */
        pageX: null,
        /**
         * @member {Number|null} pageY=null
         * @protected
         */
        pageY: null
    }}

    /**
     * @param config
     */
    construct(config) {
        super.construct(config);
        Neo.bindMethods(this, ['onDistanceChange', 'onMouseDown', 'onMouseMove', 'onMouseUp']);
    }

    /**
     * Attaches sensors event listeners to the DOM
     */
    attach() {
        document.addEventListener('mousedown', this.onMouseDown, true);
    }

    /**
     * Detaches sensors event listeners from the DOM
     */
    detach() {
        document.removeEventListener('mousedown', this.onMouseDown, true);
    }

    /**
     * Detect change in distance, starting drag when both delay and distance requirements are met
     * @param {MouseEvent|Object} event - Object in case it does get trigger via the mouseDownTimeout
     */
    onDistanceChange(event) {
        let me = this;

        if (me.currentElement) {
            const {pageX, pageY}    = event,
                  timeElapsed       = Date.now() - me.mouseDownTime,
                  distanceTravelled = _DomEvents_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getDistance(me.startEvent.pageX, me.startEvent.pageY, pageX, pageY) || 0;

            Object.assign(me, {pageX, pageY});

            if (timeElapsed >= me.delay && distanceTravelled >= me.minDistance) {
                clearTimeout(me.mouseDownTimeout);
                document.removeEventListener('mousemove', me.onDistanceChange);
                me.startDrag();
            }
        }
    }

    /**
     * @param {MouseEvent} event
     */
    onMouseDown(event) {
        if (event.button === 0 && !event.ctrlKey && !event.metaKey) {
            let me     = this,
                target = _DomEvents_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].testPathInclusion(event, me.dragTargetClasses);

            // see: https://github.com/neomjs/neo/issues/2669
            if (!event.path) {
                event.path = event.composedPath();
            }

            if (target) {
                Object.assign(me, {
                    currentElement: target.node,
                    mouseDownTime : Date.now(),
                    pageX         : event.pageX,
                    pageY         : event.pageY,
                    startEvent    : event
                });

                document.addEventListener('dragstart', preventDefault);
                document.addEventListener('mousemove', me.onDistanceChange);
                document.addEventListener('mouseup',   me.onMouseUp);

                me.mouseDownTimeout = setTimeout(() => {
                    me.onDistanceChange({pageX: me.pageX, pageY: me.pageY});
                }, me.delay);
            }
        }
    }

    /**
     * @param {MouseEvent} event
     */
    onMouseMove(event) {
        let me = this;

        if (me.dragging) {
            let element = me.currentElement,
                target  = document.elementFromPoint(event.clientX, event.clientY);

            me.trigger(element, {
                clientX      : event.clientX,
                clientY      : event.clientY,
                element,
                originalEvent: event,
                path         : me.startEvent.path || me.startEvent.composedPath(),
                target,
                type         : 'drag:move'
            });
        }
    }

    /**
     * @param {MouseEvent} event
     */
    onMouseUp(event) {
        if (event.button === 0) {
            let me = this;

            clearTimeout(me.mouseDownTimeout);

            document.removeEventListener('dragstart', preventDefault);
            document.removeEventListener('mousemove', me.onDistanceChange);
            document.removeEventListener('mouseup',   me.onMouseUp);

            if (me.dragging) {
                let element = me.currentElement,
                    target  = document.elementFromPoint(event.clientX, event.clientY);

                me.trigger(element, {
                    clientX      : event.clientX,
                    clientY      : event.clientY,
                    element,
                    originalEvent: event,
                    path         : me.startEvent.path || me.startEvent.composedPath(),
                    target,
                    type         : 'drag:end'
                });

                document.removeEventListener('contextmenu', preventDefault, true);
                document.removeEventListener('mousemove',   me.onMouseMove);

                Object.assign(me, {
                    currentElement: null,
                    dragging      : false,
                    startEvent    : null
                });
            }

            me.dragging = false;
        }
    }

    /**
     *
     */
    startDrag() {
        let me         = this,
            element    = me.currentElement,
            startEvent = me.startEvent;

        me.trigger(element, {
            clientX      : startEvent.clientX,
            clientY      : startEvent.clientY,
            element,
            originalEvent: startEvent,
            path         : startEvent.path || startEvent.composedPath(),
            target       : startEvent.target,
            type         : 'drag:start'
        });

        me.dragging = true;

        if (me.dragging) {
            document.addEventListener('contextmenu', preventDefault, true);
            document.addEventListener('mousemove',   me.onMouseMove);
        }
    }
}

function preventDefault(event) {
    event.preventDefault();
}

Neo.applyClassConfig(Mouse);




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL21haW4vc3JjX21haW5fZHJhZ2dhYmxlX3NlbnNvcl9Nb3VzZV9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBOEM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0RBQVE7QUFDM0Isd0JBQXdCO0FBQ3hCO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRXlCOzs7Ozs7Ozs7Ozs7Ozs7OztBQzdFVTtBQUNTOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpREFBSTtBQUN4Qix3QkFBd0I7QUFDeEI7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBLHNDQUFzQyxrRUFBcUI7O0FBRTNELCtCQUErQixhQUFhOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix3RUFBMkI7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUMsaUNBQWlDO0FBQzFFLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUUwQiIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvbWFpbi9kcmFnZ2FibGUvc2Vuc29yL0Jhc2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvbWFpbi9kcmFnZ2FibGUvc2Vuc29yL01vdXNlLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ29yZUJhc2UgZnJvbSAnLi4vLi4vLi4vY29yZS9CYXNlLm1qcyc7XG5cbi8qKlxuICogQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3Igb3RoZXIgc2Vuc29yc1xuICogQGNsYXNzIE5lby5tYWluLmRyYWdnYWJsZS5zZW5zb3IuQmFzZVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBCYXNlIGV4dGVuZHMgQ29yZUJhc2Uge1xuICAgIHN0YXRpYyBnZXRDb25maWcoKSB7cmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ubWFpbi5kcmFnZ2FibGUuc2Vuc29yLkJhc2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5tYWluLmRyYWdnYWJsZS5zZW5zb3IuQmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtIVE1MRWxlbWVudHxudWxsfSBjdXJyZW50RWxlbWVudD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGN1cnJlbnRFbGVtZW50OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGRyYWdUYXJnZXRDbGFzc2VzPVsnbmVvLWRyYWdnYWJsZScsJ25lby1yZXNpemFibGUnXVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ1RhcmdldENsYXNzZXM6IFsnbmVvLWRyYWdnYWJsZScsICduZW8tcmVzaXphYmxlJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc0RyYWdnaW5nPWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGlzRHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7RXZlbnR8bnVsbH0gbGFzdEV2ZW50PW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbGFzdEV2ZW50OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7RXZlbnR8bnVsbH0gc3RhcnRFdmVudD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHN0YXJ0RXZlbnQ6IG51bGxcbiAgICB9fVxuXG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgc2Vuc29ycyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIERPTVxuICAgICAqL1xuICAgIGF0dGFjaCgpIHt9XG5cbiAgICAvKipcbiAgICAgKiBEZXRhY2hlcyBzZW5zb3JzIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSBET01cbiAgICAgKi9cbiAgICBkZXRhY2goKSB7fVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNvbnN0cnVjdGVkKCkge1xuICAgICAgICB0aGlzLmF0dGFjaCgpO1xuICAgICAgICBzdXBlci5vbkNvbnN0cnVjdGVkKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcnMgYSBjdXN0b20gZXZlbnQgb24gdGhlIHRhcmdldCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gdHJpZ2dlciBldmVudCBvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZW5zb3JFdmVudCAtIFNlbnNvciBldmVudCB0byB0cmlnZ2VyXG4gICAgICogQHJldHVybnMge0V2ZW50fVxuICAgICAqL1xuICAgIHRyaWdnZXIoZWxlbWVudCwgc2Vuc29yRXZlbnQpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgICAgZXZlbnQuZGV0YWlsID0gc2Vuc29yRXZlbnQ7XG4gICAgICAgIGV2ZW50LmluaXRFdmVudChzZW5zb3JFdmVudC50eXBlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgdGhpcy5sYXN0RXZlbnQgPSBzZW5zb3JFdmVudDtcblxuICAgICAgICByZXR1cm4gc2Vuc29yRXZlbnQ7XG4gICAgfVxufVxuXG5OZW8uYXBwbHlDbGFzc0NvbmZpZyhCYXNlKTtcblxuZXhwb3J0IHtCYXNlIGFzIGRlZmF1bHR9O1xuIiwiaW1wb3J0IEJhc2UgICAgICBmcm9tICcuL0Jhc2UubWpzJztcbmltcG9ydCBEb21FdmVudHMgZnJvbSAnLi4vLi4vRG9tRXZlbnRzLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5tYWluLmRyYWdnYWJsZS5zZW5zb3IuTW91c2VcbiAqIEBleHRlbmRzIE5lby5tYWluLmRyYWdnYWJsZS5zZW5zb3IuQmFzZVxuICovXG5jbGFzcyBNb3VzZSBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBnZXRDb25maWcoKSB7cmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ubWFpbi5kcmFnZ2FibGUuc2Vuc29yLk1vdXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ubWFpbi5kcmFnZ2FibGUuc2Vuc29yLk1vdXNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gZGVsYXk9MFxuICAgICAgICAgKi9cbiAgICAgICAgZGVsYXk6IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IG1pbkRpc3RhbmNlPTFcbiAgICAgICAgICovXG4gICAgICAgIG1pbkRpc3RhbmNlOiAxLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBtb3VzZURvd25UaW1lPTBcbiAgICAgICAgICovXG4gICAgICAgIG1vdXNlRG93blRpbWU6IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gbW91c2VEb3duVGltZW91dD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBtb3VzZURvd25UaW1lb3V0OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IHBhZ2VYPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcGFnZVg6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gcGFnZVk9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBwYWdlWTogbnVsbFxuICAgIH19XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcbiAgICAgICAgTmVvLmJpbmRNZXRob2RzKHRoaXMsIFsnb25EaXN0YW5jZUNoYW5nZScsICdvbk1vdXNlRG93bicsICdvbk1vdXNlTW92ZScsICdvbk1vdXNlVXAnXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgc2Vuc29ycyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIERPTVxuICAgICAqL1xuICAgIGF0dGFjaCgpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93biwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0YWNoZXMgc2Vuc29ycyBldmVudCBsaXN0ZW5lcnMgZnJvbSB0aGUgRE9NXG4gICAgICovXG4gICAgZGV0YWNoKCkge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgY2hhbmdlIGluIGRpc3RhbmNlLCBzdGFydGluZyBkcmFnIHdoZW4gYm90aCBkZWxheSBhbmQgZGlzdGFuY2UgcmVxdWlyZW1lbnRzIGFyZSBtZXRcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR8T2JqZWN0fSBldmVudCAtIE9iamVjdCBpbiBjYXNlIGl0IGRvZXMgZ2V0IHRyaWdnZXIgdmlhIHRoZSBtb3VzZURvd25UaW1lb3V0XG4gICAgICovXG4gICAgb25EaXN0YW5jZUNoYW5nZShldmVudCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5jdXJyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3Qge3BhZ2VYLCBwYWdlWX0gICAgPSBldmVudCxcbiAgICAgICAgICAgICAgICAgIHRpbWVFbGFwc2VkICAgICAgID0gRGF0ZS5ub3coKSAtIG1lLm1vdXNlRG93blRpbWUsXG4gICAgICAgICAgICAgICAgICBkaXN0YW5jZVRyYXZlbGxlZCA9IERvbUV2ZW50cy5nZXREaXN0YW5jZShtZS5zdGFydEV2ZW50LnBhZ2VYLCBtZS5zdGFydEV2ZW50LnBhZ2VZLCBwYWdlWCwgcGFnZVkpIHx8IDA7XG5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obWUsIHtwYWdlWCwgcGFnZVl9KTtcblxuICAgICAgICAgICAgaWYgKHRpbWVFbGFwc2VkID49IG1lLmRlbGF5ICYmIGRpc3RhbmNlVHJhdmVsbGVkID49IG1lLm1pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KG1lLm1vdXNlRG93blRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1lLm9uRGlzdGFuY2VDaGFuZ2UpO1xuICAgICAgICAgICAgICAgIG1lLnN0YXJ0RHJhZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VEb3duKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5idXR0b24gPT09IDAgJiYgIWV2ZW50LmN0cmxLZXkgJiYgIWV2ZW50Lm1ldGFLZXkpIHtcbiAgICAgICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHRhcmdldCA9IERvbUV2ZW50cy50ZXN0UGF0aEluY2x1c2lvbihldmVudCwgbWUuZHJhZ1RhcmdldENsYXNzZXMpO1xuXG4gICAgICAgICAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9uZW9tanMvbmVvL2lzc3Vlcy8yNjY5XG4gICAgICAgICAgICBpZiAoIWV2ZW50LnBhdGgpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wYXRoID0gZXZlbnQuY29tcG9zZWRQYXRoKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKG1lLCB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRFbGVtZW50OiB0YXJnZXQubm9kZSxcbiAgICAgICAgICAgICAgICAgICAgbW91c2VEb3duVGltZSA6IERhdGUubm93KCksXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VYICAgICAgICAgOiBldmVudC5wYWdlWCxcbiAgICAgICAgICAgICAgICAgICAgcGFnZVkgICAgICAgICA6IGV2ZW50LnBhZ2VZLFxuICAgICAgICAgICAgICAgICAgICBzdGFydEV2ZW50ICAgIDogZXZlbnRcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBtZS5vbkRpc3RhbmNlQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgICBtZS5vbk1vdXNlVXApO1xuXG4gICAgICAgICAgICAgICAgbWUubW91c2VEb3duVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBtZS5vbkRpc3RhbmNlQ2hhbmdlKHtwYWdlWDogbWUucGFnZVgsIHBhZ2VZOiBtZS5wYWdlWX0pO1xuICAgICAgICAgICAgICAgIH0sIG1lLmRlbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlTW92ZShldmVudCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5kcmFnZ2luZykge1xuICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSBtZS5jdXJyZW50RWxlbWVudCxcbiAgICAgICAgICAgICAgICB0YXJnZXQgID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcblxuICAgICAgICAgICAgbWUudHJpZ2dlcihlbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgY2xpZW50WCAgICAgIDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgICAgICAgICBjbGllbnRZICAgICAgOiBldmVudC5jbGllbnRZLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQsXG4gICAgICAgICAgICAgICAgcGF0aCAgICAgICAgIDogbWUuc3RhcnRFdmVudC5wYXRoIHx8IG1lLnN0YXJ0RXZlbnQuY29tcG9zZWRQYXRoKCksXG4gICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgIHR5cGUgICAgICAgICA6ICdkcmFnOm1vdmUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlVXAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiA9PT0gMCkge1xuICAgICAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KG1lLm1vdXNlRG93blRpbWVvdXQpO1xuXG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBtZS5vbkRpc3RhbmNlQ2hhbmdlKTtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCAgIG1lLm9uTW91c2VVcCk7XG5cbiAgICAgICAgICAgIGlmIChtZS5kcmFnZ2luZykge1xuICAgICAgICAgICAgICAgIGxldCBlbGVtZW50ID0gbWUuY3VycmVudEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCAgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuXG4gICAgICAgICAgICAgICAgbWUudHJpZ2dlcihlbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudFggICAgICA6IGV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudFkgICAgICA6IGV2ZW50LmNsaWVudFksXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBwYXRoICAgICAgICAgOiBtZS5zdGFydEV2ZW50LnBhdGggfHwgbWUuc3RhcnRFdmVudC5jb21wb3NlZFBhdGgoKSxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICB0eXBlICAgICAgICAgOiAnZHJhZzplbmQnXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHByZXZlbnREZWZhdWx0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCAgIG1lLm9uTW91c2VNb3ZlKTtcblxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obWUsIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEVsZW1lbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGRyYWdnaW5nICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRFdmVudCAgICA6IG51bGxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgc3RhcnREcmFnKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBlbGVtZW50ICAgID0gbWUuY3VycmVudEVsZW1lbnQsXG4gICAgICAgICAgICBzdGFydEV2ZW50ID0gbWUuc3RhcnRFdmVudDtcblxuICAgICAgICBtZS50cmlnZ2VyKGVsZW1lbnQsIHtcbiAgICAgICAgICAgIGNsaWVudFggICAgICA6IHN0YXJ0RXZlbnQuY2xpZW50WCxcbiAgICAgICAgICAgIGNsaWVudFkgICAgICA6IHN0YXJ0RXZlbnQuY2xpZW50WSxcbiAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBzdGFydEV2ZW50LFxuICAgICAgICAgICAgcGF0aCAgICAgICAgIDogc3RhcnRFdmVudC5wYXRoIHx8IHN0YXJ0RXZlbnQuY29tcG9zZWRQYXRoKCksXG4gICAgICAgICAgICB0YXJnZXQgICAgICAgOiBzdGFydEV2ZW50LnRhcmdldCxcbiAgICAgICAgICAgIHR5cGUgICAgICAgICA6ICdkcmFnOnN0YXJ0J1xuICAgICAgICB9KTtcblxuICAgICAgICBtZS5kcmFnZ2luZyA9IHRydWU7XG5cbiAgICAgICAgaWYgKG1lLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHByZXZlbnREZWZhdWx0LCB0cnVlKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsICAgbWUub25Nb3VzZU1vdmUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKE1vdXNlKTtcblxuZXhwb3J0IHtNb3VzZSBhcyBkZWZhdWx0fTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==