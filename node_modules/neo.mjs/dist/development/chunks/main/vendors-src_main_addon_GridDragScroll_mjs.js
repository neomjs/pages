export const __webpack_esm_id__ = "vendors-src_main_addon_GridDragScroll_mjs";
export const __webpack_esm_ids__ = ["vendors-src_main_addon_GridDragScroll_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./src/main/addon/Base.mjs"
/*!*********************************!*\
  !*** ./src/main/addon/Base.mjs ***!
  \*********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * Base class for main thread addons
 * @class Neo.main.addon.Base
 * @extends Neo.core.Base
 *
 * This version aligns the file loading and readiness state according to the rule:
 * `initAsync()` MUST await for `loadFiles()` to be completed before the addon is considered `isReady`.
 * `preloadFilesDelay` controls when `loadFiles()` is initiated in the background, but can be
 * overridden by `cacheMethodCall()`.
 */
class Base extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.main.addon.Base'
         * @protected
         */
        className: 'Neo.main.addon.Base',
        /**
         * An identifier for core.Base to get handled like singletons for remote method access
         * @member {Boolean} isMainThreadAddon=true
         * @protected
         */
        isMainThreadAddon: true,
        /**
         * Amount in ms to delay the background loading of library files.
         * Set to `false` to disable automated preloading and rely solely on lazy loading
         * via `cacheMethodCall()`. Set to `0` for immediate background preload.
         * @member {Boolean|Number} preloadFilesDelay=5000
         * @protected
         */
        preloadFilesDelay: 5000,
        /**
         * Remote method access for other workers
         * @member {Object} remote
         * @protected
         */
        remote: {
            app: [
                'loadFiles'
            ]
        },
        /**
         * @member {Boolean} useLazyLoading=false
         */
        useLazyLoading: false
    }

    /**
     * Internal cache for remote method calls received when `isReady` is false.
     * @member {Object[]} cache=[]
     */
    cache = []
    /**
     * Returns true if `loadFiles()` has been initiated and is currently in progress.
     * @member {Boolean} isLoading
     */
    get isLoading() {
        // isLoading is true if the promise exists and its resolver is still available (meaning it's pending).
        return !!this.#loadFilesPromise && !!this.#loadFilesPromiseResolver
    }
    /**
     * A private promise that tracks the completion of `loadFiles()`.
     * This ensures `loadFiles()` is called only once and can be awaited by multiple consumers.
     * @member {Promise<void>|null} #loadFilesPromise=null
     */
    #loadFilesPromise = null
    /**
     * The `resolve` function for `#loadFilesPromise`, allowing external control over its resolution.
     * @member {Function|null} #loadFilesPromiseResolver=null
     */
    #loadFilesPromiseResolver = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        // Initialize #loadFilesPromise as a controllable promise.
        // This promise will be awaited by initAsync and resolved by executeLoadFiles.
        me.#loadFilesPromise = new Promise(resolve => {
            me.#loadFilesPromiseResolver = resolve
        });

        if (me.useLazyLoading) {
            // Do nothing. The promise remains pending, blocking initAsync (keeping isReady: false).
            // Main thread is not blocked because it only waits for remotesReady().
            // The first remote call will trigger interception -> cacheMethodCall -> executeLoadFiles.
        } else if (me.preloadFilesDelay === false) {
            // No automated preload: resolve #loadFilesPromise immediately as it won't be triggered by delay.
            // It will only be triggered by cacheMethodCall or initAsync if needed.
            me.#loadFilesPromiseResolver();
            me.#loadFilesPromiseResolver = null // Mark as resolved/no longer pending
        } else {
            const delay = Neo.isNumber(me.preloadFilesDelay) ? me.preloadFilesDelay : 0;

            if (delay === 0) {
                // Immediate preload: Directly execute loadFiles and resolve the promise.
                me.#executeLoadFiles()
            } else {
                // Delayed preload: Set up a timer to execute loadFiles later.
                me.timeout(delay).then(() => {
                    // This callback checks if #loadFilesPromise is still pending (resolver is available).
                    if (me.#loadFilesPromiseResolver) {
                        me.#executeLoadFiles()
                    }
                })
            }
        }
    }

    /**
     * Executes the actual `loadFiles()` method and resolves `#loadFilesPromise`.
     * This method is called internally to manage the single execution of `loadFiles()`.
     * It ensures `loadFiles()` is only truly called once.
     * @private
     */
    async #executeLoadFiles() {
        let me = this;

        // Only execute if the promise is still pending (resolver is available).
        if (me.#loadFilesPromiseResolver) {
            const resolver = me.#loadFilesPromiseResolver;
            me.#loadFilesPromiseResolver = null; // Mark as no longer pending/resolved

            await me.loadFiles();
            resolver() // Resolve the main #loadFilesPromise
        }
    }

    /**
     * Async initialization hook for instances.
     * `initAsync` MUST await for `loadFiles()` to be completed. Only then the addon is ready.
     * @returns {Promise<void>}
     */
    async initAsync() {
        await super.initAsync();

        let me = this;

        // `initAsync` must always wait for `me.#loadFilesPromise` to complete its resolution,
        // regardless of how it was triggered (immediate, delayed, or by cacheMethodCall).
        // `me.#loadFilesPromise` is always initialized in `construct()`.
        await me.#loadFilesPromise
    }

    /**
     * Triggered after the `isReady` config got changed.
     * When `isReady` becomes true, any cached remote method calls are executed.
     * At this point, `initAsync` has already ensured that `me.#loadFilesPromise` is resolved.
     *
     * This method is kept synchronous, delegating the async cache processing to a private method.
     *
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetIsReady(value, oldValue) {
        super.afterSetIsReady(value, oldValue);

        if (value) {
            // Initiate the asynchronous processing of cached method calls.
            // This method itself does not need to be awaited here.
            this.#processCachedMethodCalls();
        }
    }

    /**
     * Internally caches remote method calls if `isReady` is false.
     * It also ensures that `loadFiles()` is initiated immediately, bypassing `preloadFilesDelay`.
     * @param {Object} item - Contains method name (`fn`) and data (`data`).
     * @returns {Promise<unknown>} A promise that resolves with the method's return value.
     */
    cacheMethodCall(item) {
        let me = this;

        // If loadFiles is defined, and it hasn't started yet (i.e., #loadFilesPromiseResolver is still available),
        // execute it now, bypassing any pending preloadFilesDelay timer.
        if (me.#loadFilesPromiseResolver) {
            me.#executeLoadFiles() // This will resolve #loadFilesPromise immediately
        }

        return new Promise((resolve, reject) => {
            me.cache.push({...item, reject, resolve})
        })
    }

    /**
     * Placeholder method for loading external files.
     * Subclasses (e.g., `Neo.main.addon.AmCharts`) must implement this.
     * It **must** return a Promise that resolves when all necessary files are loaded.
     * If `loadFiles()` is called multiple times, it should return the same pending promise
     * or a resolved promise if files are already loaded.
     * @returns {Promise<void>}
     */
    async loadFiles() {}

    /**
     * Handles intercepted remote method calls.
     * If the addon is not ready, the call is cached using `cacheMethodCall()`.
     * Otherwise, the original method is executed.
     * @param {Object} msg The remote message object.
     * @returns {Promise<any>} A promise that resolves with the method's return value.
     */
    onInterceptRemotes(msg) {
        return this.cacheMethodCall({fn: msg.remoteMethod, data: msg.data})
    }

    /**
     * Sequentially processes any method calls that were cached while the addon was not ready.
     * This method is asynchronous to allow awaiting the execution of individual cached methods.
     * @returns {Promise<void>} A promise that resolves when all cached methods have been processed.
     * @private
     */
    async #processCachedMethodCalls() {
        let me = this;

        // Iterate over the cache items and await each one in sequence
        for (const item of me.cache) {
            let returnValue;

            try {
                returnValue = me[item.fn](item.data);

                if (Neo.isPromise(returnValue)) {
                    returnValue = await returnValue;
                }

                item.resolve(returnValue)
            } catch (e) {
                // If an error occurs (either synchronous or a promise rejection),
                // reject the promise associated with the current cached item.
                item.reject(e)

                // *** FAIL-FAST STRATEGY ***
                // If any cached method call fails, we assume subsequent cached calls
                // (especially for the same addon instance) are likely to also fail.
                break
            }
        }

        me.cache = []
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Base));


/***/ },

/***/ "./src/main/addon/GridDragScroll.mjs"
/*!*******************************************!*\
  !*** ./src/main/addon/GridDragScroll.mjs ***!
  \*******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/main/addon/Base.mjs");


/**
 * @summary Main Thread Addon for High-Performance Grid Drag Scrolling.
 *
 * This addon moves the drag-to-scroll logic from the App Worker to the Main Thread.
 * By handling `mousemove` and `touchmove` events directly in the UI thread, it eliminates the latency
 * and overhead of passing high-frequency messages between workers, resulting in
 * smoother, native-like scrolling performance for both mouse and touch users.
 *
 * It listens for `mousedown` or `touchstart` on the grid body, then attaches global `mousemove` / `touchmove` and
 * `mouseup` / `touchend` listeners to handle the drag operation, supporting "over-drag" (scrolling
 * continues even if the mouse / finger leaves the grid bounds).
 *
 * **Kinetic Scrolling:**
 * The addon implements physics-based inertial scrolling. When a user releases a drag with sufficient velocity,
 * the grid continues to scroll with a decay animation, simulating momentum and friction.
 *
 * @class Neo.main.addon.GridDragScroll
 * @extends Neo.main.addon.Base
 */
class GridDragScroll extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.main.addon.GridDragScroll'
         * @protected
         */
        className: 'Neo.main.addon.GridDragScroll',
        /**
         * Remote method access for other workers
         * @member {Object} remote
         * @protected
         */
        remote: {
            app: [
                'register',
                'unregister'
            ]
        }
    }

    /**
     * @member {Object|null} activeDrag=null
     * @protected
     */
    activeDrag = null
    /**
     * @member {Map<String, Object>} registrations=new Map()
     * @protected
     */
    registrations = new Map()

    /**
     * @param {Object} data
     */
    autoScroll(data) {
        let me                                 = this,
            {friction, registration, velocity} = data;

        if (Math.abs(velocity.x) < 0.1 && Math.abs(velocity.y) < 0.1) {
            return
        }

        if (registration.containerElement) {
            registration.containerElement.scrollLeft -= velocity.x
        }

        if (registration.bodyElement) {
            registration.bodyElement.scrollTop -= velocity.y
        }

        velocity.x *= friction;
        velocity.y *= friction;

        me.activeDrag = {
            id       : data.id,
            animation: requestAnimationFrame(me.autoScroll.bind(me, data))
        }
    }

    /**
     * @param {MouseEvent|TouchEvent} event
     * @returns {Object} {x, y}
     */
    getEventCoordinates(event) {
        if (event.type.startsWith('touch')) {
            let touch = event.touches[0] || event.changedTouches[0];
            return {x: touch.clientX, y: touch.clientY}
        }

        return {x: event.clientX, y: event.clientY}
    }

    /**
     * @param {MouseEvent|TouchEvent} event
     */
    onDragEnd(event) {
        let me = this;

        if (me.activeDrag) {
            if (event.type === 'mouseup') {
                document.body.style.removeProperty('cursor');
                document.removeEventListener('mousemove', me.activeDrag.listeners.move, {capture: true});
                document.removeEventListener('mouseup', me.activeDrag.listeners.end, {capture: true})
            } else {
                document.removeEventListener('touchmove', me.activeDrag.listeners.move, {
                    capture: true,
                    passive: false
                });
                document.removeEventListener('touchend', me.activeDrag.listeners.end, {capture: true})
            }

            let {history, id, registration} = me.activeDrag,
                now                         = Date.now(),
                cutoff                      = now - 100, // 100ms
                relevantMoves               = history.filter(item => item.time > cutoff);

            // We need at least 2 points to calculate velocity
            if (relevantMoves.length > 1) {
                let newest = relevantMoves[relevantMoves.length - 1],
                    oldest = relevantMoves[0],
                    dt     = newest.time - oldest.time,
                    vX     = (newest.x - oldest.x) / dt * 16, // px per frame (approx 16ms)
                    vY     = (newest.y - oldest.y) / dt * 16;

                // Simple exponential decay friction
                // 0.95 feels like a good balance between "slippery" and "controlled"
                me.autoScroll({
                    friction: 0.95,
                    id,
                    registration,
                    velocity: {x: vX, y: vY}
                })
            } else {
                me.activeDrag = null
            }
        }
    }

    /**
     * @param {MouseEvent|TouchEvent} event
     */
    onDragMove(event) {
        let me   = this,
            drag = me.activeDrag;

        if (!drag) {
            return
        }

        if (event.type === 'touchmove') {
            event.preventDefault() // Disable native scrolling
        }

        let {registration} = drag,
            {x, y}         = me.getEventCoordinates(event),
            deltaX         = drag.lastX - x,
            deltaY         = drag.lastY - y;

        if (deltaX !== 0 && registration.containerElement) {
            registration.containerElement.scrollLeft += deltaX
        }

        if (deltaY !== 0 && registration.bodyElement) {
            registration.bodyElement.scrollTop += deltaY
        }

        drag.lastX = x;
        drag.lastY = y;

        drag.history.push({time: Date.now(), x, y});

        // Keep history size manageable
        if (drag.history.length > 10) {
            drag.history.shift()
        }
    }

    /**
     * @param {MouseEvent|TouchEvent} event
     */
    onDragStart(event) {
        // Ignore right clicks
        if (event.type === 'mousedown' && event.button !== 0) {
            return
        }

        let me   = this,
            path = event.composedPath(),
            id, registration;

        // Stop any active animation
        if (me.activeDrag?.animation) {
            cancelAnimationFrame(me.activeDrag.animation);
            me.activeDrag = null
        }

        // Find the registration associated with the target element
        for (const [key, reg] of me.registrations) {
            if (path.includes(reg.bodyElement)) {
                id           = key;
                registration = reg;
                break
            }
        }
        if (!registration) {
            return
        }

        // Replicate the check from ScrollManager: ignore if clicking on a draggable element
        // We check for 'neo-draggable' class on the path
        if (path.some(el => el.classList?.contains('neo-draggable'))) {
            return
        }

        if (event.type === 'mousedown') {
            event.preventDefault() // Prevent text selection
        }

        let {x, y} = me.getEventCoordinates(event);

        me.activeDrag = {
            id,
            registration,
            history  : [{time: Date.now(), x, y}],
            lastX    : x,
            lastY    : y,
            listeners: {
                move: me.onDragMove.bind(me),
                end : me.onDragEnd.bind(me)
            }
        };

        if (event.type === 'mousedown') {
            document.body.style.setProperty('cursor', 'grabbing', 'important');
            document.addEventListener('mousemove', me.activeDrag.listeners.move, {capture: true});
            document.addEventListener('mouseup', me.activeDrag.listeners.end,    {capture: true})
        } else {
            document.addEventListener('touchmove', me.activeDrag.listeners.move, {capture: true, passive: false});
            document.addEventListener('touchend', me.activeDrag.listeners.end,   {capture: true})
        }
    }

    /**
     * Registers a grid for drag scrolling.
     * @param {Object} data
     * @param {String} data.bodyId      The ID of the grid body (vertical scroll target)
     * @param {String} data.containerId The ID of the grid container (horizontal scroll target)
     * @param {String} data.id          Unique identifier for the registration (e.g. ScrollManager id)
     */
    register({bodyId, containerId, id}) {
        let me = this;

        if (me.registrations.has(id)) {
            me.unregister({id})
        }

        let bodyElement      = document.getElementById(bodyId),
            containerElement = document.getElementById(containerId);

        if (bodyElement) {
            let registration = {
                bodyElement,
                containerElement,
                id,
                dragStartListener: me.onDragStart.bind(me)
            };

            if (Neo.config.hasTouchEvents) {
                bodyElement.addEventListener('touchstart', registration.dragStartListener, {
                    capture: true,
                    passive: false
                })
            } else {
                bodyElement.addEventListener('mousedown', registration.dragStartListener, {capture: true})
            }

            me.registrations.set(id, registration)
        }
    }

    /**
     * Unregisters a grid.
     * @param {Object} data
     * @param {String} data.id
     */
    unregister({id}) {
        let me           = this,
            registration = me.registrations.get(id);

        if (registration) {
            if (registration.bodyElement) {
                if (Neo.config.hasTouchEvents) {
                    registration.bodyElement.removeEventListener('touchstart', registration.dragStartListener, {
                        capture: true,
                        passive: false
                    })
                } else {
                    registration.bodyElement.removeEventListener('mousedown', registration.dragStartListener, {capture: true})
                }
            }

            // If this registration was active, cancel the drag
            if (me.activeDrag?.id === id) {
                me.onDragEnd({type: Neo.config.hasTouchEvents ? 'touchend' : 'mouseup'})
            }

            me.registrations.delete(id)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(GridDragScroll));

/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL21haW4vdmVuZG9ycy1zcmNfbWFpbl9hZGRvbl9HcmlkRHJhZ1Njcm9sbF9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQTJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzREFBUTtBQUMzQjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaURBQWlEOztB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cy8uL3NyYy9tYWluL2FkZG9uL0Jhc2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvbWFpbi9hZGRvbi9HcmlkRHJhZ1Njcm9sbC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENvcmVCYXNlIGZyb20gJy4uLy4uL2NvcmUvQmFzZS5tanMnO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIG1haW4gdGhyZWFkIGFkZG9uc1xuICogQGNsYXNzIE5lby5tYWluLmFkZG9uLkJhc2VcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqXG4gKiBUaGlzIHZlcnNpb24gYWxpZ25zIHRoZSBmaWxlIGxvYWRpbmcgYW5kIHJlYWRpbmVzcyBzdGF0ZSBhY2NvcmRpbmcgdG8gdGhlIHJ1bGU6XG4gKiBgaW5pdEFzeW5jKClgIE1VU1QgYXdhaXQgZm9yIGBsb2FkRmlsZXMoKWAgdG8gYmUgY29tcGxldGVkIGJlZm9yZSB0aGUgYWRkb24gaXMgY29uc2lkZXJlZCBgaXNSZWFkeWAuXG4gKiBgcHJlbG9hZEZpbGVzRGVsYXlgIGNvbnRyb2xzIHdoZW4gYGxvYWRGaWxlcygpYCBpcyBpbml0aWF0ZWQgaW4gdGhlIGJhY2tncm91bmQsIGJ1dCBjYW4gYmVcbiAqIG92ZXJyaWRkZW4gYnkgYGNhY2hlTWV0aG9kQ2FsbCgpYC5cbiAqL1xuY2xhc3MgQmFzZSBleHRlbmRzIENvcmVCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5tYWluLmFkZG9uLkJhc2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5tYWluLmFkZG9uLkJhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gaWRlbnRpZmllciBmb3IgY29yZS5CYXNlIHRvIGdldCBoYW5kbGVkIGxpa2Ugc2luZ2xldG9ucyBmb3IgcmVtb3RlIG1ldGhvZCBhY2Nlc3NcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNNYWluVGhyZWFkQWRkb249dHJ1ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBpc01haW5UaHJlYWRBZGRvbjogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFtb3VudCBpbiBtcyB0byBkZWxheSB0aGUgYmFja2dyb3VuZCBsb2FkaW5nIG9mIGxpYnJhcnkgZmlsZXMuXG4gICAgICAgICAqIFNldCB0byBgZmFsc2VgIHRvIGRpc2FibGUgYXV0b21hdGVkIHByZWxvYWRpbmcgYW5kIHJlbHkgc29sZWx5IG9uIGxhenkgbG9hZGluZ1xuICAgICAgICAgKiB2aWEgYGNhY2hlTWV0aG9kQ2FsbCgpYC4gU2V0IHRvIGAwYCBmb3IgaW1tZWRpYXRlIGJhY2tncm91bmQgcHJlbG9hZC5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbnxOdW1iZXJ9IHByZWxvYWRGaWxlc0RlbGF5PTUwMDBcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcHJlbG9hZEZpbGVzRGVsYXk6IDUwMDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdGUgbWV0aG9kIGFjY2VzcyBmb3Igb3RoZXIgd29ya2Vyc1xuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHJlbW90ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdGU6IHtcbiAgICAgICAgICAgIGFwcDogW1xuICAgICAgICAgICAgICAgICdsb2FkRmlsZXMnXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB1c2VMYXp5TG9hZGluZz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdXNlTGF6eUxvYWRpbmc6IGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgY2FjaGUgZm9yIHJlbW90ZSBtZXRob2QgY2FsbHMgcmVjZWl2ZWQgd2hlbiBgaXNSZWFkeWAgaXMgZmFsc2UuXG4gICAgICogQG1lbWJlciB7T2JqZWN0W119IGNhY2hlPVtdXG4gICAgICovXG4gICAgY2FjaGUgPSBbXVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBgbG9hZEZpbGVzKClgIGhhcyBiZWVuIGluaXRpYXRlZCBhbmQgaXMgY3VycmVudGx5IGluIHByb2dyZXNzLlxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzTG9hZGluZ1xuICAgICAqL1xuICAgIGdldCBpc0xvYWRpbmcoKSB7XG4gICAgICAgIC8vIGlzTG9hZGluZyBpcyB0cnVlIGlmIHRoZSBwcm9taXNlIGV4aXN0cyBhbmQgaXRzIHJlc29sdmVyIGlzIHN0aWxsIGF2YWlsYWJsZSAobWVhbmluZyBpdCdzIHBlbmRpbmcpLlxuICAgICAgICByZXR1cm4gISF0aGlzLiNsb2FkRmlsZXNQcm9taXNlICYmICEhdGhpcy4jbG9hZEZpbGVzUHJvbWlzZVJlc29sdmVyXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgcHJpdmF0ZSBwcm9taXNlIHRoYXQgdHJhY2tzIHRoZSBjb21wbGV0aW9uIG9mIGBsb2FkRmlsZXMoKWAuXG4gICAgICogVGhpcyBlbnN1cmVzIGBsb2FkRmlsZXMoKWAgaXMgY2FsbGVkIG9ubHkgb25jZSBhbmQgY2FuIGJlIGF3YWl0ZWQgYnkgbXVsdGlwbGUgY29uc3VtZXJzLlxuICAgICAqIEBtZW1iZXIge1Byb21pc2U8dm9pZD58bnVsbH0gI2xvYWRGaWxlc1Byb21pc2U9bnVsbFxuICAgICAqL1xuICAgICNsb2FkRmlsZXNQcm9taXNlID0gbnVsbFxuICAgIC8qKlxuICAgICAqIFRoZSBgcmVzb2x2ZWAgZnVuY3Rpb24gZm9yIGAjbG9hZEZpbGVzUHJvbWlzZWAsIGFsbG93aW5nIGV4dGVybmFsIGNvbnRyb2wgb3ZlciBpdHMgcmVzb2x1dGlvbi5cbiAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbnxudWxsfSAjbG9hZEZpbGVzUHJvbWlzZVJlc29sdmVyPW51bGxcbiAgICAgKi9cbiAgICAjbG9hZEZpbGVzUHJvbWlzZVJlc29sdmVyID0gbnVsbFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvLyBJbml0aWFsaXplICNsb2FkRmlsZXNQcm9taXNlIGFzIGEgY29udHJvbGxhYmxlIHByb21pc2UuXG4gICAgICAgIC8vIFRoaXMgcHJvbWlzZSB3aWxsIGJlIGF3YWl0ZWQgYnkgaW5pdEFzeW5jIGFuZCByZXNvbHZlZCBieSBleGVjdXRlTG9hZEZpbGVzLlxuICAgICAgICBtZS4jbG9hZEZpbGVzUHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgbWUuI2xvYWRGaWxlc1Byb21pc2VSZXNvbHZlciA9IHJlc29sdmVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG1lLnVzZUxhenlMb2FkaW5nKSB7XG4gICAgICAgICAgICAvLyBEbyBub3RoaW5nLiBUaGUgcHJvbWlzZSByZW1haW5zIHBlbmRpbmcsIGJsb2NraW5nIGluaXRBc3luYyAoa2VlcGluZyBpc1JlYWR5OiBmYWxzZSkuXG4gICAgICAgICAgICAvLyBNYWluIHRocmVhZCBpcyBub3QgYmxvY2tlZCBiZWNhdXNlIGl0IG9ubHkgd2FpdHMgZm9yIHJlbW90ZXNSZWFkeSgpLlxuICAgICAgICAgICAgLy8gVGhlIGZpcnN0IHJlbW90ZSBjYWxsIHdpbGwgdHJpZ2dlciBpbnRlcmNlcHRpb24gLT4gY2FjaGVNZXRob2RDYWxsIC0+IGV4ZWN1dGVMb2FkRmlsZXMuXG4gICAgICAgIH0gZWxzZSBpZiAobWUucHJlbG9hZEZpbGVzRGVsYXkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAvLyBObyBhdXRvbWF0ZWQgcHJlbG9hZDogcmVzb2x2ZSAjbG9hZEZpbGVzUHJvbWlzZSBpbW1lZGlhdGVseSBhcyBpdCB3b24ndCBiZSB0cmlnZ2VyZWQgYnkgZGVsYXkuXG4gICAgICAgICAgICAvLyBJdCB3aWxsIG9ubHkgYmUgdHJpZ2dlcmVkIGJ5IGNhY2hlTWV0aG9kQ2FsbCBvciBpbml0QXN5bmMgaWYgbmVlZGVkLlxuICAgICAgICAgICAgbWUuI2xvYWRGaWxlc1Byb21pc2VSZXNvbHZlcigpO1xuICAgICAgICAgICAgbWUuI2xvYWRGaWxlc1Byb21pc2VSZXNvbHZlciA9IG51bGwgLy8gTWFyayBhcyByZXNvbHZlZC9ubyBsb25nZXIgcGVuZGluZ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZGVsYXkgPSBOZW8uaXNOdW1iZXIobWUucHJlbG9hZEZpbGVzRGVsYXkpID8gbWUucHJlbG9hZEZpbGVzRGVsYXkgOiAwO1xuXG4gICAgICAgICAgICBpZiAoZGVsYXkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBJbW1lZGlhdGUgcHJlbG9hZDogRGlyZWN0bHkgZXhlY3V0ZSBsb2FkRmlsZXMgYW5kIHJlc29sdmUgdGhlIHByb21pc2UuXG4gICAgICAgICAgICAgICAgbWUuI2V4ZWN1dGVMb2FkRmlsZXMoKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBEZWxheWVkIHByZWxvYWQ6IFNldCB1cCBhIHRpbWVyIHRvIGV4ZWN1dGUgbG9hZEZpbGVzIGxhdGVyLlxuICAgICAgICAgICAgICAgIG1lLnRpbWVvdXQoZGVsYXkpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGNhbGxiYWNrIGNoZWNrcyBpZiAjbG9hZEZpbGVzUHJvbWlzZSBpcyBzdGlsbCBwZW5kaW5nIChyZXNvbHZlciBpcyBhdmFpbGFibGUpLlxuICAgICAgICAgICAgICAgICAgICBpZiAobWUuI2xvYWRGaWxlc1Byb21pc2VSZXNvbHZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUuI2V4ZWN1dGVMb2FkRmlsZXMoKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBhY3R1YWwgYGxvYWRGaWxlcygpYCBtZXRob2QgYW5kIHJlc29sdmVzIGAjbG9hZEZpbGVzUHJvbWlzZWAuXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGludGVybmFsbHkgdG8gbWFuYWdlIHRoZSBzaW5nbGUgZXhlY3V0aW9uIG9mIGBsb2FkRmlsZXMoKWAuXG4gICAgICogSXQgZW5zdXJlcyBgbG9hZEZpbGVzKClgIGlzIG9ubHkgdHJ1bHkgY2FsbGVkIG9uY2UuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyAjZXhlY3V0ZUxvYWRGaWxlcygpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvLyBPbmx5IGV4ZWN1dGUgaWYgdGhlIHByb21pc2UgaXMgc3RpbGwgcGVuZGluZyAocmVzb2x2ZXIgaXMgYXZhaWxhYmxlKS5cbiAgICAgICAgaWYgKG1lLiNsb2FkRmlsZXNQcm9taXNlUmVzb2x2ZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gbWUuI2xvYWRGaWxlc1Byb21pc2VSZXNvbHZlcjtcbiAgICAgICAgICAgIG1lLiNsb2FkRmlsZXNQcm9taXNlUmVzb2x2ZXIgPSBudWxsOyAvLyBNYXJrIGFzIG5vIGxvbmdlciBwZW5kaW5nL3Jlc29sdmVkXG5cbiAgICAgICAgICAgIGF3YWl0IG1lLmxvYWRGaWxlcygpO1xuICAgICAgICAgICAgcmVzb2x2ZXIoKSAvLyBSZXNvbHZlIHRoZSBtYWluICNsb2FkRmlsZXNQcm9taXNlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3luYyBpbml0aWFsaXphdGlvbiBob29rIGZvciBpbnN0YW5jZXMuXG4gICAgICogYGluaXRBc3luY2AgTVVTVCBhd2FpdCBmb3IgYGxvYWRGaWxlcygpYCB0byBiZSBjb21wbGV0ZWQuIE9ubHkgdGhlbiB0aGUgYWRkb24gaXMgcmVhZHkuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYXN5bmMgaW5pdEFzeW5jKCkge1xuICAgICAgICBhd2FpdCBzdXBlci5pbml0QXN5bmMoKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIC8vIGBpbml0QXN5bmNgIG11c3QgYWx3YXlzIHdhaXQgZm9yIGBtZS4jbG9hZEZpbGVzUHJvbWlzZWAgdG8gY29tcGxldGUgaXRzIHJlc29sdXRpb24sXG4gICAgICAgIC8vIHJlZ2FyZGxlc3Mgb2YgaG93IGl0IHdhcyB0cmlnZ2VyZWQgKGltbWVkaWF0ZSwgZGVsYXllZCwgb3IgYnkgY2FjaGVNZXRob2RDYWxsKS5cbiAgICAgICAgLy8gYG1lLiNsb2FkRmlsZXNQcm9taXNlYCBpcyBhbHdheXMgaW5pdGlhbGl6ZWQgaW4gYGNvbnN0cnVjdCgpYC5cbiAgICAgICAgYXdhaXQgbWUuI2xvYWRGaWxlc1Byb21pc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGBpc1JlYWR5YCBjb25maWcgZ290IGNoYW5nZWQuXG4gICAgICogV2hlbiBgaXNSZWFkeWAgYmVjb21lcyB0cnVlLCBhbnkgY2FjaGVkIHJlbW90ZSBtZXRob2QgY2FsbHMgYXJlIGV4ZWN1dGVkLlxuICAgICAqIEF0IHRoaXMgcG9pbnQsIGBpbml0QXN5bmNgIGhhcyBhbHJlYWR5IGVuc3VyZWQgdGhhdCBgbWUuI2xvYWRGaWxlc1Byb21pc2VgIGlzIHJlc29sdmVkLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMga2VwdCBzeW5jaHJvbm91cywgZGVsZWdhdGluZyB0aGUgYXN5bmMgY2FjaGUgcHJvY2Vzc2luZyB0byBhIHByaXZhdGUgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRJc1JlYWR5KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldElzUmVhZHkodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIEluaXRpYXRlIHRoZSBhc3luY2hyb25vdXMgcHJvY2Vzc2luZyBvZiBjYWNoZWQgbWV0aG9kIGNhbGxzLlxuICAgICAgICAgICAgLy8gVGhpcyBtZXRob2QgaXRzZWxmIGRvZXMgbm90IG5lZWQgdG8gYmUgYXdhaXRlZCBoZXJlLlxuICAgICAgICAgICAgdGhpcy4jcHJvY2Vzc0NhY2hlZE1ldGhvZENhbGxzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbGx5IGNhY2hlcyByZW1vdGUgbWV0aG9kIGNhbGxzIGlmIGBpc1JlYWR5YCBpcyBmYWxzZS5cbiAgICAgKiBJdCBhbHNvIGVuc3VyZXMgdGhhdCBgbG9hZEZpbGVzKClgIGlzIGluaXRpYXRlZCBpbW1lZGlhdGVseSwgYnlwYXNzaW5nIGBwcmVsb2FkRmlsZXNEZWxheWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gLSBDb250YWlucyBtZXRob2QgbmFtZSAoYGZuYCkgYW5kIGRhdGEgKGBkYXRhYCkuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dW5rbm93bj59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIG1ldGhvZCdzIHJldHVybiB2YWx1ZS5cbiAgICAgKi9cbiAgICBjYWNoZU1ldGhvZENhbGwoaXRlbSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIC8vIElmIGxvYWRGaWxlcyBpcyBkZWZpbmVkLCBhbmQgaXQgaGFzbid0IHN0YXJ0ZWQgeWV0IChpLmUuLCAjbG9hZEZpbGVzUHJvbWlzZVJlc29sdmVyIGlzIHN0aWxsIGF2YWlsYWJsZSksXG4gICAgICAgIC8vIGV4ZWN1dGUgaXQgbm93LCBieXBhc3NpbmcgYW55IHBlbmRpbmcgcHJlbG9hZEZpbGVzRGVsYXkgdGltZXIuXG4gICAgICAgIGlmIChtZS4jbG9hZEZpbGVzUHJvbWlzZVJlc29sdmVyKSB7XG4gICAgICAgICAgICBtZS4jZXhlY3V0ZUxvYWRGaWxlcygpIC8vIFRoaXMgd2lsbCByZXNvbHZlICNsb2FkRmlsZXNQcm9taXNlIGltbWVkaWF0ZWx5XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbWUuY2FjaGUucHVzaCh7Li4uaXRlbSwgcmVqZWN0LCByZXNvbHZlfSlcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQbGFjZWhvbGRlciBtZXRob2QgZm9yIGxvYWRpbmcgZXh0ZXJuYWwgZmlsZXMuXG4gICAgICogU3ViY2xhc3NlcyAoZS5nLiwgYE5lby5tYWluLmFkZG9uLkFtQ2hhcnRzYCkgbXVzdCBpbXBsZW1lbnQgdGhpcy5cbiAgICAgKiBJdCAqKm11c3QqKiByZXR1cm4gYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBhbGwgbmVjZXNzYXJ5IGZpbGVzIGFyZSBsb2FkZWQuXG4gICAgICogSWYgYGxvYWRGaWxlcygpYCBpcyBjYWxsZWQgbXVsdGlwbGUgdGltZXMsIGl0IHNob3VsZCByZXR1cm4gdGhlIHNhbWUgcGVuZGluZyBwcm9taXNlXG4gICAgICogb3IgYSByZXNvbHZlZCBwcm9taXNlIGlmIGZpbGVzIGFyZSBhbHJlYWR5IGxvYWRlZC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBsb2FkRmlsZXMoKSB7fVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBpbnRlcmNlcHRlZCByZW1vdGUgbWV0aG9kIGNhbGxzLlxuICAgICAqIElmIHRoZSBhZGRvbiBpcyBub3QgcmVhZHksIHRoZSBjYWxsIGlzIGNhY2hlZCB1c2luZyBgY2FjaGVNZXRob2RDYWxsKClgLlxuICAgICAqIE90aGVyd2lzZSwgdGhlIG9yaWdpbmFsIG1ldGhvZCBpcyBleGVjdXRlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbXNnIFRoZSByZW1vdGUgbWVzc2FnZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgbWV0aG9kJ3MgcmV0dXJuIHZhbHVlLlxuICAgICAqL1xuICAgIG9uSW50ZXJjZXB0UmVtb3Rlcyhtc2cpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVNZXRob2RDYWxsKHtmbjogbXNnLnJlbW90ZU1ldGhvZCwgZGF0YTogbXNnLmRhdGF9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlcXVlbnRpYWxseSBwcm9jZXNzZXMgYW55IG1ldGhvZCBjYWxscyB0aGF0IHdlcmUgY2FjaGVkIHdoaWxlIHRoZSBhZGRvbiB3YXMgbm90IHJlYWR5LlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGFzeW5jaHJvbm91cyB0byBhbGxvdyBhd2FpdGluZyB0aGUgZXhlY3V0aW9uIG9mIGluZGl2aWR1YWwgY2FjaGVkIG1ldGhvZHMuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gYWxsIGNhY2hlZCBtZXRob2RzIGhhdmUgYmVlbiBwcm9jZXNzZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyAjcHJvY2Vzc0NhY2hlZE1ldGhvZENhbGxzKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUgY2FjaGUgaXRlbXMgYW5kIGF3YWl0IGVhY2ggb25lIGluIHNlcXVlbmNlXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBtZS5jYWNoZSkge1xuICAgICAgICAgICAgbGV0IHJldHVyblZhbHVlO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gbWVbaXRlbS5mbl0oaXRlbS5kYXRhKTtcblxuICAgICAgICAgICAgICAgIGlmIChOZW8uaXNQcm9taXNlKHJldHVyblZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IGF3YWl0IHJldHVyblZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGl0ZW0ucmVzb2x2ZShyZXR1cm5WYWx1ZSlcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhbiBlcnJvciBvY2N1cnMgKGVpdGhlciBzeW5jaHJvbm91cyBvciBhIHByb21pc2UgcmVqZWN0aW9uKSxcbiAgICAgICAgICAgICAgICAvLyByZWplY3QgdGhlIHByb21pc2UgYXNzb2NpYXRlZCB3aXRoIHRoZSBjdXJyZW50IGNhY2hlZCBpdGVtLlxuICAgICAgICAgICAgICAgIGl0ZW0ucmVqZWN0KGUpXG5cbiAgICAgICAgICAgICAgICAvLyAqKiogRkFJTC1GQVNUIFNUUkFURUdZICoqKlxuICAgICAgICAgICAgICAgIC8vIElmIGFueSBjYWNoZWQgbWV0aG9kIGNhbGwgZmFpbHMsIHdlIGFzc3VtZSBzdWJzZXF1ZW50IGNhY2hlZCBjYWxsc1xuICAgICAgICAgICAgICAgIC8vIChlc3BlY2lhbGx5IGZvciB0aGUgc2FtZSBhZGRvbiBpbnN0YW5jZSkgYXJlIGxpa2VseSB0byBhbHNvIGZhaWwuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmNhY2hlID0gW11cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEJhc2UpO1xuIiwiaW1wb3J0IEJhc2UgZnJvbSAnLi9CYXNlLm1qcyc7XG5cbi8qKlxuICogQHN1bW1hcnkgTWFpbiBUaHJlYWQgQWRkb24gZm9yIEhpZ2gtUGVyZm9ybWFuY2UgR3JpZCBEcmFnIFNjcm9sbGluZy5cbiAqXG4gKiBUaGlzIGFkZG9uIG1vdmVzIHRoZSBkcmFnLXRvLXNjcm9sbCBsb2dpYyBmcm9tIHRoZSBBcHAgV29ya2VyIHRvIHRoZSBNYWluIFRocmVhZC5cbiAqIEJ5IGhhbmRsaW5nIGBtb3VzZW1vdmVgIGFuZCBgdG91Y2htb3ZlYCBldmVudHMgZGlyZWN0bHkgaW4gdGhlIFVJIHRocmVhZCwgaXQgZWxpbWluYXRlcyB0aGUgbGF0ZW5jeVxuICogYW5kIG92ZXJoZWFkIG9mIHBhc3NpbmcgaGlnaC1mcmVxdWVuY3kgbWVzc2FnZXMgYmV0d2VlbiB3b3JrZXJzLCByZXN1bHRpbmcgaW5cbiAqIHNtb290aGVyLCBuYXRpdmUtbGlrZSBzY3JvbGxpbmcgcGVyZm9ybWFuY2UgZm9yIGJvdGggbW91c2UgYW5kIHRvdWNoIHVzZXJzLlxuICpcbiAqIEl0IGxpc3RlbnMgZm9yIGBtb3VzZWRvd25gIG9yIGB0b3VjaHN0YXJ0YCBvbiB0aGUgZ3JpZCBib2R5LCB0aGVuIGF0dGFjaGVzIGdsb2JhbCBgbW91c2Vtb3ZlYCAvIGB0b3VjaG1vdmVgIGFuZFxuICogYG1vdXNldXBgIC8gYHRvdWNoZW5kYCBsaXN0ZW5lcnMgdG8gaGFuZGxlIHRoZSBkcmFnIG9wZXJhdGlvbiwgc3VwcG9ydGluZyBcIm92ZXItZHJhZ1wiIChzY3JvbGxpbmdcbiAqIGNvbnRpbnVlcyBldmVuIGlmIHRoZSBtb3VzZSAvIGZpbmdlciBsZWF2ZXMgdGhlIGdyaWQgYm91bmRzKS5cbiAqXG4gKiAqKktpbmV0aWMgU2Nyb2xsaW5nOioqXG4gKiBUaGUgYWRkb24gaW1wbGVtZW50cyBwaHlzaWNzLWJhc2VkIGluZXJ0aWFsIHNjcm9sbGluZy4gV2hlbiBhIHVzZXIgcmVsZWFzZXMgYSBkcmFnIHdpdGggc3VmZmljaWVudCB2ZWxvY2l0eSxcbiAqIHRoZSBncmlkIGNvbnRpbnVlcyB0byBzY3JvbGwgd2l0aCBhIGRlY2F5IGFuaW1hdGlvbiwgc2ltdWxhdGluZyBtb21lbnR1bSBhbmQgZnJpY3Rpb24uXG4gKlxuICogQGNsYXNzIE5lby5tYWluLmFkZG9uLkdyaWREcmFnU2Nyb2xsXG4gKiBAZXh0ZW5kcyBOZW8ubWFpbi5hZGRvbi5CYXNlXG4gKi9cbmNsYXNzIEdyaWREcmFnU2Nyb2xsIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ubWFpbi5hZGRvbi5HcmlkRHJhZ1Njcm9sbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLm1haW4uYWRkb24uR3JpZERyYWdTY3JvbGwnLFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3RlIG1ldGhvZCBhY2Nlc3MgZm9yIG90aGVyIHdvcmtlcnNcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSByZW1vdGVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3RlOiB7XG4gICAgICAgICAgICBhcHA6IFtcbiAgICAgICAgICAgICAgICAncmVnaXN0ZXInLFxuICAgICAgICAgICAgICAgICd1bnJlZ2lzdGVyJ1xuICAgICAgICAgICAgXVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGFjdGl2ZURyYWc9bnVsbFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhY3RpdmVEcmFnID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge01hcDxTdHJpbmcsIE9iamVjdD59IHJlZ2lzdHJhdGlvbnM9bmV3IE1hcCgpXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHJlZ2lzdHJhdGlvbnMgPSBuZXcgTWFwKClcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgYXV0b1Njcm9sbChkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtmcmljdGlvbiwgcmVnaXN0cmF0aW9uLCB2ZWxvY2l0eX0gPSBkYXRhO1xuXG4gICAgICAgIGlmIChNYXRoLmFicyh2ZWxvY2l0eS54KSA8IDAuMSAmJiBNYXRoLmFicyh2ZWxvY2l0eS55KSA8IDAuMSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVnaXN0cmF0aW9uLmNvbnRhaW5lckVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJlZ2lzdHJhdGlvbi5jb250YWluZXJFbGVtZW50LnNjcm9sbExlZnQgLT0gdmVsb2NpdHkueFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbi5ib2R5RWxlbWVudCkge1xuICAgICAgICAgICAgcmVnaXN0cmF0aW9uLmJvZHlFbGVtZW50LnNjcm9sbFRvcCAtPSB2ZWxvY2l0eS55XG4gICAgICAgIH1cblxuICAgICAgICB2ZWxvY2l0eS54ICo9IGZyaWN0aW9uO1xuICAgICAgICB2ZWxvY2l0eS55ICo9IGZyaWN0aW9uO1xuXG4gICAgICAgIG1lLmFjdGl2ZURyYWcgPSB7XG4gICAgICAgICAgICBpZCAgICAgICA6IGRhdGEuaWQsXG4gICAgICAgICAgICBhbmltYXRpb246IHJlcXVlc3RBbmltYXRpb25GcmFtZShtZS5hdXRvU2Nyb2xsLmJpbmQobWUsIGRhdGEpKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fFRvdWNoRXZlbnR9IGV2ZW50XG4gICAgICogQHJldHVybnMge09iamVjdH0ge3gsIHl9XG4gICAgICovXG4gICAgZ2V0RXZlbnRDb29yZGluYXRlcyhldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQudHlwZS5zdGFydHNXaXRoKCd0b3VjaCcpKSB7XG4gICAgICAgICAgICBsZXQgdG91Y2ggPSBldmVudC50b3VjaGVzWzBdIHx8IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICAgICAgcmV0dXJuIHt4OiB0b3VjaC5jbGllbnRYLCB5OiB0b3VjaC5jbGllbnRZfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHt4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudHxUb3VjaEV2ZW50fSBldmVudFxuICAgICAqL1xuICAgIG9uRHJhZ0VuZChldmVudCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5hY3RpdmVEcmFnKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ21vdXNldXAnKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnY3Vyc29yJyk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbWUuYWN0aXZlRHJhZy5saXN0ZW5lcnMubW92ZSwge2NhcHR1cmU6IHRydWV9KTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbWUuYWN0aXZlRHJhZy5saXN0ZW5lcnMuZW5kLCB7Y2FwdHVyZTogdHJ1ZX0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG1lLmFjdGl2ZURyYWcubGlzdGVuZXJzLm1vdmUsIHtcbiAgICAgICAgICAgICAgICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG1lLmFjdGl2ZURyYWcubGlzdGVuZXJzLmVuZCwge2NhcHR1cmU6IHRydWV9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQge2hpc3RvcnksIGlkLCByZWdpc3RyYXRpb259ID0gbWUuYWN0aXZlRHJhZyxcbiAgICAgICAgICAgICAgICBub3cgICAgICAgICAgICAgICAgICAgICAgICAgPSBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICAgIGN1dG9mZiAgICAgICAgICAgICAgICAgICAgICA9IG5vdyAtIDEwMCwgLy8gMTAwbXNcbiAgICAgICAgICAgICAgICByZWxldmFudE1vdmVzICAgICAgICAgICAgICAgPSBoaXN0b3J5LmZpbHRlcihpdGVtID0+IGl0ZW0udGltZSA+IGN1dG9mZik7XG5cbiAgICAgICAgICAgIC8vIFdlIG5lZWQgYXQgbGVhc3QgMiBwb2ludHMgdG8gY2FsY3VsYXRlIHZlbG9jaXR5XG4gICAgICAgICAgICBpZiAocmVsZXZhbnRNb3Zlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld2VzdCA9IHJlbGV2YW50TW92ZXNbcmVsZXZhbnRNb3Zlcy5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgICAgICAgICAgb2xkZXN0ID0gcmVsZXZhbnRNb3Zlc1swXSxcbiAgICAgICAgICAgICAgICAgICAgZHQgICAgID0gbmV3ZXN0LnRpbWUgLSBvbGRlc3QudGltZSxcbiAgICAgICAgICAgICAgICAgICAgdlggICAgID0gKG5ld2VzdC54IC0gb2xkZXN0LngpIC8gZHQgKiAxNiwgLy8gcHggcGVyIGZyYW1lIChhcHByb3ggMTZtcylcbiAgICAgICAgICAgICAgICAgICAgdlkgICAgID0gKG5ld2VzdC55IC0gb2xkZXN0LnkpIC8gZHQgKiAxNjtcblxuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBleHBvbmVudGlhbCBkZWNheSBmcmljdGlvblxuICAgICAgICAgICAgICAgIC8vIDAuOTUgZmVlbHMgbGlrZSBhIGdvb2QgYmFsYW5jZSBiZXR3ZWVuIFwic2xpcHBlcnlcIiBhbmQgXCJjb250cm9sbGVkXCJcbiAgICAgICAgICAgICAgICBtZS5hdXRvU2Nyb2xsKHtcbiAgICAgICAgICAgICAgICAgICAgZnJpY3Rpb246IDAuOTUsXG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICByZWdpc3RyYXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHZlbG9jaXR5OiB7eDogdlgsIHk6IHZZfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lLmFjdGl2ZURyYWcgPSBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR8VG91Y2hFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICBvbkRyYWdNb3ZlKGV2ZW50KSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIGRyYWcgPSBtZS5hY3RpdmVEcmFnO1xuXG4gICAgICAgIGlmICghZHJhZykge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ3RvdWNobW92ZScpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCkgLy8gRGlzYWJsZSBuYXRpdmUgc2Nyb2xsaW5nXG4gICAgICAgIH1cblxuICAgICAgICBsZXQge3JlZ2lzdHJhdGlvbn0gPSBkcmFnLFxuICAgICAgICAgICAge3gsIHl9ICAgICAgICAgPSBtZS5nZXRFdmVudENvb3JkaW5hdGVzKGV2ZW50KSxcbiAgICAgICAgICAgIGRlbHRhWCAgICAgICAgID0gZHJhZy5sYXN0WCAtIHgsXG4gICAgICAgICAgICBkZWx0YVkgICAgICAgICA9IGRyYWcubGFzdFkgLSB5O1xuXG4gICAgICAgIGlmIChkZWx0YVggIT09IDAgJiYgcmVnaXN0cmF0aW9uLmNvbnRhaW5lckVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJlZ2lzdHJhdGlvbi5jb250YWluZXJFbGVtZW50LnNjcm9sbExlZnQgKz0gZGVsdGFYXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVsdGFZICE9PSAwICYmIHJlZ2lzdHJhdGlvbi5ib2R5RWxlbWVudCkge1xuICAgICAgICAgICAgcmVnaXN0cmF0aW9uLmJvZHlFbGVtZW50LnNjcm9sbFRvcCArPSBkZWx0YVlcbiAgICAgICAgfVxuXG4gICAgICAgIGRyYWcubGFzdFggPSB4O1xuICAgICAgICBkcmFnLmxhc3RZID0geTtcblxuICAgICAgICBkcmFnLmhpc3RvcnkucHVzaCh7dGltZTogRGF0ZS5ub3coKSwgeCwgeX0pO1xuXG4gICAgICAgIC8vIEtlZXAgaGlzdG9yeSBzaXplIG1hbmFnZWFibGVcbiAgICAgICAgaWYgKGRyYWcuaGlzdG9yeS5sZW5ndGggPiAxMCkge1xuICAgICAgICAgICAgZHJhZy5oaXN0b3J5LnNoaWZ0KClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudHxUb3VjaEV2ZW50fSBldmVudFxuICAgICAqL1xuICAgIG9uRHJhZ1N0YXJ0KGV2ZW50KSB7XG4gICAgICAgIC8vIElnbm9yZSByaWdodCBjbGlja3NcbiAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdtb3VzZWRvd24nICYmIGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICBwYXRoID0gZXZlbnQuY29tcG9zZWRQYXRoKCksXG4gICAgICAgICAgICBpZCwgcmVnaXN0cmF0aW9uO1xuXG4gICAgICAgIC8vIFN0b3AgYW55IGFjdGl2ZSBhbmltYXRpb25cbiAgICAgICAgaWYgKG1lLmFjdGl2ZURyYWc/LmFuaW1hdGlvbikge1xuICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUobWUuYWN0aXZlRHJhZy5hbmltYXRpb24pO1xuICAgICAgICAgICAgbWUuYWN0aXZlRHJhZyA9IG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmQgdGhlIHJlZ2lzdHJhdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIHRhcmdldCBlbGVtZW50XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgcmVnXSBvZiBtZS5yZWdpc3RyYXRpb25zKSB7XG4gICAgICAgICAgICBpZiAocGF0aC5pbmNsdWRlcyhyZWcuYm9keUVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgaWQgICAgICAgICAgID0ga2V5O1xuICAgICAgICAgICAgICAgIHJlZ2lzdHJhdGlvbiA9IHJlZztcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcmVnaXN0cmF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlcGxpY2F0ZSB0aGUgY2hlY2sgZnJvbSBTY3JvbGxNYW5hZ2VyOiBpZ25vcmUgaWYgY2xpY2tpbmcgb24gYSBkcmFnZ2FibGUgZWxlbWVudFxuICAgICAgICAvLyBXZSBjaGVjayBmb3IgJ25lby1kcmFnZ2FibGUnIGNsYXNzIG9uIHRoZSBwYXRoXG4gICAgICAgIGlmIChwYXRoLnNvbWUoZWwgPT4gZWwuY2xhc3NMaXN0Py5jb250YWlucygnbmVvLWRyYWdnYWJsZScpKSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bicpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCkgLy8gUHJldmVudCB0ZXh0IHNlbGVjdGlvblxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHt4LCB5fSA9IG1lLmdldEV2ZW50Q29vcmRpbmF0ZXMoZXZlbnQpO1xuXG4gICAgICAgIG1lLmFjdGl2ZURyYWcgPSB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHJlZ2lzdHJhdGlvbixcbiAgICAgICAgICAgIGhpc3RvcnkgIDogW3t0aW1lOiBEYXRlLm5vdygpLCB4LCB5fV0sXG4gICAgICAgICAgICBsYXN0WCAgICA6IHgsXG4gICAgICAgICAgICBsYXN0WSAgICA6IHksXG4gICAgICAgICAgICBsaXN0ZW5lcnM6IHtcbiAgICAgICAgICAgICAgICBtb3ZlOiBtZS5vbkRyYWdNb3ZlLmJpbmQobWUpLFxuICAgICAgICAgICAgICAgIGVuZCA6IG1lLm9uRHJhZ0VuZC5iaW5kKG1lKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChldmVudC50eXBlID09PSAnbW91c2Vkb3duJykge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5zZXRQcm9wZXJ0eSgnY3Vyc29yJywgJ2dyYWJiaW5nJywgJ2ltcG9ydGFudCcpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbWUuYWN0aXZlRHJhZy5saXN0ZW5lcnMubW92ZSwge2NhcHR1cmU6IHRydWV9KTtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBtZS5hY3RpdmVEcmFnLmxpc3RlbmVycy5lbmQsICAgIHtjYXB0dXJlOiB0cnVlfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG1lLmFjdGl2ZURyYWcubGlzdGVuZXJzLm1vdmUsIHtjYXB0dXJlOiB0cnVlLCBwYXNzaXZlOiBmYWxzZX0pO1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBtZS5hY3RpdmVEcmFnLmxpc3RlbmVycy5lbmQsICAge2NhcHR1cmU6IHRydWV9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgZ3JpZCBmb3IgZHJhZyBzY3JvbGxpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5ib2R5SWQgICAgICBUaGUgSUQgb2YgdGhlIGdyaWQgYm9keSAodmVydGljYWwgc2Nyb2xsIHRhcmdldClcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5jb250YWluZXJJZCBUaGUgSUQgb2YgdGhlIGdyaWQgY29udGFpbmVyIChob3Jpem9udGFsIHNjcm9sbCB0YXJnZXQpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuaWQgICAgICAgICAgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSByZWdpc3RyYXRpb24gKGUuZy4gU2Nyb2xsTWFuYWdlciBpZClcbiAgICAgKi9cbiAgICByZWdpc3Rlcih7Ym9keUlkLCBjb250YWluZXJJZCwgaWR9KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLnJlZ2lzdHJhdGlvbnMuaGFzKGlkKSkge1xuICAgICAgICAgICAgbWUudW5yZWdpc3Rlcih7aWR9KVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGJvZHlFbGVtZW50ICAgICAgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChib2R5SWQpLFxuICAgICAgICAgICAgY29udGFpbmVyRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNvbnRhaW5lcklkKTtcblxuICAgICAgICBpZiAoYm9keUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGxldCByZWdpc3RyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgYm9keUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgY29udGFpbmVyRWxlbWVudCxcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBkcmFnU3RhcnRMaXN0ZW5lcjogbWUub25EcmFnU3RhcnQuYmluZChtZSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChOZW8uY29uZmlnLmhhc1RvdWNoRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgYm9keUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHJlZ2lzdHJhdGlvbi5kcmFnU3RhcnRMaXN0ZW5lciwge1xuICAgICAgICAgICAgICAgICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJvZHlFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHJlZ2lzdHJhdGlvbi5kcmFnU3RhcnRMaXN0ZW5lciwge2NhcHR1cmU6IHRydWV9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5yZWdpc3RyYXRpb25zLnNldChpZCwgcmVnaXN0cmF0aW9uKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5yZWdpc3RlcnMgYSBncmlkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuaWRcbiAgICAgKi9cbiAgICB1bnJlZ2lzdGVyKHtpZH0pIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICByZWdpc3RyYXRpb24gPSBtZS5yZWdpc3RyYXRpb25zLmdldChpZCk7XG5cbiAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbikge1xuICAgICAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbi5ib2R5RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChOZW8uY29uZmlnLmhhc1RvdWNoRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdHJhdGlvbi5ib2R5RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgcmVnaXN0cmF0aW9uLmRyYWdTdGFydExpc3RlbmVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWdpc3RyYXRpb24uYm9keUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgcmVnaXN0cmF0aW9uLmRyYWdTdGFydExpc3RlbmVyLCB7Y2FwdHVyZTogdHJ1ZX0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB0aGlzIHJlZ2lzdHJhdGlvbiB3YXMgYWN0aXZlLCBjYW5jZWwgdGhlIGRyYWdcbiAgICAgICAgICAgIGlmIChtZS5hY3RpdmVEcmFnPy5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICBtZS5vbkRyYWdFbmQoe3R5cGU6IE5lby5jb25maWcuaGFzVG91Y2hFdmVudHMgPyAndG91Y2hlbmQnIDogJ21vdXNldXAnfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUucmVnaXN0cmF0aW9ucy5kZWxldGUoaWQpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEdyaWREcmFnU2Nyb2xsKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9