"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["src_main_render_DomApiRenderer_mjs"],{

/***/ "./src/main/render/DomApiRenderer.mjs"
/*!********************************************!*\
  !*** ./src/main/render/DomApiRenderer.mjs ***!
  \********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _vdom_domConstants_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../vdom/domConstants.mjs */ "./src/vdom/domConstants.mjs");


const DomApiRenderer = {
    /**
     * Recursively creates a DOM element (or DocumentFragment) from a VNode tree.
     * This method handles two primary modes based on `isRoot`:
     * 1. If `isRoot` is true:
     *   a. Builds a detached DocumentFragment: if `parentNode` is null. Returns the fragment.
     *   b. Builds and inserts directly into a host DOM: if `parentNode` is provided. Inserts the fragment.
     * 2. If `isRoot` is false (default for recursive calls):
     *   Appends created DOM nodes directly to the provided `parentNode` (which is the DOM element of the direct parent VNode).
     *
     * In addition, this method handles post-processing for nodes that require a live DOM context (e.g., applying scroll state).
     * It collects these nodes in `postMountUpdates` during the recursive build phase and applies the updates immediately
     * after the root element is inserted into the document.
     *
     * @param {Object}      config
     * @param {Number}      [config.index]               The index within `parentNode` to insert the root fragment (used when `isRoot` is true).
     * @param {Boolean}     [config.isRoot=false]        If true, this is the root call for the VNode tree.
     * @param {HTMLElement} [config.parentNode=null]     The parent DOM node to insert into. Its role changes based on `isRoot`.
     * @param {Object[]}    [config.postMountUpdates=[]] Array to store nodes that need post-mount updates (e.g. scroll state).
     * @param {Object}      config.vnode                 The VNode object to convert to a real DOM element.
     * @returns {DocumentFragment|HTMLElement|null}  The created DOM node, the root DocumentFragment, or null.
     * @private
     */
    createDomTree({index, isRoot=false, parentNode, postMountUpdates=[], vnode}) {
        let domNode;

        // No node or just a reference node, opt out
        if (!vnode || vnode.componentId) {
            return null
        }

        // Handle text nodes
        if (vnode.vtype === 'text') {
            domNode = document.createTextNode(vnode.textContent || '');

            // Wrap in comment for consistency with delta updates
            const
                commentStart = document.createComment(` ${vnode.id} `),
                commentEnd   = document.createComment(' /neo-vtext '),
                fragment     = document.createDocumentFragment();

            fragment.append(commentStart, domNode, commentEnd);
            domNode = fragment
        }
        // Handle regular elements
        else if (vnode.nodeName) {
            if (vnode.ns) { // For SVG, ensure correct namespace
                domNode = document.createElementNS(vnode.ns, vnode.nodeName)
            } else {
                domNode = document.createElement(vnode.nodeName)
            }

            // Apply the top-level 'id' property first (guaranteed to exist)
            domNode[Neo.config.useDomIds ? 'id' : 'data-neo-id'] = vnode.id;

            // Apply Attributes
            Object.entries(vnode.attributes).forEach(([key, value]) => {
                if (_vdom_domConstants_mjs__WEBPACK_IMPORTED_MODULE_0__.voidAttributes.has(key)) {
                    domNode.toggleAttribute(key, value === 'true' || value === true)
                } else if (key === 'value') {
                    domNode.value = value
                } else if (value !== null && value !== undefined) {
                    domNode.setAttribute(key, value)
                }
            });

            // Apply Classes
            if (vnode.className.length > 0) {
                domNode.classList.add(...vnode.className)
            }

            // Apply Styles
            if (Neo.isObject(vnode.style)) {
                Object.entries(vnode.style).forEach(([key, value]) => {
                    let important;

                    if (Neo.isString(value) && value.includes('!important')) {
                        value = value.replace('!important', '').trim();
                        domNode.style.setProperty(Neo.decamel(key), value, 'important');
                        important = 'important'
                    }

                    domNode.style.setProperty(Neo.decamel(key), value, important)
                })
            }

            // Handle innerHTML & textContent
            // This applies to elements that contain only plain text (e.g., <span>Hello</span>)
            // If the VNode has childNodes, this block is skipped, and content is handled recursively.
            if (vnode.childNodes.length < 1) {
                if (vnode.innerHTML) {
                    domNode.innerHTML = vnode.innerHTML
                } else if (vnode.textContent) {
                    domNode.textContent = vnode.textContent
                }
            }
        } else {
            console.error('Unhandled VNode type or missing nodeName:', vnode);
            return null
        }

        if (vnode.nodeName && (vnode.scrollTop || vnode.scrollLeft)) {
            postMountUpdates.push({node: domNode, vnode})
        }

        // Recursively process children
        vnode.childNodes.forEach(childVnode => {
            this.createDomTree({parentNode: domNode, postMountUpdates, vnode: childVnode})
        })

        // Final step: handle insertion based on `isRoot` and `parentNode`
        if (isRoot) {
            // This will be either HTMLElement or a DocumentFragment (for text vnodes)
            let nodeToInsert = domNode;

            if (nodeToInsert && parentNode && index !== -1) {
                // If a specific host and index are provided, perform the insertion directly
                if (index < parentNode.childNodes.length) {
                    parentNode.insertBefore(nodeToInsert, parentNode.childNodes[index])
                } else {
                    parentNode.appendChild(nodeToInsert)
                }

                postMountUpdates.forEach(({node, vnode}) => {
                    if (vnode.scrollLeft) {node.scrollLeft = vnode.scrollLeft}
                    if (vnode.scrollTop)  {node.scrollTop  = vnode.scrollTop}
                });

                // Return the actual root DOM node (or fragment for text) that was inserted
                return domNode
            } else {
                // If no specific host or index, return the detached nodeToInsert (HTMLElement or DocumentFragment)
                return nodeToInsert
            }
        } else {
            // For recursive calls (isRoot is false), append directly to the provided parentNode.
            if (parentNode) { // parentNode here is the intermediate DOM parent
                parentNode.append(domNode)
            }

            // Return the appended node (or null)
            return domNode
        }
    }
};

const ns = Neo.ns('Neo.main.render', true);
ns.DomApiRenderer = DomApiRenderer;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DomApiRenderer);


/***/ }

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL21haW4vc3JjX21haW5fcmVuZGVyX0RvbUFwaVJlbmRlcmVyX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUEyRDs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCLGlCQUFpQixvQ0FBb0M7QUFDckQ7QUFDQTtBQUNBLG1CQUFtQiw0REFBNEQ7QUFDL0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwREFBMEQsVUFBVTtBQUNwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0Isa0VBQWM7QUFDbEM7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxxQkFBcUI7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyx5REFBeUQ7QUFDekYsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBLDJDQUEyQyxZQUFZO0FBQ3ZELDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0MsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpRUFBZSxjQUFjLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL21haW4vcmVuZGVyL0RvbUFwaVJlbmRlcmVyLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3ZvaWRBdHRyaWJ1dGVzfSBmcm9tICcuLi8uLi92ZG9tL2RvbUNvbnN0YW50cy5tanMnO1xuXG5jb25zdCBEb21BcGlSZW5kZXJlciA9IHtcbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBjcmVhdGVzIGEgRE9NIGVsZW1lbnQgKG9yIERvY3VtZW50RnJhZ21lbnQpIGZyb20gYSBWTm9kZSB0cmVlLlxuICAgICAqIFRoaXMgbWV0aG9kIGhhbmRsZXMgdHdvIHByaW1hcnkgbW9kZXMgYmFzZWQgb24gYGlzUm9vdGA6XG4gICAgICogMS4gSWYgYGlzUm9vdGAgaXMgdHJ1ZTpcbiAgICAgKiAgIGEuIEJ1aWxkcyBhIGRldGFjaGVkIERvY3VtZW50RnJhZ21lbnQ6IGlmIGBwYXJlbnROb2RlYCBpcyBudWxsLiBSZXR1cm5zIHRoZSBmcmFnbWVudC5cbiAgICAgKiAgIGIuIEJ1aWxkcyBhbmQgaW5zZXJ0cyBkaXJlY3RseSBpbnRvIGEgaG9zdCBET006IGlmIGBwYXJlbnROb2RlYCBpcyBwcm92aWRlZC4gSW5zZXJ0cyB0aGUgZnJhZ21lbnQuXG4gICAgICogMi4gSWYgYGlzUm9vdGAgaXMgZmFsc2UgKGRlZmF1bHQgZm9yIHJlY3Vyc2l2ZSBjYWxscyk6XG4gICAgICogICBBcHBlbmRzIGNyZWF0ZWQgRE9NIG5vZGVzIGRpcmVjdGx5IHRvIHRoZSBwcm92aWRlZCBgcGFyZW50Tm9kZWAgKHdoaWNoIGlzIHRoZSBET00gZWxlbWVudCBvZiB0aGUgZGlyZWN0IHBhcmVudCBWTm9kZSkuXG4gICAgICpcbiAgICAgKiBJbiBhZGRpdGlvbiwgdGhpcyBtZXRob2QgaGFuZGxlcyBwb3N0LXByb2Nlc3NpbmcgZm9yIG5vZGVzIHRoYXQgcmVxdWlyZSBhIGxpdmUgRE9NIGNvbnRleHQgKGUuZy4sIGFwcGx5aW5nIHNjcm9sbCBzdGF0ZSkuXG4gICAgICogSXQgY29sbGVjdHMgdGhlc2Ugbm9kZXMgaW4gYHBvc3RNb3VudFVwZGF0ZXNgIGR1cmluZyB0aGUgcmVjdXJzaXZlIGJ1aWxkIHBoYXNlIGFuZCBhcHBsaWVzIHRoZSB1cGRhdGVzIGltbWVkaWF0ZWx5XG4gICAgICogYWZ0ZXIgdGhlIHJvb3QgZWxlbWVudCBpcyBpbnNlcnRlZCBpbnRvIHRoZSBkb2N1bWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgICAgIFtjb25maWcuaW5kZXhdICAgICAgICAgICAgICAgVGhlIGluZGV4IHdpdGhpbiBgcGFyZW50Tm9kZWAgdG8gaW5zZXJ0IHRoZSByb290IGZyYWdtZW50ICh1c2VkIHdoZW4gYGlzUm9vdGAgaXMgdHJ1ZSkuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgW2NvbmZpZy5pc1Jvb3Q9ZmFsc2VdICAgICAgICBJZiB0cnVlLCB0aGlzIGlzIHRoZSByb290IGNhbGwgZm9yIHRoZSBWTm9kZSB0cmVlLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtjb25maWcucGFyZW50Tm9kZT1udWxsXSAgICAgVGhlIHBhcmVudCBET00gbm9kZSB0byBpbnNlcnQgaW50by4gSXRzIHJvbGUgY2hhbmdlcyBiYXNlZCBvbiBgaXNSb290YC5cbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSAgICBbY29uZmlnLnBvc3RNb3VudFVwZGF0ZXM9W11dIEFycmF5IHRvIHN0b3JlIG5vZGVzIHRoYXQgbmVlZCBwb3N0LW1vdW50IHVwZGF0ZXMgKGUuZy4gc2Nyb2xsIHN0YXRlKS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICBjb25maWcudm5vZGUgICAgICAgICAgICAgICAgIFRoZSBWTm9kZSBvYmplY3QgdG8gY29udmVydCB0byBhIHJlYWwgRE9NIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0RvY3VtZW50RnJhZ21lbnR8SFRNTEVsZW1lbnR8bnVsbH0gIFRoZSBjcmVhdGVkIERPTSBub2RlLCB0aGUgcm9vdCBEb2N1bWVudEZyYWdtZW50LCBvciBudWxsLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY3JlYXRlRG9tVHJlZSh7aW5kZXgsIGlzUm9vdD1mYWxzZSwgcGFyZW50Tm9kZSwgcG9zdE1vdW50VXBkYXRlcz1bXSwgdm5vZGV9KSB7XG4gICAgICAgIGxldCBkb21Ob2RlO1xuXG4gICAgICAgIC8vIE5vIG5vZGUgb3IganVzdCBhIHJlZmVyZW5jZSBub2RlLCBvcHQgb3V0XG4gICAgICAgIGlmICghdm5vZGUgfHwgdm5vZGUuY29tcG9uZW50SWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGUgdGV4dCBub2Rlc1xuICAgICAgICBpZiAodm5vZGUudnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgZG9tTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHRDb250ZW50IHx8ICcnKTtcblxuICAgICAgICAgICAgLy8gV3JhcCBpbiBjb21tZW50IGZvciBjb25zaXN0ZW5jeSB3aXRoIGRlbHRhIHVwZGF0ZXNcbiAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgICAgY29tbWVudFN0YXJ0ID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudChgICR7dm5vZGUuaWR9IGApLFxuICAgICAgICAgICAgICAgIGNvbW1lbnRFbmQgICA9IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoJyAvbmVvLXZ0ZXh0ICcpLFxuICAgICAgICAgICAgICAgIGZyYWdtZW50ICAgICA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kKGNvbW1lbnRTdGFydCwgZG9tTm9kZSwgY29tbWVudEVuZCk7XG4gICAgICAgICAgICBkb21Ob2RlID0gZnJhZ21lbnRcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgcmVndWxhciBlbGVtZW50c1xuICAgICAgICBlbHNlIGlmICh2bm9kZS5ub2RlTmFtZSkge1xuICAgICAgICAgICAgaWYgKHZub2RlLm5zKSB7IC8vIEZvciBTVkcsIGVuc3VyZSBjb3JyZWN0IG5hbWVzcGFjZVxuICAgICAgICAgICAgICAgIGRvbU5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlModm5vZGUubnMsIHZub2RlLm5vZGVOYW1lKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh2bm9kZS5ub2RlTmFtZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQXBwbHkgdGhlIHRvcC1sZXZlbCAnaWQnIHByb3BlcnR5IGZpcnN0IChndWFyYW50ZWVkIHRvIGV4aXN0KVxuICAgICAgICAgICAgZG9tTm9kZVtOZW8uY29uZmlnLnVzZURvbUlkcyA/ICdpZCcgOiAnZGF0YS1uZW8taWQnXSA9IHZub2RlLmlkO1xuXG4gICAgICAgICAgICAvLyBBcHBseSBBdHRyaWJ1dGVzXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyh2bm9kZS5hdHRyaWJ1dGVzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodm9pZEF0dHJpYnV0ZXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tTm9kZS50b2dnbGVBdHRyaWJ1dGUoa2V5LCB2YWx1ZSA9PT0gJ3RydWUnIHx8IHZhbHVlID09PSB0cnVlKVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAndmFsdWUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbU5vZGUudmFsdWUgPSB2YWx1ZVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBkb21Ob2RlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBBcHBseSBDbGFzc2VzXG4gICAgICAgICAgICBpZiAodm5vZGUuY2xhc3NOYW1lLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlLmNsYXNzTGlzdC5hZGQoLi4udm5vZGUuY2xhc3NOYW1lKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBcHBseSBTdHlsZXNcbiAgICAgICAgICAgIGlmIChOZW8uaXNPYmplY3Qodm5vZGUuc3R5bGUpKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXModm5vZGUuc3R5bGUpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW1wb3J0YW50O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChOZW8uaXNTdHJpbmcodmFsdWUpICYmIHZhbHVlLmluY2x1ZGVzKCchaW1wb3J0YW50JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgnIWltcG9ydGFudCcsICcnKS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb21Ob2RlLnN0eWxlLnNldFByb3BlcnR5KE5lby5kZWNhbWVsKGtleSksIHZhbHVlLCAnaW1wb3J0YW50Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRhbnQgPSAnaW1wb3J0YW50J1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZG9tTm9kZS5zdHlsZS5zZXRQcm9wZXJ0eShOZW8uZGVjYW1lbChrZXkpLCB2YWx1ZSwgaW1wb3J0YW50KVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZSBpbm5lckhUTUwgJiB0ZXh0Q29udGVudFxuICAgICAgICAgICAgLy8gVGhpcyBhcHBsaWVzIHRvIGVsZW1lbnRzIHRoYXQgY29udGFpbiBvbmx5IHBsYWluIHRleHQgKGUuZy4sIDxzcGFuPkhlbGxvPC9zcGFuPilcbiAgICAgICAgICAgIC8vIElmIHRoZSBWTm9kZSBoYXMgY2hpbGROb2RlcywgdGhpcyBibG9jayBpcyBza2lwcGVkLCBhbmQgY29udGVudCBpcyBoYW5kbGVkIHJlY3Vyc2l2ZWx5LlxuICAgICAgICAgICAgaWYgKHZub2RlLmNoaWxkTm9kZXMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgICAgIGlmICh2bm9kZS5pbm5lckhUTUwpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tTm9kZS5pbm5lckhUTUwgPSB2bm9kZS5pbm5lckhUTUxcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZub2RlLnRleHRDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbU5vZGUudGV4dENvbnRlbnQgPSB2bm9kZS50ZXh0Q29udGVudFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuaGFuZGxlZCBWTm9kZSB0eXBlIG9yIG1pc3Npbmcgbm9kZU5hbWU6Jywgdm5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2bm9kZS5ub2RlTmFtZSAmJiAodm5vZGUuc2Nyb2xsVG9wIHx8IHZub2RlLnNjcm9sbExlZnQpKSB7XG4gICAgICAgICAgICBwb3N0TW91bnRVcGRhdGVzLnB1c2goe25vZGU6IGRvbU5vZGUsIHZub2RlfSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHByb2Nlc3MgY2hpbGRyZW5cbiAgICAgICAgdm5vZGUuY2hpbGROb2Rlcy5mb3JFYWNoKGNoaWxkVm5vZGUgPT4ge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVEb21UcmVlKHtwYXJlbnROb2RlOiBkb21Ob2RlLCBwb3N0TW91bnRVcGRhdGVzLCB2bm9kZTogY2hpbGRWbm9kZX0pXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gRmluYWwgc3RlcDogaGFuZGxlIGluc2VydGlvbiBiYXNlZCBvbiBgaXNSb290YCBhbmQgYHBhcmVudE5vZGVgXG4gICAgICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBiZSBlaXRoZXIgSFRNTEVsZW1lbnQgb3IgYSBEb2N1bWVudEZyYWdtZW50IChmb3IgdGV4dCB2bm9kZXMpXG4gICAgICAgICAgICBsZXQgbm9kZVRvSW5zZXJ0ID0gZG9tTm9kZTtcblxuICAgICAgICAgICAgaWYgKG5vZGVUb0luc2VydCAmJiBwYXJlbnROb2RlICYmIGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIElmIGEgc3BlY2lmaWMgaG9zdCBhbmQgaW5kZXggYXJlIHByb3ZpZGVkLCBwZXJmb3JtIHRoZSBpbnNlcnRpb24gZGlyZWN0bHlcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBwYXJlbnROb2RlLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGVUb0luc2VydCwgcGFyZW50Tm9kZS5jaGlsZE5vZGVzW2luZGV4XSlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmFwcGVuZENoaWxkKG5vZGVUb0luc2VydClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwb3N0TW91bnRVcGRhdGVzLmZvckVhY2goKHtub2RlLCB2bm9kZX0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZub2RlLnNjcm9sbExlZnQpIHtub2RlLnNjcm9sbExlZnQgPSB2bm9kZS5zY3JvbGxMZWZ0fVxuICAgICAgICAgICAgICAgICAgICBpZiAodm5vZGUuc2Nyb2xsVG9wKSAge25vZGUuc2Nyb2xsVG9wICA9IHZub2RlLnNjcm9sbFRvcH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIFJldHVybiB0aGUgYWN0dWFsIHJvb3QgRE9NIG5vZGUgKG9yIGZyYWdtZW50IGZvciB0ZXh0KSB0aGF0IHdhcyBpbnNlcnRlZFxuICAgICAgICAgICAgICAgIHJldHVybiBkb21Ob2RlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIG5vIHNwZWNpZmljIGhvc3Qgb3IgaW5kZXgsIHJldHVybiB0aGUgZGV0YWNoZWQgbm9kZVRvSW5zZXJ0IChIVE1MRWxlbWVudCBvciBEb2N1bWVudEZyYWdtZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlVG9JbnNlcnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZvciByZWN1cnNpdmUgY2FsbHMgKGlzUm9vdCBpcyBmYWxzZSksIGFwcGVuZCBkaXJlY3RseSB0byB0aGUgcHJvdmlkZWQgcGFyZW50Tm9kZS5cbiAgICAgICAgICAgIGlmIChwYXJlbnROb2RlKSB7IC8vIHBhcmVudE5vZGUgaGVyZSBpcyB0aGUgaW50ZXJtZWRpYXRlIERPTSBwYXJlbnRcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmFwcGVuZChkb21Ob2RlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGFwcGVuZGVkIG5vZGUgKG9yIG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZG9tTm9kZVxuICAgICAgICB9XG4gICAgfVxufTtcblxuY29uc3QgbnMgPSBOZW8ubnMoJ05lby5tYWluLnJlbmRlcicsIHRydWUpO1xubnMuRG9tQXBpUmVuZGVyZXIgPSBEb21BcGlSZW5kZXJlcjtcblxuZXhwb3J0IGRlZmF1bHQgRG9tQXBpUmVuZGVyZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9