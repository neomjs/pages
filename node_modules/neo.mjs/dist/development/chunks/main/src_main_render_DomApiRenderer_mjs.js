export const __webpack_esm_id__ = "src_main_render_DomApiRenderer_mjs";
export const __webpack_esm_ids__ = ["src_main_render_DomApiRenderer_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./src/main/render/DomApiRenderer.mjs"
/*!********************************************!*\
  !*** ./src/main/render/DomApiRenderer.mjs ***!
  \********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _vdom_domConstants_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../vdom/domConstants.mjs */ "./src/vdom/domConstants.mjs");


const DomApiRenderer = {
    /**
     * Recursively creates a DOM element (or DocumentFragment) from a VNode tree.
     * This method handles two primary modes based on `isRoot`:
     * 1. If `isRoot` is true:
     *   a. Builds a detached DocumentFragment: if `parentNode` is null. Returns the fragment.
     *   b. Builds and inserts directly into a host DOM: if `parentNode` is provided. Inserts the fragment.
     * 2. If `isRoot` is false (default for recursive calls):
     *   Appends created DOM nodes directly to the provided `parentNode` (which is the DOM element of the direct parent VNode).
     *
     * In addition, this method handles post-processing for nodes that require a live DOM context (e.g., applying scroll state).
     * It collects these nodes in `postMountUpdates` during the recursive build phase and applies the updates immediately
     * after the root element is inserted into the document.
     *
     * @param {Object}      config
     * @param {Number}      [config.index]               The index within `parentNode` to insert the root fragment (used when `isRoot` is true).
     * @param {Boolean}     [config.isRoot=false]        If true, this is the root call for the VNode tree.
     * @param {HTMLElement} [config.parentNode=null]     The parent DOM node to insert into. Its role changes based on `isRoot`.
     * @param {Object[]}    [config.postMountUpdates=[]] Array to store nodes that need post-mount updates (e.g. scroll state).
     * @param {Object}      config.vnode                 The VNode object to convert to a real DOM element.
     * @returns {DocumentFragment|HTMLElement|null}  The created DOM node, the root DocumentFragment, or null.
     * @private
     */
    createDomTree({index, isRoot=false, parentNode, postMountUpdates=[], vnode}) {
        let domNode;

        // No node or just a reference node, opt out
        if (!vnode || vnode.componentId) {
            return null
        }

        // Handle text nodes
        if (vnode.vtype === 'text') {
            domNode = document.createTextNode(vnode.textContent || '');

            // Wrap in comment for consistency with delta updates
            const
                commentStart = document.createComment(` ${vnode.id} `),
                commentEnd   = document.createComment(' /neo-vtext '),
                fragment     = document.createDocumentFragment();

            fragment.append(commentStart, domNode, commentEnd);
            domNode = fragment
        }
        // Handle Fragments
        else if (vnode.nodeName === 'fragment') {
            domNode = document.createDocumentFragment();
            domNode.append(document.createComment(` ${vnode.id}-start `))
        }
        // Handle regular elements
        else if (vnode.nodeName) {
            if (vnode.ns) { // For SVG, ensure correct namespace
                domNode = document.createElementNS(vnode.ns, vnode.nodeName)
            } else {
                domNode = document.createElement(vnode.nodeName)
            }

            // Apply the top-level 'id' property first (guaranteed to exist)
            domNode[Neo.config.useDomIds ? 'id' : 'data-neo-id'] = vnode.id;

            // Apply Attributes
            Object.entries(vnode.attributes).forEach(([key, value]) => {
                if (_vdom_domConstants_mjs__WEBPACK_IMPORTED_MODULE_0__.voidAttributes.has(key)) {
                    domNode.toggleAttribute(key, value === 'true' || value === true)
                } else if (key === 'value') {
                    domNode.value = value
                } else if (value !== null && value !== undefined) {
                    domNode.setAttribute(key, value)
                }
            });

            // Apply Classes
            if (vnode.className.length > 0) {
                domNode.classList.add(...vnode.className)
            }

            // Apply Styles
            if (Neo.isObject(vnode.style)) {
                Object.entries(vnode.style).forEach(([key, value]) => {
                    let important;

                    if (Neo.isString(value) && value.includes('!important')) {
                        value = value.replace('!important', '').trim();
                        domNode.style.setProperty(Neo.decamel(key), value, 'important');
                        important = 'important'
                    }

                    domNode.style.setProperty(Neo.decamel(key), value, important)
                })
            }

            // Handle innerHTML & textContent
            // This applies to elements that contain only plain text (e.g., <span>Hello</span>)
            // If the VNode has childNodes, this block is skipped, and content is handled recursively.
            if (vnode.childNodes.length < 1) {
                if (vnode.innerHTML) {
                    domNode.innerHTML = vnode.innerHTML
                } else if (vnode.textContent) {
                    domNode.textContent = vnode.textContent
                }
            }
        } else {
            console.error('Unhandled VNode type or missing nodeName:', vnode);
            return null
        }

        if (vnode.nodeName && (vnode.scrollTop || vnode.scrollLeft)) {
            postMountUpdates.push({node: domNode, vnode})
        }

        // Recursively process children
        vnode.childNodes.forEach(childVnode => {
            this.createDomTree({parentNode: domNode, postMountUpdates, vnode: childVnode})
        })

        if (vnode.nodeName === 'fragment') {
            domNode.append(document.createComment(` ${vnode.id}-end `))
        }

        // Final step: handle insertion based on `isRoot` and `parentNode`
        if (isRoot) {
            // This will be either HTMLElement or a DocumentFragment (for text vnodes)
            let nodeToInsert = domNode;

            if (nodeToInsert && parentNode && index !== -1) {
                // If a specific host and index are provided, perform the insertion directly
                if (index < parentNode.childNodes.length) {
                    parentNode.insertBefore(nodeToInsert, parentNode.childNodes[index])
                } else {
                    parentNode.appendChild(nodeToInsert)
                }

                postMountUpdates.forEach(({node, vnode}) => {
                    if (vnode.scrollLeft) {node.scrollLeft = vnode.scrollLeft}
                    if (vnode.scrollTop)  {node.scrollTop  = vnode.scrollTop}
                });

                // Return the actual root DOM node (or fragment for text) that was inserted
                return domNode
            } else {
                // If no specific host or index, return the detached nodeToInsert (HTMLElement or DocumentFragment)
                return nodeToInsert
            }
        } else {
            // For recursive calls (isRoot is false), append directly to the provided parentNode.
            if (parentNode) { // parentNode here is the intermediate DOM parent
                parentNode.append(domNode)
            }

            // Return the appended node (or null)
            return domNode
        }
    }
};

const ns = Neo.ns('Neo.main.render', true);
ns.DomApiRenderer = DomApiRenderer;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DomApiRenderer);


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL21haW4vc3JjX21haW5fcmVuZGVyX0RvbUFwaVJlbmRlcmVyX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBMkQ7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QixpQkFBaUIsb0NBQW9DO0FBQ3JEO0FBQ0E7QUFDQSxtQkFBbUIsNERBQTREO0FBQy9FOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMERBQTBELFVBQVU7QUFDcEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsU0FBUztBQUMvRDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0Isa0VBQWM7QUFDbEM7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxxQkFBcUI7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyx5REFBeUQ7QUFDekYsU0FBUzs7QUFFVDtBQUNBLHNEQUFzRCxTQUFTO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUEsMkNBQTJDLFlBQVk7QUFDdkQsMkNBQTJDO0FBQzNDLDJDQUEyQztBQUMzQyxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlFQUFlLGNBQWMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvbWFpbi9yZW5kZXIvRG9tQXBpUmVuZGVyZXIubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dm9pZEF0dHJpYnV0ZXN9IGZyb20gJy4uLy4uL3Zkb20vZG9tQ29uc3RhbnRzLm1qcyc7XG5cbmNvbnN0IERvbUFwaVJlbmRlcmVyID0ge1xuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IGNyZWF0ZXMgYSBET00gZWxlbWVudCAob3IgRG9jdW1lbnRGcmFnbWVudCkgZnJvbSBhIFZOb2RlIHRyZWUuXG4gICAgICogVGhpcyBtZXRob2QgaGFuZGxlcyB0d28gcHJpbWFyeSBtb2RlcyBiYXNlZCBvbiBgaXNSb290YDpcbiAgICAgKiAxLiBJZiBgaXNSb290YCBpcyB0cnVlOlxuICAgICAqICAgYS4gQnVpbGRzIGEgZGV0YWNoZWQgRG9jdW1lbnRGcmFnbWVudDogaWYgYHBhcmVudE5vZGVgIGlzIG51bGwuIFJldHVybnMgdGhlIGZyYWdtZW50LlxuICAgICAqICAgYi4gQnVpbGRzIGFuZCBpbnNlcnRzIGRpcmVjdGx5IGludG8gYSBob3N0IERPTTogaWYgYHBhcmVudE5vZGVgIGlzIHByb3ZpZGVkLiBJbnNlcnRzIHRoZSBmcmFnbWVudC5cbiAgICAgKiAyLiBJZiBgaXNSb290YCBpcyBmYWxzZSAoZGVmYXVsdCBmb3IgcmVjdXJzaXZlIGNhbGxzKTpcbiAgICAgKiAgIEFwcGVuZHMgY3JlYXRlZCBET00gbm9kZXMgZGlyZWN0bHkgdG8gdGhlIHByb3ZpZGVkIGBwYXJlbnROb2RlYCAod2hpY2ggaXMgdGhlIERPTSBlbGVtZW50IG9mIHRoZSBkaXJlY3QgcGFyZW50IFZOb2RlKS5cbiAgICAgKlxuICAgICAqIEluIGFkZGl0aW9uLCB0aGlzIG1ldGhvZCBoYW5kbGVzIHBvc3QtcHJvY2Vzc2luZyBmb3Igbm9kZXMgdGhhdCByZXF1aXJlIGEgbGl2ZSBET00gY29udGV4dCAoZS5nLiwgYXBwbHlpbmcgc2Nyb2xsIHN0YXRlKS5cbiAgICAgKiBJdCBjb2xsZWN0cyB0aGVzZSBub2RlcyBpbiBgcG9zdE1vdW50VXBkYXRlc2AgZHVyaW5nIHRoZSByZWN1cnNpdmUgYnVpbGQgcGhhc2UgYW5kIGFwcGxpZXMgdGhlIHVwZGF0ZXMgaW1tZWRpYXRlbHlcbiAgICAgKiBhZnRlciB0aGUgcm9vdCBlbGVtZW50IGlzIGluc2VydGVkIGludG8gdGhlIGRvY3VtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgY29uZmlnXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgW2NvbmZpZy5pbmRleF0gICAgICAgICAgICAgICBUaGUgaW5kZXggd2l0aGluIGBwYXJlbnROb2RlYCB0byBpbnNlcnQgdGhlIHJvb3QgZnJhZ21lbnQgKHVzZWQgd2hlbiBgaXNSb290YCBpcyB0cnVlKS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICBbY29uZmlnLmlzUm9vdD1mYWxzZV0gICAgICAgIElmIHRydWUsIHRoaXMgaXMgdGhlIHJvb3QgY2FsbCBmb3IgdGhlIFZOb2RlIHRyZWUuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW2NvbmZpZy5wYXJlbnROb2RlPW51bGxdICAgICBUaGUgcGFyZW50IERPTSBub2RlIHRvIGluc2VydCBpbnRvLiBJdHMgcm9sZSBjaGFuZ2VzIGJhc2VkIG9uIGBpc1Jvb3RgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119ICAgIFtjb25maWcucG9zdE1vdW50VXBkYXRlcz1bXV0gQXJyYXkgdG8gc3RvcmUgbm9kZXMgdGhhdCBuZWVkIHBvc3QtbW91bnQgdXBkYXRlcyAoZS5nLiBzY3JvbGwgc3RhdGUpLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgIGNvbmZpZy52bm9kZSAgICAgICAgICAgICAgICAgVGhlIFZOb2RlIG9iamVjdCB0byBjb252ZXJ0IHRvIGEgcmVhbCBET00gZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7RG9jdW1lbnRGcmFnbWVudHxIVE1MRWxlbWVudHxudWxsfSAgVGhlIGNyZWF0ZWQgRE9NIG5vZGUsIHRoZSByb290IERvY3VtZW50RnJhZ21lbnQsIG9yIG51bGwuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjcmVhdGVEb21UcmVlKHtpbmRleCwgaXNSb290PWZhbHNlLCBwYXJlbnROb2RlLCBwb3N0TW91bnRVcGRhdGVzPVtdLCB2bm9kZX0pIHtcbiAgICAgICAgbGV0IGRvbU5vZGU7XG5cbiAgICAgICAgLy8gTm8gbm9kZSBvciBqdXN0IGEgcmVmZXJlbmNlIG5vZGUsIG9wdCBvdXRcbiAgICAgICAgaWYgKCF2bm9kZSB8fCB2bm9kZS5jb21wb25lbnRJZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSB0ZXh0IG5vZGVzXG4gICAgICAgIGlmICh2bm9kZS52dHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICBkb21Ob2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dENvbnRlbnQgfHwgJycpO1xuXG4gICAgICAgICAgICAvLyBXcmFwIGluIGNvbW1lbnQgZm9yIGNvbnNpc3RlbmN5IHdpdGggZGVsdGEgdXBkYXRlc1xuICAgICAgICAgICAgY29uc3RcbiAgICAgICAgICAgICAgICBjb21tZW50U3RhcnQgPSBkb2N1bWVudC5jcmVhdGVDb21tZW50KGAgJHt2bm9kZS5pZH0gYCksXG4gICAgICAgICAgICAgICAgY29tbWVudEVuZCAgID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCgnIC9uZW8tdnRleHQgJyksXG4gICAgICAgICAgICAgICAgZnJhZ21lbnQgICAgID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gICAgICAgICAgICBmcmFnbWVudC5hcHBlbmQoY29tbWVudFN0YXJ0LCBkb21Ob2RlLCBjb21tZW50RW5kKTtcbiAgICAgICAgICAgIGRvbU5vZGUgPSBmcmFnbWVudFxuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSBGcmFnbWVudHNcbiAgICAgICAgZWxzZSBpZiAodm5vZGUubm9kZU5hbWUgPT09ICdmcmFnbWVudCcpIHtcbiAgICAgICAgICAgIGRvbU5vZGUgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgICAgICBkb21Ob2RlLmFwcGVuZChkb2N1bWVudC5jcmVhdGVDb21tZW50KGAgJHt2bm9kZS5pZH0tc3RhcnQgYCkpXG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIHJlZ3VsYXIgZWxlbWVudHNcbiAgICAgICAgZWxzZSBpZiAodm5vZGUubm9kZU5hbWUpIHtcbiAgICAgICAgICAgIGlmICh2bm9kZS5ucykgeyAvLyBGb3IgU1ZHLCBlbnN1cmUgY29ycmVjdCBuYW1lc3BhY2VcbiAgICAgICAgICAgICAgICBkb21Ob2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB2bm9kZS5ub2RlTmFtZSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZG9tTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodm5vZGUubm9kZU5hbWUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFwcGx5IHRoZSB0b3AtbGV2ZWwgJ2lkJyBwcm9wZXJ0eSBmaXJzdCAoZ3VhcmFudGVlZCB0byBleGlzdClcbiAgICAgICAgICAgIGRvbU5vZGVbTmVvLmNvbmZpZy51c2VEb21JZHMgPyAnaWQnIDogJ2RhdGEtbmVvLWlkJ10gPSB2bm9kZS5pZDtcblxuICAgICAgICAgICAgLy8gQXBwbHkgQXR0cmlidXRlc1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXModm5vZGUuYXR0cmlidXRlcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZvaWRBdHRyaWJ1dGVzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbU5vZGUudG9nZ2xlQXR0cmlidXRlKGtleSwgdmFsdWUgPT09ICd0cnVlJyB8fCB2YWx1ZSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgICAgICAgICBkb21Ob2RlLnZhbHVlID0gdmFsdWVcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tTm9kZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQXBwbHkgQ2xhc3Nlc1xuICAgICAgICAgICAgaWYgKHZub2RlLmNsYXNzTmFtZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZG9tTm9kZS5jbGFzc0xpc3QuYWRkKC4uLnZub2RlLmNsYXNzTmFtZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQXBwbHkgU3R5bGVzXG4gICAgICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KHZub2RlLnN0eWxlKSkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHZub2RlLnN0eWxlKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGltcG9ydGFudDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoTmVvLmlzU3RyaW5nKHZhbHVlKSAmJiB2YWx1ZS5pbmNsdWRlcygnIWltcG9ydGFudCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoJyFpbXBvcnRhbnQnLCAnJykudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tTm9kZS5zdHlsZS5zZXRQcm9wZXJ0eShOZW8uZGVjYW1lbChrZXkpLCB2YWx1ZSwgJ2ltcG9ydGFudCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0YW50ID0gJ2ltcG9ydGFudCdcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGRvbU5vZGUuc3R5bGUuc2V0UHJvcGVydHkoTmVvLmRlY2FtZWwoa2V5KSwgdmFsdWUsIGltcG9ydGFudClcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBIYW5kbGUgaW5uZXJIVE1MICYgdGV4dENvbnRlbnRcbiAgICAgICAgICAgIC8vIFRoaXMgYXBwbGllcyB0byBlbGVtZW50cyB0aGF0IGNvbnRhaW4gb25seSBwbGFpbiB0ZXh0IChlLmcuLCA8c3Bhbj5IZWxsbzwvc3Bhbj4pXG4gICAgICAgICAgICAvLyBJZiB0aGUgVk5vZGUgaGFzIGNoaWxkTm9kZXMsIHRoaXMgYmxvY2sgaXMgc2tpcHBlZCwgYW5kIGNvbnRlbnQgaXMgaGFuZGxlZCByZWN1cnNpdmVseS5cbiAgICAgICAgICAgIGlmICh2bm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAodm5vZGUuaW5uZXJIVE1MKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbU5vZGUuaW5uZXJIVE1MID0gdm5vZGUuaW5uZXJIVE1MXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2bm9kZS50ZXh0Q29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICBkb21Ob2RlLnRleHRDb250ZW50ID0gdm5vZGUudGV4dENvbnRlbnRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmhhbmRsZWQgVk5vZGUgdHlwZSBvciBtaXNzaW5nIG5vZGVOYW1lOicsIHZub2RlKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodm5vZGUubm9kZU5hbWUgJiYgKHZub2RlLnNjcm9sbFRvcCB8fCB2bm9kZS5zY3JvbGxMZWZ0KSkge1xuICAgICAgICAgICAgcG9zdE1vdW50VXBkYXRlcy5wdXNoKHtub2RlOiBkb21Ob2RlLCB2bm9kZX0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWN1cnNpdmVseSBwcm9jZXNzIGNoaWxkcmVuXG4gICAgICAgIHZub2RlLmNoaWxkTm9kZXMuZm9yRWFjaChjaGlsZFZub2RlID0+IHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRG9tVHJlZSh7cGFyZW50Tm9kZTogZG9tTm9kZSwgcG9zdE1vdW50VXBkYXRlcywgdm5vZGU6IGNoaWxkVm5vZGV9KVxuICAgICAgICB9KVxuXG4gICAgICAgIGlmICh2bm9kZS5ub2RlTmFtZSA9PT0gJ2ZyYWdtZW50Jykge1xuICAgICAgICAgICAgZG9tTm9kZS5hcHBlbmQoZG9jdW1lbnQuY3JlYXRlQ29tbWVudChgICR7dm5vZGUuaWR9LWVuZCBgKSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmFsIHN0ZXA6IGhhbmRsZSBpbnNlcnRpb24gYmFzZWQgb24gYGlzUm9vdGAgYW5kIGBwYXJlbnROb2RlYFxuICAgICAgICBpZiAoaXNSb290KSB7XG4gICAgICAgICAgICAvLyBUaGlzIHdpbGwgYmUgZWl0aGVyIEhUTUxFbGVtZW50IG9yIGEgRG9jdW1lbnRGcmFnbWVudCAoZm9yIHRleHQgdm5vZGVzKVxuICAgICAgICAgICAgbGV0IG5vZGVUb0luc2VydCA9IGRvbU5vZGU7XG5cbiAgICAgICAgICAgIGlmIChub2RlVG9JbnNlcnQgJiYgcGFyZW50Tm9kZSAmJiBpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhIHNwZWNpZmljIGhvc3QgYW5kIGluZGV4IGFyZSBwcm92aWRlZCwgcGVyZm9ybSB0aGUgaW5zZXJ0aW9uIGRpcmVjdGx5XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgcGFyZW50Tm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlVG9JbnNlcnQsIHBhcmVudE5vZGUuY2hpbGROb2Rlc1tpbmRleF0pXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5hcHBlbmRDaGlsZChub2RlVG9JbnNlcnQpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcG9zdE1vdW50VXBkYXRlcy5mb3JFYWNoKCh7bm9kZSwgdm5vZGV9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2bm9kZS5zY3JvbGxMZWZ0KSB7bm9kZS5zY3JvbGxMZWZ0ID0gdm5vZGUuc2Nyb2xsTGVmdH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHZub2RlLnNjcm9sbFRvcCkgIHtub2RlLnNjcm9sbFRvcCAgPSB2bm9kZS5zY3JvbGxUb3B9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGFjdHVhbCByb290IERPTSBub2RlIChvciBmcmFnbWVudCBmb3IgdGV4dCkgdGhhdCB3YXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tTm9kZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBubyBzcGVjaWZpYyBob3N0IG9yIGluZGV4LCByZXR1cm4gdGhlIGRldGFjaGVkIG5vZGVUb0luc2VydCAoSFRNTEVsZW1lbnQgb3IgRG9jdW1lbnRGcmFnbWVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZVRvSW5zZXJ0XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGb3IgcmVjdXJzaXZlIGNhbGxzIChpc1Jvb3QgaXMgZmFsc2UpLCBhcHBlbmQgZGlyZWN0bHkgdG8gdGhlIHByb3ZpZGVkIHBhcmVudE5vZGUuXG4gICAgICAgICAgICBpZiAocGFyZW50Tm9kZSkgeyAvLyBwYXJlbnROb2RlIGhlcmUgaXMgdGhlIGludGVybWVkaWF0ZSBET00gcGFyZW50XG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5hcHBlbmQoZG9tTm9kZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBhcHBlbmRlZCBub2RlIChvciBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGRvbU5vZGVcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmNvbnN0IG5zID0gTmVvLm5zKCdOZW8ubWFpbi5yZW5kZXInLCB0cnVlKTtcbm5zLkRvbUFwaVJlbmRlcmVyID0gRG9tQXBpUmVuZGVyZXI7XG5cbmV4cG9ydCBkZWZhdWx0IERvbUFwaVJlbmRlcmVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==