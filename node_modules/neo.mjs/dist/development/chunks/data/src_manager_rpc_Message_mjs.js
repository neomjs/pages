"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["src_manager_rpc_Message_mjs"],{

/***/ "./src/manager/rpc/Message.mjs":
/*!*************************************!*\
  !*** ./src/manager/rpc/Message.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Base.mjs */ "./src/manager/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @class Neo.manager.rpc.Message
 * @extends Neo.manager.Base
 * @singleton
 */
class Message extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Stores the urls of endpoints for which a setTimeout() call is in progress
     * @member {String[]} endPointTimeouts=[]
     */
    endPointTimeouts = []
    /**
     * internal incrementing flag
     * @member {Number} messageId=1
     * @protected
     */
    messageId = 1
    /**
     * Time window in ms for buffering incoming message requests
     * @member {Number} requestBuffer=20
     */
    requestBuffer = 20
    /**
     * @member {Object} socketConnections={}
     */
    socketConnections = {}
    /**
     * internal incrementing flag
     * @member {Number} transactionId=1
     * @protected
     */
    transactionId = 1

    static getConfig() {return {
        /**
         * @member {String} className='Neo.manager.rpc.Message'
         * @protected
         */
        className: 'Neo.manager.rpc.Message',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true,
        /**
         * @member {Object[]} sorters
         */
        sorters: [{
            direction: 'ASC',
            property : 'id'
        }]
    }}

    /**
     *
     * @param {Object} msg
     * @returns {Promise<any>}
     */
    onMessage(msg) {
        let api = Neo.manager.rpc.Api.get(`${msg.service}.${msg.method}`);

        return this[`onMessage${Neo.capitalize(api.type)}`](msg, api);
    }

    /**
     *
     * @param {Object} msg
     * @param {Object} api
     * @protected
     * @returns {Promise<any>}
     */
    onMessageAjax(msg, api) {
        return new Promise((resolve, reject) => {
            let me  = this,
                url = api.url;

            me.register({
                id           : me.messageId,
                method       : msg.method,
                params       : msg.params,
                reject,
                resolve,
                service      : msg.service,
                transactionId: 0,
                url
            });

            me.messageId++;

            if (!me.endPointTimeouts.includes(url)) {
                me.endPointTimeouts.push(url);

                setTimeout(() => {
                    me.resolveBufferTimeout(url);
                }, me.requestBuffer)
            }
        });
    }

    /**
     *
     * @param {Object} msg
     * @param {Object} api
     * @protected
     * @returns {Promise<any>}
     */
    async onMessageWebsocket(msg, api) {
        let me         = this,
            url        = api.url,
            connection = me.socketConnections[url];

        if (!connection) {
            let module = await __webpack_require__.e(/*! import() */ "vendors-src_data_connection_WebSocket_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ../../data/connection/WebSocket.mjs */ "./src/data/connection/WebSocket.mjs"));

            me.socketConnections[url] = connection = Neo.create(module.default, {serverAddress: url});
        }

        return await connection.promiseMessage(msg);
    }

    /**
     * @param {String} url
     */
    async resolveBufferTimeout(url) {
        let me            = this,
            itemIds       = [],
            processItems  = me.find({transactionId: 0, url}),
            requests      = [],
            transactionId = me.transactionId,
            response;

        processItems.forEach(item => {
            item.transactionId = transactionId;

            itemIds.push(item.id);

            requests.push({
                id     : item.id,
                method : item.method,
                params : item.params,
                service: item.service
            });
        });

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(me.endPointTimeouts, url);

        me.transactionId++;

        response = await Neo.Fetch.request(url, {}, 'post', JSON.stringify({tid: transactionId, requests}));

        processItems.forEach(item => {
            // todo: pass the item which is included inside the response object
            // todo: reject the Promise in case the item is missing

            item.resolve();
        });

        // todo: remove only the items which are included inside the response
        me.remove(itemIds);
    }
}

Neo.applyClassConfig(Message);

let instance = Neo.create(Message);

Neo.applyToGlobalNs(instance);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (instance);


/***/ }),

/***/ "./src/util/Array.mjs":
/*!****************************!*\
  !*** ./src/util/Array.mjs ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.util.Array
 * @extends Neo.core.Base
 */
class NeoArray extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static getConfig() {return {
        /**
         * @member {String} className='Neo.util.Array'
         * @protected
         */
        className: 'Neo.util.Array'
    }}

    /**
     * Adds an item or Array of items to an array in case it does not already exist.
     * Only primitive items will get found as duplicates
     * @param {Array} arr
     * @param {*} items
     */
    static add(arr, items) {
        if (!Array.isArray(items)) {
            items = [items];
        }

        items.forEach(item => {
            if (!arr.includes(item)) {
                arr.push(item);
            }
        });
    }

    /**
     * Returns an array of items which are present in array1, but not in array2
     * @param {Array} array1=[]
     * @param {Array} array2=[]
     * @returns {Array}
     */
    static difference(array1=[], array2=[]) {
        return array1.filter(item => !array2.includes(item));
    }

    /**
     * Checks if the item is included by reference inside the array
     * @param {Array} arr
     * @param {*} item
     */
    static hasItem(arr, item) {
        return arr.includes(item);
    }

    /**
     * Returns an array of items which are present in array1 and array2
     * Only supports primitive items
     * @param {Array} array1=[]
     * @param {Array} array2=[]
     * @returns {Array}
     */
    static intersection(array1=[], array2=[]) {
        return array1.filter(item => array2.includes(item));
    }

    /**
     * Moves an item inside arr from fromIndex to toIndex
     * @param {Array} arr
     * @param {Number} fromIndex
     * @param {Number} toIndex
     */
    static move(arr, fromIndex, toIndex) {
        if (fromIndex === toIndex) {
            return arr;
        }

        if (fromIndex >= arr.length) {
            fromIndex = arr.length - 1;
        }

        arr.splice(toIndex, 0, arr.splice(fromIndex, 1)[0]);
        return arr;
    }

    /**
     * Removes an item or array of items from an array. Only primitive items will get found
     * @param {Array} arr
     * @param {*} items
     */
    static remove(arr, items) {
        let index;

        if (!Array.isArray(items)) {
            items = [items];
        }

        items.forEach(item => {
            index = arr.indexOf(item);

            index > -1 && arr.splice(index, 1);
        });
    }

    /**
     * Convenience method to combine add & remove in one call.
     * You can pass single items or an array of items to add or to remove.
     * @param {Array} arr
     * @param {*} removeItems
     * @param {*} addItems
     */
    static removeAdd(arr, removeItems, addItems) {
        this.remove(arr, removeItems);
        this.add(arr, addItems);
    }

    /**
     * Removes an item from an array in case it does exist, otherwise adds it
     * @param {Array} arr
     * @param {*} item
     */
    static toggle(arr, item) {
        this[this.hasItem(arr, item) ? 'remove' : 'add'](arr, item);
    }

    /**
     * Returns an array of items which are present in array1 and array2
     * Only supports primitive items
     * @param {Array} array1
     * @param {Array} array2
     * @returns {Array}
     */
    static union(array1, array2) {
        let result = [],
            merge  = array1.concat(array2),
            len    = merge.length,
            assoc  = {},
            item;

        while (len--) {
            item = merge[len];

            if (!assoc[item]) {
                result.unshift(item);
                assoc[item] = true;
            }
        }

        return result;
    }

    /**
     * Adds an item or Array of items to an array in case it does not already exist.
     * Only primitive items will get found as duplicates
     * @param {Array} arr
     * @param {*} items
     */
    static unshift(arr, items) {
        if (!Array.isArray(items)) {
            items = [items];
        }

        items.forEach(item => {
            if (!arr.includes(item)) {
                arr.unshift(item);
            }
        });
    }
}

Neo.applyClassConfig(NeoArray);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (NeoArray);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2RhdGEvc3JjX21hbmFnZXJfcnBjX01lc3NhZ2VfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFtQztBQUNTOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlEQUFJO0FBQzFCO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEI7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDZDQUE2QyxZQUFZLEdBQUcsV0FBVzs7QUFFdkUsZ0NBQWdDLHlCQUF5QjtBQUN6RDs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0Isd05BQTZDOztBQUU1RSxpRkFBaUYsbUJBQW1CO0FBQ3BHOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsc0JBQXNCO0FBQzNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVCxRQUFRLDhEQUFlOztBQUV2Qjs7QUFFQSxrREFBa0QsMEJBQTBCLDZCQUE2Qjs7QUFFekc7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxpRUFBZSxRQUFRLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzS1k7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNEQUFJO0FBQzNCLHdCQUF3QjtBQUN4QjtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLEdBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLEdBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsR0FBRztBQUNsQixlQUFlLEdBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLEdBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBLGlFQUFlLFFBQVEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvbWFuYWdlci9ycGMvTWVzc2FnZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy91dGlsL0FycmF5Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZSAgICAgZnJvbSAnLi4vQmFzZS5tanMnO1xuaW1wb3J0IE5lb0FycmF5IGZyb20gJy4uLy4uL3V0aWwvQXJyYXkubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLm1hbmFnZXIucnBjLk1lc3NhZ2VcbiAqIEBleHRlbmRzIE5lby5tYW5hZ2VyLkJhc2VcbiAqIEBzaW5nbGV0b25cbiAqL1xuY2xhc3MgTWVzc2FnZSBleHRlbmRzIEJhc2Uge1xuICAgIC8qKlxuICAgICAqIFN0b3JlcyB0aGUgdXJscyBvZiBlbmRwb2ludHMgZm9yIHdoaWNoIGEgc2V0VGltZW91dCgpIGNhbGwgaXMgaW4gcHJvZ3Jlc3NcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gZW5kUG9pbnRUaW1lb3V0cz1bXVxuICAgICAqL1xuICAgIGVuZFBvaW50VGltZW91dHMgPSBbXVxuICAgIC8qKlxuICAgICAqIGludGVybmFsIGluY3JlbWVudGluZyBmbGFnXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSBtZXNzYWdlSWQ9MVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBtZXNzYWdlSWQgPSAxXG4gICAgLyoqXG4gICAgICogVGltZSB3aW5kb3cgaW4gbXMgZm9yIGJ1ZmZlcmluZyBpbmNvbWluZyBtZXNzYWdlIHJlcXVlc3RzXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSByZXF1ZXN0QnVmZmVyPTIwXG4gICAgICovXG4gICAgcmVxdWVzdEJ1ZmZlciA9IDIwXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBzb2NrZXRDb25uZWN0aW9ucz17fVxuICAgICAqL1xuICAgIHNvY2tldENvbm5lY3Rpb25zID0ge31cbiAgICAvKipcbiAgICAgKiBpbnRlcm5hbCBpbmNyZW1lbnRpbmcgZmxhZ1xuICAgICAqIEBtZW1iZXIge051bWJlcn0gdHJhbnNhY3Rpb25JZD0xXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRyYW5zYWN0aW9uSWQgPSAxXG5cbiAgICBzdGF0aWMgZ2V0Q29uZmlnKCkge3JldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLm1hbmFnZXIucnBjLk1lc3NhZ2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5tYW5hZ2VyLnJwYy5NZXNzYWdlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZXRvbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZXRvbjogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdFtdfSBzb3J0ZXJzXG4gICAgICAgICAqL1xuICAgICAgICBzb3J0ZXJzOiBbe1xuICAgICAgICAgICAgZGlyZWN0aW9uOiAnQVNDJyxcbiAgICAgICAgICAgIHByb3BlcnR5IDogJ2lkJ1xuICAgICAgICB9XVxuICAgIH19XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtc2dcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIG9uTWVzc2FnZShtc2cpIHtcbiAgICAgICAgbGV0IGFwaSA9IE5lby5tYW5hZ2VyLnJwYy5BcGkuZ2V0KGAke21zZy5zZXJ2aWNlfS4ke21zZy5tZXRob2R9YCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXNbYG9uTWVzc2FnZSR7TmVvLmNhcGl0YWxpemUoYXBpLnR5cGUpfWBdKG1zZywgYXBpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtc2dcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXBpXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgb25NZXNzYWdlQWpheChtc2csIGFwaSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbGV0IG1lICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgdXJsID0gYXBpLnVybDtcblxuICAgICAgICAgICAgbWUucmVnaXN0ZXIoe1xuICAgICAgICAgICAgICAgIGlkICAgICAgICAgICA6IG1lLm1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgICBtZXRob2QgICAgICAgOiBtc2cubWV0aG9kLFxuICAgICAgICAgICAgICAgIHBhcmFtcyAgICAgICA6IG1zZy5wYXJhbXMsXG4gICAgICAgICAgICAgICAgcmVqZWN0LFxuICAgICAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICAgICAgc2VydmljZSAgICAgIDogbXNnLnNlcnZpY2UsXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25JZDogMCxcbiAgICAgICAgICAgICAgICB1cmxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS5tZXNzYWdlSWQrKztcblxuICAgICAgICAgICAgaWYgKCFtZS5lbmRQb2ludFRpbWVvdXRzLmluY2x1ZGVzKHVybCkpIHtcbiAgICAgICAgICAgICAgICBtZS5lbmRQb2ludFRpbWVvdXRzLnB1c2godXJsKTtcblxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBtZS5yZXNvbHZlQnVmZmVyVGltZW91dCh1cmwpO1xuICAgICAgICAgICAgICAgIH0sIG1lLnJlcXVlc3RCdWZmZXIpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1zZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcGlcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBhc3luYyBvbk1lc3NhZ2VXZWJzb2NrZXQobXNnLCBhcGkpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgdXJsICAgICAgICA9IGFwaS51cmwsXG4gICAgICAgICAgICBjb25uZWN0aW9uID0gbWUuc29ja2V0Q29ubmVjdGlvbnNbdXJsXTtcblxuICAgICAgICBpZiAoIWNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIGxldCBtb2R1bGUgPSBhd2FpdCBpbXBvcnQoJy4uLy4uL2RhdGEvY29ubmVjdGlvbi9XZWJTb2NrZXQubWpzJyk7XG5cbiAgICAgICAgICAgIG1lLnNvY2tldENvbm5lY3Rpb25zW3VybF0gPSBjb25uZWN0aW9uID0gTmVvLmNyZWF0ZShtb2R1bGUuZGVmYXVsdCwge3NlcnZlckFkZHJlc3M6IHVybH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IGNvbm5lY3Rpb24ucHJvbWlzZU1lc3NhZ2UobXNnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gICAgICovXG4gICAgYXN5bmMgcmVzb2x2ZUJ1ZmZlclRpbWVvdXQodXJsKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW1JZHMgICAgICAgPSBbXSxcbiAgICAgICAgICAgIHByb2Nlc3NJdGVtcyAgPSBtZS5maW5kKHt0cmFuc2FjdGlvbklkOiAwLCB1cmx9KSxcbiAgICAgICAgICAgIHJlcXVlc3RzICAgICAgPSBbXSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSWQgPSBtZS50cmFuc2FjdGlvbklkLFxuICAgICAgICAgICAgcmVzcG9uc2U7XG5cbiAgICAgICAgcHJvY2Vzc0l0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpdGVtLnRyYW5zYWN0aW9uSWQgPSB0cmFuc2FjdGlvbklkO1xuXG4gICAgICAgICAgICBpdGVtSWRzLnB1c2goaXRlbS5pZCk7XG5cbiAgICAgICAgICAgIHJlcXVlc3RzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkICAgICA6IGl0ZW0uaWQsXG4gICAgICAgICAgICAgICAgbWV0aG9kIDogaXRlbS5tZXRob2QsXG4gICAgICAgICAgICAgICAgcGFyYW1zIDogaXRlbS5wYXJhbXMsXG4gICAgICAgICAgICAgICAgc2VydmljZTogaXRlbS5zZXJ2aWNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgTmVvQXJyYXkucmVtb3ZlKG1lLmVuZFBvaW50VGltZW91dHMsIHVybCk7XG5cbiAgICAgICAgbWUudHJhbnNhY3Rpb25JZCsrO1xuXG4gICAgICAgIHJlc3BvbnNlID0gYXdhaXQgTmVvLkZldGNoLnJlcXVlc3QodXJsLCB7fSwgJ3Bvc3QnLCBKU09OLnN0cmluZ2lmeSh7dGlkOiB0cmFuc2FjdGlvbklkLCByZXF1ZXN0c30pKTtcblxuICAgICAgICBwcm9jZXNzSXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIC8vIHRvZG86IHBhc3MgdGhlIGl0ZW0gd2hpY2ggaXMgaW5jbHVkZWQgaW5zaWRlIHRoZSByZXNwb25zZSBvYmplY3RcbiAgICAgICAgICAgIC8vIHRvZG86IHJlamVjdCB0aGUgUHJvbWlzZSBpbiBjYXNlIHRoZSBpdGVtIGlzIG1pc3NpbmdcblxuICAgICAgICAgICAgaXRlbS5yZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHRvZG86IHJlbW92ZSBvbmx5IHRoZSBpdGVtcyB3aGljaCBhcmUgaW5jbHVkZWQgaW5zaWRlIHRoZSByZXNwb25zZVxuICAgICAgICBtZS5yZW1vdmUoaXRlbUlkcyk7XG4gICAgfVxufVxuXG5OZW8uYXBwbHlDbGFzc0NvbmZpZyhNZXNzYWdlKTtcblxubGV0IGluc3RhbmNlID0gTmVvLmNyZWF0ZShNZXNzYWdlKTtcblxuTmVvLmFwcGx5VG9HbG9iYWxOcyhpbnN0YW5jZSk7XG5cbmV4cG9ydCBkZWZhdWx0IGluc3RhbmNlO1xuIiwiaW1wb3J0IEJhc2UgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby51dGlsLkFycmF5XG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIE5lb0FycmF5IGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGdldENvbmZpZygpIHtyZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby51dGlsLkFycmF5J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8udXRpbC5BcnJheSdcbiAgICB9fVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBpdGVtIG9yIEFycmF5IG9mIGl0ZW1zIHRvIGFuIGFycmF5IGluIGNhc2UgaXQgZG9lcyBub3QgYWxyZWFkeSBleGlzdC5cbiAgICAgKiBPbmx5IHByaW1pdGl2ZSBpdGVtcyB3aWxsIGdldCBmb3VuZCBhcyBkdXBsaWNhdGVzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAgICogQHBhcmFtIHsqfSBpdGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBhZGQoYXJyLCBpdGVtcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgICAgICBpdGVtcyA9IFtpdGVtc107XG4gICAgICAgIH1cblxuICAgICAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaWYgKCFhcnIuaW5jbHVkZXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBhcnIucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBpdGVtcyB3aGljaCBhcmUgcHJlc2VudCBpbiBhcnJheTEsIGJ1dCBub3QgaW4gYXJyYXkyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkxPVtdXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkyPVtdXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIHN0YXRpYyBkaWZmZXJlbmNlKGFycmF5MT1bXSwgYXJyYXkyPVtdKSB7XG4gICAgICAgIHJldHVybiBhcnJheTEuZmlsdGVyKGl0ZW0gPT4gIWFycmF5Mi5pbmNsdWRlcyhpdGVtKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBpdGVtIGlzIGluY2x1ZGVkIGJ5IHJlZmVyZW5jZSBpbnNpZGUgdGhlIGFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAgICogQHBhcmFtIHsqfSBpdGVtXG4gICAgICovXG4gICAgc3RhdGljIGhhc0l0ZW0oYXJyLCBpdGVtKSB7XG4gICAgICAgIHJldHVybiBhcnIuaW5jbHVkZXMoaXRlbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBpdGVtcyB3aGljaCBhcmUgcHJlc2VudCBpbiBhcnJheTEgYW5kIGFycmF5MlxuICAgICAqIE9ubHkgc3VwcG9ydHMgcHJpbWl0aXZlIGl0ZW1zXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkxPVtdXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkyPVtdXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIHN0YXRpYyBpbnRlcnNlY3Rpb24oYXJyYXkxPVtdLCBhcnJheTI9W10pIHtcbiAgICAgICAgcmV0dXJuIGFycmF5MS5maWx0ZXIoaXRlbSA9PiBhcnJheTIuaW5jbHVkZXMoaXRlbSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGFuIGl0ZW0gaW5zaWRlIGFyciBmcm9tIGZyb21JbmRleCB0byB0b0luZGV4XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZyb21JbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0b0luZGV4XG4gICAgICovXG4gICAgc3RhdGljIG1vdmUoYXJyLCBmcm9tSW5kZXgsIHRvSW5kZXgpIHtcbiAgICAgICAgaWYgKGZyb21JbmRleCA9PT0gdG9JbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmcm9tSW5kZXggPj0gYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgZnJvbUluZGV4ID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cblxuICAgICAgICBhcnIuc3BsaWNlKHRvSW5kZXgsIDAsIGFyci5zcGxpY2UoZnJvbUluZGV4LCAxKVswXSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbiBpdGVtIG9yIGFycmF5IG9mIGl0ZW1zIGZyb20gYW4gYXJyYXkuIE9ubHkgcHJpbWl0aXZlIGl0ZW1zIHdpbGwgZ2V0IGZvdW5kXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAgICogQHBhcmFtIHsqfSBpdGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyByZW1vdmUoYXJyLCBpdGVtcykge1xuICAgICAgICBsZXQgaW5kZXg7XG5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICAgICAgaXRlbXMgPSBbaXRlbXNdO1xuICAgICAgICB9XG5cbiAgICAgICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XG5cbiAgICAgICAgICAgIGluZGV4ID4gLTEgJiYgYXJyLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCB0byBjb21iaW5lIGFkZCAmIHJlbW92ZSBpbiBvbmUgY2FsbC5cbiAgICAgKiBZb3UgY2FuIHBhc3Mgc2luZ2xlIGl0ZW1zIG9yIGFuIGFycmF5IG9mIGl0ZW1zIHRvIGFkZCBvciB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAgICogQHBhcmFtIHsqfSByZW1vdmVJdGVtc1xuICAgICAqIEBwYXJhbSB7Kn0gYWRkSXRlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgcmVtb3ZlQWRkKGFyciwgcmVtb3ZlSXRlbXMsIGFkZEl0ZW1zKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKGFyciwgcmVtb3ZlSXRlbXMpO1xuICAgICAgICB0aGlzLmFkZChhcnIsIGFkZEl0ZW1zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSBhbiBhcnJheSBpbiBjYXNlIGl0IGRvZXMgZXhpc3QsIG90aGVyd2lzZSBhZGRzIGl0XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAgICogQHBhcmFtIHsqfSBpdGVtXG4gICAgICovXG4gICAgc3RhdGljIHRvZ2dsZShhcnIsIGl0ZW0pIHtcbiAgICAgICAgdGhpc1t0aGlzLmhhc0l0ZW0oYXJyLCBpdGVtKSA/ICdyZW1vdmUnIDogJ2FkZCddKGFyciwgaXRlbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBpdGVtcyB3aGljaCBhcmUgcHJlc2VudCBpbiBhcnJheTEgYW5kIGFycmF5MlxuICAgICAqIE9ubHkgc3VwcG9ydHMgcHJpbWl0aXZlIGl0ZW1zXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkxXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkyXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIHN0YXRpYyB1bmlvbihhcnJheTEsIGFycmF5Mikge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW10sXG4gICAgICAgICAgICBtZXJnZSAgPSBhcnJheTEuY29uY2F0KGFycmF5MiksXG4gICAgICAgICAgICBsZW4gICAgPSBtZXJnZS5sZW5ndGgsXG4gICAgICAgICAgICBhc3NvYyAgPSB7fSxcbiAgICAgICAgICAgIGl0ZW07XG5cbiAgICAgICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICAgICAgICBpdGVtID0gbWVyZ2VbbGVuXTtcblxuICAgICAgICAgICAgaWYgKCFhc3NvY1tpdGVtXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC51bnNoaWZ0KGl0ZW0pO1xuICAgICAgICAgICAgICAgIGFzc29jW2l0ZW1dID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBpdGVtIG9yIEFycmF5IG9mIGl0ZW1zIHRvIGFuIGFycmF5IGluIGNhc2UgaXQgZG9lcyBub3QgYWxyZWFkeSBleGlzdC5cbiAgICAgKiBPbmx5IHByaW1pdGl2ZSBpdGVtcyB3aWxsIGdldCBmb3VuZCBhcyBkdXBsaWNhdGVzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAgICogQHBhcmFtIHsqfSBpdGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyB1bnNoaWZ0KGFyciwgaXRlbXMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICAgICAgaXRlbXMgPSBbaXRlbXNdO1xuICAgICAgICB9XG5cbiAgICAgICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGlmICghYXJyLmluY2x1ZGVzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgYXJyLnVuc2hpZnQoaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuTmVvLmFwcGx5Q2xhc3NDb25maWcoTmVvQXJyYXkpO1xuXG5leHBvcnQgZGVmYXVsdCBOZW9BcnJheTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==