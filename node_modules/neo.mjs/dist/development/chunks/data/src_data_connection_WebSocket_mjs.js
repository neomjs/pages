"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["src_data_connection_WebSocket_mjs"],{

/***/ "./src/data/connection/WebSocket.mjs"
/*!*******************************************!*\
  !*** ./src/data/connection/WebSocket.mjs ***!
  \*******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Function.mjs */ "./src/util/Function.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/Observable.mjs */ "./src/core/Observable.mjs");




/**
 * @class Neo.data.connection.WebSocket
 * @extends Neo.core.Base
 * @mixes Neo.core.Observable
 */
class Socket extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.data.connection.WebSocket'
         * @protected
         */
        className: 'Neo.data.connection.WebSocket',
        /**
         * @member {String} ntype='socket-connection'
         * @protected
         */
        ntype: 'socket-connection',
        /**
         * @member {Function} backoffStrategy=attempt=>Math.min(1000*Math.pow(2,attempt-1),30000)
         */
        backoffStrategy: attempt => Math.min(1000 * Math.pow(2, attempt - 1), 30000),
        /**
         * @member {WebSocket|null} socket_=null
         * @protected
         * @reactive
         */
        socket_: null
    }

    /**
     * @member {String|null} channel=null
     */
    channel = null
    /**
     * @member {Number} maxReconnectAttempts=5
     */
    maxReconnectAttempts = 5
    /**
     * @member {Object} messageCallbacks={}
     * @protected
     */
    messageCallbacks = {}
    /**
     * @member {Number} messageId=1
     * @protected
     */
    messageId = 1
    /**
     * @member {Number} reconnectAttempts=0
     * @protected
     */
    reconnectAttempts = 0
    /**
     * @member {String|null} serverAddress=null
     */
    serverAddress = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);
        this.createSocket()
    }

    /**
     * @param {Function} callback
     * @param {Object} scope
     */
    async attemptReconnect(callback, scope) {
        let me = this;

        me.reconnectAttempts++;

        if (me.reconnectAttempts < me.maxReconnectAttempts) {
            const delay = me.backoffStrategy(me.reconnectAttempts);

            me.fire('reconnecting', {
                attempt    : me.reconnectAttempts,
                maxAttempts: me.maxReconnectAttempts,
                delay
            });

            console.log(`WebSocket reconnect attempt ${me.reconnectAttempts}/${me.maxReconnectAttempts} in ${delay}ms`);

            await me.timeout(delay);

            if (!me.isDestroyed) {
                me.createSocket();

                callback && me.on('open', {
                    callback,
                    scope : scope || me,
                    single: true
                })
            }
        } else {
            console.error('Max reconnection attempts reached');
            me.fire('reconnect_failed')
        }
    }

    /**
     * Intercepts the WebSocket send calls
     * @param {Object} data
     * @returns {String}
     */
    beforeSend(data) {
        let me        = this,
            {channel} = me;

        return JSON.stringify(channel ? {channel, data} : data)
    }

    /**
     * Triggered before the socket config gets changed.
     * @param {WebSocket|null} value
     * @param {WebSocket|null} oldValue
     * @returns {WebSocket|null}
     * @protected
     */
    beforeSetSocket(value, oldValue) {
        if (value) {
            let me = this;

            Object.assign(value, {
                onclose  : me.onClose  .bind(me),
                onerror  : me.onError  .bind(me),
                onmessage: me.onMessage.bind(me),
                onopen   : me.onOpen   .bind(me)
            });

            (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__.createInterceptor)(value, 'send', me.beforeSend, me)
        }

        return value
    }

    /**
     * @param {Number} [code] defaults to 1000
     * @param {String} [reason]
     */
    close(code, reason) {
        this.socket.close(code, reason)
    }

    /**
     *
     */
    createSocket() {
        this.socket = new WebSocket(this.serverAddress)
    }

    /**
     *
     */
    destroy(...args) {
        this.close();
        super.destroy(...args)
    }

    /**
     * @param {CloseEvent} event The Websocket generated CloseEvent
     * @param {Number}     event.code The WebSocket connection close code provided by the server
     *
     *        Code        Name                  Description
     *        0-999                             Reserved and not used.
     *        1000        CLOSE_NORMAL          Normal closure; the connection successfully completed whatever purpose for which it was created.
     *        1001        CLOSE_GOING_AWAY      The endpoint is going away, either because of a server failure or because the browser is navigating away from the page that opened the connection.
     *        1002        CLOSE_PROTOCOL_ERROR  The endpoint is terminating the connection due to a protocol error.
     *        1003        CLOSE_UNSUPPORTED     The connection is being terminated because the endpoint received data of a type it cannot accept (for example, a text-only endpoint received binary data).
     *        1004        CLOSE_TOO_LARGE       The endpoint is terminating the connection because a data frame was received that is too large.
     *        1005        CLOSE_NO_STATUS       Reserved.  Indicates that no status code was provided even though one was expected.
     *        1006        CLOSE_ABNORMAL        Reserved. Used to indicate that a connection was closed abnormally (that is, with no close frame being sent) when a status code is expected.
     *        1007-1999                         Reserved for future use by the WebSocket standard.
     *        2000-2999                         Reserved for use by WebSocket extensions.
     *        3000-3999                         Available for use by libraries and frameworks. May not be used by applications.
     *        4000-4999                         Available for use by applications.
     *
     * @param {String}     reason A string indicating the reason the server closed the connection. This is specific to the particular server and sub-protocol.
     * @param {Boolean}    wasClean Indicates whether or not the connection was cleanly closed.
     */
    onClose(event, reason, wasClean) {
        this.fire('close', {event, reason, wasClean});

        // Auto-reconnect on abnormal closure
        if (!wasClean || event.code !== 1000) {
            console.warn('WebSocket closed abnormally, attempting reconnect...');
            this.attemptReconnect()
        }
    }

    /**
     *
     */
    onError(error) {
        this.fire('error', {error})
    }

    /**
     * @param {MessageEvent} event
     */
    onMessage(event) {
        let me   = this,
            data = JSON.parse(event.data);

        me.fire('message', {data});

        if (data.mId) {
            me.messageCallbacks[data.mId].resolve(data.data);
            delete me.messageCallbacks[data.mId]
        }
    }

    /**
     *
     */
    onOpen() {
        this.reconnectAttempts = 0;
        this.fire('open', {scope: this})
    }

    /**
     * @param {Object} data
     * @returns {Promise<any>}
     */
    promiseMessage(data) {
        let me = this;

        return new Promise((resolve, reject) => {
            me.messageCallbacks[me.messageId] = {reject, resolve};

            me.sendMessage({data, mId: me.messageId});
            me.messageId++
        })
    }

    /**
     * @param {Object} data
     */
    sendMessage(data) {
        let me       = this,
            {socket} = me,
            d        = data;

        // CONNECTING  0   The connection is not yet open.
        // OPEN        1   The connection is open and ready to communicate.
        // CLOSING     2   The connection is in the process of closing.
        // CLOSED      3   The connection is closed or couldn't be opened.

        // If socket is not yet ready let's defer to open then resend
        switch (socket.readyState) {
            case WebSocket.CLOSED:
            case WebSocket.CLOSING:
                me.attemptReconnect(function() {
                    me.sendMessage(d);
                });
                break;
            case WebSocket.CONNECTING:
                me.on('open', function() {
                    me.sendMessage(d)
                }, me, {once: true});
                break;
            case WebSocket.OPEN:
                socket.send(data);
                break;
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Socket));


/***/ }

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2RhdGEvc3JjX2RhdGFfY29ubmVjdGlvbl9XZWJTb2NrZXRfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBc0Q7QUFDSTtBQUNFOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNEQUFJO0FBQ3pCO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYix1REFBdUQscUJBQXFCLEdBQUcseUJBQXlCLEtBQUssTUFBTTs7QUFFbkg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7O0FBRXRCLHlDQUF5QyxlQUFlO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQixlQUFlLGdCQUFnQjtBQUMvQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYixZQUFZLHFFQUFpQjtBQUM3Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFlBQVk7QUFDM0IsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3Qjs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQU07QUFDbEM7O0FBRUE7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLEtBQUs7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixZQUFZO0FBQ3ZDOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQ7O0FBRWpELDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPLFdBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsc0JBQXNCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2RhdGEvY29ubmVjdGlvbi9XZWJTb2NrZXQubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCYXNlICAgICAgICAgICAgICAgIGZyb20gJy4uLy4uL2NvcmUvQmFzZS5tanMnO1xuaW1wb3J0IHtjcmVhdGVJbnRlcmNlcHRvcn0gZnJvbSAnLi4vLi4vdXRpbC9GdW5jdGlvbi5tanMnO1xuaW1wb3J0IE9ic2VydmFibGUgICAgICAgICAgZnJvbSAnLi4vLi4vY29yZS9PYnNlcnZhYmxlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5kYXRhLmNvbm5lY3Rpb24uV2ViU29ja2V0XG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKiBAbWl4ZXMgTmVvLmNvcmUuT2JzZXJ2YWJsZVxuICovXG5jbGFzcyBTb2NrZXQgZXh0ZW5kcyBCYXNlIHtcbiAgICAvKipcbiAgICAgKiBUcnVlIGF1dG9tYXRpY2FsbHkgYXBwbGllcyB0aGUgY29yZS5PYnNlcnZhYmxlIG1peGluXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gb2JzZXJ2YWJsZT10cnVlXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBvYnNlcnZhYmxlID0gdHJ1ZVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZGF0YS5jb25uZWN0aW9uLldlYlNvY2tldCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmRhdGEuY29ubmVjdGlvbi5XZWJTb2NrZXQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nc29ja2V0LWNvbm5lY3Rpb24nXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnc29ja2V0LWNvbm5lY3Rpb24nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7RnVuY3Rpb259IGJhY2tvZmZTdHJhdGVneT1hdHRlbXB0PT5NYXRoLm1pbigxMDAwKk1hdGgucG93KDIsYXR0ZW1wdC0xKSwzMDAwMClcbiAgICAgICAgICovXG4gICAgICAgIGJhY2tvZmZTdHJhdGVneTogYXR0ZW1wdCA9PiBNYXRoLm1pbigxMDAwICogTWF0aC5wb3coMiwgYXR0ZW1wdCAtIDEpLCAzMDAwMCksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtXZWJTb2NrZXR8bnVsbH0gc29ja2V0Xz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzb2NrZXRfOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGNoYW5uZWw9bnVsbFxuICAgICAqL1xuICAgIGNoYW5uZWwgPSBudWxsXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSBtYXhSZWNvbm5lY3RBdHRlbXB0cz01XG4gICAgICovXG4gICAgbWF4UmVjb25uZWN0QXR0ZW1wdHMgPSA1XG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBtZXNzYWdlQ2FsbGJhY2tzPXt9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG1lc3NhZ2VDYWxsYmFja3MgPSB7fVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gbWVzc2FnZUlkPTFcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgbWVzc2FnZUlkID0gMVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gcmVjb25uZWN0QXR0ZW1wdHM9MFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICByZWNvbm5lY3RBdHRlbXB0cyA9IDBcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gc2VydmVyQWRkcmVzcz1udWxsXG4gICAgICovXG4gICAgc2VydmVyQWRkcmVzcyA9IG51bGxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuICAgICAgICB0aGlzLmNyZWF0ZVNvY2tldCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2NvcGVcbiAgICAgKi9cbiAgICBhc3luYyBhdHRlbXB0UmVjb25uZWN0KGNhbGxiYWNrLCBzY29wZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnJlY29ubmVjdEF0dGVtcHRzKys7XG5cbiAgICAgICAgaWYgKG1lLnJlY29ubmVjdEF0dGVtcHRzIDwgbWUubWF4UmVjb25uZWN0QXR0ZW1wdHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlbGF5ID0gbWUuYmFja29mZlN0cmF0ZWd5KG1lLnJlY29ubmVjdEF0dGVtcHRzKTtcblxuICAgICAgICAgICAgbWUuZmlyZSgncmVjb25uZWN0aW5nJywge1xuICAgICAgICAgICAgICAgIGF0dGVtcHQgICAgOiBtZS5yZWNvbm5lY3RBdHRlbXB0cyxcbiAgICAgICAgICAgICAgICBtYXhBdHRlbXB0czogbWUubWF4UmVjb25uZWN0QXR0ZW1wdHMsXG4gICAgICAgICAgICAgICAgZGVsYXlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgV2ViU29ja2V0IHJlY29ubmVjdCBhdHRlbXB0ICR7bWUucmVjb25uZWN0QXR0ZW1wdHN9LyR7bWUubWF4UmVjb25uZWN0QXR0ZW1wdHN9IGluICR7ZGVsYXl9bXNgKTtcblxuICAgICAgICAgICAgYXdhaXQgbWUudGltZW91dChkZWxheSk7XG5cbiAgICAgICAgICAgIGlmICghbWUuaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICBtZS5jcmVhdGVTb2NrZXQoKTtcblxuICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIG1lLm9uKCdvcGVuJywge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUgOiBzY29wZSB8fCBtZSxcbiAgICAgICAgICAgICAgICAgICAgc2luZ2xlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ01heCByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgcmVhY2hlZCcpO1xuICAgICAgICAgICAgbWUuZmlyZSgncmVjb25uZWN0X2ZhaWxlZCcpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcmNlcHRzIHRoZSBXZWJTb2NrZXQgc2VuZCBjYWxsc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBiZWZvcmVTZW5kKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2hhbm5lbH0gPSBtZTtcblxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoY2hhbm5lbCA/IHtjaGFubmVsLCBkYXRhfSA6IGRhdGEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgc29ja2V0IGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtXZWJTb2NrZXR8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1dlYlNvY2tldHxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtXZWJTb2NrZXR8bnVsbH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0U29ja2V0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odmFsdWUsIHtcbiAgICAgICAgICAgICAgICBvbmNsb3NlICA6IG1lLm9uQ2xvc2UgIC5iaW5kKG1lKSxcbiAgICAgICAgICAgICAgICBvbmVycm9yICA6IG1lLm9uRXJyb3IgIC5iaW5kKG1lKSxcbiAgICAgICAgICAgICAgICBvbm1lc3NhZ2U6IG1lLm9uTWVzc2FnZS5iaW5kKG1lKSxcbiAgICAgICAgICAgICAgICBvbm9wZW4gICA6IG1lLm9uT3BlbiAgIC5iaW5kKG1lKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNyZWF0ZUludGVyY2VwdG9yKHZhbHVlLCAnc2VuZCcsIG1lLmJlZm9yZVNlbmQsIG1lKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb2RlXSBkZWZhdWx0cyB0byAxMDAwXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtyZWFzb25dXG4gICAgICovXG4gICAgY2xvc2UoY29kZSwgcmVhc29uKSB7XG4gICAgICAgIHRoaXMuc29ja2V0LmNsb3NlKGNvZGUsIHJlYXNvbilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGNyZWF0ZVNvY2tldCgpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQgPSBuZXcgV2ViU29ja2V0KHRoaXMuc2VydmVyQWRkcmVzcylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGRlc3Ryb3koLi4uYXJncykge1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koLi4uYXJncylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Nsb3NlRXZlbnR9IGV2ZW50IFRoZSBXZWJzb2NrZXQgZ2VuZXJhdGVkIENsb3NlRXZlbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gICAgIGV2ZW50LmNvZGUgVGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGNsb3NlIGNvZGUgcHJvdmlkZWQgYnkgdGhlIHNlcnZlclxuICAgICAqXG4gICAgICogICAgICAgIENvZGUgICAgICAgIE5hbWUgICAgICAgICAgICAgICAgICBEZXNjcmlwdGlvblxuICAgICAqICAgICAgICAwLTk5OSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVzZXJ2ZWQgYW5kIG5vdCB1c2VkLlxuICAgICAqICAgICAgICAxMDAwICAgICAgICBDTE9TRV9OT1JNQUwgICAgICAgICAgTm9ybWFsIGNsb3N1cmU7IHRoZSBjb25uZWN0aW9uIHN1Y2Nlc3NmdWxseSBjb21wbGV0ZWQgd2hhdGV2ZXIgcHVycG9zZSBmb3Igd2hpY2ggaXQgd2FzIGNyZWF0ZWQuXG4gICAgICogICAgICAgIDEwMDEgICAgICAgIENMT1NFX0dPSU5HX0FXQVkgICAgICBUaGUgZW5kcG9pbnQgaXMgZ29pbmcgYXdheSwgZWl0aGVyIGJlY2F1c2Ugb2YgYSBzZXJ2ZXIgZmFpbHVyZSBvciBiZWNhdXNlIHRoZSBicm93c2VyIGlzIG5hdmlnYXRpbmcgYXdheSBmcm9tIHRoZSBwYWdlIHRoYXQgb3BlbmVkIHRoZSBjb25uZWN0aW9uLlxuICAgICAqICAgICAgICAxMDAyICAgICAgICBDTE9TRV9QUk9UT0NPTF9FUlJPUiAgVGhlIGVuZHBvaW50IGlzIHRlcm1pbmF0aW5nIHRoZSBjb25uZWN0aW9uIGR1ZSB0byBhIHByb3RvY29sIGVycm9yLlxuICAgICAqICAgICAgICAxMDAzICAgICAgICBDTE9TRV9VTlNVUFBPUlRFRCAgICAgVGhlIGNvbm5lY3Rpb24gaXMgYmVpbmcgdGVybWluYXRlZCBiZWNhdXNlIHRoZSBlbmRwb2ludCByZWNlaXZlZCBkYXRhIG9mIGEgdHlwZSBpdCBjYW5ub3QgYWNjZXB0IChmb3IgZXhhbXBsZSwgYSB0ZXh0LW9ubHkgZW5kcG9pbnQgcmVjZWl2ZWQgYmluYXJ5IGRhdGEpLlxuICAgICAqICAgICAgICAxMDA0ICAgICAgICBDTE9TRV9UT09fTEFSR0UgICAgICAgVGhlIGVuZHBvaW50IGlzIHRlcm1pbmF0aW5nIHRoZSBjb25uZWN0aW9uIGJlY2F1c2UgYSBkYXRhIGZyYW1lIHdhcyByZWNlaXZlZCB0aGF0IGlzIHRvbyBsYXJnZS5cbiAgICAgKiAgICAgICAgMTAwNSAgICAgICAgQ0xPU0VfTk9fU1RBVFVTICAgICAgIFJlc2VydmVkLiAgSW5kaWNhdGVzIHRoYXQgbm8gc3RhdHVzIGNvZGUgd2FzIHByb3ZpZGVkIGV2ZW4gdGhvdWdoIG9uZSB3YXMgZXhwZWN0ZWQuXG4gICAgICogICAgICAgIDEwMDYgICAgICAgIENMT1NFX0FCTk9STUFMICAgICAgICBSZXNlcnZlZC4gVXNlZCB0byBpbmRpY2F0ZSB0aGF0IGEgY29ubmVjdGlvbiB3YXMgY2xvc2VkIGFibm9ybWFsbHkgKHRoYXQgaXMsIHdpdGggbm8gY2xvc2UgZnJhbWUgYmVpbmcgc2VudCkgd2hlbiBhIHN0YXR1cyBjb2RlIGlzIGV4cGVjdGVkLlxuICAgICAqICAgICAgICAxMDA3LTE5OTkgICAgICAgICAgICAgICAgICAgICAgICAgUmVzZXJ2ZWQgZm9yIGZ1dHVyZSB1c2UgYnkgdGhlIFdlYlNvY2tldCBzdGFuZGFyZC5cbiAgICAgKiAgICAgICAgMjAwMC0yOTk5ICAgICAgICAgICAgICAgICAgICAgICAgIFJlc2VydmVkIGZvciB1c2UgYnkgV2ViU29ja2V0IGV4dGVuc2lvbnMuXG4gICAgICogICAgICAgIDMwMDAtMzk5OSAgICAgICAgICAgICAgICAgICAgICAgICBBdmFpbGFibGUgZm9yIHVzZSBieSBsaWJyYXJpZXMgYW5kIGZyYW1ld29ya3MuIE1heSBub3QgYmUgdXNlZCBieSBhcHBsaWNhdGlvbnMuXG4gICAgICogICAgICAgIDQwMDAtNDk5OSAgICAgICAgICAgICAgICAgICAgICAgICBBdmFpbGFibGUgZm9yIHVzZSBieSBhcHBsaWNhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgIHJlYXNvbiBBIHN0cmluZyBpbmRpY2F0aW5nIHRoZSByZWFzb24gdGhlIHNlcnZlciBjbG9zZWQgdGhlIGNvbm5lY3Rpb24uIFRoaXMgaXMgc3BlY2lmaWMgdG8gdGhlIHBhcnRpY3VsYXIgc2VydmVyIGFuZCBzdWItcHJvdG9jb2wuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICB3YXNDbGVhbiBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdGhlIGNvbm5lY3Rpb24gd2FzIGNsZWFubHkgY2xvc2VkLlxuICAgICAqL1xuICAgIG9uQ2xvc2UoZXZlbnQsIHJlYXNvbiwgd2FzQ2xlYW4pIHtcbiAgICAgICAgdGhpcy5maXJlKCdjbG9zZScsIHtldmVudCwgcmVhc29uLCB3YXNDbGVhbn0pO1xuXG4gICAgICAgIC8vIEF1dG8tcmVjb25uZWN0IG9uIGFibm9ybWFsIGNsb3N1cmVcbiAgICAgICAgaWYgKCF3YXNDbGVhbiB8fCBldmVudC5jb2RlICE9PSAxMDAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dlYlNvY2tldCBjbG9zZWQgYWJub3JtYWxseSwgYXR0ZW1wdGluZyByZWNvbm5lY3QuLi4nKTtcbiAgICAgICAgICAgIHRoaXMuYXR0ZW1wdFJlY29ubmVjdCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5maXJlKCdlcnJvcicsIHtlcnJvcn0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtNZXNzYWdlRXZlbnR9IGV2ZW50XG4gICAgICovXG4gICAgb25NZXNzYWdlKGV2ZW50KSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuXG4gICAgICAgIG1lLmZpcmUoJ21lc3NhZ2UnLCB7ZGF0YX0pO1xuXG4gICAgICAgIGlmIChkYXRhLm1JZCkge1xuICAgICAgICAgICAgbWUubWVzc2FnZUNhbGxiYWNrc1tkYXRhLm1JZF0ucmVzb2x2ZShkYXRhLmRhdGEpO1xuICAgICAgICAgICAgZGVsZXRlIG1lLm1lc3NhZ2VDYWxsYmFja3NbZGF0YS5tSWRdXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uT3BlbigpIHtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA9IDA7XG4gICAgICAgIHRoaXMuZmlyZSgnb3BlbicsIHtzY29wZTogdGhpc30pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIHByb21pc2VNZXNzYWdlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbWUubWVzc2FnZUNhbGxiYWNrc1ttZS5tZXNzYWdlSWRdID0ge3JlamVjdCwgcmVzb2x2ZX07XG5cbiAgICAgICAgICAgIG1lLnNlbmRNZXNzYWdlKHtkYXRhLCBtSWQ6IG1lLm1lc3NhZ2VJZH0pO1xuICAgICAgICAgICAgbWUubWVzc2FnZUlkKytcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIHNlbmRNZXNzYWdlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtzb2NrZXR9ID0gbWUsXG4gICAgICAgICAgICBkICAgICAgICA9IGRhdGE7XG5cbiAgICAgICAgLy8gQ09OTkVDVElORyAgMCAgIFRoZSBjb25uZWN0aW9uIGlzIG5vdCB5ZXQgb3Blbi5cbiAgICAgICAgLy8gT1BFTiAgICAgICAgMSAgIFRoZSBjb25uZWN0aW9uIGlzIG9wZW4gYW5kIHJlYWR5IHRvIGNvbW11bmljYXRlLlxuICAgICAgICAvLyBDTE9TSU5HICAgICAyICAgVGhlIGNvbm5lY3Rpb24gaXMgaW4gdGhlIHByb2Nlc3Mgb2YgY2xvc2luZy5cbiAgICAgICAgLy8gQ0xPU0VEICAgICAgMyAgIFRoZSBjb25uZWN0aW9uIGlzIGNsb3NlZCBvciBjb3VsZG4ndCBiZSBvcGVuZWQuXG5cbiAgICAgICAgLy8gSWYgc29ja2V0IGlzIG5vdCB5ZXQgcmVhZHkgbGV0J3MgZGVmZXIgdG8gb3BlbiB0aGVuIHJlc2VuZFxuICAgICAgICBzd2l0Y2ggKHNvY2tldC5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIFdlYlNvY2tldC5DTE9TRUQ6XG4gICAgICAgICAgICBjYXNlIFdlYlNvY2tldC5DTE9TSU5HOlxuICAgICAgICAgICAgICAgIG1lLmF0dGVtcHRSZWNvbm5lY3QoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnNlbmRNZXNzYWdlKGQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBXZWJTb2NrZXQuQ09OTkVDVElORzpcbiAgICAgICAgICAgICAgICBtZS5vbignb3BlbicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBtZS5zZW5kTWVzc2FnZShkKVxuICAgICAgICAgICAgICAgIH0sIG1lLCB7b25jZTogdHJ1ZX0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBXZWJTb2NrZXQuT1BFTjpcbiAgICAgICAgICAgICAgICBzb2NrZXQuc2VuZChkYXRhKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoU29ja2V0KTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=