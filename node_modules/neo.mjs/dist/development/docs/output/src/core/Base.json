{"classData":[{"comment":"/**\n * The base class for (almost) all classes inside the Neo namespace\n * Exceptions are e.g. core.IdGenerator, vdom.VNode\n * @class Neo.core.Base\n */","meta":{"filename":"Base.mjs","lineno":13,"columnno":0,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{}},"description":"<p>The base class for (almost) all classes inside the Neo namespace\nExceptions are e.g. core.IdGenerator, vdom.VNode</p>\n","kind":"class","name":"Base","memberof":"Neo.core","longname":"Neo.core.Base","scope":"static","$longname":"Neo.core.Base","$kind":"class","id":1312,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * You can define methods which should get delayed.\n     * Types are buffer, debounce & throttle.\n     * @example\n     *  delayable: {\n     *      fireChangeEvent: {\n     *          type : 'debounce',\n     *          timer: 300\n     *      }\n     *  }\n     * @member {Object} delayable={}\n     * @protected\n     * @static\n     */","meta":{"filename":"Base.mjs","lineno":33,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{}},"description":"<p>You can define methods which should get delayed.\nTypes are buffer, debounce &amp; throttle.</p>\n","examples":["delayable: {\n     fireChangeEvent: {\n         type : 'debounce',\n         timer: 300\n     }\n }"],"kind":"member","name":"delayable","type":{"names":["Object"]},"defaultvalue":"{}","access":"protected","scope":"static","longname":"delayable","$longname":"delayable","$kind":"property","id":1313,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * Flag which will get set to true once manager.Instance got created\n     * @member {Boolean} instanceManagerAvailable=false\n     * @static\n     */","meta":{"filename":"Base.mjs","lineno":39,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{}},"description":"<p>Flag which will get set to true once manager.Instance got created</p>\n","kind":"member","name":"instanceManagerAvailable","type":{"names":["Boolean"]},"defaultvalue":false,"scope":"static","longname":"instanceManagerAvailable","$longname":"instanceManagerAvailable","$kind":"property","id":1314,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * Regex to grab the MethodName from an error\n     * which is a second generation function\n     * @member {RegExp} methodNameRegex\n     * @static\n     */","meta":{"filename":"Base.mjs","lineno":46,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{}},"description":"<p>Regex to grab the MethodName from an error\nwhich is a second generation function</p>\n","kind":"member","name":"methodNameRegex","type":{"names":["RegExp"]},"scope":"static","longname":"methodNameRegex","$longname":"methodNameRegex","$kind":"property","id":1315,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * True automatically applies the core.Observable mixin\n     * @member {Boolean} observable=false\n     * @static\n     */","meta":{"filename":"Base.mjs","lineno":52,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{}},"description":"<p>True automatically applies the core.Observable mixin</p>\n","kind":"member","name":"observable","type":{"names":["Boolean"]},"defaultvalue":false,"scope":"static","longname":"observable","$longname":"observable","$kind":"property","id":1316,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * Keep the overwritten methods\n     * @member {Object} overwrittenMethods={}\n     * @protected\n     * @static\n     */","meta":{"filename":"Base.mjs","lineno":59,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{}},"description":"<p>Keep the overwritten methods</p>\n","kind":"member","name":"overwrittenMethods","type":{"names":["Object"]},"defaultvalue":"{}","access":"protected","scope":"static","longname":"overwrittenMethods","$longname":"overwrittenMethods","$kind":"property","id":1317,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * Defines the default configuration properties for the class. These configurations are\n     * merged throughout the class hierarchy and can be overridden at the instance level.\n     *\n     * There are two main types of configs:\n     *\n     * 1.  **Reactive Configs:** Property names ending with a trailing underscore (e.g., `myConfig_`).\n     *     The framework automatically generates a public getter and setter, removing the underscore\n     *     from the property name (e.g., `this.myConfig`). This system enables powerful, optional\n     *     lifecycle hooks that are called automatically if they are implemented on the class:\n     *     - `beforeGetMyConfig(value)`: Executed before the getter returns. Can be used to dynamically modify the returned value.\n     *     - `beforeSetMyConfig(newValue, oldValue)`: Executed before a new value is set. Can be used for validation or transformation. Returning `undefined` from this hook will cancel the update.\n     *     - `afterSetMyConfig(newValue, oldValue)`: Executed after a new value has been successfully set. Ideal for triggering side effects.\n     *\n     * 2.  **Non-Reactive (Prototype-based) Configs:** Property names without a trailing underscore.\n     *     These are applied directly to the class's **prototype** during the `Neo.setupClass`\n     *     process. This is highly memory-efficient as the value is shared across all instances.\n     *     It also allows for powerful, application-wide modifications of default behaviors\n     *     by using the `Neo.overwrites` mechanism, which modifies these prototype values at\n     *     load time.\n     *\n     *     **vs. Class Fields:**\n     *     Use a non-reactive config when you want the property to be eligible for the `Neo.overwrites`\n     *     mechanism. This allows external code (like themes or application-level overrides) to change\n     *     the default value for the class, which then propagates to all subclasses and instances\n     *     globally. Use standard class fields for internal state that should not be globally reconfigured.\n     *\n     * @returns {Object} config\n     */","meta":{"range":[4214,7240],"filename":"Base.mjs","lineno":118,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{"id":"astnode100041599","name":"config","type":"ClassProperty"}},"description":"<p>Defines the default configuration properties for the class. These configurations are\nmerged throughout the class hierarchy and can be overridden at the instance level.</p>\n<p>There are two main types of configs:</p>\n<ol>\n<li><p><strong>Reactive Configs:</strong> Property names ending with a trailing underscore (e.g., <code>myConfig_</code>).\nThe framework automatically generates a public getter and setter, removing the underscore\nfrom the property name (e.g., <code>this.myConfig</code>). This system enables powerful, optional\nlifecycle hooks that are called automatically if they are implemented on the class:</p>\n<ul>\n<li><code>beforeGetMyConfig(value)</code>: Executed before the getter returns. Can be used to dynamically modify the returned value.</li>\n<li><code>beforeSetMyConfig(newValue, oldValue)</code>: Executed before a new value is set. Can be used for validation or transformation. Returning <code>undefined</code> from this hook will cancel the update.</li>\n<li><code>afterSetMyConfig(newValue, oldValue)</code>: Executed after a new value has been successfully set. Ideal for triggering side effects.</li>\n</ul>\n</li>\n<li><p><strong>Non-Reactive (Prototype-based) Configs:</strong> Property names without a trailing underscore.\nThese are applied directly to the class&#39;s <strong>prototype</strong> during the <code>Neo.setupClass</code>\nprocess. This is highly memory-efficient as the value is shared across all instances.\nIt also allows for powerful, application-wide modifications of default behaviors\nby using the <code>Neo.overwrites</code> mechanism, which modifies these prototype values at\nload time.</p>\n<p><strong>vs. Class Fields:</strong>\nUse a non-reactive config when you want the property to be eligible for the <code>Neo.overwrites</code>\nmechanism. This allows external code (like themes or application-level overrides) to change\nthe default value for the class, which then propagates to all subclasses and instances\nglobally. Use standard class fields for internal state that should not be globally reconfigured.</p>\n</li>\n</ol>\n","returns":[{"type":{"names":["Object"]},"description":"config"}],"name":"config","longname":"Base#config","kind":"member","memberof":"Base","scope":"instance","$longname":"Base#config","$kind":"property","id":1318,"neoClassName":"Neo.core.Base"},{"comment":"/**\n         * The class name which will get mapped into the Neo or app namespace\n         * @member {String} className='Neo.core.Base'\n         * @protected\n         */","meta":{"filename":"Base.mjs","lineno":95,"columnno":8,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{}},"description":"<p>The class name which will get mapped into the Neo or app namespace</p>\n","kind":"member","name":"className","type":{"names":["String"]},"defaultvalue":"'Neo.core.Base'","access":"protected","longname":"className","scope":"global","$longname":"className","$kind":"property","id":1319,"neoClassName":"Neo.core.Base"},{"comment":"/**\n         * The class shortcut-name to use for e.g. creating child components inside a JSON-format\n         * @member {String} ntype='base'\n         * @protected\n         */","meta":{"filename":"Base.mjs","lineno":101,"columnno":8,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{}},"description":"<p>The class shortcut-name to use for e.g. creating child components inside a JSON-format</p>\n","kind":"member","name":"ntype","type":{"names":["String"]},"defaultvalue":"'base'","access":"protected","longname":"ntype","scope":"global","$longname":"ntype","$kind":"property","id":1320,"neoClassName":"Neo.core.Base"},{"comment":"/**\n         * While it is recommended to change the static delayable configs on class level,\n         * you can change it on instance level too. If not null, we will do a deep merge.\n         * @member {Object} delayable=null\n         */","meta":{"filename":"Base.mjs","lineno":107,"columnno":8,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{}},"description":"<p>While it is recommended to change the static delayable configs on class level,\nyou can change it on instance level too. If not null, we will do a deep merge.</p>\n","kind":"member","name":"delayable","type":{"names":["Object"]},"defaultvalue":null,"longname":"delayable","scope":"global","$longname":"delayable","$kind":"property","id":1321,"neoClassName":"Neo.core.Base"},{"comment":"/**\n         * The unique component id\n         * @member {String|null} id_=null\n         * @reactive\n         */","meta":{"filename":"Base.mjs","lineno":113,"columnno":8,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{}},"description":"<p>The unique component id</p>\n","kind":"member","name":"id_","type":{"names":["String","null"]},"defaultvalue":null,"tags":[{"originalTitle":"reactive","title":"reactive","text":""}],"longname":"id_","scope":"global","$longname":"id_","$kind":"property","id":1322,"neoClassName":"Neo.core.Base"},{"comment":"/**\n         * An array of remote method names that should be intercepted.\n         * Names used here must be present inside the `remote_` config.\n         * If a remote call for one of these methods arrives, `onInterceptRemotes()` will be called.\n         * @member {String[]|null} interceptRemotes=null\n         * @protected\n         */","meta":{"filename":"Base.mjs","lineno":121,"columnno":8,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{}},"description":"<p>An array of remote method names that should be intercepted.\nNames used here must be present inside the <code>remote_</code> config.\nIf a remote call for one of these methods arrives, <code>onInterceptRemotes()</code> will be called.</p>\n","kind":"member","name":"interceptRemotes","type":{"names":["Array.<String>","null"]},"defaultvalue":null,"access":"protected","longname":"interceptRemotes","scope":"global","$longname":"interceptRemotes","$kind":"property","id":1323,"neoClassName":"Neo.core.Base"},{"comment":"/**\n         * Neo.create() will change this flag to true after the onConstructed() chain is done.\n         * @member {Boolean} isConstructed=false\n         * @protected\n         */","meta":{"filename":"Base.mjs","lineno":127,"columnno":8,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{}},"description":"<p>Neo.create() will change this flag to true after the onConstructed() chain is done.</p>\n","kind":"member","name":"isConstructed","type":{"names":["Boolean"]},"defaultvalue":false,"access":"protected","longname":"isConstructed","scope":"global","$longname":"isConstructed","$kind":"property","id":1324,"neoClassName":"Neo.core.Base"},{"comment":"/**\n         * This config will be set to `true` as the very first action within the `destroy()` method.\n         * Effects can observe this config to clean themselves up.\n         * @member {Boolean} isDestroying_=false\n         * @protected\n         * @reactive\n         */","meta":{"filename":"Base.mjs","lineno":135,"columnno":8,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{}},"description":"<p>This config will be set to <code>true</code> as the very first action within the <code>destroy()</code> method.\nEffects can observe this config to clean themselves up.</p>\n","kind":"member","name":"isDestroying_","type":{"names":["Boolean"]},"defaultvalue":false,"access":"protected","tags":[{"originalTitle":"reactive","title":"reactive","text":""}],"longname":"isDestroying_","scope":"global","$longname":"isDestroying_","$kind":"property","id":1325,"neoClassName":"Neo.core.Base"},{"comment":"/**\n         * The config will get set to `true` once the Promise of `async initAsync()` is resolved.\n         * You can use `afterSetIsReady()` to get notified once the ready state is reached.\n         * For observable classes, this will also fire a `ready` event.\n         * @member {Boolean} isReady_=false\n         * @reactive\n         */","meta":{"filename":"Base.mjs","lineno":143,"columnno":8,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{}},"description":"<p>The config will get set to <code>true</code> once the Promise of <code>async initAsync()</code> is resolved.\nYou can use <code>afterSetIsReady()</code> to get notified once the ready state is reached.\nFor observable classes, this will also fire a <code>ready</code> event.</p>\n","kind":"member","name":"isReady_","type":{"names":["Boolean"]},"defaultvalue":false,"tags":[{"originalTitle":"reactive","title":"reactive","text":""}],"longname":"isReady_","scope":"global","$longname":"isReady_","$kind":"property","id":1326,"neoClassName":"Neo.core.Base"},{"comment":"/**\n         * Add mixins as an array of classNames, imported modules or a mixed version\n         * @member {String[]|Neo.core.Base[]|null} mixins=null\n         */","meta":{"filename":"Base.mjs","lineno":148,"columnno":8,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{}},"description":"<p>Add mixins as an array of classNames, imported modules or a mixed version</p>\n","kind":"member","name":"mixins","type":{"names":["Array.<String>","Array.<Neo.core.Base>","null"]},"defaultvalue":null,"longname":"mixins","scope":"global","$longname":"mixins","$kind":"property","id":1327,"neoClassName":"Neo.core.Base"},{"comment":"/**\n         * You can create a new instance by passing an imported class (JS module default export)\n         * @member {Class} module=null\n         * @protected\n         */","meta":{"filename":"Base.mjs","lineno":154,"columnno":8,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{}},"description":"<p>You can create a new instance by passing an imported class (JS module default export)</p>\n","kind":"member","name":"module","type":{"names":["Class"]},"defaultvalue":null,"access":"protected","longname":"module","scope":"global","$longname":"module","$kind":"property","id":1328,"neoClassName":"Neo.core.Base"},{"comment":"/**\n         * Remote method access for other threads. Example use case:\n         * remote: {app: ['myRemoteMethod']}\n         *\n         * ONLY supported for singletons.\n         *\n         * @member {Object|null} remote_={[isDescriptor]: true, merge: 'deepArrays', value: null}\n         * @protected\n         * @reactive\n         */","meta":{"filename":"Base.mjs","lineno":165,"columnno":8,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{}},"description":"<p>Remote method access for other threads. Example use case:\nremote: {app: [&#39;myRemoteMethod&#39;]}</p>\n<p>ONLY supported for singletons.</p>\n","kind":"member","name":"remote_","type":{"names":["Object","null"]},"defaultvalue":"{[isDescriptor]: true, merge: 'deepArrays', value: null}","access":"protected","tags":[{"originalTitle":"reactive","title":"reactive","text":""}],"longname":"remote_","scope":"global","$longname":"remote_","$kind":"property","id":1329,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * A private field to store the Config controller instances.\n     * @member {Object} #configs={}\n     * @private\n     */","meta":{"filename":"Base.mjs","lineno":177,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{}},"description":"<p>A private field to store the Config controller instances.</p>\n","kind":"member","name":"#configs","type":{"names":["Object"]},"defaultvalue":"{}","access":"private","longname":"#configs","scope":"global","$longname":"#configs","$kind":"property","id":1330,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * Internal cache for all config subscription cleanup functions.\n     * @member {Function[]} #configSubscriptionCleanups=[]\n     * @private\n     */","meta":{"filename":"Base.mjs","lineno":183,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{}},"description":"<p>Internal cache for all config subscription cleanup functions.</p>\n","kind":"member","name":"#configSubscriptionCleanups","type":{"names":["Array.<function()>"]},"defaultvalue":"[]","access":"private","longname":"#configSubscriptionCleanups","scope":"global","$longname":"#configSubscriptionCleanups","$kind":"property","id":1331,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * A promise that resolves when the instance is fully initialized (after initAsync() completes).\n     * @member {Promise<void>|null} #readyPromise\n     * @private\n     */","meta":{"filename":"Base.mjs","lineno":189,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{}},"description":"<p>A promise that resolves when the instance is fully initialized (after initAsync() completes).</p>\n","kind":"member","name":"#readyPromise","type":{"names":["Promise.<void>","null"]},"access":"private","longname":"#readyPromise","scope":"global","$longname":"#readyPromise","$kind":"property","id":1332,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * A resolver function for the ready promise.\n     * @member {Function|null} #readyResolver\n     * @private\n     */","meta":{"filename":"Base.mjs","lineno":195,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{}},"description":"<p>A resolver function for the ready promise.</p>\n","kind":"member","name":"#readyResolver","type":{"names":["function","null"]},"access":"private","longname":"#readyResolver","scope":"global","$longname":"#readyResolver","$kind":"property","id":1333,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * A promise that resolves when the remote methods are registered.\n     * @member {Promise<void>|null} #remotesReadyPromise\n     * @private\n     */","meta":{"filename":"Base.mjs","lineno":201,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{}},"description":"<p>A promise that resolves when the remote methods are registered.</p>\n","kind":"member","name":"#remotesReadyPromise","type":{"names":["Promise.<void>","null"]},"access":"private","longname":"#remotesReadyPromise","scope":"global","$longname":"#remotesReadyPromise","$kind":"property","id":1334,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * A resolver function for the remotesReady promise.\n     * @member {Function|null} #remotesReadyResolver\n     * @private\n     */","meta":{"filename":"Base.mjs","lineno":207,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{}},"description":"<p>A resolver function for the remotesReady promise.</p>\n","kind":"member","name":"#remotesReadyResolver","type":{"names":["function","null"]},"access":"private","longname":"#remotesReadyResolver","scope":"global","$longname":"#remotesReadyResolver","$kind":"property","id":1335,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * Internal cache for all timeout ids when using this.timeout()\n     * @member {Number[]} timeoutIds=[]\n     * @private\n     */","meta":{"filename":"Base.mjs","lineno":213,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{}},"description":"<p>Internal cache for all timeout ids when using this.timeout()</p>\n","kind":"member","name":"timeoutIds","type":{"names":["Array.<Number>"]},"defaultvalue":"[]","access":"private","longname":"timeoutIds","scope":"global","$longname":"timeoutIds","$kind":"property","id":1336,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * The main initializer for all Neo.mjs classes, invoked by `Neo.create()`.\n     * NOTE: This is not the native `constructor()`, which is called without arguments by `Neo.create()` first.\n     *\n     * This method orchestrates the entire instance initialization process, including\n     * the setup of the powerful and flexible config system.\n     *\n     * The `config` parameter is a single object that can contain different types of properties,\n     * which are processed in a specific order to ensure consistency and predictability:\n     *\n     * 1.  **Public Class Fields & Other Properties:** Any key in the `config` object that is NOT\n     *     defined in the class's `static config` hierarchy is considered a public field or a\n     *     dynamic property. These are assigned directly to the instance (`this.myField = value`)\n     *     at the very beginning. This is crucial so that subsequent config hooks (like `afterSet*`)\n     *     can access their latest values.\n     *\n     * 2.  **Reactive Configs:** A property is considered reactive if it is defined with a trailing\n     *     underscore (e.g., `myValue_`) in the `static config` of **any class in the inheritance\n     *     chain**. Subclasses can provide new default values for these configs without the\n     *     underscore, and they will still be reactive. Their values are applied via generated\n     *     setters, triggering `beforeSet*` and `afterSet*` hooks, and they are wrapped in a\n     *     `Neo.core.Config` instance to enable subscription-based reactivity.\n     *\n     * 3.  **Non-Reactive Configs:** Properties defined in `static config` without a trailing\n     *     underscore in their entire inheritance chain. Their default values are applied directly\n     *     to the class **prototype**, making them shared across all instances and allowing for\n     *     run-time modifications (prototypal inheritance). When a new value is passed to this\n     *     method, it creates an instance-specific property that shadows the prototype value.\n     *\n     * This method also initializes the observable mixin (if applicable) and schedules asynchronous\n     * logic like `initAsync()` (which handles remote method access) to run after the synchronous\n     * construction chain is complete.\n     *\n     * @param {Object} config={} The initial configuration object for the instance.\n     */","meta":{"range":[10870,12502],"filename":"Base.mjs","lineno":250,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{"id":"astnode100041643","name":"Base#construct","type":"MethodDefinition","paramnames":["config"]},"vars":{"":null}},"description":"<p>The main initializer for all Neo.mjs classes, invoked by <code>Neo.create()</code>.\nNOTE: This is not the native <code>constructor()</code>, which is called without arguments by <code>Neo.create()</code> first.</p>\n<p>This method orchestrates the entire instance initialization process, including\nthe setup of the powerful and flexible config system.</p>\n<p>The <code>config</code> parameter is a single object that can contain different types of properties,\nwhich are processed in a specific order to ensure consistency and predictability:</p>\n<ol>\n<li><p><strong>Public Class Fields &amp; Other Properties:</strong> Any key in the <code>config</code> object that is NOT\ndefined in the class&#39;s <code>static config</code> hierarchy is considered a public field or a\ndynamic property. These are assigned directly to the instance (<code>this.myField = value</code>)\nat the very beginning. This is crucial so that subsequent config hooks (like <code>afterSet*</code>)\ncan access their latest values.</p>\n</li>\n<li><p><strong>Reactive Configs:</strong> A property is considered reactive if it is defined with a trailing\nunderscore (e.g., <code>myValue_</code>) in the <code>static config</code> of <strong>any class in the inheritance\nchain</strong>. Subclasses can provide new default values for these configs without the\nunderscore, and they will still be reactive. Their values are applied via generated\nsetters, triggering <code>beforeSet*</code> and <code>afterSet*</code> hooks, and they are wrapped in a\n<code>Neo.core.Config</code> instance to enable subscription-based reactivity.</p>\n</li>\n<li><p><strong>Non-Reactive Configs:</strong> Properties defined in <code>static config</code> without a trailing\nunderscore in their entire inheritance chain. Their default values are applied directly\nto the class <strong>prototype</strong>, making them shared across all instances and allowing for\nrun-time modifications (prototypal inheritance). When a new value is passed to this\nmethod, it creates an instance-specific property that shadows the prototype value.</p>\n</li>\n</ol>\n<p>This method also initializes the observable mixin (if applicable) and schedules asynchronous\nlogic like <code>initAsync()</code> (which handles remote method access) to run after the synchronous\nconstruction chain is complete.</p>\n","params":[{"type":{"names":["Object"]},"defaultvalue":"{}","description":"<p>The initial configuration object for the instance.</p>\n","name":"config"}],"name":"construct","longname":"Base#construct","kind":"function","memberof":"Base","scope":"instance","$longname":"Base#construct","$kind":"method","id":1337,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * Triggered after the id config got changed.\n     * You can dynamically change instance ids if needed. They need to stay unique at any given point.\n     * Use case: e.g. component based lists, where you want to re-use item instances.\n     * @param {String|null} value\n     * @param {String|null} oldValue\n     * @protected\n     */","meta":{"range":[12852,13418],"filename":"Base.mjs","lineno":312,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{"id":"astnode100041806","name":"Base#afterSetId","type":"MethodDefinition","paramnames":["value","oldValue"]},"vars":{"":null}},"description":"<p>Triggered after the id config got changed.\nYou can dynamically change instance ids if needed. They need to stay unique at any given point.\nUse case: e.g. component based lists, where you want to re-use item instances.</p>\n","params":[{"type":{"names":["String","null"]},"name":"value"},{"type":{"names":["String","null"]},"name":"oldValue"}],"access":"protected","name":"afterSetId","longname":"Base#afterSetId","kind":"function","memberof":"Base","scope":"instance","$longname":"Base#afterSetId","$kind":"method","id":1338,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * Triggered after the isReady config gets changed.\n     * Resolves the ready() promise and fires the ready event for observable classes.\n     * @param {Boolean} value\n     * @param {Boolean} oldValue\n     * @protected\n     */","meta":{"range":[13663,13947],"filename":"Base.mjs","lineno":341,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{"id":"astnode100041882","name":"Base#afterSetIsReady","type":"MethodDefinition","paramnames":["value","oldValue"]},"vars":{"":null}},"description":"<p>Triggered after the isReady config gets changed.\nResolves the ready() promise and fires the ready event for observable classes.</p>\n","params":[{"type":{"names":["Boolean"]},"name":"value"},{"type":{"names":["Boolean"]},"name":"oldValue"}],"access":"protected","name":"afterSetIsReady","longname":"Base#afterSetIsReady","kind":"function","memberof":"Base","scope":"instance","$longname":"Base#afterSetIsReady","$kind":"method","id":1339,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * Adjusts all methods inside static delayable\n     */","meta":{"range":[14020,14680],"filename":"Base.mjs","lineno":355,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{"id":"astnode100041909","name":"Base#applyDelayable","type":"MethodDefinition","paramnames":[]},"vars":{"":null}},"description":"<p>Adjusts all methods inside static delayable</p>\n","name":"applyDelayable","longname":"Base#applyDelayable","kind":"function","memberof":"Base","scope":"instance","params":[],"$longname":"Base#applyDelayable","$kind":"method","id":1340,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * This static method is called by `Neo.setupClass()` during the class creation process.\n     * It allows for modifying a class's default prototype-based configs from outside the\n     * class hierarchy, which is a powerful way to avoid boilerplate code.\n     *\n     * It looks for a matching entry in the global `Neo.overwrites` object based on the\n     * class's `className`. If found, it merges the properties from the overwrite object\n     * into the class's static `config`. This provides a powerful mechanism for theming\n     * or applying application-wide customizations to framework or library classes without\n     * needing to extend them.\n     *\n     * @example\n     * // Imagine you have hundreds of buttons in your app, and you want all of them\n     * // to have `labelPosition: 'top'` instead of the default `'left'`.\n     * // Instead of configuring each instance, you can define an overwrite.\n     *\n     * // inside an Overwrites.mjs file loaded by your app:\n     * Neo.overwrites = {\n     *     Neo: {\n     *         button: {\n     *             Base: {\n     *                 labelPosition: 'top'\n     *             }\n     *         }\n     *     }\n     * };\n     *\n     * // Now, every `Neo.button.Base` (and any class that extends it) will have this\n     * // new default value on its prototype.\n     *\n     * @param {Object} cfg The static `config` object of the class being processed.\n     * @protected\n     * @static\n     */","meta":{"range":[16144,16833],"filename":"Base.mjs","lineno":407,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{"id":"astnode100042012","name":"Base.applyOverwrites","type":"MethodDefinition","paramnames":["cfg"]},"vars":{"":null}},"description":"<p>This static method is called by <code>Neo.setupClass()</code> during the class creation process.\nIt allows for modifying a class&#39;s default prototype-based configs from outside the\nclass hierarchy, which is a powerful way to avoid boilerplate code.</p>\n<p>It looks for a matching entry in the global <code>Neo.overwrites</code> object based on the\nclass&#39;s <code>className</code>. If found, it merges the properties from the overwrite object\ninto the class&#39;s static <code>config</code>. This provides a powerful mechanism for theming\nor applying application-wide customizations to framework or library classes without\nneeding to extend them.</p>\n","examples":["// Imagine you have hundreds of buttons in your app, and you want all of them\n// to have `labelPosition: 'top'` instead of the default `'left'`.\n// Instead of configuring each instance, you can define an overwrite.\n\n// inside an Overwrites.mjs file loaded by your app:\nNeo.overwrites = {\n    Neo: {\n        button: {\n            Base: {\n                labelPosition: 'top'\n            }\n        }\n    }\n};\n\n// Now, every `Neo.button.Base` (and any class that extends it) will have this\n// new default value on its prototype."],"params":[{"type":{"names":["Object"]},"description":"<p>The static <code>config</code> object of the class being processed.</p>\n","name":"cfg"}],"access":"protected","scope":"static","name":"applyOverwrites","longname":"Base.applyOverwrites","kind":"function","memberof":"Base","$longname":"Base.applyOverwrites","$kind":"method","id":1341,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * Convenience method for beforeSet functions which test if a given value is inside a static array\n     * @param {String|Number} value\n     * @param {String|Number} oldValue\n     * @param {String} name config name\n     * @param {Array|String} [staticName=name + 's'] name of the static config array\n     * @returns {String|Number} value or oldValue\n     */","meta":{"range":[17208,17559],"filename":"Base.mjs","lineno":438,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{"id":"astnode100042081","name":"Base#beforeSetEnumValue","type":"MethodDefinition","paramnames":["value","oldValue","name","staticName"]},"vars":{"":null}},"description":"<p>Convenience method for beforeSet functions which test if a given value is inside a static array</p>\n","params":[{"type":{"names":["String","Number"]},"name":"value"},{"type":{"names":["String","Number"]},"name":"oldValue"},{"type":{"names":["String"]},"description":"<p>config name</p>\n","name":"name"},{"type":{"names":["Array","String"]},"optional":true,"defaultvalue":"name + 's'","description":"<p>name of the static config array</p>\n","name":"staticName"}],"returns":[{"type":{"names":["String","Number"]},"description":"value or oldValue"}],"name":"beforeSetEnumValue","longname":"Base#beforeSetEnumValue","kind":"function","memberof":"Base","scope":"instance","$longname":"Base#beforeSetEnumValue","$kind":"method","id":1342,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * Triggered before the remote config gets changed\n     * @param {Object|null} value\n     * @param {Object|null} oldValue\n     * @returns {Object|null}\n     * @protected\n     */","meta":{"range":[17755,18096],"filename":"Base.mjs","lineno":456,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{"id":"astnode100042132","name":"Base#beforeSetRemote","type":"MethodDefinition","paramnames":["value","oldValue"]},"vars":{"":null}},"description":"<p>Triggered before the remote config gets changed</p>\n","params":[{"type":{"names":["Object","null"]},"name":"value"},{"type":{"names":["Object","null"]},"name":"oldValue"}],"returns":[{"type":{"names":["Object","null"]}}],"access":"protected","name":"beforeSetRemote","longname":"Base#beforeSetRemote","kind":"function","memberof":"Base","scope":"instance","$longname":"Base#beforeSetRemote","$kind":"method","id":1343,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * @param {String} fn               The name of a function to find in the passed scope object.\n     * @param {Object} originName       The name of the method inside the originScope.\n     * @param {Object} scope            The scope to find the function in if it is specified as a string.\n     * @param {Object} originScope=this The scope where the function is located.\n     */","meta":{"range":[18491,18730],"filename":"Base.mjs","lineno":473,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{"id":"astnode100042165","name":"Base#bindCallback","type":"MethodDefinition","paramnames":["fn","originName","scope","originScope"]},"vars":{"":null}},"params":[{"type":{"names":["String"]},"description":"<p>The name of a function to find in the passed scope object.</p>\n","name":"fn"},{"type":{"names":["Object"]},"description":"<p>The name of the method inside the originScope.</p>\n","name":"originName"},{"type":{"names":["Object"]},"description":"<p>The scope to find the function in if it is specified as a string.</p>\n","name":"scope"},{"type":{"names":["Object"]},"defaultvalue":"this","description":"<p>The scope where the function is located.</p>\n","name":"originScope"}],"name":"bindCallback","longname":"Base#bindCallback","kind":"function","memberof":"Base","scope":"instance","$longname":"Base#bindCallback","$kind":"method","id":1344,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * From within an overwrite, a method can call a parent method, by using callOverwritten.\n     *\n     * @example\n     *    afterSetHeight(value, oldValue) {\n     *        // do the standard\n     *        this.callOverwritten(...arguments);\n     *        // do you own stuff\n     *    }\n     *\n     * We create an error to get the caller.name and then run that method on the constructor.\n     * This is based on the following error structure, e.g. afterSetHeight.\n     *\n     *     Error\n     *         at Base.callOverwritten (Base.mjs:176:21)\n     *         at Base.afterSetHeight (Overrides.mjs:19:26)\n     *\n     * @param args\n     */","meta":{"range":[19386,19612],"filename":"Base.mjs","lineno":499,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{"id":"astnode100042207","name":"Base#callOverwritten","type":"MethodDefinition","paramnames":["args"]},"vars":{"":null}},"description":"<p>From within an overwrite, a method can call a parent method, by using callOverwritten.</p>\n","examples":["afterSetHeight(value, oldValue) {\n       // do the standard\n       this.callOverwritten(...arguments);\n       // do you own stuff\n   }\n\nWe create an error to get the caller.name and then run that method on the constructor.\nThis is based on the following error structure, e.g. afterSetHeight.\n\n    Error\n        at Base.callOverwritten (Base.mjs:176:21)\n        at Base.afterSetHeight (Overrides.mjs:19:26)"],"params":[{"name":"args","variable":true}],"name":"callOverwritten","longname":"Base#callOverwritten","kind":"function","memberof":"Base","scope":"instance","$longname":"Base#callOverwritten","$kind":"method","id":1345,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * Unregisters this instance from Neo.manager.Instance\n     * and removes all object entries from this instance\n     */","meta":{"range":[19750,20678],"filename":"Base.mjs","lineno":510,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{"id":"astnode100042247","name":"Base#destroy","type":"MethodDefinition","paramnames":[]},"vars":{"":null}},"description":"<p>Unregisters this instance from Neo.manager.Instance\nand removes all object entries from this instance</p>\n","name":"destroy","longname":"Base#destroy","kind":"function","memberof":"Base","scope":"instance","params":[],"$longname":"Base#destroy","$kind":"method","id":1346,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * A public method to access the underlying Config controller.\n     * This enables advanced interactions like subscriptions.\n     * @param {String} key The name of the config property (e.g., 'items').\n     * @returns {Config|undefined} The Config instance, or undefined if not found.\n     */","meta":{"range":[20988,21213],"filename":"Base.mjs","lineno":550,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{"id":"astnode100042374","name":"Base#getConfig","type":"MethodDefinition","paramnames":["key"]},"vars":{"":null}},"description":"<p>A public method to access the underlying Config controller.\nThis enables advanced interactions like subscriptions.</p>\n","params":[{"type":{"names":["String"]},"description":"<p>The name of the config property (e.g., &#39;items&#39;).</p>\n","name":"key"}],"returns":[{"type":{"names":["Config","undefined"]},"description":"The Config instance, or undefined if not found."}],"name":"getConfig","longname":"Base#getConfig","kind":"function","memberof":"Base","scope":"instance","$longname":"Base#getConfig","$kind":"method","id":1347,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * Used inside createId() as the default value passed to the IdGenerator.\n     * Override this method as needed.\n     * @returns {String}\n     */","meta":{"range":[21377,21421],"filename":"Base.mjs","lineno":565,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{"id":"astnode100042416","name":"Base#getIdKey","type":"MethodDefinition","paramnames":[]},"vars":{"":null}},"description":"<p>Used inside createId() as the default value passed to the IdGenerator.\nOverride this method as needed.</p>\n","returns":[{"type":{"names":["String"]}}],"name":"getIdKey","longname":"Base#getIdKey","kind":"function","memberof":"Base","scope":"instance","params":[],"$longname":"Base#getIdKey","$kind":"method","id":1348,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * Returns the value of a static config key or the staticConfig object itself in case no value is set\n     * @param {String} key The key of a staticConfig defined inside static getStaticConfig\n     * @returns {*}\n     */","meta":{"range":[21660,21725],"filename":"Base.mjs","lineno":574,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{"id":"astnode100042424","name":"Base#getStaticConfig","type":"MethodDefinition","paramnames":["key"]},"vars":{"":null}},"description":"<p>Returns the value of a static config key or the staticConfig object itself in case no value is set</p>\n","params":[{"type":{"names":["String"]},"description":"<p>The key of a staticConfig defined inside static getStaticConfig</p>\n","name":"key"}],"returns":[{"type":{"names":["*"]}}],"name":"getStaticConfig","longname":"Base#getStaticConfig","kind":"function","memberof":"Base","scope":"instance","$longname":"Base#getStaticConfig","$kind":"method","id":1349,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * Check if a given ntype exists inside the proto chain, including the top level class\n     * @param {String} ntype\n     * @returns {Boolean}\n     */","meta":{"range":[21893,21975],"filename":"Base.mjs","lineno":583,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{"id":"astnode100042435","name":"Base#hasNtype","type":"MethodDefinition","paramnames":["ntype"]},"vars":{"":null}},"description":"<p>Check if a given ntype exists inside the proto chain, including the top level class</p>\n","params":[{"type":{"names":["String"]},"name":"ntype"}],"returns":[{"type":{"names":["Boolean"]}}],"name":"hasNtype","longname":"Base#hasNtype","kind":"function","memberof":"Base","scope":"instance","$longname":"Base#hasNtype","$kind":"method","id":1350,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * Gets triggered after onConstructed() is done\n     */","meta":{"range":[22049,22058],"filename":"Base.mjs","lineno":590,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{"id":"astnode100042450","name":"Base#init","type":"MethodDefinition","paramnames":[]},"vars":{"":null}},"description":"<p>Gets triggered after onConstructed() is done</p>\n","name":"init","longname":"Base#init","kind":"function","memberof":"Base","scope":"instance","params":[],"$longname":"Base#init","$kind":"method","id":1351,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * You can use this method in subclasses to perform asynchronous initialization logic.\n     * Make sure to use the parent call `await super.initAsync()` at the beginning of their implementations,\n     * or the registration of remote methods will get delayed.\n     *\n     * A common use case is requiring conditional or optional dynamic imports or fetching initial data.\n     *\n     * Once the promise returned by this method is fulfilled, the `isReady` config will be set to `true`.\n     * @returns {Promise<void>} A promise that resolves when the asynchronous initialization is complete.\n     */","meta":{"range":[22673,22809],"filename":"Base.mjs","lineno":602,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{"id":"astnode100042454","name":"Base#initAsync","type":"MethodDefinition","paramnames":[]},"vars":{"":null}},"description":"<p>You can use this method in subclasses to perform asynchronous initialization logic.\nMake sure to use the parent call <code>await super.initAsync()</code> at the beginning of their implementations,\nor the registration of remote methods will get delayed.</p>\n<p>A common use case is requiring conditional or optional dynamic imports or fetching initial data.</p>\n<p>Once the promise returned by this method is fulfilled, the <code>isReady</code> config will be set to <code>true</code>.</p>\n","returns":[{"type":{"names":["Promise.<void>"]},"description":"A promise that resolves when the asynchronous initialization is complete."}],"name":"initAsync","longname":"Base#initAsync","kind":"function","memberof":"Base","scope":"instance","params":[],"async":true,"$longname":"Base#initAsync","$kind":"method","id":1352,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * Applies all class configs to this instance\n     * @param {Object} config\n     * @param {Boolean} [preventOriginalConfig] True prevents the instance from getting an originalConfig property\n     * @protected\n     */","meta":{"range":[23044,23336],"filename":"Base.mjs","lineno":616,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{"id":"astnode100042475","name":"Base#initConfig","type":"MethodDefinition","paramnames":["config","preventOriginalConfig"]},"vars":{"":null}},"description":"<p>Applies all class configs to this instance</p>\n","params":[{"type":{"names":["Object"]},"name":"config"},{"type":{"names":["Boolean"]},"optional":true,"description":"<p>True prevents the instance from getting an originalConfig property</p>\n","name":"preventOriginalConfig"}],"access":"protected","name":"initConfig","longname":"Base#initConfig","kind":"function","memberof":"Base","scope":"instance","$longname":"Base#initConfig","$kind":"method","id":1353,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * Does get triggered with a delay to ensure that Neo.workerId & Neo.worker.Manager are defined\n     * Remote method access via promises\n     * @protected\n     */","meta":{"range":[23517,24227],"filename":"Base.mjs","lineno":631,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{"id":"astnode100042523","name":"Base#initRemote","type":"MethodDefinition","paramnames":[]},"vars":{"":null}},"description":"<p>Does get triggered with a delay to ensure that Neo.workerId &amp; Neo.worker.Manager are defined\nRemote method access via promises</p>\n","access":"protected","name":"initRemote","longname":"Base#initRemote","kind":"function","memberof":"Base","scope":"instance","params":[],"async":true,"$longname":"Base#initRemote","$kind":"method","id":1354,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * @param {String} key\n     * @returns {Boolean}\n     */","meta":{"range":[24302,24806],"filename":"Base.mjs","lineno":656,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{"id":"astnode100042619","name":"Base#isConfig","type":"MethodDefinition","paramnames":["key"]},"vars":{"":null}},"params":[{"type":{"names":["String"]},"name":"key"}],"returns":[{"type":{"names":["Boolean"]}}],"name":"isConfig","longname":"Base#isConfig","kind":"function","memberof":"Base","scope":"instance","$longname":"Base#isConfig","$kind":"method","id":1355,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * Override this method to change the order configs are applied to this instance.\n     * @param {Object} config\n     * @param {Boolean} [preventOriginalConfig] True prevents the instance from getting an originalConfig property\n     * @returns {Object} config\n     * @protected\n     */","meta":{"range":[25109,25992],"filename":"Base.mjs","lineno":672,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{"id":"astnode100042650","name":"Base#mergeConfig","type":"MethodDefinition","paramnames":["config","preventOriginalConfig"]},"vars":{"":null}},"description":"<p>Override this method to change the order configs are applied to this instance.</p>\n","params":[{"type":{"names":["Object"]},"name":"config"},{"type":{"names":["Boolean"]},"optional":true,"description":"<p>True prevents the instance from getting an originalConfig property</p>\n","name":"preventOriginalConfig"}],"returns":[{"type":{"names":["Object"]},"description":"config"}],"access":"protected","name":"mergeConfig","longname":"Base#mergeConfig","kind":"function","memberof":"Base","scope":"instance","$longname":"Base#mergeConfig","$kind":"method","id":1356,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * Subscribes *this* instance (the subscriber) to changes of a specific config property on another instance (the publisher).\n     * Ensures automatic cleanup when *this* instance (the subscriber) is destroyed.\n     *\n     * @param {String|Neo.core.Base} publisher  - The ID of the publisher instance or the instance reference itself.\n     * @param {String}               configName - The name of the config property on the publisher to subscribe to (e.g., 'myConfig').\n     * @param {Function}             fn         - The callback function to execute when the config changes.\n     * @returns {Function} A cleanup function to manually unsubscribe if needed before this instance's destruction.\n     *\n     * @example\n     * // Subscribing to a config on another instance\n     * this.observeConfig(someOtherInstance, 'myConfig', (newValue, oldValue) => {\n     *     console.log('myConfig changed:', newValue);\n     * });\n     *\n     * // Discouraged: Self-observation. Use afterSet<ConfigName>() hooks instead.\n     * this.observeConfig(this, 'myOwnConfig', (newValue, oldValue) => {\n     *     console.log('myOwnConfig changed:', newValue);\n     * });\n     */","meta":{"range":[27169,28187],"filename":"Base.mjs","lineno":721,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{"id":"astnode100042757","name":"Base#observeConfig","type":"MethodDefinition","paramnames":["publisher","configName","fn"]},"vars":{"":null}},"description":"<p>Subscribes <em>this</em> instance (the subscriber) to changes of a specific config property on another instance (the publisher).\nEnsures automatic cleanup when <em>this</em> instance (the subscriber) is destroyed.</p>\n","params":[{"type":{"names":["String","Neo.core.Base"]},"description":"<p>The ID of the publisher instance or the instance reference itself.</p>\n","name":"publisher"},{"type":{"names":["String"]},"description":"<p>The name of the config property on the publisher to subscribe to (e.g., &#39;myConfig&#39;).</p>\n","name":"configName"},{"type":{"names":["function"]},"description":"<p>The callback function to execute when the config changes.</p>\n","name":"fn"}],"returns":[{"type":{"names":["function"]},"description":"A cleanup function to manually unsubscribe if needed before this instance's destruction."}],"examples":["// Subscribing to a config on another instance\nthis.observeConfig(someOtherInstance, 'myConfig', (newValue, oldValue) => {\n    console.log('myConfig changed:', newValue);\n});\n\n// Discouraged: Self-observation. Use afterSet<ConfigName>() hooks instead.\nthis.observeConfig(this, 'myOwnConfig', (newValue, oldValue) => {\n    console.log('myOwnConfig changed:', newValue);\n});"],"name":"observeConfig","longname":"Base#observeConfig","kind":"function","memberof":"Base","scope":"instance","$longname":"Base#observeConfig","$kind":"method","id":1357,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     *\n     */","meta":{"range":[28216,28453],"filename":"Base.mjs","lineno":754,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{"id":"astnode100042875","name":"Base#onAfterConstructed","type":"MethodDefinition","paramnames":[]},"vars":{"":null}},"name":"onAfterConstructed","longname":"Base#onAfterConstructed","kind":"function","memberof":"Base","scope":"instance","params":[],"$longname":"Base#onAfterConstructed","$kind":"method","id":1358,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * Gets triggered after all constructors are done\n     */","meta":{"range":[28529,28547],"filename":"Base.mjs","lineno":766,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{"id":"astnode100042902","name":"Base#onConstructed","type":"MethodDefinition","paramnames":[]},"vars":{"":null}},"description":"<p>Gets triggered after all constructors are done</p>\n","name":"onConstructed","longname":"Base#onConstructed","kind":"function","memberof":"Base","scope":"instance","params":[],"$longname":"Base#onConstructed","$kind":"method","id":1359,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * Placeholder method for intercepting remote calls.\n     * Subclasses can override this method to implement custom interception logic.\n     * @param {Object} msg The remote message object.\n     */","meta":{"range":[28763,28825],"filename":"Base.mjs","lineno":773,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{"id":"astnode100042906","name":"Base#onInterceptRemotes","type":"MethodDefinition","paramnames":["msg"]},"vars":{"":null}},"description":"<p>Placeholder method for intercepting remote calls.\nSubclasses can override this method to implement custom interception logic.</p>\n","params":[{"type":{"names":["Object"]},"description":"<p>The remote message object.</p>\n","name":"msg"}],"name":"onInterceptRemotes","longname":"Base#onInterceptRemotes","kind":"function","memberof":"Base","scope":"instance","$longname":"Base#onInterceptRemotes","$kind":"method","id":1360,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * Helper method to replace string-based values containing \"@config:\" with the matching config value\n     * of this instance.\n     * @param {Object|Object[]} items\n     */","meta":{"range":[29015,30530],"filename":"Base.mjs","lineno":782,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{"id":"astnode100042911","name":"Base#parseItemConfigs","type":"MethodDefinition","paramnames":["items"]},"vars":{"":null}},"description":"<p>Helper method to replace string-based values containing &quot;@config:&quot; with the matching config value\nof this instance.</p>\n","params":[{"type":{"names":["Object","Array.<Object>"]},"name":"items"}],"name":"parseItemConfigs","longname":"Base#parseItemConfigs","kind":"function","memberof":"Base","scope":"instance","$longname":"Base#parseItemConfigs","$kind":"method","id":1361,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * When using set(), configs without a trailing underscore can already be assigned,\n     * so the hasOwnProperty() check will return true\n     * @param {Boolean} [forceAssign=false]\n     * @protected\n     */","meta":{"range":[30987,31917],"filename":"Base.mjs","lineno":835,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{"id":"astnode100043098","name":"Base#processConfigs","type":"MethodDefinition","paramnames":["forceAssign"]},"vars":{"":null}},"description":"<p>When using set(), configs without a trailing underscore can already be assigned,\nso the hasOwnProperty() check will return true</p>\n","params":[{"type":{"names":["Boolean"]},"optional":true,"defaultvalue":false,"name":"forceAssign"}],"access":"protected","name":"processConfigs","longname":"Base#processConfigs","kind":"function","memberof":"Base","scope":"instance","$longname":"Base#processConfigs","$kind":"method","id":1362,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * Returns a promise that resolves when the instance is fully initialized (after initAsync).\n     * Use case: alternative way to subscribe to the ready state, especially for classes which are not observable.\n     * @example: await ChromaManager.ready();\n     * @returns {Promise<void>}\n     */","meta":{"range":[32229,32279],"filename":"Base.mjs","lineno":863,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{"id":"astnode100043172","name":"Base#ready","type":"MethodDefinition","paramnames":[]},"vars":{"":null}},"description":"<p>Returns a promise that resolves when the instance is fully initialized (after initAsync).\nUse case: alternative way to subscribe to the ready state, especially for classes which are not observable.</p>\n","tags":[{"originalTitle":"example:","title":"example:","text":"await ChromaManager.ready();","value":"await ChromaManager.ready();"}],"returns":[{"type":{"names":["Promise.<void>"]}}],"name":"ready","longname":"Base#ready","kind":"function","memberof":"Base","scope":"instance","params":[],"$longname":"Base#ready","$kind":"method","id":1363,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * Returns a promise that resolves when the remote methods are registered.\n     * @returns {Promise<void>}\n     */","meta":{"range":[32412,32475],"filename":"Base.mjs","lineno":871,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{"id":"astnode100043181","name":"Base#remotesReady","type":"MethodDefinition","paramnames":[]},"vars":{"":null}},"description":"<p>Returns a promise that resolves when the remote methods are registered.</p>\n","returns":[{"type":{"names":["Promise.<void>"]}}],"name":"remotesReady","longname":"Base#remotesReady","kind":"function","memberof":"Base","scope":"instance","params":[],"$longname":"Base#remotesReady","$kind":"method","id":1364,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * Sends remote method registration messages to other threads (workers or main-threads).\n     * This method is crucial for enabling cross-worker communication and remote method invocation\n     * for singleton instances. It ensures that methods defined in the `remote` config\n     * are properly registered in the target realm.\n     * @param {String} className - The class name of the instance sending the remote messages.\n     * @param {Object} remote    - The remote config object, specifying target threads and methods.\n     * @protected\n     * @static\n     */","meta":{"range":[33056,33587],"filename":"Base.mjs","lineno":885,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{"id":"astnode100043190","name":"Base.promiseRemotes","type":"MethodDefinition","paramnames":["className","remote"]},"vars":{"":null}},"description":"<p>Sends remote method registration messages to other threads (workers or main-threads).\nThis method is crucial for enabling cross-worker communication and remote method invocation\nfor singleton instances. It ensures that methods defined in the <code>remote</code> config\nare properly registered in the target realm.</p>\n","params":[{"type":{"names":["String"]},"description":"<p>The class name of the instance sending the remote messages.</p>\n","name":"className"},{"type":{"names":["Object"]},"description":"<p>The remote config object, specifying target threads and methods.</p>\n","name":"remote"}],"access":"protected","scope":"static","name":"promiseRemotes","longname":"Base.promiseRemotes","kind":"function","memberof":"Base","async":true,"$longname":"Base.promiseRemotes","$kind":"method","id":1365,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * Serializes a config object/array to be JSON-compatible.\n     * Use this method when a config might contain references to Neo classes (constructors)\n     * which need to be converted to their className strings for serialization.\n     * @param {Array|Object} config\n     * @returns {Array|Object}\n     */","meta":{"range":[33911,35250],"filename":"Base.mjs","lineno":908,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{"id":"astnode100043269","name":"Base#serializeConfig","type":"MethodDefinition","paramnames":["config"]},"vars":{"":null}},"description":"<p>Serializes a config object/array to be JSON-compatible.\nUse this method when a config might contain references to Neo classes (constructors)\nwhich need to be converted to their className strings for serialization.</p>\n","params":[{"type":{"names":["Array","Object"]},"name":"config"}],"returns":[{"type":{"names":["Array","Object"]}}],"name":"serializeConfig","longname":"Base#serializeConfig","kind":"function","memberof":"Base","scope":"instance","$longname":"Base#serializeConfig","$kind":"method","id":1366,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * set() accepts the following input as keys:\n     * 1. Non-reactive configs\n     * 2. Reactive configs\n     * 3. Class fields defined via value\n     * 4. Class fields defined via get() & set()\n     * 5. \"Anything else\" will get directly get assigned to the instance\n     *\n     * The logic resolves circular dependencies as good as possible and ensures that config related hooks:\n     * - beforeGet<Config>\n     * - beforeSet<Config>\n     * - afterSet<Config>\n     * can access all new values from the batch operation.\n     * @param {Object} values={}\n     */","meta":{"range":[35829,37426],"filename":"Base.mjs","lineno":970,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{"id":"astnode100043446","name":"Base#set","type":"MethodDefinition","paramnames":["values"]},"vars":{"":null}},"description":"<p>set() accepts the following input as keys:</p>\n<ol>\n<li>Non-reactive configs</li>\n<li>Reactive configs</li>\n<li>Class fields defined via value</li>\n<li>Class fields defined via get() &amp; set()</li>\n<li>&quot;Anything else&quot; will get directly get assigned to the instance</li>\n</ol>\n<p>The logic resolves circular dependencies as good as possible and ensures that config related hooks:</p>\n<ul>\n<li>beforeGet<Config></li>\n<li>beforeSet<Config></li>\n<li>afterSet<Config>\ncan access all new values from the batch operation.</li>\n</ul>\n","params":[{"type":{"names":["Object"]},"defaultvalue":"{}","name":"values"}],"name":"set","longname":"Base#set","kind":"function","memberof":"Base","scope":"instance","$longname":"Base#set","$kind":"method","id":1367,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * We want to assign class fields first and remove them from the config object,\n     * so that afterSet(), beforeGet() and beforeSet() methods can get the new values right away\n     * @param {Object} config\n     * @returns {Object}\n     * @protected\n     */","meta":{"range":[37702,37999],"filename":"Base.mjs","lineno":1019,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{"id":"astnode100043569","name":"Base#setFields","type":"MethodDefinition","paramnames":["config"]},"vars":{"":null}},"description":"<p>We want to assign class fields first and remove them from the config object,\nso that afterSet(), beforeGet() and beforeSet() methods can get the new values right away</p>\n","params":[{"type":{"names":["Object"]},"name":"config"}],"returns":[{"type":{"names":["Object"]}}],"access":"protected","name":"setFields","longname":"Base#setFields","kind":"function","memberof":"Base","scope":"instance","$longname":"Base#setFields","$kind":"method","id":1368,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * Sets the value of a static config by a given key\n     * @param {String} key The key of a staticConfig defined inside static getStaticConfig\n     * @param {*} value\n     * @returns {Boolean} true in case the config exists and got changed\n     */","meta":{"range":[38265,38502],"filename":"Base.mjs","lineno":1038,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{"id":"astnode100043619","name":"Base#setStaticConfig","type":"MethodDefinition","paramnames":["key","value"]},"vars":{"":null}},"description":"<p>Sets the value of a static config by a given key</p>\n","params":[{"type":{"names":["String"]},"description":"<p>The key of a staticConfig defined inside static getStaticConfig</p>\n","name":"key"},{"type":{"names":["*"]},"name":"value"}],"returns":[{"type":{"names":["Boolean"]},"description":"true in case the config exists and got changed"}],"name":"setStaticConfig","longname":"Base#setStaticConfig","kind":"function","memberof":"Base","scope":"instance","$longname":"Base#setStaticConfig","$kind":"method","id":1369,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * Stores timeoutIds internally, so that destroy() can clear them if needed\n     * @param {Number} time in milliseconds\n     * @returns {Promise<any>}\n     */","meta":{"range":[38679,38957],"filename":"Base.mjs","lineno":1054,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{"id":"astnode100043650","name":"Base#timeout","type":"MethodDefinition","paramnames":["time"]},"vars":{"":null}},"description":"<p>Stores timeoutIds internally, so that destroy() can clear them if needed</p>\n","params":[{"type":{"names":["Number"]},"description":"<p>in milliseconds</p>\n","name":"time"}],"returns":[{"type":{"names":["Promise.<any>"]}}],"name":"timeout","longname":"Base#timeout","kind":"function","memberof":"Base","scope":"instance","$longname":"Base#timeout","$kind":"method","id":1370,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * Recursive helper to extract all mixin classes from the mixins object\n     * @param {Object} [obj=this.mixins]\n     * @param {Array} [res=[]]\n     * @returns {Array}\n     * @protected\n     */","meta":{"range":[39169,39524],"filename":"Base.mjs","lineno":1070,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{"id":"astnode100043695","name":"Base#getMixins","type":"MethodDefinition","paramnames":["obj","res"]},"vars":{"":null}},"description":"<p>Recursive helper to extract all mixin classes from the mixins object</p>\n","params":[{"type":{"names":["Object"]},"optional":true,"defaultvalue":"this.mixins","name":"obj"},{"type":{"names":["Array"]},"optional":true,"defaultvalue":"[]","name":"res"}],"returns":[{"type":{"names":["Array"]}}],"access":"protected","name":"getMixins","longname":"Base#getMixins","kind":"function","memberof":"Base","scope":"instance","$longname":"Base#getMixins","$kind":"method","id":1371,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * Serializes the instance into a JSON-compatible object for the Neural Link.\n     * Subclasses should override this to include their specific relevant state.\n     * @returns {Object}\n     */","meta":{"range":[39734,40767],"filename":"Base.mjs","lineno":1089,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{"id":"astnode100043751","name":"Base#toJSON","type":"MethodDefinition","paramnames":[]},"vars":{"":null}},"description":"<p>Serializes the instance into a JSON-compatible object for the Neural Link.\nSubclasses should override this to include their specific relevant state.</p>\n","returns":[{"type":{"names":["Object"]}}],"name":"toJSON","longname":"Base#toJSON","kind":"function","memberof":"Base","scope":"instance","params":[],"$longname":"Base#toJSON","$kind":"method","id":1372,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * <p>Enhancing the toString() method, e.g.</p>\n     * `Neo.create('Neo.button.Base').toString() => \"[object Neo.button.Base]\"`\n     * @returns {String}\n     */","meta":{"range":[40946,41010],"filename":"Base.mjs","lineno":1137,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{"id":"astnode100043859","name":"Base#Symbol.toStringTag","type":"MethodDefinition","paramnames":[]},"vars":{"":null}},"description":"<p>Enhancing the toString() method, e.g.</p>\n`Neo.create('Neo.button.Base').toString() => \"[object Neo.button.Base]\"`","returns":[{"type":{"names":["String"]}}],"name":"toStringTag","longname":"Base#Symbol.toStringTag","kind":"member","memberof":"Base#Symbol","scope":"static","params":[],"$longname":"Base#Symbol.toStringTag","$kind":"property","id":1373,"neoClassName":"Neo.core.Base"},{"comment":"/**\n     * <p>Enhancing the instanceof method. Without this change:</p>\n     * `Neo.collection.Base.prototype instanceof Neo.core.Base => true`\n     * <p>With this change:</p>\n     * `Neo.collection.Base.prototype instanceof Neo.core.Base => false`<br>\n     * `Neo.create(Neo.collection.Base) instanceof Neo.core.Base => true`\n     * @returns {Boolean}\n     */","meta":{"range":[41381,41578],"filename":"Base.mjs","lineno":1144,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/core","code":{"id":"astnode100043869","name":"Base.Symbol.hasInstance","type":"MethodDefinition","paramnames":["instance"]},"vars":{"":null}},"description":"<p>Enhancing the instanceof method. Without this change:</p>\n`Neo.collection.Base.prototype instanceof Neo.core.Base => true`\n<p>With this change:</p>\n`Neo.collection.Base.prototype instanceof Neo.core.Base => false`<br>\n`Neo.create(Neo.collection.Base) instanceof Neo.core.Base => true`","returns":[{"type":{"names":["Boolean"]}}],"name":"hasInstance","longname":"Base.Symbol.hasInstance","kind":"function","memberof":"Base.Symbol","scope":"static","params":[],"$longname":"Base.Symbol.hasInstance","$kind":"method","id":1374,"neoClassName":"Neo.core.Base"}]}