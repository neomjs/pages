/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./. lazy recursive ^\\.\\/.*\\.mjs$ include: (?:\\/%7C\\\\)app.mjs$":
/*!************************************************************************************!*\
  !*** ././ lazy ^\.\/.*\.mjs$ include: (?:\/%7C\\)app.mjs$ strict namespace object ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./apps/colors/app.mjs": [
		"./apps/colors/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-src_grid_Container_mjs",
		"vendors-apps_colors_app_mjs"
	],
	"./apps/colors/childapps/widget/app.mjs": [
		"./apps/colors/childapps/widget/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"apps_colors_childapps_widget_app_mjs"
	],
	"./apps/covid/app.mjs": [
		"./apps/covid/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-src_tab_Container_mjs",
		"vendors-apps_covid_app_mjs-src_selection_Model_mjs-src_toolbar_Base_mjs"
	],
	"./apps/email/app.mjs": [
		"./apps/email/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_grid_Container_mjs",
		"vendors-src_functional_component_Base_mjs",
		"vendors-apps_email_app_mjs-src_toolbar_Base_mjs"
	],
	"./apps/finance/app.mjs": [
		"./apps/finance/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-src_grid_Container_mjs",
		"vendors-apps_finance_app_mjs"
	],
	"./apps/form/app.mjs": [
		"./apps/form/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-src_form_Container_mjs",
		"vendors-apps_form_app_mjs-src_selection_Model_mjs"
	],
	"./apps/portal/app.mjs": [
		"./apps/portal/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-src_layout_Cube_mjs",
		"vendors-apps_portal_app_mjs"
	],
	"./apps/portal/childapps/preview/app.mjs": [
		"./apps/portal/childapps/preview/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"apps_portal_childapps_preview_app_mjs"
	],
	"./apps/realworld/app.mjs": [
		"./apps/realworld/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-apps_realworld_app_mjs"
	],
	"./apps/realworld2/app.mjs": [
		"./apps/realworld2/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_tab_Container_mjs",
		"vendors-src_form_Container_mjs",
		"vendors-src_component_Helix_mjs-src_container_Panel_mjs-src_form_field_Range_mjs",
		"vendors-src_component_Gallery_mjs",
		"vendors-examples_component_helix_Viewport_mjs-src_selection_Model_mjs-src_toolbar_Base_mjs",
		"vendors-examples_component_gallery_MainContainer_mjs",
		"vendors-apps_realworld2_app_mjs"
	],
	"./apps/route/app.mjs": [
		"./apps/route/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-apps_route_app_mjs"
	],
	"./apps/sharedcovid/app.mjs": [
		"./apps/sharedcovid/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-src_tab_Container_mjs",
		"vendors-apps_sharedcovid_app_mjs-src_selection_Model_mjs-src_toolbar_Base_mjs"
	],
	"./apps/sharedcovid/childapps/sharedcovidchart/app.mjs": [
		"./apps/sharedcovid/childapps/sharedcovidchart/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"apps_sharedcovid_childapps_sharedcovidchart_app_mjs"
	],
	"./apps/sharedcovid/childapps/sharedcovidgallery/app.mjs": [
		"./apps/sharedcovid/childapps/sharedcovidgallery/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"apps_sharedcovid_childapps_sharedcovidgallery_app_mjs"
	],
	"./apps/sharedcovid/childapps/sharedcovidhelix/app.mjs": [
		"./apps/sharedcovid/childapps/sharedcovidhelix/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"apps_sharedcovid_childapps_sharedcovidhelix_app_mjs"
	],
	"./apps/sharedcovid/childapps/sharedcovidmap/app.mjs": [
		"./apps/sharedcovid/childapps/sharedcovidmap/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"apps_sharedcovid_childapps_sharedcovidmap_app_mjs"
	],
	"./apps/shareddialog/app.mjs": [
		"./apps/shareddialog/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_dialog_Base_mjs",
		"vendors-apps_shareddialog_app_mjs-src_container_Panel_mjs"
	],
	"./apps/shareddialog/childapps/shareddialog2/app.mjs": [
		"./apps/shareddialog/childapps/shareddialog2/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-apps_shareddialog_childapps_shareddialog2_app_mjs"
	],
	"./docs/app.mjs": [
		"./docs/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_tab_Container_mjs",
		"vendors-src_draggable_DragZone_mjs",
		"vendors-src_selection_Model_mjs-src_tree_List_mjs",
		"vendors-docs_app_view_MainContainer_mjs",
		"vendors-docs_app_mjs-src_container_Viewport_mjs-src_controller_Component_mjs-src_toolbar_Base_mjs"
	],
	"./examples/button/base/app.mjs": [
		"./examples/button/base/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-examples_button_base_app_mjs-src_selection_Model_mjs"
	],
	"./examples/button/effect/app.mjs": [
		"./examples/button/effect/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-examples_button_effect_app_mjs-src_selection_Model_mjs"
	],
	"./examples/button/split/app.mjs": [
		"./examples/button/split/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-examples_button_split_app_mjs-src_selection_Model_mjs"
	],
	"./examples/calendar/basic/app.mjs": [
		"./examples/calendar/basic/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-src_component_DateSelector_mjs",
		"vendors-src_form_Container_mjs",
		"vendors-src_list_Color_mjs-src_selection_Model_mjs",
		"vendors-src_form_field_Time_mjs",
		"vendors-src_calendar_view_MainContainerStateProvider_mjs-src_container_Viewport_mjs",
		"vendors-examples_calendar_basic_app_mjs"
	],
	"./examples/calendar/weekview/app.mjs": [
		"./examples/calendar/weekview/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-src_calendar_view_week_Component_mjs",
		"vendors-src_calendar_view_MainContainerStateProvider_mjs-src_container_Viewport_mjs",
		"examples_calendar_weekview_app_mjs-src_util_Date_mjs"
	],
	"./examples/charts/app.mjs": [
		"./examples/charts/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"examples_charts_app_mjs"
	],
	"./examples/component/canvas/app.mjs": [
		"./examples/component/canvas/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"examples_component_canvas_app_mjs"
	],
	"./examples/component/carousel/app.mjs": [
		"./examples/component/carousel/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-examples_component_carousel_app_mjs"
	],
	"./examples/component/chip/app.mjs": [
		"./examples/component/chip/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"examples_component_chip_app_mjs"
	],
	"./examples/component/circle/app.mjs": [
		"./examples/component/circle/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_component_Circle_mjs",
		"examples_component_circle_app_mjs"
	],
	"./examples/component/clock/app.mjs": [
		"./examples/component/clock/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_Time_mjs",
		"vendors-examples_component_clock_app_mjs-src_form_field_Picker_mjs-src_selection_Model_mjs"
	],
	"./examples/component/coronaGallery/app.mjs": [
		"./examples/component/coronaGallery/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_component_Gallery_mjs",
		"vendors-examples_component_coronaGallery_Viewport_mjs-src_selection_Model_mjs",
		"examples_component_coronaGallery_app_mjs"
	],
	"./examples/component/coronaHelix/app.mjs": [
		"./examples/component/coronaHelix/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_component_Helix_mjs-src_container_Panel_mjs-src_form_field_Range_mjs",
		"vendors-examples_component_coronaHelix_app_mjs-src_selection_Model_mjs-src_toolbar_Base_mjs"
	],
	"./examples/component/dateSelector/app.mjs": [
		"./examples/component/dateSelector/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_component_DateSelector_mjs",
		"vendors-examples_component_dateSelector_app_mjs-src_selection_Model_mjs"
	],
	"./examples/component/gallery/app.mjs": [
		"./examples/component/gallery/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_component_Gallery_mjs",
		"vendors-examples_component_gallery_MainContainer_mjs",
		"vendors-examples_component_gallery_app_mjs-src_container_Panel_mjs-src_container_Viewport_mjs-bd568a"
	],
	"./examples/component/helix/app.mjs": [
		"./examples/component/helix/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_component_Helix_mjs-src_container_Panel_mjs-src_form_field_Range_mjs",
		"vendors-examples_component_helix_Viewport_mjs-src_selection_Model_mjs-src_toolbar_Base_mjs",
		"examples_component_helix_app_mjs"
	],
	"./examples/component/magicmovetext/app.mjs": [
		"./examples/component/magicmovetext/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_component_MagicMoveText_mjs",
		"examples_component_magicmovetext_app_mjs"
	],
	"./examples/component/multiWindowCoronaGallery/app.mjs": [
		"./examples/component/multiWindowCoronaGallery/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_component_Gallery_mjs",
		"vendors-examples_component_coronaGallery_Viewport_mjs-src_selection_Model_mjs",
		"examples_component_multiWindowCoronaGallery_app_mjs"
	],
	"./examples/component/multiWindowCoronaGallery/childapp/app.mjs": [
		"./examples/component/multiWindowCoronaGallery/childapp/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"examples_component_multiWindowCoronaGallery_childapp_app_mjs"
	],
	"./examples/component/multiWindowHelix/app.mjs": [
		"./examples/component/multiWindowHelix/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_component_Helix_mjs-src_container_Panel_mjs-src_form_field_Range_mjs",
		"vendors-examples_component_helix_Viewport_mjs-src_selection_Model_mjs-src_toolbar_Base_mjs",
		"examples_component_multiWindowHelix_app_mjs"
	],
	"./examples/component/multiWindowHelix/childapp/app.mjs": [
		"./examples/component/multiWindowHelix/childapp/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"examples_component_multiWindowHelix_childapp_app_mjs"
	],
	"./examples/component/mwc/button/app.mjs": [
		"./examples/component/mwc/button/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"examples_component_mwc_button_app_mjs"
	],
	"./examples/component/mwc/buttons/app.mjs": [
		"./examples/component/mwc/buttons/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_tab_Container_mjs",
		"vendors-examples_component_mwc_buttons_app_mjs-src_toolbar_Base_mjs"
	],
	"./examples/component/mwc/textField/app.mjs": [
		"./examples/component/mwc/textField/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"examples_component_mwc_textField_app_mjs"
	],
	"./examples/component/mwc/textFields/app.mjs": [
		"./examples/component/mwc/textFields/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_tab_Container_mjs",
		"vendors-examples_component_mwc_textFields_app_mjs-src_toolbar_Base_mjs"
	],
	"./examples/component/process/app.mjs": [
		"./examples/component/process/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_list_Color_mjs-src_selection_Model_mjs",
		"vendors-examples_component_process_app_mjs"
	],
	"./examples/component/process/realWorldExample/app.mjs": [
		"./examples/component/process/realWorldExample/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_form_Container_mjs",
		"vendors-src_component_Toast_mjs",
		"vendors-examples_component_process_realWorldExample_app_mjs-src_selection_Model_mjs"
	],
	"./examples/component/progress/app.mjs": [
		"./examples/component/progress/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"examples_component_progress_app_mjs"
	],
	"./examples/component/splitter/app.mjs": [
		"./examples/component/splitter/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_draggable_DragZone_mjs",
		"examples_component_splitter_app_mjs"
	],
	"./examples/component/statusbadge/app.mjs": [
		"./examples/component/statusbadge/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-examples_component_statusbadge_app_mjs"
	],
	"./examples/component/timer/app.mjs": [
		"./examples/component/timer/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_list_Color_mjs-src_selection_Model_mjs",
		"vendors-examples_component_timer_app_mjs"
	],
	"./examples/component/toast/app.mjs": [
		"./examples/component/toast/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_form_Container_mjs",
		"vendors-src_component_Toast_mjs",
		"vendors-examples_component_toast_app_mjs-src_selection_Model_mjs"
	],
	"./examples/component/video/app.mjs": [
		"./examples/component/video/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_component_Toast_mjs",
		"vendors-examples_component_video_app_mjs"
	],
	"./examples/component/wrapper/cesiumJS/app.mjs": [
		"./examples/component/wrapper/cesiumJS/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-examples_component_wrapper_cesiumJS_app_mjs"
	],
	"./examples/component/wrapper/googleMaps/app.mjs": [
		"./examples/component/wrapper/googleMaps/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_dialog_Base_mjs",
		"vendors-examples_component_wrapper_googleMaps_app_mjs-src_container_Panel_mjs"
	],
	"./examples/component/wrapper/monacoEditor/app.mjs": [
		"./examples/component/wrapper/monacoEditor/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_component_wrapper_MonacoEditor_mjs",
		"examples_component_wrapper_monacoEditor_app_mjs"
	],
	"./examples/container/accordion/app.mjs": [
		"./examples/container/accordion/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-examples_container_accordion_app_mjs"
	],
	"./examples/container/base/app.mjs": [
		"./examples/container/base/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"examples_container_base_app_mjs"
	],
	"./examples/core/config/app.mjs": [
		"./examples/core/config/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-examples_core_config_app_mjs"
	],
	"./examples/dashboard/app.mjs": [
		"./examples/dashboard/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"examples_dashboard_app_mjs"
	],
	"./examples/date/selectorContainer/app.mjs": [
		"./examples/date/selectorContainer/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-src_component_DateSelector_mjs",
		"vendors-examples_date_selectorContainer_app_mjs-src_selection_Model_mjs"
	],
	"./examples/dialog/app.mjs": [
		"./examples/dialog/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_dialog_Base_mjs",
		"vendors-examples_dialog_app_mjs-src_container_Panel_mjs-src_selection_Model_mjs"
	],
	"./examples/fieldWithPrefix/app.mjs": [
		"./examples/fieldWithPrefix/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-examples_fieldWithPrefix_app_mjs-src_selection_Model_mjs"
	],
	"./examples/fields/app.mjs": [
		"./examples/fields/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_tab_Container_mjs",
		"vendors-src_component_DateSelector_mjs",
		"vendors-src_form_Container_mjs",
		"vendors-src_form_field_Time_mjs",
		"vendors-examples_fields_app_mjs-src_selection_Model_mjs-src_toolbar_Base_mjs"
	],
	"./examples/form/field/checkbox/app.mjs": [
		"./examples/form/field/checkbox/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"examples_form_field_checkbox_app_mjs"
	],
	"./examples/form/field/chip/app.mjs": [
		"./examples/form/field/chip/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-examples_form_field_chip_app_mjs-src_selection_Model_mjs"
	],
	"./examples/form/field/color/app.mjs": [
		"./examples/form/field/color/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_list_Color_mjs-src_selection_Model_mjs",
		"vendors-examples_form_field_color_app_mjs"
	],
	"./examples/form/field/combobox/app.mjs": [
		"./examples/form/field/combobox/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-examples_form_field_combobox_app_mjs-src_selection_Model_mjs"
	],
	"./examples/form/field/date/app.mjs": [
		"./examples/form/field/date/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_component_DateSelector_mjs",
		"vendors-examples_form_field_date_app_mjs-src_selection_Model_mjs"
	],
	"./examples/form/field/email/app.mjs": [
		"./examples/form/field/email/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"examples_form_field_email_app_mjs"
	],
	"./examples/form/field/fileupload/app.mjs": [
		"./examples/form/field/fileupload/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-examples_form_field_fileupload_app_mjs"
	],
	"./examples/form/field/number/app.mjs": [
		"./examples/form/field/number/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"examples_form_field_number_app_mjs"
	],
	"./examples/form/field/picker/app.mjs": [
		"./examples/form/field/picker/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-examples_form_field_picker_app_mjs"
	],
	"./examples/form/field/radio/app.mjs": [
		"./examples/form/field/radio/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"examples_form_field_radio_app_mjs"
	],
	"./examples/form/field/switch/app.mjs": [
		"./examples/form/field/switch/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"examples_form_field_switch_app_mjs"
	],
	"./examples/form/field/text/app.mjs": [
		"./examples/form/field/text/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-examples_form_field_text_app_mjs"
	],
	"./examples/form/field/textarea/app.mjs": [
		"./examples/form/field/textarea/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-examples_form_field_textarea_app_mjs"
	],
	"./examples/form/field/time/app.mjs": [
		"./examples/form/field/time/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_Time_mjs",
		"vendors-examples_form_field_time_app_mjs-src_form_field_Picker_mjs-src_selection_Model_mjs"
	],
	"./examples/form/field/trigger/copyToClipboard/app.mjs": [
		"./examples/form/field/trigger/copyToClipboard/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-examples_form_field_trigger_copyToClipboard_app_mjs"
	],
	"./examples/form/field/url/app.mjs": [
		"./examples/form/field/url/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"examples_form_field_url_app_mjs"
	],
	"./examples/form/fieldset/app.mjs": [
		"./examples/form/fieldset/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_form_Container_mjs",
		"vendors-examples_form_fieldset_app_mjs"
	],
	"./examples/functional/button/base/app.mjs": [
		"./examples/functional/button/base/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_functional_component_Base_mjs",
		"vendors-examples_functional_button_base_app_mjs-src_selection_Model_mjs"
	],
	"./examples/functional/defineComponent/app.mjs": [
		"./examples/functional/defineComponent/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_functional_component_Base_mjs",
		"examples_functional_defineComponent_app_mjs"
	],
	"./examples/functional/hostComponent/app.mjs": [
		"./examples/functional/hostComponent/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_functional_component_Base_mjs",
		"vendors-examples_functional_hostComponent_app_mjs"
	],
	"./examples/grid/animatedRowSorting/app.mjs": [
		"./examples/grid/animatedRowSorting/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_grid_Container_mjs",
		"vendors-examples_grid_animatedRowSorting_app_mjs"
	],
	"./examples/grid/bigData/app.mjs": [
		"./examples/grid/bigData/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_tab_Container_mjs",
		"vendors-src_grid_Container_mjs",
		"vendors-src_form_field_Radio_mjs-src_selection_grid_CellColumnModel_mjs-src_selection_grid_Ce-f3ad8f",
		"vendors-examples_grid_bigData_app_mjs-src_toolbar_Base_mjs"
	],
	"./examples/grid/cellEditing/app.mjs": [
		"./examples/grid/cellEditing/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-src_component_DateSelector_mjs",
		"vendors-src_grid_Container_mjs",
		"vendors-src_form_field_Radio_mjs-src_selection_grid_CellColumnModel_mjs-src_selection_grid_Ce-f3ad8f",
		"vendors-examples_grid_cellEditing_app_mjs"
	],
	"./examples/grid/container/app.mjs": [
		"./examples/grid/container/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_grid_Container_mjs",
		"vendors-src_form_field_Radio_mjs-src_selection_grid_CellColumnModel_mjs-src_selection_grid_Ce-f3ad8f",
		"vendors-examples_grid_container_app_mjs"
	],
	"./examples/grid/covid/app.mjs": [
		"./examples/grid/covid/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_grid_Container_mjs",
		"vendors-examples_grid_covid_app_mjs-src_toolbar_Base_mjs"
	],
	"./examples/grid/nestedRecordFields/app.mjs": [
		"./examples/grid/nestedRecordFields/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-src_grid_Container_mjs",
		"vendors-src_component_Toast_mjs",
		"vendors-examples_grid_nestedRecordFields_app_mjs-src_toolbar_Base_mjs"
	],
	"./examples/layout/card/app.mjs": [
		"./examples/layout/card/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"examples_layout_card_app_mjs"
	],
	"./examples/layout/cube/app.mjs": [
		"./examples/layout/cube/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_layout_Cube_mjs",
		"vendors-examples_layout_cube_app_mjs"
	],
	"./examples/layout/form/app.mjs": [
		"./examples/layout/form/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_form_Container_mjs",
		"vendors-examples_layout_form_app_mjs"
	],
	"./examples/list/animate/app.mjs": [
		"./examples/list/animate/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-examples_list_animate_app_mjs-src_selection_Model_mjs"
	],
	"./examples/list/base/app.mjs": [
		"./examples/list/base/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-examples_list_base_app_mjs-src_selection_Model_mjs"
	],
	"./examples/list/chip/app.mjs": [
		"./examples/list/chip/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_list_Chip_mjs-src_selection_Model_mjs",
		"examples_list_chip_app_mjs"
	],
	"./examples/list/circle/app.mjs": [
		"./examples/list/circle/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_component_Circle_mjs",
		"vendors-examples_list_circle_app_mjs"
	],
	"./examples/list/color/app.mjs": [
		"./examples/list/color/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_list_Color_mjs-src_selection_Model_mjs",
		"examples_list_color_app_mjs"
	],
	"./examples/menu/list/app.mjs": [
		"./examples/menu/list/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_menu_List_mjs",
		"vendors-examples_menu_list_app_mjs-src_selection_Model_mjs"
	],
	"./examples/menu/panel/app.mjs": [
		"./examples/menu/panel/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_menu_List_mjs",
		"vendors-examples_menu_panel_app_mjs-src_selection_Model_mjs"
	],
	"./examples/panel/app.mjs": [
		"./examples/panel/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-examples_panel_app_mjs"
	],
	"./examples/popover/app.mjs": [
		"./examples/popover/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"examples_popover_app_mjs"
	],
	"./examples/preloadingAssets/app.mjs": [
		"./examples/preloadingAssets/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_tab_Container_mjs",
		"vendors-examples_preloadingAssets_app_mjs-src_toolbar_Base_mjs"
	],
	"./examples/remotesApi/basic/app.mjs": [
		"./examples/remotesApi/basic/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-examples_remotesApi_basic_app_mjs"
	],
	"./examples/serverside/gridContainer/app.mjs": [
		"./examples/serverside/gridContainer/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"examples_serverside_gridContainer_app_mjs"
	],
	"./examples/serverside/toolbarItems/app.mjs": [
		"./examples/serverside/toolbarItems/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-examples_serverside_toolbarItems_app_mjs"
	],
	"./examples/sitemap/app.mjs": [
		"./examples/sitemap/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-examples_sitemap_app_mjs"
	],
	"./examples/stateProvider/advanced/app.mjs": [
		"./examples/stateProvider/advanced/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-examples_stateProvider_advanced_app_mjs"
	],
	"./examples/stateProvider/dialog/app.mjs": [
		"./examples/stateProvider/dialog/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-examples_stateProvider_dialog_app_mjs"
	],
	"./examples/stateProvider/extendedClass/app.mjs": [
		"./examples/stateProvider/extendedClass/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-examples_stateProvider_extendedClass_app_mjs"
	],
	"./examples/stateProvider/inline/app.mjs": [
		"./examples/stateProvider/inline/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-examples_stateProvider_inline_app_mjs"
	],
	"./examples/stateProvider/inlineNoStateProvider/app.mjs": [
		"./examples/stateProvider/inlineNoStateProvider/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-examples_stateProvider_inlineNoStateProvider_app_mjs"
	],
	"./examples/stateProvider/multiWindow/app.mjs": [
		"./examples/stateProvider/multiWindow/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-examples_stateProvider_multiWindow_app_mjs"
	],
	"./examples/stateProvider/multiWindow2/app.mjs": [
		"./examples/stateProvider/multiWindow2/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"examples_stateProvider_multiWindow2_app_mjs"
	],
	"./examples/stateProvider/nestedData/app.mjs": [
		"./examples/stateProvider/nestedData/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-examples_stateProvider_nestedData_app_mjs"
	],
	"./examples/stateProvider/table/app.mjs": [
		"./examples/stateProvider/table/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-src_table_Container_mjs",
		"vendors-examples_stateProvider_table_app_mjs-src_selection_Model_mjs-src_toolbar_Base_mjs"
	],
	"./examples/stateProvider/twoWay/app.mjs": [
		"./examples/stateProvider/twoWay/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_state_Provider_mjs",
		"examples_stateProvider_twoWay_app_mjs"
	],
	"./examples/tab/container/app.mjs": [
		"./examples/tab/container/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_tab_Container_mjs",
		"vendors-examples_tab_container_app_mjs"
	],
	"./examples/table/cellEditing/app.mjs": [
		"./examples/table/cellEditing/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-src_table_Container_mjs",
		"vendors-src_component_DateSelector_mjs",
		"vendors-src_form_field_Radio_mjs-src_selection_Model_mjs-src_selection_table_CellModel_mjs",
		"vendors-examples_table_cellEditing_app_mjs"
	],
	"./examples/table/container/app.mjs": [
		"./examples/table/container/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_table_Container_mjs",
		"vendors-src_form_field_Radio_mjs-src_selection_Model_mjs-src_selection_table_CellModel_mjs",
		"vendors-examples_table_container_app_mjs"
	],
	"./examples/table/covid/app.mjs": [
		"./examples/table/covid/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_table_Container_mjs",
		"vendors-examples_table_covid_app_mjs-src_selection_Model_mjs-src_toolbar_Base_mjs"
	],
	"./examples/table/nestedRecordFields/app.mjs": [
		"./examples/table/nestedRecordFields/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-src_table_Container_mjs",
		"vendors-examples_table_nestedRecordFields_app_mjs-src_selection_Model_mjs-src_toolbar_Base_mjs"
	],
	"./examples/tableFiltering/app.mjs": [
		"./examples/tableFiltering/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_table_Container_mjs",
		"vendors-src_component_DateSelector_mjs",
		"vendors-src_form_field_Radio_mjs-src_selection_Model_mjs-src_selection_table_CellModel_mjs",
		"vendors-examples_tableFiltering_app_mjs-src_toolbar_Base_mjs"
	],
	"./examples/tablePerformance/app.mjs": [
		"./examples/tablePerformance/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_table_Container_mjs",
		"vendors-examples_tablePerformance_app_mjs-src_selection_Model_mjs-src_toolbar_Base_mjs"
	],
	"./examples/tableStore/app.mjs": [
		"./examples/tableStore/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_table_Container_mjs",
		"vendors-src_form_field_Radio_mjs-src_selection_Model_mjs-src_selection_table_CellModel_mjs",
		"vendors-examples_tableStore_app_mjs-src_toolbar_Base_mjs"
	],
	"./examples/tabs/app.mjs": [
		"./examples/tabs/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_tab_Container_mjs",
		"vendors-src_table_Container_mjs",
		"vendors-examples_tabs_app_mjs-src_selection_Model_mjs-src_toolbar_Base_mjs"
	],
	"./examples/todoList/version1/app.mjs": [
		"./examples/todoList/version1/app.mjs",
		"vendors-src_component_Base_mjs",
		"examples_todoList_version1_app_mjs"
	],
	"./examples/todoList/version2/app.mjs": [
		"./examples/todoList/version2/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-examples_todoList_version2_app_mjs-src_selection_Model_mjs"
	],
	"./examples/toolbar/breadcrumb/app.mjs": [
		"./examples/toolbar/breadcrumb/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-examples_toolbar_breadcrumb_app_mjs"
	],
	"./examples/toolbar/paging/app.mjs": [
		"./examples/toolbar/paging/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-src_table_Container_mjs",
		"vendors-examples_toolbar_paging_app_mjs-src_selection_Model_mjs"
	],
	"./examples/tree/app.mjs": [
		"./examples/tree/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_selection_Model_mjs-src_tree_List_mjs",
		"examples_tree_app_mjs"
	],
	"./examples/treeAccordion/app.mjs": [
		"./examples/treeAccordion/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-src_selection_Model_mjs-src_tree_List_mjs",
		"vendors-examples_treeAccordion_app_mjs"
	],
	"./examples/videoMove/app.mjs": [
		"./examples/videoMove/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"examples_videoMove_app_mjs"
	],
	"./examples/viewport/app.mjs": [
		"./examples/viewport/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_tab_Container_mjs",
		"vendors-examples_viewport_app_mjs-src_toolbar_Base_mjs"
	],
	"./examples/worker/task/app.mjs": [
		"./examples/worker/task/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"examples_worker_task_app_mjs"
	],
	"./test/components/app.mjs": [
		"./test/components/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_component_DateSelector_mjs",
		"vendors-src_list_Chip_mjs-src_selection_Model_mjs",
		"test_components_app_mjs"
	]
};
function webpackAsyncContext(req) {
	if(!__webpack_require__.o(map, req)) {
		return Promise.resolve().then(() => {
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		});
	}

	var ids = map[req], id = ids[0];
	return Promise.all(ids.slice(1).map(__webpack_require__.e)).then(() => {
		return __webpack_require__(id);
	});
}
webpackAsyncContext.keys = () => (Object.keys(map));
webpackAsyncContext.id = "./. lazy recursive ^\\.\\/.*\\.mjs$ include: (?:\\/%7C\\\\)app.mjs$";
module.exports = webpackAsyncContext;

/***/ }),

/***/ "./src/DefaultConfig.mjs":
/*!*******************************!*\
  !*** ./src/DefaultConfig.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const Neo = globalThis.Neo || {};

Neo.config = Neo.config || {};

/**
 * Config object for the neo.mjs framework which will get passed to all workers
 * You can change the configs, e.g. inside the index.html of your app
 * @memberOf module:Neo
 * @name config
 * @type Object
 */
const DefaultConfig = {
    /**
     * true will apply 'neo-body' to the document.body classList
     * @default true
     * @memberOf! module:Neo
     * @name config.applyBodyCls
     * @type Boolean
     */
    applyBodyCls: true,
    /**
     * true will apply 'position: fixed' to the html tag itself
     * See: https://github.com/neomjs/neo/issues/6429
     * @default true
     * @memberOf! module:Neo
     * @name config.applyFixedPositionToHtmlTag
     * @type Boolean
     */
    applyFixedPositionToHtmlTag: true,
    /**
     * Path to your app.mjs file. You can create multiple apps there if needed.
     * @default null
     * @memberOf! module:Neo
     * @name config.appPath
     * @type String|null
     */
    appPath: null,
    /**
     * Path to the neo.mjs directory
     * @default './'
     * @memberOf! module:Neo
     * @name config.basePath
     * @type String
     */
    basePath: './',
    /**
     * Pass a token in case you are using the CesiumJS main thread addon
     * See: https://github.com/neomjs/neo/blob/dev/src/main/addon/CesiumJS.mjs
     * @default undefined
     * @memberOf! module:Neo
     * @name config.cesiumJsToken
     * @type String|null
     */

    /**
     * Set this config to false to disable the component logging using Ctrl-Right-Click
     * @default true
     * @memberOf! module:Neo
     * @name config.enableComponentLogger
     * @type Boolean
     */
    enableComponentLogger: true,
    /**
     * Set this config to true to enable util.Logger (Neo.log()) based logs in production
     * @default false
     * @memberOf! module:Neo
     * @name config.enableLogsInProduction
     * @type Boolean
     */
    enableLogsInProduction: false,
    /**
     * The current environment. Valid values: 'development', 'dist/development', 'dist/production'
     * This config will get auto-generated
     * @default 'dist/production'
     * @memberOf! module:Neo
     * @name config.environment
     * @type String
     */
    environment: 'dist/production',
    /**
     * In case you are using the GoogleMaps main thread addon, you can pass the API key here.
     * @default undefined
     * @memberOf! module:Neo
     * @name config.googleMapsApiKey
     * @type String
     */

    /**
     * In case you are using the GoogleAnalytics main thread addon or useGoogleAnalytics: true,
     * you can change the gtag id here. Required for the online examples (gh pages)
     * @default undefined
     * @memberOf! module:Neo
     * @name config.gtagId
     * @type String
     */

    /**
     * Flag for running on https://neomjs.github.io/pages/
     * => to use local images paths instead of raw.githubusercontent.com
     * @default false
     * @memberOf! module:Neo
     * @name config.isGitHubPages
     * @type Boolean
     */
    isGitHubPages: true,
    /**
     * Flag for running the Neo main thread inside an iframe (Siesta Browser Harness)
     * @default false
     * @memberOf! module:Neo
     * @name config.isInsideSiesta
     * @type Boolean
     */
    isInsideSiesta: false,
    /**
     * delay in ms for the worker.Manager:loadApplication() call
     * @default 20
     * @memberOf! module:Neo
     * @name config.loadApplicationDelay
     * @type Number
     */
    loadApplicationDelay: 20,
    /**
     * Used by Intl.DateTimeFormat, for details take a look at:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
     * @default 'default'
     * @memberOf! module:Neo
     * @name config.locale
     * @type String
     */
    locale: 'default',
    /**
     * true will log the delta updates inside the main thread(s) as well as the requestAnimation frames
     * @default false
     * @memberOf! module:Neo
     * @name config.logDeltaUpdates
     * @type Boolean
     */
    logDeltaUpdates: false,
    /**
     * true will log console warnings, in case a component tries to update() while a parent update is running.
     * A parent update results in a short delay, so you might want to resolve these collisions.
     * @default false
     * @memberOf! module:Neo
     * @name config.logVdomUpdateCollisions
     * @type Boolean
     */
    logVdomUpdateCollisions: false,
    /**
     * Add addons for the main thread
     * ./src/main/addon/ contains all framework related options.
     * You can also create your own addons within your workspace scope. Make sure to put them inside 'src/main/addon/'
     * and prefix them with 'WS/' inside your neo-config.json file.
     * Example: ['DragDrop', 'Stylesheet', 'WS/MyAddon']
     * @default ['DragDrop', 'Navigator', 'Stylesheet']
     * @memberOf! module:Neo
     * @name config.mainThreadAddons
     * @type String[]
     */
    mainThreadAddons: ['DragDrop', 'Navigator', 'Stylesheet'],
    /**
     * Pass the URL of a JSON-file, which contains the services and methods from your backend,
     * which you want to expose to the client.
     * See: https://github.com/neomjs/neo/projects/32
     * @default null
     * @memberOf! module:Neo
     * @name config.remotesApiUrl
     * @type String|null
     */
    remotesApiUrl: null,
    /**
     * You can visually show the amount of delta updates per second using this config.
     * It expects a dom node with the id "neo-delta-updates" as the rendering target.
     * @default false
     * @memberOf! module:Neo
     * @name config.renderCountDeltas
     * @type Boolean
     */
    renderCountDeltas: false,
    /**
     * Add themes you want to use here. The first theme will get applied.
     * @default ['neo-theme-light','neo-theme-dark','neo-theme-neo-light']
     * @memberOf! module:Neo
     * @name config.themes
     * @type String[]
     */
    themes: ['neo-theme-light', 'neo-theme-dark', 'neo-theme-neo-light'],
    /**
     * Flag for standalone Siesta module tests => prevent registerRemote worker messages
     * @default false
     * @memberOf! module:Neo
     * @name config.unitTestMode
     * @type Boolean
     */
    unitTestMode: false,
    /**
     * When unitTestMode is true, this flag can be enabled to allow VDOM-related
     * operations like render() and update() to proceed. This is useful for integration-style
     * tests that need to verify component lifecycle and DOM output.
     * @default false
     * @memberOf! module:Neo
     * @name config.allowVdomUpdatesInTests
     * @type Boolean
     */
    allowVdomUpdatesInTests: false,
    /**
     * Experimental flag if an offscreen canvas worker should get created.
     * @default false
     * @memberOf! module:Neo
     * @name config.useCanvasWorker
     * @type Boolean
     */
    useCanvasWorker: false,
    /**
     * `true` will enable the advanced, secure, and performant direct DOM API rendering strategy (recommended).
     * In this mode, `Neo.vdom.Helper` will create and send structured VNode object graphs to the Main Thread.
     * `Neo.main.DeltaUpdates` will then use `Neo.main.render.DomApiRenderer` to directly manipulate the DOM.
     * Crucially, `Neo.main.render.DomApiRenderer` builds new **DOM subtrees** (from the received VNode object graphs)
     * as detached DocumentFragments or elements, entirely outside the live DOM tree.
     * These fully constructed fragments are then inserted into the live document in a **single, atomic operation**.
     * This approach inherently minimizes costly browser reflows/repaints, drastically reduces Cross-Site Scripting (XSS) risks,
     * and optimizes for surgical, atomic DOM updates for unparalleled performance.
     *
     * `false` will enable the legacy string-based rendering strategy.
     * In this mode, `Neo.vdom.Helper` will generate complete HTML strings (`outerHTML`) for VNode subtrees.
     * `Neo.main.DeltaUpdates` will then use `Neo.main.render.StringBasedRenderer` to insert these
     * strings into the DOM using methods like `parentNode.insertAdjacentHTML()`.
     * While performant for large insertions, this mode is generally less secure due to potential XSS vectors
     * and relies on browser HTML parsing, which can be less efficient for granular updates.
     *
     * This configuration affects both the initial painting of your applications and the creation
     * of new component trees at runtime.
     * @default true
     * @memberOf! module:Neo
     * @name config.useDomApiRenderer
     * @type Boolean
     */
    useDomApiRenderer: true,
    /**
     * Flag if vdom ids should get mapped into DOM element ids.
     * false will convert them into a "data-neo-id" attribute.
     * @default true
     * @memberOf! module:Neo
     * @name config.useDomIds
     * @type Boolean
     */
    useDomIds: true,
    /**
     * True will automatically include the stylesheet
     * @default true
     * @memberOf! module:Neo
     * @name config.useFontAwesome
     * @type Boolean
     */
    useFontAwesome: true,
    /**
     * Intended for the online examples where we need an easy way to add GA to every generated app
     * @default false
     * @memberOf! module:Neo
     * @name config.useGoogleAnalytics
     * @type Boolean
     */
    useGoogleAnalytics: false,
    /**
     * True will add the ServiceWorker main thread addon to support caching of assets (PWA)
     * See: https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API
     *
     * You can also use a string to specify the target environment => 'dist/production'.
     * Using 'dist/production' will also use the service worker for 'dist/esm'
     * @default false
     * @memberOf! module:Neo
     * @name config.useServiceWorker
     * @type Boolean|String
     */
    useServiceWorker: false,
    /**
     * Creates App, Data & VDom as SharedWorkers.
     * Set this one to true in case you want to connect multiple main threads.
     * @default false
     * @memberOf! module:Neo
     * @name config.useSharedWorkers
     * @type Boolean
     */
    useSharedWorkers: false,
    /**
     * True will generate a new task worker, which can get filled with own expensive remote methods
     * @default false
     * @memberOf! module:Neo
     * @name config.useTaskWorker
     * @type Boolean
     */
    useTaskWorker: false,
    /**
     * False will create the vdom.Helper within the App worker (experimental!)
     * @default true
     * @memberOf! module:Neo
     * @name config.useVdomWorker
     * @type Boolean
     */
    useVdomWorker: true,
    /**
     * buildScripts/injectPackageVersion.mjs will update this value
     * @default '10.1.1'
     * @memberOf! module:Neo
     * @name config.version
     * @type String
     */
    version: '10.1.1'
};

Object.assign(DefaultConfig, {
    /**
     * Path to the top level neo.mjs resources folder
     * @default Neo.config.basePath + 'resources/'
     * @memberOf! module:Neo
     * @name config.resourcesPath
     * @type String
     */
    resourcesPath: `${Neo.config.basePath || DefaultConfig.basePath}resources/`,
    /**
     * The default base URL for web worker entry points (App, Data, Vdom)
     * @default Neo.config.basePath + 'src/worker/'
     * @memberOf! module:Neo
     * @name config.workerBasePath
     * @type String
     */
    workerBasePath: `${Neo.config.basePath || DefaultConfig.basePath}src/worker/`,
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DefaultConfig);


/***/ }),

/***/ "./src/Neo.mjs":
/*!*********************!*\
  !*** ./src/Neo.mjs ***!
  \*********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _DefaultConfig_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultConfig.mjs */ "./src/DefaultConfig.mjs");
/* harmony import */ var _core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");



const
    camelRegex   = /-./g,
    configSymbol = Symbol.for('configSymbol'),
    getSetCache  = Symbol('getSetCache'),
    cloneMap = {
        Array(obj, deep, ignoreNeoInstances) {
            return !deep ? [...obj] : [...obj.map(val => Neo.clone(val, deep, ignoreNeoInstances))]
        },
        Date(obj) {
            return new Date(obj.valueOf())
        },
        Map(obj) {
            return new Map(obj) // shallow copy
        },
        NeoInstance(obj, ignoreNeoInstances) {
            return ignoreNeoInstances ? obj : Neo.cloneNeoInstance(obj)
        },
        Set(obj) {
            return new Set(obj)
        },
        Object(obj, deep, ignoreNeoInstances) {
            const out = {};

            // Use Reflect.ownKeys() to include symbol properties (e.g., for config descriptors)
            Reflect.ownKeys(obj).forEach(key => {
                const value = obj[key];
                out[key] = !deep ? value : Neo.clone(value, deep, ignoreNeoInstances)
            });

            return out
        }
    },
    typeDetector = {
        function: item => {
            if (item.prototype?.constructor?.isClass) {
                return 'NeoClass'
            }
        },
        object: item => {
            if (item.constructor?.isClass && item instanceof Neo.core.Base) {
                return 'NeoInstance'
            }
        }
    };

/**
 * The base module to enhance classes, create instances and the Neo namespace
 * @module Neo
 * @singleton
 * @borrows Neo.core.Util.bindMethods       as bindMethods
 * @borrows Neo.core.Util.createStyleObject as createStyleObject
 * @borrows Neo.core.Util.createStyles      as createStyles
 * @borrows Neo.core.Util.decamel           as decamel
 * @borrows Neo.core.Util.isArray           as isArray
 * @borrows Neo.core.Util.isBoolean         as isBoolean
 * @borrows Neo.core.Util.isDefined         as isDefined
 * @borrows Neo.core.Compare.isEqual        as isEqual
 * @borrows Neo.core.Util.isNumber          as isNumber
 * @borrows Neo.core.Util.isObject          as isObject
 * @borrows Neo.core.Util.isString          as isString
 * @borrows Neo.core.Util.toArray           as toArray
 * @tutorial 01_Concept
 */
let Neo = globalThis.Neo || {};

Neo = globalThis.Neo = Object.assign({
    /**
     * A map containing ntypes as key and Neo classes or singletons as values
     * @memberOf! module:Neo
     * @protected
     * @type Object
     */
    ntypeMap: {},
    /**
     * Needed for Neo.create. False for the main thread, true for the App, Data & Vdom worker
     * @memberOf! module:Neo
     * @protected
     * @type Boolean
     */
    insideWorker: typeof DedicatedWorkerGlobalScope !== 'undefined' || typeof WorkerGlobalScope !== 'undefined',

    /**
     * Maps methods from one namespace to another one
     * @example
     * // aliases
     * Neo.applyFromNs(Neo, Util, {
     *     createStyleObject: 'createStyleObject',
     *     createStyles     : 'createStyles',
     *     capitalize       : 'capitalize'
     * }, true);
     *
     * // e.g. Neo.core.Util.isObject => Neo.isObject
     * @memberOf module:Neo
     * @param {Neo|Neo.core.Base} target    The target class or singleton Instance or Neo
     * @param {Neo.core.Base}     namespace The class containing the methods
     * @param {Object}            config
     * @param {Boolean}           [bind]    set this to true in case you want to bind methods to the "from" namespace
     * @returns {Object} target
     */
    applyFromNs(target, namespace, config, bind) {
        let fnName;

        if (target && Neo.typeOf(config) === 'Object') {
            Object.entries(config).forEach(([key, value]) => {
                fnName = namespace[value];
                target[key] = bind ? fnName.bind(namespace) : fnName
            })
        }

        return target
    },

    /**
     * Maps a class to the global Neo or App namespace.
     * Can get called for classes and singleton instances
     * @memberOf module:Neo
     * @param {Neo.core.Base} cls
     */
    applyToGlobalNs(cls) {
        let proto     = typeof cls === 'function' ? cls.prototype : cls,
            className = proto.isClass ? proto.config.className : proto.className,
            nsArray   = className.split('.'),
            key       = nsArray.pop(),
            ns        = Neo.ns(nsArray, true);

        ns[key] = cls
    },

    /**
     * Copies all keys of defaults into target, in case they don't already exist
     * @memberOf module:Neo
     * @param {Object} target   The target object
     * @param {Object} defaults The object containing the keys you want to copy
     * @returns {Object} target
     */
    assignDefaults(target, defaults) {
        if (target && Neo.typeOf(defaults) === 'Object') {
            Object.entries(defaults).forEach(([key, value]) => {
                if (!Object.hasOwn(target, key)) {
                    target[key] = value
                }
            })
        }

        return target
    },

    /**
     * Assigns a new value to a given nested objects path.
     * It will create the path structure or parts of it, in case it does not exist.
     * @example
     * Neo.assignToNs('annotations.selected', false, record)
     *
     * @memberOf module:Neo
     * @param {String[]|String} path             The path string containing dots or an Array of the string parts
     * @param {*}               value            The new value to assign to the leaf node
     * @param {Object}          scope=globalThis Set a different starting point as globalThis
     * @param {Boolean}         force=true       false will only assign default values (assign if old value === undefined)
     */
    assignToNs(path, value, scope=globalThis, force=true) {
        path = Array.isArray(path) ? path : path.split('.');

        let key;

        if (path.length > 1) {
            key   = path.pop();
            scope = Neo.ns(path, true, scope)
        } else {
            key = path
        }

        if (force || scope[key] === undefined) {
            scope[key] = value
        }
    },

    /**
     * Converts kebab-case strings into camel-case
     * @memberOf module:Neo
     * @param {String} value The target object
     * @returns {String}
     */
    camel(value) {
        return value.replace(camelRegex, match => match[1].toUpperCase())
    },

    /**
     * Makes the first character of a string uppercase
     * @memberOf module:Neo
     * @param {String} value
     * @returns {Boolean|String} Returns false for non string inputs
     */
    capitalize(value) {
        return value[0].toUpperCase() + value.slice(1)
    },

    /**
     * @memberOf module:Neo
     * @param {Object|Array|*} obj
     * @param {Boolean} deep=false               Set this to true in case you want to clone nested objects as well
     * @param {Boolean} ignoreNeoInstances=false returns existing instances if set to true
     * @returns {Object|Array|*} the cloned input
     */
    clone(obj, deep=false, ignoreNeoInstances=false) {
        return cloneMap[Neo.typeOf(obj)]?.(obj, deep, ignoreNeoInstances) || obj
    },

    /**
     * Creates a new instance using the originalConfig without the id
     * @memberOf module:Neo
     * @param {Neo.core.Base} instance
     * @returns {Neo.core.Base} the cloned instance
     */
    cloneNeoInstance(instance) {
        let config = {...instance.originalConfig};

        delete config._id;
        delete config.id;

        return Neo.create(instance.className, config)
    },

    /**
     * Use Neo.create() instead of "new" to create instances of all Neo classes
     * @example
     * import Button from '../button/Base.mjs';
     *
     * Neo.create(Button, {
     *     iconCls: 'fa fa-home',
     *     text   : 'Home'
     * });
     * @example
     * import Button from '../button/Base.mjs';
     *
     * Neo.create({
     *     module : Button,
     *     iconCls: 'fa fa-home',
     *     text   : 'Home'
     * });
     * @example
     * Neo.create('Neo.button.Base' {
     *     iconCls: 'fa fa-home',
     *     text   : 'Home'
     * });
     * @example
     * Neo.create({
     *     className: 'Neo.button.Base',
     *     iconCls  : 'fa fa-home',
     *     text     : 'Home'
     * });
     * @memberOf module:Neo
     * @param {String|Object|Neo.core.Base} className
     * @param {Object}                      [config]
     * @returns {Neo.core.Base|null} The new class instance
     * @tutorial 02_ClassSystem
     */
    create(className, config) {
        let type = Neo.typeOf(className),
            cls, instance;

        if (type === 'NeoClass') {
            cls = className
        } else {
            if (type === 'Object') {
                config = className;

                if (!config.className && !config.module) {
                    // using console.error instead of throw to show the config object
                    console.error('Class created with object configuration missing className or module property', config);
                    return null
                }

                className = config.className || config.module.prototype.className
            }

            if (!exists(className)) {
                throw new Error('Class ' + className + ' does not exist')
            }

            cls = Neo.ns(className)
        }

        instance = new cls();

        instance.construct(config);
        instance.onConstructed();
        instance.onAfterConstructed();
        instance.init();

        return instance
    },

    /**
     * Defines a reactive configuration property on a target object (prototype or instance).
     * This method creates getters and setters that fully participate in Neo.mjs's reactive config system,
     * including lifecycle hooks.
     *
     * @param {Neo.core.Base}  target        - The instance or prototype on which to define the config.
     * @param {String}         key           - The name of the config property (without the '_' suffix).
     * @param {*}             [initialValue] - The initial value for the config.
     */
    createConfig(target, key, initialValue) {
        if (Neo.hasPropertySetter(target, key)) {
            throw(
`Invalid config in ${target.className}: '${key}_'. The config '${key}' is already defined as reactive by a parent class.
To override the default value, use '${key}' (without the underscore) in your static config.
If you intended to create custom logic, use the 'beforeGet${Neo.capitalize(key)}()', 'beforeSet${Neo.capitalize(key)}()', and 'afterSet${Neo.capitalize(key)}()' hooks instead of redefining the config.`
            )
        }

        const
            _key      = '_' + key,
            uKey      = key[0].toUpperCase() + key.slice(1),
            beforeGet = 'beforeGet' + uKey,
            beforeSet = 'beforeSet' + uKey,
            afterSet  = 'afterSet'  + uKey;

        Neo[getSetCache] ??= {};

        if (!Neo[getSetCache][key]) {
            // Public Descriptor
            Neo[getSetCache][key] = {
                get() {
                    let me        = this,
                        config    = me.getConfig(key),
                        hasNewKey = Object.hasOwn(me[configSymbol], key),
                        newKey    = me[configSymbol][key],
                        value     = hasNewKey ? newKey : me[_key];

                    if (value instanceof Date) {
                        value = new Date(value.valueOf());
                    }
                    // new, explicit opt-in path
                    else if (config.cloneOnGet) {
                        const {cloneOnGet} = config;

                        if (cloneOnGet === 'deep') {
                            value = Neo.clone(value, true, true);
                        } else if (cloneOnGet === 'shallow') {
                            const type = Neo.typeOf(value);

                            if (type === 'Array') {
                                value = [...value];
                            } else if (type === 'Object') {
                                value = {...value};
                            }
                        }
                    }
                    // legacy behavior
                    else if (Array.isArray(value)) {
                        value = [...value];
                    }

                    if (hasNewKey) {
                        me[key] = value;  // We do want to trigger the setter => beforeSet, afterSet
                        value = me[_key]; // Return the value parsed by the setter
                        delete me[configSymbol][key]
                    }

                    if (typeof me[beforeGet] === 'function') {
                        value = me[beforeGet](value)
                    }

                    return value
                },
                set(value) {
                    if (value === undefined) return;

                    const config = this.getConfig(key);
                    if (!config) return;

                    let me              = this,
                        oldValue        = config.get(), // Get the old value from the Config instance
                        {EffectManager} = Neo.core,
                        isNewBatch      = !EffectManager?.isPaused();

                    // If a config change is not triggered via `core.Base#set()`, honor changes inside hooks.
                    isNewBatch && EffectManager?.pause();

                    try {
                        // 1. Prevent infinite loops:
                        // Immediately remove the pending value from the configSymbol to prevent a getter from
                        // recursively re-triggering this setter.
                        delete me[configSymbol][key];

                        switch (config.clone) {
                            case 'deep':
                                value = Neo.clone(value, true, true);
                                break;
                            case 'shallow':
                                value = Neo.clone(value, false, true);
                                break;
                        }

                        // 2. Create a temporary state for beforeSet hooks:
                        // Set the new value directly on the private backing property. This allows any beforeSet
                        // hook to access the new value of this and other configs within the same `set()` call.
                        me[_key] = value;

                        if (typeof me[beforeSet] === 'function') {
                            value = me[beforeSet](value, oldValue);

                            // If they don't return a value, that means no change
                            if (value === undefined) {
                                // Restore the original value if the update is canceled.
                                me[_key] = oldValue;
                                return
                            }
                        }

                        // 3. Restore state for change detection:
                        // Revert the private backing property to its original value. This is crucial for the
                        // `config.set()` method to correctly detect if the value has actually changed.
                        me[_key] = oldValue;

                        // 4. Finalize the change:
                        // The config.set() method performs the final check and, if the value changed,
                        // triggers afterSet hooks and notifies subscribers.
                        if (config.set(value)) {
                            me[afterSet]?.(value, oldValue);
                            me.afterSetConfig?.(key, value, oldValue)
                        }
                    } finally {
                        // End the batch only if this setter started it.
                        isNewBatch && EffectManager?.resume()
                    }
                }
            };

            // Private Descriptor
            Neo[getSetCache][_key] = {
                get() {
                    return this.getConfig(key)?.get()
                },
                set(value) {
                    this.getConfig(key)?.setRaw(value)
                }
            }
        }

        Object.defineProperty(target, key,  Neo[getSetCache][key]);
        Object.defineProperty(target, _key, Neo[getSetCache][_key]);

        if (initialValue !== undefined) {
            target[key] = initialValue
        }
    },

    /**
     *
     */
    emptyFn() {},

    /**
     * Ensures a class is assigned to the Neo namespace only once, preventing duplicates.
     * This is a lightweight version of `Neo.setupClass` for simple classes
     * that do not extend `Neo.core.Base`.
     * It follows a "first one wins" strategy.
     *
     * @param {Function|Object} module    - The class constructor or singleton object to register.
     * @param {String}          classPath - The fully qualified name (e.g., 'Neo.core.Config').
     * @param {Function}       [onFirst]  - An optional callback that runs only the first time the class is registered.
     * @returns {Function|Object} The class or singleton from the Neo namespace (either the existing one or the newly set one).
     */
    gatekeep(module, classPath, onFirst) {
        const existingClass = Neo.ns(classPath, false);

        if (existingClass) {
            return existingClass
        }

        const
            nsArray   = classPath.split('.'),
            className = nsArray.pop(),
            parentNs  = Neo.ns(nsArray, true);

        parentNs[className] = module;

        onFirst?.(module);

        return parentNs[className]
    },

    /**
     * Checks if there is a set method for a given property key inside the prototype chain
     * @memberOf module:Neo
     * @param {Neo.core.Base} proto The top level prototype of a class
     * @param {String}        key   The property key to test
     * @returns {Boolean}
     */
    hasPropertySetter(proto, key) {
        let descriptor;

        while (proto.__proto__) {
            descriptor = Object.getOwnPropertyDescriptor(proto, key);

            if (typeof descriptor === 'object' && typeof descriptor.set === 'function') {
                return true
            }

            proto = proto.__proto__
        }

        return false
    },

    /**
     * Deep-merges a source object into a target object
     * @memberOf module:Neo
     * @param {Object} target
     * @param {Object} source
     * @param {Object} defaults
     * @returns {Object} target
     */
    merge(target, source, defaults) {
        if (defaults) {
            return Neo.merge(Neo.merge(target, defaults), source)
        }

        if (!target) {
            return source
        }

        for (const key in source) {
            const value = source[key];

            if (Neo.typeOf(value) === 'Object') {
                target[key] = Neo.merge(target[key] || {}, value)
            } else {
                target[key] = value
            }
        }

        return target
    },

    /**
     * Merges a new value into an existing config value based on a specified strategy.
     * This method is used during instance creation to apply merge strategies defined in config descriptors.
     * @param {any} defaultValue - The default value of the config (from static config).
     * @param {any} instanceValue - The value provided during instance creation.
     * @param {string|Function} strategy - The merge strategy: 'shallow', 'deep', 'replace', or a custom function.
     * @returns {any} The merged value.
     */
    mergeConfig(defaultValue, instanceValue, strategy) {
        const
            defaultValueType  = Neo.typeOf(defaultValue),
            instanceValueType = Neo.typeOf(instanceValue);

        if (strategy === 'shallow') {
            if (defaultValueType === 'Object' && instanceValueType === 'Object') {
                return {...defaultValue, ...instanceValue}
            }
        } else if (strategy === 'deep') {
            if (defaultValueType === 'Object' && instanceValueType === 'Object') {
                return Neo.merge(Neo.clone(defaultValue, true), instanceValue)
            }
        } else if (typeof strategy === 'function') {
            return strategy(defaultValue, instanceValue)
        }

        // Default to 'replace' or if strategy is not recognized
        return instanceValue
    },

    /**
     * Maps a className string into a given or global namespace
     * @example
     * Neo.ns('Neo.button.Base', true);
     * // =>
     * // globalThis.Neo             = globalThis.Neo             || {};
     * // globalThis.Neo.button      = globalThis.Neo.button      || {};
     * // globalThis.Neo.button.Base = globalThis.Neo.button.Base || {};
     * // return globalThis.Neo.button.Base;
     *
     * @memberOf module:Neo
     * @param {String[]|String} names        The class name string containing dots or an Array of the string parts
     * @param {Boolean}         create=false Set create to true to create empty objects for non-existing parts
     * @param {Object}          [scope]      Set a different starting point as globalThis
     * @returns {Object} reference to the toplevel namespace
     */
    ns(names, create=false, scope) {
        names = Array.isArray(names) ? names : names.split('.');

        return names.reduce((prev, current) => {
            if (create && !prev[current]) {
                prev[current] = {}
            }

            if (prev) {
                return prev[current]
            }
        }, scope || globalThis)
    },

    /**
     * Extended version of Neo.ns() which supports mapping into arrays.
     * @memberOf module:Neo
     * @param {Array|String} names        The class name string containing dots or an Array of the string parts
     * @param {Boolean}      create=false Set create to true to create empty objects for non-existing parts
     * @param {Object}       [scope]      Set a different starting point as globalThis
     * @returns {Object} reference to the toplevel namespace
     */
    nsWithArrays(names, create=false, scope) {
        names = Array.isArray(names) ? names : names.split('.');

        return names.reduce((prev, current) => {
            if (create && !prev[current]) {
                if (current.endsWith(']')) {
                    return createArrayNs(true, current, prev)
                }

                prev[current] = {}
            }

            if (prev) {
                if (current.endsWith(']')) {
                    return createArrayNs(false, current, prev)
                }

                return prev[current]
            }
        }, scope || globalThis)
    },

    /**
     * Creates instances of Neo classes using their ntype instead of the class name
     * @example
     * Neo.ntype('button' {
     *     iconCls: 'fa fa-home',
     *     text   : 'Home'
     * });
     * @example
     * Neo.ntype({
     *     ntype  : 'button',
     *     iconCls: 'fa fa-home',
     *     text   : 'Home'
     * });
     * @memberOf module:Neo
     * @param {String|Object} ntype
     * @param {Object}        [config]
     * @returns {Neo.core.Base}
     * @see {@link module:Neo.create create}
     */
    ntype(ntype, config) {
        if (typeof ntype === 'object') {
            config = ntype;

            if (!config.ntype) {
                throw new Error('Class defined with object configuration missing ntype property. ' + config.ntype)
            }

            ntype = config.ntype
        }

        let className = Neo.ntypeMap[ntype];

        if (!className) {
            throw new Error('ntype ' + ntype + ' does not exist')
        }

        return Neo.create(className, config)
    },

    /**
     * This is the final and most critical step in the Neo.mjs class creation process.
     * It is called at the end of every class module definition.
     *
     * `setupClass` performs several key operations:
     * 1.  **Mixed-Environment Gatekeeper:** It first checks if the class's namespace already exists.
     *     If it does, it immediately returns the existing class. This is the crucial "first comes wins"
     *     strategy that enables Neo.mjs to safely combine environments. For example, a bundled
     *     `dist/production` app can dynamically load an unbundled module from `dist/esm` at runtime.
     *     If that module imports a class already present in the main bundle, this check ensures the
     *     original, bundled class is used, preventing conflicts and maintaining application integrity.
     * 1.  **Configuration Merging:** It traverses the prototype chain to merge `static config`
     *     objects from parent classes into the current class, creating a unified `config`.
     * 2.  **Applying Overwrites:** It calls the static `applyOverwrites()` method on the class,
     *     allowing the global `Neo.overwrites` object to modify the class's default prototype
     *     configs. This is a key mechanism for external theming and configuration.
     * 3.  **Reactive Getter/Setter Generation:** For any config ending with an underscore (e.g., `myConfig_`),
     *     it automatically generates the corresponding public getter and setter. This enables optional
     *     lifecycle hooks that are called automatically if implemented on the class:
     *     - `beforeGetMyConfig(value)`
     *     - `beforeSetMyConfig(newValue, oldValue)`
     *     - `afterSetMyConfig(newValue, oldValue)`
     * 4.  **Prototype-based Configs:** Non-reactive configs (without an underscore) are set
     *     directly on the prototype for memory efficiency.
     * 5.  **Mixin Application:** It processes the `mixins` config to blend in functionality from
     *     other classes.
     * 6.  **Namespace Registration:** It registers the class in the global `Neo` namespace.
     * 7.  **Singleton Instantiation:** If the class is configured as a singleton, it creates the
     *     single instance.
     *
     * @memberOf module:Neo
     * @template T
     * @param {T} cls The class constructor to process.
     * @returns {T} The processed and finalized class constructor or singleton instance.
     */
    setupClass(cls) {
        let baseConfig            = null,
            baseConfigDescriptors = null,
            ntypeChain            = [],
            {ntypeMap}            = Neo,
            proto                 = cls.prototype || cls,
            ns                    = Neo.ns(proto.constructor.config.className, false),
            protos                = [],
            cfg, config, configDescriptors, ctor, hierarchyInfo, ntype;

        /*
         * If the namespace already exists, directly return it.
         * This can happen when using different versions of Neo.mjs
         * => Especially singletons (IdGenerator) must stay unique.
         *
         * This can also happen when using different environments of neo.mjs in parallel.
         * Example: code.LivePreview running inside a dist/production app.
         */
        if (ns) {
            return ns
        }

        // Traverse the prototype chain to collect inherited configs and descriptors
        while (proto.__proto__) {
            ctor = proto.constructor;

            // If a class in the prototype chain has already had its config applied,
            // we can use its pre-processed config and descriptors as a base.
            if (Object.hasOwn(ctor, 'classConfigApplied')) {
                baseConfig            = Neo.clone(ctor.config, true);
                baseConfigDescriptors = Neo.clone(ctor.configDescriptors, true);
                ntypeChain            = [...ctor.ntypeChain];
                break
            }

            protos.unshift(proto);
            proto = proto.__proto__
        }

        // Initialize accumulated config and descriptors
        config            = baseConfig            || {};
        configDescriptors = baseConfigDescriptors || {};

        // Process each class in the prototype chain (from top to bottom)
        protos.forEach(element => {
            let mixins;

            ctor = element.constructor;
            cfg  = ctor.config || {};

            if (Neo.overwrites) {
                ctor.applyOverwrites?.(cfg)
            }

            // Process each config property defined in the current class's static config
            Object.entries(cfg).forEach(([key, value]) => {
                const
                    isReactive = key.slice(-1) === '_',
                    baseKey    = isReactive ? key.slice(0, -1) : key;

                // 1. Handle descriptors: If the value is a descriptor object, store it.
                //    The 'value' property of the descriptor is then used as the actual config value.
                if (Neo.isObject(value) && value[_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_1__.isDescriptor] === true) {
                    ctor.configDescriptors ??= {};
                    ctor.configDescriptors[baseKey] = Neo.clone(value, true); // Deep clone to prevent mutation
                    value = value.value // Use the descriptor's value as the config value
                }

                // 2. Handle reactive vs. non-reactive configs: Generate getters/setters for reactive configs.
                if (isReactive) {
                    delete cfg[key];      // Remove original key with underscore
                    cfg[baseKey] = value; // Use the potentially modified value
                    Neo.createConfig(element, baseKey)
                }
                // This part handles non-reactive configs (including those that were descriptors)
                // If no property setter exists, define it directly on the prototype.
                else if (!Neo.hasPropertySetter(element, key)) {
                    Object.defineProperty(element, key, {
                        enumerable: true,
                        value,
                        writable  : true
                    })
                }
            });

            // Merge configDescriptors: Apply "first-defined wins" strategy.
            // If a descriptor for a key already exists (from a parent class), it is not overwritten.
            if (ctor.configDescriptors) {
                for (const key in ctor.configDescriptors) {
                    if (!Object.hasOwn(configDescriptors, key)) {
                        configDescriptors[key] = Neo.clone(ctor.configDescriptors[key], true) // Deep clone for immutability
                    }
                }
            }

            // Process ntype and ntypeChain
            if (Object.hasOwn(cfg, 'ntype')) {
                ntype = cfg.ntype;

                ntypeChain.unshift(ntype);

                // Running the docs app inside a workspace can pull in the same classes from different roots,
                // so we want to check for different class names as well
                if (Object.hasOwn(ntypeMap, ntype) && cfg.className !== ntypeMap[ntype]) {
                    throw new Error(`ntype conflict for '${ntype}' inside the classes:\n${ntypeMap[ntype]}\n${cfg.className}`)
                }

                ntypeMap[ntype] = cfg.className
            }

            // Process mixins
            mixins = Object.hasOwn(config, 'mixins') && config.mixins || [];

            if (ctor.observable) {
                mixins.push('Neo.core.Observable')
            }

            if (Object.hasOwn(cfg, 'mixins') && Array.isArray(cfg.mixins) && cfg.mixins.length > 0) {
                mixins.push(...cfg.mixins)
            }

            if (mixins.length > 0) {
                applyMixins(ctor, mixins, cfg);

                if (Neo.ns('Neo.core.Observable', false, ctor.prototype.mixins)) {
                    ctor.observable = true
                }
            }

            delete cfg.mixins;
            delete config.mixins;

            // Hierarchical merging of static config values based on descriptors.
            // This ensures that values are merged (e.g., shallow/deep) instead of simply overwritten.
            Object.entries(cfg).forEach(([key, value]) => {
                const descriptor = configDescriptors[key];

                if (descriptor?.merge) {
                    config[key] = Neo.mergeConfig(config[key], value, descriptor.merge)
                } else {
                    config[key] = value
                }
            });

            // Assign final processed config and descriptors to the class constructor
            Object.assign(ctor, {
                classConfigApplied: true,
                config            : Neo.clone(config,            true), // Deep clone final config for immutability
                configDescriptors : Neo.clone(configDescriptors, true), // Deep clone final descriptors for immutability
                isClass           : true,
                ntypeChain
            });

            // Apply to global namespace if not a singleton
            !config.singleton && this.applyToGlobalNs(cls)
        });

        proto = cls.prototype || cls;

        // Add is<Ntype> flags to the prototype
        ntypeChain.forEach(ntype => {
            proto[`is${Neo.capitalize(Neo.camel(ntype))}`] = true
        });

        // If it's a singleton, create and apply the instance to the global namespace
        if (proto.singleton) {
            cls = Neo.create(cls);
            Neo.applyToGlobalNs(cls)
        }

        // Add class hierarchy information to the manager or a temporary map
        hierarchyInfo = {
            className      : proto.className,
            module         : cls,
            ntype          : Object.hasOwn(proto, 'ntype') ? proto.ntype : null,
            parentClassName: proto.__proto__?.className || null
        };

        if (Neo.manager?.ClassHierarchy) {
            Neo.manager.ClassHierarchy.add(hierarchyInfo)
        } else {
            Neo.classHierarchyMap ??= {};
            Neo.classHierarchyMap[proto.className] = hierarchyInfo
        }

        return cls
    },

    /**
     * @param {*} item
     * @returns {String|null}
     */
    typeOf(item) {
        // Return null for null or undefined
        if (item == null) {
            return null
        }

        return typeDetector[typeof item]?.(item) || item.constructor?.name
    }
}, Neo);

/**
 * List of class properties which are not supposed to get mixed into other classes
 * @type {string[]}
 * @private
 */
const ignoreMixin = [
    '_name',
    'classConfigApplied',
    'className',
    'constructor',
    'id',
    'isClass',
    'mixin',
    'ntype',
    'observable'
],

    charsRegex         = /\d+/g,
    extractArraysRegex = /^(\w+)\s*((?:\[\s*\d+\s*\]\s*)*)$/;

/**
 * @param {Neo.core.Base} cls
 * @param {Array}         mixins
 * @param {Object}        classConfig
 * @private
 */
function applyMixins(cls, mixins, classConfig) {
    if (!Array.isArray(mixins)) {
        mixins = [mixins];
    }

    let i            = 0,
        len          = mixins.length,
        mixinClasses = {},
        mixin, mixinCls, mixinProto;

    for (;i < len;i++) {
        mixin = mixins[i];

        if (mixin.isClass) {
            mixinProto = mixin.prototype;
            mixinCls   = Neo.ns(mixinProto.className)
        } else {
            if (!exists(mixin)) {
                throw new Error('Attempting to mixin an undefined class: ' + mixin + ', ' + cls.prototype.className)
            }

            mixinCls   = Neo.ns(mixin);
            mixinProto = mixinCls.prototype
        }

        mixinProto.className.split('.').reduce(mixReduce(mixinCls), mixinClasses);

        Object.entries(Object.getOwnPropertyDescriptors(mixinProto)).forEach(mixinProperty(cls.prototype, mixinProto, classConfig))
    }

    cls.prototype.mixins = mixinClasses // todo: we should do a deep merge
}

/**
 * @param {Boolean} create
 * @param {Object}  current
 * @param {Object}  prev
 * @returns {Object|undefined}
 */
function createArrayNs(create, current, prev) {
    let arrDetails = parseArrayFromString(current),
        i          = 1,
        len        = arrDetails.length,
        arrItem, arrRoot;

    if (create) {
        prev[arrDetails[0]] = arrRoot = prev[arrDetails[0]] || []
    } else {
        arrRoot = prev[arrDetails[0]]
    }

    if (!arrRoot) return;

    for (; i < len; i++) {
        arrItem = parseInt(arrDetails[i]);

        if (create) {
            arrRoot[arrItem] = arrRoot[arrItem] || {}
        }

        arrRoot = arrRoot[arrItem]
    }

    return arrRoot
}

/**
 * Checks if the class name exists inside the Neo or app namespace
 * @param {String} className
 * @returns {Boolean}
 * @private
 */
function exists(className) {
    try {
        return !!className.split('.').reduce((prev, current) => {
            return prev[current]
        }, globalThis)
    } catch(e) {
        return false
    }
}

/**
 * @param {Neo.core.Base} proto
 * @param {Neo.core.Base} mixinProto
 * @param {Object}        classConfig
 * @returns {Function}
 * @private
 */
function mixinProperty(proto, mixinProto, classConfig) {
    return function([key, descriptor]) {
        if (ignoreMixin.includes(key)) return;

        // Mixins must not override existing class properties with a setter
        if (Neo.hasPropertySetter(proto, key)) return;

        // Reactive neo configs, or public class fields defined via get() AND set()
        if (descriptor.get && descriptor.set) {
            Neo.createConfig(proto, key);

            const mixinClassConfig = mixinProto.constructor.config;

            if (Object.hasOwn(mixinClassConfig, key)) {
                classConfig[key] = mixinClassConfig[key];
            }

            return
        }

        if (proto[key]?._from) {
            if (mixinProto.className === proto[key]._from) {
                console.warn('Mixin set multiple times or already defined on a Base Class', proto.className, mixinProto.className, key);
                return
            }

            throw new Error(
                `${proto.className}: Multiple mixins defining same property (${mixinProto.className}, ${proto[key]._from}) => ${key}`
            )
        }

        proto[key] = mixinProto[key];

        Object.getOwnPropertyDescriptor(proto, key)._from = mixinProto.className;

        if (typeof proto[key] === 'function') {
            proto[key]._name = key
        }
    }
}

/**
 * @param mixinCls
 * @returns {Function}
 * @private
 */
function mixReduce(mixinCls) {
    return (prev, current, idx, arr) => {
        return prev[current] = idx !== arr.length -1 ? prev[current] || {} : mixinCls
    }
}

/**
 * @param {String} str
 * @returns {Function}
 * @private
 */
function parseArrayFromString(str) {
    return (extractArraysRegex.exec(str) || [null]).slice(1).reduce(
        (fun, args) => [fun].concat(args.match(charsRegex))
    )
}

Neo.config ??= {};

Neo.assignDefaults(Neo.config, _DefaultConfig_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo);


/***/ }),

/***/ "./src/collection/Base.mjs":
/*!*********************************!*\
  !*** ./src/collection/Base.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _Filter_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Filter.mjs */ "./src/collection/Filter.mjs");
/* harmony import */ var _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Logger.mjs */ "./src/util/Logger.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _Sorter_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Sorter.mjs */ "./src/collection/Sorter.mjs");







const countMutations   = Symbol('countMutations'),
      isFiltered       = Symbol('isFiltered'),
      isSorted         = Symbol('isSorted'),
      silentUpdateMode = Symbol('silentUpdateMode'),
      toAddArray       = Symbol('toAddArray'),
      toRemoveArray    = Symbol('toRemoveArray'),
      updatingIndex    = Symbol('updatingIndex');

/**
 * @class Neo.collection.Base
 * @extends Neo.core.Base
 * @mixes Neo.core.Observable
 */
class Collection extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.collection.Base'
         * @protected
         */
        className: 'Neo.collection.Base',
        /**
         * @member {String} ntype='collection'
         * @protected
         */
        ntype: 'collection',
        /**
         * When filtering the collection for the first time, allItems will become a new collection for the unfiltered
         * state, using this id as the sourceCollectionId
         * @member {Neo.collection.Base|null} allItems=null
         * @protected
         */
        allItems: null,
        /**
         * True to sort the collection items when adding / inserting new ones
         * @member {Boolean} autoSort=true
         */
        autoSort: true,
        /**
         * Stores the items.length of the items array in use
         * @member {Number} count_=0
         * @reactive
         */
        count_: 0,
        /**
         * Use 'primitive' for default filters, use 'advanced' for filters using a filterBy method
         * which need to iterate over other collection items
         * @member {String} filterMode='primitive'
         */
        filterMode: 'primitive',
        /**
         * An Array containing Neo.util.Filter config objects or instances
         * @member {Array} filters_=[]
         * @reactive
         */
        filters_: [],
        /**
         * @member {Object[]|null} items_=null
         * @reactive
         */
        items_: null,
        /**
         * The unique(!) key property of each collection item
         * @member {String} keyProperty='id'
         */
        keyProperty: 'id',
        /**
         * Adding new items without an id (keyProperty) will use a negative index, which will decrease by -1
         * for each new item
         * @member {Number} keyPropertyIndex=-1
         */
        keyPropertyIndex: -1,
        /**
         * A map containing the key & reference of each collection item for faster access
         * @member {Map} map_=null
         * @protected
         * @reactive
         */
        map_: null,
        /**
         * An internal Array of the sort directions for faster access
         * @member {Array} sortDirections=null
         * @protected
         */
        sortDirections: null,
        /**
         * An internal Array of the sort properties for faster access
         * @member {Array} sortProperties=null
         * @protected
         */
        sortProperties: null,
        /**
         * An Array containing Neo.util.Sorter config objects or instances
         * @member {Array} sorters_=[]
         * @reactive
         */
        sorters_: [],
        /**
         * The id of another collection instance to use as this data source
         * @member {String|null} sourceId_=null
         * @reactive
         */
        sourceId_: null
    }

    /**
     * @param config
     */
    construct(config) {
        super.construct(config);

        let me           = this,
            symbolConfig = {enumerable: false, writable: true};

        me.items = me.items || [];

        Object.defineProperties(me, {
            [countMutations]  : {...symbolConfig, value: false},
            [isFiltered]      : {...symbolConfig, value: false},
            [isSorted]        : {...symbolConfig, value: false},
            [silentUpdateMode]: {...symbolConfig, value: false},
            [toAddArray]      : {...symbolConfig, value: []},
            [toRemoveArray]   : {...symbolConfig, value: []},
            [updatingIndex]   : {...symbolConfig, value: 0}
        });

        if (me.autoSort && me._sorters.length > 0) {
            me.doSort()
        }
    }

    /**
     * Adds one or more items to the end of the collection
     * @param {Array|Object} item The item(s) to add
     * @returns {Object[]} an array containing all added items
     */
    add(item) {
        return this.splice(null, null, item).addedItems
    }

    /**
     * Triggered after the filters config got changed
     * @param {Array} value
     * @param {Array} oldValue
     * @protected
     */
    afterSetFilters(value, oldValue) {
        let me = this;

        value.forEach(filter => {
            if (filter.listenerApplied === false) {
                filter.on('change', me.onFilterChange, me);
                filter.listenerApplied = true
            }
        });

        oldValue && me.filter()
    }

    /**
     * Triggered after the items config got changed
     * @param {Array} value
     * @param {Array} oldValue
     * @protected
     */
    afterSetItems(value, oldValue) {
        if (value) {
            let me            = this,
                {keyProperty} = me,
                i             = 0,
                len           = value.length,
                item;

            for (; i < len; i++) {
                item = value[i];
                me.map.set(item[keyProperty], item)
            }

            me.count = len
        }
    }

    /**
     * Triggered after the sorters config got changed
     * @param {Array} value
     * @param {Array} oldValue
     * @protected
     */
    afterSetSorters(value, oldValue) {
        let me = this;

        me.applySorterConfigs();

        value.forEach(sorter => {
            if (sorter.listenerApplied === false) {
                sorter.on('change', me.onSorterChange, me);
                sorter.listenerApplied = true
            }
        });

        oldValue && me.autoSort && me.doSort()
    }

    /**
     * Triggered after the sourceId config got changed
     * @param {Number|String} value
     * @param {Number|String} oldValue
     * @protected
     */
    afterSetSourceId(value, oldValue) {
        if (value) {
            let me     = this,
                source = Neo.get(value);

            me._items = [...source._items];
            me.map    = new Map(source.map); // creates a clone of the original map

            const listenersConfig = {
                mutate: me.onMutate,
                scope : me
            };

            source.on(listenersConfig);

            if (oldValue) {
                source = Neo.get(oldValue);
                source.un(listenersConfig)
            }
        }
    }

    /**
     * Saves the sort property & direction multiplier of each sorter inside 2 arrays for faster access when sorting
     * @protected
     */
    applySorterConfigs() {
        let me = this;

        me.sortDirections = [];
        me.sortProperties = [];

        me.sorters.forEach(sorter => {
            me.sortDirections.push(sorter.directionMultiplier);
            me.sortProperties.push(sorter.property)
        })
    }

    /**
     * @param {Array} value
     * @param {Array} oldValue
     * @protected
     */
    beforeSetFilters(value, oldValue) {
        if (!Array.isArray(value)) {
            value = value ? [value] : []
        }

        let len = oldValue && oldValue.length || 0,
            hasMatch, i;

        value.forEach((key, index) => {
            if (oldValue) {
                hasMatch = false;
                i        = 0;

                for (; i < len; i++) {
                    if (oldValue[i] === key) {
                        oldValue[i].set({
                            operator: key.operator,
                            property: key.property,
                            value   : key.value
                        });

                        hasMatch = true;
                        break
                    } else if (
                        oldValue[i].operator === (key.operator || '===') &&
                        oldValue[i].property === key.property &&
                        oldValue[i].value    === key.value
                    ) {
                        hasMatch = true;
                        break
                    }
                }
            }

            if (!hasMatch) {
                value[index] = Neo.create(_Filter_mjs__WEBPACK_IMPORTED_MODULE_1__["default"], key)
            } else {
                value[index] = oldValue[i];
                oldValue.splice(i, 1);
                len--
            }
        });

        if (Array.isArray(oldValue)) {
            oldValue.forEach(key => {
                key.destroy();
            })
        }

        return value
    }

    /**
     * @param {Map|null} value
     * @param {Map|null} oldValue
     * @protected
     */
    beforeSetMap(value, oldValue) {
        return !value ? new Map() : value
    }

    /**
     * @param {Array} value
     * @param {Array} oldValue
     * @protected
     */
    beforeSetSorters(value, oldValue) {
        if (!Array.isArray(value)) {
            value = value ? [value] : []
        }

        let len = oldValue?.length || 0,
            hasMatch, i;

        value.forEach((key, index) => {
            if (oldValue) {
                hasMatch = false;
                i        = 0;

                let {direction, property} = key;

                for (; i < len; i++) {
                    if (oldValue[i] === key) {
                        oldValue[i].set({direction, property});

                        hasMatch = true;
                        break
                    } else if (oldValue[i].property === property && oldValue[i].direction === direction) {
                        hasMatch = true;
                        break
                    }
                }
            }

            if (!hasMatch) {
                value[index] = Neo.create(_Sorter_mjs__WEBPACK_IMPORTED_MODULE_5__["default"], key)
            } else {
                value[index] = oldValue[i];
                oldValue.splice(i, 1);
                len--
            }
        });

        oldValue?.forEach(key => {
            key.destroy()
        });

        return value
    }

    /**
     * @param opts
     * @protected
     */
    cacheUpdate(opts) {
        // disabled for now
        // console.log('cacheUpdate', opts, this[toAddArray]);
        return;

        // removed by dead control flow
{}

        // removed by dead control flow
{}
    }

    /**
     * Removes all items and clears the map
     */
    clear() {
        this.splice(0, this.count)
    }

    /**
     * Clears all current filters and optionally restores the original ones in case they existed.
     * @param {boolean} [restoreOriginalFilters=false]
     */
    clearFilters(restoreOriginalFilters) {
        this.filters = restoreOriginalFilters ? Neo.clone(this.originalConfig.filters, true, true) : null
    }

    /**
     * Removes all items and clears the map, without firing a mutate event
     */
    clearSilent() {
        let me = this;

        me._items.splice(0, me.count);
        me.map.clear()
    }

    /**
     * Clears all current sorters and optionally restores the original ones in case they existed.
     * Without restoreInitialState as true this will not affect the current sorting of this collection.
     * @param {boolean} [restoreOriginalSorters=false]
     */
    clearSorters(restoreOriginalSorters) {
        this.sorters = restoreOriginalSorters ? Neo.clone(this.originalConfig.sorters, true, true) : null
    }

    /**
     * @returns {Neo.collection.Base} The cloned collection
     */
    clone() {
        let me      = this,
            config  = Neo.clone(me.originalConfig, true),
            filters = me._filters || [],
            sorters = me._sorters || [];

        // Ensure the keyProperty does not get lost.
        config.keyProperty = me.keyProperty;

        delete config.id;
        delete config.filters;
        delete config.items;
        delete config.sorters;

        if (me._items.length > 0) {
            config.items  = [...me._items];
            config.count = config.items.length;
        }

        config.filters = [];
        config.sorters = [];

        // todo: filters & sorters should push their current state and not the original one

        filters.forEach(function(filter) {
            config.filters.push(filter.originalConfig)
        });

        sorters.forEach(function(sorter) {
            config.sorters.push(sorter.originalConfig)
        });

        return Neo.create(Collection, config)
    }

    /**
     * Clears the map & items array before the super call
     */
    destroy() {
        let me = this;

        me._items.splice(0, me._items.length);
        me.map.clear();

        super.destroy()
    }

    /**
     *
     * @param {Object[]} items=this._items
     * @param {Boolean} silent=false
     * @protected
     */
    doSort(items=this._items, silent=false) {
        let me                = this,
            previousItems     = [...items],
            {sorters, sortDirections, sortProperties} = me,
            countSorters      = sortProperties.length || 0,
            hasSortByMethod   = false,
            hasTransformValue = false,
            i, mappedItems, obj, sorter, sortProperty, sortValue;

        if (countSorters > 0) {
            sorters.forEach(key => {
                if (key.sortBy) {
                    hasSortByMethod = true
                }

                if (key.useTransformValue) {
                    hasTransformValue = true
                }
            });

            if (hasSortByMethod) {
                me._items.sort((a, b) => {
                    i = 0;

                    for (; i < countSorters; i++) {
                        sorter    = sorters[i];
                        sortValue = sorter[sorter.sortBy ? 'sortBy' : 'defaultSortBy'](a, b);

                        if (sortValue !== 0) {
                            return sortValue
                        }
                    }

                    return 0
                })
            } else {
                if (hasTransformValue) {
                    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Sorting_with_map
                    mappedItems = items.map((item, index) => {
                        obj = {index};
                        i   = 0;

                        for (; i < countSorters; i++) {
                            if (sorters[i].useTransformValue) {
                                obj[sortProperties[i]] = sorters[i].transformValue(item[sortProperties[i]])
                            } else {
                                obj[sortProperties[i]] = item[sortProperties[i]]
                            }
                        }

                        return obj
                    });
                } else {
                    mappedItems = items
                }

                mappedItems.sort((a, b) => {
                    i = 0;

                    for (; i < countSorters; i++) {
                        sortProperty = sortProperties[i];

                        if (a[sortProperty] > b[sortProperty]) {
                            return 1 * sortDirections[i]
                        }

                        if (a[sortProperty] < b[sortProperty]) {
                            return -1 * sortDirections[i]
                        }
                    }

                    return 0
                });

                if (hasTransformValue) {
                    me._items = mappedItems.map(el => {
                        return items[el.index]
                    })
                }
            }
        }

        me[isSorted] = countSorters > 0;

        if (!silent && me[updatingIndex] === 0) {
            me.fire('sort', {
                items: me._items,
                previousItems,
                scope: me
            })
        }
    }

    /**
     * Resumes the collection events.
     * If you started an update using the startSilentUpdateMode flag,
     * you must use the endSilentUpdateMode param for this call.
     * Using the endSilentUpdateMode param will not fire a mutation event.
     * @param {Boolean} [endSilentUpdateMode]
     * @see {@link Neo.collection.Base#startUpdate startUpdate}
     */
    endUpdate(endSilentUpdateMode) {
        const me = this;

        if (me[updatingIndex] > 0) {
            me[updatingIndex]--
        }

        if (endSilentUpdateMode) {
            me[silentUpdateMode] = false
        } else {
            me.fire('mutate', {
                addedItems  : me[toAddArray],
                removedItems: me[toRemoveArray]
            });

            me[toAddArray]   .splice(0, me[toAddArray]   .length);
            me[toRemoveArray].splice(0, me[toRemoveArray].length)
        }
    }

    /**
     * Needed for remote filtering
     * @returns {Object[]}
     */
    exportFilters() {
        let me      = this,
            filters = [],
            filter;

        me.filters?.forEach(key => {
            filter = key.export();

            filter && filters.push(filter)
        });

        return filters
    }

    /**
     * Needed for remote sorting
     * @returns {Object[]}
     */
    exportSorters() {
        let me      = this,
            sorters = [],
            sorter;

        me.sorters?.forEach(key => {
            sorter = key.export();

            sorter && sorters.push(sorter)
        });

        return sorters
    }

    /**
     * @protected
     */
    filter() {
        let me              = this,
            filters         = me._filters,
            countAllFilters = filters.length,
            countFilters    = 0,
            items           = me.allItems?._items || me._items,
            i               = 0,
            countItems      = items.length,
            filteredItems   = [],
            needsSorting    = false,
            oldItems        = [...me._items],
            config, isIncluded, item, j, tmpItems;

        for (; i < countAllFilters; i++) {
            if (!filters[i].disabled) {
                countFilters++
            }
        }

        if (countFilters === 0 && me.allItems) {
            if (me.sorters.length > 0) {
                needsSorting = true
            }

            me.clearSilent();

            me.items = [...me.allItems._items]
        } else {
            if (!me.allItems) {
                config = {...me.originalConfig};

                delete config.filters;
                delete config.items;
                delete config.sorters;

                me.allItems = Neo.create(Collection, {
                    ...Neo.clone(config, true, true),
                    id         : me.id + '-all',
                    items      : [...me._items], // Initialize with a shallow copy of current items
                    keyProperty: me.keyProperty,
                    sourceId   : me.id
                })
            }

            me.map.clear();

            if (me.filterMode === 'primitive') {
                // using for loops on purpose -> performance
                for (i = 0; i < countItems; i++) {
                    isIncluded = true;
                    item       = items[i];
                    j          = 0;

                    for (; j < countAllFilters; j++) {
                        if (filters[j].isFiltered(item, items, items)) {
                            isIncluded = false;
                            break
                        }
                    }

                    if (isIncluded) {
                        filteredItems.push(item);
                        me.map.set(item[me.keyProperty], item)
                    }
                }

                me._items = filteredItems // silent update, the map is already in place
            } else {
                filteredItems = [...items];

                for (j=0; j < countAllFilters; j++) {
                    tmpItems = [];

                    for (i = 0; i < countItems; i++) {
                        if (!filters[j].isFiltered(filteredItems[i], filteredItems, items)) {
                            tmpItems.push(filteredItems[i])
                        }
                    }

                    filteredItems = [...tmpItems];
                    countItems    = filteredItems.length
                }

                me.items = filteredItems // update the map
            }
        }

        me[isFiltered] = countFilters !== 0;

        if (needsSorting) {
            me.doSort(me.items, true)
        }

        me.count = me.items.length;

        me.fire('filter', {
            isFiltered: me[isFiltered],
            items     : me.items,
            oldItems,
            scope     : me
        })
    }

    /**
     * Returns items which match the property and value.
     * Properties can contain dots for namespaces => find('vdom.id', 'neo-vnode-1')
     * @param {Object|String} property
     * @param {String|Number} [value] Only required in case the first param is a string
     * @param {Boolean} returnFirstMatch=false
     * @returns {Object|Object[]}
     *     returnFirstMatch=false: Returns an empty Array in case no items are found
     *     returnFirstMatch=true:  Returns the first found item or null
     */
    find(property, value, returnFirstMatch=false) {
        let me               = this,
            items            = [],
            isObjectProperty = me.isItem(property),
            item, matchArray, propertiesArray, propertiesLength;

        if (isObjectProperty) {
            propertiesArray  = Object.entries(property);
            propertiesLength = propertiesArray.length;
        }

        for (item of me.items) {
            if (isObjectProperty) {
                matchArray = [];

                propertiesArray.forEach(([key, value]) => {
                    if (Neo.ns(key, false, item) === value) {
                        matchArray.push(true)
                    }
                });

                if (matchArray.length === propertiesLength) {
                    if (returnFirstMatch) {
                        return item
                    }

                    items.push(item)
                }
            } else if (Neo.ns(property, false, item) === value) {
                if (returnFirstMatch) {
                    return item
                }

                items.push(item)
            }
        }

        return returnFirstMatch ? null : items
    }

    /**
     * Returns all items in the collection for which the passed function returns true
     * @param {function} fn The function to run for each item inside the start-end range. Return true for a match.
     * @param {Object} fn.item The current collection item
     * @param {Object} scope=this The scope in which the passed function gets executed
     * @param {Number} start=0 The start index
     * @param {Number} end=this.count The end index (up to, last value excluded)
     * @returns {Array} Returns an empty Array in case no items are found
     */
    findBy(fn, scope=this, start=0, end=this.count) {
        let me    = this,
            items = [],
            i     = start;

        for (; i < end; i++) {
            if (fn.call(scope, me.items[i])) {
                items.push(me.items[i])
            }
        }

        return items
    }

    /**
     * Returns the first item which matches the property and value
     * @param {Object|String} property
     * @param {Number|String} [value] Only required in case the first param is a string
     * @returns {Object} Returns the first found item or null
     */
    findFirst(property, value) {
        return this.find(property, value, true)
    }

    /**
     * Returns the first item inside the collection
     * @returns {Object}
     */
    first() {
        return this._items[0]
    }

    /**
     * Returns the object associated to the key, or null if there is none.
     * @param {Number|String} key
     * @returns {Object|null}
     */
    get(key) {
        return this.map.get(key) || null
    }

    /**
     * Returns the item for a given index
     * @param {Number} index
     * @returns {Object|undefined}
     */
    getAt(index) {
        return this._items[index]
    }

    /**
     * Returns the config value of this.count
     * @returns {Number}
     * @deprecated Use `this.count` directly instead.
     */
    getCount() {
        return this._count || 0 // skipping beforeGetCount() on purpose
    }

    /**
     * @returns {Number}
     */
    getCountMutations() {
        return this[countMutations]
    }

    /**
     * Returns the first matching filter for the given property config
     * @param {String} property
     * @returns {Neo.collection.Filter|null}
     */
    getFilter(property) {
        let filters = this.filters || [],
            i       = 0,
            len     = filters.length;

        for (; i < len; i++) {
            if (filters[i].property === property) {
                return filters[i]
            }
        }

        return null
    }

    /**
     * Returns the key for a given index
     * @param {Number} index
     * @returns {Number|String|undefined}
     */
    getKeyAt(index) {
        let item = this._items[index];
        return item?.[this.keyProperty]
    }

    /**
     * Returns a shallow copy of a portion of the items array
     * @param {Number} [start] Zero-based index at which to begin extraction.
     * @param {Number} [end] Zero-based index before which to end extraction (extracts up to but not including end).
     * @returns {Array}
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice
     */
    getRange(start, end) {
        return this._items.slice(start, end)
    }

    /**
     * Returns the Source Collection in case the sourceCollectionId config was set
     * @returns {Neo.collection.Base|undefined}
     */
    getSource() {
        return this.sourceId && Neo.get(this.sourceId)
    }

    /**
     * Returns a boolean asserting whether a value has been associated to the key in the Collection or not
     * @param {Number|String} key
     * @returns {Boolean}
     */
    has(key) {
        return this.map.has(key)
    }

    /**
     * Returns a boolean asserting whether an item exists in the Collection or not
     * @param {Object} item
     * @returns {Boolean}
     */
    hasItem(item) {
        return this.map.has(item[this.keyProperty])
    }

    /**
     * Returns the index for a given key or item
     * @param {Number|String|Object} key
     * @returns {Number} index (-1 in case no match is found)
     */
    indexOf(key) {
        let me = this;
        return me._items.indexOf(me.isItem(key) ? key : me.map.get(key))
    }

    /**
     * Returns the index for a given item
     * @param {Object} item
     * @returns {Number} index (-1 in case no match is found)
     */
    indexOfItem(item) {
        return this._items.indexOf(item)
    }

    /**
     * Returns the index for a given key
     * @param {Number|String} key
     * @returns {Number} index (-1 in case no match is found)
     */
    indexOfKey(key) {
        return this._items.indexOf(this.map.get(key))
    }

    /**
     * Inserts an item or an array of items at the specified index
     * @param {Number} index
     * @param {Array|Object} item
     * @returns {Object[]} an array containing all added items
     */
    insert(index, item) {
        return this.splice(index, 0, item).addedItems
    }

    /**
     * @returns {Boolean} true in case the collection is filtered
     */
    isFiltered() {
        return this[isFiltered]
    }

    /**
     * @param {Object} item
     * @returns {boolean}
     * @protected
     */
    isFilteredItem(item) {
        let me         = this,
            filters    = me._filters,
            i          = 0,
            len        = filters.length,
            isFiltered = false;

        for (; i < len; i++) {
            if (filters[i].isFiltered(item)) {
                isFiltered = true;
                break
            }
        }

        return isFiltered
    }

    /**
     * Helper method to check if a given input is either object-like or a key
     * @param {*} value
     * @returns {Boolean} returns true for object-like values
     */
    isItem(value) {
        // We can not use Neo.isObject() || Neo.isRecord(), since collections can store neo instances too.
        return typeof value === 'object'
    }

    /**
     * @returns {Boolean} true in case the collection is sorted
     */
    isSorted() {
        return this[isSorted]
    }

    /**
     * Returns the last item inside the collection
     * @returns {Object}
     */
    last() {
        return this._items[this.count -1]
    }

    /**
     * Moves an item from fromIndex to toIndex
     * @param {Number} fromIndex
     * @param {Number} toIndex
     */
    move(fromIndex, toIndex) {
        if (fromIndex === toIndex) {
            return;
        }

        let items = this._items;

        if (fromIndex >= items.length) {
            fromIndex = items.length - 1
        }

        // The splice operations are intentionally separated.
        // Using the common one-liner `items.splice(toIndex, 0, items.splice(fromIndex, 1)[0])`
        // can lead to unpredictable side effects, as the inner splice can alter the array
        // before the outer splice's index is resolved. This two-step approach is safer.
        const item = items.splice(fromIndex, 1)[0];
        items.splice(toIndex, 0, item)
    }

    /**
     * @param {Object} opts
     * @protected
     */
    onFilterChange(opts) {
        this.filter()
    }

    /**
     * @param {Object} opts
     * @protected
     */
    onMutate(opts) {
        let me = this;

        // todo: inspect the bubbling chain
        /*if (opts.preventBubbleUp) {
            me.preventBubbleUp = true
        }*/

        me.preventBubbleUp = true;

        me.splice(null, opts.removedItems, opts.addedItems)
    }

    /**
     * @param {Object} opts
     * @protected
     */
    onSorterChange(opts) {
        this.applySorterConfigs();
        this.doSort()
    }

    /**
     * Removes the last element from the items array and returns this element.
     * @returns {Object} The removed element from the collection; undefined if the collection is empty.
     */
    pop() {
        let mutation = this.splice(this.count -1, 1);
        return mutation.removedItems[0]
    }

    /**
     * Adds one or more items to the end of the collection and returns the new items count
     * @param {Array|Object} item The item(s) to add
     * @returns {Number} the collection count
     */
    push(item) {
        return this.add(item)
    }

    /**
     * Removes a given key, item or Array containing keys|items
     * @param {Number|String|Object|Array} key
     * @returns {Number} the collection count
     */
    remove(key) {
        this.splice(0, Array.isArray(key) ? key : [key]);
        return this.count
    }

    /**
     * Removes the item at the given index
     * @param {Number} index
     * @returns {Number} the collection count
     */
    removeAt(index) {
        this.splice(index, 1);
        return this.count
    }

    /**
     * Reverses the items array in place.
     * Intended for collections without sorters.
     * @returns {Array} items
     */
    reverse() {
        return this._items.reverse()
    }

    /**
     * Removes the first element from the items array and returns this element.
     * @returns {Object} The removed element from the collection; undefined if the collection is empty.
     */
    shift() {
        let mutation = this.splice(0, 1);
        return mutation.addedItems[0]
    }

    /**
     * @param {function} callback Function to test for each item, taking three parameters:
     * @param {Object}   callback.item The current collection item being processed
     * @param {Number}  [callback.index] The index of the current item being processed
     * @param {Array}   [callback.items] The items array of the collection
     *
     * @param {Object} [scope] Value to use as "this" when executing the callback
     * @returns {boolean} true if the callback function returns a truthy value for any collection item, otherwise false
     */
    some(...args) {
        return this._items.some(...args)
    }

    /**
     * Removes items from and/or adds items to this collection
     * If the toRemoveArray is used, then the index is not used for removing, the entries are found by key and removed from where they are.
     * If index is not passed, toAddArray is appended to the Collection.
     * @param {Number|null} index
     * @param {Number|Object[]} [removeCountOrToRemoveArray]
     * @param {Object|Object[]} [toAddArray]
     * @returns {Object} An object containing the addedItems & removedItems arrays
     */
    splice(index, removeCountOrToRemoveArray, toAddArray) {
        let me                 = this,
            {keyProperty, map} = me,
            source             = me.getSource(),
            addedItems         = [],
            items              = me._items,
            removedItems       = [],
            removeCountAtIndex = Neo.isNumber(removeCountOrToRemoveArray) ? removeCountOrToRemoveArray : null,
            toRemoveArray      = Array.isArray(removeCountOrToRemoveArray) ? removeCountOrToRemoveArray : null,
            i, item, key, len, toAddMap;

        if (!Neo.isNumber(index) && removeCountAtIndex) {
            _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].error(me.id + ': If index is not passed, removeCountAtIndex cannot be used')
        }

        toAddArray = toAddArray && !Array.isArray(toAddArray) ? [toAddArray] : toAddArray;

        if (toRemoveArray && (len = toRemoveArray.length) > 0) {
            if (toAddArray && toAddArray.length > 0) {
                toAddMap = toAddArray.map(e => e[keyProperty])
            }

            for (i=0; i < len; i++) {
                item = toRemoveArray[i];
                key  = me.isItem(item) ? item[keyProperty] : item;

                if (map.has(key)) {
                    if (!toAddMap || (toAddMap && toAddMap.indexOf(key) < 0)) {
                        removedItems.push(items.splice(me.indexOfKey(key), 1)[0]);
                        map.delete(key)
                    }
                }
            }
        } else if (removeCountAtIndex && removeCountAtIndex > 0) {
            removedItems.push(...items.splice(index, removeCountAtIndex));
            removedItems.forEach(e => {
                map.delete(e[keyProperty])
            })
        }

        if (toAddArray && (len = toAddArray.length) > 0) {
            for (i=0; i < len; i++) {
                item = toAddArray[i];
                key  = item[keyProperty];

                if (!key) {
                    item[keyProperty] = key = me.keyPropertyIndex;
                    me.keyPropertyIndex--
                }

                if (!map.has(key) && !me.isFilteredItem(item)) {
                    addedItems.push(item);
                    map.set(key, item)
                }
            }

            if (addedItems.length > 0) {
                if (items.length === 0) {
                    // Performance improvement for Safari, see: https://github.com/neomjs/neo/issues/6228
                    me._items = addedItems
                } else {
                    items.splice(Neo.isNumber(index) ? index : items.length, 0, ...addedItems)
                }

                if (me.autoSort && me._sorters.length > 0) {
                    me.doSort()
                }
            }
        }

        if (source) {
            if (!source.getSource()) {
                source.preventBubbleUp = true
            }

            if (!me.preventBubbleUp) {
                // console.log('source splice', source.id, 'added:', ...toAddArray, 'removed:', ...removedItems);
                me.startUpdate(true);
                source.splice(null, toRemoveArray || removedItems, toAddArray);
                me.endUpdate(true)
            }

            delete source.preventBubbleUp
        }

        if (addedItems.length > 0 || removedItems.length > 0) {
            me[countMutations]++
        }

        if (me[updatingIndex] === 0) {
            me.count = me._items.length;

            me.fire('mutate', {
                addedItems     : toAddArray,
                preventBubbleUp: me.preventBubbleUp,
                removedItems   : toRemoveArray || removedItems
            })
        } else if (!me[silentUpdateMode]) {
            me.cacheUpdate({
                addedItems,
                removedItems
            })
        }

        if (me[updatingIndex] === 0) {
            delete me.preventBubbleUp
        }

        return {addedItems, removedItems}
    }

    /**
     * Prevents the collection from firing events until endUpdate gets called.
     * If you start an update using the startSilentUpdateMode param,
     * the mutation event will not fire after using endUpdate()
     * (you must use the endSilentUpdateMode param for the endUpdate call in case you used
     * startSilentUpdateMode here)
     * @param {Boolean} [startSilentUpdateMode]
     * @see {@link Neo.collection.Base#endUpdate endUpdate}
     */
    startUpdate(startSilentUpdateMode) {
        if (startSilentUpdateMode) {
            this[silentUpdateMode] = true
        }

        this[updatingIndex]++
    }

    /**
     * Adds one or more elements to the beginning of the collection and returns the new items count
     * @param {Array|Object} item The item(s) to add
     * @returns {Number} the collection count
     */
    unshift(item) {
        this.splice(0, 0, item);
        return this.count
    }
}

/**
 * The mutate event fires after every splice call (invoked by all methods which change the content of the items array).
 * @event mutate
 * @param {Object[]} addedItems
 * @param {Boolean} preventBubbleUp private
 * @param {Object[]} removedItems
 * @returns {Object}
 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Collection));


/***/ }),

/***/ "./src/collection/Filter.mjs":
/*!***********************************!*\
  !*** ./src/collection/Filter.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");



/**
 * @class Neo.collection.Filter
 * @extends Neo.core.Base
 * @mixes Neo.core.Observable
 */
class Filter extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true
    /**
     * Valid values for the operator config:<br>
     * ['==','===','!=','!==','<','<=','>','>=','endsWith','excluded','included','isDefined','isUndefined','like','startsWith']
     * @member {String[]} operators
     * @protected
     * @static
     */
    static operators = [
        '==', '===', '!=', '!==', '<', '<=', '>', '>=', 'endsWith', 'excluded', 'included',
        'isDefined', 'isUndefined', 'like', 'startsWith'
    ]

    static config = {
        /**
         * @member {String} className='Neo.collection.Filter'
         * @protected
         */
        className: 'Neo.collection.Filter',
        /**
         * @member {String} ntype='filter'
         * @protected
         */
        ntype: 'filter',
        /**
         * Setting disabled to true will exclude this filter from the collection filtering logic
         * @member {Boolean} disabled_=false
         * @reactive
         */
        disabled_: false,
        /**
         * Provide a custom filtering function which has a higher priority than property, operator & value
         * @member {Function|null} filterBy_=null
         * @reactive
         */
        filterBy_: null,
        /**
         * True means not filtering out items in case the value is '', null, [] or {}
         * @member {Boolean} includeEmptyValues=true
         */
        includeEmptyValues: true,
        /**
         * Set this flag to true before starting bulk updates (e.g. changing property & value)
         * to prevent multiple change events
         * @member {Boolean} isUpdating_=false
         * @reactive
         */
        isUpdating_: false,
        /**
         * The owner util.Collection needs to apply an onChange listener once
         * @member {Boolean} listenerApplied=false
         * @protected
         */
        listenerApplied: false,
        /**
         * The operator to filter by (use the combination of property, operator & value)
         * Valid values:
         *
         * == (not recommended)
         * ===
         * != (not recommended)
         * !==
         * <
         * >=
         * >
         * >=
         * like (collectionValue.toLowerCase().indexOf(filterValue.toLowerCase()) > -1)
         * included (expects value to be an array)
         * excluded (expects value to be an array)
         * @member {String} operator='==='
         */
        operator_: '===',
        /**
         * The property to filter by (use the combination of property, operator & value)
         * @member {String} property_='id'
         * @reactive
         */
        property_: 'id',
        /**
         * The scope to use for the filterBy method, in case it is provided. Defaults to this instance.
         * @member {Object|null} scope=null
         */
        scope: null,
        /**
         * The value to filter by (use the combination of property, operator & value)
         * @member {String} value_=null
         * @reactive
         */
        value_: null
    }

    afterSetDisabled(...args) {
        this.fireChangeEvent(...args)
    }

    afterSetFilterBy(value, oldValue) {
        // todo
    }

    afterSetIsUpdating(value, oldValue) {
        value === false && this.fireChangeEvent(value, oldValue)
    }

    afterSetOperator(...args) {
        this.fireChangeEvent(...args)
    }

    afterSetProperty(...args) {
        this.fireChangeEvent(...args)
    }

    afterSetValue(...args) {
        this.fireChangeEvent(...args)
    }

    beforeSetFilterBy(value, oldValue) {
        if (value && typeof value !== 'function') {
            Neo.logError('filterBy has to be a function', this);
            return oldValue
        }

        return value
    }

    /**
     * Triggered before the operator config gets changed.
     * @param {String|null} value
     * @param {String} oldValue
     * @returns {String}
     * @protected
     */
    beforeSetOperator(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'operator')
    }

    /**
     * Needed for remote filtering
     * @returns {Object|null}
     */
    export() {
        let me                          = this,
            {operator, property, value} = me;

        if (!me.filterBy) {
            return {operator, property, value}
        }

        return null
    }

    /**
     * @param value
     * @param oldValue
     */
    fireChangeEvent(value, oldValue) {
        let me = this;

        if (oldValue !== undefined && me.isUpdating !== true) {
            let {operator, property, value} = me;
            me.fire('change', {operator, property, value})
        }
    }

    /**
     * Checks if a collection item matches this filter
     * @param {Object} item The current collection item
     * @param {Array} filteredItems If the collection filterMode is not primitive contains the items which passed
     * the previous filters, otherwise all collection items
     * @param {Array} allItems all collection items
     * @returns {Boolean}
     */
    isFiltered(item, filteredItems, allItems) {
        let me = this,
            filterValue, recordValue;

        if (me._disabled) {
            return false
        }

        if (me._filterBy) {
            return me.filterBy.call(me.scope || me, {
                allItems,
                filteredItems,
                item,
                value: me._value
            })
        }

        if (me.includeEmptyValues && (me._value === null || Neo.isEmpty(me._value))) {
            return false
        }

        filterValue = me._value;
        recordValue = item[me._property];

        if (filterValue instanceof Date && recordValue instanceof Date) {
            filterValue = filterValue.valueOf();
            recordValue = recordValue.valueOf()
        }

        return !Filter[me._operator](recordValue, filterValue)
    }

    static ['=='] (a, b) {return a == b}
    static ['==='](a, b) {return a === b}
    static ['!='] (a, b) {return a != b}
    static ['!=='](a, b) {return a !== b}
    static ['<']  (a, b) {return a < b}
    static ['<='] (a, b) {return a <= b}
    static ['>']  (a, b) {return a > b}
    static ['>='] (a, b) {return a >= b}

    static ['endsWith'](a, b) {
        if (!Neo.isString(a)) {a = String(a)}
        if (!Neo.isString(b)) {b = String(b)}

        return a?.toLowerCase().endsWith(b?.toLowerCase()) || false
    }

    static ['excluded'](a, b) {
        return b.indexOf(a) < 0
    }

    static ['included'](a, b) {
        return b.indexOf(a) > -1
    }

    static ['isDefined'](a, b) {
        return a !== undefined
    }

    static ['isUndefined'](a, b) {
        return a === undefined
    }

    static ['like'](a, b) {
        if (!Neo.isString(a)) {a = String(a)}
        if (!Neo.isString(b)) {b = String(b)}

        return a?.toLowerCase().includes(b?.toLowerCase()) || false
    }

    static ['startsWith'](a, b) {
        if (!Neo.isString(a)) {a = String(a)}
        if (!Neo.isString(b)) {b = String(b)}

        return a?.toLowerCase().startsWith(b?.toLowerCase()) || false
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Filter));


/***/ }),

/***/ "./src/collection/Sorter.mjs":
/*!***********************************!*\
  !*** ./src/collection/Sorter.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");



/**
 * @class Neo.collection.Sorter
 * @extends Neo.core.Base
 * @mixes Neo.core.Observable
 */
class Sorter extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.collection.Sorter'
         * @protected
         */
        className: 'Neo.collection.Sorter',
        /**
         * @member {String} ntype='sorter'
         * @protected
         */
        ntype: 'sorter',
        /**
         * Internal config which maps the direction ASC to 1, -1 otherwise
         * @member {Number} directionMultiplier=1
         * @protected
         */
        directionMultiplier: 1,
        /**
         * The sort direction when using a property.
         * @member {String} direction_='ASC'
         * @reactive
         */
        direction_: 'ASC',
        /**
         * The owner util.Collection needs to apply an onChange listener once
         * @member {boolean} listenerApplied=false
         * @protected
         */
        listenerApplied: false,
        /**
         * The property to sort by.
         * @member {String} property_='id'
         * @reactive
         */
        property_: 'id',
        /**
         * Provide a custom sorting function, has a higher priority than property & direction
         * @member {Function|null} sortBy=null
         * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator
         */
        sortBy: null,
        /**
         * True to use the transformValue method for each item (the method can get overridden)
         * @member {Boolean} useTransformValue=true
         * @protected
         */
        useTransformValue: true
    }

    /**
     * @param {String} value
     * @param {String} oldValue
     */
    afterSetDirection(value, oldValue) {
        let me = this;

        me.directionMultiplier = value === 'ASC' ? 1 : -1;

        if (oldValue) {
            me.fire('change', {
                direction: me.direction,
                property : me.property
            });
        }
    }

    /**
     * @param {String} value
     * @param {String} oldValue
     */
    afterSetProperty(value, oldValue) {
        let me = this;

        if (oldValue) {
            me.fire('change', {
                direction: me.direction,
                property : me.property
            });
        }
    }

    /**
     * Default sorter function which gets used by collections in case at least one sorter has a real sortBy method
     * @param a
     * @param b
     */
    defaultSortBy(a, b) {
        let me = this;

        a = a[me.property];
        b = b[me.property];

        if (me.useTransformValue) {
            a = me.transformValue(a);
            b = me.transformValue(b);
        }

        if (a > b) {
            return 1 * me.directionMultiplier;
        }

        if (a < b) {
            return -1 * me.directionMultiplier;
        }

        return 0;
    }

    /**
     * Needed for remote sorting
     * @returns {Object|null}
     */
    export() {
        let me                    = this,
            {direction, property} = me;

        if (!me.sortBy && direction && property) {
            return {direction, property}
        }

        return null
    }

    /**
     * @param {*} value
     * @returns {*} value
     */
    transformValue(value) {
        if (typeof value === 'string') {
            value = value.toLowerCase()
        }

        return value
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Sorter));


/***/ }),

/***/ "./src/controller/Application.mjs":
/*!****************************************!*\
  !*** ./src/controller/Application.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/controller/Base.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");



/**
 * @class Neo.controller.Application
 * @extends Neo.controller.Base
 */
class Application extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.controller.Application'
         * @protected
         */
        className: 'Neo.controller.Application',
        /**
         * @member {String} ntype='application'
         * @protected
         */
        ntype: 'application',
        /**
         * @member {String|null} appThemeFolder=null
         */
        appThemeFolder: null,
        /**
         * @member {Neo.component.Base} mainView_=null
         * @reactive
         */
        mainView_: null,
        /**
         * @member {Boolean} mounted=false
         * @protected
         */
        mounted: false,
        /**
         * @member {String} name='MyApp'
         */
        name: 'MyApp',
        /**
         * @member {String} parentId='document.body'
         */
        parentId: 'document.body',
        /**
         * @member {Boolean} rendered=false
         * @protected
         */
        rendered: false,
        /**
         * @member {Boolean} rendering=false
         * @protected
         */
        rendering: false,
        /**
         * @member {Number|null} windowId=null
         */
        windowId: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        // to guarantee that the main view can access Neo.apps at any point,
        // we need to trigger its assignment at the end of the ctor.
        let mainView = config.mainView;
        delete config.mainView;

        super.construct(config);

        let me = this;

        me.windowId = Neo.config.windowId;

        Neo.apps = Neo.apps || {};

        Neo.apps[me.name] = me;

        Neo.currentWorker.registerApp(me.name);

        if (mainView) {
            me.mainView = mainView
        }
    }

    /**
     * Triggered after the mainView config got changed
     * @param {Neo.component.Base} value
     * @param {Neo.component.Base|null} oldValue
     * @protected
     */
    async afterSetMainView(value, oldValue) {
        if (value) {
            let me = this;

            // short delay to ensure changes from onHashChange() got applied
            await me.timeout(Neo.config.hash ? 200 : 10);

            await value.render(true)
        }
    }

    /**
     * Triggered before the mainView config gets changed.
     * @param {Object} value
     * @param {Object} oldValue
     * @returns {Neo.component.Base|null}
     * @protected
     */
    beforeSetMainView(value, oldValue) {
        if (value) {
            return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, null, {
                appName : this.name,
                parentId: this.parentId,
                windowId: Neo.config.windowId
            })
        }

        return null
    }

    /**
     * Unregister the app from the CSS map
     * @param args
     */
    destroy(...args) {
        Neo.currentWorker.removeAppFromThemeMap(this.name);
        super.destroy(...args)
    }
}

Application = Neo.setupClass(Application);

// convenience shortcut
Neo.app = config => Neo.create({
    module: Application,
    ...config
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Application);


/***/ }),

/***/ "./src/controller/Base.mjs":
/*!*********************************!*\
  !*** ./src/controller/Base.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_HashHistory_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/HashHistory.mjs */ "./src/util/HashHistory.mjs");



const
    regexAmountSlashes       = /\//g,
    // Regex to extract the parameter name from a single route segment (e.g., {*itemId} -> itemId)
    regexParamNameExtraction = /{(\*|\.\.\.)?([^}]+)}/,
    // Regex to match route parameters like {paramName}, {*paramName}, or {...paramName}
    regexRouteParam          = /{(\*|\.\.\.)?([^}]+)}/g;

/**
 * @class Neo.controller.Base
 * @extends Neo.core.Base
 */
class Controller extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.controller.Base'
         * @protected
         */
        className: 'Neo.controller.Base',
        /**
         * @member {String} ntype='controller'
         * @protected
         */
        ntype: 'controller',
        /**
         * If the URL does not contain a hash value when this controller instance is created,
         * Neo.mjs will automatically set this hash value, ensuring a default route is active.
         * @member {String|null} defaultHash=null
         */
        defaultHash: null,
        /**
         * Specifies the handler method to be invoked when no other defined route matches the URL hash.
         * This acts as a fallback for unhandled routes.
         * @member {String|null} defaultRoute=null
         */
        defaultRoute: null,
        /**
         * Internal map of compiled regular expressions for each route, used for efficient hash matching.
         * @protected
         * @member {Object} handleRoutes={}
         */
        handleRoutes: {},
        /**
         * Defines the routing rules for the controller. Keys are route patterns, and values are either
         * handler method names (String) or objects containing `handler` and optional `preHandler` method names.
         * Route patterns can include parameters like `{paramName}` and wildcards like `{*paramName}` for nested paths.
         * @example
         * routes: {
         *     '/home'                         : 'handleHomeRoute',
         *     '/users/{userId}'               : {handler: 'handleUserRoute', preHandler: 'preHandleUserRoute'},
         *     '/users/{userId}/posts/{postId}': 'handlePostRoute',
         *     '/learn/{*itemId}'              : 'onLearnRoute', // Captures nested paths like /learn/gettingstarted/Workspaces
         *     'default'                       : 'handleOtherRoutes'
         * }
         * @member {Object} routes_={}
         * @reactive
         */
        routes_: {}
    }

    /**
     * Creates a new Controller instance and registers its `onHashChange` method
     * to listen for changes in the browser's URL hash.
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);
        _util_HashHistory_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].on('change', this.onHashChange, this)
    }

    /**
     * Processes the defined routes configuration, compiling route patterns into regular expressions
     * for efficient matching and sorting them by specificity (more slashes first).
     * @param {Object} value
     * @param {Object} oldValue
     * @protected
     */
    afterSetRoutes(value, oldValue){
        let me        = this,
            routeKeys = Object.keys(value);

         me.routes = routeKeys.sort(me.#sortRoutes).reduce((obj, key) => {
             obj[key] = value[key];
             return obj
         }, {});

        me.handleRoutes = {};

        routeKeys.forEach(key => {
            if (key.toLowerCase() === 'default'){
                me.defaultRoute = value[key]
            } else {
                me.handleRoutes[key] = new RegExp(key.replace(regexRouteParam, (match, isWildcard, paramName) => {
                    if (isWildcard || paramName.startsWith('*')) {
                        return '(.*)'
                    } else {
                        return '([\\w-.]+)'
                    }
                }))
            }
        })
    }

    /**
     * @param args
     */
    destroy(...args) {
        _util_HashHistory_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].un('change', this.onHashChange, this);
        super.destroy(...args)
    }

    /**
     * @returns {Promise<void>}
     */
    async initAsync() {
        await super.initAsync();

        let me                      = this,
            {defaultHash, windowId} = me,
            currentHash             = _util_HashHistory_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].first(windowId);

        if (currentHash) {
            if (currentHash.windowId === windowId) {
                await me.onHashChange(currentHash, null)
            }
        } else {
            /*
             * worker.App: onLoadApplication() will push config.hash into the HashHistory with a 5ms delay.
             * We only want to set a default route, in case the HashHistory is empty and there is no initial
             * value that will get consumed.
             */
            !Neo.config.hash && defaultHash && Neo.Main.setRoute({value: defaultHash, windowId})
        }
    }

    /**
     * Handles changes in the browser's URL hash. It identifies the most specific matching route
     * and dispatches the corresponding handler, optionally executing a preHandler first.
     * @param {Object} value - The new hash history entry.
     * @param {Object} oldValue - The previous hash history entry.
     */
    async onHashChange(value, oldValue) {
        // We only want to trigger hash changes for the same browser window (SharedWorker context)
        if (value.windowId !== this.windowId) {
            return
        }

        let me                     = this,
            {handleRoutes, routes} = me,
            routeKeys              = Object.keys(handleRoutes),
            bestMatch              = null,
            bestMatchKey           = null,
            bestMatchParams        = null;

        for (let i = 0; i < routeKeys.length; i++) {
            const key = routeKeys[i];
            const result = value.hashString.match(handleRoutes[key]);

            if (result) {
                const
                    arrayParamIds    = key.match(regexRouteParam),
                    arrayParamValues = result.splice(1, result.length - 1),
                    paramObject      = {};

                if (arrayParamIds) {
                    for (let j = 0; j < arrayParamIds.length; j++) {
                        const paramMatch = arrayParamIds[j].match(regexParamNameExtraction);

                        if (paramMatch) {
                            const paramName = paramMatch[2];
                            paramObject[paramName] = arrayParamValues[j];
                        }
                    }
                }

                // Logic to determine the best matching route:
                // 1. Prioritize routes that match a longer string (more specific match).
                // 2. If lengths are equal, prioritize routes with more slashes (deeper nesting).
                if (!bestMatch || (result[0].length > bestMatch[0].length) ||
                    (result[0].length === bestMatch[0].length && (key.match(regexAmountSlashes) || []).length > (bestMatchKey.match(regexAmountSlashes) || []).length)) {
                    bestMatch = result;
                    bestMatchKey = key;
                    bestMatchParams = paramObject;
                }
            }
        }

        if (bestMatch) {
            const route = routes[bestMatchKey];
            let handler    = null,
                preHandler = null;

            if (Neo.isString(route)) {
                handler = route
            } else if (Neo.isObject(route)) {
                handler    = route.handler;
                preHandler = route.preHandler
            }

            let responsePreHandler = true;

            if (preHandler) {
                responsePreHandler = await me[preHandler]?.call(me, bestMatchParams, value, oldValue)
            }

            if (responsePreHandler) {
                await me[handler]?.call(me, bestMatchParams, value, oldValue)
            }
        } else {
            if (me.defaultRoute) {
                me[me.defaultRoute]?.(value, oldValue)
            } else {
                me.onNoRouteFound(value, oldValue)
            }
        }
    }

    /**
     * Placeholder method invoked when no matching route is found for the current URL hash.
     * Controllers can override this to implement custom behavior for unhandled routes.
     * @param {Object} value - The current hash history entry.
     * @param {Object} oldValue - The previous hash history entry.
     */
    onNoRouteFound(value, oldValue) {

    }

    /**
     * Internal helper method to sort routes by their specificity.
     * Routes with more slashes are considered more specific and are prioritized.
     * @param {String} route1 - The first route string to compare.
     * @param {String} route2 - The second route string to compare.
     * @returns {Number} A negative value if route1 is more specific, a positive value if route2 is more specific, or 0 if they have equal specificity.
     */
    #sortRoutes(route1, route2) {
        return (route1.match(regexAmountSlashes) || []).length - (route2.match(regexAmountSlashes)|| []).length
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Controller));


/***/ }),

/***/ "./src/core/Base.mjs":
/*!***************************!*\
  !*** ./src/core/Base.mjs ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_Function_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/Function.mjs */ "./src/util/Function.mjs");
/* harmony import */ var _core_Compare_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Compare.mjs */ "./src/core/Compare.mjs");
/* harmony import */ var _core_Util_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Util.mjs */ "./src/core/Util.mjs");
/* harmony import */ var _Config_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Config.mjs */ "./src/core/Config.mjs");
/* harmony import */ var _ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");
/* harmony import */ var _IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./IdGenerator.mjs */ "./src/core/IdGenerator.mjs");
/* harmony import */ var _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./EffectManager.mjs */ "./src/core/EffectManager.mjs");









const configSymbol       = Symbol.for('configSymbol'),
      forceAssignConfigs = Symbol('forceAssignConfigs'),
      isInstance         = Symbol('isInstance');

/**
 * The base class for (almost) all classes inside the Neo namespace
 * Exceptions are e.g. core.IdGenerator, vdom.VNode
 * @class Neo.core.Base
 */
class Base {
    /**
     * You can define methods which should get delayed.
     * Types are buffer, debounce & throttle.
     * @example
     *  delayable: {
     *      fireChangeEvent: {
     *          type : 'debounce',
     *          timer: 300
     *      }
     *  }
     * @member {Object} delayable={}
     * @protected
     * @static
     */
    static delayable = {}
    /**
     * Flag which will get set to true once manager.Instance got created
     * @member {Boolean} instanceManagerAvailable=false
     * @static
     */
    static instanceManagerAvailable = false
    /**
     * Regex to grab the MethodName from an error
     * which is a second generation function
     * @member {RegExp} methodNameRegex
     * @static
     */
    static methodNameRegex = /\n.*\n\s+at\s+.*\.(\w+)\s+.*/
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=false
     * @static
     */
    static observable = false
    /**
     * Keep the overwritten methods
     * @member {Object} overwrittenMethods={}
     * @protected
     * @static
     */
    static overwrittenMethods = {}
    /**
     * Defines the default configuration properties for the class. These configurations are
     * merged throughout the class hierarchy and can be overridden at the instance level.
     *
     * There are two main types of configs:
     *
     * 1.  **Reactive Configs:** Property names ending with a trailing underscore (e.g., `myConfig_`).
     *     The framework automatically generates a public getter and setter, removing the underscore
     *     from the property name (e.g., `this.myConfig`). This system enables powerful, optional
     *     lifecycle hooks that are called automatically if they are implemented on the class:
     *     - `beforeGetMyConfig(value)`: Executed before the getter returns. Can be used to dynamically modify the returned value.
     *     - `beforeSetMyConfig(newValue, oldValue)`: Executed before a new value is set. Can be used for validation or transformation. Returning `undefined` from this hook will cancel the update.
     *     - `afterSetMyConfig(newValue, oldValue)`: Executed after a new value has been successfully set. Ideal for triggering side effects.
     *
     * 2.  **Non-Reactive (Prototype-based) Configs:** Property names without a trailing underscore.
     *     These are applied directly to the class's **prototype** during the `Neo.setupClass`
     *     process. This is highly memory-efficient as the value is shared across all instances.
     *     It also allows for powerful, application-wide modifications of default behaviors
     *     by using the `Neo.overwrites` mechanism, which modifies these prototype values at
     *     load time.
     *
     * @returns {Object} config
     */
    static config = {
        /**
         * The class name which will get mapped into the Neo or app namespace
         * @member {String} className='Neo.core.Base'
         * @protected
         */
        className: 'Neo.core.Base',
        /**
         * The class shortcut-name to use for e.g. creating child components inside a JSON-format
         * @member {String} ntype='base'
         * @protected
         */
        ntype: 'base',
        /**
         * While it is recommended to change the static delayable configs on class level,
         * you can change it on instance level too. If not null, we will do a deep merge.
         * @member {Object} delayable=null
         */
        delayable: null,
        /**
         * The unique component id
         * @member {String|null} id_=null
         * @reactive
         */
        id_: null,
        /**
         * An array of remote method names that should be intercepted.
         * Names used here must be present inside the `remote_` config.
         * If a remote call for one of these methods arrives, `onInterceptRemotes()` will be called.
         * @member {String[]|null} interceptRemotes=null
         * @protected
         */
        interceptRemotes: null,
        /**
         * Neo.create() will change this flag to true after the onConstructed() chain is done.
         * @member {Boolean} isConstructed=false
         * @protected
         */
        isConstructed: false,
        /**
         * This config will be set to `true` as the very first action within the `destroy()` method.
         * Effects can observe this config to clean themselves up.
         * @member {Boolean} isDestroying_=false
         * @protected
         * @reactive
         */
        isDestroying_: false,
        /**
         * The config will get set to `true` once the Promise of `async initAsync()` is resolved.
         * You can use `afterSetIsReady()` to get notified once the ready state is reached.
         * Since not all classes use the Observable mixin, Neo will not fire an event.
         * method body.
         * @member {Boolean} isReady_=false
         * @reactive
         */
        isReady_: false,
        /**
         * Add mixins as an array of classNames, imported modules or a mixed version
         * @member {String[]|Neo.core.Base[]|null} mixins=null
         */
        mixins: null,
        /**
         * You can create a new instance by passing an imported class (JS module default export)
         * @member {Class} module=null
         * @protected
         */
        module: null,
        /**
         * Remote method access for other threads. Example use case:
         * remote: {app: ['myRemoteMethod']}
         *
         * ONLY supported for singletons.
         *
         * @member {Object|null} remote_=null
         * @protected
         * @reactive
         */
        remote_: null
    }

    /**
     * A private field to store the Config controller instances.
     * @member {Object} #configs={}
     * @private
     */
    #configs = {};
    /**
     * Internal cache for all config subscription cleanup functions.
     * @member {Function[]} #configSubscriptionCleanups=[]
     * @private
     */
    #configSubscriptionCleanups = []
    /**
     * Internal cache for all timeout ids when using this.timeout()
     * @member {Number[]} timeoutIds=[]
     * @private
     */
    #timeoutIds = []

    /**
     * The main initializer for all Neo.mjs classes, invoked by `Neo.create()`.
     * NOTE: This is not the native `constructor()`, which is called without arguments by `Neo.create()` first.
     *
     * This method orchestrates the entire instance initialization process, including
     * the setup of the powerful and flexible config system.
     *
     * The `config` parameter is a single object that can contain different types of properties,
     * which are processed in a specific order to ensure consistency and predictability:
     *
     * 1.  **Public Class Fields & Other Properties:** Any key in the `config` object that is NOT
     *     defined in the class's `static config` hierarchy is considered a public field or a
     *     dynamic property. These are assigned directly to the instance (`this.myField = value`)
     *     at the very beginning. This is crucial so that subsequent config hooks (like `afterSet*`)
     *     can access their latest values.
     *
     * 2.  **Reactive Configs:** A property is considered reactive if it is defined with a trailing
     *     underscore (e.g., `myValue_`) in the `static config` of **any class in the inheritance
     *     chain**. Subclasses can provide new default values for these configs without the
     *     underscore, and they will still be reactive. Their values are applied via generated
     *     setters, triggering `beforeSet*` and `afterSet*` hooks, and they are wrapped in a
     *     `Neo.core.Config` instance to enable subscription-based reactivity.
     *
     * 3.  **Non-Reactive Configs:** Properties defined in `static config` without a trailing
     *     underscore in their entire inheritance chain. Their default values are applied directly
     *     to the class **prototype**, making them shared across all instances and allowing for
     *     run-time modifications (prototypal inheritance). When a new value is passed to this
     *     method, it creates an instance-specific property that shadows the prototype value.
     *
     * This method also initializes the observable mixin (if applicable) and schedules asynchronous
     * logic like `initAsync()` (which handles remote method access) to run after the synchronous
     * construction chain is complete.
     *
     * @param {Object} config={} The initial configuration object for the instance.
     */
    construct(config={}) {
        let me = this;

        Object.defineProperties(me, {
            [configSymbol]: {
                configurable: true,
                enumerable  : false,
                value       : {},
                writable    : true
            },
            [isInstance]: {
                enumerable: false,
                value     : true
            }
        });

        me.id = config.id || _IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].getId(this.getIdKey());
        delete config.id;

        // assign class field values prior to configs
        config = me.setFields(config);

        me.initConfig(config);

        Object.defineProperty(me, 'configsApplied', {
            enumerable: false,
            value     : true
        });

        me.applyDelayable();

        /*
         * We do not want to force devs to check for the `isDestroyed` flag in every possible class extension.
         * So, we are intercepting the top-most `destroy()` call to check for the flag there.
         * Rationale: `destroy()` must only get called once.
         */
        (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_0__.intercept)(me, 'destroy', me.isDestroyedCheck, me);

        // Triggers async logic after the construction chain is done.
        Promise.resolve().then(async () => {
            await me.initAsync();
            me.isReady = true
        })
    }

    /**
     * Triggered after the id config got changed.
     * You can dynamically change instance ids if needed. They need to stay unique at any given point.
     * Use case: e.g. component based lists, where you want to re-use item instances.
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetId(value, oldValue) {
        let me         = this,
            hasManager = Base.instanceManagerAvailable === true;

        if (oldValue) {
            if (hasManager) {
                Neo.manager.Instance.unregister(oldValue)
            } else if (Neo.idMap) {
                delete Neo.idMap[oldValue]
            }
        }

        if (value) {
            if (hasManager) {
                Neo.manager.Instance.register(me);
            } else {
                Neo.idMap ??= {};
                Neo.idMap[value] = me
            }
        }
    }

    /**
     * Adjusts all methods inside static delayable
     */
    applyDelayable() {
        let me            = this,
            ctorDelayable = me.constructor.delayable,
            delayable     = me.delayable ? Neo.merge({}, me.delayable, ctorDelayable) : ctorDelayable;

        Object.entries(delayable).forEach(([key, value]) => {
            if (value) {
                let map = {
                    buffer()   {me[key] = new _util_Function_mjs__WEBPACK_IMPORTED_MODULE_0__.buffer(me[key],   me, value.timer)},
                    debounce() {me[key] = new _util_Function_mjs__WEBPACK_IMPORTED_MODULE_0__.debounce(me[key], me, value.timer)},
                    throttle() {me[key] = new _util_Function_mjs__WEBPACK_IMPORTED_MODULE_0__.throttle(me[key], me, value.timer)}
                };

                map[value.type]?.()
            }
        })
    }

    /**
     * This static method is called by `Neo.setupClass()` during the class creation process.
     * It allows for modifying a class's default prototype-based configs from outside the
     * class hierarchy, which is a powerful way to avoid boilerplate code.
     *
     * It looks for a matching entry in the global `Neo.overwrites` object based on the
     * class's `className`. If found, it merges the properties from the overwrite object
     * into the class's static `config`. This provides a powerful mechanism for theming
     * or applying application-wide customizations to framework or library classes without
     * needing to extend them.
     *
     * @example
     * // Imagine you have hundreds of buttons in your app, and you want all of them
     * // to have `labelPosition: 'top'` instead of the default `'left'`.
     * // Instead of configuring each instance, you can define an overwrite.
     *
     * // inside an Overwrites.mjs file loaded by your app:
     * Neo.overwrites = {
     *     Neo: {
     *         button: {
     *             Base: {
     *                 labelPosition: 'top'
     *             }
     *         }
     *     }
     * };
     *
     * // Now, every `Neo.button.Base` (and any class that extends it) will have this
     * // new default value on its prototype.
     *
     * @param {Object} cfg The static `config` object of the class being processed.
     * @protected
     * @static
     */
    static applyOverwrites(cfg) {
        let overwrites = Neo.ns(cfg.className, false, Neo.overwrites),
            cls, item;

        if (overwrites) {
            // Apply all methods
            for (item in overwrites) {
                if (Neo.isFunction(overwrites[item])) {
                    // Already existing ones
                    cls = this.prototype;

                    if (cls[item]) {
                        // add to overwrittenMethods
                        cls.constructor.overwrittenMethods[item] = cls[item]
                    }
                }
            }

            // Apply configs to prototype
            Object.assign(cfg, overwrites)
        }
    }

    /**
     * Convenience method for beforeSet functions which test if a given value is inside a static array
     * @param {String|Number} value
     * @param {String|Number} oldValue
     * @param {String} name config name
     * @param {Array|String} [staticName=name + 's'] name of the static config array
     * @returns {String|Number} value or oldValue
     */
    beforeSetEnumValue(value, oldValue, name, staticName = name + 's') {
        let values = Array.isArray(staticName) ? staticName : this.getStaticConfig(staticName);

        if (!values.includes(value)) {
            console.error(`Supported values for ${name} are:`, ...values, this);
            return oldValue
        }

        return value
    }

    /**
     * Triggered before the remote config gets changed
     * @param {Object|null} value
     * @param {Object|null} oldValue
     * @returns {Object|null}
     * @protected
     */
    beforeSetRemote(value, oldValue) {
        let me = this;

        // Only allow remote access for singletons or main thread addons
        if (value && !me.singleton && !me.isMainThreadAddon) {
            throw new Error('Remote method access is only functional for Singleton classes ' + me.className)
        }

        return value
    }

    /**
     * @param {String} fn               The name of a function to find in the passed scope object.
     * @param {Object} originName       The name of the method inside the originScope.
     * @param {Object} scope            The scope to find the function in if it is specified as a string.
     * @param {Object} originScope=this The scope where the function is located.
     */
    bindCallback(fn, originName, scope=this, originScope=this) {
        if (fn && Neo.isString(fn)) {
            const handler = (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_0__.resolveCallback)(fn, scope);
            originScope[originName] = handler.fn.bind(handler.scope)
        }
    }

    /**
     * From within an overwrite, a method can call a parent method, by using callOverwritten.
     *
     * @example
     *    afterSetHeight(value, oldValue) {
     *        // do the standard
     *        this.callOverwritten(...arguments);
     *        // do you own stuff
     *    }
     *
     * We create an error to get the caller.name and then run that method on the constructor.
     * This is based on the following error structure, e.g. afterSetHeight.
     *
     *     Error
     *         at Base.callOverwritten (Base.mjs:176:21)
     *         at Base.afterSetHeight (Overrides.mjs:19:26)
     *
     * @param args
     */
    callOverwritten(...args) {
        let stack      = new Error().stack,
            methodName = stack.match(Base.methodNameRegex)[1];

        this.__proto__.constructor.overwrittenMethods[methodName].call(this, ...args)
    }

    /**
     * Unregisters this instance from Neo.manager.Instance
     * and removes all object entries from this instance
     */
    destroy() {
        let me = this;

        me.isDestroying = true;

        me.#timeoutIds.forEach(id => {
            clearTimeout(id)
        });

        me.#configSubscriptionCleanups.forEach(cleanup => {
            cleanup()
        });

        if (Base.instanceManagerAvailable === true) {
            Neo.manager.Instance.unregister(me)
        } else if (Neo.idMap) {
            delete Neo.idMap[me.id]
        }

        Object.keys(me).forEach(key => {
            if (Object.getOwnPropertyDescriptor(me, key).writable) {
                // We must not delete the custom destroy() interceptor
                if (key !== 'destroy' && key !== '_id') {
                    delete me[key]
                }
            }
        });

        // We do want to prevent delayed event calls after an observable instance got destroyed.
        if (Neo.isFunction(me.fire)) {
            me.fire = Neo.emptyFn
        }

        me.isDestroyed = true
    }

    /**
     * A public method to access the underlying Config controller.
     * This enables advanced interactions like subscriptions.
     * @param {String} key The name of the config property (e.g., 'items').
     * @returns {Config|undefined} The Config instance, or undefined if not found.
     */
    getConfig(key) {
        let me = this;

        if (!me.#configs[key] && me.isConfig(key)) {
            me.#configs[key] = new _Config_mjs__WEBPACK_IMPORTED_MODULE_3__["default"](me.constructor.configDescriptors?.[key])
        }

        return me.#configs[key]
    }

    /**
     * Used inside createId() as the default value passed to the IdGenerator.
     * Override this method as needed.
     * @returns {String}
     */
    getIdKey() {
        return this.ntype
    }

    /**
     * Returns the value of a static config key or the staticConfig object itself in case no value is set
     * @param {String} key The key of a staticConfig defined inside static getStaticConfig
     * @returns {*}
     */
    getStaticConfig(key) {
        return this.constructor[key]
    }

    /**
     * Check if a given ntype exists inside the proto chain, including the top level class
     * @param {String} ntype
     * @returns {Boolean}
     */
    hasNtype(ntype) {
        return this.constructor.ntypeChain.includes(ntype)
    }

    /**
     * Gets triggered after onConstructed() is done
     */
    init() {}

    /**
     * You can use this method in subclasses to perform asynchronous initialization logic.
     * Make sure to use the parent call `await super.initAsync()` at the beginning of their implementations,
     * or the registration of remote methods will get delayed.
     *
     * A common use case is requiring conditional or optional dynamic imports or fetching initial data.
     *
     * Once the promise returned by this method is fulfilled, the `isReady` config will be set to `true`.
     * @returns {Promise<void>} A promise that resolves when the asynchronous initialization is complete.
     */
    async initAsync() {
        this.remote && this.initRemote()
    }

    /**
     * Applies all class configs to this instance
     * @param {Object} config
     * @param {Boolean} [preventOriginalConfig] True prevents the instance from getting an originalConfig property
     * @protected
     */
    initConfig(config, preventOriginalConfig) {
        let me = this;

        me.isConfiguring = true;
        Object.assign(me[configSymbol], me.mergeConfig(config, preventOriginalConfig));
        delete me[configSymbol].id;
        me.processConfigs();
        me.isConfiguring = false
    }

    /**
     * Does get triggered with a delay to ensure that Neo.workerId & Neo.worker.Manager are defined
     * Remote method access via promises
     * @protected
     */
    initRemote() {
        let {className, remote} = this,
            {currentWorker}     = Neo;

        if (!Neo.config.unitTestMode) {
            if (Neo.workerId !== 'main' && currentWorker.isSharedWorker && !currentWorker.isConnected) {
                currentWorker.on('connected', () => {
                    Base.sendRemotes(className, remote)
                }, this, {once: true})
            } else {
                Base.sendRemotes(className, remote)
            }
        }
    }

    /**
     * Intercepts destroy() calls to ensure they will only get called once
     * @returns {Boolean}
     */
    isDestroyedCheck() {
        return !this.isDestroyed
    }

    /**
     * @param {String} key
     * @returns {Boolean}
     */
    isConfig(key) {
        let me = this;
        // If a `core.Config` controller is already created, return true (fastest possible check).
        // If not, a config is considered "reactive" if it has a generated property setter
        // AND it is present as a defined config in the merged static config hierarchy.
        // Neo.setupClass() removes the underscore from the static config keys.
        return me.#configs[key] || (Neo.hasPropertySetter(me, key) && (key in me.constructor.config))
    }

    /**
     * Override this method to change the order configs are applied to this instance.
     * @param {Object} config
     * @param {Boolean} [preventOriginalConfig] True prevents the instance from getting an originalConfig property
     * @returns {Object} config
     * @protected
     */
    mergeConfig(config, preventOriginalConfig) {
        let me   = this,
            ctor = me.constructor,
            configDescriptors, staticConfig;

        if (!ctor.config) {
            throw new Error('Neo.applyClassConfig has not been run on ' + me.className)
        }

        if (!preventOriginalConfig) {
            me.originalConfig = Neo.clone(config, true, true)
        }

        configDescriptors = ctor.configDescriptors;
        staticConfig      = ctor.config;

        if (configDescriptors) {
            Object.entries(config).forEach(([key, instanceValue]) => {
                const descriptor = configDescriptors[key];

                if (descriptor?.merge) {
                    config[key] = Neo.mergeConfig(staticConfig[key], instanceValue, descriptor.merge)
                }
            })
        }

        return {...staticConfig, ...config}
    }

    /**
     * Subscribes *this* instance (the subscriber) to changes of a specific config property on another instance (the publisher).
     * Ensures automatic cleanup when *this* instance (the subscriber) is destroyed.
     *
     * @param {String|Neo.core.Base} publisher  - The ID of the publisher instance or the instance reference itself.
     * @param {String}               configName - The name of the config property on the publisher to subscribe to (e.g., 'myConfig').
     * @param {Function}             fn         - The callback function to execute when the config changes.
     * @returns {Function} A cleanup function to manually unsubscribe if needed before this instance's destruction.
     *
     * @example
     * // Subscribing to a config on another instance
     * this.observeConfig(someOtherInstance, 'myConfig', (newValue, oldValue) => {
     *     console.log('myConfig changed:', newValue);
     * });
     *
     * // Discouraged: Self-observation. Use afterSet<ConfigName>() hooks instead.
     * this.observeConfig(this, 'myOwnConfig', (newValue, oldValue) => {
     *     console.log('myOwnConfig changed:', newValue);
     * });
     */
    observeConfig(publisher, configName, fn) {
        let publisherInstance = publisher;

        if (Neo.isString(publisher)) {
            publisherInstance = Neo.get(publisher);
            if (!publisherInstance) {
                console.warn(`Publisher instance with ID '${publisher}' not found. Cannot subscribe.`);
                return Neo.emptyFn
            }
        }

        if (!(publisherInstance instanceof Neo.core.Base)) {
            console.warn(`Invalid publisher provided. Must be a Neo.core.Base instance or its ID.`);
            return Neo.emptyFn
        }

        const configController = publisherInstance.getConfig(configName);

        if (!configController) {
            console.warn(`Config '${configName}' not found on publisher instance ${publisherInstance.id}. Cannot subscribe.`);
            return Neo.emptyFn
        }

        const cleanup = configController.subscribe({id: this.id, fn});

        this.#configSubscriptionCleanups.push(cleanup);

        return cleanup
    }

    /**
     *
     */
    onAfterConstructed() {
        let me = this;

        me.isConstructed = true;

        // We can only fire the event in case the Observable mixin is included.
        me.getStaticConfig('observable') && me.fire('constructed', me)
    }

    /**
     * Gets triggered after all constructors are done
     */
    onConstructed() {}

    /**
     * Placeholder method for intercepting remote calls.
     * Subclasses can override this method to implement custom interception logic.
     * @param {Object} msg The remote message object.
     */
    onInterceptRemotes(msg) {
        // No-op in base class
    }

    /**
     * Helper method to replace string based values containing "@config:" with the matching config value
     * of this instance.
     * @param {Object|Object[]} items
     */
    parseItemConfigs(items) {
        let me = this,
            ns, nsArray, nsKey, symbolNs;

        if (items) {
            if (!Array.isArray(items)) {
                items = [items]
            }

            items.forEach(item => {
                item && Object.entries(item).forEach(([key, value]) => {
                    if (Array.isArray(value)) {
                        me.parseItemConfigs(value);
                    } else if (typeof value === 'string' && value.startsWith('@config:')) {
                        nsArray = value.substring(8).trim().split('.');
                        nsKey   = nsArray.pop();
                        ns      = Neo.ns(nsArray, false, me);

                        if (ns[nsKey] === undefined) {
                            console.error('The used @config does not exist:', nsKey, nsArray.join('.'))
                        } else {
                            symbolNs = Neo.ns(nsArray, false, me[configSymbol]);

                            // The config might not be processed yet, especially for configs
                            // not ending with an underscore, so we need to check the configSymbol first.
                            if (symbolNs && Object.hasOwn(symbolNs, nsKey)) {
                                item[key] = symbolNs[nsKey]
                            } else {
                                item[key] = ns[nsKey]
                            }
                        }
                    }
                })
            })
        }
    }

    /**
     * When using set(), configs without a trailing underscore can already be assigned,
     * so the hasOwnProperty() check will return true
     * @param {Boolean} [forceAssign=false]
     * @protected
     */
    processConfigs(forceAssign=false) {
        let me   = this,
            keys = Object.keys(me[configSymbol]);

        me[forceAssignConfigs] = forceAssign;

        // We do not want to iterate over the keys, since 1 config can remove more than 1 key (beforeSetX, afterSetX)
        if (keys.length > 0) {
            // The hasOwnProperty check is intended for configs without a trailing underscore
            // => they could already have been assigned inside an afterSet-method
            if (forceAssign || !me.hasOwnProperty(keys[0])) {
                me[keys[0]] = me[configSymbol][keys[0]]
            }

            // there is a delete-call inside the config getter as well (Neo.mjs => autoGenerateGetSet())
            // we need to keep this one for configs, which do not use getters (no trailing underscore)
            delete me[configSymbol][keys[0]];

            me.processConfigs(forceAssign)
        }
    }

    /**
     * @param {String} className
     * @param {Object} remote
     * @protected
     */
    static sendRemotes(className, remote) {
        let origin;

        Object.entries(remote).forEach(([worker, methods]) => {
            if (Neo.workerId !== worker) {
                origin = Neo.workerId === 'main' ? Neo.worker.Manager : Neo.currentWorker;

                origin.sendMessage(worker, {
                    action: 'registerRemote',
                    className,
                    methods
                })
            }
        })
    }

    /**
     * set() accepts the following input as keys:
     * 1. Non-reactive configs
     * 2. Reactive configs
     * 3. Class fields defined via value
     * 4. Class fields defined via get() & set()
     * 5. "Anything else" will get directly get assigned to the instance
     *
     * The logic resolves circular dependencies as good as possible and ensures that config related hooks:
     * - beforeGet<Config>
     * - beforeSet<Config>
     * - afterSet<Config>
     * can access all new values from the batch operation.
     * @param {Object} values={}
     */
    set(values={}) {
        let me                = this,
            classFieldsViaSet = {};

        // Prevent Effects from running for bulk changes
        _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].pause();

        try {
            values = me.setFields(values);

            // If the initial config processing is still running,
            // finish this one first before dropping new values into the configSymbol.
            // See: https://github.com/neomjs/neo/issues/2201
            if (me[forceAssignConfigs] !== true && Object.keys(me[configSymbol]).length > 0) {
                me.processConfigs()
            }

            // Store class fields which are defined via get() & set() and ensure they won't get added to the config symbol.
            Object.entries(values).forEach(([key, value]) => {
                if (!me.isConfig(key)) {
                    classFieldsViaSet[key] = value;
                    delete values[key]
                }
            })

            // Add reactive configs to the configSymbol
            Object.assign(me[configSymbol], values);

            // Process class fields which are defined via get() & set() => now they can access the latest values
            // for reactive and non-reactive configs, as well as class fields defined with values.
            Object.entries(classFieldsViaSet).forEach(([key, value]) => {
                me[key] = value
            })

            // Process reactive configs
            me.processConfigs(true);
        } finally {
            // Trigger the skipped Effect, if needed
            _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].resume()
        }
    }

    /**
     * We want to assign class fields first and remove them from the config object,
     * so that afterSet(), beforeGet() and beforeSet() methods can get the new values right away
     * @param {Object} config
     * @returns {Object}
     * @protected
     */
    setFields(config) {
        let me = this;

        Object.entries(config).forEach(([key, value]) => {
            if (!me.isConfig(key) && !Neo.hasPropertySetter(me, key)) {
                me[key] = value;
                delete config[key]
            }
        });

        return config
    }

    /**
     * Sets the value of a static config by a given key
     * @param {String} key The key of a staticConfig defined inside static getStaticConfig
     * @param {*} value
     * @returns {Boolean} true in case the config exists and got changed
     */
    setStaticConfig(key, value) {
        let staticConfig = this.constructor.staticConfig;

        if (staticConfig.hasOwnProperty(key)) {
            staticConfig[key] = value;
            return true
        }

        return false
    }

    /**
     * Stores timeoutIds internally, so that destroy() can clear them if needed
     * @param {Number} time in milliseconds
     * @returns {Promise<any>}
     */
    timeout(time) {
        return new Promise(resolve => {
            let timeoutIds = this.#timeoutIds,
                timeoutId  = setTimeout(() => {timeoutIds.splice(timeoutIds.indexOf(timeoutId), 1); resolve()}, time);

            timeoutIds.push(timeoutId)
        })
    }

    /**
     * <p>Enhancing the toString() method, e.g.</p>
     * `Neo.create('Neo.button.Base').toString() => "[object Neo.button.Base (neo-button-1)]"`
     * @returns {String}
     */
    get [Symbol.toStringTag]() {
        return this.className
    }

    /**
     * <p>Enhancing the instanceof method. Without this change:</p>
     * `Neo.collection.Base.prototype instanceof Neo.core.Base => true`
     * <p>With this change:</p>
     * `Neo.collection.Base.prototype instanceof Neo.core.Base => false`<br>
     * `Neo.create(Neo.collection.Base) instanceof Neo.core.Base => true`
     * @returns {Boolean}
     */
    static [Symbol.hasInstance](instance) {
        if (!instance) {
            return false
        }

        return instance[isInstance] === true ? super[Symbol.hasInstance](instance) : false
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Base));


/***/ }),

/***/ "./src/core/Compare.mjs":
/*!******************************!*\
  !*** ./src/core/Compare.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @class Neo.core.Compare
 */
class Compare {
    /**
     * Storing the comparison method names by data type
     * @member {Object} map
     */
    static map = {
        Array      : 'compareArrays',
        Date       : 'compareDates',
        Function   : 'compareFunctions',
        Map        : 'compareMaps',
        NeoInstance: 'compareNeoInstances',
        Object     : 'compareObjects',
        RegExp     : 'compareRegExps',
        Set        : 'compareSets'
    }

    /**
     * @param {Array} item1
     * @param {Array} item2
     * @returns {Boolean}
     */
    static compareArrays(item1, item2) {
        if (item1.length !== item2.length) {
            return false
        }

        for (const [i, v] of item1.entries()) {
            if (!Compare.isEqual(v, item2[i])) {
                return false
            }
        }

        return true
    }

    /**
     * @param {Date} item1
     * @param {Date} item2
     * @returns {Boolean}
     */
    static compareDates(item1, item2) {
        return item1.valueOf() === item2.valueOf()
    }

    /**
     * @param {Function} item1
     * @param {Function} item2
     * @returns {Boolean}
     */
    static compareFunctions(item1, item2) {
        if (item1.name !== item2.name) {
            return false
        }

        return item1.toString() === item2.toString()
    }

    /**
     * @param {Map} item1
     * @param {Map} item2
     * @returns {Boolean}
     */
    static compareMaps(item1, item2) {
        if (item1.size !== item2.size) {
            return false
        }

        let val2;

        for (const [key, val] of item1) {
            val2 = item2.get(key);

            if (val2 !== val || val2 === undefined && !item2.has(key)) {
                return false
            }
        }

        return true
    }

    /**
     * @param {Neo.core.Base} item1
     * @param {Neo.core.Base} item2
     * @returns {Boolean}
     */
    static compareNeoInstances(item1, item2) {
        return item1.id === item2.id
    }

    /**
     * @param {Object} item1
     * @param {Object} item2
     * @returns {Boolean}
     */
    static compareObjects(item1, item2) {
        if (Object.keys(item1).length !== Object.keys(item2).length) {
            return false
        }

        for (let key in item1) {
            if (!Compare.isEqual(item1[key], item2[key])) {
                return false
            }
        }

        return true
    }

    /**
     * @param {RegExp} item1
     * @param {RegExp} item2
     * @returns {Boolean}
     */
    static compareRegExps(item1, item2) {
        return item1.toString() === item2.toString()
    }

    /**
     * @param {Set} item1
     * @param {Set} item2
     * @returns {Boolean}
     */
    static compareSets(item1, item2) {
        if (item1.size !== item2.size) {
            return false
        }

        for (let key of item1) {
            if (!item2.has(key)) {
                return false
            }
        }

        return true
    }

    /**
     * @param {*} item1
     * @param {*} item2
     * @returns {Boolean}
     */
    static isEqual(item1, item2) {
        if (item1 === item2) {
            return true
        }

        let type1 = Neo.typeOf(item1),
            type2 = Neo.typeOf(item2);

        if (type1 !== type2) {
            return false
        }

        if (Compare.map[type1]) {
            return Compare[Compare.map[type1]](item1, item2)
        }

        // all other types
        return item1 === item2
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.gatekeep(Compare, 'Neo.core.Compare', () => {
    // alias
    Neo.isEqual = Compare.isEqual
}));


/***/ }),

/***/ "./src/core/Config.mjs":
/*!*****************************!*\
  !*** ./src/core/Config.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EffectManager.mjs */ "./src/core/EffectManager.mjs");
/* harmony import */ var _ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");



/**
 * Represents an observable container for a config property.
 * This class manages the value of a config, its subscribers, and custom behaviors
 * like merge strategies and equality checks defined via a descriptor object.
 *
 * The primary purpose of this class is to enable fine-grained reactivity and
 * decoupled cross-instance state sharing within the Neo.mjs framework.
 * @class Neo.core.Config
 * @private
 * @internal
 */
class Config {
    /**
     * Stores all subscriptions for this Config instance.
     * The data structure is a Map where:
     * - The key is the ID of the subscription owner (e.g., a component's `id`).
     * - The value is another Map (the subscriberMap).
     *
     * The nested subscriberMap is structured as:
     * - The key is the callback function (`fn`).
     * - The value is a Set of scopes (`scopeSet`).
     *
     * This nested structure `Map<string, Map<function, Set<scope>>>` is intentionally chosen
     * to robustly handle the edge case where the same function is subscribed multiple times
     * with different scopes, all under the same owner ID. It ensures that each
     * `fn`-`scope` combination is unique and that cleanup is precise.
     * @member {Object} #subscribers={}
     * @private
     */
    #subscribers = {}
    /**
     * The internal value of the config property.
     * @member {*} #value
     * @private
     */
    #value
    /**
     * The cloning strategy to use when setting a new value.
     * Supported values: 'deep', 'shallow', 'none'.
     * @member {String} clone='deep'
     */

    /**
     * The cloning strategy to use when getting a value.
     * Supported values: 'deep', 'shallow', 'none'.
     * @member {String} cloneOnGet=null
     */

    /**
     * The function used to compare new and old values for equality.
     * Defaults to `Neo.isEqual`. Can be overridden via a descriptor.
     * @member {Function} isEqual=Neo.isEqual
     */

    /**
     * The strategy to use when merging new values into this config.
     * Defaults to 'replace'. Can be overridden via a descriptor merge property.
     * @member {Function|String} mergeStrategy='replace'
     */

    /**
     * Creates an instance of Config.
     * @param {any|Object} configObject - The initial value for the config.
     */
    constructor(configObject) {
        if (Neo.isObject(configObject) && configObject[_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_1__.isDescriptor] === true) {
            this.initDescriptor(configObject)
        } else {
            this.#value = configObject
        }
    }

    /**
     * Gets the current value of the config property.
     * @returns {any} The current value.
     */
    get() {
        // Registers this Config instance as a dependency with the currently active Effect,
        // enabling automatic re-execution when this Config's value changes.
        _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].addDependency(this);
        return this.#value
    }

    /**
     * Initializes the `Config` instance using a descriptor object.
     * Extracts `clone`, `mergeStrategy` and `isEqual` from the descriptor.
     * The internal `#value` is NOT set by this method.
     * @param {Object}    descriptor                      - The descriptor object for the config.
     * @param {string}   [descriptor.clone='deep']        - The clone strategy for set.
     * @param {string}   [descriptor.cloneOnGet]          - The clone strategy for get. Defaults to 'shallow' if clone is 'deep' or 'shallow', and 'none' if clone is 'none'.
     * @param {Function} [descriptor.isEqual=Neo.isEqual] - The equality comparison function.
     * @param {string}   [descriptor.merge='deep']        - The merge strategy.
     * @param {any}       descriptor.value                - The default value for the config (not set by this method).
     */
    initDescriptor({clone, cloneOnGet, isEqual, merge}) {
        let me = this;

        if (clone && clone !== me.clone) {
            Object.defineProperty(me, 'clone', {
                configurable: true, enumerable: true, value: clone, writable: true
            })
        }

        if (cloneOnGet && cloneOnGet !== me.cloneOnGet) {
            Object.defineProperty(me, 'cloneOnGet', {
                configurable: true, enumerable: true, value: cloneOnGet, writable: true
            })
        }

        if (isEqual && isEqual !== me.isEqual) {
            Object.defineProperty(me, 'isEqual', {
                configurable: true, enumerable: true, value: isEqual, writable: true
            })
        }

        if (merge && merge !== me.mergeStrategy) {
            Object.defineProperty(me, 'mergeStrategy', {
                configurable: true, enumerable: true, value: merge, writable: true
            })
        }
    }

    /**
     * Notifies all subscribed callbacks about a change in the config's value.
     * It iterates through the nested subscriber structure to ensure each callback
     * is executed with its intended scope.
     * @param {any} newValue - The new value of the config.
     * @param {any} oldValue - The old value of the config.
     */
    notify(newValue, oldValue) {
        for (const id in this.#subscribers) {
            if (this.#subscribers.hasOwnProperty(id)) {
                const subscriberMap = this.#subscribers[id];
                for (const [fn, scopeSet] of subscriberMap) {
                    for (const scope of scopeSet) {
                        fn.call(scope || null, newValue, oldValue)
                    }
                }
            }
        }
    }

    /**
     * Sets a new value for the config property.
     * This method performs an equality check using `this.isEqual` before updating the value.
     * If the value has changed, it updates `#value` and notifies all subscribers.
     * @param {any} newValue - The new value to set.
     * @returns {Boolean} True if the value changed, false otherwise.
     */
    set(newValue) {
        if (newValue === undefined) return false; // Preserve original behavior for undefined

        const
            me       = this,
            oldValue = me.#value;

        // The setter automatically uses the configured equality check
        if (!me.isEqual(newValue, oldValue)) {
            me.#value = newValue;
            me.notify(newValue, oldValue);
            return true
        }

        return false
    }

    /**
     * Sets the internal value of the config property directly, without performing
     * an equality check or notifying subscribers.
     * This method is intended for internal framework use where direct assignment
     * is necessary (e.g., during initial setup or specific internal optimizations).
     * @param {any} newValue - The new value to set directly.
     */
    setRaw(newValue) {
        this.#value = newValue
    }

    /**
     * Subscribes a callback function to changes in this config's value.
     * The callback will be invoked with `(newValue, oldValue)` whenever the config changes.
     * @param {Object}   options        - An object containing the subscription details.
     * @param {String}   options.id     - The ID of the subscription owner (e.g., a Neo.core.Base instance's id).
     * @param {Function} options.fn     - The callback function.
     * @param {Object}  [options.scope] - The scope to execute the callback in.
     * @returns {Function} A cleanup function to unsubscribe the callback.
     */
    subscribe({id, fn, scope}) {
        if (typeof id !== 'string' || id.length === 0 || typeof fn !== 'function') {
            throw new Error([
                'Config.subscribe: options must be an object with a non-empty string `id` ',
                '(the subscription owner\'s id), and a callback function `fn`.'
            ].join(''))
        }

        const me = this;

        // Get or create the top-level Map for the subscription owner.
        if (!me.#subscribers[id]) {
            me.#subscribers[id] = new Map()
        }

        const subscriberMap = me.#subscribers[id];

        // Get or create the Set of scopes for the specific callback function.
        if (!subscriberMap.has(fn)) {
            subscriberMap.set(fn, new Set())
        }

        const scopeSet = subscriberMap.get(fn);
        scopeSet.add(scope);

        // The returned cleanup function is precise. It removes only the specific
        // scope for the function, and cleans up the parent data structures
        // (the Set and the Maps) only if they become empty.
        return () => {
            const currentSubscriberMap = me.#subscribers[id];
            if (currentSubscriberMap) {
                const currentScopeSet = currentSubscriberMap.get(fn);
                if (currentScopeSet) {
                    currentScopeSet.delete(scope);
                    if (currentScopeSet.size === 0) {
                        currentSubscriberMap.delete(fn);
                        if (currentSubscriberMap.size === 0) {
                            delete me.#subscribers[id]
                        }
                    }
                }
            }
        }
    }
}

Object.defineProperties(Config.prototype, {
    clone        : {configurable: true, enumerable: false, value: 'deep',      writable: false},
    cloneOnGet   : {configurable: true, enumerable: false, value: null,        writable: false},
    isEqual      : {configurable: true, enumerable: false, value: Neo.isEqual, writable: false},
    mergeStrategy: {configurable: true, enumerable: false, value: 'replace',   writable: false}
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.gatekeep(Config, 'Neo.core.Config'));


/***/ }),

/***/ "./src/core/ConfigSymbols.mjs":
/*!************************************!*\
  !*** ./src/core/ConfigSymbols.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isDescriptor: () => (/* binding */ isDescriptor)
/* harmony export */ });

// e.g., in a new file src/core/ConfigSymbols.mjs
const isDescriptor = Symbol.for('Neo.Config.isDescriptor');


/***/ }),

/***/ "./src/core/EffectManager.mjs":
/*!************************************!*\
  !*** ./src/core/EffectManager.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * A singleton manager to track the currently running effect and control global effect execution.
 * It provides a centralized mechanism for pausing, resuming, and batching effect runs.
 * @class Neo.core.EffectManager
 * @singleton
 */
const EffectManager = {
    /**
     * A stack to keep track of the currently active effect and its predecessors.
     * @member {Neo.core.Effect[]} effectStack=[]
     * @protected
     */
    effectStack: [],
    /**
     * A flag to temporarily disable dependency tracking for the active effect.
     * This is used internally to prevent effects from depending on their own state, like `isRunning`.
     * @member {Boolean} isTrackingPaused=false
     * @protected
     */
    isTrackingPaused: false,
    /**
     * A counter to manage nested calls to pause() and resume(). Effect execution is
     * paused or batched while this counter is greater than 0.
     * @member {Number} pauseCounter=0
     * @protected
     */
    pauseCounter: 0,
    /**
     * A Set to store unique effects that are triggered while the manager is paused.
     * These effects will be run when resume() is called and the pauseCounter returns to 0.
     * @member {Set<Neo.core.Effect>} queuedEffects=new Set()
     * @protected
     */
    queuedEffects: new Set(),

    /**
     * Adds a `Neo.core.Config` instance as a dependency for the currently active effect,
     * unless dependency tracking is explicitly paused.
     * @param {Neo.core.Config} config The config instance to add as a dependency.
     */
    addDependency(config) {
        if (!this.isTrackingPaused) {
            this.getActiveEffect()?.addDependency(config)
        }
    },

    /**
     * Returns the effect currently at the top of the stack (i.e., the one currently running).
     * @returns {Neo.core.Effect|null}
     */
    getActiveEffect() {
        return this.effectStack[this.effectStack.length - 1]
    },

    /**
     * Checks if effect execution is currently paused or batched.
     * @returns {Boolean} True if the pauseCounter is greater than 0.
     */
    isPaused() {
        return this.pauseCounter > 0
    },

    /**
     * Pauses effect execution and begins batching.
     * Each call to pause() increments a counter, allowing for nested control.
     */
    pause() {
        this.pauseCounter++
    },

    /**
     * Disables dependency tracking for the currently active effect.
     * @protected
     */
    pauseTracking() {
        this.isTrackingPaused = true
    },

    /**
     * Pops the current effect from the stack.
     * @returns {Neo.core.Effect|null}
     */
    pop() {
        return this.effectStack.pop()
    },

    /**
     * Pushes an effect onto the stack.
     * @param {Neo.core.Effect} effect The effect to push.
     */
    push(effect) {
        this.effectStack.push(effect)
    },

    /**
     * Queues a unique effect to be run later.
     * @param {Neo.core.Effect} effect The effect to queue.
     * @protected
     */
    queue(effect) {
        this.queuedEffects.add(effect)
    },

    /**
     * Resumes effect execution. If the pause counter returns to zero and effects
     * have been queued, they will all be executed synchronously.
     */
    resume() {
        let me = this;

        if (me.pauseCounter > 0) {
            me.pauseCounter--;

            if (me.pauseCounter === 0 && me.queuedEffects.size > 0) {
                const effectsToRun = [...me.queuedEffects];
                me.queuedEffects.clear();
                effectsToRun.forEach(effect => effect.run())
            }
        }
    },

    /**
     * Re-enables dependency tracking for the currently active effect.
     * @protected
     */
    resumeTracking() {
        this.isTrackingPaused = false
    }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.gatekeep(EffectManager, 'Neo.core.EffectManager', () => {
    /**
     * Wraps a function in a batch operation, ensuring that all effects triggered
     * within it are run only once after the function completes.
     * @function Neo.batch
     * @param {Function} fn The function to execute.
     */
    Neo.batch = function(fn) {
        EffectManager.pause();
        try {
            fn()
        } finally {
            // The public resume() method handles running queued effects.
            EffectManager.resume()
        }
    }
}));


/***/ }),

/***/ "./src/core/IdGenerator.mjs":
/*!**********************************!*\
  !*** ./src/core/IdGenerator.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Provides a singleton utility for generating unique IDs.
 * @namespace Neo.core.IdGenerator
 */
const IdGenerator = {
    /**
     * The default prefix for neo instance ids
     * @member {String} base='neo-'
     */
    base: 'neo-',
    /**
     * @member {Object} idCounter={}
     */
    idCounter: {},

    /**
     * @param name
     * @returns {string}
     */
    getId(name) {
        name = name || 'neo';

        let me      = this,
            counter = me.idCounter,
            count   = counter[name] || 0;

        counter[name] = ++count;

        return me.base + (name === 'neo' ? '' : name + '-') + count;
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.gatekeep(IdGenerator, 'Neo.core.IdGenerator', () => {
    Neo.getId = IdGenerator.getId.bind(IdGenerator);
}));


/***/ }),

/***/ "./src/core/Observable.mjs":
/*!*********************************!*\
  !*** ./src/core/Observable.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");
/* harmony import */ var _util_Function_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Function.mjs */ "./src/util/Function.mjs");





/**
 * A unique, non-enumerable key for the internal event map.
 * Using a Symbol prevents property name collisions on the consuming class instance,
 * providing a robust way to manage private state within a mixin.
 * @type {Symbol}
 */
const eventMapSymbol = Symbol('eventMap');

/**
 * @class Neo.core.Observable
 * @extends Neo.core.Base
 */
class Observable extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.core.Observable'
         * @protected
         */
        className: 'Neo.core.Observable',
        /**
         * @member {String} ntype='mixin-observable'
         * @protected
         */
        ntype: 'mixin-observable',
        /**
         * A declarative way to assign event listeners to an instance upon creation.
         * The framework processes this config and calls `on()` to populate the
         * internal event registry. This config should not be manipulated directly after
         * instantiation; use `on()` and `un()` instead.
         * @member {Object|null} listeners_
         * @example
         * listeners: {
         *     myEvent: 'onMyEvent',
         *     otherEvent: {
         *         fn: 'onOtherEvent',
         *         delay: 100,
         *         once: true
         *     },
         *     scope: this
         * }
         * @reactive
         */
        listeners_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_2__.isDescriptor]: true,
            merge         : 'deep',
            value         : {}
        }
    }

    /**
     * @member {Object} [eventMapSymbol]
     * @private
     */

    /**
     * @param {Object|String} name
     * @param {Object} [opts]
     * @param {Object} [scope]
     * @param {String} [eventId]
     * @param {Object} [data]
     * @param {Number|String} [order]
     * @returns {String|null} eventId null in case an object gets passed as the name (multiple ids)
     */
    addListener(name, opts, scope, eventId, data, order) {
        let me            = this,
            delay         = 0,
            eventIdObject = typeof eventId === 'object',
            nameObject    = typeof name    === 'object',
            once          = false,
            optsType      = typeof opts,
            listener, existing, eventConfig;

        /*
         * let us support the following format too:
         *
         * currentWorker.on('connected', () => {
         *     Base.sendRemotes(className, remote)
         * }, me, {once: true})
         */
        if (eventIdObject && optsType === 'function') {
            eventId.fn = opts;
            opts     = eventId;
            optsType = 'object';
            eventId  = null;
        }

        if (nameObject) {
            if (name.hasOwnProperty('delay')) {
                delay = name.delay;
                delete name.delay
            }

            if (name.hasOwnProperty('once')) {
                once = name.once;
                delete name.once
            }

            if (name.hasOwnProperty('order')) {
                order = name.order;
                delete name.order
            }

            if (name.hasOwnProperty('scope')) {
                scope = name.scope;
                delete name.scope
            }

            Object.entries(name).forEach(([key, value]) => {
                if (Neo.isObject(value)) {
                    me.addListener(key, {delay, once, order, scope, ...value})
                } else {
                    me.addListener(key, {delay, fn: value, once, order, scope})
                }
            })
        } else if (optsType === 'object') {
            delay    = delay   || opts.delay;
            eventId  = eventId || opts.eventId;
            listener = opts.fn;
            once     = once    || opts.once;
            order    = order   || opts.order;
            scope    = scope   || opts.scope
        } else if (optsType === 'function') {
            listener = opts
        } else if (optsType === 'string') {
            listener = opts // VC hook, can get parsed after onConstructed in case the view uses the parent VC
        } else {
            throw new Error('Invalid addListener call: ' + name)
        }

        if (!nameObject) {
            // LAZY INITIALIZATION: The key to a robust mixin.
            // This ensures the private internal listener store exists on the instance.
            // `eventMapSymbol` is the *actual* registry of handler arrays, and is
            // intentionally separate from the public `listeners_` config.
            me[eventMapSymbol] ??= {};

            eventConfig = {fn: listener, id: eventId || Neo.getId('event')};

            if (data)      {eventConfig.data   = data}
            if (delay > 0) {eventConfig.delay  = delay}
            if (once)      {eventConfig.once   = once}
            if (scope)     {eventConfig.scope  = scope}

            if ((existing = me[eventMapSymbol][name])) {
                existing.forEach(cfg => {
                    if (cfg.id === eventId || (cfg.fn === listener && cfg.scope === scope)) {
                        console.error('Duplicate event handler attached:', name, me)
                    }
                });

                if (typeof order === 'number') {
                    existing.splice(order, 0, eventConfig)
                } else if (order === 'before') {
                    existing.unshift(eventConfig)
                } else {
                    existing.push(eventConfig)
                }
            } else {
                me[eventMapSymbol][name] = [eventConfig] // Use the private eventMapSymbol registry
            }

            return eventConfig.id
        }

        return null
    }

    /**
     * This hook is the bridge between the declarative `listeners_` config and the
     * imperative `on()`/`un()` methods. It's called automatically by the framework
     * whenever the `listeners` config property is changed.
     * @param {Object} value The new listeners object
     * @param {Object} oldValue The old listeners object
     * @protected
     */
    afterSetListeners(value, oldValue) {
        // Unregister any listeners from the old config object
        if (oldValue && Object.keys(oldValue).length > 0) {
            this.un(oldValue)
        }
        // Register all listeners from the new config object
        if (value && Object.keys(value).length > 0) {
            this.on(value)
        }
    }

    /**
     * Call the passed function, or a function by *name* which exists in the passed scope's
     * or this component's ownership chain.
     * @param {Function|String} fn A function, or the name of a function to find in the passed scope object.
     * @param {Object} scope       The scope to find the function in if it is specified as a string.
     * @param {Array} args         Arguments to pass to the callback.
     */
    callback(fn, scope=this, args) {
        if (fn) {
            const handler = (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_3__.resolveCallback)(fn, scope);
            handler.fn.apply(handler.scope, args)
        }
    }

    /**
     * Internal helper method for events which use the delay option
     * @param {Object} cb
     * @param {Array} args
     * @param {Number} delay
     */
    delayedCallback(cb, args, delay) {
        this.timeout(delay).then(() => {
            cb.fn.apply(cb.scope, args)
        })
    }

    /**
     * @param name
     */
    fire(name) {
        let me        = this,
            args      = [].slice.call(arguments, 1),
            listeners = me[eventMapSymbol], // Always use the private, structured registry for firing events.
            delay, handler, handlers, i, len;

        if (listeners && listeners[name]) {
            handlers = [...listeners[name]];
            len      = handlers.length;

            for (i = 0; i < len; i++) {
                handler = handlers[i];
                delay   = handler.delay;

                // Resolve function name on the scope (or me), or, if it starts with 'up.'
                // look in the ownership hierarchy from me.
                const cb = (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_3__.resolveCallback)(handler.fn, handler.scope || me);

                // remove the listener if the scope no longer exists
                if (cb.scope && !cb.scope.id) {
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(listeners[name], handler)
                } else {
                    if (!me.suspendEvents) {
                        // Object event format. Inject firer reference in as 'source'
                        if (args.length === 1 && Neo.isObject(args[0])) {
                            args[0].source = me.id
                        }

                        // remove the listener if it has the once flag
                        handler.once && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(listeners[name], handler);

                        if (Neo.isNumber(delay) && delay > 0) {
                            me.delayedCallback(cb, handler.data ? args.concat(handler.data) : args, delay)
                        } else {
                            cb.fn.apply(cb.scope, handler.data ? args.concat(handler.data) : args)
                        }
                    }
                }
            }
        }
    }

    /**
     * Alias for addListener
     * @param {Object|String} name
     * @param {Object} [opts]
     * @param {Object} [scope]
     * @param {String} [eventId]
     * @param {Object} [data]
     * @param {Number} [order]
     * @returns {String} eventId
     */
    on(...args) {
        return this.addListener(...args)
    }

    /**
     * There are different syntax's how you can use this method.
     * Using the eventId:
     * ```
     * this.removeListener('change', 'neo-event-7');
     * ```
     * Passing the handler method:
     * ```
     * this.removeListener('change', this.onChange, this);
     * ```
     * Passing an object:
     * ```
     * me.field.un({
     *     change                    : me.onFieldChange,
     *     changeClearToOriginalValue: me.onFieldChange,
     *     scope                     : me
     * });
     * ```
     * @param {Object|String} name
     * @param {Function|String} [eventId]
     * @param {Neo.core.Base} [scope]
     */
    removeListener(name, eventId, scope) {
        let me = this,
            i, len, listener, listeners, match;

        // LAZY INITIALIZATION: Ensure the internal listener store exists.
        me[eventMapSymbol] ??= {};

        if (Neo.isFunction(eventId)) {
            me.removeListener({[name]: eventId, scope});
            return
        }

        if (Neo.isObject(name)) {
            if (name.scope) {
                scope = name.scope;
                delete name.scope;
            }

            Object.entries(name).forEach(([key, value]) => {
                listeners = me[eventMapSymbol][key] || [];
                i         = 0;
                len       = listeners.length;

                for (; i < len; i++) {
                    listener = listeners[i];

                    if (
                        listener.fn.name === (Neo.isString(value) ? value : value.name) &&
                        listener.scope   === scope
                    ) {
                        listeners.splice(i, 1);
                        break
                    }
                }
            })
        } else if (Neo.isString(eventId)) {
            listeners = me[eventMapSymbol][name];
            match     = false;

            listeners.forEach((eventConfig, idx) => {
                if (eventConfig.id === eventId) {
                    return match = idx
                }
            });

            if (match !== false) {
                listeners.splice(match, 1)
            }
        }
    }

    /**
     * Alias for removeListener
     * @param {Object|String} name
     * @param {String} [eventId]
     */
    un(...args) {
        this.removeListener(...args);
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Observable));


/***/ }),

/***/ "./src/core/Util.mjs":
/*!***************************!*\
  !*** ./src/core/Util.mjs ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @class Neo.core.Util
 */
class Util {
    /**
     * A regex to remove camel case syntax
     * @member {RegExp} decamelRegEx=/([a-z])([A-Z])/g
     * @protected
     * @static
     */
    static decamelRegEx = /([a-z])([A-Z])/g

    /**
     * @param {Object} scope
     * @param {String[]} values
     */
    static bindMethods(scope, values) {
        values.forEach(value => {
            scope[value] = scope[value].bind(scope)
        })
    }

    /**
     * Transforms a styles string into a styles object using camelcase syntax
     * @param {String} string The styles string to parse
     * @returns {Object} The camelcase styles object
     */
    static createStyleObject(string) {
        let parts;

        // split(';') does fetch semicolons inside brackets
        // -> background-image: "url('data:image/png;base64,...

        // TODO: Cache all regex
        return string.split(/;(?=[^\)]*(?:\(|$))/g).reduce((obj, el) => {
            // we have to split by the first colon only
            // -> background-image: url('http://example.com/image.png')
            parts = el.split((/:(.+)/)).map(function (x) {
                let num = parseFloat(x);

                return x == num ? num : x.trim()
            });

            if (parts[0] !== '') {
                parts[0] = parts[0].replace(/-([a-z])/g, (str, letter) => {
                    return letter.toUpperCase()
                });

                obj[parts[0]] = parts[1]
            }
            return obj
        }, {})
    }

    /**
     * Converts a styles object which can use camelcase syntax into a styles string
     * @param {Object} styles The styles object
     * @returns {String} The styles string (DOM ready)
     */
    static createStyles(styles) {
        let style = '';

        Object.entries(styles).forEach(([key, value]) => {
            if (value !== undefined && value !== null) {
                style += Util.decamel(key) + ':' + value + ';'
            }
        });

        return style
    }

    /**
     * Transforms all uppercase characters of a string into -lowercase.
     * Does not touch special characters.
     * @param {String} value The input containing uppercase characters
     * @returns {String} The lowercase output
     */
    static decamel(value) {
        return value.replace(Util.decamelRegEx, '$1-$2').toLowerCase()
    }

    /**
     * Returns true if the passed value is an array
     * @param {Object} value The value to test
     * @returns {Boolean}
     */
    static isArray(value) {
        return Array.isArray(value)
    }

    /**
     * Returns true if the passed value is a boolean
     * @param {Object} value The value to test
     * @returns {Boolean}
     */
    static isBoolean(value) {
        return typeof value === 'boolean'
    }

    /**
     * Returns true if the passed value is not undefined
     * @param {Object} value The value to test
     * @returns {Boolean}
     */
    static isDefined(value) {
        return typeof value !== 'undefined'
    }

    /**
     * Returns true if the passed value is an empty Array, Object or String
     * @param {Array|Object|String} value The value to test
     * @returns {Boolean}
     */
    static isEmpty(value) {
        if (value === null || value === undefined) {
            return true
        }

        if (Array.isArray(value)) {
            return value.length === 0
        }

        if (value instanceof Date) {
            return false
        }

        if (Util.isObject(value)) {
            return Object.keys(value).length === 0
        }

        if (Util.isString(value)) {
            return value === ''
        }

        return false
    }

    /**
     * Returns true if the passed value is a function
     * @param {Function} value The value to test
     * @returns {Boolean}
     */
    static isFunction(value) {
        return typeof value === 'function'
    }

    /**
     * Returns true if the passed value is a number. Returns false for non-finite numbers
     * @param {Number} value The value to test
     * @returns {Boolean}
     */
    static isNumber(value){
        return typeof value === 'number' && isFinite(value)
    }

    /**
     * Returns true if the passed value is an object
     * @param {Object} value The value to test
     * @returns {Boolean}
     */
    static isObject(value) {
        return value?.constructor?.name === 'Object'
    }

    /**
     * Returns true if the passed value is a promise.
     * We are intentionally not checking for `value instanceof Promise`,
     * to support any "thenable" objects for flexibility.
     * @param {Object} value The value to test
     * @returns {Boolean}
     */
    static isPromise(value) {
        return typeof value?.then === 'function'
    }

    /**
     * Returns true if the passed value is a neo data record
     * @param {Object} value The value to test
     * @returns {Boolean}
     */
    static isRecord(value) {
        return value?.constructor?.name === 'Record'
    }

    /**
     * Returns true if the passed value is a string
     * @param {String} value The value to test
     * @returns {Boolean}
     */
    static isString(value) {
        return typeof value === 'string'
    }

    /**
     * Converts any iterable (strings, numeric indices and a length property) into a true array
     * @param {Object|String} iterable
     * @param {Number} [start=0] start index
     * @param {Number} [end=iterable.length] end index
     * @returns {Array}
     */
    static toArray(iterable, start, end) {
        let len;

        if (!iterable || !(len = iterable.length)) {
            return []
        }

        if (typeof iterable === 'string') {
            return iterable.split('')
        }

        return Array.prototype.slice.call(iterable, start || 0, end || len)
    }
}

const ns = Neo.ns('Neo.core', true);
ns.Util = Util;

// aliases
Neo.applyFromNs(Neo, Util, {
    bindMethods      : 'bindMethods',
    createStyleObject: 'createStyleObject',
    createStyles     : 'createStyles',
    decamel          : 'decamel',
    isArray          : 'isArray',
    isBoolean        : 'isBoolean',
    isDefined        : 'isDefined',
    isEmpty          : 'isEmpty',
    isFunction       : 'isFunction',
    isNumber         : 'isNumber',
    isObject         : 'isObject',
    isPromise        : 'isPromise',
    isRecord         : 'isRecord',
    isString         : 'isString',
    toArray          : 'toArray'
}, true);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Util);


/***/ }),

/***/ "./src/core/_export.mjs":
/*!******************************!*\
  !*** ./src/core/_export.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Base: () => (/* reexport safe */ _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   Compare: () => (/* reexport safe */ _Compare_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   IdGenerator: () => (/* reexport safe */ _IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   Observable: () => (/* reexport safe */ _Observable_mjs__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   Util: () => (/* reexport safe */ _Util_mjs__WEBPACK_IMPORTED_MODULE_4__["default"])
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _Compare_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Compare.mjs */ "./src/core/Compare.mjs");
/* harmony import */ var _IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./IdGenerator.mjs */ "./src/core/IdGenerator.mjs");
/* harmony import */ var _Observable_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _Util_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Util.mjs */ "./src/core/Util.mjs");









/***/ }),

/***/ "./src/manager/Base.mjs":
/*!******************************!*\
  !*** ./src/manager/Base.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../collection/Base.mjs */ "./src/collection/Base.mjs");


/**
 * Abstract base class for the other manager classes
 * @class Neo.manager.Base
 * @extends Neo.collection.Base
 */
class Manager extends _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]{
    static config = {
        /**
         * @member {String} className='Neo.manager.Base'
         * @protected
         */
        className: 'Neo.manager.Base'
    }

    /**
     * @param {Number|String} id
     * @returns {Object}
     */
    getById(id) {
        return id && this.get(id) || null
    }

    /**
     * @param {Object} item
     */
    register(item) {
        let me = this;

        if (me.get(item.id)) {
            Neo.logError('Trying to create an item with an already existing id', item, me.get(item.id))
        } else {
            me.push(item)
        }
    }

    /**
     * Removes a collection item passed by reference or key
     * @param {Object|String} item
     */
    unregister(item) {
        this.remove(item)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Manager));


/***/ }),

/***/ "./src/manager/ClassHierarchy.mjs":
/*!****************************************!*\
  !*** ./src/manager/ClassHierarchy.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/manager/Base.mjs");


/**
 * @class Neo.manager.ClassHierarchy
 * @extends Neo.manager.Base
 * @singleton
 *
 * This manager maintains a registry of all classes defined within the Neo.mjs framework's current realm (main or worker),
 * including their inheritance relationships and key metadata.
 * Each registered item (value in the manager's store) has the following structure:
 * @typedef {Object} ClassHierarchyInfo
 * @property {String} className - The full Neo.mjs class name (e.g., 'Neo.component.Base').
 * @property {Function|Object} module - The direct reference to the class constructor function itself (for non-singletons)
 * or the instantiated singleton object (for singletons).
 * @property {String|null} ntype - The ntype of the class if defined (e.g., 'button', 'container'), otherwise `null`.
 * @property {String|null} parentClassName - The full class name of its direct parent class,
 * or `null` if it's a top-level class (e.g., 'Neo.core.Base').
 */
class ClassHierarchy extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.ClassHierarchy'
         * @protected
         */
        className: 'Neo.manager.ClassHierarchy',
        /**
         * @member {String} keyProperty='className'
         * @protected
         */
        keyProperty: 'className',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * Memoizes the return values of isA() calls
     * @member {Map} isAQueryMap=new Map()
     * @protected
     */
    isAQueryMap = new Map()

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);
        this.consumeTempMap()
    }

    /**
     * Register all classes that got applied to the Neo namespace before this instance got created
     * @protected
     */
    consumeTempMap() {
        if (Neo.classHierarchyMap) {
            this.add(Object.values(Neo.classHierarchyMap));
            delete Neo.classHierarchyMap
        }
    }

    /**
     * Both params represent classNames.
     *
     * Example use cases:
     * - isA('Neo.button.Menu',    'Neo.button.Base')    => true
     * - isA('Neo.button.Base',    'Neo.button.Menu')    => false
     * - isA('Neo.button.Base',    'Neo.component.Base') => true
     * - isA('Neo.component.Base', 'Neo.core.Base')      => true
     * @param {String} descendant
     * @param {String} ancestor
     * @returns {Boolean}
     */
    isA(descendant, ancestor) {
        if (descendant === ancestor) {
            return true
        }

        let parent        = descendant,
            {isAQueryMap} = this,
            queryName     = `${descendant},${ancestor}`,
            returnValue   = false;

        if (isAQueryMap.has(queryName)) {
            return isAQueryMap.get(queryName)
        }

        while (parent = this.get(parent)?.parentClassName) {
            if (parent === ancestor) {
                returnValue = true;
                break
            }

            // Assumption: component.Base directly extends core.Base
            if (parent === 'Neo.component.Base' && ancestor !== 'Neo.core.Base') {
                returnValue = false;
                break
            }

            if (parent === 'Neo.core.Base') {
                returnValue = false;
                break
            }
        }

        isAQueryMap.set(queryName, returnValue);

        return returnValue
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(ClassHierarchy));


/***/ }),

/***/ "./src/manager/Component.mjs":
/*!***********************************!*\
  !*** ./src/manager/Component.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/manager/Base.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/VDom.mjs */ "./src/util/VDom.mjs");
/* harmony import */ var _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/VNode.mjs */ "./src/util/VNode.mjs");




/**
 * @class Neo.manager.Component
 * @extends Neo.manager.Base
 * @singleton
 */
class Component extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.Component'
         * @protected
         */
        className: 'Neo.manager.Component',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * @member {Map} wrapperNodes=new Map()
     */
    wrapperNodes = new Map()

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        Neo.first        = me.getFirst.bind(me); // alias
        Neo.getComponent = me.get     .bind(me)  // alias
    }

    /**
     * Flattens a given vnode tree by replacing component based subtrees with componentId based references
     * @param {Object} vnode
     * @param {String} ownerId We do not want to replace the own id => wrapped items
     * @returns {Object}
     */
    addVnodeComponentReferences(vnode, ownerId) {
        vnode = {...vnode}; // shallow copy

        let me         = this,
            childNodes = vnode?.childNodes ? [...vnode.childNodes] : [],
            childNodeId, component, componentId, parentRef, referenceNode;

        vnode.childNodes = childNodes;

        childNodes.forEach((childNode, index) => {
            childNodeId = childNode.id;

            if (!childNode.componentId && childNodeId !== ownerId) {
                component = me.get(childNodeId);

                if (!component) {
                    // searching for wrapped components as a fallback
                    component = me.wrapperNodes.get(childNodeId);

                    if (component) {
                        // update the parent component reference => assign the wrapper id
                        componentId = component.id;
                        parentRef   = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].find(component.parent.vdom, {componentId}, false);

                        if (parentRef) {
                            parentRef.vdom.id = childNodeId
                        }
                    }
                }

                if (component) {
                    componentId   = component.id;
                    referenceNode = {componentId};

                    if (componentId !== childNodeId) {
                        referenceNode.id = childNodeId
                    }
                }
            }

            childNodes[index] = component ? referenceNode : me.addVnodeComponentReferences(childNode, ownerId)
        });

        return vnode
    }

    /**
     * Returns the first component which matches the config-selector moving down the component items tree.
     * Use returnFirstMatch=false to get an array of all matching items instead.
     * If no match is found, returns null in case returnFirstMatch === true, otherwise an empty Array.
     * @param {Neo.component.Base|String} component
     * @param {Object|String|null} config
     * @param {Boolean} returnFirstMatch=true
     * @returns {Neo.component.Base|Neo.component.Base[]|null}
     */
    down(component, config, returnFirstMatch=true) {
        if (Neo.isString(component)) {
            component = this.getById(component);
        }

        let me          = this,
            matchArray  = [],
            returnValue = null,
            i           = 0,
            returnArray = [],
            childItems, configArray, configLength, len;

        if (Neo.isString(config)) {
            config = {
                ntype: config
            }
        } else if (!config) {
            config = {}
        }

        configArray  = Object.entries(config);
        configLength = configArray.length;

        configArray.forEach(([key, value]) => {
            if ((component[key] === value)
                || (key === 'ntype' && me.hasPrototypePropertyValue(component, key, value)))
            {
                matchArray.push(true)
            }
        });

        if (matchArray.length === configLength) {
            if (returnFirstMatch) {
                return component
            }

            returnArray.push(component)
        }

        childItems = me.find({parentId: component.id});
        len        = childItems.length;

        for (; i < len; i++) {
            returnValue = me.down(childItems[i], config, returnFirstMatch);

            if (returnFirstMatch) {
                if (returnValue !== null) {
                    return returnValue
                }
            } else if (returnValue.length > 0) {
                returnArray.push(...returnValue)
            }
        }

        return returnFirstMatch ? null: returnArray
    }

    /**
     * @param {Object[]} path
     * @returns {String|null} the component id in case there is a match
     */
    findParentComponent(path) {
        let me  = this,
            i   = 0,
            len = path?.length || 0,
            id;

        for (; i < len; i++) {
            id = path[i];

            if (id && me.has(id)) {
                return id
            }
        }

        return null
    }

    /**
     * Returns the object associated to the key, or null if there is none.
     * @param {Number|String} key
     * @param {Boolean}       [includeWrapperNodes=true]
     * @returns {Neo.component.Base|null}
     */
    get(key, includeWrapperNodes=true) {
        if (includeWrapperNodes) {
            let wrapperNode = this.wrapperNodes.get(key);

            if (wrapperNode) {
                return wrapperNode
            }
        }

        return super.get(key)
    }

    /**
     * Returns all child components which are recursively matched via their parentId
     * @param {Neo.component.Base} component
     * @returns {Neo.component.Base[]} childComponents
     */
    getChildComponents(component) {
        let me             = this,
            directChildren = me.find('parentId', component.id) || [],
            components     = [],
            childComponents;

        directChildren.forEach(item => {
            components.push(item);

            childComponents = me.getChildComponents(item);

            childComponents && components.push(...childComponents)
        });

        return components
    }

    /**
     * todo: replace all calls of this method to calls using the util.VNode class
     * Get the ids of all child nodes of the given vnode
     * @param {Object} vnode
     * @param {String[]} childIds=[]
     * @returns {String[]} childIds
     */
    getChildIds(vnode, childIds=[]) {
        return _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getChildIds(vnode, childIds)
    }

    /**
     * Returns all child components found inside the vnode tree
     * @param {Neo.component.Base} component
     * @returns {Neo.component.Base[]} childComponents
     */
    getChildren(component) {
        let childComponents = [],
            childNodes      = _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getChildIds(component.vnode),
            childComponent;

        childNodes.forEach(node => {
            childComponent = this.get(node);

            if (childComponent) {
                childComponents.push(childComponent)
            }
        });

        return childComponents
    }

    /**
     * !! For debugging purposes only !!
     *
     * Get the first component based on the ntype or other properties
     *
     * @param {String|Object|Array} componentDescription
     * @param {Boolean} returnFirstMatch=true
     * @returns {Neo.component.Base|null|Neo.component.Base[]}
     *
     * @example
     // as String: ntype[comma separated propterties]
     Neo.first('toolbar button[text=Try me,icon=people]')
     // as Object: Add properties. ntype is optional
     Neo.first({
                icon: 'people'
            })
     // as Array: An Array of Objects. No Strings allowed
     Neo.first([{
                ntype: 'toolbar'
            },{
                ntype: 'button', text: 'Try me', icon: 'people
            }])

     * The returnFirstMatch flag allows to return all items and
     * not stop after the first result.
     *
     * @example
     Neo.first('button', false) // => [Button, Button, Button]
     */
    getFirst(componentDescription, returnFirstMatch = true) {
        let objects = [],
            app     = Neo.apps[Object.keys(Neo.apps)[0]],
            root    = app.mainView;

        /* create an array of objects from string */
        if (Neo.isString(componentDescription)) {
            const regex = /(\w*)(\[[^\]]*\])|(\w*)/g;
            let match;

            /* generate objects which contain the information */
            while (match = regex.exec(componentDescription)) {
                let [, ntype, pairs, ntypeOnly] = match, obj;

                ntype = ntype || ntypeOnly;
                obj = {ntype};

                if (pairs) {
                    const pairsRegex = /\[(.*?)\]/,
                          pairsMatch = pairs.match(pairsRegex);

                    if (pairsMatch) {
                        const pairs = pairsMatch[1].split(',');
                        pairs.forEach((pair) => {
                            const [key, value] = pair.split('=');
                            obj[key] = value.replace(/"/g, '')
                        });
                    }
                }
                objects.push(obj);

                regex.lastIndex++
            }
        } else if (Neo.isObject(componentDescription)){
            objects.push(componentDescription)
        } else if (Neo.isArray(componentDescription)) {
            objects = componentDescription
        }

        /* find the correct child using down() */
        const result = objects.reduce((acc, key) => {
            if (acc) {
                let child = acc.down(key, returnFirstMatch);

                if (!!child) {
                    return child
                }
            }

            return null
        }, root);

        return result
    }

    /**
     * Returns an Array containing the ids of all parent components for a given component
     * @param {Neo.component.Base} component
     * @returns {String[]} parentIds
     */
    getParentIds(component) {
        let parentIds = [];

        while (component?.parentId) {
            component = this.get(component.parentId);

            if (component) {
                parentIds.push(component.id)
            }
        }

        return parentIds
    }

    /**
     * @param {Array} path
     * @returns {Array}
     */
    getParentPath(path) {
        let me            = this,
            componentPath = [],
            i             = 0,
            len           = path?.length || 0;

        for (; i < len; i++) {
            if (me.has(path[i]) || me.wrapperNodes.get(path[i])) {
                componentPath.push(path[i])
            }
        }

        return componentPath
    }

    /**
     * Returns an Array containing all parent components for a given component or component id
     * @param {Neo.component.Base|String} component
     * @returns {Neo.component.Base[]} parents
     */
    getParents(component) {
        if (Neo.isString(component)) {
            component = this.get(component)
        }

        let parents = [];

        while (component?.parentId) {
            component = this.get(component.parentId);

            if (component) {
                parents.push(component)
            }
        }

        return parents
    }

    /**
     * Check if the component had a property of any value somewhere in the Prototype chain
     *
     * @param {Neo.component.Base} component
     * @param {String} property
     * @param {*} value
     * @returns {boolean}
     */
    hasPrototypePropertyValue(component, property, value) {
        while (component !== null) {
            if (component.hasOwnProperty(property) && component[property] === value) {
                return true
            }

            component = component.__proto__
        }

        return false
    }

    /**
     * @param {String} wrapperId
     * @param {Neo.component.Base} component
     */
    registerWrapperNode(wrapperId, component) {
        this.wrapperNodes.set(wrapperId, component)
    }

    /**
     * @param {Neo.component.Base|String} item
     */
    unregister(item) {
        if (item) {
            if (Neo.isString(item)) {
                this.wrapperNodes.delete(item)
            } else if (item.id !== item.vdom.id) {
                this.wrapperNodes.delete(item.vdom.id)
            }
        }

        super.unregister(item)
    }

    /**
     * Returns the first component which matches the config-selector.
     * Use returnFirstMatch=false to get an array of all matching items instead.
     * If no match is found, returns null in case returnFirstMatch === true, otherwise an empty Array.
     * @param {String} componentId
     * @param {Object|String|null} config
     * @param {Boolean} returnFirstMatch=true
     * @returns {Neo.component.Base|Neo.component.Base[]|null}
     */
    up(componentId, config, returnFirstMatch=true) {
        let component   = this.get(componentId),
            returnArray = [],
            configArray, configLength, matchArray;

        if (Neo.isString(config)) {
            config = {
                ntype: config
            }
        } else if (!config) {
            config = {}
        }

        configArray  = Object.entries(config);
        configLength = configArray.length;

        while (component?.parentId) {
            component = this.get(component.parentId);

            if (!component) {
                return returnFirstMatch ? null : returnArray
            }

            matchArray = [];

            configArray.forEach(([key, value]) => {
                if (component[key] === value) {
                    matchArray.push(true)
                }
            });

            if (matchArray.length === configLength) {
                if (returnFirstMatch) {
                    return component
                }

                returnArray.push(component)
            }
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Component));


/***/ }),

/***/ "./src/manager/DomEvent.mjs":
/*!**********************************!*\
  !*** ./src/manager/DomEvent.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Component.mjs */ "./src/manager/Component.mjs");
/* harmony import */ var _Focus_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Focus.mjs */ "./src/manager/Focus.mjs");
/* harmony import */ var _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Logger.mjs */ "./src/util/Logger.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/VDom.mjs */ "./src/util/VDom.mjs");







const eventConfigKeys = [
    'bubble',
    'delegate',
    'local',
    'scope',
    'vnodeId'
];

const globalDomEvents = [
    'change',
    'click',
    'contextmenu',
    'dblclick',
    'drag:end',
    'drag:move',
    'drag:start',
    'focusin',
    'focusout',
    'input',
    'intersect',
    'keydown',
    'keyup',
    'mousedown',
    'mouseenter',
    'mouseleave',
    'mouseup',
    'neonavigate',
    'scroll',
    'selectionchange',
    'touchmove',
    'wheel'
];

/**
 * @class Neo.manager.DomEvent
 * @extends Neo.core.Base
 * @singleton
 */
class DomEvent extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.DomEvent'
         * @protected
         */
        className: 'Neo.manager.DomEvent',
        /**
         * @member {Object} items={}
         * @protected
         */
        items: {},
        /**
         * @member {Object} map={}
         * @protected
         */
        map: {},
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     *
     * @param {Neo.component.Base} component
     * @param {data} event
     */
    addResizeObserver(component, event) {
        if (!Neo.main.addon.ResizeObserver) {
            console.error('For using resize domListeners, you must include main.addon.ResizeObserver.', event)
        }

        let {id, windowId} = component;

        Neo.main.addon.ResizeObserver.register({id, windowId})
    }

    /**
     * @param {Object} event
     * @protected
     */
    fire(event) {
        let me          = this,
            bubble      = true,
            data        = event.data || {},
            {eventName} = event,
            i           = 0,
            listeners   = null,
            pathIds     = data.path.map(e => e.id),
            path        = _Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getParentPath(pathIds),
            len         = path.length,
            component, delegationTargetId, id, preventFire;

        for (; i < len; i++) {
            id        = path[i];
            component = Neo.getComponent(id);

            if (!component || component.disabled) {
                break
            }

            listeners = me.items[id]?.[eventName];

            if (listeners) {
                if (Array.isArray(listeners)) {
                    // Stop iteration if a handler returns false
                    listeners.every(listener => {
                        let result;

                        if (listener && listener.fn) {
                            if (eventName === 'resize') {
                                // we do not want delegation for custom main.addon.ResizeObserver events
                                delegationTargetId = data.id === component.id ? data.id : false
                            } else {
                                delegationTargetId = me.verifyDelegationPath(listener, data.path)
                            }

                            if (delegationTargetId !== false) {
                                preventFire = false;

                                // we only want mouseenter & leave to fire on their top level nodes, not for children
                                if (eventName === 'mouseenter' || eventName === 'mouseleave') {
                                    preventFire = !DomEvent.verifyMouseEnterLeave(component, data, delegationTargetId, eventName)
                                }

                                if (!preventFire) {
                                    // multiple listeners would change the reference of data.component
                                    data = Neo.clone(data, true, true);

                                    data.component = component;

                                    // Handler needs to know which actual target matched the delegate
                                    data.currentTarget = delegationTargetId;

                                    if (Neo.isString(listener.fn)) {
                                        me.bindCallback(listener.fn, 'fn', listener.scope, listener)
                                    }

                                    result = listener.fn.apply(listener.scope || globalThis, [data]);

                                    if (!listener.bubble) {
                                        bubble = false
                                    }
                                }
                            }
                        }
                        // If a listener returns false, we stop iterating the listeners
                        return result !== false
                    })
                }
            }

            // we do want to trigger the FocusManager after normal domListeners on these events got executed
            if (eventName === 'focusin' || eventName === 'focusout') {
                _Focus_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]['on' + Neo.capitalize(eventName)]({
                    componentPath: path,
                    data
                });

                break
            }

            // Honor the Event cancelBubble property
            if (!bubble || data.cancelBubble) {
                break
            }
        }

        if (eventName === 'contextmenu' && data.ctrlKey) {
            Neo.util?.Logger?.onContextMenu(data)
        } else if (eventName.startsWith('drop')) {
            let dragZone = data.dragZoneId && Neo.get(data.dragZoneId);

            if (dragZone) {
                dragZone.fire(eventName, data);
                dragZone[{
                    'drop'      : 'onDrop',
                    'drop:enter': 'onDropEnter',
                    'drop:leave': 'onDropLeave',
                }[eventName]].call(dragZone, data)
            }
        }
    }

    /**
     * @param config
     * @param scope
     * @returns {Object}
     */
    generateListenerConfig(config, scope) {
        return {
            bubble   : config.bubble,
            delegate : config.delegate,
            eventName: config.eventName,
            id       : scope.id,
            opts     : config,
            priority : config.priority,
            scope    : config.scope   || scope,
            vnodeId  : config.vnodeId || scope.vdom.id
        };
    }

    getEventName(config) {
        let eventName = null;

        if (Neo.isObject(config)) {
            Object.keys(config).forEach(key => {
                if (!eventConfigKeys.includes(key)) {
                    eventName = key
                }
            })
        }

        return eventName
    }

    /**
     * @param {Object} config
     * @param {Boolean} config.bubble
     * @param {String} config.delegate
     * @param {String} config.eventName
     * @param {String} config.id
     * @param {Object} config.opts
     * @param {Object} config.scope
     * @param {String} config.vnodeId
     * @returns {Object}
     */
    getListener(config) {
        let listeners = this.items,
            event;

        if (listeners?.[config.id]) {
            event = listeners[config.id][config.eventName];

            return event || null
        }
    }

    /**
     * Mounts local domEvent listeners for a given component
     * @param {Neo.component.Base} component
     * @protected
     */
    mountDomListeners(component) {
        let listeners   = this.items[component.id],
            localEvents = [];

        if (listeners) {
            Object.entries(listeners).forEach(([eventName, value]) => {
                value.forEach(event => {
                    eventName = event.eventName;

                    if (eventName === 'resize') {
                        this.addResizeObserver(component, event)
                    } else if (eventName && (event.local || !globalDomEvents.includes(eventName))) {
                        localEvents.push({
                            name   : eventName,
                            handler: 'domEventListener',
                            vnodeId: event.vnodeId
                        })
                    }
                })
            });

            if (localEvents.length > 0) {
                Neo.worker.App.promiseMessage('main', {
                    action  : 'addDomListener',
                    appName : component.appName,
                    events  : localEvents,
                    windowId: component.windowId
                }).then(data => {
                    // console.log('added domListener', data);
                }).catch(err => {
                    console.log('App: Got error attempting to add a domListener', err)
                })
            }
        }
    }

    /**
     * @param {Object}  config
     * @param {Boolean} config.bubble
     * @param {String}  config.delegate
     * @param {String}  config.eventName
     * @param {String}  config.id
     * @param {Boolean} config.local
     * @param {Number}  config.opts
     * @param {Number}  config.originalConfig
     * @param {String}  config.ownerId
     * @param {Number}  config.priority=1
     * @param {Object}  config.scope
     * @param {String}  config.vnodeId
     * @returns {Boolean} true if the listener got registered successfully (false in case it was already there)
     */
    register(config) {
        let me                           = this,
            alreadyRegistered            = false,
            {eventName, id, opts, scope} = config,
            listeners                    = me.items,
            fnType                       = typeof opts,
            fn, listener, listenerConfig, listenerId;

        if (fnType === 'function' || fnType === 'string') {
            fn = opts
        } else {
            fn    = opts.fn;
            scope = opts.scope || scope
        }

        if (!listeners[id]) {
            listeners[id] = {}
        }

        if (listeners[id][eventName]) {
            listener = listeners[id][eventName];

            Object.keys(listener).forEach(key => {
                if (
                    listener[key].fn.toString() === fn.toString() && // todo: add a better check
                    listener[key].scope         === scope &&
                    listener[key].delegate      === config.delegate
                ) {
                    alreadyRegistered = true
                }
            })
        } else {
            listeners[id][eventName] = []
        }

        if (alreadyRegistered === true) {
            return false
        }

        // console.log('manager.DomEvent register', eventName, config);

        listenerId = Neo.getId('dom-event');

        config.listenerId = listenerId;

        listenerConfig = {
            bubble        : config.hasOwnProperty('bubble') ? config.bubble : opts.hasOwnProperty('bubble') ? opts.bubble : true,
            delegate      : config.delegate,
            eventName,
            fn,
            id            : listenerId,
            mounted       : !config.local && globalDomEvents.includes(eventName),
            originalConfig: config.originalConfig,
            ownerId       : config.ownerId,
            priority      : config.priority || opts.priority || 1,
            scope,
            vnodeId       : config.vnodeId
        };

        me.map[listenerId] = listenerConfig;

        listeners[id][eventName].push(listenerConfig);

        listeners[id][eventName].sort((a, b) => b.priority - a.priority);

        return true
    }

    /**
     * @param {Object} config
     * @param {Boolean} config.bubble
     * @param {String} config.eventName
     * @param {String} config.id
     * @param {Object} config.opts
     * @param {Object} config.scope
     * @param {String} config.vnodeId
     * @param {Object} scope
     * @returns {Boolean} true in case the listener did exist and got removed
     */
    unregister(config, scope) {
        // todo
        console.log('unregister', config);
        console.log(this.generateListenerConfig(config, scope));
        return;

        // removed by dead control flow
{}

        // removed by dead control flow
{}
    }

    /**
     * @param {Neo.component.Base} component
     * @param {Object[]} domListeners
     * @param {Object[]} oldDomListeners
     */
    updateDomListeners(component, domListeners, oldDomListeners) {
        let me                  = this,
            registeredListeners = me.items[component.id] || {},
            i, len, listeners;

        if (Array.isArray(domListeners)) {
            if (Array.isArray(oldDomListeners)) {
                oldDomListeners.forEach(oldDomListener => {
                    // find & remove no longer existing listeners
                    if (!domListeners.includes(oldDomListener)) {
                        listeners = registeredListeners[me.getEventName(oldDomListener)] || [];
                        i         = 0;
                        len       = listeners.length;

                        for (; i < len; i++) {
                            if (listeners[i].originalConfig === oldDomListener) {
                                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].remove(listeners, listeners[i]);
                                break
                            }
                        }
                    }
                })
            }

            // add new listeners
            domListeners.forEach(domListener => {
                Object.entries(domListener).forEach(([key, value]) => {
                    if (!eventConfigKeys.includes(key)) {
                        me.register({
                            bubble        : domListener.bubble   || value.bubble,
                            delegate      : domListener.delegate || value.delegate || '#' + (component.vdom.id || component.id),
                            eventName     : key,
                            id            : component.vdom.id || component.id, // honor wrapper nodes
                            opts          : value,
                            originalConfig: domListener,
                            ownerId       : component.id,
                            priority      : domListener.priority || value.priority || 1,
                            scope         : domListener.scope    || component,
                            vnodeId       : domListener.vnodeId  || value.vnodeId  || component.vdom.id
                        })
                    }
                })
            });

            if (component.mounted && domListeners?.length > 0) {
                me.timeout(100).then(() => {
                    me.mountDomListeners(component)
                })
            }
        } else {
            _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].logError('Component.domListeners have to be an array', component)
        }
    }

    /**
     * @param {Object} listener
     * @param {Array} path
     * @returns {Boolean|String} true in case the delegation string matches the event path
     */
    verifyDelegationPath(listener, path) {
        let {delegate} = listener,
            j          = 0,
            pathLen    = path.length,
            targetId;

        if (typeof delegate === 'function') {
            j = delegate(path);

            if (j != null) {
                targetId = path[j].id
            }
        } else {
            let delegationArray = delegate.split(' '),
                len             = delegationArray.length,
                hasMatch, i, item, isId;

            for (i=len-1; i >= 0; i--) {
                hasMatch = false;
                item     = delegationArray[i];
                isId     = item.startsWith('#');

                if (isId || item.startsWith('.')) {
                    item = item.substr(1)
                }

                for (; j < pathLen; j++) {
                    if (
                        (isId && path[j].id === item) ||
                        path[j].cls.includes(item)
                    ) {
                        hasMatch = true;
                        targetId = path[j].id;
                        break
                    }
                }

                if (!hasMatch) {
                    return false
                }
            }
        }

        // ensure the delegation path is a child of the owner components root node
        for (; j < pathLen; j++) {
            if (path[j].id === listener.vnodeId) {
                return targetId
            }
        }

        return false
    }

    /**
     * @param {Neo.component.Base} component
     * @param {Object} data
     * @param {String} delegationTargetId
     * @param {String} eventName
     * @returns {Boolean}
     */
    static verifyMouseEnterLeave(component, data, delegationTargetId, eventName) {
        let targetId = eventName === 'mouseenter' ? data.fromElementId : data.toElementId,
            delegationVdom;

        if (targetId && targetId !== delegationTargetId) {
            delegationVdom = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].find(component.vdom, delegationTargetId);

            // delegationVdom can be undefined when dragging a proxy over the node.
            // see issues/1137 for details.
            if (!delegationVdom || delegationVdom.vdom && _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].find(delegationVdom.vdom, targetId)) {
                return false
            }
        }

        return true
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DomEvent));


/***/ }),

/***/ "./src/manager/Focus.mjs":
/*!*******************************!*\
  !*** ./src/manager/Focus.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @class Neo.manager.Focus
 * @extends Neo.core.Base
 * @singleton
 */
class Focus extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.Focus'
         * @protected
         */
        className: 'Neo.manager.Focus',
        /**
         * An array containing opts objects.
         * opts.componentPath
         * opts.data
         * @member {Object[]} history=[]
         */
        history: [],
        /**
         * The Date object when the last focusin event has occurred
         * @member {Date|null} lastFocusInDate=null
         * @protected
         */
        lastFocusInDate: null,
        /**
         * The Date object when the last focusout event has occurred
         * @member {Date|null} lastFocusInDate=null
         * @protected
         */
        lastFocusOutDate: null,
        /**
         * The amount of time for a focusIn to occur after the last focusOut
         * to get combined into a focusmove event.
         * @member {Number} maxFocusInOutGap=50
         */
        maxFocusInOutGap: 50,
        /**
         * The maximum amount of items stored inside the history array
         * @member {Number} maxHistoryLength=20
         */
        maxHistoryLength: 20,
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * @param {Object} opts
     * @param {Array}  opts.componentPath Component ids upwards
     * @param {Object} opts.data dom event infos
     * @protected
     */
    addToHistory(opts) {
        let history = this.history;

        history.unshift(opts);
        history.length >= this.maxHistoryLength && history.pop()
    }

    /**
     * @param {Object} opts
     * @param {Array}  opts.componentPath Component ids upwards
     * @param {Object} opts.data dom event infos
     * @protected
     */
    focusEnter(opts) {
        this.setComponentFocus(opts, true);
        this.addToHistory(opts)
    }

    /**
     * @param {Object} opts
     * @param {Array}  opts.componentPath Component ids upwards
     * @param {Object} opts.data dom event infos
     * @protected
     */
    focusLeave(opts) {
        this.setComponentFocus(opts, false)
    }

    /**
     * @param {Object} opts
     * @param {Array}  opts.componentPath Component ids upwards
     * @param {Object} opts.data dom event infos
     * @protected
     */
    focusMove(opts) {
        let me               = this,
            {history}        = me,
            newComponentPath = opts.componentPath,
            oldComponentPath = history[0].componentPath,
            focusEnter       = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].difference(newComponentPath, oldComponentPath),
            focusLeave       = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].difference(oldComponentPath, newComponentPath),
            focusMove        = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].intersection(newComponentPath, oldComponentPath),
            component, data;

        me.setComponentFocus({componentPath: focusLeave, data: opts.data}, false);
        me.setComponentFocus({componentPath: focusEnter, data: opts.data}, true);

        focusMove.forEach(id => {
            component = Neo.getComponent(id);

            if (component) {
                data = {
                    component,
                    path   : opts.data.path,
                    oldPath: history[0].data.path
                };

                component.onFocusMove?.(data);
                component.fire('focusMove', data);

                component.onFocusChange?.(data);
                component.fire('focusChange', data)
            }
        });

        me.addToHistory(opts)
    }

    /**
     * @param {Object} opts
     * @param {Array}  opts.componentPath Component ids upwards
     * @param {Object} opts.data dom event infos
     * @protected
     */
    onFocusin(opts) {
        let me = this;

        me.lastFocusInDate = new Date();

        if (me.lastFocusOutDate && me.lastFocusInDate - me.lastFocusOutDate < me.maxFocusInOutGap) {
            me.focusMove(opts)
        } else {
            me.focusEnter(opts)
        }
    }

    /**
     * @param {Object} opts
     * @param {Array}  opts.componentPath Component ids upwards
     * @param {Object} opts.data dom event infos
     * @protected
     */
    onFocusout(opts) {
        let me = this;

        me.lastFocusOutDate = new Date();

        me.timeout(me.maxFocusInOutGap).then(() => {
            if (me.lastFocusOutDate > me.lastFocusInDate) {
                me.focusLeave(opts)
            }
        })
    }

    /**
     * @param {Object} opts
     * @param {Array}  opts.componentPath Component ids upwards
     * @param {Object} opts.data dom event infos
     * @param {Boolean} containsFocus
     * @protected
     */
    setComponentFocus(opts, containsFocus) {
        let data = {
                relatedTarget: opts.data.relatedTarget
            },
            components = opts.componentPath.map(id => Neo.getComponent(id)),
            handler;

        components.forEach(component => {
            if (component) {
                component.containsFocus = containsFocus
            }
        });

        components.forEach(component => {
            if (component) {
                data.component = component;

                data[containsFocus ? 'path' : 'oldPath'] = opts.data.path

                handler = containsFocus ? 'onFocusEnter' : 'onFocusLeave';
                component[handler]?.(data);

                component.fire(containsFocus ? 'focusEnter' : 'focusLeave', data);

                component.onFocusChange?.(data);
                component.fire('focusChange', data)
            }
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Focus));


/***/ }),

/***/ "./src/manager/Instance.mjs":
/*!**********************************!*\
  !*** ./src/manager/Instance.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Base.mjs */ "./src/manager/Base.mjs");



/**
 * @class Neo.manager.Instance
 * @extends Neo.manager.Base
 * @singleton
 */
class Instance extends _Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.Instance'
         * @protected
         */
        className: 'Neo.manager.Instance',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].instanceManagerAvailable = true;

        me.consumeNeoIdMap();

        Neo.find      = me.find     .bind(me); // alias
        Neo.findFirst = me.findFirst.bind(me); // alias
        Neo.get       = me.get      .bind(me); // alias
    }

    /**
     * Register all ids which got applied to the Neo namespace before this instance got created
     * @protected
     */
    consumeNeoIdMap() {
        if (Neo.idMap) {
            this.add(Object.values(Neo.idMap));
            delete Neo.idMap
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Instance));


/***/ }),

/***/ "./src/util/Array.mjs":
/*!****************************!*\
  !*** ./src/util/Array.mjs ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.util.Array
 * @extends Neo.core.Base
 */
class NeoArray extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.Array'
         * @protected
         */
        className: 'Neo.util.Array'
    }

    /**
     * Adds an item or Array of items to an array in case it does not already exist.
     * Only primitive items will get found as duplicates
     * @param {Array} arr
     * @param {*} items
     * @returns {Array}
     */
    static add(arr, items) {
        if (!Array.isArray(items)) {
            items = [items]
        }

        items.forEach(item => {
            if (!arr.includes(item)) {
                arr.push(item);
            }
        });

        return arr
    }

    /**
     * Returns an array of items which are present in array1, but not in array2
     * @param {Array} array1=[]
     * @param {Array} array2=[]
     * @returns {Array}
     */
    static difference(array1=[], array2=[]) {
        return array1.filter(item => !array2.includes(item))
    }

    /**
     * Checks if the item is included by reference inside the array
     * @param {Array} arr
     * @param {*} item
     */
    static hasItem(arr, item) {
        return arr.includes(item)
    }

    /**
     * Inserts an item or Array of items to an array in case it does not already exist.
     * Duplicates will only get matched by reference.
     * @param {Array} arr
     * @param {Number} index
     * @param {*} items
     * @returns {Array}
     */
    static insert(arr, index, items) {
        if (!Array.isArray(items)) {
            items = [items]
        }

        let len = items.length -1,
            i   = len,
            currentIndex, item;

        // Iterate backwards
        for (; i > -1; i--) {
            item = items[i];

            currentIndex = arr.indexOf(item);

            if (index !== currentIndex) {
                if (currentIndex > -1) {
                    this.move(arr, currentIndex, index)
                } else {
                    arr.splice(index, 0, item)
                }
            }
        }

        return arr
    }

    /**
     * Returns an array of items which are present in array1 and array2
     * Only supports primitive items
     * @param {Array} array1=[]
     * @param {Array} array2=[]
     * @returns {Array}
     */
    static intersection(array1=[], array2=[]) {
        return array1.filter(item => array2.includes(item))
    }

    /**
     * Moves an item inside arr from fromIndex to toIndex
     * @param {Array} arr
     * @param {Number} fromIndex
     * @param {Number} toIndex
     */
    static move(arr, fromIndex, toIndex) {
        if (fromIndex === toIndex) {
            return arr
        }

        if (fromIndex >= arr.length) {
            fromIndex = arr.length - 1
        }

        arr.splice(toIndex, 0, arr.splice(fromIndex, 1)[0]);
        return arr
    }

    /**
     * Removes an item or array of items from an array. Only primitive items will get found
     * @param {Array} arr
     * @param {*} items
     */
    static remove(arr, items) {
        let index;

        if (!Array.isArray(items)) {
            items = [items]
        }

        items.forEach(item => {
            index = arr.indexOf(item);

            index > -1 && arr.splice(index, 1)
        });

        return arr
    }

    /**
     * Convenience method to combine add & remove in one call.
     * You can pass single items or an array of items to add or to remove.
     * @param {Array} arr
     * @param {*} removeItems
     * @param {*} addItems
     */
    static removeAdd(arr, removeItems, addItems) {
        this.remove(arr, removeItems);
        return this.add(arr, addItems)
    }

    /**
     * Removes an item from an array in case it does exist, otherwise adds it
     * @param {Array} arr
     * @param {*} item
     * @param {Boolean} [add]
     */
    static toggle(arr, item, add = !this.hasItem(arr, item)) {
        return this[add ? 'add' : 'remove'](arr, item);
    }

    /**
     * Returns an array of items which are present in the passed arrays.
     * Multiple arrays may be passed.
     * Only supports primitive items
     * @returns {Array}
     */
    static union() {
        return [...new Set(Array.prototype.concat(...arguments))]
    }

    /**
     * Adds an item or Array of items to an array in case it does not already exist.
     * Only primitive items will get found as duplicates
     * @param {Array} arr
     * @param {*} items
     */
    static unshift(arr, items) {
        if (!Array.isArray(items)) {
            items = [items]
        }

        items.forEach(item => {
            if (!arr.includes(item)) {
                arr.unshift(item)
            }
        });

        return arr
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(NeoArray));


/***/ }),

/***/ "./src/util/ClassSystem.mjs":
/*!**********************************!*\
  !*** ./src/util/ClassSystem.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.util.ClassSystem
 * @extends Neo.core.Base
 */
class ClassSystem extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.ClassSystem'
         * @protected
         */
        className: 'Neo.util.ClassSystem'
    }

    /**
     * can get used inside beforeSet methods in case you want to create instances like stores
     * @param {Object|Neo.core.Base|null} config
     * @param {Neo.core.Base|String} [DefaultClass=null]
     * @param {Object} [defaultValues={}]
     * @returns {Neo.core.Base} instance
     */
    static beforeSetInstance(config, DefaultClass=null, defaultValues={}) {
        let configType = Neo.typeOf(config);

        if (Neo.isString(DefaultClass)) {
            DefaultClass = Neo.ns(DefaultClass)
        }

        if (!config && DefaultClass) {
            config = Neo.create(DefaultClass, defaultValues)
        } else if (configType === 'NeoClass') {
            config = Neo.create(config, defaultValues)
        } else if (configType === 'Object') {
            if (config.ntype) {
                config = Neo.ntype({
                    ...defaultValues,
                    ...config
                })
            } else {
                let newConfig = {};

                if (DefaultClass) {
                    newConfig.module = DefaultClass
                }

                Object.assign(newConfig, {
                    ...defaultValues,
                    ...config
                });

                config = Neo.create(newConfig)
            }
        } else if (configType === 'NeoInstance') {
            if (defaultValues?.listeners) {
                config.on(defaultValues.listeners)
            }
        }

        return config
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(ClassSystem));


/***/ }),

/***/ "./src/util/Function.mjs":
/*!*******************************!*\
  !*** ./src/util/Function.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bindAppend: () => (/* binding */ bindAppend),
/* harmony export */   buffer: () => (/* binding */ buffer),
/* harmony export */   createInterceptor: () => (/* binding */ createInterceptor),
/* harmony export */   createSequence: () => (/* binding */ createSequence),
/* harmony export */   debounce: () => (/* binding */ debounce),
/* harmony export */   intercept: () => (/* binding */ intercept),
/* harmony export */   resolveCallback: () => (/* binding */ resolveCallback),
/* harmony export */   throttle: () => (/* binding */ throttle),
/* harmony export */   unSequence: () => (/* binding */ unSequence)
/* harmony export */ });
const originalMethodSymbol = Symbol('originalMethod');
const sequencedFnsSymbol   = Symbol('sequencedFns');

/**
 * Append args instead of prepending them
 * @param {Function} fn
 * @param {Object} scope
 * @returns {Function}
 */
function bindAppend(fn, scope) {
    const args = [].slice.call(arguments).slice(2);

    return function() {
        return fn.apply(scope, [].slice.call(arguments).concat(args))
    }
}

/**
 * @param {Function} callback
 * @param {Neo.core.Base} scope
 * @param {Number} delay=300
 * @returns {Function}
 */
function buffer(callback, scope, delay=300) {
    let timeoutId;

    const wrapper = function(...args) {
        // callback invocation comes "delay" ms after the last call to wrapper
        // so cancel any pending invocation.
        clearTimeout(timeoutId);

        wrapper.isPending = true;

        timeoutId = setTimeout(() => {
            timeoutId = 0;
            wrapper.isPending = false;
            callback.apply(scope, args)
        }, delay)
    };

    wrapper.cancel = () => {
        wrapper.isPending = false;
        clearTimeout(timeoutId)
    };

    return wrapper
}

/**
 * Intended for functions with 1 param where the interceptor can change the value
 * @param {Object} target
 * @param {String} targetMethodName
 * @param {Function} interceptFunction
 * @param {Object} scope=target
 * @returns {Function}
 */
function createInterceptor(target, targetMethodName, interceptFunction, scope) {
    let targetMethod = target[targetMethodName];

    return (target[targetMethodName] = function(value) {
        return targetMethod.call(target, interceptFunction.call(scope || target, value))
    })
}

/**
 * @param {Neo.core.Base} target
 * @param {String} methodName
 * @param {Function} fn
 * @param {Object} scope
 * @returns {Function}
 */
function createSequence(target, methodName, fn, scope) {
    let currentMethod = target[methodName],
        wrapper;

    if (currentMethod && currentMethod[sequencedFnsSymbol]) {
        // Already a sequenced method, add to its list
        wrapper = currentMethod;
        wrapper[sequencedFnsSymbol].push({fn, scope})
    } else {
        // First time sequencing this method
        let originalMethod = currentMethod || Neo.emptyFn;

        wrapper = function() {
            originalMethod.apply(this, arguments); // Call the original method

            // Call all sequenced functions
            wrapper[sequencedFnsSymbol].forEach(seqFn => {
                seqFn.fn.apply(seqFn.scope || this, arguments);
            });
        };
        wrapper[sequencedFnsSymbol] = [{fn, scope}];
        wrapper[originalMethodSymbol] = originalMethod; // Store original method
    }

    return (target[methodName] = wrapper);
}

/**
 * @param {Function} callback
 * @param {Neo.core.Base} scope
 * @param {Number} delay=300
 * @returns {Function}
 */
function debounce(callback, scope, delay=300) {
    let debounceTimer;

    return function(...args) {
        // leading edge => trigger the first call right away
        if (!Neo.isNumber(debounceTimer)) {
            // we need to check if the scope (instance) did not get destroyed yet
            scope?.id && callback.apply(scope, args);

            // we still want to start a timer to delay the 2nd+ update
            debounceTimer = setTimeout(() => {debounceTimer = null},  delay)
        } else {
            clearTimeout(debounceTimer);

            debounceTimer = setTimeout(() => {
                // we need to check if the scope (instance) did not get destroyed yet
                scope?.id && callback.apply(scope, args);
                debounceTimer = setTimeout(() => {debounceTimer = null},  delay)
            },  delay)
        }
    }
}

/**
 * The interceptor can prevent the targetMethod from getting executed in case it returns false.
 * @param {Object} target
 * @param {String} targetMethodName
 * @param {Function} interceptFunction
 * @param {Object} scope=target
 * @param {*} preventedReturnValue=null The value to return in case the interceptFunction returns false
 * @returns {Function}
 */
function intercept(target, targetMethodName, interceptFunction, scope, preventedReturnValue=null) {
    let targetMethod = target[targetMethodName];

    return (target[targetMethodName] = function() {
        return (interceptFunction.apply(scope || target, arguments) === false)
            ? preventedReturnValue
            : targetMethod.apply(target, arguments)
    })
}

/**
 * Locate a callable function by name in the passed scope.
 *
 * If the name starts with 'up.', the parent Component chain is searched.
 *
 * This is used by manager.DomEvents & core.Observable.fire and by 'handler' function calls to resolve
 * string function names in the Component's own hierarchy.
 * @param {Function|String} fn A function, or the name of a function to find in the passed scope object/
 * @param {Object} scope=this The scope to find the function in if it is specified as a string.
 * @returns {Object}
 */
function resolveCallback(fn, scope=this) {
    if (Neo.isString(fn)) {
        if (!scope[fn] && fn.startsWith('up.')) {
            fn = fn.slice(3);
            while (!scope[fn] && (scope = scope.parent));
        } else {
            scope = scope.getController?.()?.getHandlerScope(fn, null) || scope
        }

        fn = scope[fn]
    }

    return {fn, scope}
}

/**
 * @param {Function} callback
 * @param {Neo.core.Base} scope
 * @param {Number} delay=300
 * @returns {Function}
 */
function throttle(callback, scope, delay=300) {
    let lastRanDate, timeoutId;

    return function(...args) {
        if (!lastRanDate) {
            // we need to check if the scope (instance) did not get destroyed yet
            scope?.id && callback.apply(scope, args);

            lastRanDate = Date.now()
        } else {
            clearTimeout(timeoutId)

            timeoutId = setTimeout(function() {
                if ((Date.now() - lastRanDate) >= delay) {
                    // we need to check if the scope (instance) did not get destroyed yet
                    scope?.id && callback.apply(scope, args);

                    lastRanDate = Date.now()
                }
            }, delay - (Date.now() - lastRanDate))
        }
    }
}

/**
 * @param {Neo.core.Base} target
 * @param {String} methodName
 * @param {Function} fn
 * @param {Object} scope
 */
function unSequence(target, methodName, fn, scope) {
    let currentMethod = target[methodName];

    if (!currentMethod || !currentMethod[sequencedFnsSymbol]) {
        return // Not a sequenced method
    }

    const sequencedFunctions = currentMethod[sequencedFnsSymbol];

    // Filter out the function to unsequence
    currentMethod[sequencedFnsSymbol] = sequencedFunctions.filter(seqFn =>
        !(seqFn.fn === fn && seqFn.scope === scope)
    );

    if (currentMethod[sequencedFnsSymbol].length === 0) {
        // If no functions left, restore the original method
        target[methodName] = currentMethod[originalMethodSymbol]
    }
}


/***/ }),

/***/ "./src/util/HashHistory.mjs":
/*!**********************************!*\
  !*** ./src/util/HashHistory.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");



/**
 * @class Neo.util.HashHistory
 * @extends Neo.core.Base
 * @mixes Neo.core.Observable
 * @singleton
 */
class HashHistory extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.util.HashHistory'
         * @protected
         */
        className: 'Neo.util.HashHistory',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true,
        /**
         * @member {Number} maxItems=50
         * @protected
         */
        maxItems: 50,
        /**
         * Storing one stack per windowId
         * @member {Object} stacks={}
         * @protected
         */
        stacks: {}
    }

    /**
     * Convenience shortcut
     * @param {Number} [windowId]
     * @returns {Object}
     */
    first(windowId) {
        return this.getAt(0, windowId)
    }

    /**
     * @param {Number} index
     * @param {Number} [windowId]
     * @returns {Number}
     */
    getAt(index, windowId) {
        return this.getStack(windowId)[index]
    }

    /**
     * @param {Number} [windowId]
     * @returns {Number}
     */
    getCount(windowId) {
        return this.getStack(windowId).length
    }

    /**
     * @param {Number} [windowId]
     * @returns {Number}
     */
    getStack(windowId) {
        let me       = this,
            {stacks} = me,
            stackId  = windowId || Object.keys(stacks)[0],
            stack    = stacks[stackId];

        if (!stack) {
            stacks[stackId] = stack = []
        }

        return stack
    }

    /**
     * @param {Object} data
     * @param {String} data.appName
     * @param {Object} data.hash
     * @param {String} data.hashString
     * @param {Number} data.windowId
     */
    push(data) {
        let me         = this,
            {windowId} = data,
            stack      = me.getStack(windowId);

        if (stack[0]?.hashString !== data.hashString) {
            delete data[windowId];
            stack.unshift(data);

            if (stack.length > me.maxItems) {
                stack.pop()
            }

            me.fire('change', data, stack[1] || null)
        }
    }

    /**
     * Convenience shortcut
     * @param {Number} [windowId]
     * @returns {Object}
     */
    second(windowId) {
        return this.getAt(0, windowId)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(HashHistory));


/***/ }),

/***/ "./src/util/Logger.mjs":
/*!*****************************!*\
  !*** ./src/util/Logger.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.util.Logger
 * @extends Neo.core.Base
 * @singleton
 */
class Logger extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.Logger'
         * @protected
         */
        className: 'Neo.util.Logger',
        /**
         * Set the minimum level, which you want to output.
         * Change this at any time using a value of logLevels: ['info', 'log', 'warn', 'error']
         *
         *     Neo.util.Logger.level = 'error'
         *
         * @member {String} level='info'
         * @protected
         */
        level_: 'info',
        /**
         * @member {Boolean} enableLogs=true
         * @protected
         */
        singleton: true
    }

    /**
     * @member {Object} logChar
     */
    logChars  = {
        error: 'E',
        info : 'I',
        log  : 'L',
        warn : 'W'
    }
    /**
     * @member {Object} colors
     */
    logColors = {
        error: 'indianred',
        info : '#acacac',
        log  : '#448888',
        warn : '#6d6d00'
    }
    /**
     * LogLevels
     * @member {String[]} logLevels
     */
    logLevels = ['info', 'log', 'warn', 'error']

    /**
     * @param config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        // aliases
        Neo.applyFromNs(Neo, me, {
            error   : 'error',
            info    : 'info',
            log     : 'log',
            logError: 'logError',
            warn    : 'warn'
        }, true);

        me.timeout(50).then(() => {
            if (!Neo.config.enableLogsInProduction && Neo.config.environment === 'dist/production') {
                me.write = Neo.emptyFn
            }
        })
    }

    /**
     * Set level to number based on position in logLevels
     * @param {String} value
     * @param {String|Number} oldValue
     * @returns {Number}
     */
    beforeSetLevel(value, oldValue) {
        return this.logLevels.indexOf(value)
    }

    /**
     * @param {String} value
     */
    error(value) {
        throw new Error(value)
    }

    /**
     * internal helper to catch caller
     * no known native way in modern JS to know what file that triggered the current method
     * therefore we use Error, we can get the caller file from the stack trace string.
     * @protected
     * @returns {String}
     */
    getCaller() {
        let caller_path = undefined,
            err         = new Error(),
            stack_lines = err.stack.split('\n'),
            found_this  = false,
            i, line;

        for (i in stack_lines) {
            line = stack_lines[i];

            if (!found_this && /Logger\.mjs/.test(line)) {
                found_this = true
            } else if (found_this) {
                if (!/Logger\.mjs/.test(line)) {
                    // remove the closing )
                    line        = line.replace(')', '');
                    // get the part after the last /
                    caller_path = line.match(/([^\/]+)$/)[1].match(/([^ ]+)$/)[1];

                    break
                }
            }
        }

        return caller_path
    }

    /**
     * @param args
     */
    info(...args) {
        args = this.resolveArgs(...args);
        this.write(args, 'info')
    }

    /**
     * @param args
     */
    log(...args) {
        args = this.resolveArgs(...args);
        this.write(args, 'log')
    }

    /**
     * @param args
     */
    logError(...args) {
        args = this.resolveArgs(...args);
        this.write(args, 'error')
    }

    /**
     * @param {Object} data
     */
    onContextMenu(data) {
        let {config} = Neo;

        if (config.enableComponentLogger && !(config.env === 'dist/production' && config.enableLogsInProduction)) {
            let isGroupSet = false,
                component;

            data.path.forEach(item => {
                component = Neo.getComponent(item.id, false);

                if (component) {
                    if (!isGroupSet) {
                        isGroupSet = true;
                        console.group(item.id)
                    }

                    console.log(component)
                }
            });

            isGroupSet && console.groupEnd()
        }
    }

    /**
     * Internal helper for args
     * @param {Array} args
     * @returns {Object}
     * @protected
     */
    resolveArgs(...args) {
        let identifier = args[0],
            argsObject = {};

        if (args.length === 1) {
            if (Neo.isString(identifier)) {
                argsObject.msg = args[0]
            } else if (Neo.isObject(identifier)) {
                argsObject = identifier
            }
        } else if (args.length > 2) {
            argsObject.msg  = args[0];
            argsObject.data = args.slice(1)
        }

        return argsObject
    }

    /**
     * @param args
     */
    warn(...args) {
        args = this.resolveArgs(...args);
        this.write(args, 'warn')
    }

    /**
     * Output method
     * @param {Object} args
     * @param {String} level
     * @protected
     */
    write(args, level) {
        let me = this;

        if (me.beforeSetLevel(level) < me.level) {
            return
        }

        console.log('#', args.msg, level);

        let logColor = me.logColors[level],
            logChar  = me.logChars[level],
            bg       = `background-color:${logColor}; color: white; font-weight: 900;`,
            color    = `color:${logColor};`,
            msg      = `[${me.getCaller()}] ${args.msg}`;

        if (args.data) {
            console.groupCollapsed(`%c ${logChar} %c ${msg}`, bg, color)
            console.log(args.data);
            console.groupEnd()
        } else {
            console.log(`%c ${logChar} %c ${msg}`, bg, color)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Logger));


/***/ }),

/***/ "./src/util/VDom.mjs":
/*!***************************!*\
  !*** ./src/util/VDom.mjs ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../manager/Component.mjs */ "./src/manager/Component.mjs");



/**
 * @class Neo.util.VDom
 * @extends Neo.core.Base
 */
class VDom extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.VDom'
         * @protected
         */
        className: 'Neo.util.VDom'
    }

    /**
     * @param {Object} vdom
     * @param {Boolean} removeIds=true
     * @returns {Object} cloned vdom
     */
    static clone(vdom, removeIds=true) {
        let clone = Neo.clone(vdom, true);

        if (removeIds) {
            delete clone.id
        }

        if (clone.cn) {
            clone.cn.forEach((item, index) => {
                clone.cn[index] = VDom.clone(item, removeIds)
            })
        }

        return clone
    }

    /**
     * Search vdom child nodes by id or opts object for a given vdom tree
     * @param {Object} vdom
     * @param {Object|String} opts Either an object containing vdom node attributes or a string based id
     * @param {Boolean} replaceComponentRefs=true
     * @param {Number} [index] Internal flag, do not use it
     * @param {Object} [parentNode] Internal flag, do not use it
     * @returns {Object}
     *     {Number} index
     *     {String} parentId
     *     {Object} vdom
     */
    static find(vdom, opts, replaceComponentRefs=true, index, parentNode) {
        index = index || 0;
        opts  = !Neo.isString(opts) ? opts : {id: opts};

        if (replaceComponentRefs) {
            vdom = VDom.getVdom(vdom)
        }

        let child      = null,
            matchArray = [],
            styleMatch = true,
            i          = 0,
            len        = vdom.cn?.length,
            optsArray  = Object.entries(opts),
            optsLength = optsArray.length,
            subChild;

        optsArray.forEach(([key, value]) => {
            if (vdom.hasOwnProperty(key)) {
                switch (key) {
                    case 'cls':
                        if (typeof value === 'string' && Neo.isArray(vdom[key])) {
                            if (vdom[key].includes(value)) {
                                matchArray.push(true)
                            }
                        } else if (typeof value === 'string' && typeof vdom[key] === 'string') {
                            if (vdom[key] === value) {
                                matchArray.push(true)
                            }
                        } else if (Neo.isArray(value) && Neo.isArray(vdom[key])) {
                            // todo: either search the vdom array for all keys or compare if the arrays are equal.
                            throw new Error('find: cls matching not supported for target & source types of Arrays')
                        }
                        break
                    case 'style':
                        if (typeof value === 'string' && typeof vdom[key] === 'string') {
                            if (vdom[key] === value) {
                                matchArray.push(true)
                            }
                        } else if (Neo.isObject(value) && Neo.isObject(vdom[key])) {
                            Object.entries(value).forEach(([styleKey, styleValue]) => {
                                if (!(vdom[key].hasOwnProperty(styleKey) && vdom[key][styleKey] === styleValue)) {
                                    styleMatch = false
                                }
                            });

                            if (styleMatch) {
                                matchArray.push(true)
                            }
                        } else {
                            throw new Error('find: style matching not supported for mixed target & source types (Object VS String)')
                        }
                        break
                    default:
                        if (vdom[key] === value) {
                            matchArray.push(true)
                        }
                        break
                }
            }
        });

        if (matchArray.length === optsLength) {
            return {index, parentNode, vdom}
        }

        if (vdom.cn) {
            for (; i < len; i++) {
                if (vdom.cn[i]) {
                    subChild = VDom.find(vdom.cn[i], opts, replaceComponentRefs, i, vdom);

                    if (subChild) {
                        child = {
                            index     : subChild.index,
                            parentNode: subChild.parentNode,
                            vdom      : subChild.vdom
                        };
                        break
                    }
                }
            }
        }

        return child
    }

    /**
     * Convenience shortcut for find(vdom, {flag: flag});
     * @param {Object} vdom
     * @param {String} flag The flag reference specified on the target vdom child node
     * @returns {Object} vdom
     */
    static getByFlag(vdom, flag) {
        return VDom.find(vdom, {flag})?.vdom
    }

    /**
     * Get the ids of all child nodes of the given vdom tree
     * @param vdom
     * @param [childIds=[]]
     * @returns {Array} childIds
     */
    static getChildIds(vdom, childIds=[]) {
        vdom = VDom.getVdom(vdom);

        let childNodes = vdom?.cn || [];

        childNodes.forEach(childNode => {
            if (childNode.id) {
                childIds.push(childNode.id)
            }

            childIds = VDom.getChildIds(childNode, childIds)
        });

        return childIds
    }

    /**
     * @param {Object} vdom
     * @param {Number} index
     * @returns {Array}
     */
    static getColumnNodes(vdom, index) {
        vdom = VDom.getVdom(vdom);

        let columnNodes = [];

        vdom.cn?.forEach(row => {
            if (row.cn?.[index]) {
                columnNodes.push(row.cn[index])
            }
        })

        return columnNodes
    }

    /**
     * @param {Object} vdom
     * @param {Number} index
     * @returns {Array}
     */
    static getColumnNodesIds(vdom, index) {
        return VDom.getColumnNodes(vdom, index).map(e => e.id)
    }

    /**
     * @param {Object} vdom
     * @param {String} flag
     * @param {Array} [matchArray]
     * @returns {Array} an array of vdom nodes which match the flag
     */
    static getFlags(vdom, flag, matchArray) {
        vdom = VDom.getVdom(vdom);

        if (!matchArray) {
            matchArray = [];

            if (vdom.flag === flag) {
                matchArray.push(vdom)
            }
        }

        (vdom?.cn || []).forEach(childNode => {
            if (childNode.flag === flag) {
                matchArray.push(childNode)
            }

            matchArray = VDom.getFlags(childNode, flag, matchArray)
        });

        return matchArray
    }

    /**
     * @param {Object} vdom
     * @param {String} id
     * @param {Boolean} topLevel=true Internal flag, do not use it
     * @returns {Array}
     */
    static getParentNodes(vdom, id, topLevel=true) {
        vdom = VDom.getVdom(vdom);

        let parents = null,
            i       = 0,
            len     = vdom.cn?.length || 0;

        if (vdom.id === id) {
            return []
        }

        for (; i < len; i++) {
            parents = VDom.getParentNodes(vdom.cn[i], id, false);

            if (parents) {
                parents.push(vdom.cn[i]);
                break
            }
        }

        if (topLevel && parents) {
            parents.push(vdom)
        }

        return parents
    }

    /**
     * Convenience shortcut using manager.Component to replace vdom references if needed
     * @param {Object} vdom
     * @returns {Object}
     */
    static getVdom(vdom) {
        if (vdom.componentId) {
            const component = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].get(vdom.componentId);

            if (!component) {
                throw new Error(`util.VDom.getVdom: Component not found for id: ${vdom.componentId}`)
            }

            vdom = component.vdom
        }

        return vdom
    }

    /**
     * Insert a given nodeToInsert after a targetNode inside a given vdom tree
     * @param {Object} vdom The vdom tree containing the targetNode
     * @param {Object} nodeToInsert The new vdom to insert
     * @param {Object|String} targetNodeId Either a vdom node or a vdom node id
     * @returns {Boolean}
     */
    static insertAfterNode(vdom, nodeToInsert, targetNodeId) {
        return VDom.insertNode(vdom, nodeToInsert, targetNodeId, false)
    }

    /**
     * Insert a given nodeToInsert before a targetNode inside a given vdom tree
     * @param {Object} vdom The vdom tree containing the targetNode
     * @param {Object} nodeToInsert The new vdom to insert
     * @param {Object|String} targetNodeId Either a vdom node or a vdom node id
     * @returns {Boolean}
     */
    static insertBeforeNode(vdom, nodeToInsert, targetNodeId) {
        return VDom.insertNode(vdom, nodeToInsert, targetNodeId, true)
    }

    /**
     * Insert a given nodeToInsert before a targetNode inside a given vdom tree
     * @param {Object} vdom The vdom tree containing the targetNode
     * @param {Object} nodeToInsert The new vdom to insert
     * @param {Object|String} targetNodeId Either a vdom node or a vdom node id
     * @param {Boolean} insertBefore true inserts the new node at the same index, index+1 otherwise
     * @returns {Boolean}
     */
    static insertNode(vdom, nodeToInsert, targetNodeId, insertBefore) {
        if (Neo.isObject(targetNodeId)) {
            targetNodeId = targetNodeId.id
        }

        let targetNode = VDom.find(vdom, targetNodeId),
            index;

        if (targetNode) {
            index = insertBefore ? targetNode.index : targetNode.index + 1;
            targetNode.parentNode.cn.splice(index, 0, nodeToInsert);
            return true
        }

        return false
    }

    /**
     * Search vdom child nodes by id or opts object for a given vdom tree
     * @param {Object} [vdom]
     * @param {Object|String} opts Either an object containing vdom node attributes or a string based id
     * @returns {Boolean} true in case the node was found & removed
     */
    static removeVdomChild(vdom, opts) {
        let child = VDom.find(vdom, opts);

        if (child) {
            child.parentNode.cn.splice(child.index, 1);
            return true
        }

        return false
    }

    /**
     * Replaces a child node inside a vdom tree by a given id
     * @param {Object} vdom
     * @param {String} id
     * @param {Object} newChildNode
     * @returns {Boolean} true in case the node was found and replaced
     */
    static replaceVdomChild(vdom, id, newChildNode) {
        vdom = VDom.getVdom(vdom);

        let cn  = vdom.cn || [],
            i   = 0,
            len = cn.length,
            childNode;

        if (vdom.id === id) {
            throw new Error('replaceVdomChild: target id matches the root vnode id: ' + id)
        }

        for (; i < len; i++) {
            childNode = cn[i];

            if (childNode.id === id) {
                cn[i] = newChildNode;
                return true
            }

            if (VDom.replaceVdomChild(childNode, id, newChildNode)) {
                return true
            }
        }

        return false;
    }

    /**
     * Neo.vdom.Helper will create ids for each vnode which does not already have one,
     * so we need to sync them into the vdom.
     * @param {Neo.vdom.VNode} vnode
     * @param {Object} vdom
     * @param {Boolean} force=false The force param will enforce overwriting different ids
     */
    static syncVdomIds(vnode, vdom, force=false) {
        if (vnode && vdom) {
            vdom = VDom.getVdom(vdom);

            let childNodes = vdom.cn,
                cn, i, len;

            if (force) {
                if (vnode.id && vdom.id !== vnode.id) {
                    vdom.id = vnode.id
                }
            } else {
                // We only want to add an ID if the vdom node does not already have one.
                // This preserves developer-provided IDs while allowing the framework
                // to assign IDs to nodes that need them for reconciliation.
                // Also think of adding and removing nodes in parallel.
                if (vnode.id && (!vdom.id || vdom.id.startsWith('neo-vnode-'))) {
                    vdom.id = vnode.id
                }
            }

            if (childNodes) {
                cn  = childNodes.map(item => VDom.getVdom(item));
                // The vnode.childNodes array is already filtered by the worker.
                // We must filter the component's vdom.cn array identically to ensure
                // both arrays are structurally aligned for the sync loop.
                // The boolean check `item &&` is critical to remove falsy values
                // from conditional rendering and prevent runtime errors.
                cn  = cn.filter(item => item && item.removeDom !== true);
                i   = 0;
                len = cn?.length || 0;

                for (; i < len; i++) {
                    if (vnode.childNodes) {
                        VDom.syncVdomIds(vnode.childNodes[i], cn[i], force)
                    }
                }
            }
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(VDom));


/***/ }),

/***/ "./src/util/VNode.mjs":
/*!****************************!*\
  !*** ./src/util/VNode.mjs ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../manager/Component.mjs */ "./src/manager/Component.mjs");



/**
 * @class Neo.util.VNode
 * @extends Neo.core.Base
 */
class VNode extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.VNode'
         * @protected
         */
        className: 'Neo.util.VNode'
    }

    /**
     * Search vnode child nodes by id or opts object for a given vdom tree
     * @param {Object} vnode
     * @param {Object|String} opts Either an object containing vdom node attributes or a string based id
     * @param {Number} [index] Internal flag, do not use it
     * @param {Object} [parentNode] Internal flag, do not use it
     * @returns {Object}
     *     {Number} index
     *     {String} parentId
     *     {Object} vnode
     */
    static find(vnode, opts, index, parentNode) {
        vnode = VNode.getVnode(vnode);

        index = index || 0;
        opts  = typeof opts !== 'string' ? opts : {id: opts};

        let attrMatch  = true,
            matchArray = [],
            styleMatch = true,
            i          = 0,
            len        = vnode.childNodes?.length || 0,
            optsArray, optsLength, subChild;

        optsArray  = Object.entries(opts);
        optsLength = optsArray.length;

        optsArray.forEach(([key, value]) => {
            if (vnode.hasOwnProperty(key)) {
                switch (key) {
                    case 'attributes':
                        if (Neo.isObject(value) && Neo.isObject(vnode[key])) {
                            Object.entries(value).forEach(([attrKey, attrValue]) => {
                                if (!(vnode[key].hasOwnProperty(attrKey) && vnode[key][attrKey] === attrValue)) {
                                    attrMatch = false
                                }
                            });

                            if (attrMatch) {
                                matchArray.push(true)
                            }
                        }
                        break
                    case 'className':
                        if (typeof value === 'string' && Neo.isArray(vnode[key])) {
                            if (vnode[key].includes(value)) {
                                matchArray.push(true)
                            }
                        } else if (typeof value === 'string' && typeof vnode[key] === 'string') {
                            if (vnode[key] === value) {
                                matchArray.push(true)
                            }
                        } else if (Neo.isArray(value) && Neo.isArray(vnode[key])) {
                            // todo: either search the vnode array for all keys or compare if the arrays are equal.
                            throw new Error('find: cls matching not supported for target & source types of Arrays')
                        }
                        break
                    case 'style':
                        if (Neo.isObject(value) && Neo.isObject(vnode[key])) {
                            Object.entries(value).forEach(([styleKey, styleValue]) => {
                                if (!(vnode[key].hasOwnProperty(styleKey) && vnode[key][styleKey] === styleValue)) {
                                    styleMatch = false
                                }
                            });

                            if (styleMatch) {
                                matchArray.push(true)
                            }
                        }
                        break
                    default:
                        if (vnode[key] === value) {
                            matchArray.push(true)
                        }
                        break
                }
            }
        });

        if (matchArray.length === optsLength) {
            return {index, parentNode, vnode}
        }

        for (; i < len; i++) {
            subChild = VNode.find(vnode.childNodes[i], opts, i, vnode);

            if (subChild) {
                return subChild
            }
        }

        return null
    }

    /**
     * Finds a child vnode inside a vnode tree by a given id
     * @param {Object} vnode
     * @param {String|null} id
     * @returns {Object|null} child vnode or null
     */
    static getById(vnode, id) {
        vnode = VNode.getVnode(vnode);

        let childNodes = vnode.childNodes || [],
            i          = 0,
            len        = childNodes.length,
            childNode;

        if (vnode.id === id) {
            return vnode
        }

        for (; i < len; i++) {
            childNode = VNode.getVnode(childNodes[i]);

            if (childNode.id === id) {
                return childNode
            }

            childNode = VNode.getById(childNode, id);

            if (childNode) {
                return childNode
            }
        }

        return null
    }

    /**
     * Get the ids of all child nodes of the given vnode, excluding component references
     * @param {Object} vnode
     * @param {String[]} childIds=[]
     * @returns {String[]} childIds
     */
    static getChildIds(vnode, childIds=[]) {
        vnode?.childNodes?.forEach(childNode => {
            if (childNode.id && !childNode.componentId) {
                childIds.push(childNode.id)
            }

            VNode.getChildIds(childNode, childIds)
        });

        return childIds
    }

    /**
     * Convenience shortcut using manager.Component to replace vnode references if needed
     * @param {Object} vnode
     * @returns {Object}
     */
    static getVnode(vnode) {
        if (vnode.componentId) {
            const component = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].get(vnode.componentId);

            if (!component) {
                throw new Error(`util.VNode.getVnode: Component not found for id: ${vnode.componentId}`)
            }

            vnode = component.vnode
        }

        return vnode
    }

    /**
     * Removes a child vnode inside a vnode tree by a given id
     * @param {Object} vnode
     * @param {String} id
     * @returns {Boolean} true in case the node was found and removed
     */
    static removeChildVnode(vnode, id) {
        vnode = VNode.getVnode(vnode);

        let childNodes = vnode.childNodes || [],
            i          = 0,
            len        = childNodes.length,
            childNode;

        if (vnode.id === id) {
            throw new Error('removeChildVnode: target id matches the root vnode id: ' + id)
        }

        for (; i < len; i++) {
            childNode = VNode.getVnode(childNodes[i]);

            if (childNode.id === id) {
                childNodes.splice(i, 1);
                return true
            }

            if (VNode.removeChildVnode(childNode, id)) {
                return true
            }
        }

        return false
    }

    /**
     * Replaces a child vnode inside a vnode tree by a given id
     * @param {Object} vnode
     * @param {String} id
     * @param {Object} newChildVnode
     * @returns {Boolean} true in case the node was found and replaced
     */
    static replaceChildVnode(vnode, id, newChildVnode) {
        vnode = VNode.getVnode(vnode);

        let childNodes = vnode.childNodes || [],
            i          = 0,
            len        = childNodes.length,
            childNode;

        if (vnode.id === id) {
            throw new Error('replaceChildVnode: target id matches the root vnode id: ' + id)
        }

        for (; i < len; i++) {
            childNode = VNode.getVnode(childNodes[i]);

            if (childNode.id === id) {
                childNodes[i] = newChildVnode;
                return true
            }

            if (VNode.replaceChildVnode(childNode, id, newChildVnode)) {
                return true
            }
        }

        return false
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(VNode));


/***/ }),

/***/ "./src/worker/Base.mjs":
/*!*****************************!*\
  !*** ./src/worker/Base.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _core_export_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/_export.mjs */ "./src/core/_export.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _manager_ClassHierarchy_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../manager/ClassHierarchy.mjs */ "./src/manager/ClassHierarchy.mjs");
/* harmony import */ var _Message_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Message.mjs */ "./src/worker/Message.mjs");
/* harmony import */ var _mixin_RemoteMethodAccess_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mixin/RemoteMethodAccess.mjs */ "./src/worker/mixin/RemoteMethodAccess.mjs");







/**
 * The abstract base class for e.g. the App, Data & VDom worker
 * @class Neo.worker.Base
 * @extends Neo.core.Base
 * @mixes Neo.core.Observable
 * @mixes Neo.worker.mixin.RemoteMethodAccess
 * @abstract
 */
class Worker extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.worker.Base'
         * @protected
         */
        className: 'Neo.worker.Base',
        /**
         * @member {String[]|Neo.core.Base[]|null} mixins=[Observable,RemoteMethodAccess]
         */
        mixins: [_core_Observable_mjs__WEBPACK_IMPORTED_MODULE_2__["default"], _mixin_RemoteMethodAccess_mjs__WEBPACK_IMPORTED_MODULE_5__["default"]]
    }

    /**
     * @member {Object|null} channelPorts=null
     * @protected
     */
    channelPorts = null
    /**
     * Only needed for SharedWorkers
     * @member {Boolean} isConnected=false
     * @protected
     */
    isConnected = false
    /**
     * @member {Boolean} isSharedWorker=false
     * @protected
     */
    isSharedWorker = false
    /**
     * Only needed for SharedWorkers
     * @member {Array|null} ports=null
     */
    ports = null
    /**
     * @member {String|null} workerId=null
     * @protected
     */
    workerId = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this,
            gt = globalThis;

        Object.assign(me, {
            channelPorts  : {},
            isSharedWorker: gt.toString() === '[object SharedWorkerGlobalScope]',
            ports         : [],
            promises      : {}
        });

        if (me.isSharedWorker) {
            gt.onconnect = me.onConnected.bind(me)
        } else {
            gt.onmessage = me.onMessage.bind(me)
        }

        Neo.currentWorker   = me;
        Neo.setGlobalConfig = me.setGlobalConfig.bind(me);
        Neo.workerId        = me.workerId
    }

    /**
     * Entry point for dedicated and shared workers
     */
    afterConnect() {}

    /**
     * @param {Object} opts
     * @returns {Object|null}
     */
    getPort(opts) {
        let returnPort = null,
            hasMatch;

        this.ports.forEach(port => {
            hasMatch = true;

            Object.entries(opts).forEach(([key, value]) => {
                if (value !== port[key]) {
                    hasMatch = false
                }
            });

            if (hasMatch) {
                returnPort = port
            }
        });

        return returnPort
    }

    /**
     * Only relevant for SharedWorkers
     * @param {Object} data
     */
    async onConnect(data) {
        // short delay to ensure app VCs are in place
        await this.timeout(10);

        let {appName, windowId} = data;
        this.fire('connect', {appName, windowId})
    }

    /**
     * Only relevant for SharedWorkers
     * @param {Object} e
     */
    onConnected(e) {
        let me = this,
            id = Neo.getId('port');

        me.isConnected = true;

        me.ports.push({
            appName : null,
            id,
            port    : e.ports[0],
            windowId: null
        });

        me.ports[me.ports.length - 1].port.onmessage = me.onMessage.bind(me);

        // core.Base: initRemote() subscribes to this event for the SharedWorkers context
        me.fire('connected');

        me.sendMessage('main', {action: 'workerConstructed', port: id});

        me.afterConnect()
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me = this;

        if (!me.isSharedWorker) {
            me.sendMessage('main', {action: 'workerConstructed'});
            me.afterConnect()
        }
    }

    /**
     * Only relevant for SharedWorkers
     * @param {Object} data
     */
    onDisconnect(data) {
        let {appName, windowId} = data;
        this.fire('disconnect', {appName, windowId})
    }

    /**
     * @param {Object} e
     */
    onMessage(e) {
        let me                = this,
            {data}            = e,
            {action, replyId} = data,
            promise;

        if (!action) {
            throw new Error('Message action is missing: ' + data.id)
        }

        if (action !== 'reply') {
            me['on' + Neo.capitalize(action)](data);
        } else if (promise = action === 'reply' && me.promises[replyId]) {
            if (data.reject) {
                promise.reject(data.data)
            } else {
                promise.resolve(data.data)
            }

            delete me.promises[replyId]
        }
    }

    /**
     * @param {Object} msg
     */
    onPing(msg) {
        this.resolve(msg, {originMsg: msg})
    }

    /**
     * Only relevant for SharedWorkers
     * @param {Object} msg
     * @param {String} msg.appName
     */
    onRegisterApp(msg) {
        let me        = this,
            {appName} = msg,
            port;

        for (port of me.ports) {
            if (!port.appName) {
                port.appName = appName;
                me.onConnect({appName, windowId: port.windowId});
                break
            }
        }
    }

    /**
     * Handles the initial registration of the `Neo.config` for this worker's realm.
     * Triggered when receiving a worker message with `{action: 'registerNeoConfig'}` from the Main Thread's `Neo.worker.Manager`.
     * This method is primarily responsible for setting the initial global `Neo.config` object in this worker's scope
     * upon its creation. It also handles associating `windowId` with `MessagePort`s for Shared Workers.
     *
     * @param {Object} msg The incoming message object.
     * @param {Object} msg.data The initial global Neo.config data object.
     * @param {Number} msg.data.windowId The unique ID of the window/tab (relevant for SharedWorkers).
     */
    onRegisterNeoConfig(msg) {
        Neo.ns('Neo.config', true);

        let me         = this,
            {windowId} = msg.data,
            port;

        for (port of me.ports) {
            if (!port.windowId) {
                port.windowId = windowId;
                break
            }
        }

        Neo.merge(Neo.config, msg.data)
    }

    /**
     * Handles runtime updates to the global `Neo.config` for this worker's realm.
     * This method is triggered when receiving a worker message with `{action: 'setNeoConfig'}`
     * from the Main Thread's `Neo.worker.Manager`. This message signifies a global config change
     * that originated either from this worker's Main Thread or was broadcast from another
     * connected browser window via a Shared Worker.
     *
     * It merges the incoming configuration changes into this worker's local `Neo.config`
     * and fires a local `neoConfigChange` event, allowing other instances within this worker
     * to react to the updated configuration.
     *
     * @param {Object} msg The destructured arguments from the message payload.
     * @param {Object} msg.config The partial or full `Neo.config` object to merge.
     */
    onSetNeoConfig({config}) {
        let me = this;

        Neo.merge(Neo.config, config);

        me.fire('neoConfigChange', config)
    }

    /**
     * @param {String} dest app, data, main or vdom (excluding the current worker)
     * @param {Object} opts configs for Neo.worker.Message
     * @param {Array} [transfer] An optional array of Transferable objects to transfer ownership of.
     * If the ownership of an object is transferred, it becomes unusable (neutered) in the context it was sent from
     * and becomes available only to the worker it was sent to.
     * @returns {Promise<any>}
     */
    promiseMessage(dest, opts, transfer) {
        let me = this;

        return new Promise(function(resolve, reject) {
            let message = me.sendMessage(dest, opts, transfer),
                msgId   = message?.id;

            if (!msgId) {
                // a window got closed and the message port no longer exist (SharedWorkers)
                reject()
            } else {
                me.promises[msgId] = {reject, resolve}
            }
        })
    }

    /**
     * @param {String} dest app, canvas, data, main or vdom (excluding the current worker)
     * @param {Object} opts configs for Neo.worker.Message
     * @param {Array} [transfer] An optional array of Transferable objects to transfer ownership of.
     * If the ownership of an object is transferred, it becomes unusable (neutered) in the context it was sent from
     * and becomes available only to the worker it was sent to.
     * @returns {Neo.worker.Message}
     * @protected
     */
    sendMessage(dest, opts, transfer) {
        opts.destination = dest;

        let me = this,
            message, port, portObject;

        if (me.channelPorts[dest]) {
            port = me.channelPorts[dest]
        } else if (!me.isSharedWorker) {
            port = globalThis
        } else {
            if (opts.port) {
                port = me.getPort({id: opts.port}).port
            } else if (opts.windowId) {
                portObject = me.getPort({windowId: opts.windowId});
                port       = portObject?.port;

                opts.port = portObject?.id
            }  else if (opts.appName) {
                portObject = me.getPort({appName: opts.appName});
                port       = portObject?.port;

                opts.port = portObject?.id
            } else {
                port = me.ports[0].port
            }
        }

        if (port) {
            message = new _Message_mjs__WEBPACK_IMPORTED_MODULE_4__["default"](opts);
            port.postMessage(message, transfer);
        }

        return message
    }

    /**
     * Initiates a global Neo.config change from a worker's context.
     * This method is exposed globally as `Neo.setGlobalConfig` within each worker realm.
     *
     * It orchestrates the propagation of the config change to the Main Thread
     * and, if a Shared Worker is active, across all connected browser windows,
     * ensuring a single, consistent Neo.config state everywhere.
     *
     * You can pass a partial config object to update specific keys.
     * For nested objects, Neo.mjs performs a deep merge.
     *
     * @param {Object} config The partial or full Neo.config object with changes to apply.
     */
    setGlobalConfig(config) {
        const
            me        = this,
            {Manager} = Neo.worker; // Remote access proxy object

        // Apply the config change locally to this worker's Neo.config and
        // trigger its local change events immediately. This ensures immediate
        // feedback and an updated state for the worker that initiated the change.
        me.onSetNeoConfig({config});

        if (me.isSharedWorker) {
            // This block executes when the calling worker instance is a Shared Worker.
            // This happens if `Neo.config.useSharedWorkers` is true, meaning App, VDom,
            // Data, Canvas, and Task workers are all SharedWorker instances.
            // This Shared Worker (the one where setGlobalConfig was called) acts as the
            // central point to inform all connected Main Threads (browser windows).
            me.ports.forEach((port, index) => {
                // Send the config change to each connected Main Thread.
                // The `broadcast` flag is crucial here for the *receiving* Main Thread:
                // - `broadcast: true` (for the first port/Main Thread in the list): This Main Thread
                //   will apply the config locally and is then responsible for propagating it to *all*
                //   its own associated Shared Workers connected to that Main Thread),
                //   **excluding the worker that originated this change**.
                // - `broadcast: false` (for all other ports/Main Threads): These Main Threads
                //   will simply apply the config locally and stop. They are passive recipients
                //   of the broadcast, synchronizing their state without initiating further actions back.
                // The `excludeOrigin` parameter ensures the originating worker doesn't receive a redundant broadcast.
                Manager.setNeoConfig({broadcast: index < 1, config, excludeOrigin: me.workerId, windowId: port.windowId})
            })
        } else {
            // This Dedicated Worker (the one where setGlobalConfig was called) informs
            // its single, connected Main Thread. The Main Thread will then:
            // 1. Apply the config locally.
            // 2. Broadcast this change to *all* other Dedicated Workers connected to
            //    *that same Main Thread*, **excluding the sender worker itself**.
            Manager.setNeoConfig({broadcast: true, config, excludeOrigin: me.workerId})
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Worker));


/***/ }),

/***/ "./src/worker/Message.mjs":
/*!********************************!*\
  !*** ./src/worker/Message.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/IdGenerator.mjs */ "./src/core/IdGenerator.mjs");


/**
 * A wrapper for worker post messages sent between the App, Data, VDom worker & the main thread.
 * You can add optional params as needed.
 * @class Neo.worker.Message
 */
class Message {
    /**
     * @param {Object} config
     */
    constructor(config) {
        /**
         * @member {String} action
         */

        /**
         * @member {String} destination='main'
         */

        /**
         * @member {String} id=IdGenerator.getId(Neo.workerId)
         */

        /**
         * @member {String} origin=Neo.workerId
         */

        config.destination = config.destination || 'main';
        config.id          = config.id          || _core_IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getId(Neo.workerId);
        config.origin      = config.origin      || Neo.workerId;

        Object.assign(this, config)
    }
}

const ns = Neo.ns('Neo.worker', true);
ns['Message'] = Message;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Message);


/***/ }),

/***/ "./src/worker/mixin/RemoteMethodAccess.mjs":
/*!*************************************************!*\
  !*** ./src/worker/mixin/RemoteMethodAccess.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.worker.mixin.RemoteMethodAccess
 * @extends Neo.core.Base
 */
class RemoteMethodAccess extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.worker.mixin.RemoteMethodAccess'
         * @protected
         */
        className: 'Neo.worker.mixin.RemoteMethodAccess'
    }

    /**
     * @param {Object} source
     * @param {Object} target
     */
    assignPort(source, target) {
        if (source) {
            const {appName, port, windowId} = source;
            Object.assign(target, {appName, port, windowId})
        }
    }

    /**
     * @param {Object} remote
     * @param method
     * @returns {function(*=, *=): Promise<any>}
     */
    generateRemote(remote, method) {
        let me       = this,
            {origin} = remote;

        return function(data, buffer) {
            let opts = {
                action         : 'remoteMethod',
                data,
                destination    : origin,
                remoteClassName: remote.className,
                remoteMethod   : method
            };

            me.isSharedWorker && me.assignPort(data, opts);

            return me.promiseMessage(origin, opts, buffer)
        }
    }

    /**
     * @param {Object} remote
     */
    onRegisterRemote(remote) {
        if (remote.destination === Neo.workerId) {
            let me                   = this,
                {className, methods} = remote,
                pkg                  = Neo.ns(className, true);

            methods.forEach(method => {
                if (remote.origin !== 'main' && pkg[method]) {
                    throw new Error('Duplicate remote method definition ' + className + '.' + method)
                }

                pkg[method] ??= me.generateRemote(remote, method)
            })
        }
    }

    /**
     * @param {Object} msg
     */
    onRemoteMethod(msg) {
        let me  = this,
            pkg = Neo.ns(msg.remoteClassName),
            out, method;

        if (!pkg) {
            throw new Error('Invalid remote namespace "' + msg.remoteClassName + '"')
        }

        method = pkg[msg.remoteMethod];

        if (!method) {
            throw new Error('Invalid remote method name "' + msg.remoteMethod + '"')
        }

        // Check for interception
        if (!pkg.isReady && pkg.interceptRemotes?.includes(msg.remoteMethod)) {
            out = pkg.onInterceptRemotes(msg);
        } else if (Array.isArray(msg.data)) {
            out = method.call(pkg, ...msg.data)
        } else {
            out = method.call(pkg, msg.data)
        }

        if (Neo.isPromise(out)) {
            out
                /*
                 * Intended logic:
                 * If the code of a remote method fails, it would not show any errors inside the console,
                 * so we want to manually log the error for debugging.
                 * Rejecting the Promise gives us the chance to recover.
                 *
                 * Example:
                 * Neo.vdom.Helper.update(opts).catch(err => {
                 *     me.isVdomUpdating = false;
                 *     reject?.()
                 * }).then(data => {...})
                 */
                .catch(err => {console.error(err); me.reject(msg, err)})
                .then(data => {me.resolve(msg, data)})
        } else {
            me.resolve(msg, out)
        }
    }

    /**
     * Gets called when promiseMessage gets rejected
     * @param {Object} msg
     * @param {Object} data
     */
    reject(msg, data) {
        let me = this,

        opts = {
            action : 'reply',
            data,
            reject : true,
            replyId: msg.id
        };

        me.isSharedWorker && me.assignPort(msg, opts);
        me.sendMessage(msg.origin, opts)
    }

    /**
     * Gets called when promiseMessage gets resolved
     * @param {Object} msg
     * @param {Object} data
     */
    resolve(msg, data) {
        let me = this,

        opts = {
            action : 'reply',
            data,
            replyId: msg.id
        };

        me.isSharedWorker && me.assignPort(msg, opts);
        me.sendMessage(msg.origin, opts)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(RemoteMethodAccess));


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "chunks/app/" + chunkId + ".js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/^blob:/, "").replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/importScripts chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "already loaded"
/******/ 		var installedChunks = {
/******/ 			"app": 1
/******/ 		};
/******/ 		
/******/ 		// importScripts chunk loading
/******/ 		var installChunk = (data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			while(chunkIds.length)
/******/ 				installedChunks[chunkIds.pop()] = 1;
/******/ 			parentChunkLoadingFunction(data);
/******/ 		};
/******/ 		__webpack_require__.f.i = (chunkId, promises) => {
/******/ 			// "1" is the signal for "already loaded"
/******/ 			if(!installedChunks[chunkId]) {
/******/ 				if(true) { // all chunks have JS
/******/ 					importScripts(__webpack_require__.p + __webpack_require__.u(chunkId));
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || [];
/******/ 		var parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);
/******/ 		chunkLoadingGlobal.push = installChunk;
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
/*!****************************!*\
  !*** ./src/worker/App.mjs ***!
  \****************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Neo.mjs */ "./src/Neo.mjs");
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Base.mjs */ "./src/worker/Base.mjs");
/* harmony import */ var _controller_Application_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../controller/Application.mjs */ "./src/controller/Application.mjs");
/* harmony import */ var _manager_Instance_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../manager/Instance.mjs */ "./src/manager/Instance.mjs");
/* harmony import */ var _manager_DomEvent_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../manager/DomEvent.mjs */ "./src/manager/DomEvent.mjs");
/* harmony import */ var _util_HashHistory_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/HashHistory.mjs */ "./src/util/HashHistory.mjs");







/**
 * The App worker contains most parts of the framework as well as all apps which get created.
 * See the tutorials for further infos.
 * @class Neo.worker.App
 * @extends Neo.worker.Base
 * @singleton
 */
class App extends _Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.worker.App'
         * @protected
         */
        className: 'Neo.worker.App',
        /**
         * @member {Number} countLoadingThemeFiles_=0
         * @reactive
         */
        countLoadingThemeFiles_: 0,
        /**
         * Remote method access for other workers
         * @member {Object} remote
         * @protected
         */
        remote: {
            main: [
                'createNeoInstance',
                'destroyNeoInstance',
                'fireEvent',
                'getConfigs',
                'setConfigs',
                'setGlobalConfig' // points to worker.Base: setGlobalConfig()
            ]
        },
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * We are storing the params of insertThemeFiles() calls here, in case the method does get triggered
     * before the json theme structure got loaded.
     * @member {Array[]} themeFilesCache=[]
     * @protected
     */
    themeFilesCache = []
    /**
     * @member {String} workerId='app'
     * @protected
     */
    workerId = 'app'

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        // convenience shortcuts
        _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].applyDeltas    = me.applyDeltas   .bind(me);
        _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].setCssVariable = me.setCssVariable.bind(me)
    }

    /**
     * Triggered after the countLoadingThemeFiles config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetCountLoadingThemeFiles(value, oldValue) {
        if (value === 0 && oldValue !== undefined) {
            this.fire('themeFilesLoaded')
        }
    }

    /**
     * @param {String} appName
     * @param {Array|Object} deltas
     * @returns {Promise<*>}
     */
    applyDeltas(appName, deltas) {
         return this.promiseMessage('main', {action: 'updateDom', appName, deltas})
    }

    /**
     * Remote method to use inside main threads for creating neo based class instances.
     * Be aware that you can only pass configs which can get converted into pure JSON.
     *
     * Rendering a component into the document.body
     * @example:
     *     Neo.worker.App.createNeoInstance({
     *         ntype     : 'button',
     *         autoMount : true,
     *         autoRender: true
     *         text      : 'Hi Nige!'
     *     }).then(id => console.log(id))
     *
     * Inserting a component into a container
     * @example:
     *     Neo.worker.App.createNeoInstance({
     *         ntype      : 'button',
     *         parentId   : 'neo-container-3',
     *         parentIndex: 0
     *         text       : 'Hi Nige!'
     *     }).then(id => console.log(id))
     *
     * @param {Object} config
     * @param {String} [config.importPath] you can lazy load missing classes via this config. dev mode only.
     * @param {String} [config.parentId] passing a parentId will put your instance into a container
     * @param {Number} [config.parentIndex] if a parentId is passed, but no index, neo will use add()
     * @returns {String} the instance id
     */
    async createNeoInstance(config) {
        if (config.importPath) {
            await import(/* webpackIgnore: true */ config.importPath);
            delete config.importPath
        }

        let appName   = Object.keys(_Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].apps)[0], // fallback in case no appName was provided
            Container = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].container?.Base,
            index, instance, parent;

        config = {appName, ...config};

        if (config.parentId) {
            parent = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getComponent(config.parentId);

            if (Container && parent && parent instanceof Container) {
                index = config.parentIndex;

                delete config.parentId;
                delete config.parentIndex;

                if (_Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isNumber(index)) {
                    instance = parent.insert(index, config)
                } else {
                    instance = parent.add(config)
                }
            }
        } else {
            // default parentId='document.body' => we want it to get shown
            config.autoMount  = true;
            config.autoRender = true;

            instance = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"][config.ntype ? 'ntype' : 'create'](config)
        }

        return instance.id
    }

    /**
     * @param {Object} data
     */
    createThemeMap(data) {
        _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].ns('Neo.cssMap.fileInfo', true);
        _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].cssMap.fileInfo = data;
        this.resolveThemeFilesCache()
    }

    /**
     * Remote method to use inside main threads for destroying neo based class instances.
     *
     * @example:
     *     Neo.worker.App.destroyNeoInstance('neo-button-3').then(success => console.log(success))
     *
     * @param {String} id
     * @returns {Boolean} returns true, in case the instance was found
     */
    destroyNeoInstance(id) {
        let instance = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].get(id),
            parent;

        if (instance) {
            if (instance.parentId) {
                parent = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getComponent(instance.parentId);

                if (parent) {
                    parent.remove(instance);
                    return true
                }
            }

            instance.destroy(true, true);
            return true
        }

        return false
    }

    /**
     * Fires a custom event based on core.Observable on any app realm based Neo instance from main
     * @param {Object} data
     * @param {String} data.id
     * @param {String} data.name
     */
    fireEvent(data) {
        let instance = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].get(data.id),
            name;

        if (instance) {
            name = data.name;

            delete data.id;
            delete data.name;

            instance.fire(name, data);

            return true
        }

        return false
    }

    /**
     * Only needed for the SharedWorkers context
     * @param {String} eventName
     * @param {Object} data
     */
    fireMainViewsEvent(eventName, data) {
        this.ports.forEach(port => {
            _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].apps[port.appName].mainView.fire(eventName, data)
        })
    }

    /**
     * Convenience shortcut to lazy-load main thread addons, in case they are not imported yet
     * @param {String} name
     * @param {Number} windowId
     * @returns {Promise<Neo.main.addon.Base>} The namespace of the addon to use via remote method access
     */
    async getAddon(name, windowId) {
        let addon = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].main?.addon?.[name];

        if (!addon) {
            await _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].Main.importAddon({name, windowId});
            addon = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].main.addon[name]
        }

        return addon
    }

    /**
     * Get configs of any app realm based Neo instance from main
     * @param {Object} data
     * @param {String} data.id
     * @param {String|String[]} data.keys
     * Returns an array of configs if a keys array was passed.
     * Returns the value of a given config directly, in case no array was passed
     * Returns false, in case no instance got found.
     * @returns {*}
     */
    getConfigs(data) {
        let instance    = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].get(data.id),
            {keys}      = data,
            returnArray = [];

        if (instance) {
            if (!Array.isArray(keys)) {
                return instance[keys]
            }

            keys.forEach(key => {
                returnArray.push(instance[key])
            });

            return returnArray
        }

        return false
    }

    /**
     * @param {String} path
     * @returns {Promise}
     */
    importApp(path) {
        if (path.endsWith('.mjs')) {
            path = path.slice(0, -4)
        }

        return __webpack_require__("./. lazy recursive ^\\.\\/.*\\.mjs$ include: (?:\\/%7C\\\\)app.mjs$")(`./${path}.mjs`)
    }

    /**
     * In case you don't want to include prototype based CSS files, use the className param instead
     * @param {Number} windowId
     * @param {Neo.core.Base} [proto]
     * @param {String} [className]
     */
    insertThemeFiles(windowId, proto, className) {
        if (_Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].config.themes.length > 0) {
            className = className || proto.className;

            let me     = this,
                cssMap = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].cssMap,
                parent = proto?.__proto__,
                classPath, classRoot, fileName, lClassRoot, mapClassName, ns, themeFolders;

            if (!cssMap) {
                me.themeFilesCache.push([windowId, proto])
            } else {
                // we need to modify app related class names
                if (!className.startsWith('Neo.')) {
                    className  = className.split('.');
                    classRoot  = className.shift();
                    lClassRoot = classRoot.toLowerCase();

                    className[0] === 'view' && className.shift();

                    mapClassName = `apps.${_Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].apps[classRoot]?.appThemeFolder || lClassRoot}.${className.join('.')}`;
                    className    = `apps.${lClassRoot}.${className.join('.')}`;
                }

                if (parent && parent !== _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].core.Base.prototype) {
                    if (!_Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].ns(`${windowId}.${parent.className}`, false, cssMap)) {
                        me.insertThemeFiles(windowId, parent)
                    }
                }

                themeFolders = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].ns(mapClassName || className, false, cssMap.fileInfo);

                if (themeFolders && !_Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].ns(`${windowId}.${className}`, false, cssMap)) {
                    classPath = className.split('.');
                    fileName  = classPath.pop();
                    classPath = classPath.join('.');
                    ns        = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].ns(`${windowId}.${classPath}`, true, cssMap);

                    ns[fileName] = true;

                    me.countLoadingThemeFiles++;

                    _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].main.addon.Stylesheet.addThemeFiles({
                        className: mapClassName || className,
                        folders  : themeFolders,
                        windowId
                    }).then(() => {
                        me.countLoadingThemeFiles--
                    })
                }
            }
        }
    }

    /**
     * Every dom event will get forwarded as a worker message from main and ends up here first
     * @param {Object} data useful event properties, differs for different event types. See Neo.main.DomEvents.
     */
    onDomEvent(data) {
        _manager_DomEvent_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].fire(data)
    }

    /**
     * Every URL hash-change will create a post message in main and end up here first.
     * @param {Object} data parsed key-value pairs for each hash value
     */
    onHashChange(data) {
        _util_HashHistory_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].push(data.data)
    }

    /**
     * The starting point for apps
     * @param {Object} data
     */
    onLoadApplication(data) {
        let me        = this,
            {config}  = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
            {appPath} = config;

        if (config.environment !== 'development') {
            appPath = appPath.startsWith('/') ? appPath.substring(1) : appPath
        }

        me.importApp(appPath).then(module => {
            module.onStart();

            // short delay to ensure Component Controllers are ready
            config.hash && me.timeout(5).then(() => {
                _util_HashHistory_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].push(config.hash);
                // apps which will get created later must not use outdated hash values
                delete config.hash
            })
        })
    }

    /**
     * Fire event on all apps
     * @param {Object} data
     * @param {Number} data.angle
     * @param {String} data.layout landscape|portrait
     * @param {String} data.type landscape-primary|landscape-secondary|portrait-primary|portrait-secondary
     */
    onOrientationChange(data) {
        Object.values(_Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].apps).forEach(app => {
            app.fire('orientationchange', data.data)
        })
    }

    /**
     * @param {Object} msg
     */
    onRegisterNeoConfig(msg) {
        super.onRegisterNeoConfig(msg);

        let {config} = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
            {data}   = msg,
            url      = 'resources/theme-map.json';

        _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].windowConfigs = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].windowConfigs || {};

        _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].windowConfigs[data.windowId] = data;

        if (config.environment === 'development' || config.environment === 'dist/esm') {
            url = `../../${url}`
        }

        if (config.workerBasePath?.includes('node_modules')) {
            url = `../../${url}`
        }

        if (url[0] !== '.') {
            url = `./${url}`
        }

        fetch(url)
            .then(response => response.json())
            .then(data => {this.createThemeMap(data)});

        config.remotesApiUrl  && __webpack_require__.e(/*! import() */ "src_remotes_Api_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ../remotes/Api.mjs */ "./src/remotes/Api.mjs")).then(module => module.default.load());
        !config.useVdomWorker && __webpack_require__.e(/*! import() */ "vendors-src_vdom_Helper_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ../vdom/Helper.mjs */ "./src/vdom/Helper.mjs"))
    }

    /**
     * @param {Object} msg
     */
    onRegisterPort(msg) {
        let me   = this,
            port = msg.transfer;

        port.onmessage = me.onMessage.bind(me);

        me.channelPorts[msg.origin] = port
    }

    /**
     * @param {Object} data
     */
    onWindowPositionChange(data) {
        this.fireMainViewsEvent('windowPositionChange', data.data)
    }

    /**
     * Only needed for SharedWorkers
     * @param {String} appName
     */
    registerApp(appName) {
        // register the name as fast as possible
        this.onRegisterApp({ appName });
        this.sendMessage('main', {action: 'registerAppName', appName})
    }

    /**
     * Unregister the app from the CSS map
     * Only needed for SharedWorkers
     * @param {String} appName
     */
    removeAppFromThemeMap(appName) {
        delete _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].cssMap[appName.toLowerCase()]
    }

    /**
     * @private
     */
    resolveThemeFilesCache() {
        let me = this;

        me.themeFilesCache.forEach(item => {
            me.insertThemeFiles(...item)
        });

        me.themeFilesCache = []
    }

    /**
     * Set configs of any app realm based Neo instance from main
     * @param {Object} data
     * @param {String} data.id
     */
    setConfigs(data) {
        let instance = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].get(data.id);

        if (instance) {
            delete data.id;
            instance.set(data);

            return true
        }

        return false
    }

    /**
     * @param {Object} data
     * @param {String} data.key
     * @param {String} [data.priority] optionally pass 'important'
     * @param {String} data.theme=Neo.config.themes[0]
     * @param {String} data.value
     * @param {Number} data.windowId
     * @returns {Promise<any>}
     */
    async setCssVariable(data) {
        let Stylesheet = await this.getAddon('Stylesheet', data.windowId),
            theme      = data.theme || _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].config.themes?.[0];

        if (theme.startsWith('neo-')) {
            theme = theme.substring(4)
        }

        return Stylesheet.setCssVariable({theme, ...data})
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].setupClass(App));

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBwd29ya2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxxQzs7Ozs7Ozs7Ozs7Ozs7O0FDcmpEQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDhDQUE4QztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4Q0FBOEM7QUFDckUsQ0FBQzs7QUFFRCxpRUFBZSxhQUFhLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hVb0I7QUFDSzs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFF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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxlQUFlO0FBQzlCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixHQUFHO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRCxpRUFBWTtBQUM3RDtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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IndlYnBhY2s6Ly9uZW8ubWpzLy4vLi8gbGF6eSBeXFwuXFwvLipcXC5tanMkIGluY2x1ZGU6ICgiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9EZWZhdWx0Q29uZmlnLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL05lby5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb2xsZWN0aW9uL0Jhc2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29sbGVjdGlvbi9GaWx0ZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29sbGVjdGlvbi9Tb3J0ZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29udHJvbGxlci9BcHBsaWNhdGlvbi5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb250cm9sbGVyL0Jhc2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29yZS9CYXNlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvcmUvQ29tcGFyZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb3JlL0NvbmZpZy5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb3JlL0NvbmZpZ1N5bWJvbHMubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29yZS9FZmZlY3RNYW5hZ2VyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvcmUvSWRHZW5lcmF0b3IubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29yZS9PYnNlcnZhYmxlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvcmUvVXRpbC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb3JlL19leHBvcnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvbWFuYWdlci9CYXNlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL21hbmFnZXIvQ2xhc3NIaWVyYXJjaHkubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvbWFuYWdlci9Db21wb25lbnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvbWFuYWdlci9Eb21FdmVudC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9tYW5hZ2VyL0ZvY3VzLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL21hbmFnZXIvSW5zdGFuY2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdXRpbC9BcnJheS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy91dGlsL0NsYXNzU3lzdGVtLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3V0aWwvRnVuY3Rpb24ubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdXRpbC9IYXNoSGlzdG9yeS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy91dGlsL0xvZ2dlci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy91dGlsL1ZEb20ubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdXRpbC9WTm9kZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy93b3JrZXIvQmFzZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy93b3JrZXIvTWVzc2FnZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy93b3JrZXIvbWl4aW4vUmVtb3RlTWV0aG9kQWNjZXNzLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL25lby5tanMvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL25lby5tanMvd2VicGFjay9ydW50aW1lL2Vuc3VyZSBjaHVuayIsIndlYnBhY2s6Ly9uZW8ubWpzL3dlYnBhY2svcnVudGltZS9nZXQgamF2YXNjcmlwdCBjaHVuayBmaWxlbmFtZSIsIndlYnBhY2s6Ly9uZW8ubWpzL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vbmVvLm1qcy93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL25lby5tanMvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9uZW8ubWpzL3dlYnBhY2svcnVudGltZS9wdWJsaWNQYXRoIiwid2VicGFjazovL25lby5tanMvd2VicGFjay9ydW50aW1lL2ltcG9ydFNjcmlwdHMgY2h1bmsgbG9hZGluZyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3dvcmtlci9BcHAubWpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBtYXAgPSB7XG5cdFwiLi9hcHBzL2NvbG9ycy9hcHAubWpzXCI6IFtcblx0XHRcIi4vYXBwcy9jb2xvcnMvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2xpc3RfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ29tYm9Cb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19zdGF0ZV9Qcm92aWRlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2dyaWRfQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1hcHBzX2NvbG9yc19hcHBfbWpzXCJcblx0XSxcblx0XCIuL2FwcHMvY29sb3JzL2NoaWxkYXBwcy93aWRnZXQvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2FwcHMvY29sb3JzL2NoaWxkYXBwcy93aWRnZXQvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcImFwcHNfY29sb3JzX2NoaWxkYXBwc193aWRnZXRfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9hcHBzL2NvdmlkL2FwcC5tanNcIjogW1xuXHRcdFwiLi9hcHBzL2NvdmlkL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NvbWJvQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfc3RhdGVfUHJvdmlkZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY190YWJfQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1hcHBzX2NvdmlkX2FwcF9tanMtc3JjX3NlbGVjdGlvbl9Nb2RlbF9tanMtc3JjX3Rvb2xiYXJfQmFzZV9tanNcIlxuXHRdLFxuXHRcIi4vYXBwcy9lbWFpbC9hcHAubWpzXCI6IFtcblx0XHRcIi4vYXBwcy9lbWFpbC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZ3JpZF9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mdW5jdGlvbmFsX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1hcHBzX2VtYWlsX2FwcF9tanMtc3JjX3Rvb2xiYXJfQmFzZV9tanNcIlxuXHRdLFxuXHRcIi4vYXBwcy9maW5hbmNlL2FwcC5tanNcIjogW1xuXHRcdFwiLi9hcHBzL2ZpbmFuY2UvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3N0YXRlX1Byb3ZpZGVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZ3JpZF9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWFwcHNfZmluYW5jZV9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2FwcHMvZm9ybS9hcHAubWpzXCI6IFtcblx0XHRcIi4vYXBwcy9mb3JtL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19zdGF0ZV9Qcm92aWRlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1hcHBzX2Zvcm1fYXBwX21qcy1zcmNfc2VsZWN0aW9uX01vZGVsX21qc1wiXG5cdF0sXG5cdFwiLi9hcHBzL3BvcnRhbC9hcHAubWpzXCI6IFtcblx0XHRcIi4vYXBwcy9wb3J0YWwvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfc3RhdGVfUHJvdmlkZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19sYXlvdXRfQ3ViZV9tanNcIixcblx0XHRcInZlbmRvcnMtYXBwc19wb3J0YWxfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9hcHBzL3BvcnRhbC9jaGlsZGFwcHMvcHJldmlldy9hcHAubWpzXCI6IFtcblx0XHRcIi4vYXBwcy9wb3J0YWwvY2hpbGRhcHBzL3ByZXZpZXcvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcImFwcHNfcG9ydGFsX2NoaWxkYXBwc19wcmV2aWV3X2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vYXBwcy9yZWFsd29ybGQvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2FwcHMvcmVhbHdvcmxkL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWFwcHNfcmVhbHdvcmxkX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vYXBwcy9yZWFsd29ybGQyL2FwcC5tanNcIjogW1xuXHRcdFwiLi9hcHBzL3JlYWx3b3JsZDIvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2xpc3RfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ29tYm9Cb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY190YWJfQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfSGVsaXhfbWpzLXNyY19jb250YWluZXJfUGFuZWxfbWpzLXNyY19mb3JtX2ZpZWxkX1JhbmdlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0dhbGxlcnlfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2NvbXBvbmVudF9oZWxpeF9WaWV3cG9ydF9tanMtc3JjX3NlbGVjdGlvbl9Nb2RlbF9tanMtc3JjX3Rvb2xiYXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfY29tcG9uZW50X2dhbGxlcnlfTWFpbkNvbnRhaW5lcl9tanNcIixcblx0XHRcInZlbmRvcnMtYXBwc19yZWFsd29ybGQyX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vYXBwcy9yb3V0ZS9hcHAubWpzXCI6IFtcblx0XHRcIi4vYXBwcy9yb3V0ZS9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWFwcHNfcm91dGVfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9hcHBzL3NoYXJlZGNvdmlkL2FwcC5tanNcIjogW1xuXHRcdFwiLi9hcHBzL3NoYXJlZGNvdmlkL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NvbWJvQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfc3RhdGVfUHJvdmlkZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY190YWJfQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1hcHBzX3NoYXJlZGNvdmlkX2FwcF9tanMtc3JjX3NlbGVjdGlvbl9Nb2RlbF9tanMtc3JjX3Rvb2xiYXJfQmFzZV9tanNcIlxuXHRdLFxuXHRcIi4vYXBwcy9zaGFyZWRjb3ZpZC9jaGlsZGFwcHMvc2hhcmVkY292aWRjaGFydC9hcHAubWpzXCI6IFtcblx0XHRcIi4vYXBwcy9zaGFyZWRjb3ZpZC9jaGlsZGFwcHMvc2hhcmVkY292aWRjaGFydC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwiYXBwc19zaGFyZWRjb3ZpZF9jaGlsZGFwcHNfc2hhcmVkY292aWRjaGFydF9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2FwcHMvc2hhcmVkY292aWQvY2hpbGRhcHBzL3NoYXJlZGNvdmlkZ2FsbGVyeS9hcHAubWpzXCI6IFtcblx0XHRcIi4vYXBwcy9zaGFyZWRjb3ZpZC9jaGlsZGFwcHMvc2hhcmVkY292aWRnYWxsZXJ5L2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJhcHBzX3NoYXJlZGNvdmlkX2NoaWxkYXBwc19zaGFyZWRjb3ZpZGdhbGxlcnlfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9hcHBzL3NoYXJlZGNvdmlkL2NoaWxkYXBwcy9zaGFyZWRjb3ZpZGhlbGl4L2FwcC5tanNcIjogW1xuXHRcdFwiLi9hcHBzL3NoYXJlZGNvdmlkL2NoaWxkYXBwcy9zaGFyZWRjb3ZpZGhlbGl4L2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJhcHBzX3NoYXJlZGNvdmlkX2NoaWxkYXBwc19zaGFyZWRjb3ZpZGhlbGl4X2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vYXBwcy9zaGFyZWRjb3ZpZC9jaGlsZGFwcHMvc2hhcmVkY292aWRtYXAvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2FwcHMvc2hhcmVkY292aWQvY2hpbGRhcHBzL3NoYXJlZGNvdmlkbWFwL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJhcHBzX3NoYXJlZGNvdmlkX2NoaWxkYXBwc19zaGFyZWRjb3ZpZG1hcF9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2FwcHMvc2hhcmVkZGlhbG9nL2FwcC5tanNcIjogW1xuXHRcdFwiLi9hcHBzL3NoYXJlZGRpYWxvZy9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGlhbG9nX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWFwcHNfc2hhcmVkZGlhbG9nX2FwcF9tanMtc3JjX2NvbnRhaW5lcl9QYW5lbF9tanNcIlxuXHRdLFxuXHRcIi4vYXBwcy9zaGFyZWRkaWFsb2cvY2hpbGRhcHBzL3NoYXJlZGRpYWxvZzIvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2FwcHMvc2hhcmVkZGlhbG9nL2NoaWxkYXBwcy9zaGFyZWRkaWFsb2cyL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtYXBwc19zaGFyZWRkaWFsb2dfY2hpbGRhcHBzX3NoYXJlZGRpYWxvZzJfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9kb2NzL2FwcC5tanNcIjogW1xuXHRcdFwiLi9kb2NzL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY190YWJfQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZHJhZ2dhYmxlX0RyYWdab25lX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfc2VsZWN0aW9uX01vZGVsX21qcy1zcmNfdHJlZV9MaXN0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1kb2NzX2FwcF92aWV3X01haW5Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWRvY3NfYXBwX21qcy1zcmNfY29udGFpbmVyX1ZpZXdwb3J0X21qcy1zcmNfY29udHJvbGxlcl9Db21wb25lbnRfbWpzLXNyY190b29sYmFyX0Jhc2VfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2J1dHRvbi9iYXNlL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9idXR0b24vYmFzZS9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NvbWJvQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19idXR0b25fYmFzZV9hcHBfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2J1dHRvbi9lZmZlY3QvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2J1dHRvbi9lZmZlY3QvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9Db21ib0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfYnV0dG9uX2VmZmVjdF9hcHBfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2J1dHRvbi9zcGxpdC9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvYnV0dG9uL3NwbGl0L2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2xpc3RfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ29tYm9Cb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2J1dHRvbl9zcGxpdF9hcHBfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NhbGVuZGFyL2Jhc2ljL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jYWxlbmRhci9iYXNpYy9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2xpc3RfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ29tYm9Cb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19zdGF0ZV9Qcm92aWRlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9EYXRlU2VsZWN0b3JfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX0NvbnRhaW5lcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2xpc3RfQ29sb3JfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RpbWVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jYWxlbmRhcl92aWV3X01haW5Db250YWluZXJTdGF0ZVByb3ZpZGVyX21qcy1zcmNfY29udGFpbmVyX1ZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19jYWxlbmRhcl9iYXNpY19hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NhbGVuZGFyL3dlZWt2aWV3L2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jYWxlbmRhci93ZWVrdmlldy9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3N0YXRlX1Byb3ZpZGVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY2FsZW5kYXJfdmlld193ZWVrX0NvbXBvbmVudF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NhbGVuZGFyX3ZpZXdfTWFpbkNvbnRhaW5lclN0YXRlUHJvdmlkZXJfbWpzLXNyY19jb250YWluZXJfVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJleGFtcGxlc19jYWxlbmRhcl93ZWVrdmlld19hcHBfbWpzLXNyY191dGlsX0RhdGVfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NoYXJ0cy9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvY2hhcnRzL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJleGFtcGxlc19jaGFydHNfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9jb21wb25lbnQvY2FudmFzL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvY2FudmFzL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwiZXhhbXBsZXNfY29tcG9uZW50X2NhbnZhc19hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9jYXJvdXNlbC9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L2Nhcm91c2VsL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfY29tcG9uZW50X2Nhcm91c2VsX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L2NoaXAvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9jaGlwL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwiZXhhbXBsZXNfY29tcG9uZW50X2NoaXBfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9jb21wb25lbnQvY2lyY2xlL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvY2lyY2xlL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQ2lyY2xlX21qc1wiLFxuXHRcdFwiZXhhbXBsZXNfY29tcG9uZW50X2NpcmNsZV9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9jbG9jay9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L2Nsb2NrL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UaW1lX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19jb21wb25lbnRfY2xvY2tfYXBwX21qcy1zcmNfZm9ybV9maWVsZF9QaWNrZXJfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9jb3JvbmFHYWxsZXJ5L2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvY29yb25hR2FsbGVyeS9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfR2FsbGVyeV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfY29tcG9uZW50X2Nvcm9uYUdhbGxlcnlfVmlld3BvcnRfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzXCIsXG5cdFx0XCJleGFtcGxlc19jb21wb25lbnRfY29yb25hR2FsbGVyeV9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9jb3JvbmFIZWxpeC9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L2Nvcm9uYUhlbGl4L2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfSGVsaXhfbWpzLXNyY19jb250YWluZXJfUGFuZWxfbWpzLXNyY19mb3JtX2ZpZWxkX1JhbmdlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19jb21wb25lbnRfY29yb25hSGVsaXhfYXBwX21qcy1zcmNfc2VsZWN0aW9uX01vZGVsX21qcy1zcmNfdG9vbGJhcl9CYXNlX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9jb21wb25lbnQvZGF0ZVNlbGVjdG9yL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvZGF0ZVNlbGVjdG9yL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0RhdGVTZWxlY3Rvcl9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfY29tcG9uZW50X2RhdGVTZWxlY3Rvcl9hcHBfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9nYWxsZXJ5L2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvZ2FsbGVyeS9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfR2FsbGVyeV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfY29tcG9uZW50X2dhbGxlcnlfTWFpbkNvbnRhaW5lcl9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfY29tcG9uZW50X2dhbGxlcnlfYXBwX21qcy1zcmNfY29udGFpbmVyX1BhbmVsX21qcy1zcmNfY29udGFpbmVyX1ZpZXdwb3J0X21qcy1iZDU2OGFcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L2hlbGl4L2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvaGVsaXgvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9IZWxpeF9tanMtc3JjX2NvbnRhaW5lcl9QYW5lbF9tanMtc3JjX2Zvcm1fZmllbGRfUmFuZ2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2NvbXBvbmVudF9oZWxpeF9WaWV3cG9ydF9tanMtc3JjX3NlbGVjdGlvbl9Nb2RlbF9tanMtc3JjX3Rvb2xiYXJfQmFzZV9tanNcIixcblx0XHRcImV4YW1wbGVzX2NvbXBvbmVudF9oZWxpeF9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9tYWdpY21vdmV0ZXh0L2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvbWFnaWNtb3ZldGV4dC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9NYWdpY01vdmVUZXh0X21qc1wiLFxuXHRcdFwiZXhhbXBsZXNfY29tcG9uZW50X21hZ2ljbW92ZXRleHRfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9jb21wb25lbnQvbXVsdGlXaW5kb3dDb3JvbmFHYWxsZXJ5L2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvbXVsdGlXaW5kb3dDb3JvbmFHYWxsZXJ5L2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9HYWxsZXJ5X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19jb21wb25lbnRfY29yb25hR2FsbGVyeV9WaWV3cG9ydF9tanMtc3JjX3NlbGVjdGlvbl9Nb2RlbF9tanNcIixcblx0XHRcImV4YW1wbGVzX2NvbXBvbmVudF9tdWx0aVdpbmRvd0Nvcm9uYUdhbGxlcnlfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9jb21wb25lbnQvbXVsdGlXaW5kb3dDb3JvbmFHYWxsZXJ5L2NoaWxkYXBwL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvbXVsdGlXaW5kb3dDb3JvbmFHYWxsZXJ5L2NoaWxkYXBwL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJleGFtcGxlc19jb21wb25lbnRfbXVsdGlXaW5kb3dDb3JvbmFHYWxsZXJ5X2NoaWxkYXBwX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L211bHRpV2luZG93SGVsaXgvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9tdWx0aVdpbmRvd0hlbGl4L2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfSGVsaXhfbWpzLXNyY19jb250YWluZXJfUGFuZWxfbWpzLXNyY19mb3JtX2ZpZWxkX1JhbmdlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19jb21wb25lbnRfaGVsaXhfVmlld3BvcnRfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzLXNyY190b29sYmFyX0Jhc2VfbWpzXCIsXG5cdFx0XCJleGFtcGxlc19jb21wb25lbnRfbXVsdGlXaW5kb3dIZWxpeF9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9tdWx0aVdpbmRvd0hlbGl4L2NoaWxkYXBwL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvbXVsdGlXaW5kb3dIZWxpeC9jaGlsZGFwcC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwiZXhhbXBsZXNfY29tcG9uZW50X211bHRpV2luZG93SGVsaXhfY2hpbGRhcHBfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9jb21wb25lbnQvbXdjL2J1dHRvbi9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L213Yy9idXR0b24vYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJleGFtcGxlc19jb21wb25lbnRfbXdjX2J1dHRvbl9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9td2MvYnV0dG9ucy9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L213Yy9idXR0b25zL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3RhYl9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2NvbXBvbmVudF9td2NfYnV0dG9uc19hcHBfbWpzLXNyY190b29sYmFyX0Jhc2VfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9td2MvdGV4dEZpZWxkL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvbXdjL3RleHRGaWVsZC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJleGFtcGxlc19jb21wb25lbnRfbXdjX3RleHRGaWVsZF9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9td2MvdGV4dEZpZWxkcy9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L213Yy90ZXh0RmllbGRzL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3RhYl9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2NvbXBvbmVudF9td2NfdGV4dEZpZWxkc19hcHBfbWpzLXNyY190b29sYmFyX0Jhc2VfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9wcm9jZXNzL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvcHJvY2Vzcy9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9Db21ib0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2xpc3RfQ29sb3JfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2NvbXBvbmVudF9wcm9jZXNzX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L3Byb2Nlc3MvcmVhbFdvcmxkRXhhbXBsZS9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L3Byb2Nlc3MvcmVhbFdvcmxkRXhhbXBsZS9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NvbWJvQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfVG9hc3RfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2NvbXBvbmVudF9wcm9jZXNzX3JlYWxXb3JsZEV4YW1wbGVfYXBwX21qcy1zcmNfc2VsZWN0aW9uX01vZGVsX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9jb21wb25lbnQvcHJvZ3Jlc3MvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9wcm9ncmVzcy9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwiZXhhbXBsZXNfY29tcG9uZW50X3Byb2dyZXNzX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L3NwbGl0dGVyL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvc3BsaXR0ZXIvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kcmFnZ2FibGVfRHJhZ1pvbmVfbWpzXCIsXG5cdFx0XCJleGFtcGxlc19jb21wb25lbnRfc3BsaXR0ZXJfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9jb21wb25lbnQvc3RhdHVzYmFkZ2UvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9zdGF0dXNiYWRnZS9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfY29tcG9uZW50X3N0YXR1c2JhZGdlX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L3RpbWVyL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvdGltZXIvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9Db21ib0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2xpc3RfQ29sb3JfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2NvbXBvbmVudF90aW1lcl9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC90b2FzdC9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L3RvYXN0L2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NvbWJvQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfVG9hc3RfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2NvbXBvbmVudF90b2FzdF9hcHBfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC92aWRlby9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L3ZpZGVvL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9Ub2FzdF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfY29tcG9uZW50X3ZpZGVvX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L3dyYXBwZXIvY2VzaXVtSlMvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC93cmFwcGVyL2Nlc2l1bUpTL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfY29tcG9uZW50X3dyYXBwZXJfY2VzaXVtSlNfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9jb21wb25lbnQvd3JhcHBlci9nb29nbGVNYXBzL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvd3JhcHBlci9nb29nbGVNYXBzL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RpYWxvZ19CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19jb21wb25lbnRfd3JhcHBlcl9nb29nbGVNYXBzX2FwcF9tanMtc3JjX2NvbnRhaW5lcl9QYW5lbF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L3dyYXBwZXIvbW9uYWNvRWRpdG9yL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvd3JhcHBlci9tb25hY29FZGl0b3IvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfd3JhcHBlcl9Nb25hY29FZGl0b3JfbWpzXCIsXG5cdFx0XCJleGFtcGxlc19jb21wb25lbnRfd3JhcHBlcl9tb25hY29FZGl0b3JfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9jb250YWluZXIvYWNjb3JkaW9uL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb250YWluZXIvYWNjb3JkaW9uL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19jb250YWluZXJfYWNjb3JkaW9uX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvY29udGFpbmVyL2Jhc2UvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2NvbnRhaW5lci9iYXNlL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcImV4YW1wbGVzX2NvbnRhaW5lcl9iYXNlX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvY29yZS9jb25maWcvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2NvcmUvY29uZmlnL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfY29yZV9jb25maWdfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9kYXNoYm9hcmQvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2Rhc2hib2FyZC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwiZXhhbXBsZXNfZGFzaGJvYXJkX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvZGF0ZS9zZWxlY3RvckNvbnRhaW5lci9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvZGF0ZS9zZWxlY3RvckNvbnRhaW5lci9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3N0YXRlX1Byb3ZpZGVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0RhdGVTZWxlY3Rvcl9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfZGF0ZV9zZWxlY3RvckNvbnRhaW5lcl9hcHBfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2RpYWxvZy9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvZGlhbG9nL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9Db21ib0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RpYWxvZ19CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19kaWFsb2dfYXBwX21qcy1zcmNfY29udGFpbmVyX1BhbmVsX21qcy1zcmNfc2VsZWN0aW9uX01vZGVsX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9maWVsZFdpdGhQcmVmaXgvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2ZpZWxkV2l0aFByZWZpeC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NvbWJvQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19maWVsZFdpdGhQcmVmaXhfYXBwX21qcy1zcmNfc2VsZWN0aW9uX01vZGVsX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9maWVsZHMvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2ZpZWxkcy9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9Db21ib0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3RhYl9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfRGF0ZVNlbGVjdG9yX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RpbWVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2ZpZWxkc19hcHBfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzLXNyY190b29sYmFyX0Jhc2VfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2Zvcm0vZmllbGQvY2hlY2tib3gvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2Zvcm0vZmllbGQvY2hlY2tib3gvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJleGFtcGxlc19mb3JtX2ZpZWxkX2NoZWNrYm94X2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvZm9ybS9maWVsZC9jaGlwL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9mb3JtL2ZpZWxkL2NoaXAvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9Db21ib0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfZm9ybV9maWVsZF9jaGlwX2FwcF9tanMtc3JjX3NlbGVjdGlvbl9Nb2RlbF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvZm9ybS9maWVsZC9jb2xvci9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvZm9ybS9maWVsZC9jb2xvci9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NvbWJvQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9Db2xvcl9tanMtc3JjX3NlbGVjdGlvbl9Nb2RlbF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfZm9ybV9maWVsZF9jb2xvcl9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2Zvcm0vZmllbGQvY29tYm9ib3gvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2Zvcm0vZmllbGQvY29tYm9ib3gvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9Db21ib0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfZm9ybV9maWVsZF9jb21ib2JveF9hcHBfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2Zvcm0vZmllbGQvZGF0ZS9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvZm9ybS9maWVsZC9kYXRlL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0RhdGVTZWxlY3Rvcl9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfZm9ybV9maWVsZF9kYXRlX2FwcF9tanMtc3JjX3NlbGVjdGlvbl9Nb2RlbF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvZm9ybS9maWVsZC9lbWFpbC9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvZm9ybS9maWVsZC9lbWFpbC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcImV4YW1wbGVzX2Zvcm1fZmllbGRfZW1haWxfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9mb3JtL2ZpZWxkL2ZpbGV1cGxvYWQvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2Zvcm0vZmllbGQvZmlsZXVwbG9hZC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19mb3JtX2ZpZWxkX2ZpbGV1cGxvYWRfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9mb3JtL2ZpZWxkL251bWJlci9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvZm9ybS9maWVsZC9udW1iZXIvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJleGFtcGxlc19mb3JtX2ZpZWxkX251bWJlcl9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2Zvcm0vZmllbGQvcGlja2VyL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9mb3JtL2ZpZWxkL3BpY2tlci9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfZm9ybV9maWVsZF9waWNrZXJfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9mb3JtL2ZpZWxkL3JhZGlvL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9mb3JtL2ZpZWxkL3JhZGlvL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwiZXhhbXBsZXNfZm9ybV9maWVsZF9yYWRpb19hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2Zvcm0vZmllbGQvc3dpdGNoL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9mb3JtL2ZpZWxkL3N3aXRjaC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcImV4YW1wbGVzX2Zvcm1fZmllbGRfc3dpdGNoX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvZm9ybS9maWVsZC90ZXh0L2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9mb3JtL2ZpZWxkL3RleHQvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2Zvcm1fZmllbGRfdGV4dF9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2Zvcm0vZmllbGQvdGV4dGFyZWEvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2Zvcm0vZmllbGQvdGV4dGFyZWEvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2Zvcm1fZmllbGRfdGV4dGFyZWFfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9mb3JtL2ZpZWxkL3RpbWUvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2Zvcm0vZmllbGQvdGltZS9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RpbWVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2Zvcm1fZmllbGRfdGltZV9hcHBfbWpzLXNyY19mb3JtX2ZpZWxkX1BpY2tlcl9tanMtc3JjX3NlbGVjdGlvbl9Nb2RlbF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvZm9ybS9maWVsZC90cmlnZ2VyL2NvcHlUb0NsaXBib2FyZC9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvZm9ybS9maWVsZC90cmlnZ2VyL2NvcHlUb0NsaXBib2FyZC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfZm9ybV9maWVsZF90cmlnZ2VyX2NvcHlUb0NsaXBib2FyZF9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2Zvcm0vZmllbGQvdXJsL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9mb3JtL2ZpZWxkL3VybC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcImV4YW1wbGVzX2Zvcm1fZmllbGRfdXJsX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvZm9ybS9maWVsZHNldC9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvZm9ybS9maWVsZHNldC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19mb3JtX2ZpZWxkc2V0X2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvZnVuY3Rpb25hbC9idXR0b24vYmFzZS9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvZnVuY3Rpb25hbC9idXR0b24vYmFzZS9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NvbWJvQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZnVuY3Rpb25hbF9jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfZnVuY3Rpb25hbF9idXR0b25fYmFzZV9hcHBfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2Z1bmN0aW9uYWwvZGVmaW5lQ29tcG9uZW50L2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9mdW5jdGlvbmFsL2RlZmluZUNvbXBvbmVudC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Z1bmN0aW9uYWxfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJleGFtcGxlc19mdW5jdGlvbmFsX2RlZmluZUNvbXBvbmVudF9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2Z1bmN0aW9uYWwvaG9zdENvbXBvbmVudC9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvZnVuY3Rpb25hbC9ob3N0Q29tcG9uZW50L2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZnVuY3Rpb25hbF9jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfZnVuY3Rpb25hbF9ob3N0Q29tcG9uZW50X2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvZ3JpZC9hbmltYXRlZFJvd1NvcnRpbmcvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2dyaWQvYW5pbWF0ZWRSb3dTb3J0aW5nL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2dyaWRfQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19ncmlkX2FuaW1hdGVkUm93U29ydGluZ19hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2dyaWQvYmlnRGF0YS9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvZ3JpZC9iaWdEYXRhL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9Db21ib0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3RhYl9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19ncmlkX0NvbnRhaW5lcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfUmFkaW9fbWpzLXNyY19zZWxlY3Rpb25fZ3JpZF9DZWxsQ29sdW1uTW9kZWxfbWpzLXNyY19zZWxlY3Rpb25fZ3JpZF9DZS1mM2FkOGZcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfZ3JpZF9iaWdEYXRhX2FwcF9tanMtc3JjX3Rvb2xiYXJfQmFzZV9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvZ3JpZC9jZWxsRWRpdGluZy9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvZ3JpZC9jZWxsRWRpdGluZy9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NvbWJvQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfc3RhdGVfUHJvdmlkZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfRGF0ZVNlbGVjdG9yX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZ3JpZF9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1JhZGlvX21qcy1zcmNfc2VsZWN0aW9uX2dyaWRfQ2VsbENvbHVtbk1vZGVsX21qcy1zcmNfc2VsZWN0aW9uX2dyaWRfQ2UtZjNhZDhmXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2dyaWRfY2VsbEVkaXRpbmdfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9ncmlkL2NvbnRhaW5lci9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvZ3JpZC9jb250YWluZXIvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZ3JpZF9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1JhZGlvX21qcy1zcmNfc2VsZWN0aW9uX2dyaWRfQ2VsbENvbHVtbk1vZGVsX21qcy1zcmNfc2VsZWN0aW9uX2dyaWRfQ2UtZjNhZDhmXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2dyaWRfY29udGFpbmVyX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvZ3JpZC9jb3ZpZC9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvZ3JpZC9jb3ZpZC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZ3JpZF9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2dyaWRfY292aWRfYXBwX21qcy1zcmNfdG9vbGJhcl9CYXNlX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9ncmlkL25lc3RlZFJlY29yZEZpZWxkcy9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvZ3JpZC9uZXN0ZWRSZWNvcmRGaWVsZHMvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3N0YXRlX1Byb3ZpZGVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZ3JpZF9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfVG9hc3RfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2dyaWRfbmVzdGVkUmVjb3JkRmllbGRzX2FwcF9tanMtc3JjX3Rvb2xiYXJfQmFzZV9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvbGF5b3V0L2NhcmQvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2xheW91dC9jYXJkL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwiZXhhbXBsZXNfbGF5b3V0X2NhcmRfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9sYXlvdXQvY3ViZS9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvbGF5b3V0L2N1YmUvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19sYXlvdXRfQ3ViZV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfbGF5b3V0X2N1YmVfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9sYXlvdXQvZm9ybS9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvbGF5b3V0L2Zvcm0vYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX0NvbnRhaW5lcl9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfbGF5b3V0X2Zvcm1fYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9saXN0L2FuaW1hdGUvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2xpc3QvYW5pbWF0ZS9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19saXN0X2FuaW1hdGVfYXBwX21qcy1zcmNfc2VsZWN0aW9uX01vZGVsX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9saXN0L2Jhc2UvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2xpc3QvYmFzZS9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2xpc3RfYmFzZV9hcHBfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2xpc3QvY2hpcC9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvbGlzdC9jaGlwL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2xpc3RfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2xpc3RfQ2hpcF9tanMtc3JjX3NlbGVjdGlvbl9Nb2RlbF9tanNcIixcblx0XHRcImV4YW1wbGVzX2xpc3RfY2hpcF9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2xpc3QvY2lyY2xlL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9saXN0L2NpcmNsZS9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQ2lyY2xlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19saXN0X2NpcmNsZV9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2xpc3QvY29sb3IvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2xpc3QvY29sb3IvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9Db2xvcl9tanMtc3JjX3NlbGVjdGlvbl9Nb2RlbF9tanNcIixcblx0XHRcImV4YW1wbGVzX2xpc3RfY29sb3JfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9tZW51L2xpc3QvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL21lbnUvbGlzdC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2xpc3RfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX21lbnVfTGlzdF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfbWVudV9saXN0X2FwcF9tanMtc3JjX3NlbGVjdGlvbl9Nb2RlbF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvbWVudS9wYW5lbC9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvbWVudS9wYW5lbC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2xpc3RfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX21lbnVfTGlzdF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfbWVudV9wYW5lbF9hcHBfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL3BhbmVsL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9wYW5lbC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX3BhbmVsX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvcG9wb3Zlci9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvcG9wb3Zlci9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcImV4YW1wbGVzX3BvcG92ZXJfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9wcmVsb2FkaW5nQXNzZXRzL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9wcmVsb2FkaW5nQXNzZXRzL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3RhYl9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX3ByZWxvYWRpbmdBc3NldHNfYXBwX21qcy1zcmNfdG9vbGJhcl9CYXNlX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9yZW1vdGVzQXBpL2Jhc2ljL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9yZW1vdGVzQXBpL2Jhc2ljL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfcmVtb3Rlc0FwaV9iYXNpY19hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL3NlcnZlcnNpZGUvZ3JpZENvbnRhaW5lci9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvc2VydmVyc2lkZS9ncmlkQ29udGFpbmVyL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcImV4YW1wbGVzX3NlcnZlcnNpZGVfZ3JpZENvbnRhaW5lcl9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL3NlcnZlcnNpZGUvdG9vbGJhckl0ZW1zL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9zZXJ2ZXJzaWRlL3Rvb2xiYXJJdGVtcy9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX3NlcnZlcnNpZGVfdG9vbGJhckl0ZW1zX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvc2l0ZW1hcC9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvc2l0ZW1hcC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfc2l0ZW1hcF9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL3N0YXRlUHJvdmlkZXIvYWR2YW5jZWQvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL3N0YXRlUHJvdmlkZXIvYWR2YW5jZWQvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfc3RhdGVfUHJvdmlkZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX3N0YXRlUHJvdmlkZXJfYWR2YW5jZWRfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9zdGF0ZVByb3ZpZGVyL2RpYWxvZy9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvc3RhdGVQcm92aWRlci9kaWFsb2cvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfc3RhdGVfUHJvdmlkZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX3N0YXRlUHJvdmlkZXJfZGlhbG9nX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvc3RhdGVQcm92aWRlci9leHRlbmRlZENsYXNzL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9zdGF0ZVByb3ZpZGVyL2V4dGVuZGVkQ2xhc3MvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfc3RhdGVfUHJvdmlkZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX3N0YXRlUHJvdmlkZXJfZXh0ZW5kZWRDbGFzc19hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL3N0YXRlUHJvdmlkZXIvaW5saW5lL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9zdGF0ZVByb3ZpZGVyL2lubGluZS9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19zdGF0ZV9Qcm92aWRlcl9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfc3RhdGVQcm92aWRlcl9pbmxpbmVfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9zdGF0ZVByb3ZpZGVyL2lubGluZU5vU3RhdGVQcm92aWRlci9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvc3RhdGVQcm92aWRlci9pbmxpbmVOb1N0YXRlUHJvdmlkZXIvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19zdGF0ZVByb3ZpZGVyX2lubGluZU5vU3RhdGVQcm92aWRlcl9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL3N0YXRlUHJvdmlkZXIvbXVsdGlXaW5kb3cvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL3N0YXRlUHJvdmlkZXIvbXVsdGlXaW5kb3cvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3N0YXRlX1Byb3ZpZGVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19zdGF0ZVByb3ZpZGVyX211bHRpV2luZG93X2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvc3RhdGVQcm92aWRlci9tdWx0aVdpbmRvdzIvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL3N0YXRlUHJvdmlkZXIvbXVsdGlXaW5kb3cyL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJleGFtcGxlc19zdGF0ZVByb3ZpZGVyX211bHRpV2luZG93Ml9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL3N0YXRlUHJvdmlkZXIvbmVzdGVkRGF0YS9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvc3RhdGVQcm92aWRlci9uZXN0ZWREYXRhL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3N0YXRlX1Byb3ZpZGVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19zdGF0ZVByb3ZpZGVyX25lc3RlZERhdGFfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9zdGF0ZVByb3ZpZGVyL3RhYmxlL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9zdGF0ZVByb3ZpZGVyL3RhYmxlL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19zdGF0ZV9Qcm92aWRlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3RhYmxlX0NvbnRhaW5lcl9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfc3RhdGVQcm92aWRlcl90YWJsZV9hcHBfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzLXNyY190b29sYmFyX0Jhc2VfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL3N0YXRlUHJvdmlkZXIvdHdvV2F5L2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9zdGF0ZVByb3ZpZGVyL3R3b1dheS9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfc3RhdGVfUHJvdmlkZXJfbWpzXCIsXG5cdFx0XCJleGFtcGxlc19zdGF0ZVByb3ZpZGVyX3R3b1dheV9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL3RhYi9jb250YWluZXIvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL3RhYi9jb250YWluZXIvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY190YWJfQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc190YWJfY29udGFpbmVyX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvdGFibGUvY2VsbEVkaXRpbmcvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL3RhYmxlL2NlbGxFZGl0aW5nL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2xpc3RfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ29tYm9Cb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19zdGF0ZV9Qcm92aWRlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3RhYmxlX0NvbnRhaW5lcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9EYXRlU2VsZWN0b3JfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1JhZGlvX21qcy1zcmNfc2VsZWN0aW9uX01vZGVsX21qcy1zcmNfc2VsZWN0aW9uX3RhYmxlX0NlbGxNb2RlbF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfdGFibGVfY2VsbEVkaXRpbmdfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy90YWJsZS9jb250YWluZXIvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL3RhYmxlL2NvbnRhaW5lci9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY190YWJsZV9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1JhZGlvX21qcy1zcmNfc2VsZWN0aW9uX01vZGVsX21qcy1zcmNfc2VsZWN0aW9uX3RhYmxlX0NlbGxNb2RlbF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfdGFibGVfY29udGFpbmVyX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvdGFibGUvY292aWQvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL3RhYmxlL2NvdmlkL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY190YWJsZV9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX3RhYmxlX2NvdmlkX2FwcF9tanMtc3JjX3NlbGVjdGlvbl9Nb2RlbF9tanMtc3JjX3Rvb2xiYXJfQmFzZV9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvdGFibGUvbmVzdGVkUmVjb3JkRmllbGRzL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy90YWJsZS9uZXN0ZWRSZWNvcmRGaWVsZHMvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3N0YXRlX1Byb3ZpZGVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfdGFibGVfQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc190YWJsZV9uZXN0ZWRSZWNvcmRGaWVsZHNfYXBwX21qcy1zcmNfc2VsZWN0aW9uX01vZGVsX21qcy1zcmNfdG9vbGJhcl9CYXNlX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy90YWJsZUZpbHRlcmluZy9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvdGFibGVGaWx0ZXJpbmcvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2xpc3RfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ29tYm9Cb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY190YWJsZV9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfRGF0ZVNlbGVjdG9yX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9SYWRpb19tanMtc3JjX3NlbGVjdGlvbl9Nb2RlbF9tanMtc3JjX3NlbGVjdGlvbl90YWJsZV9DZWxsTW9kZWxfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX3RhYmxlRmlsdGVyaW5nX2FwcF9tanMtc3JjX3Rvb2xiYXJfQmFzZV9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvdGFibGVQZXJmb3JtYW5jZS9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvdGFibGVQZXJmb3JtYW5jZS9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY190YWJsZV9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX3RhYmxlUGVyZm9ybWFuY2VfYXBwX21qcy1zcmNfc2VsZWN0aW9uX01vZGVsX21qcy1zcmNfdG9vbGJhcl9CYXNlX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy90YWJsZVN0b3JlL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy90YWJsZVN0b3JlL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfdGFibGVfQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9SYWRpb19tanMtc3JjX3NlbGVjdGlvbl9Nb2RlbF9tanMtc3JjX3NlbGVjdGlvbl90YWJsZV9DZWxsTW9kZWxfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX3RhYmxlU3RvcmVfYXBwX21qcy1zcmNfdG9vbGJhcl9CYXNlX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy90YWJzL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy90YWJzL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3RhYl9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY190YWJsZV9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX3RhYnNfYXBwX21qcy1zcmNfc2VsZWN0aW9uX01vZGVsX21qcy1zcmNfdG9vbGJhcl9CYXNlX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy90b2RvTGlzdC92ZXJzaW9uMS9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvdG9kb0xpc3QvdmVyc2lvbjEvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJleGFtcGxlc190b2RvTGlzdF92ZXJzaW9uMV9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL3RvZG9MaXN0L3ZlcnNpb24yL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy90b2RvTGlzdC92ZXJzaW9uMi9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc190b2RvTGlzdF92ZXJzaW9uMl9hcHBfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL3Rvb2xiYXIvYnJlYWRjcnVtYi9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvdG9vbGJhci9icmVhZGNydW1iL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX3Rvb2xiYXJfYnJlYWRjcnVtYl9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL3Rvb2xiYXIvcGFnaW5nL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy90b29sYmFyL3BhZ2luZy9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9Db21ib0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3N0YXRlX1Byb3ZpZGVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfdGFibGVfQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc190b29sYmFyX3BhZ2luZ19hcHBfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL3RyZWUvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL3RyZWUvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfc2VsZWN0aW9uX01vZGVsX21qcy1zcmNfdHJlZV9MaXN0X21qc1wiLFxuXHRcdFwiZXhhbXBsZXNfdHJlZV9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL3RyZWVBY2NvcmRpb24vYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL3RyZWVBY2NvcmRpb24vYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfc3RhdGVfUHJvdmlkZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzLXNyY190cmVlX0xpc3RfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX3RyZWVBY2NvcmRpb25fYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy92aWRlb01vdmUvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL3ZpZGVvTW92ZS9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJleGFtcGxlc192aWRlb01vdmVfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy92aWV3cG9ydC9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvdmlld3BvcnQvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfdGFiX0NvbnRhaW5lcl9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfdmlld3BvcnRfYXBwX21qcy1zcmNfdG9vbGJhcl9CYXNlX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy93b3JrZXIvdGFzay9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvd29ya2VyL3Rhc2svYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwiZXhhbXBsZXNfd29ya2VyX3Rhc2tfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi90ZXN0L2NvbXBvbmVudHMvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL3Rlc3QvY29tcG9uZW50cy9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9Db21ib0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9EYXRlU2VsZWN0b3JfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0NoaXBfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzXCIsXG5cdFx0XCJ0ZXN0X2NvbXBvbmVudHNfYXBwX21qc1wiXG5cdF1cbn07XG5mdW5jdGlvbiB3ZWJwYWNrQXN5bmNDb250ZXh0KHJlcSkge1xuXHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKG1hcCwgcmVxKSkge1xuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcblx0XHRcdHZhciBlID0gbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHJlcSArIFwiJ1wiKTtcblx0XHRcdGUuY29kZSA9ICdNT0RVTEVfTk9UX0ZPVU5EJztcblx0XHRcdHRocm93IGU7XG5cdFx0fSk7XG5cdH1cblxuXHR2YXIgaWRzID0gbWFwW3JlcV0sIGlkID0gaWRzWzBdO1xuXHRyZXR1cm4gUHJvbWlzZS5hbGwoaWRzLnNsaWNlKDEpLm1hcChfX3dlYnBhY2tfcmVxdWlyZV9fLmUpKS50aGVuKCgpID0+IHtcblx0XHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhpZCk7XG5cdH0pO1xufVxud2VicGFja0FzeW5jQ29udGV4dC5rZXlzID0gKCkgPT4gKE9iamVjdC5rZXlzKG1hcCkpO1xud2VicGFja0FzeW5jQ29udGV4dC5pZCA9IFwiLi8uIGxhenkgcmVjdXJzaXZlIF5cXFxcLlxcXFwvLipcXFxcLm1qcyQgaW5jbHVkZTogKD86XFxcXC8lN0NcXFxcXFxcXClhcHAubWpzJFwiO1xubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrQXN5bmNDb250ZXh0OyIsImNvbnN0IE5lbyA9IGdsb2JhbFRoaXMuTmVvIHx8IHt9O1xuXG5OZW8uY29uZmlnID0gTmVvLmNvbmZpZyB8fCB7fTtcblxuLyoqXG4gKiBDb25maWcgb2JqZWN0IGZvciB0aGUgbmVvLm1qcyBmcmFtZXdvcmsgd2hpY2ggd2lsbCBnZXQgcGFzc2VkIHRvIGFsbCB3b3JrZXJzXG4gKiBZb3UgY2FuIGNoYW5nZSB0aGUgY29uZmlncywgZS5nLiBpbnNpZGUgdGhlIGluZGV4Lmh0bWwgb2YgeW91ciBhcHBcbiAqIEBtZW1iZXJPZiBtb2R1bGU6TmVvXG4gKiBAbmFtZSBjb25maWdcbiAqIEB0eXBlIE9iamVjdFxuICovXG5jb25zdCBEZWZhdWx0Q29uZmlnID0ge1xuICAgIC8qKlxuICAgICAqIHRydWUgd2lsbCBhcHBseSAnbmVvLWJvZHknIHRvIHRoZSBkb2N1bWVudC5ib2R5IGNsYXNzTGlzdFxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcuYXBwbHlCb2R5Q2xzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIGFwcGx5Qm9keUNsczogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiB0cnVlIHdpbGwgYXBwbHkgJ3Bvc2l0aW9uOiBmaXhlZCcgdG8gdGhlIGh0bWwgdGFnIGl0c2VsZlxuICAgICAqIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL25lb21qcy9uZW8vaXNzdWVzLzY0MjlcbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLmFwcGx5Rml4ZWRQb3NpdGlvblRvSHRtbFRhZ1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICBhcHBseUZpeGVkUG9zaXRpb25Ub0h0bWxUYWc6IHRydWUsXG4gICAgLyoqXG4gICAgICogUGF0aCB0byB5b3VyIGFwcC5tanMgZmlsZS4gWW91IGNhbiBjcmVhdGUgbXVsdGlwbGUgYXBwcyB0aGVyZSBpZiBuZWVkZWQuXG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy5hcHBQYXRoXG4gICAgICogQHR5cGUgU3RyaW5nfG51bGxcbiAgICAgKi9cbiAgICBhcHBQYXRoOiBudWxsLFxuICAgIC8qKlxuICAgICAqIFBhdGggdG8gdGhlIG5lby5tanMgZGlyZWN0b3J5XG4gICAgICogQGRlZmF1bHQgJy4vJ1xuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy5iYXNlUGF0aFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqL1xuICAgIGJhc2VQYXRoOiAnLi8nLFxuICAgIC8qKlxuICAgICAqIFBhc3MgYSB0b2tlbiBpbiBjYXNlIHlvdSBhcmUgdXNpbmcgdGhlIENlc2l1bUpTIG1haW4gdGhyZWFkIGFkZG9uXG4gICAgICogU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbmVvbWpzL25lby9ibG9iL2Rldi9zcmMvbWFpbi9hZGRvbi9DZXNpdW1KUy5tanNcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcuY2VzaXVtSnNUb2tlblxuICAgICAqIEB0eXBlIFN0cmluZ3xudWxsXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhpcyBjb25maWcgdG8gZmFsc2UgdG8gZGlzYWJsZSB0aGUgY29tcG9uZW50IGxvZ2dpbmcgdXNpbmcgQ3RybC1SaWdodC1DbGlja1xuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcuZW5hYmxlQ29tcG9uZW50TG9nZ2VyXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIGVuYWJsZUNvbXBvbmVudExvZ2dlcjogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBTZXQgdGhpcyBjb25maWcgdG8gdHJ1ZSB0byBlbmFibGUgdXRpbC5Mb2dnZXIgKE5lby5sb2coKSkgYmFzZWQgbG9ncyBpbiBwcm9kdWN0aW9uXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcuZW5hYmxlTG9nc0luUHJvZHVjdGlvblxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICBlbmFibGVMb2dzSW5Qcm9kdWN0aW9uOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBlbnZpcm9ubWVudC4gVmFsaWQgdmFsdWVzOiAnZGV2ZWxvcG1lbnQnLCAnZGlzdC9kZXZlbG9wbWVudCcsICdkaXN0L3Byb2R1Y3Rpb24nXG4gICAgICogVGhpcyBjb25maWcgd2lsbCBnZXQgYXV0by1nZW5lcmF0ZWRcbiAgICAgKiBAZGVmYXVsdCAnZGlzdC9wcm9kdWN0aW9uJ1xuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy5lbnZpcm9ubWVudFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqL1xuICAgIGVudmlyb25tZW50OiAnZGlzdC9wcm9kdWN0aW9uJyxcbiAgICAvKipcbiAgICAgKiBJbiBjYXNlIHlvdSBhcmUgdXNpbmcgdGhlIEdvb2dsZU1hcHMgbWFpbiB0aHJlYWQgYWRkb24sIHlvdSBjYW4gcGFzcyB0aGUgQVBJIGtleSBoZXJlLlxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy5nb29nbGVNYXBzQXBpS2V5XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBJbiBjYXNlIHlvdSBhcmUgdXNpbmcgdGhlIEdvb2dsZUFuYWx5dGljcyBtYWluIHRocmVhZCBhZGRvbiBvciB1c2VHb29nbGVBbmFseXRpY3M6IHRydWUsXG4gICAgICogeW91IGNhbiBjaGFuZ2UgdGhlIGd0YWcgaWQgaGVyZS4gUmVxdWlyZWQgZm9yIHRoZSBvbmxpbmUgZXhhbXBsZXMgKGdoIHBhZ2VzKVxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy5ndGFnSWRcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEZsYWcgZm9yIHJ1bm5pbmcgb24gaHR0cHM6Ly9uZW9tanMuZ2l0aHViLmlvL3BhZ2VzL1xuICAgICAqID0+IHRvIHVzZSBsb2NhbCBpbWFnZXMgcGF0aHMgaW5zdGVhZCBvZiByYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcuaXNHaXRIdWJQYWdlc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICBpc0dpdEh1YlBhZ2VzOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIEZsYWcgZm9yIHJ1bm5pbmcgdGhlIE5lbyBtYWluIHRocmVhZCBpbnNpZGUgYW4gaWZyYW1lIChTaWVzdGEgQnJvd3NlciBIYXJuZXNzKVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLmlzSW5zaWRlU2llc3RhXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIGlzSW5zaWRlU2llc3RhOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBkZWxheSBpbiBtcyBmb3IgdGhlIHdvcmtlci5NYW5hZ2VyOmxvYWRBcHBsaWNhdGlvbigpIGNhbGxcbiAgICAgKiBAZGVmYXVsdCAyMFxuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy5sb2FkQXBwbGljYXRpb25EZWxheVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIGxvYWRBcHBsaWNhdGlvbkRlbGF5OiAyMCxcbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IEludGwuRGF0ZVRpbWVGb3JtYXQsIGZvciBkZXRhaWxzIHRha2UgYSBsb29rIGF0OlxuICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGVUaW1lRm9ybWF0XG4gICAgICogQGRlZmF1bHQgJ2RlZmF1bHQnXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLmxvY2FsZVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqL1xuICAgIGxvY2FsZTogJ2RlZmF1bHQnLFxuICAgIC8qKlxuICAgICAqIHRydWUgd2lsbCBsb2cgdGhlIGRlbHRhIHVwZGF0ZXMgaW5zaWRlIHRoZSBtYWluIHRocmVhZChzKSBhcyB3ZWxsIGFzIHRoZSByZXF1ZXN0QW5pbWF0aW9uIGZyYW1lc1xuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLmxvZ0RlbHRhVXBkYXRlc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICBsb2dEZWx0YVVwZGF0ZXM6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIHRydWUgd2lsbCBsb2cgY29uc29sZSB3YXJuaW5ncywgaW4gY2FzZSBhIGNvbXBvbmVudCB0cmllcyB0byB1cGRhdGUoKSB3aGlsZSBhIHBhcmVudCB1cGRhdGUgaXMgcnVubmluZy5cbiAgICAgKiBBIHBhcmVudCB1cGRhdGUgcmVzdWx0cyBpbiBhIHNob3J0IGRlbGF5LCBzbyB5b3UgbWlnaHQgd2FudCB0byByZXNvbHZlIHRoZXNlIGNvbGxpc2lvbnMuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcubG9nVmRvbVVwZGF0ZUNvbGxpc2lvbnNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgbG9nVmRvbVVwZGF0ZUNvbGxpc2lvbnM6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEFkZCBhZGRvbnMgZm9yIHRoZSBtYWluIHRocmVhZFxuICAgICAqIC4vc3JjL21haW4vYWRkb24vIGNvbnRhaW5zIGFsbCBmcmFtZXdvcmsgcmVsYXRlZCBvcHRpb25zLlxuICAgICAqIFlvdSBjYW4gYWxzbyBjcmVhdGUgeW91ciBvd24gYWRkb25zIHdpdGhpbiB5b3VyIHdvcmtzcGFjZSBzY29wZS4gTWFrZSBzdXJlIHRvIHB1dCB0aGVtIGluc2lkZSAnc3JjL21haW4vYWRkb24vJ1xuICAgICAqIGFuZCBwcmVmaXggdGhlbSB3aXRoICdXUy8nIGluc2lkZSB5b3VyIG5lby1jb25maWcuanNvbiBmaWxlLlxuICAgICAqIEV4YW1wbGU6IFsnRHJhZ0Ryb3AnLCAnU3R5bGVzaGVldCcsICdXUy9NeUFkZG9uJ11cbiAgICAgKiBAZGVmYXVsdCBbJ0RyYWdEcm9wJywgJ05hdmlnYXRvcicsICdTdHlsZXNoZWV0J11cbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcubWFpblRocmVhZEFkZG9uc1xuICAgICAqIEB0eXBlIFN0cmluZ1tdXG4gICAgICovXG4gICAgbWFpblRocmVhZEFkZG9uczogWydEcmFnRHJvcCcsICdOYXZpZ2F0b3InLCAnU3R5bGVzaGVldCddLFxuICAgIC8qKlxuICAgICAqIFBhc3MgdGhlIFVSTCBvZiBhIEpTT04tZmlsZSwgd2hpY2ggY29udGFpbnMgdGhlIHNlcnZpY2VzIGFuZCBtZXRob2RzIGZyb20geW91ciBiYWNrZW5kLFxuICAgICAqIHdoaWNoIHlvdSB3YW50IHRvIGV4cG9zZSB0byB0aGUgY2xpZW50LlxuICAgICAqIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL25lb21qcy9uZW8vcHJvamVjdHMvMzJcbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLnJlbW90ZXNBcGlVcmxcbiAgICAgKiBAdHlwZSBTdHJpbmd8bnVsbFxuICAgICAqL1xuICAgIHJlbW90ZXNBcGlVcmw6IG51bGwsXG4gICAgLyoqXG4gICAgICogWW91IGNhbiB2aXN1YWxseSBzaG93IHRoZSBhbW91bnQgb2YgZGVsdGEgdXBkYXRlcyBwZXIgc2Vjb25kIHVzaW5nIHRoaXMgY29uZmlnLlxuICAgICAqIEl0IGV4cGVjdHMgYSBkb20gbm9kZSB3aXRoIHRoZSBpZCBcIm5lby1kZWx0YS11cGRhdGVzXCIgYXMgdGhlIHJlbmRlcmluZyB0YXJnZXQuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcucmVuZGVyQ291bnREZWx0YXNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgcmVuZGVyQ291bnREZWx0YXM6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEFkZCB0aGVtZXMgeW91IHdhbnQgdG8gdXNlIGhlcmUuIFRoZSBmaXJzdCB0aGVtZSB3aWxsIGdldCBhcHBsaWVkLlxuICAgICAqIEBkZWZhdWx0IFsnbmVvLXRoZW1lLWxpZ2h0JywnbmVvLXRoZW1lLWRhcmsnLCduZW8tdGhlbWUtbmVvLWxpZ2h0J11cbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcudGhlbWVzXG4gICAgICogQHR5cGUgU3RyaW5nW11cbiAgICAgKi9cbiAgICB0aGVtZXM6IFsnbmVvLXRoZW1lLWxpZ2h0JywgJ25lby10aGVtZS1kYXJrJywgJ25lby10aGVtZS1uZW8tbGlnaHQnXSxcbiAgICAvKipcbiAgICAgKiBGbGFnIGZvciBzdGFuZGFsb25lIFNpZXN0YSBtb2R1bGUgdGVzdHMgPT4gcHJldmVudCByZWdpc3RlclJlbW90ZSB3b3JrZXIgbWVzc2FnZXNcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy51bml0VGVzdE1vZGVcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdW5pdFRlc3RNb2RlOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBXaGVuIHVuaXRUZXN0TW9kZSBpcyB0cnVlLCB0aGlzIGZsYWcgY2FuIGJlIGVuYWJsZWQgdG8gYWxsb3cgVkRPTS1yZWxhdGVkXG4gICAgICogb3BlcmF0aW9ucyBsaWtlIHJlbmRlcigpIGFuZCB1cGRhdGUoKSB0byBwcm9jZWVkLiBUaGlzIGlzIHVzZWZ1bCBmb3IgaW50ZWdyYXRpb24tc3R5bGVcbiAgICAgKiB0ZXN0cyB0aGF0IG5lZWQgdG8gdmVyaWZ5IGNvbXBvbmVudCBsaWZlY3ljbGUgYW5kIERPTSBvdXRwdXQuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcuYWxsb3dWZG9tVXBkYXRlc0luVGVzdHNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgYWxsb3dWZG9tVXBkYXRlc0luVGVzdHM6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEV4cGVyaW1lbnRhbCBmbGFnIGlmIGFuIG9mZnNjcmVlbiBjYW52YXMgd29ya2VyIHNob3VsZCBnZXQgY3JlYXRlZC5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy51c2VDYW52YXNXb3JrZXJcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdXNlQ2FudmFzV29ya2VyOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBgdHJ1ZWAgd2lsbCBlbmFibGUgdGhlIGFkdmFuY2VkLCBzZWN1cmUsIGFuZCBwZXJmb3JtYW50IGRpcmVjdCBET00gQVBJIHJlbmRlcmluZyBzdHJhdGVneSAocmVjb21tZW5kZWQpLlxuICAgICAqIEluIHRoaXMgbW9kZSwgYE5lby52ZG9tLkhlbHBlcmAgd2lsbCBjcmVhdGUgYW5kIHNlbmQgc3RydWN0dXJlZCBWTm9kZSBvYmplY3QgZ3JhcGhzIHRvIHRoZSBNYWluIFRocmVhZC5cbiAgICAgKiBgTmVvLm1haW4uRGVsdGFVcGRhdGVzYCB3aWxsIHRoZW4gdXNlIGBOZW8ubWFpbi5yZW5kZXIuRG9tQXBpUmVuZGVyZXJgIHRvIGRpcmVjdGx5IG1hbmlwdWxhdGUgdGhlIERPTS5cbiAgICAgKiBDcnVjaWFsbHksIGBOZW8ubWFpbi5yZW5kZXIuRG9tQXBpUmVuZGVyZXJgIGJ1aWxkcyBuZXcgKipET00gc3VidHJlZXMqKiAoZnJvbSB0aGUgcmVjZWl2ZWQgVk5vZGUgb2JqZWN0IGdyYXBocylcbiAgICAgKiBhcyBkZXRhY2hlZCBEb2N1bWVudEZyYWdtZW50cyBvciBlbGVtZW50cywgZW50aXJlbHkgb3V0c2lkZSB0aGUgbGl2ZSBET00gdHJlZS5cbiAgICAgKiBUaGVzZSBmdWxseSBjb25zdHJ1Y3RlZCBmcmFnbWVudHMgYXJlIHRoZW4gaW5zZXJ0ZWQgaW50byB0aGUgbGl2ZSBkb2N1bWVudCBpbiBhICoqc2luZ2xlLCBhdG9taWMgb3BlcmF0aW9uKiouXG4gICAgICogVGhpcyBhcHByb2FjaCBpbmhlcmVudGx5IG1pbmltaXplcyBjb3N0bHkgYnJvd3NlciByZWZsb3dzL3JlcGFpbnRzLCBkcmFzdGljYWxseSByZWR1Y2VzIENyb3NzLVNpdGUgU2NyaXB0aW5nIChYU1MpIHJpc2tzLFxuICAgICAqIGFuZCBvcHRpbWl6ZXMgZm9yIHN1cmdpY2FsLCBhdG9taWMgRE9NIHVwZGF0ZXMgZm9yIHVucGFyYWxsZWxlZCBwZXJmb3JtYW5jZS5cbiAgICAgKlxuICAgICAqIGBmYWxzZWAgd2lsbCBlbmFibGUgdGhlIGxlZ2FjeSBzdHJpbmctYmFzZWQgcmVuZGVyaW5nIHN0cmF0ZWd5LlxuICAgICAqIEluIHRoaXMgbW9kZSwgYE5lby52ZG9tLkhlbHBlcmAgd2lsbCBnZW5lcmF0ZSBjb21wbGV0ZSBIVE1MIHN0cmluZ3MgKGBvdXRlckhUTUxgKSBmb3IgVk5vZGUgc3VidHJlZXMuXG4gICAgICogYE5lby5tYWluLkRlbHRhVXBkYXRlc2Agd2lsbCB0aGVuIHVzZSBgTmVvLm1haW4ucmVuZGVyLlN0cmluZ0Jhc2VkUmVuZGVyZXJgIHRvIGluc2VydCB0aGVzZVxuICAgICAqIHN0cmluZ3MgaW50byB0aGUgRE9NIHVzaW5nIG1ldGhvZHMgbGlrZSBgcGFyZW50Tm9kZS5pbnNlcnRBZGphY2VudEhUTUwoKWAuXG4gICAgICogV2hpbGUgcGVyZm9ybWFudCBmb3IgbGFyZ2UgaW5zZXJ0aW9ucywgdGhpcyBtb2RlIGlzIGdlbmVyYWxseSBsZXNzIHNlY3VyZSBkdWUgdG8gcG90ZW50aWFsIFhTUyB2ZWN0b3JzXG4gICAgICogYW5kIHJlbGllcyBvbiBicm93c2VyIEhUTUwgcGFyc2luZywgd2hpY2ggY2FuIGJlIGxlc3MgZWZmaWNpZW50IGZvciBncmFudWxhciB1cGRhdGVzLlxuICAgICAqXG4gICAgICogVGhpcyBjb25maWd1cmF0aW9uIGFmZmVjdHMgYm90aCB0aGUgaW5pdGlhbCBwYWludGluZyBvZiB5b3VyIGFwcGxpY2F0aW9ucyBhbmQgdGhlIGNyZWF0aW9uXG4gICAgICogb2YgbmV3IGNvbXBvbmVudCB0cmVlcyBhdCBydW50aW1lLlxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcudXNlRG9tQXBpUmVuZGVyZXJcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdXNlRG9tQXBpUmVuZGVyZXI6IHRydWUsXG4gICAgLyoqXG4gICAgICogRmxhZyBpZiB2ZG9tIGlkcyBzaG91bGQgZ2V0IG1hcHBlZCBpbnRvIERPTSBlbGVtZW50IGlkcy5cbiAgICAgKiBmYWxzZSB3aWxsIGNvbnZlcnQgdGhlbSBpbnRvIGEgXCJkYXRhLW5lby1pZFwiIGF0dHJpYnV0ZS5cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLnVzZURvbUlkc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICB1c2VEb21JZHM6IHRydWUsXG4gICAgLyoqXG4gICAgICogVHJ1ZSB3aWxsIGF1dG9tYXRpY2FsbHkgaW5jbHVkZSB0aGUgc3R5bGVzaGVldFxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcudXNlRm9udEF3ZXNvbWVcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdXNlRm9udEF3ZXNvbWU6IHRydWUsXG4gICAgLyoqXG4gICAgICogSW50ZW5kZWQgZm9yIHRoZSBvbmxpbmUgZXhhbXBsZXMgd2hlcmUgd2UgbmVlZCBhbiBlYXN5IHdheSB0byBhZGQgR0EgdG8gZXZlcnkgZ2VuZXJhdGVkIGFwcFxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLnVzZUdvb2dsZUFuYWx5dGljc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICB1c2VHb29nbGVBbmFseXRpY3M6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIFRydWUgd2lsbCBhZGQgdGhlIFNlcnZpY2VXb3JrZXIgbWFpbiB0aHJlYWQgYWRkb24gdG8gc3VwcG9ydCBjYWNoaW5nIG9mIGFzc2V0cyAoUFdBKVxuICAgICAqIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NlcnZpY2VfV29ya2VyX0FQSVxuICAgICAqXG4gICAgICogWW91IGNhbiBhbHNvIHVzZSBhIHN0cmluZyB0byBzcGVjaWZ5IHRoZSB0YXJnZXQgZW52aXJvbm1lbnQgPT4gJ2Rpc3QvcHJvZHVjdGlvbicuXG4gICAgICogVXNpbmcgJ2Rpc3QvcHJvZHVjdGlvbicgd2lsbCBhbHNvIHVzZSB0aGUgc2VydmljZSB3b3JrZXIgZm9yICdkaXN0L2VzbSdcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy51c2VTZXJ2aWNlV29ya2VyXG4gICAgICogQHR5cGUgQm9vbGVhbnxTdHJpbmdcbiAgICAgKi9cbiAgICB1c2VTZXJ2aWNlV29ya2VyOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIEFwcCwgRGF0YSAmIFZEb20gYXMgU2hhcmVkV29ya2Vycy5cbiAgICAgKiBTZXQgdGhpcyBvbmUgdG8gdHJ1ZSBpbiBjYXNlIHlvdSB3YW50IHRvIGNvbm5lY3QgbXVsdGlwbGUgbWFpbiB0aHJlYWRzLlxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLnVzZVNoYXJlZFdvcmtlcnNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdXNlU2hhcmVkV29ya2VyczogZmFsc2UsXG4gICAgLyoqXG4gICAgICogVHJ1ZSB3aWxsIGdlbmVyYXRlIGEgbmV3IHRhc2sgd29ya2VyLCB3aGljaCBjYW4gZ2V0IGZpbGxlZCB3aXRoIG93biBleHBlbnNpdmUgcmVtb3RlIG1ldGhvZHNcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy51c2VUYXNrV29ya2VyXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHVzZVRhc2tXb3JrZXI6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEZhbHNlIHdpbGwgY3JlYXRlIHRoZSB2ZG9tLkhlbHBlciB3aXRoaW4gdGhlIEFwcCB3b3JrZXIgKGV4cGVyaW1lbnRhbCEpXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy51c2VWZG9tV29ya2VyXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHVzZVZkb21Xb3JrZXI6IHRydWUsXG4gICAgLyoqXG4gICAgICogYnVpbGRTY3JpcHRzL2luamVjdFBhY2thZ2VWZXJzaW9uLm1qcyB3aWxsIHVwZGF0ZSB0aGlzIHZhbHVlXG4gICAgICogQGRlZmF1bHQgJzEwLjEuMSdcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcudmVyc2lvblxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqL1xuICAgIHZlcnNpb246ICcxMC4xLjEnXG59O1xuXG5PYmplY3QuYXNzaWduKERlZmF1bHRDb25maWcsIHtcbiAgICAvKipcbiAgICAgKiBQYXRoIHRvIHRoZSB0b3AgbGV2ZWwgbmVvLm1qcyByZXNvdXJjZXMgZm9sZGVyXG4gICAgICogQGRlZmF1bHQgTmVvLmNvbmZpZy5iYXNlUGF0aCArICdyZXNvdXJjZXMvJ1xuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy5yZXNvdXJjZXNQYXRoXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICovXG4gICAgcmVzb3VyY2VzUGF0aDogYCR7TmVvLmNvbmZpZy5iYXNlUGF0aCB8fCBEZWZhdWx0Q29uZmlnLmJhc2VQYXRofXJlc291cmNlcy9gLFxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGJhc2UgVVJMIGZvciB3ZWIgd29ya2VyIGVudHJ5IHBvaW50cyAoQXBwLCBEYXRhLCBWZG9tKVxuICAgICAqIEBkZWZhdWx0IE5lby5jb25maWcuYmFzZVBhdGggKyAnc3JjL3dvcmtlci8nXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLndvcmtlckJhc2VQYXRoXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICovXG4gICAgd29ya2VyQmFzZVBhdGg6IGAke05lby5jb25maWcuYmFzZVBhdGggfHwgRGVmYXVsdENvbmZpZy5iYXNlUGF0aH1zcmMvd29ya2VyL2AsXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgRGVmYXVsdENvbmZpZztcbiIsImltcG9ydCBEZWZhdWx0Q29uZmlnICBmcm9tICcuL0RlZmF1bHRDb25maWcubWpzJztcbmltcG9ydCB7aXNEZXNjcmlwdG9yfSBmcm9tICcuL2NvcmUvQ29uZmlnU3ltYm9scy5tanMnO1xuXG5jb25zdFxuICAgIGNhbWVsUmVnZXggICA9IC8tLi9nLFxuICAgIGNvbmZpZ1N5bWJvbCA9IFN5bWJvbC5mb3IoJ2NvbmZpZ1N5bWJvbCcpLFxuICAgIGdldFNldENhY2hlICA9IFN5bWJvbCgnZ2V0U2V0Q2FjaGUnKSxcbiAgICBjbG9uZU1hcCA9IHtcbiAgICAgICAgQXJyYXkob2JqLCBkZWVwLCBpZ25vcmVOZW9JbnN0YW5jZXMpIHtcbiAgICAgICAgICAgIHJldHVybiAhZGVlcCA/IFsuLi5vYmpdIDogWy4uLm9iai5tYXAodmFsID0+IE5lby5jbG9uZSh2YWwsIGRlZXAsIGlnbm9yZU5lb0luc3RhbmNlcykpXVxuICAgICAgICB9LFxuICAgICAgICBEYXRlKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG9iai52YWx1ZU9mKCkpXG4gICAgICAgIH0sXG4gICAgICAgIE1hcChvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWFwKG9iaikgLy8gc2hhbGxvdyBjb3B5XG4gICAgICAgIH0sXG4gICAgICAgIE5lb0luc3RhbmNlKG9iaiwgaWdub3JlTmVvSW5zdGFuY2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gaWdub3JlTmVvSW5zdGFuY2VzID8gb2JqIDogTmVvLmNsb25lTmVvSW5zdGFuY2Uob2JqKVxuICAgICAgICB9LFxuICAgICAgICBTZXQob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNldChvYmopXG4gICAgICAgIH0sXG4gICAgICAgIE9iamVjdChvYmosIGRlZXAsIGlnbm9yZU5lb0luc3RhbmNlcykge1xuICAgICAgICAgICAgY29uc3Qgb3V0ID0ge307XG5cbiAgICAgICAgICAgIC8vIFVzZSBSZWZsZWN0Lm93bktleXMoKSB0byBpbmNsdWRlIHN5bWJvbCBwcm9wZXJ0aWVzIChlLmcuLCBmb3IgY29uZmlnIGRlc2NyaXB0b3JzKVxuICAgICAgICAgICAgUmVmbGVjdC5vd25LZXlzKG9iaikuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV07XG4gICAgICAgICAgICAgICAgb3V0W2tleV0gPSAhZGVlcCA/IHZhbHVlIDogTmVvLmNsb25lKHZhbHVlLCBkZWVwLCBpZ25vcmVOZW9JbnN0YW5jZXMpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIG91dFxuICAgICAgICB9XG4gICAgfSxcbiAgICB0eXBlRGV0ZWN0b3IgPSB7XG4gICAgICAgIGZ1bmN0aW9uOiBpdGVtID0+IHtcbiAgICAgICAgICAgIGlmIChpdGVtLnByb3RvdHlwZT8uY29uc3RydWN0b3I/LmlzQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ05lb0NsYXNzJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvYmplY3Q6IGl0ZW0gPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW0uY29uc3RydWN0b3I/LmlzQ2xhc3MgJiYgaXRlbSBpbnN0YW5jZW9mIE5lby5jb3JlLkJhc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ05lb0luc3RhbmNlJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuLyoqXG4gKiBUaGUgYmFzZSBtb2R1bGUgdG8gZW5oYW5jZSBjbGFzc2VzLCBjcmVhdGUgaW5zdGFuY2VzIGFuZCB0aGUgTmVvIG5hbWVzcGFjZVxuICogQG1vZHVsZSBOZW9cbiAqIEBzaW5nbGV0b25cbiAqIEBib3Jyb3dzIE5lby5jb3JlLlV0aWwuYmluZE1ldGhvZHMgICAgICAgYXMgYmluZE1ldGhvZHNcbiAqIEBib3Jyb3dzIE5lby5jb3JlLlV0aWwuY3JlYXRlU3R5bGVPYmplY3QgYXMgY3JlYXRlU3R5bGVPYmplY3RcbiAqIEBib3Jyb3dzIE5lby5jb3JlLlV0aWwuY3JlYXRlU3R5bGVzICAgICAgYXMgY3JlYXRlU3R5bGVzXG4gKiBAYm9ycm93cyBOZW8uY29yZS5VdGlsLmRlY2FtZWwgICAgICAgICAgIGFzIGRlY2FtZWxcbiAqIEBib3Jyb3dzIE5lby5jb3JlLlV0aWwuaXNBcnJheSAgICAgICAgICAgYXMgaXNBcnJheVxuICogQGJvcnJvd3MgTmVvLmNvcmUuVXRpbC5pc0Jvb2xlYW4gICAgICAgICBhcyBpc0Jvb2xlYW5cbiAqIEBib3Jyb3dzIE5lby5jb3JlLlV0aWwuaXNEZWZpbmVkICAgICAgICAgYXMgaXNEZWZpbmVkXG4gKiBAYm9ycm93cyBOZW8uY29yZS5Db21wYXJlLmlzRXF1YWwgICAgICAgIGFzIGlzRXF1YWxcbiAqIEBib3Jyb3dzIE5lby5jb3JlLlV0aWwuaXNOdW1iZXIgICAgICAgICAgYXMgaXNOdW1iZXJcbiAqIEBib3Jyb3dzIE5lby5jb3JlLlV0aWwuaXNPYmplY3QgICAgICAgICAgYXMgaXNPYmplY3RcbiAqIEBib3Jyb3dzIE5lby5jb3JlLlV0aWwuaXNTdHJpbmcgICAgICAgICAgYXMgaXNTdHJpbmdcbiAqIEBib3Jyb3dzIE5lby5jb3JlLlV0aWwudG9BcnJheSAgICAgICAgICAgYXMgdG9BcnJheVxuICogQHR1dG9yaWFsIDAxX0NvbmNlcHRcbiAqL1xubGV0IE5lbyA9IGdsb2JhbFRoaXMuTmVvIHx8IHt9O1xuXG5OZW8gPSBnbG9iYWxUaGlzLk5lbyA9IE9iamVjdC5hc3NpZ24oe1xuICAgIC8qKlxuICAgICAqIEEgbWFwIGNvbnRhaW5pbmcgbnR5cGVzIGFzIGtleSBhbmQgTmVvIGNsYXNzZXMgb3Igc2luZ2xldG9ucyBhcyB2YWx1ZXNcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICovXG4gICAgbnR5cGVNYXA6IHt9LFxuICAgIC8qKlxuICAgICAqIE5lZWRlZCBmb3IgTmVvLmNyZWF0ZS4gRmFsc2UgZm9yIHRoZSBtYWluIHRocmVhZCwgdHJ1ZSBmb3IgdGhlIEFwcCwgRGF0YSAmIFZkb20gd29ya2VyXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICBpbnNpZGVXb3JrZXI6IHR5cGVvZiBEZWRpY2F0ZWRXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyxcblxuICAgIC8qKlxuICAgICAqIE1hcHMgbWV0aG9kcyBmcm9tIG9uZSBuYW1lc3BhY2UgdG8gYW5vdGhlciBvbmVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGFsaWFzZXNcbiAgICAgKiBOZW8uYXBwbHlGcm9tTnMoTmVvLCBVdGlsLCB7XG4gICAgICogICAgIGNyZWF0ZVN0eWxlT2JqZWN0OiAnY3JlYXRlU3R5bGVPYmplY3QnLFxuICAgICAqICAgICBjcmVhdGVTdHlsZXMgICAgIDogJ2NyZWF0ZVN0eWxlcycsXG4gICAgICogICAgIGNhcGl0YWxpemUgICAgICAgOiAnY2FwaXRhbGl6ZSdcbiAgICAgKiB9LCB0cnVlKTtcbiAgICAgKlxuICAgICAqIC8vIGUuZy4gTmVvLmNvcmUuVXRpbC5pc09iamVjdCA9PiBOZW8uaXNPYmplY3RcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOk5lb1xuICAgICAqIEBwYXJhbSB7TmVvfE5lby5jb3JlLkJhc2V9IHRhcmdldCAgICBUaGUgdGFyZ2V0IGNsYXNzIG9yIHNpbmdsZXRvbiBJbnN0YW5jZSBvciBOZW9cbiAgICAgKiBAcGFyYW0ge05lby5jb3JlLkJhc2V9ICAgICBuYW1lc3BhY2UgVGhlIGNsYXNzIGNvbnRhaW5pbmcgdGhlIG1ldGhvZHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgICBjb25maWdcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgICAgICBbYmluZF0gICAgc2V0IHRoaXMgdG8gdHJ1ZSBpbiBjYXNlIHlvdSB3YW50IHRvIGJpbmQgbWV0aG9kcyB0byB0aGUgXCJmcm9tXCIgbmFtZXNwYWNlXG4gICAgICogQHJldHVybnMge09iamVjdH0gdGFyZ2V0XG4gICAgICovXG4gICAgYXBwbHlGcm9tTnModGFyZ2V0LCBuYW1lc3BhY2UsIGNvbmZpZywgYmluZCkge1xuICAgICAgICBsZXQgZm5OYW1lO1xuXG4gICAgICAgIGlmICh0YXJnZXQgJiYgTmVvLnR5cGVPZihjb25maWcpID09PSAnT2JqZWN0Jykge1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoY29uZmlnKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICBmbk5hbWUgPSBuYW1lc3BhY2VbdmFsdWVdO1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gYmluZCA/IGZuTmFtZS5iaW5kKG5hbWVzcGFjZSkgOiBmbk5hbWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1hcHMgYSBjbGFzcyB0byB0aGUgZ2xvYmFsIE5lbyBvciBBcHAgbmFtZXNwYWNlLlxuICAgICAqIENhbiBnZXQgY2FsbGVkIGZvciBjbGFzc2VzIGFuZCBzaW5nbGV0b24gaW5zdGFuY2VzXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpOZW9cbiAgICAgKiBAcGFyYW0ge05lby5jb3JlLkJhc2V9IGNsc1xuICAgICAqL1xuICAgIGFwcGx5VG9HbG9iYWxOcyhjbHMpIHtcbiAgICAgICAgbGV0IHByb3RvICAgICA9IHR5cGVvZiBjbHMgPT09ICdmdW5jdGlvbicgPyBjbHMucHJvdG90eXBlIDogY2xzLFxuICAgICAgICAgICAgY2xhc3NOYW1lID0gcHJvdG8uaXNDbGFzcyA/IHByb3RvLmNvbmZpZy5jbGFzc05hbWUgOiBwcm90by5jbGFzc05hbWUsXG4gICAgICAgICAgICBuc0FycmF5ICAgPSBjbGFzc05hbWUuc3BsaXQoJy4nKSxcbiAgICAgICAgICAgIGtleSAgICAgICA9IG5zQXJyYXkucG9wKCksXG4gICAgICAgICAgICBucyAgICAgICAgPSBOZW8ubnMobnNBcnJheSwgdHJ1ZSk7XG5cbiAgICAgICAgbnNba2V5XSA9IGNsc1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgYWxsIGtleXMgb2YgZGVmYXVsdHMgaW50byB0YXJnZXQsIGluIGNhc2UgdGhleSBkb24ndCBhbHJlYWR5IGV4aXN0XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpOZW9cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0ICAgVGhlIHRhcmdldCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdHMgVGhlIG9iamVjdCBjb250YWluaW5nIHRoZSBrZXlzIHlvdSB3YW50IHRvIGNvcHlcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cbiAgICBhc3NpZ25EZWZhdWx0cyh0YXJnZXQsIGRlZmF1bHRzKSB7XG4gICAgICAgIGlmICh0YXJnZXQgJiYgTmVvLnR5cGVPZihkZWZhdWx0cykgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhkZWZhdWx0cykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFPYmplY3QuaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXRcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBhIG5ldyB2YWx1ZSB0byBhIGdpdmVuIG5lc3RlZCBvYmplY3RzIHBhdGguXG4gICAgICogSXQgd2lsbCBjcmVhdGUgdGhlIHBhdGggc3RydWN0dXJlIG9yIHBhcnRzIG9mIGl0LCBpbiBjYXNlIGl0IGRvZXMgbm90IGV4aXN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICogTmVvLmFzc2lnblRvTnMoJ2Fubm90YXRpb25zLnNlbGVjdGVkJywgZmFsc2UsIHJlY29yZClcbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6TmVvXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXXxTdHJpbmd9IHBhdGggICAgICAgICAgICAgVGhlIHBhdGggc3RyaW5nIGNvbnRhaW5pbmcgZG90cyBvciBhbiBBcnJheSBvZiB0aGUgc3RyaW5nIHBhcnRzXG4gICAgICogQHBhcmFtIHsqfSAgICAgICAgICAgICAgIHZhbHVlICAgICAgICAgICAgVGhlIG5ldyB2YWx1ZSB0byBhc3NpZ24gdG8gdGhlIGxlYWYgbm9kZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICBzY29wZT1nbG9iYWxUaGlzIFNldCBhIGRpZmZlcmVudCBzdGFydGluZyBwb2ludCBhcyBnbG9iYWxUaGlzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICAgIGZvcmNlPXRydWUgICAgICAgZmFsc2Ugd2lsbCBvbmx5IGFzc2lnbiBkZWZhdWx0IHZhbHVlcyAoYXNzaWduIGlmIG9sZCB2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAqL1xuICAgIGFzc2lnblRvTnMocGF0aCwgdmFsdWUsIHNjb3BlPWdsb2JhbFRoaXMsIGZvcmNlPXRydWUpIHtcbiAgICAgICAgcGF0aCA9IEFycmF5LmlzQXJyYXkocGF0aCkgPyBwYXRoIDogcGF0aC5zcGxpdCgnLicpO1xuXG4gICAgICAgIGxldCBrZXk7XG5cbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAga2V5ICAgPSBwYXRoLnBvcCgpO1xuICAgICAgICAgICAgc2NvcGUgPSBOZW8ubnMocGF0aCwgdHJ1ZSwgc2NvcGUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBrZXkgPSBwYXRoXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm9yY2UgfHwgc2NvcGVba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzY29wZVtrZXldID0gdmFsdWVcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBrZWJhYi1jYXNlIHN0cmluZ3MgaW50byBjYW1lbC1jYXNlXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpOZW9cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIHRhcmdldCBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGNhbWVsKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKGNhbWVsUmVnZXgsIG1hdGNoID0+IG1hdGNoWzFdLnRvVXBwZXJDYXNlKCkpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2VzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBzdHJpbmcgdXBwZXJjYXNlXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpOZW9cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbnxTdHJpbmd9IFJldHVybnMgZmFsc2UgZm9yIG5vbiBzdHJpbmcgaW5wdXRzXG4gICAgICovXG4gICAgY2FwaXRhbGl6ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWVbMF0udG9VcHBlckNhc2UoKSArIHZhbHVlLnNsaWNlKDEpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6TmVvXG4gICAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl8Kn0gb2JqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBkZWVwPWZhbHNlICAgICAgICAgICAgICAgU2V0IHRoaXMgdG8gdHJ1ZSBpbiBjYXNlIHlvdSB3YW50IHRvIGNsb25lIG5lc3RlZCBvYmplY3RzIGFzIHdlbGxcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlnbm9yZU5lb0luc3RhbmNlcz1mYWxzZSByZXR1cm5zIGV4aXN0aW5nIGluc3RhbmNlcyBpZiBzZXQgdG8gdHJ1ZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8QXJyYXl8Kn0gdGhlIGNsb25lZCBpbnB1dFxuICAgICAqL1xuICAgIGNsb25lKG9iaiwgZGVlcD1mYWxzZSwgaWdub3JlTmVvSW5zdGFuY2VzPWZhbHNlKSB7XG4gICAgICAgIHJldHVybiBjbG9uZU1hcFtOZW8udHlwZU9mKG9iaildPy4ob2JqLCBkZWVwLCBpZ25vcmVOZW9JbnN0YW5jZXMpIHx8IG9ialxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIHVzaW5nIHRoZSBvcmlnaW5hbENvbmZpZyB3aXRob3V0IHRoZSBpZFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6TmVvXG4gICAgICogQHBhcmFtIHtOZW8uY29yZS5CYXNlfSBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29yZS5CYXNlfSB0aGUgY2xvbmVkIGluc3RhbmNlXG4gICAgICovXG4gICAgY2xvbmVOZW9JbnN0YW5jZShpbnN0YW5jZSkge1xuICAgICAgICBsZXQgY29uZmlnID0gey4uLmluc3RhbmNlLm9yaWdpbmFsQ29uZmlnfTtcblxuICAgICAgICBkZWxldGUgY29uZmlnLl9pZDtcbiAgICAgICAgZGVsZXRlIGNvbmZpZy5pZDtcblxuICAgICAgICByZXR1cm4gTmVvLmNyZWF0ZShpbnN0YW5jZS5jbGFzc05hbWUsIGNvbmZpZylcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXNlIE5lby5jcmVhdGUoKSBpbnN0ZWFkIG9mIFwibmV3XCIgdG8gY3JlYXRlIGluc3RhbmNlcyBvZiBhbGwgTmVvIGNsYXNzZXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGltcG9ydCBCdXR0b24gZnJvbSAnLi4vYnV0dG9uL0Jhc2UubWpzJztcbiAgICAgKlxuICAgICAqIE5lby5jcmVhdGUoQnV0dG9uLCB7XG4gICAgICogICAgIGljb25DbHM6ICdmYSBmYS1ob21lJyxcbiAgICAgKiAgICAgdGV4dCAgIDogJ0hvbWUnXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpbXBvcnQgQnV0dG9uIGZyb20gJy4uL2J1dHRvbi9CYXNlLm1qcyc7XG4gICAgICpcbiAgICAgKiBOZW8uY3JlYXRlKHtcbiAgICAgKiAgICAgbW9kdWxlIDogQnV0dG9uLFxuICAgICAqICAgICBpY29uQ2xzOiAnZmEgZmEtaG9tZScsXG4gICAgICogICAgIHRleHQgICA6ICdIb21lJ1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlXG4gICAgICogTmVvLmNyZWF0ZSgnTmVvLmJ1dHRvbi5CYXNlJyB7XG4gICAgICogICAgIGljb25DbHM6ICdmYSBmYS1ob21lJyxcbiAgICAgKiAgICAgdGV4dCAgIDogJ0hvbWUnXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBOZW8uY3JlYXRlKHtcbiAgICAgKiAgICAgY2xhc3NOYW1lOiAnTmVvLmJ1dHRvbi5CYXNlJyxcbiAgICAgKiAgICAgaWNvbkNscyAgOiAnZmEgZmEtaG9tZScsXG4gICAgICogICAgIHRleHQgICAgIDogJ0hvbWUnXG4gICAgICogfSk7XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpOZW9cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8TmVvLmNvcmUuQmFzZX0gY2xhc3NOYW1lXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgIFtjb25maWddXG4gICAgICogQHJldHVybnMge05lby5jb3JlLkJhc2V8bnVsbH0gVGhlIG5ldyBjbGFzcyBpbnN0YW5jZVxuICAgICAqIEB0dXRvcmlhbCAwMl9DbGFzc1N5c3RlbVxuICAgICAqL1xuICAgIGNyZWF0ZShjbGFzc05hbWUsIGNvbmZpZykge1xuICAgICAgICBsZXQgdHlwZSA9IE5lby50eXBlT2YoY2xhc3NOYW1lKSxcbiAgICAgICAgICAgIGNscywgaW5zdGFuY2U7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdOZW9DbGFzcycpIHtcbiAgICAgICAgICAgIGNscyA9IGNsYXNzTmFtZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnID0gY2xhc3NOYW1lO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFjb25maWcuY2xhc3NOYW1lICYmICFjb25maWcubW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVzaW5nIGNvbnNvbGUuZXJyb3IgaW5zdGVhZCBvZiB0aHJvdyB0byBzaG93IHRoZSBjb25maWcgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0NsYXNzIGNyZWF0ZWQgd2l0aCBvYmplY3QgY29uZmlndXJhdGlvbiBtaXNzaW5nIGNsYXNzTmFtZSBvciBtb2R1bGUgcHJvcGVydHknLCBjb25maWcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9IGNvbmZpZy5jbGFzc05hbWUgfHwgY29uZmlnLm1vZHVsZS5wcm90b3R5cGUuY2xhc3NOYW1lXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZXhpc3RzKGNsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsYXNzICcgKyBjbGFzc05hbWUgKyAnIGRvZXMgbm90IGV4aXN0JylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2xzID0gTmVvLm5zKGNsYXNzTmFtZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGluc3RhbmNlID0gbmV3IGNscygpO1xuXG4gICAgICAgIGluc3RhbmNlLmNvbnN0cnVjdChjb25maWcpO1xuICAgICAgICBpbnN0YW5jZS5vbkNvbnN0cnVjdGVkKCk7XG4gICAgICAgIGluc3RhbmNlLm9uQWZ0ZXJDb25zdHJ1Y3RlZCgpO1xuICAgICAgICBpbnN0YW5jZS5pbml0KCk7XG5cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlZmluZXMgYSByZWFjdGl2ZSBjb25maWd1cmF0aW9uIHByb3BlcnR5IG9uIGEgdGFyZ2V0IG9iamVjdCAocHJvdG90eXBlIG9yIGluc3RhbmNlKS5cbiAgICAgKiBUaGlzIG1ldGhvZCBjcmVhdGVzIGdldHRlcnMgYW5kIHNldHRlcnMgdGhhdCBmdWxseSBwYXJ0aWNpcGF0ZSBpbiBOZW8ubWpzJ3MgcmVhY3RpdmUgY29uZmlnIHN5c3RlbSxcbiAgICAgKiBpbmNsdWRpbmcgbGlmZWN5Y2xlIGhvb2tzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOZW8uY29yZS5CYXNlfSAgdGFyZ2V0ICAgICAgICAtIFRoZSBpbnN0YW5jZSBvciBwcm90b3R5cGUgb24gd2hpY2ggdG8gZGVmaW5lIHRoZSBjb25maWcuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgICAgICAga2V5ICAgICAgICAgICAtIFRoZSBuYW1lIG9mIHRoZSBjb25maWcgcHJvcGVydHkgKHdpdGhvdXQgdGhlICdfJyBzdWZmaXgpLlxuICAgICAqIEBwYXJhbSB7Kn0gICAgICAgICAgICAgW2luaXRpYWxWYWx1ZV0gLSBUaGUgaW5pdGlhbCB2YWx1ZSBmb3IgdGhlIGNvbmZpZy5cbiAgICAgKi9cbiAgICBjcmVhdGVDb25maWcodGFyZ2V0LCBrZXksIGluaXRpYWxWYWx1ZSkge1xuICAgICAgICBpZiAoTmVvLmhhc1Byb3BlcnR5U2V0dGVyKHRhcmdldCwga2V5KSkge1xuICAgICAgICAgICAgdGhyb3coXG5gSW52YWxpZCBjb25maWcgaW4gJHt0YXJnZXQuY2xhc3NOYW1lfTogJyR7a2V5fV8nLiBUaGUgY29uZmlnICcke2tleX0nIGlzIGFscmVhZHkgZGVmaW5lZCBhcyByZWFjdGl2ZSBieSBhIHBhcmVudCBjbGFzcy5cblRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IHZhbHVlLCB1c2UgJyR7a2V5fScgKHdpdGhvdXQgdGhlIHVuZGVyc2NvcmUpIGluIHlvdXIgc3RhdGljIGNvbmZpZy5cbklmIHlvdSBpbnRlbmRlZCB0byBjcmVhdGUgY3VzdG9tIGxvZ2ljLCB1c2UgdGhlICdiZWZvcmVHZXQke05lby5jYXBpdGFsaXplKGtleSl9KCknLCAnYmVmb3JlU2V0JHtOZW8uY2FwaXRhbGl6ZShrZXkpfSgpJywgYW5kICdhZnRlclNldCR7TmVvLmNhcGl0YWxpemUoa2V5KX0oKScgaG9va3MgaW5zdGVhZCBvZiByZWRlZmluaW5nIHRoZSBjb25maWcuYFxuICAgICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIF9rZXkgICAgICA9ICdfJyArIGtleSxcbiAgICAgICAgICAgIHVLZXkgICAgICA9IGtleVswXS50b1VwcGVyQ2FzZSgpICsga2V5LnNsaWNlKDEpLFxuICAgICAgICAgICAgYmVmb3JlR2V0ID0gJ2JlZm9yZUdldCcgKyB1S2V5LFxuICAgICAgICAgICAgYmVmb3JlU2V0ID0gJ2JlZm9yZVNldCcgKyB1S2V5LFxuICAgICAgICAgICAgYWZ0ZXJTZXQgID0gJ2FmdGVyU2V0JyAgKyB1S2V5O1xuXG4gICAgICAgIE5lb1tnZXRTZXRDYWNoZV0gPz89IHt9O1xuXG4gICAgICAgIGlmICghTmVvW2dldFNldENhY2hlXVtrZXldKSB7XG4gICAgICAgICAgICAvLyBQdWJsaWMgRGVzY3JpcHRvclxuICAgICAgICAgICAgTmVvW2dldFNldENhY2hlXVtrZXldID0ge1xuICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcgICAgPSBtZS5nZXRDb25maWcoa2V5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc05ld0tleSA9IE9iamVjdC5oYXNPd24obWVbY29uZmlnU3ltYm9sXSwga2V5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0tleSAgICA9IG1lW2NvbmZpZ1N5bWJvbF1ba2V5XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICAgICA9IGhhc05ld0tleSA/IG5ld0tleSA6IG1lW19rZXldO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUodmFsdWUudmFsdWVPZigpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBuZXcsIGV4cGxpY2l0IG9wdC1pbiBwYXRoXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbmZpZy5jbG9uZU9uR2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7Y2xvbmVPbkdldH0gPSBjb25maWc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbG9uZU9uR2V0ID09PSAnZGVlcCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IE5lby5jbG9uZSh2YWx1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNsb25lT25HZXQgPT09ICdzaGFsbG93Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBOZW8udHlwZU9mKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnQXJyYXknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gWy4uLnZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gey4uLnZhbHVlfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gbGVnYWN5IGJlaGF2aW9yXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFsuLi52YWx1ZV07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzTmV3S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZVtrZXldID0gdmFsdWU7ICAvLyBXZSBkbyB3YW50IHRvIHRyaWdnZXIgdGhlIHNldHRlciA9PiBiZWZvcmVTZXQsIGFmdGVyU2V0XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG1lW19rZXldOyAvLyBSZXR1cm4gdGhlIHZhbHVlIHBhcnNlZCBieSB0aGUgc2V0dGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgbWVbY29uZmlnU3ltYm9sXVtrZXldXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lW2JlZm9yZUdldF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbWVbYmVmb3JlR2V0XSh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5nZXRDb25maWcoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb25maWcpIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICBsZXQgbWUgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlICAgICAgICA9IGNvbmZpZy5nZXQoKSwgLy8gR2V0IHRoZSBvbGQgdmFsdWUgZnJvbSB0aGUgQ29uZmlnIGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICB7RWZmZWN0TWFuYWdlcn0gPSBOZW8uY29yZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzTmV3QmF0Y2ggICAgICA9ICFFZmZlY3RNYW5hZ2VyPy5pc1BhdXNlZCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGEgY29uZmlnIGNoYW5nZSBpcyBub3QgdHJpZ2dlcmVkIHZpYSBgY29yZS5CYXNlI3NldCgpYCwgaG9ub3IgY2hhbmdlcyBpbnNpZGUgaG9va3MuXG4gICAgICAgICAgICAgICAgICAgIGlzTmV3QmF0Y2ggJiYgRWZmZWN0TWFuYWdlcj8ucGF1c2UoKTtcblxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gMS4gUHJldmVudCBpbmZpbml0ZSBsb29wczpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEltbWVkaWF0ZWx5IHJlbW92ZSB0aGUgcGVuZGluZyB2YWx1ZSBmcm9tIHRoZSBjb25maWdTeW1ib2wgdG8gcHJldmVudCBhIGdldHRlciBmcm9tXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWN1cnNpdmVseSByZS10cmlnZ2VyaW5nIHRoaXMgc2V0dGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG1lW2NvbmZpZ1N5bWJvbF1ba2V5XTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb25maWcuY2xvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdkZWVwJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBOZW8uY2xvbmUodmFsdWUsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzaGFsbG93JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBOZW8uY2xvbmUodmFsdWUsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDIuIENyZWF0ZSBhIHRlbXBvcmFyeSBzdGF0ZSBmb3IgYmVmb3JlU2V0IGhvb2tzOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBuZXcgdmFsdWUgZGlyZWN0bHkgb24gdGhlIHByaXZhdGUgYmFja2luZyBwcm9wZXJ0eS4gVGhpcyBhbGxvd3MgYW55IGJlZm9yZVNldFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaG9vayB0byBhY2Nlc3MgdGhlIG5ldyB2YWx1ZSBvZiB0aGlzIGFuZCBvdGhlciBjb25maWdzIHdpdGhpbiB0aGUgc2FtZSBgc2V0KClgIGNhbGwuXG4gICAgICAgICAgICAgICAgICAgICAgICBtZVtfa2V5XSA9IHZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lW2JlZm9yZVNldF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG1lW2JlZm9yZVNldF0odmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXkgZG9uJ3QgcmV0dXJuIGEgdmFsdWUsIHRoYXQgbWVhbnMgbm8gY2hhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgdmFsdWUgaWYgdGhlIHVwZGF0ZSBpcyBjYW5jZWxlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVbX2tleV0gPSBvbGRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAzLiBSZXN0b3JlIHN0YXRlIGZvciBjaGFuZ2UgZGV0ZWN0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2ZXJ0IHRoZSBwcml2YXRlIGJhY2tpbmcgcHJvcGVydHkgdG8gaXRzIG9yaWdpbmFsIHZhbHVlLiBUaGlzIGlzIGNydWNpYWwgZm9yIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYGNvbmZpZy5zZXQoKWAgbWV0aG9kIHRvIGNvcnJlY3RseSBkZXRlY3QgaWYgdGhlIHZhbHVlIGhhcyBhY3R1YWxseSBjaGFuZ2VkLlxuICAgICAgICAgICAgICAgICAgICAgICAgbWVbX2tleV0gPSBvbGRWYWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gNC4gRmluYWxpemUgdGhlIGNoYW5nZTpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBjb25maWcuc2V0KCkgbWV0aG9kIHBlcmZvcm1zIHRoZSBmaW5hbCBjaGVjayBhbmQsIGlmIHRoZSB2YWx1ZSBjaGFuZ2VkLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJpZ2dlcnMgYWZ0ZXJTZXQgaG9va3MgYW5kIG5vdGlmaWVzIHN1YnNjcmliZXJzLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5zZXQodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVbYWZ0ZXJTZXRdPy4odmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5hZnRlclNldENvbmZpZz8uKGtleSwgdmFsdWUsIG9sZFZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5kIHRoZSBiYXRjaCBvbmx5IGlmIHRoaXMgc2V0dGVyIHN0YXJ0ZWQgaXQuXG4gICAgICAgICAgICAgICAgICAgICAgICBpc05ld0JhdGNoICYmIEVmZmVjdE1hbmFnZXI/LnJlc3VtZSgpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBQcml2YXRlIERlc2NyaXB0b3JcbiAgICAgICAgICAgIE5lb1tnZXRTZXRDYWNoZV1bX2tleV0gPSB7XG4gICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb25maWcoa2V5KT8uZ2V0KClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldENvbmZpZyhrZXkpPy5zZXRSYXcodmFsdWUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCAgTmVvW2dldFNldENhY2hlXVtrZXldKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX2tleSwgTmVvW2dldFNldENhY2hlXVtfa2V5XSk7XG5cbiAgICAgICAgaWYgKGluaXRpYWxWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IGluaXRpYWxWYWx1ZVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZW1wdHlGbigpIHt9LFxuXG4gICAgLyoqXG4gICAgICogRW5zdXJlcyBhIGNsYXNzIGlzIGFzc2lnbmVkIHRvIHRoZSBOZW8gbmFtZXNwYWNlIG9ubHkgb25jZSwgcHJldmVudGluZyBkdXBsaWNhdGVzLlxuICAgICAqIFRoaXMgaXMgYSBsaWdodHdlaWdodCB2ZXJzaW9uIG9mIGBOZW8uc2V0dXBDbGFzc2AgZm9yIHNpbXBsZSBjbGFzc2VzXG4gICAgICogdGhhdCBkbyBub3QgZXh0ZW5kIGBOZW8uY29yZS5CYXNlYC5cbiAgICAgKiBJdCBmb2xsb3dzIGEgXCJmaXJzdCBvbmUgd2luc1wiIHN0cmF0ZWd5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9IG1vZHVsZSAgICAtIFRoZSBjbGFzcyBjb25zdHJ1Y3RvciBvciBzaW5nbGV0b24gb2JqZWN0IHRvIHJlZ2lzdGVyLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgICAgICBjbGFzc1BhdGggLSBUaGUgZnVsbHkgcXVhbGlmaWVkIG5hbWUgKGUuZy4sICdOZW8uY29yZS5Db25maWcnKS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSAgICAgICBbb25GaXJzdF0gIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgdGhhdCBydW5zIG9ubHkgdGhlIGZpcnN0IHRpbWUgdGhlIGNsYXNzIGlzIHJlZ2lzdGVyZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufE9iamVjdH0gVGhlIGNsYXNzIG9yIHNpbmdsZXRvbiBmcm9tIHRoZSBOZW8gbmFtZXNwYWNlIChlaXRoZXIgdGhlIGV4aXN0aW5nIG9uZSBvciB0aGUgbmV3bHkgc2V0IG9uZSkuXG4gICAgICovXG4gICAgZ2F0ZWtlZXAobW9kdWxlLCBjbGFzc1BhdGgsIG9uRmlyc3QpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdDbGFzcyA9IE5lby5ucyhjbGFzc1BhdGgsIGZhbHNlKTtcblxuICAgICAgICBpZiAoZXhpc3RpbmdDbGFzcykge1xuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nQ2xhc3NcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBuc0FycmF5ICAgPSBjbGFzc1BhdGguc3BsaXQoJy4nKSxcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IG5zQXJyYXkucG9wKCksXG4gICAgICAgICAgICBwYXJlbnROcyAgPSBOZW8ubnMobnNBcnJheSwgdHJ1ZSk7XG5cbiAgICAgICAgcGFyZW50TnNbY2xhc3NOYW1lXSA9IG1vZHVsZTtcblxuICAgICAgICBvbkZpcnN0Py4obW9kdWxlKTtcblxuICAgICAgICByZXR1cm4gcGFyZW50TnNbY2xhc3NOYW1lXVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlcmUgaXMgYSBzZXQgbWV0aG9kIGZvciBhIGdpdmVuIHByb3BlcnR5IGtleSBpbnNpZGUgdGhlIHByb3RvdHlwZSBjaGFpblxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6TmVvXG4gICAgICogQHBhcmFtIHtOZW8uY29yZS5CYXNlfSBwcm90byBUaGUgdG9wIGxldmVsIHByb3RvdHlwZSBvZiBhIGNsYXNzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgICAgICBrZXkgICBUaGUgcHJvcGVydHkga2V5IHRvIHRlc3RcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNQcm9wZXJ0eVNldHRlcihwcm90bywga2V5KSB7XG4gICAgICAgIGxldCBkZXNjcmlwdG9yO1xuXG4gICAgICAgIHdoaWxlIChwcm90by5fX3Byb3RvX18pIHtcbiAgICAgICAgICAgIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCBrZXkpO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlc2NyaXB0b3IgPT09ICdvYmplY3QnICYmIHR5cGVvZiBkZXNjcmlwdG9yLnNldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByb3RvID0gcHJvdG8uX19wcm90b19fXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVlcC1tZXJnZXMgYSBzb3VyY2Ugb2JqZWN0IGludG8gYSB0YXJnZXQgb2JqZWN0XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpOZW9cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0c1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHRhcmdldFxuICAgICAqL1xuICAgIG1lcmdlKHRhcmdldCwgc291cmNlLCBkZWZhdWx0cykge1xuICAgICAgICBpZiAoZGVmYXVsdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBOZW8ubWVyZ2UoTmVvLm1lcmdlKHRhcmdldCwgZGVmYXVsdHMpLCBzb3VyY2UpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuXG4gICAgICAgICAgICBpZiAoTmVvLnR5cGVPZih2YWx1ZSkgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBOZW8ubWVyZ2UodGFyZ2V0W2tleV0gfHwge30sIHZhbHVlKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1lcmdlcyBhIG5ldyB2YWx1ZSBpbnRvIGFuIGV4aXN0aW5nIGNvbmZpZyB2YWx1ZSBiYXNlZCBvbiBhIHNwZWNpZmllZCBzdHJhdGVneS5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIGR1cmluZyBpbnN0YW5jZSBjcmVhdGlvbiB0byBhcHBseSBtZXJnZSBzdHJhdGVnaWVzIGRlZmluZWQgaW4gY29uZmlnIGRlc2NyaXB0b3JzLlxuICAgICAqIEBwYXJhbSB7YW55fSBkZWZhdWx0VmFsdWUgLSBUaGUgZGVmYXVsdCB2YWx1ZSBvZiB0aGUgY29uZmlnIChmcm9tIHN0YXRpYyBjb25maWcpLlxuICAgICAqIEBwYXJhbSB7YW55fSBpbnN0YW5jZVZhbHVlIC0gVGhlIHZhbHVlIHByb3ZpZGVkIGR1cmluZyBpbnN0YW5jZSBjcmVhdGlvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xGdW5jdGlvbn0gc3RyYXRlZ3kgLSBUaGUgbWVyZ2Ugc3RyYXRlZ3k6ICdzaGFsbG93JywgJ2RlZXAnLCAncmVwbGFjZScsIG9yIGEgY3VzdG9tIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHthbnl9IFRoZSBtZXJnZWQgdmFsdWUuXG4gICAgICovXG4gICAgbWVyZ2VDb25maWcoZGVmYXVsdFZhbHVlLCBpbnN0YW5jZVZhbHVlLCBzdHJhdGVneSkge1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlVHlwZSAgPSBOZW8udHlwZU9mKGRlZmF1bHRWYWx1ZSksXG4gICAgICAgICAgICBpbnN0YW5jZVZhbHVlVHlwZSA9IE5lby50eXBlT2YoaW5zdGFuY2VWYWx1ZSk7XG5cbiAgICAgICAgaWYgKHN0cmF0ZWd5ID09PSAnc2hhbGxvdycpIHtcbiAgICAgICAgICAgIGlmIChkZWZhdWx0VmFsdWVUeXBlID09PSAnT2JqZWN0JyAmJiBpbnN0YW5jZVZhbHVlVHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gey4uLmRlZmF1bHRWYWx1ZSwgLi4uaW5zdGFuY2VWYWx1ZX1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzdHJhdGVneSA9PT0gJ2RlZXAnKSB7XG4gICAgICAgICAgICBpZiAoZGVmYXVsdFZhbHVlVHlwZSA9PT0gJ09iamVjdCcgJiYgaW5zdGFuY2VWYWx1ZVR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5lby5tZXJnZShOZW8uY2xvbmUoZGVmYXVsdFZhbHVlLCB0cnVlKSwgaW5zdGFuY2VWYWx1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3RyYXRlZ3kgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJhdGVneShkZWZhdWx0VmFsdWUsIGluc3RhbmNlVmFsdWUpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZhdWx0IHRvICdyZXBsYWNlJyBvciBpZiBzdHJhdGVneSBpcyBub3QgcmVjb2duaXplZFxuICAgICAgICByZXR1cm4gaW5zdGFuY2VWYWx1ZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYXBzIGEgY2xhc3NOYW1lIHN0cmluZyBpbnRvIGEgZ2l2ZW4gb3IgZ2xvYmFsIG5hbWVzcGFjZVxuICAgICAqIEBleGFtcGxlXG4gICAgICogTmVvLm5zKCdOZW8uYnV0dG9uLkJhc2UnLCB0cnVlKTtcbiAgICAgKiAvLyA9PlxuICAgICAqIC8vIGdsb2JhbFRoaXMuTmVvICAgICAgICAgICAgID0gZ2xvYmFsVGhpcy5OZW8gICAgICAgICAgICAgfHwge307XG4gICAgICogLy8gZ2xvYmFsVGhpcy5OZW8uYnV0dG9uICAgICAgPSBnbG9iYWxUaGlzLk5lby5idXR0b24gICAgICB8fCB7fTtcbiAgICAgKiAvLyBnbG9iYWxUaGlzLk5lby5idXR0b24uQmFzZSA9IGdsb2JhbFRoaXMuTmVvLmJ1dHRvbi5CYXNlIHx8IHt9O1xuICAgICAqIC8vIHJldHVybiBnbG9iYWxUaGlzLk5lby5idXR0b24uQmFzZTtcbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6TmVvXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXXxTdHJpbmd9IG5hbWVzICAgICAgICBUaGUgY2xhc3MgbmFtZSBzdHJpbmcgY29udGFpbmluZyBkb3RzIG9yIGFuIEFycmF5IG9mIHRoZSBzdHJpbmcgcGFydHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgICAgY3JlYXRlPWZhbHNlIFNldCBjcmVhdGUgdG8gdHJ1ZSB0byBjcmVhdGUgZW1wdHkgb2JqZWN0cyBmb3Igbm9uLWV4aXN0aW5nIHBhcnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgIFtzY29wZV0gICAgICBTZXQgYSBkaWZmZXJlbnQgc3RhcnRpbmcgcG9pbnQgYXMgZ2xvYmFsVGhpc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHJlZmVyZW5jZSB0byB0aGUgdG9wbGV2ZWwgbmFtZXNwYWNlXG4gICAgICovXG4gICAgbnMobmFtZXMsIGNyZWF0ZT1mYWxzZSwgc2NvcGUpIHtcbiAgICAgICAgbmFtZXMgPSBBcnJheS5pc0FycmF5KG5hbWVzKSA/IG5hbWVzIDogbmFtZXMuc3BsaXQoJy4nKTtcblxuICAgICAgICByZXR1cm4gbmFtZXMucmVkdWNlKChwcmV2LCBjdXJyZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoY3JlYXRlICYmICFwcmV2W2N1cnJlbnRdKSB7XG4gICAgICAgICAgICAgICAgcHJldltjdXJyZW50XSA9IHt9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXZbY3VycmVudF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgc2NvcGUgfHwgZ2xvYmFsVGhpcylcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXh0ZW5kZWQgdmVyc2lvbiBvZiBOZW8ubnMoKSB3aGljaCBzdXBwb3J0cyBtYXBwaW5nIGludG8gYXJyYXlzLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6TmVvXG4gICAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IG5hbWVzICAgICAgICBUaGUgY2xhc3MgbmFtZSBzdHJpbmcgY29udGFpbmluZyBkb3RzIG9yIGFuIEFycmF5IG9mIHRoZSBzdHJpbmcgcGFydHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgY3JlYXRlPWZhbHNlIFNldCBjcmVhdGUgdG8gdHJ1ZSB0byBjcmVhdGUgZW1wdHkgb2JqZWN0cyBmb3Igbm9uLWV4aXN0aW5nIHBhcnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgIFtzY29wZV0gICAgICBTZXQgYSBkaWZmZXJlbnQgc3RhcnRpbmcgcG9pbnQgYXMgZ2xvYmFsVGhpc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHJlZmVyZW5jZSB0byB0aGUgdG9wbGV2ZWwgbmFtZXNwYWNlXG4gICAgICovXG4gICAgbnNXaXRoQXJyYXlzKG5hbWVzLCBjcmVhdGU9ZmFsc2UsIHNjb3BlKSB7XG4gICAgICAgIG5hbWVzID0gQXJyYXkuaXNBcnJheShuYW1lcykgPyBuYW1lcyA6IG5hbWVzLnNwbGl0KCcuJyk7XG5cbiAgICAgICAgcmV0dXJuIG5hbWVzLnJlZHVjZSgocHJldiwgY3VycmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNyZWF0ZSAmJiAhcHJldltjdXJyZW50XSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LmVuZHNXaXRoKCddJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUFycmF5TnModHJ1ZSwgY3VycmVudCwgcHJldilcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwcmV2W2N1cnJlbnRdID0ge31cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5lbmRzV2l0aCgnXScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVBcnJheU5zKGZhbHNlLCBjdXJyZW50LCBwcmV2KVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2W2N1cnJlbnRdXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHNjb3BlIHx8IGdsb2JhbFRoaXMpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgaW5zdGFuY2VzIG9mIE5lbyBjbGFzc2VzIHVzaW5nIHRoZWlyIG50eXBlIGluc3RlYWQgb2YgdGhlIGNsYXNzIG5hbWVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIE5lby5udHlwZSgnYnV0dG9uJyB7XG4gICAgICogICAgIGljb25DbHM6ICdmYSBmYS1ob21lJyxcbiAgICAgKiAgICAgdGV4dCAgIDogJ0hvbWUnXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBOZW8ubnR5cGUoe1xuICAgICAqICAgICBudHlwZSAgOiAnYnV0dG9uJyxcbiAgICAgKiAgICAgaWNvbkNsczogJ2ZhIGZhLWhvbWUnLFxuICAgICAqICAgICB0ZXh0ICAgOiAnSG9tZSdcbiAgICAgKiB9KTtcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOk5lb1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gbnR5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgIFtjb25maWddXG4gICAgICogQHJldHVybnMge05lby5jb3JlLkJhc2V9XG4gICAgICogQHNlZSB7QGxpbmsgbW9kdWxlOk5lby5jcmVhdGUgY3JlYXRlfVxuICAgICAqL1xuICAgIG50eXBlKG50eXBlLCBjb25maWcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBudHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbmZpZyA9IG50eXBlO1xuXG4gICAgICAgICAgICBpZiAoIWNvbmZpZy5udHlwZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2xhc3MgZGVmaW5lZCB3aXRoIG9iamVjdCBjb25maWd1cmF0aW9uIG1pc3NpbmcgbnR5cGUgcHJvcGVydHkuICcgKyBjb25maWcubnR5cGUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG50eXBlID0gY29uZmlnLm50eXBlXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY2xhc3NOYW1lID0gTmVvLm50eXBlTWFwW250eXBlXTtcblxuICAgICAgICBpZiAoIWNsYXNzTmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdudHlwZSAnICsgbnR5cGUgKyAnIGRvZXMgbm90IGV4aXN0JylcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBOZW8uY3JlYXRlKGNsYXNzTmFtZSwgY29uZmlnKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBmaW5hbCBhbmQgbW9zdCBjcml0aWNhbCBzdGVwIGluIHRoZSBOZW8ubWpzIGNsYXNzIGNyZWF0aW9uIHByb2Nlc3MuXG4gICAgICogSXQgaXMgY2FsbGVkIGF0IHRoZSBlbmQgb2YgZXZlcnkgY2xhc3MgbW9kdWxlIGRlZmluaXRpb24uXG4gICAgICpcbiAgICAgKiBgc2V0dXBDbGFzc2AgcGVyZm9ybXMgc2V2ZXJhbCBrZXkgb3BlcmF0aW9uczpcbiAgICAgKiAxLiAgKipNaXhlZC1FbnZpcm9ubWVudCBHYXRla2VlcGVyOioqIEl0IGZpcnN0IGNoZWNrcyBpZiB0aGUgY2xhc3MncyBuYW1lc3BhY2UgYWxyZWFkeSBleGlzdHMuXG4gICAgICogICAgIElmIGl0IGRvZXMsIGl0IGltbWVkaWF0ZWx5IHJldHVybnMgdGhlIGV4aXN0aW5nIGNsYXNzLiBUaGlzIGlzIHRoZSBjcnVjaWFsIFwiZmlyc3QgY29tZXMgd2luc1wiXG4gICAgICogICAgIHN0cmF0ZWd5IHRoYXQgZW5hYmxlcyBOZW8ubWpzIHRvIHNhZmVseSBjb21iaW5lIGVudmlyb25tZW50cy4gRm9yIGV4YW1wbGUsIGEgYnVuZGxlZFxuICAgICAqICAgICBgZGlzdC9wcm9kdWN0aW9uYCBhcHAgY2FuIGR5bmFtaWNhbGx5IGxvYWQgYW4gdW5idW5kbGVkIG1vZHVsZSBmcm9tIGBkaXN0L2VzbWAgYXQgcnVudGltZS5cbiAgICAgKiAgICAgSWYgdGhhdCBtb2R1bGUgaW1wb3J0cyBhIGNsYXNzIGFscmVhZHkgcHJlc2VudCBpbiB0aGUgbWFpbiBidW5kbGUsIHRoaXMgY2hlY2sgZW5zdXJlcyB0aGVcbiAgICAgKiAgICAgb3JpZ2luYWwsIGJ1bmRsZWQgY2xhc3MgaXMgdXNlZCwgcHJldmVudGluZyBjb25mbGljdHMgYW5kIG1haW50YWluaW5nIGFwcGxpY2F0aW9uIGludGVncml0eS5cbiAgICAgKiAxLiAgKipDb25maWd1cmF0aW9uIE1lcmdpbmc6KiogSXQgdHJhdmVyc2VzIHRoZSBwcm90b3R5cGUgY2hhaW4gdG8gbWVyZ2UgYHN0YXRpYyBjb25maWdgXG4gICAgICogICAgIG9iamVjdHMgZnJvbSBwYXJlbnQgY2xhc3NlcyBpbnRvIHRoZSBjdXJyZW50IGNsYXNzLCBjcmVhdGluZyBhIHVuaWZpZWQgYGNvbmZpZ2AuXG4gICAgICogMi4gICoqQXBwbHlpbmcgT3ZlcndyaXRlczoqKiBJdCBjYWxscyB0aGUgc3RhdGljIGBhcHBseU92ZXJ3cml0ZXMoKWAgbWV0aG9kIG9uIHRoZSBjbGFzcyxcbiAgICAgKiAgICAgYWxsb3dpbmcgdGhlIGdsb2JhbCBgTmVvLm92ZXJ3cml0ZXNgIG9iamVjdCB0byBtb2RpZnkgdGhlIGNsYXNzJ3MgZGVmYXVsdCBwcm90b3R5cGVcbiAgICAgKiAgICAgY29uZmlncy4gVGhpcyBpcyBhIGtleSBtZWNoYW5pc20gZm9yIGV4dGVybmFsIHRoZW1pbmcgYW5kIGNvbmZpZ3VyYXRpb24uXG4gICAgICogMy4gICoqUmVhY3RpdmUgR2V0dGVyL1NldHRlciBHZW5lcmF0aW9uOioqIEZvciBhbnkgY29uZmlnIGVuZGluZyB3aXRoIGFuIHVuZGVyc2NvcmUgKGUuZy4sIGBteUNvbmZpZ19gKSxcbiAgICAgKiAgICAgaXQgYXV0b21hdGljYWxseSBnZW5lcmF0ZXMgdGhlIGNvcnJlc3BvbmRpbmcgcHVibGljIGdldHRlciBhbmQgc2V0dGVyLiBUaGlzIGVuYWJsZXMgb3B0aW9uYWxcbiAgICAgKiAgICAgbGlmZWN5Y2xlIGhvb2tzIHRoYXQgYXJlIGNhbGxlZCBhdXRvbWF0aWNhbGx5IGlmIGltcGxlbWVudGVkIG9uIHRoZSBjbGFzczpcbiAgICAgKiAgICAgLSBgYmVmb3JlR2V0TXlDb25maWcodmFsdWUpYFxuICAgICAqICAgICAtIGBiZWZvcmVTZXRNeUNvbmZpZyhuZXdWYWx1ZSwgb2xkVmFsdWUpYFxuICAgICAqICAgICAtIGBhZnRlclNldE15Q29uZmlnKG5ld1ZhbHVlLCBvbGRWYWx1ZSlgXG4gICAgICogNC4gICoqUHJvdG90eXBlLWJhc2VkIENvbmZpZ3M6KiogTm9uLXJlYWN0aXZlIGNvbmZpZ3MgKHdpdGhvdXQgYW4gdW5kZXJzY29yZSkgYXJlIHNldFxuICAgICAqICAgICBkaXJlY3RseSBvbiB0aGUgcHJvdG90eXBlIGZvciBtZW1vcnkgZWZmaWNpZW5jeS5cbiAgICAgKiA1LiAgKipNaXhpbiBBcHBsaWNhdGlvbjoqKiBJdCBwcm9jZXNzZXMgdGhlIGBtaXhpbnNgIGNvbmZpZyB0byBibGVuZCBpbiBmdW5jdGlvbmFsaXR5IGZyb21cbiAgICAgKiAgICAgb3RoZXIgY2xhc3Nlcy5cbiAgICAgKiA2LiAgKipOYW1lc3BhY2UgUmVnaXN0cmF0aW9uOioqIEl0IHJlZ2lzdGVycyB0aGUgY2xhc3MgaW4gdGhlIGdsb2JhbCBgTmVvYCBuYW1lc3BhY2UuXG4gICAgICogNy4gICoqU2luZ2xldG9uIEluc3RhbnRpYXRpb246KiogSWYgdGhlIGNsYXNzIGlzIGNvbmZpZ3VyZWQgYXMgYSBzaW5nbGV0b24sIGl0IGNyZWF0ZXMgdGhlXG4gICAgICogICAgIHNpbmdsZSBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6TmVvXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKiBAcGFyYW0ge1R9IGNscyBUaGUgY2xhc3MgY29uc3RydWN0b3IgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7VH0gVGhlIHByb2Nlc3NlZCBhbmQgZmluYWxpemVkIGNsYXNzIGNvbnN0cnVjdG9yIG9yIHNpbmdsZXRvbiBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBzZXR1cENsYXNzKGNscykge1xuICAgICAgICBsZXQgYmFzZUNvbmZpZyAgICAgICAgICAgID0gbnVsbCxcbiAgICAgICAgICAgIGJhc2VDb25maWdEZXNjcmlwdG9ycyA9IG51bGwsXG4gICAgICAgICAgICBudHlwZUNoYWluICAgICAgICAgICAgPSBbXSxcbiAgICAgICAgICAgIHtudHlwZU1hcH0gICAgICAgICAgICA9IE5lbyxcbiAgICAgICAgICAgIHByb3RvICAgICAgICAgICAgICAgICA9IGNscy5wcm90b3R5cGUgfHwgY2xzLFxuICAgICAgICAgICAgbnMgICAgICAgICAgICAgICAgICAgID0gTmVvLm5zKHByb3RvLmNvbnN0cnVjdG9yLmNvbmZpZy5jbGFzc05hbWUsIGZhbHNlKSxcbiAgICAgICAgICAgIHByb3RvcyAgICAgICAgICAgICAgICA9IFtdLFxuICAgICAgICAgICAgY2ZnLCBjb25maWcsIGNvbmZpZ0Rlc2NyaXB0b3JzLCBjdG9yLCBoaWVyYXJjaHlJbmZvLCBudHlwZTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBJZiB0aGUgbmFtZXNwYWNlIGFscmVhZHkgZXhpc3RzLCBkaXJlY3RseSByZXR1cm4gaXQuXG4gICAgICAgICAqIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHVzaW5nIGRpZmZlcmVudCB2ZXJzaW9ucyBvZiBOZW8ubWpzXG4gICAgICAgICAqID0+IEVzcGVjaWFsbHkgc2luZ2xldG9ucyAoSWRHZW5lcmF0b3IpIG11c3Qgc3RheSB1bmlxdWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgY2FuIGFsc28gaGFwcGVuIHdoZW4gdXNpbmcgZGlmZmVyZW50IGVudmlyb25tZW50cyBvZiBuZW8ubWpzIGluIHBhcmFsbGVsLlxuICAgICAgICAgKiBFeGFtcGxlOiBjb2RlLkxpdmVQcmV2aWV3IHJ1bm5pbmcgaW5zaWRlIGEgZGlzdC9wcm9kdWN0aW9uIGFwcC5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChucykge1xuICAgICAgICAgICAgcmV0dXJuIG5zXG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmF2ZXJzZSB0aGUgcHJvdG90eXBlIGNoYWluIHRvIGNvbGxlY3QgaW5oZXJpdGVkIGNvbmZpZ3MgYW5kIGRlc2NyaXB0b3JzXG4gICAgICAgIHdoaWxlIChwcm90by5fX3Byb3RvX18pIHtcbiAgICAgICAgICAgIGN0b3IgPSBwcm90by5jb25zdHJ1Y3RvcjtcblxuICAgICAgICAgICAgLy8gSWYgYSBjbGFzcyBpbiB0aGUgcHJvdG90eXBlIGNoYWluIGhhcyBhbHJlYWR5IGhhZCBpdHMgY29uZmlnIGFwcGxpZWQsXG4gICAgICAgICAgICAvLyB3ZSBjYW4gdXNlIGl0cyBwcmUtcHJvY2Vzc2VkIGNvbmZpZyBhbmQgZGVzY3JpcHRvcnMgYXMgYSBiYXNlLlxuICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oY3RvciwgJ2NsYXNzQ29uZmlnQXBwbGllZCcpKSB7XG4gICAgICAgICAgICAgICAgYmFzZUNvbmZpZyAgICAgICAgICAgID0gTmVvLmNsb25lKGN0b3IuY29uZmlnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBiYXNlQ29uZmlnRGVzY3JpcHRvcnMgPSBOZW8uY2xvbmUoY3Rvci5jb25maWdEZXNjcmlwdG9ycywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgbnR5cGVDaGFpbiAgICAgICAgICAgID0gWy4uLmN0b3IubnR5cGVDaGFpbl07XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvdG9zLnVuc2hpZnQocHJvdG8pO1xuICAgICAgICAgICAgcHJvdG8gPSBwcm90by5fX3Byb3RvX19cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluaXRpYWxpemUgYWNjdW11bGF0ZWQgY29uZmlnIGFuZCBkZXNjcmlwdG9yc1xuICAgICAgICBjb25maWcgICAgICAgICAgICA9IGJhc2VDb25maWcgICAgICAgICAgICB8fCB7fTtcbiAgICAgICAgY29uZmlnRGVzY3JpcHRvcnMgPSBiYXNlQ29uZmlnRGVzY3JpcHRvcnMgfHwge307XG5cbiAgICAgICAgLy8gUHJvY2VzcyBlYWNoIGNsYXNzIGluIHRoZSBwcm90b3R5cGUgY2hhaW4gKGZyb20gdG9wIHRvIGJvdHRvbSlcbiAgICAgICAgcHJvdG9zLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgICAgICBsZXQgbWl4aW5zO1xuXG4gICAgICAgICAgICBjdG9yID0gZWxlbWVudC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIGNmZyAgPSBjdG9yLmNvbmZpZyB8fCB7fTtcblxuICAgICAgICAgICAgaWYgKE5lby5vdmVyd3JpdGVzKSB7XG4gICAgICAgICAgICAgICAgY3Rvci5hcHBseU92ZXJ3cml0ZXM/LihjZmcpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFByb2Nlc3MgZWFjaCBjb25maWcgcHJvcGVydHkgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBjbGFzcydzIHN0YXRpYyBjb25maWdcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGNmZykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3RcbiAgICAgICAgICAgICAgICAgICAgaXNSZWFjdGl2ZSA9IGtleS5zbGljZSgtMSkgPT09ICdfJyxcbiAgICAgICAgICAgICAgICAgICAgYmFzZUtleSAgICA9IGlzUmVhY3RpdmUgPyBrZXkuc2xpY2UoMCwgLTEpIDoga2V5O1xuXG4gICAgICAgICAgICAgICAgLy8gMS4gSGFuZGxlIGRlc2NyaXB0b3JzOiBJZiB0aGUgdmFsdWUgaXMgYSBkZXNjcmlwdG9yIG9iamVjdCwgc3RvcmUgaXQuXG4gICAgICAgICAgICAgICAgLy8gICAgVGhlICd2YWx1ZScgcHJvcGVydHkgb2YgdGhlIGRlc2NyaXB0b3IgaXMgdGhlbiB1c2VkIGFzIHRoZSBhY3R1YWwgY29uZmlnIHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmIChOZW8uaXNPYmplY3QodmFsdWUpICYmIHZhbHVlW2lzRGVzY3JpcHRvcl0gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3Rvci5jb25maWdEZXNjcmlwdG9ycyA/Pz0ge307XG4gICAgICAgICAgICAgICAgICAgIGN0b3IuY29uZmlnRGVzY3JpcHRvcnNbYmFzZUtleV0gPSBOZW8uY2xvbmUodmFsdWUsIHRydWUpOyAvLyBEZWVwIGNsb25lIHRvIHByZXZlbnQgbXV0YXRpb25cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS52YWx1ZSAvLyBVc2UgdGhlIGRlc2NyaXB0b3IncyB2YWx1ZSBhcyB0aGUgY29uZmlnIHZhbHVlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gMi4gSGFuZGxlIHJlYWN0aXZlIHZzLiBub24tcmVhY3RpdmUgY29uZmlnczogR2VuZXJhdGUgZ2V0dGVycy9zZXR0ZXJzIGZvciByZWFjdGl2ZSBjb25maWdzLlxuICAgICAgICAgICAgICAgIGlmIChpc1JlYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjZmdba2V5XTsgICAgICAvLyBSZW1vdmUgb3JpZ2luYWwga2V5IHdpdGggdW5kZXJzY29yZVxuICAgICAgICAgICAgICAgICAgICBjZmdbYmFzZUtleV0gPSB2YWx1ZTsgLy8gVXNlIHRoZSBwb3RlbnRpYWxseSBtb2RpZmllZCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICBOZW8uY3JlYXRlQ29uZmlnKGVsZW1lbnQsIGJhc2VLZXkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoaXMgcGFydCBoYW5kbGVzIG5vbi1yZWFjdGl2ZSBjb25maWdzIChpbmNsdWRpbmcgdGhvc2UgdGhhdCB3ZXJlIGRlc2NyaXB0b3JzKVxuICAgICAgICAgICAgICAgIC8vIElmIG5vIHByb3BlcnR5IHNldHRlciBleGlzdHMsIGRlZmluZSBpdCBkaXJlY3RseSBvbiB0aGUgcHJvdG90eXBlLlxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFOZW8uaGFzUHJvcGVydHlTZXR0ZXIoZWxlbWVudCwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZSAgOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIE1lcmdlIGNvbmZpZ0Rlc2NyaXB0b3JzOiBBcHBseSBcImZpcnN0LWRlZmluZWQgd2luc1wiIHN0cmF0ZWd5LlxuICAgICAgICAgICAgLy8gSWYgYSBkZXNjcmlwdG9yIGZvciBhIGtleSBhbHJlYWR5IGV4aXN0cyAoZnJvbSBhIHBhcmVudCBjbGFzcyksIGl0IGlzIG5vdCBvdmVyd3JpdHRlbi5cbiAgICAgICAgICAgIGlmIChjdG9yLmNvbmZpZ0Rlc2NyaXB0b3JzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3Rvci5jb25maWdEZXNjcmlwdG9ycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5oYXNPd24oY29uZmlnRGVzY3JpcHRvcnMsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ0Rlc2NyaXB0b3JzW2tleV0gPSBOZW8uY2xvbmUoY3Rvci5jb25maWdEZXNjcmlwdG9yc1trZXldLCB0cnVlKSAvLyBEZWVwIGNsb25lIGZvciBpbW11dGFiaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUHJvY2VzcyBudHlwZSBhbmQgbnR5cGVDaGFpblxuICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oY2ZnLCAnbnR5cGUnKSkge1xuICAgICAgICAgICAgICAgIG50eXBlID0gY2ZnLm50eXBlO1xuXG4gICAgICAgICAgICAgICAgbnR5cGVDaGFpbi51bnNoaWZ0KG50eXBlKTtcblxuICAgICAgICAgICAgICAgIC8vIFJ1bm5pbmcgdGhlIGRvY3MgYXBwIGluc2lkZSBhIHdvcmtzcGFjZSBjYW4gcHVsbCBpbiB0aGUgc2FtZSBjbGFzc2VzIGZyb20gZGlmZmVyZW50IHJvb3RzLFxuICAgICAgICAgICAgICAgIC8vIHNvIHdlIHdhbnQgdG8gY2hlY2sgZm9yIGRpZmZlcmVudCBjbGFzcyBuYW1lcyBhcyB3ZWxsXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd24obnR5cGVNYXAsIG50eXBlKSAmJiBjZmcuY2xhc3NOYW1lICE9PSBudHlwZU1hcFtudHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBudHlwZSBjb25mbGljdCBmb3IgJyR7bnR5cGV9JyBpbnNpZGUgdGhlIGNsYXNzZXM6XFxuJHtudHlwZU1hcFtudHlwZV19XFxuJHtjZmcuY2xhc3NOYW1lfWApXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbnR5cGVNYXBbbnR5cGVdID0gY2ZnLmNsYXNzTmFtZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQcm9jZXNzIG1peGluc1xuICAgICAgICAgICAgbWl4aW5zID0gT2JqZWN0Lmhhc093bihjb25maWcsICdtaXhpbnMnKSAmJiBjb25maWcubWl4aW5zIHx8IFtdO1xuXG4gICAgICAgICAgICBpZiAoY3Rvci5vYnNlcnZhYmxlKSB7XG4gICAgICAgICAgICAgICAgbWl4aW5zLnB1c2goJ05lby5jb3JlLk9ic2VydmFibGUnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihjZmcsICdtaXhpbnMnKSAmJiBBcnJheS5pc0FycmF5KGNmZy5taXhpbnMpICYmIGNmZy5taXhpbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG1peGlucy5wdXNoKC4uLmNmZy5taXhpbnMpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtaXhpbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGFwcGx5TWl4aW5zKGN0b3IsIG1peGlucywgY2ZnKTtcblxuICAgICAgICAgICAgICAgIGlmIChOZW8ubnMoJ05lby5jb3JlLk9ic2VydmFibGUnLCBmYWxzZSwgY3Rvci5wcm90b3R5cGUubWl4aW5zKSkge1xuICAgICAgICAgICAgICAgICAgICBjdG9yLm9ic2VydmFibGUgPSB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWxldGUgY2ZnLm1peGlucztcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcubWl4aW5zO1xuXG4gICAgICAgICAgICAvLyBIaWVyYXJjaGljYWwgbWVyZ2luZyBvZiBzdGF0aWMgY29uZmlnIHZhbHVlcyBiYXNlZCBvbiBkZXNjcmlwdG9ycy5cbiAgICAgICAgICAgIC8vIFRoaXMgZW5zdXJlcyB0aGF0IHZhbHVlcyBhcmUgbWVyZ2VkIChlLmcuLCBzaGFsbG93L2RlZXApIGluc3RlYWQgb2Ygc2ltcGx5IG92ZXJ3cml0dGVuLlxuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoY2ZnKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gY29uZmlnRGVzY3JpcHRvcnNba2V5XTtcblxuICAgICAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yPy5tZXJnZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25maWdba2V5XSA9IE5lby5tZXJnZUNvbmZpZyhjb25maWdba2V5XSwgdmFsdWUsIGRlc2NyaXB0b3IubWVyZ2UpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnW2tleV0gPSB2YWx1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBBc3NpZ24gZmluYWwgcHJvY2Vzc2VkIGNvbmZpZyBhbmQgZGVzY3JpcHRvcnMgdG8gdGhlIGNsYXNzIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGN0b3IsIHtcbiAgICAgICAgICAgICAgICBjbGFzc0NvbmZpZ0FwcGxpZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlnICAgICAgICAgICAgOiBOZW8uY2xvbmUoY29uZmlnLCAgICAgICAgICAgIHRydWUpLCAvLyBEZWVwIGNsb25lIGZpbmFsIGNvbmZpZyBmb3IgaW1tdXRhYmlsaXR5XG4gICAgICAgICAgICAgICAgY29uZmlnRGVzY3JpcHRvcnMgOiBOZW8uY2xvbmUoY29uZmlnRGVzY3JpcHRvcnMsIHRydWUpLCAvLyBEZWVwIGNsb25lIGZpbmFsIGRlc2NyaXB0b3JzIGZvciBpbW11dGFiaWxpdHlcbiAgICAgICAgICAgICAgICBpc0NsYXNzICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICAgICAgbnR5cGVDaGFpblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEFwcGx5IHRvIGdsb2JhbCBuYW1lc3BhY2UgaWYgbm90IGEgc2luZ2xldG9uXG4gICAgICAgICAgICAhY29uZmlnLnNpbmdsZXRvbiAmJiB0aGlzLmFwcGx5VG9HbG9iYWxOcyhjbHMpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHByb3RvID0gY2xzLnByb3RvdHlwZSB8fCBjbHM7XG5cbiAgICAgICAgLy8gQWRkIGlzPE50eXBlPiBmbGFncyB0byB0aGUgcHJvdG90eXBlXG4gICAgICAgIG50eXBlQ2hhaW4uZm9yRWFjaChudHlwZSA9PiB7XG4gICAgICAgICAgICBwcm90b1tgaXMke05lby5jYXBpdGFsaXplKE5lby5jYW1lbChudHlwZSkpfWBdID0gdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBJZiBpdCdzIGEgc2luZ2xldG9uLCBjcmVhdGUgYW5kIGFwcGx5IHRoZSBpbnN0YW5jZSB0byB0aGUgZ2xvYmFsIG5hbWVzcGFjZVxuICAgICAgICBpZiAocHJvdG8uc2luZ2xldG9uKSB7XG4gICAgICAgICAgICBjbHMgPSBOZW8uY3JlYXRlKGNscyk7XG4gICAgICAgICAgICBOZW8uYXBwbHlUb0dsb2JhbE5zKGNscylcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBjbGFzcyBoaWVyYXJjaHkgaW5mb3JtYXRpb24gdG8gdGhlIG1hbmFnZXIgb3IgYSB0ZW1wb3JhcnkgbWFwXG4gICAgICAgIGhpZXJhcmNoeUluZm8gPSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgICAgICA6IHByb3RvLmNsYXNzTmFtZSxcbiAgICAgICAgICAgIG1vZHVsZSAgICAgICAgIDogY2xzLFxuICAgICAgICAgICAgbnR5cGUgICAgICAgICAgOiBPYmplY3QuaGFzT3duKHByb3RvLCAnbnR5cGUnKSA/IHByb3RvLm50eXBlIDogbnVsbCxcbiAgICAgICAgICAgIHBhcmVudENsYXNzTmFtZTogcHJvdG8uX19wcm90b19fPy5jbGFzc05hbWUgfHwgbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChOZW8ubWFuYWdlcj8uQ2xhc3NIaWVyYXJjaHkpIHtcbiAgICAgICAgICAgIE5lby5tYW5hZ2VyLkNsYXNzSGllcmFyY2h5LmFkZChoaWVyYXJjaHlJbmZvKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgTmVvLmNsYXNzSGllcmFyY2h5TWFwID8/PSB7fTtcbiAgICAgICAgICAgIE5lby5jbGFzc0hpZXJhcmNoeU1hcFtwcm90by5jbGFzc05hbWVdID0gaGllcmFyY2h5SW5mb1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNsc1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IGl0ZW1cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgdHlwZU9mKGl0ZW0pIHtcbiAgICAgICAgLy8gUmV0dXJuIG51bGwgZm9yIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgIGlmIChpdGVtID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHlwZURldGVjdG9yW3R5cGVvZiBpdGVtXT8uKGl0ZW0pIHx8IGl0ZW0uY29uc3RydWN0b3I/Lm5hbWVcbiAgICB9XG59LCBOZW8pO1xuXG4vKipcbiAqIExpc3Qgb2YgY2xhc3MgcHJvcGVydGllcyB3aGljaCBhcmUgbm90IHN1cHBvc2VkIHRvIGdldCBtaXhlZCBpbnRvIG90aGVyIGNsYXNzZXNcbiAqIEB0eXBlIHtzdHJpbmdbXX1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGlnbm9yZU1peGluID0gW1xuICAgICdfbmFtZScsXG4gICAgJ2NsYXNzQ29uZmlnQXBwbGllZCcsXG4gICAgJ2NsYXNzTmFtZScsXG4gICAgJ2NvbnN0cnVjdG9yJyxcbiAgICAnaWQnLFxuICAgICdpc0NsYXNzJyxcbiAgICAnbWl4aW4nLFxuICAgICdudHlwZScsXG4gICAgJ29ic2VydmFibGUnXG5dLFxuXG4gICAgY2hhcnNSZWdleCAgICAgICAgID0gL1xcZCsvZyxcbiAgICBleHRyYWN0QXJyYXlzUmVnZXggPSAvXihcXHcrKVxccyooKD86XFxbXFxzKlxcZCtcXHMqXFxdXFxzKikqKSQvO1xuXG4vKipcbiAqIEBwYXJhbSB7TmVvLmNvcmUuQmFzZX0gY2xzXG4gKiBAcGFyYW0ge0FycmF5fSAgICAgICAgIG1peGluc1xuICogQHBhcmFtIHtPYmplY3R9ICAgICAgICBjbGFzc0NvbmZpZ1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYXBwbHlNaXhpbnMoY2xzLCBtaXhpbnMsIGNsYXNzQ29uZmlnKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG1peGlucykpIHtcbiAgICAgICAgbWl4aW5zID0gW21peGluc107XG4gICAgfVxuXG4gICAgbGV0IGkgICAgICAgICAgICA9IDAsXG4gICAgICAgIGxlbiAgICAgICAgICA9IG1peGlucy5sZW5ndGgsXG4gICAgICAgIG1peGluQ2xhc3NlcyA9IHt9LFxuICAgICAgICBtaXhpbiwgbWl4aW5DbHMsIG1peGluUHJvdG87XG5cbiAgICBmb3IgKDtpIDwgbGVuO2krKykge1xuICAgICAgICBtaXhpbiA9IG1peGluc1tpXTtcblxuICAgICAgICBpZiAobWl4aW4uaXNDbGFzcykge1xuICAgICAgICAgICAgbWl4aW5Qcm90byA9IG1peGluLnByb3RvdHlwZTtcbiAgICAgICAgICAgIG1peGluQ2xzICAgPSBOZW8ubnMobWl4aW5Qcm90by5jbGFzc05hbWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWV4aXN0cyhtaXhpbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRpbmcgdG8gbWl4aW4gYW4gdW5kZWZpbmVkIGNsYXNzOiAnICsgbWl4aW4gKyAnLCAnICsgY2xzLnByb3RvdHlwZS5jbGFzc05hbWUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1peGluQ2xzICAgPSBOZW8ubnMobWl4aW4pO1xuICAgICAgICAgICAgbWl4aW5Qcm90byA9IG1peGluQ2xzLnByb3RvdHlwZVxuICAgICAgICB9XG5cbiAgICAgICAgbWl4aW5Qcm90by5jbGFzc05hbWUuc3BsaXQoJy4nKS5yZWR1Y2UobWl4UmVkdWNlKG1peGluQ2xzKSwgbWl4aW5DbGFzc2VzKTtcblxuICAgICAgICBPYmplY3QuZW50cmllcyhPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhtaXhpblByb3RvKSkuZm9yRWFjaChtaXhpblByb3BlcnR5KGNscy5wcm90b3R5cGUsIG1peGluUHJvdG8sIGNsYXNzQ29uZmlnKSlcbiAgICB9XG5cbiAgICBjbHMucHJvdG90eXBlLm1peGlucyA9IG1peGluQ2xhc3NlcyAvLyB0b2RvOiB3ZSBzaG91bGQgZG8gYSBkZWVwIG1lcmdlXG59XG5cbi8qKlxuICogQHBhcmFtIHtCb29sZWFufSBjcmVhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSAgY3VycmVudFxuICogQHBhcmFtIHtPYmplY3R9ICBwcmV2XG4gKiBAcmV0dXJucyB7T2JqZWN0fHVuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXJyYXlOcyhjcmVhdGUsIGN1cnJlbnQsIHByZXYpIHtcbiAgICBsZXQgYXJyRGV0YWlscyA9IHBhcnNlQXJyYXlGcm9tU3RyaW5nKGN1cnJlbnQpLFxuICAgICAgICBpICAgICAgICAgID0gMSxcbiAgICAgICAgbGVuICAgICAgICA9IGFyckRldGFpbHMubGVuZ3RoLFxuICAgICAgICBhcnJJdGVtLCBhcnJSb290O1xuXG4gICAgaWYgKGNyZWF0ZSkge1xuICAgICAgICBwcmV2W2FyckRldGFpbHNbMF1dID0gYXJyUm9vdCA9IHByZXZbYXJyRGV0YWlsc1swXV0gfHwgW11cbiAgICB9IGVsc2Uge1xuICAgICAgICBhcnJSb290ID0gcHJldlthcnJEZXRhaWxzWzBdXVxuICAgIH1cblxuICAgIGlmICghYXJyUm9vdCkgcmV0dXJuO1xuXG4gICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBhcnJJdGVtID0gcGFyc2VJbnQoYXJyRGV0YWlsc1tpXSk7XG5cbiAgICAgICAgaWYgKGNyZWF0ZSkge1xuICAgICAgICAgICAgYXJyUm9vdFthcnJJdGVtXSA9IGFyclJvb3RbYXJySXRlbV0gfHwge31cbiAgICAgICAgfVxuXG4gICAgICAgIGFyclJvb3QgPSBhcnJSb290W2Fyckl0ZW1dXG4gICAgfVxuXG4gICAgcmV0dXJuIGFyclJvb3Rcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGNsYXNzIG5hbWUgZXhpc3RzIGluc2lkZSB0aGUgTmVvIG9yIGFwcCBuYW1lc3BhY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXhpc3RzKGNsYXNzTmFtZSkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAhIWNsYXNzTmFtZS5zcGxpdCgnLicpLnJlZHVjZSgocHJldiwgY3VycmVudCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHByZXZbY3VycmVudF1cbiAgICAgICAgfSwgZ2xvYmFsVGhpcylcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7TmVvLmNvcmUuQmFzZX0gcHJvdG9cbiAqIEBwYXJhbSB7TmVvLmNvcmUuQmFzZX0gbWl4aW5Qcm90b1xuICogQHBhcmFtIHtPYmplY3R9ICAgICAgICBjbGFzc0NvbmZpZ1xuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWl4aW5Qcm9wZXJ0eShwcm90bywgbWl4aW5Qcm90bywgY2xhc3NDb25maWcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oW2tleSwgZGVzY3JpcHRvcl0pIHtcbiAgICAgICAgaWYgKGlnbm9yZU1peGluLmluY2x1ZGVzKGtleSkpIHJldHVybjtcblxuICAgICAgICAvLyBNaXhpbnMgbXVzdCBub3Qgb3ZlcnJpZGUgZXhpc3RpbmcgY2xhc3MgcHJvcGVydGllcyB3aXRoIGEgc2V0dGVyXG4gICAgICAgIGlmIChOZW8uaGFzUHJvcGVydHlTZXR0ZXIocHJvdG8sIGtleSkpIHJldHVybjtcblxuICAgICAgICAvLyBSZWFjdGl2ZSBuZW8gY29uZmlncywgb3IgcHVibGljIGNsYXNzIGZpZWxkcyBkZWZpbmVkIHZpYSBnZXQoKSBBTkQgc2V0KClcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IuZ2V0ICYmIGRlc2NyaXB0b3Iuc2V0KSB7XG4gICAgICAgICAgICBOZW8uY3JlYXRlQ29uZmlnKHByb3RvLCBrZXkpO1xuXG4gICAgICAgICAgICBjb25zdCBtaXhpbkNsYXNzQ29uZmlnID0gbWl4aW5Qcm90by5jb25zdHJ1Y3Rvci5jb25maWc7XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKG1peGluQ2xhc3NDb25maWcsIGtleSkpIHtcbiAgICAgICAgICAgICAgICBjbGFzc0NvbmZpZ1trZXldID0gbWl4aW5DbGFzc0NvbmZpZ1trZXldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm90b1trZXldPy5fZnJvbSkge1xuICAgICAgICAgICAgaWYgKG1peGluUHJvdG8uY2xhc3NOYW1lID09PSBwcm90b1trZXldLl9mcm9tKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdNaXhpbiBzZXQgbXVsdGlwbGUgdGltZXMgb3IgYWxyZWFkeSBkZWZpbmVkIG9uIGEgQmFzZSBDbGFzcycsIHByb3RvLmNsYXNzTmFtZSwgbWl4aW5Qcm90by5jbGFzc05hbWUsIGtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBgJHtwcm90by5jbGFzc05hbWV9OiBNdWx0aXBsZSBtaXhpbnMgZGVmaW5pbmcgc2FtZSBwcm9wZXJ0eSAoJHttaXhpblByb3RvLmNsYXNzTmFtZX0sICR7cHJvdG9ba2V5XS5fZnJvbX0pID0+ICR7a2V5fWBcbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIHByb3RvW2tleV0gPSBtaXhpblByb3RvW2tleV07XG5cbiAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90bywga2V5KS5fZnJvbSA9IG1peGluUHJvdG8uY2xhc3NOYW1lO1xuXG4gICAgICAgIGlmICh0eXBlb2YgcHJvdG9ba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcHJvdG9ba2V5XS5fbmFtZSA9IGtleVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSBtaXhpbkNsc1xuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWl4UmVkdWNlKG1peGluQ2xzKSB7XG4gICAgcmV0dXJuIChwcmV2LCBjdXJyZW50LCBpZHgsIGFycikgPT4ge1xuICAgICAgICByZXR1cm4gcHJldltjdXJyZW50XSA9IGlkeCAhPT0gYXJyLmxlbmd0aCAtMSA/IHByZXZbY3VycmVudF0gfHwge30gOiBtaXhpbkNsc1xuICAgIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwYXJzZUFycmF5RnJvbVN0cmluZyhzdHIpIHtcbiAgICByZXR1cm4gKGV4dHJhY3RBcnJheXNSZWdleC5leGVjKHN0cikgfHwgW251bGxdKS5zbGljZSgxKS5yZWR1Y2UoXG4gICAgICAgIChmdW4sIGFyZ3MpID0+IFtmdW5dLmNvbmNhdChhcmdzLm1hdGNoKGNoYXJzUmVnZXgpKVxuICAgIClcbn1cblxuTmVvLmNvbmZpZyA/Pz0ge307XG5cbk5lby5hc3NpZ25EZWZhdWx0cyhOZW8uY29uZmlnLCBEZWZhdWx0Q29uZmlnKTtcblxuZXhwb3J0IGRlZmF1bHQgTmVvO1xuIiwiaW1wb3J0IEJhc2UgICAgICAgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQgRmlsdGVyICAgICBmcm9tICcuL0ZpbHRlci5tanMnO1xuaW1wb3J0IExvZ2dlciAgICAgZnJvbSAnLi4vdXRpbC9Mb2dnZXIubWpzJztcbmltcG9ydCBOZW9BcnJheSAgIGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBPYnNlcnZhYmxlIGZyb20gJy4uL2NvcmUvT2JzZXJ2YWJsZS5tanMnO1xuaW1wb3J0IFNvcnRlciAgICAgZnJvbSAnLi9Tb3J0ZXIubWpzJztcblxuY29uc3QgY291bnRNdXRhdGlvbnMgICA9IFN5bWJvbCgnY291bnRNdXRhdGlvbnMnKSxcbiAgICAgIGlzRmlsdGVyZWQgICAgICAgPSBTeW1ib2woJ2lzRmlsdGVyZWQnKSxcbiAgICAgIGlzU29ydGVkICAgICAgICAgPSBTeW1ib2woJ2lzU29ydGVkJyksXG4gICAgICBzaWxlbnRVcGRhdGVNb2RlID0gU3ltYm9sKCdzaWxlbnRVcGRhdGVNb2RlJyksXG4gICAgICB0b0FkZEFycmF5ICAgICAgID0gU3ltYm9sKCd0b0FkZEFycmF5JyksXG4gICAgICB0b1JlbW92ZUFycmF5ICAgID0gU3ltYm9sKCd0b1JlbW92ZUFycmF5JyksXG4gICAgICB1cGRhdGluZ0luZGV4ICAgID0gU3ltYm9sKCd1cGRhdGluZ0luZGV4Jyk7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jb2xsZWN0aW9uLkJhc2VcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqIEBtaXhlcyBOZW8uY29yZS5PYnNlcnZhYmxlXG4gKi9cbmNsYXNzIENvbGxlY3Rpb24gZXh0ZW5kcyBCYXNlIHtcbiAgICAvKipcbiAgICAgKiBUcnVlIGF1dG9tYXRpY2FsbHkgYXBwbGllcyB0aGUgY29yZS5PYnNlcnZhYmxlIG1peGluXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gb2JzZXJ2YWJsZT10cnVlXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBvYnNlcnZhYmxlID0gdHJ1ZVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29sbGVjdGlvbi5CYXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29sbGVjdGlvbi5CYXNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2NvbGxlY3Rpb24nXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnY29sbGVjdGlvbicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIGZpbHRlcmluZyB0aGUgY29sbGVjdGlvbiBmb3IgdGhlIGZpcnN0IHRpbWUsIGFsbEl0ZW1zIHdpbGwgYmVjb21lIGEgbmV3IGNvbGxlY3Rpb24gZm9yIHRoZSB1bmZpbHRlcmVkXG4gICAgICAgICAqIHN0YXRlLCB1c2luZyB0aGlzIGlkIGFzIHRoZSBzb3VyY2VDb2xsZWN0aW9uSWRcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbGxlY3Rpb24uQmFzZXxudWxsfSBhbGxJdGVtcz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGFsbEl0ZW1zOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSB0byBzb3J0IHRoZSBjb2xsZWN0aW9uIGl0ZW1zIHdoZW4gYWRkaW5nIC8gaW5zZXJ0aW5nIG5ldyBvbmVzXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGF1dG9Tb3J0PXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9Tb3J0OiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcmVzIHRoZSBpdGVtcy5sZW5ndGggb2YgdGhlIGl0ZW1zIGFycmF5IGluIHVzZVxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGNvdW50Xz0wXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgY291bnRfOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogVXNlICdwcmltaXRpdmUnIGZvciBkZWZhdWx0IGZpbHRlcnMsIHVzZSAnYWR2YW5jZWQnIGZvciBmaWx0ZXJzIHVzaW5nIGEgZmlsdGVyQnkgbWV0aG9kXG4gICAgICAgICAqIHdoaWNoIG5lZWQgdG8gaXRlcmF0ZSBvdmVyIG90aGVyIGNvbGxlY3Rpb24gaXRlbXNcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBmaWx0ZXJNb2RlPSdwcmltaXRpdmUnXG4gICAgICAgICAqL1xuICAgICAgICBmaWx0ZXJNb2RlOiAncHJpbWl0aXZlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIEFycmF5IGNvbnRhaW5pbmcgTmVvLnV0aWwuRmlsdGVyIGNvbmZpZyBvYmplY3RzIG9yIGluc3RhbmNlc1xuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheX0gZmlsdGVyc189W11cbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBmaWx0ZXJzXzogW10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3RbXXxudWxsfSBpdGVtc189bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1zXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB1bmlxdWUoISkga2V5IHByb3BlcnR5IG9mIGVhY2ggY29sbGVjdGlvbiBpdGVtXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30ga2V5UHJvcGVydHk9J2lkJ1xuICAgICAgICAgKi9cbiAgICAgICAga2V5UHJvcGVydHk6ICdpZCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRpbmcgbmV3IGl0ZW1zIHdpdGhvdXQgYW4gaWQgKGtleVByb3BlcnR5KSB3aWxsIHVzZSBhIG5lZ2F0aXZlIGluZGV4LCB3aGljaCB3aWxsIGRlY3JlYXNlIGJ5IC0xXG4gICAgICAgICAqIGZvciBlYWNoIG5ldyBpdGVtXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0ga2V5UHJvcGVydHlJbmRleD0tMVxuICAgICAgICAgKi9cbiAgICAgICAga2V5UHJvcGVydHlJbmRleDogLTEsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIG1hcCBjb250YWluaW5nIHRoZSBrZXkgJiByZWZlcmVuY2Ugb2YgZWFjaCBjb2xsZWN0aW9uIGl0ZW0gZm9yIGZhc3RlciBhY2Nlc3NcbiAgICAgICAgICogQG1lbWJlciB7TWFwfSBtYXBfPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIG1hcF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBpbnRlcm5hbCBBcnJheSBvZiB0aGUgc29ydCBkaXJlY3Rpb25zIGZvciBmYXN0ZXIgYWNjZXNzXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5fSBzb3J0RGlyZWN0aW9ucz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNvcnREaXJlY3Rpb25zOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gaW50ZXJuYWwgQXJyYXkgb2YgdGhlIHNvcnQgcHJvcGVydGllcyBmb3IgZmFzdGVyIGFjY2Vzc1xuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheX0gc29ydFByb3BlcnRpZXM9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzb3J0UHJvcGVydGllczogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIEFycmF5IGNvbnRhaW5pbmcgTmVvLnV0aWwuU29ydGVyIGNvbmZpZyBvYmplY3RzIG9yIGluc3RhbmNlc1xuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheX0gc29ydGVyc189W11cbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzb3J0ZXJzXzogW10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaWQgb2YgYW5vdGhlciBjb2xsZWN0aW9uIGluc3RhbmNlIHRvIHVzZSBhcyB0aGlzIGRhdGEgc291cmNlXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBzb3VyY2VJZF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHNvdXJjZUlkXzogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgc3ltYm9sQ29uZmlnID0ge2VudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZX07XG5cbiAgICAgICAgbWUuaXRlbXMgPSBtZS5pdGVtcyB8fCBbXTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhtZSwge1xuICAgICAgICAgICAgW2NvdW50TXV0YXRpb25zXSAgOiB7Li4uc3ltYm9sQ29uZmlnLCB2YWx1ZTogZmFsc2V9LFxuICAgICAgICAgICAgW2lzRmlsdGVyZWRdICAgICAgOiB7Li4uc3ltYm9sQ29uZmlnLCB2YWx1ZTogZmFsc2V9LFxuICAgICAgICAgICAgW2lzU29ydGVkXSAgICAgICAgOiB7Li4uc3ltYm9sQ29uZmlnLCB2YWx1ZTogZmFsc2V9LFxuICAgICAgICAgICAgW3NpbGVudFVwZGF0ZU1vZGVdOiB7Li4uc3ltYm9sQ29uZmlnLCB2YWx1ZTogZmFsc2V9LFxuICAgICAgICAgICAgW3RvQWRkQXJyYXldICAgICAgOiB7Li4uc3ltYm9sQ29uZmlnLCB2YWx1ZTogW119LFxuICAgICAgICAgICAgW3RvUmVtb3ZlQXJyYXldICAgOiB7Li4uc3ltYm9sQ29uZmlnLCB2YWx1ZTogW119LFxuICAgICAgICAgICAgW3VwZGF0aW5nSW5kZXhdICAgOiB7Li4uc3ltYm9sQ29uZmlnLCB2YWx1ZTogMH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG1lLmF1dG9Tb3J0ICYmIG1lLl9zb3J0ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG1lLmRvU29ydCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIG9uZSBvciBtb3JlIGl0ZW1zIHRvIHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gaXRlbSBUaGUgaXRlbShzKSB0byBhZGRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0W119IGFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIGFkZGVkIGl0ZW1zXG4gICAgICovXG4gICAgYWRkKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BsaWNlKG51bGwsIG51bGwsIGl0ZW0pLmFkZGVkSXRlbXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGZpbHRlcnMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEZpbHRlcnModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgdmFsdWUuZm9yRWFjaChmaWx0ZXIgPT4ge1xuICAgICAgICAgICAgaWYgKGZpbHRlci5saXN0ZW5lckFwcGxpZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyLm9uKCdjaGFuZ2UnLCBtZS5vbkZpbHRlckNoYW5nZSwgbWUpO1xuICAgICAgICAgICAgICAgIGZpbHRlci5saXN0ZW5lckFwcGxpZWQgPSB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9sZFZhbHVlICYmIG1lLmZpbHRlcigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBpdGVtcyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SXRlbXModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHtrZXlQcm9wZXJ0eX0gPSBtZSxcbiAgICAgICAgICAgICAgICBpICAgICAgICAgICAgID0gMCxcbiAgICAgICAgICAgICAgICBsZW4gICAgICAgICAgID0gdmFsdWUubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGl0ZW07XG5cbiAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpdGVtID0gdmFsdWVbaV07XG4gICAgICAgICAgICAgICAgbWUubWFwLnNldChpdGVtW2tleVByb3BlcnR5XSwgaXRlbSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUuY291bnQgPSBsZW5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc29ydGVycyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U29ydGVycyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5hcHBseVNvcnRlckNvbmZpZ3MoKTtcblxuICAgICAgICB2YWx1ZS5mb3JFYWNoKHNvcnRlciA9PiB7XG4gICAgICAgICAgICBpZiAoc29ydGVyLmxpc3RlbmVyQXBwbGllZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBzb3J0ZXIub24oJ2NoYW5nZScsIG1lLm9uU29ydGVyQ2hhbmdlLCBtZSk7XG4gICAgICAgICAgICAgICAgc29ydGVyLmxpc3RlbmVyQXBwbGllZCA9IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgb2xkVmFsdWUgJiYgbWUuYXV0b1NvcnQgJiYgbWUuZG9Tb3J0KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNvdXJjZUlkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U291cmNlSWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgc291cmNlID0gTmVvLmdldCh2YWx1ZSk7XG5cbiAgICAgICAgICAgIG1lLl9pdGVtcyA9IFsuLi5zb3VyY2UuX2l0ZW1zXTtcbiAgICAgICAgICAgIG1lLm1hcCAgICA9IG5ldyBNYXAoc291cmNlLm1hcCk7IC8vIGNyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgb3JpZ2luYWwgbWFwXG5cbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVyc0NvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICBtdXRhdGU6IG1lLm9uTXV0YXRlLFxuICAgICAgICAgICAgICAgIHNjb3BlIDogbWVcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHNvdXJjZS5vbihsaXN0ZW5lcnNDb25maWcpO1xuXG4gICAgICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSBOZW8uZ2V0KG9sZFZhbHVlKTtcbiAgICAgICAgICAgICAgICBzb3VyY2UudW4obGlzdGVuZXJzQ29uZmlnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2F2ZXMgdGhlIHNvcnQgcHJvcGVydHkgJiBkaXJlY3Rpb24gbXVsdGlwbGllciBvZiBlYWNoIHNvcnRlciBpbnNpZGUgMiBhcnJheXMgZm9yIGZhc3RlciBhY2Nlc3Mgd2hlbiBzb3J0aW5nXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFwcGx5U29ydGVyQ29uZmlncygpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5zb3J0RGlyZWN0aW9ucyA9IFtdO1xuICAgICAgICBtZS5zb3J0UHJvcGVydGllcyA9IFtdO1xuXG4gICAgICAgIG1lLnNvcnRlcnMuZm9yRWFjaChzb3J0ZXIgPT4ge1xuICAgICAgICAgICAgbWUuc29ydERpcmVjdGlvbnMucHVzaChzb3J0ZXIuZGlyZWN0aW9uTXVsdGlwbGllcik7XG4gICAgICAgICAgICBtZS5zb3J0UHJvcGVydGllcy5wdXNoKHNvcnRlci5wcm9wZXJ0eSlcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldEZpbHRlcnModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgPyBbdmFsdWVdIDogW11cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBsZW4gPSBvbGRWYWx1ZSAmJiBvbGRWYWx1ZS5sZW5ndGggfHwgMCxcbiAgICAgICAgICAgIGhhc01hdGNoLCBpO1xuXG4gICAgICAgIHZhbHVlLmZvckVhY2goKGtleSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChvbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGhhc01hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaSAgICAgICAgPSAwO1xuXG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2xkVmFsdWVbaV0gPT09IGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWVbaV0uc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjoga2V5Lm9wZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBrZXkucHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgICA6IGtleS52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc01hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZVtpXS5vcGVyYXRvciA9PT0gKGtleS5vcGVyYXRvciB8fCAnPT09JykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlW2ldLnByb3BlcnR5ID09PSBrZXkucHJvcGVydHkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlW2ldLnZhbHVlICAgID09PSBrZXkudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNNYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWhhc01hdGNoKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVbaW5kZXhdID0gTmVvLmNyZWF0ZShGaWx0ZXIsIGtleSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWVbaW5kZXhdID0gb2xkVmFsdWVbaV07XG4gICAgICAgICAgICAgICAgb2xkVmFsdWUuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIGxlbi0tXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgb2xkVmFsdWUuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgIGtleS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtNYXB8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge01hcHxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRNYXAodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhdmFsdWUgPyBuZXcgTWFwKCkgOiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0U29ydGVycyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSA/IFt2YWx1ZV0gOiBbXVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGxlbiA9IG9sZFZhbHVlPy5sZW5ndGggfHwgMCxcbiAgICAgICAgICAgIGhhc01hdGNoLCBpO1xuXG4gICAgICAgIHZhbHVlLmZvckVhY2goKGtleSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChvbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGhhc01hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaSAgICAgICAgPSAwO1xuXG4gICAgICAgICAgICAgICAgbGV0IHtkaXJlY3Rpb24sIHByb3BlcnR5fSA9IGtleTtcblxuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZFZhbHVlW2ldID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlW2ldLnNldCh7ZGlyZWN0aW9uLCBwcm9wZXJ0eX0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNNYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9sZFZhbHVlW2ldLnByb3BlcnR5ID09PSBwcm9wZXJ0eSAmJiBvbGRWYWx1ZVtpXS5kaXJlY3Rpb24gPT09IGRpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFoYXNNYXRjaCkge1xuICAgICAgICAgICAgICAgIHZhbHVlW2luZGV4XSA9IE5lby5jcmVhdGUoU29ydGVyLCBrZXkpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlW2luZGV4XSA9IG9sZFZhbHVlW2ldO1xuICAgICAgICAgICAgICAgIG9sZFZhbHVlLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICBsZW4tLVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBvbGRWYWx1ZT8uZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAga2V5LmRlc3Ryb3koKVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb3B0c1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjYWNoZVVwZGF0ZShvcHRzKSB7XG4gICAgICAgIC8vIGRpc2FibGVkIGZvciBub3dcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2NhY2hlVXBkYXRlJywgb3B0cywgdGhpc1t0b0FkZEFycmF5XSk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7a2V5UHJvcGVydHl9ID0gbWUsXG4gICAgICAgICAgICBpbmRleCwgdG9BZGRNYXAsIHRvUmVtb3ZlTWFwO1xuXG4gICAgICAgIGlmICghbWVbc2lsZW50VXBkYXRlTW9kZV0pIHtcbiAgICAgICAgICAgIHRvQWRkTWFwICAgID0gbWVbdG9BZGRBcnJheV0gICAubWFwKGUgPT4gZVtrZXlQcm9wZXJ0eV0pO1xuICAgICAgICAgICAgdG9SZW1vdmVNYXAgPSBtZVt0b1JlbW92ZUFycmF5XS5tYXAoZSA9PiBlW2tleVByb3BlcnR5XSk7XG5cbiAgICAgICAgICAgIG9wdHMuYWRkZWRJdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9IHRvUmVtb3ZlTWFwLmluZGV4T2YoaXRlbVtrZXlQcm9wZXJ0eV0pID4gLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lW3RvUmVtb3ZlQXJyYXldLnNwbGljZShpbmRleCwgMSlcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRvQWRkTWFwLmluZGV4T2YoaXRlbVtrZXlQcm9wZXJ0eV0pIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBtZVt0b0FkZEFycmF5XS5wdXNoKGl0ZW0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG9wdHMucmVtb3ZlZEl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID0gdG9BZGRNYXAuaW5kZXhPZihpdGVtW2tleVByb3BlcnR5XSkgPiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVbdG9BZGRBcnJheV0uc3BsaWNlKGluZGV4LCAxKVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG9SZW1vdmVNYXAuaW5kZXhPZihpdGVtW2tleVByb3BlcnR5XSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lW3RvUmVtb3ZlQXJyYXldLnB1c2goaXRlbSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgaXRlbXMgYW5kIGNsZWFycyB0aGUgbWFwXG4gICAgICovXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuc3BsaWNlKDAsIHRoaXMuY291bnQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGFsbCBjdXJyZW50IGZpbHRlcnMgYW5kIG9wdGlvbmFsbHkgcmVzdG9yZXMgdGhlIG9yaWdpbmFsIG9uZXMgaW4gY2FzZSB0aGV5IGV4aXN0ZWQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmVzdG9yZU9yaWdpbmFsRmlsdGVycz1mYWxzZV1cbiAgICAgKi9cbiAgICBjbGVhckZpbHRlcnMocmVzdG9yZU9yaWdpbmFsRmlsdGVycykge1xuICAgICAgICB0aGlzLmZpbHRlcnMgPSByZXN0b3JlT3JpZ2luYWxGaWx0ZXJzID8gTmVvLmNsb25lKHRoaXMub3JpZ2luYWxDb25maWcuZmlsdGVycywgdHJ1ZSwgdHJ1ZSkgOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgaXRlbXMgYW5kIGNsZWFycyB0aGUgbWFwLCB3aXRob3V0IGZpcmluZyBhIG11dGF0ZSBldmVudFxuICAgICAqL1xuICAgIGNsZWFyU2lsZW50KCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLl9pdGVtcy5zcGxpY2UoMCwgbWUuY291bnQpO1xuICAgICAgICBtZS5tYXAuY2xlYXIoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgY3VycmVudCBzb3J0ZXJzIGFuZCBvcHRpb25hbGx5IHJlc3RvcmVzIHRoZSBvcmlnaW5hbCBvbmVzIGluIGNhc2UgdGhleSBleGlzdGVkLlxuICAgICAqIFdpdGhvdXQgcmVzdG9yZUluaXRpYWxTdGF0ZSBhcyB0cnVlIHRoaXMgd2lsbCBub3QgYWZmZWN0IHRoZSBjdXJyZW50IHNvcnRpbmcgb2YgdGhpcyBjb2xsZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Jlc3RvcmVPcmlnaW5hbFNvcnRlcnM9ZmFsc2VdXG4gICAgICovXG4gICAgY2xlYXJTb3J0ZXJzKHJlc3RvcmVPcmlnaW5hbFNvcnRlcnMpIHtcbiAgICAgICAgdGhpcy5zb3J0ZXJzID0gcmVzdG9yZU9yaWdpbmFsU29ydGVycyA/IE5lby5jbG9uZSh0aGlzLm9yaWdpbmFsQ29uZmlnLnNvcnRlcnMsIHRydWUsIHRydWUpIDogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOZW8uY29sbGVjdGlvbi5CYXNlfSBUaGUgY2xvbmVkIGNvbGxlY3Rpb25cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnICA9IE5lby5jbG9uZShtZS5vcmlnaW5hbENvbmZpZywgdHJ1ZSksXG4gICAgICAgICAgICBmaWx0ZXJzID0gbWUuX2ZpbHRlcnMgfHwgW10sXG4gICAgICAgICAgICBzb3J0ZXJzID0gbWUuX3NvcnRlcnMgfHwgW107XG5cbiAgICAgICAgLy8gRW5zdXJlIHRoZSBrZXlQcm9wZXJ0eSBkb2VzIG5vdCBnZXQgbG9zdC5cbiAgICAgICAgY29uZmlnLmtleVByb3BlcnR5ID0gbWUua2V5UHJvcGVydHk7XG5cbiAgICAgICAgZGVsZXRlIGNvbmZpZy5pZDtcbiAgICAgICAgZGVsZXRlIGNvbmZpZy5maWx0ZXJzO1xuICAgICAgICBkZWxldGUgY29uZmlnLml0ZW1zO1xuICAgICAgICBkZWxldGUgY29uZmlnLnNvcnRlcnM7XG5cbiAgICAgICAgaWYgKG1lLl9pdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25maWcuaXRlbXMgID0gWy4uLm1lLl9pdGVtc107XG4gICAgICAgICAgICBjb25maWcuY291bnQgPSBjb25maWcuaXRlbXMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnLmZpbHRlcnMgPSBbXTtcbiAgICAgICAgY29uZmlnLnNvcnRlcnMgPSBbXTtcblxuICAgICAgICAvLyB0b2RvOiBmaWx0ZXJzICYgc29ydGVycyBzaG91bGQgcHVzaCB0aGVpciBjdXJyZW50IHN0YXRlIGFuZCBub3QgdGhlIG9yaWdpbmFsIG9uZVxuXG4gICAgICAgIGZpbHRlcnMuZm9yRWFjaChmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICAgICAgICAgIGNvbmZpZy5maWx0ZXJzLnB1c2goZmlsdGVyLm9yaWdpbmFsQ29uZmlnKVxuICAgICAgICB9KTtcblxuICAgICAgICBzb3J0ZXJzLmZvckVhY2goZnVuY3Rpb24oc29ydGVyKSB7XG4gICAgICAgICAgICBjb25maWcuc29ydGVycy5wdXNoKHNvcnRlci5vcmlnaW5hbENvbmZpZylcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIE5lby5jcmVhdGUoQ29sbGVjdGlvbiwgY29uZmlnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgbWFwICYgaXRlbXMgYXJyYXkgYmVmb3JlIHRoZSBzdXBlciBjYWxsXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5faXRlbXMuc3BsaWNlKDAsIG1lLl9pdGVtcy5sZW5ndGgpO1xuICAgICAgICBtZS5tYXAuY2xlYXIoKTtcblxuICAgICAgICBzdXBlci5kZXN0cm95KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGl0ZW1zPXRoaXMuX2l0ZW1zXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaWxlbnQ9ZmFsc2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZG9Tb3J0KGl0ZW1zPXRoaXMuX2l0ZW1zLCBzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHByZXZpb3VzSXRlbXMgICAgID0gWy4uLml0ZW1zXSxcbiAgICAgICAgICAgIHtzb3J0ZXJzLCBzb3J0RGlyZWN0aW9ucywgc29ydFByb3BlcnRpZXN9ID0gbWUsXG4gICAgICAgICAgICBjb3VudFNvcnRlcnMgICAgICA9IHNvcnRQcm9wZXJ0aWVzLmxlbmd0aCB8fCAwLFxuICAgICAgICAgICAgaGFzU29ydEJ5TWV0aG9kICAgPSBmYWxzZSxcbiAgICAgICAgICAgIGhhc1RyYW5zZm9ybVZhbHVlID0gZmFsc2UsXG4gICAgICAgICAgICBpLCBtYXBwZWRJdGVtcywgb2JqLCBzb3J0ZXIsIHNvcnRQcm9wZXJ0eSwgc29ydFZhbHVlO1xuXG4gICAgICAgIGlmIChjb3VudFNvcnRlcnMgPiAwKSB7XG4gICAgICAgICAgICBzb3J0ZXJzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5LnNvcnRCeSkge1xuICAgICAgICAgICAgICAgICAgICBoYXNTb3J0QnlNZXRob2QgPSB0cnVlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGtleS51c2VUcmFuc2Zvcm1WYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBoYXNUcmFuc2Zvcm1WYWx1ZSA9IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGhhc1NvcnRCeU1ldGhvZCkge1xuICAgICAgICAgICAgICAgIG1lLl9pdGVtcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGkgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgY291bnRTb3J0ZXJzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRlciAgICA9IHNvcnRlcnNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3J0VmFsdWUgPSBzb3J0ZXJbc29ydGVyLnNvcnRCeSA/ICdzb3J0QnknIDogJ2RlZmF1bHRTb3J0QnknXShhLCBiKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvcnRWYWx1ZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzb3J0VmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc1RyYW5zZm9ybVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvcnQjU29ydGluZ193aXRoX21hcFxuICAgICAgICAgICAgICAgICAgICBtYXBwZWRJdGVtcyA9IGl0ZW1zLm1hcCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IHtpbmRleH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpICAgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGNvdW50U29ydGVyczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvcnRlcnNbaV0udXNlVHJhbnNmb3JtVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqW3NvcnRQcm9wZXJ0aWVzW2ldXSA9IHNvcnRlcnNbaV0udHJhbnNmb3JtVmFsdWUoaXRlbVtzb3J0UHJvcGVydGllc1tpXV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqW3NvcnRQcm9wZXJ0aWVzW2ldXSA9IGl0ZW1bc29ydFByb3BlcnRpZXNbaV1dXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcHBlZEl0ZW1zID0gaXRlbXNcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtYXBwZWRJdGVtcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGkgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgY291bnRTb3J0ZXJzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRQcm9wZXJ0eSA9IHNvcnRQcm9wZXJ0aWVzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYVtzb3J0UHJvcGVydHldID4gYltzb3J0UHJvcGVydHldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEgKiBzb3J0RGlyZWN0aW9uc1tpXVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYVtzb3J0UHJvcGVydHldIDwgYltzb3J0UHJvcGVydHldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xICogc29ydERpcmVjdGlvbnNbaV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaGFzVHJhbnNmb3JtVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuX2l0ZW1zID0gbWFwcGVkSXRlbXMubWFwKGVsID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtc1tlbC5pbmRleF1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtZVtpc1NvcnRlZF0gPSBjb3VudFNvcnRlcnMgPiAwO1xuXG4gICAgICAgIGlmICghc2lsZW50ICYmIG1lW3VwZGF0aW5nSW5kZXhdID09PSAwKSB7XG4gICAgICAgICAgICBtZS5maXJlKCdzb3J0Jywge1xuICAgICAgICAgICAgICAgIGl0ZW1zOiBtZS5faXRlbXMsXG4gICAgICAgICAgICAgICAgcHJldmlvdXNJdGVtcyxcbiAgICAgICAgICAgICAgICBzY29wZTogbWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXN1bWVzIHRoZSBjb2xsZWN0aW9uIGV2ZW50cy5cbiAgICAgKiBJZiB5b3Ugc3RhcnRlZCBhbiB1cGRhdGUgdXNpbmcgdGhlIHN0YXJ0U2lsZW50VXBkYXRlTW9kZSBmbGFnLFxuICAgICAqIHlvdSBtdXN0IHVzZSB0aGUgZW5kU2lsZW50VXBkYXRlTW9kZSBwYXJhbSBmb3IgdGhpcyBjYWxsLlxuICAgICAqIFVzaW5nIHRoZSBlbmRTaWxlbnRVcGRhdGVNb2RlIHBhcmFtIHdpbGwgbm90IGZpcmUgYSBtdXRhdGlvbiBldmVudC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtlbmRTaWxlbnRVcGRhdGVNb2RlXVxuICAgICAqIEBzZWUge0BsaW5rIE5lby5jb2xsZWN0aW9uLkJhc2Ujc3RhcnRVcGRhdGUgc3RhcnRVcGRhdGV9XG4gICAgICovXG4gICAgZW5kVXBkYXRlKGVuZFNpbGVudFVwZGF0ZU1vZGUpIHtcbiAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZVt1cGRhdGluZ0luZGV4XSA+IDApIHtcbiAgICAgICAgICAgIG1lW3VwZGF0aW5nSW5kZXhdLS1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbmRTaWxlbnRVcGRhdGVNb2RlKSB7XG4gICAgICAgICAgICBtZVtzaWxlbnRVcGRhdGVNb2RlXSA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5maXJlKCdtdXRhdGUnLCB7XG4gICAgICAgICAgICAgICAgYWRkZWRJdGVtcyAgOiBtZVt0b0FkZEFycmF5XSxcbiAgICAgICAgICAgICAgICByZW1vdmVkSXRlbXM6IG1lW3RvUmVtb3ZlQXJyYXldXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbWVbdG9BZGRBcnJheV0gICAuc3BsaWNlKDAsIG1lW3RvQWRkQXJyYXldICAgLmxlbmd0aCk7XG4gICAgICAgICAgICBtZVt0b1JlbW92ZUFycmF5XS5zcGxpY2UoMCwgbWVbdG9SZW1vdmVBcnJheV0ubGVuZ3RoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTmVlZGVkIGZvciByZW1vdGUgZmlsdGVyaW5nXG4gICAgICogQHJldHVybnMge09iamVjdFtdfVxuICAgICAqL1xuICAgIGV4cG9ydEZpbHRlcnMoKSB7XG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGZpbHRlcnMgPSBbXSxcbiAgICAgICAgICAgIGZpbHRlcjtcblxuICAgICAgICBtZS5maWx0ZXJzPy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBmaWx0ZXIgPSBrZXkuZXhwb3J0KCk7XG5cbiAgICAgICAgICAgIGZpbHRlciAmJiBmaWx0ZXJzLnB1c2goZmlsdGVyKVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZmlsdGVyc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5lZWRlZCBmb3IgcmVtb3RlIHNvcnRpbmdcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0W119XG4gICAgICovXG4gICAgZXhwb3J0U29ydGVycygpIHtcbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgc29ydGVycyA9IFtdLFxuICAgICAgICAgICAgc29ydGVyO1xuXG4gICAgICAgIG1lLnNvcnRlcnM/LmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIHNvcnRlciA9IGtleS5leHBvcnQoKTtcblxuICAgICAgICAgICAgc29ydGVyICYmIHNvcnRlcnMucHVzaChzb3J0ZXIpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBzb3J0ZXJzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGZpbHRlcigpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBmaWx0ZXJzICAgICAgICAgPSBtZS5fZmlsdGVycyxcbiAgICAgICAgICAgIGNvdW50QWxsRmlsdGVycyA9IGZpbHRlcnMubGVuZ3RoLFxuICAgICAgICAgICAgY291bnRGaWx0ZXJzICAgID0gMCxcbiAgICAgICAgICAgIGl0ZW1zICAgICAgICAgICA9IG1lLmFsbEl0ZW1zPy5faXRlbXMgfHwgbWUuX2l0ZW1zLFxuICAgICAgICAgICAgaSAgICAgICAgICAgICAgID0gMCxcbiAgICAgICAgICAgIGNvdW50SXRlbXMgICAgICA9IGl0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgIGZpbHRlcmVkSXRlbXMgICA9IFtdLFxuICAgICAgICAgICAgbmVlZHNTb3J0aW5nICAgID0gZmFsc2UsXG4gICAgICAgICAgICBvbGRJdGVtcyAgICAgICAgPSBbLi4ubWUuX2l0ZW1zXSxcbiAgICAgICAgICAgIGNvbmZpZywgaXNJbmNsdWRlZCwgaXRlbSwgaiwgdG1wSXRlbXM7XG5cbiAgICAgICAgZm9yICg7IGkgPCBjb3VudEFsbEZpbHRlcnM7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFmaWx0ZXJzW2ldLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgY291bnRGaWx0ZXJzKytcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb3VudEZpbHRlcnMgPT09IDAgJiYgbWUuYWxsSXRlbXMpIHtcbiAgICAgICAgICAgIGlmIChtZS5zb3J0ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBuZWVkc1NvcnRpbmcgPSB0cnVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLmNsZWFyU2lsZW50KCk7XG5cbiAgICAgICAgICAgIG1lLml0ZW1zID0gWy4uLm1lLmFsbEl0ZW1zLl9pdGVtc11cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghbWUuYWxsSXRlbXMpIHtcbiAgICAgICAgICAgICAgICBjb25maWcgPSB7Li4ubWUub3JpZ2luYWxDb25maWd9O1xuXG4gICAgICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5maWx0ZXJzO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuaXRlbXM7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5zb3J0ZXJzO1xuXG4gICAgICAgICAgICAgICAgbWUuYWxsSXRlbXMgPSBOZW8uY3JlYXRlKENvbGxlY3Rpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uTmVvLmNsb25lKGNvbmZpZywgdHJ1ZSwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgIGlkICAgICAgICAgOiBtZS5pZCArICctYWxsJyxcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMgICAgICA6IFsuLi5tZS5faXRlbXNdLCAvLyBJbml0aWFsaXplIHdpdGggYSBzaGFsbG93IGNvcHkgb2YgY3VycmVudCBpdGVtc1xuICAgICAgICAgICAgICAgICAgICBrZXlQcm9wZXJ0eTogbWUua2V5UHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZUlkICAgOiBtZS5pZFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLm1hcC5jbGVhcigpO1xuXG4gICAgICAgICAgICBpZiAobWUuZmlsdGVyTW9kZSA9PT0gJ3ByaW1pdGl2ZScpIHtcbiAgICAgICAgICAgICAgICAvLyB1c2luZyBmb3IgbG9vcHMgb24gcHVycG9zZSAtPiBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudEl0ZW1zOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaXNJbmNsdWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0gICAgICAgPSBpdGVtc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaiAgICAgICAgICA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGogPCBjb3VudEFsbEZpbHRlcnM7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlcnNbal0uaXNGaWx0ZXJlZChpdGVtLCBpdGVtcywgaXRlbXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNJbmNsdWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNJbmNsdWRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWRJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUubWFwLnNldChpdGVtW21lLmtleVByb3BlcnR5XSwgaXRlbSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1lLl9pdGVtcyA9IGZpbHRlcmVkSXRlbXMgLy8gc2lsZW50IHVwZGF0ZSwgdGhlIG1hcCBpcyBhbHJlYWR5IGluIHBsYWNlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpbHRlcmVkSXRlbXMgPSBbLi4uaXRlbXNdO1xuXG4gICAgICAgICAgICAgICAgZm9yIChqPTA7IGogPCBjb3VudEFsbEZpbHRlcnM7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB0bXBJdGVtcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudEl0ZW1zOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmlsdGVyc1tqXS5pc0ZpbHRlcmVkKGZpbHRlcmVkSXRlbXNbaV0sIGZpbHRlcmVkSXRlbXMsIGl0ZW1zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcEl0ZW1zLnB1c2goZmlsdGVyZWRJdGVtc1tpXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkSXRlbXMgPSBbLi4udG1wSXRlbXNdO1xuICAgICAgICAgICAgICAgICAgICBjb3VudEl0ZW1zICAgID0gZmlsdGVyZWRJdGVtcy5sZW5ndGhcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZS5pdGVtcyA9IGZpbHRlcmVkSXRlbXMgLy8gdXBkYXRlIHRoZSBtYXBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1lW2lzRmlsdGVyZWRdID0gY291bnRGaWx0ZXJzICE9PSAwO1xuXG4gICAgICAgIGlmIChuZWVkc1NvcnRpbmcpIHtcbiAgICAgICAgICAgIG1lLmRvU29ydChtZS5pdGVtcywgdHJ1ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmNvdW50ID0gbWUuaXRlbXMubGVuZ3RoO1xuXG4gICAgICAgIG1lLmZpcmUoJ2ZpbHRlcicsIHtcbiAgICAgICAgICAgIGlzRmlsdGVyZWQ6IG1lW2lzRmlsdGVyZWRdLFxuICAgICAgICAgICAgaXRlbXMgICAgIDogbWUuaXRlbXMsXG4gICAgICAgICAgICBvbGRJdGVtcyxcbiAgICAgICAgICAgIHNjb3BlICAgICA6IG1lXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpdGVtcyB3aGljaCBtYXRjaCB0aGUgcHJvcGVydHkgYW5kIHZhbHVlLlxuICAgICAqIFByb3BlcnRpZXMgY2FuIGNvbnRhaW4gZG90cyBmb3IgbmFtZXNwYWNlcyA9PiBmaW5kKCd2ZG9tLmlkJywgJ25lby12bm9kZS0xJylcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBbdmFsdWVdIE9ubHkgcmVxdWlyZWQgaW4gY2FzZSB0aGUgZmlyc3QgcGFyYW0gaXMgYSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJldHVybkZpcnN0TWF0Y2g9ZmFsc2VcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fE9iamVjdFtdfVxuICAgICAqICAgICByZXR1cm5GaXJzdE1hdGNoPWZhbHNlOiBSZXR1cm5zIGFuIGVtcHR5IEFycmF5IGluIGNhc2Ugbm8gaXRlbXMgYXJlIGZvdW5kXG4gICAgICogICAgIHJldHVybkZpcnN0TWF0Y2g9dHJ1ZTogIFJldHVybnMgdGhlIGZpcnN0IGZvdW5kIGl0ZW0gb3IgbnVsbFxuICAgICAqL1xuICAgIGZpbmQocHJvcGVydHksIHZhbHVlLCByZXR1cm5GaXJzdE1hdGNoPWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW1zICAgICAgICAgICAgPSBbXSxcbiAgICAgICAgICAgIGlzT2JqZWN0UHJvcGVydHkgPSBtZS5pc0l0ZW0ocHJvcGVydHkpLFxuICAgICAgICAgICAgaXRlbSwgbWF0Y2hBcnJheSwgcHJvcGVydGllc0FycmF5LCBwcm9wZXJ0aWVzTGVuZ3RoO1xuXG4gICAgICAgIGlmIChpc09iamVjdFByb3BlcnR5KSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzQXJyYXkgID0gT2JqZWN0LmVudHJpZXMocHJvcGVydHkpO1xuICAgICAgICAgICAgcHJvcGVydGllc0xlbmd0aCA9IHByb3BlcnRpZXNBcnJheS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGl0ZW0gb2YgbWUuaXRlbXMpIHtcbiAgICAgICAgICAgIGlmIChpc09iamVjdFByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hBcnJheSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgcHJvcGVydGllc0FycmF5LmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoTmVvLm5zKGtleSwgZmFsc2UsIGl0ZW0pID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hBcnJheS5wdXNoKHRydWUpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmIChtYXRjaEFycmF5Lmxlbmd0aCA9PT0gcHJvcGVydGllc0xlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuRmlyc3RNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKE5lby5ucyhwcm9wZXJ0eSwgZmFsc2UsIGl0ZW0pID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5GaXJzdE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaXRlbXMucHVzaChpdGVtKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldHVybkZpcnN0TWF0Y2ggPyBudWxsIDogaXRlbXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBpdGVtcyBpbiB0aGUgY29sbGVjdGlvbiBmb3Igd2hpY2ggdGhlIHBhc3NlZCBmdW5jdGlvbiByZXR1cm5zIHRydWVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gcnVuIGZvciBlYWNoIGl0ZW0gaW5zaWRlIHRoZSBzdGFydC1lbmQgcmFuZ2UuIFJldHVybiB0cnVlIGZvciBhIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmbi5pdGVtIFRoZSBjdXJyZW50IGNvbGxlY3Rpb24gaXRlbVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZT10aGlzIFRoZSBzY29wZSBpbiB3aGljaCB0aGUgcGFzc2VkIGZ1bmN0aW9uIGdldHMgZXhlY3V0ZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQ9MCBUaGUgc3RhcnQgaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZW5kPXRoaXMuY291bnQgVGhlIGVuZCBpbmRleCAodXAgdG8sIGxhc3QgdmFsdWUgZXhjbHVkZWQpXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGVtcHR5IEFycmF5IGluIGNhc2Ugbm8gaXRlbXMgYXJlIGZvdW5kXG4gICAgICovXG4gICAgZmluZEJ5KGZuLCBzY29wZT10aGlzLCBzdGFydD0wLCBlbmQ9dGhpcy5jb3VudCkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbXMgPSBbXSxcbiAgICAgICAgICAgIGkgICAgID0gc3RhcnQ7XG5cbiAgICAgICAgZm9yICg7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKGZuLmNhbGwoc2NvcGUsIG1lLml0ZW1zW2ldKSkge1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2gobWUuaXRlbXNbaV0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlbXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBpdGVtIHdoaWNoIG1hdGNoZXMgdGhlIHByb3BlcnR5IGFuZCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IFt2YWx1ZV0gT25seSByZXF1aXJlZCBpbiBjYXNlIHRoZSBmaXJzdCBwYXJhbSBpcyBhIHN0cmluZ1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGZpcnN0IGZvdW5kIGl0ZW0gb3IgbnVsbFxuICAgICAqL1xuICAgIGZpbmRGaXJzdChwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZChwcm9wZXJ0eSwgdmFsdWUsIHRydWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgaXRlbSBpbnNpZGUgdGhlIGNvbGxlY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGZpcnN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXNbMF1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBvYmplY3QgYXNzb2NpYXRlZCB0byB0aGUga2V5LCBvciBudWxsIGlmIHRoZXJlIGlzIG5vbmUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBrZXlcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgZ2V0KGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAuZ2V0KGtleSkgfHwgbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGl0ZW0gZm9yIGEgZ2l2ZW4gaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXRBdChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXNbaW5kZXhdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29uZmlnIHZhbHVlIG9mIHRoaXMuY291bnRcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBgdGhpcy5jb3VudGAgZGlyZWN0bHkgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBnZXRDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvdW50IHx8IDAgLy8gc2tpcHBpbmcgYmVmb3JlR2V0Q291bnQoKSBvbiBwdXJwb3NlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRDb3VudE11dGF0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbY291bnRNdXRhdGlvbnNdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgbWF0Y2hpbmcgZmlsdGVyIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkgY29uZmlnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAgICogQHJldHVybnMge05lby5jb2xsZWN0aW9uLkZpbHRlcnxudWxsfVxuICAgICAqL1xuICAgIGdldEZpbHRlcihwcm9wZXJ0eSkge1xuICAgICAgICBsZXQgZmlsdGVycyA9IHRoaXMuZmlsdGVycyB8fCBbXSxcbiAgICAgICAgICAgIGkgICAgICAgPSAwLFxuICAgICAgICAgICAgbGVuICAgICA9IGZpbHRlcnMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChmaWx0ZXJzW2ldLnByb3BlcnR5ID09PSBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJzW2ldXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGtleSBmb3IgYSBnaXZlbiBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8U3RyaW5nfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXRLZXlBdChpbmRleCkge1xuICAgICAgICBsZXQgaXRlbSA9IHRoaXMuX2l0ZW1zW2luZGV4XTtcbiAgICAgICAgcmV0dXJuIGl0ZW0/Llt0aGlzLmtleVByb3BlcnR5XVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzaGFsbG93IGNvcHkgb2YgYSBwb3J0aW9uIG9mIHRoZSBpdGVtcyBhcnJheVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRdIFplcm8tYmFzZWQgaW5kZXggYXQgd2hpY2ggdG8gYmVnaW4gZXh0cmFjdGlvbi5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2VuZF0gWmVyby1iYXNlZCBpbmRleCBiZWZvcmUgd2hpY2ggdG8gZW5kIGV4dHJhY3Rpb24gKGV4dHJhY3RzIHVwIHRvIGJ1dCBub3QgaW5jbHVkaW5nIGVuZCkuXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqIEBsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NsaWNlXG4gICAgICovXG4gICAgZ2V0UmFuZ2Uoc3RhcnQsIGVuZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXMuc2xpY2Uoc3RhcnQsIGVuZClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBTb3VyY2UgQ29sbGVjdGlvbiBpbiBjYXNlIHRoZSBzb3VyY2VDb2xsZWN0aW9uSWQgY29uZmlnIHdhcyBzZXRcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbGxlY3Rpb24uQmFzZXx1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0U291cmNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VJZCAmJiBOZW8uZ2V0KHRoaXMuc291cmNlSWQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGJvb2xlYW4gYXNzZXJ0aW5nIHdoZXRoZXIgYSB2YWx1ZSBoYXMgYmVlbiBhc3NvY2lhdGVkIHRvIHRoZSBrZXkgaW4gdGhlIENvbGxlY3Rpb24gb3Igbm90XG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBrZXlcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcC5oYXMoa2V5KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBib29sZWFuIGFzc2VydGluZyB3aGV0aGVyIGFuIGl0ZW0gZXhpc3RzIGluIHRoZSBDb2xsZWN0aW9uIG9yIG5vdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzSXRlbShpdGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcC5oYXMoaXRlbVt0aGlzLmtleVByb3BlcnR5XSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBmb3IgYSBnaXZlbiBrZXkgb3IgaXRlbVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xPYmplY3R9IGtleVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IGluZGV4ICgtMSBpbiBjYXNlIG5vIG1hdGNoIGlzIGZvdW5kKVxuICAgICAqL1xuICAgIGluZGV4T2Yoa2V5KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBtZS5faXRlbXMuaW5kZXhPZihtZS5pc0l0ZW0oa2V5KSA/IGtleSA6IG1lLm1hcC5nZXQoa2V5KSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBmb3IgYSBnaXZlbiBpdGVtXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBpbmRleCAoLTEgaW4gY2FzZSBubyBtYXRjaCBpcyBmb3VuZClcbiAgICAgKi9cbiAgICBpbmRleE9mSXRlbShpdGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtcy5pbmRleE9mKGl0ZW0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW5kZXggZm9yIGEgZ2l2ZW4ga2V5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBrZXlcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBpbmRleCAoLTEgaW4gY2FzZSBubyBtYXRjaCBpcyBmb3VuZClcbiAgICAgKi9cbiAgICBpbmRleE9mS2V5KGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXMuaW5kZXhPZih0aGlzLm1hcC5nZXQoa2V5KSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGFuIGl0ZW0gb3IgYW4gYXJyYXkgb2YgaXRlbXMgYXQgdGhlIHNwZWNpZmllZCBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBpdGVtXG4gICAgICogQHJldHVybnMge09iamVjdFtdfSBhbiBhcnJheSBjb250YWluaW5nIGFsbCBhZGRlZCBpdGVtc1xuICAgICAqL1xuICAgIGluc2VydChpbmRleCwgaXRlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zcGxpY2UoaW5kZXgsIDAsIGl0ZW0pLmFkZGVkSXRlbXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpbiBjYXNlIHRoZSBjb2xsZWN0aW9uIGlzIGZpbHRlcmVkXG4gICAgICovXG4gICAgaXNGaWx0ZXJlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbaXNGaWx0ZXJlZF1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpc0ZpbHRlcmVkSXRlbShpdGVtKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGZpbHRlcnMgICAgPSBtZS5fZmlsdGVycyxcbiAgICAgICAgICAgIGkgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgbGVuICAgICAgICA9IGZpbHRlcnMubGVuZ3RoLFxuICAgICAgICAgICAgaXNGaWx0ZXJlZCA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChmaWx0ZXJzW2ldLmlzRmlsdGVyZWQoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBpc0ZpbHRlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlzRmlsdGVyZWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIGNoZWNrIGlmIGEgZ2l2ZW4gaW5wdXQgaXMgZWl0aGVyIG9iamVjdC1saWtlIG9yIGEga2V5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSByZXR1cm5zIHRydWUgZm9yIG9iamVjdC1saWtlIHZhbHVlc1xuICAgICAqL1xuICAgIGlzSXRlbSh2YWx1ZSkge1xuICAgICAgICAvLyBXZSBjYW4gbm90IHVzZSBOZW8uaXNPYmplY3QoKSB8fCBOZW8uaXNSZWNvcmQoKSwgc2luY2UgY29sbGVjdGlvbnMgY2FuIHN0b3JlIG5lbyBpbnN0YW5jZXMgdG9vLlxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0J1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGluIGNhc2UgdGhlIGNvbGxlY3Rpb24gaXMgc29ydGVkXG4gICAgICovXG4gICAgaXNTb3J0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW2lzU29ydGVkXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxhc3QgaXRlbSBpbnNpZGUgdGhlIGNvbGxlY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGxhc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtc1t0aGlzLmNvdW50IC0xXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGFuIGl0ZW0gZnJvbSBmcm9tSW5kZXggdG8gdG9JbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmcm9tSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdG9JbmRleFxuICAgICAqL1xuICAgIG1vdmUoZnJvbUluZGV4LCB0b0luZGV4KSB7XG4gICAgICAgIGlmIChmcm9tSW5kZXggPT09IHRvSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpdGVtcyA9IHRoaXMuX2l0ZW1zO1xuXG4gICAgICAgIGlmIChmcm9tSW5kZXggPj0gaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBmcm9tSW5kZXggPSBpdGVtcy5sZW5ndGggLSAxXG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgc3BsaWNlIG9wZXJhdGlvbnMgYXJlIGludGVudGlvbmFsbHkgc2VwYXJhdGVkLlxuICAgICAgICAvLyBVc2luZyB0aGUgY29tbW9uIG9uZS1saW5lciBgaXRlbXMuc3BsaWNlKHRvSW5kZXgsIDAsIGl0ZW1zLnNwbGljZShmcm9tSW5kZXgsIDEpWzBdKWBcbiAgICAgICAgLy8gY2FuIGxlYWQgdG8gdW5wcmVkaWN0YWJsZSBzaWRlIGVmZmVjdHMsIGFzIHRoZSBpbm5lciBzcGxpY2UgY2FuIGFsdGVyIHRoZSBhcnJheVxuICAgICAgICAvLyBiZWZvcmUgdGhlIG91dGVyIHNwbGljZSdzIGluZGV4IGlzIHJlc29sdmVkLiBUaGlzIHR3by1zdGVwIGFwcHJvYWNoIGlzIHNhZmVyLlxuICAgICAgICBjb25zdCBpdGVtID0gaXRlbXMuc3BsaWNlKGZyb21JbmRleCwgMSlbMF07XG4gICAgICAgIGl0ZW1zLnNwbGljZSh0b0luZGV4LCAwLCBpdGVtKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uRmlsdGVyQ2hhbmdlKG9wdHMpIHtcbiAgICAgICAgdGhpcy5maWx0ZXIoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uTXV0YXRlKG9wdHMpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvLyB0b2RvOiBpbnNwZWN0IHRoZSBidWJibGluZyBjaGFpblxuICAgICAgICAvKmlmIChvcHRzLnByZXZlbnRCdWJibGVVcCkge1xuICAgICAgICAgICAgbWUucHJldmVudEJ1YmJsZVVwID0gdHJ1ZVxuICAgICAgICB9Ki9cblxuICAgICAgICBtZS5wcmV2ZW50QnViYmxlVXAgPSB0cnVlO1xuXG4gICAgICAgIG1lLnNwbGljZShudWxsLCBvcHRzLnJlbW92ZWRJdGVtcywgb3B0cy5hZGRlZEl0ZW1zKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uU29ydGVyQ2hhbmdlKG9wdHMpIHtcbiAgICAgICAgdGhpcy5hcHBseVNvcnRlckNvbmZpZ3MoKTtcbiAgICAgICAgdGhpcy5kb1NvcnQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGxhc3QgZWxlbWVudCBmcm9tIHRoZSBpdGVtcyBhcnJheSBhbmQgcmV0dXJucyB0aGlzIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIHJlbW92ZWQgZWxlbWVudCBmcm9tIHRoZSBjb2xsZWN0aW9uOyB1bmRlZmluZWQgaWYgdGhlIGNvbGxlY3Rpb24gaXMgZW1wdHkuXG4gICAgICovXG4gICAgcG9wKCkge1xuICAgICAgICBsZXQgbXV0YXRpb24gPSB0aGlzLnNwbGljZSh0aGlzLmNvdW50IC0xLCAxKTtcbiAgICAgICAgcmV0dXJuIG11dGF0aW9uLnJlbW92ZWRJdGVtc1swXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgb25lIG9yIG1vcmUgaXRlbXMgdG8gdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvbiBhbmQgcmV0dXJucyB0aGUgbmV3IGl0ZW1zIGNvdW50XG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGl0ZW0gVGhlIGl0ZW0ocykgdG8gYWRkXG4gICAgICogQHJldHVybnMge051bWJlcn0gdGhlIGNvbGxlY3Rpb24gY291bnRcbiAgICAgKi9cbiAgICBwdXNoKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGl0ZW0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGdpdmVuIGtleSwgaXRlbSBvciBBcnJheSBjb250YWluaW5nIGtleXN8aXRlbXNcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8T2JqZWN0fEFycmF5fSBrZXlcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgY29sbGVjdGlvbiBjb3VudFxuICAgICAqL1xuICAgIHJlbW92ZShrZXkpIHtcbiAgICAgICAgdGhpcy5zcGxpY2UoMCwgQXJyYXkuaXNBcnJheShrZXkpID8ga2V5IDogW2tleV0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb3VudFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGl0ZW0gYXQgdGhlIGdpdmVuIGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge051bWJlcn0gdGhlIGNvbGxlY3Rpb24gY291bnRcbiAgICAgKi9cbiAgICByZW1vdmVBdChpbmRleCkge1xuICAgICAgICB0aGlzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvdW50XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJzZXMgdGhlIGl0ZW1zIGFycmF5IGluIHBsYWNlLlxuICAgICAqIEludGVuZGVkIGZvciBjb2xsZWN0aW9ucyB3aXRob3V0IHNvcnRlcnMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBpdGVtc1xuICAgICAqL1xuICAgIHJldmVyc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtcy5yZXZlcnNlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBmaXJzdCBlbGVtZW50IGZyb20gdGhlIGl0ZW1zIGFycmF5IGFuZCByZXR1cm5zIHRoaXMgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcmVtb3ZlZCBlbGVtZW50IGZyb20gdGhlIGNvbGxlY3Rpb247IHVuZGVmaW5lZCBpZiB0aGUgY29sbGVjdGlvbiBpcyBlbXB0eS5cbiAgICAgKi9cbiAgICBzaGlmdCgpIHtcbiAgICAgICAgbGV0IG11dGF0aW9uID0gdGhpcy5zcGxpY2UoMCwgMSk7XG4gICAgICAgIHJldHVybiBtdXRhdGlvbi5hZGRlZEl0ZW1zWzBdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gdGVzdCBmb3IgZWFjaCBpdGVtLCB0YWtpbmcgdGhyZWUgcGFyYW1ldGVyczpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICBjYWxsYmFjay5pdGVtIFRoZSBjdXJyZW50IGNvbGxlY3Rpb24gaXRlbSBiZWluZyBwcm9jZXNzZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gIFtjYWxsYmFjay5pbmRleF0gVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGl0ZW0gYmVpbmcgcHJvY2Vzc2VkXG4gICAgICogQHBhcmFtIHtBcnJheX0gICBbY2FsbGJhY2suaXRlbXNdIFRoZSBpdGVtcyBhcnJheSBvZiB0aGUgY29sbGVjdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV0gVmFsdWUgdG8gdXNlIGFzIFwidGhpc1wiIHdoZW4gZXhlY3V0aW5nIHRoZSBjYWxsYmFja1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlIGZvciBhbnkgY29sbGVjdGlvbiBpdGVtLCBvdGhlcndpc2UgZmFsc2VcbiAgICAgKi9cbiAgICBzb21lKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zLnNvbWUoLi4uYXJncylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGl0ZW1zIGZyb20gYW5kL29yIGFkZHMgaXRlbXMgdG8gdGhpcyBjb2xsZWN0aW9uXG4gICAgICogSWYgdGhlIHRvUmVtb3ZlQXJyYXkgaXMgdXNlZCwgdGhlbiB0aGUgaW5kZXggaXMgbm90IHVzZWQgZm9yIHJlbW92aW5nLCB0aGUgZW50cmllcyBhcmUgZm91bmQgYnkga2V5IGFuZCByZW1vdmVkIGZyb20gd2hlcmUgdGhleSBhcmUuXG4gICAgICogSWYgaW5kZXggaXMgbm90IHBhc3NlZCwgdG9BZGRBcnJheSBpcyBhcHBlbmRlZCB0byB0aGUgQ29sbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdFtdfSBbcmVtb3ZlQ291bnRPclRvUmVtb3ZlQXJyYXldXG4gICAgICogQHBhcmFtIHtPYmplY3R8T2JqZWN0W119IFt0b0FkZEFycmF5XVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBhZGRlZEl0ZW1zICYgcmVtb3ZlZEl0ZW1zIGFycmF5c1xuICAgICAqL1xuICAgIHNwbGljZShpbmRleCwgcmVtb3ZlQ291bnRPclRvUmVtb3ZlQXJyYXksIHRvQWRkQXJyYXkpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7a2V5UHJvcGVydHksIG1hcH0gPSBtZSxcbiAgICAgICAgICAgIHNvdXJjZSAgICAgICAgICAgICA9IG1lLmdldFNvdXJjZSgpLFxuICAgICAgICAgICAgYWRkZWRJdGVtcyAgICAgICAgID0gW10sXG4gICAgICAgICAgICBpdGVtcyAgICAgICAgICAgICAgPSBtZS5faXRlbXMsXG4gICAgICAgICAgICByZW1vdmVkSXRlbXMgICAgICAgPSBbXSxcbiAgICAgICAgICAgIHJlbW92ZUNvdW50QXRJbmRleCA9IE5lby5pc051bWJlcihyZW1vdmVDb3VudE9yVG9SZW1vdmVBcnJheSkgPyByZW1vdmVDb3VudE9yVG9SZW1vdmVBcnJheSA6IG51bGwsXG4gICAgICAgICAgICB0b1JlbW92ZUFycmF5ICAgICAgPSBBcnJheS5pc0FycmF5KHJlbW92ZUNvdW50T3JUb1JlbW92ZUFycmF5KSA/IHJlbW92ZUNvdW50T3JUb1JlbW92ZUFycmF5IDogbnVsbCxcbiAgICAgICAgICAgIGksIGl0ZW0sIGtleSwgbGVuLCB0b0FkZE1hcDtcblxuICAgICAgICBpZiAoIU5lby5pc051bWJlcihpbmRleCkgJiYgcmVtb3ZlQ291bnRBdEluZGV4KSB7XG4gICAgICAgICAgICBMb2dnZXIuZXJyb3IobWUuaWQgKyAnOiBJZiBpbmRleCBpcyBub3QgcGFzc2VkLCByZW1vdmVDb3VudEF0SW5kZXggY2Fubm90IGJlIHVzZWQnKVxuICAgICAgICB9XG5cbiAgICAgICAgdG9BZGRBcnJheSA9IHRvQWRkQXJyYXkgJiYgIUFycmF5LmlzQXJyYXkodG9BZGRBcnJheSkgPyBbdG9BZGRBcnJheV0gOiB0b0FkZEFycmF5O1xuXG4gICAgICAgIGlmICh0b1JlbW92ZUFycmF5ICYmIChsZW4gPSB0b1JlbW92ZUFycmF5Lmxlbmd0aCkgPiAwKSB7XG4gICAgICAgICAgICBpZiAodG9BZGRBcnJheSAmJiB0b0FkZEFycmF5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0b0FkZE1hcCA9IHRvQWRkQXJyYXkubWFwKGUgPT4gZVtrZXlQcm9wZXJ0eV0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaT0wOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpdGVtID0gdG9SZW1vdmVBcnJheVtpXTtcbiAgICAgICAgICAgICAgICBrZXkgID0gbWUuaXNJdGVtKGl0ZW0pID8gaXRlbVtrZXlQcm9wZXJ0eV0gOiBpdGVtO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1hcC5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRvQWRkTWFwIHx8ICh0b0FkZE1hcCAmJiB0b0FkZE1hcC5pbmRleE9mKGtleSkgPCAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZEl0ZW1zLnB1c2goaXRlbXMuc3BsaWNlKG1lLmluZGV4T2ZLZXkoa2V5KSwgMSlbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLmRlbGV0ZShrZXkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocmVtb3ZlQ291bnRBdEluZGV4ICYmIHJlbW92ZUNvdW50QXRJbmRleCA+IDApIHtcbiAgICAgICAgICAgIHJlbW92ZWRJdGVtcy5wdXNoKC4uLml0ZW1zLnNwbGljZShpbmRleCwgcmVtb3ZlQ291bnRBdEluZGV4KSk7XG4gICAgICAgICAgICByZW1vdmVkSXRlbXMuZm9yRWFjaChlID0+IHtcbiAgICAgICAgICAgICAgICBtYXAuZGVsZXRlKGVba2V5UHJvcGVydHldKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b0FkZEFycmF5ICYmIChsZW4gPSB0b0FkZEFycmF5Lmxlbmd0aCkgPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGk9MDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IHRvQWRkQXJyYXlbaV07XG4gICAgICAgICAgICAgICAga2V5ICA9IGl0ZW1ba2V5UHJvcGVydHldO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVtrZXlQcm9wZXJ0eV0gPSBrZXkgPSBtZS5rZXlQcm9wZXJ0eUluZGV4O1xuICAgICAgICAgICAgICAgICAgICBtZS5rZXlQcm9wZXJ0eUluZGV4LS1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIW1hcC5oYXMoa2V5KSAmJiAhbWUuaXNGaWx0ZXJlZEl0ZW0oaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkZWRJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBtYXAuc2V0KGtleSwgaXRlbSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhZGRlZEl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBlcmZvcm1hbmNlIGltcHJvdmVtZW50IGZvciBTYWZhcmksIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL25lb21qcy9uZW8vaXNzdWVzLzYyMjhcbiAgICAgICAgICAgICAgICAgICAgbWUuX2l0ZW1zID0gYWRkZWRJdGVtc1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zLnNwbGljZShOZW8uaXNOdW1iZXIoaW5kZXgpID8gaW5kZXggOiBpdGVtcy5sZW5ndGgsIDAsIC4uLmFkZGVkSXRlbXMpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG1lLmF1dG9Tb3J0ICYmIG1lLl9zb3J0ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuZG9Tb3J0KClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoIXNvdXJjZS5nZXRTb3VyY2UoKSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZS5wcmV2ZW50QnViYmxlVXAgPSB0cnVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghbWUucHJldmVudEJ1YmJsZVVwKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3NvdXJjZSBzcGxpY2UnLCBzb3VyY2UuaWQsICdhZGRlZDonLCAuLi50b0FkZEFycmF5LCAncmVtb3ZlZDonLCAuLi5yZW1vdmVkSXRlbXMpO1xuICAgICAgICAgICAgICAgIG1lLnN0YXJ0VXBkYXRlKHRydWUpO1xuICAgICAgICAgICAgICAgIHNvdXJjZS5zcGxpY2UobnVsbCwgdG9SZW1vdmVBcnJheSB8fCByZW1vdmVkSXRlbXMsIHRvQWRkQXJyYXkpO1xuICAgICAgICAgICAgICAgIG1lLmVuZFVwZGF0ZSh0cnVlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWxldGUgc291cmNlLnByZXZlbnRCdWJibGVVcFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFkZGVkSXRlbXMubGVuZ3RoID4gMCB8fCByZW1vdmVkSXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbWVbY291bnRNdXRhdGlvbnNdKytcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZVt1cGRhdGluZ0luZGV4XSA9PT0gMCkge1xuICAgICAgICAgICAgbWUuY291bnQgPSBtZS5faXRlbXMubGVuZ3RoO1xuXG4gICAgICAgICAgICBtZS5maXJlKCdtdXRhdGUnLCB7XG4gICAgICAgICAgICAgICAgYWRkZWRJdGVtcyAgICAgOiB0b0FkZEFycmF5LFxuICAgICAgICAgICAgICAgIHByZXZlbnRCdWJibGVVcDogbWUucHJldmVudEJ1YmJsZVVwLFxuICAgICAgICAgICAgICAgIHJlbW92ZWRJdGVtcyAgIDogdG9SZW1vdmVBcnJheSB8fCByZW1vdmVkSXRlbXNcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSBpZiAoIW1lW3NpbGVudFVwZGF0ZU1vZGVdKSB7XG4gICAgICAgICAgICBtZS5jYWNoZVVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgYWRkZWRJdGVtcyxcbiAgICAgICAgICAgICAgICByZW1vdmVkSXRlbXNcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWVbdXBkYXRpbmdJbmRleF0gPT09IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSBtZS5wcmV2ZW50QnViYmxlVXBcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7YWRkZWRJdGVtcywgcmVtb3ZlZEl0ZW1zfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByZXZlbnRzIHRoZSBjb2xsZWN0aW9uIGZyb20gZmlyaW5nIGV2ZW50cyB1bnRpbCBlbmRVcGRhdGUgZ2V0cyBjYWxsZWQuXG4gICAgICogSWYgeW91IHN0YXJ0IGFuIHVwZGF0ZSB1c2luZyB0aGUgc3RhcnRTaWxlbnRVcGRhdGVNb2RlIHBhcmFtLFxuICAgICAqIHRoZSBtdXRhdGlvbiBldmVudCB3aWxsIG5vdCBmaXJlIGFmdGVyIHVzaW5nIGVuZFVwZGF0ZSgpXG4gICAgICogKHlvdSBtdXN0IHVzZSB0aGUgZW5kU2lsZW50VXBkYXRlTW9kZSBwYXJhbSBmb3IgdGhlIGVuZFVwZGF0ZSBjYWxsIGluIGNhc2UgeW91IHVzZWRcbiAgICAgKiBzdGFydFNpbGVudFVwZGF0ZU1vZGUgaGVyZSlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzdGFydFNpbGVudFVwZGF0ZU1vZGVdXG4gICAgICogQHNlZSB7QGxpbmsgTmVvLmNvbGxlY3Rpb24uQmFzZSNlbmRVcGRhdGUgZW5kVXBkYXRlfVxuICAgICAqL1xuICAgIHN0YXJ0VXBkYXRlKHN0YXJ0U2lsZW50VXBkYXRlTW9kZSkge1xuICAgICAgICBpZiAoc3RhcnRTaWxlbnRVcGRhdGVNb2RlKSB7XG4gICAgICAgICAgICB0aGlzW3NpbGVudFVwZGF0ZU1vZGVdID0gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpc1t1cGRhdGluZ0luZGV4XSsrXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBvbmUgb3IgbW9yZSBlbGVtZW50cyB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjb2xsZWN0aW9uIGFuZCByZXR1cm5zIHRoZSBuZXcgaXRlbXMgY291bnRcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gaXRlbSBUaGUgaXRlbShzKSB0byBhZGRcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgY29sbGVjdGlvbiBjb3VudFxuICAgICAqL1xuICAgIHVuc2hpZnQoaXRlbSkge1xuICAgICAgICB0aGlzLnNwbGljZSgwLCAwLCBpdGVtKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY291bnRcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIG11dGF0ZSBldmVudCBmaXJlcyBhZnRlciBldmVyeSBzcGxpY2UgY2FsbCAoaW52b2tlZCBieSBhbGwgbWV0aG9kcyB3aGljaCBjaGFuZ2UgdGhlIGNvbnRlbnQgb2YgdGhlIGl0ZW1zIGFycmF5KS5cbiAqIEBldmVudCBtdXRhdGVcbiAqIEBwYXJhbSB7T2JqZWN0W119IGFkZGVkSXRlbXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJldmVudEJ1YmJsZVVwIHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0W119IHJlbW92ZWRJdGVtc1xuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhDb2xsZWN0aW9uKTtcbiIsImltcG9ydCBCYXNlICAgICAgIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuaW1wb3J0IE9ic2VydmFibGUgZnJvbSAnLi4vY29yZS9PYnNlcnZhYmxlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jb2xsZWN0aW9uLkZpbHRlclxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICogQG1peGVzIE5lby5jb3JlLk9ic2VydmFibGVcbiAqL1xuY2xhc3MgRmlsdGVyIGV4dGVuZHMgQmFzZSB7XG4gICAgLyoqXG4gICAgICogVHJ1ZSBhdXRvbWF0aWNhbGx5IGFwcGxpZXMgdGhlIGNvcmUuT2JzZXJ2YWJsZSBtaXhpblxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG9ic2VydmFibGU9dHJ1ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgb2JzZXJ2YWJsZSA9IHRydWVcbiAgICAvKipcbiAgICAgKiBWYWxpZCB2YWx1ZXMgZm9yIHRoZSBvcGVyYXRvciBjb25maWc6PGJyPlxuICAgICAqIFsnPT0nLCc9PT0nLCchPScsJyE9PScsJzwnLCc8PScsJz4nLCc+PScsJ2VuZHNXaXRoJywnZXhjbHVkZWQnLCdpbmNsdWRlZCcsJ2lzRGVmaW5lZCcsJ2lzVW5kZWZpbmVkJywnbGlrZScsJ3N0YXJ0c1dpdGgnXVxuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBvcGVyYXRvcnNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBvcGVyYXRvcnMgPSBbXG4gICAgICAgICc9PScsICc9PT0nLCAnIT0nLCAnIT09JywgJzwnLCAnPD0nLCAnPicsICc+PScsICdlbmRzV2l0aCcsICdleGNsdWRlZCcsICdpbmNsdWRlZCcsXG4gICAgICAgICdpc0RlZmluZWQnLCAnaXNVbmRlZmluZWQnLCAnbGlrZScsICdzdGFydHNXaXRoJ1xuICAgIF1cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbGxlY3Rpb24uRmlsdGVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29sbGVjdGlvbi5GaWx0ZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nZmlsdGVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2ZpbHRlcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXR0aW5nIGRpc2FibGVkIHRvIHRydWUgd2lsbCBleGNsdWRlIHRoaXMgZmlsdGVyIGZyb20gdGhlIGNvbGxlY3Rpb24gZmlsdGVyaW5nIGxvZ2ljXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGRpc2FibGVkXz1mYWxzZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGRpc2FibGVkXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm92aWRlIGEgY3VzdG9tIGZpbHRlcmluZyBmdW5jdGlvbiB3aGljaCBoYXMgYSBoaWdoZXIgcHJpb3JpdHkgdGhhbiBwcm9wZXJ0eSwgb3BlcmF0b3IgJiB2YWx1ZVxuICAgICAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbnxudWxsfSBmaWx0ZXJCeV89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGZpbHRlckJ5XzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgbWVhbnMgbm90IGZpbHRlcmluZyBvdXQgaXRlbXMgaW4gY2FzZSB0aGUgdmFsdWUgaXMgJycsIG51bGwsIFtdIG9yIHt9XG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGluY2x1ZGVFbXB0eVZhbHVlcz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBpbmNsdWRlRW1wdHlWYWx1ZXM6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhpcyBmbGFnIHRvIHRydWUgYmVmb3JlIHN0YXJ0aW5nIGJ1bGsgdXBkYXRlcyAoZS5nLiBjaGFuZ2luZyBwcm9wZXJ0eSAmIHZhbHVlKVxuICAgICAgICAgKiB0byBwcmV2ZW50IG11bHRpcGxlIGNoYW5nZSBldmVudHNcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNVcGRhdGluZ189ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBpc1VwZGF0aW5nXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgb3duZXIgdXRpbC5Db2xsZWN0aW9uIG5lZWRzIHRvIGFwcGx5IGFuIG9uQ2hhbmdlIGxpc3RlbmVyIG9uY2VcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbGlzdGVuZXJBcHBsaWVkPWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGxpc3RlbmVyQXBwbGllZDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgb3BlcmF0b3IgdG8gZmlsdGVyIGJ5ICh1c2UgdGhlIGNvbWJpbmF0aW9uIG9mIHByb3BlcnR5LCBvcGVyYXRvciAmIHZhbHVlKVxuICAgICAgICAgKiBWYWxpZCB2YWx1ZXM6XG4gICAgICAgICAqXG4gICAgICAgICAqID09IChub3QgcmVjb21tZW5kZWQpXG4gICAgICAgICAqID09PVxuICAgICAgICAgKiAhPSAobm90IHJlY29tbWVuZGVkKVxuICAgICAgICAgKiAhPT1cbiAgICAgICAgICogPFxuICAgICAgICAgKiA+PVxuICAgICAgICAgKiA+XG4gICAgICAgICAqID49XG4gICAgICAgICAqIGxpa2UgKGNvbGxlY3Rpb25WYWx1ZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoZmlsdGVyVmFsdWUudG9Mb3dlckNhc2UoKSkgPiAtMSlcbiAgICAgICAgICogaW5jbHVkZWQgKGV4cGVjdHMgdmFsdWUgdG8gYmUgYW4gYXJyYXkpXG4gICAgICAgICAqIGV4Y2x1ZGVkIChleHBlY3RzIHZhbHVlIHRvIGJlIGFuIGFycmF5KVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG9wZXJhdG9yPSc9PT0nXG4gICAgICAgICAqL1xuICAgICAgICBvcGVyYXRvcl86ICc9PT0nLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHByb3BlcnR5IHRvIGZpbHRlciBieSAodXNlIHRoZSBjb21iaW5hdGlvbiBvZiBwcm9wZXJ0eSwgb3BlcmF0b3IgJiB2YWx1ZSlcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBwcm9wZXJ0eV89J2lkJ1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHByb3BlcnR5XzogJ2lkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzY29wZSB0byB1c2UgZm9yIHRoZSBmaWx0ZXJCeSBtZXRob2QsIGluIGNhc2UgaXQgaXMgcHJvdmlkZWQuIERlZmF1bHRzIHRvIHRoaXMgaW5zdGFuY2UuXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBzY29wZT1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBzY29wZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB2YWx1ZSB0byBmaWx0ZXIgYnkgKHVzZSB0aGUgY29tYmluYXRpb24gb2YgcHJvcGVydHksIG9wZXJhdG9yICYgdmFsdWUpXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gdmFsdWVfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZV86IG51bGxcbiAgICB9XG5cbiAgICBhZnRlclNldERpc2FibGVkKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5maXJlQ2hhbmdlRXZlbnQoLi4uYXJncylcbiAgICB9XG5cbiAgICBhZnRlclNldEZpbHRlckJ5KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICAvLyB0b2RvXG4gICAgfVxuXG4gICAgYWZ0ZXJTZXRJc1VwZGF0aW5nKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB2YWx1ZSA9PT0gZmFsc2UgJiYgdGhpcy5maXJlQ2hhbmdlRXZlbnQodmFsdWUsIG9sZFZhbHVlKVxuICAgIH1cblxuICAgIGFmdGVyU2V0T3BlcmF0b3IoLi4uYXJncykge1xuICAgICAgICB0aGlzLmZpcmVDaGFuZ2VFdmVudCguLi5hcmdzKVxuICAgIH1cblxuICAgIGFmdGVyU2V0UHJvcGVydHkoLi4uYXJncykge1xuICAgICAgICB0aGlzLmZpcmVDaGFuZ2VFdmVudCguLi5hcmdzKVxuICAgIH1cblxuICAgIGFmdGVyU2V0VmFsdWUoLi4uYXJncykge1xuICAgICAgICB0aGlzLmZpcmVDaGFuZ2VFdmVudCguLi5hcmdzKVxuICAgIH1cblxuICAgIGJlZm9yZVNldEZpbHRlckJ5KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBOZW8ubG9nRXJyb3IoJ2ZpbHRlckJ5IGhhcyB0byBiZSBhIGZ1bmN0aW9uJywgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gb2xkVmFsdWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIG9wZXJhdG9yIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRPcGVyYXRvcih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ29wZXJhdG9yJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOZWVkZWQgZm9yIHJlbW90ZSBmaWx0ZXJpbmdcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgZXhwb3J0KCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtvcGVyYXRvciwgcHJvcGVydHksIHZhbHVlfSA9IG1lO1xuXG4gICAgICAgIGlmICghbWUuZmlsdGVyQnkpIHtcbiAgICAgICAgICAgIHJldHVybiB7b3BlcmF0b3IsIHByb3BlcnR5LCB2YWx1ZX1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHBhcmFtIG9sZFZhbHVlXG4gICAgICovXG4gICAgZmlyZUNoYW5nZUV2ZW50KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIG1lLmlzVXBkYXRpbmcgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGxldCB7b3BlcmF0b3IsIHByb3BlcnR5LCB2YWx1ZX0gPSBtZTtcbiAgICAgICAgICAgIG1lLmZpcmUoJ2NoYW5nZScsIHtvcGVyYXRvciwgcHJvcGVydHksIHZhbHVlfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIGNvbGxlY3Rpb24gaXRlbSBtYXRjaGVzIHRoaXMgZmlsdGVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gVGhlIGN1cnJlbnQgY29sbGVjdGlvbiBpdGVtXG4gICAgICogQHBhcmFtIHtBcnJheX0gZmlsdGVyZWRJdGVtcyBJZiB0aGUgY29sbGVjdGlvbiBmaWx0ZXJNb2RlIGlzIG5vdCBwcmltaXRpdmUgY29udGFpbnMgdGhlIGl0ZW1zIHdoaWNoIHBhc3NlZFxuICAgICAqIHRoZSBwcmV2aW91cyBmaWx0ZXJzLCBvdGhlcndpc2UgYWxsIGNvbGxlY3Rpb24gaXRlbXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhbGxJdGVtcyBhbGwgY29sbGVjdGlvbiBpdGVtc1xuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzRmlsdGVyZWQoaXRlbSwgZmlsdGVyZWRJdGVtcywgYWxsSXRlbXMpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIGZpbHRlclZhbHVlLCByZWNvcmRWYWx1ZTtcblxuICAgICAgICBpZiAobWUuX2Rpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZS5fZmlsdGVyQnkpIHtcbiAgICAgICAgICAgIHJldHVybiBtZS5maWx0ZXJCeS5jYWxsKG1lLnNjb3BlIHx8IG1lLCB7XG4gICAgICAgICAgICAgICAgYWxsSXRlbXMsXG4gICAgICAgICAgICAgICAgZmlsdGVyZWRJdGVtcyxcbiAgICAgICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBtZS5fdmFsdWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWUuaW5jbHVkZUVtcHR5VmFsdWVzICYmIChtZS5fdmFsdWUgPT09IG51bGwgfHwgTmVvLmlzRW1wdHkobWUuX3ZhbHVlKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgZmlsdGVyVmFsdWUgPSBtZS5fdmFsdWU7XG4gICAgICAgIHJlY29yZFZhbHVlID0gaXRlbVttZS5fcHJvcGVydHldO1xuXG4gICAgICAgIGlmIChmaWx0ZXJWYWx1ZSBpbnN0YW5jZW9mIERhdGUgJiYgcmVjb3JkVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICBmaWx0ZXJWYWx1ZSA9IGZpbHRlclZhbHVlLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIHJlY29yZFZhbHVlID0gcmVjb3JkVmFsdWUudmFsdWVPZigpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gIUZpbHRlclttZS5fb3BlcmF0b3JdKHJlY29yZFZhbHVlLCBmaWx0ZXJWYWx1ZSlcbiAgICB9XG5cbiAgICBzdGF0aWMgWyc9PSddIChhLCBiKSB7cmV0dXJuIGEgPT0gYn1cbiAgICBzdGF0aWMgWyc9PT0nXShhLCBiKSB7cmV0dXJuIGEgPT09IGJ9XG4gICAgc3RhdGljIFsnIT0nXSAoYSwgYikge3JldHVybiBhICE9IGJ9XG4gICAgc3RhdGljIFsnIT09J10oYSwgYikge3JldHVybiBhICE9PSBifVxuICAgIHN0YXRpYyBbJzwnXSAgKGEsIGIpIHtyZXR1cm4gYSA8IGJ9XG4gICAgc3RhdGljIFsnPD0nXSAoYSwgYikge3JldHVybiBhIDw9IGJ9XG4gICAgc3RhdGljIFsnPiddICAoYSwgYikge3JldHVybiBhID4gYn1cbiAgICBzdGF0aWMgWyc+PSddIChhLCBiKSB7cmV0dXJuIGEgPj0gYn1cblxuICAgIHN0YXRpYyBbJ2VuZHNXaXRoJ10oYSwgYikge1xuICAgICAgICBpZiAoIU5lby5pc1N0cmluZyhhKSkge2EgPSBTdHJpbmcoYSl9XG4gICAgICAgIGlmICghTmVvLmlzU3RyaW5nKGIpKSB7YiA9IFN0cmluZyhiKX1cblxuICAgICAgICByZXR1cm4gYT8udG9Mb3dlckNhc2UoKS5lbmRzV2l0aChiPy50b0xvd2VyQ2FzZSgpKSB8fCBmYWxzZVxuICAgIH1cblxuICAgIHN0YXRpYyBbJ2V4Y2x1ZGVkJ10oYSwgYikge1xuICAgICAgICByZXR1cm4gYi5pbmRleE9mKGEpIDwgMFxuICAgIH1cblxuICAgIHN0YXRpYyBbJ2luY2x1ZGVkJ10oYSwgYikge1xuICAgICAgICByZXR1cm4gYi5pbmRleE9mKGEpID4gLTFcbiAgICB9XG5cbiAgICBzdGF0aWMgWydpc0RlZmluZWQnXShhLCBiKSB7XG4gICAgICAgIHJldHVybiBhICE9PSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICBzdGF0aWMgWydpc1VuZGVmaW5lZCddKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPT09IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIHN0YXRpYyBbJ2xpa2UnXShhLCBiKSB7XG4gICAgICAgIGlmICghTmVvLmlzU3RyaW5nKGEpKSB7YSA9IFN0cmluZyhhKX1cbiAgICAgICAgaWYgKCFOZW8uaXNTdHJpbmcoYikpIHtiID0gU3RyaW5nKGIpfVxuXG4gICAgICAgIHJldHVybiBhPy50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGI/LnRvTG93ZXJDYXNlKCkpIHx8IGZhbHNlXG4gICAgfVxuXG4gICAgc3RhdGljIFsnc3RhcnRzV2l0aCddKGEsIGIpIHtcbiAgICAgICAgaWYgKCFOZW8uaXNTdHJpbmcoYSkpIHthID0gU3RyaW5nKGEpfVxuICAgICAgICBpZiAoIU5lby5pc1N0cmluZyhiKSkge2IgPSBTdHJpbmcoYil9XG5cbiAgICAgICAgcmV0dXJuIGE/LnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChiPy50b0xvd2VyQ2FzZSgpKSB8fCBmYWxzZVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoRmlsdGVyKTtcbiIsImltcG9ydCBCYXNlICAgICAgIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuaW1wb3J0IE9ic2VydmFibGUgZnJvbSAnLi4vY29yZS9PYnNlcnZhYmxlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jb2xsZWN0aW9uLlNvcnRlclxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICogQG1peGVzIE5lby5jb3JlLk9ic2VydmFibGVcbiAqL1xuY2xhc3MgU29ydGVyIGV4dGVuZHMgQmFzZSB7XG4gICAgLyoqXG4gICAgICogVHJ1ZSBhdXRvbWF0aWNhbGx5IGFwcGxpZXMgdGhlIGNvcmUuT2JzZXJ2YWJsZSBtaXhpblxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG9ic2VydmFibGU9dHJ1ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgb2JzZXJ2YWJsZSA9IHRydWVcblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbGxlY3Rpb24uU29ydGVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29sbGVjdGlvbi5Tb3J0ZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nc29ydGVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3NvcnRlcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBjb25maWcgd2hpY2ggbWFwcyB0aGUgZGlyZWN0aW9uIEFTQyB0byAxLCAtMSBvdGhlcndpc2VcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBkaXJlY3Rpb25NdWx0aXBsaWVyPTFcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgZGlyZWN0aW9uTXVsdGlwbGllcjogMSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzb3J0IGRpcmVjdGlvbiB3aGVuIHVzaW5nIGEgcHJvcGVydHkuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gZGlyZWN0aW9uXz0nQVNDJ1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGRpcmVjdGlvbl86ICdBU0MnLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG93bmVyIHV0aWwuQ29sbGVjdGlvbiBuZWVkcyB0byBhcHBseSBhbiBvbkNoYW5nZSBsaXN0ZW5lciBvbmNlXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59IGxpc3RlbmVyQXBwbGllZD1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBsaXN0ZW5lckFwcGxpZWQ6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHByb3BlcnR5IHRvIHNvcnQgYnkuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gcHJvcGVydHlfPSdpZCdcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBwcm9wZXJ0eV86ICdpZCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm92aWRlIGEgY3VzdG9tIHNvcnRpbmcgZnVuY3Rpb24sIGhhcyBhIGhpZ2hlciBwcmlvcml0eSB0aGFuIHByb3BlcnR5ICYgZGlyZWN0aW9uXG4gICAgICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufG51bGx9IHNvcnRCeT1udWxsXG4gICAgICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQ29sbGF0b3JcbiAgICAgICAgICovXG4gICAgICAgIHNvcnRCeTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgdG8gdXNlIHRoZSB0cmFuc2Zvcm1WYWx1ZSBtZXRob2QgZm9yIGVhY2ggaXRlbSAodGhlIG1ldGhvZCBjYW4gZ2V0IG92ZXJyaWRkZW4pXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHVzZVRyYW5zZm9ybVZhbHVlPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdXNlVHJhbnNmb3JtVmFsdWU6IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhZnRlclNldERpcmVjdGlvbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5kaXJlY3Rpb25NdWx0aXBsaWVyID0gdmFsdWUgPT09ICdBU0MnID8gMSA6IC0xO1xuXG4gICAgICAgIGlmIChvbGRWYWx1ZSkge1xuICAgICAgICAgICAgbWUuZmlyZSgnY2hhbmdlJywge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogbWUuZGlyZWN0aW9uLFxuICAgICAgICAgICAgICAgIHByb3BlcnR5IDogbWUucHJvcGVydHlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICovXG4gICAgYWZ0ZXJTZXRQcm9wZXJ0eSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgIG1lLmZpcmUoJ2NoYW5nZScsIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246IG1lLmRpcmVjdGlvbixcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSA6IG1lLnByb3BlcnR5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgc29ydGVyIGZ1bmN0aW9uIHdoaWNoIGdldHMgdXNlZCBieSBjb2xsZWN0aW9ucyBpbiBjYXNlIGF0IGxlYXN0IG9uZSBzb3J0ZXIgaGFzIGEgcmVhbCBzb3J0QnkgbWV0aG9kXG4gICAgICogQHBhcmFtIGFcbiAgICAgKiBAcGFyYW0gYlxuICAgICAqL1xuICAgIGRlZmF1bHRTb3J0QnkoYSwgYikge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGEgPSBhW21lLnByb3BlcnR5XTtcbiAgICAgICAgYiA9IGJbbWUucHJvcGVydHldO1xuXG4gICAgICAgIGlmIChtZS51c2VUcmFuc2Zvcm1WYWx1ZSkge1xuICAgICAgICAgICAgYSA9IG1lLnRyYW5zZm9ybVZhbHVlKGEpO1xuICAgICAgICAgICAgYiA9IG1lLnRyYW5zZm9ybVZhbHVlKGIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGEgPiBiKSB7XG4gICAgICAgICAgICByZXR1cm4gMSAqIG1lLmRpcmVjdGlvbk11bHRpcGxpZXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgICAgIHJldHVybiAtMSAqIG1lLmRpcmVjdGlvbk11bHRpcGxpZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOZWVkZWQgZm9yIHJlbW90ZSBzb3J0aW5nXG4gICAgICogQHJldHVybnMge09iamVjdHxudWxsfVxuICAgICAqL1xuICAgIGV4cG9ydCgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7ZGlyZWN0aW9uLCBwcm9wZXJ0eX0gPSBtZTtcblxuICAgICAgICBpZiAoIW1lLnNvcnRCeSAmJiBkaXJlY3Rpb24gJiYgcHJvcGVydHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7ZGlyZWN0aW9uLCBwcm9wZXJ0eX1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHsqfSB2YWx1ZVxuICAgICAqL1xuICAgIHRyYW5zZm9ybVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoU29ydGVyKTtcbiIsImltcG9ydCBCYXNlICAgICAgICAgICAgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQgQ2xhc3NTeXN0ZW1VdGlsIGZyb20gJy4uL3V0aWwvQ2xhc3NTeXN0ZW0ubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNvbnRyb2xsZXIuQXBwbGljYXRpb25cbiAqIEBleHRlbmRzIE5lby5jb250cm9sbGVyLkJhc2VcbiAqL1xuY2xhc3MgQXBwbGljYXRpb24gZXh0ZW5kcyBCYXNlIHtcbiAgICAvKipcbiAgICAgKiBUcnVlIGF1dG9tYXRpY2FsbHkgYXBwbGllcyB0aGUgY29yZS5PYnNlcnZhYmxlIG1peGluXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gb2JzZXJ2YWJsZT10cnVlXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBvYnNlcnZhYmxlID0gdHJ1ZVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29udHJvbGxlci5BcHBsaWNhdGlvbidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbnRyb2xsZXIuQXBwbGljYXRpb24nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nYXBwbGljYXRpb24nXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnYXBwbGljYXRpb24nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGFwcFRoZW1lRm9sZGVyPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGFwcFRoZW1lRm9sZGVyOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbXBvbmVudC5CYXNlfSBtYWluVmlld189bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIG1haW5WaWV3XzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG1vdW50ZWQ9ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbW91bnRlZDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG5hbWU9J015QXBwJ1xuICAgICAgICAgKi9cbiAgICAgICAgbmFtZTogJ015QXBwJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gcGFyZW50SWQ9J2RvY3VtZW50LmJvZHknXG4gICAgICAgICAqL1xuICAgICAgICBwYXJlbnRJZDogJ2RvY3VtZW50LmJvZHknLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gcmVuZGVyZWQ9ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVuZGVyZWQ6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gcmVuZGVyaW5nPWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHJlbmRlcmluZzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gd2luZG93SWQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgd2luZG93SWQ6IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICAvLyB0byBndWFyYW50ZWUgdGhhdCB0aGUgbWFpbiB2aWV3IGNhbiBhY2Nlc3MgTmVvLmFwcHMgYXQgYW55IHBvaW50LFxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHRyaWdnZXIgaXRzIGFzc2lnbm1lbnQgYXQgdGhlIGVuZCBvZiB0aGUgY3Rvci5cbiAgICAgICAgbGV0IG1haW5WaWV3ID0gY29uZmlnLm1haW5WaWV3O1xuICAgICAgICBkZWxldGUgY29uZmlnLm1haW5WaWV3O1xuXG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUud2luZG93SWQgPSBOZW8uY29uZmlnLndpbmRvd0lkO1xuXG4gICAgICAgIE5lby5hcHBzID0gTmVvLmFwcHMgfHwge307XG5cbiAgICAgICAgTmVvLmFwcHNbbWUubmFtZV0gPSBtZTtcblxuICAgICAgICBOZW8uY3VycmVudFdvcmtlci5yZWdpc3RlckFwcChtZS5uYW1lKTtcblxuICAgICAgICBpZiAobWFpblZpZXcpIHtcbiAgICAgICAgICAgIG1lLm1haW5WaWV3ID0gbWFpblZpZXdcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbWFpblZpZXcgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYXN5bmMgYWZ0ZXJTZXRNYWluVmlldyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgICAgICAvLyBzaG9ydCBkZWxheSB0byBlbnN1cmUgY2hhbmdlcyBmcm9tIG9uSGFzaENoYW5nZSgpIGdvdCBhcHBsaWVkXG4gICAgICAgICAgICBhd2FpdCBtZS50aW1lb3V0KE5lby5jb25maWcuaGFzaCA/IDIwMCA6IDEwKTtcblxuICAgICAgICAgICAgYXdhaXQgdmFsdWUucmVuZGVyKHRydWUpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBtYWluVmlldyBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0TWFpblZpZXcodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIENsYXNzU3lzdGVtVXRpbC5iZWZvcmVTZXRJbnN0YW5jZSh2YWx1ZSwgbnVsbCwge1xuICAgICAgICAgICAgICAgIGFwcE5hbWUgOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgcGFyZW50SWQ6IHRoaXMucGFyZW50SWQsXG4gICAgICAgICAgICAgICAgd2luZG93SWQ6IE5lby5jb25maWcud2luZG93SWRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVucmVnaXN0ZXIgdGhlIGFwcCBmcm9tIHRoZSBDU1MgbWFwXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICBkZXN0cm95KC4uLmFyZ3MpIHtcbiAgICAgICAgTmVvLmN1cnJlbnRXb3JrZXIucmVtb3ZlQXBwRnJvbVRoZW1lTWFwKHRoaXMubmFtZSk7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koLi4uYXJncylcbiAgICB9XG59XG5cbkFwcGxpY2F0aW9uID0gTmVvLnNldHVwQ2xhc3MoQXBwbGljYXRpb24pO1xuXG4vLyBjb252ZW5pZW5jZSBzaG9ydGN1dFxuTmVvLmFwcCA9IGNvbmZpZyA9PiBOZW8uY3JlYXRlKHtcbiAgICBtb2R1bGU6IEFwcGxpY2F0aW9uLFxuICAgIC4uLmNvbmZpZ1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IEFwcGxpY2F0aW9uO1xuIiwiaW1wb3J0IEJhc2UgICAgICAgIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuaW1wb3J0IEhhc2hIaXN0b3J5IGZyb20gJy4uL3V0aWwvSGFzaEhpc3RvcnkubWpzJztcblxuY29uc3RcbiAgICByZWdleEFtb3VudFNsYXNoZXMgICAgICAgPSAvXFwvL2csXG4gICAgLy8gUmVnZXggdG8gZXh0cmFjdCB0aGUgcGFyYW1ldGVyIG5hbWUgZnJvbSBhIHNpbmdsZSByb3V0ZSBzZWdtZW50IChlLmcuLCB7Kml0ZW1JZH0gLT4gaXRlbUlkKVxuICAgIHJlZ2V4UGFyYW1OYW1lRXh0cmFjdGlvbiA9IC97KFxcKnxcXC5cXC5cXC4pPyhbXn1dKyl9LyxcbiAgICAvLyBSZWdleCB0byBtYXRjaCByb3V0ZSBwYXJhbWV0ZXJzIGxpa2Uge3BhcmFtTmFtZX0sIHsqcGFyYW1OYW1lfSwgb3Igey4uLnBhcmFtTmFtZX1cbiAgICByZWdleFJvdXRlUGFyYW0gICAgICAgICAgPSAveyhcXCp8XFwuXFwuXFwuKT8oW159XSspfS9nO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uY29udHJvbGxlci5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIENvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb250cm9sbGVyLkJhc2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb250cm9sbGVyLkJhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nY29udHJvbGxlcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdjb250cm9sbGVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSBVUkwgZG9lcyBub3QgY29udGFpbiBhIGhhc2ggdmFsdWUgd2hlbiB0aGlzIGNvbnRyb2xsZXIgaW5zdGFuY2UgaXMgY3JlYXRlZCxcbiAgICAgICAgICogTmVvLm1qcyB3aWxsIGF1dG9tYXRpY2FsbHkgc2V0IHRoaXMgaGFzaCB2YWx1ZSwgZW5zdXJpbmcgYSBkZWZhdWx0IHJvdXRlIGlzIGFjdGl2ZS5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGRlZmF1bHRIYXNoPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRlZmF1bHRIYXNoOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBoYW5kbGVyIG1ldGhvZCB0byBiZSBpbnZva2VkIHdoZW4gbm8gb3RoZXIgZGVmaW5lZCByb3V0ZSBtYXRjaGVzIHRoZSBVUkwgaGFzaC5cbiAgICAgICAgICogVGhpcyBhY3RzIGFzIGEgZmFsbGJhY2sgZm9yIHVuaGFuZGxlZCByb3V0ZXMuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBkZWZhdWx0Um91dGU9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZGVmYXVsdFJvdXRlOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgbWFwIG9mIGNvbXBpbGVkIHJlZ3VsYXIgZXhwcmVzc2lvbnMgZm9yIGVhY2ggcm91dGUsIHVzZWQgZm9yIGVmZmljaWVudCBoYXNoIG1hdGNoaW5nLlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gaGFuZGxlUm91dGVzPXt9XG4gICAgICAgICAqL1xuICAgICAgICBoYW5kbGVSb3V0ZXM6IHt9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lcyB0aGUgcm91dGluZyBydWxlcyBmb3IgdGhlIGNvbnRyb2xsZXIuIEtleXMgYXJlIHJvdXRlIHBhdHRlcm5zLCBhbmQgdmFsdWVzIGFyZSBlaXRoZXJcbiAgICAgICAgICogaGFuZGxlciBtZXRob2QgbmFtZXMgKFN0cmluZykgb3Igb2JqZWN0cyBjb250YWluaW5nIGBoYW5kbGVyYCBhbmQgb3B0aW9uYWwgYHByZUhhbmRsZXJgIG1ldGhvZCBuYW1lcy5cbiAgICAgICAgICogUm91dGUgcGF0dGVybnMgY2FuIGluY2x1ZGUgcGFyYW1ldGVycyBsaWtlIGB7cGFyYW1OYW1lfWAgYW5kIHdpbGRjYXJkcyBsaWtlIGB7KnBhcmFtTmFtZX1gIGZvciBuZXN0ZWQgcGF0aHMuXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIHJvdXRlczoge1xuICAgICAgICAgKiAgICAgJy9ob21lJyAgICAgICAgICAgICAgICAgICAgICAgICA6ICdoYW5kbGVIb21lUm91dGUnLFxuICAgICAgICAgKiAgICAgJy91c2Vycy97dXNlcklkfScgICAgICAgICAgICAgICA6IHtoYW5kbGVyOiAnaGFuZGxlVXNlclJvdXRlJywgcHJlSGFuZGxlcjogJ3ByZUhhbmRsZVVzZXJSb3V0ZSd9LFxuICAgICAgICAgKiAgICAgJy91c2Vycy97dXNlcklkfS9wb3N0cy97cG9zdElkfSc6ICdoYW5kbGVQb3N0Um91dGUnLFxuICAgICAgICAgKiAgICAgJy9sZWFybi97Kml0ZW1JZH0nICAgICAgICAgICAgICA6ICdvbkxlYXJuUm91dGUnLCAvLyBDYXB0dXJlcyBuZXN0ZWQgcGF0aHMgbGlrZSAvbGVhcm4vZ2V0dGluZ3N0YXJ0ZWQvV29ya3NwYWNlc1xuICAgICAgICAgKiAgICAgJ2RlZmF1bHQnICAgICAgICAgICAgICAgICAgICAgICA6ICdoYW5kbGVPdGhlclJvdXRlcydcbiAgICAgICAgICogfVxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHJvdXRlc189e31cbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICByb3V0ZXNfOiB7fVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ29udHJvbGxlciBpbnN0YW5jZSBhbmQgcmVnaXN0ZXJzIGl0cyBgb25IYXNoQ2hhbmdlYCBtZXRob2RcbiAgICAgKiB0byBsaXN0ZW4gZm9yIGNoYW5nZXMgaW4gdGhlIGJyb3dzZXIncyBVUkwgaGFzaC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcbiAgICAgICAgSGFzaEhpc3Rvcnkub24oJ2NoYW5nZScsIHRoaXMub25IYXNoQ2hhbmdlLCB0aGlzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2Nlc3NlcyB0aGUgZGVmaW5lZCByb3V0ZXMgY29uZmlndXJhdGlvbiwgY29tcGlsaW5nIHJvdXRlIHBhdHRlcm5zIGludG8gcmVndWxhciBleHByZXNzaW9uc1xuICAgICAqIGZvciBlZmZpY2llbnQgbWF0Y2hpbmcgYW5kIHNvcnRpbmcgdGhlbSBieSBzcGVjaWZpY2l0eSAobW9yZSBzbGFzaGVzIGZpcnN0KS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRSb3V0ZXModmFsdWUsIG9sZFZhbHVlKXtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICByb3V0ZUtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG5cbiAgICAgICAgIG1lLnJvdXRlcyA9IHJvdXRlS2V5cy5zb3J0KG1lLiNzb3J0Um91dGVzKS5yZWR1Y2UoKG9iaiwga2V5KSA9PiB7XG4gICAgICAgICAgICAgb2JqW2tleV0gPSB2YWx1ZVtrZXldO1xuICAgICAgICAgICAgIHJldHVybiBvYmpcbiAgICAgICAgIH0sIHt9KTtcblxuICAgICAgICBtZS5oYW5kbGVSb3V0ZXMgPSB7fTtcblxuICAgICAgICByb3V0ZUtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgaWYgKGtleS50b0xvd2VyQ2FzZSgpID09PSAnZGVmYXVsdCcpe1xuICAgICAgICAgICAgICAgIG1lLmRlZmF1bHRSb3V0ZSA9IHZhbHVlW2tleV1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWUuaGFuZGxlUm91dGVzW2tleV0gPSBuZXcgUmVnRXhwKGtleS5yZXBsYWNlKHJlZ2V4Um91dGVQYXJhbSwgKG1hdGNoLCBpc1dpbGRjYXJkLCBwYXJhbU5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzV2lsZGNhcmQgfHwgcGFyYW1OYW1lLnN0YXJ0c1dpdGgoJyonKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcoLiopJ1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcoW1xcXFx3LS5dKyknXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqL1xuICAgIGRlc3Ryb3koLi4uYXJncykge1xuICAgICAgICBIYXNoSGlzdG9yeS51bignY2hhbmdlJywgdGhpcy5vbkhhc2hDaGFuZ2UsIHRoaXMpO1xuICAgICAgICBzdXBlci5kZXN0cm95KC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYXN5bmMgaW5pdEFzeW5jKCkge1xuICAgICAgICBhd2FpdCBzdXBlci5pbml0QXN5bmMoKTtcblxuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2RlZmF1bHRIYXNoLCB3aW5kb3dJZH0gPSBtZSxcbiAgICAgICAgICAgIGN1cnJlbnRIYXNoICAgICAgICAgICAgID0gSGFzaEhpc3RvcnkuZmlyc3Qod2luZG93SWQpO1xuXG4gICAgICAgIGlmIChjdXJyZW50SGFzaCkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRIYXNoLndpbmRvd0lkID09PSB3aW5kb3dJZCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IG1lLm9uSGFzaENoYW5nZShjdXJyZW50SGFzaCwgbnVsbClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiB3b3JrZXIuQXBwOiBvbkxvYWRBcHBsaWNhdGlvbigpIHdpbGwgcHVzaCBjb25maWcuaGFzaCBpbnRvIHRoZSBIYXNoSGlzdG9yeSB3aXRoIGEgNW1zIGRlbGF5LlxuICAgICAgICAgICAgICogV2Ugb25seSB3YW50IHRvIHNldCBhIGRlZmF1bHQgcm91dGUsIGluIGNhc2UgdGhlIEhhc2hIaXN0b3J5IGlzIGVtcHR5IGFuZCB0aGVyZSBpcyBubyBpbml0aWFsXG4gICAgICAgICAgICAgKiB2YWx1ZSB0aGF0IHdpbGwgZ2V0IGNvbnN1bWVkLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAhTmVvLmNvbmZpZy5oYXNoICYmIGRlZmF1bHRIYXNoICYmIE5lby5NYWluLnNldFJvdXRlKHt2YWx1ZTogZGVmYXVsdEhhc2gsIHdpbmRvd0lkfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgY2hhbmdlcyBpbiB0aGUgYnJvd3NlcidzIFVSTCBoYXNoLiBJdCBpZGVudGlmaWVzIHRoZSBtb3N0IHNwZWNpZmljIG1hdGNoaW5nIHJvdXRlXG4gICAgICogYW5kIGRpc3BhdGNoZXMgdGhlIGNvcnJlc3BvbmRpbmcgaGFuZGxlciwgb3B0aW9uYWxseSBleGVjdXRpbmcgYSBwcmVIYW5kbGVyIGZpcnN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSAtIFRoZSBuZXcgaGFzaCBoaXN0b3J5IGVudHJ5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRWYWx1ZSAtIFRoZSBwcmV2aW91cyBoYXNoIGhpc3RvcnkgZW50cnkuXG4gICAgICovXG4gICAgYXN5bmMgb25IYXNoQ2hhbmdlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICAvLyBXZSBvbmx5IHdhbnQgdG8gdHJpZ2dlciBoYXNoIGNoYW5nZXMgZm9yIHRoZSBzYW1lIGJyb3dzZXIgd2luZG93IChTaGFyZWRXb3JrZXIgY29udGV4dClcbiAgICAgICAgaWYgKHZhbHVlLndpbmRvd0lkICE9PSB0aGlzLndpbmRvd0lkKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtoYW5kbGVSb3V0ZXMsIHJvdXRlc30gPSBtZSxcbiAgICAgICAgICAgIHJvdXRlS2V5cyAgICAgICAgICAgICAgPSBPYmplY3Qua2V5cyhoYW5kbGVSb3V0ZXMpLFxuICAgICAgICAgICAgYmVzdE1hdGNoICAgICAgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICBiZXN0TWF0Y2hLZXkgICAgICAgICAgID0gbnVsbCxcbiAgICAgICAgICAgIGJlc3RNYXRjaFBhcmFtcyAgICAgICAgPSBudWxsO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm91dGVLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSByb3V0ZUtleXNbaV07XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZS5oYXNoU3RyaW5nLm1hdGNoKGhhbmRsZVJvdXRlc1trZXldKTtcblxuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgICAgICAgIGFycmF5UGFyYW1JZHMgICAgPSBrZXkubWF0Y2gocmVnZXhSb3V0ZVBhcmFtKSxcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlQYXJhbVZhbHVlcyA9IHJlc3VsdC5zcGxpY2UoMSwgcmVzdWx0Lmxlbmd0aCAtIDEpLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbU9iamVjdCAgICAgID0ge307XG5cbiAgICAgICAgICAgICAgICBpZiAoYXJyYXlQYXJhbUlkcykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGFycmF5UGFyYW1JZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtTWF0Y2ggPSBhcnJheVBhcmFtSWRzW2pdLm1hdGNoKHJlZ2V4UGFyYW1OYW1lRXh0cmFjdGlvbik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyYW1OYW1lID0gcGFyYW1NYXRjaFsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbU9iamVjdFtwYXJhbU5hbWVdID0gYXJyYXlQYXJhbVZhbHVlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIExvZ2ljIHRvIGRldGVybWluZSB0aGUgYmVzdCBtYXRjaGluZyByb3V0ZTpcbiAgICAgICAgICAgICAgICAvLyAxLiBQcmlvcml0aXplIHJvdXRlcyB0aGF0IG1hdGNoIGEgbG9uZ2VyIHN0cmluZyAobW9yZSBzcGVjaWZpYyBtYXRjaCkuXG4gICAgICAgICAgICAgICAgLy8gMi4gSWYgbGVuZ3RocyBhcmUgZXF1YWwsIHByaW9yaXRpemUgcm91dGVzIHdpdGggbW9yZSBzbGFzaGVzIChkZWVwZXIgbmVzdGluZykuXG4gICAgICAgICAgICAgICAgaWYgKCFiZXN0TWF0Y2ggfHwgKHJlc3VsdFswXS5sZW5ndGggPiBiZXN0TWF0Y2hbMF0ubGVuZ3RoKSB8fFxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0WzBdLmxlbmd0aCA9PT0gYmVzdE1hdGNoWzBdLmxlbmd0aCAmJiAoa2V5Lm1hdGNoKHJlZ2V4QW1vdW50U2xhc2hlcykgfHwgW10pLmxlbmd0aCA+IChiZXN0TWF0Y2hLZXkubWF0Y2gocmVnZXhBbW91bnRTbGFzaGVzKSB8fCBbXSkubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2ggPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaEtleSA9IGtleTtcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoUGFyYW1zID0gcGFyYW1PYmplY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJlc3RNYXRjaCkge1xuICAgICAgICAgICAgY29uc3Qgcm91dGUgPSByb3V0ZXNbYmVzdE1hdGNoS2V5XTtcbiAgICAgICAgICAgIGxldCBoYW5kbGVyICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBwcmVIYW5kbGVyID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKE5lby5pc1N0cmluZyhyb3V0ZSkpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyID0gcm91dGVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTmVvLmlzT2JqZWN0KHJvdXRlKSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIgICAgPSByb3V0ZS5oYW5kbGVyO1xuICAgICAgICAgICAgICAgIHByZUhhbmRsZXIgPSByb3V0ZS5wcmVIYW5kbGVyXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCByZXNwb25zZVByZUhhbmRsZXIgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAocHJlSGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlUHJlSGFuZGxlciA9IGF3YWl0IG1lW3ByZUhhbmRsZXJdPy5jYWxsKG1lLCBiZXN0TWF0Y2hQYXJhbXMsIHZhbHVlLCBvbGRWYWx1ZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlUHJlSGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGF3YWl0IG1lW2hhbmRsZXJdPy5jYWxsKG1lLCBiZXN0TWF0Y2hQYXJhbXMsIHZhbHVlLCBvbGRWYWx1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtZS5kZWZhdWx0Um91dGUpIHtcbiAgICAgICAgICAgICAgICBtZVttZS5kZWZhdWx0Um91dGVdPy4odmFsdWUsIG9sZFZhbHVlKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZS5vbk5vUm91dGVGb3VuZCh2YWx1ZSwgb2xkVmFsdWUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQbGFjZWhvbGRlciBtZXRob2QgaW52b2tlZCB3aGVuIG5vIG1hdGNoaW5nIHJvdXRlIGlzIGZvdW5kIGZvciB0aGUgY3VycmVudCBVUkwgaGFzaC5cbiAgICAgKiBDb250cm9sbGVycyBjYW4gb3ZlcnJpZGUgdGhpcyB0byBpbXBsZW1lbnQgY3VzdG9tIGJlaGF2aW9yIGZvciB1bmhhbmRsZWQgcm91dGVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSAtIFRoZSBjdXJyZW50IGhhc2ggaGlzdG9yeSBlbnRyeS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2xkVmFsdWUgLSBUaGUgcHJldmlvdXMgaGFzaCBoaXN0b3J5IGVudHJ5LlxuICAgICAqL1xuICAgIG9uTm9Sb3V0ZUZvdW5kKHZhbHVlLCBvbGRWYWx1ZSkge1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgaGVscGVyIG1ldGhvZCB0byBzb3J0IHJvdXRlcyBieSB0aGVpciBzcGVjaWZpY2l0eS5cbiAgICAgKiBSb3V0ZXMgd2l0aCBtb3JlIHNsYXNoZXMgYXJlIGNvbnNpZGVyZWQgbW9yZSBzcGVjaWZpYyBhbmQgYXJlIHByaW9yaXRpemVkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByb3V0ZTEgLSBUaGUgZmlyc3Qgcm91dGUgc3RyaW5nIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHJvdXRlMiAtIFRoZSBzZWNvbmQgcm91dGUgc3RyaW5nIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge051bWJlcn0gQSBuZWdhdGl2ZSB2YWx1ZSBpZiByb3V0ZTEgaXMgbW9yZSBzcGVjaWZpYywgYSBwb3NpdGl2ZSB2YWx1ZSBpZiByb3V0ZTIgaXMgbW9yZSBzcGVjaWZpYywgb3IgMCBpZiB0aGV5IGhhdmUgZXF1YWwgc3BlY2lmaWNpdHkuXG4gICAgICovXG4gICAgI3NvcnRSb3V0ZXMocm91dGUxLCByb3V0ZTIpIHtcbiAgICAgICAgcmV0dXJuIChyb3V0ZTEubWF0Y2gocmVnZXhBbW91bnRTbGFzaGVzKSB8fCBbXSkubGVuZ3RoIC0gKHJvdXRlMi5tYXRjaChyZWdleEFtb3VudFNsYXNoZXMpfHwgW10pLmxlbmd0aFxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ29udHJvbGxlcik7XG4iLCJpbXBvcnQge2J1ZmZlciwgZGVib3VuY2UsIGludGVyY2VwdCwgcmVzb2x2ZUNhbGxiYWNrLCB0aHJvdHRsZX0gZnJvbSAnLi4vdXRpbC9GdW5jdGlvbi5tanMnO1xuaW1wb3J0IENvbXBhcmUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gJy4uL2NvcmUvQ29tcGFyZS5tanMnO1xuaW1wb3J0IFV0aWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gJy4uL2NvcmUvVXRpbC5tanMnO1xuaW1wb3J0IENvbmZpZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gJy4vQ29uZmlnLm1qcyc7XG5pbXBvcnQge2lzRGVzY3JpcHRvcn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSAnLi9Db25maWdTeW1ib2xzLm1qcyc7XG5pbXBvcnQgSWRHZW5lcmF0b3IgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSAnLi9JZEdlbmVyYXRvci5tanMnO1xuaW1wb3J0IEVmZmVjdE1hbmFnZXIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gJy4vRWZmZWN0TWFuYWdlci5tanMnO1xuXG5cbmNvbnN0IGNvbmZpZ1N5bWJvbCAgICAgICA9IFN5bWJvbC5mb3IoJ2NvbmZpZ1N5bWJvbCcpLFxuICAgICAgZm9yY2VBc3NpZ25Db25maWdzID0gU3ltYm9sKCdmb3JjZUFzc2lnbkNvbmZpZ3MnKSxcbiAgICAgIGlzSW5zdGFuY2UgICAgICAgICA9IFN5bWJvbCgnaXNJbnN0YW5jZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGNsYXNzIGZvciAoYWxtb3N0KSBhbGwgY2xhc3NlcyBpbnNpZGUgdGhlIE5lbyBuYW1lc3BhY2VcbiAqIEV4Y2VwdGlvbnMgYXJlIGUuZy4gY29yZS5JZEdlbmVyYXRvciwgdmRvbS5WTm9kZVxuICogQGNsYXNzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgQmFzZSB7XG4gICAgLyoqXG4gICAgICogWW91IGNhbiBkZWZpbmUgbWV0aG9kcyB3aGljaCBzaG91bGQgZ2V0IGRlbGF5ZWQuXG4gICAgICogVHlwZXMgYXJlIGJ1ZmZlciwgZGVib3VuY2UgJiB0aHJvdHRsZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICBkZWxheWFibGU6IHtcbiAgICAgKiAgICAgIGZpcmVDaGFuZ2VFdmVudDoge1xuICAgICAqICAgICAgICAgIHR5cGUgOiAnZGVib3VuY2UnLFxuICAgICAqICAgICAgICAgIHRpbWVyOiAzMDBcbiAgICAgKiAgICAgIH1cbiAgICAgKiAgfVxuICAgICAqIEBtZW1iZXIge09iamVjdH0gZGVsYXlhYmxlPXt9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgZGVsYXlhYmxlID0ge31cbiAgICAvKipcbiAgICAgKiBGbGFnIHdoaWNoIHdpbGwgZ2V0IHNldCB0byB0cnVlIG9uY2UgbWFuYWdlci5JbnN0YW5jZSBnb3QgY3JlYXRlZFxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGluc3RhbmNlTWFuYWdlckF2YWlsYWJsZT1mYWxzZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgaW5zdGFuY2VNYW5hZ2VyQXZhaWxhYmxlID0gZmFsc2VcbiAgICAvKipcbiAgICAgKiBSZWdleCB0byBncmFiIHRoZSBNZXRob2ROYW1lIGZyb20gYW4gZXJyb3JcbiAgICAgKiB3aGljaCBpcyBhIHNlY29uZCBnZW5lcmF0aW9uIGZ1bmN0aW9uXG4gICAgICogQG1lbWJlciB7UmVnRXhwfSBtZXRob2ROYW1lUmVnZXhcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIG1ldGhvZE5hbWVSZWdleCA9IC9cXG4uKlxcblxccythdFxccysuKlxcLihcXHcrKVxccysuKi9cbiAgICAvKipcbiAgICAgKiBUcnVlIGF1dG9tYXRpY2FsbHkgYXBwbGllcyB0aGUgY29yZS5PYnNlcnZhYmxlIG1peGluXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gb2JzZXJ2YWJsZT1mYWxzZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgb2JzZXJ2YWJsZSA9IGZhbHNlXG4gICAgLyoqXG4gICAgICogS2VlcCB0aGUgb3ZlcndyaXR0ZW4gbWV0aG9kc1xuICAgICAqIEBtZW1iZXIge09iamVjdH0gb3ZlcndyaXR0ZW5NZXRob2RzPXt9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgb3ZlcndyaXR0ZW5NZXRob2RzID0ge31cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcyBmb3IgdGhlIGNsYXNzLiBUaGVzZSBjb25maWd1cmF0aW9ucyBhcmVcbiAgICAgKiBtZXJnZWQgdGhyb3VnaG91dCB0aGUgY2xhc3MgaGllcmFyY2h5IGFuZCBjYW4gYmUgb3ZlcnJpZGRlbiBhdCB0aGUgaW5zdGFuY2UgbGV2ZWwuXG4gICAgICpcbiAgICAgKiBUaGVyZSBhcmUgdHdvIG1haW4gdHlwZXMgb2YgY29uZmlnczpcbiAgICAgKlxuICAgICAqIDEuICAqKlJlYWN0aXZlIENvbmZpZ3M6KiogUHJvcGVydHkgbmFtZXMgZW5kaW5nIHdpdGggYSB0cmFpbGluZyB1bmRlcnNjb3JlIChlLmcuLCBgbXlDb25maWdfYCkuXG4gICAgICogICAgIFRoZSBmcmFtZXdvcmsgYXV0b21hdGljYWxseSBnZW5lcmF0ZXMgYSBwdWJsaWMgZ2V0dGVyIGFuZCBzZXR0ZXIsIHJlbW92aW5nIHRoZSB1bmRlcnNjb3JlXG4gICAgICogICAgIGZyb20gdGhlIHByb3BlcnR5IG5hbWUgKGUuZy4sIGB0aGlzLm15Q29uZmlnYCkuIFRoaXMgc3lzdGVtIGVuYWJsZXMgcG93ZXJmdWwsIG9wdGlvbmFsXG4gICAgICogICAgIGxpZmVjeWNsZSBob29rcyB0aGF0IGFyZSBjYWxsZWQgYXV0b21hdGljYWxseSBpZiB0aGV5IGFyZSBpbXBsZW1lbnRlZCBvbiB0aGUgY2xhc3M6XG4gICAgICogICAgIC0gYGJlZm9yZUdldE15Q29uZmlnKHZhbHVlKWA6IEV4ZWN1dGVkIGJlZm9yZSB0aGUgZ2V0dGVyIHJldHVybnMuIENhbiBiZSB1c2VkIHRvIGR5bmFtaWNhbGx5IG1vZGlmeSB0aGUgcmV0dXJuZWQgdmFsdWUuXG4gICAgICogICAgIC0gYGJlZm9yZVNldE15Q29uZmlnKG5ld1ZhbHVlLCBvbGRWYWx1ZSlgOiBFeGVjdXRlZCBiZWZvcmUgYSBuZXcgdmFsdWUgaXMgc2V0LiBDYW4gYmUgdXNlZCBmb3IgdmFsaWRhdGlvbiBvciB0cmFuc2Zvcm1hdGlvbi4gUmV0dXJuaW5nIGB1bmRlZmluZWRgIGZyb20gdGhpcyBob29rIHdpbGwgY2FuY2VsIHRoZSB1cGRhdGUuXG4gICAgICogICAgIC0gYGFmdGVyU2V0TXlDb25maWcobmV3VmFsdWUsIG9sZFZhbHVlKWA6IEV4ZWN1dGVkIGFmdGVyIGEgbmV3IHZhbHVlIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBzZXQuIElkZWFsIGZvciB0cmlnZ2VyaW5nIHNpZGUgZWZmZWN0cy5cbiAgICAgKlxuICAgICAqIDIuICAqKk5vbi1SZWFjdGl2ZSAoUHJvdG90eXBlLWJhc2VkKSBDb25maWdzOioqIFByb3BlcnR5IG5hbWVzIHdpdGhvdXQgYSB0cmFpbGluZyB1bmRlcnNjb3JlLlxuICAgICAqICAgICBUaGVzZSBhcmUgYXBwbGllZCBkaXJlY3RseSB0byB0aGUgY2xhc3MncyAqKnByb3RvdHlwZSoqIGR1cmluZyB0aGUgYE5lby5zZXR1cENsYXNzYFxuICAgICAqICAgICBwcm9jZXNzLiBUaGlzIGlzIGhpZ2hseSBtZW1vcnktZWZmaWNpZW50IGFzIHRoZSB2YWx1ZSBpcyBzaGFyZWQgYWNyb3NzIGFsbCBpbnN0YW5jZXMuXG4gICAgICogICAgIEl0IGFsc28gYWxsb3dzIGZvciBwb3dlcmZ1bCwgYXBwbGljYXRpb24td2lkZSBtb2RpZmljYXRpb25zIG9mIGRlZmF1bHQgYmVoYXZpb3JzXG4gICAgICogICAgIGJ5IHVzaW5nIHRoZSBgTmVvLm92ZXJ3cml0ZXNgIG1lY2hhbmlzbSwgd2hpY2ggbW9kaWZpZXMgdGhlc2UgcHJvdG90eXBlIHZhbHVlcyBhdFxuICAgICAqICAgICBsb2FkIHRpbWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNsYXNzIG5hbWUgd2hpY2ggd2lsbCBnZXQgbWFwcGVkIGludG8gdGhlIE5lbyBvciBhcHAgbmFtZXNwYWNlXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29yZS5CYXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29yZS5CYXNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjbGFzcyBzaG9ydGN1dC1uYW1lIHRvIHVzZSBmb3IgZS5nLiBjcmVhdGluZyBjaGlsZCBjb21wb25lbnRzIGluc2lkZSBhIEpTT04tZm9ybWF0XG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2Jhc2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnYmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGlsZSBpdCBpcyByZWNvbW1lbmRlZCB0byBjaGFuZ2UgdGhlIHN0YXRpYyBkZWxheWFibGUgY29uZmlncyBvbiBjbGFzcyBsZXZlbCxcbiAgICAgICAgICogeW91IGNhbiBjaGFuZ2UgaXQgb24gaW5zdGFuY2UgbGV2ZWwgdG9vLiBJZiBub3QgbnVsbCwgd2Ugd2lsbCBkbyBhIGRlZXAgbWVyZ2UuXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gZGVsYXlhYmxlPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRlbGF5YWJsZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB1bmlxdWUgY29tcG9uZW50IGlkXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBpZF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGlkXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFycmF5IG9mIHJlbW90ZSBtZXRob2QgbmFtZXMgdGhhdCBzaG91bGQgYmUgaW50ZXJjZXB0ZWQuXG4gICAgICAgICAqIE5hbWVzIHVzZWQgaGVyZSBtdXN0IGJlIHByZXNlbnQgaW5zaWRlIHRoZSBgcmVtb3RlX2AgY29uZmlnLlxuICAgICAgICAgKiBJZiBhIHJlbW90ZSBjYWxsIGZvciBvbmUgb2YgdGhlc2UgbWV0aG9kcyBhcnJpdmVzLCBgb25JbnRlcmNlcHRSZW1vdGVzKClgIHdpbGwgYmUgY2FsbGVkLlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXXxudWxsfSBpbnRlcmNlcHRSZW1vdGVzPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaW50ZXJjZXB0UmVtb3RlczogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5lby5jcmVhdGUoKSB3aWxsIGNoYW5nZSB0aGlzIGZsYWcgdG8gdHJ1ZSBhZnRlciB0aGUgb25Db25zdHJ1Y3RlZCgpIGNoYWluIGlzIGRvbmUuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzQ29uc3RydWN0ZWQ9ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaXNDb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGNvbmZpZyB3aWxsIGJlIHNldCB0byBgdHJ1ZWAgYXMgdGhlIHZlcnkgZmlyc3QgYWN0aW9uIHdpdGhpbiB0aGUgYGRlc3Ryb3koKWAgbWV0aG9kLlxuICAgICAgICAgKiBFZmZlY3RzIGNhbiBvYnNlcnZlIHRoaXMgY29uZmlnIHRvIGNsZWFuIHRoZW1zZWx2ZXMgdXAuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzRGVzdHJveWluZ189ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGlzRGVzdHJveWluZ186IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvbmZpZyB3aWxsIGdldCBzZXQgdG8gYHRydWVgIG9uY2UgdGhlIFByb21pc2Ugb2YgYGFzeW5jIGluaXRBc3luYygpYCBpcyByZXNvbHZlZC5cbiAgICAgICAgICogWW91IGNhbiB1c2UgYGFmdGVyU2V0SXNSZWFkeSgpYCB0byBnZXQgbm90aWZpZWQgb25jZSB0aGUgcmVhZHkgc3RhdGUgaXMgcmVhY2hlZC5cbiAgICAgICAgICogU2luY2Ugbm90IGFsbCBjbGFzc2VzIHVzZSB0aGUgT2JzZXJ2YWJsZSBtaXhpbiwgTmVvIHdpbGwgbm90IGZpcmUgYW4gZXZlbnQuXG4gICAgICAgICAqIG1ldGhvZCBib2R5LlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc1JlYWR5Xz1mYWxzZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGlzUmVhZHlfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBtaXhpbnMgYXMgYW4gYXJyYXkgb2YgY2xhc3NOYW1lcywgaW1wb3J0ZWQgbW9kdWxlcyBvciBhIG1peGVkIHZlcnNpb25cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW118TmVvLmNvcmUuQmFzZVtdfG51bGx9IG1peGlucz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBtaXhpbnM6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBZb3UgY2FuIGNyZWF0ZSBhIG5ldyBpbnN0YW5jZSBieSBwYXNzaW5nIGFuIGltcG9ydGVkIGNsYXNzIChKUyBtb2R1bGUgZGVmYXVsdCBleHBvcnQpXG4gICAgICAgICAqIEBtZW1iZXIge0NsYXNzfSBtb2R1bGU9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBtb2R1bGU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdGUgbWV0aG9kIGFjY2VzcyBmb3Igb3RoZXIgdGhyZWFkcy4gRXhhbXBsZSB1c2UgY2FzZTpcbiAgICAgICAgICogcmVtb3RlOiB7YXBwOiBbJ215UmVtb3RlTWV0aG9kJ119XG4gICAgICAgICAqXG4gICAgICAgICAqIE9OTFkgc3VwcG9ydGVkIGZvciBzaW5nbGV0b25zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gcmVtb3RlXz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdGVfOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBwcml2YXRlIGZpZWxkIHRvIHN0b3JlIHRoZSBDb25maWcgY29udHJvbGxlciBpbnN0YW5jZXMuXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSAjY29uZmlncz17fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgI2NvbmZpZ3MgPSB7fTtcbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBjYWNoZSBmb3IgYWxsIGNvbmZpZyBzdWJzY3JpcHRpb24gY2xlYW51cCBmdW5jdGlvbnMuXG4gICAgICogQG1lbWJlciB7RnVuY3Rpb25bXX0gI2NvbmZpZ1N1YnNjcmlwdGlvbkNsZWFudXBzPVtdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICAjY29uZmlnU3Vic2NyaXB0aW9uQ2xlYW51cHMgPSBbXVxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGNhY2hlIGZvciBhbGwgdGltZW91dCBpZHMgd2hlbiB1c2luZyB0aGlzLnRpbWVvdXQoKVxuICAgICAqIEBtZW1iZXIge051bWJlcltdfSB0aW1lb3V0SWRzPVtdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICAjdGltZW91dElkcyA9IFtdXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWFpbiBpbml0aWFsaXplciBmb3IgYWxsIE5lby5tanMgY2xhc3NlcywgaW52b2tlZCBieSBgTmVvLmNyZWF0ZSgpYC5cbiAgICAgKiBOT1RFOiBUaGlzIGlzIG5vdCB0aGUgbmF0aXZlIGBjb25zdHJ1Y3RvcigpYCwgd2hpY2ggaXMgY2FsbGVkIHdpdGhvdXQgYXJndW1lbnRzIGJ5IGBOZW8uY3JlYXRlKClgIGZpcnN0LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2Qgb3JjaGVzdHJhdGVzIHRoZSBlbnRpcmUgaW5zdGFuY2UgaW5pdGlhbGl6YXRpb24gcHJvY2VzcywgaW5jbHVkaW5nXG4gICAgICogdGhlIHNldHVwIG9mIHRoZSBwb3dlcmZ1bCBhbmQgZmxleGlibGUgY29uZmlnIHN5c3RlbS5cbiAgICAgKlxuICAgICAqIFRoZSBgY29uZmlnYCBwYXJhbWV0ZXIgaXMgYSBzaW5nbGUgb2JqZWN0IHRoYXQgY2FuIGNvbnRhaW4gZGlmZmVyZW50IHR5cGVzIG9mIHByb3BlcnRpZXMsXG4gICAgICogd2hpY2ggYXJlIHByb2Nlc3NlZCBpbiBhIHNwZWNpZmljIG9yZGVyIHRvIGVuc3VyZSBjb25zaXN0ZW5jeSBhbmQgcHJlZGljdGFiaWxpdHk6XG4gICAgICpcbiAgICAgKiAxLiAgKipQdWJsaWMgQ2xhc3MgRmllbGRzICYgT3RoZXIgUHJvcGVydGllczoqKiBBbnkga2V5IGluIHRoZSBgY29uZmlnYCBvYmplY3QgdGhhdCBpcyBOT1RcbiAgICAgKiAgICAgZGVmaW5lZCBpbiB0aGUgY2xhc3MncyBgc3RhdGljIGNvbmZpZ2AgaGllcmFyY2h5IGlzIGNvbnNpZGVyZWQgYSBwdWJsaWMgZmllbGQgb3IgYVxuICAgICAqICAgICBkeW5hbWljIHByb3BlcnR5LiBUaGVzZSBhcmUgYXNzaWduZWQgZGlyZWN0bHkgdG8gdGhlIGluc3RhbmNlIChgdGhpcy5teUZpZWxkID0gdmFsdWVgKVxuICAgICAqICAgICBhdCB0aGUgdmVyeSBiZWdpbm5pbmcuIFRoaXMgaXMgY3J1Y2lhbCBzbyB0aGF0IHN1YnNlcXVlbnQgY29uZmlnIGhvb2tzIChsaWtlIGBhZnRlclNldCpgKVxuICAgICAqICAgICBjYW4gYWNjZXNzIHRoZWlyIGxhdGVzdCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAyLiAgKipSZWFjdGl2ZSBDb25maWdzOioqIEEgcHJvcGVydHkgaXMgY29uc2lkZXJlZCByZWFjdGl2ZSBpZiBpdCBpcyBkZWZpbmVkIHdpdGggYSB0cmFpbGluZ1xuICAgICAqICAgICB1bmRlcnNjb3JlIChlLmcuLCBgbXlWYWx1ZV9gKSBpbiB0aGUgYHN0YXRpYyBjb25maWdgIG9mICoqYW55IGNsYXNzIGluIHRoZSBpbmhlcml0YW5jZVxuICAgICAqICAgICBjaGFpbioqLiBTdWJjbGFzc2VzIGNhbiBwcm92aWRlIG5ldyBkZWZhdWx0IHZhbHVlcyBmb3IgdGhlc2UgY29uZmlncyB3aXRob3V0IHRoZVxuICAgICAqICAgICB1bmRlcnNjb3JlLCBhbmQgdGhleSB3aWxsIHN0aWxsIGJlIHJlYWN0aXZlLiBUaGVpciB2YWx1ZXMgYXJlIGFwcGxpZWQgdmlhIGdlbmVyYXRlZFxuICAgICAqICAgICBzZXR0ZXJzLCB0cmlnZ2VyaW5nIGBiZWZvcmVTZXQqYCBhbmQgYGFmdGVyU2V0KmAgaG9va3MsIGFuZCB0aGV5IGFyZSB3cmFwcGVkIGluIGFcbiAgICAgKiAgICAgYE5lby5jb3JlLkNvbmZpZ2AgaW5zdGFuY2UgdG8gZW5hYmxlIHN1YnNjcmlwdGlvbi1iYXNlZCByZWFjdGl2aXR5LlxuICAgICAqXG4gICAgICogMy4gICoqTm9uLVJlYWN0aXZlIENvbmZpZ3M6KiogUHJvcGVydGllcyBkZWZpbmVkIGluIGBzdGF0aWMgY29uZmlnYCB3aXRob3V0IGEgdHJhaWxpbmdcbiAgICAgKiAgICAgdW5kZXJzY29yZSBpbiB0aGVpciBlbnRpcmUgaW5oZXJpdGFuY2UgY2hhaW4uIFRoZWlyIGRlZmF1bHQgdmFsdWVzIGFyZSBhcHBsaWVkIGRpcmVjdGx5XG4gICAgICogICAgIHRvIHRoZSBjbGFzcyAqKnByb3RvdHlwZSoqLCBtYWtpbmcgdGhlbSBzaGFyZWQgYWNyb3NzIGFsbCBpbnN0YW5jZXMgYW5kIGFsbG93aW5nIGZvclxuICAgICAqICAgICBydW4tdGltZSBtb2RpZmljYXRpb25zIChwcm90b3R5cGFsIGluaGVyaXRhbmNlKS4gV2hlbiBhIG5ldyB2YWx1ZSBpcyBwYXNzZWQgdG8gdGhpc1xuICAgICAqICAgICBtZXRob2QsIGl0IGNyZWF0ZXMgYW4gaW5zdGFuY2Utc3BlY2lmaWMgcHJvcGVydHkgdGhhdCBzaGFkb3dzIHRoZSBwcm90b3R5cGUgdmFsdWUuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBhbHNvIGluaXRpYWxpemVzIHRoZSBvYnNlcnZhYmxlIG1peGluIChpZiBhcHBsaWNhYmxlKSBhbmQgc2NoZWR1bGVzIGFzeW5jaHJvbm91c1xuICAgICAqIGxvZ2ljIGxpa2UgYGluaXRBc3luYygpYCAod2hpY2ggaGFuZGxlcyByZW1vdGUgbWV0aG9kIGFjY2VzcykgdG8gcnVuIGFmdGVyIHRoZSBzeW5jaHJvbm91c1xuICAgICAqIGNvbnN0cnVjdGlvbiBjaGFpbiBpcyBjb21wbGV0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWc9e30gVGhlIGluaXRpYWwgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHRoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnPXt9KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobWUsIHtcbiAgICAgICAgICAgIFtjb25maWdTeW1ib2xdOiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGUgIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgdmFsdWUgICAgICAgOiB7fSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZSAgICA6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbaXNJbnN0YW5jZV06IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB2YWx1ZSAgICAgOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLmlkID0gY29uZmlnLmlkIHx8IElkR2VuZXJhdG9yLmdldElkKHRoaXMuZ2V0SWRLZXkoKSk7XG4gICAgICAgIGRlbGV0ZSBjb25maWcuaWQ7XG5cbiAgICAgICAgLy8gYXNzaWduIGNsYXNzIGZpZWxkIHZhbHVlcyBwcmlvciB0byBjb25maWdzXG4gICAgICAgIGNvbmZpZyA9IG1lLnNldEZpZWxkcyhjb25maWcpO1xuXG4gICAgICAgIG1lLmluaXRDb25maWcoY29uZmlnKTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWUsICdjb25maWdzQXBwbGllZCcsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWUgICAgIDogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBtZS5hcHBseURlbGF5YWJsZSgpO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFdlIGRvIG5vdCB3YW50IHRvIGZvcmNlIGRldnMgdG8gY2hlY2sgZm9yIHRoZSBgaXNEZXN0cm95ZWRgIGZsYWcgaW4gZXZlcnkgcG9zc2libGUgY2xhc3MgZXh0ZW5zaW9uLlxuICAgICAgICAgKiBTbywgd2UgYXJlIGludGVyY2VwdGluZyB0aGUgdG9wLW1vc3QgYGRlc3Ryb3koKWAgY2FsbCB0byBjaGVjayBmb3IgdGhlIGZsYWcgdGhlcmUuXG4gICAgICAgICAqIFJhdGlvbmFsZTogYGRlc3Ryb3koKWAgbXVzdCBvbmx5IGdldCBjYWxsZWQgb25jZS5cbiAgICAgICAgICovXG4gICAgICAgIGludGVyY2VwdChtZSwgJ2Rlc3Ryb3knLCBtZS5pc0Rlc3Ryb3llZENoZWNrLCBtZSk7XG5cbiAgICAgICAgLy8gVHJpZ2dlcnMgYXN5bmMgbG9naWMgYWZ0ZXIgdGhlIGNvbnN0cnVjdGlvbiBjaGFpbiBpcyBkb25lLlxuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IG1lLmluaXRBc3luYygpO1xuICAgICAgICAgICAgbWUuaXNSZWFkeSA9IHRydWVcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGlkIGNvbmZpZyBnb3QgY2hhbmdlZC5cbiAgICAgKiBZb3UgY2FuIGR5bmFtaWNhbGx5IGNoYW5nZSBpbnN0YW5jZSBpZHMgaWYgbmVlZGVkLiBUaGV5IG5lZWQgdG8gc3RheSB1bmlxdWUgYXQgYW55IGdpdmVuIHBvaW50LlxuICAgICAqIFVzZSBjYXNlOiBlLmcuIGNvbXBvbmVudCBiYXNlZCBsaXN0cywgd2hlcmUgeW91IHdhbnQgdG8gcmUtdXNlIGl0ZW0gaW5zdGFuY2VzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRJZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaGFzTWFuYWdlciA9IEJhc2UuaW5zdGFuY2VNYW5hZ2VyQXZhaWxhYmxlID09PSB0cnVlO1xuXG4gICAgICAgIGlmIChvbGRWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKGhhc01hbmFnZXIpIHtcbiAgICAgICAgICAgICAgICBOZW8ubWFuYWdlci5JbnN0YW5jZS51bnJlZ2lzdGVyKG9sZFZhbHVlKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChOZW8uaWRNYXApIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgTmVvLmlkTWFwW29sZFZhbHVlXVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoaGFzTWFuYWdlcikge1xuICAgICAgICAgICAgICAgIE5lby5tYW5hZ2VyLkluc3RhbmNlLnJlZ2lzdGVyKG1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgTmVvLmlkTWFwID8/PSB7fTtcbiAgICAgICAgICAgICAgICBOZW8uaWRNYXBbdmFsdWVdID0gbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkanVzdHMgYWxsIG1ldGhvZHMgaW5zaWRlIHN0YXRpYyBkZWxheWFibGVcbiAgICAgKi9cbiAgICBhcHBseURlbGF5YWJsZSgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY3RvckRlbGF5YWJsZSA9IG1lLmNvbnN0cnVjdG9yLmRlbGF5YWJsZSxcbiAgICAgICAgICAgIGRlbGF5YWJsZSAgICAgPSBtZS5kZWxheWFibGUgPyBOZW8ubWVyZ2Uoe30sIG1lLmRlbGF5YWJsZSwgY3RvckRlbGF5YWJsZSkgOiBjdG9yRGVsYXlhYmxlO1xuXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGRlbGF5YWJsZSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFwID0ge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXIoKSAgIHttZVtrZXldID0gbmV3IGJ1ZmZlcihtZVtrZXldLCAgIG1lLCB2YWx1ZS50aW1lcil9LFxuICAgICAgICAgICAgICAgICAgICBkZWJvdW5jZSgpIHttZVtrZXldID0gbmV3IGRlYm91bmNlKG1lW2tleV0sIG1lLCB2YWx1ZS50aW1lcil9LFxuICAgICAgICAgICAgICAgICAgICB0aHJvdHRsZSgpIHttZVtrZXldID0gbmV3IHRocm90dGxlKG1lW2tleV0sIG1lLCB2YWx1ZS50aW1lcil9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIG1hcFt2YWx1ZS50eXBlXT8uKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIHN0YXRpYyBtZXRob2QgaXMgY2FsbGVkIGJ5IGBOZW8uc2V0dXBDbGFzcygpYCBkdXJpbmcgdGhlIGNsYXNzIGNyZWF0aW9uIHByb2Nlc3MuXG4gICAgICogSXQgYWxsb3dzIGZvciBtb2RpZnlpbmcgYSBjbGFzcydzIGRlZmF1bHQgcHJvdG90eXBlLWJhc2VkIGNvbmZpZ3MgZnJvbSBvdXRzaWRlIHRoZVxuICAgICAqIGNsYXNzIGhpZXJhcmNoeSwgd2hpY2ggaXMgYSBwb3dlcmZ1bCB3YXkgdG8gYXZvaWQgYm9pbGVycGxhdGUgY29kZS5cbiAgICAgKlxuICAgICAqIEl0IGxvb2tzIGZvciBhIG1hdGNoaW5nIGVudHJ5IGluIHRoZSBnbG9iYWwgYE5lby5vdmVyd3JpdGVzYCBvYmplY3QgYmFzZWQgb24gdGhlXG4gICAgICogY2xhc3MncyBgY2xhc3NOYW1lYC4gSWYgZm91bmQsIGl0IG1lcmdlcyB0aGUgcHJvcGVydGllcyBmcm9tIHRoZSBvdmVyd3JpdGUgb2JqZWN0XG4gICAgICogaW50byB0aGUgY2xhc3MncyBzdGF0aWMgYGNvbmZpZ2AuIFRoaXMgcHJvdmlkZXMgYSBwb3dlcmZ1bCBtZWNoYW5pc20gZm9yIHRoZW1pbmdcbiAgICAgKiBvciBhcHBseWluZyBhcHBsaWNhdGlvbi13aWRlIGN1c3RvbWl6YXRpb25zIHRvIGZyYW1ld29yayBvciBsaWJyYXJ5IGNsYXNzZXMgd2l0aG91dFxuICAgICAqIG5lZWRpbmcgdG8gZXh0ZW5kIHRoZW0uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIEltYWdpbmUgeW91IGhhdmUgaHVuZHJlZHMgb2YgYnV0dG9ucyBpbiB5b3VyIGFwcCwgYW5kIHlvdSB3YW50IGFsbCBvZiB0aGVtXG4gICAgICogLy8gdG8gaGF2ZSBgbGFiZWxQb3NpdGlvbjogJ3RvcCdgIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgYCdsZWZ0J2AuXG4gICAgICogLy8gSW5zdGVhZCBvZiBjb25maWd1cmluZyBlYWNoIGluc3RhbmNlLCB5b3UgY2FuIGRlZmluZSBhbiBvdmVyd3JpdGUuXG4gICAgICpcbiAgICAgKiAvLyBpbnNpZGUgYW4gT3ZlcndyaXRlcy5tanMgZmlsZSBsb2FkZWQgYnkgeW91ciBhcHA6XG4gICAgICogTmVvLm92ZXJ3cml0ZXMgPSB7XG4gICAgICogICAgIE5lbzoge1xuICAgICAqICAgICAgICAgYnV0dG9uOiB7XG4gICAgICogICAgICAgICAgICAgQmFzZToge1xuICAgICAqICAgICAgICAgICAgICAgICBsYWJlbFBvc2l0aW9uOiAndG9wJ1xuICAgICAqICAgICAgICAgICAgIH1cbiAgICAgKiAgICAgICAgIH1cbiAgICAgKiAgICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiAvLyBOb3csIGV2ZXJ5IGBOZW8uYnV0dG9uLkJhc2VgIChhbmQgYW55IGNsYXNzIHRoYXQgZXh0ZW5kcyBpdCkgd2lsbCBoYXZlIHRoaXNcbiAgICAgKiAvLyBuZXcgZGVmYXVsdCB2YWx1ZSBvbiBpdHMgcHJvdG90eXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyBUaGUgc3RhdGljIGBjb25maWdgIG9iamVjdCBvZiB0aGUgY2xhc3MgYmVpbmcgcHJvY2Vzc2VkLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGFwcGx5T3ZlcndyaXRlcyhjZmcpIHtcbiAgICAgICAgbGV0IG92ZXJ3cml0ZXMgPSBOZW8ubnMoY2ZnLmNsYXNzTmFtZSwgZmFsc2UsIE5lby5vdmVyd3JpdGVzKSxcbiAgICAgICAgICAgIGNscywgaXRlbTtcblxuICAgICAgICBpZiAob3ZlcndyaXRlcykge1xuICAgICAgICAgICAgLy8gQXBwbHkgYWxsIG1ldGhvZHNcbiAgICAgICAgICAgIGZvciAoaXRlbSBpbiBvdmVyd3JpdGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKE5lby5pc0Z1bmN0aW9uKG92ZXJ3cml0ZXNbaXRlbV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFscmVhZHkgZXhpc3Rpbmcgb25lc1xuICAgICAgICAgICAgICAgICAgICBjbHMgPSB0aGlzLnByb3RvdHlwZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY2xzW2l0ZW1dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdG8gb3ZlcndyaXR0ZW5NZXRob2RzXG4gICAgICAgICAgICAgICAgICAgICAgICBjbHMuY29uc3RydWN0b3Iub3ZlcndyaXR0ZW5NZXRob2RzW2l0ZW1dID0gY2xzW2l0ZW1dXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZ3MgdG8gcHJvdG90eXBlXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGNmZywgb3ZlcndyaXRlcylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgYmVmb3JlU2V0IGZ1bmN0aW9ucyB3aGljaCB0ZXN0IGlmIGEgZ2l2ZW4gdmFsdWUgaXMgaW5zaWRlIGEgc3RhdGljIGFycmF5XG4gICAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBjb25maWcgbmFtZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBbc3RhdGljTmFtZT1uYW1lICsgJ3MnXSBuYW1lIG9mIHRoZSBzdGF0aWMgY29uZmlnIGFycmF5XG4gICAgICogQHJldHVybnMge1N0cmluZ3xOdW1iZXJ9IHZhbHVlIG9yIG9sZFZhbHVlXG4gICAgICovXG4gICAgYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgbmFtZSwgc3RhdGljTmFtZSA9IG5hbWUgKyAncycpIHtcbiAgICAgICAgbGV0IHZhbHVlcyA9IEFycmF5LmlzQXJyYXkoc3RhdGljTmFtZSkgPyBzdGF0aWNOYW1lIDogdGhpcy5nZXRTdGF0aWNDb25maWcoc3RhdGljTmFtZSk7XG5cbiAgICAgICAgaWYgKCF2YWx1ZXMuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBTdXBwb3J0ZWQgdmFsdWVzIGZvciAke25hbWV9IGFyZTpgLCAuLi52YWx1ZXMsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIG9sZFZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSByZW1vdGUgY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFJlbW90ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvLyBPbmx5IGFsbG93IHJlbW90ZSBhY2Nlc3MgZm9yIHNpbmdsZXRvbnMgb3IgbWFpbiB0aHJlYWQgYWRkb25zXG4gICAgICAgIGlmICh2YWx1ZSAmJiAhbWUuc2luZ2xldG9uICYmICFtZS5pc01haW5UaHJlYWRBZGRvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZW1vdGUgbWV0aG9kIGFjY2VzcyBpcyBvbmx5IGZ1bmN0aW9uYWwgZm9yIFNpbmdsZXRvbiBjbGFzc2VzICcgKyBtZS5jbGFzc05hbWUpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZm4gICAgICAgICAgICAgICBUaGUgbmFtZSBvZiBhIGZ1bmN0aW9uIHRvIGZpbmQgaW4gdGhlIHBhc3NlZCBzY29wZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9yaWdpbk5hbWUgICAgICAgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCBpbnNpZGUgdGhlIG9yaWdpblNjb3BlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZSAgICAgICAgICAgIFRoZSBzY29wZSB0byBmaW5kIHRoZSBmdW5jdGlvbiBpbiBpZiBpdCBpcyBzcGVjaWZpZWQgYXMgYSBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9yaWdpblNjb3BlPXRoaXMgVGhlIHNjb3BlIHdoZXJlIHRoZSBmdW5jdGlvbiBpcyBsb2NhdGVkLlxuICAgICAqL1xuICAgIGJpbmRDYWxsYmFjayhmbiwgb3JpZ2luTmFtZSwgc2NvcGU9dGhpcywgb3JpZ2luU2NvcGU9dGhpcykge1xuICAgICAgICBpZiAoZm4gJiYgTmVvLmlzU3RyaW5nKGZuKSkge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IHJlc29sdmVDYWxsYmFjayhmbiwgc2NvcGUpO1xuICAgICAgICAgICAgb3JpZ2luU2NvcGVbb3JpZ2luTmFtZV0gPSBoYW5kbGVyLmZuLmJpbmQoaGFuZGxlci5zY29wZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZyb20gd2l0aGluIGFuIG92ZXJ3cml0ZSwgYSBtZXRob2QgY2FuIGNhbGwgYSBwYXJlbnQgbWV0aG9kLCBieSB1c2luZyBjYWxsT3ZlcndyaXR0ZW4uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIGFmdGVyU2V0SGVpZ2h0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAqICAgICAgICAvLyBkbyB0aGUgc3RhbmRhcmRcbiAgICAgKiAgICAgICAgdGhpcy5jYWxsT3ZlcndyaXR0ZW4oLi4uYXJndW1lbnRzKTtcbiAgICAgKiAgICAgICAgLy8gZG8geW91IG93biBzdHVmZlxuICAgICAqICAgIH1cbiAgICAgKlxuICAgICAqIFdlIGNyZWF0ZSBhbiBlcnJvciB0byBnZXQgdGhlIGNhbGxlci5uYW1lIGFuZCB0aGVuIHJ1biB0aGF0IG1ldGhvZCBvbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICogVGhpcyBpcyBiYXNlZCBvbiB0aGUgZm9sbG93aW5nIGVycm9yIHN0cnVjdHVyZSwgZS5nLiBhZnRlclNldEhlaWdodC5cbiAgICAgKlxuICAgICAqICAgICBFcnJvclxuICAgICAqICAgICAgICAgYXQgQmFzZS5jYWxsT3ZlcndyaXR0ZW4gKEJhc2UubWpzOjE3NjoyMSlcbiAgICAgKiAgICAgICAgIGF0IEJhc2UuYWZ0ZXJTZXRIZWlnaHQgKE92ZXJyaWRlcy5tanM6MTk6MjYpXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqL1xuICAgIGNhbGxPdmVyd3JpdHRlbiguLi5hcmdzKSB7XG4gICAgICAgIGxldCBzdGFjayAgICAgID0gbmV3IEVycm9yKCkuc3RhY2ssXG4gICAgICAgICAgICBtZXRob2ROYW1lID0gc3RhY2subWF0Y2goQmFzZS5tZXRob2ROYW1lUmVnZXgpWzFdO1xuXG4gICAgICAgIHRoaXMuX19wcm90b19fLmNvbnN0cnVjdG9yLm92ZXJ3cml0dGVuTWV0aG9kc1ttZXRob2ROYW1lXS5jYWxsKHRoaXMsIC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5yZWdpc3RlcnMgdGhpcyBpbnN0YW5jZSBmcm9tIE5lby5tYW5hZ2VyLkluc3RhbmNlXG4gICAgICogYW5kIHJlbW92ZXMgYWxsIG9iamVjdCBlbnRyaWVzIGZyb20gdGhpcyBpbnN0YW5jZVxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuaXNEZXN0cm95aW5nID0gdHJ1ZTtcblxuICAgICAgICBtZS4jdGltZW91dElkcy5mb3JFYWNoKGlkID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChpZClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUuI2NvbmZpZ1N1YnNjcmlwdGlvbkNsZWFudXBzLmZvckVhY2goY2xlYW51cCA9PiB7XG4gICAgICAgICAgICBjbGVhbnVwKClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKEJhc2UuaW5zdGFuY2VNYW5hZ2VyQXZhaWxhYmxlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBOZW8ubWFuYWdlci5JbnN0YW5jZS51bnJlZ2lzdGVyKG1lKVxuICAgICAgICB9IGVsc2UgaWYgKE5lby5pZE1hcCkge1xuICAgICAgICAgICAgZGVsZXRlIE5lby5pZE1hcFttZS5pZF1cbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5rZXlzKG1lKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtZSwga2V5KS53cml0YWJsZSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIG11c3Qgbm90IGRlbGV0ZSB0aGUgY3VzdG9tIGRlc3Ryb3koKSBpbnRlcmNlcHRvclxuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICdkZXN0cm95JyAmJiBrZXkgIT09ICdfaWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBtZVtrZXldXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBXZSBkbyB3YW50IHRvIHByZXZlbnQgZGVsYXllZCBldmVudCBjYWxscyBhZnRlciBhbiBvYnNlcnZhYmxlIGluc3RhbmNlIGdvdCBkZXN0cm95ZWQuXG4gICAgICAgIGlmIChOZW8uaXNGdW5jdGlvbihtZS5maXJlKSkge1xuICAgICAgICAgICAgbWUuZmlyZSA9IE5lby5lbXB0eUZuXG4gICAgICAgIH1cblxuICAgICAgICBtZS5pc0Rlc3Ryb3llZCA9IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHB1YmxpYyBtZXRob2QgdG8gYWNjZXNzIHRoZSB1bmRlcmx5aW5nIENvbmZpZyBjb250cm9sbGVyLlxuICAgICAqIFRoaXMgZW5hYmxlcyBhZHZhbmNlZCBpbnRlcmFjdGlvbnMgbGlrZSBzdWJzY3JpcHRpb25zLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIG5hbWUgb2YgdGhlIGNvbmZpZyBwcm9wZXJ0eSAoZS5nLiwgJ2l0ZW1zJykuXG4gICAgICogQHJldHVybnMge0NvbmZpZ3x1bmRlZmluZWR9IFRoZSBDb25maWcgaW5zdGFuY2UsIG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmQuXG4gICAgICovXG4gICAgZ2V0Q29uZmlnKGtleSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUuI2NvbmZpZ3Nba2V5XSAmJiBtZS5pc0NvbmZpZyhrZXkpKSB7XG4gICAgICAgICAgICBtZS4jY29uZmlnc1trZXldID0gbmV3IENvbmZpZyhtZS5jb25zdHJ1Y3Rvci5jb25maWdEZXNjcmlwdG9ycz8uW2tleV0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWUuI2NvbmZpZ3Nba2V5XVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgaW5zaWRlIGNyZWF0ZUlkKCkgYXMgdGhlIGRlZmF1bHQgdmFsdWUgcGFzc2VkIHRvIHRoZSBJZEdlbmVyYXRvci5cbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBhcyBuZWVkZWQuXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRJZEtleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubnR5cGVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBhIHN0YXRpYyBjb25maWcga2V5IG9yIHRoZSBzdGF0aWNDb25maWcgb2JqZWN0IGl0c2VsZiBpbiBjYXNlIG5vIHZhbHVlIGlzIHNldFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIGtleSBvZiBhIHN0YXRpY0NvbmZpZyBkZWZpbmVkIGluc2lkZSBzdGF0aWMgZ2V0U3RhdGljQ29uZmlnXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0U3RhdGljQ29uZmlnKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RvcltrZXldXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSBnaXZlbiBudHlwZSBleGlzdHMgaW5zaWRlIHRoZSBwcm90byBjaGFpbiwgaW5jbHVkaW5nIHRoZSB0b3AgbGV2ZWwgY2xhc3NcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbnR5cGVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNOdHlwZShudHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5udHlwZUNoYWluLmluY2x1ZGVzKG50eXBlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdHJpZ2dlcmVkIGFmdGVyIG9uQ29uc3RydWN0ZWQoKSBpcyBkb25lXG4gICAgICovXG4gICAgaW5pdCgpIHt9XG5cbiAgICAvKipcbiAgICAgKiBZb3UgY2FuIHVzZSB0aGlzIG1ldGhvZCBpbiBzdWJjbGFzc2VzIHRvIHBlcmZvcm0gYXN5bmNocm9ub3VzIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxuICAgICAqIE1ha2Ugc3VyZSB0byB1c2UgdGhlIHBhcmVudCBjYWxsIGBhd2FpdCBzdXBlci5pbml0QXN5bmMoKWAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGVpciBpbXBsZW1lbnRhdGlvbnMsXG4gICAgICogb3IgdGhlIHJlZ2lzdHJhdGlvbiBvZiByZW1vdGUgbWV0aG9kcyB3aWxsIGdldCBkZWxheWVkLlxuICAgICAqXG4gICAgICogQSBjb21tb24gdXNlIGNhc2UgaXMgcmVxdWlyaW5nIGNvbmRpdGlvbmFsIG9yIG9wdGlvbmFsIGR5bmFtaWMgaW1wb3J0cyBvciBmZXRjaGluZyBpbml0aWFsIGRhdGEuXG4gICAgICpcbiAgICAgKiBPbmNlIHRoZSBwcm9taXNlIHJldHVybmVkIGJ5IHRoaXMgbWV0aG9kIGlzIGZ1bGZpbGxlZCwgdGhlIGBpc1JlYWR5YCBjb25maWcgd2lsbCBiZSBzZXQgdG8gYHRydWVgLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBhc3luY2hyb25vdXMgaW5pdGlhbGl6YXRpb24gaXMgY29tcGxldGUuXG4gICAgICovXG4gICAgYXN5bmMgaW5pdEFzeW5jKCkge1xuICAgICAgICB0aGlzLnJlbW90ZSAmJiB0aGlzLmluaXRSZW1vdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYWxsIGNsYXNzIGNvbmZpZ3MgdG8gdGhpcyBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtwcmV2ZW50T3JpZ2luYWxDb25maWddIFRydWUgcHJldmVudHMgdGhlIGluc3RhbmNlIGZyb20gZ2V0dGluZyBhbiBvcmlnaW5hbENvbmZpZyBwcm9wZXJ0eVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpbml0Q29uZmlnKGNvbmZpZywgcHJldmVudE9yaWdpbmFsQ29uZmlnKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuaXNDb25maWd1cmluZyA9IHRydWU7XG4gICAgICAgIE9iamVjdC5hc3NpZ24obWVbY29uZmlnU3ltYm9sXSwgbWUubWVyZ2VDb25maWcoY29uZmlnLCBwcmV2ZW50T3JpZ2luYWxDb25maWcpKTtcbiAgICAgICAgZGVsZXRlIG1lW2NvbmZpZ1N5bWJvbF0uaWQ7XG4gICAgICAgIG1lLnByb2Nlc3NDb25maWdzKCk7XG4gICAgICAgIG1lLmlzQ29uZmlndXJpbmcgPSBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERvZXMgZ2V0IHRyaWdnZXJlZCB3aXRoIGEgZGVsYXkgdG8gZW5zdXJlIHRoYXQgTmVvLndvcmtlcklkICYgTmVvLndvcmtlci5NYW5hZ2VyIGFyZSBkZWZpbmVkXG4gICAgICogUmVtb3RlIG1ldGhvZCBhY2Nlc3MgdmlhIHByb21pc2VzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGluaXRSZW1vdGUoKSB7XG4gICAgICAgIGxldCB7Y2xhc3NOYW1lLCByZW1vdGV9ID0gdGhpcyxcbiAgICAgICAgICAgIHtjdXJyZW50V29ya2VyfSAgICAgPSBOZW87XG5cbiAgICAgICAgaWYgKCFOZW8uY29uZmlnLnVuaXRUZXN0TW9kZSkge1xuICAgICAgICAgICAgaWYgKE5lby53b3JrZXJJZCAhPT0gJ21haW4nICYmIGN1cnJlbnRXb3JrZXIuaXNTaGFyZWRXb3JrZXIgJiYgIWN1cnJlbnRXb3JrZXIuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50V29ya2VyLm9uKCdjb25uZWN0ZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIEJhc2Uuc2VuZFJlbW90ZXMoY2xhc3NOYW1lLCByZW1vdGUpXG4gICAgICAgICAgICAgICAgfSwgdGhpcywge29uY2U6IHRydWV9KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBCYXNlLnNlbmRSZW1vdGVzKGNsYXNzTmFtZSwgcmVtb3RlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJjZXB0cyBkZXN0cm95KCkgY2FsbHMgdG8gZW5zdXJlIHRoZXkgd2lsbCBvbmx5IGdldCBjYWxsZWQgb25jZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzRGVzdHJveWVkQ2hlY2soKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5pc0Rlc3Ryb3llZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0NvbmZpZyhrZXkpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcbiAgICAgICAgLy8gSWYgYSBgY29yZS5Db25maWdgIGNvbnRyb2xsZXIgaXMgYWxyZWFkeSBjcmVhdGVkLCByZXR1cm4gdHJ1ZSAoZmFzdGVzdCBwb3NzaWJsZSBjaGVjaykuXG4gICAgICAgIC8vIElmIG5vdCwgYSBjb25maWcgaXMgY29uc2lkZXJlZCBcInJlYWN0aXZlXCIgaWYgaXQgaGFzIGEgZ2VuZXJhdGVkIHByb3BlcnR5IHNldHRlclxuICAgICAgICAvLyBBTkQgaXQgaXMgcHJlc2VudCBhcyBhIGRlZmluZWQgY29uZmlnIGluIHRoZSBtZXJnZWQgc3RhdGljIGNvbmZpZyBoaWVyYXJjaHkuXG4gICAgICAgIC8vIE5lby5zZXR1cENsYXNzKCkgcmVtb3ZlcyB0aGUgdW5kZXJzY29yZSBmcm9tIHRoZSBzdGF0aWMgY29uZmlnIGtleXMuXG4gICAgICAgIHJldHVybiBtZS4jY29uZmlnc1trZXldIHx8IChOZW8uaGFzUHJvcGVydHlTZXR0ZXIobWUsIGtleSkgJiYgKGtleSBpbiBtZS5jb25zdHJ1Y3Rvci5jb25maWcpKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGNoYW5nZSB0aGUgb3JkZXIgY29uZmlncyBhcmUgYXBwbGllZCB0byB0aGlzIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtwcmV2ZW50T3JpZ2luYWxDb25maWddIFRydWUgcHJldmVudHMgdGhlIGluc3RhbmNlIGZyb20gZ2V0dGluZyBhbiBvcmlnaW5hbENvbmZpZyBwcm9wZXJ0eVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBtZXJnZUNvbmZpZyhjb25maWcsIHByZXZlbnRPcmlnaW5hbENvbmZpZykge1xuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICBjdG9yID0gbWUuY29uc3RydWN0b3IsXG4gICAgICAgICAgICBjb25maWdEZXNjcmlwdG9ycywgc3RhdGljQ29uZmlnO1xuXG4gICAgICAgIGlmICghY3Rvci5jb25maWcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTmVvLmFwcGx5Q2xhc3NDb25maWcgaGFzIG5vdCBiZWVuIHJ1biBvbiAnICsgbWUuY2xhc3NOYW1lKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwcmV2ZW50T3JpZ2luYWxDb25maWcpIHtcbiAgICAgICAgICAgIG1lLm9yaWdpbmFsQ29uZmlnID0gTmVvLmNsb25lKGNvbmZpZywgdHJ1ZSwgdHJ1ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZ0Rlc2NyaXB0b3JzID0gY3Rvci5jb25maWdEZXNjcmlwdG9ycztcbiAgICAgICAgc3RhdGljQ29uZmlnICAgICAgPSBjdG9yLmNvbmZpZztcblxuICAgICAgICBpZiAoY29uZmlnRGVzY3JpcHRvcnMpIHtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGNvbmZpZykuZm9yRWFjaCgoW2tleSwgaW5zdGFuY2VWYWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gY29uZmlnRGVzY3JpcHRvcnNba2V5XTtcblxuICAgICAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yPy5tZXJnZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25maWdba2V5XSA9IE5lby5tZXJnZUNvbmZpZyhzdGF0aWNDb25maWdba2V5XSwgaW5zdGFuY2VWYWx1ZSwgZGVzY3JpcHRvci5tZXJnZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsuLi5zdGF0aWNDb25maWcsIC4uLmNvbmZpZ31cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVzICp0aGlzKiBpbnN0YW5jZSAodGhlIHN1YnNjcmliZXIpIHRvIGNoYW5nZXMgb2YgYSBzcGVjaWZpYyBjb25maWcgcHJvcGVydHkgb24gYW5vdGhlciBpbnN0YW5jZSAodGhlIHB1Ymxpc2hlcikuXG4gICAgICogRW5zdXJlcyBhdXRvbWF0aWMgY2xlYW51cCB3aGVuICp0aGlzKiBpbnN0YW5jZSAodGhlIHN1YnNjcmliZXIpIGlzIGRlc3Ryb3llZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE5lby5jb3JlLkJhc2V9IHB1Ymxpc2hlciAgLSBUaGUgSUQgb2YgdGhlIHB1Ymxpc2hlciBpbnN0YW5jZSBvciB0aGUgaW5zdGFuY2UgcmVmZXJlbmNlIGl0c2VsZi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICAgICAgICAgICBjb25maWdOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGNvbmZpZyBwcm9wZXJ0eSBvbiB0aGUgcHVibGlzaGVyIHRvIHN1YnNjcmliZSB0byAoZS5nLiwgJ215Q29uZmlnJykuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gICAgICAgICAgICAgZm4gICAgICAgICAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gdGhlIGNvbmZpZyBjaGFuZ2VzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBjbGVhbnVwIGZ1bmN0aW9uIHRvIG1hbnVhbGx5IHVuc3Vic2NyaWJlIGlmIG5lZWRlZCBiZWZvcmUgdGhpcyBpbnN0YW5jZSdzIGRlc3RydWN0aW9uLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBTdWJzY3JpYmluZyB0byBhIGNvbmZpZyBvbiBhbm90aGVyIGluc3RhbmNlXG4gICAgICogdGhpcy5vYnNlcnZlQ29uZmlnKHNvbWVPdGhlckluc3RhbmNlLCAnbXlDb25maWcnLCAobmV3VmFsdWUsIG9sZFZhbHVlKSA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKCdteUNvbmZpZyBjaGFuZ2VkOicsIG5ld1ZhbHVlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIERpc2NvdXJhZ2VkOiBTZWxmLW9ic2VydmF0aW9uLiBVc2UgYWZ0ZXJTZXQ8Q29uZmlnTmFtZT4oKSBob29rcyBpbnN0ZWFkLlxuICAgICAqIHRoaXMub2JzZXJ2ZUNvbmZpZyh0aGlzLCAnbXlPd25Db25maWcnLCAobmV3VmFsdWUsIG9sZFZhbHVlKSA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKCdteU93bkNvbmZpZyBjaGFuZ2VkOicsIG5ld1ZhbHVlKTtcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBvYnNlcnZlQ29uZmlnKHB1Ymxpc2hlciwgY29uZmlnTmFtZSwgZm4pIHtcbiAgICAgICAgbGV0IHB1Ymxpc2hlckluc3RhbmNlID0gcHVibGlzaGVyO1xuXG4gICAgICAgIGlmIChOZW8uaXNTdHJpbmcocHVibGlzaGVyKSkge1xuICAgICAgICAgICAgcHVibGlzaGVySW5zdGFuY2UgPSBOZW8uZ2V0KHB1Ymxpc2hlcik7XG4gICAgICAgICAgICBpZiAoIXB1Ymxpc2hlckluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBQdWJsaXNoZXIgaW5zdGFuY2Ugd2l0aCBJRCAnJHtwdWJsaXNoZXJ9JyBub3QgZm91bmQuIENhbm5vdCBzdWJzY3JpYmUuYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5lby5lbXB0eUZuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIShwdWJsaXNoZXJJbnN0YW5jZSBpbnN0YW5jZW9mIE5lby5jb3JlLkJhc2UpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYEludmFsaWQgcHVibGlzaGVyIHByb3ZpZGVkLiBNdXN0IGJlIGEgTmVvLmNvcmUuQmFzZSBpbnN0YW5jZSBvciBpdHMgSUQuYCk7XG4gICAgICAgICAgICByZXR1cm4gTmVvLmVtcHR5Rm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbmZpZ0NvbnRyb2xsZXIgPSBwdWJsaXNoZXJJbnN0YW5jZS5nZXRDb25maWcoY29uZmlnTmFtZSk7XG5cbiAgICAgICAgaWYgKCFjb25maWdDb250cm9sbGVyKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYENvbmZpZyAnJHtjb25maWdOYW1lfScgbm90IGZvdW5kIG9uIHB1Ymxpc2hlciBpbnN0YW5jZSAke3B1Ymxpc2hlckluc3RhbmNlLmlkfS4gQ2Fubm90IHN1YnNjcmliZS5gKTtcbiAgICAgICAgICAgIHJldHVybiBOZW8uZW1wdHlGblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2xlYW51cCA9IGNvbmZpZ0NvbnRyb2xsZXIuc3Vic2NyaWJlKHtpZDogdGhpcy5pZCwgZm59KTtcblxuICAgICAgICB0aGlzLiNjb25maWdTdWJzY3JpcHRpb25DbGVhbnVwcy5wdXNoKGNsZWFudXApO1xuXG4gICAgICAgIHJldHVybiBjbGVhbnVwXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkFmdGVyQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuaXNDb25zdHJ1Y3RlZCA9IHRydWU7XG5cbiAgICAgICAgLy8gV2UgY2FuIG9ubHkgZmlyZSB0aGUgZXZlbnQgaW4gY2FzZSB0aGUgT2JzZXJ2YWJsZSBtaXhpbiBpcyBpbmNsdWRlZC5cbiAgICAgICAgbWUuZ2V0U3RhdGljQ29uZmlnKCdvYnNlcnZhYmxlJykgJiYgbWUuZmlyZSgnY29uc3RydWN0ZWQnLCBtZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCBhZnRlciBhbGwgY29uc3RydWN0b3JzIGFyZSBkb25lXG4gICAgICovXG4gICAgb25Db25zdHJ1Y3RlZCgpIHt9XG5cbiAgICAvKipcbiAgICAgKiBQbGFjZWhvbGRlciBtZXRob2QgZm9yIGludGVyY2VwdGluZyByZW1vdGUgY2FsbHMuXG4gICAgICogU3ViY2xhc3NlcyBjYW4gb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gaW1wbGVtZW50IGN1c3RvbSBpbnRlcmNlcHRpb24gbG9naWMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1zZyBUaGUgcmVtb3RlIG1lc3NhZ2Ugb2JqZWN0LlxuICAgICAqL1xuICAgIG9uSW50ZXJjZXB0UmVtb3Rlcyhtc2cpIHtcbiAgICAgICAgLy8gTm8tb3AgaW4gYmFzZSBjbGFzc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gcmVwbGFjZSBzdHJpbmcgYmFzZWQgdmFsdWVzIGNvbnRhaW5pbmcgXCJAY29uZmlnOlwiIHdpdGggdGhlIG1hdGNoaW5nIGNvbmZpZyB2YWx1ZVxuICAgICAqIG9mIHRoaXMgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R8T2JqZWN0W119IGl0ZW1zXG4gICAgICovXG4gICAgcGFyc2VJdGVtQ29uZmlncyhpdGVtcykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgbnMsIG5zQXJyYXksIG5zS2V5LCBzeW1ib2xOcztcblxuICAgICAgICBpZiAoaXRlbXMpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICAgICAgICAgICAgICBpdGVtcyA9IFtpdGVtc11cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBpdGVtICYmIE9iamVjdC5lbnRyaWVzKGl0ZW0pLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLnBhcnNlSXRlbUNvbmZpZ3ModmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUuc3RhcnRzV2l0aCgnQGNvbmZpZzonKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnNBcnJheSA9IHZhbHVlLnN1YnN0cmluZyg4KS50cmltKCkuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5zS2V5ICAgPSBuc0FycmF5LnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbnMgICAgICA9IE5lby5ucyhuc0FycmF5LCBmYWxzZSwgbWUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobnNbbnNLZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUaGUgdXNlZCBAY29uZmlnIGRvZXMgbm90IGV4aXN0OicsIG5zS2V5LCBuc0FycmF5LmpvaW4oJy4nKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sTnMgPSBOZW8ubnMobnNBcnJheSwgZmFsc2UsIG1lW2NvbmZpZ1N5bWJvbF0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGNvbmZpZyBtaWdodCBub3QgYmUgcHJvY2Vzc2VkIHlldCwgZXNwZWNpYWxseSBmb3IgY29uZmlnc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdCBlbmRpbmcgd2l0aCBhbiB1bmRlcnNjb3JlLCBzbyB3ZSBuZWVkIHRvIGNoZWNrIHRoZSBjb25maWdTeW1ib2wgZmlyc3QuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN5bWJvbE5zICYmIE9iamVjdC5oYXNPd24oc3ltYm9sTnMsIG5zS2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtW2tleV0gPSBzeW1ib2xOc1tuc0tleV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtW2tleV0gPSBuc1tuc0tleV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gdXNpbmcgc2V0KCksIGNvbmZpZ3Mgd2l0aG91dCBhIHRyYWlsaW5nIHVuZGVyc2NvcmUgY2FuIGFscmVhZHkgYmUgYXNzaWduZWQsXG4gICAgICogc28gdGhlIGhhc093blByb3BlcnR5KCkgY2hlY2sgd2lsbCByZXR1cm4gdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZvcmNlQXNzaWduPWZhbHNlXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwcm9jZXNzQ29uZmlncyhmb3JjZUFzc2lnbj1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICBrZXlzID0gT2JqZWN0LmtleXMobWVbY29uZmlnU3ltYm9sXSk7XG5cbiAgICAgICAgbWVbZm9yY2VBc3NpZ25Db25maWdzXSA9IGZvcmNlQXNzaWduO1xuXG4gICAgICAgIC8vIFdlIGRvIG5vdCB3YW50IHRvIGl0ZXJhdGUgb3ZlciB0aGUga2V5cywgc2luY2UgMSBjb25maWcgY2FuIHJlbW92ZSBtb3JlIHRoYW4gMSBrZXkgKGJlZm9yZVNldFgsIGFmdGVyU2V0WClcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gVGhlIGhhc093blByb3BlcnR5IGNoZWNrIGlzIGludGVuZGVkIGZvciBjb25maWdzIHdpdGhvdXQgYSB0cmFpbGluZyB1bmRlcnNjb3JlXG4gICAgICAgICAgICAvLyA9PiB0aGV5IGNvdWxkIGFscmVhZHkgaGF2ZSBiZWVuIGFzc2lnbmVkIGluc2lkZSBhbiBhZnRlclNldC1tZXRob2RcbiAgICAgICAgICAgIGlmIChmb3JjZUFzc2lnbiB8fCAhbWUuaGFzT3duUHJvcGVydHkoa2V5c1swXSkpIHtcbiAgICAgICAgICAgICAgICBtZVtrZXlzWzBdXSA9IG1lW2NvbmZpZ1N5bWJvbF1ba2V5c1swXV1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGhlcmUgaXMgYSBkZWxldGUtY2FsbCBpbnNpZGUgdGhlIGNvbmZpZyBnZXR0ZXIgYXMgd2VsbCAoTmVvLm1qcyA9PiBhdXRvR2VuZXJhdGVHZXRTZXQoKSlcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8ga2VlcCB0aGlzIG9uZSBmb3IgY29uZmlncywgd2hpY2ggZG8gbm90IHVzZSBnZXR0ZXJzIChubyB0cmFpbGluZyB1bmRlcnNjb3JlKVxuICAgICAgICAgICAgZGVsZXRlIG1lW2NvbmZpZ1N5bWJvbF1ba2V5c1swXV07XG5cbiAgICAgICAgICAgIG1lLnByb2Nlc3NDb25maWdzKGZvcmNlQXNzaWduKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZW1vdGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc3RhdGljIHNlbmRSZW1vdGVzKGNsYXNzTmFtZSwgcmVtb3RlKSB7XG4gICAgICAgIGxldCBvcmlnaW47XG5cbiAgICAgICAgT2JqZWN0LmVudHJpZXMocmVtb3RlKS5mb3JFYWNoKChbd29ya2VyLCBtZXRob2RzXSkgPT4ge1xuICAgICAgICAgICAgaWYgKE5lby53b3JrZXJJZCAhPT0gd29ya2VyKSB7XG4gICAgICAgICAgICAgICAgb3JpZ2luID0gTmVvLndvcmtlcklkID09PSAnbWFpbicgPyBOZW8ud29ya2VyLk1hbmFnZXIgOiBOZW8uY3VycmVudFdvcmtlcjtcblxuICAgICAgICAgICAgICAgIG9yaWdpbi5zZW5kTWVzc2FnZSh3b3JrZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAncmVnaXN0ZXJSZW1vdGUnLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZHNcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNldCgpIGFjY2VwdHMgdGhlIGZvbGxvd2luZyBpbnB1dCBhcyBrZXlzOlxuICAgICAqIDEuIE5vbi1yZWFjdGl2ZSBjb25maWdzXG4gICAgICogMi4gUmVhY3RpdmUgY29uZmlnc1xuICAgICAqIDMuIENsYXNzIGZpZWxkcyBkZWZpbmVkIHZpYSB2YWx1ZVxuICAgICAqIDQuIENsYXNzIGZpZWxkcyBkZWZpbmVkIHZpYSBnZXQoKSAmIHNldCgpXG4gICAgICogNS4gXCJBbnl0aGluZyBlbHNlXCIgd2lsbCBnZXQgZGlyZWN0bHkgZ2V0IGFzc2lnbmVkIHRvIHRoZSBpbnN0YW5jZVxuICAgICAqXG4gICAgICogVGhlIGxvZ2ljIHJlc29sdmVzIGNpcmN1bGFyIGRlcGVuZGVuY2llcyBhcyBnb29kIGFzIHBvc3NpYmxlIGFuZCBlbnN1cmVzIHRoYXQgY29uZmlnIHJlbGF0ZWQgaG9va3M6XG4gICAgICogLSBiZWZvcmVHZXQ8Q29uZmlnPlxuICAgICAqIC0gYmVmb3JlU2V0PENvbmZpZz5cbiAgICAgKiAtIGFmdGVyU2V0PENvbmZpZz5cbiAgICAgKiBjYW4gYWNjZXNzIGFsbCBuZXcgdmFsdWVzIGZyb20gdGhlIGJhdGNoIG9wZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzPXt9XG4gICAgICovXG4gICAgc2V0KHZhbHVlcz17fSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY2xhc3NGaWVsZHNWaWFTZXQgPSB7fTtcblxuICAgICAgICAvLyBQcmV2ZW50IEVmZmVjdHMgZnJvbSBydW5uaW5nIGZvciBidWxrIGNoYW5nZXNcbiAgICAgICAgRWZmZWN0TWFuYWdlci5wYXVzZSgpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSBtZS5zZXRGaWVsZHModmFsdWVzKTtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIGluaXRpYWwgY29uZmlnIHByb2Nlc3NpbmcgaXMgc3RpbGwgcnVubmluZyxcbiAgICAgICAgICAgIC8vIGZpbmlzaCB0aGlzIG9uZSBmaXJzdCBiZWZvcmUgZHJvcHBpbmcgbmV3IHZhbHVlcyBpbnRvIHRoZSBjb25maWdTeW1ib2wuXG4gICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9uZW9tanMvbmVvL2lzc3Vlcy8yMjAxXG4gICAgICAgICAgICBpZiAobWVbZm9yY2VBc3NpZ25Db25maWdzXSAhPT0gdHJ1ZSAmJiBPYmplY3Qua2V5cyhtZVtjb25maWdTeW1ib2xdKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbWUucHJvY2Vzc0NvbmZpZ3MoKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTdG9yZSBjbGFzcyBmaWVsZHMgd2hpY2ggYXJlIGRlZmluZWQgdmlhIGdldCgpICYgc2V0KCkgYW5kIGVuc3VyZSB0aGV5IHdvbid0IGdldCBhZGRlZCB0byB0aGUgY29uZmlnIHN5bWJvbC5cbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHZhbHVlcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFtZS5pc0NvbmZpZyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzRmllbGRzVmlhU2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHZhbHVlc1trZXldXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgLy8gQWRkIHJlYWN0aXZlIGNvbmZpZ3MgdG8gdGhlIGNvbmZpZ1N5bWJvbFxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihtZVtjb25maWdTeW1ib2xdLCB2YWx1ZXMpO1xuXG4gICAgICAgICAgICAvLyBQcm9jZXNzIGNsYXNzIGZpZWxkcyB3aGljaCBhcmUgZGVmaW5lZCB2aWEgZ2V0KCkgJiBzZXQoKSA9PiBub3cgdGhleSBjYW4gYWNjZXNzIHRoZSBsYXRlc3QgdmFsdWVzXG4gICAgICAgICAgICAvLyBmb3IgcmVhY3RpdmUgYW5kIG5vbi1yZWFjdGl2ZSBjb25maWdzLCBhcyB3ZWxsIGFzIGNsYXNzIGZpZWxkcyBkZWZpbmVkIHdpdGggdmFsdWVzLlxuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoY2xhc3NGaWVsZHNWaWFTZXQpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIG1lW2tleV0gPSB2YWx1ZVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgLy8gUHJvY2VzcyByZWFjdGl2ZSBjb25maWdzXG4gICAgICAgICAgICBtZS5wcm9jZXNzQ29uZmlncyh0cnVlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIC8vIFRyaWdnZXIgdGhlIHNraXBwZWQgRWZmZWN0LCBpZiBuZWVkZWRcbiAgICAgICAgICAgIEVmZmVjdE1hbmFnZXIucmVzdW1lKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdlIHdhbnQgdG8gYXNzaWduIGNsYXNzIGZpZWxkcyBmaXJzdCBhbmQgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgY29uZmlnIG9iamVjdCxcbiAgICAgKiBzbyB0aGF0IGFmdGVyU2V0KCksIGJlZm9yZUdldCgpIGFuZCBiZWZvcmVTZXQoKSBtZXRob2RzIGNhbiBnZXQgdGhlIG5ldyB2YWx1ZXMgcmlnaHQgYXdheVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZXRGaWVsZHMoY29uZmlnKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgT2JqZWN0LmVudHJpZXMoY29uZmlnKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmICghbWUuaXNDb25maWcoa2V5KSAmJiAhTmVvLmhhc1Byb3BlcnR5U2V0dGVyKG1lLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgbWVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBjb25maWdba2V5XVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY29uZmlnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmFsdWUgb2YgYSBzdGF0aWMgY29uZmlnIGJ5IGEgZ2l2ZW4ga2V5XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUga2V5IG9mIGEgc3RhdGljQ29uZmlnIGRlZmluZWQgaW5zaWRlIHN0YXRpYyBnZXRTdGF0aWNDb25maWdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaW4gY2FzZSB0aGUgY29uZmlnIGV4aXN0cyBhbmQgZ290IGNoYW5nZWRcbiAgICAgKi9cbiAgICBzZXRTdGF0aWNDb25maWcoa2V5LCB2YWx1ZSkge1xuICAgICAgICBsZXQgc3RhdGljQ29uZmlnID0gdGhpcy5jb25zdHJ1Y3Rvci5zdGF0aWNDb25maWc7XG5cbiAgICAgICAgaWYgKHN0YXRpY0NvbmZpZy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBzdGF0aWNDb25maWdba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3JlcyB0aW1lb3V0SWRzIGludGVybmFsbHksIHNvIHRoYXQgZGVzdHJveSgpIGNhbiBjbGVhciB0aGVtIGlmIG5lZWRlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIGluIG1pbGxpc2Vjb25kc1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgdGltZW91dCh0aW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIGxldCB0aW1lb3V0SWRzID0gdGhpcy4jdGltZW91dElkcyxcbiAgICAgICAgICAgICAgICB0aW1lb3V0SWQgID0gc2V0VGltZW91dCgoKSA9PiB7dGltZW91dElkcy5zcGxpY2UodGltZW91dElkcy5pbmRleE9mKHRpbWVvdXRJZCksIDEpOyByZXNvbHZlKCl9LCB0aW1lKTtcblxuICAgICAgICAgICAgdGltZW91dElkcy5wdXNoKHRpbWVvdXRJZClcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiA8cD5FbmhhbmNpbmcgdGhlIHRvU3RyaW5nKCkgbWV0aG9kLCBlLmcuPC9wPlxuICAgICAqIGBOZW8uY3JlYXRlKCdOZW8uYnV0dG9uLkJhc2UnKS50b1N0cmluZygpID0+IFwiW29iamVjdCBOZW8uYnV0dG9uLkJhc2UgKG5lby1idXR0b24tMSldXCJgXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsYXNzTmFtZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIDxwPkVuaGFuY2luZyB0aGUgaW5zdGFuY2VvZiBtZXRob2QuIFdpdGhvdXQgdGhpcyBjaGFuZ2U6PC9wPlxuICAgICAqIGBOZW8uY29sbGVjdGlvbi5CYXNlLnByb3RvdHlwZSBpbnN0YW5jZW9mIE5lby5jb3JlLkJhc2UgPT4gdHJ1ZWBcbiAgICAgKiA8cD5XaXRoIHRoaXMgY2hhbmdlOjwvcD5cbiAgICAgKiBgTmVvLmNvbGxlY3Rpb24uQmFzZS5wcm90b3R5cGUgaW5zdGFuY2VvZiBOZW8uY29yZS5CYXNlID0+IGZhbHNlYDxicj5cbiAgICAgKiBgTmVvLmNyZWF0ZShOZW8uY29sbGVjdGlvbi5CYXNlKSBpbnN0YW5jZW9mIE5lby5jb3JlLkJhc2UgPT4gdHJ1ZWBcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgW1N5bWJvbC5oYXNJbnN0YW5jZV0oaW5zdGFuY2UpIHtcbiAgICAgICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5zdGFuY2VbaXNJbnN0YW5jZV0gPT09IHRydWUgPyBzdXBlcltTeW1ib2wuaGFzSW5zdGFuY2VdKGluc3RhbmNlKSA6IGZhbHNlXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhCYXNlKTtcbiIsIi8qKlxuICogQGNsYXNzIE5lby5jb3JlLkNvbXBhcmVcbiAqL1xuY2xhc3MgQ29tcGFyZSB7XG4gICAgLyoqXG4gICAgICogU3RvcmluZyB0aGUgY29tcGFyaXNvbiBtZXRob2QgbmFtZXMgYnkgZGF0YSB0eXBlXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBtYXBcbiAgICAgKi9cbiAgICBzdGF0aWMgbWFwID0ge1xuICAgICAgICBBcnJheSAgICAgIDogJ2NvbXBhcmVBcnJheXMnLFxuICAgICAgICBEYXRlICAgICAgIDogJ2NvbXBhcmVEYXRlcycsXG4gICAgICAgIEZ1bmN0aW9uICAgOiAnY29tcGFyZUZ1bmN0aW9ucycsXG4gICAgICAgIE1hcCAgICAgICAgOiAnY29tcGFyZU1hcHMnLFxuICAgICAgICBOZW9JbnN0YW5jZTogJ2NvbXBhcmVOZW9JbnN0YW5jZXMnLFxuICAgICAgICBPYmplY3QgICAgIDogJ2NvbXBhcmVPYmplY3RzJyxcbiAgICAgICAgUmVnRXhwICAgICA6ICdjb21wYXJlUmVnRXhwcycsXG4gICAgICAgIFNldCAgICAgICAgOiAnY29tcGFyZVNldHMnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheX0gaXRlbTFcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpdGVtMlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBjb21wYXJlQXJyYXlzKGl0ZW0xLCBpdGVtMikge1xuICAgICAgICBpZiAoaXRlbTEubGVuZ3RoICE9PSBpdGVtMi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBbaSwgdl0gb2YgaXRlbTEuZW50cmllcygpKSB7XG4gICAgICAgICAgICBpZiAoIUNvbXBhcmUuaXNFcXVhbCh2LCBpdGVtMltpXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtEYXRlfSBpdGVtMVxuICAgICAqIEBwYXJhbSB7RGF0ZX0gaXRlbTJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgY29tcGFyZURhdGVzKGl0ZW0xLCBpdGVtMikge1xuICAgICAgICByZXR1cm4gaXRlbTEudmFsdWVPZigpID09PSBpdGVtMi52YWx1ZU9mKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVtMVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZW0yXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGNvbXBhcmVGdW5jdGlvbnMoaXRlbTEsIGl0ZW0yKSB7XG4gICAgICAgIGlmIChpdGVtMS5uYW1lICE9PSBpdGVtMi5uYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpdGVtMS50b1N0cmluZygpID09PSBpdGVtMi50b1N0cmluZygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtNYXB9IGl0ZW0xXG4gICAgICogQHBhcmFtIHtNYXB9IGl0ZW0yXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGNvbXBhcmVNYXBzKGl0ZW0xLCBpdGVtMikge1xuICAgICAgICBpZiAoaXRlbTEuc2l6ZSAhPT0gaXRlbTIuc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdmFsMjtcblxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgaXRlbTEpIHtcbiAgICAgICAgICAgIHZhbDIgPSBpdGVtMi5nZXQoa2V5KTtcblxuICAgICAgICAgICAgaWYgKHZhbDIgIT09IHZhbCB8fCB2YWwyID09PSB1bmRlZmluZWQgJiYgIWl0ZW0yLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmNvcmUuQmFzZX0gaXRlbTFcbiAgICAgKiBAcGFyYW0ge05lby5jb3JlLkJhc2V9IGl0ZW0yXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGNvbXBhcmVOZW9JbnN0YW5jZXMoaXRlbTEsIGl0ZW0yKSB7XG4gICAgICAgIHJldHVybiBpdGVtMS5pZCA9PT0gaXRlbTIuaWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbTFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbTJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgY29tcGFyZU9iamVjdHMoaXRlbTEsIGl0ZW0yKSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhpdGVtMSkubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhpdGVtMikubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGtleSBpbiBpdGVtMSkge1xuICAgICAgICAgICAgaWYgKCFDb21wYXJlLmlzRXF1YWwoaXRlbTFba2V5XSwgaXRlbTJba2V5XSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IGl0ZW0xXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IGl0ZW0yXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGNvbXBhcmVSZWdFeHBzKGl0ZW0xLCBpdGVtMikge1xuICAgICAgICByZXR1cm4gaXRlbTEudG9TdHJpbmcoKSA9PT0gaXRlbTIudG9TdHJpbmcoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U2V0fSBpdGVtMVxuICAgICAqIEBwYXJhbSB7U2V0fSBpdGVtMlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBjb21wYXJlU2V0cyhpdGVtMSwgaXRlbTIpIHtcbiAgICAgICAgaWYgKGl0ZW0xLnNpemUgIT09IGl0ZW0yLnNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQga2V5IG9mIGl0ZW0xKSB7XG4gICAgICAgICAgICBpZiAoIWl0ZW0yLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Kn0gaXRlbTFcbiAgICAgKiBAcGFyYW0geyp9IGl0ZW0yXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGlzRXF1YWwoaXRlbTEsIGl0ZW0yKSB7XG4gICAgICAgIGlmIChpdGVtMSA9PT0gaXRlbTIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdHlwZTEgPSBOZW8udHlwZU9mKGl0ZW0xKSxcbiAgICAgICAgICAgIHR5cGUyID0gTmVvLnR5cGVPZihpdGVtMik7XG5cbiAgICAgICAgaWYgKHR5cGUxICE9PSB0eXBlMikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQ29tcGFyZS5tYXBbdHlwZTFdKSB7XG4gICAgICAgICAgICByZXR1cm4gQ29tcGFyZVtDb21wYXJlLm1hcFt0eXBlMV1dKGl0ZW0xLCBpdGVtMilcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFsbCBvdGhlciB0eXBlc1xuICAgICAgICByZXR1cm4gaXRlbTEgPT09IGl0ZW0yXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uZ2F0ZWtlZXAoQ29tcGFyZSwgJ05lby5jb3JlLkNvbXBhcmUnLCAoKSA9PiB7XG4gICAgLy8gYWxpYXNcbiAgICBOZW8uaXNFcXVhbCA9IENvbXBhcmUuaXNFcXVhbFxufSk7XG4iLCJpbXBvcnQgRWZmZWN0TWFuYWdlciAgZnJvbSAnLi9FZmZlY3RNYW5hZ2VyLm1qcyc7XG5pbXBvcnQge2lzRGVzY3JpcHRvcn0gZnJvbSAnLi9Db25maWdTeW1ib2xzLm1qcyc7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBvYnNlcnZhYmxlIGNvbnRhaW5lciBmb3IgYSBjb25maWcgcHJvcGVydHkuXG4gKiBUaGlzIGNsYXNzIG1hbmFnZXMgdGhlIHZhbHVlIG9mIGEgY29uZmlnLCBpdHMgc3Vic2NyaWJlcnMsIGFuZCBjdXN0b20gYmVoYXZpb3JzXG4gKiBsaWtlIG1lcmdlIHN0cmF0ZWdpZXMgYW5kIGVxdWFsaXR5IGNoZWNrcyBkZWZpbmVkIHZpYSBhIGRlc2NyaXB0b3Igb2JqZWN0LlxuICpcbiAqIFRoZSBwcmltYXJ5IHB1cnBvc2Ugb2YgdGhpcyBjbGFzcyBpcyB0byBlbmFibGUgZmluZS1ncmFpbmVkIHJlYWN0aXZpdHkgYW5kXG4gKiBkZWNvdXBsZWQgY3Jvc3MtaW5zdGFuY2Ugc3RhdGUgc2hhcmluZyB3aXRoaW4gdGhlIE5lby5tanMgZnJhbWV3b3JrLlxuICogQGNsYXNzIE5lby5jb3JlLkNvbmZpZ1xuICogQHByaXZhdGVcbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBDb25maWcge1xuICAgIC8qKlxuICAgICAqIFN0b3JlcyBhbGwgc3Vic2NyaXB0aW9ucyBmb3IgdGhpcyBDb25maWcgaW5zdGFuY2UuXG4gICAgICogVGhlIGRhdGEgc3RydWN0dXJlIGlzIGEgTWFwIHdoZXJlOlxuICAgICAqIC0gVGhlIGtleSBpcyB0aGUgSUQgb2YgdGhlIHN1YnNjcmlwdGlvbiBvd25lciAoZS5nLiwgYSBjb21wb25lbnQncyBgaWRgKS5cbiAgICAgKiAtIFRoZSB2YWx1ZSBpcyBhbm90aGVyIE1hcCAodGhlIHN1YnNjcmliZXJNYXApLlxuICAgICAqXG4gICAgICogVGhlIG5lc3RlZCBzdWJzY3JpYmVyTWFwIGlzIHN0cnVjdHVyZWQgYXM6XG4gICAgICogLSBUaGUga2V5IGlzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiAoYGZuYCkuXG4gICAgICogLSBUaGUgdmFsdWUgaXMgYSBTZXQgb2Ygc2NvcGVzIChgc2NvcGVTZXRgKS5cbiAgICAgKlxuICAgICAqIFRoaXMgbmVzdGVkIHN0cnVjdHVyZSBgTWFwPHN0cmluZywgTWFwPGZ1bmN0aW9uLCBTZXQ8c2NvcGU+Pj5gIGlzIGludGVudGlvbmFsbHkgY2hvc2VuXG4gICAgICogdG8gcm9idXN0bHkgaGFuZGxlIHRoZSBlZGdlIGNhc2Ugd2hlcmUgdGhlIHNhbWUgZnVuY3Rpb24gaXMgc3Vic2NyaWJlZCBtdWx0aXBsZSB0aW1lc1xuICAgICAqIHdpdGggZGlmZmVyZW50IHNjb3BlcywgYWxsIHVuZGVyIHRoZSBzYW1lIG93bmVyIElELiBJdCBlbnN1cmVzIHRoYXQgZWFjaFxuICAgICAqIGBmbmAtYHNjb3BlYCBjb21iaW5hdGlvbiBpcyB1bmlxdWUgYW5kIHRoYXQgY2xlYW51cCBpcyBwcmVjaXNlLlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gI3N1YnNjcmliZXJzPXt9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICAjc3Vic2NyaWJlcnMgPSB7fVxuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlcm5hbCB2YWx1ZSBvZiB0aGUgY29uZmlnIHByb3BlcnR5LlxuICAgICAqIEBtZW1iZXIgeyp9ICN2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgI3ZhbHVlXG4gICAgLyoqXG4gICAgICogVGhlIGNsb25pbmcgc3RyYXRlZ3kgdG8gdXNlIHdoZW4gc2V0dGluZyBhIG5ldyB2YWx1ZS5cbiAgICAgKiBTdXBwb3J0ZWQgdmFsdWVzOiAnZGVlcCcsICdzaGFsbG93JywgJ25vbmUnLlxuICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xvbmU9J2RlZXAnXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2xvbmluZyBzdHJhdGVneSB0byB1c2Ugd2hlbiBnZXR0aW5nIGEgdmFsdWUuXG4gICAgICogU3VwcG9ydGVkIHZhbHVlczogJ2RlZXAnLCAnc2hhbGxvdycsICdub25lJy5cbiAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsb25lT25HZXQ9bnVsbFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZ1bmN0aW9uIHVzZWQgdG8gY29tcGFyZSBuZXcgYW5kIG9sZCB2YWx1ZXMgZm9yIGVxdWFsaXR5LlxuICAgICAqIERlZmF1bHRzIHRvIGBOZW8uaXNFcXVhbGAuIENhbiBiZSBvdmVycmlkZGVuIHZpYSBhIGRlc2NyaXB0b3IuXG4gICAgICogQG1lbWJlciB7RnVuY3Rpb259IGlzRXF1YWw9TmVvLmlzRXF1YWxcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBzdHJhdGVneSB0byB1c2Ugd2hlbiBtZXJnaW5nIG5ldyB2YWx1ZXMgaW50byB0aGlzIGNvbmZpZy5cbiAgICAgKiBEZWZhdWx0cyB0byAncmVwbGFjZScuIENhbiBiZSBvdmVycmlkZGVuIHZpYSBhIGRlc2NyaXB0b3IgbWVyZ2UgcHJvcGVydHkuXG4gICAgICogQG1lbWJlciB7RnVuY3Rpb258U3RyaW5nfSBtZXJnZVN0cmF0ZWd5PSdyZXBsYWNlJ1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBDb25maWcuXG4gICAgICogQHBhcmFtIHthbnl8T2JqZWN0fSBjb25maWdPYmplY3QgLSBUaGUgaW5pdGlhbCB2YWx1ZSBmb3IgdGhlIGNvbmZpZy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWdPYmplY3QpIHtcbiAgICAgICAgaWYgKE5lby5pc09iamVjdChjb25maWdPYmplY3QpICYmIGNvbmZpZ09iamVjdFtpc0Rlc2NyaXB0b3JdID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmluaXREZXNjcmlwdG9yKGNvbmZpZ09iamVjdClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI3ZhbHVlID0gY29uZmlnT2JqZWN0XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBjb25maWcgcHJvcGVydHkuXG4gICAgICogQHJldHVybnMge2FueX0gVGhlIGN1cnJlbnQgdmFsdWUuXG4gICAgICovXG4gICAgZ2V0KCkge1xuICAgICAgICAvLyBSZWdpc3RlcnMgdGhpcyBDb25maWcgaW5zdGFuY2UgYXMgYSBkZXBlbmRlbmN5IHdpdGggdGhlIGN1cnJlbnRseSBhY3RpdmUgRWZmZWN0LFxuICAgICAgICAvLyBlbmFibGluZyBhdXRvbWF0aWMgcmUtZXhlY3V0aW9uIHdoZW4gdGhpcyBDb25maWcncyB2YWx1ZSBjaGFuZ2VzLlxuICAgICAgICBFZmZlY3RNYW5hZ2VyLmFkZERlcGVuZGVuY3kodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLiN2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBgQ29uZmlnYCBpbnN0YW5jZSB1c2luZyBhIGRlc2NyaXB0b3Igb2JqZWN0LlxuICAgICAqIEV4dHJhY3RzIGBjbG9uZWAsIGBtZXJnZVN0cmF0ZWd5YCBhbmQgYGlzRXF1YWxgIGZyb20gdGhlIGRlc2NyaXB0b3IuXG4gICAgICogVGhlIGludGVybmFsIGAjdmFsdWVgIGlzIE5PVCBzZXQgYnkgdGhpcyBtZXRob2QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgIGRlc2NyaXB0b3IgICAgICAgICAgICAgICAgICAgICAgLSBUaGUgZGVzY3JpcHRvciBvYmplY3QgZm9yIHRoZSBjb25maWcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICAgW2Rlc2NyaXB0b3IuY2xvbmU9J2RlZXAnXSAgICAgICAgLSBUaGUgY2xvbmUgc3RyYXRlZ3kgZm9yIHNldC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gICBbZGVzY3JpcHRvci5jbG9uZU9uR2V0XSAgICAgICAgICAtIFRoZSBjbG9uZSBzdHJhdGVneSBmb3IgZ2V0LiBEZWZhdWx0cyB0byAnc2hhbGxvdycgaWYgY2xvbmUgaXMgJ2RlZXAnIG9yICdzaGFsbG93JywgYW5kICdub25lJyBpZiBjbG9uZSBpcyAnbm9uZScuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Rlc2NyaXB0b3IuaXNFcXVhbD1OZW8uaXNFcXVhbF0gLSBUaGUgZXF1YWxpdHkgY29tcGFyaXNvbiBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gICBbZGVzY3JpcHRvci5tZXJnZT0nZGVlcCddICAgICAgICAtIFRoZSBtZXJnZSBzdHJhdGVneS5cbiAgICAgKiBAcGFyYW0ge2FueX0gICAgICAgZGVzY3JpcHRvci52YWx1ZSAgICAgICAgICAgICAgICAtIFRoZSBkZWZhdWx0IHZhbHVlIGZvciB0aGUgY29uZmlnIChub3Qgc2V0IGJ5IHRoaXMgbWV0aG9kKS5cbiAgICAgKi9cbiAgICBpbml0RGVzY3JpcHRvcih7Y2xvbmUsIGNsb25lT25HZXQsIGlzRXF1YWwsIG1lcmdlfSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChjbG9uZSAmJiBjbG9uZSAhPT0gbWUuY2xvbmUpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZSwgJ2Nsb25lJywge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IGNsb25lLCB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbG9uZU9uR2V0ICYmIGNsb25lT25HZXQgIT09IG1lLmNsb25lT25HZXQpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZSwgJ2Nsb25lT25HZXQnLCB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogY2xvbmVPbkdldCwgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNFcXVhbCAmJiBpc0VxdWFsICE9PSBtZS5pc0VxdWFsKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWUsICdpc0VxdWFsJywge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IGlzRXF1YWwsIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lcmdlICYmIG1lcmdlICE9PSBtZS5tZXJnZVN0cmF0ZWd5KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWUsICdtZXJnZVN0cmF0ZWd5Jywge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IG1lcmdlLCB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vdGlmaWVzIGFsbCBzdWJzY3JpYmVkIGNhbGxiYWNrcyBhYm91dCBhIGNoYW5nZSBpbiB0aGUgY29uZmlnJ3MgdmFsdWUuXG4gICAgICogSXQgaXRlcmF0ZXMgdGhyb3VnaCB0aGUgbmVzdGVkIHN1YnNjcmliZXIgc3RydWN0dXJlIHRvIGVuc3VyZSBlYWNoIGNhbGxiYWNrXG4gICAgICogaXMgZXhlY3V0ZWQgd2l0aCBpdHMgaW50ZW5kZWQgc2NvcGUuXG4gICAgICogQHBhcmFtIHthbnl9IG5ld1ZhbHVlIC0gVGhlIG5ldyB2YWx1ZSBvZiB0aGUgY29uZmlnLlxuICAgICAqIEBwYXJhbSB7YW55fSBvbGRWYWx1ZSAtIFRoZSBvbGQgdmFsdWUgb2YgdGhlIGNvbmZpZy5cbiAgICAgKi9cbiAgICBub3RpZnkobmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgaW4gdGhpcy4jc3Vic2NyaWJlcnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNzdWJzY3JpYmVycy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJzY3JpYmVyTWFwID0gdGhpcy4jc3Vic2NyaWJlcnNbaWRdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2ZuLCBzY29wZVNldF0gb2Ygc3Vic2NyaWJlck1hcCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHNjb3BlIG9mIHNjb3BlU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbi5jYWxsKHNjb3BlIHx8IG51bGwsIG5ld1ZhbHVlLCBvbGRWYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgYSBuZXcgdmFsdWUgZm9yIHRoZSBjb25maWcgcHJvcGVydHkuXG4gICAgICogVGhpcyBtZXRob2QgcGVyZm9ybXMgYW4gZXF1YWxpdHkgY2hlY2sgdXNpbmcgYHRoaXMuaXNFcXVhbGAgYmVmb3JlIHVwZGF0aW5nIHRoZSB2YWx1ZS5cbiAgICAgKiBJZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWQsIGl0IHVwZGF0ZXMgYCN2YWx1ZWAgYW5kIG5vdGlmaWVzIGFsbCBzdWJzY3JpYmVycy5cbiAgICAgKiBAcGFyYW0ge2FueX0gbmV3VmFsdWUgLSBUaGUgbmV3IHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgY2hhbmdlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHNldChuZXdWYWx1ZSkge1xuICAgICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZhbHNlOyAvLyBQcmVzZXJ2ZSBvcmlnaW5hbCBiZWhhdmlvciBmb3IgdW5kZWZpbmVkXG5cbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIG9sZFZhbHVlID0gbWUuI3ZhbHVlO1xuXG4gICAgICAgIC8vIFRoZSBzZXR0ZXIgYXV0b21hdGljYWxseSB1c2VzIHRoZSBjb25maWd1cmVkIGVxdWFsaXR5IGNoZWNrXG4gICAgICAgIGlmICghbWUuaXNFcXVhbChuZXdWYWx1ZSwgb2xkVmFsdWUpKSB7XG4gICAgICAgICAgICBtZS4jdmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgIG1lLm5vdGlmeShuZXdWYWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGludGVybmFsIHZhbHVlIG9mIHRoZSBjb25maWcgcHJvcGVydHkgZGlyZWN0bHksIHdpdGhvdXQgcGVyZm9ybWluZ1xuICAgICAqIGFuIGVxdWFsaXR5IGNoZWNrIG9yIG5vdGlmeWluZyBzdWJzY3JpYmVycy5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBpbnRlbmRlZCBmb3IgaW50ZXJuYWwgZnJhbWV3b3JrIHVzZSB3aGVyZSBkaXJlY3QgYXNzaWdubWVudFxuICAgICAqIGlzIG5lY2Vzc2FyeSAoZS5nLiwgZHVyaW5nIGluaXRpYWwgc2V0dXAgb3Igc3BlY2lmaWMgaW50ZXJuYWwgb3B0aW1pemF0aW9ucykuXG4gICAgICogQHBhcmFtIHthbnl9IG5ld1ZhbHVlIC0gVGhlIG5ldyB2YWx1ZSB0byBzZXQgZGlyZWN0bHkuXG4gICAgICovXG4gICAgc2V0UmF3KG5ld1ZhbHVlKSB7XG4gICAgICAgIHRoaXMuI3ZhbHVlID0gbmV3VmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVzIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gY2hhbmdlcyBpbiB0aGlzIGNvbmZpZydzIHZhbHVlLlxuICAgICAqIFRoZSBjYWxsYmFjayB3aWxsIGJlIGludm9rZWQgd2l0aCBgKG5ld1ZhbHVlLCBvbGRWYWx1ZSlgIHdoZW5ldmVyIHRoZSBjb25maWcgY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICBvcHRpb25zICAgICAgICAtIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBzdWJzY3JpcHRpb24gZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICBvcHRpb25zLmlkICAgICAtIFRoZSBJRCBvZiB0aGUgc3Vic2NyaXB0aW9uIG93bmVyIChlLmcuLCBhIE5lby5jb3JlLkJhc2UgaW5zdGFuY2UncyBpZCkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5mbiAgICAgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICBbb3B0aW9ucy5zY29wZV0gLSBUaGUgc2NvcGUgdG8gZXhlY3V0ZSB0aGUgY2FsbGJhY2sgaW4uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBBIGNsZWFudXAgZnVuY3Rpb24gdG8gdW5zdWJzY3JpYmUgdGhlIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIHN1YnNjcmliZSh7aWQsIGZuLCBzY29wZX0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycgfHwgaWQubGVuZ3RoID09PSAwIHx8IHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFtcbiAgICAgICAgICAgICAgICAnQ29uZmlnLnN1YnNjcmliZTogb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCB3aXRoIGEgbm9uLWVtcHR5IHN0cmluZyBgaWRgICcsXG4gICAgICAgICAgICAgICAgJyh0aGUgc3Vic2NyaXB0aW9uIG93bmVyXFwncyBpZCksIGFuZCBhIGNhbGxiYWNrIGZ1bmN0aW9uIGBmbmAuJ1xuICAgICAgICAgICAgXS5qb2luKCcnKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1lID0gdGhpcztcblxuICAgICAgICAvLyBHZXQgb3IgY3JlYXRlIHRoZSB0b3AtbGV2ZWwgTWFwIGZvciB0aGUgc3Vic2NyaXB0aW9uIG93bmVyLlxuICAgICAgICBpZiAoIW1lLiNzdWJzY3JpYmVyc1tpZF0pIHtcbiAgICAgICAgICAgIG1lLiNzdWJzY3JpYmVyc1tpZF0gPSBuZXcgTWFwKClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN1YnNjcmliZXJNYXAgPSBtZS4jc3Vic2NyaWJlcnNbaWRdO1xuXG4gICAgICAgIC8vIEdldCBvciBjcmVhdGUgdGhlIFNldCBvZiBzY29wZXMgZm9yIHRoZSBzcGVjaWZpYyBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgICAgaWYgKCFzdWJzY3JpYmVyTWFwLmhhcyhmbikpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXJNYXAuc2V0KGZuLCBuZXcgU2V0KCkpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzY29wZVNldCA9IHN1YnNjcmliZXJNYXAuZ2V0KGZuKTtcbiAgICAgICAgc2NvcGVTZXQuYWRkKHNjb3BlKTtcblxuICAgICAgICAvLyBUaGUgcmV0dXJuZWQgY2xlYW51cCBmdW5jdGlvbiBpcyBwcmVjaXNlLiBJdCByZW1vdmVzIG9ubHkgdGhlIHNwZWNpZmljXG4gICAgICAgIC8vIHNjb3BlIGZvciB0aGUgZnVuY3Rpb24sIGFuZCBjbGVhbnMgdXAgdGhlIHBhcmVudCBkYXRhIHN0cnVjdHVyZXNcbiAgICAgICAgLy8gKHRoZSBTZXQgYW5kIHRoZSBNYXBzKSBvbmx5IGlmIHRoZXkgYmVjb21lIGVtcHR5LlxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFN1YnNjcmliZXJNYXAgPSBtZS4jc3Vic2NyaWJlcnNbaWRdO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRTdWJzY3JpYmVyTWFwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFNjb3BlU2V0ID0gY3VycmVudFN1YnNjcmliZXJNYXAuZ2V0KGZuKTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFNjb3BlU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTY29wZVNldC5kZWxldGUoc2NvcGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFNjb3BlU2V0LnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdWJzY3JpYmVyTWFwLmRlbGV0ZShmbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFN1YnNjcmliZXJNYXAuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBtZS4jc3Vic2NyaWJlcnNbaWRdXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENvbmZpZy5wcm90b3R5cGUsIHtcbiAgICBjbG9uZSAgICAgICAgOiB7Y29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiBmYWxzZSwgdmFsdWU6ICdkZWVwJywgICAgICB3cml0YWJsZTogZmFsc2V9LFxuICAgIGNsb25lT25HZXQgICA6IHtjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IGZhbHNlLCB2YWx1ZTogbnVsbCwgICAgICAgIHdyaXRhYmxlOiBmYWxzZX0sXG4gICAgaXNFcXVhbCAgICAgIDoge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogZmFsc2UsIHZhbHVlOiBOZW8uaXNFcXVhbCwgd3JpdGFibGU6IGZhbHNlfSxcbiAgICBtZXJnZVN0cmF0ZWd5OiB7Y29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiBmYWxzZSwgdmFsdWU6ICdyZXBsYWNlJywgICB3cml0YWJsZTogZmFsc2V9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgTmVvLmdhdGVrZWVwKENvbmZpZywgJ05lby5jb3JlLkNvbmZpZycpO1xuIiwiXG4vLyBlLmcuLCBpbiBhIG5ldyBmaWxlIHNyYy9jb3JlL0NvbmZpZ1N5bWJvbHMubWpzXG5leHBvcnQgY29uc3QgaXNEZXNjcmlwdG9yID0gU3ltYm9sLmZvcignTmVvLkNvbmZpZy5pc0Rlc2NyaXB0b3InKTtcbiIsIi8qKlxuICogQSBzaW5nbGV0b24gbWFuYWdlciB0byB0cmFjayB0aGUgY3VycmVudGx5IHJ1bm5pbmcgZWZmZWN0IGFuZCBjb250cm9sIGdsb2JhbCBlZmZlY3QgZXhlY3V0aW9uLlxuICogSXQgcHJvdmlkZXMgYSBjZW50cmFsaXplZCBtZWNoYW5pc20gZm9yIHBhdXNpbmcsIHJlc3VtaW5nLCBhbmQgYmF0Y2hpbmcgZWZmZWN0IHJ1bnMuXG4gKiBAY2xhc3MgTmVvLmNvcmUuRWZmZWN0TWFuYWdlclxuICogQHNpbmdsZXRvblxuICovXG5jb25zdCBFZmZlY3RNYW5hZ2VyID0ge1xuICAgIC8qKlxuICAgICAqIEEgc3RhY2sgdG8ga2VlcCB0cmFjayBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSBlZmZlY3QgYW5kIGl0cyBwcmVkZWNlc3NvcnMuXG4gICAgICogQG1lbWJlciB7TmVvLmNvcmUuRWZmZWN0W119IGVmZmVjdFN0YWNrPVtdXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGVmZmVjdFN0YWNrOiBbXSxcbiAgICAvKipcbiAgICAgKiBBIGZsYWcgdG8gdGVtcG9yYXJpbHkgZGlzYWJsZSBkZXBlbmRlbmN5IHRyYWNraW5nIGZvciB0aGUgYWN0aXZlIGVmZmVjdC5cbiAgICAgKiBUaGlzIGlzIHVzZWQgaW50ZXJuYWxseSB0byBwcmV2ZW50IGVmZmVjdHMgZnJvbSBkZXBlbmRpbmcgb24gdGhlaXIgb3duIHN0YXRlLCBsaWtlIGBpc1J1bm5pbmdgLlxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzVHJhY2tpbmdQYXVzZWQ9ZmFsc2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaXNUcmFja2luZ1BhdXNlZDogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQSBjb3VudGVyIHRvIG1hbmFnZSBuZXN0ZWQgY2FsbHMgdG8gcGF1c2UoKSBhbmQgcmVzdW1lKCkuIEVmZmVjdCBleGVjdXRpb24gaXNcbiAgICAgKiBwYXVzZWQgb3IgYmF0Y2hlZCB3aGlsZSB0aGlzIGNvdW50ZXIgaXMgZ3JlYXRlciB0aGFuIDAuXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSBwYXVzZUNvdW50ZXI9MFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwYXVzZUNvdW50ZXI6IDAsXG4gICAgLyoqXG4gICAgICogQSBTZXQgdG8gc3RvcmUgdW5pcXVlIGVmZmVjdHMgdGhhdCBhcmUgdHJpZ2dlcmVkIHdoaWxlIHRoZSBtYW5hZ2VyIGlzIHBhdXNlZC5cbiAgICAgKiBUaGVzZSBlZmZlY3RzIHdpbGwgYmUgcnVuIHdoZW4gcmVzdW1lKCkgaXMgY2FsbGVkIGFuZCB0aGUgcGF1c2VDb3VudGVyIHJldHVybnMgdG8gMC5cbiAgICAgKiBAbWVtYmVyIHtTZXQ8TmVvLmNvcmUuRWZmZWN0Pn0gcXVldWVkRWZmZWN0cz1uZXcgU2V0KClcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcXVldWVkRWZmZWN0czogbmV3IFNldCgpLFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGBOZW8uY29yZS5Db25maWdgIGluc3RhbmNlIGFzIGEgZGVwZW5kZW5jeSBmb3IgdGhlIGN1cnJlbnRseSBhY3RpdmUgZWZmZWN0LFxuICAgICAqIHVubGVzcyBkZXBlbmRlbmN5IHRyYWNraW5nIGlzIGV4cGxpY2l0bHkgcGF1c2VkLlxuICAgICAqIEBwYXJhbSB7TmVvLmNvcmUuQ29uZmlnfSBjb25maWcgVGhlIGNvbmZpZyBpbnN0YW5jZSB0byBhZGQgYXMgYSBkZXBlbmRlbmN5LlxuICAgICAqL1xuICAgIGFkZERlcGVuZGVuY3koY29uZmlnKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1RyYWNraW5nUGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLmdldEFjdGl2ZUVmZmVjdCgpPy5hZGREZXBlbmRlbmN5KGNvbmZpZylcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBlZmZlY3QgY3VycmVudGx5IGF0IHRoZSB0b3Agb2YgdGhlIHN0YWNrIChpLmUuLCB0aGUgb25lIGN1cnJlbnRseSBydW5uaW5nKS5cbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvcmUuRWZmZWN0fG51bGx9XG4gICAgICovXG4gICAgZ2V0QWN0aXZlRWZmZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lZmZlY3RTdGFja1t0aGlzLmVmZmVjdFN0YWNrLmxlbmd0aCAtIDFdXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBlZmZlY3QgZXhlY3V0aW9uIGlzIGN1cnJlbnRseSBwYXVzZWQgb3IgYmF0Y2hlZC5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGF1c2VDb3VudGVyIGlzIGdyZWF0ZXIgdGhhbiAwLlxuICAgICAqL1xuICAgIGlzUGF1c2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXVzZUNvdW50ZXIgPiAwXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhdXNlcyBlZmZlY3QgZXhlY3V0aW9uIGFuZCBiZWdpbnMgYmF0Y2hpbmcuXG4gICAgICogRWFjaCBjYWxsIHRvIHBhdXNlKCkgaW5jcmVtZW50cyBhIGNvdW50ZXIsIGFsbG93aW5nIGZvciBuZXN0ZWQgY29udHJvbC5cbiAgICAgKi9cbiAgICBwYXVzZSgpIHtcbiAgICAgICAgdGhpcy5wYXVzZUNvdW50ZXIrK1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXNhYmxlcyBkZXBlbmRlbmN5IHRyYWNraW5nIGZvciB0aGUgY3VycmVudGx5IGFjdGl2ZSBlZmZlY3QuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHBhdXNlVHJhY2tpbmcoKSB7XG4gICAgICAgIHRoaXMuaXNUcmFja2luZ1BhdXNlZCA9IHRydWVcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUG9wcyB0aGUgY3VycmVudCBlZmZlY3QgZnJvbSB0aGUgc3RhY2suXG4gICAgICogQHJldHVybnMge05lby5jb3JlLkVmZmVjdHxudWxsfVxuICAgICAqL1xuICAgIHBvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWZmZWN0U3RhY2sucG9wKClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHVzaGVzIGFuIGVmZmVjdCBvbnRvIHRoZSBzdGFjay5cbiAgICAgKiBAcGFyYW0ge05lby5jb3JlLkVmZmVjdH0gZWZmZWN0IFRoZSBlZmZlY3QgdG8gcHVzaC5cbiAgICAgKi9cbiAgICBwdXNoKGVmZmVjdCkge1xuICAgICAgICB0aGlzLmVmZmVjdFN0YWNrLnB1c2goZWZmZWN0KVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBRdWV1ZXMgYSB1bmlxdWUgZWZmZWN0IHRvIGJlIHJ1biBsYXRlci5cbiAgICAgKiBAcGFyYW0ge05lby5jb3JlLkVmZmVjdH0gZWZmZWN0IFRoZSBlZmZlY3QgdG8gcXVldWUuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHF1ZXVlKGVmZmVjdCkge1xuICAgICAgICB0aGlzLnF1ZXVlZEVmZmVjdHMuYWRkKGVmZmVjdClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzdW1lcyBlZmZlY3QgZXhlY3V0aW9uLiBJZiB0aGUgcGF1c2UgY291bnRlciByZXR1cm5zIHRvIHplcm8gYW5kIGVmZmVjdHNcbiAgICAgKiBoYXZlIGJlZW4gcXVldWVkLCB0aGV5IHdpbGwgYWxsIGJlIGV4ZWN1dGVkIHN5bmNocm9ub3VzbHkuXG4gICAgICovXG4gICAgcmVzdW1lKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5wYXVzZUNvdW50ZXIgPiAwKSB7XG4gICAgICAgICAgICBtZS5wYXVzZUNvdW50ZXItLTtcblxuICAgICAgICAgICAgaWYgKG1lLnBhdXNlQ291bnRlciA9PT0gMCAmJiBtZS5xdWV1ZWRFZmZlY3RzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWZmZWN0c1RvUnVuID0gWy4uLm1lLnF1ZXVlZEVmZmVjdHNdO1xuICAgICAgICAgICAgICAgIG1lLnF1ZXVlZEVmZmVjdHMuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICBlZmZlY3RzVG9SdW4uZm9yRWFjaChlZmZlY3QgPT4gZWZmZWN0LnJ1bigpKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlLWVuYWJsZXMgZGVwZW5kZW5jeSB0cmFja2luZyBmb3IgdGhlIGN1cnJlbnRseSBhY3RpdmUgZWZmZWN0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICByZXN1bWVUcmFja2luZygpIHtcbiAgICAgICAgdGhpcy5pc1RyYWNraW5nUGF1c2VkID0gZmFsc2VcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBOZW8uZ2F0ZWtlZXAoRWZmZWN0TWFuYWdlciwgJ05lby5jb3JlLkVmZmVjdE1hbmFnZXInLCAoKSA9PiB7XG4gICAgLyoqXG4gICAgICogV3JhcHMgYSBmdW5jdGlvbiBpbiBhIGJhdGNoIG9wZXJhdGlvbiwgZW5zdXJpbmcgdGhhdCBhbGwgZWZmZWN0cyB0cmlnZ2VyZWRcbiAgICAgKiB3aXRoaW4gaXQgYXJlIHJ1biBvbmx5IG9uY2UgYWZ0ZXIgdGhlIGZ1bmN0aW9uIGNvbXBsZXRlcy5cbiAgICAgKiBAZnVuY3Rpb24gTmVvLmJhdGNoXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUuXG4gICAgICovXG4gICAgTmVvLmJhdGNoID0gZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgRWZmZWN0TWFuYWdlci5wYXVzZSgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm4oKVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgLy8gVGhlIHB1YmxpYyByZXN1bWUoKSBtZXRob2QgaGFuZGxlcyBydW5uaW5nIHF1ZXVlZCBlZmZlY3RzLlxuICAgICAgICAgICAgRWZmZWN0TWFuYWdlci5yZXN1bWUoKVxuICAgICAgICB9XG4gICAgfVxufSk7XG4iLCIvKipcbiAqIFByb3ZpZGVzIGEgc2luZ2xldG9uIHV0aWxpdHkgZm9yIGdlbmVyYXRpbmcgdW5pcXVlIElEcy5cbiAqIEBuYW1lc3BhY2UgTmVvLmNvcmUuSWRHZW5lcmF0b3JcbiAqL1xuY29uc3QgSWRHZW5lcmF0b3IgPSB7XG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgcHJlZml4IGZvciBuZW8gaW5zdGFuY2UgaWRzXG4gICAgICogQG1lbWJlciB7U3RyaW5nfSBiYXNlPSduZW8tJ1xuICAgICAqL1xuICAgIGJhc2U6ICduZW8tJyxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGlkQ291bnRlcj17fVxuICAgICAqL1xuICAgIGlkQ291bnRlcjoge30sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbmFtZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0SWQobmFtZSkge1xuICAgICAgICBuYW1lID0gbmFtZSB8fCAnbmVvJztcblxuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb3VudGVyID0gbWUuaWRDb3VudGVyLFxuICAgICAgICAgICAgY291bnQgICA9IGNvdW50ZXJbbmFtZV0gfHwgMDtcblxuICAgICAgICBjb3VudGVyW25hbWVdID0gKytjb3VudDtcblxuICAgICAgICByZXR1cm4gbWUuYmFzZSArIChuYW1lID09PSAnbmVvJyA/ICcnIDogbmFtZSArICctJykgKyBjb3VudDtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5nYXRla2VlcChJZEdlbmVyYXRvciwgJ05lby5jb3JlLklkR2VuZXJhdG9yJywgKCkgPT4ge1xuICAgIE5lby5nZXRJZCA9IElkR2VuZXJhdG9yLmdldElkLmJpbmQoSWRHZW5lcmF0b3IpO1xufSk7XG4iLCJpbXBvcnQgQmFzZSAgICAgICAgICAgICAgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgICAgICAgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IHtpc0Rlc2NyaXB0b3J9ICAgIGZyb20gJy4uL2NvcmUvQ29uZmlnU3ltYm9scy5tanMnO1xuaW1wb3J0IHtyZXNvbHZlQ2FsbGJhY2t9IGZyb20gJy4uL3V0aWwvRnVuY3Rpb24ubWpzJztcblxuLyoqXG4gKiBBIHVuaXF1ZSwgbm9uLWVudW1lcmFibGUga2V5IGZvciB0aGUgaW50ZXJuYWwgZXZlbnQgbWFwLlxuICogVXNpbmcgYSBTeW1ib2wgcHJldmVudHMgcHJvcGVydHkgbmFtZSBjb2xsaXNpb25zIG9uIHRoZSBjb25zdW1pbmcgY2xhc3MgaW5zdGFuY2UsXG4gKiBwcm92aWRpbmcgYSByb2J1c3Qgd2F5IHRvIG1hbmFnZSBwcml2YXRlIHN0YXRlIHdpdGhpbiBhIG1peGluLlxuICogQHR5cGUge1N5bWJvbH1cbiAqL1xuY29uc3QgZXZlbnRNYXBTeW1ib2wgPSBTeW1ib2woJ2V2ZW50TWFwJyk7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jb3JlLk9ic2VydmFibGVcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgT2JzZXJ2YWJsZSBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvcmUuT2JzZXJ2YWJsZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvcmUuT2JzZXJ2YWJsZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdtaXhpbi1vYnNlcnZhYmxlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ21peGluLW9ic2VydmFibGUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQSBkZWNsYXJhdGl2ZSB3YXkgdG8gYXNzaWduIGV2ZW50IGxpc3RlbmVycyB0byBhbiBpbnN0YW5jZSB1cG9uIGNyZWF0aW9uLlxuICAgICAgICAgKiBUaGUgZnJhbWV3b3JrIHByb2Nlc3NlcyB0aGlzIGNvbmZpZyBhbmQgY2FsbHMgYG9uKClgIHRvIHBvcHVsYXRlIHRoZVxuICAgICAgICAgKiBpbnRlcm5hbCBldmVudCByZWdpc3RyeS4gVGhpcyBjb25maWcgc2hvdWxkIG5vdCBiZSBtYW5pcHVsYXRlZCBkaXJlY3RseSBhZnRlclxuICAgICAgICAgKiBpbnN0YW50aWF0aW9uOyB1c2UgYG9uKClgIGFuZCBgdW4oKWAgaW5zdGVhZC5cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGxpc3RlbmVyc19cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogbGlzdGVuZXJzOiB7XG4gICAgICAgICAqICAgICBteUV2ZW50OiAnb25NeUV2ZW50JyxcbiAgICAgICAgICogICAgIG90aGVyRXZlbnQ6IHtcbiAgICAgICAgICogICAgICAgICBmbjogJ29uT3RoZXJFdmVudCcsXG4gICAgICAgICAqICAgICAgICAgZGVsYXk6IDEwMCxcbiAgICAgICAgICogICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgICAqICAgICB9LFxuICAgICAgICAgKiAgICAgc2NvcGU6IHRoaXNcbiAgICAgICAgICogfVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGxpc3RlbmVyc186IHtcbiAgICAgICAgICAgIFtpc0Rlc2NyaXB0b3JdOiB0cnVlLFxuICAgICAgICAgICAgbWVyZ2UgICAgICAgICA6ICdkZWVwJyxcbiAgICAgICAgICAgIHZhbHVlICAgICAgICAgOiB7fVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBbZXZlbnRNYXBTeW1ib2xdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c11cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZXZlbnRJZF1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2RhdGFdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBbb3JkZXJdXG4gICAgICogQHJldHVybnMge1N0cmluZ3xudWxsfSBldmVudElkIG51bGwgaW4gY2FzZSBhbiBvYmplY3QgZ2V0cyBwYXNzZWQgYXMgdGhlIG5hbWUgKG11bHRpcGxlIGlkcylcbiAgICAgKi9cbiAgICBhZGRMaXN0ZW5lcihuYW1lLCBvcHRzLCBzY29wZSwgZXZlbnRJZCwgZGF0YSwgb3JkZXIpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZGVsYXkgICAgICAgICA9IDAsXG4gICAgICAgICAgICBldmVudElkT2JqZWN0ID0gdHlwZW9mIGV2ZW50SWQgPT09ICdvYmplY3QnLFxuICAgICAgICAgICAgbmFtZU9iamVjdCAgICA9IHR5cGVvZiBuYW1lICAgID09PSAnb2JqZWN0JyxcbiAgICAgICAgICAgIG9uY2UgICAgICAgICAgPSBmYWxzZSxcbiAgICAgICAgICAgIG9wdHNUeXBlICAgICAgPSB0eXBlb2Ygb3B0cyxcbiAgICAgICAgICAgIGxpc3RlbmVyLCBleGlzdGluZywgZXZlbnRDb25maWc7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogbGV0IHVzIHN1cHBvcnQgdGhlIGZvbGxvd2luZyBmb3JtYXQgdG9vOlxuICAgICAgICAgKlxuICAgICAgICAgKiBjdXJyZW50V29ya2VyLm9uKCdjb25uZWN0ZWQnLCAoKSA9PiB7XG4gICAgICAgICAqICAgICBCYXNlLnNlbmRSZW1vdGVzKGNsYXNzTmFtZSwgcmVtb3RlKVxuICAgICAgICAgKiB9LCBtZSwge29uY2U6IHRydWV9KVxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGV2ZW50SWRPYmplY3QgJiYgb3B0c1R5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGV2ZW50SWQuZm4gPSBvcHRzO1xuICAgICAgICAgICAgb3B0cyAgICAgPSBldmVudElkO1xuICAgICAgICAgICAgb3B0c1R5cGUgPSAnb2JqZWN0JztcbiAgICAgICAgICAgIGV2ZW50SWQgID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuYW1lT2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAobmFtZS5oYXNPd25Qcm9wZXJ0eSgnZGVsYXknKSkge1xuICAgICAgICAgICAgICAgIGRlbGF5ID0gbmFtZS5kZWxheTtcbiAgICAgICAgICAgICAgICBkZWxldGUgbmFtZS5kZWxheVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmFtZS5oYXNPd25Qcm9wZXJ0eSgnb25jZScpKSB7XG4gICAgICAgICAgICAgICAgb25jZSA9IG5hbWUub25jZTtcbiAgICAgICAgICAgICAgICBkZWxldGUgbmFtZS5vbmNlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuYW1lLmhhc093blByb3BlcnR5KCdvcmRlcicpKSB7XG4gICAgICAgICAgICAgICAgb3JkZXIgPSBuYW1lLm9yZGVyO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBuYW1lLm9yZGVyXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuYW1lLmhhc093blByb3BlcnR5KCdzY29wZScpKSB7XG4gICAgICAgICAgICAgICAgc2NvcGUgPSBuYW1lLnNjb3BlO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBuYW1lLnNjb3BlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKG5hbWUpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChOZW8uaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmFkZExpc3RlbmVyKGtleSwge2RlbGF5LCBvbmNlLCBvcmRlciwgc2NvcGUsIC4uLnZhbHVlfSlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZS5hZGRMaXN0ZW5lcihrZXksIHtkZWxheSwgZm46IHZhbHVlLCBvbmNlLCBvcmRlciwgc2NvcGV9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSBpZiAob3B0c1R5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBkZWxheSAgICA9IGRlbGF5ICAgfHwgb3B0cy5kZWxheTtcbiAgICAgICAgICAgIGV2ZW50SWQgID0gZXZlbnRJZCB8fCBvcHRzLmV2ZW50SWQ7XG4gICAgICAgICAgICBsaXN0ZW5lciA9IG9wdHMuZm47XG4gICAgICAgICAgICBvbmNlICAgICA9IG9uY2UgICAgfHwgb3B0cy5vbmNlO1xuICAgICAgICAgICAgb3JkZXIgICAgPSBvcmRlciAgIHx8IG9wdHMub3JkZXI7XG4gICAgICAgICAgICBzY29wZSAgICA9IHNjb3BlICAgfHwgb3B0cy5zY29wZVxuICAgICAgICB9IGVsc2UgaWYgKG9wdHNUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBsaXN0ZW5lciA9IG9wdHNcbiAgICAgICAgfSBlbHNlIGlmIChvcHRzVHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyID0gb3B0cyAvLyBWQyBob29rLCBjYW4gZ2V0IHBhcnNlZCBhZnRlciBvbkNvbnN0cnVjdGVkIGluIGNhc2UgdGhlIHZpZXcgdXNlcyB0aGUgcGFyZW50IFZDXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWRkTGlzdGVuZXIgY2FsbDogJyArIG5hbWUpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW5hbWVPYmplY3QpIHtcbiAgICAgICAgICAgIC8vIExBWlkgSU5JVElBTElaQVRJT046IFRoZSBrZXkgdG8gYSByb2J1c3QgbWl4aW4uXG4gICAgICAgICAgICAvLyBUaGlzIGVuc3VyZXMgdGhlIHByaXZhdGUgaW50ZXJuYWwgbGlzdGVuZXIgc3RvcmUgZXhpc3RzIG9uIHRoZSBpbnN0YW5jZS5cbiAgICAgICAgICAgIC8vIGBldmVudE1hcFN5bWJvbGAgaXMgdGhlICphY3R1YWwqIHJlZ2lzdHJ5IG9mIGhhbmRsZXIgYXJyYXlzLCBhbmQgaXNcbiAgICAgICAgICAgIC8vIGludGVudGlvbmFsbHkgc2VwYXJhdGUgZnJvbSB0aGUgcHVibGljIGBsaXN0ZW5lcnNfYCBjb25maWcuXG4gICAgICAgICAgICBtZVtldmVudE1hcFN5bWJvbF0gPz89IHt9O1xuXG4gICAgICAgICAgICBldmVudENvbmZpZyA9IHtmbjogbGlzdGVuZXIsIGlkOiBldmVudElkIHx8IE5lby5nZXRJZCgnZXZlbnQnKX07XG5cbiAgICAgICAgICAgIGlmIChkYXRhKSAgICAgIHtldmVudENvbmZpZy5kYXRhICAgPSBkYXRhfVxuICAgICAgICAgICAgaWYgKGRlbGF5ID4gMCkge2V2ZW50Q29uZmlnLmRlbGF5ICA9IGRlbGF5fVxuICAgICAgICAgICAgaWYgKG9uY2UpICAgICAge2V2ZW50Q29uZmlnLm9uY2UgICA9IG9uY2V9XG4gICAgICAgICAgICBpZiAoc2NvcGUpICAgICB7ZXZlbnRDb25maWcuc2NvcGUgID0gc2NvcGV9XG5cbiAgICAgICAgICAgIGlmICgoZXhpc3RpbmcgPSBtZVtldmVudE1hcFN5bWJvbF1bbmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgZXhpc3RpbmcuZm9yRWFjaChjZmcgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ZnLmlkID09PSBldmVudElkIHx8IChjZmcuZm4gPT09IGxpc3RlbmVyICYmIGNmZy5zY29wZSA9PT0gc2NvcGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdEdXBsaWNhdGUgZXZlbnQgaGFuZGxlciBhdHRhY2hlZDonLCBuYW1lLCBtZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcmRlciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhpc3Rpbmcuc3BsaWNlKG9yZGVyLCAwLCBldmVudENvbmZpZylcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAnYmVmb3JlJykge1xuICAgICAgICAgICAgICAgICAgICBleGlzdGluZy51bnNoaWZ0KGV2ZW50Q29uZmlnKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLnB1c2goZXZlbnRDb25maWcpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZVtldmVudE1hcFN5bWJvbF1bbmFtZV0gPSBbZXZlbnRDb25maWddIC8vIFVzZSB0aGUgcHJpdmF0ZSBldmVudE1hcFN5bWJvbCByZWdpc3RyeVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZXZlbnRDb25maWcuaWRcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBob29rIGlzIHRoZSBicmlkZ2UgYmV0d2VlbiB0aGUgZGVjbGFyYXRpdmUgYGxpc3RlbmVyc19gIGNvbmZpZyBhbmQgdGhlXG4gICAgICogaW1wZXJhdGl2ZSBgb24oKWAvYHVuKClgIG1ldGhvZHMuIEl0J3MgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYnkgdGhlIGZyYW1ld29ya1xuICAgICAqIHdoZW5ldmVyIHRoZSBgbGlzdGVuZXJzYCBjb25maWcgcHJvcGVydHkgaXMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgVGhlIG5ldyBsaXN0ZW5lcnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFZhbHVlIFRoZSBvbGQgbGlzdGVuZXJzIG9iamVjdFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldExpc3RlbmVycyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgLy8gVW5yZWdpc3RlciBhbnkgbGlzdGVuZXJzIGZyb20gdGhlIG9sZCBjb25maWcgb2JqZWN0XG4gICAgICAgIGlmIChvbGRWYWx1ZSAmJiBPYmplY3Qua2V5cyhvbGRWYWx1ZSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy51bihvbGRWYWx1ZSlcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWdpc3RlciBhbGwgbGlzdGVuZXJzIGZyb20gdGhlIG5ldyBjb25maWcgb2JqZWN0XG4gICAgICAgIGlmICh2YWx1ZSAmJiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5vbih2YWx1ZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgdGhlIHBhc3NlZCBmdW5jdGlvbiwgb3IgYSBmdW5jdGlvbiBieSAqbmFtZSogd2hpY2ggZXhpc3RzIGluIHRoZSBwYXNzZWQgc2NvcGUnc1xuICAgICAqIG9yIHRoaXMgY29tcG9uZW50J3Mgb3duZXJzaGlwIGNoYWluLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBmbiBBIGZ1bmN0aW9uLCBvciB0aGUgbmFtZSBvZiBhIGZ1bmN0aW9uIHRvIGZpbmQgaW4gdGhlIHBhc3NlZCBzY29wZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNjb3BlICAgICAgIFRoZSBzY29wZSB0byBmaW5kIHRoZSBmdW5jdGlvbiBpbiBpZiBpdCBpcyBzcGVjaWZpZWQgYXMgYSBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyAgICAgICAgIEFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBjYWxsYmFjayhmbiwgc2NvcGU9dGhpcywgYXJncykge1xuICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSByZXNvbHZlQ2FsbGJhY2soZm4sIHNjb3BlKTtcbiAgICAgICAgICAgIGhhbmRsZXIuZm4uYXBwbHkoaGFuZGxlci5zY29wZSwgYXJncylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGhlbHBlciBtZXRob2QgZm9yIGV2ZW50cyB3aGljaCB1c2UgdGhlIGRlbGF5IG9wdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3NcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVsYXlcbiAgICAgKi9cbiAgICBkZWxheWVkQ2FsbGJhY2soY2IsIGFyZ3MsIGRlbGF5KSB7XG4gICAgICAgIHRoaXMudGltZW91dChkZWxheSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBjYi5mbi5hcHBseShjYi5zY29wZSwgYXJncylcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbmFtZVxuICAgICAqL1xuICAgIGZpcmUobmFtZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGFyZ3MgICAgICA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcbiAgICAgICAgICAgIGxpc3RlbmVycyA9IG1lW2V2ZW50TWFwU3ltYm9sXSwgLy8gQWx3YXlzIHVzZSB0aGUgcHJpdmF0ZSwgc3RydWN0dXJlZCByZWdpc3RyeSBmb3IgZmlyaW5nIGV2ZW50cy5cbiAgICAgICAgICAgIGRlbGF5LCBoYW5kbGVyLCBoYW5kbGVycywgaSwgbGVuO1xuXG4gICAgICAgIGlmIChsaXN0ZW5lcnMgJiYgbGlzdGVuZXJzW25hbWVdKSB7XG4gICAgICAgICAgICBoYW5kbGVycyA9IFsuLi5saXN0ZW5lcnNbbmFtZV1dO1xuICAgICAgICAgICAgbGVuICAgICAgPSBoYW5kbGVycy5sZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBoYW5kbGVyc1tpXTtcbiAgICAgICAgICAgICAgICBkZWxheSAgID0gaGFuZGxlci5kZWxheTtcblxuICAgICAgICAgICAgICAgIC8vIFJlc29sdmUgZnVuY3Rpb24gbmFtZSBvbiB0aGUgc2NvcGUgKG9yIG1lKSwgb3IsIGlmIGl0IHN0YXJ0cyB3aXRoICd1cC4nXG4gICAgICAgICAgICAgICAgLy8gbG9vayBpbiB0aGUgb3duZXJzaGlwIGhpZXJhcmNoeSBmcm9tIG1lLlxuICAgICAgICAgICAgICAgIGNvbnN0IGNiID0gcmVzb2x2ZUNhbGxiYWNrKGhhbmRsZXIuZm4sIGhhbmRsZXIuc2NvcGUgfHwgbWUpO1xuXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBsaXN0ZW5lciBpZiB0aGUgc2NvcGUgbm8gbG9uZ2VyIGV4aXN0c1xuICAgICAgICAgICAgICAgIGlmIChjYi5zY29wZSAmJiAhY2Iuc2NvcGUuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGxpc3RlbmVyc1tuYW1lXSwgaGFuZGxlcilcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1lLnN1c3BlbmRFdmVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9iamVjdCBldmVudCBmb3JtYXQuIEluamVjdCBmaXJlciByZWZlcmVuY2UgaW4gYXMgJ3NvdXJjZSdcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiBOZW8uaXNPYmplY3QoYXJnc1swXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzWzBdLnNvdXJjZSA9IG1lLmlkXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgbGlzdGVuZXIgaWYgaXQgaGFzIHRoZSBvbmNlIGZsYWdcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIub25jZSAmJiBOZW9BcnJheS5yZW1vdmUobGlzdGVuZXJzW25hbWVdLCBoYW5kbGVyKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE5lby5pc051bWJlcihkZWxheSkgJiYgZGVsYXkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUuZGVsYXllZENhbGxiYWNrKGNiLCBoYW5kbGVyLmRhdGEgPyBhcmdzLmNvbmNhdChoYW5kbGVyLmRhdGEpIDogYXJncywgZGVsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNiLmZuLmFwcGx5KGNiLnNjb3BlLCBoYW5kbGVyLmRhdGEgPyBhcmdzLmNvbmNhdChoYW5kbGVyLmRhdGEpIDogYXJncylcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciBhZGRMaXN0ZW5lclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c11cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZXZlbnRJZF1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2RhdGFdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcmRlcl1cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBldmVudElkXG4gICAgICovXG4gICAgb24oLi4uYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRMaXN0ZW5lciguLi5hcmdzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZXJlIGFyZSBkaWZmZXJlbnQgc3ludGF4J3MgaG93IHlvdSBjYW4gdXNlIHRoaXMgbWV0aG9kLlxuICAgICAqIFVzaW5nIHRoZSBldmVudElkOlxuICAgICAqIGBgYFxuICAgICAqIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2NoYW5nZScsICduZW8tZXZlbnQtNycpO1xuICAgICAqIGBgYFxuICAgICAqIFBhc3NpbmcgdGhlIGhhbmRsZXIgbWV0aG9kOlxuICAgICAqIGBgYFxuICAgICAqIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMub25DaGFuZ2UsIHRoaXMpO1xuICAgICAqIGBgYFxuICAgICAqIFBhc3NpbmcgYW4gb2JqZWN0OlxuICAgICAqIGBgYFxuICAgICAqIG1lLmZpZWxkLnVuKHtcbiAgICAgKiAgICAgY2hhbmdlICAgICAgICAgICAgICAgICAgICA6IG1lLm9uRmllbGRDaGFuZ2UsXG4gICAgICogICAgIGNoYW5nZUNsZWFyVG9PcmlnaW5hbFZhbHVlOiBtZS5vbkZpZWxkQ2hhbmdlLFxuICAgICAqICAgICBzY29wZSAgICAgICAgICAgICAgICAgICAgIDogbWVcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gW2V2ZW50SWRdXG4gICAgICogQHBhcmFtIHtOZW8uY29yZS5CYXNlfSBbc2NvcGVdXG4gICAgICovXG4gICAgcmVtb3ZlTGlzdGVuZXIobmFtZSwgZXZlbnRJZCwgc2NvcGUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIGksIGxlbiwgbGlzdGVuZXIsIGxpc3RlbmVycywgbWF0Y2g7XG5cbiAgICAgICAgLy8gTEFaWSBJTklUSUFMSVpBVElPTjogRW5zdXJlIHRoZSBpbnRlcm5hbCBsaXN0ZW5lciBzdG9yZSBleGlzdHMuXG4gICAgICAgIG1lW2V2ZW50TWFwU3ltYm9sXSA/Pz0ge307XG5cbiAgICAgICAgaWYgKE5lby5pc0Z1bmN0aW9uKGV2ZW50SWQpKSB7XG4gICAgICAgICAgICBtZS5yZW1vdmVMaXN0ZW5lcih7W25hbWVdOiBldmVudElkLCBzY29wZX0pO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KG5hbWUpKSB7XG4gICAgICAgICAgICBpZiAobmFtZS5zY29wZSkge1xuICAgICAgICAgICAgICAgIHNjb3BlID0gbmFtZS5zY29wZTtcbiAgICAgICAgICAgICAgICBkZWxldGUgbmFtZS5zY29wZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMobmFtZSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzID0gbWVbZXZlbnRNYXBTeW1ib2xdW2tleV0gfHwgW107XG4gICAgICAgICAgICAgICAgaSAgICAgICAgID0gMDtcbiAgICAgICAgICAgICAgICBsZW4gICAgICAgPSBsaXN0ZW5lcnMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lci5mbi5uYW1lID09PSAoTmVvLmlzU3RyaW5nKHZhbHVlKSA/IHZhbHVlIDogdmFsdWUubmFtZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLnNjb3BlICAgPT09IHNjb3BlXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2UgaWYgKE5lby5pc1N0cmluZyhldmVudElkKSkge1xuICAgICAgICAgICAgbGlzdGVuZXJzID0gbWVbZXZlbnRNYXBTeW1ib2xdW25hbWVdO1xuICAgICAgICAgICAgbWF0Y2ggICAgID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGxpc3RlbmVycy5mb3JFYWNoKChldmVudENvbmZpZywgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50Q29uZmlnLmlkID09PSBldmVudElkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaCA9IGlkeFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAobWF0Y2ggIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShtYXRjaCwgMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciByZW1vdmVMaXN0ZW5lclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZXZlbnRJZF1cbiAgICAgKi9cbiAgICB1biguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoLi4uYXJncyk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhPYnNlcnZhYmxlKTtcbiIsIi8qKlxuICogQGNsYXNzIE5lby5jb3JlLlV0aWxcbiAqL1xuY2xhc3MgVXRpbCB7XG4gICAgLyoqXG4gICAgICogQSByZWdleCB0byByZW1vdmUgY2FtZWwgY2FzZSBzeW50YXhcbiAgICAgKiBAbWVtYmVyIHtSZWdFeHB9IGRlY2FtZWxSZWdFeD0vKFthLXpdKShbQS1aXSkvZ1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGRlY2FtZWxSZWdFeCA9IC8oW2Etel0pKFtBLVpdKS9nXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2NvcGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSB2YWx1ZXNcbiAgICAgKi9cbiAgICBzdGF0aWMgYmluZE1ldGhvZHMoc2NvcGUsIHZhbHVlcykge1xuICAgICAgICB2YWx1ZXMuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICAgICAgICBzY29wZVt2YWx1ZV0gPSBzY29wZVt2YWx1ZV0uYmluZChzY29wZSlcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGEgc3R5bGVzIHN0cmluZyBpbnRvIGEgc3R5bGVzIG9iamVjdCB1c2luZyBjYW1lbGNhc2Ugc3ludGF4XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgc3R5bGVzIHN0cmluZyB0byBwYXJzZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBjYW1lbGNhc2Ugc3R5bGVzIG9iamVjdFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVTdHlsZU9iamVjdChzdHJpbmcpIHtcbiAgICAgICAgbGV0IHBhcnRzO1xuXG4gICAgICAgIC8vIHNwbGl0KCc7JykgZG9lcyBmZXRjaCBzZW1pY29sb25zIGluc2lkZSBicmFja2V0c1xuICAgICAgICAvLyAtPiBiYWNrZ3JvdW5kLWltYWdlOiBcInVybCgnZGF0YTppbWFnZS9wbmc7YmFzZTY0LC4uLlxuXG4gICAgICAgIC8vIFRPRE86IENhY2hlIGFsbCByZWdleFxuICAgICAgICByZXR1cm4gc3RyaW5nLnNwbGl0KC87KD89W15cXCldKig/OlxcKHwkKSkvZykucmVkdWNlKChvYmosIGVsKSA9PiB7XG4gICAgICAgICAgICAvLyB3ZSBoYXZlIHRvIHNwbGl0IGJ5IHRoZSBmaXJzdCBjb2xvbiBvbmx5XG4gICAgICAgICAgICAvLyAtPiBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2h0dHA6Ly9leGFtcGxlLmNvbS9pbWFnZS5wbmcnKVxuICAgICAgICAgICAgcGFydHMgPSBlbC5zcGxpdCgoLzooLispLykpLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIGxldCBudW0gPSBwYXJzZUZsb2F0KHgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHggPT0gbnVtID8gbnVtIDogeC50cmltKClcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAocGFydHNbMF0gIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgcGFydHNbMF0gPSBwYXJ0c1swXS5yZXBsYWNlKC8tKFthLXpdKS9nLCAoc3RyLCBsZXR0ZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBvYmpbcGFydHNbMF1dID0gcGFydHNbMV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmpcbiAgICAgICAgfSwge30pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBzdHlsZXMgb2JqZWN0IHdoaWNoIGNhbiB1c2UgY2FtZWxjYXNlIHN5bnRheCBpbnRvIGEgc3R5bGVzIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZXMgVGhlIHN0eWxlcyBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgc3R5bGVzIHN0cmluZyAoRE9NIHJlYWR5KVxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVTdHlsZXMoc3R5bGVzKSB7XG4gICAgICAgIGxldCBzdHlsZSA9ICcnO1xuXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHN0eWxlcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN0eWxlICs9IFV0aWwuZGVjYW1lbChrZXkpICsgJzonICsgdmFsdWUgKyAnOydcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHN0eWxlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBhbGwgdXBwZXJjYXNlIGNoYXJhY3RlcnMgb2YgYSBzdHJpbmcgaW50byAtbG93ZXJjYXNlLlxuICAgICAqIERvZXMgbm90IHRvdWNoIHNwZWNpYWwgY2hhcmFjdGVycy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIGlucHV0IGNvbnRhaW5pbmcgdXBwZXJjYXNlIGNoYXJhY3RlcnNcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbG93ZXJjYXNlIG91dHB1dFxuICAgICAqL1xuICAgIHN0YXRpYyBkZWNhbWVsKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKFV0aWwuZGVjYW1lbFJlZ0V4LCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYW4gYXJyYXlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgVGhlIHZhbHVlIHRvIHRlc3RcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNBcnJheSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhIGJvb2xlYW5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgVGhlIHZhbHVlIHRvIHRlc3RcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIG5vdCB1bmRlZmluZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgVGhlIHZhbHVlIHRvIHRlc3RcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNEZWZpbmVkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYW4gZW1wdHkgQXJyYXksIE9iamVjdCBvciBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxTdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGlzRW1wdHkodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPT09IDBcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFV0aWwuaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCA9PT0gMFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFV0aWwuaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09ICcnXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdmFsdWUgVGhlIHZhbHVlIHRvIHRlc3RcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYSBudW1iZXIuIFJldHVybnMgZmFsc2UgZm9yIG5vbi1maW5pdGUgbnVtYmVyc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpc051bWJlcih2YWx1ZSl7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGFuIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpc09iamVjdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU/LmNvbnN0cnVjdG9yPy5uYW1lID09PSAnT2JqZWN0J1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGEgcHJvbWlzZS5cbiAgICAgKiBXZSBhcmUgaW50ZW50aW9uYWxseSBub3QgY2hlY2tpbmcgZm9yIGB2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2VgLFxuICAgICAqIHRvIHN1cHBvcnQgYW55IFwidGhlbmFibGVcIiBvYmplY3RzIGZvciBmbGV4aWJpbGl0eS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgVGhlIHZhbHVlIHRvIHRlc3RcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNQcm9taXNlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWU/LnRoZW4gPT09ICdmdW5jdGlvbidcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhIG5lbyBkYXRhIHJlY29yZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpc1JlY29yZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU/LmNvbnN0cnVjdG9yPy5uYW1lID09PSAnUmVjb3JkJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGEgc3RyaW5nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYW55IGl0ZXJhYmxlIChzdHJpbmdzLCBudW1lcmljIGluZGljZXMgYW5kIGEgbGVuZ3RoIHByb3BlcnR5KSBpbnRvIGEgdHJ1ZSBhcnJheVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gaXRlcmFibGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0PTBdIHN0YXJ0IGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtlbmQ9aXRlcmFibGUubGVuZ3RoXSBlbmQgaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgc3RhdGljIHRvQXJyYXkoaXRlcmFibGUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgbGV0IGxlbjtcblxuICAgICAgICBpZiAoIWl0ZXJhYmxlIHx8ICEobGVuID0gaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhYmxlLnNwbGl0KCcnKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGl0ZXJhYmxlLCBzdGFydCB8fCAwLCBlbmQgfHwgbGVuKVxuICAgIH1cbn1cblxuY29uc3QgbnMgPSBOZW8ubnMoJ05lby5jb3JlJywgdHJ1ZSk7XG5ucy5VdGlsID0gVXRpbDtcblxuLy8gYWxpYXNlc1xuTmVvLmFwcGx5RnJvbU5zKE5lbywgVXRpbCwge1xuICAgIGJpbmRNZXRob2RzICAgICAgOiAnYmluZE1ldGhvZHMnLFxuICAgIGNyZWF0ZVN0eWxlT2JqZWN0OiAnY3JlYXRlU3R5bGVPYmplY3QnLFxuICAgIGNyZWF0ZVN0eWxlcyAgICAgOiAnY3JlYXRlU3R5bGVzJyxcbiAgICBkZWNhbWVsICAgICAgICAgIDogJ2RlY2FtZWwnLFxuICAgIGlzQXJyYXkgICAgICAgICAgOiAnaXNBcnJheScsXG4gICAgaXNCb29sZWFuICAgICAgICA6ICdpc0Jvb2xlYW4nLFxuICAgIGlzRGVmaW5lZCAgICAgICAgOiAnaXNEZWZpbmVkJyxcbiAgICBpc0VtcHR5ICAgICAgICAgIDogJ2lzRW1wdHknLFxuICAgIGlzRnVuY3Rpb24gICAgICAgOiAnaXNGdW5jdGlvbicsXG4gICAgaXNOdW1iZXIgICAgICAgICA6ICdpc051bWJlcicsXG4gICAgaXNPYmplY3QgICAgICAgICA6ICdpc09iamVjdCcsXG4gICAgaXNQcm9taXNlICAgICAgICA6ICdpc1Byb21pc2UnLFxuICAgIGlzUmVjb3JkICAgICAgICAgOiAnaXNSZWNvcmQnLFxuICAgIGlzU3RyaW5nICAgICAgICAgOiAnaXNTdHJpbmcnLFxuICAgIHRvQXJyYXkgICAgICAgICAgOiAndG9BcnJheSdcbn0sIHRydWUpO1xuXG5leHBvcnQgZGVmYXVsdCBVdGlsO1xuIiwiaW1wb3J0IEJhc2UgICAgICAgIGZyb20gJy4vQmFzZS5tanMnO1xuaW1wb3J0IENvbXBhcmUgICAgIGZyb20gJy4vQ29tcGFyZS5tanMnO1xuaW1wb3J0IElkR2VuZXJhdG9yIGZyb20gJy4vSWRHZW5lcmF0b3IubWpzJztcbmltcG9ydCBPYnNlcnZhYmxlICBmcm9tICcuL09ic2VydmFibGUubWpzJztcbmltcG9ydCBVdGlsICAgICAgICBmcm9tICcuL1V0aWwubWpzJztcblxuZXhwb3J0IHtCYXNlLCBDb21wYXJlLCBJZEdlbmVyYXRvciwgT2JzZXJ2YWJsZSwgVXRpbH07XG4iLCJpbXBvcnQgQ29sbGVjdGlvbiBmcm9tICcuLi9jb2xsZWN0aW9uL0Jhc2UubWpzJztcblxuLyoqXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciB0aGUgb3RoZXIgbWFuYWdlciBjbGFzc2VzXG4gKiBAY2xhc3MgTmVvLm1hbmFnZXIuQmFzZVxuICogQGV4dGVuZHMgTmVvLmNvbGxlY3Rpb24uQmFzZVxuICovXG5jbGFzcyBNYW5hZ2VyIGV4dGVuZHMgQ29sbGVjdGlvbntcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5tYW5hZ2VyLkJhc2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5tYW5hZ2VyLkJhc2UnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBpZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0QnlJZChpZCkge1xuICAgICAgICByZXR1cm4gaWQgJiYgdGhpcy5nZXQoaWQpIHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuICAgICAqL1xuICAgIHJlZ2lzdGVyKGl0ZW0pIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuZ2V0KGl0ZW0uaWQpKSB7XG4gICAgICAgICAgICBOZW8ubG9nRXJyb3IoJ1RyeWluZyB0byBjcmVhdGUgYW4gaXRlbSB3aXRoIGFuIGFscmVhZHkgZXhpc3RpbmcgaWQnLCBpdGVtLCBtZS5nZXQoaXRlbS5pZCkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5wdXNoKGl0ZW0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgY29sbGVjdGlvbiBpdGVtIHBhc3NlZCBieSByZWZlcmVuY2Ugb3Iga2V5XG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBpdGVtXG4gICAgICovXG4gICAgdW5yZWdpc3RlcihpdGVtKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKGl0ZW0pXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhNYW5hZ2VyKTtcbiIsImltcG9ydCBCYXNlTWFuYWdlciBmcm9tICcuL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLm1hbmFnZXIuQ2xhc3NIaWVyYXJjaHlcbiAqIEBleHRlbmRzIE5lby5tYW5hZ2VyLkJhc2VcbiAqIEBzaW5nbGV0b25cbiAqXG4gKiBUaGlzIG1hbmFnZXIgbWFpbnRhaW5zIGEgcmVnaXN0cnkgb2YgYWxsIGNsYXNzZXMgZGVmaW5lZCB3aXRoaW4gdGhlIE5lby5tanMgZnJhbWV3b3JrJ3MgY3VycmVudCByZWFsbSAobWFpbiBvciB3b3JrZXIpLFxuICogaW5jbHVkaW5nIHRoZWlyIGluaGVyaXRhbmNlIHJlbGF0aW9uc2hpcHMgYW5kIGtleSBtZXRhZGF0YS5cbiAqIEVhY2ggcmVnaXN0ZXJlZCBpdGVtICh2YWx1ZSBpbiB0aGUgbWFuYWdlcidzIHN0b3JlKSBoYXMgdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmU6XG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDbGFzc0hpZXJhcmNoeUluZm9cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBjbGFzc05hbWUgLSBUaGUgZnVsbCBOZW8ubWpzIGNsYXNzIG5hbWUgKGUuZy4sICdOZW8uY29tcG9uZW50LkJhc2UnKS5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb258T2JqZWN0fSBtb2R1bGUgLSBUaGUgZGlyZWN0IHJlZmVyZW5jZSB0byB0aGUgY2xhc3MgY29uc3RydWN0b3IgZnVuY3Rpb24gaXRzZWxmIChmb3Igbm9uLXNpbmdsZXRvbnMpXG4gKiBvciB0aGUgaW5zdGFudGlhdGVkIHNpbmdsZXRvbiBvYmplY3QgKGZvciBzaW5nbGV0b25zKS5cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfG51bGx9IG50eXBlIC0gVGhlIG50eXBlIG9mIHRoZSBjbGFzcyBpZiBkZWZpbmVkIChlLmcuLCAnYnV0dG9uJywgJ2NvbnRhaW5lcicpLCBvdGhlcndpc2UgYG51bGxgLlxuICogQHByb3BlcnR5IHtTdHJpbmd8bnVsbH0gcGFyZW50Q2xhc3NOYW1lIC0gVGhlIGZ1bGwgY2xhc3MgbmFtZSBvZiBpdHMgZGlyZWN0IHBhcmVudCBjbGFzcyxcbiAqIG9yIGBudWxsYCBpZiBpdCdzIGEgdG9wLWxldmVsIGNsYXNzIChlLmcuLCAnTmVvLmNvcmUuQmFzZScpLlxuICovXG5jbGFzcyBDbGFzc0hpZXJhcmNoeSBleHRlbmRzIEJhc2VNYW5hZ2VyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5tYW5hZ2VyLkNsYXNzSGllcmFyY2h5J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ubWFuYWdlci5DbGFzc0hpZXJhcmNoeScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGtleVByb3BlcnR5PSdjbGFzc05hbWUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGtleVByb3BlcnR5OiAnY2xhc3NOYW1lJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZXRvbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZXRvbjogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1lbW9pemVzIHRoZSByZXR1cm4gdmFsdWVzIG9mIGlzQSgpIGNhbGxzXG4gICAgICogQG1lbWJlciB7TWFwfSBpc0FRdWVyeU1hcD1uZXcgTWFwKClcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaXNBUXVlcnlNYXAgPSBuZXcgTWFwKClcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuICAgICAgICB0aGlzLmNvbnN1bWVUZW1wTWFwKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhbGwgY2xhc3NlcyB0aGF0IGdvdCBhcHBsaWVkIHRvIHRoZSBOZW8gbmFtZXNwYWNlIGJlZm9yZSB0aGlzIGluc3RhbmNlIGdvdCBjcmVhdGVkXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNvbnN1bWVUZW1wTWFwKCkge1xuICAgICAgICBpZiAoTmVvLmNsYXNzSGllcmFyY2h5TWFwKSB7XG4gICAgICAgICAgICB0aGlzLmFkZChPYmplY3QudmFsdWVzKE5lby5jbGFzc0hpZXJhcmNoeU1hcCkpO1xuICAgICAgICAgICAgZGVsZXRlIE5lby5jbGFzc0hpZXJhcmNoeU1hcFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQm90aCBwYXJhbXMgcmVwcmVzZW50IGNsYXNzTmFtZXMuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlIHVzZSBjYXNlczpcbiAgICAgKiAtIGlzQSgnTmVvLmJ1dHRvbi5NZW51JywgICAgJ05lby5idXR0b24uQmFzZScpICAgID0+IHRydWVcbiAgICAgKiAtIGlzQSgnTmVvLmJ1dHRvbi5CYXNlJywgICAgJ05lby5idXR0b24uTWVudScpICAgID0+IGZhbHNlXG4gICAgICogLSBpc0EoJ05lby5idXR0b24uQmFzZScsICAgICdOZW8uY29tcG9uZW50LkJhc2UnKSA9PiB0cnVlXG4gICAgICogLSBpc0EoJ05lby5jb21wb25lbnQuQmFzZScsICdOZW8uY29yZS5CYXNlJykgICAgICA9PiB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRlc2NlbmRhbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYW5jZXN0b3JcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0EoZGVzY2VuZGFudCwgYW5jZXN0b3IpIHtcbiAgICAgICAgaWYgKGRlc2NlbmRhbnQgPT09IGFuY2VzdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHBhcmVudCAgICAgICAgPSBkZXNjZW5kYW50LFxuICAgICAgICAgICAge2lzQVF1ZXJ5TWFwfSA9IHRoaXMsXG4gICAgICAgICAgICBxdWVyeU5hbWUgICAgID0gYCR7ZGVzY2VuZGFudH0sJHthbmNlc3Rvcn1gLFxuICAgICAgICAgICAgcmV0dXJuVmFsdWUgICA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChpc0FRdWVyeU1hcC5oYXMocXVlcnlOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQVF1ZXJ5TWFwLmdldChxdWVyeU5hbWUpXG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAocGFyZW50ID0gdGhpcy5nZXQocGFyZW50KT8ucGFyZW50Q2xhc3NOYW1lKSB7XG4gICAgICAgICAgICBpZiAocGFyZW50ID09PSBhbmNlc3Rvcikge1xuICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBc3N1bXB0aW9uOiBjb21wb25lbnQuQmFzZSBkaXJlY3RseSBleHRlbmRzIGNvcmUuQmFzZVxuICAgICAgICAgICAgaWYgKHBhcmVudCA9PT0gJ05lby5jb21wb25lbnQuQmFzZScgJiYgYW5jZXN0b3IgIT09ICdOZW8uY29yZS5CYXNlJykge1xuICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBhcmVudCA9PT0gJ05lby5jb3JlLkJhc2UnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaXNBUXVlcnlNYXAuc2V0KHF1ZXJ5TmFtZSwgcmV0dXJuVmFsdWUpO1xuXG4gICAgICAgIHJldHVybiByZXR1cm5WYWx1ZVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ2xhc3NIaWVyYXJjaHkpO1xuIiwiaW1wb3J0IE1hbmFnZXIgICBmcm9tICcuL0Jhc2UubWpzJztcbmltcG9ydCBWRG9tVXRpbCAgZnJvbSAnLi4vdXRpbC9WRG9tLm1qcyc7XG5pbXBvcnQgVk5vZGVVdGlsIGZyb20gJy4uL3V0aWwvVk5vZGUubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLm1hbmFnZXIuQ29tcG9uZW50XG4gKiBAZXh0ZW5kcyBOZW8ubWFuYWdlci5CYXNlXG4gKiBAc2luZ2xldG9uXG4gKi9cbmNsYXNzIENvbXBvbmVudCBleHRlbmRzIE1hbmFnZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLm1hbmFnZXIuQ29tcG9uZW50J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ubWFuYWdlci5Db21wb25lbnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2luZ2xldG9uPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2luZ2xldG9uOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7TWFwfSB3cmFwcGVyTm9kZXM9bmV3IE1hcCgpXG4gICAgICovXG4gICAgd3JhcHBlck5vZGVzID0gbmV3IE1hcCgpXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIE5lby5maXJzdCAgICAgICAgPSBtZS5nZXRGaXJzdC5iaW5kKG1lKTsgLy8gYWxpYXNcbiAgICAgICAgTmVvLmdldENvbXBvbmVudCA9IG1lLmdldCAgICAgLmJpbmQobWUpICAvLyBhbGlhc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZsYXR0ZW5zIGEgZ2l2ZW4gdm5vZGUgdHJlZSBieSByZXBsYWNpbmcgY29tcG9uZW50IGJhc2VkIHN1YnRyZWVzIHdpdGggY29tcG9uZW50SWQgYmFzZWQgcmVmZXJlbmNlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2bm9kZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvd25lcklkIFdlIGRvIG5vdCB3YW50IHRvIHJlcGxhY2UgdGhlIG93biBpZCA9PiB3cmFwcGVkIGl0ZW1zXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBhZGRWbm9kZUNvbXBvbmVudFJlZmVyZW5jZXModm5vZGUsIG93bmVySWQpIHtcbiAgICAgICAgdm5vZGUgPSB7Li4udm5vZGV9OyAvLyBzaGFsbG93IGNvcHlcblxuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjaGlsZE5vZGVzID0gdm5vZGU/LmNoaWxkTm9kZXMgPyBbLi4udm5vZGUuY2hpbGROb2Rlc10gOiBbXSxcbiAgICAgICAgICAgIGNoaWxkTm9kZUlkLCBjb21wb25lbnQsIGNvbXBvbmVudElkLCBwYXJlbnRSZWYsIHJlZmVyZW5jZU5vZGU7XG5cbiAgICAgICAgdm5vZGUuY2hpbGROb2RlcyA9IGNoaWxkTm9kZXM7XG5cbiAgICAgICAgY2hpbGROb2Rlcy5mb3JFYWNoKChjaGlsZE5vZGUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjaGlsZE5vZGVJZCA9IGNoaWxkTm9kZS5pZDtcblxuICAgICAgICAgICAgaWYgKCFjaGlsZE5vZGUuY29tcG9uZW50SWQgJiYgY2hpbGROb2RlSWQgIT09IG93bmVySWQpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQgPSBtZS5nZXQoY2hpbGROb2RlSWQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VhcmNoaW5nIGZvciB3cmFwcGVkIGNvbXBvbmVudHMgYXMgYSBmYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQgPSBtZS53cmFwcGVyTm9kZXMuZ2V0KGNoaWxkTm9kZUlkKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHBhcmVudCBjb21wb25lbnQgcmVmZXJlbmNlID0+IGFzc2lnbiB0aGUgd3JhcHBlciBpZFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50SWQgPSBjb21wb25lbnQuaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRSZWYgICA9IFZEb21VdGlsLmZpbmQoY29tcG9uZW50LnBhcmVudC52ZG9tLCB7Y29tcG9uZW50SWR9LCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRSZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRSZWYudmRvbS5pZCA9IGNoaWxkTm9kZUlkXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudElkICAgPSBjb21wb25lbnQuaWQ7XG4gICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZU5vZGUgPSB7Y29tcG9uZW50SWR9O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnRJZCAhPT0gY2hpbGROb2RlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZU5vZGUuaWQgPSBjaGlsZE5vZGVJZFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGlsZE5vZGVzW2luZGV4XSA9IGNvbXBvbmVudCA/IHJlZmVyZW5jZU5vZGUgOiBtZS5hZGRWbm9kZUNvbXBvbmVudFJlZmVyZW5jZXMoY2hpbGROb2RlLCBvd25lcklkKVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdm5vZGVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBjb21wb25lbnQgd2hpY2ggbWF0Y2hlcyB0aGUgY29uZmlnLXNlbGVjdG9yIG1vdmluZyBkb3duIHRoZSBjb21wb25lbnQgaXRlbXMgdHJlZS5cbiAgICAgKiBVc2UgcmV0dXJuRmlyc3RNYXRjaD1mYWxzZSB0byBnZXQgYW4gYXJyYXkgb2YgYWxsIG1hdGNoaW5nIGl0ZW1zIGluc3RlYWQuXG4gICAgICogSWYgbm8gbWF0Y2ggaXMgZm91bmQsIHJldHVybnMgbnVsbCBpbiBjYXNlIHJldHVybkZpcnN0TWF0Y2ggPT09IHRydWUsIG90aGVyd2lzZSBhbiBlbXB0eSBBcnJheS5cbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZXxTdHJpbmd9IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xudWxsfSBjb25maWdcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJldHVybkZpcnN0TWF0Y2g9dHJ1ZVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29tcG9uZW50LkJhc2V8TmVvLmNvbXBvbmVudC5CYXNlW118bnVsbH1cbiAgICAgKi9cbiAgICBkb3duKGNvbXBvbmVudCwgY29uZmlnLCByZXR1cm5GaXJzdE1hdGNoPXRydWUpIHtcbiAgICAgICAgaWYgKE5lby5pc1N0cmluZyhjb21wb25lbnQpKSB7XG4gICAgICAgICAgICBjb21wb25lbnQgPSB0aGlzLmdldEJ5SWQoY29tcG9uZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtZSAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBtYXRjaEFycmF5ICA9IFtdLFxuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBudWxsLFxuICAgICAgICAgICAgaSAgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgcmV0dXJuQXJyYXkgPSBbXSxcbiAgICAgICAgICAgIGNoaWxkSXRlbXMsIGNvbmZpZ0FycmF5LCBjb25maWdMZW5ndGgsIGxlbjtcblxuICAgICAgICBpZiAoTmVvLmlzU3RyaW5nKGNvbmZpZykpIHtcbiAgICAgICAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICBudHlwZTogY29uZmlnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWNvbmZpZykge1xuICAgICAgICAgICAgY29uZmlnID0ge31cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZ0FycmF5ICA9IE9iamVjdC5lbnRyaWVzKGNvbmZpZyk7XG4gICAgICAgIGNvbmZpZ0xlbmd0aCA9IGNvbmZpZ0FycmF5Lmxlbmd0aDtcblxuICAgICAgICBjb25maWdBcnJheS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmICgoY29tcG9uZW50W2tleV0gPT09IHZhbHVlKVxuICAgICAgICAgICAgICAgIHx8IChrZXkgPT09ICdudHlwZScgJiYgbWUuaGFzUHJvdG90eXBlUHJvcGVydHlWYWx1ZShjb21wb25lbnQsIGtleSwgdmFsdWUpKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtYXRjaEFycmF5LnB1c2godHJ1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG1hdGNoQXJyYXkubGVuZ3RoID09PSBjb25maWdMZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChyZXR1cm5GaXJzdE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm5BcnJheS5wdXNoKGNvbXBvbmVudClcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkSXRlbXMgPSBtZS5maW5kKHtwYXJlbnRJZDogY29tcG9uZW50LmlkfSk7XG4gICAgICAgIGxlbiAgICAgICAgPSBjaGlsZEl0ZW1zLmxlbmd0aDtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IG1lLmRvd24oY2hpbGRJdGVtc1tpXSwgY29uZmlnLCByZXR1cm5GaXJzdE1hdGNoKTtcblxuICAgICAgICAgICAgaWYgKHJldHVybkZpcnN0TWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBpZiAocmV0dXJuVmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXR1cm5WYWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuQXJyYXkucHVzaCguLi5yZXR1cm5WYWx1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXR1cm5GaXJzdE1hdGNoID8gbnVsbDogcmV0dXJuQXJyYXlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBwYXRoXG4gICAgICogQHJldHVybnMge1N0cmluZ3xudWxsfSB0aGUgY29tcG9uZW50IGlkIGluIGNhc2UgdGhlcmUgaXMgYSBtYXRjaFxuICAgICAqL1xuICAgIGZpbmRQYXJlbnRDb21wb25lbnQocGF0aCkge1xuICAgICAgICBsZXQgbWUgID0gdGhpcyxcbiAgICAgICAgICAgIGkgICA9IDAsXG4gICAgICAgICAgICBsZW4gPSBwYXRoPy5sZW5ndGggfHwgMCxcbiAgICAgICAgICAgIGlkO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlkID0gcGF0aFtpXTtcblxuICAgICAgICAgICAgaWYgKGlkICYmIG1lLmhhcyhpZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgb2JqZWN0IGFzc29jaWF0ZWQgdG8gdGhlIGtleSwgb3IgbnVsbCBpZiB0aGVyZSBpcyBub25lLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICBbaW5jbHVkZVdyYXBwZXJOb2Rlcz10cnVlXVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH1cbiAgICAgKi9cbiAgICBnZXQoa2V5LCBpbmNsdWRlV3JhcHBlck5vZGVzPXRydWUpIHtcbiAgICAgICAgaWYgKGluY2x1ZGVXcmFwcGVyTm9kZXMpIHtcbiAgICAgICAgICAgIGxldCB3cmFwcGVyTm9kZSA9IHRoaXMud3JhcHBlck5vZGVzLmdldChrZXkpO1xuXG4gICAgICAgICAgICBpZiAod3JhcHBlck5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlck5vZGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdXBlci5nZXQoa2V5KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIGNoaWxkIGNvbXBvbmVudHMgd2hpY2ggYXJlIHJlY3Vyc2l2ZWx5IG1hdGNoZWQgdmlhIHRoZWlyIHBhcmVudElkXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudFxuICAgICAqIEByZXR1cm5zIHtOZW8uY29tcG9uZW50LkJhc2VbXX0gY2hpbGRDb21wb25lbnRzXG4gICAgICovXG4gICAgZ2V0Q2hpbGRDb21wb25lbnRzKGNvbXBvbmVudCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZGlyZWN0Q2hpbGRyZW4gPSBtZS5maW5kKCdwYXJlbnRJZCcsIGNvbXBvbmVudC5pZCkgfHwgW10sXG4gICAgICAgICAgICBjb21wb25lbnRzICAgICA9IFtdLFxuICAgICAgICAgICAgY2hpbGRDb21wb25lbnRzO1xuXG4gICAgICAgIGRpcmVjdENoaWxkcmVuLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnB1c2goaXRlbSk7XG5cbiAgICAgICAgICAgIGNoaWxkQ29tcG9uZW50cyA9IG1lLmdldENoaWxkQ29tcG9uZW50cyhpdGVtKTtcblxuICAgICAgICAgICAgY2hpbGRDb21wb25lbnRzICYmIGNvbXBvbmVudHMucHVzaCguLi5jaGlsZENvbXBvbmVudHMpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjb21wb25lbnRzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdG9kbzogcmVwbGFjZSBhbGwgY2FsbHMgb2YgdGhpcyBtZXRob2QgdG8gY2FsbHMgdXNpbmcgdGhlIHV0aWwuVk5vZGUgY2xhc3NcbiAgICAgKiBHZXQgdGhlIGlkcyBvZiBhbGwgY2hpbGQgbm9kZXMgb2YgdGhlIGdpdmVuIHZub2RlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZub2RlXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gY2hpbGRJZHM9W11cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nW119IGNoaWxkSWRzXG4gICAgICovXG4gICAgZ2V0Q2hpbGRJZHModm5vZGUsIGNoaWxkSWRzPVtdKSB7XG4gICAgICAgIHJldHVybiBWTm9kZVV0aWwuZ2V0Q2hpbGRJZHModm5vZGUsIGNoaWxkSWRzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIGNoaWxkIGNvbXBvbmVudHMgZm91bmQgaW5zaWRlIHRoZSB2bm9kZSB0cmVlXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudFxuICAgICAqIEByZXR1cm5zIHtOZW8uY29tcG9uZW50LkJhc2VbXX0gY2hpbGRDb21wb25lbnRzXG4gICAgICovXG4gICAgZ2V0Q2hpbGRyZW4oY29tcG9uZW50KSB7XG4gICAgICAgIGxldCBjaGlsZENvbXBvbmVudHMgPSBbXSxcbiAgICAgICAgICAgIGNoaWxkTm9kZXMgICAgICA9IFZOb2RlVXRpbC5nZXRDaGlsZElkcyhjb21wb25lbnQudm5vZGUpLFxuICAgICAgICAgICAgY2hpbGRDb21wb25lbnQ7XG5cbiAgICAgICAgY2hpbGROb2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgY2hpbGRDb21wb25lbnQgPSB0aGlzLmdldChub2RlKTtcblxuICAgICAgICAgICAgaWYgKGNoaWxkQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgY2hpbGRDb21wb25lbnRzLnB1c2goY2hpbGRDb21wb25lbnQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjaGlsZENvbXBvbmVudHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAhISBGb3IgZGVidWdnaW5nIHB1cnBvc2VzIG9ubHkgISFcbiAgICAgKlxuICAgICAqIEdldCB0aGUgZmlyc3QgY29tcG9uZW50IGJhc2VkIG9uIHRoZSBudHlwZSBvciBvdGhlciBwcm9wZXJ0aWVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8QXJyYXl9IGNvbXBvbmVudERlc2NyaXB0aW9uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSByZXR1cm5GaXJzdE1hdGNoPXRydWVcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx8TmVvLmNvbXBvbmVudC5CYXNlW119XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAvLyBhcyBTdHJpbmc6IG50eXBlW2NvbW1hIHNlcGFyYXRlZCBwcm9wdGVydGllc11cbiAgICAgTmVvLmZpcnN0KCd0b29sYmFyIGJ1dHRvblt0ZXh0PVRyeSBtZSxpY29uPXBlb3BsZV0nKVxuICAgICAvLyBhcyBPYmplY3Q6IEFkZCBwcm9wZXJ0aWVzLiBudHlwZSBpcyBvcHRpb25hbFxuICAgICBOZW8uZmlyc3Qoe1xuICAgICAgICAgICAgICAgIGljb246ICdwZW9wbGUnXG4gICAgICAgICAgICB9KVxuICAgICAvLyBhcyBBcnJheTogQW4gQXJyYXkgb2YgT2JqZWN0cy4gTm8gU3RyaW5ncyBhbGxvd2VkXG4gICAgIE5lby5maXJzdChbe1xuICAgICAgICAgICAgICAgIG50eXBlOiAndG9vbGJhcidcbiAgICAgICAgICAgIH0se1xuICAgICAgICAgICAgICAgIG50eXBlOiAnYnV0dG9uJywgdGV4dDogJ1RyeSBtZScsIGljb246ICdwZW9wbGVcbiAgICAgICAgICAgIH1dKVxuXG4gICAgICogVGhlIHJldHVybkZpcnN0TWF0Y2ggZmxhZyBhbGxvd3MgdG8gcmV0dXJuIGFsbCBpdGVtcyBhbmRcbiAgICAgKiBub3Qgc3RvcCBhZnRlciB0aGUgZmlyc3QgcmVzdWx0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgTmVvLmZpcnN0KCdidXR0b24nLCBmYWxzZSkgLy8gPT4gW0J1dHRvbiwgQnV0dG9uLCBCdXR0b25dXG4gICAgICovXG4gICAgZ2V0Rmlyc3QoY29tcG9uZW50RGVzY3JpcHRpb24sIHJldHVybkZpcnN0TWF0Y2ggPSB0cnVlKSB7XG4gICAgICAgIGxldCBvYmplY3RzID0gW10sXG4gICAgICAgICAgICBhcHAgICAgID0gTmVvLmFwcHNbT2JqZWN0LmtleXMoTmVvLmFwcHMpWzBdXSxcbiAgICAgICAgICAgIHJvb3QgICAgPSBhcHAubWFpblZpZXc7XG5cbiAgICAgICAgLyogY3JlYXRlIGFuIGFycmF5IG9mIG9iamVjdHMgZnJvbSBzdHJpbmcgKi9cbiAgICAgICAgaWYgKE5lby5pc1N0cmluZyhjb21wb25lbnREZXNjcmlwdGlvbikpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gLyhcXHcqKShcXFtbXlxcXV0qXFxdKXwoXFx3KikvZztcbiAgICAgICAgICAgIGxldCBtYXRjaDtcblxuICAgICAgICAgICAgLyogZ2VuZXJhdGUgb2JqZWN0cyB3aGljaCBjb250YWluIHRoZSBpbmZvcm1hdGlvbiAqL1xuICAgICAgICAgICAgd2hpbGUgKG1hdGNoID0gcmVnZXguZXhlYyhjb21wb25lbnREZXNjcmlwdGlvbikpIHtcbiAgICAgICAgICAgICAgICBsZXQgWywgbnR5cGUsIHBhaXJzLCBudHlwZU9ubHldID0gbWF0Y2gsIG9iajtcblxuICAgICAgICAgICAgICAgIG50eXBlID0gbnR5cGUgfHwgbnR5cGVPbmx5O1xuICAgICAgICAgICAgICAgIG9iaiA9IHtudHlwZX07XG5cbiAgICAgICAgICAgICAgICBpZiAocGFpcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFpcnNSZWdleCA9IC9cXFsoLio/KVxcXS8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBhaXJzTWF0Y2ggPSBwYWlycy5tYXRjaChwYWlyc1JlZ2V4KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocGFpcnNNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFpcnMgPSBwYWlyc01hdGNoWzFdLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYWlycy5mb3JFYWNoKChwYWlyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gcGFpci5zcGxpdCgnPScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWUucmVwbGFjZSgvXCIvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmplY3RzLnB1c2gob2JqKTtcblxuICAgICAgICAgICAgICAgIHJlZ2V4Lmxhc3RJbmRleCsrXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoTmVvLmlzT2JqZWN0KGNvbXBvbmVudERlc2NyaXB0aW9uKSl7XG4gICAgICAgICAgICBvYmplY3RzLnB1c2goY29tcG9uZW50RGVzY3JpcHRpb24pXG4gICAgICAgIH0gZWxzZSBpZiAoTmVvLmlzQXJyYXkoY29tcG9uZW50RGVzY3JpcHRpb24pKSB7XG4gICAgICAgICAgICBvYmplY3RzID0gY29tcG9uZW50RGVzY3JpcHRpb25cbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGZpbmQgdGhlIGNvcnJlY3QgY2hpbGQgdXNpbmcgZG93bigpICovXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG9iamVjdHMucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKGFjYykge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IGFjYy5kb3duKGtleSwgcmV0dXJuRmlyc3RNYXRjaCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoISFjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH0sIHJvb3QpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIEFycmF5IGNvbnRhaW5pbmcgdGhlIGlkcyBvZiBhbGwgcGFyZW50IGNvbXBvbmVudHMgZm9yIGEgZ2l2ZW4gY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmdbXX0gcGFyZW50SWRzXG4gICAgICovXG4gICAgZ2V0UGFyZW50SWRzKGNvbXBvbmVudCkge1xuICAgICAgICBsZXQgcGFyZW50SWRzID0gW107XG5cbiAgICAgICAgd2hpbGUgKGNvbXBvbmVudD8ucGFyZW50SWQpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudCA9IHRoaXMuZ2V0KGNvbXBvbmVudC5wYXJlbnRJZCk7XG5cbiAgICAgICAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRJZHMucHVzaChjb21wb25lbnQuaWQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyZW50SWRzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBnZXRQYXJlbnRQYXRoKHBhdGgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY29tcG9uZW50UGF0aCA9IFtdLFxuICAgICAgICAgICAgaSAgICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICBsZW4gICAgICAgICAgID0gcGF0aD8ubGVuZ3RoIHx8IDA7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKG1lLmhhcyhwYXRoW2ldKSB8fCBtZS53cmFwcGVyTm9kZXMuZ2V0KHBhdGhbaV0pKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50UGF0aC5wdXNoKHBhdGhbaV0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tcG9uZW50UGF0aFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gQXJyYXkgY29udGFpbmluZyBhbGwgcGFyZW50IGNvbXBvbmVudHMgZm9yIGEgZ2l2ZW4gY29tcG9uZW50IG9yIGNvbXBvbmVudCBpZFxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfFN0cmluZ30gY29tcG9uZW50XG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZVtdfSBwYXJlbnRzXG4gICAgICovXG4gICAgZ2V0UGFyZW50cyhjb21wb25lbnQpIHtcbiAgICAgICAgaWYgKE5lby5pc1N0cmluZyhjb21wb25lbnQpKSB7XG4gICAgICAgICAgICBjb21wb25lbnQgPSB0aGlzLmdldChjb21wb25lbnQpXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcGFyZW50cyA9IFtdO1xuXG4gICAgICAgIHdoaWxlIChjb21wb25lbnQ/LnBhcmVudElkKSB7XG4gICAgICAgICAgICBjb21wb25lbnQgPSB0aGlzLmdldChjb21wb25lbnQucGFyZW50SWQpO1xuXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgcGFyZW50cy5wdXNoKGNvbXBvbmVudClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJlbnRzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGNvbXBvbmVudCBoYWQgYSBwcm9wZXJ0eSBvZiBhbnkgdmFsdWUgc29tZXdoZXJlIGluIHRoZSBQcm90b3R5cGUgY2hhaW5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzUHJvdG90eXBlUHJvcGVydHlWYWx1ZShjb21wb25lbnQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgICAgICB3aGlsZSAoY29tcG9uZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50Lmhhc093blByb3BlcnR5KHByb3BlcnR5KSAmJiBjb21wb25lbnRbcHJvcGVydHldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudC5fX3Byb3RvX19cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB3cmFwcGVySWRcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50XG4gICAgICovXG4gICAgcmVnaXN0ZXJXcmFwcGVyTm9kZSh3cmFwcGVySWQsIGNvbXBvbmVudCkge1xuICAgICAgICB0aGlzLndyYXBwZXJOb2Rlcy5zZXQod3JhcHBlcklkLCBjb21wb25lbnQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V8U3RyaW5nfSBpdGVtXG4gICAgICovXG4gICAgdW5yZWdpc3RlcihpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICBpZiAoTmVvLmlzU3RyaW5nKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cmFwcGVyTm9kZXMuZGVsZXRlKGl0ZW0pXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0uaWQgIT09IGl0ZW0udmRvbS5pZCkge1xuICAgICAgICAgICAgICAgIHRoaXMud3JhcHBlck5vZGVzLmRlbGV0ZShpdGVtLnZkb20uaWQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdXBlci51bnJlZ2lzdGVyKGl0ZW0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgY29tcG9uZW50IHdoaWNoIG1hdGNoZXMgdGhlIGNvbmZpZy1zZWxlY3Rvci5cbiAgICAgKiBVc2UgcmV0dXJuRmlyc3RNYXRjaD1mYWxzZSB0byBnZXQgYW4gYXJyYXkgb2YgYWxsIG1hdGNoaW5nIGl0ZW1zIGluc3RlYWQuXG4gICAgICogSWYgbm8gbWF0Y2ggaXMgZm91bmQsIHJldHVybnMgbnVsbCBpbiBjYXNlIHJldHVybkZpcnN0TWF0Y2ggPT09IHRydWUsIG90aGVyd2lzZSBhbiBlbXB0eSBBcnJheS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9uZW50SWRcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd8bnVsbH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtCb29sZWFufSByZXR1cm5GaXJzdE1hdGNoPXRydWVcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlfE5lby5jb21wb25lbnQuQmFzZVtdfG51bGx9XG4gICAgICovXG4gICAgdXAoY29tcG9uZW50SWQsIGNvbmZpZywgcmV0dXJuRmlyc3RNYXRjaD10cnVlKSB7XG4gICAgICAgIGxldCBjb21wb25lbnQgICA9IHRoaXMuZ2V0KGNvbXBvbmVudElkKSxcbiAgICAgICAgICAgIHJldHVybkFycmF5ID0gW10sXG4gICAgICAgICAgICBjb25maWdBcnJheSwgY29uZmlnTGVuZ3RoLCBtYXRjaEFycmF5O1xuXG4gICAgICAgIGlmIChOZW8uaXNTdHJpbmcoY29uZmlnKSkge1xuICAgICAgICAgICAgY29uZmlnID0ge1xuICAgICAgICAgICAgICAgIG50eXBlOiBjb25maWdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghY29uZmlnKSB7XG4gICAgICAgICAgICBjb25maWcgPSB7fVxuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnQXJyYXkgID0gT2JqZWN0LmVudHJpZXMoY29uZmlnKTtcbiAgICAgICAgY29uZmlnTGVuZ3RoID0gY29uZmlnQXJyYXkubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChjb21wb25lbnQ/LnBhcmVudElkKSB7XG4gICAgICAgICAgICBjb21wb25lbnQgPSB0aGlzLmdldChjb21wb25lbnQucGFyZW50SWQpO1xuXG4gICAgICAgICAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5GaXJzdE1hdGNoID8gbnVsbCA6IHJldHVybkFycmF5XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1hdGNoQXJyYXkgPSBbXTtcblxuICAgICAgICAgICAgY29uZmlnQXJyYXkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudFtrZXldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaEFycmF5LnB1c2godHJ1ZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKG1hdGNoQXJyYXkubGVuZ3RoID09PSBjb25maWdMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAocmV0dXJuRmlyc3RNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcG9uZW50XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuQXJyYXkucHVzaChjb21wb25lbnQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKENvbXBvbmVudCk7XG4iLCJpbXBvcnQgQmFzZSAgICAgICAgICAgICBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBDb21wb25lbnRNYW5hZ2VyIGZyb20gJy4vQ29tcG9uZW50Lm1qcyc7XG5pbXBvcnQgRm9jdXNNYW5hZ2VyICAgICBmcm9tICcuL0ZvY3VzLm1qcyc7XG5pbXBvcnQgTG9nZ2VyICAgICAgICAgICBmcm9tICcuLi91dGlsL0xvZ2dlci5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICAgICAgICAgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IFZEb21VdGlsICAgICAgICAgZnJvbSAnLi4vdXRpbC9WRG9tLm1qcyc7XG5cbmNvbnN0IGV2ZW50Q29uZmlnS2V5cyA9IFtcbiAgICAnYnViYmxlJyxcbiAgICAnZGVsZWdhdGUnLFxuICAgICdsb2NhbCcsXG4gICAgJ3Njb3BlJyxcbiAgICAndm5vZGVJZCdcbl07XG5cbmNvbnN0IGdsb2JhbERvbUV2ZW50cyA9IFtcbiAgICAnY2hhbmdlJyxcbiAgICAnY2xpY2snLFxuICAgICdjb250ZXh0bWVudScsXG4gICAgJ2RibGNsaWNrJyxcbiAgICAnZHJhZzplbmQnLFxuICAgICdkcmFnOm1vdmUnLFxuICAgICdkcmFnOnN0YXJ0JyxcbiAgICAnZm9jdXNpbicsXG4gICAgJ2ZvY3Vzb3V0JyxcbiAgICAnaW5wdXQnLFxuICAgICdpbnRlcnNlY3QnLFxuICAgICdrZXlkb3duJyxcbiAgICAna2V5dXAnLFxuICAgICdtb3VzZWRvd24nLFxuICAgICdtb3VzZWVudGVyJyxcbiAgICAnbW91c2VsZWF2ZScsXG4gICAgJ21vdXNldXAnLFxuICAgICduZW9uYXZpZ2F0ZScsXG4gICAgJ3Njcm9sbCcsXG4gICAgJ3NlbGVjdGlvbmNoYW5nZScsXG4gICAgJ3RvdWNobW92ZScsXG4gICAgJ3doZWVsJ1xuXTtcblxuLyoqXG4gKiBAY2xhc3MgTmVvLm1hbmFnZXIuRG9tRXZlbnRcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqIEBzaW5nbGV0b25cbiAqL1xuY2xhc3MgRG9tRXZlbnQgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5tYW5hZ2VyLkRvbUV2ZW50J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ubWFuYWdlci5Eb21FdmVudCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGl0ZW1zPXt9XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1zOiB7fSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gbWFwPXt9XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG1hcDoge30sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaW5nbGV0b249dHJ1ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzaW5nbGV0b246IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge2RhdGF9IGV2ZW50XG4gICAgICovXG4gICAgYWRkUmVzaXplT2JzZXJ2ZXIoY29tcG9uZW50LCBldmVudCkge1xuICAgICAgICBpZiAoIU5lby5tYWluLmFkZG9uLlJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGb3IgdXNpbmcgcmVzaXplIGRvbUxpc3RlbmVycywgeW91IG11c3QgaW5jbHVkZSBtYWluLmFkZG9uLlJlc2l6ZU9ic2VydmVyLicsIGV2ZW50KVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHtpZCwgd2luZG93SWR9ID0gY29tcG9uZW50O1xuXG4gICAgICAgIE5lby5tYWluLmFkZG9uLlJlc2l6ZU9ic2VydmVyLnJlZ2lzdGVyKHtpZCwgd2luZG93SWR9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBmaXJlKGV2ZW50KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBidWJibGUgICAgICA9IHRydWUsXG4gICAgICAgICAgICBkYXRhICAgICAgICA9IGV2ZW50LmRhdGEgfHwge30sXG4gICAgICAgICAgICB7ZXZlbnROYW1lfSA9IGV2ZW50LFxuICAgICAgICAgICAgaSAgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgbGlzdGVuZXJzICAgPSBudWxsLFxuICAgICAgICAgICAgcGF0aElkcyAgICAgPSBkYXRhLnBhdGgubWFwKGUgPT4gZS5pZCksXG4gICAgICAgICAgICBwYXRoICAgICAgICA9IENvbXBvbmVudE1hbmFnZXIuZ2V0UGFyZW50UGF0aChwYXRoSWRzKSxcbiAgICAgICAgICAgIGxlbiAgICAgICAgID0gcGF0aC5sZW5ndGgsXG4gICAgICAgICAgICBjb21wb25lbnQsIGRlbGVnYXRpb25UYXJnZXRJZCwgaWQsIHByZXZlbnRGaXJlO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlkICAgICAgICA9IHBhdGhbaV07XG4gICAgICAgICAgICBjb21wb25lbnQgPSBOZW8uZ2V0Q29tcG9uZW50KGlkKTtcblxuICAgICAgICAgICAgaWYgKCFjb21wb25lbnQgfHwgY29tcG9uZW50LmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGlzdGVuZXJzID0gbWUuaXRlbXNbaWRdPy5bZXZlbnROYW1lXTtcblxuICAgICAgICAgICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGxpc3RlbmVycykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RvcCBpdGVyYXRpb24gaWYgYSBoYW5kbGVyIHJldHVybnMgZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLmV2ZXJ5KGxpc3RlbmVyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lciAmJiBsaXN0ZW5lci5mbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09ICdyZXNpemUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGRvIG5vdCB3YW50IGRlbGVnYXRpb24gZm9yIGN1c3RvbSBtYWluLmFkZG9uLlJlc2l6ZU9ic2VydmVyIGV2ZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0aW9uVGFyZ2V0SWQgPSBkYXRhLmlkID09PSBjb21wb25lbnQuaWQgPyBkYXRhLmlkIDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0aW9uVGFyZ2V0SWQgPSBtZS52ZXJpZnlEZWxlZ2F0aW9uUGF0aChsaXN0ZW5lciwgZGF0YS5wYXRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWxlZ2F0aW9uVGFyZ2V0SWQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZlbnRGaXJlID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2Ugb25seSB3YW50IG1vdXNlZW50ZXIgJiBsZWF2ZSB0byBmaXJlIG9uIHRoZWlyIHRvcCBsZXZlbCBub2Rlcywgbm90IGZvciBjaGlsZHJlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSAnbW91c2VlbnRlcicgfHwgZXZlbnROYW1lID09PSAnbW91c2VsZWF2ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZlbnRGaXJlID0gIURvbUV2ZW50LnZlcmlmeU1vdXNlRW50ZXJMZWF2ZShjb21wb25lbnQsIGRhdGEsIGRlbGVnYXRpb25UYXJnZXRJZCwgZXZlbnROYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmV2ZW50RmlyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbXVsdGlwbGUgbGlzdGVuZXJzIHdvdWxkIGNoYW5nZSB0aGUgcmVmZXJlbmNlIG9mIGRhdGEuY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gTmVvLmNsb25lKGRhdGEsIHRydWUsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlciBuZWVkcyB0byBrbm93IHdoaWNoIGFjdHVhbCB0YXJnZXQgbWF0Y2hlZCB0aGUgZGVsZWdhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuY3VycmVudFRhcmdldCA9IGRlbGVnYXRpb25UYXJnZXRJZDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE5lby5pc1N0cmluZyhsaXN0ZW5lci5mbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5iaW5kQ2FsbGJhY2sobGlzdGVuZXIuZm4sICdmbicsIGxpc3RlbmVyLnNjb3BlLCBsaXN0ZW5lcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbGlzdGVuZXIuZm4uYXBwbHkobGlzdGVuZXIuc2NvcGUgfHwgZ2xvYmFsVGhpcywgW2RhdGFdKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsaXN0ZW5lci5idWJibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWJibGUgPSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBsaXN0ZW5lciByZXR1cm5zIGZhbHNlLCB3ZSBzdG9wIGl0ZXJhdGluZyB0aGUgbGlzdGVuZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICE9PSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gd2UgZG8gd2FudCB0byB0cmlnZ2VyIHRoZSBGb2N1c01hbmFnZXIgYWZ0ZXIgbm9ybWFsIGRvbUxpc3RlbmVycyBvbiB0aGVzZSBldmVudHMgZ290IGV4ZWN1dGVkXG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSAnZm9jdXNpbicgfHwgZXZlbnROYW1lID09PSAnZm9jdXNvdXQnKSB7XG4gICAgICAgICAgICAgICAgRm9jdXNNYW5hZ2VyWydvbicgKyBOZW8uY2FwaXRhbGl6ZShldmVudE5hbWUpXSh7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEhvbm9yIHRoZSBFdmVudCBjYW5jZWxCdWJibGUgcHJvcGVydHlcbiAgICAgICAgICAgIGlmICghYnViYmxlIHx8IGRhdGEuY2FuY2VsQnViYmxlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudE5hbWUgPT09ICdjb250ZXh0bWVudScgJiYgZGF0YS5jdHJsS2V5KSB7XG4gICAgICAgICAgICBOZW8udXRpbD8uTG9nZ2VyPy5vbkNvbnRleHRNZW51KGRhdGEpXG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnROYW1lLnN0YXJ0c1dpdGgoJ2Ryb3AnKSkge1xuICAgICAgICAgICAgbGV0IGRyYWdab25lID0gZGF0YS5kcmFnWm9uZUlkICYmIE5lby5nZXQoZGF0YS5kcmFnWm9uZUlkKTtcblxuICAgICAgICAgICAgaWYgKGRyYWdab25lKSB7XG4gICAgICAgICAgICAgICAgZHJhZ1pvbmUuZmlyZShldmVudE5hbWUsIGRhdGEpO1xuICAgICAgICAgICAgICAgIGRyYWdab25lW3tcbiAgICAgICAgICAgICAgICAgICAgJ2Ryb3AnICAgICAgOiAnb25Ecm9wJyxcbiAgICAgICAgICAgICAgICAgICAgJ2Ryb3A6ZW50ZXInOiAnb25Ecm9wRW50ZXInLFxuICAgICAgICAgICAgICAgICAgICAnZHJvcDpsZWF2ZSc6ICdvbkRyb3BMZWF2ZScsXG4gICAgICAgICAgICAgICAgfVtldmVudE5hbWVdXS5jYWxsKGRyYWdab25lLCBkYXRhKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGNvbmZpZ1xuICAgICAqIEBwYXJhbSBzY29wZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2VuZXJhdGVMaXN0ZW5lckNvbmZpZyhjb25maWcsIHNjb3BlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBidWJibGUgICA6IGNvbmZpZy5idWJibGUsXG4gICAgICAgICAgICBkZWxlZ2F0ZSA6IGNvbmZpZy5kZWxlZ2F0ZSxcbiAgICAgICAgICAgIGV2ZW50TmFtZTogY29uZmlnLmV2ZW50TmFtZSxcbiAgICAgICAgICAgIGlkICAgICAgIDogc2NvcGUuaWQsXG4gICAgICAgICAgICBvcHRzICAgICA6IGNvbmZpZyxcbiAgICAgICAgICAgIHByaW9yaXR5IDogY29uZmlnLnByaW9yaXR5LFxuICAgICAgICAgICAgc2NvcGUgICAgOiBjb25maWcuc2NvcGUgICB8fCBzY29wZSxcbiAgICAgICAgICAgIHZub2RlSWQgIDogY29uZmlnLnZub2RlSWQgfHwgc2NvcGUudmRvbS5pZFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGdldEV2ZW50TmFtZShjb25maWcpIHtcbiAgICAgICAgbGV0IGV2ZW50TmFtZSA9IG51bGw7XG5cbiAgICAgICAgaWYgKE5lby5pc09iamVjdChjb25maWcpKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhjb25maWcpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWV2ZW50Q29uZmlnS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZSA9IGtleVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXZlbnROYW1lXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY29uZmlnLmJ1YmJsZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcuZGVsZWdhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLmV2ZW50TmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcuaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnLm9wdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnLnNjb3BlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy52bm9kZUlkXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRMaXN0ZW5lcihjb25maWcpIHtcbiAgICAgICAgbGV0IGxpc3RlbmVycyA9IHRoaXMuaXRlbXMsXG4gICAgICAgICAgICBldmVudDtcblxuICAgICAgICBpZiAobGlzdGVuZXJzPy5bY29uZmlnLmlkXSkge1xuICAgICAgICAgICAgZXZlbnQgPSBsaXN0ZW5lcnNbY29uZmlnLmlkXVtjb25maWcuZXZlbnROYW1lXTtcblxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50IHx8IG51bGxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdW50cyBsb2NhbCBkb21FdmVudCBsaXN0ZW5lcnMgZm9yIGEgZ2l2ZW4gY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBtb3VudERvbUxpc3RlbmVycyhjb21wb25lbnQpIHtcbiAgICAgICAgbGV0IGxpc3RlbmVycyAgID0gdGhpcy5pdGVtc1tjb21wb25lbnQuaWRdLFxuICAgICAgICAgICAgbG9jYWxFdmVudHMgPSBbXTtcblxuICAgICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhsaXN0ZW5lcnMpLmZvckVhY2goKFtldmVudE5hbWUsIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIHZhbHVlLmZvckVhY2goZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBldmVudE5hbWUgPSBldmVudC5ldmVudE5hbWU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gJ3Jlc2l6ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkUmVzaXplT2JzZXJ2ZXIoY29tcG9uZW50LCBldmVudClcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudE5hbWUgJiYgKGV2ZW50LmxvY2FsIHx8ICFnbG9iYWxEb21FdmVudHMuaW5jbHVkZXMoZXZlbnROYW1lKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsRXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgICA6IGV2ZW50TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyOiAnZG9tRXZlbnRMaXN0ZW5lcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdm5vZGVJZDogZXZlbnQudm5vZGVJZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGxvY2FsRXZlbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBOZW8ud29ya2VyLkFwcC5wcm9taXNlTWVzc2FnZSgnbWFpbicsIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uICA6ICdhZGREb21MaXN0ZW5lcicsXG4gICAgICAgICAgICAgICAgICAgIGFwcE5hbWUgOiBjb21wb25lbnQuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzICA6IGxvY2FsRXZlbnRzLFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3dJZDogY29tcG9uZW50LndpbmRvd0lkXG4gICAgICAgICAgICAgICAgfSkudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2FkZGVkIGRvbUxpc3RlbmVyJywgZGF0YSk7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0FwcDogR290IGVycm9yIGF0dGVtcHRpbmcgdG8gYWRkIGEgZG9tTGlzdGVuZXInLCBlcnIpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgY29uZmlnXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjb25maWcuYnViYmxlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICBjb25maWcuZGVsZWdhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gIGNvbmZpZy5ldmVudE5hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gIGNvbmZpZy5pZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY29uZmlnLmxvY2FsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICBjb25maWcub3B0c1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgY29uZmlnLm9yaWdpbmFsQ29uZmlnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICBjb25maWcub3duZXJJZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgY29uZmlnLnByaW9yaXR5PTFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gIGNvbmZpZy5zY29wZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgY29uZmlnLnZub2RlSWRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgbGlzdGVuZXIgZ290IHJlZ2lzdGVyZWQgc3VjY2Vzc2Z1bGx5IChmYWxzZSBpbiBjYXNlIGl0IHdhcyBhbHJlYWR5IHRoZXJlKVxuICAgICAqL1xuICAgIHJlZ2lzdGVyKGNvbmZpZykge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBhbHJlYWR5UmVnaXN0ZXJlZCAgICAgICAgICAgID0gZmFsc2UsXG4gICAgICAgICAgICB7ZXZlbnROYW1lLCBpZCwgb3B0cywgc2NvcGV9ID0gY29uZmlnLFxuICAgICAgICAgICAgbGlzdGVuZXJzICAgICAgICAgICAgICAgICAgICA9IG1lLml0ZW1zLFxuICAgICAgICAgICAgZm5UeXBlICAgICAgICAgICAgICAgICAgICAgICA9IHR5cGVvZiBvcHRzLFxuICAgICAgICAgICAgZm4sIGxpc3RlbmVyLCBsaXN0ZW5lckNvbmZpZywgbGlzdGVuZXJJZDtcblxuICAgICAgICBpZiAoZm5UeXBlID09PSAnZnVuY3Rpb24nIHx8IGZuVHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGZuID0gb3B0c1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm4gICAgPSBvcHRzLmZuO1xuICAgICAgICAgICAgc2NvcGUgPSBvcHRzLnNjb3BlIHx8IHNjb3BlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWxpc3RlbmVyc1tpZF0pIHtcbiAgICAgICAgICAgIGxpc3RlbmVyc1tpZF0gPSB7fVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3RlbmVyc1tpZF1bZXZlbnROYW1lXSkge1xuICAgICAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaWRdW2V2ZW50TmFtZV07XG5cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGxpc3RlbmVyKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcltrZXldLmZuLnRvU3RyaW5nKCkgPT09IGZuLnRvU3RyaW5nKCkgJiYgLy8gdG9kbzogYWRkIGEgYmV0dGVyIGNoZWNrXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyW2tleV0uc2NvcGUgICAgICAgICA9PT0gc2NvcGUgJiZcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJba2V5XS5kZWxlZ2F0ZSAgICAgID09PSBjb25maWcuZGVsZWdhdGVcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgYWxyZWFkeVJlZ2lzdGVyZWQgPSB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpc3RlbmVyc1tpZF1bZXZlbnROYW1lXSA9IFtdXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWxyZWFkeVJlZ2lzdGVyZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ21hbmFnZXIuRG9tRXZlbnQgcmVnaXN0ZXInLCBldmVudE5hbWUsIGNvbmZpZyk7XG5cbiAgICAgICAgbGlzdGVuZXJJZCA9IE5lby5nZXRJZCgnZG9tLWV2ZW50Jyk7XG5cbiAgICAgICAgY29uZmlnLmxpc3RlbmVySWQgPSBsaXN0ZW5lcklkO1xuXG4gICAgICAgIGxpc3RlbmVyQ29uZmlnID0ge1xuICAgICAgICAgICAgYnViYmxlICAgICAgICA6IGNvbmZpZy5oYXNPd25Qcm9wZXJ0eSgnYnViYmxlJykgPyBjb25maWcuYnViYmxlIDogb3B0cy5oYXNPd25Qcm9wZXJ0eSgnYnViYmxlJykgPyBvcHRzLmJ1YmJsZSA6IHRydWUsXG4gICAgICAgICAgICBkZWxlZ2F0ZSAgICAgIDogY29uZmlnLmRlbGVnYXRlLFxuICAgICAgICAgICAgZXZlbnROYW1lLFxuICAgICAgICAgICAgZm4sXG4gICAgICAgICAgICBpZCAgICAgICAgICAgIDogbGlzdGVuZXJJZCxcbiAgICAgICAgICAgIG1vdW50ZWQgICAgICAgOiAhY29uZmlnLmxvY2FsICYmIGdsb2JhbERvbUV2ZW50cy5pbmNsdWRlcyhldmVudE5hbWUpLFxuICAgICAgICAgICAgb3JpZ2luYWxDb25maWc6IGNvbmZpZy5vcmlnaW5hbENvbmZpZyxcbiAgICAgICAgICAgIG93bmVySWQgICAgICAgOiBjb25maWcub3duZXJJZCxcbiAgICAgICAgICAgIHByaW9yaXR5ICAgICAgOiBjb25maWcucHJpb3JpdHkgfHwgb3B0cy5wcmlvcml0eSB8fCAxLFxuICAgICAgICAgICAgc2NvcGUsXG4gICAgICAgICAgICB2bm9kZUlkICAgICAgIDogY29uZmlnLnZub2RlSWRcbiAgICAgICAgfTtcblxuICAgICAgICBtZS5tYXBbbGlzdGVuZXJJZF0gPSBsaXN0ZW5lckNvbmZpZztcblxuICAgICAgICBsaXN0ZW5lcnNbaWRdW2V2ZW50TmFtZV0ucHVzaChsaXN0ZW5lckNvbmZpZyk7XG5cbiAgICAgICAgbGlzdGVuZXJzW2lkXVtldmVudE5hbWVdLnNvcnQoKGEsIGIpID0+IGIucHJpb3JpdHkgLSBhLnByaW9yaXR5KTtcblxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNvbmZpZy5idWJibGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLmV2ZW50TmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcuaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnLm9wdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnLnNjb3BlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy52bm9kZUlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNjb3BlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaW4gY2FzZSB0aGUgbGlzdGVuZXIgZGlkIGV4aXN0IGFuZCBnb3QgcmVtb3ZlZFxuICAgICAqL1xuICAgIHVucmVnaXN0ZXIoY29uZmlnLCBzY29wZSkge1xuICAgICAgICAvLyB0b2RvXG4gICAgICAgIGNvbnNvbGUubG9nKCd1bnJlZ2lzdGVyJywgY29uZmlnKTtcbiAgICAgICAgY29uc29sZS5sb2codGhpcy5nZW5lcmF0ZUxpc3RlbmVyQ29uZmlnKGNvbmZpZywgc2NvcGUpKTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGxldCBsaXN0ZW5lciA9IHRoaXMuZ2V0TGlzdGVuZXIoY29uZmlnKTtcblxuICAgICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdsaXN0ZW5lciBmb3VuZCcsIGxpc3RlbmVyKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRvbUxpc3RlbmVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IG9sZERvbUxpc3RlbmVyc1xuICAgICAqL1xuICAgIHVwZGF0ZURvbUxpc3RlbmVycyhjb21wb25lbnQsIGRvbUxpc3RlbmVycywgb2xkRG9tTGlzdGVuZXJzKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHJlZ2lzdGVyZWRMaXN0ZW5lcnMgPSBtZS5pdGVtc1tjb21wb25lbnQuaWRdIHx8IHt9LFxuICAgICAgICAgICAgaSwgbGVuLCBsaXN0ZW5lcnM7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZG9tTGlzdGVuZXJzKSkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2xkRG9tTGlzdGVuZXJzKSkge1xuICAgICAgICAgICAgICAgIG9sZERvbUxpc3RlbmVycy5mb3JFYWNoKG9sZERvbUxpc3RlbmVyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmluZCAmIHJlbW92ZSBubyBsb25nZXIgZXhpc3RpbmcgbGlzdGVuZXJzXG4gICAgICAgICAgICAgICAgICAgIGlmICghZG9tTGlzdGVuZXJzLmluY2x1ZGVzKG9sZERvbUxpc3RlbmVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzID0gcmVnaXN0ZXJlZExpc3RlbmVyc1ttZS5nZXRFdmVudE5hbWUob2xkRG9tTGlzdGVuZXIpXSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgICAgICAgICA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW4gICAgICAgPSBsaXN0ZW5lcnMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tpXS5vcmlnaW5hbENvbmZpZyA9PT0gb2xkRG9tTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGxpc3RlbmVycywgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBhZGQgbmV3IGxpc3RlbmVyc1xuICAgICAgICAgICAgZG9tTGlzdGVuZXJzLmZvckVhY2goZG9tTGlzdGVuZXIgPT4ge1xuICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGRvbUxpc3RlbmVyKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFldmVudENvbmZpZ0tleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUucmVnaXN0ZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1YmJsZSAgICAgICAgOiBkb21MaXN0ZW5lci5idWJibGUgICB8fCB2YWx1ZS5idWJibGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGUgICAgICA6IGRvbUxpc3RlbmVyLmRlbGVnYXRlIHx8IHZhbHVlLmRlbGVnYXRlIHx8ICcjJyArIChjb21wb25lbnQudmRvbS5pZCB8fCBjb21wb25lbnQuaWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZSAgICAgOiBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQgICAgICAgICAgICA6IGNvbXBvbmVudC52ZG9tLmlkIHx8IGNvbXBvbmVudC5pZCwgLy8gaG9ub3Igd3JhcHBlciBub2Rlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMgICAgICAgICAgOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbENvbmZpZzogZG9tTGlzdGVuZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3duZXJJZCAgICAgICA6IGNvbXBvbmVudC5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eSAgICAgIDogZG9tTGlzdGVuZXIucHJpb3JpdHkgfHwgdmFsdWUucHJpb3JpdHkgfHwgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZSAgICAgICAgIDogZG9tTGlzdGVuZXIuc2NvcGUgICAgfHwgY29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZub2RlSWQgICAgICAgOiBkb21MaXN0ZW5lci52bm9kZUlkICB8fCB2YWx1ZS52bm9kZUlkICB8fCBjb21wb25lbnQudmRvbS5pZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5tb3VudGVkICYmIGRvbUxpc3RlbmVycz8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG1lLnRpbWVvdXQoMTAwKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbWUubW91bnREb21MaXN0ZW5lcnMoY29tcG9uZW50KVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBMb2dnZXIubG9nRXJyb3IoJ0NvbXBvbmVudC5kb21MaXN0ZW5lcnMgaGF2ZSB0byBiZSBhbiBhcnJheScsIGNvbXBvbmVudClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsaXN0ZW5lclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGhcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbnxTdHJpbmd9IHRydWUgaW4gY2FzZSB0aGUgZGVsZWdhdGlvbiBzdHJpbmcgbWF0Y2hlcyB0aGUgZXZlbnQgcGF0aFxuICAgICAqL1xuICAgIHZlcmlmeURlbGVnYXRpb25QYXRoKGxpc3RlbmVyLCBwYXRoKSB7XG4gICAgICAgIGxldCB7ZGVsZWdhdGV9ID0gbGlzdGVuZXIsXG4gICAgICAgICAgICBqICAgICAgICAgID0gMCxcbiAgICAgICAgICAgIHBhdGhMZW4gICAgPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgICAgIHRhcmdldElkO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZGVsZWdhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGogPSBkZWxlZ2F0ZShwYXRoKTtcblxuICAgICAgICAgICAgaWYgKGogIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRhcmdldElkID0gcGF0aFtqXS5pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGRlbGVnYXRpb25BcnJheSA9IGRlbGVnYXRlLnNwbGl0KCcgJyksXG4gICAgICAgICAgICAgICAgbGVuICAgICAgICAgICAgID0gZGVsZWdhdGlvbkFycmF5Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICBoYXNNYXRjaCwgaSwgaXRlbSwgaXNJZDtcblxuICAgICAgICAgICAgZm9yIChpPWxlbi0xOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGhhc01hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaXRlbSAgICAgPSBkZWxlZ2F0aW9uQXJyYXlbaV07XG4gICAgICAgICAgICAgICAgaXNJZCAgICAgPSBpdGVtLnN0YXJ0c1dpdGgoJyMnKTtcblxuICAgICAgICAgICAgICAgIGlmIChpc0lkIHx8IGl0ZW0uc3RhcnRzV2l0aCgnLicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBpdGVtLnN1YnN0cigxKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAoOyBqIDwgcGF0aExlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIChpc0lkICYmIHBhdGhbal0uaWQgPT09IGl0ZW0pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoW2pdLmNscy5pbmNsdWRlcyhpdGVtKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc01hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldElkID0gcGF0aFtqXS5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWhhc01hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVuc3VyZSB0aGUgZGVsZWdhdGlvbiBwYXRoIGlzIGEgY2hpbGQgb2YgdGhlIG93bmVyIGNvbXBvbmVudHMgcm9vdCBub2RlXG4gICAgICAgIGZvciAoOyBqIDwgcGF0aExlbjsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGF0aFtqXS5pZCA9PT0gbGlzdGVuZXIudm5vZGVJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRJZFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRlbGVnYXRpb25UYXJnZXRJZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgdmVyaWZ5TW91c2VFbnRlckxlYXZlKGNvbXBvbmVudCwgZGF0YSwgZGVsZWdhdGlvblRhcmdldElkLCBldmVudE5hbWUpIHtcbiAgICAgICAgbGV0IHRhcmdldElkID0gZXZlbnROYW1lID09PSAnbW91c2VlbnRlcicgPyBkYXRhLmZyb21FbGVtZW50SWQgOiBkYXRhLnRvRWxlbWVudElkLFxuICAgICAgICAgICAgZGVsZWdhdGlvblZkb207XG5cbiAgICAgICAgaWYgKHRhcmdldElkICYmIHRhcmdldElkICE9PSBkZWxlZ2F0aW9uVGFyZ2V0SWQpIHtcbiAgICAgICAgICAgIGRlbGVnYXRpb25WZG9tID0gVkRvbVV0aWwuZmluZChjb21wb25lbnQudmRvbSwgZGVsZWdhdGlvblRhcmdldElkKTtcblxuICAgICAgICAgICAgLy8gZGVsZWdhdGlvblZkb20gY2FuIGJlIHVuZGVmaW5lZCB3aGVuIGRyYWdnaW5nIGEgcHJveHkgb3ZlciB0aGUgbm9kZS5cbiAgICAgICAgICAgIC8vIHNlZSBpc3N1ZXMvMTEzNyBmb3IgZGV0YWlscy5cbiAgICAgICAgICAgIGlmICghZGVsZWdhdGlvblZkb20gfHwgZGVsZWdhdGlvblZkb20udmRvbSAmJiBWRG9tVXRpbC5maW5kKGRlbGVnYXRpb25WZG9tLnZkb20sIHRhcmdldElkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKERvbUV2ZW50KTtcbiIsImltcG9ydCBDb3JlQmFzZSBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBOZW9BcnJheSBmcm9tICcuLi91dGlsL0FycmF5Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5tYW5hZ2VyLkZvY3VzXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKiBAc2luZ2xldG9uXG4gKi9cbmNsYXNzIEZvY3VzIGV4dGVuZHMgQ29yZUJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLm1hbmFnZXIuRm9jdXMnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5tYW5hZ2VyLkZvY3VzJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFycmF5IGNvbnRhaW5pbmcgb3B0cyBvYmplY3RzLlxuICAgICAgICAgKiBvcHRzLmNvbXBvbmVudFBhdGhcbiAgICAgICAgICogb3B0cy5kYXRhXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdFtdfSBoaXN0b3J5PVtdXG4gICAgICAgICAqL1xuICAgICAgICBoaXN0b3J5OiBbXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBEYXRlIG9iamVjdCB3aGVuIHRoZSBsYXN0IGZvY3VzaW4gZXZlbnQgaGFzIG9jY3VycmVkXG4gICAgICAgICAqIEBtZW1iZXIge0RhdGV8bnVsbH0gbGFzdEZvY3VzSW5EYXRlPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbGFzdEZvY3VzSW5EYXRlOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIERhdGUgb2JqZWN0IHdoZW4gdGhlIGxhc3QgZm9jdXNvdXQgZXZlbnQgaGFzIG9jY3VycmVkXG4gICAgICAgICAqIEBtZW1iZXIge0RhdGV8bnVsbH0gbGFzdEZvY3VzSW5EYXRlPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbGFzdEZvY3VzT3V0RGF0ZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhbW91bnQgb2YgdGltZSBmb3IgYSBmb2N1c0luIHRvIG9jY3VyIGFmdGVyIHRoZSBsYXN0IGZvY3VzT3V0XG4gICAgICAgICAqIHRvIGdldCBjb21iaW5lZCBpbnRvIGEgZm9jdXNtb3ZlIGV2ZW50LlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IG1heEZvY3VzSW5PdXRHYXA9NTBcbiAgICAgICAgICovXG4gICAgICAgIG1heEZvY3VzSW5PdXRHYXA6IDUwLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1heGltdW0gYW1vdW50IG9mIGl0ZW1zIHN0b3JlZCBpbnNpZGUgdGhlIGhpc3RvcnkgYXJyYXlcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBtYXhIaXN0b3J5TGVuZ3RoPTIwXG4gICAgICAgICAqL1xuICAgICAgICBtYXhIaXN0b3J5TGVuZ3RoOiAyMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZXRvbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZXRvbjogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtBcnJheX0gIG9wdHMuY29tcG9uZW50UGF0aCBDb21wb25lbnQgaWRzIHVwd2FyZHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5kYXRhIGRvbSBldmVudCBpbmZvc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZGRUb0hpc3Rvcnkob3B0cykge1xuICAgICAgICBsZXQgaGlzdG9yeSA9IHRoaXMuaGlzdG9yeTtcblxuICAgICAgICBoaXN0b3J5LnVuc2hpZnQob3B0cyk7XG4gICAgICAgIGhpc3RvcnkubGVuZ3RoID49IHRoaXMubWF4SGlzdG9yeUxlbmd0aCAmJiBoaXN0b3J5LnBvcCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgb3B0cy5jb21wb25lbnRQYXRoIENvbXBvbmVudCBpZHMgdXB3YXJkc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmRhdGEgZG9tIGV2ZW50IGluZm9zXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGZvY3VzRW50ZXIob3B0cykge1xuICAgICAgICB0aGlzLnNldENvbXBvbmVudEZvY3VzKG9wdHMsIHRydWUpO1xuICAgICAgICB0aGlzLmFkZFRvSGlzdG9yeShvcHRzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtBcnJheX0gIG9wdHMuY29tcG9uZW50UGF0aCBDb21wb25lbnQgaWRzIHVwd2FyZHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5kYXRhIGRvbSBldmVudCBpbmZvc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBmb2N1c0xlYXZlKG9wdHMpIHtcbiAgICAgICAgdGhpcy5zZXRDb21wb25lbnRGb2N1cyhvcHRzLCBmYWxzZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9ICBvcHRzLmNvbXBvbmVudFBhdGggQ29tcG9uZW50IGlkcyB1cHdhcmRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuZGF0YSBkb20gZXZlbnQgaW5mb3NcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZm9jdXNNb3ZlKG9wdHMpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2hpc3Rvcnl9ICAgICAgICA9IG1lLFxuICAgICAgICAgICAgbmV3Q29tcG9uZW50UGF0aCA9IG9wdHMuY29tcG9uZW50UGF0aCxcbiAgICAgICAgICAgIG9sZENvbXBvbmVudFBhdGggPSBoaXN0b3J5WzBdLmNvbXBvbmVudFBhdGgsXG4gICAgICAgICAgICBmb2N1c0VudGVyICAgICAgID0gTmVvQXJyYXkuZGlmZmVyZW5jZShuZXdDb21wb25lbnRQYXRoLCBvbGRDb21wb25lbnRQYXRoKSxcbiAgICAgICAgICAgIGZvY3VzTGVhdmUgICAgICAgPSBOZW9BcnJheS5kaWZmZXJlbmNlKG9sZENvbXBvbmVudFBhdGgsIG5ld0NvbXBvbmVudFBhdGgpLFxuICAgICAgICAgICAgZm9jdXNNb3ZlICAgICAgICA9IE5lb0FycmF5LmludGVyc2VjdGlvbihuZXdDb21wb25lbnRQYXRoLCBvbGRDb21wb25lbnRQYXRoKSxcbiAgICAgICAgICAgIGNvbXBvbmVudCwgZGF0YTtcblxuICAgICAgICBtZS5zZXRDb21wb25lbnRGb2N1cyh7Y29tcG9uZW50UGF0aDogZm9jdXNMZWF2ZSwgZGF0YTogb3B0cy5kYXRhfSwgZmFsc2UpO1xuICAgICAgICBtZS5zZXRDb21wb25lbnRGb2N1cyh7Y29tcG9uZW50UGF0aDogZm9jdXNFbnRlciwgZGF0YTogb3B0cy5kYXRhfSwgdHJ1ZSk7XG5cbiAgICAgICAgZm9jdXNNb3ZlLmZvckVhY2goaWQgPT4ge1xuICAgICAgICAgICAgY29tcG9uZW50ID0gTmVvLmdldENvbXBvbmVudChpZCk7XG5cbiAgICAgICAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgIHBhdGggICA6IG9wdHMuZGF0YS5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBvbGRQYXRoOiBoaXN0b3J5WzBdLmRhdGEucGF0aFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBjb21wb25lbnQub25Gb2N1c01vdmU/LihkYXRhKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuZmlyZSgnZm9jdXNNb3ZlJywgZGF0YSk7XG5cbiAgICAgICAgICAgICAgICBjb21wb25lbnQub25Gb2N1c0NoYW5nZT8uKGRhdGEpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5maXJlKCdmb2N1c0NoYW5nZScsIGRhdGEpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLmFkZFRvSGlzdG9yeShvcHRzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtBcnJheX0gIG9wdHMuY29tcG9uZW50UGF0aCBDb21wb25lbnQgaWRzIHVwd2FyZHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5kYXRhIGRvbSBldmVudCBpbmZvc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbkZvY3VzaW4ob3B0cykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmxhc3RGb2N1c0luRGF0ZSA9IG5ldyBEYXRlKCk7XG5cbiAgICAgICAgaWYgKG1lLmxhc3RGb2N1c091dERhdGUgJiYgbWUubGFzdEZvY3VzSW5EYXRlIC0gbWUubGFzdEZvY3VzT3V0RGF0ZSA8IG1lLm1heEZvY3VzSW5PdXRHYXApIHtcbiAgICAgICAgICAgIG1lLmZvY3VzTW92ZShvcHRzKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUuZm9jdXNFbnRlcihvcHRzKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgb3B0cy5jb21wb25lbnRQYXRoIENvbXBvbmVudCBpZHMgdXB3YXJkc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmRhdGEgZG9tIGV2ZW50IGluZm9zXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uRm9jdXNvdXQob3B0cykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmxhc3RGb2N1c091dERhdGUgPSBuZXcgRGF0ZSgpO1xuXG4gICAgICAgIG1lLnRpbWVvdXQobWUubWF4Rm9jdXNJbk91dEdhcCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBpZiAobWUubGFzdEZvY3VzT3V0RGF0ZSA+IG1lLmxhc3RGb2N1c0luRGF0ZSkge1xuICAgICAgICAgICAgICAgIG1lLmZvY3VzTGVhdmUob3B0cylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9ICBvcHRzLmNvbXBvbmVudFBhdGggQ29tcG9uZW50IGlkcyB1cHdhcmRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuZGF0YSBkb20gZXZlbnQgaW5mb3NcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNvbnRhaW5zRm9jdXNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2V0Q29tcG9uZW50Rm9jdXMob3B0cywgY29udGFpbnNGb2N1cykge1xuICAgICAgICBsZXQgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICByZWxhdGVkVGFyZ2V0OiBvcHRzLmRhdGEucmVsYXRlZFRhcmdldFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbXBvbmVudHMgPSBvcHRzLmNvbXBvbmVudFBhdGgubWFwKGlkID0+IE5lby5nZXRDb21wb25lbnQoaWQpKSxcbiAgICAgICAgICAgIGhhbmRsZXI7XG5cbiAgICAgICAgY29tcG9uZW50cy5mb3JFYWNoKGNvbXBvbmVudCA9PiB7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LmNvbnRhaW5zRm9jdXMgPSBjb250YWluc0ZvY3VzXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbXBvbmVudHMuZm9yRWFjaChjb21wb25lbnQgPT4ge1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIGRhdGEuY29tcG9uZW50ID0gY29tcG9uZW50O1xuXG4gICAgICAgICAgICAgICAgZGF0YVtjb250YWluc0ZvY3VzID8gJ3BhdGgnIDogJ29sZFBhdGgnXSA9IG9wdHMuZGF0YS5wYXRoXG5cbiAgICAgICAgICAgICAgICBoYW5kbGVyID0gY29udGFpbnNGb2N1cyA/ICdvbkZvY3VzRW50ZXInIDogJ29uRm9jdXNMZWF2ZSc7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50W2hhbmRsZXJdPy4oZGF0YSk7XG5cbiAgICAgICAgICAgICAgICBjb21wb25lbnQuZmlyZShjb250YWluc0ZvY3VzID8gJ2ZvY3VzRW50ZXInIDogJ2ZvY3VzTGVhdmUnLCBkYXRhKTtcblxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5vbkZvY3VzQ2hhbmdlPy4oZGF0YSk7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LmZpcmUoJ2ZvY3VzQ2hhbmdlJywgZGF0YSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEZvY3VzKTtcbiIsImltcG9ydCBCYXNlICAgIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuaW1wb3J0IE1hbmFnZXIgZnJvbSAnLi9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5tYW5hZ2VyLkluc3RhbmNlXG4gKiBAZXh0ZW5kcyBOZW8ubWFuYWdlci5CYXNlXG4gKiBAc2luZ2xldG9uXG4gKi9cbmNsYXNzIEluc3RhbmNlIGV4dGVuZHMgTWFuYWdlciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ubWFuYWdlci5JbnN0YW5jZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLm1hbmFnZXIuSW5zdGFuY2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2luZ2xldG9uPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2luZ2xldG9uOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBCYXNlLmluc3RhbmNlTWFuYWdlckF2YWlsYWJsZSA9IHRydWU7XG5cbiAgICAgICAgbWUuY29uc3VtZU5lb0lkTWFwKCk7XG5cbiAgICAgICAgTmVvLmZpbmQgICAgICA9IG1lLmZpbmQgICAgIC5iaW5kKG1lKTsgLy8gYWxpYXNcbiAgICAgICAgTmVvLmZpbmRGaXJzdCA9IG1lLmZpbmRGaXJzdC5iaW5kKG1lKTsgLy8gYWxpYXNcbiAgICAgICAgTmVvLmdldCAgICAgICA9IG1lLmdldCAgICAgIC5iaW5kKG1lKTsgLy8gYWxpYXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhbGwgaWRzIHdoaWNoIGdvdCBhcHBsaWVkIHRvIHRoZSBOZW8gbmFtZXNwYWNlIGJlZm9yZSB0aGlzIGluc3RhbmNlIGdvdCBjcmVhdGVkXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNvbnN1bWVOZW9JZE1hcCgpIHtcbiAgICAgICAgaWYgKE5lby5pZE1hcCkge1xuICAgICAgICAgICAgdGhpcy5hZGQoT2JqZWN0LnZhbHVlcyhOZW8uaWRNYXApKTtcbiAgICAgICAgICAgIGRlbGV0ZSBOZW8uaWRNYXBcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoSW5zdGFuY2UpO1xuIiwiaW1wb3J0IEJhc2UgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby51dGlsLkFycmF5XG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIE5lb0FycmF5IGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8udXRpbC5BcnJheSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnV0aWwuQXJyYXknXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBpdGVtIG9yIEFycmF5IG9mIGl0ZW1zIHRvIGFuIGFycmF5IGluIGNhc2UgaXQgZG9lcyBub3QgYWxyZWFkeSBleGlzdC5cbiAgICAgKiBPbmx5IHByaW1pdGl2ZSBpdGVtcyB3aWxsIGdldCBmb3VuZCBhcyBkdXBsaWNhdGVzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAgICogQHBhcmFtIHsqfSBpdGVtc1xuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkKGFyciwgaXRlbXMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICAgICAgaXRlbXMgPSBbaXRlbXNdXG4gICAgICAgIH1cblxuICAgICAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaWYgKCFhcnIuaW5jbHVkZXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBhcnIucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGFyclxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgaXRlbXMgd2hpY2ggYXJlIHByZXNlbnQgaW4gYXJyYXkxLCBidXQgbm90IGluIGFycmF5MlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5MT1bXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5Mj1bXVxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZGlmZmVyZW5jZShhcnJheTE9W10sIGFycmF5Mj1bXSkge1xuICAgICAgICByZXR1cm4gYXJyYXkxLmZpbHRlcihpdGVtID0+ICFhcnJheTIuaW5jbHVkZXMoaXRlbSkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBpdGVtIGlzIGluY2x1ZGVkIGJ5IHJlZmVyZW5jZSBpbnNpZGUgdGhlIGFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAgICogQHBhcmFtIHsqfSBpdGVtXG4gICAgICovXG4gICAgc3RhdGljIGhhc0l0ZW0oYXJyLCBpdGVtKSB7XG4gICAgICAgIHJldHVybiBhcnIuaW5jbHVkZXMoaXRlbSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGFuIGl0ZW0gb3IgQXJyYXkgb2YgaXRlbXMgdG8gYW4gYXJyYXkgaW4gY2FzZSBpdCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LlxuICAgICAqIER1cGxpY2F0ZXMgd2lsbCBvbmx5IGdldCBtYXRjaGVkIGJ5IHJlZmVyZW5jZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcGFyYW0geyp9IGl0ZW1zXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIHN0YXRpYyBpbnNlcnQoYXJyLCBpbmRleCwgaXRlbXMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICAgICAgaXRlbXMgPSBbaXRlbXNdXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbGVuID0gaXRlbXMubGVuZ3RoIC0xLFxuICAgICAgICAgICAgaSAgID0gbGVuLFxuICAgICAgICAgICAgY3VycmVudEluZGV4LCBpdGVtO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgYmFja3dhcmRzXG4gICAgICAgIGZvciAoOyBpID4gLTE7IGktLSkge1xuICAgICAgICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuXG4gICAgICAgICAgICBjdXJyZW50SW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcblxuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSBjdXJyZW50SW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZlKGFyciwgY3VycmVudEluZGV4LCBpbmRleClcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhcnIuc3BsaWNlKGluZGV4LCAwLCBpdGVtKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhcnJcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGl0ZW1zIHdoaWNoIGFyZSBwcmVzZW50IGluIGFycmF5MSBhbmQgYXJyYXkyXG4gICAgICogT25seSBzdXBwb3J0cyBwcmltaXRpdmUgaXRlbXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheTE9W11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheTI9W11cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgc3RhdGljIGludGVyc2VjdGlvbihhcnJheTE9W10sIGFycmF5Mj1bXSkge1xuICAgICAgICByZXR1cm4gYXJyYXkxLmZpbHRlcihpdGVtID0+IGFycmF5Mi5pbmNsdWRlcyhpdGVtKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhbiBpdGVtIGluc2lkZSBhcnIgZnJvbSBmcm9tSW5kZXggdG8gdG9JbmRleFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmcm9tSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdG9JbmRleFxuICAgICAqL1xuICAgIHN0YXRpYyBtb3ZlKGFyciwgZnJvbUluZGV4LCB0b0luZGV4KSB7XG4gICAgICAgIGlmIChmcm9tSW5kZXggPT09IHRvSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmcm9tSW5kZXggPj0gYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgZnJvbUluZGV4ID0gYXJyLmxlbmd0aCAtIDFcbiAgICAgICAgfVxuXG4gICAgICAgIGFyci5zcGxpY2UodG9JbmRleCwgMCwgYXJyLnNwbGljZShmcm9tSW5kZXgsIDEpWzBdKTtcbiAgICAgICAgcmV0dXJuIGFyclxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW4gaXRlbSBvciBhcnJheSBvZiBpdGVtcyBmcm9tIGFuIGFycmF5LiBPbmx5IHByaW1pdGl2ZSBpdGVtcyB3aWxsIGdldCBmb3VuZFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICAgICAqIEBwYXJhbSB7Kn0gaXRlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgcmVtb3ZlKGFyciwgaXRlbXMpIHtcbiAgICAgICAgbGV0IGluZGV4O1xuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICAgICAgICAgIGl0ZW1zID0gW2l0ZW1zXVxuICAgICAgICB9XG5cbiAgICAgICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XG5cbiAgICAgICAgICAgIGluZGV4ID4gLTEgJiYgYXJyLnNwbGljZShpbmRleCwgMSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGFyclxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCB0byBjb21iaW5lIGFkZCAmIHJlbW92ZSBpbiBvbmUgY2FsbC5cbiAgICAgKiBZb3UgY2FuIHBhc3Mgc2luZ2xlIGl0ZW1zIG9yIGFuIGFycmF5IG9mIGl0ZW1zIHRvIGFkZCBvciB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAgICogQHBhcmFtIHsqfSByZW1vdmVJdGVtc1xuICAgICAqIEBwYXJhbSB7Kn0gYWRkSXRlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgcmVtb3ZlQWRkKGFyciwgcmVtb3ZlSXRlbXMsIGFkZEl0ZW1zKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKGFyciwgcmVtb3ZlSXRlbXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5hZGQoYXJyLCBhZGRJdGVtcylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSBhbiBhcnJheSBpbiBjYXNlIGl0IGRvZXMgZXhpc3QsIG90aGVyd2lzZSBhZGRzIGl0XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAgICogQHBhcmFtIHsqfSBpdGVtXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYWRkXVxuICAgICAqL1xuICAgIHN0YXRpYyB0b2dnbGUoYXJyLCBpdGVtLCBhZGQgPSAhdGhpcy5oYXNJdGVtKGFyciwgaXRlbSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbYWRkID8gJ2FkZCcgOiAncmVtb3ZlJ10oYXJyLCBpdGVtKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGl0ZW1zIHdoaWNoIGFyZSBwcmVzZW50IGluIHRoZSBwYXNzZWQgYXJyYXlzLlxuICAgICAqIE11bHRpcGxlIGFycmF5cyBtYXkgYmUgcGFzc2VkLlxuICAgICAqIE9ubHkgc3VwcG9ydHMgcHJpbWl0aXZlIGl0ZW1zXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIHN0YXRpYyB1bmlvbigpIHtcbiAgICAgICAgcmV0dXJuIFsuLi5uZXcgU2V0KEFycmF5LnByb3RvdHlwZS5jb25jYXQoLi4uYXJndW1lbnRzKSldXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBpdGVtIG9yIEFycmF5IG9mIGl0ZW1zIHRvIGFuIGFycmF5IGluIGNhc2UgaXQgZG9lcyBub3QgYWxyZWFkeSBleGlzdC5cbiAgICAgKiBPbmx5IHByaW1pdGl2ZSBpdGVtcyB3aWxsIGdldCBmb3VuZCBhcyBkdXBsaWNhdGVzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAgICogQHBhcmFtIHsqfSBpdGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyB1bnNoaWZ0KGFyciwgaXRlbXMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICAgICAgaXRlbXMgPSBbaXRlbXNdXG4gICAgICAgIH1cblxuICAgICAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaWYgKCFhcnIuaW5jbHVkZXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBhcnIudW5zaGlmdChpdGVtKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gYXJyXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhOZW9BcnJheSk7XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnV0aWwuQ2xhc3NTeXN0ZW1cbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgQ2xhc3NTeXN0ZW0gZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby51dGlsLkNsYXNzU3lzdGVtJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8udXRpbC5DbGFzc1N5c3RlbSdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjYW4gZ2V0IHVzZWQgaW5zaWRlIGJlZm9yZVNldCBtZXRob2RzIGluIGNhc2UgeW91IHdhbnQgdG8gY3JlYXRlIGluc3RhbmNlcyBsaWtlIHN0b3Jlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fE5lby5jb3JlLkJhc2V8bnVsbH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtOZW8uY29yZS5CYXNlfFN0cmluZ30gW0RlZmF1bHRDbGFzcz1udWxsXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZGVmYXVsdFZhbHVlcz17fV1cbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvcmUuQmFzZX0gaW5zdGFuY2VcbiAgICAgKi9cbiAgICBzdGF0aWMgYmVmb3JlU2V0SW5zdGFuY2UoY29uZmlnLCBEZWZhdWx0Q2xhc3M9bnVsbCwgZGVmYXVsdFZhbHVlcz17fSkge1xuICAgICAgICBsZXQgY29uZmlnVHlwZSA9IE5lby50eXBlT2YoY29uZmlnKTtcblxuICAgICAgICBpZiAoTmVvLmlzU3RyaW5nKERlZmF1bHRDbGFzcykpIHtcbiAgICAgICAgICAgIERlZmF1bHRDbGFzcyA9IE5lby5ucyhEZWZhdWx0Q2xhc3MpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNvbmZpZyAmJiBEZWZhdWx0Q2xhc3MpIHtcbiAgICAgICAgICAgIGNvbmZpZyA9IE5lby5jcmVhdGUoRGVmYXVsdENsYXNzLCBkZWZhdWx0VmFsdWVzKVxuICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZ1R5cGUgPT09ICdOZW9DbGFzcycpIHtcbiAgICAgICAgICAgIGNvbmZpZyA9IE5lby5jcmVhdGUoY29uZmlnLCBkZWZhdWx0VmFsdWVzKVxuICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZ1R5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAoY29uZmlnLm50eXBlKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnID0gTmVvLm50eXBlKHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZGVmYXVsdFZhbHVlcyxcbiAgICAgICAgICAgICAgICAgICAgLi4uY29uZmlnXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld0NvbmZpZyA9IHt9O1xuXG4gICAgICAgICAgICAgICAgaWYgKERlZmF1bHRDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICBuZXdDb25maWcubW9kdWxlID0gRGVmYXVsdENsYXNzXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihuZXdDb25maWcsIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZGVmYXVsdFZhbHVlcyxcbiAgICAgICAgICAgICAgICAgICAgLi4uY29uZmlnXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBjb25maWcgPSBOZW8uY3JlYXRlKG5ld0NvbmZpZylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjb25maWdUeXBlID09PSAnTmVvSW5zdGFuY2UnKSB7XG4gICAgICAgICAgICBpZiAoZGVmYXVsdFZhbHVlcz8ubGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLm9uKGRlZmF1bHRWYWx1ZXMubGlzdGVuZXJzKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbmZpZ1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ2xhc3NTeXN0ZW0pO1xuIiwiY29uc3Qgb3JpZ2luYWxNZXRob2RTeW1ib2wgPSBTeW1ib2woJ29yaWdpbmFsTWV0aG9kJyk7XG5jb25zdCBzZXF1ZW5jZWRGbnNTeW1ib2wgICA9IFN5bWJvbCgnc2VxdWVuY2VkRm5zJyk7XG5cbi8qKlxuICogQXBwZW5kIGFyZ3MgaW5zdGVhZCBvZiBwcmVwZW5kaW5nIHRoZW1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gc2NvcGVcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRBcHBlbmQoZm4sIHNjb3BlKSB7XG4gICAgY29uc3QgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5zbGljZSgyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHNjb3BlLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykuY29uY2F0KGFyZ3MpKVxuICAgIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHBhcmFtIHtOZW8uY29yZS5CYXNlfSBzY29wZVxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5PTMwMFxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVmZmVyKGNhbGxiYWNrLCBzY29wZSwgZGVsYXk9MzAwKSB7XG4gICAgbGV0IHRpbWVvdXRJZDtcblxuICAgIGNvbnN0IHdyYXBwZXIgPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICAgIC8vIGNhbGxiYWNrIGludm9jYXRpb24gY29tZXMgXCJkZWxheVwiIG1zIGFmdGVyIHRoZSBsYXN0IGNhbGwgdG8gd3JhcHBlclxuICAgICAgICAvLyBzbyBjYW5jZWwgYW55IHBlbmRpbmcgaW52b2NhdGlvbi5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG5cbiAgICAgICAgd3JhcHBlci5pc1BlbmRpbmcgPSB0cnVlO1xuXG4gICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGltZW91dElkID0gMDtcbiAgICAgICAgICAgIHdyYXBwZXIuaXNQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseShzY29wZSwgYXJncylcbiAgICAgICAgfSwgZGVsYXkpXG4gICAgfTtcblxuICAgIHdyYXBwZXIuY2FuY2VsID0gKCkgPT4ge1xuICAgICAgICB3cmFwcGVyLmlzUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKVxuICAgIH07XG5cbiAgICByZXR1cm4gd3JhcHBlclxufVxuXG4vKipcbiAqIEludGVuZGVkIGZvciBmdW5jdGlvbnMgd2l0aCAxIHBhcmFtIHdoZXJlIHRoZSBpbnRlcmNlcHRvciBjYW4gY2hhbmdlIHRoZSB2YWx1ZVxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IHRhcmdldE1ldGhvZE5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGludGVyY2VwdEZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gc2NvcGU9dGFyZ2V0XG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVJbnRlcmNlcHRvcih0YXJnZXQsIHRhcmdldE1ldGhvZE5hbWUsIGludGVyY2VwdEZ1bmN0aW9uLCBzY29wZSkge1xuICAgIGxldCB0YXJnZXRNZXRob2QgPSB0YXJnZXRbdGFyZ2V0TWV0aG9kTmFtZV07XG5cbiAgICByZXR1cm4gKHRhcmdldFt0YXJnZXRNZXRob2ROYW1lXSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXRNZXRob2QuY2FsbCh0YXJnZXQsIGludGVyY2VwdEZ1bmN0aW9uLmNhbGwoc2NvcGUgfHwgdGFyZ2V0LCB2YWx1ZSkpXG4gICAgfSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05lby5jb3JlLkJhc2V9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZE5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gc2NvcGVcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNlcXVlbmNlKHRhcmdldCwgbWV0aG9kTmFtZSwgZm4sIHNjb3BlKSB7XG4gICAgbGV0IGN1cnJlbnRNZXRob2QgPSB0YXJnZXRbbWV0aG9kTmFtZV0sXG4gICAgICAgIHdyYXBwZXI7XG5cbiAgICBpZiAoY3VycmVudE1ldGhvZCAmJiBjdXJyZW50TWV0aG9kW3NlcXVlbmNlZEZuc1N5bWJvbF0pIHtcbiAgICAgICAgLy8gQWxyZWFkeSBhIHNlcXVlbmNlZCBtZXRob2QsIGFkZCB0byBpdHMgbGlzdFxuICAgICAgICB3cmFwcGVyID0gY3VycmVudE1ldGhvZDtcbiAgICAgICAgd3JhcHBlcltzZXF1ZW5jZWRGbnNTeW1ib2xdLnB1c2goe2ZuLCBzY29wZX0pXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRmlyc3QgdGltZSBzZXF1ZW5jaW5nIHRoaXMgbWV0aG9kXG4gICAgICAgIGxldCBvcmlnaW5hbE1ldGhvZCA9IGN1cnJlbnRNZXRob2QgfHwgTmVvLmVtcHR5Rm47XG5cbiAgICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgb3JpZ2luYWxNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gQ2FsbCB0aGUgb3JpZ2luYWwgbWV0aG9kXG5cbiAgICAgICAgICAgIC8vIENhbGwgYWxsIHNlcXVlbmNlZCBmdW5jdGlvbnNcbiAgICAgICAgICAgIHdyYXBwZXJbc2VxdWVuY2VkRm5zU3ltYm9sXS5mb3JFYWNoKHNlcUZuID0+IHtcbiAgICAgICAgICAgICAgICBzZXFGbi5mbi5hcHBseShzZXFGbi5zY29wZSB8fCB0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHdyYXBwZXJbc2VxdWVuY2VkRm5zU3ltYm9sXSA9IFt7Zm4sIHNjb3BlfV07XG4gICAgICAgIHdyYXBwZXJbb3JpZ2luYWxNZXRob2RTeW1ib2xdID0gb3JpZ2luYWxNZXRob2Q7IC8vIFN0b3JlIG9yaWdpbmFsIG1ldGhvZFxuICAgIH1cblxuICAgIHJldHVybiAodGFyZ2V0W21ldGhvZE5hbWVdID0gd3JhcHBlcik7XG59XG5cbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7TmVvLmNvcmUuQmFzZX0gc2NvcGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheT0zMDBcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlYm91bmNlKGNhbGxiYWNrLCBzY29wZSwgZGVsYXk9MzAwKSB7XG4gICAgbGV0IGRlYm91bmNlVGltZXI7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgICAvLyBsZWFkaW5nIGVkZ2UgPT4gdHJpZ2dlciB0aGUgZmlyc3QgY2FsbCByaWdodCBhd2F5XG4gICAgICAgIGlmICghTmVvLmlzTnVtYmVyKGRlYm91bmNlVGltZXIpKSB7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoZSBzY29wZSAoaW5zdGFuY2UpIGRpZCBub3QgZ2V0IGRlc3Ryb3llZCB5ZXRcbiAgICAgICAgICAgIHNjb3BlPy5pZCAmJiBjYWxsYmFjay5hcHBseShzY29wZSwgYXJncyk7XG5cbiAgICAgICAgICAgIC8vIHdlIHN0aWxsIHdhbnQgdG8gc3RhcnQgYSB0aW1lciB0byBkZWxheSB0aGUgMm5kKyB1cGRhdGVcbiAgICAgICAgICAgIGRlYm91bmNlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtkZWJvdW5jZVRpbWVyID0gbnVsbH0sICBkZWxheSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChkZWJvdW5jZVRpbWVyKTtcblxuICAgICAgICAgICAgZGVib3VuY2VUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlIHNjb3BlIChpbnN0YW5jZSkgZGlkIG5vdCBnZXQgZGVzdHJveWVkIHlldFxuICAgICAgICAgICAgICAgIHNjb3BlPy5pZCAmJiBjYWxsYmFjay5hcHBseShzY29wZSwgYXJncyk7XG4gICAgICAgICAgICAgICAgZGVib3VuY2VUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge2RlYm91bmNlVGltZXIgPSBudWxsfSwgIGRlbGF5KVxuICAgICAgICAgICAgfSwgIGRlbGF5KVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBpbnRlcmNlcHRvciBjYW4gcHJldmVudCB0aGUgdGFyZ2V0TWV0aG9kIGZyb20gZ2V0dGluZyBleGVjdXRlZCBpbiBjYXNlIGl0IHJldHVybnMgZmFsc2UuXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gdGFyZ2V0TWV0aG9kTmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gaW50ZXJjZXB0RnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZT10YXJnZXRcbiAqIEBwYXJhbSB7Kn0gcHJldmVudGVkUmV0dXJuVmFsdWU9bnVsbCBUaGUgdmFsdWUgdG8gcmV0dXJuIGluIGNhc2UgdGhlIGludGVyY2VwdEZ1bmN0aW9uIHJldHVybnMgZmFsc2VcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVyY2VwdCh0YXJnZXQsIHRhcmdldE1ldGhvZE5hbWUsIGludGVyY2VwdEZ1bmN0aW9uLCBzY29wZSwgcHJldmVudGVkUmV0dXJuVmFsdWU9bnVsbCkge1xuICAgIGxldCB0YXJnZXRNZXRob2QgPSB0YXJnZXRbdGFyZ2V0TWV0aG9kTmFtZV07XG5cbiAgICByZXR1cm4gKHRhcmdldFt0YXJnZXRNZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKGludGVyY2VwdEZ1bmN0aW9uLmFwcGx5KHNjb3BlIHx8IHRhcmdldCwgYXJndW1lbnRzKSA9PT0gZmFsc2UpXG4gICAgICAgICAgICA/IHByZXZlbnRlZFJldHVyblZhbHVlXG4gICAgICAgICAgICA6IHRhcmdldE1ldGhvZC5hcHBseSh0YXJnZXQsIGFyZ3VtZW50cylcbiAgICB9KVxufVxuXG4vKipcbiAqIExvY2F0ZSBhIGNhbGxhYmxlIGZ1bmN0aW9uIGJ5IG5hbWUgaW4gdGhlIHBhc3NlZCBzY29wZS5cbiAqXG4gKiBJZiB0aGUgbmFtZSBzdGFydHMgd2l0aCAndXAuJywgdGhlIHBhcmVudCBDb21wb25lbnQgY2hhaW4gaXMgc2VhcmNoZWQuXG4gKlxuICogVGhpcyBpcyB1c2VkIGJ5IG1hbmFnZXIuRG9tRXZlbnRzICYgY29yZS5PYnNlcnZhYmxlLmZpcmUgYW5kIGJ5ICdoYW5kbGVyJyBmdW5jdGlvbiBjYWxscyB0byByZXNvbHZlXG4gKiBzdHJpbmcgZnVuY3Rpb24gbmFtZXMgaW4gdGhlIENvbXBvbmVudCdzIG93biBoaWVyYXJjaHkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gZm4gQSBmdW5jdGlvbiwgb3IgdGhlIG5hbWUgb2YgYSBmdW5jdGlvbiB0byBmaW5kIGluIHRoZSBwYXNzZWQgc2NvcGUgb2JqZWN0L1xuICogQHBhcmFtIHtPYmplY3R9IHNjb3BlPXRoaXMgVGhlIHNjb3BlIHRvIGZpbmQgdGhlIGZ1bmN0aW9uIGluIGlmIGl0IGlzIHNwZWNpZmllZCBhcyBhIHN0cmluZy5cbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlQ2FsbGJhY2soZm4sIHNjb3BlPXRoaXMpIHtcbiAgICBpZiAoTmVvLmlzU3RyaW5nKGZuKSkge1xuICAgICAgICBpZiAoIXNjb3BlW2ZuXSAmJiBmbi5zdGFydHNXaXRoKCd1cC4nKSkge1xuICAgICAgICAgICAgZm4gPSBmbi5zbGljZSgzKTtcbiAgICAgICAgICAgIHdoaWxlICghc2NvcGVbZm5dICYmIChzY29wZSA9IHNjb3BlLnBhcmVudCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2NvcGUgPSBzY29wZS5nZXRDb250cm9sbGVyPy4oKT8uZ2V0SGFuZGxlclNjb3BlKGZuLCBudWxsKSB8fCBzY29wZVxuICAgICAgICB9XG5cbiAgICAgICAgZm4gPSBzY29wZVtmbl1cbiAgICB9XG5cbiAgICByZXR1cm4ge2ZuLCBzY29wZX1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHBhcmFtIHtOZW8uY29yZS5CYXNlfSBzY29wZVxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5PTMwMFxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gdGhyb3R0bGUoY2FsbGJhY2ssIHNjb3BlLCBkZWxheT0zMDApIHtcbiAgICBsZXQgbGFzdFJhbkRhdGUsIHRpbWVvdXRJZDtcblxuICAgIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICAgIGlmICghbGFzdFJhbkRhdGUpIHtcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlIHNjb3BlIChpbnN0YW5jZSkgZGlkIG5vdCBnZXQgZGVzdHJveWVkIHlldFxuICAgICAgICAgICAgc2NvcGU/LmlkICYmIGNhbGxiYWNrLmFwcGx5KHNjb3BlLCBhcmdzKTtcblxuICAgICAgICAgICAgbGFzdFJhbkRhdGUgPSBEYXRlLm5vdygpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKVxuXG4gICAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICgoRGF0ZS5ub3coKSAtIGxhc3RSYW5EYXRlKSA+PSBkZWxheSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoZSBzY29wZSAoaW5zdGFuY2UpIGRpZCBub3QgZ2V0IGRlc3Ryb3llZCB5ZXRcbiAgICAgICAgICAgICAgICAgICAgc2NvcGU/LmlkICYmIGNhbGxiYWNrLmFwcGx5KHNjb3BlLCBhcmdzKTtcblxuICAgICAgICAgICAgICAgICAgICBsYXN0UmFuRGF0ZSA9IERhdGUubm93KClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBkZWxheSAtIChEYXRlLm5vdygpIC0gbGFzdFJhbkRhdGUpKVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7TmVvLmNvcmUuQmFzZX0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kTmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5TZXF1ZW5jZSh0YXJnZXQsIG1ldGhvZE5hbWUsIGZuLCBzY29wZSkge1xuICAgIGxldCBjdXJyZW50TWV0aG9kID0gdGFyZ2V0W21ldGhvZE5hbWVdO1xuXG4gICAgaWYgKCFjdXJyZW50TWV0aG9kIHx8ICFjdXJyZW50TWV0aG9kW3NlcXVlbmNlZEZuc1N5bWJvbF0pIHtcbiAgICAgICAgcmV0dXJuIC8vIE5vdCBhIHNlcXVlbmNlZCBtZXRob2RcbiAgICB9XG5cbiAgICBjb25zdCBzZXF1ZW5jZWRGdW5jdGlvbnMgPSBjdXJyZW50TWV0aG9kW3NlcXVlbmNlZEZuc1N5bWJvbF07XG5cbiAgICAvLyBGaWx0ZXIgb3V0IHRoZSBmdW5jdGlvbiB0byB1bnNlcXVlbmNlXG4gICAgY3VycmVudE1ldGhvZFtzZXF1ZW5jZWRGbnNTeW1ib2xdID0gc2VxdWVuY2VkRnVuY3Rpb25zLmZpbHRlcihzZXFGbiA9PlxuICAgICAgICAhKHNlcUZuLmZuID09PSBmbiAmJiBzZXFGbi5zY29wZSA9PT0gc2NvcGUpXG4gICAgKTtcblxuICAgIGlmIChjdXJyZW50TWV0aG9kW3NlcXVlbmNlZEZuc1N5bWJvbF0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIElmIG5vIGZ1bmN0aW9ucyBsZWZ0LCByZXN0b3JlIHRoZSBvcmlnaW5hbCBtZXRob2RcbiAgICAgICAgdGFyZ2V0W21ldGhvZE5hbWVdID0gY3VycmVudE1ldGhvZFtvcmlnaW5hbE1ldGhvZFN5bWJvbF1cbiAgICB9XG59XG4iLCJpbXBvcnQgQmFzZSAgICAgICBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBPYnNlcnZhYmxlIGZyb20gJy4uL2NvcmUvT2JzZXJ2YWJsZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8udXRpbC5IYXNoSGlzdG9yeVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICogQG1peGVzIE5lby5jb3JlLk9ic2VydmFibGVcbiAqIEBzaW5nbGV0b25cbiAqL1xuY2xhc3MgSGFzaEhpc3RvcnkgZXh0ZW5kcyBCYXNlIHtcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBvYnNlcnZhYmxlPXRydWVcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIG9ic2VydmFibGUgPSB0cnVlXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby51dGlsLkhhc2hIaXN0b3J5J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8udXRpbC5IYXNoSGlzdG9yeScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaW5nbGV0b249dHJ1ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzaW5nbGV0b246IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IG1heEl0ZW1zPTUwXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG1heEl0ZW1zOiA1MCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3Jpbmcgb25lIHN0YWNrIHBlciB3aW5kb3dJZFxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHN0YWNrcz17fVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzdGFja3M6IHt9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3dpbmRvd0lkXVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZmlyc3Qod2luZG93SWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXQoMCwgd2luZG93SWQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFt3aW5kb3dJZF1cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldEF0KGluZGV4LCB3aW5kb3dJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGFjayh3aW5kb3dJZClbaW5kZXhdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFt3aW5kb3dJZF1cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldENvdW50KHdpbmRvd0lkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0YWNrKHdpbmRvd0lkKS5sZW5ndGhcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3dpbmRvd0lkXVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0U3RhY2sod2luZG93SWQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtzdGFja3N9ID0gbWUsXG4gICAgICAgICAgICBzdGFja0lkICA9IHdpbmRvd0lkIHx8IE9iamVjdC5rZXlzKHN0YWNrcylbMF0sXG4gICAgICAgICAgICBzdGFjayAgICA9IHN0YWNrc1tzdGFja0lkXTtcblxuICAgICAgICBpZiAoIXN0YWNrKSB7XG4gICAgICAgICAgICBzdGFja3Nbc3RhY2tJZF0gPSBzdGFjayA9IFtdXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RhY2tcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmFwcE5hbWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YS5oYXNoXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuaGFzaFN0cmluZ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLndpbmRvd0lkXG4gICAgICovXG4gICAgcHVzaChkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt3aW5kb3dJZH0gPSBkYXRhLFxuICAgICAgICAgICAgc3RhY2sgICAgICA9IG1lLmdldFN0YWNrKHdpbmRvd0lkKTtcblxuICAgICAgICBpZiAoc3RhY2tbMF0/Lmhhc2hTdHJpbmcgIT09IGRhdGEuaGFzaFN0cmluZykge1xuICAgICAgICAgICAgZGVsZXRlIGRhdGFbd2luZG93SWRdO1xuICAgICAgICAgICAgc3RhY2sudW5zaGlmdChkYXRhKTtcblxuICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IG1lLm1heEl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgc3RhY2sucG9wKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUuZmlyZSgnY2hhbmdlJywgZGF0YSwgc3RhY2tbMV0gfHwgbnVsbClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIHNob3J0Y3V0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFt3aW5kb3dJZF1cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHNlY29uZCh3aW5kb3dJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBdCgwLCB3aW5kb3dJZClcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEhhc2hIaXN0b3J5KTtcbiIsImltcG9ydCBCYXNlIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8udXRpbC5Mb2dnZXJcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqIEBzaW5nbGV0b25cbiAqL1xuY2xhc3MgTG9nZ2VyIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8udXRpbC5Mb2dnZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby51dGlsLkxvZ2dlcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIG1pbmltdW0gbGV2ZWwsIHdoaWNoIHlvdSB3YW50IHRvIG91dHB1dC5cbiAgICAgICAgICogQ2hhbmdlIHRoaXMgYXQgYW55IHRpbWUgdXNpbmcgYSB2YWx1ZSBvZiBsb2dMZXZlbHM6IFsnaW5mbycsICdsb2cnLCAnd2FybicsICdlcnJvciddXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICBOZW8udXRpbC5Mb2dnZXIubGV2ZWwgPSAnZXJyb3InXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbGV2ZWw9J2luZm8nXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGxldmVsXzogJ2luZm8nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZW5hYmxlTG9ncz10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZXRvbjogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gbG9nQ2hhclxuICAgICAqL1xuICAgIGxvZ0NoYXJzICA9IHtcbiAgICAgICAgZXJyb3I6ICdFJyxcbiAgICAgICAgaW5mbyA6ICdJJyxcbiAgICAgICAgbG9nICA6ICdMJyxcbiAgICAgICAgd2FybiA6ICdXJ1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGNvbG9yc1xuICAgICAqL1xuICAgIGxvZ0NvbG9ycyA9IHtcbiAgICAgICAgZXJyb3I6ICdpbmRpYW5yZWQnLFxuICAgICAgICBpbmZvIDogJyNhY2FjYWMnLFxuICAgICAgICBsb2cgIDogJyM0NDg4ODgnLFxuICAgICAgICB3YXJuIDogJyM2ZDZkMDAnXG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZ0xldmVsc1xuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBsb2dMZXZlbHNcbiAgICAgKi9cbiAgICBsb2dMZXZlbHMgPSBbJ2luZm8nLCAnbG9nJywgJ3dhcm4nLCAnZXJyb3InXVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvLyBhbGlhc2VzXG4gICAgICAgIE5lby5hcHBseUZyb21OcyhOZW8sIG1lLCB7XG4gICAgICAgICAgICBlcnJvciAgIDogJ2Vycm9yJyxcbiAgICAgICAgICAgIGluZm8gICAgOiAnaW5mbycsXG4gICAgICAgICAgICBsb2cgICAgIDogJ2xvZycsXG4gICAgICAgICAgICBsb2dFcnJvcjogJ2xvZ0Vycm9yJyxcbiAgICAgICAgICAgIHdhcm4gICAgOiAnd2FybidcbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgbWUudGltZW91dCg1MCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIU5lby5jb25maWcuZW5hYmxlTG9nc0luUHJvZHVjdGlvbiAmJiBOZW8uY29uZmlnLmVudmlyb25tZW50ID09PSAnZGlzdC9wcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIG1lLndyaXRlID0gTmVvLmVtcHR5Rm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgbGV2ZWwgdG8gbnVtYmVyIGJhc2VkIG9uIHBvc2l0aW9uIGluIGxvZ0xldmVsc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIGJlZm9yZVNldExldmVsKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2dMZXZlbHMuaW5kZXhPZih2YWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cbiAgICBlcnJvcih2YWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaW50ZXJuYWwgaGVscGVyIHRvIGNhdGNoIGNhbGxlclxuICAgICAqIG5vIGtub3duIG5hdGl2ZSB3YXkgaW4gbW9kZXJuIEpTIHRvIGtub3cgd2hhdCBmaWxlIHRoYXQgdHJpZ2dlcmVkIHRoZSBjdXJyZW50IG1ldGhvZFxuICAgICAqIHRoZXJlZm9yZSB3ZSB1c2UgRXJyb3IsIHdlIGNhbiBnZXQgdGhlIGNhbGxlciBmaWxlIGZyb20gdGhlIHN0YWNrIHRyYWNlIHN0cmluZy5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRDYWxsZXIoKSB7XG4gICAgICAgIGxldCBjYWxsZXJfcGF0aCA9IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGVyciAgICAgICAgID0gbmV3IEVycm9yKCksXG4gICAgICAgICAgICBzdGFja19saW5lcyA9IGVyci5zdGFjay5zcGxpdCgnXFxuJyksXG4gICAgICAgICAgICBmb3VuZF90aGlzICA9IGZhbHNlLFxuICAgICAgICAgICAgaSwgbGluZTtcblxuICAgICAgICBmb3IgKGkgaW4gc3RhY2tfbGluZXMpIHtcbiAgICAgICAgICAgIGxpbmUgPSBzdGFja19saW5lc1tpXTtcblxuICAgICAgICAgICAgaWYgKCFmb3VuZF90aGlzICYmIC9Mb2dnZXJcXC5tanMvLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICBmb3VuZF90aGlzID0gdHJ1ZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChmb3VuZF90aGlzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEvTG9nZ2VyXFwubWpzLy50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgY2xvc2luZyApXG4gICAgICAgICAgICAgICAgICAgIGxpbmUgICAgICAgID0gbGluZS5yZXBsYWNlKCcpJywgJycpO1xuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIHBhcnQgYWZ0ZXIgdGhlIGxhc3QgL1xuICAgICAgICAgICAgICAgICAgICBjYWxsZXJfcGF0aCA9IGxpbmUubWF0Y2goLyhbXlxcL10rKSQvKVsxXS5tYXRjaCgvKFteIF0rKSQvKVsxXTtcblxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjYWxsZXJfcGF0aFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICovXG4gICAgaW5mbyguLi5hcmdzKSB7XG4gICAgICAgIGFyZ3MgPSB0aGlzLnJlc29sdmVBcmdzKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLndyaXRlKGFyZ3MsICdpbmZvJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqL1xuICAgIGxvZyguLi5hcmdzKSB7XG4gICAgICAgIGFyZ3MgPSB0aGlzLnJlc29sdmVBcmdzKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLndyaXRlKGFyZ3MsICdsb2cnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICovXG4gICAgbG9nRXJyb3IoLi4uYXJncykge1xuICAgICAgICBhcmdzID0gdGhpcy5yZXNvbHZlQXJncyguLi5hcmdzKTtcbiAgICAgICAgdGhpcy53cml0ZShhcmdzLCAnZXJyb3InKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Db250ZXh0TWVudShkYXRhKSB7XG4gICAgICAgIGxldCB7Y29uZmlnfSA9IE5lbztcblxuICAgICAgICBpZiAoY29uZmlnLmVuYWJsZUNvbXBvbmVudExvZ2dlciAmJiAhKGNvbmZpZy5lbnYgPT09ICdkaXN0L3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5lbmFibGVMb2dzSW5Qcm9kdWN0aW9uKSkge1xuICAgICAgICAgICAgbGV0IGlzR3JvdXBTZXQgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb21wb25lbnQ7XG5cbiAgICAgICAgICAgIGRhdGEucGF0aC5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudCA9IE5lby5nZXRDb21wb25lbnQoaXRlbS5pZCwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzR3JvdXBTZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzR3JvdXBTZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5ncm91cChpdGVtLmlkKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coY29tcG9uZW50KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpc0dyb3VwU2V0ICYmIGNvbnNvbGUuZ3JvdXBFbmQoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgaGVscGVyIGZvciBhcmdzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJnc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHJlc29sdmVBcmdzKC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IGlkZW50aWZpZXIgPSBhcmdzWzBdLFxuICAgICAgICAgICAgYXJnc09iamVjdCA9IHt9O1xuXG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKE5lby5pc1N0cmluZyhpZGVudGlmaWVyKSkge1xuICAgICAgICAgICAgICAgIGFyZ3NPYmplY3QubXNnID0gYXJnc1swXVxuICAgICAgICAgICAgfSBlbHNlIGlmIChOZW8uaXNPYmplY3QoaWRlbnRpZmllcikpIHtcbiAgICAgICAgICAgICAgICBhcmdzT2JqZWN0ID0gaWRlbnRpZmllclxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgYXJnc09iamVjdC5tc2cgID0gYXJnc1swXTtcbiAgICAgICAgICAgIGFyZ3NPYmplY3QuZGF0YSA9IGFyZ3Muc2xpY2UoMSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhcmdzT2JqZWN0XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICB3YXJuKC4uLmFyZ3MpIHtcbiAgICAgICAgYXJncyA9IHRoaXMucmVzb2x2ZUFyZ3MoLi4uYXJncyk7XG4gICAgICAgIHRoaXMud3JpdGUoYXJncywgJ3dhcm4nKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE91dHB1dCBtZXRob2RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsZXZlbFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB3cml0ZShhcmdzLCBsZXZlbCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5iZWZvcmVTZXRMZXZlbChsZXZlbCkgPCBtZS5sZXZlbCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZygnIycsIGFyZ3MubXNnLCBsZXZlbCk7XG5cbiAgICAgICAgbGV0IGxvZ0NvbG9yID0gbWUubG9nQ29sb3JzW2xldmVsXSxcbiAgICAgICAgICAgIGxvZ0NoYXIgID0gbWUubG9nQ2hhcnNbbGV2ZWxdLFxuICAgICAgICAgICAgYmcgICAgICAgPSBgYmFja2dyb3VuZC1jb2xvcjoke2xvZ0NvbG9yfTsgY29sb3I6IHdoaXRlOyBmb250LXdlaWdodDogOTAwO2AsXG4gICAgICAgICAgICBjb2xvciAgICA9IGBjb2xvcjoke2xvZ0NvbG9yfTtgLFxuICAgICAgICAgICAgbXNnICAgICAgPSBgWyR7bWUuZ2V0Q2FsbGVyKCl9XSAke2FyZ3MubXNnfWA7XG5cbiAgICAgICAgaWYgKGFyZ3MuZGF0YSkge1xuICAgICAgICAgICAgY29uc29sZS5ncm91cENvbGxhcHNlZChgJWMgJHtsb2dDaGFyfSAlYyAke21zZ31gLCBiZywgY29sb3IpXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhhcmdzLmRhdGEpO1xuICAgICAgICAgICAgY29uc29sZS5ncm91cEVuZCgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgJWMgJHtsb2dDaGFyfSAlYyAke21zZ31gLCBiZywgY29sb3IpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKExvZ2dlcik7XG4iLCJpbXBvcnQgQmFzZSAgICAgICAgICAgICBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBDb21wb25lbnRNYW5hZ2VyIGZyb20gJy4uL21hbmFnZXIvQ29tcG9uZW50Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby51dGlsLlZEb21cbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgVkRvbSBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnV0aWwuVkRvbSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnV0aWwuVkRvbSdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmRvbVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVtb3ZlSWRzPXRydWVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBjbG9uZWQgdmRvbVxuICAgICAqL1xuICAgIHN0YXRpYyBjbG9uZSh2ZG9tLCByZW1vdmVJZHM9dHJ1ZSkge1xuICAgICAgICBsZXQgY2xvbmUgPSBOZW8uY2xvbmUodmRvbSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKHJlbW92ZUlkcykge1xuICAgICAgICAgICAgZGVsZXRlIGNsb25lLmlkXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2xvbmUuY24pIHtcbiAgICAgICAgICAgIGNsb25lLmNuLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY2xvbmUuY25baW5kZXhdID0gVkRvbS5jbG9uZShpdGVtLCByZW1vdmVJZHMpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNsb25lXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VhcmNoIHZkb20gY2hpbGQgbm9kZXMgYnkgaWQgb3Igb3B0cyBvYmplY3QgZm9yIGEgZ2l2ZW4gdmRvbSB0cmVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZkb21cbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IG9wdHMgRWl0aGVyIGFuIG9iamVjdCBjb250YWluaW5nIHZkb20gbm9kZSBhdHRyaWJ1dGVzIG9yIGEgc3RyaW5nIGJhc2VkIGlkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSByZXBsYWNlQ29tcG9uZW50UmVmcz10cnVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtpbmRleF0gSW50ZXJuYWwgZmxhZywgZG8gbm90IHVzZSBpdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyZW50Tm9kZV0gSW50ZXJuYWwgZmxhZywgZG8gbm90IHVzZSBpdFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogICAgIHtOdW1iZXJ9IGluZGV4XG4gICAgICogICAgIHtTdHJpbmd9IHBhcmVudElkXG4gICAgICogICAgIHtPYmplY3R9IHZkb21cbiAgICAgKi9cbiAgICBzdGF0aWMgZmluZCh2ZG9tLCBvcHRzLCByZXBsYWNlQ29tcG9uZW50UmVmcz10cnVlLCBpbmRleCwgcGFyZW50Tm9kZSkge1xuICAgICAgICBpbmRleCA9IGluZGV4IHx8IDA7XG4gICAgICAgIG9wdHMgID0gIU5lby5pc1N0cmluZyhvcHRzKSA/IG9wdHMgOiB7aWQ6IG9wdHN9O1xuXG4gICAgICAgIGlmIChyZXBsYWNlQ29tcG9uZW50UmVmcykge1xuICAgICAgICAgICAgdmRvbSA9IFZEb20uZ2V0VmRvbSh2ZG9tKVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNoaWxkICAgICAgPSBudWxsLFxuICAgICAgICAgICAgbWF0Y2hBcnJheSA9IFtdLFxuICAgICAgICAgICAgc3R5bGVNYXRjaCA9IHRydWUsXG4gICAgICAgICAgICBpICAgICAgICAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgICAgICAgPSB2ZG9tLmNuPy5sZW5ndGgsXG4gICAgICAgICAgICBvcHRzQXJyYXkgID0gT2JqZWN0LmVudHJpZXMob3B0cyksXG4gICAgICAgICAgICBvcHRzTGVuZ3RoID0gb3B0c0FycmF5Lmxlbmd0aCxcbiAgICAgICAgICAgIHN1YkNoaWxkO1xuXG4gICAgICAgIG9wdHNBcnJheS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmICh2ZG9tLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjbHMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgTmVvLmlzQXJyYXkodmRvbVtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ZG9tW2tleV0uaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoQXJyYXkucHVzaCh0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmRvbVtrZXldID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ZG9tW2tleV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoQXJyYXkucHVzaCh0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoTmVvLmlzQXJyYXkodmFsdWUpICYmIE5lby5pc0FycmF5KHZkb21ba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0b2RvOiBlaXRoZXIgc2VhcmNoIHRoZSB2ZG9tIGFycmF5IGZvciBhbGwga2V5cyBvciBjb21wYXJlIGlmIHRoZSBhcnJheXMgYXJlIGVxdWFsLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmluZDogY2xzIG1hdGNoaW5nIG5vdCBzdXBwb3J0ZWQgZm9yIHRhcmdldCAmIHNvdXJjZSB0eXBlcyBvZiBBcnJheXMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3R5bGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHZkb21ba2V5XSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmRvbVtrZXldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEFycmF5LnB1c2godHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKE5lby5pc09iamVjdCh2YWx1ZSkgJiYgTmVvLmlzT2JqZWN0KHZkb21ba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZW50cmllcyh2YWx1ZSkuZm9yRWFjaCgoW3N0eWxlS2V5LCBzdHlsZVZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh2ZG9tW2tleV0uaGFzT3duUHJvcGVydHkoc3R5bGVLZXkpICYmIHZkb21ba2V5XVtzdHlsZUtleV0gPT09IHN0eWxlVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZU1hdGNoID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hBcnJheS5wdXNoKHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpbmQ6IHN0eWxlIG1hdGNoaW5nIG5vdCBzdXBwb3J0ZWQgZm9yIG1peGVkIHRhcmdldCAmIHNvdXJjZSB0eXBlcyAoT2JqZWN0IFZTIFN0cmluZyknKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ZG9tW2tleV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hBcnJheS5wdXNoKHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG1hdGNoQXJyYXkubGVuZ3RoID09PSBvcHRzTGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4ge2luZGV4LCBwYXJlbnROb2RlLCB2ZG9tfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZkb20uY24pIHtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodmRvbS5jbltpXSkge1xuICAgICAgICAgICAgICAgICAgICBzdWJDaGlsZCA9IFZEb20uZmluZCh2ZG9tLmNuW2ldLCBvcHRzLCByZXBsYWNlQ29tcG9uZW50UmVmcywgaSwgdmRvbSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YkNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCAgICAgOiBzdWJDaGlsZC5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlOiBzdWJDaGlsZC5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZkb20gICAgICA6IHN1YkNoaWxkLnZkb21cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXQgZm9yIGZpbmQodmRvbSwge2ZsYWc6IGZsYWd9KTtcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmRvbVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmbGFnIFRoZSBmbGFnIHJlZmVyZW5jZSBzcGVjaWZpZWQgb24gdGhlIHRhcmdldCB2ZG9tIGNoaWxkIG5vZGVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB2ZG9tXG4gICAgICovXG4gICAgc3RhdGljIGdldEJ5RmxhZyh2ZG9tLCBmbGFnKSB7XG4gICAgICAgIHJldHVybiBWRG9tLmZpbmQodmRvbSwge2ZsYWd9KT8udmRvbVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaWRzIG9mIGFsbCBjaGlsZCBub2RlcyBvZiB0aGUgZ2l2ZW4gdmRvbSB0cmVlXG4gICAgICogQHBhcmFtIHZkb21cbiAgICAgKiBAcGFyYW0gW2NoaWxkSWRzPVtdXVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gY2hpbGRJZHNcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q2hpbGRJZHModmRvbSwgY2hpbGRJZHM9W10pIHtcbiAgICAgICAgdmRvbSA9IFZEb20uZ2V0VmRvbSh2ZG9tKTtcblxuICAgICAgICBsZXQgY2hpbGROb2RlcyA9IHZkb20/LmNuIHx8IFtdO1xuXG4gICAgICAgIGNoaWxkTm9kZXMuZm9yRWFjaChjaGlsZE5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5pZCkge1xuICAgICAgICAgICAgICAgIGNoaWxkSWRzLnB1c2goY2hpbGROb2RlLmlkKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGlsZElkcyA9IFZEb20uZ2V0Q2hpbGRJZHMoY2hpbGROb2RlLCBjaGlsZElkcylcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkSWRzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZkb21cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgc3RhdGljIGdldENvbHVtbk5vZGVzKHZkb20sIGluZGV4KSB7XG4gICAgICAgIHZkb20gPSBWRG9tLmdldFZkb20odmRvbSk7XG5cbiAgICAgICAgbGV0IGNvbHVtbk5vZGVzID0gW107XG5cbiAgICAgICAgdmRvbS5jbj8uZm9yRWFjaChyb3cgPT4ge1xuICAgICAgICAgICAgaWYgKHJvdy5jbj8uW2luZGV4XSkge1xuICAgICAgICAgICAgICAgIGNvbHVtbk5vZGVzLnB1c2gocm93LmNuW2luZGV4XSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICByZXR1cm4gY29sdW1uTm9kZXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmRvbVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q29sdW1uTm9kZXNJZHModmRvbSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIFZEb20uZ2V0Q29sdW1uTm9kZXModmRvbSwgaW5kZXgpLm1hcChlID0+IGUuaWQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZkb21cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmxhZ1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IFttYXRjaEFycmF5XVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gYW4gYXJyYXkgb2YgdmRvbSBub2RlcyB3aGljaCBtYXRjaCB0aGUgZmxhZ1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXRGbGFncyh2ZG9tLCBmbGFnLCBtYXRjaEFycmF5KSB7XG4gICAgICAgIHZkb20gPSBWRG9tLmdldFZkb20odmRvbSk7XG5cbiAgICAgICAgaWYgKCFtYXRjaEFycmF5KSB7XG4gICAgICAgICAgICBtYXRjaEFycmF5ID0gW107XG5cbiAgICAgICAgICAgIGlmICh2ZG9tLmZsYWcgPT09IGZsYWcpIHtcbiAgICAgICAgICAgICAgICBtYXRjaEFycmF5LnB1c2godmRvbSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICh2ZG9tPy5jbiB8fCBbXSkuZm9yRWFjaChjaGlsZE5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5mbGFnID09PSBmbGFnKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hBcnJheS5wdXNoKGNoaWxkTm9kZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWF0Y2hBcnJheSA9IFZEb20uZ2V0RmxhZ3MoY2hpbGROb2RlLCBmbGFnLCBtYXRjaEFycmF5KVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbWF0Y2hBcnJheVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2ZG9tXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB0b3BMZXZlbD10cnVlIEludGVybmFsIGZsYWcsIGRvIG5vdCB1c2UgaXRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgc3RhdGljIGdldFBhcmVudE5vZGVzKHZkb20sIGlkLCB0b3BMZXZlbD10cnVlKSB7XG4gICAgICAgIHZkb20gPSBWRG9tLmdldFZkb20odmRvbSk7XG5cbiAgICAgICAgbGV0IHBhcmVudHMgPSBudWxsLFxuICAgICAgICAgICAgaSAgICAgICA9IDAsXG4gICAgICAgICAgICBsZW4gICAgID0gdmRvbS5jbj8ubGVuZ3RoIHx8IDA7XG5cbiAgICAgICAgaWYgKHZkb20uaWQgPT09IGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gW11cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHBhcmVudHMgPSBWRG9tLmdldFBhcmVudE5vZGVzKHZkb20uY25baV0sIGlkLCBmYWxzZSk7XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnRzKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50cy5wdXNoKHZkb20uY25baV0pO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9wTGV2ZWwgJiYgcGFyZW50cykge1xuICAgICAgICAgICAgcGFyZW50cy5wdXNoKHZkb20pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyZW50c1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIHNob3J0Y3V0IHVzaW5nIG1hbmFnZXIuQ29tcG9uZW50IHRvIHJlcGxhY2UgdmRvbSByZWZlcmVuY2VzIGlmIG5lZWRlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2ZG9tXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0VmRvbSh2ZG9tKSB7XG4gICAgICAgIGlmICh2ZG9tLmNvbXBvbmVudElkKSB7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSBDb21wb25lbnRNYW5hZ2VyLmdldCh2ZG9tLmNvbXBvbmVudElkKTtcblxuICAgICAgICAgICAgaWYgKCFjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHV0aWwuVkRvbS5nZXRWZG9tOiBDb21wb25lbnQgbm90IGZvdW5kIGZvciBpZDogJHt2ZG9tLmNvbXBvbmVudElkfWApXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZkb20gPSBjb21wb25lbnQudmRvbVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZkb21cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnQgYSBnaXZlbiBub2RlVG9JbnNlcnQgYWZ0ZXIgYSB0YXJnZXROb2RlIGluc2lkZSBhIGdpdmVuIHZkb20gdHJlZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2ZG9tIFRoZSB2ZG9tIHRyZWUgY29udGFpbmluZyB0aGUgdGFyZ2V0Tm9kZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlVG9JbnNlcnQgVGhlIG5ldyB2ZG9tIHRvIGluc2VydFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gdGFyZ2V0Tm9kZUlkIEVpdGhlciBhIHZkb20gbm9kZSBvciBhIHZkb20gbm9kZSBpZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpbnNlcnRBZnRlck5vZGUodmRvbSwgbm9kZVRvSW5zZXJ0LCB0YXJnZXROb2RlSWQpIHtcbiAgICAgICAgcmV0dXJuIFZEb20uaW5zZXJ0Tm9kZSh2ZG9tLCBub2RlVG9JbnNlcnQsIHRhcmdldE5vZGVJZCwgZmFsc2UpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGEgZ2l2ZW4gbm9kZVRvSW5zZXJ0IGJlZm9yZSBhIHRhcmdldE5vZGUgaW5zaWRlIGEgZ2l2ZW4gdmRvbSB0cmVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZkb20gVGhlIHZkb20gdHJlZSBjb250YWluaW5nIHRoZSB0YXJnZXROb2RlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGVUb0luc2VydCBUaGUgbmV3IHZkb20gdG8gaW5zZXJ0XG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSB0YXJnZXROb2RlSWQgRWl0aGVyIGEgdmRvbSBub2RlIG9yIGEgdmRvbSBub2RlIGlkXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGluc2VydEJlZm9yZU5vZGUodmRvbSwgbm9kZVRvSW5zZXJ0LCB0YXJnZXROb2RlSWQpIHtcbiAgICAgICAgcmV0dXJuIFZEb20uaW5zZXJ0Tm9kZSh2ZG9tLCBub2RlVG9JbnNlcnQsIHRhcmdldE5vZGVJZCwgdHJ1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnQgYSBnaXZlbiBub2RlVG9JbnNlcnQgYmVmb3JlIGEgdGFyZ2V0Tm9kZSBpbnNpZGUgYSBnaXZlbiB2ZG9tIHRyZWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmRvbSBUaGUgdmRvbSB0cmVlIGNvbnRhaW5pbmcgdGhlIHRhcmdldE5vZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVRvSW5zZXJ0IFRoZSBuZXcgdmRvbSB0byBpbnNlcnRcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHRhcmdldE5vZGVJZCBFaXRoZXIgYSB2ZG9tIG5vZGUgb3IgYSB2ZG9tIG5vZGUgaWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGluc2VydEJlZm9yZSB0cnVlIGluc2VydHMgdGhlIG5ldyBub2RlIGF0IHRoZSBzYW1lIGluZGV4LCBpbmRleCsxIG90aGVyd2lzZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpbnNlcnROb2RlKHZkb20sIG5vZGVUb0luc2VydCwgdGFyZ2V0Tm9kZUlkLCBpbnNlcnRCZWZvcmUpIHtcbiAgICAgICAgaWYgKE5lby5pc09iamVjdCh0YXJnZXROb2RlSWQpKSB7XG4gICAgICAgICAgICB0YXJnZXROb2RlSWQgPSB0YXJnZXROb2RlSWQuaWRcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0YXJnZXROb2RlID0gVkRvbS5maW5kKHZkb20sIHRhcmdldE5vZGVJZCksXG4gICAgICAgICAgICBpbmRleDtcblxuICAgICAgICBpZiAodGFyZ2V0Tm9kZSkge1xuICAgICAgICAgICAgaW5kZXggPSBpbnNlcnRCZWZvcmUgPyB0YXJnZXROb2RlLmluZGV4IDogdGFyZ2V0Tm9kZS5pbmRleCArIDE7XG4gICAgICAgICAgICB0YXJnZXROb2RlLnBhcmVudE5vZGUuY24uc3BsaWNlKGluZGV4LCAwLCBub2RlVG9JbnNlcnQpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlYXJjaCB2ZG9tIGNoaWxkIG5vZGVzIGJ5IGlkIG9yIG9wdHMgb2JqZWN0IGZvciBhIGdpdmVuIHZkb20gdHJlZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbdmRvbV1cbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IG9wdHMgRWl0aGVyIGFuIG9iamVjdCBjb250YWluaW5nIHZkb20gbm9kZSBhdHRyaWJ1dGVzIG9yIGEgc3RyaW5nIGJhc2VkIGlkXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaW4gY2FzZSB0aGUgbm9kZSB3YXMgZm91bmQgJiByZW1vdmVkXG4gICAgICovXG4gICAgc3RhdGljIHJlbW92ZVZkb21DaGlsZCh2ZG9tLCBvcHRzKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IFZEb20uZmluZCh2ZG9tLCBvcHRzKTtcblxuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudE5vZGUuY24uc3BsaWNlKGNoaWxkLmluZGV4LCAxKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBhIGNoaWxkIG5vZGUgaW5zaWRlIGEgdmRvbSB0cmVlIGJ5IGEgZ2l2ZW4gaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmRvbVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdDaGlsZE5vZGVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpbiBjYXNlIHRoZSBub2RlIHdhcyBmb3VuZCBhbmQgcmVwbGFjZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgcmVwbGFjZVZkb21DaGlsZCh2ZG9tLCBpZCwgbmV3Q2hpbGROb2RlKSB7XG4gICAgICAgIHZkb20gPSBWRG9tLmdldFZkb20odmRvbSk7XG5cbiAgICAgICAgbGV0IGNuICA9IHZkb20uY24gfHwgW10sXG4gICAgICAgICAgICBpICAgPSAwLFxuICAgICAgICAgICAgbGVuID0gY24ubGVuZ3RoLFxuICAgICAgICAgICAgY2hpbGROb2RlO1xuXG4gICAgICAgIGlmICh2ZG9tLmlkID09PSBpZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXBsYWNlVmRvbUNoaWxkOiB0YXJnZXQgaWQgbWF0Y2hlcyB0aGUgcm9vdCB2bm9kZSBpZDogJyArIGlkKVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY2hpbGROb2RlID0gY25baV07XG5cbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGUuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgY25baV0gPSBuZXdDaGlsZE5vZGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFZEb20ucmVwbGFjZVZkb21DaGlsZChjaGlsZE5vZGUsIGlkLCBuZXdDaGlsZE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOZW8udmRvbS5IZWxwZXIgd2lsbCBjcmVhdGUgaWRzIGZvciBlYWNoIHZub2RlIHdoaWNoIGRvZXMgbm90IGFscmVhZHkgaGF2ZSBvbmUsXG4gICAgICogc28gd2UgbmVlZCB0byBzeW5jIHRoZW0gaW50byB0aGUgdmRvbS5cbiAgICAgKiBAcGFyYW0ge05lby52ZG9tLlZOb2RlfSB2bm9kZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2ZG9tXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBmb3JjZT1mYWxzZSBUaGUgZm9yY2UgcGFyYW0gd2lsbCBlbmZvcmNlIG92ZXJ3cml0aW5nIGRpZmZlcmVudCBpZHNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3luY1Zkb21JZHModm5vZGUsIHZkb20sIGZvcmNlPWZhbHNlKSB7XG4gICAgICAgIGlmICh2bm9kZSAmJiB2ZG9tKSB7XG4gICAgICAgICAgICB2ZG9tID0gVkRvbS5nZXRWZG9tKHZkb20pO1xuXG4gICAgICAgICAgICBsZXQgY2hpbGROb2RlcyA9IHZkb20uY24sXG4gICAgICAgICAgICAgICAgY24sIGksIGxlbjtcblxuICAgICAgICAgICAgaWYgKGZvcmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZub2RlLmlkICYmIHZkb20uaWQgIT09IHZub2RlLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZkb20uaWQgPSB2bm9kZS5pZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gV2Ugb25seSB3YW50IHRvIGFkZCBhbiBJRCBpZiB0aGUgdmRvbSBub2RlIGRvZXMgbm90IGFscmVhZHkgaGF2ZSBvbmUuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBwcmVzZXJ2ZXMgZGV2ZWxvcGVyLXByb3ZpZGVkIElEcyB3aGlsZSBhbGxvd2luZyB0aGUgZnJhbWV3b3JrXG4gICAgICAgICAgICAgICAgLy8gdG8gYXNzaWduIElEcyB0byBub2RlcyB0aGF0IG5lZWQgdGhlbSBmb3IgcmVjb25jaWxpYXRpb24uXG4gICAgICAgICAgICAgICAgLy8gQWxzbyB0aGluayBvZiBhZGRpbmcgYW5kIHJlbW92aW5nIG5vZGVzIGluIHBhcmFsbGVsLlxuICAgICAgICAgICAgICAgIGlmICh2bm9kZS5pZCAmJiAoIXZkb20uaWQgfHwgdmRvbS5pZC5zdGFydHNXaXRoKCduZW8tdm5vZGUtJykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZkb20uaWQgPSB2bm9kZS5pZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZXMpIHtcbiAgICAgICAgICAgICAgICBjbiAgPSBjaGlsZE5vZGVzLm1hcChpdGVtID0+IFZEb20uZ2V0VmRvbShpdGVtKSk7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHZub2RlLmNoaWxkTm9kZXMgYXJyYXkgaXMgYWxyZWFkeSBmaWx0ZXJlZCBieSB0aGUgd29ya2VyLlxuICAgICAgICAgICAgICAgIC8vIFdlIG11c3QgZmlsdGVyIHRoZSBjb21wb25lbnQncyB2ZG9tLmNuIGFycmF5IGlkZW50aWNhbGx5IHRvIGVuc3VyZVxuICAgICAgICAgICAgICAgIC8vIGJvdGggYXJyYXlzIGFyZSBzdHJ1Y3R1cmFsbHkgYWxpZ25lZCBmb3IgdGhlIHN5bmMgbG9vcC5cbiAgICAgICAgICAgICAgICAvLyBUaGUgYm9vbGVhbiBjaGVjayBgaXRlbSAmJmAgaXMgY3JpdGljYWwgdG8gcmVtb3ZlIGZhbHN5IHZhbHVlc1xuICAgICAgICAgICAgICAgIC8vIGZyb20gY29uZGl0aW9uYWwgcmVuZGVyaW5nIGFuZCBwcmV2ZW50IHJ1bnRpbWUgZXJyb3JzLlxuICAgICAgICAgICAgICAgIGNuICA9IGNuLmZpbHRlcihpdGVtID0+IGl0ZW0gJiYgaXRlbS5yZW1vdmVEb20gIT09IHRydWUpO1xuICAgICAgICAgICAgICAgIGkgICA9IDA7XG4gICAgICAgICAgICAgICAgbGVuID0gY24/Lmxlbmd0aCB8fCAwO1xuXG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodm5vZGUuY2hpbGROb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgVkRvbS5zeW5jVmRvbUlkcyh2bm9kZS5jaGlsZE5vZGVzW2ldLCBjbltpXSwgZm9yY2UpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFZEb20pO1xuIiwiaW1wb3J0IEJhc2UgICAgICAgICAgICAgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQgQ29tcG9uZW50TWFuYWdlciBmcm9tICcuLi9tYW5hZ2VyL0NvbXBvbmVudC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8udXRpbC5WTm9kZVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBWTm9kZSBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnV0aWwuVk5vZGUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby51dGlsLlZOb2RlJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlYXJjaCB2bm9kZSBjaGlsZCBub2RlcyBieSBpZCBvciBvcHRzIG9iamVjdCBmb3IgYSBnaXZlbiB2ZG9tIHRyZWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdm5vZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IG9wdHMgRWl0aGVyIGFuIG9iamVjdCBjb250YWluaW5nIHZkb20gbm9kZSBhdHRyaWJ1dGVzIG9yIGEgc3RyaW5nIGJhc2VkIGlkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtpbmRleF0gSW50ZXJuYWwgZmxhZywgZG8gbm90IHVzZSBpdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyZW50Tm9kZV0gSW50ZXJuYWwgZmxhZywgZG8gbm90IHVzZSBpdFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogICAgIHtOdW1iZXJ9IGluZGV4XG4gICAgICogICAgIHtTdHJpbmd9IHBhcmVudElkXG4gICAgICogICAgIHtPYmplY3R9IHZub2RlXG4gICAgICovXG4gICAgc3RhdGljIGZpbmQodm5vZGUsIG9wdHMsIGluZGV4LCBwYXJlbnROb2RlKSB7XG4gICAgICAgIHZub2RlID0gVk5vZGUuZ2V0Vm5vZGUodm5vZGUpO1xuXG4gICAgICAgIGluZGV4ID0gaW5kZXggfHwgMDtcbiAgICAgICAgb3B0cyAgPSB0eXBlb2Ygb3B0cyAhPT0gJ3N0cmluZycgPyBvcHRzIDoge2lkOiBvcHRzfTtcblxuICAgICAgICBsZXQgYXR0ck1hdGNoICA9IHRydWUsXG4gICAgICAgICAgICBtYXRjaEFycmF5ID0gW10sXG4gICAgICAgICAgICBzdHlsZU1hdGNoID0gdHJ1ZSxcbiAgICAgICAgICAgIGkgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgbGVuICAgICAgICA9IHZub2RlLmNoaWxkTm9kZXM/Lmxlbmd0aCB8fCAwLFxuICAgICAgICAgICAgb3B0c0FycmF5LCBvcHRzTGVuZ3RoLCBzdWJDaGlsZDtcblxuICAgICAgICBvcHRzQXJyYXkgID0gT2JqZWN0LmVudHJpZXMob3B0cyk7XG4gICAgICAgIG9wdHNMZW5ndGggPSBvcHRzQXJyYXkubGVuZ3RoO1xuXG4gICAgICAgIG9wdHNBcnJheS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmICh2bm9kZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYXR0cmlidXRlcyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KHZhbHVlKSAmJiBOZW8uaXNPYmplY3Qodm5vZGVba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZW50cmllcyh2YWx1ZSkuZm9yRWFjaCgoW2F0dHJLZXksIGF0dHJWYWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodm5vZGVba2V5XS5oYXNPd25Qcm9wZXJ0eShhdHRyS2V5KSAmJiB2bm9kZVtrZXldW2F0dHJLZXldID09PSBhdHRyVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyTWF0Y2ggPSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ck1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoQXJyYXkucHVzaCh0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NsYXNzTmFtZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiBOZW8uaXNBcnJheSh2bm9kZVtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2bm9kZVtrZXldLmluY2x1ZGVzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEFycmF5LnB1c2godHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHZub2RlW2tleV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZub2RlW2tleV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoQXJyYXkucHVzaCh0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoTmVvLmlzQXJyYXkodmFsdWUpICYmIE5lby5pc0FycmF5KHZub2RlW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG9kbzogZWl0aGVyIHNlYXJjaCB0aGUgdm5vZGUgYXJyYXkgZm9yIGFsbCBrZXlzIG9yIGNvbXBhcmUgaWYgdGhlIGFycmF5cyBhcmUgZXF1YWwuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaW5kOiBjbHMgbWF0Y2hpbmcgbm90IHN1cHBvcnRlZCBmb3IgdGFyZ2V0ICYgc291cmNlIHR5cGVzIG9mIEFycmF5cycpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzdHlsZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KHZhbHVlKSAmJiBOZW8uaXNPYmplY3Qodm5vZGVba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZW50cmllcyh2YWx1ZSkuZm9yRWFjaCgoW3N0eWxlS2V5LCBzdHlsZVZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh2bm9kZVtrZXldLmhhc093blByb3BlcnR5KHN0eWxlS2V5KSAmJiB2bm9kZVtrZXldW3N0eWxlS2V5XSA9PT0gc3R5bGVWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlTWF0Y2ggPSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEFycmF5LnB1c2godHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZub2RlW2tleV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hBcnJheS5wdXNoKHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG1hdGNoQXJyYXkubGVuZ3RoID09PSBvcHRzTGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4ge2luZGV4LCBwYXJlbnROb2RlLCB2bm9kZX1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHN1YkNoaWxkID0gVk5vZGUuZmluZCh2bm9kZS5jaGlsZE5vZGVzW2ldLCBvcHRzLCBpLCB2bm9kZSk7XG5cbiAgICAgICAgICAgIGlmIChzdWJDaGlsZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWJDaGlsZFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyBhIGNoaWxkIHZub2RlIGluc2lkZSBhIHZub2RlIHRyZWUgYnkgYSBnaXZlbiBpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2bm9kZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IGlkXG4gICAgICogQHJldHVybnMge09iamVjdHxudWxsfSBjaGlsZCB2bm9kZSBvciBudWxsXG4gICAgICovXG4gICAgc3RhdGljIGdldEJ5SWQodm5vZGUsIGlkKSB7XG4gICAgICAgIHZub2RlID0gVk5vZGUuZ2V0Vm5vZGUodm5vZGUpO1xuXG4gICAgICAgIGxldCBjaGlsZE5vZGVzID0gdm5vZGUuY2hpbGROb2RlcyB8fCBbXSxcbiAgICAgICAgICAgIGkgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgbGVuICAgICAgICA9IGNoaWxkTm9kZXMubGVuZ3RoLFxuICAgICAgICAgICAgY2hpbGROb2RlO1xuXG4gICAgICAgIGlmICh2bm9kZS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgIHJldHVybiB2bm9kZVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY2hpbGROb2RlID0gVk5vZGUuZ2V0Vm5vZGUoY2hpbGROb2Rlc1tpXSk7XG5cbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGUuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkTm9kZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGlsZE5vZGUgPSBWTm9kZS5nZXRCeUlkKGNoaWxkTm9kZSwgaWQpO1xuXG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkTm9kZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGlkcyBvZiBhbGwgY2hpbGQgbm9kZXMgb2YgdGhlIGdpdmVuIHZub2RlLCBleGNsdWRpbmcgY29tcG9uZW50IHJlZmVyZW5jZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdm5vZGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBjaGlsZElkcz1bXVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmdbXX0gY2hpbGRJZHNcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q2hpbGRJZHModm5vZGUsIGNoaWxkSWRzPVtdKSB7XG4gICAgICAgIHZub2RlPy5jaGlsZE5vZGVzPy5mb3JFYWNoKGNoaWxkTm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlLmlkICYmICFjaGlsZE5vZGUuY29tcG9uZW50SWQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZElkcy5wdXNoKGNoaWxkTm9kZS5pZClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgVk5vZGUuZ2V0Q2hpbGRJZHMoY2hpbGROb2RlLCBjaGlsZElkcylcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkSWRzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXQgdXNpbmcgbWFuYWdlci5Db21wb25lbnQgdG8gcmVwbGFjZSB2bm9kZSByZWZlcmVuY2VzIGlmIG5lZWRlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2bm9kZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgc3RhdGljIGdldFZub2RlKHZub2RlKSB7XG4gICAgICAgIGlmICh2bm9kZS5jb21wb25lbnRJZCkge1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gQ29tcG9uZW50TWFuYWdlci5nZXQodm5vZGUuY29tcG9uZW50SWQpO1xuXG4gICAgICAgICAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRpbC5WTm9kZS5nZXRWbm9kZTogQ29tcG9uZW50IG5vdCBmb3VuZCBmb3IgaWQ6ICR7dm5vZGUuY29tcG9uZW50SWR9YClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdm5vZGUgPSBjb21wb25lbnQudm5vZGVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2bm9kZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBjaGlsZCB2bm9kZSBpbnNpZGUgYSB2bm9kZSB0cmVlIGJ5IGEgZ2l2ZW4gaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdm5vZGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpbiBjYXNlIHRoZSBub2RlIHdhcyBmb3VuZCBhbmQgcmVtb3ZlZFxuICAgICAqL1xuICAgIHN0YXRpYyByZW1vdmVDaGlsZFZub2RlKHZub2RlLCBpZCkge1xuICAgICAgICB2bm9kZSA9IFZOb2RlLmdldFZub2RlKHZub2RlKTtcblxuICAgICAgICBsZXQgY2hpbGROb2RlcyA9IHZub2RlLmNoaWxkTm9kZXMgfHwgW10sXG4gICAgICAgICAgICBpICAgICAgICAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgICAgICAgPSBjaGlsZE5vZGVzLmxlbmd0aCxcbiAgICAgICAgICAgIGNoaWxkTm9kZTtcblxuICAgICAgICBpZiAodm5vZGUuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlbW92ZUNoaWxkVm5vZGU6IHRhcmdldCBpZCBtYXRjaGVzIHRoZSByb290IHZub2RlIGlkOiAnICsgaWQpXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjaGlsZE5vZGUgPSBWTm9kZS5nZXRWbm9kZShjaGlsZE5vZGVzW2ldKTtcblxuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoVk5vZGUucmVtb3ZlQ2hpbGRWbm9kZShjaGlsZE5vZGUsIGlkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBhIGNoaWxkIHZub2RlIGluc2lkZSBhIHZub2RlIHRyZWUgYnkgYSBnaXZlbiBpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2bm9kZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdDaGlsZFZub2RlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaW4gY2FzZSB0aGUgbm9kZSB3YXMgZm91bmQgYW5kIHJlcGxhY2VkXG4gICAgICovXG4gICAgc3RhdGljIHJlcGxhY2VDaGlsZFZub2RlKHZub2RlLCBpZCwgbmV3Q2hpbGRWbm9kZSkge1xuICAgICAgICB2bm9kZSA9IFZOb2RlLmdldFZub2RlKHZub2RlKTtcblxuICAgICAgICBsZXQgY2hpbGROb2RlcyA9IHZub2RlLmNoaWxkTm9kZXMgfHwgW10sXG4gICAgICAgICAgICBpICAgICAgICAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgICAgICAgPSBjaGlsZE5vZGVzLmxlbmd0aCxcbiAgICAgICAgICAgIGNoaWxkTm9kZTtcblxuICAgICAgICBpZiAodm5vZGUuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcGxhY2VDaGlsZFZub2RlOiB0YXJnZXQgaWQgbWF0Y2hlcyB0aGUgcm9vdCB2bm9kZSBpZDogJyArIGlkKVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY2hpbGROb2RlID0gVk5vZGUuZ2V0Vm5vZGUoY2hpbGROb2Rlc1tpXSk7XG5cbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGUuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgY2hpbGROb2Rlc1tpXSA9IG5ld0NoaWxkVm5vZGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFZOb2RlLnJlcGxhY2VDaGlsZFZub2RlKGNoaWxkTm9kZSwgaWQsIG5ld0NoaWxkVm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVk5vZGUpO1xuIiwiaW1wb3J0IEJhc2UgICAgICAgICAgICAgICAgICBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCAqIGFzIGNvcmUgICAgICAgICAgICAgZnJvbSAnLi4vY29yZS9fZXhwb3J0Lm1qcyc7XG5pbXBvcnQgT2JzZXJ2YWJsZSAgICAgICAgICAgIGZyb20gJy4uL2NvcmUvT2JzZXJ2YWJsZS5tanMnO1xuaW1wb3J0IENsYXNzSGllcmFyY2h5TWFuYWdlciBmcm9tICcuLi9tYW5hZ2VyL0NsYXNzSGllcmFyY2h5Lm1qcyc7XG5pbXBvcnQgTWVzc2FnZSAgICAgICAgICAgICAgIGZyb20gJy4vTWVzc2FnZS5tanMnO1xuaW1wb3J0IFJlbW90ZU1ldGhvZEFjY2VzcyAgICBmcm9tICcuL21peGluL1JlbW90ZU1ldGhvZEFjY2Vzcy5tanMnO1xuXG4vKipcbiAqIFRoZSBhYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBlLmcuIHRoZSBBcHAsIERhdGEgJiBWRG9tIHdvcmtlclxuICogQGNsYXNzIE5lby53b3JrZXIuQmFzZVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICogQG1peGVzIE5lby5jb3JlLk9ic2VydmFibGVcbiAqIEBtaXhlcyBOZW8ud29ya2VyLm1peGluLlJlbW90ZU1ldGhvZEFjY2Vzc1xuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIFdvcmtlciBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLndvcmtlci5CYXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ud29ya2VyLkJhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW118TmVvLmNvcmUuQmFzZVtdfG51bGx9IG1peGlucz1bT2JzZXJ2YWJsZSxSZW1vdGVNZXRob2RBY2Nlc3NdXG4gICAgICAgICAqL1xuICAgICAgICBtaXhpbnM6IFtPYnNlcnZhYmxlLCBSZW1vdGVNZXRob2RBY2Nlc3NdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGNoYW5uZWxQb3J0cz1udWxsXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNoYW5uZWxQb3J0cyA9IG51bGxcbiAgICAvKipcbiAgICAgKiBPbmx5IG5lZWRlZCBmb3IgU2hhcmVkV29ya2Vyc1xuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzQ29ubmVjdGVkPWZhbHNlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGlzQ29ubmVjdGVkID0gZmFsc2VcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc1NoYXJlZFdvcmtlcj1mYWxzZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpc1NoYXJlZFdvcmtlciA9IGZhbHNlXG4gICAgLyoqXG4gICAgICogT25seSBuZWVkZWQgZm9yIFNoYXJlZFdvcmtlcnNcbiAgICAgKiBAbWVtYmVyIHtBcnJheXxudWxsfSBwb3J0cz1udWxsXG4gICAgICovXG4gICAgcG9ydHMgPSBudWxsXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IHdvcmtlcklkPW51bGxcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgd29ya2VySWQgPSBudWxsXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgZ3QgPSBnbG9iYWxUaGlzO1xuXG4gICAgICAgIE9iamVjdC5hc3NpZ24obWUsIHtcbiAgICAgICAgICAgIGNoYW5uZWxQb3J0cyAgOiB7fSxcbiAgICAgICAgICAgIGlzU2hhcmVkV29ya2VyOiBndC50b1N0cmluZygpID09PSAnW29iamVjdCBTaGFyZWRXb3JrZXJHbG9iYWxTY29wZV0nLFxuICAgICAgICAgICAgcG9ydHMgICAgICAgICA6IFtdLFxuICAgICAgICAgICAgcHJvbWlzZXMgICAgICA6IHt9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChtZS5pc1NoYXJlZFdvcmtlcikge1xuICAgICAgICAgICAgZ3Qub25jb25uZWN0ID0gbWUub25Db25uZWN0ZWQuYmluZChtZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGd0Lm9ubWVzc2FnZSA9IG1lLm9uTWVzc2FnZS5iaW5kKG1lKVxuICAgICAgICB9XG5cbiAgICAgICAgTmVvLmN1cnJlbnRXb3JrZXIgICA9IG1lO1xuICAgICAgICBOZW8uc2V0R2xvYmFsQ29uZmlnID0gbWUuc2V0R2xvYmFsQ29uZmlnLmJpbmQobWUpO1xuICAgICAgICBOZW8ud29ya2VySWQgICAgICAgID0gbWUud29ya2VySWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbnRyeSBwb2ludCBmb3IgZGVkaWNhdGVkIGFuZCBzaGFyZWQgd29ya2Vyc1xuICAgICAqL1xuICAgIGFmdGVyQ29ubmVjdCgpIHt9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRQb3J0KG9wdHMpIHtcbiAgICAgICAgbGV0IHJldHVyblBvcnQgPSBudWxsLFxuICAgICAgICAgICAgaGFzTWF0Y2g7XG5cbiAgICAgICAgdGhpcy5wb3J0cy5mb3JFYWNoKHBvcnQgPT4ge1xuICAgICAgICAgICAgaGFzTWF0Y2ggPSB0cnVlO1xuXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhvcHRzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHBvcnRba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBoYXNNYXRjaCA9IGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChoYXNNYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldHVyblBvcnQgPSBwb3J0XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXR1cm5Qb3J0XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT25seSByZWxldmFudCBmb3IgU2hhcmVkV29ya2Vyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgYXN5bmMgb25Db25uZWN0KGRhdGEpIHtcbiAgICAgICAgLy8gc2hvcnQgZGVsYXkgdG8gZW5zdXJlIGFwcCBWQ3MgYXJlIGluIHBsYWNlXG4gICAgICAgIGF3YWl0IHRoaXMudGltZW91dCgxMCk7XG5cbiAgICAgICAgbGV0IHthcHBOYW1lLCB3aW5kb3dJZH0gPSBkYXRhO1xuICAgICAgICB0aGlzLmZpcmUoJ2Nvbm5lY3QnLCB7YXBwTmFtZSwgd2luZG93SWR9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9ubHkgcmVsZXZhbnQgZm9yIFNoYXJlZFdvcmtlcnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZVxuICAgICAqL1xuICAgIG9uQ29ubmVjdGVkKGUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIGlkID0gTmVvLmdldElkKCdwb3J0Jyk7XG5cbiAgICAgICAgbWUuaXNDb25uZWN0ZWQgPSB0cnVlO1xuXG4gICAgICAgIG1lLnBvcnRzLnB1c2goe1xuICAgICAgICAgICAgYXBwTmFtZSA6IG51bGwsXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBvcnQgICAgOiBlLnBvcnRzWzBdLFxuICAgICAgICAgICAgd2luZG93SWQ6IG51bGxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUucG9ydHNbbWUucG9ydHMubGVuZ3RoIC0gMV0ucG9ydC5vbm1lc3NhZ2UgPSBtZS5vbk1lc3NhZ2UuYmluZChtZSk7XG5cbiAgICAgICAgLy8gY29yZS5CYXNlOiBpbml0UmVtb3RlKCkgc3Vic2NyaWJlcyB0byB0aGlzIGV2ZW50IGZvciB0aGUgU2hhcmVkV29ya2VycyBjb250ZXh0XG4gICAgICAgIG1lLmZpcmUoJ2Nvbm5lY3RlZCcpO1xuXG4gICAgICAgIG1lLnNlbmRNZXNzYWdlKCdtYWluJywge2FjdGlvbjogJ3dvcmtlckNvbnN0cnVjdGVkJywgcG9ydDogaWR9KTtcblxuICAgICAgICBtZS5hZnRlckNvbm5lY3QoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25Db25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgc3VwZXIub25Db25zdHJ1Y3RlZCgpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5pc1NoYXJlZFdvcmtlcikge1xuICAgICAgICAgICAgbWUuc2VuZE1lc3NhZ2UoJ21haW4nLCB7YWN0aW9uOiAnd29ya2VyQ29uc3RydWN0ZWQnfSk7XG4gICAgICAgICAgICBtZS5hZnRlckNvbm5lY3QoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT25seSByZWxldmFudCBmb3IgU2hhcmVkV29ya2Vyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25EaXNjb25uZWN0KGRhdGEpIHtcbiAgICAgICAgbGV0IHthcHBOYW1lLCB3aW5kb3dJZH0gPSBkYXRhO1xuICAgICAgICB0aGlzLmZpcmUoJ2Rpc2Nvbm5lY3QnLCB7YXBwTmFtZSwgd2luZG93SWR9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlXG4gICAgICovXG4gICAgb25NZXNzYWdlKGUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtkYXRhfSAgICAgICAgICAgID0gZSxcbiAgICAgICAgICAgIHthY3Rpb24sIHJlcGx5SWR9ID0gZGF0YSxcbiAgICAgICAgICAgIHByb21pc2U7XG5cbiAgICAgICAgaWYgKCFhY3Rpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWVzc2FnZSBhY3Rpb24gaXMgbWlzc2luZzogJyArIGRhdGEuaWQpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWN0aW9uICE9PSAncmVwbHknKSB7XG4gICAgICAgICAgICBtZVsnb24nICsgTmVvLmNhcGl0YWxpemUoYWN0aW9uKV0oZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvbWlzZSA9IGFjdGlvbiA9PT0gJ3JlcGx5JyAmJiBtZS5wcm9taXNlc1tyZXBseUlkXSkge1xuICAgICAgICAgICAgaWYgKGRhdGEucmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5yZWplY3QoZGF0YS5kYXRhKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLnJlc29sdmUoZGF0YS5kYXRhKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWxldGUgbWUucHJvbWlzZXNbcmVwbHlJZF1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtc2dcbiAgICAgKi9cbiAgICBvblBpbmcobXNnKSB7XG4gICAgICAgIHRoaXMucmVzb2x2ZShtc2csIHtvcmlnaW5Nc2c6IG1zZ30pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT25seSByZWxldmFudCBmb3IgU2hhcmVkV29ya2Vyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtc2dcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnLmFwcE5hbWVcbiAgICAgKi9cbiAgICBvblJlZ2lzdGVyQXBwKG1zZykge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHthcHBOYW1lfSA9IG1zZyxcbiAgICAgICAgICAgIHBvcnQ7XG5cbiAgICAgICAgZm9yIChwb3J0IG9mIG1lLnBvcnRzKSB7XG4gICAgICAgICAgICBpZiAoIXBvcnQuYXBwTmFtZSkge1xuICAgICAgICAgICAgICAgIHBvcnQuYXBwTmFtZSA9IGFwcE5hbWU7XG4gICAgICAgICAgICAgICAgbWUub25Db25uZWN0KHthcHBOYW1lLCB3aW5kb3dJZDogcG9ydC53aW5kb3dJZH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSBpbml0aWFsIHJlZ2lzdHJhdGlvbiBvZiB0aGUgYE5lby5jb25maWdgIGZvciB0aGlzIHdvcmtlcidzIHJlYWxtLlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIHJlY2VpdmluZyBhIHdvcmtlciBtZXNzYWdlIHdpdGggYHthY3Rpb246ICdyZWdpc3Rlck5lb0NvbmZpZyd9YCBmcm9tIHRoZSBNYWluIFRocmVhZCdzIGBOZW8ud29ya2VyLk1hbmFnZXJgLlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHByaW1hcmlseSByZXNwb25zaWJsZSBmb3Igc2V0dGluZyB0aGUgaW5pdGlhbCBnbG9iYWwgYE5lby5jb25maWdgIG9iamVjdCBpbiB0aGlzIHdvcmtlcidzIHNjb3BlXG4gICAgICogdXBvbiBpdHMgY3JlYXRpb24uIEl0IGFsc28gaGFuZGxlcyBhc3NvY2lhdGluZyBgd2luZG93SWRgIHdpdGggYE1lc3NhZ2VQb3J0YHMgZm9yIFNoYXJlZCBXb3JrZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1zZyBUaGUgaW5jb21pbmcgbWVzc2FnZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1zZy5kYXRhIFRoZSBpbml0aWFsIGdsb2JhbCBOZW8uY29uZmlnIGRhdGEgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtc2cuZGF0YS53aW5kb3dJZCBUaGUgdW5pcXVlIElEIG9mIHRoZSB3aW5kb3cvdGFiIChyZWxldmFudCBmb3IgU2hhcmVkV29ya2VycykuXG4gICAgICovXG4gICAgb25SZWdpc3Rlck5lb0NvbmZpZyhtc2cpIHtcbiAgICAgICAgTmVvLm5zKCdOZW8uY29uZmlnJywgdHJ1ZSk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3dpbmRvd0lkfSA9IG1zZy5kYXRhLFxuICAgICAgICAgICAgcG9ydDtcblxuICAgICAgICBmb3IgKHBvcnQgb2YgbWUucG9ydHMpIHtcbiAgICAgICAgICAgIGlmICghcG9ydC53aW5kb3dJZCkge1xuICAgICAgICAgICAgICAgIHBvcnQud2luZG93SWQgPSB3aW5kb3dJZDtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgTmVvLm1lcmdlKE5lby5jb25maWcsIG1zZy5kYXRhKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgcnVudGltZSB1cGRhdGVzIHRvIHRoZSBnbG9iYWwgYE5lby5jb25maWdgIGZvciB0aGlzIHdvcmtlcidzIHJlYWxtLlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHRyaWdnZXJlZCB3aGVuIHJlY2VpdmluZyBhIHdvcmtlciBtZXNzYWdlIHdpdGggYHthY3Rpb246ICdzZXROZW9Db25maWcnfWBcbiAgICAgKiBmcm9tIHRoZSBNYWluIFRocmVhZCdzIGBOZW8ud29ya2VyLk1hbmFnZXJgLiBUaGlzIG1lc3NhZ2Ugc2lnbmlmaWVzIGEgZ2xvYmFsIGNvbmZpZyBjaGFuZ2VcbiAgICAgKiB0aGF0IG9yaWdpbmF0ZWQgZWl0aGVyIGZyb20gdGhpcyB3b3JrZXIncyBNYWluIFRocmVhZCBvciB3YXMgYnJvYWRjYXN0IGZyb20gYW5vdGhlclxuICAgICAqIGNvbm5lY3RlZCBicm93c2VyIHdpbmRvdyB2aWEgYSBTaGFyZWQgV29ya2VyLlxuICAgICAqXG4gICAgICogSXQgbWVyZ2VzIHRoZSBpbmNvbWluZyBjb25maWd1cmF0aW9uIGNoYW5nZXMgaW50byB0aGlzIHdvcmtlcidzIGxvY2FsIGBOZW8uY29uZmlnYFxuICAgICAqIGFuZCBmaXJlcyBhIGxvY2FsIGBuZW9Db25maWdDaGFuZ2VgIGV2ZW50LCBhbGxvd2luZyBvdGhlciBpbnN0YW5jZXMgd2l0aGluIHRoaXMgd29ya2VyXG4gICAgICogdG8gcmVhY3QgdG8gdGhlIHVwZGF0ZWQgY29uZmlndXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtc2cgVGhlIGRlc3RydWN0dXJlZCBhcmd1bWVudHMgZnJvbSB0aGUgbWVzc2FnZSBwYXlsb2FkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtc2cuY29uZmlnIFRoZSBwYXJ0aWFsIG9yIGZ1bGwgYE5lby5jb25maWdgIG9iamVjdCB0byBtZXJnZS5cbiAgICAgKi9cbiAgICBvblNldE5lb0NvbmZpZyh7Y29uZmlnfSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIE5lby5tZXJnZShOZW8uY29uZmlnLCBjb25maWcpO1xuXG4gICAgICAgIG1lLmZpcmUoJ25lb0NvbmZpZ0NoYW5nZScsIGNvbmZpZylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVzdCBhcHAsIGRhdGEsIG1haW4gb3IgdmRvbSAoZXhjbHVkaW5nIHRoZSBjdXJyZW50IHdvcmtlcilcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBjb25maWdzIGZvciBOZW8ud29ya2VyLk1lc3NhZ2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdHJhbnNmZXJdIEFuIG9wdGlvbmFsIGFycmF5IG9mIFRyYW5zZmVyYWJsZSBvYmplY3RzIHRvIHRyYW5zZmVyIG93bmVyc2hpcCBvZi5cbiAgICAgKiBJZiB0aGUgb3duZXJzaGlwIG9mIGFuIG9iamVjdCBpcyB0cmFuc2ZlcnJlZCwgaXQgYmVjb21lcyB1bnVzYWJsZSAobmV1dGVyZWQpIGluIHRoZSBjb250ZXh0IGl0IHdhcyBzZW50IGZyb21cbiAgICAgKiBhbmQgYmVjb21lcyBhdmFpbGFibGUgb25seSB0byB0aGUgd29ya2VyIGl0IHdhcyBzZW50IHRvLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgcHJvbWlzZU1lc3NhZ2UoZGVzdCwgb3B0cywgdHJhbnNmZXIpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZSA9IG1lLnNlbmRNZXNzYWdlKGRlc3QsIG9wdHMsIHRyYW5zZmVyKSxcbiAgICAgICAgICAgICAgICBtc2dJZCAgID0gbWVzc2FnZT8uaWQ7XG5cbiAgICAgICAgICAgIGlmICghbXNnSWQpIHtcbiAgICAgICAgICAgICAgICAvLyBhIHdpbmRvdyBnb3QgY2xvc2VkIGFuZCB0aGUgbWVzc2FnZSBwb3J0IG5vIGxvbmdlciBleGlzdCAoU2hhcmVkV29ya2VycylcbiAgICAgICAgICAgICAgICByZWplY3QoKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZS5wcm9taXNlc1ttc2dJZF0gPSB7cmVqZWN0LCByZXNvbHZlfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkZXN0IGFwcCwgY2FudmFzLCBkYXRhLCBtYWluIG9yIHZkb20gKGV4Y2x1ZGluZyB0aGUgY3VycmVudCB3b3JrZXIpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgY29uZmlncyBmb3IgTmVvLndvcmtlci5NZXNzYWdlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3RyYW5zZmVyXSBBbiBvcHRpb25hbCBhcnJheSBvZiBUcmFuc2ZlcmFibGUgb2JqZWN0cyB0byB0cmFuc2ZlciBvd25lcnNoaXAgb2YuXG4gICAgICogSWYgdGhlIG93bmVyc2hpcCBvZiBhbiBvYmplY3QgaXMgdHJhbnNmZXJyZWQsIGl0IGJlY29tZXMgdW51c2FibGUgKG5ldXRlcmVkKSBpbiB0aGUgY29udGV4dCBpdCB3YXMgc2VudCBmcm9tXG4gICAgICogYW5kIGJlY29tZXMgYXZhaWxhYmxlIG9ubHkgdG8gdGhlIHdvcmtlciBpdCB3YXMgc2VudCB0by5cbiAgICAgKiBAcmV0dXJucyB7TmVvLndvcmtlci5NZXNzYWdlfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZW5kTWVzc2FnZShkZXN0LCBvcHRzLCB0cmFuc2Zlcikge1xuICAgICAgICBvcHRzLmRlc3RpbmF0aW9uID0gZGVzdDtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgbWVzc2FnZSwgcG9ydCwgcG9ydE9iamVjdDtcblxuICAgICAgICBpZiAobWUuY2hhbm5lbFBvcnRzW2Rlc3RdKSB7XG4gICAgICAgICAgICBwb3J0ID0gbWUuY2hhbm5lbFBvcnRzW2Rlc3RdXG4gICAgICAgIH0gZWxzZSBpZiAoIW1lLmlzU2hhcmVkV29ya2VyKSB7XG4gICAgICAgICAgICBwb3J0ID0gZ2xvYmFsVGhpc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG9wdHMucG9ydCkge1xuICAgICAgICAgICAgICAgIHBvcnQgPSBtZS5nZXRQb3J0KHtpZDogb3B0cy5wb3J0fSkucG9ydFxuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRzLndpbmRvd0lkKSB7XG4gICAgICAgICAgICAgICAgcG9ydE9iamVjdCA9IG1lLmdldFBvcnQoe3dpbmRvd0lkOiBvcHRzLndpbmRvd0lkfSk7XG4gICAgICAgICAgICAgICAgcG9ydCAgICAgICA9IHBvcnRPYmplY3Q/LnBvcnQ7XG5cbiAgICAgICAgICAgICAgICBvcHRzLnBvcnQgPSBwb3J0T2JqZWN0Py5pZFxuICAgICAgICAgICAgfSAgZWxzZSBpZiAob3B0cy5hcHBOYW1lKSB7XG4gICAgICAgICAgICAgICAgcG9ydE9iamVjdCA9IG1lLmdldFBvcnQoe2FwcE5hbWU6IG9wdHMuYXBwTmFtZX0pO1xuICAgICAgICAgICAgICAgIHBvcnQgICAgICAgPSBwb3J0T2JqZWN0Py5wb3J0O1xuXG4gICAgICAgICAgICAgICAgb3B0cy5wb3J0ID0gcG9ydE9iamVjdD8uaWRcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9ydCA9IG1lLnBvcnRzWzBdLnBvcnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3J0KSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gbmV3IE1lc3NhZ2Uob3B0cyk7XG4gICAgICAgICAgICBwb3J0LnBvc3RNZXNzYWdlKG1lc3NhZ2UsIHRyYW5zZmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZXNzYWdlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhdGVzIGEgZ2xvYmFsIE5lby5jb25maWcgY2hhbmdlIGZyb20gYSB3b3JrZXIncyBjb250ZXh0LlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGV4cG9zZWQgZ2xvYmFsbHkgYXMgYE5lby5zZXRHbG9iYWxDb25maWdgIHdpdGhpbiBlYWNoIHdvcmtlciByZWFsbS5cbiAgICAgKlxuICAgICAqIEl0IG9yY2hlc3RyYXRlcyB0aGUgcHJvcGFnYXRpb24gb2YgdGhlIGNvbmZpZyBjaGFuZ2UgdG8gdGhlIE1haW4gVGhyZWFkXG4gICAgICogYW5kLCBpZiBhIFNoYXJlZCBXb3JrZXIgaXMgYWN0aXZlLCBhY3Jvc3MgYWxsIGNvbm5lY3RlZCBicm93c2VyIHdpbmRvd3MsXG4gICAgICogZW5zdXJpbmcgYSBzaW5nbGUsIGNvbnNpc3RlbnQgTmVvLmNvbmZpZyBzdGF0ZSBldmVyeXdoZXJlLlxuICAgICAqXG4gICAgICogWW91IGNhbiBwYXNzIGEgcGFydGlhbCBjb25maWcgb2JqZWN0IHRvIHVwZGF0ZSBzcGVjaWZpYyBrZXlzLlxuICAgICAqIEZvciBuZXN0ZWQgb2JqZWN0cywgTmVvLm1qcyBwZXJmb3JtcyBhIGRlZXAgbWVyZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBwYXJ0aWFsIG9yIGZ1bGwgTmVvLmNvbmZpZyBvYmplY3Qgd2l0aCBjaGFuZ2VzIHRvIGFwcGx5LlxuICAgICAqL1xuICAgIHNldEdsb2JhbENvbmZpZyhjb25maWcpIHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7TWFuYWdlcn0gPSBOZW8ud29ya2VyOyAvLyBSZW1vdGUgYWNjZXNzIHByb3h5IG9iamVjdFxuXG4gICAgICAgIC8vIEFwcGx5IHRoZSBjb25maWcgY2hhbmdlIGxvY2FsbHkgdG8gdGhpcyB3b3JrZXIncyBOZW8uY29uZmlnIGFuZFxuICAgICAgICAvLyB0cmlnZ2VyIGl0cyBsb2NhbCBjaGFuZ2UgZXZlbnRzIGltbWVkaWF0ZWx5LiBUaGlzIGVuc3VyZXMgaW1tZWRpYXRlXG4gICAgICAgIC8vIGZlZWRiYWNrIGFuZCBhbiB1cGRhdGVkIHN0YXRlIGZvciB0aGUgd29ya2VyIHRoYXQgaW5pdGlhdGVkIHRoZSBjaGFuZ2UuXG4gICAgICAgIG1lLm9uU2V0TmVvQ29uZmlnKHtjb25maWd9KTtcblxuICAgICAgICBpZiAobWUuaXNTaGFyZWRXb3JrZXIpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgYmxvY2sgZXhlY3V0ZXMgd2hlbiB0aGUgY2FsbGluZyB3b3JrZXIgaW5zdGFuY2UgaXMgYSBTaGFyZWQgV29ya2VyLlxuICAgICAgICAgICAgLy8gVGhpcyBoYXBwZW5zIGlmIGBOZW8uY29uZmlnLnVzZVNoYXJlZFdvcmtlcnNgIGlzIHRydWUsIG1lYW5pbmcgQXBwLCBWRG9tLFxuICAgICAgICAgICAgLy8gRGF0YSwgQ2FudmFzLCBhbmQgVGFzayB3b3JrZXJzIGFyZSBhbGwgU2hhcmVkV29ya2VyIGluc3RhbmNlcy5cbiAgICAgICAgICAgIC8vIFRoaXMgU2hhcmVkIFdvcmtlciAodGhlIG9uZSB3aGVyZSBzZXRHbG9iYWxDb25maWcgd2FzIGNhbGxlZCkgYWN0cyBhcyB0aGVcbiAgICAgICAgICAgIC8vIGNlbnRyYWwgcG9pbnQgdG8gaW5mb3JtIGFsbCBjb25uZWN0ZWQgTWFpbiBUaHJlYWRzIChicm93c2VyIHdpbmRvd3MpLlxuICAgICAgICAgICAgbWUucG9ydHMuZm9yRWFjaCgocG9ydCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBTZW5kIHRoZSBjb25maWcgY2hhbmdlIHRvIGVhY2ggY29ubmVjdGVkIE1haW4gVGhyZWFkLlxuICAgICAgICAgICAgICAgIC8vIFRoZSBgYnJvYWRjYXN0YCBmbGFnIGlzIGNydWNpYWwgaGVyZSBmb3IgdGhlICpyZWNlaXZpbmcqIE1haW4gVGhyZWFkOlxuICAgICAgICAgICAgICAgIC8vIC0gYGJyb2FkY2FzdDogdHJ1ZWAgKGZvciB0aGUgZmlyc3QgcG9ydC9NYWluIFRocmVhZCBpbiB0aGUgbGlzdCk6IFRoaXMgTWFpbiBUaHJlYWRcbiAgICAgICAgICAgICAgICAvLyAgIHdpbGwgYXBwbHkgdGhlIGNvbmZpZyBsb2NhbGx5IGFuZCBpcyB0aGVuIHJlc3BvbnNpYmxlIGZvciBwcm9wYWdhdGluZyBpdCB0byAqYWxsKlxuICAgICAgICAgICAgICAgIC8vICAgaXRzIG93biBhc3NvY2lhdGVkIFNoYXJlZCBXb3JrZXJzIGNvbm5lY3RlZCB0byB0aGF0IE1haW4gVGhyZWFkKSxcbiAgICAgICAgICAgICAgICAvLyAgICoqZXhjbHVkaW5nIHRoZSB3b3JrZXIgdGhhdCBvcmlnaW5hdGVkIHRoaXMgY2hhbmdlKiouXG4gICAgICAgICAgICAgICAgLy8gLSBgYnJvYWRjYXN0OiBmYWxzZWAgKGZvciBhbGwgb3RoZXIgcG9ydHMvTWFpbiBUaHJlYWRzKTogVGhlc2UgTWFpbiBUaHJlYWRzXG4gICAgICAgICAgICAgICAgLy8gICB3aWxsIHNpbXBseSBhcHBseSB0aGUgY29uZmlnIGxvY2FsbHkgYW5kIHN0b3AuIFRoZXkgYXJlIHBhc3NpdmUgcmVjaXBpZW50c1xuICAgICAgICAgICAgICAgIC8vICAgb2YgdGhlIGJyb2FkY2FzdCwgc3luY2hyb25pemluZyB0aGVpciBzdGF0ZSB3aXRob3V0IGluaXRpYXRpbmcgZnVydGhlciBhY3Rpb25zIGJhY2suXG4gICAgICAgICAgICAgICAgLy8gVGhlIGBleGNsdWRlT3JpZ2luYCBwYXJhbWV0ZXIgZW5zdXJlcyB0aGUgb3JpZ2luYXRpbmcgd29ya2VyIGRvZXNuJ3QgcmVjZWl2ZSBhIHJlZHVuZGFudCBicm9hZGNhc3QuXG4gICAgICAgICAgICAgICAgTWFuYWdlci5zZXROZW9Db25maWcoe2Jyb2FkY2FzdDogaW5kZXggPCAxLCBjb25maWcsIGV4Y2x1ZGVPcmlnaW46IG1lLndvcmtlcklkLCB3aW5kb3dJZDogcG9ydC53aW5kb3dJZH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhpcyBEZWRpY2F0ZWQgV29ya2VyICh0aGUgb25lIHdoZXJlIHNldEdsb2JhbENvbmZpZyB3YXMgY2FsbGVkKSBpbmZvcm1zXG4gICAgICAgICAgICAvLyBpdHMgc2luZ2xlLCBjb25uZWN0ZWQgTWFpbiBUaHJlYWQuIFRoZSBNYWluIFRocmVhZCB3aWxsIHRoZW46XG4gICAgICAgICAgICAvLyAxLiBBcHBseSB0aGUgY29uZmlnIGxvY2FsbHkuXG4gICAgICAgICAgICAvLyAyLiBCcm9hZGNhc3QgdGhpcyBjaGFuZ2UgdG8gKmFsbCogb3RoZXIgRGVkaWNhdGVkIFdvcmtlcnMgY29ubmVjdGVkIHRvXG4gICAgICAgICAgICAvLyAgICAqdGhhdCBzYW1lIE1haW4gVGhyZWFkKiwgKipleGNsdWRpbmcgdGhlIHNlbmRlciB3b3JrZXIgaXRzZWxmKiouXG4gICAgICAgICAgICBNYW5hZ2VyLnNldE5lb0NvbmZpZyh7YnJvYWRjYXN0OiB0cnVlLCBjb25maWcsIGV4Y2x1ZGVPcmlnaW46IG1lLndvcmtlcklkfSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoV29ya2VyKTtcbiIsImltcG9ydCBJZEdlbmVyYXRvciBmcm9tICcuLi9jb3JlL0lkR2VuZXJhdG9yLm1qcyc7XG5cbi8qKlxuICogQSB3cmFwcGVyIGZvciB3b3JrZXIgcG9zdCBtZXNzYWdlcyBzZW50IGJldHdlZW4gdGhlIEFwcCwgRGF0YSwgVkRvbSB3b3JrZXIgJiB0aGUgbWFpbiB0aHJlYWQuXG4gKiBZb3UgY2FuIGFkZCBvcHRpb25hbCBwYXJhbXMgYXMgbmVlZGVkLlxuICogQGNsYXNzIE5lby53b3JrZXIuTWVzc2FnZVxuICovXG5jbGFzcyBNZXNzYWdlIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGFjdGlvblxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBkZXN0aW5hdGlvbj0nbWFpbidcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gaWQ9SWRHZW5lcmF0b3IuZ2V0SWQoTmVvLndvcmtlcklkKVxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBvcmlnaW49TmVvLndvcmtlcklkXG4gICAgICAgICAqL1xuXG4gICAgICAgIGNvbmZpZy5kZXN0aW5hdGlvbiA9IGNvbmZpZy5kZXN0aW5hdGlvbiB8fCAnbWFpbic7XG4gICAgICAgIGNvbmZpZy5pZCAgICAgICAgICA9IGNvbmZpZy5pZCAgICAgICAgICB8fCBJZEdlbmVyYXRvci5nZXRJZChOZW8ud29ya2VySWQpO1xuICAgICAgICBjb25maWcub3JpZ2luICAgICAgPSBjb25maWcub3JpZ2luICAgICAgfHwgTmVvLndvcmtlcklkO1xuXG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY29uZmlnKVxuICAgIH1cbn1cblxuY29uc3QgbnMgPSBOZW8ubnMoJ05lby53b3JrZXInLCB0cnVlKTtcbm5zWydNZXNzYWdlJ10gPSBNZXNzYWdlO1xuXG5leHBvcnQgZGVmYXVsdCBNZXNzYWdlO1xuIiwiaW1wb3J0IEJhc2UgZnJvbSAnLi4vLi4vY29yZS9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby53b3JrZXIubWl4aW4uUmVtb3RlTWV0aG9kQWNjZXNzXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIFJlbW90ZU1ldGhvZEFjY2VzcyBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLndvcmtlci5taXhpbi5SZW1vdGVNZXRob2RBY2Nlc3MnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby53b3JrZXIubWl4aW4uUmVtb3RlTWV0aG9kQWNjZXNzJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAgICovXG4gICAgYXNzaWduUG9ydChzb3VyY2UsIHRhcmdldCkge1xuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICBjb25zdCB7YXBwTmFtZSwgcG9ydCwgd2luZG93SWR9ID0gc291cmNlO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHthcHBOYW1lLCBwb3J0LCB3aW5kb3dJZH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVtb3RlXG4gICAgICogQHBhcmFtIG1ldGhvZFxuICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbigqPSwgKj0pOiBQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgZ2VuZXJhdGVSZW1vdGUocmVtb3RlLCBtZXRob2QpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtvcmlnaW59ID0gcmVtb3RlO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihkYXRhLCBidWZmZXIpIHtcbiAgICAgICAgICAgIGxldCBvcHRzID0ge1xuICAgICAgICAgICAgICAgIGFjdGlvbiAgICAgICAgIDogJ3JlbW90ZU1ldGhvZCcsXG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbiAgICA6IG9yaWdpbixcbiAgICAgICAgICAgICAgICByZW1vdGVDbGFzc05hbWU6IHJlbW90ZS5jbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgcmVtb3RlTWV0aG9kICAgOiBtZXRob2RcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG1lLmlzU2hhcmVkV29ya2VyICYmIG1lLmFzc2lnblBvcnQoZGF0YSwgb3B0cyk7XG5cbiAgICAgICAgICAgIHJldHVybiBtZS5wcm9taXNlTWVzc2FnZShvcmlnaW4sIG9wdHMsIGJ1ZmZlcilcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZW1vdGVcbiAgICAgKi9cbiAgICBvblJlZ2lzdGVyUmVtb3RlKHJlbW90ZSkge1xuICAgICAgICBpZiAocmVtb3RlLmRlc3RpbmF0aW9uID09PSBOZW8ud29ya2VySWQpIHtcbiAgICAgICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAge2NsYXNzTmFtZSwgbWV0aG9kc30gPSByZW1vdGUsXG4gICAgICAgICAgICAgICAgcGtnICAgICAgICAgICAgICAgICAgPSBOZW8ubnMoY2xhc3NOYW1lLCB0cnVlKTtcblxuICAgICAgICAgICAgbWV0aG9kcy5mb3JFYWNoKG1ldGhvZCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlbW90ZS5vcmlnaW4gIT09ICdtYWluJyAmJiBwa2dbbWV0aG9kXSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0R1cGxpY2F0ZSByZW1vdGUgbWV0aG9kIGRlZmluaXRpb24gJyArIGNsYXNzTmFtZSArICcuJyArIG1ldGhvZClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwa2dbbWV0aG9kXSA/Pz0gbWUuZ2VuZXJhdGVSZW1vdGUocmVtb3RlLCBtZXRob2QpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1zZ1xuICAgICAqL1xuICAgIG9uUmVtb3RlTWV0aG9kKG1zZykge1xuICAgICAgICBsZXQgbWUgID0gdGhpcyxcbiAgICAgICAgICAgIHBrZyA9IE5lby5ucyhtc2cucmVtb3RlQ2xhc3NOYW1lKSxcbiAgICAgICAgICAgIG91dCwgbWV0aG9kO1xuXG4gICAgICAgIGlmICghcGtnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmVtb3RlIG5hbWVzcGFjZSBcIicgKyBtc2cucmVtb3RlQ2xhc3NOYW1lICsgJ1wiJylcbiAgICAgICAgfVxuXG4gICAgICAgIG1ldGhvZCA9IHBrZ1ttc2cucmVtb3RlTWV0aG9kXTtcblxuICAgICAgICBpZiAoIW1ldGhvZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJlbW90ZSBtZXRob2QgbmFtZSBcIicgKyBtc2cucmVtb3RlTWV0aG9kICsgJ1wiJylcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGZvciBpbnRlcmNlcHRpb25cbiAgICAgICAgaWYgKCFwa2cuaXNSZWFkeSAmJiBwa2cuaW50ZXJjZXB0UmVtb3Rlcz8uaW5jbHVkZXMobXNnLnJlbW90ZU1ldGhvZCkpIHtcbiAgICAgICAgICAgIG91dCA9IHBrZy5vbkludGVyY2VwdFJlbW90ZXMobXNnKTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG1zZy5kYXRhKSkge1xuICAgICAgICAgICAgb3V0ID0gbWV0aG9kLmNhbGwocGtnLCAuLi5tc2cuZGF0YSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dCA9IG1ldGhvZC5jYWxsKHBrZywgbXNnLmRhdGEpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoTmVvLmlzUHJvbWlzZShvdXQpKSB7XG4gICAgICAgICAgICBvdXRcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIEludGVuZGVkIGxvZ2ljOlxuICAgICAgICAgICAgICAgICAqIElmIHRoZSBjb2RlIG9mIGEgcmVtb3RlIG1ldGhvZCBmYWlscywgaXQgd291bGQgbm90IHNob3cgYW55IGVycm9ycyBpbnNpZGUgdGhlIGNvbnNvbGUsXG4gICAgICAgICAgICAgICAgICogc28gd2Ugd2FudCB0byBtYW51YWxseSBsb2cgdGhlIGVycm9yIGZvciBkZWJ1Z2dpbmcuXG4gICAgICAgICAgICAgICAgICogUmVqZWN0aW5nIHRoZSBQcm9taXNlIGdpdmVzIHVzIHRoZSBjaGFuY2UgdG8gcmVjb3Zlci5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEV4YW1wbGU6XG4gICAgICAgICAgICAgICAgICogTmVvLnZkb20uSGVscGVyLnVwZGF0ZShvcHRzKS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAqICAgICBtZS5pc1Zkb21VcGRhdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAqICAgICByZWplY3Q/LigpXG4gICAgICAgICAgICAgICAgICogfSkudGhlbihkYXRhID0+IHsuLi59KVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4ge2NvbnNvbGUuZXJyb3IoZXJyKTsgbWUucmVqZWN0KG1zZywgZXJyKX0pXG4gICAgICAgICAgICAgICAgLnRoZW4oZGF0YSA9PiB7bWUucmVzb2x2ZShtc2csIGRhdGEpfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLnJlc29sdmUobXNnLCBvdXQpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHByb21pc2VNZXNzYWdlIGdldHMgcmVqZWN0ZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbXNnXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICByZWplY3QobXNnLCBkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG5cbiAgICAgICAgb3B0cyA9IHtcbiAgICAgICAgICAgIGFjdGlvbiA6ICdyZXBseScsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcmVqZWN0IDogdHJ1ZSxcbiAgICAgICAgICAgIHJlcGx5SWQ6IG1zZy5pZFxuICAgICAgICB9O1xuXG4gICAgICAgIG1lLmlzU2hhcmVkV29ya2VyICYmIG1lLmFzc2lnblBvcnQobXNnLCBvcHRzKTtcbiAgICAgICAgbWUuc2VuZE1lc3NhZ2UobXNnLm9yaWdpbiwgb3B0cylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHByb21pc2VNZXNzYWdlIGdldHMgcmVzb2x2ZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbXNnXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICByZXNvbHZlKG1zZywgZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuXG4gICAgICAgIG9wdHMgPSB7XG4gICAgICAgICAgICBhY3Rpb24gOiAncmVwbHknLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHJlcGx5SWQ6IG1zZy5pZFxuICAgICAgICB9O1xuXG4gICAgICAgIG1lLmlzU2hhcmVkV29ya2VyICYmIG1lLmFzc2lnblBvcnQobXNnLCBvcHRzKTtcbiAgICAgICAgbWUuc2VuZE1lc3NhZ2UobXNnLm9yaWdpbiwgb3B0cylcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFJlbW90ZU1ldGhvZEFjY2Vzcyk7XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuLy8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbl9fd2VicGFja19yZXF1aXJlX18ubSA9IF9fd2VicGFja19tb2R1bGVzX187XG5cbiIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uZiA9IHt9O1xuLy8gVGhpcyBmaWxlIGNvbnRhaW5zIG9ubHkgdGhlIGVudHJ5IGNodW5rLlxuLy8gVGhlIGNodW5rIGxvYWRpbmcgZnVuY3Rpb24gZm9yIGFkZGl0aW9uYWwgY2h1bmtzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmUgPSAoY2h1bmtJZCkgPT4ge1xuXHRyZXR1cm4gUHJvbWlzZS5hbGwoT2JqZWN0LmtleXMoX193ZWJwYWNrX3JlcXVpcmVfXy5mKS5yZWR1Y2UoKHByb21pc2VzLCBrZXkpID0+IHtcblx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmZba2V5XShjaHVua0lkLCBwcm9taXNlcyk7XG5cdFx0cmV0dXJuIHByb21pc2VzO1xuXHR9LCBbXSkpO1xufTsiLCIvLyBUaGlzIGZ1bmN0aW9uIGFsbG93IHRvIHJlZmVyZW5jZSBhc3luYyBjaHVua3Ncbl9fd2VicGFja19yZXF1aXJlX18udSA9IChjaHVua0lkKSA9PiB7XG5cdC8vIHJldHVybiB1cmwgZm9yIGZpbGVuYW1lcyBiYXNlZCBvbiB0ZW1wbGF0ZVxuXHRyZXR1cm4gXCJjaHVua3MvYXBwL1wiICsgY2h1bmtJZCArIFwiLmpzXCI7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsInZhciBzY3JpcHRVcmw7XG5pZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5nLmltcG9ydFNjcmlwdHMpIHNjcmlwdFVybCA9IF9fd2VicGFja19yZXF1aXJlX18uZy5sb2NhdGlvbiArIFwiXCI7XG52YXIgZG9jdW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmcuZG9jdW1lbnQ7XG5pZiAoIXNjcmlwdFVybCAmJiBkb2N1bWVudCkge1xuXHRpZiAoZG9jdW1lbnQuY3VycmVudFNjcmlwdCAmJiBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnRhZ05hbWUudG9VcHBlckNhc2UoKSA9PT0gJ1NDUklQVCcpXG5cdFx0c2NyaXB0VXJsID0gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM7XG5cdGlmICghc2NyaXB0VXJsKSB7XG5cdFx0dmFyIHNjcmlwdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTtcblx0XHRpZihzY3JpcHRzLmxlbmd0aCkge1xuXHRcdFx0dmFyIGkgPSBzY3JpcHRzLmxlbmd0aCAtIDE7XG5cdFx0XHR3aGlsZSAoaSA+IC0xICYmICghc2NyaXB0VXJsIHx8ICEvXmh0dHAocz8pOi8udGVzdChzY3JpcHRVcmwpKSkgc2NyaXB0VXJsID0gc2NyaXB0c1tpLS1dLnNyYztcblx0XHR9XG5cdH1cbn1cbi8vIFdoZW4gc3VwcG9ydGluZyBicm93c2VycyB3aGVyZSBhbiBhdXRvbWF0aWMgcHVibGljUGF0aCBpcyBub3Qgc3VwcG9ydGVkIHlvdSBtdXN0IHNwZWNpZnkgYW4gb3V0cHV0LnB1YmxpY1BhdGggbWFudWFsbHkgdmlhIGNvbmZpZ3VyYXRpb25cbi8vIG9yIHBhc3MgYW4gZW1wdHkgc3RyaW5nIChcIlwiKSBhbmQgc2V0IHRoZSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyB2YXJpYWJsZSBmcm9tIHlvdXIgY29kZSB0byB1c2UgeW91ciBvd24gbG9naWMuXG5pZiAoIXNjcmlwdFVybCkgdGhyb3cgbmV3IEVycm9yKFwiQXV0b21hdGljIHB1YmxpY1BhdGggaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXJcIik7XG5zY3JpcHRVcmwgPSBzY3JpcHRVcmwucmVwbGFjZSgvXmJsb2I6LywgXCJcIikucmVwbGFjZSgvIy4qJC8sIFwiXCIpLnJlcGxhY2UoL1xcPy4qJC8sIFwiXCIpLnJlcGxhY2UoL1xcL1teXFwvXSskLywgXCIvXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5wID0gc2NyaXB0VXJsOyIsIi8vIG5vIGJhc2VVUklcblxuLy8gb2JqZWN0IHRvIHN0b3JlIGxvYWRlZCBjaHVua3Ncbi8vIFwiMVwiIG1lYW5zIFwiYWxyZWFkeSBsb2FkZWRcIlxudmFyIGluc3RhbGxlZENodW5rcyA9IHtcblx0XCJhcHBcIjogMVxufTtcblxuLy8gaW1wb3J0U2NyaXB0cyBjaHVuayBsb2FkaW5nXG52YXIgaW5zdGFsbENodW5rID0gKGRhdGEpID0+IHtcblx0dmFyIFtjaHVua0lkcywgbW9yZU1vZHVsZXMsIHJ1bnRpbWVdID0gZGF0YTtcblx0Zm9yKHZhciBtb2R1bGVJZCBpbiBtb3JlTW9kdWxlcykge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhtb3JlTW9kdWxlcywgbW9kdWxlSWQpKSB7XG5cdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLm1bbW9kdWxlSWRdID0gbW9yZU1vZHVsZXNbbW9kdWxlSWRdO1xuXHRcdH1cblx0fVxuXHRpZihydW50aW1lKSBydW50aW1lKF9fd2VicGFja19yZXF1aXJlX18pO1xuXHR3aGlsZShjaHVua0lkcy5sZW5ndGgpXG5cdFx0aW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRzLnBvcCgpXSA9IDE7XG5cdHBhcmVudENodW5rTG9hZGluZ0Z1bmN0aW9uKGRhdGEpO1xufTtcbl9fd2VicGFja19yZXF1aXJlX18uZi5pID0gKGNodW5rSWQsIHByb21pc2VzKSA9PiB7XG5cdC8vIFwiMVwiIGlzIHRoZSBzaWduYWwgZm9yIFwiYWxyZWFkeSBsb2FkZWRcIlxuXHRpZighaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdKSB7XG5cdFx0aWYodHJ1ZSkgeyAvLyBhbGwgY2h1bmtzIGhhdmUgSlNcblx0XHRcdGltcG9ydFNjcmlwdHMoX193ZWJwYWNrX3JlcXVpcmVfXy5wICsgX193ZWJwYWNrX3JlcXVpcmVfXy51KGNodW5rSWQpKTtcblx0XHR9XG5cdH1cbn07XG5cbnZhciBjaHVua0xvYWRpbmdHbG9iYWwgPSBzZWxmW1wid2VicGFja0NodW5rbmVvX21qc1wiXSA9IHNlbGZbXCJ3ZWJwYWNrQ2h1bmtuZW9fbWpzXCJdIHx8IFtdO1xudmFyIHBhcmVudENodW5rTG9hZGluZ0Z1bmN0aW9uID0gY2h1bmtMb2FkaW5nR2xvYmFsLnB1c2guYmluZChjaHVua0xvYWRpbmdHbG9iYWwpO1xuY2h1bmtMb2FkaW5nR2xvYmFsLnB1c2ggPSBpbnN0YWxsQ2h1bms7XG5cbi8vIG5vIEhNUlxuXG4vLyBubyBITVIgbWFuaWZlc3QiLCJpbXBvcnQgTmVvICAgICAgICAgICAgIGZyb20gJy4uL05lby5tanMnO1xuaW1wb3J0IEJhc2UgICAgICAgICAgICBmcm9tICcuL0Jhc2UubWpzJztcbmltcG9ydCBBcHBsaWNhdGlvbiAgICAgZnJvbSAnLi4vY29udHJvbGxlci9BcHBsaWNhdGlvbi5tanMnO1xuaW1wb3J0IEluc3RhbmNlTWFuYWdlciBmcm9tICcuLi9tYW5hZ2VyL0luc3RhbmNlLm1qcyc7XG5pbXBvcnQgRG9tRXZlbnRNYW5hZ2VyIGZyb20gJy4uL21hbmFnZXIvRG9tRXZlbnQubWpzJztcbmltcG9ydCBIYXNoSGlzdG9yeSAgICAgZnJvbSAnLi4vdXRpbC9IYXNoSGlzdG9yeS5tanMnO1xuXG4vKipcbiAqIFRoZSBBcHAgd29ya2VyIGNvbnRhaW5zIG1vc3QgcGFydHMgb2YgdGhlIGZyYW1ld29yayBhcyB3ZWxsIGFzIGFsbCBhcHBzIHdoaWNoIGdldCBjcmVhdGVkLlxuICogU2VlIHRoZSB0dXRvcmlhbHMgZm9yIGZ1cnRoZXIgaW5mb3MuXG4gKiBAY2xhc3MgTmVvLndvcmtlci5BcHBcbiAqIEBleHRlbmRzIE5lby53b3JrZXIuQmFzZVxuICogQHNpbmdsZXRvblxuICovXG5jbGFzcyBBcHAgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby53b3JrZXIuQXBwJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ud29ya2VyLkFwcCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGNvdW50TG9hZGluZ1RoZW1lRmlsZXNfPTBcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBjb3VudExvYWRpbmdUaGVtZUZpbGVzXzogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW90ZSBtZXRob2QgYWNjZXNzIGZvciBvdGhlciB3b3JrZXJzXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gcmVtb3RlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHJlbW90ZToge1xuICAgICAgICAgICAgbWFpbjogW1xuICAgICAgICAgICAgICAgICdjcmVhdGVOZW9JbnN0YW5jZScsXG4gICAgICAgICAgICAgICAgJ2Rlc3Ryb3lOZW9JbnN0YW5jZScsXG4gICAgICAgICAgICAgICAgJ2ZpcmVFdmVudCcsXG4gICAgICAgICAgICAgICAgJ2dldENvbmZpZ3MnLFxuICAgICAgICAgICAgICAgICdzZXRDb25maWdzJyxcbiAgICAgICAgICAgICAgICAnc2V0R2xvYmFsQ29uZmlnJyAvLyBwb2ludHMgdG8gd29ya2VyLkJhc2U6IHNldEdsb2JhbENvbmZpZygpXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaW5nbGV0b249dHJ1ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzaW5nbGV0b246IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXZSBhcmUgc3RvcmluZyB0aGUgcGFyYW1zIG9mIGluc2VydFRoZW1lRmlsZXMoKSBjYWxscyBoZXJlLCBpbiBjYXNlIHRoZSBtZXRob2QgZG9lcyBnZXQgdHJpZ2dlcmVkXG4gICAgICogYmVmb3JlIHRoZSBqc29uIHRoZW1lIHN0cnVjdHVyZSBnb3QgbG9hZGVkLlxuICAgICAqIEBtZW1iZXIge0FycmF5W119IHRoZW1lRmlsZXNDYWNoZT1bXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0aGVtZUZpbGVzQ2FjaGUgPSBbXVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge1N0cmluZ30gd29ya2VySWQ9J2FwcCdcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgd29ya2VySWQgPSAnYXBwJ1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvLyBjb252ZW5pZW5jZSBzaG9ydGN1dHNcbiAgICAgICAgTmVvLmFwcGx5RGVsdGFzICAgID0gbWUuYXBwbHlEZWx0YXMgICAuYmluZChtZSk7XG4gICAgICAgIE5lby5zZXRDc3NWYXJpYWJsZSA9IG1lLnNldENzc1ZhcmlhYmxlLmJpbmQobWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBjb3VudExvYWRpbmdUaGVtZUZpbGVzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldENvdW50TG9hZGluZ1RoZW1lRmlsZXModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gMCAmJiBvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ3RoZW1lRmlsZXNMb2FkZWQnKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFwcE5hbWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gZGVsdGFzXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Kj59XG4gICAgICovXG4gICAgYXBwbHlEZWx0YXMoYXBwTmFtZSwgZGVsdGFzKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlTWVzc2FnZSgnbWFpbicsIHthY3Rpb246ICd1cGRhdGVEb20nLCBhcHBOYW1lLCBkZWx0YXN9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW90ZSBtZXRob2QgdG8gdXNlIGluc2lkZSBtYWluIHRocmVhZHMgZm9yIGNyZWF0aW5nIG5lbyBiYXNlZCBjbGFzcyBpbnN0YW5jZXMuXG4gICAgICogQmUgYXdhcmUgdGhhdCB5b3UgY2FuIG9ubHkgcGFzcyBjb25maWdzIHdoaWNoIGNhbiBnZXQgY29udmVydGVkIGludG8gcHVyZSBKU09OLlxuICAgICAqXG4gICAgICogUmVuZGVyaW5nIGEgY29tcG9uZW50IGludG8gdGhlIGRvY3VtZW50LmJvZHlcbiAgICAgKiBAZXhhbXBsZTpcbiAgICAgKiAgICAgTmVvLndvcmtlci5BcHAuY3JlYXRlTmVvSW5zdGFuY2Uoe1xuICAgICAqICAgICAgICAgbnR5cGUgICAgIDogJ2J1dHRvbicsXG4gICAgICogICAgICAgICBhdXRvTW91bnQgOiB0cnVlLFxuICAgICAqICAgICAgICAgYXV0b1JlbmRlcjogdHJ1ZVxuICAgICAqICAgICAgICAgdGV4dCAgICAgIDogJ0hpIE5pZ2UhJ1xuICAgICAqICAgICB9KS50aGVuKGlkID0+IGNvbnNvbGUubG9nKGlkKSlcbiAgICAgKlxuICAgICAqIEluc2VydGluZyBhIGNvbXBvbmVudCBpbnRvIGEgY29udGFpbmVyXG4gICAgICogQGV4YW1wbGU6XG4gICAgICogICAgIE5lby53b3JrZXIuQXBwLmNyZWF0ZU5lb0luc3RhbmNlKHtcbiAgICAgKiAgICAgICAgIG50eXBlICAgICAgOiAnYnV0dG9uJyxcbiAgICAgKiAgICAgICAgIHBhcmVudElkICAgOiAnbmVvLWNvbnRhaW5lci0zJyxcbiAgICAgKiAgICAgICAgIHBhcmVudEluZGV4OiAwXG4gICAgICogICAgICAgICB0ZXh0ICAgICAgIDogJ0hpIE5pZ2UhJ1xuICAgICAqICAgICB9KS50aGVuKGlkID0+IGNvbnNvbGUubG9nKGlkKSlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pbXBvcnRQYXRoXSB5b3UgY2FuIGxhenkgbG9hZCBtaXNzaW5nIGNsYXNzZXMgdmlhIHRoaXMgY29uZmlnLiBkZXYgbW9kZSBvbmx5LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnBhcmVudElkXSBwYXNzaW5nIGEgcGFyZW50SWQgd2lsbCBwdXQgeW91ciBpbnN0YW5jZSBpbnRvIGEgY29udGFpbmVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucGFyZW50SW5kZXhdIGlmIGEgcGFyZW50SWQgaXMgcGFzc2VkLCBidXQgbm8gaW5kZXgsIG5lbyB3aWxsIHVzZSBhZGQoKVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBpbnN0YW5jZSBpZFxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZU5lb0luc3RhbmNlKGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnLmltcG9ydFBhdGgpIHtcbiAgICAgICAgICAgIGF3YWl0IGltcG9ydCgvKiB3ZWJwYWNrSWdub3JlOiB0cnVlICovIGNvbmZpZy5pbXBvcnRQYXRoKTtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuaW1wb3J0UGF0aFxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGFwcE5hbWUgICA9IE9iamVjdC5rZXlzKE5lby5hcHBzKVswXSwgLy8gZmFsbGJhY2sgaW4gY2FzZSBubyBhcHBOYW1lIHdhcyBwcm92aWRlZFxuICAgICAgICAgICAgQ29udGFpbmVyID0gTmVvLmNvbnRhaW5lcj8uQmFzZSxcbiAgICAgICAgICAgIGluZGV4LCBpbnN0YW5jZSwgcGFyZW50O1xuXG4gICAgICAgIGNvbmZpZyA9IHthcHBOYW1lLCAuLi5jb25maWd9O1xuXG4gICAgICAgIGlmIChjb25maWcucGFyZW50SWQpIHtcbiAgICAgICAgICAgIHBhcmVudCA9IE5lby5nZXRDb21wb25lbnQoY29uZmlnLnBhcmVudElkKTtcblxuICAgICAgICAgICAgaWYgKENvbnRhaW5lciAmJiBwYXJlbnQgJiYgcGFyZW50IGluc3RhbmNlb2YgQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBjb25maWcucGFyZW50SW5kZXg7XG5cbiAgICAgICAgICAgICAgICBkZWxldGUgY29uZmlnLnBhcmVudElkO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBjb25maWcucGFyZW50SW5kZXg7XG5cbiAgICAgICAgICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKGluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZSA9IHBhcmVudC5pbnNlcnQoaW5kZXgsIGNvbmZpZylcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZSA9IHBhcmVudC5hZGQoY29uZmlnKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGRlZmF1bHQgcGFyZW50SWQ9J2RvY3VtZW50LmJvZHknID0+IHdlIHdhbnQgaXQgdG8gZ2V0IHNob3duXG4gICAgICAgICAgICBjb25maWcuYXV0b01vdW50ICA9IHRydWU7XG4gICAgICAgICAgICBjb25maWcuYXV0b1JlbmRlciA9IHRydWU7XG5cbiAgICAgICAgICAgIGluc3RhbmNlID0gTmVvW2NvbmZpZy5udHlwZSA/ICdudHlwZScgOiAnY3JlYXRlJ10oY29uZmlnKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLmlkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBjcmVhdGVUaGVtZU1hcChkYXRhKSB7XG4gICAgICAgIE5lby5ucygnTmVvLmNzc01hcC5maWxlSW5mbycsIHRydWUpO1xuICAgICAgICBOZW8uY3NzTWFwLmZpbGVJbmZvID0gZGF0YTtcbiAgICAgICAgdGhpcy5yZXNvbHZlVGhlbWVGaWxlc0NhY2hlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdGUgbWV0aG9kIHRvIHVzZSBpbnNpZGUgbWFpbiB0aHJlYWRzIGZvciBkZXN0cm95aW5nIG5lbyBiYXNlZCBjbGFzcyBpbnN0YW5jZXMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZTpcbiAgICAgKiAgICAgTmVvLndvcmtlci5BcHAuZGVzdHJveU5lb0luc3RhbmNlKCduZW8tYnV0dG9uLTMnKS50aGVuKHN1Y2Nlc3MgPT4gY29uc29sZS5sb2coc3VjY2VzcykpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gcmV0dXJucyB0cnVlLCBpbiBjYXNlIHRoZSBpbnN0YW5jZSB3YXMgZm91bmRcbiAgICAgKi9cbiAgICBkZXN0cm95TmVvSW5zdGFuY2UoaWQpIHtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gTmVvLmdldChpZCksXG4gICAgICAgICAgICBwYXJlbnQ7XG5cbiAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UucGFyZW50SWQpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBOZW8uZ2V0Q29tcG9uZW50KGluc3RhbmNlLnBhcmVudElkKTtcblxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LnJlbW92ZShpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbnN0YW5jZS5kZXN0cm95KHRydWUsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpcmVzIGEgY3VzdG9tIGV2ZW50IGJhc2VkIG9uIGNvcmUuT2JzZXJ2YWJsZSBvbiBhbnkgYXBwIHJlYWxtIGJhc2VkIE5lbyBpbnN0YW5jZSBmcm9tIG1haW5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEubmFtZVxuICAgICAqL1xuICAgIGZpcmVFdmVudChkYXRhKSB7XG4gICAgICAgIGxldCBpbnN0YW5jZSA9IE5lby5nZXQoZGF0YS5pZCksXG4gICAgICAgICAgICBuYW1lO1xuXG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgbmFtZSA9IGRhdGEubmFtZTtcblxuICAgICAgICAgICAgZGVsZXRlIGRhdGEuaWQ7XG4gICAgICAgICAgICBkZWxldGUgZGF0YS5uYW1lO1xuXG4gICAgICAgICAgICBpbnN0YW5jZS5maXJlKG5hbWUsIGRhdGEpO1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT25seSBuZWVkZWQgZm9yIHRoZSBTaGFyZWRXb3JrZXJzIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBmaXJlTWFpblZpZXdzRXZlbnQoZXZlbnROYW1lLCBkYXRhKSB7XG4gICAgICAgIHRoaXMucG9ydHMuZm9yRWFjaChwb3J0ID0+IHtcbiAgICAgICAgICAgIE5lby5hcHBzW3BvcnQuYXBwTmFtZV0ubWFpblZpZXcuZmlyZShldmVudE5hbWUsIGRhdGEpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXQgdG8gbGF6eS1sb2FkIG1haW4gdGhyZWFkIGFkZG9ucywgaW4gY2FzZSB0aGV5IGFyZSBub3QgaW1wb3J0ZWQgeWV0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2luZG93SWRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxOZW8ubWFpbi5hZGRvbi5CYXNlPn0gVGhlIG5hbWVzcGFjZSBvZiB0aGUgYWRkb24gdG8gdXNlIHZpYSByZW1vdGUgbWV0aG9kIGFjY2Vzc1xuICAgICAqL1xuICAgIGFzeW5jIGdldEFkZG9uKG5hbWUsIHdpbmRvd0lkKSB7XG4gICAgICAgIGxldCBhZGRvbiA9IE5lby5tYWluPy5hZGRvbj8uW25hbWVdO1xuXG4gICAgICAgIGlmICghYWRkb24pIHtcbiAgICAgICAgICAgIGF3YWl0IE5lby5NYWluLmltcG9ydEFkZG9uKHtuYW1lLCB3aW5kb3dJZH0pO1xuICAgICAgICAgICAgYWRkb24gPSBOZW8ubWFpbi5hZGRvbltuYW1lXVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFkZG9uXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGNvbmZpZ3Mgb2YgYW55IGFwcCByZWFsbSBiYXNlZCBOZW8gaW5zdGFuY2UgZnJvbSBtYWluXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5pZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfFN0cmluZ1tdfSBkYXRhLmtleXNcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGNvbmZpZ3MgaWYgYSBrZXlzIGFycmF5IHdhcyBwYXNzZWQuXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgYSBnaXZlbiBjb25maWcgZGlyZWN0bHksIGluIGNhc2Ugbm8gYXJyYXkgd2FzIHBhc3NlZFxuICAgICAqIFJldHVybnMgZmFsc2UsIGluIGNhc2Ugbm8gaW5zdGFuY2UgZ290IGZvdW5kLlxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldENvbmZpZ3MoZGF0YSkge1xuICAgICAgICBsZXQgaW5zdGFuY2UgICAgPSBOZW8uZ2V0KGRhdGEuaWQpLFxuICAgICAgICAgICAge2tleXN9ICAgICAgPSBkYXRhLFxuICAgICAgICAgICAgcmV0dXJuQXJyYXkgPSBbXTtcblxuICAgICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShrZXlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZVtrZXlzXVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm5BcnJheS5wdXNoKGluc3RhbmNlW2tleV0pXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHJldHVybkFycmF5XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGltcG9ydEFwcChwYXRoKSB7XG4gICAgICAgIGlmIChwYXRoLmVuZHNXaXRoKCcubWpzJykpIHtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIC00KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGltcG9ydChcbiAgICAgICAgICAgIC8qIHdlYnBhY2tJbmNsdWRlOiAvKD86XFwvfFxcXFwpYXBwLm1qcyQvICovXG4gICAgICAgICAgICAvKiB3ZWJwYWNrRXhjbHVkZTogLyg/OlxcL3xcXFxcKShkaXN0fG5vZGVfbW9kdWxlcykvKD8hbmVvLm1qcykgKi9cbiAgICAgICAgICAgIC8qIHdlYnBhY2tNb2RlOiBcImxhenlcIiAqL1xuICAgICAgICAgICAgYC4uLy4uLyR7cGF0aH0ubWpzYFxuICAgICAgICApXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW4gY2FzZSB5b3UgZG9uJ3Qgd2FudCB0byBpbmNsdWRlIHByb3RvdHlwZSBiYXNlZCBDU1MgZmlsZXMsIHVzZSB0aGUgY2xhc3NOYW1lIHBhcmFtIGluc3RlYWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2luZG93SWRcbiAgICAgKiBAcGFyYW0ge05lby5jb3JlLkJhc2V9IFtwcm90b11cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NsYXNzTmFtZV1cbiAgICAgKi9cbiAgICBpbnNlcnRUaGVtZUZpbGVzKHdpbmRvd0lkLCBwcm90bywgY2xhc3NOYW1lKSB7XG4gICAgICAgIGlmIChOZW8uY29uZmlnLnRoZW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSBjbGFzc05hbWUgfHwgcHJvdG8uY2xhc3NOYW1lO1xuXG4gICAgICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBjc3NNYXAgPSBOZW8uY3NzTWFwLFxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHByb3RvPy5fX3Byb3RvX18sXG4gICAgICAgICAgICAgICAgY2xhc3NQYXRoLCBjbGFzc1Jvb3QsIGZpbGVOYW1lLCBsQ2xhc3NSb290LCBtYXBDbGFzc05hbWUsIG5zLCB0aGVtZUZvbGRlcnM7XG5cbiAgICAgICAgICAgIGlmICghY3NzTWFwKSB7XG4gICAgICAgICAgICAgICAgbWUudGhlbWVGaWxlc0NhY2hlLnB1c2goW3dpbmRvd0lkLCBwcm90b10pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gbW9kaWZ5IGFwcCByZWxhdGVkIGNsYXNzIG5hbWVzXG4gICAgICAgICAgICAgICAgaWYgKCFjbGFzc05hbWUuc3RhcnRzV2l0aCgnTmVvLicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZSAgPSBjbGFzc05hbWUuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NSb290ICA9IGNsYXNzTmFtZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBsQ2xhc3NSb290ID0gY2xhc3NSb290LnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lWzBdID09PSAndmlldycgJiYgY2xhc3NOYW1lLnNoaWZ0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgbWFwQ2xhc3NOYW1lID0gYGFwcHMuJHtOZW8uYXBwc1tjbGFzc1Jvb3RdPy5hcHBUaGVtZUZvbGRlciB8fCBsQ2xhc3NSb290fS4ke2NsYXNzTmFtZS5qb2luKCcuJyl9YDtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lICAgID0gYGFwcHMuJHtsQ2xhc3NSb290fS4ke2NsYXNzTmFtZS5qb2luKCcuJyl9YDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudCAhPT0gTmVvLmNvcmUuQmFzZS5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFOZW8ubnMoYCR7d2luZG93SWR9LiR7cGFyZW50LmNsYXNzTmFtZX1gLCBmYWxzZSwgY3NzTWFwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUuaW5zZXJ0VGhlbWVGaWxlcyh3aW5kb3dJZCwgcGFyZW50KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhlbWVGb2xkZXJzID0gTmVvLm5zKG1hcENsYXNzTmFtZSB8fCBjbGFzc05hbWUsIGZhbHNlLCBjc3NNYXAuZmlsZUluZm8pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoZW1lRm9sZGVycyAmJiAhTmVvLm5zKGAke3dpbmRvd0lkfS4ke2NsYXNzTmFtZX1gLCBmYWxzZSwgY3NzTWFwKSkge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc1BhdGggPSBjbGFzc05hbWUuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWUgID0gY2xhc3NQYXRoLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBjbGFzc1BhdGggPSBjbGFzc1BhdGguam9pbignLicpO1xuICAgICAgICAgICAgICAgICAgICBucyAgICAgICAgPSBOZW8ubnMoYCR7d2luZG93SWR9LiR7Y2xhc3NQYXRofWAsIHRydWUsIGNzc01hcCk7XG5cbiAgICAgICAgICAgICAgICAgICAgbnNbZmlsZU5hbWVdID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICBtZS5jb3VudExvYWRpbmdUaGVtZUZpbGVzKys7XG5cbiAgICAgICAgICAgICAgICAgICAgTmVvLm1haW4uYWRkb24uU3R5bGVzaGVldC5hZGRUaGVtZUZpbGVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogbWFwQ2xhc3NOYW1lIHx8IGNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbGRlcnMgIDogdGhlbWVGb2xkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93SWRcbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5jb3VudExvYWRpbmdUaGVtZUZpbGVzLS1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmVyeSBkb20gZXZlbnQgd2lsbCBnZXQgZm9yd2FyZGVkIGFzIGEgd29ya2VyIG1lc3NhZ2UgZnJvbSBtYWluIGFuZCBlbmRzIHVwIGhlcmUgZmlyc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSB1c2VmdWwgZXZlbnQgcHJvcGVydGllcywgZGlmZmVycyBmb3IgZGlmZmVyZW50IGV2ZW50IHR5cGVzLiBTZWUgTmVvLm1haW4uRG9tRXZlbnRzLlxuICAgICAqL1xuICAgIG9uRG9tRXZlbnQoZGF0YSkge1xuICAgICAgICBEb21FdmVudE1hbmFnZXIuZmlyZShkYXRhKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2ZXJ5IFVSTCBoYXNoLWNoYW5nZSB3aWxsIGNyZWF0ZSBhIHBvc3QgbWVzc2FnZSBpbiBtYWluIGFuZCBlbmQgdXAgaGVyZSBmaXJzdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBwYXJzZWQga2V5LXZhbHVlIHBhaXJzIGZvciBlYWNoIGhhc2ggdmFsdWVcbiAgICAgKi9cbiAgICBvbkhhc2hDaGFuZ2UoZGF0YSkge1xuICAgICAgICBIYXNoSGlzdG9yeS5wdXNoKGRhdGEuZGF0YSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RhcnRpbmcgcG9pbnQgZm9yIGFwcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uTG9hZEFwcGxpY2F0aW9uKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y29uZmlnfSAgPSBOZW8sXG4gICAgICAgICAgICB7YXBwUGF0aH0gPSBjb25maWc7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5lbnZpcm9ubWVudCAhPT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgYXBwUGF0aCA9IGFwcFBhdGguc3RhcnRzV2l0aCgnLycpID8gYXBwUGF0aC5zdWJzdHJpbmcoMSkgOiBhcHBQYXRoXG4gICAgICAgIH1cblxuICAgICAgICBtZS5pbXBvcnRBcHAoYXBwUGF0aCkudGhlbihtb2R1bGUgPT4ge1xuICAgICAgICAgICAgbW9kdWxlLm9uU3RhcnQoKTtcblxuICAgICAgICAgICAgLy8gc2hvcnQgZGVsYXkgdG8gZW5zdXJlIENvbXBvbmVudCBDb250cm9sbGVycyBhcmUgcmVhZHlcbiAgICAgICAgICAgIGNvbmZpZy5oYXNoICYmIG1lLnRpbWVvdXQoNSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgSGFzaEhpc3RvcnkucHVzaChjb25maWcuaGFzaCk7XG4gICAgICAgICAgICAgICAgLy8gYXBwcyB3aGljaCB3aWxsIGdldCBjcmVhdGVkIGxhdGVyIG11c3Qgbm90IHVzZSBvdXRkYXRlZCBoYXNoIHZhbHVlc1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuaGFzaFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaXJlIGV2ZW50IG9uIGFsbCBhcHBzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5hbmdsZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmxheW91dCBsYW5kc2NhcGV8cG9ydHJhaXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS50eXBlIGxhbmRzY2FwZS1wcmltYXJ5fGxhbmRzY2FwZS1zZWNvbmRhcnl8cG9ydHJhaXQtcHJpbWFyeXxwb3J0cmFpdC1zZWNvbmRhcnlcbiAgICAgKi9cbiAgICBvbk9yaWVudGF0aW9uQ2hhbmdlKGRhdGEpIHtcbiAgICAgICAgT2JqZWN0LnZhbHVlcyhOZW8uYXBwcykuZm9yRWFjaChhcHAgPT4ge1xuICAgICAgICAgICAgYXBwLmZpcmUoJ29yaWVudGF0aW9uY2hhbmdlJywgZGF0YS5kYXRhKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtc2dcbiAgICAgKi9cbiAgICBvblJlZ2lzdGVyTmVvQ29uZmlnKG1zZykge1xuICAgICAgICBzdXBlci5vblJlZ2lzdGVyTmVvQ29uZmlnKG1zZyk7XG5cbiAgICAgICAgbGV0IHtjb25maWd9ID0gTmVvLFxuICAgICAgICAgICAge2RhdGF9ICAgPSBtc2csXG4gICAgICAgICAgICB1cmwgICAgICA9ICdyZXNvdXJjZXMvdGhlbWUtbWFwLmpzb24nO1xuXG4gICAgICAgIE5lby53aW5kb3dDb25maWdzID0gTmVvLndpbmRvd0NvbmZpZ3MgfHwge307XG5cbiAgICAgICAgTmVvLndpbmRvd0NvbmZpZ3NbZGF0YS53aW5kb3dJZF0gPSBkYXRhO1xuXG4gICAgICAgIGlmIChjb25maWcuZW52aXJvbm1lbnQgPT09ICdkZXZlbG9wbWVudCcgfHwgY29uZmlnLmVudmlyb25tZW50ID09PSAnZGlzdC9lc20nKSB7XG4gICAgICAgICAgICB1cmwgPSBgLi4vLi4vJHt1cmx9YFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy53b3JrZXJCYXNlUGF0aD8uaW5jbHVkZXMoJ25vZGVfbW9kdWxlcycpKSB7XG4gICAgICAgICAgICB1cmwgPSBgLi4vLi4vJHt1cmx9YFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVybFswXSAhPT0gJy4nKSB7XG4gICAgICAgICAgICB1cmwgPSBgLi8ke3VybH1gXG4gICAgICAgIH1cblxuICAgICAgICBmZXRjaCh1cmwpXG4gICAgICAgICAgICAudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5qc29uKCkpXG4gICAgICAgICAgICAudGhlbihkYXRhID0+IHt0aGlzLmNyZWF0ZVRoZW1lTWFwKGRhdGEpfSk7XG5cbiAgICAgICAgY29uZmlnLnJlbW90ZXNBcGlVcmwgICYmIGltcG9ydCgnLi4vcmVtb3Rlcy9BcGkubWpzJykudGhlbihtb2R1bGUgPT4gbW9kdWxlLmRlZmF1bHQubG9hZCgpKTtcbiAgICAgICAgIWNvbmZpZy51c2VWZG9tV29ya2VyICYmIGltcG9ydCgnLi4vdmRvbS9IZWxwZXIubWpzJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbXNnXG4gICAgICovXG4gICAgb25SZWdpc3RlclBvcnQobXNnKSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIHBvcnQgPSBtc2cudHJhbnNmZXI7XG5cbiAgICAgICAgcG9ydC5vbm1lc3NhZ2UgPSBtZS5vbk1lc3NhZ2UuYmluZChtZSk7XG5cbiAgICAgICAgbWUuY2hhbm5lbFBvcnRzW21zZy5vcmlnaW5dID0gcG9ydFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25XaW5kb3dQb3NpdGlvbkNoYW5nZShkYXRhKSB7XG4gICAgICAgIHRoaXMuZmlyZU1haW5WaWV3c0V2ZW50KCd3aW5kb3dQb3NpdGlvbkNoYW5nZScsIGRhdGEuZGF0YSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPbmx5IG5lZWRlZCBmb3IgU2hhcmVkV29ya2Vyc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcHBOYW1lXG4gICAgICovXG4gICAgcmVnaXN0ZXJBcHAoYXBwTmFtZSkge1xuICAgICAgICAvLyByZWdpc3RlciB0aGUgbmFtZSBhcyBmYXN0IGFzIHBvc3NpYmxlXG4gICAgICAgIHRoaXMub25SZWdpc3RlckFwcCh7IGFwcE5hbWUgfSk7XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2UoJ21haW4nLCB7YWN0aW9uOiAncmVnaXN0ZXJBcHBOYW1lJywgYXBwTmFtZX0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5yZWdpc3RlciB0aGUgYXBwIGZyb20gdGhlIENTUyBtYXBcbiAgICAgKiBPbmx5IG5lZWRlZCBmb3IgU2hhcmVkV29ya2Vyc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcHBOYW1lXG4gICAgICovXG4gICAgcmVtb3ZlQXBwRnJvbVRoZW1lTWFwKGFwcE5hbWUpIHtcbiAgICAgICAgZGVsZXRlIE5lby5jc3NNYXBbYXBwTmFtZS50b0xvd2VyQ2FzZSgpXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcmVzb2x2ZVRoZW1lRmlsZXNDYWNoZSgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS50aGVtZUZpbGVzQ2FjaGUuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIG1lLmluc2VydFRoZW1lRmlsZXMoLi4uaXRlbSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUudGhlbWVGaWxlc0NhY2hlID0gW11cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgY29uZmlncyBvZiBhbnkgYXBwIHJlYWxtIGJhc2VkIE5lbyBpbnN0YW5jZSBmcm9tIG1haW5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmlkXG4gICAgICovXG4gICAgc2V0Q29uZmlncyhkYXRhKSB7XG4gICAgICAgIGxldCBpbnN0YW5jZSA9IE5lby5nZXQoZGF0YS5pZCk7XG5cbiAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgICBkZWxldGUgZGF0YS5pZDtcbiAgICAgICAgICAgIGluc3RhbmNlLnNldChkYXRhKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEua2V5XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtkYXRhLnByaW9yaXR5XSBvcHRpb25hbGx5IHBhc3MgJ2ltcG9ydGFudCdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS50aGVtZT1OZW8uY29uZmlnLnRoZW1lc1swXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLnZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEud2luZG93SWRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIGFzeW5jIHNldENzc1ZhcmlhYmxlKGRhdGEpIHtcbiAgICAgICAgbGV0IFN0eWxlc2hlZXQgPSBhd2FpdCB0aGlzLmdldEFkZG9uKCdTdHlsZXNoZWV0JywgZGF0YS53aW5kb3dJZCksXG4gICAgICAgICAgICB0aGVtZSAgICAgID0gZGF0YS50aGVtZSB8fCBOZW8uY29uZmlnLnRoZW1lcz8uWzBdO1xuXG4gICAgICAgIGlmICh0aGVtZS5zdGFydHNXaXRoKCduZW8tJykpIHtcbiAgICAgICAgICAgIHRoZW1lID0gdGhlbWUuc3Vic3RyaW5nKDQpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gU3R5bGVzaGVldC5zZXRDc3NWYXJpYWJsZSh7dGhlbWUsIC4uLmRhdGF9KVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQXBwKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==