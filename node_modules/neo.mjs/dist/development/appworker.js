/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./. lazy recursive ^\\.\\/.*\\.mjs$ include: (?:\\/%7C\\\\)app.mjs$":
/*!************************************************************************************!*\
  !*** ././ lazy ^\.\/.*\.mjs$ include: (?:\/%7C\\)app.mjs$ strict namespace object ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./apps/colors/app.mjs": [
		"./apps/colors/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-src_grid_Container_mjs",
		"vendors-apps_colors_app_mjs"
	],
	"./apps/colors/childapps/widget/app.mjs": [
		"./apps/colors/childapps/widget/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"apps_colors_childapps_widget_app_mjs"
	],
	"./apps/covid/app.mjs": [
		"./apps/covid/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-src_tab_Container_mjs",
		"vendors-apps_covid_app_mjs-src_selection_Model_mjs-src_toolbar_Base_mjs"
	],
	"./apps/email/app.mjs": [
		"./apps/email/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_grid_Container_mjs",
		"vendors-src_functional_component_Base_mjs",
		"vendors-apps_email_app_mjs-src_toolbar_Base_mjs"
	],
	"./apps/finance/app.mjs": [
		"./apps/finance/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-src_grid_Container_mjs",
		"vendors-apps_finance_app_mjs"
	],
	"./apps/form/app.mjs": [
		"./apps/form/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-src_form_Container_mjs",
		"vendors-apps_form_app_mjs-src_selection_Model_mjs"
	],
	"./apps/portal/app.mjs": [
		"./apps/portal/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-src_layout_Cube_mjs",
		"vendors-apps_portal_app_mjs"
	],
	"./apps/portal/childapps/preview/app.mjs": [
		"./apps/portal/childapps/preview/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"apps_portal_childapps_preview_app_mjs"
	],
	"./apps/realworld/app.mjs": [
		"./apps/realworld/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-apps_realworld_app_mjs"
	],
	"./apps/realworld2/app.mjs": [
		"./apps/realworld2/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_tab_Container_mjs",
		"vendors-src_form_Container_mjs",
		"vendors-src_component_Helix_mjs-src_container_Panel_mjs-src_form_field_Range_mjs",
		"vendors-src_component_Gallery_mjs",
		"vendors-examples_component_helix_Viewport_mjs-src_selection_Model_mjs-src_toolbar_Base_mjs",
		"vendors-examples_component_gallery_MainContainer_mjs",
		"vendors-apps_realworld2_app_mjs"
	],
	"./apps/route/app.mjs": [
		"./apps/route/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-apps_route_app_mjs"
	],
	"./apps/sharedcovid/app.mjs": [
		"./apps/sharedcovid/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-src_tab_Container_mjs",
		"vendors-apps_sharedcovid_app_mjs-src_selection_Model_mjs-src_toolbar_Base_mjs"
	],
	"./apps/sharedcovid/childapps/sharedcovidchart/app.mjs": [
		"./apps/sharedcovid/childapps/sharedcovidchart/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"apps_sharedcovid_childapps_sharedcovidchart_app_mjs"
	],
	"./apps/sharedcovid/childapps/sharedcovidgallery/app.mjs": [
		"./apps/sharedcovid/childapps/sharedcovidgallery/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"apps_sharedcovid_childapps_sharedcovidgallery_app_mjs"
	],
	"./apps/sharedcovid/childapps/sharedcovidhelix/app.mjs": [
		"./apps/sharedcovid/childapps/sharedcovidhelix/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"apps_sharedcovid_childapps_sharedcovidhelix_app_mjs"
	],
	"./apps/sharedcovid/childapps/sharedcovidmap/app.mjs": [
		"./apps/sharedcovid/childapps/sharedcovidmap/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"apps_sharedcovid_childapps_sharedcovidmap_app_mjs"
	],
	"./apps/shareddialog/app.mjs": [
		"./apps/shareddialog/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_dialog_Base_mjs",
		"vendors-apps_shareddialog_app_mjs-src_container_Panel_mjs"
	],
	"./apps/shareddialog/childapps/shareddialog2/app.mjs": [
		"./apps/shareddialog/childapps/shareddialog2/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-apps_shareddialog_childapps_shareddialog2_app_mjs"
	],
	"./docs/app.mjs": [
		"./docs/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_tab_Container_mjs",
		"vendors-src_draggable_DragZone_mjs",
		"vendors-src_selection_Model_mjs-src_tree_List_mjs",
		"vendors-docs_app_view_MainContainer_mjs",
		"vendors-docs_app_mjs-src_container_Viewport_mjs-src_controller_Component_mjs-src_toolbar_Base_mjs"
	],
	"./examples/button/base/app.mjs": [
		"./examples/button/base/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-examples_button_base_app_mjs-src_selection_Model_mjs"
	],
	"./examples/button/effect/app.mjs": [
		"./examples/button/effect/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-examples_button_effect_app_mjs-src_selection_Model_mjs"
	],
	"./examples/button/split/app.mjs": [
		"./examples/button/split/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-examples_button_split_app_mjs-src_selection_Model_mjs"
	],
	"./examples/calendar/basic/app.mjs": [
		"./examples/calendar/basic/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-src_component_DateSelector_mjs",
		"vendors-src_form_Container_mjs",
		"vendors-src_list_Color_mjs-src_selection_Model_mjs",
		"vendors-src_form_field_Time_mjs",
		"vendors-src_calendar_view_MainContainerStateProvider_mjs-src_container_Viewport_mjs",
		"vendors-examples_calendar_basic_app_mjs"
	],
	"./examples/calendar/weekview/app.mjs": [
		"./examples/calendar/weekview/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-src_calendar_view_week_Component_mjs",
		"vendors-src_calendar_view_MainContainerStateProvider_mjs-src_container_Viewport_mjs",
		"examples_calendar_weekview_app_mjs-src_util_Date_mjs"
	],
	"./examples/charts/app.mjs": [
		"./examples/charts/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"examples_charts_app_mjs"
	],
	"./examples/component/canvas/app.mjs": [
		"./examples/component/canvas/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"examples_component_canvas_app_mjs"
	],
	"./examples/component/carousel/app.mjs": [
		"./examples/component/carousel/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-examples_component_carousel_app_mjs"
	],
	"./examples/component/chip/app.mjs": [
		"./examples/component/chip/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"examples_component_chip_app_mjs"
	],
	"./examples/component/circle/app.mjs": [
		"./examples/component/circle/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_component_Circle_mjs",
		"examples_component_circle_app_mjs"
	],
	"./examples/component/clock/app.mjs": [
		"./examples/component/clock/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_Time_mjs",
		"vendors-examples_component_clock_app_mjs-src_form_field_Picker_mjs-src_selection_Model_mjs"
	],
	"./examples/component/coronaGallery/app.mjs": [
		"./examples/component/coronaGallery/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_component_Gallery_mjs",
		"vendors-examples_component_coronaGallery_Viewport_mjs-src_selection_Model_mjs",
		"examples_component_coronaGallery_app_mjs"
	],
	"./examples/component/coronaHelix/app.mjs": [
		"./examples/component/coronaHelix/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_component_Helix_mjs-src_container_Panel_mjs-src_form_field_Range_mjs",
		"vendors-examples_component_coronaHelix_app_mjs-src_selection_Model_mjs-src_toolbar_Base_mjs"
	],
	"./examples/component/dateSelector/app.mjs": [
		"./examples/component/dateSelector/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_component_DateSelector_mjs",
		"vendors-examples_component_dateSelector_app_mjs-src_selection_Model_mjs"
	],
	"./examples/component/gallery/app.mjs": [
		"./examples/component/gallery/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_component_Gallery_mjs",
		"vendors-examples_component_gallery_MainContainer_mjs",
		"vendors-examples_component_gallery_app_mjs-src_container_Panel_mjs-src_container_Viewport_mjs-bd568a"
	],
	"./examples/component/helix/app.mjs": [
		"./examples/component/helix/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_component_Helix_mjs-src_container_Panel_mjs-src_form_field_Range_mjs",
		"vendors-examples_component_helix_Viewport_mjs-src_selection_Model_mjs-src_toolbar_Base_mjs",
		"examples_component_helix_app_mjs"
	],
	"./examples/component/magicmovetext/app.mjs": [
		"./examples/component/magicmovetext/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_component_MagicMoveText_mjs",
		"examples_component_magicmovetext_app_mjs"
	],
	"./examples/component/multiWindowCoronaGallery/app.mjs": [
		"./examples/component/multiWindowCoronaGallery/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_component_Gallery_mjs",
		"vendors-examples_component_coronaGallery_Viewport_mjs-src_selection_Model_mjs",
		"examples_component_multiWindowCoronaGallery_app_mjs"
	],
	"./examples/component/multiWindowCoronaGallery/childapp/app.mjs": [
		"./examples/component/multiWindowCoronaGallery/childapp/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"examples_component_multiWindowCoronaGallery_childapp_app_mjs"
	],
	"./examples/component/multiWindowHelix/app.mjs": [
		"./examples/component/multiWindowHelix/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_component_Helix_mjs-src_container_Panel_mjs-src_form_field_Range_mjs",
		"vendors-examples_component_helix_Viewport_mjs-src_selection_Model_mjs-src_toolbar_Base_mjs",
		"examples_component_multiWindowHelix_app_mjs"
	],
	"./examples/component/multiWindowHelix/childapp/app.mjs": [
		"./examples/component/multiWindowHelix/childapp/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"examples_component_multiWindowHelix_childapp_app_mjs"
	],
	"./examples/component/mwc/button/app.mjs": [
		"./examples/component/mwc/button/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"examples_component_mwc_button_app_mjs"
	],
	"./examples/component/mwc/buttons/app.mjs": [
		"./examples/component/mwc/buttons/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_tab_Container_mjs",
		"vendors-examples_component_mwc_buttons_app_mjs-src_toolbar_Base_mjs"
	],
	"./examples/component/mwc/textField/app.mjs": [
		"./examples/component/mwc/textField/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"examples_component_mwc_textField_app_mjs"
	],
	"./examples/component/mwc/textFields/app.mjs": [
		"./examples/component/mwc/textFields/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_tab_Container_mjs",
		"vendors-examples_component_mwc_textFields_app_mjs-src_toolbar_Base_mjs"
	],
	"./examples/component/process/app.mjs": [
		"./examples/component/process/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_list_Color_mjs-src_selection_Model_mjs",
		"vendors-examples_component_process_app_mjs"
	],
	"./examples/component/process/realWorldExample/app.mjs": [
		"./examples/component/process/realWorldExample/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_form_Container_mjs",
		"vendors-src_component_Toast_mjs",
		"vendors-examples_component_process_realWorldExample_app_mjs-src_selection_Model_mjs"
	],
	"./examples/component/progress/app.mjs": [
		"./examples/component/progress/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"examples_component_progress_app_mjs"
	],
	"./examples/component/splitter/app.mjs": [
		"./examples/component/splitter/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_draggable_DragZone_mjs",
		"examples_component_splitter_app_mjs"
	],
	"./examples/component/statusbadge/app.mjs": [
		"./examples/component/statusbadge/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-examples_component_statusbadge_app_mjs"
	],
	"./examples/component/timer/app.mjs": [
		"./examples/component/timer/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_list_Color_mjs-src_selection_Model_mjs",
		"vendors-examples_component_timer_app_mjs"
	],
	"./examples/component/toast/app.mjs": [
		"./examples/component/toast/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_form_Container_mjs",
		"vendors-src_component_Toast_mjs",
		"vendors-examples_component_toast_app_mjs-src_selection_Model_mjs"
	],
	"./examples/component/video/app.mjs": [
		"./examples/component/video/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_component_Toast_mjs",
		"vendors-examples_component_video_app_mjs"
	],
	"./examples/component/wrapper/cesiumJS/app.mjs": [
		"./examples/component/wrapper/cesiumJS/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-examples_component_wrapper_cesiumJS_app_mjs"
	],
	"./examples/component/wrapper/googleMaps/app.mjs": [
		"./examples/component/wrapper/googleMaps/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_dialog_Base_mjs",
		"vendors-examples_component_wrapper_googleMaps_app_mjs-src_container_Panel_mjs"
	],
	"./examples/component/wrapper/monacoEditor/app.mjs": [
		"./examples/component/wrapper/monacoEditor/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_component_wrapper_MonacoEditor_mjs",
		"examples_component_wrapper_monacoEditor_app_mjs"
	],
	"./examples/container/accordion/app.mjs": [
		"./examples/container/accordion/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-examples_container_accordion_app_mjs"
	],
	"./examples/container/base/app.mjs": [
		"./examples/container/base/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"examples_container_base_app_mjs"
	],
	"./examples/core/config/app.mjs": [
		"./examples/core/config/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-examples_core_config_app_mjs"
	],
	"./examples/dashboard/app.mjs": [
		"./examples/dashboard/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"examples_dashboard_app_mjs"
	],
	"./examples/date/selectorContainer/app.mjs": [
		"./examples/date/selectorContainer/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-src_component_DateSelector_mjs",
		"vendors-examples_date_selectorContainer_app_mjs-src_selection_Model_mjs"
	],
	"./examples/dialog/app.mjs": [
		"./examples/dialog/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_dialog_Base_mjs",
		"vendors-examples_dialog_app_mjs-src_container_Panel_mjs-src_selection_Model_mjs"
	],
	"./examples/fieldWithPrefix/app.mjs": [
		"./examples/fieldWithPrefix/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-examples_fieldWithPrefix_app_mjs-src_selection_Model_mjs"
	],
	"./examples/fields/app.mjs": [
		"./examples/fields/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_tab_Container_mjs",
		"vendors-src_component_DateSelector_mjs",
		"vendors-src_form_Container_mjs",
		"vendors-src_form_field_Time_mjs",
		"vendors-examples_fields_app_mjs-src_selection_Model_mjs-src_toolbar_Base_mjs"
	],
	"./examples/form/field/checkbox/app.mjs": [
		"./examples/form/field/checkbox/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"examples_form_field_checkbox_app_mjs"
	],
	"./examples/form/field/chip/app.mjs": [
		"./examples/form/field/chip/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-examples_form_field_chip_app_mjs-src_selection_Model_mjs"
	],
	"./examples/form/field/color/app.mjs": [
		"./examples/form/field/color/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_list_Color_mjs-src_selection_Model_mjs",
		"vendors-examples_form_field_color_app_mjs"
	],
	"./examples/form/field/combobox/app.mjs": [
		"./examples/form/field/combobox/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-examples_form_field_combobox_app_mjs-src_selection_Model_mjs"
	],
	"./examples/form/field/date/app.mjs": [
		"./examples/form/field/date/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_component_DateSelector_mjs",
		"vendors-examples_form_field_date_app_mjs-src_selection_Model_mjs"
	],
	"./examples/form/field/email/app.mjs": [
		"./examples/form/field/email/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"examples_form_field_email_app_mjs"
	],
	"./examples/form/field/fileupload/app.mjs": [
		"./examples/form/field/fileupload/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-examples_form_field_fileupload_app_mjs"
	],
	"./examples/form/field/number/app.mjs": [
		"./examples/form/field/number/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"examples_form_field_number_app_mjs"
	],
	"./examples/form/field/picker/app.mjs": [
		"./examples/form/field/picker/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-examples_form_field_picker_app_mjs"
	],
	"./examples/form/field/radio/app.mjs": [
		"./examples/form/field/radio/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"examples_form_field_radio_app_mjs"
	],
	"./examples/form/field/switch/app.mjs": [
		"./examples/form/field/switch/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"examples_form_field_switch_app_mjs"
	],
	"./examples/form/field/text/app.mjs": [
		"./examples/form/field/text/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-examples_form_field_text_app_mjs"
	],
	"./examples/form/field/textarea/app.mjs": [
		"./examples/form/field/textarea/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-examples_form_field_textarea_app_mjs"
	],
	"./examples/form/field/time/app.mjs": [
		"./examples/form/field/time/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_Time_mjs",
		"vendors-examples_form_field_time_app_mjs-src_form_field_Picker_mjs-src_selection_Model_mjs"
	],
	"./examples/form/field/trigger/copyToClipboard/app.mjs": [
		"./examples/form/field/trigger/copyToClipboard/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-examples_form_field_trigger_copyToClipboard_app_mjs"
	],
	"./examples/form/field/url/app.mjs": [
		"./examples/form/field/url/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"examples_form_field_url_app_mjs"
	],
	"./examples/form/fieldset/app.mjs": [
		"./examples/form/fieldset/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_form_Container_mjs",
		"vendors-examples_form_fieldset_app_mjs"
	],
	"./examples/functional/button/base/app.mjs": [
		"./examples/functional/button/base/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_functional_component_Base_mjs",
		"vendors-examples_functional_button_base_app_mjs-src_selection_Model_mjs"
	],
	"./examples/functional/defineComponent/app.mjs": [
		"./examples/functional/defineComponent/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_functional_component_Base_mjs",
		"examples_functional_defineComponent_app_mjs"
	],
	"./examples/functional/hostComponent/app.mjs": [
		"./examples/functional/hostComponent/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_functional_component_Base_mjs",
		"vendors-examples_functional_hostComponent_app_mjs"
	],
	"./examples/functional/nestedTemplateComponent/app.mjs": [
		"./examples/functional/nestedTemplateComponent/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_functional_component_Base_mjs",
		"vendors-examples_functional_nestedTemplateComponent_app_mjs"
	],
	"./examples/functional/templateComponent/app.mjs": [
		"./examples/functional/templateComponent/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_functional_component_Base_mjs",
		"vendors-examples_functional_templateComponent_app_mjs"
	],
	"./examples/grid/animatedRowSorting/app.mjs": [
		"./examples/grid/animatedRowSorting/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_grid_Container_mjs",
		"vendors-examples_grid_animatedRowSorting_app_mjs"
	],
	"./examples/grid/bigData/app.mjs": [
		"./examples/grid/bigData/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_tab_Container_mjs",
		"vendors-src_grid_Container_mjs",
		"vendors-src_form_field_Radio_mjs-src_selection_grid_CellColumnModel_mjs-src_selection_grid_Ce-f3ad8f",
		"vendors-examples_grid_bigData_app_mjs-src_toolbar_Base_mjs"
	],
	"./examples/grid/cellEditing/app.mjs": [
		"./examples/grid/cellEditing/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-src_component_DateSelector_mjs",
		"vendors-src_grid_Container_mjs",
		"vendors-src_form_field_Radio_mjs-src_selection_grid_CellColumnModel_mjs-src_selection_grid_Ce-f3ad8f",
		"vendors-examples_grid_cellEditing_app_mjs"
	],
	"./examples/grid/container/app.mjs": [
		"./examples/grid/container/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_grid_Container_mjs",
		"vendors-src_form_field_Radio_mjs-src_selection_grid_CellColumnModel_mjs-src_selection_grid_Ce-f3ad8f",
		"vendors-examples_grid_container_app_mjs"
	],
	"./examples/grid/covid/app.mjs": [
		"./examples/grid/covid/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_grid_Container_mjs",
		"vendors-examples_grid_covid_app_mjs-src_toolbar_Base_mjs"
	],
	"./examples/grid/nestedRecordFields/app.mjs": [
		"./examples/grid/nestedRecordFields/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-src_grid_Container_mjs",
		"vendors-src_component_Toast_mjs",
		"vendors-examples_grid_nestedRecordFields_app_mjs-src_toolbar_Base_mjs"
	],
	"./examples/layout/card/app.mjs": [
		"./examples/layout/card/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"examples_layout_card_app_mjs"
	],
	"./examples/layout/cube/app.mjs": [
		"./examples/layout/cube/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_layout_Cube_mjs",
		"vendors-examples_layout_cube_app_mjs"
	],
	"./examples/layout/form/app.mjs": [
		"./examples/layout/form/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_form_Container_mjs",
		"vendors-examples_layout_form_app_mjs"
	],
	"./examples/list/animate/app.mjs": [
		"./examples/list/animate/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-examples_list_animate_app_mjs-src_selection_Model_mjs"
	],
	"./examples/list/base/app.mjs": [
		"./examples/list/base/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-examples_list_base_app_mjs-src_selection_Model_mjs"
	],
	"./examples/list/chip/app.mjs": [
		"./examples/list/chip/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_list_Chip_mjs-src_selection_Model_mjs",
		"examples_list_chip_app_mjs"
	],
	"./examples/list/circle/app.mjs": [
		"./examples/list/circle/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_component_Circle_mjs",
		"vendors-examples_list_circle_app_mjs"
	],
	"./examples/list/color/app.mjs": [
		"./examples/list/color/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_list_Color_mjs-src_selection_Model_mjs",
		"examples_list_color_app_mjs"
	],
	"./examples/menu/list/app.mjs": [
		"./examples/menu/list/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_menu_List_mjs",
		"vendors-examples_menu_list_app_mjs-src_selection_Model_mjs"
	],
	"./examples/menu/panel/app.mjs": [
		"./examples/menu/panel/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_menu_List_mjs",
		"vendors-examples_menu_panel_app_mjs-src_selection_Model_mjs"
	],
	"./examples/panel/app.mjs": [
		"./examples/panel/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-examples_panel_app_mjs"
	],
	"./examples/popover/app.mjs": [
		"./examples/popover/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"examples_popover_app_mjs"
	],
	"./examples/preloadingAssets/app.mjs": [
		"./examples/preloadingAssets/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_tab_Container_mjs",
		"vendors-examples_preloadingAssets_app_mjs-src_toolbar_Base_mjs"
	],
	"./examples/remotesApi/basic/app.mjs": [
		"./examples/remotesApi/basic/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-examples_remotesApi_basic_app_mjs"
	],
	"./examples/serverside/gridContainer/app.mjs": [
		"./examples/serverside/gridContainer/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"examples_serverside_gridContainer_app_mjs"
	],
	"./examples/serverside/toolbarItems/app.mjs": [
		"./examples/serverside/toolbarItems/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-examples_serverside_toolbarItems_app_mjs"
	],
	"./examples/sitemap/app.mjs": [
		"./examples/sitemap/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-examples_sitemap_app_mjs"
	],
	"./examples/stateProvider/advanced/app.mjs": [
		"./examples/stateProvider/advanced/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-examples_stateProvider_advanced_app_mjs"
	],
	"./examples/stateProvider/dialog/app.mjs": [
		"./examples/stateProvider/dialog/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-examples_stateProvider_dialog_app_mjs"
	],
	"./examples/stateProvider/extendedClass/app.mjs": [
		"./examples/stateProvider/extendedClass/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-examples_stateProvider_extendedClass_app_mjs"
	],
	"./examples/stateProvider/inline/app.mjs": [
		"./examples/stateProvider/inline/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-examples_stateProvider_inline_app_mjs"
	],
	"./examples/stateProvider/inlineNoStateProvider/app.mjs": [
		"./examples/stateProvider/inlineNoStateProvider/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-examples_stateProvider_inlineNoStateProvider_app_mjs"
	],
	"./examples/stateProvider/multiWindow/app.mjs": [
		"./examples/stateProvider/multiWindow/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-examples_stateProvider_multiWindow_app_mjs"
	],
	"./examples/stateProvider/multiWindow2/app.mjs": [
		"./examples/stateProvider/multiWindow2/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"examples_stateProvider_multiWindow2_app_mjs"
	],
	"./examples/stateProvider/nestedData/app.mjs": [
		"./examples/stateProvider/nestedData/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-examples_stateProvider_nestedData_app_mjs"
	],
	"./examples/stateProvider/table/app.mjs": [
		"./examples/stateProvider/table/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-src_table_Container_mjs",
		"vendors-examples_stateProvider_table_app_mjs-src_selection_Model_mjs-src_toolbar_Base_mjs"
	],
	"./examples/stateProvider/twoWay/app.mjs": [
		"./examples/stateProvider/twoWay/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_state_Provider_mjs",
		"examples_stateProvider_twoWay_app_mjs"
	],
	"./examples/tab/container/app.mjs": [
		"./examples/tab/container/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_tab_Container_mjs",
		"vendors-examples_tab_container_app_mjs"
	],
	"./examples/table/cellEditing/app.mjs": [
		"./examples/table/cellEditing/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-src_table_Container_mjs",
		"vendors-src_component_DateSelector_mjs",
		"vendors-src_form_field_Radio_mjs-src_selection_Model_mjs-src_selection_table_CellModel_mjs",
		"vendors-examples_table_cellEditing_app_mjs"
	],
	"./examples/table/container/app.mjs": [
		"./examples/table/container/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_table_Container_mjs",
		"vendors-src_form_field_Radio_mjs-src_selection_Model_mjs-src_selection_table_CellModel_mjs",
		"vendors-examples_table_container_app_mjs"
	],
	"./examples/table/covid/app.mjs": [
		"./examples/table/covid/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_table_Container_mjs",
		"vendors-examples_table_covid_app_mjs-src_selection_Model_mjs-src_toolbar_Base_mjs"
	],
	"./examples/table/nestedRecordFields/app.mjs": [
		"./examples/table/nestedRecordFields/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-src_table_Container_mjs",
		"vendors-examples_table_nestedRecordFields_app_mjs-src_selection_Model_mjs-src_toolbar_Base_mjs"
	],
	"./examples/tableFiltering/app.mjs": [
		"./examples/tableFiltering/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_table_Container_mjs",
		"vendors-src_component_DateSelector_mjs",
		"vendors-src_form_field_Radio_mjs-src_selection_Model_mjs-src_selection_table_CellModel_mjs",
		"vendors-examples_tableFiltering_app_mjs-src_toolbar_Base_mjs"
	],
	"./examples/tablePerformance/app.mjs": [
		"./examples/tablePerformance/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_table_Container_mjs",
		"vendors-examples_tablePerformance_app_mjs-src_selection_Model_mjs-src_toolbar_Base_mjs"
	],
	"./examples/tableStore/app.mjs": [
		"./examples/tableStore/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-src_table_Container_mjs",
		"vendors-src_form_field_Radio_mjs-src_selection_Model_mjs-src_selection_table_CellModel_mjs",
		"vendors-examples_tableStore_app_mjs-src_toolbar_Base_mjs"
	],
	"./examples/tabs/app.mjs": [
		"./examples/tabs/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_tab_Container_mjs",
		"vendors-src_table_Container_mjs",
		"vendors-examples_tabs_app_mjs-src_selection_Model_mjs-src_toolbar_Base_mjs"
	],
	"./examples/todoList/version1/app.mjs": [
		"./examples/todoList/version1/app.mjs",
		"vendors-src_component_Base_mjs",
		"examples_todoList_version1_app_mjs"
	],
	"./examples/todoList/version2/app.mjs": [
		"./examples/todoList/version2/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-examples_todoList_version2_app_mjs-src_selection_Model_mjs"
	],
	"./examples/toolbar/breadcrumb/app.mjs": [
		"./examples/toolbar/breadcrumb/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-examples_toolbar_breadcrumb_app_mjs"
	],
	"./examples/toolbar/paging/app.mjs": [
		"./examples/toolbar/paging/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-src_table_Container_mjs",
		"vendors-examples_toolbar_paging_app_mjs-src_selection_Model_mjs"
	],
	"./examples/tree/app.mjs": [
		"./examples/tree/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_selection_Model_mjs-src_tree_List_mjs",
		"examples_tree_app_mjs"
	],
	"./examples/treeAccordion/app.mjs": [
		"./examples/treeAccordion/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_form_field_Number_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_form_field_CheckBox_mjs",
		"vendors-examples_ConfigurationViewport_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_state_Provider_mjs",
		"vendors-src_selection_Model_mjs-src_tree_List_mjs",
		"vendors-examples_treeAccordion_app_mjs"
	],
	"./examples/videoMove/app.mjs": [
		"./examples/videoMove/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"examples_videoMove_app_mjs"
	],
	"./examples/viewport/app.mjs": [
		"./examples/viewport/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_tab_Container_mjs",
		"vendors-examples_viewport_app_mjs-src_toolbar_Base_mjs"
	],
	"./examples/worker/task/app.mjs": [
		"./examples/worker/task/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"examples_worker_task_app_mjs"
	],
	"./test/components/app.mjs": [
		"./test/components/app.mjs",
		"vendors-src_component_Base_mjs",
		"vendors-src_container_Base_mjs",
		"vendors-src_button_Base_mjs",
		"vendors-src_form_field_Text_mjs",
		"vendors-src_form_field_Base_mjs",
		"vendors-src_data_Store_mjs",
		"vendors-src_list_Base_mjs",
		"vendors-src_form_field_ComboBox_mjs",
		"vendors-src_component_DateSelector_mjs",
		"vendors-src_list_Chip_mjs-src_selection_Model_mjs",
		"test_components_app_mjs"
	]
};
function webpackAsyncContext(req) {
	if(!__webpack_require__.o(map, req)) {
		return Promise.resolve().then(() => {
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		});
	}

	var ids = map[req], id = ids[0];
	return Promise.all(ids.slice(1).map(__webpack_require__.e)).then(() => {
		return __webpack_require__(id);
	});
}
webpackAsyncContext.keys = () => (Object.keys(map));
webpackAsyncContext.id = "./. lazy recursive ^\\.\\/.*\\.mjs$ include: (?:\\/%7C\\\\)app.mjs$";
module.exports = webpackAsyncContext;

/***/ }),

/***/ "./src/DefaultConfig.mjs":
/*!*******************************!*\
  !*** ./src/DefaultConfig.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const Neo = globalThis.Neo || {};

Neo.config = Neo.config || {};

/**
 * Config object for the neo.mjs framework which will get passed to all workers
 * You can change the configs, e.g. inside the index.html of your app
 * @memberOf module:Neo
 * @name config
 * @type Object
 */
const DefaultConfig = {
    /**
     * true will apply 'neo-body' to the document.body classList
     * @default true
     * @memberOf! module:Neo
     * @name config.applyBodyCls
     * @type Boolean
     */
    applyBodyCls: true,
    /**
     * true will apply 'position: fixed' to the html tag itself
     * See: https://github.com/neomjs/neo/issues/6429
     * @default true
     * @memberOf! module:Neo
     * @name config.applyFixedPositionToHtmlTag
     * @type Boolean
     */
    applyFixedPositionToHtmlTag: true,
    /**
     * Path to your app.mjs file. You can create multiple apps there if needed.
     * @default null
     * @memberOf! module:Neo
     * @name config.appPath
     * @type String|null
     */
    appPath: null,
    /**
     * Path to the neo.mjs directory
     * @default './'
     * @memberOf! module:Neo
     * @name config.basePath
     * @type String
     */
    basePath: './',
    /**
     * Pass a token in case you are using the CesiumJS main thread addon
     * See: https://github.com/neomjs/neo/blob/dev/src/main/addon/CesiumJS.mjs
     * @default undefined
     * @memberOf! module:Neo
     * @name config.cesiumJsToken
     * @type String|null
     */

    /**
     * Set this config to false to disable the component logging using Ctrl-Right-Click
     * @default true
     * @memberOf! module:Neo
     * @name config.enableComponentLogger
     * @type Boolean
     */
    enableComponentLogger: true,
    /**
     * Set this config to true to enable util.Logger (Neo.log()) based logs in production
     * @default false
     * @memberOf! module:Neo
     * @name config.enableLogsInProduction
     * @type Boolean
     */
    enableLogsInProduction: false,
    /**
     * The current environment. Valid values: 'development', 'dist/development', 'dist/production'
     * This config will get auto-generated
     * @default 'dist/production'
     * @memberOf! module:Neo
     * @name config.environment
     * @type String
     */
    environment: 'dist/production',
    /**
     * In case you are using the GoogleMaps main thread addon, you can pass the API key here.
     * @default undefined
     * @memberOf! module:Neo
     * @name config.googleMapsApiKey
     * @type String
     */

    /**
     * In case you are using the GoogleAnalytics main thread addon or useGoogleAnalytics: true,
     * you can change the gtag id here. Required for the online examples (gh pages)
     * @default undefined
     * @memberOf! module:Neo
     * @name config.gtagId
     * @type String
     */

    /**
     * Flag for running on https://neomjs.github.io/pages/
     * => to use local images paths instead of raw.githubusercontent.com
     * @default false
     * @memberOf! module:Neo
     * @name config.isGitHubPages
     * @type Boolean
     */
    isGitHubPages: true,
    /**
     * Flag for running the Neo main thread inside an iframe (Siesta Browser Harness)
     * @default false
     * @memberOf! module:Neo
     * @name config.isInsideSiesta
     * @type Boolean
     */
    isInsideSiesta: false,
    /**
     * delay in ms for the worker.Manager:loadApplication() call
     * @default 20
     * @memberOf! module:Neo
     * @name config.loadApplicationDelay
     * @type Number
     */
    loadApplicationDelay: 20,
    /**
     * Used by Intl.DateTimeFormat, for details take a look at:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
     * @default 'default'
     * @memberOf! module:Neo
     * @name config.locale
     * @type String
     */
    locale: 'default',
    /**
     * true will log the delta updates inside the main thread(s) as well as the requestAnimation frames
     * @default false
     * @memberOf! module:Neo
     * @name config.logDeltaUpdates
     * @type Boolean
     */
    logDeltaUpdates: false,
    /**
     * true will log console warnings, in case a component tries to update() while a parent update is running.
     * A parent update results in a short delay, so you might want to resolve these collisions.
     * @default false
     * @memberOf! module:Neo
     * @name config.logVdomUpdateCollisions
     * @type Boolean
     */
    logVdomUpdateCollisions: false,
    /**
     * Add addons for the main thread
     * ./src/main/addon/ contains all framework related options.
     * You can also create your own addons within your workspace scope. Make sure to put them inside 'src/main/addon/'
     * and prefix them with 'WS/' inside your neo-config.json file.
     * Example: ['DragDrop', 'Stylesheet', 'WS/MyAddon']
     * @default ['DragDrop', 'Navigator', 'Stylesheet']
     * @memberOf! module:Neo
     * @name config.mainThreadAddons
     * @type String[]
     */
    mainThreadAddons: ['DragDrop', 'Navigator', 'Stylesheet'],
    /**
     * Pass the URL of a JSON-file, which contains the services and methods from your backend,
     * which you want to expose to the client.
     * See: https://github.com/neomjs/neo/projects/32
     * @default null
     * @memberOf! module:Neo
     * @name config.remotesApiUrl
     * @type String|null
     */
    remotesApiUrl: null,
    /**
     * You can visually show the amount of delta updates per second using this config.
     * It expects a dom node with the id "neo-delta-updates" as the rendering target.
     * @default false
     * @memberOf! module:Neo
     * @name config.renderCountDeltas
     * @type Boolean
     */
    renderCountDeltas: false,
    /**
     * Add themes you want to use here. The first theme will get applied.
     * @default ['neo-theme-light','neo-theme-dark','neo-theme-neo-light']
     * @memberOf! module:Neo
     * @name config.themes
     * @type String[]
     */
    themes: ['neo-theme-light', 'neo-theme-dark', 'neo-theme-neo-light'],
    /**
     * Flag for standalone Siesta module tests => prevent registerRemote worker messages
     * @default false
     * @memberOf! module:Neo
     * @name config.unitTestMode
     * @type Boolean
     */
    unitTestMode: false,
    /**
     * When unitTestMode is true, this flag can be enabled to allow VDOM-related
     * operations like initVnode() and update() to proceed. This is useful for integration-style
     * tests that need to verify component lifecycle and DOM output.
     * @default false
     * @memberOf! module:Neo
     * @name config.allowVdomUpdatesInTests
     * @type Boolean
     */
    allowVdomUpdatesInTests: false,
    /**
     * Experimental flag if an offscreen canvas worker should get created.
     * @default false
     * @memberOf! module:Neo
     * @name config.useCanvasWorker
     * @type Boolean
     */
    useCanvasWorker: false,
    /**
     * `true` will enable the advanced, secure, and performant direct DOM API rendering strategy (recommended).
     * In this mode, `Neo.vdom.Helper` will create and send structured VNode object graphs to the Main Thread.
     * `Neo.main.DeltaUpdates` will then use `Neo.main.render.DomApiRenderer` to directly manipulate the DOM.
     * Crucially, `Neo.main.render.DomApiRenderer` builds new **DOM subtrees** (from the received VNode object graphs)
     * as detached DocumentFragments or elements, entirely outside the live DOM tree.
     * These fully constructed fragments are then inserted into the live document in a **single, atomic operation**.
     * This approach inherently minimizes costly browser reflows/repaints, drastically reduces Cross-Site Scripting (XSS) risks,
     * and optimizes for surgical, atomic DOM updates for unparalleled performance.
     *
     * `false` will enable the legacy string-based rendering strategy.
     * In this mode, `Neo.vdom.Helper` will generate complete HTML strings (`outerHTML`) for VNode subtrees.
     * `Neo.main.DeltaUpdates` will then use `Neo.main.render.StringBasedRenderer` to insert these
     * strings into the DOM using methods like `parentNode.insertAdjacentHTML()`.
     * While performant for large insertions, this mode is generally less secure due to potential XSS vectors
     * and relies on browser HTML parsing, which can be less efficient for granular updates.
     *
     * This configuration affects both the initial painting of your applications and the creation
     * of new component trees at runtime.
     * @default true
     * @memberOf! module:Neo
     * @name config.useDomApiRenderer
     * @type Boolean
     */
    useDomApiRenderer: true,
    /**
     * Flag if vdom ids should get mapped into DOM element ids.
     * false will convert them into a "data-neo-id" attribute.
     * @default true
     * @memberOf! module:Neo
     * @name config.useDomIds
     * @type Boolean
     */
    useDomIds: true,
    /**
     * True will automatically include the stylesheet
     * @default true
     * @memberOf! module:Neo
     * @name config.useFontAwesome
     * @type Boolean
     */
    useFontAwesome: true,
    /**
     * Intended for the online examples where we need an easy way to add GA to every generated app
     * @default false
     * @memberOf! module:Neo
     * @name config.useGoogleAnalytics
     * @type Boolean
     */
    useGoogleAnalytics: false,
    /**
     * True will add the ServiceWorker main thread addon to support caching of assets (PWA)
     * See: https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API
     *
     * You can also use a string to specify the target environment => 'dist/production'.
     * Using 'dist/production' will also use the service worker for 'dist/esm'
     * @default false
     * @memberOf! module:Neo
     * @name config.useServiceWorker
     * @type Boolean|String
     */
    useServiceWorker: false,
    /**
     * Creates App, Data & VDom as SharedWorkers.
     * Set this one to true in case you want to connect multiple main threads.
     * @default false
     * @memberOf! module:Neo
     * @name config.useSharedWorkers
     * @type Boolean
     */
    useSharedWorkers: false,
    /**
     * True will generate a new task worker, which can get filled with own expensive remote methods
     * @default false
     * @memberOf! module:Neo
     * @name config.useTaskWorker
     * @type Boolean
     */
    useTaskWorker: false,
    /**
     * False will create the vdom.Helper within the App worker (experimental!)
     * @default true
     * @memberOf! module:Neo
     * @name config.useVdomWorker
     * @type Boolean
     */
    useVdomWorker: true,
    /**
     * buildScripts/injectPackageVersion.mjs will update this value
     * @default '10.5.4'
     * @memberOf! module:Neo
     * @name config.version
     * @type String
     */
    version: '10.5.4'
};

Object.assign(DefaultConfig, {
    /**
     * Path to the top level neo.mjs resources folder
     * @default Neo.config.basePath + 'resources/'
     * @memberOf! module:Neo
     * @name config.resourcesPath
     * @type String
     */
    resourcesPath: `${Neo.config.basePath || DefaultConfig.basePath}resources/`,
    /**
     * The default base URL for web worker entry points (App, Data, Vdom)
     * @default Neo.config.basePath + 'src/worker/'
     * @memberOf! module:Neo
     * @name config.workerBasePath
     * @type String
     */
    workerBasePath: `${Neo.config.basePath || DefaultConfig.basePath}src/worker/`,
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DefaultConfig);


/***/ }),

/***/ "./src/Neo.mjs":
/*!*********************!*\
  !*** ./src/Neo.mjs ***!
  \*********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _DefaultConfig_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultConfig.mjs */ "./src/DefaultConfig.mjs");
/* harmony import */ var _core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");



const
    camelRegex   = /-./g,
    configSymbol = Symbol.for('configSymbol'),
    getSetCache  = Symbol('getSetCache'),
    cloneMap = {
        Array(obj, deep, ignoreNeoInstances) {
            return !deep ? [...obj] : [...obj.map(val => Neo.clone(val, deep, ignoreNeoInstances))]
        },
        Date(obj) {
            return new Date(obj.valueOf())
        },
        Map(obj) {
            return new Map(obj) // shallow copy
        },
        NeoInstance(obj, ignoreNeoInstances) {
            return ignoreNeoInstances ? obj : Neo.cloneNeoInstance(obj)
        },
        Set(obj) {
            return new Set(obj)
        },
        Object(obj, deep, ignoreNeoInstances) {
            const out = {};

            // Use Reflect.ownKeys() to include symbol properties (e.g., for config descriptors)
            Reflect.ownKeys(obj).forEach(key => {
                const value = obj[key];
                out[key] = !deep ? value : Neo.clone(value, deep, ignoreNeoInstances)
            });

            return out
        }
    },
    typeDetector = {
        function: item => {
            if (item.prototype?.constructor?.isClass) {
                return 'NeoClass'
            }
        },
        object: item => {
            if (item.constructor?.isClass && item instanceof Neo.core.Base) {
                return 'NeoInstance'
            }
        }
    };

/**
 * The base module to enhance classes, create instances and the Neo namespace
 * @module Neo
 * @singleton
 * @borrows Neo.core.Util.bindMethods       as bindMethods
 * @borrows Neo.core.Util.createStyleObject as createStyleObject
 * @borrows Neo.core.Util.createStyles      as createStyles
 * @borrows Neo.core.Util.decamel           as decamel
 * @borrows Neo.core.Util.isArray           as isArray
 * @borrows Neo.core.Util.isBoolean         as isBoolean
 * @borrows Neo.core.Util.isDefined         as isDefined
 * @borrows Neo.core.Compare.isEqual        as isEqual
 * @borrows Neo.core.Util.isNumber          as isNumber
 * @borrows Neo.core.Util.isObject          as isObject
 * @borrows Neo.core.Util.isString          as isString
 * @borrows Neo.core.Util.toArray           as toArray
 * @tutorial 01_Concept
 */
let Neo = globalThis.Neo || {};

Neo = globalThis.Neo = Object.assign({
    /**
     * A map containing ntypes as key and Neo classes or singletons as values
     * @memberOf! module:Neo
     * @protected
     * @type Object
     */
    ntypeMap: {},
    /**
     * Needed for Neo.create. False for the main thread, true for the App, Data & Vdom worker
     * @memberOf! module:Neo
     * @protected
     * @type Boolean
     */
    insideWorker: typeof DedicatedWorkerGlobalScope !== 'undefined' || typeof WorkerGlobalScope !== 'undefined',

    /**
     * Maps methods from one namespace to another one
     * @example
     * // aliases
     * Neo.applyFromNs(Neo, Util, {
     *     createStyleObject: 'createStyleObject',
     *     createStyles     : 'createStyles',
     *     capitalize       : 'capitalize'
     * }, true);
     *
     * // e.g. Neo.core.Util.isObject => Neo.isObject
     * @memberOf module:Neo
     * @param {Neo|Neo.core.Base} target    The target class or singleton Instance or Neo
     * @param {Neo.core.Base}     namespace The class containing the methods
     * @param {Object}            config
     * @param {Boolean}           [bind]    set this to true in case you want to bind methods to the "from" namespace
     * @returns {Object} target
     */
    applyFromNs(target, namespace, config, bind) {
        let fnName;

        if (target && Neo.typeOf(config) === 'Object') {
            Object.entries(config).forEach(([key, value]) => {
                fnName = namespace[value];
                target[key] = bind ? fnName.bind(namespace) : fnName
            })
        }

        return target
    },

    /**
     * Maps a class to the global Neo or App namespace.
     * Can get called for classes and singleton instances
     * @memberOf module:Neo
     * @param {Neo.core.Base} cls
     */
    applyToGlobalNs(cls) {
        let proto     = typeof cls === 'function' ? cls.prototype : cls,
            className = proto.isClass ? proto.config.className : proto.className,
            nsArray   = className.split('.'),
            key       = nsArray.pop(),
            ns        = Neo.ns(nsArray, true);

        ns[key] = cls
    },

    /**
     * Copies all keys of defaults into target, in case they don't already exist
     * @memberOf module:Neo
     * @param {Object} target   The target object
     * @param {Object} defaults The object containing the keys you want to copy
     * @returns {Object} target
     */
    assignDefaults(target, defaults) {
        if (target && Neo.typeOf(defaults) === 'Object') {
            Object.entries(defaults).forEach(([key, value]) => {
                if (!Object.hasOwn(target, key)) {
                    target[key] = value
                }
            })
        }

        return target
    },

    /**
     * Assigns a new value to a given nested objects path.
     * It will create the path structure or parts of it, in case it does not exist.
     * @example
     * Neo.assignToNs('annotations.selected', false, record)
     *
     * @memberOf module:Neo
     * @param {String[]|String} path             The path string containing dots or an Array of the string parts
     * @param {*}               value            The new value to assign to the leaf node
     * @param {Object}          scope=globalThis Set a different starting point as globalThis
     * @param {Boolean}         force=true       false will only assign default values (assign if old value === undefined)
     */
    assignToNs(path, value, scope=globalThis, force=true) {
        path = Array.isArray(path) ? path : path.split('.');

        let key;

        if (path.length > 1) {
            key   = path.pop();
            scope = Neo.ns(path, true, scope)
        } else {
            key = path
        }

        if (force || scope[key] === undefined) {
            scope[key] = value
        }
    },

    /**
     * Converts kebab-case strings into camel-case
     * @memberOf module:Neo
     * @param {String} value The target object
     * @returns {String}
     */
    camel(value) {
        return value.replace(camelRegex, match => match[1].toUpperCase())
    },

    /**
     * Makes the first character of a string uppercase
     * @memberOf module:Neo
     * @param {String} value
     * @returns {Boolean|String} Returns false for non string inputs
     */
    capitalize(value) {
        return value[0].toUpperCase() + value.slice(1)
    },

    /**
     * @memberOf module:Neo
     * @param {Object|Array|*} obj
     * @param {Boolean} deep=false               Set this to true in case you want to clone nested objects as well
     * @param {Boolean} ignoreNeoInstances=false returns existing instances if set to true
     * @returns {Object|Array|*} the cloned input
     */
    clone(obj, deep=false, ignoreNeoInstances=false) {
        return cloneMap[Neo.typeOf(obj)]?.(obj, deep, ignoreNeoInstances) || obj
    },

    /**
     * Creates a new instance using the originalConfig without the id
     * @memberOf module:Neo
     * @param {Neo.core.Base} instance
     * @returns {Neo.core.Base} the cloned instance
     */
    cloneNeoInstance(instance) {
        let config = {...instance.originalConfig};

        delete config._id;
        delete config.id;

        return Neo.create(instance.className, config)
    },

    /**
     * Use Neo.create() instead of "new" to create instances of all Neo classes
     * @example
     * import Button from '../button/Base.mjs';
     *
     * Neo.create(Button, {
     *     iconCls: 'fa fa-home',
     *     text   : 'Home'
     * });
     * @example
     * import Button from '../button/Base.mjs';
     *
     * Neo.create({
     *     module : Button,
     *     iconCls: 'fa fa-home',
     *     text   : 'Home'
     * });
     * @example
     * Neo.create('Neo.button.Base' {
     *     iconCls: 'fa fa-home',
     *     text   : 'Home'
     * });
     * @example
     * Neo.create({
     *     className: 'Neo.button.Base',
     *     iconCls  : 'fa fa-home',
     *     text     : 'Home'
     * });
     * @memberOf module:Neo
     * @param {String|Object|Neo.core.Base} className
     * @param {Object}                      [config]
     * @returns {Neo.core.Base|null} The new class instance
     * @tutorial 02_ClassSystem
     */
    create(className, config) {
        let type = Neo.typeOf(className),
            cls, instance;

        if (type === 'NeoClass') {
            cls = className
        } else {
            if (type === 'Object') {
                config = className;

                if (!config.className && !config.module) {
                    // using console.error instead of throw to show the config object
                    console.error('Class created with object configuration missing className or module property', config);
                    return null
                }

                className = config.className || config.module.prototype.className
            }

            if (!exists(className)) {
                throw new Error('Class ' + className + ' does not exist')
            }

            cls = Neo.ns(className)
        }

        instance = new cls();

        instance.construct(config);
        instance.onConstructed();
        instance.onAfterConstructed();
        instance.init();

        return instance
    },

    /**
     * Defines a reactive configuration property on a target object (prototype or instance).
     * This method creates getters and setters that fully participate in Neo.mjs's reactive config system,
     * including lifecycle hooks.
     *
     * @param {Neo.core.Base}  target        - The instance or prototype on which to define the config.
     * @param {String}         key           - The name of the config property (without the '_' suffix).
     * @param {*}             [initialValue] - The initial value for the config.
     */
    createConfig(target, key, initialValue) {
        if (Neo.hasPropertySetter(target, key)) {
            throw(
`Invalid config in ${target.className}: '${key}_'. The config '${key}' is already defined as reactive by a parent class.
To override the default value, use '${key}' (without the underscore) in your static config.
If you intended to create custom logic, use the 'beforeGet${Neo.capitalize(key)}()', 'beforeSet${Neo.capitalize(key)}()', and 'afterSet${Neo.capitalize(key)}()' hooks instead of redefining the config.`
            )
        }

        const
            _key      = '_' + key,
            uKey      = key[0].toUpperCase() + key.slice(1),
            beforeGet = 'beforeGet' + uKey,
            beforeSet = 'beforeSet' + uKey,
            afterSet  = 'afterSet'  + uKey;

        Neo[getSetCache] ??= {};

        if (!Neo[getSetCache][key]) {
            // Public Descriptor
            Neo[getSetCache][key] = {
                get() {
                    let me        = this,
                        config    = me.getConfig(key),
                        hasNewKey = Object.hasOwn(me[configSymbol], key),
                        newKey    = me[configSymbol][key],
                        value     = hasNewKey ? newKey : me[_key];

                    if (value instanceof Date) {
                        value = new Date(value.valueOf());
                    }
                    // new, explicit opt-in path
                    else if (config.cloneOnGet) {
                        const {cloneOnGet} = config;

                        if (cloneOnGet === 'deep') {
                            value = Neo.clone(value, true, true);
                        } else if (cloneOnGet === 'shallow') {
                            const type = Neo.typeOf(value);

                            if (type === 'Array') {
                                value = [...value];
                            } else if (type === 'Object') {
                                value = {...value};
                            }
                        }
                    }
                    // legacy behavior
                    else if (Array.isArray(value)) {
                        value = [...value];
                    }

                    if (hasNewKey) {
                        me[key] = value;  // We do want to trigger the setter => beforeSet, afterSet
                        value = me[_key]; // Return the value parsed by the setter
                        delete me[configSymbol][key]
                    }

                    if (typeof me[beforeGet] === 'function') {
                        value = me[beforeGet](value)
                    }

                    return value
                },
                set(value) {
                    if (value === undefined) return;

                    const config = this.getConfig(key);
                    if (!config) return;

                    let me              = this,
                        oldValue        = config.get(), // Get the old value from the Config instance
                        {EffectManager} = Neo.core,
                        isNewBatch      = !EffectManager?.isPaused();

                    // If a config change is not triggered via `core.Base#set()`, honor changes inside hooks.
                    isNewBatch && EffectManager?.pause();

                    try {
                        // 1. Prevent infinite loops:
                        // Immediately remove the pending value from the configSymbol to prevent a getter from
                        // recursively re-triggering this setter.
                        delete me[configSymbol][key];

                        switch (config.clone) {
                            case 'deep':
                                value = Neo.clone(value, true, true);
                                break;
                            case 'shallow':
                                value = Neo.clone(value, false, true);
                                break;
                        }

                        // 2. Create a temporary state for beforeSet hooks:
                        // Set the new value directly on the private backing property. This allows any beforeSet
                        // hook to access the new value of this and other configs within the same `set()` call.
                        me[_key] = value;

                        if (typeof me[beforeSet] === 'function') {
                            value = me[beforeSet](value, oldValue);

                            // If they don't return a value, that means no change
                            if (value === undefined) {
                                // Restore the original value if the update is canceled.
                                me[_key] = oldValue;
                                return
                            }
                        }

                        // 3. Restore state for change detection:
                        // Revert the private backing property to its original value. This is crucial for the
                        // `config.set()` method to correctly detect if the value has actually changed.
                        me[_key] = oldValue;

                        // 4. Finalize the change:
                        // The config.set() method performs the final check and, if the value changed,
                        // triggers afterSet hooks and notifies subscribers.
                        if (config.set(value)) {
                            me[afterSet]?.(value, oldValue);
                            me.afterSetConfig?.(key, value, oldValue)
                        }
                    } finally {
                        // End the batch only if this setter started it.
                        isNewBatch && EffectManager?.resume()
                    }
                }
            };

            // Private Descriptor
            Neo[getSetCache][_key] = {
                get() {
                    return this.getConfig(key)?.get()
                },
                set(value) {
                    this.getConfig(key)?.setRaw(value)
                }
            }
        }

        Object.defineProperty(target, key,  Neo[getSetCache][key]);
        Object.defineProperty(target, _key, Neo[getSetCache][_key]);

        if (initialValue !== undefined) {
            target[key] = initialValue
        }
    },

    /**
     *
     */
    emptyFn() {},

    /**
     * Ensures a class is assigned to the Neo namespace only once, preventing duplicates.
     * This is a lightweight version of `Neo.setupClass` for simple classes
     * that do not extend `Neo.core.Base`.
     * It follows a "first one wins" strategy.
     *
     * @param {Function|Object} module    - The class constructor or singleton object to register.
     * @param {String}          classPath - The fully qualified name (e.g., 'Neo.core.Config').
     * @param {Function}       [onFirst]  - An optional callback that runs only the first time the class is registered.
     * @returns {Function|Object} The class or singleton from the Neo namespace (either the existing one or the newly set one).
     */
    gatekeep(module, classPath, onFirst) {
        const existingClass = Neo.ns(classPath, false);

        if (existingClass) {
            return existingClass
        }

        const
            nsArray   = classPath.split('.'),
            className = nsArray.pop(),
            parentNs  = Neo.ns(nsArray, true);

        parentNs[className] = module;

        onFirst?.(module);

        return parentNs[className]
    },

    /**
     * Checks if there is a set method for a given property key inside the prototype chain
     * @memberOf module:Neo
     * @param {Neo.core.Base} proto The top level prototype of a class
     * @param {String}        key   The property key to test
     * @returns {Boolean}
     */
    hasPropertySetter(proto, key) {
        let descriptor;

        while (proto.__proto__) {
            descriptor = Object.getOwnPropertyDescriptor(proto, key);

            if (typeof descriptor === 'object' && typeof descriptor.set === 'function') {
                return true
            }

            proto = proto.__proto__
        }

        return false
    },

    /**
     * Deep-merges a source object into a target object
     * @memberOf module:Neo
     * @param {Object} target
     * @param {Object} source
     * @param {Object} defaults
     * @returns {Object} target
     */
    merge(target, source, defaults) {
        if (defaults) {
            return Neo.merge(Neo.merge(target, defaults), source)
        }

        if (!target) {
            return source
        }

        for (const key in source) {
            const value = source[key];

            if (Neo.typeOf(value) === 'Object') {
                target[key] = Neo.merge(target[key] || {}, value)
            } else {
                target[key] = value
            }
        }

        return target
    },

    /**
     * Merges a new value into an existing config value based on a specified strategy.
     * This method is used during instance creation to apply merge strategies defined in config descriptors.
     * @param {any} defaultValue - The default value of the config (from static config).
     * @param {any} instanceValue - The value provided during instance creation.
     * @param {string|Function} strategy - The merge strategy: 'shallow', 'deep', 'replace', or a custom function.
     * @returns {any} The merged value.
     */
    mergeConfig(defaultValue, instanceValue, strategy) {
        const
            defaultValueType  = Neo.typeOf(defaultValue),
            instanceValueType = Neo.typeOf(instanceValue);

        if (strategy === 'shallow') {
            if (defaultValueType === 'Object' && instanceValueType === 'Object') {
                return {...defaultValue, ...instanceValue}
            }
        } else if (strategy === 'deep') {
            if (defaultValueType === 'Object' && instanceValueType === 'Object') {
                return Neo.merge(Neo.clone(defaultValue, true), instanceValue)
            }
        } else if (typeof strategy === 'function') {
            return strategy(defaultValue, instanceValue)
        }

        // Default to 'replace' or if strategy is not recognized
        return instanceValue
    },

    /**
     * Maps a className string into a given or global namespace
     * @example
     * Neo.ns('Neo.button.Base', true);
     * // =>
     * // globalThis.Neo             = globalThis.Neo             || {};
     * // globalThis.Neo.button      = globalThis.Neo.button      || {};
     * // globalThis.Neo.button.Base = globalThis.Neo.button.Base || {};
     * // return globalThis.Neo.button.Base;
     *
     * @memberOf module:Neo
     * @param {String[]|String} names        The class name string containing dots or an Array of the string parts
     * @param {Boolean}         create=false Set create to true to create empty objects for non-existing parts
     * @param {Object}          [scope]      Set a different starting point as globalThis
     * @returns {Object} reference to the toplevel namespace
     */
    ns(names, create=false, scope) {
        names = Array.isArray(names) ? names : names.split('.');

        return names.reduce((prev, current) => {
            if (create && !prev[current]) {
                prev[current] = {}
            }

            if (prev) {
                return prev[current]
            }
        }, scope || globalThis)
    },

    /**
     * Extended version of Neo.ns() which supports mapping into arrays.
     * @memberOf module:Neo
     * @param {Array|String} names        The class name string containing dots or an Array of the string parts
     * @param {Boolean}      create=false Set create to true to create empty objects for non-existing parts
     * @param {Object}       [scope]      Set a different starting point as globalThis
     * @returns {Object} reference to the toplevel namespace
     */
    nsWithArrays(names, create=false, scope) {
        names = Array.isArray(names) ? names : names.split('.');

        return names.reduce((prev, current) => {
            if (create && !prev[current]) {
                if (current.endsWith(']')) {
                    return createArrayNs(true, current, prev)
                }

                prev[current] = {}
            }

            if (prev) {
                if (current.endsWith(']')) {
                    return createArrayNs(false, current, prev)
                }

                return prev[current]
            }
        }, scope || globalThis)
    },

    /**
     * Creates instances of Neo classes using their ntype instead of the class name
     * @example
     * Neo.ntype('button' {
     *     iconCls: 'fa fa-home',
     *     text   : 'Home'
     * });
     * @example
     * Neo.ntype({
     *     ntype  : 'button',
     *     iconCls: 'fa fa-home',
     *     text   : 'Home'
     * });
     * @memberOf module:Neo
     * @param {String|Object} ntype
     * @param {Object}        [config]
     * @returns {Neo.core.Base}
     * @see {@link module:Neo.create create}
     */
    ntype(ntype, config) {
        if (typeof ntype === 'object') {
            config = ntype;

            if (!config.ntype) {
                throw new Error('Class defined with object configuration missing ntype property. ' + config.ntype)
            }

            ntype = config.ntype
        }

        let className = Neo.ntypeMap[ntype];

        if (!className) {
            throw new Error('ntype ' + ntype + ' does not exist')
        }

        return Neo.create(className, config)
    },

    /**
     * This is the final and most critical step in the Neo.mjs class creation process.
     * It is called at the end of every class module definition.
     *
     * `setupClass` performs several key operations:
     * 1.  **Mixed-Environment Gatekeeper:** It first checks if the class's namespace already exists.
     *     If it does, it immediately returns the existing class. This is the crucial "first comes wins"
     *     strategy that enables Neo.mjs to safely combine environments. For example, a bundled
     *     `dist/production` app can dynamically load an unbundled module from `dist/esm` at runtime.
     *     If that module imports a class already present in the main bundle, this check ensures the
     *     original, bundled class is used, preventing conflicts and maintaining application integrity.
     * 1.  **Configuration Merging:** It traverses the prototype chain to merge `static config`
     *     objects from parent classes into the current class, creating a unified `config`.
     * 2.  **Applying Overwrites:** It calls the static `applyOverwrites()` method on the class,
     *     allowing the global `Neo.overwrites` object to modify the class's default prototype
     *     configs. This is a key mechanism for external theming and configuration.
     * 3.  **Reactive Getter/Setter Generation:** For any config ending with an underscore (e.g., `myConfig_`),
     *     it automatically generates the corresponding public getter and setter. This enables optional
     *     lifecycle hooks that are called automatically if implemented on the class:
     *     - `beforeGetMyConfig(value)`
     *     - `beforeSetMyConfig(newValue, oldValue)`
     *     - `afterSetMyConfig(newValue, oldValue)`
     * 4.  **Prototype-based Configs:** Non-reactive configs (without an underscore) are set
     *     directly on the prototype for memory efficiency.
     * 5.  **Mixin Application:** It processes the `mixins` config to blend in functionality from
     *     other classes.
     * 6.  **Namespace Registration:** It registers the class in the global `Neo` namespace.
     * 7.  **Singleton Instantiation:** If the class is configured as a singleton, it creates the
     *     single instance.
     *
     * @memberOf module:Neo
     * @template T
     * @param {T} cls The class constructor to process.
     * @returns {T} The processed and finalized class constructor or singleton instance.
     */
    setupClass(cls) {
        let baseConfig            = null,
            baseConfigDescriptors = null,
            ntypeChain            = [],
            {ntypeMap}            = Neo,
            proto                 = cls.prototype || cls,
            ns                    = Neo.ns(proto.constructor.config.className, false),
            protos                = [],
            cfg, config, configDescriptors, ctor, hierarchyInfo, ntype;

        /*
         * If the namespace already exists, directly return it.
         * This can happen when using different versions of Neo.mjs
         * => Especially singletons (IdGenerator) must stay unique.
         *
         * This can also happen when using different environments of neo.mjs in parallel.
         * Example: code.LivePreview running inside a dist/production app.
         */
        if (ns) {
            return ns
        }

        // Traverse the prototype chain to collect inherited configs and descriptors
        while (proto.__proto__) {
            ctor = proto.constructor;

            // If a class in the prototype chain has already had its config applied,
            // we can use its pre-processed config and descriptors as a base.
            if (Object.hasOwn(ctor, 'classConfigApplied')) {
                baseConfig            = Neo.clone(ctor.config, true);
                baseConfigDescriptors = Neo.clone(ctor.configDescriptors, true);
                ntypeChain            = [...ctor.ntypeChain];
                break
            }

            protos.unshift(proto);
            proto = proto.__proto__
        }

        // Initialize accumulated config and descriptors
        config            = baseConfig            || {};
        configDescriptors = baseConfigDescriptors || {};

        // Process each class in the prototype chain (from top to bottom)
        protos.forEach(element => {
            let mixins;

            ctor = element.constructor;
            cfg  = ctor.config || {};

            if (Neo.overwrites) {
                ctor.applyOverwrites?.(cfg)
            }

            // Process each config property defined in the current class's static config
            Object.entries(cfg).forEach(([key, value]) => {
                const
                    isReactive = key.slice(-1) === '_',
                    baseKey    = isReactive ? key.slice(0, -1) : key;

                // 1. Handle descriptors: If the value is a descriptor object, store it.
                //    The 'value' property of the descriptor is then used as the actual config value.
                if (Neo.isObject(value) && value[_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_1__.isDescriptor] === true) {
                    ctor.configDescriptors ??= {};
                    ctor.configDescriptors[baseKey] = Neo.clone(value, true); // Deep clone to prevent mutation
                    value = value.value // Use the descriptor's value as the config value
                }

                // 2. Handle reactive vs. non-reactive configs: Generate getters/setters for reactive configs.
                if (isReactive) {
                    delete cfg[key];      // Remove original key with underscore
                    cfg[baseKey] = value; // Use the potentially modified value
                    Neo.createConfig(element, baseKey)
                }
                // This part handles non-reactive configs (including those that were descriptors)
                // If no property setter exists, define it directly on the prototype.
                else if (!Neo.hasPropertySetter(element, key)) {
                    Object.defineProperty(element, key, {
                        enumerable: true,
                        value,
                        writable  : true
                    })
                }
            });

            // Merge configDescriptors: Apply "first-defined wins" strategy.
            // If a descriptor for a key already exists (from a parent class), it is not overwritten.
            if (ctor.configDescriptors) {
                for (const key in ctor.configDescriptors) {
                    if (!Object.hasOwn(configDescriptors, key)) {
                        configDescriptors[key] = Neo.clone(ctor.configDescriptors[key], true) // Deep clone for immutability
                    }
                }
            }

            // Process ntype and ntypeChain
            if (Object.hasOwn(cfg, 'ntype')) {
                ntype = cfg.ntype;

                ntypeChain.unshift(ntype);

                // Running the docs app inside a workspace can pull in the same classes from different roots,
                // so we want to check for different class names as well
                if (Object.hasOwn(ntypeMap, ntype) && cfg.className !== ntypeMap[ntype]) {
                    throw new Error(`ntype conflict for '${ntype}' inside the classes:\n${ntypeMap[ntype]}\n${cfg.className}`)
                }

                ntypeMap[ntype] = cfg.className
            }

            // Process mixins
            mixins = Object.hasOwn(config, 'mixins') && config.mixins || [];

            if (ctor.observable) {
                mixins.push('Neo.core.Observable')
            }

            if (Object.hasOwn(cfg, 'mixins') && Array.isArray(cfg.mixins) && cfg.mixins.length > 0) {
                mixins.push(...cfg.mixins)
            }

            if (mixins.length > 0) {
                applyMixins(ctor, mixins, cfg);

                if (Neo.ns('Neo.core.Observable', false, ctor.prototype.mixins)) {
                    ctor.observable = true
                }
            }

            delete cfg.mixins;
            delete config.mixins;

            // Hierarchical merging of static config values based on descriptors.
            // This ensures that values are merged (e.g., shallow/deep) instead of simply overwritten.
            Object.entries(cfg).forEach(([key, value]) => {
                const descriptor = configDescriptors[key];

                if (descriptor?.merge) {
                    config[key] = Neo.mergeConfig(config[key], value, descriptor.merge)
                } else {
                    config[key] = value
                }
            });

            // Assign final processed config and descriptors to the class constructor
            Object.assign(ctor, {
                classConfigApplied: true,
                config            : Neo.clone(config,            true), // Deep clone final config for immutability
                configDescriptors : Neo.clone(configDescriptors, true), // Deep clone final descriptors for immutability
                isClass           : true,
                ntypeChain
            });

            // Apply to global namespace if not a singleton
            !config.singleton && this.applyToGlobalNs(cls)
        });

        proto = cls.prototype || cls;

        // Add is<Ntype> flags to the prototype
        ntypeChain.forEach(ntype => {
            proto[`is${Neo.capitalize(Neo.camel(ntype))}`] = true
        });

        // If it's a singleton, create and apply the instance to the global namespace
        if (proto.singleton) {
            cls = Neo.create(cls);
            Neo.applyToGlobalNs(cls)
        }

        // Add class hierarchy information to the manager or a temporary map
        hierarchyInfo = {
            className      : proto.className,
            module         : cls,
            ntype          : Object.hasOwn(proto, 'ntype') ? proto.ntype : null,
            parentClassName: proto.__proto__?.className || null
        };

        if (Neo.manager?.ClassHierarchy) {
            Neo.manager.ClassHierarchy.add(hierarchyInfo)
        } else {
            Neo.classHierarchyMap ??= {};
            Neo.classHierarchyMap[proto.className] = hierarchyInfo
        }

        return cls
    },

    /**
     * @param {*} item
     * @returns {String|null}
     */
    typeOf(item) {
        // Return null for null or undefined
        if (item == null) {
            return null
        }

        return typeDetector[typeof item]?.(item) || item.constructor?.name
    }
}, Neo);

/**
 * List of class properties which are not supposed to get mixed into other classes
 * @type {string[]}
 * @private
 */
const ignoreMixin = [
    '_name',
    'classConfigApplied',
    'className',
    'constructor',
    'id',
    'isClass',
    'mixin',
    'ntype',
    'observable'
],

    charsRegex         = /\d+/g,
    extractArraysRegex = /^(\w+)\s*((?:\[\s*\d+\s*\]\s*)*)$/;

/**
 * @param {Neo.core.Base} cls
 * @param {Array}         mixins
 * @param {Object}        classConfig
 * @private
 */
function applyMixins(cls, mixins, classConfig) {
    if (!Array.isArray(mixins)) {
        mixins = [mixins];
    }

    let i            = 0,
        len          = mixins.length,
        mixinClasses = {},
        mixin, mixinCls, mixinProto;

    for (;i < len;i++) {
        mixin = mixins[i];

        if (mixin.isClass) {
            mixinProto = mixin.prototype;
            mixinCls   = Neo.ns(mixinProto.className)
        } else {
            if (!exists(mixin)) {
                throw new Error('Attempting to mixin an undefined class: ' + mixin + ', ' + cls.prototype.className)
            }

            mixinCls   = Neo.ns(mixin);
            mixinProto = mixinCls.prototype
        }

        mixinProto.className.split('.').reduce(mixReduce(mixinCls), mixinClasses);

        Object.entries(Object.getOwnPropertyDescriptors(mixinProto)).forEach(mixinProperty(cls.prototype, mixinProto, classConfig))
    }

    cls.prototype.mixins = mixinClasses // todo: we should do a deep merge
}

/**
 * @param {Boolean} create
 * @param {Object}  current
 * @param {Object}  prev
 * @returns {Object|undefined}
 */
function createArrayNs(create, current, prev) {
    let arrDetails = parseArrayFromString(current),
        i          = 1,
        len        = arrDetails.length,
        arrItem, arrRoot;

    if (create) {
        prev[arrDetails[0]] = arrRoot = prev[arrDetails[0]] || []
    } else {
        arrRoot = prev[arrDetails[0]]
    }

    if (!arrRoot) return;

    for (; i < len; i++) {
        arrItem = parseInt(arrDetails[i]);

        if (create) {
            arrRoot[arrItem] = arrRoot[arrItem] || {}
        }

        arrRoot = arrRoot[arrItem]
    }

    return arrRoot
}

/**
 * Checks if the class name exists inside the Neo or app namespace
 * @param {String} className
 * @returns {Boolean}
 * @private
 */
function exists(className) {
    try {
        return !!className.split('.').reduce((prev, current) => {
            return prev[current]
        }, globalThis)
    } catch(e) {
        return false
    }
}

/**
 * @param {Neo.core.Base} proto
 * @param {Neo.core.Base} mixinProto
 * @param {Object}        classConfig
 * @returns {Function}
 * @private
 */
function mixinProperty(proto, mixinProto, classConfig) {
    return function([key, descriptor]) {
        if (ignoreMixin.includes(key)) return;

        // Mixins must not override existing class properties with a setter
        if (Neo.hasPropertySetter(proto, key)) return;

        // Reactive neo configs, or public class fields defined via get() AND set()
        if (descriptor.get && descriptor.set) {
            Neo.createConfig(proto, key);

            const mixinClassConfig = mixinProto.constructor.config;

            if (Object.hasOwn(mixinClassConfig, key)) {
                classConfig[key] = mixinClassConfig[key];
            }

            return
        }

        if (proto[key]?._from) {
            if (mixinProto.className === proto[key]._from) {
                console.warn('Mixin set multiple times or already defined on a Base Class', proto.className, mixinProto.className, key);
                return
            }

            throw new Error(
                `${proto.className}: Multiple mixins defining same property (${mixinProto.className}, ${proto[key]._from}) => ${key}`
            )
        }

        proto[key] = mixinProto[key];

        Object.getOwnPropertyDescriptor(proto, key)._from = mixinProto.className;

        if (typeof proto[key] === 'function') {
            proto[key]._name = key
        }
    }
}

/**
 * @param mixinCls
 * @returns {Function}
 * @private
 */
function mixReduce(mixinCls) {
    return (prev, current, idx, arr) => {
        return prev[current] = idx !== arr.length -1 ? prev[current] || {} : mixinCls
    }
}

/**
 * @param {String} str
 * @returns {Function}
 * @private
 */
function parseArrayFromString(str) {
    return (extractArraysRegex.exec(str) || [null]).slice(1).reduce(
        (fun, args) => [fun].concat(args.match(charsRegex))
    )
}

Neo.config ??= {};

Neo.assignDefaults(Neo.config, _DefaultConfig_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo);


/***/ }),

/***/ "./src/collection/Base.mjs":
/*!*********************************!*\
  !*** ./src/collection/Base.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _Filter_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Filter.mjs */ "./src/collection/Filter.mjs");
/* harmony import */ var _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Logger.mjs */ "./src/util/Logger.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _Sorter_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Sorter.mjs */ "./src/collection/Sorter.mjs");







const countMutations   = Symbol('countMutations'),
      isFiltered       = Symbol('isFiltered'),
      isSorted         = Symbol('isSorted'),
      silentUpdateMode = Symbol('silentUpdateMode'),
      toAddArray       = Symbol('toAddArray'),
      toRemoveArray    = Symbol('toRemoveArray'),
      updatingIndex    = Symbol('updatingIndex');

/**
 * @class Neo.collection.Base
 * @extends Neo.core.Base
 * @mixes Neo.core.Observable
 */
class Collection extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.collection.Base'
         * @protected
         */
        className: 'Neo.collection.Base',
        /**
         * @member {String} ntype='collection'
         * @protected
         */
        ntype: 'collection',
        /**
         * When filtering the collection for the first time, allItems will become a new collection for the unfiltered
         * state, using this id as the sourceCollectionId
         * @member {Neo.collection.Base|null} allItems=null
         * @protected
         */
        allItems: null,
        /**
         * True to sort the collection items when adding / inserting new ones
         * @member {Boolean} autoSort=true
         */
        autoSort: true,
        /**
         * Stores the items.length of the items array in use
         * @member {Number} count_=0
         * @reactive
         */
        count_: 0,
        /**
         * Use 'primitive' for default filters, use 'advanced' for filters using a filterBy method
         * which need to iterate over other collection items
         * @member {String} filterMode='primitive'
         */
        filterMode: 'primitive',
        /**
         * An Array containing Neo.util.Filter config objects or instances
         * @member {Array} filters_=[]
         * @reactive
         */
        filters_: [],
        /**
         * @member {Object[]|null} items_=null
         * @reactive
         */
        items_: null,
        /**
         * The unique(!) key property of each collection item
         * @member {String} keyProperty='id'
         */
        keyProperty: 'id',
        /**
         * Adding new items without an id (keyProperty) will use a negative index, which will decrease by -1
         * for each new item
         * @member {Number} keyPropertyIndex=-1
         */
        keyPropertyIndex: -1,
        /**
         * A map containing the key & reference of each collection item for faster access
         * @member {Map} map_=null
         * @protected
         * @reactive
         */
        map_: null,
        /**
         * An internal Array of the sort directions for faster access
         * @member {Array} sortDirections=null
         * @protected
         */
        sortDirections: null,
        /**
         * An internal Array of the sort properties for faster access
         * @member {Array} sortProperties=null
         * @protected
         */
        sortProperties: null,
        /**
         * An Array containing Neo.util.Sorter config objects or instances
         * @member {Array} sorters_=[]
         * @reactive
         */
        sorters_: [],
        /**
         * The id of another collection instance to use as this data source
         * @member {String|null} sourceId_=null
         * @reactive
         */
        sourceId_: null
    }

    /**
     * @param config
     */
    construct(config) {
        let me           = this,
            symbolConfig = {enumerable: false, writable: true};

        Object.defineProperties(me, {
            [countMutations]  : {...symbolConfig, value: false},
            [isFiltered]      : {...symbolConfig, value: false},
            [isSorted]        : {...symbolConfig, value: false},
            [silentUpdateMode]: {...symbolConfig, value: false},
            [toAddArray]      : {...symbolConfig, value: []},
            [toRemoveArray]   : {...symbolConfig, value: []},
            [updatingIndex]   : {...symbolConfig, value: 0}
        });

        super.construct(config);

        me.items = me.items || [];

        if (me.autoSort && me._sorters.length > 0) {
            me.doSort()
        }
    }

    /**
     * Adds one or more items to the end of the collection
     * @param {Array|Object} item The item(s) to add
     * @returns {Object[]} an array containing all added items
     */
    add(item) {
        return this.splice(null, null, item).addedItems
    }

    /**
     * Triggered after the filters config got changed
     * @param {Array} value
     * @param {Array} oldValue
     * @protected
     */
    afterSetFilters(value, oldValue) {
        let me = this;

        value.forEach(filter => {
            if (filter.listenerApplied === false) {
                filter.on('change', me.onFilterChange, me);
                filter.listenerApplied = true
            }
        });

        oldValue && me.filter()
    }

    /**
     * Triggered after the items config got changed
     * @param {Array} value
     * @param {Array} oldValue
     * @protected
     */
    afterSetItems(value, oldValue) {
        if (value) {
            let me            = this,
                {keyProperty} = me,
                i             = 0,
                len           = value.length,
                item;

            for (; i < len; i++) {
                item = value[i];
                me.map.set(item[keyProperty], item)
            }

            me.count = len
        }
    }

    /**
     * Triggered after the sorters config got changed
     * @param {Array} value
     * @param {Array} oldValue
     * @protected
     */
    afterSetSorters(value, oldValue) {
        let me = this;

        me.applySorterConfigs();

        value.forEach(sorter => {
            if (sorter.listenerApplied === false) {
                sorter.on('change', me.onSorterChange, me);
                sorter.listenerApplied = true
            }
        });

        oldValue && me.autoSort && me.doSort()
    }

    /**
     * Triggered after the sourceId config got changed
     * @param {Number|String} value
     * @param {Number|String} oldValue
     * @protected
     */
    afterSetSourceId(value, oldValue) {
        if (value) {
            let me     = this,
                source = Neo.get(value);

            me._items = [...source._items];
            me.map    = new Map(source.map); // creates a clone of the original map

            const listenersConfig = {
                mutate: me.onMutate,
                scope : me
            };

            source.on(listenersConfig);

            if (oldValue) {
                source = Neo.get(oldValue);
                source.un(listenersConfig)
            }
        }
    }

    /**
     * Saves the sort property & direction multiplier of each sorter inside 2 arrays for faster access when sorting
     * @protected
     */
    applySorterConfigs() {
        let me = this;

        me.sortDirections = [];
        me.sortProperties = [];

        me.sorters.forEach(sorter => {
            me.sortDirections.push(sorter.directionMultiplier);
            me.sortProperties.push(sorter.property)
        })
    }

    /**
     * @param {Array} value
     * @param {Array} oldValue
     * @protected
     */
    beforeSetFilters(value, oldValue) {
        if (!Array.isArray(value)) {
            value = value ? [value] : []
        }

        let len = oldValue && oldValue.length || 0,
            hasMatch, i;

        value.forEach((key, index) => {
            if (oldValue) {
                hasMatch = false;
                i        = 0;

                for (; i < len; i++) {
                    if (oldValue[i] === key) {
                        oldValue[i].set({
                            operator: key.operator,
                            property: key.property,
                            value   : key.value
                        });

                        hasMatch = true;
                        break
                    } else if (
                        oldValue[i].operator === (key.operator || '===') &&
                        oldValue[i].property === key.property &&
                        oldValue[i].value    === key.value
                    ) {
                        hasMatch = true;
                        break
                    }
                }
            }

            if (!hasMatch) {
                value[index] = Neo.create(_Filter_mjs__WEBPACK_IMPORTED_MODULE_1__["default"], key)
            } else {
                value[index] = oldValue[i];
                oldValue.splice(i, 1);
                len--
            }
        });

        if (Array.isArray(oldValue)) {
            oldValue.forEach(key => {
                key.destroy();
            })
        }

        return value
    }

    /**
     * @param {Map|null} value
     * @param {Map|null} oldValue
     * @protected
     */
    beforeSetMap(value, oldValue) {
        return !value ? new Map() : value
    }

    /**
     * @param {Array} value
     * @param {Array} oldValue
     * @protected
     */
    beforeSetSorters(value, oldValue) {
        if (!Array.isArray(value)) {
            value = value ? [value] : []
        }

        let len = oldValue?.length || 0,
            hasMatch, i;

        value.forEach((key, index) => {
            if (oldValue) {
                hasMatch = false;
                i        = 0;

                let {direction, property} = key;

                for (; i < len; i++) {
                    if (oldValue[i] === key) {
                        oldValue[i].set({direction, property});

                        hasMatch = true;
                        break
                    } else if (oldValue[i].property === property && oldValue[i].direction === direction) {
                        hasMatch = true;
                        break
                    }
                }
            }

            if (!hasMatch) {
                value[index] = Neo.create(_Sorter_mjs__WEBPACK_IMPORTED_MODULE_5__["default"], key)
            } else {
                value[index] = oldValue[i];
                oldValue.splice(i, 1);
                len--
            }
        });

        oldValue?.forEach(key => {
            key.destroy()
        });

        return value
    }

    /**
     * @param opts
     * @protected
     */
    cacheUpdate(opts) {
        // disabled for now
        // console.log('cacheUpdate', opts, this[toAddArray]);
        return;

        // removed by dead control flow
{}

        // removed by dead control flow
{}
    }

    /**
     * Removes all items and clears the map
     */
    clear() {
        this.splice(0, this.count)
    }

    /**
     * Clears all current filters and optionally restores the original ones in case they existed.
     * @param {boolean} [restoreOriginalFilters=false]
     */
    clearFilters(restoreOriginalFilters) {
        this.filters = restoreOriginalFilters ? Neo.clone(this.originalConfig.filters, true, true) : null
    }

    /**
     * Removes all items and clears the map, without firing a mutate event
     */
    clearSilent() {
        let me = this;

        me._items.splice(0, me.count);
        me.map.clear()
    }

    /**
     * Clears all current sorters and optionally restores the original ones in case they existed.
     * Without restoreInitialState as true this will not affect the current sorting of this collection.
     * @param {boolean} [restoreOriginalSorters=false]
     */
    clearSorters(restoreOriginalSorters) {
        this.sorters = restoreOriginalSorters ? Neo.clone(this.originalConfig.sorters, true, true) : null
    }

    /**
     * @returns {Neo.collection.Base} The cloned collection
     */
    clone() {
        let me      = this,
            config  = Neo.clone(me.originalConfig, true),
            filters = me._filters || [],
            sorters = me._sorters || [];

        // Ensure the keyProperty does not get lost.
        config.keyProperty = me.keyProperty;

        delete config.id;
        delete config.filters;
        delete config.items;
        delete config.sorters;

        if (me._items.length > 0) {
            config.items  = [...me._items];
            config.count = config.items.length;
        }

        config.filters = [];
        config.sorters = [];

        // todo: filters & sorters should push their current state and not the original one

        filters.forEach(function(filter) {
            config.filters.push(filter.originalConfig)
        });

        sorters.forEach(function(sorter) {
            config.sorters.push(sorter.originalConfig)
        });

        return Neo.create(Collection, config)
    }

    /**
     * Clears the map & items array before the super call
     */
    destroy() {
        let me = this;

        me._items.splice(0, me._items.length);
        me.map.clear();

        super.destroy()
    }

    /**
     *
     * @param {Object[]} items=this._items
     * @param {Boolean} silent=false
     * @protected
     */
    doSort(items=this._items, silent=false) {
        let me                = this,
            previousItems     = [...items],
            {sorters, sortDirections, sortProperties} = me,
            countSorters      = sortProperties.length || 0,
            hasSortByMethod   = false,
            hasTransformValue = false,
            i, mappedItems, obj, sorter, sortProperty, sortValue;

        if (countSorters > 0) {
            sorters.forEach(key => {
                if (key.sortBy) {
                    hasSortByMethod = true
                }

                if (key.useTransformValue) {
                    hasTransformValue = true
                }
            });

            if (hasSortByMethod) {
                me._items.sort((a, b) => {
                    i = 0;

                    for (; i < countSorters; i++) {
                        sorter    = sorters[i];
                        sortValue = sorter[sorter.sortBy ? 'sortBy' : 'defaultSortBy'](a, b);

                        if (sortValue !== 0) {
                            return sortValue
                        }
                    }

                    return 0
                })
            } else {
                if (hasTransformValue) {
                    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Sorting_with_map
                    mappedItems = items.map((item, index) => {
                        obj = {index};
                        i   = 0;

                        for (; i < countSorters; i++) {
                            if (sorters[i].useTransformValue) {
                                obj[sortProperties[i]] = sorters[i].transformValue(item[sortProperties[i]])
                            } else {
                                obj[sortProperties[i]] = item[sortProperties[i]]
                            }
                        }

                        return obj
                    });
                } else {
                    mappedItems = items
                }

                mappedItems.sort((a, b) => {
                    i = 0;

                    for (; i < countSorters; i++) {
                        sortProperty = sortProperties[i];

                        if (a[sortProperty] > b[sortProperty]) {
                            return 1 * sortDirections[i]
                        }

                        if (a[sortProperty] < b[sortProperty]) {
                            return -1 * sortDirections[i]
                        }
                    }

                    return 0
                });

                if (hasTransformValue) {
                    me._items = mappedItems.map(el => {
                        return items[el.index]
                    })
                }
            }
        }

        me[isSorted] = countSorters > 0;

        if (!silent && me[updatingIndex] === 0) {
            me.fire('sort', {
                items: me._items,
                previousItems,
                scope: me
            })
        }
    }

    /**
     * Resumes the collection events.
     * If you started an update using the startSilentUpdateMode flag,
     * you must use the endSilentUpdateMode param for this call.
     * Using the endSilentUpdateMode param will not fire a mutation event.
     * @param {Boolean} [endSilentUpdateMode]
     * @see {@link Neo.collection.Base#startUpdate startUpdate}
     */
    endUpdate(endSilentUpdateMode) {
        const me = this;

        if (me[updatingIndex] > 0) {
            me[updatingIndex]--
        }

        if (endSilentUpdateMode) {
            me[silentUpdateMode] = false
        } else {
            me.fire('mutate', {
                addedItems  : me[toAddArray],
                removedItems: me[toRemoveArray]
            });

            me[toAddArray]   .splice(0, me[toAddArray]   .length);
            me[toRemoveArray].splice(0, me[toRemoveArray].length)
        }
    }

    /**
     * Needed for remote filtering
     * @returns {Object[]}
     */
    exportFilters() {
        let me      = this,
            filters = [],
            filter;

        me.filters?.forEach(key => {
            filter = key.export();

            filter && filters.push(filter)
        });

        return filters
    }

    /**
     * Needed for remote sorting
     * @returns {Object[]}
     */
    exportSorters() {
        let me      = this,
            sorters = [],
            sorter;

        me.sorters?.forEach(key => {
            sorter = key.export();

            sorter && sorters.push(sorter)
        });

        return sorters
    }

    /**
     * @protected
     */
    filter() {
        let me              = this,
            filters         = me._filters,
            countAllFilters = filters.length,
            countFilters    = 0,
            items           = me.allItems?._items || me._items,
            i               = 0,
            countItems      = items.length,
            filteredItems   = [],
            needsSorting    = false,
            oldItems        = [...me._items],
            config, isIncluded, item, j, tmpItems;

        for (; i < countAllFilters; i++) {
            if (!filters[i].disabled) {
                countFilters++
            }
        }

        if (countFilters === 0 && me.allItems) {
            if (me.sorters.length > 0) {
                needsSorting = true
            }

            me.clearSilent();

            me.items = [...me.allItems._items]
        } else {
            if (!me.allItems) {
                config = {...me.originalConfig};

                delete config.filters;
                delete config.items;
                delete config.sorters;

                me.allItems = Neo.create(Collection, {
                    ...Neo.clone(config, true, true),
                    id         : me.id + '-all',
                    items      : [...me._items], // Initialize with a shallow copy of current items
                    keyProperty: me.keyProperty,
                    sourceId   : me.id
                })
            }

            me.map.clear();

            if (me.filterMode === 'primitive') {
                // using for loops on purpose -> performance
                for (i = 0; i < countItems; i++) {
                    isIncluded = true;
                    item       = items[i];
                    j          = 0;

                    for (; j < countAllFilters; j++) {
                        if (filters[j].isFiltered(item, items, items)) {
                            isIncluded = false;
                            break
                        }
                    }

                    if (isIncluded) {
                        filteredItems.push(item);
                        me.map.set(item[me.keyProperty], item)
                    }
                }

                me._items = filteredItems // silent update, the map is already in place
            } else {
                filteredItems = [...items];

                for (j=0; j < countAllFilters; j++) {
                    tmpItems = [];

                    for (i = 0; i < countItems; i++) {
                        if (!filters[j].isFiltered(filteredItems[i], filteredItems, items)) {
                            tmpItems.push(filteredItems[i])
                        }
                    }

                    filteredItems = [...tmpItems];
                    countItems    = filteredItems.length
                }

                me.items = filteredItems // update the map
            }
        }

        me[isFiltered] = countFilters !== 0;

        if (needsSorting) {
            me.doSort(me.items, true)
        }

        me.count = me.items.length;

        me.fire('filter', {
            isFiltered: me[isFiltered],
            items     : me.items,
            oldItems,
            scope     : me
        })
    }

    /**
     * Returns items which match the property and value.
     * Properties can contain dots for namespaces => find('vdom.id', 'neo-vnode-1')
     * @param {Object|String} property
     * @param {String|Number} [value] Only required in case the first param is a string
     * @param {Boolean} returnFirstMatch=false
     * @returns {Object|Object[]}
     *     returnFirstMatch=false: Returns an empty Array in case no items are found
     *     returnFirstMatch=true:  Returns the first found item or null
     */
    find(property, value, returnFirstMatch=false) {
        let me               = this,
            items            = [],
            isObjectProperty = me.isItem(property),
            item, matchArray, propertiesArray, propertiesLength;

        if (isObjectProperty) {
            propertiesArray  = Object.entries(property);
            propertiesLength = propertiesArray.length;
        }

        for (item of me.items) {
            if (isObjectProperty) {
                matchArray = [];

                propertiesArray.forEach(([key, value]) => {
                    if (Neo.ns(key, false, item) === value) {
                        matchArray.push(true)
                    }
                });

                if (matchArray.length === propertiesLength) {
                    if (returnFirstMatch) {
                        return item
                    }

                    items.push(item)
                }
            } else if (Neo.ns(property, false, item) === value) {
                if (returnFirstMatch) {
                    return item
                }

                items.push(item)
            }
        }

        return returnFirstMatch ? null : items
    }

    /**
     * Returns all items in the collection for which the passed function returns true
     * @param {function} fn The function to run for each item inside the start-end range. Return true for a match.
     * @param {Object} fn.item The current collection item
     * @param {Object} scope=this The scope in which the passed function gets executed
     * @param {Number} start=0 The start index
     * @param {Number} end=this.count The end index (up to, last value excluded)
     * @returns {Array} Returns an empty Array in case no items are found
     */
    findBy(fn, scope=this, start=0, end=this.count) {
        let me    = this,
            items = [],
            i     = start;

        for (; i < end; i++) {
            if (fn.call(scope, me.items[i])) {
                items.push(me.items[i])
            }
        }

        return items
    }

    /**
     * Returns the first item which matches the property and value
     * @param {Object|String} property
     * @param {Number|String} [value] Only required in case the first param is a string
     * @returns {Object} Returns the first found item or null
     */
    findFirst(property, value) {
        return this.find(property, value, true)
    }

    /**
     * Returns the first item inside the collection
     * @returns {Object}
     */
    first() {
        return this.getAt(0)
    }

    /**
     * Returns the object associated to the key, or null if there is none.
     * @param {Number|String} key
     * @returns {Object|null}
     */
    get(key) {
        return this.map.get(key) || null
    }

    /**
     * Returns the item for a given index
     * @param {Number} index
     * @returns {Object|undefined}
     */
    getAt(index) {
        return this._items[index]
    }

    /**
     * Returns the config value of this.count
     * @returns {Number}
     * @deprecated Use `this.count` directly instead.
     */
    getCount() {
        return this._count || 0 // skipping beforeGetCount() on purpose
    }

    /**
     * @returns {Number}
     */
    getCountMutations() {
        return this[countMutations]
    }

    /**
     * Returns the first matching filter for the given property config
     * @param {String} property
     * @returns {Neo.collection.Filter|null}
     */
    getFilter(property) {
        let filters = this.filters || [],
            i       = 0,
            len     = filters.length;

        for (; i < len; i++) {
            if (filters[i].property === property) {
                return filters[i]
            }
        }

        return null
    }

    /**
     * Returns the key for a given index
     * @param {Number} index
     * @returns {Number|String|undefined}
     */
    getKeyAt(index) {
        let item = this._items[index];
        return item?.[this.keyProperty]
    }

    /**
     * Returns a shallow copy of a portion of the items array
     * @param {Number} [start] Zero-based index at which to begin extraction.
     * @param {Number} [end] Zero-based index before which to end extraction (extracts up to but not including end).
     * @returns {Array}
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice
     */
    getRange(start, end) {
        return this._items.slice(start, end)
    }

    /**
     * Returns the Source Collection in case the sourceCollectionId config was set
     * @returns {Neo.collection.Base|undefined}
     */
    getSource() {
        return this.sourceId && Neo.get(this.sourceId)
    }

    /**
     * Returns a boolean asserting whether a value has been associated to the key in the Collection or not
     * @param {Number|String} key
     * @returns {Boolean}
     */
    has(key) {
        return this.map.has(key)
    }

    /**
     * Returns a boolean asserting whether an item exists in the Collection or not
     * @param {Object} item
     * @returns {Boolean}
     */
    hasItem(item) {
        return this.map.has(item[this.keyProperty])
    }

    /**
     * Returns the index for a given key or item
     * @param {Number|String|Object} key
     * @returns {Number} index (-1 in case no match is found)
     */
    indexOf(key) {
        let me = this;
        return me._items.indexOf(me.isItem(key) ? key : me.map.get(key))
    }

    /**
     * Returns the index for a given item
     * @param {Object} item
     * @returns {Number} index (-1 in case no match is found)
     */
    indexOfItem(item) {
        return this._items.indexOf(item)
    }

    /**
     * Returns the index for a given key
     * @param {Number|String} key
     * @returns {Number} index (-1 in case no match is found)
     */
    indexOfKey(key) {
        return this._items.indexOf(this.map.get(key))
    }

    /**
     * Inserts an item or an array of items at the specified index
     * @param {Number} index
     * @param {Array|Object} item
     * @returns {Object[]} an array containing all added items
     */
    insert(index, item) {
        return this.splice(index, 0, item).addedItems
    }

    /**
     * @returns {Boolean} true in case the collection is filtered
     */
    isFiltered() {
        return this[isFiltered]
    }

    /**
     * @param {Object} item
     * @returns {boolean}
     * @protected
     */
    isFilteredItem(item) {
        let me         = this,
            filters    = me._filters,
            i          = 0,
            len        = filters.length,
            isFiltered = false;

        for (; i < len; i++) {
            if (filters[i].isFiltered(item)) {
                isFiltered = true;
                break
            }
        }

        return isFiltered
    }

    /**
     * Helper method to check if a given input is either object-like or a key
     * @param {*} value
     * @returns {Boolean} returns true for object-like values
     */
    isItem(value) {
        // We can not use Neo.isObject() || Neo.isRecord(), since collections can store neo instances too.
        return typeof value === 'object'
    }

    /**
     * @returns {Boolean} true in case the collection is sorted
     */
    isSorted() {
        return this[isSorted]
    }

    /**
     * Returns the last item inside the collection
     * @returns {Object}
     */
    last() {
        return this.getAt(this.count -1)
    }

    /**
     * Moves an item from fromIndex to toIndex
     * @param {Number} fromIndex
     * @param {Number} toIndex
     */
    move(fromIndex, toIndex) {
        if (fromIndex === toIndex) {
            return;
        }

        let items = this._items;

        if (fromIndex >= items.length) {
            fromIndex = items.length - 1
        }

        // The splice operations are intentionally separated.
        // Using the common one-liner `items.splice(toIndex, 0, items.splice(fromIndex, 1)[0])`
        // can lead to unpredictable side effects, as the inner splice can alter the array
        // before the outer splice's index is resolved. This two-step approach is safer.
        const item = items.splice(fromIndex, 1)[0];
        items.splice(toIndex, 0, item)
    }

    /**
     * @param {Object} opts
     * @protected
     */
    onFilterChange(opts) {
        this.filter()
    }

    /**
     * @param {Object} opts
     * @protected
     */
    onMutate(opts) {
        let me = this;

        // todo: inspect the bubbling chain
        /*if (opts.preventBubbleUp) {
            me.preventBubbleUp = true
        }*/

        me.preventBubbleUp = true;

        me.splice(null, opts.removedItems, opts.addedItems)
    }

    /**
     * @param {Object} opts
     * @protected
     */
    onSorterChange(opts) {
        this.applySorterConfigs();
        this.doSort()
    }

    /**
     * Removes the last element from the items array and returns this element.
     * @returns {Object} The removed element from the collection; undefined if the collection is empty.
     */
    pop() {
        let mutation = this.splice(this.count -1, 1);
        return mutation.removedItems[0]
    }

    /**
     * Adds one or more items to the end of the collection and returns the new items count
     * @param {Array|Object} item The item(s) to add
     * @returns {Number} the collection count
     */
    push(item) {
        return this.add(item)
    }

    /**
     * Removes a given key, item or Array containing keys|items
     * @param {Number|String|Object|Array} key
     * @returns {Number} the collection count
     */
    remove(key) {
        this.splice(0, Array.isArray(key) ? key : [key]);
        return this.count
    }

    /**
     * Removes the item at the given index
     * @param {Number} index
     * @returns {Number} the collection count
     */
    removeAt(index) {
        this.splice(index, 1);
        return this.count
    }

    /**
     * Reverses the items array in place.
     * Intended for collections without sorters.
     * @returns {Array} items
     */
    reverse() {
        return this._items.reverse()
    }

    /**
     * Removes the first element from the items array and returns this element.
     * @returns {Object} The removed element from the collection; undefined if the collection is empty.
     */
    shift() {
        let mutation = this.splice(0, 1);
        return mutation.addedItems[0]
    }

    /**
     * @param {function} callback Function to test for each item, taking three parameters:
     * @param {Object}   callback.item The current collection item being processed
     * @param {Number}  [callback.index] The index of the current item being processed
     * @param {Array}   [callback.items] The items array of the collection
     *
     * @param {Object} [scope] Value to use as "this" when executing the callback
     * @returns {boolean} true if the callback function returns a truthy value for any collection item, otherwise false
     */
    some(...args) {
        return this._items.some(...args)
    }

    /**
     * Executes a provided function once for each array element.
     * @param {Function} fn The function to execute for each element.
     * @param {Object} [scope] Value to use as `this` when executing `fn`.
     */
    forEach(fn, scope) {
        this._items.forEach(fn, scope);
    }

    /**
     * Removes items from and/or adds items to this collection
     * If the toRemoveArray is used, then the index is not used for removing, the entries are found by key and removed from where they are.
     * If index is not passed, toAddArray is appended to the Collection.
     * @param {Number|null} index
     * @param {Number|Object[]} [removeCountOrToRemoveArray]
     * @param {Object|Object[]} [toAddArray]
     * @returns {Object} An object containing the addedItems & removedItems arrays
     */
    splice(index, removeCountOrToRemoveArray, toAddArray) {
        let me                 = this,
            {keyProperty, map} = me,
            source             = me.getSource(),
            addedItems         = [],
            items              = me._items,
            removedItems       = [],
            removeCountAtIndex = Neo.isNumber(removeCountOrToRemoveArray) ? removeCountOrToRemoveArray : null,
            toRemoveArray      = Array.isArray(removeCountOrToRemoveArray) ? removeCountOrToRemoveArray : null,
            i, item, key, len, toAddMap;

        if (!Neo.isNumber(index) && removeCountAtIndex) {
            _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].error(me.id + ': If index is not passed, removeCountAtIndex cannot be used')
        }

        toAddArray = toAddArray && !Array.isArray(toAddArray) ? [toAddArray] : toAddArray;

        if (toRemoveArray && (len = toRemoveArray.length) > 0) {
            if (toAddArray && toAddArray.length > 0) {
                toAddMap = toAddArray.map(e => e[keyProperty])
            }

            for (i=0; i < len; i++) {
                item = toRemoveArray[i];
                key  = me.isItem(item) ? item[keyProperty] : item;

                if (map.has(key)) {
                    if (!toAddMap || (toAddMap && toAddMap.indexOf(key) < 0)) {
                        removedItems.push(items.splice(me.indexOfKey(key), 1)[0]);
                        map.delete(key)
                    }
                }
            }
        } else if (removeCountAtIndex && removeCountAtIndex > 0) {
            // Optimization: If this is a full clear operation, use map.clear()
            if (index === 0 && removeCountAtIndex === me.count) {
                removedItems = items;
                me._items = [];
                map.clear()
            } else {
                removedItems = items.splice(index, removeCountAtIndex);

                // For partial removals, iterate and delete individual items from the map
                removedItems.forEach(e => {
                    map.delete(e[keyProperty])
                })
            }
        }

        if (toAddArray && (len = toAddArray.length) > 0) {
            for (i=0; i < len; i++) {
                item = toAddArray[i];
                key  = item[keyProperty];

                if (!key) {
                    item[keyProperty] = key = me.keyPropertyIndex;
                    me.keyPropertyIndex--
                }

                if (!map.has(key) && !me.isFilteredItem(item)) {
                    addedItems.push(item);
                    map.set(key, item)
                }
            }

            if (addedItems.length > 0) {
                if (!items || items.length === 0) {
                    // Performance improvement for Safari, see: https://github.com/neomjs/neo/issues/6228
                    me._items = addedItems
                } else {
                    const finalIndex = Neo.isNumber(index) ? index : items.length;

                    if (addedItems.length > 5000) {
                        // Manually splice for large arrays to avoid a stack overflow
                        const beginning = items.slice(0, finalIndex);
                        const end       = items.slice(finalIndex);
                        me._items       = beginning.concat(addedItems, end);
                    } else {
                        items.splice(finalIndex, 0, ...addedItems)
                    }
                }

                if (me.autoSort && me._sorters.length > 0) {
                    me.doSort()
                }
            }
        }

        if (source) {
            if (!source.getSource()) {
                source.preventBubbleUp = true
            }

            if (!me.preventBubbleUp) {
                // console.log('source splice', source.id, 'added:', ...toAddArray, 'removed:', ...removedItems);
                me.startUpdate(true);
                source.splice(null, toRemoveArray || removedItems, toAddArray);
                me.endUpdate(true)
            }

            delete source.preventBubbleUp
        }

        if (addedItems.length > 0 || removedItems.length > 0) {
            me[countMutations]++
        }

        if (me[updatingIndex] === 0) {
            me.count = me._items.length;

            me.fire('mutate', {
                addedItems     : toAddArray,
                preventBubbleUp: me.preventBubbleUp,
                removedItems   : toRemoveArray || removedItems
            })
        } else if (!me[silentUpdateMode]) {
            me.cacheUpdate({
                addedItems,
                removedItems
            })
        }

        if (me[updatingIndex] === 0) {
            delete me.preventBubbleUp
        }

        return {addedItems, removedItems}
    }

    /**
     * Prevents the collection from firing events until endUpdate gets called.
     * If you start an update using the startSilentUpdateMode param,
     * the mutation event will not fire after using endUpdate()
     * (you must use the endSilentUpdateMode param for the endUpdate call in case you used
     * startSilentUpdateMode here)
     * @param {Boolean} [startSilentUpdateMode]
     * @see {@link Neo.collection.Base#endUpdate endUpdate}
     */
    startUpdate(startSilentUpdateMode) {
        if (startSilentUpdateMode) {
            this[silentUpdateMode] = true
        }

        this[updatingIndex]++
    }

    /**
     * Adds one or more elements to the beginning of the collection and returns the new items count
     * @param {Array|Object} item The item(s) to add
     * @returns {Number} the collection count
     */
    unshift(item) {
        this.splice(0, 0, item);
        return this.count
    }
}

/**
 * The mutate event fires after every splice call (invoked by all methods which change the content of the items array).
 * @event mutate
 * @param {Object[]} addedItems
 * @param {Boolean} preventBubbleUp private
 * @param {Object[]} removedItems
 * @returns {Object}
 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Collection));


/***/ }),

/***/ "./src/collection/Filter.mjs":
/*!***********************************!*\
  !*** ./src/collection/Filter.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");



/**
 * @class Neo.collection.Filter
 * @extends Neo.core.Base
 * @mixes Neo.core.Observable
 */
class Filter extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true
    /**
     * Valid values for the operator config:<br>
     * ['==','===','!=','!==','<','<=','>','>=','endsWith','excluded','included','isDefined','isUndefined','like','startsWith']
     * @member {String[]} operators
     * @protected
     * @static
     */
    static operators = [
        '==', '===', '!=', '!==', '<', '<=', '>', '>=', 'endsWith', 'excluded', 'included',
        'isDefined', 'isUndefined', 'like', 'startsWith'
    ]

    static config = {
        /**
         * @member {String} className='Neo.collection.Filter'
         * @protected
         */
        className: 'Neo.collection.Filter',
        /**
         * @member {String} ntype='filter'
         * @protected
         */
        ntype: 'filter',
        /**
         * Setting disabled to true will exclude this filter from the collection filtering logic
         * @member {Boolean} disabled_=false
         * @reactive
         */
        disabled_: false,
        /**
         * Provide a custom filtering function which has a higher priority than property, operator & value
         * @member {Function|null} filterBy_=null
         * @reactive
         */
        filterBy_: null,
        /**
         * True means not filtering out items in case the value is '', null, [] or {}
         * @member {Boolean} includeEmptyValues=true
         */
        includeEmptyValues: true,
        /**
         * Set this flag to true before starting bulk updates (e.g. changing property & value)
         * to prevent multiple change events
         * @member {Boolean} isUpdating_=false
         * @reactive
         */
        isUpdating_: false,
        /**
         * The owner util.Collection needs to apply an onChange listener once
         * @member {Boolean} listenerApplied=false
         * @protected
         */
        listenerApplied: false,
        /**
         * The operator to filter by (use the combination of property, operator & value)
         * Valid values:
         *
         * == (not recommended)
         * ===
         * != (not recommended)
         * !==
         * <
         * >=
         * >
         * >=
         * like (collectionValue.toLowerCase().indexOf(filterValue.toLowerCase()) > -1)
         * included (expects value to be an array)
         * excluded (expects value to be an array)
         * @member {String} operator='==='
         */
        operator_: '===',
        /**
         * The property to filter by (use the combination of property, operator & value)
         * @member {String} property_='id'
         * @reactive
         */
        property_: 'id',
        /**
         * The scope to use for the filterBy method, in case it is provided. Defaults to this instance.
         * @member {Object|null} scope=null
         */
        scope: null,
        /**
         * The value to filter by (use the combination of property, operator & value)
         * @member {String} value_=null
         * @reactive
         */
        value_: null
    }

    afterSetDisabled(...args) {
        this.fireChangeEvent(...args)
    }

    afterSetFilterBy(value, oldValue) {
        // todo
    }

    afterSetIsUpdating(value, oldValue) {
        value === false && this.fireChangeEvent(value, oldValue)
    }

    afterSetOperator(...args) {
        this.fireChangeEvent(...args)
    }

    afterSetProperty(...args) {
        this.fireChangeEvent(...args)
    }

    afterSetValue(...args) {
        this.fireChangeEvent(...args)
    }

    beforeSetFilterBy(value, oldValue) {
        if (value && typeof value !== 'function') {
            Neo.logError('filterBy has to be a function', this);
            return oldValue
        }

        return value
    }

    /**
     * Triggered before the operator config gets changed.
     * @param {String|null} value
     * @param {String} oldValue
     * @returns {String}
     * @protected
     */
    beforeSetOperator(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'operator')
    }

    /**
     * Needed for remote filtering
     * @returns {Object|null}
     */
    export() {
        let me                          = this,
            {operator, property, value} = me;

        if (!me.filterBy) {
            return {operator, property, value}
        }

        return null
    }

    /**
     * @param value
     * @param oldValue
     */
    fireChangeEvent(value, oldValue) {
        let me = this;

        if (oldValue !== undefined && me.isUpdating !== true) {
            let {operator, property, value} = me;
            me.fire('change', {operator, property, value})
        }
    }

    /**
     * Checks if a collection item matches this filter
     * @param {Object} item The current collection item
     * @param {Array} filteredItems If the collection filterMode is not primitive contains the items which passed
     * the previous filters, otherwise all collection items
     * @param {Array} allItems all collection items
     * @returns {Boolean}
     */
    isFiltered(item, filteredItems, allItems) {
        let me = this,
            filterValue, recordValue;

        if (me._disabled) {
            return false
        }

        if (me._filterBy) {
            return me.filterBy.call(me.scope || me, {
                allItems,
                filteredItems,
                item,
                value: me._value
            })
        }

        if (me.includeEmptyValues && (me._value === null || Neo.isEmpty(me._value))) {
            return false
        }

        filterValue = me._value;
        recordValue = item[me._property];

        if (filterValue instanceof Date && recordValue instanceof Date) {
            filterValue = filterValue.valueOf();
            recordValue = recordValue.valueOf()
        }

        return !Filter[me._operator](recordValue, filterValue)
    }

    static ['=='] (a, b) {return a == b}
    static ['==='](a, b) {return a === b}
    static ['!='] (a, b) {return a != b}
    static ['!=='](a, b) {return a !== b}
    static ['<']  (a, b) {return a < b}
    static ['<='] (a, b) {return a <= b}
    static ['>']  (a, b) {return a > b}
    static ['>='] (a, b) {return a >= b}

    static ['endsWith'](a, b) {
        if (!Neo.isString(a)) {a = String(a)}
        if (!Neo.isString(b)) {b = String(b)}

        return a?.toLowerCase().endsWith(b?.toLowerCase()) || false
    }

    static ['excluded'](a, b) {
        return b.indexOf(a) < 0
    }

    static ['included'](a, b) {
        return b.indexOf(a) > -1
    }

    static ['isDefined'](a, b) {
        return a !== undefined
    }

    static ['isUndefined'](a, b) {
        return a === undefined
    }

    static ['like'](a, b) {
        if (!Neo.isString(a)) {a = String(a)}
        if (!Neo.isString(b)) {b = String(b)}

        return a?.toLowerCase().includes(b?.toLowerCase()) || false
    }

    static ['startsWith'](a, b) {
        if (!Neo.isString(a)) {a = String(a)}
        if (!Neo.isString(b)) {b = String(b)}

        return a?.toLowerCase().startsWith(b?.toLowerCase()) || false
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Filter));


/***/ }),

/***/ "./src/collection/Sorter.mjs":
/*!***********************************!*\
  !*** ./src/collection/Sorter.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");



/**
 * @class Neo.collection.Sorter
 * @extends Neo.core.Base
 * @mixes Neo.core.Observable
 */
class Sorter extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.collection.Sorter'
         * @protected
         */
        className: 'Neo.collection.Sorter',
        /**
         * @member {String} ntype='sorter'
         * @protected
         */
        ntype: 'sorter',
        /**
         * Internal config which maps the direction ASC to 1, -1 otherwise
         * @member {Number} directionMultiplier=1
         * @protected
         */
        directionMultiplier: 1,
        /**
         * The sort direction when using a property.
         * @member {String} direction_='ASC'
         * @reactive
         */
        direction_: 'ASC',
        /**
         * The owner util.Collection needs to apply an onChange listener once
         * @member {boolean} listenerApplied=false
         * @protected
         */
        listenerApplied: false,
        /**
         * The property to sort by.
         * @member {String} property_='id'
         * @reactive
         */
        property_: 'id',
        /**
         * Provide a custom sorting function, has a higher priority than property & direction
         * @member {Function|null} sortBy=null
         * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator
         */
        sortBy: null,
        /**
         * True to use the transformValue method for each item (the method can get overridden)
         * @member {Boolean} useTransformValue=true
         * @protected
         */
        useTransformValue: true
    }

    /**
     * @param {String} value
     * @param {String} oldValue
     */
    afterSetDirection(value, oldValue) {
        let me = this;

        me.directionMultiplier = value === 'ASC' ? 1 : -1;

        if (oldValue) {
            me.fire('change', {
                direction: me.direction,
                property : me.property
            });
        }
    }

    /**
     * @param {String} value
     * @param {String} oldValue
     */
    afterSetProperty(value, oldValue) {
        let me = this;

        if (oldValue) {
            me.fire('change', {
                direction: me.direction,
                property : me.property
            });
        }
    }

    /**
     * Default sorter function which gets used by collections in case at least one sorter has a real sortBy method
     * @param a
     * @param b
     */
    defaultSortBy(a, b) {
        let me = this;

        a = a[me.property];
        b = b[me.property];

        if (me.useTransformValue) {
            a = me.transformValue(a);
            b = me.transformValue(b);
        }

        if (a > b) {
            return 1 * me.directionMultiplier;
        }

        if (a < b) {
            return -1 * me.directionMultiplier;
        }

        return 0;
    }

    /**
     * Needed for remote sorting
     * @returns {Object|null}
     */
    export() {
        let me                    = this,
            {direction, property} = me;

        if (!me.sortBy && direction && property) {
            return {direction, property}
        }

        return null
    }

    /**
     * @param {*} value
     * @returns {*} value
     */
    transformValue(value) {
        if (typeof value === 'string') {
            value = value.toLowerCase()
        }

        return value
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Sorter));


/***/ }),

/***/ "./src/controller/Application.mjs":
/*!****************************************!*\
  !*** ./src/controller/Application.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/controller/Base.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");



/**
 * @class Neo.controller.Application
 * @extends Neo.controller.Base
 */
class Application extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.controller.Application'
         * @protected
         */
        className: 'Neo.controller.Application',
        /**
         * @member {String} ntype='application'
         * @protected
         */
        ntype: 'application',
        /**
         * @member {String|null} appThemeFolder=null
         */
        appThemeFolder: null,
        /**
         * @member {Neo.component.Base} mainView_=null
         * @reactive
         */
        mainView_: null,
        /**
         * @member {Boolean} mounted=false
         * @protected
         */
        mounted: false,
        /**
         * @member {String} name='MyApp'
         */
        name: 'MyApp',
        /**
         * @member {String} parentId='document.body'
         */
        parentId: 'document.body',
        /**
         * @member {Boolean} vnodeInitialising=false
         * @protected
         */
        vnodeInitialising: false,
        /**
         * @member {Boolean} vnodeInitialized=false
         * @protected
         */
        vnodeInitialized: false,
        /**
         * @member {Number|null} windowId=null
         */
        windowId: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        // to guarantee that the main view can access Neo.apps at any point,
        // we need to trigger its assignment at the end of the ctor.
        let mainView = config.mainView;
        delete config.mainView;

        super.construct(config);

        let me = this;

        me.windowId = Neo.config.windowId;

        Neo.apps = Neo.apps || {};

        Neo.apps[me.name] = me;

        Neo.currentWorker.registerApp(me.name);

        if (mainView) {
            me.mainView = mainView
        }
    }

    /**
     * Triggered after the mainView config got changed
     * @param {Neo.component.Base} value
     * @param {Neo.component.Base|null} oldValue
     * @protected
     */
    async afterSetMainView(value, oldValue) {
        if (value) {
            let me = this;

            // short delay to ensure changes from onHashChange() got applied
            await me.timeout(Neo.config.hash ? 200 : 10);

            await value.initVnode(true)
        }
    }

    /**
     * Triggered before the mainView config gets changed.
     * @param {Object} value
     * @param {Object} oldValue
     * @returns {Neo.component.Base|null}
     * @protected
     */
    beforeSetMainView(value, oldValue) {
        if (value) {
            return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, null, {
                appName : this.name,
                parentId: this.parentId,
                windowId: Neo.config.windowId
            })
        }

        return null
    }

    /**
     * Unregister the app from the CSS map
     * @param args
     */
    destroy(...args) {
        Neo.currentWorker.removeAppFromThemeMap(this.name);
        super.destroy(...args)
    }
}

Application = Neo.setupClass(Application);

// convenience shortcut
Neo.app = config => Neo.create({
    module: Application,
    ...config
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Application);


/***/ }),

/***/ "./src/controller/Base.mjs":
/*!*********************************!*\
  !*** ./src/controller/Base.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_HashHistory_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/HashHistory.mjs */ "./src/util/HashHistory.mjs");



const
    regexAmountSlashes       = /\//g,
    // Regex to extract the parameter name from a single route segment (e.g., {*itemId} -> itemId)
    regexParamNameExtraction = /{(\*|\.\.\.)?([^}]+)}/,
    // Regex to match route parameters like {paramName}, {*paramName}, or {...paramName}
    regexRouteParam          = /{(\*|\.\.\.)?([^}]+)}/g;

/**
 * @class Neo.controller.Base
 * @extends Neo.core.Base
 */
class Controller extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.controller.Base'
         * @protected
         */
        className: 'Neo.controller.Base',
        /**
         * @member {String} ntype='controller'
         * @protected
         */
        ntype: 'controller',
        /**
         * If the URL does not contain a hash value when this controller instance is created,
         * Neo.mjs will automatically set this hash value, ensuring a default route is active.
         * @member {String|null} defaultHash=null
         */
        defaultHash: null,
        /**
         * Specifies the handler method to be invoked when no other defined route matches the URL hash.
         * This acts as a fallback for unhandled routes.
         * @member {String|null} defaultRoute=null
         */
        defaultRoute: null,
        /**
         * Internal map of compiled regular expressions for each route, used for efficient hash matching.
         * @protected
         * @member {Object} handleRoutes={}
         */
        handleRoutes: {},
        /**
         * Defines the routing rules for the controller. Keys are route patterns, and values are either
         * handler method names (String) or objects containing `handler` and optional `preHandler` method names.
         * Route patterns can include parameters like `{paramName}` and wildcards like `{*paramName}` for nested paths.
         * @example
         * routes: {
         *     '/home'                         : 'handleHomeRoute',
         *     '/users/{userId}'               : {handler: 'handleUserRoute', preHandler: 'preHandleUserRoute'},
         *     '/users/{userId}/posts/{postId}': 'handlePostRoute',
         *     '/learn/{*itemId}'              : 'onLearnRoute', // Captures nested paths like /learn/gettingstarted/Workspaces
         *     'default'                       : 'handleOtherRoutes'
         * }
         * @member {Object} routes_={}
         * @reactive
         */
        routes_: {}
    }

    /**
     * Creates a new Controller instance and registers its `onHashChange` method
     * to listen for changes in the browser's URL hash.
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);
        _util_HashHistory_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].on('change', this.onHashChange, this)
    }

    /**
     * Processes the defined routes configuration, compiling route patterns into regular expressions
     * for efficient matching and sorting them by specificity (more slashes first).
     * @param {Object} value
     * @param {Object} oldValue
     * @protected
     */
    afterSetRoutes(value, oldValue){
        let me        = this,
            routeKeys = Object.keys(value);

         me.routes = routeKeys.sort(me.#sortRoutes).reduce((obj, key) => {
             obj[key] = value[key];
             return obj
         }, {});

        me.handleRoutes = {};

        routeKeys.forEach(key => {
            if (key.toLowerCase() === 'default'){
                me.defaultRoute = value[key]
            } else {
                me.handleRoutes[key] = new RegExp(key.replace(regexRouteParam, (match, isWildcard, paramName) => {
                    if (isWildcard || paramName.startsWith('*')) {
                        return '(.*)'
                    } else {
                        return '([\\w-.]+)'
                    }
                }))
            }
        })
    }

    /**
     * @param args
     */
    destroy(...args) {
        _util_HashHistory_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].un('change', this.onHashChange, this);
        super.destroy(...args)
    }

    /**
     * @returns {Promise<void>}
     */
    async initAsync() {
        await super.initAsync();

        let me                      = this,
            {defaultHash, windowId} = me,
            currentHash             = _util_HashHistory_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].first(windowId);

        if (currentHash) {
            if (currentHash.windowId === windowId) {
                await me.onHashChange(currentHash, null)
            }
        } else {
            /*
             * worker.App: onLoadApplication() will push config.hash into the HashHistory with a 5ms delay.
             * We only want to set a default route, in case the HashHistory is empty and there is no initial
             * value that will get consumed.
             */
            !Neo.config.hash && defaultHash && Neo.Main.setRoute({value: defaultHash, windowId})
        }
    }

    /**
     * Handles changes in the browser's URL hash. It identifies the most specific matching route
     * and dispatches the corresponding handler, optionally executing a preHandler first.
     * @param {Object} value - The new hash history entry.
     * @param {Object} oldValue - The previous hash history entry.
     */
    async onHashChange(value, oldValue) {
        // We only want to trigger hash changes for the same browser window (SharedWorker context)
        if (value.windowId !== this.windowId) {
            return
        }

        let me                     = this,
            {handleRoutes, routes} = me,
            routeKeys              = Object.keys(handleRoutes),
            bestMatch              = null,
            bestMatchKey           = null,
            bestMatchParams        = null;

        for (let i = 0; i < routeKeys.length; i++) {
            const key = routeKeys[i];
            const result = value.hashString.match(handleRoutes[key]);

            if (result) {
                const
                    arrayParamIds    = key.match(regexRouteParam),
                    arrayParamValues = result.splice(1, result.length - 1),
                    paramObject      = {};

                if (arrayParamIds) {
                    for (let j = 0; j < arrayParamIds.length; j++) {
                        const paramMatch = arrayParamIds[j].match(regexParamNameExtraction);

                        if (paramMatch) {
                            const paramName = paramMatch[2];
                            paramObject[paramName] = arrayParamValues[j];
                        }
                    }
                }

                // Logic to determine the best matching route:
                // 1. Prioritize routes that match a longer string (more specific match).
                // 2. If lengths are equal, prioritize routes with more slashes (deeper nesting).
                if (!bestMatch || (result[0].length > bestMatch[0].length) ||
                    (result[0].length === bestMatch[0].length && (key.match(regexAmountSlashes) || []).length > (bestMatchKey.match(regexAmountSlashes) || []).length)) {
                    bestMatch = result;
                    bestMatchKey = key;
                    bestMatchParams = paramObject;
                }
            }
        }

        if (bestMatch) {
            const route = routes[bestMatchKey];
            let handler    = null,
                preHandler = null;

            if (Neo.isString(route)) {
                handler = route
            } else if (Neo.isObject(route)) {
                handler    = route.handler;
                preHandler = route.preHandler
            }

            let responsePreHandler = true;

            if (preHandler) {
                responsePreHandler = await me[preHandler]?.call(me, bestMatchParams, value, oldValue)
            }

            if (responsePreHandler) {
                await me[handler]?.call(me, bestMatchParams, value, oldValue)
            }
        } else {
            if (me.defaultRoute) {
                me[me.defaultRoute]?.(value, oldValue)
            } else {
                me.onNoRouteFound(value, oldValue)
            }
        }
    }

    /**
     * Placeholder method invoked when no matching route is found for the current URL hash.
     * Controllers can override this to implement custom behavior for unhandled routes.
     * @param {Object} value - The current hash history entry.
     * @param {Object} oldValue - The previous hash history entry.
     */
    onNoRouteFound(value, oldValue) {

    }

    /**
     * Internal helper method to sort routes by their specificity.
     * Routes with more slashes are considered more specific and are prioritized.
     * @param {String} route1 - The first route string to compare.
     * @param {String} route2 - The second route string to compare.
     * @returns {Number} A negative value if route1 is more specific, a positive value if route2 is more specific, or 0 if they have equal specificity.
     */
    #sortRoutes(route1, route2) {
        return (route1.match(regexAmountSlashes) || []).length - (route2.match(regexAmountSlashes)|| []).length
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Controller));


/***/ }),

/***/ "./src/core/Base.mjs":
/*!***************************!*\
  !*** ./src/core/Base.mjs ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_Function_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/Function.mjs */ "./src/util/Function.mjs");
/* harmony import */ var _core_Compare_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Compare.mjs */ "./src/core/Compare.mjs");
/* harmony import */ var _core_Util_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Util.mjs */ "./src/core/Util.mjs");
/* harmony import */ var _Config_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Config.mjs */ "./src/core/Config.mjs");
/* harmony import */ var _ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");
/* harmony import */ var _IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./IdGenerator.mjs */ "./src/core/IdGenerator.mjs");
/* harmony import */ var _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./EffectManager.mjs */ "./src/core/EffectManager.mjs");








const configSymbol       = Symbol.for('configSymbol'),
      forceAssignConfigs = Symbol('forceAssignConfigs'),
      isInstance         = Symbol('isInstance');

/**
 * The base class for (almost) all classes inside the Neo namespace
 * Exceptions are e.g. core.IdGenerator, vdom.VNode
 * @class Neo.core.Base
 */
class Base {
    /**
     * You can define methods which should get delayed.
     * Types are buffer, debounce & throttle.
     * @example
     *  delayable: {
     *      fireChangeEvent: {
     *          type : 'debounce',
     *          timer: 300
     *      }
     *  }
     * @member {Object} delayable={}
     * @protected
     * @static
     */
    static delayable = {}
    /**
     * Flag which will get set to true once manager.Instance got created
     * @member {Boolean} instanceManagerAvailable=false
     * @static
     */
    static instanceManagerAvailable = false
    /**
     * Regex to grab the MethodName from an error
     * which is a second generation function
     * @member {RegExp} methodNameRegex
     * @static
     */
    static methodNameRegex = /\n.*\n\s+at\s+.*\.(\w+)\s+.*/
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=false
     * @static
     */
    static observable = false
    /**
     * Keep the overwritten methods
     * @member {Object} overwrittenMethods={}
     * @protected
     * @static
     */
    static overwrittenMethods = {}
    /**
     * Defines the default configuration properties for the class. These configurations are
     * merged throughout the class hierarchy and can be overridden at the instance level.
     *
     * There are two main types of configs:
     *
     * 1.  **Reactive Configs:** Property names ending with a trailing underscore (e.g., `myConfig_`).
     *     The framework automatically generates a public getter and setter, removing the underscore
     *     from the property name (e.g., `this.myConfig`). This system enables powerful, optional
     *     lifecycle hooks that are called automatically if they are implemented on the class:
     *     - `beforeGetMyConfig(value)`: Executed before the getter returns. Can be used to dynamically modify the returned value.
     *     - `beforeSetMyConfig(newValue, oldValue)`: Executed before a new value is set. Can be used for validation or transformation. Returning `undefined` from this hook will cancel the update.
     *     - `afterSetMyConfig(newValue, oldValue)`: Executed after a new value has been successfully set. Ideal for triggering side effects.
     *
     * 2.  **Non-Reactive (Prototype-based) Configs:** Property names without a trailing underscore.
     *     These are applied directly to the class's **prototype** during the `Neo.setupClass`
     *     process. This is highly memory-efficient as the value is shared across all instances.
     *     It also allows for powerful, application-wide modifications of default behaviors
     *     by using the `Neo.overwrites` mechanism, which modifies these prototype values at
     *     load time.
     *
     * @returns {Object} config
     */
    static config = {
        /**
         * The class name which will get mapped into the Neo or app namespace
         * @member {String} className='Neo.core.Base'
         * @protected
         */
        className: 'Neo.core.Base',
        /**
         * The class shortcut-name to use for e.g. creating child components inside a JSON-format
         * @member {String} ntype='base'
         * @protected
         */
        ntype: 'base',
        /**
         * While it is recommended to change the static delayable configs on class level,
         * you can change it on instance level too. If not null, we will do a deep merge.
         * @member {Object} delayable=null
         */
        delayable: null,
        /**
         * The unique component id
         * @member {String|null} id_=null
         * @reactive
         */
        id_: null,
        /**
         * An array of remote method names that should be intercepted.
         * Names used here must be present inside the `remote_` config.
         * If a remote call for one of these methods arrives, `onInterceptRemotes()` will be called.
         * @member {String[]|null} interceptRemotes=null
         * @protected
         */
        interceptRemotes: null,
        /**
         * Neo.create() will change this flag to true after the onConstructed() chain is done.
         * @member {Boolean} isConstructed=false
         * @protected
         */
        isConstructed: false,
        /**
         * This config will be set to `true` as the very first action within the `destroy()` method.
         * Effects can observe this config to clean themselves up.
         * @member {Boolean} isDestroying_=false
         * @protected
         * @reactive
         */
        isDestroying_: false,
        /**
         * The config will get set to `true` once the Promise of `async initAsync()` is resolved.
         * You can use `afterSetIsReady()` to get notified once the ready state is reached.
         * Since not all classes use the Observable mixin, Neo will not fire an event.
         * method body.
         * @member {Boolean} isReady_=false
         * @reactive
         */
        isReady_: false,
        /**
         * Add mixins as an array of classNames, imported modules or a mixed version
         * @member {String[]|Neo.core.Base[]|null} mixins=null
         */
        mixins: null,
        /**
         * You can create a new instance by passing an imported class (JS module default export)
         * @member {Class} module=null
         * @protected
         */
        module: null,
        /**
         * Remote method access for other threads. Example use case:
         * remote: {app: ['myRemoteMethod']}
         *
         * ONLY supported for singletons.
         *
         * @member {Object|null} remote_=null
         * @protected
         * @reactive
         */
        remote_: null
    }

    /**
     * A private field to store the Config controller instances.
     * @member {Object} #configs={}
     * @private
     */
    #configs = {};
    /**
     * Internal cache for all config subscription cleanup functions.
     * @member {Function[]} #configSubscriptionCleanups=[]
     * @private
     */
    #configSubscriptionCleanups = []
    /**
     * Internal cache for all timeout ids when using this.timeout()
     * @member {Number[]} timeoutIds=[]
     * @private
     */
    #timeoutIds = []

    /**
     * The main initializer for all Neo.mjs classes, invoked by `Neo.create()`.
     * NOTE: This is not the native `constructor()`, which is called without arguments by `Neo.create()` first.
     *
     * This method orchestrates the entire instance initialization process, including
     * the setup of the powerful and flexible config system.
     *
     * The `config` parameter is a single object that can contain different types of properties,
     * which are processed in a specific order to ensure consistency and predictability:
     *
     * 1.  **Public Class Fields & Other Properties:** Any key in the `config` object that is NOT
     *     defined in the class's `static config` hierarchy is considered a public field or a
     *     dynamic property. These are assigned directly to the instance (`this.myField = value`)
     *     at the very beginning. This is crucial so that subsequent config hooks (like `afterSet*`)
     *     can access their latest values.
     *
     * 2.  **Reactive Configs:** A property is considered reactive if it is defined with a trailing
     *     underscore (e.g., `myValue_`) in the `static config` of **any class in the inheritance
     *     chain**. Subclasses can provide new default values for these configs without the
     *     underscore, and they will still be reactive. Their values are applied via generated
     *     setters, triggering `beforeSet*` and `afterSet*` hooks, and they are wrapped in a
     *     `Neo.core.Config` instance to enable subscription-based reactivity.
     *
     * 3.  **Non-Reactive Configs:** Properties defined in `static config` without a trailing
     *     underscore in their entire inheritance chain. Their default values are applied directly
     *     to the class **prototype**, making them shared across all instances and allowing for
     *     run-time modifications (prototypal inheritance). When a new value is passed to this
     *     method, it creates an instance-specific property that shadows the prototype value.
     *
     * This method also initializes the observable mixin (if applicable) and schedules asynchronous
     * logic like `initAsync()` (which handles remote method access) to run after the synchronous
     * construction chain is complete.
     *
     * @param {Object} config={} The initial configuration object for the instance.
     */
    construct(config={}) {
        let me = this;

        Object.defineProperties(me, {
            [configSymbol]: {
                configurable: true,
                enumerable  : false,
                value       : {},
                writable    : true
            },
            [isInstance]: {
                enumerable: false,
                value     : true
            }
        });

        me.id = config.id || _IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].getId(this.getIdKey());
        delete config.id;

        // Assign class field values prior to configs
        config = me.setFields(config);

        me.initConfig(config);

        Object.defineProperty(me, 'configsApplied', {
            enumerable: false,
            value     : true
        });

        me.applyDelayable();

        /*
         * We do not want to force devs to check for the `isDestroyed` flag in every possible class extension.
         * So, we are intercepting the top-most `destroy()` call to check for the flag there.
         * Rationale: `destroy()` must only get called once.
         */
        (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_0__.intercept)(me, 'destroy', me.isDestroyedCheck, me);

        // Triggers async logic after the construction chain is done.
        Promise.resolve().then(async () => {
            await me.initAsync();
            me.isReady = true
        })
    }

    /**
     * Triggered after the id config got changed.
     * You can dynamically change instance ids if needed. They need to stay unique at any given point.
     * Use case: e.g. component based lists, where you want to re-use item instances.
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetId(value, oldValue) {
        let me         = this,
            hasManager = Base.instanceManagerAvailable === true;

        if (oldValue) {
            if (hasManager) {
                Neo.manager.Instance.unregister(oldValue)
            } else if (Neo.idMap) {
                delete Neo.idMap[oldValue]
            }
        }

        if (value) {
            if (hasManager) {
                Neo.manager.Instance.register(me)
            } else {
                Neo.idMap ??= {};
                Neo.idMap[value] = me
            }
        }
    }

    /**
     * Adjusts all methods inside static delayable
     */
    applyDelayable() {
        let me            = this,
            ctorDelayable = me.constructor.delayable,
            delayable     = me.delayable ? Neo.merge({}, me.delayable, ctorDelayable) : ctorDelayable;

        Object.entries(delayable).forEach(([key, value]) => {
            if (value) {
                let map = {
                    buffer()   {me[key] = new _util_Function_mjs__WEBPACK_IMPORTED_MODULE_0__.buffer(me[key],   me, value.timer)},
                    debounce() {me[key] = new _util_Function_mjs__WEBPACK_IMPORTED_MODULE_0__.debounce(me[key], me, value.timer)},
                    throttle() {me[key] = new _util_Function_mjs__WEBPACK_IMPORTED_MODULE_0__.throttle(me[key], me, value.timer)}
                };

                map[value.type]?.()
            }
        })
    }

    /**
     * This static method is called by `Neo.setupClass()` during the class creation process.
     * It allows for modifying a class's default prototype-based configs from outside the
     * class hierarchy, which is a powerful way to avoid boilerplate code.
     *
     * It looks for a matching entry in the global `Neo.overwrites` object based on the
     * class's `className`. If found, it merges the properties from the overwrite object
     * into the class's static `config`. This provides a powerful mechanism for theming
     * or applying application-wide customizations to framework or library classes without
     * needing to extend them.
     *
     * @example
     * // Imagine you have hundreds of buttons in your app, and you want all of them
     * // to have `labelPosition: 'top'` instead of the default `'left'`.
     * // Instead of configuring each instance, you can define an overwrite.
     *
     * // inside an Overwrites.mjs file loaded by your app:
     * Neo.overwrites = {
     *     Neo: {
     *         button: {
     *             Base: {
     *                 labelPosition: 'top'
     *             }
     *         }
     *     }
     * };
     *
     * // Now, every `Neo.button.Base` (and any class that extends it) will have this
     * // new default value on its prototype.
     *
     * @param {Object} cfg The static `config` object of the class being processed.
     * @protected
     * @static
     */
    static applyOverwrites(cfg) {
        let overwrites = Neo.ns(cfg.className, false, Neo.overwrites),
            cls, item;

        if (overwrites) {
            // Apply all methods
            for (item in overwrites) {
                if (Neo.isFunction(overwrites[item])) {
                    // Already existing ones
                    cls = this.prototype;

                    if (cls[item]) {
                        // Add to overwrittenMethods
                        cls.constructor.overwrittenMethods[item] = cls[item]
                    }
                }
            }

            // Apply configs to prototype
            Object.assign(cfg, overwrites)
        }
    }

    /**
     * Convenience method for beforeSet functions which test if a given value is inside a static array
     * @param {String|Number} value
     * @param {String|Number} oldValue
     * @param {String} name config name
     * @param {Array|String} [staticName=name + 's'] name of the static config array
     * @returns {String|Number} value or oldValue
     */
    beforeSetEnumValue(value, oldValue, name, staticName = name + 's') {
        let values = Array.isArray(staticName) ? staticName : this.getStaticConfig(staticName);

        if (!values.includes(value)) {
            console.error(`Supported values for ${name} are:`, ...values, this);
            return oldValue
        }

        return value
    }

    /**
     * Triggered before the remote config gets changed
     * @param {Object|null} value
     * @param {Object|null} oldValue
     * @returns {Object|null}
     * @protected
     */
    beforeSetRemote(value, oldValue) {
        let me = this;

        // Only allow remote access for singletons or main thread addons
        if (value && !me.singleton && !me.isMainThreadAddon) {
            throw new Error('Remote method access is only functional for Singleton classes ' + me.className)
        }

        return value
    }

    /**
     * @param {String} fn               The name of a function to find in the passed scope object.
     * @param {Object} originName       The name of the method inside the originScope.
     * @param {Object} scope            The scope to find the function in if it is specified as a string.
     * @param {Object} originScope=this The scope where the function is located.
     */
    bindCallback(fn, originName, scope=this, originScope=this) {
        if (fn && Neo.isString(fn)) {
            const handler = (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_0__.resolveCallback)(fn, scope);
            originScope[originName] = handler.fn.bind(handler.scope)
        }
    }

    /**
     * From within an overwrite, a method can call a parent method, by using callOverwritten.
     *
     * @example
     *    afterSetHeight(value, oldValue) {
     *        // do the standard
     *        this.callOverwritten(...arguments);
     *        // do you own stuff
     *    }
     *
     * We create an error to get the caller.name and then run that method on the constructor.
     * This is based on the following error structure, e.g. afterSetHeight.
     *
     *     Error
     *         at Base.callOverwritten (Base.mjs:176:21)
     *         at Base.afterSetHeight (Overrides.mjs:19:26)
     *
     * @param args
     */
    callOverwritten(...args) {
        let stack      = new Error().stack,
            methodName = stack.match(Base.methodNameRegex)[1];

        this.__proto__.constructor.overwrittenMethods[methodName].call(this, ...args)
    }

    /**
     * Unregisters this instance from Neo.manager.Instance
     * and removes all object entries from this instance
     */
    destroy() {
        let me = this;

        me.isDestroying = true;

        me.#timeoutIds.forEach(id => {
            clearTimeout(id)
        });

        me.#configSubscriptionCleanups.forEach(cleanup => {
            cleanup()
        });

        if (Base.instanceManagerAvailable === true) {
            Neo.manager.Instance.unregister(me)
        } else if (Neo.idMap) {
            delete Neo.idMap[me.id]
        }

        Object.keys(me).forEach(key => {
            if (Object.getOwnPropertyDescriptor(me, key).writable) {
                // We must not delete the custom destroy() interceptor
                if (key !== 'destroy' && key !== '_id') {
                    delete me[key]
                }
            }
        });

        // We do want to prevent delayed event calls after an observable instance got destroyed.
        if (Neo.isFunction(me.fire)) {
            me.fire = Neo.emptyFn
        }

        me.isDestroyed = true
    }

    /**
     * A public method to access the underlying Config controller.
     * This enables advanced interactions like subscriptions.
     * @param {String} key The name of the config property (e.g., 'items').
     * @returns {Config|undefined} The Config instance, or undefined if not found.
     */
    getConfig(key) {
        let me = this;

        if (!me.#configs[key] && me.isConfig(key)) {
            me.#configs[key] = new _Config_mjs__WEBPACK_IMPORTED_MODULE_3__["default"](me.constructor.configDescriptors?.[key])
        }

        return me.#configs[key]
    }

    /**
     * Used inside createId() as the default value passed to the IdGenerator.
     * Override this method as needed.
     * @returns {String}
     */
    getIdKey() {
        return this.ntype
    }

    /**
     * Returns the value of a static config key or the staticConfig object itself in case no value is set
     * @param {String} key The key of a staticConfig defined inside static getStaticConfig
     * @returns {*}
     */
    getStaticConfig(key) {
        return this.constructor[key]
    }

    /**
     * Check if a given ntype exists inside the proto chain, including the top level class
     * @param {String} ntype
     * @returns {Boolean}
     */
    hasNtype(ntype) {
        return this.constructor.ntypeChain.includes(ntype)
    }

    /**
     * Gets triggered after onConstructed() is done
     */
    init() {}

    /**
     * You can use this method in subclasses to perform asynchronous initialization logic.
     * Make sure to use the parent call `await super.initAsync()` at the beginning of their implementations,
     * or the registration of remote methods will get delayed.
     *
     * A common use case is requiring conditional or optional dynamic imports or fetching initial data.
     *
     * Once the promise returned by this method is fulfilled, the `isReady` config will be set to `true`.
     * @returns {Promise<void>} A promise that resolves when the asynchronous initialization is complete.
     */
    async initAsync() {
        this.remote && this.initRemote()
    }

    /**
     * Applies all class configs to this instance
     * @param {Object} config
     * @param {Boolean} [preventOriginalConfig] True prevents the instance from getting an originalConfig property
     * @protected
     */
    initConfig(config, preventOriginalConfig) {
        let me = this;

        me.isConfiguring = true;
        Object.assign(me[configSymbol], me.mergeConfig(config, preventOriginalConfig));
        delete me[configSymbol].id;
        me.processConfigs();
        me.isConfiguring = false
    }

    /**
     * Does get triggered with a delay to ensure that Neo.workerId & Neo.worker.Manager are defined
     * Remote method access via promises
     * @protected
     */
    initRemote() {
        let {className, remote} = this,
            {currentWorker}     = Neo;

        if (!Neo.config.unitTestMode) {
            if (Neo.workerId !== 'main' && currentWorker.isSharedWorker && !currentWorker.isConnected) {
                currentWorker.on('connected', () => {
                    Base.sendRemotes(className, remote)
                }, this, {once: true})
            } else {
                Base.sendRemotes(className, remote)
            }
        }
    }

    /**
     * Intercepts destroy() calls to ensure they will only get called once
     * @returns {Boolean}
     */
    isDestroyedCheck() {
        return !this.isDestroyed
    }

    /**
     * @param {String} key
     * @returns {Boolean}
     */
    isConfig(key) {
        let me = this;
        // If a `core.Config` controller is already created, return true (fastest possible check).
        // If not, a config is considered "reactive" if it has a generated property setter
        // AND it is present as a defined config in the merged static config hierarchy.
        // Neo.setupClass() removes the underscore from the static config keys.
        return me.#configs[key] || (Neo.hasPropertySetter(me, key) && (key in me.constructor.config))
    }

    /**
     * Override this method to change the order configs are applied to this instance.
     * @param {Object} config
     * @param {Boolean} [preventOriginalConfig] True prevents the instance from getting an originalConfig property
     * @returns {Object} config
     * @protected
     */
    mergeConfig(config, preventOriginalConfig) {
        let me   = this,
            ctor = me.constructor,
            configDescriptors, staticConfig;

        if (!ctor.config) {
            throw new Error('Neo.applyClassConfig has not been run on ' + me.className)
        }

        if (!preventOriginalConfig) {
            me.originalConfig = Neo.clone(config, true, true)
        }

        configDescriptors = ctor.configDescriptors;
        staticConfig      = ctor.config;

        if (configDescriptors) {
            Object.entries(config).forEach(([key, instanceValue]) => {
                const descriptor = configDescriptors[key];

                if (descriptor?.merge) {
                    config[key] = Neo.mergeConfig(staticConfig[key], instanceValue, descriptor.merge)
                }
            })
        }

        return {...staticConfig, ...config}
    }

    /**
     * Subscribes *this* instance (the subscriber) to changes of a specific config property on another instance (the publisher).
     * Ensures automatic cleanup when *this* instance (the subscriber) is destroyed.
     *
     * @param {String|Neo.core.Base} publisher  - The ID of the publisher instance or the instance reference itself.
     * @param {String}               configName - The name of the config property on the publisher to subscribe to (e.g., 'myConfig').
     * @param {Function}             fn         - The callback function to execute when the config changes.
     * @returns {Function} A cleanup function to manually unsubscribe if needed before this instance's destruction.
     *
     * @example
     * // Subscribing to a config on another instance
     * this.observeConfig(someOtherInstance, 'myConfig', (newValue, oldValue) => {
     *     console.log('myConfig changed:', newValue);
     * });
     *
     * // Discouraged: Self-observation. Use afterSet<ConfigName>() hooks instead.
     * this.observeConfig(this, 'myOwnConfig', (newValue, oldValue) => {
     *     console.log('myOwnConfig changed:', newValue);
     * });
     */
    observeConfig(publisher, configName, fn) {
        let publisherInstance = publisher;

        if (Neo.isString(publisher)) {
            publisherInstance = Neo.get(publisher);
            if (!publisherInstance) {
                console.warn(`Publisher instance with ID '${publisher}' not found. Cannot subscribe.`);
                return Neo.emptyFn
            }
        }

        if (!(publisherInstance instanceof Neo.core.Base)) {
            console.warn(`Invalid publisher provided. Must be a Neo.core.Base instance or its ID.`);
            return Neo.emptyFn
        }

        const configController = publisherInstance.getConfig(configName);

        if (!configController) {
            console.warn(`Config '${configName}' not found on publisher instance ${publisherInstance.id}. Cannot subscribe.`);
            return Neo.emptyFn
        }

        const cleanup = configController.subscribe({id: this.id, fn});

        this.#configSubscriptionCleanups.push(cleanup);

        return cleanup
    }

    /**
     *
     */
    onAfterConstructed() {
        let me = this;

        me.isConstructed = true;

        // We can only fire the event in case the Observable mixin is included.
        me.getStaticConfig('observable') && me.fire('constructed', me)
    }

    /**
     * Gets triggered after all constructors are done
     */
    onConstructed() {}

    /**
     * Placeholder method for intercepting remote calls.
     * Subclasses can override this method to implement custom interception logic.
     * @param {Object} msg The remote message object.
     */
    onInterceptRemotes(msg) {
        // No-op in base class
    }

    /**
     * Helper method to replace string-based values containing "@config:" with the matching config value
     * of this instance.
     * @param {Object|Object[]} items
     */
    parseItemConfigs(items) {
        let me = this,
            ns, nsArray, nsKey, symbolNs;

        if (items) {
            if (!Array.isArray(items)) {
                items = [items]
            }

            items.forEach(item => {
                item && Object.entries(item).forEach(([key, value]) => {
                    if (Array.isArray(value)) {
                        me.parseItemConfigs(value);
                    } else if (typeof value === 'string' && value.startsWith('@config:')) {
                        nsArray = value.substring(8).trim().split('.');
                        nsKey   = nsArray.pop();
                        ns      = Neo.ns(nsArray, false, me);

                        if (ns[nsKey] === undefined) {
                            console.error('The used @config does not exist:', nsKey, nsArray.join('.'))
                        } else {
                            symbolNs = Neo.ns(nsArray, false, me[configSymbol]);

                            // The config might not be processed yet, especially for configs
                            // not ending with an underscore, so we need to check the configSymbol first.
                            if (symbolNs && Object.hasOwn(symbolNs, nsKey)) {
                                item[key] = symbolNs[nsKey]
                            } else {
                                item[key] = ns[nsKey]
                            }
                        }
                    }
                })
            })
        }
    }

    /**
     * When using set(), configs without a trailing underscore can already be assigned,
     * so the hasOwnProperty() check will return true
     * @param {Boolean} [forceAssign=false]
     * @protected
     */
    processConfigs(forceAssign=false) {
        let me   = this,
            keys = Object.keys(me[configSymbol]);

        me[forceAssignConfigs] = forceAssign;

        // We do not want to iterate over the keys, since 1 config can remove more than 1 key (beforeSetX, afterSetX)
        if (keys.length > 0) {
            // The hasOwnProperty check is intended for configs without a trailing underscore
            // => they could already have been assigned inside an afterSet-method
            if (forceAssign || !me.hasOwnProperty(keys[0])) {
                me[keys[0]] = me[configSymbol][keys[0]]
            }

            // there is a delete-call inside the config getter as well (Neo.mjs => autoGenerateGetSet())
            // we need to keep this one for configs, which do not use getters (no trailing underscore)
            delete me[configSymbol][keys[0]];

            me.processConfigs(forceAssign)
        }
    }

    /**
     * @param {String} className
     * @param {Object} remote
     * @protected
     */
    static sendRemotes(className, remote) {
        let origin;

        Object.entries(remote).forEach(([worker, methods]) => {
            if (Neo.workerId !== worker) {
                origin = Neo.workerId === 'main' ? Neo.worker.Manager : Neo.currentWorker;

                origin.sendMessage(worker, {
                    action: 'registerRemote',
                    className,
                    methods
                })
            }
        })
    }

    /**
     * set() accepts the following input as keys:
     * 1. Non-reactive configs
     * 2. Reactive configs
     * 3. Class fields defined via value
     * 4. Class fields defined via get() & set()
     * 5. "Anything else" will get directly get assigned to the instance
     *
     * The logic resolves circular dependencies as good as possible and ensures that config related hooks:
     * - beforeGet<Config>
     * - beforeSet<Config>
     * - afterSet<Config>
     * can access all new values from the batch operation.
     * @param {Object} values={}
     */
    set(values={}) {
        let me                = this,
            classFieldsViaSet = {};

        // Prevent Effects from running for bulk changes
        _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].pause();

        try {
            values = me.setFields(values);

            // If the initial config processing is still running,
            // finish this one first before dropping new values into the configSymbol.
            // See: https://github.com/neomjs/neo/issues/2201
            if (me[forceAssignConfigs] !== true && Object.keys(me[configSymbol]).length > 0) {
                me.processConfigs()
            }

            // Store class fields which are defined via get() & set() and ensure they won't get added to the config symbol.
            Object.entries(values).forEach(([key, value]) => {
                if (!me.isConfig(key)) {
                    classFieldsViaSet[key] = value;
                    delete values[key]
                }
            })

            // Add reactive configs to the configSymbol
            Object.assign(me[configSymbol], values);

            // Process class fields which are defined via get() & set() => now they can access the latest values
            // for reactive and non-reactive configs, as well as class fields defined with values.
            Object.entries(classFieldsViaSet).forEach(([key, value]) => {
                me[key] = value
            })

            // Process reactive configs
            me.processConfigs(true);
        } finally {
            // Trigger the skipped Effect, if needed
            _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].resume()
        }
    }

    /**
     * We want to assign class fields first and remove them from the config object,
     * so that afterSet(), beforeGet() and beforeSet() methods can get the new values right away
     * @param {Object} config
     * @returns {Object}
     * @protected
     */
    setFields(config) {
        let me = this;

        Object.entries(config).forEach(([key, value]) => {
            if (!me.isConfig(key) && !Neo.hasPropertySetter(me, key)) {
                me[key] = value;
                delete config[key]
            }
        });

        return config
    }

    /**
     * Sets the value of a static config by a given key
     * @param {String} key The key of a staticConfig defined inside static getStaticConfig
     * @param {*} value
     * @returns {Boolean} true in case the config exists and got changed
     */
    setStaticConfig(key, value) {
        let staticConfig = this.constructor.staticConfig;

        if (staticConfig.hasOwnProperty(key)) {
            staticConfig[key] = value;
            return true
        }

        return false
    }

    /**
     * Stores timeoutIds internally, so that destroy() can clear them if needed
     * @param {Number} time in milliseconds
     * @returns {Promise<any>}
     */
    timeout(time) {
        return new Promise(resolve => {
            let timeoutIds = this.#timeoutIds,
                timeoutId  = setTimeout(() => {timeoutIds.splice(timeoutIds.indexOf(timeoutId), 1); resolve()}, time);

            timeoutIds.push(timeoutId)
        })
    }

    /**
     * <p>Enhancing the toString() method, e.g.</p>
     * `Neo.create('Neo.button.Base').toString() => "[object Neo.button.Base (neo-button-1)]"`
     * @returns {String}
     */
    get [Symbol.toStringTag]() {
        return this.className
    }

    /**
     * <p>Enhancing the instanceof method. Without this change:</p>
     * `Neo.collection.Base.prototype instanceof Neo.core.Base => true`
     * <p>With this change:</p>
     * `Neo.collection.Base.prototype instanceof Neo.core.Base => false`<br>
     * `Neo.create(Neo.collection.Base) instanceof Neo.core.Base => true`
     * @returns {Boolean}
     */
    static [Symbol.hasInstance](instance) {
        if (!instance) {
            return false
        }

        return instance[isInstance] === true ? super[Symbol.hasInstance](instance) : false
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Base));


/***/ }),

/***/ "./src/core/Compare.mjs":
/*!******************************!*\
  !*** ./src/core/Compare.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @class Neo.core.Compare
 */
class Compare {
    /**
     * Storing the comparison method names by data type
     * @member {Object} map
     */
    static map = {
        Array      : 'compareArrays',
        Date       : 'compareDates',
        Function   : 'compareFunctions',
        Map        : 'compareMaps',
        NeoInstance: 'compareNeoInstances',
        Object     : 'compareObjects',
        RegExp     : 'compareRegExps',
        Set        : 'compareSets'
    }

    /**
     * @param {Array} item1
     * @param {Array} item2
     * @returns {Boolean}
     */
    static compareArrays(item1, item2) {
        if (item1.length !== item2.length) {
            return false
        }

        for (const [i, v] of item1.entries()) {
            if (!Compare.isEqual(v, item2[i])) {
                return false
            }
        }

        return true
    }

    /**
     * @param {Date} item1
     * @param {Date} item2
     * @returns {Boolean}
     */
    static compareDates(item1, item2) {
        return item1.valueOf() === item2.valueOf()
    }

    /**
     * @param {Function} item1
     * @param {Function} item2
     * @returns {Boolean}
     */
    static compareFunctions(item1, item2) {
        if (item1.name !== item2.name) {
            return false
        }

        return item1.toString() === item2.toString()
    }

    /**
     * @param {Map} item1
     * @param {Map} item2
     * @returns {Boolean}
     */
    static compareMaps(item1, item2) {
        if (item1.size !== item2.size) {
            return false
        }

        let val2;

        for (const [key, val] of item1) {
            val2 = item2.get(key);

            if (val2 !== val || val2 === undefined && !item2.has(key)) {
                return false
            }
        }

        return true
    }

    /**
     * @param {Neo.core.Base} item1
     * @param {Neo.core.Base} item2
     * @returns {Boolean}
     */
    static compareNeoInstances(item1, item2) {
        return item1.id === item2.id
    }

    /**
     * @param {Object} item1
     * @param {Object} item2
     * @returns {Boolean}
     */
    static compareObjects(item1, item2) {
        if (Object.keys(item1).length !== Object.keys(item2).length) {
            return false
        }

        for (let key in item1) {
            if (!Compare.isEqual(item1[key], item2[key])) {
                return false
            }
        }

        return true
    }

    /**
     * @param {RegExp} item1
     * @param {RegExp} item2
     * @returns {Boolean}
     */
    static compareRegExps(item1, item2) {
        return item1.toString() === item2.toString()
    }

    /**
     * @param {Set} item1
     * @param {Set} item2
     * @returns {Boolean}
     */
    static compareSets(item1, item2) {
        if (item1.size !== item2.size) {
            return false
        }

        for (let key of item1) {
            if (!item2.has(key)) {
                return false
            }
        }

        return true
    }

    /**
     * @param {*} item1
     * @param {*} item2
     * @returns {Boolean}
     */
    static isEqual(item1, item2) {
        if (item1 === item2) {
            return true
        }

        let type1 = Neo.typeOf(item1),
            type2 = Neo.typeOf(item2);

        if (type1 !== type2) {
            return false
        }

        if (Compare.map[type1]) {
            return Compare[Compare.map[type1]](item1, item2)
        }

        // all other types
        return item1 === item2
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.gatekeep(Compare, 'Neo.core.Compare', () => {
    // alias
    Neo.isEqual = Compare.isEqual
}));


/***/ }),

/***/ "./src/core/Config.mjs":
/*!*****************************!*\
  !*** ./src/core/Config.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EffectManager.mjs */ "./src/core/EffectManager.mjs");
/* harmony import */ var _ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");



/**
 * Represents an observable container for a config property.
 * This class manages the value of a config, its subscribers, and custom behaviors
 * like merge strategies and equality checks defined via a descriptor object.
 *
 * The primary purpose of this class is to enable fine-grained reactivity and
 * decoupled cross-instance state sharing within the Neo.mjs framework.
 * @class Neo.core.Config
 * @private
 * @internal
 */
class Config {
    /**
     * Stores all subscriptions for this Config instance.
     * The data structure is a Map where:
     * - The key is the ID of the subscription owner (e.g., a component's `id`).
     * - The value is another Map (the subscriberMap).
     *
     * The nested subscriberMap is structured as:
     * - The key is the callback function (`fn`).
     * - The value is a Set of scopes (`scopeSet`).
     *
     * This nested structure `Map<string, Map<function, Set<scope>>>` is intentionally chosen
     * to robustly handle the edge case where the same function is subscribed multiple times
     * with different scopes, all under the same owner ID. It ensures that each
     * `fn`-`scope` combination is unique and that cleanup is precise.
     * @member {Object} #subscribers={}
     * @private
     */
    #subscribers = {}
    /**
     * The internal value of the config property.
     * @member {*} #value
     * @private
     */
    #value
    /**
     * The cloning strategy to use when setting a new value.
     * Supported values: 'deep', 'shallow', 'none'.
     * @member {String} clone='deep'
     */

    /**
     * The cloning strategy to use when getting a value.
     * Supported values: 'deep', 'shallow', 'none'.
     * @member {String} cloneOnGet=null
     */

    /**
     * The function used to compare new and old values for equality.
     * Defaults to `Neo.isEqual`. Can be overridden via a descriptor.
     * @member {Function} isEqual=Neo.isEqual
     */

    /**
     * The strategy to use when merging new values into this config.
     * Defaults to 'replace'. Can be overridden via a descriptor merge property.
     * @member {Function|String} mergeStrategy='replace'
     */

    /**
     * Creates an instance of Config.
     * @param {any|Object} configObject - The initial value for the config.
     */
    constructor(configObject) {
        if (Neo.isObject(configObject) && configObject[_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_1__.isDescriptor] === true) {
            this.initDescriptor(configObject)
        } else {
            this.#value = configObject
        }
    }

    /**
     * Gets the current value of the config property.
     * @returns {any} The current value.
     */
    get() {
        // Registers this Config instance as a dependency with the currently active Effect,
        // enabling automatic re-execution when this Config's value changes.
        _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].addDependency(this);
        return this.#value
    }

    /**
     * Initializes the `Config` instance using a descriptor object.
     * Extracts `clone`, `mergeStrategy` and `isEqual` from the descriptor.
     * The internal `#value` is NOT set by this method.
     * @param {Object}    descriptor                      - The descriptor object for the config.
     * @param {string}   [descriptor.clone='deep']        - The clone strategy for set.
     * @param {string}   [descriptor.cloneOnGet]          - The clone strategy for get. Defaults to 'shallow' if clone is 'deep' or 'shallow', and 'none' if clone is 'none'.
     * @param {Function} [descriptor.isEqual=Neo.isEqual] - The equality comparison function.
     * @param {string}   [descriptor.merge='deep']        - The merge strategy.
     * @param {any}       descriptor.value                - The default value for the config (not set by this method).
     */
    initDescriptor({clone, cloneOnGet, isEqual, merge}) {
        let me = this;

        if (clone && clone !== me.clone) {
            Object.defineProperty(me, 'clone', {
                configurable: true, enumerable: true, value: clone, writable: true
            })
        }

        if (cloneOnGet && cloneOnGet !== me.cloneOnGet) {
            Object.defineProperty(me, 'cloneOnGet', {
                configurable: true, enumerable: true, value: cloneOnGet, writable: true
            })
        }

        if (isEqual && isEqual !== me.isEqual) {
            Object.defineProperty(me, 'isEqual', {
                configurable: true, enumerable: true, value: isEqual, writable: true
            })
        }

        if (merge && merge !== me.mergeStrategy) {
            Object.defineProperty(me, 'mergeStrategy', {
                configurable: true, enumerable: true, value: merge, writable: true
            })
        }
    }

    /**
     * Notifies all subscribed callbacks about a change in the config's value.
     * It iterates through the nested subscriber structure to ensure each callback
     * is executed with its intended scope.
     * @param {any} newValue - The new value of the config.
     * @param {any} oldValue - The old value of the config.
     */
    notify(newValue, oldValue) {
        for (const id in this.#subscribers) {
            if (this.#subscribers.hasOwnProperty(id)) {
                const subscriberMap = this.#subscribers[id];
                for (const [fn, scopeSet] of subscriberMap) {
                    for (const scope of scopeSet) {
                        fn.call(scope || null, newValue, oldValue)
                    }
                }
            }
        }
    }

    /**
     * Sets a new value for the config property.
     * This method performs an equality check using `this.isEqual` before updating the value.
     * If the value has changed, it updates `#value` and notifies all subscribers.
     * @param {any} newValue - The new value to set.
     * @returns {Boolean} True if the value changed, false otherwise.
     */
    set(newValue) {
        if (newValue === undefined) return false; // Preserve original behavior for undefined

        const
            me       = this,
            oldValue = me.#value;

        // The setter automatically uses the configured equality check
        if (!me.isEqual(newValue, oldValue)) {
            me.#value = newValue;
            me.notify(newValue, oldValue);
            return true
        }

        return false
    }

    /**
     * Sets the internal value of the config property directly, without performing
     * an equality check or notifying subscribers.
     * This method is intended for internal framework use where direct assignment
     * is necessary (e.g., during initial setup or specific internal optimizations).
     * @param {any} newValue - The new value to set directly.
     */
    setRaw(newValue) {
        this.#value = newValue
    }

    /**
     * Subscribes a callback function to changes in this config's value.
     * The callback will be invoked with `(newValue, oldValue)` whenever the config changes.
     * @param {Object}   options        - An object containing the subscription details.
     * @param {String}   options.id     - The ID of the subscription owner (e.g., a Neo.core.Base instance's id).
     * @param {Function} options.fn     - The callback function.
     * @param {Object}  [options.scope] - The scope to execute the callback in.
     * @returns {Function} A cleanup function to unsubscribe the callback.
     */
    subscribe({id, fn, scope}) {
        if (typeof id !== 'string' || id.length === 0 || typeof fn !== 'function') {
            throw new Error([
                'Config.subscribe: options must be an object with a non-empty string `id` ',
                '(the subscription owner\'s id), and a callback function `fn`.'
            ].join(''))
        }

        const me = this;

        // Get or create the top-level Map for the subscription owner.
        if (!me.#subscribers[id]) {
            me.#subscribers[id] = new Map()
        }

        const subscriberMap = me.#subscribers[id];

        // Get or create the Set of scopes for the specific callback function.
        if (!subscriberMap.has(fn)) {
            subscriberMap.set(fn, new Set())
        }

        const scopeSet = subscriberMap.get(fn);
        scopeSet.add(scope);

        // The returned cleanup function is precise. It removes only the specific
        // scope for the function, and cleans up the parent data structures
        // (the Set and the Maps) only if they become empty.
        return () => {
            const currentSubscriberMap = me.#subscribers[id];
            if (currentSubscriberMap) {
                const currentScopeSet = currentSubscriberMap.get(fn);
                if (currentScopeSet) {
                    currentScopeSet.delete(scope);
                    if (currentScopeSet.size === 0) {
                        currentSubscriberMap.delete(fn);
                        if (currentSubscriberMap.size === 0) {
                            delete me.#subscribers[id]
                        }
                    }
                }
            }
        }
    }
}

Object.defineProperties(Config.prototype, {
    clone        : {configurable: true, enumerable: false, value: 'deep',      writable: false},
    cloneOnGet   : {configurable: true, enumerable: false, value: null,        writable: false},
    isEqual      : {configurable: true, enumerable: false, value: Neo.isEqual, writable: false},
    mergeStrategy: {configurable: true, enumerable: false, value: 'replace',   writable: false}
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.gatekeep(Config, 'Neo.core.Config'));


/***/ }),

/***/ "./src/core/ConfigSymbols.mjs":
/*!************************************!*\
  !*** ./src/core/ConfigSymbols.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isDescriptor: () => (/* binding */ isDescriptor)
/* harmony export */ });
const isDescriptor = Symbol.for('Neo.Config.isDescriptor');


/***/ }),

/***/ "./src/core/EffectManager.mjs":
/*!************************************!*\
  !*** ./src/core/EffectManager.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * A singleton manager to track the currently running effect and control global effect execution.
 * It provides a centralized mechanism for pausing, resuming, and batching effect runs.
 * @class Neo.core.EffectManager
 * @singleton
 */
const EffectManager = {
    /**
     * A stack to keep track of the currently active effect and its predecessors.
     * @member {Neo.core.Effect[]} effectStack=[]
     * @protected
     */
    effectStack: [],
    /**
     * A flag to temporarily disable dependency tracking for the active effect.
     * This is used internally to prevent effects from depending on their own state, like `isRunning`.
     * @member {Boolean} isTrackingPaused=false
     * @protected
     */
    isTrackingPaused: false,
    /**
     * A counter to manage nested calls to pause() and resume(). Effect execution is
     * paused or batched while this counter is greater than 0.
     * @member {Number} pauseCounter=0
     * @protected
     */
    pauseCounter: 0,
    /**
     * A Set to store unique effects that are triggered while the manager is paused.
     * These effects will be run when resume() is called and the pauseCounter returns to 0.
     * @member {Set<Neo.core.Effect>} queuedEffects=new Set()
     * @protected
     */
    queuedEffects: new Set(),

    /**
     * Adds a `Neo.core.Config` instance as a dependency for the currently active effect,
     * unless dependency tracking is explicitly paused.
     * @param {Neo.core.Config} config The config instance to add as a dependency.
     */
    addDependency(config) {
        if (!this.isTrackingPaused) {
            this.getActiveEffect()?.addDependency(config)
        }
    },

    /**
     * Returns the effect currently at the top of the stack (i.e., the one currently running).
     * @returns {Neo.core.Effect|null}
     */
    getActiveEffect() {
        return this.effectStack[this.effectStack.length - 1]
    },

    /**
     * Checks if effect execution is currently paused or batched.
     * @returns {Boolean} True if the pauseCounter is greater than 0.
     */
    isPaused() {
        return this.pauseCounter > 0
    },

    /**
     * Pauses effect execution and begins batching.
     * Each call to pause() increments a counter, allowing for nested control.
     */
    pause() {
        this.pauseCounter++
    },

    /**
     * Disables dependency tracking for the currently active effect.
     * @protected
     */
    pauseTracking() {
        this.isTrackingPaused = true
    },

    /**
     * Pops the current effect from the stack.
     * @returns {Neo.core.Effect|null}
     */
    pop() {
        return this.effectStack.pop()
    },

    /**
     * Pushes an effect onto the stack.
     * @param {Neo.core.Effect} effect The effect to push.
     */
    push(effect) {
        this.effectStack.push(effect)
    },

    /**
     * Queues a unique effect to be run later.
     * @param {Neo.core.Effect} effect The effect to queue.
     * @protected
     */
    queue(effect) {
        this.queuedEffects.add(effect)
    },

    /**
     * Resumes effect execution. If the pause counter returns to zero and effects
     * have been queued, they will all be executed synchronously.
     */
    resume() {
        let me = this;

        if (me.pauseCounter > 0) {
            me.pauseCounter--;

            if (me.pauseCounter === 0 && me.queuedEffects.size > 0) {
                const effectsToRun = [...me.queuedEffects];
                me.queuedEffects.clear();
                effectsToRun.forEach(effect => effect.run())
            }
        }
    },

    /**
     * Re-enables dependency tracking for the currently active effect.
     * @protected
     */
    resumeTracking() {
        this.isTrackingPaused = false
    }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.gatekeep(EffectManager, 'Neo.core.EffectManager', () => {
    /**
     * Wraps a function in a batch operation, ensuring that all effects triggered
     * within it are run only once after the function completes.
     * @function Neo.batch
     * @param {Function} fn The function to execute.
     */
    Neo.batch = function(fn) {
        EffectManager.pause();
        try {
            fn()
        } finally {
            // The public resume() method handles running queued effects.
            EffectManager.resume()
        }
    }
}));


/***/ }),

/***/ "./src/core/IdGenerator.mjs":
/*!**********************************!*\
  !*** ./src/core/IdGenerator.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Provides a singleton utility for generating unique IDs.
 * @namespace Neo.core.IdGenerator
 */
const IdGenerator = {
    /**
     * The default prefix for neo instance ids
     * @member {String} base='neo-'
     */
    base: 'neo-',
    /**
     * @member {Object} idCounter={}
     */
    idCounter: {},

    /**
     * @param name
     * @returns {string}
     */
    getId(name) {
        name = name || 'neo';

        let me      = this,
            counter = me.idCounter,
            count   = counter[name] || 0;

        counter[name] = ++count;

        return me.base + (name === 'neo' ? '' : name + '-') + count;
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.gatekeep(IdGenerator, 'Neo.core.IdGenerator', () => {
    Neo.getId = IdGenerator.getId.bind(IdGenerator);
}));


/***/ }),

/***/ "./src/core/Observable.mjs":
/*!*********************************!*\
  !*** ./src/core/Observable.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");
/* harmony import */ var _util_Function_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Function.mjs */ "./src/util/Function.mjs");





/**
 * A unique, non-enumerable key for the internal event map.
 * Using a Symbol prevents property name collisions on the consuming class instance,
 * providing a robust way to manage private state within a mixin.
 * @type {Symbol}
 */
const eventMapSymbol = Symbol('eventMap');

/**
 * @class Neo.core.Observable
 * @extends Neo.core.Base
 */
class Observable extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.core.Observable'
         * @protected
         */
        className: 'Neo.core.Observable',
        /**
         * @member {String} ntype='mixin-observable'
         * @protected
         */
        ntype: 'mixin-observable',
        /**
         * A declarative way to assign event listeners to an instance upon creation.
         * The framework processes this config and calls `on()` to populate the
         * internal event registry. This config should not be manipulated directly after
         * instantiation; use `on()` and `un()` instead.
         * @member {Object|null} listeners_
         * @example
         * listeners: {
         *     myEvent: 'onMyEvent',
         *     otherEvent: {
         *         fn: 'onOtherEvent',
         *         delay: 100,
         *         once: true
         *     },
         *     scope: this
         * }
         * @reactive
         */
        listeners_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_2__.isDescriptor]: true,
            merge         : 'deep',
            value         : {}
        }
    }

    /**
     * @member {Object} [eventMapSymbol]
     * @private
     */

    /**
     * @param {Object|String} name
     * @param {Object} [opts]
     * @param {Object} [scope]
     * @param {String} [eventId]
     * @param {Object} [data]
     * @param {Number|String} [order]
     * @returns {String|null} eventId null in case an object gets passed as the name (multiple ids)
     */
    addListener(name, opts, scope, eventId, data, order) {
        let me            = this,
            delay         = 0,
            eventIdObject = typeof eventId === 'object',
            nameObject    = typeof name    === 'object',
            once          = false,
            optsType      = typeof opts,
            listener, existing, eventConfig;

        /*
         * let us support the following format too:
         *
         * currentWorker.on('connected', () => {
         *     Base.sendRemotes(className, remote)
         * }, me, {once: true})
         */
        if (eventIdObject && optsType === 'function') {
            eventId.fn = opts;
            opts     = eventId;
            optsType = 'object';
            eventId  = null;
        }

        if (nameObject) {
            if (name.hasOwnProperty('delay')) {
                delay = name.delay;
                delete name.delay
            }

            if (name.hasOwnProperty('once')) {
                once = name.once;
                delete name.once
            }

            if (name.hasOwnProperty('order')) {
                order = name.order;
                delete name.order
            }

            if (name.hasOwnProperty('scope')) {
                scope = name.scope;
                delete name.scope
            }

            Object.entries(name).forEach(([key, value]) => {
                if (Neo.isObject(value)) {
                    me.addListener(key, {delay, once, order, scope, ...value})
                } else {
                    me.addListener(key, {delay, fn: value, once, order, scope})
                }
            })
        } else if (optsType === 'object') {
            delay    = delay   || opts.delay;
            eventId  = eventId || opts.eventId;
            listener = opts.fn;
            once     = once    || opts.once;
            order    = order   || opts.order;
            scope    = scope   || opts.scope
        } else if (optsType === 'function') {
            listener = opts
        } else if (optsType === 'string') {
            listener = opts // VC hook, can get parsed after onConstructed in case the view uses the parent VC
        } else {
            throw new Error('Invalid addListener call: ' + name)
        }

        if (!nameObject) {
            // LAZY INITIALIZATION: The key to a robust mixin.
            // This ensures the private internal listener store exists on the instance.
            // `eventMapSymbol` is the *actual* registry of handler arrays, and is
            // intentionally separate from the public `listeners_` config.
            me[eventMapSymbol] ??= {};

            eventConfig = {fn: listener, id: eventId || Neo.getId('event')};

            if (data)      {eventConfig.data   = data}
            if (delay > 0) {eventConfig.delay  = delay}
            if (once)      {eventConfig.once   = once}
            if (scope)     {eventConfig.scope  = scope}

            if ((existing = me[eventMapSymbol][name])) {
                existing.forEach(cfg => {
                    if (cfg.id === eventId || (cfg.fn === listener && cfg.scope === scope)) {
                        console.error('Duplicate event handler attached:', name, me)
                    }
                });

                if (typeof order === 'number') {
                    existing.splice(order, 0, eventConfig)
                } else if (order === 'before') {
                    existing.unshift(eventConfig)
                } else {
                    existing.push(eventConfig)
                }
            } else {
                me[eventMapSymbol][name] = [eventConfig] // Use the private eventMapSymbol registry
            }

            return eventConfig.id
        }

        return null
    }

    /**
     * This hook is the bridge between the declarative `listeners_` config and the
     * imperative `on()`/`un()` methods. It's called automatically by the framework
     * whenever the `listeners` config property is changed.
     * @param {Object} value The new listeners object
     * @param {Object} oldValue The old listeners object
     * @protected
     */
    afterSetListeners(value, oldValue) {
        // Unregister any listeners from the old config object
        if (oldValue && Object.keys(oldValue).length > 0) {
            this.un(oldValue)
        }
        // Register all listeners from the new config object
        if (value && Object.keys(value).length > 0) {
            this.on(value)
        }
    }

    /**
     * Call the passed function, or a function by *name* which exists in the passed scope's
     * or this component's ownership chain.
     * @param {Function|String} fn A function, or the name of a function to find in the passed scope object.
     * @param {Object} scope       The scope to find the function in if it is specified as a string.
     * @param {Array} args         Arguments to pass to the callback.
     */
    callback(fn, scope=this, args) {
        if (fn) {
            const handler = (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_3__.resolveCallback)(fn, scope);
            handler.fn.apply(handler.scope, args)
        }
    }

    /**
     * Internal helper method for events which use the delay option
     * @param {Object} cb
     * @param {Array} args
     * @param {Number} delay
     */
    delayedCallback(cb, args, delay) {
        this.timeout(delay).then(() => {
            cb.fn.apply(cb.scope, args)
        })
    }

    /**
     * @param name
     */
    fire(name) {
        let me        = this,
            args      = [].slice.call(arguments, 1),
            listeners = me[eventMapSymbol], // Always use the private, structured registry for firing events.
            delay, handler, handlers, i, len;

        if (listeners && listeners[name]) {
            handlers = [...listeners[name]];
            len      = handlers.length;

            for (i = 0; i < len; i++) {
                handler = handlers[i];
                delay   = handler.delay;

                // Resolve function name on the scope (or me), or, if it starts with 'up.'
                // look in the ownership hierarchy from me.
                const cb = (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_3__.resolveCallback)(handler.fn, handler.scope || me);

                // remove the listener if the scope no longer exists
                if (cb.scope && !cb.scope.id) {
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(listeners[name], handler)
                } else {
                    if (!me.suspendEvents) {
                        // Object event format. Inject firer reference in as 'source'
                        if (args.length === 1 && Neo.isObject(args[0])) {
                            args[0].source = me.id
                        }

                        // remove the listener if it has the once flag
                        handler.once && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(listeners[name], handler);

                        if (Neo.isNumber(delay) && delay > 0) {
                            me.delayedCallback(cb, handler.data ? args.concat(handler.data) : args, delay)
                        } else {
                            cb.fn.apply(cb.scope, handler.data ? args.concat(handler.data) : args)
                        }
                    }
                }
            }
        }
    }

    /**
     * Alias for addListener
     * @param {Object|String} name
     * @param {Object} [opts]
     * @param {Object} [scope]
     * @param {String} [eventId]
     * @param {Object} [data]
     * @param {Number} [order]
     * @returns {String} eventId
     */
    on(...args) {
        return this.addListener(...args)
    }

    /**
     * There are different syntax's how you can use this method.
     * Using the eventId:
     * ```
     * this.removeListener('change', 'neo-event-7');
     * ```
     * Passing the handler method:
     * ```
     * this.removeListener('change', this.onChange, this);
     * ```
     * Passing an object:
     * ```
     * me.field.un({
     *     change                    : me.onFieldChange,
     *     changeClearToOriginalValue: me.onFieldChange,
     *     scope                     : me
     * });
     * ```
     * @param {Object|String} name
     * @param {Function|String} [eventId]
     * @param {Neo.core.Base} [scope]
     */
    removeListener(name, eventId, scope) {
        let me = this,
            i, len, listener, listeners, match;

        // LAZY INITIALIZATION: Ensure the internal listener store exists.
        me[eventMapSymbol] ??= {};

        if (Neo.isFunction(eventId)) {
            me.removeListener({[name]: eventId, scope});
            return
        }

        if (Neo.isObject(name)) {
            if (name.scope) {
                scope = name.scope;
                delete name.scope;
            }

            Object.entries(name).forEach(([key, value]) => {
                listeners = me[eventMapSymbol][key] || [];
                i         = 0;
                len       = listeners.length;

                for (; i < len; i++) {
                    listener = listeners[i];

                    if (
                        listener.fn.name === (Neo.isString(value) ? value : value.name) &&
                        listener.scope   === scope
                    ) {
                        listeners.splice(i, 1);
                        break
                    }
                }
            })
        } else if (Neo.isString(eventId)) {
            listeners = me[eventMapSymbol][name];
            match     = false;

            listeners.forEach((eventConfig, idx) => {
                if (eventConfig.id === eventId) {
                    return match = idx
                }
            });

            if (match !== false) {
                listeners.splice(match, 1)
            }
        }
    }

    /**
     * Alias for removeListener
     * @param {Object|String} name
     * @param {String} [eventId]
     */
    un(...args) {
        this.removeListener(...args);
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Observable));


/***/ }),

/***/ "./src/core/Util.mjs":
/*!***************************!*\
  !*** ./src/core/Util.mjs ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @class Neo.core.Util
 */
class Util {
    /**
     * A regex to remove camel case syntax
     * @member {RegExp} decamelRegEx=/([a-z])([A-Z])/g
     * @protected
     * @static
     */
    static decamelRegEx = /([a-z])([A-Z])/g

    /**
     * @param {Object} scope
     * @param {String[]} values
     */
    static bindMethods(scope, values) {
        values.forEach(value => {
            scope[value] = scope[value].bind(scope)
        })
    }

    /**
     * Transforms a styles string into a styles object using camelcase syntax
     * @param {String} string The styles string to parse
     * @returns {Object} The camelcase styles object
     */
    static createStyleObject(string) {
        let parts;

        // split(';') does fetch semicolons inside brackets
        // -> background-image: "url('data:image/png;base64,...

        // TODO: Cache all regex
        return string.split(/;(?=[^\)]*(?:\(|$))/g).reduce((obj, el) => {
            // we have to split by the first colon only
            // -> background-image: url('http://example.com/image.png')
            parts = el.split((/:(.+)/)).map(function (x) {
                let num = parseFloat(x);

                return x == num ? num : x.trim()
            });

            if (parts[0] !== '') {
                parts[0] = parts[0].replace(/-([a-z])/g, (str, letter) => {
                    return letter.toUpperCase()
                });

                obj[parts[0]] = parts[1]
            }
            return obj
        }, {})
    }

    /**
     * Converts a styles object which can use camelcase syntax into a styles string
     * @param {Object} styles The styles object
     * @returns {String} The styles string (DOM ready)
     */
    static createStyles(styles) {
        let style = '';

        Object.entries(styles).forEach(([key, value]) => {
            if (value !== undefined && value !== null) {
                style += Util.decamel(key) + ':' + value + ';'
            }
        });

        return style
    }

    /**
     * Transforms all uppercase characters of a string into -lowercase.
     * Does not touch special characters.
     * @param {String} value The input containing uppercase characters
     * @returns {String} The lowercase output
     */
    static decamel(value) {
        return value.replace(Util.decamelRegEx, '$1-$2').toLowerCase()
    }

    /**
     * Returns true if the passed value is an array
     * @param {Object} value The value to test
     * @returns {Boolean}
     */
    static isArray(value) {
        return Array.isArray(value)
    }

    /**
     * Returns true if the passed value is a boolean
     * @param {Object} value The value to test
     * @returns {Boolean}
     */
    static isBoolean(value) {
        return typeof value === 'boolean'
    }

    /**
     * Returns true if the passed value is not undefined
     * @param {Object} value The value to test
     * @returns {Boolean}
     */
    static isDefined(value) {
        return typeof value !== 'undefined'
    }

    /**
     * Returns true if the passed value is an empty Array, Object or String
     * @param {Array|Object|String} value The value to test
     * @returns {Boolean}
     */
    static isEmpty(value) {
        if (value === null || value === undefined) {
            return true
        }

        if (Array.isArray(value)) {
            return value.length === 0
        }

        if (value instanceof Date) {
            return false
        }

        if (Util.isObject(value)) {
            return Object.keys(value).length === 0
        }

        if (Util.isString(value)) {
            return value === ''
        }

        return false
    }

    /**
     * Returns true if the passed value is a function
     * @param {Function} value The value to test
     * @returns {Boolean}
     */
    static isFunction(value) {
        return typeof value === 'function'
    }

    /**
     * Returns true if the passed value is a number. Returns false for non-finite numbers
     * @param {Number} value The value to test
     * @returns {Boolean}
     */
    static isNumber(value){
        return typeof value === 'number' && isFinite(value)
    }

    /**
     * Returns true if the passed value is an object
     * @param {Object} value The value to test
     * @returns {Boolean}
     */
    static isObject(value) {
        return value?.constructor?.name === 'Object'
    }

    /**
     * Returns true if the passed value is a promise.
     * We are intentionally not checking for `value instanceof Promise`,
     * to support any "thenable" objects for flexibility.
     * @param {Object} value The value to test
     * @returns {Boolean}
     */
    static isPromise(value) {
        return typeof value?.then === 'function'
    }

    /**
     * Returns true if the passed value is a neo data record
     * @param {Object} value The value to test
     * @returns {Boolean}
     */
    static isRecord(value) {
        return value?.constructor?.name === 'Record'
    }

    /**
     * Returns true if the passed value is a string
     * @param {String} value The value to test
     * @returns {Boolean}
     */
    static isString(value) {
        return typeof value === 'string'
    }

    /**
     * Converts any iterable (strings, numeric indices and a length property) into a true array
     * @param {Object|String} iterable
     * @param {Number} [start=0] start index
     * @param {Number} [end=iterable.length] end index
     * @returns {Array}
     */
    static toArray(iterable, start, end) {
        let len;

        if (!iterable || !(len = iterable.length)) {
            return []
        }

        if (typeof iterable === 'string') {
            return iterable.split('')
        }

        return Array.prototype.slice.call(iterable, start || 0, end || len)
    }
}

const ns = Neo.ns('Neo.core', true);
ns.Util = Util;

// aliases
Neo.applyFromNs(Neo, Util, {
    bindMethods      : 'bindMethods',
    createStyleObject: 'createStyleObject',
    createStyles     : 'createStyles',
    decamel          : 'decamel',
    isArray          : 'isArray',
    isBoolean        : 'isBoolean',
    isDefined        : 'isDefined',
    isEmpty          : 'isEmpty',
    isFunction       : 'isFunction',
    isNumber         : 'isNumber',
    isObject         : 'isObject',
    isPromise        : 'isPromise',
    isRecord         : 'isRecord',
    isString         : 'isString',
    toArray          : 'toArray'
}, true);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Util);


/***/ }),

/***/ "./src/core/_export.mjs":
/*!******************************!*\
  !*** ./src/core/_export.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Base: () => (/* reexport safe */ _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   Compare: () => (/* reexport safe */ _Compare_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   IdGenerator: () => (/* reexport safe */ _IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   Observable: () => (/* reexport safe */ _Observable_mjs__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   Util: () => (/* reexport safe */ _Util_mjs__WEBPACK_IMPORTED_MODULE_4__["default"])
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _Compare_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Compare.mjs */ "./src/core/Compare.mjs");
/* harmony import */ var _IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./IdGenerator.mjs */ "./src/core/IdGenerator.mjs");
/* harmony import */ var _Observable_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _Util_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Util.mjs */ "./src/core/Util.mjs");









/***/ }),

/***/ "./src/manager/Base.mjs":
/*!******************************!*\
  !*** ./src/manager/Base.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../collection/Base.mjs */ "./src/collection/Base.mjs");


/**
 * Abstract base class for the other manager classes
 * @class Neo.manager.Base
 * @extends Neo.collection.Base
 */
class Manager extends _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]{
    static config = {
        /**
         * @member {String} className='Neo.manager.Base'
         * @protected
         */
        className: 'Neo.manager.Base'
    }

    /**
     * @param {Number|String} id
     * @returns {Object}
     */
    getById(id) {
        return id && this.get(id) || null
    }

    /**
     * @param {Object} item
     */
    register(item) {
        let me = this;

        if (me.get(item.id)) {
            Neo.logError('Trying to create an item with an already existing id', item, me.get(item.id))
        } else {
            me.push(item)
        }
    }

    /**
     * Removes a collection item passed by reference or key
     * @param {Object|String} item
     */
    unregister(item) {
        this.remove(item)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Manager));


/***/ }),

/***/ "./src/manager/ClassHierarchy.mjs":
/*!****************************************!*\
  !*** ./src/manager/ClassHierarchy.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/manager/Base.mjs");


/**
 * @class Neo.manager.ClassHierarchy
 * @extends Neo.manager.Base
 * @singleton
 *
 * This manager maintains a registry of all classes defined within the Neo.mjs framework's current realm (main or worker),
 * including their inheritance relationships and key metadata.
 * Each registered item (value in the manager's store) has the following structure:
 * @typedef {Object} ClassHierarchyInfo
 * @property {String} className - The full Neo.mjs class name (e.g., 'Neo.component.Base').
 * @property {Function|Object} module - The direct reference to the class constructor function itself (for non-singletons)
 * or the instantiated singleton object (for singletons).
 * @property {String|null} ntype - The ntype of the class if defined (e.g., 'button', 'container'), otherwise `null`.
 * @property {String|null} parentClassName - The full class name of its direct parent class,
 * or `null` if it's a top-level class (e.g., 'Neo.core.Base').
 */
class ClassHierarchy extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.ClassHierarchy'
         * @protected
         */
        className: 'Neo.manager.ClassHierarchy',
        /**
         * @member {String} keyProperty='className'
         * @protected
         */
        keyProperty: 'className',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * Memoizes the return values of isA() calls
     * @member {Map} isAQueryMap=new Map()
     * @protected
     */
    isAQueryMap = new Map()

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);
        this.consumeTempMap()
    }

    /**
     * Register all classes that got applied to the Neo namespace before this instance got created
     * @protected
     */
    consumeTempMap() {
        if (Neo.classHierarchyMap) {
            this.add(Object.values(Neo.classHierarchyMap));
            delete Neo.classHierarchyMap
        }
    }

    /**
     * Both params represent classNames.
     *
     * Example use cases:
     * - isA('Neo.button.Menu',    'Neo.button.Base')    => true
     * - isA('Neo.button.Base',    'Neo.button.Menu')    => false
     * - isA('Neo.button.Base',    'Neo.component.Base') => true
     * - isA('Neo.component.Base', 'Neo.core.Base')      => true
     * @param {String} descendant
     * @param {String} ancestor
     * @returns {Boolean}
     */
    isA(descendant, ancestor) {
        if (descendant === ancestor) {
            return true
        }

        let parent        = descendant,
            {isAQueryMap} = this,
            queryName     = `${descendant},${ancestor}`,
            returnValue   = false;

        if (isAQueryMap.has(queryName)) {
            return isAQueryMap.get(queryName)
        }

        while (parent = this.get(parent)?.parentClassName) {
            if (parent === ancestor) {
                returnValue = true;
                break
            }

            // Assumption: component.Base directly extends core.Base
            if (parent === 'Neo.component.Base' && ancestor !== 'Neo.core.Base') {
                returnValue = false;
                break
            }

            if (parent === 'Neo.core.Base') {
                returnValue = false;
                break
            }
        }

        isAQueryMap.set(queryName, returnValue);

        return returnValue
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(ClassHierarchy));


/***/ }),

/***/ "./src/manager/Component.mjs":
/*!***********************************!*\
  !*** ./src/manager/Component.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/manager/Base.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/VDom.mjs */ "./src/util/VDom.mjs");
/* harmony import */ var _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/VNode.mjs */ "./src/util/VNode.mjs");




/**
 * @class Neo.manager.Component
 * @extends Neo.manager.Base
 * @singleton
 */
class Component extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.Component'
         * @protected
         */
        className: 'Neo.manager.Component',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * @member {Map} wrapperNodes=new Map()
     */
    wrapperNodes = new Map()

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        Neo.first        = me.getFirst.bind(me); // alias
        Neo.getComponent = me.get     .bind(me)  // alias
    }

    /**
     * Flattens a given vnode tree by replacing component based subtrees with componentId based references
     * @param {Object} vnode
     * @param {String} ownerId We do not want to replace the own id => wrapped items
     * @returns {Object}
     */
    addVnodeComponentReferences(vnode, ownerId) {
        vnode = {...vnode}; // shallow copy

        let me         = this,
            childNodes = vnode?.childNodes ? [...vnode.childNodes] : [],
            childNodeId, component, componentId, parentRef, referenceNode;

        vnode.childNodes = childNodes;

        childNodes.forEach((childNode, index) => {
            childNodeId = childNode.id;

            if (!childNode.componentId && childNodeId !== ownerId) {
                component = me.get(childNodeId);

                if (!component) {
                    // searching for wrapped components as a fallback
                    component = me.wrapperNodes.get(childNodeId);

                    if (component) {
                        // update the parent component reference => assign the wrapper id
                        componentId = component.id;
                        parentRef   = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].find(component.parent.vdom, {componentId}, false);

                        if (parentRef) {
                            parentRef.vdom.id = childNodeId
                        }
                    }
                }

                if (component) {
                    componentId   = component.id;
                    referenceNode = {componentId};

                    if (componentId !== childNodeId) {
                        referenceNode.id = childNodeId
                    }
                }
            }

            childNodes[index] = component ? referenceNode : me.addVnodeComponentReferences(childNode, ownerId)
        });

        return vnode
    }

    /**
     * Returns the first component which matches the config-selector moving down the component items tree.
     * Use returnFirstMatch=false to get an array of all matching items instead.
     * If no match is found, returns null in case returnFirstMatch === true, otherwise an empty Array.
     * @param {Neo.component.Base|String} component
     * @param {Object|String|null} config
     * @param {Boolean} returnFirstMatch=true
     * @returns {Neo.component.Base|Neo.component.Base[]|null}
     */
    down(component, config, returnFirstMatch=true) {
        if (Neo.isString(component)) {
            component = this.getById(component);
        }

        let me          = this,
            matchArray  = [],
            returnValue = null,
            i           = 0,
            returnArray = [],
            childItems, configArray, configLength, len;

        if (Neo.isString(config)) {
            config = {
                ntype: config
            }
        } else if (!config) {
            config = {}
        }

        configArray  = Object.entries(config);
        configLength = configArray.length;

        configArray.forEach(([key, value]) => {
            if ((component[key] === value)
                || (key === 'ntype' && me.hasPrototypePropertyValue(component, key, value)))
            {
                matchArray.push(true)
            }
        });

        if (matchArray.length === configLength) {
            if (returnFirstMatch) {
                return component
            }

            returnArray.push(component)
        }

        childItems = me.find({parentId: component.id});
        len        = childItems.length;

        for (; i < len; i++) {
            returnValue = me.down(childItems[i], config, returnFirstMatch);

            if (returnFirstMatch) {
                if (returnValue !== null) {
                    return returnValue
                }
            } else if (returnValue.length > 0) {
                returnArray.push(...returnValue)
            }
        }

        return returnFirstMatch ? null: returnArray
    }

    /**
     * @param {Object[]} path
     * @returns {String|null} the component id in case there is a match
     */
    findParentComponent(path) {
        let me  = this,
            i   = 0,
            len = path?.length || 0,
            id;

        for (; i < len; i++) {
            id = path[i];

            if (id && me.has(id)) {
                return id
            }
        }

        return null
    }

    /**
     * Returns the object associated to the key, or null if there is none.
     * @param {Number|String} key
     * @param {Boolean}       [includeWrapperNodes=true]
     * @returns {Neo.component.Base|null}
     */
    get(key, includeWrapperNodes=true) {
        if (includeWrapperNodes) {
            let wrapperNode = this.wrapperNodes.get(key);

            if (wrapperNode) {
                return wrapperNode
            }
        }

        return super.get(key)
    }

    /**
     * Returns all child components which are recursively matched via their parentId
     * @param {Neo.component.Base} component
     * @returns {Neo.component.Base[]} childComponents
     */
    getChildComponents(component) {
        let me             = this,
            directChildren = me.find('parentId', component.id) || [],
            components     = [],
            childComponents;

        directChildren.forEach(item => {
            components.push(item);

            childComponents = me.getChildComponents(item);

            childComponents && components.push(...childComponents)
        });

        return components
    }

    /**
     * todo: replace all calls of this method to calls using the util.VNode class
     * Get the ids of all child nodes of the given vnode
     * @param {Object} vnode
     * @param {String[]} childIds=[]
     * @returns {String[]} childIds
     */
    getChildIds(vnode, childIds=[]) {
        return _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getChildIds(vnode, childIds)
    }

    /**
     * Returns all child components found inside the vnode tree
     * @param {Neo.component.Base} component
     * @returns {Neo.component.Base[]} childComponents
     */
    getChildren(component) {
        let childComponents = [],
            childNodes      = _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getChildIds(component.vnode),
            childComponent;

        childNodes.forEach(node => {
            childComponent = this.get(node);

            if (childComponent) {
                childComponents.push(childComponent)
            }
        });

        return childComponents
    }

    /**
     * !! For debugging purposes only !!
     *
     * Get the first component based on the ntype or other properties
     *
     * @param {String|Object|Array} componentDescription
     * @param {Boolean} returnFirstMatch=true
     * @returns {Neo.component.Base|null|Neo.component.Base[]}
     *
     * @example
     // as String: ntype[comma separated propterties]
     Neo.first('toolbar button[text=Try me,icon=people]')
     // as Object: Add properties. ntype is optional
     Neo.first({
                icon: 'people'
            })
     // as Array: An Array of Objects. No Strings allowed
     Neo.first([{
                ntype: 'toolbar'
            },{
                ntype: 'button', text: 'Try me', icon: 'people
            }])

     * The returnFirstMatch flag allows to return all items and
     * not stop after the first result.
     *
     * @example
     Neo.first('button', false) // => [Button, Button, Button]
     */
    getFirst(componentDescription, returnFirstMatch = true) {
        let objects = [],
            app     = Neo.apps[Object.keys(Neo.apps)[0]],
            root    = app.mainView;

        /* create an array of objects from string */
        if (Neo.isString(componentDescription)) {
            const regex = /(\w*)(\[[^\]]*\])|(\w*)/g;
            let match;

            /* generate objects which contain the information */
            while (match = regex.exec(componentDescription)) {
                let [, ntype, pairs, ntypeOnly] = match, obj;

                ntype = ntype || ntypeOnly;
                obj = {ntype};

                if (pairs) {
                    const pairsRegex = /\[(.*?)\]/,
                          pairsMatch = pairs.match(pairsRegex);

                    if (pairsMatch) {
                        const pairs = pairsMatch[1].split(',');
                        pairs.forEach((pair) => {
                            const [key, value] = pair.split('=');
                            obj[key] = value.replace(/"/g, '')
                        });
                    }
                }
                objects.push(obj);

                regex.lastIndex++
            }
        } else if (Neo.isObject(componentDescription)){
            objects.push(componentDescription)
        } else if (Neo.isArray(componentDescription)) {
            objects = componentDescription
        }

        /* find the correct child using down() */
        const result = objects.reduce((acc, key) => {
            if (acc) {
                let child = acc.down(key, returnFirstMatch);

                if (!!child) {
                    return child
                }
            }

            return null
        }, root);

        return result
    }

    /**
     * Returns an Array containing the ids of all parent components for a given component
     * @param {Neo.component.Base} component
     * @returns {String[]} parentIds
     */
    getParentIds(component) {
        let parentIds = [];

        while (component?.parentId) {
            component = this.get(component.parentId);

            if (component) {
                parentIds.push(component.id)
            }
        }

        return parentIds
    }

    /**
     * @param {Array} path
     * @returns {Array}
     */
    getParentPath(path) {
        let me            = this,
            componentPath = [],
            i             = 0,
            len           = path?.length || 0;

        for (; i < len; i++) {
            if (me.has(path[i]) || me.wrapperNodes.get(path[i])) {
                componentPath.push(path[i])
            }
        }

        return componentPath
    }

    /**
     * Returns an Array containing all parent components for a given component or component id
     * @param {Neo.component.Base|String} component
     * @returns {Neo.component.Base[]} parents
     */
    getParents(component) {
        if (Neo.isString(component)) {
            component = this.get(component)
        }

        let parents = [];

        while (component?.parentId) {
            component = this.get(component.parentId);

            if (component) {
                parents.push(component)
            }
        }

        return parents
    }

    /**
     * Check if the component had a property of any value somewhere in the Prototype chain
     *
     * @param {Neo.component.Base} component
     * @param {String} property
     * @param {*} value
     * @returns {boolean}
     */
    hasPrototypePropertyValue(component, property, value) {
        while (component !== null) {
            if (component.hasOwnProperty(property) && component[property] === value) {
                return true
            }

            component = component.__proto__
        }

        return false
    }

    /**
     * @param {String} wrapperId
     * @param {Neo.component.Base} component
     */
    registerWrapperNode(wrapperId, component) {
        this.wrapperNodes.set(wrapperId, component)
    }

    /**
     * @param {Neo.component.Base|String} item
     */
    unregister(item) {
        if (item) {
            if (Neo.isString(item)) {
                this.wrapperNodes.delete(item)
            } else if (item.id !== item.vdom.id) {
                this.wrapperNodes.delete(item.vdom.id)
            }
        }

        super.unregister(item)
    }

    /**
     * Returns the first component which matches the config-selector.
     * Use returnFirstMatch=false to get an array of all matching items instead.
     * If no match is found, returns null in case returnFirstMatch === true, otherwise an empty Array.
     * @param {String} componentId
     * @param {Object|String|null} config
     * @param {Boolean} returnFirstMatch=true
     * @returns {Neo.component.Base|Neo.component.Base[]|null}
     */
    up(componentId, config, returnFirstMatch=true) {
        let component   = this.get(componentId),
            returnArray = [],
            configArray, configLength, matchArray;

        if (Neo.isString(config)) {
            config = {
                ntype: config
            }
        } else if (!config) {
            config = {}
        }

        configArray  = Object.entries(config);
        configLength = configArray.length;

        while (component?.parentId) {
            component = this.get(component.parentId);

            if (!component) {
                return returnFirstMatch ? null : returnArray
            }

            matchArray = [];

            configArray.forEach(([key, value]) => {
                if (component[key] === value) {
                    matchArray.push(true)
                }
            });

            if (matchArray.length === configLength) {
                if (returnFirstMatch) {
                    return component
                }

                returnArray.push(component)
            }
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Component));


/***/ }),

/***/ "./src/manager/DomEvent.mjs":
/*!**********************************!*\
  !*** ./src/manager/DomEvent.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Component.mjs */ "./src/manager/Component.mjs");
/* harmony import */ var _Focus_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Focus.mjs */ "./src/manager/Focus.mjs");
/* harmony import */ var _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Logger.mjs */ "./src/util/Logger.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/VDom.mjs */ "./src/util/VDom.mjs");







const eventConfigKeys = [
    'bubble',
    'delegate',
    'local',
    'scope',
    'vnodeId'
];

const globalDomEvents = [
    'change',
    'click',
    'contextmenu',
    'dblclick',
    'drag:end',
    'drag:move',
    'drag:start',
    'focusin',
    'focusout',
    'input',
    'intersect',
    'keydown',
    'keyup',
    'mousedown',
    'mouseenter',
    'mouseleave',
    'mouseup',
    'neonavigate',
    'scroll',
    'selectionchange',
    'touchmove',
    'wheel'
];

/**
 * @class Neo.manager.DomEvent
 * @extends Neo.core.Base
 * @singleton
 */
class DomEvent extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.DomEvent'
         * @protected
         */
        className: 'Neo.manager.DomEvent',
        /**
         * @member {Object} items={}
         * @protected
         */
        items: {},
        /**
         * @member {Object} map={}
         * @protected
         */
        map: {},
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     *
     * @param {Neo.component.Base} component
     * @param {data} event
     */
    addResizeObserver(component, event) {
        if (!Neo.main.addon.ResizeObserver) {
            console.error('For using resize domListeners, you must include main.addon.ResizeObserver.', event)
        }

        let {id, windowId} = component;

        Neo.main.addon.ResizeObserver.register({id, windowId})
    }

    /**
     * @param {Object} event
     * @protected
     */
    fire(event) {
        let me          = this,
            bubble      = true,
            data        = event.data || {},
            {eventName} = event,
            i           = 0,
            listeners   = null,
            pathIds     = data.path.map(e => e.id),
            path        = _Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getParentPath(pathIds),
            len         = path.length,
            component, delegationTargetId, id, preventFire;

        for (; i < len; i++) {
            id        = path[i];
            component = Neo.getComponent(id);

            if (!component || component.disabled) {
                break
            }

            listeners = me.items[id]?.[eventName];

            if (listeners) {
                if (Array.isArray(listeners)) {
                    // Stop iteration if a handler returns false
                    listeners.every(listener => {
                        let result;

                        if (listener && listener.fn) {
                            if (eventName === 'resize') {
                                // we do not want delegation for custom main.addon.ResizeObserver events
                                delegationTargetId = data.id === component.id ? data.id : false
                            } else {
                                delegationTargetId = me.verifyDelegationPath(listener, data.path)
                            }

                            if (delegationTargetId !== false) {
                                preventFire = false;

                                // we only want mouseenter & leave to fire on their top level nodes, not for children
                                if (eventName === 'mouseenter' || eventName === 'mouseleave') {
                                    preventFire = !DomEvent.verifyMouseEnterLeave(component, data, delegationTargetId, eventName)
                                }

                                if (!preventFire) {
                                    // multiple listeners would change the reference of data.component
                                    data = Neo.clone(data, true, true);

                                    data.component = component;

                                    // Handler needs to know which actual target matched the delegate
                                    data.currentTarget = delegationTargetId;

                                    if (Neo.isString(listener.fn)) {
                                        me.bindCallback(listener.fn, 'fn', listener.scope, listener)
                                    }

                                    result = listener.fn.apply(listener.scope || globalThis, [data]);

                                    if (!listener.bubble) {
                                        bubble = false
                                    }
                                }
                            }
                        }
                        // If a listener returns false, we stop iterating the listeners
                        return result !== false
                    })
                }
            }

            // we do want to trigger the FocusManager after normal domListeners on these events got executed
            if (eventName === 'focusin' || eventName === 'focusout') {
                _Focus_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]['on' + Neo.capitalize(eventName)]({
                    componentPath: path,
                    data
                });

                break
            }

            // Honor the Event cancelBubble property
            if (!bubble || data.cancelBubble) {
                break
            }
        }

        if (eventName === 'contextmenu' && data.ctrlKey) {
            Neo.util?.Logger?.onContextMenu(data)
        } else if (eventName.startsWith('drop')) {
            let dragZone = data.dragZoneId && Neo.get(data.dragZoneId);

            if (dragZone) {
                dragZone.fire(eventName, data);
                dragZone[{
                    'drop'      : 'onDrop',
                    'drop:enter': 'onDropEnter',
                    'drop:leave': 'onDropLeave',
                }[eventName]].call(dragZone, data)
            }
        }
    }

    /**
     * @param config
     * @param scope
     * @returns {Object}
     */
    generateListenerConfig(config, scope) {
        return {
            bubble   : config.bubble,
            delegate : config.delegate,
            eventName: config.eventName,
            id       : scope.id,
            opts     : config,
            priority : config.priority,
            scope    : config.scope   || scope,
            vnodeId  : config.vnodeId || scope.vdom.id
        };
    }

    getEventName(config) {
        let eventName = null;

        if (Neo.isObject(config)) {
            Object.keys(config).forEach(key => {
                if (!eventConfigKeys.includes(key)) {
                    eventName = key
                }
            })
        }

        return eventName
    }

    /**
     * @param {Object} config
     * @param {Boolean} config.bubble
     * @param {String} config.delegate
     * @param {String} config.eventName
     * @param {String} config.id
     * @param {Object} config.opts
     * @param {Object} config.scope
     * @param {String} config.vnodeId
     * @returns {Object}
     */
    getListener(config) {
        let listeners = this.items,
            event;

        if (listeners?.[config.id]) {
            event = listeners[config.id][config.eventName];

            return event || null
        }
    }

    /**
     * Mounts local domEvent listeners for a given component
     * @param {Neo.component.Base} component
     * @protected
     */
    mountDomListeners(component) {
        let listeners   = this.items[component.id],
            localEvents = [];

        if (listeners) {
            Object.entries(listeners).forEach(([eventName, value]) => {
                value.forEach(event => {
                    eventName = event.eventName;

                    if (eventName === 'resize') {
                        this.addResizeObserver(component, event)
                    } else if (eventName && (event.local || !globalDomEvents.includes(eventName))) {
                        localEvents.push({
                            name   : eventName,
                            handler: 'domEventListener',
                            vnodeId: event.vnodeId
                        })
                    }
                })
            });

            if (localEvents.length > 0) {
                Neo.worker.App.promiseMessage('main', {
                    action  : 'addDomListener',
                    appName : component.appName,
                    events  : localEvents,
                    windowId: component.windowId
                }).then(data => {
                    // console.log('added domListener', data);
                }).catch(err => {
                    console.log('App: Got error attempting to add a domListener', err)
                })
            }
        }
    }

    /**
     * @param {Object}  config
     * @param {Boolean} config.bubble
     * @param {String}  config.delegate
     * @param {String}  config.eventName
     * @param {String}  config.id
     * @param {Boolean} config.local
     * @param {Number}  config.opts
     * @param {Number}  config.originalConfig
     * @param {String}  config.ownerId
     * @param {Number}  config.priority=1
     * @param {Object}  config.scope
     * @param {String}  config.vnodeId
     * @returns {Boolean} true if the listener got registered successfully (false in case it was already there)
     */
    register(config) {
        let me                           = this,
            alreadyRegistered            = false,
            {eventName, id, opts, scope} = config,
            listeners                    = me.items,
            fnType                       = typeof opts,
            fn, listener, listenerConfig, listenerId;

        if (fnType === 'function' || fnType === 'string') {
            fn = opts
        } else {
            fn    = opts.fn;
            scope = opts.scope || scope
        }

        if (!listeners[id]) {
            listeners[id] = {}
        }

        if (listeners[id][eventName]) {
            listener = listeners[id][eventName];

            Object.keys(listener).forEach(key => {
                if (
                    listener[key].fn.toString() === fn.toString() && // todo: add a better check
                    listener[key].scope         === scope &&
                    listener[key].delegate      === config.delegate
                ) {
                    alreadyRegistered = true
                }
            })
        } else {
            listeners[id][eventName] = []
        }

        if (alreadyRegistered === true) {
            return false
        }

        // console.log('manager.DomEvent register', eventName, config);

        listenerId = Neo.getId('dom-event');

        config.listenerId = listenerId;

        listenerConfig = {
            bubble        : config.hasOwnProperty('bubble') ? config.bubble : opts.hasOwnProperty('bubble') ? opts.bubble : true,
            delegate      : config.delegate,
            eventName,
            fn,
            id            : listenerId,
            mounted       : !config.local && globalDomEvents.includes(eventName),
            originalConfig: config.originalConfig,
            ownerId       : config.ownerId,
            priority      : config.priority || opts.priority || 1,
            scope,
            vnodeId       : config.vnodeId
        };

        me.map[listenerId] = listenerConfig;

        listeners[id][eventName].push(listenerConfig);

        listeners[id][eventName].sort((a, b) => b.priority - a.priority);

        return true
    }

    /**
     * @param {Object} config
     * @param {Boolean} config.bubble
     * @param {String} config.eventName
     * @param {String} config.id
     * @param {Object} config.opts
     * @param {Object} config.scope
     * @param {String} config.vnodeId
     * @param {Object} scope
     * @returns {Boolean} true in case the listener did exist and got removed
     */
    unregister(config, scope) {
        // todo
        console.log('unregister', config);
        console.log(this.generateListenerConfig(config, scope));
        return;

        // removed by dead control flow
{}

        // removed by dead control flow
{}
    }

    /**
     * @param {Neo.component.Base} component
     * @param {Object[]} domListeners
     * @param {Object[]} oldDomListeners
     */
    updateDomListeners(component, domListeners, oldDomListeners) {
        let me                  = this,
            registeredListeners = me.items[component.id] || {},
            i, len, listeners;

        if (Array.isArray(domListeners)) {
            if (Array.isArray(oldDomListeners)) {
                oldDomListeners.forEach(oldDomListener => {
                    // find & remove no longer existing listeners
                    if (!domListeners.includes(oldDomListener)) {
                        listeners = registeredListeners[me.getEventName(oldDomListener)] || [];
                        i         = 0;
                        len       = listeners.length;

                        for (; i < len; i++) {
                            if (listeners[i].originalConfig === oldDomListener) {
                                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].remove(listeners, listeners[i]);
                                break
                            }
                        }
                    }
                })
            }

            // add new listeners
            domListeners.forEach(domListener => {
                Object.entries(domListener).forEach(([key, value]) => {
                    if (!eventConfigKeys.includes(key)) {
                        me.register({
                            bubble        : domListener.bubble   || value.bubble,
                            delegate      : domListener.delegate || value.delegate || '#' + (component.vdom.id || component.id),
                            eventName     : key,
                            id            : component.vdom.id || component.id, // honor wrapper nodes
                            opts          : value,
                            originalConfig: domListener,
                            ownerId       : component.id,
                            priority      : domListener.priority || value.priority || 1,
                            scope         : domListener.scope    || component,
                            vnodeId       : domListener.vnodeId  || value.vnodeId  || component.vdom.id
                        })
                    }
                })
            });

            if (component.mounted && domListeners?.length > 0) {
                me.timeout(100).then(() => {
                    me.mountDomListeners(component)
                })
            }
        } else {
            _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].logError('Component.domListeners have to be an array', component)
        }
    }

    /**
     * @param {Object} listener
     * @param {Array} path
     * @returns {Boolean|String} true in case the delegation string matches the event path
     */
    verifyDelegationPath(listener, path) {
        let {delegate} = listener,
            j          = 0,
            pathLen    = path.length,
            targetId;

        if (typeof delegate === 'function') {
            j = delegate(path);

            if (j != null) {
                targetId = path[j].id
            }
        } else {
            let delegationArray = delegate.split(' '),
                len             = delegationArray.length,
                hasMatch, i, item, isId;

            for (i=len-1; i >= 0; i--) {
                hasMatch = false;
                item     = delegationArray[i];
                isId     = item.startsWith('#');

                if (isId || item.startsWith('.')) {
                    item = item.substr(1)
                }

                for (; j < pathLen; j++) {
                    if (
                        (isId && path[j].id === item) ||
                        path[j].cls.includes(item)
                    ) {
                        hasMatch = true;
                        targetId = path[j].id;
                        break
                    }
                }

                if (!hasMatch) {
                    return false
                }
            }
        }

        // ensure the delegation path is a child of the owner components root node
        for (; j < pathLen; j++) {
            if (path[j].id === listener.vnodeId) {
                return targetId
            }
        }

        return false
    }

    /**
     * @param {Neo.component.Base} component
     * @param {Object} data
     * @param {String} delegationTargetId
     * @param {String} eventName
     * @returns {Boolean}
     */
    static verifyMouseEnterLeave(component, data, delegationTargetId, eventName) {
        let targetId = eventName === 'mouseenter' ? data.fromElementId : data.toElementId,
            delegationVdom;

        if (targetId && targetId !== delegationTargetId) {
            delegationVdom = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].find(component.vdom, delegationTargetId);

            // delegationVdom can be undefined when dragging a proxy over the node.
            // see issues/1137 for details.
            if (!delegationVdom || delegationVdom.vdom && _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].find(delegationVdom.vdom, targetId)) {
                return false
            }
        }

        return true
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DomEvent));


/***/ }),

/***/ "./src/manager/Focus.mjs":
/*!*******************************!*\
  !*** ./src/manager/Focus.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @class Neo.manager.Focus
 * @extends Neo.core.Base
 * @singleton
 */
class Focus extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.Focus'
         * @protected
         */
        className: 'Neo.manager.Focus',
        /**
         * An array containing opts objects.
         * opts.componentPath
         * opts.data
         * @member {Object[]} history=[]
         */
        history: [],
        /**
         * The Date object when the last focusin event has occurred
         * @member {Date|null} lastFocusInDate=null
         * @protected
         */
        lastFocusInDate: null,
        /**
         * The Date object when the last focusout event has occurred
         * @member {Date|null} lastFocusInDate=null
         * @protected
         */
        lastFocusOutDate: null,
        /**
         * The amount of time for a focusIn to occur after the last focusOut
         * to get combined into a focusmove event.
         * @member {Number} maxFocusInOutGap=50
         */
        maxFocusInOutGap: 50,
        /**
         * The maximum amount of items stored inside the history array
         * @member {Number} maxHistoryLength=20
         */
        maxHistoryLength: 20,
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * @param {Object} opts
     * @param {Array}  opts.componentPath Component ids upwards
     * @param {Object} opts.data dom event infos
     * @protected
     */
    addToHistory(opts) {
        let history = this.history;

        history.unshift(opts);
        history.length >= this.maxHistoryLength && history.pop()
    }

    /**
     * @param {Object} opts
     * @param {Array}  opts.componentPath Component ids upwards
     * @param {Object} opts.data dom event infos
     * @protected
     */
    focusEnter(opts) {
        this.setComponentFocus(opts, true);
        this.addToHistory(opts)
    }

    /**
     * @param {Object} opts
     * @param {Array}  opts.componentPath Component ids upwards
     * @param {Object} opts.data dom event infos
     * @protected
     */
    focusLeave(opts) {
        this.setComponentFocus(opts, false)
    }

    /**
     * @param {Object} opts
     * @param {Array}  opts.componentPath Component ids upwards
     * @param {Object} opts.data dom event infos
     * @protected
     */
    focusMove(opts) {
        let me               = this,
            {history}        = me,
            newComponentPath = opts.componentPath,
            oldComponentPath = history[0].componentPath,
            focusEnter       = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].difference(newComponentPath, oldComponentPath),
            focusLeave       = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].difference(oldComponentPath, newComponentPath),
            focusMove        = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].intersection(newComponentPath, oldComponentPath),
            component, data;

        me.setComponentFocus({componentPath: focusLeave, data: opts.data}, false);
        me.setComponentFocus({componentPath: focusEnter, data: opts.data}, true);

        focusMove.forEach(id => {
            component = Neo.getComponent(id);

            if (component) {
                data = {
                    component,
                    path   : opts.data.path,
                    oldPath: history[0].data.path
                };

                component.onFocusMove?.(data);
                component.fire('focusMove', data);

                component.onFocusChange?.(data);
                component.fire('focusChange', data)
            }
        });

        me.addToHistory(opts)
    }

    /**
     * @param {Object} opts
     * @param {Array}  opts.componentPath Component ids upwards
     * @param {Object} opts.data dom event infos
     * @protected
     */
    onFocusin(opts) {
        let me = this;

        me.lastFocusInDate = new Date();

        if (me.lastFocusOutDate && me.lastFocusInDate - me.lastFocusOutDate < me.maxFocusInOutGap) {
            me.focusMove(opts)
        } else {
            me.focusEnter(opts)
        }
    }

    /**
     * @param {Object} opts
     * @param {Array}  opts.componentPath Component ids upwards
     * @param {Object} opts.data dom event infos
     * @protected
     */
    onFocusout(opts) {
        let me = this;

        me.lastFocusOutDate = new Date();

        me.timeout(me.maxFocusInOutGap).then(() => {
            if (me.lastFocusOutDate > me.lastFocusInDate) {
                me.focusLeave(opts)
            }
        })
    }

    /**
     * @param {Object} opts
     * @param {Array}  opts.componentPath Component ids upwards
     * @param {Object} opts.data dom event infos
     * @param {Boolean} containsFocus
     * @protected
     */
    setComponentFocus(opts, containsFocus) {
        let data = {
                relatedTarget: opts.data.relatedTarget
            },
            components = opts.componentPath.map(id => Neo.getComponent(id)),
            handler;

        components.forEach(component => {
            if (component) {
                component.containsFocus = containsFocus
            }
        });

        components.forEach(component => {
            if (component) {
                data.component = component;

                data[containsFocus ? 'path' : 'oldPath'] = opts.data.path

                handler = containsFocus ? 'onFocusEnter' : 'onFocusLeave';
                component[handler]?.(data);

                component.fire(containsFocus ? 'focusEnter' : 'focusLeave', data);

                component.onFocusChange?.(data);
                component.fire('focusChange', data)
            }
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Focus));


/***/ }),

/***/ "./src/manager/Instance.mjs":
/*!**********************************!*\
  !*** ./src/manager/Instance.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Base.mjs */ "./src/manager/Base.mjs");



/**
 * @class Neo.manager.Instance
 * @extends Neo.manager.Base
 * @singleton
 */
class Instance extends _Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.Instance'
         * @protected
         */
        className: 'Neo.manager.Instance',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].instanceManagerAvailable = true;

        me.consumeNeoIdMap();

        Neo.find      = me.find     .bind(me); // alias
        Neo.findFirst = me.findFirst.bind(me); // alias
        Neo.get       = me.get      .bind(me); // alias
    }

    /**
     * Register all ids which got applied to the Neo namespace before this instance got created
     * @protected
     */
    consumeNeoIdMap() {
        if (Neo.idMap) {
            this.add(Object.values(Neo.idMap));
            delete Neo.idMap
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Instance));


/***/ }),

/***/ "./src/util/Array.mjs":
/*!****************************!*\
  !*** ./src/util/Array.mjs ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.util.Array
 * @extends Neo.core.Base
 */
class NeoArray extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.Array'
         * @protected
         */
        className: 'Neo.util.Array'
    }

    /**
     * Adds an item or Array of items to an array in case it does not already exist.
     * Only primitive items will get found as duplicates
     * @param {Array} arr
     * @param {*} items
     * @returns {Array}
     */
    static add(arr, items) {
        if (!Array.isArray(items)) {
            items = [items]
        }

        items.forEach(item => {
            if (!arr.includes(item)) {
                arr.push(item);
            }
        });

        return arr
    }

    /**
     * Returns an array of items which are present in array1, but not in array2
     * @param {Array} array1=[]
     * @param {Array} array2=[]
     * @returns {Array}
     */
    static difference(array1=[], array2=[]) {
        return array1.filter(item => !array2.includes(item))
    }

    /**
     * Checks if the item is included by reference inside the array
     * @param {Array} arr
     * @param {*} item
     */
    static hasItem(arr, item) {
        return arr.includes(item)
    }

    /**
     * Inserts an item or Array of items to an array in case it does not already exist.
     * Duplicates will only get matched by reference.
     * @param {Array} arr
     * @param {Number} index
     * @param {*} items
     * @returns {Array}
     */
    static insert(arr, index, items) {
        if (!Array.isArray(items)) {
            items = [items]
        }

        let len = items.length -1,
            i   = len,
            currentIndex, item;

        // Iterate backwards
        for (; i > -1; i--) {
            item = items[i];

            currentIndex = arr.indexOf(item);

            if (index !== currentIndex) {
                if (currentIndex > -1) {
                    this.move(arr, currentIndex, index)
                } else {
                    arr.splice(index, 0, item)
                }
            }
        }

        return arr
    }

    /**
     * Returns an array of items which are present in array1 and array2
     * Only supports primitive items
     * @param {Array} array1=[]
     * @param {Array} array2=[]
     * @returns {Array}
     */
    static intersection(array1=[], array2=[]) {
        return array1.filter(item => array2.includes(item))
    }

    /**
     * Moves an item inside arr from fromIndex to toIndex
     * @param {Array} arr
     * @param {Number} fromIndex
     * @param {Number} toIndex
     */
    static move(arr, fromIndex, toIndex) {
        if (fromIndex === toIndex) {
            return arr
        }

        if (fromIndex >= arr.length) {
            fromIndex = arr.length - 1
        }

        arr.splice(toIndex, 0, arr.splice(fromIndex, 1)[0]);
        return arr
    }

    /**
     * Removes an item or array of items from an array. Only primitive items will get found
     * @param {Array} arr
     * @param {*} items
     */
    static remove(arr, items) {
        let index;

        if (!Array.isArray(items)) {
            items = [items]
        }

        items.forEach(item => {
            index = arr.indexOf(item);

            index > -1 && arr.splice(index, 1)
        });

        return arr
    }

    /**
     * Convenience method to combine add & remove in one call.
     * You can pass single items or an array of items to add or to remove.
     * @param {Array} arr
     * @param {*} removeItems
     * @param {*} addItems
     */
    static removeAdd(arr, removeItems, addItems) {
        this.remove(arr, removeItems);
        return this.add(arr, addItems)
    }

    /**
     * Removes an item from an array in case it does exist, otherwise adds it
     * @param {Array} arr
     * @param {*} item
     * @param {Boolean} [add]
     */
    static toggle(arr, item, add = !this.hasItem(arr, item)) {
        return this[add ? 'add' : 'remove'](arr, item);
    }

    /**
     * Returns an array of items which are present in the passed arrays.
     * Multiple arrays may be passed.
     * Only supports primitive items
     * @returns {Array}
     */
    static union() {
        return [...new Set(Array.prototype.concat(...arguments))]
    }

    /**
     * Adds an item or Array of items to an array in case it does not already exist.
     * Only primitive items will get found as duplicates
     * @param {Array} arr
     * @param {*} items
     */
    static unshift(arr, items) {
        if (!Array.isArray(items)) {
            items = [items]
        }

        items.forEach(item => {
            if (!arr.includes(item)) {
                arr.unshift(item)
            }
        });

        return arr
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(NeoArray));


/***/ }),

/***/ "./src/util/ClassSystem.mjs":
/*!**********************************!*\
  !*** ./src/util/ClassSystem.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.util.ClassSystem
 * @extends Neo.core.Base
 */
class ClassSystem extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.ClassSystem'
         * @protected
         */
        className: 'Neo.util.ClassSystem'
    }

    /**
     * can get used inside beforeSet methods in case you want to create instances like stores
     * @param {Object|Neo.core.Base|null} config
     * @param {Neo.core.Base|String} [DefaultClass=null]
     * @param {Object} [defaultValues={}]
     * @returns {Neo.core.Base} instance
     */
    static beforeSetInstance(config, DefaultClass=null, defaultValues={}) {
        let configType = Neo.typeOf(config);

        if (Neo.isString(DefaultClass)) {
            DefaultClass = Neo.ns(DefaultClass)
        }

        if (!config && DefaultClass) {
            config = Neo.create(DefaultClass, defaultValues)
        } else if (configType === 'NeoClass') {
            config = Neo.create(config, defaultValues)
        } else if (configType === 'Object') {
            if (config.ntype) {
                config = Neo.ntype({
                    ...defaultValues,
                    ...config
                })
            } else {
                let newConfig = {};

                if (DefaultClass) {
                    newConfig.module = DefaultClass
                }

                Object.assign(newConfig, {
                    ...defaultValues,
                    ...config
                });

                config = Neo.create(newConfig)
            }
        } else if (configType === 'NeoInstance') {
            if (defaultValues?.listeners) {
                config.on(defaultValues.listeners)
            }
        }

        return config
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(ClassSystem));


/***/ }),

/***/ "./src/util/Function.mjs":
/*!*******************************!*\
  !*** ./src/util/Function.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bindAppend: () => (/* binding */ bindAppend),
/* harmony export */   buffer: () => (/* binding */ buffer),
/* harmony export */   createInterceptor: () => (/* binding */ createInterceptor),
/* harmony export */   createSequence: () => (/* binding */ createSequence),
/* harmony export */   debounce: () => (/* binding */ debounce),
/* harmony export */   intercept: () => (/* binding */ intercept),
/* harmony export */   resolveCallback: () => (/* binding */ resolveCallback),
/* harmony export */   throttle: () => (/* binding */ throttle),
/* harmony export */   unSequence: () => (/* binding */ unSequence)
/* harmony export */ });
const originalMethodSymbol = Symbol('originalMethod');
const sequencedFnsSymbol   = Symbol('sequencedFns');

/**
 * Append args instead of prepending them
 * @param {Function} fn
 * @param {Object} scope
 * @returns {Function}
 */
function bindAppend(fn, scope) {
    const args = [].slice.call(arguments).slice(2);

    return function() {
        return fn.apply(scope, [].slice.call(arguments).concat(args))
    }
}

/**
 * @param {Function} callback
 * @param {Neo.core.Base} scope
 * @param {Number} delay=300
 * @returns {Function}
 */
function buffer(callback, scope, delay=300) {
    let timeoutId;

    const wrapper = function(...args) {
        // callback invocation comes "delay" ms after the last call to wrapper
        // so cancel any pending invocation.
        clearTimeout(timeoutId);

        wrapper.isPending = true;

        timeoutId = setTimeout(() => {
            timeoutId = 0;
            wrapper.isPending = false;
            callback.apply(scope, args)
        }, delay)
    };

    wrapper.cancel = () => {
        wrapper.isPending = false;
        clearTimeout(timeoutId)
    };

    return wrapper
}

/**
 * Intended for functions with 1 param where the interceptor can change the value
 * @param {Object} target
 * @param {String} targetMethodName
 * @param {Function} interceptFunction
 * @param {Object} scope=target
 * @returns {Function}
 */
function createInterceptor(target, targetMethodName, interceptFunction, scope) {
    let targetMethod = target[targetMethodName];

    return (target[targetMethodName] = function(value) {
        return targetMethod.call(target, interceptFunction.call(scope || target, value))
    })
}

/**
 * @param {Neo.core.Base} target
 * @param {String} methodName
 * @param {Function} fn
 * @param {Object} scope
 * @returns {Function}
 */
function createSequence(target, methodName, fn, scope) {
    let currentMethod = target[methodName],
        wrapper;

    if (currentMethod && currentMethod[sequencedFnsSymbol]) {
        // Already a sequenced method, add to its list
        wrapper = currentMethod;
        wrapper[sequencedFnsSymbol].push({fn, scope})
    } else {
        // First time sequencing this method
        let originalMethod = currentMethod || Neo.emptyFn;

        wrapper = function() {
            originalMethod.apply(this, arguments); // Call the original method

            // Call all sequenced functions
            wrapper[sequencedFnsSymbol].forEach(seqFn => {
                seqFn.fn.apply(seqFn.scope || this, arguments);
            });
        };
        wrapper[sequencedFnsSymbol] = [{fn, scope}];
        wrapper[originalMethodSymbol] = originalMethod; // Store original method
    }

    return (target[methodName] = wrapper);
}

/**
 * @param {Function} callback
 * @param {Neo.core.Base} scope
 * @param {Number} delay=300
 * @returns {Function}
 */
function debounce(callback, scope, delay=300) {
    let debounceTimer;

    return function(...args) {
        // leading edge => trigger the first call right away
        if (!Neo.isNumber(debounceTimer)) {
            // we need to check if the scope (instance) did not get destroyed yet
            scope?.id && callback.apply(scope, args);

            // we still want to start a timer to delay the 2nd+ update
            debounceTimer = setTimeout(() => {debounceTimer = null},  delay)
        } else {
            clearTimeout(debounceTimer);

            debounceTimer = setTimeout(() => {
                // we need to check if the scope (instance) did not get destroyed yet
                scope?.id && callback.apply(scope, args);
                debounceTimer = setTimeout(() => {debounceTimer = null},  delay)
            },  delay)
        }
    }
}

/**
 * The interceptor can prevent the targetMethod from getting executed in case it returns false.
 * @param {Object} target
 * @param {String} targetMethodName
 * @param {Function} interceptFunction
 * @param {Object} scope=target
 * @param {*} preventedReturnValue=null The value to return in case the interceptFunction returns false
 * @returns {Function}
 */
function intercept(target, targetMethodName, interceptFunction, scope, preventedReturnValue=null) {
    let targetMethod = target[targetMethodName];

    return (target[targetMethodName] = function() {
        return (interceptFunction.apply(scope || target, arguments) === false)
            ? preventedReturnValue
            : targetMethod.apply(target, arguments)
    })
}

/**
 * Locate a callable function by name in the passed scope.
 *
 * If the name starts with 'up.', the parent Component chain is searched.
 *
 * This is used by manager.DomEvents & core.Observable.fire and by 'handler' function calls to resolve
 * string function names in the Component's own hierarchy.
 * @param {Function|String} fn A function, or the name of a function to find in the passed scope object/
 * @param {Object} scope=this The scope to find the function in if it is specified as a string.
 * @returns {Object}
 */
function resolveCallback(fn, scope=this) {
    if (Neo.isString(fn)) {
        if (!scope[fn] && fn.startsWith('up.')) {
            fn = fn.slice(3);
            while (!scope[fn] && (scope = scope.parent));
        } else {
            scope = scope.getController?.()?.getHandlerScope(fn, null) || scope
        }

        fn = scope[fn]
    }

    return {fn, scope}
}

/**
 * @param {Function} callback
 * @param {Neo.core.Base} scope
 * @param {Number} delay=300
 * @returns {Function}
 */
function throttle(callback, scope, delay=300) {
    let lastRanDate, timeoutId;

    return function(...args) {
        if (!lastRanDate) {
            // we need to check if the scope (instance) did not get destroyed yet
            scope?.id && callback.apply(scope, args);

            lastRanDate = Date.now()
        } else {
            clearTimeout(timeoutId)

            timeoutId = setTimeout(function() {
                if ((Date.now() - lastRanDate) >= delay) {
                    // we need to check if the scope (instance) did not get destroyed yet
                    scope?.id && callback.apply(scope, args);

                    lastRanDate = Date.now()
                }
            }, delay - (Date.now() - lastRanDate))
        }
    }
}

/**
 * @param {Neo.core.Base} target
 * @param {String} methodName
 * @param {Function} fn
 * @param {Object} scope
 */
function unSequence(target, methodName, fn, scope) {
    let currentMethod = target[methodName];

    if (!currentMethod || !currentMethod[sequencedFnsSymbol]) {
        return // Not a sequenced method
    }

    const sequencedFunctions = currentMethod[sequencedFnsSymbol];

    // Filter out the function to unsequence
    currentMethod[sequencedFnsSymbol] = sequencedFunctions.filter(seqFn =>
        !(seqFn.fn === fn && seqFn.scope === scope)
    );

    if (currentMethod[sequencedFnsSymbol].length === 0) {
        // If no functions left, restore the original method
        target[methodName] = currentMethod[originalMethodSymbol]
    }
}


/***/ }),

/***/ "./src/util/HashHistory.mjs":
/*!**********************************!*\
  !*** ./src/util/HashHistory.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");



/**
 * @class Neo.util.HashHistory
 * @extends Neo.core.Base
 * @mixes Neo.core.Observable
 * @singleton
 */
class HashHistory extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.util.HashHistory'
         * @protected
         */
        className: 'Neo.util.HashHistory',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true,
        /**
         * @member {Number} maxItems=50
         * @protected
         */
        maxItems: 50,
        /**
         * Storing one stack per windowId
         * @member {Object} stacks={}
         * @protected
         */
        stacks: {}
    }

    /**
     * Convenience shortcut
     * @param {Number} [windowId]
     * @returns {Object}
     */
    first(windowId) {
        return this.getAt(0, windowId)
    }

    /**
     * @param {Number} index
     * @param {Number} [windowId]
     * @returns {Number}
     */
    getAt(index, windowId) {
        return this.getStack(windowId)[index]
    }

    /**
     * @param {Number} [windowId]
     * @returns {Number}
     */
    getCount(windowId) {
        return this.getStack(windowId).length
    }

    /**
     * @param {Number} [windowId]
     * @returns {Number}
     */
    getStack(windowId) {
        let me       = this,
            {stacks} = me,
            stackId  = windowId || Object.keys(stacks)[0],
            stack    = stacks[stackId];

        if (!stack) {
            stacks[stackId] = stack = []
        }

        return stack
    }

    /**
     * @param {Object} data
     * @param {String} data.appName
     * @param {Object} data.hash
     * @param {String} data.hashString
     * @param {Number} data.windowId
     */
    push(data) {
        let me         = this,
            {windowId} = data,
            stack      = me.getStack(windowId);

        if (stack[0]?.hashString !== data.hashString) {
            delete data[windowId];
            stack.unshift(data);

            if (stack.length > me.maxItems) {
                stack.pop()
            }

            me.fire('change', data, stack[1] || null)
        }
    }

    /**
     * Convenience shortcut
     * @param {Number} [windowId]
     * @returns {Object}
     */
    second(windowId) {
        return this.getAt(0, windowId)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(HashHistory));


/***/ }),

/***/ "./src/util/Logger.mjs":
/*!*****************************!*\
  !*** ./src/util/Logger.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.util.Logger
 * @extends Neo.core.Base
 * @singleton
 */
class Logger extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.Logger'
         * @protected
         */
        className: 'Neo.util.Logger',
        /**
         * Set the minimum level, which you want to output.
         * Change this at any time using a value of logLevels: ['info', 'log', 'warn', 'error']
         *
         *     Neo.util.Logger.level = 'error'
         *
         * @member {String} level='info'
         * @protected
         */
        level_: 'info',
        /**
         * @member {Boolean} enableLogs=true
         * @protected
         */
        singleton: true
    }

    /**
     * @member {Object} logChar
     */
    logChars  = {
        error: 'E',
        info : 'I',
        log  : 'L',
        warn : 'W'
    }
    /**
     * @member {Object} colors
     */
    logColors = {
        error: 'indianred',
        info : '#acacac',
        log  : '#448888',
        warn : '#6d6d00'
    }
    /**
     * LogLevels
     * @member {String[]} logLevels
     */
    logLevels = ['info', 'log', 'warn', 'error']

    /**
     * @param config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        // aliases
        Neo.applyFromNs(Neo, me, {
            error   : 'error',
            info    : 'info',
            log     : 'log',
            logError: 'logError',
            warn    : 'warn'
        }, true);

        me.timeout(50).then(() => {
            if (!Neo.config.enableLogsInProduction && Neo.config.environment === 'dist/production') {
                me.write = Neo.emptyFn
            }
        })
    }

    /**
     * Set level to number based on position in logLevels
     * @param {String} value
     * @param {String|Number} oldValue
     * @returns {Number}
     */
    beforeSetLevel(value, oldValue) {
        return this.logLevels.indexOf(value)
    }

    /**
     * @param {String} value
     */
    error(value) {
        throw new Error(value)
    }

    /**
     * internal helper to catch caller
     * no known native way in modern JS to know what file that triggered the current method
     * therefore we use Error, we can get the caller file from the stack trace string.
     * @protected
     * @returns {String}
     */
    getCaller() {
        let caller_path = undefined,
            err         = new Error(),
            stack_lines = err.stack.split('\n'),
            found_this  = false,
            i, line;

        for (i in stack_lines) {
            line = stack_lines[i];

            if (!found_this && /Logger\.mjs/.test(line)) {
                found_this = true
            } else if (found_this) {
                if (!/Logger\.mjs/.test(line)) {
                    // remove the closing )
                    line        = line.replace(')', '');
                    // get the part after the last /
                    caller_path = line.match(/([^\/]+)$/)[1].match(/([^ ]+)$/)[1];

                    break
                }
            }
        }

        return caller_path
    }

    /**
     * @param args
     */
    info(...args) {
        args = this.resolveArgs(...args);
        this.write(args, 'info')
    }

    /**
     * @param args
     */
    log(...args) {
        args = this.resolveArgs(...args);
        this.write(args, 'log')
    }

    /**
     * @param args
     */
    logError(...args) {
        args = this.resolveArgs(...args);
        this.write(args, 'error')
    }

    /**
     * @param {Object} data
     */
    onContextMenu(data) {
        let {config} = Neo;

        if (config.enableComponentLogger && !(config.env === 'dist/production' && config.enableLogsInProduction)) {
            let isGroupSet = false,
                component;

            data.path.forEach(item => {
                component = Neo.getComponent(item.id, false);

                if (component) {
                    if (!isGroupSet) {
                        isGroupSet = true;
                        console.group(item.id)
                    }

                    console.log(component)
                }
            });

            isGroupSet && console.groupEnd()
        }
    }

    /**
     * Internal helper for args
     * @param {Array} args
     * @returns {Object}
     * @protected
     */
    resolveArgs(...args) {
        let identifier = args[0],
            argsObject = {};

        if (args.length === 1) {
            if (Neo.isString(identifier)) {
                argsObject.msg = args[0]
            } else if (Neo.isObject(identifier)) {
                argsObject = identifier
            }
        } else if (args.length > 2) {
            argsObject.msg  = args[0];
            argsObject.data = args.slice(1)
        }

        return argsObject
    }

    /**
     * @param args
     */
    warn(...args) {
        args = this.resolveArgs(...args);
        this.write(args, 'warn')
    }

    /**
     * Output method
     * @param {Object} args
     * @param {String} level
     * @protected
     */
    write(args, level) {
        let me = this;

        if (me.beforeSetLevel(level) < me.level) {
            return
        }

        console.log('#', args.msg, level);

        let logColor = me.logColors[level],
            logChar  = me.logChars[level],
            bg       = `background-color:${logColor}; color: white; font-weight: 900;`,
            color    = `color:${logColor};`,
            msg      = `[${me.getCaller()}] ${args.msg}`;

        if (args.data) {
            console.groupCollapsed(`%c ${logChar} %c ${msg}`, bg, color)
            console.log(args.data);
            console.groupEnd()
        } else {
            console.log(`%c ${logChar} %c ${msg}`, bg, color)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Logger));


/***/ }),

/***/ "./src/util/VDom.mjs":
/*!***************************!*\
  !*** ./src/util/VDom.mjs ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../manager/Component.mjs */ "./src/manager/Component.mjs");



/**
 * @class Neo.util.VDom
 * @extends Neo.core.Base
 */
class VDom extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.VDom'
         * @protected
         */
        className: 'Neo.util.VDom'
    }

    /**
     * @param {Object} vdom
     * @param {Boolean} removeIds=true
     * @returns {Object} cloned vdom
     */
    static clone(vdom, removeIds=true) {
        let clone = Neo.clone(vdom, true);

        if (removeIds) {
            delete clone.id
        }

        if (clone.cn) {
            clone.cn.forEach((item, index) => {
                clone.cn[index] = VDom.clone(item, removeIds)
            })
        }

        return clone
    }

    /**
     * Search vdom child nodes by id or opts object for a given vdom tree
     * @param {Object} vdom
     * @param {Object|String} opts Either an object containing vdom node attributes or a string based id
     * @param {Boolean} replaceComponentRefs=true
     * @param {Number} [index] Internal flag, do not use it
     * @param {Object} [parentNode] Internal flag, do not use it
     * @returns {Object}
     *     {Number} index
     *     {String} parentId
     *     {Object} vdom
     */
    static find(vdom, opts, replaceComponentRefs=true, index, parentNode) {
        index = index || 0;
        opts  = !Neo.isString(opts) ? opts : {id: opts};

        if (replaceComponentRefs) {
            vdom = VDom.getVdom(vdom)
        }

        let child      = null,
            matchArray = [],
            styleMatch = true,
            i          = 0,
            len        = vdom.cn?.length,
            optsArray  = Object.entries(opts),
            optsLength = optsArray.length,
            subChild;

        optsArray.forEach(([key, value]) => {
            if (vdom.hasOwnProperty(key)) {
                switch (key) {
                    case 'cls':
                        if (typeof value === 'string' && Neo.isArray(vdom[key])) {
                            if (vdom[key].includes(value)) {
                                matchArray.push(true)
                            }
                        } else if (typeof value === 'string' && typeof vdom[key] === 'string') {
                            if (vdom[key] === value) {
                                matchArray.push(true)
                            }
                        } else if (Neo.isArray(value) && Neo.isArray(vdom[key])) {
                            // todo: either search the vdom array for all keys or compare if the arrays are equal.
                            throw new Error('find: cls matching not supported for target & source types of Arrays')
                        }
                        break
                    case 'style':
                        if (typeof value === 'string' && typeof vdom[key] === 'string') {
                            if (vdom[key] === value) {
                                matchArray.push(true)
                            }
                        } else if (Neo.isObject(value) && Neo.isObject(vdom[key])) {
                            Object.entries(value).forEach(([styleKey, styleValue]) => {
                                if (!(vdom[key].hasOwnProperty(styleKey) && vdom[key][styleKey] === styleValue)) {
                                    styleMatch = false
                                }
                            });

                            if (styleMatch) {
                                matchArray.push(true)
                            }
                        } else {
                            throw new Error('find: style matching not supported for mixed target & source types (Object VS String)')
                        }
                        break
                    default:
                        if (vdom[key] === value) {
                            matchArray.push(true)
                        }
                        break
                }
            }
        });

        if (matchArray.length === optsLength) {
            return {index, parentNode, vdom}
        }

        if (vdom.cn) {
            for (; i < len; i++) {
                if (vdom.cn[i]) {
                    subChild = VDom.find(vdom.cn[i], opts, replaceComponentRefs, i, vdom);

                    if (subChild) {
                        child = {
                            index     : subChild.index,
                            parentNode: subChild.parentNode,
                            vdom      : subChild.vdom
                        };
                        break
                    }
                }
            }
        }

        return child
    }

    /**
     * Convenience shortcut for find(vdom, {flag: flag});
     * @param {Object} vdom
     * @param {String} flag The flag reference specified on the target vdom child node
     * @returns {Object} vdom
     */
    static getByFlag(vdom, flag) {
        return VDom.find(vdom, {flag})?.vdom
    }

    /**
     * Get the ids of all child nodes of the given vdom tree
     * @param vdom
     * @param [childIds=[]]
     * @returns {Array} childIds
     */
    static getChildIds(vdom, childIds=[]) {
        vdom = VDom.getVdom(vdom);

        let childNodes = vdom?.cn || [];

        childNodes.forEach(childNode => {
            if (childNode.id) {
                childIds.push(childNode.id)
            }

            childIds = VDom.getChildIds(childNode, childIds)
        });

        return childIds
    }

    /**
     * @param {Object} vdom
     * @param {Number} index
     * @returns {Array}
     */
    static getColumnNodes(vdom, index) {
        vdom = VDom.getVdom(vdom);

        let columnNodes = [];

        vdom.cn?.forEach(row => {
            if (row.cn?.[index]) {
                columnNodes.push(row.cn[index])
            }
        })

        return columnNodes
    }

    /**
     * @param {Object} vdom
     * @param {Number} index
     * @returns {Array}
     */
    static getColumnNodesIds(vdom, index) {
        return VDom.getColumnNodes(vdom, index).map(e => e.id)
    }

    /**
     * @param {Object} vdom
     * @param {String} flag
     * @param {Array} [matchArray]
     * @returns {Array} an array of vdom nodes which match the flag
     */
    static getFlags(vdom, flag, matchArray) {
        vdom = VDom.getVdom(vdom);

        if (!matchArray) {
            matchArray = [];

            if (vdom.flag === flag) {
                matchArray.push(vdom)
            }
        }

        (vdom?.cn || []).forEach(childNode => {
            if (childNode.flag === flag) {
                matchArray.push(childNode)
            }

            matchArray = VDom.getFlags(childNode, flag, matchArray)
        });

        return matchArray
    }

    /**
     * @param {Object} vdom
     * @param {String} id
     * @param {Boolean} topLevel=true Internal flag, do not use it
     * @returns {Array}
     */
    static getParentNodes(vdom, id, topLevel=true) {
        vdom = VDom.getVdom(vdom);

        let parents = null,
            i       = 0,
            len     = vdom.cn?.length || 0;

        if (vdom.id === id) {
            return []
        }

        for (; i < len; i++) {
            parents = VDom.getParentNodes(vdom.cn[i], id, false);

            if (parents) {
                parents.push(vdom.cn[i]);
                break
            }
        }

        if (topLevel && parents) {
            parents.push(vdom)
        }

        return parents
    }

    /**
     * Convenience shortcut using manager.Component to replace vdom references if needed
     * @param {Object} vdom
     * @returns {Object}
     */
    static getVdom(vdom) {
        if (vdom.componentId) {
            const component = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].get(vdom.componentId);

            if (!component) {
                throw new Error(`util.VDom.getVdom: Component not found for id: ${vdom.componentId}`)
            }

            vdom = component.vdom
        }

        return vdom
    }

    /**
     * Insert a given nodeToInsert after a targetNode inside a given vdom tree
     * @param {Object} vdom The vdom tree containing the targetNode
     * @param {Object} nodeToInsert The new vdom to insert
     * @param {Object|String} targetNodeId Either a vdom node or a vdom node id
     * @returns {Boolean}
     */
    static insertAfterNode(vdom, nodeToInsert, targetNodeId) {
        return VDom.insertNode(vdom, nodeToInsert, targetNodeId, false)
    }

    /**
     * Insert a given nodeToInsert before a targetNode inside a given vdom tree
     * @param {Object} vdom The vdom tree containing the targetNode
     * @param {Object} nodeToInsert The new vdom to insert
     * @param {Object|String} targetNodeId Either a vdom node or a vdom node id
     * @returns {Boolean}
     */
    static insertBeforeNode(vdom, nodeToInsert, targetNodeId) {
        return VDom.insertNode(vdom, nodeToInsert, targetNodeId, true)
    }

    /**
     * Insert a given nodeToInsert before a targetNode inside a given vdom tree
     * @param {Object} vdom The vdom tree containing the targetNode
     * @param {Object} nodeToInsert The new vdom to insert
     * @param {Object|String} targetNodeId Either a vdom node or a vdom node id
     * @param {Boolean} insertBefore true inserts the new node at the same index, index+1 otherwise
     * @returns {Boolean}
     */
    static insertNode(vdom, nodeToInsert, targetNodeId, insertBefore) {
        if (Neo.isObject(targetNodeId)) {
            targetNodeId = targetNodeId.id
        }

        let targetNode = VDom.find(vdom, targetNodeId),
            index;

        if (targetNode) {
            index = insertBefore ? targetNode.index : targetNode.index + 1;
            targetNode.parentNode.cn.splice(index, 0, nodeToInsert);
            return true
        }

        return false
    }

    /**
     * Search vdom child nodes by id or opts object for a given vdom tree
     * @param {Object} [vdom]
     * @param {Object|String} opts Either an object containing vdom node attributes or a string based id
     * @returns {Boolean} true in case the node was found & removed
     */
    static removeVdomChild(vdom, opts) {
        let child = VDom.find(vdom, opts);

        if (child) {
            child.parentNode.cn.splice(child.index, 1);
            return true
        }

        return false
    }

    /**
     * Replaces a child node inside a vdom tree by a given id
     * @param {Object} vdom
     * @param {String} id
     * @param {Object} newChildNode
     * @returns {Boolean} true in case the node was found and replaced
     */
    static replaceVdomChild(vdom, id, newChildNode) {
        vdom = VDom.getVdom(vdom);

        let cn  = vdom.cn || [],
            i   = 0,
            len = cn.length,
            childNode;

        if (vdom.id === id) {
            throw new Error('replaceVdomChild: target id matches the root vnode id: ' + id)
        }

        for (; i < len; i++) {
            childNode = cn[i];

            if (childNode.id === id) {
                cn[i] = newChildNode;
                return true
            }

            if (VDom.replaceVdomChild(childNode, id, newChildNode)) {
                return true
            }
        }

        return false;
    }

    /**
     * Neo.vdom.Helper will create ids for each vnode which does not already have one,
     * so we need to sync them into the vdom.
     * @param {Neo.vdom.VNode} vnode
     * @param {Object} vdom
     * @param {Boolean} force=false The force param will enforce overwriting different ids
     */
    static syncVdomIds(vnode, vdom, force=false) {
        if (vnode && vdom) {
            vdom = VDom.getVdom(vdom);

            let childNodes = vdom.cn,
                cn, i, len;

            if (force) {
                if (vnode.id && vdom.id !== vnode.id) {
                    vdom.id = vnode.id
                }
            } else {
                // We only want to add an ID if the vdom node does not already have one.
                // This preserves developer-provided IDs while allowing the framework
                // to assign IDs to nodes that need them for reconciliation.
                // Also think of adding and removing nodes in parallel.
                if (vnode.id && (!vdom.id || vdom.id.startsWith('neo-vnode-'))) {
                    vdom.id = vnode.id
                }
            }

            if (childNodes) {
                cn  = childNodes.map(item => VDom.getVdom(item));
                // The vnode.childNodes array is already filtered by the worker.
                // We must filter the component's vdom.cn array identically to ensure
                // both arrays are structurally aligned for the sync loop.
                // The boolean check `item &&` is critical to remove falsy values
                // from conditional rendering and prevent runtime errors.
                cn  = cn.filter(item => item && item.removeDom !== true);
                i   = 0;
                len = cn?.length || 0;

                for (; i < len; i++) {
                    if (vnode.childNodes) {
                        VDom.syncVdomIds(vnode.childNodes[i], cn[i], force)
                    }
                }
            }
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(VDom));


/***/ }),

/***/ "./src/util/VNode.mjs":
/*!****************************!*\
  !*** ./src/util/VNode.mjs ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../manager/Component.mjs */ "./src/manager/Component.mjs");



/**
 * @class Neo.util.VNode
 * @extends Neo.core.Base
 */
class VNode extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.VNode'
         * @protected
         */
        className: 'Neo.util.VNode'
    }

    /**
     * Search vnode child nodes by id or opts object for a given vdom tree
     * @param {Object} vnode
     * @param {Object|String} opts Either an object containing vdom node attributes or a string based id
     * @param {Number} [index] Internal flag, do not use it
     * @param {Object} [parentNode] Internal flag, do not use it
     * @returns {Object}
     *     {Number} index
     *     {String} parentId
     *     {Object} vnode
     */
    static find(vnode, opts, index, parentNode) {
        vnode = VNode.getVnode(vnode);

        index = index || 0;
        opts  = typeof opts !== 'string' ? opts : {id: opts};

        let attrMatch  = true,
            matchArray = [],
            styleMatch = true,
            i          = 0,
            len        = vnode.childNodes?.length || 0,
            optsArray, optsLength, subChild;

        optsArray  = Object.entries(opts);
        optsLength = optsArray.length;

        optsArray.forEach(([key, value]) => {
            if (vnode.hasOwnProperty(key)) {
                switch (key) {
                    case 'attributes':
                        if (Neo.isObject(value) && Neo.isObject(vnode[key])) {
                            Object.entries(value).forEach(([attrKey, attrValue]) => {
                                if (!(vnode[key].hasOwnProperty(attrKey) && vnode[key][attrKey] === attrValue)) {
                                    attrMatch = false
                                }
                            });

                            if (attrMatch) {
                                matchArray.push(true)
                            }
                        }
                        break
                    case 'className':
                        if (typeof value === 'string' && Neo.isArray(vnode[key])) {
                            if (vnode[key].includes(value)) {
                                matchArray.push(true)
                            }
                        } else if (typeof value === 'string' && typeof vnode[key] === 'string') {
                            if (vnode[key] === value) {
                                matchArray.push(true)
                            }
                        } else if (Neo.isArray(value) && Neo.isArray(vnode[key])) {
                            // todo: either search the vnode array for all keys or compare if the arrays are equal.
                            throw new Error('find: cls matching not supported for target & source types of Arrays')
                        }
                        break
                    case 'style':
                        if (Neo.isObject(value) && Neo.isObject(vnode[key])) {
                            Object.entries(value).forEach(([styleKey, styleValue]) => {
                                if (!(vnode[key].hasOwnProperty(styleKey) && vnode[key][styleKey] === styleValue)) {
                                    styleMatch = false
                                }
                            });

                            if (styleMatch) {
                                matchArray.push(true)
                            }
                        }
                        break
                    default:
                        if (vnode[key] === value) {
                            matchArray.push(true)
                        }
                        break
                }
            }
        });

        if (matchArray.length === optsLength) {
            return {index, parentNode, vnode}
        }

        for (; i < len; i++) {
            subChild = VNode.find(vnode.childNodes[i], opts, i, vnode);

            if (subChild) {
                return subChild
            }
        }

        return null
    }

    /**
     * Finds a child vnode inside a vnode tree by a given id
     * @param {Object} vnode
     * @param {String|null} id
     * @returns {Object|null} child vnode or null
     */
    static getById(vnode, id) {
        vnode = VNode.getVnode(vnode);

        let childNodes = vnode.childNodes || [],
            i          = 0,
            len        = childNodes.length,
            childNode;

        if (vnode.id === id) {
            return vnode
        }

        for (; i < len; i++) {
            childNode = VNode.getVnode(childNodes[i]);

            if (childNode.id === id) {
                return childNode
            }

            childNode = VNode.getById(childNode, id);

            if (childNode) {
                return childNode
            }
        }

        return null
    }

    /**
     * Get the ids of all child nodes of the given vnode, excluding component references
     * @param {Object} vnode
     * @param {String[]} childIds=[]
     * @returns {String[]} childIds
     */
    static getChildIds(vnode, childIds=[]) {
        vnode?.childNodes?.forEach(childNode => {
            if (childNode.id && !childNode.componentId) {
                childIds.push(childNode.id)
            }

            VNode.getChildIds(childNode, childIds)
        });

        return childIds
    }

    /**
     * Convenience shortcut using manager.Component to replace vnode references if needed
     * @param {Object} vnode
     * @returns {Object}
     */
    static getVnode(vnode) {
        if (vnode.componentId) {
            const component = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].get(vnode.componentId);

            if (!component) {
                throw new Error(`util.VNode.getVnode: Component not found for id: ${vnode.componentId}`)
            }

            vnode = component.vnode
        }

        return vnode
    }

    /**
     * Removes a child vnode inside a vnode tree by a given id
     * @param {Object} vnode
     * @param {String} id
     * @returns {Boolean} true in case the node was found and removed
     */
    static removeChildVnode(vnode, id) {
        vnode = VNode.getVnode(vnode);

        let childNodes = vnode.childNodes || [],
            i          = 0,
            len        = childNodes.length,
            childNode;

        if (vnode.id === id) {
            throw new Error('removeChildVnode: target id matches the root vnode id: ' + id)
        }

        for (; i < len; i++) {
            childNode = VNode.getVnode(childNodes[i]);

            if (childNode.id === id) {
                childNodes.splice(i, 1);
                return true
            }

            if (VNode.removeChildVnode(childNode, id)) {
                return true
            }
        }

        return false
    }

    /**
     * Replaces a child vnode inside a vnode tree by a given id
     * @param {Object} vnode
     * @param {String} id
     * @param {Object} newChildVnode
     * @returns {Boolean} true in case the node was found and replaced
     */
    static replaceChildVnode(vnode, id, newChildVnode) {
        vnode = VNode.getVnode(vnode);

        let childNodes = vnode.childNodes || [],
            i          = 0,
            len        = childNodes.length,
            childNode;

        if (vnode.id === id) {
            throw new Error('replaceChildVnode: target id matches the root vnode id: ' + id)
        }

        for (; i < len; i++) {
            childNode = VNode.getVnode(childNodes[i]);

            if (childNode.id === id) {
                childNodes[i] = newChildVnode;
                return true
            }

            if (VNode.replaceChildVnode(childNode, id, newChildVnode)) {
                return true
            }
        }

        return false
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(VNode));


/***/ }),

/***/ "./src/worker/Base.mjs":
/*!*****************************!*\
  !*** ./src/worker/Base.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _core_export_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/_export.mjs */ "./src/core/_export.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _manager_ClassHierarchy_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../manager/ClassHierarchy.mjs */ "./src/manager/ClassHierarchy.mjs");
/* harmony import */ var _Message_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Message.mjs */ "./src/worker/Message.mjs");
/* harmony import */ var _mixin_RemoteMethodAccess_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mixin/RemoteMethodAccess.mjs */ "./src/worker/mixin/RemoteMethodAccess.mjs");







/**
 * The abstract base class for e.g. the App, Data & VDom worker
 * @class Neo.worker.Base
 * @extends Neo.core.Base
 * @mixes Neo.core.Observable
 * @mixes Neo.worker.mixin.RemoteMethodAccess
 * @abstract
 */
class Worker extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.worker.Base'
         * @protected
         */
        className: 'Neo.worker.Base',
        /**
         * @member {String[]|Neo.core.Base[]|null} mixins=[Observable,RemoteMethodAccess]
         */
        mixins: [_core_Observable_mjs__WEBPACK_IMPORTED_MODULE_2__["default"], _mixin_RemoteMethodAccess_mjs__WEBPACK_IMPORTED_MODULE_5__["default"]]
    }

    /**
     * @member {Object|null} channelPorts=null
     * @protected
     */
    channelPorts = null
    /**
     * Only needed for SharedWorkers
     * @member {Boolean} isConnected=false
     * @protected
     */
    isConnected = false
    /**
     * @member {Boolean} isSharedWorker=false
     * @protected
     */
    isSharedWorker = false
    /**
     * Only needed for SharedWorkers
     * @member {Array|null} ports=null
     */
    ports = null
    /**
     * @member {String|null} workerId=null
     * @protected
     */
    workerId = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this,
            gt = globalThis;

        Object.assign(me, {
            channelPorts  : {},
            isSharedWorker: gt.toString() === '[object SharedWorkerGlobalScope]',
            ports         : [],
            promises      : {}
        });

        if (me.isSharedWorker) {
            gt.onconnect = me.onConnected.bind(me)
        } else {
            gt.onmessage = me.onMessage.bind(me)
        }

        Neo.currentWorker   = me;
        Neo.setGlobalConfig = me.setGlobalConfig.bind(me);
        Neo.workerId        = me.workerId
    }

    /**
     * Entry point for dedicated and shared workers
     */
    afterConnect() {}

    /**
     * @param {Object} opts
     * @returns {Object|null}
     */
    getPort(opts) {
        let returnPort = null,
            hasMatch;

        this.ports.forEach(port => {
            hasMatch = true;

            Object.entries(opts).forEach(([key, value]) => {
                if (value !== port[key]) {
                    hasMatch = false
                }
            });

            if (hasMatch) {
                returnPort = port
            }
        });

        return returnPort
    }

    /**
     * Only relevant for SharedWorkers
     * @param {Object} data
     */
    async onConnect(data) {
        // short delay to ensure app VCs are in place
        await this.timeout(10);

        let {appName, windowId} = data;
        this.fire('connect', {appName, windowId})
    }

    /**
     * Only relevant for SharedWorkers
     * @param {Object} e
     */
    onConnected(e) {
        let me = this,
            id = Neo.getId('port');

        me.isConnected = true;

        me.ports.push({
            appName : null,
            id,
            port    : e.ports[0],
            windowId: null
        });

        me.ports[me.ports.length - 1].port.onmessage = me.onMessage.bind(me);

        // core.Base: initRemote() subscribes to this event for the SharedWorkers context
        me.fire('connected');

        me.sendMessage('main', {action: 'workerConstructed', port: id});

        me.afterConnect()
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me = this;

        if (!me.isSharedWorker) {
            me.sendMessage('main', {action: 'workerConstructed'});
            me.afterConnect()
        }
    }

    /**
     * Only relevant for SharedWorkers
     * @param {Object} data
     */
    onDisconnect(data) {
        let {appName, windowId} = data;
        this.fire('disconnect', {appName, windowId})
    }

    /**
     * @param {Object} e
     */
    onMessage(e) {
        let me                = this,
            {data}            = e,
            {action, replyId} = data,
            promise;

        if (!action) {
            throw new Error('Message action is missing: ' + data.id)
        }

        if (action !== 'reply') {
            me['on' + Neo.capitalize(action)](data);
        } else if (promise = action === 'reply' && me.promises[replyId]) {
            if (data.reject) {
                promise.reject(data.data)
            } else {
                promise.resolve(data.data)
            }

            delete me.promises[replyId]
        }
    }

    /**
     * @param {Object} msg
     */
    onPing(msg) {
        this.resolve(msg, {originMsg: msg})
    }

    /**
     * Only relevant for SharedWorkers
     * @param {Object} msg
     * @param {String} msg.appName
     */
    onRegisterApp(msg) {
        let me        = this,
            {appName} = msg,
            port;

        for (port of me.ports) {
            if (!port.appName) {
                port.appName = appName;
                me.onConnect({appName, windowId: port.windowId});
                break
            }
        }
    }

    /**
     * Handles the initial registration of the `Neo.config` for this worker's realm.
     * Triggered when receiving a worker message with `{action: 'registerNeoConfig'}` from the Main Thread's `Neo.worker.Manager`.
     * This method is primarily responsible for setting the initial global `Neo.config` object in this worker's scope
     * upon its creation. It also handles associating `windowId` with `MessagePort`s for Shared Workers.
     *
     * @param {Object} msg The incoming message object.
     * @param {Object} msg.data The initial global Neo.config data object.
     * @param {Number} msg.data.windowId The unique ID of the window/tab (relevant for SharedWorkers).
     */
    onRegisterNeoConfig(msg) {
        Neo.ns('Neo.config', true);

        let me         = this,
            {windowId} = msg.data,
            port;

        for (port of me.ports) {
            if (!port.windowId) {
                port.windowId = windowId;
                break
            }
        }

        Neo.merge(Neo.config, msg.data)
    }

    /**
     * Handles runtime updates to the global `Neo.config` for this worker's realm.
     * This method is triggered when receiving a worker message with `{action: 'setNeoConfig'}`
     * from the Main Thread's `Neo.worker.Manager`. This message signifies a global config change
     * that originated either from this worker's Main Thread or was broadcast from another
     * connected browser window via a Shared Worker.
     *
     * It merges the incoming configuration changes into this worker's local `Neo.config`
     * and fires a local `neoConfigChange` event, allowing other instances within this worker
     * to react to the updated configuration.
     *
     * @param {Object} msg The destructured arguments from the message payload.
     * @param {Object} msg.config The partial or full `Neo.config` object to merge.
     */
    onSetNeoConfig({config}) {
        let me = this;

        Neo.merge(Neo.config, config);

        me.fire('neoConfigChange', config)
    }

    /**
     * @param {String} dest app, data, main or vdom (excluding the current worker)
     * @param {Object} opts configs for Neo.worker.Message
     * @param {Array} [transfer] An optional array of Transferable objects to transfer ownership of.
     * If the ownership of an object is transferred, it becomes unusable (neutered) in the context it was sent from
     * and becomes available only to the worker it was sent to.
     * @returns {Promise<any>}
     */
    promiseMessage(dest, opts, transfer) {
        let me = this;

        return new Promise(function(resolve, reject) {
            let message = me.sendMessage(dest, opts, transfer),
                msgId   = message?.id;

            if (!msgId) {
                // a window got closed and the message port no longer exist (SharedWorkers)
                reject()
            } else {
                me.promises[msgId] = {reject, resolve}
            }
        })
    }

    /**
     * @param {String} dest app, canvas, data, main or vdom (excluding the current worker)
     * @param {Object} opts configs for Neo.worker.Message
     * @param {Array} [transfer] An optional array of Transferable objects to transfer ownership of.
     * If the ownership of an object is transferred, it becomes unusable (neutered) in the context it was sent from
     * and becomes available only to the worker it was sent to.
     * @returns {Neo.worker.Message}
     * @protected
     */
    sendMessage(dest, opts, transfer) {
        opts.destination = dest;

        let me = this,
            message, port, portObject;

        if (me.channelPorts[dest]) {
            port = me.channelPorts[dest]
        } else if (!me.isSharedWorker) {
            port = globalThis
        } else {
            if (opts.port) {
                port = me.getPort({id: opts.port}).port
            } else if (opts.windowId) {
                portObject = me.getPort({windowId: opts.windowId});
                port       = portObject?.port;

                opts.port = portObject?.id
            }  else if (opts.appName) {
                portObject = me.getPort({appName: opts.appName});
                port       = portObject?.port;

                opts.port = portObject?.id
            } else {
                port = me.ports[0].port
            }
        }

        if (port) {
            message = new _Message_mjs__WEBPACK_IMPORTED_MODULE_4__["default"](opts);
            port.postMessage(message, transfer);
        }

        return message
    }

    /**
     * Initiates a global Neo.config change from a worker's context.
     * This method is exposed globally as `Neo.setGlobalConfig` within each worker realm.
     *
     * It orchestrates the propagation of the config change to the Main Thread
     * and, if a Shared Worker is active, across all connected browser windows,
     * ensuring a single, consistent Neo.config state everywhere.
     *
     * You can pass a partial config object to update specific keys.
     * For nested objects, Neo.mjs performs a deep merge.
     *
     * @param {Object} config The partial or full Neo.config object with changes to apply.
     */
    setGlobalConfig(config) {
        const
            me        = this,
            {Manager} = Neo.worker; // Remote access proxy object

        // Apply the config change locally to this worker's Neo.config and
        // trigger its local change events immediately. This ensures immediate
        // feedback and an updated state for the worker that initiated the change.
        me.onSetNeoConfig({config});

        if (me.isSharedWorker) {
            // This block executes when the calling worker instance is a Shared Worker.
            // This happens if `Neo.config.useSharedWorkers` is true, meaning App, VDom,
            // Data, Canvas, and Task workers are all SharedWorker instances.
            // This Shared Worker (the one where setGlobalConfig was called) acts as the
            // central point to inform all connected Main Threads (browser windows).
            me.ports.forEach((port, index) => {
                // Send the config change to each connected Main Thread.
                // The `broadcast` flag is crucial here for the *receiving* Main Thread:
                // - `broadcast: true` (for the first port/Main Thread in the list): This Main Thread
                //   will apply the config locally and is then responsible for propagating it to *all*
                //   its own associated Shared Workers connected to that Main Thread),
                //   **excluding the worker that originated this change**.
                // - `broadcast: false` (for all other ports/Main Threads): These Main Threads
                //   will simply apply the config locally and stop. They are passive recipients
                //   of the broadcast, synchronizing their state without initiating further actions back.
                // The `excludeOrigin` parameter ensures the originating worker doesn't receive a redundant broadcast.
                Manager.setNeoConfig({broadcast: index < 1, config, excludeOrigin: me.workerId, windowId: port.windowId})
            })
        } else {
            // This Dedicated Worker (the one where setGlobalConfig was called) informs
            // its single, connected Main Thread. The Main Thread will then:
            // 1. Apply the config locally.
            // 2. Broadcast this change to *all* other Dedicated Workers connected to
            //    *that same Main Thread*, **excluding the sender worker itself**.
            Manager.setNeoConfig({broadcast: true, config, excludeOrigin: me.workerId})
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Worker));


/***/ }),

/***/ "./src/worker/Message.mjs":
/*!********************************!*\
  !*** ./src/worker/Message.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/IdGenerator.mjs */ "./src/core/IdGenerator.mjs");


/**
 * A wrapper for worker post messages sent between the App, Data, VDom worker & the main thread.
 * You can add optional params as needed.
 * @class Neo.worker.Message
 */
class Message {
    /**
     * @param {Object} config
     */
    constructor(config) {
        /**
         * @member {String} action
         */

        /**
         * @member {String} destination='main'
         */

        /**
         * @member {String} id=IdGenerator.getId(Neo.workerId)
         */

        /**
         * @member {String} origin=Neo.workerId
         */

        config.destination = config.destination || 'main';
        config.id          = config.id          || _core_IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getId(Neo.workerId);
        config.origin      = config.origin      || Neo.workerId;

        Object.assign(this, config)
    }
}

const ns = Neo.ns('Neo.worker', true);
ns['Message'] = Message;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Message);


/***/ }),

/***/ "./src/worker/mixin/RemoteMethodAccess.mjs":
/*!*************************************************!*\
  !*** ./src/worker/mixin/RemoteMethodAccess.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.worker.mixin.RemoteMethodAccess
 * @extends Neo.core.Base
 */
class RemoteMethodAccess extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.worker.mixin.RemoteMethodAccess'
         * @protected
         */
        className: 'Neo.worker.mixin.RemoteMethodAccess'
    }

    /**
     * @param {Object} source
     * @param {Object} target
     */
    assignPort(source, target) {
        if (source) {
            const {appName, port, windowId} = source;
            Object.assign(target, {appName, port, windowId})
        }
    }

    /**
     * @param {Object} remote
     * @param method
     * @returns {function(*=, *=): Promise<any>}
     */
    generateRemote(remote, method) {
        let me       = this,
            {origin} = remote;

        return function(data, buffer) {
            let opts = {
                action         : 'remoteMethod',
                data,
                destination    : origin,
                remoteClassName: remote.className,
                remoteMethod   : method
            };

            me.isSharedWorker && me.assignPort(data, opts);

            return me.promiseMessage(origin, opts, buffer)
        }
    }

    /**
     * @param {Object} remote
     */
    onRegisterRemote(remote) {
        if (remote.destination === Neo.workerId) {
            let me                   = this,
                {className, methods} = remote,
                pkg                  = Neo.ns(className, true);

            methods.forEach(method => {
                if (remote.origin !== 'main' && pkg[method]) {
                    throw new Error('Duplicate remote method definition ' + className + '.' + method)
                }

                pkg[method] ??= me.generateRemote(remote, method)
            })
        }
    }

    /**
     * @param {Object} msg
     */
    onRemoteMethod(msg) {
        let me  = this,
            pkg = Neo.ns(msg.remoteClassName),
            out, method;

        if (!pkg) {
            throw new Error('Invalid remote namespace "' + msg.remoteClassName + '"')
        }

        method = pkg[msg.remoteMethod];

        if (!method) {
            throw new Error('Invalid remote method name "' + msg.remoteMethod + '"')
        }

        // Check for interception
        if (!pkg.isReady && pkg.interceptRemotes?.includes(msg.remoteMethod)) {
            out = pkg.onInterceptRemotes(msg);
        } else if (Array.isArray(msg.data)) {
            out = method.call(pkg, ...msg.data)
        } else {
            out = method.call(pkg, msg.data)
        }

        if (Neo.isPromise(out)) {
            out
                /*
                 * Intended logic:
                 * If the code of a remote method fails, it would not show any errors inside the console,
                 * so we want to manually log the error for debugging.
                 * Rejecting the Promise gives us the chance to recover.
                 *
                 * Example:
                 * Neo.vdom.Helper.update(opts).catch(err => {
                 *     me.isVdomUpdating = false;
                 *     reject?.()
                 * }).then(data => {...})
                 */
                .catch(err => {console.error(err); me.reject(msg, err)})
                .then(data => {me.resolve(msg, data)})
        } else {
            me.resolve(msg, out)
        }
    }

    /**
     * Gets called when promiseMessage gets rejected
     * @param {Object} msg
     * @param {Object} data
     */
    reject(msg, data) {
        let me = this,

        opts = {
            action : 'reply',
            data,
            reject : true,
            replyId: msg.id
        };

        me.isSharedWorker && me.assignPort(msg, opts);
        me.sendMessage(msg.origin, opts)
    }

    /**
     * Gets called when promiseMessage gets resolved
     * @param {Object} msg
     * @param {Object} data
     */
    resolve(msg, data) {
        let me = this,

        opts = {
            action : 'reply',
            data,
            replyId: msg.id
        };

        me.isSharedWorker && me.assignPort(msg, opts);
        me.sendMessage(msg.origin, opts)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(RemoteMethodAccess));


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "chunks/app/" + chunkId + ".js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/^blob:/, "").replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/importScripts chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "already loaded"
/******/ 		var installedChunks = {
/******/ 			"app": 1
/******/ 		};
/******/ 		
/******/ 		// importScripts chunk loading
/******/ 		var installChunk = (data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			while(chunkIds.length)
/******/ 				installedChunks[chunkIds.pop()] = 1;
/******/ 			parentChunkLoadingFunction(data);
/******/ 		};
/******/ 		__webpack_require__.f.i = (chunkId, promises) => {
/******/ 			// "1" is the signal for "already loaded"
/******/ 			if(!installedChunks[chunkId]) {
/******/ 				if(true) { // all chunks have JS
/******/ 					importScripts(__webpack_require__.p + __webpack_require__.u(chunkId));
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || [];
/******/ 		var parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);
/******/ 		chunkLoadingGlobal.push = installChunk;
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
/*!****************************!*\
  !*** ./src/worker/App.mjs ***!
  \****************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Neo.mjs */ "./src/Neo.mjs");
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Base.mjs */ "./src/worker/Base.mjs");
/* harmony import */ var _controller_Application_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../controller/Application.mjs */ "./src/controller/Application.mjs");
/* harmony import */ var _manager_Instance_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../manager/Instance.mjs */ "./src/manager/Instance.mjs");
/* harmony import */ var _manager_DomEvent_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../manager/DomEvent.mjs */ "./src/manager/DomEvent.mjs");
/* harmony import */ var _util_HashHistory_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/HashHistory.mjs */ "./src/util/HashHistory.mjs");







/**
 * The App worker contains most parts of the framework as well as all apps which get created.
 * See the tutorials for further infos.
 * @class Neo.worker.App
 * @extends Neo.worker.Base
 * @singleton
 */
class App extends _Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.worker.App'
         * @protected
         */
        className: 'Neo.worker.App',
        /**
         * @member {Number} countLoadingThemeFiles_=0
         * @reactive
         */
        countLoadingThemeFiles_: 0,
        /**
         * Remote method access for other workers
         * @member {Object} remote
         * @protected
         */
        remote: {
            main: [
                'createNeoInstance',
                'destroyNeoInstance',
                'fireEvent',
                'getConfigs',
                'setConfigs',
                'setGlobalConfig' // points to worker.Base: setGlobalConfig()
            ]
        },
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * We are storing the params of insertThemeFiles() calls here, in case the method does get triggered
     * before the json theme structure got loaded.
     * @member {Array[]} themeFilesCache=[]
     * @protected
     */
    themeFilesCache = []
    /**
     * @member {String} workerId='app'
     * @protected
     */
    workerId = 'app'

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        // convenience shortcuts
        _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].applyDeltas    = me.applyDeltas   .bind(me);
        _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].setCssVariable = me.setCssVariable.bind(me)
    }

    /**
     * Triggered after the countLoadingThemeFiles config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetCountLoadingThemeFiles(value, oldValue) {
        if (value === 0 && oldValue !== undefined) {
            this.fire('themeFilesLoaded')
        }
    }

    /**
     * @param {String} appName
     * @param {Array|Object} deltas
     * @returns {Promise<*>}
     */
    applyDeltas(appName, deltas) {
         return this.promiseMessage('main', {action: 'updateDom', appName, deltas})
    }

    /**
     * Remote method to use inside main threads for creating neo based class instances.
     * Be aware that you can only pass configs which can get converted into pure JSON.
     *
     * Mounting a component into the document.body
     * @example:
     *     Neo.worker.App.createNeoInstance({
     *         ntype        : 'button',
     *         autoInitVnode: true,
     *         autoMount    : true,
     *         text         : 'Hi Nige!'
     *     }).then(id => console.log(id))
     *
     * Inserting a component into a container
     * @example:
     *     Neo.worker.App.createNeoInstance({
     *         ntype      : 'button',
     *         parentId   : 'neo-container-3',
     *         parentIndex: 0
     *         text       : 'Hi Nige!'
     *     }).then(id => console.log(id))
     *
     * @param {Object} config
     * @param {String} [config.importPath] you can lazy load missing classes via this config. dev mode only.
     * @param {String} [config.parentId] passing a parentId will put your instance into a container
     * @param {Number} [config.parentIndex] if a parentId is passed, but no index, neo will use add()
     * @returns {String} the instance id
     */
    async createNeoInstance(config) {
        if (config.importPath) {
            await import(/* webpackIgnore: true */ config.importPath);
            delete config.importPath
        }

        let appName   = Object.keys(_Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].apps)[0], // fallback in case no appName was provided
            Container = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].container?.Base,
            index, instance, parent;

        config = {appName, ...config};

        if (config.parentId) {
            parent = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getComponent(config.parentId);

            if (Container && parent && parent instanceof Container) {
                index = config.parentIndex;

                delete config.parentId;
                delete config.parentIndex;

                if (_Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isNumber(index)) {
                    instance = parent.insert(index, config)
                } else {
                    instance = parent.add(config)
                }
            }
        } else {
            // default parentId='document.body' => we want it to get shown
            config.autoInitVnode = true;
            config.autoMount     = true;

            instance = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"][config.ntype ? 'ntype' : 'create'](config)
        }

        return instance.id
    }

    /**
     * @param {Object} data
     */
    createThemeMap(data) {
        _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].ns('Neo.cssMap.fileInfo', true);
        _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].cssMap.fileInfo = data;
        this.resolveThemeFilesCache()
    }

    /**
     * Remote method to use inside main threads for destroying neo based class instances.
     *
     * @example:
     *     Neo.worker.App.destroyNeoInstance('neo-button-3').then(success => console.log(success))
     *
     * @param {String} id
     * @returns {Boolean} returns true, in case the instance was found
     */
    destroyNeoInstance(id) {
        let instance = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].get(id),
            parent;

        if (instance) {
            if (instance.parentId) {
                parent = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getComponent(instance.parentId);

                if (parent) {
                    parent.remove(instance);
                    return true
                }
            }

            instance.destroy(true, true);
            return true
        }

        return false
    }

    /**
     * Fires a custom event based on core.Observable on any app realm based Neo instance from main
     * @param {Object} data
     * @param {String} data.id
     * @param {String} data.name
     */
    fireEvent(data) {
        let instance = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].get(data.id),
            name;

        if (instance) {
            name = data.name;

            delete data.id;
            delete data.name;

            instance.fire(name, data);

            return true
        }

        return false
    }

    /**
     * Only needed for the SharedWorkers context
     * @param {String} eventName
     * @param {Object} data
     */
    fireMainViewsEvent(eventName, data) {
        this.ports.forEach(port => {
            _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].apps[port.appName].mainView.fire(eventName, data)
        })
    }

    /**
     * Convenience shortcut to lazy-load main thread addons, in case they are not imported yet
     * @param {String} name
     * @param {Number} windowId
     * @returns {Promise<Neo.main.addon.Base>} The namespace of the addon to use via remote method access
     */
    async getAddon(name, windowId) {
        let addon = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].main?.addon?.[name];

        if (!addon) {
            await _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].Main.importAddon({name, windowId});
            addon = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].main.addon[name]
        }

        return addon
    }

    /**
     * Get configs of any app realm based Neo instance from main
     * @param {Object} data
     * @param {String} data.id
     * @param {String|String[]} data.keys
     * Returns an array of configs if a keys array was passed.
     * Returns the value of a given config directly, in case no array was passed
     * Returns false, in case no instance got found.
     * @returns {*}
     */
    getConfigs(data) {
        let instance    = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].get(data.id),
            {keys}      = data,
            returnArray = [];

        if (instance) {
            if (!Array.isArray(keys)) {
                return instance[keys]
            }

            keys.forEach(key => {
                returnArray.push(instance[key])
            });

            return returnArray
        }

        return false
    }

    /**
     * @param {String} path
     * @returns {Promise}
     */
    importApp(path) {
        if (path.endsWith('.mjs')) {
            path = path.slice(0, -4)
        }

        return __webpack_require__("./. lazy recursive ^\\.\\/.*\\.mjs$ include: (?:\\/%7C\\\\)app.mjs$")(`./${path}.mjs`)
    }

    /**
     * In case you don't want to include prototype based CSS files, use the className param instead
     * @param {Number} windowId
     * @param {Neo.core.Base} [proto]
     * @param {String} [className]
     */
    insertThemeFiles(windowId, proto, className) {
        if (_Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].config.themes.length > 0) {
            className = className || proto.className;

            let me     = this,
                cssMap = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].cssMap,
                parent = proto?.__proto__,
                classPath, classRoot, fileName, lClassRoot, mapClassName, ns, themeFolders;

            if (!cssMap) {
                me.themeFilesCache.push([windowId, proto])
            } else {
                // we need to modify app related class names
                if (!className.startsWith('Neo.')) {
                    className  = className.split('.');
                    classRoot  = className.shift();
                    lClassRoot = classRoot.toLowerCase();

                    className[0] === 'view' && className.shift();

                    mapClassName = `apps.${_Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].apps[classRoot]?.appThemeFolder || lClassRoot}.${className.join('.')}`;
                    className    = `apps.${lClassRoot}.${className.join('.')}`;
                }

                if (parent && parent !== _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].core.Base.prototype) {
                    if (!_Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].ns(`${windowId}.${parent.className}`, false, cssMap)) {
                        me.insertThemeFiles(windowId, parent)
                    }
                }

                themeFolders = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].ns(mapClassName || className, false, cssMap.fileInfo);

                if (themeFolders && !_Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].ns(`${windowId}.${className}`, false, cssMap)) {
                    classPath = className.split('.');
                    fileName  = classPath.pop();
                    classPath = classPath.join('.');
                    ns        = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].ns(`${windowId}.${classPath}`, true, cssMap);

                    ns[fileName] = true;

                    me.countLoadingThemeFiles++;

                    _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].main.addon.Stylesheet.addThemeFiles({
                        className: mapClassName || className,
                        folders  : themeFolders,
                        windowId
                    }).then(() => {
                        me.countLoadingThemeFiles--
                    })
                }
            }
        }
    }

    /**
     * Every dom event will get forwarded as a worker message from main and ends up here first
     * @param {Object} data useful event properties, differs for different event types. See Neo.main.DomEvents.
     */
    onDomEvent(data) {
        _manager_DomEvent_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].fire(data)
    }

    /**
     * Every URL hash-change will create a post message in main and end up here first.
     * @param {Object} data parsed key-value pairs for each hash value
     */
    onHashChange(data) {
        _util_HashHistory_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].push(data.data)
    }

    /**
     * The starting point for apps
     * @param {Object} data
     */
    onLoadApplication(data) {
        let me        = this,
            {config}  = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
            {appPath} = config;

        if (config.environment !== 'development') {
            appPath = appPath.startsWith('/') ? appPath.substring(1) : appPath
        }

        me.importApp(appPath).then(module => {
            module.onStart();

            // short delay to ensure Component Controllers are ready
            config.hash && me.timeout(5).then(() => {
                _util_HashHistory_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].push(config.hash);
                // apps which will get created later must not use outdated hash values
                delete config.hash
            })
        })
    }

    /**
     * Fire event on all apps
     * @param {Object} data
     * @param {Number} data.angle
     * @param {String} data.layout landscape|portrait
     * @param {String} data.type landscape-primary|landscape-secondary|portrait-primary|portrait-secondary
     */
    onOrientationChange(data) {
        Object.values(_Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].apps).forEach(app => {
            app.fire('orientationchange', data.data)
        })
    }

    /**
     * @param {Object} msg
     */
    onRegisterNeoConfig(msg) {
        super.onRegisterNeoConfig(msg);

        let {config} = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
            {data}   = msg,
            url      = 'resources/theme-map.json';

        _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].windowConfigs = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].windowConfigs || {};

        _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].windowConfigs[data.windowId] = data;

        if (config.environment === 'development' || config.environment === 'dist/esm') {
            url = `../../${url}`
        }

        if (config.workerBasePath?.includes('node_modules')) {
            url = `../../${url}`
        }

        if (url[0] !== '.') {
            url = `./${url}`
        }

        fetch(url)
            .then(response => response.json())
            .then(data => {this.createThemeMap(data)});

        config.remotesApiUrl  && __webpack_require__.e(/*! import() */ "src_remotes_Api_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ../remotes/Api.mjs */ "./src/remotes/Api.mjs")).then(module => module.default.load());
        !config.useVdomWorker && __webpack_require__.e(/*! import() */ "vendors-src_vdom_Helper_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ../vdom/Helper.mjs */ "./src/vdom/Helper.mjs"))
    }

    /**
     * @param {Object} msg
     */
    onRegisterPort(msg) {
        let me   = this,
            port = msg.transfer;

        port.onmessage = me.onMessage.bind(me);

        me.channelPorts[msg.origin] = port
    }

    /**
     * @param {Object} data
     */
    onWindowPositionChange(data) {
        this.fireMainViewsEvent('windowPositionChange', data.data)
    }

    /**
     * Only needed for SharedWorkers
     * @param {String} appName
     */
    registerApp(appName) {
        // register the name as fast as possible
        this.onRegisterApp({ appName });
        this.sendMessage('main', {action: 'registerAppName', appName})
    }

    /**
     * Unregister the app from the CSS map
     * Only needed for SharedWorkers
     * @param {String} appName
     */
    removeAppFromThemeMap(appName) {
        delete _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].cssMap[appName.toLowerCase()]
    }

    /**
     * @private
     */
    resolveThemeFilesCache() {
        let me = this;

        me.themeFilesCache.forEach(item => {
            me.insertThemeFiles(...item)
        });

        me.themeFilesCache = []
    }

    /**
     * Set configs of any app realm based Neo instance from main
     * @param {Object} data
     * @param {String} data.id
     */
    setConfigs(data) {
        let instance = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].get(data.id);

        if (instance) {
            delete data.id;
            instance.set(data);

            return true
        }

        return false
    }

    /**
     * @param {Object} data
     * @param {String} data.key
     * @param {String} [data.priority] optionally pass 'important'
     * @param {String} data.theme=Neo.config.themes[0]
     * @param {String} data.value
     * @param {Number} data.windowId
     * @returns {Promise<any>}
     */
    async setCssVariable(data) {
        let Stylesheet = await this.getAddon('Stylesheet', data.windowId),
            theme      = data.theme || _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].config.themes?.[0];

        if (theme.startsWith('neo-')) {
            theme = theme.substring(4)
        }

        return Stylesheet.setCssVariable({theme, ...data})
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].setupClass(App));

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBwd29ya2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLHFDOzs7Ozs7Ozs7Ozs7Ozs7QUMza0RBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsOENBQThDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDhDQUE4QztBQUNyRSxDQUFDOztBQUVELGlFQUFlLGFBQWEsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeFVvQjtBQUNLOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQyxlQUFlLG1CQUFtQjtBQUNsQyxlQUFlLG1CQUFtQjtBQUNsQyxlQUFlLG1CQUFtQjtBQUNsQyxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDLGVBQWUsaUJBQWlCO0FBQ2hDLGVBQWUsaUJBQWlCO0FBQ2hDLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsZUFBZSw2QkFBNkI7QUFDNUMsZUFBZSw2QkFBNkI7QUFDNUMsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQixlQUFlLGdCQUFnQjtBQUMvQixlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCLEtBQUssSUFBSSxrQkFBa0IsSUFBSTtBQUNyRSxzQ0FBc0MsSUFBSTtBQUMxQyw0REFBNEQsb0JBQW9CLGlCQUFpQixvQkFBb0Isb0JBQW9CLG9CQUFvQjtBQUM3SjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixZQUFZOztBQUUzQztBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDO0FBQzFDLDBDQUEwQztBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QixlQUFlO0FBQ3hDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDLGVBQWUsaUJBQWlCO0FBQ2hDLGVBQWUsZ0JBQWdCO0FBQy9CLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5REFBeUQ7QUFDekQsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCLGVBQWUsS0FBSztBQUNwQixlQUFlLGlCQUFpQjtBQUNoQyxpQkFBaUIsS0FBSztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDLGVBQWUsaUJBQWlCO0FBQ2hDLGVBQWUsaUJBQWlCO0FBQ2hDLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxjQUFjO0FBQzdCLGVBQWUsY0FBYztBQUM3QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLGVBQWU7QUFDOUIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEscUJBQXFCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaURBQWlELGlFQUFZO0FBQzdEO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQztBQUMxQywwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxNQUFNLHlCQUF5QixnQkFBZ0IsSUFBSSxjQUFjO0FBQzVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLGlDQUFpQztBQUN4RCxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUEsVUFBVSxRQUFRO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBLFdBQVcsU0FBUztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixnQkFBZ0IsNENBQTRDLHFCQUFxQixJQUFJLGlCQUFpQixPQUFPLElBQUk7QUFDcEk7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsK0JBQStCLDBEQUFhOztBQUU1QyxpRUFBZSxHQUFHLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5akN1QjtBQUNKO0FBQ007QUFDRDtBQUNLO0FBQ1Y7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0RBQUk7QUFDN0I7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLEtBQUs7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQSxpQ0FBaUMsOEJBQThCO0FBQy9ELGlDQUFpQyw4QkFBOEI7QUFDL0QsaUNBQWlDLDhCQUE4QjtBQUMvRCxpQ0FBaUMsOEJBQThCO0FBQy9ELGlDQUFpQywyQkFBMkI7QUFDNUQsaUNBQWlDLDJCQUEyQjtBQUM1RCxpQ0FBaUM7QUFDakMsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyxtREFBTTtBQUNoRCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIscUJBQXFCOztBQUUxQyx1QkFBdUIsU0FBUztBQUNoQztBQUNBLHlDQUF5QyxvQkFBb0I7O0FBRTdEO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyxtREFBTTtBQUNoRCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRO0FBQUEsRUFFaUM7O0FBRXpDLFFBQVE7QUFBQSxFQW1CQztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHlDQUF5QztBQUN0RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9COztBQUVBLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckIsa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwyQkFBMkIsa0JBQWtCO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUscUJBQXFCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIscUJBQXFCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDs7QUFFQSwwQkFBMEIscUJBQXFCO0FBQy9DOztBQUVBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxlQUFlO0FBQzlCLGVBQWUsU0FBUztBQUN4QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLGVBQWU7QUFDOUIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxjQUFjO0FBQzdCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVEseUNBQXlDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSw0QkFBNEI7QUFDM0MsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixRQUFRLHlDQUF5QztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsaUJBQWlCO0FBQ2hDLGVBQWUsaUJBQWlCO0FBQ2hDLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSx3REFBTTtBQUNsQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsU0FBUztBQUNwQixXQUFXLFVBQVU7QUFDckIsYUFBYTtBQUNiOztBQUVBLGlFQUFlLDBCQUEwQixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3MENBO0FBQ007O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0RBQUk7QUFDekI7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLDJCQUEyQjs7QUFFeEM7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsMkJBQTJCO0FBQzVDLCtCQUErQiwwQkFBMEI7QUFDekQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQiwwQkFBMEI7O0FBRTFCO0FBQ0EsK0JBQStCO0FBQy9CLCtCQUErQjs7QUFFL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0I7QUFDL0IsK0JBQStCOztBQUUvQjtBQUNBOztBQUVBO0FBQ0EsK0JBQStCO0FBQy9CLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBOztBQUVBLGlFQUFlLHNCQUFzQixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4UUk7QUFDTTs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzREFBSTtBQUN6QjtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFCQUFxQjs7QUFFbEM7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsR0FBRztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxzQkFBc0IsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeEpHO0FBQ2E7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlEQUFJO0FBQzlCO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSx5QkFBeUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkRBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxpRUFBZSxXQUFXLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hKZ0I7QUFDTzs7QUFFbEQ7QUFDQTtBQUNBLCtFQUErRSxTQUFTO0FBQ3hGLGlDQUFpQyxnQkFBZ0IsSUFBSTtBQUNyRCw2Q0FBNkMsVUFBVSxHQUFHLFdBQVcsTUFBTTtBQUMzRSxpQ0FBaUMsZ0JBQWdCLElBQUk7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNEQUFJO0FBQzdCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFVBQVUsdUJBQXVCLFdBQVc7QUFDcEc7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU8sbUJBQW1CLDZEQUE2RDtBQUMvRyx3QkFBd0IsT0FBTyxRQUFRLE9BQU87QUFDOUMsd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxRQUFRLDZEQUFXO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLElBQUk7O0FBRWQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw2REFBVztBQUNuQjtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsdUJBQXVCO0FBQ3BDLHNDQUFzQyw2REFBVzs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSw2QkFBNkI7QUFDL0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsc0JBQXNCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLDBCQUEwQjtBQUM5RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSwwQkFBMEIsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqUGtEO0FBQ0Q7QUFDSDtBQUNKO0FBQ087QUFDRjtBQUNFOztBQUUzRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtCQUErQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRLFVBQVU7QUFDakM7QUFDQSx1QkFBdUI7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVULDZCQUE2Qix3REFBVztBQUN4Qzs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNkRBQVM7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYyxzREFBTSw2QkFBNkI7QUFDakYsZ0NBQWdDLGNBQWMsd0RBQVEsMkJBQTJCO0FBQ2pGLGdDQUFnQyxjQUFjLHdEQUFRO0FBQ3REOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxlQUFlO0FBQzlCLGVBQWUsUUFBUTtBQUN2QixlQUFlLGNBQWM7QUFDN0IsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0RBQWtELE1BQU07QUFDeEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtRUFBZTtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxtREFBTTtBQUN6Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDLGFBQWEsbUJBQW1COztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTLFdBQVc7QUFDckMsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUEsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckMsZUFBZSxzQkFBc0I7QUFDckMsZUFBZSxzQkFBc0I7QUFDckMsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFVBQVU7QUFDdEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0NBQW9DLFdBQVcsb0NBQW9DLHFCQUFxQjtBQUN4RztBQUNBOztBQUVBLG9EQUFvRCxnQkFBZ0I7O0FBRXBFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0EsUUFBUSwwREFBYTs7QUFFckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsWUFBWSwwREFBYTtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxxREFBcUQsVUFBVTs7QUFFOUc7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxvQkFBb0IsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQzc2QnBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLE1BQU07QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCLGVBQWUsS0FBSztBQUNwQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxlQUFlO0FBQzlCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLEtBQUs7QUFDcEIsZUFBZSxLQUFLO0FBQ3BCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsR0FBRztBQUNsQixlQUFlLEdBQUc7QUFDbEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlO0FBQ2Y7QUFDQTtBQUNBLENBQUMsQ0FBQyxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4SzhDO0FBQ0E7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEdBQUc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQSx1REFBdUQsNERBQVk7QUFDbkU7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsS0FBSztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMERBQWE7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekIsZUFBZSxXQUFXO0FBQzFCO0FBQ0Esb0JBQW9CLGtDQUFrQztBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQixlQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBLGtEQUFrRDs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsMkVBQTJFO0FBQy9GLG9CQUFvQiwyRUFBMkU7QUFDL0Ysb0JBQW9CLDJFQUEyRTtBQUMvRixvQkFBb0I7QUFDcEIsQ0FBQzs7QUFFRCxpRUFBZSx1Q0FBdUMsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ2xQaEQ7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQkFBc0I7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsQ0FBQyxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDbEpIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWU7QUFDZjtBQUNBLENBQUMsQ0FBQyxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xDd0M7QUFDTztBQUNRO0FBQ0w7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaURBQUk7QUFDN0I7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUVBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBOztBQUVBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLGVBQWU7QUFDOUIsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU8sV0FBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUMsb0NBQW9DO0FBQzdFLGtCQUFrQjtBQUNsQix5Q0FBeUMscUNBQXFDO0FBQzlFO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCOztBQUUzQiw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1Qiw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1FQUFlO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLFNBQVM7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLG1FQUFlOztBQUUxQztBQUNBO0FBQ0Esb0JBQW9CLHVEQUFRO0FBQzVCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLHVEQUFROztBQUVoRDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLCtCQUErQix1QkFBdUI7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixTQUFTO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSwwQkFBMEIsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZXMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQixxREFBcUQ7O0FBRXJEO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxpRUFBZSxJQUFJLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3T2lCO0FBQ0c7QUFDSTtBQUNEO0FBQ047O0FBRWlCOzs7Ozs7Ozs7Ozs7Ozs7OztBQ05OOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDREQUFVO0FBQ2hDO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSx1QkFBdUIsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5Q0Y7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0EsY0FBYyxhQUFhO0FBQzNCLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0EsNkJBQTZCLGlEQUFXO0FBQ3hDO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLCtCQUErQixXQUFXLEdBQUcsU0FBUztBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlFQUFlLDhCQUE4QixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakhYO0FBQ007QUFDQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpREFBTztBQUMvQjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlEQUFpRDtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCLFdBQVc7O0FBRTVCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxzREFBUSw4QkFBOEIsWUFBWTs7QUFFeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyQkFBMkI7QUFDMUMsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhCQUE4Qix1QkFBdUI7QUFDckQ7O0FBRUEsZUFBZSxTQUFTO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLFNBQVM7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQSxlQUFlLHVEQUFTO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQyxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix1REFBUztBQUN2Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEMsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLDJCQUEyQjtBQUMxQyxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsUUFBUTtBQUN2QixlQUFlLEdBQUc7QUFDbEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLDJCQUEyQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsU0FBUztBQUN4QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUseUJBQXlCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxZU87QUFDRDtBQUNKO0FBQ087QUFDRDtBQUNEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzREFBSTtBQUMzQjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLGNBQWM7O0FBRTNCLGdEQUFnRCxhQUFhO0FBQzdEOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzREFBZ0I7QUFDMUM7QUFDQTs7QUFFQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGtEQUFZO0FBQzVCO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQixhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNEJBQTRCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUTtBQUFBLEVBQXdDOztBQUVoRCxRQUFRO0FBQUEsRUFFQztBQUNUOztBQUVBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsU0FBUztBQUN4QztBQUNBLGdDQUFnQyx1REFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxVQUFVO0FBQ1YsWUFBWSx3REFBTTtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsUUFBUTtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsc0RBQVE7O0FBRXJDO0FBQ0E7QUFDQSwwREFBMEQsc0RBQVE7QUFDbEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSx3QkFBd0IsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdmhCQTtBQUNDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNEQUFRO0FBQzVCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0EsK0JBQStCLHVEQUFRO0FBQ3ZDLCtCQUErQix1REFBUTtBQUN2QywrQkFBK0IsdURBQVE7QUFDdkM7O0FBRUEsOEJBQThCLDJDQUEyQztBQUN6RSw4QkFBOEIsMkNBQTJDOztBQUV6RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSxpRUFBZSxxQkFBcUIsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeE1FO0FBQ047O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaURBQU87QUFDOUI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBLFFBQVEsc0RBQUk7O0FBRVo7O0FBRUEsK0NBQStDO0FBQy9DLCtDQUErQztBQUMvQywrQ0FBK0M7QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSx3QkFBd0IsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuREo7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNEQUFJO0FBQzNCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsR0FBRztBQUNsQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsR0FBRztBQUNsQixlQUFlLEdBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsR0FBRztBQUNsQixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsd0JBQXdCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbE1KOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzREFBSTtBQUM5QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsMkJBQTJCO0FBQzFDLGVBQWUsc0JBQXNCO0FBQ3JDLGVBQWUsUUFBUSxpQkFBaUI7QUFDeEMsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQSx3RUFBd0U7QUFDeEU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlFQUFlLDJCQUEyQixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvRDNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ087QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFVBQVU7QUFDcEQsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQ7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHdDQUF3QyxVQUFVO0FBQ2xELHdEQUF3RDtBQUN4RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ087QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDLHFCQUFxQjtBQUNuRSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHFCQUFxQjtBQUN2RSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxHQUFHO0FBQ2QsYUFBYTtBQUNiO0FBQ087QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CO0FBQ087QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbE8wQztBQUNNOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0RBQUk7QUFDOUI7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSwyQkFBMkIsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNySFA7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0RBQUk7QUFDekI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsZUFBZTtBQUM5QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxhQUFhLFFBQVE7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVyxjQUFjLGlCQUFpQjtBQUNyRixnQ0FBZ0MsVUFBVTtBQUMxQywyQkFBMkIsZUFBZSxJQUFJLFNBQVM7O0FBRXZEO0FBQ0EseUNBQXlDLFNBQVMsS0FBSyxJQUFJO0FBQzNEO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsOEJBQThCLFNBQVMsS0FBSyxJQUFJO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxzQkFBc0IsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcFBVO0FBQ1E7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNEQUFJO0FBQ3ZCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsZUFBZTtBQUM5QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsOENBQThDOztBQUU5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxXQUFXO0FBQ3ZELGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBLGdDQUFnQyxLQUFLO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLFNBQVM7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsOERBQWdCOztBQUU5QztBQUNBLGtGQUFrRixpQkFBaUI7QUFDbkc7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsZUFBZTtBQUM5QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxlQUFlO0FBQzlCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLGVBQWU7QUFDOUIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxlQUFlO0FBQzlCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGVBQWUsU0FBUztBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsb0JBQW9CLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZhWTtBQUNROztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzREFBSTtBQUN4QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGVBQWU7QUFDOUIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1EOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQSxlQUFlLFNBQVM7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsYUFBYTtBQUM1QixpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGVBQWUsU0FBUztBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDhEQUFnQjs7QUFFOUM7QUFDQSxvRkFBb0Ysa0JBQWtCO0FBQ3RHOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGVBQWUsU0FBUztBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGVBQWUsU0FBUztBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUscUJBQXFCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1UGdCO0FBQ0c7QUFDRztBQUNPO0FBQ2hCO0FBQ2lCOztBQUVuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNEQUFJO0FBQ3pCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwrQkFBK0I7QUFDbkQ7QUFDQSxpQkFBaUIsNERBQVUsRUFBRSxxRUFBa0I7QUFDL0M7O0FBRUE7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLG1CQUFtQjtBQUNoQyw4QkFBOEIsa0JBQWtCO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTs7QUFFQSxnQ0FBZ0Msc0NBQXNDOztBQUV0RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvQ0FBb0MsNEJBQTRCO0FBQ2hFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQyxpQ0FBaUMsa0JBQWtCO0FBQ25EOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCLGFBQWEsaUJBQWlCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLDJCQUEyQixlQUFlO0FBQzFDOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaUNBQWlDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3REFBd0QsNEJBQTRCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsVUFBVTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUVBQXVFLHVCQUF1QjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLG9CQUFvQixPQUFPO0FBQzNCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLHNDQUFzQztBQUN0QztBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsbUNBQW1DLGNBQWM7QUFDakQsY0FBYztBQUNkLHlDQUF5Qyx3QkFBd0I7QUFDakU7O0FBRUE7QUFDQSxlQUFlO0FBQ2YseUNBQXlDLHNCQUFzQjtBQUMvRDs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsb0RBQU87QUFDakM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVMsY0FBYzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU87O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msa0ZBQWtGO0FBQ3hILGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxvREFBb0Q7QUFDdEY7QUFDQTtBQUNBOztBQUVBLGlFQUFlLHNCQUFzQixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQzdZWTs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7O0FBRUE7QUFDQSxvQkFBb0IsUUFBUTtBQUM1Qjs7QUFFQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCOztBQUVBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7O0FBRUE7QUFDQSxtREFBbUQsNkRBQVc7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUVBQWUsT0FBTyxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZDZ0I7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHNEQUFJO0FBQ3JDO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QyxtQ0FBbUMsd0JBQXdCO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFROztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvQkFBb0I7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQixJQUFJO0FBQ3hDO0FBQ0EsK0JBQStCLG9CQUFvQixvQkFBb0I7QUFDdkUsK0JBQStCLHNCQUFzQjtBQUNyRCxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLGtDQUFrQyxFQUFDOzs7Ozs7O1VDM0psRDtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOztVQUVBO1VBQ0E7Ozs7O1dDekJBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EseUNBQXlDLHdDQUF3QztXQUNqRjtXQUNBO1dBQ0EsRTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEVBQUU7V0FDRixFOzs7OztXQ1JBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsRTs7Ozs7V0NKQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEdBQUc7V0FDSDtXQUNBO1dBQ0EsQ0FBQyxJOzs7OztXQ1BELHdGOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBLHVEQUF1RCxpQkFBaUI7V0FDeEU7V0FDQSxnREFBZ0QsYUFBYTtXQUM3RCxFOzs7OztXQ05BO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLGtDOzs7OztXQ2xCQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsYUFBYTtXQUNiO1dBQ0E7V0FDQTtXQUNBOztXQUVBO1dBQ0E7V0FDQTs7V0FFQTs7V0FFQSxrQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcEN5QztBQUNBO0FBQ21CO0FBQ047QUFDQTtBQUNBOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpREFBSTtBQUN0QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFFBQVEsZ0RBQUc7QUFDWCxRQUFRLGdEQUFHO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxjQUFjO0FBQzdCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsNkNBQTZDLHFDQUFxQztBQUNsRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxnREFBRztBQUN2Qyx3QkFBd0IsZ0RBQUc7QUFDM0I7O0FBRUEsa0JBQWtCOztBQUVsQjtBQUNBLHFCQUFxQixnREFBRzs7QUFFeEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixnREFBRztBQUN2QjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixnREFBRztBQUMxQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxRQUFRLGdEQUFHO0FBQ1gsUUFBUSxnREFBRztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQSx1QkFBdUIsZ0RBQUc7QUFDMUI7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QixnREFBRzs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLHVCQUF1QixnREFBRztBQUMxQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0RBQUc7QUFDZixTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLDhCQUE4QjtBQUMvQztBQUNBO0FBQ0Esb0JBQW9CLGdEQUFHOztBQUV2QjtBQUNBLGtCQUFrQixnREFBRyxtQkFBbUIsZUFBZTtBQUN2RCxvQkFBb0IsZ0RBQUc7QUFDdkI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDBCQUEwQixnREFBRztBQUM3QixhQUFhLFdBQVc7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsMkZBSUgsR0FBTyxFQUFFLEtBQUssS0FBSyxDQUN0QjtBQUNUOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxlQUFlO0FBQzlCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsWUFBWSxnREFBRztBQUNmOztBQUVBO0FBQ0EseUJBQXlCLGdEQUFHO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDJDQUEyQyxnREFBRywrQ0FBK0MsR0FBRyxvQkFBb0I7QUFDcEgsMkNBQTJDLFdBQVcsR0FBRyxvQkFBb0I7QUFDN0U7O0FBRUEseUNBQXlDLGdEQUFHO0FBQzVDLHlCQUF5QixnREFBRyxPQUFPLFNBQVMsR0FBRyxpQkFBaUI7QUFDaEU7QUFDQTtBQUNBOztBQUVBLCtCQUErQixnREFBRzs7QUFFbEMscUNBQXFDLGdEQUFHLE9BQU8sU0FBUyxHQUFHLFVBQVU7QUFDckU7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdEQUFHLE9BQU8sU0FBUyxHQUFHLFVBQVU7O0FBRWhFOztBQUVBOztBQUVBLG9CQUFvQixnREFBRztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsUUFBUSw2REFBZTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxRQUFRLDZEQUFXO0FBQ25COztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTLEVBQUUsZ0RBQUc7QUFDM0IsYUFBYSxTQUFTOztBQUV0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLDZEQUFXO0FBQzNCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLHNCQUFzQixnREFBRztBQUN6QjtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxRQUFRLEVBQUUsZ0RBQUc7QUFDMUIsYUFBYSxRQUFRO0FBQ3JCOztBQUVBLFFBQVEsZ0RBQUcsaUJBQWlCLGdEQUFHOztBQUUvQixRQUFRLGdEQUFHOztBQUVYO0FBQ0EsMkJBQTJCLElBQUk7QUFDL0I7O0FBRUE7QUFDQSwyQkFBMkIsSUFBSTtBQUMvQjs7QUFFQTtBQUNBLHVCQUF1QixJQUFJO0FBQzNCOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsMEJBQTBCOztBQUVyRCxpQ0FBaUMsbUtBQTRCO0FBQzdELGlDQUFpQywyS0FBNEI7QUFDN0Q7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixTQUFTO0FBQ3RDLGtDQUFrQyxtQ0FBbUM7QUFDckU7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxlQUFlLGdEQUFHO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsdUJBQXVCLGdEQUFHOztBQUUxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxnREFBRzs7QUFFMUM7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxlQUFlO0FBQ3pEO0FBQ0E7O0FBRUEsaUVBQWUsZ0RBQUcsZ0JBQWdCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vLi8gbGF6eSBeXFwuXFwvLipcXC5tanMkIGluY2x1ZGU6ICgiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9EZWZhdWx0Q29uZmlnLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL05lby5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb2xsZWN0aW9uL0Jhc2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29sbGVjdGlvbi9GaWx0ZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29sbGVjdGlvbi9Tb3J0ZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29udHJvbGxlci9BcHBsaWNhdGlvbi5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb250cm9sbGVyL0Jhc2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29yZS9CYXNlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvcmUvQ29tcGFyZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb3JlL0NvbmZpZy5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb3JlL0NvbmZpZ1N5bWJvbHMubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29yZS9FZmZlY3RNYW5hZ2VyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvcmUvSWRHZW5lcmF0b3IubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29yZS9PYnNlcnZhYmxlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvcmUvVXRpbC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb3JlL19leHBvcnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvbWFuYWdlci9CYXNlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL21hbmFnZXIvQ2xhc3NIaWVyYXJjaHkubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvbWFuYWdlci9Db21wb25lbnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvbWFuYWdlci9Eb21FdmVudC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9tYW5hZ2VyL0ZvY3VzLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL21hbmFnZXIvSW5zdGFuY2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdXRpbC9BcnJheS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy91dGlsL0NsYXNzU3lzdGVtLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3V0aWwvRnVuY3Rpb24ubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdXRpbC9IYXNoSGlzdG9yeS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy91dGlsL0xvZ2dlci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy91dGlsL1ZEb20ubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdXRpbC9WTm9kZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy93b3JrZXIvQmFzZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy93b3JrZXIvTWVzc2FnZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy93b3JrZXIvbWl4aW4vUmVtb3RlTWV0aG9kQWNjZXNzLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL25lby5tanMvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL25lby5tanMvd2VicGFjay9ydW50aW1lL2Vuc3VyZSBjaHVuayIsIndlYnBhY2s6Ly9uZW8ubWpzL3dlYnBhY2svcnVudGltZS9nZXQgamF2YXNjcmlwdCBjaHVuayBmaWxlbmFtZSIsIndlYnBhY2s6Ly9uZW8ubWpzL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vbmVvLm1qcy93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL25lby5tanMvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9uZW8ubWpzL3dlYnBhY2svcnVudGltZS9wdWJsaWNQYXRoIiwid2VicGFjazovL25lby5tanMvd2VicGFjay9ydW50aW1lL2ltcG9ydFNjcmlwdHMgY2h1bmsgbG9hZGluZyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3dvcmtlci9BcHAubWpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBtYXAgPSB7XG5cdFwiLi9hcHBzL2NvbG9ycy9hcHAubWpzXCI6IFtcblx0XHRcIi4vYXBwcy9jb2xvcnMvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2xpc3RfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ29tYm9Cb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19zdGF0ZV9Qcm92aWRlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2dyaWRfQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1hcHBzX2NvbG9yc19hcHBfbWpzXCJcblx0XSxcblx0XCIuL2FwcHMvY29sb3JzL2NoaWxkYXBwcy93aWRnZXQvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2FwcHMvY29sb3JzL2NoaWxkYXBwcy93aWRnZXQvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcImFwcHNfY29sb3JzX2NoaWxkYXBwc193aWRnZXRfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9hcHBzL2NvdmlkL2FwcC5tanNcIjogW1xuXHRcdFwiLi9hcHBzL2NvdmlkL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NvbWJvQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfc3RhdGVfUHJvdmlkZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY190YWJfQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1hcHBzX2NvdmlkX2FwcF9tanMtc3JjX3NlbGVjdGlvbl9Nb2RlbF9tanMtc3JjX3Rvb2xiYXJfQmFzZV9tanNcIlxuXHRdLFxuXHRcIi4vYXBwcy9lbWFpbC9hcHAubWpzXCI6IFtcblx0XHRcIi4vYXBwcy9lbWFpbC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZ3JpZF9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mdW5jdGlvbmFsX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1hcHBzX2VtYWlsX2FwcF9tanMtc3JjX3Rvb2xiYXJfQmFzZV9tanNcIlxuXHRdLFxuXHRcIi4vYXBwcy9maW5hbmNlL2FwcC5tanNcIjogW1xuXHRcdFwiLi9hcHBzL2ZpbmFuY2UvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3N0YXRlX1Byb3ZpZGVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZ3JpZF9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWFwcHNfZmluYW5jZV9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2FwcHMvZm9ybS9hcHAubWpzXCI6IFtcblx0XHRcIi4vYXBwcy9mb3JtL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19zdGF0ZV9Qcm92aWRlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1hcHBzX2Zvcm1fYXBwX21qcy1zcmNfc2VsZWN0aW9uX01vZGVsX21qc1wiXG5cdF0sXG5cdFwiLi9hcHBzL3BvcnRhbC9hcHAubWpzXCI6IFtcblx0XHRcIi4vYXBwcy9wb3J0YWwvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfc3RhdGVfUHJvdmlkZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19sYXlvdXRfQ3ViZV9tanNcIixcblx0XHRcInZlbmRvcnMtYXBwc19wb3J0YWxfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9hcHBzL3BvcnRhbC9jaGlsZGFwcHMvcHJldmlldy9hcHAubWpzXCI6IFtcblx0XHRcIi4vYXBwcy9wb3J0YWwvY2hpbGRhcHBzL3ByZXZpZXcvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcImFwcHNfcG9ydGFsX2NoaWxkYXBwc19wcmV2aWV3X2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vYXBwcy9yZWFsd29ybGQvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2FwcHMvcmVhbHdvcmxkL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWFwcHNfcmVhbHdvcmxkX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vYXBwcy9yZWFsd29ybGQyL2FwcC5tanNcIjogW1xuXHRcdFwiLi9hcHBzL3JlYWx3b3JsZDIvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2xpc3RfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ29tYm9Cb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY190YWJfQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfSGVsaXhfbWpzLXNyY19jb250YWluZXJfUGFuZWxfbWpzLXNyY19mb3JtX2ZpZWxkX1JhbmdlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0dhbGxlcnlfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2NvbXBvbmVudF9oZWxpeF9WaWV3cG9ydF9tanMtc3JjX3NlbGVjdGlvbl9Nb2RlbF9tanMtc3JjX3Rvb2xiYXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfY29tcG9uZW50X2dhbGxlcnlfTWFpbkNvbnRhaW5lcl9tanNcIixcblx0XHRcInZlbmRvcnMtYXBwc19yZWFsd29ybGQyX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vYXBwcy9yb3V0ZS9hcHAubWpzXCI6IFtcblx0XHRcIi4vYXBwcy9yb3V0ZS9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWFwcHNfcm91dGVfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9hcHBzL3NoYXJlZGNvdmlkL2FwcC5tanNcIjogW1xuXHRcdFwiLi9hcHBzL3NoYXJlZGNvdmlkL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NvbWJvQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfc3RhdGVfUHJvdmlkZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY190YWJfQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1hcHBzX3NoYXJlZGNvdmlkX2FwcF9tanMtc3JjX3NlbGVjdGlvbl9Nb2RlbF9tanMtc3JjX3Rvb2xiYXJfQmFzZV9tanNcIlxuXHRdLFxuXHRcIi4vYXBwcy9zaGFyZWRjb3ZpZC9jaGlsZGFwcHMvc2hhcmVkY292aWRjaGFydC9hcHAubWpzXCI6IFtcblx0XHRcIi4vYXBwcy9zaGFyZWRjb3ZpZC9jaGlsZGFwcHMvc2hhcmVkY292aWRjaGFydC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwiYXBwc19zaGFyZWRjb3ZpZF9jaGlsZGFwcHNfc2hhcmVkY292aWRjaGFydF9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2FwcHMvc2hhcmVkY292aWQvY2hpbGRhcHBzL3NoYXJlZGNvdmlkZ2FsbGVyeS9hcHAubWpzXCI6IFtcblx0XHRcIi4vYXBwcy9zaGFyZWRjb3ZpZC9jaGlsZGFwcHMvc2hhcmVkY292aWRnYWxsZXJ5L2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJhcHBzX3NoYXJlZGNvdmlkX2NoaWxkYXBwc19zaGFyZWRjb3ZpZGdhbGxlcnlfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9hcHBzL3NoYXJlZGNvdmlkL2NoaWxkYXBwcy9zaGFyZWRjb3ZpZGhlbGl4L2FwcC5tanNcIjogW1xuXHRcdFwiLi9hcHBzL3NoYXJlZGNvdmlkL2NoaWxkYXBwcy9zaGFyZWRjb3ZpZGhlbGl4L2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJhcHBzX3NoYXJlZGNvdmlkX2NoaWxkYXBwc19zaGFyZWRjb3ZpZGhlbGl4X2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vYXBwcy9zaGFyZWRjb3ZpZC9jaGlsZGFwcHMvc2hhcmVkY292aWRtYXAvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2FwcHMvc2hhcmVkY292aWQvY2hpbGRhcHBzL3NoYXJlZGNvdmlkbWFwL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJhcHBzX3NoYXJlZGNvdmlkX2NoaWxkYXBwc19zaGFyZWRjb3ZpZG1hcF9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2FwcHMvc2hhcmVkZGlhbG9nL2FwcC5tanNcIjogW1xuXHRcdFwiLi9hcHBzL3NoYXJlZGRpYWxvZy9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGlhbG9nX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWFwcHNfc2hhcmVkZGlhbG9nX2FwcF9tanMtc3JjX2NvbnRhaW5lcl9QYW5lbF9tanNcIlxuXHRdLFxuXHRcIi4vYXBwcy9zaGFyZWRkaWFsb2cvY2hpbGRhcHBzL3NoYXJlZGRpYWxvZzIvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2FwcHMvc2hhcmVkZGlhbG9nL2NoaWxkYXBwcy9zaGFyZWRkaWFsb2cyL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtYXBwc19zaGFyZWRkaWFsb2dfY2hpbGRhcHBzX3NoYXJlZGRpYWxvZzJfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9kb2NzL2FwcC5tanNcIjogW1xuXHRcdFwiLi9kb2NzL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY190YWJfQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZHJhZ2dhYmxlX0RyYWdab25lX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfc2VsZWN0aW9uX01vZGVsX21qcy1zcmNfdHJlZV9MaXN0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1kb2NzX2FwcF92aWV3X01haW5Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWRvY3NfYXBwX21qcy1zcmNfY29udGFpbmVyX1ZpZXdwb3J0X21qcy1zcmNfY29udHJvbGxlcl9Db21wb25lbnRfbWpzLXNyY190b29sYmFyX0Jhc2VfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2J1dHRvbi9iYXNlL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9idXR0b24vYmFzZS9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NvbWJvQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19idXR0b25fYmFzZV9hcHBfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2J1dHRvbi9lZmZlY3QvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2J1dHRvbi9lZmZlY3QvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9Db21ib0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfYnV0dG9uX2VmZmVjdF9hcHBfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2J1dHRvbi9zcGxpdC9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvYnV0dG9uL3NwbGl0L2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2xpc3RfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ29tYm9Cb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2J1dHRvbl9zcGxpdF9hcHBfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NhbGVuZGFyL2Jhc2ljL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jYWxlbmRhci9iYXNpYy9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2xpc3RfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ29tYm9Cb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19zdGF0ZV9Qcm92aWRlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9EYXRlU2VsZWN0b3JfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX0NvbnRhaW5lcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2xpc3RfQ29sb3JfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RpbWVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jYWxlbmRhcl92aWV3X01haW5Db250YWluZXJTdGF0ZVByb3ZpZGVyX21qcy1zcmNfY29udGFpbmVyX1ZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19jYWxlbmRhcl9iYXNpY19hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NhbGVuZGFyL3dlZWt2aWV3L2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jYWxlbmRhci93ZWVrdmlldy9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3N0YXRlX1Byb3ZpZGVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY2FsZW5kYXJfdmlld193ZWVrX0NvbXBvbmVudF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NhbGVuZGFyX3ZpZXdfTWFpbkNvbnRhaW5lclN0YXRlUHJvdmlkZXJfbWpzLXNyY19jb250YWluZXJfVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJleGFtcGxlc19jYWxlbmRhcl93ZWVrdmlld19hcHBfbWpzLXNyY191dGlsX0RhdGVfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NoYXJ0cy9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvY2hhcnRzL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJleGFtcGxlc19jaGFydHNfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9jb21wb25lbnQvY2FudmFzL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvY2FudmFzL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwiZXhhbXBsZXNfY29tcG9uZW50X2NhbnZhc19hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9jYXJvdXNlbC9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L2Nhcm91c2VsL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfY29tcG9uZW50X2Nhcm91c2VsX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L2NoaXAvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9jaGlwL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwiZXhhbXBsZXNfY29tcG9uZW50X2NoaXBfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9jb21wb25lbnQvY2lyY2xlL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvY2lyY2xlL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQ2lyY2xlX21qc1wiLFxuXHRcdFwiZXhhbXBsZXNfY29tcG9uZW50X2NpcmNsZV9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9jbG9jay9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L2Nsb2NrL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UaW1lX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19jb21wb25lbnRfY2xvY2tfYXBwX21qcy1zcmNfZm9ybV9maWVsZF9QaWNrZXJfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9jb3JvbmFHYWxsZXJ5L2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvY29yb25hR2FsbGVyeS9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfR2FsbGVyeV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfY29tcG9uZW50X2Nvcm9uYUdhbGxlcnlfVmlld3BvcnRfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzXCIsXG5cdFx0XCJleGFtcGxlc19jb21wb25lbnRfY29yb25hR2FsbGVyeV9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9jb3JvbmFIZWxpeC9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L2Nvcm9uYUhlbGl4L2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfSGVsaXhfbWpzLXNyY19jb250YWluZXJfUGFuZWxfbWpzLXNyY19mb3JtX2ZpZWxkX1JhbmdlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19jb21wb25lbnRfY29yb25hSGVsaXhfYXBwX21qcy1zcmNfc2VsZWN0aW9uX01vZGVsX21qcy1zcmNfdG9vbGJhcl9CYXNlX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9jb21wb25lbnQvZGF0ZVNlbGVjdG9yL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvZGF0ZVNlbGVjdG9yL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0RhdGVTZWxlY3Rvcl9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfY29tcG9uZW50X2RhdGVTZWxlY3Rvcl9hcHBfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9nYWxsZXJ5L2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvZ2FsbGVyeS9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfR2FsbGVyeV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfY29tcG9uZW50X2dhbGxlcnlfTWFpbkNvbnRhaW5lcl9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfY29tcG9uZW50X2dhbGxlcnlfYXBwX21qcy1zcmNfY29udGFpbmVyX1BhbmVsX21qcy1zcmNfY29udGFpbmVyX1ZpZXdwb3J0X21qcy1iZDU2OGFcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L2hlbGl4L2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvaGVsaXgvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9IZWxpeF9tanMtc3JjX2NvbnRhaW5lcl9QYW5lbF9tanMtc3JjX2Zvcm1fZmllbGRfUmFuZ2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2NvbXBvbmVudF9oZWxpeF9WaWV3cG9ydF9tanMtc3JjX3NlbGVjdGlvbl9Nb2RlbF9tanMtc3JjX3Rvb2xiYXJfQmFzZV9tanNcIixcblx0XHRcImV4YW1wbGVzX2NvbXBvbmVudF9oZWxpeF9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9tYWdpY21vdmV0ZXh0L2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvbWFnaWNtb3ZldGV4dC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9NYWdpY01vdmVUZXh0X21qc1wiLFxuXHRcdFwiZXhhbXBsZXNfY29tcG9uZW50X21hZ2ljbW92ZXRleHRfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9jb21wb25lbnQvbXVsdGlXaW5kb3dDb3JvbmFHYWxsZXJ5L2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvbXVsdGlXaW5kb3dDb3JvbmFHYWxsZXJ5L2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9HYWxsZXJ5X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19jb21wb25lbnRfY29yb25hR2FsbGVyeV9WaWV3cG9ydF9tanMtc3JjX3NlbGVjdGlvbl9Nb2RlbF9tanNcIixcblx0XHRcImV4YW1wbGVzX2NvbXBvbmVudF9tdWx0aVdpbmRvd0Nvcm9uYUdhbGxlcnlfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9jb21wb25lbnQvbXVsdGlXaW5kb3dDb3JvbmFHYWxsZXJ5L2NoaWxkYXBwL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvbXVsdGlXaW5kb3dDb3JvbmFHYWxsZXJ5L2NoaWxkYXBwL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJleGFtcGxlc19jb21wb25lbnRfbXVsdGlXaW5kb3dDb3JvbmFHYWxsZXJ5X2NoaWxkYXBwX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L211bHRpV2luZG93SGVsaXgvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9tdWx0aVdpbmRvd0hlbGl4L2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfSGVsaXhfbWpzLXNyY19jb250YWluZXJfUGFuZWxfbWpzLXNyY19mb3JtX2ZpZWxkX1JhbmdlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19jb21wb25lbnRfaGVsaXhfVmlld3BvcnRfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzLXNyY190b29sYmFyX0Jhc2VfbWpzXCIsXG5cdFx0XCJleGFtcGxlc19jb21wb25lbnRfbXVsdGlXaW5kb3dIZWxpeF9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9tdWx0aVdpbmRvd0hlbGl4L2NoaWxkYXBwL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvbXVsdGlXaW5kb3dIZWxpeC9jaGlsZGFwcC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwiZXhhbXBsZXNfY29tcG9uZW50X211bHRpV2luZG93SGVsaXhfY2hpbGRhcHBfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9jb21wb25lbnQvbXdjL2J1dHRvbi9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L213Yy9idXR0b24vYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJleGFtcGxlc19jb21wb25lbnRfbXdjX2J1dHRvbl9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9td2MvYnV0dG9ucy9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L213Yy9idXR0b25zL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3RhYl9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2NvbXBvbmVudF9td2NfYnV0dG9uc19hcHBfbWpzLXNyY190b29sYmFyX0Jhc2VfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9td2MvdGV4dEZpZWxkL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvbXdjL3RleHRGaWVsZC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJleGFtcGxlc19jb21wb25lbnRfbXdjX3RleHRGaWVsZF9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9td2MvdGV4dEZpZWxkcy9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L213Yy90ZXh0RmllbGRzL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3RhYl9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2NvbXBvbmVudF9td2NfdGV4dEZpZWxkc19hcHBfbWpzLXNyY190b29sYmFyX0Jhc2VfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9wcm9jZXNzL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvcHJvY2Vzcy9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9Db21ib0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2xpc3RfQ29sb3JfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2NvbXBvbmVudF9wcm9jZXNzX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L3Byb2Nlc3MvcmVhbFdvcmxkRXhhbXBsZS9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L3Byb2Nlc3MvcmVhbFdvcmxkRXhhbXBsZS9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NvbWJvQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfVG9hc3RfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2NvbXBvbmVudF9wcm9jZXNzX3JlYWxXb3JsZEV4YW1wbGVfYXBwX21qcy1zcmNfc2VsZWN0aW9uX01vZGVsX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9jb21wb25lbnQvcHJvZ3Jlc3MvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9wcm9ncmVzcy9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwiZXhhbXBsZXNfY29tcG9uZW50X3Byb2dyZXNzX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L3NwbGl0dGVyL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvc3BsaXR0ZXIvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kcmFnZ2FibGVfRHJhZ1pvbmVfbWpzXCIsXG5cdFx0XCJleGFtcGxlc19jb21wb25lbnRfc3BsaXR0ZXJfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9jb21wb25lbnQvc3RhdHVzYmFkZ2UvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC9zdGF0dXNiYWRnZS9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfY29tcG9uZW50X3N0YXR1c2JhZGdlX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L3RpbWVyL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvdGltZXIvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9Db21ib0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2xpc3RfQ29sb3JfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2NvbXBvbmVudF90aW1lcl9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC90b2FzdC9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L3RvYXN0L2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NvbWJvQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfVG9hc3RfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2NvbXBvbmVudF90b2FzdF9hcHBfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC92aWRlby9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L3ZpZGVvL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9Ub2FzdF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfY29tcG9uZW50X3ZpZGVvX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L3dyYXBwZXIvY2VzaXVtSlMvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2NvbXBvbmVudC93cmFwcGVyL2Nlc2l1bUpTL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfY29tcG9uZW50X3dyYXBwZXJfY2VzaXVtSlNfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9jb21wb25lbnQvd3JhcHBlci9nb29nbGVNYXBzL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvd3JhcHBlci9nb29nbGVNYXBzL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RpYWxvZ19CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19jb21wb25lbnRfd3JhcHBlcl9nb29nbGVNYXBzX2FwcF9tanMtc3JjX2NvbnRhaW5lcl9QYW5lbF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvY29tcG9uZW50L3dyYXBwZXIvbW9uYWNvRWRpdG9yL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb21wb25lbnQvd3JhcHBlci9tb25hY29FZGl0b3IvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfd3JhcHBlcl9Nb25hY29FZGl0b3JfbWpzXCIsXG5cdFx0XCJleGFtcGxlc19jb21wb25lbnRfd3JhcHBlcl9tb25hY29FZGl0b3JfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9jb250YWluZXIvYWNjb3JkaW9uL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9jb250YWluZXIvYWNjb3JkaW9uL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19jb250YWluZXJfYWNjb3JkaW9uX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvY29udGFpbmVyL2Jhc2UvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2NvbnRhaW5lci9iYXNlL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcImV4YW1wbGVzX2NvbnRhaW5lcl9iYXNlX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvY29yZS9jb25maWcvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2NvcmUvY29uZmlnL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfY29yZV9jb25maWdfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9kYXNoYm9hcmQvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2Rhc2hib2FyZC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwiZXhhbXBsZXNfZGFzaGJvYXJkX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvZGF0ZS9zZWxlY3RvckNvbnRhaW5lci9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvZGF0ZS9zZWxlY3RvckNvbnRhaW5lci9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3N0YXRlX1Byb3ZpZGVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0RhdGVTZWxlY3Rvcl9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfZGF0ZV9zZWxlY3RvckNvbnRhaW5lcl9hcHBfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2RpYWxvZy9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvZGlhbG9nL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9Db21ib0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RpYWxvZ19CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19kaWFsb2dfYXBwX21qcy1zcmNfY29udGFpbmVyX1BhbmVsX21qcy1zcmNfc2VsZWN0aW9uX01vZGVsX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9maWVsZFdpdGhQcmVmaXgvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2ZpZWxkV2l0aFByZWZpeC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NvbWJvQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19maWVsZFdpdGhQcmVmaXhfYXBwX21qcy1zcmNfc2VsZWN0aW9uX01vZGVsX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9maWVsZHMvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2ZpZWxkcy9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9Db21ib0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3RhYl9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfRGF0ZVNlbGVjdG9yX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RpbWVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2ZpZWxkc19hcHBfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzLXNyY190b29sYmFyX0Jhc2VfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2Zvcm0vZmllbGQvY2hlY2tib3gvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2Zvcm0vZmllbGQvY2hlY2tib3gvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJleGFtcGxlc19mb3JtX2ZpZWxkX2NoZWNrYm94X2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvZm9ybS9maWVsZC9jaGlwL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9mb3JtL2ZpZWxkL2NoaXAvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9Db21ib0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfZm9ybV9maWVsZF9jaGlwX2FwcF9tanMtc3JjX3NlbGVjdGlvbl9Nb2RlbF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvZm9ybS9maWVsZC9jb2xvci9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvZm9ybS9maWVsZC9jb2xvci9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NvbWJvQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9Db2xvcl9tanMtc3JjX3NlbGVjdGlvbl9Nb2RlbF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfZm9ybV9maWVsZF9jb2xvcl9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2Zvcm0vZmllbGQvY29tYm9ib3gvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2Zvcm0vZmllbGQvY29tYm9ib3gvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9Db21ib0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfZm9ybV9maWVsZF9jb21ib2JveF9hcHBfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2Zvcm0vZmllbGQvZGF0ZS9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvZm9ybS9maWVsZC9kYXRlL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0RhdGVTZWxlY3Rvcl9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfZm9ybV9maWVsZF9kYXRlX2FwcF9tanMtc3JjX3NlbGVjdGlvbl9Nb2RlbF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvZm9ybS9maWVsZC9lbWFpbC9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvZm9ybS9maWVsZC9lbWFpbC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcImV4YW1wbGVzX2Zvcm1fZmllbGRfZW1haWxfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9mb3JtL2ZpZWxkL2ZpbGV1cGxvYWQvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2Zvcm0vZmllbGQvZmlsZXVwbG9hZC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19mb3JtX2ZpZWxkX2ZpbGV1cGxvYWRfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9mb3JtL2ZpZWxkL251bWJlci9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvZm9ybS9maWVsZC9udW1iZXIvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJleGFtcGxlc19mb3JtX2ZpZWxkX251bWJlcl9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2Zvcm0vZmllbGQvcGlja2VyL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9mb3JtL2ZpZWxkL3BpY2tlci9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfZm9ybV9maWVsZF9waWNrZXJfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9mb3JtL2ZpZWxkL3JhZGlvL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9mb3JtL2ZpZWxkL3JhZGlvL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwiZXhhbXBsZXNfZm9ybV9maWVsZF9yYWRpb19hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2Zvcm0vZmllbGQvc3dpdGNoL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9mb3JtL2ZpZWxkL3N3aXRjaC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcImV4YW1wbGVzX2Zvcm1fZmllbGRfc3dpdGNoX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvZm9ybS9maWVsZC90ZXh0L2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9mb3JtL2ZpZWxkL3RleHQvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2Zvcm1fZmllbGRfdGV4dF9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2Zvcm0vZmllbGQvdGV4dGFyZWEvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2Zvcm0vZmllbGQvdGV4dGFyZWEvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2Zvcm1fZmllbGRfdGV4dGFyZWFfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9mb3JtL2ZpZWxkL3RpbWUvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2Zvcm0vZmllbGQvdGltZS9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RpbWVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2Zvcm1fZmllbGRfdGltZV9hcHBfbWpzLXNyY19mb3JtX2ZpZWxkX1BpY2tlcl9tanMtc3JjX3NlbGVjdGlvbl9Nb2RlbF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvZm9ybS9maWVsZC90cmlnZ2VyL2NvcHlUb0NsaXBib2FyZC9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvZm9ybS9maWVsZC90cmlnZ2VyL2NvcHlUb0NsaXBib2FyZC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfZm9ybV9maWVsZF90cmlnZ2VyX2NvcHlUb0NsaXBib2FyZF9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2Zvcm0vZmllbGQvdXJsL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9mb3JtL2ZpZWxkL3VybC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcImV4YW1wbGVzX2Zvcm1fZmllbGRfdXJsX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvZm9ybS9maWVsZHNldC9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvZm9ybS9maWVsZHNldC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19mb3JtX2ZpZWxkc2V0X2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvZnVuY3Rpb25hbC9idXR0b24vYmFzZS9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvZnVuY3Rpb25hbC9idXR0b24vYmFzZS9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NvbWJvQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZnVuY3Rpb25hbF9jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfZnVuY3Rpb25hbF9idXR0b25fYmFzZV9hcHBfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2Z1bmN0aW9uYWwvZGVmaW5lQ29tcG9uZW50L2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9mdW5jdGlvbmFsL2RlZmluZUNvbXBvbmVudC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Z1bmN0aW9uYWxfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJleGFtcGxlc19mdW5jdGlvbmFsX2RlZmluZUNvbXBvbmVudF9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2Z1bmN0aW9uYWwvaG9zdENvbXBvbmVudC9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvZnVuY3Rpb25hbC9ob3N0Q29tcG9uZW50L2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZnVuY3Rpb25hbF9jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfZnVuY3Rpb25hbF9ob3N0Q29tcG9uZW50X2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvZnVuY3Rpb25hbC9uZXN0ZWRUZW1wbGF0ZUNvbXBvbmVudC9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvZnVuY3Rpb25hbC9uZXN0ZWRUZW1wbGF0ZUNvbXBvbmVudC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Z1bmN0aW9uYWxfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2Z1bmN0aW9uYWxfbmVzdGVkVGVtcGxhdGVDb21wb25lbnRfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9mdW5jdGlvbmFsL3RlbXBsYXRlQ29tcG9uZW50L2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9mdW5jdGlvbmFsL3RlbXBsYXRlQ29tcG9uZW50L2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZnVuY3Rpb25hbF9jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfZnVuY3Rpb25hbF90ZW1wbGF0ZUNvbXBvbmVudF9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2dyaWQvYW5pbWF0ZWRSb3dTb3J0aW5nL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9ncmlkL2FuaW1hdGVkUm93U29ydGluZy9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19ncmlkX0NvbnRhaW5lcl9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfZ3JpZF9hbmltYXRlZFJvd1NvcnRpbmdfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9ncmlkL2JpZ0RhdGEvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2dyaWQvYmlnRGF0YS9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2xpc3RfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ29tYm9Cb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY190YWJfQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZ3JpZF9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1JhZGlvX21qcy1zcmNfc2VsZWN0aW9uX2dyaWRfQ2VsbENvbHVtbk1vZGVsX21qcy1zcmNfc2VsZWN0aW9uX2dyaWRfQ2UtZjNhZDhmXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2dyaWRfYmlnRGF0YV9hcHBfbWpzLXNyY190b29sYmFyX0Jhc2VfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2dyaWQvY2VsbEVkaXRpbmcvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2dyaWQvY2VsbEVkaXRpbmcvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9Db21ib0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3N0YXRlX1Byb3ZpZGVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0RhdGVTZWxlY3Rvcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2dyaWRfQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9SYWRpb19tanMtc3JjX3NlbGVjdGlvbl9ncmlkX0NlbGxDb2x1bW5Nb2RlbF9tanMtc3JjX3NlbGVjdGlvbl9ncmlkX0NlLWYzYWQ4ZlwiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19ncmlkX2NlbGxFZGl0aW5nX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvZ3JpZC9jb250YWluZXIvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2dyaWQvY29udGFpbmVyL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2dyaWRfQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9SYWRpb19tanMtc3JjX3NlbGVjdGlvbl9ncmlkX0NlbGxDb2x1bW5Nb2RlbF9tanMtc3JjX3NlbGVjdGlvbl9ncmlkX0NlLWYzYWQ4ZlwiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19ncmlkX2NvbnRhaW5lcl9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2dyaWQvY292aWQvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2dyaWQvY292aWQvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2dyaWRfQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19ncmlkX2NvdmlkX2FwcF9tanMtc3JjX3Rvb2xiYXJfQmFzZV9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvZ3JpZC9uZXN0ZWRSZWNvcmRGaWVsZHMvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2dyaWQvbmVzdGVkUmVjb3JkRmllbGRzL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19zdGF0ZV9Qcm92aWRlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2dyaWRfQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X1RvYXN0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19ncmlkX25lc3RlZFJlY29yZEZpZWxkc19hcHBfbWpzLXNyY190b29sYmFyX0Jhc2VfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL2xheW91dC9jYXJkL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9sYXlvdXQvY2FyZC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcImV4YW1wbGVzX2xheW91dF9jYXJkX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvbGF5b3V0L2N1YmUvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2xheW91dC9jdWJlL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGF5b3V0X0N1YmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2xheW91dF9jdWJlX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvbGF5b3V0L2Zvcm0vYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2xheW91dC9mb3JtL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX2xheW91dF9mb3JtX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvbGlzdC9hbmltYXRlL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9saXN0L2FuaW1hdGUvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2xpc3RfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfbGlzdF9hbmltYXRlX2FwcF9tanMtc3JjX3NlbGVjdGlvbl9Nb2RlbF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvbGlzdC9iYXNlL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9saXN0L2Jhc2UvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19saXN0X2Jhc2VfYXBwX21qcy1zcmNfc2VsZWN0aW9uX01vZGVsX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9saXN0L2NoaXAvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL2xpc3QvY2hpcC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0NoaXBfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzXCIsXG5cdFx0XCJleGFtcGxlc19saXN0X2NoaXBfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9saXN0L2NpcmNsZS9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvbGlzdC9jaXJjbGUvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0NpcmNsZV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfbGlzdF9jaXJjbGVfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9saXN0L2NvbG9yL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9saXN0L2NvbG9yL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2xpc3RfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2xpc3RfQ29sb3JfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzXCIsXG5cdFx0XCJleGFtcGxlc19saXN0X2NvbG9yX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvbWVudS9saXN0L2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9tZW51L2xpc3QvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19tZW51X0xpc3RfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX21lbnVfbGlzdF9hcHBfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL21lbnUvcGFuZWwvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL21lbnUvcGFuZWwvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19tZW51X0xpc3RfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX21lbnVfcGFuZWxfYXBwX21qcy1zcmNfc2VsZWN0aW9uX01vZGVsX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9wYW5lbC9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvcGFuZWwvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19wYW5lbF9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL3BvcG92ZXIvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL3BvcG92ZXIvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJleGFtcGxlc19wb3BvdmVyX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvcHJlbG9hZGluZ0Fzc2V0cy9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvcHJlbG9hZGluZ0Fzc2V0cy9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY190YWJfQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19wcmVsb2FkaW5nQXNzZXRzX2FwcF9tanMtc3JjX3Rvb2xiYXJfQmFzZV9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvcmVtb3Rlc0FwaS9iYXNpYy9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvcmVtb3Rlc0FwaS9iYXNpYy9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX3JlbW90ZXNBcGlfYmFzaWNfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9zZXJ2ZXJzaWRlL2dyaWRDb250YWluZXIvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL3NlcnZlcnNpZGUvZ3JpZENvbnRhaW5lci9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJleGFtcGxlc19zZXJ2ZXJzaWRlX2dyaWRDb250YWluZXJfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9zZXJ2ZXJzaWRlL3Rvb2xiYXJJdGVtcy9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvc2VydmVyc2lkZS90b29sYmFySXRlbXMvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19zZXJ2ZXJzaWRlX3Rvb2xiYXJJdGVtc19hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL3NpdGVtYXAvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL3NpdGVtYXAvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX3NpdGVtYXBfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9zdGF0ZVByb3ZpZGVyL2FkdmFuY2VkL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9zdGF0ZVByb3ZpZGVyL2FkdmFuY2VkL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3N0YXRlX1Byb3ZpZGVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19zdGF0ZVByb3ZpZGVyX2FkdmFuY2VkX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvc3RhdGVQcm92aWRlci9kaWFsb2cvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL3N0YXRlUHJvdmlkZXIvZGlhbG9nL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3N0YXRlX1Byb3ZpZGVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19zdGF0ZVByb3ZpZGVyX2RpYWxvZ19hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL3N0YXRlUHJvdmlkZXIvZXh0ZW5kZWRDbGFzcy9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvc3RhdGVQcm92aWRlci9leHRlbmRlZENsYXNzL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3N0YXRlX1Byb3ZpZGVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19zdGF0ZVByb3ZpZGVyX2V4dGVuZGVkQ2xhc3NfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9zdGF0ZVByb3ZpZGVyL2lubGluZS9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvc3RhdGVQcm92aWRlci9pbmxpbmUvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfc3RhdGVfUHJvdmlkZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX3N0YXRlUHJvdmlkZXJfaW5saW5lX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvc3RhdGVQcm92aWRlci9pbmxpbmVOb1N0YXRlUHJvdmlkZXIvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL3N0YXRlUHJvdmlkZXIvaW5saW5lTm9TdGF0ZVByb3ZpZGVyL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfc3RhdGVQcm92aWRlcl9pbmxpbmVOb1N0YXRlUHJvdmlkZXJfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9zdGF0ZVByb3ZpZGVyL211bHRpV2luZG93L2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9zdGF0ZVByb3ZpZGVyL211bHRpV2luZG93L2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19zdGF0ZV9Qcm92aWRlcl9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfc3RhdGVQcm92aWRlcl9tdWx0aVdpbmRvd19hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL3N0YXRlUHJvdmlkZXIvbXVsdGlXaW5kb3cyL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy9zdGF0ZVByb3ZpZGVyL211bHRpV2luZG93Mi9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwiZXhhbXBsZXNfc3RhdGVQcm92aWRlcl9tdWx0aVdpbmRvdzJfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9zdGF0ZVByb3ZpZGVyL25lc3RlZERhdGEvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL3N0YXRlUHJvdmlkZXIvbmVzdGVkRGF0YS9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19zdGF0ZV9Qcm92aWRlcl9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfc3RhdGVQcm92aWRlcl9uZXN0ZWREYXRhX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvc3RhdGVQcm92aWRlci90YWJsZS9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvc3RhdGVQcm92aWRlci90YWJsZS9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfc3RhdGVfUHJvdmlkZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY190YWJsZV9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX3N0YXRlUHJvdmlkZXJfdGFibGVfYXBwX21qcy1zcmNfc2VsZWN0aW9uX01vZGVsX21qcy1zcmNfdG9vbGJhcl9CYXNlX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy9zdGF0ZVByb3ZpZGVyL3R3b1dheS9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvc3RhdGVQcm92aWRlci90d29XYXkvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3N0YXRlX1Byb3ZpZGVyX21qc1wiLFxuXHRcdFwiZXhhbXBsZXNfc3RhdGVQcm92aWRlcl90d29XYXlfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy90YWIvY29udGFpbmVyL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy90YWIvY29udGFpbmVyL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfdGFiX0NvbnRhaW5lcl9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfdGFiX2NvbnRhaW5lcl9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL3RhYmxlL2NlbGxFZGl0aW5nL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy90YWJsZS9jZWxsRWRpdGluZy9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NoZWNrQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc19Db25maWd1cmF0aW9uVmlld3BvcnRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NvbWJvQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfc3RhdGVfUHJvdmlkZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY190YWJsZV9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfRGF0ZVNlbGVjdG9yX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9SYWRpb19tanMtc3JjX3NlbGVjdGlvbl9Nb2RlbF9tanMtc3JjX3NlbGVjdGlvbl90YWJsZV9DZWxsTW9kZWxfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX3RhYmxlX2NlbGxFZGl0aW5nX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvdGFibGUvY29udGFpbmVyL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy90YWJsZS9jb250YWluZXIvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfQ29uZmlndXJhdGlvblZpZXdwb3J0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfdGFibGVfQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9SYWRpb19tanMtc3JjX3NlbGVjdGlvbl9Nb2RlbF9tanMtc3JjX3NlbGVjdGlvbl90YWJsZV9DZWxsTW9kZWxfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX3RhYmxlX2NvbnRhaW5lcl9hcHBfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL3RhYmxlL2NvdmlkL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy90YWJsZS9jb3ZpZC9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfdGFibGVfQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc190YWJsZV9jb3ZpZF9hcHBfbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzLXNyY190b29sYmFyX0Jhc2VfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL3RhYmxlL25lc3RlZFJlY29yZEZpZWxkcy9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvdGFibGUvbmVzdGVkUmVjb3JkRmllbGRzL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19zdGF0ZV9Qcm92aWRlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3RhYmxlX0NvbnRhaW5lcl9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfdGFibGVfbmVzdGVkUmVjb3JkRmllbGRzX2FwcF9tanMtc3JjX3NlbGVjdGlvbl9Nb2RlbF9tanMtc3JjX3Rvb2xiYXJfQmFzZV9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvdGFibGVGaWx0ZXJpbmcvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL3RhYmxlRmlsdGVyaW5nL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19saXN0X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NvbWJvQm94X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfdGFibGVfQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0RhdGVTZWxlY3Rvcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfUmFkaW9fbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzLXNyY19zZWxlY3Rpb25fdGFibGVfQ2VsbE1vZGVsX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc190YWJsZUZpbHRlcmluZ19hcHBfbWpzLXNyY190b29sYmFyX0Jhc2VfbWpzXCJcblx0XSxcblx0XCIuL2V4YW1wbGVzL3RhYmxlUGVyZm9ybWFuY2UvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL3RhYmxlUGVyZm9ybWFuY2UvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9OdW1iZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfdGFibGVfQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc190YWJsZVBlcmZvcm1hbmNlX2FwcF9tanMtc3JjX3NlbGVjdGlvbl9Nb2RlbF9tanMtc3JjX3Rvb2xiYXJfQmFzZV9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvdGFibGVTdG9yZS9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvdGFibGVTdG9yZS9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9DaGVja0JveF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3RhYmxlX0NvbnRhaW5lcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfUmFkaW9fbWpzLXNyY19zZWxlY3Rpb25fTW9kZWxfbWpzLXNyY19zZWxlY3Rpb25fdGFibGVfQ2VsbE1vZGVsX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc190YWJsZVN0b3JlX2FwcF9tanMtc3JjX3Rvb2xiYXJfQmFzZV9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvdGFicy9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvdGFicy9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1RleHRfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX051bWJlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2RhdGFfU3RvcmVfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY190YWJfQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfdGFibGVfQ29udGFpbmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc190YWJzX2FwcF9tanMtc3JjX3NlbGVjdGlvbl9Nb2RlbF9tanMtc3JjX3Rvb2xiYXJfQmFzZV9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvdG9kb0xpc3QvdmVyc2lvbjEvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL3RvZG9MaXN0L3ZlcnNpb24xL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwiZXhhbXBsZXNfdG9kb0xpc3RfdmVyc2lvbjFfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy90b2RvTGlzdC92ZXJzaW9uMi9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvdG9kb0xpc3QvdmVyc2lvbjIvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2xpc3RfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfdG9kb0xpc3RfdmVyc2lvbjJfYXBwX21qcy1zcmNfc2VsZWN0aW9uX01vZGVsX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy90b29sYmFyL2JyZWFkY3J1bWIvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL3Rvb2xiYXIvYnJlYWRjcnVtYi9hcHAubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbnRhaW5lcl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfYnV0dG9uX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc190b29sYmFyX2JyZWFkY3J1bWJfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy90b29sYmFyL3BhZ2luZy9hcHAubWpzXCI6IFtcblx0XHRcIi4vZXhhbXBsZXMvdG9vbGJhci9wYWdpbmcvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2xpc3RfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ29tYm9Cb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19zdGF0ZV9Qcm92aWRlcl9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3RhYmxlX0NvbnRhaW5lcl9tanNcIixcblx0XHRcInZlbmRvcnMtZXhhbXBsZXNfdG9vbGJhcl9wYWdpbmdfYXBwX21qcy1zcmNfc2VsZWN0aW9uX01vZGVsX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy90cmVlL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy90cmVlL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2xpc3RfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3NlbGVjdGlvbl9Nb2RlbF9tanMtc3JjX3RyZWVfTGlzdF9tanNcIixcblx0XHRcImV4YW1wbGVzX3RyZWVfYXBwX21qc1wiXG5cdF0sXG5cdFwiLi9leGFtcGxlcy90cmVlQWNjb3JkaW9uL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy90cmVlQWNjb3JkaW9uL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfVGV4dF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfTnVtYmVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ2hlY2tCb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX0NvbmZpZ3VyYXRpb25WaWV3cG9ydF9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2xpc3RfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3N0YXRlX1Byb3ZpZGVyX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfc2VsZWN0aW9uX01vZGVsX21qcy1zcmNfdHJlZV9MaXN0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1leGFtcGxlc190cmVlQWNjb3JkaW9uX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvdmlkZW9Nb3ZlL2FwcC5tanNcIjogW1xuXHRcdFwiLi9leGFtcGxlcy92aWRlb01vdmUvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwiZXhhbXBsZXNfdmlkZW9Nb3ZlX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvdmlld3BvcnQvYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL3ZpZXdwb3J0L2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX3RhYl9Db250YWluZXJfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLWV4YW1wbGVzX3ZpZXdwb3J0X2FwcF9tanMtc3JjX3Rvb2xiYXJfQmFzZV9tanNcIlxuXHRdLFxuXHRcIi4vZXhhbXBsZXMvd29ya2VyL3Rhc2svYXBwLm1qc1wiOiBbXG5cdFx0XCIuL2V4YW1wbGVzL3dvcmtlci90YXNrL2FwcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2NvbXBvbmVudF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29udGFpbmVyX0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19idXR0b25fQmFzZV9tanNcIixcblx0XHRcImV4YW1wbGVzX3dvcmtlcl90YXNrX2FwcF9tanNcIlxuXHRdLFxuXHRcIi4vdGVzdC9jb21wb25lbnRzL2FwcC5tanNcIjogW1xuXHRcdFwiLi90ZXN0L2NvbXBvbmVudHMvYXBwLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfY29tcG9uZW50X0Jhc2VfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2J1dHRvbl9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9UZXh0X21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZm9ybV9maWVsZF9CYXNlX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfZGF0YV9TdG9yZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2xpc3RfQmFzZV9tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX2Zvcm1fZmllbGRfQ29tYm9Cb3hfbWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19jb21wb25lbnRfRGF0ZVNlbGVjdG9yX21qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbGlzdF9DaGlwX21qcy1zcmNfc2VsZWN0aW9uX01vZGVsX21qc1wiLFxuXHRcdFwidGVzdF9jb21wb25lbnRzX2FwcF9tanNcIlxuXHRdXG59O1xuZnVuY3Rpb24gd2VicGFja0FzeW5jQ29udGV4dChyZXEpIHtcblx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhtYXAsIHJlcSkpIHtcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG5cdFx0XHR2YXIgZSA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIidcIik7XG5cdFx0XHRlLmNvZGUgPSAnTU9EVUxFX05PVF9GT1VORCc7XG5cdFx0XHR0aHJvdyBlO1xuXHRcdH0pO1xuXHR9XG5cblx0dmFyIGlkcyA9IG1hcFtyZXFdLCBpZCA9IGlkc1swXTtcblx0cmV0dXJuIFByb21pc2UuYWxsKGlkcy5zbGljZSgxKS5tYXAoX193ZWJwYWNrX3JlcXVpcmVfXy5lKSkudGhlbigoKSA9PiB7XG5cdFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oaWQpO1xuXHR9KTtcbn1cbndlYnBhY2tBc3luY0NvbnRleHQua2V5cyA9ICgpID0+IChPYmplY3Qua2V5cyhtYXApKTtcbndlYnBhY2tBc3luY0NvbnRleHQuaWQgPSBcIi4vLiBsYXp5IHJlY3Vyc2l2ZSBeXFxcXC5cXFxcLy4qXFxcXC5tanMkIGluY2x1ZGU6ICg/OlxcXFwvJTdDXFxcXFxcXFwpYXBwLm1qcyRcIjtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0FzeW5jQ29udGV4dDsiLCJjb25zdCBOZW8gPSBnbG9iYWxUaGlzLk5lbyB8fCB7fTtcblxuTmVvLmNvbmZpZyA9IE5lby5jb25maWcgfHwge307XG5cbi8qKlxuICogQ29uZmlnIG9iamVjdCBmb3IgdGhlIG5lby5tanMgZnJhbWV3b3JrIHdoaWNoIHdpbGwgZ2V0IHBhc3NlZCB0byBhbGwgd29ya2Vyc1xuICogWW91IGNhbiBjaGFuZ2UgdGhlIGNvbmZpZ3MsIGUuZy4gaW5zaWRlIHRoZSBpbmRleC5odG1sIG9mIHlvdXIgYXBwXG4gKiBAbWVtYmVyT2YgbW9kdWxlOk5lb1xuICogQG5hbWUgY29uZmlnXG4gKiBAdHlwZSBPYmplY3RcbiAqL1xuY29uc3QgRGVmYXVsdENvbmZpZyA9IHtcbiAgICAvKipcbiAgICAgKiB0cnVlIHdpbGwgYXBwbHkgJ25lby1ib2R5JyB0byB0aGUgZG9jdW1lbnQuYm9keSBjbGFzc0xpc3RcbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLmFwcGx5Qm9keUNsc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICBhcHBseUJvZHlDbHM6IHRydWUsXG4gICAgLyoqXG4gICAgICogdHJ1ZSB3aWxsIGFwcGx5ICdwb3NpdGlvbjogZml4ZWQnIHRvIHRoZSBodG1sIHRhZyBpdHNlbGZcbiAgICAgKiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9uZW9tanMvbmVvL2lzc3Vlcy82NDI5XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy5hcHBseUZpeGVkUG9zaXRpb25Ub0h0bWxUYWdcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgYXBwbHlGaXhlZFBvc2l0aW9uVG9IdG1sVGFnOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIFBhdGggdG8geW91ciBhcHAubWpzIGZpbGUuIFlvdSBjYW4gY3JlYXRlIG11bHRpcGxlIGFwcHMgdGhlcmUgaWYgbmVlZGVkLlxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcuYXBwUGF0aFxuICAgICAqIEB0eXBlIFN0cmluZ3xudWxsXG4gICAgICovXG4gICAgYXBwUGF0aDogbnVsbCxcbiAgICAvKipcbiAgICAgKiBQYXRoIHRvIHRoZSBuZW8ubWpzIGRpcmVjdG9yeVxuICAgICAqIEBkZWZhdWx0ICcuLydcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcuYmFzZVBhdGhcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKi9cbiAgICBiYXNlUGF0aDogJy4vJyxcbiAgICAvKipcbiAgICAgKiBQYXNzIGEgdG9rZW4gaW4gY2FzZSB5b3UgYXJlIHVzaW5nIHRoZSBDZXNpdW1KUyBtYWluIHRocmVhZCBhZGRvblxuICAgICAqIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL25lb21qcy9uZW8vYmxvYi9kZXYvc3JjL21haW4vYWRkb24vQ2VzaXVtSlMubWpzXG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLmNlc2l1bUpzVG9rZW5cbiAgICAgKiBAdHlwZSBTdHJpbmd8bnVsbFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRoaXMgY29uZmlnIHRvIGZhbHNlIHRvIGRpc2FibGUgdGhlIGNvbXBvbmVudCBsb2dnaW5nIHVzaW5nIEN0cmwtUmlnaHQtQ2xpY2tcbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLmVuYWJsZUNvbXBvbmVudExvZ2dlclxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICBlbmFibGVDb21wb25lbnRMb2dnZXI6IHRydWUsXG4gICAgLyoqXG4gICAgICogU2V0IHRoaXMgY29uZmlnIHRvIHRydWUgdG8gZW5hYmxlIHV0aWwuTG9nZ2VyIChOZW8ubG9nKCkpIGJhc2VkIGxvZ3MgaW4gcHJvZHVjdGlvblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLmVuYWJsZUxvZ3NJblByb2R1Y3Rpb25cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgZW5hYmxlTG9nc0luUHJvZHVjdGlvbjogZmFsc2UsXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuIFZhbGlkIHZhbHVlczogJ2RldmVsb3BtZW50JywgJ2Rpc3QvZGV2ZWxvcG1lbnQnLCAnZGlzdC9wcm9kdWN0aW9uJ1xuICAgICAqIFRoaXMgY29uZmlnIHdpbGwgZ2V0IGF1dG8tZ2VuZXJhdGVkXG4gICAgICogQGRlZmF1bHQgJ2Rpc3QvcHJvZHVjdGlvbidcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcuZW52aXJvbm1lbnRcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKi9cbiAgICBlbnZpcm9ubWVudDogJ2Rpc3QvcHJvZHVjdGlvbicsXG4gICAgLyoqXG4gICAgICogSW4gY2FzZSB5b3UgYXJlIHVzaW5nIHRoZSBHb29nbGVNYXBzIG1haW4gdGhyZWFkIGFkZG9uLCB5b3UgY2FuIHBhc3MgdGhlIEFQSSBrZXkgaGVyZS5cbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcuZ29vZ2xlTWFwc0FwaUtleVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogSW4gY2FzZSB5b3UgYXJlIHVzaW5nIHRoZSBHb29nbGVBbmFseXRpY3MgbWFpbiB0aHJlYWQgYWRkb24gb3IgdXNlR29vZ2xlQW5hbHl0aWNzOiB0cnVlLFxuICAgICAqIHlvdSBjYW4gY2hhbmdlIHRoZSBndGFnIGlkIGhlcmUuIFJlcXVpcmVkIGZvciB0aGUgb25saW5lIGV4YW1wbGVzIChnaCBwYWdlcylcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcuZ3RhZ0lkXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBGbGFnIGZvciBydW5uaW5nIG9uIGh0dHBzOi8vbmVvbWpzLmdpdGh1Yi5pby9wYWdlcy9cbiAgICAgKiA9PiB0byB1c2UgbG9jYWwgaW1hZ2VzIHBhdGhzIGluc3RlYWQgb2YgcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLmlzR2l0SHViUGFnZXNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgaXNHaXRIdWJQYWdlczogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBGbGFnIGZvciBydW5uaW5nIHRoZSBOZW8gbWFpbiB0aHJlYWQgaW5zaWRlIGFuIGlmcmFtZSAoU2llc3RhIEJyb3dzZXIgSGFybmVzcylcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy5pc0luc2lkZVNpZXN0YVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICBpc0luc2lkZVNpZXN0YTogZmFsc2UsXG4gICAgLyoqXG4gICAgICogZGVsYXkgaW4gbXMgZm9yIHRoZSB3b3JrZXIuTWFuYWdlcjpsb2FkQXBwbGljYXRpb24oKSBjYWxsXG4gICAgICogQGRlZmF1bHQgMjBcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcubG9hZEFwcGxpY2F0aW9uRGVsYXlcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICBsb2FkQXBwbGljYXRpb25EZWxheTogMjAsXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBJbnRsLkRhdGVUaW1lRm9ybWF0LCBmb3IgZGV0YWlscyB0YWtlIGEgbG9vayBhdDpcbiAgICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlVGltZUZvcm1hdFxuICAgICAqIEBkZWZhdWx0ICdkZWZhdWx0J1xuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy5sb2NhbGVcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKi9cbiAgICBsb2NhbGU6ICdkZWZhdWx0JyxcbiAgICAvKipcbiAgICAgKiB0cnVlIHdpbGwgbG9nIHRoZSBkZWx0YSB1cGRhdGVzIGluc2lkZSB0aGUgbWFpbiB0aHJlYWQocykgYXMgd2VsbCBhcyB0aGUgcmVxdWVzdEFuaW1hdGlvbiBmcmFtZXNcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy5sb2dEZWx0YVVwZGF0ZXNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgbG9nRGVsdGFVcGRhdGVzOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiB0cnVlIHdpbGwgbG9nIGNvbnNvbGUgd2FybmluZ3MsIGluIGNhc2UgYSBjb21wb25lbnQgdHJpZXMgdG8gdXBkYXRlKCkgd2hpbGUgYSBwYXJlbnQgdXBkYXRlIGlzIHJ1bm5pbmcuXG4gICAgICogQSBwYXJlbnQgdXBkYXRlIHJlc3VsdHMgaW4gYSBzaG9ydCBkZWxheSwgc28geW91IG1pZ2h0IHdhbnQgdG8gcmVzb2x2ZSB0aGVzZSBjb2xsaXNpb25zLlxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLmxvZ1Zkb21VcGRhdGVDb2xsaXNpb25zXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIGxvZ1Zkb21VcGRhdGVDb2xsaXNpb25zOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBBZGQgYWRkb25zIGZvciB0aGUgbWFpbiB0aHJlYWRcbiAgICAgKiAuL3NyYy9tYWluL2FkZG9uLyBjb250YWlucyBhbGwgZnJhbWV3b3JrIHJlbGF0ZWQgb3B0aW9ucy5cbiAgICAgKiBZb3UgY2FuIGFsc28gY3JlYXRlIHlvdXIgb3duIGFkZG9ucyB3aXRoaW4geW91ciB3b3Jrc3BhY2Ugc2NvcGUuIE1ha2Ugc3VyZSB0byBwdXQgdGhlbSBpbnNpZGUgJ3NyYy9tYWluL2FkZG9uLydcbiAgICAgKiBhbmQgcHJlZml4IHRoZW0gd2l0aCAnV1MvJyBpbnNpZGUgeW91ciBuZW8tY29uZmlnLmpzb24gZmlsZS5cbiAgICAgKiBFeGFtcGxlOiBbJ0RyYWdEcm9wJywgJ1N0eWxlc2hlZXQnLCAnV1MvTXlBZGRvbiddXG4gICAgICogQGRlZmF1bHQgWydEcmFnRHJvcCcsICdOYXZpZ2F0b3InLCAnU3R5bGVzaGVldCddXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLm1haW5UaHJlYWRBZGRvbnNcbiAgICAgKiBAdHlwZSBTdHJpbmdbXVxuICAgICAqL1xuICAgIG1haW5UaHJlYWRBZGRvbnM6IFsnRHJhZ0Ryb3AnLCAnTmF2aWdhdG9yJywgJ1N0eWxlc2hlZXQnXSxcbiAgICAvKipcbiAgICAgKiBQYXNzIHRoZSBVUkwgb2YgYSBKU09OLWZpbGUsIHdoaWNoIGNvbnRhaW5zIHRoZSBzZXJ2aWNlcyBhbmQgbWV0aG9kcyBmcm9tIHlvdXIgYmFja2VuZCxcbiAgICAgKiB3aGljaCB5b3Ugd2FudCB0byBleHBvc2UgdG8gdGhlIGNsaWVudC5cbiAgICAgKiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9uZW9tanMvbmVvL3Byb2plY3RzLzMyXG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy5yZW1vdGVzQXBpVXJsXG4gICAgICogQHR5cGUgU3RyaW5nfG51bGxcbiAgICAgKi9cbiAgICByZW1vdGVzQXBpVXJsOiBudWxsLFxuICAgIC8qKlxuICAgICAqIFlvdSBjYW4gdmlzdWFsbHkgc2hvdyB0aGUgYW1vdW50IG9mIGRlbHRhIHVwZGF0ZXMgcGVyIHNlY29uZCB1c2luZyB0aGlzIGNvbmZpZy5cbiAgICAgKiBJdCBleHBlY3RzIGEgZG9tIG5vZGUgd2l0aCB0aGUgaWQgXCJuZW8tZGVsdGEtdXBkYXRlc1wiIGFzIHRoZSByZW5kZXJpbmcgdGFyZ2V0LlxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLnJlbmRlckNvdW50RGVsdGFzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHJlbmRlckNvdW50RGVsdGFzOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBBZGQgdGhlbWVzIHlvdSB3YW50IHRvIHVzZSBoZXJlLiBUaGUgZmlyc3QgdGhlbWUgd2lsbCBnZXQgYXBwbGllZC5cbiAgICAgKiBAZGVmYXVsdCBbJ25lby10aGVtZS1saWdodCcsJ25lby10aGVtZS1kYXJrJywnbmVvLXRoZW1lLW5lby1saWdodCddXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLnRoZW1lc1xuICAgICAqIEB0eXBlIFN0cmluZ1tdXG4gICAgICovXG4gICAgdGhlbWVzOiBbJ25lby10aGVtZS1saWdodCcsICduZW8tdGhlbWUtZGFyaycsICduZW8tdGhlbWUtbmVvLWxpZ2h0J10sXG4gICAgLyoqXG4gICAgICogRmxhZyBmb3Igc3RhbmRhbG9uZSBTaWVzdGEgbW9kdWxlIHRlc3RzID0+IHByZXZlbnQgcmVnaXN0ZXJSZW1vdGUgd29ya2VyIG1lc3NhZ2VzXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcudW5pdFRlc3RNb2RlXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHVuaXRUZXN0TW9kZTogZmFsc2UsXG4gICAgLyoqXG4gICAgICogV2hlbiB1bml0VGVzdE1vZGUgaXMgdHJ1ZSwgdGhpcyBmbGFnIGNhbiBiZSBlbmFibGVkIHRvIGFsbG93IFZET00tcmVsYXRlZFxuICAgICAqIG9wZXJhdGlvbnMgbGlrZSBpbml0Vm5vZGUoKSBhbmQgdXBkYXRlKCkgdG8gcHJvY2VlZC4gVGhpcyBpcyB1c2VmdWwgZm9yIGludGVncmF0aW9uLXN0eWxlXG4gICAgICogdGVzdHMgdGhhdCBuZWVkIHRvIHZlcmlmeSBjb21wb25lbnQgbGlmZWN5Y2xlIGFuZCBET00gb3V0cHV0LlxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLmFsbG93VmRvbVVwZGF0ZXNJblRlc3RzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIGFsbG93VmRvbVVwZGF0ZXNJblRlc3RzOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBFeHBlcmltZW50YWwgZmxhZyBpZiBhbiBvZmZzY3JlZW4gY2FudmFzIHdvcmtlciBzaG91bGQgZ2V0IGNyZWF0ZWQuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcudXNlQ2FudmFzV29ya2VyXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHVzZUNhbnZhc1dvcmtlcjogZmFsc2UsXG4gICAgLyoqXG4gICAgICogYHRydWVgIHdpbGwgZW5hYmxlIHRoZSBhZHZhbmNlZCwgc2VjdXJlLCBhbmQgcGVyZm9ybWFudCBkaXJlY3QgRE9NIEFQSSByZW5kZXJpbmcgc3RyYXRlZ3kgKHJlY29tbWVuZGVkKS5cbiAgICAgKiBJbiB0aGlzIG1vZGUsIGBOZW8udmRvbS5IZWxwZXJgIHdpbGwgY3JlYXRlIGFuZCBzZW5kIHN0cnVjdHVyZWQgVk5vZGUgb2JqZWN0IGdyYXBocyB0byB0aGUgTWFpbiBUaHJlYWQuXG4gICAgICogYE5lby5tYWluLkRlbHRhVXBkYXRlc2Agd2lsbCB0aGVuIHVzZSBgTmVvLm1haW4ucmVuZGVyLkRvbUFwaVJlbmRlcmVyYCB0byBkaXJlY3RseSBtYW5pcHVsYXRlIHRoZSBET00uXG4gICAgICogQ3J1Y2lhbGx5LCBgTmVvLm1haW4ucmVuZGVyLkRvbUFwaVJlbmRlcmVyYCBidWlsZHMgbmV3ICoqRE9NIHN1YnRyZWVzKiogKGZyb20gdGhlIHJlY2VpdmVkIFZOb2RlIG9iamVjdCBncmFwaHMpXG4gICAgICogYXMgZGV0YWNoZWQgRG9jdW1lbnRGcmFnbWVudHMgb3IgZWxlbWVudHMsIGVudGlyZWx5IG91dHNpZGUgdGhlIGxpdmUgRE9NIHRyZWUuXG4gICAgICogVGhlc2UgZnVsbHkgY29uc3RydWN0ZWQgZnJhZ21lbnRzIGFyZSB0aGVuIGluc2VydGVkIGludG8gdGhlIGxpdmUgZG9jdW1lbnQgaW4gYSAqKnNpbmdsZSwgYXRvbWljIG9wZXJhdGlvbioqLlxuICAgICAqIFRoaXMgYXBwcm9hY2ggaW5oZXJlbnRseSBtaW5pbWl6ZXMgY29zdGx5IGJyb3dzZXIgcmVmbG93cy9yZXBhaW50cywgZHJhc3RpY2FsbHkgcmVkdWNlcyBDcm9zcy1TaXRlIFNjcmlwdGluZyAoWFNTKSByaXNrcyxcbiAgICAgKiBhbmQgb3B0aW1pemVzIGZvciBzdXJnaWNhbCwgYXRvbWljIERPTSB1cGRhdGVzIGZvciB1bnBhcmFsbGVsZWQgcGVyZm9ybWFuY2UuXG4gICAgICpcbiAgICAgKiBgZmFsc2VgIHdpbGwgZW5hYmxlIHRoZSBsZWdhY3kgc3RyaW5nLWJhc2VkIHJlbmRlcmluZyBzdHJhdGVneS5cbiAgICAgKiBJbiB0aGlzIG1vZGUsIGBOZW8udmRvbS5IZWxwZXJgIHdpbGwgZ2VuZXJhdGUgY29tcGxldGUgSFRNTCBzdHJpbmdzIChgb3V0ZXJIVE1MYCkgZm9yIFZOb2RlIHN1YnRyZWVzLlxuICAgICAqIGBOZW8ubWFpbi5EZWx0YVVwZGF0ZXNgIHdpbGwgdGhlbiB1c2UgYE5lby5tYWluLnJlbmRlci5TdHJpbmdCYXNlZFJlbmRlcmVyYCB0byBpbnNlcnQgdGhlc2VcbiAgICAgKiBzdHJpbmdzIGludG8gdGhlIERPTSB1c2luZyBtZXRob2RzIGxpa2UgYHBhcmVudE5vZGUuaW5zZXJ0QWRqYWNlbnRIVE1MKClgLlxuICAgICAqIFdoaWxlIHBlcmZvcm1hbnQgZm9yIGxhcmdlIGluc2VydGlvbnMsIHRoaXMgbW9kZSBpcyBnZW5lcmFsbHkgbGVzcyBzZWN1cmUgZHVlIHRvIHBvdGVudGlhbCBYU1MgdmVjdG9yc1xuICAgICAqIGFuZCByZWxpZXMgb24gYnJvd3NlciBIVE1MIHBhcnNpbmcsIHdoaWNoIGNhbiBiZSBsZXNzIGVmZmljaWVudCBmb3IgZ3JhbnVsYXIgdXBkYXRlcy5cbiAgICAgKlxuICAgICAqIFRoaXMgY29uZmlndXJhdGlvbiBhZmZlY3RzIGJvdGggdGhlIGluaXRpYWwgcGFpbnRpbmcgb2YgeW91ciBhcHBsaWNhdGlvbnMgYW5kIHRoZSBjcmVhdGlvblxuICAgICAqIG9mIG5ldyBjb21wb25lbnQgdHJlZXMgYXQgcnVudGltZS5cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLnVzZURvbUFwaVJlbmRlcmVyXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHVzZURvbUFwaVJlbmRlcmVyOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIEZsYWcgaWYgdmRvbSBpZHMgc2hvdWxkIGdldCBtYXBwZWQgaW50byBET00gZWxlbWVudCBpZHMuXG4gICAgICogZmFsc2Ugd2lsbCBjb252ZXJ0IHRoZW0gaW50byBhIFwiZGF0YS1uZW8taWRcIiBhdHRyaWJ1dGUuXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy51c2VEb21JZHNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdXNlRG9tSWRzOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIFRydWUgd2lsbCBhdXRvbWF0aWNhbGx5IGluY2x1ZGUgdGhlIHN0eWxlc2hlZXRcbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLnVzZUZvbnRBd2Vzb21lXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHVzZUZvbnRBd2Vzb21lOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIEludGVuZGVkIGZvciB0aGUgb25saW5lIGV4YW1wbGVzIHdoZXJlIHdlIG5lZWQgYW4gZWFzeSB3YXkgdG8gYWRkIEdBIHRvIGV2ZXJ5IGdlbmVyYXRlZCBhcHBcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy51c2VHb29nbGVBbmFseXRpY3NcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdXNlR29vZ2xlQW5hbHl0aWNzOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBUcnVlIHdpbGwgYWRkIHRoZSBTZXJ2aWNlV29ya2VyIG1haW4gdGhyZWFkIGFkZG9uIHRvIHN1cHBvcnQgY2FjaGluZyBvZiBhc3NldHMgKFBXQSlcbiAgICAgKiBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TZXJ2aWNlX1dvcmtlcl9BUElcbiAgICAgKlxuICAgICAqIFlvdSBjYW4gYWxzbyB1c2UgYSBzdHJpbmcgdG8gc3BlY2lmeSB0aGUgdGFyZ2V0IGVudmlyb25tZW50ID0+ICdkaXN0L3Byb2R1Y3Rpb24nLlxuICAgICAqIFVzaW5nICdkaXN0L3Byb2R1Y3Rpb24nIHdpbGwgYWxzbyB1c2UgdGhlIHNlcnZpY2Ugd29ya2VyIGZvciAnZGlzdC9lc20nXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcudXNlU2VydmljZVdvcmtlclxuICAgICAqIEB0eXBlIEJvb2xlYW58U3RyaW5nXG4gICAgICovXG4gICAgdXNlU2VydmljZVdvcmtlcjogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBBcHAsIERhdGEgJiBWRG9tIGFzIFNoYXJlZFdvcmtlcnMuXG4gICAgICogU2V0IHRoaXMgb25lIHRvIHRydWUgaW4gY2FzZSB5b3Ugd2FudCB0byBjb25uZWN0IG11bHRpcGxlIG1haW4gdGhyZWFkcy5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy51c2VTaGFyZWRXb3JrZXJzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHVzZVNoYXJlZFdvcmtlcnM6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIFRydWUgd2lsbCBnZW5lcmF0ZSBhIG5ldyB0YXNrIHdvcmtlciwgd2hpY2ggY2FuIGdldCBmaWxsZWQgd2l0aCBvd24gZXhwZW5zaXZlIHJlbW90ZSBtZXRob2RzXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcudXNlVGFza1dvcmtlclxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICB1c2VUYXNrV29ya2VyOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBGYWxzZSB3aWxsIGNyZWF0ZSB0aGUgdmRvbS5IZWxwZXIgd2l0aGluIHRoZSBBcHAgd29ya2VyIChleHBlcmltZW50YWwhKVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcudXNlVmRvbVdvcmtlclxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICB1c2VWZG9tV29ya2VyOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIGJ1aWxkU2NyaXB0cy9pbmplY3RQYWNrYWdlVmVyc2lvbi5tanMgd2lsbCB1cGRhdGUgdGhpcyB2YWx1ZVxuICAgICAqIEBkZWZhdWx0ICcxMC41LjQnXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLnZlcnNpb25cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKi9cbiAgICB2ZXJzaW9uOiAnMTAuNS40J1xufTtcblxuT2JqZWN0LmFzc2lnbihEZWZhdWx0Q29uZmlnLCB7XG4gICAgLyoqXG4gICAgICogUGF0aCB0byB0aGUgdG9wIGxldmVsIG5lby5tanMgcmVzb3VyY2VzIGZvbGRlclxuICAgICAqIEBkZWZhdWx0IE5lby5jb25maWcuYmFzZVBhdGggKyAncmVzb3VyY2VzLydcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcucmVzb3VyY2VzUGF0aFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqL1xuICAgIHJlc291cmNlc1BhdGg6IGAke05lby5jb25maWcuYmFzZVBhdGggfHwgRGVmYXVsdENvbmZpZy5iYXNlUGF0aH1yZXNvdXJjZXMvYCxcbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBiYXNlIFVSTCBmb3Igd2ViIHdvcmtlciBlbnRyeSBwb2ludHMgKEFwcCwgRGF0YSwgVmRvbSlcbiAgICAgKiBAZGVmYXVsdCBOZW8uY29uZmlnLmJhc2VQYXRoICsgJ3NyYy93b3JrZXIvJ1xuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy53b3JrZXJCYXNlUGF0aFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqL1xuICAgIHdvcmtlckJhc2VQYXRoOiBgJHtOZW8uY29uZmlnLmJhc2VQYXRoIHx8IERlZmF1bHRDb25maWcuYmFzZVBhdGh9c3JjL3dvcmtlci9gLFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IERlZmF1bHRDb25maWc7XG4iLCJpbXBvcnQgRGVmYXVsdENvbmZpZyAgZnJvbSAnLi9EZWZhdWx0Q29uZmlnLm1qcyc7XG5pbXBvcnQge2lzRGVzY3JpcHRvcn0gZnJvbSAnLi9jb3JlL0NvbmZpZ1N5bWJvbHMubWpzJztcblxuY29uc3RcbiAgICBjYW1lbFJlZ2V4ICAgPSAvLS4vZyxcbiAgICBjb25maWdTeW1ib2wgPSBTeW1ib2wuZm9yKCdjb25maWdTeW1ib2wnKSxcbiAgICBnZXRTZXRDYWNoZSAgPSBTeW1ib2woJ2dldFNldENhY2hlJyksXG4gICAgY2xvbmVNYXAgPSB7XG4gICAgICAgIEFycmF5KG9iaiwgZGVlcCwgaWdub3JlTmVvSW5zdGFuY2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gIWRlZXAgPyBbLi4ub2JqXSA6IFsuLi5vYmoubWFwKHZhbCA9PiBOZW8uY2xvbmUodmFsLCBkZWVwLCBpZ25vcmVOZW9JbnN0YW5jZXMpKV1cbiAgICAgICAgfSxcbiAgICAgICAgRGF0ZShvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShvYmoudmFsdWVPZigpKVxuICAgICAgICB9LFxuICAgICAgICBNYXAob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1hcChvYmopIC8vIHNoYWxsb3cgY29weVxuICAgICAgICB9LFxuICAgICAgICBOZW9JbnN0YW5jZShvYmosIGlnbm9yZU5lb0luc3RhbmNlcykge1xuICAgICAgICAgICAgcmV0dXJuIGlnbm9yZU5lb0luc3RhbmNlcyA/IG9iaiA6IE5lby5jbG9uZU5lb0luc3RhbmNlKG9iailcbiAgICAgICAgfSxcbiAgICAgICAgU2V0KG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTZXQob2JqKVxuICAgICAgICB9LFxuICAgICAgICBPYmplY3Qob2JqLCBkZWVwLCBpZ25vcmVOZW9JbnN0YW5jZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IG91dCA9IHt9O1xuXG4gICAgICAgICAgICAvLyBVc2UgUmVmbGVjdC5vd25LZXlzKCkgdG8gaW5jbHVkZSBzeW1ib2wgcHJvcGVydGllcyAoZS5nLiwgZm9yIGNvbmZpZyBkZXNjcmlwdG9ycylcbiAgICAgICAgICAgIFJlZmxlY3Qub3duS2V5cyhvYmopLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgIG91dFtrZXldID0gIWRlZXAgPyB2YWx1ZSA6IE5lby5jbG9uZSh2YWx1ZSwgZGVlcCwgaWdub3JlTmVvSW5zdGFuY2VzKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBvdXRcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdHlwZURldGVjdG9yID0ge1xuICAgICAgICBmdW5jdGlvbjogaXRlbSA9PiB7XG4gICAgICAgICAgICBpZiAoaXRlbS5wcm90b3R5cGU/LmNvbnN0cnVjdG9yPy5pc0NsYXNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdOZW9DbGFzcydcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb2JqZWN0OiBpdGVtID0+IHtcbiAgICAgICAgICAgIGlmIChpdGVtLmNvbnN0cnVjdG9yPy5pc0NsYXNzICYmIGl0ZW0gaW5zdGFuY2VvZiBOZW8uY29yZS5CYXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdOZW9JbnN0YW5jZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbi8qKlxuICogVGhlIGJhc2UgbW9kdWxlIHRvIGVuaGFuY2UgY2xhc3NlcywgY3JlYXRlIGluc3RhbmNlcyBhbmQgdGhlIE5lbyBuYW1lc3BhY2VcbiAqIEBtb2R1bGUgTmVvXG4gKiBAc2luZ2xldG9uXG4gKiBAYm9ycm93cyBOZW8uY29yZS5VdGlsLmJpbmRNZXRob2RzICAgICAgIGFzIGJpbmRNZXRob2RzXG4gKiBAYm9ycm93cyBOZW8uY29yZS5VdGlsLmNyZWF0ZVN0eWxlT2JqZWN0IGFzIGNyZWF0ZVN0eWxlT2JqZWN0XG4gKiBAYm9ycm93cyBOZW8uY29yZS5VdGlsLmNyZWF0ZVN0eWxlcyAgICAgIGFzIGNyZWF0ZVN0eWxlc1xuICogQGJvcnJvd3MgTmVvLmNvcmUuVXRpbC5kZWNhbWVsICAgICAgICAgICBhcyBkZWNhbWVsXG4gKiBAYm9ycm93cyBOZW8uY29yZS5VdGlsLmlzQXJyYXkgICAgICAgICAgIGFzIGlzQXJyYXlcbiAqIEBib3Jyb3dzIE5lby5jb3JlLlV0aWwuaXNCb29sZWFuICAgICAgICAgYXMgaXNCb29sZWFuXG4gKiBAYm9ycm93cyBOZW8uY29yZS5VdGlsLmlzRGVmaW5lZCAgICAgICAgIGFzIGlzRGVmaW5lZFxuICogQGJvcnJvd3MgTmVvLmNvcmUuQ29tcGFyZS5pc0VxdWFsICAgICAgICBhcyBpc0VxdWFsXG4gKiBAYm9ycm93cyBOZW8uY29yZS5VdGlsLmlzTnVtYmVyICAgICAgICAgIGFzIGlzTnVtYmVyXG4gKiBAYm9ycm93cyBOZW8uY29yZS5VdGlsLmlzT2JqZWN0ICAgICAgICAgIGFzIGlzT2JqZWN0XG4gKiBAYm9ycm93cyBOZW8uY29yZS5VdGlsLmlzU3RyaW5nICAgICAgICAgIGFzIGlzU3RyaW5nXG4gKiBAYm9ycm93cyBOZW8uY29yZS5VdGlsLnRvQXJyYXkgICAgICAgICAgIGFzIHRvQXJyYXlcbiAqIEB0dXRvcmlhbCAwMV9Db25jZXB0XG4gKi9cbmxldCBOZW8gPSBnbG9iYWxUaGlzLk5lbyB8fCB7fTtcblxuTmVvID0gZ2xvYmFsVGhpcy5OZW8gPSBPYmplY3QuYXNzaWduKHtcbiAgICAvKipcbiAgICAgKiBBIG1hcCBjb250YWluaW5nIG50eXBlcyBhcyBrZXkgYW5kIE5lbyBjbGFzc2VzIG9yIHNpbmdsZXRvbnMgYXMgdmFsdWVzXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqL1xuICAgIG50eXBlTWFwOiB7fSxcbiAgICAvKipcbiAgICAgKiBOZWVkZWQgZm9yIE5lby5jcmVhdGUuIEZhbHNlIGZvciB0aGUgbWFpbiB0aHJlYWQsIHRydWUgZm9yIHRoZSBBcHAsIERhdGEgJiBWZG9tIHdvcmtlclxuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgaW5zaWRlV29ya2VyOiB0eXBlb2YgRGVkaWNhdGVkV29ya2VyR2xvYmFsU2NvcGUgIT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcsXG5cbiAgICAvKipcbiAgICAgKiBNYXBzIG1ldGhvZHMgZnJvbSBvbmUgbmFtZXNwYWNlIHRvIGFub3RoZXIgb25lXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBhbGlhc2VzXG4gICAgICogTmVvLmFwcGx5RnJvbU5zKE5lbywgVXRpbCwge1xuICAgICAqICAgICBjcmVhdGVTdHlsZU9iamVjdDogJ2NyZWF0ZVN0eWxlT2JqZWN0JyxcbiAgICAgKiAgICAgY3JlYXRlU3R5bGVzICAgICA6ICdjcmVhdGVTdHlsZXMnLFxuICAgICAqICAgICBjYXBpdGFsaXplICAgICAgIDogJ2NhcGl0YWxpemUnXG4gICAgICogfSwgdHJ1ZSk7XG4gICAgICpcbiAgICAgKiAvLyBlLmcuIE5lby5jb3JlLlV0aWwuaXNPYmplY3QgPT4gTmVvLmlzT2JqZWN0XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpOZW9cbiAgICAgKiBAcGFyYW0ge05lb3xOZW8uY29yZS5CYXNlfSB0YXJnZXQgICAgVGhlIHRhcmdldCBjbGFzcyBvciBzaW5nbGV0b24gSW5zdGFuY2Ugb3IgTmVvXG4gICAgICogQHBhcmFtIHtOZW8uY29yZS5CYXNlfSAgICAgbmFtZXNwYWNlIFRoZSBjbGFzcyBjb250YWluaW5nIHRoZSBtZXRob2RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICAgY29uZmlnXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICAgICAgW2JpbmRdICAgIHNldCB0aGlzIHRvIHRydWUgaW4gY2FzZSB5b3Ugd2FudCB0byBiaW5kIG1ldGhvZHMgdG8gdGhlIFwiZnJvbVwiIG5hbWVzcGFjZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHRhcmdldFxuICAgICAqL1xuICAgIGFwcGx5RnJvbU5zKHRhcmdldCwgbmFtZXNwYWNlLCBjb25maWcsIGJpbmQpIHtcbiAgICAgICAgbGV0IGZuTmFtZTtcblxuICAgICAgICBpZiAodGFyZ2V0ICYmIE5lby50eXBlT2YoY29uZmlnKSA9PT0gJ09iamVjdCcpIHtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGNvbmZpZykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgZm5OYW1lID0gbmFtZXNwYWNlW3ZhbHVlXTtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IGJpbmQgPyBmbk5hbWUuYmluZChuYW1lc3BhY2UpIDogZm5OYW1lXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYXBzIGEgY2xhc3MgdG8gdGhlIGdsb2JhbCBOZW8gb3IgQXBwIG5hbWVzcGFjZS5cbiAgICAgKiBDYW4gZ2V0IGNhbGxlZCBmb3IgY2xhc3NlcyBhbmQgc2luZ2xldG9uIGluc3RhbmNlc1xuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6TmVvXG4gICAgICogQHBhcmFtIHtOZW8uY29yZS5CYXNlfSBjbHNcbiAgICAgKi9cbiAgICBhcHBseVRvR2xvYmFsTnMoY2xzKSB7XG4gICAgICAgIGxldCBwcm90byAgICAgPSB0eXBlb2YgY2xzID09PSAnZnVuY3Rpb24nID8gY2xzLnByb3RvdHlwZSA6IGNscyxcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IHByb3RvLmlzQ2xhc3MgPyBwcm90by5jb25maWcuY2xhc3NOYW1lIDogcHJvdG8uY2xhc3NOYW1lLFxuICAgICAgICAgICAgbnNBcnJheSAgID0gY2xhc3NOYW1lLnNwbGl0KCcuJyksXG4gICAgICAgICAgICBrZXkgICAgICAgPSBuc0FycmF5LnBvcCgpLFxuICAgICAgICAgICAgbnMgICAgICAgID0gTmVvLm5zKG5zQXJyYXksIHRydWUpO1xuXG4gICAgICAgIG5zW2tleV0gPSBjbHNcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIGFsbCBrZXlzIG9mIGRlZmF1bHRzIGludG8gdGFyZ2V0LCBpbiBjYXNlIHRoZXkgZG9uJ3QgYWxyZWFkeSBleGlzdFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6TmVvXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCAgIFRoZSB0YXJnZXQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRzIFRoZSBvYmplY3QgY29udGFpbmluZyB0aGUga2V5cyB5b3Ugd2FudCB0byBjb3B5XG4gICAgICogQHJldHVybnMge09iamVjdH0gdGFyZ2V0XG4gICAgICovXG4gICAgYXNzaWduRGVmYXVsdHModGFyZ2V0LCBkZWZhdWx0cykge1xuICAgICAgICBpZiAodGFyZ2V0ICYmIE5lby50eXBlT2YoZGVmYXVsdHMpID09PSAnT2JqZWN0Jykge1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoZGVmYXVsdHMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghT2JqZWN0Lmhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgYSBuZXcgdmFsdWUgdG8gYSBnaXZlbiBuZXN0ZWQgb2JqZWN0cyBwYXRoLlxuICAgICAqIEl0IHdpbGwgY3JlYXRlIHRoZSBwYXRoIHN0cnVjdHVyZSBvciBwYXJ0cyBvZiBpdCwgaW4gY2FzZSBpdCBkb2VzIG5vdCBleGlzdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIE5lby5hc3NpZ25Ub05zKCdhbm5vdGF0aW9ucy5zZWxlY3RlZCcsIGZhbHNlLCByZWNvcmQpXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOk5lb1xuICAgICAqIEBwYXJhbSB7U3RyaW5nW118U3RyaW5nfSBwYXRoICAgICAgICAgICAgIFRoZSBwYXRoIHN0cmluZyBjb250YWluaW5nIGRvdHMgb3IgYW4gQXJyYXkgb2YgdGhlIHN0cmluZyBwYXJ0c1xuICAgICAqIEBwYXJhbSB7Kn0gICAgICAgICAgICAgICB2YWx1ZSAgICAgICAgICAgIFRoZSBuZXcgdmFsdWUgdG8gYXNzaWduIHRvIHRoZSBsZWFmIG5vZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgc2NvcGU9Z2xvYmFsVGhpcyBTZXQgYSBkaWZmZXJlbnQgc3RhcnRpbmcgcG9pbnQgYXMgZ2xvYmFsVGhpc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgICBmb3JjZT10cnVlICAgICAgIGZhbHNlIHdpbGwgb25seSBhc3NpZ24gZGVmYXVsdCB2YWx1ZXMgKGFzc2lnbiBpZiBvbGQgdmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgKi9cbiAgICBhc3NpZ25Ub05zKHBhdGgsIHZhbHVlLCBzY29wZT1nbG9iYWxUaGlzLCBmb3JjZT10cnVlKSB7XG4gICAgICAgIHBhdGggPSBBcnJheS5pc0FycmF5KHBhdGgpID8gcGF0aCA6IHBhdGguc3BsaXQoJy4nKTtcblxuICAgICAgICBsZXQga2V5O1xuXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGtleSAgID0gcGF0aC5wb3AoKTtcbiAgICAgICAgICAgIHNjb3BlID0gTmVvLm5zKHBhdGgsIHRydWUsIHNjb3BlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAga2V5ID0gcGF0aFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvcmNlIHx8IHNjb3BlW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2NvcGVba2V5XSA9IHZhbHVlXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMga2ViYWItY2FzZSBzdHJpbmdzIGludG8gY2FtZWwtY2FzZVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6TmVvXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFRoZSB0YXJnZXQgb2JqZWN0XG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBjYW1lbCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUucmVwbGFjZShjYW1lbFJlZ2V4LCBtYXRjaCA9PiBtYXRjaFsxXS50b1VwcGVyQ2FzZSgpKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgc3RyaW5nIHVwcGVyY2FzZVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6TmVvXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW58U3RyaW5nfSBSZXR1cm5zIGZhbHNlIGZvciBub24gc3RyaW5nIGlucHV0c1xuICAgICAqL1xuICAgIGNhcGl0YWxpemUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlWzBdLnRvVXBwZXJDYXNlKCkgKyB2YWx1ZS5zbGljZSgxKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOk5lb1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fCp9IG9ialxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGVlcD1mYWxzZSAgICAgICAgICAgICAgIFNldCB0aGlzIHRvIHRydWUgaW4gY2FzZSB5b3Ugd2FudCB0byBjbG9uZSBuZXN0ZWQgb2JqZWN0cyBhcyB3ZWxsXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpZ25vcmVOZW9JbnN0YW5jZXM9ZmFsc2UgcmV0dXJucyBleGlzdGluZyBpbnN0YW5jZXMgaWYgc2V0IHRvIHRydWVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fEFycmF5fCp9IHRoZSBjbG9uZWQgaW5wdXRcbiAgICAgKi9cbiAgICBjbG9uZShvYmosIGRlZXA9ZmFsc2UsIGlnbm9yZU5lb0luc3RhbmNlcz1mYWxzZSkge1xuICAgICAgICByZXR1cm4gY2xvbmVNYXBbTmVvLnR5cGVPZihvYmopXT8uKG9iaiwgZGVlcCwgaWdub3JlTmVvSW5zdGFuY2VzKSB8fCBvYmpcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSB1c2luZyB0aGUgb3JpZ2luYWxDb25maWcgd2l0aG91dCB0aGUgaWRcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOk5lb1xuICAgICAqIEBwYXJhbSB7TmVvLmNvcmUuQmFzZX0gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvcmUuQmFzZX0gdGhlIGNsb25lZCBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNsb25lTmVvSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHsuLi5pbnN0YW5jZS5vcmlnaW5hbENvbmZpZ307XG5cbiAgICAgICAgZGVsZXRlIGNvbmZpZy5faWQ7XG4gICAgICAgIGRlbGV0ZSBjb25maWcuaWQ7XG5cbiAgICAgICAgcmV0dXJuIE5lby5jcmVhdGUoaW5zdGFuY2UuY2xhc3NOYW1lLCBjb25maWcpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVzZSBOZW8uY3JlYXRlKCkgaW5zdGVhZCBvZiBcIm5ld1wiIHRvIGNyZWF0ZSBpbnN0YW5jZXMgb2YgYWxsIE5lbyBjbGFzc2VzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpbXBvcnQgQnV0dG9uIGZyb20gJy4uL2J1dHRvbi9CYXNlLm1qcyc7XG4gICAgICpcbiAgICAgKiBOZW8uY3JlYXRlKEJ1dHRvbiwge1xuICAgICAqICAgICBpY29uQ2xzOiAnZmEgZmEtaG9tZScsXG4gICAgICogICAgIHRleHQgICA6ICdIb21lJ1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlXG4gICAgICogaW1wb3J0IEJ1dHRvbiBmcm9tICcuLi9idXR0b24vQmFzZS5tanMnO1xuICAgICAqXG4gICAgICogTmVvLmNyZWF0ZSh7XG4gICAgICogICAgIG1vZHVsZSA6IEJ1dHRvbixcbiAgICAgKiAgICAgaWNvbkNsczogJ2ZhIGZhLWhvbWUnLFxuICAgICAqICAgICB0ZXh0ICAgOiAnSG9tZSdcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIE5lby5jcmVhdGUoJ05lby5idXR0b24uQmFzZScge1xuICAgICAqICAgICBpY29uQ2xzOiAnZmEgZmEtaG9tZScsXG4gICAgICogICAgIHRleHQgICA6ICdIb21lJ1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlXG4gICAgICogTmVvLmNyZWF0ZSh7XG4gICAgICogICAgIGNsYXNzTmFtZTogJ05lby5idXR0b24uQmFzZScsXG4gICAgICogICAgIGljb25DbHMgIDogJ2ZhIGZhLWhvbWUnLFxuICAgICAqICAgICB0ZXh0ICAgICA6ICdIb21lJ1xuICAgICAqIH0pO1xuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6TmVvXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fE5lby5jb3JlLkJhc2V9IGNsYXNzTmFtZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICBbY29uZmlnXVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29yZS5CYXNlfG51bGx9IFRoZSBuZXcgY2xhc3MgaW5zdGFuY2VcbiAgICAgKiBAdHV0b3JpYWwgMDJfQ2xhc3NTeXN0ZW1cbiAgICAgKi9cbiAgICBjcmVhdGUoY2xhc3NOYW1lLCBjb25maWcpIHtcbiAgICAgICAgbGV0IHR5cGUgPSBOZW8udHlwZU9mKGNsYXNzTmFtZSksXG4gICAgICAgICAgICBjbHMsIGluc3RhbmNlO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAnTmVvQ2xhc3MnKSB7XG4gICAgICAgICAgICBjbHMgPSBjbGFzc05hbWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnT2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGNvbmZpZyA9IGNsYXNzTmFtZTtcblxuICAgICAgICAgICAgICAgIGlmICghY29uZmlnLmNsYXNzTmFtZSAmJiAhY29uZmlnLm1vZHVsZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB1c2luZyBjb25zb2xlLmVycm9yIGluc3RlYWQgb2YgdGhyb3cgdG8gc2hvdyB0aGUgY29uZmlnIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdDbGFzcyBjcmVhdGVkIHdpdGggb2JqZWN0IGNvbmZpZ3VyYXRpb24gbWlzc2luZyBjbGFzc05hbWUgb3IgbW9kdWxlIHByb3BlcnR5JywgY29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjbGFzc05hbWUgPSBjb25maWcuY2xhc3NOYW1lIHx8IGNvbmZpZy5tb2R1bGUucHJvdG90eXBlLmNsYXNzTmFtZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWV4aXN0cyhjbGFzc05hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGFzcyAnICsgY2xhc3NOYW1lICsgJyBkb2VzIG5vdCBleGlzdCcpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNscyA9IE5lby5ucyhjbGFzc05hbWUpXG4gICAgICAgIH1cblxuICAgICAgICBpbnN0YW5jZSA9IG5ldyBjbHMoKTtcblxuICAgICAgICBpbnN0YW5jZS5jb25zdHJ1Y3QoY29uZmlnKTtcbiAgICAgICAgaW5zdGFuY2Uub25Db25zdHJ1Y3RlZCgpO1xuICAgICAgICBpbnN0YW5jZS5vbkFmdGVyQ29uc3RydWN0ZWQoKTtcbiAgICAgICAgaW5zdGFuY2UuaW5pdCgpO1xuXG4gICAgICAgIHJldHVybiBpbnN0YW5jZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGEgcmVhY3RpdmUgY29uZmlndXJhdGlvbiBwcm9wZXJ0eSBvbiBhIHRhcmdldCBvYmplY3QgKHByb3RvdHlwZSBvciBpbnN0YW5jZSkuXG4gICAgICogVGhpcyBtZXRob2QgY3JlYXRlcyBnZXR0ZXJzIGFuZCBzZXR0ZXJzIHRoYXQgZnVsbHkgcGFydGljaXBhdGUgaW4gTmVvLm1qcydzIHJlYWN0aXZlIGNvbmZpZyBzeXN0ZW0sXG4gICAgICogaW5jbHVkaW5nIGxpZmVjeWNsZSBob29rcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TmVvLmNvcmUuQmFzZX0gIHRhcmdldCAgICAgICAgLSBUaGUgaW5zdGFuY2Ugb3IgcHJvdG90eXBlIG9uIHdoaWNoIHRvIGRlZmluZSB0aGUgY29uZmlnLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgICAgIGtleSAgICAgICAgICAgLSBUaGUgbmFtZSBvZiB0aGUgY29uZmlnIHByb3BlcnR5ICh3aXRob3V0IHRoZSAnXycgc3VmZml4KS5cbiAgICAgKiBAcGFyYW0geyp9ICAgICAgICAgICAgIFtpbml0aWFsVmFsdWVdIC0gVGhlIGluaXRpYWwgdmFsdWUgZm9yIHRoZSBjb25maWcuXG4gICAgICovXG4gICAgY3JlYXRlQ29uZmlnKHRhcmdldCwga2V5LCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgaWYgKE5lby5oYXNQcm9wZXJ0eVNldHRlcih0YXJnZXQsIGtleSkpIHtcbiAgICAgICAgICAgIHRocm93KFxuYEludmFsaWQgY29uZmlnIGluICR7dGFyZ2V0LmNsYXNzTmFtZX06ICcke2tleX1fJy4gVGhlIGNvbmZpZyAnJHtrZXl9JyBpcyBhbHJlYWR5IGRlZmluZWQgYXMgcmVhY3RpdmUgYnkgYSBwYXJlbnQgY2xhc3MuXG5UbyBvdmVycmlkZSB0aGUgZGVmYXVsdCB2YWx1ZSwgdXNlICcke2tleX0nICh3aXRob3V0IHRoZSB1bmRlcnNjb3JlKSBpbiB5b3VyIHN0YXRpYyBjb25maWcuXG5JZiB5b3UgaW50ZW5kZWQgdG8gY3JlYXRlIGN1c3RvbSBsb2dpYywgdXNlIHRoZSAnYmVmb3JlR2V0JHtOZW8uY2FwaXRhbGl6ZShrZXkpfSgpJywgJ2JlZm9yZVNldCR7TmVvLmNhcGl0YWxpemUoa2V5KX0oKScsIGFuZCAnYWZ0ZXJTZXQke05lby5jYXBpdGFsaXplKGtleSl9KCknIGhvb2tzIGluc3RlYWQgb2YgcmVkZWZpbmluZyB0aGUgY29uZmlnLmBcbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBfa2V5ICAgICAgPSAnXycgKyBrZXksXG4gICAgICAgICAgICB1S2V5ICAgICAgPSBrZXlbMF0udG9VcHBlckNhc2UoKSArIGtleS5zbGljZSgxKSxcbiAgICAgICAgICAgIGJlZm9yZUdldCA9ICdiZWZvcmVHZXQnICsgdUtleSxcbiAgICAgICAgICAgIGJlZm9yZVNldCA9ICdiZWZvcmVTZXQnICsgdUtleSxcbiAgICAgICAgICAgIGFmdGVyU2V0ICA9ICdhZnRlclNldCcgICsgdUtleTtcblxuICAgICAgICBOZW9bZ2V0U2V0Q2FjaGVdID8/PSB7fTtcblxuICAgICAgICBpZiAoIU5lb1tnZXRTZXRDYWNoZV1ba2V5XSkge1xuICAgICAgICAgICAgLy8gUHVibGljIERlc2NyaXB0b3JcbiAgICAgICAgICAgIE5lb1tnZXRTZXRDYWNoZV1ba2V5XSA9IHtcbiAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnICAgID0gbWUuZ2V0Q29uZmlnKGtleSksXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNOZXdLZXkgPSBPYmplY3QuaGFzT3duKG1lW2NvbmZpZ1N5bWJvbF0sIGtleSksXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdLZXkgICAgPSBtZVtjb25maWdTeW1ib2xdW2tleV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSAgICAgPSBoYXNOZXdLZXkgPyBuZXdLZXkgOiBtZVtfa2V5XTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBEYXRlKHZhbHVlLnZhbHVlT2YoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gbmV3LCBleHBsaWNpdCBvcHQtaW4gcGF0aFxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb25maWcuY2xvbmVPbkdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qge2Nsb25lT25HZXR9ID0gY29uZmlnO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xvbmVPbkdldCA9PT0gJ2RlZXAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBOZW8uY2xvbmUodmFsdWUsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjbG9uZU9uR2V0ID09PSAnc2hhbGxvdycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gTmVvLnR5cGVPZih2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ0FycmF5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFsuLi52YWx1ZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnT2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHsuLi52YWx1ZX07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGxlZ2FjeSBiZWhhdmlvclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBbLi4udmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc05ld0tleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVba2V5XSA9IHZhbHVlOyAgLy8gV2UgZG8gd2FudCB0byB0cmlnZ2VyIHRoZSBzZXR0ZXIgPT4gYmVmb3JlU2V0LCBhZnRlclNldFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBtZVtfa2V5XTsgLy8gUmV0dXJuIHRoZSB2YWx1ZSBwYXJzZWQgYnkgdGhlIHNldHRlclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG1lW2NvbmZpZ1N5bWJvbF1ba2V5XVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZVtiZWZvcmVHZXRdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG1lW2JlZm9yZUdldF0odmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuZ2V0Q29uZmlnKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29uZmlnKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IG1lICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZSAgICAgICAgPSBjb25maWcuZ2V0KCksIC8vIEdldCB0aGUgb2xkIHZhbHVlIGZyb20gdGhlIENvbmZpZyBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAge0VmZmVjdE1hbmFnZXJ9ID0gTmVvLmNvcmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc05ld0JhdGNoICAgICAgPSAhRWZmZWN0TWFuYWdlcj8uaXNQYXVzZWQoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhIGNvbmZpZyBjaGFuZ2UgaXMgbm90IHRyaWdnZXJlZCB2aWEgYGNvcmUuQmFzZSNzZXQoKWAsIGhvbm9yIGNoYW5nZXMgaW5zaWRlIGhvb2tzLlxuICAgICAgICAgICAgICAgICAgICBpc05ld0JhdGNoICYmIEVmZmVjdE1hbmFnZXI/LnBhdXNlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEuIFByZXZlbnQgaW5maW5pdGUgbG9vcHM6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbW1lZGlhdGVseSByZW1vdmUgdGhlIHBlbmRpbmcgdmFsdWUgZnJvbSB0aGUgY29uZmlnU3ltYm9sIHRvIHByZXZlbnQgYSBnZXR0ZXIgZnJvbVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVjdXJzaXZlbHkgcmUtdHJpZ2dlcmluZyB0aGlzIHNldHRlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBtZVtjb25maWdTeW1ib2xdW2tleV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29uZmlnLmNsb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGVlcCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gTmVvLmNsb25lKHZhbHVlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2hhbGxvdyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gTmVvLmNsb25lKHZhbHVlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAyLiBDcmVhdGUgYSB0ZW1wb3Jhcnkgc3RhdGUgZm9yIGJlZm9yZVNldCBob29rczpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgbmV3IHZhbHVlIGRpcmVjdGx5IG9uIHRoZSBwcml2YXRlIGJhY2tpbmcgcHJvcGVydHkuIFRoaXMgYWxsb3dzIGFueSBiZWZvcmVTZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhvb2sgdG8gYWNjZXNzIHRoZSBuZXcgdmFsdWUgb2YgdGhpcyBhbmQgb3RoZXIgY29uZmlncyB3aXRoaW4gdGhlIHNhbWUgYHNldCgpYCBjYWxsLlxuICAgICAgICAgICAgICAgICAgICAgICAgbWVbX2tleV0gPSB2YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZVtiZWZvcmVTZXRdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBtZVtiZWZvcmVTZXRdKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGV5IGRvbid0IHJldHVybiBhIHZhbHVlLCB0aGF0IG1lYW5zIG5vIGNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHZhbHVlIGlmIHRoZSB1cGRhdGUgaXMgY2FuY2VsZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lW19rZXldID0gb2xkVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gMy4gUmVzdG9yZSBzdGF0ZSBmb3IgY2hhbmdlIGRldGVjdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldmVydCB0aGUgcHJpdmF0ZSBiYWNraW5nIHByb3BlcnR5IHRvIGl0cyBvcmlnaW5hbCB2YWx1ZS4gVGhpcyBpcyBjcnVjaWFsIGZvciB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBjb25maWcuc2V0KClgIG1ldGhvZCB0byBjb3JyZWN0bHkgZGV0ZWN0IGlmIHRoZSB2YWx1ZSBoYXMgYWN0dWFsbHkgY2hhbmdlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1lW19rZXldID0gb2xkVmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDQuIEZpbmFsaXplIHRoZSBjaGFuZ2U6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY29uZmlnLnNldCgpIG1ldGhvZCBwZXJmb3JtcyB0aGUgZmluYWwgY2hlY2sgYW5kLCBpZiB0aGUgdmFsdWUgY2hhbmdlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyaWdnZXJzIGFmdGVyU2V0IGhvb2tzIGFuZCBub3RpZmllcyBzdWJzY3JpYmVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcuc2V0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lW2FmdGVyU2V0XT8uKHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUuYWZ0ZXJTZXRDb25maWc/LihrZXksIHZhbHVlLCBvbGRWYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuZCB0aGUgYmF0Y2ggb25seSBpZiB0aGlzIHNldHRlciBzdGFydGVkIGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgaXNOZXdCYXRjaCAmJiBFZmZlY3RNYW5hZ2VyPy5yZXN1bWUoKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gUHJpdmF0ZSBEZXNjcmlwdG9yXG4gICAgICAgICAgICBOZW9bZ2V0U2V0Q2FjaGVdW19rZXldID0ge1xuICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29uZmlnKGtleSk/LmdldCgpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRDb25maWcoa2V5KT8uc2V0UmF3KHZhbHVlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgIE5lb1tnZXRTZXRDYWNoZV1ba2V5XSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF9rZXksIE5lb1tnZXRTZXRDYWNoZV1bX2tleV0pO1xuXG4gICAgICAgIGlmIChpbml0aWFsVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBpbml0aWFsVmFsdWVcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGVtcHR5Rm4oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgYSBjbGFzcyBpcyBhc3NpZ25lZCB0byB0aGUgTmVvIG5hbWVzcGFjZSBvbmx5IG9uY2UsIHByZXZlbnRpbmcgZHVwbGljYXRlcy5cbiAgICAgKiBUaGlzIGlzIGEgbGlnaHR3ZWlnaHQgdmVyc2lvbiBvZiBgTmVvLnNldHVwQ2xhc3NgIGZvciBzaW1wbGUgY2xhc3Nlc1xuICAgICAqIHRoYXQgZG8gbm90IGV4dGVuZCBgTmVvLmNvcmUuQmFzZWAuXG4gICAgICogSXQgZm9sbG93cyBhIFwiZmlyc3Qgb25lIHdpbnNcIiBzdHJhdGVneS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSBtb2R1bGUgICAgLSBUaGUgY2xhc3MgY29uc3RydWN0b3Igb3Igc2luZ2xldG9uIG9iamVjdCB0byByZWdpc3Rlci5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICAgICAgY2xhc3NQYXRoIC0gVGhlIGZ1bGx5IHF1YWxpZmllZCBuYW1lIChlLmcuLCAnTmVvLmNvcmUuQ29uZmlnJykuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gICAgICAgW29uRmlyc3RdICAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHRoYXQgcnVucyBvbmx5IHRoZSBmaXJzdCB0aW1lIHRoZSBjbGFzcyBpcyByZWdpc3RlcmVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxPYmplY3R9IFRoZSBjbGFzcyBvciBzaW5nbGV0b24gZnJvbSB0aGUgTmVvIG5hbWVzcGFjZSAoZWl0aGVyIHRoZSBleGlzdGluZyBvbmUgb3IgdGhlIG5ld2x5IHNldCBvbmUpLlxuICAgICAqL1xuICAgIGdhdGVrZWVwKG1vZHVsZSwgY2xhc3NQYXRoLCBvbkZpcnN0KSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQ2xhc3MgPSBOZW8ubnMoY2xhc3NQYXRoLCBmYWxzZSk7XG5cbiAgICAgICAgaWYgKGV4aXN0aW5nQ2xhc3MpIHtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZ0NsYXNzXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdFxuICAgICAgICAgICAgbnNBcnJheSAgID0gY2xhc3NQYXRoLnNwbGl0KCcuJyksXG4gICAgICAgICAgICBjbGFzc05hbWUgPSBuc0FycmF5LnBvcCgpLFxuICAgICAgICAgICAgcGFyZW50TnMgID0gTmVvLm5zKG5zQXJyYXksIHRydWUpO1xuXG4gICAgICAgIHBhcmVudE5zW2NsYXNzTmFtZV0gPSBtb2R1bGU7XG5cbiAgICAgICAgb25GaXJzdD8uKG1vZHVsZSk7XG5cbiAgICAgICAgcmV0dXJuIHBhcmVudE5zW2NsYXNzTmFtZV1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZXJlIGlzIGEgc2V0IG1ldGhvZCBmb3IgYSBnaXZlbiBwcm9wZXJ0eSBrZXkgaW5zaWRlIHRoZSBwcm90b3R5cGUgY2hhaW5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOk5lb1xuICAgICAqIEBwYXJhbSB7TmVvLmNvcmUuQmFzZX0gcHJvdG8gVGhlIHRvcCBsZXZlbCBwcm90b3R5cGUgb2YgYSBjbGFzc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgICAga2V5ICAgVGhlIHByb3BlcnR5IGtleSB0byB0ZXN0XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzUHJvcGVydHlTZXR0ZXIocHJvdG8sIGtleSkge1xuICAgICAgICBsZXQgZGVzY3JpcHRvcjtcblxuICAgICAgICB3aGlsZSAocHJvdG8uX19wcm90b19fKSB7XG4gICAgICAgICAgICBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90bywga2V5KTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZXNjcmlwdG9yID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZGVzY3JpcHRvci5zZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcm90byA9IHByb3RvLl9fcHJvdG9fX1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlZXAtbWVyZ2VzIGEgc291cmNlIG9iamVjdCBpbnRvIGEgdGFyZ2V0IG9iamVjdFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6TmVvXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdHNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cbiAgICBtZXJnZSh0YXJnZXQsIHNvdXJjZSwgZGVmYXVsdHMpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRzKSB7XG4gICAgICAgICAgICByZXR1cm4gTmVvLm1lcmdlKE5lby5tZXJnZSh0YXJnZXQsIGRlZmF1bHRzKSwgc291cmNlKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2VcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBzb3VyY2Vba2V5XTtcblxuICAgICAgICAgICAgaWYgKE5lby50eXBlT2YodmFsdWUpID09PSAnT2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gTmVvLm1lcmdlKHRhcmdldFtrZXldIHx8IHt9LCB2YWx1ZSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXJnZXMgYSBuZXcgdmFsdWUgaW50byBhbiBleGlzdGluZyBjb25maWcgdmFsdWUgYmFzZWQgb24gYSBzcGVjaWZpZWQgc3RyYXRlZ3kuXG4gICAgICogVGhpcyBtZXRob2QgaXMgdXNlZCBkdXJpbmcgaW5zdGFuY2UgY3JlYXRpb24gdG8gYXBwbHkgbWVyZ2Ugc3RyYXRlZ2llcyBkZWZpbmVkIGluIGNvbmZpZyBkZXNjcmlwdG9ycy5cbiAgICAgKiBAcGFyYW0ge2FueX0gZGVmYXVsdFZhbHVlIC0gVGhlIGRlZmF1bHQgdmFsdWUgb2YgdGhlIGNvbmZpZyAoZnJvbSBzdGF0aWMgY29uZmlnKS5cbiAgICAgKiBAcGFyYW0ge2FueX0gaW5zdGFuY2VWYWx1ZSAtIFRoZSB2YWx1ZSBwcm92aWRlZCBkdXJpbmcgaW5zdGFuY2UgY3JlYXRpb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd8RnVuY3Rpb259IHN0cmF0ZWd5IC0gVGhlIG1lcmdlIHN0cmF0ZWd5OiAnc2hhbGxvdycsICdkZWVwJywgJ3JlcGxhY2UnLCBvciBhIGN1c3RvbSBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7YW55fSBUaGUgbWVyZ2VkIHZhbHVlLlxuICAgICAqL1xuICAgIG1lcmdlQ29uZmlnKGRlZmF1bHRWYWx1ZSwgaW5zdGFuY2VWYWx1ZSwgc3RyYXRlZ3kpIHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZVR5cGUgID0gTmVvLnR5cGVPZihkZWZhdWx0VmFsdWUpLFxuICAgICAgICAgICAgaW5zdGFuY2VWYWx1ZVR5cGUgPSBOZW8udHlwZU9mKGluc3RhbmNlVmFsdWUpO1xuXG4gICAgICAgIGlmIChzdHJhdGVneSA9PT0gJ3NoYWxsb3cnKSB7XG4gICAgICAgICAgICBpZiAoZGVmYXVsdFZhbHVlVHlwZSA9PT0gJ09iamVjdCcgJiYgaW5zdGFuY2VWYWx1ZVR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsuLi5kZWZhdWx0VmFsdWUsIC4uLmluc3RhbmNlVmFsdWV9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyYXRlZ3kgPT09ICdkZWVwJykge1xuICAgICAgICAgICAgaWYgKGRlZmF1bHRWYWx1ZVR5cGUgPT09ICdPYmplY3QnICYmIGluc3RhbmNlVmFsdWVUeXBlID09PSAnT2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBOZW8ubWVyZ2UoTmVvLmNsb25lKGRlZmF1bHRWYWx1ZSwgdHJ1ZSksIGluc3RhbmNlVmFsdWUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHN0cmF0ZWd5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyYXRlZ3koZGVmYXVsdFZhbHVlLCBpbnN0YW5jZVZhbHVlKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmYXVsdCB0byAncmVwbGFjZScgb3IgaWYgc3RyYXRlZ3kgaXMgbm90IHJlY29nbml6ZWRcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlVmFsdWVcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFwcyBhIGNsYXNzTmFtZSBzdHJpbmcgaW50byBhIGdpdmVuIG9yIGdsb2JhbCBuYW1lc3BhY2VcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIE5lby5ucygnTmVvLmJ1dHRvbi5CYXNlJywgdHJ1ZSk7XG4gICAgICogLy8gPT5cbiAgICAgKiAvLyBnbG9iYWxUaGlzLk5lbyAgICAgICAgICAgICA9IGdsb2JhbFRoaXMuTmVvICAgICAgICAgICAgIHx8IHt9O1xuICAgICAqIC8vIGdsb2JhbFRoaXMuTmVvLmJ1dHRvbiAgICAgID0gZ2xvYmFsVGhpcy5OZW8uYnV0dG9uICAgICAgfHwge307XG4gICAgICogLy8gZ2xvYmFsVGhpcy5OZW8uYnV0dG9uLkJhc2UgPSBnbG9iYWxUaGlzLk5lby5idXR0b24uQmFzZSB8fCB7fTtcbiAgICAgKiAvLyByZXR1cm4gZ2xvYmFsVGhpcy5OZW8uYnV0dG9uLkJhc2U7XG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOk5lb1xuICAgICAqIEBwYXJhbSB7U3RyaW5nW118U3RyaW5nfSBuYW1lcyAgICAgICAgVGhlIGNsYXNzIG5hbWUgc3RyaW5nIGNvbnRhaW5pbmcgZG90cyBvciBhbiBBcnJheSBvZiB0aGUgc3RyaW5nIHBhcnRzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICAgIGNyZWF0ZT1mYWxzZSBTZXQgY3JlYXRlIHRvIHRydWUgdG8gY3JlYXRlIGVtcHR5IG9iamVjdHMgZm9yIG5vbi1leGlzdGluZyBwYXJ0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICBbc2NvcGVdICAgICAgU2V0IGEgZGlmZmVyZW50IHN0YXJ0aW5nIHBvaW50IGFzIGdsb2JhbFRoaXNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSByZWZlcmVuY2UgdG8gdGhlIHRvcGxldmVsIG5hbWVzcGFjZVxuICAgICAqL1xuICAgIG5zKG5hbWVzLCBjcmVhdGU9ZmFsc2UsIHNjb3BlKSB7XG4gICAgICAgIG5hbWVzID0gQXJyYXkuaXNBcnJheShuYW1lcykgPyBuYW1lcyA6IG5hbWVzLnNwbGl0KCcuJyk7XG5cbiAgICAgICAgcmV0dXJuIG5hbWVzLnJlZHVjZSgocHJldiwgY3VycmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNyZWF0ZSAmJiAhcHJldltjdXJyZW50XSkge1xuICAgICAgICAgICAgICAgIHByZXZbY3VycmVudF0gPSB7fVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2W2N1cnJlbnRdXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHNjb3BlIHx8IGdsb2JhbFRoaXMpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4dGVuZGVkIHZlcnNpb24gb2YgTmVvLm5zKCkgd2hpY2ggc3VwcG9ydHMgbWFwcGluZyBpbnRvIGFycmF5cy5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOk5lb1xuICAgICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBuYW1lcyAgICAgICAgVGhlIGNsYXNzIG5hbWUgc3RyaW5nIGNvbnRhaW5pbmcgZG90cyBvciBhbiBBcnJheSBvZiB0aGUgc3RyaW5nIHBhcnRzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgIGNyZWF0ZT1mYWxzZSBTZXQgY3JlYXRlIHRvIHRydWUgdG8gY3JlYXRlIGVtcHR5IG9iamVjdHMgZm9yIG5vbi1leGlzdGluZyBwYXJ0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICBbc2NvcGVdICAgICAgU2V0IGEgZGlmZmVyZW50IHN0YXJ0aW5nIHBvaW50IGFzIGdsb2JhbFRoaXNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSByZWZlcmVuY2UgdG8gdGhlIHRvcGxldmVsIG5hbWVzcGFjZVxuICAgICAqL1xuICAgIG5zV2l0aEFycmF5cyhuYW1lcywgY3JlYXRlPWZhbHNlLCBzY29wZSkge1xuICAgICAgICBuYW1lcyA9IEFycmF5LmlzQXJyYXkobmFtZXMpID8gbmFtZXMgOiBuYW1lcy5zcGxpdCgnLicpO1xuXG4gICAgICAgIHJldHVybiBuYW1lcy5yZWR1Y2UoKHByZXYsIGN1cnJlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChjcmVhdGUgJiYgIXByZXZbY3VycmVudF0pIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5lbmRzV2l0aCgnXScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVBcnJheU5zKHRydWUsIGN1cnJlbnQsIHByZXYpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcHJldltjdXJyZW50XSA9IHt9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQuZW5kc1dpdGgoJ10nKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQXJyYXlOcyhmYWxzZSwgY3VycmVudCwgcHJldilcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldltjdXJyZW50XVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBzY29wZSB8fCBnbG9iYWxUaGlzKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGluc3RhbmNlcyBvZiBOZW8gY2xhc3NlcyB1c2luZyB0aGVpciBudHlwZSBpbnN0ZWFkIG9mIHRoZSBjbGFzcyBuYW1lXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBOZW8ubnR5cGUoJ2J1dHRvbicge1xuICAgICAqICAgICBpY29uQ2xzOiAnZmEgZmEtaG9tZScsXG4gICAgICogICAgIHRleHQgICA6ICdIb21lJ1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlXG4gICAgICogTmVvLm50eXBlKHtcbiAgICAgKiAgICAgbnR5cGUgIDogJ2J1dHRvbicsXG4gICAgICogICAgIGljb25DbHM6ICdmYSBmYS1ob21lJyxcbiAgICAgKiAgICAgdGV4dCAgIDogJ0hvbWUnXG4gICAgICogfSk7XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpOZW9cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IG50eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICBbY29uZmlnXVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29yZS5CYXNlfVxuICAgICAqIEBzZWUge0BsaW5rIG1vZHVsZTpOZW8uY3JlYXRlIGNyZWF0ZX1cbiAgICAgKi9cbiAgICBudHlwZShudHlwZSwgY29uZmlnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbnR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25maWcgPSBudHlwZTtcblxuICAgICAgICAgICAgaWYgKCFjb25maWcubnR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsYXNzIGRlZmluZWQgd2l0aCBvYmplY3QgY29uZmlndXJhdGlvbiBtaXNzaW5nIG50eXBlIHByb3BlcnR5LiAnICsgY29uZmlnLm50eXBlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBudHlwZSA9IGNvbmZpZy5udHlwZVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNsYXNzTmFtZSA9IE5lby5udHlwZU1hcFtudHlwZV07XG5cbiAgICAgICAgaWYgKCFjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbnR5cGUgJyArIG50eXBlICsgJyBkb2VzIG5vdCBleGlzdCcpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTmVvLmNyZWF0ZShjbGFzc05hbWUsIGNvbmZpZylcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgZmluYWwgYW5kIG1vc3QgY3JpdGljYWwgc3RlcCBpbiB0aGUgTmVvLm1qcyBjbGFzcyBjcmVhdGlvbiBwcm9jZXNzLlxuICAgICAqIEl0IGlzIGNhbGxlZCBhdCB0aGUgZW5kIG9mIGV2ZXJ5IGNsYXNzIG1vZHVsZSBkZWZpbml0aW9uLlxuICAgICAqXG4gICAgICogYHNldHVwQ2xhc3NgIHBlcmZvcm1zIHNldmVyYWwga2V5IG9wZXJhdGlvbnM6XG4gICAgICogMS4gICoqTWl4ZWQtRW52aXJvbm1lbnQgR2F0ZWtlZXBlcjoqKiBJdCBmaXJzdCBjaGVja3MgaWYgdGhlIGNsYXNzJ3MgbmFtZXNwYWNlIGFscmVhZHkgZXhpc3RzLlxuICAgICAqICAgICBJZiBpdCBkb2VzLCBpdCBpbW1lZGlhdGVseSByZXR1cm5zIHRoZSBleGlzdGluZyBjbGFzcy4gVGhpcyBpcyB0aGUgY3J1Y2lhbCBcImZpcnN0IGNvbWVzIHdpbnNcIlxuICAgICAqICAgICBzdHJhdGVneSB0aGF0IGVuYWJsZXMgTmVvLm1qcyB0byBzYWZlbHkgY29tYmluZSBlbnZpcm9ubWVudHMuIEZvciBleGFtcGxlLCBhIGJ1bmRsZWRcbiAgICAgKiAgICAgYGRpc3QvcHJvZHVjdGlvbmAgYXBwIGNhbiBkeW5hbWljYWxseSBsb2FkIGFuIHVuYnVuZGxlZCBtb2R1bGUgZnJvbSBgZGlzdC9lc21gIGF0IHJ1bnRpbWUuXG4gICAgICogICAgIElmIHRoYXQgbW9kdWxlIGltcG9ydHMgYSBjbGFzcyBhbHJlYWR5IHByZXNlbnQgaW4gdGhlIG1haW4gYnVuZGxlLCB0aGlzIGNoZWNrIGVuc3VyZXMgdGhlXG4gICAgICogICAgIG9yaWdpbmFsLCBidW5kbGVkIGNsYXNzIGlzIHVzZWQsIHByZXZlbnRpbmcgY29uZmxpY3RzIGFuZCBtYWludGFpbmluZyBhcHBsaWNhdGlvbiBpbnRlZ3JpdHkuXG4gICAgICogMS4gICoqQ29uZmlndXJhdGlvbiBNZXJnaW5nOioqIEl0IHRyYXZlcnNlcyB0aGUgcHJvdG90eXBlIGNoYWluIHRvIG1lcmdlIGBzdGF0aWMgY29uZmlnYFxuICAgICAqICAgICBvYmplY3RzIGZyb20gcGFyZW50IGNsYXNzZXMgaW50byB0aGUgY3VycmVudCBjbGFzcywgY3JlYXRpbmcgYSB1bmlmaWVkIGBjb25maWdgLlxuICAgICAqIDIuICAqKkFwcGx5aW5nIE92ZXJ3cml0ZXM6KiogSXQgY2FsbHMgdGhlIHN0YXRpYyBgYXBwbHlPdmVyd3JpdGVzKClgIG1ldGhvZCBvbiB0aGUgY2xhc3MsXG4gICAgICogICAgIGFsbG93aW5nIHRoZSBnbG9iYWwgYE5lby5vdmVyd3JpdGVzYCBvYmplY3QgdG8gbW9kaWZ5IHRoZSBjbGFzcydzIGRlZmF1bHQgcHJvdG90eXBlXG4gICAgICogICAgIGNvbmZpZ3MuIFRoaXMgaXMgYSBrZXkgbWVjaGFuaXNtIGZvciBleHRlcm5hbCB0aGVtaW5nIGFuZCBjb25maWd1cmF0aW9uLlxuICAgICAqIDMuICAqKlJlYWN0aXZlIEdldHRlci9TZXR0ZXIgR2VuZXJhdGlvbjoqKiBGb3IgYW55IGNvbmZpZyBlbmRpbmcgd2l0aCBhbiB1bmRlcnNjb3JlIChlLmcuLCBgbXlDb25maWdfYCksXG4gICAgICogICAgIGl0IGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVzIHRoZSBjb3JyZXNwb25kaW5nIHB1YmxpYyBnZXR0ZXIgYW5kIHNldHRlci4gVGhpcyBlbmFibGVzIG9wdGlvbmFsXG4gICAgICogICAgIGxpZmVjeWNsZSBob29rcyB0aGF0IGFyZSBjYWxsZWQgYXV0b21hdGljYWxseSBpZiBpbXBsZW1lbnRlZCBvbiB0aGUgY2xhc3M6XG4gICAgICogICAgIC0gYGJlZm9yZUdldE15Q29uZmlnKHZhbHVlKWBcbiAgICAgKiAgICAgLSBgYmVmb3JlU2V0TXlDb25maWcobmV3VmFsdWUsIG9sZFZhbHVlKWBcbiAgICAgKiAgICAgLSBgYWZ0ZXJTZXRNeUNvbmZpZyhuZXdWYWx1ZSwgb2xkVmFsdWUpYFxuICAgICAqIDQuICAqKlByb3RvdHlwZS1iYXNlZCBDb25maWdzOioqIE5vbi1yZWFjdGl2ZSBjb25maWdzICh3aXRob3V0IGFuIHVuZGVyc2NvcmUpIGFyZSBzZXRcbiAgICAgKiAgICAgZGlyZWN0bHkgb24gdGhlIHByb3RvdHlwZSBmb3IgbWVtb3J5IGVmZmljaWVuY3kuXG4gICAgICogNS4gICoqTWl4aW4gQXBwbGljYXRpb246KiogSXQgcHJvY2Vzc2VzIHRoZSBgbWl4aW5zYCBjb25maWcgdG8gYmxlbmQgaW4gZnVuY3Rpb25hbGl0eSBmcm9tXG4gICAgICogICAgIG90aGVyIGNsYXNzZXMuXG4gICAgICogNi4gICoqTmFtZXNwYWNlIFJlZ2lzdHJhdGlvbjoqKiBJdCByZWdpc3RlcnMgdGhlIGNsYXNzIGluIHRoZSBnbG9iYWwgYE5lb2AgbmFtZXNwYWNlLlxuICAgICAqIDcuICAqKlNpbmdsZXRvbiBJbnN0YW50aWF0aW9uOioqIElmIHRoZSBjbGFzcyBpcyBjb25maWd1cmVkIGFzIGEgc2luZ2xldG9uLCBpdCBjcmVhdGVzIHRoZVxuICAgICAqICAgICBzaW5nbGUgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOk5lb1xuICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICogQHBhcmFtIHtUfSBjbHMgVGhlIGNsYXNzIGNvbnN0cnVjdG9yIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge1R9IFRoZSBwcm9jZXNzZWQgYW5kIGZpbmFsaXplZCBjbGFzcyBjb25zdHJ1Y3RvciBvciBzaW5nbGV0b24gaW5zdGFuY2UuXG4gICAgICovXG4gICAgc2V0dXBDbGFzcyhjbHMpIHtcbiAgICAgICAgbGV0IGJhc2VDb25maWcgICAgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICBiYXNlQ29uZmlnRGVzY3JpcHRvcnMgPSBudWxsLFxuICAgICAgICAgICAgbnR5cGVDaGFpbiAgICAgICAgICAgID0gW10sXG4gICAgICAgICAgICB7bnR5cGVNYXB9ICAgICAgICAgICAgPSBOZW8sXG4gICAgICAgICAgICBwcm90byAgICAgICAgICAgICAgICAgPSBjbHMucHJvdG90eXBlIHx8IGNscyxcbiAgICAgICAgICAgIG5zICAgICAgICAgICAgICAgICAgICA9IE5lby5ucyhwcm90by5jb25zdHJ1Y3Rvci5jb25maWcuY2xhc3NOYW1lLCBmYWxzZSksXG4gICAgICAgICAgICBwcm90b3MgICAgICAgICAgICAgICAgPSBbXSxcbiAgICAgICAgICAgIGNmZywgY29uZmlnLCBjb25maWdEZXNjcmlwdG9ycywgY3RvciwgaGllcmFyY2h5SW5mbywgbnR5cGU7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogSWYgdGhlIG5hbWVzcGFjZSBhbHJlYWR5IGV4aXN0cywgZGlyZWN0bHkgcmV0dXJuIGl0LlxuICAgICAgICAgKiBUaGlzIGNhbiBoYXBwZW4gd2hlbiB1c2luZyBkaWZmZXJlbnQgdmVyc2lvbnMgb2YgTmVvLm1qc1xuICAgICAgICAgKiA9PiBFc3BlY2lhbGx5IHNpbmdsZXRvbnMgKElkR2VuZXJhdG9yKSBtdXN0IHN0YXkgdW5pcXVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGNhbiBhbHNvIGhhcHBlbiB3aGVuIHVzaW5nIGRpZmZlcmVudCBlbnZpcm9ubWVudHMgb2YgbmVvLm1qcyBpbiBwYXJhbGxlbC5cbiAgICAgICAgICogRXhhbXBsZTogY29kZS5MaXZlUHJldmlldyBydW5uaW5nIGluc2lkZSBhIGRpc3QvcHJvZHVjdGlvbiBhcHAuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAobnMpIHtcbiAgICAgICAgICAgIHJldHVybiBuc1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJhdmVyc2UgdGhlIHByb3RvdHlwZSBjaGFpbiB0byBjb2xsZWN0IGluaGVyaXRlZCBjb25maWdzIGFuZCBkZXNjcmlwdG9yc1xuICAgICAgICB3aGlsZSAocHJvdG8uX19wcm90b19fKSB7XG4gICAgICAgICAgICBjdG9yID0gcHJvdG8uY29uc3RydWN0b3I7XG5cbiAgICAgICAgICAgIC8vIElmIGEgY2xhc3MgaW4gdGhlIHByb3RvdHlwZSBjaGFpbiBoYXMgYWxyZWFkeSBoYWQgaXRzIGNvbmZpZyBhcHBsaWVkLFxuICAgICAgICAgICAgLy8gd2UgY2FuIHVzZSBpdHMgcHJlLXByb2Nlc3NlZCBjb25maWcgYW5kIGRlc2NyaXB0b3JzIGFzIGEgYmFzZS5cbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKGN0b3IsICdjbGFzc0NvbmZpZ0FwcGxpZWQnKSkge1xuICAgICAgICAgICAgICAgIGJhc2VDb25maWcgICAgICAgICAgICA9IE5lby5jbG9uZShjdG9yLmNvbmZpZywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYmFzZUNvbmZpZ0Rlc2NyaXB0b3JzID0gTmVvLmNsb25lKGN0b3IuY29uZmlnRGVzY3JpcHRvcnMsIHRydWUpO1xuICAgICAgICAgICAgICAgIG50eXBlQ2hhaW4gICAgICAgICAgICA9IFsuLi5jdG9yLm50eXBlQ2hhaW5dO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByb3Rvcy51bnNoaWZ0KHByb3RvKTtcbiAgICAgICAgICAgIHByb3RvID0gcHJvdG8uX19wcm90b19fXG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbml0aWFsaXplIGFjY3VtdWxhdGVkIGNvbmZpZyBhbmQgZGVzY3JpcHRvcnNcbiAgICAgICAgY29uZmlnICAgICAgICAgICAgPSBiYXNlQ29uZmlnICAgICAgICAgICAgfHwge307XG4gICAgICAgIGNvbmZpZ0Rlc2NyaXB0b3JzID0gYmFzZUNvbmZpZ0Rlc2NyaXB0b3JzIHx8IHt9O1xuXG4gICAgICAgIC8vIFByb2Nlc3MgZWFjaCBjbGFzcyBpbiB0aGUgcHJvdG90eXBlIGNoYWluIChmcm9tIHRvcCB0byBib3R0b20pXG4gICAgICAgIHByb3Rvcy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgbGV0IG1peGlucztcblxuICAgICAgICAgICAgY3RvciA9IGVsZW1lbnQuY29uc3RydWN0b3I7XG4gICAgICAgICAgICBjZmcgID0gY3Rvci5jb25maWcgfHwge307XG5cbiAgICAgICAgICAgIGlmIChOZW8ub3ZlcndyaXRlcykge1xuICAgICAgICAgICAgICAgIGN0b3IuYXBwbHlPdmVyd3JpdGVzPy4oY2ZnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQcm9jZXNzIGVhY2ggY29uZmlnIHByb3BlcnR5IGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgY2xhc3MncyBzdGF0aWMgY29uZmlnXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhjZmcpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgICAgICAgIGlzUmVhY3RpdmUgPSBrZXkuc2xpY2UoLTEpID09PSAnXycsXG4gICAgICAgICAgICAgICAgICAgIGJhc2VLZXkgICAgPSBpc1JlYWN0aXZlID8ga2V5LnNsaWNlKDAsIC0xKSA6IGtleTtcblxuICAgICAgICAgICAgICAgIC8vIDEuIEhhbmRsZSBkZXNjcmlwdG9yczogSWYgdGhlIHZhbHVlIGlzIGEgZGVzY3JpcHRvciBvYmplY3QsIHN0b3JlIGl0LlxuICAgICAgICAgICAgICAgIC8vICAgIFRoZSAndmFsdWUnIHByb3BlcnR5IG9mIHRoZSBkZXNjcmlwdG9yIGlzIHRoZW4gdXNlZCBhcyB0aGUgYWN0dWFsIGNvbmZpZyB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KHZhbHVlKSAmJiB2YWx1ZVtpc0Rlc2NyaXB0b3JdID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0b3IuY29uZmlnRGVzY3JpcHRvcnMgPz89IHt9O1xuICAgICAgICAgICAgICAgICAgICBjdG9yLmNvbmZpZ0Rlc2NyaXB0b3JzW2Jhc2VLZXldID0gTmVvLmNsb25lKHZhbHVlLCB0cnVlKTsgLy8gRGVlcCBjbG9uZSB0byBwcmV2ZW50IG11dGF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudmFsdWUgLy8gVXNlIHRoZSBkZXNjcmlwdG9yJ3MgdmFsdWUgYXMgdGhlIGNvbmZpZyB2YWx1ZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIDIuIEhhbmRsZSByZWFjdGl2ZSB2cy4gbm9uLXJlYWN0aXZlIGNvbmZpZ3M6IEdlbmVyYXRlIGdldHRlcnMvc2V0dGVycyBmb3IgcmVhY3RpdmUgY29uZmlncy5cbiAgICAgICAgICAgICAgICBpZiAoaXNSZWFjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgY2ZnW2tleV07ICAgICAgLy8gUmVtb3ZlIG9yaWdpbmFsIGtleSB3aXRoIHVuZGVyc2NvcmVcbiAgICAgICAgICAgICAgICAgICAgY2ZnW2Jhc2VLZXldID0gdmFsdWU7IC8vIFVzZSB0aGUgcG90ZW50aWFsbHkgbW9kaWZpZWQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgTmVvLmNyZWF0ZUNvbmZpZyhlbGVtZW50LCBiYXNlS2V5KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGlzIHBhcnQgaGFuZGxlcyBub24tcmVhY3RpdmUgY29uZmlncyAoaW5jbHVkaW5nIHRob3NlIHRoYXQgd2VyZSBkZXNjcmlwdG9ycylcbiAgICAgICAgICAgICAgICAvLyBJZiBubyBwcm9wZXJ0eSBzZXR0ZXIgZXhpc3RzLCBkZWZpbmUgaXQgZGlyZWN0bHkgb24gdGhlIHByb3RvdHlwZS5cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghTmVvLmhhc1Byb3BlcnR5U2V0dGVyKGVsZW1lbnQsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsIGtleSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGUgIDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBNZXJnZSBjb25maWdEZXNjcmlwdG9yczogQXBwbHkgXCJmaXJzdC1kZWZpbmVkIHdpbnNcIiBzdHJhdGVneS5cbiAgICAgICAgICAgIC8vIElmIGEgZGVzY3JpcHRvciBmb3IgYSBrZXkgYWxyZWFkeSBleGlzdHMgKGZyb20gYSBwYXJlbnQgY2xhc3MpLCBpdCBpcyBub3Qgb3ZlcndyaXR0ZW4uXG4gICAgICAgICAgICBpZiAoY3Rvci5jb25maWdEZXNjcmlwdG9ycykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGN0b3IuY29uZmlnRGVzY3JpcHRvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFPYmplY3QuaGFzT3duKGNvbmZpZ0Rlc2NyaXB0b3JzLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWdEZXNjcmlwdG9yc1trZXldID0gTmVvLmNsb25lKGN0b3IuY29uZmlnRGVzY3JpcHRvcnNba2V5XSwgdHJ1ZSkgLy8gRGVlcCBjbG9uZSBmb3IgaW1tdXRhYmlsaXR5XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFByb2Nlc3MgbnR5cGUgYW5kIG50eXBlQ2hhaW5cbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKGNmZywgJ250eXBlJykpIHtcbiAgICAgICAgICAgICAgICBudHlwZSA9IGNmZy5udHlwZTtcblxuICAgICAgICAgICAgICAgIG50eXBlQ2hhaW4udW5zaGlmdChudHlwZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBSdW5uaW5nIHRoZSBkb2NzIGFwcCBpbnNpZGUgYSB3b3Jrc3BhY2UgY2FuIHB1bGwgaW4gdGhlIHNhbWUgY2xhc3NlcyBmcm9tIGRpZmZlcmVudCByb290cyxcbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSB3YW50IHRvIGNoZWNrIGZvciBkaWZmZXJlbnQgY2xhc3MgbmFtZXMgYXMgd2VsbFxuICAgICAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKG50eXBlTWFwLCBudHlwZSkgJiYgY2ZnLmNsYXNzTmFtZSAhPT0gbnR5cGVNYXBbbnR5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbnR5cGUgY29uZmxpY3QgZm9yICcke250eXBlfScgaW5zaWRlIHRoZSBjbGFzc2VzOlxcbiR7bnR5cGVNYXBbbnR5cGVdfVxcbiR7Y2ZnLmNsYXNzTmFtZX1gKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG50eXBlTWFwW250eXBlXSA9IGNmZy5jbGFzc05hbWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUHJvY2VzcyBtaXhpbnNcbiAgICAgICAgICAgIG1peGlucyA9IE9iamVjdC5oYXNPd24oY29uZmlnLCAnbWl4aW5zJykgJiYgY29uZmlnLm1peGlucyB8fCBbXTtcblxuICAgICAgICAgICAgaWYgKGN0b3Iub2JzZXJ2YWJsZSkge1xuICAgICAgICAgICAgICAgIG1peGlucy5wdXNoKCdOZW8uY29yZS5PYnNlcnZhYmxlJylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oY2ZnLCAnbWl4aW5zJykgJiYgQXJyYXkuaXNBcnJheShjZmcubWl4aW5zKSAmJiBjZmcubWl4aW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBtaXhpbnMucHVzaCguLi5jZmcubWl4aW5zKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWl4aW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBhcHBseU1peGlucyhjdG9yLCBtaXhpbnMsIGNmZyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoTmVvLm5zKCdOZW8uY29yZS5PYnNlcnZhYmxlJywgZmFsc2UsIGN0b3IucHJvdG90eXBlLm1peGlucykpIHtcbiAgICAgICAgICAgICAgICAgICAgY3Rvci5vYnNlcnZhYmxlID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlIGNmZy5taXhpbnM7XG4gICAgICAgICAgICBkZWxldGUgY29uZmlnLm1peGlucztcblxuICAgICAgICAgICAgLy8gSGllcmFyY2hpY2FsIG1lcmdpbmcgb2Ygc3RhdGljIGNvbmZpZyB2YWx1ZXMgYmFzZWQgb24gZGVzY3JpcHRvcnMuXG4gICAgICAgICAgICAvLyBUaGlzIGVuc3VyZXMgdGhhdCB2YWx1ZXMgYXJlIG1lcmdlZCAoZS5nLiwgc2hhbGxvdy9kZWVwKSBpbnN0ZWFkIG9mIHNpbXBseSBvdmVyd3JpdHRlbi5cbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGNmZykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IGNvbmZpZ0Rlc2NyaXB0b3JzW2tleV07XG5cbiAgICAgICAgICAgICAgICBpZiAoZGVzY3JpcHRvcj8ubWVyZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnW2tleV0gPSBOZW8ubWVyZ2VDb25maWcoY29uZmlnW2tleV0sIHZhbHVlLCBkZXNjcmlwdG9yLm1lcmdlKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ1trZXldID0gdmFsdWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQXNzaWduIGZpbmFsIHByb2Nlc3NlZCBjb25maWcgYW5kIGRlc2NyaXB0b3JzIHRvIHRoZSBjbGFzcyBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihjdG9yLCB7XG4gICAgICAgICAgICAgICAgY2xhc3NDb25maWdBcHBsaWVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZyAgICAgICAgICAgIDogTmVvLmNsb25lKGNvbmZpZywgICAgICAgICAgICB0cnVlKSwgLy8gRGVlcCBjbG9uZSBmaW5hbCBjb25maWcgZm9yIGltbXV0YWJpbGl0eVxuICAgICAgICAgICAgICAgIGNvbmZpZ0Rlc2NyaXB0b3JzIDogTmVvLmNsb25lKGNvbmZpZ0Rlc2NyaXB0b3JzLCB0cnVlKSwgLy8gRGVlcCBjbG9uZSBmaW5hbCBkZXNjcmlwdG9ycyBmb3IgaW1tdXRhYmlsaXR5XG4gICAgICAgICAgICAgICAgaXNDbGFzcyAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgICAgIG50eXBlQ2hhaW5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBBcHBseSB0byBnbG9iYWwgbmFtZXNwYWNlIGlmIG5vdCBhIHNpbmdsZXRvblxuICAgICAgICAgICAgIWNvbmZpZy5zaW5nbGV0b24gJiYgdGhpcy5hcHBseVRvR2xvYmFsTnMoY2xzKVxuICAgICAgICB9KTtcblxuICAgICAgICBwcm90byA9IGNscy5wcm90b3R5cGUgfHwgY2xzO1xuXG4gICAgICAgIC8vIEFkZCBpczxOdHlwZT4gZmxhZ3MgdG8gdGhlIHByb3RvdHlwZVxuICAgICAgICBudHlwZUNoYWluLmZvckVhY2gobnR5cGUgPT4ge1xuICAgICAgICAgICAgcHJvdG9bYGlzJHtOZW8uY2FwaXRhbGl6ZShOZW8uY2FtZWwobnR5cGUpKX1gXSA9IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gSWYgaXQncyBhIHNpbmdsZXRvbiwgY3JlYXRlIGFuZCBhcHBseSB0aGUgaW5zdGFuY2UgdG8gdGhlIGdsb2JhbCBuYW1lc3BhY2VcbiAgICAgICAgaWYgKHByb3RvLnNpbmdsZXRvbikge1xuICAgICAgICAgICAgY2xzID0gTmVvLmNyZWF0ZShjbHMpO1xuICAgICAgICAgICAgTmVvLmFwcGx5VG9HbG9iYWxOcyhjbHMpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgY2xhc3MgaGllcmFyY2h5IGluZm9ybWF0aW9uIHRvIHRoZSBtYW5hZ2VyIG9yIGEgdGVtcG9yYXJ5IG1hcFxuICAgICAgICBoaWVyYXJjaHlJbmZvID0ge1xuICAgICAgICAgICAgY2xhc3NOYW1lICAgICAgOiBwcm90by5jbGFzc05hbWUsXG4gICAgICAgICAgICBtb2R1bGUgICAgICAgICA6IGNscyxcbiAgICAgICAgICAgIG50eXBlICAgICAgICAgIDogT2JqZWN0Lmhhc093bihwcm90bywgJ250eXBlJykgPyBwcm90by5udHlwZSA6IG51bGwsXG4gICAgICAgICAgICBwYXJlbnRDbGFzc05hbWU6IHByb3RvLl9fcHJvdG9fXz8uY2xhc3NOYW1lIHx8IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoTmVvLm1hbmFnZXI/LkNsYXNzSGllcmFyY2h5KSB7XG4gICAgICAgICAgICBOZW8ubWFuYWdlci5DbGFzc0hpZXJhcmNoeS5hZGQoaGllcmFyY2h5SW5mbylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIE5lby5jbGFzc0hpZXJhcmNoeU1hcCA/Pz0ge307XG4gICAgICAgICAgICBOZW8uY2xhc3NIaWVyYXJjaHlNYXBbcHJvdG8uY2xhc3NOYW1lXSA9IGhpZXJhcmNoeUluZm9cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbHNcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSBpdGVtXG4gICAgICogQHJldHVybnMge1N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHR5cGVPZihpdGVtKSB7XG4gICAgICAgIC8vIFJldHVybiBudWxsIGZvciBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICBpZiAoaXRlbSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHR5cGVEZXRlY3Rvclt0eXBlb2YgaXRlbV0/LihpdGVtKSB8fCBpdGVtLmNvbnN0cnVjdG9yPy5uYW1lXG4gICAgfVxufSwgTmVvKTtcblxuLyoqXG4gKiBMaXN0IG9mIGNsYXNzIHByb3BlcnRpZXMgd2hpY2ggYXJlIG5vdCBzdXBwb3NlZCB0byBnZXQgbWl4ZWQgaW50byBvdGhlciBjbGFzc2VzXG4gKiBAdHlwZSB7c3RyaW5nW119XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBpZ25vcmVNaXhpbiA9IFtcbiAgICAnX25hbWUnLFxuICAgICdjbGFzc0NvbmZpZ0FwcGxpZWQnLFxuICAgICdjbGFzc05hbWUnLFxuICAgICdjb25zdHJ1Y3RvcicsXG4gICAgJ2lkJyxcbiAgICAnaXNDbGFzcycsXG4gICAgJ21peGluJyxcbiAgICAnbnR5cGUnLFxuICAgICdvYnNlcnZhYmxlJ1xuXSxcblxuICAgIGNoYXJzUmVnZXggICAgICAgICA9IC9cXGQrL2csXG4gICAgZXh0cmFjdEFycmF5c1JlZ2V4ID0gL14oXFx3KylcXHMqKCg/OlxcW1xccypcXGQrXFxzKlxcXVxccyopKikkLztcblxuLyoqXG4gKiBAcGFyYW0ge05lby5jb3JlLkJhc2V9IGNsc1xuICogQHBhcmFtIHtBcnJheX0gICAgICAgICBtaXhpbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgY2xhc3NDb25maWdcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFwcGx5TWl4aW5zKGNscywgbWl4aW5zLCBjbGFzc0NvbmZpZykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShtaXhpbnMpKSB7XG4gICAgICAgIG1peGlucyA9IFttaXhpbnNdO1xuICAgIH1cblxuICAgIGxldCBpICAgICAgICAgICAgPSAwLFxuICAgICAgICBsZW4gICAgICAgICAgPSBtaXhpbnMubGVuZ3RoLFxuICAgICAgICBtaXhpbkNsYXNzZXMgPSB7fSxcbiAgICAgICAgbWl4aW4sIG1peGluQ2xzLCBtaXhpblByb3RvO1xuXG4gICAgZm9yICg7aSA8IGxlbjtpKyspIHtcbiAgICAgICAgbWl4aW4gPSBtaXhpbnNbaV07XG5cbiAgICAgICAgaWYgKG1peGluLmlzQ2xhc3MpIHtcbiAgICAgICAgICAgIG1peGluUHJvdG8gPSBtaXhpbi5wcm90b3R5cGU7XG4gICAgICAgICAgICBtaXhpbkNscyAgID0gTmVvLm5zKG1peGluUHJvdG8uY2xhc3NOYW1lKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFleGlzdHMobWl4aW4pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0aW5nIHRvIG1peGluIGFuIHVuZGVmaW5lZCBjbGFzczogJyArIG1peGluICsgJywgJyArIGNscy5wcm90b3R5cGUuY2xhc3NOYW1lKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtaXhpbkNscyAgID0gTmVvLm5zKG1peGluKTtcbiAgICAgICAgICAgIG1peGluUHJvdG8gPSBtaXhpbkNscy5wcm90b3R5cGVcbiAgICAgICAgfVxuXG4gICAgICAgIG1peGluUHJvdG8uY2xhc3NOYW1lLnNwbGl0KCcuJykucmVkdWNlKG1peFJlZHVjZShtaXhpbkNscyksIG1peGluQ2xhc3Nlcyk7XG5cbiAgICAgICAgT2JqZWN0LmVudHJpZXMoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMobWl4aW5Qcm90bykpLmZvckVhY2gobWl4aW5Qcm9wZXJ0eShjbHMucHJvdG90eXBlLCBtaXhpblByb3RvLCBjbGFzc0NvbmZpZykpXG4gICAgfVxuXG4gICAgY2xzLnByb3RvdHlwZS5taXhpbnMgPSBtaXhpbkNsYXNzZXMgLy8gdG9kbzogd2Ugc2hvdWxkIGRvIGEgZGVlcCBtZXJnZVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY3JlYXRlXG4gKiBAcGFyYW0ge09iamVjdH0gIGN1cnJlbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSAgcHJldlxuICogQHJldHVybnMge09iamVjdHx1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5TnMoY3JlYXRlLCBjdXJyZW50LCBwcmV2KSB7XG4gICAgbGV0IGFyckRldGFpbHMgPSBwYXJzZUFycmF5RnJvbVN0cmluZyhjdXJyZW50KSxcbiAgICAgICAgaSAgICAgICAgICA9IDEsXG4gICAgICAgIGxlbiAgICAgICAgPSBhcnJEZXRhaWxzLmxlbmd0aCxcbiAgICAgICAgYXJySXRlbSwgYXJyUm9vdDtcblxuICAgIGlmIChjcmVhdGUpIHtcbiAgICAgICAgcHJldlthcnJEZXRhaWxzWzBdXSA9IGFyclJvb3QgPSBwcmV2W2FyckRldGFpbHNbMF1dIHx8IFtdXG4gICAgfSBlbHNlIHtcbiAgICAgICAgYXJyUm9vdCA9IHByZXZbYXJyRGV0YWlsc1swXV1cbiAgICB9XG5cbiAgICBpZiAoIWFyclJvb3QpIHJldHVybjtcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgYXJySXRlbSA9IHBhcnNlSW50KGFyckRldGFpbHNbaV0pO1xuXG4gICAgICAgIGlmIChjcmVhdGUpIHtcbiAgICAgICAgICAgIGFyclJvb3RbYXJySXRlbV0gPSBhcnJSb290W2Fyckl0ZW1dIHx8IHt9XG4gICAgICAgIH1cblxuICAgICAgICBhcnJSb290ID0gYXJyUm9vdFthcnJJdGVtXVxuICAgIH1cblxuICAgIHJldHVybiBhcnJSb290XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBjbGFzcyBuYW1lIGV4aXN0cyBpbnNpZGUgdGhlIE5lbyBvciBhcHAgbmFtZXNwYWNlXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGV4aXN0cyhjbGFzc05hbWUpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gISFjbGFzc05hbWUuc3BsaXQoJy4nKS5yZWR1Y2UoKHByZXYsIGN1cnJlbnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBwcmV2W2N1cnJlbnRdXG4gICAgICAgIH0sIGdsb2JhbFRoaXMpXG4gICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge05lby5jb3JlLkJhc2V9IHByb3RvXG4gKiBAcGFyYW0ge05lby5jb3JlLkJhc2V9IG1peGluUHJvdG9cbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgY2xhc3NDb25maWdcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1peGluUHJvcGVydHkocHJvdG8sIG1peGluUHJvdG8sIGNsYXNzQ29uZmlnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKFtrZXksIGRlc2NyaXB0b3JdKSB7XG4gICAgICAgIGlmIChpZ25vcmVNaXhpbi5pbmNsdWRlcyhrZXkpKSByZXR1cm47XG5cbiAgICAgICAgLy8gTWl4aW5zIG11c3Qgbm90IG92ZXJyaWRlIGV4aXN0aW5nIGNsYXNzIHByb3BlcnRpZXMgd2l0aCBhIHNldHRlclxuICAgICAgICBpZiAoTmVvLmhhc1Byb3BlcnR5U2V0dGVyKHByb3RvLCBrZXkpKSByZXR1cm47XG5cbiAgICAgICAgLy8gUmVhY3RpdmUgbmVvIGNvbmZpZ3MsIG9yIHB1YmxpYyBjbGFzcyBmaWVsZHMgZGVmaW5lZCB2aWEgZ2V0KCkgQU5EIHNldCgpXG4gICAgICAgIGlmIChkZXNjcmlwdG9yLmdldCAmJiBkZXNjcmlwdG9yLnNldCkge1xuICAgICAgICAgICAgTmVvLmNyZWF0ZUNvbmZpZyhwcm90bywga2V5KTtcblxuICAgICAgICAgICAgY29uc3QgbWl4aW5DbGFzc0NvbmZpZyA9IG1peGluUHJvdG8uY29uc3RydWN0b3IuY29uZmlnO1xuXG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihtaXhpbkNsYXNzQ29uZmlnLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgY2xhc3NDb25maWdba2V5XSA9IG1peGluQ2xhc3NDb25maWdba2V5XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvdG9ba2V5XT8uX2Zyb20pIHtcbiAgICAgICAgICAgIGlmIChtaXhpblByb3RvLmNsYXNzTmFtZSA9PT0gcHJvdG9ba2V5XS5fZnJvbSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignTWl4aW4gc2V0IG11bHRpcGxlIHRpbWVzIG9yIGFscmVhZHkgZGVmaW5lZCBvbiBhIEJhc2UgQ2xhc3MnLCBwcm90by5jbGFzc05hbWUsIG1peGluUHJvdG8uY2xhc3NOYW1lLCBrZXkpO1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYCR7cHJvdG8uY2xhc3NOYW1lfTogTXVsdGlwbGUgbWl4aW5zIGRlZmluaW5nIHNhbWUgcHJvcGVydHkgKCR7bWl4aW5Qcm90by5jbGFzc05hbWV9LCAke3Byb3RvW2tleV0uX2Zyb219KSA9PiAke2tleX1gXG4gICAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICBwcm90b1trZXldID0gbWl4aW5Qcm90b1trZXldO1xuXG4gICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG8sIGtleSkuX2Zyb20gPSBtaXhpblByb3RvLmNsYXNzTmFtZTtcblxuICAgICAgICBpZiAodHlwZW9mIHByb3RvW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHByb3RvW2tleV0uX25hbWUgPSBrZXlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0gbWl4aW5DbHNcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1peFJlZHVjZShtaXhpbkNscykge1xuICAgIHJldHVybiAocHJldiwgY3VycmVudCwgaWR4LCBhcnIpID0+IHtcbiAgICAgICAgcmV0dXJuIHByZXZbY3VycmVudF0gPSBpZHggIT09IGFyci5sZW5ndGggLTEgPyBwcmV2W2N1cnJlbnRdIHx8IHt9IDogbWl4aW5DbHNcbiAgICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcGFyc2VBcnJheUZyb21TdHJpbmcoc3RyKSB7XG4gICAgcmV0dXJuIChleHRyYWN0QXJyYXlzUmVnZXguZXhlYyhzdHIpIHx8IFtudWxsXSkuc2xpY2UoMSkucmVkdWNlKFxuICAgICAgICAoZnVuLCBhcmdzKSA9PiBbZnVuXS5jb25jYXQoYXJncy5tYXRjaChjaGFyc1JlZ2V4KSlcbiAgICApXG59XG5cbk5lby5jb25maWcgPz89IHt9O1xuXG5OZW8uYXNzaWduRGVmYXVsdHMoTmVvLmNvbmZpZywgRGVmYXVsdENvbmZpZyk7XG5cbmV4cG9ydCBkZWZhdWx0IE5lbztcbiIsImltcG9ydCBCYXNlICAgICAgIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuaW1wb3J0IEZpbHRlciAgICAgZnJvbSAnLi9GaWx0ZXIubWpzJztcbmltcG9ydCBMb2dnZXIgICAgIGZyb20gJy4uL3V0aWwvTG9nZ2VyLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICBmcm9tICcuLi91dGlsL0FycmF5Lm1qcyc7XG5pbXBvcnQgT2JzZXJ2YWJsZSBmcm9tICcuLi9jb3JlL09ic2VydmFibGUubWpzJztcbmltcG9ydCBTb3J0ZXIgICAgIGZyb20gJy4vU29ydGVyLm1qcyc7XG5cbmNvbnN0IGNvdW50TXV0YXRpb25zICAgPSBTeW1ib2woJ2NvdW50TXV0YXRpb25zJyksXG4gICAgICBpc0ZpbHRlcmVkICAgICAgID0gU3ltYm9sKCdpc0ZpbHRlcmVkJyksXG4gICAgICBpc1NvcnRlZCAgICAgICAgID0gU3ltYm9sKCdpc1NvcnRlZCcpLFxuICAgICAgc2lsZW50VXBkYXRlTW9kZSA9IFN5bWJvbCgnc2lsZW50VXBkYXRlTW9kZScpLFxuICAgICAgdG9BZGRBcnJheSAgICAgICA9IFN5bWJvbCgndG9BZGRBcnJheScpLFxuICAgICAgdG9SZW1vdmVBcnJheSAgICA9IFN5bWJvbCgndG9SZW1vdmVBcnJheScpLFxuICAgICAgdXBkYXRpbmdJbmRleCAgICA9IFN5bWJvbCgndXBkYXRpbmdJbmRleCcpO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uY29sbGVjdGlvbi5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKiBAbWl4ZXMgTmVvLmNvcmUuT2JzZXJ2YWJsZVxuICovXG5jbGFzcyBDb2xsZWN0aW9uIGV4dGVuZHMgQmFzZSB7XG4gICAgLyoqXG4gICAgICogVHJ1ZSBhdXRvbWF0aWNhbGx5IGFwcGxpZXMgdGhlIGNvcmUuT2JzZXJ2YWJsZSBtaXhpblxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG9ic2VydmFibGU9dHJ1ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgb2JzZXJ2YWJsZSA9IHRydWVcblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbGxlY3Rpb24uQmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbGxlY3Rpb24uQmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdjb2xsZWN0aW9uJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2NvbGxlY3Rpb24nLFxuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiBmaWx0ZXJpbmcgdGhlIGNvbGxlY3Rpb24gZm9yIHRoZSBmaXJzdCB0aW1lLCBhbGxJdGVtcyB3aWxsIGJlY29tZSBhIG5ldyBjb2xsZWN0aW9uIGZvciB0aGUgdW5maWx0ZXJlZFxuICAgICAgICAgKiBzdGF0ZSwgdXNpbmcgdGhpcyBpZCBhcyB0aGUgc291cmNlQ29sbGVjdGlvbklkXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb2xsZWN0aW9uLkJhc2V8bnVsbH0gYWxsSXRlbXM9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBhbGxJdGVtczogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgdG8gc29ydCB0aGUgY29sbGVjdGlvbiBpdGVtcyB3aGVuIGFkZGluZyAvIGluc2VydGluZyBuZXcgb25lc1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhdXRvU29ydD10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBhdXRvU29ydDogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3JlcyB0aGUgaXRlbXMubGVuZ3RoIG9mIHRoZSBpdGVtcyBhcnJheSBpbiB1c2VcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBjb3VudF89MFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGNvdW50XzogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZSAncHJpbWl0aXZlJyBmb3IgZGVmYXVsdCBmaWx0ZXJzLCB1c2UgJ2FkdmFuY2VkJyBmb3IgZmlsdGVycyB1c2luZyBhIGZpbHRlckJ5IG1ldGhvZFxuICAgICAgICAgKiB3aGljaCBuZWVkIHRvIGl0ZXJhdGUgb3ZlciBvdGhlciBjb2xsZWN0aW9uIGl0ZW1zXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gZmlsdGVyTW9kZT0ncHJpbWl0aXZlJ1xuICAgICAgICAgKi9cbiAgICAgICAgZmlsdGVyTW9kZTogJ3ByaW1pdGl2ZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBBcnJheSBjb250YWluaW5nIE5lby51dGlsLkZpbHRlciBjb25maWcgb2JqZWN0cyBvciBpbnN0YW5jZXNcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl9IGZpbHRlcnNfPVtdXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgZmlsdGVyc186IFtdLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0W118bnVsbH0gaXRlbXNfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtc186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdW5pcXVlKCEpIGtleSBwcm9wZXJ0eSBvZiBlYWNoIGNvbGxlY3Rpb24gaXRlbVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGtleVByb3BlcnR5PSdpZCdcbiAgICAgICAgICovXG4gICAgICAgIGtleVByb3BlcnR5OiAnaWQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkaW5nIG5ldyBpdGVtcyB3aXRob3V0IGFuIGlkIChrZXlQcm9wZXJ0eSkgd2lsbCB1c2UgYSBuZWdhdGl2ZSBpbmRleCwgd2hpY2ggd2lsbCBkZWNyZWFzZSBieSAtMVxuICAgICAgICAgKiBmb3IgZWFjaCBuZXcgaXRlbVxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGtleVByb3BlcnR5SW5kZXg9LTFcbiAgICAgICAgICovXG4gICAgICAgIGtleVByb3BlcnR5SW5kZXg6IC0xLFxuICAgICAgICAvKipcbiAgICAgICAgICogQSBtYXAgY29udGFpbmluZyB0aGUga2V5ICYgcmVmZXJlbmNlIG9mIGVhY2ggY29sbGVjdGlvbiBpdGVtIGZvciBmYXN0ZXIgYWNjZXNzXG4gICAgICAgICAqIEBtZW1iZXIge01hcH0gbWFwXz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBtYXBfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gaW50ZXJuYWwgQXJyYXkgb2YgdGhlIHNvcnQgZGlyZWN0aW9ucyBmb3IgZmFzdGVyIGFjY2Vzc1xuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheX0gc29ydERpcmVjdGlvbnM9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzb3J0RGlyZWN0aW9uczogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGludGVybmFsIEFycmF5IG9mIHRoZSBzb3J0IHByb3BlcnRpZXMgZm9yIGZhc3RlciBhY2Nlc3NcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl9IHNvcnRQcm9wZXJ0aWVzPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc29ydFByb3BlcnRpZXM6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBBcnJheSBjb250YWluaW5nIE5lby51dGlsLlNvcnRlciBjb25maWcgb2JqZWN0cyBvciBpbnN0YW5jZXNcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl9IHNvcnRlcnNfPVtdXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgc29ydGVyc186IFtdLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGlkIG9mIGFub3RoZXIgY29sbGVjdGlvbiBpbnN0YW5jZSB0byB1c2UgYXMgdGhpcyBkYXRhIHNvdXJjZVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gc291cmNlSWRfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzb3VyY2VJZF86IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHN5bWJvbENvbmZpZyA9IHtlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWV9O1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG1lLCB7XG4gICAgICAgICAgICBbY291bnRNdXRhdGlvbnNdICA6IHsuLi5zeW1ib2xDb25maWcsIHZhbHVlOiBmYWxzZX0sXG4gICAgICAgICAgICBbaXNGaWx0ZXJlZF0gICAgICA6IHsuLi5zeW1ib2xDb25maWcsIHZhbHVlOiBmYWxzZX0sXG4gICAgICAgICAgICBbaXNTb3J0ZWRdICAgICAgICA6IHsuLi5zeW1ib2xDb25maWcsIHZhbHVlOiBmYWxzZX0sXG4gICAgICAgICAgICBbc2lsZW50VXBkYXRlTW9kZV06IHsuLi5zeW1ib2xDb25maWcsIHZhbHVlOiBmYWxzZX0sXG4gICAgICAgICAgICBbdG9BZGRBcnJheV0gICAgICA6IHsuLi5zeW1ib2xDb25maWcsIHZhbHVlOiBbXX0sXG4gICAgICAgICAgICBbdG9SZW1vdmVBcnJheV0gICA6IHsuLi5zeW1ib2xDb25maWcsIHZhbHVlOiBbXX0sXG4gICAgICAgICAgICBbdXBkYXRpbmdJbmRleF0gICA6IHsuLi5zeW1ib2xDb25maWcsIHZhbHVlOiAwfVxuICAgICAgICB9KTtcblxuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBtZS5pdGVtcyA9IG1lLml0ZW1zIHx8IFtdO1xuXG4gICAgICAgIGlmIChtZS5hdXRvU29ydCAmJiBtZS5fc29ydGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBtZS5kb1NvcnQoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBvbmUgb3IgbW9yZSBpdGVtcyB0byB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGl0ZW0gVGhlIGl0ZW0ocykgdG8gYWRkXG4gICAgICogQHJldHVybnMge09iamVjdFtdfSBhbiBhcnJheSBjb250YWluaW5nIGFsbCBhZGRlZCBpdGVtc1xuICAgICAqL1xuICAgIGFkZChpdGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwbGljZShudWxsLCBudWxsLCBpdGVtKS5hZGRlZEl0ZW1zXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBmaWx0ZXJzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRGaWx0ZXJzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHZhbHVlLmZvckVhY2goZmlsdGVyID0+IHtcbiAgICAgICAgICAgIGlmIChmaWx0ZXIubGlzdGVuZXJBcHBsaWVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGZpbHRlci5vbignY2hhbmdlJywgbWUub25GaWx0ZXJDaGFuZ2UsIG1lKTtcbiAgICAgICAgICAgICAgICBmaWx0ZXIubGlzdGVuZXJBcHBsaWVkID0gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBvbGRWYWx1ZSAmJiBtZS5maWx0ZXIoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaXRlbXMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEl0ZW1zKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICB7a2V5UHJvcGVydHl9ID0gbWUsXG4gICAgICAgICAgICAgICAgaSAgICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICAgICAgbGVuICAgICAgICAgICA9IHZhbHVlLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpdGVtO1xuXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IHZhbHVlW2ldO1xuICAgICAgICAgICAgICAgIG1lLm1hcC5zZXQoaXRlbVtrZXlQcm9wZXJ0eV0sIGl0ZW0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLmNvdW50ID0gbGVuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNvcnRlcnMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNvcnRlcnModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuYXBwbHlTb3J0ZXJDb25maWdzKCk7XG5cbiAgICAgICAgdmFsdWUuZm9yRWFjaChzb3J0ZXIgPT4ge1xuICAgICAgICAgICAgaWYgKHNvcnRlci5saXN0ZW5lckFwcGxpZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgc29ydGVyLm9uKCdjaGFuZ2UnLCBtZS5vblNvcnRlckNoYW5nZSwgbWUpO1xuICAgICAgICAgICAgICAgIHNvcnRlci5saXN0ZW5lckFwcGxpZWQgPSB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9sZFZhbHVlICYmIG1lLmF1dG9Tb3J0ICYmIG1lLmRvU29ydCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzb3VyY2VJZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNvdXJjZUlkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHNvdXJjZSA9IE5lby5nZXQodmFsdWUpO1xuXG4gICAgICAgICAgICBtZS5faXRlbXMgPSBbLi4uc291cmNlLl9pdGVtc107XG4gICAgICAgICAgICBtZS5tYXAgICAgPSBuZXcgTWFwKHNvdXJjZS5tYXApOyAvLyBjcmVhdGVzIGEgY2xvbmUgb2YgdGhlIG9yaWdpbmFsIG1hcFxuXG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lcnNDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgbXV0YXRlOiBtZS5vbk11dGF0ZSxcbiAgICAgICAgICAgICAgICBzY29wZSA6IG1lXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBzb3VyY2Uub24obGlzdGVuZXJzQ29uZmlnKTtcblxuICAgICAgICAgICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgc291cmNlID0gTmVvLmdldChvbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgc291cmNlLnVuKGxpc3RlbmVyc0NvbmZpZylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNhdmVzIHRoZSBzb3J0IHByb3BlcnR5ICYgZGlyZWN0aW9uIG11bHRpcGxpZXIgb2YgZWFjaCBzb3J0ZXIgaW5zaWRlIDIgYXJyYXlzIGZvciBmYXN0ZXIgYWNjZXNzIHdoZW4gc29ydGluZ1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhcHBseVNvcnRlckNvbmZpZ3MoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuc29ydERpcmVjdGlvbnMgPSBbXTtcbiAgICAgICAgbWUuc29ydFByb3BlcnRpZXMgPSBbXTtcblxuICAgICAgICBtZS5zb3J0ZXJzLmZvckVhY2goc29ydGVyID0+IHtcbiAgICAgICAgICAgIG1lLnNvcnREaXJlY3Rpb25zLnB1c2goc29ydGVyLmRpcmVjdGlvbk11bHRpcGxpZXIpO1xuICAgICAgICAgICAgbWUuc29ydFByb3BlcnRpZXMucHVzaChzb3J0ZXIucHJvcGVydHkpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRGaWx0ZXJzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlID8gW3ZhbHVlXSA6IFtdXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbGVuID0gb2xkVmFsdWUgJiYgb2xkVmFsdWUubGVuZ3RoIHx8IDAsXG4gICAgICAgICAgICBoYXNNYXRjaCwgaTtcblxuICAgICAgICB2YWx1ZS5mb3JFYWNoKChrZXksIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBoYXNNYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGkgICAgICAgID0gMDtcblxuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZFZhbHVlW2ldID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlW2ldLnNldCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IGtleS5vcGVyYXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eToga2V5LnByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICAgOiBrZXkudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNNYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWVbaV0ub3BlcmF0b3IgPT09IChrZXkub3BlcmF0b3IgfHwgJz09PScpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZVtpXS5wcm9wZXJ0eSA9PT0ga2V5LnByb3BlcnR5ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZVtpXS52YWx1ZSAgICA9PT0ga2V5LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFoYXNNYXRjaCkge1xuICAgICAgICAgICAgICAgIHZhbHVlW2luZGV4XSA9IE5lby5jcmVhdGUoRmlsdGVyLCBrZXkpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlW2luZGV4XSA9IG9sZFZhbHVlW2ldO1xuICAgICAgICAgICAgICAgIG9sZFZhbHVlLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICBsZW4tLVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgIG9sZFZhbHVlLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICBrZXkuZGVzdHJveSgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TWFwfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtNYXB8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0TWFwKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gIXZhbHVlID8gbmV3IE1hcCgpIDogdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFNvcnRlcnModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgPyBbdmFsdWVdIDogW11cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBsZW4gPSBvbGRWYWx1ZT8ubGVuZ3RoIHx8IDAsXG4gICAgICAgICAgICBoYXNNYXRjaCwgaTtcblxuICAgICAgICB2YWx1ZS5mb3JFYWNoKChrZXksIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBoYXNNYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGkgICAgICAgID0gMDtcblxuICAgICAgICAgICAgICAgIGxldCB7ZGlyZWN0aW9uLCBwcm9wZXJ0eX0gPSBrZXk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRWYWx1ZVtpXSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZVtpXS5zZXQoe2RpcmVjdGlvbiwgcHJvcGVydHl9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvbGRWYWx1ZVtpXS5wcm9wZXJ0eSA9PT0gcHJvcGVydHkgJiYgb2xkVmFsdWVbaV0uZGlyZWN0aW9uID09PSBkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc01hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaGFzTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVtpbmRleF0gPSBOZW8uY3JlYXRlKFNvcnRlciwga2V5KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVtpbmRleF0gPSBvbGRWYWx1ZVtpXTtcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgbGVuLS1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgb2xkVmFsdWU/LmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGtleS5kZXN0cm95KClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9wdHNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY2FjaGVVcGRhdGUob3B0cykge1xuICAgICAgICAvLyBkaXNhYmxlZCBmb3Igbm93XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdjYWNoZVVwZGF0ZScsIG9wdHMsIHRoaXNbdG9BZGRBcnJheV0pO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2tleVByb3BlcnR5fSA9IG1lLFxuICAgICAgICAgICAgaW5kZXgsIHRvQWRkTWFwLCB0b1JlbW92ZU1hcDtcblxuICAgICAgICBpZiAoIW1lW3NpbGVudFVwZGF0ZU1vZGVdKSB7XG4gICAgICAgICAgICB0b0FkZE1hcCAgICA9IG1lW3RvQWRkQXJyYXldICAgLm1hcChlID0+IGVba2V5UHJvcGVydHldKTtcbiAgICAgICAgICAgIHRvUmVtb3ZlTWFwID0gbWVbdG9SZW1vdmVBcnJheV0ubWFwKGUgPT4gZVtrZXlQcm9wZXJ0eV0pO1xuXG4gICAgICAgICAgICBvcHRzLmFkZGVkSXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPSB0b1JlbW92ZU1hcC5pbmRleE9mKGl0ZW1ba2V5UHJvcGVydHldKSA+IC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBtZVt0b1JlbW92ZUFycmF5XS5zcGxpY2UoaW5kZXgsIDEpXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b0FkZE1hcC5pbmRleE9mKGl0ZW1ba2V5UHJvcGVydHldKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbWVbdG9BZGRBcnJheV0ucHVzaChpdGVtKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBvcHRzLnJlbW92ZWRJdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9IHRvQWRkTWFwLmluZGV4T2YoaXRlbVtrZXlQcm9wZXJ0eV0pID4gLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lW3RvQWRkQXJyYXldLnNwbGljZShpbmRleCwgMSlcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRvUmVtb3ZlTWFwLmluZGV4T2YoaXRlbVtrZXlQcm9wZXJ0eV0pIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBtZVt0b1JlbW92ZUFycmF5XS5wdXNoKGl0ZW0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGl0ZW1zIGFuZCBjbGVhcnMgdGhlIG1hcFxuICAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLnNwbGljZSgwLCB0aGlzLmNvdW50KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgY3VycmVudCBmaWx0ZXJzIGFuZCBvcHRpb25hbGx5IHJlc3RvcmVzIHRoZSBvcmlnaW5hbCBvbmVzIGluIGNhc2UgdGhleSBleGlzdGVkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Jlc3RvcmVPcmlnaW5hbEZpbHRlcnM9ZmFsc2VdXG4gICAgICovXG4gICAgY2xlYXJGaWx0ZXJzKHJlc3RvcmVPcmlnaW5hbEZpbHRlcnMpIHtcbiAgICAgICAgdGhpcy5maWx0ZXJzID0gcmVzdG9yZU9yaWdpbmFsRmlsdGVycyA/IE5lby5jbG9uZSh0aGlzLm9yaWdpbmFsQ29uZmlnLmZpbHRlcnMsIHRydWUsIHRydWUpIDogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGl0ZW1zIGFuZCBjbGVhcnMgdGhlIG1hcCwgd2l0aG91dCBmaXJpbmcgYSBtdXRhdGUgZXZlbnRcbiAgICAgKi9cbiAgICBjbGVhclNpbGVudCgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5faXRlbXMuc3BsaWNlKDAsIG1lLmNvdW50KTtcbiAgICAgICAgbWUubWFwLmNsZWFyKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYWxsIGN1cnJlbnQgc29ydGVycyBhbmQgb3B0aW9uYWxseSByZXN0b3JlcyB0aGUgb3JpZ2luYWwgb25lcyBpbiBjYXNlIHRoZXkgZXhpc3RlZC5cbiAgICAgKiBXaXRob3V0IHJlc3RvcmVJbml0aWFsU3RhdGUgYXMgdHJ1ZSB0aGlzIHdpbGwgbm90IGFmZmVjdCB0aGUgY3VycmVudCBzb3J0aW5nIG9mIHRoaXMgY29sbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXN0b3JlT3JpZ2luYWxTb3J0ZXJzPWZhbHNlXVxuICAgICAqL1xuICAgIGNsZWFyU29ydGVycyhyZXN0b3JlT3JpZ2luYWxTb3J0ZXJzKSB7XG4gICAgICAgIHRoaXMuc29ydGVycyA9IHJlc3RvcmVPcmlnaW5hbFNvcnRlcnMgPyBOZW8uY2xvbmUodGhpcy5vcmlnaW5hbENvbmZpZy5zb3J0ZXJzLCB0cnVlLCB0cnVlKSA6IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbGxlY3Rpb24uQmFzZX0gVGhlIGNsb25lZCBjb2xsZWN0aW9uXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyAgPSBOZW8uY2xvbmUobWUub3JpZ2luYWxDb25maWcsIHRydWUpLFxuICAgICAgICAgICAgZmlsdGVycyA9IG1lLl9maWx0ZXJzIHx8IFtdLFxuICAgICAgICAgICAgc29ydGVycyA9IG1lLl9zb3J0ZXJzIHx8IFtdO1xuXG4gICAgICAgIC8vIEVuc3VyZSB0aGUga2V5UHJvcGVydHkgZG9lcyBub3QgZ2V0IGxvc3QuXG4gICAgICAgIGNvbmZpZy5rZXlQcm9wZXJ0eSA9IG1lLmtleVByb3BlcnR5O1xuXG4gICAgICAgIGRlbGV0ZSBjb25maWcuaWQ7XG4gICAgICAgIGRlbGV0ZSBjb25maWcuZmlsdGVycztcbiAgICAgICAgZGVsZXRlIGNvbmZpZy5pdGVtcztcbiAgICAgICAgZGVsZXRlIGNvbmZpZy5zb3J0ZXJzO1xuXG4gICAgICAgIGlmIChtZS5faXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uZmlnLml0ZW1zICA9IFsuLi5tZS5faXRlbXNdO1xuICAgICAgICAgICAgY29uZmlnLmNvdW50ID0gY29uZmlnLml0ZW1zLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZy5maWx0ZXJzID0gW107XG4gICAgICAgIGNvbmZpZy5zb3J0ZXJzID0gW107XG5cbiAgICAgICAgLy8gdG9kbzogZmlsdGVycyAmIHNvcnRlcnMgc2hvdWxkIHB1c2ggdGhlaXIgY3VycmVudCBzdGF0ZSBhbmQgbm90IHRoZSBvcmlnaW5hbCBvbmVcblxuICAgICAgICBmaWx0ZXJzLmZvckVhY2goZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgICAgICAgICBjb25maWcuZmlsdGVycy5wdXNoKGZpbHRlci5vcmlnaW5hbENvbmZpZylcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc29ydGVycy5mb3JFYWNoKGZ1bmN0aW9uKHNvcnRlcikge1xuICAgICAgICAgICAgY29uZmlnLnNvcnRlcnMucHVzaChzb3J0ZXIub3JpZ2luYWxDb25maWcpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBOZW8uY3JlYXRlKENvbGxlY3Rpb24sIGNvbmZpZylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIG1hcCAmIGl0ZW1zIGFycmF5IGJlZm9yZSB0aGUgc3VwZXIgY2FsbFxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuX2l0ZW1zLnNwbGljZSgwLCBtZS5faXRlbXMubGVuZ3RoKTtcbiAgICAgICAgbWUubWFwLmNsZWFyKCk7XG5cbiAgICAgICAgc3VwZXIuZGVzdHJveSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBpdGVtcz10aGlzLl9pdGVtc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50PWZhbHNlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGRvU29ydChpdGVtcz10aGlzLl9pdGVtcywgc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBwcmV2aW91c0l0ZW1zICAgICA9IFsuLi5pdGVtc10sXG4gICAgICAgICAgICB7c29ydGVycywgc29ydERpcmVjdGlvbnMsIHNvcnRQcm9wZXJ0aWVzfSA9IG1lLFxuICAgICAgICAgICAgY291bnRTb3J0ZXJzICAgICAgPSBzb3J0UHJvcGVydGllcy5sZW5ndGggfHwgMCxcbiAgICAgICAgICAgIGhhc1NvcnRCeU1ldGhvZCAgID0gZmFsc2UsXG4gICAgICAgICAgICBoYXNUcmFuc2Zvcm1WYWx1ZSA9IGZhbHNlLFxuICAgICAgICAgICAgaSwgbWFwcGVkSXRlbXMsIG9iaiwgc29ydGVyLCBzb3J0UHJvcGVydHksIHNvcnRWYWx1ZTtcblxuICAgICAgICBpZiAoY291bnRTb3J0ZXJzID4gMCkge1xuICAgICAgICAgICAgc29ydGVycy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGtleS5zb3J0QnkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzU29ydEJ5TWV0aG9kID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChrZXkudXNlVHJhbnNmb3JtVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzVHJhbnNmb3JtVmFsdWUgPSB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChoYXNTb3J0QnlNZXRob2QpIHtcbiAgICAgICAgICAgICAgICBtZS5faXRlbXMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpID0gMDtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGNvdW50U29ydGVyczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3J0ZXIgICAgPSBzb3J0ZXJzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ydFZhbHVlID0gc29ydGVyW3NvcnRlci5zb3J0QnkgPyAnc29ydEJ5JyA6ICdkZWZhdWx0U29ydEJ5J10oYSwgYik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3J0VmFsdWUgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc29ydFZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChoYXNUcmFuc2Zvcm1WYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb3J0I1NvcnRpbmdfd2l0aF9tYXBcbiAgICAgICAgICAgICAgICAgICAgbWFwcGVkSXRlbXMgPSBpdGVtcy5tYXAoKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSB7aW5kZXh9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaSAgID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBjb3VudFNvcnRlcnM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3J0ZXJzW2ldLnVzZVRyYW5zZm9ybVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ialtzb3J0UHJvcGVydGllc1tpXV0gPSBzb3J0ZXJzW2ldLnRyYW5zZm9ybVZhbHVlKGl0ZW1bc29ydFByb3BlcnRpZXNbaV1dKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ialtzb3J0UHJvcGVydGllc1tpXV0gPSBpdGVtW3NvcnRQcm9wZXJ0aWVzW2ldXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9ialxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXBwZWRJdGVtcyA9IGl0ZW1zXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWFwcGVkSXRlbXMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpID0gMDtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGNvdW50U29ydGVyczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3J0UHJvcGVydHkgPSBzb3J0UHJvcGVydGllc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFbc29ydFByb3BlcnR5XSA+IGJbc29ydFByb3BlcnR5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxICogc29ydERpcmVjdGlvbnNbaV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFbc29ydFByb3BlcnR5XSA8IGJbc29ydFByb3BlcnR5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMSAqIHNvcnREaXJlY3Rpb25zW2ldXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGhhc1RyYW5zZm9ybVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLl9pdGVtcyA9IG1hcHBlZEl0ZW1zLm1hcChlbCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbXNbZWwuaW5kZXhdXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWVbaXNTb3J0ZWRdID0gY291bnRTb3J0ZXJzID4gMDtcblxuICAgICAgICBpZiAoIXNpbGVudCAmJiBtZVt1cGRhdGluZ0luZGV4XSA9PT0gMCkge1xuICAgICAgICAgICAgbWUuZmlyZSgnc29ydCcsIHtcbiAgICAgICAgICAgICAgICBpdGVtczogbWUuX2l0ZW1zLFxuICAgICAgICAgICAgICAgIHByZXZpb3VzSXRlbXMsXG4gICAgICAgICAgICAgICAgc2NvcGU6IG1lXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzdW1lcyB0aGUgY29sbGVjdGlvbiBldmVudHMuXG4gICAgICogSWYgeW91IHN0YXJ0ZWQgYW4gdXBkYXRlIHVzaW5nIHRoZSBzdGFydFNpbGVudFVwZGF0ZU1vZGUgZmxhZyxcbiAgICAgKiB5b3UgbXVzdCB1c2UgdGhlIGVuZFNpbGVudFVwZGF0ZU1vZGUgcGFyYW0gZm9yIHRoaXMgY2FsbC5cbiAgICAgKiBVc2luZyB0aGUgZW5kU2lsZW50VXBkYXRlTW9kZSBwYXJhbSB3aWxsIG5vdCBmaXJlIGEgbXV0YXRpb24gZXZlbnQuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZW5kU2lsZW50VXBkYXRlTW9kZV1cbiAgICAgKiBAc2VlIHtAbGluayBOZW8uY29sbGVjdGlvbi5CYXNlI3N0YXJ0VXBkYXRlIHN0YXJ0VXBkYXRlfVxuICAgICAqL1xuICAgIGVuZFVwZGF0ZShlbmRTaWxlbnRVcGRhdGVNb2RlKSB7XG4gICAgICAgIGNvbnN0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWVbdXBkYXRpbmdJbmRleF0gPiAwKSB7XG4gICAgICAgICAgICBtZVt1cGRhdGluZ0luZGV4XS0tXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kU2lsZW50VXBkYXRlTW9kZSkge1xuICAgICAgICAgICAgbWVbc2lsZW50VXBkYXRlTW9kZV0gPSBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUuZmlyZSgnbXV0YXRlJywge1xuICAgICAgICAgICAgICAgIGFkZGVkSXRlbXMgIDogbWVbdG9BZGRBcnJheV0sXG4gICAgICAgICAgICAgICAgcmVtb3ZlZEl0ZW1zOiBtZVt0b1JlbW92ZUFycmF5XVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lW3RvQWRkQXJyYXldICAgLnNwbGljZSgwLCBtZVt0b0FkZEFycmF5XSAgIC5sZW5ndGgpO1xuICAgICAgICAgICAgbWVbdG9SZW1vdmVBcnJheV0uc3BsaWNlKDAsIG1lW3RvUmVtb3ZlQXJyYXldLmxlbmd0aClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5lZWRlZCBmb3IgcmVtb3RlIGZpbHRlcmluZ1xuICAgICAqIEByZXR1cm5zIHtPYmplY3RbXX1cbiAgICAgKi9cbiAgICBleHBvcnRGaWx0ZXJzKCkge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBmaWx0ZXJzID0gW10sXG4gICAgICAgICAgICBmaWx0ZXI7XG5cbiAgICAgICAgbWUuZmlsdGVycz8uZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgZmlsdGVyID0ga2V5LmV4cG9ydCgpO1xuXG4gICAgICAgICAgICBmaWx0ZXIgJiYgZmlsdGVycy5wdXNoKGZpbHRlcilcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZpbHRlcnNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOZWVkZWQgZm9yIHJlbW90ZSBzb3J0aW5nXG4gICAgICogQHJldHVybnMge09iamVjdFtdfVxuICAgICAqL1xuICAgIGV4cG9ydFNvcnRlcnMoKSB7XG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHNvcnRlcnMgPSBbXSxcbiAgICAgICAgICAgIHNvcnRlcjtcblxuICAgICAgICBtZS5zb3J0ZXJzPy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBzb3J0ZXIgPSBrZXkuZXhwb3J0KCk7XG5cbiAgICAgICAgICAgIHNvcnRlciAmJiBzb3J0ZXJzLnB1c2goc29ydGVyKVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc29ydGVyc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBmaWx0ZXIoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZmlsdGVycyAgICAgICAgID0gbWUuX2ZpbHRlcnMsXG4gICAgICAgICAgICBjb3VudEFsbEZpbHRlcnMgPSBmaWx0ZXJzLmxlbmd0aCxcbiAgICAgICAgICAgIGNvdW50RmlsdGVycyAgICA9IDAsXG4gICAgICAgICAgICBpdGVtcyAgICAgICAgICAgPSBtZS5hbGxJdGVtcz8uX2l0ZW1zIHx8IG1lLl9pdGVtcyxcbiAgICAgICAgICAgIGkgICAgICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICBjb3VudEl0ZW1zICAgICAgPSBpdGVtcy5sZW5ndGgsXG4gICAgICAgICAgICBmaWx0ZXJlZEl0ZW1zICAgPSBbXSxcbiAgICAgICAgICAgIG5lZWRzU29ydGluZyAgICA9IGZhbHNlLFxuICAgICAgICAgICAgb2xkSXRlbXMgICAgICAgID0gWy4uLm1lLl9pdGVtc10sXG4gICAgICAgICAgICBjb25maWcsIGlzSW5jbHVkZWQsIGl0ZW0sIGosIHRtcEl0ZW1zO1xuXG4gICAgICAgIGZvciAoOyBpIDwgY291bnRBbGxGaWx0ZXJzOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghZmlsdGVyc1tpXS5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIGNvdW50RmlsdGVycysrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY291bnRGaWx0ZXJzID09PSAwICYmIG1lLmFsbEl0ZW1zKSB7XG4gICAgICAgICAgICBpZiAobWUuc29ydGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbmVlZHNTb3J0aW5nID0gdHJ1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5jbGVhclNpbGVudCgpO1xuXG4gICAgICAgICAgICBtZS5pdGVtcyA9IFsuLi5tZS5hbGxJdGVtcy5faXRlbXNdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIW1lLmFsbEl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnID0gey4uLm1lLm9yaWdpbmFsQ29uZmlnfTtcblxuICAgICAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuZmlsdGVycztcbiAgICAgICAgICAgICAgICBkZWxldGUgY29uZmlnLml0ZW1zO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuc29ydGVycztcblxuICAgICAgICAgICAgICAgIG1lLmFsbEl0ZW1zID0gTmVvLmNyZWF0ZShDb2xsZWN0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgIC4uLk5lby5jbG9uZShjb25maWcsIHRydWUsIHRydWUpLFxuICAgICAgICAgICAgICAgICAgICBpZCAgICAgICAgIDogbWUuaWQgKyAnLWFsbCcsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zICAgICAgOiBbLi4ubWUuX2l0ZW1zXSwgLy8gSW5pdGlhbGl6ZSB3aXRoIGEgc2hhbGxvdyBjb3B5IG9mIGN1cnJlbnQgaXRlbXNcbiAgICAgICAgICAgICAgICAgICAga2V5UHJvcGVydHk6IG1lLmtleVByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VJZCAgIDogbWUuaWRcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5tYXAuY2xlYXIoKTtcblxuICAgICAgICAgICAgaWYgKG1lLmZpbHRlck1vZGUgPT09ICdwcmltaXRpdmUnKSB7XG4gICAgICAgICAgICAgICAgLy8gdXNpbmcgZm9yIGxvb3BzIG9uIHB1cnBvc2UgLT4gcGVyZm9ybWFuY2VcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnRJdGVtczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzSW5jbHVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpdGVtICAgICAgID0gaXRlbXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGogICAgICAgICAgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBqIDwgY291bnRBbGxGaWx0ZXJzOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJzW2pdLmlzRmlsdGVyZWQoaXRlbSwgaXRlbXMsIGl0ZW1zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzSW5jbHVkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSW5jbHVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkSXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLm1hcC5zZXQoaXRlbVttZS5rZXlQcm9wZXJ0eV0sIGl0ZW0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZS5faXRlbXMgPSBmaWx0ZXJlZEl0ZW1zIC8vIHNpbGVudCB1cGRhdGUsIHRoZSBtYXAgaXMgYWxyZWFkeSBpbiBwbGFjZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZEl0ZW1zID0gWy4uLml0ZW1zXTtcblxuICAgICAgICAgICAgICAgIGZvciAoaj0wOyBqIDwgY291bnRBbGxGaWx0ZXJzOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wSXRlbXMgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnRJdGVtczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbHRlcnNbal0uaXNGaWx0ZXJlZChmaWx0ZXJlZEl0ZW1zW2ldLCBmaWx0ZXJlZEl0ZW1zLCBpdGVtcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBJdGVtcy5wdXNoKGZpbHRlcmVkSXRlbXNbaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZEl0ZW1zID0gWy4uLnRtcEl0ZW1zXTtcbiAgICAgICAgICAgICAgICAgICAgY291bnRJdGVtcyAgICA9IGZpbHRlcmVkSXRlbXMubGVuZ3RoXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWUuaXRlbXMgPSBmaWx0ZXJlZEl0ZW1zIC8vIHVwZGF0ZSB0aGUgbWFwXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtZVtpc0ZpbHRlcmVkXSA9IGNvdW50RmlsdGVycyAhPT0gMDtcblxuICAgICAgICBpZiAobmVlZHNTb3J0aW5nKSB7XG4gICAgICAgICAgICBtZS5kb1NvcnQobWUuaXRlbXMsIHRydWUpXG4gICAgICAgIH1cblxuICAgICAgICBtZS5jb3VudCA9IG1lLml0ZW1zLmxlbmd0aDtcblxuICAgICAgICBtZS5maXJlKCdmaWx0ZXInLCB7XG4gICAgICAgICAgICBpc0ZpbHRlcmVkOiBtZVtpc0ZpbHRlcmVkXSxcbiAgICAgICAgICAgIGl0ZW1zICAgICA6IG1lLml0ZW1zLFxuICAgICAgICAgICAgb2xkSXRlbXMsXG4gICAgICAgICAgICBzY29wZSAgICAgOiBtZVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaXRlbXMgd2hpY2ggbWF0Y2ggdGhlIHByb3BlcnR5IGFuZCB2YWx1ZS5cbiAgICAgKiBQcm9wZXJ0aWVzIGNhbiBjb250YWluIGRvdHMgZm9yIG5hbWVzcGFjZXMgPT4gZmluZCgndmRvbS5pZCcsICduZW8tdm5vZGUtMScpXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gW3ZhbHVlXSBPbmx5IHJlcXVpcmVkIGluIGNhc2UgdGhlIGZpcnN0IHBhcmFtIGlzIGEgc3RyaW5nXG4gICAgICogQHBhcmFtIHtCb29sZWFufSByZXR1cm5GaXJzdE1hdGNoPWZhbHNlXG4gICAgICogQHJldHVybnMge09iamVjdHxPYmplY3RbXX1cbiAgICAgKiAgICAgcmV0dXJuRmlyc3RNYXRjaD1mYWxzZTogUmV0dXJucyBhbiBlbXB0eSBBcnJheSBpbiBjYXNlIG5vIGl0ZW1zIGFyZSBmb3VuZFxuICAgICAqICAgICByZXR1cm5GaXJzdE1hdGNoPXRydWU6ICBSZXR1cm5zIHRoZSBmaXJzdCBmb3VuZCBpdGVtIG9yIG51bGxcbiAgICAgKi9cbiAgICBmaW5kKHByb3BlcnR5LCB2YWx1ZSwgcmV0dXJuRmlyc3RNYXRjaD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtcyAgICAgICAgICAgID0gW10sXG4gICAgICAgICAgICBpc09iamVjdFByb3BlcnR5ID0gbWUuaXNJdGVtKHByb3BlcnR5KSxcbiAgICAgICAgICAgIGl0ZW0sIG1hdGNoQXJyYXksIHByb3BlcnRpZXNBcnJheSwgcHJvcGVydGllc0xlbmd0aDtcblxuICAgICAgICBpZiAoaXNPYmplY3RQcm9wZXJ0eSkge1xuICAgICAgICAgICAgcHJvcGVydGllc0FycmF5ICA9IE9iamVjdC5lbnRyaWVzKHByb3BlcnR5KTtcbiAgICAgICAgICAgIHByb3BlcnRpZXNMZW5ndGggPSBwcm9wZXJ0aWVzQXJyYXkubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpdGVtIG9mIG1lLml0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3RQcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIG1hdGNoQXJyYXkgPSBbXTtcblxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXNBcnJheS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE5lby5ucyhrZXksIGZhbHNlLCBpdGVtKSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoQXJyYXkucHVzaCh0cnVlKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hBcnJheS5sZW5ndGggPT09IHByb3BlcnRpZXNMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldHVybkZpcnN0TWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChOZW8ubnMocHJvcGVydHksIGZhbHNlLCBpdGVtKSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAocmV0dXJuRmlyc3RNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXR1cm5GaXJzdE1hdGNoID8gbnVsbCA6IGl0ZW1zXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgaXRlbXMgaW4gdGhlIGNvbGxlY3Rpb24gZm9yIHdoaWNoIHRoZSBwYXNzZWQgZnVuY3Rpb24gcmV0dXJucyB0cnVlXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIHJ1biBmb3IgZWFjaCBpdGVtIGluc2lkZSB0aGUgc3RhcnQtZW5kIHJhbmdlLiBSZXR1cm4gdHJ1ZSBmb3IgYSBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZm4uaXRlbSBUaGUgY3VycmVudCBjb2xsZWN0aW9uIGl0ZW1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2NvcGU9dGhpcyBUaGUgc2NvcGUgaW4gd2hpY2ggdGhlIHBhc3NlZCBmdW5jdGlvbiBnZXRzIGV4ZWN1dGVkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0PTAgVGhlIHN0YXJ0IGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZD10aGlzLmNvdW50IFRoZSBlbmQgaW5kZXggKHVwIHRvLCBsYXN0IHZhbHVlIGV4Y2x1ZGVkKVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBlbXB0eSBBcnJheSBpbiBjYXNlIG5vIGl0ZW1zIGFyZSBmb3VuZFxuICAgICAqL1xuICAgIGZpbmRCeShmbiwgc2NvcGU9dGhpcywgc3RhcnQ9MCwgZW5kPXRoaXMuY291bnQpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW1zID0gW10sXG4gICAgICAgICAgICBpICAgICA9IHN0YXJ0O1xuXG4gICAgICAgIGZvciAoOyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChmbi5jYWxsKHNjb3BlLCBtZS5pdGVtc1tpXSkpIHtcbiAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKG1lLml0ZW1zW2ldKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGl0ZW1zXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgaXRlbSB3aGljaCBtYXRjaGVzIHRoZSBwcm9wZXJ0eSBhbmQgdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBbdmFsdWVdIE9ubHkgcmVxdWlyZWQgaW4gY2FzZSB0aGUgZmlyc3QgcGFyYW0gaXMgYSBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBmaXJzdCBmb3VuZCBpdGVtIG9yIG51bGxcbiAgICAgKi9cbiAgICBmaW5kRmlyc3QocHJvcGVydHksIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmQocHJvcGVydHksIHZhbHVlLCB0cnVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGl0ZW0gaW5zaWRlIHRoZSBjb2xsZWN0aW9uXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBmaXJzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXQoMClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBvYmplY3QgYXNzb2NpYXRlZCB0byB0aGUga2V5LCBvciBudWxsIGlmIHRoZXJlIGlzIG5vbmUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBrZXlcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgZ2V0KGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAuZ2V0KGtleSkgfHwgbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGl0ZW0gZm9yIGEgZ2l2ZW4gaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXRBdChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXNbaW5kZXhdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29uZmlnIHZhbHVlIG9mIHRoaXMuY291bnRcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBgdGhpcy5jb3VudGAgZGlyZWN0bHkgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBnZXRDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvdW50IHx8IDAgLy8gc2tpcHBpbmcgYmVmb3JlR2V0Q291bnQoKSBvbiBwdXJwb3NlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRDb3VudE11dGF0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbY291bnRNdXRhdGlvbnNdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgbWF0Y2hpbmcgZmlsdGVyIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkgY29uZmlnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAgICogQHJldHVybnMge05lby5jb2xsZWN0aW9uLkZpbHRlcnxudWxsfVxuICAgICAqL1xuICAgIGdldEZpbHRlcihwcm9wZXJ0eSkge1xuICAgICAgICBsZXQgZmlsdGVycyA9IHRoaXMuZmlsdGVycyB8fCBbXSxcbiAgICAgICAgICAgIGkgICAgICAgPSAwLFxuICAgICAgICAgICAgbGVuICAgICA9IGZpbHRlcnMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChmaWx0ZXJzW2ldLnByb3BlcnR5ID09PSBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJzW2ldXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGtleSBmb3IgYSBnaXZlbiBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8U3RyaW5nfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXRLZXlBdChpbmRleCkge1xuICAgICAgICBsZXQgaXRlbSA9IHRoaXMuX2l0ZW1zW2luZGV4XTtcbiAgICAgICAgcmV0dXJuIGl0ZW0/Llt0aGlzLmtleVByb3BlcnR5XVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzaGFsbG93IGNvcHkgb2YgYSBwb3J0aW9uIG9mIHRoZSBpdGVtcyBhcnJheVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRdIFplcm8tYmFzZWQgaW5kZXggYXQgd2hpY2ggdG8gYmVnaW4gZXh0cmFjdGlvbi5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2VuZF0gWmVyby1iYXNlZCBpbmRleCBiZWZvcmUgd2hpY2ggdG8gZW5kIGV4dHJhY3Rpb24gKGV4dHJhY3RzIHVwIHRvIGJ1dCBub3QgaW5jbHVkaW5nIGVuZCkuXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqIEBsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NsaWNlXG4gICAgICovXG4gICAgZ2V0UmFuZ2Uoc3RhcnQsIGVuZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXMuc2xpY2Uoc3RhcnQsIGVuZClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBTb3VyY2UgQ29sbGVjdGlvbiBpbiBjYXNlIHRoZSBzb3VyY2VDb2xsZWN0aW9uSWQgY29uZmlnIHdhcyBzZXRcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbGxlY3Rpb24uQmFzZXx1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0U291cmNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VJZCAmJiBOZW8uZ2V0KHRoaXMuc291cmNlSWQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGJvb2xlYW4gYXNzZXJ0aW5nIHdoZXRoZXIgYSB2YWx1ZSBoYXMgYmVlbiBhc3NvY2lhdGVkIHRvIHRoZSBrZXkgaW4gdGhlIENvbGxlY3Rpb24gb3Igbm90XG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBrZXlcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcC5oYXMoa2V5KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBib29sZWFuIGFzc2VydGluZyB3aGV0aGVyIGFuIGl0ZW0gZXhpc3RzIGluIHRoZSBDb2xsZWN0aW9uIG9yIG5vdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzSXRlbShpdGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcC5oYXMoaXRlbVt0aGlzLmtleVByb3BlcnR5XSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBmb3IgYSBnaXZlbiBrZXkgb3IgaXRlbVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xPYmplY3R9IGtleVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IGluZGV4ICgtMSBpbiBjYXNlIG5vIG1hdGNoIGlzIGZvdW5kKVxuICAgICAqL1xuICAgIGluZGV4T2Yoa2V5KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBtZS5faXRlbXMuaW5kZXhPZihtZS5pc0l0ZW0oa2V5KSA/IGtleSA6IG1lLm1hcC5nZXQoa2V5KSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBmb3IgYSBnaXZlbiBpdGVtXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBpbmRleCAoLTEgaW4gY2FzZSBubyBtYXRjaCBpcyBmb3VuZClcbiAgICAgKi9cbiAgICBpbmRleE9mSXRlbShpdGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtcy5pbmRleE9mKGl0ZW0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW5kZXggZm9yIGEgZ2l2ZW4ga2V5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBrZXlcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBpbmRleCAoLTEgaW4gY2FzZSBubyBtYXRjaCBpcyBmb3VuZClcbiAgICAgKi9cbiAgICBpbmRleE9mS2V5KGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXMuaW5kZXhPZih0aGlzLm1hcC5nZXQoa2V5KSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGFuIGl0ZW0gb3IgYW4gYXJyYXkgb2YgaXRlbXMgYXQgdGhlIHNwZWNpZmllZCBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBpdGVtXG4gICAgICogQHJldHVybnMge09iamVjdFtdfSBhbiBhcnJheSBjb250YWluaW5nIGFsbCBhZGRlZCBpdGVtc1xuICAgICAqL1xuICAgIGluc2VydChpbmRleCwgaXRlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zcGxpY2UoaW5kZXgsIDAsIGl0ZW0pLmFkZGVkSXRlbXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpbiBjYXNlIHRoZSBjb2xsZWN0aW9uIGlzIGZpbHRlcmVkXG4gICAgICovXG4gICAgaXNGaWx0ZXJlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbaXNGaWx0ZXJlZF1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpc0ZpbHRlcmVkSXRlbShpdGVtKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGZpbHRlcnMgICAgPSBtZS5fZmlsdGVycyxcbiAgICAgICAgICAgIGkgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgbGVuICAgICAgICA9IGZpbHRlcnMubGVuZ3RoLFxuICAgICAgICAgICAgaXNGaWx0ZXJlZCA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChmaWx0ZXJzW2ldLmlzRmlsdGVyZWQoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBpc0ZpbHRlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlzRmlsdGVyZWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIGNoZWNrIGlmIGEgZ2l2ZW4gaW5wdXQgaXMgZWl0aGVyIG9iamVjdC1saWtlIG9yIGEga2V5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSByZXR1cm5zIHRydWUgZm9yIG9iamVjdC1saWtlIHZhbHVlc1xuICAgICAqL1xuICAgIGlzSXRlbSh2YWx1ZSkge1xuICAgICAgICAvLyBXZSBjYW4gbm90IHVzZSBOZW8uaXNPYmplY3QoKSB8fCBOZW8uaXNSZWNvcmQoKSwgc2luY2UgY29sbGVjdGlvbnMgY2FuIHN0b3JlIG5lbyBpbnN0YW5jZXMgdG9vLlxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0J1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGluIGNhc2UgdGhlIGNvbGxlY3Rpb24gaXMgc29ydGVkXG4gICAgICovXG4gICAgaXNTb3J0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW2lzU29ydGVkXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxhc3QgaXRlbSBpbnNpZGUgdGhlIGNvbGxlY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGxhc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEF0KHRoaXMuY291bnQgLTEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgYW4gaXRlbSBmcm9tIGZyb21JbmRleCB0byB0b0luZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZyb21JbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0b0luZGV4XG4gICAgICovXG4gICAgbW92ZShmcm9tSW5kZXgsIHRvSW5kZXgpIHtcbiAgICAgICAgaWYgKGZyb21JbmRleCA9PT0gdG9JbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGl0ZW1zID0gdGhpcy5faXRlbXM7XG5cbiAgICAgICAgaWYgKGZyb21JbmRleCA+PSBpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZyb21JbmRleCA9IGl0ZW1zLmxlbmd0aCAtIDFcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBzcGxpY2Ugb3BlcmF0aW9ucyBhcmUgaW50ZW50aW9uYWxseSBzZXBhcmF0ZWQuXG4gICAgICAgIC8vIFVzaW5nIHRoZSBjb21tb24gb25lLWxpbmVyIGBpdGVtcy5zcGxpY2UodG9JbmRleCwgMCwgaXRlbXMuc3BsaWNlKGZyb21JbmRleCwgMSlbMF0pYFxuICAgICAgICAvLyBjYW4gbGVhZCB0byB1bnByZWRpY3RhYmxlIHNpZGUgZWZmZWN0cywgYXMgdGhlIGlubmVyIHNwbGljZSBjYW4gYWx0ZXIgdGhlIGFycmF5XG4gICAgICAgIC8vIGJlZm9yZSB0aGUgb3V0ZXIgc3BsaWNlJ3MgaW5kZXggaXMgcmVzb2x2ZWQuIFRoaXMgdHdvLXN0ZXAgYXBwcm9hY2ggaXMgc2FmZXIuXG4gICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtcy5zcGxpY2UoZnJvbUluZGV4LCAxKVswXTtcbiAgICAgICAgaXRlbXMuc3BsaWNlKHRvSW5kZXgsIDAsIGl0ZW0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25GaWx0ZXJDaGFuZ2Uob3B0cykge1xuICAgICAgICB0aGlzLmZpbHRlcigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25NdXRhdGUob3B0cykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIC8vIHRvZG86IGluc3BlY3QgdGhlIGJ1YmJsaW5nIGNoYWluXG4gICAgICAgIC8qaWYgKG9wdHMucHJldmVudEJ1YmJsZVVwKSB7XG4gICAgICAgICAgICBtZS5wcmV2ZW50QnViYmxlVXAgPSB0cnVlXG4gICAgICAgIH0qL1xuXG4gICAgICAgIG1lLnByZXZlbnRCdWJibGVVcCA9IHRydWU7XG5cbiAgICAgICAgbWUuc3BsaWNlKG51bGwsIG9wdHMucmVtb3ZlZEl0ZW1zLCBvcHRzLmFkZGVkSXRlbXMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25Tb3J0ZXJDaGFuZ2Uob3B0cykge1xuICAgICAgICB0aGlzLmFwcGx5U29ydGVyQ29uZmlncygpO1xuICAgICAgICB0aGlzLmRvU29ydCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgbGFzdCBlbGVtZW50IGZyb20gdGhlIGl0ZW1zIGFycmF5IGFuZCByZXR1cm5zIHRoaXMgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcmVtb3ZlZCBlbGVtZW50IGZyb20gdGhlIGNvbGxlY3Rpb247IHVuZGVmaW5lZCBpZiB0aGUgY29sbGVjdGlvbiBpcyBlbXB0eS5cbiAgICAgKi9cbiAgICBwb3AoKSB7XG4gICAgICAgIGxldCBtdXRhdGlvbiA9IHRoaXMuc3BsaWNlKHRoaXMuY291bnQgLTEsIDEpO1xuICAgICAgICByZXR1cm4gbXV0YXRpb24ucmVtb3ZlZEl0ZW1zWzBdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBvbmUgb3IgbW9yZSBpdGVtcyB0byB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uIGFuZCByZXR1cm5zIHRoZSBuZXcgaXRlbXMgY291bnRcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gaXRlbSBUaGUgaXRlbShzKSB0byBhZGRcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgY29sbGVjdGlvbiBjb3VudFxuICAgICAqL1xuICAgIHB1c2goaXRlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGQoaXRlbSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgZ2l2ZW4ga2V5LCBpdGVtIG9yIEFycmF5IGNvbnRhaW5pbmcga2V5c3xpdGVtc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xPYmplY3R8QXJyYXl9IGtleVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBjb2xsZWN0aW9uIGNvdW50XG4gICAgICovXG4gICAgcmVtb3ZlKGtleSkge1xuICAgICAgICB0aGlzLnNwbGljZSgwLCBBcnJheS5pc0FycmF5KGtleSkgPyBrZXkgOiBba2V5XSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvdW50XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgaXRlbSBhdCB0aGUgZ2l2ZW4gaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgY29sbGVjdGlvbiBjb3VudFxuICAgICAqL1xuICAgIHJlbW92ZUF0KGluZGV4KSB7XG4gICAgICAgIHRoaXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY291bnRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnNlcyB0aGUgaXRlbXMgYXJyYXkgaW4gcGxhY2UuXG4gICAgICogSW50ZW5kZWQgZm9yIGNvbGxlY3Rpb25zIHdpdGhvdXQgc29ydGVycy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGl0ZW1zXG4gICAgICovXG4gICAgcmV2ZXJzZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zLnJldmVyc2UoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGZpcnN0IGVsZW1lbnQgZnJvbSB0aGUgaXRlbXMgYXJyYXkgYW5kIHJldHVybnMgdGhpcyBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSByZW1vdmVkIGVsZW1lbnQgZnJvbSB0aGUgY29sbGVjdGlvbjsgdW5kZWZpbmVkIGlmIHRoZSBjb2xsZWN0aW9uIGlzIGVtcHR5LlxuICAgICAqL1xuICAgIHNoaWZ0KCkge1xuICAgICAgICBsZXQgbXV0YXRpb24gPSB0aGlzLnNwbGljZSgwLCAxKTtcbiAgICAgICAgcmV0dXJuIG11dGF0aW9uLmFkZGVkSXRlbXNbMF1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBGdW5jdGlvbiB0byB0ZXN0IGZvciBlYWNoIGl0ZW0sIHRha2luZyB0aHJlZSBwYXJhbWV0ZXJzOlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgIGNhbGxiYWNrLml0ZW0gVGhlIGN1cnJlbnQgY29sbGVjdGlvbiBpdGVtIGJlaW5nIHByb2Nlc3NlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgW2NhbGxiYWNrLmluZGV4XSBUaGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgaXRlbSBiZWluZyBwcm9jZXNzZWRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgIFtjYWxsYmFjay5pdGVtc10gVGhlIGl0ZW1zIGFycmF5IG9mIHRoZSBjb2xsZWN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSBWYWx1ZSB0byB1c2UgYXMgXCJ0aGlzXCIgd2hlbiBleGVjdXRpbmcgdGhlIGNhbGxiYWNrXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHJldHVybnMgYSB0cnV0aHkgdmFsdWUgZm9yIGFueSBjb2xsZWN0aW9uIGl0ZW0sIG90aGVyd2lzZSBmYWxzZVxuICAgICAqL1xuICAgIHNvbWUoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXMuc29tZSguLi5hcmdzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIGEgcHJvdmlkZWQgZnVuY3Rpb24gb25jZSBmb3IgZWFjaCBhcnJheSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBleGVjdXRlIGZvciBlYWNoIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV0gVmFsdWUgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyBgZm5gLlxuICAgICAqL1xuICAgIGZvckVhY2goZm4sIHNjb3BlKSB7XG4gICAgICAgIHRoaXMuX2l0ZW1zLmZvckVhY2goZm4sIHNjb3BlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGl0ZW1zIGZyb20gYW5kL29yIGFkZHMgaXRlbXMgdG8gdGhpcyBjb2xsZWN0aW9uXG4gICAgICogSWYgdGhlIHRvUmVtb3ZlQXJyYXkgaXMgdXNlZCwgdGhlbiB0aGUgaW5kZXggaXMgbm90IHVzZWQgZm9yIHJlbW92aW5nLCB0aGUgZW50cmllcyBhcmUgZm91bmQgYnkga2V5IGFuZCByZW1vdmVkIGZyb20gd2hlcmUgdGhleSBhcmUuXG4gICAgICogSWYgaW5kZXggaXMgbm90IHBhc3NlZCwgdG9BZGRBcnJheSBpcyBhcHBlbmRlZCB0byB0aGUgQ29sbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdFtdfSBbcmVtb3ZlQ291bnRPclRvUmVtb3ZlQXJyYXldXG4gICAgICogQHBhcmFtIHtPYmplY3R8T2JqZWN0W119IFt0b0FkZEFycmF5XVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBhZGRlZEl0ZW1zICYgcmVtb3ZlZEl0ZW1zIGFycmF5c1xuICAgICAqL1xuICAgIHNwbGljZShpbmRleCwgcmVtb3ZlQ291bnRPclRvUmVtb3ZlQXJyYXksIHRvQWRkQXJyYXkpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7a2V5UHJvcGVydHksIG1hcH0gPSBtZSxcbiAgICAgICAgICAgIHNvdXJjZSAgICAgICAgICAgICA9IG1lLmdldFNvdXJjZSgpLFxuICAgICAgICAgICAgYWRkZWRJdGVtcyAgICAgICAgID0gW10sXG4gICAgICAgICAgICBpdGVtcyAgICAgICAgICAgICAgPSBtZS5faXRlbXMsXG4gICAgICAgICAgICByZW1vdmVkSXRlbXMgICAgICAgPSBbXSxcbiAgICAgICAgICAgIHJlbW92ZUNvdW50QXRJbmRleCA9IE5lby5pc051bWJlcihyZW1vdmVDb3VudE9yVG9SZW1vdmVBcnJheSkgPyByZW1vdmVDb3VudE9yVG9SZW1vdmVBcnJheSA6IG51bGwsXG4gICAgICAgICAgICB0b1JlbW92ZUFycmF5ICAgICAgPSBBcnJheS5pc0FycmF5KHJlbW92ZUNvdW50T3JUb1JlbW92ZUFycmF5KSA/IHJlbW92ZUNvdW50T3JUb1JlbW92ZUFycmF5IDogbnVsbCxcbiAgICAgICAgICAgIGksIGl0ZW0sIGtleSwgbGVuLCB0b0FkZE1hcDtcblxuICAgICAgICBpZiAoIU5lby5pc051bWJlcihpbmRleCkgJiYgcmVtb3ZlQ291bnRBdEluZGV4KSB7XG4gICAgICAgICAgICBMb2dnZXIuZXJyb3IobWUuaWQgKyAnOiBJZiBpbmRleCBpcyBub3QgcGFzc2VkLCByZW1vdmVDb3VudEF0SW5kZXggY2Fubm90IGJlIHVzZWQnKVxuICAgICAgICB9XG5cbiAgICAgICAgdG9BZGRBcnJheSA9IHRvQWRkQXJyYXkgJiYgIUFycmF5LmlzQXJyYXkodG9BZGRBcnJheSkgPyBbdG9BZGRBcnJheV0gOiB0b0FkZEFycmF5O1xuXG4gICAgICAgIGlmICh0b1JlbW92ZUFycmF5ICYmIChsZW4gPSB0b1JlbW92ZUFycmF5Lmxlbmd0aCkgPiAwKSB7XG4gICAgICAgICAgICBpZiAodG9BZGRBcnJheSAmJiB0b0FkZEFycmF5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0b0FkZE1hcCA9IHRvQWRkQXJyYXkubWFwKGUgPT4gZVtrZXlQcm9wZXJ0eV0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaT0wOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpdGVtID0gdG9SZW1vdmVBcnJheVtpXTtcbiAgICAgICAgICAgICAgICBrZXkgID0gbWUuaXNJdGVtKGl0ZW0pID8gaXRlbVtrZXlQcm9wZXJ0eV0gOiBpdGVtO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1hcC5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRvQWRkTWFwIHx8ICh0b0FkZE1hcCAmJiB0b0FkZE1hcC5pbmRleE9mKGtleSkgPCAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZEl0ZW1zLnB1c2goaXRlbXMuc3BsaWNlKG1lLmluZGV4T2ZLZXkoa2V5KSwgMSlbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLmRlbGV0ZShrZXkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocmVtb3ZlQ291bnRBdEluZGV4ICYmIHJlbW92ZUNvdW50QXRJbmRleCA+IDApIHtcbiAgICAgICAgICAgIC8vIE9wdGltaXphdGlvbjogSWYgdGhpcyBpcyBhIGZ1bGwgY2xlYXIgb3BlcmF0aW9uLCB1c2UgbWFwLmNsZWFyKClcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCAmJiByZW1vdmVDb3VudEF0SW5kZXggPT09IG1lLmNvdW50KSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlZEl0ZW1zID0gaXRlbXM7XG4gICAgICAgICAgICAgICAgbWUuX2l0ZW1zID0gW107XG4gICAgICAgICAgICAgICAgbWFwLmNsZWFyKClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlZEl0ZW1zID0gaXRlbXMuc3BsaWNlKGluZGV4LCByZW1vdmVDb3VudEF0SW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgLy8gRm9yIHBhcnRpYWwgcmVtb3ZhbHMsIGl0ZXJhdGUgYW5kIGRlbGV0ZSBpbmRpdmlkdWFsIGl0ZW1zIGZyb20gdGhlIG1hcFxuICAgICAgICAgICAgICAgIHJlbW92ZWRJdGVtcy5mb3JFYWNoKGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBtYXAuZGVsZXRlKGVba2V5UHJvcGVydHldKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9BZGRBcnJheSAmJiAobGVuID0gdG9BZGRBcnJheS5sZW5ndGgpID4gMCkge1xuICAgICAgICAgICAgZm9yIChpPTA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSB0b0FkZEFycmF5W2ldO1xuICAgICAgICAgICAgICAgIGtleSAgPSBpdGVtW2tleVByb3BlcnR5XTtcblxuICAgICAgICAgICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1ba2V5UHJvcGVydHldID0ga2V5ID0gbWUua2V5UHJvcGVydHlJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgbWUua2V5UHJvcGVydHlJbmRleC0tXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFtYXAuaGFzKGtleSkgJiYgIW1lLmlzRmlsdGVyZWRJdGVtKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZGVkSXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgbWFwLnNldChrZXksIGl0ZW0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYWRkZWRJdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtcyB8fCBpdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGVyZm9ybWFuY2UgaW1wcm92ZW1lbnQgZm9yIFNhZmFyaSwgc2VlOiBodHRwczovL2dpdGh1Yi5jb20vbmVvbWpzL25lby9pc3N1ZXMvNjIyOFxuICAgICAgICAgICAgICAgICAgICBtZS5faXRlbXMgPSBhZGRlZEl0ZW1zXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmluYWxJbmRleCA9IE5lby5pc051bWJlcihpbmRleCkgPyBpbmRleCA6IGl0ZW1zLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkZWRJdGVtcy5sZW5ndGggPiA1MDAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYW51YWxseSBzcGxpY2UgZm9yIGxhcmdlIGFycmF5cyB0byBhdm9pZCBhIHN0YWNrIG92ZXJmbG93XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiZWdpbm5pbmcgPSBpdGVtcy5zbGljZSgwLCBmaW5hbEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZCAgICAgICA9IGl0ZW1zLnNsaWNlKGZpbmFsSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUuX2l0ZW1zICAgICAgID0gYmVnaW5uaW5nLmNvbmNhdChhZGRlZEl0ZW1zLCBlbmQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMuc3BsaWNlKGZpbmFsSW5kZXgsIDAsIC4uLmFkZGVkSXRlbXMpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobWUuYXV0b1NvcnQgJiYgbWUuX3NvcnRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBtZS5kb1NvcnQoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmICghc291cmNlLmdldFNvdXJjZSgpKSB7XG4gICAgICAgICAgICAgICAgc291cmNlLnByZXZlbnRCdWJibGVVcCA9IHRydWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFtZS5wcmV2ZW50QnViYmxlVXApIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnc291cmNlIHNwbGljZScsIHNvdXJjZS5pZCwgJ2FkZGVkOicsIC4uLnRvQWRkQXJyYXksICdyZW1vdmVkOicsIC4uLnJlbW92ZWRJdGVtcyk7XG4gICAgICAgICAgICAgICAgbWUuc3RhcnRVcGRhdGUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgc291cmNlLnNwbGljZShudWxsLCB0b1JlbW92ZUFycmF5IHx8IHJlbW92ZWRJdGVtcywgdG9BZGRBcnJheSk7XG4gICAgICAgICAgICAgICAgbWUuZW5kVXBkYXRlKHRydWUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbGV0ZSBzb3VyY2UucHJldmVudEJ1YmJsZVVwXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWRkZWRJdGVtcy5sZW5ndGggPiAwIHx8IHJlbW92ZWRJdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBtZVtjb3VudE11dGF0aW9uc10rK1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lW3VwZGF0aW5nSW5kZXhdID09PSAwKSB7XG4gICAgICAgICAgICBtZS5jb3VudCA9IG1lLl9pdGVtcy5sZW5ndGg7XG5cbiAgICAgICAgICAgIG1lLmZpcmUoJ211dGF0ZScsIHtcbiAgICAgICAgICAgICAgICBhZGRlZEl0ZW1zICAgICA6IHRvQWRkQXJyYXksXG4gICAgICAgICAgICAgICAgcHJldmVudEJ1YmJsZVVwOiBtZS5wcmV2ZW50QnViYmxlVXAsXG4gICAgICAgICAgICAgICAgcmVtb3ZlZEl0ZW1zICAgOiB0b1JlbW92ZUFycmF5IHx8IHJlbW92ZWRJdGVtc1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIGlmICghbWVbc2lsZW50VXBkYXRlTW9kZV0pIHtcbiAgICAgICAgICAgIG1lLmNhY2hlVXBkYXRlKHtcbiAgICAgICAgICAgICAgICBhZGRlZEl0ZW1zLFxuICAgICAgICAgICAgICAgIHJlbW92ZWRJdGVtc1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZVt1cGRhdGluZ0luZGV4XSA9PT0gMCkge1xuICAgICAgICAgICAgZGVsZXRlIG1lLnByZXZlbnRCdWJibGVVcFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHthZGRlZEl0ZW1zLCByZW1vdmVkSXRlbXN9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJldmVudHMgdGhlIGNvbGxlY3Rpb24gZnJvbSBmaXJpbmcgZXZlbnRzIHVudGlsIGVuZFVwZGF0ZSBnZXRzIGNhbGxlZC5cbiAgICAgKiBJZiB5b3Ugc3RhcnQgYW4gdXBkYXRlIHVzaW5nIHRoZSBzdGFydFNpbGVudFVwZGF0ZU1vZGUgcGFyYW0sXG4gICAgICogdGhlIG11dGF0aW9uIGV2ZW50IHdpbGwgbm90IGZpcmUgYWZ0ZXIgdXNpbmcgZW5kVXBkYXRlKClcbiAgICAgKiAoeW91IG11c3QgdXNlIHRoZSBlbmRTaWxlbnRVcGRhdGVNb2RlIHBhcmFtIGZvciB0aGUgZW5kVXBkYXRlIGNhbGwgaW4gY2FzZSB5b3UgdXNlZFxuICAgICAqIHN0YXJ0U2lsZW50VXBkYXRlTW9kZSBoZXJlKVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3N0YXJ0U2lsZW50VXBkYXRlTW9kZV1cbiAgICAgKiBAc2VlIHtAbGluayBOZW8uY29sbGVjdGlvbi5CYXNlI2VuZFVwZGF0ZSBlbmRVcGRhdGV9XG4gICAgICovXG4gICAgc3RhcnRVcGRhdGUoc3RhcnRTaWxlbnRVcGRhdGVNb2RlKSB7XG4gICAgICAgIGlmIChzdGFydFNpbGVudFVwZGF0ZU1vZGUpIHtcbiAgICAgICAgICAgIHRoaXNbc2lsZW50VXBkYXRlTW9kZV0gPSB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzW3VwZGF0aW5nSW5kZXhdKytcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIG9uZSBvciBtb3JlIGVsZW1lbnRzIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGNvbGxlY3Rpb24gYW5kIHJldHVybnMgdGhlIG5ldyBpdGVtcyBjb3VudFxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBpdGVtIFRoZSBpdGVtKHMpIHRvIGFkZFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBjb2xsZWN0aW9uIGNvdW50XG4gICAgICovXG4gICAgdW5zaGlmdChpdGVtKSB7XG4gICAgICAgIHRoaXMuc3BsaWNlKDAsIDAsIGl0ZW0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb3VudFxuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbXV0YXRlIGV2ZW50IGZpcmVzIGFmdGVyIGV2ZXJ5IHNwbGljZSBjYWxsIChpbnZva2VkIGJ5IGFsbCBtZXRob2RzIHdoaWNoIGNoYW5nZSB0aGUgY29udGVudCBvZiB0aGUgaXRlbXMgYXJyYXkpLlxuICogQGV2ZW50IG11dGF0ZVxuICogQHBhcmFtIHtPYmplY3RbXX0gYWRkZWRJdGVtc1xuICogQHBhcmFtIHtCb29sZWFufSBwcmV2ZW50QnViYmxlVXAgcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3RbXX0gcmVtb3ZlZEl0ZW1zXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKENvbGxlY3Rpb24pO1xuIiwiaW1wb3J0IEJhc2UgICAgICAgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQgT2JzZXJ2YWJsZSBmcm9tICcuLi9jb3JlL09ic2VydmFibGUubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNvbGxlY3Rpb24uRmlsdGVyXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKiBAbWl4ZXMgTmVvLmNvcmUuT2JzZXJ2YWJsZVxuICovXG5jbGFzcyBGaWx0ZXIgZXh0ZW5kcyBCYXNlIHtcbiAgICAvKipcbiAgICAgKiBUcnVlIGF1dG9tYXRpY2FsbHkgYXBwbGllcyB0aGUgY29yZS5PYnNlcnZhYmxlIG1peGluXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gb2JzZXJ2YWJsZT10cnVlXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBvYnNlcnZhYmxlID0gdHJ1ZVxuICAgIC8qKlxuICAgICAqIFZhbGlkIHZhbHVlcyBmb3IgdGhlIG9wZXJhdG9yIGNvbmZpZzo8YnI+XG4gICAgICogWyc9PScsJz09PScsJyE9JywnIT09JywnPCcsJzw9JywnPicsJz49JywnZW5kc1dpdGgnLCdleGNsdWRlZCcsJ2luY2x1ZGVkJywnaXNEZWZpbmVkJywnaXNVbmRlZmluZWQnLCdsaWtlJywnc3RhcnRzV2l0aCddXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IG9wZXJhdG9yc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIG9wZXJhdG9ycyA9IFtcbiAgICAgICAgJz09JywgJz09PScsICchPScsICchPT0nLCAnPCcsICc8PScsICc+JywgJz49JywgJ2VuZHNXaXRoJywgJ2V4Y2x1ZGVkJywgJ2luY2x1ZGVkJyxcbiAgICAgICAgJ2lzRGVmaW5lZCcsICdpc1VuZGVmaW5lZCcsICdsaWtlJywgJ3N0YXJ0c1dpdGgnXG4gICAgXVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29sbGVjdGlvbi5GaWx0ZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb2xsZWN0aW9uLkZpbHRlcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdmaWx0ZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnZmlsdGVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHRpbmcgZGlzYWJsZWQgdG8gdHJ1ZSB3aWxsIGV4Y2x1ZGUgdGhpcyBmaWx0ZXIgZnJvbSB0aGUgY29sbGVjdGlvbiBmaWx0ZXJpbmcgbG9naWNcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZGlzYWJsZWRfPWZhbHNlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZWRfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3ZpZGUgYSBjdXN0b20gZmlsdGVyaW5nIGZ1bmN0aW9uIHdoaWNoIGhhcyBhIGhpZ2hlciBwcmlvcml0eSB0aGFuIHByb3BlcnR5LCBvcGVyYXRvciAmIHZhbHVlXG4gICAgICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufG51bGx9IGZpbHRlckJ5Xz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgZmlsdGVyQnlfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSBtZWFucyBub3QgZmlsdGVyaW5nIG91dCBpdGVtcyBpbiBjYXNlIHRoZSB2YWx1ZSBpcyAnJywgbnVsbCwgW10gb3Ige31cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaW5jbHVkZUVtcHR5VmFsdWVzPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGluY2x1ZGVFbXB0eVZhbHVlczogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGlzIGZsYWcgdG8gdHJ1ZSBiZWZvcmUgc3RhcnRpbmcgYnVsayB1cGRhdGVzIChlLmcuIGNoYW5naW5nIHByb3BlcnR5ICYgdmFsdWUpXG4gICAgICAgICAqIHRvIHByZXZlbnQgbXVsdGlwbGUgY2hhbmdlIGV2ZW50c1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc1VwZGF0aW5nXz1mYWxzZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGlzVXBkYXRpbmdfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBvd25lciB1dGlsLkNvbGxlY3Rpb24gbmVlZHMgdG8gYXBwbHkgYW4gb25DaGFuZ2UgbGlzdGVuZXIgb25jZVxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBsaXN0ZW5lckFwcGxpZWQ9ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdGVuZXJBcHBsaWVkOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBvcGVyYXRvciB0byBmaWx0ZXIgYnkgKHVzZSB0aGUgY29tYmluYXRpb24gb2YgcHJvcGVydHksIG9wZXJhdG9yICYgdmFsdWUpXG4gICAgICAgICAqIFZhbGlkIHZhbHVlczpcbiAgICAgICAgICpcbiAgICAgICAgICogPT0gKG5vdCByZWNvbW1lbmRlZClcbiAgICAgICAgICogPT09XG4gICAgICAgICAqICE9IChub3QgcmVjb21tZW5kZWQpXG4gICAgICAgICAqICE9PVxuICAgICAgICAgKiA8XG4gICAgICAgICAqID49XG4gICAgICAgICAqID5cbiAgICAgICAgICogPj1cbiAgICAgICAgICogbGlrZSAoY29sbGVjdGlvblZhbHVlLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihmaWx0ZXJWYWx1ZS50b0xvd2VyQ2FzZSgpKSA+IC0xKVxuICAgICAgICAgKiBpbmNsdWRlZCAoZXhwZWN0cyB2YWx1ZSB0byBiZSBhbiBhcnJheSlcbiAgICAgICAgICogZXhjbHVkZWQgKGV4cGVjdHMgdmFsdWUgdG8gYmUgYW4gYXJyYXkpXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gb3BlcmF0b3I9Jz09PSdcbiAgICAgICAgICovXG4gICAgICAgIG9wZXJhdG9yXzogJz09PScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcHJvcGVydHkgdG8gZmlsdGVyIGJ5ICh1c2UgdGhlIGNvbWJpbmF0aW9uIG9mIHByb3BlcnR5LCBvcGVyYXRvciAmIHZhbHVlKVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHByb3BlcnR5Xz0naWQnXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgcHJvcGVydHlfOiAnaWQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNjb3BlIHRvIHVzZSBmb3IgdGhlIGZpbHRlckJ5IG1ldGhvZCwgaW4gY2FzZSBpdCBpcyBwcm92aWRlZC4gRGVmYXVsdHMgdG8gdGhpcyBpbnN0YW5jZS5cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IHNjb3BlPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHNjb3BlOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZhbHVlIHRvIGZpbHRlciBieSAodXNlIHRoZSBjb21iaW5hdGlvbiBvZiBwcm9wZXJ0eSwgb3BlcmF0b3IgJiB2YWx1ZSlcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB2YWx1ZV89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlXzogbnVsbFxuICAgIH1cblxuICAgIGFmdGVyU2V0RGlzYWJsZWQoLi4uYXJncykge1xuICAgICAgICB0aGlzLmZpcmVDaGFuZ2VFdmVudCguLi5hcmdzKVxuICAgIH1cblxuICAgIGFmdGVyU2V0RmlsdGVyQnkodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIC8vIHRvZG9cbiAgICB9XG5cbiAgICBhZnRlclNldElzVXBkYXRpbmcodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHZhbHVlID09PSBmYWxzZSAmJiB0aGlzLmZpcmVDaGFuZ2VFdmVudCh2YWx1ZSwgb2xkVmFsdWUpXG4gICAgfVxuXG4gICAgYWZ0ZXJTZXRPcGVyYXRvciguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuZmlyZUNoYW5nZUV2ZW50KC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgYWZ0ZXJTZXRQcm9wZXJ0eSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuZmlyZUNoYW5nZUV2ZW50KC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgYWZ0ZXJTZXRWYWx1ZSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuZmlyZUNoYW5nZUV2ZW50KC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgYmVmb3JlU2V0RmlsdGVyQnkodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIE5lby5sb2dFcnJvcignZmlsdGVyQnkgaGFzIHRvIGJlIGEgZnVuY3Rpb24nLCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBvbGRWYWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgb3BlcmF0b3IgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldE9wZXJhdG9yKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnb3BlcmF0b3InKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5lZWRlZCBmb3IgcmVtb3RlIGZpbHRlcmluZ1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICBleHBvcnQoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge29wZXJhdG9yLCBwcm9wZXJ0eSwgdmFsdWV9ID0gbWU7XG5cbiAgICAgICAgaWYgKCFtZS5maWx0ZXJCeSkge1xuICAgICAgICAgICAgcmV0dXJuIHtvcGVyYXRvciwgcHJvcGVydHksIHZhbHVlfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcGFyYW0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBmaXJlQ2hhbmdlRXZlbnQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgbWUuaXNVcGRhdGluZyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgbGV0IHtvcGVyYXRvciwgcHJvcGVydHksIHZhbHVlfSA9IG1lO1xuICAgICAgICAgICAgbWUuZmlyZSgnY2hhbmdlJywge29wZXJhdG9yLCBwcm9wZXJ0eSwgdmFsdWV9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgY29sbGVjdGlvbiBpdGVtIG1hdGNoZXMgdGhpcyBmaWx0ZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbSBUaGUgY3VycmVudCBjb2xsZWN0aW9uIGl0ZW1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBmaWx0ZXJlZEl0ZW1zIElmIHRoZSBjb2xsZWN0aW9uIGZpbHRlck1vZGUgaXMgbm90IHByaW1pdGl2ZSBjb250YWlucyB0aGUgaXRlbXMgd2hpY2ggcGFzc2VkXG4gICAgICogdGhlIHByZXZpb3VzIGZpbHRlcnMsIG90aGVyd2lzZSBhbGwgY29sbGVjdGlvbiBpdGVtc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFsbEl0ZW1zIGFsbCBjb2xsZWN0aW9uIGl0ZW1zXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNGaWx0ZXJlZChpdGVtLCBmaWx0ZXJlZEl0ZW1zLCBhbGxJdGVtcykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgZmlsdGVyVmFsdWUsIHJlY29yZFZhbHVlO1xuXG4gICAgICAgIGlmIChtZS5fZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lLl9maWx0ZXJCeSkge1xuICAgICAgICAgICAgcmV0dXJuIG1lLmZpbHRlckJ5LmNhbGwobWUuc2NvcGUgfHwgbWUsIHtcbiAgICAgICAgICAgICAgICBhbGxJdGVtcyxcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZEl0ZW1zLFxuICAgICAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICAgICAgdmFsdWU6IG1lLl92YWx1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZS5pbmNsdWRlRW1wdHlWYWx1ZXMgJiYgKG1lLl92YWx1ZSA9PT0gbnVsbCB8fCBOZW8uaXNFbXB0eShtZS5fdmFsdWUpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBmaWx0ZXJWYWx1ZSA9IG1lLl92YWx1ZTtcbiAgICAgICAgcmVjb3JkVmFsdWUgPSBpdGVtW21lLl9wcm9wZXJ0eV07XG5cbiAgICAgICAgaWYgKGZpbHRlclZhbHVlIGluc3RhbmNlb2YgRGF0ZSAmJiByZWNvcmRWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIGZpbHRlclZhbHVlID0gZmlsdGVyVmFsdWUudmFsdWVPZigpO1xuICAgICAgICAgICAgcmVjb3JkVmFsdWUgPSByZWNvcmRWYWx1ZS52YWx1ZU9mKClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhRmlsdGVyW21lLl9vcGVyYXRvcl0ocmVjb3JkVmFsdWUsIGZpbHRlclZhbHVlKVxuICAgIH1cblxuICAgIHN0YXRpYyBbJz09J10gKGEsIGIpIHtyZXR1cm4gYSA9PSBifVxuICAgIHN0YXRpYyBbJz09PSddKGEsIGIpIHtyZXR1cm4gYSA9PT0gYn1cbiAgICBzdGF0aWMgWychPSddIChhLCBiKSB7cmV0dXJuIGEgIT0gYn1cbiAgICBzdGF0aWMgWychPT0nXShhLCBiKSB7cmV0dXJuIGEgIT09IGJ9XG4gICAgc3RhdGljIFsnPCddICAoYSwgYikge3JldHVybiBhIDwgYn1cbiAgICBzdGF0aWMgWyc8PSddIChhLCBiKSB7cmV0dXJuIGEgPD0gYn1cbiAgICBzdGF0aWMgWyc+J10gIChhLCBiKSB7cmV0dXJuIGEgPiBifVxuICAgIHN0YXRpYyBbJz49J10gKGEsIGIpIHtyZXR1cm4gYSA+PSBifVxuXG4gICAgc3RhdGljIFsnZW5kc1dpdGgnXShhLCBiKSB7XG4gICAgICAgIGlmICghTmVvLmlzU3RyaW5nKGEpKSB7YSA9IFN0cmluZyhhKX1cbiAgICAgICAgaWYgKCFOZW8uaXNTdHJpbmcoYikpIHtiID0gU3RyaW5nKGIpfVxuXG4gICAgICAgIHJldHVybiBhPy50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKGI/LnRvTG93ZXJDYXNlKCkpIHx8IGZhbHNlXG4gICAgfVxuXG4gICAgc3RhdGljIFsnZXhjbHVkZWQnXShhLCBiKSB7XG4gICAgICAgIHJldHVybiBiLmluZGV4T2YoYSkgPCAwXG4gICAgfVxuXG4gICAgc3RhdGljIFsnaW5jbHVkZWQnXShhLCBiKSB7XG4gICAgICAgIHJldHVybiBiLmluZGV4T2YoYSkgPiAtMVxuICAgIH1cblxuICAgIHN0YXRpYyBbJ2lzRGVmaW5lZCddKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgIT09IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIHN0YXRpYyBbJ2lzVW5kZWZpbmVkJ10oYSwgYikge1xuICAgICAgICByZXR1cm4gYSA9PT0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgc3RhdGljIFsnbGlrZSddKGEsIGIpIHtcbiAgICAgICAgaWYgKCFOZW8uaXNTdHJpbmcoYSkpIHthID0gU3RyaW5nKGEpfVxuICAgICAgICBpZiAoIU5lby5pc1N0cmluZyhiKSkge2IgPSBTdHJpbmcoYil9XG5cbiAgICAgICAgcmV0dXJuIGE/LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoYj8udG9Mb3dlckNhc2UoKSkgfHwgZmFsc2VcbiAgICB9XG5cbiAgICBzdGF0aWMgWydzdGFydHNXaXRoJ10oYSwgYikge1xuICAgICAgICBpZiAoIU5lby5pc1N0cmluZyhhKSkge2EgPSBTdHJpbmcoYSl9XG4gICAgICAgIGlmICghTmVvLmlzU3RyaW5nKGIpKSB7YiA9IFN0cmluZyhiKX1cblxuICAgICAgICByZXR1cm4gYT8udG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKGI/LnRvTG93ZXJDYXNlKCkpIHx8IGZhbHNlXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhGaWx0ZXIpO1xuIiwiaW1wb3J0IEJhc2UgICAgICAgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQgT2JzZXJ2YWJsZSBmcm9tICcuLi9jb3JlL09ic2VydmFibGUubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNvbGxlY3Rpb24uU29ydGVyXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKiBAbWl4ZXMgTmVvLmNvcmUuT2JzZXJ2YWJsZVxuICovXG5jbGFzcyBTb3J0ZXIgZXh0ZW5kcyBCYXNlIHtcbiAgICAvKipcbiAgICAgKiBUcnVlIGF1dG9tYXRpY2FsbHkgYXBwbGllcyB0aGUgY29yZS5PYnNlcnZhYmxlIG1peGluXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gb2JzZXJ2YWJsZT10cnVlXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBvYnNlcnZhYmxlID0gdHJ1ZVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29sbGVjdGlvbi5Tb3J0ZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb2xsZWN0aW9uLlNvcnRlcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdzb3J0ZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnc29ydGVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGNvbmZpZyB3aGljaCBtYXBzIHRoZSBkaXJlY3Rpb24gQVNDIHRvIDEsIC0xIG90aGVyd2lzZVxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGRpcmVjdGlvbk11bHRpcGxpZXI9MVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBkaXJlY3Rpb25NdWx0aXBsaWVyOiAxLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNvcnQgZGlyZWN0aW9uIHdoZW4gdXNpbmcgYSBwcm9wZXJ0eS5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBkaXJlY3Rpb25fPSdBU0MnXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgZGlyZWN0aW9uXzogJ0FTQycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgb3duZXIgdXRpbC5Db2xsZWN0aW9uIG5lZWRzIHRvIGFwcGx5IGFuIG9uQ2hhbmdlIGxpc3RlbmVyIG9uY2VcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn0gbGlzdGVuZXJBcHBsaWVkPWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGxpc3RlbmVyQXBwbGllZDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcHJvcGVydHkgdG8gc29ydCBieS5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBwcm9wZXJ0eV89J2lkJ1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHByb3BlcnR5XzogJ2lkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3ZpZGUgYSBjdXN0b20gc29ydGluZyBmdW5jdGlvbiwgaGFzIGEgaGlnaGVyIHByaW9yaXR5IHRoYW4gcHJvcGVydHkgJiBkaXJlY3Rpb25cbiAgICAgICAgICogQG1lbWJlciB7RnVuY3Rpb258bnVsbH0gc29ydEJ5PW51bGxcbiAgICAgICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9Db2xsYXRvclxuICAgICAgICAgKi9cbiAgICAgICAgc29ydEJ5OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSB0byB1c2UgdGhlIHRyYW5zZm9ybVZhbHVlIG1ldGhvZCBmb3IgZWFjaCBpdGVtICh0aGUgbWV0aG9kIGNhbiBnZXQgb3ZlcnJpZGRlbilcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gdXNlVHJhbnNmb3JtVmFsdWU9dHJ1ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB1c2VUcmFuc2Zvcm1WYWx1ZTogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIGFmdGVyU2V0RGlyZWN0aW9uKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmRpcmVjdGlvbk11bHRpcGxpZXIgPSB2YWx1ZSA9PT0gJ0FTQycgPyAxIDogLTE7XG5cbiAgICAgICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAgICAgICBtZS5maXJlKCdjaGFuZ2UnLCB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBtZS5kaXJlY3Rpb24sXG4gICAgICAgICAgICAgICAgcHJvcGVydHkgOiBtZS5wcm9wZXJ0eVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhZnRlclNldFByb3BlcnR5KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChvbGRWYWx1ZSkge1xuICAgICAgICAgICAgbWUuZmlyZSgnY2hhbmdlJywge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogbWUuZGlyZWN0aW9uLFxuICAgICAgICAgICAgICAgIHByb3BlcnR5IDogbWUucHJvcGVydHlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBzb3J0ZXIgZnVuY3Rpb24gd2hpY2ggZ2V0cyB1c2VkIGJ5IGNvbGxlY3Rpb25zIGluIGNhc2UgYXQgbGVhc3Qgb25lIHNvcnRlciBoYXMgYSByZWFsIHNvcnRCeSBtZXRob2RcbiAgICAgKiBAcGFyYW0gYVxuICAgICAqIEBwYXJhbSBiXG4gICAgICovXG4gICAgZGVmYXVsdFNvcnRCeShhLCBiKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgYSA9IGFbbWUucHJvcGVydHldO1xuICAgICAgICBiID0gYlttZS5wcm9wZXJ0eV07XG5cbiAgICAgICAgaWYgKG1lLnVzZVRyYW5zZm9ybVZhbHVlKSB7XG4gICAgICAgICAgICBhID0gbWUudHJhbnNmb3JtVmFsdWUoYSk7XG4gICAgICAgICAgICBiID0gbWUudHJhbnNmb3JtVmFsdWUoYik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYSA+IGIpIHtcbiAgICAgICAgICAgIHJldHVybiAxICogbWUuZGlyZWN0aW9uTXVsdGlwbGllcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhIDwgYikge1xuICAgICAgICAgICAgcmV0dXJuIC0xICogbWUuZGlyZWN0aW9uTXVsdGlwbGllcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5lZWRlZCBmb3IgcmVtb3RlIHNvcnRpbmdcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgZXhwb3J0KCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtkaXJlY3Rpb24sIHByb3BlcnR5fSA9IG1lO1xuXG4gICAgICAgIGlmICghbWUuc29ydEJ5ICYmIGRpcmVjdGlvbiAmJiBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgcmV0dXJuIHtkaXJlY3Rpb24sIHByb3BlcnR5fVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybnMgeyp9IHZhbHVlXG4gICAgICovXG4gICAgdHJhbnNmb3JtVmFsdWUodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhTb3J0ZXIpO1xuIiwiaW1wb3J0IEJhc2UgICAgICAgICAgICBmcm9tICcuL0Jhc2UubWpzJztcbmltcG9ydCBDbGFzc1N5c3RlbVV0aWwgZnJvbSAnLi4vdXRpbC9DbGFzc1N5c3RlbS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uY29udHJvbGxlci5BcHBsaWNhdGlvblxuICogQGV4dGVuZHMgTmVvLmNvbnRyb2xsZXIuQmFzZVxuICovXG5jbGFzcyBBcHBsaWNhdGlvbiBleHRlbmRzIEJhc2Uge1xuICAgIC8qKlxuICAgICAqIFRydWUgYXV0b21hdGljYWxseSBhcHBsaWVzIHRoZSBjb3JlLk9ic2VydmFibGUgbWl4aW5cbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBvYnNlcnZhYmxlPXRydWVcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIG9ic2VydmFibGUgPSB0cnVlXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb250cm9sbGVyLkFwcGxpY2F0aW9uJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29udHJvbGxlci5BcHBsaWNhdGlvbicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdhcHBsaWNhdGlvbidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdhcHBsaWNhdGlvbicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gYXBwVGhlbWVGb2xkZXI9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgYXBwVGhlbWVGb2xkZXI6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29tcG9uZW50LkJhc2V9IG1haW5WaWV3Xz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbWFpblZpZXdfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbW91bnRlZD1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBtb3VudGVkOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbmFtZT0nTXlBcHAnXG4gICAgICAgICAqL1xuICAgICAgICBuYW1lOiAnTXlBcHAnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBwYXJlbnRJZD0nZG9jdW1lbnQuYm9keSdcbiAgICAgICAgICovXG4gICAgICAgIHBhcmVudElkOiAnZG9jdW1lbnQuYm9keScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB2bm9kZUluaXRpYWxpc2luZz1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB2bm9kZUluaXRpYWxpc2luZzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB2bm9kZUluaXRpYWxpemVkPWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHZub2RlSW5pdGlhbGl6ZWQ6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IHdpbmRvd0lkPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHdpbmRvd0lkOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgLy8gdG8gZ3VhcmFudGVlIHRoYXQgdGhlIG1haW4gdmlldyBjYW4gYWNjZXNzIE5lby5hcHBzIGF0IGFueSBwb2ludCxcbiAgICAgICAgLy8gd2UgbmVlZCB0byB0cmlnZ2VyIGl0cyBhc3NpZ25tZW50IGF0IHRoZSBlbmQgb2YgdGhlIGN0b3IuXG4gICAgICAgIGxldCBtYWluVmlldyA9IGNvbmZpZy5tYWluVmlldztcbiAgICAgICAgZGVsZXRlIGNvbmZpZy5tYWluVmlldztcblxuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLndpbmRvd0lkID0gTmVvLmNvbmZpZy53aW5kb3dJZDtcblxuICAgICAgICBOZW8uYXBwcyA9IE5lby5hcHBzIHx8IHt9O1xuXG4gICAgICAgIE5lby5hcHBzW21lLm5hbWVdID0gbWU7XG5cbiAgICAgICAgTmVvLmN1cnJlbnRXb3JrZXIucmVnaXN0ZXJBcHAobWUubmFtZSk7XG5cbiAgICAgICAgaWYgKG1haW5WaWV3KSB7XG4gICAgICAgICAgICBtZS5tYWluVmlldyA9IG1haW5WaWV3XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1haW5WaWV3IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIGFmdGVyU2V0TWFpblZpZXcodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAgICAgLy8gc2hvcnQgZGVsYXkgdG8gZW5zdXJlIGNoYW5nZXMgZnJvbSBvbkhhc2hDaGFuZ2UoKSBnb3QgYXBwbGllZFxuICAgICAgICAgICAgYXdhaXQgbWUudGltZW91dChOZW8uY29uZmlnLmhhc2ggPyAyMDAgOiAxMCk7XG5cbiAgICAgICAgICAgIGF3YWl0IHZhbHVlLmluaXRWbm9kZSh0cnVlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgbWFpblZpZXcgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldE1haW5WaWV3KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBDbGFzc1N5c3RlbVV0aWwuYmVmb3JlU2V0SW5zdGFuY2UodmFsdWUsIG51bGwsIHtcbiAgICAgICAgICAgICAgICBhcHBOYW1lIDogdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgIHBhcmVudElkOiB0aGlzLnBhcmVudElkLFxuICAgICAgICAgICAgICAgIHdpbmRvd0lkOiBOZW8uY29uZmlnLndpbmRvd0lkXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVbnJlZ2lzdGVyIHRoZSBhcHAgZnJvbSB0aGUgQ1NTIG1hcFxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICovXG4gICAgZGVzdHJveSguLi5hcmdzKSB7XG4gICAgICAgIE5lby5jdXJyZW50V29ya2VyLnJlbW92ZUFwcEZyb21UaGVtZU1hcCh0aGlzLm5hbWUpO1xuICAgICAgICBzdXBlci5kZXN0cm95KC4uLmFyZ3MpXG4gICAgfVxufVxuXG5BcHBsaWNhdGlvbiA9IE5lby5zZXR1cENsYXNzKEFwcGxpY2F0aW9uKTtcblxuLy8gY29udmVuaWVuY2Ugc2hvcnRjdXRcbk5lby5hcHAgPSBjb25maWcgPT4gTmVvLmNyZWF0ZSh7XG4gICAgbW9kdWxlOiBBcHBsaWNhdGlvbixcbiAgICAuLi5jb25maWdcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBBcHBsaWNhdGlvbjtcbiIsImltcG9ydCBCYXNlICAgICAgICBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBIYXNoSGlzdG9yeSBmcm9tICcuLi91dGlsL0hhc2hIaXN0b3J5Lm1qcyc7XG5cbmNvbnN0XG4gICAgcmVnZXhBbW91bnRTbGFzaGVzICAgICAgID0gL1xcLy9nLFxuICAgIC8vIFJlZ2V4IHRvIGV4dHJhY3QgdGhlIHBhcmFtZXRlciBuYW1lIGZyb20gYSBzaW5nbGUgcm91dGUgc2VnbWVudCAoZS5nLiwgeyppdGVtSWR9IC0+IGl0ZW1JZClcbiAgICByZWdleFBhcmFtTmFtZUV4dHJhY3Rpb24gPSAveyhcXCp8XFwuXFwuXFwuKT8oW159XSspfS8sXG4gICAgLy8gUmVnZXggdG8gbWF0Y2ggcm91dGUgcGFyYW1ldGVycyBsaWtlIHtwYXJhbU5hbWV9LCB7KnBhcmFtTmFtZX0sIG9yIHsuLi5wYXJhbU5hbWV9XG4gICAgcmVnZXhSb3V0ZVBhcmFtICAgICAgICAgID0gL3soXFwqfFxcLlxcLlxcLik/KFtefV0rKX0vZztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNvbnRyb2xsZXIuQmFzZVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBDb250cm9sbGVyIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29udHJvbGxlci5CYXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29udHJvbGxlci5CYXNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2NvbnRyb2xsZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnY29udHJvbGxlcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgVVJMIGRvZXMgbm90IGNvbnRhaW4gYSBoYXNoIHZhbHVlIHdoZW4gdGhpcyBjb250cm9sbGVyIGluc3RhbmNlIGlzIGNyZWF0ZWQsXG4gICAgICAgICAqIE5lby5tanMgd2lsbCBhdXRvbWF0aWNhbGx5IHNldCB0aGlzIGhhc2ggdmFsdWUsIGVuc3VyaW5nIGEgZGVmYXVsdCByb3V0ZSBpcyBhY3RpdmUuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBkZWZhdWx0SGFzaD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkZWZhdWx0SGFzaDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgaGFuZGxlciBtZXRob2QgdG8gYmUgaW52b2tlZCB3aGVuIG5vIG90aGVyIGRlZmluZWQgcm91dGUgbWF0Y2hlcyB0aGUgVVJMIGhhc2guXG4gICAgICAgICAqIFRoaXMgYWN0cyBhcyBhIGZhbGxiYWNrIGZvciB1bmhhbmRsZWQgcm91dGVzLlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gZGVmYXVsdFJvdXRlPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRlZmF1bHRSb3V0ZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIG1hcCBvZiBjb21waWxlZCByZWd1bGFyIGV4cHJlc3Npb25zIGZvciBlYWNoIHJvdXRlLCB1c2VkIGZvciBlZmZpY2llbnQgaGFzaCBtYXRjaGluZy5cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGhhbmRsZVJvdXRlcz17fVxuICAgICAgICAgKi9cbiAgICAgICAgaGFuZGxlUm91dGVzOiB7fSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgdGhlIHJvdXRpbmcgcnVsZXMgZm9yIHRoZSBjb250cm9sbGVyLiBLZXlzIGFyZSByb3V0ZSBwYXR0ZXJucywgYW5kIHZhbHVlcyBhcmUgZWl0aGVyXG4gICAgICAgICAqIGhhbmRsZXIgbWV0aG9kIG5hbWVzIChTdHJpbmcpIG9yIG9iamVjdHMgY29udGFpbmluZyBgaGFuZGxlcmAgYW5kIG9wdGlvbmFsIGBwcmVIYW5kbGVyYCBtZXRob2QgbmFtZXMuXG4gICAgICAgICAqIFJvdXRlIHBhdHRlcm5zIGNhbiBpbmNsdWRlIHBhcmFtZXRlcnMgbGlrZSBge3BhcmFtTmFtZX1gIGFuZCB3aWxkY2FyZHMgbGlrZSBgeypwYXJhbU5hbWV9YCBmb3IgbmVzdGVkIHBhdGhzLlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiByb3V0ZXM6IHtcbiAgICAgICAgICogICAgICcvaG9tZScgICAgICAgICAgICAgICAgICAgICAgICAgOiAnaGFuZGxlSG9tZVJvdXRlJyxcbiAgICAgICAgICogICAgICcvdXNlcnMve3VzZXJJZH0nICAgICAgICAgICAgICAgOiB7aGFuZGxlcjogJ2hhbmRsZVVzZXJSb3V0ZScsIHByZUhhbmRsZXI6ICdwcmVIYW5kbGVVc2VyUm91dGUnfSxcbiAgICAgICAgICogICAgICcvdXNlcnMve3VzZXJJZH0vcG9zdHMve3Bvc3RJZH0nOiAnaGFuZGxlUG9zdFJvdXRlJyxcbiAgICAgICAgICogICAgICcvbGVhcm4veyppdGVtSWR9JyAgICAgICAgICAgICAgOiAnb25MZWFyblJvdXRlJywgLy8gQ2FwdHVyZXMgbmVzdGVkIHBhdGhzIGxpa2UgL2xlYXJuL2dldHRpbmdzdGFydGVkL1dvcmtzcGFjZXNcbiAgICAgICAgICogICAgICdkZWZhdWx0JyAgICAgICAgICAgICAgICAgICAgICAgOiAnaGFuZGxlT3RoZXJSb3V0ZXMnXG4gICAgICAgICAqIH1cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSByb3V0ZXNfPXt9XG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgcm91dGVzXzoge31cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvbnRyb2xsZXIgaW5zdGFuY2UgYW5kIHJlZ2lzdGVycyBpdHMgYG9uSGFzaENoYW5nZWAgbWV0aG9kXG4gICAgICogdG8gbGlzdGVuIGZvciBjaGFuZ2VzIGluIHRoZSBicm93c2VyJ3MgVVJMIGhhc2guXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG4gICAgICAgIEhhc2hIaXN0b3J5Lm9uKCdjaGFuZ2UnLCB0aGlzLm9uSGFzaENoYW5nZSwgdGhpcylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzZXMgdGhlIGRlZmluZWQgcm91dGVzIGNvbmZpZ3VyYXRpb24sIGNvbXBpbGluZyByb3V0ZSBwYXR0ZXJucyBpbnRvIHJlZ3VsYXIgZXhwcmVzc2lvbnNcbiAgICAgKiBmb3IgZWZmaWNpZW50IG1hdGNoaW5nIGFuZCBzb3J0aW5nIHRoZW0gYnkgc3BlY2lmaWNpdHkgKG1vcmUgc2xhc2hlcyBmaXJzdCkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Um91dGVzKHZhbHVlLCBvbGRWYWx1ZSl7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgcm91dGVLZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuXG4gICAgICAgICBtZS5yb3V0ZXMgPSByb3V0ZUtleXMuc29ydChtZS4jc29ydFJvdXRlcykucmVkdWNlKChvYmosIGtleSkgPT4ge1xuICAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWVba2V5XTtcbiAgICAgICAgICAgICByZXR1cm4gb2JqXG4gICAgICAgICB9LCB7fSk7XG5cbiAgICAgICAgbWUuaGFuZGxlUm91dGVzID0ge307XG5cbiAgICAgICAgcm91dGVLZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGlmIChrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2RlZmF1bHQnKXtcbiAgICAgICAgICAgICAgICBtZS5kZWZhdWx0Um91dGUgPSB2YWx1ZVtrZXldXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lLmhhbmRsZVJvdXRlc1trZXldID0gbmV3IFJlZ0V4cChrZXkucmVwbGFjZShyZWdleFJvdXRlUGFyYW0sIChtYXRjaCwgaXNXaWxkY2FyZCwgcGFyYW1OYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1dpbGRjYXJkIHx8IHBhcmFtTmFtZS5zdGFydHNXaXRoKCcqJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnKC4qKSdcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnKFtcXFxcdy0uXSspJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICBkZXN0cm95KC4uLmFyZ3MpIHtcbiAgICAgICAgSGFzaEhpc3RvcnkudW4oJ2NoYW5nZScsIHRoaXMub25IYXNoQ2hhbmdlLCB0aGlzKTtcbiAgICAgICAgc3VwZXIuZGVzdHJveSguLi5hcmdzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIGluaXRBc3luYygpIHtcbiAgICAgICAgYXdhaXQgc3VwZXIuaW5pdEFzeW5jKCk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtkZWZhdWx0SGFzaCwgd2luZG93SWR9ID0gbWUsXG4gICAgICAgICAgICBjdXJyZW50SGFzaCAgICAgICAgICAgICA9IEhhc2hIaXN0b3J5LmZpcnN0KHdpbmRvd0lkKTtcblxuICAgICAgICBpZiAoY3VycmVudEhhc2gpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50SGFzaC53aW5kb3dJZCA9PT0gd2luZG93SWQpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBtZS5vbkhhc2hDaGFuZ2UoY3VycmVudEhhc2gsIG51bGwpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogd29ya2VyLkFwcDogb25Mb2FkQXBwbGljYXRpb24oKSB3aWxsIHB1c2ggY29uZmlnLmhhc2ggaW50byB0aGUgSGFzaEhpc3Rvcnkgd2l0aCBhIDVtcyBkZWxheS5cbiAgICAgICAgICAgICAqIFdlIG9ubHkgd2FudCB0byBzZXQgYSBkZWZhdWx0IHJvdXRlLCBpbiBjYXNlIHRoZSBIYXNoSGlzdG9yeSBpcyBlbXB0eSBhbmQgdGhlcmUgaXMgbm8gaW5pdGlhbFxuICAgICAgICAgICAgICogdmFsdWUgdGhhdCB3aWxsIGdldCBjb25zdW1lZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgIU5lby5jb25maWcuaGFzaCAmJiBkZWZhdWx0SGFzaCAmJiBOZW8uTWFpbi5zZXRSb3V0ZSh7dmFsdWU6IGRlZmF1bHRIYXNoLCB3aW5kb3dJZH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGNoYW5nZXMgaW4gdGhlIGJyb3dzZXIncyBVUkwgaGFzaC4gSXQgaWRlbnRpZmllcyB0aGUgbW9zdCBzcGVjaWZpYyBtYXRjaGluZyByb3V0ZVxuICAgICAqIGFuZCBkaXNwYXRjaGVzIHRoZSBjb3JyZXNwb25kaW5nIGhhbmRsZXIsIG9wdGlvbmFsbHkgZXhlY3V0aW5nIGEgcHJlSGFuZGxlciBmaXJzdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgLSBUaGUgbmV3IGhhc2ggaGlzdG9yeSBlbnRyeS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2xkVmFsdWUgLSBUaGUgcHJldmlvdXMgaGFzaCBoaXN0b3J5IGVudHJ5LlxuICAgICAqL1xuICAgIGFzeW5jIG9uSGFzaENoYW5nZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgLy8gV2Ugb25seSB3YW50IHRvIHRyaWdnZXIgaGFzaCBjaGFuZ2VzIGZvciB0aGUgc2FtZSBicm93c2VyIHdpbmRvdyAoU2hhcmVkV29ya2VyIGNvbnRleHQpXG4gICAgICAgIGlmICh2YWx1ZS53aW5kb3dJZCAhPT0gdGhpcy53aW5kb3dJZCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7aGFuZGxlUm91dGVzLCByb3V0ZXN9ID0gbWUsXG4gICAgICAgICAgICByb3V0ZUtleXMgICAgICAgICAgICAgID0gT2JqZWN0LmtleXMoaGFuZGxlUm91dGVzKSxcbiAgICAgICAgICAgIGJlc3RNYXRjaCAgICAgICAgICAgICAgPSBudWxsLFxuICAgICAgICAgICAgYmVzdE1hdGNoS2V5ICAgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICBiZXN0TWF0Y2hQYXJhbXMgICAgICAgID0gbnVsbDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdXRlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gcm91dGVLZXlzW2ldO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsdWUuaGFzaFN0cmluZy5tYXRjaChoYW5kbGVSb3V0ZXNba2V5XSk7XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBjb25zdFxuICAgICAgICAgICAgICAgICAgICBhcnJheVBhcmFtSWRzICAgID0ga2V5Lm1hdGNoKHJlZ2V4Um91dGVQYXJhbSksXG4gICAgICAgICAgICAgICAgICAgIGFycmF5UGFyYW1WYWx1ZXMgPSByZXN1bHQuc3BsaWNlKDEsIHJlc3VsdC5sZW5ndGggLSAxKSxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1PYmplY3QgICAgICA9IHt9O1xuXG4gICAgICAgICAgICAgICAgaWYgKGFycmF5UGFyYW1JZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBhcnJheVBhcmFtSWRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJhbU1hdGNoID0gYXJyYXlQYXJhbUlkc1tqXS5tYXRjaChyZWdleFBhcmFtTmFtZUV4dHJhY3Rpb24pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1NYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtTmFtZSA9IHBhcmFtTWF0Y2hbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1PYmplY3RbcGFyYW1OYW1lXSA9IGFycmF5UGFyYW1WYWx1ZXNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBMb2dpYyB0byBkZXRlcm1pbmUgdGhlIGJlc3QgbWF0Y2hpbmcgcm91dGU6XG4gICAgICAgICAgICAgICAgLy8gMS4gUHJpb3JpdGl6ZSByb3V0ZXMgdGhhdCBtYXRjaCBhIGxvbmdlciBzdHJpbmcgKG1vcmUgc3BlY2lmaWMgbWF0Y2gpLlxuICAgICAgICAgICAgICAgIC8vIDIuIElmIGxlbmd0aHMgYXJlIGVxdWFsLCBwcmlvcml0aXplIHJvdXRlcyB3aXRoIG1vcmUgc2xhc2hlcyAoZGVlcGVyIG5lc3RpbmcpLlxuICAgICAgICAgICAgICAgIGlmICghYmVzdE1hdGNoIHx8IChyZXN1bHRbMF0ubGVuZ3RoID4gYmVzdE1hdGNoWzBdLmxlbmd0aCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdFswXS5sZW5ndGggPT09IGJlc3RNYXRjaFswXS5sZW5ndGggJiYgKGtleS5tYXRjaChyZWdleEFtb3VudFNsYXNoZXMpIHx8IFtdKS5sZW5ndGggPiAoYmVzdE1hdGNoS2V5Lm1hdGNoKHJlZ2V4QW1vdW50U2xhc2hlcykgfHwgW10pLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2hLZXkgPSBrZXk7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaFBhcmFtcyA9IHBhcmFtT2JqZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiZXN0TWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHJvdXRlID0gcm91dGVzW2Jlc3RNYXRjaEtleV07XG4gICAgICAgICAgICBsZXQgaGFuZGxlciAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgcHJlSGFuZGxlciA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChOZW8uaXNTdHJpbmcocm91dGUpKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlciA9IHJvdXRlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKE5lby5pc09iamVjdChyb3V0ZSkpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyICAgID0gcm91dGUuaGFuZGxlcjtcbiAgICAgICAgICAgICAgICBwcmVIYW5kbGVyID0gcm91dGUucHJlSGFuZGxlclxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgcmVzcG9uc2VQcmVIYW5kbGVyID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKHByZUhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZVByZUhhbmRsZXIgPSBhd2FpdCBtZVtwcmVIYW5kbGVyXT8uY2FsbChtZSwgYmVzdE1hdGNoUGFyYW1zLCB2YWx1ZSwgb2xkVmFsdWUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZXNwb25zZVByZUhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBtZVtoYW5kbGVyXT8uY2FsbChtZSwgYmVzdE1hdGNoUGFyYW1zLCB2YWx1ZSwgb2xkVmFsdWUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobWUuZGVmYXVsdFJvdXRlKSB7XG4gICAgICAgICAgICAgICAgbWVbbWUuZGVmYXVsdFJvdXRlXT8uKHZhbHVlLCBvbGRWYWx1ZSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWUub25Ob1JvdXRlRm91bmQodmFsdWUsIG9sZFZhbHVlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGxhY2Vob2xkZXIgbWV0aG9kIGludm9rZWQgd2hlbiBubyBtYXRjaGluZyByb3V0ZSBpcyBmb3VuZCBmb3IgdGhlIGN1cnJlbnQgVVJMIGhhc2guXG4gICAgICogQ29udHJvbGxlcnMgY2FuIG92ZXJyaWRlIHRoaXMgdG8gaW1wbGVtZW50IGN1c3RvbSBiZWhhdmlvciBmb3IgdW5oYW5kbGVkIHJvdXRlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgLSBUaGUgY3VycmVudCBoYXNoIGhpc3RvcnkgZW50cnkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFZhbHVlIC0gVGhlIHByZXZpb3VzIGhhc2ggaGlzdG9yeSBlbnRyeS5cbiAgICAgKi9cbiAgICBvbk5vUm91dGVGb3VuZCh2YWx1ZSwgb2xkVmFsdWUpIHtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGhlbHBlciBtZXRob2QgdG8gc29ydCByb3V0ZXMgYnkgdGhlaXIgc3BlY2lmaWNpdHkuXG4gICAgICogUm91dGVzIHdpdGggbW9yZSBzbGFzaGVzIGFyZSBjb25zaWRlcmVkIG1vcmUgc3BlY2lmaWMgYW5kIGFyZSBwcmlvcml0aXplZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcm91dGUxIC0gVGhlIGZpcnN0IHJvdXRlIHN0cmluZyB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByb3V0ZTIgLSBUaGUgc2Vjb25kIHJvdXRlIHN0cmluZyB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IEEgbmVnYXRpdmUgdmFsdWUgaWYgcm91dGUxIGlzIG1vcmUgc3BlY2lmaWMsIGEgcG9zaXRpdmUgdmFsdWUgaWYgcm91dGUyIGlzIG1vcmUgc3BlY2lmaWMsIG9yIDAgaWYgdGhleSBoYXZlIGVxdWFsIHNwZWNpZmljaXR5LlxuICAgICAqL1xuICAgICNzb3J0Um91dGVzKHJvdXRlMSwgcm91dGUyKSB7XG4gICAgICAgIHJldHVybiAocm91dGUxLm1hdGNoKHJlZ2V4QW1vdW50U2xhc2hlcykgfHwgW10pLmxlbmd0aCAtIChyb3V0ZTIubWF0Y2gocmVnZXhBbW91bnRTbGFzaGVzKXx8IFtdKS5sZW5ndGhcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKENvbnRyb2xsZXIpO1xuIiwiaW1wb3J0IHtidWZmZXIsIGRlYm91bmNlLCBpbnRlcmNlcHQsIHJlc29sdmVDYWxsYmFjaywgdGhyb3R0bGV9IGZyb20gJy4uL3V0aWwvRnVuY3Rpb24ubWpzJztcbmltcG9ydCBDb21wYXJlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tICcuLi9jb3JlL0NvbXBhcmUubWpzJztcbmltcG9ydCBVdGlsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tICcuLi9jb3JlL1V0aWwubWpzJztcbmltcG9ydCBDb25maWcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tICcuL0NvbmZpZy5tanMnO1xuaW1wb3J0IHtpc0Rlc2NyaXB0b3J9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gJy4vQ29uZmlnU3ltYm9scy5tanMnO1xuaW1wb3J0IElkR2VuZXJhdG9yICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gJy4vSWRHZW5lcmF0b3IubWpzJztcbmltcG9ydCBFZmZlY3RNYW5hZ2VyICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tICcuL0VmZmVjdE1hbmFnZXIubWpzJztcblxuY29uc3QgY29uZmlnU3ltYm9sICAgICAgID0gU3ltYm9sLmZvcignY29uZmlnU3ltYm9sJyksXG4gICAgICBmb3JjZUFzc2lnbkNvbmZpZ3MgPSBTeW1ib2woJ2ZvcmNlQXNzaWduQ29uZmlncycpLFxuICAgICAgaXNJbnN0YW5jZSAgICAgICAgID0gU3ltYm9sKCdpc0luc3RhbmNlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgY2xhc3MgZm9yIChhbG1vc3QpIGFsbCBjbGFzc2VzIGluc2lkZSB0aGUgTmVvIG5hbWVzcGFjZVxuICogRXhjZXB0aW9ucyBhcmUgZS5nLiBjb3JlLklkR2VuZXJhdG9yLCB2ZG9tLlZOb2RlXG4gKiBAY2xhc3MgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBCYXNlIHtcbiAgICAvKipcbiAgICAgKiBZb3UgY2FuIGRlZmluZSBtZXRob2RzIHdoaWNoIHNob3VsZCBnZXQgZGVsYXllZC5cbiAgICAgKiBUeXBlcyBhcmUgYnVmZmVyLCBkZWJvdW5jZSAmIHRocm90dGxlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogIGRlbGF5YWJsZToge1xuICAgICAqICAgICAgZmlyZUNoYW5nZUV2ZW50OiB7XG4gICAgICogICAgICAgICAgdHlwZSA6ICdkZWJvdW5jZScsXG4gICAgICogICAgICAgICAgdGltZXI6IDMwMFxuICAgICAqICAgICAgfVxuICAgICAqICB9XG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBkZWxheWFibGU9e31cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBkZWxheWFibGUgPSB7fVxuICAgIC8qKlxuICAgICAqIEZsYWcgd2hpY2ggd2lsbCBnZXQgc2V0IHRvIHRydWUgb25jZSBtYW5hZ2VyLkluc3RhbmNlIGdvdCBjcmVhdGVkXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaW5zdGFuY2VNYW5hZ2VyQXZhaWxhYmxlPWZhbHNlXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBpbnN0YW5jZU1hbmFnZXJBdmFpbGFibGUgPSBmYWxzZVxuICAgIC8qKlxuICAgICAqIFJlZ2V4IHRvIGdyYWIgdGhlIE1ldGhvZE5hbWUgZnJvbSBhbiBlcnJvclxuICAgICAqIHdoaWNoIGlzIGEgc2Vjb25kIGdlbmVyYXRpb24gZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyIHtSZWdFeHB9IG1ldGhvZE5hbWVSZWdleFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgbWV0aG9kTmFtZVJlZ2V4ID0gL1xcbi4qXFxuXFxzK2F0XFxzKy4qXFwuKFxcdyspXFxzKy4qL1xuICAgIC8qKlxuICAgICAqIFRydWUgYXV0b21hdGljYWxseSBhcHBsaWVzIHRoZSBjb3JlLk9ic2VydmFibGUgbWl4aW5cbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBvYnNlcnZhYmxlPWZhbHNlXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBvYnNlcnZhYmxlID0gZmFsc2VcbiAgICAvKipcbiAgICAgKiBLZWVwIHRoZSBvdmVyd3JpdHRlbiBtZXRob2RzXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBvdmVyd3JpdHRlbk1ldGhvZHM9e31cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBvdmVyd3JpdHRlbk1ldGhvZHMgPSB7fVxuICAgIC8qKlxuICAgICAqIERlZmluZXMgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzIGZvciB0aGUgY2xhc3MuIFRoZXNlIGNvbmZpZ3VyYXRpb25zIGFyZVxuICAgICAqIG1lcmdlZCB0aHJvdWdob3V0IHRoZSBjbGFzcyBoaWVyYXJjaHkgYW5kIGNhbiBiZSBvdmVycmlkZGVuIGF0IHRoZSBpbnN0YW5jZSBsZXZlbC5cbiAgICAgKlxuICAgICAqIFRoZXJlIGFyZSB0d28gbWFpbiB0eXBlcyBvZiBjb25maWdzOlxuICAgICAqXG4gICAgICogMS4gICoqUmVhY3RpdmUgQ29uZmlnczoqKiBQcm9wZXJ0eSBuYW1lcyBlbmRpbmcgd2l0aCBhIHRyYWlsaW5nIHVuZGVyc2NvcmUgKGUuZy4sIGBteUNvbmZpZ19gKS5cbiAgICAgKiAgICAgVGhlIGZyYW1ld29yayBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlcyBhIHB1YmxpYyBnZXR0ZXIgYW5kIHNldHRlciwgcmVtb3ZpbmcgdGhlIHVuZGVyc2NvcmVcbiAgICAgKiAgICAgZnJvbSB0aGUgcHJvcGVydHkgbmFtZSAoZS5nLiwgYHRoaXMubXlDb25maWdgKS4gVGhpcyBzeXN0ZW0gZW5hYmxlcyBwb3dlcmZ1bCwgb3B0aW9uYWxcbiAgICAgKiAgICAgbGlmZWN5Y2xlIGhvb2tzIHRoYXQgYXJlIGNhbGxlZCBhdXRvbWF0aWNhbGx5IGlmIHRoZXkgYXJlIGltcGxlbWVudGVkIG9uIHRoZSBjbGFzczpcbiAgICAgKiAgICAgLSBgYmVmb3JlR2V0TXlDb25maWcodmFsdWUpYDogRXhlY3V0ZWQgYmVmb3JlIHRoZSBnZXR0ZXIgcmV0dXJucy4gQ2FuIGJlIHVzZWQgdG8gZHluYW1pY2FsbHkgbW9kaWZ5IHRoZSByZXR1cm5lZCB2YWx1ZS5cbiAgICAgKiAgICAgLSBgYmVmb3JlU2V0TXlDb25maWcobmV3VmFsdWUsIG9sZFZhbHVlKWA6IEV4ZWN1dGVkIGJlZm9yZSBhIG5ldyB2YWx1ZSBpcyBzZXQuIENhbiBiZSB1c2VkIGZvciB2YWxpZGF0aW9uIG9yIHRyYW5zZm9ybWF0aW9uLiBSZXR1cm5pbmcgYHVuZGVmaW5lZGAgZnJvbSB0aGlzIGhvb2sgd2lsbCBjYW5jZWwgdGhlIHVwZGF0ZS5cbiAgICAgKiAgICAgLSBgYWZ0ZXJTZXRNeUNvbmZpZyhuZXdWYWx1ZSwgb2xkVmFsdWUpYDogRXhlY3V0ZWQgYWZ0ZXIgYSBuZXcgdmFsdWUgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IHNldC4gSWRlYWwgZm9yIHRyaWdnZXJpbmcgc2lkZSBlZmZlY3RzLlxuICAgICAqXG4gICAgICogMi4gICoqTm9uLVJlYWN0aXZlIChQcm90b3R5cGUtYmFzZWQpIENvbmZpZ3M6KiogUHJvcGVydHkgbmFtZXMgd2l0aG91dCBhIHRyYWlsaW5nIHVuZGVyc2NvcmUuXG4gICAgICogICAgIFRoZXNlIGFyZSBhcHBsaWVkIGRpcmVjdGx5IHRvIHRoZSBjbGFzcydzICoqcHJvdG90eXBlKiogZHVyaW5nIHRoZSBgTmVvLnNldHVwQ2xhc3NgXG4gICAgICogICAgIHByb2Nlc3MuIFRoaXMgaXMgaGlnaGx5IG1lbW9yeS1lZmZpY2llbnQgYXMgdGhlIHZhbHVlIGlzIHNoYXJlZCBhY3Jvc3MgYWxsIGluc3RhbmNlcy5cbiAgICAgKiAgICAgSXQgYWxzbyBhbGxvd3MgZm9yIHBvd2VyZnVsLCBhcHBsaWNhdGlvbi13aWRlIG1vZGlmaWNhdGlvbnMgb2YgZGVmYXVsdCBiZWhhdmlvcnNcbiAgICAgKiAgICAgYnkgdXNpbmcgdGhlIGBOZW8ub3ZlcndyaXRlc2AgbWVjaGFuaXNtLCB3aGljaCBtb2RpZmllcyB0aGVzZSBwcm90b3R5cGUgdmFsdWVzIGF0XG4gICAgICogICAgIGxvYWQgdGltZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2xhc3MgbmFtZSB3aGljaCB3aWxsIGdldCBtYXBwZWQgaW50byB0aGUgTmVvIG9yIGFwcCBuYW1lc3BhY2VcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb3JlLkJhc2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb3JlLkJhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNsYXNzIHNob3J0Y3V0LW5hbWUgdG8gdXNlIGZvciBlLmcuIGNyZWF0aW5nIGNoaWxkIGNvbXBvbmVudHMgaW5zaWRlIGEgSlNPTi1mb3JtYXRcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nYmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdiYXNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoaWxlIGl0IGlzIHJlY29tbWVuZGVkIHRvIGNoYW5nZSB0aGUgc3RhdGljIGRlbGF5YWJsZSBjb25maWdzIG9uIGNsYXNzIGxldmVsLFxuICAgICAgICAgKiB5b3UgY2FuIGNoYW5nZSBpdCBvbiBpbnN0YW5jZSBsZXZlbCB0b28uIElmIG5vdCBudWxsLCB3ZSB3aWxsIGRvIGEgZGVlcCBtZXJnZS5cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBkZWxheWFibGU9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZGVsYXlhYmxlOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHVuaXF1ZSBjb21wb25lbnQgaWRcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGlkXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgaWRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgb2YgcmVtb3RlIG1ldGhvZCBuYW1lcyB0aGF0IHNob3VsZCBiZSBpbnRlcmNlcHRlZC5cbiAgICAgICAgICogTmFtZXMgdXNlZCBoZXJlIG11c3QgYmUgcHJlc2VudCBpbnNpZGUgdGhlIGByZW1vdGVfYCBjb25maWcuXG4gICAgICAgICAqIElmIGEgcmVtb3RlIGNhbGwgZm9yIG9uZSBvZiB0aGVzZSBtZXRob2RzIGFycml2ZXMsIGBvbkludGVyY2VwdFJlbW90ZXMoKWAgd2lsbCBiZSBjYWxsZWQuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfG51bGx9IGludGVyY2VwdFJlbW90ZXM9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBpbnRlcmNlcHRSZW1vdGVzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogTmVvLmNyZWF0ZSgpIHdpbGwgY2hhbmdlIHRoaXMgZmxhZyB0byB0cnVlIGFmdGVyIHRoZSBvbkNvbnN0cnVjdGVkKCkgY2hhaW4gaXMgZG9uZS5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNDb25zdHJ1Y3RlZD1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBpc0NvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgY29uZmlnIHdpbGwgYmUgc2V0IHRvIGB0cnVlYCBhcyB0aGUgdmVyeSBmaXJzdCBhY3Rpb24gd2l0aGluIHRoZSBgZGVzdHJveSgpYCBtZXRob2QuXG4gICAgICAgICAqIEVmZmVjdHMgY2FuIG9ic2VydmUgdGhpcyBjb25maWcgdG8gY2xlYW4gdGhlbXNlbHZlcyB1cC5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNEZXN0cm95aW5nXz1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgaXNEZXN0cm95aW5nXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY29uZmlnIHdpbGwgZ2V0IHNldCB0byBgdHJ1ZWAgb25jZSB0aGUgUHJvbWlzZSBvZiBgYXN5bmMgaW5pdEFzeW5jKClgIGlzIHJlc29sdmVkLlxuICAgICAgICAgKiBZb3UgY2FuIHVzZSBgYWZ0ZXJTZXRJc1JlYWR5KClgIHRvIGdldCBub3RpZmllZCBvbmNlIHRoZSByZWFkeSBzdGF0ZSBpcyByZWFjaGVkLlxuICAgICAgICAgKiBTaW5jZSBub3QgYWxsIGNsYXNzZXMgdXNlIHRoZSBPYnNlcnZhYmxlIG1peGluLCBOZW8gd2lsbCBub3QgZmlyZSBhbiBldmVudC5cbiAgICAgICAgICogbWV0aG9kIGJvZHkuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzUmVhZHlfPWZhbHNlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgaXNSZWFkeV86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIG1peGlucyBhcyBhbiBhcnJheSBvZiBjbGFzc05hbWVzLCBpbXBvcnRlZCBtb2R1bGVzIG9yIGEgbWl4ZWQgdmVyc2lvblxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXXxOZW8uY29yZS5CYXNlW118bnVsbH0gbWl4aW5zPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIG1peGluczogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFlvdSBjYW4gY3JlYXRlIGEgbmV3IGluc3RhbmNlIGJ5IHBhc3NpbmcgYW4gaW1wb3J0ZWQgY2xhc3MgKEpTIG1vZHVsZSBkZWZhdWx0IGV4cG9ydClcbiAgICAgICAgICogQG1lbWJlciB7Q2xhc3N9IG1vZHVsZT1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG1vZHVsZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW90ZSBtZXRob2QgYWNjZXNzIGZvciBvdGhlciB0aHJlYWRzLiBFeGFtcGxlIHVzZSBjYXNlOlxuICAgICAgICAgKiByZW1vdGU6IHthcHA6IFsnbXlSZW1vdGVNZXRob2QnXX1cbiAgICAgICAgICpcbiAgICAgICAgICogT05MWSBzdXBwb3J0ZWQgZm9yIHNpbmdsZXRvbnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSByZW1vdGVfPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHJlbW90ZV86IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHByaXZhdGUgZmllbGQgdG8gc3RvcmUgdGhlIENvbmZpZyBjb250cm9sbGVyIGluc3RhbmNlcy5cbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9ICNjb25maWdzPXt9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICAjY29uZmlncyA9IHt9O1xuICAgIC8qKlxuICAgICAqIEludGVybmFsIGNhY2hlIGZvciBhbGwgY29uZmlnIHN1YnNjcmlwdGlvbiBjbGVhbnVwIGZ1bmN0aW9ucy5cbiAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbltdfSAjY29uZmlnU3Vic2NyaXB0aW9uQ2xlYW51cHM9W11cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgICNjb25maWdTdWJzY3JpcHRpb25DbGVhbnVwcyA9IFtdXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgY2FjaGUgZm9yIGFsbCB0aW1lb3V0IGlkcyB3aGVuIHVzaW5nIHRoaXMudGltZW91dCgpXG4gICAgICogQG1lbWJlciB7TnVtYmVyW119IHRpbWVvdXRJZHM9W11cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgICN0aW1lb3V0SWRzID0gW11cblxuICAgIC8qKlxuICAgICAqIFRoZSBtYWluIGluaXRpYWxpemVyIGZvciBhbGwgTmVvLm1qcyBjbGFzc2VzLCBpbnZva2VkIGJ5IGBOZW8uY3JlYXRlKClgLlxuICAgICAqIE5PVEU6IFRoaXMgaXMgbm90IHRoZSBuYXRpdmUgYGNvbnN0cnVjdG9yKClgLCB3aGljaCBpcyBjYWxsZWQgd2l0aG91dCBhcmd1bWVudHMgYnkgYE5lby5jcmVhdGUoKWAgZmlyc3QuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBvcmNoZXN0cmF0ZXMgdGhlIGVudGlyZSBpbnN0YW5jZSBpbml0aWFsaXphdGlvbiBwcm9jZXNzLCBpbmNsdWRpbmdcbiAgICAgKiB0aGUgc2V0dXAgb2YgdGhlIHBvd2VyZnVsIGFuZCBmbGV4aWJsZSBjb25maWcgc3lzdGVtLlxuICAgICAqXG4gICAgICogVGhlIGBjb25maWdgIHBhcmFtZXRlciBpcyBhIHNpbmdsZSBvYmplY3QgdGhhdCBjYW4gY29udGFpbiBkaWZmZXJlbnQgdHlwZXMgb2YgcHJvcGVydGllcyxcbiAgICAgKiB3aGljaCBhcmUgcHJvY2Vzc2VkIGluIGEgc3BlY2lmaWMgb3JkZXIgdG8gZW5zdXJlIGNvbnNpc3RlbmN5IGFuZCBwcmVkaWN0YWJpbGl0eTpcbiAgICAgKlxuICAgICAqIDEuICAqKlB1YmxpYyBDbGFzcyBGaWVsZHMgJiBPdGhlciBQcm9wZXJ0aWVzOioqIEFueSBrZXkgaW4gdGhlIGBjb25maWdgIG9iamVjdCB0aGF0IGlzIE5PVFxuICAgICAqICAgICBkZWZpbmVkIGluIHRoZSBjbGFzcydzIGBzdGF0aWMgY29uZmlnYCBoaWVyYXJjaHkgaXMgY29uc2lkZXJlZCBhIHB1YmxpYyBmaWVsZCBvciBhXG4gICAgICogICAgIGR5bmFtaWMgcHJvcGVydHkuIFRoZXNlIGFyZSBhc3NpZ25lZCBkaXJlY3RseSB0byB0aGUgaW5zdGFuY2UgKGB0aGlzLm15RmllbGQgPSB2YWx1ZWApXG4gICAgICogICAgIGF0IHRoZSB2ZXJ5IGJlZ2lubmluZy4gVGhpcyBpcyBjcnVjaWFsIHNvIHRoYXQgc3Vic2VxdWVudCBjb25maWcgaG9va3MgKGxpa2UgYGFmdGVyU2V0KmApXG4gICAgICogICAgIGNhbiBhY2Nlc3MgdGhlaXIgbGF0ZXN0IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIDIuICAqKlJlYWN0aXZlIENvbmZpZ3M6KiogQSBwcm9wZXJ0eSBpcyBjb25zaWRlcmVkIHJlYWN0aXZlIGlmIGl0IGlzIGRlZmluZWQgd2l0aCBhIHRyYWlsaW5nXG4gICAgICogICAgIHVuZGVyc2NvcmUgKGUuZy4sIGBteVZhbHVlX2ApIGluIHRoZSBgc3RhdGljIGNvbmZpZ2Agb2YgKiphbnkgY2xhc3MgaW4gdGhlIGluaGVyaXRhbmNlXG4gICAgICogICAgIGNoYWluKiouIFN1YmNsYXNzZXMgY2FuIHByb3ZpZGUgbmV3IGRlZmF1bHQgdmFsdWVzIGZvciB0aGVzZSBjb25maWdzIHdpdGhvdXQgdGhlXG4gICAgICogICAgIHVuZGVyc2NvcmUsIGFuZCB0aGV5IHdpbGwgc3RpbGwgYmUgcmVhY3RpdmUuIFRoZWlyIHZhbHVlcyBhcmUgYXBwbGllZCB2aWEgZ2VuZXJhdGVkXG4gICAgICogICAgIHNldHRlcnMsIHRyaWdnZXJpbmcgYGJlZm9yZVNldCpgIGFuZCBgYWZ0ZXJTZXQqYCBob29rcywgYW5kIHRoZXkgYXJlIHdyYXBwZWQgaW4gYVxuICAgICAqICAgICBgTmVvLmNvcmUuQ29uZmlnYCBpbnN0YW5jZSB0byBlbmFibGUgc3Vic2NyaXB0aW9uLWJhc2VkIHJlYWN0aXZpdHkuXG4gICAgICpcbiAgICAgKiAzLiAgKipOb24tUmVhY3RpdmUgQ29uZmlnczoqKiBQcm9wZXJ0aWVzIGRlZmluZWQgaW4gYHN0YXRpYyBjb25maWdgIHdpdGhvdXQgYSB0cmFpbGluZ1xuICAgICAqICAgICB1bmRlcnNjb3JlIGluIHRoZWlyIGVudGlyZSBpbmhlcml0YW5jZSBjaGFpbi4gVGhlaXIgZGVmYXVsdCB2YWx1ZXMgYXJlIGFwcGxpZWQgZGlyZWN0bHlcbiAgICAgKiAgICAgdG8gdGhlIGNsYXNzICoqcHJvdG90eXBlKiosIG1ha2luZyB0aGVtIHNoYXJlZCBhY3Jvc3MgYWxsIGluc3RhbmNlcyBhbmQgYWxsb3dpbmcgZm9yXG4gICAgICogICAgIHJ1bi10aW1lIG1vZGlmaWNhdGlvbnMgKHByb3RvdHlwYWwgaW5oZXJpdGFuY2UpLiBXaGVuIGEgbmV3IHZhbHVlIGlzIHBhc3NlZCB0byB0aGlzXG4gICAgICogICAgIG1ldGhvZCwgaXQgY3JlYXRlcyBhbiBpbnN0YW5jZS1zcGVjaWZpYyBwcm9wZXJ0eSB0aGF0IHNoYWRvd3MgdGhlIHByb3RvdHlwZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGFsc28gaW5pdGlhbGl6ZXMgdGhlIG9ic2VydmFibGUgbWl4aW4gKGlmIGFwcGxpY2FibGUpIGFuZCBzY2hlZHVsZXMgYXN5bmNocm9ub3VzXG4gICAgICogbG9naWMgbGlrZSBgaW5pdEFzeW5jKClgICh3aGljaCBoYW5kbGVzIHJlbW90ZSBtZXRob2QgYWNjZXNzKSB0byBydW4gYWZ0ZXIgdGhlIHN5bmNocm9ub3VzXG4gICAgICogY29uc3RydWN0aW9uIGNoYWluIGlzIGNvbXBsZXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZz17fSBUaGUgaW5pdGlhbCBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgdGhlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWc9e30pIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhtZSwge1xuICAgICAgICAgICAgW2NvbmZpZ1N5bWJvbF06IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZSAgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB2YWx1ZSAgICAgICA6IHt9LFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlICAgIDogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtpc0luc3RhbmNlXToge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHZhbHVlICAgICA6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUuaWQgPSBjb25maWcuaWQgfHwgSWRHZW5lcmF0b3IuZ2V0SWQodGhpcy5nZXRJZEtleSgpKTtcbiAgICAgICAgZGVsZXRlIGNvbmZpZy5pZDtcblxuICAgICAgICAvLyBBc3NpZ24gY2xhc3MgZmllbGQgdmFsdWVzIHByaW9yIHRvIGNvbmZpZ3NcbiAgICAgICAgY29uZmlnID0gbWUuc2V0RmllbGRzKGNvbmZpZyk7XG5cbiAgICAgICAgbWUuaW5pdENvbmZpZyhjb25maWcpO1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZSwgJ2NvbmZpZ3NBcHBsaWVkJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZSAgICAgOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLmFwcGx5RGVsYXlhYmxlKCk7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogV2UgZG8gbm90IHdhbnQgdG8gZm9yY2UgZGV2cyB0byBjaGVjayBmb3IgdGhlIGBpc0Rlc3Ryb3llZGAgZmxhZyBpbiBldmVyeSBwb3NzaWJsZSBjbGFzcyBleHRlbnNpb24uXG4gICAgICAgICAqIFNvLCB3ZSBhcmUgaW50ZXJjZXB0aW5nIHRoZSB0b3AtbW9zdCBgZGVzdHJveSgpYCBjYWxsIHRvIGNoZWNrIGZvciB0aGUgZmxhZyB0aGVyZS5cbiAgICAgICAgICogUmF0aW9uYWxlOiBgZGVzdHJveSgpYCBtdXN0IG9ubHkgZ2V0IGNhbGxlZCBvbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgaW50ZXJjZXB0KG1lLCAnZGVzdHJveScsIG1lLmlzRGVzdHJveWVkQ2hlY2ssIG1lKTtcblxuICAgICAgICAvLyBUcmlnZ2VycyBhc3luYyBsb2dpYyBhZnRlciB0aGUgY29uc3RydWN0aW9uIGNoYWluIGlzIGRvbmUuXG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgbWUuaW5pdEFzeW5jKCk7XG4gICAgICAgICAgICBtZS5pc1JlYWR5ID0gdHJ1ZVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaWQgY29uZmlnIGdvdCBjaGFuZ2VkLlxuICAgICAqIFlvdSBjYW4gZHluYW1pY2FsbHkgY2hhbmdlIGluc3RhbmNlIGlkcyBpZiBuZWVkZWQuIFRoZXkgbmVlZCB0byBzdGF5IHVuaXF1ZSBhdCBhbnkgZ2l2ZW4gcG9pbnQuXG4gICAgICogVXNlIGNhc2U6IGUuZy4gY29tcG9uZW50IGJhc2VkIGxpc3RzLCB3aGVyZSB5b3Ugd2FudCB0byByZS11c2UgaXRlbSBpbnN0YW5jZXMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldElkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBoYXNNYW5hZ2VyID0gQmFzZS5pbnN0YW5jZU1hbmFnZXJBdmFpbGFibGUgPT09IHRydWU7XG5cbiAgICAgICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoaGFzTWFuYWdlcikge1xuICAgICAgICAgICAgICAgIE5lby5tYW5hZ2VyLkluc3RhbmNlLnVucmVnaXN0ZXIob2xkVmFsdWUpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKE5lby5pZE1hcCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBOZW8uaWRNYXBbb2xkVmFsdWVdXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChoYXNNYW5hZ2VyKSB7XG4gICAgICAgICAgICAgICAgTmVvLm1hbmFnZXIuSW5zdGFuY2UucmVnaXN0ZXIobWUpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIE5lby5pZE1hcCA/Pz0ge307XG4gICAgICAgICAgICAgICAgTmVvLmlkTWFwW3ZhbHVlXSA9IG1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGp1c3RzIGFsbCBtZXRob2RzIGluc2lkZSBzdGF0aWMgZGVsYXlhYmxlXG4gICAgICovXG4gICAgYXBwbHlEZWxheWFibGUoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGN0b3JEZWxheWFibGUgPSBtZS5jb25zdHJ1Y3Rvci5kZWxheWFibGUsXG4gICAgICAgICAgICBkZWxheWFibGUgICAgID0gbWUuZGVsYXlhYmxlID8gTmVvLm1lcmdlKHt9LCBtZS5kZWxheWFibGUsIGN0b3JEZWxheWFibGUpIDogY3RvckRlbGF5YWJsZTtcblxuICAgICAgICBPYmplY3QuZW50cmllcyhkZWxheWFibGUpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hcCA9IHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyKCkgICB7bWVba2V5XSA9IG5ldyBidWZmZXIobWVba2V5XSwgICBtZSwgdmFsdWUudGltZXIpfSxcbiAgICAgICAgICAgICAgICAgICAgZGVib3VuY2UoKSB7bWVba2V5XSA9IG5ldyBkZWJvdW5jZShtZVtrZXldLCBtZSwgdmFsdWUudGltZXIpfSxcbiAgICAgICAgICAgICAgICAgICAgdGhyb3R0bGUoKSB7bWVba2V5XSA9IG5ldyB0aHJvdHRsZShtZVtrZXldLCBtZSwgdmFsdWUudGltZXIpfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBtYXBbdmFsdWUudHlwZV0/LigpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBzdGF0aWMgbWV0aG9kIGlzIGNhbGxlZCBieSBgTmVvLnNldHVwQ2xhc3MoKWAgZHVyaW5nIHRoZSBjbGFzcyBjcmVhdGlvbiBwcm9jZXNzLlxuICAgICAqIEl0IGFsbG93cyBmb3IgbW9kaWZ5aW5nIGEgY2xhc3MncyBkZWZhdWx0IHByb3RvdHlwZS1iYXNlZCBjb25maWdzIGZyb20gb3V0c2lkZSB0aGVcbiAgICAgKiBjbGFzcyBoaWVyYXJjaHksIHdoaWNoIGlzIGEgcG93ZXJmdWwgd2F5IHRvIGF2b2lkIGJvaWxlcnBsYXRlIGNvZGUuXG4gICAgICpcbiAgICAgKiBJdCBsb29rcyBmb3IgYSBtYXRjaGluZyBlbnRyeSBpbiB0aGUgZ2xvYmFsIGBOZW8ub3ZlcndyaXRlc2Agb2JqZWN0IGJhc2VkIG9uIHRoZVxuICAgICAqIGNsYXNzJ3MgYGNsYXNzTmFtZWAuIElmIGZvdW5kLCBpdCBtZXJnZXMgdGhlIHByb3BlcnRpZXMgZnJvbSB0aGUgb3ZlcndyaXRlIG9iamVjdFxuICAgICAqIGludG8gdGhlIGNsYXNzJ3Mgc3RhdGljIGBjb25maWdgLiBUaGlzIHByb3ZpZGVzIGEgcG93ZXJmdWwgbWVjaGFuaXNtIGZvciB0aGVtaW5nXG4gICAgICogb3IgYXBwbHlpbmcgYXBwbGljYXRpb24td2lkZSBjdXN0b21pemF0aW9ucyB0byBmcmFtZXdvcmsgb3IgbGlicmFyeSBjbGFzc2VzIHdpdGhvdXRcbiAgICAgKiBuZWVkaW5nIHRvIGV4dGVuZCB0aGVtLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBJbWFnaW5lIHlvdSBoYXZlIGh1bmRyZWRzIG9mIGJ1dHRvbnMgaW4geW91ciBhcHAsIGFuZCB5b3Ugd2FudCBhbGwgb2YgdGhlbVxuICAgICAqIC8vIHRvIGhhdmUgYGxhYmVsUG9zaXRpb246ICd0b3AnYCBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IGAnbGVmdCdgLlxuICAgICAqIC8vIEluc3RlYWQgb2YgY29uZmlndXJpbmcgZWFjaCBpbnN0YW5jZSwgeW91IGNhbiBkZWZpbmUgYW4gb3ZlcndyaXRlLlxuICAgICAqXG4gICAgICogLy8gaW5zaWRlIGFuIE92ZXJ3cml0ZXMubWpzIGZpbGUgbG9hZGVkIGJ5IHlvdXIgYXBwOlxuICAgICAqIE5lby5vdmVyd3JpdGVzID0ge1xuICAgICAqICAgICBOZW86IHtcbiAgICAgKiAgICAgICAgIGJ1dHRvbjoge1xuICAgICAqICAgICAgICAgICAgIEJhc2U6IHtcbiAgICAgKiAgICAgICAgICAgICAgICAgbGFiZWxQb3NpdGlvbjogJ3RvcCdcbiAgICAgKiAgICAgICAgICAgICB9XG4gICAgICogICAgICAgICB9XG4gICAgICogICAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogLy8gTm93LCBldmVyeSBgTmVvLmJ1dHRvbi5CYXNlYCAoYW5kIGFueSBjbGFzcyB0aGF0IGV4dGVuZHMgaXQpIHdpbGwgaGF2ZSB0aGlzXG4gICAgICogLy8gbmV3IGRlZmF1bHQgdmFsdWUgb24gaXRzIHByb3RvdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgVGhlIHN0YXRpYyBgY29uZmlnYCBvYmplY3Qgb2YgdGhlIGNsYXNzIGJlaW5nIHByb2Nlc3NlZC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBhcHBseU92ZXJ3cml0ZXMoY2ZnKSB7XG4gICAgICAgIGxldCBvdmVyd3JpdGVzID0gTmVvLm5zKGNmZy5jbGFzc05hbWUsIGZhbHNlLCBOZW8ub3ZlcndyaXRlcyksXG4gICAgICAgICAgICBjbHMsIGl0ZW07XG5cbiAgICAgICAgaWYgKG92ZXJ3cml0ZXMpIHtcbiAgICAgICAgICAgIC8vIEFwcGx5IGFsbCBtZXRob2RzXG4gICAgICAgICAgICBmb3IgKGl0ZW0gaW4gb3ZlcndyaXRlcykge1xuICAgICAgICAgICAgICAgIGlmIChOZW8uaXNGdW5jdGlvbihvdmVyd3JpdGVzW2l0ZW1dKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBbHJlYWR5IGV4aXN0aW5nIG9uZXNcbiAgICAgICAgICAgICAgICAgICAgY2xzID0gdGhpcy5wcm90b3R5cGU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsc1tpdGVtXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRvIG92ZXJ3cml0dGVuTWV0aG9kc1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xzLmNvbnN0cnVjdG9yLm92ZXJ3cml0dGVuTWV0aG9kc1tpdGVtXSA9IGNsc1tpdGVtXVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBcHBseSBjb25maWdzIHRvIHByb3RvdHlwZVxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihjZmcsIG92ZXJ3cml0ZXMpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgZm9yIGJlZm9yZVNldCBmdW5jdGlvbnMgd2hpY2ggdGVzdCBpZiBhIGdpdmVuIHZhbHVlIGlzIGluc2lkZSBhIHN0YXRpYyBhcnJheVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgY29uZmlnIG5hbWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gW3N0YXRpY05hbWU9bmFtZSArICdzJ10gbmFtZSBvZiB0aGUgc3RhdGljIGNvbmZpZyBhcnJheVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8TnVtYmVyfSB2YWx1ZSBvciBvbGRWYWx1ZVxuICAgICAqL1xuICAgIGJlZm9yZVNldEVudW1WYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsIG5hbWUsIHN0YXRpY05hbWUgPSBuYW1lICsgJ3MnKSB7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBBcnJheS5pc0FycmF5KHN0YXRpY05hbWUpID8gc3RhdGljTmFtZSA6IHRoaXMuZ2V0U3RhdGljQ29uZmlnKHN0YXRpY05hbWUpO1xuXG4gICAgICAgIGlmICghdmFsdWVzLmluY2x1ZGVzKHZhbHVlKSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgU3VwcG9ydGVkIHZhbHVlcyBmb3IgJHtuYW1lfSBhcmU6YCwgLi4udmFsdWVzLCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBvbGRWYWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgcmVtb3RlIGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdHxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fG51bGx9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge09iamVjdHxudWxsfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRSZW1vdGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgLy8gT25seSBhbGxvdyByZW1vdGUgYWNjZXNzIGZvciBzaW5nbGV0b25zIG9yIG1haW4gdGhyZWFkIGFkZG9uc1xuICAgICAgICBpZiAodmFsdWUgJiYgIW1lLnNpbmdsZXRvbiAmJiAhbWUuaXNNYWluVGhyZWFkQWRkb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVtb3RlIG1ldGhvZCBhY2Nlc3MgaXMgb25seSBmdW5jdGlvbmFsIGZvciBTaW5nbGV0b24gY2xhc3NlcyAnICsgbWUuY2xhc3NOYW1lKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZuICAgICAgICAgICAgICAgVGhlIG5hbWUgb2YgYSBmdW5jdGlvbiB0byBmaW5kIGluIHRoZSBwYXNzZWQgc2NvcGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcmlnaW5OYW1lICAgICAgIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgaW5zaWRlIHRoZSBvcmlnaW5TY29wZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2NvcGUgICAgICAgICAgICBUaGUgc2NvcGUgdG8gZmluZCB0aGUgZnVuY3Rpb24gaW4gaWYgaXQgaXMgc3BlY2lmaWVkIGFzIGEgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcmlnaW5TY29wZT10aGlzIFRoZSBzY29wZSB3aGVyZSB0aGUgZnVuY3Rpb24gaXMgbG9jYXRlZC5cbiAgICAgKi9cbiAgICBiaW5kQ2FsbGJhY2soZm4sIG9yaWdpbk5hbWUsIHNjb3BlPXRoaXMsIG9yaWdpblNjb3BlPXRoaXMpIHtcbiAgICAgICAgaWYgKGZuICYmIE5lby5pc1N0cmluZyhmbikpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSByZXNvbHZlQ2FsbGJhY2soZm4sIHNjb3BlKTtcbiAgICAgICAgICAgIG9yaWdpblNjb3BlW29yaWdpbk5hbWVdID0gaGFuZGxlci5mbi5iaW5kKGhhbmRsZXIuc2NvcGUpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGcm9tIHdpdGhpbiBhbiBvdmVyd3JpdGUsIGEgbWV0aG9kIGNhbiBjYWxsIGEgcGFyZW50IG1ldGhvZCwgYnkgdXNpbmcgY2FsbE92ZXJ3cml0dGVuLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICBhZnRlclNldEhlaWdodCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgKiAgICAgICAgLy8gZG8gdGhlIHN0YW5kYXJkXG4gICAgICogICAgICAgIHRoaXMuY2FsbE92ZXJ3cml0dGVuKC4uLmFyZ3VtZW50cyk7XG4gICAgICogICAgICAgIC8vIGRvIHlvdSBvd24gc3R1ZmZcbiAgICAgKiAgICB9XG4gICAgICpcbiAgICAgKiBXZSBjcmVhdGUgYW4gZXJyb3IgdG8gZ2V0IHRoZSBjYWxsZXIubmFtZSBhbmQgdGhlbiBydW4gdGhhdCBtZXRob2Qgb24gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqIFRoaXMgaXMgYmFzZWQgb24gdGhlIGZvbGxvd2luZyBlcnJvciBzdHJ1Y3R1cmUsIGUuZy4gYWZ0ZXJTZXRIZWlnaHQuXG4gICAgICpcbiAgICAgKiAgICAgRXJyb3JcbiAgICAgKiAgICAgICAgIGF0IEJhc2UuY2FsbE92ZXJ3cml0dGVuIChCYXNlLm1qczoxNzY6MjEpXG4gICAgICogICAgICAgICBhdCBCYXNlLmFmdGVyU2V0SGVpZ2h0IChPdmVycmlkZXMubWpzOjE5OjI2KVxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICBjYWxsT3ZlcndyaXR0ZW4oLi4uYXJncykge1xuICAgICAgICBsZXQgc3RhY2sgICAgICA9IG5ldyBFcnJvcigpLnN0YWNrLFxuICAgICAgICAgICAgbWV0aG9kTmFtZSA9IHN0YWNrLm1hdGNoKEJhc2UubWV0aG9kTmFtZVJlZ2V4KVsxXTtcblxuICAgICAgICB0aGlzLl9fcHJvdG9fXy5jb25zdHJ1Y3Rvci5vdmVyd3JpdHRlbk1ldGhvZHNbbWV0aG9kTmFtZV0uY2FsbCh0aGlzLCAuLi5hcmdzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVucmVnaXN0ZXJzIHRoaXMgaW5zdGFuY2UgZnJvbSBOZW8ubWFuYWdlci5JbnN0YW5jZVxuICAgICAqIGFuZCByZW1vdmVzIGFsbCBvYmplY3QgZW50cmllcyBmcm9tIHRoaXMgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmlzRGVzdHJveWluZyA9IHRydWU7XG5cbiAgICAgICAgbWUuI3RpbWVvdXRJZHMuZm9yRWFjaChpZCA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoaWQpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLiNjb25maWdTdWJzY3JpcHRpb25DbGVhbnVwcy5mb3JFYWNoKGNsZWFudXAgPT4ge1xuICAgICAgICAgICAgY2xlYW51cCgpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChCYXNlLmluc3RhbmNlTWFuYWdlckF2YWlsYWJsZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgTmVvLm1hbmFnZXIuSW5zdGFuY2UudW5yZWdpc3RlcihtZSlcbiAgICAgICAgfSBlbHNlIGlmIChOZW8uaWRNYXApIHtcbiAgICAgICAgICAgIGRlbGV0ZSBOZW8uaWRNYXBbbWUuaWRdXG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3Qua2V5cyhtZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobWUsIGtleSkud3JpdGFibGUpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBtdXN0IG5vdCBkZWxldGUgdGhlIGN1c3RvbSBkZXN0cm95KCkgaW50ZXJjZXB0b3JcbiAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAnZGVzdHJveScgJiYga2V5ICE9PSAnX2lkJykge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbWVba2V5XVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gV2UgZG8gd2FudCB0byBwcmV2ZW50IGRlbGF5ZWQgZXZlbnQgY2FsbHMgYWZ0ZXIgYW4gb2JzZXJ2YWJsZSBpbnN0YW5jZSBnb3QgZGVzdHJveWVkLlxuICAgICAgICBpZiAoTmVvLmlzRnVuY3Rpb24obWUuZmlyZSkpIHtcbiAgICAgICAgICAgIG1lLmZpcmUgPSBOZW8uZW1wdHlGblxuICAgICAgICB9XG5cbiAgICAgICAgbWUuaXNEZXN0cm95ZWQgPSB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBwdWJsaWMgbWV0aG9kIHRvIGFjY2VzcyB0aGUgdW5kZXJseWluZyBDb25maWcgY29udHJvbGxlci5cbiAgICAgKiBUaGlzIGVuYWJsZXMgYWR2YW5jZWQgaW50ZXJhY3Rpb25zIGxpa2Ugc3Vic2NyaXB0aW9ucy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBuYW1lIG9mIHRoZSBjb25maWcgcHJvcGVydHkgKGUuZy4sICdpdGVtcycpLlxuICAgICAqIEByZXR1cm5zIHtDb25maWd8dW5kZWZpbmVkfSBUaGUgQ29uZmlnIGluc3RhbmNlLCBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kLlxuICAgICAqL1xuICAgIGdldENvbmZpZyhrZXkpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIW1lLiNjb25maWdzW2tleV0gJiYgbWUuaXNDb25maWcoa2V5KSkge1xuICAgICAgICAgICAgbWUuI2NvbmZpZ3Nba2V5XSA9IG5ldyBDb25maWcobWUuY29uc3RydWN0b3IuY29uZmlnRGVzY3JpcHRvcnM/LltrZXldKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1lLiNjb25maWdzW2tleV1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGluc2lkZSBjcmVhdGVJZCgpIGFzIHRoZSBkZWZhdWx0IHZhbHVlIHBhc3NlZCB0byB0aGUgSWRHZW5lcmF0b3IuXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgYXMgbmVlZGVkLlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0SWRLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm50eXBlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgYSBzdGF0aWMgY29uZmlnIGtleSBvciB0aGUgc3RhdGljQ29uZmlnIG9iamVjdCBpdHNlbGYgaW4gY2FzZSBubyB2YWx1ZSBpcyBzZXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBrZXkgb2YgYSBzdGF0aWNDb25maWcgZGVmaW5lZCBpbnNpZGUgc3RhdGljIGdldFN0YXRpY0NvbmZpZ1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFN0YXRpY0NvbmZpZyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3Jba2V5XVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgZ2l2ZW4gbnR5cGUgZXhpc3RzIGluc2lkZSB0aGUgcHJvdG8gY2hhaW4sIGluY2x1ZGluZyB0aGUgdG9wIGxldmVsIGNsYXNzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG50eXBlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzTnR5cGUobnR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubnR5cGVDaGFpbi5pbmNsdWRlcyhudHlwZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCBhZnRlciBvbkNvbnN0cnVjdGVkKCkgaXMgZG9uZVxuICAgICAqL1xuICAgIGluaXQoKSB7fVxuXG4gICAgLyoqXG4gICAgICogWW91IGNhbiB1c2UgdGhpcyBtZXRob2QgaW4gc3ViY2xhc3NlcyB0byBwZXJmb3JtIGFzeW5jaHJvbm91cyBpbml0aWFsaXphdGlvbiBsb2dpYy5cbiAgICAgKiBNYWtlIHN1cmUgdG8gdXNlIHRoZSBwYXJlbnQgY2FsbCBgYXdhaXQgc3VwZXIuaW5pdEFzeW5jKClgIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlaXIgaW1wbGVtZW50YXRpb25zLFxuICAgICAqIG9yIHRoZSByZWdpc3RyYXRpb24gb2YgcmVtb3RlIG1ldGhvZHMgd2lsbCBnZXQgZGVsYXllZC5cbiAgICAgKlxuICAgICAqIEEgY29tbW9uIHVzZSBjYXNlIGlzIHJlcXVpcmluZyBjb25kaXRpb25hbCBvciBvcHRpb25hbCBkeW5hbWljIGltcG9ydHMgb3IgZmV0Y2hpbmcgaW5pdGlhbCBkYXRhLlxuICAgICAqXG4gICAgICogT25jZSB0aGUgcHJvbWlzZSByZXR1cm5lZCBieSB0aGlzIG1ldGhvZCBpcyBmdWxmaWxsZWQsIHRoZSBgaXNSZWFkeWAgY29uZmlnIHdpbGwgYmUgc2V0IHRvIGB0cnVlYC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgYXN5bmNocm9ub3VzIGluaXRpYWxpemF0aW9uIGlzIGNvbXBsZXRlLlxuICAgICAqL1xuICAgIGFzeW5jIGluaXRBc3luYygpIHtcbiAgICAgICAgdGhpcy5yZW1vdGUgJiYgdGhpcy5pbml0UmVtb3RlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGFsbCBjbGFzcyBjb25maWdzIHRvIHRoaXMgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcHJldmVudE9yaWdpbmFsQ29uZmlnXSBUcnVlIHByZXZlbnRzIHRoZSBpbnN0YW5jZSBmcm9tIGdldHRpbmcgYW4gb3JpZ2luYWxDb25maWcgcHJvcGVydHlcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaW5pdENvbmZpZyhjb25maWcsIHByZXZlbnRPcmlnaW5hbENvbmZpZykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmlzQ29uZmlndXJpbmcgPSB0cnVlO1xuICAgICAgICBPYmplY3QuYXNzaWduKG1lW2NvbmZpZ1N5bWJvbF0sIG1lLm1lcmdlQ29uZmlnKGNvbmZpZywgcHJldmVudE9yaWdpbmFsQ29uZmlnKSk7XG4gICAgICAgIGRlbGV0ZSBtZVtjb25maWdTeW1ib2xdLmlkO1xuICAgICAgICBtZS5wcm9jZXNzQ29uZmlncygpO1xuICAgICAgICBtZS5pc0NvbmZpZ3VyaW5nID0gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEb2VzIGdldCB0cmlnZ2VyZWQgd2l0aCBhIGRlbGF5IHRvIGVuc3VyZSB0aGF0IE5lby53b3JrZXJJZCAmIE5lby53b3JrZXIuTWFuYWdlciBhcmUgZGVmaW5lZFxuICAgICAqIFJlbW90ZSBtZXRob2QgYWNjZXNzIHZpYSBwcm9taXNlc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpbml0UmVtb3RlKCkge1xuICAgICAgICBsZXQge2NsYXNzTmFtZSwgcmVtb3RlfSA9IHRoaXMsXG4gICAgICAgICAgICB7Y3VycmVudFdvcmtlcn0gICAgID0gTmVvO1xuXG4gICAgICAgIGlmICghTmVvLmNvbmZpZy51bml0VGVzdE1vZGUpIHtcbiAgICAgICAgICAgIGlmIChOZW8ud29ya2VySWQgIT09ICdtYWluJyAmJiBjdXJyZW50V29ya2VyLmlzU2hhcmVkV29ya2VyICYmICFjdXJyZW50V29ya2VyLmlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFdvcmtlci5vbignY29ubmVjdGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBCYXNlLnNlbmRSZW1vdGVzKGNsYXNzTmFtZSwgcmVtb3RlKVxuICAgICAgICAgICAgICAgIH0sIHRoaXMsIHtvbmNlOiB0cnVlfSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgQmFzZS5zZW5kUmVtb3RlcyhjbGFzc05hbWUsIHJlbW90ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVyY2VwdHMgZGVzdHJveSgpIGNhbGxzIHRvIGVuc3VyZSB0aGV5IHdpbGwgb25seSBnZXQgY2FsbGVkIG9uY2VcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0Rlc3Ryb3llZENoZWNrKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuaXNEZXN0cm95ZWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNDb25maWcoa2V5KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG4gICAgICAgIC8vIElmIGEgYGNvcmUuQ29uZmlnYCBjb250cm9sbGVyIGlzIGFscmVhZHkgY3JlYXRlZCwgcmV0dXJuIHRydWUgKGZhc3Rlc3QgcG9zc2libGUgY2hlY2spLlxuICAgICAgICAvLyBJZiBub3QsIGEgY29uZmlnIGlzIGNvbnNpZGVyZWQgXCJyZWFjdGl2ZVwiIGlmIGl0IGhhcyBhIGdlbmVyYXRlZCBwcm9wZXJ0eSBzZXR0ZXJcbiAgICAgICAgLy8gQU5EIGl0IGlzIHByZXNlbnQgYXMgYSBkZWZpbmVkIGNvbmZpZyBpbiB0aGUgbWVyZ2VkIHN0YXRpYyBjb25maWcgaGllcmFyY2h5LlxuICAgICAgICAvLyBOZW8uc2V0dXBDbGFzcygpIHJlbW92ZXMgdGhlIHVuZGVyc2NvcmUgZnJvbSB0aGUgc3RhdGljIGNvbmZpZyBrZXlzLlxuICAgICAgICByZXR1cm4gbWUuI2NvbmZpZ3Nba2V5XSB8fCAoTmVvLmhhc1Byb3BlcnR5U2V0dGVyKG1lLCBrZXkpICYmIChrZXkgaW4gbWUuY29uc3RydWN0b3IuY29uZmlnKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBjaGFuZ2UgdGhlIG9yZGVyIGNvbmZpZ3MgYXJlIGFwcGxpZWQgdG8gdGhpcyBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcHJldmVudE9yaWdpbmFsQ29uZmlnXSBUcnVlIHByZXZlbnRzIHRoZSBpbnN0YW5jZSBmcm9tIGdldHRpbmcgYW4gb3JpZ2luYWxDb25maWcgcHJvcGVydHlcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgbWVyZ2VDb25maWcoY29uZmlnLCBwcmV2ZW50T3JpZ2luYWxDb25maWcpIHtcbiAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgY3RvciA9IG1lLmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgY29uZmlnRGVzY3JpcHRvcnMsIHN0YXRpY0NvbmZpZztcblxuICAgICAgICBpZiAoIWN0b3IuY29uZmlnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lby5hcHBseUNsYXNzQ29uZmlnIGhhcyBub3QgYmVlbiBydW4gb24gJyArIG1lLmNsYXNzTmFtZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcHJldmVudE9yaWdpbmFsQ29uZmlnKSB7XG4gICAgICAgICAgICBtZS5vcmlnaW5hbENvbmZpZyA9IE5lby5jbG9uZShjb25maWcsIHRydWUsIHRydWUpXG4gICAgICAgIH1cblxuICAgICAgICBjb25maWdEZXNjcmlwdG9ycyA9IGN0b3IuY29uZmlnRGVzY3JpcHRvcnM7XG4gICAgICAgIHN0YXRpY0NvbmZpZyAgICAgID0gY3Rvci5jb25maWc7XG5cbiAgICAgICAgaWYgKGNvbmZpZ0Rlc2NyaXB0b3JzKSB7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhjb25maWcpLmZvckVhY2goKFtrZXksIGluc3RhbmNlVmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IGNvbmZpZ0Rlc2NyaXB0b3JzW2tleV07XG5cbiAgICAgICAgICAgICAgICBpZiAoZGVzY3JpcHRvcj8ubWVyZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnW2tleV0gPSBOZW8ubWVyZ2VDb25maWcoc3RhdGljQ29uZmlnW2tleV0sIGluc3RhbmNlVmFsdWUsIGRlc2NyaXB0b3IubWVyZ2UpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7Li4uc3RhdGljQ29uZmlnLCAuLi5jb25maWd9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlcyAqdGhpcyogaW5zdGFuY2UgKHRoZSBzdWJzY3JpYmVyKSB0byBjaGFuZ2VzIG9mIGEgc3BlY2lmaWMgY29uZmlnIHByb3BlcnR5IG9uIGFub3RoZXIgaW5zdGFuY2UgKHRoZSBwdWJsaXNoZXIpLlxuICAgICAqIEVuc3VyZXMgYXV0b21hdGljIGNsZWFudXAgd2hlbiAqdGhpcyogaW5zdGFuY2UgKHRoZSBzdWJzY3JpYmVyKSBpcyBkZXN0cm95ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xOZW8uY29yZS5CYXNlfSBwdWJsaXNoZXIgIC0gVGhlIElEIG9mIHRoZSBwdWJsaXNoZXIgaW5zdGFuY2Ugb3IgdGhlIGluc3RhbmNlIHJlZmVyZW5jZSBpdHNlbGYuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgICAgICAgICAgICAgY29uZmlnTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBjb25maWcgcHJvcGVydHkgb24gdGhlIHB1Ymxpc2hlciB0byBzdWJzY3JpYmUgdG8gKGUuZy4sICdteUNvbmZpZycpLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259ICAgICAgICAgICAgIGZuICAgICAgICAgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIHRoZSBjb25maWcgY2hhbmdlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgY2xlYW51cCBmdW5jdGlvbiB0byBtYW51YWxseSB1bnN1YnNjcmliZSBpZiBuZWVkZWQgYmVmb3JlIHRoaXMgaW5zdGFuY2UncyBkZXN0cnVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gU3Vic2NyaWJpbmcgdG8gYSBjb25maWcgb24gYW5vdGhlciBpbnN0YW5jZVxuICAgICAqIHRoaXMub2JzZXJ2ZUNvbmZpZyhzb21lT3RoZXJJbnN0YW5jZSwgJ215Q29uZmlnJywgKG5ld1ZhbHVlLCBvbGRWYWx1ZSkgPT4ge1xuICAgICAqICAgICBjb25zb2xlLmxvZygnbXlDb25maWcgY2hhbmdlZDonLCBuZXdWYWx1ZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBEaXNjb3VyYWdlZDogU2VsZi1vYnNlcnZhdGlvbi4gVXNlIGFmdGVyU2V0PENvbmZpZ05hbWU+KCkgaG9va3MgaW5zdGVhZC5cbiAgICAgKiB0aGlzLm9ic2VydmVDb25maWcodGhpcywgJ215T3duQ29uZmlnJywgKG5ld1ZhbHVlLCBvbGRWYWx1ZSkgPT4ge1xuICAgICAqICAgICBjb25zb2xlLmxvZygnbXlPd25Db25maWcgY2hhbmdlZDonLCBuZXdWYWx1ZSk7XG4gICAgICogfSk7XG4gICAgICovXG4gICAgb2JzZXJ2ZUNvbmZpZyhwdWJsaXNoZXIsIGNvbmZpZ05hbWUsIGZuKSB7XG4gICAgICAgIGxldCBwdWJsaXNoZXJJbnN0YW5jZSA9IHB1Ymxpc2hlcjtcblxuICAgICAgICBpZiAoTmVvLmlzU3RyaW5nKHB1Ymxpc2hlcikpIHtcbiAgICAgICAgICAgIHB1Ymxpc2hlckluc3RhbmNlID0gTmVvLmdldChwdWJsaXNoZXIpO1xuICAgICAgICAgICAgaWYgKCFwdWJsaXNoZXJJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgUHVibGlzaGVyIGluc3RhbmNlIHdpdGggSUQgJyR7cHVibGlzaGVyfScgbm90IGZvdW5kLiBDYW5ub3Qgc3Vic2NyaWJlLmApO1xuICAgICAgICAgICAgICAgIHJldHVybiBOZW8uZW1wdHlGblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEocHVibGlzaGVySW5zdGFuY2UgaW5zdGFuY2VvZiBOZW8uY29yZS5CYXNlKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBJbnZhbGlkIHB1Ymxpc2hlciBwcm92aWRlZC4gTXVzdCBiZSBhIE5lby5jb3JlLkJhc2UgaW5zdGFuY2Ugb3IgaXRzIElELmApO1xuICAgICAgICAgICAgcmV0dXJuIE5lby5lbXB0eUZuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb25maWdDb250cm9sbGVyID0gcHVibGlzaGVySW5zdGFuY2UuZ2V0Q29uZmlnKGNvbmZpZ05hbWUpO1xuXG4gICAgICAgIGlmICghY29uZmlnQ29udHJvbGxlcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBDb25maWcgJyR7Y29uZmlnTmFtZX0nIG5vdCBmb3VuZCBvbiBwdWJsaXNoZXIgaW5zdGFuY2UgJHtwdWJsaXNoZXJJbnN0YW5jZS5pZH0uIENhbm5vdCBzdWJzY3JpYmUuYCk7XG4gICAgICAgICAgICByZXR1cm4gTmVvLmVtcHR5Rm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSBjb25maWdDb250cm9sbGVyLnN1YnNjcmliZSh7aWQ6IHRoaXMuaWQsIGZufSk7XG5cbiAgICAgICAgdGhpcy4jY29uZmlnU3Vic2NyaXB0aW9uQ2xlYW51cHMucHVzaChjbGVhbnVwKTtcblxuICAgICAgICByZXR1cm4gY2xlYW51cFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25BZnRlckNvbnN0cnVjdGVkKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmlzQ29uc3RydWN0ZWQgPSB0cnVlO1xuXG4gICAgICAgIC8vIFdlIGNhbiBvbmx5IGZpcmUgdGhlIGV2ZW50IGluIGNhc2UgdGhlIE9ic2VydmFibGUgbWl4aW4gaXMgaW5jbHVkZWQuXG4gICAgICAgIG1lLmdldFN0YXRpY0NvbmZpZygnb2JzZXJ2YWJsZScpICYmIG1lLmZpcmUoJ2NvbnN0cnVjdGVkJywgbWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0cmlnZ2VyZWQgYWZ0ZXIgYWxsIGNvbnN0cnVjdG9ycyBhcmUgZG9uZVxuICAgICAqL1xuICAgIG9uQ29uc3RydWN0ZWQoKSB7fVxuXG4gICAgLyoqXG4gICAgICogUGxhY2Vob2xkZXIgbWV0aG9kIGZvciBpbnRlcmNlcHRpbmcgcmVtb3RlIGNhbGxzLlxuICAgICAqIFN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGltcGxlbWVudCBjdXN0b20gaW50ZXJjZXB0aW9uIGxvZ2ljLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtc2cgVGhlIHJlbW90ZSBtZXNzYWdlIG9iamVjdC5cbiAgICAgKi9cbiAgICBvbkludGVyY2VwdFJlbW90ZXMobXNnKSB7XG4gICAgICAgIC8vIE5vLW9wIGluIGJhc2UgY2xhc3NcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIHJlcGxhY2Ugc3RyaW5nLWJhc2VkIHZhbHVlcyBjb250YWluaW5nIFwiQGNvbmZpZzpcIiB3aXRoIHRoZSBtYXRjaGluZyBjb25maWcgdmFsdWVcbiAgICAgKiBvZiB0aGlzIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fE9iamVjdFtdfSBpdGVtc1xuICAgICAqL1xuICAgIHBhcnNlSXRlbUNvbmZpZ3MoaXRlbXMpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIG5zLCBuc0FycmF5LCBuc0tleSwgc3ltYm9sTnM7XG5cbiAgICAgICAgaWYgKGl0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgICAgICAgICAgaXRlbXMgPSBbaXRlbXNdXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgaXRlbSAmJiBPYmplY3QuZW50cmllcyhpdGVtKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5wYXJzZUl0ZW1Db25maWdzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLnN0YXJ0c1dpdGgoJ0Bjb25maWc6JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5zQXJyYXkgPSB2YWx1ZS5zdWJzdHJpbmcoOCkudHJpbSgpLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuc0tleSAgID0gbnNBcnJheS5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5zICAgICAgPSBOZW8ubnMobnNBcnJheSwgZmFsc2UsIG1lKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5zW25zS2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignVGhlIHVzZWQgQGNvbmZpZyBkb2VzIG5vdCBleGlzdDonLCBuc0tleSwgbnNBcnJheS5qb2luKCcuJykpXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbE5zID0gTmVvLm5zKG5zQXJyYXksIGZhbHNlLCBtZVtjb25maWdTeW1ib2xdKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBjb25maWcgbWlnaHQgbm90IGJlIHByb2Nlc3NlZCB5ZXQsIGVzcGVjaWFsbHkgZm9yIGNvbmZpZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3QgZW5kaW5nIHdpdGggYW4gdW5kZXJzY29yZSwgc28gd2UgbmVlZCB0byBjaGVjayB0aGUgY29uZmlnU3ltYm9sIGZpcnN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzeW1ib2xOcyAmJiBPYmplY3QuaGFzT3duKHN5bWJvbE5zLCBuc0tleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbVtrZXldID0gc3ltYm9sTnNbbnNLZXldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbVtrZXldID0gbnNbbnNLZXldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHVzaW5nIHNldCgpLCBjb25maWdzIHdpdGhvdXQgYSB0cmFpbGluZyB1bmRlcnNjb3JlIGNhbiBhbHJlYWR5IGJlIGFzc2lnbmVkLFxuICAgICAqIHNvIHRoZSBoYXNPd25Qcm9wZXJ0eSgpIGNoZWNrIHdpbGwgcmV0dXJuIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JjZUFzc2lnbj1mYWxzZV1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcHJvY2Vzc0NvbmZpZ3MoZm9yY2VBc3NpZ249ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKG1lW2NvbmZpZ1N5bWJvbF0pO1xuXG4gICAgICAgIG1lW2ZvcmNlQXNzaWduQ29uZmlnc10gPSBmb3JjZUFzc2lnbjtcblxuICAgICAgICAvLyBXZSBkbyBub3Qgd2FudCB0byBpdGVyYXRlIG92ZXIgdGhlIGtleXMsIHNpbmNlIDEgY29uZmlnIGNhbiByZW1vdmUgbW9yZSB0aGFuIDEga2V5IChiZWZvcmVTZXRYLCBhZnRlclNldFgpXG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIFRoZSBoYXNPd25Qcm9wZXJ0eSBjaGVjayBpcyBpbnRlbmRlZCBmb3IgY29uZmlncyB3aXRob3V0IGEgdHJhaWxpbmcgdW5kZXJzY29yZVxuICAgICAgICAgICAgLy8gPT4gdGhleSBjb3VsZCBhbHJlYWR5IGhhdmUgYmVlbiBhc3NpZ25lZCBpbnNpZGUgYW4gYWZ0ZXJTZXQtbWV0aG9kXG4gICAgICAgICAgICBpZiAoZm9yY2VBc3NpZ24gfHwgIW1lLmhhc093blByb3BlcnR5KGtleXNbMF0pKSB7XG4gICAgICAgICAgICAgICAgbWVba2V5c1swXV0gPSBtZVtjb25maWdTeW1ib2xdW2tleXNbMF1dXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIGEgZGVsZXRlLWNhbGwgaW5zaWRlIHRoZSBjb25maWcgZ2V0dGVyIGFzIHdlbGwgKE5lby5tanMgPT4gYXV0b0dlbmVyYXRlR2V0U2V0KCkpXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGtlZXAgdGhpcyBvbmUgZm9yIGNvbmZpZ3MsIHdoaWNoIGRvIG5vdCB1c2UgZ2V0dGVycyAobm8gdHJhaWxpbmcgdW5kZXJzY29yZSlcbiAgICAgICAgICAgIGRlbGV0ZSBtZVtjb25maWdTeW1ib2xdW2tleXNbMF1dO1xuXG4gICAgICAgICAgICBtZS5wcm9jZXNzQ29uZmlncyhmb3JjZUFzc2lnbilcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVtb3RlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHN0YXRpYyBzZW5kUmVtb3RlcyhjbGFzc05hbWUsIHJlbW90ZSkge1xuICAgICAgICBsZXQgb3JpZ2luO1xuXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHJlbW90ZSkuZm9yRWFjaCgoW3dvcmtlciwgbWV0aG9kc10pID0+IHtcbiAgICAgICAgICAgIGlmIChOZW8ud29ya2VySWQgIT09IHdvcmtlcikge1xuICAgICAgICAgICAgICAgIG9yaWdpbiA9IE5lby53b3JrZXJJZCA9PT0gJ21haW4nID8gTmVvLndvcmtlci5NYW5hZ2VyIDogTmVvLmN1cnJlbnRXb3JrZXI7XG5cbiAgICAgICAgICAgICAgICBvcmlnaW4uc2VuZE1lc3NhZ2Uod29ya2VyLCB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogJ3JlZ2lzdGVyUmVtb3RlJyxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgICAgICBtZXRob2RzXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZXQoKSBhY2NlcHRzIHRoZSBmb2xsb3dpbmcgaW5wdXQgYXMga2V5czpcbiAgICAgKiAxLiBOb24tcmVhY3RpdmUgY29uZmlnc1xuICAgICAqIDIuIFJlYWN0aXZlIGNvbmZpZ3NcbiAgICAgKiAzLiBDbGFzcyBmaWVsZHMgZGVmaW5lZCB2aWEgdmFsdWVcbiAgICAgKiA0LiBDbGFzcyBmaWVsZHMgZGVmaW5lZCB2aWEgZ2V0KCkgJiBzZXQoKVxuICAgICAqIDUuIFwiQW55dGhpbmcgZWxzZVwiIHdpbGwgZ2V0IGRpcmVjdGx5IGdldCBhc3NpZ25lZCB0byB0aGUgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIFRoZSBsb2dpYyByZXNvbHZlcyBjaXJjdWxhciBkZXBlbmRlbmNpZXMgYXMgZ29vZCBhcyBwb3NzaWJsZSBhbmQgZW5zdXJlcyB0aGF0IGNvbmZpZyByZWxhdGVkIGhvb2tzOlxuICAgICAqIC0gYmVmb3JlR2V0PENvbmZpZz5cbiAgICAgKiAtIGJlZm9yZVNldDxDb25maWc+XG4gICAgICogLSBhZnRlclNldDxDb25maWc+XG4gICAgICogY2FuIGFjY2VzcyBhbGwgbmV3IHZhbHVlcyBmcm9tIHRoZSBiYXRjaCBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlcz17fVxuICAgICAqL1xuICAgIHNldCh2YWx1ZXM9e30pIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNsYXNzRmllbGRzVmlhU2V0ID0ge307XG5cbiAgICAgICAgLy8gUHJldmVudCBFZmZlY3RzIGZyb20gcnVubmluZyBmb3IgYnVsayBjaGFuZ2VzXG4gICAgICAgIEVmZmVjdE1hbmFnZXIucGF1c2UoKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFsdWVzID0gbWUuc2V0RmllbGRzKHZhbHVlcyk7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBpbml0aWFsIGNvbmZpZyBwcm9jZXNzaW5nIGlzIHN0aWxsIHJ1bm5pbmcsXG4gICAgICAgICAgICAvLyBmaW5pc2ggdGhpcyBvbmUgZmlyc3QgYmVmb3JlIGRyb3BwaW5nIG5ldyB2YWx1ZXMgaW50byB0aGUgY29uZmlnU3ltYm9sLlxuICAgICAgICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbmVvbWpzL25lby9pc3N1ZXMvMjIwMVxuICAgICAgICAgICAgaWYgKG1lW2ZvcmNlQXNzaWduQ29uZmlnc10gIT09IHRydWUgJiYgT2JqZWN0LmtleXMobWVbY29uZmlnU3ltYm9sXSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG1lLnByb2Nlc3NDb25maWdzKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3RvcmUgY2xhc3MgZmllbGRzIHdoaWNoIGFyZSBkZWZpbmVkIHZpYSBnZXQoKSAmIHNldCgpIGFuZCBlbnN1cmUgdGhleSB3b24ndCBnZXQgYWRkZWQgdG8gdGhlIGNvbmZpZyBzeW1ib2wuXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyh2YWx1ZXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghbWUuaXNDb25maWcoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc0ZpZWxkc1ZpYVNldFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZXNba2V5XVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIC8vIEFkZCByZWFjdGl2ZSBjb25maWdzIHRvIHRoZSBjb25maWdTeW1ib2xcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obWVbY29uZmlnU3ltYm9sXSwgdmFsdWVzKTtcblxuICAgICAgICAgICAgLy8gUHJvY2VzcyBjbGFzcyBmaWVsZHMgd2hpY2ggYXJlIGRlZmluZWQgdmlhIGdldCgpICYgc2V0KCkgPT4gbm93IHRoZXkgY2FuIGFjY2VzcyB0aGUgbGF0ZXN0IHZhbHVlc1xuICAgICAgICAgICAgLy8gZm9yIHJlYWN0aXZlIGFuZCBub24tcmVhY3RpdmUgY29uZmlncywgYXMgd2VsbCBhcyBjbGFzcyBmaWVsZHMgZGVmaW5lZCB3aXRoIHZhbHVlcy5cbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGNsYXNzRmllbGRzVmlhU2V0KS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICBtZVtrZXldID0gdmFsdWVcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIC8vIFByb2Nlc3MgcmVhY3RpdmUgY29uZmlnc1xuICAgICAgICAgICAgbWUucHJvY2Vzc0NvbmZpZ3ModHJ1ZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAvLyBUcmlnZ2VyIHRoZSBza2lwcGVkIEVmZmVjdCwgaWYgbmVlZGVkXG4gICAgICAgICAgICBFZmZlY3RNYW5hZ2VyLnJlc3VtZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXZSB3YW50IHRvIGFzc2lnbiBjbGFzcyBmaWVsZHMgZmlyc3QgYW5kIHJlbW92ZSB0aGVtIGZyb20gdGhlIGNvbmZpZyBvYmplY3QsXG4gICAgICogc28gdGhhdCBhZnRlclNldCgpLCBiZWZvcmVHZXQoKSBhbmQgYmVmb3JlU2V0KCkgbWV0aG9kcyBjYW4gZ2V0IHRoZSBuZXcgdmFsdWVzIHJpZ2h0IGF3YXlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2V0RmllbGRzKGNvbmZpZykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGNvbmZpZykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBpZiAoIW1lLmlzQ29uZmlnKGtleSkgJiYgIU5lby5oYXNQcm9wZXJ0eVNldHRlcihtZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIG1lW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBkZWxldGUgY29uZmlnW2tleV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNvbmZpZ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlIG9mIGEgc3RhdGljIGNvbmZpZyBieSBhIGdpdmVuIGtleVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIGtleSBvZiBhIHN0YXRpY0NvbmZpZyBkZWZpbmVkIGluc2lkZSBzdGF0aWMgZ2V0U3RhdGljQ29uZmlnXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGluIGNhc2UgdGhlIGNvbmZpZyBleGlzdHMgYW5kIGdvdCBjaGFuZ2VkXG4gICAgICovXG4gICAgc2V0U3RhdGljQ29uZmlnKGtleSwgdmFsdWUpIHtcbiAgICAgICAgbGV0IHN0YXRpY0NvbmZpZyA9IHRoaXMuY29uc3RydWN0b3Iuc3RhdGljQ29uZmlnO1xuXG4gICAgICAgIGlmIChzdGF0aWNDb25maWcuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgc3RhdGljQ29uZmlnW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdG9yZXMgdGltZW91dElkcyBpbnRlcm5hbGx5LCBzbyB0aGF0IGRlc3Ryb3koKSBjYW4gY2xlYXIgdGhlbSBpZiBuZWVkZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGltZSBpbiBtaWxsaXNlY29uZHNcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIHRpbWVvdXQodGltZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBsZXQgdGltZW91dElkcyA9IHRoaXMuI3RpbWVvdXRJZHMsXG4gICAgICAgICAgICAgICAgdGltZW91dElkICA9IHNldFRpbWVvdXQoKCkgPT4ge3RpbWVvdXRJZHMuc3BsaWNlKHRpbWVvdXRJZHMuaW5kZXhPZih0aW1lb3V0SWQpLCAxKTsgcmVzb2x2ZSgpfSwgdGltZSk7XG5cbiAgICAgICAgICAgIHRpbWVvdXRJZHMucHVzaCh0aW1lb3V0SWQpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogPHA+RW5oYW5jaW5nIHRoZSB0b1N0cmluZygpIG1ldGhvZCwgZS5nLjwvcD5cbiAgICAgKiBgTmVvLmNyZWF0ZSgnTmVvLmJ1dHRvbi5CYXNlJykudG9TdHJpbmcoKSA9PiBcIltvYmplY3QgTmVvLmJ1dHRvbi5CYXNlIChuZW8tYnV0dG9uLTEpXVwiYFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGFzc05hbWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiA8cD5FbmhhbmNpbmcgdGhlIGluc3RhbmNlb2YgbWV0aG9kLiBXaXRob3V0IHRoaXMgY2hhbmdlOjwvcD5cbiAgICAgKiBgTmVvLmNvbGxlY3Rpb24uQmFzZS5wcm90b3R5cGUgaW5zdGFuY2VvZiBOZW8uY29yZS5CYXNlID0+IHRydWVgXG4gICAgICogPHA+V2l0aCB0aGlzIGNoYW5nZTo8L3A+XG4gICAgICogYE5lby5jb2xsZWN0aW9uLkJhc2UucHJvdG90eXBlIGluc3RhbmNlb2YgTmVvLmNvcmUuQmFzZSA9PiBmYWxzZWA8YnI+XG4gICAgICogYE5lby5jcmVhdGUoTmVvLmNvbGxlY3Rpb24uQmFzZSkgaW5zdGFuY2VvZiBOZW8uY29yZS5CYXNlID0+IHRydWVgXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIFtTeW1ib2wuaGFzSW5zdGFuY2VdKGluc3RhbmNlKSB7XG4gICAgICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlW2lzSW5zdGFuY2VdID09PSB0cnVlID8gc3VwZXJbU3ltYm9sLmhhc0luc3RhbmNlXShpbnN0YW5jZSkgOiBmYWxzZVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQmFzZSk7XG4iLCIvKipcbiAqIEBjbGFzcyBOZW8uY29yZS5Db21wYXJlXG4gKi9cbmNsYXNzIENvbXBhcmUge1xuICAgIC8qKlxuICAgICAqIFN0b3JpbmcgdGhlIGNvbXBhcmlzb24gbWV0aG9kIG5hbWVzIGJ5IGRhdGEgdHlwZVxuICAgICAqIEBtZW1iZXIge09iamVjdH0gbWFwXG4gICAgICovXG4gICAgc3RhdGljIG1hcCA9IHtcbiAgICAgICAgQXJyYXkgICAgICA6ICdjb21wYXJlQXJyYXlzJyxcbiAgICAgICAgRGF0ZSAgICAgICA6ICdjb21wYXJlRGF0ZXMnLFxuICAgICAgICBGdW5jdGlvbiAgIDogJ2NvbXBhcmVGdW5jdGlvbnMnLFxuICAgICAgICBNYXAgICAgICAgIDogJ2NvbXBhcmVNYXBzJyxcbiAgICAgICAgTmVvSW5zdGFuY2U6ICdjb21wYXJlTmVvSW5zdGFuY2VzJyxcbiAgICAgICAgT2JqZWN0ICAgICA6ICdjb21wYXJlT2JqZWN0cycsXG4gICAgICAgIFJlZ0V4cCAgICAgOiAnY29tcGFyZVJlZ0V4cHMnLFxuICAgICAgICBTZXQgICAgICAgIDogJ2NvbXBhcmVTZXRzJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGl0ZW0xXG4gICAgICogQHBhcmFtIHtBcnJheX0gaXRlbTJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgY29tcGFyZUFycmF5cyhpdGVtMSwgaXRlbTIpIHtcbiAgICAgICAgaWYgKGl0ZW0xLmxlbmd0aCAhPT0gaXRlbTIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgW2ksIHZdIG9mIGl0ZW0xLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaWYgKCFDb21wYXJlLmlzRXF1YWwodiwgaXRlbTJbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RGF0ZX0gaXRlbTFcbiAgICAgKiBAcGFyYW0ge0RhdGV9IGl0ZW0yXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGNvbXBhcmVEYXRlcyhpdGVtMSwgaXRlbTIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0xLnZhbHVlT2YoKSA9PT0gaXRlbTIudmFsdWVPZigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlbTFcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVtMlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBjb21wYXJlRnVuY3Rpb25zKGl0ZW0xLCBpdGVtMikge1xuICAgICAgICBpZiAoaXRlbTEubmFtZSAhPT0gaXRlbTIubmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlbTEudG9TdHJpbmcoKSA9PT0gaXRlbTIudG9TdHJpbmcoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TWFwfSBpdGVtMVxuICAgICAqIEBwYXJhbSB7TWFwfSBpdGVtMlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBjb21wYXJlTWFwcyhpdGVtMSwgaXRlbTIpIHtcbiAgICAgICAgaWYgKGl0ZW0xLnNpemUgIT09IGl0ZW0yLnNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHZhbDI7XG5cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIGl0ZW0xKSB7XG4gICAgICAgICAgICB2YWwyID0gaXRlbTIuZ2V0KGtleSk7XG5cbiAgICAgICAgICAgIGlmICh2YWwyICE9PSB2YWwgfHwgdmFsMiA9PT0gdW5kZWZpbmVkICYmICFpdGVtMi5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb3JlLkJhc2V9IGl0ZW0xXG4gICAgICogQHBhcmFtIHtOZW8uY29yZS5CYXNlfSBpdGVtMlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBjb21wYXJlTmVvSW5zdGFuY2VzKGl0ZW0xLCBpdGVtMikge1xuICAgICAgICByZXR1cm4gaXRlbTEuaWQgPT09IGl0ZW0yLmlkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW0xXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW0yXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGNvbXBhcmVPYmplY3RzKGl0ZW0xLCBpdGVtMikge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMoaXRlbTEpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoaXRlbTIpLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gaXRlbTEpIHtcbiAgICAgICAgICAgIGlmICghQ29tcGFyZS5pc0VxdWFsKGl0ZW0xW2tleV0sIGl0ZW0yW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBpdGVtMVxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBpdGVtMlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBjb21wYXJlUmVnRXhwcyhpdGVtMSwgaXRlbTIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0xLnRvU3RyaW5nKCkgPT09IGl0ZW0yLnRvU3RyaW5nKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1NldH0gaXRlbTFcbiAgICAgKiBAcGFyYW0ge1NldH0gaXRlbTJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgY29tcGFyZVNldHMoaXRlbTEsIGl0ZW0yKSB7XG4gICAgICAgIGlmIChpdGVtMS5zaXplICE9PSBpdGVtMi5zaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGtleSBvZiBpdGVtMSkge1xuICAgICAgICAgICAgaWYgKCFpdGVtMi5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IGl0ZW0xXG4gICAgICogQHBhcmFtIHsqfSBpdGVtMlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpc0VxdWFsKGl0ZW0xLCBpdGVtMikge1xuICAgICAgICBpZiAoaXRlbTEgPT09IGl0ZW0yKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHR5cGUxID0gTmVvLnR5cGVPZihpdGVtMSksXG4gICAgICAgICAgICB0eXBlMiA9IE5lby50eXBlT2YoaXRlbTIpO1xuXG4gICAgICAgIGlmICh0eXBlMSAhPT0gdHlwZTIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKENvbXBhcmUubWFwW3R5cGUxXSkge1xuICAgICAgICAgICAgcmV0dXJuIENvbXBhcmVbQ29tcGFyZS5tYXBbdHlwZTFdXShpdGVtMSwgaXRlbTIpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBhbGwgb3RoZXIgdHlwZXNcbiAgICAgICAgcmV0dXJuIGl0ZW0xID09PSBpdGVtMlxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLmdhdGVrZWVwKENvbXBhcmUsICdOZW8uY29yZS5Db21wYXJlJywgKCkgPT4ge1xuICAgIC8vIGFsaWFzXG4gICAgTmVvLmlzRXF1YWwgPSBDb21wYXJlLmlzRXF1YWxcbn0pO1xuIiwiaW1wb3J0IEVmZmVjdE1hbmFnZXIgIGZyb20gJy4vRWZmZWN0TWFuYWdlci5tanMnO1xuaW1wb3J0IHtpc0Rlc2NyaXB0b3J9IGZyb20gJy4vQ29uZmlnU3ltYm9scy5tanMnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gb2JzZXJ2YWJsZSBjb250YWluZXIgZm9yIGEgY29uZmlnIHByb3BlcnR5LlxuICogVGhpcyBjbGFzcyBtYW5hZ2VzIHRoZSB2YWx1ZSBvZiBhIGNvbmZpZywgaXRzIHN1YnNjcmliZXJzLCBhbmQgY3VzdG9tIGJlaGF2aW9yc1xuICogbGlrZSBtZXJnZSBzdHJhdGVnaWVzIGFuZCBlcXVhbGl0eSBjaGVja3MgZGVmaW5lZCB2aWEgYSBkZXNjcmlwdG9yIG9iamVjdC5cbiAqXG4gKiBUaGUgcHJpbWFyeSBwdXJwb3NlIG9mIHRoaXMgY2xhc3MgaXMgdG8gZW5hYmxlIGZpbmUtZ3JhaW5lZCByZWFjdGl2aXR5IGFuZFxuICogZGVjb3VwbGVkIGNyb3NzLWluc3RhbmNlIHN0YXRlIHNoYXJpbmcgd2l0aGluIHRoZSBOZW8ubWpzIGZyYW1ld29yay5cbiAqIEBjbGFzcyBOZW8uY29yZS5Db25maWdcbiAqIEBwcml2YXRlXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgQ29uZmlnIHtcbiAgICAvKipcbiAgICAgKiBTdG9yZXMgYWxsIHN1YnNjcmlwdGlvbnMgZm9yIHRoaXMgQ29uZmlnIGluc3RhbmNlLlxuICAgICAqIFRoZSBkYXRhIHN0cnVjdHVyZSBpcyBhIE1hcCB3aGVyZTpcbiAgICAgKiAtIFRoZSBrZXkgaXMgdGhlIElEIG9mIHRoZSBzdWJzY3JpcHRpb24gb3duZXIgKGUuZy4sIGEgY29tcG9uZW50J3MgYGlkYCkuXG4gICAgICogLSBUaGUgdmFsdWUgaXMgYW5vdGhlciBNYXAgKHRoZSBzdWJzY3JpYmVyTWFwKS5cbiAgICAgKlxuICAgICAqIFRoZSBuZXN0ZWQgc3Vic2NyaWJlck1hcCBpcyBzdHJ1Y3R1cmVkIGFzOlxuICAgICAqIC0gVGhlIGtleSBpcyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gKGBmbmApLlxuICAgICAqIC0gVGhlIHZhbHVlIGlzIGEgU2V0IG9mIHNjb3BlcyAoYHNjb3BlU2V0YCkuXG4gICAgICpcbiAgICAgKiBUaGlzIG5lc3RlZCBzdHJ1Y3R1cmUgYE1hcDxzdHJpbmcsIE1hcDxmdW5jdGlvbiwgU2V0PHNjb3BlPj4+YCBpcyBpbnRlbnRpb25hbGx5IGNob3NlblxuICAgICAqIHRvIHJvYnVzdGx5IGhhbmRsZSB0aGUgZWRnZSBjYXNlIHdoZXJlIHRoZSBzYW1lIGZ1bmN0aW9uIGlzIHN1YnNjcmliZWQgbXVsdGlwbGUgdGltZXNcbiAgICAgKiB3aXRoIGRpZmZlcmVudCBzY29wZXMsIGFsbCB1bmRlciB0aGUgc2FtZSBvd25lciBJRC4gSXQgZW5zdXJlcyB0aGF0IGVhY2hcbiAgICAgKiBgZm5gLWBzY29wZWAgY29tYmluYXRpb24gaXMgdW5pcXVlIGFuZCB0aGF0IGNsZWFudXAgaXMgcHJlY2lzZS5cbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9ICNzdWJzY3JpYmVycz17fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgI3N1YnNjcmliZXJzID0ge31cbiAgICAvKipcbiAgICAgKiBUaGUgaW50ZXJuYWwgdmFsdWUgb2YgdGhlIGNvbmZpZyBwcm9wZXJ0eS5cbiAgICAgKiBAbWVtYmVyIHsqfSAjdmFsdWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgICN2YWx1ZVxuICAgIC8qKlxuICAgICAqIFRoZSBjbG9uaW5nIHN0cmF0ZWd5IHRvIHVzZSB3aGVuIHNldHRpbmcgYSBuZXcgdmFsdWUuXG4gICAgICogU3VwcG9ydGVkIHZhbHVlczogJ2RlZXAnLCAnc2hhbGxvdycsICdub25lJy5cbiAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsb25lPSdkZWVwJ1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNsb25pbmcgc3RyYXRlZ3kgdG8gdXNlIHdoZW4gZ2V0dGluZyBhIHZhbHVlLlxuICAgICAqIFN1cHBvcnRlZCB2YWx1ZXM6ICdkZWVwJywgJ3NoYWxsb3cnLCAnbm9uZScuXG4gICAgICogQG1lbWJlciB7U3RyaW5nfSBjbG9uZU9uR2V0PW51bGxcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGNvbXBhcmUgbmV3IGFuZCBvbGQgdmFsdWVzIGZvciBlcXVhbGl0eS5cbiAgICAgKiBEZWZhdWx0cyB0byBgTmVvLmlzRXF1YWxgLiBDYW4gYmUgb3ZlcnJpZGRlbiB2aWEgYSBkZXNjcmlwdG9yLlxuICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBpc0VxdWFsPU5lby5pc0VxdWFsXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RyYXRlZ3kgdG8gdXNlIHdoZW4gbWVyZ2luZyBuZXcgdmFsdWVzIGludG8gdGhpcyBjb25maWcuXG4gICAgICogRGVmYXVsdHMgdG8gJ3JlcGxhY2UnLiBDYW4gYmUgb3ZlcnJpZGRlbiB2aWEgYSBkZXNjcmlwdG9yIG1lcmdlIHByb3BlcnR5LlxuICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufFN0cmluZ30gbWVyZ2VTdHJhdGVneT0ncmVwbGFjZSdcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQ29uZmlnLlxuICAgICAqIEBwYXJhbSB7YW55fE9iamVjdH0gY29uZmlnT2JqZWN0IC0gVGhlIGluaXRpYWwgdmFsdWUgZm9yIHRoZSBjb25maWcuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnT2JqZWN0KSB7XG4gICAgICAgIGlmIChOZW8uaXNPYmplY3QoY29uZmlnT2JqZWN0KSAmJiBjb25maWdPYmplY3RbaXNEZXNjcmlwdG9yXSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5pbml0RGVzY3JpcHRvcihjb25maWdPYmplY3QpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiN2YWx1ZSA9IGNvbmZpZ09iamVjdFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgY29uZmlnIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHthbnl9IFRoZSBjdXJyZW50IHZhbHVlLlxuICAgICAqL1xuICAgIGdldCgpIHtcbiAgICAgICAgLy8gUmVnaXN0ZXJzIHRoaXMgQ29uZmlnIGluc3RhbmNlIGFzIGEgZGVwZW5kZW5jeSB3aXRoIHRoZSBjdXJyZW50bHkgYWN0aXZlIEVmZmVjdCxcbiAgICAgICAgLy8gZW5hYmxpbmcgYXV0b21hdGljIHJlLWV4ZWN1dGlvbiB3aGVuIHRoaXMgQ29uZmlnJ3MgdmFsdWUgY2hhbmdlcy5cbiAgICAgICAgRWZmZWN0TWFuYWdlci5hZGREZXBlbmRlbmN5KHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy4jdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgYENvbmZpZ2AgaW5zdGFuY2UgdXNpbmcgYSBkZXNjcmlwdG9yIG9iamVjdC5cbiAgICAgKiBFeHRyYWN0cyBgY2xvbmVgLCBgbWVyZ2VTdHJhdGVneWAgYW5kIGBpc0VxdWFsYCBmcm9tIHRoZSBkZXNjcmlwdG9yLlxuICAgICAqIFRoZSBpbnRlcm5hbCBgI3ZhbHVlYCBpcyBOT1Qgc2V0IGJ5IHRoaXMgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICBkZXNjcmlwdG9yICAgICAgICAgICAgICAgICAgICAgIC0gVGhlIGRlc2NyaXB0b3Igb2JqZWN0IGZvciB0aGUgY29uZmlnLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgIFtkZXNjcmlwdG9yLmNsb25lPSdkZWVwJ10gICAgICAgIC0gVGhlIGNsb25lIHN0cmF0ZWd5IGZvciBzZXQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICAgW2Rlc2NyaXB0b3IuY2xvbmVPbkdldF0gICAgICAgICAgLSBUaGUgY2xvbmUgc3RyYXRlZ3kgZm9yIGdldC4gRGVmYXVsdHMgdG8gJ3NoYWxsb3cnIGlmIGNsb25lIGlzICdkZWVwJyBvciAnc2hhbGxvdycsIGFuZCAnbm9uZScgaWYgY2xvbmUgaXMgJ25vbmUnLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtkZXNjcmlwdG9yLmlzRXF1YWw9TmVvLmlzRXF1YWxdIC0gVGhlIGVxdWFsaXR5IGNvbXBhcmlzb24gZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICAgW2Rlc2NyaXB0b3IubWVyZ2U9J2RlZXAnXSAgICAgICAgLSBUaGUgbWVyZ2Ugc3RyYXRlZ3kuXG4gICAgICogQHBhcmFtIHthbnl9ICAgICAgIGRlc2NyaXB0b3IudmFsdWUgICAgICAgICAgICAgICAgLSBUaGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIGNvbmZpZyAobm90IHNldCBieSB0aGlzIG1ldGhvZCkuXG4gICAgICovXG4gICAgaW5pdERlc2NyaXB0b3Ioe2Nsb25lLCBjbG9uZU9uR2V0LCBpc0VxdWFsLCBtZXJnZX0pIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoY2xvbmUgJiYgY2xvbmUgIT09IG1lLmNsb25lKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWUsICdjbG9uZScsIHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiBjbG9uZSwgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2xvbmVPbkdldCAmJiBjbG9uZU9uR2V0ICE9PSBtZS5jbG9uZU9uR2V0KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWUsICdjbG9uZU9uR2V0Jywge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IGNsb25lT25HZXQsIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRXF1YWwgJiYgaXNFcXVhbCAhPT0gbWUuaXNFcXVhbCkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1lLCAnaXNFcXVhbCcsIHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiBpc0VxdWFsLCB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZXJnZSAmJiBtZXJnZSAhPT0gbWUubWVyZ2VTdHJhdGVneSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1lLCAnbWVyZ2VTdHJhdGVneScsIHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiBtZXJnZSwgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb3RpZmllcyBhbGwgc3Vic2NyaWJlZCBjYWxsYmFja3MgYWJvdXQgYSBjaGFuZ2UgaW4gdGhlIGNvbmZpZydzIHZhbHVlLlxuICAgICAqIEl0IGl0ZXJhdGVzIHRocm91Z2ggdGhlIG5lc3RlZCBzdWJzY3JpYmVyIHN0cnVjdHVyZSB0byBlbnN1cmUgZWFjaCBjYWxsYmFja1xuICAgICAqIGlzIGV4ZWN1dGVkIHdpdGggaXRzIGludGVuZGVkIHNjb3BlLlxuICAgICAqIEBwYXJhbSB7YW55fSBuZXdWYWx1ZSAtIFRoZSBuZXcgdmFsdWUgb2YgdGhlIGNvbmZpZy5cbiAgICAgKiBAcGFyYW0ge2FueX0gb2xkVmFsdWUgLSBUaGUgb2xkIHZhbHVlIG9mIHRoZSBjb25maWcuXG4gICAgICovXG4gICAgbm90aWZ5KG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIGluIHRoaXMuI3N1YnNjcmliZXJzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jc3Vic2NyaWJlcnMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3Vic2NyaWJlck1hcCA9IHRoaXMuI3N1YnNjcmliZXJzW2lkXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtmbiwgc2NvcGVTZXRdIG9mIHN1YnNjcmliZXJNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzY29wZSBvZiBzY29wZVNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm4uY2FsbChzY29wZSB8fCBudWxsLCBuZXdWYWx1ZSwgb2xkVmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbmV3IHZhbHVlIGZvciB0aGUgY29uZmlnIHByb3BlcnR5LlxuICAgICAqIFRoaXMgbWV0aG9kIHBlcmZvcm1zIGFuIGVxdWFsaXR5IGNoZWNrIHVzaW5nIGB0aGlzLmlzRXF1YWxgIGJlZm9yZSB1cGRhdGluZyB0aGUgdmFsdWUuXG4gICAgICogSWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkLCBpdCB1cGRhdGVzIGAjdmFsdWVgIGFuZCBub3RpZmllcyBhbGwgc3Vic2NyaWJlcnMuXG4gICAgICogQHBhcmFtIHthbnl9IG5ld1ZhbHVlIC0gVGhlIG5ldyB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGNoYW5nZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZXQobmV3VmFsdWUpIHtcbiAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBmYWxzZTsgLy8gUHJlc2VydmUgb3JpZ2luYWwgYmVoYXZpb3IgZm9yIHVuZGVmaW5lZFxuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBvbGRWYWx1ZSA9IG1lLiN2YWx1ZTtcblxuICAgICAgICAvLyBUaGUgc2V0dGVyIGF1dG9tYXRpY2FsbHkgdXNlcyB0aGUgY29uZmlndXJlZCBlcXVhbGl0eSBjaGVja1xuICAgICAgICBpZiAoIW1lLmlzRXF1YWwobmV3VmFsdWUsIG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgbWUuI3ZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICBtZS5ub3RpZnkobmV3VmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBpbnRlcm5hbCB2YWx1ZSBvZiB0aGUgY29uZmlnIHByb3BlcnR5IGRpcmVjdGx5LCB3aXRob3V0IHBlcmZvcm1pbmdcbiAgICAgKiBhbiBlcXVhbGl0eSBjaGVjayBvciBub3RpZnlpbmcgc3Vic2NyaWJlcnMuXG4gICAgICogVGhpcyBtZXRob2QgaXMgaW50ZW5kZWQgZm9yIGludGVybmFsIGZyYW1ld29yayB1c2Ugd2hlcmUgZGlyZWN0IGFzc2lnbm1lbnRcbiAgICAgKiBpcyBuZWNlc3NhcnkgKGUuZy4sIGR1cmluZyBpbml0aWFsIHNldHVwIG9yIHNwZWNpZmljIGludGVybmFsIG9wdGltaXphdGlvbnMpLlxuICAgICAqIEBwYXJhbSB7YW55fSBuZXdWYWx1ZSAtIFRoZSBuZXcgdmFsdWUgdG8gc2V0IGRpcmVjdGx5LlxuICAgICAqL1xuICAgIHNldFJhdyhuZXdWYWx1ZSkge1xuICAgICAgICB0aGlzLiN2YWx1ZSA9IG5ld1ZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlcyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGNoYW5nZXMgaW4gdGhpcyBjb25maWcncyB2YWx1ZS5cbiAgICAgKiBUaGUgY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkIHdpdGggYChuZXdWYWx1ZSwgb2xkVmFsdWUpYCB3aGVuZXZlciB0aGUgY29uZmlnIGNoYW5nZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgb3B0aW9ucyAgICAgICAgLSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgc3Vic2NyaXB0aW9uIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgb3B0aW9ucy5pZCAgICAgLSBUaGUgSUQgb2YgdGhlIHN1YnNjcmlwdGlvbiBvd25lciAoZS5nLiwgYSBOZW8uY29yZS5CYXNlIGluc3RhbmNlJ3MgaWQpLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMuZm4gICAgIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgW29wdGlvbnMuc2NvcGVdIC0gVGhlIHNjb3BlIHRvIGV4ZWN1dGUgdGhlIGNhbGxiYWNrIGluLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBjbGVhbnVwIGZ1bmN0aW9uIHRvIHVuc3Vic2NyaWJlIHRoZSBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBzdWJzY3JpYmUoe2lkLCBmbiwgc2NvcGV9KSB7XG4gICAgICAgIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnIHx8IGlkLmxlbmd0aCA9PT0gMCB8fCB0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihbXG4gICAgICAgICAgICAgICAgJ0NvbmZpZy5zdWJzY3JpYmU6IG9wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3Qgd2l0aCBhIG5vbi1lbXB0eSBzdHJpbmcgYGlkYCAnLFxuICAgICAgICAgICAgICAgICcodGhlIHN1YnNjcmlwdGlvbiBvd25lclxcJ3MgaWQpLCBhbmQgYSBjYWxsYmFjayBmdW5jdGlvbiBgZm5gLidcbiAgICAgICAgICAgIF0uam9pbignJykpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgLy8gR2V0IG9yIGNyZWF0ZSB0aGUgdG9wLWxldmVsIE1hcCBmb3IgdGhlIHN1YnNjcmlwdGlvbiBvd25lci5cbiAgICAgICAgaWYgKCFtZS4jc3Vic2NyaWJlcnNbaWRdKSB7XG4gICAgICAgICAgICBtZS4jc3Vic2NyaWJlcnNbaWRdID0gbmV3IE1hcCgpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdWJzY3JpYmVyTWFwID0gbWUuI3N1YnNjcmliZXJzW2lkXTtcblxuICAgICAgICAvLyBHZXQgb3IgY3JlYXRlIHRoZSBTZXQgb2Ygc2NvcGVzIGZvciB0aGUgc3BlY2lmaWMgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICAgIGlmICghc3Vic2NyaWJlck1hcC5oYXMoZm4pKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyTWFwLnNldChmbiwgbmV3IFNldCgpKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2NvcGVTZXQgPSBzdWJzY3JpYmVyTWFwLmdldChmbik7XG4gICAgICAgIHNjb3BlU2V0LmFkZChzY29wZSk7XG5cbiAgICAgICAgLy8gVGhlIHJldHVybmVkIGNsZWFudXAgZnVuY3Rpb24gaXMgcHJlY2lzZS4gSXQgcmVtb3ZlcyBvbmx5IHRoZSBzcGVjaWZpY1xuICAgICAgICAvLyBzY29wZSBmb3IgdGhlIGZ1bmN0aW9uLCBhbmQgY2xlYW5zIHVwIHRoZSBwYXJlbnQgZGF0YSBzdHJ1Y3R1cmVzXG4gICAgICAgIC8vICh0aGUgU2V0IGFuZCB0aGUgTWFwcykgb25seSBpZiB0aGV5IGJlY29tZSBlbXB0eS5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTdWJzY3JpYmVyTWFwID0gbWUuI3N1YnNjcmliZXJzW2lkXTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50U3Vic2NyaWJlck1hcCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTY29wZVNldCA9IGN1cnJlbnRTdWJzY3JpYmVyTWFwLmdldChmbik7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTY29wZVNldCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2NvcGVTZXQuZGVsZXRlKHNjb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTY29wZVNldC5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3Vic2NyaWJlck1hcC5kZWxldGUoZm4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTdWJzY3JpYmVyTWFwLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgbWUuI3N1YnNjcmliZXJzW2lkXVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDb25maWcucHJvdG90eXBlLCB7XG4gICAgY2xvbmUgICAgICAgIDoge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogZmFsc2UsIHZhbHVlOiAnZGVlcCcsICAgICAgd3JpdGFibGU6IGZhbHNlfSxcbiAgICBjbG9uZU9uR2V0ICAgOiB7Y29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiBmYWxzZSwgdmFsdWU6IG51bGwsICAgICAgICB3cml0YWJsZTogZmFsc2V9LFxuICAgIGlzRXF1YWwgICAgICA6IHtjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IGZhbHNlLCB2YWx1ZTogTmVvLmlzRXF1YWwsIHdyaXRhYmxlOiBmYWxzZX0sXG4gICAgbWVyZ2VTdHJhdGVneToge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogZmFsc2UsIHZhbHVlOiAncmVwbGFjZScsICAgd3JpdGFibGU6IGZhbHNlfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5nYXRla2VlcChDb25maWcsICdOZW8uY29yZS5Db25maWcnKTtcbiIsImV4cG9ydCBjb25zdCBpc0Rlc2NyaXB0b3IgPSBTeW1ib2wuZm9yKCdOZW8uQ29uZmlnLmlzRGVzY3JpcHRvcicpO1xuIiwiLyoqXG4gKiBBIHNpbmdsZXRvbiBtYW5hZ2VyIHRvIHRyYWNrIHRoZSBjdXJyZW50bHkgcnVubmluZyBlZmZlY3QgYW5kIGNvbnRyb2wgZ2xvYmFsIGVmZmVjdCBleGVjdXRpb24uXG4gKiBJdCBwcm92aWRlcyBhIGNlbnRyYWxpemVkIG1lY2hhbmlzbSBmb3IgcGF1c2luZywgcmVzdW1pbmcsIGFuZCBiYXRjaGluZyBlZmZlY3QgcnVucy5cbiAqIEBjbGFzcyBOZW8uY29yZS5FZmZlY3RNYW5hZ2VyXG4gKiBAc2luZ2xldG9uXG4gKi9cbmNvbnN0IEVmZmVjdE1hbmFnZXIgPSB7XG4gICAgLyoqXG4gICAgICogQSBzdGFjayB0byBrZWVwIHRyYWNrIG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIGVmZmVjdCBhbmQgaXRzIHByZWRlY2Vzc29ycy5cbiAgICAgKiBAbWVtYmVyIHtOZW8uY29yZS5FZmZlY3RbXX0gZWZmZWN0U3RhY2s9W11cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZWZmZWN0U3RhY2s6IFtdLFxuICAgIC8qKlxuICAgICAqIEEgZmxhZyB0byB0ZW1wb3JhcmlseSBkaXNhYmxlIGRlcGVuZGVuY3kgdHJhY2tpbmcgZm9yIHRoZSBhY3RpdmUgZWZmZWN0LlxuICAgICAqIFRoaXMgaXMgdXNlZCBpbnRlcm5hbGx5IHRvIHByZXZlbnQgZWZmZWN0cyBmcm9tIGRlcGVuZGluZyBvbiB0aGVpciBvd24gc3RhdGUsIGxpa2UgYGlzUnVubmluZ2AuXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNUcmFja2luZ1BhdXNlZD1mYWxzZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpc1RyYWNraW5nUGF1c2VkOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBBIGNvdW50ZXIgdG8gbWFuYWdlIG5lc3RlZCBjYWxscyB0byBwYXVzZSgpIGFuZCByZXN1bWUoKS4gRWZmZWN0IGV4ZWN1dGlvbiBpc1xuICAgICAqIHBhdXNlZCBvciBiYXRjaGVkIHdoaWxlIHRoaXMgY291bnRlciBpcyBncmVhdGVyIHRoYW4gMC5cbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHBhdXNlQ291bnRlcj0wXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHBhdXNlQ291bnRlcjogMCxcbiAgICAvKipcbiAgICAgKiBBIFNldCB0byBzdG9yZSB1bmlxdWUgZWZmZWN0cyB0aGF0IGFyZSB0cmlnZ2VyZWQgd2hpbGUgdGhlIG1hbmFnZXIgaXMgcGF1c2VkLlxuICAgICAqIFRoZXNlIGVmZmVjdHMgd2lsbCBiZSBydW4gd2hlbiByZXN1bWUoKSBpcyBjYWxsZWQgYW5kIHRoZSBwYXVzZUNvdW50ZXIgcmV0dXJucyB0byAwLlxuICAgICAqIEBtZW1iZXIge1NldDxOZW8uY29yZS5FZmZlY3Q+fSBxdWV1ZWRFZmZlY3RzPW5ldyBTZXQoKVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBxdWV1ZWRFZmZlY3RzOiBuZXcgU2V0KCksXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgYE5lby5jb3JlLkNvbmZpZ2AgaW5zdGFuY2UgYXMgYSBkZXBlbmRlbmN5IGZvciB0aGUgY3VycmVudGx5IGFjdGl2ZSBlZmZlY3QsXG4gICAgICogdW5sZXNzIGRlcGVuZGVuY3kgdHJhY2tpbmcgaXMgZXhwbGljaXRseSBwYXVzZWQuXG4gICAgICogQHBhcmFtIHtOZW8uY29yZS5Db25maWd9IGNvbmZpZyBUaGUgY29uZmlnIGluc3RhbmNlIHRvIGFkZCBhcyBhIGRlcGVuZGVuY3kuXG4gICAgICovXG4gICAgYWRkRGVwZW5kZW5jeShjb25maWcpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVHJhY2tpbmdQYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0QWN0aXZlRWZmZWN0KCk/LmFkZERlcGVuZGVuY3koY29uZmlnKVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGVmZmVjdCBjdXJyZW50bHkgYXQgdGhlIHRvcCBvZiB0aGUgc3RhY2sgKGkuZS4sIHRoZSBvbmUgY3VycmVudGx5IHJ1bm5pbmcpLlxuICAgICAqIEByZXR1cm5zIHtOZW8uY29yZS5FZmZlY3R8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRBY3RpdmVFZmZlY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVmZmVjdFN0YWNrW3RoaXMuZWZmZWN0U3RhY2subGVuZ3RoIC0gMV1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGVmZmVjdCBleGVjdXRpb24gaXMgY3VycmVudGx5IHBhdXNlZCBvciBiYXRjaGVkLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBwYXVzZUNvdW50ZXIgaXMgZ3JlYXRlciB0aGFuIDAuXG4gICAgICovXG4gICAgaXNQYXVzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhdXNlQ291bnRlciA+IDBcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGF1c2VzIGVmZmVjdCBleGVjdXRpb24gYW5kIGJlZ2lucyBiYXRjaGluZy5cbiAgICAgKiBFYWNoIGNhbGwgdG8gcGF1c2UoKSBpbmNyZW1lbnRzIGEgY291bnRlciwgYWxsb3dpbmcgZm9yIG5lc3RlZCBjb250cm9sLlxuICAgICAqL1xuICAgIHBhdXNlKCkge1xuICAgICAgICB0aGlzLnBhdXNlQ291bnRlcisrXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpc2FibGVzIGRlcGVuZGVuY3kgdHJhY2tpbmcgZm9yIHRoZSBjdXJyZW50bHkgYWN0aXZlIGVmZmVjdC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcGF1c2VUcmFja2luZygpIHtcbiAgICAgICAgdGhpcy5pc1RyYWNraW5nUGF1c2VkID0gdHJ1ZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQb3BzIHRoZSBjdXJyZW50IGVmZmVjdCBmcm9tIHRoZSBzdGFjay5cbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvcmUuRWZmZWN0fG51bGx9XG4gICAgICovXG4gICAgcG9wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lZmZlY3RTdGFjay5wb3AoKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYW4gZWZmZWN0IG9udG8gdGhlIHN0YWNrLlxuICAgICAqIEBwYXJhbSB7TmVvLmNvcmUuRWZmZWN0fSBlZmZlY3QgVGhlIGVmZmVjdCB0byBwdXNoLlxuICAgICAqL1xuICAgIHB1c2goZWZmZWN0KSB7XG4gICAgICAgIHRoaXMuZWZmZWN0U3RhY2sucHVzaChlZmZlY3QpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFF1ZXVlcyBhIHVuaXF1ZSBlZmZlY3QgdG8gYmUgcnVuIGxhdGVyLlxuICAgICAqIEBwYXJhbSB7TmVvLmNvcmUuRWZmZWN0fSBlZmZlY3QgVGhlIGVmZmVjdCB0byBxdWV1ZS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcXVldWUoZWZmZWN0KSB7XG4gICAgICAgIHRoaXMucXVldWVkRWZmZWN0cy5hZGQoZWZmZWN0KVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXN1bWVzIGVmZmVjdCBleGVjdXRpb24uIElmIHRoZSBwYXVzZSBjb3VudGVyIHJldHVybnMgdG8gemVybyBhbmQgZWZmZWN0c1xuICAgICAqIGhhdmUgYmVlbiBxdWV1ZWQsIHRoZXkgd2lsbCBhbGwgYmUgZXhlY3V0ZWQgc3luY2hyb25vdXNseS5cbiAgICAgKi9cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLnBhdXNlQ291bnRlciA+IDApIHtcbiAgICAgICAgICAgIG1lLnBhdXNlQ291bnRlci0tO1xuXG4gICAgICAgICAgICBpZiAobWUucGF1c2VDb3VudGVyID09PSAwICYmIG1lLnF1ZXVlZEVmZmVjdHMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlZmZlY3RzVG9SdW4gPSBbLi4ubWUucXVldWVkRWZmZWN0c107XG4gICAgICAgICAgICAgICAgbWUucXVldWVkRWZmZWN0cy5jbGVhcigpO1xuICAgICAgICAgICAgICAgIGVmZmVjdHNUb1J1bi5mb3JFYWNoKGVmZmVjdCA9PiBlZmZlY3QucnVuKCkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmUtZW5hYmxlcyBkZXBlbmRlbmN5IHRyYWNraW5nIGZvciB0aGUgY3VycmVudGx5IGFjdGl2ZSBlZmZlY3QuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHJlc3VtZVRyYWNraW5nKCkge1xuICAgICAgICB0aGlzLmlzVHJhY2tpbmdQYXVzZWQgPSBmYWxzZVxuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5nYXRla2VlcChFZmZlY3RNYW5hZ2VyLCAnTmVvLmNvcmUuRWZmZWN0TWFuYWdlcicsICgpID0+IHtcbiAgICAvKipcbiAgICAgKiBXcmFwcyBhIGZ1bmN0aW9uIGluIGEgYmF0Y2ggb3BlcmF0aW9uLCBlbnN1cmluZyB0aGF0IGFsbCBlZmZlY3RzIHRyaWdnZXJlZFxuICAgICAqIHdpdGhpbiBpdCBhcmUgcnVuIG9ubHkgb25jZSBhZnRlciB0aGUgZnVuY3Rpb24gY29tcGxldGVzLlxuICAgICAqIEBmdW5jdGlvbiBOZW8uYmF0Y2hcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gZXhlY3V0ZS5cbiAgICAgKi9cbiAgICBOZW8uYmF0Y2ggPSBmdW5jdGlvbihmbikge1xuICAgICAgICBFZmZlY3RNYW5hZ2VyLnBhdXNlKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmbigpXG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAvLyBUaGUgcHVibGljIHJlc3VtZSgpIG1ldGhvZCBoYW5kbGVzIHJ1bm5pbmcgcXVldWVkIGVmZmVjdHMuXG4gICAgICAgICAgICBFZmZlY3RNYW5hZ2VyLnJlc3VtZSgpXG4gICAgICAgIH1cbiAgICB9XG59KTtcbiIsIi8qKlxuICogUHJvdmlkZXMgYSBzaW5nbGV0b24gdXRpbGl0eSBmb3IgZ2VuZXJhdGluZyB1bmlxdWUgSURzLlxuICogQG5hbWVzcGFjZSBOZW8uY29yZS5JZEdlbmVyYXRvclxuICovXG5jb25zdCBJZEdlbmVyYXRvciA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBwcmVmaXggZm9yIG5lbyBpbnN0YW5jZSBpZHNcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGJhc2U9J25lby0nXG4gICAgICovXG4gICAgYmFzZTogJ25lby0nLFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gaWRDb3VudGVyPXt9XG4gICAgICovXG4gICAgaWRDb3VudGVyOiB7fSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBuYW1lXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRJZChuYW1lKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lIHx8ICduZW8nO1xuXG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvdW50ZXIgPSBtZS5pZENvdW50ZXIsXG4gICAgICAgICAgICBjb3VudCAgID0gY291bnRlcltuYW1lXSB8fCAwO1xuXG4gICAgICAgIGNvdW50ZXJbbmFtZV0gPSArK2NvdW50O1xuXG4gICAgICAgIHJldHVybiBtZS5iYXNlICsgKG5hbWUgPT09ICduZW8nID8gJycgOiBuYW1lICsgJy0nKSArIGNvdW50O1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLmdhdGVrZWVwKElkR2VuZXJhdG9yLCAnTmVvLmNvcmUuSWRHZW5lcmF0b3InLCAoKSA9PiB7XG4gICAgTmVvLmdldElkID0gSWRHZW5lcmF0b3IuZ2V0SWQuYmluZChJZEdlbmVyYXRvcik7XG59KTtcbiIsImltcG9ydCBCYXNlICAgICAgICAgICAgICBmcm9tICcuL0Jhc2UubWpzJztcbmltcG9ydCBOZW9BcnJheSAgICAgICAgICBmcm9tICcuLi91dGlsL0FycmF5Lm1qcyc7XG5pbXBvcnQge2lzRGVzY3JpcHRvcn0gICAgZnJvbSAnLi4vY29yZS9Db25maWdTeW1ib2xzLm1qcyc7XG5pbXBvcnQge3Jlc29sdmVDYWxsYmFja30gZnJvbSAnLi4vdXRpbC9GdW5jdGlvbi5tanMnO1xuXG4vKipcbiAqIEEgdW5pcXVlLCBub24tZW51bWVyYWJsZSBrZXkgZm9yIHRoZSBpbnRlcm5hbCBldmVudCBtYXAuXG4gKiBVc2luZyBhIFN5bWJvbCBwcmV2ZW50cyBwcm9wZXJ0eSBuYW1lIGNvbGxpc2lvbnMgb24gdGhlIGNvbnN1bWluZyBjbGFzcyBpbnN0YW5jZSxcbiAqIHByb3ZpZGluZyBhIHJvYnVzdCB3YXkgdG8gbWFuYWdlIHByaXZhdGUgc3RhdGUgd2l0aGluIGEgbWl4aW4uXG4gKiBAdHlwZSB7U3ltYm9sfVxuICovXG5jb25zdCBldmVudE1hcFN5bWJvbCA9IFN5bWJvbCgnZXZlbnRNYXAnKTtcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNvcmUuT2JzZXJ2YWJsZVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBPYnNlcnZhYmxlIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29yZS5PYnNlcnZhYmxlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29yZS5PYnNlcnZhYmxlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J21peGluLW9ic2VydmFibGUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnbWl4aW4tb2JzZXJ2YWJsZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGRlY2xhcmF0aXZlIHdheSB0byBhc3NpZ24gZXZlbnQgbGlzdGVuZXJzIHRvIGFuIGluc3RhbmNlIHVwb24gY3JlYXRpb24uXG4gICAgICAgICAqIFRoZSBmcmFtZXdvcmsgcHJvY2Vzc2VzIHRoaXMgY29uZmlnIGFuZCBjYWxscyBgb24oKWAgdG8gcG9wdWxhdGUgdGhlXG4gICAgICAgICAqIGludGVybmFsIGV2ZW50IHJlZ2lzdHJ5LiBUaGlzIGNvbmZpZyBzaG91bGQgbm90IGJlIG1hbmlwdWxhdGVkIGRpcmVjdGx5IGFmdGVyXG4gICAgICAgICAqIGluc3RhbnRpYXRpb247IHVzZSBgb24oKWAgYW5kIGB1bigpYCBpbnN0ZWFkLlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gbGlzdGVuZXJzX1xuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBsaXN0ZW5lcnM6IHtcbiAgICAgICAgICogICAgIG15RXZlbnQ6ICdvbk15RXZlbnQnLFxuICAgICAgICAgKiAgICAgb3RoZXJFdmVudDoge1xuICAgICAgICAgKiAgICAgICAgIGZuOiAnb25PdGhlckV2ZW50JyxcbiAgICAgICAgICogICAgICAgICBkZWxheTogMTAwLFxuICAgICAgICAgKiAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgICogICAgIH0sXG4gICAgICAgICAqICAgICBzY29wZTogdGhpc1xuICAgICAgICAgKiB9XG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdGVuZXJzXzoge1xuICAgICAgICAgICAgW2lzRGVzY3JpcHRvcl06IHRydWUsXG4gICAgICAgICAgICBtZXJnZSAgICAgICAgIDogJ2RlZXAnLFxuICAgICAgICAgICAgdmFsdWUgICAgICAgICA6IHt9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IFtldmVudE1hcFN5bWJvbF1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtldmVudElkXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZGF0YV1cbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IFtvcmRlcl1cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9IGV2ZW50SWQgbnVsbCBpbiBjYXNlIGFuIG9iamVjdCBnZXRzIHBhc3NlZCBhcyB0aGUgbmFtZSAobXVsdGlwbGUgaWRzKVxuICAgICAqL1xuICAgIGFkZExpc3RlbmVyKG5hbWUsIG9wdHMsIHNjb3BlLCBldmVudElkLCBkYXRhLCBvcmRlcikge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBkZWxheSAgICAgICAgID0gMCxcbiAgICAgICAgICAgIGV2ZW50SWRPYmplY3QgPSB0eXBlb2YgZXZlbnRJZCA9PT0gJ29iamVjdCcsXG4gICAgICAgICAgICBuYW1lT2JqZWN0ICAgID0gdHlwZW9mIG5hbWUgICAgPT09ICdvYmplY3QnLFxuICAgICAgICAgICAgb25jZSAgICAgICAgICA9IGZhbHNlLFxuICAgICAgICAgICAgb3B0c1R5cGUgICAgICA9IHR5cGVvZiBvcHRzLFxuICAgICAgICAgICAgbGlzdGVuZXIsIGV4aXN0aW5nLCBldmVudENvbmZpZztcblxuICAgICAgICAvKlxuICAgICAgICAgKiBsZXQgdXMgc3VwcG9ydCB0aGUgZm9sbG93aW5nIGZvcm1hdCB0b286XG4gICAgICAgICAqXG4gICAgICAgICAqIGN1cnJlbnRXb3JrZXIub24oJ2Nvbm5lY3RlZCcsICgpID0+IHtcbiAgICAgICAgICogICAgIEJhc2Uuc2VuZFJlbW90ZXMoY2xhc3NOYW1lLCByZW1vdGUpXG4gICAgICAgICAqIH0sIG1lLCB7b25jZTogdHJ1ZX0pXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoZXZlbnRJZE9iamVjdCAmJiBvcHRzVHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZXZlbnRJZC5mbiA9IG9wdHM7XG4gICAgICAgICAgICBvcHRzICAgICA9IGV2ZW50SWQ7XG4gICAgICAgICAgICBvcHRzVHlwZSA9ICdvYmplY3QnO1xuICAgICAgICAgICAgZXZlbnRJZCAgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5hbWVPYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChuYW1lLmhhc093blByb3BlcnR5KCdkZWxheScpKSB7XG4gICAgICAgICAgICAgICAgZGVsYXkgPSBuYW1lLmRlbGF5O1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBuYW1lLmRlbGF5XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuYW1lLmhhc093blByb3BlcnR5KCdvbmNlJykpIHtcbiAgICAgICAgICAgICAgICBvbmNlID0gbmFtZS5vbmNlO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBuYW1lLm9uY2VcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5hbWUuaGFzT3duUHJvcGVydHkoJ29yZGVyJykpIHtcbiAgICAgICAgICAgICAgICBvcmRlciA9IG5hbWUub3JkZXI7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5hbWUub3JkZXJcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5hbWUuaGFzT3duUHJvcGVydHkoJ3Njb3BlJykpIHtcbiAgICAgICAgICAgICAgICBzY29wZSA9IG5hbWUuc2NvcGU7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5hbWUuc2NvcGVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMobmFtZSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKE5lby5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuYWRkTGlzdGVuZXIoa2V5LCB7ZGVsYXksIG9uY2UsIG9yZGVyLCBzY29wZSwgLi4udmFsdWV9KVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmFkZExpc3RlbmVyKGtleSwge2RlbGF5LCBmbjogdmFsdWUsIG9uY2UsIG9yZGVyLCBzY29wZX0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIGlmIChvcHRzVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGRlbGF5ICAgID0gZGVsYXkgICB8fCBvcHRzLmRlbGF5O1xuICAgICAgICAgICAgZXZlbnRJZCAgPSBldmVudElkIHx8IG9wdHMuZXZlbnRJZDtcbiAgICAgICAgICAgIGxpc3RlbmVyID0gb3B0cy5mbjtcbiAgICAgICAgICAgIG9uY2UgICAgID0gb25jZSAgICB8fCBvcHRzLm9uY2U7XG4gICAgICAgICAgICBvcmRlciAgICA9IG9yZGVyICAgfHwgb3B0cy5vcmRlcjtcbiAgICAgICAgICAgIHNjb3BlICAgID0gc2NvcGUgICB8fCBvcHRzLnNjb3BlXG4gICAgICAgIH0gZWxzZSBpZiAob3B0c1R5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyID0gb3B0c1xuICAgICAgICB9IGVsc2UgaWYgKG9wdHNUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbGlzdGVuZXIgPSBvcHRzIC8vIFZDIGhvb2ssIGNhbiBnZXQgcGFyc2VkIGFmdGVyIG9uQ29uc3RydWN0ZWQgaW4gY2FzZSB0aGUgdmlldyB1c2VzIHRoZSBwYXJlbnQgVkNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZGRMaXN0ZW5lciBjYWxsOiAnICsgbmFtZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbmFtZU9iamVjdCkge1xuICAgICAgICAgICAgLy8gTEFaWSBJTklUSUFMSVpBVElPTjogVGhlIGtleSB0byBhIHJvYnVzdCBtaXhpbi5cbiAgICAgICAgICAgIC8vIFRoaXMgZW5zdXJlcyB0aGUgcHJpdmF0ZSBpbnRlcm5hbCBsaXN0ZW5lciBzdG9yZSBleGlzdHMgb24gdGhlIGluc3RhbmNlLlxuICAgICAgICAgICAgLy8gYGV2ZW50TWFwU3ltYm9sYCBpcyB0aGUgKmFjdHVhbCogcmVnaXN0cnkgb2YgaGFuZGxlciBhcnJheXMsIGFuZCBpc1xuICAgICAgICAgICAgLy8gaW50ZW50aW9uYWxseSBzZXBhcmF0ZSBmcm9tIHRoZSBwdWJsaWMgYGxpc3RlbmVyc19gIGNvbmZpZy5cbiAgICAgICAgICAgIG1lW2V2ZW50TWFwU3ltYm9sXSA/Pz0ge307XG5cbiAgICAgICAgICAgIGV2ZW50Q29uZmlnID0ge2ZuOiBsaXN0ZW5lciwgaWQ6IGV2ZW50SWQgfHwgTmVvLmdldElkKCdldmVudCcpfTtcblxuICAgICAgICAgICAgaWYgKGRhdGEpICAgICAge2V2ZW50Q29uZmlnLmRhdGEgICA9IGRhdGF9XG4gICAgICAgICAgICBpZiAoZGVsYXkgPiAwKSB7ZXZlbnRDb25maWcuZGVsYXkgID0gZGVsYXl9XG4gICAgICAgICAgICBpZiAob25jZSkgICAgICB7ZXZlbnRDb25maWcub25jZSAgID0gb25jZX1cbiAgICAgICAgICAgIGlmIChzY29wZSkgICAgIHtldmVudENvbmZpZy5zY29wZSAgPSBzY29wZX1cblxuICAgICAgICAgICAgaWYgKChleGlzdGluZyA9IG1lW2V2ZW50TWFwU3ltYm9sXVtuYW1lXSkpIHtcbiAgICAgICAgICAgICAgICBleGlzdGluZy5mb3JFYWNoKGNmZyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjZmcuaWQgPT09IGV2ZW50SWQgfHwgKGNmZy5mbiA9PT0gbGlzdGVuZXIgJiYgY2ZnLnNjb3BlID09PSBzY29wZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0R1cGxpY2F0ZSBldmVudCBoYW5kbGVyIGF0dGFjaGVkOicsIG5hbWUsIG1lKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9yZGVyID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5zcGxpY2Uob3JkZXIsIDAsIGV2ZW50Q29uZmlnKVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3JkZXIgPT09ICdiZWZvcmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLnVuc2hpZnQoZXZlbnRDb25maWcpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcucHVzaChldmVudENvbmZpZylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lW2V2ZW50TWFwU3ltYm9sXVtuYW1lXSA9IFtldmVudENvbmZpZ10gLy8gVXNlIHRoZSBwcml2YXRlIGV2ZW50TWFwU3ltYm9sIHJlZ2lzdHJ5XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBldmVudENvbmZpZy5pZFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGhvb2sgaXMgdGhlIGJyaWRnZSBiZXR3ZWVuIHRoZSBkZWNsYXJhdGl2ZSBgbGlzdGVuZXJzX2AgY29uZmlnIGFuZCB0aGVcbiAgICAgKiBpbXBlcmF0aXZlIGBvbigpYC9gdW4oKWAgbWV0aG9kcy4gSXQncyBjYWxsZWQgYXV0b21hdGljYWxseSBieSB0aGUgZnJhbWV3b3JrXG4gICAgICogd2hlbmV2ZXIgdGhlIGBsaXN0ZW5lcnNgIGNvbmZpZyBwcm9wZXJ0eSBpcyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBUaGUgbmV3IGxpc3RlbmVycyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2xkVmFsdWUgVGhlIG9sZCBsaXN0ZW5lcnMgb2JqZWN0XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TGlzdGVuZXJzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICAvLyBVbnJlZ2lzdGVyIGFueSBsaXN0ZW5lcnMgZnJvbSB0aGUgb2xkIGNvbmZpZyBvYmplY3RcbiAgICAgICAgaWYgKG9sZFZhbHVlICYmIE9iamVjdC5rZXlzKG9sZFZhbHVlKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnVuKG9sZFZhbHVlKVxuICAgICAgICB9XG4gICAgICAgIC8vIFJlZ2lzdGVyIGFsbCBsaXN0ZW5lcnMgZnJvbSB0aGUgbmV3IGNvbmZpZyBvYmplY3RcbiAgICAgICAgaWYgKHZhbHVlICYmIE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLm9uKHZhbHVlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbCB0aGUgcGFzc2VkIGZ1bmN0aW9uLCBvciBhIGZ1bmN0aW9uIGJ5ICpuYW1lKiB3aGljaCBleGlzdHMgaW4gdGhlIHBhc3NlZCBzY29wZSdzXG4gICAgICogb3IgdGhpcyBjb21wb25lbnQncyBvd25lcnNoaXAgY2hhaW4uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd9IGZuIEEgZnVuY3Rpb24sIG9yIHRoZSBuYW1lIG9mIGEgZnVuY3Rpb24gdG8gZmluZCBpbiB0aGUgcGFzc2VkIHNjb3BlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2NvcGUgICAgICAgVGhlIHNjb3BlIHRvIGZpbmQgdGhlIGZ1bmN0aW9uIGluIGlmIGl0IGlzIHNwZWNpZmllZCBhcyBhIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzICAgICAgICAgQXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIGNhbGxiYWNrKGZuLCBzY29wZT10aGlzLCBhcmdzKSB7XG4gICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IHJlc29sdmVDYWxsYmFjayhmbiwgc2NvcGUpO1xuICAgICAgICAgICAgaGFuZGxlci5mbi5hcHBseShoYW5kbGVyLnNjb3BlLCBhcmdzKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgaGVscGVyIG1ldGhvZCBmb3IgZXZlbnRzIHdoaWNoIHVzZSB0aGUgZGVsYXkgb3B0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNiXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJnc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVxuICAgICAqL1xuICAgIGRlbGF5ZWRDYWxsYmFjayhjYiwgYXJncywgZGVsYXkpIHtcbiAgICAgICAgdGhpcy50aW1lb3V0KGRlbGF5KS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGNiLmZuLmFwcGx5KGNiLnNjb3BlLCBhcmdzKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBuYW1lXG4gICAgICovXG4gICAgZmlyZShuYW1lKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgYXJncyAgICAgID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxuICAgICAgICAgICAgbGlzdGVuZXJzID0gbWVbZXZlbnRNYXBTeW1ib2xdLCAvLyBBbHdheXMgdXNlIHRoZSBwcml2YXRlLCBzdHJ1Y3R1cmVkIHJlZ2lzdHJ5IGZvciBmaXJpbmcgZXZlbnRzLlxuICAgICAgICAgICAgZGVsYXksIGhhbmRsZXIsIGhhbmRsZXJzLCBpLCBsZW47XG5cbiAgICAgICAgaWYgKGxpc3RlbmVycyAmJiBsaXN0ZW5lcnNbbmFtZV0pIHtcbiAgICAgICAgICAgIGhhbmRsZXJzID0gWy4uLmxpc3RlbmVyc1tuYW1lXV07XG4gICAgICAgICAgICBsZW4gICAgICA9IGhhbmRsZXJzLmxlbmd0aDtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlciA9IGhhbmRsZXJzW2ldO1xuICAgICAgICAgICAgICAgIGRlbGF5ICAgPSBoYW5kbGVyLmRlbGF5O1xuXG4gICAgICAgICAgICAgICAgLy8gUmVzb2x2ZSBmdW5jdGlvbiBuYW1lIG9uIHRoZSBzY29wZSAob3IgbWUpLCBvciwgaWYgaXQgc3RhcnRzIHdpdGggJ3VwLidcbiAgICAgICAgICAgICAgICAvLyBsb29rIGluIHRoZSBvd25lcnNoaXAgaGllcmFyY2h5IGZyb20gbWUuXG4gICAgICAgICAgICAgICAgY29uc3QgY2IgPSByZXNvbHZlQ2FsbGJhY2soaGFuZGxlci5mbiwgaGFuZGxlci5zY29wZSB8fCBtZSk7XG5cbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIGxpc3RlbmVyIGlmIHRoZSBzY29wZSBubyBsb25nZXIgZXhpc3RzXG4gICAgICAgICAgICAgICAgaWYgKGNiLnNjb3BlICYmICFjYi5zY29wZS5pZCkge1xuICAgICAgICAgICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUobGlzdGVuZXJzW25hbWVdLCBoYW5kbGVyKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWUuc3VzcGVuZEV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT2JqZWN0IGV2ZW50IGZvcm1hdC4gSW5qZWN0IGZpcmVyIHJlZmVyZW5jZSBpbiBhcyAnc291cmNlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmIE5lby5pc09iamVjdChhcmdzWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbMF0uc291cmNlID0gbWUuaWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBsaXN0ZW5lciBpZiBpdCBoYXMgdGhlIG9uY2UgZmxhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5vbmNlICYmIE5lb0FycmF5LnJlbW92ZShsaXN0ZW5lcnNbbmFtZV0sIGhhbmRsZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKGRlbGF5KSAmJiBkZWxheSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5kZWxheWVkQ2FsbGJhY2soY2IsIGhhbmRsZXIuZGF0YSA/IGFyZ3MuY29uY2F0KGhhbmRsZXIuZGF0YSkgOiBhcmdzLCBkZWxheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2IuZm4uYXBwbHkoY2Iuc2NvcGUsIGhhbmRsZXIuZGF0YSA/IGFyZ3MuY29uY2F0KGhhbmRsZXIuZGF0YSkgOiBhcmdzKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxpYXMgZm9yIGFkZExpc3RlbmVyXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtldmVudElkXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZGF0YV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29yZGVyXVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IGV2ZW50SWRcbiAgICAgKi9cbiAgICBvbiguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZExpc3RlbmVyKC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlcmUgYXJlIGRpZmZlcmVudCBzeW50YXgncyBob3cgeW91IGNhbiB1c2UgdGhpcyBtZXRob2QuXG4gICAgICogVXNpbmcgdGhlIGV2ZW50SWQ6XG4gICAgICogYGBgXG4gICAgICogdGhpcy5yZW1vdmVMaXN0ZW5lcignY2hhbmdlJywgJ25lby1ldmVudC03Jyk7XG4gICAgICogYGBgXG4gICAgICogUGFzc2luZyB0aGUgaGFuZGxlciBtZXRob2Q6XG4gICAgICogYGBgXG4gICAgICogdGhpcy5yZW1vdmVMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5vbkNoYW5nZSwgdGhpcyk7XG4gICAgICogYGBgXG4gICAgICogUGFzc2luZyBhbiBvYmplY3Q6XG4gICAgICogYGBgXG4gICAgICogbWUuZmllbGQudW4oe1xuICAgICAqICAgICBjaGFuZ2UgICAgICAgICAgICAgICAgICAgIDogbWUub25GaWVsZENoYW5nZSxcbiAgICAgKiAgICAgY2hhbmdlQ2xlYXJUb09yaWdpbmFsVmFsdWU6IG1lLm9uRmllbGRDaGFuZ2UsXG4gICAgICogICAgIHNjb3BlICAgICAgICAgICAgICAgICAgICAgOiBtZVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBbZXZlbnRJZF1cbiAgICAgKiBAcGFyYW0ge05lby5jb3JlLkJhc2V9IFtzY29wZV1cbiAgICAgKi9cbiAgICByZW1vdmVMaXN0ZW5lcihuYW1lLCBldmVudElkLCBzY29wZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgaSwgbGVuLCBsaXN0ZW5lciwgbGlzdGVuZXJzLCBtYXRjaDtcblxuICAgICAgICAvLyBMQVpZIElOSVRJQUxJWkFUSU9OOiBFbnN1cmUgdGhlIGludGVybmFsIGxpc3RlbmVyIHN0b3JlIGV4aXN0cy5cbiAgICAgICAgbWVbZXZlbnRNYXBTeW1ib2xdID8/PSB7fTtcblxuICAgICAgICBpZiAoTmVvLmlzRnVuY3Rpb24oZXZlbnRJZCkpIHtcbiAgICAgICAgICAgIG1lLnJlbW92ZUxpc3RlbmVyKHtbbmFtZV06IGV2ZW50SWQsIHNjb3BlfSk7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChOZW8uaXNPYmplY3QobmFtZSkpIHtcbiAgICAgICAgICAgIGlmIChuYW1lLnNjb3BlKSB7XG4gICAgICAgICAgICAgICAgc2NvcGUgPSBuYW1lLnNjb3BlO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBuYW1lLnNjb3BlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhuYW1lKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMgPSBtZVtldmVudE1hcFN5bWJvbF1ba2V5XSB8fCBbXTtcbiAgICAgICAgICAgICAgICBpICAgICAgICAgPSAwO1xuICAgICAgICAgICAgICAgIGxlbiAgICAgICA9IGxpc3RlbmVycy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXJzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmZuLm5hbWUgPT09IChOZW8uaXNTdHJpbmcodmFsdWUpID8gdmFsdWUgOiB2YWx1ZS5uYW1lKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIuc2NvcGUgICA9PT0gc2NvcGVcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSBpZiAoTmVvLmlzU3RyaW5nKGV2ZW50SWQpKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMgPSBtZVtldmVudE1hcFN5bWJvbF1bbmFtZV07XG4gICAgICAgICAgICBtYXRjaCAgICAgPSBmYWxzZTtcblxuICAgICAgICAgICAgbGlzdGVuZXJzLmZvckVhY2goKGV2ZW50Q29uZmlnLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRDb25maWcuaWQgPT09IGV2ZW50SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoID0gaWR4XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChtYXRjaCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKG1hdGNoLCAxKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxpYXMgZm9yIHJlbW92ZUxpc3RlbmVyXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtldmVudElkXVxuICAgICAqL1xuICAgIHVuKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lciguLi5hcmdzKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKE9ic2VydmFibGUpO1xuIiwiLyoqXG4gKiBAY2xhc3MgTmVvLmNvcmUuVXRpbFxuICovXG5jbGFzcyBVdGlsIHtcbiAgICAvKipcbiAgICAgKiBBIHJlZ2V4IHRvIHJlbW92ZSBjYW1lbCBjYXNlIHN5bnRheFxuICAgICAqIEBtZW1iZXIge1JlZ0V4cH0gZGVjYW1lbFJlZ0V4PS8oW2Etel0pKFtBLVpdKS9nXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgZGVjYW1lbFJlZ0V4ID0gLyhbYS16XSkoW0EtWl0pL2dcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IHZhbHVlc1xuICAgICAqL1xuICAgIHN0YXRpYyBiaW5kTWV0aG9kcyhzY29wZSwgdmFsdWVzKSB7XG4gICAgICAgIHZhbHVlcy5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICAgICAgICAgIHNjb3BlW3ZhbHVlXSA9IHNjb3BlW3ZhbHVlXS5iaW5kKHNjb3BlKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgYSBzdHlsZXMgc3RyaW5nIGludG8gYSBzdHlsZXMgb2JqZWN0IHVzaW5nIGNhbWVsY2FzZSBzeW50YXhcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBzdHlsZXMgc3RyaW5nIHRvIHBhcnNlXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIGNhbWVsY2FzZSBzdHlsZXMgb2JqZWN0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVN0eWxlT2JqZWN0KHN0cmluZykge1xuICAgICAgICBsZXQgcGFydHM7XG5cbiAgICAgICAgLy8gc3BsaXQoJzsnKSBkb2VzIGZldGNoIHNlbWljb2xvbnMgaW5zaWRlIGJyYWNrZXRzXG4gICAgICAgIC8vIC0+IGJhY2tncm91bmQtaW1hZ2U6IFwidXJsKCdkYXRhOmltYWdlL3BuZztiYXNlNjQsLi4uXG5cbiAgICAgICAgLy8gVE9ETzogQ2FjaGUgYWxsIHJlZ2V4XG4gICAgICAgIHJldHVybiBzdHJpbmcuc3BsaXQoLzsoPz1bXlxcKV0qKD86XFwofCQpKS9nKS5yZWR1Y2UoKG9iaiwgZWwpID0+IHtcbiAgICAgICAgICAgIC8vIHdlIGhhdmUgdG8gc3BsaXQgYnkgdGhlIGZpcnN0IGNvbG9uIG9ubHlcbiAgICAgICAgICAgIC8vIC0+IGJhY2tncm91bmQtaW1hZ2U6IHVybCgnaHR0cDovL2V4YW1wbGUuY29tL2ltYWdlLnBuZycpXG4gICAgICAgICAgICBwYXJ0cyA9IGVsLnNwbGl0KCgvOiguKykvKSkubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgbGV0IG51bSA9IHBhcnNlRmxvYXQoeCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4geCA9PSBudW0gPyBudW0gOiB4LnRyaW0oKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChwYXJ0c1swXSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICBwYXJ0c1swXSA9IHBhcnRzWzBdLnJlcGxhY2UoLy0oW2Etel0pL2csIChzdHIsIGxldHRlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKClcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIG9ialtwYXJ0c1swXV0gPSBwYXJ0c1sxXVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9ialxuICAgICAgICB9LCB7fSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIHN0eWxlcyBvYmplY3Qgd2hpY2ggY2FuIHVzZSBjYW1lbGNhc2Ugc3ludGF4IGludG8gYSBzdHlsZXMgc3RyaW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlcyBUaGUgc3R5bGVzIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBzdHlsZXMgc3RyaW5nIChET00gcmVhZHkpXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVN0eWxlcyhzdHlsZXMpIHtcbiAgICAgICAgbGV0IHN0eWxlID0gJyc7XG5cbiAgICAgICAgT2JqZWN0LmVudHJpZXMoc3R5bGVzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUgKz0gVXRpbC5kZWNhbWVsKGtleSkgKyAnOicgKyB2YWx1ZSArICc7J1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc3R5bGVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGFsbCB1cHBlcmNhc2UgY2hhcmFjdGVycyBvZiBhIHN0cmluZyBpbnRvIC1sb3dlcmNhc2UuXG4gICAgICogRG9lcyBub3QgdG91Y2ggc3BlY2lhbCBjaGFyYWN0ZXJzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBUaGUgaW5wdXQgY29udGFpbmluZyB1cHBlcmNhc2UgY2hhcmFjdGVyc1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBsb3dlcmNhc2Ugb3V0cHV0XG4gICAgICovXG4gICAgc3RhdGljIGRlY2FtZWwodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoVXRpbC5kZWNhbWVsUmVnRXgsICckMS0kMicpLnRvTG93ZXJDYXNlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhbiBhcnJheVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpc0FycmF5KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGEgYm9vbGVhblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgbm90IHVuZGVmaW5lZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpc0RlZmluZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhbiBlbXB0eSBBcnJheSwgT2JqZWN0IG9yIFN0cmluZ1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fFN0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHRvIHRlc3RcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNFbXB0eSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA9PT0gMFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoVXRpbC5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID09PSAwXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoVXRpbC5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gJydcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGEgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbidcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhIG51bWJlci4gUmV0dXJucyBmYWxzZSBmb3Igbm9uLWZpbml0ZSBudW1iZXJzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGlzTnVtYmVyKHZhbHVlKXtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZT8uY29uc3RydWN0b3I/Lm5hbWUgPT09ICdPYmplY3QnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYSBwcm9taXNlLlxuICAgICAqIFdlIGFyZSBpbnRlbnRpb25hbGx5IG5vdCBjaGVja2luZyBmb3IgYHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZWAsXG4gICAgICogdG8gc3VwcG9ydCBhbnkgXCJ0aGVuYWJsZVwiIG9iamVjdHMgZm9yIGZsZXhpYmlsaXR5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpc1Byb21pc2UodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZT8udGhlbiA9PT0gJ2Z1bmN0aW9uJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGEgbmVvIGRhdGEgcmVjb3JkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGlzUmVjb3JkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZT8uY29uc3RydWN0b3I/Lm5hbWUgPT09ICdSZWNvcmQnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHRvIHRlc3RcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZydcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbnkgaXRlcmFibGUgKHN0cmluZ3MsIG51bWVyaWMgaW5kaWNlcyBhbmQgYSBsZW5ndGggcHJvcGVydHkpIGludG8gYSB0cnVlIGFycmF5XG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBpdGVyYWJsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnQ9MF0gc3RhcnQgaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2VuZD1pdGVyYWJsZS5sZW5ndGhdIGVuZCBpbmRleFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBzdGF0aWMgdG9BcnJheShpdGVyYWJsZSwgc3RhcnQsIGVuZCkge1xuICAgICAgICBsZXQgbGVuO1xuXG4gICAgICAgIGlmICghaXRlcmFibGUgfHwgIShsZW4gPSBpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gW11cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlcmFibGUuc3BsaXQoJycpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaXRlcmFibGUsIHN0YXJ0IHx8IDAsIGVuZCB8fCBsZW4pXG4gICAgfVxufVxuXG5jb25zdCBucyA9IE5lby5ucygnTmVvLmNvcmUnLCB0cnVlKTtcbm5zLlV0aWwgPSBVdGlsO1xuXG4vLyBhbGlhc2VzXG5OZW8uYXBwbHlGcm9tTnMoTmVvLCBVdGlsLCB7XG4gICAgYmluZE1ldGhvZHMgICAgICA6ICdiaW5kTWV0aG9kcycsXG4gICAgY3JlYXRlU3R5bGVPYmplY3Q6ICdjcmVhdGVTdHlsZU9iamVjdCcsXG4gICAgY3JlYXRlU3R5bGVzICAgICA6ICdjcmVhdGVTdHlsZXMnLFxuICAgIGRlY2FtZWwgICAgICAgICAgOiAnZGVjYW1lbCcsXG4gICAgaXNBcnJheSAgICAgICAgICA6ICdpc0FycmF5JyxcbiAgICBpc0Jvb2xlYW4gICAgICAgIDogJ2lzQm9vbGVhbicsXG4gICAgaXNEZWZpbmVkICAgICAgICA6ICdpc0RlZmluZWQnLFxuICAgIGlzRW1wdHkgICAgICAgICAgOiAnaXNFbXB0eScsXG4gICAgaXNGdW5jdGlvbiAgICAgICA6ICdpc0Z1bmN0aW9uJyxcbiAgICBpc051bWJlciAgICAgICAgIDogJ2lzTnVtYmVyJyxcbiAgICBpc09iamVjdCAgICAgICAgIDogJ2lzT2JqZWN0JyxcbiAgICBpc1Byb21pc2UgICAgICAgIDogJ2lzUHJvbWlzZScsXG4gICAgaXNSZWNvcmQgICAgICAgICA6ICdpc1JlY29yZCcsXG4gICAgaXNTdHJpbmcgICAgICAgICA6ICdpc1N0cmluZycsXG4gICAgdG9BcnJheSAgICAgICAgICA6ICd0b0FycmF5J1xufSwgdHJ1ZSk7XG5cbmV4cG9ydCBkZWZhdWx0IFV0aWw7XG4iLCJpbXBvcnQgQmFzZSAgICAgICAgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQgQ29tcGFyZSAgICAgZnJvbSAnLi9Db21wYXJlLm1qcyc7XG5pbXBvcnQgSWRHZW5lcmF0b3IgZnJvbSAnLi9JZEdlbmVyYXRvci5tanMnO1xuaW1wb3J0IE9ic2VydmFibGUgIGZyb20gJy4vT2JzZXJ2YWJsZS5tanMnO1xuaW1wb3J0IFV0aWwgICAgICAgIGZyb20gJy4vVXRpbC5tanMnO1xuXG5leHBvcnQge0Jhc2UsIENvbXBhcmUsIElkR2VuZXJhdG9yLCBPYnNlcnZhYmxlLCBVdGlsfTtcbiIsImltcG9ydCBDb2xsZWN0aW9uIGZyb20gJy4uL2NvbGxlY3Rpb24vQmFzZS5tanMnO1xuXG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIHRoZSBvdGhlciBtYW5hZ2VyIGNsYXNzZXNcbiAqIEBjbGFzcyBOZW8ubWFuYWdlci5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29sbGVjdGlvbi5CYXNlXG4gKi9cbmNsYXNzIE1hbmFnZXIgZXh0ZW5kcyBDb2xsZWN0aW9ue1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLm1hbmFnZXIuQmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLm1hbmFnZXIuQmFzZSdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGlkXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRCeUlkKGlkKSB7XG4gICAgICAgIHJldHVybiBpZCAmJiB0aGlzLmdldChpZCkgfHwgbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG4gICAgICovXG4gICAgcmVnaXN0ZXIoaXRlbSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5nZXQoaXRlbS5pZCkpIHtcbiAgICAgICAgICAgIE5lby5sb2dFcnJvcignVHJ5aW5nIHRvIGNyZWF0ZSBhbiBpdGVtIHdpdGggYW4gYWxyZWFkeSBleGlzdGluZyBpZCcsIGl0ZW0sIG1lLmdldChpdGVtLmlkKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLnB1c2goaXRlbSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBjb2xsZWN0aW9uIGl0ZW0gcGFzc2VkIGJ5IHJlZmVyZW5jZSBvciBrZXlcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGl0ZW1cbiAgICAgKi9cbiAgICB1bnJlZ2lzdGVyKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoaXRlbSlcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKE1hbmFnZXIpO1xuIiwiaW1wb3J0IEJhc2VNYW5hZ2VyIGZyb20gJy4vQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8ubWFuYWdlci5DbGFzc0hpZXJhcmNoeVxuICogQGV4dGVuZHMgTmVvLm1hbmFnZXIuQmFzZVxuICogQHNpbmdsZXRvblxuICpcbiAqIFRoaXMgbWFuYWdlciBtYWludGFpbnMgYSByZWdpc3RyeSBvZiBhbGwgY2xhc3NlcyBkZWZpbmVkIHdpdGhpbiB0aGUgTmVvLm1qcyBmcmFtZXdvcmsncyBjdXJyZW50IHJlYWxtIChtYWluIG9yIHdvcmtlciksXG4gKiBpbmNsdWRpbmcgdGhlaXIgaW5oZXJpdGFuY2UgcmVsYXRpb25zaGlwcyBhbmQga2V5IG1ldGFkYXRhLlxuICogRWFjaCByZWdpc3RlcmVkIGl0ZW0gKHZhbHVlIGluIHRoZSBtYW5hZ2VyJ3Mgc3RvcmUpIGhhcyB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZTpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENsYXNzSGllcmFyY2h5SW5mb1xuICogQHByb3BlcnR5IHtTdHJpbmd9IGNsYXNzTmFtZSAtIFRoZSBmdWxsIE5lby5tanMgY2xhc3MgbmFtZSAoZS5nLiwgJ05lby5jb21wb25lbnQuQmFzZScpLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbnxPYmplY3R9IG1vZHVsZSAtIFRoZSBkaXJlY3QgcmVmZXJlbmNlIHRvIHRoZSBjbGFzcyBjb25zdHJ1Y3RvciBmdW5jdGlvbiBpdHNlbGYgKGZvciBub24tc2luZ2xldG9ucylcbiAqIG9yIHRoZSBpbnN0YW50aWF0ZWQgc2luZ2xldG9uIG9iamVjdCAoZm9yIHNpbmdsZXRvbnMpLlxuICogQHByb3BlcnR5IHtTdHJpbmd8bnVsbH0gbnR5cGUgLSBUaGUgbnR5cGUgb2YgdGhlIGNsYXNzIGlmIGRlZmluZWQgKGUuZy4sICdidXR0b24nLCAnY29udGFpbmVyJyksIG90aGVyd2lzZSBgbnVsbGAuXG4gKiBAcHJvcGVydHkge1N0cmluZ3xudWxsfSBwYXJlbnRDbGFzc05hbWUgLSBUaGUgZnVsbCBjbGFzcyBuYW1lIG9mIGl0cyBkaXJlY3QgcGFyZW50IGNsYXNzLFxuICogb3IgYG51bGxgIGlmIGl0J3MgYSB0b3AtbGV2ZWwgY2xhc3MgKGUuZy4sICdOZW8uY29yZS5CYXNlJykuXG4gKi9cbmNsYXNzIENsYXNzSGllcmFyY2h5IGV4dGVuZHMgQmFzZU1hbmFnZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLm1hbmFnZXIuQ2xhc3NIaWVyYXJjaHknXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5tYW5hZ2VyLkNsYXNzSGllcmFyY2h5JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30ga2V5UHJvcGVydHk9J2NsYXNzTmFtZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAga2V5UHJvcGVydHk6ICdjbGFzc05hbWUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2luZ2xldG9uPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2luZ2xldG9uOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVtb2l6ZXMgdGhlIHJldHVybiB2YWx1ZXMgb2YgaXNBKCkgY2FsbHNcbiAgICAgKiBAbWVtYmVyIHtNYXB9IGlzQVF1ZXJ5TWFwPW5ldyBNYXAoKVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpc0FRdWVyeU1hcCA9IG5ldyBNYXAoKVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG4gICAgICAgIHRoaXMuY29uc3VtZVRlbXBNYXAoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGFsbCBjbGFzc2VzIHRoYXQgZ290IGFwcGxpZWQgdG8gdGhlIE5lbyBuYW1lc3BhY2UgYmVmb3JlIHRoaXMgaW5zdGFuY2UgZ290IGNyZWF0ZWRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY29uc3VtZVRlbXBNYXAoKSB7XG4gICAgICAgIGlmIChOZW8uY2xhc3NIaWVyYXJjaHlNYXApIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKE9iamVjdC52YWx1ZXMoTmVvLmNsYXNzSGllcmFyY2h5TWFwKSk7XG4gICAgICAgICAgICBkZWxldGUgTmVvLmNsYXNzSGllcmFyY2h5TWFwXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCb3RoIHBhcmFtcyByZXByZXNlbnQgY2xhc3NOYW1lcy5cbiAgICAgKlxuICAgICAqIEV4YW1wbGUgdXNlIGNhc2VzOlxuICAgICAqIC0gaXNBKCdOZW8uYnV0dG9uLk1lbnUnLCAgICAnTmVvLmJ1dHRvbi5CYXNlJykgICAgPT4gdHJ1ZVxuICAgICAqIC0gaXNBKCdOZW8uYnV0dG9uLkJhc2UnLCAgICAnTmVvLmJ1dHRvbi5NZW51JykgICAgPT4gZmFsc2VcbiAgICAgKiAtIGlzQSgnTmVvLmJ1dHRvbi5CYXNlJywgICAgJ05lby5jb21wb25lbnQuQmFzZScpID0+IHRydWVcbiAgICAgKiAtIGlzQSgnTmVvLmNvbXBvbmVudC5CYXNlJywgJ05lby5jb3JlLkJhc2UnKSAgICAgID0+IHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVzY2VuZGFudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhbmNlc3RvclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzQShkZXNjZW5kYW50LCBhbmNlc3Rvcikge1xuICAgICAgICBpZiAoZGVzY2VuZGFudCA9PT0gYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcGFyZW50ICAgICAgICA9IGRlc2NlbmRhbnQsXG4gICAgICAgICAgICB7aXNBUXVlcnlNYXB9ID0gdGhpcyxcbiAgICAgICAgICAgIHF1ZXJ5TmFtZSAgICAgPSBgJHtkZXNjZW5kYW50fSwke2FuY2VzdG9yfWAsXG4gICAgICAgICAgICByZXR1cm5WYWx1ZSAgID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGlzQVF1ZXJ5TWFwLmhhcyhxdWVyeU5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNBUXVlcnlNYXAuZ2V0KHF1ZXJ5TmFtZSlcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChwYXJlbnQgPSB0aGlzLmdldChwYXJlbnQpPy5wYXJlbnRDbGFzc05hbWUpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgPT09IGFuY2VzdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFzc3VtcHRpb246IGNvbXBvbmVudC5CYXNlIGRpcmVjdGx5IGV4dGVuZHMgY29yZS5CYXNlXG4gICAgICAgICAgICBpZiAocGFyZW50ID09PSAnTmVvLmNvbXBvbmVudC5CYXNlJyAmJiBhbmNlc3RvciAhPT0gJ05lby5jb3JlLkJhc2UnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFyZW50ID09PSAnTmVvLmNvcmUuQmFzZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpc0FRdWVyeU1hcC5zZXQocXVlcnlOYW1lLCByZXR1cm5WYWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhDbGFzc0hpZXJhcmNoeSk7XG4iLCJpbXBvcnQgTWFuYWdlciAgIGZyb20gJy4vQmFzZS5tanMnO1xuaW1wb3J0IFZEb21VdGlsICBmcm9tICcuLi91dGlsL1ZEb20ubWpzJztcbmltcG9ydCBWTm9kZVV0aWwgZnJvbSAnLi4vdXRpbC9WTm9kZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8ubWFuYWdlci5Db21wb25lbnRcbiAqIEBleHRlbmRzIE5lby5tYW5hZ2VyLkJhc2VcbiAqIEBzaW5nbGV0b25cbiAqL1xuY2xhc3MgQ29tcG9uZW50IGV4dGVuZHMgTWFuYWdlciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ubWFuYWdlci5Db21wb25lbnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5tYW5hZ2VyLkNvbXBvbmVudCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaW5nbGV0b249dHJ1ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzaW5nbGV0b246IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtNYXB9IHdyYXBwZXJOb2Rlcz1uZXcgTWFwKClcbiAgICAgKi9cbiAgICB3cmFwcGVyTm9kZXMgPSBuZXcgTWFwKClcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgTmVvLmZpcnN0ICAgICAgICA9IG1lLmdldEZpcnN0LmJpbmQobWUpOyAvLyBhbGlhc1xuICAgICAgICBOZW8uZ2V0Q29tcG9uZW50ID0gbWUuZ2V0ICAgICAuYmluZChtZSkgIC8vIGFsaWFzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmxhdHRlbnMgYSBnaXZlbiB2bm9kZSB0cmVlIGJ5IHJlcGxhY2luZyBjb21wb25lbnQgYmFzZWQgc3VidHJlZXMgd2l0aCBjb21wb25lbnRJZCBiYXNlZCByZWZlcmVuY2VzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZub2RlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG93bmVySWQgV2UgZG8gbm90IHdhbnQgdG8gcmVwbGFjZSB0aGUgb3duIGlkID0+IHdyYXBwZWQgaXRlbXNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGFkZFZub2RlQ29tcG9uZW50UmVmZXJlbmNlcyh2bm9kZSwgb3duZXJJZCkge1xuICAgICAgICB2bm9kZSA9IHsuLi52bm9kZX07IC8vIHNoYWxsb3cgY29weVxuXG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNoaWxkTm9kZXMgPSB2bm9kZT8uY2hpbGROb2RlcyA/IFsuLi52bm9kZS5jaGlsZE5vZGVzXSA6IFtdLFxuICAgICAgICAgICAgY2hpbGROb2RlSWQsIGNvbXBvbmVudCwgY29tcG9uZW50SWQsIHBhcmVudFJlZiwgcmVmZXJlbmNlTm9kZTtcblxuICAgICAgICB2bm9kZS5jaGlsZE5vZGVzID0gY2hpbGROb2RlcztcblxuICAgICAgICBjaGlsZE5vZGVzLmZvckVhY2goKGNoaWxkTm9kZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNoaWxkTm9kZUlkID0gY2hpbGROb2RlLmlkO1xuXG4gICAgICAgICAgICBpZiAoIWNoaWxkTm9kZS5jb21wb25lbnRJZCAmJiBjaGlsZE5vZGVJZCAhPT0gb3duZXJJZCkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudCA9IG1lLmdldChjaGlsZE5vZGVJZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzZWFyY2hpbmcgZm9yIHdyYXBwZWQgY29tcG9uZW50cyBhcyBhIGZhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudCA9IG1lLndyYXBwZXJOb2Rlcy5nZXQoY2hpbGROb2RlSWQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgcGFyZW50IGNvbXBvbmVudCByZWZlcmVuY2UgPT4gYXNzaWduIHRoZSB3cmFwcGVyIGlkXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRJZCA9IGNvbXBvbmVudC5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFJlZiAgID0gVkRvbVV0aWwuZmluZChjb21wb25lbnQucGFyZW50LnZkb20sIHtjb21wb25lbnRJZH0sIGZhbHNlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudFJlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFJlZi52ZG9tLmlkID0gY2hpbGROb2RlSWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50SWQgICA9IGNvbXBvbmVudC5pZDtcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlTm9kZSA9IHtjb21wb25lbnRJZH07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudElkICE9PSBjaGlsZE5vZGVJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlTm9kZS5pZCA9IGNoaWxkTm9kZUlkXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoaWxkTm9kZXNbaW5kZXhdID0gY29tcG9uZW50ID8gcmVmZXJlbmNlTm9kZSA6IG1lLmFkZFZub2RlQ29tcG9uZW50UmVmZXJlbmNlcyhjaGlsZE5vZGUsIG93bmVySWQpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB2bm9kZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGNvbXBvbmVudCB3aGljaCBtYXRjaGVzIHRoZSBjb25maWctc2VsZWN0b3IgbW92aW5nIGRvd24gdGhlIGNvbXBvbmVudCBpdGVtcyB0cmVlLlxuICAgICAqIFVzZSByZXR1cm5GaXJzdE1hdGNoPWZhbHNlIHRvIGdldCBhbiBhcnJheSBvZiBhbGwgbWF0Y2hpbmcgaXRlbXMgaW5zdGVhZC5cbiAgICAgKiBJZiBubyBtYXRjaCBpcyBmb3VuZCwgcmV0dXJucyBudWxsIGluIGNhc2UgcmV0dXJuRmlyc3RNYXRjaCA9PT0gdHJ1ZSwgb3RoZXJ3aXNlIGFuIGVtcHR5IEFycmF5LlxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfFN0cmluZ30gY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfG51bGx9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmV0dXJuRmlyc3RNYXRjaD10cnVlXG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZXxOZW8uY29tcG9uZW50LkJhc2VbXXxudWxsfVxuICAgICAqL1xuICAgIGRvd24oY29tcG9uZW50LCBjb25maWcsIHJldHVybkZpcnN0TWF0Y2g9dHJ1ZSkge1xuICAgICAgICBpZiAoTmVvLmlzU3RyaW5nKGNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudCA9IHRoaXMuZ2V0QnlJZChjb21wb25lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIG1hdGNoQXJyYXkgID0gW10sXG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IG51bGwsXG4gICAgICAgICAgICBpICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICByZXR1cm5BcnJheSA9IFtdLFxuICAgICAgICAgICAgY2hpbGRJdGVtcywgY29uZmlnQXJyYXksIGNvbmZpZ0xlbmd0aCwgbGVuO1xuXG4gICAgICAgIGlmIChOZW8uaXNTdHJpbmcoY29uZmlnKSkge1xuICAgICAgICAgICAgY29uZmlnID0ge1xuICAgICAgICAgICAgICAgIG50eXBlOiBjb25maWdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghY29uZmlnKSB7XG4gICAgICAgICAgICBjb25maWcgPSB7fVxuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnQXJyYXkgID0gT2JqZWN0LmVudHJpZXMoY29uZmlnKTtcbiAgICAgICAgY29uZmlnTGVuZ3RoID0gY29uZmlnQXJyYXkubGVuZ3RoO1xuXG4gICAgICAgIGNvbmZpZ0FycmF5LmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKChjb21wb25lbnRba2V5XSA9PT0gdmFsdWUpXG4gICAgICAgICAgICAgICAgfHwgKGtleSA9PT0gJ250eXBlJyAmJiBtZS5oYXNQcm90b3R5cGVQcm9wZXJ0eVZhbHVlKGNvbXBvbmVudCwga2V5LCB2YWx1ZSkpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1hdGNoQXJyYXkucHVzaCh0cnVlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobWF0Y2hBcnJheS5sZW5ndGggPT09IGNvbmZpZ0xlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHJldHVybkZpcnN0TWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcG9uZW50XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybkFycmF5LnB1c2goY29tcG9uZW50KVxuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGRJdGVtcyA9IG1lLmZpbmQoe3BhcmVudElkOiBjb21wb25lbnQuaWR9KTtcbiAgICAgICAgbGVuICAgICAgICA9IGNoaWxkSXRlbXMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gbWUuZG93bihjaGlsZEl0ZW1zW2ldLCBjb25maWcsIHJldHVybkZpcnN0TWF0Y2gpO1xuXG4gICAgICAgICAgICBpZiAocmV0dXJuRmlyc3RNYXRjaCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5WYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJldHVyblZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm5BcnJheS5wdXNoKC4uLnJldHVyblZhbHVlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldHVybkZpcnN0TWF0Y2ggPyBudWxsOiByZXR1cm5BcnJheVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IHBhdGhcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9IHRoZSBjb21wb25lbnQgaWQgaW4gY2FzZSB0aGVyZSBpcyBhIG1hdGNoXG4gICAgICovXG4gICAgZmluZFBhcmVudENvbXBvbmVudChwYXRoKSB7XG4gICAgICAgIGxldCBtZSAgPSB0aGlzLFxuICAgICAgICAgICAgaSAgID0gMCxcbiAgICAgICAgICAgIGxlbiA9IHBhdGg/Lmxlbmd0aCB8fCAwLFxuICAgICAgICAgICAgaWQ7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWQgPSBwYXRoW2ldO1xuXG4gICAgICAgICAgICBpZiAoaWQgJiYgbWUuaGFzKGlkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpZFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBvYmplY3QgYXNzb2NpYXRlZCB0byB0aGUga2V5LCBvciBudWxsIGlmIHRoZXJlIGlzIG5vbmUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgIFtpbmNsdWRlV3JhcHBlck5vZGVzPXRydWVdXG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZXxudWxsfVxuICAgICAqL1xuICAgIGdldChrZXksIGluY2x1ZGVXcmFwcGVyTm9kZXM9dHJ1ZSkge1xuICAgICAgICBpZiAoaW5jbHVkZVdyYXBwZXJOb2Rlcykge1xuICAgICAgICAgICAgbGV0IHdyYXBwZXJOb2RlID0gdGhpcy53cmFwcGVyTm9kZXMuZ2V0KGtleSk7XG5cbiAgICAgICAgICAgIGlmICh3cmFwcGVyTm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVyTm9kZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldChrZXkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgY2hpbGQgY29tcG9uZW50cyB3aGljaCBhcmUgcmVjdXJzaXZlbHkgbWF0Y2hlZCB2aWEgdGhlaXIgcGFyZW50SWRcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50XG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZVtdfSBjaGlsZENvbXBvbmVudHNcbiAgICAgKi9cbiAgICBnZXRDaGlsZENvbXBvbmVudHMoY29tcG9uZW50KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBkaXJlY3RDaGlsZHJlbiA9IG1lLmZpbmQoJ3BhcmVudElkJywgY29tcG9uZW50LmlkKSB8fCBbXSxcbiAgICAgICAgICAgIGNvbXBvbmVudHMgICAgID0gW10sXG4gICAgICAgICAgICBjaGlsZENvbXBvbmVudHM7XG5cbiAgICAgICAgZGlyZWN0Q2hpbGRyZW4uZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaChpdGVtKTtcblxuICAgICAgICAgICAgY2hpbGRDb21wb25lbnRzID0gbWUuZ2V0Q2hpbGRDb21wb25lbnRzKGl0ZW0pO1xuXG4gICAgICAgICAgICBjaGlsZENvbXBvbmVudHMgJiYgY29tcG9uZW50cy5wdXNoKC4uLmNoaWxkQ29tcG9uZW50cylcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0b2RvOiByZXBsYWNlIGFsbCBjYWxscyBvZiB0aGlzIG1ldGhvZCB0byBjYWxscyB1c2luZyB0aGUgdXRpbC5WTm9kZSBjbGFzc1xuICAgICAqIEdldCB0aGUgaWRzIG9mIGFsbCBjaGlsZCBub2RlcyBvZiB0aGUgZ2l2ZW4gdm5vZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdm5vZGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBjaGlsZElkcz1bXVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmdbXX0gY2hpbGRJZHNcbiAgICAgKi9cbiAgICBnZXRDaGlsZElkcyh2bm9kZSwgY2hpbGRJZHM9W10pIHtcbiAgICAgICAgcmV0dXJuIFZOb2RlVXRpbC5nZXRDaGlsZElkcyh2bm9kZSwgY2hpbGRJZHMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgY2hpbGQgY29tcG9uZW50cyBmb3VuZCBpbnNpZGUgdGhlIHZub2RlIHRyZWVcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50XG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZVtdfSBjaGlsZENvbXBvbmVudHNcbiAgICAgKi9cbiAgICBnZXRDaGlsZHJlbihjb21wb25lbnQpIHtcbiAgICAgICAgbGV0IGNoaWxkQ29tcG9uZW50cyA9IFtdLFxuICAgICAgICAgICAgY2hpbGROb2RlcyAgICAgID0gVk5vZGVVdGlsLmdldENoaWxkSWRzKGNvbXBvbmVudC52bm9kZSksXG4gICAgICAgICAgICBjaGlsZENvbXBvbmVudDtcblxuICAgICAgICBjaGlsZE5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICBjaGlsZENvbXBvbmVudCA9IHRoaXMuZ2V0KG5vZGUpO1xuXG4gICAgICAgICAgICBpZiAoY2hpbGRDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZENvbXBvbmVudHMucHVzaChjaGlsZENvbXBvbmVudClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkQ29tcG9uZW50c1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICEhIEZvciBkZWJ1Z2dpbmcgcHVycG9zZXMgb25seSAhIVxuICAgICAqXG4gICAgICogR2V0IHRoZSBmaXJzdCBjb21wb25lbnQgYmFzZWQgb24gdGhlIG50eXBlIG9yIG90aGVyIHByb3BlcnRpZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdHxBcnJheX0gY29tcG9uZW50RGVzY3JpcHRpb25cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJldHVybkZpcnN0TWF0Y2g9dHJ1ZVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbHxOZW8uY29tcG9uZW50LkJhc2VbXX1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgIC8vIGFzIFN0cmluZzogbnR5cGVbY29tbWEgc2VwYXJhdGVkIHByb3B0ZXJ0aWVzXVxuICAgICBOZW8uZmlyc3QoJ3Rvb2xiYXIgYnV0dG9uW3RleHQ9VHJ5IG1lLGljb249cGVvcGxlXScpXG4gICAgIC8vIGFzIE9iamVjdDogQWRkIHByb3BlcnRpZXMuIG50eXBlIGlzIG9wdGlvbmFsXG4gICAgIE5lby5maXJzdCh7XG4gICAgICAgICAgICAgICAgaWNvbjogJ3Blb3BsZSdcbiAgICAgICAgICAgIH0pXG4gICAgIC8vIGFzIEFycmF5OiBBbiBBcnJheSBvZiBPYmplY3RzLiBObyBTdHJpbmdzIGFsbG93ZWRcbiAgICAgTmVvLmZpcnN0KFt7XG4gICAgICAgICAgICAgICAgbnR5cGU6ICd0b29sYmFyJ1xuICAgICAgICAgICAgfSx7XG4gICAgICAgICAgICAgICAgbnR5cGU6ICdidXR0b24nLCB0ZXh0OiAnVHJ5IG1lJywgaWNvbjogJ3Blb3BsZVxuICAgICAgICAgICAgfV0pXG5cbiAgICAgKiBUaGUgcmV0dXJuRmlyc3RNYXRjaCBmbGFnIGFsbG93cyB0byByZXR1cm4gYWxsIGl0ZW1zIGFuZFxuICAgICAqIG5vdCBzdG9wIGFmdGVyIHRoZSBmaXJzdCByZXN1bHQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICBOZW8uZmlyc3QoJ2J1dHRvbicsIGZhbHNlKSAvLyA9PiBbQnV0dG9uLCBCdXR0b24sIEJ1dHRvbl1cbiAgICAgKi9cbiAgICBnZXRGaXJzdChjb21wb25lbnREZXNjcmlwdGlvbiwgcmV0dXJuRmlyc3RNYXRjaCA9IHRydWUpIHtcbiAgICAgICAgbGV0IG9iamVjdHMgPSBbXSxcbiAgICAgICAgICAgIGFwcCAgICAgPSBOZW8uYXBwc1tPYmplY3Qua2V5cyhOZW8uYXBwcylbMF1dLFxuICAgICAgICAgICAgcm9vdCAgICA9IGFwcC5tYWluVmlldztcblxuICAgICAgICAvKiBjcmVhdGUgYW4gYXJyYXkgb2Ygb2JqZWN0cyBmcm9tIHN0cmluZyAqL1xuICAgICAgICBpZiAoTmVvLmlzU3RyaW5nKGNvbXBvbmVudERlc2NyaXB0aW9uKSkge1xuICAgICAgICAgICAgY29uc3QgcmVnZXggPSAvKFxcdyopKFxcW1teXFxdXSpcXF0pfChcXHcqKS9nO1xuICAgICAgICAgICAgbGV0IG1hdGNoO1xuXG4gICAgICAgICAgICAvKiBnZW5lcmF0ZSBvYmplY3RzIHdoaWNoIGNvbnRhaW4gdGhlIGluZm9ybWF0aW9uICovXG4gICAgICAgICAgICB3aGlsZSAobWF0Y2ggPSByZWdleC5leGVjKGNvbXBvbmVudERlc2NyaXB0aW9uKSkge1xuICAgICAgICAgICAgICAgIGxldCBbLCBudHlwZSwgcGFpcnMsIG50eXBlT25seV0gPSBtYXRjaCwgb2JqO1xuXG4gICAgICAgICAgICAgICAgbnR5cGUgPSBudHlwZSB8fCBudHlwZU9ubHk7XG4gICAgICAgICAgICAgICAgb2JqID0ge250eXBlfTtcblxuICAgICAgICAgICAgICAgIGlmIChwYWlycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYWlyc1JlZ2V4ID0gL1xcWyguKj8pXFxdLyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGFpcnNNYXRjaCA9IHBhaXJzLm1hdGNoKHBhaXJzUmVnZXgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYWlyc01hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYWlycyA9IHBhaXJzTWF0Y2hbMV0uc3BsaXQoJywnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhaXJzLmZvckVhY2goKHBhaXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBwYWlyLnNwbGl0KCc9Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0gPSB2YWx1ZS5yZXBsYWNlKC9cIi9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9iamVjdHMucHVzaChvYmopO1xuXG4gICAgICAgICAgICAgICAgcmVnZXgubGFzdEluZGV4KytcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChOZW8uaXNPYmplY3QoY29tcG9uZW50RGVzY3JpcHRpb24pKXtcbiAgICAgICAgICAgIG9iamVjdHMucHVzaChjb21wb25lbnREZXNjcmlwdGlvbilcbiAgICAgICAgfSBlbHNlIGlmIChOZW8uaXNBcnJheShjb21wb25lbnREZXNjcmlwdGlvbikpIHtcbiAgICAgICAgICAgIG9iamVjdHMgPSBjb21wb25lbnREZXNjcmlwdGlvblxuICAgICAgICB9XG5cbiAgICAgICAgLyogZmluZCB0aGUgY29ycmVjdCBjaGlsZCB1c2luZyBkb3duKCkgKi9cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gb2JqZWN0cy5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAoYWNjKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gYWNjLmRvd24oa2V5LCByZXR1cm5GaXJzdE1hdGNoKTtcblxuICAgICAgICAgICAgICAgIGlmICghIWNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfSwgcm9vdCk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gQXJyYXkgY29udGFpbmluZyB0aGUgaWRzIG9mIGFsbCBwYXJlbnQgY29tcG9uZW50cyBmb3IgYSBnaXZlbiBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50XG4gICAgICogQHJldHVybnMge1N0cmluZ1tdfSBwYXJlbnRJZHNcbiAgICAgKi9cbiAgICBnZXRQYXJlbnRJZHMoY29tcG9uZW50KSB7XG4gICAgICAgIGxldCBwYXJlbnRJZHMgPSBbXTtcblxuICAgICAgICB3aGlsZSAoY29tcG9uZW50Py5wYXJlbnRJZCkge1xuICAgICAgICAgICAgY29tcG9uZW50ID0gdGhpcy5nZXQoY29tcG9uZW50LnBhcmVudElkKTtcblxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIHBhcmVudElkcy5wdXNoKGNvbXBvbmVudC5pZClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJlbnRJZHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIGdldFBhcmVudFBhdGgocGF0aCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb21wb25lbnRQYXRoID0gW10sXG4gICAgICAgICAgICBpICAgICAgICAgICAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgICAgICAgICAgPSBwYXRoPy5sZW5ndGggfHwgMDtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobWUuaGFzKHBhdGhbaV0pIHx8IG1lLndyYXBwZXJOb2Rlcy5nZXQocGF0aFtpXSkpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRQYXRoLnB1c2gocGF0aFtpXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21wb25lbnRQYXRoXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBBcnJheSBjb250YWluaW5nIGFsbCBwYXJlbnQgY29tcG9uZW50cyBmb3IgYSBnaXZlbiBjb21wb25lbnQgb3IgY29tcG9uZW50IGlkXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V8U3RyaW5nfSBjb21wb25lbnRcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlW119IHBhcmVudHNcbiAgICAgKi9cbiAgICBnZXRQYXJlbnRzKGNvbXBvbmVudCkge1xuICAgICAgICBpZiAoTmVvLmlzU3RyaW5nKGNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudCA9IHRoaXMuZ2V0KGNvbXBvbmVudClcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwYXJlbnRzID0gW107XG5cbiAgICAgICAgd2hpbGUgKGNvbXBvbmVudD8ucGFyZW50SWQpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudCA9IHRoaXMuZ2V0KGNvbXBvbmVudC5wYXJlbnRJZCk7XG5cbiAgICAgICAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRzLnB1c2goY29tcG9uZW50KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcmVudHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgY29tcG9uZW50IGhhZCBhIHByb3BlcnR5IG9mIGFueSB2YWx1ZSBzb21ld2hlcmUgaW4gdGhlIFByb3RvdHlwZSBjaGFpblxuICAgICAqXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNQcm90b3R5cGVQcm9wZXJ0eVZhbHVlKGNvbXBvbmVudCwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgICAgIHdoaWxlIChjb21wb25lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQuaGFzT3duUHJvcGVydHkocHJvcGVydHkpICYmIGNvbXBvbmVudFtwcm9wZXJ0eV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50Ll9fcHJvdG9fX1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHdyYXBwZXJJZFxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBjb21wb25lbnRcbiAgICAgKi9cbiAgICByZWdpc3RlcldyYXBwZXJOb2RlKHdyYXBwZXJJZCwgY29tcG9uZW50KSB7XG4gICAgICAgIHRoaXMud3JhcHBlck5vZGVzLnNldCh3cmFwcGVySWQsIGNvbXBvbmVudClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZXxTdHJpbmd9IGl0ZW1cbiAgICAgKi9cbiAgICB1bnJlZ2lzdGVyKGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmIChOZW8uaXNTdHJpbmcoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyYXBwZXJOb2Rlcy5kZWxldGUoaXRlbSlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS5pZCAhPT0gaXRlbS52ZG9tLmlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cmFwcGVyTm9kZXMuZGVsZXRlKGl0ZW0udmRvbS5pZClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN1cGVyLnVucmVnaXN0ZXIoaXRlbSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBjb21wb25lbnQgd2hpY2ggbWF0Y2hlcyB0aGUgY29uZmlnLXNlbGVjdG9yLlxuICAgICAqIFVzZSByZXR1cm5GaXJzdE1hdGNoPWZhbHNlIHRvIGdldCBhbiBhcnJheSBvZiBhbGwgbWF0Y2hpbmcgaXRlbXMgaW5zdGVhZC5cbiAgICAgKiBJZiBubyBtYXRjaCBpcyBmb3VuZCwgcmV0dXJucyBudWxsIGluIGNhc2UgcmV0dXJuRmlyc3RNYXRjaCA9PT0gdHJ1ZSwgb3RoZXJ3aXNlIGFuIGVtcHR5IEFycmF5LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb25lbnRJZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xudWxsfSBjb25maWdcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJldHVybkZpcnN0TWF0Y2g9dHJ1ZVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29tcG9uZW50LkJhc2V8TmVvLmNvbXBvbmVudC5CYXNlW118bnVsbH1cbiAgICAgKi9cbiAgICB1cChjb21wb25lbnRJZCwgY29uZmlnLCByZXR1cm5GaXJzdE1hdGNoPXRydWUpIHtcbiAgICAgICAgbGV0IGNvbXBvbmVudCAgID0gdGhpcy5nZXQoY29tcG9uZW50SWQpLFxuICAgICAgICAgICAgcmV0dXJuQXJyYXkgPSBbXSxcbiAgICAgICAgICAgIGNvbmZpZ0FycmF5LCBjb25maWdMZW5ndGgsIG1hdGNoQXJyYXk7XG5cbiAgICAgICAgaWYgKE5lby5pc1N0cmluZyhjb25maWcpKSB7XG4gICAgICAgICAgICBjb25maWcgPSB7XG4gICAgICAgICAgICAgICAgbnR5cGU6IGNvbmZpZ1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFjb25maWcpIHtcbiAgICAgICAgICAgIGNvbmZpZyA9IHt9XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWdBcnJheSAgPSBPYmplY3QuZW50cmllcyhjb25maWcpO1xuICAgICAgICBjb25maWdMZW5ndGggPSBjb25maWdBcnJheS5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGNvbXBvbmVudD8ucGFyZW50SWQpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudCA9IHRoaXMuZ2V0KGNvbXBvbmVudC5wYXJlbnRJZCk7XG5cbiAgICAgICAgICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHVybkZpcnN0TWF0Y2ggPyBudWxsIDogcmV0dXJuQXJyYXlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWF0Y2hBcnJheSA9IFtdO1xuXG4gICAgICAgICAgICBjb25maWdBcnJheS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50W2tleV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoQXJyYXkucHVzaCh0cnVlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAobWF0Y2hBcnJheS5sZW5ndGggPT09IGNvbmZpZ0xlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5GaXJzdE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wb25lbnRcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm5BcnJheS5wdXNoKGNvbXBvbmVudClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ29tcG9uZW50KTtcbiIsImltcG9ydCBCYXNlICAgICAgICAgICAgIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuaW1wb3J0IENvbXBvbmVudE1hbmFnZXIgZnJvbSAnLi9Db21wb25lbnQubWpzJztcbmltcG9ydCBGb2N1c01hbmFnZXIgICAgIGZyb20gJy4vRm9jdXMubWpzJztcbmltcG9ydCBMb2dnZXIgICAgICAgICAgIGZyb20gJy4uL3V0aWwvTG9nZ2VyLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgICAgICBmcm9tICcuLi91dGlsL0FycmF5Lm1qcyc7XG5pbXBvcnQgVkRvbVV0aWwgICAgICAgICBmcm9tICcuLi91dGlsL1ZEb20ubWpzJztcblxuY29uc3QgZXZlbnRDb25maWdLZXlzID0gW1xuICAgICdidWJibGUnLFxuICAgICdkZWxlZ2F0ZScsXG4gICAgJ2xvY2FsJyxcbiAgICAnc2NvcGUnLFxuICAgICd2bm9kZUlkJ1xuXTtcblxuY29uc3QgZ2xvYmFsRG9tRXZlbnRzID0gW1xuICAgICdjaGFuZ2UnLFxuICAgICdjbGljaycsXG4gICAgJ2NvbnRleHRtZW51JyxcbiAgICAnZGJsY2xpY2snLFxuICAgICdkcmFnOmVuZCcsXG4gICAgJ2RyYWc6bW92ZScsXG4gICAgJ2RyYWc6c3RhcnQnLFxuICAgICdmb2N1c2luJyxcbiAgICAnZm9jdXNvdXQnLFxuICAgICdpbnB1dCcsXG4gICAgJ2ludGVyc2VjdCcsXG4gICAgJ2tleWRvd24nLFxuICAgICdrZXl1cCcsXG4gICAgJ21vdXNlZG93bicsXG4gICAgJ21vdXNlZW50ZXInLFxuICAgICdtb3VzZWxlYXZlJyxcbiAgICAnbW91c2V1cCcsXG4gICAgJ25lb25hdmlnYXRlJyxcbiAgICAnc2Nyb2xsJyxcbiAgICAnc2VsZWN0aW9uY2hhbmdlJyxcbiAgICAndG91Y2htb3ZlJyxcbiAgICAnd2hlZWwnXG5dO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8ubWFuYWdlci5Eb21FdmVudFxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICogQHNpbmdsZXRvblxuICovXG5jbGFzcyBEb21FdmVudCBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLm1hbmFnZXIuRG9tRXZlbnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5tYW5hZ2VyLkRvbUV2ZW50JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gaXRlbXM9e31cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbXM6IHt9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBtYXA9e31cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbWFwOiB7fSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZXRvbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZXRvbjogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7ZGF0YX0gZXZlbnRcbiAgICAgKi9cbiAgICBhZGRSZXNpemVPYnNlcnZlcihjb21wb25lbnQsIGV2ZW50KSB7XG4gICAgICAgIGlmICghTmVvLm1haW4uYWRkb24uUmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZvciB1c2luZyByZXNpemUgZG9tTGlzdGVuZXJzLCB5b3UgbXVzdCBpbmNsdWRlIG1haW4uYWRkb24uUmVzaXplT2JzZXJ2ZXIuJywgZXZlbnQpXG4gICAgICAgIH1cblxuICAgICAgICBsZXQge2lkLCB3aW5kb3dJZH0gPSBjb21wb25lbnQ7XG5cbiAgICAgICAgTmVvLm1haW4uYWRkb24uUmVzaXplT2JzZXJ2ZXIucmVnaXN0ZXIoe2lkLCB3aW5kb3dJZH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGZpcmUoZXZlbnQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGJ1YmJsZSAgICAgID0gdHJ1ZSxcbiAgICAgICAgICAgIGRhdGEgICAgICAgID0gZXZlbnQuZGF0YSB8fCB7fSxcbiAgICAgICAgICAgIHtldmVudE5hbWV9ID0gZXZlbnQsXG4gICAgICAgICAgICBpICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICBsaXN0ZW5lcnMgICA9IG51bGwsXG4gICAgICAgICAgICBwYXRoSWRzICAgICA9IGRhdGEucGF0aC5tYXAoZSA9PiBlLmlkKSxcbiAgICAgICAgICAgIHBhdGggICAgICAgID0gQ29tcG9uZW50TWFuYWdlci5nZXRQYXJlbnRQYXRoKHBhdGhJZHMpLFxuICAgICAgICAgICAgbGVuICAgICAgICAgPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgICAgIGNvbXBvbmVudCwgZGVsZWdhdGlvblRhcmdldElkLCBpZCwgcHJldmVudEZpcmU7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWQgICAgICAgID0gcGF0aFtpXTtcbiAgICAgICAgICAgIGNvbXBvbmVudCA9IE5lby5nZXRDb21wb25lbnQoaWQpO1xuXG4gICAgICAgICAgICBpZiAoIWNvbXBvbmVudCB8fCBjb21wb25lbnQuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsaXN0ZW5lcnMgPSBtZS5pdGVtc1tpZF0/LltldmVudE5hbWVdO1xuXG4gICAgICAgICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobGlzdGVuZXJzKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdG9wIGl0ZXJhdGlvbiBpZiBhIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuZXZlcnkobGlzdGVuZXIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyICYmIGxpc3RlbmVyLmZuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gJ3Jlc2l6ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgZG8gbm90IHdhbnQgZGVsZWdhdGlvbiBmb3IgY3VzdG9tIG1haW4uYWRkb24uUmVzaXplT2JzZXJ2ZXIgZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGVnYXRpb25UYXJnZXRJZCA9IGRhdGEuaWQgPT09IGNvbXBvbmVudC5pZCA/IGRhdGEuaWQgOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGVnYXRpb25UYXJnZXRJZCA9IG1lLnZlcmlmeURlbGVnYXRpb25QYXRoKGxpc3RlbmVyLCBkYXRhLnBhdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlbGVnYXRpb25UYXJnZXRJZCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmVudEZpcmUgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBvbmx5IHdhbnQgbW91c2VlbnRlciAmIGxlYXZlIHRvIGZpcmUgb24gdGhlaXIgdG9wIGxldmVsIG5vZGVzLCBub3QgZm9yIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09ICdtb3VzZWVudGVyJyB8fCBldmVudE5hbWUgPT09ICdtb3VzZWxlYXZlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmVudEZpcmUgPSAhRG9tRXZlbnQudmVyaWZ5TW91c2VFbnRlckxlYXZlKGNvbXBvbmVudCwgZGF0YSwgZGVsZWdhdGlvblRhcmdldElkLCBldmVudE5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXByZXZlbnRGaXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtdWx0aXBsZSBsaXN0ZW5lcnMgd291bGQgY2hhbmdlIHRoZSByZWZlcmVuY2Ugb2YgZGF0YS5jb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBOZW8uY2xvbmUoZGF0YSwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuY29tcG9uZW50ID0gY29tcG9uZW50O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGVyIG5lZWRzIHRvIGtub3cgd2hpY2ggYWN0dWFsIHRhcmdldCBtYXRjaGVkIHRoZSBkZWxlZ2F0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5jdXJyZW50VGFyZ2V0ID0gZGVsZWdhdGlvblRhcmdldElkO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoTmVvLmlzU3RyaW5nKGxpc3RlbmVyLmZuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLmJpbmRDYWxsYmFjayhsaXN0ZW5lci5mbiwgJ2ZuJywgbGlzdGVuZXIuc2NvcGUsIGxpc3RlbmVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBsaXN0ZW5lci5mbi5hcHBseShsaXN0ZW5lci5zY29wZSB8fCBnbG9iYWxUaGlzLCBbZGF0YV0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxpc3RlbmVyLmJ1YmJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1YmJsZSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBhIGxpc3RlbmVyIHJldHVybnMgZmFsc2UsIHdlIHN0b3AgaXRlcmF0aW5nIHRoZSBsaXN0ZW5lcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgIT09IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB3ZSBkbyB3YW50IHRvIHRyaWdnZXIgdGhlIEZvY3VzTWFuYWdlciBhZnRlciBub3JtYWwgZG9tTGlzdGVuZXJzIG9uIHRoZXNlIGV2ZW50cyBnb3QgZXhlY3V0ZWRcbiAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09ICdmb2N1c2luJyB8fCBldmVudE5hbWUgPT09ICdmb2N1c291dCcpIHtcbiAgICAgICAgICAgICAgICBGb2N1c01hbmFnZXJbJ29uJyArIE5lby5jYXBpdGFsaXplKGV2ZW50TmFtZSldKHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50UGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSG9ub3IgdGhlIEV2ZW50IGNhbmNlbEJ1YmJsZSBwcm9wZXJ0eVxuICAgICAgICAgICAgaWYgKCFidWJibGUgfHwgZGF0YS5jYW5jZWxCdWJibGUpIHtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gJ2NvbnRleHRtZW51JyAmJiBkYXRhLmN0cmxLZXkpIHtcbiAgICAgICAgICAgIE5lby51dGlsPy5Mb2dnZXI/Lm9uQ29udGV4dE1lbnUoZGF0YSlcbiAgICAgICAgfSBlbHNlIGlmIChldmVudE5hbWUuc3RhcnRzV2l0aCgnZHJvcCcpKSB7XG4gICAgICAgICAgICBsZXQgZHJhZ1pvbmUgPSBkYXRhLmRyYWdab25lSWQgJiYgTmVvLmdldChkYXRhLmRyYWdab25lSWQpO1xuXG4gICAgICAgICAgICBpZiAoZHJhZ1pvbmUpIHtcbiAgICAgICAgICAgICAgICBkcmFnWm9uZS5maXJlKGV2ZW50TmFtZSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgZHJhZ1pvbmVbe1xuICAgICAgICAgICAgICAgICAgICAnZHJvcCcgICAgICA6ICdvbkRyb3AnLFxuICAgICAgICAgICAgICAgICAgICAnZHJvcDplbnRlcic6ICdvbkRyb3BFbnRlcicsXG4gICAgICAgICAgICAgICAgICAgICdkcm9wOmxlYXZlJzogJ29uRHJvcExlYXZlJyxcbiAgICAgICAgICAgICAgICB9W2V2ZW50TmFtZV1dLmNhbGwoZHJhZ1pvbmUsIGRhdGEpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gY29uZmlnXG4gICAgICogQHBhcmFtIHNjb3BlXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZW5lcmF0ZUxpc3RlbmVyQ29uZmlnKGNvbmZpZywgc2NvcGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJ1YmJsZSAgIDogY29uZmlnLmJ1YmJsZSxcbiAgICAgICAgICAgIGRlbGVnYXRlIDogY29uZmlnLmRlbGVnYXRlLFxuICAgICAgICAgICAgZXZlbnROYW1lOiBjb25maWcuZXZlbnROYW1lLFxuICAgICAgICAgICAgaWQgICAgICAgOiBzY29wZS5pZCxcbiAgICAgICAgICAgIG9wdHMgICAgIDogY29uZmlnLFxuICAgICAgICAgICAgcHJpb3JpdHkgOiBjb25maWcucHJpb3JpdHksXG4gICAgICAgICAgICBzY29wZSAgICA6IGNvbmZpZy5zY29wZSAgIHx8IHNjb3BlLFxuICAgICAgICAgICAgdm5vZGVJZCAgOiBjb25maWcudm5vZGVJZCB8fCBzY29wZS52ZG9tLmlkXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZ2V0RXZlbnROYW1lKGNvbmZpZykge1xuICAgICAgICBsZXQgZXZlbnROYW1lID0gbnVsbDtcblxuICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KGNvbmZpZykpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGNvbmZpZykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghZXZlbnRDb25maWdLZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnROYW1lID0ga2V5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBldmVudE5hbWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjb25maWcuYnViYmxlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy5kZWxlZ2F0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcuZXZlbnROYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy5pZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcub3B0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcuc2NvcGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLnZub2RlSWRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldExpc3RlbmVyKGNvbmZpZykge1xuICAgICAgICBsZXQgbGlzdGVuZXJzID0gdGhpcy5pdGVtcyxcbiAgICAgICAgICAgIGV2ZW50O1xuXG4gICAgICAgIGlmIChsaXN0ZW5lcnM/Lltjb25maWcuaWRdKSB7XG4gICAgICAgICAgICBldmVudCA9IGxpc3RlbmVyc1tjb25maWcuaWRdW2NvbmZpZy5ldmVudE5hbWVdO1xuXG4gICAgICAgICAgICByZXR1cm4gZXZlbnQgfHwgbnVsbFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW91bnRzIGxvY2FsIGRvbUV2ZW50IGxpc3RlbmVycyBmb3IgYSBnaXZlbiBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG1vdW50RG9tTGlzdGVuZXJzKGNvbXBvbmVudCkge1xuICAgICAgICBsZXQgbGlzdGVuZXJzICAgPSB0aGlzLml0ZW1zW2NvbXBvbmVudC5pZF0sXG4gICAgICAgICAgICBsb2NhbEV2ZW50cyA9IFtdO1xuXG4gICAgICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGxpc3RlbmVycykuZm9yRWFjaCgoW2V2ZW50TmFtZSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZSA9IGV2ZW50LmV2ZW50TmFtZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSAncmVzaXplJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRSZXNpemVPYnNlcnZlcihjb21wb25lbnQsIGV2ZW50KVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50TmFtZSAmJiAoZXZlbnQubG9jYWwgfHwgIWdsb2JhbERvbUV2ZW50cy5pbmNsdWRlcyhldmVudE5hbWUpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxFdmVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSAgIDogZXZlbnROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXI6ICdkb21FdmVudExpc3RlbmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2bm9kZUlkOiBldmVudC52bm9kZUlkXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAobG9jYWxFdmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIE5lby53b3JrZXIuQXBwLnByb21pc2VNZXNzYWdlKCdtYWluJywge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb24gIDogJ2FkZERvbUxpc3RlbmVyJyxcbiAgICAgICAgICAgICAgICAgICAgYXBwTmFtZSA6IGNvbXBvbmVudC5hcHBOYW1lLFxuICAgICAgICAgICAgICAgICAgICBldmVudHMgIDogbG9jYWxFdmVudHMsXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0lkOiBjb21wb25lbnQud2luZG93SWRcbiAgICAgICAgICAgICAgICB9KS50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnYWRkZWQgZG9tTGlzdGVuZXInLCBkYXRhKTtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQXBwOiBHb3QgZXJyb3IgYXR0ZW1wdGluZyB0byBhZGQgYSBkb21MaXN0ZW5lcicsIGVycilcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICBjb25maWdcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNvbmZpZy5idWJibGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gIGNvbmZpZy5kZWxlZ2F0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgY29uZmlnLmV2ZW50TmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgY29uZmlnLmlkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjb25maWcubG9jYWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gIGNvbmZpZy5vcHRzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICBjb25maWcub3JpZ2luYWxDb25maWdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gIGNvbmZpZy5vd25lcklkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICBjb25maWcucHJpb3JpdHk9MVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgY29uZmlnLnNjb3BlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICBjb25maWcudm5vZGVJZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHRoZSBsaXN0ZW5lciBnb3QgcmVnaXN0ZXJlZCBzdWNjZXNzZnVsbHkgKGZhbHNlIGluIGNhc2UgaXQgd2FzIGFscmVhZHkgdGhlcmUpXG4gICAgICovXG4gICAgcmVnaXN0ZXIoY29uZmlnKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGFscmVhZHlSZWdpc3RlcmVkICAgICAgICAgICAgPSBmYWxzZSxcbiAgICAgICAgICAgIHtldmVudE5hbWUsIGlkLCBvcHRzLCBzY29wZX0gPSBjb25maWcsXG4gICAgICAgICAgICBsaXN0ZW5lcnMgICAgICAgICAgICAgICAgICAgID0gbWUuaXRlbXMsXG4gICAgICAgICAgICBmblR5cGUgICAgICAgICAgICAgICAgICAgICAgID0gdHlwZW9mIG9wdHMsXG4gICAgICAgICAgICBmbiwgbGlzdGVuZXIsIGxpc3RlbmVyQ29uZmlnLCBsaXN0ZW5lcklkO1xuXG4gICAgICAgIGlmIChmblR5cGUgPT09ICdmdW5jdGlvbicgfHwgZm5UeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZm4gPSBvcHRzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmbiAgICA9IG9wdHMuZm47XG4gICAgICAgICAgICBzY29wZSA9IG9wdHMuc2NvcGUgfHwgc2NvcGVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbGlzdGVuZXJzW2lkXSkge1xuICAgICAgICAgICAgbGlzdGVuZXJzW2lkXSA9IHt9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdGVuZXJzW2lkXVtldmVudE5hbWVdKSB7XG4gICAgICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpZF1bZXZlbnROYW1lXTtcblxuICAgICAgICAgICAgT2JqZWN0LmtleXMobGlzdGVuZXIpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyW2tleV0uZm4udG9TdHJpbmcoKSA9PT0gZm4udG9TdHJpbmcoKSAmJiAvLyB0b2RvOiBhZGQgYSBiZXR0ZXIgY2hlY2tcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJba2V5XS5zY29wZSAgICAgICAgID09PSBzY29wZSAmJlxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcltrZXldLmRlbGVnYXRlICAgICAgPT09IGNvbmZpZy5kZWxlZ2F0ZVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBhbHJlYWR5UmVnaXN0ZXJlZCA9IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGlzdGVuZXJzW2lkXVtldmVudE5hbWVdID0gW11cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhbHJlYWR5UmVnaXN0ZXJlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnbWFuYWdlci5Eb21FdmVudCByZWdpc3RlcicsIGV2ZW50TmFtZSwgY29uZmlnKTtcblxuICAgICAgICBsaXN0ZW5lcklkID0gTmVvLmdldElkKCdkb20tZXZlbnQnKTtcblxuICAgICAgICBjb25maWcubGlzdGVuZXJJZCA9IGxpc3RlbmVySWQ7XG5cbiAgICAgICAgbGlzdGVuZXJDb25maWcgPSB7XG4gICAgICAgICAgICBidWJibGUgICAgICAgIDogY29uZmlnLmhhc093blByb3BlcnR5KCdidWJibGUnKSA/IGNvbmZpZy5idWJibGUgOiBvcHRzLmhhc093blByb3BlcnR5KCdidWJibGUnKSA/IG9wdHMuYnViYmxlIDogdHJ1ZSxcbiAgICAgICAgICAgIGRlbGVnYXRlICAgICAgOiBjb25maWcuZGVsZWdhdGUsXG4gICAgICAgICAgICBldmVudE5hbWUsXG4gICAgICAgICAgICBmbixcbiAgICAgICAgICAgIGlkICAgICAgICAgICAgOiBsaXN0ZW5lcklkLFxuICAgICAgICAgICAgbW91bnRlZCAgICAgICA6ICFjb25maWcubG9jYWwgJiYgZ2xvYmFsRG9tRXZlbnRzLmluY2x1ZGVzKGV2ZW50TmFtZSksXG4gICAgICAgICAgICBvcmlnaW5hbENvbmZpZzogY29uZmlnLm9yaWdpbmFsQ29uZmlnLFxuICAgICAgICAgICAgb3duZXJJZCAgICAgICA6IGNvbmZpZy5vd25lcklkLFxuICAgICAgICAgICAgcHJpb3JpdHkgICAgICA6IGNvbmZpZy5wcmlvcml0eSB8fCBvcHRzLnByaW9yaXR5IHx8IDEsXG4gICAgICAgICAgICBzY29wZSxcbiAgICAgICAgICAgIHZub2RlSWQgICAgICAgOiBjb25maWcudm5vZGVJZFxuICAgICAgICB9O1xuXG4gICAgICAgIG1lLm1hcFtsaXN0ZW5lcklkXSA9IGxpc3RlbmVyQ29uZmlnO1xuXG4gICAgICAgIGxpc3RlbmVyc1tpZF1bZXZlbnROYW1lXS5wdXNoKGxpc3RlbmVyQ29uZmlnKTtcblxuICAgICAgICBsaXN0ZW5lcnNbaWRdW2V2ZW50TmFtZV0uc29ydCgoYSwgYikgPT4gYi5wcmlvcml0eSAtIGEucHJpb3JpdHkpO1xuXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY29uZmlnLmJ1YmJsZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcuZXZlbnROYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy5pZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcub3B0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcuc2NvcGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLnZub2RlSWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2NvcGVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpbiBjYXNlIHRoZSBsaXN0ZW5lciBkaWQgZXhpc3QgYW5kIGdvdCByZW1vdmVkXG4gICAgICovXG4gICAgdW5yZWdpc3Rlcihjb25maWcsIHNjb3BlKSB7XG4gICAgICAgIC8vIHRvZG9cbiAgICAgICAgY29uc29sZS5sb2coJ3VucmVnaXN0ZXInLCBjb25maWcpO1xuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmdlbmVyYXRlTGlzdGVuZXJDb25maWcoY29uZmlnLCBzY29wZSkpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgICAgbGV0IGxpc3RlbmVyID0gdGhpcy5nZXRMaXN0ZW5lcihjb25maWcpO1xuXG4gICAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2xpc3RlbmVyIGZvdW5kJywgbGlzdGVuZXIpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZG9tTGlzdGVuZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gb2xkRG9tTGlzdGVuZXJzXG4gICAgICovXG4gICAgdXBkYXRlRG9tTGlzdGVuZXJzKGNvbXBvbmVudCwgZG9tTGlzdGVuZXJzLCBvbGREb21MaXN0ZW5lcnMpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgcmVnaXN0ZXJlZExpc3RlbmVycyA9IG1lLml0ZW1zW2NvbXBvbmVudC5pZF0gfHwge30sXG4gICAgICAgICAgICBpLCBsZW4sIGxpc3RlbmVycztcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkb21MaXN0ZW5lcnMpKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvbGREb21MaXN0ZW5lcnMpKSB7XG4gICAgICAgICAgICAgICAgb2xkRG9tTGlzdGVuZXJzLmZvckVhY2gob2xkRG9tTGlzdGVuZXIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBmaW5kICYgcmVtb3ZlIG5vIGxvbmdlciBleGlzdGluZyBsaXN0ZW5lcnNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkb21MaXN0ZW5lcnMuaW5jbHVkZXMob2xkRG9tTGlzdGVuZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMgPSByZWdpc3RlcmVkTGlzdGVuZXJzW21lLmdldEV2ZW50TmFtZShvbGREb21MaXN0ZW5lcildIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSAgICAgICAgID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbiAgICAgICA9IGxpc3RlbmVycy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzW2ldLm9yaWdpbmFsQ29uZmlnID09PSBvbGREb21MaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUobGlzdGVuZXJzLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFkZCBuZXcgbGlzdGVuZXJzXG4gICAgICAgICAgICBkb21MaXN0ZW5lcnMuZm9yRWFjaChkb21MaXN0ZW5lciA9PiB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoZG9tTGlzdGVuZXIpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV2ZW50Q29uZmlnS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5yZWdpc3Rlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnViYmxlICAgICAgICA6IGRvbUxpc3RlbmVyLmJ1YmJsZSAgIHx8IHZhbHVlLmJ1YmJsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZSAgICAgIDogZG9tTGlzdGVuZXIuZGVsZWdhdGUgfHwgdmFsdWUuZGVsZWdhdGUgfHwgJyMnICsgKGNvbXBvbmVudC52ZG9tLmlkIHx8IGNvbXBvbmVudC5pZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnROYW1lICAgICA6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCAgICAgICAgICAgIDogY29tcG9uZW50LnZkb20uaWQgfHwgY29tcG9uZW50LmlkLCAvLyBob25vciB3cmFwcGVyIG5vZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0cyAgICAgICAgICA6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsQ29uZmlnOiBkb21MaXN0ZW5lcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvd25lcklkICAgICAgIDogY29tcG9uZW50LmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5ICAgICAgOiBkb21MaXN0ZW5lci5wcmlvcml0eSB8fCB2YWx1ZS5wcmlvcml0eSB8fCAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlICAgICAgICAgOiBkb21MaXN0ZW5lci5zY29wZSAgICB8fCBjb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdm5vZGVJZCAgICAgICA6IGRvbUxpc3RlbmVyLnZub2RlSWQgIHx8IHZhbHVlLnZub2RlSWQgIHx8IGNvbXBvbmVudC52ZG9tLmlkXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50Lm1vdW50ZWQgJiYgZG9tTGlzdGVuZXJzPy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbWUudGltZW91dCgxMDApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBtZS5tb3VudERvbUxpc3RlbmVycyhjb21wb25lbnQpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIExvZ2dlci5sb2dFcnJvcignQ29tcG9uZW50LmRvbUxpc3RlbmVycyBoYXZlIHRvIGJlIGFuIGFycmF5JywgY29tcG9uZW50KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxpc3RlbmVyXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufFN0cmluZ30gdHJ1ZSBpbiBjYXNlIHRoZSBkZWxlZ2F0aW9uIHN0cmluZyBtYXRjaGVzIHRoZSBldmVudCBwYXRoXG4gICAgICovXG4gICAgdmVyaWZ5RGVsZWdhdGlvblBhdGgobGlzdGVuZXIsIHBhdGgpIHtcbiAgICAgICAgbGV0IHtkZWxlZ2F0ZX0gPSBsaXN0ZW5lcixcbiAgICAgICAgICAgIGogICAgICAgICAgPSAwLFxuICAgICAgICAgICAgcGF0aExlbiAgICA9IHBhdGgubGVuZ3RoLFxuICAgICAgICAgICAgdGFyZ2V0SWQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkZWxlZ2F0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaiA9IGRlbGVnYXRlKHBhdGgpO1xuXG4gICAgICAgICAgICBpZiAoaiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0SWQgPSBwYXRoW2pdLmlkXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgZGVsZWdhdGlvbkFycmF5ID0gZGVsZWdhdGUuc3BsaXQoJyAnKSxcbiAgICAgICAgICAgICAgICBsZW4gICAgICAgICAgICAgPSBkZWxlZ2F0aW9uQXJyYXkubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGhhc01hdGNoLCBpLCBpdGVtLCBpc0lkO1xuXG4gICAgICAgICAgICBmb3IgKGk9bGVuLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgaGFzTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpdGVtICAgICA9IGRlbGVnYXRpb25BcnJheVtpXTtcbiAgICAgICAgICAgICAgICBpc0lkICAgICA9IGl0ZW0uc3RhcnRzV2l0aCgnIycpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzSWQgfHwgaXRlbS5zdGFydHNXaXRoKCcuJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IGl0ZW0uc3Vic3RyKDEpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICg7IGogPCBwYXRoTGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgKGlzSWQgJiYgcGF0aFtqXS5pZCA9PT0gaXRlbSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhbal0uY2xzLmluY2x1ZGVzKGl0ZW0pXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0SWQgPSBwYXRoW2pdLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghaGFzTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW5zdXJlIHRoZSBkZWxlZ2F0aW9uIHBhdGggaXMgYSBjaGlsZCBvZiB0aGUgb3duZXIgY29tcG9uZW50cyByb290IG5vZGVcbiAgICAgICAgZm9yICg7IGogPCBwYXRoTGVuOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXRoW2pdLmlkID09PSBsaXN0ZW5lci52bm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldElkXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVsZWdhdGlvblRhcmdldElkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyB2ZXJpZnlNb3VzZUVudGVyTGVhdmUoY29tcG9uZW50LCBkYXRhLCBkZWxlZ2F0aW9uVGFyZ2V0SWQsIGV2ZW50TmFtZSkge1xuICAgICAgICBsZXQgdGFyZ2V0SWQgPSBldmVudE5hbWUgPT09ICdtb3VzZWVudGVyJyA/IGRhdGEuZnJvbUVsZW1lbnRJZCA6IGRhdGEudG9FbGVtZW50SWQsXG4gICAgICAgICAgICBkZWxlZ2F0aW9uVmRvbTtcblxuICAgICAgICBpZiAodGFyZ2V0SWQgJiYgdGFyZ2V0SWQgIT09IGRlbGVnYXRpb25UYXJnZXRJZCkge1xuICAgICAgICAgICAgZGVsZWdhdGlvblZkb20gPSBWRG9tVXRpbC5maW5kKGNvbXBvbmVudC52ZG9tLCBkZWxlZ2F0aW9uVGFyZ2V0SWQpO1xuXG4gICAgICAgICAgICAvLyBkZWxlZ2F0aW9uVmRvbSBjYW4gYmUgdW5kZWZpbmVkIHdoZW4gZHJhZ2dpbmcgYSBwcm94eSBvdmVyIHRoZSBub2RlLlxuICAgICAgICAgICAgLy8gc2VlIGlzc3Vlcy8xMTM3IGZvciBkZXRhaWxzLlxuICAgICAgICAgICAgaWYgKCFkZWxlZ2F0aW9uVmRvbSB8fCBkZWxlZ2F0aW9uVmRvbS52ZG9tICYmIFZEb21VdGlsLmZpbmQoZGVsZWdhdGlvblZkb20udmRvbSwgdGFyZ2V0SWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoRG9tRXZlbnQpO1xuIiwiaW1wb3J0IENvcmVCYXNlIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuaW1wb3J0IE5lb0FycmF5IGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLm1hbmFnZXIuRm9jdXNcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqIEBzaW5nbGV0b25cbiAqL1xuY2xhc3MgRm9jdXMgZXh0ZW5kcyBDb3JlQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ubWFuYWdlci5Gb2N1cydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLm1hbmFnZXIuRm9jdXMnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgY29udGFpbmluZyBvcHRzIG9iamVjdHMuXG4gICAgICAgICAqIG9wdHMuY29tcG9uZW50UGF0aFxuICAgICAgICAgKiBvcHRzLmRhdGFcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0W119IGhpc3Rvcnk9W11cbiAgICAgICAgICovXG4gICAgICAgIGhpc3Rvcnk6IFtdLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIERhdGUgb2JqZWN0IHdoZW4gdGhlIGxhc3QgZm9jdXNpbiBldmVudCBoYXMgb2NjdXJyZWRcbiAgICAgICAgICogQG1lbWJlciB7RGF0ZXxudWxsfSBsYXN0Rm9jdXNJbkRhdGU9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBsYXN0Rm9jdXNJbkRhdGU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgRGF0ZSBvYmplY3Qgd2hlbiB0aGUgbGFzdCBmb2N1c291dCBldmVudCBoYXMgb2NjdXJyZWRcbiAgICAgICAgICogQG1lbWJlciB7RGF0ZXxudWxsfSBsYXN0Rm9jdXNJbkRhdGU9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBsYXN0Rm9jdXNPdXREYXRlOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFtb3VudCBvZiB0aW1lIGZvciBhIGZvY3VzSW4gdG8gb2NjdXIgYWZ0ZXIgdGhlIGxhc3QgZm9jdXNPdXRcbiAgICAgICAgICogdG8gZ2V0IGNvbWJpbmVkIGludG8gYSBmb2N1c21vdmUgZXZlbnQuXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gbWF4Rm9jdXNJbk91dEdhcD01MFxuICAgICAgICAgKi9cbiAgICAgICAgbWF4Rm9jdXNJbk91dEdhcDogNTAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWF4aW11bSBhbW91bnQgb2YgaXRlbXMgc3RvcmVkIGluc2lkZSB0aGUgaGlzdG9yeSBhcnJheVxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IG1heEhpc3RvcnlMZW5ndGg9MjBcbiAgICAgICAgICovXG4gICAgICAgIG1heEhpc3RvcnlMZW5ndGg6IDIwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2luZ2xldG9uPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2luZ2xldG9uOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgb3B0cy5jb21wb25lbnRQYXRoIENvbXBvbmVudCBpZHMgdXB3YXJkc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmRhdGEgZG9tIGV2ZW50IGluZm9zXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFkZFRvSGlzdG9yeShvcHRzKSB7XG4gICAgICAgIGxldCBoaXN0b3J5ID0gdGhpcy5oaXN0b3J5O1xuXG4gICAgICAgIGhpc3RvcnkudW5zaGlmdChvcHRzKTtcbiAgICAgICAgaGlzdG9yeS5sZW5ndGggPj0gdGhpcy5tYXhIaXN0b3J5TGVuZ3RoICYmIGhpc3RvcnkucG9wKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9ICBvcHRzLmNvbXBvbmVudFBhdGggQ29tcG9uZW50IGlkcyB1cHdhcmRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuZGF0YSBkb20gZXZlbnQgaW5mb3NcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZm9jdXNFbnRlcihvcHRzKSB7XG4gICAgICAgIHRoaXMuc2V0Q29tcG9uZW50Rm9jdXMob3B0cywgdHJ1ZSk7XG4gICAgICAgIHRoaXMuYWRkVG9IaXN0b3J5KG9wdHMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgb3B0cy5jb21wb25lbnRQYXRoIENvbXBvbmVudCBpZHMgdXB3YXJkc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmRhdGEgZG9tIGV2ZW50IGluZm9zXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGZvY3VzTGVhdmUob3B0cykge1xuICAgICAgICB0aGlzLnNldENvbXBvbmVudEZvY3VzKG9wdHMsIGZhbHNlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtBcnJheX0gIG9wdHMuY29tcG9uZW50UGF0aCBDb21wb25lbnQgaWRzIHVwd2FyZHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5kYXRhIGRvbSBldmVudCBpbmZvc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBmb2N1c01vdmUob3B0cykge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7aGlzdG9yeX0gICAgICAgID0gbWUsXG4gICAgICAgICAgICBuZXdDb21wb25lbnRQYXRoID0gb3B0cy5jb21wb25lbnRQYXRoLFxuICAgICAgICAgICAgb2xkQ29tcG9uZW50UGF0aCA9IGhpc3RvcnlbMF0uY29tcG9uZW50UGF0aCxcbiAgICAgICAgICAgIGZvY3VzRW50ZXIgICAgICAgPSBOZW9BcnJheS5kaWZmZXJlbmNlKG5ld0NvbXBvbmVudFBhdGgsIG9sZENvbXBvbmVudFBhdGgpLFxuICAgICAgICAgICAgZm9jdXNMZWF2ZSAgICAgICA9IE5lb0FycmF5LmRpZmZlcmVuY2Uob2xkQ29tcG9uZW50UGF0aCwgbmV3Q29tcG9uZW50UGF0aCksXG4gICAgICAgICAgICBmb2N1c01vdmUgICAgICAgID0gTmVvQXJyYXkuaW50ZXJzZWN0aW9uKG5ld0NvbXBvbmVudFBhdGgsIG9sZENvbXBvbmVudFBhdGgpLFxuICAgICAgICAgICAgY29tcG9uZW50LCBkYXRhO1xuXG4gICAgICAgIG1lLnNldENvbXBvbmVudEZvY3VzKHtjb21wb25lbnRQYXRoOiBmb2N1c0xlYXZlLCBkYXRhOiBvcHRzLmRhdGF9LCBmYWxzZSk7XG4gICAgICAgIG1lLnNldENvbXBvbmVudEZvY3VzKHtjb21wb25lbnRQYXRoOiBmb2N1c0VudGVyLCBkYXRhOiBvcHRzLmRhdGF9LCB0cnVlKTtcblxuICAgICAgICBmb2N1c01vdmUuZm9yRWFjaChpZCA9PiB7XG4gICAgICAgICAgICBjb21wb25lbnQgPSBOZW8uZ2V0Q29tcG9uZW50KGlkKTtcblxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICAgICAgcGF0aCAgIDogb3B0cy5kYXRhLnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIG9sZFBhdGg6IGhpc3RvcnlbMF0uZGF0YS5wYXRoXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5vbkZvY3VzTW92ZT8uKGRhdGEpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5maXJlKCdmb2N1c01vdmUnLCBkYXRhKTtcblxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5vbkZvY3VzQ2hhbmdlPy4oZGF0YSk7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LmZpcmUoJ2ZvY3VzQ2hhbmdlJywgZGF0YSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUuYWRkVG9IaXN0b3J5KG9wdHMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgb3B0cy5jb21wb25lbnRQYXRoIENvbXBvbmVudCBpZHMgdXB3YXJkc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmRhdGEgZG9tIGV2ZW50IGluZm9zXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uRm9jdXNpbihvcHRzKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUubGFzdEZvY3VzSW5EYXRlID0gbmV3IERhdGUoKTtcblxuICAgICAgICBpZiAobWUubGFzdEZvY3VzT3V0RGF0ZSAmJiBtZS5sYXN0Rm9jdXNJbkRhdGUgLSBtZS5sYXN0Rm9jdXNPdXREYXRlIDwgbWUubWF4Rm9jdXNJbk91dEdhcCkge1xuICAgICAgICAgICAgbWUuZm9jdXNNb3ZlKG9wdHMpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5mb2N1c0VudGVyKG9wdHMpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9ICBvcHRzLmNvbXBvbmVudFBhdGggQ29tcG9uZW50IGlkcyB1cHdhcmRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuZGF0YSBkb20gZXZlbnQgaW5mb3NcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25Gb2N1c291dChvcHRzKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUubGFzdEZvY3VzT3V0RGF0ZSA9IG5ldyBEYXRlKCk7XG5cbiAgICAgICAgbWUudGltZW91dChtZS5tYXhGb2N1c0luT3V0R2FwKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChtZS5sYXN0Rm9jdXNPdXREYXRlID4gbWUubGFzdEZvY3VzSW5EYXRlKSB7XG4gICAgICAgICAgICAgICAgbWUuZm9jdXNMZWF2ZShvcHRzKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtBcnJheX0gIG9wdHMuY29tcG9uZW50UGF0aCBDb21wb25lbnQgaWRzIHVwd2FyZHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5kYXRhIGRvbSBldmVudCBpbmZvc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY29udGFpbnNGb2N1c1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZXRDb21wb25lbnRGb2N1cyhvcHRzLCBjb250YWluc0ZvY3VzKSB7XG4gICAgICAgIGxldCBkYXRhID0ge1xuICAgICAgICAgICAgICAgIHJlbGF0ZWRUYXJnZXQ6IG9wdHMuZGF0YS5yZWxhdGVkVGFyZ2V0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29tcG9uZW50cyA9IG9wdHMuY29tcG9uZW50UGF0aC5tYXAoaWQgPT4gTmVvLmdldENvbXBvbmVudChpZCkpLFxuICAgICAgICAgICAgaGFuZGxlcjtcblxuICAgICAgICBjb21wb25lbnRzLmZvckVhY2goY29tcG9uZW50ID0+IHtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuY29udGFpbnNGb2N1cyA9IGNvbnRhaW5zRm9jdXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29tcG9uZW50cy5mb3JFYWNoKGNvbXBvbmVudCA9PiB7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgZGF0YS5jb21wb25lbnQgPSBjb21wb25lbnQ7XG5cbiAgICAgICAgICAgICAgICBkYXRhW2NvbnRhaW5zRm9jdXMgPyAncGF0aCcgOiAnb2xkUGF0aCddID0gb3B0cy5kYXRhLnBhdGhcblxuICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBjb250YWluc0ZvY3VzID8gJ29uRm9jdXNFbnRlcicgOiAnb25Gb2N1c0xlYXZlJztcbiAgICAgICAgICAgICAgICBjb21wb25lbnRbaGFuZGxlcl0/LihkYXRhKTtcblxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5maXJlKGNvbnRhaW5zRm9jdXMgPyAnZm9jdXNFbnRlcicgOiAnZm9jdXNMZWF2ZScsIGRhdGEpO1xuXG4gICAgICAgICAgICAgICAgY29tcG9uZW50Lm9uRm9jdXNDaGFuZ2U/LihkYXRhKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuZmlyZSgnZm9jdXNDaGFuZ2UnLCBkYXRhKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoRm9jdXMpO1xuIiwiaW1wb3J0IEJhc2UgICAgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQgTWFuYWdlciBmcm9tICcuL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLm1hbmFnZXIuSW5zdGFuY2VcbiAqIEBleHRlbmRzIE5lby5tYW5hZ2VyLkJhc2VcbiAqIEBzaW5nbGV0b25cbiAqL1xuY2xhc3MgSW5zdGFuY2UgZXh0ZW5kcyBNYW5hZ2VyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5tYW5hZ2VyLkluc3RhbmNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ubWFuYWdlci5JbnN0YW5jZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaW5nbGV0b249dHJ1ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzaW5nbGV0b246IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIEJhc2UuaW5zdGFuY2VNYW5hZ2VyQXZhaWxhYmxlID0gdHJ1ZTtcblxuICAgICAgICBtZS5jb25zdW1lTmVvSWRNYXAoKTtcblxuICAgICAgICBOZW8uZmluZCAgICAgID0gbWUuZmluZCAgICAgLmJpbmQobWUpOyAvLyBhbGlhc1xuICAgICAgICBOZW8uZmluZEZpcnN0ID0gbWUuZmluZEZpcnN0LmJpbmQobWUpOyAvLyBhbGlhc1xuICAgICAgICBOZW8uZ2V0ICAgICAgID0gbWUuZ2V0ICAgICAgLmJpbmQobWUpOyAvLyBhbGlhc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGFsbCBpZHMgd2hpY2ggZ290IGFwcGxpZWQgdG8gdGhlIE5lbyBuYW1lc3BhY2UgYmVmb3JlIHRoaXMgaW5zdGFuY2UgZ290IGNyZWF0ZWRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY29uc3VtZU5lb0lkTWFwKCkge1xuICAgICAgICBpZiAoTmVvLmlkTWFwKSB7XG4gICAgICAgICAgICB0aGlzLmFkZChPYmplY3QudmFsdWVzKE5lby5pZE1hcCkpO1xuICAgICAgICAgICAgZGVsZXRlIE5lby5pZE1hcFxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhJbnN0YW5jZSk7XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnV0aWwuQXJyYXlcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgTmVvQXJyYXkgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby51dGlsLkFycmF5J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8udXRpbC5BcnJheSdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGl0ZW0gb3IgQXJyYXkgb2YgaXRlbXMgdG8gYW4gYXJyYXkgaW4gY2FzZSBpdCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LlxuICAgICAqIE9ubHkgcHJpbWl0aXZlIGl0ZW1zIHdpbGwgZ2V0IGZvdW5kIGFzIGR1cGxpY2F0ZXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAgICAgKiBAcGFyYW0geyp9IGl0ZW1zXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIHN0YXRpYyBhZGQoYXJyLCBpdGVtcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgICAgICBpdGVtcyA9IFtpdGVtc11cbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpZiAoIWFyci5pbmNsdWRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgIGFyci5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gYXJyXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBpdGVtcyB3aGljaCBhcmUgcHJlc2VudCBpbiBhcnJheTEsIGJ1dCBub3QgaW4gYXJyYXkyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkxPVtdXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkyPVtdXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIHN0YXRpYyBkaWZmZXJlbmNlKGFycmF5MT1bXSwgYXJyYXkyPVtdKSB7XG4gICAgICAgIHJldHVybiBhcnJheTEuZmlsdGVyKGl0ZW0gPT4gIWFycmF5Mi5pbmNsdWRlcyhpdGVtKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGl0ZW0gaXMgaW5jbHVkZWQgYnkgcmVmZXJlbmNlIGluc2lkZSB0aGUgYXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAgICAgKiBAcGFyYW0geyp9IGl0ZW1cbiAgICAgKi9cbiAgICBzdGF0aWMgaGFzSXRlbShhcnIsIGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGFyci5pbmNsdWRlcyhpdGVtKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYW4gaXRlbSBvciBBcnJheSBvZiBpdGVtcyB0byBhbiBhcnJheSBpbiBjYXNlIGl0IGRvZXMgbm90IGFscmVhZHkgZXhpc3QuXG4gICAgICogRHVwbGljYXRlcyB3aWxsIG9ubHkgZ2V0IG1hdGNoZWQgYnkgcmVmZXJlbmNlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEBwYXJhbSB7Kn0gaXRlbXNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgc3RhdGljIGluc2VydChhcnIsIGluZGV4LCBpdGVtcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgICAgICBpdGVtcyA9IFtpdGVtc11cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBsZW4gPSBpdGVtcy5sZW5ndGggLTEsXG4gICAgICAgICAgICBpICAgPSBsZW4sXG4gICAgICAgICAgICBjdXJyZW50SW5kZXgsIGl0ZW07XG5cbiAgICAgICAgLy8gSXRlcmF0ZSBiYWNrd2FyZHNcbiAgICAgICAgZm9yICg7IGkgPiAtMTsgaS0tKSB7XG4gICAgICAgICAgICBpdGVtID0gaXRlbXNbaV07XG5cbiAgICAgICAgICAgIGN1cnJlbnRJbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IGN1cnJlbnRJbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmUoYXJyLCBjdXJyZW50SW5kZXgsIGluZGV4KVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFyci5zcGxpY2UoaW5kZXgsIDAsIGl0ZW0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFyclxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgaXRlbXMgd2hpY2ggYXJlIHByZXNlbnQgaW4gYXJyYXkxIGFuZCBhcnJheTJcbiAgICAgKiBPbmx5IHN1cHBvcnRzIHByaW1pdGl2ZSBpdGVtc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5MT1bXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5Mj1bXVxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50ZXJzZWN0aW9uKGFycmF5MT1bXSwgYXJyYXkyPVtdKSB7XG4gICAgICAgIHJldHVybiBhcnJheTEuZmlsdGVyKGl0ZW0gPT4gYXJyYXkyLmluY2x1ZGVzKGl0ZW0pKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGFuIGl0ZW0gaW5zaWRlIGFyciBmcm9tIGZyb21JbmRleCB0byB0b0luZGV4XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZyb21JbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0b0luZGV4XG4gICAgICovXG4gICAgc3RhdGljIG1vdmUoYXJyLCBmcm9tSW5kZXgsIHRvSW5kZXgpIHtcbiAgICAgICAgaWYgKGZyb21JbmRleCA9PT0gdG9JbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyclxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZyb21JbmRleCA+PSBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICBmcm9tSW5kZXggPSBhcnIubGVuZ3RoIC0gMVxuICAgICAgICB9XG5cbiAgICAgICAgYXJyLnNwbGljZSh0b0luZGV4LCAwLCBhcnIuc3BsaWNlKGZyb21JbmRleCwgMSlbMF0pO1xuICAgICAgICByZXR1cm4gYXJyXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbiBpdGVtIG9yIGFycmF5IG9mIGl0ZW1zIGZyb20gYW4gYXJyYXkuIE9ubHkgcHJpbWl0aXZlIGl0ZW1zIHdpbGwgZ2V0IGZvdW5kXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAgICogQHBhcmFtIHsqfSBpdGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyByZW1vdmUoYXJyLCBpdGVtcykge1xuICAgICAgICBsZXQgaW5kZXg7XG5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICAgICAgaXRlbXMgPSBbaXRlbXNdXG4gICAgICAgIH1cblxuICAgICAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcblxuICAgICAgICAgICAgaW5kZXggPiAtMSAmJiBhcnIuc3BsaWNlKGluZGV4LCAxKVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gYXJyXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIGNvbWJpbmUgYWRkICYgcmVtb3ZlIGluIG9uZSBjYWxsLlxuICAgICAqIFlvdSBjYW4gcGFzcyBzaW5nbGUgaXRlbXMgb3IgYW4gYXJyYXkgb2YgaXRlbXMgdG8gYWRkIG9yIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAgICAgKiBAcGFyYW0geyp9IHJlbW92ZUl0ZW1zXG4gICAgICogQHBhcmFtIHsqfSBhZGRJdGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyByZW1vdmVBZGQoYXJyLCByZW1vdmVJdGVtcywgYWRkSXRlbXMpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoYXJyLCByZW1vdmVJdGVtcyk7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChhcnIsIGFkZEl0ZW1zKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW4gaXRlbSBmcm9tIGFuIGFycmF5IGluIGNhc2UgaXQgZG9lcyBleGlzdCwgb3RoZXJ3aXNlIGFkZHMgaXRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAgICAgKiBAcGFyYW0geyp9IGl0ZW1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthZGRdXG4gICAgICovXG4gICAgc3RhdGljIHRvZ2dsZShhcnIsIGl0ZW0sIGFkZCA9ICF0aGlzLmhhc0l0ZW0oYXJyLCBpdGVtKSkge1xuICAgICAgICByZXR1cm4gdGhpc1thZGQgPyAnYWRkJyA6ICdyZW1vdmUnXShhcnIsIGl0ZW0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgaXRlbXMgd2hpY2ggYXJlIHByZXNlbnQgaW4gdGhlIHBhc3NlZCBhcnJheXMuXG4gICAgICogTXVsdGlwbGUgYXJyYXlzIG1heSBiZSBwYXNzZWQuXG4gICAgICogT25seSBzdXBwb3J0cyBwcmltaXRpdmUgaXRlbXNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgc3RhdGljIHVuaW9uKCkge1xuICAgICAgICByZXR1cm4gWy4uLm5ldyBTZXQoQXJyYXkucHJvdG90eXBlLmNvbmNhdCguLi5hcmd1bWVudHMpKV1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGl0ZW0gb3IgQXJyYXkgb2YgaXRlbXMgdG8gYW4gYXJyYXkgaW4gY2FzZSBpdCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LlxuICAgICAqIE9ubHkgcHJpbWl0aXZlIGl0ZW1zIHdpbGwgZ2V0IGZvdW5kIGFzIGR1cGxpY2F0ZXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAgICAgKiBAcGFyYW0geyp9IGl0ZW1zXG4gICAgICovXG4gICAgc3RhdGljIHVuc2hpZnQoYXJyLCBpdGVtcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgICAgICBpdGVtcyA9IFtpdGVtc11cbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpZiAoIWFyci5pbmNsdWRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgIGFyci51bnNoaWZ0KGl0ZW0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBhcnJcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKE5lb0FycmF5KTtcbiIsImltcG9ydCBCYXNlIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8udXRpbC5DbGFzc1N5c3RlbVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBDbGFzc1N5c3RlbSBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnV0aWwuQ2xhc3NTeXN0ZW0nXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby51dGlsLkNsYXNzU3lzdGVtJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNhbiBnZXQgdXNlZCBpbnNpZGUgYmVmb3JlU2V0IG1ldGhvZHMgaW4gY2FzZSB5b3Ugd2FudCB0byBjcmVhdGUgaW5zdGFuY2VzIGxpa2Ugc3RvcmVzXG4gICAgICogQHBhcmFtIHtPYmplY3R8TmVvLmNvcmUuQmFzZXxudWxsfSBjb25maWdcbiAgICAgKiBAcGFyYW0ge05lby5jb3JlLkJhc2V8U3RyaW5nfSBbRGVmYXVsdENsYXNzPW51bGxdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtkZWZhdWx0VmFsdWVzPXt9XVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29yZS5CYXNlfSBpbnN0YW5jZVxuICAgICAqL1xuICAgIHN0YXRpYyBiZWZvcmVTZXRJbnN0YW5jZShjb25maWcsIERlZmF1bHRDbGFzcz1udWxsLCBkZWZhdWx0VmFsdWVzPXt9KSB7XG4gICAgICAgIGxldCBjb25maWdUeXBlID0gTmVvLnR5cGVPZihjb25maWcpO1xuXG4gICAgICAgIGlmIChOZW8uaXNTdHJpbmcoRGVmYXVsdENsYXNzKSkge1xuICAgICAgICAgICAgRGVmYXVsdENsYXNzID0gTmVvLm5zKERlZmF1bHRDbGFzcylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY29uZmlnICYmIERlZmF1bHRDbGFzcykge1xuICAgICAgICAgICAgY29uZmlnID0gTmVvLmNyZWF0ZShEZWZhdWx0Q2xhc3MsIGRlZmF1bHRWYWx1ZXMpXG4gICAgICAgIH0gZWxzZSBpZiAoY29uZmlnVHlwZSA9PT0gJ05lb0NsYXNzJykge1xuICAgICAgICAgICAgY29uZmlnID0gTmVvLmNyZWF0ZShjb25maWcsIGRlZmF1bHRWYWx1ZXMpXG4gICAgICAgIH0gZWxzZSBpZiAoY29uZmlnVHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICAgICAgICAgIGlmIChjb25maWcubnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjb25maWcgPSBOZW8ubnR5cGUoe1xuICAgICAgICAgICAgICAgICAgICAuLi5kZWZhdWx0VmFsdWVzLFxuICAgICAgICAgICAgICAgICAgICAuLi5jb25maWdcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV3Q29uZmlnID0ge307XG5cbiAgICAgICAgICAgICAgICBpZiAoRGVmYXVsdENsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbmZpZy5tb2R1bGUgPSBEZWZhdWx0Q2xhc3NcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKG5ld0NvbmZpZywge1xuICAgICAgICAgICAgICAgICAgICAuLi5kZWZhdWx0VmFsdWVzLFxuICAgICAgICAgICAgICAgICAgICAuLi5jb25maWdcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGNvbmZpZyA9IE5lby5jcmVhdGUobmV3Q29uZmlnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZ1R5cGUgPT09ICdOZW9JbnN0YW5jZScpIHtcbiAgICAgICAgICAgIGlmIChkZWZhdWx0VmFsdWVzPy5saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBjb25maWcub24oZGVmYXVsdFZhbHVlcy5saXN0ZW5lcnMpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uZmlnXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhDbGFzc1N5c3RlbSk7XG4iLCJjb25zdCBvcmlnaW5hbE1ldGhvZFN5bWJvbCA9IFN5bWJvbCgnb3JpZ2luYWxNZXRob2QnKTtcbmNvbnN0IHNlcXVlbmNlZEZuc1N5bWJvbCAgID0gU3ltYm9sKCdzZXF1ZW5jZWRGbnMnKTtcblxuLyoqXG4gKiBBcHBlbmQgYXJncyBpbnN0ZWFkIG9mIHByZXBlbmRpbmcgdGhlbVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZVxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZEFwcGVuZChmbiwgc2NvcGUpIHtcbiAgICBjb25zdCBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLnNsaWNlKDIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkoc2NvcGUsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5jb25jYXQoYXJncykpXG4gICAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcGFyYW0ge05lby5jb3JlLkJhc2V9IHNjb3BlXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsYXk9MzAwXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWZmZXIoY2FsbGJhY2ssIHNjb3BlLCBkZWxheT0zMDApIHtcbiAgICBsZXQgdGltZW91dElkO1xuXG4gICAgY29uc3Qgd3JhcHBlciA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gY2FsbGJhY2sgaW52b2NhdGlvbiBjb21lcyBcImRlbGF5XCIgbXMgYWZ0ZXIgdGhlIGxhc3QgY2FsbCB0byB3cmFwcGVyXG4gICAgICAgIC8vIHNvIGNhbmNlbCBhbnkgcGVuZGluZyBpbnZvY2F0aW9uLlxuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcblxuICAgICAgICB3cmFwcGVyLmlzUGVuZGluZyA9IHRydWU7XG5cbiAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aW1lb3V0SWQgPSAwO1xuICAgICAgICAgICAgd3JhcHBlci5pc1BlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHNjb3BlLCBhcmdzKVxuICAgICAgICB9LCBkZWxheSlcbiAgICB9O1xuXG4gICAgd3JhcHBlci5jYW5jZWwgPSAoKSA9PiB7XG4gICAgICAgIHdyYXBwZXIuaXNQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpXG4gICAgfTtcblxuICAgIHJldHVybiB3cmFwcGVyXG59XG5cbi8qKlxuICogSW50ZW5kZWQgZm9yIGZ1bmN0aW9ucyB3aXRoIDEgcGFyYW0gd2hlcmUgdGhlIGludGVyY2VwdG9yIGNhbiBjaGFuZ2UgdGhlIHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gdGFyZ2V0TWV0aG9kTmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gaW50ZXJjZXB0RnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZT10YXJnZXRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUludGVyY2VwdG9yKHRhcmdldCwgdGFyZ2V0TWV0aG9kTmFtZSwgaW50ZXJjZXB0RnVuY3Rpb24sIHNjb3BlKSB7XG4gICAgbGV0IHRhcmdldE1ldGhvZCA9IHRhcmdldFt0YXJnZXRNZXRob2ROYW1lXTtcblxuICAgIHJldHVybiAodGFyZ2V0W3RhcmdldE1ldGhvZE5hbWVdID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldE1ldGhvZC5jYWxsKHRhcmdldCwgaW50ZXJjZXB0RnVuY3Rpb24uY2FsbChzY29wZSB8fCB0YXJnZXQsIHZhbHVlKSlcbiAgICB9KVxufVxuXG4vKipcbiAqIEBwYXJhbSB7TmVvLmNvcmUuQmFzZX0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kTmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZVxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VxdWVuY2UodGFyZ2V0LCBtZXRob2ROYW1lLCBmbiwgc2NvcGUpIHtcbiAgICBsZXQgY3VycmVudE1ldGhvZCA9IHRhcmdldFttZXRob2ROYW1lXSxcbiAgICAgICAgd3JhcHBlcjtcblxuICAgIGlmIChjdXJyZW50TWV0aG9kICYmIGN1cnJlbnRNZXRob2Rbc2VxdWVuY2VkRm5zU3ltYm9sXSkge1xuICAgICAgICAvLyBBbHJlYWR5IGEgc2VxdWVuY2VkIG1ldGhvZCwgYWRkIHRvIGl0cyBsaXN0XG4gICAgICAgIHdyYXBwZXIgPSBjdXJyZW50TWV0aG9kO1xuICAgICAgICB3cmFwcGVyW3NlcXVlbmNlZEZuc1N5bWJvbF0ucHVzaCh7Zm4sIHNjb3BlfSlcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGaXJzdCB0aW1lIHNlcXVlbmNpbmcgdGhpcyBtZXRob2RcbiAgICAgICAgbGV0IG9yaWdpbmFsTWV0aG9kID0gY3VycmVudE1ldGhvZCB8fCBOZW8uZW1wdHlGbjtcblxuICAgICAgICB3cmFwcGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBvcmlnaW5hbE1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBDYWxsIHRoZSBvcmlnaW5hbCBtZXRob2RcblxuICAgICAgICAgICAgLy8gQ2FsbCBhbGwgc2VxdWVuY2VkIGZ1bmN0aW9uc1xuICAgICAgICAgICAgd3JhcHBlcltzZXF1ZW5jZWRGbnNTeW1ib2xdLmZvckVhY2goc2VxRm4gPT4ge1xuICAgICAgICAgICAgICAgIHNlcUZuLmZuLmFwcGx5KHNlcUZuLnNjb3BlIHx8IHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgd3JhcHBlcltzZXF1ZW5jZWRGbnNTeW1ib2xdID0gW3tmbiwgc2NvcGV9XTtcbiAgICAgICAgd3JhcHBlcltvcmlnaW5hbE1ldGhvZFN5bWJvbF0gPSBvcmlnaW5hbE1ldGhvZDsgLy8gU3RvcmUgb3JpZ2luYWwgbWV0aG9kXG4gICAgfVxuXG4gICAgcmV0dXJuICh0YXJnZXRbbWV0aG9kTmFtZV0gPSB3cmFwcGVyKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHBhcmFtIHtOZW8uY29yZS5CYXNlfSBzY29wZVxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5PTMwMFxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVib3VuY2UoY2FsbGJhY2ssIHNjb3BlLCBkZWxheT0zMDApIHtcbiAgICBsZXQgZGVib3VuY2VUaW1lcjtcblxuICAgIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICAgIC8vIGxlYWRpbmcgZWRnZSA9PiB0cmlnZ2VyIHRoZSBmaXJzdCBjYWxsIHJpZ2h0IGF3YXlcbiAgICAgICAgaWYgKCFOZW8uaXNOdW1iZXIoZGVib3VuY2VUaW1lcikpIHtcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlIHNjb3BlIChpbnN0YW5jZSkgZGlkIG5vdCBnZXQgZGVzdHJveWVkIHlldFxuICAgICAgICAgICAgc2NvcGU/LmlkICYmIGNhbGxiYWNrLmFwcGx5KHNjb3BlLCBhcmdzKTtcblxuICAgICAgICAgICAgLy8gd2Ugc3RpbGwgd2FudCB0byBzdGFydCBhIHRpbWVyIHRvIGRlbGF5IHRoZSAybmQrIHVwZGF0ZVxuICAgICAgICAgICAgZGVib3VuY2VUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge2RlYm91bmNlVGltZXIgPSBudWxsfSwgIGRlbGF5KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGRlYm91bmNlVGltZXIpO1xuXG4gICAgICAgICAgICBkZWJvdW5jZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBjaGVjayBpZiB0aGUgc2NvcGUgKGluc3RhbmNlKSBkaWQgbm90IGdldCBkZXN0cm95ZWQgeWV0XG4gICAgICAgICAgICAgICAgc2NvcGU/LmlkICYmIGNhbGxiYWNrLmFwcGx5KHNjb3BlLCBhcmdzKTtcbiAgICAgICAgICAgICAgICBkZWJvdW5jZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7ZGVib3VuY2VUaW1lciA9IG51bGx9LCAgZGVsYXkpXG4gICAgICAgICAgICB9LCAgZGVsYXkpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogVGhlIGludGVyY2VwdG9yIGNhbiBwcmV2ZW50IHRoZSB0YXJnZXRNZXRob2QgZnJvbSBnZXR0aW5nIGV4ZWN1dGVkIGluIGNhc2UgaXQgcmV0dXJucyBmYWxzZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0YXJnZXRNZXRob2ROYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnRlcmNlcHRGdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3R9IHNjb3BlPXRhcmdldFxuICogQHBhcmFtIHsqfSBwcmV2ZW50ZWRSZXR1cm5WYWx1ZT1udWxsIFRoZSB2YWx1ZSB0byByZXR1cm4gaW4gY2FzZSB0aGUgaW50ZXJjZXB0RnVuY3Rpb24gcmV0dXJucyBmYWxzZVxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJjZXB0KHRhcmdldCwgdGFyZ2V0TWV0aG9kTmFtZSwgaW50ZXJjZXB0RnVuY3Rpb24sIHNjb3BlLCBwcmV2ZW50ZWRSZXR1cm5WYWx1ZT1udWxsKSB7XG4gICAgbGV0IHRhcmdldE1ldGhvZCA9IHRhcmdldFt0YXJnZXRNZXRob2ROYW1lXTtcblxuICAgIHJldHVybiAodGFyZ2V0W3RhcmdldE1ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAoaW50ZXJjZXB0RnVuY3Rpb24uYXBwbHkoc2NvcGUgfHwgdGFyZ2V0LCBhcmd1bWVudHMpID09PSBmYWxzZSlcbiAgICAgICAgICAgID8gcHJldmVudGVkUmV0dXJuVmFsdWVcbiAgICAgICAgICAgIDogdGFyZ2V0TWV0aG9kLmFwcGx5KHRhcmdldCwgYXJndW1lbnRzKVxuICAgIH0pXG59XG5cbi8qKlxuICogTG9jYXRlIGEgY2FsbGFibGUgZnVuY3Rpb24gYnkgbmFtZSBpbiB0aGUgcGFzc2VkIHNjb3BlLlxuICpcbiAqIElmIHRoZSBuYW1lIHN0YXJ0cyB3aXRoICd1cC4nLCB0aGUgcGFyZW50IENvbXBvbmVudCBjaGFpbiBpcyBzZWFyY2hlZC5cbiAqXG4gKiBUaGlzIGlzIHVzZWQgYnkgbWFuYWdlci5Eb21FdmVudHMgJiBjb3JlLk9ic2VydmFibGUuZmlyZSBhbmQgYnkgJ2hhbmRsZXInIGZ1bmN0aW9uIGNhbGxzIHRvIHJlc29sdmVcbiAqIHN0cmluZyBmdW5jdGlvbiBuYW1lcyBpbiB0aGUgQ29tcG9uZW50J3Mgb3duIGhpZXJhcmNoeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBmbiBBIGZ1bmN0aW9uLCBvciB0aGUgbmFtZSBvZiBhIGZ1bmN0aW9uIHRvIGZpbmQgaW4gdGhlIHBhc3NlZCBzY29wZSBvYmplY3QvXG4gKiBAcGFyYW0ge09iamVjdH0gc2NvcGU9dGhpcyBUaGUgc2NvcGUgdG8gZmluZCB0aGUgZnVuY3Rpb24gaW4gaWYgaXQgaXMgc3BlY2lmaWVkIGFzIGEgc3RyaW5nLlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVDYWxsYmFjayhmbiwgc2NvcGU9dGhpcykge1xuICAgIGlmIChOZW8uaXNTdHJpbmcoZm4pKSB7XG4gICAgICAgIGlmICghc2NvcGVbZm5dICYmIGZuLnN0YXJ0c1dpdGgoJ3VwLicpKSB7XG4gICAgICAgICAgICBmbiA9IGZuLnNsaWNlKDMpO1xuICAgICAgICAgICAgd2hpbGUgKCFzY29wZVtmbl0gJiYgKHNjb3BlID0gc2NvcGUucGFyZW50KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY29wZSA9IHNjb3BlLmdldENvbnRyb2xsZXI/LigpPy5nZXRIYW5kbGVyU2NvcGUoZm4sIG51bGwpIHx8IHNjb3BlXG4gICAgICAgIH1cblxuICAgICAgICBmbiA9IHNjb3BlW2ZuXVxuICAgIH1cblxuICAgIHJldHVybiB7Zm4sIHNjb3BlfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcGFyYW0ge05lby5jb3JlLkJhc2V9IHNjb3BlXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsYXk9MzAwXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aHJvdHRsZShjYWxsYmFjaywgc2NvcGUsIGRlbGF5PTMwMCkge1xuICAgIGxldCBsYXN0UmFuRGF0ZSwgdGltZW91dElkO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKCFsYXN0UmFuRGF0ZSkge1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBjaGVjayBpZiB0aGUgc2NvcGUgKGluc3RhbmNlKSBkaWQgbm90IGdldCBkZXN0cm95ZWQgeWV0XG4gICAgICAgICAgICBzY29wZT8uaWQgJiYgY2FsbGJhY2suYXBwbHkoc2NvcGUsIGFyZ3MpO1xuXG4gICAgICAgICAgICBsYXN0UmFuRGF0ZSA9IERhdGUubm93KClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpXG5cbiAgICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKChEYXRlLm5vdygpIC0gbGFzdFJhbkRhdGUpID49IGRlbGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlIHNjb3BlIChpbnN0YW5jZSkgZGlkIG5vdCBnZXQgZGVzdHJveWVkIHlldFxuICAgICAgICAgICAgICAgICAgICBzY29wZT8uaWQgJiYgY2FsbGJhY2suYXBwbHkoc2NvcGUsIGFyZ3MpO1xuXG4gICAgICAgICAgICAgICAgICAgIGxhc3RSYW5EYXRlID0gRGF0ZS5ub3coKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGRlbGF5IC0gKERhdGUubm93KCkgLSBsYXN0UmFuRGF0ZSkpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtOZW8uY29yZS5CYXNlfSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2ROYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtPYmplY3R9IHNjb3BlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1blNlcXVlbmNlKHRhcmdldCwgbWV0aG9kTmFtZSwgZm4sIHNjb3BlKSB7XG4gICAgbGV0IGN1cnJlbnRNZXRob2QgPSB0YXJnZXRbbWV0aG9kTmFtZV07XG5cbiAgICBpZiAoIWN1cnJlbnRNZXRob2QgfHwgIWN1cnJlbnRNZXRob2Rbc2VxdWVuY2VkRm5zU3ltYm9sXSkge1xuICAgICAgICByZXR1cm4gLy8gTm90IGEgc2VxdWVuY2VkIG1ldGhvZFxuICAgIH1cblxuICAgIGNvbnN0IHNlcXVlbmNlZEZ1bmN0aW9ucyA9IGN1cnJlbnRNZXRob2Rbc2VxdWVuY2VkRm5zU3ltYm9sXTtcblxuICAgIC8vIEZpbHRlciBvdXQgdGhlIGZ1bmN0aW9uIHRvIHVuc2VxdWVuY2VcbiAgICBjdXJyZW50TWV0aG9kW3NlcXVlbmNlZEZuc1N5bWJvbF0gPSBzZXF1ZW5jZWRGdW5jdGlvbnMuZmlsdGVyKHNlcUZuID0+XG4gICAgICAgICEoc2VxRm4uZm4gPT09IGZuICYmIHNlcUZuLnNjb3BlID09PSBzY29wZSlcbiAgICApO1xuXG4gICAgaWYgKGN1cnJlbnRNZXRob2Rbc2VxdWVuY2VkRm5zU3ltYm9sXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gSWYgbm8gZnVuY3Rpb25zIGxlZnQsIHJlc3RvcmUgdGhlIG9yaWdpbmFsIG1ldGhvZFxuICAgICAgICB0YXJnZXRbbWV0aG9kTmFtZV0gPSBjdXJyZW50TWV0aG9kW29yaWdpbmFsTWV0aG9kU3ltYm9sXVxuICAgIH1cbn1cbiIsImltcG9ydCBCYXNlICAgICAgIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuaW1wb3J0IE9ic2VydmFibGUgZnJvbSAnLi4vY29yZS9PYnNlcnZhYmxlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby51dGlsLkhhc2hIaXN0b3J5XG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKiBAbWl4ZXMgTmVvLmNvcmUuT2JzZXJ2YWJsZVxuICogQHNpbmdsZXRvblxuICovXG5jbGFzcyBIYXNoSGlzdG9yeSBleHRlbmRzIEJhc2Uge1xuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG9ic2VydmFibGU9dHJ1ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgb2JzZXJ2YWJsZSA9IHRydWVcblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnV0aWwuSGFzaEhpc3RvcnknXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby51dGlsLkhhc2hIaXN0b3J5JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZXRvbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZXRvbjogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gbWF4SXRlbXM9NTBcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbWF4SXRlbXM6IDUwLFxuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcmluZyBvbmUgc3RhY2sgcGVyIHdpbmRvd0lkXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gc3RhY2tzPXt9XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHN0YWNrczoge31cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbd2luZG93SWRdXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBmaXJzdCh3aW5kb3dJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBdCgwLCB3aW5kb3dJZClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3dpbmRvd0lkXVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0QXQoaW5kZXgsIHdpbmRvd0lkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0YWNrKHdpbmRvd0lkKVtpbmRleF1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3dpbmRvd0lkXVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0Q291bnQod2luZG93SWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhY2sod2luZG93SWQpLmxlbmd0aFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbd2luZG93SWRdXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRTdGFjayh3aW5kb3dJZCkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3N0YWNrc30gPSBtZSxcbiAgICAgICAgICAgIHN0YWNrSWQgID0gd2luZG93SWQgfHwgT2JqZWN0LmtleXMoc3RhY2tzKVswXSxcbiAgICAgICAgICAgIHN0YWNrICAgID0gc3RhY2tzW3N0YWNrSWRdO1xuXG4gICAgICAgIGlmICghc3RhY2spIHtcbiAgICAgICAgICAgIHN0YWNrc1tzdGFja0lkXSA9IHN0YWNrID0gW11cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdGFja1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuYXBwTmFtZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhLmhhc2hcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5oYXNoU3RyaW5nXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEud2luZG93SWRcbiAgICAgKi9cbiAgICBwdXNoKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3dpbmRvd0lkfSA9IGRhdGEsXG4gICAgICAgICAgICBzdGFjayAgICAgID0gbWUuZ2V0U3RhY2sod2luZG93SWQpO1xuXG4gICAgICAgIGlmIChzdGFja1swXT8uaGFzaFN0cmluZyAhPT0gZGF0YS5oYXNoU3RyaW5nKSB7XG4gICAgICAgICAgICBkZWxldGUgZGF0YVt3aW5kb3dJZF07XG4gICAgICAgICAgICBzdGFjay51bnNoaWZ0KGRhdGEpO1xuXG4gICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gbWUubWF4SXRlbXMpIHtcbiAgICAgICAgICAgICAgICBzdGFjay5wb3AoKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5maXJlKCdjaGFuZ2UnLCBkYXRhLCBzdGFja1sxXSB8fCBudWxsKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3dpbmRvd0lkXVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgc2Vjb25kKHdpbmRvd0lkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEF0KDAsIHdpbmRvd0lkKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoSGFzaEhpc3RvcnkpO1xuIiwiaW1wb3J0IEJhc2UgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby51dGlsLkxvZ2dlclxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICogQHNpbmdsZXRvblxuICovXG5jbGFzcyBMb2dnZXIgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby51dGlsLkxvZ2dlcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnV0aWwuTG9nZ2VyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgbWluaW11bSBsZXZlbCwgd2hpY2ggeW91IHdhbnQgdG8gb3V0cHV0LlxuICAgICAgICAgKiBDaGFuZ2UgdGhpcyBhdCBhbnkgdGltZSB1c2luZyBhIHZhbHVlIG9mIGxvZ0xldmVsczogWydpbmZvJywgJ2xvZycsICd3YXJuJywgJ2Vycm9yJ11cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIE5lby51dGlsLkxvZ2dlci5sZXZlbCA9ICdlcnJvcidcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBsZXZlbD0naW5mbydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbGV2ZWxfOiAnaW5mbycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBlbmFibGVMb2dzPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2luZ2xldG9uOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBsb2dDaGFyXG4gICAgICovXG4gICAgbG9nQ2hhcnMgID0ge1xuICAgICAgICBlcnJvcjogJ0UnLFxuICAgICAgICBpbmZvIDogJ0knLFxuICAgICAgICBsb2cgIDogJ0wnLFxuICAgICAgICB3YXJuIDogJ1cnXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gY29sb3JzXG4gICAgICovXG4gICAgbG9nQ29sb3JzID0ge1xuICAgICAgICBlcnJvcjogJ2luZGlhbnJlZCcsXG4gICAgICAgIGluZm8gOiAnI2FjYWNhYycsXG4gICAgICAgIGxvZyAgOiAnIzQ0ODg4OCcsXG4gICAgICAgIHdhcm4gOiAnIzZkNmQwMCdcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9nTGV2ZWxzXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IGxvZ0xldmVsc1xuICAgICAqL1xuICAgIGxvZ0xldmVscyA9IFsnaW5mbycsICdsb2cnLCAnd2FybicsICdlcnJvciddXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIC8vIGFsaWFzZXNcbiAgICAgICAgTmVvLmFwcGx5RnJvbU5zKE5lbywgbWUsIHtcbiAgICAgICAgICAgIGVycm9yICAgOiAnZXJyb3InLFxuICAgICAgICAgICAgaW5mbyAgICA6ICdpbmZvJyxcbiAgICAgICAgICAgIGxvZyAgICAgOiAnbG9nJyxcbiAgICAgICAgICAgIGxvZ0Vycm9yOiAnbG9nRXJyb3InLFxuICAgICAgICAgICAgd2FybiAgICA6ICd3YXJuJ1xuICAgICAgICB9LCB0cnVlKTtcblxuICAgICAgICBtZS50aW1lb3V0KDUwKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmICghTmVvLmNvbmZpZy5lbmFibGVMb2dzSW5Qcm9kdWN0aW9uICYmIE5lby5jb25maWcuZW52aXJvbm1lbnQgPT09ICdkaXN0L3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgbWUud3JpdGUgPSBOZW8uZW1wdHlGblxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBsZXZlbCB0byBudW1iZXIgYmFzZWQgb24gcG9zaXRpb24gaW4gbG9nTGV2ZWxzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICovXG4gICAgYmVmb3JlU2V0TGV2ZWwodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvZ0xldmVscy5pbmRleE9mKHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIGVycm9yKHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih2YWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBpbnRlcm5hbCBoZWxwZXIgdG8gY2F0Y2ggY2FsbGVyXG4gICAgICogbm8ga25vd24gbmF0aXZlIHdheSBpbiBtb2Rlcm4gSlMgdG8ga25vdyB3aGF0IGZpbGUgdGhhdCB0cmlnZ2VyZWQgdGhlIGN1cnJlbnQgbWV0aG9kXG4gICAgICogdGhlcmVmb3JlIHdlIHVzZSBFcnJvciwgd2UgY2FuIGdldCB0aGUgY2FsbGVyIGZpbGUgZnJvbSB0aGUgc3RhY2sgdHJhY2Ugc3RyaW5nLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldENhbGxlcigpIHtcbiAgICAgICAgbGV0IGNhbGxlcl9wYXRoID0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgZXJyICAgICAgICAgPSBuZXcgRXJyb3IoKSxcbiAgICAgICAgICAgIHN0YWNrX2xpbmVzID0gZXJyLnN0YWNrLnNwbGl0KCdcXG4nKSxcbiAgICAgICAgICAgIGZvdW5kX3RoaXMgID0gZmFsc2UsXG4gICAgICAgICAgICBpLCBsaW5lO1xuXG4gICAgICAgIGZvciAoaSBpbiBzdGFja19saW5lcykge1xuICAgICAgICAgICAgbGluZSA9IHN0YWNrX2xpbmVzW2ldO1xuXG4gICAgICAgICAgICBpZiAoIWZvdW5kX3RoaXMgJiYgL0xvZ2dlclxcLm1qcy8udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICAgIGZvdW5kX3RoaXMgPSB0cnVlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvdW5kX3RoaXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIS9Mb2dnZXJcXC5tanMvLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBjbG9zaW5nIClcbiAgICAgICAgICAgICAgICAgICAgbGluZSAgICAgICAgPSBsaW5lLnJlcGxhY2UoJyknLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgcGFydCBhZnRlciB0aGUgbGFzdCAvXG4gICAgICAgICAgICAgICAgICAgIGNhbGxlcl9wYXRoID0gbGluZS5tYXRjaCgvKFteXFwvXSspJC8pWzFdLm1hdGNoKC8oW14gXSspJC8pWzFdO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNhbGxlcl9wYXRoXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICBpbmZvKC4uLmFyZ3MpIHtcbiAgICAgICAgYXJncyA9IHRoaXMucmVzb2x2ZUFyZ3MoLi4uYXJncyk7XG4gICAgICAgIHRoaXMud3JpdGUoYXJncywgJ2luZm8nKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICovXG4gICAgbG9nKC4uLmFyZ3MpIHtcbiAgICAgICAgYXJncyA9IHRoaXMucmVzb2x2ZUFyZ3MoLi4uYXJncyk7XG4gICAgICAgIHRoaXMud3JpdGUoYXJncywgJ2xvZycpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICBsb2dFcnJvciguLi5hcmdzKSB7XG4gICAgICAgIGFyZ3MgPSB0aGlzLnJlc29sdmVBcmdzKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLndyaXRlKGFyZ3MsICdlcnJvcicpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkNvbnRleHRNZW51KGRhdGEpIHtcbiAgICAgICAgbGV0IHtjb25maWd9ID0gTmVvO1xuXG4gICAgICAgIGlmIChjb25maWcuZW5hYmxlQ29tcG9uZW50TG9nZ2VyICYmICEoY29uZmlnLmVudiA9PT0gJ2Rpc3QvcHJvZHVjdGlvbicgJiYgY29uZmlnLmVuYWJsZUxvZ3NJblByb2R1Y3Rpb24pKSB7XG4gICAgICAgICAgICBsZXQgaXNHcm91cFNldCA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudDtcblxuICAgICAgICAgICAgZGF0YS5wYXRoLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50ID0gTmVvLmdldENvbXBvbmVudChpdGVtLmlkLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNHcm91cFNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNHcm91cFNldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmdyb3VwKGl0ZW0uaWQpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhjb21wb25lbnQpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlzR3JvdXBTZXQgJiYgY29uc29sZS5ncm91cEVuZCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBoZWxwZXIgZm9yIGFyZ3NcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcmVzb2x2ZUFyZ3MoLi4uYXJncykge1xuICAgICAgICBsZXQgaWRlbnRpZmllciA9IGFyZ3NbMF0sXG4gICAgICAgICAgICBhcmdzT2JqZWN0ID0ge307XG5cbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBpZiAoTmVvLmlzU3RyaW5nKGlkZW50aWZpZXIpKSB7XG4gICAgICAgICAgICAgICAgYXJnc09iamVjdC5tc2cgPSBhcmdzWzBdXG4gICAgICAgICAgICB9IGVsc2UgaWYgKE5lby5pc09iamVjdChpZGVudGlmaWVyKSkge1xuICAgICAgICAgICAgICAgIGFyZ3NPYmplY3QgPSBpZGVudGlmaWVyXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICBhcmdzT2JqZWN0Lm1zZyAgPSBhcmdzWzBdO1xuICAgICAgICAgICAgYXJnc09iamVjdC5kYXRhID0gYXJncy5zbGljZSgxKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFyZ3NPYmplY3RcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqL1xuICAgIHdhcm4oLi4uYXJncykge1xuICAgICAgICBhcmdzID0gdGhpcy5yZXNvbHZlQXJncyguLi5hcmdzKTtcbiAgICAgICAgdGhpcy53cml0ZShhcmdzLCAnd2FybicpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3V0cHV0IG1ldGhvZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxldmVsXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHdyaXRlKGFyZ3MsIGxldmVsKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmJlZm9yZVNldExldmVsKGxldmVsKSA8IG1lLmxldmVsKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKCcjJywgYXJncy5tc2csIGxldmVsKTtcblxuICAgICAgICBsZXQgbG9nQ29sb3IgPSBtZS5sb2dDb2xvcnNbbGV2ZWxdLFxuICAgICAgICAgICAgbG9nQ2hhciAgPSBtZS5sb2dDaGFyc1tsZXZlbF0sXG4gICAgICAgICAgICBiZyAgICAgICA9IGBiYWNrZ3JvdW5kLWNvbG9yOiR7bG9nQ29sb3J9OyBjb2xvcjogd2hpdGU7IGZvbnQtd2VpZ2h0OiA5MDA7YCxcbiAgICAgICAgICAgIGNvbG9yICAgID0gYGNvbG9yOiR7bG9nQ29sb3J9O2AsXG4gICAgICAgICAgICBtc2cgICAgICA9IGBbJHttZS5nZXRDYWxsZXIoKX1dICR7YXJncy5tc2d9YDtcblxuICAgICAgICBpZiAoYXJncy5kYXRhKSB7XG4gICAgICAgICAgICBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKGAlYyAke2xvZ0NoYXJ9ICVjICR7bXNnfWAsIGJnLCBjb2xvcilcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGFyZ3MuZGF0YSk7XG4gICAgICAgICAgICBjb25zb2xlLmdyb3VwRW5kKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAlYyAke2xvZ0NoYXJ9ICVjICR7bXNnfWAsIGJnLCBjb2xvcilcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoTG9nZ2VyKTtcbiIsImltcG9ydCBCYXNlICAgICAgICAgICAgIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuaW1wb3J0IENvbXBvbmVudE1hbmFnZXIgZnJvbSAnLi4vbWFuYWdlci9Db21wb25lbnQubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnV0aWwuVkRvbVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBWRG9tIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8udXRpbC5WRG9tJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8udXRpbC5WRG9tJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2ZG9tXG4gICAgICogQHBhcmFtIHtCb29sZWFufSByZW1vdmVJZHM9dHJ1ZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGNsb25lZCB2ZG9tXG4gICAgICovXG4gICAgc3RhdGljIGNsb25lKHZkb20sIHJlbW92ZUlkcz10cnVlKSB7XG4gICAgICAgIGxldCBjbG9uZSA9IE5lby5jbG9uZSh2ZG9tLCB0cnVlKTtcblxuICAgICAgICBpZiAocmVtb3ZlSWRzKSB7XG4gICAgICAgICAgICBkZWxldGUgY2xvbmUuaWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbG9uZS5jbikge1xuICAgICAgICAgICAgY2xvbmUuY24uZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBjbG9uZS5jbltpbmRleF0gPSBWRG9tLmNsb25lKGl0ZW0sIHJlbW92ZUlkcylcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xvbmVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWFyY2ggdmRvbSBjaGlsZCBub2RlcyBieSBpZCBvciBvcHRzIG9iamVjdCBmb3IgYSBnaXZlbiB2ZG9tIHRyZWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmRvbVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gb3B0cyBFaXRoZXIgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdmRvbSBub2RlIGF0dHJpYnV0ZXMgb3IgYSBzdHJpbmcgYmFzZWQgaWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlcGxhY2VDb21wb25lbnRSZWZzPXRydWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2luZGV4XSBJbnRlcm5hbCBmbGFnLCBkbyBub3QgdXNlIGl0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJlbnROb2RlXSBJbnRlcm5hbCBmbGFnLCBkbyBub3QgdXNlIGl0XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiAgICAge051bWJlcn0gaW5kZXhcbiAgICAgKiAgICAge1N0cmluZ30gcGFyZW50SWRcbiAgICAgKiAgICAge09iamVjdH0gdmRvbVxuICAgICAqL1xuICAgIHN0YXRpYyBmaW5kKHZkb20sIG9wdHMsIHJlcGxhY2VDb21wb25lbnRSZWZzPXRydWUsIGluZGV4LCBwYXJlbnROb2RlKSB7XG4gICAgICAgIGluZGV4ID0gaW5kZXggfHwgMDtcbiAgICAgICAgb3B0cyAgPSAhTmVvLmlzU3RyaW5nKG9wdHMpID8gb3B0cyA6IHtpZDogb3B0c307XG5cbiAgICAgICAgaWYgKHJlcGxhY2VDb21wb25lbnRSZWZzKSB7XG4gICAgICAgICAgICB2ZG9tID0gVkRvbS5nZXRWZG9tKHZkb20pXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY2hpbGQgICAgICA9IG51bGwsXG4gICAgICAgICAgICBtYXRjaEFycmF5ID0gW10sXG4gICAgICAgICAgICBzdHlsZU1hdGNoID0gdHJ1ZSxcbiAgICAgICAgICAgIGkgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgbGVuICAgICAgICA9IHZkb20uY24/Lmxlbmd0aCxcbiAgICAgICAgICAgIG9wdHNBcnJheSAgPSBPYmplY3QuZW50cmllcyhvcHRzKSxcbiAgICAgICAgICAgIG9wdHNMZW5ndGggPSBvcHRzQXJyYXkubGVuZ3RoLFxuICAgICAgICAgICAgc3ViQ2hpbGQ7XG5cbiAgICAgICAgb3B0c0FycmF5LmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZkb20uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Nscyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiBOZW8uaXNBcnJheSh2ZG9tW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZkb21ba2V5XS5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hBcnJheS5wdXNoKHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHR5cGVvZiB2ZG9tW2tleV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZkb21ba2V5XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hBcnJheS5wdXNoKHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChOZW8uaXNBcnJheSh2YWx1ZSkgJiYgTmVvLmlzQXJyYXkodmRvbVtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvZG86IGVpdGhlciBzZWFyY2ggdGhlIHZkb20gYXJyYXkgZm9yIGFsbCBrZXlzIG9yIGNvbXBhcmUgaWYgdGhlIGFycmF5cyBhcmUgZXF1YWwuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaW5kOiBjbHMgbWF0Y2hpbmcgbm90IHN1cHBvcnRlZCBmb3IgdGFyZ2V0ICYgc291cmNlIHR5cGVzIG9mIEFycmF5cycpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzdHlsZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmRvbVtrZXldID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ZG9tW2tleV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoQXJyYXkucHVzaCh0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoTmVvLmlzT2JqZWN0KHZhbHVlKSAmJiBOZW8uaXNPYmplY3QodmRvbVtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5mb3JFYWNoKChbc3R5bGVLZXksIHN0eWxlVmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHZkb21ba2V5XS5oYXNPd25Qcm9wZXJ0eShzdHlsZUtleSkgJiYgdmRvbVtrZXldW3N0eWxlS2V5XSA9PT0gc3R5bGVWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlTWF0Y2ggPSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEFycmF5LnB1c2godHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmluZDogc3R5bGUgbWF0Y2hpbmcgbm90IHN1cHBvcnRlZCBmb3IgbWl4ZWQgdGFyZ2V0ICYgc291cmNlIHR5cGVzIChPYmplY3QgVlMgU3RyaW5nKScpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZkb21ba2V5XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEFycmF5LnB1c2godHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobWF0Y2hBcnJheS5sZW5ndGggPT09IG9wdHNMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB7aW5kZXgsIHBhcmVudE5vZGUsIHZkb219XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmRvbS5jbikge1xuICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh2ZG9tLmNuW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YkNoaWxkID0gVkRvbS5maW5kKHZkb20uY25baV0sIG9wdHMsIHJlcGxhY2VDb21wb25lbnRSZWZzLCBpLCB2ZG9tKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc3ViQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ICAgICA6IHN1YkNoaWxkLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGU6IHN1YkNoaWxkLnBhcmVudE5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmRvbSAgICAgIDogc3ViQ2hpbGQudmRvbVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hpbGRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dCBmb3IgZmluZCh2ZG9tLCB7ZmxhZzogZmxhZ30pO1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2ZG9tXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZsYWcgVGhlIGZsYWcgcmVmZXJlbmNlIHNwZWNpZmllZCBvbiB0aGUgdGFyZ2V0IHZkb20gY2hpbGQgbm9kZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHZkb21cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0QnlGbGFnKHZkb20sIGZsYWcpIHtcbiAgICAgICAgcmV0dXJuIFZEb20uZmluZCh2ZG9tLCB7ZmxhZ30pPy52ZG9tXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpZHMgb2YgYWxsIGNoaWxkIG5vZGVzIG9mIHRoZSBnaXZlbiB2ZG9tIHRyZWVcbiAgICAgKiBAcGFyYW0gdmRvbVxuICAgICAqIEBwYXJhbSBbY2hpbGRJZHM9W11dXG4gICAgICogQHJldHVybnMge0FycmF5fSBjaGlsZElkc1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXRDaGlsZElkcyh2ZG9tLCBjaGlsZElkcz1bXSkge1xuICAgICAgICB2ZG9tID0gVkRvbS5nZXRWZG9tKHZkb20pO1xuXG4gICAgICAgIGxldCBjaGlsZE5vZGVzID0gdmRvbT8uY24gfHwgW107XG5cbiAgICAgICAgY2hpbGROb2Rlcy5mb3JFYWNoKGNoaWxkTm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlLmlkKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRJZHMucHVzaChjaGlsZE5vZGUuaWQpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoaWxkSWRzID0gVkRvbS5nZXRDaGlsZElkcyhjaGlsZE5vZGUsIGNoaWxkSWRzKVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY2hpbGRJZHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmRvbVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q29sdW1uTm9kZXModmRvbSwgaW5kZXgpIHtcbiAgICAgICAgdmRvbSA9IFZEb20uZ2V0VmRvbSh2ZG9tKTtcblxuICAgICAgICBsZXQgY29sdW1uTm9kZXMgPSBbXTtcblxuICAgICAgICB2ZG9tLmNuPy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgICAgICAgICBpZiAocm93LmNuPy5baW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgY29sdW1uTm9kZXMucHVzaChyb3cuY25baW5kZXhdKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIHJldHVybiBjb2x1bW5Ob2Rlc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2ZG9tXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRDb2x1bW5Ob2Rlc0lkcyh2ZG9tLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gVkRvbS5nZXRDb2x1bW5Ob2Rlcyh2ZG9tLCBpbmRleCkubWFwKGUgPT4gZS5pZClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmRvbVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmbGFnXG4gICAgICogQHBhcmFtIHtBcnJheX0gW21hdGNoQXJyYXldXG4gICAgICogQHJldHVybnMge0FycmF5fSBhbiBhcnJheSBvZiB2ZG9tIG5vZGVzIHdoaWNoIG1hdGNoIHRoZSBmbGFnXG4gICAgICovXG4gICAgc3RhdGljIGdldEZsYWdzKHZkb20sIGZsYWcsIG1hdGNoQXJyYXkpIHtcbiAgICAgICAgdmRvbSA9IFZEb20uZ2V0VmRvbSh2ZG9tKTtcblxuICAgICAgICBpZiAoIW1hdGNoQXJyYXkpIHtcbiAgICAgICAgICAgIG1hdGNoQXJyYXkgPSBbXTtcblxuICAgICAgICAgICAgaWYgKHZkb20uZmxhZyA9PT0gZmxhZykge1xuICAgICAgICAgICAgICAgIG1hdGNoQXJyYXkucHVzaCh2ZG9tKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgKHZkb20/LmNuIHx8IFtdKS5mb3JFYWNoKGNoaWxkTm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlLmZsYWcgPT09IGZsYWcpIHtcbiAgICAgICAgICAgICAgICBtYXRjaEFycmF5LnB1c2goY2hpbGROb2RlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtYXRjaEFycmF5ID0gVkRvbS5nZXRGbGFncyhjaGlsZE5vZGUsIGZsYWcsIG1hdGNoQXJyYXkpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBtYXRjaEFycmF5XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZkb21cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHRvcExldmVsPXRydWUgSW50ZXJuYWwgZmxhZywgZG8gbm90IHVzZSBpdFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0UGFyZW50Tm9kZXModmRvbSwgaWQsIHRvcExldmVsPXRydWUpIHtcbiAgICAgICAgdmRvbSA9IFZEb20uZ2V0VmRvbSh2ZG9tKTtcblxuICAgICAgICBsZXQgcGFyZW50cyA9IG51bGwsXG4gICAgICAgICAgICBpICAgICAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgICAgPSB2ZG9tLmNuPy5sZW5ndGggfHwgMDtcblxuICAgICAgICBpZiAodmRvbS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgcGFyZW50cyA9IFZEb20uZ2V0UGFyZW50Tm9kZXModmRvbS5jbltpXSwgaWQsIGZhbHNlKTtcblxuICAgICAgICAgICAgaWYgKHBhcmVudHMpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRzLnB1c2godmRvbS5jbltpXSk7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b3BMZXZlbCAmJiBwYXJlbnRzKSB7XG4gICAgICAgICAgICBwYXJlbnRzLnB1c2godmRvbSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJlbnRzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXQgdXNpbmcgbWFuYWdlci5Db21wb25lbnQgdG8gcmVwbGFjZSB2ZG9tIHJlZmVyZW5jZXMgaWYgbmVlZGVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZkb21cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRWZG9tKHZkb20pIHtcbiAgICAgICAgaWYgKHZkb20uY29tcG9uZW50SWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IENvbXBvbmVudE1hbmFnZXIuZ2V0KHZkb20uY29tcG9uZW50SWQpO1xuXG4gICAgICAgICAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRpbC5WRG9tLmdldFZkb206IENvbXBvbmVudCBub3QgZm91bmQgZm9yIGlkOiAke3Zkb20uY29tcG9uZW50SWR9YClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmRvbSA9IGNvbXBvbmVudC52ZG9tXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmRvbVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc2VydCBhIGdpdmVuIG5vZGVUb0luc2VydCBhZnRlciBhIHRhcmdldE5vZGUgaW5zaWRlIGEgZ2l2ZW4gdmRvbSB0cmVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZkb20gVGhlIHZkb20gdHJlZSBjb250YWluaW5nIHRoZSB0YXJnZXROb2RlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGVUb0luc2VydCBUaGUgbmV3IHZkb20gdG8gaW5zZXJ0XG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSB0YXJnZXROb2RlSWQgRWl0aGVyIGEgdmRvbSBub2RlIG9yIGEgdmRvbSBub2RlIGlkXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGluc2VydEFmdGVyTm9kZSh2ZG9tLCBub2RlVG9JbnNlcnQsIHRhcmdldE5vZGVJZCkge1xuICAgICAgICByZXR1cm4gVkRvbS5pbnNlcnROb2RlKHZkb20sIG5vZGVUb0luc2VydCwgdGFyZ2V0Tm9kZUlkLCBmYWxzZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnQgYSBnaXZlbiBub2RlVG9JbnNlcnQgYmVmb3JlIGEgdGFyZ2V0Tm9kZSBpbnNpZGUgYSBnaXZlbiB2ZG9tIHRyZWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmRvbSBUaGUgdmRvbSB0cmVlIGNvbnRhaW5pbmcgdGhlIHRhcmdldE5vZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVRvSW5zZXJ0IFRoZSBuZXcgdmRvbSB0byBpbnNlcnRcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHRhcmdldE5vZGVJZCBFaXRoZXIgYSB2ZG9tIG5vZGUgb3IgYSB2ZG9tIG5vZGUgaWRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgaW5zZXJ0QmVmb3JlTm9kZSh2ZG9tLCBub2RlVG9JbnNlcnQsIHRhcmdldE5vZGVJZCkge1xuICAgICAgICByZXR1cm4gVkRvbS5pbnNlcnROb2RlKHZkb20sIG5vZGVUb0luc2VydCwgdGFyZ2V0Tm9kZUlkLCB0cnVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc2VydCBhIGdpdmVuIG5vZGVUb0luc2VydCBiZWZvcmUgYSB0YXJnZXROb2RlIGluc2lkZSBhIGdpdmVuIHZkb20gdHJlZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2ZG9tIFRoZSB2ZG9tIHRyZWUgY29udGFpbmluZyB0aGUgdGFyZ2V0Tm9kZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlVG9JbnNlcnQgVGhlIG5ldyB2ZG9tIHRvIGluc2VydFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gdGFyZ2V0Tm9kZUlkIEVpdGhlciBhIHZkb20gbm9kZSBvciBhIHZkb20gbm9kZSBpZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5zZXJ0QmVmb3JlIHRydWUgaW5zZXJ0cyB0aGUgbmV3IG5vZGUgYXQgdGhlIHNhbWUgaW5kZXgsIGluZGV4KzEgb3RoZXJ3aXNlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGluc2VydE5vZGUodmRvbSwgbm9kZVRvSW5zZXJ0LCB0YXJnZXROb2RlSWQsIGluc2VydEJlZm9yZSkge1xuICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KHRhcmdldE5vZGVJZCkpIHtcbiAgICAgICAgICAgIHRhcmdldE5vZGVJZCA9IHRhcmdldE5vZGVJZC5pZFxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHRhcmdldE5vZGUgPSBWRG9tLmZpbmQodmRvbSwgdGFyZ2V0Tm9kZUlkKSxcbiAgICAgICAgICAgIGluZGV4O1xuXG4gICAgICAgIGlmICh0YXJnZXROb2RlKSB7XG4gICAgICAgICAgICBpbmRleCA9IGluc2VydEJlZm9yZSA/IHRhcmdldE5vZGUuaW5kZXggOiB0YXJnZXROb2RlLmluZGV4ICsgMTtcbiAgICAgICAgICAgIHRhcmdldE5vZGUucGFyZW50Tm9kZS5jbi5zcGxpY2UoaW5kZXgsIDAsIG5vZGVUb0luc2VydCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VhcmNoIHZkb20gY2hpbGQgbm9kZXMgYnkgaWQgb3Igb3B0cyBvYmplY3QgZm9yIGEgZ2l2ZW4gdmRvbSB0cmVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFt2ZG9tXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gb3B0cyBFaXRoZXIgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdmRvbSBub2RlIGF0dHJpYnV0ZXMgb3IgYSBzdHJpbmcgYmFzZWQgaWRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpbiBjYXNlIHRoZSBub2RlIHdhcyBmb3VuZCAmIHJlbW92ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgcmVtb3ZlVmRvbUNoaWxkKHZkb20sIG9wdHMpIHtcbiAgICAgICAgbGV0IGNoaWxkID0gVkRvbS5maW5kKHZkb20sIG9wdHMpO1xuXG4gICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgY2hpbGQucGFyZW50Tm9kZS5jbi5zcGxpY2UoY2hpbGQuaW5kZXgsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIGEgY2hpbGQgbm9kZSBpbnNpZGUgYSB2ZG9tIHRyZWUgYnkgYSBnaXZlbiBpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2ZG9tXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5ld0NoaWxkTm9kZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGluIGNhc2UgdGhlIG5vZGUgd2FzIGZvdW5kIGFuZCByZXBsYWNlZFxuICAgICAqL1xuICAgIHN0YXRpYyByZXBsYWNlVmRvbUNoaWxkKHZkb20sIGlkLCBuZXdDaGlsZE5vZGUpIHtcbiAgICAgICAgdmRvbSA9IFZEb20uZ2V0VmRvbSh2ZG9tKTtcblxuICAgICAgICBsZXQgY24gID0gdmRvbS5jbiB8fCBbXSxcbiAgICAgICAgICAgIGkgICA9IDAsXG4gICAgICAgICAgICBsZW4gPSBjbi5sZW5ndGgsXG4gICAgICAgICAgICBjaGlsZE5vZGU7XG5cbiAgICAgICAgaWYgKHZkb20uaWQgPT09IGlkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcGxhY2VWZG9tQ2hpbGQ6IHRhcmdldCBpZCBtYXRjaGVzIHRoZSByb290IHZub2RlIGlkOiAnICsgaWQpXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjaGlsZE5vZGUgPSBjbltpXTtcblxuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICBjbltpXSA9IG5ld0NoaWxkTm9kZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoVkRvbS5yZXBsYWNlVmRvbUNoaWxkKGNoaWxkTm9kZSwgaWQsIG5ld0NoaWxkTm9kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5lby52ZG9tLkhlbHBlciB3aWxsIGNyZWF0ZSBpZHMgZm9yIGVhY2ggdm5vZGUgd2hpY2ggZG9lcyBub3QgYWxyZWFkeSBoYXZlIG9uZSxcbiAgICAgKiBzbyB3ZSBuZWVkIHRvIHN5bmMgdGhlbSBpbnRvIHRoZSB2ZG9tLlxuICAgICAqIEBwYXJhbSB7TmVvLnZkb20uVk5vZGV9IHZub2RlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZkb21cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZvcmNlPWZhbHNlIFRoZSBmb3JjZSBwYXJhbSB3aWxsIGVuZm9yY2Ugb3ZlcndyaXRpbmcgZGlmZmVyZW50IGlkc1xuICAgICAqL1xuICAgIHN0YXRpYyBzeW5jVmRvbUlkcyh2bm9kZSwgdmRvbSwgZm9yY2U9ZmFsc2UpIHtcbiAgICAgICAgaWYgKHZub2RlICYmIHZkb20pIHtcbiAgICAgICAgICAgIHZkb20gPSBWRG9tLmdldFZkb20odmRvbSk7XG5cbiAgICAgICAgICAgIGxldCBjaGlsZE5vZGVzID0gdmRvbS5jbixcbiAgICAgICAgICAgICAgICBjbiwgaSwgbGVuO1xuXG4gICAgICAgICAgICBpZiAoZm9yY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodm5vZGUuaWQgJiYgdmRvbS5pZCAhPT0gdm5vZGUuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmRvbS5pZCA9IHZub2RlLmlkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBvbmx5IHdhbnQgdG8gYWRkIGFuIElEIGlmIHRoZSB2ZG9tIG5vZGUgZG9lcyBub3QgYWxyZWFkeSBoYXZlIG9uZS5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIHByZXNlcnZlcyBkZXZlbG9wZXItcHJvdmlkZWQgSURzIHdoaWxlIGFsbG93aW5nIHRoZSBmcmFtZXdvcmtcbiAgICAgICAgICAgICAgICAvLyB0byBhc3NpZ24gSURzIHRvIG5vZGVzIHRoYXQgbmVlZCB0aGVtIGZvciByZWNvbmNpbGlhdGlvbi5cbiAgICAgICAgICAgICAgICAvLyBBbHNvIHRoaW5rIG9mIGFkZGluZyBhbmQgcmVtb3Zpbmcgbm9kZXMgaW4gcGFyYWxsZWwuXG4gICAgICAgICAgICAgICAgaWYgKHZub2RlLmlkICYmICghdmRvbS5pZCB8fCB2ZG9tLmlkLnN0YXJ0c1dpdGgoJ25lby12bm9kZS0nKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmRvbS5pZCA9IHZub2RlLmlkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2hpbGROb2Rlcykge1xuICAgICAgICAgICAgICAgIGNuICA9IGNoaWxkTm9kZXMubWFwKGl0ZW0gPT4gVkRvbS5nZXRWZG9tKGl0ZW0pKTtcbiAgICAgICAgICAgICAgICAvLyBUaGUgdm5vZGUuY2hpbGROb2RlcyBhcnJheSBpcyBhbHJlYWR5IGZpbHRlcmVkIGJ5IHRoZSB3b3JrZXIuXG4gICAgICAgICAgICAgICAgLy8gV2UgbXVzdCBmaWx0ZXIgdGhlIGNvbXBvbmVudCdzIHZkb20uY24gYXJyYXkgaWRlbnRpY2FsbHkgdG8gZW5zdXJlXG4gICAgICAgICAgICAgICAgLy8gYm90aCBhcnJheXMgYXJlIHN0cnVjdHVyYWxseSBhbGlnbmVkIGZvciB0aGUgc3luYyBsb29wLlxuICAgICAgICAgICAgICAgIC8vIFRoZSBib29sZWFuIGNoZWNrIGBpdGVtICYmYCBpcyBjcml0aWNhbCB0byByZW1vdmUgZmFsc3kgdmFsdWVzXG4gICAgICAgICAgICAgICAgLy8gZnJvbSBjb25kaXRpb25hbCByZW5kZXJpbmcgYW5kIHByZXZlbnQgcnVudGltZSBlcnJvcnMuXG4gICAgICAgICAgICAgICAgY24gID0gY24uZmlsdGVyKGl0ZW0gPT4gaXRlbSAmJiBpdGVtLnJlbW92ZURvbSAhPT0gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaSAgID0gMDtcbiAgICAgICAgICAgICAgICBsZW4gPSBjbj8ubGVuZ3RoIHx8IDA7XG5cbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2bm9kZS5jaGlsZE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBWRG9tLnN5bmNWZG9tSWRzKHZub2RlLmNoaWxkTm9kZXNbaV0sIGNuW2ldLCBmb3JjZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVkRvbSk7XG4iLCJpbXBvcnQgQmFzZSAgICAgICAgICAgICBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBDb21wb25lbnRNYW5hZ2VyIGZyb20gJy4uL21hbmFnZXIvQ29tcG9uZW50Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby51dGlsLlZOb2RlXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIFZOb2RlIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8udXRpbC5WTm9kZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnV0aWwuVk5vZGUnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VhcmNoIHZub2RlIGNoaWxkIG5vZGVzIGJ5IGlkIG9yIG9wdHMgb2JqZWN0IGZvciBhIGdpdmVuIHZkb20gdHJlZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2bm9kZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gb3B0cyBFaXRoZXIgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdmRvbSBub2RlIGF0dHJpYnV0ZXMgb3IgYSBzdHJpbmcgYmFzZWQgaWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2luZGV4XSBJbnRlcm5hbCBmbGFnLCBkbyBub3QgdXNlIGl0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJlbnROb2RlXSBJbnRlcm5hbCBmbGFnLCBkbyBub3QgdXNlIGl0XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiAgICAge051bWJlcn0gaW5kZXhcbiAgICAgKiAgICAge1N0cmluZ30gcGFyZW50SWRcbiAgICAgKiAgICAge09iamVjdH0gdm5vZGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZmluZCh2bm9kZSwgb3B0cywgaW5kZXgsIHBhcmVudE5vZGUpIHtcbiAgICAgICAgdm5vZGUgPSBWTm9kZS5nZXRWbm9kZSh2bm9kZSk7XG5cbiAgICAgICAgaW5kZXggPSBpbmRleCB8fCAwO1xuICAgICAgICBvcHRzICA9IHR5cGVvZiBvcHRzICE9PSAnc3RyaW5nJyA/IG9wdHMgOiB7aWQ6IG9wdHN9O1xuXG4gICAgICAgIGxldCBhdHRyTWF0Y2ggID0gdHJ1ZSxcbiAgICAgICAgICAgIG1hdGNoQXJyYXkgPSBbXSxcbiAgICAgICAgICAgIHN0eWxlTWF0Y2ggPSB0cnVlLFxuICAgICAgICAgICAgaSAgICAgICAgICA9IDAsXG4gICAgICAgICAgICBsZW4gICAgICAgID0gdm5vZGUuY2hpbGROb2Rlcz8ubGVuZ3RoIHx8IDAsXG4gICAgICAgICAgICBvcHRzQXJyYXksIG9wdHNMZW5ndGgsIHN1YkNoaWxkO1xuXG4gICAgICAgIG9wdHNBcnJheSAgPSBPYmplY3QuZW50cmllcyhvcHRzKTtcbiAgICAgICAgb3B0c0xlbmd0aCA9IG9wdHNBcnJheS5sZW5ndGg7XG5cbiAgICAgICAgb3B0c0FycmF5LmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZub2RlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdhdHRyaWJ1dGVzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChOZW8uaXNPYmplY3QodmFsdWUpICYmIE5lby5pc09iamVjdCh2bm9kZVtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5mb3JFYWNoKChbYXR0cktleSwgYXR0clZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh2bm9kZVtrZXldLmhhc093blByb3BlcnR5KGF0dHJLZXkpICYmIHZub2RlW2tleV1bYXR0cktleV0gPT09IGF0dHJWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJNYXRjaCA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRyTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hBcnJheS5wdXNoKHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2xhc3NOYW1lJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIE5lby5pc0FycmF5KHZub2RlW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZub2RlW2tleV0uaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoQXJyYXkucHVzaCh0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB0eXBlb2Ygdm5vZGVba2V5XSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodm5vZGVba2V5XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hBcnJheS5wdXNoKHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChOZW8uaXNBcnJheSh2YWx1ZSkgJiYgTmVvLmlzQXJyYXkodm5vZGVba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0b2RvOiBlaXRoZXIgc2VhcmNoIHRoZSB2bm9kZSBhcnJheSBmb3IgYWxsIGtleXMgb3IgY29tcGFyZSBpZiB0aGUgYXJyYXlzIGFyZSBlcXVhbC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpbmQ6IGNscyBtYXRjaGluZyBub3Qgc3VwcG9ydGVkIGZvciB0YXJnZXQgJiBzb3VyY2UgdHlwZXMgb2YgQXJyYXlzJylcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N0eWxlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChOZW8uaXNPYmplY3QodmFsdWUpICYmIE5lby5pc09iamVjdCh2bm9kZVtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5mb3JFYWNoKChbc3R5bGVLZXksIHN0eWxlVmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHZub2RlW2tleV0uaGFzT3duUHJvcGVydHkoc3R5bGVLZXkpICYmIHZub2RlW2tleV1bc3R5bGVLZXldID09PSBzdHlsZVZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVNYXRjaCA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoQXJyYXkucHVzaCh0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodm5vZGVba2V5XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEFycmF5LnB1c2godHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobWF0Y2hBcnJheS5sZW5ndGggPT09IG9wdHNMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB7aW5kZXgsIHBhcmVudE5vZGUsIHZub2RlfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgc3ViQ2hpbGQgPSBWTm9kZS5maW5kKHZub2RlLmNoaWxkTm9kZXNbaV0sIG9wdHMsIGksIHZub2RlKTtcblxuICAgICAgICAgICAgaWYgKHN1YkNoaWxkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YkNoaWxkXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmRzIGEgY2hpbGQgdm5vZGUgaW5zaWRlIGEgdm5vZGUgdHJlZSBieSBhIGdpdmVuIGlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZub2RlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gaWRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9IGNoaWxkIHZub2RlIG9yIG51bGxcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0QnlJZCh2bm9kZSwgaWQpIHtcbiAgICAgICAgdm5vZGUgPSBWTm9kZS5nZXRWbm9kZSh2bm9kZSk7XG5cbiAgICAgICAgbGV0IGNoaWxkTm9kZXMgPSB2bm9kZS5jaGlsZE5vZGVzIHx8IFtdLFxuICAgICAgICAgICAgaSAgICAgICAgICA9IDAsXG4gICAgICAgICAgICBsZW4gICAgICAgID0gY2hpbGROb2Rlcy5sZW5ndGgsXG4gICAgICAgICAgICBjaGlsZE5vZGU7XG5cbiAgICAgICAgaWYgKHZub2RlLmlkID09PSBpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHZub2RlXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjaGlsZE5vZGUgPSBWTm9kZS5nZXRWbm9kZShjaGlsZE5vZGVzW2ldKTtcblxuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGROb2RlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoaWxkTm9kZSA9IFZOb2RlLmdldEJ5SWQoY2hpbGROb2RlLCBpZCk7XG5cbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGROb2RlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaWRzIG9mIGFsbCBjaGlsZCBub2RlcyBvZiB0aGUgZ2l2ZW4gdm5vZGUsIGV4Y2x1ZGluZyBjb21wb25lbnQgcmVmZXJlbmNlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2bm9kZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IGNoaWxkSWRzPVtdXG4gICAgICogQHJldHVybnMge1N0cmluZ1tdfSBjaGlsZElkc1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXRDaGlsZElkcyh2bm9kZSwgY2hpbGRJZHM9W10pIHtcbiAgICAgICAgdm5vZGU/LmNoaWxkTm9kZXM/LmZvckVhY2goY2hpbGROb2RlID0+IHtcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGUuaWQgJiYgIWNoaWxkTm9kZS5jb21wb25lbnRJZCkge1xuICAgICAgICAgICAgICAgIGNoaWxkSWRzLnB1c2goY2hpbGROb2RlLmlkKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBWTm9kZS5nZXRDaGlsZElkcyhjaGlsZE5vZGUsIGNoaWxkSWRzKVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY2hpbGRJZHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dCB1c2luZyBtYW5hZ2VyLkNvbXBvbmVudCB0byByZXBsYWNlIHZub2RlIHJlZmVyZW5jZXMgaWYgbmVlZGVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZub2RlXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Vm5vZGUodm5vZGUpIHtcbiAgICAgICAgaWYgKHZub2RlLmNvbXBvbmVudElkKSB7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSBDb21wb25lbnRNYW5hZ2VyLmdldCh2bm9kZS5jb21wb25lbnRJZCk7XG5cbiAgICAgICAgICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1dGlsLlZOb2RlLmdldFZub2RlOiBDb21wb25lbnQgbm90IGZvdW5kIGZvciBpZDogJHt2bm9kZS5jb21wb25lbnRJZH1gKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2bm9kZSA9IGNvbXBvbmVudC52bm9kZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZub2RlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGNoaWxkIHZub2RlIGluc2lkZSBhIHZub2RlIHRyZWUgYnkgYSBnaXZlbiBpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2bm9kZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGluIGNhc2UgdGhlIG5vZGUgd2FzIGZvdW5kIGFuZCByZW1vdmVkXG4gICAgICovXG4gICAgc3RhdGljIHJlbW92ZUNoaWxkVm5vZGUodm5vZGUsIGlkKSB7XG4gICAgICAgIHZub2RlID0gVk5vZGUuZ2V0Vm5vZGUodm5vZGUpO1xuXG4gICAgICAgIGxldCBjaGlsZE5vZGVzID0gdm5vZGUuY2hpbGROb2RlcyB8fCBbXSxcbiAgICAgICAgICAgIGkgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgbGVuICAgICAgICA9IGNoaWxkTm9kZXMubGVuZ3RoLFxuICAgICAgICAgICAgY2hpbGROb2RlO1xuXG4gICAgICAgIGlmICh2bm9kZS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVtb3ZlQ2hpbGRWbm9kZTogdGFyZ2V0IGlkIG1hdGNoZXMgdGhlIHJvb3Qgdm5vZGUgaWQ6ICcgKyBpZClcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNoaWxkTm9kZSA9IFZOb2RlLmdldFZub2RlKGNoaWxkTm9kZXNbaV0pO1xuXG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlLmlkID09PSBpZCkge1xuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChWTm9kZS5yZW1vdmVDaGlsZFZub2RlKGNoaWxkTm9kZSwgaWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIGEgY2hpbGQgdm5vZGUgaW5zaWRlIGEgdm5vZGUgdHJlZSBieSBhIGdpdmVuIGlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZub2RlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5ld0NoaWxkVm5vZGVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpbiBjYXNlIHRoZSBub2RlIHdhcyBmb3VuZCBhbmQgcmVwbGFjZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgcmVwbGFjZUNoaWxkVm5vZGUodm5vZGUsIGlkLCBuZXdDaGlsZFZub2RlKSB7XG4gICAgICAgIHZub2RlID0gVk5vZGUuZ2V0Vm5vZGUodm5vZGUpO1xuXG4gICAgICAgIGxldCBjaGlsZE5vZGVzID0gdm5vZGUuY2hpbGROb2RlcyB8fCBbXSxcbiAgICAgICAgICAgIGkgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgbGVuICAgICAgICA9IGNoaWxkTm9kZXMubGVuZ3RoLFxuICAgICAgICAgICAgY2hpbGROb2RlO1xuXG4gICAgICAgIGlmICh2bm9kZS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVwbGFjZUNoaWxkVm5vZGU6IHRhcmdldCBpZCBtYXRjaGVzIHRoZSByb290IHZub2RlIGlkOiAnICsgaWQpXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjaGlsZE5vZGUgPSBWTm9kZS5nZXRWbm9kZShjaGlsZE5vZGVzW2ldKTtcblxuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVzW2ldID0gbmV3Q2hpbGRWbm9kZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoVk5vZGUucmVwbGFjZUNoaWxkVm5vZGUoY2hpbGROb2RlLCBpZCwgbmV3Q2hpbGRWbm9kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhWTm9kZSk7XG4iLCJpbXBvcnQgQmFzZSAgICAgICAgICAgICAgICAgIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuaW1wb3J0ICogYXMgY29yZSAgICAgICAgICAgICBmcm9tICcuLi9jb3JlL19leHBvcnQubWpzJztcbmltcG9ydCBPYnNlcnZhYmxlICAgICAgICAgICAgZnJvbSAnLi4vY29yZS9PYnNlcnZhYmxlLm1qcyc7XG5pbXBvcnQgQ2xhc3NIaWVyYXJjaHlNYW5hZ2VyIGZyb20gJy4uL21hbmFnZXIvQ2xhc3NIaWVyYXJjaHkubWpzJztcbmltcG9ydCBNZXNzYWdlICAgICAgICAgICAgICAgZnJvbSAnLi9NZXNzYWdlLm1qcyc7XG5pbXBvcnQgUmVtb3RlTWV0aG9kQWNjZXNzICAgIGZyb20gJy4vbWl4aW4vUmVtb3RlTWV0aG9kQWNjZXNzLm1qcyc7XG5cbi8qKlxuICogVGhlIGFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIGUuZy4gdGhlIEFwcCwgRGF0YSAmIFZEb20gd29ya2VyXG4gKiBAY2xhc3MgTmVvLndvcmtlci5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKiBAbWl4ZXMgTmVvLmNvcmUuT2JzZXJ2YWJsZVxuICogQG1peGVzIE5lby53b3JrZXIubWl4aW4uUmVtb3RlTWV0aG9kQWNjZXNzXG4gKiBAYWJzdHJhY3RcbiAqL1xuY2xhc3MgV29ya2VyIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ud29ya2VyLkJhc2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby53b3JrZXIuQmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXXxOZW8uY29yZS5CYXNlW118bnVsbH0gbWl4aW5zPVtPYnNlcnZhYmxlLFJlbW90ZU1ldGhvZEFjY2Vzc11cbiAgICAgICAgICovXG4gICAgICAgIG1peGluczogW09ic2VydmFibGUsIFJlbW90ZU1ldGhvZEFjY2Vzc11cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gY2hhbm5lbFBvcnRzPW51bGxcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY2hhbm5lbFBvcnRzID0gbnVsbFxuICAgIC8qKlxuICAgICAqIE9ubHkgbmVlZGVkIGZvciBTaGFyZWRXb3JrZXJzXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNDb25uZWN0ZWQ9ZmFsc2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaXNDb25uZWN0ZWQgPSBmYWxzZVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzU2hhcmVkV29ya2VyPWZhbHNlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGlzU2hhcmVkV29ya2VyID0gZmFsc2VcbiAgICAvKipcbiAgICAgKiBPbmx5IG5lZWRlZCBmb3IgU2hhcmVkV29ya2Vyc1xuICAgICAqIEBtZW1iZXIge0FycmF5fG51bGx9IHBvcnRzPW51bGxcbiAgICAgKi9cbiAgICBwb3J0cyA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gd29ya2VySWQ9bnVsbFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB3b3JrZXJJZCA9IG51bGxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBndCA9IGdsb2JhbFRoaXM7XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihtZSwge1xuICAgICAgICAgICAgY2hhbm5lbFBvcnRzICA6IHt9LFxuICAgICAgICAgICAgaXNTaGFyZWRXb3JrZXI6IGd0LnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IFNoYXJlZFdvcmtlckdsb2JhbFNjb3BlXScsXG4gICAgICAgICAgICBwb3J0cyAgICAgICAgIDogW10sXG4gICAgICAgICAgICBwcm9taXNlcyAgICAgIDoge31cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG1lLmlzU2hhcmVkV29ya2VyKSB7XG4gICAgICAgICAgICBndC5vbmNvbm5lY3QgPSBtZS5vbkNvbm5lY3RlZC5iaW5kKG1lKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ3Qub25tZXNzYWdlID0gbWUub25NZXNzYWdlLmJpbmQobWUpXG4gICAgICAgIH1cblxuICAgICAgICBOZW8uY3VycmVudFdvcmtlciAgID0gbWU7XG4gICAgICAgIE5lby5zZXRHbG9iYWxDb25maWcgPSBtZS5zZXRHbG9iYWxDb25maWcuYmluZChtZSk7XG4gICAgICAgIE5lby53b3JrZXJJZCAgICAgICAgPSBtZS53b3JrZXJJZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVudHJ5IHBvaW50IGZvciBkZWRpY2F0ZWQgYW5kIHNoYXJlZCB3b3JrZXJzXG4gICAgICovXG4gICAgYWZ0ZXJDb25uZWN0KCkge31cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHJldHVybnMge09iamVjdHxudWxsfVxuICAgICAqL1xuICAgIGdldFBvcnQob3B0cykge1xuICAgICAgICBsZXQgcmV0dXJuUG9ydCA9IG51bGwsXG4gICAgICAgICAgICBoYXNNYXRjaDtcblxuICAgICAgICB0aGlzLnBvcnRzLmZvckVhY2gocG9ydCA9PiB7XG4gICAgICAgICAgICBoYXNNYXRjaCA9IHRydWU7XG5cbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKG9wdHMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gcG9ydFtrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc01hdGNoID0gZmFsc2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGhhc01hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuUG9ydCA9IHBvcnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJldHVyblBvcnRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPbmx5IHJlbGV2YW50IGZvciBTaGFyZWRXb3JrZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBhc3luYyBvbkNvbm5lY3QoZGF0YSkge1xuICAgICAgICAvLyBzaG9ydCBkZWxheSB0byBlbnN1cmUgYXBwIFZDcyBhcmUgaW4gcGxhY2VcbiAgICAgICAgYXdhaXQgdGhpcy50aW1lb3V0KDEwKTtcblxuICAgICAgICBsZXQge2FwcE5hbWUsIHdpbmRvd0lkfSA9IGRhdGE7XG4gICAgICAgIHRoaXMuZmlyZSgnY29ubmVjdCcsIHthcHBOYW1lLCB3aW5kb3dJZH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT25seSByZWxldmFudCBmb3IgU2hhcmVkV29ya2Vyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlXG4gICAgICovXG4gICAgb25Db25uZWN0ZWQoZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgaWQgPSBOZW8uZ2V0SWQoJ3BvcnQnKTtcblxuICAgICAgICBtZS5pc0Nvbm5lY3RlZCA9IHRydWU7XG5cbiAgICAgICAgbWUucG9ydHMucHVzaCh7XG4gICAgICAgICAgICBhcHBOYW1lIDogbnVsbCxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcG9ydCAgICA6IGUucG9ydHNbMF0sXG4gICAgICAgICAgICB3aW5kb3dJZDogbnVsbFxuICAgICAgICB9KTtcblxuICAgICAgICBtZS5wb3J0c1ttZS5wb3J0cy5sZW5ndGggLSAxXS5wb3J0Lm9ubWVzc2FnZSA9IG1lLm9uTWVzc2FnZS5iaW5kKG1lKTtcblxuICAgICAgICAvLyBjb3JlLkJhc2U6IGluaXRSZW1vdGUoKSBzdWJzY3JpYmVzIHRvIHRoaXMgZXZlbnQgZm9yIHRoZSBTaGFyZWRXb3JrZXJzIGNvbnRleHRcbiAgICAgICAgbWUuZmlyZSgnY29ubmVjdGVkJyk7XG5cbiAgICAgICAgbWUuc2VuZE1lc3NhZ2UoJ21haW4nLCB7YWN0aW9uOiAnd29ya2VyQ29uc3RydWN0ZWQnLCBwb3J0OiBpZH0pO1xuXG4gICAgICAgIG1lLmFmdGVyQ29ubmVjdCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNvbnN0cnVjdGVkKCkge1xuICAgICAgICBzdXBlci5vbkNvbnN0cnVjdGVkKCk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIW1lLmlzU2hhcmVkV29ya2VyKSB7XG4gICAgICAgICAgICBtZS5zZW5kTWVzc2FnZSgnbWFpbicsIHthY3Rpb246ICd3b3JrZXJDb25zdHJ1Y3RlZCd9KTtcbiAgICAgICAgICAgIG1lLmFmdGVyQ29ubmVjdCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPbmx5IHJlbGV2YW50IGZvciBTaGFyZWRXb3JrZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkRpc2Nvbm5lY3QoZGF0YSkge1xuICAgICAgICBsZXQge2FwcE5hbWUsIHdpbmRvd0lkfSA9IGRhdGE7XG4gICAgICAgIHRoaXMuZmlyZSgnZGlzY29ubmVjdCcsIHthcHBOYW1lLCB3aW5kb3dJZH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVcbiAgICAgKi9cbiAgICBvbk1lc3NhZ2UoZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2RhdGF9ICAgICAgICAgICAgPSBlLFxuICAgICAgICAgICAge2FjdGlvbiwgcmVwbHlJZH0gPSBkYXRhLFxuICAgICAgICAgICAgcHJvbWlzZTtcblxuICAgICAgICBpZiAoIWFjdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXNzYWdlIGFjdGlvbiBpcyBtaXNzaW5nOiAnICsgZGF0YS5pZClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhY3Rpb24gIT09ICdyZXBseScpIHtcbiAgICAgICAgICAgIG1lWydvbicgKyBOZW8uY2FwaXRhbGl6ZShhY3Rpb24pXShkYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9taXNlID0gYWN0aW9uID09PSAncmVwbHknICYmIG1lLnByb21pc2VzW3JlcGx5SWRdKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5yZWplY3QpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLnJlamVjdChkYXRhLmRhdGEpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb21pc2UucmVzb2x2ZShkYXRhLmRhdGEpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbGV0ZSBtZS5wcm9taXNlc1tyZXBseUlkXVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1zZ1xuICAgICAqL1xuICAgIG9uUGluZyhtc2cpIHtcbiAgICAgICAgdGhpcy5yZXNvbHZlKG1zZywge29yaWdpbk1zZzogbXNnfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPbmx5IHJlbGV2YW50IGZvciBTaGFyZWRXb3JrZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1zZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cuYXBwTmFtZVxuICAgICAqL1xuICAgIG9uUmVnaXN0ZXJBcHAobXNnKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2FwcE5hbWV9ID0gbXNnLFxuICAgICAgICAgICAgcG9ydDtcblxuICAgICAgICBmb3IgKHBvcnQgb2YgbWUucG9ydHMpIHtcbiAgICAgICAgICAgIGlmICghcG9ydC5hcHBOYW1lKSB7XG4gICAgICAgICAgICAgICAgcG9ydC5hcHBOYW1lID0gYXBwTmFtZTtcbiAgICAgICAgICAgICAgICBtZS5vbkNvbm5lY3Qoe2FwcE5hbWUsIHdpbmRvd0lkOiBwb3J0LndpbmRvd0lkfSk7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlIGluaXRpYWwgcmVnaXN0cmF0aW9uIG9mIHRoZSBgTmVvLmNvbmZpZ2AgZm9yIHRoaXMgd29ya2VyJ3MgcmVhbG0uXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gcmVjZWl2aW5nIGEgd29ya2VyIG1lc3NhZ2Ugd2l0aCBge2FjdGlvbjogJ3JlZ2lzdGVyTmVvQ29uZmlnJ31gIGZyb20gdGhlIE1haW4gVGhyZWFkJ3MgYE5lby53b3JrZXIuTWFuYWdlcmAuXG4gICAgICogVGhpcyBtZXRob2QgaXMgcHJpbWFyaWx5IHJlc3BvbnNpYmxlIGZvciBzZXR0aW5nIHRoZSBpbml0aWFsIGdsb2JhbCBgTmVvLmNvbmZpZ2Agb2JqZWN0IGluIHRoaXMgd29ya2VyJ3Mgc2NvcGVcbiAgICAgKiB1cG9uIGl0cyBjcmVhdGlvbi4gSXQgYWxzbyBoYW5kbGVzIGFzc29jaWF0aW5nIGB3aW5kb3dJZGAgd2l0aCBgTWVzc2FnZVBvcnRgcyBmb3IgU2hhcmVkIFdvcmtlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbXNnIFRoZSBpbmNvbWluZyBtZXNzYWdlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbXNnLmRhdGEgVGhlIGluaXRpYWwgZ2xvYmFsIE5lby5jb25maWcgZGF0YSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1zZy5kYXRhLndpbmRvd0lkIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHdpbmRvdy90YWIgKHJlbGV2YW50IGZvciBTaGFyZWRXb3JrZXJzKS5cbiAgICAgKi9cbiAgICBvblJlZ2lzdGVyTmVvQ29uZmlnKG1zZykge1xuICAgICAgICBOZW8ubnMoJ05lby5jb25maWcnLCB0cnVlKTtcblxuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7d2luZG93SWR9ID0gbXNnLmRhdGEsXG4gICAgICAgICAgICBwb3J0O1xuXG4gICAgICAgIGZvciAocG9ydCBvZiBtZS5wb3J0cykge1xuICAgICAgICAgICAgaWYgKCFwb3J0LndpbmRvd0lkKSB7XG4gICAgICAgICAgICAgICAgcG9ydC53aW5kb3dJZCA9IHdpbmRvd0lkO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBOZW8ubWVyZ2UoTmVvLmNvbmZpZywgbXNnLmRhdGEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBydW50aW1lIHVwZGF0ZXMgdG8gdGhlIGdsb2JhbCBgTmVvLmNvbmZpZ2AgZm9yIHRoaXMgd29ya2VyJ3MgcmVhbG0uXG4gICAgICogVGhpcyBtZXRob2QgaXMgdHJpZ2dlcmVkIHdoZW4gcmVjZWl2aW5nIGEgd29ya2VyIG1lc3NhZ2Ugd2l0aCBge2FjdGlvbjogJ3NldE5lb0NvbmZpZyd9YFxuICAgICAqIGZyb20gdGhlIE1haW4gVGhyZWFkJ3MgYE5lby53b3JrZXIuTWFuYWdlcmAuIFRoaXMgbWVzc2FnZSBzaWduaWZpZXMgYSBnbG9iYWwgY29uZmlnIGNoYW5nZVxuICAgICAqIHRoYXQgb3JpZ2luYXRlZCBlaXRoZXIgZnJvbSB0aGlzIHdvcmtlcidzIE1haW4gVGhyZWFkIG9yIHdhcyBicm9hZGNhc3QgZnJvbSBhbm90aGVyXG4gICAgICogY29ubmVjdGVkIGJyb3dzZXIgd2luZG93IHZpYSBhIFNoYXJlZCBXb3JrZXIuXG4gICAgICpcbiAgICAgKiBJdCBtZXJnZXMgdGhlIGluY29taW5nIGNvbmZpZ3VyYXRpb24gY2hhbmdlcyBpbnRvIHRoaXMgd29ya2VyJ3MgbG9jYWwgYE5lby5jb25maWdgXG4gICAgICogYW5kIGZpcmVzIGEgbG9jYWwgYG5lb0NvbmZpZ0NoYW5nZWAgZXZlbnQsIGFsbG93aW5nIG90aGVyIGluc3RhbmNlcyB3aXRoaW4gdGhpcyB3b3JrZXJcbiAgICAgKiB0byByZWFjdCB0byB0aGUgdXBkYXRlZCBjb25maWd1cmF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1zZyBUaGUgZGVzdHJ1Y3R1cmVkIGFyZ3VtZW50cyBmcm9tIHRoZSBtZXNzYWdlIHBheWxvYWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1zZy5jb25maWcgVGhlIHBhcnRpYWwgb3IgZnVsbCBgTmVvLmNvbmZpZ2Agb2JqZWN0IHRvIG1lcmdlLlxuICAgICAqL1xuICAgIG9uU2V0TmVvQ29uZmlnKHtjb25maWd9KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgTmVvLm1lcmdlKE5lby5jb25maWcsIGNvbmZpZyk7XG5cbiAgICAgICAgbWUuZmlyZSgnbmVvQ29uZmlnQ2hhbmdlJywgY29uZmlnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkZXN0IGFwcCwgZGF0YSwgbWFpbiBvciB2ZG9tIChleGNsdWRpbmcgdGhlIGN1cnJlbnQgd29ya2VyKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIGNvbmZpZ3MgZm9yIE5lby53b3JrZXIuTWVzc2FnZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt0cmFuc2Zlcl0gQW4gb3B0aW9uYWwgYXJyYXkgb2YgVHJhbnNmZXJhYmxlIG9iamVjdHMgdG8gdHJhbnNmZXIgb3duZXJzaGlwIG9mLlxuICAgICAqIElmIHRoZSBvd25lcnNoaXAgb2YgYW4gb2JqZWN0IGlzIHRyYW5zZmVycmVkLCBpdCBiZWNvbWVzIHVudXNhYmxlIChuZXV0ZXJlZCkgaW4gdGhlIGNvbnRleHQgaXQgd2FzIHNlbnQgZnJvbVxuICAgICAqIGFuZCBiZWNvbWVzIGF2YWlsYWJsZSBvbmx5IHRvIHRoZSB3b3JrZXIgaXQgd2FzIHNlbnQgdG8uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBwcm9taXNlTWVzc2FnZShkZXN0LCBvcHRzLCB0cmFuc2Zlcikge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlID0gbWUuc2VuZE1lc3NhZ2UoZGVzdCwgb3B0cywgdHJhbnNmZXIpLFxuICAgICAgICAgICAgICAgIG1zZ0lkICAgPSBtZXNzYWdlPy5pZDtcblxuICAgICAgICAgICAgaWYgKCFtc2dJZCkge1xuICAgICAgICAgICAgICAgIC8vIGEgd2luZG93IGdvdCBjbG9zZWQgYW5kIHRoZSBtZXNzYWdlIHBvcnQgbm8gbG9uZ2VyIGV4aXN0IChTaGFyZWRXb3JrZXJzKVxuICAgICAgICAgICAgICAgIHJlamVjdCgpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lLnByb21pc2VzW21zZ0lkXSA9IHtyZWplY3QsIHJlc29sdmV9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRlc3QgYXBwLCBjYW52YXMsIGRhdGEsIG1haW4gb3IgdmRvbSAoZXhjbHVkaW5nIHRoZSBjdXJyZW50IHdvcmtlcilcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBjb25maWdzIGZvciBOZW8ud29ya2VyLk1lc3NhZ2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdHJhbnNmZXJdIEFuIG9wdGlvbmFsIGFycmF5IG9mIFRyYW5zZmVyYWJsZSBvYmplY3RzIHRvIHRyYW5zZmVyIG93bmVyc2hpcCBvZi5cbiAgICAgKiBJZiB0aGUgb3duZXJzaGlwIG9mIGFuIG9iamVjdCBpcyB0cmFuc2ZlcnJlZCwgaXQgYmVjb21lcyB1bnVzYWJsZSAobmV1dGVyZWQpIGluIHRoZSBjb250ZXh0IGl0IHdhcyBzZW50IGZyb21cbiAgICAgKiBhbmQgYmVjb21lcyBhdmFpbGFibGUgb25seSB0byB0aGUgd29ya2VyIGl0IHdhcyBzZW50IHRvLlxuICAgICAqIEByZXR1cm5zIHtOZW8ud29ya2VyLk1lc3NhZ2V9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNlbmRNZXNzYWdlKGRlc3QsIG9wdHMsIHRyYW5zZmVyKSB7XG4gICAgICAgIG9wdHMuZGVzdGluYXRpb24gPSBkZXN0O1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBtZXNzYWdlLCBwb3J0LCBwb3J0T2JqZWN0O1xuXG4gICAgICAgIGlmIChtZS5jaGFubmVsUG9ydHNbZGVzdF0pIHtcbiAgICAgICAgICAgIHBvcnQgPSBtZS5jaGFubmVsUG9ydHNbZGVzdF1cbiAgICAgICAgfSBlbHNlIGlmICghbWUuaXNTaGFyZWRXb3JrZXIpIHtcbiAgICAgICAgICAgIHBvcnQgPSBnbG9iYWxUaGlzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAob3B0cy5wb3J0KSB7XG4gICAgICAgICAgICAgICAgcG9ydCA9IG1lLmdldFBvcnQoe2lkOiBvcHRzLnBvcnR9KS5wb3J0XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdHMud2luZG93SWQpIHtcbiAgICAgICAgICAgICAgICBwb3J0T2JqZWN0ID0gbWUuZ2V0UG9ydCh7d2luZG93SWQ6IG9wdHMud2luZG93SWR9KTtcbiAgICAgICAgICAgICAgICBwb3J0ICAgICAgID0gcG9ydE9iamVjdD8ucG9ydDtcblxuICAgICAgICAgICAgICAgIG9wdHMucG9ydCA9IHBvcnRPYmplY3Q/LmlkXG4gICAgICAgICAgICB9ICBlbHNlIGlmIChvcHRzLmFwcE5hbWUpIHtcbiAgICAgICAgICAgICAgICBwb3J0T2JqZWN0ID0gbWUuZ2V0UG9ydCh7YXBwTmFtZTogb3B0cy5hcHBOYW1lfSk7XG4gICAgICAgICAgICAgICAgcG9ydCAgICAgICA9IHBvcnRPYmplY3Q/LnBvcnQ7XG5cbiAgICAgICAgICAgICAgICBvcHRzLnBvcnQgPSBwb3J0T2JqZWN0Py5pZFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwb3J0ID0gbWUucG9ydHNbMF0ucG9ydFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvcnQpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBuZXcgTWVzc2FnZShvcHRzKTtcbiAgICAgICAgICAgIHBvcnQucG9zdE1lc3NhZ2UobWVzc2FnZSwgdHJhbnNmZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWF0ZXMgYSBnbG9iYWwgTmVvLmNvbmZpZyBjaGFuZ2UgZnJvbSBhIHdvcmtlcidzIGNvbnRleHQuXG4gICAgICogVGhpcyBtZXRob2QgaXMgZXhwb3NlZCBnbG9iYWxseSBhcyBgTmVvLnNldEdsb2JhbENvbmZpZ2Agd2l0aGluIGVhY2ggd29ya2VyIHJlYWxtLlxuICAgICAqXG4gICAgICogSXQgb3JjaGVzdHJhdGVzIHRoZSBwcm9wYWdhdGlvbiBvZiB0aGUgY29uZmlnIGNoYW5nZSB0byB0aGUgTWFpbiBUaHJlYWRcbiAgICAgKiBhbmQsIGlmIGEgU2hhcmVkIFdvcmtlciBpcyBhY3RpdmUsIGFjcm9zcyBhbGwgY29ubmVjdGVkIGJyb3dzZXIgd2luZG93cyxcbiAgICAgKiBlbnN1cmluZyBhIHNpbmdsZSwgY29uc2lzdGVudCBOZW8uY29uZmlnIHN0YXRlIGV2ZXJ5d2hlcmUuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIHBhc3MgYSBwYXJ0aWFsIGNvbmZpZyBvYmplY3QgdG8gdXBkYXRlIHNwZWNpZmljIGtleXMuXG4gICAgICogRm9yIG5lc3RlZCBvYmplY3RzLCBOZW8ubWpzIHBlcmZvcm1zIGEgZGVlcCBtZXJnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIHBhcnRpYWwgb3IgZnVsbCBOZW8uY29uZmlnIG9iamVjdCB3aXRoIGNoYW5nZXMgdG8gYXBwbHkuXG4gICAgICovXG4gICAgc2V0R2xvYmFsQ29uZmlnKGNvbmZpZykge1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtNYW5hZ2VyfSA9IE5lby53b3JrZXI7IC8vIFJlbW90ZSBhY2Nlc3MgcHJveHkgb2JqZWN0XG5cbiAgICAgICAgLy8gQXBwbHkgdGhlIGNvbmZpZyBjaGFuZ2UgbG9jYWxseSB0byB0aGlzIHdvcmtlcidzIE5lby5jb25maWcgYW5kXG4gICAgICAgIC8vIHRyaWdnZXIgaXRzIGxvY2FsIGNoYW5nZSBldmVudHMgaW1tZWRpYXRlbHkuIFRoaXMgZW5zdXJlcyBpbW1lZGlhdGVcbiAgICAgICAgLy8gZmVlZGJhY2sgYW5kIGFuIHVwZGF0ZWQgc3RhdGUgZm9yIHRoZSB3b3JrZXIgdGhhdCBpbml0aWF0ZWQgdGhlIGNoYW5nZS5cbiAgICAgICAgbWUub25TZXROZW9Db25maWcoe2NvbmZpZ30pO1xuXG4gICAgICAgIGlmIChtZS5pc1NoYXJlZFdvcmtlcikge1xuICAgICAgICAgICAgLy8gVGhpcyBibG9jayBleGVjdXRlcyB3aGVuIHRoZSBjYWxsaW5nIHdvcmtlciBpbnN0YW5jZSBpcyBhIFNoYXJlZCBXb3JrZXIuXG4gICAgICAgICAgICAvLyBUaGlzIGhhcHBlbnMgaWYgYE5lby5jb25maWcudXNlU2hhcmVkV29ya2Vyc2AgaXMgdHJ1ZSwgbWVhbmluZyBBcHAsIFZEb20sXG4gICAgICAgICAgICAvLyBEYXRhLCBDYW52YXMsIGFuZCBUYXNrIHdvcmtlcnMgYXJlIGFsbCBTaGFyZWRXb3JrZXIgaW5zdGFuY2VzLlxuICAgICAgICAgICAgLy8gVGhpcyBTaGFyZWQgV29ya2VyICh0aGUgb25lIHdoZXJlIHNldEdsb2JhbENvbmZpZyB3YXMgY2FsbGVkKSBhY3RzIGFzIHRoZVxuICAgICAgICAgICAgLy8gY2VudHJhbCBwb2ludCB0byBpbmZvcm0gYWxsIGNvbm5lY3RlZCBNYWluIFRocmVhZHMgKGJyb3dzZXIgd2luZG93cykuXG4gICAgICAgICAgICBtZS5wb3J0cy5mb3JFYWNoKChwb3J0LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFNlbmQgdGhlIGNvbmZpZyBjaGFuZ2UgdG8gZWFjaCBjb25uZWN0ZWQgTWFpbiBUaHJlYWQuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGBicm9hZGNhc3RgIGZsYWcgaXMgY3J1Y2lhbCBoZXJlIGZvciB0aGUgKnJlY2VpdmluZyogTWFpbiBUaHJlYWQ6XG4gICAgICAgICAgICAgICAgLy8gLSBgYnJvYWRjYXN0OiB0cnVlYCAoZm9yIHRoZSBmaXJzdCBwb3J0L01haW4gVGhyZWFkIGluIHRoZSBsaXN0KTogVGhpcyBNYWluIFRocmVhZFxuICAgICAgICAgICAgICAgIC8vICAgd2lsbCBhcHBseSB0aGUgY29uZmlnIGxvY2FsbHkgYW5kIGlzIHRoZW4gcmVzcG9uc2libGUgZm9yIHByb3BhZ2F0aW5nIGl0IHRvICphbGwqXG4gICAgICAgICAgICAgICAgLy8gICBpdHMgb3duIGFzc29jaWF0ZWQgU2hhcmVkIFdvcmtlcnMgY29ubmVjdGVkIHRvIHRoYXQgTWFpbiBUaHJlYWQpLFxuICAgICAgICAgICAgICAgIC8vICAgKipleGNsdWRpbmcgdGhlIHdvcmtlciB0aGF0IG9yaWdpbmF0ZWQgdGhpcyBjaGFuZ2UqKi5cbiAgICAgICAgICAgICAgICAvLyAtIGBicm9hZGNhc3Q6IGZhbHNlYCAoZm9yIGFsbCBvdGhlciBwb3J0cy9NYWluIFRocmVhZHMpOiBUaGVzZSBNYWluIFRocmVhZHNcbiAgICAgICAgICAgICAgICAvLyAgIHdpbGwgc2ltcGx5IGFwcGx5IHRoZSBjb25maWcgbG9jYWxseSBhbmQgc3RvcC4gVGhleSBhcmUgcGFzc2l2ZSByZWNpcGllbnRzXG4gICAgICAgICAgICAgICAgLy8gICBvZiB0aGUgYnJvYWRjYXN0LCBzeW5jaHJvbml6aW5nIHRoZWlyIHN0YXRlIHdpdGhvdXQgaW5pdGlhdGluZyBmdXJ0aGVyIGFjdGlvbnMgYmFjay5cbiAgICAgICAgICAgICAgICAvLyBUaGUgYGV4Y2x1ZGVPcmlnaW5gIHBhcmFtZXRlciBlbnN1cmVzIHRoZSBvcmlnaW5hdGluZyB3b3JrZXIgZG9lc24ndCByZWNlaXZlIGEgcmVkdW5kYW50IGJyb2FkY2FzdC5cbiAgICAgICAgICAgICAgICBNYW5hZ2VyLnNldE5lb0NvbmZpZyh7YnJvYWRjYXN0OiBpbmRleCA8IDEsIGNvbmZpZywgZXhjbHVkZU9yaWdpbjogbWUud29ya2VySWQsIHdpbmRvd0lkOiBwb3J0LndpbmRvd0lkfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGlzIERlZGljYXRlZCBXb3JrZXIgKHRoZSBvbmUgd2hlcmUgc2V0R2xvYmFsQ29uZmlnIHdhcyBjYWxsZWQpIGluZm9ybXNcbiAgICAgICAgICAgIC8vIGl0cyBzaW5nbGUsIGNvbm5lY3RlZCBNYWluIFRocmVhZC4gVGhlIE1haW4gVGhyZWFkIHdpbGwgdGhlbjpcbiAgICAgICAgICAgIC8vIDEuIEFwcGx5IHRoZSBjb25maWcgbG9jYWxseS5cbiAgICAgICAgICAgIC8vIDIuIEJyb2FkY2FzdCB0aGlzIGNoYW5nZSB0byAqYWxsKiBvdGhlciBEZWRpY2F0ZWQgV29ya2VycyBjb25uZWN0ZWQgdG9cbiAgICAgICAgICAgIC8vICAgICp0aGF0IHNhbWUgTWFpbiBUaHJlYWQqLCAqKmV4Y2x1ZGluZyB0aGUgc2VuZGVyIHdvcmtlciBpdHNlbGYqKi5cbiAgICAgICAgICAgIE1hbmFnZXIuc2V0TmVvQ29uZmlnKHticm9hZGNhc3Q6IHRydWUsIGNvbmZpZywgZXhjbHVkZU9yaWdpbjogbWUud29ya2VySWR9KVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhXb3JrZXIpO1xuIiwiaW1wb3J0IElkR2VuZXJhdG9yIGZyb20gJy4uL2NvcmUvSWRHZW5lcmF0b3IubWpzJztcblxuLyoqXG4gKiBBIHdyYXBwZXIgZm9yIHdvcmtlciBwb3N0IG1lc3NhZ2VzIHNlbnQgYmV0d2VlbiB0aGUgQXBwLCBEYXRhLCBWRG9tIHdvcmtlciAmIHRoZSBtYWluIHRocmVhZC5cbiAqIFlvdSBjYW4gYWRkIG9wdGlvbmFsIHBhcmFtcyBhcyBuZWVkZWQuXG4gKiBAY2xhc3MgTmVvLndvcmtlci5NZXNzYWdlXG4gKi9cbmNsYXNzIE1lc3NhZ2Uge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gYWN0aW9uXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGRlc3RpbmF0aW9uPSdtYWluJ1xuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBpZD1JZEdlbmVyYXRvci5nZXRJZChOZW8ud29ya2VySWQpXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG9yaWdpbj1OZW8ud29ya2VySWRcbiAgICAgICAgICovXG5cbiAgICAgICAgY29uZmlnLmRlc3RpbmF0aW9uID0gY29uZmlnLmRlc3RpbmF0aW9uIHx8ICdtYWluJztcbiAgICAgICAgY29uZmlnLmlkICAgICAgICAgID0gY29uZmlnLmlkICAgICAgICAgIHx8IElkR2VuZXJhdG9yLmdldElkKE5lby53b3JrZXJJZCk7XG4gICAgICAgIGNvbmZpZy5vcmlnaW4gICAgICA9IGNvbmZpZy5vcmlnaW4gICAgICB8fCBOZW8ud29ya2VySWQ7XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjb25maWcpXG4gICAgfVxufVxuXG5jb25zdCBucyA9IE5lby5ucygnTmVvLndvcmtlcicsIHRydWUpO1xubnNbJ01lc3NhZ2UnXSA9IE1lc3NhZ2U7XG5cbmV4cG9ydCBkZWZhdWx0IE1lc3NhZ2U7XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuLi8uLi9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLndvcmtlci5taXhpbi5SZW1vdGVNZXRob2RBY2Nlc3NcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgUmVtb3RlTWV0aG9kQWNjZXNzIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ud29ya2VyLm1peGluLlJlbW90ZU1ldGhvZEFjY2VzcydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLndvcmtlci5taXhpbi5SZW1vdGVNZXRob2RBY2Nlc3MnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cbiAgICBhc3NpZ25Qb3J0KHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHthcHBOYW1lLCBwb3J0LCB3aW5kb3dJZH0gPSBzb3VyY2U7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRhcmdldCwge2FwcE5hbWUsIHBvcnQsIHdpbmRvd0lkfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZW1vdGVcbiAgICAgKiBAcGFyYW0gbWV0aG9kXG4gICAgICogQHJldHVybnMge2Z1bmN0aW9uKCo9LCAqPSk6IFByb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBnZW5lcmF0ZVJlbW90ZShyZW1vdGUsIG1ldGhvZCkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge29yaWdpbn0gPSByZW1vdGU7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGEsIGJ1ZmZlcikge1xuICAgICAgICAgICAgbGV0IG9wdHMgPSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uICAgICAgICAgOiAncmVtb3RlTWV0aG9kJyxcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uICAgIDogb3JpZ2luLFxuICAgICAgICAgICAgICAgIHJlbW90ZUNsYXNzTmFtZTogcmVtb3RlLmNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICByZW1vdGVNZXRob2QgICA6IG1ldGhvZFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgbWUuaXNTaGFyZWRXb3JrZXIgJiYgbWUuYXNzaWduUG9ydChkYXRhLCBvcHRzKTtcblxuICAgICAgICAgICAgcmV0dXJuIG1lLnByb21pc2VNZXNzYWdlKG9yaWdpbiwgb3B0cywgYnVmZmVyKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlbW90ZVxuICAgICAqL1xuICAgIG9uUmVnaXN0ZXJSZW1vdGUocmVtb3RlKSB7XG4gICAgICAgIGlmIChyZW1vdGUuZGVzdGluYXRpb24gPT09IE5lby53b3JrZXJJZCkge1xuICAgICAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICB7Y2xhc3NOYW1lLCBtZXRob2RzfSA9IHJlbW90ZSxcbiAgICAgICAgICAgICAgICBwa2cgICAgICAgICAgICAgICAgICA9IE5lby5ucyhjbGFzc05hbWUsIHRydWUpO1xuXG4gICAgICAgICAgICBtZXRob2RzLmZvckVhY2gobWV0aG9kID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmVtb3RlLm9yaWdpbiAhPT0gJ21haW4nICYmIHBrZ1ttZXRob2RdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRHVwbGljYXRlIHJlbW90ZSBtZXRob2QgZGVmaW5pdGlvbiAnICsgY2xhc3NOYW1lICsgJy4nICsgbWV0aG9kKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBrZ1ttZXRob2RdID8/PSBtZS5nZW5lcmF0ZVJlbW90ZShyZW1vdGUsIG1ldGhvZClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbXNnXG4gICAgICovXG4gICAgb25SZW1vdGVNZXRob2QobXNnKSB7XG4gICAgICAgIGxldCBtZSAgPSB0aGlzLFxuICAgICAgICAgICAgcGtnID0gTmVvLm5zKG1zZy5yZW1vdGVDbGFzc05hbWUpLFxuICAgICAgICAgICAgb3V0LCBtZXRob2Q7XG5cbiAgICAgICAgaWYgKCFwa2cpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZW1vdGUgbmFtZXNwYWNlIFwiJyArIG1zZy5yZW1vdGVDbGFzc05hbWUgKyAnXCInKVxuICAgICAgICB9XG5cbiAgICAgICAgbWV0aG9kID0gcGtnW21zZy5yZW1vdGVNZXRob2RdO1xuXG4gICAgICAgIGlmICghbWV0aG9kKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmVtb3RlIG1ldGhvZCBuYW1lIFwiJyArIG1zZy5yZW1vdGVNZXRob2QgKyAnXCInKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIGludGVyY2VwdGlvblxuICAgICAgICBpZiAoIXBrZy5pc1JlYWR5ICYmIHBrZy5pbnRlcmNlcHRSZW1vdGVzPy5pbmNsdWRlcyhtc2cucmVtb3RlTWV0aG9kKSkge1xuICAgICAgICAgICAgb3V0ID0gcGtnLm9uSW50ZXJjZXB0UmVtb3Rlcyhtc2cpO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobXNnLmRhdGEpKSB7XG4gICAgICAgICAgICBvdXQgPSBtZXRob2QuY2FsbChwa2csIC4uLm1zZy5kYXRhKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0ID0gbWV0aG9kLmNhbGwocGtnLCBtc2cuZGF0YSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChOZW8uaXNQcm9taXNlKG91dCkpIHtcbiAgICAgICAgICAgIG91dFxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogSW50ZW5kZWQgbG9naWM6XG4gICAgICAgICAgICAgICAgICogSWYgdGhlIGNvZGUgb2YgYSByZW1vdGUgbWV0aG9kIGZhaWxzLCBpdCB3b3VsZCBub3Qgc2hvdyBhbnkgZXJyb3JzIGluc2lkZSB0aGUgY29uc29sZSxcbiAgICAgICAgICAgICAgICAgKiBzbyB3ZSB3YW50IHRvIG1hbnVhbGx5IGxvZyB0aGUgZXJyb3IgZm9yIGRlYnVnZ2luZy5cbiAgICAgICAgICAgICAgICAgKiBSZWplY3RpbmcgdGhlIFByb21pc2UgZ2l2ZXMgdXMgdGhlIGNoYW5jZSB0byByZWNvdmVyLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogRXhhbXBsZTpcbiAgICAgICAgICAgICAgICAgKiBOZW8udmRvbS5IZWxwZXIudXBkYXRlKG9wdHMpLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICogICAgIG1lLmlzVmRvbVVwZGF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICogICAgIHJlamVjdD8uKClcbiAgICAgICAgICAgICAgICAgKiB9KS50aGVuKGRhdGEgPT4gey4uLn0pXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7Y29uc29sZS5lcnJvcihlcnIpOyBtZS5yZWplY3QobXNnLCBlcnIpfSlcbiAgICAgICAgICAgICAgICAudGhlbihkYXRhID0+IHttZS5yZXNvbHZlKG1zZywgZGF0YSl9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUucmVzb2x2ZShtc2csIG91dClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gcHJvbWlzZU1lc3NhZ2UgZ2V0cyByZWplY3RlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtc2dcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIHJlamVjdChtc2csIGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcblxuICAgICAgICBvcHRzID0ge1xuICAgICAgICAgICAgYWN0aW9uIDogJ3JlcGx5JyxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICByZWplY3QgOiB0cnVlLFxuICAgICAgICAgICAgcmVwbHlJZDogbXNnLmlkXG4gICAgICAgIH07XG5cbiAgICAgICAgbWUuaXNTaGFyZWRXb3JrZXIgJiYgbWUuYXNzaWduUG9ydChtc2csIG9wdHMpO1xuICAgICAgICBtZS5zZW5kTWVzc2FnZShtc2cub3JpZ2luLCBvcHRzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gcHJvbWlzZU1lc3NhZ2UgZ2V0cyByZXNvbHZlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtc2dcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIHJlc29sdmUobXNnLCBkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG5cbiAgICAgICAgb3B0cyA9IHtcbiAgICAgICAgICAgIGFjdGlvbiA6ICdyZXBseScsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcmVwbHlJZDogbXNnLmlkXG4gICAgICAgIH07XG5cbiAgICAgICAgbWUuaXNTaGFyZWRXb3JrZXIgJiYgbWUuYXNzaWduUG9ydChtc2csIG9wdHMpO1xuICAgICAgICBtZS5zZW5kTWVzc2FnZShtc2cub3JpZ2luLCBvcHRzKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoUmVtb3RlTWV0aG9kQWNjZXNzKTtcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4vLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5tID0gX193ZWJwYWNrX21vZHVsZXNfXztcblxuIiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5mID0ge307XG4vLyBUaGlzIGZpbGUgY29udGFpbnMgb25seSB0aGUgZW50cnkgY2h1bmsuXG4vLyBUaGUgY2h1bmsgbG9hZGluZyBmdW5jdGlvbiBmb3IgYWRkaXRpb25hbCBjaHVua3Ncbl9fd2VicGFja19yZXF1aXJlX18uZSA9IChjaHVua0lkKSA9PiB7XG5cdHJldHVybiBQcm9taXNlLmFsbChPYmplY3Qua2V5cyhfX3dlYnBhY2tfcmVxdWlyZV9fLmYpLnJlZHVjZSgocHJvbWlzZXMsIGtleSkgPT4ge1xuXHRcdF9fd2VicGFja19yZXF1aXJlX18uZltrZXldKGNodW5rSWQsIHByb21pc2VzKTtcblx0XHRyZXR1cm4gcHJvbWlzZXM7XG5cdH0sIFtdKSk7XG59OyIsIi8vIFRoaXMgZnVuY3Rpb24gYWxsb3cgdG8gcmVmZXJlbmNlIGFzeW5jIGNodW5rc1xuX193ZWJwYWNrX3JlcXVpcmVfXy51ID0gKGNodW5rSWQpID0+IHtcblx0Ly8gcmV0dXJuIHVybCBmb3IgZmlsZW5hbWVzIGJhc2VkIG9uIHRlbXBsYXRlXG5cdHJldHVybiBcImNodW5rcy9hcHAvXCIgKyBjaHVua0lkICsgXCIuanNcIjtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcblx0fVxufSkoKTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwidmFyIHNjcmlwdFVybDtcbmlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLmcuaW1wb3J0U2NyaXB0cykgc2NyaXB0VXJsID0gX193ZWJwYWNrX3JlcXVpcmVfXy5nLmxvY2F0aW9uICsgXCJcIjtcbnZhciBkb2N1bWVudCA9IF9fd2VicGFja19yZXF1aXJlX18uZy5kb2N1bWVudDtcbmlmICghc2NyaXB0VXJsICYmIGRvY3VtZW50KSB7XG5cdGlmIChkb2N1bWVudC5jdXJyZW50U2NyaXB0ICYmIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQudGFnTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnU0NSSVBUJylcblx0XHRzY3JpcHRVcmwgPSBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYztcblx0aWYgKCFzY3JpcHRVcmwpIHtcblx0XHR2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO1xuXHRcdGlmKHNjcmlwdHMubGVuZ3RoKSB7XG5cdFx0XHR2YXIgaSA9IHNjcmlwdHMubGVuZ3RoIC0gMTtcblx0XHRcdHdoaWxlIChpID4gLTEgJiYgKCFzY3JpcHRVcmwgfHwgIS9eaHR0cChzPyk6Ly50ZXN0KHNjcmlwdFVybCkpKSBzY3JpcHRVcmwgPSBzY3JpcHRzW2ktLV0uc3JjO1xuXHRcdH1cblx0fVxufVxuLy8gV2hlbiBzdXBwb3J0aW5nIGJyb3dzZXJzIHdoZXJlIGFuIGF1dG9tYXRpYyBwdWJsaWNQYXRoIGlzIG5vdCBzdXBwb3J0ZWQgeW91IG11c3Qgc3BlY2lmeSBhbiBvdXRwdXQucHVibGljUGF0aCBtYW51YWxseSB2aWEgY29uZmlndXJhdGlvblxuLy8gb3IgcGFzcyBhbiBlbXB0eSBzdHJpbmcgKFwiXCIpIGFuZCBzZXQgdGhlIF9fd2VicGFja19wdWJsaWNfcGF0aF9fIHZhcmlhYmxlIGZyb20geW91ciBjb2RlIHRvIHVzZSB5b3VyIG93biBsb2dpYy5cbmlmICghc2NyaXB0VXJsKSB0aHJvdyBuZXcgRXJyb3IoXCJBdXRvbWF0aWMgcHVibGljUGF0aCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlclwiKTtcbnNjcmlwdFVybCA9IHNjcmlwdFVybC5yZXBsYWNlKC9eYmxvYjovLCBcIlwiKS5yZXBsYWNlKC8jLiokLywgXCJcIikucmVwbGFjZSgvXFw/LiokLywgXCJcIikucmVwbGFjZSgvXFwvW15cXC9dKyQvLCBcIi9cIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBzY3JpcHRVcmw7IiwiLy8gbm8gYmFzZVVSSVxuXG4vLyBvYmplY3QgdG8gc3RvcmUgbG9hZGVkIGNodW5rc1xuLy8gXCIxXCIgbWVhbnMgXCJhbHJlYWR5IGxvYWRlZFwiXG52YXIgaW5zdGFsbGVkQ2h1bmtzID0ge1xuXHRcImFwcFwiOiAxXG59O1xuXG4vLyBpbXBvcnRTY3JpcHRzIGNodW5rIGxvYWRpbmdcbnZhciBpbnN0YWxsQ2h1bmsgPSAoZGF0YSkgPT4ge1xuXHR2YXIgW2NodW5rSWRzLCBtb3JlTW9kdWxlcywgcnVudGltZV0gPSBkYXRhO1xuXHRmb3IodmFyIG1vZHVsZUlkIGluIG1vcmVNb2R1bGVzKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKG1vcmVNb2R1bGVzLCBtb2R1bGVJZCkpIHtcblx0XHRcdF9fd2VicGFja19yZXF1aXJlX18ubVttb2R1bGVJZF0gPSBtb3JlTW9kdWxlc1ttb2R1bGVJZF07XG5cdFx0fVxuXHR9XG5cdGlmKHJ1bnRpbWUpIHJ1bnRpbWUoX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cdHdoaWxlKGNodW5rSWRzLmxlbmd0aClcblx0XHRpbnN0YWxsZWRDaHVua3NbY2h1bmtJZHMucG9wKCldID0gMTtcblx0cGFyZW50Q2h1bmtMb2FkaW5nRnVuY3Rpb24oZGF0YSk7XG59O1xuX193ZWJwYWNrX3JlcXVpcmVfXy5mLmkgPSAoY2h1bmtJZCwgcHJvbWlzZXMpID0+IHtcblx0Ly8gXCIxXCIgaXMgdGhlIHNpZ25hbCBmb3IgXCJhbHJlYWR5IGxvYWRlZFwiXG5cdGlmKCFpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0pIHtcblx0XHRpZih0cnVlKSB7IC8vIGFsbCBjaHVua3MgaGF2ZSBKU1xuXHRcdFx0aW1wb3J0U2NyaXB0cyhfX3dlYnBhY2tfcmVxdWlyZV9fLnAgKyBfX3dlYnBhY2tfcmVxdWlyZV9fLnUoY2h1bmtJZCkpO1xuXHRcdH1cblx0fVxufTtcblxudmFyIGNodW5rTG9hZGluZ0dsb2JhbCA9IHNlbGZbXCJ3ZWJwYWNrQ2h1bmtuZW9fbWpzXCJdID0gc2VsZltcIndlYnBhY2tDaHVua25lb19tanNcIl0gfHwgW107XG52YXIgcGFyZW50Q2h1bmtMb2FkaW5nRnVuY3Rpb24gPSBjaHVua0xvYWRpbmdHbG9iYWwucHVzaC5iaW5kKGNodW5rTG9hZGluZ0dsb2JhbCk7XG5jaHVua0xvYWRpbmdHbG9iYWwucHVzaCA9IGluc3RhbGxDaHVuaztcblxuLy8gbm8gSE1SXG5cbi8vIG5vIEhNUiBtYW5pZmVzdCIsImltcG9ydCBOZW8gICAgICAgICAgICAgZnJvbSAnLi4vTmVvLm1qcyc7XG5pbXBvcnQgQmFzZSAgICAgICAgICAgIGZyb20gJy4vQmFzZS5tanMnO1xuaW1wb3J0IEFwcGxpY2F0aW9uICAgICBmcm9tICcuLi9jb250cm9sbGVyL0FwcGxpY2F0aW9uLm1qcyc7XG5pbXBvcnQgSW5zdGFuY2VNYW5hZ2VyIGZyb20gJy4uL21hbmFnZXIvSW5zdGFuY2UubWpzJztcbmltcG9ydCBEb21FdmVudE1hbmFnZXIgZnJvbSAnLi4vbWFuYWdlci9Eb21FdmVudC5tanMnO1xuaW1wb3J0IEhhc2hIaXN0b3J5ICAgICBmcm9tICcuLi91dGlsL0hhc2hIaXN0b3J5Lm1qcyc7XG5cbi8qKlxuICogVGhlIEFwcCB3b3JrZXIgY29udGFpbnMgbW9zdCBwYXJ0cyBvZiB0aGUgZnJhbWV3b3JrIGFzIHdlbGwgYXMgYWxsIGFwcHMgd2hpY2ggZ2V0IGNyZWF0ZWQuXG4gKiBTZWUgdGhlIHR1dG9yaWFscyBmb3IgZnVydGhlciBpbmZvcy5cbiAqIEBjbGFzcyBOZW8ud29ya2VyLkFwcFxuICogQGV4dGVuZHMgTmVvLndvcmtlci5CYXNlXG4gKiBAc2luZ2xldG9uXG4gKi9cbmNsYXNzIEFwcCBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLndvcmtlci5BcHAnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby53b3JrZXIuQXBwJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gY291bnRMb2FkaW5nVGhlbWVGaWxlc189MFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGNvdW50TG9hZGluZ1RoZW1lRmlsZXNfOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3RlIG1ldGhvZCBhY2Nlc3MgZm9yIG90aGVyIHdvcmtlcnNcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSByZW1vdGVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3RlOiB7XG4gICAgICAgICAgICBtYWluOiBbXG4gICAgICAgICAgICAgICAgJ2NyZWF0ZU5lb0luc3RhbmNlJyxcbiAgICAgICAgICAgICAgICAnZGVzdHJveU5lb0luc3RhbmNlJyxcbiAgICAgICAgICAgICAgICAnZmlyZUV2ZW50JyxcbiAgICAgICAgICAgICAgICAnZ2V0Q29uZmlncycsXG4gICAgICAgICAgICAgICAgJ3NldENvbmZpZ3MnLFxuICAgICAgICAgICAgICAgICdzZXRHbG9iYWxDb25maWcnIC8vIHBvaW50cyB0byB3b3JrZXIuQmFzZTogc2V0R2xvYmFsQ29uZmlnKClcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZXRvbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZXRvbjogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdlIGFyZSBzdG9yaW5nIHRoZSBwYXJhbXMgb2YgaW5zZXJ0VGhlbWVGaWxlcygpIGNhbGxzIGhlcmUsIGluIGNhc2UgdGhlIG1ldGhvZCBkb2VzIGdldCB0cmlnZ2VyZWRcbiAgICAgKiBiZWZvcmUgdGhlIGpzb24gdGhlbWUgc3RydWN0dXJlIGdvdCBsb2FkZWQuXG4gICAgICogQG1lbWJlciB7QXJyYXlbXX0gdGhlbWVGaWxlc0NhY2hlPVtdXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRoZW1lRmlsZXNDYWNoZSA9IFtdXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7U3RyaW5nfSB3b3JrZXJJZD0nYXBwJ1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB3b3JrZXJJZCA9ICdhcHAnXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIC8vIGNvbnZlbmllbmNlIHNob3J0Y3V0c1xuICAgICAgICBOZW8uYXBwbHlEZWx0YXMgICAgPSBtZS5hcHBseURlbHRhcyAgIC5iaW5kKG1lKTtcbiAgICAgICAgTmVvLnNldENzc1ZhcmlhYmxlID0gbWUuc2V0Q3NzVmFyaWFibGUuYmluZChtZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGNvdW50TG9hZGluZ1RoZW1lRmlsZXMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Q291bnRMb2FkaW5nVGhlbWVGaWxlcyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSAwICYmIG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgndGhlbWVGaWxlc0xvYWRlZCcpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXBwTmFtZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBkZWx0YXNcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTwqPn1cbiAgICAgKi9cbiAgICBhcHBseURlbHRhcyhhcHBOYW1lLCBkZWx0YXMpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLnByb21pc2VNZXNzYWdlKCdtYWluJywge2FjdGlvbjogJ3VwZGF0ZURvbScsIGFwcE5hbWUsIGRlbHRhc30pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3RlIG1ldGhvZCB0byB1c2UgaW5zaWRlIG1haW4gdGhyZWFkcyBmb3IgY3JlYXRpbmcgbmVvIGJhc2VkIGNsYXNzIGluc3RhbmNlcy5cbiAgICAgKiBCZSBhd2FyZSB0aGF0IHlvdSBjYW4gb25seSBwYXNzIGNvbmZpZ3Mgd2hpY2ggY2FuIGdldCBjb252ZXJ0ZWQgaW50byBwdXJlIEpTT04uXG4gICAgICpcbiAgICAgKiBNb3VudGluZyBhIGNvbXBvbmVudCBpbnRvIHRoZSBkb2N1bWVudC5ib2R5XG4gICAgICogQGV4YW1wbGU6XG4gICAgICogICAgIE5lby53b3JrZXIuQXBwLmNyZWF0ZU5lb0luc3RhbmNlKHtcbiAgICAgKiAgICAgICAgIG50eXBlICAgICAgICA6ICdidXR0b24nLFxuICAgICAqICAgICAgICAgYXV0b0luaXRWbm9kZTogdHJ1ZSxcbiAgICAgKiAgICAgICAgIGF1dG9Nb3VudCAgICA6IHRydWUsXG4gICAgICogICAgICAgICB0ZXh0ICAgICAgICAgOiAnSGkgTmlnZSEnXG4gICAgICogICAgIH0pLnRoZW4oaWQgPT4gY29uc29sZS5sb2coaWQpKVxuICAgICAqXG4gICAgICogSW5zZXJ0aW5nIGEgY29tcG9uZW50IGludG8gYSBjb250YWluZXJcbiAgICAgKiBAZXhhbXBsZTpcbiAgICAgKiAgICAgTmVvLndvcmtlci5BcHAuY3JlYXRlTmVvSW5zdGFuY2Uoe1xuICAgICAqICAgICAgICAgbnR5cGUgICAgICA6ICdidXR0b24nLFxuICAgICAqICAgICAgICAgcGFyZW50SWQgICA6ICduZW8tY29udGFpbmVyLTMnLFxuICAgICAqICAgICAgICAgcGFyZW50SW5kZXg6IDBcbiAgICAgKiAgICAgICAgIHRleHQgICAgICAgOiAnSGkgTmlnZSEnXG4gICAgICogICAgIH0pLnRoZW4oaWQgPT4gY29uc29sZS5sb2coaWQpKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmltcG9ydFBhdGhdIHlvdSBjYW4gbGF6eSBsb2FkIG1pc3NpbmcgY2xhc3NlcyB2aWEgdGhpcyBjb25maWcuIGRldiBtb2RlIG9ubHkuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcucGFyZW50SWRdIHBhc3NpbmcgYSBwYXJlbnRJZCB3aWxsIHB1dCB5b3VyIGluc3RhbmNlIGludG8gYSBjb250YWluZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5wYXJlbnRJbmRleF0gaWYgYSBwYXJlbnRJZCBpcyBwYXNzZWQsIGJ1dCBubyBpbmRleCwgbmVvIHdpbGwgdXNlIGFkZCgpXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdGhlIGluc3RhbmNlIGlkXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlTmVvSW5zdGFuY2UoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcuaW1wb3J0UGF0aCkge1xuICAgICAgICAgICAgYXdhaXQgaW1wb3J0KC8qIHdlYnBhY2tJZ25vcmU6IHRydWUgKi8gY29uZmlnLmltcG9ydFBhdGgpO1xuICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5pbXBvcnRQYXRoXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgYXBwTmFtZSAgID0gT2JqZWN0LmtleXMoTmVvLmFwcHMpWzBdLCAvLyBmYWxsYmFjayBpbiBjYXNlIG5vIGFwcE5hbWUgd2FzIHByb3ZpZGVkXG4gICAgICAgICAgICBDb250YWluZXIgPSBOZW8uY29udGFpbmVyPy5CYXNlLFxuICAgICAgICAgICAgaW5kZXgsIGluc3RhbmNlLCBwYXJlbnQ7XG5cbiAgICAgICAgY29uZmlnID0ge2FwcE5hbWUsIC4uLmNvbmZpZ307XG5cbiAgICAgICAgaWYgKGNvbmZpZy5wYXJlbnRJZCkge1xuICAgICAgICAgICAgcGFyZW50ID0gTmVvLmdldENvbXBvbmVudChjb25maWcucGFyZW50SWQpO1xuXG4gICAgICAgICAgICBpZiAoQ29udGFpbmVyICYmIHBhcmVudCAmJiBwYXJlbnQgaW5zdGFuY2VvZiBDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGNvbmZpZy5wYXJlbnRJbmRleDtcblxuICAgICAgICAgICAgICAgIGRlbGV0ZSBjb25maWcucGFyZW50SWQ7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5wYXJlbnRJbmRleDtcblxuICAgICAgICAgICAgICAgIGlmIChOZW8uaXNOdW1iZXIoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlID0gcGFyZW50Lmluc2VydChpbmRleCwgY29uZmlnKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlID0gcGFyZW50LmFkZChjb25maWcpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZGVmYXVsdCBwYXJlbnRJZD0nZG9jdW1lbnQuYm9keScgPT4gd2Ugd2FudCBpdCB0byBnZXQgc2hvd25cbiAgICAgICAgICAgIGNvbmZpZy5hdXRvSW5pdFZub2RlID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5hdXRvTW91bnQgICAgID0gdHJ1ZTtcblxuICAgICAgICAgICAgaW5zdGFuY2UgPSBOZW9bY29uZmlnLm50eXBlID8gJ250eXBlJyA6ICdjcmVhdGUnXShjb25maWcpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5zdGFuY2UuaWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGNyZWF0ZVRoZW1lTWFwKGRhdGEpIHtcbiAgICAgICAgTmVvLm5zKCdOZW8uY3NzTWFwLmZpbGVJbmZvJywgdHJ1ZSk7XG4gICAgICAgIE5lby5jc3NNYXAuZmlsZUluZm8gPSBkYXRhO1xuICAgICAgICB0aGlzLnJlc29sdmVUaGVtZUZpbGVzQ2FjaGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW90ZSBtZXRob2QgdG8gdXNlIGluc2lkZSBtYWluIHRocmVhZHMgZm9yIGRlc3Ryb3lpbmcgbmVvIGJhc2VkIGNsYXNzIGluc3RhbmNlcy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlOlxuICAgICAqICAgICBOZW8ud29ya2VyLkFwcC5kZXN0cm95TmVvSW5zdGFuY2UoJ25lby1idXR0b24tMycpLnRoZW4oc3VjY2VzcyA9PiBjb25zb2xlLmxvZyhzdWNjZXNzKSlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSByZXR1cm5zIHRydWUsIGluIGNhc2UgdGhlIGluc3RhbmNlIHdhcyBmb3VuZFxuICAgICAqL1xuICAgIGRlc3Ryb3lOZW9JbnN0YW5jZShpZCkge1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSBOZW8uZ2V0KGlkKSxcbiAgICAgICAgICAgIHBhcmVudDtcblxuICAgICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZS5wYXJlbnRJZCkge1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IE5lby5nZXRDb21wb25lbnQoaW5zdGFuY2UucGFyZW50SWQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQucmVtb3ZlKGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGluc3RhbmNlLmRlc3Ryb3kodHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlyZXMgYSBjdXN0b20gZXZlbnQgYmFzZWQgb24gY29yZS5PYnNlcnZhYmxlIG9uIGFueSBhcHAgcmVhbG0gYmFzZWQgTmVvIGluc3RhbmNlIGZyb20gbWFpblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5uYW1lXG4gICAgICovXG4gICAgZmlyZUV2ZW50KGRhdGEpIHtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gTmVvLmdldChkYXRhLmlkKSxcbiAgICAgICAgICAgIG5hbWU7XG5cbiAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgICBuYW1lID0gZGF0YS5uYW1lO1xuXG4gICAgICAgICAgICBkZWxldGUgZGF0YS5pZDtcbiAgICAgICAgICAgIGRlbGV0ZSBkYXRhLm5hbWU7XG5cbiAgICAgICAgICAgIGluc3RhbmNlLmZpcmUobmFtZSwgZGF0YSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPbmx5IG5lZWRlZCBmb3IgdGhlIFNoYXJlZFdvcmtlcnMgY29udGV4dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGZpcmVNYWluVmlld3NFdmVudChldmVudE5hbWUsIGRhdGEpIHtcbiAgICAgICAgdGhpcy5wb3J0cy5mb3JFYWNoKHBvcnQgPT4ge1xuICAgICAgICAgICAgTmVvLmFwcHNbcG9ydC5hcHBOYW1lXS5tYWluVmlldy5maXJlKGV2ZW50TmFtZSwgZGF0YSlcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dCB0byBsYXp5LWxvYWQgbWFpbiB0aHJlYWQgYWRkb25zLCBpbiBjYXNlIHRoZXkgYXJlIG5vdCBpbXBvcnRlZCB5ZXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aW5kb3dJZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE5lby5tYWluLmFkZG9uLkJhc2U+fSBUaGUgbmFtZXNwYWNlIG9mIHRoZSBhZGRvbiB0byB1c2UgdmlhIHJlbW90ZSBtZXRob2QgYWNjZXNzXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWRkb24obmFtZSwgd2luZG93SWQpIHtcbiAgICAgICAgbGV0IGFkZG9uID0gTmVvLm1haW4/LmFkZG9uPy5bbmFtZV07XG5cbiAgICAgICAgaWYgKCFhZGRvbikge1xuICAgICAgICAgICAgYXdhaXQgTmVvLk1haW4uaW1wb3J0QWRkb24oe25hbWUsIHdpbmRvd0lkfSk7XG4gICAgICAgICAgICBhZGRvbiA9IE5lby5tYWluLmFkZG9uW25hbWVdXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYWRkb25cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY29uZmlncyBvZiBhbnkgYXBwIHJlYWxtIGJhc2VkIE5lbyBpbnN0YW5jZSBmcm9tIG1haW5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8U3RyaW5nW119IGRhdGEua2V5c1xuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgY29uZmlncyBpZiBhIGtleXMgYXJyYXkgd2FzIHBhc3NlZC5cbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBhIGdpdmVuIGNvbmZpZyBkaXJlY3RseSwgaW4gY2FzZSBubyBhcnJheSB3YXMgcGFzc2VkXG4gICAgICogUmV0dXJucyBmYWxzZSwgaW4gY2FzZSBubyBpbnN0YW5jZSBnb3QgZm91bmQuXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0Q29uZmlncyhkYXRhKSB7XG4gICAgICAgIGxldCBpbnN0YW5jZSAgICA9IE5lby5nZXQoZGF0YS5pZCksXG4gICAgICAgICAgICB7a2V5c30gICAgICA9IGRhdGEsXG4gICAgICAgICAgICByZXR1cm5BcnJheSA9IFtdO1xuXG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGtleXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlW2tleXNdXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybkFycmF5LnB1c2goaW5zdGFuY2Vba2V5XSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuQXJyYXlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgaW1wb3J0QXBwKHBhdGgpIHtcbiAgICAgICAgaWYgKHBhdGguZW5kc1dpdGgoJy5tanMnKSkge1xuICAgICAgICAgICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgLTQpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW1wb3J0KFxuICAgICAgICAgICAgLyogd2VicGFja0luY2x1ZGU6IC8oPzpcXC98XFxcXClhcHAubWpzJC8gKi9cbiAgICAgICAgICAgIC8qIHdlYnBhY2tFeGNsdWRlOiAvKD86XFwvfFxcXFwpKGRpc3R8bm9kZV9tb2R1bGVzKS8oPyFuZW8ubWpzKSAqL1xuICAgICAgICAgICAgLyogd2VicGFja01vZGU6IFwibGF6eVwiICovXG4gICAgICAgICAgICBgLi4vLi4vJHtwYXRofS5tanNgXG4gICAgICAgIClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbiBjYXNlIHlvdSBkb24ndCB3YW50IHRvIGluY2x1ZGUgcHJvdG90eXBlIGJhc2VkIENTUyBmaWxlcywgdXNlIHRoZSBjbGFzc05hbWUgcGFyYW0gaW5zdGVhZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aW5kb3dJZFxuICAgICAqIEBwYXJhbSB7TmVvLmNvcmUuQmFzZX0gW3Byb3RvXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY2xhc3NOYW1lXVxuICAgICAqL1xuICAgIGluc2VydFRoZW1lRmlsZXMod2luZG93SWQsIHByb3RvLCBjbGFzc05hbWUpIHtcbiAgICAgICAgaWYgKE5lby5jb25maWcudGhlbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZSB8fCBwcm90by5jbGFzc05hbWU7XG5cbiAgICAgICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGNzc01hcCA9IE5lby5jc3NNYXAsXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcHJvdG8/Ll9fcHJvdG9fXyxcbiAgICAgICAgICAgICAgICBjbGFzc1BhdGgsIGNsYXNzUm9vdCwgZmlsZU5hbWUsIGxDbGFzc1Jvb3QsIG1hcENsYXNzTmFtZSwgbnMsIHRoZW1lRm9sZGVycztcblxuICAgICAgICAgICAgaWYgKCFjc3NNYXApIHtcbiAgICAgICAgICAgICAgICBtZS50aGVtZUZpbGVzQ2FjaGUucHVzaChbd2luZG93SWQsIHByb3RvXSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBtb2RpZnkgYXBwIHJlbGF0ZWQgY2xhc3MgbmFtZXNcbiAgICAgICAgICAgICAgICBpZiAoIWNsYXNzTmFtZS5zdGFydHNXaXRoKCdOZW8uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lICA9IGNsYXNzTmFtZS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgICAgICAgICBjbGFzc1Jvb3QgID0gY2xhc3NOYW1lLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGxDbGFzc1Jvb3QgPSBjbGFzc1Jvb3QudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVbMF0gPT09ICd2aWV3JyAmJiBjbGFzc05hbWUuc2hpZnQoKTtcblxuICAgICAgICAgICAgICAgICAgICBtYXBDbGFzc05hbWUgPSBgYXBwcy4ke05lby5hcHBzW2NsYXNzUm9vdF0/LmFwcFRoZW1lRm9sZGVyIHx8IGxDbGFzc1Jvb3R9LiR7Y2xhc3NOYW1lLmpvaW4oJy4nKX1gO1xuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWUgICAgPSBgYXBwcy4ke2xDbGFzc1Jvb3R9LiR7Y2xhc3NOYW1lLmpvaW4oJy4nKX1gO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50ICE9PSBOZW8uY29yZS5CYXNlLnByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIU5lby5ucyhgJHt3aW5kb3dJZH0uJHtwYXJlbnQuY2xhc3NOYW1lfWAsIGZhbHNlLCBjc3NNYXApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5pbnNlcnRUaGVtZUZpbGVzKHdpbmRvd0lkLCBwYXJlbnQpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGVtZUZvbGRlcnMgPSBOZW8ubnMobWFwQ2xhc3NOYW1lIHx8IGNsYXNzTmFtZSwgZmFsc2UsIGNzc01hcC5maWxlSW5mbyk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhlbWVGb2xkZXJzICYmICFOZW8ubnMoYCR7d2luZG93SWR9LiR7Y2xhc3NOYW1lfWAsIGZhbHNlLCBjc3NNYXApKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzUGF0aCA9IGNsYXNzTmFtZS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZSAgPSBjbGFzc1BhdGgucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzUGF0aCA9IGNsYXNzUGF0aC5qb2luKCcuJyk7XG4gICAgICAgICAgICAgICAgICAgIG5zICAgICAgICA9IE5lby5ucyhgJHt3aW5kb3dJZH0uJHtjbGFzc1BhdGh9YCwgdHJ1ZSwgY3NzTWFwKTtcblxuICAgICAgICAgICAgICAgICAgICBuc1tmaWxlTmFtZV0gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIG1lLmNvdW50TG9hZGluZ1RoZW1lRmlsZXMrKztcblxuICAgICAgICAgICAgICAgICAgICBOZW8ubWFpbi5hZGRvbi5TdHlsZXNoZWV0LmFkZFRoZW1lRmlsZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBtYXBDbGFzc05hbWUgfHwgY2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9sZGVycyAgOiB0aGVtZUZvbGRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3dJZFxuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLmNvdW50TG9hZGluZ1RoZW1lRmlsZXMtLVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2ZXJ5IGRvbSBldmVudCB3aWxsIGdldCBmb3J3YXJkZWQgYXMgYSB3b3JrZXIgbWVzc2FnZSBmcm9tIG1haW4gYW5kIGVuZHMgdXAgaGVyZSBmaXJzdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIHVzZWZ1bCBldmVudCBwcm9wZXJ0aWVzLCBkaWZmZXJzIGZvciBkaWZmZXJlbnQgZXZlbnQgdHlwZXMuIFNlZSBOZW8ubWFpbi5Eb21FdmVudHMuXG4gICAgICovXG4gICAgb25Eb21FdmVudChkYXRhKSB7XG4gICAgICAgIERvbUV2ZW50TWFuYWdlci5maXJlKGRhdGEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZlcnkgVVJMIGhhc2gtY2hhbmdlIHdpbGwgY3JlYXRlIGEgcG9zdCBtZXNzYWdlIGluIG1haW4gYW5kIGVuZCB1cCBoZXJlIGZpcnN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIHBhcnNlZCBrZXktdmFsdWUgcGFpcnMgZm9yIGVhY2ggaGFzaCB2YWx1ZVxuICAgICAqL1xuICAgIG9uSGFzaENoYW5nZShkYXRhKSB7XG4gICAgICAgIEhhc2hIaXN0b3J5LnB1c2goZGF0YS5kYXRhKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBzdGFydGluZyBwb2ludCBmb3IgYXBwc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Mb2FkQXBwbGljYXRpb24oZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjb25maWd9ICA9IE5lbyxcbiAgICAgICAgICAgIHthcHBQYXRofSA9IGNvbmZpZztcblxuICAgICAgICBpZiAoY29uZmlnLmVudmlyb25tZW50ICE9PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICBhcHBQYXRoID0gYXBwUGF0aC5zdGFydHNXaXRoKCcvJykgPyBhcHBQYXRoLnN1YnN0cmluZygxKSA6IGFwcFBhdGhcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmltcG9ydEFwcChhcHBQYXRoKS50aGVuKG1vZHVsZSA9PiB7XG4gICAgICAgICAgICBtb2R1bGUub25TdGFydCgpO1xuXG4gICAgICAgICAgICAvLyBzaG9ydCBkZWxheSB0byBlbnN1cmUgQ29tcG9uZW50IENvbnRyb2xsZXJzIGFyZSByZWFkeVxuICAgICAgICAgICAgY29uZmlnLmhhc2ggJiYgbWUudGltZW91dCg1KS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBIYXNoSGlzdG9yeS5wdXNoKGNvbmZpZy5oYXNoKTtcbiAgICAgICAgICAgICAgICAvLyBhcHBzIHdoaWNoIHdpbGwgZ2V0IGNyZWF0ZWQgbGF0ZXIgbXVzdCBub3QgdXNlIG91dGRhdGVkIGhhc2ggdmFsdWVzXG4gICAgICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5oYXNoXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpcmUgZXZlbnQgb24gYWxsIGFwcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLmFuZ2xlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEubGF5b3V0IGxhbmRzY2FwZXxwb3J0cmFpdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLnR5cGUgbGFuZHNjYXBlLXByaW1hcnl8bGFuZHNjYXBlLXNlY29uZGFyeXxwb3J0cmFpdC1wcmltYXJ5fHBvcnRyYWl0LXNlY29uZGFyeVxuICAgICAqL1xuICAgIG9uT3JpZW50YXRpb25DaGFuZ2UoZGF0YSkge1xuICAgICAgICBPYmplY3QudmFsdWVzKE5lby5hcHBzKS5mb3JFYWNoKGFwcCA9PiB7XG4gICAgICAgICAgICBhcHAuZmlyZSgnb3JpZW50YXRpb25jaGFuZ2UnLCBkYXRhLmRhdGEpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1zZ1xuICAgICAqL1xuICAgIG9uUmVnaXN0ZXJOZW9Db25maWcobXNnKSB7XG4gICAgICAgIHN1cGVyLm9uUmVnaXN0ZXJOZW9Db25maWcobXNnKTtcblxuICAgICAgICBsZXQge2NvbmZpZ30gPSBOZW8sXG4gICAgICAgICAgICB7ZGF0YX0gICA9IG1zZyxcbiAgICAgICAgICAgIHVybCAgICAgID0gJ3Jlc291cmNlcy90aGVtZS1tYXAuanNvbic7XG5cbiAgICAgICAgTmVvLndpbmRvd0NvbmZpZ3MgPSBOZW8ud2luZG93Q29uZmlncyB8fCB7fTtcblxuICAgICAgICBOZW8ud2luZG93Q29uZmlnc1tkYXRhLndpbmRvd0lkXSA9IGRhdGE7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5lbnZpcm9ubWVudCA9PT0gJ2RldmVsb3BtZW50JyB8fCBjb25maWcuZW52aXJvbm1lbnQgPT09ICdkaXN0L2VzbScpIHtcbiAgICAgICAgICAgIHVybCA9IGAuLi8uLi8ke3VybH1gXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLndvcmtlckJhc2VQYXRoPy5pbmNsdWRlcygnbm9kZV9tb2R1bGVzJykpIHtcbiAgICAgICAgICAgIHVybCA9IGAuLi8uLi8ke3VybH1gXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXJsWzBdICE9PSAnLicpIHtcbiAgICAgICAgICAgIHVybCA9IGAuLyR7dXJsfWBcbiAgICAgICAgfVxuXG4gICAgICAgIGZldGNoKHVybClcbiAgICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmpzb24oKSlcbiAgICAgICAgICAgIC50aGVuKGRhdGEgPT4ge3RoaXMuY3JlYXRlVGhlbWVNYXAoZGF0YSl9KTtcblxuICAgICAgICBjb25maWcucmVtb3Rlc0FwaVVybCAgJiYgaW1wb3J0KCcuLi9yZW1vdGVzL0FwaS5tanMnKS50aGVuKG1vZHVsZSA9PiBtb2R1bGUuZGVmYXVsdC5sb2FkKCkpO1xuICAgICAgICAhY29uZmlnLnVzZVZkb21Xb3JrZXIgJiYgaW1wb3J0KCcuLi92ZG9tL0hlbHBlci5tanMnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtc2dcbiAgICAgKi9cbiAgICBvblJlZ2lzdGVyUG9ydChtc2cpIHtcbiAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgcG9ydCA9IG1zZy50cmFuc2ZlcjtcblxuICAgICAgICBwb3J0Lm9ubWVzc2FnZSA9IG1lLm9uTWVzc2FnZS5iaW5kKG1lKTtcblxuICAgICAgICBtZS5jaGFubmVsUG9ydHNbbXNnLm9yaWdpbl0gPSBwb3J0XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbldpbmRvd1Bvc2l0aW9uQ2hhbmdlKGRhdGEpIHtcbiAgICAgICAgdGhpcy5maXJlTWFpblZpZXdzRXZlbnQoJ3dpbmRvd1Bvc2l0aW9uQ2hhbmdlJywgZGF0YS5kYXRhKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9ubHkgbmVlZGVkIGZvciBTaGFyZWRXb3JrZXJzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFwcE5hbWVcbiAgICAgKi9cbiAgICByZWdpc3RlckFwcChhcHBOYW1lKSB7XG4gICAgICAgIC8vIHJlZ2lzdGVyIHRoZSBuYW1lIGFzIGZhc3QgYXMgcG9zc2libGVcbiAgICAgICAgdGhpcy5vblJlZ2lzdGVyQXBwKHsgYXBwTmFtZSB9KTtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZSgnbWFpbicsIHthY3Rpb246ICdyZWdpc3RlckFwcE5hbWUnLCBhcHBOYW1lfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVbnJlZ2lzdGVyIHRoZSBhcHAgZnJvbSB0aGUgQ1NTIG1hcFxuICAgICAqIE9ubHkgbmVlZGVkIGZvciBTaGFyZWRXb3JrZXJzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFwcE5hbWVcbiAgICAgKi9cbiAgICByZW1vdmVBcHBGcm9tVGhlbWVNYXAoYXBwTmFtZSkge1xuICAgICAgICBkZWxldGUgTmVvLmNzc01hcFthcHBOYW1lLnRvTG93ZXJDYXNlKCldXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICByZXNvbHZlVGhlbWVGaWxlc0NhY2hlKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnRoZW1lRmlsZXNDYWNoZS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgbWUuaW5zZXJ0VGhlbWVGaWxlcyguLi5pdGVtKVxuICAgICAgICB9KTtcblxuICAgICAgICBtZS50aGVtZUZpbGVzQ2FjaGUgPSBbXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBjb25maWdzIG9mIGFueSBhcHAgcmVhbG0gYmFzZWQgTmVvIGluc3RhbmNlIGZyb20gbWFpblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuaWRcbiAgICAgKi9cbiAgICBzZXRDb25maWdzKGRhdGEpIHtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gTmVvLmdldChkYXRhLmlkKTtcblxuICAgICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBkYXRhLmlkO1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0KGRhdGEpO1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5rZXlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2RhdGEucHJpb3JpdHldIG9wdGlvbmFsbHkgcGFzcyAnaW1wb3J0YW50J1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLnRoZW1lPU5lby5jb25maWcudGhlbWVzWzBdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEudmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS53aW5kb3dJZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgYXN5bmMgc2V0Q3NzVmFyaWFibGUoZGF0YSkge1xuICAgICAgICBsZXQgU3R5bGVzaGVldCA9IGF3YWl0IHRoaXMuZ2V0QWRkb24oJ1N0eWxlc2hlZXQnLCBkYXRhLndpbmRvd0lkKSxcbiAgICAgICAgICAgIHRoZW1lICAgICAgPSBkYXRhLnRoZW1lIHx8IE5lby5jb25maWcudGhlbWVzPy5bMF07XG5cbiAgICAgICAgaWYgKHRoZW1lLnN0YXJ0c1dpdGgoJ25lby0nKSkge1xuICAgICAgICAgICAgdGhlbWUgPSB0aGVtZS5zdWJzdHJpbmcoNClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBTdHlsZXNoZWV0LnNldENzc1ZhcmlhYmxlKHt0aGVtZSwgLi4uZGF0YX0pXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhBcHApO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9