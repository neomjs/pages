import e from"../../../src/core/Base.mjs";import n from"./config.mjs";import s from"./GitHub.mjs";import o from"./Storage.mjs";export default Neo.setupClass(class extends e{static config={className:"DevIndex.services.OptIn",singleton:!0,optInRepoOwner:"neomjs",optInRepoName:"devindex-opt-in"};async run(){console.log("[OptIn] Checking for new opt-in requests...");const e=(await o.getOptInSync()).lastCheck;let n=e,t=!0,i=null,a=[];for(;t;){const o="\n                query($owner: String!, $name: String!, $cursor: String) {\n                    repository(owner: $owner, name: $name) {\n                        stargazers(first: 100, orderBy: {field: STARRED_AT, direction: DESC}, after: $cursor) {\n                            pageInfo {\n                                hasNextPage\n                                endCursor\n                            }\n                            edges {\n                                starredAt\n                                node {\n                                    login\n                                }\n                            }\n                        }\n                    }\n                }",r={owner:this.optInRepoOwner,name:this.optInRepoName,cursor:i};let l;try{l=await s.query(o,r,3,"OptIn Stars")}catch(e){if(e.message.includes("NOT_FOUND")||e.message.includes("Could not resolve"))return void console.warn(`[OptIn] Opt-in repository ${this.optInRepoOwner}/${this.optInRepoName} not found. Skipping.`);throw e}const u=l?.repository?.stargazers;if(!u)break;const c=u.edges||[];let d=!1;for(const s of c){const o=s.starredAt,t=s.node.login;if(e&&o<=e){d=!0;break}(!n||o>n)&&(n=o),a.push(t)}if(d)break;t=u.pageInfo.hasNextPage,i=u.pageInfo.endCursor}const r=await this.processIssues();let l=[...new Set(a)],u=[...l],c=[];if(r&&(l.push(...r.selfLogins),l.push(...r.othersLogins),u.push(...r.selfLogins),c.push(...r.issuesToClose),l=[...new Set(l)],u=[...new Set(u)]),l.length>0){console.log(`[OptIn] Found ${l.length} new opt-in requests:`,l);const e=await o.getBlocklist(),s=u.filter(n=>e.has(n.toLowerCase()));s.length>0&&(console.log("[OptIn] Removing from blocklist:",s),await o.removeFromBlocklist(s));const t=await o.getTracker(),i=new Set(t.map(e=>e.login.toLowerCase())),a=await o.getBlocklist(),r=l.filter(e=>{const n=e.toLowerCase();return!i.has(n)&&!a.has(n)});if(r.length>0){console.log("[OptIn] Adding to tracker:",r);const e=r.map(e=>({login:e,lastUpdate:null}));await o.updateTracker(e)}else console.log("[OptIn] All opted-in users are already tracked or blocked.");await o.saveOptInSync({lastCheck:n}),console.log(`[OptIn] Processed opt-ins and updated sync state to ${n}.`)}else console.log("[OptIn] No new opt-in requests found.");if(c.length>0){const e=await o.getTracker(),n=new Set(e.map(e=>e.login.toLowerCase())),s=await o.getBlocklist();await this.closeIssues(c,n,s)}}async processIssues(){console.log("[OptIn] Checking for new opt-in issue requests...");let e=!0,n=null,o=[],t=[],i=[];for(;e;){const a='\n                query($owner: String!, $name: String!, $cursor: String) {\n                    repository(owner: $owner, name: $name) {\n                        issues(first: 100, states: OPEN, labels: ["devindex-opt-in"], after: $cursor) {\n                            pageInfo {\n                                hasNextPage\n                                endCursor\n                            }\n                            nodes {\n                                id\n                                number\n                                body\n                                author {\n                                    login\n                                }\n                            }\n                        }\n                    }\n                }',r={owner:this.optInRepoOwner,name:this.optInRepoName,cursor:n};let l;try{l=await s.query(a,r,3,"OptIn Issues")}catch(e){if(e.message.includes("NOT_FOUND")||e.message.includes("Could not resolve"))return null;throw e}const u=l?.repository?.issues;if(!u)break;const c=u.nodes||[];for(const e of c){const n=e.body.match(/### GitHub Usernames\s*([\s\S]*?)(?:###|$)/);if(n){const o=n[1].split("\n").map(e=>e.trim()).filter(e=>e&&!e.startsWith("-")&&!e.startsWith("[")),a=[],r=[];for(const e of o)try{await s.rest(`users/${e}`),a.push(e),t.push(e)}catch(n){r.push(e)}i.push({id:e.id,type:"others",validLogins:a,invalidLogins:r})}else e.author&&e.author.login&&(o.push(e.author.login),i.push({id:e.id,type:"self",logins:[e.author.login]}))}e=u.pageInfo.hasNextPage,n=u.pageInfo.endCursor}return{selfLogins:o,othersLogins:t,issuesToClose:i}}async closeIssues(e,n,o){for(const t of e)try{let e="";if("self"===t.type){const s=t.logins[0];e=n.has(s.toLowerCase())?`Thank you for opting in! @${s} is already in our tracking queue and will be processed soon.\n\n*This issue has been automatically closed.*`:`Thank you for opting in! @${s} has been added to our tracking queue.\n\n*This issue has been automatically closed.*`}else if("others"===t.type){if(t.validLogins&&t.validLogins.length>0){e="Thank you for your nominations!\n\n";const s=[],i=[],a=[];t.validLogins.forEach(e=>{const t=e.toLowerCase();o.has(t)?a.push(e):n.has(t)?i.push(e):s.push(e)}),s.length>0&&(e+=`**Successfully Added to Queue:**\n${s.map(e=>`- @${e}`).join("\n")}\n\n`),i.length>0&&(e+=`**Already in Queue (Skipped):**\n${i.map(e=>`- @${e}`).join("\n")}\n\n`),a.length>0&&(e+=`**Opted Out (Skipped):**\n${a.map(e=>`- @${e}`).join("\n")}\n*(Note: Users who have explicitly opted out can only opt back in themselves.)*\n\n`),t.invalidLogins&&t.invalidLogins.length>0&&(e+=`**Failed Validation (Not Found):**\n${t.invalidLogins.map(e=>`- ${e}`).join("\n")}\n\n`)}else t.invalidLogins&&t.invalidLogins.length>0?(e="We could not validate any of the provided usernames. Please double-check them and submit a new request if needed.\n\n",e+=`**Failed Validation (Not Found):**\n${t.invalidLogins.map(e=>`- ${e}`).join("\n")}\n\n`):e="We could not parse any usernames from this issue. Please ensure you follow the issue template format.\n\n";e+="*This issue has been automatically closed.*"}else e="We could not parse the usernames from this issue. Please ensure you follow the issue template format.\n\n*This issue has been automatically closed.*";const i="\n                    mutation($subjectId: ID!, $body: String!) {\n                        addComment(input: {subjectId: $subjectId, body: $body}) {\n                            clientMutationId\n                        }\n                    }";await s.query(i,{subjectId:t.id,body:e},3,`OptIn Comment ${t.id}`);const a="\n                    mutation($issueId: ID!) {\n                        closeIssue(input: {issueId: $issueId}) {\n                            clientMutationId\n                        }\n                    }";await s.query(a,{issueId:t.id},3,`OptIn Close ${t.id}`),console.log(`[OptIn] Closed issue ${t.id}`)}catch(e){console.error(`[OptIn] Failed to close issue ${t.id}:`,e.message)}}});