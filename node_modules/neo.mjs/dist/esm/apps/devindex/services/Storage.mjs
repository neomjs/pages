import t from"fs/promises";import a from"../../../src/core/Base.mjs";import s from"./config.mjs";export default Neo.setupClass(class extends a{static config={className:"DevIndex.services.Storage",singleton:!0};async initAsync(){await this.ensureFiles()}async ensureFiles(){const a=[{path:s.paths.users,default:[]},{path:s.paths.tracker,default:{}},{path:s.paths.visited,default:[]},{path:s.paths.blocklist,default:[]},{path:s.paths.allowlist,default:[]},{path:s.paths.failed,default:{}},{path:s.paths.threshold,default:{tc:s.github.minTotalContributions}},{path:s.paths.optoutSync,default:{lastCheck:null}},{path:s.paths.optinSync,default:{lastCheck:null}}];for(const s of a)try{await t.access(s.path)}catch{await this.writeJson(s.path,s.default),console.log(`[Storage] Created missing file: ${s.path}`)}}async getBlocklist(){const t=await this.readJson(s.paths.blocklist,[]);return new Set(t.map(t=>t.toLowerCase()))}async addToBlocklist(t){const a=await this.readJson(s.paths.blocklist,[]),e=new Set(a.map(t=>t.toLowerCase()));let i=!1;for(const s of t)e.has(s.toLowerCase())||(a.push(s),e.add(s.toLowerCase()),i=!0);i&&(a.sort((t,a)=>t.toLowerCase().localeCompare(a.toLowerCase())),await this.writeJson(s.paths.blocklist,a))}async removeFromBlocklist(t){const a=await this.readJson(s.paths.blocklist,[]),e=new Set(t.map(t=>t.toLowerCase())),i=a.length,r=a.filter(t=>!e.has(t.toLowerCase()));r.length!==i&&await this.writeJson(s.paths.blocklist,r)}async getOptOutSync(){return this.readJson(s.paths.optoutSync,{lastCheck:null})}async saveOptOutSync(t){await this.writeJson(s.paths.optoutSync,t)}async getOptInSync(){return this.readJson(s.paths.optinSync,{lastCheck:null})}async saveOptInSync(t){await this.writeJson(s.paths.optinSync,t)}async getAllowlist(){const t=await this.readJson(s.paths.allowlist,[]);return new Set(t.map(t=>t.toLowerCase()))}async getLowestContributionThreshold(){return(await this.readJson(s.paths.threshold,{tc:s.github.minTotalContributions})).tc}async getFailed(){const t=await this.readJson(s.paths.failed,{}),a=new Map;if(Array.isArray(t)){const s=(new Date).toISOString();t.forEach(t=>a.set(t.toLowerCase(),s))}else Object.entries(t).forEach(([t,s])=>a.set(t.toLowerCase(),s));return a}async updateFailed(t,a=!0){const s=await this.getFailed();let e=!1;t.forEach(t=>{const i=t.toLowerCase();a?s.has(i)||(s.set(i,(new Date).toISOString()),e=!0):s.has(i)&&(s.delete(i),e=!0)}),e&&await this.saveFailed(s)}async saveFailed(t){const a={};Array.from(t.keys()).sort().forEach(s=>{a[s]=t.get(s)}),await this.writeJson(s.paths.failed,a)}async getVisited(){const t=await this.readJson(s.paths.visited,[]);return new Set(t)}async updateVisited(t){const a=await this.readJson(s.paths.visited,[]),e=new Set(a);let i=!1;const r=Array.isArray(t)?t:Array.from(t);for(const t of r)e.has(t)||(e.add(t),i=!0);i&&await this.writeJson(s.paths.visited,Array.from(e))}async getTracker(){const t=await this.readJson(s.paths.tracker,{});return Object.entries(t).map(([t,a])=>({login:t,lastUpdate:a}))}async updateTracker(t){const a=await this.readJson(s.paths.tracker,{}),e={};Object.entries(a).forEach(([t,a])=>e[t.toLowerCase()]={originalKey:t,val:a});let i=!1;for(const a of t){const t=a.login.toLowerCase(),s=e[t],r=s?s.val:void 0;a.delete?s&&(delete e[t],i=!0):(null==r||a.lastUpdate&&a.lastUpdate>r)&&(s?(s.val=a.lastUpdate||r||null,s.originalKey=a.login):e[t]={originalKey:a.login,val:a.lastUpdate||null},i=!0)}if(i){const t={};Object.values(e).forEach(a=>{t[a.originalKey]=a.val}),await this.writeJson(s.paths.tracker,t)}}async getUsers(){return this.readJson(s.paths.users,[])}async updateUsers(t){const a=await this.getUsers(),e=new Map(a.map(t=>[t.l,t]));let i=!1;for(const a of t)e.set(a.l,a),i=!0;if(i){let t=Array.from(e.values());t.sort((t,a)=>(a.tc||0)-(t.tc||0));const a=s.github.maxUsers,i=await this.getAllowlist(),r=a?a+i.size:null;let o=[];if(r&&t.length>r){o=t.slice(r).map(t=>t.l),t=t.slice(0,r);const a=t[t.length-1].tc||s.github.minTotalContributions;await this.writeJson(s.paths.threshold,{tc:a})}if(await this.writeJson(s.paths.users,t),o.length>0){const t=o.map(t=>({login:t,delete:!0}));await this.updateTracker(t),await this.updateFailed(o,!1)}}}async deleteUsers(t){const a=await this.getUsers(),e=new Set(t.map(t=>t.toLowerCase())),i=a.length,r=a.filter(t=>!e.has(t.l.toLowerCase()));return r.length!==i&&(await this.writeJson(s.paths.users,r),!0)}async readJson(a,s){try{const s=await t.readFile(a,"utf-8");return a.endsWith(".jsonl")?s.trim()?s.split("\n").filter(t=>t.trim()).map(t=>JSON.parse(t)):[]:JSON.parse(s)}catch(t){if("ENOENT"===t.code)return s;throw t}}async writeJson(a,e){let i;if(a.endsWith(".jsonl")){if(!Array.isArray(e))throw new Error("JSONL writer expects an Array");i=e.map(t=>JSON.stringify(t)).join("\n")}else if(a===s.paths.users&&Array.isArray(e)){i=`[\n${e.map(t=>JSON.stringify(t)).join(",\n")}\n]`}else i=JSON.stringify(e,null,2);const r=`${a}.tmp`;await t.writeFile(r,i,"utf-8"),await t.rename(r,a)}});