import t from"../../../src/core/Base.mjs";import e from"./config.mjs";import o from"./GitHub.mjs";import n from"./Heuristics.mjs";import s from"./LocationNormalizer.mjs";import a from"./Storage.mjs";export default Neo.setupClass(class extends t{static config={className:"DevIndex.services.Updater",singleton:!0};async processBatch(t,n=0){if(!t||0===t.length)return;console.log(`[Updater] Processing batch of ${t.length} users...`);let s=[],i=[],r=[],l=[],c=[],u=0,g=0,p=0;const m=e.updater.saveInterval,d=await a.getAllowlist(),h=await a.getUsers(),w=new Map(h.map(t=>[t.l.toLowerCase(),t])),f=await a.getLowestContributionThreshold(),y=Math.max(e.github.minTotalContributions,f),C=async t=>{try{const e=await this.fetchUserData(t);if(e){const o=d.has(t.toLowerCase()),n=e.tc>=y;n||o?(s.push(e),i.push({login:t,lastUpdate:e.lu}),l.push(t),u++,console.log(`[${t}] OK (${e.tc})`+(o&&!n?" [ALLOWLISTED]":""))):(i.push({login:t,delete:!0}),p++,console.log(`[${t}] SKIPPED (Low Activity: ${e.tc}) [PRUNED]`))}else i.push({login:t,lastUpdate:(new Date).toISOString()}),p++,console.log(`[${t}] SKIPPED (No Data/Bot)`)}catch(e){const n=t.toLowerCase(),a=e.message.includes("Could not resolve to a User")||e.message.includes("NOT_FOUND")||e.message.includes("GraphQL Fatal Error"),l=w.get(n);if(a&&l&&l.i)try{const e=await o.getLoginByDatabaseId(l.i);if(e&&e.toLowerCase()!==n){console.log(`[${t}] ðŸ”„ RENAME DETECTED -> ${e}`),i.push({login:t,delete:!0}),c.push(t);const o=await this.fetchUserData(e);if(o)return s.push(o),i.push({login:e,lastUpdate:o.lu}),u++,void console.log(`[${e}] Rename recovery successful.`)}}catch(e){console.warn(`[${t}] Rename check failed: ${e.message}`)}a&&!l?(console.log(`[${t}] PERMANENT FAILURE: Invalid User/Org. [PRUNED]`),i.push({login:t,delete:!0}),p++):(console.log(`[${t}] FAILED: ${e.message}`),i.push({login:t,lastUpdate:(new Date).toISOString()}),r.push(t),g++),e.message.includes("rate limit")&&(console.warn(`[Updater] ðŸš¨ Rate limit hit for ${t}. Forcing shutdown sequence.`),o.rateLimit.core.remaining=0)}};for(let e=0;e<t.length;e+=8){if(o.rateLimit.core.remaining<50){if(console.warn(`\n[Updater] âš ï¸ RATE LIMIT CRITICAL: ${o.rateLimit.core.remaining} requests remaining.`),o.rateLimit.core.reset){const t=new Date(1e3*o.rateLimit.core.reset);console.warn(`[Updater] Limit resets at: ${t.toLocaleString()}`)}console.warn("[Updater] Stopping gracefully to preserve quota.\n");break}const n=t.slice(e,e+8);await Promise.all(n.map(t=>C(t))),s.length>=m&&(await this.saveCheckpoint(s,i,r,l,c),s=[],i=[],r=[],l=[],c=[])}if((s.length>0||i.length>0||r.length>0||c.length>0)&&await this.saveCheckpoint(s,i,r,l,c),console.log("--------------------------------------------------"),console.log("[Updater] Run Complete."),console.log(`[Updater] Successfully Updated: ${u}`),console.log(`[Updater] Skipped/Pruned: ${p}`),console.log(`[Updater] Failed (Penalty Box): ${g}`),n>0){const t=u+p+g,e=Math.max(0,n-t);console.log(`[Updater] Remaining Backlog: ${e}`)}console.log("--------------------------------------------------")}async saveCheckpoint(t,e,n=[],s=[],i=[]){t.length>0&&await a.updateUsers(t),e.length>0&&await a.updateTracker(e),i.length>0&&await a.deleteUsers(i),n.length>0&&await a.updateFailed(n,!0),s.length>0&&await a.updateFailed(s,!1),console.log(`[Updater] Checkpoint: Saved ${t.length} records, Pruned ${i.length} old logins. (API Quota: ${o.rateLimit.core.remaining}/${o.rateLimit.core.limit})`)}async fetchUserData(t){const e=`\n            query { \n                rateLimit { remaining limit resetAt }\n                user(login: "${t}") { \n                    createdAt \n                    avatarUrl \n                    name \n                    location\n                    company\n                    bio\n                    followers { totalCount }\n                    isHireable\n                    hasSponsorsListing\n                    sponsorshipsAsMaintainer { totalCount }\n                    twitterUsername\n                    websiteUrl\n                    socialAccounts(first: 5) {\n                        nodes {\n                            provider\n                            url\n                        }\n                    }\n                } \n            }`,a=o.rest(`users/${t}/orgs`,t).then(t=>Array.isArray(t)?t.map(t=>({name:t.login,avatar_url:t.avatar_url,login:t.login})):[]).catch(e=>(console.warn(`[Updater] [${t}] Skipped orgs (REST Error): ${e.message}`),[])),i=o.query(e,{},3,t);let r,l;try{[r,l]=await Promise.all([i,a])}catch(t){if(t.message.includes("NOT_FOUND"))return null;throw t}if(!r?.user)return null;const{createdAt:c,avatarUrl:u,name:g,location:p,company:m,bio:d,followers:h,socialAccounts:w,isHireable:f,hasSponsorsListing:y,sponsorshipsAsMaintainer:C,twitterUsername:U,websiteUrl:$}=r.user,b=new Date(c).getFullYear(),L=(new Date).getFullYear();let v=null;const R=w?.nodes?.find(t=>"LINKEDIN"===t.provider);R?v=R.url:r.user.websiteUrl&&r.user.websiteUrl.includes("linkedin.com/in/")&&(v=r.user.websiteUrl);const I={},D=async(e,n)=>{let s=`query { \n                rateLimit { remaining limit resetAt }\n                user(login: "${t}") {`;for(let t=e;t<=n;t++)s+=` y${t}: contributionsCollection(from: "${t}-01-01T00:00:00Z", to: "${t}-12-31T23:59:59Z") { \n                    totalCommitContributions\n                    totalIssueContributions\n                    totalPullRequestContributions\n                    totalPullRequestReviewContributions\n                    totalRepositoryContributions\n                    restrictedContributionsCount\n                    commitContributionsByRepository(maxRepositories: 10) {\n                        repository { name, owner { login } }\n                        contributions { totalCount }\n                    }\n                }`;s+=" } }";const a=await o.query(s,{},3,t);a?.user&&Object.assign(I,a.user)},A=[];for(let t=b;t<=L;t+=4){const e=Math.min(t+4-1,L);A.push({start:t,end:e})}for(const e of A)try{await D(e.start,e.end)}catch(o){console.warn(`[Updater] [${t}] Batch failed (${e.start}-${e.end}). Falling back to single years...`);for(let o=e.start;o<=e.end;o++)try{await D(o,o)}catch(e){if(e.message.includes("IP allow list enabled")){console.warn(`[Updater] [${t}] Year ${o} blocked by IP allow list. Skipping year.`);continue}throw console.error(`[Updater] [${t}] Year ${o} failed even individually.`),e}}let E=0;const P=[],S=[],k=[],N=new Map;for(let t=b;t<=L;t++){const e=I[`y${t}`],o=e?.totalCommitContributions||0,n=e?.restrictedContributionsCount||0,s=o+(e?.totalIssueContributions||0)+(e?.totalPullRequestContributions||0)+(e?.totalPullRequestReviewContributions||0)+(e?.totalRepositoryContributions||0)+n;e?.commitContributionsByRepository&&e.commitContributionsByRepository.forEach(t=>{const e=t.repository.name,o=`${t.repository.owner.login}/${e}`,n=t.contributions.totalCount;N.set(o,(N.get(o)||0)+n)}),P.push(s),S.push(o),k.push(n),E+=s}const T=t=>{if(!t)return null;const e=t.match(/\/u\/(\d+)/);return e?parseInt(e[1],10):null},F={l:t,tc:E,fy:b,lu:(new Date).toISOString(),y:P,cy:S,py:k};if(N.size>0){let t=null,e=-1;for(const[o,n]of N)n>e&&(e=n,t=o);t&&(F.tr=[t,e])}g&&g!==t&&(F.n=g);const q=T(u);q&&(F.i=q),p&&(F.lc=p);const O=s.normalize(p);if(O&&(F.cc=O),m&&(F.c=m),d&&(F.b=d),h?.totalCount>0&&(F.fl=h.totalCount),v){const t=v.match(/linkedin\.com\/in\/([^/]+)/);t&&(F.li=t[1])}f&&(F.h=1),(y||C?.totalCount>0)&&(F.s=C?.totalCount||0),U&&(F.t=U),$&&(F.w=$),l.length>0&&(F.o=l.slice(0,5).map(t=>[t.login,T(t.avatar_url)]));const B=n.analyze(F);return B&&(F.hm=B),F}});