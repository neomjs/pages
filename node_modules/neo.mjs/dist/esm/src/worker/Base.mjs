import e from"../core/Base.mjs";import*as o from"../core/_export.mjs";import r from"../core/Observable.mjs";import t from"../manager/ClassHierarchy.mjs";import s from"./Message.mjs";import n from"./mixin/RemoteMethodAccess.mjs";export default Neo.setupClass(class extends e{static config={className:"Neo.worker.Base",mixins:[r,n]};channelPorts=null;isConnected=!1;isSharedWorker=!1;ports=null;workerId=null;construct(e){super.construct(e);let o=this,r=globalThis;Object.assign(o,{channelPorts:{},isSharedWorker:"[object SharedWorkerGlobalScope]"===r.toString(),ports:[],promises:{},remotesToRegister:[]}),o.isSharedWorker?r.onconnect=o.onConnected.bind(o):r.onmessage=o.onMessage.bind(o),Neo.currentWorker=o,Neo.setGlobalConfig=o.setGlobalConfig.bind(o),Neo.workerId=o.workerId}afterConnect(){}hasWorker(e){switch(e){case"app":case"data":case"main":return!0;case"canvas":return Neo.config.useCanvasWorker;case"service":return Neo.config.useServiceWorker;case"task":return Neo.config.useTaskWorker;case"vdom":return Neo.config.useVdomWorker}return!1}getPort(e){let o,r=null;return this.ports.forEach(t=>{o=!0,Object.entries(e).forEach(([e,r])=>{r!==t[e]&&(o=!1)}),o&&(r=t)}),r}async onConnect(e){await this.timeout(10);let{appName:o,windowId:r}=e;this.fire("connect",{appName:o,windowId:r})}onConnected(e){let o=this,r=Neo.getId("port");o.isConnected=!0,o.ports.push({appName:null,id:r,port:e.ports[0],windowId:null}),o.ports[o.ports.length-1].port.onmessage=o.onMessage.bind(o),o.fire("connected"),o.sendMessage(r,{action:"workerConstructed",port:r}),o.remotesToRegister.forEach(e=>{o.sendMessage(r,{action:"registerRemote",...e})}),o.afterConnect()}onConstructed(){super.onConstructed();let e=this;e.isSharedWorker||(e.sendMessage(Neo.config.windowId,{action:"workerConstructed"}),e.afterConnect())}onDisconnect(e){let{appName:o,windowId:r}=e;this.fire("disconnect",{appName:o,windowId:r})}onMessage(e){let o,r=this,{data:t}=e,{action:s,replyId:n}=t;if(!s)throw new Error("Message action is missing: "+t.id);"reply"!==s?r["on"+Neo.capitalize(s)](t):(o="reply"===s&&r.promises[n])&&(t.reject?o.reject(t.data):o.resolve(t.data),delete r.promises[n])}onPing(e){this.resolve(e,{originMsg:e})}onRegisterApp(e){let o,r=this,{appName:t}=e;for(o of r.ports)if(!o.appName){o.appName=t,r.onConnect({appName:t,windowId:o.windowId});break}}onRegisterNeoConfig({data:e}){Neo.ns("Neo.config",!0);for(const o of this.ports)if(!o.windowId){o.windowId=e.windowId;break}Neo.merge(Neo.config,e)}onSetNeoConfig({config:e}){Neo.merge(Neo.config,e),this.fire("neoConfigChange",e)}promiseMessage(e,o,r){let t=this;return new Promise(function(s,n){let i=t.sendMessage(e,o,r),a=i?.id;a?t.promises[a]={reject:n,resolve:s}:n()})}sendMessage(e,o,r){"main"===e&&this.isSharedWorker&&"registerRemote"!==o.action&&console.warn('sendMessage destination "main" is deprecated. Use a windowId instead.',o),o.destination=e;let t,n,i,a=this;return a.channelPorts[e]?n=a.channelPorts[e]:a.isSharedWorker?(i=a.getPort({windowId:e})||a.getPort({id:e}),i?(n=i.port,o.port=i.id):o.port?n=a.getPort({id:o.port}).port:o.windowId?(i=a.getPort({windowId:o.windowId}),n=i?.port,o.port=i?.id):o.appName?(i=a.getPort({appName:o.appName}),n=i?.port,o.port=i?.id):n=a.ports[0].port):n=globalThis,n&&(t=new s(o),n.postMessage(t,r)),t}setGlobalConfig(e){const o=this,{Manager:r}=Neo.worker;o.onSetNeoConfig({config:e}),o.isSharedWorker?o.ports.forEach((t,s)=>{r.setNeoConfig({broadcast:s<1,config:e,excludeOrigin:o.workerId,windowId:t.windowId})}):r.setNeoConfig({broadcast:!0,config:e,excludeOrigin:o.workerId})}});