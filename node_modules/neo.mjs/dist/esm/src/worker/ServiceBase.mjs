import e from"../core/Base.mjs";import s from"./Message.mjs";import t from"./mixin/RemoteMethodAccess.mjs";export default Neo.setupClass(class extends e{static config={className:"Neo.worker.ServiceBase",cacheName_:"neo-runtime",mixins:[t],remote:{app:["clearCache","clearCaches","preloadAssets","removeAssets"]}};cachePaths=["raw.githubusercontent.com/","/dist/esm/","/dist/production/","/fontawesome","/resources/"];channelPorts=null;lastClient=null;promises=[];remotes=[];workerId=null;construct(e){super.construct(e);let s=this,t=e=>s[e].bind(s);s.channelPorts=[],Object.assign(globalThis,{onactivate:t("onActivate"),onfetch:t("onFetch"),oninstall:t("onInstall"),onmessage:t("onMessage")}),Neo.currentWorker=s,Neo.workerId=s.workerId}beforeGetCacheName(e){return e+"-"+this.version}async clearCache(e=this.cacheName){return await caches.delete(e),{success:!0}}async clearCaches(){let e=await caches.keys();return await Promise.all(e.map((e=>caches.delete(e)))),{success:!0}}createMessageChannel(e){let s=this,t=new MessageChannel,{port1:a,port2:o}=t;a.onmessage=s.onMessage.bind(s),s.sendMessage("app",{action:"registerPort",transfer:o},[o]),s.channelPorts.push({clientId:e.id,destination:"app",port:a})}getPort(e,s=this.lastClient?.id){for(let t of this.channelPorts)if(s===t.clientId&&e===t.destination)return t.port;return null}initRemote(){let e=this,s=e.lastClient?.id;s&&!e.remotes.includes(s)&&(e.remotes.push(s),super.initRemote())}async onActivate(e){console.log("onActivate",e);let s,t=this,a=await caches.keys();for(s of a)s.startsWith(t._cacheName)&&s!==t.cacheName&&t.clearCache(s)}async onConnect(e){console.log("onConnect",e),this.createMessageChannel(e),this.initRemote()}onFetch(e){let s,t=!1,{request:a}=e;for(s of this.cachePaths)if(a.url.includes(s)){t=!0;break}t&&"GET"===a.method&&e.respondWith(caches.match(a).then((e=>e||caches.open(this.cacheName).then((e=>fetch(a).then((s=>e.put(a,s.clone()).then((()=>s)))))))))}onInstall(e){console.log("onInstall",e)}onMessage(e){let s,t=this,{data:a}=e,{action:o,replyId:n}=a;if(e.source&&(t.lastClient=e.source),!o)throw new Error("Message action is missing: "+a.id);"reply"!==o?t["on"+Neo.capitalize(o)](a,e):(s="reply"===o&&t.promises[n])&&(s[a.reject?"reject":"resolve"](a.data),delete t.promises[n])}onPing(e,s){this.resolve(e,{originMsg:e})}async onRegisterNeoConfig(e,s){this.onConnect(s.source)}async onSkipWaiting(e,s){await globalThis.skipWaiting()}onUnregisterPort(e,s){for(let[e,t]of this.channelPorts.entries())if(t.clientId===s.source.id){this.channelPorts.splice(e,1);break}}async preloadAssets(e){let s,t,a,o=e.cacheName||this.cacheName,n=await caches.open(o),{files:r}=e,c=[];for(a of(Array.isArray(r)||(r=[r]),r))t=!1,e.forceReload||(s=await n.match(a),t=!!s),!t&&c.push(a);return c.length>0&&await n.addAll(c),{success:!0}}promiseMessage(e,s,t){let a=this;return new Promise((function(o,n){let r=a.sendMessage(e,s,t).id;a.promises[r]={reject:n,resolve:o}}))}async removeAssets(e){Neo.isObject(e)||(e={assets:e});let{assets:s,options:t={}}=e,a=e.cacheName||this.cacheName,o=await caches.open(a),n=[];return Array.isArray(s)||(s=[s]),s.forEach((e=>{n.push(o.delete(e,t))})),await Promise.all(n),{success:!0}}sendMessage(e,t,a){t.destination=e;let o=new s(t);return(this.getPort(e)||this.lastClient).postMessage(o,a),o}});