import e from"../core/Base.mjs";import o from"../main/DomAccess.mjs";import r from"../main/DomEvents.mjs";import s from"./Message.mjs";import t from"../core/Observable.mjs";import a from"./mixin/RemoteMethodAccess.mjs";const n=Neo.config,i="development"===n.environment||"dist/esm"===n.environment;navigator.serviceWorker?.addEventListener("controllerchange",function(){window.location.reload()},{once:!0});class d extends e{static config={className:"Neo.worker.Manager",activeWorkers:0,appNames:[],applicationLoaded:!1,constructedThreads:0,mixins:[t,a],remote:{app:["setNeoConfig","startWorker"],canvas:["setNeoConfig"],data:["setNeoConfig"],task:["setNeoConfig"],vdom:["setNeoConfig"]},sharedWorkersEnabled:!1,singleton:!0,stopCommunication:!1,webWorkersEnabled:!1,windowId:window.__NEO_SSR__?.windowId||crypto.randomUUID(),workers:{app:{fileName:i?"App.mjs":"appworker.js"},canvas:{fileName:i?"Canvas.mjs":"canvasworker.js"},data:{fileName:i?"Data.mjs":"dataworker.js"},task:{fileName:i?"Task.mjs":"taskworker.js"},vdom:{fileName:i?"VDom.mjs":"vdomworker.js"}}};serviceWorker=null;construct(e){let s=this;s.promises={},super.construct(e),s.detectFeatures(),!Neo.insideWorker&&s.createWorkers(),navigator.serviceWorker&&(navigator.serviceWorker.onmessage=s.onWorkerMessage.bind(s),s.checkServiceWorkerVersion()),Neo.setGlobalConfig=s.setGlobalConfig.bind(s),Neo.workerId="main",s.on({"message:addDomListener":{fn:r.addDomListener,scope:r},"message:getOffscreenCanvas":{fn:o.onGetOffscreenCanvas,scope:o},"message:readDom":{fn:o.onReadDom,scope:o},"message:registerRemote":{fn:s.onRegisterRemote,scope:s},"message:workerConstructed":{fn:s.onWorkerConstructed,scope:s}})}broadcast(e,o){let r=this;Object.keys(r.workers).forEach(s=>{s!==o&&r.getWorker(s)&&r.sendMessage(s,e)})}async checkServiceWorkerVersion(){if(navigator.serviceWorker?.controller){let e=await this.promiseMessage("service",{action:"getVersion"});if(e?.version&&e.version!==Neo.config.version){const o="neoVersionReload",r=parseInt(sessionStorage.getItem(o)||"0"),s=Date.now();if(s-r<5e3)return void console.error("Reload loop detected. Aborting version enforcement.");sessionStorage.setItem(o,String(s)),console.error(`Version Mismatch! Client: ${Neo.config.version}, SW: ${e.version}. Reloading.`),location.reload(!0)}}}createWorker(e){let o=this,{fileName:r}=e,s=(e.basePath||Neo.config.workerBasePath)+r,t=`neomjs-${r.substring(0,r.indexOf(".")).toLowerCase()}-worker`,a=o.sharedWorkersEnabled&&n.useSharedWorkers,i=new(a?SharedWorker:Worker)(s,{name:t,type:"module"});return(a?i.port:i).onmessage=o.onWorkerMessage.bind(o),(a?i.port:i).onerror=o.onWorkerError.bind(o),o.activeWorkers++,i}createWorkers(){let e,o,s=this,t=Neo.clone(n,!0),{hash:a,href:i,search:d}=location,{windowId:c}=s,l=window.__NEO_SSR__;for([e,o]of(delete t.cesiumJsToken,a&&(t.hash={hash:r.parseHash(a.substring(1)),hashString:a.substring(1),windowId:c}),t.url={href:i,search:d},Object.entries(s.workers))){if("canvas"===e&&!t.useCanvasWorker||"task"===e&&!t.useTaskWorker||"vdom"===e&&!t.useVdomWorker)continue;try{o.worker=s.createWorker(o)}catch(e){document.body.innerHTML=e,s.stopCommunication=!0;break}let r={...t,windowId:c};l&&"app"===e&&(Object.assign(r,{cssMap:l.cssMap,useSSR:!0,vnode:l.vnode}),l.hash&&(r.hash=l.hash)),s.sendMessage(e,{action:"registerNeoConfig",data:r})}}detectFeatures(){let e=this;if(n.devicePixelRatio=window.devicePixelRatio||1,n.hasMouseEvents=matchMedia("(pointer:fine)").matches,n.hasTouchEvents="ontouchstart"in window||navigator.maxTouchPoints>0,n.prefersDarkTheme=matchMedia("(prefers-color-scheme: dark)").matches,document.body.classList.add(n.hasMouseEvents?"neo-mouse":"neo-no-mouse"),!window.Worker)throw new Error("Your browser does not support Web Workers");e.webWorkersEnabled=!0,window.SharedWorker&&(e.sharedWorkersEnabled=!0)}getWorker(e){if("service"===e)return navigator.serviceWorker?.controller||this.serviceWorker;const o=this.workers[e];return o?e instanceof Worker?e:o.worker:null}hasWorker(e){return!!this.getWorker(e)}handleDomUpdate(e,o,r,s=!1){let t=this;if(o?.length>0)return t.promiseForwardMessage(e).then(e=>{t.sendMessage(r,s?e:{action:"reply",replyId:e.id,success:!0})}),void t.fire("updateVdom",s?e:{data:e,replyId:e.id});t.sendMessage(r,s?e:{action:"reply",replyId:e.id,success:!0})}loadApplication(){this.sendMessage("app",{action:"loadApplication"})}onWorkerConstructed(e){let o=this;o.constructedThreads++,o.applicationLoaded||o.constructedThreads!==o.activeWorkers+1||(o.applicationLoaded=!0,n.appPath&&o.timeout(n.loadApplicationDelay).then(()=>{o.loadApplication()}))}onWorkerError(e){!i&&console.log("Worker Error:",e)}onWorkerMessage(e){let o,r=this,{data:s}=e,t=null;const{action:a,destination:n,replyId:i}=s;if(r.fire("message:"+a,s),"updateVdom"===a)return s.replyId=s.id,void r.handleDomUpdate(s,s.deltas,s.origin,!1);if("reply"===a)if(o=r.promises[i],o)"main"===n&&(s=s.data),s&&(o[s.reject?"reject":"resolve"](s),delete r.promises[i]);else{let e=s.data;if(e)if(e.autoMount||e.updateVdom){let o=e.deltas;e.autoMount&&(o=[{action:"insertNode",index:e.parentIndex,outerHTML:e.outerHTML,parentId:e.parentId,vnode:e.vnode}],e.deltas=o),r.handleDomUpdate(s,o,n,!0)}else r.sendMessage(n,s)}if("main"!==n&&n!==r.windowId&&"reply"!==a)s.transfer&&(t=[s.transfer]),r.promiseMessage(n,s,t).then(e=>{r.sendMessage(e.destination,e)}).catch(e=>{r.sendMessage(s.origin,{action:"reply",reject:!0,replyId:s.id,error:e.message})});else if("main"!==n&&n!==r.windowId||"registerAppName"!==a)"main"!==n&&n!==r.windowId||"remoteMethod"!==a||r.onRemoteMethod(s);else{let{appName:e}=s;r.appNames.push(e),r.broadcast({action:"registerApp",appName:e})}}promiseForwardMessage(e){return new Promise((o,r)=>{this.promises[e.replyId]={data:e,reject:r,resolve:o}})}promiseMessage(e,o,r){let s=this;return new Promise((t,a)=>{let n,i=s.sendMessage(e,o,r);i?(n=i.id,s.promises[n]={reject:a,resolve:t}):a(new Error(s.stopCommunication?"Communication is stopped.":`Target worker '${e}' does not exist.`))})}resolveDomOperationPromise(e){if(e){let{promises:o}=this,r=o[e];r&&(r.resolve(r.data),delete o[e])}}sendMessage(e,o,r){let t,a,n=this;return!n.stopCommunication&&(o.channelPort?(a=o.channelPort,delete o.channelPort):a=n.getWorker(e),a)?(o.destination=e,o.windowId??=n.windowId,t=new s(o),(a.port?a.port:a).postMessage(t,r),t):null}setGlobalConfig(e){Neo.worker.App.setGlobalConfig(e)}setNeoConfig({broadcast:e,config:o,excludeOrigin:r}){Neo.merge(Neo.config,o),this.fire("neoConfigChange",o),e&&this.broadcast({action:"setNeoConfig",config:o},r)}startWorker({name:e}){let o=this;if(o.hasWorker(e))return!0;let s=o.workers[e];if(!s)return console.error(`Worker with name '${e}' is not defined.`),!1;let t="use"+Neo.capitalize(e)+"Worker";!1===n[t]&&(n[t]=!0),s.worker=o.createWorker(s);let a=Neo.clone(n,!0),{hash:i,href:d,search:c}=location,{windowId:l}=o;delete a.cesiumJsToken,a.url={href:d,search:c},i&&(a.hash={hash:r.parseHash(i.substring(1)),hashString:i.substring(1),windowId:l});let m={...a,windowId:l};return o.sendMessage(e,{action:"registerNeoConfig",data:m}),!0}}export default Neo.setupClass(d);