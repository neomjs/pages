import e from"../core/Base.mjs";import o from"../main/DomAccess.mjs";import r from"../main/DomEvents.mjs";import s from"./Message.mjs";import t from"../core/Observable.mjs";import n from"./mixin/RemoteMethodAccess.mjs";const a=Neo.config,i="development"===a.environment||"dist/esm"===a.environment;navigator.serviceWorker?.addEventListener("controllerchange",function(){window.location.reload()},{once:!0});class d extends e{static config={className:"Neo.worker.Manager",activeWorkers:0,appNames:[],constructedThreads:0,mixins:[t,n],remote:{app:["setNeoConfig"],canvas:["setNeoConfig"],data:["setNeoConfig"],task:["setNeoConfig"],vdom:["setNeoConfig"]},sharedWorkersEnabled:!1,singleton:!0,stopCommunication:!1,webWorkersEnabled:!1,windowId:window.__NEO_SSR__?.windowId||crypto.randomUUID(),workers:{app:{fileName:i?"App.mjs":"appworker.js"},canvas:{fileName:i?"Canvas.mjs":"canvasworker.js"},data:{fileName:i?"Data.mjs":"dataworker.js"},task:{fileName:i?"Task.mjs":"taskworker.js"},vdom:{fileName:i?"VDom.mjs":"vdomworker.js"}}};serviceWorker=null;construct(e){super.construct(e);let s=this;s.detectFeatures(),!Neo.insideWorker&&s.createWorkers(),navigator.serviceWorker&&(navigator.serviceWorker.onmessage=s.onWorkerMessage.bind(s),s.checkServiceWorkerVersion()),Neo.setGlobalConfig=s.setGlobalConfig.bind(s),Neo.workerId="main",s.promises={},s.on({"message:addDomListener":{fn:r.addDomListener,scope:r},"message:getOffscreenCanvas":{fn:o.onGetOffscreenCanvas,scope:o},"message:readDom":{fn:o.onReadDom,scope:o},"message:registerRemote":{fn:s.onRegisterRemote,scope:s},"message:workerConstructed":{fn:s.onWorkerConstructed,scope:s}})}broadcast(e,o){let r=this;Object.keys(r.workers).forEach(s=>{s!==o&&r.getWorker(s)&&r.sendMessage(s,e)})}async checkServiceWorkerVersion(){if(navigator.serviceWorker?.controller){let e=await this.promiseMessage("service",{action:"getVersion"});if(e?.version&&e.version!==Neo.config.version){const o="neoVersionReload",r=parseInt(sessionStorage.getItem(o)||"0"),s=Date.now();if(s-r<5e3)return void console.error("Reload loop detected. Aborting version enforcement.");sessionStorage.setItem(o,String(s)),console.error(`Version Mismatch! Client: ${Neo.config.version}, SW: ${e.version}. Reloading.`),location.reload(!0)}}}createWorker(e){let o=this,{fileName:r}=e,s=(e.basePath||Neo.config.workerBasePath)+r,t=`neomjs-${r.substring(0,r.indexOf(".")).toLowerCase()}-worker`,n=o.sharedWorkersEnabled&&a.useSharedWorkers,d=n?SharedWorker:Worker,c=new d(s,i?{name:t,type:"module"}:{name:t});return(n?c.port:c).onmessage=o.onWorkerMessage.bind(o),(n?c.port:c).onerror=o.onWorkerError.bind(o),o.activeWorkers++,c}createWorkers(){let e,o,s=this,t=Neo.clone(a,!0),{hash:n,href:i,search:d}=location,{windowId:c}=s,m=window.__NEO_SSR__;for([e,o]of(delete t.cesiumJsToken,n&&(t.hash={hash:r.parseHash(n.substring(1)),hashString:n.substring(1),windowId:c}),t.url={href:i,search:d},Object.entries(s.workers))){if("canvas"===e&&!t.useCanvasWorker||"task"===e&&!t.useTaskWorker||"vdom"===e&&!t.useVdomWorker)continue;try{o.worker=s.createWorker(o)}catch(e){document.body.innerHTML=e,s.stopCommunication=!0;break}let r={...t,windowId:c};m&&"app"===e&&(Object.assign(r,{cssMap:m.cssMap,useSSR:!0,vnode:m.vnode}),m.hash&&(r.hash=m.hash)),s.sendMessage(e,{action:"registerNeoConfig",data:r})}}detectFeatures(){let e=this;if(a.hasMouseEvents=matchMedia("(pointer:fine)").matches,a.hasTouchEvents="ontouchstart"in window||navigator.maxTouchPoints>0,a.prefersDarkTheme=matchMedia("(prefers-color-scheme: dark)").matches,document.body.classList.add(a.hasMouseEvents?"neo-mouse":"neo-no-mouse"),!window.Worker)throw new Error("Your browser does not support Web Workers");e.webWorkersEnabled=!0,window.SharedWorker&&(e.sharedWorkersEnabled=!0)}getWorker(e){return"service"===e?navigator.serviceWorker?.controller||this.serviceWorker:e instanceof Worker?e:this.workers[e].worker}hasWorker(e){return!!this.getWorker(e)}handleDomUpdate(e,o,r,s=!1){let t=this;if(o?.length>0)return t.promiseForwardMessage(e).then(e=>{t.sendMessage(r,s?e:{action:"reply",replyId:e.id,success:!0})}),void t.fire("updateVdom",s?e:{data:e,replyId:e.id});t.sendMessage(r,s?e:{action:"reply",replyId:e.id,success:!0})}loadApplication(){this.sendMessage("app",{action:"loadApplication"})}onWorkerConstructed(e){let o=this;o.constructedThreads++,o.constructedThreads===o.activeWorkers+1&&a.appPath&&o.timeout(a.loadApplicationDelay).then(()=>{o.loadApplication()})}onWorkerError(e){!i&&console.log("Worker Error:",e)}onWorkerMessage(e){let o,r=this,{data:s}=e,t=null;const{action:n,destination:a,replyId:i}=s;if(r.fire("message:"+n,s),"updateVdom"===n)return s.replyId=s.id,void r.handleDomUpdate(s,s.deltas,s.origin,!1);if("reply"===n)if(o=r.promises[i],o)"main"===a&&(s=s.data),s&&(o[s.reject?"reject":"resolve"](s),delete r.promises[i]);else{let e=s.data;if(e)if(e.autoMount||e.updateVdom){let o=e.deltas;e.autoMount&&(o=[{action:"insertNode",index:e.parentIndex,outerHTML:e.outerHTML,parentId:e.parentId,vnode:e.vnode}],e.deltas=o),r.handleDomUpdate(s,o,a,!0)}else r.sendMessage(a,s)}if("main"!==a&&a!==r.windowId&&"reply"!==n)s.transfer&&(t=[s.transfer]),r.promiseMessage(a,s,t).then(e=>{r.sendMessage(e.destination,e)}).catch(e=>{r.sendMessage(s.origin,{action:"reply",reject:!0,replyId:s.id,error:e.message})});else if("main"!==a&&a!==r.windowId||"registerAppName"!==n)"main"!==a&&a!==r.windowId||"remoteMethod"!==n||r.onRemoteMethod(s);else{let{appName:e}=s;r.appNames.push(e),r.broadcast({action:"registerApp",appName:e})}}promiseForwardMessage(e){return new Promise((o,r)=>{this.promises[e.replyId]={data:e,reject:r,resolve:o}})}promiseMessage(e,o,r){let s=this;return new Promise((t,n)=>{let a,i=s.sendMessage(e,o,r);i?(a=i.id,s.promises[a]={reject:n,resolve:t}):n(new Error(s.stopCommunication?"Communication is stopped.":`Target worker '${e}' does not exist.`))})}resolveDomOperationPromise(e){if(e){let{promises:o}=this,r=o[e];r&&(r.resolve(r.data),delete o[e])}}sendMessage(e,o,r){let t,n,a=this;return!a.stopCommunication&&(o.channelPort?(n=o.channelPort,delete o.channelPort):n=a.getWorker(e),n)?(o.destination=e,o.windowId??=a.windowId,t=new s(o),(n.port?n.port:n).postMessage(t,r),t):null}setGlobalConfig(e){Neo.worker.App.setGlobalConfig(e)}setNeoConfig({broadcast:e,config:o,excludeOrigin:r}){Neo.merge(Neo.config,o),this.fire("neoConfigChange",o),e&&this.broadcast({action:"setNeoConfig",config:o},r)}}export default Neo.setupClass(d);