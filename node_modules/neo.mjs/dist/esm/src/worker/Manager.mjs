import e from"../core/Base.mjs";import r from"../main/DomAccess.mjs";import s from"../main/DomEvents.mjs";import o from"./Message.mjs";import a from"../core/Observable.mjs";import t from"./mixin/RemoteMethodAccess.mjs";const n=Neo.config,i="development"===n.environment||"dist/esm"===n.environment;navigator.serviceWorker?.addEventListener("controllerchange",function(){window.location.reload()},{once:!0});class d extends e{static config={className:"Neo.worker.Manager",singleton:!0,activeWorkers:0,appNames:[],constructedThreads:0,mixins:[a,t],sharedWorkersEnabled:!1,stopCommunication:!1,webWorkersEnabled:!1,windowId:(new Date).getTime(),workers:{app:{fileName:i?"App.mjs":"appworker.js"},canvas:{fileName:i?"Canvas.mjs":"canvasworker.js"},data:{fileName:i?"Data.mjs":"dataworker.js"},task:{fileName:i?"Task.mjs":"taskworker.js"},vdom:{fileName:i?"VDom.mjs":"vdomworker.js"}}};serviceWorker=null;construct(e){super.construct(e);let o=this;o.detectFeatures(),!Neo.insideWorker&&o.createWorkers(),Neo.workerId="main",o.promises={},o.on({"message:addDomListener":{fn:s.addDomListener,scope:s},"message:getOffscreenCanvas":{fn:r.onGetOffscreenCanvas,scope:r},"message:readDom":{fn:r.onReadDom,scope:r},"message:registerRemote":{fn:o.onRegisterRemote,scope:o},"message:workerConstructed":{fn:o.onWorkerConstructed,scope:o}})}broadcast(e){Object.keys(this.workers).forEach(r=>{"canvas"===r&&!n.useCanvasWorker||"task"===r&&!n.useTaskWorker||"vdom"===r&&!n.useVdomWorker||this.sendMessage(r,e)})}createWorker(e){let r=this,{fileName:s}=e,o=(e.basePath||Neo.config.workerBasePath)+s,a=`neomjs-${s.substring(0,s.indexOf(".")).toLowerCase()}-worker`,t=r.sharedWorkersEnabled&&n.useSharedWorkers,d=t?SharedWorker:Worker,m=new d(o,i?{name:a,type:"module"}:{name:a});return(t?m.port:m).onmessage=r.onWorkerMessage.bind(r),(t?m.port:m).onerror=r.onWorkerError.bind(r),r.activeWorkers++,m}createWorkers(){let e,r,o=this,a=Neo.clone(n,!0),{hash:t,href:i,search:d}=location,{windowId:m}=o;for([e,r]of(delete a.cesiumJsToken,t&&(a.hash={hash:s.parseHash(t.substring(1)),hashString:t.substring(1),windowId:m}),a.url={href:i,search:d},Object.entries(o.workers)))if(!("canvas"===e&&!a.useCanvasWorker||"task"===e&&!a.useTaskWorker||"vdom"===e&&!a.useVdomWorker)){try{r.worker=o.createWorker(r)}catch(e){document.body.innerHTML=e,o.stopCommunication=!0;break}o.sendMessage(e,{action:"registerNeoConfig",data:{...a,windowId:m}})}}detectFeatures(){let e=this;if(n.hasMouseEvents=matchMedia("(pointer:fine)").matches,n.hasTouchEvents="ontouchstart"in window||navigator.maxTouchPoints>0,document.body.classList.add(n.hasMouseEvents?"neo-mouse":"neo-no-mouse"),!window.Worker)throw new Error("Your browser does not support Web Workers");e.webWorkersEnabled=!0,window.SharedWorker&&(e.sharedWorkersEnabled=!0)}getWorker(e){return"service"===e?navigator.serviceWorker?.controller||this.serviceWorker:e instanceof Worker?e:this.workers[e].worker}loadApplication(e){this.sendMessage("app",{action:"loadApplication",path:e,resourcesPath:n.resourcesPath})}onWorkerConstructed(e){let r=this;r.constructedThreads++,r.constructedThreads===r.activeWorkers&&n.appPath&&r.timeout(n.loadApplicationDelay).then(()=>{r.loadApplication(n.appPath)})}onWorkerError(e){!i&&console.log("Worker Error:",e)}onWorkerMessage(e){let r,s=this,{data:o}=e,a=null;const{action:t,destination:n,replyId:i}=o;if(s.fire("message:"+t,o),"reply"===t&&(r=s.promises[i],r?("main"===n&&(o=o.data),r[o.reject?"reject":"resolve"](o),delete s.promises[i]):o.data&&(o.data.autoMount&&s.fire("automount",o),o.data.updateVdom&&s.fire("updateVdom",o),s.promiseForwardMessage(o).then(e=>{s.sendMessage(e.destination,e)}))),"main"!==n&&"reply"!==t)o.transfer&&(a=[o.transfer]),s.promiseMessage(n,o,a).then(e=>{s.sendMessage(e.destination,e)}).catch(e=>{s.sendMessage(o.origin,{action:"reply",reject:!0,replyId:o.id,error:e.message})});else if("main"===n&&"registerAppName"===t){let{appName:e}=o;s.appNames.push(e),s.broadcast({action:"registerApp",appName:e})}else"main"===n&&"remoteMethod"===t&&s.onRemoteMethod(o)}promiseForwardMessage(e){return new Promise((r,s)=>{this.promises[e.replyId]={data:e,reject:s,resolve:r}})}promiseMessage(e,r,s){let o=this;return new Promise((a,t)=>{let n=o.sendMessage(e,r,s).id;o.promises[n]={reject:t,resolve:a}})}resolveDomOperationPromise(e){if(e){let{promises:r}=this,s=r[e];s&&(s.resolve(s.data),delete r[e])}}sendMessage(e,r,s){let a,t,n=this;if(!n.stopCommunication){if(r.channelPort?(t=r.channelPort,delete r.channelPort):t=n.getWorker(e),!t)throw new Error("Called sendMessage for a worker that does not exist: "+e);return r.destination=e,a=new o(r),(t.port?t.port:t).postMessage(a,s),a}}}export default Neo.setupClass(d);