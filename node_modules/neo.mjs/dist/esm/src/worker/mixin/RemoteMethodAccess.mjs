import e from"../../core/Base.mjs";export default Neo.setupClass(class extends e{static config={className:"Neo.worker.mixin.RemoteMethodAccess",mixin:!0};assignPort(e,t){if(e){const{appName:o,port:r,windowId:a}=e;Object.assign(t,{appName:o,port:r,windowId:a})}}generateRemote(e,t){let o=this,{origin:r}=e;return function(a,s){let i={action:"remoteMethod",data:a,destination:r,remoteClassName:e.className,remoteMethod:t};return o.isSharedWorker&&o.assignPort(a,i),o.promiseMessage(r,i,s)}}onRegisterRemote(e){if(e.destination===Neo.workerId){let t=this,{className:o,methods:r}=e,a=Neo.ns(o,!0);r.forEach((r=>{if("main"!==e.origin&&a[r])throw new Error("Duplicate remote method definition "+o+"."+r);a[r]??=t.generateRemote(e,r)}))}}onRemoteMethod(e){let t,o,r=this,a=Neo.ns(e.remoteClassName);if(!a)throw new Error('Invalid remote namespace "'+e.remoteClassName+'"');if(o=a[e.remoteMethod],!o)throw new Error('Invalid remote method name "'+e.remoteMethod+'"');t=Array.isArray(e.data)?o.call(a,...e.data):o.call(a,e.data),t instanceof Promise?t.catch((t=>{r.reject(e,t)})).then((t=>{r.resolve(e,t)})):r.resolve(e,t)}reject(e,t){let o=this,r={action:"reply",data:t,reject:!0,replyId:e.id};o.isSharedWorker&&o.assignPort(e,r),o.sendMessage(e.origin,r)}resolve(e,t){let o=this,r={action:"reply",data:t,replyId:e.id};o.isSharedWorker&&o.assignPort(e,r),o.sendMessage(e.origin,r)}});