import e from"../../core/Base.mjs";export default Neo.setupClass(class extends e{static config={className:"Neo.worker.mixin.RemoteMethodAccess"};assignPort(e,o){if(e){const{appName:t,port:r,windowId:i}=e;Object.assign(o,{appName:t,port:r,windowId:i})}}generateRemote(e,o){let t=this,{origin:r}=e;return function(i,s){let a={action:"remoteMethod",data:i,destination:r,remoteClassName:e.className,remoteMethod:o};return"main"===r&&i?.windowId&&(a.destination=i.windowId),t.isSharedWorker&&t.assignPort(i,a),t.promiseMessage(a.destination,a,s)}}onRegisterRemote(e){if(e.destination===Neo.workerId){let o=this,{className:t,methods:r}=e,i=Neo.ns(t,!0);r.forEach(r=>{if("main"!==e.origin&&i[r])throw new Error("Duplicate remote method definition "+t+"."+r);i[r]??=o.generateRemote(e,r)}),e.id&&o.resolve(e,!0)}}onRemoteMethod(e){let o,t,r=this,i=Neo.ns(e.remoteClassName);if(!i)throw new Error('Invalid remote namespace "'+e.remoteClassName+'"');if(t=i[e.remoteMethod],!t)throw new Error('Invalid remote method name "'+e.remoteMethod+'" in namespace "'+e.remoteClassName+'"');o=!i.isReady&&i.interceptRemotes?.includes(e.remoteMethod)?i.onInterceptRemotes(e):Array.isArray(e.data)?t.call(i,...e.data):t.call(i,e.data),Neo.isPromise(o)?o.catch(o=>{console.error(o),r.reject(e,o)}).then(o=>{r.resolve(e,o)}):r.resolve(e,o)}reject(e,o){let t=this,r={action:"reply",data:o,reject:!0,replyId:e.id};t.isSharedWorker&&(t.assignPort(e,r),"main"===e.origin&&r.windowId&&(e.origin=r.windowId)),t.sendMessage(e.origin,r)}resolve(e,o){let t,r=this,i=null;Neo.isObject(o)&&Array.isArray(o.transfer)&&(i=o.transfer,o=o.result||o),t={action:"reply",data:o,replyId:e.id},r.isSharedWorker&&(r.assignPort(e,t),"main"===e.origin&&t.windowId&&(e.origin=t.windowId)),r.sendMessage(e.origin,t,i)}});