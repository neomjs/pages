import e from"../../core/Base.mjs";export default Neo.setupClass(class extends e{static config={className:"Neo.worker.mixin.RemoteMethodAccess"};assignPort(e,t){if(e){const{appName:o,port:r,windowId:s}=e;Object.assign(t,{appName:o,port:r,windowId:s})}}generateRemote(e,t){let o=this,{origin:r}=e;return function(s,a){let i={action:"remoteMethod",data:s,destination:r,remoteClassName:e.className,remoteMethod:t};return o.isSharedWorker&&o.assignPort(s,i),o.promiseMessage(r,i,a)}}onRegisterRemote(e){if(e.destination===Neo.workerId){let t=this,{className:o,methods:r}=e,s=Neo.ns(o,!0);r.forEach(r=>{if("main"!==e.origin&&s[r])throw new Error("Duplicate remote method definition "+o+"."+r);s[r]??=t.generateRemote(e,r)})}}onRemoteMethod(e){let t,o,r=this,s=Neo.ns(e.remoteClassName);if(!s)throw new Error('Invalid remote namespace "'+e.remoteClassName+'"');if(o=s[e.remoteMethod],!o)throw new Error('Invalid remote method name "'+e.remoteMethod+'"');t=!s.isReady&&s.interceptRemotes?.includes(e.remoteMethod)?s.onInterceptRemotes(e):Array.isArray(e.data)?o.call(s,...e.data):o.call(s,e.data),Neo.isPromise(t)?t.catch(t=>{console.error(t),r.reject(e,t)}).then(t=>{r.resolve(e,t)}):r.resolve(e,t)}reject(e,t){let o=this,r={action:"reply",data:t,reject:!0,replyId:e.id};o.isSharedWorker&&o.assignPort(e,r),o.sendMessage(e.origin,r)}resolve(e,t){let o=this,r={action:"reply",data:t,replyId:e.id};o.isSharedWorker&&o.assignPort(e,r),o.sendMessage(e.origin,r)}});