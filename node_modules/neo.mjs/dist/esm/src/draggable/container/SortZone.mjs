import e from"./DragZone.mjs";import t from"../../util/Array.mjs";import r from"../../util/Rectangle.mjs";import n from"../../util/VDom.mjs";export default Neo.setupClass(class extends e{static config={className:"Neo.draggable.container.SortZone",ntype:"container-sortzone",adjustItemRectsToParent:!1,alwaysFireDragMove:!0,currentIndex:-1,detachThreshold:.8,dragHandleSelector:null,enableProxyToPopup:!1,indexMap:null,itemRects:null,itemStyles:null,lastIntersectionRatio:1,ownerRect:null,ownerStyle:null,reattachThreshold:.6,reversedLayoutDirection:!1,scrollLeft:0,scrollTop:0,sortDirection:"horizontal",startIndex:-1};isOverDragging=!1;isWindowDragging=!1;adjustItemCls(e){let r=this;if(r.dragHandleSelector){const i=r.dragHandleSelector.startsWith(".")?r.dragHandleSelector.substring(1):r.dragHandleSelector;r.owner.items.filter(e=>"string"!=typeof e&&n.find(e.vdom,{cls:i})).forEach(r=>{const n=r.wrapperCls||[];t.toggle(n,"neo-draggable",e),r.wrapperCls=n})}else super.adjustItemCls(e)}checkWindowBoundary(e){let t=this,{proxyRect:n}=e;if(n&&t.boundaryContainerRect){const i=t.boundaryContainerRect,o=r.getIntersection(n,i),a=n.width*n.height,l=o?o.width*o.height:0,d=a>0?l/a:0,s=d>t.lastIntersectionRatio,c=d<t.lastIntersectionRatio;if(t.lastIntersectionRatio=d,t.isWindowDragging){if(t.isWindowDragging)return s&&d>t.reattachThreshold?(t.dragPlaceholder.wrapperStyle={...t.dragPlaceholder.wrapperStyle,visibility:"visible"},t.itemRects.forEach((e,r)=>{let n=t.indexMap[r];if(-1!==n){let r=t.owner.items[n];r!==t.dragPlaceholder&&r!==t.dragComponent&&(r.wrapperStyle={...r.wrapperStyle,height:`${e.height}px`,left:`${e.left}px`,top:`${e.top}px`,width:`${e.width}px`})}}),t.fire("dragBoundaryEntry",{draggedItem:t.dragComponent,proxyRect:n,sortZone:t})):t.onWindowDragContinue(d,e),!0}else if(c&&d<t.detachThreshold)return t.isWindowDragging=!0,t.fire("dragBoundaryExit",{draggedItem:t.dragComponent,proxyRect:n,sortZone:t}),!0}return!1}getDragProxyConfig(){return{...this.dragProxyConfig,cls:[...this.owner.cls]}}moveTo(e,t){this.owner.moveTo(e,t)}async onDragEnd(e){let t,r=this,{itemStyles:n,owner:i}=r,o=i.style||{};if(await r.timeout(10),i.dragResortable){if(r.dragPlaceholder){const e=r.dragComponent,t=[],n=r.sortableItems.indexOf(r.dragPlaceholder);e&&n>-1&&(r.isWindowDragging||(!r.isRemoteDragging||r.isRemoteDragging&&!r.isWindowDragging)&&t.push({action:"moveNode",id:e.id,index:n,parentId:i.getVdomItemsRoot().id}),t.push({action:"removeNode",id:r.dragPlaceholder.id}),await Neo.applyDeltas(r.windowId,t))}if(o.height=r.ownerStyle.height||null,o.minWidth=r.ownerStyle.minWidth||null,o.width=r.ownerStyle.width||null,i.style=o,r.sortableItems?.forEach((e,i)=>{r.isWindowDragging&&e===r.dragComponent||(t=e.wrapperStyle||{},Object.assign(t,{height:n[i].height||null,left:null,margin:null,position:null,top:null,width:n[i].width||null}),i===r.startIndex&&(t.visibility=null),e.wrapperStyle=t)}),r.dragComponent){let e=r.dragComponent.wrapperStyle||{};e.visibility=null,r.dragComponent.wrapperStyle=e}if(!r.isWindowDragging&&!r.isRemoteDragging&&r.startIndex!==r.currentIndex){let e,t;if(r.dragPlaceholder){const n=r.dragComponent;e=r.owner.items.indexOf(n),t=r.owner.items.indexOf(r.sortableItems[r.currentIndex])}else e=r.owner.items.indexOf(r.sortableItems[r.startIndex]),t=r.owner.items.indexOf(r.sortableItems[r.currentIndex]);r.moveTo(e,t)}Object.assign(r,{currentIndex:-1,indexMap:null,isRemoteDragging:!1,isWindowDragging:!1,itemRects:null,itemStyles:null,ownerRect:null,startIndex:-1,sortableItems:null}),await r.timeout(30),r.dragEnd(e)}}async onDragMove(e){let t=this;if(!t.itemRects||t.isScrolling||!t.boundaryContainerRect)return;if(!t.isRemoteDragging&&t.dragProxy&&t.enableProxyToPopup&&t.checkWindowBoundary(e))return;let r,n,i,o,a,l,{clientX:d,clientY:s}=e,c=t.currentIndex,{itemRects:g}=t,h=g.length-1,w=t.adjustItemRectsToParent?t.ownerRect.x:0,p=t.adjustItemRectsToParent?t.ownerRect.y:0,m=t.reversedLayoutDirection;"horizontal"===t.sortDirection?(r=d-w+t.scrollLeft-t.offsetX-g[c].left,i=d>t.boundaryContainerRect.right,o=d<t.boundaryContainerRect.left,a="width"):(r=s-p+t.scrollTop-t.offsetY-g[c].top,i=s>t.boundaryContainerRect.bottom,o=s<t.boundaryContainerRect.top,a="height"),n=i||o,l=n?.02:.55,o?c>0&&(t.currentIndex--,await t.scrollToIndex(),t.switchItems(c,t.currentIndex)):i?c<h&&(t.currentIndex++,await t.scrollToIndex(),t.switchItems(c,t.currentIndex)):c>0&&(!m&&r<0||m&&r>0)?Math.abs(r)>g[c-1][a]*l&&(t.currentIndex--,t.switchItems(c,t.currentIndex)):c<h&&(!m&&r>0||m&&r<0)&&Math.abs(r)>g[c+1][a]*l&&(t.currentIndex++,t.switchItems(c,t.currentIndex)),t.isOverDragging=n&&0!==t.currentIndex&&t.currentIndex!==h,t.isOverDragging&&(await t.timeout(30),t.isOverDragging&&await t.onDragMove(e))}async onDragStart(e){let t,r,i,o,a,l,d=this,{adjustItemRectsToParent:s,dragHandleSelector:c,owner:g}=d,h=d.itemStyles=[],{layout:w}=g,p=g.style||{};if(g.dragResortable){if(c){const i=c.substring(1),o=e.path.find(e=>e.cls.includes(i));if(!o)return;for(let r=e.path.indexOf(o);r<e.path.length;r++){const n=e.path[r],i=Neo.getComponent(n.id);if(i&&g.items.includes(i)){t=i;break}}if(!t)return;if(l=g.items.filter(e=>n.find(e.vdom,{cls:c.startsWith(".")?c.substring(1):c})),r=l.indexOf(t),r<0)return}else t=Neo.getComponent(e.path[0].id),l=g.items,r=g.indexOf(t.id);i={},Object.assign(d,{currentIndex:r,dragElement:n.find(g.vdom,t.id).vdom,dragProxyConfig:d.getDragProxyConfig(),indexMap:i,lastIntersectionRatio:1,ownerStyle:{height:p.height,minWidth:p.minWidth,width:p.width},reversedLayoutDirection:"column-reverse"===w.direction||"row-reverse"===w.direction,sortableItems:l,sortDirection:w.direction?.includes("column")?"vertical":"horizontal",startIndex:r}),d.dragComponent=t,l.forEach((e,t)=>{i[t]=g.items.indexOf(e),h.push({height:e.height?`${e.height}px`:e.style?.height,width:e.width?`${e.width}px`:e.style?.width})});const m=await g.getDomRect([g.id].concat(l.map(e=>e.id)));if(d.ownerRect=m.shift(),m.length>0){const e=m[0],t=m[m.length-1];d.sortDirection,e.x>d.ownerRect.x&&(d.ownerRect.x=e.x),e.y>d.ownerRect.y&&(d.ownerRect.y=e.y),d.ownerRect.width=t.x+t.width-d.ownerRect.x,d.ownerRect.height=t.y+t.height-d.ownerRect.y}if(g.style={...p,height:`${d.ownerRect.height}px`,minWidth:`${d.ownerRect.width}px`,width:`${d.ownerRect.width}px`},s&&m.forEach(e=>{e.x-=d.ownerRect.x,e.y-=d.ownerRect.y}),d.itemRects=m,await d.dragStart(e),d.dragPlaceholder){const e=l.indexOf(t);e>-1&&(l[e]=d.dragPlaceholder),d.dragElement=d.dragPlaceholder.vdom}l.forEach((e,t)=>{o=e.wrapperStyle||{},a=d.itemRects[t],d.adjustProxyRectToParent?.(a,d.ownerRect),e.wrapperStyle=Object.assign(o,{height:`${a.height}px`,left:`${a.left}px`,margin:"0px",position:"absolute",top:`${a.top}px`,width:`${a.width}px`})}),await d.timeout(5),d.dragPlaceholder||(o=t.wrapperStyle||{},o.visibility="hidden",t.wrapperStyle=o)}}onWindowDragContinue(e,t){}async scrollToIndex(){let e=this;e.isScrolling=!0,await(e.owner.scrollToIndex?.(e.currentIndex,e.itemRects[e.currentIndex])),e.isScrolling=!1}switchItems(e,t){let r,n=this,i=n.reversedLayoutDirection;(!i&&t<e||i&&e<t)&&(r=e,e=t,t=r);let o=n.itemRects,a=n.indexMap,l=o[e],d=o[t],s=l.clone(),c=d.clone();if("horizontal"===n.sortDirection){const e=c.x-(s.x+s.width);l.width=c.width,d.x=s.x+c.width+e,d.width=s.width}else{const e=c.y-(s.y+s.height);l.height=c.height,d.height=s.height,d.y=s.y+c.height+e}r=a[e],a[e]=a[t],a[t]=r,n.updateItem(e,l),n.updateItem(t,d)}updateItem(e,t){let r,n=this,i=n.indexMap[e];if(-1===i){if(!n.dragPlaceholder)return;r=n.dragPlaceholder}else r=n.owner.items[i],n.dragPlaceholder&&r===n.dragComponent&&(r=n.dragPlaceholder);let{wrapperStyle:o}=r;o.left=`${t.left}px`,o.top=`${t.top}px`,r.wrapperStyle=o}});