import e from"./DragZone.mjs";import t from"../../util/Array.mjs";import r from"../../util/Rectangle.mjs";import i from"../../util/VDom.mjs";export default Neo.setupClass(class extends e{static config={className:"Neo.draggable.container.SortZone",ntype:"container-sortzone",adjustItemRectsToParent:!1,alwaysFireDragMove:!0,currentIndex:-1,dragHandleSelector:null,enableProxyToPopup:!1,indexMap:null,itemMargin:null,itemRects:null,itemStyles:null,ownerRect:null,ownerStyle:null,reversedLayoutDirection:!1,scrollLeft:0,scrollTop:0,sortDirection:"horizontal",startIndex:-1};isOverDragging=!1;isWindowDragging=!1;adjustItemCls(e){let r=this;if(r.dragHandleSelector){const n=r.dragHandleSelector.startsWith(".")?r.dragHandleSelector.substring(1):r.dragHandleSelector;r.owner.items.filter(e=>"string"!=typeof e&&i.find(e.vdom,{cls:n})).forEach(r=>{const i=r.wrapperCls||[];t.toggle(i,"neo-draggable",e),r.wrapperCls=i})}else super.adjustItemCls(e)}getDragProxyConfig(){return{...this.dragProxyConfig,cls:[...this.owner.cls]}}moveTo(e,t){this.owner.moveTo(e,t)}async onDragEnd(e){let t,r=this,{itemStyles:i,owner:n}=r,o=n.style||{};await r.timeout(10),n.sortable&&(o.height=r.ownerStyle.height||null,o.minWidth=r.ownerStyle.minWidth||null,o.width=r.ownerStyle.width||null,n.style=o,r.sortableItems.forEach((e,n)=>{t=e.wrapperStyle||{},Object.assign(t,{height:i[n].height||null,left:null,margin:null,position:null,top:null,width:i[n].width||null}),n===r.startIndex&&(t.visibility=null),e.wrapperStyle=t}),r.startIndex!==r.currentIndex&&r.moveTo(r.owner.items.indexOf(r.sortableItems[r.startIndex]),r.owner.items.indexOf(r.sortableItems[r.currentIndex])),Object.assign(r,{currentIndex:-1,indexMap:null,itemRects:null,itemStyles:null,ownerRect:null,startIndex:-1,sortableItems:null}),await r.timeout(30),r.dragEnd(e))}async onDragMove(e){let t=this;if(!t.itemRects||t.isScrolling)return;if(t.dragProxy&&t.enableProxyToPopup){const{proxyRect:i}=e;if(i&&t.boundaryContainerRect){const e=t.boundaryContainerRect,n=r.getIntersection(i,e),o=i.width*i.height,a=n?n.width*n.height:0;if(t.isWindowDragging){if(t.isWindowDragging)return void(o>0&&a/o>.51&&t.fire("dragBoundaryEntry",{draggedItem:Neo.getComponent(t.dragElement.id),proxyRect:i,sortZone:t}))}else if(o>0&&a/o<.5)return t.isWindowDragging=!0,void t.fire("dragBoundaryExit",{draggedItem:Neo.getComponent(t.dragElement.id),proxyRect:i,sortZone:t})}}let i,n,o,a,s,l,{clientX:d,clientY:c}=e,g=t.currentIndex,{itemRects:h}=t,u=h.length-1,p=t.adjustItemRectsToParent?t.ownerRect.x:0,m=t.adjustItemRectsToParent?t.ownerRect.y:0,w=t.reversedLayoutDirection;"horizontal"===t.sortDirection?(i=d-p+t.scrollLeft-t.offsetX-h[g].left,o=d>t.boundaryContainerRect.right,a=d<t.boundaryContainerRect.left,s="width"):(i=c-m+t.scrollTop-t.offsetY-h[g].top,o=c>t.boundaryContainerRect.bottom,a=c<t.boundaryContainerRect.top,s="height"),n=o||a,l=n?.02:.55,a?g>0&&(t.currentIndex--,await t.scrollToIndex(),t.switchItems(g,t.currentIndex)):o?g<u&&(t.currentIndex++,await t.scrollToIndex(),t.switchItems(g,t.currentIndex)):g>0&&(!w&&i<0||w&&i>0)?Math.abs(i)>h[g-1][s]*l&&(t.currentIndex--,t.switchItems(g,t.currentIndex)):g<u&&(!w&&i>0||w&&i<0)&&Math.abs(i)>h[g+1][s]*l&&(t.currentIndex++,t.switchItems(g,t.currentIndex)),t.isOverDragging=n&&0!==t.currentIndex&&t.currentIndex!==u,t.isOverDragging&&(await t.timeout(30),t.isOverDragging&&await t.onDragMove(e))}async onDragStart(e){let t,r,n,o,a,s,l=this,{adjustItemRectsToParent:d,dragHandleSelector:c,owner:g}=l,h=l.itemStyles=[],{layout:u}=g,p=g.style||{};if(g.sortable){if(c){const n=c.substring(1),o=e.path.find(e=>e.cls.includes(n));if(!o)return;for(let r=e.path.indexOf(o);r<e.path.length;r++){const i=e.path[r],n=Neo.getComponent(i.id);if(n&&g.items.includes(n)){t=n;break}}if(!t)return;if(s=g.items.filter(e=>i.find(e.vdom,{cls:c.startsWith(".")?c.substring(1):c})),r=s.indexOf(t),r<0)return}else t=Neo.getComponent(e.path[0].id),s=g.items,r=g.indexOf(t.id);n={},Object.assign(l,{currentIndex:r,dragElement:i.find(g.vdom,t.id).vdom,dragProxyConfig:l.getDragProxyConfig(),indexMap:n,ownerStyle:{height:p.height,minWidth:p.minWidth,width:p.width},reversedLayoutDirection:"column-reverse"===u.direction||"row-reverse"===u.direction,sortableItems:s,sortDirection:u.direction?.includes("column")?"vertical":"horizontal",startIndex:r}),await l.dragStart(e),s.forEach((e,t)=>{n[t]=g.items.indexOf(e),h.push({height:e.height?`${e.height}px`:e.style?.height,width:e.width?`${e.width}px`:e.style?.width})});const m=await g.getDomRect([g.id].concat(s.map(e=>e.id)));l.ownerRect=m.shift(),g.style={...p,height:`${l.ownerRect.height}px`,minWidth:`${l.ownerRect.width}px`,width:`${l.ownerRect.width}px`},d&&m.forEach(e=>{e.x-=l.ownerRect.x,e.y-=l.ownerRect.y}),l.itemRects=m,s.forEach((e,t)=>{o=e.wrapperStyle||{},a=l.itemRects[t],l.adjustProxyRectToParent?.(a,l.ownerRect),e.wrapperStyle=Object.assign(o,{height:`${a.height}px`,left:`${a.left}px`,margin:l.itemMargin,position:"absolute",top:`${a.top}px`,width:`${a.width}px`})}),await l.timeout(5),o=t.wrapperStyle||{},o.visibility="hidden",t.wrapperStyle=o}}async scrollToIndex(){let e=this;e.isScrolling=!0,await(e.owner.scrollToIndex?.(e.currentIndex,e.itemRects[e.currentIndex])),e.isScrolling=!1}startWindowDrag(e){let{popupHeight:t,popupWidth:r,windowName:i}=e;this.dragProxy.hidden=!0,Neo.main.addon.DragDrop.startWindowDrag({popupHeight:t,popupName:i,popupWidth:r})}switchItems(e,t){let r,i=this,n=i.reversedLayoutDirection;(!n&&t<e||n&&e<t)&&(r=e,e=t,t=r);let o=i.itemRects,a=i.indexMap,s=o[e],l=o[t],d=s.clone(),c=l.clone();"horizontal"===i.sortDirection?(s.width=c.width,l.x=d.x+c.width,l.width=d.width):(s.height=c.height,l.height=d.height,l.y=d.y+c.height),r=a[e],a[e]=a[t],a[t]=r,i.updateItem(e,s),i.updateItem(t,l)}updateItem(e,t){let r=this.owner.items[this.indexMap[e]],{wrapperStyle:i}=r;i.left=`${t.left}px`,i.top=`${t.top}px`,r.wrapperStyle=i}});