import e from"../component/Base.mjs";export default Neo.setupClass(class extends e{static config={className:"Neo.component.MagicMoveText",ntype:"magic-move-text",autoCycle_:!0,autoCycleInterval_:2e3,baseCls:["neo-magic-move-text"],colorMove:null,colorFadeIn:null,colorFadeOut:null,cycleTexts:null,fontFamily_:"Helvetica Neue",text_:null,transitionTime_:500,_vdom:{style:{},cn:[{cls:["neo-content"],cn:[]},{cls:["neo-measure-element-wrapper"],removeDom:!0,cn:[{cls:["neo-measure-element"],cn:[]}]}]}};chars=[];charsVdom=[];contentHeight=0;contentWidth=0;currentIndex=0;initialResizeEvent=!0;intervalId=null;isTransitioning=!1;measureCache={};previousChars=[];get measureElement(){return this.measureWrapper.cn[0]}get measureWrapper(){return this.vdom.cn[1]}construct(e){super.construct(e);let t=this;t.addDomListeners({resize:t.onResize,scope:t})}async addResizeObserver(e){let{id:t,windowId:a}=this;(await Neo.currentWorker.getAddon("ResizeObserver",a))[e?"register":"unregister"]({id:t,windowId:a}),e&&(this.initialResizeEvent=!0)}afterSetAutoCycle(e,t){this.mounted&&this.startAutoCycle(e)}afterSetAutoCycleInterval(e,t){let a=this;t&&a.mounted&&(a.startAutoCycle(!1),a.startAutoCycle())}afterSetFontFamily(e,t){let a=this;a.measureCache={},a.vdom.style.fontFamily=e,a.update()}afterSetMounted(e,t){super.afterSetMounted(e,t);let a=this;e?a.getDomRect().then(e=>{a.contentHeight=e.height,a.contentWidth=e.width}):(a.measureCache={},a.previousChars=[]),void 0!==t&&(a.addResizeObserver(e),a.autoCycle&&a.startAutoCycle(e))}async afterSetText(e,t){let a=this,{measureElement:s}=a;t&&(a.previousChars=a.chars),e&&(a.chars=[],s.cn=[],e?.split("").forEach(e=>{a.chars.push({name:e})," "===e&&(e="&#32;"),s.cn.push({tag:"span",html:e})}),a.mounted&&await a.measureChars(),await a.updateChars())}afterSetTransitionTime(e,t){this.vdom.style["--neo-transition-time"]=e+"ms",this.update()}createCharsVdom(e){let t,a=this,{chars:s}=a,r=[];return e.forEach((e,n)=>{null!==e&&(t=s[n],r.push({cls:["neo-char"],html:t.name,style:{color:a.colorFadeIn,left:t.left,opacity:0,top:t.top}}))}),r}cycleText(){let e=this;e.text=e.cycleTexts[e.currentIndex],e.currentIndex=(e.currentIndex+1)%e.cycleTexts.length}async measureChars(){let e,t,a=this,{measureCache:s,measureElement:r,measureWrapper:n,text:o}=a;s[o]?(t=[...s[o]],e=t.shift()):(n.style={height:a.contentHeight+"px",width:a.contentWidth+"px"},delete n.removeDom,await a.promiseUpdate(),await a.timeout(20),t=await a.getDomRect([n.id,...r.cn.map(e=>e.id)]),e=t.shift(),s[o]=[e,...t]),t.forEach((t,s)=>{a.chars[s].left=t.left-e.left+"px",a.chars[s].top=t.top-e.top+"px"}),n.removeDom=!0,await a.promiseUpdate()}async onResize({rect:e}){let t=this;t.contentHeight=e.height,t.contentWidth=e.width,t.measureCache={},t.initialResizeEvent?t.initialResizeEvent=!1:t.isTransitioning||(await t.measureChars(),t.charsVdom=t.createCharsVdom(t.chars.map(e=>e.name)))}sortCharacters(e,t){let a=parseFloat(e.style.top)-parseFloat(t.style.top);return 0!==a?a:parseFloat(e.style.left)-parseFloat(t.style.left)}startAutoCycle(e=!0){let t=this;e?(t.intervalId=setInterval(t.cycleText.bind(t),t.autoCycleInterval),t.timeout(20).then(()=>{t.cycleText()})):clearInterval(t.intervalId)}async updateChars(){let e,t,a=this,{chars:s,previousChars:r}=a,n=a.vdom.cn[0],o=s.map(e=>e.name);for(a.isTransitioning=!0,a.charsVdom.length>1&&(n.cn=a.charsVdom,await a.promiseUpdate()),r.forEach((r,i)=>{t=o.indexOf(r.name),t>-1?(e=n.cn[i],Object.assign(e.style,{color:a.colorMove,left:s[t].left,top:s[t].top}),o[t]=null):(e=n.cn[i],e.flag="remove")}),n.cn.push(...a.createCharsVdom(o)),await a.promiseUpdate(),n.cn.forEach(e=>{"remove"===e.flag?(e.style.color=a.colorFadeOut,e.style.opacity=0):delete e.style.opacity}),await a.promiseUpdate(),await a.timeout(a.transitionTime),n.cn.sort(a.sortCharacters),t=n.cn.length-1;t>=0;t--)e=n.cn[t],delete e.flag,delete e.style.color,0===e.style.opacity&&n.cn.splice(t,1);await a.promiseUpdate(),await a.timeout(200),a.charsVdom=[...n.cn],n.cn.length=0,n.cn.push({html:a.text}),await a.promiseUpdate(),a.isTransitioning=!1}});