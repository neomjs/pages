import t from"../core/Base.mjs";import e from"../util/ClassSystem.mjs";import r from"../core/Config.mjs";import s from"../core/Effect.mjs";import a from"../core/EffectManager.mjs";import o from"../core/Observable.mjs";import{createHierarchicalDataProxy as n}from"./createHierarchicalDataProxy.mjs";import{isDescriptor as i}from"../core/ConfigSymbols.mjs";const c=Symbol.for("twoWayBinding");export default Neo.setupClass(class extends t{static observable=!0;static config={className:"Neo.state.Provider",ntype:"state-provider",component:null,data_:{[i]:!0,merge:"deep",value:{}},formulas_:null,parent_:null,stores_:null};#t=new Map;#e={};#r=new Map;construct(t){Neo.isUsingStateProviders=!0,super.construct(t)}afterSetData(t,e){t&&this.processDataObject(t)}afterSetFormulas(t,e){const r=this;r.#r.forEach(t=>t.destroy()),r.#r.clear(),t&&Object.entries(t).forEach(([t,e])=>{const a=new s({fn:()=>{const s=r.getHierarchyData(),a=e(s);r.setData(t,a)},lazy:!0});r.#r.set(t,a)})}beforeGetData(t){return this.getHierarchyData()}beforeSetStores(t,r){if(t){let r=this;Object.entries(t).forEach(([s,a])=>{Object.entries(a.listeners||{}).forEach(([t,e])=>{r.bindCallback(e,t,r,a.listeners)}),t[s]=e.beforeSetInstance(a)})}return t}createBinding(t,e,r){const a=this,o=new s(()=>{const s=Neo.get(t);if(s&&!s.isDestroyed){const t=a.getHierarchyData(),o=Neo.isFunction(r)?r.call(a,t):t[r];s._skipTwoWayPush=e,s[e]=o,delete s._skipTwoWayPush}});return a.#t.set(t,o),a.observeConfig(t,"isDestroying",e=>{e&&(o.destroy(),a.#t.delete(t))}),o}createBindings(t){let e=this,r=!1;Object.entries(t.bind||{}).forEach(([s,a])=>{let o=a;Neo.isObject(a)&&(a.twoWay&&(r=!0),o=a.key),e.isStoreValue(o)?e.resolveStore(t,s,o.substring(7)):e.createBinding(t.id,s,o,a.twoWay)}),r&&(t[c]=!0)}destroy(){const t=this;t.#r.forEach(t=>t.destroy()),t.#r.clear(),t.#t.forEach(t=>t.destroy()),t.#t.clear(),super.destroy()}getController(t){return this.component.getController(t)}getData(t){const e=this.getOwnerOfDataProperty(t);if(e)return e.owner.getDataConfig(e.propertyName).get()}getDataConfig(t){return this.#e[t]||null}getHierarchyData(){return n(this)}getOwnerOfDataProperty(t){let e=this;if(e.#e[t])return{owner:e,propertyName:t};const r=e.getParent();return r?r.getOwnerOfDataProperty(t):null}getParent(){let t=this;return t._parent?t._parent:t.component&&t.component.parent?.getStateProvider()||null}getStore(t,e=this){let r,{stores:s}=this;return s?.hasOwnProperty(t)?s[t]:(r=this.getParent(),r||console.error(`store '${t}' not found inside this stateProvider or parents.`,e),r.getStore(t,e))}hasNestedDataStartingWith(t){const e=`${t}.`;return!!Object.keys(this.#e).some(t=>t.startsWith(e))||(this.getParent()?.hasNestedDataStartingWith(t)||!1)}getTopLevelDataKeys(t){const e=new Set,r=t?`${t}.`:"";for(const t in this.#e)if(t.startsWith(r)){const s=t.substring(r.length).split(".")[0];s&&e.add(s)}return Array.from(e)}internalSetData(t,e,r){const s=this;if(Neo.isObject(t))return void Object.entries(t).forEach(([t,e])=>{s.internalSetData(t,e,r)});if("Object"===Neo.typeOf(e))return void Object.entries(e).forEach(([e,a])=>{const o=`${t}.${e}`;s.internalSetData(o,a,r)});const a=s.getOwnerOfDataProperty(t),o=a?a.owner:r||s;s.#s(o,t,e,null);let n=t,i=e;for(;n.includes(".");){const t=n.split(".").pop();n=n.substring(0,n.lastIndexOf("."));const e=o.getDataConfig(n);if(e){const r=e.get();if(!Neo.isObject(r))break;{const s={...r,[t]:i};e.set(s),i=s}}else{const e={[t]:i};s.#s(o,n,e),i=e}}}isStoreValue(t){return Neo.isString(t)&&t.startsWith("stores.")}onConstructed(){super.onConstructed(),this.#r.forEach(t=>t.run())}onDataPropertyChange(t,e,r){}processDataObject(t,e=""){let s=this;Object.entries(t).forEach(([t,a])=>{const o=e?`${e}.${t}`:t;s.#e[o]?s.#e[o].set(a):s.#e[o]=new r(a),"Object"===Neo.typeOf(a)&&s.processDataObject(a,o)})}resolveStore(t,e,r){let s=this.getStore(r);t[e]!==s&&(t[e]=s)}#s(t,e,s,a){let o=t.getDataConfig(e),n=a;o?(n=o.get(),o.set(s)):(o=new r(s),t.#e[e]=o,t.#t.forEach(t=>t.run())),t.onDataPropertyChange(e,s,n)}setData(t,e){a.pause();try{this.internalSetData(t,e,this)}finally{a.resume()}}setDataAtSameLevel(t,e){a.pause();try{this.internalSetData(t,e)}finally{a.resume()}}});