import{buffer as e,debounce as t,intercept as s,resolveCallback as o,throttle as r}from"../util/Function.mjs";import i from"./IdGenerator.mjs";const n=Symbol.for("configSymbol"),a=Symbol("forceAssignConfigs"),c=Symbol("isInstance");class l{static delayable={};static instanceManagerAvailable=!1;static methodNameRegex=/\n.*\n\s+at\s+.*\.(\w+)\s+.*/;static observable=!1;static overwrittenMethods={};static config={className:"Neo.core.Base",ntype:"base",delayable:null,id_:null,isConstructed:!1,mixins:null,module:null};#e=[];construct(e={}){let t=this;Object.defineProperties(t,{[n]:{configurable:!0,enumerable:!1,value:{},writable:!0},[c]:{enumerable:!1,value:!0}}),t.createId(e.id||t.id),delete e.id,t.constructor.config&&delete t.constructor.config.id,t.getStaticConfig("observable")&&t.initObservable(e),e=t.setFields(e),t.initConfig(e),Object.defineProperty(t,"configsApplied",{enumerable:!1,value:!0}),t.applyDelayable(),s(t,"destroy",t.isDestroyedCheck,t),t.remote&&setTimeout(t.initRemote.bind(t),1)}afterSetId(e,t){let s=this,o=!0===l.instanceManagerAvailable;t&&(o?Neo.manager.Instance.unregister(t):delete Neo.idMap[t]),e&&(o?Neo.manager.Instance.register(s):(Neo.idMap=Neo.idMap||{},Neo.idMap[s.id]=s))}applyDelayable(){let s=this,o=s.constructor.delayable,i=s.delayable?Neo.merge({},s.delayable,o):o;Object.entries(i).forEach((([o,i])=>{if(i){let n={buffer(){s[o]=new e(s[o],s,i.timer)},debounce(){s[o]=new t(s[o],s,i.timer)},throttle(){s[o]=new r(s[o],s,i.timer)}};n[i.type]?.()}}))}static applyOverwrites(e){let t,s,o=Neo.ns(e.className,!1,Neo.overwrites);if(o){for(s in o)Neo.isFunction(o[s])&&(t=this.prototype,t[s]&&(t.constructor.overwrittenMethods[s]=t[s]));Object.assign(e,o)}}beforeSetEnumValue(e,t,s,o=s+"s"){let r=Array.isArray(o)?o:this.getStaticConfig(o);return r.includes(e)?e:(console.error(`Supported values for ${s} are:`,...r,this),t)}bindCallback(e,t,s=this,r=this){if(e&&Neo.isString(e)){const i=o(e,s);r[t]=i.fn.bind(i.scope)}}callOverwritten(...e){let t=(new Error).stack.match(l.methodNameRegex)[1];this.__proto__.constructor.overwrittenMethods[t].call(this,...e)}createId(e){this.id=e||i.getId(this.getIdKey())}destroy(){let e=this;e.#e.forEach((e=>{clearTimeout(e)})),!0===l.instanceManagerAvailable?Neo.manager.Instance.unregister(e):Neo.idMap&&delete Neo.idMap[e.id],Object.keys(e).forEach((t=>{Object.getOwnPropertyDescriptor(e,t).writable&&"destroy"!==t&&"_id"!==t&&delete e[t]})),Neo.isFunction(e.fire)&&(e.fire=Neo.emptyFn),e.isDestroyed=!0}getIdKey(){return this.ntype}getStaticConfig(e){return this.constructor[e]}hasNtype(e){return this.constructor.ntypeChain.includes(e)}init(){}initConfig(e,t){let s=this;s.isConfiguring=!0,Object.assign(s[n],s.mergeConfig(e,t)),s.processConfigs(),s.isConfiguring=!1}initRemote(){let e=this,{className:t,remote:s}=e,{currentWorker:o}=Neo;if(!e.singleton&&!e.isMainThreadAddon)throw new Error("Remote method access is only functional for Singleton classes "+t);!Neo.config.unitTestMode&&Neo.isObject(s)&&("main"!==Neo.workerId&&o.isSharedWorker&&!o.isConnected?o.on("connected",(()=>{l.sendRemotes(t,s)}),e,{once:!0}):l.sendRemotes(t,s))}isDestroyedCheck(){return!this.isDestroyed}mergeConfig(e,t){let s=this,o=s.constructor;if(!o.config)throw new Error("Neo.applyClassConfig has not been run on "+s.className);return t||(s.originalConfig=Neo.clone(e,!0,!0)),{...o.config,...e}}onAfterConstructed(){let e=this;e.isConstructed=!0,e.getStaticConfig("observable")&&e.fire("constructed",e)}onConstructed(){}parseItemConfigs(e){let t,s,o,r,i=this;e&&(Array.isArray(e)||(e=[e]),e.forEach((e=>{e&&Object.entries(e).forEach((([a,c])=>{Array.isArray(c)?i.parseItemConfigs(c):"string"==typeof c&&c.startsWith("@config:")&&(s=c.substring(8).trim().split("."),o=s.pop(),t=Neo.ns(s,!1,i),void 0===t[o]?console.error("The used @config does not exist:",o,s.join(".")):(r=Neo.ns(s,!1,i[n]),r&&Object.hasOwn(r,o)?e[a]=r[o]:e[a]=t[o]))}))})))}processConfigs(e=!1){let t=this,s=Object.keys(t[n]);t[a]=e,s.length>0&&(!e&&t.hasOwnProperty(s[0])||(t[s[0]]=t[n][s[0]]),delete t[n][s[0]],t.processConfigs(e))}static sendRemotes(e,t){let s;Object.entries(t).forEach((([t,o])=>{Neo.workerId!==t&&(s="main"===Neo.workerId?Neo.worker.Manager:Neo.currentWorker,s.sendMessage(t,{action:"registerRemote",className:e,methods:o}))}))}set(e={}){let t=this;e=t.setFields(e),!0!==t[a]&&Object.keys(t[n]).length>0&&t.processConfigs(),Object.assign(t[n],e),t.processConfigs(!0)}setFields(e){let t=this,s=t.constructor.config;return Object.entries(e).forEach((([o,r])=>{s.hasOwnProperty(o)||Neo.hasPropertySetter(t,o)||(t[o]=r,delete e[o])})),e}setStaticConfig(e,t){let s=this.constructor.staticConfig;return!!s.hasOwnProperty(e)&&(s[e]=t,!0)}timeout(e){return new Promise((t=>{let s=this.#e,o=setTimeout((()=>{s.splice(s.indexOf(o),1),t()}),e);s.push(o)}))}get[Symbol.toStringTag](){return`${this.className} (id: ${this.id})`}static[Symbol.hasInstance](e){return!!e&&(!0===e[c]&&super[Symbol.hasInstance](e))}}export default Neo.setupClass(l);