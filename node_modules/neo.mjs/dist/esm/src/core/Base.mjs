import{buffer as e,debounce as t,intercept as s,resolveCallback as o,throttle as i}from"../util/Function.mjs";import r from"../core/Compare.mjs";import n from"../core/Util.mjs";import a from"./Config.mjs";import{isDescriptor as c}from"./ConfigSymbols.mjs";import l from"./IdGenerator.mjs";import f from"./EffectBatchManager.mjs";const g=Symbol.for("configSymbol"),d=Symbol("forceAssignConfigs"),u=Symbol("isInstance");class m{static delayable={};static instanceManagerAvailable=!1;static methodNameRegex=/\n.*\n\s+at\s+.*\.(\w+)\s+.*/;static observable=!1;static overwrittenMethods={};static config={className:"Neo.core.Base",ntype:"base",delayable:null,id_:null,interceptRemotes:null,isConstructed:!1,isDestroying_:!1,isReady_:!1,mixins:null,module:null,remote_:null};#e={};#t=[];#s=[];construct(e={}){let t=this;Object.defineProperties(t,{[g]:{configurable:!0,enumerable:!1,value:{},writable:!0},[u]:{enumerable:!1,value:!0}}),t.id=e.id||l.getId(this.getIdKey()),delete e.id,t.getStaticConfig("observable")&&t.initObservable(e),e=t.setFields(e),t.initConfig(e),Object.defineProperty(t,"configsApplied",{enumerable:!1,value:!0}),t.applyDelayable(),s(t,"destroy",t.isDestroyedCheck,t),Promise.resolve().then(async()=>{await t.initAsync(),t.isReady=!0})}afterSetId(e,t){let s=this,o=!0===m.instanceManagerAvailable;t&&(o?Neo.manager.Instance.unregister(t):Neo.idMap&&delete Neo.idMap[t]),e&&(o?Neo.manager.Instance.register(s):(Neo.idMap??={},Neo.idMap[e]=s))}applyDelayable(){let s=this,o=s.constructor.delayable,r=s.delayable?Neo.merge({},s.delayable,o):o;Object.entries(r).forEach(([o,r])=>{if(r){let n={buffer(){s[o]=new e(s[o],s,r.timer)},debounce(){s[o]=new t(s[o],s,r.timer)},throttle(){s[o]=new i(s[o],s,r.timer)}};n[r.type]?.()}})}static applyOverwrites(e){let t,s,o=Neo.ns(e.className,!1,Neo.overwrites);if(o){for(s in o)Neo.isFunction(o[s])&&(t=this.prototype,t[s]&&(t.constructor.overwrittenMethods[s]=t[s]));Object.assign(e,o)}}beforeSetEnumValue(e,t,s,o=s+"s"){let i=Array.isArray(o)?o:this.getStaticConfig(o);return i.includes(e)?e:(console.error(`Supported values for ${s} are:`,...i,this),t)}beforeSetRemote(e,t){let s=this;if(e&&!s.singleton&&!s.isMainThreadAddon)throw new Error("Remote method access is only functional for Singleton classes "+s.className);return e}bindCallback(e,t,s=this,i=this){if(e&&Neo.isString(e)){const r=o(e,s);i[t]=r.fn.bind(r.scope)}}callOverwritten(...e){let t=(new Error).stack.match(m.methodNameRegex)[1];this.__proto__.constructor.overwrittenMethods[t].call(this,...e)}destroy(){let e=this;e.isDestroying=!0,e.#s.forEach(e=>{clearTimeout(e)}),e.#t.forEach(e=>{e()}),!0===m.instanceManagerAvailable?Neo.manager.Instance.unregister(e):Neo.idMap&&delete Neo.idMap[e.id],Object.keys(e).forEach(t=>{Object.getOwnPropertyDescriptor(e,t).writable&&"destroy"!==t&&"_id"!==t&&delete e[t]}),Neo.isFunction(e.fire)&&(e.fire=Neo.emptyFn),e.isDestroyed=!0}getConfig(e){let t=this;return!t.#e[e]&&t.isConfig(e)&&(t.#e[e]=new a(t.constructor.configDescriptors?.[e])),t.#e[e]}getIdKey(){return this.ntype}getStaticConfig(e){return this.constructor[e]}hasNtype(e){return this.constructor.ntypeChain.includes(e)}init(){}async initAsync(){this.remote&&this.initRemote()}initConfig(e,t){let s=this;s.isConfiguring=!0,Object.assign(s[g],s.mergeConfig(e,t)),delete s[g].id,s.processConfigs(),s.isConfiguring=!1}initRemote(){let{className:e,remote:t}=this,{currentWorker:s}=Neo;Neo.config.unitTestMode||("main"!==Neo.workerId&&s.isSharedWorker&&!s.isConnected?s.on("connected",()=>{m.sendRemotes(e,t)},this,{once:!0}):m.sendRemotes(e,t))}isDestroyedCheck(){return!this.isDestroyed}isConfig(e){let t=this;return t.#e[e]||Neo.hasPropertySetter(t,e)&&e in t.constructor.config}mergeConfig(e,t){let s,o,i=this,r=i.constructor;if(!r.config)throw new Error("Neo.applyClassConfig has not been run on "+i.className);return t||(i.originalConfig=Neo.clone(e,!0,!0)),s=r.configDescriptors,o=r.config,s&&Object.entries(e).forEach(([t,i])=>{const r=s[t];r?.merge&&(e[t]=Neo.mergeConfig(o[t],i,r.merge))}),{...o,...e}}observeConfig(e,t,s){let o=e;if(Neo.isString(e)&&(o=Neo.get(e),!o))return console.warn(`Publisher instance with ID '${e}' not found. Cannot subscribe.`),Neo.emptyFn;if(!(o instanceof Neo.core.Base))return console.warn("Invalid publisher provided. Must be a Neo.core.Base instance or its ID."),Neo.emptyFn;const i=o.getConfig(t);if(!i)return console.warn(`Config '${t}' not found on publisher instance ${o.id}. Cannot subscribe.`),Neo.emptyFn;const r=i.subscribe({id:this.id,fn:s});return this.#t.push(r),r}onAfterConstructed(){let e=this;e.isConstructed=!0,e.getStaticConfig("observable")&&e.fire("constructed",e)}onConstructed(){}onInterceptRemotes(e){}parseItemConfigs(e){let t,s,o,i,r=this;e&&(Array.isArray(e)||(e=[e]),e.forEach(e=>{e&&Object.entries(e).forEach(([n,a])=>{Array.isArray(a)?r.parseItemConfigs(a):"string"==typeof a&&a.startsWith("@config:")&&(s=a.substring(8).trim().split("."),o=s.pop(),t=Neo.ns(s,!1,r),void 0===t[o]?console.error("The used @config does not exist:",o,s.join(".")):(i=Neo.ns(s,!1,r[g]),i&&Object.hasOwn(i,o)?e[n]=i[o]:e[n]=t[o]))})}))}processConfigs(e=!1){let t=this,s=Object.keys(t[g]);t[d]=e,s.length>0&&(!e&&t.hasOwnProperty(s[0])||(t[s[0]]=t[g][s[0]]),delete t[g][s[0]],t.processConfigs(e))}static sendRemotes(e,t){let s;Object.entries(t).forEach(([t,o])=>{Neo.workerId!==t&&(s="main"===Neo.workerId?Neo.worker.Manager:Neo.currentWorker,s.sendMessage(t,{action:"registerRemote",className:e,methods:o}))})}set(e={}){let t=this,s={};f.startBatch(),e=t.setFields(e),!0!==t[d]&&Object.keys(t[g]).length>0&&t.processConfigs(),Object.entries(e).forEach(([o,i])=>{t.isConfig(o)||(s[o]=i,delete e[o])}),Object.assign(t[g],e),Object.entries(s).forEach(([e,s])=>{t[e]=s}),t.processConfigs(!0),f.endBatch()}setFields(e){let t=this;return Object.entries(e).forEach(([s,o])=>{t.isConfig(s)||Neo.hasPropertySetter(t,s)||(t[s]=o,delete e[s])}),e}setStaticConfig(e,t){let s=this.constructor.staticConfig;return!!s.hasOwnProperty(e)&&(s[e]=t,!0)}timeout(e){return new Promise(t=>{let s=this.#s,o=setTimeout(()=>{s.splice(s.indexOf(o),1),t()},e);s.push(o)})}get[Symbol.toStringTag](){return this.className}static[Symbol.hasInstance](e){return!!e&&(!0===e[u]&&super[Symbol.hasInstance](e))}}export default Neo.setupClass(m);