import{buffer as e,debounce as t,intercept as s,resolveCallback as r,throttle as o}from"../util/Function.mjs";import i from"../core/Compare.mjs";import n from"../core/Util.mjs";import a from"./Config.mjs";import{isDescriptor as c,mergeFrom as l}from"./ConfigSymbols.mjs";import m from"./IdGenerator.mjs";import f from"./EffectManager.mjs";const d=Symbol.for("configSymbol"),g=Symbol("forceAssignConfigs"),u=Symbol("isInstance");class y{static delayable={};static instanceManagerAvailable=!1;static methodNameRegex=/\n.*\n\s+at\s+.*\.(\w+)\s+.*/;static observable=!1;static overwrittenMethods={};static config={className:"Neo.core.Base",ntype:"base",delayable:null,id_:null,interceptRemotes:null,isConstructed:!1,isDestroying_:!1,isReady_:!1,mixins:null,module:null,remote_:{[c]:!0,merge:"deepArrays",value:null}};#e=new Map;#t={};#s=[];#r=null;#o=null;#i=null;#n=null;construct(e={}){let t=this;Object.defineProperties(t,{[d]:{configurable:!0,enumerable:!1,value:{},writable:!0},[u]:{enumerable:!1,value:!0}}),t.id=e.id||t.constructor.config.id||m.getId(this.getIdKey()),delete e.id,e=t.setFields(e),t.initConfig(e),Object.defineProperty(t,"configsApplied",{enumerable:!1,value:!0}),t.applyDelayable(),s(t,"destroy",t.#a,t),t.#r=new Promise(e=>{t.#o=e}),t.#i=new Promise(e=>{t.#n=e}),Promise.resolve().then(async()=>{try{await t.initAsync(),t.isReady=!0}catch(e){if(e!==Neo.isDestroyed)throw e}})}afterSetId(e,t){let s=this,r=!0===y.instanceManagerAvailable;t&&(r?Neo.manager.Instance.unregister(t):Neo.idMap&&delete Neo.idMap[t]),e&&(r?Neo.manager.Instance.register(s):(Neo.idMap??={},Neo.idMap[e]=s))}afterSetIsReady(e,t){if(e){let e=this;e.#o?.(),e.getStaticConfig("observable")&&e.fire("ready")}}applyDelayable(){let s=this,r=s.constructor.delayable,i=s.delayable?Neo.merge({},s.delayable,r):r;Object.entries(i).forEach(([r,i])=>{if(i){let n={buffer(){s[r]=new e(s[r],s,i.timer)},debounce(){s[r]=new t(s[r],s,i.timer)},throttle(){s[r]=new o(s[r],s,i.timer)}};n[i.type]?.()}})}static applyOverwrites(e){let t,s,r=Neo.ns(e.className,!1,Neo.overwrites);if(r){for(s in r)Neo.isFunction(r[s])&&(t=this.prototype,t[s]&&(t.constructor.overwrittenMethods[s]=t[s]));Object.assign(e,r)}}beforeSetEnumValue(e,t,s,r=s+"s"){let o=Array.isArray(r)?r:this.getStaticConfig(r);return o.includes(e)?e:(console.error(`Supported values for ${s} are:`,...o,this),t)}beforeSetRemote(e,t){let s=this;if(e&&!s.singleton&&!s.isMainThreadAddon)throw new Error("Remote method access is only functional for Singleton classes "+s.className);return e}bindCallback(e,t,s=this,o=this){if(e&&Neo.isString(e)){const i=r(e,s);o[t]=i.fn.bind(i.scope)}}callOverwritten(...e){let t=(new Error).stack.match(y.methodNameRegex)[1];this.__proto__.constructor.overwrittenMethods[t].call(this,...e)}destroy(){let e=this;e.#e.forEach((e,t)=>{Neo.isNumber(t)&&clearTimeout(t),e(Neo.isDestroyed)}),e.#e.clear(),e.#s.forEach(e=>{e()}),!0===y.instanceManagerAvailable?Neo.manager.Instance.unregister(e):Neo.idMap&&delete Neo.idMap[e.id],Object.keys(e).forEach(t=>{Object.getOwnPropertyDescriptor(e,t).writable&&"destroy"!==t&&"_id"!==t&&delete e[t]}),Neo.isFunction(e.fire)&&(e.fire=Neo.emptyFn),e.isDestroyed=!0}getConfig(e){let t=this;return!t.#t[e]&&t.isConfig(e)&&(t.#t[e]=new a(t.constructor.configDescriptors?.[e])),t.#t[e]}getIdKey(){return this.ntype}getStaticConfig(e){return this.constructor[e]}hasNtype(e){return this.constructor.ntypeChain.includes(e)}init(){}async initAsync(){let e=this;e.remote&&await e.initRemote(),e.#n()}initConfig(e,t){let s=this;s.isConfiguring=!0,Object.assign(s[d],s.mergeConfig(e,t)),delete s[d].id,s.processConfigs(),s.isConfiguring=!1}async initRemote(){let{className:e,remote:t}=this,{currentWorker:s}=Neo;Neo.config.isMiddleware||Neo.config.unitTestMode||("main"!==Neo.workerId&&s.isSharedWorker?(t.main&&s.remotesToRegister.push({className:e,methods:t.main}),s.isConnected||await new Promise(e=>{s.on("connected",()=>e(),this,{once:!0})})):"service"===Neo.workerId&&t.app&&s.remotesToRegister.push({className:e,methods:t.app}),await y.promiseRemotes(e,t))}isConfig(e){let t=this;return t.#t[e]||Neo.hasPropertySetter(t,e)&&e in t.constructor.config}mergeConfig(e,t){let s,r,o=this,i=o.constructor;if(!i.config)throw new Error("Neo.applyClassConfig has not been run on "+o.className);return t||(o.originalConfig=Neo.clone(e,!0,!0)),s=i.configDescriptors,r=i.config,s&&Object.entries(e).forEach(([t,o])=>{const i=s[t];i?.merge&&(e[t]=Neo.mergeConfig(r[t],o,i.merge))}),{...r,...e}}observeConfig(e,t,s){let r=e;if(Neo.isString(e)&&(r=Neo.get(e),!r))return console.warn(`Publisher instance with ID '${e}' not found. Cannot subscribe.`),Neo.emptyFn;if(!(r instanceof Neo.core.Base))return console.warn("Invalid publisher provided. Must be a Neo.core.Base instance or its ID."),Neo.emptyFn;const o=r.getConfig(t);if(!o)return console.warn(`Config '${t}' not found on publisher instance ${r.id}. Cannot subscribe.`),Neo.emptyFn;const i=o.subscribe({id:this.id,fn:s});return this.#s.push(i),i}onAfterConstructed(){let e=this;e.isConstructed=!0,e.getStaticConfig("observable")&&e.fire("constructed",e)}onConstructed(){}onInterceptRemotes(e){}parseItemConfigs(e){let t,s,r,o,i=this;if(e){if(!Array.isArray(e)){if(Neo.isObject(e))return void Object.keys(e).forEach(t=>{let s=e[t];s&&(s[l]&&i[s[l]]&&(e[t]=Neo.mergeConfig(i[s[l]],s,"deep"),s=e[t],delete s[l]),i.parseItemConfigs([s]))});e=[e]}e.forEach((n,a)=>{n&&(n[l]&&i[n[l]]&&(e[a]=Neo.mergeConfig(i[n[l]],n,"deep"),delete(n=e[a])[l]),Object.entries(n).forEach(([e,a])=>{Array.isArray(a)||Neo.isObject(a)&&"items"===e?i.parseItemConfigs(a):"string"==typeof a&&a.startsWith("@config:")&&(s=a.substring(8).trim().split("."),r=s.pop(),t=Neo.ns(s,!1,i),void 0===t[r]?console.error("The used @config does not exist:",r,s.join(".")):(o=Neo.ns(s,!1,i[d]),o&&Object.hasOwn(o,r)?n[e]=o[r]:n[e]=t[r]))}))})}}#a(){return this.isDestroying=!0,!this.isDestroyed}processConfigs(e=!1){let t=this,s=Object.keys(t[d]);t[g]=e,s.length>0&&(!e&&t.hasOwnProperty(s[0])||(t[s[0]]=t[d][s[0]]),delete t[d][s[0]],t.processConfigs(e))}ready(){return this.#r}remotesReady(){return this.#i}static async promiseRemotes(e,t){let s,r=[];Object.entries(t).forEach(([t,o])=>{Neo.workerId!==t&&(s="main"===Neo.workerId?Neo.worker.Manager:Neo.currentWorker,s.hasWorker(t)&&r.push(s.promiseMessage(t,{action:"registerRemote",className:e,methods:o})))}),await Promise.all(r)}serializeConfig(e){let t=this,s=Neo.typeOf(e);if("Array"===s)return e.map(e=>t.serializeConfig(e));if("NeoInstance"===s)return{className:e.className,id:e.id};if("Object"!==s)return"NeoClass"===s?e.prototype.className:e;let r={};return Object.entries(e).forEach(([e,o])=>{s=Neo.typeOf(o),"NeoClass"===s?"module"===e?r.className=o.prototype.className:r[e]=o.prototype.className:r[e]="NeoInstance"===s?{className:o.className,id:o.id}:"Object"===s||"Array"===s?t.serializeConfig(o):"Function"!==s?o:"[Function]"}),r}set(e={}){let t=this,s={};f.pause();try{e=t.setFields(e),!0!==t[g]&&Object.keys(t[d]).length>0&&t.processConfigs(),Object.entries(e).forEach(([r,o])=>{t.isConfig(r)||(s[r]=o,delete e[r])}),Object.assign(t[d],e),Object.entries(s).forEach(([e,s])=>{t[e]=s}),t.processConfigs(!0)}finally{f.resume()}}setFields(e){let t=this;return Object.entries(e).forEach(([s,r])=>{t.isConfig(s)||Neo.hasPropertySetter(t,s)||(t[s]=r,delete e[s])}),e}setStaticConfig(e,t){let s=this.constructor.staticConfig;return!!s.hasOwnProperty(e)&&(s[e]=t,!0)}timeout(e){let t=this;return new Promise((s,r)=>{let o=setTimeout(()=>{t.unregisterAsync(o),s()},e);t.registerAsync(o,r)})}trap(e){let t=this;return new Promise((s,r)=>{const o=Symbol();t.registerAsync(o,r),e.then(e=>{t.unregisterAsync(o),s(e)}).catch(e=>{t.unregisterAsync(o),r(e)})})}unregisterAsync(e){this.#e.delete(e)}registerAsync(e,t){this.#e.set(e,t)}getMixins(e=this.mixins,t=[]){return e&&Object.values(e).forEach(e=>{e&&e.prototype?t.push(e):Neo.isObject(e)&&this.getMixins(e,t)}),t}toJSON(){let e=this;if(e.__inToJSON)return{className:e.className,id:e.id,isDestroyed:e.isDestroyed,ntype:e.ntype,remote:e.remote};e.__inToJSON=!0;try{let t={className:e.className,id:e.id,isDestroyed:e.isDestroyed,ntype:e.ntype,remote:e.remote};return e.getMixins().forEach(s=>{s.prototype.toJSON&&Object.assign(t,s.prototype.toJSON.call(e))}),t}finally{delete e.__inToJSON}}get[Symbol.toStringTag](){return this.className}static[Symbol.hasInstance](e){return!!e&&(!0===e[u]&&super[Symbol.hasInstance](e))}}export default Neo.setupClass(y);