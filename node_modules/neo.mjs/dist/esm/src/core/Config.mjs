import e from"./EffectManager.mjs";import{isDescriptor as r}from"./ConfigSymbols.mjs";class t{#e={};#r;constructor(e){Neo.isObject(e)&&!0===e[r]?this.initDescriptor(e):this.#r=e}get(){return e.addDependency(this),this.#r}initDescriptor({clone:e,cloneOnGet:r,isEqual:t,merge:i}){let s=this;e&&e!==s.clone&&Object.defineProperty(s,"clone",{configurable:!0,enumerable:!0,value:e,writable:!0}),r&&r!==s.cloneOnGet&&Object.defineProperty(s,"cloneOnGet",{configurable:!0,enumerable:!0,value:r,writable:!0}),t&&t!==s.isEqual&&Object.defineProperty(s,"isEqual",{configurable:!0,enumerable:!0,value:t,writable:!0}),i&&i!==s.mergeStrategy&&Object.defineProperty(s,"mergeStrategy",{configurable:!0,enumerable:!0,value:i,writable:!0})}notify(e,r){for(const t in this.#e)if(this.#e.hasOwnProperty(t)){const i=this.#e[t];for(const[t,s]of i)for(const i of s)t.call(i||null,e,r)}}set(e){if(void 0===e)return!1;const r=this,t=r.#r;return!r.isEqual(e,t)&&(r.#r=e,r.notify(e,t),!0)}setRaw(e){this.#r=e}subscribe({id:e,fn:r,scope:t}){if("string"!=typeof e||0===e.length||"function"!=typeof r)throw new Error(["Config.subscribe: options must be an object with a non-empty string `id` ","(the subscription owner's id), and a callback function `fn`."].join(""));const i=this;i.#e[e]||(i.#e[e]=new Map);const s=i.#e[e];s.has(r)||s.set(r,new Set);return s.get(r).add(t),()=>{const s=i.#e[e];if(s){const n=s.get(r);n&&(n.delete(t),0===n.size&&(s.delete(r),0===s.size&&delete i.#e[e]))}}}}Object.defineProperties(t.prototype,{clone:{configurable:!0,enumerable:!1,value:"deep",writable:!1},cloneOnGet:{configurable:!0,enumerable:!1,value:null,writable:!1},isEqual:{configurable:!0,enumerable:!1,value:Neo.isEqual,writable:!1},mergeStrategy:{configurable:!0,enumerable:!1,value:"replace",writable:!1}});export default Neo.gatekeep(t,"Neo.core.Config");