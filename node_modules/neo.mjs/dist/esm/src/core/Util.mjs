class t{static decamelRegEx=/([a-z])([A-Z])/g;static bindMethods(t,e){e.forEach(e=>{t[e]=t[e].bind(t)})}static createStyleObject(t){let e;return t.split(/;(?=[^\)]*(?:\(|$))/g).reduce((t,r)=>(e=r.split(/:(.+)/).map(function(t){let e=parseFloat(t);return t==e?e:t.trim()}),""!==e[0]&&(e[0]=e[0].replace(/-([a-z])/g,(t,e)=>e.toUpperCase()),t[e[0]]=e[1]),t),{})}static createStyles(e){let r="";return Object.entries(e).forEach(([e,i])=>{null!=i&&(r+=t.decamel(e)+":"+i+";")}),r}static decamel(e){return e.replace(t.decamelRegEx,"$1-$2").toLowerCase()}static isArray(t){return Array.isArray(t)}static isBoolean(t){return"boolean"==typeof t}static isDefined(t){return void 0!==t}static isEmpty(e){return null==e||(Array.isArray(e)?0===e.length:!(e instanceof Date)&&(t.isObject(e)?0===Object.keys(e).length:!!t.isString(e)&&""===e))}static isFunction(t){return"function"==typeof t}static isNumber(t){return"number"==typeof t&&isFinite(t)}static isObject(t){return"Object"===t?.constructor?.name}static isPromise(t){return"function"==typeof t?.then}static isRecord(t){return"Record"===t?.constructor?.name}static isString(t){return"string"==typeof t}static toArray(t,e,r){let i;return t&&(i=t.length)?"string"==typeof t?t.split(""):Array.prototype.slice.call(t,e||0,r||i):[]}}Neo.ns("Neo.core",!0).Util=t,Neo.applyFromNs(Neo,t,{bindMethods:"bindMethods",createStyleObject:"createStyleObject",createStyles:"createStyles",decamel:"decamel",isArray:"isArray",isBoolean:"isBoolean",isDefined:"isDefined",isEmpty:"isEmpty",isFunction:"isFunction",isNumber:"isNumber",isObject:"isObject",isPromise:"isPromise",isRecord:"isRecord",isString:"isString",toArray:"toArray"},!0);export default t;