import{internalId as e}from"../core/ConfigSymbols.mjs";import t from"../core/Base.mjs";import i from"./Model.mjs";const l=Symbol.for("data"),s=Symbol.for("initialIndex"),a=Symbol.for("isModified"),r=Symbol.for("originalData"),o=Symbol.for("version");let d;d=Neo.setupClass(class extends t{static config={className:"Neo.data.RecordFactory",recordNamespace:"Neo.data.record",singleton:!0};assignDefaultValues(e,t){return t.fieldsMap.forEach((i,l)=>{if(!i.virtual){if(i.mapping&&!Object.hasOwn(e,l)){let t,s=i.mapping.split("."),a=s.pop();t=s.length>0?Neo.ns(s,!1,e):e,t&&Object.hasOwn(t,a)&&(e[l]=t[a])}if(Object.hasOwn(i,"defaultValue")){const s=Neo.isFunction(i.defaultValue)?i.defaultValue():i.defaultValue;t.hasNestedFields?Neo.assignToNs(l,s,e,!1):void 0===e[l]&&(e[l]=s)}}}),e}createField({field:e,model:t,path:i="",proto:s}){let a,r=e.name,o=""===i?r:`${i}.${r}`;e.fields?e.fields.forEach(e=>{this.createField({field:e,model:t,path:o,proto:s})}):(a=e.virtual?{[o]:{configurable:!0,enumerable:!0,get(){return e.calculate(this[l],this)}}}:{[o]:{configurable:!0,enumerable:!0,get(){return t.hasNestedFields?Neo.ns(o,!1,this[l]):this[l][r]},set(i){this.notifyChange({fields:{[o]:d.parseRecordValue({record:this,field:e,value:i})},model:t,record:this})}}},Object.defineProperties(s,a))}createRecord(e,t){let i=Neo.ns(`${this.recordNamespace}.${e.className}.${e.id}`);return i||(i=this.createRecordClass(e)),new i(t)}createRecordClass(t,n=!1){if(t instanceof i){let i,c,u,f=`${this.recordNamespace}.${t.className}.${t.id}`,h=Neo.ns(f);return!h||n?(c=f.split("."),i=c.pop(),h=Neo.ns(c,!0),u=h[i]=class{static name="Record";[l]={};[s]=null;[o]=0;[e]=Neo.getId("record");get isModified(){let e=this;return t.trackModifiedFields?!Neo.isEqual(e[l],e[r]):e[a]}get version(){return this[o]}constructor(e){let i=this;Object.hasOwn(e,s)&&(i[s]=e[s],delete e[s]),e=d.assignDefaultValues(e,t),t.trackModifiedFields?(i[r]={},i.setOriginal(e)):i[a]=!1,i.setSilent(e)}get(e){return t.getField(e)?this[e]:e.includes(".")?Neo.ns(e,!1,this[l]):this[l][e]}isModifiedField(e){let i=this;if(t.trackModifiedFields){let s,a;if(t.hasNestedFields&&e?.includes(".")){let t=e.split(".");e=t.pop(),s=Neo.ns(t,!1,i[l]),a=Neo.ns(t,!1,i[r])}else s=i[l],a=i[r];return t.getField(e)||Object.hasOwn(s,e)||console.error("The record does not contain the field",e,i),!Neo.isEqual(s[e],a[e])}return null}notifyChange(e,t=!1){const i={...e,silent:t};return d.setRecordFields(i),i}reset(e){this.setOriginal(e),this.set(e)}set(e){this.notifyChange({fields:e,model:t,record:this})}setOriginal(e){d.setRecordFields({fields:e,model:t,record:this,silent:!0,useOriginalData:!0})}setSilent(e){this.notifyChange({fields:e,model:t,record:this},!0)}toJSON(){return structuredClone(this[l])}},Array.isArray(t.fields)&&t.fields.forEach(e=>{d.createField({field:e,model:t,proto:u.prototype})}),Object.defineProperty(u.prototype,"isRecord",{value:!0}),Object.defineProperty(u,"isClass",{value:!0}),h[i]):h}}isRecord(e){return e?.isRecord||!1}onRecordChange(e){Neo.get(e.model.storeId)?.onRecordChange(e)}parseRecordValue({record:e,field:t,value:i=null,recordConfig:s=null,useOriginalData:a=!1}){if(t.calculate)return t.calculate(e[a?r:l],t);t.convert&&(i=t.convert(i,e));let o=t.name,{mapping:d,maxLength:n,minLength:c,nullable:u}=t,f=s?.[o]||e[o],h=t.type?.toLowerCase();if(d&&s){let e=d.split("."),t=e.pop();e=Neo.ns(e,!0,s),i=e[t]}return Object.hasOwn(t,"maxLength")&&i?.toString().length>n?(console.warn(`Setting record field: ${o} value: ${i} conflicts with maxLength: ${n}`),f):Object.hasOwn(t,"minLength")&&i?.toString().length<c?(console.warn(`Setting record field: ${o} value: ${i} conflicts with minLength: ${c}`),f):Object.hasOwn(t,"nullable")&&!1===u&&null===i?(console.warn(`Setting record field: ${o} value: ${i} conflicts with nullable: ${u}`),f):"date"===h&&"Date"!==Neo.typeOf(i)?new Date(i):("float"===h&&i?i=parseFloat(i):"html"===h&&i?i+="":"int"!==h&&"integer"!==h||!i?"string"===h&&i&&(i=(i+="").replace(/(<([^>]+)>)/gi,"")):i=parseInt(i),i)}setRecordData({fieldName:e,model:t,record:i,useOriginalData:s=!1,value:a}){if(s&&!t.trackModifiedFields)return;let o=s?r:l;if(t.hasNestedFields&&e.includes(".")){let t,l;l=e.split("."),e=l.pop(),t=Neo.ns(l,!0,i[o]),t[e]=a}else i[o][e]=a}setRecordFields({changedFields:e=[],fields:t,model:i,record:l,silent:s=!1,useOriginalData:r=!1}){let d,n,c,u=this,{calculatedFieldsMap:f,fieldsMap:h,trackModifiedFields:g}=i;!g&&r||(Object.entries(t).forEach(([t,s])=>{d=h.has(t),Neo.isObject(s)&&!d?Object.entries(s).forEach(([s,a])=>{u.setRecordFields({changedFields:e,fields:{[`${t}.${s}`]:a},model:i,record:l,silent:!0,useOriginalData:r})}):d&&(c=l[t],s=u.parseRecordValue({record:l,field:i.getField(t),value:s}),Neo.isEqual(c,s)||(u.setRecordData({fieldName:t,model:i,record:l,useOriginalData:r,value:s}),g||r||(l[a]=!0),e.push({name:t,oldValue:c,value:s})))}),n=Object.keys(e).length>0,n&&(l[o]++,f.forEach((t,s)=>{t.virtual||(c=l[s],t=u.parseRecordValue({record:l,field:i.getField(s),useOriginalData:r}),Neo.isEqual(c,t)||(u.setRecordData({fieldName:s,model:i,record:l,useOriginalData:r,value:t}),e.push({name:s,oldValue:c,value:t})))})),s||r||!n||u.onRecordChange({fields:e,model:i,record:l}))}});export default d;