import e from"../core/Base.mjs";import t from"./Model.mjs";const l=Symbol.for("data"),i=Symbol.for("initialIndex"),s=Symbol.for("isModified"),a=Symbol.for("originalData");let r;r=Neo.setupClass(class extends e{static config={className:"Neo.data.RecordFactory",recordNamespace:"Neo.data.record",singleton:!0};assignDefaultValues(e,t){return t.fieldsMap.forEach((l,i)=>{if(Object.hasOwn(l,"defaultValue")){const s=Neo.isFunction(l.defaultValue)?l.defaultValue():l.defaultValue;t.hasNestedFields?Neo.assignToNs(i,s,e,!1):void 0===e[i]&&(e[i]=s)}}),e}createField({field:e,model:t,path:i="",proto:s}){let a,o=e.name,d=""===i?o:`${i}.${o}`;e.fields?e.fields.forEach(e=>{this.createField({field:e,model:t,path:d,proto:s})}):(a={[d]:{configurable:!0,enumerable:!0,get(){return t.hasNestedFields?Neo.ns(d,!1,this[l]):this[l][o]},set(l){this.notifyChange({fields:{[d]:r.parseRecordValue({record:this,field:e,value:l})},model:t,record:this})}}},Object.defineProperties(s,a))}createRecord(e,t){let l=Neo.ns(`${this.recordNamespace}.${e.className}.${e.id}`);return l||(l=this.createRecordClass(e)),new l(t)}createRecordClass(e,o=!1){if(e instanceof t){let t,d,n,c=`${this.recordNamespace}.${e.className}.${e.id}`,u=Neo.ns(c);return!u||o?(d=c.split("."),t=d.pop(),u=Neo.ns(d,!0),n=u[t]=class{static name="Record";[l]={};[i]=null;get isModified(){let t=this;return e.trackModifiedFields?!Neo.isEqual(t[l],t[a]):t[s]}constructor(t){let l=this;Object.hasOwn(t,i)&&(l[i]=t[i],delete t[i]),t=r.assignDefaultValues(t,e),e.trackModifiedFields?(l[a]={},l.setOriginal(t)):l[s]=!1,l.setSilent(t)}isModifiedField(t){let i=this;if(e.trackModifiedFields){let s,r;if(e.hasNestedFields&&t?.includes(".")){let e=t.split(".");t=e.pop(),s=Neo.ns(e,!1,i[l]),r=Neo.ns(e,!1,i[a])}else s=i[l],r=i[a];return e.getField(t)||Object.hasOwn(s,t)||console.error("The record does not contain the field",t,i),!Neo.isEqual(s[t],r[t])}return null}notifyChange(e,t=!1){const l={...e,silent:t};return r.setRecordFields(l),l}reset(e){this.setOriginal(e),this.set(e)}set(t){this.notifyChange({fields:t,model:e,record:this})}setOriginal(t){r.setRecordFields({fields:t,model:e,record:this,silent:!0,useOriginalData:!0})}setSilent(t){this.notifyChange({fields:t,model:e,record:this},!0)}toJSON(){return structuredClone(this[l])}},Array.isArray(e.fields)&&e.fields.forEach(t=>{r.createField({field:t,model:e,proto:n.prototype})}),Object.defineProperty(n.prototype,"isRecord",{value:!0}),Object.defineProperty(n,"isClass",{value:!0}),u[t]):u}}isRecord(e){return e?.isRecord||!1}onRecordChange(e){Neo.get(e.model.storeId)?.onRecordChange(e)}parseRecordValue({record:e,field:t,value:i=null,recordConfig:s=null,useOriginalData:r=!1}){if(t.calculate)return t.calculate(e[r?a:l],t);t.convert&&(i=t.convert(i));let o=t.name,{mapping:d,maxLength:n,minLength:c,nullable:u}=t,f=s?.[o]||e[o],h=t.type?.toLowerCase();if(d&&s){let e=d.split("."),t=e.pop();e=Neo.ns(e,!0,s),i=e[t]}return Object.hasOwn(t,"maxLength")&&i?.toString().length>n?(console.warn(`Setting record field: ${o} value: ${i} conflicts with maxLength: ${n}`),f):Object.hasOwn(t,"minLength")&&i?.toString().length<c?(console.warn(`Setting record field: ${o} value: ${i} conflicts with minLength: ${c}`),f):Object.hasOwn(t,"nullable")&&!1===u&&null===i?(console.warn(`Setting record field: ${o} value: ${i} conflicts with nullable: ${u}`),f):"date"===h&&"Date"!==Neo.typeOf(i)?new Date(i):("float"===h&&i?i=parseFloat(i):"html"===h&&i?i+="":"int"!==h&&"integer"!==h||!i?"string"===h&&i&&(i=(i+="").replace(/(<([^>]+)>)/gi,"")):i=parseInt(i),i)}setRecordData({fieldName:e,model:t,record:i,useOriginalData:s=!1,value:r}){if(s&&!t.trackModifiedFields)return;let o=s?a:l;if(t.hasNestedFields&&e.includes(".")){let t,l;l=e.split("."),e=l.pop(),t=Neo.ns(l,!0,i[o]),t[e]=r}else i[o][e]=r}setRecordFields({changedFields:e=[],fields:t,model:l,record:i,silent:a=!1,useOriginalData:r=!1}){let o,d,n,c=this,{calculatedFieldsMap:u,fieldsMap:f,trackModifiedFields:h}=l;!h&&r||(Object.entries(t).forEach(([t,a])=>{o=f.has(t),Neo.isObject(a)&&!o?Object.entries(a).forEach(([s,a])=>{c.setRecordFields({changedFields:e,fields:{[`${t}.${s}`]:a},model:l,record:i,silent:!0,useOriginalData:r})}):o&&(n=i[t],a=c.parseRecordValue({record:i,field:l.getField(t),value:a}),Neo.isEqual(n,a)||(c.setRecordData({fieldName:t,model:l,record:i,useOriginalData:r,value:a}),h||r||(i[s]=!0),e.push({name:t,oldValue:n,value:a})))}),d=Object.keys(e).length>0,d&&u.forEach((t,s)=>{n=i[s],t=c.parseRecordValue({record:i,field:l.getField(s),useOriginalData:r}),Neo.isEqual(n,t)||(c.setRecordData({fieldName:s,model:l,record:i,useOriginalData:r,value:t}),e.push({name:s,oldValue:n,value:t}))}),a||r||!d||c.onRecordChange({fields:e,model:l,record:i}))}});export default r;