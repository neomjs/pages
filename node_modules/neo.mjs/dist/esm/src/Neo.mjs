import e from"./DefaultConfig.mjs";const t=/-./g,r=Symbol.for("configSymbol"),s=Symbol("getSetCache"),n={function:e=>{if(e.prototype?.constructor.isClass)return"NeoClass"},object:e=>{if(e.constructor.isClass&&e instanceof o.core.Base)return"NeoInstance"}};let o=globalThis.Neo||{};o=globalThis.Neo=Object.assign({ntypeMap:{},insideWorker:"undefined"!=typeof DedicatedWorkerGlobalScope||"undefined"!=typeof WorkerGlobalScope,applyFromNs(e,t,r,s){let n;return e&&"Object"===o.typeOf(r)&&Object.entries(r).forEach(([r,o])=>{n=t[o],e[r]=s?n.bind(t):n}),e},applyToGlobalNs(e){let t="function"==typeof e?e.prototype:e,r=(t.isClass?t.config.className:t.className).split("."),s=r.pop();o.ns(r,!0)[s]=e},assignDefaults:(e,t)=>(e&&"Object"===o.typeOf(t)&&Object.entries(t).forEach(([t,r])=>{Object.hasOwn(e,t)||(e[t]=r)}),e),assignToNs(e,t,r=globalThis,s=!0){let n;(e=Array.isArray(e)?e:e.split(".")).length>1?(n=e.pop(),r=o.ns(e,!0,r)):n=e,(s||void 0===r[n])&&(r[n]=t)},camel:e=>e.replace(t,e=>e[1].toUpperCase()),capitalize:e=>e[0].toUpperCase()+e.slice(1),clone(e,t=!1,r=!1){let s;return{Array:()=>t?[...e.map(e=>o.clone(e,t,r))]:[...e],Date:()=>new Date(e.valueOf()),Map:()=>new Map(e),NeoInstance:()=>r?e:this.cloneNeoInstance(e),Set:()=>new Set(e),Object:()=>(s={},Object.entries(e).forEach(([e,n])=>{s[e]=t?o.clone(n,t,r):n}),s)}[o.typeOf(e)]?.()||e},cloneNeoInstance(e){let t={...e.originalConfig};return delete t._id,delete t.id,o.create(e.className,t)},create(e,t){let r,s,n=o.typeOf(e);if("NeoClass"===n)r=e;else{if("Object"===n){if(!(t=e).className&&!t.module)return console.error("Class created with object configuration missing className or module property",t),null;e=t.className||t.module.prototype.className}if(!p(e))throw new Error("Class "+e+" does not exist");r=o.ns(e)}return s=new r,s.construct(t),s.onConstructed(),s.onAfterConstructed(),s.init(),s},emptyFn(){},hasPropertySetter(e,t){let r;for(;e.__proto__;){if(r=Object.getOwnPropertyDescriptor(e,t),"object"==typeof r&&"function"==typeof r.set)return!0;e=e.__proto__}return!1},merge(e,t,r){if(r)return o.merge(o.merge(e,r),t);for(const r in t){const s=t[r];"Object"===o.typeOf(s)?e[r]=o.merge(e[r]||{},s):e[r]=s}return e},ns:(e,t=!1,r)=>(e=Array.isArray(e)?e:e.split(".")).reduce((e,r)=>{if(t&&!e[r]&&(e[r]={}),e)return e[r]},r||globalThis),nsWithArrays:(e,t=!1,r)=>(e=Array.isArray(e)?e:e.split(".")).reduce((e,r)=>{if(t&&!e[r]){if(r.endsWith("]"))return c(!0,r,e);e[r]={}}if(e)return r.endsWith("]")?c(!1,r,e):e[r]},r||globalThis),ntype(e,t){if("object"==typeof e){if(!(t=e).ntype)throw new Error("Class defined with object configuration missing ntype property. "+t.ntype);e=t.ntype}let r=o.ntypeMap[e];if(!r)throw new Error("ntype "+e+" does not exist");return o.create(r,t)},setupClass(e){let t,n,a,i,l,c=null,y=[],{ntypeMap:m}=o,d=e.prototype||e,b=o.ns(d.constructor.config.className,!1),h=[];if(b)return b;for(;d.__proto__;){if(a=d.constructor,Object.hasOwn(a,"classConfigApplied")){c=o.clone(a.config,!0),y=[...a.ntypeChain];break}h.unshift(d),d=d.__proto__}return n=c||{},h.forEach(i=>{let c;if(a=i.constructor,t=a.config||{},o.overwrites&&a.applyOverwrites?.(t),Object.entries(t).forEach(([e,n])=>{"_"===e.slice(-1)?(delete t[e],e=e.slice(0,-1),t[e]=n,function(e,t){if(o.hasPropertySetter(e,t))throw"Config "+t+"_ ("+e.className+") already has a set method, use beforeGet, beforeSet & afterSet instead";o[s]||(o[s]={});o[s][t]||(o[s][t]={get(){let e=this,s=`beforeGet${t[0].toUpperCase()+t.slice(1)}`,n=Object.hasOwn(e[r],t),o=e[r][t],a=n?o:e["_"+t];return Array.isArray(a)?"items"!==t&&(a=[...a]):a instanceof Date&&(a=new Date(a.valueOf())),n&&(e[t]=a,a=e["_"+t],delete e[r][t]),"function"==typeof e[s]&&(a=e[s](a)),a},set(e){if(void 0===e)return;let s=this,n="_"+t,a=t[0].toUpperCase()+t.slice(1),i="beforeSet"+a,l="afterSet"+a,c=s[n];if(delete s[r][t],"items"!==t&&"vnode"!==t&&(e=o.clone(e,!0,!0)),s[n]=e,"function"==typeof s[i]){if(void 0===(e=s[i](e,c)))return void(s[n]=c);s[n]=e}("vnode"===t&&e!==c||!o.isEqual(e,c))&&(s[l]?.(e,c),s.afterSetConfig?.(t,e,c))}});Object.defineProperty(e,t,o[s][t])}(i,e)):o.hasPropertySetter(i,e)||Object.defineProperty(i,e,{enumerable:!0,value:n,writable:!0})}),Object.hasOwn(t,"ntype")){if(l=t.ntype,y.unshift(l),Object.hasOwn(m,l)&&t.className!==m[l])throw new Error(`ntype conflict for '${l}' inside the classes:\n${m[l]}\n${t.className}`);m[l]=t.className}c=Object.hasOwn(n,"mixins")&&n.mixins||[],a.observable&&c.push("Neo.core.Observable"),Object.hasOwn(t,"mixins")&&Array.isArray(t.mixins)&&t.mixins.length>0&&c.push(...t.mixins),c.length>0&&(!function(e,t){Array.isArray(t)||(t=[t]);let r,s,n,a=0,i=t.length,l={};for(;a<i;a++){if(r=t[a],r.isClass)n=r.prototype,s=o.ns(n.className);else{if(!p(r))throw new Error("Attempting to mixin an undefined class: "+r+", "+e.prototype.className);s=o.ns(r),n=s.prototype}n.className.split(".").reduce(u(s),l),Object.getOwnPropertyNames(n).forEach(f(e.prototype,n))}e.prototype.mixins=l}(a,c),o.ns("Neo.core.Observable",!1,a.prototype.mixins)&&(a.observable=!0)),delete t.mixins,delete n.mixins,Object.assign(n,t),Object.assign(a,{classConfigApplied:!0,config:o.clone(n,!0),isClass:!0,ntypeChain:y}),!n.singleton&&this.applyToGlobalNs(e)}),d=e.prototype||e,y.forEach(e=>{d[`is${o.capitalize(o.camel(e))}`]=!0}),d.singleton&&(e=o.create(e),o.applyToGlobalNs(e)),i={className:d.className,module:e,ntype:Object.hasOwn(d,"ntype")?d.ntype:null,parentClassName:d.__proto__?.className||null},o.manager?.ClassHierarchy?o.manager.ClassHierarchy.add(i):(o.classHierarchyMap??={},o.classHierarchyMap[d.className]=i),e},typeOf:e=>null==e?null:n[typeof e]?.(e)||e.constructor.name},o);const a=["_name","classConfigApplied","className","constructor","isClass","mixin","ntype","observable"],i=/\d+/g,l=/^(\w+)\s*((?:\[\s*\d+\s*\]\s*)*)$/;function c(e,t,r){let s,n,o=(p=t,(l.exec(p)||[null]).slice(1).reduce((e,t)=>[e].concat(t.match(i)))),a=1,c=o.length;var p;if(e?r[o[0]]=n=r[o[0]]||[]:n=r[o[0]],n){for(;a<c;a++)s=parseInt(o[a]),e&&(n[s]=n[s]||{}),n=n[s];return n}}function p(e){try{return!!e.split(".").reduce((e,t)=>e[t],globalThis)}catch(e){return!1}}function f(e,t){return function(r){if(!~a.indexOf(r)){if(e[r]?._from){if(t.className===e[r]._from)return void console.warn("Mixin set multiple times or already defined on a Base Class",e.className,t.className,r);throw new Error(`${e.className}: Multiple mixins defining same property (${t.className}, ${e[r]._from}) => ${r}`)}e[r]=t[r],Object.getOwnPropertyDescriptor(e,r)._from=t.className,"function"==typeof e[r]&&(e[r]._name=r)}}}function u(e){return(t,r,s,n)=>t[r]=s!==n.length-1?t[r]||{}:e}o.config=o.config||{},o.assignDefaults(o.config,e);export default o;