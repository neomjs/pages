import e from"./DefaultConfig.mjs";import{isDescriptor as t}from"./core/ConfigSymbols.mjs";const r=/-./g,n=Symbol.for("configSymbol"),s=Symbol("getSetCache"),o={Array:(e,t,r)=>t?[...e.map(e=>a.clone(e,t,r))]:[...e],Date:e=>new Date(e.valueOf()),Map:e=>new Map(e),NeoInstance:(e,t)=>t?e:a.cloneNeoInstance(e),Set:e=>new Set(e),Object(e,t,r){const n={};return Reflect.ownKeys(e).forEach(s=>{const o=e[s];n[s]=t?a.clone(o,t,r):o}),n}},i={function:e=>{if(e.prototype?.constructor?.isClass)return"NeoClass"},object:e=>{if(e.constructor?.isClass&&e instanceof a.core.Base)return"NeoInstance"}};let a=globalThis.Neo||{};a=globalThis.Neo=Object.assign({ntypeMap:{},insideWorker:"undefined"!=typeof DedicatedWorkerGlobalScope||"undefined"!=typeof WorkerGlobalScope,applyFromNs(e,t,r,n){let s;return e&&"Object"===a.typeOf(r)&&Object.entries(r).forEach(([r,o])=>{s=t[o],e[r]=n?s.bind(t):s}),e},applyToGlobalNs(e){let t="function"==typeof e?e.prototype:e,r=(t.isClass?t.config.className:t.className).split("."),n=r.pop();a.ns(r,!0)[n]=e},assignDefaults:(e,t)=>(e&&"Object"===a.typeOf(t)&&Object.entries(t).forEach(([t,r])=>{Object.hasOwn(e,t)||(e[t]=r)}),e),assignToNs(e,t,r=globalThis,n=!0){let s;(e=Array.isArray(e)?e:e.split(".")).length>1?(s=e.pop(),r=a.ns(e,!0,r)):s=e,(n||void 0===r[s])&&(r[s]=t)},camel:e=>e.replace(r,e=>e[1].toUpperCase()),capitalize:e=>e[0].toUpperCase()+e.slice(1),clone:(e,t=!1,r=!1)=>o[a.typeOf(e)]?.(e,t,r)||e,cloneNeoInstance(e){let t={...e.originalConfig};return delete t._id,delete t.id,a.create(e.className,t)},create(e,t){let r,n,s=a.typeOf(e);if("NeoClass"===s)r=e;else{if("Object"===s){if(!(t=e).className&&!t.module)return console.error("Class created with object configuration missing className or module property",t),null;e=t.className||t.module.prototype.className}if(!u(e))throw new Error("Class "+e+" does not exist");r=a.ns(e)}return n=new r,n.construct(t),n.onConstructed(),n.onAfterConstructed(),n.init(),n},createConfig(e,t,r){if(a.hasPropertySetter(e,t))throw`Invalid config in ${e.className}: '${t}_'. The config '${t}' is already defined as reactive by a parent class.\nTo override the default value, use '${t}' (without the underscore) in your static config.\nIf you intended to create custom logic, use the 'beforeGet${a.capitalize(t)}()', 'beforeSet${a.capitalize(t)}()',and 'afterSet${a.capitalize(t)}()' hooks instead of redefining the config.`;const o="_"+t,i=t[0].toUpperCase()+t.slice(1),c="beforeGet"+i,l="beforeSet"+i,f="afterSet"+i;a[s]??={},a[s][t]||(a[s][t]={get(){let e=this,r=e.getConfig(t),s=Object.hasOwn(e[n],t),i=e[n][t],l=s?i:e[o];if(l instanceof Date)l=new Date(l.valueOf());else if(r.cloneOnGet){const{cloneOnGet:e}=r;if("deep"===e)l=a.clone(l,!0,!0);else if("shallow"===e){const e=a.typeOf(l);"Array"===e?l=[...l]:"Object"===e&&(l={...l})}}else Array.isArray(l)&&(l=[...l]);return s&&(e[t]=l,l=e[o],delete e[n][t]),"function"==typeof e[c]&&(l=e[c](l)),l},set(e){if(void 0===e)return;const r=this.getConfig(t);if(!r)return;let s=this,i=r.get(),{EffectManager:c}=a.core,p=!c?.isPaused();p&&c?.pause();try{switch(delete s[n][t],r.clone){case"deep":e=a.clone(e,!0,!0);break;case"shallow":e=a.clone(e,!1,!0)}if(s[o]=e,"function"==typeof s[l]&&void 0===(e=s[l](e,i)))return void(s[o]=i);s[o]=i,r.set(e)&&(s[f]?.(e,i),s.afterSetConfig?.(t,e,i))}finally{p&&c?.resume()}}},a[s][o]={get(){return this.getConfig(t)?.get()},set(e){this.getConfig(t)?.setRaw(e)}}),Object.defineProperty(e,t,a[s][t]),Object.defineProperty(e,o,a[s][o]),void 0!==r&&(e[t]=r)},emptyFn(){},gatekeep(e,t,r){const n=a.ns(t,!1);if(n)return n;const s=t.split("."),o=s.pop(),i=a.ns(s,!0);return i[o]=e,r?.(e),i[o]},hasPropertySetter(e,t){let r;for(;e.__proto__;){if(r=Object.getOwnPropertyDescriptor(e,t),"object"==typeof r&&"function"==typeof r.set)return!0;e=e.__proto__}return!1},merge(e,t,r){if(r)return a.merge(a.merge(e,r),t);if(!e)return t;for(const r in t){const n=t[r];"Object"===a.typeOf(n)?e[r]=a.merge(e[r]||{},n):e[r]=n}return e},mergeDeepArrays(e,t){if(!e)return t;if(!t)return e;if(Array.isArray(e)&&Array.isArray(t)){const r=new Map,n=a.clone(e,!0,!0),s=e=>e&&"object"==typeof e?e.id??e.name??null:null;return n.forEach((e,t)=>{const n=s(e);null!==n&&r.set(n,t)}),t.forEach(e=>{const t=s(e),o=null!==t?r.get(t):-1;if(void 0!==o&&o>-1)n[o]=a.mergeDeepArrays(n[o],e);else{-1===n.findIndex(t=>a.isEqual(t,e))&&n.push(a.clone(e,!0,!0))}}),n}let r=a.clone(e,!0);return Object.entries(t).forEach(([e,t])=>{r[e]&&(Array.isArray(r[e])&&Array.isArray(t)||a.isObject(r[e])&&a.isObject(t))?r[e]=a.mergeDeepArrays(r[e],t):r[e]=t}),r},mergeConfig(e,t,r){const n=a.typeOf(e),s=a.typeOf(t);if("shallow"===r){if("Object"===n&&"Object"===s)return{...e,...t}}else if("deep"===r){if("Object"===n&&"Object"===s)return a.merge(a.clone(e,!0),t)}else if("deepArrays"===r){if("Object"===n&&"Object"===s)return a.mergeDeepArrays(e,t);if("Array"===n&&"Array"===s)return a.mergeDeepArrays(e,t)}else if("function"==typeof r)return r(e,t);return t},ns:(e,t=!1,r)=>(e=Array.isArray(e)?e:e.split(".")).reduce((e,r)=>{if(t&&!e[r]&&(e[r]={}),e)return e[r]},r||globalThis),nsWithArrays:(e,t=!1,r)=>(e=Array.isArray(e)?e:e.split(".")).reduce((e,r)=>{if(t&&!e[r]){if(r.endsWith("]"))return p(!0,r,e);e[r]={}}if(e)return r.endsWith("]")?p(!1,r,e):e[r]},r||globalThis),ntype(e,t){if("object"==typeof e){if(!(t=e).ntype)throw new Error("Class defined with object configuration missing ntype property. "+t.ntype);e=t.ntype}let r=a.ntypeMap[e];if(!r)throw new Error("ntype "+e+" does not exist");return a.create(r,t)},setupClass(e){let r,n,s,o,i,c,l=null,f=null,p=[],{ntypeMap:m}=a,d=e.prototype||e,b=a.ns(d.constructor.config.className,!1),h=[];if(b)return b;for(;d.__proto__;){if(o=d.constructor,Object.hasOwn(o,"classConfigApplied")){l=a.clone(o.config,!0),f=a.clone(o.configDescriptors,!0),p=[...o.ntypeChain];break}h.unshift(d),d=d.__proto__}return n=l||{},s=f||{},h.forEach(i=>{let l,f={};if(o=i.constructor,r=o.config?a.clone(o.config,!0):{},a.overwrites&&o.applyOverwrites?.(r),Object.entries(r).forEach(([e,n])=>{const s="_"===e.slice(-1),o=s?e.slice(0,-1):e;a.isObject(n)&&!0===n[t]&&(f[o]=a.clone(n,!0),n=n.value,s||(r[e]=n)),s?(delete r[e],r[o]=n,a.createConfig(i,o)):a.hasPropertySetter(i,e)||Object.defineProperty(i,e,{enumerable:!0,value:n,writable:!0})}),Object.keys(f).length>0)for(const e in f)Object.hasOwn(s,e)?Object.assign(s[e],f[e]):s[e]=f[e];if(Object.hasOwn(r,"ntype")){if(c=r.ntype,p.unshift(c),Object.hasOwn(m,c)&&r.className!==m[c])throw new Error(`ntype conflict for '${c}' inside the classes:\n${m[c]}\n${r.className}`);m[c]=r.className}l=Object.hasOwn(n,"mixins")&&n.mixins||[],o.observable&&l.push("Neo.core.Observable"),Object.hasOwn(r,"mixins")&&Array.isArray(r.mixins)&&r.mixins.length>0&&l.push(...r.mixins),l.length>0&&(!function(e,t,r){Array.isArray(t)||(t=[t]);let n,s,o,i=0,c=t.length,l={};for(;i<c;i++){if(n=t[i],n.isClass)o=n.prototype,s=a.ns(o.className);else{if(!u(n))throw new Error("Attempting to mixin an undefined class: "+n+", "+e.prototype.className);s=a.ns(n),o=s.prototype}o.className.split(".").reduce(g(s),l),Object.entries(Object.getOwnPropertyDescriptors(o)).forEach(y(e.prototype,o,r))}e.prototype.mixins=l}(o,l,r),a.ns("Neo.core.Observable",!1,o.prototype.mixins)&&(o.observable=!0)),delete r.mixins,delete n.mixins,Object.entries(r).forEach(([e,t])=>{const r=s[e];n[e]=r?.merge?a.mergeConfig(n[e],t,r.merge):t}),Object.assign(o,{classConfigApplied:!0,config:a.clone(n,!0),configDescriptors:a.clone(s,!0),isClass:!0,ntypeChain:p}),!n.singleton&&this.applyToGlobalNs(e)}),d=e.prototype||e,p.forEach(e=>{d[`is${a.capitalize(a.camel(e))}`]=!0}),d.singleton&&(e=a.create(e),a.applyToGlobalNs(e)),i={className:d.className,module:e,ntype:Object.hasOwn(d,"ntype")?d.ntype:null,parentClassName:d.__proto__?.className||null},a.manager?.ClassHierarchy?a.manager.ClassHierarchy.add(i):(a.classHierarchyMap??={},a.classHierarchyMap[d.className]=i),e},typeOf:e=>null==e?null:i[typeof e]?.(e)||e.constructor?.name},a);const c=["_name","classConfigApplied","className","constructor","id","isClass","mixin","ntype","observable","toJSON"],l=/\d+/g,f=/^(\w+)\s*((?:\[\s*\d+\s*\]\s*)*)$/;function p(e,t,r){let n,s,o=(c=t,(f.exec(c)||[null]).slice(1).reduce((e,t)=>[e].concat(t.match(l)))),i=1,a=o.length;var c;if(e?r[o[0]]=s=r[o[0]]||[]:s=r[o[0]],s){for(;i<a;i++)n=parseInt(o[i]),e&&(s[n]=s[n]||{}),s=s[n];return s}}function u(e){try{return!!e.split(".").reduce((e,t)=>e[t],globalThis)}catch(e){return!1}}function y(e,t,r){return function([n,s]){if(!c.includes(n)&&!a.hasPropertySetter(e,n)){if(s.get&&s.set){a.createConfig(e,n);const s=t.constructor.config;return void(Object.hasOwn(s,n)&&(r[n]=s[n]))}if(e[n]?._from){if(t.className===e[n]._from)return void console.warn("Mixin set multiple times or already defined on a Base Class",e.className,t.className,n);throw new Error(`${e.className}: Multiple mixins defining same property (${t.className}, ${e[n]._from}) => ${n}`)}e[n]=t[n],Object.getOwnPropertyDescriptor(e,n)._from=t.className,"function"==typeof e[n]&&(e[n]._name=n)}}}function g(e){return(t,r,n,s)=>t[r]=n!==s.length-1?t[r]||{}:e}a.config??={},a.assignDefaults(a.config,e);export default a;