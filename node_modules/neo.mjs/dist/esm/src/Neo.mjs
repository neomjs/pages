import e from"./DefaultConfig.mjs";import{isDescriptor as t}from"./core/ConfigSymbols.mjs";const r=/-./g,s=Symbol.for("configSymbol"),n=Symbol("getSetCache"),o={Array:(e,t,r)=>t?[...e.map(e=>a.clone(e,t,r))]:[...e],Date:e=>new Date(e.valueOf()),Map:e=>new Map(e),NeoInstance:(e,t)=>t?e:a.cloneNeoInstance(e),Set:e=>new Set(e),Object(e,t,r){const s={};return Reflect.ownKeys(e).forEach(n=>{const o=e[n];s[n]=t?a.clone(o,t,r):o}),s}},i={function:e=>{if(e.prototype?.constructor?.isClass)return"NeoClass"},object:e=>{if(e.constructor?.isClass&&e instanceof a.core.Base)return"NeoInstance"}};let a=globalThis.Neo||{};a=globalThis.Neo=Object.assign({ntypeMap:{},insideWorker:"undefined"!=typeof DedicatedWorkerGlobalScope||"undefined"!=typeof WorkerGlobalScope,applyFromNs(e,t,r,s){let n;return e&&"Object"===a.typeOf(r)&&Object.entries(r).forEach(([r,o])=>{n=t[o],e[r]=s?n.bind(t):n}),e},applyToGlobalNs(e){let t="function"==typeof e?e.prototype:e,r=(t.isClass?t.config.className:t.className).split("."),s=r.pop();a.ns(r,!0)[s]=e},assignDefaults:(e,t)=>(e&&"Object"===a.typeOf(t)&&Object.entries(t).forEach(([t,r])=>{Object.hasOwn(e,t)||(e[t]=r)}),e),assignToNs(e,t,r=globalThis,s=!0){let n;(e=Array.isArray(e)?e:e.split(".")).length>1?(n=e.pop(),r=a.ns(e,!0,r)):n=e,(s||void 0===r[n])&&(r[n]=t)},camel:e=>e.replace(r,e=>e[1].toUpperCase()),capitalize:e=>e[0].toUpperCase()+e.slice(1),clone:(e,t=!1,r=!1)=>o[a.typeOf(e)]?.(e,t,r)||e,cloneNeoInstance(e){let t={...e.originalConfig};return delete t._id,delete t.id,a.create(e.className,t)},create(e,t){let r,s,n=a.typeOf(e);if("NeoClass"===n)r=e;else{if("Object"===n){if(!(t=e).className&&!t.module)return console.error("Class created with object configuration missing className or module property",t),null;e=t.className||t.module.prototype.className}if(!y(e))throw new Error("Class "+e+" does not exist");r=a.ns(e)}return s=new r,s.construct(t),s.onConstructed(),s.onAfterConstructed(),s.init(),s},emptyFn(){},hasPropertySetter(e,t){let r;for(;e.__proto__;){if(r=Object.getOwnPropertyDescriptor(e,t),"object"==typeof r&&"function"==typeof r.set)return!0;e=e.__proto__}return!1},merge(e,t,r){if(r)return a.merge(a.merge(e,r),t);if(!e)return t;for(const r in t){const s=t[r];"Object"===a.typeOf(s)?e[r]=a.merge(e[r]||{},s):e[r]=s}return e},mergeConfig(e,t,r){const s=a.typeOf(e),n=a.typeOf(t);if("shallow"===r){if("Object"===s&&"Object"===n)return{...e,...t}}else if("deep"===r){if("Object"===s&&"Object"===n)return a.merge(a.clone(e,!0),t)}else if("function"==typeof r)return r(e,t);return t},ns:(e,t=!1,r)=>(e=Array.isArray(e)?e:e.split(".")).reduce((e,r)=>{if(t&&!e[r]&&(e[r]={}),e)return e[r]},r||globalThis),nsWithArrays:(e,t=!1,r)=>(e=Array.isArray(e)?e:e.split(".")).reduce((e,r)=>{if(t&&!e[r]){if(r.endsWith("]"))return u(!0,r,e);e[r]={}}if(e)return r.endsWith("]")?u(!1,r,e):e[r]},r||globalThis),ntype(e,t){if("object"==typeof e){if(!(t=e).ntype)throw new Error("Class defined with object configuration missing ntype property. "+t.ntype);e=t.ntype}let r=a.ntypeMap[e];if(!r)throw new Error("ntype "+e+" does not exist");return a.create(r,t)},setupClass(e){let r,s,n,o,i,c,l=null,f=null,u=[],{ntypeMap:h}=a,b=e.prototype||e,d=a.ns(b.constructor.config.className,!1),O=[];if(d)return d;for(;b.__proto__;){if(o=b.constructor,Object.hasOwn(o,"classConfigApplied")){l=a.clone(o.config,!0),f=a.clone(o.configDescriptors,!0),u=[...o.ntypeChain];break}O.unshift(b),b=b.__proto__}return s=l||{},n=f||{},O.forEach(i=>{let l;if(o=i.constructor,r=o.config||{},a.overwrites&&o.applyOverwrites?.(r),Object.entries(r).forEach(([e,s])=>{const n="_"===e.slice(-1),c=n?e.slice(0,-1):e;a.isObject(s)&&!0===s[t]&&(o.configDescriptors??={},o.configDescriptors[c]=a.clone(s,!0),s=s.value),n?(delete r[e],r[c]=s,p(i,c)):a.hasPropertySetter(i,e)||Object.defineProperty(i,e,{enumerable:!0,value:s,writable:!0})}),o.configDescriptors)for(const e in o.configDescriptors)Object.hasOwn(n,e)||(n[e]=a.clone(o.configDescriptors[e],!0));if(Object.hasOwn(r,"ntype")){if(c=r.ntype,u.unshift(c),Object.hasOwn(h,c)&&r.className!==h[c])throw new Error(`ntype conflict for '${c}' inside the classes:\n${h[c]}\n${r.className}`);h[c]=r.className}l=Object.hasOwn(s,"mixins")&&s.mixins||[],o.observable&&l.push("Neo.core.Observable"),Object.hasOwn(r,"mixins")&&Array.isArray(r.mixins)&&r.mixins.length>0&&l.push(...r.mixins),l.length>0&&(!function(e,t,r){Array.isArray(t)||(t=[t]);let s,n,o,i=0,c=t.length,l={};for(;i<c;i++){if(s=t[i],s.isClass)o=s.prototype,n=a.ns(o.className);else{if(!y(s))throw new Error("Attempting to mixin an undefined class: "+s+", "+e.prototype.className);n=a.ns(s),o=n.prototype}o.className.split(".").reduce(g(n),l),Object.entries(Object.getOwnPropertyDescriptors(o)).forEach(m(e.prototype,o,r))}e.prototype.mixins=l}(o,l,r),a.ns("Neo.core.Observable",!1,o.prototype.mixins)&&(o.observable=!0)),delete r.mixins,delete s.mixins,Object.entries(r).forEach(([e,t])=>{const r=n[e];s[e]=r?.merge?a.mergeConfig(s[e],t,r.merge):t}),Object.assign(o,{classConfigApplied:!0,config:a.clone(s,!0),configDescriptors:a.clone(n,!0),isClass:!0,ntypeChain:u}),!s.singleton&&this.applyToGlobalNs(e)}),b=e.prototype||e,u.forEach(e=>{b[`is${a.capitalize(a.camel(e))}`]=!0}),b.singleton&&(e=a.create(e),a.applyToGlobalNs(e)),i={className:b.className,module:e,ntype:Object.hasOwn(b,"ntype")?b.ntype:null,parentClassName:b.__proto__?.className||null},a.manager?.ClassHierarchy?a.manager.ClassHierarchy.add(i):(a.classHierarchyMap??={},a.classHierarchyMap[b.className]=i),e},typeOf:e=>null==e?null:i[typeof e]?.(e)||e.constructor?.name},a);const c=["_name","classConfigApplied","className","constructor","id","isClass","mixin","ntype","observable"],l=/\d+/g,f=/^(\w+)\s*((?:\[\s*\d+\s*\]\s*)*)$/;function p(e,t){if(a.hasPropertySetter(e,t))throw"Config "+t+"_ ("+e.className+") already has a set method, use beforeGet, beforeSet & afterSet instead";const r="_"+t,o=t[0].toUpperCase()+t.slice(1),i="beforeGet"+o,c="beforeSet"+o,l="afterSet"+o;a[n]||(a[n]={}),a[n][t]||(a[n][t]={get(){let e=this,n=e.getConfig(t),o=Object.hasOwn(e[s],t),c=e[s][t],l=o?c:e[r];if(l instanceof Date)l=new Date(l.valueOf());else if(n.cloneOnGet){const{cloneOnGet:e}=n;if("deep"===e)l=a.clone(l,!0,!0);else if("shallow"===e){const e=a.typeOf(l);"Array"===e?l=[...l]:"Object"===e&&(l={...l})}}else Array.isArray(l)&&(l=[...l]);return o&&(e[t]=l,l=e[r],delete e[s][t]),"function"==typeof e[i]&&(l=e[i](l)),l},set(e){if(void 0===e)return;const n=this.getConfig(t);if(!n)return;let o=this,i=n.get(),{EffectBatchManager:f}=a.core,p=!f?.isBatchActive();switch(p&&f?.startBatch(),delete o[s][t],n.clone){case"deep":e=a.clone(e,!0,!0);break;case"shallow":e=a.clone(e,!1,!0)}if(o[r]=e,"function"==typeof o[c]&&void 0===(e=o[c](e,i)))return o[r]=i,void(p&&f?.endBatch());o[r]=i,n.set(e)&&(o[l]?.(e,i),o.afterSetConfig?.(t,e,i)),p&&f?.endBatch()}},a[n][r]={get(){return this.getConfig(t)?.get()},set(e){this.getConfig(t)?.setRaw(e)}}),Object.defineProperty(e,t,a[n][t]),Object.defineProperty(e,r,a[n][r])}function u(e,t,r){let s,n,o=(c=t,(f.exec(c)||[null]).slice(1).reduce((e,t)=>[e].concat(t.match(l)))),i=1,a=o.length;var c;if(e?r[o[0]]=n=r[o[0]]||[]:n=r[o[0]],n){for(;i<a;i++)s=parseInt(o[i]),e&&(n[s]=n[s]||{}),n=n[s];return n}}function y(e){try{return!!e.split(".").reduce((e,t)=>e[t],globalThis)}catch(e){return!1}}function m(e,t,r){return function([s,n]){if(!c.includes(s)&&!a.hasPropertySetter(e,s)){if(n.get&&n.set){p(e,s);const n=t.constructor.config;return void(Object.hasOwn(n,s)&&(r[s]=n[s]))}if(e[s]?._from){if(t.className===e[s]._from)return void console.warn("Mixin set multiple times or already defined on a Base Class",e.className,t.className,s);throw new Error(`${e.className}: Multiple mixins defining same property (${t.className}, ${e[s]._from}) => ${s}`)}e[s]=t[s],Object.getOwnPropertyDescriptor(e,s)._from=t.className,"function"==typeof e[s]&&(e[s]._name=s)}}}function g(e){return(t,r,s,n)=>t[r]=s!==n.length-1?t[r]||{}:e}a.config??={},a.assignDefaults(a.config,e);export default a;