import e from"./DefaultConfig.mjs";const t=/-./g,r=Symbol.for("configSymbol"),s=Symbol("getSetCache"),n={function:e=>{if(e.prototype?.constructor.isClass)return"NeoClass"},object:e=>{if(e.constructor.isClass&&e instanceof o.core.Base)return"NeoInstance"}};let o=globalThis.Neo||{};o=globalThis.Neo=Object.assign({ntypeMap:{},insideWorker:"undefined"!=typeof DedicatedWorkerGlobalScope||"undefined"!=typeof WorkerGlobalScope,applyFromNs(e,t,r,s){let n;return e&&"Object"===o.typeOf(r)&&Object.entries(r).forEach((([r,o])=>{n=t[o],e[r]=s?n.bind(t):n})),e},applyToGlobalNs(e){let t="function"==typeof e?e.prototype:e,r=(t.isClass?t.config.className:t.className).split("."),s=r.pop();o.ns(r,!0)[s]=e},assignDefaults:(e,t)=>(e&&"Object"===o.typeOf(t)&&Object.entries(t).forEach((([t,r])=>{Object.hasOwn(e,t)||(e[t]=r)})),e),assignToNs(e,t,r=globalThis,s=!0){let n;(e=Array.isArray(e)?e:e.split(".")).length>1?(n=e.pop(),r=o.ns(e,!0,r)):n=e,(s||void 0===r[n])&&(r[n]=t)},camel:e=>e.replace(t,(e=>e[1].toUpperCase())),capitalize:e=>e[0].toUpperCase()+e.slice(1),clone(e,t=!1,r=!1){let s;return{Array:()=>t?[...e.map((e=>o.clone(e,t,r)))]:[...e],Date:()=>new Date(e.valueOf()),Map:()=>new Map(e),NeoInstance:()=>r?e:this.cloneNeoInstance(e),Set:()=>new Set(e),Object:()=>(s={},Object.entries(e).forEach((([e,n])=>{s[e]=t?o.clone(n,t,r):n})),s)}[o.typeOf(e)]?.()||e},cloneNeoInstance(e){let t={...e.originalConfig};return delete t._id,delete t.id,o.create(e.className,t)},create(e,t){let r,s,n=o.typeOf(e);if("NeoClass"===n)r=e;else{if("Object"===n){if(!(t=e).className&&!t.module)return console.error("Class created with object configuration missing className or module property",t),null;e=t.className||t.module.prototype.className}if(!p(e))throw new Error("Class "+e+" does not exist");r=o.ns(e)}return s=new r,s.construct(t),s.onConstructed(),s.onAfterConstructed(),s.init(),s},emptyFn(){},hasPropertySetter(e,t){let r;for(;e.__proto__;){if(r=Object.getOwnPropertyDescriptor(e,t),"object"==typeof r&&"function"==typeof r.set)return!0;e=e.__proto__}return!1},merge(e,t,r){if(r)return o.merge(o.merge(e,r),t);for(const r in t){const s=t[r];"Object"===o.typeOf(s)?e[r]=o.merge(e[r]||{},s):e[r]=s}return e},ns:(e,t=!1,r)=>(e=Array.isArray(e)?e:e.split(".")).reduce(((e,r)=>{if(t&&!e[r]&&(e[r]={}),e)return e[r]}),r||globalThis),nsWithArrays:(e,t=!1,r)=>(e=Array.isArray(e)?e:e.split(".")).reduce(((e,r)=>{if(t&&!e[r]){if(r.endsWith("]"))return c(!0,r,e);e[r]={}}if(e)return r.endsWith("]")?c(!1,r,e):e[r]}),r||globalThis),ntype(e,t){if("object"==typeof e){if(!(t=e).ntype)throw new Error("Class defined with object configuration missing ntype property. "+t.ntype);e=t.ntype}let r=o.ntypeMap[e];if(!r)throw new Error("ntype "+e+" does not exist");return o.create(r,t)},setupClass(e){let t,n,i,a,l=null,c=[],{ntypeMap:y}=o,m=e.prototype||e,b=o.ns(m.constructor.config.className,!1),d=[];if(b)return b;for(;m.__proto__;){if(i=m.constructor,Object.hasOwn(i,"classConfigApplied")){l=o.clone(i.config,!0),c=[...i.ntypeChain];break}d.unshift(m),m=m.__proto__}return n=l||{},d.forEach((l=>{let m;if(i=l.constructor,t=i.config||{},o.overwrites&&i.applyOverwrites?.(t),Object.entries(t).forEach((([e,n])=>{"_"===e.slice(-1)?(delete t[e],e=e.slice(0,-1),t[e]=n,function(e,t){if(o.hasPropertySetter(e,t))throw"Config "+t+"_ ("+e.className+") already has a set method, use beforeGet, beforeSet & afterSet instead";o[s]||(o[s]={});o[s][t]||(o[s][t]={get(){let e=this,s=`beforeGet${t[0].toUpperCase()+t.slice(1)}`,n=Object.hasOwn(e[r],t),o=e[r][t],i=n?o:e["_"+t];return Array.isArray(i)?"items"!==t&&(i=[...i]):i instanceof Date&&(i=new Date(i.valueOf())),n&&(e[t]=i,i=e["_"+t],delete e[r][t]),"function"==typeof e[s]&&(i=e[s](i)),i},set(e){if(void 0===e)return;let s=this,n="_"+t,i=t[0].toUpperCase()+t.slice(1),a="beforeSet"+i,l="afterSet"+i,c=s[n];if(delete s[r][t],"items"!==t&&"vnode"!==t&&(e=o.clone(e,!0,!0)),s[n]=e,"function"==typeof s[a]){if(void 0===(e=s[a](e,c)))return void(s[n]=c);s[n]=e}("vnode"===t&&e!==c||!o.isEqual(e,c))&&(s[l]?.(e,c),s.afterSetConfig?.(t,e,c))}});Object.defineProperty(e,t,o[s][t])}(l,e)):o.hasPropertySetter(l,e)||Object.defineProperty(l,e,{enumerable:!0,value:n,writable:!0})})),Object.hasOwn(t,"ntype")){if(a=t.ntype,c.unshift(a),Object.hasOwn(y,a)&&t.className!==y[a])throw new Error(`ntype conflict for '${a}' inside the classes:\n${y[a]}\n${t.className}`);y[a]=t.className}m=Object.hasOwn(n,"mixins")&&n.mixins||[],i.observable&&m.push("Neo.core.Observable"),Object.hasOwn(t,"mixins")&&Array.isArray(t.mixins)&&t.mixins.length>0&&m.push(...t.mixins),m.length>0&&(!function(e,t){Array.isArray(t)||(t=[t]);let r,s,n,i=0,a=t.length,l={};for(;i<a;i++){if(r=t[i],r.isClass)n=r.prototype,s=o.ns(n.className);else{if(!p(r))throw new Error("Attempting to mixin an undefined class: "+r+", "+e.prototype.className);s=o.ns(r),n=s.prototype}n.className.split(".").reduce(u(s),l),Object.getOwnPropertyNames(n).forEach(f(e.prototype,n))}e.prototype.mixins=l}(i,m),o.ns("Neo.core.Observable",!1,i.prototype.mixins)&&(i.observable=!0)),delete t.mixins,delete n.mixins,Object.assign(n,t),Object.assign(i,{classConfigApplied:!0,config:o.clone(n,!0),isClass:!0,ntypeChain:c}),!n.singleton&&this.applyToGlobalNs(e)})),m=e.prototype||e,c.forEach((e=>{m[`is${o.capitalize(o.camel(e))}`]=!0})),m.singleton&&(e=o.create(e),o.applyToGlobalNs(e)),e},typeOf:e=>null==e?null:n[typeof e]?.(e)||e.constructor.name},o);const i=["_name","classConfigApplied","className","constructor","isClass","mixin","ntype","observable"],a=/\d+/g,l=/^(\w+)\s*((?:\[\s*\d+\s*\]\s*)*)$/;function c(e,t,r){let s,n,o=(p=t,(l.exec(p)||[null]).slice(1).reduce(((e,t)=>[e].concat(t.match(a))))),i=1,c=o.length;var p;if(e?r[o[0]]=n=r[o[0]]||[]:n=r[o[0]],n){for(;i<c;i++)s=parseInt(o[i]),e&&(n[s]=n[s]||{}),n=n[s];return n}}function p(e){try{return!!e.split(".").reduce(((e,t)=>e[t]),globalThis)}catch(e){return!1}}function f(e,t){return function(r){if(!~i.indexOf(r)){if(e[r]?._from){if(t.className===e[r]._from)return void console.warn("Mixin set multiple times or already defined on a Base Class",e.className,t.className,r);throw new Error(`${e.className}: Multiple mixins defining same property (${t.className}, ${e[r]._from}) => ${r}`)}e[r]=t[r],Object.getOwnPropertyDescriptor(e,r)._from=t.className,"function"==typeof e[r]&&(e[r]._name=r)}}}function u(e){return(t,r,s,n)=>t[r]=s!==n.length-1?t[r]||{}:e}o.config=o.config||{},o.assignDefaults(o.config,e);export default o;