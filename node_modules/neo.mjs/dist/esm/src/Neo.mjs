import e from"./DefaultConfig.mjs";import{isDescriptor as t}from"./core/ConfigSymbols.mjs";const r=/-./g,s=Symbol.for("configSymbol"),n=Symbol("getSetCache"),o={Array:(e,t,r)=>t?[...e.map(e=>a.clone(e,t,r))]:[...e],Date:e=>new Date(e.valueOf()),Map:e=>new Map(e),NeoInstance:(e,t)=>t?e:a.cloneNeoInstance(e),Set:e=>new Set(e),Object(e,t,r){const s={};return Reflect.ownKeys(e).forEach(n=>{const o=e[n];s[n]=t?a.clone(o,t,r):o}),s}},i={function:e=>{if(e.prototype?.constructor?.isClass)return"NeoClass"},object:e=>{if(e.constructor?.isClass&&e instanceof a.core.Base)return"NeoInstance"}};let a=globalThis.Neo||{};a=globalThis.Neo=Object.assign({ntypeMap:{},insideWorker:"undefined"!=typeof DedicatedWorkerGlobalScope||"undefined"!=typeof WorkerGlobalScope,applyFromNs(e,t,r,s){let n;return e&&"Object"===a.typeOf(r)&&Object.entries(r).forEach(([r,o])=>{n=t[o],e[r]=s?n.bind(t):n}),e},applyToGlobalNs(e){let t="function"==typeof e?e.prototype:e,r=(t.isClass?t.config.className:t.className).split("."),s=r.pop();a.ns(r,!0)[s]=e},assignDefaults:(e,t)=>(e&&"Object"===a.typeOf(t)&&Object.entries(t).forEach(([t,r])=>{Object.hasOwn(e,t)||(e[t]=r)}),e),assignToNs(e,t,r=globalThis,s=!0){let n;(e=Array.isArray(e)?e:e.split(".")).length>1?(n=e.pop(),r=a.ns(e,!0,r)):n=e,(s||void 0===r[n])&&(r[n]=t)},camel:e=>e.replace(r,e=>e[1].toUpperCase()),capitalize:e=>e[0].toUpperCase()+e.slice(1),clone:(e,t=!1,r=!1)=>o[a.typeOf(e)]?.(e,t,r)||e,cloneNeoInstance(e){let t={...e.originalConfig};return delete t._id,delete t.id,a.create(e.className,t)},create(e,t){let r,s,n=a.typeOf(e);if("NeoClass"===n)r=e;else{if("Object"===n){if(!(t=e).className&&!t.module)return console.error("Class created with object configuration missing className or module property",t),null;e=t.className||t.module.prototype.className}if(!u(e))throw new Error("Class "+e+" does not exist");r=a.ns(e)}return s=new r,s.construct(t),s.onConstructed(),s.onAfterConstructed(),s.init(),s},createConfig(e,t,r){if(a.hasPropertySetter(e,t))throw`Invalid config in ${e.className}: '${t}_'. The config '${t}' is already defined as reactive by a parent class.\nTo override the default value, use '${t}' (without the underscore) in your static config.\nIf you intended to create custom logic, use the 'beforeGet${a.capitalize(t)}()', 'beforeSet${a.capitalize(t)}()',and 'afterSet${a.capitalize(t)}()' hooks instead of redefining the config.`;const o="_"+t,i=t[0].toUpperCase()+t.slice(1),c="beforeGet"+i,l="beforeSet"+i,f="afterSet"+i;a[n]??={},a[n][t]||(a[n][t]={get(){let e=this,r=e.getConfig(t),n=Object.hasOwn(e[s],t),i=e[s][t],l=n?i:e[o];if(l instanceof Date)l=new Date(l.valueOf());else if(r.cloneOnGet){const{cloneOnGet:e}=r;if("deep"===e)l=a.clone(l,!0,!0);else if("shallow"===e){const e=a.typeOf(l);"Array"===e?l=[...l]:"Object"===e&&(l={...l})}}else Array.isArray(l)&&(l=[...l]);return n&&(e[t]=l,l=e[o],delete e[s][t]),"function"==typeof e[c]&&(l=e[c](l)),l},set(e){if(void 0===e)return;const r=this.getConfig(t);if(!r)return;let n=this,i=r.get(),{EffectManager:c}=a.core,p=!c?.isPaused();p&&c?.pause();try{switch(delete n[s][t],r.clone){case"deep":e=a.clone(e,!0,!0);break;case"shallow":e=a.clone(e,!1,!0)}if(n[o]=e,"function"==typeof n[l]&&void 0===(e=n[l](e,i)))return void(n[o]=i);n[o]=i,r.set(e)&&(n[f]?.(e,i),n.afterSetConfig?.(t,e,i))}finally{p&&c?.resume()}}},a[n][o]={get(){return this.getConfig(t)?.get()},set(e){this.getConfig(t)?.setRaw(e)}}),Object.defineProperty(e,t,a[n][t]),Object.defineProperty(e,o,a[n][o]),void 0!==r&&(e[t]=r)},emptyFn(){},gatekeep(e,t,r){const s=a.ns(t,!1);if(s)return s;const n=t.split("."),o=n.pop(),i=a.ns(n,!0);return i[o]=e,r?.(e),i[o]},hasPropertySetter(e,t){let r;for(;e.__proto__;){if(r=Object.getOwnPropertyDescriptor(e,t),"object"==typeof r&&"function"==typeof r.set)return!0;e=e.__proto__}return!1},merge(e,t,r){if(r)return a.merge(a.merge(e,r),t);if(!e)return t;for(const r in t){const s=t[r];"Object"===a.typeOf(s)?e[r]=a.merge(e[r]||{},s):e[r]=s}return e},mergeConfig(e,t,r){const s=a.typeOf(e),n=a.typeOf(t);if("shallow"===r){if("Object"===s&&"Object"===n)return{...e,...t}}else if("deep"===r){if("Object"===s&&"Object"===n)return a.merge(a.clone(e,!0),t)}else if("function"==typeof r)return r(e,t);return t},ns:(e,t=!1,r)=>(e=Array.isArray(e)?e:e.split(".")).reduce((e,r)=>{if(t&&!e[r]&&(e[r]={}),e)return e[r]},r||globalThis),nsWithArrays:(e,t=!1,r)=>(e=Array.isArray(e)?e:e.split(".")).reduce((e,r)=>{if(t&&!e[r]){if(r.endsWith("]"))return p(!0,r,e);e[r]={}}if(e)return r.endsWith("]")?p(!1,r,e):e[r]},r||globalThis),ntype(e,t){if("object"==typeof e){if(!(t=e).ntype)throw new Error("Class defined with object configuration missing ntype property. "+t.ntype);e=t.ntype}let r=a.ntypeMap[e];if(!r)throw new Error("ntype "+e+" does not exist");return a.create(r,t)},setupClass(e){let r,s,n,o,i,c,l=null,f=null,p=[],{ntypeMap:m}=a,d=e.prototype||e,h=a.ns(d.constructor.config.className,!1),b=[];if(h)return h;for(;d.__proto__;){if(o=d.constructor,Object.hasOwn(o,"classConfigApplied")){l=a.clone(o.config,!0),f=a.clone(o.configDescriptors,!0),p=[...o.ntypeChain];break}b.unshift(d),d=d.__proto__}return s=l||{},n=f||{},b.forEach(i=>{let l;if(o=i.constructor,r=o.config||{},a.overwrites&&o.applyOverwrites?.(r),Object.entries(r).forEach(([e,s])=>{const n="_"===e.slice(-1),c=n?e.slice(0,-1):e;a.isObject(s)&&!0===s[t]&&(o.configDescriptors??={},o.configDescriptors[c]=a.clone(s,!0),s=s.value),n?(delete r[e],r[c]=s,a.createConfig(i,c)):a.hasPropertySetter(i,e)||Object.defineProperty(i,e,{enumerable:!0,value:s,writable:!0})}),o.configDescriptors)for(const e in o.configDescriptors)Object.hasOwn(n,e)||(n[e]=a.clone(o.configDescriptors[e],!0));if(Object.hasOwn(r,"ntype")){if(c=r.ntype,p.unshift(c),Object.hasOwn(m,c)&&r.className!==m[c])throw new Error(`ntype conflict for '${c}' inside the classes:\n${m[c]}\n${r.className}`);m[c]=r.className}l=Object.hasOwn(s,"mixins")&&s.mixins||[],o.observable&&l.push("Neo.core.Observable"),Object.hasOwn(r,"mixins")&&Array.isArray(r.mixins)&&r.mixins.length>0&&l.push(...r.mixins),l.length>0&&(!function(e,t,r){Array.isArray(t)||(t=[t]);let s,n,o,i=0,c=t.length,l={};for(;i<c;i++){if(s=t[i],s.isClass)o=s.prototype,n=a.ns(o.className);else{if(!u(s))throw new Error("Attempting to mixin an undefined class: "+s+", "+e.prototype.className);n=a.ns(s),o=n.prototype}o.className.split(".").reduce(g(n),l),Object.entries(Object.getOwnPropertyDescriptors(o)).forEach(y(e.prototype,o,r))}e.prototype.mixins=l}(o,l,r),a.ns("Neo.core.Observable",!1,o.prototype.mixins)&&(o.observable=!0)),delete r.mixins,delete s.mixins,Object.entries(r).forEach(([e,t])=>{const r=n[e];s[e]=r?.merge?a.mergeConfig(s[e],t,r.merge):t}),Object.assign(o,{classConfigApplied:!0,config:a.clone(s,!0),configDescriptors:a.clone(n,!0),isClass:!0,ntypeChain:p}),!s.singleton&&this.applyToGlobalNs(e)}),d=e.prototype||e,p.forEach(e=>{d[`is${a.capitalize(a.camel(e))}`]=!0}),d.singleton&&(e=a.create(e),a.applyToGlobalNs(e)),i={className:d.className,module:e,ntype:Object.hasOwn(d,"ntype")?d.ntype:null,parentClassName:d.__proto__?.className||null},a.manager?.ClassHierarchy?a.manager.ClassHierarchy.add(i):(a.classHierarchyMap??={},a.classHierarchyMap[d.className]=i),e},typeOf:e=>null==e?null:i[typeof e]?.(e)||e.constructor?.name},a);const c=["_name","classConfigApplied","className","constructor","id","isClass","mixin","ntype","observable"],l=/\d+/g,f=/^(\w+)\s*((?:\[\s*\d+\s*\]\s*)*)$/;function p(e,t,r){let s,n,o=(c=t,(f.exec(c)||[null]).slice(1).reduce((e,t)=>[e].concat(t.match(l)))),i=1,a=o.length;var c;if(e?r[o[0]]=n=r[o[0]]||[]:n=r[o[0]],n){for(;i<a;i++)s=parseInt(o[i]),e&&(n[s]=n[s]||{}),n=n[s];return n}}function u(e){try{return!!e.split(".").reduce((e,t)=>e[t],globalThis)}catch(e){return!1}}function y(e,t,r){return function([s,n]){if(!c.includes(s)&&!a.hasPropertySetter(e,s)){if(n.get&&n.set){a.createConfig(e,s);const n=t.constructor.config;return void(Object.hasOwn(n,s)&&(r[s]=n[s]))}if(e[s]?._from){if(t.className===e[s]._from)return void console.warn("Mixin set multiple times or already defined on a Base Class",e.className,t.className,s);throw new Error(`${e.className}: Multiple mixins defining same property (${t.className}, ${e[s]._from}) => ${s}`)}e[s]=t[s],Object.getOwnPropertyDescriptor(e,s)._from=t.className,"function"==typeof e[s]&&(e[s]._name=s)}}}function g(e){return(t,r,s,n)=>t[r]=s!==n.length-1?t[r]||{}:e}a.config??={},a.assignDefaults(a.config,e);export default a;