import e from"../../component/Abstract.mjs";import t from"../../core/Effect.mjs";import n from"../../util/Array.mjs";const o=Symbol.for("activeDomListeners"),s=Symbol.for("hookIndex"),i=Symbol.for("hooks"),d=Symbol.for("pendingDomEvents"),l=Symbol("vdomToApply");export default Neo.setupClass(class extends e{static config={className:"Neo.functional.component.Base",enableHtmlTemplates_:!1,ntype:"functional-component",vdom:{}};childComponents=null;#e=null;construct(e){super.construct(e);let n=this,c={configurable:!0,enumerable:!1,writable:!0};Object.defineProperties(n,{[o]:{...c,value:[]},[s]:{...c,value:0},[i]:{...c,value:[]},[d]:{...c,value:[]},[l]:{...c,value:null}}),n.vdomEffect=new t({fn:()=>{n[s]=0,n[d]=[],n[l]=n.createVdom(n)},componentId:n.id,subscriber:{id:n.id,fn:n.onEffectRunStateChange,scope:n}})}afterSetMounted(e,t){if(super.afterSetMounted(e,t),void 0!==t){e&&this.applyPendingDomListeners()}}afterSetEnableHtmlTemplates_(e,t){e&&!this.htmlParser&&import("../util/html.mjs").then(e=>{this.htmlParser=e.default})}afterSetWindowId(e,t){super.afterSetWindowId(e,t),this.childComponents?.forEach(t=>{t.instance.windowId=e})}applyPendingDomListeners(){const e=this,t=e[o],n=e[d];n.length>0&&(Neo.isEqual(t,n)||(t?.length>0&&e.removeDomListeners(e[o]),e.addDomListeners([...n]),e[o]=[...n]),e[d]=[])}beforeUpdate(){}createVdom(e){const t=this;return t.enableHtmlTemplates&&"function"==typeof t.createTemplateVdom?t.createTemplateVdom(e):{}}destroy(){const e=this;e.vdomEffect?.destroy(),e.childComponents?.forEach(e=>{e.instance.destroy()}),e.childComponents?.clear(),e[d]=null,super.destroy()}diffAndSet(e,t,n){const o={};for(const s in t){const i=t[s],d=n[s];Neo.isEqual(i,d)||("Object"===Neo.typeOf(i)&&"NeoInstance"===Neo.typeOf(e[s])?this.diffAndSet(e[s],i,d||{}):o[s]=i)}Object.keys(o).length>0&&e.set(o)}onEffectRunStateChange(e,t){if(!1===e){const e=this,t=e[l];if(t){e.#e=new Map;const o=e.processVdomForComponents(t,e.id);e.childComponents?.size>0&&[...e.childComponents].forEach(([t,n])=>{e.#e.has(t)||(e.childComponents.delete(t),n.instance.destroy())});const s=e.childComponents?new Set(e.childComponents.keys()):new Set;let i=!1;for(const t of e.#e.keys())if(!s.has(t)){i=!0;break}i&&(e.updateDepth=-1),e.childComponents=e.#e;for(const t in e.vdom)delete e.vdom[t];Object.assign(e.vdom,o),e[l]=null;const d=e.getVdomRoot();e.cls&&(d.cls=n.union(e.cls,d.cls)),e.id&&(d.id=e.id),e.syncVdomIds(),!1!==e.beforeUpdate()&&e.updateVdom(),e.mounted&&e.applyPendingDomListeners()}}}processVdomForComponents(e,t,n){if(!e)return e;if(e.componentId)return e;const o=this;if(e.className||e.module||e.ntype){const s=e.id;s||console.error(['Component definition in functional component VDOM is missing an "id". For stable reconciliation, ','especially in dynamic lists, provide a unique "id" property.'].join(""),e);let i,d=o.childComponents?.get(s),l={...e};return delete l.className,delete l.id,delete l.module,delete l.ntype,d?(i=d.instance,this.diffAndSet(i,l,d.lastConfig)):(o.childComponents??=new Map,i=Neo[e.className||e.module?"create":"ntype"]({...e,parentId:t,parentIndex:n,windowId:o.windowId})),o.#e.set(s,{instance:i,lastConfig:l}),i.createVdomReference()}return e.cn&&Array.isArray(e.cn)&&(e.cn=e.cn.map((e,n)=>o.processVdomForComponents(e,t,n))),e}});