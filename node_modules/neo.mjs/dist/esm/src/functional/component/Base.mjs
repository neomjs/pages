import e from"../../component/Abstract.mjs";import n from"../../core/Effect.mjs";import o from"../../util/Array.mjs";const t=Symbol.for("activeDomListeners"),s=Symbol.for("hookIndex"),i=Symbol.for("hooks"),d=Symbol.for("pendingDomEvents"),c=Symbol("vdomToApply");export default Neo.setupClass(class extends e{static config={className:"Neo.functional.component.Base",ntype:"functional-component",vdom:{}};childComponents=null;#e=null;construct(e){super.construct(e);let o=this,r={configurable:!0,enumerable:!1,writable:!0};Object.defineProperties(o,{[t]:{...r,value:[]},[s]:{...r,value:0},[i]:{...r,value:[]},[d]:{...r,value:[]},[c]:{...r,value:null}}),o.vdomEffect=new n({fn:()=>{o[s]=0,o[d]=[],o[c]=o.createVdom(o)},componentId:o.id,subscriber:{id:o.id,fn:o.onEffectRunStateChange,scope:o}})}afterSetMounted(e,n){if(super.afterSetMounted(e,n),void 0!==n){e&&this.applyPendingDomListeners()}}afterSetWindowId(e,n){super.afterSetWindowId(e,n),this.childComponents?.forEach(n=>{n.instance.windowId=e})}applyPendingDomListeners(){const e=this,n=e[t],o=e[d];o.length>0&&(Neo.isEqual(n,o)||(n?.length>0&&e.removeDomListeners(e[t]),e.addDomListeners([...o]),e[t]=[...o]),e[d]=[])}beforeUpdate(){}createVdom(e){return{}}destroy(){const e=this;e.vdomEffect?.destroy(),e.childComponents?.forEach(e=>{e.instance.destroy()}),e.childComponents?.clear(),e[d]=null,super.destroy()}diffAndSet(e,n,o){const t={};for(const s in n){const i=n[s],d=o[s];Neo.isEqual(i,d)||("Object"===Neo.typeOf(i)&&"NeoInstance"===Neo.typeOf(e[s])?this.diffAndSet(e[s],i,d||{}):t[s]=i)}Object.keys(t).length>0&&e.set(t)}onEffectRunStateChange(e,n){if(!1===e){const e=this,n=e[c];if(n){e.#e=new Map;const t=e.processVdomForComponents(n,e.id);e.childComponents?.size>0&&[...e.childComponents].forEach(([n,o])=>{e.#e.has(n)||(e.childComponents.delete(n),o.instance.destroy())});const s=e.childComponents?new Set(e.childComponents.keys()):new Set;let i=!1;for(const n of e.#e.keys())if(!s.has(n)){i=!0;break}i&&(e.updateDepth=-1),e.childComponents=e.#e;for(const n in e.vdom)delete e.vdom[n];Object.assign(e.vdom,t),e[c]=null;const d=e.getVdomRoot();e.cls&&(d.cls=o.union(e.cls,d.cls)),e.id&&(d.id=e.id),e.syncVdomIds(),!1!==e.beforeUpdate()&&e.updateVdom(),e.mounted&&e.applyPendingDomListeners()}}}processVdomForComponents(e,n,o){if(!e)return e;if(e.componentId)return e;const t=this;if(e.className||e.module||e.ntype){const s=e.id;s||console.error(['Component definition in functional component VDOM is missing an "id". For stable reconciliation, ','especially in dynamic lists, provide a unique "id" property.'].join(""),e);let i,d=t.childComponents?.get(s),c={...e};return delete c.className,delete c.id,delete c.module,delete c.ntype,d?(i=d.instance,this.diffAndSet(i,c,d.lastConfig)):(t.childComponents??=new Map,i=Neo[e.className||e.module?"create":"ntype"]({...e,parentId:n,parentIndex:o,windowId:t.windowId})),t.#e.set(s,{instance:i,lastConfig:c}),i.createVdomReference()}return e.cn&&Array.isArray(e.cn)&&(e.cn=e.cn.map((e,o)=>t.processVdomForComponents(e,n,o))),e}});