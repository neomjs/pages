import e from"../../core/Base.mjs";import o from"../../manager/Component.mjs";import n from"../../mixin/DomEvents.mjs";import t from"../../core/Effect.mjs";import s from"../../util/Array.mjs";import i from"../../core/Observable.mjs";import r from"../../mixin/VdomLifecycle.mjs";const d=Symbol.for("activeDomListeners"),m=Symbol.for("hookIndex"),l=Symbol.for("hooks"),c=Symbol.for("pendingDomEvents"),a=Symbol("vdomToApply");export default Neo.setupClass(class extends e{static config={className:"Neo.functional.component.Base",ntype:"functional-component",cls:null,mixins:[n,i,r],mounted_:!1,parentId_:null,vdom:{},windowId_:null};childComponents=null;isAwaitingMount=!1;#e=null;get mountedPromise(){let e=this;return e._mountedPromise||(e._mountedPromise=new Promise(o=>{e.mounted?o(e):e.mountedPromiseResolve=o})),e._mountedPromise}get parent(){let e=this;return e.parentComponent||("document.body"===e.parentId?null:Neo.getComponent(e.parentId))}construct(e){super.construct(e);let o=this,n={configurable:!0,enumerable:!1,writable:!0};Object.defineProperties(o,{[d]:{...n,value:[]},[m]:{...n,value:0},[l]:{...n,value:[]},[c]:{...n,value:[]},[a]:{...n,value:null}}),o.vdomEffect=new t({fn:()=>{o[m]=0,o[c]=[],o[a]=o.createVdom(o,o.data)},componentId:o.id,subscriber:{id:o.id,fn:o.onEffectRunStateChange,scope:o}})}afterSetId(e,n){super.afterSetId(e,n),n&&o.unregister(n),e&&o.register(this)}afterSetMounted(e,o){if(void 0!==o){const o=this;e?(o.initDomEvents(),o.applyPendingDomListeners(),o.mountedPromiseResolve?.(this),delete o.mountedPromiseResolve):delete o._mountedPromise}}afterSetWindowId(e,o){const n=this;e&&Neo.currentWorker.insertThemeFiles(e,n.__proto__),n.childComponents?.forEach(o=>{o.instance.windowId=e}),o&&(n.isVdomUpdating=!1)}applyPendingDomListeners(){const e=this,o=e[d],n=e[c];n.length>0&&(Neo.isEqual(o,n)||(o?.length>0&&e.removeDomListeners(e[d]),e.addDomListeners([...n]),e[d]=[...n]),e[c]=[])}createVdom(e,o){return{}}destroy(){const e=this;e.vdomEffect?.destroy(),e.childComponents?.forEach(e=>{e.instance.destroy()}),e.childComponents?.clear(),e.removeDomEvents(),e[c]=null,o.unregister(e),super.destroy()}diffAndSet(e,o,n){const t={};for(const s in o){const i=o[s],r=n[s];Neo.isEqual(i,r)||("Object"===Neo.typeOf(i)&&"NeoInstance"===Neo.typeOf(e[s])?this.diffAndSet(e[s],i,r||{}):t[s]=i)}Object.keys(t).length>0&&e.set(t)}onEffectRunStateChange(e,o){if(!1===e){const e=this,o=e[a];if(o){e.#e=new Map;const n=e.processVdomForComponents(o,e.id);e.childComponents?.size>0&&[...e.childComponents].forEach(([o,n])=>{e.#e.has(o)||(e.childComponents.delete(o),n.instance.destroy())});const t=e.childComponents?new Set(e.childComponents.keys()):new Set;let i=!1;for(const o of e.#e.keys())if(!t.has(o)){i=!0;break}i&&(e.updateDepth=-1),e.childComponents=e.#e;for(const o in e.vdom)delete e.vdom[o];Object.assign(e.vdom,n),e[a]=null;const r=e.getVdomRoot();e.cls&&(r.cls=s.union(e.cls,r.cls)),e.id&&(r.id=e.id),e.updateVdom(),e.mounted&&e.applyPendingDomListeners()}}}processVdomForComponents(e,o,n){if(!e)return e;if(e.componentId)return e;const t=this;if(e.className||e.module||e.ntype){const s=e.id;s||console.error(['Component definition in functional component VDOM is missing an "id". For stable reconciliation, ','especially in dynamic lists, provide a unique "id" property.'].join(""),e);let i,r=t.childComponents?.get(s),d={...e};return delete d.className,delete d.id,delete d.module,delete d.ntype,r?(i=r.instance,this.diffAndSet(i,d,r.lastConfig)):(t.childComponents??=new Map,i=Neo[e.className||e.module?"create":"ntype"]({...e,parentId:o,parentIndex:n,windowId:t.windowId})),t.#e.set(s,{instance:i,lastConfig:d}),i.createVdomReference()}return e.cn&&Array.isArray(e.cn)&&(e.cn=e.cn.map((e,n)=>t.processVdomForComponents(e,o,n))),e}set(e={},o=!1){let n=this;return n.silentVdomUpdate=!0,super.set(e),n.silentVdomUpdate=!1,o||!n.needsVdomUpdate?Promise.resolve():n.promiseUpdate()}});