import e from"../core/Base.mjs";import d from"../manager/Component.mjs";import t from"../util/Array.mjs";import o from"../util/vdom/TreeBuilder.mjs";import n from"../util/VDom.mjs";import i from"../manager/VDomUpdate.mjs";import r from"../util/VNode.mjs";import{isDescriptor as a}from"../core/ConfigSymbols.mjs";const{currentWorker:s}=Neo;class m extends e{static config={className:"Neo.mixin.VdomLifecycle",autoMount:!1,autoRender:!1,hasUnmountedVdomChanges_:!1,isVdomUpdating_:!1,mounted_:!1,needsVdomUpdate_:!1,rendering_:!1,silentVdomUpdate_:!1,updateDepth_:1,vnode_:{[a]:!0,clone:"none",cloneOnGet:"none",isEqual:(e,d)=>e===d,value:null}};afterSetHasUnmountedVdomChanges(e,t){if(e||!e&&t){let t,o=d.getParentIds(this),n=0,i=o.length;for(;n<i;n++)t=Neo.getComponent(o[n]),t&&(t._hasUnmountedVdomChanges=e)}}afterSetVdom(e,d){this.updateVdom()}afterSetVnode(e,d){void 0!==d&&this.syncVnodeTree()}createVdomReference(){let e=this,d={componentId:e.id},t=e.vdom.id;return t&&e.id!==t&&(d.id=t),d}async executeVdomUpdate(e,d){let t=this;e&&i.addPromiseCallback(t.id,e),t.isVdomUpdating=!0,i.registerInFlightUpdate(t.id,t.updateDepth);try{const{vdom:e,vnode:d}=t,n=i.getMergedChildIds(t.id),r={vdom:o.getVdomTree(e,t.updateDepth,n),vnode:o.getVnodeTree(d,t.updateDepth,n)};s?.isSharedWorker&&(r.appName=t.appName,r.windowId=t.windowId),t._needsVdomUpdate=!1,t.afterSetNeedsVdomUpdate?.(!1,!0),t._updateDepth=t.constructor.config.updateDepth;const a=await Promise.resolve(Neo.vdom.Helper.update(r));t.id&&(t.vnode=a.vnode,!Neo.config.useVdomWorker&&a.deltas?.length>0&&await Neo.applyDeltas(t.appName,a.deltas),t.isVdomUpdating=!1,t.resolveVdomUpdate(a))}catch(e){t.isVdomUpdating=!1,i.unregisterInFlightUpdate(t.id),d?.(e)}}getMountedParentId(){let e=this.parentId,d=Neo.getComponent(e),t=d?.getVdomItemsRoot?.();return t?t.id:e}getMountedParentIndex(){let e,d=this.parent,t=d?.items||[],o=0,n=0,i=t.length;for(;o<i;o++){if(e=t[o],e===this)return n;e.hidden||"removeDom"!==e.hideMode||n++}}getVdomChild(e,d=this.vdom){return n.find(d,e)?.vdom}getVdomRoot(){return this.vdom}getVnodeRoot(){return this.vnode}hasUpdateCollision(e,d){return-1===e||d<e}isParentUpdating(e=this.parentId,d,t=1){if("document.body"!==e){let o=this,n=Neo.getComponent(e);if(n){if(n.isVdomUpdating){const e=i.getInFlightUpdateDepth(n.id);return!!o.hasUpdateCollision(e,t)&&(Neo.config.logVdomUpdateCollisions&&console.warn("vdom parent update conflict with:",n,"for:",o),i.registerPostUpdate(n.id,o.id,d),!0)}return o.isParentUpdating(n.parentId,d,t+1)}}return!1}mergeIntoParentUpdate(e=this.parentId,d=1){if("document.body"!==e){let t=this,o=Neo.getComponent(e);if(o)return o.needsVdomUpdate&&t.hasUpdateCollision(o.updateDepth,d)?(i.registerMerged(o.id,t.id,t.updateDepth,d),!0):t.mergeIntoParentUpdate(o.parentId,d+1)}return!1}onRender(e,t){let o=this,{app:n}=o;if(o.rendering=!1,n){n.rendered||(n.rendering=!1,n.rendered=!0,n.fire("render")),o.vnode=e;let i,r=d.getChildIds(e),a=0,s=r.length;for(;a<s;a++)i=Neo.getComponent(r[a]),i&&(i.rendered=!0);o._rendered=!0,o.fire("rendered",o.id),t&&(o.mounted=!0,n.mounted||(n.mounted=!0,n.fire("mounted")))}}promiseUpdate(){return new Promise((e,d)=>{this.updateVdom(e,d)})}async render(e){let d=this,t=e||d.autoMount,{app:n}=d,{allowVdomUpdatesInTests:i,unitTestMode:r,useVdomWorker:a}=Neo.config;if(!r||i)if(r||!t||0===s.countLoadingThemeFiles){if(d.rendering=!0,n.rendered||(n.rendering=!0),d.vdom){d.isVdomUpdating=!0,delete d.vdom.removeDom,d._needsVdomUpdate=!1,d.afterSetNeedsVdomUpdate?.(!1,!0);const e=await Promise.resolve(Neo.vdom.Helper.create({appName:d.appName,autoMount:t,parentId:t?d.getMountedParentId():void 0,parentIndex:t?d.getMountedParentIndex():void 0,vdom:o.getVdomTree(d.vdom,-1),windowId:d.windowId}));d.onRender(e.vnode,!!a&&t),d.isVdomUpdating=!1,t&&!a&&d.mount(),d.resolveVdomUpdate()}}else s.on("themeFilesLoaded",function(){!d.mounted&&d.render(e)},d,{once:!0})}resolveVdomUpdate(e){let d=this;i.executeCallbacks(d.id,e),i.unregisterInFlightUpdate(d.id),i.triggerPostUpdates(d.id),d.needsVdomUpdate&&d.update()}syncVdomIds(e=this.vnode,d=this.vdom,t=!1){n.syncVdomIds(e,d,t)}syncVnodeTree(e=this.vnode){let t,o=this,n=d.getChildren(o),i=!1,a={};o.syncVdomIds(),e&&o.id!==e.id&&d.registerWrapperNode(e.id,o),n.forEach(e=>{t=r.find(o.vnode,e.vdom.id)?.vnode,t&&(a[e.id]=t,e.id!==t.id&&d.registerWrapperNode(t.id,e))}),n.forEach(e=>{t=a[e.id],t?(e._vnode=d.addVnodeComponentReferences(t,e.id),e.rendered||(e._rendered=!0,e.fire("rendered",e.id)),e.mounted=!0):console.warn("syncVnodeTree: Could not replace the child vnode for",e.id)}),o._vnode=e?d.addVnodeComponentReferences(e,o.id):null}update(){this.afterSetVdom(this.vdom,null)}updateVdom(e,d){if(!this.isConstructed)return void e?.();if(Neo.config.unitTestMode&&!Neo.config.allowVdomUpdatesInTests)return void d?.();let t=this,{mounted:o,parentId:n,vnode:r}=t;if(t.isVdomUpdating||t.silentVdomUpdate)e&&i.addPromiseCallback(t.id,e),t.needsVdomUpdate=!0;else if(e&&i.addPromiseCallback(t.id,e),o){if(!t.mergeIntoParentUpdate(n)&&!t.isParentUpdating(n,e)&&o&&r){let o=i.getAdjustedUpdateDepth(t.id);null!==o&&(t.updateDepth=o),Neo.config.unitTestMode||0===s.countLoadingThemeFiles?t.executeVdomUpdate(null,d):s.on("themeFilesLoaded",function(){t.updateVdom(e,d)},t,{once:!0})}}else t.isAwaitingMount||(t.isAwaitingMount=!0,t.mountedPromise.then(()=>{t.isAwaitingMount=!1,t.vnode&&t.update()}));t.hasUnmountedVdomChanges=!o&&t.hasBeenMounted}}Neo.setupClass(m);export default m;