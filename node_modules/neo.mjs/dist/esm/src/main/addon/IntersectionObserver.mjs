import e from"./Base.mjs";import t from"../DomEvents.mjs";export default Neo.setupClass(class extends e{static config={className:"Neo.main.addon.IntersectionObserver",remote:{app:["disconnect","observe","register"]}};map={};observeCache={};disconnect(e){this.map[e.id]?.disconnect()}findTopmostItem(e,s){let r,a,o,n,i=this;e.forEach(e=>{n=e.target,r=n.dataset&&{...n.dataset}||null,a=t.getPathFromElement(e.target).map(e=>t.getTargetData(e)),o=n.getBoundingClientRect(),o.y<200&&(e.isIntersecting,i.sendMessage({data:r,id:s.rootId,isIntersecting:!0,path:a,targetId:n.id}))})}isVisible(e,s){let r,a,o,n=this;e.forEach(e=>{o=e.target,r=o.dataset&&{...o.dataset}||null,a=t.getPathFromElement(e.target).map(e=>t.getTargetData(e)),e.isIntersecting&&n.sendMessage({data:r,id:s.rootId,isIntersecting:!0,path:a,targetId:o.id})})}observe(e){let t=!1,{id:s,observe:r}=e,{observeCache:a}=this,o=this.map[e.id],n=[];return Neo.isArray(r)||(r=[r]),r.forEach(e=>{n.push(...document.querySelectorAll(e))}),o?(e.disconnect&&o.disconnect(),n.forEach(e=>{o.observe(e)})):(t=!0,a[s]||(a[s]=[]),a[s].push(e)),{cached:t,countTargets:n.length}}register(e){let t,s=this,{observeCache:r}=s,{id:a,observe:o}=e,n=!0;return s.map[a]=t=new IntersectionObserver(s[e.callback].bind(s),{root:document.querySelector(e.root),rootMargin:e.rootMargin||"0px",threshold:e.threshold||0}),t.rootId=e.id,o&&(n=s.observe({id:a,observe:o})),r[a]&&(r[a].forEach(e=>s.observe(e)),delete r[a]),n}sendMessage(e){Neo.worker.Manager.sendMessage("app",{action:"domEvent",eventName:"intersect",data:e})}});