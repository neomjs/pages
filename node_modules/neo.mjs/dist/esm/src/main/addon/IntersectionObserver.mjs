import e from"./Base.mjs";import t from"../DomEvents.mjs";export default Neo.setupClass(class extends e{static config={className:"Neo.main.addon.IntersectionObserver",remote:{app:["disconnect","observe","register"]}};cache={};map={};disconnect(e){this.map[e.id]?.disconnect()}findTopmostItem(e,s){let a,r,o,n,i=this;e.forEach((e=>{n=e.target,a=n.dataset&&{...n.dataset}||null,r=t.getPathFromElement(e.target).map((e=>t.getTargetData(e))),o=n.getBoundingClientRect(),o.y<200&&(e.isIntersecting,i.sendMessage({data:a,id:s.rootId,isIntersecting:!0,path:r,targetId:n.id}))}))}isVisible(e,s){let a,r,o,n=this;e.forEach((e=>{o=e.target,a=o.dataset&&{...o.dataset}||null,r=t.getPathFromElement(e.target).map((e=>t.getTargetData(e))),e.isIntersecting&&n.sendMessage({data:a,id:s.rootId,isIntersecting:!0,path:r,targetId:o.id})}))}observe(e){let t=this.cache,s=!1,{id:a,observe:r}=e,o=this.map[e.id],n=[];return Neo.isArray(r)||(r=[r]),r.forEach((e=>{n.push(...document.querySelectorAll(e))})),o?(e.disconnect&&o.disconnect(),n.forEach((e=>{o.observe(e)}))):(s=!0,t[a]||(t[a]=[]),t[a].push(e)),{cached:s,countTargets:n.length}}register(e){let t,s=this,{cache:a}=s,{id:r,observe:o}=e,n=!0;return s.map[r]=t=new IntersectionObserver(s[e.callback].bind(s),{root:document.querySelector(e.root),rootMargin:e.rootMargin||"0px",threshold:e.threshold||0}),t.rootId=e.id,o&&(n=s.observe({id:r,observe:o})),a[r]&&(a[r].forEach((e=>s.observe(e))),delete a[r]),n}sendMessage(e){Neo.worker.Manager.sendMessage("app",{action:"domEvent",eventName:"intersect",data:e})}});