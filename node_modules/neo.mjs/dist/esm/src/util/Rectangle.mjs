const t=Object.freeze([]),e=(t=0)=>{switch(Array.isArray(t)||(t=[t]),t.length){case 1:return t.length=4,t.fill(t[0],1,4);case 2:return[t[0],t[1],t[0],t[1]];case 3:return[t[0],t[1],t[2],t[1]]}return t},i=t=>{const e=o[t.ourEdge],i=o[t.theirEdge];return`${e}${t.ourEdgeOffset}${t.ourEdgeUnit}-${i}${t.theirEdgeOffset}${t.theirEdgeUnit}`},n=t=>{const e=t instanceof DOMRect?t:(1===t?.nodeType?t:"string"==typeof t?document.getElementById(t):null)?.getBoundingClientRect();return e&&new l(e.x,e.y,e.width,e.height)},o={t:"b",r:"l",b:"t",l:"r"},h={t:0,r:1,b:2,l:3},r=["top","right","bottom","left"],s=["t","r","b","l"],g=["width","height"],c=[0,0,0,0],a=/^([trblc])(\d*)(%|px)?-([trblc])(\d*)(%|px)?$/;export default class l extends DOMRect{static config={className:"Neo.util.Rectangle"};minHeight=null;minWidth=null;static excludes(t,e){return t.bottom<e.top||t.left>e.right||t.right<e.left||t.top>e.bottom}static getIntersection(t,e){let i=Math.max(t.x,e.x),n=Math.max(t.y,e.y),o=Math.min(t.right,e.right),h=Math.min(t.bottom,e.bottom),r=Math.max(0,o-i),s=Math.max(0,h-n);return s<1||r<1?null:new l(i,n,r,s)}static includes(t,e){return t.bottom>=e.bottom&&t.left<=e.left&&t.right>=e.right&&t.top<=e.top}static leavesSide(t,e,i){return!l.includes(t,e)&&("bottom"===i?t.bottom<e.bottom:"left"===i?t.left>e.left:"right"===i?t.right<e.right:"top"===i?t.top>e.top:void 0)}static moveBy(t,e=null,i=null){let n={...t};return Neo.isNumber(e)&&(n.left+=e,n.right+=e,n.x+=e),Neo.isNumber(i)&&(n.bottom+=i,n.top+=i,n.y+=i),n}static moveTo(t,e=null,i=null){let n={...t};return Neo.isNumber(e)&&(n.left=e,n.right=e+n.width,n.x=e),Neo.isNumber(i)&&(n.bottom=i+n.height,n.top=i,n.y=i),n}set bottom(t){this.height+=t-this.bottom}get bottom(){return super.bottom}set right(t){this.width+=t-this.right}get right(){return super.right}changeX(t){const e=this.x-t;this.x=t,this.width+=e}changeY(t){const e=this.y-t;this.y=t,this.height+=e}clone(){return l.clone(this)}static clone(t){const e=new l(t.x,t.y,t.width,t.height);return e.minWidth=t.minWidth,e.minHeight=t.minHeight,e}intersects(t){const e=this;if(t.height&&t.width){const i=Math.max(e.x,t.x),n=Math.max(e.y,t.y),o=Math.min(e.x+e.width,t.x+t.width),h=Math.min(e.y+e.height,t.y+t.height);return!(i>=o||n>=h)&&new l(i,n,o-i,h-n)}return t.x>=e.x&&t.y>=e.y&&t.right<=e.right&&t.bottom<=e.bottom}contains(t){return this.bottom>=t.bottom&&this.left<=t.left&&this.right>=t.right&&this.top<=t.top}expand(t){return t=e(t),new this.constructor(this.x-t[3],this.y-t[0],this.width+t[1]+t[3],this.height+t[0]+t[2])}moveBy(t=0,e=0){const i=this.clone();return Array.isArray(t)&&(e=t[1],t=t[0]),i.x+=t,i.y+=e,i}contains(t){return this.constructor.includes(this,t)}constrainTo(t){const e=this,i=e.minWidth||e.width;if((e.minHeight||e.height)>t.height||i>t.width)return!1;const n=e.clone();return n.x=Math.max(e.x+Math.min(t.right-n.right,0),t.x),n.y=Math.max(e.y+Math.min(t.bottom-n.bottom,0),t.y),n.bottom=Math.min(n.bottom,t.bottom),n.right=Math.min(n.right,t.right),n}alignTo(t){const l=this,{constrainTo:d,target:m,edgeAlign:u,axisLock:b,offset:x,matchSize:f}=t,y=t.targetMargin?e(t.targetMargin):c,p=n(m),w=n(d),E=(t=>{const e=a.exec(t),i=h[e[1]],n=h[e[4]];return{ourEdge:e[1],ourEdgeOffset:parseInt(e[2]||50),ourEdgeUnit:e[3]||"%",ourEdgeZone:i,theirEdge:e[4],theirEdgeOffset:parseInt(e[5]||50),theirEdgeUnit:e[6]||"%",theirEdgeZone:n,edgeAligned:(1&i)==(1&n)&&i!==n}})(u),M=g[1&E.theirEdgeZone];let $=l.clone();f&&($[M]=p[M]);const A=$.getAnchorPoint(E.ourEdgeZone,E.ourEdgeOffset,E.ourEdgeUnit),z=p.getAnchorPoint(E.theirEdgeZone,E.theirEdgeOffset,E.theirEdgeUnit,y),N=[z[0]-A[0],z[1]-A[1]];if($=$.moveBy(N),$.zone=E.theirEdgeZone,$.position=r[$.zone],w&&!w.contains($)){if(p.intersects($))return $;let t=E.theirEdgeZone;const e=[{zone:t,edgeAlign:u}];if(b)e[1]={zone:t=(t+2)%4,edgeAlign:i(E)},e.push({zone:t=(E.theirEdgeZone+1)%4,edgeAlign:`${o[s[t]]}-${s[t]}`}),e.push({zone:t=(E.theirEdgeZone+3)%4,edgeAlign:`${o[s[t]]}-${s[t]}`});else for(let i=1;i<4;i++)e.push({zone:t=(t+1)%4,edgeAlign:`${o[s[t]]}-${s[t]}`});for(let t=0;t<e.length;t++){const i=w.clone();switch(e[t].zone){case 0:i.bottom=p.y-y[0];break;case 1:i.changeX(p.right+y[1]);break;case 2:i.changeY(p.bottom+y[2]);break;case 3:i.right=p.x-y[3]}e[t].constrainRect=i}for(let t=0;t<e.length;t++){const{zone:i,edgeAlign:n,constrainRect:h}=e[t],g=s[i];f&&($[M]=g===E.theirEdge||g==o[E.theirEdge]?p[M]:l[M]),$=$.alignTo({target:p,edgeAlign:n,targetMargin:y});let c=$.constrainTo(h);if(c)return c.zone=i,c.position=r[i],c}}return x&&$.moveBy(x),$}getAnchorPoint(e,i,n,o=t){const h=this;let r;switch(e){case 0:r=[h.x,h.y-(o[0]||0),h.width,0];break;case 1:r=[h.x+h.width+(o[1]||0),h.y,h.height,1];break;case 2:r=[h.x,h.y+h.height+(o[2]||0),h.width,0];break;case 3:r=[h.x-(o[3]||0),h.y,h.height,1]}return r[r[3]]+="%"===n?r[2]/100*i:i,r.length=2,r}equals(t){return t instanceof DOMRect&&t.x===this.x&&t.y===this.y&&t.height===this.height&&t.width===this.width}show(t="red"){const e=document.createElement("div");return e.style=`\n            position:absolute;\n            transform:translate3d(${this.x}px, ${this.y}px, 0);\n            height:${this.height}px;\n            width:${this.width}px;\n            background-color:${t}\n        `,document.body.appendChild(e),setTimeout((()=>e.remove()),3e4),e}toJSON(){const{bottom:t,height:e,left:i,minHeight:n,minWidth:o,right:h,top:r,width:s,x:g,y:c}=this;return{bottom:t,height:e,left:i,minHeight:n,minWidth:o,right:h,top:r,width:s,x:g,y:c}}}