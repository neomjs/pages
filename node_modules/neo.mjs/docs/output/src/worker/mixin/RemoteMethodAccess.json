{"classData":[{"comment":"/**\n * @summary Mixin to enable and handle remote method access across threads (Workers and Main Threads).\n *\n * **What is Remote Method Access?**\n * This pattern allows code running in one thread (e.g., an App Worker) to execute a method located in another thread\n * (e.g., the Main Thread) as if it were a local function call. Since the threads are isolated, the execution is asynchronous:\n * the caller invokes the method and awaits a `Promise` that resolves with the return value from the other thread.\n *\n * **Crucial Constraints:**\n * - **Serialization:** All arguments passed to the method and the return value sent back MUST be **JSON-serializable**.\n *   This means you cannot pass DOM nodes, DOM Events, or complex class instances directly.\n * - **Transferables:** `ArrayBuffer`, `MessagePort` and `OffscreenCanvas` can be transferred (zero-copy) if explicitly handled.\n *\n * This mixin is the core mechanism for cross-thread communication in Neo.mjs. It is consumed by:\n * - `Neo.worker.Base` (App, Data, VDom, Task, Canvas workers)\n * - `Neo.worker.ServiceBase` (Service Worker)\n * - `Neo.worker.Manager` (Main Thread)\n *\n * This broad usage ensures that **all** connected realms can communicate with each other. This includes\n * Worker-to-Worker, Worker-to-Main, and even Main-to-Worker method calls.\n *\n * **Key Responsibilities:**\n * 1. **Registration:** Registers methods defined in the `remote` config as callable endpoints.\n * 2. **Proxy Generation:** Creates local proxy functions that send messages to the target thread when called.\n * 3. **Routing:** Ensures messages are sent to the correct `windowId` in a multi-window environment.\n * 4. **Interception:** Supports the `interceptRemotes` config to intercept calls before they are executed.\n *    This is particularly critical for Main Thread Addons (Singletons). Calls arriving before an addon is\n *    `isReady` (e.g., waiting for external libraries like Monaco Editor or Google Maps to load) can be\n *    intercepted and queued, ensuring they execute only once the singleton is fully functional.\n *\n * **Synchronous vs. Asynchronous:**\n * - **Definition:** Remote methods can be defined as synchronous or asynchronous functions in their origin class.\n * - **Execution:** When called from a different thread, the execution is **ALWAYS asynchronous**. The proxy\n *   function returns a `Promise` that resolves with the return value of the remote method. This is true even if\n *   the original method is synchronous.\n *\n * **Namespace-Driven Access:**\n * Remote access is resolved via namespaces. The calling thread must know the full class name (e.g., `Neo.main.addon.LocalStorage`)\n * to invoke the method.\n *\n * **Architectural Note:**\n * To support the distributed multi-window architecture where one App Worker serves multiple connected Main Threads,\n * **the first parameter of any remote method MUST be an object containing `windowId`**.\n * This allows the sender to attach the `windowId` (and other metadata) to the payload, ensuring the message\n * is routed to the correct browser window context. Calls passing arrays or primitive values as the first argument\n * cannot be reliably routed in a shared-worker environment.\n *\n * @example\n * // 1. Usage in Neo.component.wrapper.MonacoEditor\n * // Calls the remote method 'setTheme' on the Main Thread addon 'Neo.main.addon.MonacoEditor'\n * Neo.main.addon.MonacoEditor.setTheme({\n *     id      : me.id,\n *     value   : 'vs-dark',\n *     windowId: me.windowId // Critical for routing!\n * }).then(() => {\n *     console.log('Theme updated');\n * });\n *\n * @example\n * // 2. Usage in a Controller accessing LocalStorage\n * // Calls 'readLocalStorageItem' on the Main Thread addon 'Neo.main.addon.LocalStorage'\n * const value = await Neo.main.addon.LocalStorage.readLocalStorageItem({\n *     key     : 'mySettings',\n *     windowId: this.windowId\n * });\n *\n * @class Neo.worker.mixin.RemoteMethodAccess\n * @extends Neo.core.Base\n * @see Neo.worker.Base\n * @see Neo.worker.ServiceBase\n * @see Neo.worker.Manager\n * @see Neo.main.addon.Base\n * @see Neo.main.addon.MonacoEditor\n * @see Neo.main.addon.LocalStorage\n */","meta":{"filename":"RemoteMethodAccess.mjs","lineno":3,"columnno":0,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/worker/mixin","code":{}},"summary":"Mixin to enable and handle remote method access across threads (Workers and Main Threads).\n\n**What is Remote Method Access?**\nThis pattern allows code running in one thread (e.g., an App Worker) to execute a method located in another thread\n(e.g., the Main Thread) as if it were a local function call. Since the threads are isolated, the execution is asynchronous:\nthe caller invokes the method and awaits a `Promise` that resolves with the return value from the other thread.\n\n**Crucial Constraints:**\n- **Serialization:** All arguments passed to the method and the return value sent back MUST be **JSON-serializable**.\n  This means you cannot pass DOM nodes, DOM Events, or complex class instances directly.\n- **Transferables:** `ArrayBuffer`, `MessagePort` and `OffscreenCanvas` can be transferred (zero-copy) if explicitly handled.\n\nThis mixin is the core mechanism for cross-thread communication in Neo.mjs. It is consumed by:\n- `Neo.worker.Base` (App, Data, VDom, Task, Canvas workers)\n- `Neo.worker.ServiceBase` (Service Worker)\n- `Neo.worker.Manager` (Main Thread)\n\nThis broad usage ensures that **all** connected realms can communicate with each other. This includes\nWorker-to-Worker, Worker-to-Main, and even Main-to-Worker method calls.\n\n**Key Responsibilities:**\n1. **Registration:** Registers methods defined in the `remote` config as callable endpoints.\n2. **Proxy Generation:** Creates local proxy functions that send messages to the target thread when called.\n3. **Routing:** Ensures messages are sent to the correct `windowId` in a multi-window environment.\n4. **Interception:** Supports the `interceptRemotes` config to intercept calls before they are executed.\n   This is particularly critical for Main Thread Addons (Singletons). Calls arriving before an addon is\n   `isReady` (e.g., waiting for external libraries like Monaco Editor or Google Maps to load) can be\n   intercepted and queued, ensuring they execute only once the singleton is fully functional.\n\n**Synchronous vs. Asynchronous:**\n- **Definition:** Remote methods can be defined as synchronous or asynchronous functions in their origin class.\n- **Execution:** When called from a different thread, the execution is **ALWAYS asynchronous**. The proxy\n  function returns a `Promise` that resolves with the return value of the remote method. This is true even if\n  the original method is synchronous.\n\n**Namespace-Driven Access:**\nRemote access is resolved via namespaces. The calling thread must know the full class name (e.g., `Neo.main.addon.LocalStorage`)\nto invoke the method.\n\n**Architectural Note:**\nTo support the distributed multi-window architecture where one App Worker serves multiple connected Main Threads,\n**the first parameter of any remote method MUST be an object containing `windowId`**.\nThis allows the sender to attach the `windowId` (and other metadata) to the payload, ensuring the message\nis routed to the correct browser window context. Calls passing arrays or primitive values as the first argument\ncannot be reliably routed in a shared-worker environment.","examples":["// 1. Usage in Neo.component.wrapper.MonacoEditor\n// Calls the remote method 'setTheme' on the Main Thread addon 'Neo.main.addon.MonacoEditor'\nNeo.main.addon.MonacoEditor.setTheme({\n    id      : me.id,\n    value   : 'vs-dark',\n    windowId: me.windowId // Critical for routing!\n}).then(() => {\n    console.log('Theme updated');\n});","// 2. Usage in a Controller accessing LocalStorage\n// Calls 'readLocalStorageItem' on the Main Thread addon 'Neo.main.addon.LocalStorage'\nconst value = await Neo.main.addon.LocalStorage.readLocalStorageItem({\n    key     : 'mySettings',\n    windowId: this.windowId\n});"],"kind":"class","name":"RemoteMethodAccess","augments":["Neo.core.Base"],"see":["Neo.worker.Base","Neo.worker.ServiceBase","Neo.worker.Manager","Neo.main.addon.Base","Neo.main.addon.MonacoEditor","Neo.main.addon.LocalStorage"],"memberof":"Neo.worker.mixin","longname":"Neo.worker.mixin.RemoteMethodAccess","scope":"static","$longname":"Neo.worker.mixin.RemoteMethodAccess","$kind":"class","id":5759,"neoClassName":"Neo.worker.mixin.RemoteMethodAccess"},{"comment":"/**\n         * @member {String} className='Neo.worker.mixin.RemoteMethodAccess'\n         * @protected\n         */","meta":{"filename":"RemoteMethodAccess.mjs","lineno":84,"columnno":8,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/worker/mixin","code":{}},"kind":"member","name":"className","type":{"names":["String"]},"defaultvalue":"'Neo.worker.mixin.RemoteMethodAccess'","access":"protected","longname":"className","scope":"global","$longname":"className","$kind":"property","id":5760,"neoClassName":"Neo.worker.mixin.RemoteMethodAccess"},{"comment":"/**\n     * Helper method to copy routing information (appName, port, windowId) from a source message to a target message.\n     * This is crucial in SharedWorker environments to maintain the context of the original sender when formulating a reply or forwarding a message.\n     *\n     * @param {Object} source The source message object containing routing metadata.\n     * @param {Object} target The target message object to populate with routing metadata.\n     */","meta":{"range":[4899,5080],"filename":"RemoteMethodAccess.mjs","lineno":94,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/worker/mixin","code":{"id":"astnode100038487","name":"RemoteMethodAccess#assignPort","type":"MethodDefinition","paramnames":["source","target"]},"vars":{"":null}},"description":"<p>Helper method to copy routing information (appName, port, windowId) from a source message to a target message.\nThis is crucial in SharedWorker environments to maintain the context of the original sender when formulating a reply or forwarding a message.</p>\n","params":[{"type":{"names":["Object"]},"description":"<p>The source message object containing routing metadata.</p>\n","name":"source"},{"type":{"names":["Object"]},"description":"<p>The target message object to populate with routing metadata.</p>\n","name":"target"}],"name":"assignPort","longname":"RemoteMethodAccess#assignPort","kind":"function","memberof":"RemoteMethodAccess","scope":"instance","$longname":"RemoteMethodAccess#assignPort","$kind":"method","id":5761,"neoClassName":"Neo.worker.mixin.RemoteMethodAccess"},{"comment":"/**\n     * Generates a proxy function for a remote method.\n     * When this proxy is called, it sends a message to the target thread to execute the real method.\n     *\n     * It handles:\n     * 1. Constructing the message payload with `action: 'remoteMethod'`.\n     * 2. determining the correct destination (e.g., using `windowId` from the data if targeting 'main').\n     * 3. Preserving routing context in SharedWorker environments.\n     * 4. Returning a Promise that resolves with the remote method's result.\n     *\n     * @param {Object} remote The remote configuration object.\n     * @param {String} method The name of the method to generate a proxy for.\n     * @returns {function(*=, *=): Promise<any>} The proxy function.\n     */","meta":{"range":[5826,6468],"filename":"RemoteMethodAccess.mjs","lineno":115,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/worker/mixin","code":{"id":"astnode100038519","name":"RemoteMethodAccess#generateRemote","type":"MethodDefinition","paramnames":["remote","method"]},"vars":{"":null}},"description":"<p>Generates a proxy function for a remote method.\nWhen this proxy is called, it sends a message to the target thread to execute the real method.</p>\n<p>It handles:</p>\n<ol>\n<li>Constructing the message payload with <code>action: &#39;remoteMethod&#39;</code>.</li>\n<li>determining the correct destination (e.g., using <code>windowId</code> from the data if targeting &#39;main&#39;).</li>\n<li>Preserving routing context in SharedWorker environments.</li>\n<li>Returning a Promise that resolves with the remote method&#39;s result.</li>\n</ol>\n","params":[{"type":{"names":["Object"]},"description":"<p>The remote configuration object.</p>\n","name":"remote"},{"type":{"names":["String"]},"description":"<p>The name of the method to generate a proxy for.</p>\n","name":"method"}],"returns":[{"type":{"names":["function"]},"description":"The proxy function."}],"name":"generateRemote","longname":"RemoteMethodAccess#generateRemote","kind":"function","memberof":"RemoteMethodAccess","scope":"instance","$longname":"RemoteMethodAccess#generateRemote","$kind":"method","id":5762,"neoClassName":"Neo.worker.mixin.RemoteMethodAccess"},{"comment":"/**\n     * Handles the 'registerRemote' message action.\n     * It iterates over the list of methods provided in the remote config and generates local proxy functions\n     * for them in the appropriate namespace. This makes the remote methods available to be called as if they were local.\n     *\n     * @param {Object} remote The remote configuration object containing className and methods list.\n     */","meta":{"range":[6882,7523],"filename":"RemoteMethodAccess.mjs","lineno":145,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/worker/mixin","code":{"id":"astnode100038591","name":"RemoteMethodAccess#onRegisterRemote","type":"MethodDefinition","paramnames":["remote"]},"vars":{"":null}},"description":"<p>Handles the &#39;registerRemote&#39; message action.\nIt iterates over the list of methods provided in the remote config and generates local proxy functions\nfor them in the appropriate namespace. This makes the remote methods available to be called as if they were local.</p>\n","params":[{"type":{"names":["Object"]},"description":"<p>The remote configuration object containing className and methods list.</p>\n","name":"remote"}],"name":"onRegisterRemote","longname":"RemoteMethodAccess#onRegisterRemote","kind":"function","memberof":"RemoteMethodAccess","scope":"instance","$longname":"RemoteMethodAccess#onRegisterRemote","$kind":"method","id":5763,"neoClassName":"Neo.worker.mixin.RemoteMethodAccess"},{"comment":"/**\n     * Handles the execution of a requested remote method.\n     * Triggered when a worker receives a message with `action: 'remoteMethod'`.\n     *\n     * This method:\n     * 1. Resolves the target class and method from the namespace.\n     * 2. Checks if the call should be intercepted (e.g., if the target singleton is not ready).\n     * 3. Executes the method (handling both sync and async results).\n     * 4. Catches errors and sends a rejection reply.\n     * 5. Resolves success and sends a reply with the result.\n     *\n     * @param {Object} msg The message payload containing remoteClassName, remoteMethod, and data.\n     */","meta":{"range":[8168,9738],"filename":"RemoteMethodAccess.mjs","lineno":178,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/worker/mixin","code":{"id":"astnode100038676","name":"RemoteMethodAccess#onRemoteMethod","type":"MethodDefinition","paramnames":["msg"]},"vars":{"":null}},"description":"<p>Handles the execution of a requested remote method.\nTriggered when a worker receives a message with <code>action: &#39;remoteMethod&#39;</code>.</p>\n<p>This method:</p>\n<ol>\n<li>Resolves the target class and method from the namespace.</li>\n<li>Checks if the call should be intercepted (e.g., if the target singleton is not ready).</li>\n<li>Executes the method (handling both sync and async results).</li>\n<li>Catches errors and sends a rejection reply.</li>\n<li>Resolves success and sends a reply with the result.</li>\n</ol>\n","params":[{"type":{"names":["Object"]},"description":"<p>The message payload containing remoteClassName, remoteMethod, and data.</p>\n","name":"msg"}],"name":"onRemoteMethod","longname":"RemoteMethodAccess#onRemoteMethod","kind":"function","memberof":"RemoteMethodAccess","scope":"instance","$longname":"RemoteMethodAccess#onRemoteMethod","$kind":"method","id":5764,"neoClassName":"Neo.worker.mixin.RemoteMethodAccess"},{"comment":"/**\n     * Sends a rejection reply back to the caller of a remote method.\n     * Used when the execution of the remote method fails or throws an error.\n     * It ensures the reply is routed back to the correct origin (windowId or worker).\n     *\n     * @param {Object} msg The original message object.\n     * @param {Object} data The error data to send back.\n     */","meta":{"range":[10115,10535],"filename":"RemoteMethodAccess.mjs","lineno":231,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/worker/mixin","code":{"id":"astnode100038838","name":"RemoteMethodAccess#reject","type":"MethodDefinition","paramnames":["msg","data"]},"vars":{"":null}},"description":"<p>Sends a rejection reply back to the caller of a remote method.\nUsed when the execution of the remote method fails or throws an error.\nIt ensures the reply is routed back to the correct origin (windowId or worker).</p>\n","params":[{"type":{"names":["Object"]},"description":"<p>The original message object.</p>\n","name":"msg"},{"type":{"names":["Object"]},"description":"<p>The error data to send back.</p>\n","name":"data"}],"name":"reject","longname":"RemoteMethodAccess#reject","kind":"function","memberof":"RemoteMethodAccess","scope":"instance","$longname":"RemoteMethodAccess#reject","$kind":"method","id":5765,"neoClassName":"Neo.worker.mixin.RemoteMethodAccess"},{"comment":"/**\n     * Sends a success reply back to the caller of a remote method.\n     * Used when the remote method executes successfully.\n     * It handles the transfer of transferable objects (like ArrayBuffers) and ensures correct routing.\n     *\n     * @param {Object} msg The original message object.\n     * @param {Object} data The result data to send back.\n     */","meta":{"range":[10908,11523],"filename":"RemoteMethodAccess.mjs","lineno":260,"columnno":4,"path":"/Users/Shared/github/neomjs/pages/node_modules/neo.mjs/src/worker/mixin","code":{"id":"astnode100038901","name":"RemoteMethodAccess#resolve","type":"MethodDefinition","paramnames":["msg","data"]},"vars":{"":null}},"description":"<p>Sends a success reply back to the caller of a remote method.\nUsed when the remote method executes successfully.\nIt handles the transfer of transferable objects (like ArrayBuffers) and ensures correct routing.</p>\n","params":[{"type":{"names":["Object"]},"description":"<p>The original message object.</p>\n","name":"msg"},{"type":{"names":["Object"]},"description":"<p>The result data to send back.</p>\n","name":"data"}],"name":"resolve","longname":"RemoteMethodAccess#resolve","kind":"function","memberof":"RemoteMethodAccess","scope":"instance","$longname":"RemoteMethodAccess#resolve","$kind":"method","id":5766,"neoClassName":"Neo.worker.mixin.RemoteMethodAccess"}]}