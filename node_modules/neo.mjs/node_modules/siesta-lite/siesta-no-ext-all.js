/*

Siesta 5.3.2
Copyright(c) 2009-2020 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
;if (typeof Joose == "undefined") !function () {;
var Joose = {}

// configuration hash

Joose.C             = typeof JOOSE_CFG != 'undefined' ? JOOSE_CFG : {}

Joose.is_IE         = '\v' == 'v'
Joose.is_NodeJS     = Boolean(typeof process != 'undefined' && process.pid)


Joose.top           = Joose.is_NodeJS && global || this

Joose.stub          = function () {
    return function () { throw new Error("Modules can not be instantiated") }
}


Joose.VERSION       = ({ /*PKGVERSION*/VERSION : '3.50.1' }).VERSION


if (typeof module != 'undefined') module.exports = Joose
/*if (!Joose.is_NodeJS) */
this.Joose = Joose


// Static helpers for Arrays
Joose.A = {

    each : function (array, func, scope) {
        scope = scope || this
        
        for (var i = 0, len = array.length; i < len; i++) 
            if (func.call(scope, array[i], i) === false) return false
    },
    
    
    eachR : function (array, func, scope) {
        scope = scope || this

        for (var i = array.length - 1; i >= 0; i--) 
            if (func.call(scope, array[i], i) === false) return false
    },
    
    
    exists : function (array, value) {
        for (var i = 0, len = array.length; i < len; i++) if (array[i] == value) return true
            
        return false
    },
    
    
    map : function (array, func, scope) {
        scope = scope || this
        
        var res = []
        
        for (var i = 0, len = array.length; i < len; i++) 
            res.push( func.call(scope, array[i], i) )
            
        return res
    },
    

    grep : function (array, func) {
        var a = []
        
        Joose.A.each(array, function (t) {
            if (func(t)) a.push(t)
        })
        
        return a
    },
    
    
    remove : function (array, removeEle) {
        var a = []
        
        Joose.A.each(array, function (t) {
            if (t !== removeEle) a.push(t)
        })
        
        return a
    }
    
}

// Static helpers for Strings
Joose.S = {
    
    saneSplit : function (str, delimeter) {
        var res = (str || '').split(delimeter)
        
        if (res.length == 1 && !res[0]) res.shift()
        
        return res
    },
    

    uppercaseFirst : function (string) { 
        return string.substr(0, 1).toUpperCase() + string.substr(1, string.length - 1)
    },
    
    
    strToClass : function (name, top) {
        var current = top || Joose.top
        
        Joose.A.each(name.split('.'), function (segment) {
            if (current) 
                current = current[ segment ]
            else
                return false
        })
        
        return current
    }
}

var baseFunc    = function () {}

var enumProps   = [ 'hasOwnProperty', 'valueOf', 'toString', 'constructor' ]

var manualEnum  = true

for (var i in { toString : 1 }) manualEnum = false


// Static helpers for objects
Joose.O = {

    each : function (object, func, scope) {
        scope = scope || this
        
        for (var i in object) 
            if (func.call(scope, object[i], i) === false) return false
        
        if (manualEnum) 
            return Joose.A.each(enumProps, function (el) {
                
                if (object.hasOwnProperty(el)) return func.call(scope, object[el], el)
            })
    },
    
    
    eachOwn : function (object, func, scope) {
        scope = scope || this
        
        return Joose.O.each(object, function (value, name) {
            if (object.hasOwnProperty(name)) return func.call(scope, value, name)
        }, scope)
    },
    
    
    copy : function (source, target) {
        target = target || {}
        
        Joose.O.each(source, function (value, name) { target[name] = value })
        
        return target
    },
    
    
    copyOwn : function (source, target) {
        target = target || {}
        
        Joose.O.eachOwn(source, function (value, name) { target[name] = value })
        
        return target
    },
    
    
    getMutableCopy : function (object) {
        baseFunc.prototype = object
        
        return new baseFunc()
    },
    
    
    extend : function (target, source) {
        return Joose.O.copy(source, target)
    },
    
    
    isEmpty : function (object) {
        for (var i in object) if (object.hasOwnProperty(i)) return false
        
        return true
    },
    
    
    isInstance: function (obj) {
        return obj && obj.meta && obj.constructor == obj.meta.c
    },
    
    
    isClass : function (obj) {
        return obj && obj.meta && obj.meta.c == obj
    },
    
    
    wantArray : function (obj) {
        if (obj instanceof Array) return obj
        
        return [ obj ]
    },
    
    
    // this was a bug in WebKit, which gives typeof / / == 'function'
    // should be monitored and removed at some point in the future
    isFunction : function (obj) {
        return typeof obj == 'function' && obj.constructor != / /.constructor
    }
}


//initializers

Joose.I = {
    Array       : function () { return [] },
    Object      : function () { return {} },
    Function    : function () { return arguments.callee },
    Now         : function () { return new Date() }
};
Joose.Proto = Joose.stub()

Joose.Proto.Empty = Joose.stub()
    
Joose.Proto.Empty.meta = {};
;(function () {

    Joose.Proto.Object = Joose.stub()
    
    
    var SUPER = function () {
        var self = SUPER.caller
        
        if (self == SUPERARG) self = self.caller
        
        if (!self.SUPER) throw "Invalid call to SUPER"
        
        return self.SUPER[self.methodName].apply(this, arguments)
    }
    
    
    var SUPERARG = function () {
        return this.SUPER.apply(this, arguments[0])
    }
    
    
    
    Joose.Proto.Object.prototype = {
        
        SUPERARG : SUPERARG,
        SUPER : SUPER,
        
        INNER : function () {
            throw "Invalid call to INNER"
        },                
        
        
        BUILD : function (config) {
            return arguments.length == 1 && typeof config == 'object' && config || {}
        },
        
        
        initialize: function () {
        },
        
        
        toString: function () {
            return "a " + this.meta.name
        }
        
    }
        
    Joose.Proto.Object.meta = {
        constructor     : Joose.Proto.Object,
        
        methods         : Joose.O.copy(Joose.Proto.Object.prototype),
        attributes      : {}
    }
    
    Joose.Proto.Object.prototype.meta = Joose.Proto.Object.meta

})();
;(function () {

    Joose.Proto.Class = function () {
        return this.initialize(this.BUILD.apply(this, arguments)) || this
    }
    
    var bootstrap = {
        
        VERSION             : null,
        AUTHORITY           : null,
        
        constructor         : Joose.Proto.Class,
        superClass          : null,
        
        name                : null,
        
        attributes          : null,
        methods             : null,
        
        meta                : null,
        c                   : null,
        
        defaultSuperClass   : Joose.Proto.Object,
        
        
        BUILD : function (name, extend) {
            this.name = name
            
            return { __extend__ : extend || {} }
        },
        
        
        initialize: function (props) {
            var extend      = props.__extend__
            
            this.VERSION    = extend.VERSION
            this.AUTHORITY  = extend.AUTHORITY
            
            delete extend.VERSION
            delete extend.AUTHORITY
            
            this.c = this.extractConstructor(extend)
            
            this.adaptConstructor(this.c)
            
            if (extend.constructorOnly) {
                delete extend.constructorOnly
                return
            }
            
            this.construct(extend)
        },
        
        
        construct : function (extend) {
            if (!this.prepareProps(extend)) return
            
            var superClass = this.superClass = this.extractSuperClass(extend)
            
            this.processSuperClass(superClass)
            
            this.adaptPrototype(this.c.prototype)
            
            this.finalize(extend)
        },
        
        
        finalize : function (extend) {
            this.processStem(extend)
            
            this.extend(extend)
        },
        
        
        //if the extension returns false from this method it should re-enter 'construct'
        prepareProps : function (extend) {
            return true
        },
        
        
        extractConstructor : function (extend) {
            var res = extend.hasOwnProperty('constructor') ? extend.constructor : this.defaultConstructor()
            
            delete extend.constructor
            
            return res
        },
        
        
        extractSuperClass : function (extend) {
            if (extend.hasOwnProperty('isa') && !extend.isa) throw new Error("Attempt to inherit from undefined superclass [" + this.name + "]")
            
            var res = extend.isa || this.defaultSuperClass
            
            delete extend.isa
            
            return res
        },
        
        
        processStem : function () {
            var superMeta       = this.superClass.meta
            
            this.methods        = Joose.O.getMutableCopy(superMeta.methods || {})
            this.attributes     = Joose.O.getMutableCopy(superMeta.attributes || {})
        },
        
        
        initInstance : function (instance, props) {
            Joose.O.copyOwn(props, instance)
        },
        
        
        defaultConstructor: function () {
            return function (arg) {
                var BUILD = this.BUILD
                
                var args = BUILD && BUILD.apply(this, arguments) || arg || {}
                
                var thisMeta    = this.meta
                
                thisMeta.initInstance(this, args)
                
                return thisMeta.hasMethod('initialize') && this.initialize(args) || this
            }
        },
        
        
        processSuperClass: function (superClass) {
            var superProto      = superClass.prototype
            
            //non-Joose superclasses
            if (!superClass.meta) {
                
                var extend = Joose.O.copy(superProto)
                
                extend.isa = Joose.Proto.Empty
                // clear potential value in the `extend.constructor` to prevent it from being modified
                delete extend.constructor
                
                var meta = new this.defaultSuperClass.meta.constructor(null, extend)
                
                superClass.meta = superProto.meta = meta
                
                meta.c = superClass
            }
            
            this.c.prototype    = Joose.O.getMutableCopy(superProto)
            this.c.superClass   = superProto
        },
        
        
        adaptConstructor: function (c) {
            c.meta = this
            
            if (!c.hasOwnProperty('toString')) c.toString = function () { return this.meta.name }
        },
    
        
        adaptPrototype: function (proto) {
            //this will fix weird semantic of native "constructor" property to more intuitive (idea borrowed from Ext)
            proto.constructor   = this.c
            proto.meta          = this
        },
        
        
        addMethod: function (name, func) {
            func.SUPER = this.superClass.prototype
            
            //chrome don't allow to redefine the "name" property
            func.methodName = name
            
            this.methods[name] = func
            this.c.prototype[name] = func
        },
        
        
        addAttribute: function (name, init) {
            this.attributes[name] = init
            this.c.prototype[name] = init
        },
        
        
        removeMethod : function (name) {
            delete this.methods[name]
            delete this.c.prototype[name]
        },
    
        
        removeAttribute: function (name) {
            delete this.attributes[name]
            delete this.c.prototype[name]
        },
        
        
        hasMethod: function (name) { 
            return Boolean(this.methods[name])
        },
        
        
        hasAttribute: function (name) { 
            return this.attributes[name] !== undefined
        },
        
    
        hasOwnMethod: function (name) { 
            return this.hasMethod(name) && this.methods.hasOwnProperty(name)
        },
        
        
        hasOwnAttribute: function (name) { 
            return this.hasAttribute(name) && this.attributes.hasOwnProperty(name)
        },
        
        
        extend : function (props) {
            Joose.O.eachOwn(props, function (value, name) {
                if (name != 'meta' && name != 'constructor') 
                    if (Joose.O.isFunction(value) && !value.meta) 
                        this.addMethod(name, value) 
                    else 
                        this.addAttribute(name, value)
            }, this)
        },
        
        
        subClassOf : function (classObject, extend) {
            return this.subClass(extend, null, classObject)
        },
    
    
        subClass : function (extend, name, classObject) {
            extend      = extend        || {}
            extend.isa  = classObject   || this.c
            
            return new this.constructor(name, extend).c
        },
        
        
        instantiate : function () {
            var f = function () {}
            
            f.prototype = this.c.prototype
            
            var obj = new f()
            
            return this.c.apply(obj, arguments) || obj
        }
    }
    
    //micro bootstraping
    
    Joose.Proto.Class.prototype = Joose.O.getMutableCopy(Joose.Proto.Object.prototype)
    
    Joose.O.extend(Joose.Proto.Class.prototype, bootstrap)
    
    Joose.Proto.Class.prototype.meta = new Joose.Proto.Class('Joose.Proto.Class', bootstrap)
    
    
    
    Joose.Proto.Class.meta.addMethod('isa', function (someClass) {
        var f = function () {}
        
        f.prototype = this.c.prototype
        
        return new f() instanceof someClass
    })
})();
Joose.Managed = Joose.stub()

Joose.Managed.Property = new Joose.Proto.Class('Joose.Managed.Property', {
    
    name            : null,
    
    init            : null,
    value           : null,
    
    definedIn       : null,
    
    
    initialize : function (props) {
        Joose.Managed.Property.superClass.initialize.call(this, props)
        
        this.computeValue()
    },
    
    
    computeValue : function () {
        this.value = this.init
    },    
    
    
    //targetClass is still open at this stage
    preApply : function (targetClass) {
    },
    

    //targetClass is already open at this stage
    postUnApply : function (targetClass) {
    },
    
    
    apply : function (target) {
        target[this.name] = this.value
    },
    
    
    isAppliedTo : function (target) {
        return target[this.name] == this.value
    },
    
    
    unapply : function (from) {
        if (!this.isAppliedTo(from)) throw "Unapply of property [" + this.name + "] from [" + from + "] failed"
        
        delete from[this.name]
    },
    
    
    cloneProps : function () {
        return {
            name        : this.name, 
            init        : this.init,
            definedIn   : this.definedIn
        }
    },

    
    clone : function (name) {
        var props = this.cloneProps()
        
        props.name = name || props.name
        
        return new this.constructor(props)
    }
    
    
}).c;
Joose.Managed.Property.ConflictMarker = new Joose.Proto.Class('Joose.Managed.Property.ConflictMarker', {
    
    isa : Joose.Managed.Property,

    apply : function (target) {
        throw new Error("Attempt to apply ConflictMarker [" + this.name + "] to [" + target + "]")
    }
    
}).c;
Joose.Managed.Property.Requirement = new Joose.Proto.Class('Joose.Managed.Property.Requirement', {
    
    isa : Joose.Managed.Property,

    
    apply : function (target) {
        if (!target.meta.hasMethod(this.name)) 
            throw new Error("Requirement [" + this.name + "], defined in [" + this.definedIn.definedIn.name + "] is not satisfied for class [" + target + "]")
    },
    
    
    unapply : function (from) {
    }
    
}).c;
Joose.Managed.Property.Attribute = new Joose.Proto.Class('Joose.Managed.Property.Attribute', {
    
    isa : Joose.Managed.Property,
    
    slot                : null,
    
    
    initialize : function () {
        Joose.Managed.Property.Attribute.superClass.initialize.apply(this, arguments)
        
        this.slot = this.name
    },
    
    
    apply : function (target) {
        target.prototype[ this.slot ] = this.value
    },
    
    
    isAppliedTo : function (target) {
        return target.prototype[ this.slot ] == this.value
    },
    
    
    unapply : function (from) {
        if (!this.isAppliedTo(from)) throw "Unapply of property [" + this.name + "] from [" + from + "] failed"
        
        delete from.prototype[this.slot]
    },
    
    
    clearValue : function (instance) {
        delete instance[ this.slot ]
    },
    
    
    hasValue : function (instance) {
        return instance.hasOwnProperty(this.slot)
    },
        
        
    getRawValueFrom : function (instance) {
        return instance[ this.slot ]
    },
    
    
    setRawValueTo : function (instance, value) {
        instance[ this.slot ] = value
        
        return this
    }
    
}).c;
Joose.Managed.Property.MethodModifier = new Joose.Proto.Class('Joose.Managed.Property.MethodModifier', {
    
    isa : Joose.Managed.Property,

    
    prepareWrapper : function () {
        throw "Abstract method [prepareWrapper] of " + this + " was called"
    },
    
    
    apply : function (target) {
        var name            = this.name
        var targetProto     = target.prototype
        var isOwn           = targetProto.hasOwnProperty(name)
        var original        = targetProto[name]
        var superProto      = target.meta.superClass.prototype
        
        
        var originalCall = isOwn ? original : function () { 
            return superProto[name].apply(this, arguments) 
        }
        
        var methodWrapper = this.prepareWrapper({
            name            : name,
            modifier        : this.value, 
            
            isOwn           : isOwn,
            originalCall    : originalCall, 
            
            superProto      : superProto,
            
            target          : target
        })
        
        if (isOwn) methodWrapper.__ORIGINAL__ = original
        
        methodWrapper.__CONTAIN__   = this.value
        methodWrapper.__METHOD__    = this
        this.value.displayName      = this.getDisplayName(target)
        methodWrapper.displayName   = 'internal wrapper' 
        
        targetProto[name] = methodWrapper
    },
    
    
    getDisplayName : function (target) {
        return target.meta.name + '[' + this.name + ']'
    },
    
    
    isAppliedTo : function (target) {
        var targetCont = target.prototype[this.name]
        
        return targetCont && targetCont.__CONTAIN__ == this.value
    },
    
    
    unapply : function (from) {
        var name = this.name
        var fromProto = from.prototype
        var original = fromProto[name].__ORIGINAL__
        
        if (!this.isAppliedTo(from)) throw "Unapply of method [" + name + "] from class [" + from + "] failed"
        
        //if modifier was applied to own method - restore it
        if (original) 
            fromProto[name] = original
        //otherwise - just delete it, to reveal the inherited method 
        else
            delete fromProto[name]
    }
    
}).c;
Joose.Managed.Property.MethodModifier.Override = new Joose.Proto.Class('Joose.Managed.Property.MethodModifier.Override', {
    
    isa : Joose.Managed.Property.MethodModifier,

    
    prepareWrapper : function (params) {
        
        var modifier        = params.modifier
        var originalCall    = params.originalCall
        var superProto      = params.superProto
        var superMetaConst  = superProto.meta.constructor
        
        //call to Joose.Proto level, require some additional processing
        var isCallToProto = (superMetaConst == Joose.Proto.Class || superMetaConst == Joose.Proto.Object) && !(params.isOwn && originalCall.IS_OVERRIDE) 
        
        var original = originalCall
        
        if (isCallToProto) original = function () {
            var beforeSUPER = this.SUPER
            
            this.SUPER  = superProto.SUPER
            
            var res = originalCall.apply(this, arguments)
            
            this.SUPER = beforeSUPER
            
            return res
        }

        var override = function () {
            
            var beforeSUPER = this.SUPER
            
            this.SUPER  = original
            
            var res = modifier.apply(this, arguments)
            
            this.SUPER = beforeSUPER
            
            return res
        }
        
        override.IS_OVERRIDE = true
        
        return override
    },
    
    getDisplayName : function (target) {
        return target.meta.name + '[override ' + this.name + ']'
    }
    
    
}).c;
Joose.Managed.Property.MethodModifier.Put = new Joose.Proto.Class('Joose.Managed.Property.MethodModifier.Put', {
    
    isa : Joose.Managed.Property.MethodModifier.Override,


    prepareWrapper : function (params) {
        
        if (params.isOwn) throw "Method [" + params.name + "] is applying over something [" + params.originalCall + "] in class [" + params.target + "]"
        
        return Joose.Managed.Property.MethodModifier.Put.superClass.prepareWrapper.call(this, params)
    },
    
    getDisplayName : function (target) {
        return target.meta.name + '[' + this.name + ']'
    }
    
    
}).c;
Joose.Managed.Property.MethodModifier.After = new Joose.Proto.Class('Joose.Managed.Property.MethodModifier.After', {
    
    isa : Joose.Managed.Property.MethodModifier,

    
    prepareWrapper : function (params) {
        
        var modifier        = params.modifier
        var originalCall    = params.originalCall
        
        return function () {
            var res = originalCall.apply(this, arguments)
            modifier.apply(this, arguments)
            return res
        }
    },
    
    getDisplayName : function (target) {
        return target.meta.name + '[after ' + this.name + ']'
    }
    
}).c;
Joose.Managed.Property.MethodModifier.Before = new Joose.Proto.Class('Joose.Managed.Property.MethodModifier.Before', {
    
    isa : Joose.Managed.Property.MethodModifier,

    
    prepareWrapper : function (params) {
        
        var modifier        = params.modifier
        var originalCall    = params.originalCall
        
        return function () {
            modifier.apply(this, arguments)
            return originalCall.apply(this, arguments)
        }
    },
    
    getDisplayName : function (target) {
        return target.meta.name + '[before ' + this.name + ']'
    }
    
}).c;
Joose.Managed.Property.MethodModifier.Around = new Joose.Proto.Class('Joose.Managed.Property.MethodModifier.Around', {
    
    isa : Joose.Managed.Property.MethodModifier,

    prepareWrapper : function (params) {
        
        var modifier        = params.modifier
        var originalCall    = params.originalCall
        
        var me
        
        var bound = function () {
            return originalCall.apply(me, arguments)
        }
            
        return function () {
            me = this
            
            var boundArr = [ bound ]
            boundArr.push.apply(boundArr, arguments)
            
            return modifier.apply(this, boundArr)
        }
    },
    
    getDisplayName : function (target) {
        return target.meta.name + '[around ' + this.name + ']'
    }
    
}).c;
Joose.Managed.Property.MethodModifier.Augment = new Joose.Proto.Class('Joose.Managed.Property.MethodModifier.Augment', {
    
    isa : Joose.Managed.Property.MethodModifier,

    
    prepareWrapper : function (params) {
        
        var AUGMENT = function () {
            
            //populate callstack to the most deep non-augment method
            var callstack = []
            
            var self = AUGMENT
            
            do {
                callstack.push(self.IS_AUGMENT ? self.__CONTAIN__ : self)
                
                self = self.IS_AUGMENT && (self.__ORIGINAL__ || self.SUPER[self.methodName])
            } while (self)
            
            
            //save previous INNER
            var beforeINNER = this.INNER
            
            //create new INNER
            this.INNER = function () {
                var innerCall = callstack.pop()
                
                return innerCall ? innerCall.apply(this, arguments) : undefined
            }
            
            //augment modifier results in hypotetical INNER call of the same method in subclass 
            var res = this.INNER.apply(this, arguments)
            
            //restore previous INNER chain
            this.INNER = beforeINNER
            
            return res
        }
        
        AUGMENT.methodName  = params.name
        AUGMENT.SUPER       = params.superProto
        AUGMENT.IS_AUGMENT  = true
        
        return AUGMENT
    },
    
    getDisplayName : function (target) {
        return target.meta.name + '[augment ' + this.name + ']'
    }
    
}).c;
Joose.Managed.PropertySet = new Joose.Proto.Class('Joose.Managed.PropertySet', {
    
    isa                       : Joose.Managed.Property,

    properties                : null,
    
    propertyMetaClass         : Joose.Managed.Property,
    
    
    initialize : function (props) {
        Joose.Managed.PropertySet.superClass.initialize.call(this, props)
        
        //XXX this guards the meta roles :)
        this.properties = props.properties || {}
    },
    
    
    addProperty : function (name, props) {
        var metaClass = props.meta || this.propertyMetaClass
        delete props.meta
        
        props.definedIn     = this
        props.name          = name
        
        return this.properties[name] = new metaClass(props)
    },
    
    
    addPropertyObject : function (object) {
        return this.properties[object.name] = object
    },
    
    
    removeProperty : function (name) {
        var prop = this.properties[name]
        
        delete this.properties[name]
        
        return prop
    },
    
    
    haveProperty : function (name) {
        return this.properties[name] != null
    },
    

    haveOwnProperty : function (name) {
        return this.haveProperty(name) && this.properties.hasOwnProperty(name)
    },
    
    
    getProperty : function (name) {
        return this.properties[name]
    },
    
    
    //includes inherited properties (probably you wants 'eachOwn', which process only "own" (including consumed from Roles) properties) 
    each : function (func, scope) {
        Joose.O.each(this.properties, func, scope || this)
    },
    
    
    eachOwn : function (func, scope) {
        Joose.O.eachOwn(this.properties, func, scope || this)
    },
    
    
    //synonym for each
    eachAll : function (func, scope) {
        this.each(func, scope)
    },
    
    
    cloneProps : function () {
        var props = Joose.Managed.PropertySet.superClass.cloneProps.call(this)
        
        props.propertyMetaClass     = this.propertyMetaClass
        
        return props
    },
    
    
    clone : function (name) {
        var clone = this.cleanClone(name)
        
        clone.properties = Joose.O.copyOwn(this.properties)
        
        return clone
    },
    
    
    cleanClone : function (name) {
        var props = this.cloneProps()
        
        props.name = name || props.name
        
        return new this.constructor(props)
    },
    
    
    alias : function (what) {
        var props = this.properties
        
        Joose.O.each(what, function (aliasName, originalName) {
            var original = props[originalName]
            
            if (original) this.addPropertyObject(original.clone(aliasName))
        }, this)
    },
    
    
    exclude : function (what) {
        var props = this.properties
        
        Joose.A.each(what, function (name) {
            delete props[name]
        })
    },
    
    
    beforeConsumedBy : function () {
    },
    
    
    flattenTo : function (target) {
        var targetProps = target.properties
        
        this.eachOwn(function (property, name) {
            var targetProperty = targetProps[name]
            
            if (targetProperty instanceof Joose.Managed.Property.ConflictMarker) return
            
            if (!targetProps.hasOwnProperty(name) || targetProperty == null) {
                target.addPropertyObject(property)
                return
            }
            
            if (targetProperty == property) return
            
            target.removeProperty(name)
            target.addProperty(name, {
                meta : Joose.Managed.Property.ConflictMarker
            })
        }, this)
    },
    
    
    composeTo : function (target) {
        this.eachOwn(function (property, name) {
            if (!target.haveOwnProperty(name)) target.addPropertyObject(property)
        })
    },
    
    
    composeFrom : function () {
        if (!arguments.length) return
        
        var flattening = this.cleanClone()
        
        Joose.A.each(arguments, function (arg) {
            var isDescriptor    = !(arg instanceof Joose.Managed.PropertySet)
            var propSet         = isDescriptor ? arg.propertySet : arg
            
            propSet.beforeConsumedBy(this, flattening)
            
            if (isDescriptor) {
                if (arg.alias || arg.exclude)   propSet = propSet.clone()
                if (arg.alias)                  propSet.alias(arg.alias)
                if (arg.exclude)                propSet.exclude(arg.exclude)
            }
            
            propSet.flattenTo(flattening)
        }, this)
        
        flattening.composeTo(this)
    },
    
    
    preApply : function (target) {
        this.eachOwn(function (property) {
            property.preApply(target)
        })
    },
    
    
    apply : function (target) {
        this.eachOwn(function (property) {
            property.apply(target)
        })
    },
    
    
    unapply : function (from) {
        this.eachOwn(function (property) {
            property.unapply(from)
        })
    },
    
    
    postUnApply : function (target) {
        this.eachOwn(function (property) {
            property.postUnApply(target)
        })
    }
    
}).c
;
var __ID__ = 1


Joose.Managed.PropertySet.Mutable = new Joose.Proto.Class('Joose.Managed.PropertySet.Mutable', {
    
    isa                 : Joose.Managed.PropertySet,

    ID                  : null,
    
    derivatives         : null,
    
    opened              : null,
    
    composedFrom        : null,
    
    
    initialize : function (props) {
        Joose.Managed.PropertySet.Mutable.superClass.initialize.call(this, props)
        
        //initially opened
        this.opened             = 1
        this.derivatives        = {}
        this.ID                 = __ID__++
        this.composedFrom       = []
    },
    
    
    addComposeInfo : function () {
        this.ensureOpen()
        
        Joose.A.each(arguments, function (arg) {
            this.composedFrom.push(arg)
            
            var propSet = arg instanceof Joose.Managed.PropertySet ? arg : arg.propertySet
                
            propSet.derivatives[this.ID] = this
        }, this)
    },
    
    
    removeComposeInfo : function () {
        this.ensureOpen()
        
        Joose.A.each(arguments, function (arg) {
            
            var i = 0
            
            while (i < this.composedFrom.length) {
                var propSet = this.composedFrom[i]
                propSet = propSet instanceof Joose.Managed.PropertySet ? propSet : propSet.propertySet
                
                if (arg == propSet) {
                    delete propSet.derivatives[this.ID]
                    this.composedFrom.splice(i, 1)
                } else i++
            }
            
        }, this)
    },
    
    
    ensureOpen : function () {
        if (!this.opened) throw "Mutation of closed property set: [" + this.name + "]"
    },
    
    
    addProperty : function (name, props) {
        this.ensureOpen()
        
        return Joose.Managed.PropertySet.Mutable.superClass.addProperty.call(this, name, props)
    },
    

    addPropertyObject : function (object) {
        this.ensureOpen()
        
        return Joose.Managed.PropertySet.Mutable.superClass.addPropertyObject.call(this, object)
    },
    
    
    removeProperty : function (name) {
        this.ensureOpen()
        
        return Joose.Managed.PropertySet.Mutable.superClass.removeProperty.call(this, name)
    },
    
    
    composeFrom : function () {
        this.ensureOpen()
        
        return Joose.Managed.PropertySet.Mutable.superClass.composeFrom.apply(this, this.composedFrom)
    },
    
    
    open : function () {
        this.opened++
        
        if (this.opened == 1) {
        
            Joose.O.each(this.derivatives, function (propSet) {
                propSet.open()
            })
            
            this.deCompose()
        }
    },
    
    
    close : function () {
        if (!this.opened) throw "Unmatched 'close' operation on property set: [" + this.name + "]"
        
        if (this.opened == 1) {
            this.reCompose()
            
            Joose.O.each(this.derivatives, function (propSet) {
                propSet.close()
            })
        }
        this.opened--
    },
    
    
    reCompose : function () {
        this.composeFrom()
    },
    
    
    deCompose : function () {
        this.eachOwn(function (property, name) {
            if (property.definedIn != this) this.removeProperty(name)
        }, this)
    }
    
}).c;
Joose.Managed.StemElement = function () { throw "Modules may not be instantiated." }

Joose.Managed.StemElement.Attributes = new Joose.Proto.Class('Joose.Managed.StemElement.Attributes', {
    
    isa                     : Joose.Managed.PropertySet.Mutable,
    
    propertyMetaClass       : Joose.Managed.Property.Attribute
    
}).c
;
Joose.Managed.StemElement.Methods = new Joose.Proto.Class('Joose.Managed.StemElement.Methods', {
    
    isa : Joose.Managed.PropertySet.Mutable,
    
    propertyMetaClass : Joose.Managed.Property.MethodModifier.Put,

    
    preApply : function () {
    },
    
    
    postUnApply : function () {
    }
    
}).c;
Joose.Managed.StemElement.Requirements = new Joose.Proto.Class('Joose.Managed.StemElement.Requirements', {

    isa                     : Joose.Managed.PropertySet.Mutable,
    
    propertyMetaClass       : Joose.Managed.Property.Requirement,
    
    
    
    alias : function () {
    },
    
    
    exclude : function () {
    },
    
    
    flattenTo : function (target) {
        this.each(function (property, name) {
            if (!target.haveProperty(name)) target.addPropertyObject(property)
        })
    },
    
    
    composeTo : function (target) {
        this.flattenTo(target)
    },
    
    
    preApply : function () {
    },
    
    
    postUnApply : function () {
    }
    
}).c;
Joose.Managed.StemElement.MethodModifiers = new Joose.Proto.Class('Joose.Managed.StemElement.MethodModifiers', {

    isa                     : Joose.Managed.PropertySet.Mutable,
    
    propertyMetaClass       : null,
    
    
    addProperty : function (name, props) {
        var metaClass = props.meta
        delete props.meta
        
        props.definedIn         = this
        props.name              = name
        
        var modifier            = new metaClass(props)
        var properties          = this.properties
        
        if (!properties[name]) properties[ name ] = []
        
        properties[name].push(modifier)
        
        return modifier
    },
    

    addPropertyObject : function (object) {
        var name            = object.name
        var properties      = this.properties
        
        if (!properties[name]) properties[name] = []
        
        properties[name].push(object)
        
        return object
    },
    
    
    //remove only the last modifier
    removeProperty : function (name) {
        if (!this.haveProperty(name)) return undefined
        
        var properties      = this.properties
        var modifier        = properties[ name ].pop()
        
        //if all modifiers were removed - clearing the properties
        if (!properties[name].length) Joose.Managed.StemElement.MethodModifiers.superClass.removeProperty.call(this, name)
        
        return modifier
    },
    
    
    alias : function () {
    },
    
    
    exclude : function () {
    },
    
    
    flattenTo : function (target) {
        var targetProps = target.properties
        
        this.each(function (modifiersArr, name) {
            var targetModifiersArr = targetProps[name]
            
            if (targetModifiersArr == null) targetModifiersArr = targetProps[name] = []
            
            Joose.A.each(modifiersArr, function (modifier) {
                if (!Joose.A.exists(targetModifiersArr, modifier)) targetModifiersArr.push(modifier)
            })
            
        })
    },
    
    
    composeTo : function (target) {
        this.flattenTo(target)
    },

    
    deCompose : function () {
        this.each(function (modifiersArr, name) {
            var i = 0
            
            while (i < modifiersArr.length) 
                if (modifiersArr[i].definedIn != this) 
                    modifiersArr.splice(i, 1)
                else 
                    i++
        })
    },
    
    
    preApply : function (target) {
    },

    
    postUnApply : function (target) {
    },
    
    
    apply : function (target) {
        this.each(function (modifiersArr, name) {
            Joose.A.each(modifiersArr, function (modifier) {
                modifier.apply(target)
            })
        })
    },
    
    
    unapply : function (from) {
        this.each(function (modifiersArr, name) {
            for (var i = modifiersArr.length - 1; i >=0 ; i--) modifiersArr[i].unapply(from)
        })
    }
    
    
    
}).c;
Joose.Managed.PropertySet.Composition = new Joose.Proto.Class('Joose.Managed.PropertySet.Composition', {
    
    isa                         : Joose.Managed.PropertySet.Mutable,
    
    propertyMetaClass           : Joose.Managed.PropertySet.Mutable,
    
    processOrder                : null,

    
    each : function (func, scope) {
        var props   = this.properties
        var scope   = scope || this
        
        Joose.A.each(this.processOrder, function (name) {
            func.call(scope, props[name], name)
        })
    },
    
    
    eachR : function (func, scope) {
        var props   = this.properties
        var scope   = scope || this
        
        Joose.A.eachR(this.processOrder, function (name) {
            func.call(scope, props[name], name)
        })
        
        
//        var props           = this.properties
//        var processOrder    = this.processOrder
//        
//        for(var i = processOrder.length - 1; i >= 0; i--) 
//            func.call(scope || this, props[ processOrder[i] ], processOrder[i])
    },
    
    
    clone : function (name) {
        var clone = this.cleanClone(name)
        
        this.each(function (property) {
            clone.addPropertyObject(property.clone())
        })
        
        return clone
    },
    
    
    alias : function (what) {
        this.each(function (property) {
            property.alias(what)
        })
    },
    
    
    exclude : function (what) {
        this.each(function (property) {
            property.exclude(what)
        })
    },
    
    
    flattenTo : function (target) {
        var targetProps = target.properties
        
        this.each(function (property, name) {
            var subTarget = targetProps[name] || target.addProperty(name, {
                meta : property.constructor
            })
            
            property.flattenTo(subTarget)
        })
    },
    
    
    composeTo : function (target) {
        var targetProps = target.properties
        
        this.each(function (property, name) {
            var subTarget = targetProps[name] || target.addProperty(name, {
                meta : property.constructor
            })
            
            property.composeTo(subTarget)
        })
    },
    
    
    
    deCompose : function () {
        this.eachR(function (property) {
            property.open()
        })
        
        Joose.Managed.PropertySet.Composition.superClass.deCompose.call(this)
    },
    
    
    reCompose : function () {
        Joose.Managed.PropertySet.Composition.superClass.reCompose.call(this)
        
        this.each(function (property) {
            property.close()
        })
    },
    
    
    unapply : function (from) {
        this.eachR(function (property) {
            property.unapply(from)
        })
    }
    
}).c
;
Joose.Managed.Stem = new Joose.Proto.Class('Joose.Managed.Stem', {
    
    isa                  : Joose.Managed.PropertySet.Composition,
    
    targetMeta           : null,
    
    attributesMC         : Joose.Managed.StemElement.Attributes,
    methodsMC            : Joose.Managed.StemElement.Methods,
    requirementsMC       : Joose.Managed.StemElement.Requirements,
    methodsModifiersMC   : Joose.Managed.StemElement.MethodModifiers,
    
    processOrder         : [ 'attributes', 'methods', 'requirements', 'methodsModifiers' ],
    
    
    initialize : function (props) {
        Joose.Managed.Stem.superClass.initialize.call(this, props)
        
        var targetMeta = this.targetMeta
        
        this.addProperty('attributes', {
            meta : this.attributesMC,
            
            //it can be no 'targetMeta' in clones
            properties : targetMeta ? targetMeta.attributes : {}
        })
        
        
        this.addProperty('methods', {
            meta : this.methodsMC,
            
            properties : targetMeta ? targetMeta.methods : {}
        })
        
        
        this.addProperty('requirements', {
            meta : this.requirementsMC
        })
        
        
        this.addProperty('methodsModifiers', {
            meta : this.methodsModifiersMC
        })
    },
    
    
    reCompose : function () {
        var c       = this.targetMeta.c
        
        this.preApply(c)
        
        Joose.Managed.Stem.superClass.reCompose.call(this)
        
        this.apply(c)
    },
    
    
    deCompose : function () {
        var c       = this.targetMeta.c
        
        this.unapply(c)
        
        Joose.Managed.Stem.superClass.deCompose.call(this)
        
        this.postUnApply(c)
    }
    
    
}).c
;
Joose.Managed.Builder = new Joose.Proto.Class('Joose.Managed.Builder', {
    
    targetMeta          : null,
    
    
    _buildStart : function (targetMeta, props) {
        targetMeta.stem.open()
        
        Joose.A.each([ 'trait', 'traits', 'removeTrait', 'removeTraits', 'does', 'doesnot', 'doesnt' ], function (builder) {
            if (props[builder]) {
                this[builder](targetMeta, props[builder])
                delete props[builder]
            }
        }, this)
    },
    
    
    _extend : function (props) {
        if (Joose.O.isEmpty(props)) return
        
        var targetMeta = this.targetMeta
        
        this._buildStart(targetMeta, props)
        
        Joose.O.eachOwn(props, function (value, name) {
            var handler = this[name]
            
            if (!handler) throw new Error("Unknown builder [" + name + "] was used during extending of [" + targetMeta.c + "]")
            
            handler.call(this, targetMeta, value)
        }, this)
        
        this._buildComplete(targetMeta, props)
    },
    

    _buildComplete : function (targetMeta, props) {
        targetMeta.stem.close()
    },
    
    
    methods : function (targetMeta, info) {
        Joose.O.eachOwn(info, function (value, name) {
            targetMeta.addMethod(name, value)
        })
    },
    

    removeMethods : function (targetMeta, info) {
        Joose.A.each(info, function (name) {
            targetMeta.removeMethod(name)
        })
    },
    
    
    have : function (targetMeta, info) {
        Joose.O.eachOwn(info, function (value, name) {
            targetMeta.addAttribute(name, value)
        })
    },
    
    
    havenot : function (targetMeta, info) {
        Joose.A.each(info, function (name) {
            targetMeta.removeAttribute(name)
        })
    },
    

    havent : function (targetMeta, info) {
        this.havenot(targetMeta, info)
    },
    
    
    after : function (targetMeta, info) {
        Joose.O.each(info, function (value, name) {
            targetMeta.addMethodModifier(name, value, Joose.Managed.Property.MethodModifier.After)
        })
    },
    
    
    before : function (targetMeta, info) {
        Joose.O.each(info, function (value, name) {
            targetMeta.addMethodModifier(name, value, Joose.Managed.Property.MethodModifier.Before)
        })
    },
    
    
    override : function (targetMeta, info) {
        Joose.O.each(info, function (value, name) {
            targetMeta.addMethodModifier(name, value, Joose.Managed.Property.MethodModifier.Override)
        })
    },
    
    
    around : function (targetMeta, info) {
        Joose.O.each(info, function (value, name) {
            targetMeta.addMethodModifier(name, value, Joose.Managed.Property.MethodModifier.Around)
        })
    },
    
    
    augment : function (targetMeta, info) {
        Joose.O.each(info, function (value, name) {
            targetMeta.addMethodModifier(name, value, Joose.Managed.Property.MethodModifier.Augment)
        })
    },
    
    
    removeModifier : function (targetMeta, info) {
        Joose.A.each(info, function (name) {
            targetMeta.removeMethodModifier(name)
        })
    },
    
    
    does : function (targetMeta, info) {
        Joose.A.each(Joose.O.wantArray(info), function (desc) {
            targetMeta.addRole(desc)
        })
    },
    

    doesnot : function (targetMeta, info) {
        Joose.A.each(Joose.O.wantArray(info), function (desc) {
            targetMeta.removeRole(desc)
        })
    },
    
    
    doesnt : function (targetMeta, info) {
        this.doesnot(targetMeta, info)
    },
    
    
    trait : function () {
        this.traits.apply(this, arguments)
    },
    
    
    traits : function (targetMeta, info) {
        if (targetMeta.firstPass) return
        
        if (!targetMeta.meta.isDetached) throw "Can't apply trait to not detached class"
        
        targetMeta.meta.extend({
            does : info
        })
    },
    
    
    removeTrait : function () {
        this.removeTraits.apply(this, arguments)
    },
     
    
    removeTraits : function (targetMeta, info) {
        if (!targetMeta.meta.isDetached) throw "Can't remove trait from not detached class"
        
        targetMeta.meta.extend({
            doesnot : info
        })
    },
    
    name : function (targetMeta, name) {
        targetMeta.name     = name
    }
    
}).c;
Joose.Managed.Class = new Joose.Proto.Class('Joose.Managed.Class', {
    
    isa                         : Joose.Proto.Class,
    
    stem                        : null,
    stemClass                   : Joose.Managed.Stem,
    stemClassCreated            : false,
    
    builder                     : null,
    builderClass                : Joose.Managed.Builder,
    builderClassCreated         : false,
    
    isDetached                  : false,
    firstPass                   : true,
    
    // a special instance, which, when passed as 1st argument to constructor, signifies that constructor should
    // skips traits processing for this instance
    skipTraitsAnchor            : {},
    
    
    //build for metaclasses - collects traits from roles
    BUILD : function () {
        var sup = Joose.Managed.Class.superClass.BUILD.apply(this, arguments)
        
        var props   = sup.__extend__
        
        var traits = Joose.O.wantArray(props.trait || props.traits || [])
        delete props.trait
        delete props.traits
        
        Joose.A.each(Joose.O.wantArray(props.does || []), function (arg) {
            var role = (arg.meta instanceof Joose.Managed.Class) ? arg : arg.role
            
            if (role.meta.meta.isDetached) traits.push(role.meta.constructor)
        })
        
        if (traits.length) props.traits = traits 
        
        return sup
    },
    
    
    initInstance : function (instance, props) {
        Joose.O.each(this.attributes, function (attribute, name) {
            
            if (attribute instanceof Joose.Managed.Attribute) 
                attribute.initFromConfig(instance, props)
            else 
                if (props.hasOwnProperty(name)) instance[name] = props[name]
        })
    },
    
    
    // we are using the same constructor for usual and meta- classes
    defaultConstructor: function () {
        return function (skipTraitsAnchor, params) {
            
            var thisMeta    = this.meta
            var skipTraits  = skipTraitsAnchor == thisMeta.skipTraitsAnchor
            
            var BUILD       = this.BUILD
            
            var props       = BUILD && BUILD.apply(this, skipTraits ? params : arguments) || (skipTraits ? params[0] : skipTraitsAnchor) || {}
            
            
            // either looking for traits in __extend__ (meta-class) or in usual props (usual class)
            var extend  = props.__extend__ || props
            
            var traits = extend.trait || extend.traits
            
            if (traits || extend.detached) {
                delete extend.trait
                delete extend.traits
                delete extend.detached
                
                if (!skipTraits) {
                    var classWithTrait  = thisMeta.subClass({ does : traits || [] }, thisMeta.name)
                    var meta            = classWithTrait.meta
                    meta.isDetached     = true
                    
                    return meta.instantiate(thisMeta.skipTraitsAnchor, arguments)
                }
            }
            
            thisMeta.initInstance(this, props)
            
            return thisMeta.hasMethod('initialize') && this.initialize(props) || this
        }
    },
    
    
    finalize: function (extend) {
        Joose.Managed.Class.superClass.finalize.call(this, extend)
        
        this.stem.close()
        
        this.afterMutate()
    },
    
    
    processStem : function () {
        Joose.Managed.Class.superClass.processStem.call(this)
        
        this.builder    = new this.builderClass({ targetMeta : this })
        this.stem       = new this.stemClass({ name : this.name, targetMeta : this })
        
        var builderClass = this.getClassInAttribute('builderClass')
        
        if (builderClass) {
            this.builderClassCreated = true
            this.addAttribute('builderClass', this.subClassOf(builderClass))
        }
        
        
        var stemClass = this.getClassInAttribute('stemClass')
        
        if (stemClass) {
            this.stemClassCreated = true
            this.addAttribute('stemClass', this.subClassOf(stemClass))
        }
    },
    
    
    extend : function (props) {
        if (props.builder) {
            this.getBuilderTarget().meta.extend(props.builder)
            delete props.builder
        }
        
        if (props.stem) {
            this.getStemTarget().meta.extend(props.stem)
            delete props.stem
        }
        
        this.builder._extend(props)
        
        this.firstPass = false
        
        if (!this.stem.opened) this.afterMutate()
    },
    
    
    getBuilderTarget : function () {
        var builderClass = this.getClassInAttribute('builderClass')
        if (!builderClass) throw "Attempt to extend a builder on non-meta class"
        
        return builderClass
    },
    

    getStemTarget : function () {
        var stemClass = this.getClassInAttribute('stemClass')
        if (!stemClass) throw "Attempt to extend a stem on non-meta class"
        
        return stemClass
    },
    
    
    getClassInAttribute : function (attributeName) {
        var attrClass = this.getAttribute(attributeName)
        if (attrClass instanceof Joose.Managed.Property.Attribute) attrClass = attrClass.value
        
        return attrClass
    },
    
    
    addMethodModifier: function (name, func, type) {
        var props = {}
        
        props.init = func
        props.meta = type
        
        return this.stem.properties.methodsModifiers.addProperty(name, props)
    },
    
    
    removeMethodModifier: function (name) {
        return this.stem.properties.methodsModifiers.removeProperty(name)
    },
    
    
    addMethod: function (name, func, props) {
        props = props || {}
        props.init = func
        
        return this.stem.properties.methods.addProperty(name, props)
    },
    
    
    addAttribute: function (name, init, props) {
        props = props || {}
        props.init = init
        
        return this.stem.properties.attributes.addProperty(name, props)
    },
    
    
    removeMethod : function (name) {
        return this.stem.properties.methods.removeProperty(name)
    },

    
    removeAttribute: function (name) {
        return this.stem.properties.attributes.removeProperty(name)
    },
    
    
    hasMethod: function (name) {
        return this.stem.properties.methods.haveProperty(name)
    },
    
    
    hasAttribute: function (name) { 
        return this.stem.properties.attributes.haveProperty(name)
    },
    
    
    hasMethodModifiersFor : function (name) {
        return this.stem.properties.methodsModifiers.haveProperty(name)
    },
    
    
    hasOwnMethod: function (name) {
        return this.stem.properties.methods.haveOwnProperty(name)
    },
    
    
    hasOwnAttribute: function (name) { 
        return this.stem.properties.attributes.haveOwnProperty(name)
    },
    

    getMethod : function (name) {
        return this.stem.properties.methods.getProperty(name)
    },
    
    
    getAttribute : function (name) {
        return this.stem.properties.attributes.getProperty(name)
    },
    
    
    eachRole : function (roles, func, scope) {
        Joose.A.each(roles, function (arg, index) {
            var role = (arg.meta instanceof Joose.Managed.Class) ? arg : arg.role
            
            func.call(scope || this, arg, role, index)
        }, this)
    },
    
    
    addRole : function () {
        
        this.eachRole(arguments, function (arg, role) {
            
            this.beforeRoleAdd(role)
            
            var desc = arg
            
            //compose descriptor can contain 'alias' and 'exclude' fields, in this case actual reference should be stored
            //into 'propertySet' field
            if (role != arg) {
                desc.propertySet = role.meta.stem
                delete desc.role
            } else
                desc = desc.meta.stem
            
            this.stem.addComposeInfo(desc)
            
        }, this)
    },
    
    
    beforeRoleAdd : function (role) {
        var roleMeta = role.meta
        
        if (roleMeta.builderClassCreated) this.getBuilderTarget().meta.extend({
            does : [ roleMeta.getBuilderTarget() ]
        })
        
        if (roleMeta.stemClassCreated) this.getStemTarget().meta.extend({
            does : [ roleMeta.getStemTarget() ]
        })
        
        if (roleMeta.meta.isDetached && !this.firstPass) this.builder.traits(this, roleMeta.constructor)
    },
    
    
    beforeRoleRemove : function (role) {
        var roleMeta = role.meta
        
        if (roleMeta.builderClassCreated) this.getBuilderTarget().meta.extend({
            doesnt : [ roleMeta.getBuilderTarget() ]
        })
        
        if (roleMeta.stemClassCreated) this.getStemTarget().meta.extend({
            doesnt : [ roleMeta.getStemTarget() ]
        })
        
        if (roleMeta.meta.isDetached && !this.firstPass) this.builder.removeTraits(this, roleMeta.constructor)
    },
    
    
    removeRole : function () {
        this.eachRole(arguments, function (arg, role) {
            this.beforeRoleRemove(role)
            
            this.stem.removeComposeInfo(role.meta.stem)
        }, this)
    },
    
    
    getRoles : function () {
        
        return Joose.A.map(this.stem.composedFrom, function (composeDesc) {
            //compose descriptor can contain 'alias' and 'exclude' fields, in this case actual reference is stored
            //into 'propertySet' field
            if (!(composeDesc instanceof Joose.Managed.PropertySet)) return composeDesc.propertySet
            
            return composeDesc.targetMeta.c
        })
    },
    
    
    does : function (role) {
        var myRoles = this.getRoles()
        
        for (var i = 0; i < myRoles.length; i++) if (role == myRoles[i]) return true
        for (var i = 0; i < myRoles.length; i++) if (myRoles[i].meta.does(role)) return true
        
        var superMeta = this.superClass.meta
        
        // considering the case of inheriting from non-Joose classes
        if (this.superClass != Joose.Proto.Empty && superMeta && superMeta.meta && superMeta.meta.hasMethod('does')) return superMeta.does(role)
        
        return false
    },
    
    
    getMethods : function () {
        return this.stem.properties.methods
    },
    
    
    getAttributes : function () {
        return this.stem.properties.attributes
    },
    
    
    afterMutate : function () {
    },
    
    
    getCurrentMethod : function () {
        for (var wrapper = arguments.callee.caller, count = 0; wrapper && count < 5; wrapper = wrapper.caller, count++)
            if (wrapper.__METHOD__) return wrapper.__METHOD__
        
        return null
    }
    
    
}).c;
Joose.Managed.Role = new Joose.Managed.Class('Joose.Managed.Role', {
    
    isa                         : Joose.Managed.Class,
    
    have : {
        defaultSuperClass       : Joose.Proto.Empty,
        
        builderRole             : null,
        stemRole                : null
    },
    
    
    methods : {
        
        defaultConstructor : function () {
            return function () {
                throw new Error("Roles cant be instantiated")
            }
        },
        

        processSuperClass : function () {
            if (this.superClass != this.defaultSuperClass) throw new Error("Roles can't inherit from anything")
        },
        
        
        getBuilderTarget : function () {
            if (!this.builderRole) {
                this.builderRole = new this.constructor().c
                this.builderClassCreated = true
            }
            
            return this.builderRole
        },
        
    
        getStemTarget : function () {
            if (!this.stemRole) {
                this.stemRole = new this.constructor().c
                this.stemClassCreated = true
            }
            
            return this.stemRole
        },
        
    
        addRequirement : function (methodName) {
            this.stem.properties.requirements.addProperty(methodName, {})
        }
        
    },
    

    stem : {
        methods : {
            
            apply : function () {
            },
            
            
            unapply : function () {
            }
        }
    },
    
    
    builder : {
        methods : {
            requires : function (targetClassMeta, info) {
                Joose.A.each(Joose.O.wantArray(info), function (methodName) {
                    targetClassMeta.addRequirement(methodName)
                }, this)
            }
        }
    }
    
}).c;
Joose.Managed.Attribute = new Joose.Managed.Class('Joose.Managed.Attribute', {
    
    isa : Joose.Managed.Property.Attribute,
    
    have : {
        is              : null,
        
        builder         : null,
        
        isPrivate       : false,
        
        role            : null,
        
        publicName      : null,
        setterName      : null,
        getterName      : null,
        
        //indicates the logical readableness/writeableness of the attribute
        readable        : false,
        writeable       : false,
        
        //indicates the physical presense of the accessor (may be absent for "combined" accessors for example)
        hasGetter       : false,
        hasSetter       : false,
        
        required        : false,
        
        canInlineSetRaw : true,
        canInlineGetRaw : true
    },
    
    
    after : {
        initialize : function () {
            var name = this.name
            
            this.publicName = name.replace(/^_+/, '')
            
            this.slot = this.isPrivate ? '$' + name : name
            
            this.setterName = this.setterName || this.getSetterName()
            this.getterName = this.getterName || this.getGetterName()
            
            this.readable  = this.hasGetter = /^r/i.test(this.is)
            this.writeable = this.hasSetter = /^.w/i.test(this.is)
        }
    },
    
    
    override : {
        
        computeValue : function () {
            var init    = this.init
            
            if (Joose.O.isClass(init) || !Joose.O.isFunction(init)) this.SUPER()
        },
        
        
        preApply : function (targetClass) {
            targetClass.meta.extend({
                methods : this.getAccessorsFor(targetClass)
            })
        },
        
        
        postUnApply : function (from) {
            from.meta.extend({
                removeMethods : this.getAccessorsFrom(from)
            })
        }
        
    },
    
    
    methods : {
        
        getAccessorsFor : function (targetClass) {
            var targetMeta = targetClass.meta
            var setterName = this.setterName
            var getterName = this.getterName
            
            var methods = {}
            
            if (this.hasSetter && !targetMeta.hasMethod(setterName)) {
                methods[setterName] = this.getSetter()
                methods[setterName].ACCESSOR_FROM = this
            }
            
            if (this.hasGetter && !targetMeta.hasMethod(getterName)) {
                methods[getterName] = this.getGetter()
                methods[getterName].ACCESSOR_FROM = this
            }
            
            return methods
        },
        
        
        getAccessorsFrom : function (from) {
            var targetMeta = from.meta
            var setterName = this.setterName
            var getterName = this.getterName
            
            var setter = this.hasSetter && targetMeta.getMethod(setterName)
            var getter = this.hasGetter && targetMeta.getMethod(getterName)
            
            var removeMethods = []
            
            if (setter && setter.value.ACCESSOR_FROM == this) removeMethods.push(setterName)
            if (getter && getter.value.ACCESSOR_FROM == this) removeMethods.push(getterName)
            
            return removeMethods
        },
        
        
        getGetterName : function () {
            return 'get' + Joose.S.uppercaseFirst(this.publicName)
        },


        getSetterName : function () {
            return 'set' + Joose.S.uppercaseFirst(this.publicName)
        },
        
        
        getSetter : function () {
            var me      = this
            var slot    = me.slot
            
            if (me.canInlineSetRaw)
                return function (value) {
                    this[ slot ] = value
                    
                    return this
                }
            else
                return function () {
                    return me.setRawValueTo.apply(this, arguments)
                }
        },
        
        
        getGetter : function () {
            var me      = this
            var slot    = me.slot
            
            if (me.canInlineGetRaw)
                return function (value) {
                    return this[ slot ]
                }
            else
                return function () {
                    return me.getRawValueFrom.apply(this, arguments)
                }
        },
        
        
        getValueFrom : function (instance) {
            var getterName      = this.getterName
            
            if (this.readable && instance.meta.hasMethod(getterName)) return instance[ getterName ]()
            
            return this.getRawValueFrom(instance)
        },
        
        
        setValueTo : function (instance, value) {
            var setterName      = this.setterName
            
            if (this.writeable && instance.meta.hasMethod(setterName)) 
                instance[ setterName ](value)
            else
                this.setRawValueTo(instance, value)
        },
        
        
        initFromConfig : function (instance, config) {
            var name            = this.name
            
            var value, isSet = false
            
            if (config.hasOwnProperty(name)) {
                value = config[name]
                isSet = true
            } else {
                var init    = this.init
                
                // simple function (not class) has been used as "init" value
                if (Joose.O.isFunction(init) && !Joose.O.isClass(init)) {
                    
                    value = init.call(instance, config, name)
                    
                    isSet = true
                    
                } else if (this.builder) {
                    
                    value = instance[ this.builder.replace(/^this\./, '') ](config, name)
                    isSet = true
                }
            }
            
            if (isSet)
                this.setRawValueTo(instance, value)
            else 
                if (this.required) throw new Error("Required attribute [" + name + "] is missed during initialization of " + instance)
        }
    }

}).c
;
Joose.Managed.Attribute.Builder = new Joose.Managed.Role('Joose.Managed.Attribute.Builder', {
    
    
    have : {
        defaultAttributeClass : Joose.Managed.Attribute
    },
    
    builder : {
        
        methods : {
            
            has : function (targetClassMeta, info) {
                Joose.O.eachOwn(info, function (props, name) {
                    if (typeof props != 'object' || props == null || props.constructor == / /.constructor) props = { init : props }
                    
                    props.meta = props.meta || targetClassMeta.defaultAttributeClass
                    
                    if (/^__/.test(name)) {
                        name = name.replace(/^_+/, '')
                        
                        props.isPrivate = true
                    }
                    
                    targetClassMeta.addAttribute(name, props.init, props)
                }, this)
            },
            
            
            hasnot : function (targetClassMeta, info) {
                this.havenot(targetClassMeta, info)
            },
            
            
            hasnt : function (targetClassMeta, info) {
                this.hasnot(targetClassMeta, info)
            }
        }
            
    }
    
}).c
;
Joose.Managed.My = new Joose.Managed.Role('Joose.Managed.My', {
    
    have : {
        myClass                         : null,
        
        needToReAlias                   : false
    },
    
    
    methods : {
        createMy : function (extend) {
            var thisMeta        = this.meta
            var isRole          = this instanceof Joose.Managed.Role
            
            var myExtend        = extend.my || {}
            delete extend.my
            
            // Symbiont will generally have the same meta class as its hoster, excepting the cases, when the superclass also have the symbiont. 
            // In such cases, the meta class for symbiont will be inherited (unless explicitly specified)
            var superClassMy    = this.superClass.meta.myClass
            
            if (!isRole && !myExtend.isa && superClassMy) myExtend.isa = superClassMy
            

            if (!myExtend.meta && !myExtend.isa) myExtend.meta = this.constructor
            
            myExtend.name       = this.name + '.my'
            
            var createdClass    = this.myClass = Class(myExtend)
            
            var c               = this.c
            
            c.prototype.my      = c.my = isRole ? createdClass : new createdClass({ HOST : c })
            
            this.needToReAlias = true
        },
        
        
        aliasStaticMethods : function () {
            this.needToReAlias = false
            
            var c           = this.c
            var myProto     = this.myClass.prototype
            
            Joose.O.eachOwn(c, function (property, name) {
                if (property.IS_ALIAS) delete c[ name ] 
            })
            
            this.myClass.meta.stem.properties.methods.each(function (method, name) {
                
                if (!c[ name ])
                    (c[ name ] = function () {
                        return myProto[ name ].apply(c.my, arguments)
                    }).IS_ALIAS = true
            })
        }
    },
    
    
    override : {
        
        extend : function (props) {
            var myClass = this.myClass
            
            if (!myClass && this.superClass.meta.myClass) this.createMy(props)
            
            if (props.my) {
                if (!myClass) 
                    this.createMy(props)
                else {
                    this.needToReAlias = true
                    
                    myClass.meta.extend(props.my)
                    delete props.my
                }
            }
            
            this.SUPER(props)
            
            if (this.needToReAlias && !(this instanceof Joose.Managed.Role)) this.aliasStaticMethods()
        }  
    },
    
    
    before : {
        
        addRole : function () {
            var myStem
            
            Joose.A.each(arguments, function (arg) {
                
                if (!arg) throw new Error("Attempt to consume an undefined Role into [" + this.name + "]")
                
                //instanceof Class to allow treat classes as roles
                var role = (arg.meta instanceof Joose.Managed.Class) ? arg : arg.role
                
                if (role.meta.meta.hasAttribute('myClass') && role.meta.myClass) {
                    
                    if (!this.myClass) {
                        this.createMy({
                            my : {
                                does : role.meta.myClass
                            }
                        })
                        return
                    }
                    
                    myStem = this.myClass.meta.stem
                    if (!myStem.opened) myStem.open()
                    
                    myStem.addComposeInfo(role.my.meta.stem)
                }
            }, this)
            
            if (myStem) {
                myStem.close()
                
                this.needToReAlias = true
            }
        },
        
        
        removeRole : function () {
            if (!this.myClass) return
            
            var myStem = this.myClass.meta.stem
            myStem.open()
            
            Joose.A.each(arguments, function (role) {
                if (role.meta.meta.hasAttribute('myClass') && role.meta.myClass) {
                    myStem.removeComposeInfo(role.my.meta.stem)
                    
                    this.needToReAlias = true
                }
            }, this)
            
            myStem.close()
        }
        
    }
    
}).c;
Joose.Namespace = Joose.stub()

Joose.Namespace.Able = new Joose.Managed.Role('Joose.Namespace.Able', {

    have : {
        bodyFunc                : null
    },
    
    
    before : {
        extend : function (extend) {
            if (extend.body) {
                this.bodyFunc = extend.body
                delete extend.body
            }
        }
    },
    
    
    after: {
        
        afterMutate : function () {
            var bodyFunc = this.bodyFunc
            delete this.bodyFunc
            
            if (bodyFunc) Joose.Namespace.Manager.my.executeIn(this.c, bodyFunc)
        }
    }
    
}).c;
Joose.Managed.Bootstrap = new Joose.Managed.Role('Joose.Managed.Bootstrap', {
    
    does   : [ Joose.Namespace.Able, Joose.Managed.My, Joose.Managed.Attribute.Builder ]
    
}).c
;
Joose.Meta = Joose.stub()


Joose.Meta.Object = new Joose.Proto.Class('Joose.Meta.Object', {
    
    isa             : Joose.Proto.Object
    
}).c


;
Joose.Meta.Class = new Joose.Managed.Class('Joose.Meta.Class', {
    
    isa                         : Joose.Managed.Class,
    
    does                        : Joose.Managed.Bootstrap,
    
    have : {
        defaultSuperClass       : Joose.Meta.Object
    }
    
}).c

;
Joose.Meta.Role = new Joose.Meta.Class('Joose.Meta.Role', {
    
    isa                         : Joose.Managed.Role,
    
    does                        : Joose.Managed.Bootstrap
    
}).c;
Joose.Namespace.Keeper = new Joose.Meta.Class('Joose.Namespace.Keeper', {
    
    isa         : Joose.Meta.Class,
    
    have        : {
        externalConstructor             : null
    },
    
    
    methods: {
        
        defaultConstructor: function () {
            
            return function () {
                //constructors should assume that meta is attached to 'arguments.callee' (not to 'this') 
                var thisMeta = arguments.callee.meta
                
                if (thisMeta instanceof Joose.Namespace.Keeper) throw new Error("Module [" + thisMeta.c + "] may not be instantiated. Forgot to 'use' the class with the same name?")
                
                var externalConstructor = thisMeta.externalConstructor
                
                if (typeof externalConstructor == 'function') {
                    
                    externalConstructor.meta = thisMeta
                    
                    return externalConstructor.apply(this, arguments)
                }
                
                throw "NamespaceKeeper of [" + thisMeta.name + "] was planted incorrectly."
            }
        },
        
        
        //withClass should be not constructed yet on this stage (see Joose.Proto.Class.construct)
        //it should be on the 'constructorOnly' life stage (should already have constructor)
        plant: function (withClass) {
            var keeper = this.c
            
            keeper.meta = withClass.meta
            
            keeper.meta.c = keeper
            keeper.meta.externalConstructor = withClass
        }
    }
    
}).c


;
Joose.Namespace.Manager = new Joose.Managed.Class('Joose.Namespace.Manager', {
    
    have : {
        current     : null
    },
    
    
    methods : {
        
        initialize : function () {
            this.current    = [ Joose.top ]
        },
        
        
        getCurrent: function () {
            return this.current[0]
        },
        
        
        executeIn : function (ns, func) {
            var current = this.current
            
            current.unshift(ns)
            var res = func.call(ns, ns)
            current.shift()
            
            return res
        },
        
        
        earlyCreate : function (name, metaClass, props) {
            props.constructorOnly = true
            
            return new metaClass(name, props).c
        },
        
        
        //this function establishing the full "namespace chain" (including the last element)
        create : function (nsName, metaClass, extend) {
            
            //if no name provided, then we creating an anonymous class, so just skip all the namespace manipulations
            if (!nsName) return new metaClass(nsName, extend).c
            
            var me = this
            
            if (/^\./.test(nsName)) return this.executeIn(Joose.top, function () {
                return me.create(nsName.replace(/^\./, ''), metaClass, extend)
            })
            
            var props   = extend || {}
            
            var parts   = Joose.S.saneSplit(nsName, '.')
            var object  = this.getCurrent()
            var soFar   = object == Joose.top ? [] : Joose.S.saneSplit(object.meta.name, '.')
            
            for (var i = 0; i < parts.length; i++) {
                var part        = parts[i]
                var isLast      = i == parts.length - 1
                
                if (part == "meta" || part == "my" || !part) throw "Module name [" + nsName + "] may not include a part called 'meta' or 'my' or empty part."
                
                var cur =   object[part]
                
                soFar.push(part)
                
                var soFarName       = soFar.join(".")
                var needFinalize    = false
                var nsKeeper
                
                // if the namespace segment is empty
                if (typeof cur == "undefined") {
                    if (isLast) {
                        // perform "early create" which just fills the namespace segment with right constructor
                        // this allows us to have a right constructor in the namespace segment when the `body` will be called
                        nsKeeper        = this.earlyCreate(soFarName, metaClass, props)
                        needFinalize    = true
                    } else
                        nsKeeper        = new Joose.Namespace.Keeper(soFarName).c
                    
                    object[part] = nsKeeper
                    
                    cur = nsKeeper
                    
                } else if (isLast && cur && cur.meta) {
                    
                    var currentMeta = cur.meta
                    
                    if (metaClass == Joose.Namespace.Keeper)
                        //`Module` over something case - extend the original
                        currentMeta.extend(props)
                    else {
                        
                        if (currentMeta instanceof Joose.Namespace.Keeper) {
                            
                            currentMeta.plant(this.earlyCreate(soFarName, metaClass, props))
                            
                            needFinalize = true
                        } else
                            if (!Joose.C.ignoreRepeatedDeclarations) throw new Error("Double declaration of [" + soFarName + "]")
                    }
                    
                } else 
                    if (isLast && !(cur && cur.meta && cur.meta.meta)) throw "Trying to setup module " + soFarName + " failed. There is already something: " + cur

                // hook to allow embedd resource into meta
                if (isLast) this.prepareMeta(cur.meta)
                    
                if (needFinalize) cur.meta.construct(props)
                    
                object = cur
            }
            
            return object
        },
        
        
        prepareMeta : function () {
        },
        
        
        prepareProperties : function (name, props, defaultMeta, callback) {
            if (name && typeof name != 'string') {
                props   = name
                name    = null
            }
            
            var meta
            
            if (props && props.meta) {
                meta = props.meta
                delete props.meta
            }
            
            if (!meta)
                if (props && typeof props.isa == 'function' && props.isa.meta)
                    meta = props.isa.meta.constructor
                else
                    meta = defaultMeta
            
            return callback.call(this, name, meta, props)
        },
        
        
        getDefaultHelperFor : function (metaClass) {
            var me = this
            
            return function (name, props) {
                return me.prepareProperties(name, props, metaClass, function (name, meta, props) {
                    return me.create(name, meta, props)
                })
            }
        },
        
        
        register : function (helperName, metaClass, func) {
            var me = this
            
            if (this.meta.hasMethod(helperName)) {
                
                var helper = function () {
                    return me[ helperName ].apply(me, arguments)
                }
                
                if (!Joose.top[ helperName ])   Joose.top[ helperName ]         = helper
                if (!Joose[ helperName ])       Joose[ helperName ]             = helper
                
                if (Joose.is_NodeJS && typeof exports != 'undefined')            exports[ helperName ]    = helper
                
            } else {
                var methods = {}
                
                methods[ helperName ] = func || this.getDefaultHelperFor(metaClass)
                
                this.meta.extend({
                    methods : methods
                })
                
                this.register(helperName)
            }
        },
        
        
        Module : function (name, props) {
            return this.prepareProperties(name, props, Joose.Namespace.Keeper, function (name, meta, props) {
                if (typeof props == 'function') props = { body : props }    
                
                return this.create(name, meta, props)
            })
        }
    }
    
}).c

Joose.Namespace.Manager.my = new Joose.Namespace.Manager()

Joose.Namespace.Manager.my.register('Class', Joose.Meta.Class)
Joose.Namespace.Manager.my.register('Role', Joose.Meta.Role)
Joose.Namespace.Manager.my.register('Module')


// for the rest of the package
var Class       = Joose.Class
var Role        = Joose.Role
;
Role('Joose.Attribute.Delegate', {
    
    have : {
        handles : null
    },
    
    
    override : {
        
        eachDelegate : function (handles, func, scope) {
            if (typeof handles == 'string') return func.call(scope, handles, handles)
            
            if (handles instanceof Array)
                return Joose.A.each(handles, function (delegateTo) {
                    
                    func.call(scope, delegateTo, delegateTo)
                })
                
            if (handles === Object(handles))
                Joose.O.eachOwn(handles, function (delegateTo, handleAs) {
                    
                    func.call(scope, handleAs, delegateTo)
                })
        },
        
        
        getAccessorsFor : function (targetClass) {
            var targetMeta  = targetClass.meta
            var methods     = this.SUPER(targetClass)
            
            var me      = this
            
            this.eachDelegate(this.handles, function (handleAs, delegateTo) {
                
                if (!targetMeta.hasMethod(handleAs)) {
                    var handler = methods[ handleAs ] = function () {
                        var attrValue = me.getValueFrom(this)
                        
                        return attrValue[ delegateTo ].apply(attrValue, arguments)
                    }
                    
                    handler.ACCESSOR_FROM = me
                }
            })
            
            return methods
        },
        
        
        getAccessorsFrom : function (from) {
            var methods = this.SUPER(from)
            
            var me          = this
            var targetMeta  = from.meta
            
            this.eachDelegate(this.handles, function (handleAs) {
                
                var handler = targetMeta.getMethod(handleAs)
                
                if (handler && handler.value.ACCESSOR_FROM == me) methods.push(handleAs)
            })
            
            return methods
        }
    }
})

;
Role('Joose.Attribute.Trigger', {
    
    have : {
        trigger        : null
    }, 

    
    after : {
        initialize : function() {
            if (this.trigger) {
                if (!this.writeable) throw new Error("Can't use `trigger` for read-only attributes")
                
                this.hasSetter = true
            }
        }
    },
    
    
    override : {
        
        getSetter : function() {
            var original    = this.SUPER()
            var trigger     = this.trigger
            
            if (!trigger) return original
            
            var me      = this
            var init    = Joose.O.isFunction(me.init) ? null : me.init
            
            return function () {
                var oldValue    = me.hasValue(this) ? me.getValueFrom(this) : init
                
                var res         = original.apply(this, arguments)
                
                trigger.call(this, me.getValueFrom(this), oldValue)
                
                return res
            }
        }
    }
})    

;
Role('Joose.Attribute.Lazy', {
    
    
    have : {
        lazy        : null
    }, 
    
    
    before : {
        computeValue : function () {
            if (typeof this.init == 'function' && this.lazy) {
                this.lazy = this.init    
                delete this.init    
            }
        }
    },
    
    
    after : {
        initialize : function () {
            if (this.lazy) this.readable = this.hasGetter = true
        }
    },
    
    
    override : {
        
        getGetter : function () {
            var original    = this.SUPER()
            var lazy        = this.lazy
            
            if (!lazy) return original
            
            var me      = this    
            
            return function () {
                if (!me.hasValue(this)) {
                    var initializer = typeof lazy == 'function' ? lazy : this[ lazy.replace(/^this\./, '') ]
                    
                    me.setValueTo(this, initializer.apply(this, arguments))
                }
                
                return original.call(this)    
            }
        }
    }
})

;
Role('Joose.Attribute.Accessor.Combined', {
    
    
    have : {
        isCombined        : false
    }, 
    
    
    after : {
        initialize : function() {
            this.isCombined = this.isCombined || /..c/i.test(this.is)
            
            if (this.isCombined) {
                this.slot = '$$' + this.name
                
                this.hasGetter = true
                this.hasSetter = false
                
                this.setterName = this.getterName = this.publicName
            }
        }
    },
    
    
    override : {
        
        getGetter : function() {
            var getter    = this.SUPER()
            
            if (!this.isCombined) return getter
            
            var setter    = this.getSetter()
            
            var me = this
            
            return function () {
                
                if (!arguments.length) {
                    if (me.readable) return getter.call(this)
                    throw new Error("Call to getter of unreadable attribute: [" + me.name + "]")
                }
                
                if (me.writeable) return setter.apply(this, arguments)
                
                throw new Error("Call to setter of read-only attribute: [" + me.name + "]")    
            }
        }
    }
    
})

;
Joose.Managed.Attribute.meta.extend({
    does : [ Joose.Attribute.Delegate, Joose.Attribute.Trigger, Joose.Attribute.Lazy, Joose.Attribute.Accessor.Combined ]
})            

;
Role('Joose.Meta.Singleton', {

    has : {
        forceInstance           : Joose.I.Object,
        instance                : null
    },



    override : {

        defaultConstructor : function () {
            var meta        = this
            var previous    = this.SUPER()

            this.adaptConstructor(previous)

            return function (forceInstance, params) {
                if (forceInstance == meta.forceInstance) return previous.apply(this, params) || this

                var instance = meta.instance

                if (!instance) instance = meta.instance = new meta.c(meta.forceInstance, arguments)

                if (meta.hasMethod('configure')) instance.configure.apply(instance, arguments)

                return instance
            }
        }
    }


})


Joose.Namespace.Manager.my.register('Singleton', Class({
    isa     : Joose.Meta.Class,
    meta    : Joose.Meta.Class,

    does    : Joose.Meta.Singleton
}))
;
;
}();;
;
Joose.C.ignoreRepeatedDeclarations = true;
Class('JooseX.Observable.Event', {
    
    has : {
        name        : { required : true },
        args        : { required : true },
        
        source      : { required : true },
        
        splat       : null,
        current     : null,
        
        bubbling    : true
    },
    
        
    methods : {
        
        stopPropagation : function () {
            this.bubbling = false
        }
    }
})


;
Class('JooseX.Observable.Listener', {

    has : {
        channel     : { required : true },
        eventName   : { required : true },
        
        func        : { required : true },
        scope       : null,
        
        single          : false,
        
        buffer          : null,
        bufferMax       : null,
        
        bufferStartedAt : null,
        bufferTimeout   : null,
        
        delayTimeout    : null,
        
        delay           : null
    },
    
        
    methods : {
        
        activate : function (event, args) {
            var me      = this
            
            if (me.buffer != null) {
                
                if (me.bufferMax != null)
                    if (!me.bufferStartedAt) 
                        me.bufferStartedAt = new Date()
                    else
                        if (new Date - me.bufferStartedAt > me.bufferMax) return
                
                        
                if (me.bufferTimeout) clearTimeout(me.bufferTimeout)
                
                me.bufferTimeout = setTimeout(function () {
                    
                    delete me.bufferStartedAt
                    delete me.bufferTimeout
                    
                    me.doActivate(event, args)
                    
                }, me.buffer)
                
                return
            }
            
            if (me.delay != null) {
                
                me.delayTimeout = setTimeout(function () {
                    
                    delete me.delayTimeout
                    
                    me.doActivate(event, args)
                    
                }, me.delay)
                
                return
            }
            
            return me.doActivate(event, args)
        },
        
        
        doActivate : function (event, args) {
            if (this.single) this.remove()
            
            return this.func.apply(this.scope || event.source, [ event ].concat(args) ) !== false
        },
        
        
        cancel  : function () {
            if (this.buffer) {
                clearTimeout(this.bufferTimeout)
                
                delete this.bufferTimeout
                delete this.bufferStartedAt
            }
            
            if (this.delay) clearTimeout(this.delayTimeout)
        },
        
        
        remove : function () {
            this.channel.removeListener(this)
        }
    }
})


;
Class('JooseX.Observable.Channel', {
    
    has : {
        channels    : Joose.I.Object,
        
        listeners   : Joose.I.Object
    },
    
        
    methods : {
        
        destroy : function () {
            Joose.O.each(this.channels, function (channel, name) {
                channel.purgeListeners()
            })
            
            this.channels   = null
            
            // cleanup paranoya
            Joose.O.each(this.listeners, function (value, name) {
                this.listeners[ name ]  = null
            }, this)
            
            this.listeners  = null
        },
        
        
        // (!) segments array will be destroyed in this method
        getListenersFor : function (segments, name, activators) {
            var listeners = this.listeners
            
            if (listeners[ '**' ]) {
                
                var splat       = segments.concat(name)
                
                Joose.A.each(listeners[ '**' ], function (listener) {
                    activators.push({
                        listener    : listener,
                        splat       : splat
                    })
                })
            }
            
            if (segments.length) {
                var next = this.getSingleChannel(segments.shift(), true)
                
                if (next) next.getListenersFor(segments, name, activators)
            } else {
                
                if (listeners[ '*' ])
                    Joose.A.each(listeners[ '*' ], function (listener) {
                        
                        activators.push({
                            listener    : listener,
                            splat       : name
                        })
                    })
                
                if (listeners[ name ])  
                    Joose.A.each(listeners[ name ], function (listener) {
                        
                        activators.push({
                            listener    : listener
                        })
                    })
            }
        },
        
        
        hasListenerFor : function (segments, name) {
            var listeners = this.listeners
            
            if (listeners[ '**' ] && listeners[ '**' ].length) return true
            
            if (segments.length)  {
                var next = this.getSingleChannel(segments.shift(), true)
                
                if (next) return next.hasListenerFor(segments, name)
                
            } else {
                
                if (listeners[ '*' ] && listeners[ '*' ].length) return true
                
                if (listeners[ name ] && listeners[ name ].length) return true  
            }
            
            return false
        },
        
        
        addListener : function (listener) {
            var eventName   = listener.eventName
            var listeners   = this.listeners
            
            listeners[ eventName ] = listeners[ eventName ] || []
            
            listeners[ eventName ].push(listener)
        },
        
        
        removeListener : function (listenerToRemove) {
            // already purged
            if (!this.listeners) return
            
            var eventListeners      = this.listeners[ listenerToRemove.eventName ]
            
            eventListeners && Joose.A.each(eventListeners, function (listener, index) {
                
                if (listener == listenerToRemove) {
                    
                    eventListeners.splice(index, 1)
                    
                    return false
                }
            })
        },
        
        
        removeListenerByHandler : function (eventName, func, scope) {
            var eventListeners      = this.listeners[ eventName ]
            
            eventListeners && Joose.A.each(eventListeners, function (listener, index) {
                
                if (listener.func == func && listener.scope == scope) {
                    
                    eventListeners.splice(index, 1)
                    
                    return false
                }
            })
        },
        
        
        getSingleChannel : function (name, doNotCreate) {
            var channels    = this.channels
            
            if (channels[ name ]) return channels[ name ]
            
            if (doNotCreate) return null
            
            return channels[ name ] = new JooseX.Observable.Channel()
        },
        
        
        // (!) segments array will be destroyed in this method
        getChannel : function (segments, doNotCreate) {
            if (!segments.length) return this
            
            var next    = this.getSingleChannel(segments.shift(), doNotCreate)
            
            if (doNotCreate && !next) return null
            
            return next.getChannel(segments, doNotCreate)
        }
    }
})


;
Role('JooseX.Observable', {
    
    /*PKGVERSION*/VERSION : 0.04,
    
//    use : [ 
//        'JooseX.Observable.Channel',    
//        'JooseX.Observable.Listener', 
//        'JooseX.Observable.Event'    
//    ],
    
    
//    trait   : 'JooseX.Observable.Meta',
    
    
    has : {
        rootChannel             : {
            is          : 'rw',
            init        : function () { return new JooseX.Observable.Channel() }
        },
        
        suspendCounter          : 0
    },
    
        
    methods : {
        
        getBubbleTarget : function () {
        },
        
        
        parseEventPath : function (path) {
            var channels    = path.split('/')
            var eventName   = channels.pop()
            
            if (channels.length && !channels[ 0 ]) channels.shift()
            
            return {
                channels        : channels,
                eventName       : eventName
            }
        },
        
        
        on : function (path, func, scope, options) {
            if (!func) throw "Not valid listener function provided when subsribing on event: " + path
            
            var parsed      = this.parseEventPath(path)
            var channel     = this.getRootChannel().getChannel(parsed.channels)
            
            var listener    = new JooseX.Observable.Listener(Joose.O.extend(options || {}, {
                channel     : channel,
                eventName   : parsed.eventName,
                
                func        : func,
                scope       : scope
            }))
            
            channel.addListener(listener)
            
            return listener
        },
        
        
        un : function (path, func, scope) {
            
            if (path instanceof JooseX.Observable.Listener) {
                
                path.remove()
                
                return
            }
            
            var parsed      = this.parseEventPath(path)
            var channel     = this.getRootChannel().getChannel(parsed.channels, true)
            
            if (channel) channel.removeListenerByHandler(parsed.eventName, func, scope)
        },
        
        
        emit : function () {
            return this.fireEvent.apply(this, arguments)
        },
        
        
        fireEvent : function (path) {
            if (this.suspendCounter) return
            
            var args        = Array.prototype.slice.call(arguments, 1)

            var event       = new JooseX.Observable.Event({
                name        : path,
                args        : args,
                
                source      : this
            }) 
            
            return this.propagateEvent(event, path, args)
        },
        
        
        propagateEvent : function (event, path, args) {
            if (this.suspendCounter) return
            
            var parsed      = this.parseEventPath(path)
            var eventName   = parsed.eventName
            
            if (!eventName == '*' || eventName == '**') throw new Error("Can't fire an empty event or event with `*`, `**` names ")
            
            var activators  = []
            
            this.getRootChannel().getListenersFor(parsed.channels, eventName, activators)
            
            var res             = true
            
            event.current       = this
            
            if (activators.length) Joose.A.each(activators, function (activator) {
                event.splat = activator.splat
                
                res = activator.listener.activate(event, args) !== false && res
            })
            
            if (event.bubbling) {
                
                var further = this.getBubbleTarget()
                
                if (further) res = further.propagateEvent(event, path, args) !== false && res
            } 
                
            return res
        },
        
        
        hasListenerFor : function (path) {
            var parsed      = this.parseEventPath(path)
            
            return this.getRootChannel().hasListenerFor(parsed.channels, parsed.eventName)
        },
        
        
        purgeListeners  : function () {
            this.rootChannel.destroy()
            
            this.rootChannel = new JooseX.Observable.Channel()
        },
        
        
        suspendEvents : function () {
            this.suspendCounter++
        },
        
        
        resumeEvents : function () {
            this.suspendCounter--
            
            if (this.suspendCounter < 0) this.suspendCounter = 0
        }
    }
});
;
Class('JooseX.Namespace.Depended.Manager', {
    
    my : {
    
        have : {
            
            INC                             : [ 'lib', '/jsan' ],
            
            disableCaching                  : true,
            
            resources                       : {},
            
            resourceTypes                   : {},
            
            ANONYMOUS_RESOURCE_COUNTER      : 0
        },
    
        
        
        methods : {
            
            //get own resource of some thing (resource will be also attached to that abstract thing)
            //if the something is requesting own resource its considered loaded
            getMyResource : function (type, token, me) {
                var resource = this.getResource({
                    type : type,
                    token : token
                })
                
                if (resource.attachedTo && resource.attachedTo != me) throw resource + " is already attached to [" + resource.attachedTo + "]"
                
                resource.attachedTo     = me
                resource.loaded         = true
                resource.loading        = false
                
                return resource
            },
            
            
            getResource : function (descriptor) {
                
                if (typeof descriptor == 'object') {
                    var type                = descriptor.type = descriptor.type || 'javascript'
                    var token               = descriptor.token
                    var requiredVersion     = descriptor.version
                    
                    delete descriptor.version
                    
                } else 
                    if (typeof descriptor == 'string') {
                    
                        var match = /^(\w+):\/\/(.+)/.exec(descriptor)
                        
                        if (match) {
                            // type & token are explicitly specified
                            type    = match[1]
                            token   = match[2]
                            
                            if (type == 'http' || type == 'https') {
                                token   = type + '://' + token
                                type    = 'javascript'
                            }
                        } else {
                            // no type specified
                            token = descriptor
                            
                            type = /\//.test(token) || /\.js$/.test(token) ? 'javascript' : 'joose'
                        }
                    }
                    
                if (!token) {
                    token       = '__ANONYMOUS_RESOURCE__' + this.ANONYMOUS_RESOURCE_COUNTER++
                    descriptor  = undefined
                }
                
                var id = type + '://' + token
                
                var resource = this.resources[id]
                
                if (!resource) {
                    var resourceClass = this.resourceTypes[type]
                    if (!resourceClass) throw new Error("Unknown resource type: [" + type + "]")
                    
                    resource = this.resources[id] = new resourceClass(typeof descriptor == 'object' ? descriptor : { 
                        token : token,
                        
                        type : type
                    })
                }
                
                resource.setRequiredVersion(requiredVersion)
                
                return resource
            },
            
            
            registerResourceClass : function (typeName, resourceClass) {
                this.resourceTypes[typeName] = resourceClass
            },
            
            
            use : function (dependenciesInfo, callback, scope) {
                Class({
                    use    : dependenciesInfo,
                    
                    body   : function () {
                        if (callback) Joose.Namespace.Manager.my.executeIn(Joose.top, function (ns) {
                            callback.call(scope || this, ns)
                        })
                    }
                })
            },
            
            
            getINC : function () {
                var INC         = this.INC
                var original    = use.__ORIGINAL__
                var paths       = use.paths
                
                // user have modified the `use.path` with direct assignment - return `use.paths`
                if (INC == original && paths != original) return paths
                
                // user have modified the `JooseX.Namespace.Depended.Manager.my.INC` with direct assignment - return it
                if (INC != original && paths == original) return INC
                
                if (INC != original && paths != original) throw "Both INC sources has been modified"
                
                // user was only using the in-place array mutations - return any
                return INC
            }
        }
    }
})

use = function (dependenciesInfo, callback, scope) {
    JooseX.Namespace.Depended.Manager.my.use(dependenciesInfo, callback, scope) 
}

use.paths = use.__ORIGINAL__ = JooseX.Namespace.Depended.Manager.my.INC


Joose.I.FutureClass = function (className) { 
    return function () { 
        return eval(className) 
    } 
}


/**

Name
====


JooseX.Namespace.Depended.Manager - A global collection of all resources


SYNOPSIS
========

        JooseX.Namespace.Depended.Manager.my.registerResourceClass('custom-type', JooseX.Namespace.Depended.Resource.Custom)
        

DESCRIPTION
===========

`JooseX.Namespace.Depended.Manager` is a global collection of all resources. 

**Note:** Its a pure [static](http://joose.github.com/Joose/doc/html/Joose/Manual/Static.html) class - all its methods and properties are static.


METHODS
=======

### registerResourceClass

> `void registerResourceClass(String type, Class constructor)`

> After you've created your custom resource class, you need to register it with call to this method.

> Then you can refer to new resources with the following descriptors: 

                {
                    type    : 'custom-type',
                    token   : 'some-token'
                }



GETTING HELP
============

This extension is supported via github issues tracker: <http://github.com/SamuraiJack/JooseX-Namespace-Depended-Manager/issues>

For general Joose questions you can also visit [#joose](http://webchat.freenode.net/?randomnick=1&channels=joose&prompt=1) on freenode or the mailing list at <http://groups.google.com/group/joose-js>
 


SEE ALSO
========

Authoring [JooseX.Namespace.Depended](Authoring.html)

Abstract base resource class: [JooseX.Namespace.Depended.Resource](Resource.html)

General documentation for Joose: <http://joose.github.com/Joose/>


BUGS
====

All complex software has bugs lurking in it, and this module is no exception.

Please report any bugs through the web interface at [http://github.com/SamuraiJack/JooseX-Namespace-Depended-Manager/issues](http://github.com/SamuraiJack/JooseX-Namespace-Depended-Manager/issues)



AUTHORS
=======

Nickolay Platonov [nplatonov@cpan.org](mailto:nplatonov@cpan.org)



COPYRIGHT AND LICENSE
=====================

Copyright (c) 2009, Nickolay Platonov

All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
* Neither the name of Nickolay Platonov nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 


*/
;
Class('JooseX.Namespace.Depended.Resource', {
    
    has : {
        
        attachedTo          : null,
        
        type                : null,
        token               : null,
        
        id                  : null,
        
        loading             : false,
        loaded              : false,
        ready               : false,
        
        presence            : null,
        readyness           : null,
        
        loadedFromURL       : null,
        
        readyListeners      : Joose.I.Array,
        
        dependencies        : Joose.I.Object,
        
        onBeforeReady       : { is : 'rw', init : null },
        readyDelegated      : false,
        
        version             : { is : 'rw', init : null },
        requiredVersion     : { is : 'rw', init : null },
        
        hasReadyCheckScheduled  : false
    },
    
    
    after: {
        
        initialize: function () {
            if (!this.id) this.id = this.type + '://' + this.token
        }
        
    },

    
    
    methods: {
        
        setOnBeforeReady : function (func) {
            if (this.onBeforeReady) throw "Can't redefine 'onBeforeReady' for " + this
            
            this.onBeforeReady = func
        },
        
        
        setVersion : function (version) {
            if (!version) return
            
            if (this.version && this.version != version) throw new Error("Cant redefine version of " + this)
            
            var requiredVersion = this.requiredVersion
            
            if (requiredVersion && version < requiredVersion) throw new Error("Versions conflict on " + this + " required [" + requiredVersion + "], got [" + version + "]")
                
            this.version = version
        },
        
        
        setRequiredVersion : function (version) {
            if (!version) return
            
            var requiredVersion = this.requiredVersion
            
            if (!requiredVersion || version > requiredVersion) 
                if (this.isLoaded() || this.loading)
                    throw "Cant increase required version - " + this + " is already loaded"
                else
                    this.requiredVersion = version
        },
        
        
        toString : function () {
            return "Resource: id=[" + this.id + "], type=[" + this.meta.name + "]"
        },
        
        
        addDescriptor : function (descriptor) {
            var resource = JooseX.Namespace.Depended.Manager.my.getResource(descriptor)
            
            var dependencies    = this.dependencies
            var resourceID      = resource.id
            
            //if there is already such dependency or the resource is ready
            if (dependencies[ resourceID ] || resource.isReady()) return
            
            var me = this
            //pushing listener to the end(!) of the list
            resource.readyListeners.push(function () {
                
                delete dependencies[ resourceID ]
                me.checkReady()
            })
            
            //adding dependency
            dependencies[ resourceID ] = resource
            
            //we are not ready, since there are depedencies to load                
            this.ready = false
        },
        
        
        handleDependencies : function () {
            // || {} required for classes on which this Role was applied after they were created - they have this.dependencies not initialized
            Joose.O.eachOwn(this.dependencies || {}, function (resource) {
                resource.handleLoad()
            })
            
            this.checkReady()
        },
        
        
        checkReady : function () {
            if (!Joose.O.isEmpty(this.dependencies) || this.hasReadyCheckScheduled) return
            
            if (this.onBeforeReady) {
                
                if (!this.readyDelegated) {
                    this.readyDelegated = true
                    
                    var me = this
                    
                    this.onBeforeReady(function(){
                        me.fireReady()
                    }, me)
                }
            } else 
                this.fireReady()
        },
        
        
        fireReady: function () {
            this.ready      = true
            
            var listeners   = this.readyListeners
            
            this.readyListeners = []
            
            Joose.A.each(listeners, function (listener) {
                listener()
            })
        },
        
        
        isReady : function () {
            if (!this.isLoaded()) return false
            
            var isReady = false
            
            try {
                isReady = this.readyness()
            } catch (e) {
            }
            
            return isReady || this.ready
        },
        
        
        isLoaded : function () {
            var isPresent = false
            
            try {
                isPresent = this.presence()
            } catch (e) {
            }
            
            return isPresent || this.loaded
        },
        
        
        handleLoad: function() {
            
            if (this.isLoaded()) {
                this.checkReady()
                return
            }
            
            if (this.loading) return
            this.loading = true
            
            var urls = Joose.O.wantArray(this.getUrls())
            
            var me = this
            
            
            // this delays the 'checkReady' until the resourse will be *fully* materialized
            // *fully* means that even the main class of the resource is already "ready"
            // the possible other classes in the same file could be not
            // see 110_several_classes_in_file.t.js, 120_script_tag_transport.t.js for example
            me.hasReadyCheckScheduled = true
            
            var onsuccess = function (resourceBlob, url) {
                me.loaded = true
                me.loading = false
                
                me.loadedFromURL = url
                
                Joose.Namespace.Manager.my.executeIn(Joose.top, function () {
                    
                    me.materialize(resourceBlob, url)
                })
                
                me.hasReadyCheckScheduled = false
                
                // handle the dependency of the class after its materialization completition
                me.handleDependencies()
            }
            
            var onerror = function (e) {
                //if no more urls
                if (!urls.length) throw new Error(me + " not found") 
                
                me.load(urls.shift(), onsuccess, onerror)
            }
            
            this.load(urls.shift(), onsuccess, onerror)
        },
        

        getUrls: function () {
            throw "Abstract resource method 'getUrls' was called"
        },
        
        
        load : function (url, onsuccess, onerror) {
            throw "Abstract resource method 'load' was called"
        },
        
        
        materialize : function (resourceBlob) {
            throw "Abstract resource method 'materialize' was called"
        }
        
    }
})


/**

Name
====


JooseX.Namespace.Depended.Resource - Abstract resource class 


SYNOPSIS
========
        
        //mostly for subclassing only
        Class("JooseX.Namespace.Depended.Resource.JavaScript", {
        
            isa : JooseX.Namespace.Depended.Resource,
            
            ...
        })


DESCRIPTION
===========

`JooseX.Namespace.Depended.Resource` is an abstract resource class. Its not supposed to be used directly, instead you should use
one of its subclasses.


ATTRIBUTES
==========

### attachedTo

> `Object attachedTo`

> An arbitrary object to which this resource is attached (its a corresponding class in JooseX.Namespace.Depended)


### type

> `String type`

> A type of resource  - plain string. `JooseX.Namespace.Depended.Manager` maintain a collection of resource types, accessible 


### token

> `String token`

> A token of resource  - plain string with arbitrary semantic. Each subclass should provide this semantic along with `token -> url` conertion method (locator)  


### id

> `String id`

> An id of resource - is computed as `type + '://' + token'


### loading

> `Boolean loading`

> A sign whether this resource is currently loading

  
### loaded

> `Boolean loaded`

> A sign whether this resource is already loaded


### ready

> `Boolean ready`

> A sign whether this resource is considered ready. Resource is ready, when its loaded, and all its dependencies are ready.


### loadedFromURL

> `String loadedFromURL`

> An url, from which the resource was loaded.


### readyListeners

> `Array[Function] readyListeners`

> An array of functions, which will be called after this resource becomes ready. Functions will be called sequentially. 


### dependencies

> `Object dependencies`

> An object containing the dependencies of this resource. Keys are the `id`s of resources and the values - the resource instances itself.

 
### onBeforeReady

> `Function onBeforeReady`

> A function, which will be called, right after the all dependencies of the resource became ready, but before its own `readyListeners` will be called.
It supposed to perform any needed additional actions to post-process the loaded resource.

> Function will receive two arguments - the 1st is the callback, which should be called when `onBeforeReady` will finish its work. 2nd is the resource instance.

  
### version

> `r/w Number version`

> A version of this resource. Currently is handled as Number, this may change in future releases.

  
### requiredVersion

> `r/w Number requiredVersion`

> A *requiredVersion* version of this resource. Required here means the maximum version from all references to this resource. 



METHODS
=======

### addDescriptor

> `void addDescriptor(Object|String descriptor)`

> Add the resource, described with passed descriptor as the dependency for this resource.


### getUrls

> `String|Array[String] getUrls()`

> Abstract method, will throw an exception if not overriden. It should return the array of urls (or a single url) from which this resource can be potentially loaded. 
This method should take into account the `use.paths` setting


### load

> `void load(String url, Function onsuccess, Function onerror)`

> Abstract method, will throw an exception if not overriden. It should load the content of the resource from the passed `url`. If there was an error during loading
(for example file not found) should not throw the exception. Instead, should call the `onerror` continuation with it (exception instance).

> After successfull loading, should call the `onsuccess` continuation with the resource content as 1st argument, and `url` as 2nd: `onsuccess(text, url)`


### materialize

> `void materialize(String resourceBlob, String url)`

> Abstract method, will throw an exception if not overriden. It should "materialize" the resource. The concrete semantic of this action is determined by resource nature.
For example this method can create some tag in the DOM tree, or execute the code or something else.

> Currently this method is supposed to operate synchronously, this may change in future releases. 
 

SEE ALSO
========

Web page of this package: <http://github.com/SamuraiJack/JooseX-Namespace-Depended-Resource/>

General documentation for Joose: <http://joose.github.com/Joose/>


BUGS
====

All complex software has bugs lurking in it, and this module is no exception.

Please report any bugs through the web interface at <http://github.com/SamuraiJack/JooseX-Namespace-Depended-Resource/issues>



AUTHORS
=======

Nickolay Platonov <nplatonov@cpan.org>



COPYRIGHT AND LICENSE
=====================

Copyright (c) 2009-2010, Nickolay Platonov

All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
* Neither the name of Nickolay Platonov nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 


*/
;
Role('JooseX.Namespace.Depended.Materialize.Eval', {
    
    requires : [ 'handleLoad' ],
    
    methods : {
        
        materialize : function (resourceBlob) {
            // "indirect eval" call 
            (window.execScript || window.eval)(resourceBlob)
        }
    }
})

/**

Name
====


JooseX.Namespace.Depended.Materialize.Eval - materializator, which treat the resource content as JavaScript code, and use `eval` function to evalute it 


SYNOPSIS
========
        
        //generally for consuming only
        
        Class("JooseX.Namespace.Depended.Resource.Custom", {
        
            isa : JooseX.Namespace.Depended.Resource,
            
            does : [ JooseX.Namespace.Depended.Materialize.Eval, ...]
            
            ...
        })


DESCRIPTION
===========

`JooseX.Namespace.Depended.Materialize.Eval` is a materializator role. It provide the implementation of `materialize` method. 


SEE ALSO
========

Authoring [JooseX.Namespace.Depended](../Authoring.html)

Abstract base resource class: [JooseX.Namespace.Depended.Resource](../Resource.html)


General documentation for Joose: <http://joose.github.com/Joose/>


AUTHORS
=======

Nickolay Platonov <nplatonov@cpan.org>



COPYRIGHT AND LICENSE
=====================

Copyright (c) 2009-2010, Nickolay Platonov

All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
* Neither the name of Nickolay Platonov nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 


*/;
Class('JooseX.Namespace.Depended.Resource.JavaScript', {
    
    isa : JooseX.Namespace.Depended.Resource,
    
    has : {
        
        hasDirectUrl    : false
    },
    
    after: {
        
        initialize: function () {
            var me      = this
            
            // backward compat
            if (this.type == 'nonjoose') this.type = 'javascript'
            
            
            var presence = this.presence
            
            if (typeof presence == 'string') this.presence = function () {
                return eval(presence)
            }
            
            if (!presence) this.presence = function () {
                return eval(me.token)
            }
            
            if (!this.readyness) this.readyness = this.presence
        }
        
    },

    
    methods : {
        
        BUILD : function (config) {
            var token = config.token
            
            var match = /^=(.*)/.exec(token)
            
            if (match) {
                this.hasDirectUrl   = true
                
                token               = match[1]
            }
            
            if (/^http/.test(token)) {
                this.hasDirectUrl   = true
                
                config.trait        = JooseX.Namespace.Depended.Transport.ScriptTag
            }
            
            if (/^\//.test(token)) this.hasDirectUrl   = true
                
            return config
        },
        
        
        getUrls : function () {
            var url = this.token
            
            if (this.hasDirectUrl) return [ url ]
            
            var manager = JooseX.Namespace.Depended.Manager.my
            
            return Joose.A.map(manager.getINC(), function (libroot) {
                libroot = libroot.replace(/\/$/, '')
                
                return [ libroot ].concat(url).join('/') + (manager.disableCaching ? '?disableCaching=' + new Date().getTime() : '')
            })
        }
    }

})

JooseX.Namespace.Depended.Manager.my.registerResourceClass('javascript',    JooseX.Namespace.Depended.Resource.JavaScript)
JooseX.Namespace.Depended.Manager.my.registerResourceClass('nonjoose',      JooseX.Namespace.Depended.Resource.JavaScript)
;
Class('JooseX.Namespace.Depended.Resource.JooseClass', {
    
    isa : JooseX.Namespace.Depended.Resource.JavaScript,
    
    // NOTE : we don't add the default materialization and transport roles here - they'll be added
    // in one of the Bootstrap/*.js files
    
    after: {
        
        initialize: function () {
            var me = this
            
            this.presence = function () {
                var c = Joose.S.strToClass(me.token)
                
                return c && c.meta.resource
            }
            
            this.readyness = function () {
                var c = eval(me.token)
                
                return c && c.meta.resource.ready
            }
        }
        
    },
    
    
    methods : {
        
        addDescriptor : function (descriptor) {
            if (typeof descriptor == 'object' && !descriptor.token) 
                Joose.O.eachOwn(descriptor, function (version, name) {
                    this.addDescriptor({
                        type : 'joose',
                        token : name,
                        version : version
                    })
                }, this)
            else
                this.SUPER(descriptor)
        },
        
        
        getUrls : function () {
            var urls = []
            var className = this.token.split('.')
            
            var manager = JooseX.Namespace.Depended.Manager.my
            
            return Joose.A.map(manager.getINC(), function (libroot) {
                libroot = libroot.replace(/\/$/, '')
                
                return [ libroot ].concat(className).join('/') + '.js' + (manager.disableCaching ? '?disableCaching=' + new Date().getTime() : '')
            })
        }
    }

})

JooseX.Namespace.Depended.Manager.my.registerResourceClass('joose', JooseX.Namespace.Depended.Resource.JooseClass);
;
if (typeof JooseX != "undefined" && !JooseX.SimpleRequest) {;
Class("JooseX.SimpleRequest", {

    have : {
    	req : null
	},

    
    methods: {
    	
        initialize: function () {
            if (window.XMLHttpRequest)
                this.req = new XMLHttpRequest()
            else
                this.req = new ActiveXObject("Microsoft.XMLHTTP")
        },
        
        
        getText: function (urlOrOptions, async, callback, scope) {
            var req = this.req
            
            var headers
            var url
            
            if (typeof urlOrOptions != 'string') {
                headers = urlOrOptions.headers
                url = urlOrOptions.url
                async = async || urlOrOptions.async
                callback = callback || urlOrOptions.callback
                scope = scope || urlOrOptions.scope
            } else url = urlOrOptions
            
            req.open('GET', url, async || false)
            
            if (headers) Joose.O.eachOwn(headers, function (value, name) {
                req.setRequestHeader(name, value)
            })
            
            try {
                req.onreadystatechange = function (event) {  
                    if (async && req.readyState == 4) {  
                        // status is set to 0 for failed cross-domain requests..
                        // but if the response text presents - we treat this as successfull request
                        // see https://www.assembla.com/spaces/bryntum/tickets/590
                        if (req.status == 200 || req.status == 0 && req.responseText.length > 0) 
                            callback.call(scope || this, true, req.responseText)
                        else 
                            callback.call(scope || this, false, "File not found: " + url)
                    }  
                };  
                req.send(null)
            } catch (e) {
                throw "File not found: " + url
            }
            
            if (!async)
                if (req.status == 200 || req.status == 0 && req.responseText.length > 0) 
                    return req.responseText; 
                else 
                    throw "File not found: " + url
            
            return null
        }
    }
})
;
};
Role('JooseX.Namespace.Depended.Materialize.ScriptTag', {
    
    requires : [ 'handleLoad' ],
    
    methods : {
        
        materialize : function (resourceBlob) {
            var loaderNode = document.createElement("script")
            
            loaderNode.text = resourceBlob
            
            //adding to body, because Safari do not create HEAD for iframe's documents
            document.body.appendChild(loaderNode)
        }
    }
})
;
Role('JooseX.Namespace.Depended.Transport.XHRAsync', {
    
    requires : [ 'handleLoad' ],
    
    override : {
        
        load: function (url, onsuccess, onerror) {
            var req = new JooseX.SimpleRequest()
            
            try {
                req.getText(url, true, function (success, text) {
                    
                    if (!success) { 
                        onerror(this + " not found") 
                        return 
                    }
                    
                    onsuccess(text, url)
                })
            } catch (e) {
                onerror(e)
            }
        }
    }
})


/**

Name
====


JooseX.Namespace.Depended.Transport.XHRAsync - transport, which use the asynchronous XHR request for resource loading 


SYNOPSIS
========
        
        //generally for consuming only
        
        Class("JooseX.Namespace.Depended.Resource.Custom", {
        
            isa : JooseX.Namespace.Depended.Resource,
            
            does : [ JooseX.Namespace.Depended.Transport.XHRAsync, ...]
            
            ...
        })


DESCRIPTION
===========

`JooseX.Namespace.Depended.Transport.XHRAsync` is a transport role. It provide the implementation of `load` method, which use the 
asynchronous XHR request for resource loading. 



SEE ALSO
========

Authoring [JooseX.Namespace.Depended](../Authoring.html)

Abstract base resource class: [JooseX.Namespace.Depended.Resource](../Resource.html)


General documentation for Joose: <http://joose.github.com/Joose/>


AUTHORS
=======

Nickolay Platonov <nplatonov@cpan.org>



COPYRIGHT AND LICENSE
=====================

Copyright (c) 2009-2010, Nickolay Platonov

All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
* Neither the name of Nickolay Platonov nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 


*/;
Role('JooseX.Namespace.Depended.Transport.ScriptTag', {
    
    requires : [ 'handleLoad' ],
    
    
    methods : {
        
        getScriptTag : function () {
            
        }
    },
    
    
    override : {
        
        load: function (url, onsuccess, onerror) {

            var scriptNode       = document.createElement('script')

            scriptNode.type      = 'text/javascript'
            scriptNode.src       = url
            scriptNode.async     = true
            
            
            if (Joose.is_IE) {
                
                var timeout    = setTimeout(function () {
                    
                    onerror(url + " load failed.")
                    
                }, 10000)
                
                scriptNode.onreadystatechange = function() {
                    
                    var readyState = scriptNode.readyState
                    
                    if (readyState == 'complete' || readyState == 'loaded') {
                        
                        clearTimeout(timeout)
                            
                        onsuccess(null, url)
                    }
                }
                
                
            } else {
                
                scriptNode.onload = function() {
                    onsuccess(scriptNode.text, url)
                }
            
                scriptNode.onerror = function () {
                    onerror(url + " load failed.")
                }
            }
                
            var head            = document.getElementsByTagName('head')[0] || document.body
            
            head.appendChild(scriptNode)
        },
        
        
        materialize : function (blob, url) {
        }
    }
})



/**

Name
====


JooseX.Namespace.Depended.Transport.ScriptTag - transport, which use the &lt;script&gt; tag for resource loading 


SYNOPSIS
========
        
        //generally for consuming only
        
        Class("JooseX.Namespace.Depended.Resource.Custom", {
        
            isa : JooseX.Namespace.Depended.Resource,
            
            does : [ JooseX.Namespace.Depended.Transport.ScriptTag, ...]
            
            ...
        })


DESCRIPTION
===========

`JooseX.Namespace.Depended.Transport.ScriptTag` is a transport role. It provide the implementation of `load` method, which use the 
&lt;script&gt; tag for resource loading. It also overrides the `materialize` method as &lt;script&gt; tag execute the code along with loading. 



SEE ALSO
========

Authoring [JooseX.Namespace.Depended](../Authoring.html)

Abstract base resource class: [JooseX.Namespace.Depended.Resource](../Resource.html)


General documentation for Joose: <http://joose.github.com/Joose/>


AUTHORS
=======

Nickolay Platonov <nplatonov@cpan.org>



COPYRIGHT AND LICENSE
=====================

Copyright (c) 2009-2010, Nickolay Platonov

All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
* Neither the name of Nickolay Platonov nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 


*/;
Role('JooseX.Namespace.Depended.Transport.NodeJS', {

    requires : [ 'handleLoad' ],
    
    override : {
        
        load: function (url, onsuccess, onerror) {
            var fs = require('fs')
            
            try {
                var content = fs.readFileSync(url, 'utf8')
                
            } catch (e) {
                
                onerror(e)
                
                return
            }
            
            onsuccess(content, url)
            
//            fs.readFile(url, function (err, data) {
//                if (err) {
//                    onerror(err)
//                    
//                    return
//                }
//                
//                onsuccess(data, url)
//            })            
        }
    }
})


/**

Name
====


JooseX.Namespace.Depended.Transport.Node - transport, which use the `fs.readFileSync()` call of NodeJS, to load the content of resource. 


SYNOPSIS
========
        
        //generally for consuming only
        
        Class("JooseX.Namespace.Depended.Resource.Custom", {
        
            isa : JooseX.Namespace.Depended.Resource,
            
            does : [ JooseX.Namespace.Depended.Transport.Node, ...]
            
            ...
        })


DESCRIPTION
===========

`JooseX.Namespace.Depended.Transport.Node` is a transport role. It provide the implementation of `load` method, 
which use the `fs.readFile()` call of NodeJS for resource loading. 

This transport behaves synchronously.



SEE ALSO
========

Authoring [JooseX.Namespace.Depended](../Authoring.html)

Abstract base resource class: [JooseX.Namespace.Depended.Resource](../Resource.html)


General documentation for Joose: <http://joose.github.com/Joose/>


AUTHORS
=======

Nickolay Platonov <nplatonov@cpan.org>



COPYRIGHT AND LICENSE
=====================

Copyright (c) 2009-2010, Nickolay Platonov

All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
* Neither the name of Nickolay Platonov nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 


*/;
Role('JooseX.Namespace.Depended.Materialize.NodeJS', {

    requires : [ 'handleLoad' ],

    methods : {

        materialize : function (resourceBlob, url) {

//             if (global.__PROVIDER__)
// //                require('vm').runInThisContext(resourceBlob + '', url)
//
// //                // running in Test.Run
// //
//                 eval(resourceBlob + '')
//
//             else
//                 // global scope
//                 require('vm').runInThisContext('(function (exports, require, module, __filename, __dirname) {' + resourceBlob + '})', url)(exports, require, module, __filename, __dirname)
        }
    }
})

/**

Name
====


JooseX.Namespace.Depended.Materialize.NodeJS - materializator, which execute the code, using the `Script.runInThisContext` call of NodeJS.


SYNOPSIS
========

        //generally for consuming only

        Class("JooseX.Namespace.Depended.Resource.Custom", {

            isa : JooseX.Namespace.Depended.Resource,

            does : [ JooseX.Namespace.Depended.Materialize.NodeJS, ...]

            ...
        })


DESCRIPTION
===========

`JooseX.Namespace.Depended.Materialize.NodeJS` is a materializator role. It provide the implementation of `materialize` method.


SEE ALSO
========

Authoring [JooseX.Namespace.Depended](../Authoring.html)

Abstract base resource class: [JooseX.Namespace.Depended.Resource](../Resource.html)


General documentation for Joose: <http://joose.github.com/Joose/>


AUTHORS
=======

Nickolay Platonov <nplatonov@cpan.org>



COPYRIGHT AND LICENSE
=====================

Copyright (c) 2009-2010, Nickolay Platonov

All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
* Neither the name of Nickolay Platonov nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


*/;
Class('JooseX.Namespace.Depended.Resource.Require', {

    isa     : JooseX.Namespace.Depended.Resource,


    methods : {

        getUrls : function () {
            return [ this.token ]
        },


        load: function (url, onsuccess, onerror) {

            // require.async(url, function (err) {
            //     if (err instanceof Error)
            //         onerror(err)
            //     else
            //         onsuccess('', url)
            // })

        },


        materialize : function () {
        }

    }

})

JooseX.Namespace.Depended.Manager.my.registerResourceClass('require', JooseX.Namespace.Depended.Resource.Require)
;
Role('JooseX.Namespace.Depended', {

    /*VERSION,*/

    meta : Joose.Managed.Role,

    requires : [ 'prepareProperties' ],


    have : {
        containResources                    : [ 'use', 'meta', 'isa', 'does', 'trait', 'traits' ]
    },


    override: {

//        GETCURRENT : function () {
//            var currentModule   = this.getCurrent()
//
//            return currentModule == Joose.top ? 'TOP' : currentModule.meta.name
//        },


        prepareProperties : function (name, extend, defaultMeta, callback) {
            if (name && typeof name != 'string') {
                extend = name
                name = null
            }

            extend = extend || {}

            var summaredDeps    = this.collectAllDeps(extend)
            var currentModule   = this.getCurrent()

            // if (currentModule !== Joose.top && !currentModule.meta) {
            //     require('console').log("CURRENT MODULE: %s", require('util').inspect(currentModule))
            //     require('console').log("TOP: %s", require('util').inspect(Joose.top))
            // }

            var resource = JooseX.Namespace.Depended.Manager.my.getResource({
                type    : 'joose',
                token   : currentModule == Joose.top ? name : currentModule.meta.name + '.' + name
            })


            if (extend.VERSION) resource.setVersion(extend.VERSION)

            //BEGIN executes right after the all dependencies are loaded, but before this module becomes ready (before body())
            //this allows to manually control the "ready-ness" of module (custom pre-processing)
            //BEGIN receives the function (callback), which should be called at the end of custom processing
            if (extend.BEGIN) {
                resource.setOnBeforeReady(extend.BEGIN)

                delete extend.BEGIN
            }

            Joose.A.each(summaredDeps, function (descriptor) {
                resource.addDescriptor(descriptor)
            })


            //skip constructing for classes w/o dependencies
            if (Joose.O.isEmpty(resource.dependencies)) {
                this.inlineAllDeps(extend)

                var res = this.SUPER(name, extend, defaultMeta, callback)

                //this will allow to classes which don't have dependencies to be ready synchronously
                resource.checkReady()

                return res
            } else {

                var me      = this
                var SUPER   = this.SUPER

                var current

                //unshift is critical for correct order of readyListerens processing!
                //constructing is delaying until resource will become ready
                resource.readyListeners.unshift(function () {
                    me.inlineAllDeps(extend)

                    Joose.Namespace.Manager.my.executeIn(currentModule, function () {

                        SUPER.call(me, name, extend, defaultMeta, callback)
                    })
                })

                // running as <script> in browser or as main script in node
                if (!resource.hasReadyCheckScheduled)
                    if (Joose.is_NodeJS)
                        resource.handleDependencies()
                    else
                        // defer the dependencies loading, because they actually could be provided later in the same bundle file
                        // this, however, affect performance, so bundles should be created in the dependencies-ordered way
                        setTimeout(function () {
                            resource.handleDependencies()
                        }, 0)


                return this.create(name, Joose.Namespace.Keeper, {})
            }
        },


        prepareMeta : function (meta) {
            meta.resource = meta.resource || JooseX.Namespace.Depended.Manager.my.getMyResource('joose', meta.name, meta.c)
        }
    },
    //eof override


    methods : {

        alsoDependsFrom : function (extend, summaredDeps) {
        },


        collectAllDeps : function (extend) {
            var summaredDeps    = []
            var me              = this

            //gathering all the related resourses from various builders
            this.collectClassDeps(extend, summaredDeps)

            var extendMy = extend.my

            //gathering resourses of 'my'
            this.collectClassDeps(extendMy, summaredDeps)


            //gathering resourses from own attributes
            if (extend.has) Joose.O.each(extend.has, function (attr, name) {
                // do not try to collect the dependencies when class is given as init value
                if (Joose.O.isClass(attr)) return

                me.collectClassDeps(attr, summaredDeps)
            })

            //gathering resourses from attributes of `my`
            if (extendMy && extendMy.has) Joose.O.each(extendMy.has, function (attr, name) {
                // do not try to collect the dependencies when class is given as init value
                if (Joose.O.isClass(attr)) return

                me.collectClassDeps(attr, summaredDeps)
            })

            //and from externally collected additional resources
            this.alsoDependsFrom(extend, summaredDeps)

            return summaredDeps
        },


        collectClassDeps : function (from, to) {

            if (from) Joose.A.each(this.containResources, function (propName) {

                this.collectDependencies(from[propName], to, from, propName)

            }, this)
        },


        collectDependencies : function (from, to, extend, propName) {
            if (from) Joose.A.each(Joose.O.wantArray(from), function (descriptor) {
                if (descriptor && typeof descriptor != 'function') to.push(descriptor)
            })
        },


        inlineAllDeps : function (extend) {
            var me              = this

            this.inlineDeps(extend)

            var extendMy = extend.my

            if (extendMy) this.inlineDeps(extendMy)


            if (extend.has) Joose.O.each(extend.has, function (attr, name) {

                if (attr && typeof attr == 'object') me.inlineDeps(attr)
            })

            if (extendMy && extendMy.has) Joose.O.each(extendMy.has, function (attr, name) {

                if (attr && typeof attr == 'object') me.inlineDeps(attr)
            })
        },


        inlineDeps : function (extend) {
            delete extend.use

            Joose.A.each(this.containResources, function (propName) {

                if (extend[propName]) {

                    var descriptors = []

                    Joose.A.each(Joose.O.wantArray(extend[propName]), function (descriptor, index) {

                        var descType = typeof descriptor

                        if (descType == 'function')
                            descriptors.push(descriptor.meta ? descriptor : (propName != 'isa' ? descriptor() : null ))
                        else
                            if (descType == 'object')
                                if (descriptor.token)
                                    descriptors.push(eval(descriptor.token))
                                else
                                    Joose.O.each(descriptor, function (version, name) {
                                        descriptors.push(eval(name))
                                    })
                            else
                                if (descType == 'string')
                                    descriptors.push(eval(descriptor))
                                else
                                    throw new Error("Wrong dependency descriptor format: " + descriptor)

                    })

                    if (propName != 'isa' && propName != 'meta')
                        extend[propName] = descriptors
                    else
                        if (descriptors.length > 1)
                            throw "Cant specify several super- or meta- classes"
                        else
                            if (descriptors[0]) extend[propName] = descriptors[0]

                }
            })
        }
    }
})


Joose.Namespace.Manager.meta.extend({
    does : JooseX.Namespace.Depended
})

;
if (Joose.is_NodeJS) {

    JooseX.Namespace.Depended.Resource.JavaScript.meta.extend({
        
        does : [ JooseX.Namespace.Depended.Transport.NodeJS, JooseX.Namespace.Depended.Materialize.NodeJS ]
    })
    
    
    
    JooseX.Namespace.Depended.Manager.my.disableCaching = false
    
    Joose.Namespace.Manager.my.containResources.unshift('require')
    
    
    
    JooseX.Namespace.Depended.meta.extend({
        
        override : {
            
            collectDependencies : function (from, to, extend, propName) {
                if (propName != 'require') return this.SUPERARG(arguments)
                
                if (!from) return
                
                Joose.A.each(Joose.O.wantArray(from), function (url) {
                    to.push({
                        type    : 'require',
                        token   : url
                    })
                })
                
                delete extend.require
            }
        }
    })
} else
    JooseX.Namespace.Depended.Resource.JavaScript.meta.extend({
        
        does : [ JooseX.Namespace.Depended.Transport.XHRAsync, JooseX.Namespace.Depended.Materialize.Eval ]
    })
;
;
Class('Scope.Provider', {

    /*VERSION,*/

    has     : {
        name                : null,

        launchId            : null,

        scope               : null,

        seedingCode         : null,
        seedingScript       : null,
        seedingScriptIsEcmaModule : false,

        preload             : {
            is      : 'ro',
            init    : Joose.I.Array
        },

        cleanupCallback         : null,
        beforeCleanupCallback   : null
    },


    methods : {

        isCSS : function (url) {
            return /\.css(\?.*)?$/i.test(url)
        },


        isAlreadySetUp : function () {
            return Boolean(this.scope)
        },


        addPreload : function (preloadDesc) {
            if (this.isAlreadySetUp()) throw new Error("Can't use `addPreload` - scope is already setup. Use `runCode/runScript` instead")

            if (typeof preloadDesc == 'string')

                if (this.isCSS(preloadDesc))
                    preloadDesc = {
                        type        : 'css',
                        url         : preloadDesc
                    }
                else
                    preloadDesc = {
                        type        : 'js',
                        url         : preloadDesc
                    }
            else

                if (preloadDesc.text)
                    preloadDesc = {
                        type        : 'js',
                        content     : preloadDesc.text
                    }

            if (!preloadDesc.type) throw new Error("Preload descriptor must have the `type` property")

            this.preload.push(preloadDesc)
        },


        addOnErrorHandler : function (handler, callback) {
            throw "Abstract method `addOnErrorHandler` of Scope.Provider called"
        },


        create : function () {
            throw "Abstract method `create` of Scope.Provider called"
        },


        setup : function (callback) {
            throw "Abstract method `setup` of Scope.Provider called"
        },


        cleanup : function (callback) {
            throw "Abstract method `cleanup` of Scope.Provider called"
        },


        runCode : function (text, callback) {
            throw "Abstract method `runCode` of Scope.Provider called"
        },


        runScript : function (url, callback) {
            throw "Abstract method `runScript` of Scope.Provider called"
        }
    }
})


Scope.Provider.__ONLOAD__   = {}
Scope.Provider.__ONERROR__  = {}
Scope.Provider.__FAILED_PRELOAD__  = {};
Role('Scope.Provider.Role.WithDOM', {

    requires    : [ 'getDocument', 'create', 'getPreload', 'isAlreadySetUp', 'setViewportSize' ],

    has : {
        useStrictMode               : true,

        sourceURL                   : null,
        crossOriginFailed           : false,

        innerHtmlHead               : null,
        innerHtmlBody               : null,

        minViewportSize             : null,

        parentWindow                : function () { return window },
        scopeId                     : function () { return Math.round(Math.random() * 1e10) },

        failOnResourceLoadError     : false,
        failOnPromiseRejection      : true,

        //                init function
        attachToOnError : function () {

            // returns the value of the attribute
            // the "handler" argument is no longer used, its now being taken from the __ONERROR__ handler every time
            return function (window, scopeId, handler, preventDefault, failOnResourceLoadError, failOnPromiseRejection) {
                handler     = (window.opener || window.parent).Scope.Provider.__ONERROR__[ scopeId  ]

                if (failOnResourceLoadError && ("ErrorEvent" in window)) {
//                    if (window.ErrorEvent.__SIESTA_HOOK_INSTALLED__) return

                    // http://stackoverflow.com/questions/8504673/how-to-detect-on-page-404-errors-using-javascript
                    window.addEventListener('error', handler, true)

//                    window.ErrorEvent.__SIESTA_HOOK_INSTALLED__ = true
                } else {
                    var prevHandler         = window.onerror
                    if (prevHandler && prevHandler.__SP_MANAGED__) return

                    // this, "managed" handler is basically a wrapper around the current value in the "__ONERROR__" hash
                    window.onerror = function (message, url, lineNumber) {
                        // prevent recursive calls if other authors politely has not overwrite the handler and call it
                        if (handler.__CALLING__) return

                        handler.__CALLING__ = true

                        prevHandler && prevHandler.apply(this, arguments)

                        handler.apply(this, arguments)

                        handler.__CALLING__ = false

                        // in FF/IE need to return `true` to prevent default action
                        if (preventDefault !== false) return window.WebKitPoint ? false : true
                    }

                    window.onerror.__SP_MANAGED__ = true
                }

                if (failOnPromiseRejection && window.Promise && ('onunhandledrejection' in window)) {
                    window.addEventListener('unhandledrejection', function (e) {
                        handler.apply(this, [ null, null, null, null, null, e ])
                    }, true)
                }
            }
        },

        // this is a "cached" onerror handler - a handler which was provided before the scope
        // has started the creation process - should be installed ASAP in the creation process
        // to allow catching of the exceptions in the scope with `sourceURL`
        cachedOnError   : null
    },


    override : {

        cleanup : function () {
            var onErrorHandler  = this.cachedOnError

            this.cachedOnError  = null

            // can throw exceptions for cross-domain case
            try {
                var scope       = this.scope

                if (scope.ErrorEvent /*&& scope.ErrorEvent.__SIESTA_HOOK_INSTALLED__*/) scope.removeEventListener('error', onErrorHandler)

                scope.onerror  = null
            } catch (e) {
            }

            this.SUPERARG(arguments)

            this.scope          = null
        }
    },


    methods : {

        cleanupHandlers : function () {
            var scopeProvider   = this.parentWindow.Scope.Provider
            var scopeId         = this.scopeId

            delete scopeProvider.__ONLOAD__[ scopeId ]
            delete scopeProvider.__ONERROR__[ scopeId ]
            delete scopeProvider.__FAILED_PRELOAD__[ scopeId ]
        },


        getHead : function () {
            return this.getDocument().getElementsByTagName('head')[ 0 ]
        },


        installOnErrorHandler : function (handler) {
            if (this.crossOriginFailed) return

            if (!this.isAlreadySetUp()) throw "Scope should be already set up"

            this.attachToOnError(this.scope, this.scopeId, handler, false, this.failOnResourceLoadError, this.failOnPromiseRejection)
        },


        addOnErrorHandler : function (handler, preventDefault) {
            if (this.crossOriginFailed) return

            handler.__SP_MANAGED__  = true

            this.cachedOnError      = handler

            var scopeId     = this.scopeId

            this.parentWindow.Scope.Provider.__ONERROR__[ scopeId ] = handler

            var attachToOnError = ';(' + this.attachToOnError.toString() + ')(window, '
                + scopeId
                + ', (window.opener || window.parent).Scope.Provider.__ONERROR__[ ' + scopeId + ' ], '
                + preventDefault + ', '
                + this.failOnResourceLoadError + ', '
                + this.failOnPromiseRejection
            + ');'

            if (this.isAlreadySetUp())
                this.runCode(attachToOnError)
            else {
                // this is a fallback - run the "attachToOnError" from inside of scope
                this.getPreload().unshift({
                    type        : 'js',
                    content     : attachToOnError,
                    unordered   : true
                })
            }
        },


        addSeedingToPreload : function () {
            var preload             = this.getPreload()

            if (this.seedingCode) preload.unshift({
                type            : 'js',
                content         : this.seedingCode
            })

            if (this.seedingScript) preload.push({
                type            : 'js',
                url             : this.seedingScript,
                isEcmaModule    : this.seedingScriptIsEcmaModule
            })
        },


        setup : function (callback) {
            var isIE                = 'v' == '\v' || Boolean(this.parentWindow.msWriteProfilerMark)
//            var isOpera             = Object.prototype.toString.call(this.parentWindow.opera) == '[object Opera]'
            var hasInlineScript     = false

            Joose.A.each(this.getPreload(), function (preloadDesc) {
                // IE will execute the inline scripts ASAP, this might be not what we want (inline script might be need executed only after some url script)
                // its however ok in some cases (like adding `onerror` handler
                // such inline scripts should be marked with `unordered` - true
                if (preloadDesc.type == 'js' && preloadDesc.content && !preloadDesc.unordered) {
                    hasInlineScript = true

                    return false
                }
            })

            var me          = this

            var cont        = function (e) {
                callback && callback(me, me.parentWindow.Scope.Provider.__FAILED_PRELOAD__[ me.scopeId ], e)
            }

            this.parentWindow.Scope.Provider.__FAILED_PRELOAD__[ this.scopeId ] = {}

            if (this.sourceURL || isIE && hasInlineScript) {
                this.addSeedingToPreload()

                this.setupIncrementally(cont)

            } else {
                // for sane browsers just add the seeding code and seeding script to preloads
                if (!isIE) this.addSeedingToPreload()

                // seeding scripts are included only for sane browsers (not IE)
                this.setupWithDocWrite(cont, isIE)
            }
        },


        setupWithDocWrite : function (callback, needToSeed) {
            var html        = []
            var me          = this

            Joose.A.each(this.getPreload(), function (preloadDesc) {

                if (preloadDesc.type == 'js')
                    html.push(
                        me.getScriptTagString(preloadDesc.url, preloadDesc.content, preloadDesc.isEcmaModule)
                    )

                else if (preloadDesc.type == 'css')
                    html.push(
                        me.getLinkTagString(preloadDesc.url, preloadDesc.content)
                    )

                else throw "Incorrect preload descriptor " + preloadDesc
            })

            // no need to wait for DOM ready - we'll overwrite it anyway
            this.create()

            var scopeId              = this.scopeId

            this.parentWindow.Scope.Provider.__ONLOAD__[ scopeId ]    = function () {
                var cont = function () { callback && callback() }

                // sane browsers - seeding code and script has been already added
                if (!needToSeed) { cont(); return }

                // our beloved IE - manually seeding the scope

                if (me.seedingCode) me.runCode(me.seedingCode, null)

                if (me.seedingScript)
                    me.runScript(me.seedingScript, cont, me.seedingScriptIsEcmaModule)
                else
                    cont()
            }

            var doc             = this.getDocument()

            doc.open()

            doc.write([
                this.useStrictMode ? '<!DOCTYPE html>' : '',
                '<html style="width: 100%; height: 100%; margin : 0; padding : 0;">',
                    '<head>',
                        this.innerHtmlHead || '',
                        html.join(''),
                    '</head>',

                    // delay here is for IE9 - the "onerror" handlers of the <script> tags are fired _after_ <body> onload otherwise
                    '<body style="margin : 0; padding : 0; width: 100%; height: 100%" onload="setTimeout(function () { (window.opener || window.parent).Scope.Provider.__ONLOAD__[' + scopeId + ']() }, 0)">',
                        this.innerHtmlBody || '',
                    '</body>',
                '</html>'
            ].join(''))

            doc.close()

            // Chrome (Webkit?) will clear the `onerror` after "doc.open()/.close()" so need to re-install it
            if (me.cachedOnError) me.installOnErrorHandler(me.cachedOnError)
        },


        setupIncrementally : function (callback) {
            // here the "onerror" should be included early in the "preloads"
            this.create(function (me, e) {
                if (e) {
                    callback && callback(e)
                    return
                }

                if (!me.sourceURL) {
                    var doc     = me.getDocument()

                    if (me.innerHtmlHead) {
                        var head    = me.getHead()

                        // IE9 throws exception when accessing innerHTML of the <head> - its read only
                        try {
                            head.innerHTML  = me.innerHtmlHead
                        } catch (e) {
                            var div         = doc.createElement('div')

                            div.innerHTML   = me.innerHtmlHead

                            for (var i = 0; i < div.children.length; i++) head.appendChild(div.children[ i ])
                        }
                    }

                    if (me.innerHtmlBody) doc.body.innerHTML = me.innerHtmlBody
                }

                var loadScripts     = function (preloads, callback) {

                    var cont = function () {
                        // cleanup can happen in the middle of setup
                        if (me.scope) loadScripts(preloads, callback)
                    }

                    if (!preloads.length)
                        callback && callback()
                    else {
                        var preloadDesc     = preloads.shift()

                        if (preloadDesc.url)
                            me.runScript(preloadDesc.url, cont, preloadDesc.isEcmaModule)
                        else
                            if (preloadDesc.type == 'js')
                                me.runCode(preloadDesc.content, cont, preloadDesc.isEcmaModule)
                            else {
                                me.addStyleTag(preloadDesc.content)

                                cont()
                            }
                    }
                }

                // cleanup can happen in the middle of setup
                if (me.scope) loadScripts(me.getPreload().slice(), callback)
            })
        },


        getScriptTagString : function (url, text, isEcmaModule) {
            var type    = isEcmaModule ? 'module' : 'text/javascript',
                res     = '<script type="' + type + '"' + (isEcmaModule ? ' crossorigin="anonymous"' : '')

            var onerror = '(window.opener || window.parent).Scope.Provider.__FAILED_PRELOAD__[ scopeId ][ url ] = true'

            onerror     = onerror.replace(/scopeId/, "'" + this.scopeId + "'").replace(/url/, "'" + url + "'")

            if (url)
                res     += ' src="' + url + '" onerror="' + onerror + '"></script>'
            else
                res     += '>' + text.replace(/<\/script>/gi, '\\x3C/script>') + '</script>'

            return res
        },


        getLinkTagString : function (url, text) {
            if (url) return '<link href="' + url + '" rel="stylesheet" type="text/css" />'

            if (text) return '<style>' + text + '</style>'
        },



        loadCSS : function (url, callback) {
            var doc         = this.getDocument()
            var link        = doc.createElement('link')

            link.type       = 'text/css'
            link.rel        = 'stylesheet'
            link.href       = url

            var hasOnLoad   = false

            if ('onload' in link) {
                hasOnLoad   = true

                link.onload = function () {
                    link.onload     = null

                    if (callback) callback()

                    callback        = null
                    link            = null
                }
            }

            this.getHead().appendChild(link)

            if (!hasOnLoad) {
                var hasContinued    = false

                var cont            = function () {
                    // just in case some crazy JS engine calls `onerror` even after node removal
                    if (hasContinued) return
                    hasContinued    = true
                    clearTimeout(forcedTimeout)

                    if (callback) callback()

                    doc.body.removeChild(img)
                }

                var forcedTimeout   = setTimeout(cont, 30000)

                var img             = doc.createElement('img')

                img.onerror         = cont

                doc.body.appendChild(img)

                img.src             = url
            }
        },


        runCode : function (text, callback, isEcmaModule) {
            if (this.crossOriginFailed) {
                callback && callback()

                return
            }

            this.getHead().appendChild(this.createScriptTag(text, null, null, null, isEcmaModule))

            callback && callback()
        },


        runScript : function (url, callback, isEcmaModule) {
            if (this.crossOriginFailed) {
                callback && callback()

                return
            }

            var scopeId     = this.scopeId

            if (this.isCSS(url))
                this.loadCSS(url, callback)
            else {
                var onerror = function () {
                    this.onerror    = null

                    var doc         = this.ownerDocument
                    var win         = doc.defaultView || doc.parentWindow

                    ;(win.opener || win.parent).Scope.Provider.__FAILED_PRELOAD__[ scopeId ][ url ] = true

                    callback()
                }

                this.getHead().appendChild(this.createScriptTag(null, url, callback, onerror, isEcmaModule))
            }
        },


        createScriptTag : function (text, url, callback, errback, isEcmaModule) {
            var node = this.getDocument().createElement("script")

            node.setAttribute("type", isEcmaModule ? 'module' : 'text/javascript')
            isEcmaModule && node.setAttribute("crossorigin", "anonymous")

            if (url) node.setAttribute("src", url)

            if (text) node.text = text

            if (callback)
                node.onload = node.onreadystatechange = function () {
                    if (!node.readyState || node.readyState == "loaded" || node.readyState == "complete" || node.readyState == 4 && node.status == 200) {
                        node.onload = node.onreadystatechange = null

                        //surely for IE6..
                        if ('v' == '\v')
                            setTimeout(callback, 0)
                        else
                            callback()
                    }
                }

            if (errback) node.onerror = errback

            return node
        },


        addStyleTag : function (text) {
            var document    = this.getDocument()
            var node        = document.createElement('style')

            node.setAttribute("type", "text/css")

            var head = document.getElementsByTagName('head')[0]
            head.appendChild(node)

            if (node.styleSheet) {   // IE
                node.styleSheet.cssText = text
            } else {                // the world
                node.appendChild(document.createTextNode(text))
            }
        }
    }
})


/**

Name
====

Scope.Provider.Role.WithDOM - role for scope provider, which uses `script` tag for running the code.


SYNOPSIS
========

        Class('Scope.Provider.IFrame', {

            isa     : Scope.Provider,

            does    : Scope.Provider.Role.WithDOM,

            ...
        })

DESCRIPTION
===========

`Scope.Provider.Role.WithDOM` requires the implementation of the `getDocument` method, which should return the
document into which the `script` tags will be created.

In return, this role provides the implementation of `runCode` and `runScript`.




GETTING HELP
============

This extension is supported via github issues tracker: <http://github.com/SamuraiJack/Scope-Provider/issues>

For general Joose questions you can also visit [#joose](http://webchat.freenode.net/?randomnick=1&channels=joose&prompt=1)
on irc.freenode.org or the forum at: <http://joose.it/forum>



SEE ALSO
========

Web page of this module: <http://github.com/SamuraiJack/Scope-Provider/>

General documentation for Joose: <http://joose.github.com/Joose>


BUGS
====

All complex software has bugs lurking in it, and this module is no exception.

Please report any bugs through the web interface at <http://github.com/SamuraiJack/Scope-Provider/issues>



AUTHORS
=======

Nickolay Platonov <nplatonov@cpan.org>





COPYRIGHT AND LICENSE
=====================

This software is Copyright (c) 2010 by Nickolay Platonov <nplatonov@cpan.org>.

This is free software, licensed under:

  The GNU Lesser General Public License, Version 3, June 2007

*/
;
Class('Scope.Provider.IFrame', {
    
    isa     : Scope.Provider,
    
    does    : Scope.Provider.Role.WithDOM,
    
    
    have : {
        iframe          : null,
        cls             : null,
        
        performWrap     : false,
        wrapCls         : null,
        wrapper         : null,
        
        // should be inside of the `wrapper` el
        iframeParentEl  : null,
        parentEl        : null,
        
        cleanupDelay    : 1000
    },
    

    methods : {
        
        getDocument : function () {
            return this.iframe.contentWindow.document
        },
        
        
        setViewportSize : function (width, height) {
            var iframe              = this.iframe
            
            if (!iframe) return
            
            iframe.style.width      = width + 'px'
            iframe.style.height     = height + 'px'
        },
        
        
        create : function (onLoadCallback) {
            var me                  = this
            var doc                 = this.parentWindow.document
            var iframe              = this.iframe = doc.createElement('iframe')
            
            var minViewportSize     = this.minViewportSize
            
            iframe.className        = this.cls || ''
            iframe.style.width      = (minViewportSize && minViewportSize.width || 1024) + 'px'
            iframe.style.height     = (minViewportSize && minViewportSize.height || 768) + 'px'
            iframe.setAttribute('frameborder', 0)
            
            if (this.name) iframe.setAttribute('name', this.name)

            var ignoreOnLoad        = false    
            
            var callback = function () {
                if (ignoreOnLoad) return
                
                if (iframe.detachEvent) 
                    iframe.detachEvent('onload', callback)
                else
                    iframe.onload = null
                    
                try {
                    var headContent = me.getHead().innerHTML
                    
                    onLoadCallback && onLoadCallback(me)
                } catch (e) {
                    // cross-origin exception
                    me.crossOriginFailed    = true
                    
                    onLoadCallback && onLoadCallback(me, e)
                }
            }
            
            if (iframe.attachEvent) 
                iframe.attachEvent('onload', callback)
            else
                iframe.onload   = callback
            
            iframe.src = this.sourceURL || 'about:blank'
            
            if (this.performWrap) {
                var wrapper             = this.wrapper
                
                if (!wrapper) {
                    wrapper             = this.wrapper = doc.createElement('div')
                    wrapper.className   = this.wrapCls || ''
                }
                
                ;(this.iframeParentEl || wrapper).appendChild(iframe)
                
                // no required anymore, since whole wrapper will be removed
                this.iframeParentEl     = null
            } 
            
            ;(this.parentEl || doc.body).appendChild(wrapper || iframe)
            
            var scope       = this.scope = iframe.contentWindow
            
            // dances with tambourine around the IE (probably for some old version, remove one day)
            if ('v' == '\v' || Boolean(this.parentWindow.msWriteProfilerMark)) {
                try {
                    var scopeDoc    = this.getDocument()
                    // only ignore the 1st call to callback when there is a `sourceURL` config
                    // which will later be assigned to `iframe.src` and will trigger a new iframe loading
                    if (this.sourceURL) ignoreOnLoad = true
                    
                    scopeDoc.open()
                    scopeDoc.write([
                        this.useStrictMode ? '<!DOCTYPE html>' : '',
                        '<html style="width: 100%; height: 100%; margin : 0; padding : 0;">',
                            '<head>',
                            '</head>',
                            '<body style="margin : 0; padding : 0; width: 100%; height: 100%">',
                            '</body>',
                        '</html>'
                    ].join(''))
                    scopeDoc.close()
                    
                    ignoreOnLoad = false
                } catch (e) {
                    // cross-origin exception
                    me.crossOriginFailed    = true
                }
                
                iframe.onreadystatechange = function () {
                    if (iframe.readyState == 'complete') iframe.onreadystatechange = null
                    
                    // trying to add the "early" onerror handler on each "readyState" change
                    // for some mystical reasons can't use `me.installOnErrorHandler` need to inline the call
                    if (me.cachedOnError && !me.crossOriginFailed) me.attachToOnError(scope, me.scopeId, me.cachedOnError)
                }
                
                if (this.sourceURL) iframe.src = this.sourceURL
            }
            
            // trying to add the "early" onerror handler - installing it in this stage will only work in FF 
            // (other browsers will clear on varios stages)
            if (me.cachedOnError) me.installOnErrorHandler(me.cachedOnError)
        },
        
        
        cleanup : function () {
            var wrapper     = this.wrapper || this.iframe
            var iframe      = this.iframe
            var me          = this
            
            // remove this property one more time, because sometimes it is not cleared in IE
            // (seems "onreadystatechange" is not fired)
            iframe.onreadystatechange   = null
            
            wrapper.style.display    = 'none'
            
            var onUnloadChecker = function () {
                if (!window.onunload) window.onunload = function () { return 'something' }
            }
            
            // add the `onunload` handler if there's no any - attempting to prevent browser from caching the iframe
            // trying to create the handler from inside of the scope
            this.runCode(';(' + onUnloadChecker.toString() + ')();')

            this.iframe     = null
            this.scope      = null
            this.wrapper    = null

            if (me.beforeCleanupCallback) me.beforeCleanupCallback()
            me.beforeCleanupCallback    = null
            
            if (!me.crossOriginFailed)
                // chaging the page, triggering `onunload` and hopefully preventing browser from caching the content of iframe
                iframe.src      = 'javascript:false'
            
            // wait again before removing iframe from the DOM, as recommended by some online sources
            setTimeout(function () {
                ;(me.parentEl || me.parentWindow.document.body).removeChild(wrapper)
                
                wrapper     = null
                iframe      = null
                
                me.parentEl = null
                
                me.cleanupHandlers()
                
                if (me.cleanupCallback) me.cleanupCallback()
                me.cleanupCallback  = null
                
            }, me.cleanupDelay)
        }
    }
})

/**

Name
====

Scope.Provider.IFrame - scope provider, which uses the iframe.


SYNOPSIS
========

        var provider = new Scope.Provider.IFrame()
        
        provider.setup(function () {
        
            if (provider.scope.SOME_GLOBAL == 'some_value') {
                ...
            }
            
            provider.runCode(text, callback)
            
            ...
            
            provider.runScript(url, callback)
            
            ...
            
            provider.cleanup()        
        })


DESCRIPTION
===========

`Scope.Provider.IFrame` is an implementation of the scope provider, which uses the iframe, 
to create a new scope.


ISA
===

[Scope.Provider](../Provider.html)


DOES
====

[Scope.Provider.Role.WithDOM](Role/WithDOM.html)



GETTING HELP
============

This extension is supported via github issues tracker: <http://github.com/SamuraiJack/Scope-Provider/issues>

You can also ask questions at IRC channel : [#joose](http://webchat.freenode.net/?randomnick=1&channels=joose&prompt=1)
 
Or the mailing list: <http://groups.google.com/group/joose-js>
 


SEE ALSO
========

Web page of this module: <http://github.com/SamuraiJack/Scope-Provider/>

General documentation for Joose: <http://joose.github.com/Joose>


BUGS
====

All complex software has bugs lurking in it, and this module is no exception.

Please report any bugs through the web interface at <http://github.com/SamuraiJack/Scope-Provider/issues>



AUTHORS
=======

Nickolay Platonov <nplatonov@cpan.org>





COPYRIGHT AND LICENSE
=====================

This software is Copyright (c) 2010 by Nickolay Platonov <nplatonov@cpan.org>.

This is free software, licensed under:

  The GNU Lesser General Public License, Version 3, June 2007

*/;
Class('Scope.Provider.Window', {

    isa     : Scope.Provider,

    does    : Scope.Provider.Role.WithDOM,


    has     : {
        popupWindow     : null
    },


    methods : {

        setViewportSize : function (width, height) {
            var popupWindow     = this.popupWindow

            if (!popupWindow) return

            // is not guaranteed to work
            popupWindow.resizeTo(width, height)
        },


        create : function (onLoadCallback) {
            var minViewportSize     = this.minViewportSize

            var width       = minViewportSize && minViewportSize.width || 1024
            var height      = minViewportSize && minViewportSize.height || 768

            var popup       = this.scope = this.popupWindow = this.parentWindow.open(
                // left/top is set to > 0 value with intent to keep the mouse cursor outside of the popup
                // its always recommened to set the mousecursor position to 0, 0 in the automation script
                this.sourceURL || 'about:blank',
                '_blank',
                "left=10,top=10,width=" + width + ",height=" + height
            )

            if (!popup) {
                alert('Please enable popups for the host with this test suite running: ' + this.parentWindow.location.host)
                throw 'Please enable popups for the host with this test suite running: ' + this.parentWindow.location.host
            }

            var isIE = 'v' == '\v' || Boolean(this.parentWindow.msWriteProfilerMark)

            // dances with tambourine around the IE
            if (isIE && !this.sourceURL) {
                var doc = this.getDocument()

                doc.open()
                doc.write('')
                doc.close()
            }

            // trying to add the "early" onerror handler - will probably only work in FF
            if (this.cachedOnError) this.installOnErrorHandler(this.cachedOnError)

            /*!
             * contentloaded.js
             *
             * Author: Diego Perini (diego.perini at gmail.com)
             * Summary: cross-browser wrapper for DOMContentLoaded
             * Updated: 20101020
             * License: MIT
             * Version: 1.2
             *
             * URL:
             * http://javascript.nwbox.com/ContentLoaded/
             * http://javascript.nwbox.com/ContentLoaded/MIT-LICENSE
             *
             */

            var me              = this

            // @win window reference
            // @fn function reference
            var contentLoaded = function (win, fn) {

                var done = false, top = true,

                doc = win.document, root = doc.documentElement,

                add = doc.addEventListener ? 'addEventListener' : 'attachEvent',
                rem = doc.addEventListener ? 'removeEventListener' : 'detachEvent',
                pre = doc.addEventListener ? '' : 'on',

                init = function(e) {
                    if (e.type == 'readystatechange' && doc.readyState != 'complete') return;

                    (e.type == 'load' ? win : doc)[ rem ](pre + e.type, init, false);

                    if (!done && (done = true)) fn.call(win, me);
                },

                poll = function () {
                    try { root.doScroll('left'); } catch(e) { setTimeout(poll, 50); return; }

                    init('poll');
                };

                if (doc.readyState == 'complete')
                    fn.call(win, me);
                else {
                    if (doc.createEventObject && root.doScroll) {
                        try { top = !win.frameElement; } catch(e) { }
                        if (top) poll();
                    }
                    doc[add](pre + 'DOMContentLoaded', init, false);
                    doc[add](pre + 'readystatechange', init, false);
                    win[add](pre + 'load', init, false);
                }
            }

            if (this.sourceURL)
                // seems the "doc.readyState" is set before the DOM is created on the page
                // if one will start interact with page immediately he can overwrite the page content
                setTimeout(function () {
                    contentLoaded(popup, onLoadCallback || function () {})
                }, 10)
            else
                contentLoaded(popup, onLoadCallback || function () {})
        },


        getDocument : function () {
            return this.popupWindow.document
        },


        cleanup : function () {
            if (this.beforeCleanupCallback) this.beforeCleanupCallback()
            this.beforeCleanupCallback      = null

            this.popupWindow.close()

            this.popupWindow = null

            this.cleanupHandlers()
            if (this.cleanupCallback) this.cleanupCallback()
            this.cleanupCallback            = null
        }
    }
})

/**

Name
====

Scope.Provider.Window - scope provider, which uses the popup browser window.


SYNOPSIS
========

        var provider = new Scope.Provider.Window()

        provider.setup(function () {

            if (provider.scope.SOME_GLOBAL == 'some_value') {
                ...
            }

            provider.runCode(text, callback)

            ...

            provider.runScript(url, callback)

            ...

            provider.cleanup()
        })


DESCRIPTION
===========

`Scope.Provider.Window` is an implementation of the scope provider, which uses the popup browser window,
to create a new scope.


ISA
===

[Scope.Provider](../Provider.html)


DOES
====

[Scope.Provider.Role.WithDOM](Role/WithDOM.html)



GETTING HELP
============

This extension is supported via github issues tracker: <http://github.com/SamuraiJack/Scope-Provider/issues>

You can also ask questions at IRC channel : [#joose](http://webchat.freenode.net/?randomnick=1&channels=joose&prompt=1)

Or the mailing list: <http://groups.google.com/group/joose-js>



SEE ALSO
========

Web page of this module: <http://github.com/SamuraiJack/Scope-Provider/>

General documentation for Joose: <http://joose.github.com/Joose>


BUGS
====

All complex software has bugs lurking in it, and this module is no exception.

Please report any bugs through the web interface at <http://github.com/SamuraiJack/Scope-Provider/issues>



AUTHORS
=======

Nickolay Platonov <nplatonov@cpan.org>





COPYRIGHT AND LICENSE
=====================

This software is Copyright (c) 2010 by Nickolay Platonov <nplatonov@cpan.org>.

This is free software, licensed under:

  The GNU Lesser General Public License, Version 3, June 2007

*/;
Class('Scope.Provider.NodeJS', {

    isa     : Scope.Provider,


    has     : {
        sourceURL               : null,
        requireFunc             : null,

        errorHandlerBorrowed    : null,
        onErrorHandler          : null
    },


    methods : {

        runInContext : function (code, scope, options) {
            var vm          = require('vm')

            return vm.runInContext(code, scope, options)
        },


        addOnErrorHandler : function (handler, preventDefault) {
            var me          = this

            if (me.eventHandlerBorrowed) throw new Error("Exclusive resource borrowing failed")

            me.onErrorHandler   = handler

            var exceptionHander
            var rejectionHandler

            process.on('uncaughtException', exceptionHandler = function (e) {
                handler(e.message, null, null, null, e)
            })

            process.on('unhandledRejection', rejectHandler = function (reason) {
                handler(null, null, null, null, null, { reason : reason })
            })

            return me.eventHandlerBorrowed = function () {
                process.removeListener('uncaughtException', exceptionHandler)
                process.removeListener('unhandledRejection', rejectHandler)

                me.eventHandlerBorrowed     = null
                me.onErrorHandler           = null
            }
        },


        create : function (callback) {
            var vm          = require('vm')
            var sandbox     = {}

            Joose.O.extend(sandbox, {
                process         : process,
                console         : console,

                global          : sandbox,

                // TODO wrap this in functions in target context
                // currently in the test context `setTimeout instanceOf Function === false`
                setImmediate    : setImmediate,
                clearImmediate  : clearImmediate,
                setTimeout      : setTimeout,
                clearTimeout    : clearTimeout,
                setInterval     : setInterval,
                clearInterval   : clearInterval
            })

            var scope       = this.scope    = vm.createContext(sandbox)

            callback && callback()
        },


        setup : function (callback) {
            this.create()

            var me      = this

            if (this.seedingCode) this.runCode(this.seedingCode)

            Joose.A.each(this.getPreload(), function (preloadDesc) {

                if (preloadDesc.type == 'js')
                    if (preloadDesc.url)
                        me.runScript(preloadDesc.url)
                    else
                        me.runCode(preloadDesc.content)
            })

            if (this.seedingScript) {
                this.runScript(this.seedingScript)
            }

            callback && callback(me)
        },


        stripBom : function (content) {
            // Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
            // because the buffer-to-string conversion in `fs.readFileSync()`
            // translates it to FEFF, the UTF-16 BOM.
            if (content.charCodeAt(0) === 0xFEFF) content = content.slice(1)

            return content
        },


        fileNameToModuleId : function (url) {
            var path        = require('path')

            var filename

            if (path.isAbsolute(url)) {
                filename    = url
            } else {
                filename    = path.resolve('./', url)
            }

            return filename
        },


        runCode : function (text, callback) {
            var vm          = require('vm')

            var res         = vm.runInContext(this.stripBom(text), this.scope)

            callback && callback(res)

            return res
        },


        runScript : function (url, callback) {
            if (/mjs(\?.*)?$/.test(url)) {
                return this.importEcmaModule(url, callback)
            } else
                return this.requireCjsModule(url, callback)
        },


        requireCjsModule : function (url, callback) {
            var vm              = require('vm')

            var old             = vm.runInThisContext
            var scope           = this.scope

            vm.runInThisContext = function (code, options) {
                return vm.runInContext(code, scope, options)
            }

            try {
                var res             = this.requireFunc(this.fileNameToModuleId(url))
            } catch (e) {
                this.onErrorHandler && this.onErrorHandler(e.message, null, null, null, e)
            }

            vm.runInThisContext = old

            callback && callback(res)

            return res
        },


        importEcmaModule : function (url, callback) {
            // seems node only support dynamic `import` for the current context
            // see how it is implemented in NodeJsEmbed
            throw new Error("Ecma module for different context - implement me?")
        },


        cleanup : function () {
            if (this.beforeCleanupCallback) this.beforeCleanupCallback()
            if (this.cleanupCallback) this.cleanupCallback()
        }
    }
})
;
Class('Scope.Provider.NodeJsEmbed', {

    isa     : Scope.Provider.NodeJS,


    methods : {

        runCode : function (text, callback) {
            var vm          = require('vm')

            // the '/' filename is required for loading Ecma modules
            // this goes as "referrer" for the module url
            var res         = vm.runInThisContext(this.stripBom(text), { filename : '/' })

            callback && callback(res)

            return res
        },


        requireCjsModule : function (url, callback) {
            try {
                var res         = this.requireFunc(this.fileNameToModuleId(url))
            } catch (e) {
                this.onErrorHandler && this.onErrorHandler(e.message, null, null, null, e)
            }

            callback && callback(res)

            return res
        },


        importEcmaModule : function (url, callback) {
            // seems node supports dynamic `import` ONLY for the current context (on the C++ level)
            this.runCode("import('" + this.fileNameToModuleId(url) + "')").then(
                function (res) { callback && callback(res) },
                function () {}
            )
        },


        create : function (callback) {
            this.scope      = SCOPE

            callback && callback()
        }
    }
})
;
;
/*
    http://www.JSON.org/json2.js
    2011-02-23

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html


    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.


    This file creates a global JSON object containing two methods: stringify
    and parse.

        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.

            replacer    an optional parameter that determines how object
                        values are stringified for objects. It can be a
                        function or an array of strings.

            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t' or '&nbsp;'),
                        it contains the characters used to indent at each level.

            This method produces a JSON text from a JavaScript value.

            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method
            will be passed the key associated with the value, and this will be
            bound to the value

            For example, this would serialize Dates as ISO strings.

                Date.prototype.toJSON = function (key) {
                    function f(n) {
                        // Format integers to have at least two digits.
                        return n < 10 ? '0' + n : n;
                    }

                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                };

            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.

            If the replacer parameter is an array of strings, then it will be
            used to select the members to be serialized. It filters the results
            such that only members with keys listed in the replacer array are
            stringified.

            Values that do not have JSON representations, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.

            The optional space parameter produces a stringification of the
            value that is filled with line breaks and indentation to make it
            easier to read.

            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            the indentation will be that many spaces.

            Example:

            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            // text is '["e",{"pluribus":"unum"}]'


            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

            text = JSON.stringify([new Date()], function (key, value) {
                return this[key] instanceof Date ?
                    'Date(' + this[key] + ')' : value;
            });
            // text is '["Date(---current time---)"]'


        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
                var d;
                if (typeof value === 'string' &&
                        value.slice(0, 5) === 'Date(' &&
                        value.slice(-1) === ')') {
                    d = new Date(value.slice(5, -1));
                    if (d) {
                        return d;
                    }
                }
                return value;
            });


    This is a reference implementation. You are free to copy, modify, or
    redistribute.
*/

// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

var JSON;
if (!JSON) {
    JSON = {};
}

(function () {
    "use strict";

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function (key) {

            return isFinite(this.valueOf()) ?
                this.getUTCFullYear()     + '-' +
                f(this.getUTCMonth() + 1) + '-' +
                f(this.getUTCDate())      + 'T' +
                f(this.getUTCHours())     + ':' +
                f(this.getUTCMinutes())   + ':' +
                f(this.getUTCSeconds())   + 'Z' : null;
        };

        String.prototype.toJSON      =
            Number.prototype.toJSON  =
            Boolean.prototype.toJSON = function (key) {
                return this.valueOf();
            };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string' ? c :
                '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === 'string') {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0 ? '{}' : gap ?
                '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
                '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function' ?
                    walk({'': j}, '') : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }
}());
;
!function () {
    
    var REF      = 1    

    Class('Data.Visitor2', {
        
        has : {
            seenPlaceholder : {
                init        : {}
            },
            
            outOfDepthPlaceholder : {
                init        : {}
            },
            
            seen            : Joose.I.Object,
            
            maxDepth        : null
        },
            
        methods : {
            
            getClassNameFor : function (object) {
                if (Joose.O.isInstance(object))      return object.meta.name
                
                return Object.prototype.toString.call(object).replace(/^\[object /, '').replace(/\]$/, '')
            },
            
            
            getRefAdr : function () {
                return REF++
            },
            
            
            assignRefAdrTo : function (object) {
                if (!object.__REFADR__) 
                    if (Object.defineProperty)
                        Object.defineProperty(object, '__REFADR__', { value : REF++ })
                    else
                        object.__REFADR__ = REF++
                
                return object.__REFADR__
            },
                
                
            isSeen : function (object) {
                return object.__REFADR__ && this.seen.hasOwnProperty(object.__REFADR__)
            },
            
            
            markSeenAs : function (object, result) {
                return this.seen[ object.__REFADR__ ] = result
            },
            
            
            hasSeenResultFor : function (object) {
                var ref = object.__REFADR__
                
                return this.seen.hasOwnProperty(ref) && this.seen[ ref ] != this.seenPlaceholder
            },
            
            
            visit : function (value, depth) {
                // will be false for NaN values
                if (depth > this.maxDepth)
                    return this.visitOutOfDepthValue(value, depth + 1)
                else
                    if (Object(value) === value)
                        if (this.isSeen(value)) 
                            return this.visitSeen(value, depth + 1)
                        else                        
                            return this.visitNotSeen(value, depth + 1)
                    else
                        return this.visitValue(value, depth + 1)
            },
            
            
            visitOutOfDepthValue : function (value, depth) {
                return this.outOfDepthPlaceholder
            },
            
            
            visitValue : function (value, depth) {
                return value
            },
            
            
            visitSeen : function (value, depth) {
                return this.seen[ value.__REFADR__ ]
            },
            
            
            getInitialSeenMarker : function (object, depth) {
                return this.seenPlaceholder
            },
            
            
            visitNotSeen : function (object, depth) {
                this.assignRefAdrTo(object)
                
                this.markSeenAs(object, this.getInitialSeenMarker(object, depth))
    
                
                if (Joose.O.isInstance(object)) return this.markSeenAs(object, this.visitJooseInstance(object, depth))
                
                
                var methodName = 'visit' + this.getClassNameFor(object)
                
                if (!this.meta.hasMethod(methodName)) methodName = 'visitObject' 
                
                return this.markSeenAs(object, this[ methodName ](object, depth))
            },
            
            
            visitArray  : function (array, depth) {
                Joose.A.each(array, function (value, index) {
                    
                    this.visitArrayEntry(value, index, array, depth)
                    
                }, this)
                
                return array
            },
            
            
            visitArrayEntry  : function (entry, index, array, depth) {
                return this.visit(entry, depth)
            },
            
            
            visitObject : function (object, depth) {
                
                Joose.O.eachOwn(object, function (value, key) {
                    
                    if (key != '__REFADR__') {
                        this.visitObjectKey(key, value, object, depth)
                        this.visitObjectValue(value, key, object, depth)
                    }
                    
                }, this)
                
                return object
            },
            
            
            visitJooseInstance : function (value, depth) {
                return this.visitObject(value, depth)
            },
            
            
            visitObjectKey : function (key, value, object, depth) {
                return this.visitValue(key, depth)
            },
            
            
            visitObjectValue : function (value, key, object, depth) {
                return this.visit(value, depth)
            }
        },
        
        
        my : {
            
            has : {
                HOST        : null
            },
            
            
            methods : {
                
                visit : function (value, maxDepth) {
                    var visitor     = new this.HOST({
                        maxDepth        : maxDepth || Infinity
                    })
                    
                    return visitor.visit(value, 0)
                }
            }
        }
    })    
    
}()


;
;
;
Class('Siesta.Util.Serializer', {

    isa : Data.Visitor2,

    has     : {
        result                  : Joose.I.Array,
        manualEnum              : function () {
            for (var i in { toString : 1 }) return false

            return true
        }
    },


    methods : {

        assignRefAdrTo : function (object) {
            try {
                return this.SUPER(object)
            } catch (e) {
                if (!object.__REFADR__) object.__REFADR__ = this.getRefAdr()
            }

            return object.__REFADR__
        },


        write : function (str) {
            this.result.push(str)
        },


        visitOutOfDepthValue : function (value, depth) {
            this.write('...')
        },


        visitSymbol: function (value) {
            this.write(value.toString())
        },


        visitValue : function (value) {
            if (value == null)
                // `null` and `undefined`
                this.write(value + '')
            else {
                if (typeof value === 'symbol')
                    this.write(value.toString())
                else
                    this.write(typeof value == 'string' ? '"' + value.replace(/"/g, '\\"').replace(/\n/g, '\\n') + '"' : value + '')
            }
        },


        visitObjectKey : function (key, value, object) {
            this.write('"' + key + '": ')
        },


        getClassNameFor : function (object) {
            if (object.nodeType != null && object.nodeName != null && object.tagName) return 'DOMElement'

            // trying to detect and not dive into global window
            if (object.document != null && object.location != null && object.location.href != null) return 'Window'

            return this.SUPER(object)
        },


        visitSeen : function (value, depth) {
            this.write('[Circular]')
        },


        visitRegExp : function (value, depth) {
            this.write(value + '')
        },


        visitFunction : function (value, depth) {
            this.write('function ' + (value.name || '') + '() { ... }')
        },


        visitDate : function (value, depth) {
            this.write('"' + value + '"')
        },


        // safer alternative to parent's implementation of `visitObject` - some host objects has no "hasOwnProperty" method
        visitObject : function (object, depth) {
            for (var key in object) {
                if (key != '__REFADR__' && (!object.hasOwnProperty || object.hasOwnProperty(key))) {
                    var value   = object[ key ]

                    this.visitObjectKey(key, value, object, depth)
                    this.visitObjectValue(value, key, object, depth)
                }
            }

            var me  = this

            if (this.manualEnum)
                Joose.A.each([ 'hasOwnProperty', 'valueOf', 'toString', 'constructor' ], function (key) {
                    if (object.hasOwnProperty && object.hasOwnProperty(key)) {
                        var value   = object[ key ]

                        me.visitObjectKey(key, value, object, depth)
                        me.visitObjectValue(value, key, object, depth)
                    }
                })

            return object
        },


        visitJooseInstance : function (value, depth) {
            if (value.meta.hasMethod('toString')) {
                this.write(value.toString())

                return value
            }

            return this.SUPERARG(arguments)
        },


        visitDOMElement : function (object, depth) {
            var output  = '&lt;' + object.tagName

            if (object.id) output += ' id="' + object.id + '"'
            if (object.className) output += ' class="' + object.className + '"'

            this.write(output + '&gt;')
        },


        visitDOMStringMap : function () {
            this.write('[DOMStringMap]')
        },


        // the Object.prototype.toString.call(window) for FF
        visitWindow : function () {
            this.write('[window]')
        },


        // window.location type in FF
        visitLocation : function () {
            this.write('[window.location]')
        },


        visitMap : function (map) {
            this.write('Map(' + map.size + '){')

            // we use iterator here instead of simple "for .. of" loop, because IE does not support it
            var iterator        = map.entries()

            for (var entry = iterator.next(); !entry.done; entry = iterator.next()) {
                this.visit(entry.value[ 0 ])
                this.write('=>')
                this.visit(entry.value[ 1 ])
                this.write(', ')
            }

            if (map.size > 0) this.result.pop()

            this.write('}')
        }
    },


    before : {
        visitObject : function () {
            this.write('{')
        },


        visitArray : function () {
            this.write('[')
        }
    },


    after : {
        visitObject : function () {
            var result = this.result

            if (result[ result.length - 1 ] == ', ') result.pop()

            this.write('}')
        },


        visitArray : function () {
            var result = this.result

            if (result[ result.length - 1 ] == ', ') result.pop()

            this.write(']')
        },


        visitObjectValue : function () {
            this.write(', ')
        },


        visitArrayEntry : function () {
            this.write(', ')
        }
    },


    my : {

        has : {
            HOST        : null
        },


        methods : {

            stringify : function (value, maxDepth) {
                try {
                    if (value != null && value.foobar) visitor = null
                } catch (e) {
                    if (value) return 'Value from cross-domain context'
                }

                var visitor     = new this.HOST({
                    maxDepth        : maxDepth || 4
                })

                visitor.visit(value, 0)

                return visitor.result.join('')
            }
        }
    }
})
;
Role('Siesta.Util.Role.CanFormatStrings', {

    has     : {
        serializeFormatingPlaceholders      : true
    },

    methods : {

        formatString: function (string, data) {
            if (!data) return string

            var match
            var variables           = []
            var isRaw               = []
            var regexp              = /\{(\!)?((?:\w|-|_)+?)\}/g

            while (match = regexp.exec(string)) {
                isRaw.push(match[ 1 ])
                variables.push(match[ 2 ])
            }

            var result              = string

            Joose.A.each(variables, function (variable, index) {
                var varIsRaw        = isRaw[ index ]

                result              = result.replace(
                    new RegExp('\\{' + (varIsRaw ? '!' : '') + variable + '\\}', 'g'),
                    data.hasOwnProperty(variable) ?
                        varIsRaw || !this.serializeFormatingPlaceholders ? data[ variable ] + '' : Siesta.Util.Serializer.stringify(data[ variable ])
                    :
                        ''
                )
            }, this)

            return result
        },


        // Extract normal chars, or special keys in brackets such as [TAB], [RIGHT] or [ENTER]
        extractKeysAndSpecialKeys : function (string) {
            var KeyCodes        = Siesta.Test.UserAgent.KeyCodes().keys
            var me              = this

            var res             = []
            // either: [[SPECIAL]] (meaning plain text), [SPECIAL] (meaning special char), or any character
            var tokens          = string.match(/(\[\[(?:\w|-){1,11}\]\])|(\[(?:\w|-){1,11}\])|([\s\S])/g) || [];

            Joose.A.each(tokens, function (token, index) {
                if (token.length > 1) {
                    var isDouble        = /\[\[/.test(token)

                    var specialKey      = token.substring(isDouble ? 2 : 1, token.length - (isDouble ? 2 : 1))
                    var normalText      = KeyCodes[ specialKey.toUpperCase() ] === undefined

                    if (normalText || isDouble) {
                        res.push('[')
                        if (normalText && isDouble) res.push('[')
                        res.push.apply(res, me.extractKeysAndSpecialKeys(specialKey))
                        res.push(']')
                        if (normalText && isDouble) res.push(']')
                    } else {
                        res.push(token)
                    }
                } else
                    res.push(token)
            })

            return res
        }
    }
})
;
Role('Siesta.Util.Role.CanGetType', {
    
    methods : {
        
        /**
         * This method returns a result of `Object.prototype.toString` applied to the passed argument. The `[object` and trailing `]` are trimmed.
         *
         * @param {Mixed} object
         * @return {String} The name of the "type" for this object.
         */
        typeOf : function (object) {
            return Object.prototype.toString.call(object).slice(8, -1)
        }
    }
})
;
/**
@class Siesta.Util.Role.CanCompareObjects

A mixin, providing the "compareObjects" method.

*/
Role('Siesta.Util.Role.CanCompareObjects', {

    does    : [
        Siesta.Util.Role.CanGetType
    ],

    methods : {

        countKeys : function (object) {
            var counter = 0

            Joose.O.eachOwn(object, function () {
                counter++
            })

            return counter
        },


        /**
         * This method performs a deep comparison of the passed JavaScript objects. Objects must not contain cyclic references.
         * Supported objects are: Object, Array, Function, RegExp, Date, Map (the latter only for keys of primitive values - strings, numbers and browser >= MS Edge).
         * When comparing Maps, the order of insertion does not matter.
         *
         * You can use this method in your own assertions, since it does not create an actual assertion in the test results,
         * but rather just returns a boolean value with comparison result.
         *
         * @param {Mixed} obj1 The 1st object to compare
         * @param {Mixed} obj2 The 2nd object to compare
         * @param {Boolean} strict When passed the `true` value, the comparison of the primitive values will be performed with the
         * `===` operator (so [ 1 ] and [ "1" ] object will be different). Additionally, when this flag is set to `true`, then
         * when comparing Function, RegExp and Date instances, additional check that objects contains the same set of own properties ("hasOwnProperty")
         * will be performed.
         * @param {Boolean} onlyPrimitives When set to `true`, the function will not recurse into composite objects (like [] or {}) and will just report that
         * objects are different. Use this mode when you are only interested in comparison of primitive values (numbers, strings, etc).
         * @param {Boolean} asObjects When set to `true`, the function will compare various special Object instances, like Functions, RegExp etc,
         * by comparison of their properties only and not taking the anything else into account.
         * @return {Boolean} `true` if the passed objects are equal
         */
        compareObjects : function (obj1, obj2, strict, onlyPrimitives, asObjects) {
            var obj1IsPlaceholder       = Joose.O.isInstance(obj1) && obj1.meta.does(Siesta.Test.Role.Placeholder)
            var obj2IsPlaceholder       = Joose.O.isInstance(obj2) && obj2.meta.does(Siesta.Test.Role.Placeholder)

            if (strict) {
                if (obj1 === obj2) return true
            } else
                if (obj1 == obj2) return true

            if (obj1IsPlaceholder && obj2IsPlaceholder)
                return obj1.equalsTo(obj2)
            else if (obj2IsPlaceholder)
                return obj2.equalsTo(obj1)
            else if (obj1IsPlaceholder)
                return obj1.equalsTo(obj2)

            if (onlyPrimitives) return false

            var type1 = this.typeOf(obj1)
            var type2 = this.typeOf(obj2)

            if (type1 != type2) return false

            var me = this

            if (type1 == 'Set') {
                if (obj1.size != obj2.size)
                    return false
                else {
                    // we use iterator here instead of simple "for .. of" loop, because IE does not support it
                    var iterator        = obj1.entries()

                    for (var entry = iterator.next(); !entry.done; entry = iterator.next()) {
                        var key     = entry.value[ 0 ]

                        if (!obj2.has(key)) return false
                    }

                    // we use iterator here instead of simple "for .. of" loop, because IE does not support it
                    var iterator        = obj2.entries()

                    for (var entry = iterator.next(); !entry.done; entry = iterator.next()) {
                        var key     = entry.value[ 0 ]

                        if (!obj1.has(key)) return false
                    }

                    return true
                }
            }

            if (type1 == 'Map') {
                if (obj1.size != obj2.size)
                    return false
                else {
                    // we use iterator here instead of simple "for .. of" loop, because IE does not support it
                    var iterator        = obj1.entries()

                    for (var entry = iterator.next(); !entry.done; entry = iterator.next()) {
                        var key     = entry.value[ 0 ]
                        var value   = entry.value[ 1 ]

                        if (!obj2.has(key) || !me.compareObjects(value, obj2.get(key), strict)) return false
                    }

                    var iterator        = obj2.entries()

                    for (var entry = iterator.next(); !entry.done; entry = iterator.next()) {
                        var key     = entry.value[ 0 ]
                        var value   = entry.value[ 1 ]

                        if (!obj1.has(key) || !me.compareObjects(value, obj1.get(key), strict)) return false
                    }

                    return true
                }
            }

            if (type1 == 'Object' || asObjects)
                if (this.countKeys(obj1) != this.countKeys(obj2))
                    return false
                else {
                    var res = Joose.O.eachOwn(obj1, function (value, name) {

                        if (!me.compareObjects(value, obj2[ name ], strict)) return false
                    })

                    return res === false ? false : true
                }

            if (type1 == 'Array')
                if (obj1.length != obj2.length)
                    return false
                else {
                    for (var i = 0; i < obj1.length; i++)
                        if (!this.compareObjects(obj1[ i ], obj2[ i ], strict)) return false

                    return true
                }

            if (type1 == 'Function')
                return obj1.toString() == obj2.toString() && (!strict || this.compareObjects(obj1, obj2, strict, false, true))

            if (type1 == 'RegExp')
                return obj1.source == obj2.source && obj1.global == obj2.global && obj1.ignoreCase == obj2.ignoreCase
                    && obj1.multiline == obj2.multiline && (!strict || this.compareObjects(obj1, obj2, strict, false, true))

            if (type1 == 'Date') return !Boolean(obj1 - obj2) && (!strict || this.compareObjects(obj1, obj2, strict, false, true))

            return false
        }
    }
})
;
Role('Siesta.Util.Role.CanEscapeRegExp', {
    
    methods : {
        
        escapeRegExp : function (str) {
            return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&")
        }
    }
})
;
!function () {
/* header */
    
var id      = 1

Role('Siesta.Util.Role.HasUniqueGeneratedId', {
    
    has : {
        id                      : {
            is      : 'ro',
            init    : function () { return id++ }
        }
    }
})

/* footer */
}();
Class('Siesta.Util.Queue', {
    
    has     : {
        // array of Objects, each containing arbitrary data about queue step. Possibly keys:
        // `processor` - an individual processor function for this step
        // can also be provided for whole queue
        // will receive the: (stepData, index, queue)
        // `isAsync` - when provided, the `next` function will be also embedded,
        // which should be called manually
        // `interval` - the delay after step (except for asynchronous)
        steps                   : Joose.I.Array,

        interval                : 100,
        callbackDelay           : 0,
        // setTimeout
        deferer                 : { required : true },
        // clearTimeout - only required when "abort" is planned / possible
        deferClearer            : null,
        
        processor               : null,
        processorScope          : null,
        
        currentTimeout          : null,
        callback                : null,
        scope                   : null,
        isAborted               : false,
        
        observeTest             : null,

        currentDelayStepId      : null,
        
        isDestroyed             : false
    },
    
    
    methods : {
        
        // step is an object with
        // { 
        //      processor : func, 
        //      processorScope : obj,
        //      next : func (in case of async step, will be populated by queue)
        // }
        
        addStep : function (stepData) {
            this.addSyncStep(stepData)
        },
        
        
        addSyncStep : function (stepData) {
            this.steps.push(stepData)
        },
        
        
        addAsyncStep : function (stepData) {
            stepData.isAsync = true
            
            this.steps.push(stepData)
        },

        addDelayStep : function (delayMs) {
            var origSetTimeout = this.deferer;
            var me = this;

            this.addAsyncStep({
                processor : function(data) {
                    me.currentDelayStepId = origSetTimeout(data.next, delayMs || 500);
                }
            });
        },
        
        
        run : function (callback, scope) {
            this.callback   = callback
            this.scope      = scope
            
            // abort the queue, if the provided test instance has finalized (probably because of exception)
            this.observeTest && this.observeTest.on('teststop', function () { this.abort(true) }, this, { single : true })
            
            this.doSteps(this.steps.slice(), callback, scope)
        },
        
        
        abort : function (ignoreCallback) {
            if (this.isDestroyed) return
            
            this.isAborted      = true
            
            var deferClearer    = this.deferClearer
            
            if (!deferClearer) throw "Need `deferClearer` to be able to `abort` the queue"

            deferClearer(this.currentDelayStepId);
            deferClearer(this.currentTimeout)
            
            if (!ignoreCallback) this.callback.call(this.scope || this)
            
            this.destroy()
        },
        
        
        doSteps : function (steps, callback, scope) {
            this.currentTimeout = null
            
            var me          = this
            var deferer     = this.deferer
            var step        = steps.shift()
            
            if (this.isAborted) return
            
            if (step) {
                // Normally, the `doSteps` is called recursively for every step in the chain
                // but, steps may complete synchronously, which means, stack will grow
                // since some version, FF has smaller stack size than other browsers
                // and it starts behaving unstable when stack grows
                // because of that, we perform a special check if step has completed synchronously
                // and processing the next step in the same `doStep` context (in the loop), avoiding recursion
                
                // if `doOneStep` has returned `true`, then step has completed synchronously
                // and the flow did not recurse into `doSteps`
                // in this case we continue processing to the next step
                while (this.doOneStep(step, steps, callback, scope) && !this.isAborted) {
                    if (steps.length)
                        step = steps.shift()
                    else {
                        this.doSteps(steps, callback, scope)
                        break;
                    }
                }
            } else {
                if (callback)
                    if (this.callbackDelay)
                        deferer(function () {
                            if (!me.isAborted) { callback.call(scope || this); me.destroy() }
                        }, this.callbackDelay)
                    else {
                        callback.call(scope || this)
                        me.destroy()
                    }
            }
        },
        
        
        doOneStep : function (step, steps, callback, scope) {
            var me              = this
            var deferer         = this.deferer
            
            var processor       = step.processor || this.processor
            var processorScope  = step.processorScope || this.processorScope
            
            var index           = this.steps.length - steps.length - 1
            
            if (!processor) throw new Error("No process function found for step: " + index)
            
            if (step.isAsync) {
                var stepHasCompletedSynchronously   = false
                var processorHasCompleted           = false
                
                var next = step.next = function () {
                    // if at this point `processorHasCompleted` is still `false`, that means that "next" function
                    // has been called before the `processor` function has returned, and thus, step has completed 
                    // synchronously
                    // see the comment in `doSteps` why we treat this case differently
                    if (!processorHasCompleted)
                        stepHasCompletedSynchronously   = true
                    else
                        me.doSteps(steps, callback, scope)
                }
                
                // processor should call `next` to continue
                processor.call(processorScope || me, step, index, this, next)
                
                processorHasCompleted               = true
                
                if (stepHasCompletedSynchronously) return true
            } else {
                processor.call(processorScope || me, step, index, this)
                
                if (this.isAborted) return
                
                var interval = step.hasOwnProperty('interval') ? step.interval : me.interval
                
                if (interval) 
                    this.currentTimeout = deferer(function () {
                        me.doSteps(steps, callback, scope)    
                    }, interval)
                else
                    me.doSteps(steps, callback, scope)
            }
        },
        
        
        // help garbage collector to release the memory 
        destroy : function () {
            if (this.isDestroyed) return
            
            this.callback   = this.observeTest      = this.deferer = this.deferClearer = null
            this.processor  = this.processorScope   = null
            
            // cleanup paranoya, this shouldn't matter in general, since "next" here is from the same context
            for (var i = 0; i < this.steps.length; i++) this.steps[ i ].next = null
            this.steps          = null
            
            this.isDestroyed    = true
        }
    }
})
;
Class('Siesta.Util.XMLNode', {
    
    has     : {
        children        : Joose.I.Array,
        
        tag             : { required : true },
        attributes      : Joose.I.Object,
        
        textContent     : null,
        
        escapeTable     : {
            
            init    : {
                '&'     : '&amp;', 
                '<'     : '&lt;', 
                '>'     : '&gt;', 
                '"'     : '&quot;'
            }
        }
        
    },
    
    
    methods : {
        
        escapeXml : function (s) {
            var me = this
            
            return typeof s != 'string' ? s : s.replace(/[&<>"]/g, function (match) {
                return me.escapeTable[ match ]
            })
        },
        
        
        toString : function () {
            var me                  = this
            var childrenContent     = []
            
            Joose.A.each(this.children, function (child) {
                childrenContent.push(child.toString())
            })
            
            var attributesContent       = []
            
            Joose.O.each(this.attributes, function (value, name) {
                attributesContent.push(name + '="' + me.escapeXml(value) + '"')
            })
            
            // to have predictable order of attributes in tests
            attributesContent.sort()
            
            attributesContent.unshift(this.tag)
            
            
            return '<' + attributesContent.join(' ') + '>' + (this.textContent != null ? this.escapeXml(this.textContent) : '') + childrenContent.join('') + '</' + this.tag + '>' 
        },
        
        
        appendChild : function (child) {
            if (child instanceof Siesta.Util.XMLNode)
                child.parent    = this
            else
                child           = new Siesta.Util.XMLNode(Joose.O.extend(child, { parent : this }))
                
            this.children.push(child)
            
            return child
        },
        
        
        setAttribute : function (name, value) {
            this.attributes[ name ] = value
        }
    }
})
;
Class('Siesta.Util.Rect', {
    
    has     : {
        left            : null,
        top             : null,
        width           : null,
        height          : null,
        
        right           : null,
        bottom          : null
    },
    
    
    methods : {
        
        initialize : function () {
            var left        = this.left
            var width       = this.width
            var right       = this.right
            
            if (right == null && left != null && width != null) this.right = left + width - 1
            
            if (width == null && left != null && right != null) this.width = right - left + 1
            
            var top         = this.top
            var height      = this.height
            var bottom      = this.bottom
            
            if (bottom == null && top != null && height != null) this.bottom = top + height - 1
            
            if (height == null && top != null && bottom != null) this.height = bottom - top + 1
        },
        
        
        isEmpty : function () {
            return this.left == null
        },
        
        
        intersect : function (rect) {
            if (
                rect.isEmpty() || this.isEmpty()
                    ||
                rect.left > this.right || rect.right < this.left
                    ||
                rect.top > this.bottom || rect.bottom < this.top
            ) return this.my.getEmpty()
            
            return new this.constructor({
                left        : Math.max(this.left, rect.left),
                right       : Math.min(this.right, rect.right),
                top         : Math.max(this.top, rect.top),
                bottom      : Math.min(this.bottom, rect.bottom)
            })
        },
        
        
        contains : function (left, top) {
            return this.left <= left && left <= this.right 
                    && 
                this.top <= top && top <= this.bottom
        },
        
        
        cropLeftRight : function (rect) {
            return this.intersect(new this.constructor({
                left        : rect.left,
                right       : rect.right,
                top         : this.top,
                bottom      : this.bottom
            }))
        },
        
        
        cropTopBottom : function (rect) {
            return this.intersect(new this.constructor({
                left        : this.left,
                right       : this.right,
                top         : rect.top,
                bottom      : rect.bottom
            }))
        },
        
        
        equalsTo : function (rect) {
            return this.left == rect.left && this.right == rect.right && this.top == rect.top && this.bottom == rect.bottom
        }
    },
    
    
    // static methods/props
    my : {
        has : {
            HOST        : null
        }, 
        
        methods : {
            
            getEmpty : function () {
                return new this.HOST()
            }
        }
    }
})
;
Class('Siesta.Content.Resource', {
    
    has : {
        url             : null,
        
        content         : null
    },
    
    
    methods : {
        
        asHTML : function () {
            throw "Abstract method called"
        },
        
        
        asDescriptor : function () {
            throw "Abstract method called"
        },
        
        
        // todo should check same-origin 
        canCache : function () {
        }
        
    }
        
})
//eof Siesta.Result

;
Class('Siesta.Content.Resource.CSS', {
    
    isa     : Siesta.Content.Resource,
    
    has     : {
    },
    
    
    methods : {
        
        asHTML : function () {
        },
        
        
        asDescriptor : function () {
            var res = {
                type        : 'css'
            }
            
            if (this.url)       res.url         = this.url
            if (this.content)   res.content     = this.content
            
            return res
        }
    }
        
})
//eof Siesta.Result

;
Class('Siesta.Content.Resource.JavaScript', {

    isa     : Siesta.Content.Resource,

    has     : {
        instrument          : false,

        isEcmaModule        : false
    },


    methods : {

        asHTML : function () {
        },


        asDescriptor : function () {
            var res = {
                type        : 'js'
            }

            if (this.url)          res.url          = this.url
            if (this.content)      res.content      = this.content
            if (this.isEcmaModule) res.isEcmaModule = this.isEcmaModule

            return res
        }
    }

})
//eof Siesta.Result

;
Class('Siesta.Content.Preset', {

    has : {
        preload                 : Joose.I.Array,

        resources               : Joose.I.Array
    },


    methods : {

        initialize : function () {
            var me              = this

            Joose.A.each(this.preload, function (preloadDesc) {

                me.addResource(preloadDesc)
            })
        },


        isCSS : function (url) {
            return /\.css(\?.*)?$/i.test(url)
        },


        getResourceFromDescriptor : function (desc) {
            var constructor, config

            var CSS

            if (typeof desc == 'string') {
                constructor     = this.isCSS(desc) ? Siesta.Content.Resource.CSS : Siesta.Content.Resource.JavaScript

                config          = { url     : desc }
            } else if (desc.text) {
                constructor     = Siesta.Content.Resource.JavaScript
                config          = { content : desc.text }

            } else {
                if (!desc.url && !desc.content) throw "Incorrect preload descriptor:" + desc

                constructor     = desc.type && desc.type == 'css' || this.isCSS(desc.url) ? Siesta.Content.Resource.CSS : Siesta.Content.Resource.JavaScript

                config          = {}

                if (desc.url)           config.url          = desc.url
                if (desc.content)       config.content      = desc.content
                if (desc.instrument)    config.instrument   = desc.instrument
                if (desc.isEcmaModule)  config.isEcmaModule = desc.isEcmaModule
            }

            return new constructor(config)
        },


        addResource : function (desc) {
            var resource    = (desc instanceof Siesta.Content.Resource) && desc || this.getResourceFromDescriptor(desc)

            this.resources.push(resource)

            return resource
        },


        eachResource : function (func, scope) {
            return Joose.A.each(this.resources, func, scope || this)
        },


        // deprecated - seems preset doesn't need to know about scope providers
        prepareScope : function (scopeProvider, contentManager) {

            this.eachResource(function (resource) {

                if (contentManager.hasContentOf(resource))
                    scopeProvider.addPreload({
                        type        : (resource instanceof Siesta.Content.Resource.CSS) ? 'css' : 'js',
                        content     : contentManager.getContentOf(resource)
                    })
                else
                    scopeProvider.addPreload(resource.asDescriptor())
            })
        }
    }

})

;
Class('Siesta.Content.Manager', {

    has : {
        disabled        : false,

        presets         : {
            required    : true
        },

        urls            : Joose.I.Object,

        maxLoads        : 5,

        project         : null
    },


    methods : {

        cache : function (callback, errback, ignoreErrors) {
            if (this.disabled) {
                callback && callback()

                return
            }

            var urls    = this.urls
            var me      = this

            Joose.A.each(this.presets, function (preset) {
                preset.eachResource(function (resource) {
                    if (resource.url) urls[ resource.url ] = null
                })
            })

            var loadCount   = 0
            var errorCount  = 0

            var urlsArray   = []

            Joose.O.each(urls, function (value, url) {
                // if some content has been already provided - skip it from caching
                if (!me.hasContentOf(url)) urlsArray.push(url)
            })

            var total       = urlsArray.length

            if (total) {

                var loadSingle = function () {
                    if (!urlsArray.length) return

                    var url     = urlsArray.shift()

                    me.load(url, function (content) {
                        if (errorCount) return

                        urls[ url ] = content

                        if (++loadCount == total)
                            callback && callback()
                        else
                            loadSingle()

                    }, ignoreErrors ? function () {

                        if (++loadCount == total)
                            callback && callback()
                        else
                            loadSingle()

                    } : function () {
                        errorCount++

                        errback && errback(url)
                    })
                }

                // running only `maxLoads` "loading threads" at the same time
                for (var i = 0; i < this.maxLoads; i++) loadSingle()

            } else
                callback && callback()
        },


        load : function (url, callback, errback) {
            throw "abstract method `load` called"
        },


        addContent : function (url, content) {
            this.urls[ url ]    = content
        },


        hasContentOf : function (url) {
            if (url instanceof Siesta.Content.Resource) url = url.url

            return typeof this.urls[ url ] == 'string'
        },


        getContentOf : function (url) {
            if (url instanceof Siesta.Content.Resource) url = url.url

            return this.urls[ url ]
        }
    }
})

;
;
Class('Siesta', {
    /*PKGVERSION*/VERSION : '5.3.2',

    // "my" should been named "static"
    my : {

        has : {
            config          : null,
            activeHarness   : null,
            license         : '%LICENSE%'
        },

        methods : {

            getConfigForTestScript : function (text) {
                try {
                    eval(text)

                    return this.config
                } catch (e) {
                    return null
                }
            },


            StartTest : function (arg1, arg2) {
                if (typeof arg1 == 'object')
                    this.config = arg1
                else if (typeof arg2 == 'object')
                    this.config = arg2
                else
                    this.config = null
            }
        }
    }
})

// fake StartTest function to extract test configs
if (typeof StartTest == 'undefined') StartTest = Siesta.StartTest
if (typeof startTest == 'undefined') startTest = Siesta.StartTest
if (typeof describe == 'undefined') describe = Siesta.StartTest

// from MDN
// this polyfill is required by Ext, since Ext adds it to own context and after that assumes every function
// used as a callback has "bind" method
if (!Function.prototype.bind) {
    Function.prototype.bind = function(oThis) {
        if (typeof this !== 'function') {
            // closest thing possible to the ECMAScript 5
            // internal IsCallable function
            throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
        }

        var aArgs       = Array.prototype.slice.call(arguments, 1),
            fToBind     = this,
            fNOP        = function () {},
            fBound      = function () {
                return fToBind.apply(
                    this instanceof fNOP ? this : oThis,
                    aArgs.concat(Array.prototype.slice.call(arguments))
                );
            };

        fNOP.prototype      = this.prototype;
        fBound.prototype    = new fNOP();

        return fBound;
    };
};
Siesta.CurrentLocale = Siesta.CurrentLocale || {

    "Siesta.Project" : {
        preloadHasFailed            : 'Preload of {url} has failed',
        preloadHasFailedForTest     : 'Preload of {url} has failed for test {test}',
        staticDeprecationWarning    : 'You are calling static method `{methodName}` of the project class {projectClass}. Such usage is deprecated now, please switch to creation of the project class instance: `var project = new {projectClass}()`',
        resourceFailedToLoad        : 'Loading of a {nodeName} resource failed',
        crossOriginFailed           : 'Failed to access cross-origin page: {url}. \nIn general tests should reside on the same domain as the app itself,\nbut you can try to disable web security:\nhttps://www.bryntum.com/blog/testing-x-domain-websites-with-siesta-in-chrome/'
    },

    "Siesta.Project.Browser.UI.AboutWindow" : {

        upgradeText : 'Upgrade to Siesta Standard',
        closeText   : 'Close',
        titleText   : 'ABOUT SIESTA (v{VERSION})',

        bodyText    : '<img height="35" src="https://www.bryntum.com/bryntum-logo.png"/>' +
             '<p>Siesta is a JavaScript unit and functional test tool made by <a target="_blank" href="https://www.bryntum.com">Bryntum</a>. You can test any web page or JavaScript code, including Ext JS, jQuery or NodeJS. ' +
             'Siesta comes in two versions: <strong>Lite</strong> and <strong>Standard</strong>. With Lite, you can launch your tests in the browser UI. ' +
             'With the Standard version, you can also automate your tests and use the automation scripts together with tools like Puppeteer or Selenium WebDriver. </p>' +
             'Siesta would not be possible without these awesome products & libraries: <br>' +
                     '<ul style="padding:0 0 0 30px">' +
                       '<li><a href="http://sencha.com/extjs">Ext JS</a></li>' +
                       '<li><a href="http://jquery.com">jQuery</a></li>' +
                       '<li><a href="http://http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a></li>' +
                       '<li><a href="http://joose.it/">Joose</a></li>' +
                       '<li><a href="https://github.com/gotwarlost/istanbul">Istanbul</a></li>' +
                    '</ul>'
    },

    "Siesta.Project.Browser.UI.AssertionGrid" : {
        initializingText    : 'Initializing test...'
    },

    "Siesta.Project.Browser.UI.CoverageReport" : {
        closeText               : 'Close',
        showText                : 'Show: ',
        lowText                 : 'Low',
        mediumText              : 'Med',
        highText                : 'High',
        statementsText          : 'Statements',
        branchesText            : 'Branches',
        functionsText           : 'Functions',
        linesText               : 'Lines',
        loadingText             : "Loading coverage data...",
        loadingErrorText        : 'Loading error',
        loadingErrorMessageText : 'Could not load the report data from this url: ',
        globalNamespaceText     : '[Global namespace]'
    },

    "Siesta.Project.Browser.UI.DomContainer" : {
        title                   : 'DOM Panel',
        viewDocsText            : 'View documentation for ',
        docsUrlText             : 'http://docs.sencha.com/{0}/apidocs/#!/api/{1}'
    },

    "Siesta.Project.Browser.UI.ResultPanel" : {
        rerunText               : 'Run test',
        toggleDomVisibleText    : 'Toggle DOM visible',
        viewSourceText          : 'View source',
        showFailedOnlyText      : 'Show failed only',
        componentInspectorText  : 'Toggle Ext Component Inspector',
        eventRecorderText       : 'Event Recorder',
        closeText               : 'Close'
    },

    "Siesta.Project.Browser.UI.TestGrid" : {
        mouseSimulation         : 'Mouse simulation',
        title                   : 'Test list',
        nameText                : 'Name',
        filterTestsText         : 'Filter tests',
        expandCollapseAllText   : 'Expand / Collapse all',
        runCheckedText          : 'Run checked',
        runFailedText           : 'Run failed',
        runAllText              : 'Run all',
        observerModeText        : 'Observer mode',
        observerModeTooltip     : 'Sets the `forceDOMVisible` and `runCore=sequential` globally',
        passText                : 'Pass',
        failText                : 'Fail',
        optionsText             : 'Options...',
        todoPassedText          : 'todo assertion(s) passed',
        todoFailedText          : 'todo assertion(s) failed',
        viewDomText             : 'View DOM',
        transparentExText       : 'Transparent exceptions',
        transparentExTooltip    : 'Disable internal try/catch for any exceptions from tests. Useful for debugging.',
        cachePreloadsText       : 'Cache preloads',
        autoLaunchText          : 'Auto launch',
        autoLaunchTooltip       : 'Launch the test suite immediately after project page load.',
        speedRunText            : 'Fast (still accurate)',
        speedRunTooltip         : 'Reduce mouse cursor visualization quality to run tests faster',
        turboMode           : 'Very fast, but inaccurate',
        turboModeTooltip    : 'Sets the `mouseMovePrecision` option to `Infinity`. Read the docs before using.',
        breakOnFailText         : 'Break on fail',
        breakOnFailTooltip      : 'Stop the test suite on first failed assertion',
        debuggerOnFailText      : 'Debugger on fail',
        debuggerOnFailTooltip   : 'Issue a `debugger` statement on any failed assertion. Useful for debugging',
        aboutText               : 'About Siesta',
        documentationText       : 'Siesta Documentation',
        siestaDocsUrl           : 'https://bryntum.com/docs/siesta',
        filterFieldTooltip      : [
            'Supported patterns for tests filtering:\n',
            'WORD - any word, will match with the test file name (no directory part)\n',
            'WORD | WORD - any of the alternative patterns\n',
            'GROUP > TEST - first match GROUP with the group name, then TEST with tests inside that group\n',
            'GROUP1 | GROUP2 > TEST1 | TEST2 - alternation support for groups too\n'
        ].join(''),
        landscape               : 'Landscape'
    },

    "Siesta.Project.Browser.UI.VersionUpdateButton" : {

        newUpdateText           : 'New Update Available...',
        updateWindowTitleText   : 'New version available for download! Current version: ',
        cancelText              : 'Cancel',
        changelogLoadFailedText : 'Bummer! Failed to fetch changelog.',
        downloadText            : 'Download ',
        liteText                : ' (Lite)',
        standardText            : ' (Standard)',
        loadingChangelogText    : 'Loading changelog...'
    },

    "Siesta.Project.Browser.UI.Viewport" : {
        apiLinkText       : 'API Documentation',
        apiLinkUrl        : 'https://bryntum.com/docs/siesta',
        uncheckOthersText : 'Uncheck others (and check this)',
        uncheckAllText    : 'Uncheck all',
        checkAllText      : 'Check all',
        runThisText       : 'Run this',
        expandAll           : 'Expand all',
        collapseAll         : 'Collapse all',
        filterToCurrentGroup    : 'Filter to current group',
        filterToFailed          : 'Filter to failed',
        httpWarningTitle  : 'You must use a web server',
        httpWarningDesc   : 'You must run Siesta in a web server context, and not using the file:/// protocol',
        viewSource        : 'View source'
    },


    "Siesta.Project.Browser" : {
        codeCoverageWarningText : "Can not enable code coverage - did you forget to include the `siesta-coverage-all.js` on the project page?",
        noJasmine               : "No `jasmine` object found on spec runner page",
        noJasmineSiestaReporter : "Can't find SiestaReporter in Jasmine. \nDid you add the `siesta/bin/jasmine-siesta-reporter.js` file to your spec runner page?"
    },

    "Siesta.Result.Assertion" : {
        todoText        : 'TODO: ',
        passText        : 'ok',
        failText        : 'fail'
    },

    "Siesta.Role.ConsoleReporter" : {
        passText            : 'PASS',
        failText            : 'FAIL',
        warnText            : 'WARN',
        errorText           : 'ERROR',
        missingFileText     : 'Test file [{URL}] not found.',
        allTestsPassedText  : 'All tests passed',
        failuresFoundText   : 'There are failures'
    },

    "Siesta.Test.Action.Drag" : {
        byOrToMissingText   : 'Either "to" or "by" configuration option is required for "drag" step',
        byAndToDefinedText  : 'Exactly one of "to" or "by" configuration options is required for "drag" step, not both'
    },

    "Siesta.Test.Action.Eval" : {
        invalidMethodNameText : "Invalid method name: ",
        wrongFormatText       : "Wrong format of the action string: ",
        parseErrorText        : "Can't parse arguments: "
    },

    "Siesta.Test.Action.Wait" : {
        missingMethodText     : 'Could not find a waitFor method named '
    },

    "Siesta.Test.BDD.Expectation" : {
        expectText                  : 'Expect',
        needNotText                 : 'Need not',
        needText                    : 'Need',
        needMatchingText            : 'Need matching',
        needNotMatchingText         : 'Need not matching',
        needStringNotContainingText : 'Need string not containing',
        needStringContainingText    : 'Need string containing',
        needArrayNotContainingText  : 'Need array not containing',
        needArrayContainingText     : 'Need array containing',
        needGreaterEqualThanText    : 'Need value greater or equal than',
        needGreaterThanText         : 'Need value greater than',
        needLessThanText            : 'Need value less than',
        needLessEqualThanText       : 'Need value less or equal than',
        needValueNotCloseToText     : 'Need value not close to',
        needValueCloseToText        : 'Need value close to',
        toBeText                    : 'to be',
        toBeDefinedText             : 'to be defined',
        toBeUndefinedText           : 'to be undefined',
        toBeEqualToText             : 'to be equal to',
        toBeTruthyText              : 'to be truthy',
        toBeFalsyText               : 'to be falsy',
        toMatchText                 : 'to match',
        toContainText               : 'to contain',
        toBeLessThanText            : 'to be less than',
        toBeGreaterThanText         : 'to be greater than',
        toBeCloseToText             : 'to be close to',
        toThrowText                 : 'to throw exception',
        thresholdIsText             : 'Threshold is ',
        exactMatchText              : 'Exact match text',
        thrownExceptionText         : 'Thrown exception',
        noExceptionThrownText       : 'No exception thrown',
        wrongSpy                    : 'Incorrect spy instance',
        toHaveBeenCalledDescTpl     : 'Expect method {methodName} to have been called {!need} times',
        actualNbrOfCalls            : 'Actual number of calls',
        expectedNbrOfCalls          : 'Expected number of calls',
        toHaveBeenCalledWithDescTpl : 'Expect method {methodName} to have been called at least once with the specified arguments'
    },

    "Siesta.Test.ExtJS.Ajax"        : {
        ajaxIsLoading               : 'An Ajax call is currently loading',
        allAjaxRequestsToComplete   : 'all ajax requests to complete',
        ajaxRequest                 : 'ajax request',
        toComplete                  : 'to complete'
    },

    "Siesta.Test.ExtJS.Component"   : {
        badInputText                : 'Expected an Ext.Component, got',
        toBeVisible                 : 'to be visible',
        toNotBeVisible              : 'to not be visible',
        component                   : 'component',
        Component                   : 'Component',
        componentQuery              : 'componentQuery',
        compositeQuery              : 'composite query',
        toReturnEmptyArray          : 'to return an empty array',
        toReturnEmpty               : 'to return empty',
        toReturnAVisibleComponent   : 'to return a visible component',
        toReturnHiddenCmp           : 'to return a hidden/missing component',
        invalidDestroysOkInput      : 'No components provided, or component query returned empty result',
        exception                   : 'Exception',
        exceptionAnnotation         : 'Exception thrown while calling "destroy" method of',
        destroyFailed               : 'was not destroyed (probably destroy was canceled in the `beforedestroy` listener)',
        destroyPassed               : 'All passed components were destroyed ok'
    },

    "Siesta.Test.ExtJS.DataView"    : {
        view                        : 'view',
        toRender                    : 'to render'
    },

    "Siesta.Test.ExtJS.Element"     : {
        top                         : 'top',
        left                        : 'left',
        bottom                      : 'bottom',
        right                       : 'right'
    },

    "Siesta.Test.ExtJS.Grid"     : {
        waitForRowsVisible          : 'rows to show for panel with id',
        waitForCellEmpty            : 'cell to be empty'
    },

    "Siesta.Test.ExtJS.Observable" : {
        hasListenerInvalid           : '1st argument for `t.hasListener` should be an observable instance',
        hasListenerPass              : 'Observable has listener for {eventName}',
        hasListenerFail              : 'Provided observable has no listeners for event',

        isFiredWithSignatureNotFired : 'event was not fired during the test',
        observableFired              : 'Observable fired',
        correctSignature             : 'with correct signature',
        incorrectSignature           : 'with incorrect signature'
    },

    "Siesta.Test.ExtJS.Store"        : {
        storesToLoad                 : 'stores to load',
        failedToLoadStore            : 'Failed to load the store',
        URL                          : 'URL'
    },

    "Siesta.Test.Action"             : {
        missingTestAction            : 'Action [{0}] requires `{1}` method in your test class'
    },

    "Siesta.Test.BDD"                : {
        codeBodyMissing              : 'Code body is not provided for',
        codeBodyOf                   : 'Code body of',
        missingFirstArg              : 'does not declare a test instance as 1st argument',
        iitFound                     : 't.iit should only be used during debugging',
        noObject                     : 'No object to spy on'
    },

    "Siesta.Test.BDD.Spy"                : {
        spyingNotOnFunction          : 'Trying to create a spy over a non-function property'
    },

    "Siesta.Test.Browser"            : {
        popupsDisabled                  : 'Failed to open the popup for url: {url}. Enable the popups in the browser settings.',
        noDomElementFound            : 'No DOM element found for CSS selector',
        noActionTargetFound          : 'No action target found for',
        waitForEvent                 : 'observable to fire its',
        event                        : 'event',
        wrongFormat                  : 'Wrong format for expected number of events',
        unrecognizedSignature        : 'Unrecognized signature for `firesOk`',
        observableFired              : 'Observable fired',
        observableFiredOk            : 'Observable fired expected number of',
        actualNbrEvents              : 'Actual number of events',
        expectedNbrEvents            : 'Expected number of events',
        events                       : 'events',
        noElementFound               : 'Could not find any element at',
        targetElementOfAction        : 'Target element of action',
        targetElementOfSomeAction    : 'Target element of some action',
        isNotVisible                 : 'is not visible or not reachable',
        text                         : 'text',
        toBePresent                  : 'to be present',
        toNotBePresent               : 'to not be present',
        target                       : 'target',
        toAppear                     : 'to appear',
        targetMoved                  : 'Moving target detected, retargeting initiated',
        alertMethodNotCalled         : 'Expected a call to alert()',
        focusLostWarning             : 'Focus has left the test window {url}',
        focusLostWarningLauncher     : 'Focus has left the test window {url}, it will be restarted. This behavior is controled with the --restart-on-blur option.'
    },

    "Siesta.Test.Date"               :  {
        isEqualTo                    : 'is equal to',
        Got                          : 'Got'
    },

    "Siesta.Test.Element"            : {
        elementContent               : 'element content',
        toAppear                     : 'to appear',
        toDisappear                  : 'to disappear',
        toAppearAt                   : 'to appear at',
        monkeyException              : 'Monkey testing action did not complete properly - probably an exception was thrown',
        monkeyNoExceptions           : 'No exceptions thrown during monkey test',
        monkeyActionLog              : 'Monkey action log',
        elementHasClass              : 'Element has the CSS class',
        elementHasNoClass            : 'Element has no CSS class',
        elementClasses               : 'Classes of element',
        needClass                    : 'Need CSS class',

        hasStyleDescTpl              : 'Element has correct {value} for CSS style {property}',
        elementStyles                : 'Styles of element',
        needStyle                    : 'Need style',

        hasNotStyleDescTpl           : 'Element does not have: {value} for CSS style {property}',
        hasTheStyle                  : 'Element has the style',

        element                      : 'element',
        toBeTopEl                    : 'to be the top element at its position',
        toNotBeTopEl                 : 'to not be the top element at its position',

        selector                     : 'selector',
        selectors                    : 'selectors',
        noCssSelector                : 'A CSS selector must be supplied',

        waitForSelectorsBadInput     : 'An array of CSS selectors must be supplied',

        Position                     : 'Position',
        noElementAtPosition          : 'No element found at the specified position',
        elementIsAtDescTpl           : 'DOM element or its child is at [ {x}, {y} ] coordinates',
        topElement                   : 'Top element',
        elementIsAtPassTpl           : 'DOM element is at [ {x}, {y} ] coordinates',
        allowChildrenDesc            : 'Need exactly this or its child',
        allowChildrenAnnotation      : 'Passed element is not the top-most one and not the child of one',
        shouldBe                     : 'Should be',
        noChildrenFailAnnotation     : 'Passed element is not the top-most one',

        topLeft                      : '(t-l)',
        bottomLeft                   : '(b-l)',
        topRight                     : '(t-r)',
        bottomRight                  : '(b-r)',

        elementIsNotTopElementPassTpl: 'Element is not the top element on the screen',
        selectorIsAtPassTpl          : 'Found element matching CSS selector {selector} at [ {xy} ]',
        elementMatching              : 'Element matching',
        selectorIsAtFailAnnotation   : 'Passed selector does not match any selector at',
        selectorExistsFailTpl        : 'No element matching the passed selector found',
        selectorExistsPassTpl        : 'Found DOM element(s) matching CSS selector {selector}',

        selectorNotExistsFailTpl     : 'Elements found matching the passed selector',
        selectorNotExistsPassTpl     : 'Did not find any DOM element(s) matching CSS selector {selector}',

        toChangeForElement           : 'to change for element',

        selectorCountIsPassTpl       : 'Found exactly {count} elements matching {selector}',
        selectorCountIsFailTpl       : 'Found {got} elements matching the selector {selector}, expected {need}',
        isInViewPassTpl              : 'Passed element is within the visible viewport',

        toAppearInTheViewport        : 'to appear in the viewport',

        elementIsEmptyPassTpl        : 'Passed element is empty',
        elementIsNotEmptyPassTpl     : 'Passed element is not empty',
        elementToBeEmpty             : 'element to be empty',
        elementToNotBeEmpty          : 'element to not be empty'
    },

    "Siesta.Test.ExtJS"              : {
        bundleUrlNotFound                   : 'Cannot find Ext JS bundle url',
        assertNoGlobalExtOverridesInvalid   : 'Was not able to find the Ext JS bundle URL in the `assertNoGlobalExtOverrides` assertion',
        assertNoGlobalExtOverridesPassTpl   : 'No global Ext overrides found',
        assertNoGlobalExtOverridesGotDesc   : 'Number of overrides found',
        foundOverridesFor                   : 'Found overrides for',
        animationsToFinalize                : 'animations to finalize',
        extOverridesInvalid                 : 'Was not able to find the ExtJS bundle URL in the `assertMaxNumberOfGlobalExtOverrides` assertion)',
        foundLessOrEqualThan                : 'Found less or equal than',
        nbrOverridesFound                   : 'Number of overrides found',
        globalOverrides                     : 'Ext JS global overrides'
    },

    "Siesta.Test.ExtJSCore"          : {
        waitedForRequires           : 'Waiting for required classes took too long - \nCheck the `Net` tab in Firebug and the `loaderPath` config',
        waitedForExt                 : 'Waiting for Ext.onReady took too long - probably some dependency could not be loaded. \nCheck the `Net` tab in Firebug and the `loaderPath` config',
        waitedForApp                 : 'Waiting for MVC application launch took too long - no MVC application on test page? \nYou may need to disable the `waitForAppReady` config option',
        noComponentMatch             : 'Your component query: "{component}" returned no components',
        multipleComponentMatch       : 'Your component query: "{component}" returned more than 1 component',
        noComponentFound             : 'No component found for CQ',
        knownBugIn                   : 'Known bug in',
        Class                        : 'Class',
        wasLoaded                    : 'was loaded',
        wasNotLoaded                 : 'was not loaded',
        invalidCompositeQuery        : 'Invalid composite query selector',
        ComponentQuery               : 'ComponentQuery',
        CompositeQuery               : 'CompositeQuery',
        matchedNoCmp                 : 'matched no Ext.Component',
        messageBoxVisible            : 'Message box is visible',
        messageBoxHidden             : 'Message box is hidden',
        waitedForComponentQuery      : 'Waiting too long for Ext.ComponentQuery'
    },

    "Siesta.Test.Function"           : {
        Need                         : 'need',
        atLeast                      : 'at least',
        exactly                      : 'exactly',
        methodCalledExactly          : 'method was called exactly {n} times',
        exceptionEvalutingClass      : 'Exception [{e}] caught while evaluating the class name'
    },

    "Siesta.Test.More"               : {
        isGreaterPassTpl             : '`{value1}` is greater than `{value2}`',
        isLessPassTpl                : '`{value1}` is less than `{value2}`',
        isGreaterEqualPassTpl        : '`{value1}` is greater or equal to`{value2}`',
        isLessEqualPassTpl           : '`{value1}` is less or equal to`{value2}`',
        isApproxToPassTpl            : '`{value1}` is approximately equal to `{value2}`',

        needGreaterThan              : 'Need greater than',
        needGreaterEqualTo           : 'Need greater or equal to',
        needLessThan                 : 'Need less than',
        needLessEqualTo              : 'Need less or equal to',

        exactMatch                   : 'Exact match',
        withinThreshold              : 'Match within treshhold',
        needApprox                   : 'Need approx',
        thresholdIs                  : 'Threshold is',

        stringMatchesRe              : '`{string}` matches regexp {regex}',
        stringNotMatchesRe           : '`{string}` does not match regexp {regex}',
        needStringMatching           : 'Need string matching',
        needStringNotMatching        : 'Need string not matching',
        needStringContaining         : 'Need string containing',
        needStringNotContaining      : 'Need string not containing',
        stringHasSubstring           : '`{string}` has a substring: `{regex}`',
        stringHasNoSubstring         : '`{string}` does not have a substring: `{regex}`',

        throwsOkInvalid              : 'throws_ok accepts a function as 1st argument',
        didntThrow                   : 'Function did not throw an exception',
        exMatchesRe                  : 'Function throws exception matching to {expected}',
        exceptionStringifiesTo       : 'Exception stringifies to',
        exContainsSubstring          : 'Function throws exception containing a substring: {expected}',

        fnDoesntThrow                : 'Function does not throw any exceptions',
        fnThrew                      : 'Function threw an exception',

        isInstanceOfPass             : 'Object is an instance of the specified class',
        needInstanceOf               : 'Need instance of',
        isAString                    : '{value} is a string',
        aStringValue                 : 'AStringValue',
        isAnObject                   : '{value} is an object',
        anObject                     : 'An object value',
        isAnArray                    : '{value} is an array',
        anArrayValue                 : 'An array value',
        isANumber                    : '{value} is a number',
        aNumberValue                 : 'a number value',
        isABoolean                   : '{value} is a boolean',
        aBooleanValue                : 'a number value',
        isADate                      : '{value} is a date',
        aDateValue                   : 'a date value',
        isARe                        : '{value} is a regular expression',
        aReValue                     : 'a regular expression',
        isAFunction                  : '{value} is a function',
        aFunctionValue               : 'a function',
        isDeeplyPassTpl              : '{obj1} is deeply equal to {obj2}',
        isDeeplyStrictPassTpl        : '{obj1} is strictly deeply equal to {obj2}',
        globalCheckNotSupported      : 'Testing leakage of global variables is not supported on this platform',
        globalVariables              : 'Global Variables',
        noGlobalsFound               : 'No unexpected global variables found',
        globalFound                  : 'Unexpected global found',
        globalName                   : 'Global name',
        value                        : 'value',

        conditionToBeFulfilled       : 'condition to be fulfilled',
        pageToLoad                   : 'page to load',
        ms                           : 'ms',
        waitingFor                   : 'Waiting for',
        waitedTooLong                : 'Waited too long for',
        conditionNotFulfilled        : 'Condition was not fullfilled during',
        waitingAborted               : 'Waiting aborted',
        Waited                       : 'Waited',
        checkerException             : 'checker threw an exception',
        Exception                    : 'Exception',
        msFor                        : 'ms for',
        forcedWaitFinalization       : 'Forced finalization of waiting for',
        chainStepNotCompleted        : 'The step in `t.chain()` call did not complete within required timeframe, chain can not proceed',
        stepNumber                   : 'Step number',
        oneBased                     : '(1-based)',
        atLine                       : 'At line',
        chainStepEx                  : 'Chain step threw an exception',
        stepFn                       : 'Step function',
        notUsingNext                 : 'does not use the provided "next" function anywhere',
        calledMoreThanOnce           : 'The `next` callback of {num} step (1-based) of `t.chain()` call at line {line} is called more than once.',
        tooManyDifferences           : 'Showing {num} of {total} differences'
    },


    "Siesta.Test.SenchaTouch"               : {
        STSetupFailed                       : 'Waiting for Ext.setup took too long - some dependency could not be loaded? Check the `Net` tab in Firebug',
        invalidSwipeDir                     : 'Invalid swipe direction',
        moveFingerByInvalidInput            : 'Trying to call moveFingerBy without relative distances',
        scrollUntilFailed                   : 'scrollUntil failed to achieve its mission',
        scrollUntilElementVisibleInvalid    : 'scrollUntilElementVisible: target or scrollable not provided',
        scrollerReachPos                    : 'scroller to reach position'
    },

    "Siesta.Test"                           : {
        noCodeProvidedToTest                : 'No code provided to test',
        addingAssertionsAfterDone           : 'Adding assertions after the test has finished',
        testFailedAndAborted                : 'Assertion failed, test execution aborted',
        atLine                              : 'at line',
        of                                  : 'of',
        character                           : 'character',
        isTruthy                            : '`{value}` is a "truthy" value',
        needTruthy                          : 'Need "truthy" value',
        isFalsy                             : '`{value}` is a "falsy" value',
        needFalsy                           : 'Need "falsy" value',
        isEqualTo                           : '`{got}` is equal to `{expected}`',
        isNotEqualTo                        : '`{got}` is not equal to `{expected}`',
        needNot                             : 'Need not',
        isStrictlyEqual                     : '`{got}` is strictly equal to `{expected}`',
        needStrictly                        : 'Need strictly',
        isStrictlyNotEqual                  : '`{got}` is strictly not equal to `{expected}`',
        needStrictlyNot                     : 'Need strictly not',
        alreadyWaiting                      : 'Already waiting with title',
        noOngoingWait                       : 'There is no ongoing `wait` action with title',
        noMatchingEndAsync                  : 'No matching `endAsync` call within {time}ms',
        endAsyncMisuse                      : 'Calls to endAsync without argument should only be performed if you have single beginAsync statement',
        codeBodyMissingForSubTest           : 'Code body is not provided for sub test [{name}]',
        codeBodyMissingTestArg              : 'Code body of sub test [{name}] does not declare a test instance as 1st argument',
        Subtest                             : 'Subtest',
        Test                                : 'Test',
        failedToFinishWithin                : 'Subtest {name} failed to finish within {timeout}ms',
        threwException                      : 'threw an exception',
        testAlreadyStarted                  : 'Test has already been started',
        setupTookTooLong                    : '`setup` method took too long to complete',
        errorBeforeTestStarted              : 'Error happened before the test started',
        testStillRunning                    : 'Your test is still considered to be running, if this is unexpected please see console for more information',
        testNotFinalized                    : 'Your test [{url}] has not finalized, most likely since a timer (setTimeout) is still active. ' +
                                              'If this is the expected behavior, try setting "overrideSetTimeout : false" on your Harness configuration.',
        missingDoneCall                     : 'Test has completed, but there was no `t.done()` call. Add it at the bottom, or use `t.beginAsync()` for asynchronous code',
        allTestsPassed                      : 'All tests passed',

        'Snoozed until'                     : 'Snoozed until',
        testTearDownTimeout                 : "Test's tear down process has timeout out"
    },

    "Siesta.Recorder.UI.Editor.Code"           : {
        invalidSyntax                       : 'Invalid syntax'
    },

    "Siesta.Recorder.UI.Editor.DragTarget"     : {
        targetLabel                         : 'Target',
        toLabel                             : 'To',
        byLabel                             : 'By',
        cancelButtonText                    : 'Cancel',
        saveButtonText                      : 'Save',

        dragVariantTitle                    : 'Edit `drag` action',
        moveCursorVariantTitle              : 'Edit `moveCursor` action'
    },

    "Siesta.Recorder.UI.RecorderPanel"      : {
        actionColumnHeader                  : 'Action',
        offsetColumnHeader                  : 'Offset',
        queryMatchesNothing                 : 'Query matches no DOM elements or components',
        queryMatchesMultiple                : 'Query matches multiple components',
        noVisibleElsFound                   : 'No visible elements found for target',
        noTestDetected                      : 'No test detected',
        noTestStarted                       : 'You need to run a test first, or provide a Page URL',
        recordTooltip                       : 'Record',
        stopTooltip                         : 'Stop',
        playTooltip                         : 'Play',
        clearTooltip                        : 'Clear all',
        codeWindowTitle                     : 'Code',
        addNewTooltip                       : 'Add a new step',
        removeAllPromptTitle                : 'Remove all?',
        removeAllPromptMessage              : 'Do you want to clear the recorded events?',
        Error                               : 'Error',
        showSource                          : 'Show source',
        showSourceInNewWindow               : 'Show source in new window',
        newRecording                        : 'New recording...',
        pageUrl                             : 'Page URL'
    },

    "Siesta.Recorder.UI.TargetColumn"       : {
        headerText                          : 'Target / Value',
        by                                  : 'by',
        to                                  : 'to',
        coordinateTargetWarning             : 'Siesta was unable to find a stable selector for this target. Using coordinates as locator is not recommended.'
    }
};

;
// Localization helper
Siesta.Resource = (function () {
    
    var cacheByNamespace    = {}
    
    var Resource    = Class({
        does    : Siesta.Util.Role.CanFormatStrings,
        
        has     : {
            dict        : null
        },
        
        methods : {
            'get' : function (key, data) {
                var text = this.dict[ key ];
        
                if (text) return this.formatString(text, data);
        
                if (window.console && console.error) {
                    window.top.console.error('TEXT_NOT_DEFINED: ' + key);
                }
        
                return 'TEXT_NOT_DEFINED: ' + key;
            }
        }
    
    })
    

    return function (namespace, key, data) {
        var dictionary  = Siesta.CurrentLocale[ namespace ];

        if (!dictionary) {
            throw 'Missing dictionary for namespace: ' + namespace;
        }
        
        var resource    = cacheByNamespace[ namespace ]
        
        if (!resource) {
            resource    = cacheByNamespace[ namespace ] = new Resource({ dict : dictionary, serializeFormatingPlaceholders : false })
        }

        if (key) return resource.get(key, data)

        return resource
    }
})();
;
;(function () {
    
var ID = 0

Class('Siesta.Result', {
    
    has : {
        description     : null,
        
        children        : Joose.I.Array,
        
        length          : 0,
        
        id              : function () {
            return ++ID
        },
        
        parent          : null
    },
    
    
    methods : {
        
        itemAt : function (i) {
            return this.children[ i ]
        },
        
        
        push        : function (result) {
            this.children.push(result)
            
            result.parent   = this
            
            this.length     = this.children.length
        },
        
        
        each : function (func, scope) {
            var children        = this.children
            
            if (func.call(scope || this, this) === false) return false
            
            for (var i = 0; i < children.length; i++)
                if (children[ i ].each(func, scope) === false) return false
        },
        
        
        eachChild : function (func, scope) {
            var children        = this.children
            
            for (var i = 0; i < children.length; i++)
                if (func.call(scope, children[ i ]) === false) return false
        },
        
        
        toString : function () {
            return this.description
        },
        
        
        toJSON : function () {
            return {
                type        : this.meta.name,
                description : this.description
            }
        },
        
        
        findChildById : function (id) {
            var child
            
            this.each(function (node) {
                if (node.id == id) { child = node; return false } 
            })
            
            return child
        }
    },
    
    // used for self-testing when we need different ids for outer context and context being tested
    my : {
        methods     : {
            seedID : function (value) {
                ID          = value
            }
        }
    }
        
})


})();
Class('Siesta.Result.Diagnostic', {
    
    isa : Siesta.Result,
    
    has : {
        isWarning           : false
    },

    methods : {
        
        toString : function () {
            return '# ' + this.description
        },
        
        
        toJSON : function () {
            var info        = {
                parentId        : this.parent.id,
                
                type            : this.meta.name,
                description     : this.description
            }
            
            if (this.isWarning) info.isWarning = true
            
            return info
        }
    }    
});

;
Class('Siesta.Result.Summary', {
    
    isa         : Siesta.Result,
    
    has         : {
        isFailed            : false
    },
    
    methods : {
        
        // summary should belong only to the top level Siesta.Result.SubTest instance
        getTest : function () {
            return this.parent.test
        },
        
        
        toString : function () {
            
        }
    }    
});

;
Class('Siesta.Result.Assertion', {
    
    isa : Siesta.Result,

    has : {
        name            : null,
        
        passed          : null,
        
        annotation      : null,
        
        index           : null,
        // stored as string
        sourceLine      : null,
        
        isTodo          : false,
        
        isException     : false,
        exceptionType   : null,

        isWaitFor       : false,
        completed       : false      // for waitFor assertions
    },
    
    
    methods : {

        isPassed : function (raw) {
            if (raw) return this.passed
            
            if (this.isTodo) return true
            
            if (this.isWaitFor && !this.completed) return true
            
            return this.passed
        },
        
        
        toString : function () {
            var R       = Siesta.Resource('Siesta.Result.Assertion');
            
            var text    = (this.isTodo ? R.get('todoText') : '') + 
                (this.passed ? R.get('passText') : R.get('failText')) + ' ' + this.index + ' - ' + this.description
            
            if (this.annotation) text += '\n' + this.annotation
            
            return text
        },
        
        
        toJSON : function () {
            var me      = this
            
            var info    = {
                parentId        : this.parent.id,
                
                type            : this.meta.name,
                passed          : this.passed,
                index           : this.index,
                description     : String(this.description) || 'No description'
            }
            
            if (this.annotation) info.annotation = String(this.annotation)
            
            // copy if true
            Joose.A.each([ 'isTodo', 'isWaitFor', 'isException', 'sourceLine', 'name' ], function (name) {
                if (me[ name ]) info[ name ] = me[ name ]
            })
            
            if (this.isException)   {
                info.exceptionType  = this.exceptionType
            }
            
            return info
        }
    }
})

;
Class('Siesta.Result.SubTest', {
    
    isa : Siesta.Result,
    

    has : {
        // reference to a test it belongs to
        // SubTests result instances will be set as `results` for sub tests instances
        test            : null
    },
    
    
    methods : {
        
        isWorking : function () {
            return !this.test.isFinished()
        },
        
        
        toJSON : function () {
            var test            = this.test
            
            // a flag that test instance does not belongs to the current context
            // this only happens during self-testing
            // if this is the case, in IE, calling any method from the test context will throw exception
            // "can't execute script from freed context", so we avoid calling any methods on the test in such case
            // accessing properties is ok though
            var isCrossContext  = !(test instanceof Object)
            
            var report      = {
                id              : this.id,
                parentId        : test.parent ? test.parent.getResults().id : null,
                
                type            : this.meta.name,
                name            : test.name,
                
                startDate       : test.startDate,
                endDate         : test.endDate || (new Date() - 0),
                
                passed          : isCrossContext ? null : test.isPassed()
            }
            
            // top level test
            if (!test.parent)   {
                report.automationElementId  = test.automationElementId
                report.url                  = test.url
                report.jUnitClass           = test.getJUnitClass()
                report.groups               = test.groups
            }
            
            if (test.specType) report.bddSpecType  = test.specType
            if (test.isTodo) report.isTodo = true
            
            var isFailed    = false
            var assertions  = []
            
            Joose.A.each(this.children, function (result) {
                if ((result instanceof Siesta.Result.Assertion) || (result instanceof Siesta.Result.Diagnostic) || (result instanceof Siesta.Result.SubTest)) {
                    var assertion   = result.toJSON()
                    
                    if (!assertion.passed && !assertion.isTodo) isFailed = true
                    
                    assertions.push(assertion)
                }
            })
            
            report.assertions       = assertions
            
            // see a comment above
            if (isCrossContext) {
                report.passed       = !(isFailed || test.failed || !test.endDate)
            }
            
            return report
        }
        
    }
})

;
/**
@class Siesta.Test.Function

This is a mixin, with helper methods for testing functionality relating to Functions (such as spies). This mixin is consumed by {@link Siesta.Test}

*/
Role('Siesta.Test.Function', {

    methods : {
         /**
         * This assertion passes if the function is called at least one time during the test life span.
         *
         * @param {Function/String} fn The function itself or the name of the function on the host object (2nd argument)
         * @param {Object} host The "owner" of the method
         * @param {String} [desc] The description of the assertion.
         */
        isCalled : function(fn, obj, desc) {
            this.isCalledNTimes(fn, obj, 1, desc, true);
        },

        /**
         * This assertion passes if the function is called exactly one time during the test life span.
         *
         * @param {Function/String} fn The function itself or the name of the function on the host object (2nd argument)
         * @param {Object} host The "owner" of the method
         * @param {String} [desc] The description of the assertion.
         */
        isCalledOnce : function(fn, obj, desc) {
            this.isCalledNTimes(fn, obj, 1, desc, false);
        },

        /**
         * This assertion passes if the function is called exactly (n) times during the test life span.
         *
         * @param {Function/String} fn The function itself or the name of the function on the host object (2nd argument)
         * @param {Object} host The "owner" of the method
         * @param {Number} n The expected number of calls
         * @param {String} [desc] The description of the assertion.
         */
        isCalledNTimes : function(fn, obj, n, desc, isGreaterEqual) {
            var me          = this,
                prop        = typeof fn === "string" ? fn : me.getPropertyName(obj, fn);

            var counter     = 0;
            var original    = obj[ prop ]

            obj[ prop ]     = function () { counter++; return original.apply(this, arguments) }

            desc            = desc ? (desc + ' ') : '';

            this.on('beforetestfinalizeearly', function () {
                var R       = Siesta.Resource('Siesta.Test.Function');

                if (counter === n || (isGreaterEqual && counter > n)) {
                    me.pass(desc || (prop + ' ' + R.get('methodCalledExactly').replace('{n}', n)));
                } else {

                    me.fail(desc || prop, {
                        assertionName       : 'isCalledNTimes ' + prop,
                        got                 : counter,
                        need                : n,
                        needDesc            : R.get("Need") + " " + (isGreaterEqual ? R.get('atLeast') : R.get('exactly')) + " "
                    });
                }

                obj[ prop ]     = original
            });
        },

        /**
         * This assertion passes if the function is not called during the test life span.
         *
         * @param {Function/String} fn The function itself or the name of the function on the host object (2nd argument)
         * @param {Object} host The "owner" of the method
         * @param {String} [desc] The description of the assertion.
         */
        isntCalled : function(fn, obj, desc) {
            this.isCalledNTimes(fn, obj, 0, desc);
        },

        getPropertyName : function(host, obj) {
            for (var o in host) {
                if (host[o] === obj) return o;
            }
        },

        /**
         * This assertion passes when the supplied class method is called exactly (n) times during the test life span.
         * Under "class method" here we mean the function in the prototype. Note, that this assertion counts calls to the method in *any* class instance.
         *
         * The `className` parameter can be supplied as a class constructor function or as a string, representing the class
         * name. In the latter case the `class` will be eval'ed to get a reference to the class constructor.
         *
         * For example:

    StartTest(function (t) {

        function machine(type, version) {
            this.machineInfo = {
                type        : type,
                version     : version
            };
        };

        machine.prototype.update = function (type, version) {
            this.setVersion(type);
            this.setType(version);
        };

        machine.prototype.setVersion = function (data) {
            this.machineInfo.version = data;
        };

        machine.prototype.setType = function (data) {
            this.machineInfo.type = data;
        };

        t.methodIsCalled("setVersion", machine, "Checking if method 'setVersion' has been called");
        t.methodIsCalled("setType", machine, "Checking if method 'setType' has been called");

        var m = new machine('rover', '0.1.2');

        m.update('3.2.1', 'New Rover');
    });

         *
         * This assertion is useful when testing for example an Ext JS class where event listeners are added during
         * class instantiation time, which means you need to observe the prototype method before instantiation.
         *
         * @param {Function/String} fn The function itself or the name of the method on the class (2nd argument)
         * @param {Function/String} className The constructor function or the name of the class that contains the method
         * @param {Number} n The expected number of calls
         * @param {String} [desc] The description of the assertion
         */
        methodIsCalledNTimes: function(fn, className, n, desc, isGreaterEqual){
            var me          = this,
                counter     = 0;
            var R           = Siesta.Resource('Siesta.Test.Function');

            desc            = desc ? (desc + ' ') : '';

            try {
                if (me.typeOf(className) == 'String') className = me.global.eval(className)
            } catch (e) {
                me.fail(desc, {
                    assertionName       : 'isMethodCalled',
                    annotation          : R.get('exceptionEvalutingClass').replace('{e}', e) + "[" + className + "]"
                })

                return
            }

            var prototype   = className.prototype;
            var prop        = typeof fn === "string" ? fn : me.getPropertyName(prototype, fn);

            me.on('beforetestfinalizeearly', function () {
                if (counter === n || (isGreaterEqual && counter > n)) {
                    me.pass(desc || (prop + ' ' + R.get('methodCalledExactly').replace('{n}', n)));
                } else {
                    me.fail(desc || prop, {
                        assertionName       : 'methodIsCalledNTimes ' + prop,
                        got                 : counter,
                        need                : n ,
                        needDesc            : R.get("Need") + " " + (isGreaterEqual ? R.get('atLeast') : R.get('exactly')) + " "
                    });
                }
            });

            fn                  = prototype[ prop ];
            prototype[ prop ]   = function () { counter++; return fn.apply(this, arguments); };
        },

        /**
         * This assertion passes if the class method is called at least one time during the test life span.
         *
         * See {@link #methodIsCalledNTimes} for more details.
         *
         * @param {Function/String} fn The function itself or the name of the method on the class (2nd argument)
         * @param {Function/String} className The class constructor function or name of the class that contains the method
         * @param {String} [desc] The description of the assertion.
         */
        methodIsCalled : function(fn, className, desc) {
            this.methodIsCalledNTimes(fn, className, 1, desc, true);
        },

        /**
         * This assertion passes if the class method is not called during the test life span.
         *
         * See {@link #methodIsCalledNTimes} for more details.
         *
         * @param {Function/String} fn The function itself or the name of the method on the class (2nd argument)
         * @param {Function/String} className The class constructor function or name of the class that contains the method
         * @param {String} [desc] The description of the assertion.
         */
        methodIsntCalled : function(fn, className, desc) {
            this.methodIsCalledNTimes(fn, className, 0, desc);
        }
    }
});
;
/**
@class Siesta.Test.Date

A mixin with the additinal assertions for dates. Being consumed by {@link Siesta.Test}

*/
Role('Siesta.Test.Date', {
    
    methods : {
        
        isDateEq: function (got, expectedDate, description) {
            this.isDateEqual.apply(this, arguments);
        },

        
        /**
         * This assertion passes when the 2 provided dates are equal and fails otherwise.
         * 
         * It has a synonym: `isDateEq`
         * 
         * @param {Date} got The 1st date to compare
         * @param {Date} expectedDate The 2nd date to compare
         * @param {String} [description] The description of the assertion
         */
        isDateEqual: function (got, expectedDate, description) {
            var R = Siesta.Resource('Siesta.Test.Date');

            if (got - expectedDate === 0) {
                this.pass(description, {
                    descTpl         : '{got} ' + R.get('isEqualTo') + ' {expectedDate}',
                    got             : got,
                    expectedDate    : expectedDate
                });
            } else {
                this.fail(description, {
                    assertionName   : 'isDateEqual',
                    
                    got             : got ? got.toString() : '',
                    gotDesc         : R.get('Got'),
                    
                    need            : expectedDate.toString()
                });
            }
        }
    }
});
;
/**
@class Siesta.Test.More

A mixin with additional generic assertion methods, which can work cross-platform between browsers and NodeJS.
Is being consumed by {@link Siesta.Test}, so all of them are available in all tests.

*/
Role('Siesta.Test.More', {

    requires        : [ 'isFailed', 'typeOf', 'on' ],


    has : {
        autoCheckGlobals        : false,
        expectedGlobals         : Joose.I.Array,

        disableGlobalsCheck     : false,

        browserGlobals : {
            init : [
                'console',
                'getInterface',
                'ExtBox1',
                '__IE_DEVTOOLBAR_CONSOLE_COMMAND_LINE',
                /__BROWSERTOOLS/, // IE11 with console open
                'seleniumAlert',
                'onload',
                'onerror',
                'StartTest',
                'startTest',
                '__loaderInstrumentationHookInstalled__',
                'describe',
                // will be reported in IE8 after overriding
                'setTimeout',
                'clearTimeout',
                'requestAnimationFrame',
                'cancelAnimationFrame',
                '__coverage__',
                /cov_\w+/
            ]
        },

        /**
         * @cfg {Number} waitForTimeout Default timeout for `waitFor` (in milliseconds). Default value is 10000.
         */
        waitForTimeout                  : 10000,

        waitForPollInterval             : 100,

        suppressPassedWaitForAssertion  : false
    },


    methods : {

        /**
         * This assertion passes, when the comparison of 1st with 2nd, using `>` operator will return `true` and fails otherwise.
         *
         * @param {Number/Date} value1 The 1st value to compare
         * @param {Number/Date} value2 The 2nd value to compare
         * @param {String} [desc] The description of the assertion
         */
        isGreater : function (value1, value2, desc) {
            var R       = Siesta.Resource('Siesta.Test.More');

            if (value1 > value2)
                this.pass(desc, {
                    descTpl             : R.get('isGreaterPassTpl'),
                    value1              : value1,
                    value2              : value2
                })
            else
                this.fail(desc, {
                    assertionName       : 'isGreater',

                    got                 : value1,
                    need                : value2,

                    needDesc            : R.get('needGreaterThan')
                })
        },


        /**
         * This assertion passes, when the comparison of 1st with 2nd, using `<` operator will return `true` and fails otherwise.
         *
         * @param {Number/Date} value1 The 1st value to compare
         * @param {Number/Date} value2 The 2nd value to compare
         * @param {String} [desc] The description of the assertion
         */
        isLess : function (value1, value2, desc) {
            var R       = Siesta.Resource('Siesta.Test.More');

            if (value1 < value2)
                this.pass(desc, {
                    descTpl             : R.get('isLessPassTpl'),
                    value1              : value1,
                    value2              : value2
                })
            else
                this.fail(desc, {
                    assertionName       : 'isLess',

                    got                 : value1,
                    need                : value2,

                    needDesc            : R.get('needLessThan')
                })
        },


        isGE : function () {
            this.isGreaterOrEqual.apply(this, arguments)
        },

        /**
         * This assertion passes, when the comparison of 1st with 2nd, using `>=` operator will return `true` and fails otherwise.
         *
         * It has a synonym - `isGE`.
         *
         * @param {Number/Date} value1 The 1st value to compare
         * @param {Number/Date} value2 The 2nd value to compare
         * @param {String} [desc] The description of the assertion
         */
        isGreaterOrEqual : function (value1, value2, desc) {
            var R       = Siesta.Resource('Siesta.Test.More');

            if (value1 >= value2)
                this.pass(desc, {
                    descTpl             : R.get('isGreaterEqualPassTpl'),
                    value1              : value1,
                    value2              : value2
                })
            else
                this.fail(desc, {
                    assertionName       : 'isGreaterOrEqual',

                    got                 : value1,
                    need                : value2,

                    needDesc            : R.get('needGreaterEqualTo')
                })
        },



        isLE : function () {
            this.isLessOrEqual.apply(this, arguments)
        },

        /**
         * This assertion passes, when the comparison of 1st with 2nd, using `<=` operator will return `true` and fails otherwise.
         *
         * It has a synonym - `isLE`.
         *
         * @param {Number/Date} value1 The 1st value to compare
         * @param {Number/Date} value2 The 2nd value to compare
         * @param {String} [desc] The description of the assertion
         */
        isLessOrEqual : function (value1, value2, desc) {
            var R       = Siesta.Resource('Siesta.Test.More');

            if (value1 <= value2)
                this.pass(desc, {
                    descTpl             : R.get('isLessEqualPassTpl'),
                    value1              : value1,
                    value2              : value2
                })
            else
                this.fail(desc, {
                    assertionName       : 'isLessOrEqual',

                    got                 : value1,
                    need                : value2,

                    needDesc            : R.get('needLessEqualTo')
                })
        },


        /**
         * This assertion suppose to compare the numeric values. It passes when the passed values are approximately the same (the difference
         * is withing a threshold). A threshold can be provided explicitly (when assertion is called with 4 arguments),
         * or it will be set to 5% from the 1st value (when calling assertion with 3 arguments).
         *
         * @param {Number} value1 The 1st value to compare
         * @param {Number} value2 The 2nd value to compare
         * @param {Number} threshold The maximum allowed difference between values. This argument can be omitted.
         * @param {String} [desc] The description of the assertion
         */
        isApprox : function (value1, value2, threshold, desc) {
            var R       = Siesta.Resource('Siesta.Test.More');

            if (arguments.length == 2) threshold  = Math.abs(value1 * 0.05)

            if (arguments.length == 3) {
                if (this.typeOf(threshold) == 'String') {
                    desc            = threshold
                    threshold      = Math.abs(value1 * 0.05)
                }
            }

            // this function normalizes the fractional numbers to fixed point presentation
            // for example in JS: 1.05 - 1 = 0.050000000000000044
            // so what we do is: (1.05 * 10^2 - 1 * 10^2) / 10^2 = (105 - 100) / 100 = 0.05
            var subtract    = function (value1, value2) {
                var fractionalLength    = function (v) {
                    var afterPointPart = (v + '').split('.')[ 1 ]

                    return afterPointPart && afterPointPart.length || 0
                }

                var maxLength           = Math.max(fractionalLength(value1), fractionalLength(value2))
                var k                   = Math.pow(10, maxLength);

                return (value1 * k - value2 * k) / k;
            };

            if (Math.abs(subtract(value2, value1)) <= threshold)
                this.pass(desc, {
                    descTpl             : R.get('isApproxToPassTpl'),
                    value1              : value1,
                    value2              : value2,
                    annotation          : value2 == value1 ? R.get('exactMatch') : (R.get('withinThreshold') + ': ' + threshold)
                })
            else
                this.fail(desc, {
                    assertionName       : 'isApprox',
                    got                 : value1,
                    need                : value2,
                    needDesc            : R.get('needApprox'),
                    annotation          : R.get('thresholdIs') + ': ' + threshold
                })
        },


        /**
         * This assertion passes when the passed `string` matches to a regular expression `regex`. When `regex` is a string,
         * assertion will check that it is a substring of `string`
         *
         * @param {String} string The string to check for "likeness"
         * @param {String/RegExp} regex The regex against which to test the string, can be also a plain string
         * @param {String} [desc] The description of the assertion
         */
        like : function (string, regex, desc) {
            var R       = Siesta.Resource('Siesta.Test.More');

            if (this.typeOf(regex) == "RegExp")

                if (string.match(regex))
                    this.pass(desc, {
                        descTpl             : R.get('stringMatchesRe'),
                        string              : string,
                        regex               : regex
                    })
                else
                    this.fail(desc, {
                        assertionName       : 'like',
                        got                 : string,
                        need                : regex,
                        needDesc            : R.get('needStringMatching')
                    })
            else

                if (string.indexOf(regex) != -1)
                    this.pass(desc, {
                        descTpl             : R.get('stringHasSubstring'),
                        string              : string,
                        regex               : regex
                    })
                else
                    this.fail(desc, {
                        assertionName       : 'like',
                        got                 : string,
                        need                : regex,
                        needDesc            : R.get('needStringContaining')
                    })
        },

        /**
         * This method is the opposite of 'like', it adds failed assertion, when the string matches the passed regex.
         *
         * @param {String} string The string to check for "unlikeness"
         * @param {String/RegExp} regex The regex against which to test the string, can be also a plain string
         * @param {String} [desc] The description of the assertion
         */
        unlike : function(string, regex, desc) {
            var R       = Siesta.Resource('Siesta.Test.More');

            if (this.typeOf(regex) == "RegExp")

                if (!string.match(regex))
                    this.pass(desc, {
                        descTpl             : R.get('stringNotMatchesRe'),
                        string              : string,
                        regex               : regex
                    })
                else
                    this.fail(desc, {
                        assertionName       : 'unlike',
                        got                 : string,
                        need                : regex,
                        needDesc            : R.get('needStringNotMatching')
                    })
            else

                if (string.indexOf(regex) == -1)
                    this.pass(desc, {
                        descTpl             : R.get('stringHasNoSubstring'),
                        string              : string,
                        regex               : regex
                    })
                else
                    this.fail(desc, {
                        assertionName       : 'unlike',
                        got                 : string,
                        need                : regex,
                        needDesc            : R.get('needStringNotContaining')
                    })
        },


        "throws" : function () {
            this.throwsOk.apply(this, arguments)
        },

        throws_ok : function () {
            this.throwsOk.apply(this, arguments)
        },

        /**
         * This assertion passes if the `func` function throws an exception during executing, and the
         * stringified exception passes the 'like' assertion (with 'expected' parameter).
         *
         * It has synonyms - `throws_ok` and `throws`.
         *
         *      t.throwsOk(function(){
         *          throw "oopsie";
         *      }, 'oopsie', 'Some description text');
         *
         * See also {@link Siesta.Test#livesOk} method.
         *
         * @param {Function} func The function which should throw an exception
         * @param {String/RegExp} expected The regex against which to test the stringified exception, can be also a plain string
         * @param {String} [desc] The description of the assertion
         */
        throwsOk : function (func, expected, desc) {
            var R       = Siesta.Resource('Siesta.Test.More');

            if (this.typeOf(func) != 'Function') throw new Error(R.get('throwsOkInvalid'))

            var e = this.getExceptionCatcher()(func)

            // assuming no one will throw undefined exception..
            if (e === undefined) {
                this.fail(desc, {
                    assertionName       : 'throws_ok',
                    annotation          : R.get('didntThrow')
                })

                return
            }

            if (e instanceof this.getTestErrorClass())
                //IE uses non-standard 'description' property for error msg
                e = e.message || e.description

            e = '' + e

            if (this.typeOf(expected) == "RegExp")

                if (e.match(expected))
                    this.pass(desc, {
                        descTpl             : R.get('exMatchesRe'),
                        expected            : expected
                    })
                else
                    this.fail(desc, {
                        assertionName       : 'throws_ok',
                        got                 : e,
                        gotDesc             : R.get('exceptionStringifiesTo'),
                        need                : expected,
                        needDesc            : R.get('needStringMatching')
                    })
            else

                if (e.indexOf(expected) != -1)
                    this.pass(desc, {
                        descTpl             : R.get('exContainsSubstring'),
                        expected            : expected
                    })
                else
                    this.fail(desc, {
                        assertionName       : 'throws_ok',
                        got                 : e,
                        gotDesc             : R.get('exceptionStringifiesTo'),
                        need                : expected,
                        needDesc            : R.get('needStringContaining')
                    })
        },



        lives_ok : function () {
            this.livesOk.apply(this, arguments)
        },

        lives : function () {
            this.livesOk.apply(this, arguments)
        },

        /**
         * This assertion passes, when the supplied `func` function doesn't throw an exception during execution.
         *
         * See also {@link Siesta.Test#throwsOk} method.
         *
         * This method has two synonyms: `lives_ok` and `lives`
         *
         * @param {Function} func The function which is not supposed to throw an exception
         * @param {String} [desc] The description of the assertion
         */
        livesOk : function (func, desc) {
            if (this.typeOf(func) != 'Function') {
                func = [ desc, desc = func ][ 0 ]
            }

            var R       = Siesta.Resource('Siesta.Test.More');
            var e       = this.getExceptionCatcher()(func)

            if (e === undefined)
                this.pass(desc, {
                    descTpl             : R.get('fnDoesntThrow')
                })
            else
                this.fail(desc, {
                    assertionName       : 'lives_ok',
                    annotation          : R.get('fnThrew') + ': ' + e
                })
        },


        isa_ok : function (value, className, desc) {
            this.isInstanceOf(value, className, desc)
        },


        isaOk : function (value, className, desc) {
            this.isInstanceOf(value, className, desc)
        },

        /**
         * This assertion passes, when the supplied `value` is the instance of the `className`. The check is performed with
         * `instanceof` operator. The `className` parameter can be supplied as class constructor or as string, representing the class
         * name. In the latter case the `class` will eval'ed to receive the class constructor.
         *
         * This method has synonyms: `isaOk`, `isa_ok`
         *
         * @param {Mixed} value The value to check for 'isa' relationship
         * @param {Class/String} className The class to check for 'isa' relationship with `value`
         * @param {String} [desc] The description of the assertion
         */
        isInstanceOf : function (value, className, desc) {
            var R       = Siesta.Resource('Siesta.Test.More');

            try {
                if (this.typeOf(className) == 'String') className = this.global.eval(className)
            } catch (e) {
                this.fail(desc, {
                    assertionName       : 'isa_ok',
                    annotation          : Siesta.Resource('Siesta.Test.Function', 'exceptionEvalutingClass')
                })

                return
            }

            if (value instanceof className)
                this.pass(desc, {
                    descTpl             : R.get('isInstanceOfPass')
                })
            else
                this.fail(desc, {
                    assertionName       : 'isa_ok',
                    got                 : value,
                    need                : String(className),
                    needDesc            : R.get('needInstanceOf')
                })
        },


        /**
         * This assertion passes, if supplied value is a String.
         *
         * @param {Mixed} value The value to check.
         * @param {String} [desc] The description of the assertion
         */
        isString : function (value, desc) {
            var R       = Siesta.Resource('Siesta.Test.More');

            if (this.typeOf(value) == 'String')
                this.pass(desc, {
                    descTpl     : R.get('isAString'),
                    value       : value
                })
            else
                this.fail(desc, {
                    got         : value,
                    need        : R.get('aStringValue')
                })
        },


        /**
         * This assertion passes, if supplied value is an Object
         *
         * @param {Mixed} value The value to check.
         * @param {String} [desc] The description of the assertion
         */
        isObject : function (value, desc) {
            var R       = Siesta.Resource('Siesta.Test.More');

            if (this.typeOf(value) == 'Object')
                this.pass(desc, {
                    descTpl     : R.get('isAnObject'),
                    value       : value
                })
            else
                this.fail(desc, {
                    got         : value,
                    need        : R.get('anObject')
                })
        },


        /**
         * This assertion passes, if supplied value is an Array
         *
         * @param {Mixed} value The value to check.
         * @param {String} [desc] The description of the assertion
         */
        isArray : function (value, desc) {
            var R       = Siesta.Resource('Siesta.Test.More');

            if (this.typeOf(value) == 'Array')
                this.pass(desc, {
                    descTpl     : R.get('isAnArray'),
                    value       : value
                })
            else
                this.fail(desc, {
                    got         : value,
                    need        : R.get('anArrayValue')
                })
        },


        /**
         * This assertion passes, if supplied value is a Number.
         *
         * @param {Mixed} value The value to check.
         * @param {String} [desc] The description of the assertion
         */
        isNumber : function (value, desc) {
            var R       = Siesta.Resource('Siesta.Test.More');

            if (this.typeOf(value) == 'Number')
                this.pass(desc, {
                    descTpl     : R.get('isANumber'),
                    value       : value
                })
            else
                this.fail(desc, {
                    got         : value,
                    need        : R.get('aNumberValue')
                })
        },


        /**
         * This assertion passes, if supplied value is a Boolean.
         *
         * @param {Mixed} value The value to check.
         * @param {String} [desc] The description of the assertion
         */
        isBoolean : function (value, desc) {
            var R       = Siesta.Resource('Siesta.Test.More');

            if (this.typeOf(value) == 'Boolean')
                this.pass(desc, {
                    descTpl     : R.get('isABoolean'),
                    value       : value
                })
            else
                this.fail(desc, {
                    got         : value,
                    need        : R.get('aBooleanValue')
                })
        },


        /**
         * This assertion passes, if supplied value is a Date.
         *
         * @param {Mixed} value The value to check.
         * @param {String} [desc] The description of the assertion
         */
        isDate : function (value, desc) {
            var R       = Siesta.Resource('Siesta.Test.More');

            if (this.typeOf(value) == 'Date')
                this.pass(desc, {
                    descTpl     : R.get('isADate'),
                    value       : value
                })
            else
                this.fail(desc, {
                    got         : value,
                    need        : R.get('aDateValue')
                })
        },


        /**
         * This assertion passes, if supplied value is a RegExp.
         *
         * @param {Mixed} value The value to check.
         * @param {String} [desc] The description of the assertion
         */
        isRegExp : function (value, desc) {
            var R       = Siesta.Resource('Siesta.Test.More');

            if (this.typeOf(value) == 'RegExp')
                this.pass(desc, {
                    descTpl     : R.get('isARe'),
                    value       : value
                })
            else
                this.fail(desc, {
                    got         : value,
                    need        : R.get('aReValue')
                })
        },


        /**
         * This assertion passes, if supplied value is a Function.
         *
         * @param {Mixed} value The value to check.
         * @param {String} [desc] The description of the assertion
         */
        isFunction : function (value, desc) {
            var R       = Siesta.Resource('Siesta.Test.More');

            if (this.typeOf(value) == 'Function' || this.typeOf(value) == 'AsyncFunction')
                this.pass(desc, {
                    descTpl     : R.get('isAFunction'),
                    value       : value
                })
            else
                this.fail(desc, {
                    got         : value,
                    need        : R.get('aFunctionValue')
                })
        },


        is_deeply : function (obj1, obj2, desc) {
            this.isDeeply.apply(this, arguments)
        },

        /**
         * This assertion passes when in-depth comparison of 1st and 2nd arguments (which are assumed to be JSON objects) shows that they are equal.
         * Comparison is performed with '==' operator, so `[ 1 ]` and `[ "1" ] objects will be equal. The objects should not contain cyclic references.
         *
         * This method works correctly with the *placeholders* generated with method {@link #any}.
         *
         * This method has a synonym: `is_deeply`
         *
         * @param {Object} obj1 The 1st object to compare
         * @param {Object} obj2 The 2nd object to compare
         * @param {String} [desc] The description of the assertion
         */
        isDeeply : function (obj1, obj2, desc) {
            var R       = Siesta.Resource('Siesta.Test.More');

            var diff

            if (this.typeOf(obj1) === this.typeOf(obj2) && this.compareObjects(obj1, obj2)) {

                this.pass(desc, {
                    descTpl             : R.get('isDeeplyPassTpl'),
                    obj1                : obj1,
                    obj2                : obj2
                })
            }
            // DeepDiff Not supported in IE8
            else if (typeof DeepDiff != 'undefined' && (diff = DeepDiff(obj1, obj2))) {

                if (diff.length > 5) {
                    this.diag(R.get('tooManyDifferences', { num : 5, total : diff.length}))
                }

                for (var i = 0; i < Math.min(diff.length, 5); i++) {
                    var diffItem    = diff[i];
                    var path        = (diffItem.path || []).join('.');
                    var saw         = path ? (path + ': ' + diffItem.lhs) : obj1;
                    var expected    = path ? (path + ': ' + diffItem.rhs) : obj2;

                    this.fail(desc, {
                        assertionName       : 'isDeeply',
                        got                 : saw,
                        need                : expected
                    })

                    // Also log it to console for easy inspection
                    window.console && console.log('DIFF RESULT:', diffItem);
                }

            } else {
                this.fail(desc, {
                    assertionName       : 'isDeeply',
                    got                 : obj1,
                    need                : obj2
                })
            }
        },


        /**
         * This assertion passes when in-depth comparison of 1st and 2nd arguments (which are assumed to be JSON objects) shows that they are equal.
         * Comparison is performed with '===' operator, so `[ 1 ]` and `[ "1" ] objects will be different. The objects should not contain cyclic references.
         *
         * This method works correctly with the *placeholders* generated with method {@link #any}.
         *
         * @param {Object} obj1 The 1st object to compare
         * @param {Object} obj2 The 2nd object to compare
         * @param {String} [desc] The description of the assertion
         */
        isDeeplyStrict : function (obj1, obj2, desc) {
            if (this.typeOf(obj1) === this.typeOf(obj2) && this.compareObjects(obj1, obj2, true)) {

                var R       = Siesta.Resource('Siesta.Test.More');

                this.pass(desc, {
                    descTpl             : R.get('isDeeplyStrictPassTpl'),
                    obj1                : obj1,
                    obj2                : obj2
                })
            }
            else
                this.fail(desc, {
                    assertionName       : 'isDeeplyStrict',
                    got                 : obj1,
                    need                : obj2
                })
        },

        expectGlobal : function () {
            this.expectGlobals.apply(this, arguments)
        },


        /**
         * This method accepts a variable number of names of expected properties in the global scope. When verifying the globals with {@link #verifyGlobals}
         * assertions, the expected gloabls will not be counted as failed assertions.
         *
         * This method has a synonym with singular name: `expectGlobal`
         *
         * @param {String/RegExp} name1 The name of global property or the regular expression to match several properties
         * @param {String/RegExp} name2 The name of global property or the regular expression to match several properties
         * @param {String/RegExp} nameN The name of global property or the regular expression to match several properties
         */
        expectGlobals : function () {
            this.expectedGlobals.push.apply(this.expectedGlobals, arguments)
        },


        isGlobalExpected : function (name, index) {
            var me                  = this

            if (!index || index && !index.expectedStrings) {
                if (!index) index   = {}

                Joose.O.extend(index, {
                    expectedStrings     : {},
                    expectedRegExps     : []
                })

                Joose.A.each(this.expectedGlobals.concat(this.browserGlobals), function (value) {
                    if (me.typeOf(value) == 'RegExp')
                        index.expectedRegExps.push(value)
                    else
                        index.expectedStrings[ value ] = true
                })
            }

            if (index.expectedStrings[ name ]) return true

            var imageWithIdCreatesGlobalEnumerable  = Siesta.Project.Browser.FeatureSupport().supports.imageWithIdCreatesGlobalEnumerable;

            // remove after https://bugzilla.mozilla.org/show_bug.cgi?id=959992 will be fixed
            if (imageWithIdCreatesGlobalEnumerable) {
                var domEl       = this.global.document.getElementById(name)

                if (domEl && domEl.tagName.toLowerCase() == 'img') return true;
            }

            for (var i = 0; i < index.expectedRegExps.length; i++)
                if (index.expectedRegExps[ i ].test(name)) return true

            return false
        },


        forEachUnexpectedGlobal : function (func, scope) {
            scope                   = scope || this

            var index               = {}

            for (var name in this.global)
                if (!this.isGlobalExpected(name, index)) {
                    if (func.call(scope, name) === false) {
                        break;
                    }
                }
        },


        /**
         * This method accepts a variable number of names of expected properties in the global scope and then performs a globals check.
         *
         * It will scan all globals properties in the scope of test and compare them with the list of expected globals. Expected globals can be provided with:
         * {@link #expectGlobals} method or {@link Siesta.Project#expectedGlobals expectedGlobals} configuration option of project.
         *
         * You can enable this assertion to automatically happen at the end of each test, using {@link Siesta.Project#autoCheckGlobals autoCheckGlobals} option of the project.
         *
         * @param {String/RegExp} name1 The name of global property or the regular expression to match several properties
         * @param {String/RegExp} name2 The name of global property or the regular expression to match several properties
         * @param {String/RegExp} nameN The name of global property or the regular expression to match several properties
         */
        verifyGlobals : function () {
            var R       = Siesta.Resource('Siesta.Test.More');

            if (this.disableGlobalsCheck) {
                this.diag(R.get('globalCheckNotSupported'));

                return
            }

            this.expectGlobals.apply(this, arguments)

            this.diag(R.get('globalVariables'))

            var failed          = false
            var i               = 0
            this.forEachUnexpectedGlobal(function (name) {
                this.fail(
                    R.get('globalFound'),
                    R.get('globalName') + ': ' + name + ', ' + R.get('value') + ': ' + Siesta.Util.Serializer.stringify(this.global[ name ])
                )

                failed      = true
                return i++ < 50 // Only report first 50 globals to protect against legacy apps with thousands of globals
            })

            if (!failed) this.pass(R.get('noGlobalsFound'))
        },


        // will create a half-realized, "phantom", "isWaitFor" assertion, which is only purposed
        // for user to get the instant feedback about "waitFor" actions
        // this assertion will be "finalized" and added to the test results in the "finalizeWaiting"
        startWaiting : function (description, sourceLine) {
            var result = new Siesta.Result.Assertion({
                description     : description,
                isWaitFor       : true,
                sourceLine      : sourceLine
            });

            this.fireEvent('testupdate', this, result, this.getResults())

            return result;
        },


        finalizeWaiting : function (result, passed, desc, annotation, errback, suppressPassedWaitForAssertion) {
            // Treat this is an ordinary assertion from now on
            result.completed = true;

            if (passed) {
                if (this.suppressPassedWaitForAssertion || suppressPassedWaitForAssertion) {
                    // Make sure UI is updated and the "noise" is removed
                    this.fireEvent('assertiondiscard', this, result)
                } else {
                    this.pass(desc, annotation, result)
                }
            }
            else {
                this.fail(desc, annotation, result);

                errback && errback()
            }
        },


        /**
         * Waits for passed checker method to return true (or any non-false value, like for example DOM element or array), and calls the callback when this happens.
         * As an additional feature, the callback will receive the result from the checker method as the 1st argument.
         *

    t.waitFor(
        function () { return document.getElementById('someEl') },
        function (el) {
            // waited for element #someEl to appear
            // element will be available in the callback as 1st argument "el"
        }
    )

         * You can also call this method with a single Object having the following properties: `method`, `callback`, `scope`, `timeout`, `interval`, `description`:

    t.waitFor({
        method      : function () { return document.getElementById('someEl') },
        callback    : function (el) {
            // waited for element #someEl to appear
            // element will be available in the callback as 1st argument "el"
        }
    })

         *
         * @param {Function/Number/Object} condition Either a function which should return true (or any other "truthy" value) when a certain condition has been fulfilled,
         * or a number of ms to wait before calling the callback. Can be also an object with the following properties:
         * @param {Function} condition.callback A function to call when the condition has been met. Will receive a result from checker function.
         * @param {Function} condition.method A condition checker function.
         * @param {Object} condition.scope The scope for the callback.
         * @param {Number} condition.timeout The maximum amount of time (in milliseconds) to wait for the condition to be fulfilled.
         * @param {Number} condition.interval The polling interval (in milliseconds)
         * @param {String} condition.description The assertion description
         *
         * @param {Function} callback A function to call when the condition has been met. Will receive a result from checker function.
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time (in milliseconds) to wait for the condition to be fulfilled.
         * Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. If condition is not fullfilled within this time, a failed assertion will be added to the test.
         * @param {Int} [interval=100] The polling interval (in milliseconds)
         *
         * @return {Promise} A promise which will be resolved when wait completes (either successfully or by timeout). In case of successfull resolution
         * promise will be resolved to the result from the checker function. Additionally it has a `force` property as noted below.
         * @return {Function} return.force A function, that will force this wait operation to immediately complete (and call the callback).
         * No call to checker will be performed and callback will not receive a result from it.
         */
        waitFor : function (method, callback, scope, timeout, interval)  {
            var R                       = Siesta.Resource('Siesta.Test.More');
            var description             = ' ' + R.get('conditionToBeFulfilled');
            var assertionName           = 'waitFor';
            var me                      = this;
            var sourceLine              = me.getSourceLine();
            var originalSetTimeout      = me.originalSetTimeout;
            var originalClearTimeout    = me.originalClearTimeout;
            var errback;
            var suppressAssertion;

            if (arguments.length === 1 && this.typeOf(method) == 'Object') {
                var options         = method;

                method              = options.method;
                callback            = options.callback;
                scope               = options.scope;
                timeout             = options.timeout;
                interval            = options.interval

                description         = options.description || description;
                assertionName       = options.assertionName || assertionName;
                suppressAssertion   = options.suppressAssertion;

                // errback is called in case "waitFor" has failed
                errback             = options.errback
            } else
                options             = {}

            var isWaitingForTime        = this.typeOf(method) == 'Number'

            callback                    = callback || function () {}
            description                 = isWaitingForTime ? (method + ' ' + R.get('ms')) : description;

            var pollTimeout

            // early notification about the started "waitFor" operation
            var waitAssertion           = me.startWaiting(R.get('waitingFor') + ' ' + description, sourceLine);

            interval                    = interval || this.waitForPollInterval
            timeout                     = timeout || this.waitForTimeout

            var resolve

            var res = new Promise(function (resolution) {
                resolve = resolution
            })

            // this async frame is not supposed to fail, because it's delayed to `timeout + 3 * interval`
            // failure supposed to be generated in the "pollFunc" and this async frame to be closed
            // however, in IE the async frame may end earlier than failure from "pollFunc"
            // in such case we report the same error as in "pollFunc"
            var async                   = this.beginAsync((isWaitingForTime ? method : timeout) + 3 * interval, function () {
                isDone      = true

                originalClearTimeout(pollTimeout)

                me.finalizeWaiting(waitAssertion, false, R.get('waitedTooLong') + ': ' + description, {
                    assertionName       : assertionName,
                    annotation          : me.typeOf(options.annotation) === 'Function' ? options.annotation() : R.get('conditionNotFulfilled') + ' ' + timeout + R.get('ms') + '. \n\n [code]' + method.toString() + '[/code]'
                }, errback, suppressAssertion)

                resolve()

                return true
            })

            var isDone      = false

            // stop polling, if this test instance has finalized (probably because of exception)
            this.on('beforetestfinalize', function () {
                if (!isDone) {
                    isDone      = true

                    me.finalizeWaiting(waitAssertion, false, R.get('waitingAborted'), null, null, suppressAssertion);
                    me.endAsync(async)

                    originalClearTimeout(pollTimeout)
                }
            }, null, { single : true })

            if (isWaitingForTime) {
                if (method < 0) {
                    throw new Error('Cannot wait for a negative amount of time');
                }
                pollTimeout = originalSetTimeout(function() {
                    isDone      = true

                    me.finalizeWaiting(waitAssertion, true, R.get('Waited') + ' ' + method + ' ' + R.get('ms'), null, null, suppressAssertion || method === 0);
                    me.endAsync(async);
                    me.processCallbackFromTest(callback, [], scope || me)

                    resolve()
                }, method);

            } else {

                var result;
                var startDate   = new Date()

                var pollFunc    = function () {
                    var time = new Date() - startDate;

                    if (time > timeout) {
                        me.endAsync(async);

                        me.finalizeWaiting(waitAssertion, false, R.get('waitedTooLong') + ': ' + description, {
                            assertionName       : assertionName,
                            annotation          : me.typeOf(options.annotation) === 'Function' ? options.annotation() : R.get('conditionNotFulfilled') + ' ' + timeout + R.get('ms') + '. \n\n [code]' + method.toString() + '[/code]'
                        }, errback, suppressAssertion)

                        isDone      = true

                        resolve()

                        return
                    }

                    try {
                        result = method.call(scope || me);
                    } catch (e) {
                        me.endAsync(async);

                        me.finalizeWaiting(waitAssertion, false, assertionName + ' ' + R.get('checkerException'), {
                            assertionName       : assertionName,
                            got                 : e.toString(),
                            gotDesc             : R.get('Exception')
                        }, errback, suppressAssertion)

                        isDone      = true

                        resolve()

                        return
                    }

                    if (result != null && result !== false) {
                        me.endAsync(async);

                        isDone      = true
                        me.finalizeWaiting(
                            waitAssertion,
                            true,
                            R.get('Waited') + ' ' + time + ' ' + R.get('msFor') + ' ' + description,
                            me.typeOf(options.annotation) === 'Function' ? options.annotation() : null,
                            null,
                            // always add assertion (set "suppress" to false), if user has provided description
                            (suppressAssertion || time === 0) && !options.description
                        );

                        me.processCallbackFromTest(callback, [ result ], scope || me)

                        resolve(result)
                    } else
                        pollTimeout = originalSetTimeout(pollFunc, interval)
                }

                pollFunc()
            }

            res.force = function () {
                // wait operation already completed
                if (isDone) return

                isDone      = true

                originalClearTimeout(pollTimeout)

                me.endAsync(async);

                me.finalizeWaiting(waitAssertion, true, R.get('forcedWaitFinalization') + ' ' + description, null, null, suppressAssertion);

                me.processCallbackFromTest(callback, [], scope || me)

                resolve()
            }

            return res
        },

        /**
         * Waits for the number of a number millseconds and calls the callback when after waiting. This is just a convenience synonym for the {@link #waitFor} method.

         t.waitForMs(1500, callback)

         *
         * @param {Number} method The number of ms to wait before calling the callback.
         * @param {Function} callback A function to call when the condition has been met. Will receive a result from checker function.
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time (in milliseconds) to wait for the condition to be fulfilled.
         * Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. If condition is not fullfilled within this time, a failed assertion will be added to the test.
         * @param {Int} [interval=100] The polling interval (in milliseconds)
         *
         * @return {Object} An object with the following properties:
         * @return {Function} return.force A function, that will force this wait operation to immediately complete (and call the callback).
         * No call to checker will be performed and callback will not receive a result from it.
         */
        waitForMs : function() {
            return this.waitFor.apply(this, arguments);
        },


        /**
         * Waits for the passed checker method to return true (or any non-false value, like for example DOM element or array), and calls the callback when this happens.
         * This is just a convenience synonym for the {@link #waitFor} method.
         *

         t.waitForFn(function() { return true; }, callback)

         *
         * @param {Function} fn The checker function.
         * @param {Function} callback A function to call when the condition has been met. Will receive a result from checker function.
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time (in milliseconds) to wait for the condition to be fulfilled.
         * Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. If condition is not fullfilled within this time, a failed assertion will be added to the test.
         * @param {Int} [interval=100] The polling interval (in milliseconds)
         *
         * @return {Object} An object with the following properties:
         * @return {Function} return.force A function, that will force this wait operation to immediately complete (and call the callback).
         * No call to checker will be performed and callback will not receive a result from it.
         */
        waitForFn : function() {
            return this.waitFor.apply(this, arguments);
        },

        // takes the step function and tries to analyze if it is missing the call to "next"
        // returns "true" if "next" is used,
        analyzeChainStep : function (func) {
            var sources         = func.toString()

            var isArrow         = !sources.match(/^function/)
            var firstArg

            if (isArrow) {
                if (sources.match(/^\(/))
                    // args wrapper in ()
                    firstArg    = sources.match(/\(\s*(.*?)\s*(?:,|\))/)[ 1 ]
                else
                    // single argument not wrapped in ()
                    firstArg    = sources.match(/(.*?)\s*=>/)[ 1 ]
            } else {
                firstArg        = sources.match(/function\s*[^(]*\(\s*(.*?)\s*(?:,|\))/)[ 1 ]
            }

            if (!firstArg) return false

            var body

            if (isArrow)
                body            = sources.match(/=>\s*([\s\S]*)/)[ 1 ]
            else
                body            = sources.match(/\{([\s\S]*)\}/)[ 1 ]

            return body.indexOf(firstArg) != -1
        },


        stringifyChainStep : function (step) {
            return this.typeOf(step).match(/^(Async)?Function$/) ? step.toString() : Siesta.Util.Serializer.stringify(step)
        },


        /**
         * This method accepts a variable number of steps, either as individual arguments or as a single array containing them. Steps and arrays
         * of steps are handled just fine, and any step-arrays passed will be flattened. Each step should be either a function or configuration
         * object for {@link Siesta.Test.Action test actions}. These functions / actions will be executed in order.
         *
         * 1) For a function step, it will receive a callback as the 1st argument, to call when the step is completed.
         * As the 2nd and further arguments, the step function will receive the arguments passed to the previous callback.
         *
         * If a function step returns a promise, it should not call the callback, but instead Siesta will wait until the promise returned is
         * resolved / rejected. This plays nicely with the `async/await` functions:
         *

    let someAsyncOperation =
        t => new Promise((resolve, reject) => {
            setTimeout(() => { resolve("someValue") }, 300)
        })

    t.it('Doing async stuff', t => {
        t.chain(
            // function step, that returns a promise (sugared with async/await)
            async () => {
                return await someAsyncOperation(t)
            },
            // desugared version
            function (next, result) {
                return someAsyncOperation(t)
            }
        )
    })

         *
         * The last step will receive a no-op callback, which can be ignored or still called. **Note**, that last step is assumed to
         * complete synchronously! If you need to launch some asynchronous process in the last step, you may need to add another empty function step
         * to the end of the chain.
         *
         * 2) For `Siesta.Test.Action` objects, the callback will be called by the action class automatically,
         * there's no need to provide any callback manually. The configuration object should contain an "action" property, specifying the action class
         * along with other config options depending on the action class. For brevity, instead of using the "action" property, the configuration
         * object can contain the property corresponding to the action name itself, with the action's target (or even a test method with arguments).
         * See the following examples and also refer to the documentation of the action classes.
         *
         * If the configuration object will contain a `desc` property, a passing assertion with its value will be added to the test, after this step has completed.
         *
         * 3) If a step is a sub test instance, created with {@link #getSubTest} method, then the step will launch it.
         *
         * It's better to see how it works in action. For example, when using using only functions:

    t.chain(
        // function receives a callback as 1st argument
        function (next) {
            // we pass that callback to the "click" method
            t.click(buttonEl, next)
        },
        function (next) {
            t.type(fieldEl, 'Something', next)
        },
        function (next) {
            t.is(fieldEl.value == 'Something', 'Correct value in the field')

            // call the callback with some arguments
            next('foo', 'bar')
        },
        // those arguments are now available as arguments of next step
        function (next, value1, value2) {
            t.is(value1, 'foo', 'The arguments for the callback are translated to the arguments of the step')
            t.is(value2, 'bar', 'The arguments for the callback are translated to the arguments of the step')
        }
    )

         *
         * The same example, using action configuration objects for first 2 steps. For the list of available actions
         * please refer to the classes in the `Siesta.Test.Action` namespace.

    t.chain(
        {
            action      : 'click',
            target      : buttonEl,
            desc        : "Clicked on the button"
        },
        // or
        {
            click       : buttonEl,
            desc        : "Clicked on the button"
        },

        {
            action      : 'type',
            target      : fieldEl,
            text        : 'Something',
            desc        : "Typed in the field"
        },
        // or
        {
            type        : 'Something',
            target      : fieldEl,
            desc        : "Typed in the field"
        },

        {
            waitFor     : 'Selector',
            args        : '.selector'
        }
        // or, using Siesta.Test.Action.MethodCall notation:
        {
            waitForSelector : '.selector'
        }

        function (next) {
            t.is(fieldEl.value == 'Something', 'Correct value in the field')

            next('foo', 'bar')
        },
        ...
    )

         * Please note, that by default, each step is expected to complete within the {@link Siesta.Project#defaultTimeout} time.
         * You can change this with the `timeout` property of the step configuration object, allowing some steps to last longer.
         * Steps with sub-tests are expected to complete within {@link Siesta.Project#subTestTimeout}.
         *
         * In a special case, `action` property of the step configuration object can be a function. In this case you can also
         * provide a `timeout` property, otherwise this case is identical to using functions:
         *

    t.chain(
        {
            action      : function (next) { ... },
            // allow 50s for the function to call "next" before step will be considered timed-out
            timeout     : 50000
        },
        ...
    )

         *  **Tip**:
         *
         *  If a step is presented with a `null` or `undefined` value it will be ignored. Additionally, a step can be
         *  an array of steps - all arrays passed to t.chain will be flattened.
         *
         *  These tips allows us to implement conditional steps processing, like this:
         *

    var el1IsInDom          = t.$('.some-class1')[ 0 ]
    var el2IsInDom          = t.$('.some-class2')[ 0 ]

    t.chain(
        { click : '.some-other-el' },

        el1IsInDom ? [
            { click : el1IsInDom },

            el2IsInDom ? [
                { click : el1IsInDom }
            ] : null,
        ] : null,

        ...
    )

         *
         *  See also : {@link #chainForArray}.
         *
         *  @param {Function/Object/Array} step1 The function to execute or action configuration, or an array of steps
         *  @param {Function/Object} step2 The function to execute or action configuration
         *  @param {Function/Object} stepN The function to execute or action configuration
         */
        chain : function () {
            // inline any arrays in the arguments into one array
            var steps       = this.flattenArray(arguments)
            var R           = Siesta.Resource('Siesta.Test.More');

            var nonEmpty    = []
            Joose.A.each(steps, function (step) { if (step) nonEmpty.push(step) })

            steps           = nonEmpty

            var len         = steps.length

            // do nothing
            if (!len) return;

            var me          = this
            var self        = arguments.callee

            var queue       = new Siesta.Util.Queue({
                deferer         : this.originalSetTimeout,
                deferClearer    : this.originalClearTimeout,

                // some dirt - "chain" is generic method and does not know about `simulator`, which appears on browser level only
                interval        : self.hasOwnProperty('actionDelay') ? self.actionDelay : (this.simulator ? this.simulator.actionDelay : 1),

                observeTest     : this
            })

            // hack to allow configuration of `actionDelay`...
            delete self.actionDelay

            var sourceLine  = me.getSourceLine();

            var args        = []

            Joose.A.each(steps, function (step, index) {

                var isLast      = index == len - 1

                queue.addAsyncStep({
                    processor : function (data) {
                        var initStep = function (stepHasOwnAsyncFrame) {

                            if (!stepHasOwnAsyncFrame) {
                                var timeout     = step.timeout || me.defaultTimeout

                                // + 100 to allow `waitFor` steps (which will be waiting the `timeout` time) to
                                // generate their own failures
                                var async       = me.beginAsync(timeout + 100, function () {
                                    me.fail(
                                        R.get('chainStepNotCompleted'),
                                        {
                                            sourceLine      : sourceLine,
                                            annotation      : R.get('stepNumber') + ': ' + (index + 1) + ' ' + R.get('oneBased')
                                                + (sourceLine ? ('\n' + R.get('atLine') + ': ' + sourceLine) : '')
                                                + '\nStep source: ' + me.stringifyChainStep(step),
                                            ownTextOnly     : true
                                        }
                                    )

                                    return true
                                })
                            }

                            return {
                                next    : function () {
                                    var self    = arguments.callee
                                    if (self.__CALLED__) me.fail(R.get('calledMoreThanOnce', { num : index + 1, line : sourceLine }))

                                    self.__CALLED__ = true

                                    if (!stepHasOwnAsyncFrame) me.endAsync(async)

                                    args        =  Array.prototype.slice.call(arguments)

                                    if (step.desc) me.pass(step.desc)

                                    data.next()
                                },
                                async   : async
                            }
                        }

                        if (step instanceof Siesta.Test) {

                            me.launchSubTest(step, initStep(true).next)

                        } else if (me.typeOf(step).match(/^(Async)?Function$/) || me.typeOf(step.action).match(/^(Async)?Function$/)) {
                            var func            = me.typeOf(step).match(/^(Async)?Function$/) ? step : step.action

                            var stepInitData    = initStep(false)
                            // if the last step is a function - then provide empty function as the "next" callback for it
                            var next            = isLast ? function () {} : stepInitData.next

                            args.unshift(next)

                            var result

                            if (me.transparentEx)
                                result = func.apply(me, args)
                            else {
                                var e = me.getExceptionCatcher()(function () {
                                    result = func.apply(me, args)
                                })

                                if (e !== undefined) {
                                    // the "me.endAsync()" here is not enough, because for the t.beforeEach()
                                    // hook, we have a nested chain - one in the "launchSpecs",
                                    // 2nd in the "runBeforeSpecHooks", thats why in the following statement
                                    // we finalize the whole test, to avoid extra waiting for the
                                    // "chain step can not proceed" message
                                    // for `isLast` case `endAsync` will be done below
                                    if (!isLast) me.endAsync(stepInitData.async)

                                    me.failWithException(e, R.get('chainStepEx'))
                                }
                            }

                            // if there's no returning value from the step, then it must call `next` to continue
                            if (!result && !isLast && !me.analyzeChainStep(func)) me.fail(R.get('stepFn') + ' [' + func.toString() + '] ' + R.get('notUsingNext'))

                            if (result) me.handleReturnedPromise(
                                result,
                                next,
                                me.formatString(
                                    'The promise returned from the chain step [' + me.stringifyChainStep(step) + '] did not resolve within {time}ms',
                                    { time : me.defaultTimeout }
                                )
                            )

                            // and finalize the async frame manually, as the "nextFunc" for last step will never be called
                            if (isLast) {
                                me.endAsync(stepInitData.async)

                                if (step.desc) me.pass(step.desc)
                            }

                        } else if (me.typeOf(step) == 'String') {
                            var action      = new Siesta.Test.Action.Eval({
                                actionString        : step,
                                next                : initStep(false).next,
                                test                : me
                            })

                            action.process()

                        } else {
                            var action      = Siesta.Test.ActionRegistry().create(step, me, args, initStep)

                            action.process()
                        }
                    }
                })
            })

            queue.run()
        },


        /**
         * This is a wrapper around the {@link #chain} method, which allows you to run the chain over the steps, generated from the elements
         * of some array. For example, if in some step of outer chain, we need to click the elements with ids, given as the array, we can do:
         *

    function (next) {
        var ids     = [ 'button-1', 'button-2', 'button-3' ]

        t.chainForArray(ids, function (elId) {
            return { click : '#' + elId }
        }, next)
    }
         *
         * @param {Array} array An array with arbitrary elements
         * @param {Function} generator A function, which will be called for every element of the `array`. It should return
         * a chain step, generated from that element. This function can return an array of steps as well. If generator will return `null` or
         * `undefined` nothing will be added to the chain.
         * @param {Function} generator.el An element of the `array`
         * @param {Function} generator.index An index of the element
         * @param {Function} [callback] A function to call, once the chain is completed.
         */
        chainForArray : function (array, generator, callback, reverse) {
            var me          = this
            var steps       = []

            Joose.A[ reverse ? 'eachR' : 'each' ](array, function (el, index) {
                var res     = generator.call(me, el, index)

                if (me.typeOf(res) == 'Array')
                    steps.push.apply(steps, res)
                else
                    if (res) steps.push(res)
            })

            if (callback) steps.push(function () {
                me.processCallbackFromTest(callback)
            })

            this.chain(steps)
        },


        verifyExpectedNumber : function (actual, expected) {
            var operator        = '=='

            if (this.typeOf(expected) == 'String') {
                var match       = /([<>=]=?)\s*(\d+)/.exec(expected)
                var R               = Siesta.Resource('Siesta.Test.Browser');

                if (!match) throw new Error(R.get('wrongFormat')  + ": " + expected)

                operator        = match[ 1 ]
                expected        = Number(match[ 2 ])
            }

            switch (operator) {
                case '==' : return actual == expected
                case '<=' : return actual <= expected
                case '>=' : return actual >= expected
                case '<' : return actual < expected
                case '>' : return actual > expected
            }
        },


        getMaximalTimeout : function () {
            return Math.max(this.waitForTimeout, this.defaultTimeout, this.subTestTimeout, this.timeout || 0, this.isReadyTimeout)
        }
    },


    after : {

        onBeforeTestFinalize : function () {
            if (this.autoCheckGlobals && !this.isFailed() && !this.parent) this.verifyGlobals()
        }
    }
})
//eof Siesta.Test.More
;
Role('Siesta.Test.Role.Placeholder', {
    
    requires    : [
        'equalsTo'
    ]
})
;
/**
@class Siesta.Test.BDD.Spy

This class implements a "spy" - function wrapper which tracks the calls to itself. Spy can be installed
instead of a method in some object or can be used standalone.

Note, that spies "belongs" to a spec and once the spec is completed all spies that were installed during it
will be removed.

*/
Class('Siesta.Test.BDD.Spy', {

    does        : [
        Siesta.Util.Role.CanGetType
    ],

    has         : {
        name                    : null,

        processor               : {
            lazy        : 'this.buildProcessor'
        },

        hostObject              : null,
        propertyName            : null,

        hasOwnOriginalValue     : false,
        originalValue           : null,

        strategy                : 'callThrough',

        returnValueObj          : undefined,
        fakeFunc                : null,
        throwErrorObj           : null,

        // array of { object : scope, args : [], returnValue : }
        callsLog                : Joose.I.Array,

        /**
         * @property {Object} calls This is an object property with several helper methods, related to the calls
         * tracking information. It is assigned to the wrapper function of spy.
         *
         * @property {Function} calls.any Returns `true` if spy was called at least once, `false` otherwise
         * @property {Function} calls.count Returns the number of times this spy was called
         * @property {Function} calls.argsFor Accepts an number of the call (0-based) and return an array of arguments
         * for that call.
         * @property {Function} calls.allArgs Returns an array with the arguments for every tracked function call.
         * Every element of the array is, in turn, an array of arguments.
         * @property {Function} calls.all Returns an array with the context for every tracked function call.
         * Every element of the array is an object of the following structure:

    { object : this, args : [ 0, 1, 2 ], returnValue : undefined }

         * @property {Function} calls.mostRecent Returns a context object of the most-recent tracked function call.
         * @property {Function} calls.first Returns a context object of the first tracked function call.
         * @property {Function} calls.reset Reset all tracking data.
         *
         *
         * Example:

    t.spyOn(obj, 'someMethod').callThrough()

    obj.someMethod(0, 1)
    obj.someMethod(1, 2)

    t.expect(obj.someMethod.calls.any()).toBe(true)
    t.expect(obj.someMethod.calls.count()).toBe(2)
    t.expect(obj.someMethod.calls.first()).toEqual({ object : obj, args : [ 0, 1 ], returnValue : undefined })

         */
        calls                   : null,

        t                       : null,

        /**
         * @property {Siesta.Test.BDD.Spy} and This is just a reference to itself, to add some syntax sugar.
         *
         * This property is also assigned to the wrapper function of spy.
         *

    t.spyOn(obj, 'someMethod').callThrough()

    // same thing as above
    t.spyOn(obj, 'someMethod').and.callThrough()

    // returns spy instance
    obj.someMethod.and

         */
        and                     : function () { return this }
    },


    methods     : {

        initialize : function () {
            var me              = this

            this.calls          = {
                any         : function () { return me.callsLog.length > 0 },
                count       : function () { return me.callsLog.length },
                argsFor     : function (i) { return me.callsLog[ i ].args },

                allArgs     : function (i) { return Joose.A.map(me.callsLog, function (call) { return call.args } ) },
                all         : function () { return me.callsLog },

                mostRecent  : function () { return me.callsLog[ me.callsLog.length - 1 ] },
                first       : function () { return me.callsLog[ 0 ] },

                reset       : function () { me.reset() }
            }

            var R       = Siesta.Resource('Siesta.Test.BDD.Spy')

            var hostObject      = this.hostObject
            var propertyName    = this.propertyName

            if (hostObject) {
                var originalValue           = hostObject[ propertyName ]

                if (!/Function/.test(this.typeOf(originalValue))) throw R.get("spyingNotOnFunction")

                if (originalValue.__SIESTA_SPY__) originalValue.__SIESTA_SPY__.remove()

                this.originalValue          = hostObject[ propertyName ]
                this.hasOwnOriginalValue    = hostObject.hasOwnProperty(propertyName)

                hostObject[ propertyName ]  = this.getProcessor()
            }

            if (this.t) this.t.spies.push(this)
        },


        buildProcessor : function () {
            var me          = this

            var processor   = function () {
                var args        = Array.prototype.slice.call(arguments)
                var log         = { object : this, args : args }

                me.callsLog.push(log)

                return log.returnValue = me[ me.strategy + 'Strategy' ](this, args)
            }

            processor.__SIESTA_SPY__    = processor.and = me
            processor.calls             = me.calls

            return processor
        },


        returnValueStrategy : function (obj, args) {
            return this.returnValueObj
        },


        callThroughStrategy : function (obj, args) {
            return this.originalValue.apply(obj, args)
        },


        callFakeStrategy : function (obj, args) {
            return this.fakeFunc.apply(obj, args)
        },


        throwErrorStrategy : function (obj, args) {
            var error       = this.throwErrorObj
            var ERROR       = this.t && this.t.global ? this.t.global.Error : Error

            if (!(error instanceof ERROR)) error = new ERROR(error)

            throw error
        },


        /**
         * This method makes the spy to also execute the original function it has been installed over. The
         * value returned from original function is returned from the spy.
         *
         * @return {Siesta.Test.BDD.Spy} This spy instance
         */
        callThrough : function () {
            if (!this.hostObject) throw "Need the host object to call through to original method"

            this.strategy       = 'callThrough'

            return this
        },


        /**
         * This method makes the spy to just return `undefined` and not execute the original function.
         *
         * @return {Siesta.Test.BDD.Spy} This spy instance
         */
        stub : function () {
            this.returnValue()

            return this
        },


        /**
         * This method makes the spy to return the value provided and not execute the original function.
         *
         * @param {Object} value The value that will be returned from the spy.
         *
         * @return {Siesta.Test.BDD.Spy} This spy instance
         */
        returnValue : function (value) {
            this.strategy       = 'returnValue'

            this.returnValueObj = value

            return this
        },


        /**
         * This method makes the spy to call the provided function and return the value from it, instead of the original function.
         *
         * @param {Function} func The function to call instead of the original function
         *
         * @return {Siesta.Test.BDD.Spy} This spy instance
         */
        callFake : function (func) {
            this.strategy   = 'callFake'

            this.fakeFunc   = func

            return this
        },


        /**
         * This method makes the spy to throw the specified `error` value (instead of calling the original function).
         *
         * @param {Object} error The error value to throw. If it is not an `Error` instance, it will be passed to `Error` constructor first.
         *
         * @return {Siesta.Test.BDD.Spy} This spy instance
         */
        throwError : function (error) {
            this.strategy       = 'throwError'

            this.throwErrorObj  = error

            return this
        },


        remove : function () {
            var hostObject      = this.hostObject

            if (hostObject) {
                if (this.hasOwnOriginalValue)
                    hostObject[ this.propertyName ] = this.originalValue
                else
                    delete hostObject[ this.propertyName ]
            }

            // cleanup paranoya
            this.originalValue  = this.hostObject = hostObject = null
            this.callsLog       = []

            this.returnValueObj = this.fakeFunc = this.throwErrorObj = null

            var processor       = this.getProcessor()

            if (processor)
                processor.and   = processor.calls   = processor.__SIESTA_SPY__ = null

            this.processor      = null
        },


        /**
         * This method resets all calls tracking data. Spy will report as it has never been called yet.
         */
        reset : function () {
            this.callsLog      = []
        }
    }
})
;
Class('Siesta.Test.BDD.Placeholder', {
    
    does        : Siesta.Test.Role.Placeholder,
    
    has         : {
        clsConstructor  : { required : true },
        t               : null,
        context         : null,
        
        globals         : {
            init            : [
                'String',
                'Boolean',
                'Number',
                'Date',
                'RegExp',
                'Function',
                'Array',
                'Object'
            ]
        }
    },
    
    
    methods     : {
        
        getClassName : function (onlyGlobals) {
            var clsConstructor      = this.getClassConstructor()
            var context             = this.context

            var clsName
            
            Joose.A.each(this.globals, function (property) {
                if (clsConstructor == context[ property ]) { clsName = property; return false }    
            })
            
            return onlyGlobals ? clsName : clsName || (clsConstructor ? clsConstructor + '' : '')
        },
        
        
        getClassConstructor : function () {
            return this.clsConstructor
        },
        
        
        equalsTo : function (value) {
            var clsConstructor      = this.getClassConstructor()
            
            if (!clsConstructor) return true
            
            if (value instanceof Siesta.Test.BDD.Placeholder) {
                var ownClassName    = this.getClassName(true)
                
                if (
                    value.getClassName(true) == 'Object' && (
                        ownClassName == 'Date' ||
                        ownClassName == 'RegExp' ||
                        ownClassName == 'Function'||
                        ownClassName == 'Array'
                    )
                ) {
                    return true
                }
                
                return clsConstructor == value.getClassConstructor()
            }
            
            var isEqual             = false
            
            var globalCls           = this.getClassName(true)
            
            if (globalCls)
                isEqual             = this.t.typeOf(value) == globalCls || (value instanceof this.context[ globalCls ])
            
            return isEqual || (value instanceof clsConstructor)
        },
        
        
        toString : function () {
            return 'any ' + (this.getClassName() || 'value')
        }
    }
})
;
Class('Siesta.Test.BDD.NumberPlaceholder', {
    
    does        : Siesta.Test.Role.Placeholder,
    
    has         : {
        value           : { required : true },
        threshold       : null
    },
    
    
    methods     : {
        
        initialize : function () {
            if (this.threshold == null) this.threshold = this.value * 0.05
        },
        
        
        equalsTo : function (value) {
            return Math.abs(value - this.value) <= this.threshold
        },
        
        
        toString : function () {
            return 'any number approximately equal to ' + this.value
        }
    }
})
;
Class('Siesta.Test.BDD.StringPlaceholder', {
    
    does        : [
        Siesta.Util.Role.CanGetType,
        Siesta.Test.Role.Placeholder
    ],
    
    has         : {
        value           : { required : true }
    },
    
    
    methods     : {
        
        equalsTo : function (string) {
            if (this.typeOf(this.value) == 'RegExp')
                return this.value.test(string)
            else
                return String(string).indexOf(this.value) > -1
        },
        
        
        toString : function () {
            if (this.typeOf(this.value) == 'RegExp')
                return 'any string matching: ' + this.value
            else
                return 'any string containing: ' + this.value
        }
    }
})
;
/**
@class Siesta.Test.BDD.Expectation

This class is the central point for writing assertions in BDD style. Instances of this class can be generated with the {@link Siesta.Test#expect expect}
method. Then, calling some method on the instance will create a new assertion in the test.

* **Note**, that to negate any assertion, you can use a special property {@link #not}, that contains an expectation instance with the opposite meaning.

For example:

    t.expect(1).toBe(1)
    t.expect(1).not.toBe(2)

    t.expect('Foo').toContain('oo')
    t.expect('Foo').not.toContain('bar')


*/
Class('Siesta.Test.BDD.Expectation', {

    does        : [
        Siesta.Util.Role.CanGetType
    ],

    has         : {
        value           : null,

        isNot           : false,

        /**
         * @property {Siesta.Test.BDD.Expectation} not Another expectation instance with the negated meaning.
         */
        not             : null,

        t               : null
    },


    methods     : {

        initialize : function () {

            if (!this.isNot) this.not = new this.constructor({
                isNot           : true,
                t               : this.t,

                value           : this.value
            })
        },


        process : function (passed, config) {
            var isNot       = this.isNot
            config          = config || {}

            config.not      = config.not || isNot ? 'not ' : ''
            config.got      = config.hasOwnProperty('got') ? config.got : this.value

            if (config.noGot) delete config.got

            var assertionName   = config.assertionName

            if (assertionName && isNot) config.assertionName = assertionName.replace(/^(expect\(.+?\)\.)/, '$1not.')

            passed          = isNot ? !passed : passed

            this.t[ passed ? 'pass' : 'fail' ](null, config)
        },


        /**
         * This assertion compares the value provided to the {@link Siesta.Test#expect expect} method with the `expectedValue` argument.
         * Comparison is done with `===` operator, so it should be used **only with the primitivies** - numbers, strings, booleans etc.
         *
         * To deeply compare Date, Arrays and JSON objects in general, use {@link #toEqual} method.
         *
         * This method works correctly with the placeholders generated with {@link Siesta.Test#any any} method
         *
         * @param {Primitive} expectedValue An expected value
         */
        toBe : function (expectedValue) {
            var R = Siesta.Resource('Siesta.Test.BDD.Expectation');

            this.process(this.t.compareObjects(this.value, expectedValue, true, true), {
                descTpl             : R.get('expectText') + ' {got} {!not}' + R.get('toBeText') + ' {need}',
                assertionName       : 'expect(got).toBe(need)',
                need                : expectedValue,
                needDesc            : this.isNot ? R.get('needNotText') : R.get('needText')
            })
        },


        /**
         * This assertion compares the value provided to the {@link Siesta.Test#expect expect} method with the `expectedValue` argument.
         *
         * Comparison works for Date, Array, and JSON objects in general. It is performed "deeply".
         * Right now the values should not contain cyclic references.
         *
         * This method works correctly with the placeholders generated with {@link Siesta.Test#any any} method
         *
         * @param {Mixed} expectedValue An expected value
         */
        toEqual : function (expectedValue) {
            var R = Siesta.Resource('Siesta.Test.BDD.Expectation');

            this.process(this.t.compareObjects(this.value, expectedValue, true), {
                descTpl             : R.get('expectText') +' {got} {!not}' + R.get('toBeEqualToText') + ' {need}',
                assertionName       : 'expect(got).toEqual(need)',
                need                : expectedValue,
                needDesc            : this.isNot ? R.get('needNotText') : R.get('needText')
            })
        },


        /**
         * This assertion passes, when value provided to the {@link Siesta.Test#expect expect} method is `null`.
         */
        toBeNull : function () {
            var R = Siesta.Resource('Siesta.Test.BDD.Expectation');

            this.process(this.t.compareObjects(this.value, null, true, true), {
                descTpl             : R.get('expectText') + ' {got} {!not}' + R.get('toBeText') + ' null',
                assertionName       : 'expect(got).toBeNull()',
                need                : null,
                needDesc            : this.isNot ? R.get('needNotText') : R.get('needText')
            })
        },


        /**
         * This assertion passes, when value provided to the {@link Siesta.Test#expect expect} method is `NaN`.
         */
        toBeNaN : function () {
            var value   = this.value
            var R = Siesta.Resource('Siesta.Test.BDD.Expectation');

            this.process(this.t.typeOf(value) == 'Number' && value != value, {
                descTpl             : R.get('expectText') + ' {got} {!not}' + R.get('toBeText') + ' NaN',
                assertionName       : 'expect(got).toBeNaN()',
                need                : NaN,
                needDesc            : this.isNot ? R.get('needNotText') : R.get('needText')
            })
        },


        /**
         * This assertion passes, when value provided to the {@link Siesta.Test#expect expect} method is not the `undefined` value.
         */
        toBeDefined : function () {
            var R = Siesta.Resource('Siesta.Test.BDD.Expectation');

            this.process(this.value !== undefined, {
                descTpl             : R.get('expectText') + ' {got} {!not}' + R.get('toBeDefinedText'),
                assertionName       : 'expect(got).toBeDefined()'
            })
        },


        /**
         * This assertion passes, when value provided to the {@link Siesta.Test#expect expect} method is the `undefined` value.
         */
        toBeUndefined : function (value) {
            var R = Siesta.Resource('Siesta.Test.BDD.Expectation');

            this.process(this.value === undefined, {
                descTpl             : R.get('expectText') + ' {got} {!not}' + R.get('toBeUndefinedText'),
                assertionName       : 'expect(got).toBeUndefined()'
            })
        },


        /**
         * This assertion passes, when value provided to the {@link Siesta.Test#expect expect} method is "truthy" - evaluates to `true`.
         * For example - non empty strings, numbers except the 0, objects, arrays etc.
         */
        toBeTruthy : function () {
            var R = Siesta.Resource('Siesta.Test.BDD.Expectation');

            this.process(this.value, {
                descTpl             : R.get('expectText') + ' {got} {!not}' + R.get('toBeTruthyText'),
                assertionName       : 'expect(got).toBeTruthy()'
            })
        },


        /**
         * This assertion passes, when value provided to the {@link Siesta.Test#expect expect} method is "falsy" - evaluates to `false`.
         * For example - empty strings, number 0, `null`, `undefined`, etc.
         */
        toBeFalsy : function () {
            var R = Siesta.Resource('Siesta.Test.BDD.Expectation');

            this.process(!this.value, {
                descTpl             : R.get('expectText') + ' {got} {!not}' + R.get('toBeFalsyText'),
                assertionName       : 'expect(got).toBeFalsy()'
            })
        },


        /**
         * This assertion passes, when the string provided to the {@link Siesta.Test#expect expect} method matches the regular expression.
         *
         * @param {RegExp} regexp The regular expression to match the string against
         */
        toMatch : function (regexp) {
            var R = Siesta.Resource('Siesta.Test.BDD.Expectation');

            if (this.t.typeOf(regexp) != 'RegExp') throw new Error("`expect().toMatch()` matcher expects a regular expression")

            this.process(new RegExp(regexp).test(this.value), {
                descTpl             : R.get('expectText') + ' {got} {!not}' + R.get('toMatchText') + ' {need}',
                assertionName       : 'expect(got).toMatch(need)',
                need                : regexp,
                needDesc            : this.isNot ? R.get('needNotMatchingText') : R.get('needMatchingText')
            })
        },


        /**
         * This assertion passes in 2 cases:
         *
         * 1) When the value provided to the {@link Siesta.Test#expect expect} method is a string, and it contains a passed substring.
         * 2) When the value provided to the {@link Siesta.Test#expect expect} method is an array (or array-like), and it contains a passed element.
         *
         * @param {String/Mixed} element The element of the array or a sub-string
         */
        toContain : function (element) {
            var value       = this.value
            var t           = this.t
            var R = Siesta.Resource('Siesta.Test.BDD.Expectation');

            var passed      = false

            if (t.typeOf(value) == 'String') {
                this.process(value.indexOf(element) >= 0, {
                    descTpl             : R.get('expectText') + ' {got} {!not}' + R.get('toContainText') + ' {need}',
                    assertionName       : 'expect(got).toContain(need)',
                    need                : element,
                    needDesc            : this.isNot ? R.get('needStringNotContainingText') : R.get('needStringContainingText')
                })
            } else {
                // Normalize to allow NodeList, Arguments etc.
                value = Array.prototype.slice.call(value);

                for (var i = 0; i < value.length; i++)
                    if (t.compareObjects(element, value[ i ], true)) {
                        passed      = true
                        break
                    }

                this.process(passed, {
                    descTpl             : R.get('expectText') + ' {got} {!not}' + R.get('toContainText') + ' {need}',
                    assertionName       : 'expect(got).toContain(need)',
                    need                : element,
                    needDesc            : this.isNot ? R.get('needArrayNotContainingText') : R.get('needArrayContainingText')
                })

            }
        },


        /**
         * This assertion passes, when the number provided to the {@link Siesta.Test#expect expect} method is less than the
         * expected number.
         *
         * @param {Number} expectedValue The number to compare with
         */
        toBeLessThan : function (expectedValue) {
            var R = Siesta.Resource('Siesta.Test.BDD.Expectation');

            this.process(this.value < expectedValue, {
                descTpl             : R.get('expectText') + ' {got} {!not}' + R.get('toBeLessThanText') + ' {need}',
                assertionName       : 'expect(got).toBeLessThan(need)',
                need                : expectedValue,
                needDesc            : this.isNot ? R.get('needGreaterEqualThanText') : R.get('needLessThanText')
            })
        },


        /**
         * This assertion passes, when the number provided to the {@link Siesta.Test#expect expect} method is greater than the
         * expected number.
         *
         * @param {Number} expectedValue The number to compare with
         */
        toBeGreaterThan : function (expectedValue) {
            var R = Siesta.Resource('Siesta.Test.BDD.Expectation');

            this.process(this.value > expectedValue, {
                descTpl             : R.get('expectText') + ' {got} {!not}' + R.get('toBeGreaterThanText') + ' {need}',
                assertionName       : 'expect(got).toBeGreaterThan(need)',
                need                : expectedValue,
                needDesc            : this.isNot ? R.get('needLessEqualThanText') : R.get('needGreaterThanText')
            })
        },


        /**
         * This assertion passes, when the number provided to the {@link Siesta.Test#expect expect} method is approximately equal
         * the given number. The proximity can be defined as the `precision` argument
         *
         * @param {Number} expectedValue The number to compare with
         * @param {Number} [precision=2] The number of digits after dot (comma) that should be same in both numbers.
         */
        toBeCloseTo : function (expectedValue, precision) {
            precision       = precision != null ? precision : 2

            // not sure why we divide the precision by 2, but jasmine does that for some reason
            var threshold   = Math.pow(10, -precision) / 2
            var delta       = Math.abs(this.value - expectedValue)
            var R           = Siesta.Resource('Siesta.Test.BDD.Expectation');

            this.process(delta < threshold, {
                descTpl             : R.get('expectText') + ' {got} {!not}' + R.get('toBeCloseToText') +' {need}',
                assertionName       : 'expect(got).toBeCloseTo(need)',
                need                : expectedValue,
                needDesc            : this.isNot ? R.get('needValueNotCloseToText') : R.get('needValueCloseToText'),
                annotation          : delta ? R.get('thresholdIsText') + threshold : R.get('exactMatchText')
            })
        },


        /**
         * This assertion passes when the function provided to the {@link Siesta.Test#expect expect} method, throws an exception
         * during its execution.
         *
         * t.expect(function(){
         *     throw "oopsie";
         * }).toThrow());
         *
         */
        toThrow : function () {
            var func    = this.value
            var t       = this.t
            var R       = Siesta.Resource('Siesta.Test.BDD.Expectation');

            if (t.typeOf(func) != 'Function') throw new Error("`expect().toMatch()` matcher expects a function")

            var e       = t.getExceptionCatcher()(func)

            if (e instanceof t.getTestErrorClass())
                //IE uses non-standard 'description' property for error msg
                e = e.message || e.description

            this.process(e !== undefined, {
                descTpl             : R.get('expectText') + ' function {!not}' + R.get('toThrowText'),
                assertionName       : 'expect(func).toThrow()',
                annotation          : e ? (R.get('thrownExceptionText') + ': ' + Siesta.Util.Serializer.stringify(e)) : R.get('noExceptionThrownText'),

                noGot               : true
            })
        },


        /**
         * This assertion passes, if a spy, provided to the {@link Siesta.Test#expect expect} method have been
         * called expected number of times. The expected number of times can be provided as the 1st argument and by default
         * is 1.
         *
         * One can also provide the function, spied on, to the {@link Siesta.Test#expect expect} method.
         *
         * Examples:
         *
    var spy = t.spyOn(obj, 'process')

    // call the method 2 times
    obj.process()
    obj.process()

    // following 2 calls are equivalent
    t.expect(spy).toHaveBeenCalled();
    t.expect(obj.process).toHaveBeenCalled();

    // one can also use exact number of calls or comparison operators
    t.expect(obj.process).toHaveBeenCalled(2);
    t.expect(obj.process).toHaveBeenCalled('>1');
    t.expect(obj.process).toHaveBeenCalled('<=3');

         *
         * See also {@link #toHaveBeenCalledWith}
         *
         * @param {Number/String} expectedNumber Expected number of calls. Can be either a number, specifying the exact
         * number of calls, or a string. In the latter case one can include a comparison operator in front of the number.
         *
         */
        toHaveBeenCalled : function (expectedNumber) {
            expectedNumber  = expectedNumber != null ? expectedNumber : '>=1'

            var spy         = this.value
            var t           = this.t
            var R           = Siesta.Resource('Siesta.Test.BDD.Expectation');

            if (this.typeOf(spy) == 'Function') {
                if (!spy.__SIESTA_SPY__) throw new Error(R.get('wrongSpy'))

                spy         = spy.__SIESTA_SPY__
            }

            if (!(spy instanceof Siesta.Test.BDD.Spy)) throw new Error(R.get('wrongSpy'))

            this.process(t.verifyExpectedNumber(spy.callsLog.length, expectedNumber), {
                descTpl             : R.get('toHaveBeenCalledDescTpl'),
                assertionName       : 'expect(func).toHaveBeenCalled()',
                methodName          : spy.propertyName || '[function]',
                got                 : spy.callsLog.length,
                gotDesc             : R.get('actualNbrOfCalls'),
                need                : (this.isNot ? 'not ' : '') + expectedNumber,
                needDesc            : R.get('expectedNbrOfCalls')
            })
        },


        /**
         * This assertion passes, if a spy, provided to the {@link Siesta.Test#expect expect} method have been
         * called at least once with the specified arguments.
         *
         * One can also provide the function, spied on, to the {@link Siesta.Test#expect expect} method.
         *
         * One can use placeholders, generated with the {@link Siesta.Test.BDD#any any} method to verify the arguments.
         *
         * Example:
         *

    var spy = t.spyOn(obj, 'process')

    // call the method 2 times with different arguments
    obj.build('development', '1.0.0')
    obj.build('release', '1.0.1')

    t.expect(spy).toHaveBeenCalledWith('development', '1.0.0');
    // or
    t.expect(obj.process).toHaveBeenCalledWith('development', t.any(String));

         *
         * See also {@link #toHaveBeenCalled}
         *
         * @param {Object} arg1 Argument to a call
         * @param {Object} arg2 Argument to a call
         * @param {Object} argN Argument to a call
         */
        toHaveBeenCalledWith : function () {
            var spy         = this.value
            var t           = this.t
            var R           = Siesta.Resource('Siesta.Test.BDD.Expectation');

            if (this.typeOf(spy) == 'Function') {
                if (!spy.__SIESTA_SPY__) throw new Error(R.get('wrongSpy'))

                spy         = spy.__SIESTA_SPY__
            }

            if (!(spy instanceof Siesta.Test.BDD.Spy)) throw new Error(R.get('wrongSpy'))

            var args                        = Array.prototype.slice.call(arguments)
            var foundCallWithMatchingArgs   = false

            Joose.A.each(spy.callsLog, function (call) {
                if (t.compareObjects(call.args, args)) { foundCallWithMatchingArgs = true; return false }
            })

            this.process(foundCallWithMatchingArgs, {
                descTpl             : R.get('toHaveBeenCalledWithDescTpl'),
                assertionName       : 'expect(func).toHaveBeenCalledWith()',
                methodName          : spy.propertyName,
                noGot               : true
            })
        }
    }
})
;
/**
@class Siesta.Test.BDD

A mixin providing a BDD style layer for most of the assertion methods.
It is consumed by {@link Siesta.Test}, so all of its methods are available in all tests.

*/
Role('Siesta.Test.BDD', {

    requires    : [
        'getSubTest', 'chain'
    ],

    has         : {
        specType                : null, // `describe` or `it`

        beforeEachHooks         : Joose.I.Array,
        afterEachHooks          : Joose.I.Array,

        sequentialSubTests      : Joose.I.Array,

        // flag, whether the "run" function of the test (containing actual test code) have been already run
        codeProcessed           : false,

        launchTimeout           : null,

        // Siesta.Test.BDD.Expectation should already present on the page
        expectationClass        : Siesta.Test.BDD.Expectation,

        failOnExclusiveSpecsWhenAutomated   : false,

        spies                   : Joose.I.Array
    },


    methods     : {

        checkSpecFunction : function (func, type, name) {
            if (!func)          throw new Error(Siesta.Resource('Siesta.Test.BDD', 'codeBodyMissing') + " " + (type == 'describe' ? 'suite' : 'spec') + ' [' + name + ']')
            if (!func.length)   throw new Error(Siesta.Resource('Siesta.Test.BDD', 'codeBodyOf') + " " + (type == 'describe' ? 'suite' : 'spec') + ' [' + name + '] ' + Siesta.Resource('Siesta.Test.BDD', 'missingFirstArg'))
        },


        /**
         * This is an "exclusive" version of the regular {@link #describe} suite. When such suites presents in some test file,
         * the other regular suites at the same level will not be executed, only "exclusive" ones.
         *
         * @param {String} name The name or description of the suite
         * @param {Function} code The code function for this suite. It will receive a test instance as the first argument which should be used for all assertion methods.
         * @param {Number} [timeout] A maximum duration for this suite. If not provided {@link Siesta.Project#subTestTimeout} value is used.
         */
        ddescribe : function (name, code, timeout) {
            this.describe(name, code, timeout, true)
        },


        /**
         * This is a no-op method, allowing you to quickly ignore some suites.
         */
        xdescribe : function () {
        },


        /**
         * This method starts a sub test with *suite* (in BDD terms). Such suite consists from one or more *specs* (see method {@link #it}} or other suites.
         * The number of nesting levels is not limited. All suites of the same nesting level are executed sequentially.
         *
         * For example:
         *
    t.describe('A product', function (t) {

        t.it('should have feature X', function (t) {
            ...
        })

        t.describe('feature X', function (t) {
            t.it('should be cool', function (t) {
                ...
            })
        })
    })
         *
         * See also {@link #beforeEach}, {@link #afterEach}, {@link #xdescribe}, {@link #ddescribe}
         *
         * @param {String} name The name or description of the suite
         * @param {Function} code The code function for this suite. It will receive a test instance as the first argument which should be used for all assertion methods.
         * @param {Number} [timeout] A maximum duration for this suite. If not provided {@link Siesta.Project#subTestTimeout} value is used.
         */
        describe : function (name, code, timeout, isExclusive) {
            this.checkSpecFunction(code, 'describe', name)

            var subTest     = this.getSubTest({
                name            : name,
                run             : code,

                isExclusive     : isExclusive,

                specType        : 'describe',
                timeout         : timeout
            })

            if (this.codeProcessed) this.scheduleSpecsLaunch()

            this.sequentialSubTests.push(subTest)
        },


        /**
         * This is an "exclusive" version of the regular {@link #it} spec. When such specs presents in some suite,
         * the other regular specs at the same level will not be executed, only "exclusive" ones. Note, that even "regular" suites (`t.describe`) sections
         * will be ignored, if they are on the same level with the exclusive `iit` section.
         *
         * @param {String} name The name or description of the spec
         * @param {Function} code The code function for this spec. It will receive a test instance as the first argument which should be used for all assertion methods.
         * @param {Number} [timeout] A maximum duration for this spec. If not provided {@link Siesta.Project#subTestTimeout} value is used.
         */
        iit : function (name, code, timeout) {
            if (this.project.isAutomated) {
                if (this.failOnExclusiveSpecsWhenAutomated) this.fail(Siesta.Resource('Siesta.Test.BDD', 'iitFound'));
            }
            this.it(name, code, timeout, true)
        },


        /**
         * This is a no-op method, allowing you to quickly ignore some specs.
         */
        xit : function () {
        },


        /**
         * This method starts a sub test with *spec* (in BDD terms). Such spec consists from one or more assertions (or *expectations*, *matchers*, etc) or other nested specs
         * and/or suites. See the {@link #expect} method. The number of nesting levels is not limited. All specs of the same nesting level are executed sequentially.
         *
         * For example:
         *
    t.describe('A product', function (t) {

        t.it('should have feature X', function (t) {
            ...
        })

        t.it('should have feature Y', function (t) {
            ...
        })
    })
         *
         * See also {@link #beforeEach}, {@link #afterEach}, {@link #xit}, {@link #iit}
         *
         * @param {String} name The name or description of the spec
         * @param {Function} code The code function for this spec. It will receive a test instance as the first argument which should be used for all assertion methods.
         * @param {Number} [timeout] A maximum duration for this spec. If not provided {@link Siesta.Project#subTestTimeout} value is used.
         */
        it : function (name, code, timeout, isExclusive, isTodo) {
            this.checkSpecFunction(code, 'it', name)

            var subTest     = this.getSubTest({
                name            : name,
                run             : code,

                isExclusive     : isExclusive,
                isTodo          : Boolean(isTodo) || this.isTodo,

                specType        : 'it',
                timeout         : timeout
            })

            if (this.codeProcessed) this.scheduleSpecsLaunch()

            this.sequentialSubTests.push(subTest)
        },


        /**
         * This method returns an "expectation" instance, which can be used to check various assertions about the passed value.
         *
         * **Note**, that every expectation has a special property `not`, that contains another expectation, but with the negated meaning.
         *
         * For example:
         *

    t.expect(1).toBe(1)
    t.expect(1).not.toBe(2)

    t.expect('Foo').toContain('oo')
    t.expect('Foo').not.toContain('bar')


         * Please refer to the documentation of the {@link Siesta.Test.BDD.Expectation} class for the list of available methods.
         *
         * @param {Mixed} value Any value, that will be assert about
         * @return {Siesta.Test.BDD.Expectation} Expectation instance
         */
        expect : function (value) {
            return new this.expectationClass({
                t           : this,
                value       : value
            })
        },


        /**
         * This method returns a *placeholder*, denoting any instance of the provided class constructor. Such placeholder can be used in various
         * comparison assertions, like {@link #is}, {@link #isDeeply}, {@link Siesta.Test.BDD.Expectation#toBe expect().toBe()},
         * {@link Siesta.Test.BDD.Expectation#toBe expect().toEqual()} and so on.
         *
         * For example:

    t.is(1, t.any(Number))

    t.expect(1).toBe(t.any(Number))

    t.isDeeply({ name : 'John', age : 45 }, { name : 'John', age : t.any(Number))

    t.expect({ name : 'John', age : 45 }).toEqual({ name : 'John', age : t.any(Number))

    t.is(NaN, t.any(), 'When class constructor is not provided `t.any()` should match anything')

         *
         * See also {@link #anyNumberApprox}, {@link #anyStringLike}.
         *
         * @param {Function} clsConstructor A class constructor instances of which are denoted with this placeholder. As a special case if this argument
         * is not provided, a placeholder will match any value.
         *
         * @return {Object} A placeholder object
         */
        any : function (clsConstructor) {
            return new Siesta.Test.BDD.Placeholder({
                clsConstructor      : clsConstructor,
                t                   : this,
                context             : this.global
            })
        },

        /**
         * This method returns a *placeholder*, denoting any number approximately equal to the provided value.
         * Such placeholder can be used in various comparison assertions, like {@link #is}, {@link #isDeeply},
         * {@link Siesta.Test.BDD.Expectation#toBe expect().toBe()},
         * {@link Siesta.Test.BDD.Expectation#toBe expect().toEqual()} and so on.
         *
         * For example:

    t.is(1, t.anyNumberApprox(1.2, 0.5))

    t.expect(1).toBe(t.anyNumberApprox(1.2, 0.5))

         *
         * @param {Number} value The approximate value
         * @param {Number} [threshold] The threshold. If omitted, it is set to 5% from the `value`.
         *
         * @return {Object} A placeholder object
         */
        anyNumberApprox : function (value, threshold) {
            return new Siesta.Test.BDD.NumberPlaceholder({
                value               : value,
                threshold           : threshold
            })
        },


        /**
         * This method returns a *placeholder*, denoting any string that matches provided value.
         * Such placeholder can be used in various comparison assertions, like {@link #is}, {@link #isDeeply},
         * {@link Siesta.Test.BDD.Expectation#toBe expect().toBe()},
         * {@link Siesta.Test.BDD.Expectation#toBe expect().toEqual()} and so on.
         *
         * For example:

    t.is('foo', t.anyStringLike('oo'))

    t.expect('bar').toBe(t.anyStringLike(/ar$/))

         *
         * @param {String/RegExp} value If given as string will denote a substring a string being checked should contain,
         * if given as RegExp instance then string being checked should match this RegExp
         *
         * @return {Object} A placeholder object
         */
        anyStringLike : function (value) {
            return new Siesta.Test.BDD.StringPlaceholder({ value : value })
        },


        scheduleSpecsLaunch : function () {
            if (this.launchTimeout) return

            var async                   = this.beginAsync()
            var originalSetTimeout      = this.originalSetTimeout
            var me                      = this

            this.launchTimeout          = originalSetTimeout(function () {
                me.endAsync(async)
                me.launchTimeout        = null

                me.launchSpecs()
            }, 0)
        },


        runBeforeSpecHooks : function (sourceTest, done) {
            var me          = this

            var runOwnHooks = function (done) {
                me.chainForArray(me.beforeEachHooks, function (hook) {
                    return function (next) {
                        var code        = hook.code

                        if (me.typeOf(code) === 'AsyncFunction') {
                            return code(sourceTest, function () {})
                        } else {
                            if (hook.isAsync) {
                                code(sourceTest, next)
                            } else {
                                code(sourceTest)
                                next()
                            }
                        }
                    }
                }, done)
            }

            if (this.parent)
                this.parent.runBeforeSpecHooks(sourceTest, function () {
                    runOwnHooks(done)
                })
            else
                runOwnHooks(done)
        },


        runAfterSpecHooks : function (sourceTest, done) {
            var me      = this

            me.chainForArray(
                this.afterEachHooks, function (hook) {
                    return function (next) {
                        var code        = hook.code

                        if (me.typeOf(code) === 'AsyncFunction') {
                            return code(sourceTest, function () {})
                        } else {
                            if (hook.isAsync) {
                                code(sourceTest, next)
                            } else {
                                code(sourceTest)
                                next()
                            }
                        }
                    }
                }, function () {
                    me.parent ? me.parent.runAfterSpecHooks(sourceTest, done) : done()
                },
                // reverse
                true
            )
        },


        launchSpecs : function () {
            var me                  = this
            var sequentialSubTests  = this.sequentialSubTests

            this.sequentialSubTests = []

            // hackish way to pass a config to `t.chain`
            this.chain.actionDelay  = 0

            var exclusiveSubTests   = []

            Joose.A.each(sequentialSubTests, function (subTest) {
                if (subTest.isExclusive) exclusiveSubTests.push(subTest)
            })

            this.chainForArray(exclusiveSubTests.length ? exclusiveSubTests : sequentialSubTests, function (subTest) {
                return [
                    subTest.specType == 'it' ? function (next) { me.runBeforeSpecHooks(subTest, next) } : null,
                    subTest,
                    subTest.specType == 'it' ? function (next) { me.runAfterSpecHooks(subTest, next) } : null
                ]
            })
        },


        /**
         * This method allows you to execute some "setup" code hook before every spec ("it" block) of the current test.
         * Such hooks are **not** executed for the "describe" blocks and sub-tests generated with
         * the {@link Siesta.Test#getSubTest getSubTest} method.
         *
         * Note, that specs can be nested and all `beforeEach` hooks are executed in order, starting from the outer-most one.
         *
         * The 1st argument of the hook function is always the test instance being launched.
         *
         * If the hook function is async (`async () => {}`) Siesta will "await" until it completes.
         *
         * If hook is declared with 2 arguments - it is supposed to be asynchronous (you can also force the asynchronous
         * mode with the `isAsync` argument, see below). The completion callback will be provided as the 2nd argument for the hook.
         *
         * This method can be called several times, providing several "hook" functions.
         *
         * For example:

    StartTest(function (t) {
        var baz     = 0

        t.beforeEach(function (t) {
            // the `t` instance here is the "t" instance from the "it" block below
            baz     = 0
        })

        t.it("This feature should work", function (t) {
            t.expect(myFunction(baz++)).toEqual('someResult')
        })
    })

         *
         * @param {Function} code A function to execute before every spec
         * @param {Siesta.Test} code.t A test instance being launched
         * @param {Function} code.next A callback to call when the `beforeEach` method completes. This argument is only provided
         * when hook function is declared with 2 arguments (or the `isAsync` argument is passed as `true`)
         * @param {Boolean} isAsync When passed as `true` this argument makes the `beforeEach` method asynchronous. In this case,
         * the `code` function will receive an additional callback argument, which should be called once the method has completed its work.
         *
         * Note, that `beforeEach` method should complete within {@link Siesta.Test#defaultTimeout defaultTimeout} time, otherwise
         * failing assertion will be added to the test.
         *
         * Example of asynchronous hook:

    StartTest(function (t) {
        var baz     = 0
        var delay = (time) => new Promise(resolve => setTimeout(resolve, time))

        // asynchronous hook function
        t.beforeEach(async t => {
            await delay(100)
            baz     = 0
        })

        // asynchronous setup code
        t.beforeEach(function (t, next) {

            // `beforeEach` will complete in 100ms
            setTimeout(function () {
                baz     = 0
                next()
            }, 100)
        })

        t.describe("This feature should work", function (t) {
            t.expect(myFunction(baz++)).toEqual('someResult')
        })
    })

         */
        beforeEach : function (code, isAsync) {
            this.beforeEachHooks.push({ code : code, isAsync : isAsync || code.length == 2 })
        },


        /**
         * This method allows you to execute some "setup" code hook after every spec ("it" block) of the current test.
         * Such hooks are **not** executed for the "describe" blocks and sub-tests generated with
         * the {@link Siesta.Test#getSubTest getSubTest} method.
         *
         * Note, that specs can be nested and all `afterEach` hooks are executed in order, starting from the most-nested one.
         *
         * The 1st argument of the hook function is always the test instance being launched.
         *
         * If the hook function is async (`async () => {}`) Siesta will "await" until it completes.
         *
         * If hook is declared with 2 arguments - it is supposed to be asynchronous (you can also force the asynchronous
         * mode with the `isAsync` argument, see below). The completion callback will be provided as the 2nd argument for the hook.
         *
         * This method can be called several times, providing several "hook" functions.
         *
         * For example:

    StartTest(function (t) {
        var baz     = 0

        t.afterEach(function (t) {
            // the `t` instance here is the "t" instance from the "it" block below
            baz     = 0
        })

        t.it("This feature should work", function (t) {
            t.expect(myFunction(baz++)).toEqual('someResult')
        })
    })

         *
         * @param {Function} code A function to execute after every spec
         * @param {Siesta.Test} code.t A test instance being completed
         * @param {Function} code.next A callback to call when the `afterEach` method completes. This argument is only provided
         * when hook function is declared with 2 arguments (or the `isAsync` argument is passed as `true`)
         * @param {Boolean} isAsync When passed as `true` this argument makes the `afterEach` method asynchronous. In this case,
         * the `code` function will receive an additional callback argument, which should be called once the method has completed its work.
         *
         * Note, that `afterEach` method should complete within {@link Siesta.Test#defaultTimeout defaultTimeout} time, otherwise
         * failing assertion will be added to the test.
         *
         * Example of asynchronous hook:

    StartTest(function (t) {
        var baz     = 0
        var delay = (time) => new Promise(resolve => setTimeout(resolve, time))

        // asynchronous hook function
        t.beforeEach(async t => {
            await delay(100)
            baz     = 0
        })

        // asynchronous setup code
        t.afterEach(function (t, next) {

            // `afterEach` will complete in 100ms
            setTimeout(function () {
                baz     = 0
                next()
            }, 100)
        })

        t.describe("This feature should work", function (t) {
            t.expect(myFunction(baz++)).toEqual('someResult')
        })
    })

         */
        afterEach : function (code, isAsync) {
            this.afterEachHooks.push({ code : code, isAsync : isAsync || code.length == 2 })
        },


        /**
         * This method installs a "spy" instead of normal function in some object. The "spy" is basically another function,
         * which tracks the calls to itself. With spies, one can verify that some function was called and that
         * it was called with certain arguments.
         *
         * By default, spy will call the original method and return a value from it. To enable different behavior, you can use one of these methods:
         *
         * - {@link Siesta.Test.BDD.Spy#returnValue returnValue} - return a specific value
         * - {@link Siesta.Test.BDD.Spy#callThrough callThrough} - call the original method and return a value from it
         * - {@link Siesta.Test.BDD.Spy#stub stub} - call the original method and return a value from it
         * - {@link Siesta.Test.BDD.Spy#callFake callFake} - call the provided function and return a value from it
         * - {@link Siesta.Test.BDD.Spy#throwError throwError} - throw a specific exception object
         *

        const spy = t.spyOn(obj, 'process')
        // or, if you need to call some method instead
        const spy = t.spyOn(obj, 'process').and.callFake(() => {
            // is called instead of `process` method
        })

        // call the method
        obj.process('fast', 1)

        t.expect(spy).toHaveBeenCalled();
        t.expect(spy).toHaveBeenCalledWith('fast', 1);

         *
         * See also {@link #createSpy}, {@link #createSpyObj}, {@link Siesta.Test.BDD.Expectation#toHaveBeenCalled toHaveBeenCalled},
         * {@link Siesta.Test.BDD.Expectation#toHaveBeenCalledWith toHaveBeenCalledWith}
         *
         * See also the {@link Siesta.Test.BDD.Spy} class for additional details.
         *
         * @param {Object} object An object which property is being spied
         * @param {String} propertyName A name of the property over which to install the spy.
         *
         * @return {Siesta.Test.BDD.Spy} spy Created spy instance
         */
        spyOn : function (object, propertyName) {
            var R       = Siesta.Resource('Siesta.Test.BDD')

            if (!object) { this.warn(R.get('noObject')); return; }

            return new Siesta.Test.BDD.Spy({
                name            : propertyName,

                t               : this,
                hostObject      : object,
                propertyName    : propertyName
            })
        },

        /**
         * This method create a standalone spy function, which tracks all calls to it. Tracking is done using the associated
         * spy instance, which is available as `and` property. One can use the {@link Siesta.Test.BDD.Spy} class API to
         * verify the calls to the spy function.
         *
         * Example:

    var spyFunc     = t.createSpy('onadd listener')

    myObservable.addEventListener('add', spyFunc)

    // do something that triggers the `add` event on the `myObservable`

    t.expect(spyFunc).toHaveBeenCalled()

    t.expect(spyFunc.calls.argsFor(1)).toEqual([ 'Arg1', 'Arg2' ])

         *
         * See also: {@link #spyOn}
         *
         * @param {String} [spyName='James Bond'] A name of the spy for debugging purposes
         *
         * @return {Function} Created function. The associated spy instance is assigned to it as the `and` property
         */
        createSpy : function (spyName) {
            return (new Siesta.Test.BDD.Spy({
                name            : spyName || 'James Bond',
                t               : this
            })).stub().getProcessor()
        },


        /**
         * This method creates an object, which properties are spy functions. Such object can later be used as a mockup.
         *
         * This method can be called with one argument only, which should be an array of properties.
         *
         * Example:

    var mockup      = t.createSpyObj('encoder-mockup', [ 'encode', 'decode' ])
    // or just
    var mockup      = t.createSpyObj([ 'encode', 'decode' ])

    mockup.encode('string')
    mockup.decode('string')

    t.expect(mockup.encode).toHaveBeenCalled()


         *
         * See also: {@link #createSpy}
         *
         * @param {String} spyName A name of the spy object. Can be omitted.
         * @param {Array[String]} properties An array of the property names. For each property name a spy function will be created.
         *
         * @return {Object} A mockup object
         */
        createSpyObj : function (spyName, properties) {
            if (arguments.length == 1) { properties = spyName; spyName = null }

            spyName     = spyName || 'spyObject'

            var me      = this
            var obj     = {}

            Joose.A.each(properties, function (propertyName) {
                obj[ propertyName ] = me.createSpy(spyName)
            })

            return obj
        }
    },


    override : {

        cleanup : function () {
            this.beforeEachHooks    = this.afterEachHooks = null

            this.SUPER()
        },


        onTestFinalize : function () {
            Joose.A.each(this.spies, function (spy) { spy.remove() })

            this.spies  = null

            this.SUPER()
        },


        afterLaunch : function () {
            this.codeProcessed      = true

            this.launchSpecs()

            this.SUPERARG(arguments)
        }
    }

})
//eof Siesta.Test.BDD
;
Role('Siesta.Test.Sub', {
    
    has : {
        isExclusive         : false,
        parent              : { required : true }
    },
    
    
    methods : {
        
        getExceptionCatcher : function () {
            return this.parent.getExceptionCatcher()
        },
        
        
        getTestErrorClass : function () {
            return this.parent.getTestErrorClass()
        },
        
        
        getStartTestAnchor : function () {
            return this.parent.getStartTestAnchor()
        },
        
        
        expectGlobals : function () {
            return this.parent.expectGlobals.apply(this.parent, arguments)
        }
    }
        
})
;
/**
@class Siesta.Test
@mixin Siesta.Test.More
@mixin Siesta.Test.Date
@mixin Siesta.Test.Function
@mixin Siesta.Test.BDD
@mixin Siesta.Util.Role.CanCompareObjects

`Siesta.Test` is a base testing class in Siesta hierarchy. It's not supposed to be created manually, instead the project will create it for you.

This file is a reference only, for a getting start guide and manual please refer to the <a href="#!/guide/getting_started_browser">Siesta getting started in browser environment</a> guide.

SYNOPSIS
========

    StartTest(function(t) {
        t.diag("Sanity")

        t.ok($, 'jQuery is here')

        t.ok(Your.Project, 'My project is here')
        t.ok(Your.Project.Util, '.. indeed')

        setTimeout(function () {

            t.ok(true, "True is ok")

        }, 500)
    })


*/

Class('Siesta.Test', {

    does        : [
        Siesta.Util.Role.CanFormatStrings,
        Siesta.Util.Role.CanGetType,
        Siesta.Util.Role.CanCompareObjects,
        Siesta.Util.Role.CanEscapeRegExp,

        Siesta.Test.More,
        Siesta.Test.Date,
        Siesta.Test.Function,
        Siesta.Test.BDD,

        JooseX.Observable,

        // quick "id" attribute, perhaps should be changed later
        Siesta.Util.Role.HasUniqueGeneratedId
    ],


    has        : {
        name                : null,

        uniqueId            : function () {
            var holder  = Siesta.Test

            holder.__UNIQUE_ID_GEN__ = holder.__UNIQUE_ID_GEN__ || 0

            return ++holder.__UNIQUE_ID_GEN__
        },

        /**
         * @property url The url of this test, as given to the {@link Siesta.Project#start start} method. All subtests of some top-level test shares the same url.
         */
        url                 : { required : true },
        urlExtractRegex     : {
            is      : 'rwc',
            lazy    : function () {
                return new RegExp(this.url.replace(/([.*+?^${}()|[\]\/\\])/g, "\\$1") + ':(\\d+)')
            }
        },

        referenceUrl        : null,

        assertPlanned       : null,
        assertCount         : 0,

        // whether this test contains only "todo" assertions
        isTodo              : false,

        results             : {
            lazy    : function () {
                return new Siesta.Result.SubTest({ description  : this.name || 'Root', test : this })
            }
        },

        run                 : null,
        startTestAnchor     : null,
        exceptionCatcher    : null,
        testErrorClass      : null,

        // same number for the whole subtests tree
        generation          : function () {
            return Math.random()
        },

        launchId            : null,

        parent              : null,

        project             : null,

        // backward compat - alias for `project`
        harness             : null,


        /**
         * @cfg {Number} isReadyTimeout
         *
         * Timeout in milliseconds to wait for test start. Default value is 10000. See also {@link #isReady}
         */
        isReadyTimeout      : 10000,

        // indicates that a test has thrown an exception (not related to failed assertions)
        failed              : false,
        failedException     : null, // stringified exception
        failedExceptionType : null, // type of exception

        // start and end date are stored as numbers (new Date() - 0)
        // this is to allow sharing date instances between different contexts
        startDate           : null,
        endDate             : null,
        lastActivityDate    : null,
        contentManager      : null,

        // the scope provider for the context of the test page
        scopeProvider       : null,
        // the context of the test page
        global              : null,

        reusingSandbox      : false,
        sandboxCleanup      : true,
        sharedSandboxState  : null,

        // the scope provider for the context of the test script
        // usually the same as the `scopeProvider`, but may be different in case of using `enablePageRedirect` option
        scriptScopeProvider : null,

        transparentEx       : false,

        needDone            : false,
        isDone              : false,

        defaultTimeout      : 15000,
        // a default timeout for sub tests
        subTestTimeout      : null,
        // a timeout of this particular test
        timeout             : null,

        timeoutsCount       : function () {
            return { counter : 1 }
        },
        timeoutIds          : Joose.I.Object,
        idsToIndex          : Joose.I.Object,
        waitTitles          : Joose.I.Object,


        // indicates that test function has completed the execution (test may be still running due to async)
        processed           : false,
        // indicates that test has started finalization process ("tearDown" method). At this point, test is considered
        // finished, but the failing assertion (if "tearDown" fails) may still be added
        finalizationStarted : false,

        callback            : null,

        // Nbr of exceptions detected while running the test
        nbrExceptions       : 0,
        testEndReported     : false,

        // only used for testing itself, otherwise should be always `true`
        needToCleanup               : true,

        overrideSetTimeout          : false,

        overrideForSetTimeout       : null,
        overrideForClearTimeout     : null,

        originalSetTimeout          : null,
        originalClearTimeout        : null,

        sourceLineForAllAssertions  : false,

        $passCount                  : null,
        $failCount                  : null,

        actionableMethods           : {
            lazy        : 'buildActionableMethods'
        },

        jUnitClass                  : null,
        groups                      : null,
        automationElementId         : null,

        // enableCodeCoverage          : false,

        snoozeUntil                 : null,

        // user-provided config values
        config                      : null
    },


    methods : {

        initialize : function () {
            // backward compat - both `project` and `harness` attributes should be supported
            this.harness            = this.project = this.project || this.harness

            // suppress bubblings of some events (JooseX.Observable does not provide better mechanism for that, yet)
            this.on('teststart', function (event) {
                if (this.parent) event.stopPropagation()
            })

            this.on('testfinalize', function (event) {
                if (this.parent) event.stopPropagation()
            })

            this.on('teststop', function (event) {
                if (this.parent) event.stopPropagation()
            })

            this.on('beforetestfinalize', function (event) {
                if (this.parent) event.stopPropagation()
            })

            this.on('beforetestfinalizeearly', function (event) {
                if (this.parent) event.stopPropagation()
            })

            this.subTestTimeout     = this.subTestTimeout || 2 * this.defaultTimeout

            if (this.snoozeUntil) {
                this.snoozeUntil = new Date(this.snoozeUntil)

                if (isNaN(this.snoozeUntil - 0 )) this.snoozeUntil = null
            }

            if (this.snoozeUntil && new Date() < this.snoozeUntil) this.isTodo = true

            // Potentially may overwrite default properties and break test instance, should be used with care
            if (this.config) Joose.O.extend(this, this.config)
        },

        /**
         * This method allows you to delay the start of the test, for example for performing some asynchronous setup code (like login into an application).
         * Note, that you may want to use the {@link #setup} method instead, as it is a bit simpler to implement.
         *
         * It is supposed to be overridden in a subclass of the Siesta.Test class and should return an object with two properties: "ready" and "reason"
         * ("reason" is only meaningful for the case where "ready : false"). The Test instance will poll this method and will only launch
         * the test after this method returns "ready : true". If waiting for this condition takes longer than {@link #isReadyTimeout}, the test
         * will be launched anyway, but a failing assertion will be added to it.
         *
         * **Important** This method should always check the value returned by a `this.SUPER` call.
         *
         * A typical example of using this method can be seen below:
         *

    Class('My.Test.Class', {

        isa         : Siesta.Test.Browser,

        has         : {
            isCustomSetupDone           : false
        },

        override : {

            isReady : function () {
                var result = this.SUPERARG(arguments);

                if (!result.ready) return result;

                if (!this.isCustomSetupDone) return {
                    ready       : false,
                    reason      : "Waiting for `isCustomSetupDone` took too long - something wrong?"
                }

                return {
                    ready       : true
                }
            },


            start : function () {
                var me      = this;

                Ext.Ajax.request({
                    url     : 'do_login.php',

                    params  : { ... },

                    success : function () {
                        me.isCustomSetupDone    = true
                    }
                })

                this.SUPERARG(arguments)
            }
        },

        ....
    })

         *
         * @return {Object} Object with properties `{ ready : true/false, reason : 'description' }`
         */
        isReady: function() {
            var R = Siesta.Resource('Siesta.Test');

            // this should allow us to wait until the presense of "run" function
            // it will become available after call to StartTest method
            // which some users may call asynchronously, after some delay
            // see https://www.assembla.com/spaces/bryntum/tickets/379
            // in this case test can not be configured using object as 1st argument for StartTest
            this.run    = this.run || this.getStartTestAnchor().args && this.getStartTestAnchor().args[ 0 ]

            return {
                ready   : this.typeOf(this.run) == 'Function' || this.typeOf(this.run) == 'AsyncFunction',
                reason  : R.get('noCodeProvidedToTest')
            }
        },


        // indicates that the tests are identical or from the same tree (one is parent for another)
        isFromTheSameGeneration : function (test2) {
            return this.generation == test2.generation
        },


        toString : function() {
            return this.url
        },


        // deprecated
        plan : function (value) {
            if (this.assertPlanned != null) throw new Error("Test plan can't be changed")

            this.assertPlanned = value
        },


        addResult : function (result) {
            var isAssertion = result instanceof Siesta.Result.Assertion

            if (isAssertion) result.isTodo = this.isTodo

            // only allow to add diagnostic results and todo results after the end of test
            // and only if "needDone" is enabled
            if (isAssertion && (this.isDone || this.isFinished()) && !result.isTodo) {
                if (!this.testEndReported) {
                    this.testEndReported = true
                    var R = Siesta.Resource('Siesta.Test');

                    this.fail(R.get('addingAssertionsAfterDone'))
                }
            }

            if (isAssertion && !result.index) {
                result.index = ++this.assertCount
            }

            this.getResults().push(result)

            // clear the cache
            this.$passCount     = this.$failCount   = null

            /**
             * This event is fired when an individual test case receives a new result (assertion or diagnostic message).
             *
             * This event bubbles up to the {@link Siesta.Project project}, so you can observe it on the project as well.
             *
             * @event testupdate
             * @member Siesta.Test
             * @param {JooseX.Observable.Event} event The event instance
             * @param {Siesta.Test} test The test instance that just has started
             * @param {Siesta.Result} result The new result. Instance of Siesta.Result.Assertion or Siesta.Result.Diagnostic classes
             */
            this.fireEvent('testupdate', this, result, this.getResults())

            this.lastActivityDate = new Date();

            return result
        },


        /**
         * This method output the diagnostic message.
         * @param {String} desc The text of diagnostic message
         */
        diag : function (desc, callback) {
            this.addResult(new Siesta.Result.Diagnostic({
                // protection from user passing some arbitrary JSON object instead of string
                // (which can be circular and then test report will fail with "Converting circular structure to JSON"
                description : String(desc || '')
            }))

            callback && callback();
        },


        /**
         * This method add the passed assertion to this test.
         *
         * @param {String} desc The description of the assertion
         * @param {String/Object} [annotation] The string with additional description how exactly this assertion passes. Will be shown with monospace font.
         * Can be also an object with the following properties:
         * @param {String} annotation.annotation The actual annotation text
         * @param {String} annotation.descTpl The template for the default description text. Will be used if user did not provide any description for
         * assertion. Template can contain variables in braces. The values for variables are taken as properties of `annotation` parameters with the same name:
         *

    this.pass(desc, {
        descTpl         : '{value1} sounds like {value2}',
        value1          : '1',
        value2          : 'one
    })

         *
         */
        pass : function (desc, annotation, result) {
            if (annotation && this.typeOf(annotation) != 'String') {
                // create a default assertion description
                if (!desc && annotation.descTpl) desc = this.formatString(annotation.descTpl, annotation)

                // actual annotation
                annotation          = annotation.annotation
            }

            if (result) {
                result.passed       = true
                result.description  = String(desc || '')
                result.annotation   = annotation
            }

            this.addResult(result || new Siesta.Result.Assertion({
                passed          : true,

                // protection from user passing some arbitrary JSON object instead of string
                // (which can be circular and then test report will fail with "Converting circular structure to JSON"
                annotation      : String(annotation || ''),
                description     : String(desc || ''),
                sourceLine      : (result && result.sourceLine) || (annotation && annotation.sourceLine) || this.sourceLineForAllAssertions && this.getSourceLine() || null
            }))
        },


        /**
         * This method add the failed assertion to this test.
         *
         * @param {String} desc The description of the assertion
         * @param {String/Object} annotation The additional description how exactly this assertion fails. Will be shown with monospace font.
         *
         * Can be either string or an object with the following properties. In the latter case a string will be constructed from the properties of the object.
         *
         * - `assertionName` - the name of assertion, will be shown in the 1st line, along with originating source line (in FF and Chrome only)
         * - `got` - an arbitrary JavaScript object, when provided will be shown on the next line
         * - `need` - an arbitrary JavaScript object, when provided will be shown on the next line
         * - `gotDesc` - a prompt for "got", default value is "Got", but can be for example: "We have"
         * - `needDesc` - a prompt for "need", default value is "Need", but can be for example: "We need"
         * - `annotation` - A text to append on the last line, can contain some additional explanations
         *
         *  The "got" and "need" values will be stringified to the "not quite JSON" notation. Notably the points of circular references will be
         *  marked with `[Circular]` marks and the values at 4th (and following) level of depth will be marked with triple points: `[ [ [ ... ] ] ]`
         */
        fail : function (desc, annotation, result) {
            var sourceLine          = (result && result.sourceLine) || (annotation && annotation.sourceLine) || this.getSourceLine()
            var assertionName       = '';

            if (annotation && this.typeOf(annotation) != 'String') {
                if (!desc && annotation.descTpl) desc = this.formatString(annotation.descTpl, annotation)

                var strings             = []

                var params              = annotation
                var hasGot              = params.hasOwnProperty('got')
                var hasNeed             = params.hasOwnProperty('need')
                var gotDesc             = params.gotDesc || 'Got'
                var needDesc            = params.needDesc || 'Need'

                assertionName           = params.assertionName
                annotation              = params.annotation

                if (!params.ownTextOnly && (assertionName || sourceLine)) strings.push(
                    'Failed assertion ' + (assertionName ? '`' + assertionName + '` ' : '') + this.formatSourceLine(sourceLine)
                )

                if (hasGot && hasNeed) {
                    var max         = Math.max(gotDesc.length, needDesc.length)

                    gotDesc         = this.appendSpaces(gotDesc, max - gotDesc.length + 1)
                    needDesc        = this.appendSpaces(needDesc, max - needDesc.length + 1)
                }

                if (hasGot)     strings.push(gotDesc   + ': ' + Siesta.Util.Serializer.stringify(params.got))
                if (hasNeed)    strings.push(needDesc  + ': ' + Siesta.Util.Serializer.stringify(params.need))

                if (annotation) strings.push(annotation)

                annotation      = strings.join('\n')
            }

            if (result) {
                // Failing a pending waitFor operation
                result.name         = assertionName;
                result.passed       = false;
                result.annotation   = annotation;
                result.description  = desc;
            }

            this.addResult(result || new Siesta.Result.Assertion({
                name        : assertionName,
                passed      : false,
                sourceLine  : sourceLine,

                // protection from user passing some arbitrary JSON object instead of string
                // (which can be circular and then test report will fail with "Converting circular structure to JSON"
                annotation  : String(annotation || ''),
                description : String(desc || '')
            }))

            this.onFailedAssertion()
        },


        onFailedAssertion : function (noNeedToExit) {
            if (!this.isTodo) {
                if (this.project.debuggerOnFail) eval("debugger")

                if (this.project.breakOnFail && !this.__STOPPED__) {
                    this.__STOPPED__    = true

                    this.project.stopCurrentLaunch(this)

                    if (!noNeedToExit) this.exit()
                }
            }
        },


        /**
         * This method stops the execution of the test early. You can use it if, for example, you already know the status of
         * test (failed) and further actions involves long waitings etc.
         *
         * This method accepts the same arguments as the {@link #fail} method. If at least the one argument is given,
         * a failed assertion will be added to the test before the exit.
         *
         * For example:
         *

        t.chain(
            function (next) {
                // do something

                next()
            },
            function (next) {
                if (someCondition)
                    t.exit("Failure description")
                else
                    next()
            },
            { waitFor : function () { ... } }
        )


         *
         * @param {String} [desc] The description of the assertion
         * @param {String/Object} [annotation] The additional description how exactly this assertion fails. Will be shown with monospace font.
         */
        exit : function (desc, annotation) {
            if (arguments.length > 0) this.fail(desc, annotation)

            this.finalize(true)
            throw '__SIESTA_TEST_EXIT_EXCEPTION__'
        },


        getSource : function () {
            return this.contentManager.getContentOf(this.url)
        },


        getSourceLine : function () {
            var stack           = new Error().stack

            if (!stack) {
                try {
                    throw new Error()
                } catch (e) {
                    stack       = e.stack
                }
            }

            if (stack) {
                var match       = stack.match(this.urlExtractRegex())

                if (match) return match[ 1 ]
            }

            return null
        },


        getStartTestAnchor : function () {
            return this.startTestAnchor
        },


        getExceptionCatcher : function () {
            return this.exceptionCatcher
        },


        getTestErrorClass : function () {
            return this.testErrorClass
        },


        processCallbackFromTest : function (callback, args, scope) {
            var me      = this

            if (!callback) return true;

            if (this.transparentEx) {
                callback.apply(scope || this.global, args || [])
            } else {
                var e = this.getExceptionCatcher()(function () {
                    callback.apply(scope || me.global, args || [])
                })

                if (e) {
                    this.failWithException(e)

                    // flow should be interrupted - exception detected
                    return false
                }
            }

            // flow can be continued
            return true
        },


        getStackTrace : function (e) {
            if (Object(e) !== e)    return null
            if (!e.stack)           return null

            var stackLines      = (e.stack + '').split('\n')
            var message         = e + ''
            var R               = Siesta.Resource('Siesta.Test');
            var result          = []
            var match

            for (var i = 0; i < stackLines.length; i++) {
                var line        = stackLines[ i ]

                if (!line) continue

                // first line should contain exception message
                if (!i) {
                    if (line != message)
                        result.push(message)
                    else {
                        result.push(line)
                        continue;
                    }
                }

                result.push(line)
            }

            if (!result.length) return null

            return result
        },


        formatSourceLine : function (sourceLine) {
            var R               = Siesta.Resource('Siesta.Test');

            return sourceLine ? (R.get('atLine') + ' ' + sourceLine + ' ' + R.get('of') + ' ' + this.url) : ''
        },


        appendSpaces : function (str, num) {
            var spaces      = ''

            while (num--) spaces += ' '

            return str + spaces
        },


        eachAssertion : function (func, scope) {
            scope       = scope || this

            this.getResults().each(function (result) {
                if (result instanceof Siesta.Result.Assertion) func.call(scope, result)
            })
        },


        eachSubTest : function (func, scope) {
            scope       = scope || this

            this.getResults().each(function (result) {
                if (result instanceof Siesta.Result.SubTest)
                    if (func.call(scope, result.test) === false) return false
            })
        },


        eachChildTest : function (func, scope) {
            scope       = scope || this

            this.getResults().eachChild(function (result) {
                if (result instanceof Siesta.Result.SubTest)
                    if (func.call(scope, result.test) === false) return false
            })
        },


        /**
         * This assertion passes when the supplied `value` evalutes to `true` and fails otherwise.
         *
         * @param {Mixed} value The value, indicating wheter assertions passes or fails
         * @param {String} [desc] The description of the assertion
         */
        ok : function (value, desc) {
            var R               = Siesta.Resource('Siesta.Test');

            if (value)
                this.pass(desc, {
                    descTpl             : R.get('isTruthy'),
                    value               : value
                })
            else
                this.fail(desc, {
                    assertionName       : 'ok',
                    got                 : value,
                    annotation          : R.get('needTruthy')
                })
        },


        notok : function () {
            this.notOk.apply(this, arguments)
        },

        /**
         * This assertion passes when the supplied `value` evalutes to `false` and fails otherwise.
         *
         * It has a synonym - `notok`.
         *
         * @param {Mixed} value The value, indicating wheter assertions passes or fails
         * @param {String} [desc] The description of the assertion
         */
        notOk : function (value, desc) {
            var R               = Siesta.Resource('Siesta.Test');

            if (!value)
                this.pass(desc, {
                    descTpl             : R.get('isFalsy'),
                    value               : value
                })
            else
                this.fail(desc, {
                    assertionName       : 'notOk',
                    got                 : value,
                    annotation          : R.get('needFalsy')
                })
        },


        /**
         * This assertion passes when the comparison of 1st and 2nd arguments with `==` operator returns true and fails otherwise.
         *
         * As a special case, one or both arguments can be *placeholders*, generated with method {@link #any}.
         *
         * @param {Mixed} got The value "we have" - will be shown as "Got:" in case of failure
         * @param {Mixed} expected The value "we expect" - will be shown as "Need:" in case of failure
         * @param {String} [desc] The description of the assertion
         */
        is : function (got, expected, desc) {
            var R               = Siesta.Resource('Siesta.Test');

            if (expected && got instanceof this.global.Date) {
                this.isDateEqual(got, expected, desc);
            } else if (this.compareObjects(got, expected, false, true))
                this.pass(desc, {
                    descTpl             : R.get('isEqualTo'),
                    got                 : got,
                    expected            : expected
                })
            else
                this.fail(desc, {
                    assertionName       : 'is',
                    got                 : got,
                    need                : expected
                })
        },



        isnot : function () {
            this.isNot.apply(this, arguments)
        },

        isnt : function () {
            this.isNot.apply(this, arguments)
        },


        /**
         * This assertion passes when the comparison of 1st and 2nd arguments with `!=` operator returns true and fails otherwise.
         * It has synonyms - `isnot` and `isnt`.
         *
         * As a special case, one or both arguments can be instance of {@link Siesta.Test.BDD.Placeholder} class, generated with method {@link #any}.
         *
         * @param {Mixed} got The value "we have" - will be shown as "Got:" in case of failure
         * @param {Mixed} expected The value "we expect" - will be shown as "Need:" in case of failure
         * @param {String} [desc] The description of the assertion
         */
        isNot : function (got, expected, desc) {
            var R               = Siesta.Resource('Siesta.Test');

            if (!this.compareObjects(got, expected, false, true))
                this.pass(desc, {
                    descTpl             : R.get('isNotEqualTo'),
                    got                 : got,
                    expected            : expected
                })
            else
                this.fail(desc, {
                    assertionName       : 'isnt',
                    got                 : got,
                    need                : expected,
                    needDesc            : R.get('needNot')
                })
        },


        /**
         * This assertion passes when the comparison of 1st and 2nd arguments with `===` operator returns true and fails otherwise.
         *
         * As a special case, one or both arguments can be instance of {@link Siesta.Test.BDD.Placeholder} class, generated with method {@link #any}.
         *
         * @param {Mixed} got The value "we have" - will be shown as "Got:" in case of failure
         * @param {Mixed} expected The value "we expect" - will be shown as "Need:" in case of failure
         * @param {String} [desc] The description of the assertion
         */
        exact : function (got, expected, desc) {
            var R               = Siesta.Resource('Siesta.Test');

            if (this.compareObjects(got, expected, true, true))
                this.pass(desc, {
                    descTpl             : R.get('isStrictlyEqual'),
                    got                 : got,
                    expected            : expected
                })
            else
                this.fail(desc, {
                    assertionName       : 'isStrict',
                    got                 : got,
                    need                : expected,
                    needDesc            : R.get('needStrictly')
                })
        },


        /**
         * This assertion passes when the comparison of 1st and 2nd arguments with `===` operator returns true and fails otherwise.
         *
         * As a special case, one or both arguments can be instance of {@link Siesta.Test.BDD.Placeholder} class, generated with method {@link #any}.
         *
         * @param {Mixed} got The value "we have" - will be shown as "Got:" in case of failure
         * @param {Mixed} expected The value "we expect" - will be shown as "Need:" in case of failure
         * @param {String} [desc] The description of the assertion
         */
        isStrict : function (got, expected, desc) {
            var R               = Siesta.Resource('Siesta.Test');

            if (this.compareObjects(got, expected, true, true))
                this.pass(desc, {
                    descTpl             : R.get('isStrictlyEqual'),
                    got                 : got,
                    expected            : expected
                })
            else
                this.fail(desc, {
                    assertionName       : 'isStrict',
                    got                 : got,
                    need                : expected,
                    needDesc            : R.get('needStrictly')
                })
        },


        isntStrict : function () {
            this.isNotStrict.apply(this, arguments)
        },

        /**
         * This assertion passes when the comparison of 1st and 2nd arguments with `!==` operator returns true and fails otherwise.
         * It has synonyms - `isntStrict`.
         *
         * As a special case, one or both arguments can be instance of {@link Siesta.Test.BDD.Placeholder} class, generated with method {@link #any}.
         *
         * @param {Mixed} got The value "we have" - will be shown as "Got:" in case of failure
         * @param {Mixed} expected The value "we expect" - will be shown as "Need:" in case of failure
         * @param {String} [desc] The description of the assertion
         */
        isNotStrict : function (got, expected, desc) {
            var R               = Siesta.Resource('Siesta.Test');

            if (!this.compareObjects(got, expected, true, true))
                this.pass(desc, {
                    descTpl             : R.get('isStrictlyNotEqual'),
                    got                 : got,
                    expected            : expected
                })
            else
                this.fail(desc, {
                    assertionName       : 'isntStrict',
                    got                 : got,
                    need                : expected,
                    needDesc            : R.get('needStrictlyNot')
                })
        },


        // DEPRECATED in 5.0
        wait : function (title, howLong) {
            var R               = Siesta.Resource('Siesta.Test');

            if (this.waitTitles.hasOwnProperty(title)) throw new Error(R.get('alreadyWaiting')+ " [" + title + "]")

            return this.waitTitles[ title ] = this.beginAsync(howLong)
        },


        // DEPRECATED in 5.0
        endWait : function (title) {
            var R               = Siesta.Resource('Siesta.Test');

            if (!this.waitTitles.hasOwnProperty(title)) throw new Error(R.get('noOngoingWait') + " [" + title + "]")

            this.endAsync(this.waitTitles[ title ])

            delete this.waitTitles[ title ]
        },



        /**
         * This method starts the "asynchronous frame". The test will wait for all asynchronous frames to complete before it will finalize.
         * The frame should be finished with the {@link #endAsync} call within the provided `time`, otherwise a failure will be reported.
         *
         * For example:
         *
         *      var async = t.beginAsync()
         *
         *      Ext.require('Some.Class', function () {
         *
         *          t.ok(Some.Class, 'Some class was loaded')
         *
         *          t.endAsync(async)
         *      })
         *
         *
         * Additionally, if you return a `Promise` instance from the test function itself, Siesta will wait until that promise is resolved before finalizing the test.
         * In modern browsers, this allows us to use `async/await` functions:

     StartTest(t => {
        let someAsyncOperation = () => new Promise((resolve, reject) => {
            setTimeout(() => resolve(true), 1000)
        })

        t.it('Doing async stuff', async t => {
            let res = await someAsyncOperation()

            t.ok(res, "Async stuff finished correctly")
        })
    })

         * @param {Number} time The maximum time (in ms) to wait until force the finalization of this async frame. Optional. Default time is 15000 ms.
         * @param {Function} errback Optional. The function to call in case the call to {@link #endAsync} was not detected withing `time`. If function
         * will return any "truthy" value, the failure will not be reported (you can report own failure with this errback).
         *
         * @return {Object} The frame object, which can be used in {@link #endAsync} call
         */
        beginAsync : function (time, errback) {
            time                        = time || this.defaultTimeout

            if (time > this.getMaximalTimeout()) this.fireEvent('maxtimeoutchanged', time)

            var R                       = Siesta.Resource('Siesta.Test');
            var me                      = this
            var originalSetTimeout      = this.originalSetTimeout

            var index                   = this.timeoutsCount.counter++

            // in NodeJS `setTimeout` returns an object and not a simple ID, so we try hard to store that object under unique index
            // also using `setTimeout` from the scope of test - as timeouts in different scopes in browsers are mis-synchronized
            // can't just use `this.originalSetTimeout` because of scoping issues
            var timeoutId               = originalSetTimeout(function () {

                if (me.hasAsyncFrame(index)) {
                    if (!errback || !errback.call(me, me)) me.fail(R.get('noMatchingEndAsync', { time : time }))

                    me.endAsync(index)
                }
            }, time)

            this.timeoutIds[ index ]    = timeoutId

            return index
        },


        timeoutIdToIndex : function (id) {
            var index

            if (typeof id == 'object') {
                index       = id.__index
            } else {
                index       = this.idsToIndex[ id ]
            }

            return index
        },


        hasAsyncFrame : function (index) {
            return this.timeoutIds.hasOwnProperty(index)
        },


        hasAsyncFrameByTimeoutId : function (id) {
            return this.timeoutIds.hasOwnProperty(this.timeoutIdToIndex(id))
        },


        /**
         * This method finalize the "asynchronous frame" started with {@link #beginAsync}.
         *
         * @param {Object} frame The frame to finalize (returned by {@link #beginAsync} method
         */
        endAsync : function (index) {
            var originalSetTimeout      = this.originalSetTimeout
            var originalClearTimeout    = this.originalClearTimeout || this.global.clearTimeout
            var counter                 = 0
            var R                       = Siesta.Resource('Siesta.Test');

            if (index == null) Joose.O.each(this.timeoutIds, function (timeoutId, indx) {
                index = indx
                if (counter++) throw new Error(R.get('endAsyncMisuse'))
            })

            var timeoutId               = this.timeoutIds[ index ]

            // need to call in this way for IE < 9
            originalClearTimeout(timeoutId)
            delete this.timeoutIds[ index ]

            var me = this

            if (this.processed && !this.isFinished())
                // to allow potential call to `done` after `endAsync`
                originalSetTimeout(function () {
                    me.finalize()
                }, 1)
        },


        clearTimeouts : function () {
            var originalClearTimeout    = this.originalClearTimeout

            Joose.O.each(this.timeoutIds, function (value, id) {
                originalClearTimeout(value)
            })

            this.timeoutIds = {}
        },


        processSubTestConfig : function (config) {
            var cfg = Joose.O.extend({
                parent                  : this,

                isTodo                  : this.isTodo,
                transparentEx           : this.transparentEx,

                waitForTimeout          : this.waitForTimeout,
                waitForPollInterval     : this.waitForPollInterval,
                defaultTimeout          : this.defaultTimeout,
                timeout                 : this.subTestTimeout,
                subTestTimeout          : this.subTestTimeout,

                global                  : this.global,
                url                     : this.url,
                scopeProvider           : this.scopeProvider,
                project                 : this.project,
                generation              : this.generation,
                launchId                : this.launchId,

                overrideSetTimeout      : this.overrideSetTimeout,
                originalSetTimeout      : this.originalSetTimeout,
                originalClearTimeout    : this.originalClearTimeout,

                // share the same counter for the whole subtests tree
                timeoutsCount           : this.timeoutsCount,

                autoCheckGlobals        : false,
                needToCleanup           : false
            }, config)

            return cfg
        },


        /**
         * Returns a new instance of the test class, configured as being a "sub test" of the current test.
         *
         * The number of nesting levels is not limited - ie sub-tests may have own sub-tests.
         *
         * Note, that this method does not starts the sub test, but only instatiate it. To start the sub test,
         * use the {@link #launchSubTest} method or the {@link #subTest} helper method.
         *
         * @param {String} name The name of the test. Will be used in the UI, as the parent node name in the assertions tree
         * @param {Function} code A function with test code. Will receive a test instance as the 1st argument.
         * @param {Number} [timeout] A maximum duration (in ms) for this sub test. If test will not complete within this time,
         * it will be considered failed. If not provided, the {@link Siesta.Project#subTestTimeout} value is used.
         *
         * @return {Siesta.Test} A sub test instance
         */
        getSubTest : function (arg1, arg2, arg3) {
            var config
            var R = Siesta.Resource('Siesta.Test');

            if (arguments.length == 2 || arguments.length == 3)
                config = {
                    name        : arg1,
                    run         : arg2,
                    timeout     : arg3
                }
            else if (arguments.length == 1 && this.typeOf(arg1) == 'Function')
                config  = {
                    name        : 'Sub test',
                    run         : arg1
                }

            config              = config || arg1 || {}

            // pass-through only valid timeout values
            if (config.timeout == null) delete config.timeout

            var name            = config.name

            if (!config.run) {
                this.failWithException(R.get('codeBodyMissingForSubTest', { name : name }))
                throw new Error(R.get('codeBodyMissingForSubTest', { name : name }))
            }
            if (!config.run.length) {
                this.failWithException(R.get('codeBodyMissingTestArg', { name : name }))
                throw new Error(R.get('codeBodyMissingTestArg', { name : name }))
            }

            // in the following code, we cache a specialized version of the current test class,
            // that version has "Siesta.Test.Sub" role consumed, as a trait (on the instance level)
            // this is done for efficiency (to not create a separate class per every sub test)
            // and also because Chrome was throwing this exception randomly:
            //     Required attribute [parent] is missed during initialization of undefined
            // caching seems to have that fixed
            var constructor     = config.meta || this.meta.c
            var cls             = constructor
            var cfg             = this.processSubTestConfig(config)

            if (constructor.__WITHSUB__)
                cls             = constructor.__WITHSUB__
            else
                // only need trait for the top level test
                if (!this.parent) cfg.trait = Siesta.Test.Sub

            var subTest         = new cls(cfg)

            if (!this.parent && !constructor.__WITHSUB__) constructor.__WITHSUB__ = subTest.meta.c

            return subTest
        },


        /**
         * This method launch the provided sub test instance.
         *
         * @param {Siesta.Test} subTest A test instance to launch
         * @param {Function} callback A function to call, after the test is completed. This function is called regardless from the test execution result.
         */
        launchSubTest : function (subTest, callback) {
            var me          = this
            var R           = Siesta.Resource('Siesta.Test');
            var timeout     = subTest.timeout || this.subTestTimeout

            var async       = this.beginAsync(timeout, function () {
                me.fail(R.get('failedToFinishWithin', { name : subTest.name ? '[' + subTest.name + ']' : '', timeout : timeout }))

                me.restoreTimeoutOverrides()

                testEndListener.remove()

                subTest.finalize(true)

                callback && callback(subTest)

                return true
            })

            var testEndListener = subTest.on('testfinalize', function () {
                me.endAsync(async)

                me.restoreTimeoutOverrides()

                callback && callback(subTest)
            })

            this.addResult(subTest.getResults())

            subTest.start()
        },


        /**
         * With this method you can mark a group of assertions as "todo", assuming they most likely will fail,
         * but it's still worth to try to run them.
         * The supplied `code` function will be run, it will receive a new test instance as the 1st argument,
         * which should be used for assertion checks (and not the primary test instance, received from `StartTest`).
         *
         * Assertions, failed inside of the `code` block will be still treated by project as "green".
         * Assertions, passed inside of the `code` block will be treated by project as bonus ones and highlighted.
         *
         * See also {@link Siesta.Test.ExtJS#knownBugIn} and {@link Siesta.Test.ExtJS#snooze} methods. Note, that this method will start a new {@link #subTest sub test}.
         *
         * For example:

            t.todo('Scheduled for 4.1.x release', function (todo) {

                var treePanel    = new Ext.tree.Panel()

                todo.is(treePanel.getView().store, treePanel.store, 'NodeStore and TreeStore have been merged and there is only 1 store now');
            })

         * @param {String} why The reason/description for the todo
         * @param {Function} code A function, wrapping the "todo" assertions. This function will receive a special test class instance
         * which should be used for assertion checks
         */
        todo : function (why, code, callback) {
            if (this.typeOf(why) == 'Function') why = [ code, code = why ][ 0 ]

            var todo        = this.getSubTest({
                name            : why,

                run             : code,

                isTodo          : true,
                transparentEx   : false
            })

            this.launchSubTest(todo, callback)
        },


        /**
         * This method allows you to "snooze" the failing test (make it a {@link Siesta.Test#todo todo test} until certain date.
         * After that date, test will become "normal" again. Use with care :)
         *
            t.snooze('2014-10-10', function (todo) {

                var treePanel    = new Ext.tree.Panel()

                todo.is(treePanel.getView().store, treePanel.store, 'NodeStore and TreeStore have been merged and there is only 1 store now');
            })
         *
         * @param {String/Date} snoozeUntilDate The date until which we don't want to hear about this test. Can be provided as `Date` instance or a string, recognized by `Date` constructor
         * @param {Function} fn The function body of the test, will receive a new test instance as 1st argument
         * @param {String} reason The reason or explanation why this test is "snoozed"
         */
        snooze : function(snoozeUntilDate, fn, reason) {
            var R           = Siesta.Resource('Siesta.Test');
            var snoozeDate  = new Date(snoozeUntilDate)

            if (new Date() > snoozeDate) {
                this.it('Unsnoozed', fn, null, false, false);
            } else {
                this.it(R.get('Snoozed until') + ' ' + snoozeDate + ': ' + (reason || ''), fn, null, false, true);
            }
        },



        /**
         * This method starts a new sub test. Sub tests have separate order of assertions. In the browser UI,
         * sub tests are presented with the "parent" node of the assertions tree. Sub tests are useful if you want to test
         * several asynchronous processes in parallel, and would like to see assertions from every process separated.
         *
         * Sub tests may have their own sub tests, the number of nesting levels is not limited.
         *
         * Sub test can contain asynchronous methods as any other tests. Sub tests are considered completed
         * only when all of its asynchronous methods have completed *and* all of its sub-tests are completed too.
         *
         * For example:
         *

    t.subTest('Load 1st store', function (t) {
        var async   = t.beginAsync()

        store1.load({
            callback : function () {
                t.endAsync(async);
                t.isGreater(store1.getCount(), 0, "Store1 has been loaded")
            }
        })
    })

    t.subTest('Load 2nd store', function (t) {
        var async   = t.beginAsync()

        store2.load({
            callback : function () {
                t.endAsync(async);
                t.isGreater(store2.getCount(), 0, "Store2 has been loaded")
            }
        })
    })

         * Note, that sub test starts right away, w/o waiting for any previous sub tests to complete. If you'd like to run several sub-tests
         * sequentially, use {@link #chain} method in combination with {@link #getSubTest} method.
         *
         * @param {String} desc The name of the sub test. Will be shown as the name of the parent node in assertion tree.
         * @param {Function} code The test function to execute. It will receive a test instance as 1st argument. This test instance *must* be
         * used for assertions inside of the test function
         * @param {Function} callback The callback to execute after the sub test completes (either successfully or not)
         * @param {Number} [timeout] A maximum duration (in ms) for this sub test. If test will not complete within this time,
         * it will be considered failed. If not provided, the {@link Siesta.Project#subTestTimeout} value is used.
         */
        subTest : function (desc, code, callback, timeout) {
            var subTest     = this.getSubTest({
                name            : desc || Siesta.Resource('Siesta.Test', 'Subtest'),
                timeout         : timeout,
                run             : code
            })

            this.launchSubTest(subTest, callback)

            return subTest
        },


        stringifyException : function (e, stackTrace) {
            var stringified             = e + ''
            var annotation              = typeof stackTrace === 'string' ? stackTrace : (stackTrace || this.getStackTrace(e) || []).join('\n')

            // prepend the exception message to the stack trace if its not already there
            if (annotation.indexOf(stringified) == -1) annotation = stringified + '\n' + annotation

            return annotation
        },


        failWithException : function (e, description, useDoFinalize) {
            var R                       = Siesta.Resource('Siesta.Test');

            this.failed                 = true

            this.failedException        = e + ''
            this.failedExceptionType    = this.typeOf(e)

            var stackTrace              = this.getStackTrace(e)

            this.addResult(new Siesta.Result.Assertion({
                isException     : true,
                exceptionType   : this.failedExceptionType,
                passed          : false,
                description     : description ? description : ((this.parent ? R.get('Subtest') + " `" + this.name + "`" : R.get('Test') + ' ') + ' ' + R.get('threwException')),
                annotation      : this.stringifyException(e, stackTrace)
            }))

            /**
             * This event is fired when an individual test case has thrown an exception.
             *
             * This event bubbles up to the {@link Siesta.Project project}, so you can observe it on the project as well.
             *
             * @event testfailedwithexception
             * @member Siesta.Test
             * @param {JooseX.Observable.Event} event The event instance
             * @param {Siesta.Test} test The test instance that just threw an exception
             * @param {Object} exception The exception thrown
             */
            this.fireEvent('testfailedwithexception', this, e, stackTrace);

            this.onFailedAssertion(true)

            if (useDoFinalize)
                this.doFinalize()
            else
                this.finalize(true)
        },


        restoreTimeoutOverrides : function () {
            if (this.overrideSetTimeout) {
                this.global.setTimeout      = this.overrideForSetTimeout
                this.global.clearTimeout    = this.overrideForClearTimeout
            }
        },


        // start method can potentially immediately fail the test because of `preloadErrors`
        // it should not access the test's scope because of possible cross-origin failure
        // but it still fires the "teststart" event to notify about assertions
        start : function (preloadErrors) {
            var me          = this;
            var R           = Siesta.Resource('Siesta.Test');

            if (this.startDate) throw R.get('testAlreadyStarted');

            this.startDate  = new Date() - 0

            /**
             * This event is fired when an individual test case starts. When *started*, the test will be waiting for
             * the {@link #isReady} condition to be fullfilled and the {@link #setup} method to complete.
             * After that the test will be *launched* (and execute the `StartTest` function).
             *
             * This event bubbles up to the {@link Siesta.Project project}, you can observe it on the project as well.
             *
             * @event teststart
             * @member Siesta.Test
             * @param {JooseX.Observable.Event} event The event instance
             * @param {Siesta.Test} test The test instance that just has started
             */
            this.fireEvent('teststart', this);

            if (preloadErrors && preloadErrors.length) {
                // this branch bypasses the "doStart" and "finalize" methods
                // its kind of "shortcut execution path"
                Joose.A.each(preloadErrors, function (error) {
                    if (!error.isException)
                        me.fail(error.message)
                    else {
                        me.failWithException(error.message, '', true)
                        return false
                    }
                })

                me.doFinalize()

                return true
            } else
                this.doStart()
        },


        doStart : function () {
            var me          = this
            var R           = Siesta.Resource('Siesta.Test');

            me.onTestStart()

            // Sub-tests should not perform the `setup` or wait for `isReady` readyness
            if (me.parent || me.reusingSandbox) {
                me.launch()
                return
            }

            var errorMessage;

            // Note, that `setTimeout, setInterval` and similar methods here are from the project context

            var cont            = function (isReadyError) {
                var hasTimedOut     = false

                var setupTimeout    = setTimeout(function () {
                    hasTimedOut     = true
                    me.launch(R.get('setupTookTooLong'))
                }, me.isReadyTimeout)

                me.setup(
                    function () {
                        if (!hasTimedOut) {
                            clearTimeout(setupTimeout)
                            me.launch(isReadyError)
                        }
                    },
                    function (setupError) {
                        if (!hasTimedOut) {
                            clearTimeout(setupTimeout)
                            me.launch(isReadyError || setupError)
                        }
                    }
                );
            }

            var readyRes        = me.isReady();

            if (readyRes.ready) {
                // We're ready to go
                cont();
            } else {
                // Need to wait for isReady to give green light
                var timeout         = setTimeout(function () {
                    clearInterval(interval)
                    cont(errorMessage)

                }, me.isReadyTimeout)

                var interval = setInterval(function(){
                    readyRes = me.isReady();

                    if (readyRes.ready) {
                        clearInterval(interval)
                        clearTimeout(timeout)
                        cont();
                    } else {
                        errorMessage = readyRes.reason || errorMessage;
                    }
                }, 100);
            }
        },


        /**
         * This method can perform any setup code your tests need. It is called before the begining of every test and receives
         * a callback and errback, either of those should be called once the setup has completed (or failed).
         * See also {@link #tearDown}.
         *
         * ** IMPORTANT ** Make sure you've called the "super" `setup` method, to perform default setup actions. See below for example.
         *
         * Typical usage for this method can be for example to log in into the application, before interacting with it:
         *

    Class('My.Test.Class', {

        isa         : Siesta.Test.Browser,

        override : {

            setup : function (callback, errback) {
                this.SUPER(function () {

                    Ext.Ajax.request({
                        url     : 'do_login.php',

                        params  : { ... },

                        success : function () {
                            callback()
                        },
                        failure : function () {
                            errback('Login failed')
                        }
                    })

                }, errback)
            }
        },

        ....
    })

         *
         * This method will be called *after* the {@link #isReady} method has reported that the test is ready to start.
         *
         * If the setup has failed for some reason, then an errback should be called and a failing assertion will be added to the test
         * (though the test will be launched anyway). A text of the failed assertion can be given as the 1st argument for the errback.
         *
         * Note, that the setup is supposed to be completed within the {@link #isReadyTimeout} timeout, otherwise it will be
         * considered failed and the test will be launched with a failed assertion.
         *
         * If you need to perform a setup at an earlier point, check the {@link #earlySetup} method.
         *
         * @param {Function} callback A function to call when the setup has completed successfully
         * @param {Function} errback A function to call when the setup has completed with an error
         */
        setup : function (callback, errback) {
            callback.call(this)
        },


        /**
         * This method can perform any asynchronous finalization code your tests need. It is called after the test has
         * been finished (or finalized externally by any reason, for example if user re-starts the test).
         * This method receives a callback and errback, either of those should be called once the tear down has completed
         * (or has failed). Typical usage for this method can be for example to clear the database or release some other resource.
         *
         * **Note** though, that if test suite has experienced a hard failure, this method may not be called.
         *

    Class('My.Test.Class', {

        isa         : Siesta.Test.Browser,

        override : {

            tearDown : function (callback, errback) {
                Ext.Ajax.request({
                    url     : 'clear_the_db.php',

                    params  : { ... },

                    success : function () {
                        callback()
                    },
                    failure : function () {
                        errback("Error message")
                    }
                })
            }
        },

        ....
    })

         *
         * If the tearDown has failed for some reason, then an errback should be called and a failing assertion will be added to the test
         * (though the test will be launched anyway). A text of the failed assertion can be given as the 1st argument for the errback.
         *
         * Note, that the tear down process is supposed to be completed within the {@link #isReadyTimeout} timeout, after this
         * timeout a failing assertion will be added to the test and test suite will just continue execution.
         *
         * @param {Function} callback A function to call when the tear down process has completed successfully
         * @param {Function} errback A function to call when the tear down process has failed.
         * @param {String} [errback.errorMessage] An error message which will be added as a failing assertion to the test.
         */
        tearDown : function (callback, errback) {
            callback.call(this)
        },


        /**
         * This method can perform any setup code your tests need. It is the earliest point for doing setup, it is called
         * even before the iframe of the test is created and started loading. Note, that this means there's no DOM or `window`
         * element the test can access at this point. Normally, you should use the {@link #setup} method
         * for tests initialization purposes.
         *
         * ** IMPORTANT ** Make sure you've called the "SUPER" `earlySetup` method, to perform default setup actions. See below for example.
         *
         * Typical usage for this method can be, for example, to clear the database, before starting to
         * load the {@link Siesta.Project.Browser#pageUrl pageUrl} link.
         *
         * This method receives a callback and errback, either of these should be called once the setup has completed (or failed).
         *

    Class('My.Test.Class', {

        isa         : Siesta.Test.Browser,

        override : {

            earlySetup : function (callback, errback) {
                this.SUPER(
                    function () {
                        Ext.Ajax.request({
                            url     : 'clear_test_db.php',

                            params  : { ... },

                            success : function () {
                                callback()
                            },
                            failure : function () {
                                errback('Reseting DB has failed')
                            }
                        })
                    },
                    errback
                )
            }
        },

        ....
    })

         *
         * If the setup has failed for some reason, then an errback should be called and a failing assertion will be added to the test
         * (though the test will be launched anyway). A text of the failed assertion can be given as the 1st argument for the errback.
         *
         * Note, that the setup is supposed to be completed within the {@link #isReadyTimeout} timeout, otherwise it will be
         * considered failed and the test will be launched with a failed assertion.
         *
         * @param {Function} callback A function to call when the setup has completed successfully
         * @param {Function} errback A function to call when the setup has completed with an error
         */
        earlySetup : function (callback, errback) {
            callback.call(this)
        },


        // only called for the re-used contexts
        cleanupContextBeforeStart : function () {
            var global      = this.global

            this.forEachUnexpectedGlobal(function (name) {
                try {
                    // can throw exception in IE8
                    delete global[ name ]
                } catch (e) {
                }
            })
        },


        // this method assumes "overrideSetTimeout" option is enabled
        clearAsyncFrameGlobally : function (id) {
            var topTest     = this

            while (topTest.parent) topTest = topTest.parent

            topTest.eachSubTest(function (subTest) {
                if (subTest.hasAsyncFrameByTimeoutId(id)) {
                    subTest.overrideForClearTimeout(id)
                    return false
                }
            })
        },


        launch : function (errorMessage) {
            if (errorMessage) {
                var R = Siesta.Resource('Siesta.Test');

                this.fail(R.get('errorBeforeTestStarted'), {
                    annotation      : errorMessage
                })
            }

            var me                      = this
            var global                  = this.global

            var scopeProvider           = this.scopeProvider

            var originalSetTimeout      = this.originalSetTimeout
            var originalClearTimeout    = this.originalClearTimeout

            if (this.overrideSetTimeout) {
                // see http://www.adequatelygood.com/2011/4/Replacing-setTimeout-Globally
                if (!this.reusingSandbox && !this.parent) scopeProvider.runCode('var setTimeout, clearTimeout;')

                global.setTimeout = this.overrideForSetTimeout = function (func, delay) {

                    var index = me.timeoutsCount.counter++

                    // in NodeJS `setTimeout` returns an object and not a simple ID, so we try hard to store that object under unique index
                    // also using `setTimeout` from the scope of test - as timeouts in different scopes in browsers are mis-synchronized
                    var timeoutId = originalSetTimeout(function () {
                        originalClearTimeout(timeoutId)
                        delete me.timeoutIds[ index ]

                        // if the test func has been executed, but the test was not finalized yet - then we should try to finalize it
                        if (me.processed && !me.isFinished())
                            // we are doing that after slight delay, potentially allowing to setup some other async frames in the "func" below
                            originalSetTimeout(function () {
                                me.finalize()
                            }, 1)

                        func()

                    }, delay)

                    // in NodeJS saves the index of the timeout descriptor to the descriptor
                    if (typeof timeoutId == 'object')
                        timeoutId.__index = index
                    else
                        // in browser (where `timeoutId` is a number) - to the `idsToIndex` hash
                        me.idsToIndex[ timeoutId ] = index

                    return me.timeoutIds[ index ] = timeoutId
                }

                global.clearTimeout = this.overrideForClearTimeout = function (id) {
                    if (id == null) return

                    // if there's no timeout id with this index, that probably means
                    // that this "clearTimeout" call corresponds to the "setTimeout" from some other
                    // sub test - parent most probably (or sibling sub test)
                    // strictly that may not be true, because user can launch several sub tests
                    // simultaneously, but, "overrideSetTimeout" for that case can not be supported reliably
                    // anyway, as we need to know from what test the "setTimeout" call comes (to keep it
                    // active) and we can't override it twice
                    if (!me.hasAsyncFrameByTimeoutId(id)) {
                        me.clearAsyncFrameGlobally(id)

                        return
                    }

                    originalClearTimeout(id)

                    var index       = me.timeoutIdToIndex(id)

                    if (index != null) delete me.timeoutIds[ index ]

                    // if the test func has been executed, but the test was not finalized yet - then we should try to finalize it
                    if (me.processed && !me.isFinished())
                        // we are doing that after slight delay, potentially allowing to setup some other async frames after the "clearTimeout" will complete
                        originalSetTimeout(function () {
                            me.finalize()
                        }, 1)
                }
            }
            // eof this.overrideSetTimeout

            // we only don't need to cleanup up when doing a self-testing or for sub-tests
            if (this.needToCleanup) {
                scopeProvider.beforeCleanupCallback = function () {
                    // if scope cleanup happens most probably user has restarted the test and is not interested in the results
                    // of previous launch
                    // finalizing the previous test in such case
                    if (!me.isFinished()) me.finalize(true)

                    if (me.overrideSetTimeout) {
                        global.setTimeout           = originalSetTimeout
                        global.clearTimeout         = originalClearTimeout
                    }

                    // cleanup the closures just in case (probably useful for IE)
                    originalSetTimeout          = originalClearTimeout  = null
                    global                      = null

                    // this iterator will also process "this" test instance too
                    me.eachSubTest(function (subTest) {
                        subTest.cleanup()
                    })
                }
            }

            if (this.reusingSandbox && this.sandboxCleanup && !this.parent) {
                this.cleanupContextBeforeStart()
            }

            var result
            var run     = this.run
            var e

            if (this.transparentEx) {
                if (me.project.debuggerOnStart && !me.parent) eval("debugger")

                result  = run(me)
            } else
                e = this.getExceptionCatcher()(function () {

                    if (me.project.debuggerOnStart && !me.parent) eval("debugger")

                    result = run(me)
                })

            if (result) this.handleReturnedPromise(
                result,
                null,
                this.formatString(
                    'The promise returned from the sub-test [' + me.name + '] did not resolve within {time}ms',
                    { time : me.defaultTimeout }
                )
            )

            this.afterLaunch(e)
        },


        handleReturnedPromise : function (promise, callback, message) {
            var global      = this.global
            var Promise     = global.Promise || global.Ext && global.Ext.Promise

            if (!Promise || !(promise instanceof Promise)) return

            var me      = this

            var async   = this.beginAsync(this.defaultTimeout, function () {
                me.fail(message)
                return true
            })

            promise.then(function (value) {
                me.endAsync(async)

                callback && callback(value)
            }, function (e) {
                me.endAsync(async)

                if (e) {
                    me.failWithException(e, "Unhandled promise rejection during the test: [" + me.name + "]")

                    if (me.transparentEx && typeof console !== 'undefined') console.error(e)
                }
            })
        },


        // called before the iframe of the test is removed from DOM
        cleanup : function () {
            this.overrideForSetTimeout  = this.overrideForClearTimeout  = null
            this.originalSetTimeout     = this.originalClearTimeout     = null
            this.global                 = this._global = this.run       = null
            this.exceptionCatcher       = this.testErrorClass           = null
            this.startTestAnchor                                        = null

            this.scopeProvider          = null

            this.purgeListeners()
        },


        // a method executed after the "run" function has been ran - used in BDD role for example
        afterLaunch : function (e) {
            if (e)
                this.failWithException(e)
            else
                this.finalize()
        },


        finalize : function (force) {
            var me          = this
            var R           = Siesta.Resource('Siesta.Test');

            if (me.finalizationStarted || me.isFinished()) return

            me.processed    = true

            if (force) {
                me.clearTimeouts()

                me.eachChildTest(function (childTest) { childTest.finalize(true) })
            }

            if (!Joose.O.isEmpty(me.timeoutIds)) {
                if (
                    !me.__timeoutWarning && me.overrideSetTimeout && me.lastActivityDate &&
                    new Date() - me.lastActivityDate > me.defaultTimeout * 2
                ) {
                    me.diag(R.get('testStillRunning'));
                    me.warn(R.get('testNotFinalized', { url : me.url }));
                    me.__timeoutWarning = true;
                }

                return
            }

            try {
                // test finalization should be proteced from exceptions, otherwise the "me.callback()" wont' be called
                // and "testfinalize" event won't be fired, which will lead to "inactivity timeout" error in automation launchers
                if (!me.isDone && me.doDone(force) === false) return
            } catch (e) {
                me.fail("Exception during test finalization" + e.stack)
                typeof console !== 'undefined' && console.log("Exception during test finalization", e.stack)
            }

            me.finalizationStarted  = true

            me.fireEvent('teststop', me);

            var finalizationCodeStarted     = false

            // will be called only once
            var finalizationCode    = function (tearDownError) {
                if (finalizationCodeStarted) return

                finalizationCodeStarted     = true

                if (tearDownError) me.fail(tearDownError)

                me.doFinalize()
            }

            // sub-tests don't do the "tearDown" process
            if (me.parent || me.reusingSandbox) {
                finalizationCode()

                return
            }

            var originalSetTimeout      = me.originalSetTimeout
            var originalClearTimeout    = me.originalClearTimeout

            var timeout         = originalSetTimeout(function () {
                finalizationCode(R.get('testTearDownTimeout'))
            }, me.isReadyTimeout)

            try {
                me.tearDown(function () {
                    originalClearTimeout(timeout)

                    finalizationCode()
                }, function (error) {
                    originalClearTimeout(timeout)

                    finalizationCode(error)
                })
            } catch (e) {
                finalizationCode(e + '')
            }
        },


        doFinalize : function () {
            var me              = this

            // will be called only once
            if (me.endDate) return

            me.endDate          = new Date() - 0

            if (!me.parent) me.addResult(new Siesta.Result.Summary({
                isFailed            : me.isFailed(),
                description         : me.getSummaryMessage()
            }))

            try {
                me.onTestFinalize()
            } catch (e) {
                typeof console !== 'undefined' && console.log(e)
            }

            /**
             * This event is fired when an individual test case ends (either because it has completed correctly or thrown an exception).
             *
             * This event bubbles up to the {@link Siesta.Project project}, so you can observe it on the project as well.
             *
             * @event testfinalize
             * @member Siesta.Test
             * @param {JooseX.Observable.Event} event The event instance
             * @param {Siesta.Test} test The test instance that just has completed
             */
            me.fireEvent('testfinalize', me);

            // a test end event that bubbles
            me.fireEvent('testendbubbling', me);

            me.callback && me.callback()

            // help garbage collector to cleanup all the context of this callback (huge impact)
            me.callback         = null
        },


        onBeforeTestFinalize : function () {
        },


        onTestFinalize : function () {
        },


        onTestStart : function () {
        },


        getSummaryMessage : function (lineBreaks) {
            var res             = []

            var passCount       = this.getPassCount()
            var failCount       = this.getFailCount()
            var assertPlanned   = this.assertPlanned
            var total           = failCount + passCount

            res.push('Passed: ' + passCount)
            res.push('Failed: ' + failCount)

            if (!this.failed) {
                // there was a t.plan() call
                if (assertPlanned != null) {
                    if (total < assertPlanned)
                        res.push('Looks like you planned ' + assertPlanned + ' tests, but ran only ' + total)

                    if (total > assertPlanned)
                        res.push('Looks like you planned ' + assertPlanned + ' tests, but ran ' +  (total - assertPlanned) + ' extra tests, ' + total + ' total.')

                    if (total == assertPlanned && !failCount) res.push('All tests passed')
                } else {
                    var R = Siesta.Resource('Siesta.Test');

                    if (!this.isDoneCorrectly()) res.push(R.get('missingDoneCall'))

                    if (this.isDoneCorrectly() && !failCount) res.push(R.get('allTestsPassed'))
                }
            }

            return lineBreaks ? res.join(lineBreaks) : res
        },


        /**
         * This method indicates that the test has reached the expected point of its completion and no more assertions are planned.
         * Adding assertions after the call to `done` will be considered as a failure.
         *
         * This method **does not** stop the execution of the test. For that, see the {@link #exit} method.
         *
         * See also {@link Siesta.Project#needDone}
         *
         *
         * @param {Number} delay Optional. When provided, the test will not complete right away, but will wait for `delay` milliseconds for additional assertions.
         */
        done : function (delay) {
            var me                      = this

            if (delay) {
                var async               = this.beginAsync()
                var originalSetTimeout  = this.originalSetTimeout

                originalSetTimeout(function () {
                    me.endAsync(async)
                    me.done()
                }, delay)

            } else {
                this.doDone(false)

                if (this.processed) this.finalize()
            }
        },


        doDone : function (force) {
            var me          = this

            // this is the early "testfinalize" hook, we need "early" and "regular" hooks, since we want the globals check to be the last assertion
            // this event is basically cancellable "testfinalize"
            me.fireEvent('beforetestfinalizeearly', me)

            // Firing the `beforetestfinalizeearly` events may trigger additional test actions
            if (!Joose.O.isEmpty(me.timeoutIds)) {
                if (force)
                    me.clearTimeouts()
                else
                    return false
            }

            // assertion can stil be added in this method and the following event listeners
            // but not after!
            me.onBeforeTestFinalize()

            /**
             * This event is fired before each individual test case ends (no any corresponding Harness actions will have been run yet).
             *
             * This event bubbles up to the {@link Siesta.Project project}, so you can observe it on the project as well.
             *
             * @event beforetestfinalize
             * @member Siesta.Test
             * @param {JooseX.Observable.Event} event The event instance
             * @param {Siesta.Test} test The test instance that is about to finalize
             */
            me.fireEvent('beforetestfinalize', me);

            this.isDone     = true
        },

        // `isDoneCorrectly` means that either test does not need the call to `done`
        // or the call to `done` has been already made
        isDoneCorrectly : function () {
            return !this.needDone || this.isDone
        },


        getAssertionCount : function (excludeTodo) {
            var count   = 0

            this.eachAssertion(function (assertion) {
                if (!excludeTodo || !assertion.isTodo) count++
            })

            return count
        },


        // cached method except the "includeTodo" case
        getPassCount : function (includeTodo) {
            if (this.$passCount != null && !includeTodo) return this.$passCount

            var passCount = 0

            this.eachAssertion(function (assertion) {
                if (assertion.passed && (includeTodo || !assertion.isTodo)) passCount++
            })

            return includeTodo ? passCount : this.$passCount = passCount
        },

        getTodoPassCount : function () {
            var todoCount = 0;

            this.eachAssertion(function (assertion) {
                if (assertion.isTodo && assertion.passed) todoCount++;
            });

            return todoCount;
        },

        getTodoFailCount : function () {
            var todoCount = 0;

            this.eachAssertion(function (assertion) {
                if (assertion.isTodo && !assertion.passed) todoCount++;
            });

            return todoCount;
        },


        // cached method except the "includeTodo" case
        getFailCount : function (includeTodo) {
            if (this.$failCount != null && !includeTodo) return this.$failCount

            var failCount = 0

            this.eachAssertion(function (assertion) {
                if (!assertion.passed && (includeTodo || !assertion.isTodo)) failCount++
            })

            return includeTodo ? failCount : this.$failCount = failCount
        },


        getFailedAssertions : function () {
            var failed      = [];

            this.eachAssertion(function (assertion) {
                if (!assertion.isPassed()) failed.push(assertion)
            })

            return failed
        },


        isPassed : function () {
            var passCount       = this.getPassCount()
            var failCount       = this.getFailCount()
            var assertPlanned   = this.assertPlanned

            return this.isFinished() && (!this.failed || this.isTodo) && !failCount && (
                assertPlanned != null && passCount == assertPlanned
                    ||
                assertPlanned == null && this.isDoneCorrectly()
            )
        },


        isFailed : function () {
            var passCount       = this.getPassCount()
            var failCount       = this.getFailCount()
            var assertPlanned   = this.assertPlanned

            return this.failed || failCount || (

                this.isFinished() && (
                    assertPlanned != null && passCount != assertPlanned
                        ||
                    assertPlanned == null && !this.isDoneCorrectly()
                )
            )
        },


        isFailedWithException : function () {
            return this.failed
        },


        isStarted : function () {
            return this.startDate != null
        },


        isFinished : function () {
            return this.endDate != null
        },


        getDuration : function () {
            return this.endDate - this.startDate
        },


        getBubbleTarget : function () {
            return this.parent || this.project;
        },


        warn : function (message) {
            this.addResult(new Siesta.Result.Diagnostic({
                description : message,
                isWarning   : true
            }))
        },


        // TODO duplication with identical project method, move to a role
        flattenArray : function (array, stripEmpty) {
            var me          = this
            var result      = []

            Joose.A.each(array, function (el) {
                if (me.typeOf(el) == 'Array')
                    result.push.apply(result, me.flattenArray(el, stripEmpty))
                else
                    if (!stripEmpty || el)
                        result.push(el)
            })

            return result
        },


        trimString : function (string) {
            // "polyfill" regexp from MDN
            // Make sure we trim BOM and NBSP
            return String(string).replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '')
        },


        buildActionableMethods : function () {
            var methods     = {}

            this.meta.getMethods().each(function (method, name) {
                methods[ name.toLowerCase() ] = name
            })

            return methods
        },


        getJUnitClass : function () {
            return this.jUnitClass || this.meta.name || 'Siesta.Test'
        },


        // to give test scripts access to locales
        resource : function () {
            return Siesta.Resource.apply(Siesta.Resource, arguments)
        },


        getRootTest : function () {
            var root        = this

            while (root.parent) root = root.parent

            return root
        },


        onException : function () {
        }
    }
    // eof methods

})
//eof Siesta.Test
;
Singleton('Siesta.Test.ActionRegistry', {

    has : {
        actionClasses       : Joose.I.Object
    },


    methods : {

        registerAction : function (name, constructor) {
            this.actionClasses[ name.toLowerCase() ] = constructor
        },


        getActionClass : function (name) {
            return this.actionClasses[ name.toLowerCase() ]
        },


        create : function (obj, test, defaultArgs, initStep) {
            if (obj !== Object(obj)) throw "Action configuration should be an Object instance"

            obj     = Joose.O.copy(obj)

            if (!obj.action) {
                var actionClasses       = this.actionClasses
                var methods             = {}

                if (test) {
                    methods             = test.getActionableMethods()
                }

                Joose.O.eachOwn(obj, function (value, key) {
                    var shortcut        = key.toLowerCase()

                    if (actionClasses[ shortcut ]) {
                        obj.action      = shortcut

                        switch (shortcut) {
                            case 'setvalue' :
                            case 'waitfor'  :
                            // do nothing
                            break

                            case 'type'     :
                                obj.text        = value
                            break

                            default         :
                                obj.target      = value
                        }

                        return false
                    } else if (methods[ shortcut ]) {
                        if (shortcut.match(/^waitFor/i)) {
                            obj.action      = 'wait'
                            obj.waitFor     = methods[ shortcut ]
                            obj.args        = value || []
                        } else {
                            obj.action      = 'methodCall'
                            obj.methodName  = methods[ shortcut ]
                            obj.args        = value || []
                        }

                        return false
                    }
                })
            }

            if (!obj.action) throw "Need to include `action` property or shortcut property in the step config: " + Siesta.Util.Serializer.stringify(obj, 2)

            // Don't get the arguments from the previous step if it is a waitFor action,
            // it does not make sense and messes up the arguments
            if (obj.action != 'wait' && obj.action != 'waitfor' && obj.action != 'delay' && obj.action != 'methodCall') {
                if (!obj.args && defaultArgs) obj.args = defaultArgs
            }

            var actionClass = this.getActionClass(obj.action)

            // if there's `initStep` function - overwrite the "next" function anyway
            if (!obj.next || initStep) obj.next     = initStep(actionClass.prototype.hasOwnAsyncFrame).next
            if (!obj.test || test) obj.test     = test

            return new actionClass(obj)
        }
    }
});
;
/**
@class Siesta.Test.Action

Base class for {@link Siesta.Test#chain} actions.

*/
Class('Siesta.Test.Action', {
    
    has : {
        args                : null, 
        
        /**
         * @cfg {String} desc When provided, once step is completed, a passing assertion with this text will be added to a test.
         * This configuration option can be useful to indicate the progress of "wait" steps  
         */
        desc                : null,
        test                : { required : true },
        next                : { required : true },
        
        requiredTestMethod  : null
    },

    
    methods : {
        
        initialize : function () {
            var requiredTestMethod  = this.requiredTestMethod
            
            // additional sanity check
            if (requiredTestMethod && !this.test[ requiredTestMethod ]) 
                throw new Error(Siesta.Resource('Siesta.Test.Action','missingTestAction').replace('{0}', this.meta.name).replace('{1}', requiredTestMethod))
        },
        
        
        process : function () {
            this.next()
        }
    }
});
;
/**

@class Siesta.Test.Action.Done
@extends Siesta.Test.Action

This action can be included in the `t.chain` call with "done" shortcut:

    t.chain(
        {
            action      : 'done'
        }
    )

This action will just call the {@link Siesta.Test#done done} method of the test.

*/
Class('Siesta.Test.Action.Done', {
    
    isa         : Siesta.Test.Action,
    
    has : {
        /**
         * @cfg {Number} delay
         * 
         * An optional `delay` argument for {@link Siesta.Test#done done} call.
         */
        delay  :        null
    },

    
    methods : {
        
        process : function () {
            this.test.done(this.delay)
            
            this.next()
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('done', Siesta.Test.Action.Done);
/**

@class Siesta.Test.Action.Wait
@extends Siesta.Test.Action

This action can be included in the `t.chain` call with "wait" or "delay" shortcuts:

    t.chain(
        {
            action      : 'wait',   // or "delay"
            delay       : 1000      // 1 second
        }
    )

Alternatively, for convenience, this action can be included in the chain using "waitFor" config (the "action" property can be omitted):

    t.chain(
        {
            waitFor     : 'selector',           // or any other waitFor* method name
            args        : [ '.x-grid-row' ]     // an array of arguments for the specified method
        }
    )
    
    t.chain(
        {
            waitFor     : 'rowsVisible',        // or any other waitFor* method name
            args        : [ grid ]              // an array of arguments for the specified method
        }
    )
    
    t.chain(
        {
            waitFor     : 'waitForRowsVisible', // full method name is also ok
            args        : grid                  // a single value will be converted to array automatically
        }
    )
    
In the latter case, this action will perform a call to the one of the `waitFor*` methods of the test instance.
The name of the method is computed by prepending the uppercased value of `waitFor` config with the string "waitFor" 
(unless it doesn't already start with "waitFor").
The arguments for method call can be provided as the "args" array. Any non-array value for "args" will be converted to an array with one element.
* **Note**, that this action will provide a `callback`, `scope`, and `timeout` arguments for `waitFor*` methods - you should not specify them. 


As a special case, the value of `waitFor` config can be a Number or Function - that will trigger the call to {@link Siesta.Test#waitFor} method with provided value:

    t.chain(
        {
            waitFor     : 500
        },
        // same as
        {
            waitFor     : '',
            args        : [ 500 ] 
        },
        {
            waitFor     : function () { return document.body.className.match(/someClass/) }
        }
    )

*/
Class('Siesta.Test.Action.Wait', {
    
    isa         : Siesta.Test.Action,
    
    has : {
        /**
         * @cfg {Number} delay
         * 
         * A number of milliseconds to wait before continuing.
         */
        delay           : 1000,
        
        /**
         * @cfg {Number} timeout
         * 
         * The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value. 
         */
        timeout         : null,

        /**
         * @cfg {Number} interval
         * 
         * The interval between the checks for condition. Default value is 100ms. 
         */
        interval        : null,
        
        /**
         * @cfg {Array/Function} args
         * 
         * The array of arguments to pass to waitForXXX method. You should omit the 3 last parameters: callback, scope, timeout. Any non-array value will be converted to 
         * a single-value array. Can be also a function, returning either an array of a single value, which will be converted to array.
         * Function will be called using test instance as a "this" scope.
         * If you need to pass a function, as an argument, wrap in the array. Compare: 
    {
        waitFor : 'SomeCondition',
        // will be called when processing the action, should return an array of arguments
        args    : function () {} 
    }
    
    {
        waitFor : 'SomeCondition',
        // won't be called, instead will be passed as 1st argument
        args    : [ function () {} ] 
    }
         *  
         */
        args            : Joose.I.Array,

        /**
         * @cfg {String} waitFor
         * 
         * The name of the `waitFor` method to call. You can omit the leading "waitFor":
         * 

    t.chain(
        {
            waitFor     : 'selector',
            ...
        },
        // same as
        {
            waitFor     : 'waitForSelector',
            ...
        }
    )
         * 
         */
        waitFor         : null,
        
        
        /**
         * @cfg {Object/Function} trigger 
         * 
         * A config object for the action that should trigger the waiting condition. Can be also a regular function to execute. 
         * An action or function will be executed right *after* the waiting has started, to avoid the race conditions. 
         * 
         * To illustrate, imagine, when clicking on some button, new data package will be loaded and some event `dataloaded` 
         * will be fired. We want to wait for that event. Usually, you will write this as the following action steps, in the `chain` method:
         * 

    t.chain(
        { click : '.someButton' },
        { waitFor : 'Event', args : [ someDataStorage, 'dataload' ] },
        ...
    )

         * However, imagine loading mechanism implements caching, and sometimes loading happens *synchronously*. In this case,
         * the `dataload` event will be also fired synchronously, right during the "onclick" handler of the button. Then, we'll start
         * waiting for that event (which has already been fired) and the `waitFor` action will fail.
         * 
         * To avoid this race condition, we need to first start waiting for the event, and only then - perform a click:
         * 

    t.chain(
        function (next) {
            t.waitForEvent(someDataStorage, 'dataload', next);
            
            t.click('.someButton', function () {})
        },
        ...
    )

         * or, using `trigger` config:

    t.chain(
        { 
            waitFor : 'Event', 
            args    : [ someDataStorage, 'dataload' ],
            trigger : { click : '.someButton' } 
        },
        ...
    )

         */
        trigger         : null,

        hasOwnAsyncFrame    : true,
        description         : '' // used internally to have custom wait messages that don't produce noise in the UI (chain step automatically adds a t.pass with 'desc')
    },

    
    methods : {
        
        process : function () {
            var waitFor     = this.waitFor;
            var test        = this.test

            if (test.typeOf(waitFor) === 'Number' || test.typeOf(waitFor) === 'Function') {
                // Caller supplied a function returning true when done waiting or
                // a number of milliseconds to wait for.
                this.args   = [ waitFor ];
                waitFor     = '';
            }
            
            if (waitFor == null) {
                this.args   = [ this.delay ];
                waitFor     = '';
            }
            
            // special case for { waitForFn : function () {} }" - we consider the function here
            // not a function which should return an array with arguments for the "waitFor" method
            // (which is a usual behavior for { someMehthod : function () {} } ), but the `waitFor` checker function itself
            if (test.typeOf(this.args) === "Function" && waitFor != 'waitForFn') {
                this.args   = this.args.call(test, this);
            }
            
            if (test.typeOf(this.args) !== "Array") {
                this.args   = [ this.args ];
            }

            // also allow full method names
            waitFor         = waitFor.replace(/^waitFor/, '')
            var methodName  = 'waitFor' + Joose.S.uppercaseFirst(waitFor);
            
            if (!test[ methodName ]){
                throw Siesta.Resource("Siesta.Test.Action.Wait", 'missingMethodText') + methodName;
            }
            
            // If using simple waitFor statement, use the object notation to be able to pass a description
            // which gives better debugging help than "Waited too long for condition to be fulfilled".
            if (methodName === 'waitFor') {
                test.waitFor({
                    method          : this.args[ 0 ],
                    callback        : this.next,
                    scope           : test,
                    timeout         : this.timeout || test.waitForTimeout,
                    interval        : this.interval,
                    description     : this.description || this.desc || ''
                });
            } else {
                test[ methodName ].apply(test, this.args.concat(this.next, test, this.timeout || test.waitForTimeout));
            }
            
            var trigger     = this.trigger
            
            if (trigger) {
                if (test.typeOf(trigger) == 'Function') 
                    trigger.call(test, test)
                else {
                    if (!(trigger instanceof Siesta.Test.Action)) {
                        trigger.next        = function () {}
                        trigger.test        = this.test
                        
                        trigger             = Siesta.Test.ActionRegistry().create(trigger, test)
                    }
                    
                    trigger.process()
                }
            }
            
        }
    }
});

Joose.A.each([ 'wait', 'waitFor', 'delay' ], function(name) {
    Siesta.Test.ActionRegistry().registerAction(name, Siesta.Test.Action.Wait);
});;
/**

@class Siesta.Test.Action.Eval
@extends Siesta.Test.Action

This action can be included in the `t.chain` steps only with a plain string. Siesta will examine the passed string,
and call an apropriate method of the test class. String should have the following format: 
    
    methodName(params) 

Method name is anything until the first parenthes. Method name may have an optional prefix `t.`. 
Everything in between of outermost parentheses will be treated as parameters for method call. For example:

    t.chain(
        // string should look like a usual method call, 
        // but arguments can't reference any variables
        // strings should be quoted, to include quoting symbol in string use double slash: \\
        't.click("combo[type=some\\"Type] => .x-form-trigger")',
        
        // leading "t." is optional, but quoting is not
        'waitForComponent("combo[type=someType]")',
        
        // JSON objects are ok, but they should be a valid JSON - ie object properties should be quoted
        'myClick([ 10, 10 ], { "foo" : "bar" })',
    )
    
* **Note** You can pass the JSON objects as arguments, but they should be serialized as valid JSON - ie object properties should be quoted.
    
* **Note** A callback for next step in chain will be always appended to provided parameters. Make sure it is placed in a correct spot!
For example if method signature is `t.someMethod(param1, param2, callback)` and you are calling this method as:
    
    t.chain(
        `t.someMethod("text")`
    )
it will fail - callback will be provided in place of `param2`. Instead call it as: 
    
    t.chain(
        `t.someMethod("text", null)`
    )

This action may save you few keystrokes, when you need to perform some action with static arguments (known prior the action).

*/
Class('Siesta.Test.Action.Eval', {
    
    isa         : Siesta.Test.Action,
    
    has : {
        /**
         * @cfg {Object} options
         *
         * Any options that will be used when simulating the event. For information about possible
         * config options, please see: <https://developer.mozilla.org/en-US/docs/DOM/event.initMouseEvent>
         */
        actionString          : null
    },

    
    methods : {
        
        process : function () {
            var test            = this.test
            var parsed          = this.parseActionString(this.actionString)
            
            if (parsed.error) {
                test.fail(parsed.error)
                this.next()
                return
            }
            
            var methodName      = parsed.methodName
            
            if (!methodName || test.typeOf(test[ methodName ]) != 'Function') {
                test.fail(Siesta.Resource("Siesta.Test.Action.Eval", 'invalidMethodNameText') + methodName)
                this.next()
                return
            }
            
            parsed.params.push(this.next)
            
            test[ methodName ].apply(test, parsed.params)
        },
        
        
        parseActionString : function (actionString) {
            var match           = /^\s*(.+?)\(\s*(.*)\s*\)\s*$/.exec(actionString)
            
            if (!match) return {
                error       : Siesta.Resource("Siesta.Test.Action.Eval", 'wrongFormatText') + actionString
            }
            
            var methodName      = match[ 1 ].replace(/^t\./, '')
            
            try {
                var params      = JSON.parse('[' + match[ 2 ] + ']')
            } catch (e) {
                return {
                    error       : Siesta.Resource("Siesta.Test.Action.Eval", 'parseErrorText') + match[ 2 ]
                }
            }
            
            return {
                methodName      : methodName,
                params          : params
            }
        }
    }
});
;
/**

@class Siesta.Test.Action.MethodCall
@extends Siesta.Test.Action

This action allows you to call any method of the test class. You can add it to the `chain` method by providing a property in the config object,
which corresponds to some method of the test class. The value of this property should contain arguments for the method call (see {@link #args}).

    t.chain(
        function (next) {
            t.someMethodCall('arg1', 'arg2', next)
        },
        // or
        {
            someMethodCall  : [ 'arg1', 'arg2' ]
        },
        ...
        {
            waitForSelector : '.selector'
        }
    )
    

*/
Class('Siesta.Test.Action.MethodCall', {
    
    isa         : Siesta.Test.Action,
    
    has : {
        /**
         * @cfg {String} methodName
         *
         * A name of the method to call.
         */
        methodName      : null,
        
        /**
         * @cfg {Array/Function/Object} args
         *
         * Arguments for the method call. Usually should be an array. 
         * 
         * If its a function, then the function will be called at the action execution time and result from the 
         * action will be treated as `args`. The only exception is the "waitForFn" method, for which the supplied function
         * will be treated as the 1st argument for the "waitForFn" method. 
         * 
         * Anything else will be converted to a single element array. 
         * 
         * The callback will be added as the last argument (after resolving this config), unless the {@link #callbackIndex} is specified.
         */
        args            : null,
        
        /**
         * @cfg {Number} callbackIndex An index in the {@link #args} array where the callback should be inserted. 
         */
        callbackIndex   : null
    },

    
    methods : {
        
        process : function () {
            var test            = this.test
            var methodName      = this.methodName
            var args            = this.args
            
            if (test.typeOf(args) == 'Function') args  = args.call(test, this)
            
            if (test.typeOf(args) == 'Array') {
                args = args.slice();
            } else {
                args = [ args ]
            }
            
            if (this.callbackIndex != null) 
                args.splice(this.callbackIndex, 0, this.next)
            else
                args.push(this.next)
            
            test[ methodName ].apply(test, args)
        }
    }
});

Siesta.Test.ActionRegistry().registerAction('methodCall', Siesta.Test.Action.MethodCall)
;
Class("Siesta.Util.TreeStoreFilterer", {
    
    has : {
        idProp          : { required : true },
        childNodesProp  : { required : true },
        parentNodeProp  : { required : true },
        isLeaf          : { required : true }
    },
    
    does    : [
        Siesta.Util.Role.CanEscapeRegExp
    ],
    
    methods : {
        
        parseFilterValue : function (filterValue) {
            var parts               = filterValue.split(/\s*\>\s*/)
            
            var groupFilter         = parts.length > 1 ? parts[ 0 ] : ''
            var leafFilter          = parts.length > 1 ? parts[ 1 ] : parts[ 0 ]
            
            return {
                testFilterRegexps   : this.splitTermByPipe(leafFilter),
                groupFilterRegexps  : groupFilter ? this.splitTermByPipe(groupFilter) : null
            }
        },
        
        
        checkCommonFilter : function (node, getTitle, testFilterRegexps, groupFilterRegexps) {
            if (groupFilterRegexps) {
                var currentNode     = node
                var isInGroup       = false

                while (currentNode && currentNode[ this.parentNodeProp ]) {
                    var parent      = currentNode[ this.parentNodeProp ]

                    if (this.matchAnyOfRegExps(getTitle(parent), groupFilterRegexps)) {
                        isInGroup   = true
                        break
                    }

                    currentNode     = parent
                }

                if (!isInGroup) return false
            }

            if (this.matchAnyOfRegExps(getTitle(node), testFilterRegexps)) return true

            // if there's no name filtering testFilterRegexps - return true (show all elements)
            return !testFilterRegexps.length
        },
        
        // split term by | first, then by whitespace
        splitTermByPipe : function (term) {
            var parts           = term.split(/\s*\|\s*/);
            var regexps         = []
            var me              = this
    
            for (var i = 0; i < parts.length; i++) {
                // ignore empty
                if (parts[ i ]) {
                    regexps.push(
                        Joose.A.map(parts[ i ].split(/\s+/), function (token) {
                            return new RegExp(me.escapeRegExp(token), 'i')
                        })
                    )
                }
            }
            
            return regexps
        },
        
        
        matchAnyOfRegExps : function (string, regexps) {
            for (var p = 0; p < regexps.length; p++) {
                var groupMatch  = true
                var len         = regexps[ p ].length
    
                // blazing fast "for" loop! :)
                for (var i = 0; i < len; i++)
                    if (!regexps[ p ][ i ].test(string)) {
                        groupMatch = false
                        break
                    }
    
                if (groupMatch) return true
            }
            
            return false
        },
        

        collectNodes : function (root, params) {
            var me                      = this;
            
            var filter                  = params.filter;
            var scope                   = params.scope || this;
            var shallowScan             = params.shallow;
            var checkParents            = params.checkParents || shallowScan;
            var fullMatchingParents     = params.fullMatchingParents;
            var onlyParents             = params.onlyParents || fullMatchingParents;
    
            if (onlyParents && checkParents) throw new Error("Can't combine `onlyParents` and `checkParents` options");
            
            var idProp                  = this.idProp
            var parentNodeProp          = this.parentNodeProp
            var childNodesProp          = this.childNodesProp
            var isLeaf                  = this.isLeaf
            
            var rootVisible             = params.rootVisible
            
            var visibleNodes            = {}
    
            var includeNodeInResults    = function (node) {
                visibleNodes[ node[ idProp ] ] = true;
                
                var parent      = node[ parentNodeProp ];
    
                while (parent && !visibleNodes[ parent[ idProp ] ]) {
                    visibleNodes[ parent[ idProp ] ] = true;
    
                    parent      = parent[ parentNodeProp ];
                }
            };
            
            var cascadeNode             = function (node, func) {
                func(node)
                
                var childNodes  = node[ childNodesProp ];
                var length      = childNodes.length;
                
                // at this point nodeMatches and fullMatchingParents can't be both true
                for (var k = 0; k < length; k++) 
                    if (isLeaf(node))
                        func(node)
                    else
                        cascadeNode(childNodes[ k ], func)
            }
    
            if (rootVisible) visibleNodes[ root[ idProp ] ] = true
    
            var collectNodes    = function (node) {
                if (node.hidden) return;
    
                var nodeMatches, childNodes, length, k;
    
                // `collectNodes` should not be called for leafs at all
                if (isLeaf(node)) {
                    if (filter.call(scope, node, visibleNodes)) {
                        includeNodeInResults(node);
                    }
                } else {
                    if (onlyParents) {
                        nodeMatches     = filter.call(scope, node);
    
                        if (nodeMatches) {
                            includeNodeInResults(node);
    
                            // if "fullMatchingParents" option enabled we gather all matched parent's sub-tree
                            if (fullMatchingParents) {
                                cascadeNode(node, function (currentNode) {
                                    visibleNodes[ currentNode[ idProp ] ] = true;
                                });
    
                                return;
                            }
                        }
    
                        childNodes      = node[ childNodesProp ];
                        length          = childNodes.length;
                        
                        // at this point nodeMatches and fullMatchingParents can't be both true
                        for (k = 0; k < length; k++)
                            if (nodeMatches && isLeaf(childNodes[ k ]))
                                visibleNodes[ childNodes[ k ][ idProp ] ] = true;
                            else if (!isLeaf(childNodes[ k ]))
                                collectNodes(childNodes[ k ]);
    
                    } else {
                        // mark matching nodes to be kept in results
                        if (checkParents) {
                            nodeMatches = filter.call(scope, node, visibleNodes);
    
                            if (nodeMatches) {
                                includeNodeInResults(node);
                            }
                        }
    
                        // recurse if
                        // - we don't check parents
                        // - shallow scan is not enabled
                        // - shallow scan is enabled and parent node matches the filter or it does not, but its and invisible root, so we don't care
                        if (!checkParents || !shallowScan || shallowScan && (nodeMatches || node == root && !rootVisible)) {
                            childNodes      = node[ childNodesProp ];
                            length          = childNodes.length;
    
                            for (k = 0; k < length; k++) collectNodes(childNodes[ k ]);
                        }
                    }
                }
            };
    
            collectNodes(root);
            
            return visibleNodes
        }
    }
});
;
Role('Siesta.Util.Role.CanDetectES6', {

    has : {
        supportsArrowFunctions : function () {
            return this.canEvaluate('x => x')
        }
    },

    methods : {
        canEvaluate : function (str) {
            try {
                eval(str)
                return true
            } catch (e) {
                return false
            }
        }
    }
})
;
/**

@class Siesta.Project

`Siesta.Project` is an abstract base project class in Siesta hierarchy. This class provides no UI,
you should use one of it subclasses, for example {@link Siesta.Project.Browser} or {@link Siesta.Project.Browser.ExtJS}

This file is a reference only, for a getting start guide and manual, please refer to <a href="#!/guide/getting_started_browser">Siesta getting started in browser environment</a> guide.


Synopsys
========

    var project = new Siesta.Project.Browser.ExtJS();

    project.configure({
        title     : 'Awesome Test Suite',

        transparentEx       : true,

        autoCheckGlobals    : true,
        expectedGlobals     : [
            'Ext',
            'Sch'
        ],

        preload : [
            "http://cdn.sencha.io/ext-4.0.2a/ext-all-debug.js",
            "../awesome-project-all.js",
            {
                text    : "console.log('preload completed')"
            }
        ]
    })


    project.plan(
        // simple string - url relative to project file
        'sanity.t.js',

        // test file descriptor with own configuration options
        {
            url     : 'basic.t.js',

            // replace `preload` option of project
            preload : [
                "http://cdn.sencha.io/ext-4.0.6/ext-all-debug.js",
                "../awesome-project-all.js"
            ]
        },

        // groups ("folders") of test files (possibly with own options)
        {
            group       : 'Sanity',

            autoCheckGlobals    : false,

            items       : [
                'data/crud.t.js',
                ...
            ]
        },
        ...
    )


*/


Class('Siesta.Project', {

    does        : [
        JooseX.Observable,
        Siesta.Util.Role.CanGetType,
        Siesta.Util.Role.CanDetectES6
    ],

    has : {
        /**
         * @cfg {String} title The title of the test suite. Can contain HTML. When provided in the test file descriptor - will change the name of test in the project UI.
         */
        title               : null,

        /**
         * @cfg {String} desc The description of the test. Can contain HTML. When provided, will be shown as the tooltip in the tests grid.
         */
        desc                : null,

        /**
         * @cfg {Class} testClass The test class which will be used for creating test instances, defaults to {@link Siesta.Test}.
         * You can subclass {@link Siesta.Test} and provide a new class.
         *
         * This option can be also specified in the test file descriptor.
         */
        testClass           : Siesta.Test,
        contentManagerClass : Siesta.Content.Manager,

        // fields of test descriptor:
        // - id - either `url` or wbs + group - computed
        // - url
        // - isMissing - true if test file is missing
        // - testCode - a test code source (can be provided by user)
        // - testConfig - config object provided to the StartTest
        // - index - (in the group) computed
        // - scopeProvider
        // - scopeProviderConfig
        // - preload
        // - alsoPreload
        // - parent - parent descriptor (or project for top-most ones) - computed
        // - preset - computed by project - instance of Siesta.Content.Preset
        // - forceDOMVisible - true to show the <iframe> on top of all others when running this test
        //                     (required for IE when using "document.getElementFromPoint()")
        // OR - object
        // - group - group name
        // - items - array of test descriptors
        // - expanded - initial state of the group (true by default)
        descriptors         : Joose.I.Array,
        descriptorsById     : Joose.I.Object,

        launchCounter       : 0,

        launches            : Joose.I.Object,

        scopesByURL         : Joose.I.Object,
        testsByURL          : Joose.I.Object,

        /**
         * @cfg {Boolean} transparentEx When set to `true` project will not try to catch any exception, thrown from the test code.
         * This is very useful for debugging - you can for example use the "break on error" option in Firebug.
         * But, using this option may naturally lead to unhandled exceptions, which may leave the project in incosistent state -
         * refresh the browser page in such case.
         *
         * Defaults to `false` - project will do its best to detect any exception thrown from the test code.
         *
         * This option can be also specified in the test file descriptor.
         */
        transparentEx       : false,

        scopeProviderConfig     : null,
        scopeProvider           : null,

        /**
         * @cfg {String} runCore Either `parallel` or `sequential`. Indicates how the individual tests should be run - several at once or one-by-one.
         * Default value is "parallel". You do not need to change this option usually.
         */
        runCore                 : 'parallel',

        /**
         * @cfg {Number} maxThreads The maximum number of tests running at the same time. Only applicable for `parallel` run-core.
         */
        maxThreads              : 4,

        /**
         * @cfg {Boolean} autoCheckGlobals When set to `true`, project will automatically issue an {@link Siesta.Test#verifyGlobals} assertion at the end of each test,
         * so you won't have to manually specify it each time. The assertion will be triggered only if test completed successfully. Default value is `false`.
         * See also {@link #expectedGlobals} configuration option and {@link Siesta.Test#expectGlobals} method.
         *
         * This option will be always disabled in Opera, since every DOM element with `id` is being added as a global symbol in it.
         *
         * This option can be also specified in the test file descriptor.
         */
        autoCheckGlobals        : false,

        disableGlobalsCheck     : false,

        /**
         * @cfg {Array} expectedGlobals An array of strings or regular expressions which are likely to present in the scope of each test. There is no need to provide the name
         * of built-in globals - project will automatically scan them from the empty context. Only provide the names of global properties which will be created
         * by your preload code.
         *
         * For example
         *
    project.configure({
        title               : 'Ext Scheduler Test Suite',

        autoCheckGlobals    : true,
        expectedGlobals     : [
            'Ext',
            'MyProject',
            /jQuery\d+/, // Can use RegExp too!
        ],
        ...
    })

         * This option can be also specified in the test file descriptor.
         */
        expectedGlobals         : Joose.I.Array,
        // will be populated by `populateCleanScopeGlobals`
        cleanScopeGlobals       : Joose.I.Array,

        /**
         * @cfg {Array} preload
         *
         * The array which contains the *preload descriptors* describing which files/code should be preloaded into the scope of each test.
         *
         * Preload descriptor can be:
         *
         * - a string, containing an url to load (cross-domain urls are ok, if url ends with ".css" it will be loaded as CSS)
         * - an object `{ type : 'css/js', url : '...' }` allowing to specify the CSS files with different extension
         * - an object `{ type : 'css/js', content : '...' }` allowing to specify the inline content for script / style. The content should only be the tag content - not the tag itself, it'll be created by Siesta.
         * - an object `{ text : '...' }` which is a shortcut for `{ type : 'js', content : '...' }`
         *
         * `preload` array can contain other nested arrays which will be flattened recursively. Any "empty" values
         * (like `null`, empty string, false etc) will be ignored.
         *
         * For example:
         *
    project.configure({
        title           : 'Ext Scheduler Test Suite',

        preload         : [
            'http://cdn.sencha.io/ext-4.0.2a/resources/css/ext-all.css',
            'http://cdn.sencha.io/ext-4.0.2a/ext-all-debug.js',
            {
                text    : 'MySpecialGlobalFunc = function () { if (typeof console != "undefined") ... }'
            },
            // simple conditional preload
            someCondition ?
                [
                    'http://mydomain.com/file.css',
                    'http://mydomain.com/file.js'
                ]
            :
                null
        ],
        ...
    })

         * This option can be also specified in the test file descriptor. **Note**, that if test descriptor has non-empty
         * {@link Siesta.Project.Browser#pageUrl pageUrl} option, then *it will not inherit* the `preload` option
         * from parent descriptors or project, **unless** it has the `preload` config set to string `inherit`.
         * If both `pageUrl` and `preload` are set on the project level, `preload` value still will be inherited. For example:
         *
    project.configure({
        pageUrl         : 'general-page.html',
        preload         : [ 'my-file.js' ],
        ...
    })

    project.plan(
        // this test will inherit both `pageUrl` and `preload`
        'test1.js',
        {
            // no preloads inherited
            pageUrl     : 'host-page.html',
            url         : 'test2.js'
        },
        {
            // inherit `preload` value from the upper level - [ 'my-file.js' ]
            pageUrl     : 'host-page.html',
            preload     : 'inherit',
            url         : 'test3.js'
        },
        {
            group       : 'Some group',
            pageUrl     : 'host-page2.html',
            preload     : 'inherit',

            items           : [
                {
                    // inherit `pageUrl` value from the group
                    // inherit `preload` value from the upper level - [ 'my-file.js' ]
                    url     : 'test3.js'
                }
            ]
        }
    )

         * When loading ES6 modules, one need to indicate this using the `isEcmaModule` property of the preload descriptor.
         * In this case, the module `<script>` tag will be created with the `type` attribute set to `module`, instead of `text/javascript`.
         *

    project.configure({
        preload         : [
            {
                type            : 'js',
                url             : 'some_file.js',
                isEcmaModule    : true
            },
            {
                type            : 'js',
                content         : 'import {something} from "another/module.js"',
                isEcmaModule    : true
            }

        ],
        ...
    })

         *
         *
         */
        preload                 : Joose.I.Array,

        /**
         * @cfg {Array} alsoPreload The array with preload descriptors describing which files/code should be preloaded **additionally**.
         *
         * This option can be also specified in the test file descriptor.
         */

        /**
         * @cfg {Object} listeners The object which keys corresponds to event names and values - to event handlers. If provided, the special key "scope" will be treated as the
         * scope for all event handlers, otherwise the project itself will be used as scope.
         *
         * Note, that the events from individual {@link Siesta.Test test cases} instances will bubble up to the project - you can listen to all of them in one place:
         *

    project.configure({
        title     : 'Awesome Test Suite',

        preload : [
            'http://cdn.sencha.io/ext-4.1.0-gpl/resources/css/ext-all.css',
            'http://cdn.sencha.io/ext-4.1.0-gpl/ext-all-debug.js',

            'preload.js'
        ],

        listeners : {
            testsuitestart      : function (event, project) {
                log('Test suite is starting: ' + project.title)
            },
            testsuiteend        : function (event, project) {
                log('Test suite is finishing: ' + project.title)
            },
            teststart           : function (event, test) {
                log('Test case is starting: ' + test.url)
            },
            testupdate          : function (event, test, result) {
                log('Test case [' + test.url + '] has been updated: ' + result.description + (result.annotation ? ', ' + result.annotation : ''))
            },
            testfailedwithexception : function (event, test) {
                log('Test case [' + test.url + '] has failed with exception: ' + test.failedException)
            },
            testfinalize        : function (event, test) {
                log('Test case [' + test.url + '] has completed')
            }
        }
    })

         */


        /**
         * @cfg {Boolean} cachePreload When set to `true`, project will cache the content of the preload files and provide it for each test, instead of loading it
         * from network each time. This option may give a slight speedup in tests execution (especially when running the suite from the remote server), but see the
         * caveats below. Default value is `false`.
         *
         * Caveats: this option doesn't work very well for CSS (due to broken relative urls for images). Also its not "debugging-friendly" - as you will not be able
         * to setup breakpoints for cached code.
         */
        cachePreload            : false,

        mainPreset              : null,
        emptyPreset             : null,

        /**
         * @cfg {Number} keepNLastResults
         *
         * Indicates the number of the test results which still should be kept, for user examination.
         * Results are cleared when their total number exceed this value, based on FIFO order.
         */
        keepNLastResults        : 2,

        lastResultsURLs         : Joose.I.Array,
        lastResultsByURL        : Joose.I.Object,

        /**
         * @cfg {Boolean} breakOnFail When set to `true`, the project will not start launching any further tests after
         * detecting a failed assertion. When running in automation mode, test suite will be finalized immediately,
         * ignoring the --rerun-failed option.
         *
         * Default value is `false`.
         */
        breakOnFail             : false,

        /**
         * @cfg {Boolean} overrideSetTimeout When set to `true`, the tests will override the native "setTimeout" from the context of each test
         * for asynchronous code tracking. If setting it to `false`, you will need to use `beginAsync/endAsync` calls to indicate that test is still running.
         *
         * Note, that this option may not work reliably, when used for several sub tests launched simultaneously (for example
         * for several sibling {@link Siesta.Test#todo} sections.
         *
         * This option can be also specified in the test file descriptor. Defaults to `false`.
         */
        overrideSetTimeout      : false,

        /**
         * @cfg {Boolean} needDone When set to `true`, the tests will must indicate that that they have reached the correct
         * exit point with `t.done()` call, after which, adding any assertions is not allowed.
         * Using this option will ensure that test did not exit prematurely with some exception silently caught.
         *
         * This option can be also specified in the test file descriptor.
         */
        needDone                : false,

        // the default timeout for tests will be increased when launching more than this number of files
        increaseTimeoutThreshold    : 8,

        // the start and end dates for the most recent `launch` method
        startDate               : null,
        endDate                 : null,

        /**
         * @cfg {Number} waitForTimeout Default timeout for `waitFor` (in milliseconds). Default value is 10000.
         *
         * This option can be also specified in the test file descriptor.
         */
        waitForTimeout          : 10000,

        /**
         * @cfg {Number} defaultTimeout Default timeout for `beginAsync` operation (in milliseconds). Default value is 15000.
         *
         * This option can be also specified in the test file descriptor.
         */
        defaultTimeout          : 15000,

        /**
         * @cfg {Number} subTestTimeout Default timeout for sub tests. Default value is twice bigger than {@link #defaultTimeout}.
         *
         * This option can be also specified in the test file descriptor.
         */
        subTestTimeout          : null,

        /**
         * @cfg {Number} isReadyTimeout Default timeout for test start (in milliseconds). Default value is 15000. See {@link Siesta.Test#isReady} for details.
         *
         * This option can be also specified in the test file descriptor.
         */
        isReadyTimeout          : 10000,

        /**
         * @cfg {Number} pauseBetweenTests Default timeout between tests (in milliseconds). Increase this settings for big test suites, to give browser time for memory cleanup.
         */
        pauseBetweenTests       : 10,


        /**
         * @cfg {Boolean} failOnExclusiveSpecsWhenAutomated When this option is enabled and Siesta is running in automation mode
         * (using WebDriver or Puppeteer launcher) any exclusive BDD specs found (like {@link Siesta.Test#iit t.iit} or {@link Siesta.Test#ddescribe t.ddescribe}
         * will cause a failing assertion. The idea behind this setting is that such "exclusive" specs should only be used during debugging
         * and are often mistakenly committed in the codebase, leaving other specs not executed.
         *
         * This option can be also specified in the test file descriptor.
         */
        failOnExclusiveSpecsWhenAutomated   : false,

        /**
         * @cfg {Date/String} snooze
         *
         * Either a `Date` instance or a string, recognized by the [Date constructor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse).
         *
         * If test is running prior the specified date, the whole test will be made a "todo". See the {@link Siesta.Test#snooze} method.
         *
         * Example:
         *

    project.plan(
        {
            group       : 'Some group',

            snooze      : '2016-10-11',

            items           : [
                ...
            ]
        }
    )

         *
         * This option can be also specified in the test file descriptor.
         */
        snooze                      : null,


        /**
         * @cfg {String} referenceUrl
         *
         * The url, containing additional information about the test. This option is inherited from the group configs,
         * as other options. In the Siesta user interface, `CTRL+click` on the
         * test row will open a new browser window, pointing to this url. Can be used to link the test with some external
         * resource like ticket, screenshot, etc.

    project.plan(
         {
             url                : 'my_test.t.js',
             referenceUrl       : 'http://jira.com/jira_issue'
         }
    )
         * This option can be also specified in the test file descriptor.
         */
        referenceUrl                : null,


        /**
         * @cfg {Boolean} suppressPassedWaitForAssertion
         *
         * When enabled, the passed "waitFor" assertions won't be included in the tests.
         *
         * This option can be also specified in the test file descriptor.
         */
        suppressPassedWaitForAssertion  : false,

        /**
         * @cfg {Boolean} isEcmaModule
         *
         * This option can be specified in the test file descriptor and/or as the global project config. In the latter case it will affect all tests.
         *
         * When enabled, the test script file (the one containing the `StartTest()` function) will be loaded using
         * `<script type="module">` instead of `<script type="text/javascript">`
         *
         * See also a note in the {@link Siesta.Project#preload preload} config.
         */
        isEcmaModule                : null,


        setupDone                   : false,

        sourceLineForAllAssertions  : false,

        currentLaunchId             : null,

        isAutomated                 : false,
        autoLaunchTests             : true,

        configSynonyms              : function () { return this.processConfigSynonyms(this.buildConfigSynonyms()) },

        uniqueCounter                   : 0,
        valueToHashIndicies             : Joose.I.Object,

        // lazy attribute, should be accessed with "getSandboxHashStructure" method
        sandboxHashStructure            : {
            lazy    : 'this.buildSandboxHashStructure'
        },


        /**
         * @cfg {Boolean} sandbox
         *
         * This option controls whether the individual tests should be run in isolation from each other. By default it is enabled,
         * and every test file will be run inside of the newly created iframe (or in the separate Node.js process), so that it can not interfere with
         * any other test. Such setup gives you predictable starting state for every test, removes the need for any kind of
         * cleanup at the end of the test and is more robust in general.
         *
         * However, the setup of the new sandbox creates some overhead. If you are sure that your tests
         * do not modify any global state (like global variable that can affect the other test) you may want to run
         * all of them in the same context, saving the setup time. In this case, you may want to disable this option.
         *
         * Siesta collects all tests with this option disabled and split them into chunks. Every chunk will have exactly
         * the same values for the configs that influence the initial setup of the page: {@link #preload}, {@link #alsoPreload},
         * {@link #pageUrl}, {@link Siesta.Test.ExtJS#requires} and some others. The tests inside of every
         * chunk will be run sequentially, in the same sandbox.
         *
         * **Important**: The 1st test in every chunk will be run normally. Starting from the 2nd one, tests
         * will skip the {@link Siesta.Test#isReady} check and {@link Siesta.Test#setup} methods. This is because all the
         * setup is supposed to be already done by the 1st test. This behavior may change (or made configurable) in the future.
         *
         * This option can be specified in the test file descriptor.
         *
         * See also {@link #sandboxBoundaryByGroup}, {@link #sandboxCleanup}
         */
        sandbox                         : true,

        /**
         * @cfg {Boolean} sandboxBoundaryByGroup
         *
         * Only applicable for tests with the {@link #sandbox} option *disabled*.
         *
         * when this option is enabled, the tests to be run in the same context will be guaranteed to reside in the same group.
         * If a new test group starts (even with the same "preload" config) - a fresh context for that group will be created
         * by Siesta.
         *
         * For example, in the following setup, both "Group 1" and "Group 2" have sandboxing disabled and the
         * same "preload" config. If `sandboxBoundaryByGroup` will be disabled all 4 individual tests will be run
         * in the same context. If `sandboxBoundaryByGroup` will be enabled, separate fresh context will be created
         * for the tests from each group.
         *

    project.configure({
        preload     : [ ... ]
    });

    project.plan(
        {
            group       : 'Group 1',
            sandbox     : false,
            items       : [
                '010-basics/010_sanity.t.js',
                '010-basics/020_jshint.t.js'
            ]
        },
        {
            group       : 'Group 2',
            sandbox     : false,
            items       : [
                '020-basics/010_sanity.t.js',
                '020-basics/030_bdd.t.js'
            ]
        },
        ...
    )

         *
         */
        sandboxBoundaryByGroup          : true,


        /**
         * @cfg {Boolean} sandboxCleanup
         *
         * Only applicable for tests with the {@link #sandbox} option *disabled*. When enabled, test that runs
         * in shared sandbox (the sandbox in which another test just has been run) will perform a cleanup.
         *
         * By default it will remove any "unexpected" globals (see {@link #expectedGlobals}) and clear the DOM.
         *
         * If you will disable this option, every new test in the "groups" will start from the state previous test
         * has finished the execution. This will allow you split one big test scenario into several files
         *
         * This option can be specified in the test file descriptor.
         */
        sandboxCleanup                  : true,


        /**
         * @cfg {Boolean} debuggerOnFail When set to `true`, the project will issue a `debugger` statement after detecting a failed assertion, allowing you
         * to inspect the internal state of the test in the browser's debugger. Default value is `false`.
         */
        debuggerOnFail                  : false,


        /**
         * @cfg {Boolean} debuggerOnStart When set to `true`, the project will issue a `debugger` statement before launching any test. Default value is `false`.
         */
        debuggerOnStart                 : false
    },


    methods : {

        initialize : function () {
            var me      = this

            me.on('testupdate', function (event, test, result, parentResult) {
                me.onTestUpdate(test, result, parentResult);
            })

            me.on('testfailedwithexception', function (event, test, exception, stack) {
                me.onTestFail(test, exception, stack);
            })

            me.on('teststart', function (event, test) {
                me.onTestStart(test);
            })

            me.on('testfinalize', function (event, test) {
                me.onTestEnd(test);
            })
        },


        buildConfigSynonyms : function () {
            return {}
        },


        // creates a reference from every synonym to a full list of synonyms, including the main name itself
        // { 'main' : [ 'main', 'syn1', 'syn2' ], 'syn1' : [ 'main', 'syn1', 'syn2' ], 'syn2' : [ 'main', 'syn1', 'syn2' ] }
        processConfigSynonyms : function (synonyms) {
            var result      = {}

            Joose.O.each(synonyms, function (synonymsList, mainName) {
                if (synonymsList instanceof Array)
                    synonymsList.unshift(mainName)
                else
                    synonymsList = [ mainName, synonymsList ]

                Joose.A.each(synonymsList, function (synonym) {
                    result[ synonym ] = synonymsList
                })
            })

            return result
        },


        onTestUpdate : function (test, result, parentResult) {
        },


        onTestFail : function (test, exception, stack) {
        },


        onTestStart : function (test) {
        },


        onTestEnd : function (test) {
        },


        onTestSuiteStart : function (descriptors, contentManager, launchState) {
            this.startDate  = new Date()

            /**
             * This event is fired when the test suite starts. Note, that when running the test suite in the browser, this event can be fired several times
             * (for each group of tests you've launched).
             *
             * You can subscribe to it, using regular ExtJS syntax:
             *
             *      project.on('testsuitestart', function (event, project) {}, scope, { single : true })
             *
             * See also the "/examples/events"
             *
             * @event testsuitestart
             * @member Siesta.Project
             * @param {JooseX.Observable.Event} event The event instance
             * @param {Siesta.Project} project The project that just has started
             */
            this.fireEvent('testsuitestart', this, launchState)
        },


        onTestSuiteEnd : function (descriptors, contentManager, launchState) {
            this.endDate    = new Date()

            /**
             * This event is fired when the test suite ends. Note, that when running the test suite in the browser, this event can be fired several times
             * (for each group of tests you've launched).
             *
             * @event testsuiteend
             * @member Siesta.Project
             * @param {JooseX.Observable.Event} event The event instance
             * @param {Siesta.Project} project The project that just has ended
             */
            this.fireEvent('testsuiteend', this, launchState)
        },


        onBeforeScopePreload : function (scopeProvider, url) {
            this.fireEvent('beforescopepreload', scopeProvider, url)
        },


        onAfterScopePreload : function (scopeProvider, url) {
            this.fireEvent('afterscopepreload', scopeProvider, url)
        },


        onCachingError : function (descriptors, contentManager) {
        },


        /**
         * This method configures the project instance. It just copies the passed configuration option into project instance.
         *
         * @param {Object} config - configuration options (values of attributes for this class)
         */
        configure : function (config) {
            Joose.O.copy(config, this)

            var me      = this

            if (config.listeners) Joose.O.each(config.listeners, function (value, name) {
                if (name == 'scope') return

                me.on(name, value, config.scope || me)
            })
        },


        // backward compat
        processPreloadArray : function (preload) {
            var me      = this

            preload     = this.flattenArray(preload, true)

            Joose.A.each(preload, function (obj, index) {
                // do not process { text : "" } preload descriptors
                if (Object(obj) === obj) {
                    if (obj.url) obj.url    = me.normalizeURL(obj.url)
                } else
                    preload[ index ]        = me.normalizeURL(obj)
            })

            return preload
        },


        populateCleanScopeGlobals : function (scopeProvider, callback) {
            var scopeProviderClass  = eval(scopeProvider)
            var cleanScope          = new scopeProviderClass()

            var cleanScopeGlobals   = this.cleanScopeGlobals

            // we can also use "create" and not "setup" here
            // create will only create the iframe (in browsers) and will not try to update its content
            // the latter crashes IE8
            cleanScope.setup(function () {

                for (var name in cleanScope.scope) cleanScopeGlobals.push(name)

                callback()

                // this setTimeout seems to stop the spinning loading indicator in FF
                // accorting to https://github.com/3rd-Eden/Socket.IO/commit/bad600fb1fb70238f42767c56f01256470fa3c15
                // it only works *after* onload (this callback will be called *in* onload)

                setTimeout(function () {
                    // will remove the iframe (in case of browser project) from DOM and stop loading indicator
                    cleanScope.cleanup()
                }, 0)
            })
        },


        startSingle : function (desc, callback) {
            var me              = this

            this.__counter__    = this.__counter__ || 0

            var startSingle     = function () {
                me.launch([ me.normalizeDescriptor(desc, me, me.__counter__++) ], callback)
            }

            me.setupDone ? startSingle() : this.setup(startSingle)
        },


        setup : function (callback) {
            var me              = this

            this.mainPreset     = new Siesta.Content.Preset({
                preload     : this.processPreloadArray(this.preload)
            })

            this.emptyPreset    = new Siesta.Content.Preset()

            // A system level descriptor used by the recorder
            me.descriptors.push({
                isSystemDescriptor  : true,
                url                 : '/'
            });

            me.normalizeDescriptors(me.descriptors)

            this.populateCleanScopeGlobals(this.scopeProvider, callback)
        },


        /**
         * This method adds *test file descriptors* (test files), to the project. It can be called several times.
         *
         * A test file descritor is one of the following:
         *
         * - a string, containing a test file url. The url should be unique among all tests. If you need to re-use the same test
         * file, you can add an arbitrary query string to it: `my_test.t.js?copy=1`
         * - an object containing the `url` property `{ url : '...', option1 : 'value1', option2 : 'value2' }`. The `url` property should point to the test file.
         * Other properties can contain values of some configuration options of the project (marked accordingly). In this case, they will **override** the corresponding values,
         * provided to project or parent descriptor.
         * - an object `{ group : 'groupName', items : [], expanded : true, option1 : 'value1' }` specifying the folder of test files. The `expanded` property
         * sets the initial state of the folder - "collapsed/expanded". The `items` property can contain an array of test file descriptors.
         * Other properties will override the applicable project options **for all child descriptors**.
         *
         * If test descriptor is `null` or other "falsy" value it is ignored.
         *
         * Groups (folder) may contain nested groups. Number of nesting levels is not limited.
         *
         * For example, one may easily have a special group of test files, having its own `preload` configuration (for example for testing on-demand loading). In the same
         * time some test in that group may have its own preload, overriding others.

    project.configure({
        title           : 'Ext Scheduler Test Suite',
        preload         : [
            'http://cdn.sencha.io/ext-4.0.2a/resources/css/ext-all.css',
            'http://cdn.sencha.io/ext-4.0.2a/ext-all-debug.js',
            '../awesome-app-all-debug.js'
        ],
        ...
    })

    project.plan(
        // regular file
        'data/crud.t.js',
        // a group with own "preload" config for its items
        {
            group       : 'On-demand loading',

            preload     : [
                'http://cdn.sencha.io/ext-4.0.2a/resources/css/ext-all.css',
                'http://cdn.sencha.io/ext-4.0.2a/ext-all-debug.js',
            ],
            items       : [
                'ondemand/sanity.t.js',
                'ondemand/special-test.t.js',
                // a test descriptor with its own "preload" config (have the most priority)
                {
                    url         : 'ondemand/4-0-6-compat.t.js',
                    preload     : [
                        'http://cdn.sencha.io/ext-4.0.6/resources/css/ext-all.css',
                        'http://cdn.sencha.io/ext-4.0.6/ext-all-debug.js',
                    ]
                },
                // sub-group
                {
                    group       : 'Sub-group',
                    items       : [
                        ...
                    ]
                }
            ]
        },
        ...
    )

         * Additionally, you can provide a test descriptor in the test file itself, adding it as the 1st or 2nd argument for `StartTest` call:
         *
    StartTest({
        autoCheckGlobals    : false,
        alsoPreload         : [ 'some_additional_preload.js' ]
    }, function (t) {
        ...
    })
         *
         * Values from this object takes the highest priority and will override any other configuration.
         *
         * Test descriptor may contain special property - `config` which will be applied to the test instance created. Be careful not to overwrite
         * standard properties and methods!
         *

    project.plan(
        {
            url         : 'ondemand/4-0-6-compat.t.js',
            config      : {
                myProperty1     : 'value1',
                myProperty2     : 'value2'
            }
        },
        ...
    )

    StartTest(function (t) {
        if (t.myProperty1 == 'value1') {
            // do this
        }
        ...
    })

         *
         * @param {Array/Mixed} descriptor1 or an array of descriptors
         * @param {Mixed} descriptor2
         * @param {Mixed} descriptorN
         */
        plan : function () {
            var descriptors     = this.flattenArray(arguments)

            // A system level descriptor used by the recorder
            this.descriptors.push.apply(this.descriptors, descriptors)
        },


        /**
         * This method will launch a test suite.
         *
         * For backward compatibility, it also calls {@link #plan} with its arguments.
         */
        start : function () {
            var me          = Siesta.my.activeHarness = this

            me.plan(this.flattenArray(arguments))

            this.setup(function () {
                me.setupDone        = true

                me.fireEvent('setupdone')

                if (me.autoLaunchTests) me.launch(me.descriptors)
            })
        },


        /**
         * This method will read the content of the provided `url` then will try to parse it as JSON
         * and pass to the regular {@link #start} method. The file on the `url` should contain
         * a valid JSON array object with test descriptors.
         *
         * You can use this method in conjunction with the `bin/discover` utility, which can
         * auto-discover the test files and generate a starter file for you. In such setup, it is convenient
         * to specify the test configs in the test file itself (see {@link #start} method for details).
         * However, in such setup, you can not use conditional processing of the descriptors set, so
         * you decide what fits best to your needs.
         *
         * @param {String} url
         */
        startFromUrl : function (url) {
            var contentManager  = new this.contentManagerClass({
                project         : this,
                presets         : [  new Siesta.Content.Preset({ preload : [ url ] }) ]
            })

            var me      = this

            contentManager.cache(function () {
                var content     = contentManager.getContentOf(url)

                try {
                    var descriptors     = JSON.parse(content)
                } catch (e) {
                    alert("The content of: " + url + " is not a valid JSON")
                    return
                }

                if (me.typeOf(descriptors) == 'Array')
                    me.start(descriptors)
                else {
                    alert("The content of: " + url + " is not an array")
                }

            }, function () {
                alert("Can not load the content of: " + url)
            })
        },


        // good to have this as a separate method for testing
        normalizeDescriptors : function (descArray) {
            var me              = this

            var descriptors     = []

            Joose.A.each(descArray, function (desc, index) {
                if (desc) descriptors.push(me.normalizeDescriptor(desc, me, index))
            })

            me.descriptors      = descriptors
        },


        launch : function (descriptors, callback, errback) {
            var launchId                = this.currentLaunchId  = ++this.launchCounter
            var me                      = this

            //console.time('launch')
            //console.time('launch-till-preload')
            //console.time('launch-after-preload')

            // no folders, only leafs
            var flattenDescriptors      = this.flattenDescriptors(descriptors)
            // the preset for the test scripts files
            var testScriptsPreset       = new Siesta.Content.Preset()
            var presets                 = [ testScriptsPreset, this.mainPreset ]

            var notLaunchedByAutomationId   = {}

            Joose.A.each(flattenDescriptors, function (desc) {
                if (desc.preset != me.mainPreset && desc.preset != me.emptyPreset) presets.push(desc.preset)

                if (!desc.testCode) testScriptsPreset.addResource(desc.url)

                me.deleteTestByURL(desc.url)

                // only used in automation, where the `desc.automationElementId` is populated
                notLaunchedByAutomationId[ desc.automationElementId ] = 1
            })

            // cache either everything (this.cachePreload) or only the test files (to be able to show missing files / show content)
            var contentManager  = new this.contentManagerClass({
                project         : this,
                presets         : [ testScriptsPreset ].concat(this.cachePreload ? presets : [])
            })

            var launchState     = this.launches[ launchId ] = {
                launchId            : launchId,
                increaseTimeout     : this.runCore == 'parallel' && flattenDescriptors.length > this.increaseTimeoutThreshold,
                descriptors         : flattenDescriptors,
                contentManager      : contentManager,
                needToStop          : false,
                notLaunchedByAutomationId   : notLaunchedByAutomationId
            }

            //console.time('caching')

            me.onTestSuiteStart(descriptors, contentManager, launchState)

            contentManager.cache(function () {

                //console.timeEnd('caching')

                Joose.A.each(flattenDescriptors, function (desc) {
                    var url             = desc.url

                    if (contentManager.hasContentOf(url)) {
                        // the test descriptor defined in the test file itself, takes the highest precendence
                        var testConfig  = desc.testConfig = Siesta.getConfigForTestScript(contentManager.getContentOf(url))

                        // if testConfig contains the "preload" or "alsoPreload" key - then we need to update the preset of the descriptor
                        if (testConfig && (testConfig.preload || testConfig.alsoPreload)) desc.preset = me.getDescriptorPreset(desc)
                    } else
                        // if test code is provided, then test is considered not missing
                        // allow subclasses to define there own logic when found missing test file
                        if (!desc.testCode) me.markMissingFile(desc)

                    me.normalizeScopeProvider(desc)
                })

                me.fireEvent('testsuitelaunch', descriptors, contentManager, launchState)

                me.runCoreGeneral(flattenDescriptors, contentManager, launchState, launchState.callback = function () {
                    me.onTestSuiteEnd(descriptors, contentManager, launchState)

                    callback && callback(descriptors)

                    launchState.needToStop  = true

                    delete me.launches[ launchId ]
                })

            }, function () {}, true)
        },


        markMissingFile : function (desc) {
            desc.isMissing = true
        },


        flattenDescriptors : function (descriptors, includeFolders) {
            var flatten     = []
            var me          = this

            Joose.A.each(descriptors, function (descriptor) {
                if (descriptor.group) {
                    if (includeFolders) flatten.push(descriptor)

                    flatten.push.apply(flatten, me.flattenDescriptors(descriptor.items, includeFolders))
                } else
                    if (!descriptor.isSystemDescriptor) flatten.push(descriptor)
            })

            return flatten
        },


        forEachDescriptor : function (descriptors, includeFolders, func, scope) {
            var me          = this

            return Joose.A.each(descriptors, function (descriptor) {
                if (descriptor.group) {
                    if (includeFolders)
                        if (func.call(scope || me, descriptor) === false) return false

                    return me.forEachDescriptor(descriptor.items, includeFolders, func, scope)
                } else
                    if (!descriptor.isSystemDescriptor)
                        if (func.call(scope || me, descriptor) === false) return false
            })
        },


        lookUpValueInDescriptorTree : function (descriptor, configName, doNotLookAtRoot) {
            if (this.descriptorHasOwnValueFor(descriptor, configName)) return this.getConfigValueFromDescriptor(descriptor, configName)

            var parent  = descriptor.parent

            if (parent) {
                if (parent == this)
                    if (doNotLookAtRoot)
                        return undefined
                    else
                        // using project instance itself as a descriptor - a bit hackish because of the "testConfig" property,
                        // which is being checked first
                        return this.getConfigValueFromDescriptor(this, configName)

                return this.lookUpValueInDescriptorTree(parent, configName, doNotLookAtRoot)
            }

            return undefined
        },


        descriptorHasOwnValueFor : function (descriptor, configName) {
            // the test descriptor, defined in the test file (as the 1st arg to StartTest)
            // takes the highest priority
            var testConfig          = descriptor.testConfig

            // "fast" branch
            if (testConfig && testConfig.hasOwnProperty(configName) || descriptor.hasOwnProperty(configName)) return true

            var synonymList         = this.configSynonyms[ configName ]

            var result              = false

            // now checking synonims
            if (synonymList) Joose.A.each(synonymList, function (synonym) {
                // already checked above
                if (synonym != configName) {
                    if (testConfig && testConfig.hasOwnProperty(synonym) || descriptor.hasOwnProperty(synonym)) {
                        result      = true
                        return false
                    }
                }
            })

            return result
        },


        getConfigValueFromDescriptor : function (descriptor, configName, allowInherited) {
            if (descriptor == this) {
                var synonymList         = this.configSynonyms[ configName ] || [ configName ]

                var result, foundOwnValue

                Joose.A.each(synonymList, function (synonym) {
                    if (descriptor.hasOwnProperty(synonym)) {
                        result          = descriptor[ synonym ]
                        foundOwnValue   = true
                        return false
                    }
                })

                return foundOwnValue ? result : this[ configName ]
            } else {
                var testConfig          = descriptor.testConfig

                // "fast" branch
                if (testConfig && testConfig.hasOwnProperty(configName)) return testConfig[ configName ]
                if (descriptor.hasOwnProperty(configName)) return descriptor[ configName ]

                var synonymList         = this.configSynonyms[ configName ]

                var result

                // now checking synonims
                if (synonymList) Joose.A.each(synonymList, function (synonym) {
                    // already checked above
                    if (synonym != configName) {
                        if (testConfig && testConfig.hasOwnProperty(synonym) || descriptor.hasOwnProperty(synonym)) {
                            result      = testConfig && testConfig.hasOwnProperty(synonym) ? testConfig[ synonym ] : descriptor[ synonym ]
                            return false
                        }
                    }
                })

                return result
            }
        },


        getDescriptorConfig : function (descriptor, configName, doNotLookAtRoot) {
            return this.lookUpValueInDescriptorTree(descriptor, configName, doNotLookAtRoot)
        },


        getDescriptorPreset : function (desc) {
            var preload                 = this.getDescriptorConfig(desc, 'preload', true)
            var alsoPreload             = this.getDescriptorConfig(desc, 'alsoPreload', true)

            if (preload || alsoPreload) {
                var totalPreload        = (preload || this.preload || []).concat(alsoPreload || [])

                // filter out empty array as preloads - return `emptyPreset` for them
                return totalPreload.length ? new Siesta.Content.Preset({ preload : this.processPreloadArray(totalPreload) }) : this.emptyPreset
            }

            return this.mainPreset
        },


        normalizeScopeProvider : function (desc) {
            var scopeProvider = this.getDescriptorConfig(desc, 'scopeProvider')

            if (scopeProvider) {
                var match

                if (match = /^=(.+)/.exec(scopeProvider))
                    scopeProvider = match[ 1 ]
                else
                    scopeProvider = scopeProvider.replace(/^(Scope\.Provider\.)?/, 'Scope.Provider.')
            }

            desc.scopeProvider          = scopeProvider
            desc.scopeProviderConfig    = this.getDescriptorConfig(desc, 'scopeProviderConfig')
        },


        normalizeDescriptor : function (desc, parent, index, level) {
            if (desc.normalized) return desc

            if (typeof desc == 'string') desc = { url : desc }

            level       = level || 0

            var me      = this

            desc.parent = parent

            // folder
            if (desc.group) {
                desc.id     = parent == this ? 'testFolder-' + level + '-' + index : parent.id + '/' + level + '-' + index

                var items   = []

                Joose.A.each(desc.items || [], function (subDesc, index) {
                    if (subDesc) items.push(me.normalizeDescriptor(subDesc, desc, index, level + 1))
                })

                desc.items  = items

            } else {
                // leaf case
                desc.id                     = desc.url
                desc.preset                 = this.getDescriptorPreset(desc)

                desc.name                   = desc.name || desc.url.replace(/(?:.*\/)?([^/]+)$/, '$1')

                // the only thing left to normalize in the descriptor is now "scopeProvider"
                // we postpone this normalization to the moment after loading of the test files,
                // since they can also contain "scopeProvider"-related configs
                // see "normalizeScopeProvider"
            }

            this.descriptorsById[ desc.id ] = desc

            desc.normalized     = true

            return desc
        },


        runCoreGeneral : function (descriptors, contentManager, launchState, callback) {
            var runCoreMethod   = 'runCore' + Joose.S.uppercaseFirst(this.runCore)

            if (typeof this[ runCoreMethod ] != 'function') throw new Error("Invalid `runCore` specified: [" + this.runCore + "]")

            this[ runCoreMethod ](descriptors, contentManager, launchState, callback)
        },


        runCoreParallel : function (descriptors, contentManager, launchState, callback) {
            var me              = this
            var processedNum    = 0
            var count           = descriptors.length

            if (!count) callback()

            var hasExited               = false
            var hasLaunchedAllThreads   = false

            var doProcessURL  = function (desc) {
                me.processURL(desc, desc.index, contentManager, launchState, function () {
                    processedNum++

                    // set the internal closure `exitLoop` to stop launching new branches
                    // on the 1st encountering of `me.needToStop` flag
                    if (launchState.needToStop) {

                        if (!hasExited) {
                            hasExited = true
                            callback()
                        }

                        return
                    }

                    if (processedNum == count)
                        callback()
                    else
                        launchThread(descriptors)
                })
            }

            var launchThread  = function (descriptors) {
                var desc = descriptors.shift()

                if (!desc) return

                if (hasLaunchedAllThreads)
                    setTimeout(function () {
                        doProcessURL(desc)
                    }, me.pauseBetweenTests)
                else
                    doProcessURL(desc)
            }

            for (var i = 1; i <= this.maxThreads; i++) launchThread(descriptors)

            hasLaunchedAllThreads = true
        },


        runCoreSequential : function (descriptors, contentManager, launchState, callback) {
            if (descriptors.length && !launchState.needToStop) {
                var desc        = descriptors.shift()
                var me          = this

                this.processURL(desc, desc.index, contentManager, launchState, function () {

                    if (descriptors.length && !launchState.needToStop)
                        setTimeout(function () {
                            me.runCoreSequential(descriptors, contentManager, launchState, callback)
                        }, me.pauseBetweenTests)
                    else
                        callback()
                })

            } else
                callback()
        },


        stopCurrentLaunch : function (sourceTest) {
            var launchState     = this.launches[ sourceTest ? sourceTest.launchId : this.currentLaunchId ]

            if (launchState && !launchState.needToStop) {
                // this will indicate to the `onTestUpdate` and other methods that updates are coming from the
                // stale launch and should not be reported (updates could be generated in the `test.finalize()` below)
                launchState.needToStop  = true

                var me                  = this;

                Joose.A.each(launchState.descriptors, function (desc) {
                    var test    = me.testsByURL[ desc.url ]

                    if (test) {
                        // exceptions can arise if test page has switched to different context for example (click on the link)
                        // and siesta is trying to clear the timeouts with "clearTimeout"
                        try {
                            test.finalize(true)
                        } catch (e) {
                        }
                    }
                })

                // indicate that something has been changed indeed by returning `true`
                return true
            }
        },


        getSeedingCode : function (desc, launchId) {
            var code    = function (descId, launchId) {
                StartTest = startTest = function () {
                    arguments.callee.args   = arguments
                }
                describe                = function () {
                    if (describe.called) throw new Error("`describe()` used as global function instead of test method `t.describe()`")
                    describe.called = true

                    StartTest.apply(this, arguments)
                }

                StartTest.launchId          = launchId
                StartTest.id                = descId

                // for older IE - the try/catch should be from the same context as the exception
                StartTest.exceptionCatcher  = function (func) { var ex; try { func() } catch (e) { ex = e; } return ex == '__SIESTA_TEST_EXIT_EXCEPTION__' ? undefined : ex; };

                // for Error instances we try to pick up the values from "message" or "description" property
                // so need to have a correct constructor from the context of test
                StartTest.testErrorClass    = Error;
            }

            return ';(' + code.toString() + ')(' + JSON.stringify(desc.id) + ', ' + launchId + ')'
        },


        getScopeProviderConfigFor : function (desc, launchId) {
            var config          = Joose.O.copy(desc.scopeProviderConfig || {})

            config.seedingCode  = this.getSeedingCode(desc, launchId)
            config.launchId     = launchId

            return config
        },


        keepTestResult : function (url) {
            // already keeping
            if (this.lastResultsByURL[ url ]) {
                var indexOf     = -1

                Joose.A.each(this.lastResultsURLs, function (resultUrl, i) {
                    if (resultUrl == url) { indexOf = i; return false }
                })

                this.lastResultsURLs.splice(indexOf, 1)
                this.lastResultsURLs.push(url)

                return
            }

            this.lastResultsURLs.push(url)
            this.lastResultsByURL[ url ] = true

            if (this.lastResultsURLs.length > this.keepNLastResults) this.releaseTestResult()
        },


        releaseTestResult : function () {
            if (this.lastResultsURLs.length <= this.keepNLastResults) return

            var url     = this.lastResultsURLs.shift()

            delete this.lastResultsByURL[ url ]

            var test    = this.getTestByURL(url)

            if (test && test.isFinished()) this.cleanupScopeForURL(url)
        },


        isKeepingResultForURL : function (url) {
            return this.lastResultsByURL[ url ]
        },


        setupScope : function (desc, launchId) {
            var url                 = desc.url

            var alreadyExisting     = this.scopesByURL[ url ]
            // if test suite has been restarted at the "testsuitestart" point
            // then previous launch will concur the latest launch for the "this.scopesByURL" state
            // so we prevent the older launch to overwrite the newer
            var isOutdatedRequest    = alreadyExisting && alreadyExisting.launchId > launchId

            var scopeProviderClass  = eval(desc.scopeProvider)

            var newProvider         = new scopeProviderClass(this.getScopeProviderConfigFor(desc, launchId))

            if (isOutdatedRequest) {
                return newProvider
            } else {
                this.cleanupScopeForURL(url)

                this.keepTestResult(url)

                return this.scopesByURL[ url ] = newProvider
            }
        },


        cleanupScopeForURL : function (url) {
            var scopeProvider = this.scopesByURL[ url ]

            if (scopeProvider) {
                delete this.scopesByURL[ url ]

                scopeProvider.cleanup()
            }
        },


        // should prepare the "seedingScript" - include it to the `scopeProvider`
        prepareScopeSeeding : function (scopeProvider, desc, contentManager) {
            var isEcmaModule    = this.getDescriptorConfig(desc, 'isEcmaModule')

            if (desc.testCode || this.cachePreload && contentManager.hasContentOf(desc.url))
                scopeProvider.addPreload({
                    type            : 'js',
                    content         : desc.testCode || (contentManager.getContentOf(desc.url) + '\n//# sourceURL=' + desc.url),
                    isEcmaModule    : isEcmaModule
                })
            else {
                scopeProvider.seedingScript             = this.resolveURL(desc.url, scopeProvider, desc)
                scopeProvider.seedingScriptIsEcmaModule = isEcmaModule
            }
        },


        // should normalize non-standard urls (like specifying Class.Name in preload)
        // such behavior is not documented and generally deprecated
        normalizeURL : function (url) {
            return url
        },


        resolveURL : function (url, scopeProvider, desc) {
            return url
        },


        canUseCachedContent : function (resource, desc) {
            return this.cachePreload && resource instanceof Siesta.Content.Resource.JavaScript
        },


        addCachedResourceToPreloads : function (scopeProvider, contentManager, resource, desc) {
            scopeProvider.addPreload({
                type        : 'js',
                content     : contentManager.getContentOf(resource)
            })
        },


        getOnErrorHandler : function (testHolder, preloadErrors) {
            var R = Siesta.Resource('Siesta.Project');

            // dirty, all-in-one error handler, ideally should be refactored
            return function (msg, url, lineNumber, col, error, promiseRejectionEvent) {
                // according to https://stackoverflow.com/questions/49384120/resizeobserver-loop-limit-exceeded
                // the `ResizeObserver loop limit exceeded` is some dummy error that can be safely ignored
                var shouldIgnore    = /__SIESTA_TEST_EXIT_EXCEPTION__|ResizeObserver loop limit exceeded/
                var test            = testHolder.test

                if (promiseRejectionEvent) {
                    msg             = promiseRejectionEvent.reason || ''
                    url             = lineNumber = col = ''
                    error           = test.global && promiseRejectionEvent.reason instanceof test.global.Error ? promiseRejectionEvent.reason : null;
                }

                // Either an HTMLElement load failure - "window.addEventListener('error', handler, true)"
                // OR
                // Error in a script on another domain (message Script error)
                if (arguments.length === 1) {
                    var event       = msg

                    error           = event.error

                    if (event.target && event.target.tagName && !error) {
                        msg         = R.get('resourceFailedToLoad', { nodeName : event.target ? event.target.nodeName.toUpperCase() : ''});
                        url         = event.srcElement ? event.srcElement.href || event.srcElement.src : ''
                        lineNumber  = ''

                        test.fail(msg + ' ' + (event.target ? event.target.outerHTML : url));

                        return;
                    } else {
                        msg         = event.message;
                        url         = '';
                        lineNumber  = 0;
                    }
                }

                if (shouldIgnore.test(msg)) return

                // this handler can still be called if test uses "failOnResourceLoadError", which install this handler to
                // 'error' event of the `window`, instead of window.onerror
                // so we consult with the test if we should ignore this exception, as it will be handled somewhere else
                if (test && test.onException(msg, url, lineNumber, col, error) === true) return

                if (test && test.isStarted()) {
                    test.nbrExceptions++;

                    // this is the final "message receiver" in test.. probably test should install on error handlers
                    // by itself somehow..
                    test.failWithException(
                        error || (msg + ' ' + url + ' ' + lineNumber),
                        promiseRejectionEvent ? "Unhandled promise rejection in test " + (test.name || test.url): null
                    )
                } else {
                    preloadErrors && preloadErrors.push({
                        isException     : true,
                        message         : error && error.stack ? test.stringifyException(error, error.stack) : msg + ' ' + url + ' ' + lineNumber
                    })
                }
            }
        },


        processURL : function (desc, index, contentManager, launchState, callback, noCleanup, sharedSandboxState) {
            var me      = this
            var url     = desc.url

            if (desc.isMissing) {
                callback()

                return
            }

            // delete the test from "not launched" as soon as the processing has started
            delete launchState.notLaunchedByAutomationId[ desc.automationElementId ]

            // a magical shared object, which will contain the `test` property with test instance, once the test will be created
            var testHolder      = {}
            // an array of errors occured during preload phase
            var preloadErrors   = []

            var onErrorHandler  = this.getOnErrorHandler(testHolder, preloadErrors)
            var scopeProvider   = this.setupScope(desc, launchState.launchId)
            var transparentEx   = this.getDescriptorConfig(desc, 'transparentEx')

            // trying to setup the `onerror` handler as early as possible - to detect each and every exception from the test
            var onErrorHandlerBorrowing = scopeProvider.addOnErrorHandler(onErrorHandler, !transparentEx)

//            scopeProvider.addPreload({
//                type        : 'js',
//                content     : 'console.time("scope-onload")'
//            })

            desc.preset.eachResource(function (resource) {
                var hasContent      = contentManager.hasContentOf(resource)

                if (hasContent && me.canUseCachedContent(resource, desc)) {
                    me.addCachedResourceToPreloads(scopeProvider, contentManager, resource, desc)
                } else {
                    var resourceDesc    = resource.asDescriptor()

                    if (resourceDesc.url) resourceDesc.url = me.resolveURL(resourceDesc.url, scopeProvider, desc)

                    scopeProvider.addPreload(resourceDesc)
                }
            })


            me.prepareScopeSeeding(scopeProvider, desc, contentManager)

            var testClass       = me.getDescriptorConfig(desc, 'testClass')
            if (me.typeOf(testClass) == 'String') testClass = Joose.S.strToClass(testClass)

            var testConfig      = me.getNewTestConfiguration(desc, scopeProvider, contentManager, launchState, sharedSandboxState)

            // create the test instance early, so that one can perform some setup (as the test class method call)
            // even before the "pageUrl" starts loading
            var test            = testHolder.test = new testClass(testConfig)

            this.onBeforeScopePreload(scopeProvider, url, test)

            test.earlySetup(function () {
                cont()
            }, function (errorMessage) {
                preloadErrors.push({ isException : false, message : errorMessage })

                cont()
            })

            function cont() {
                //console.timeEnd('launch-till-preload')

                //console.time('preload')

    //            scopeProvider.addPreload({
    //                type        : 'js',
    //                content     : 'console.timeEnd("scope-onload")'
    //            })
                var R       = Siesta.Resource('Siesta.Project')

                scopeProvider.setup(function (scopeProvider, failedPreloads, crossOriginFailed) {
                    me.onAfterScopePreload(scopeProvider, url, test, failedPreloads)

                    failedPreloads && Joose.O.each(failedPreloads, function (value, url) {
                        preloadErrors.unshift({
                            isException : false,
                            message     : R.get('preloadHasFailed', { url : url })
                        })
                    })

                    if (crossOriginFailed) {
                        preloadErrors.push({
                            isException : true,
                            message     : R.get('crossOriginFailed', { url : scopeProvider.sourceURL })
                        })
                    }

                    // scope provider has been cleaned up while setting up? (may be user has restarted the test)
                    // then do nothing
                    if (!scopeProvider.scope) { callback(); return }

                    me.launchTest({
                        testHolder          : testHolder,
                        desc                : desc,
                        scopeProvider       : scopeProvider,
                        contentManager      : contentManager,
                        launchState         : launchState,
                        preloadErrors       : preloadErrors,
                        onErrorHandler      : onErrorHandler,
                        onErrorHandlerBorrowing : onErrorHandlerBorrowing,

                        // need to provide the "startTestAnchor" explicitly (and not just get from "scope" inside of the "launchTest"
                        // method, because for "enablePageRedirect" method, startAnchor is calculated differently
                        startTestAnchor     : crossOriginFailed ? null : scopeProvider.scope.StartTest,
                        noCleanup           : noCleanup,
                        reusingSandbox      : false
                    }, callback)
                })
            }
        },


        launchTest : function (options, callback) {
            var scopeProvider   = options.scopeProvider
            var desc            = options.desc
//            desc, scopeProvider, contentManager, options, preloadErrors, onErrorHandler, callback

            //console.timeEnd('preload')
            //console.timeEnd('launch-after-preload')
            var me              = this
            var url             = desc.url

            var testHolder      = options.testHolder
            var noCleanup       = options.noCleanup
            var cleanupUrl      = options.cleanupUrl
            var test            = testHolder.test

            // "main" test callback, called once test is completed
            test.callback       = function () {
                if (!noCleanup && !me.isKeepingResultForURL(url)) {
                    // `cleanupUrl` will be different for shared sandbox tests
                    me.cleanupScopeForURL(cleanupUrl || url)
                }

                callback && callback(testHolder)

                testHolder  = null
            }

            if (scopeProvider.crossOriginFailed) {
                // test will immediately fail
                if (!test.isFinished()) test.start(options.preloadErrors)

                options         = null
                test            = null

                return
            }

            var startTestAnchor = options.startTestAnchor
            var args            = startTestAnchor && startTestAnchor.args
            var global          = scopeProvider.scope

            // additional setup of the test instance, setting up the properties, which are known only after scope
            // is loaded
            Joose.O.extend(test, {
                startTestAnchor     : startTestAnchor,
                exceptionCatcher    : startTestAnchor.exceptionCatcher,
                testErrorClass      : startTestAnchor.testErrorClass,

                global              : global,

                // the "options" part is used by the "enablePageRedirect" branch, where
                // the test script is executed in different context from the "global" context
                originalSetTimeout  : options.originalSetTimeout || global.setTimeout,
                originalClearTimeout: options.originalClearTimeout || global.clearTimeout,

                // pick either 1st or 2nd argument depending which one is a function
                run                 : args && (typeof args[ 0 ] == 'function' ? args[ 0 ] : args[ 1 ]),

                reusingSandbox      : options.reusingSandbox
            })

            // after the scope setup, the `onerror` handler might be cleared - installing it again
            if (options.onErrorHandler) {
                if (options.onErrorHandlerBorrowing) options.onErrorHandlerBorrowing()

                options.onErrorHandlerBorrowing = scopeProvider.addOnErrorHandler(options.onErrorHandler, !this.getDescriptorConfig(desc, 'transparentEx'))
            }

            this.saveTestWithURL(url, test)

            var doLaunch        = function() {
                // scope provider has been cleaned up while setting up? (may be user has restarted the test)
                // then do nothing
                if (!scopeProvider.scope) { callback(); return }

                //console.timeEnd('launch')

                me.fireEvent('beforeteststart', test)

                // in the edge case, test can be already finished before its even started :)
                // this happens if user re-launch the test during these 10ms - test will be
                // finalized forcefully in the "deleteTestByUrl" method
                if (!test.isFinished()) test.start(options.preloadErrors)

                options         = null
                test            = null
            }

            if (options.reusingSandbox)
                doLaunch()
            else {
                if (scopeProvider instanceof Scope.Provider.IFrame)
                    // start the test after slight delay - to run it already *after* onload (in browsers)
                    global.setTimeout(doLaunch, 10)
                else
                    // for Window provider, `global.setTimeout` seems to not execute passed function _sometimes_
                    // also increase the "onload" delay
                    setTimeout(doLaunch, 50)
            }
        },


        getNewTestConfiguration : function (desc, scopeProvider, contentManager, launchState, sharedSandboxState) {
            var groups          = []
            var currentDesc     = desc.parent

            while (currentDesc) {
                // do not push name of the top-level "hidden" group which has no parent
                currentDesc.parent && groups.unshift(String(currentDesc.group))

                currentDesc     = currentDesc.parent
            }

            var config          = {
                url                 : desc.url,
                name                : desc.name,

                referenceUrl        : this.getDescriptorConfig(desc, 'referenceUrl'),

                launchId            : launchState.launchId,

                automationElementId : desc.automationElementId,
                groups              : groups,
                jUnitClass          : this.getDescriptorConfig(desc, 'jUnitClass'),

                project             : this,

                expectedGlobals     : this.cleanScopeGlobals.concat(this.getDescriptorConfig(desc, 'expectedGlobals')),
                autoCheckGlobals    : this.getDescriptorConfig(desc, 'autoCheckGlobals'),
                disableGlobalsCheck : this.disableGlobalsCheck,

                scopeProvider       : scopeProvider,

                contentManager      : contentManager,

                transparentEx       : this.getDescriptorConfig(desc, 'transparentEx'),
                needDone            : this.getDescriptorConfig(desc, 'needDone'),

                overrideSetTimeout          : this.getDescriptorConfig(desc, 'overrideSetTimeout'),

                defaultTimeout              : this.getDescriptorConfig(desc, 'defaultTimeout') * (launchState.increaseTimeout ? 2 : 1),
                subTestTimeout              : this.getDescriptorConfig(desc, 'subTestTimeout') * (launchState.increaseTimeout ? 2 : 1),
                waitForTimeout              : this.getDescriptorConfig(desc, 'waitForTimeout') * (launchState.increaseTimeout ? 3 : 1),
                isReadyTimeout              : this.getDescriptorConfig(desc, 'isReadyTimeout'),

                sourceLineForAllAssertions  : this.sourceLineForAllAssertions,

                sandboxCleanup              : this.getDescriptorConfig(desc, 'sandboxCleanup'),
                sharedSandboxState          : sharedSandboxState,

                config                      : this.getDescriptorConfig(desc, 'config'),

                failOnExclusiveSpecsWhenAutomated   : this.getDescriptorConfig(desc, 'failOnExclusiveSpecsWhenAutomated'),

                // enableCodeCoverage          : this.getDescriptorConfig(desc, 'enableCodeCoverage'),
                snoozeUntil                 : this.getDescriptorConfig(desc, 'snooze'),
                suppressPassedWaitForAssertion  : this.getDescriptorConfig(desc, 'suppressPassedWaitForAssertion')
            }

            return config
        },


        getScriptDescriptor : function (id) {
            return this.descriptorsById[ id ]
        },


        getDescById : function (id) {
            return this.descriptorsById[ id ]
        },


        getTestByURL : function (url) {
            return this.testsByURL[ url ]
        },


        saveTestWithURL : function (url, test) {
            this.testsByURL[ url ] = test
        },


        deleteTestByURL : function (url) {
            var test    = this.testsByURL[ url ]

            if (test) {
                // exceptions can arise if test page has switched to different context for example (click on the link)
                // and siesta is trying to clear the timeouts with "clearTimeout"
                try {
                    test.finalize(true)
                } catch (e) {
                }
                this.cleanupScopeForURL(url)
            }

            delete this.testsByURL[ url ]
        },


        allPassed : function () {
            var allPassed       = true
            var me              = this

            Joose.A.each(this.flattenDescriptors(this.descriptors), function (descriptor) {
                // if at least one test is missing then something is wrong
                if (descriptor.isMissing) { allPassed = false; return false }

                var test        = me.getTestByURL(descriptor.url)

                // ignore missing tests (could be skipped by test filtering)
                if (!test) return

                allPassed       = allPassed && test.isPassed()

                // stop iteration if found failed test
                if (!allPassed) return false
            })

            return allPassed
        },


        flattenArray : function (array, stripEmpty) {
            var me          = this
            var result      = []

            Joose.A.each(array, function (el) {
                if (me.typeOf(el) == 'Array')
                    result.push.apply(result, me.flattenArray(el, stripEmpty))
                else
                    if (!stripEmpty || el)
                        result.push(el)
            })

            return result
        },


        buildSandboxHashStructure : function () {
            return [
                'preload',
                'alsoPreload',
                'hostPageUrl',
                'pageUrl',
                'useStrictMode',
                'overrideSetTimeout'
            ]
        },


        assignUniqueTag     : function (value, configName) {
            // has to be an Object-like value (object, array, function, etc)
            if (value == null) return ''

            if (value === Object(value)) {
                if (value.__UNIQUE__) return value.__UNIQUE__

                return value.__UNIQUE__ = (this.uniqueCounter++).toString(36)
            } else {
                value                   = value + ''

                var configIndex         = this.valueToHashIndicies[ configName ]

                if (!configIndex) configIndex = this.valueToHashIndicies[ configName ] = {}

                if (configIndex[ value ]) return configIndex[ value ]

                return configIndex[ value ] = (this.uniqueCounter++).toString(36)
            }
        },


        calculateSharedContextGroupHash : function (desc) {
            var me              = this
            var structure       = this.getSandboxHashStructure()

            var hash            = ''

            Joose.A.each(structure, function (configName) {
                hash            += me.assignUniqueTag(me.getDescriptorConfig(desc, configName), configName)
            })

            if (this.sandboxBoundaryByGroup) hash += this.assignUniqueTag(desc.parent)

            return hash
        },


        sortDescriptors : function (descriptors, forcedRunCore, idsOnly) {
            var me                  = this
            var canRunParallel      = []
            var mustRunSequential   = []

            // array of { groupHash : ..., items : [] } objects
            var sharedContextGroups = []
            var groupsByHash        = {}

            Joose.A.each(descriptors, function (desc) {
                if (!me.getDescriptorConfig(desc, 'sandbox')) {
                    var hash        = me.calculateSharedContextGroupHash(desc)
                    var group       = groupsByHash[ hash ]

                    if (!group) {
                        group       = groupsByHash[ hash ] = { groupHash : hash, items : [] }
                        sharedContextGroups.push(group)
                    }

                    group.items.push(idsOnly ? desc.id : desc)
                } else {
                    var runCore         = forcedRunCore || me.getDescriptorConfig(desc, 'runCore')

                    if (runCore == 'sequential' || me.testMustRunSequential(desc))
                        mustRunSequential.push(idsOnly ? desc.id : desc)
                    else
                        canRunParallel.push(idsOnly ? desc.id : desc)
                }
            })

            return {
                sharedContextGroups     : sharedContextGroups,
                mustRunSequential       : mustRunSequential,
                canRunParallel          : canRunParallel
            }
        },


        hasDescriptorWithNativeEventsSimulation : function (descriptors) {
            return false
        }
    },
    // eof methods

    my : {

        has     : {
            HOST            : null,
            instance        : null
        },

        methods : {

            // backward compat for static project instance
            staticDeprecationWarning : function (methodName) {
                var message     = Siesta.Resource('Siesta.Project', 'staticDeprecationWarning', { methodName : methodName, projectClass : this.HOST + '' })

                if (typeof console != 'undefined') console.warn(message)
            },


            configure : function (config) {
                this.staticDeprecationWarning('configure')

                var instance        = this.instance = new this.HOST()

                return instance.configure(config)
            },


            start : function () {
                this.staticDeprecationWarning('start')

                return this.instance.start.apply(this.instance, arguments)
            },


            on : function () {
                this.staticDeprecationWarning('on')

                return this.instance.on.apply(this.instance, arguments)
            }
            // eof backward compat
        }
    }
})
//eof Siesta.Project

// backward compat
Siesta.Harness = Siesta.Project
;
/**
@class Siesta.Util.Role.CanStyleOutput
@private

A role, providing output coloring functionality

*/
Role('Siesta.Util.Role.CanStyleOutput', {

    has         : {
        /**
         * @cfg {Boolean} disableColoring When set to `true` will disable the colors in the console output in automation launchers / NodeJS launcher
         */
        disableColoring : false,

        style               : {
            is          : 'rwc',
            lazy        : 'this.buildStyle'
        },

        styles              : {
            init    : {
                'bold'      : [1, 22],
                'italic'    : [3, 23],
                'underline' : [4, 24],

                'black '    : [30, 39],
                'yellow'    : [33, 39],
                'cyan'      : [36, 39],
                'white'     : [37, 39],
                'green'     : [32, 39],
                'red'       : [31, 39],
                'grey'      : [90, 39],
                'blue'      : [34, 39],
                'magenta'   : [35, 39],

                'bgblack '  : [40, 49],
                'bgyellow'  : [43, 49],
                'bgcyan'    : [46, 49],
                'bgwhite'   : [47, 49],
                'bggreen'   : [42, 49],
                'bgred'     : [41, 49],
                'bggrey'    : [100, 49],
                'bgblue'    : [44, 49],
                'bgmagenta' : [45, 49],

                'inverse'   : [7, 27]
            }
        }
    },


    methods : {

        buildStyle : function () {
            var me          = this
            var style       = {}

            Joose.O.each(this.styles, function (value, name) {

                style[ name ] = function (text) { return me.styled(text, name) }
            })

            return style
        },


        styled : function (text, style) {
            if (this.disableColoring) return text

            var styles = this.styles

            return '\x1B[' + styles[ style ][ 0 ] + 'm' + text + '\x1B[' + styles[ style ][ 1 ] + 'm'
        }
    }
})
;
;
Role('Siesta.Util.Role.CanParseBrowser', {

    methods : {

        parseBrowser : function (uaString) {
            var browser = 'unknown'
            var version = ''

            var match

            if (match = /Firefox\/((?:\d+\.?)+)/.exec(uaString)) {
                browser     = "Firefox"
                version     = match[ 1 ]
            }

            if (match = /Chrome\/((?:\d+\.?)+)/.exec(uaString)) {
                browser     = "Chrome"
                version     = match[ 1 ]
            }

            if (match = /MSIE\s*((?:\d+\.?)+)/.exec(uaString)) {
                browser     = "IE"
                version     = match[ 1 ]
            }

            if (uaString.match(/trident/i) && (match = /rv.(\d\d\.?\d?)/.exec(uaString))) {
                browser     = "IE"
                version     = match[ 1 ]
            }

            if (match = /chrome.+? edge\/(\d+(\.\d+)?)/i.exec(uaString)) {
                browser     = "Edge"
                version     = match[ 1 ]
            }

            if (match = /Apple.*Version\/((?:\d+\.?)+)\s*(?=Safari\/((?:\d+\.?)+))/.exec(uaString)) {
                browser     = "Safari"
                version     = match[ 1 ] + ' (' + match[ 2 ] + ')'
            }

            if (match = /PhantomJS\/(\d+\.\d+\.\d+)/.exec(uaString)) {
                browser     = "PhantomJS"
                version     = match[ 1 ]
            }

            if (match = /SlimerJS\/(\d+\.\d+\.\d+)/.exec(uaString)) {
                browser     = "SlimerJS"
                version     = match[ 1 ]
            }

            if (match = /NodeJS\/(.+)/.exec(uaString)) {
                browser     = "NodeJS"
                version     = match[ 1 ]
            }

            return {
                name        : browser,
                version     : version
            }
        }
    }
});
;
if (typeof Promise == "undefined") {;
/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   v4.2.4+314e4831
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.ES6Promise = factory());
}(this, (function () { 'use strict';

function objectOrFunction(x) {
  var type = typeof x;
  return x !== null && (type === 'object' || type === 'function');
}

function isFunction(x) {
  return typeof x === 'function';
}



var _isArray = void 0;
if (Array.isArray) {
  _isArray = Array.isArray;
} else {
  _isArray = function (x) {
    return Object.prototype.toString.call(x) === '[object Array]';
  };
}

var isArray = _isArray;

var len = 0;
var vertxNext = void 0;
var customSchedulerFn = void 0;

var asap = function asap(callback, arg) {
  queue[len] = callback;
  queue[len + 1] = arg;
  len += 2;
  if (len === 2) {
    // If len is 2, that means that we need to schedule an async flush.
    // If additional callbacks are queued before the queue is flushed, they
    // will be processed by this flush that we are scheduling.
    if (customSchedulerFn) {
      customSchedulerFn(flush);
    } else {
      scheduleFlush();
    }
  }
};

function setScheduler(scheduleFn) {
  customSchedulerFn = scheduleFn;
}

function setAsap(asapFn) {
  asap = asapFn;
}

var browserWindow = typeof window !== 'undefined' ? window : undefined;
var browserGlobal = browserWindow || {};
var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

// test for web worker but not in IE10
var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

// node
function useNextTick() {
  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
  // see https://github.com/cujojs/when/issues/410 for details
  return function () {
    return process.nextTick(flush);
  };
}

// vertx
function useVertxTimer() {
  if (typeof vertxNext !== 'undefined') {
    return function () {
      vertxNext(flush);
    };
  }

  return useSetTimeout();
}

function useMutationObserver() {
  var iterations = 0;
  var observer = new BrowserMutationObserver(flush);
  var node = document.createTextNode('');
  observer.observe(node, { characterData: true });

  return function () {
    node.data = iterations = ++iterations % 2;
  };
}

// web worker
function useMessageChannel() {
  var channel = new MessageChannel();
  channel.port1.onmessage = flush;
  return function () {
    return channel.port2.postMessage(0);
  };
}

function useSetTimeout() {
  // Store setTimeout reference so es6-promise will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var globalSetTimeout = setTimeout;
  return function () {
    return globalSetTimeout(flush, 1);
  };
}

var queue = new Array(1000);
function flush() {
  for (var i = 0; i < len; i += 2) {
    var callback = queue[i];
    var arg = queue[i + 1];

    callback(arg);

    queue[i] = undefined;
    queue[i + 1] = undefined;
  }

  len = 0;
}

function attemptVertx() {
  try {
    var vertx = Function('return this')().require('vertx');
    vertxNext = vertx.runOnLoop || vertx.runOnContext;
    return useVertxTimer();
  } catch (e) {
    return useSetTimeout();
  }
}

var scheduleFlush = void 0;
// Decide what async method to use to triggering processing of queued callbacks:
if (isNode) {
  scheduleFlush = useNextTick();
} else if (BrowserMutationObserver) {
  scheduleFlush = useMutationObserver();
} else if (isWorker) {
  scheduleFlush = useMessageChannel();
} else if (browserWindow === undefined && typeof require === 'function') {
  scheduleFlush = attemptVertx();
} else {
  scheduleFlush = useSetTimeout();
}

function then(onFulfillment, onRejection) {
  var parent = this;

  var child = new this.constructor(noop);

  if (child[PROMISE_ID] === undefined) {
    makePromise(child);
  }

  var _state = parent._state;


  if (_state) {
    var callback = arguments[_state - 1];
    asap(function () {
      return invokeCallback(_state, child, callback, parent._result);
    });
  } else {
    subscribe(parent, child, onFulfillment, onRejection);
  }

  return child;
}

/**
  `Promise.resolve` returns a promise that will become resolved with the
  passed `value`. It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    resolve(1);
  });

  promise.then(function(value){
    // value === 1
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.resolve(1);

  promise.then(function(value){
    // value === 1
  });
  ```

  @method resolve
  @static
  @param {Any} value value that the returned promise will be resolved with
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/
function resolve$1(object) {
  /*jshint validthis:true */
  var Constructor = this;

  if (object && typeof object === 'object' && object.constructor === Constructor) {
    return object;
  }

  var promise = new Constructor(noop);
  resolve(promise, object);
  return promise;
}

var PROMISE_ID = Math.random().toString(36).substring(2);

function noop() {}

var PENDING = void 0;
var FULFILLED = 1;
var REJECTED = 2;

var TRY_CATCH_ERROR = { error: null };

function selfFulfillment() {
  return new TypeError("You cannot resolve a promise with itself");
}

function cannotReturnOwn() {
  return new TypeError('A promises callback cannot return that same promise.');
}

function getThen(promise) {
  try {
    return promise.then;
  } catch (error) {
    TRY_CATCH_ERROR.error = error;
    return TRY_CATCH_ERROR;
  }
}

function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
  try {
    then$$1.call(value, fulfillmentHandler, rejectionHandler);
  } catch (e) {
    return e;
  }
}

function handleForeignThenable(promise, thenable, then$$1) {
  asap(function (promise) {
    var sealed = false;
    var error = tryThen(then$$1, thenable, function (value) {
      if (sealed) {
        return;
      }
      sealed = true;
      if (thenable !== value) {
        resolve(promise, value);
      } else {
        fulfill(promise, value);
      }
    }, function (reason) {
      if (sealed) {
        return;
      }
      sealed = true;

      reject(promise, reason);
    }, 'Settle: ' + (promise._label || ' unknown promise'));

    if (!sealed && error) {
      sealed = true;
      reject(promise, error);
    }
  }, promise);
}

function handleOwnThenable(promise, thenable) {
  if (thenable._state === FULFILLED) {
    fulfill(promise, thenable._result);
  } else if (thenable._state === REJECTED) {
    reject(promise, thenable._result);
  } else {
    subscribe(thenable, undefined, function (value) {
      return resolve(promise, value);
    }, function (reason) {
      return reject(promise, reason);
    });
  }
}

function handleMaybeThenable(promise, maybeThenable, then$$1) {
  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
    handleOwnThenable(promise, maybeThenable);
  } else {
    if (then$$1 === TRY_CATCH_ERROR) {
      reject(promise, TRY_CATCH_ERROR.error);
      TRY_CATCH_ERROR.error = null;
    } else if (then$$1 === undefined) {
      fulfill(promise, maybeThenable);
    } else if (isFunction(then$$1)) {
      handleForeignThenable(promise, maybeThenable, then$$1);
    } else {
      fulfill(promise, maybeThenable);
    }
  }
}

function resolve(promise, value) {
  if (promise === value) {
    reject(promise, selfFulfillment());
  } else if (objectOrFunction(value)) {
    handleMaybeThenable(promise, value, getThen(value));
  } else {
    fulfill(promise, value);
  }
}

function publishRejection(promise) {
  if (promise._onerror) {
    promise._onerror(promise._result);
  }

  publish(promise);
}

function fulfill(promise, value) {
  if (promise._state !== PENDING) {
    return;
  }

  promise._result = value;
  promise._state = FULFILLED;

  if (promise._subscribers.length !== 0) {
    asap(publish, promise);
  }
}

function reject(promise, reason) {
  if (promise._state !== PENDING) {
    return;
  }
  promise._state = REJECTED;
  promise._result = reason;

  asap(publishRejection, promise);
}

function subscribe(parent, child, onFulfillment, onRejection) {
  var _subscribers = parent._subscribers;
  var length = _subscribers.length;


  parent._onerror = null;

  _subscribers[length] = child;
  _subscribers[length + FULFILLED] = onFulfillment;
  _subscribers[length + REJECTED] = onRejection;

  if (length === 0 && parent._state) {
    asap(publish, parent);
  }
}

function publish(promise) {
  var subscribers = promise._subscribers;
  var settled = promise._state;

  if (subscribers.length === 0) {
    return;
  }

  var child = void 0,
      callback = void 0,
      detail = promise._result;

  for (var i = 0; i < subscribers.length; i += 3) {
    child = subscribers[i];
    callback = subscribers[i + settled];

    if (child) {
      invokeCallback(settled, child, callback, detail);
    } else {
      callback(detail);
    }
  }

  promise._subscribers.length = 0;
}

function tryCatch(callback, detail) {
  try {
    return callback(detail);
  } catch (e) {
    TRY_CATCH_ERROR.error = e;
    return TRY_CATCH_ERROR;
  }
}

function invokeCallback(settled, promise, callback, detail) {
  var hasCallback = isFunction(callback),
      value = void 0,
      error = void 0,
      succeeded = void 0,
      failed = void 0;

  if (hasCallback) {
    value = tryCatch(callback, detail);

    if (value === TRY_CATCH_ERROR) {
      failed = true;
      error = value.error;
      value.error = null;
    } else {
      succeeded = true;
    }

    if (promise === value) {
      reject(promise, cannotReturnOwn());
      return;
    }
  } else {
    value = detail;
    succeeded = true;
  }

  if (promise._state !== PENDING) {
    // noop
  } else if (hasCallback && succeeded) {
    resolve(promise, value);
  } else if (failed) {
    reject(promise, error);
  } else if (settled === FULFILLED) {
    fulfill(promise, value);
  } else if (settled === REJECTED) {
    reject(promise, value);
  }
}

function initializePromise(promise, resolver) {
  try {
    resolver(function resolvePromise(value) {
      resolve(promise, value);
    }, function rejectPromise(reason) {
      reject(promise, reason);
    });
  } catch (e) {
    reject(promise, e);
  }
}

var id = 0;
function nextId() {
  return id++;
}

function makePromise(promise) {
  promise[PROMISE_ID] = id++;
  promise._state = undefined;
  promise._result = undefined;
  promise._subscribers = [];
}

function validationError() {
  return new Error('Array Methods must be provided an Array');
}

var Enumerator = function () {
  function Enumerator(Constructor, input) {
    this._instanceConstructor = Constructor;
    this.promise = new Constructor(noop);

    if (!this.promise[PROMISE_ID]) {
      makePromise(this.promise);
    }

    if (isArray(input)) {
      this.length = input.length;
      this._remaining = input.length;

      this._result = new Array(this.length);

      if (this.length === 0) {
        fulfill(this.promise, this._result);
      } else {
        this.length = this.length || 0;
        this._enumerate(input);
        if (this._remaining === 0) {
          fulfill(this.promise, this._result);
        }
      }
    } else {
      reject(this.promise, validationError());
    }
  }

  Enumerator.prototype._enumerate = function _enumerate(input) {
    for (var i = 0; this._state === PENDING && i < input.length; i++) {
      this._eachEntry(input[i], i);
    }
  };

  Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {
    var c = this._instanceConstructor;
    var resolve$$1 = c.resolve;


    if (resolve$$1 === resolve$1) {
      var _then = getThen(entry);

      if (_then === then && entry._state !== PENDING) {
        this._settledAt(entry._state, i, entry._result);
      } else if (typeof _then !== 'function') {
        this._remaining--;
        this._result[i] = entry;
      } else if (c === Promise$2) {
        var promise = new c(noop);
        handleMaybeThenable(promise, entry, _then);
        this._willSettleAt(promise, i);
      } else {
        this._willSettleAt(new c(function (resolve$$1) {
          return resolve$$1(entry);
        }), i);
      }
    } else {
      this._willSettleAt(resolve$$1(entry), i);
    }
  };

  Enumerator.prototype._settledAt = function _settledAt(state, i, value) {
    var promise = this.promise;


    if (promise._state === PENDING) {
      this._remaining--;

      if (state === REJECTED) {
        reject(promise, value);
      } else {
        this._result[i] = value;
      }
    }

    if (this._remaining === 0) {
      fulfill(promise, this._result);
    }
  };

  Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {
    var enumerator = this;

    subscribe(promise, undefined, function (value) {
      return enumerator._settledAt(FULFILLED, i, value);
    }, function (reason) {
      return enumerator._settledAt(REJECTED, i, reason);
    });
  };

  return Enumerator;
}();

/**
  `Promise.all` accepts an array of promises, and returns a new promise which
  is fulfilled with an array of fulfillment values for the passed promises, or
  rejected with the reason of the first passed promise to be rejected. It casts all
  elements of the passed iterable to promises as it runs this algorithm.

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = resolve(2);
  let promise3 = resolve(3);
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // The array here would be [ 1, 2, 3 ];
  });
  ```

  If any of the `promises` given to `all` are rejected, the first promise
  that is rejected will be given as an argument to the returned promises's
  rejection handler. For example:

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = reject(new Error("2"));
  let promise3 = reject(new Error("3"));
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(error) {
    // error.message === "2"
  });
  ```

  @method all
  @static
  @param {Array} entries array of promises
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all `promises` have been
  fulfilled, or rejected if any of them become rejected.
  @static
*/
function all(entries) {
  return new Enumerator(this, entries).promise;
}

/**
  `Promise.race` returns a new promise which is settled in the same way as the
  first passed promise to settle.

  Example:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 2');
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // result === 'promise 2' because it was resolved before promise1
    // was resolved.
  });
  ```

  `Promise.race` is deterministic in that only the state of the first
  settled promise matters. For example, even if other promises given to the
  `promises` array argument are resolved, but the first settled promise has
  become rejected before the other promises became fulfilled, the returned
  promise will become rejected:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      reject(new Error('promise 2'));
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // Code here never runs
  }, function(reason){
    // reason.message === 'promise 2' because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  An example real-world use case is implementing timeouts:

  ```javascript
  Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @static
  @param {Array} promises array of promises to observe
  Useful for tooling.
  @return {Promise} a promise which settles in the same way as the first passed
  promise to settle.
*/
function race(entries) {
  /*jshint validthis:true */
  var Constructor = this;

  if (!isArray(entries)) {
    return new Constructor(function (_, reject) {
      return reject(new TypeError('You must pass an array to race.'));
    });
  } else {
    return new Constructor(function (resolve, reject) {
      var length = entries.length;
      for (var i = 0; i < length; i++) {
        Constructor.resolve(entries[i]).then(resolve, reject);
      }
    });
  }
}

/**
  `Promise.reject` returns a promise rejected with the passed `reason`.
  It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    reject(new Error('WHOOPS'));
  });

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.reject(new Error('WHOOPS'));

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  @method reject
  @static
  @param {Any} reason value that the returned promise will be rejected with.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/
function reject$1(reason) {
  /*jshint validthis:true */
  var Constructor = this;
  var promise = new Constructor(noop);
  reject(promise, reason);
  return promise;
}

function needsResolver() {
  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
}

function needsNew() {
  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
}

/**
  Promise objects represent the eventual result of an asynchronous operation. The
  primary way of interacting with a promise is through its `then` method, which
  registers callbacks to receive either a promise's eventual value or the reason
  why the promise cannot be fulfilled.

  Terminology
  -----------

  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  - `thenable` is an object or function that defines a `then` method.
  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  - `exception` is a value that is thrown using the throw statement.
  - `reason` is a value that indicates why a promise was rejected.
  - `settled` the final resting state of a promise, fulfilled or rejected.

  A promise can be in one of three states: pending, fulfilled, or rejected.

  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  state.  Promises that are rejected have a rejection reason and are in the
  rejected state.  A fulfillment value is never a thenable.

  Promises can also be said to *resolve* a value.  If this value is also a
  promise, then the original promise's settled state will match the value's
  settled state.  So a promise that *resolves* a promise that rejects will
  itself reject, and a promise that *resolves* a promise that fulfills will
  itself fulfill.


  Basic Usage:
  ------------

  ```js
  let promise = new Promise(function(resolve, reject) {
    // on success
    resolve(value);

    // on failure
    reject(reason);
  });

  promise.then(function(value) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Advanced Usage:
  ---------------

  Promises shine when abstracting away asynchronous interactions such as
  `XMLHttpRequest`s.

  ```js
  function getJSON(url) {
    return new Promise(function(resolve, reject){
      let xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.onreadystatechange = handler;
      xhr.responseType = 'json';
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send();

      function handler() {
        if (this.readyState === this.DONE) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
          }
        }
      };
    });
  }

  getJSON('/posts.json').then(function(json) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Unlike callbacks, promises are great composable primitives.

  ```js
  Promise.all([
    getJSON('/posts'),
    getJSON('/comments')
  ]).then(function(values){
    values[0] // => postsJSON
    values[1] // => commentsJSON

    return values;
  });
  ```

  @class Promise
  @param {Function} resolver
  Useful for tooling.
  @constructor
*/

var Promise$2 = function () {
  function Promise(resolver) {
    this[PROMISE_ID] = nextId();
    this._result = this._state = undefined;
    this._subscribers = [];

    if (noop !== resolver) {
      typeof resolver !== 'function' && needsResolver();
      this instanceof Promise ? initializePromise(this, resolver) : needsNew();
    }
  }

  /**
  The primary way of interacting with a promise is through its `then` method,
  which registers callbacks to receive either a promise's eventual value or the
  reason why the promise cannot be fulfilled.
   ```js
  findUser().then(function(user){
    // user is available
  }, function(reason){
    // user is unavailable, and you are given the reason why
  });
  ```
   Chaining
  --------
   The return value of `then` is itself a promise.  This second, 'downstream'
  promise is resolved with the return value of the first promise's fulfillment
  or rejection handler, or rejected if the handler throws an exception.
   ```js
  findUser().then(function (user) {
    return user.name;
  }, function (reason) {
    return 'default name';
  }).then(function (userName) {
    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
    // will be `'default name'`
  });
   findUser().then(function (user) {
    throw new Error('Found user, but still unhappy');
  }, function (reason) {
    throw new Error('`findUser` rejected and we're unhappy');
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
  });
  ```
  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
   ```js
  findUser().then(function (user) {
    throw new PedagogicalException('Upstream error');
  }).then(function (value) {
    // never reached
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // The `PedgagocialException` is propagated all the way down to here
  });
  ```
   Assimilation
  ------------
   Sometimes the value you want to propagate to a downstream promise can only be
  retrieved asynchronously. This can be achieved by returning a promise in the
  fulfillment or rejection handler. The downstream promise will then be pending
  until the returned promise is settled. This is called *assimilation*.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // The user's comments are now available
  });
  ```
   If the assimliated promise rejects, then the downstream promise will also reject.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // If `findCommentsByAuthor` fulfills, we'll have the value here
  }, function (reason) {
    // If `findCommentsByAuthor` rejects, we'll have the reason here
  });
  ```
   Simple Example
  --------------
   Synchronous Example
   ```javascript
  let result;
   try {
    result = findResult();
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
  findResult(function(result, err){
    if (err) {
      // failure
    } else {
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findResult().then(function(result){
    // success
  }, function(reason){
    // failure
  });
  ```
   Advanced Example
  --------------
   Synchronous Example
   ```javascript
  let author, books;
   try {
    author = findAuthor();
    books  = findBooksByAuthor(author);
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
   function foundBooks(books) {
   }
   function failure(reason) {
   }
   findAuthor(function(author, err){
    if (err) {
      failure(err);
      // failure
    } else {
      try {
        findBoooksByAuthor(author, function(books, err) {
          if (err) {
            failure(err);
          } else {
            try {
              foundBooks(books);
            } catch(reason) {
              failure(reason);
            }
          }
        });
      } catch(error) {
        failure(err);
      }
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findAuthor().
    then(findBooksByAuthor).
    then(function(books){
      // found books
  }).catch(function(reason){
    // something went wrong
  });
  ```
   @method then
  @param {Function} onFulfilled
  @param {Function} onRejected
  Useful for tooling.
  @return {Promise}
  */

  /**
  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
  as the catch block of a try/catch statement.
  ```js
  function findAuthor(){
  throw new Error('couldn't find that author');
  }
  // synchronous
  try {
  findAuthor();
  } catch(reason) {
  // something went wrong
  }
  // async with promises
  findAuthor().catch(function(reason){
  // something went wrong
  });
  ```
  @method catch
  @param {Function} onRejection
  Useful for tooling.
  @return {Promise}
  */


  Promise.prototype.catch = function _catch(onRejection) {
    return this.then(null, onRejection);
  };

  /**
    `finally` will be invoked regardless of the promise's fate just as native
    try/catch/finally behaves

    Synchronous example:

    ```js
    findAuthor() {
      if (Math.random() > 0.5) {
        throw new Error();
      }
      return new Author();
    }

    try {
      return findAuthor(); // succeed or fail
    } catch(error) {
      return findOtherAuther();
    } finally {
      // always runs
      // doesn't affect the return value
    }
    ```

    Asynchronous example:

    ```js
    findAuthor().catch(function(reason){
      return findOtherAuther();
    }).finally(function(){
      // author was either found, or not
    });
    ```

    @method finally
    @param {Function} callback
    @return {Promise}
  */


  Promise.prototype.finally = function _finally(callback) {
    var promise = this;
    var constructor = promise.constructor;

    return promise.then(function (value) {
      return constructor.resolve(callback()).then(function () {
        return value;
      });
    }, function (reason) {
      return constructor.resolve(callback()).then(function () {
        throw reason;
      });
    });
  };

  return Promise;
}();

Promise$2.prototype.then = then;
Promise$2.all = all;
Promise$2.race = race;
Promise$2.resolve = resolve$1;
Promise$2.reject = reject$1;
Promise$2._setScheduler = setScheduler;
Promise$2._setAsap = setAsap;
Promise$2._asap = asap;

/*global self*/
function polyfill() {
  var local = void 0;

  if (typeof global !== 'undefined') {
    local = global;
  } else if (typeof self !== 'undefined') {
    local = self;
  } else {
    try {
      local = Function('return this')();
    } catch (e) {
      throw new Error('polyfill failed because global object is unavailable in this environment');
    }
  }

  var P = local.Promise;

  if (P) {
    var promiseToString = null;
    try {
      promiseToString = Object.prototype.toString.call(P.resolve());
    } catch (e) {
      // silently ignored
    }

    if (promiseToString === '[object Promise]' && !P.cast) {
      return;
    }
  }

  local.Promise = Promise$2;
}

// Strange compat..
Promise$2.polyfill = polyfill;
Promise$2.Promise = Promise$2;

Promise$2.polyfill();

return Promise$2;

})));
;
};
/*!
 * Bowser - a browser detector
 * https://github.com/ded/bowser
 * MIT License | (c) Dustin Diaz 2015
 */

!function (root, name, definition) {
  // SIESTA PATCH BEGIN
  // if (typeof module != 'undefined' && module.exports) module.exports = definition()
  // else if (typeof define == 'function' && define.amd) define(name, definition)
  // else root[name] = definition()

    var global = typeof window != 'undefined' ? window : root
    global[name] = definition()
  // SIESTA PATCH END
}(this, 'bowser', function () {
  /**
    * See useragents.js for examples of navigator.userAgent
    */

  var t = true

  function detect(ua) {

    function getFirstMatch(regex) {
      var match = ua.match(regex);
      return (match && match.length > 1 && match[1]) || '';
    }

    function getSecondMatch(regex) {
      var match = ua.match(regex);
      return (match && match.length > 1 && match[2]) || '';
    }

    var iosdevice = getFirstMatch(/(ipod|iphone|ipad)/i).toLowerCase()
      , likeAndroid = /like android/i.test(ua)
      , android = !likeAndroid && /android/i.test(ua)
      , nexusMobile = /nexus\s*[0-6]\s*/i.test(ua)
      , nexusTablet = !nexusMobile && /nexus\s*[0-9]+/i.test(ua)
      , chromeos = /CrOS/.test(ua)
      , silk = /silk/i.test(ua)
      , sailfish = /sailfish/i.test(ua)
      , tizen = /tizen/i.test(ua)
      , webos = /(web|hpw)os/i.test(ua)
      , windowsphone = /windows phone/i.test(ua)
      , samsungBrowser = /SamsungBrowser/i.test(ua)
      , windows = !windowsphone && /windows/i.test(ua)
      , mac = !iosdevice && !silk && /macintosh/i.test(ua)
      , linux = !android && !sailfish && !tizen && !webos && /linux/i.test(ua)
      , edgeVersion = getFirstMatch(/edge\/(\d+(\.\d+)?)/i)
      , versionIdentifier = getFirstMatch(/version\/(\d+(\.\d+)?)/i)
      , tablet = /tablet/i.test(ua)
      , mobile = !tablet && /[^-]mobi/i.test(ua)
      , xbox = /xbox/i.test(ua)
      , result

    if (/opera/i.test(ua)) {
      //  an old Opera
      result = {
        name: 'Opera'
      , opera: t
      , version: versionIdentifier || getFirstMatch(/(?:opera|opr|opios)[\s\/](\d+(\.\d+)?)/i)
      }
    } else if (/opr|opios/i.test(ua)) {
      // a new Opera
      result = {
        name: 'Opera'
        , opera: t
        , version: getFirstMatch(/(?:opr|opios)[\s\/](\d+(\.\d+)?)/i) || versionIdentifier
      }
    }
    else if (/SamsungBrowser/i.test(ua)) {
      result = {
        name: 'Samsung Internet for Android'
        , samsungBrowser: t
        , version: versionIdentifier || getFirstMatch(/(?:SamsungBrowser)[\s\/](\d+(\.\d+)?)/i)
      }
    }
    else if (/coast/i.test(ua)) {
      result = {
        name: 'Opera Coast'
        , coast: t
        , version: versionIdentifier || getFirstMatch(/(?:coast)[\s\/](\d+(\.\d+)?)/i)
      }
    }
    else if (/yabrowser/i.test(ua)) {
      result = {
        name: 'Yandex Browser'
      , yandexbrowser: t
      , version: versionIdentifier || getFirstMatch(/(?:yabrowser)[\s\/](\d+(\.\d+)?)/i)
      }
    }
    else if (/ucbrowser/i.test(ua)) {
      result = {
          name: 'UC Browser'
        , ucbrowser: t
        , version: getFirstMatch(/(?:ucbrowser)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/mxios/i.test(ua)) {
      result = {
        name: 'Maxthon'
        , maxthon: t
        , version: getFirstMatch(/(?:mxios)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/epiphany/i.test(ua)) {
      result = {
        name: 'Epiphany'
        , epiphany: t
        , version: getFirstMatch(/(?:epiphany)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/puffin/i.test(ua)) {
      result = {
        name: 'Puffin'
        , puffin: t
        , version: getFirstMatch(/(?:puffin)[\s\/](\d+(?:\.\d+)?)/i)
      }
    }
    else if (/sleipnir/i.test(ua)) {
      result = {
        name: 'Sleipnir'
        , sleipnir: t
        , version: getFirstMatch(/(?:sleipnir)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/k-meleon/i.test(ua)) {
      result = {
        name: 'K-Meleon'
        , kMeleon: t
        , version: getFirstMatch(/(?:k-meleon)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (windowsphone) {
      result = {
        name: 'Windows Phone'
      , windowsphone: t
      }
      if (edgeVersion) {
        result.msedge = t
        result.version = edgeVersion
      }
      else {
        result.msie = t
        result.version = getFirstMatch(/iemobile\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/msie|trident/i.test(ua)) {
      result = {
        name: 'Internet Explorer'
      , msie: t
      , version: getFirstMatch(/(?:msie |rv:)(\d+(\.\d+)?)/i)
      }
    } else if (chromeos) {
      result = {
        name: 'Chrome'
      , chromeos: t
      , chromeBook: t
      , chrome: t
      , version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
      }
    } else if (/chrome.+? edge/i.test(ua)) {
      result = {
        name: 'Microsoft Edge'
      , msedge: t
      , version: edgeVersion
      }
    }
    else if (/vivaldi/i.test(ua)) {
      result = {
        name: 'Vivaldi'
        , vivaldi: t
        , version: getFirstMatch(/vivaldi\/(\d+(\.\d+)?)/i) || versionIdentifier
      }
    }
    else if (sailfish) {
      result = {
        name: 'Sailfish'
      , sailfish: t
      , version: getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/seamonkey\//i.test(ua)) {
      result = {
        name: 'SeaMonkey'
      , seamonkey: t
      , version: getFirstMatch(/seamonkey\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/firefox|iceweasel|fxios/i.test(ua)) {
      result = {
        name: 'Firefox'
      , firefox: t
      , version: getFirstMatch(/(?:firefox|iceweasel|fxios)[ \/](\d+(\.\d+)?)/i)
      }
      if (/\((mobile|tablet);[^\)]*rv:[\d\.]+\)/i.test(ua)) {
        result.firefoxos = t
      }
    }
    else if (silk) {
      result =  {
        name: 'Amazon Silk'
      , silk: t
      , version : getFirstMatch(/silk\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/phantom/i.test(ua)) {
      result = {
        name: 'PhantomJS'
      , phantom: t
      , version: getFirstMatch(/phantomjs\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/slimerjs/i.test(ua)) {
      result = {
        name: 'SlimerJS'
        , slimer: t
        , version: getFirstMatch(/slimerjs\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/blackberry|\bbb\d+/i.test(ua) || /rim\stablet/i.test(ua)) {
      result = {
        name: 'BlackBerry'
      , blackberry: t
      , version: versionIdentifier || getFirstMatch(/blackberry[\d]+\/(\d+(\.\d+)?)/i)
      }
    }
    else if (webos) {
      result = {
        name: 'WebOS'
      , webos: t
      , version: versionIdentifier || getFirstMatch(/w(?:eb)?osbrowser\/(\d+(\.\d+)?)/i)
      };
      /touchpad\//i.test(ua) && (result.touchpad = t)
    }
    else if (/bada/i.test(ua)) {
      result = {
        name: 'Bada'
      , bada: t
      , version: getFirstMatch(/dolfin\/(\d+(\.\d+)?)/i)
      };
    }
    else if (tizen) {
      result = {
        name: 'Tizen'
      , tizen: t
      , version: getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.\d+)?)/i) || versionIdentifier
      };
    }
    else if (/qupzilla/i.test(ua)) {
      result = {
        name: 'QupZilla'
        , qupzilla: t
        , version: getFirstMatch(/(?:qupzilla)[\s\/](\d+(?:\.\d+)+)/i) || versionIdentifier
      }
    }
    else if (/chromium/i.test(ua)) {
      result = {
        name: 'Chromium'
        , chromium: t
        , version: getFirstMatch(/(?:chromium)[\s\/](\d+(?:\.\d+)?)/i) || versionIdentifier
      }
    }
    else if (/chrome|crios|crmo/i.test(ua)) {
      result = {
        name: 'Chrome'
        , chrome: t
        , version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
      }
    }
    else if (android) {
      result = {
        name: 'Android'
        , version: versionIdentifier
      }
    }
    else if (/safari|applewebkit/i.test(ua)) {
      result = {
        name: 'Safari'
      , safari: t
      }
      if (versionIdentifier) {
        result.version = versionIdentifier
      }
    }
    else if (iosdevice) {
      result = {
        name : iosdevice == 'iphone' ? 'iPhone' : iosdevice == 'ipad' ? 'iPad' : 'iPod'
      }
      // WTF: version is not part of user agent in web apps
      if (versionIdentifier) {
        result.version = versionIdentifier
      }
    }
    else if(/googlebot/i.test(ua)) {
      result = {
        name: 'Googlebot'
      , googlebot: t
      , version: getFirstMatch(/googlebot\/(\d+(\.\d+))/i) || versionIdentifier
      }
    }
    else {
      result = {
        name: getFirstMatch(/^(.*)\/(.*) /),
        version: getSecondMatch(/^(.*)\/(.*) /)
     };
   }

    // set webkit or gecko flag for browsers based on these engines
    if (!result.msedge && /(apple)?webkit/i.test(ua)) {
      if (/(apple)?webkit\/537\.36/i.test(ua)) {
        result.name = result.name || "Blink"
        result.blink = t
      } else {
        result.name = result.name || "Webkit"
        result.webkit = t
      }
      if (!result.version && versionIdentifier) {
        result.version = versionIdentifier
      }
    } else if (!result.opera && /gecko\//i.test(ua)) {
      result.name = result.name || "Gecko"
      result.gecko = t
      result.version = result.version || getFirstMatch(/gecko\/(\d+(\.\d+)?)/i)
    }

    // set OS flags for platforms that have multiple browsers
    if (!result.windowsphone && !result.msedge && (android || result.silk)) {
      result.android = t
    } else if (!result.windowsphone && !result.msedge && iosdevice) {
      result[iosdevice] = t
      result.ios = t
    } else if (mac) {
      result.mac = t
    } else if (xbox) {
      result.xbox = t
    } else if (windows) {
      result.windows = t
    } else if (linux) {
      result.linux = t
    }

    // OS version extraction
    var osVersion = '';
    if (result.windowsphone) {
      osVersion = getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i);
    } else if (iosdevice) {
      osVersion = getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i);
      osVersion = osVersion.replace(/[_\s]/g, '.');
    } else if (android) {
      osVersion = getFirstMatch(/android[ \/-](\d+(\.\d+)*)/i);
    } else if (result.webos) {
      osVersion = getFirstMatch(/(?:web|hpw)os\/(\d+(\.\d+)*)/i);
    } else if (result.blackberry) {
      osVersion = getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i);
    } else if (result.bada) {
      osVersion = getFirstMatch(/bada\/(\d+(\.\d+)*)/i);
    } else if (result.tizen) {
      osVersion = getFirstMatch(/tizen[\/\s](\d+(\.\d+)*)/i);
    }
    if (osVersion) {
      result.osversion = osVersion;
    }

    // device type extraction
    var osMajorVersion = osVersion.split('.')[0];
    if (
         tablet
      || nexusTablet
      || iosdevice == 'ipad'
      || (android && (osMajorVersion == 3 || (osMajorVersion >= 4 && !mobile)))
      || result.silk
    ) {
      result.tablet = t
    } else if (
         mobile
      || iosdevice == 'iphone'
      || iosdevice == 'ipod'
      || android
      || nexusMobile
      || result.blackberry
      || result.webos
      || result.bada
    ) {
      result.mobile = t
    }

    // Graded Browser Support
    // http://developer.yahoo.com/yui/articles/gbs
    if (result.msedge ||
        (result.msie && result.version >= 10) ||
        (result.yandexbrowser && result.version >= 15) ||
		    (result.vivaldi && result.version >= 1.0) ||
        (result.chrome && result.version >= 20) ||
        (result.samsungBrowser && result.version >= 4) ||
        (result.firefox && result.version >= 20.0) ||
        (result.safari && result.version >= 6) ||
        (result.opera && result.version >= 10.0) ||
        (result.ios && result.osversion && result.osversion.split(".")[0] >= 6) ||
        (result.blackberry && result.version >= 10.1)
        || (result.chromium && result.version >= 20)
        ) {
      result.a = t;
    }
    else if ((result.msie && result.version < 10) ||
        (result.chrome && result.version < 20) ||
        (result.firefox && result.version < 20.0) ||
        (result.safari && result.version < 6) ||
        (result.opera && result.version < 10.0) ||
        (result.ios && result.osversion && result.osversion.split(".")[0] < 6)
        || (result.chromium && result.version < 20)
        ) {
      result.c = t
    } else result.x = t

    return result
  }

  var bowser = detect(typeof navigator !== 'undefined' ? navigator.userAgent || '' : '')

  bowser.test = function (browserList) {
    for (var i = 0; i < browserList.length; ++i) {
      var browserItem = browserList[i];
      if (typeof browserItem=== 'string') {
        if (browserItem in bowser) {
          return true;
        }
      }
    }
    return false;
  }

  /**
   * Get version precisions count
   *
   * @example
   *   getVersionPrecision("1.10.3") // 3
   *
   * @param  {string} version
   * @return {number}
   */
  function getVersionPrecision(version) {
    return version.split(".").length;
  }

  /**
   * Array::map polyfill
   *
   * @param  {Array} arr
   * @param  {Function} iterator
   * @return {Array}
   */
  function map(arr, iterator) {
    var result = [], i;
    if (Array.prototype.map) {
      return Array.prototype.map.call(arr, iterator);
    }
    for (i = 0; i < arr.length; i++) {
      result.push(iterator(arr[i]));
    }
    return result;
  }

  /**
   * Calculate browser version weight
   *
   * @example
   *   compareVersions(['1.10.2.1',  '1.8.2.1.90'])    // 1
   *   compareVersions(['1.010.2.1', '1.09.2.1.90']);  // 1
   *   compareVersions(['1.10.2.1',  '1.10.2.1']);     // 0
   *   compareVersions(['1.10.2.1',  '1.0800.2']);     // -1
   *
   * @param  {Array<String>} versions versions to compare
   * @return {Number} comparison result
   */
  function compareVersions(versions) {
    // 1) get common precision for both versions, for example for "10.0" and "9" it should be 2
    var precision = Math.max(getVersionPrecision(versions[0]), getVersionPrecision(versions[1]));
    var chunks = map(versions, function (version) {
      var delta = precision - getVersionPrecision(version);

      // 2) "9" -> "9.0" (for precision = 2)
      version = version + new Array(delta + 1).join(".0");

      // 3) "9.0" -> ["000000000"", "000000009"]
      return map(version.split("."), function (chunk) {
        return new Array(20 - chunk.length).join("0") + chunk;
      }).reverse();
    });

    // iterate in reverse order by reversed chunks array
    while (--precision >= 0) {
      // 4) compare: "000000009" > "000000010" = false (but "9" > "10" = true)
      if (chunks[0][precision] > chunks[1][precision]) {
        return 1;
      }
      else if (chunks[0][precision] === chunks[1][precision]) {
        if (precision === 0) {
          // all version chunks are same
          return 0;
        }
      }
      else {
        return -1;
      }
    }
  }

  /**
   * Check if browser is unsupported
   *
   * @example
   *   bowser.isUnsupportedBrowser({
   *     msie: "10",
   *     firefox: "23",
   *     chrome: "29",
   *     safari: "5.1",
   *     opera: "16",
   *     phantom: "534"
   *   });
   *
   * @param  {Object}  minVersions map of minimal version to browser
   * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map
   * @param  {String}  [ua] user agent string
   * @return {Boolean}
   */
  function isUnsupportedBrowser(minVersions, strictMode, ua) {
    var _bowser = bowser;

    // make strictMode param optional with ua param usage
    if (typeof strictMode === 'string') {
      ua = strictMode;
      strictMode = void(0);
    }

    if (strictMode === void(0)) {
      strictMode = false;
    }
    if (ua) {
      _bowser = detect(ua);
    }

    var version = "" + _bowser.version;
    for (var browser in minVersions) {
      if (minVersions.hasOwnProperty(browser)) {
        if (_bowser[browser]) {
          if (typeof minVersions[browser] !== 'string') {
            throw new Error('Browser version in the minVersion map should be a string: ' + browser + ': ' + String(minVersions));
          }

          // browser version and min supported version.
          return compareVersions([version, minVersions[browser]]) < 0;
        }
      }
    }

    return strictMode; // not found
  }

  /**
   * Check if browser is supported
   *
   * @param  {Object} minVersions map of minimal version to browser
   * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map
   * @param  {String}  [ua] user agent string
   * @return {Boolean}
   */
  function check(minVersions, strictMode, ua) {
    return !isUnsupportedBrowser(minVersions, strictMode, ua);
  }

  bowser.isUnsupportedBrowser = isUnsupportedBrowser;
  bowser.compareVersions = compareVersions;
  bowser.check = check;

  /*
   * Set our detect method to the main bowser object so we can
   * reuse it to test other user agents.
   * This is needed to implement future tests.
   */
  bowser._detect = detect;

  return bowser
});
;
/*!
* jQuery JavaScript Library v1.6.2
* http://jquery.com/
*
* Copyright 2011, John Resig
* Dual licensed under the MIT or GPL Version 2 licenses.
* http://jquery.org/license
*
* Includes Sizzle.js
* http://sizzlejs.com/
* Copyright 2011, The Dojo Foundation
* Released under the MIT, BSD, and GPL Licenses.
*
* Date: Thu Jun 30 14:16:56 2011 -0400
*/
(function (window, undefined) {

    // Use the correct document accordingly with window argument (sandbox)
    var document = window.document,
	navigator = window.navigator,
	location = window.location;
    var jQuery = (function () {

        // Define a local copy of jQuery
        var jQuery = function (selector, context) {
            // The jQuery object is actually just the init constructor 'enhanced'
            return new jQuery.fn.init(selector, context, rootjQuery);
        },

        // Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

        // Map over the $ in case of overwrite
	_$ = window.$,

        // A central reference to the root jQuery(document)
	rootjQuery,

        // A simple way to check for HTML strings or ID strings
        // (both of which we optimize for)
	quickExpr = /^(?:[^<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,

        // Check if a string has a non-whitespace character in it
	rnotwhite = /\S/,

        // Used for trimming whitespace
	trimLeft = /^\s+/,
	trimRight = /\s+$/,

        // Check for digits
	rdigit = /\d/,

        // Match a standalone tag
	rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,

        // JSON RegExp
	rvalidchars = /^[\],:{}\s]*$/,
	rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
	rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,

        // Useragent RegExp
	rwebkit = /(webkit)[ \/]([\w.]+)/,
	ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/,
	rmsie = /(msie) ([\w.]+)/,
	rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/,

        // Matches dashed string for camelizing
	rdashAlpha = /-([a-z])/ig,

        // Used by jQuery.camelCase as callback to replace()
	fcamelCase = function (all, letter) {
	    return letter.toUpperCase();
	},

        // Keep a UserAgent string for use with jQuery.browser
	userAgent = navigator.userAgent,

        // For matching the engine and version of the browser
	browserMatch,

        // The deferred used on DOM ready
	readyList,

        // The ready event handler
	DOMContentLoaded,

        // Save a reference to some core methods
	toString = Object.prototype.toString,
	hasOwn = Object.prototype.hasOwnProperty,
	push = Array.prototype.push,
	slice = Array.prototype.slice,
	trim = String.prototype.trim,
	indexOf = Array.prototype.indexOf,

        // [[Class]] -> type pairs
	class2type = {};

        jQuery.fn = jQuery.prototype = {
            constructor: jQuery,
            init: function (selector, context, rootjQuery) {
                var match, elem, ret, doc;

                // Handle $(""), $(null), or $(undefined)
                if (!selector) {
                    return this;
                }

                // Handle $(DOMElement)
                if (selector.nodeType) {
                    this.context = this[0] = selector;
                    this.length = 1;
                    return this;
                }

                // The body element only exists once, optimize finding it
                if (selector === "body" && !context && document.body) {
                    this.context = document;
                    this[0] = document.body;
                    this.selector = selector;
                    this.length = 1;
                    return this;
                }

                // Handle HTML strings
                if (typeof selector === "string") {
                    // Are we dealing with HTML string or an ID?
                    if (selector.charAt(0) === "<" && selector.charAt(selector.length - 1) === ">" && selector.length >= 3) {
                        // Assume that strings that start and end with <> are HTML and skip the regex check
                        match = [null, selector, null];

                    } else {
                        match = quickExpr.exec(selector);
                    }

                    // Verify a match, and that no context was specified for #id
                    if (match && (match[1] || !context)) {

                        // HANDLE: $(html) -> $(array)
                        if (match[1]) {
                            context = context instanceof jQuery ? context[0] : context;
                            doc = (context ? context.ownerDocument || context : document);

                            // If a single string is passed in and it's a single tag
                            // just do a createElement and skip the rest
                            ret = rsingleTag.exec(selector);

                            if (ret) {
                                if (jQuery.isPlainObject(context)) {
                                    selector = [document.createElement(ret[1])];
                                    jQuery.fn.attr.call(selector, context, true);

                                } else {
                                    selector = [doc.createElement(ret[1])];
                                }

                            } else {
                                ret = jQuery.buildFragment([match[1]], [doc]);
                                selector = (ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment).childNodes;
                            }

                            return jQuery.merge(this, selector);

                            // HANDLE: $("#id")
                        } else {
                            elem = document.getElementById(match[2]);

                            // Check parentNode to catch when Blackberry 4.6 returns
                            // nodes that are no longer in the document #6963
                            if (elem && elem.parentNode) {
                                // Handle the case where IE and Opera return items
                                // by name instead of ID
                                if (elem.id !== match[2]) {
                                    return rootjQuery.find(selector);
                                }

                                // Otherwise, we inject the element directly into the jQuery object
                                this.length = 1;
                                this[0] = elem;
                            }

                            this.context = document;
                            this.selector = selector;
                            return this;
                        }

                        // HANDLE: $(expr, $(...))
                    } else if (!context || context.jquery) {
                        return (context || rootjQuery).find(selector);

                        // HANDLE: $(expr, context)
                        // (which is just equivalent to: $(context).find(expr)
                    } else {
                        return this.constructor(context).find(selector);
                    }

                    // HANDLE: $(function)
                    // Shortcut for document ready
                } else if (jQuery.isFunction(selector)) {
                    return rootjQuery.ready(selector);
                }

                if (selector.selector !== undefined) {
                    this.selector = selector.selector;
                    this.context = selector.context;
                }

                return jQuery.makeArray(selector, this);
            },

            // Start with an empty selector
            selector: "",

            // The current version of jQuery being used
            jquery: "1.6.2",

            // The default length of a jQuery object is 0
            length: 0,

            // The number of elements contained in the matched element set
            size: function () {
                return this.length;
            },

            toArray: function () {
                return slice.call(this, 0);
            },

            // Get the Nth element in the matched element set OR
            // Get the whole matched element set as a clean array
            get: function (num) {
                return num == null ?

                // Return a 'clean' array
			this.toArray() :

                // Return just the object
			(num < 0 ? this[this.length + num] : this[num]);
            },

            // Take an array of elements and push it onto the stack
            // (returning the new matched element set)
            pushStack: function (elems, name, selector) {
                // Build a new jQuery matched element set
                var ret = this.constructor();

                if (jQuery.isArray(elems)) {
                    push.apply(ret, elems);

                } else {
                    jQuery.merge(ret, elems);
                }

                // Add the old object onto the stack (as a reference)
                ret.prevObject = this;

                ret.context = this.context;

                if (name === "find") {
                    ret.selector = this.selector + (this.selector ? " " : "") + selector;
                } else if (name) {
                    ret.selector = this.selector + "." + name + "(" + selector + ")";
                }

                // Return the newly-formed element set
                return ret;
            },

            // Execute a callback for every element in the matched set.
            // (You can seed the arguments with an array of args, but this is
            // only used internally.)
            each: function (callback, args) {
                return jQuery.each(this, callback, args);
            },

            ready: function (fn) {
                // Attach the listeners
                jQuery.bindReady();

                // Add the callback
                readyList.done(fn);

                return this;
            },

            eq: function (i) {
                return i === -1 ?
			this.slice(i) :
			this.slice(i, +i + 1);
            },

            first: function () {
                return this.eq(0);
            },

            last: function () {
                return this.eq(-1);
            },

            slice: function () {
                return this.pushStack(slice.apply(this, arguments),
			"slice", slice.call(arguments).join(","));
            },

            map: function (callback) {
                return this.pushStack(jQuery.map(this, function (elem, i) {
                    return callback.call(elem, i, elem);
                }));
            },

            end: function () {
                return this.prevObject || this.constructor(null);
            },

            // For internal use only.
            // Behaves like an Array's method, not like a jQuery method.
            push: push,
            sort: [].sort,
            splice: [].splice
        };

        // Give the init function the jQuery prototype for later instantiation
        jQuery.fn.init.prototype = jQuery.fn;

        jQuery.extend = jQuery.fn.extend = function () {
            var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

            // Handle a deep copy situation
            if (typeof target === "boolean") {
                deep = target;
                target = arguments[1] || {};
                // skip the boolean and the target
                i = 2;
            }

            // Handle case when target is a string or something (possible in deep copy)
            if (typeof target !== "object" && !jQuery.isFunction(target)) {
                target = {};
            }

            // extend jQuery itself if only one argument is passed
            if (length === i) {
                target = this;
                --i;
            }

            for (; i < length; i++) {
                // Only deal with non-null/undefined values
                if ((options = arguments[i]) != null) {
                    // Extend the base object
                    for (name in options) {
                        src = target[name];
                        copy = options[name];

                        // Prevent never-ending loop
                        if (target === copy) {
                            continue;
                        }

                        // Recurse if we're merging plain objects or arrays
                        if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                            if (copyIsArray) {
                                copyIsArray = false;
                                clone = src && jQuery.isArray(src) ? src : [];

                            } else {
                                clone = src && jQuery.isPlainObject(src) ? src : {};
                            }

                            // Never move original objects, clone them
                            target[name] = jQuery.extend(deep, clone, copy);

                            // Don't bring in undefined values
                        } else if (copy !== undefined) {
                            target[name] = copy;
                        }
                    }
                }
            }

            // Return the modified object
            return target;
        };

        jQuery.extend({
            noConflict: function (deep) {
                if (window.$ === jQuery) {
                    window.$ = _$;
                }

                if (deep && window.jQuery === jQuery) {
                    window.jQuery = _jQuery;
                }

                return jQuery;
            },

            // Is the DOM ready to be used? Set to true once it occurs.
            isReady: false,

            // A counter to track how many items to wait for before
            // the ready event fires. See #6781
            readyWait: 1,

            // Hold (or release) the ready event
            holdReady: function (hold) {
                if (hold) {
                    jQuery.readyWait++;
                } else {
                    jQuery.ready(true);
                }
            },

            // Handle when the DOM is ready
            ready: function (wait) {
                // Either a released hold or an DOMready/load event and not yet ready
                if ((wait === true && ! --jQuery.readyWait) || (wait !== true && !jQuery.isReady)) {
                    // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
                    if (!document.body) {
                        return setTimeout(jQuery.ready, 1);
                    }

                    // Remember that the DOM is ready
                    jQuery.isReady = true;

                    // If a normal DOM Ready event fired, decrement, and wait if need be
                    if (wait !== true && --jQuery.readyWait > 0) {
                        return;
                    }

                    // If there are functions bound, to execute
                    readyList.resolveWith(document, [jQuery]);

                    // Trigger any bound ready events
                    if (jQuery.fn.trigger) {
                        jQuery(document).trigger("ready").unbind("ready");
                    }
                }
            },

            bindReady: function () {
                if (readyList) {
                    return;
                }

                readyList = jQuery._Deferred();

                // Catch cases where $(document).ready() is called after the
                // browser event has already occurred.
                if (document.readyState === "complete") {
                    // Handle it asynchronously to allow scripts the opportunity to delay ready
                    return setTimeout(jQuery.ready, 1);
                }

                // Mozilla, Opera and webkit nightlies currently support this event
                if (document.addEventListener) {
                    // Use the handy event callback
                    document.addEventListener("DOMContentLoaded", DOMContentLoaded, false);

                    // A fallback to window.onload, that will always work
                    window.addEventListener("load", jQuery.ready, false);

                    // If IE event model is used
                } else if (document.attachEvent) {
                    // ensure firing before onload,
                    // maybe late but safe also for iframes
                    document.attachEvent("onreadystatechange", DOMContentLoaded);

                    // A fallback to window.onload, that will always work
                    window.attachEvent("onload", jQuery.ready);

                    // If IE and not a frame
                    // continually check to see if the document is ready
                    var toplevel = false;

                    try {
                        toplevel = window.frameElement == null;
                    } catch (e) { }

                    if (document.documentElement.doScroll && toplevel) {
                        doScrollCheck();
                    }
                }
            },

            // See test/unit/core.js for details concerning isFunction.
            // Since version 1.3, DOM methods and functions like alert
            // aren't supported. They return false on IE (#2968).
            isFunction: function (obj) {
                return jQuery.type(obj) === "function";
            },

            isArray: Array.isArray || function (obj) {
                return jQuery.type(obj) === "array";
            },

            // A crude way of determining if an object is a window
            isWindow: function (obj) {
                return obj && typeof obj === "object" && "setInterval" in obj;
            },

            isNaN: function (obj) {
                return obj == null || !rdigit.test(obj) || isNaN(obj);
            },

            type: function (obj) {
                return obj == null ?
			String(obj) :
			class2type[toString.call(obj)] || "object";
            },

            isPlainObject: function (obj) {
                // Must be an Object.
                // Because of IE, we also have to check the presence of the constructor property.
                // Make sure that DOM nodes and window objects don't pass through, as well
                if (!obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
                    return false;
                }

                // Not own constructor property must be Object
                if (obj.constructor &&
			!hasOwn.call(obj, "constructor") &&
			!hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
                    return false;
                }

                // Own properties are enumerated firstly, so to speed up,
                // if last one is own, then all properties are own.

                var key;
                for (key in obj) { }

                return key === undefined || hasOwn.call(obj, key);
            },

            isEmptyObject: function (obj) {
                for (var name in obj) {
                    return false;
                }
                return true;
            },

            error: function (msg) {
                throw msg;
            },

            parseJSON: function (data) {
                if (typeof data !== "string" || !data) {
                    return null;
                }

                // Make sure leading/trailing whitespace is removed (IE can't handle it)
                data = jQuery.trim(data);

                // Attempt to parse using the native JSON parser first
                if (window.JSON && window.JSON.parse) {
                    return window.JSON.parse(data);
                }

                // Make sure the incoming data is actual JSON
                // Logic borrowed from http://json.org/json2.js
                if (rvalidchars.test(data.replace(rvalidescape, "@")
			.replace(rvalidtokens, "]")
			.replace(rvalidbraces, ""))) {

                    return (new Function("return " + data))();

                }
                jQuery.error("Invalid JSON: " + data);
            },

            // Cross-browser xml parsing
            // (xml & tmp used internally)
            parseXML: function (data, xml, tmp) {

                if (window.DOMParser) { // Standard
                    tmp = new DOMParser();
                    xml = tmp.parseFromString(data, "text/xml");
                } else { // IE
                    xml = new ActiveXObject("Microsoft.XMLDOM");
                    xml.async = "false";
                    xml.loadXML(data);
                }

                tmp = xml.documentElement;

                if (!tmp || !tmp.nodeName || tmp.nodeName === "parsererror") {
                    jQuery.error("Invalid XML: " + data);
                }

                return xml;
            },

            noop: function () { },

            // Evaluates a script in a global context
            // Workarounds based on findings by Jim Driscoll
            // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
            globalEval: function (data) {
                if (data && rnotwhite.test(data)) {
                    // We use execScript on Internet Explorer
                    // We use an anonymous function so that context is window
                    // rather than jQuery in Firefox
                    (window.execScript || function (data) {
                        window["eval"].call(window, data);
                    })(data);
                }
            },

            // Converts a dashed string to camelCased string;
            // Used by both the css and data modules
            camelCase: function (string) {
                return string.replace(rdashAlpha, fcamelCase);
            },

            nodeName: function (elem, name) {
                return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();
            },

            // args is for internal usage only
            each: function (object, callback, args) {
                var name, i = 0,
			length = object.length,
			isObj = length === undefined || jQuery.isFunction(object);

                if (args) {
                    if (isObj) {
                        for (name in object) {
                            if (callback.apply(object[name], args) === false) {
                                break;
                            }
                        }
                    } else {
                        for (; i < length; ) {
                            if (callback.apply(object[i++], args) === false) {
                                break;
                            }
                        }
                    }

                    // A special, fast, case for the most common use of each
                } else {
                    if (isObj) {
                        for (name in object) {
                            if (callback.call(object[name], name, object[name]) === false) {
                                break;
                            }
                        }
                    } else {
                        for (; i < length; ) {
                            if (callback.call(object[i], i, object[i++]) === false) {
                                break;
                            }
                        }
                    }
                }

                return object;
            },

            // Use native String.trim function wherever possible
            trim: trim ?
		function (text) {
		    return text == null ?
				"" :
				trim.call(text);
		} :

            // Otherwise use our own trimming functionality
		function (text) {
		    return text == null ?
				"" :
				text.toString().replace(trimLeft, "").replace(trimRight, "");
		},

            // results is for internal usage only
            makeArray: function (array, results) {
                var ret = results || [];

                if (array != null) {
                    // The window, strings (and functions) also have 'length'
                    // The extra typeof function check is to prevent crashes
                    // in Safari 2 (See: #3039)
                    // Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
                    var type = jQuery.type(array);

                    if (array.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow(array)) {
                        push.call(ret, array);
                    } else {
                        jQuery.merge(ret, array);
                    }
                }

                return ret;
            },

            inArray: function (elem, array) {

                if (indexOf) {
                    return indexOf.call(array, elem);
                }

                for (var i = 0, length = array.length; i < length; i++) {
                    if (array[i] === elem) {
                        return i;
                    }
                }

                return -1;
            },

            merge: function (first, second) {
                var i = first.length,
			j = 0;

                if (typeof second.length === "number") {
                    for (var l = second.length; j < l; j++) {
                        first[i++] = second[j];
                    }

                } else {
                    while (second[j] !== undefined) {
                        first[i++] = second[j++];
                    }
                }

                first.length = i;

                return first;
            },

            grep: function (elems, callback, inv) {
                var ret = [], retVal;
                inv = !!inv;

                // Go through the array, only saving the items
                // that pass the validator function
                for (var i = 0, length = elems.length; i < length; i++) {
                    retVal = !!callback(elems[i], i);
                    if (inv !== retVal) {
                        ret.push(elems[i]);
                    }
                }

                return ret;
            },

            // arg is for internal usage only
            map: function (elems, callback, arg) {
                var value, key, ret = [],
			i = 0,
			length = elems.length,
                // jquery objects are treated as arrays
			isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ((length > 0 && elems[0] && elems[length - 1]) || length === 0 || jQuery.isArray(elems));

                // Go through the array, translating each of the items to their
                if (isArray) {
                    for (; i < length; i++) {
                        value = callback(elems[i], i, arg);

                        if (value != null) {
                            ret[ret.length] = value;
                        }
                    }

                    // Go through every key on the object,
                } else {
                    for (key in elems) {
                        value = callback(elems[key], key, arg);

                        if (value != null) {
                            ret[ret.length] = value;
                        }
                    }
                }

                // Flatten any nested arrays
                return ret.concat.apply([], ret);
            },

            // A global GUID counter for objects
            guid: 1,

            // Bind a function to a context, optionally partially applying any
            // arguments.
            proxy: function (fn, context) {
                if (typeof context === "string") {
                    var tmp = fn[context];
                    context = fn;
                    fn = tmp;
                }

                // Quick check to determine if target is callable, in the spec
                // this throws a TypeError, but we will just return undefined.
                if (!jQuery.isFunction(fn)) {
                    return undefined;
                }

                // Simulated bind
                var args = slice.call(arguments, 2),
			proxy = function () {
			    return fn.apply(context, args.concat(slice.call(arguments)));
			};

                // Set the guid of unique handler to the same of original handler, so it can be removed
                proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;

                return proxy;
            },

            // Mutifunctional method to get and set values to a collection
            // The value/s can optionally be executed if it's a function
            access: function (elems, key, value, exec, fn, pass) {
                var length = elems.length;

                // Setting many attributes
                if (typeof key === "object") {
                    for (var k in key) {
                        jQuery.access(elems, k, key[k], exec, fn, value);
                    }
                    return elems;
                }

                // Setting one attribute
                if (value !== undefined) {
                    // Optionally, function values get executed if exec is true
                    exec = !pass && exec && jQuery.isFunction(value);

                    for (var i = 0; i < length; i++) {
                        fn(elems[i], key, exec ? value.call(elems[i], i, fn(elems[i], key)) : value, pass);
                    }

                    return elems;
                }

                // Getting an attribute
                return length ? fn(elems[0], key) : undefined;
            },

            now: function () {
                return (new Date()).getTime();
            },

            // Use of jQuery.browser is frowned upon.
            // More details: http://docs.jquery.com/Utilities/jQuery.browser
            uaMatch: function (ua) {
                ua = ua.toLowerCase();

                // temp hack for IE11
                if (ua.match(/trident/i) && ua.match(/rv.\d\d/)) {
                    return { browser: "msie", version: "11.0"};
                }
                var match = rwebkit.exec(ua) ||
			ropera.exec(ua) ||
			rmsie.exec(ua) ||
			ua.indexOf("compatible") < 0 && rmozilla.exec(ua) ||
			[];

                return { browser: match[1] || "", version: match[2] || "0" };
            },

            sub: function () {
                function jQuerySub(selector, context) {
                    return new jQuerySub.fn.init(selector, context);
                }
                jQuery.extend(true, jQuerySub, this);
                jQuerySub.superclass = this;
                jQuerySub.fn = jQuerySub.prototype = this();
                jQuerySub.fn.constructor = jQuerySub;
                jQuerySub.sub = this.sub;
                jQuerySub.fn.init = function init(selector, context) {
                    if (context && context instanceof jQuery && !(context instanceof jQuerySub)) {
                        context = jQuerySub(context);
                    }

                    return jQuery.fn.init.call(this, selector, context, rootjQuerySub);
                };
                jQuerySub.fn.init.prototype = jQuerySub.fn;
                var rootjQuerySub = jQuerySub(document);
                return jQuerySub;
            },

            browser: {}
        });

        // Populate the class2type map
        jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function (i, name) {
            class2type["[object " + name + "]"] = name.toLowerCase();
        });

        browserMatch = jQuery.uaMatch(userAgent);
        if (browserMatch.browser) {
            jQuery.browser[browserMatch.browser] = true;
            jQuery.browser.version = browserMatch.version;
        }

        // Deprecated, use jQuery.browser.webkit instead
        if (jQuery.browser.webkit) {
            jQuery.browser.safari = /safari/i.test(userAgent) && !/chrome/i.test(userAgent);
        }

        // IE doesn't match non-breaking spaces with \s
        if (rnotwhite.test("\xA0")) {
            trimLeft = /^[\s\xA0]+/;
            trimRight = /[\s\xA0]+$/;
        }

        // All jQuery objects should point back to these
        rootjQuery = jQuery(document);

        // Cleanup functions for the document ready method
        if (document.addEventListener) {
            DOMContentLoaded = function () {
                document.removeEventListener("DOMContentLoaded", DOMContentLoaded, false);
                jQuery.ready();
            };

        } else if (document.attachEvent) {
            DOMContentLoaded = function () {
                // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
                if (document.readyState === "complete") {
                    document.detachEvent("onreadystatechange", DOMContentLoaded);
                    jQuery.ready();
                }
            };
        }

        // The DOM ready check for Internet Explorer
        function doScrollCheck() {
            if (jQuery.isReady) {
                return;
            }

            try {
                // If IE is used, use the trick by Diego Perini
                // http://javascript.nwbox.com/IEContentLoaded/
                document.documentElement.doScroll("left");
            } catch (e) {
                setTimeout(doScrollCheck, 1);
                return;
            }

            // and execute any waiting functions
            jQuery.ready();
        }

        return jQuery;

    })();


    var // Promise methods
	promiseMethods = "done fail isResolved isRejected promise then always pipe".split(" "),
    // Static reference to slice
	sliceDeferred = [].slice;

    jQuery.extend({
        // Create a simple deferred (one callbacks list)
        _Deferred: function () {
            var // callbacks list
			callbacks = [],
            // stored [ context , args ]
			fired,
            // to avoid firing when already doing so
			firing,
            // flag to know if the deferred has been cancelled
			cancelled,
            // the deferred itself
			deferred = {

			    // done( f1, f2, ...)
			    done: function () {
			        if (!cancelled) {
			            var args = arguments,
							i,
							length,
							elem,
							type,
							_fired;
			            if (fired) {
			                _fired = fired;
			                fired = 0;
			            }
			            for (i = 0, length = args.length; i < length; i++) {
			                elem = args[i];
			                type = jQuery.type(elem);
			                if (type === "array") {
			                    deferred.done.apply(deferred, elem);
			                } else if (type === "function") {
			                    callbacks.push(elem);
			                }
			            }
			            if (_fired) {
			                deferred.resolveWith(_fired[0], _fired[1]);
			            }
			        }
			        return this;
			    },

			    // resolve with given context and args
			    resolveWith: function (context, args) {
			        if (!cancelled && !fired && !firing) {
			            // make sure args are available (#8421)
			            args = args || [];
			            firing = 1;
			            try {
			                while (callbacks[0]) {
			                    callbacks.shift().apply(context, args);
			                }
			            }
			            finally {
			                fired = [context, args];
			                firing = 0;
			            }
			        }
			        return this;
			    },

			    // resolve with this as context and given arguments
			    resolve: function () {
			        deferred.resolveWith(this, arguments);
			        return this;
			    },

			    // Has this deferred been resolved?
			    isResolved: function () {
			        return !!(firing || fired);
			    },

			    // Cancel
			    cancel: function () {
			        cancelled = 1;
			        callbacks = [];
			        return this;
			    }
			};

            return deferred;
        },

        // Full fledged deferred (two callbacks list)
        Deferred: function (func) {
            var deferred = jQuery._Deferred(),
			failDeferred = jQuery._Deferred(),
			promise;
            // Add errorDeferred methods, then and promise
            jQuery.extend(deferred, {
                then: function (doneCallbacks, failCallbacks) {
                    deferred.done(doneCallbacks).fail(failCallbacks);
                    return this;
                },
                always: function () {
                    return deferred.done.apply(deferred, arguments).fail.apply(this, arguments);
                },
                fail: failDeferred.done,
                rejectWith: failDeferred.resolveWith,
                reject: failDeferred.resolve,
                isRejected: failDeferred.isResolved,
                pipe: function (fnDone, fnFail) {
                    return jQuery.Deferred(function (newDefer) {
                        jQuery.each({
                            done: [fnDone, "resolve"],
                            fail: [fnFail, "reject"]
                        }, function (handler, data) {
                            var fn = data[0],
							action = data[1],
							returned;
                            if (jQuery.isFunction(fn)) {
                                deferred[handler](function () {
                                    returned = fn.apply(this, arguments);
                                    if (returned && jQuery.isFunction(returned.promise)) {
                                        returned.promise().then(newDefer.resolve, newDefer.reject);
                                    } else {
                                        newDefer[action](returned);
                                    }
                                });
                            } else {
                                deferred[handler](newDefer[action]);
                            }
                        });
                    }).promise();
                },
                // Get a promise for this deferred
                // If obj is provided, the promise aspect is added to the object
                promise: function (obj) {
                    if (obj == null) {
                        if (promise) {
                            return promise;
                        }
                        promise = obj = {};
                    }
                    var i = promiseMethods.length;
                    while (i--) {
                        obj[promiseMethods[i]] = deferred[promiseMethods[i]];
                    }
                    return obj;
                }
            });
            // Make sure only one callback list will be used
            deferred.done(failDeferred.cancel).fail(deferred.cancel);
            // Unexpose cancel
            delete deferred.cancel;
            // Call given func if any
            if (func) {
                func.call(deferred, deferred);
            }
            return deferred;
        },

        // Deferred helper
        when: function (firstParam) {
            var args = arguments,
			i = 0,
			length = args.length,
			count = length,
			deferred = length <= 1 && firstParam && jQuery.isFunction(firstParam.promise) ?
				firstParam :
				jQuery.Deferred();
            function resolveFunc(i) {
                return function (value) {
                    args[i] = arguments.length > 1 ? sliceDeferred.call(arguments, 0) : value;
                    if (!(--count)) {
                        // Strange bug in FF4:
                        // Values changed onto the arguments object sometimes end up as undefined values
                        // outside the $.when method. Cloning the object into a fresh array solves the issue
                        deferred.resolveWith(deferred, sliceDeferred.call(args, 0));
                    }
                };
            }
            if (length > 1) {
                for (; i < length; i++) {
                    if (args[i] && jQuery.isFunction(args[i].promise)) {
                        args[i].promise().then(resolveFunc(i), deferred.reject);
                    } else {
                        --count;
                    }
                }
                if (!count) {
                    deferred.resolveWith(deferred, args);
                }
            } else if (deferred !== firstParam) {
                deferred.resolveWith(deferred, length ? [firstParam] : []);
            }
            return deferred.promise();
        }
    });



    jQuery.support = (function () {

        var div = document.createElement("div"),
		documentElement = document.documentElement,
		all,
		a,
		select,
		opt,
		input,
		marginDiv,
		support,
		fragment,
		body,
		testElementParent,
		testElement,
		testElementStyle,
		tds,
		events,
		eventName,
		i,
		isSupported;

        // Preliminary tests
        div.setAttribute("className", "t");
        div.innerHTML = "   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>";

        all = div.getElementsByTagName("*");
        a = div.getElementsByTagName("a")[0];

        // Can't get basic test support
        if (!all || !all.length || !a) {
            return {};
        }

        // First batch of supports tests
        select = document.createElement("select");
        opt = select.appendChild(document.createElement("option"));
        input = div.getElementsByTagName("input")[0];

        support = {
            // IE strips leading whitespace when .innerHTML is used
            leadingWhitespace: (div.firstChild.nodeType === 3),

            // Make sure that tbody elements aren't automatically inserted
            // IE will insert them into empty tables
            tbody: !div.getElementsByTagName("tbody").length,

            // Make sure that link elements get serialized correctly by innerHTML
            // This requires a wrapper element in IE
            htmlSerialize: !!div.getElementsByTagName("link").length,

            // Get the style information from getAttribute
            // (IE uses .cssText instead)
            style: /top/.test(a.getAttribute("style")),

            // Make sure that URLs aren't manipulated
            // (IE normalizes it by default)
            hrefNormalized: (a.getAttribute("href") === "/a"),

            // Make sure that element opacity exists
            // (IE uses filter instead)
            // Use a regex to work around a WebKit issue. See #5145
            opacity: /^0.55$/.test(a.style.opacity),

            // Verify style float existence
            // (IE uses styleFloat instead of cssFloat)
            cssFloat: !!a.style.cssFloat,

            // Make sure that if no value is specified for a checkbox
            // that it defaults to "on".
            // (WebKit defaults to "" instead)
            checkOn: (input.value === "on"),

            // Make sure that a selected-by-default option has a working selected property.
            // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
            optSelected: opt.selected,

            // Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
            getSetAttribute: div.className !== "t",

            // Will be defined later
            submitBubbles: true,
            changeBubbles: true,
            focusinBubbles: false,
            deleteExpando: true,
            noCloneEvent: true,
            inlineBlockNeedsLayout: false,
            shrinkWrapBlocks: false,
            reliableMarginRight: true
        };

        // Make sure checked status is properly cloned
        input.checked = true;
        support.noCloneChecked = input.cloneNode(true).checked;

        // Make sure that the options inside disabled selects aren't marked as disabled
        // (WebKit marks them as disabled)
        select.disabled = true;
        support.optDisabled = !opt.disabled;

        // Test to see if it's possible to delete an expando from an element
        // Fails in Internet Explorer
        try {
            delete div.test;
        } catch (e) {
            support.deleteExpando = false;
        }

        if (!div.addEventListener && div.attachEvent && div.fireEvent) {
            div.attachEvent("onclick", function () {
                // Cloning a node shouldn't copy over any
                // bound event handlers (IE does this)
                support.noCloneEvent = false;
            });
            div.cloneNode(true).fireEvent("onclick");
        }

        // Check if a radio maintains it's value
        // after being appended to the DOM
        input = document.createElement("input");
        input.value = "t";
        input.setAttribute("type", "radio");
        support.radioValue = input.value === "t";

        input.setAttribute("checked", "checked");
        div.appendChild(input);
        fragment = document.createDocumentFragment();
        fragment.appendChild(div.firstChild);

        // WebKit doesn't clone checked state correctly in fragments
        support.checkClone = fragment.cloneNode(true).cloneNode(true).lastChild.checked;

        div.innerHTML = "";

        // Figure out if the W3C box model works as expected
        div.style.width = div.style.paddingLeft = "1px";

        body = document.getElementsByTagName("body")[0];
        // We use our own, invisible, body unless the body is already present
        // in which case we use a div (#9239)
        testElement = document.createElement(body ? "div" : "body");
        testElementStyle = {
            visibility: "hidden",
            width: 0,
            height: 0,
            border: 0,
            margin: 0
        };
        if (body) {
            jQuery.extend(testElementStyle, {
                position: "absolute",
                left: -1000,
                top: -1000
            });
        }
        for (i in testElementStyle) {
            testElement.style[i] = testElementStyle[i];
        }
        testElement.appendChild(div);
        testElementParent = body || documentElement;
        testElementParent.insertBefore(testElement, testElementParent.firstChild);

        // Check if a disconnected checkbox will retain its checked
        // value of true after appended to the DOM (IE6/7)
        support.appendChecked = input.checked;

        support.boxModel = div.offsetWidth === 2;

        if ("zoom" in div.style) {
            // Check if natively block-level elements act like inline-block
            // elements when setting their display to 'inline' and giving
            // them layout
            // (IE < 8 does this)
            div.style.display = "inline";
            div.style.zoom = 1;
            support.inlineBlockNeedsLayout = (div.offsetWidth === 2);

            // Check if elements with layout shrink-wrap their children
            // (IE 6 does this)
            div.style.display = "";
            div.innerHTML = "<div style='width:4px;'></div>";
            support.shrinkWrapBlocks = (div.offsetWidth !== 2);
        }

        div.innerHTML = "<table><tr><td style='padding:0;border:0;display:none'></td><td>t</td></tr></table>";
        tds = div.getElementsByTagName("td");

        // Check if table cells still have offsetWidth/Height when they are set
        // to display:none and there are still other visible table cells in a
        // table row; if so, offsetWidth/Height are not reliable for use when
        // determining if an element has been hidden directly using
        // display:none (it is still safe to use offsets if a parent element is
        // hidden; don safety goggles and see bug #4512 for more information).
        // (only IE 8 fails this test)
        isSupported = (tds[0].offsetHeight === 0);

        tds[0].style.display = "";
        tds[1].style.display = "none";

        // Check if empty table cells still have offsetWidth/Height
        // (IE < 8 fail this test)
        support.reliableHiddenOffsets = isSupported && (tds[0].offsetHeight === 0);
        div.innerHTML = "";

        // Check if div with explicit width and no margin-right incorrectly
        // gets computed margin-right based on width of container. For more
        // info see bug #3333
        // Fails in WebKit before Feb 2011 nightlies
        // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
        if (document.defaultView && document.defaultView.getComputedStyle) {
            marginDiv = document.createElement("div");
            marginDiv.style.width = "0";
            marginDiv.style.marginRight = "0";
            div.appendChild(marginDiv);
            support.reliableMarginRight =
			(parseInt((document.defaultView.getComputedStyle(marginDiv, null) || { marginRight: 0 }).marginRight, 10) || 0) === 0;
        }

        // Remove the body element we added
        testElement.innerHTML = "";
        testElementParent.removeChild(testElement);

        // Technique from Juriy Zaytsev
        // http://thinkweb2.com/projects/prototype/detecting-event-support-without-browser-sniffing/
        // We only care about the case where non-standard event systems
        // are used, namely in IE. Short-circuiting here helps us to
        // avoid an eval call (in setAttribute) which can cause CSP
        // to go haywire. See: https://developer.mozilla.org/en/Security/CSP
        if (div.attachEvent) {
            for (i in {
                submit: 1,
                change: 1,
                focusin: 1
            }) {
                eventName = "on" + i;
                isSupported = (eventName in div);
                if (!isSupported) {
                    div.setAttribute(eventName, "return;");
                    isSupported = (typeof div[eventName] === "function");
                }
                support[i + "Bubbles"] = isSupported;
            }
        }

        // Null connected elements to avoid leaks in IE
        testElement = fragment = select = opt = body = marginDiv = div = input = null;

        return support;
    })();

    // Keep track of boxModel
    jQuery.boxModel = jQuery.support.boxModel;




    var rbrace = /^(?:\{.*\}|\[.*\])$/,
	rmultiDash = /([a-z])([A-Z])/g;

    jQuery.extend({
        cache: {},

        // Please use with caution
        uuid: 0,

        // Unique for each copy of jQuery on the page
        // Non-digits removed to match rinlinejQuery
        expando: "jQuery" + (jQuery.fn.jquery + Math.random()).replace(/\D/g, ""),

        // The following elements throw uncatchable exceptions if you
        // attempt to add expando properties to them.
        noData: {
            "embed": true,
            // Ban all objects except for Flash (which handle expandos)
            "object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
            "applet": true
        },

        hasData: function (elem) {
            elem = elem.nodeType ? jQuery.cache[elem[jQuery.expando]] : elem[jQuery.expando];

            return !!elem && !isEmptyDataObject(elem);
        },

        data: function (elem, name, data, pvt /* Internal Use Only */) {
            if (!jQuery.acceptData(elem)) {
                return;
            }

            var internalKey = jQuery.expando, getByName = typeof name === "string", thisCache,

            // We have to handle DOM nodes and JS objects differently because IE6-7
            // can't GC object references properly across the DOM-JS boundary
			isNode = elem.nodeType,

            // Only DOM nodes need the global jQuery cache; JS object data is
            // attached directly to the object so GC can occur automatically
			cache = isNode ? jQuery.cache : elem,

            // Only defining an ID for JS objects if its cache already exists allows
            // the code to shortcut on the same path as a DOM node with no cache
			id = isNode ? elem[jQuery.expando] : elem[jQuery.expando] && jQuery.expando;

            // Avoid doing any more work than we need to when trying to get data on an
            // object that has no data at all
            if ((!id || (pvt && id && !cache[id][internalKey])) && getByName && data === undefined) {
                return;
            }

            if (!id) {
                // Only DOM nodes need a new unique ID for each element since their data
                // ends up in the global cache
                if (isNode) {
                    elem[jQuery.expando] = id = ++jQuery.uuid;
                } else {
                    id = jQuery.expando;
                }
            }

            if (!cache[id]) {
                cache[id] = {};

                // TODO: This is a hack for 1.5 ONLY. Avoids exposing jQuery
                // metadata on plain JS objects when the object is serialized using
                // JSON.stringify
                if (!isNode) {
                    cache[id].toJSON = jQuery.noop;
                }
            }

            // An object can be passed to jQuery.data instead of a key/value pair; this gets
            // shallow copied over onto the existing cache
            if (typeof name === "object" || typeof name === "function") {
                if (pvt) {
                    cache[id][internalKey] = jQuery.extend(cache[id][internalKey], name);
                } else {
                    cache[id] = jQuery.extend(cache[id], name);
                }
            }

            thisCache = cache[id];

            // Internal jQuery data is stored in a separate object inside the object's data
            // cache in order to avoid key collisions between internal data and user-defined
            // data
            if (pvt) {
                if (!thisCache[internalKey]) {
                    thisCache[internalKey] = {};
                }

                thisCache = thisCache[internalKey];
            }

            if (data !== undefined) {
                thisCache[jQuery.camelCase(name)] = data;
            }

            // TODO: This is a hack for 1.5 ONLY. It will be removed in 1.6. Users should
            // not attempt to inspect the internal events object using jQuery.data, as this
            // internal data object is undocumented and subject to change.
            if (name === "events" && !thisCache[name]) {
                return thisCache[internalKey] && thisCache[internalKey].events;
            }

            return getByName ?
            // Check for both converted-to-camel and non-converted data property names
			thisCache[jQuery.camelCase(name)] || thisCache[name] :
			thisCache;
        },

        removeData: function (elem, name, pvt /* Internal Use Only */) {
            if (!jQuery.acceptData(elem)) {
                return;
            }

            var internalKey = jQuery.expando, isNode = elem.nodeType,

            // See jQuery.data for more information
			cache = isNode ? jQuery.cache : elem,

            // See jQuery.data for more information
			id = isNode ? elem[jQuery.expando] : jQuery.expando;

            // If there is already no cache entry for this object, there is no
            // purpose in continuing
            if (!cache[id]) {
                return;
            }

            if (name) {
                var thisCache = pvt ? cache[id][internalKey] : cache[id];

                if (thisCache) {
                    delete thisCache[name];

                    // If there is no data left in the cache, we want to continue
                    // and let the cache object itself get destroyed
                    if (!isEmptyDataObject(thisCache)) {
                        return;
                    }
                }
            }

            // See jQuery.data for more information
            if (pvt) {
                delete cache[id][internalKey];

                // Don't destroy the parent cache unless the internal data object
                // had been the only thing left in it
                if (!isEmptyDataObject(cache[id])) {
                    return;
                }
            }

            var internalCache = cache[id][internalKey];

            // Browsers that fail expando deletion also refuse to delete expandos on
            // the window, but it will allow it on all other JS objects; other browsers
            // don't care
            if (jQuery.support.deleteExpando || cache != window) {
                delete cache[id];
            } else {
                cache[id] = null;
            }

            // We destroyed the entire user cache at once because it's faster than
            // iterating through each key, but we need to continue to persist internal
            // data if it existed
            if (internalCache) {
                cache[id] = {};
                // TODO: This is a hack for 1.5 ONLY. Avoids exposing jQuery
                // metadata on plain JS objects when the object is serialized using
                // JSON.stringify
                if (!isNode) {
                    cache[id].toJSON = jQuery.noop;
                }

                cache[id][internalKey] = internalCache;

                // Otherwise, we need to eliminate the expando on the node to avoid
                // false lookups in the cache for entries that no longer exist
            } else if (isNode) {
                // IE does not allow us to delete expando properties from nodes,
                // nor does it have a removeAttribute function on Document nodes;
                // we must handle all of these cases
                if (jQuery.support.deleteExpando) {
                    delete elem[jQuery.expando];
                } else if (elem.removeAttribute) {
                    elem.removeAttribute(jQuery.expando);
                } else {
                    elem[jQuery.expando] = null;
                }
            }
        },

        // For internal use only.
        _data: function (elem, name, data) {
            return jQuery.data(elem, name, data, true);
        },

        // A method for determining if a DOM node can handle the data expando
        acceptData: function (elem) {
            if (elem.nodeName) {
                var match = jQuery.noData[elem.nodeName.toLowerCase()];

                if (match) {
                    return !(match === true || elem.getAttribute("classid") !== match);
                }
            }

            return true;
        }
    });

    jQuery.fn.extend({
        data: function (key, value) {
            var data = null;

            if (typeof key === "undefined") {
                if (this.length) {
                    data = jQuery.data(this[0]);

                    if (this[0].nodeType === 1) {
                        var attr = this[0].attributes, name;
                        for (var i = 0, l = attr.length; i < l; i++) {
                            name = attr[i].name;

                            if (name.indexOf("data-") === 0) {
                                name = jQuery.camelCase(name.substring(5));

                                dataAttr(this[0], name, data[name]);
                            }
                        }
                    }
                }

                return data;

            } else if (typeof key === "object") {
                return this.each(function () {
                    jQuery.data(this, key);
                });
            }

            var parts = key.split(".");
            parts[1] = parts[1] ? "." + parts[1] : "";

            if (value === undefined) {
                data = this.triggerHandler("getData" + parts[1] + "!", [parts[0]]);

                // Try to fetch any internally stored data first
                if (data === undefined && this.length) {
                    data = jQuery.data(this[0], key);
                    data = dataAttr(this[0], key, data);
                }

                return data === undefined && parts[1] ?
				this.data(parts[0]) :
				data;

            } else {
                return this.each(function () {
                    var $this = jQuery(this),
					args = [parts[0], value];

                    $this.triggerHandler("setData" + parts[1] + "!", args);
                    jQuery.data(this, key, value);
                    $this.triggerHandler("changeData" + parts[1] + "!", args);
                });
            }
        },

        removeData: function (key) {
            return this.each(function () {
                jQuery.removeData(this, key);
            });
        }
    });

    function dataAttr(elem, key, data) {
        // If nothing was found internally, try to fetch any
        // data from the HTML5 data-* attribute
        if (data === undefined && elem.nodeType === 1) {
            var name = "data-" + key.replace(rmultiDash, "$1-$2").toLowerCase();

            data = elem.getAttribute(name);

            if (typeof data === "string") {
                try {
                    data = data === "true" ? true :
				data === "false" ? false :
				data === "null" ? null :
				!jQuery.isNaN(data) ? parseFloat(data) :
					rbrace.test(data) ? jQuery.parseJSON(data) :
					data;
                } catch (e) { }

                // Make sure we set the data so it isn't changed later
                jQuery.data(elem, key, data);

            } else {
                data = undefined;
            }
        }

        return data;
    }

    // TODO: This is a hack for 1.5 ONLY to allow objects with a single toJSON
    // property to be considered empty objects; this property always exists in
    // order to make sure JSON.stringify does not expose internal metadata
    function isEmptyDataObject(obj) {
        for (var name in obj) {
            if (name !== "toJSON") {
                return false;
            }
        }

        return true;
    }




    function handleQueueMarkDefer(elem, type, src) {
        var deferDataKey = type + "defer",
		queueDataKey = type + "queue",
		markDataKey = type + "mark",
		defer = jQuery.data(elem, deferDataKey, undefined, true);
        if (defer &&
		(src === "queue" || !jQuery.data(elem, queueDataKey, undefined, true)) &&
		(src === "mark" || !jQuery.data(elem, markDataKey, undefined, true))) {
            // Give room for hard-coded callbacks to fire first
            // and eventually mark/queue something else on the element
            setTimeout(function () {
                if (!jQuery.data(elem, queueDataKey, undefined, true) &&
				!jQuery.data(elem, markDataKey, undefined, true)) {
                    jQuery.removeData(elem, deferDataKey, true);
                    defer.resolve();
                }
            }, 0);
        }
    }

    jQuery.extend({

        _mark: function (elem, type) {
            if (elem) {
                type = (type || "fx") + "mark";
                jQuery.data(elem, type, (jQuery.data(elem, type, undefined, true) || 0) + 1, true);
            }
        },

        _unmark: function (force, elem, type) {
            if (force !== true) {
                type = elem;
                elem = force;
                force = false;
            }
            if (elem) {
                type = type || "fx";
                var key = type + "mark",
				count = force ? 0 : ((jQuery.data(elem, key, undefined, true) || 1) - 1);
                if (count) {
                    jQuery.data(elem, key, count, true);
                } else {
                    jQuery.removeData(elem, key, true);
                    handleQueueMarkDefer(elem, type, "mark");
                }
            }
        },

        queue: function (elem, type, data) {
            if (elem) {
                type = (type || "fx") + "queue";
                var q = jQuery.data(elem, type, undefined, true);
                // Speed up dequeue by getting out quickly if this is just a lookup
                if (data) {
                    if (!q || jQuery.isArray(data)) {
                        q = jQuery.data(elem, type, jQuery.makeArray(data), true);
                    } else {
                        q.push(data);
                    }
                }
                return q || [];
            }
        },

        dequeue: function (elem, type) {
            type = type || "fx";

            var queue = jQuery.queue(elem, type),
			fn = queue.shift(),
			defer;

            // If the fx queue is dequeued, always remove the progress sentinel
            if (fn === "inprogress") {
                fn = queue.shift();
            }

            if (fn) {
                // Add a progress sentinel to prevent the fx queue from being
                // automatically dequeued
                if (type === "fx") {
                    queue.unshift("inprogress");
                }

                fn.call(elem, function () {
                    jQuery.dequeue(elem, type);
                });
            }

            if (!queue.length) {
                jQuery.removeData(elem, type + "queue", true);
                handleQueueMarkDefer(elem, type, "queue");
            }
        }
    });

    jQuery.fn.extend({
        queue: function (type, data) {
            if (typeof type !== "string") {
                data = type;
                type = "fx";
            }

            if (data === undefined) {
                return jQuery.queue(this[0], type);
            }
            return this.each(function () {
                var queue = jQuery.queue(this, type, data);

                if (type === "fx" && queue[0] !== "inprogress") {
                    jQuery.dequeue(this, type);
                }
            });
        },
        dequeue: function (type) {
            return this.each(function () {
                jQuery.dequeue(this, type);
            });
        },
        // Based off of the plugin by Clint Helfers, with permission.
        // http://blindsignals.com/index.php/2009/07/jquery-delay/
        delay: function (time, type) {
            time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
            type = type || "fx";

            return this.queue(type, function () {
                var elem = this;
                setTimeout(function () {
                    jQuery.dequeue(elem, type);
                }, time);
            });
        },
        clearQueue: function (type) {
            return this.queue(type || "fx", []);
        },
        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function (type, object) {
            if (typeof type !== "string") {
                object = type;
                type = undefined;
            }
            type = type || "fx";
            var defer = jQuery.Deferred(),
			elements = this,
			i = elements.length,
			count = 1,
			deferDataKey = type + "defer",
			queueDataKey = type + "queue",
			markDataKey = type + "mark",
			tmp;
            function resolve() {
                if (!(--count)) {
                    defer.resolveWith(elements, [elements]);
                }
            }
            while (i--) {
                if ((tmp = jQuery.data(elements[i], deferDataKey, undefined, true) ||
					(jQuery.data(elements[i], queueDataKey, undefined, true) ||
						jQuery.data(elements[i], markDataKey, undefined, true)) &&
					jQuery.data(elements[i], deferDataKey, jQuery._Deferred(), true))) {
                    count++;
                    tmp.done(resolve);
                }
            }
            resolve();
            return defer.promise();
        }
    });




    var rclass = /[\n\t\r]/g,
	rspace = /\s+/,
	rreturn = /\r/g,
	rtype = /^(?:button|input)$/i,
	rfocusable = /^(?:button|input|object|select|textarea)$/i,
	rclickable = /^a(?:rea)?$/i,
	rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
	rinvalidChar = /\:|^on/,
	formHook, boolHook;

    jQuery.fn.extend({
        attr: function (name, value) {
            return jQuery.access(this, name, value, true, jQuery.attr);
        },

        removeAttr: function (name) {
            return this.each(function () {
                jQuery.removeAttr(this, name);
            });
        },

        prop: function (name, value) {
            return jQuery.access(this, name, value, true, jQuery.prop);
        },

        removeProp: function (name) {
            name = jQuery.propFix[name] || name;
            return this.each(function () {
                // try/catch handles cases where IE balks (such as removing a property on window)
                try {
                    this[name] = undefined;
                    delete this[name];
                } catch (e) { }
            });
        },

        addClass: function (value) {
            var classNames, i, l, elem,
			setClass, c, cl;

            if (jQuery.isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).addClass(value.call(this, j, this.className));
                });
            }

            if (value && typeof value === "string") {
                classNames = value.split(rspace);

                for (i = 0, l = this.length; i < l; i++) {
                    elem = this[i];

                    if (elem.nodeType === 1) {
                        if (!elem.className && classNames.length === 1) {
                            elem.className = value;

                        } else {
                            setClass = " " + elem.className + " ";

                            for (c = 0, cl = classNames.length; c < cl; c++) {
                                if (! ~setClass.indexOf(" " + classNames[c] + " ")) {
                                    setClass += classNames[c] + " ";
                                }
                            }
                            elem.className = jQuery.trim(setClass);
                        }
                    }
                }
            }

            return this;
        },

        removeClass: function (value) {
            var classNames, i, l, elem, className, c, cl;

            if (jQuery.isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).removeClass(value.call(this, j, this.className));
                });
            }

            if ((value && typeof value === "string") || value === undefined) {
                classNames = (value || "").split(rspace);

                for (i = 0, l = this.length; i < l; i++) {
                    elem = this[i];

                    if (elem.nodeType === 1 && elem.className) {
                        if (value) {
                            className = (" " + elem.className + " ").replace(rclass, " ");
                            for (c = 0, cl = classNames.length; c < cl; c++) {
                                className = className.replace(" " + classNames[c] + " ", " ");
                            }
                            elem.className = jQuery.trim(className);

                        } else {
                            elem.className = "";
                        }
                    }
                }
            }

            return this;
        },

        toggleClass: function (value, stateVal) {
            var type = typeof value,
			isBool = typeof stateVal === "boolean";

            if (jQuery.isFunction(value)) {
                return this.each(function (i) {
                    jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
                });
            }

            return this.each(function () {
                if (type === "string") {
                    // toggle individual class names
                    var className,
					i = 0,
					self = jQuery(this),
					state = stateVal,
					classNames = value.split(rspace);

                    while ((className = classNames[i++])) {
                        // check each className given, space seperated list
                        state = isBool ? state : !self.hasClass(className);
                        self[state ? "addClass" : "removeClass"](className);
                    }

                } else if (type === "undefined" || type === "boolean") {
                    if (this.className) {
                        // store className if set
                        jQuery._data(this, "__className__", this.className);
                    }

                    // toggle whole className
                    this.className = this.className || value === false ? "" : jQuery._data(this, "__className__") || "";
                }
            });
        },

        hasClass: function (selector) {
            var className = " " + selector + " ";
            for (var i = 0, l = this.length; i < l; i++) {
                if ((" " + this[i].className + " ").replace(rclass, " ").indexOf(className) > -1) {
                    return true;
                }
            }

            return false;
        },

        val: function (value) {
            var hooks, ret,
			elem = this[0];

            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.nodeName.toLowerCase()] || jQuery.valHooks[elem.type];

                    if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
                        return ret;
                    }

                    ret = elem.value;

                    return typeof ret === "string" ?
                    // handle most common string cases
					ret.replace(rreturn, "") :
                    // handle cases where value is null/undef or number
					ret == null ? "" : ret;
                }

                return undefined;
            }

            var isFunction = jQuery.isFunction(value);

            return this.each(function (i) {
                var self = jQuery(this), val;

                if (this.nodeType !== 1) {
                    return;
                }

                if (isFunction) {
                    val = value.call(this, i, self.val());
                } else {
                    val = value;
                }

                // Treat null/undefined as ""; convert numbers to string
                if (val == null) {
                    val = "";
                } else if (typeof val === "number") {
                    val += "";
                } else if (jQuery.isArray(val)) {
                    val = jQuery.map(val, function (value) {
                        return value == null ? "" : value + "";
                    });
                }

                hooks = jQuery.valHooks[this.nodeName.toLowerCase()] || jQuery.valHooks[this.type];

                // If set returns undefined, fall back to normal setting
                if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
                    this.value = val;
                }
            });
        }
    });

    jQuery.extend({
        valHooks: {
            option: {
                get: function (elem) {
                    // attributes.value is undefined in Blackberry 4.7 but
                    // uses .value. See #6932
                    var val = elem.attributes.value;
                    return !val || val.specified ? elem.value : elem.text;
                }
            },
            select: {
                get: function (elem) {
                    var value,
					index = elem.selectedIndex,
					values = [],
					options = elem.options,
					one = elem.type === "select-one";

                    // Nothing was selected
                    if (index < 0) {
                        return null;
                    }

                    // Loop through all the selected options
                    for (var i = one ? index : 0, max = one ? index + 1 : options.length; i < max; i++) {
                        var option = options[i];

                        // Don't return options that are disabled or in a disabled optgroup
                        if (option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
							(!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {

                            // Get the specific value for the option
                            value = jQuery(option).val();

                            // We don't need an array for one selects
                            if (one) {
                                return value;
                            }

                            // Multi-Selects return an array
                            values.push(value);
                        }
                    }

                    // Fixes Bug #2551 -- select.val() broken in IE after form.reset()
                    if (one && !values.length && options.length) {
                        return jQuery(options[index]).val();
                    }

                    return values;
                },

                set: function (elem, value) {
                    var values = jQuery.makeArray(value);

                    jQuery(elem).find("option").each(function () {
                        this.selected = jQuery.inArray(jQuery(this).val(), values) >= 0;
                    });

                    if (!values.length) {
                        elem.selectedIndex = -1;
                    }
                    return values;
                }
            }
        },

        attrFn: {
            val: true,
            css: true,
            html: true,
            text: true,
            data: true,
            width: true,
            height: true,
            offset: true
        },

        attrFix: {
            // Always normalize to ensure hook usage
            tabindex: "tabIndex"
        },

        attr: function (elem, name, value, pass) {
            var nType = elem.nodeType;

            // don't get/set attributes on text, comment and attribute nodes
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return undefined;
            }

            if (pass && name in jQuery.attrFn) {
                return jQuery(elem)[name](value);
            }

            // Fallback to prop when attributes are not supported
            if (!("getAttribute" in elem)) {
                return jQuery.prop(elem, name, value);
            }

            var ret, hooks,
			notxml = nType !== 1 || !jQuery.isXMLDoc(elem);

            // Normalize the name if needed
            if (notxml) {
                name = jQuery.attrFix[name] || name;

                hooks = jQuery.attrHooks[name];

                if (!hooks) {
                    // Use boolHook for boolean attributes
                    if (rboolean.test(name)) {

                        hooks = boolHook;

                        // Use formHook for forms and if the name contains certain characters
                    } else if (formHook && name !== "className" &&
					(jQuery.nodeName(elem, "form") || rinvalidChar.test(name))) {

                        hooks = formHook;
                    }
                }
            }

            if (value !== undefined) {

                if (value === null) {
                    jQuery.removeAttr(elem, name);
                    return undefined;

                } else if (hooks && "set" in hooks && notxml && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;

                } else {
                    elem.setAttribute(name, "" + value);
                    return value;
                }

            } else if (hooks && "get" in hooks && notxml && (ret = hooks.get(elem, name)) !== null) {
                return ret;

            } else {

                ret = elem.getAttribute(name);

                // Non-existent attributes return null, we normalize to undefined
                return ret === null ?
				undefined :
				ret;
            }
        },

        removeAttr: function (elem, name) {
            var propName;
            if (elem.nodeType === 1) {
                name = jQuery.attrFix[name] || name;

                if (jQuery.support.getSetAttribute) {
                    // Use removeAttribute in browsers that support it
                    elem.removeAttribute(name);
                } else {
                    jQuery.attr(elem, name, "");
                    elem.removeAttributeNode(elem.getAttributeNode(name));
                }

                // Set corresponding property to false for boolean attributes
                if (rboolean.test(name) && (propName = jQuery.propFix[name] || name) in elem) {
                    elem[propName] = false;
                }
            }
        },

        attrHooks: {
            type: {
                set: function (elem, value) {
                    // We can't allow the type property to be changed (since it causes problems in IE)
                    if (rtype.test(elem.nodeName) && elem.parentNode) {
                        jQuery.error("type property can't be changed");
                    } else if (!jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
                        // Setting the type on a radio button after the value resets the value in IE6-9
                        // Reset value to it's default in case type is set after value
                        // This is for element creation
                        var val = elem.value;
                        elem.setAttribute("type", value);
                        if (val) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            },
            tabIndex: {
                get: function (elem) {
                    // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
                    // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                    var attributeNode = elem.getAttributeNode("tabIndex");

                    return attributeNode && attributeNode.specified ?
					parseInt(attributeNode.value, 10) :
					rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ?
						0 :
						undefined;
                }
            },
            // Use the value property for back compat
            // Use the formHook for button elements in IE6/7 (#1954)
            value: {
                get: function (elem, name) {
                    if (formHook && jQuery.nodeName(elem, "button")) {
                        return formHook.get(elem, name);
                    }
                    return name in elem ?
					elem.value :
					null;
                },
                set: function (elem, value, name) {
                    if (formHook && jQuery.nodeName(elem, "button")) {
                        return formHook.set(elem, value, name);
                    }
                    // Does not return so that setAttribute is also used
                    elem.value = value;
                }
            }
        },

        propFix: {
            tabindex: "tabIndex",
            readonly: "readOnly",
            "for": "htmlFor",
            "class": "className",
            maxlength: "maxLength",
            cellspacing: "cellSpacing",
            cellpadding: "cellPadding",
            rowspan: "rowSpan",
            colspan: "colSpan",
            usemap: "useMap",
            frameborder: "frameBorder",
            contenteditable: "contentEditable"
        },

        prop: function (elem, name, value) {
            var nType = elem.nodeType;

            // don't get/set properties on text, comment and attribute nodes
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return undefined;
            }

            var ret, hooks,
			notxml = nType !== 1 || !jQuery.isXMLDoc(elem);

            if (notxml) {
                // Fix name and attach hooks
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
            }

            if (value !== undefined) {
                if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;

                } else {
                    return (elem[name] = value);
                }

            } else {
                if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== undefined) {
                    return ret;

                } else {
                    return elem[name];
                }
            }
        },

        propHooks: {}
    });

    // Hook for boolean attributes
    boolHook = {
        get: function (elem, name) {
            // Align boolean attributes with corresponding properties
            return jQuery.prop(elem, name) ?
			name.toLowerCase() :
			undefined;
        },
        set: function (elem, value, name) {
            var propName;
            if (value === false) {
                // Remove boolean attributes when set to false
                jQuery.removeAttr(elem, name);
            } else {
                // value is true since we know at this point it's type boolean and not false
                // Set boolean attributes to the same name and set the DOM property
                propName = jQuery.propFix[name] || name;
                if (propName in elem) {
                    // Only set the IDL specifically if it already exists on the element
                    elem[propName] = true;
                }

                elem.setAttribute(name, name.toLowerCase());
            }
            return name;
        }
    };

    // IE6/7 do not support getting/setting some attributes with get/setAttribute
    if (!jQuery.support.getSetAttribute) {

        // propFix is more comprehensive and contains all fixes
        jQuery.attrFix = jQuery.propFix;

        // Use this for any attribute on a form in IE6/7
        formHook = jQuery.attrHooks.name = jQuery.attrHooks.title = jQuery.valHooks.button = {
            get: function (elem, name) {
                var ret;
                ret = elem.getAttributeNode(name);
                // Return undefined if nodeValue is empty string
                return ret && ret.nodeValue !== "" ?
				ret.nodeValue :
				undefined;
            },
            set: function (elem, value, name) {
                // Check form objects in IE (multiple bugs related)
                // Only use nodeValue if the attribute node exists on the form
                var ret = elem.getAttributeNode(name);
                if (ret) {
                    ret.nodeValue = value;
                    return value;
                }
            }
        };

        // Set width and height to auto instead of 0 on empty string( Bug #8150 )
        // This is for removals
        jQuery.each(["width", "height"], function (i, name) {
            jQuery.attrHooks[name] = jQuery.extend(jQuery.attrHooks[name], {
                set: function (elem, value) {
                    if (value === "") {
                        elem.setAttribute(name, "auto");
                        return value;
                    }
                }
            });
        });
    }


    // Some attributes require a special call on IE
    if (!jQuery.support.hrefNormalized) {
        jQuery.each(["href", "src", "width", "height"], function (i, name) {
            jQuery.attrHooks[name] = jQuery.extend(jQuery.attrHooks[name], {
                get: function (elem) {
                    var ret = elem.getAttribute(name, 2);
                    return ret === null ? undefined : ret;
                }
            });
        });
    }

    if (!jQuery.support.style) {
        jQuery.attrHooks.style = {
            get: function (elem) {
                // Return undefined in the case of empty string
                // Normalize to lowercase since IE uppercases css property names
                return elem.style.cssText.toLowerCase() || undefined;
            },
            set: function (elem, value) {
                return (elem.style.cssText = "" + value);
            }
        };
    }

    // Safari mis-reports the default selected property of an option
    // Accessing the parent's selectedIndex property fixes it
    if (!jQuery.support.optSelected) {
        jQuery.propHooks.selected = jQuery.extend(jQuery.propHooks.selected, {
            get: function (elem) {
                var parent = elem.parentNode;

                if (parent) {
                    parent.selectedIndex;

                    // Make sure that it also works with optgroups, see #5701
                    if (parent.parentNode) {
                        parent.parentNode.selectedIndex;
                    }
                }
            }
        });
    }

    // Radios and checkboxes getter/setter
    if (!jQuery.support.checkOn) {
        jQuery.each(["radio", "checkbox"], function () {
            jQuery.valHooks[this] = {
                get: function (elem) {
                    // Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
                    return elem.getAttribute("value") === null ? "on" : elem.value;
                }
            };
        });
    }
    jQuery.each(["radio", "checkbox"], function () {
        jQuery.valHooks[this] = jQuery.extend(jQuery.valHooks[this], {
            set: function (elem, value) {
                if (jQuery.isArray(value)) {
                    return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0);
                }
            }
        });
    });




    var rnamespaces = /\.(.*)$/,
	rformElems = /^(?:textarea|input|select)$/i,
	rperiod = /\./g,
	rspaces = / /g,
	rescape = /[^\w\s.|`]/g,
	fcleanup = function (nm) {
	    return nm.replace(rescape, "\\$&");
	};

    /*
    * A number of helper functions used for managing events.
    * Many of the ideas behind this code originated from
    * Dean Edwards' addEvent library.
    */
    jQuery.event = {

        // Bind an event to an element
        // Original by Dean Edwards
        add: function (elem, types, handler, data) {
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }

            if (handler === false) {
                handler = returnFalse;
            } else if (!handler) {
                // Fixes bug #7229. Fix recommended by jdalton
                return;
            }

            var handleObjIn, handleObj;

            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
            }

            // Make sure that the function being executed has a unique ID
            if (!handler.guid) {
                handler.guid = jQuery.guid++;
            }

            // Init the element's event structure
            var elemData = jQuery._data(elem);

            // If no elemData is found then we must be trying to bind to one of the
            // banned noData elements
            if (!elemData) {
                return;
            }

            var events = elemData.events,
			eventHandle = elemData.handle;

            if (!events) {
                elemData.events = events = {};
            }

            if (!eventHandle) {
                elemData.handle = eventHandle = function (e) {
                    // Discard the second event of a jQuery.event.trigger() and
                    // when an event is called after a page has unloaded
                    return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
					jQuery.event.handle.apply(eventHandle.elem, arguments) :
					undefined;
                };
            }

            // Add elem as a property of the handle function
            // This is to prevent a memory leak with non-native events in IE.
            eventHandle.elem = elem;

            // Handle multiple events separated by a space
            // jQuery(...).bind("mouseover mouseout", fn);
            types = types.split(" ");

            var type, i = 0, namespaces;

            while ((type = types[i++])) {
                handleObj = handleObjIn ?
				jQuery.extend({}, handleObjIn) :
				{ handler: handler, data: data };

                // Namespaced event handlers
                if (type.indexOf(".") > -1) {
                    namespaces = type.split(".");
                    type = namespaces.shift();
                    handleObj.namespace = namespaces.slice(0).sort().join(".");

                } else {
                    namespaces = [];
                    handleObj.namespace = "";
                }

                handleObj.type = type;
                if (!handleObj.guid) {
                    handleObj.guid = handler.guid;
                }

                // Get the current list of functions bound to this event
                var handlers = events[type],
				special = jQuery.event.special[type] || {};

                // Init the event handler queue
                if (!handlers) {
                    handlers = events[type] = [];

                    // Check for a special event handler
                    // Only use addEventListener/attachEvent if the special
                    // events handler returns false
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                        // Bind the global event handler to the element
                        if (elem.addEventListener) {
                            elem.addEventListener(type, eventHandle, false);

                        } else if (elem.attachEvent) {
                            elem.attachEvent("on" + type, eventHandle);
                        }
                    }
                }

                if (special.add) {
                    special.add.call(elem, handleObj);

                    if (!handleObj.handler.guid) {
                        handleObj.handler.guid = handler.guid;
                    }
                }

                // Add the function to the element's handler list
                handlers.push(handleObj);

                // Keep track of which events have been used, for event optimization
                jQuery.event.global[type] = true;
            }

            // Nullify elem to prevent memory leaks in IE
            elem = null;
        },

        global: {},

        // Detach an event or set of events from an element
        remove: function (elem, types, handler, pos) {
            // don't do events on text and comment nodes
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }

            if (handler === false) {
                handler = returnFalse;
            }

            var ret, type, fn, j, i = 0, all, namespaces, namespace, special, eventType, handleObj, origType,
			elemData = jQuery.hasData(elem) && jQuery._data(elem),
			events = elemData && elemData.events;

            if (!elemData || !events) {
                return;
            }

            // types is actually an event object here
            if (types && types.type) {
                handler = types.handler;
                types = types.type;
            }

            // Unbind all events for the element
            if (!types || typeof types === "string" && types.charAt(0) === ".") {
                types = types || "";

                for (type in events) {
                    jQuery.event.remove(elem, type + types);
                }

                return;
            }

            // Handle multiple events separated by a space
            // jQuery(...).unbind("mouseover mouseout", fn);
            types = types.split(" ");

            while ((type = types[i++])) {
                origType = type;
                handleObj = null;
                all = type.indexOf(".") < 0;
                namespaces = [];

                if (!all) {
                    // Namespaced event handlers
                    namespaces = type.split(".");
                    type = namespaces.shift();

                    namespace = new RegExp("(^|\\.)" +
					jQuery.map(namespaces.slice(0).sort(), fcleanup).join("\\.(?:.*\\.)?") + "(\\.|$)");
                }

                eventType = events[type];

                if (!eventType) {
                    continue;
                }

                if (!handler) {
                    for (j = 0; j < eventType.length; j++) {
                        handleObj = eventType[j];

                        if (all || namespace.test(handleObj.namespace)) {
                            jQuery.event.remove(elem, origType, handleObj.handler, j);
                            eventType.splice(j--, 1);
                        }
                    }

                    continue;
                }

                special = jQuery.event.special[type] || {};

                for (j = pos || 0; j < eventType.length; j++) {
                    handleObj = eventType[j];

                    if (handler.guid === handleObj.guid) {
                        // remove the given handler for the given type
                        if (all || namespace.test(handleObj.namespace)) {
                            if (pos == null) {
                                eventType.splice(j--, 1);
                            }

                            if (special.remove) {
                                special.remove.call(elem, handleObj);
                            }
                        }

                        if (pos != null) {
                            break;
                        }
                    }
                }

                // remove generic event handler if no more handlers exist
                if (eventType.length === 0 || pos != null && eventType.length === 1) {
                    if (!special.teardown || special.teardown.call(elem, namespaces) === false) {
                        jQuery.removeEvent(elem, type, elemData.handle);
                    }

                    ret = null;
                    delete events[type];
                }
            }

            // Remove the expando if it's no longer used
            if (jQuery.isEmptyObject(events)) {
                var handle = elemData.handle;
                if (handle) {
                    handle.elem = null;
                }

                delete elemData.events;
                delete elemData.handle;

                if (jQuery.isEmptyObject(elemData)) {
                    jQuery.removeData(elem, undefined, true);
                }
            }
        },

        // Events that are safe to short-circuit if no handlers are attached.
        // Native DOM events should not be added, they may have inline handlers.
        customEvent: {
            "getData": true,
            "setData": true,
            "changeData": true
        },

        trigger: function (event, data, elem, onlyHandlers) {
            // Event object or event type
            var type = event.type || event,
			namespaces = [],
			exclusive;

            if (type.indexOf("!") >= 0) {
                // Exclusive events trigger only for the exact event (no namespaces)
                type = type.slice(0, -1);
                exclusive = true;
            }

            if (type.indexOf(".") >= 0) {
                // Namespaced trigger; create a regexp to match event type in handle()
                namespaces = type.split(".");
                type = namespaces.shift();
                namespaces.sort();
            }

            if ((!elem || jQuery.event.customEvent[type]) && !jQuery.event.global[type]) {
                // No jQuery handlers for this event type, and it can't have inline handlers
                return;
            }

            // Caller can pass in an Event, Object, or just an event type string
            event = typeof event === "object" ?
            // jQuery.Event object
			event[jQuery.expando] ? event :
            // Object literal
			new jQuery.Event(type, event) :
            // Just the event type (string)
			new jQuery.Event(type);

            event.type = type;
            event.exclusive = exclusive;
            event.namespace = namespaces.join(".");
            event.namespace_re = new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.)?") + "(\\.|$)");

            // triggerHandler() and global events don't bubble or run the default action
            if (onlyHandlers || !elem) {
                event.preventDefault();
                event.stopPropagation();
            }

            // Handle a global trigger
            if (!elem) {
                // TODO: Stop taunting the data cache; remove global events and always attach to document
                jQuery.each(jQuery.cache, function () {
                    // internalKey variable is just used to make it easier to find
                    // and potentially change this stuff later; currently it just
                    // points to jQuery.expando
                    var internalKey = jQuery.expando,
					internalCache = this[internalKey];
                    if (internalCache && internalCache.events && internalCache.events[type]) {
                        jQuery.event.trigger(event, data, internalCache.handle.elem);
                    }
                });
                return;
            }

            // Don't do events on text and comment nodes
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }

            // Clean up the event in case it is being reused
            event.result = undefined;
            event.target = elem;

            // Clone any incoming data and prepend the event, creating the handler arg list
            data = data != null ? jQuery.makeArray(data) : [];
            data.unshift(event);

            var cur = elem,
            // IE doesn't like method names with a colon (#3533, #8272)
			ontype = type.indexOf(":") < 0 ? "on" + type : "";

            // Fire event on the current element, then bubble up the DOM tree
            do {
                var handle = jQuery._data(cur, "handle");

                event.currentTarget = cur;
                if (handle) {
                    handle.apply(cur, data);
                }

                // Trigger an inline bound script
                if (ontype && jQuery.acceptData(cur) && cur[ontype] && cur[ontype].apply(cur, data) === false) {
                    event.result = false;
                    event.preventDefault();
                }

                // Bubble up to document, then to window
                cur = cur.parentNode || cur.ownerDocument || cur === event.target.ownerDocument && window;
            } while (cur && !event.isPropagationStopped());

            // If nobody prevented the default action, do it now
            if (!event.isDefaultPrevented()) {
                var old,
				special = jQuery.event.special[type] || {};

                if ((!special._default || special._default.call(elem.ownerDocument, event) === false) &&
				!(type === "click" && jQuery.nodeName(elem, "a")) && jQuery.acceptData(elem)) {

                    // Call a native DOM method on the target with the same name name as the event.
                    // Can't use an .isFunction)() check here because IE6/7 fails that test.
                    // IE<9 dies on focus to hidden element (#1486), may want to revisit a try/catch.
                    try {
                        if (ontype && elem[type]) {
                            // Don't re-trigger an onFOO event when we call its FOO() method
                            old = elem[ontype];

                            if (old) {
                                elem[ontype] = null;
                            }

                            jQuery.event.triggered = type;
                            elem[type]();
                        }
                    } catch (ieError) { }

                    if (old) {
                        elem[ontype] = old;
                    }

                    jQuery.event.triggered = undefined;
                }
            }

            return event.result;
        },

        handle: function (event) {
            event = jQuery.event.fix(event || window.event);
            // Snapshot the handlers list since a called handler may add/remove events.
            var handlers = ((jQuery._data(this, "events") || {})[event.type] || []).slice(0),
			run_all = !event.exclusive && !event.namespace,
			args = Array.prototype.slice.call(arguments, 0);

            // Use the fix-ed Event rather than the (read-only) native event
            args[0] = event;
            event.currentTarget = this;

            for (var j = 0, l = handlers.length; j < l; j++) {
                var handleObj = handlers[j];

                // Triggered event must 1) be non-exclusive and have no namespace, or
                // 2) have namespace(s) a subset or equal to those in the bound event.
                if (run_all || event.namespace_re.test(handleObj.namespace)) {
                    // Pass in a reference to the handler function itself
                    // So that we can later remove it
                    event.handler = handleObj.handler;
                    event.data = handleObj.data;
                    event.handleObj = handleObj;

                    var ret = handleObj.handler.apply(this, args);

                    if (ret !== undefined) {
                        event.result = ret;
                        if (ret === false) {
                            event.preventDefault();
                            event.stopPropagation();
                        }
                    }

                    if (event.isImmediatePropagationStopped()) {
                        break;
                    }
                }
            }
            return event.result;
        },

        props: "altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which".split(" "),

        fix: function (event) {
            if (event[jQuery.expando]) {
                return event;
            }

            // store a copy of the original event object
            // and "clone" to set read-only properties
            var originalEvent = event;
            event = jQuery.Event(originalEvent);

            for (var i = this.props.length, prop; i; ) {
                prop = this.props[--i];
                event[prop] = originalEvent[prop];
            }

            // Fix target property, if necessary
            if (!event.target) {
                // Fixes #1925 where srcElement might not be defined either
                event.target = event.srcElement || document;
            }

            // check if target is a textnode (safari)
            if (event.target.nodeType === 3) {
                event.target = event.target.parentNode;
            }

            // Add relatedTarget, if necessary
            if (!event.relatedTarget && event.fromElement) {
                event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;
            }

            // Calculate pageX/Y if missing and clientX/Y available
            if (event.pageX == null && event.clientX != null) {
                var eventDocument = event.target.ownerDocument || document,
				doc = eventDocument.documentElement,
				body = eventDocument.body;

                event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
            }

            // Add which for key events
            if (event.which == null && (event.charCode != null || event.keyCode != null)) {
                event.which = event.charCode != null ? event.charCode : event.keyCode;
            }

            // Add metaKey to non-Mac browsers (use ctrl for PC's and Meta for Macs)
            if (!event.metaKey && event.ctrlKey) {
                event.metaKey = event.ctrlKey;
            }

            // Add which for click: 1 === left; 2 === middle; 3 === right
            // Note: button is not normalized, so don't use it
            if (!event.which && event.button !== undefined) {
                event.which = (event.button & 1 ? 1 : (event.button & 2 ? 3 : (event.button & 4 ? 2 : 0)));
            }

            return event;
        },

        // Deprecated, use jQuery.guid instead
        guid: 1E8,

        // Deprecated, use jQuery.proxy instead
        proxy: jQuery.proxy,

        special: {
            ready: {
                // Make sure the ready event is setup
                setup: jQuery.bindReady,
                teardown: jQuery.noop
            },

            live: {
                add: function (handleObj) {
                    jQuery.event.add(this,
					liveConvert(handleObj.origType, handleObj.selector),
					jQuery.extend({}, handleObj, { handler: liveHandler, guid: handleObj.handler.guid }));
                },

                remove: function (handleObj) {
                    jQuery.event.remove(this, liveConvert(handleObj.origType, handleObj.selector), handleObj);
                }
            },

            beforeunload: {
                setup: function (data, namespaces, eventHandle) {
                    // We only want to do this special case on windows
                    if (jQuery.isWindow(this)) {
                        this.onbeforeunload = eventHandle;
                    }
                },

                teardown: function (namespaces, eventHandle) {
                    if (this.onbeforeunload === eventHandle) {
                        this.onbeforeunload = null;
                    }
                }
            }
        }
    };

    jQuery.removeEvent = document.removeEventListener ?
	function (elem, type, handle) {
	    if (elem.removeEventListener) {
	        elem.removeEventListener(type, handle, false);
	    }
	} :
	function (elem, type, handle) {
	    if (elem.detachEvent) {
	        elem.detachEvent("on" + type, handle);
	    }
	};

    jQuery.Event = function (src, props) {
        // Allow instantiation without the 'new' keyword
        if (!this.preventDefault) {
            return new jQuery.Event(src, props);
        }

        // Event object
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;

            // Events bubbling up the document may have been marked as prevented
            // by a handler lower down the tree; reflect the correct value.
            this.isDefaultPrevented = (src.defaultPrevented || src.returnValue === false ||
			src.getPreventDefault && src.getPreventDefault()) ? returnTrue : returnFalse;

            // Event type
        } else {
            this.type = src;
        }

        // Put explicitly provided properties onto the event object
        if (props) {
            jQuery.extend(this, props);
        }

        // timeStamp is buggy for some events on Firefox(#3843)
        // So we won't rely on the native value
        this.timeStamp = jQuery.now();

        // Mark it as fixed
        this[jQuery.expando] = true;
    };

    function returnFalse() {
        return false;
    }
    function returnTrue() {
        return true;
    }

    // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
    // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
    jQuery.Event.prototype = {
        preventDefault: function () {
            this.isDefaultPrevented = returnTrue;

            var e = this.originalEvent;
            if (!e) {
                return;
            }

            // if preventDefault exists run it on the original event
            if (e.preventDefault) {
                e.preventDefault();

                // otherwise set the returnValue property of the original event to false (IE)
            } else {
                e.returnValue = false;
            }
        },
        stopPropagation: function () {
            this.isPropagationStopped = returnTrue;

            var e = this.originalEvent;
            if (!e) {
                return;
            }
            // if stopPropagation exists run it on the original event
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            // otherwise set the cancelBubble property of the original event to true (IE)
            e.cancelBubble = true;
        },
        stopImmediatePropagation: function () {
            this.isImmediatePropagationStopped = returnTrue;
            this.stopPropagation();
        },
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse
    };

    // Checks if an event happened on an element within another element
    // Used in jQuery.event.special.mouseenter and mouseleave handlers
    var withinElement = function (event) {

        // Check if mouse(over|out) are still within the same parent element
        var related = event.relatedTarget,
		inside = false,
		eventType = event.type;

        event.type = event.data;

        if (related !== this) {

            if (related) {
                inside = jQuery.contains(this, related);
            }

            if (!inside) {

                jQuery.event.handle.apply(this, arguments);

                event.type = eventType;
            }
        }
    },

    // In case of event delegation, we only need to rename the event.type,
    // liveHandler will take care of the rest.
delegate = function (event) {
    event.type = event.data;
    jQuery.event.handle.apply(this, arguments);
};

    // Create mouseenter and mouseleave events
    jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    }, function (orig, fix) {
        jQuery.event.special[orig] = {
            setup: function (data) {
                jQuery.event.add(this, fix, data && data.selector ? delegate : withinElement, orig);
            },
            teardown: function (data) {
                jQuery.event.remove(this, fix, data && data.selector ? delegate : withinElement);
            }
        };
    });

    // submit delegation
    if (!jQuery.support.submitBubbles) {

        jQuery.event.special.submit = {
            setup: function (data, namespaces) {
                if (!jQuery.nodeName(this, "form")) {
                    jQuery.event.add(this, "click.specialSubmit", function (e) {
                        var elem = e.target,
						type = elem.type;

                        if ((type === "submit" || type === "image") && jQuery(elem).closest("form").length) {
                            trigger("submit", this, arguments);
                        }
                    });

                    jQuery.event.add(this, "keypress.specialSubmit", function (e) {
                        var elem = e.target,
						type = elem.type;

                        if ((type === "text" || type === "password") && jQuery(elem).closest("form").length && e.keyCode === 13) {
                            trigger("submit", this, arguments);
                        }
                    });

                } else {
                    return false;
                }
            },

            teardown: function (namespaces) {
                jQuery.event.remove(this, ".specialSubmit");
            }
        };

    }

    // change delegation, happens here so we have bind.
    if (!jQuery.support.changeBubbles) {

        var changeFilters,

	getVal = function (elem) {
	    var type = elem.type, val = elem.value;

	    if (type === "radio" || type === "checkbox") {
	        val = elem.checked;

	    } else if (type === "select-multiple") {
	        val = elem.selectedIndex > -1 ?
				jQuery.map(elem.options, function (elem) {
				    return elem.selected;
				}).join("-") :
				"";

	    } else if (jQuery.nodeName(elem, "select")) {
	        val = elem.selectedIndex;
	    }

	    return val;
	},

	testChange = function testChange(e) {
	    var elem = e.target, data, val;

	    if (!rformElems.test(elem.nodeName) || elem.readOnly) {
	        return;
	    }

	    data = jQuery._data(elem, "_change_data");
	    val = getVal(elem);

	    // the current data will be also retrieved by beforeactivate
	    if (e.type !== "focusout" || elem.type !== "radio") {
	        jQuery._data(elem, "_change_data", val);
	    }

	    if (data === undefined || val === data) {
	        return;
	    }

	    if (data != null || val) {
	        e.type = "change";
	        e.liveFired = undefined;
	        jQuery.event.trigger(e, arguments[1], elem);
	    }
	};

        jQuery.event.special.change = {
            filters: {
                focusout: testChange,

                beforedeactivate: testChange,

                click: function (e) {
                    var elem = e.target, type = jQuery.nodeName(elem, "input") ? elem.type : "";

                    if (type === "radio" || type === "checkbox" || jQuery.nodeName(elem, "select")) {
                        testChange.call(this, e);
                    }
                },

                // Change has to be called before submit
                // Keydown will be called before keypress, which is used in submit-event delegation
                keydown: function (e) {
                    var elem = e.target, type = jQuery.nodeName(elem, "input") ? elem.type : "";

                    if ((e.keyCode === 13 && !jQuery.nodeName(elem, "textarea")) ||
					(e.keyCode === 32 && (type === "checkbox" || type === "radio")) ||
					type === "select-multiple") {
                        testChange.call(this, e);
                    }
                },

                // Beforeactivate happens also before the previous element is blurred
                // with this event you can't trigger a change event, but you can store
                // information
                beforeactivate: function (e) {
                    var elem = e.target;
                    jQuery._data(elem, "_change_data", getVal(elem));
                }
            },

            setup: function (data, namespaces) {
                if (this.type === "file") {
                    return false;
                }

                for (var type in changeFilters) {
                    jQuery.event.add(this, type + ".specialChange", changeFilters[type]);
                }

                return rformElems.test(this.nodeName);
            },

            teardown: function (namespaces) {
                jQuery.event.remove(this, ".specialChange");

                return rformElems.test(this.nodeName);
            }
        };

        changeFilters = jQuery.event.special.change.filters;

        // Handle when the input is .focus()'d
        changeFilters.focus = changeFilters.beforeactivate;
    }

    function trigger(type, elem, args) {
        // Piggyback on a donor event to simulate a different one.
        // Fake originalEvent to avoid donor's stopPropagation, but if the
        // simulated event prevents default then we do the same on the donor.
        // Don't pass args or remember liveFired; they apply to the donor event.
        var event = jQuery.extend({}, args[0]);
        event.type = type;
        event.originalEvent = {};
        event.liveFired = undefined;
        jQuery.event.handle.call(elem, event);
        if (event.isDefaultPrevented()) {
            args[0].preventDefault();
        }
    }

    // Create "bubbling" focus and blur events
    if (!jQuery.support.focusinBubbles) {
        jQuery.each({ focus: "focusin", blur: "focusout" }, function (orig, fix) {

            // Attach a single capturing handler while someone wants focusin/focusout
            var attaches = 0;

            jQuery.event.special[fix] = {
                setup: function () {
                    if (attaches++ === 0) {
                        document.addEventListener(orig, handler, true);
                    }
                },
                teardown: function () {
                    if (--attaches === 0) {
                        document.removeEventListener(orig, handler, true);
                    }
                }
            };

            function handler(donor) {
                // Donor event is always a native one; fix it and switch its type.
                // Let focusin/out handler cancel the donor focus/blur event.
                var e = jQuery.event.fix(donor);
                e.type = fix;
                e.originalEvent = {};
                jQuery.event.trigger(e, null, e.target);
                if (e.isDefaultPrevented()) {
                    donor.preventDefault();
                }
            }
        });
    }

    jQuery.each(["bind", "one"], function (i, name) {
        jQuery.fn[name] = function (type, data, fn) {
            var handler;

            // Handle object literals
            if (typeof type === "object") {
                for (var key in type) {
                    this[name](key, data, type[key], fn);
                }
                return this;
            }

            if (arguments.length === 2 || data === false) {
                fn = data;
                data = undefined;
            }

            if (name === "one") {
                handler = function (event) {
                    jQuery(this).unbind(event, handler);
                    return fn.apply(this, arguments);
                };
                handler.guid = fn.guid || jQuery.guid++;
            } else {
                handler = fn;
            }

            if (type === "unload" && name !== "one") {
                this.one(type, data, fn);

            } else {
                for (var i = 0, l = this.length; i < l; i++) {
                    jQuery.event.add(this[i], type, handler, data);
                }
            }

            return this;
        };
    });

    jQuery.fn.extend({
        unbind: function (type, fn) {
            // Handle object literals
            if (typeof type === "object" && !type.preventDefault) {
                for (var key in type) {
                    this.unbind(key, type[key]);
                }

            } else {
                for (var i = 0, l = this.length; i < l; i++) {
                    jQuery.event.remove(this[i], type, fn);
                }
            }

            return this;
        },

        delegate: function (selector, types, data, fn) {
            return this.live(types, data, fn, selector);
        },

        undelegate: function (selector, types, fn) {
            if (arguments.length === 0) {
                return this.unbind("live");

            } else {
                return this.die(types, null, fn, selector);
            }
        },

        trigger: function (type, data) {
            return this.each(function () {
                jQuery.event.trigger(type, data, this);
            });
        },

        triggerHandler: function (type, data) {
            if (this[0]) {
                return jQuery.event.trigger(type, data, this[0], true);
            }
        },

        toggle: function (fn) {
            // Save reference to arguments for access in closure
            var args = arguments,
			guid = fn.guid || jQuery.guid++,
			i = 0,
			toggler = function (event) {
			    // Figure out which function to execute
			    var lastToggle = (jQuery.data(this, "lastToggle" + fn.guid) || 0) % i;
			    jQuery.data(this, "lastToggle" + fn.guid, lastToggle + 1);

			    // Make sure that clicks stop
			    event.preventDefault();

			    // and execute the function
			    return args[lastToggle].apply(this, arguments) || false;
			};

            // link all the functions, so any of them can unbind this click handler
            toggler.guid = guid;
            while (i < args.length) {
                args[i++].guid = guid;
            }

            return this.click(toggler);
        },

        hover: function (fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        }
    });

    var liveMap = {
        focus: "focusin",
        blur: "focusout",
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    };

    jQuery.each(["live", "die"], function (i, name) {
        jQuery.fn[name] = function (types, data, fn, origSelector /* Internal Use Only */) {
            var type, i = 0, match, namespaces, preType,
			selector = origSelector || this.selector,
			context = origSelector ? this : jQuery(this.context);

            if (typeof types === "object" && !types.preventDefault) {
                for (var key in types) {
                    context[name](key, data, types[key], selector);
                }

                return this;
            }

            if (name === "die" && !types &&
					origSelector && origSelector.charAt(0) === ".") {

                context.unbind(origSelector);

                return this;
            }

            if (data === false || jQuery.isFunction(data)) {
                fn = data || returnFalse;
                data = undefined;
            }

            types = (types || "").split(" ");

            while ((type = types[i++]) != null) {
                match = rnamespaces.exec(type);
                namespaces = "";

                if (match) {
                    namespaces = match[0];
                    type = type.replace(rnamespaces, "");
                }

                if (type === "hover") {
                    types.push("mouseenter" + namespaces, "mouseleave" + namespaces);
                    continue;
                }

                preType = type;

                if (liveMap[type]) {
                    types.push(liveMap[type] + namespaces);
                    type = type + namespaces;

                } else {
                    type = (liveMap[type] || type) + namespaces;
                }

                if (name === "live") {
                    // bind live handler
                    for (var j = 0, l = context.length; j < l; j++) {
                        jQuery.event.add(context[j], "live." + liveConvert(type, selector),
						{ data: data, selector: selector, handler: fn, origType: type, origHandler: fn, preType: preType });
                    }

                } else {
                    // unbind live handler
                    context.unbind("live." + liveConvert(type, selector), fn);
                }
            }

            return this;
        };
    });

    function liveHandler(event) {
        var stop, maxLevel, related, match, handleObj, elem, j, i, l, data, close, namespace, ret,
		elems = [],
		selectors = [],
		events = jQuery._data(this, "events");

        // Make sure we avoid non-left-click bubbling in Firefox (#3861) and disabled elements in IE (#6911)
        if (event.liveFired === this || !events || !events.live || event.target.disabled || event.button && event.type === "click") {
            return;
        }

        if (event.namespace) {
            namespace = new RegExp("(^|\\.)" + event.namespace.split(".").join("\\.(?:.*\\.)?") + "(\\.|$)");
        }

        event.liveFired = this;

        var live = events.live.slice(0);

        for (j = 0; j < live.length; j++) {
            handleObj = live[j];

            if (handleObj.origType.replace(rnamespaces, "") === event.type) {
                selectors.push(handleObj.selector);

            } else {
                live.splice(j--, 1);
            }
        }

        match = jQuery(event.target).closest(selectors, event.currentTarget);

        for (i = 0, l = match.length; i < l; i++) {
            close = match[i];

            for (j = 0; j < live.length; j++) {
                handleObj = live[j];

                if (close.selector === handleObj.selector && (!namespace || namespace.test(handleObj.namespace)) && !close.elem.disabled) {
                    elem = close.elem;
                    related = null;

                    // Those two events require additional checking
                    if (handleObj.preType === "mouseenter" || handleObj.preType === "mouseleave") {
                        event.type = handleObj.preType;
                        related = jQuery(event.relatedTarget).closest(handleObj.selector)[0];

                        // Make sure not to accidentally match a child element with the same selector
                        if (related && jQuery.contains(elem, related)) {
                            related = elem;
                        }
                    }

                    if (!related || related !== elem) {
                        elems.push({ elem: elem, handleObj: handleObj, level: close.level });
                    }
                }
            }
        }

        for (i = 0, l = elems.length; i < l; i++) {
            match = elems[i];

            if (maxLevel && match.level > maxLevel) {
                break;
            }

            event.currentTarget = match.elem;
            event.data = match.handleObj.data;
            event.handleObj = match.handleObj;

            ret = match.handleObj.origHandler.apply(match.elem, arguments);

            if (ret === false || event.isPropagationStopped()) {
                maxLevel = match.level;

                if (ret === false) {
                    stop = false;
                }
                if (event.isImmediatePropagationStopped()) {
                    break;
                }
            }
        }

        return stop;
    }

    function liveConvert(type, selector) {
        return (type && type !== "*" ? type + "." : "") + selector.replace(rperiod, "`").replace(rspaces, "&");
    }

    jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error").split(" "), function (i, name) {

	    // Handle event binding
	    jQuery.fn[name] = function (data, fn) {
	        if (fn == null) {
	            fn = data;
	            data = null;
	        }

	        return arguments.length > 0 ?
			this.bind(name, data, fn) :
			this.trigger(name);
	    };

	    if (jQuery.attrFn) {
	        jQuery.attrFn[name] = true;
	    }
	});



    /*!
    * Sizzle CSS Selector Engine
    *  Copyright 2011, The Dojo Foundation
    *  Released under the MIT, BSD, and GPL Licenses.
    *  More information: http://sizzlejs.com/
    */
    (function () {

        var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
	done = 0,
	toString = Object.prototype.toString,
	hasDuplicate = false,
	baseHasDuplicate = true,
	rBackslash = /\\/g,
	rNonWord = /\W/;

        // Here we check if the JavaScript engine is using some sort of
        // optimization where it does not always call our comparision
        // function. If that is the case, discard the hasDuplicate value.
        //   Thus far that includes Google Chrome.
        [0, 0].sort(function () {
            baseHasDuplicate = false;
            return 0;
        });

        var Sizzle = function (selector, context, results, seed) {
            results = results || [];
            context = context || document;

            var origContext = context;

            if (context.nodeType !== 1 && context.nodeType !== 9) {
                return [];
            }

            if (!selector || typeof selector !== "string") {
                return results;
            }

            var m, set, checkSet, extra, ret, cur, pop, i,
		prune = true,
		contextXML = Sizzle.isXML(context),
		parts = [],
		soFar = selector;

            // Reset the position of the chunker regexp (start from head)
            do {
                chunker.exec("");
                m = chunker.exec(soFar);

                if (m) {
                    soFar = m[3];

                    parts.push(m[1]);

                    if (m[2]) {
                        extra = m[3];
                        break;
                    }
                }
            } while (m);

            if (parts.length > 1 && origPOS.exec(selector)) {

                if (parts.length === 2 && Expr.relative[parts[0]]) {
                    set = posProcess(parts[0] + parts[1], context);

                } else {
                    set = Expr.relative[parts[0]] ?
				[context] :
				Sizzle(parts.shift(), context);

                    while (parts.length) {
                        selector = parts.shift();

                        if (Expr.relative[selector]) {
                            selector += parts.shift();
                        }

                        set = posProcess(selector, set);
                    }
                }

            } else {
                // Take a shortcut and set the context if the root selector is an ID
                // (but not if it'll be faster if the inner selector is an ID)
                if (!seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
				Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1])) {

                    ret = Sizzle.find(parts.shift(), context, contextXML);
                    context = ret.expr ?
				Sizzle.filter(ret.expr, ret.set)[0] :
				ret.set[0];
                }

                if (context) {
                    ret = seed ?
				{ expr: parts.pop(), set: makeArray(seed)} :
				Sizzle.find(parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML);

                    set = ret.expr ?
				Sizzle.filter(ret.expr, ret.set) :
				ret.set;

                    if (parts.length > 0) {
                        checkSet = makeArray(set);

                    } else {
                        prune = false;
                    }

                    while (parts.length) {
                        cur = parts.pop();
                        pop = cur;

                        if (!Expr.relative[cur]) {
                            cur = "";
                        } else {
                            pop = parts.pop();
                        }

                        if (pop == null) {
                            pop = context;
                        }

                        Expr.relative[cur](checkSet, pop, contextXML);
                    }

                } else {
                    checkSet = parts = [];
                }
            }

            if (!checkSet) {
                checkSet = set;
            }

            if (!checkSet) {
                Sizzle.error(cur || selector);
            }

            if (toString.call(checkSet) === "[object Array]") {
                if (!prune) {
                    results.push.apply(results, checkSet);

                } else if (context && context.nodeType === 1) {
                    for (i = 0; checkSet[i] != null; i++) {
                        if (checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i]))) {
                            results.push(set[i]);
                        }
                    }

                } else {
                    for (i = 0; checkSet[i] != null; i++) {
                        if (checkSet[i] && checkSet[i].nodeType === 1) {
                            results.push(set[i]);
                        }
                    }
                }

            } else {
                makeArray(checkSet, results);
            }

            if (extra) {
                Sizzle(extra, origContext, results, seed);
                Sizzle.uniqueSort(results);
            }

            return results;
        };

        Sizzle.uniqueSort = function (results) {
            if (sortOrder) {
                hasDuplicate = baseHasDuplicate;
                results.sort(sortOrder);

                if (hasDuplicate) {
                    for (var i = 1; i < results.length; i++) {
                        if (results[i] === results[i - 1]) {
                            results.splice(i--, 1);
                        }
                    }
                }
            }

            return results;
        };

        Sizzle.matches = function (expr, set) {
            return Sizzle(expr, null, null, set);
        };

        Sizzle.matchesSelector = function (node, expr) {
            return Sizzle(expr, null, null, [node]).length > 0;
        };

        Sizzle.find = function (expr, context, isXML) {
            var set;

            if (!expr) {
                return [];
            }

            for (var i = 0, l = Expr.order.length; i < l; i++) {
                var match,
			type = Expr.order[i];

                if ((match = Expr.leftMatch[type].exec(expr))) {
                    var left = match[1];
                    match.splice(1, 1);

                    if (left.substr(left.length - 1) !== "\\") {
                        match[1] = (match[1] || "").replace(rBackslash, "");
                        set = Expr.find[type](match, context, isXML);

                        if (set != null) {
                            expr = expr.replace(Expr.match[type], "");
                            break;
                        }
                    }
                }
            }

            if (!set) {
                set = typeof context.getElementsByTagName !== "undefined" ?
			context.getElementsByTagName("*") :
			[];
            }

            return { set: set, expr: expr };
        };

        Sizzle.filter = function (expr, set, inplace, not) {
            var match, anyFound,
		old = expr,
		result = [],
		curLoop = set,
		isXMLFilter = set && set[0] && Sizzle.isXML(set[0]);

            while (expr && set.length) {
                for (var type in Expr.filter) {
                    if ((match = Expr.leftMatch[type].exec(expr)) != null && match[2]) {
                        var found, item,
					filter = Expr.filter[type],
					left = match[1];

                        anyFound = false;

                        match.splice(1, 1);

                        if (left.substr(left.length - 1) === "\\") {
                            continue;
                        }

                        if (curLoop === result) {
                            result = [];
                        }

                        if (Expr.preFilter[type]) {
                            match = Expr.preFilter[type](match, curLoop, inplace, result, not, isXMLFilter);

                            if (!match) {
                                anyFound = found = true;

                            } else if (match === true) {
                                continue;
                            }
                        }

                        if (match) {
                            for (var i = 0; (item = curLoop[i]) != null; i++) {
                                if (item) {
                                    found = filter(item, match, i, curLoop);
                                    var pass = not ^ !!found;

                                    if (inplace && found != null) {
                                        if (pass) {
                                            anyFound = true;

                                        } else {
                                            curLoop[i] = false;
                                        }

                                    } else if (pass) {
                                        result.push(item);
                                        anyFound = true;
                                    }
                                }
                            }
                        }

                        if (found !== undefined) {
                            if (!inplace) {
                                curLoop = result;
                            }

                            expr = expr.replace(Expr.match[type], "");

                            if (!anyFound) {
                                return [];
                            }

                            break;
                        }
                    }
                }

                // Improper expression
                if (expr === old) {
                    if (anyFound == null) {
                        Sizzle.error(expr);

                    } else {
                        break;
                    }
                }

                old = expr;
            }

            return curLoop;
        };

        Sizzle.error = function (msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg);
        };

        var Expr = Sizzle.selectors = {
            order: ["ID", "NAME", "TAG"],

            match: {
                ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
                CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
                NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
                ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
                TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
                CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
                POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
                PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
            },

            leftMatch: {},

            attrMap: {
                "class": "className",
                "for": "htmlFor"
            },

            attrHandle: {
                href: function (elem) {
                    return elem.getAttribute("href");
                },
                type: function (elem) {
                    return elem.getAttribute("type");
                }
            },

            relative: {
                "+": function (checkSet, part) {
                    var isPartStr = typeof part === "string",
				isTag = isPartStr && !rNonWord.test(part),
				isPartStrNotTag = isPartStr && !isTag;

                    if (isTag) {
                        part = part.toLowerCase();
                    }

                    for (var i = 0, l = checkSet.length, elem; i < l; i++) {
                        if ((elem = checkSet[i])) {
                            while ((elem = elem.previousSibling) && elem.nodeType !== 1) { }

                            checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
						elem || false :
						elem === part;
                        }
                    }

                    if (isPartStrNotTag) {
                        Sizzle.filter(part, checkSet, true);
                    }
                },

                ">": function (checkSet, part) {
                    var elem,
				isPartStr = typeof part === "string",
				i = 0,
				l = checkSet.length;

                    if (isPartStr && !rNonWord.test(part)) {
                        part = part.toLowerCase();

                        for (; i < l; i++) {
                            elem = checkSet[i];

                            if (elem) {
                                var parent = elem.parentNode;
                                checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
                            }
                        }

                    } else {
                        for (; i < l; i++) {
                            elem = checkSet[i];

                            if (elem) {
                                checkSet[i] = isPartStr ?
							elem.parentNode :
							elem.parentNode === part;
                            }
                        }

                        if (isPartStr) {
                            Sizzle.filter(part, checkSet, true);
                        }
                    }
                },

                "": function (checkSet, part, isXML) {
                    var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

                    if (typeof part === "string" && !rNonWord.test(part)) {
                        part = part.toLowerCase();
                        nodeCheck = part;
                        checkFn = dirNodeCheck;
                    }

                    checkFn("parentNode", part, doneName, checkSet, nodeCheck, isXML);
                },

                "~": function (checkSet, part, isXML) {
                    var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

                    if (typeof part === "string" && !rNonWord.test(part)) {
                        part = part.toLowerCase();
                        nodeCheck = part;
                        checkFn = dirNodeCheck;
                    }

                    checkFn("previousSibling", part, doneName, checkSet, nodeCheck, isXML);
                }
            },

            find: {
                ID: function (match, context, isXML) {
                    if (typeof context.getElementById !== "undefined" && !isXML) {
                        var m = context.getElementById(match[1]);
                        // Check parentNode to catch when Blackberry 4.6 returns
                        // nodes that are no longer in the document #6963
                        return m && m.parentNode ? [m] : [];
                    }
                },

                NAME: function (match, context) {
                    if (typeof context.getElementsByName !== "undefined") {
                        var ret = [],
					results = context.getElementsByName(match[1]);

                        for (var i = 0, l = results.length; i < l; i++) {
                            if (results[i].getAttribute("name") === match[1]) {
                                ret.push(results[i]);
                            }
                        }

                        return ret.length === 0 ? null : ret;
                    }
                },

                TAG: function (match, context) {
                    if (typeof context.getElementsByTagName !== "undefined") {
                        return context.getElementsByTagName(match[1]);
                    }
                }
            },
            preFilter: {
                CLASS: function (match, curLoop, inplace, result, not, isXML) {
                    match = " " + match[1].replace(rBackslash, "") + " ";

                    if (isXML) {
                        return match;
                    }

                    for (var i = 0, elem; (elem = curLoop[i]) != null; i++) {
                        if (elem) {
                            if (not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n\r]/g, " ").indexOf(match) >= 0)) {
                                if (!inplace) {
                                    result.push(elem);
                                }

                            } else if (inplace) {
                                curLoop[i] = false;
                            }
                        }
                    }

                    return false;
                },

                ID: function (match) {
                    return match[1].replace(rBackslash, "");
                },

                TAG: function (match, curLoop) {
                    return match[1].replace(rBackslash, "").toLowerCase();
                },

                CHILD: function (match) {
                    if (match[1] === "nth") {
                        if (!match[2]) {
                            Sizzle.error(match[0]);
                        }

                        match[2] = match[2].replace(/^\+|\s*/g, '');

                        // parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
                        var test = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(
					match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
					!/\D/.test(match[2]) && "0n+" + match[2] || match[2]);

                        // calculate the numbers (first)n+(last) including if they are negative
                        match[2] = (test[1] + (test[2] || 1)) - 0;
                        match[3] = test[3] - 0;
                    }
                    else if (match[2]) {
                        Sizzle.error(match[0]);
                    }

                    // TODO: Move to normal caching system
                    match[0] = done++;

                    return match;
                },

                ATTR: function (match, curLoop, inplace, result, not, isXML) {
                    var name = match[1] = match[1].replace(rBackslash, "");

                    if (!isXML && Expr.attrMap[name]) {
                        match[1] = Expr.attrMap[name];
                    }

                    // Handle if an un-quoted value was used
                    match[4] = (match[4] || match[5] || "").replace(rBackslash, "");

                    if (match[2] === "~=") {
                        match[4] = " " + match[4] + " ";
                    }

                    return match;
                },

                PSEUDO: function (match, curLoop, inplace, result, not) {
                    if (match[1] === "not") {
                        // If we're dealing with a complex expression, or a simple one
                        if ((chunker.exec(match[3]) || "").length > 1 || /^\w/.test(match[3])) {
                            match[3] = Sizzle(match[3], null, null, curLoop);

                        } else {
                            var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);

                            if (!inplace) {
                                result.push.apply(result, ret);
                            }

                            return false;
                        }

                    } else if (Expr.match.POS.test(match[0]) || Expr.match.CHILD.test(match[0])) {
                        return true;
                    }

                    return match;
                },

                POS: function (match) {
                    match.unshift(true);

                    return match;
                }
            },

            filters: {
                enabled: function (elem) {
                    return elem.disabled === false && elem.type !== "hidden";
                },

                disabled: function (elem) {
                    return elem.disabled === true;
                },

                checked: function (elem) {
                    return elem.checked === true;
                },

                selected: function (elem) {
                    // Accessing this property makes selected-by-default
                    // options in Safari work properly
                    if (elem.parentNode) {
                        elem.parentNode.selectedIndex;
                    }

                    return elem.selected === true;
                },

                parent: function (elem) {
                    return !!elem.firstChild;
                },

                empty: function (elem) {
                    return !elem.firstChild;
                },

                has: function (elem, i, match) {
                    return !!Sizzle(match[3], elem).length;
                },

                header: function (elem) {
                    return (/h\d/i).test(elem.nodeName);
                },

                text: function (elem) {
                    var attr = elem.getAttribute("type"), type = elem.type;
                    // IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc) 
                    // use getAttribute instead to test this case
                    return elem.nodeName.toLowerCase() === "input" && "text" === type && (attr === type || attr === null);
                },

                radio: function (elem) {
                    return elem.nodeName.toLowerCase() === "input" && "radio" === elem.type;
                },

                checkbox: function (elem) {
                    return elem.nodeName.toLowerCase() === "input" && "checkbox" === elem.type;
                },

                file: function (elem) {
                    return elem.nodeName.toLowerCase() === "input" && "file" === elem.type;
                },

                password: function (elem) {
                    return elem.nodeName.toLowerCase() === "input" && "password" === elem.type;
                },

                submit: function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return (name === "input" || name === "button") && "submit" === elem.type;
                },

                image: function (elem) {
                    return elem.nodeName.toLowerCase() === "input" && "image" === elem.type;
                },

                reset: function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return (name === "input" || name === "button") && "reset" === elem.type;
                },

                button: function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === "input" && "button" === elem.type || name === "button";
                },

                input: function (elem) {
                    return (/input|select|textarea|button/i).test(elem.nodeName);
                },

                focus: function (elem) {
                    return elem === elem.ownerDocument.activeElement;
                }
            },
            setFilters: {
                first: function (elem, i) {
                    return i === 0;
                },

                last: function (elem, i, match, array) {
                    return i === array.length - 1;
                },

                even: function (elem, i) {
                    return i % 2 === 0;
                },

                odd: function (elem, i) {
                    return i % 2 === 1;
                },

                lt: function (elem, i, match) {
                    return i < match[3] - 0;
                },

                gt: function (elem, i, match) {
                    return i > match[3] - 0;
                },

                nth: function (elem, i, match) {
                    return match[3] - 0 === i;
                },

                eq: function (elem, i, match) {
                    return match[3] - 0 === i;
                }
            },
            filter: {
                PSEUDO: function (elem, match, i, array) {
                    var name = match[1],
				filter = Expr.filters[name];

                    if (filter) {
                        return filter(elem, i, match, array);

                    } else if (name === "contains") {
                        return (elem.textContent || elem.innerText || Sizzle.getText([elem]) || "").indexOf(match[3]) >= 0;

                    } else if (name === "not") {
                        var not = match[3];

                        for (var j = 0, l = not.length; j < l; j++) {
                            if (not[j] === elem) {
                                return false;
                            }
                        }

                        return true;

                    } else {
                        Sizzle.error(name);
                    }
                },

                CHILD: function (elem, match) {
                    var type = match[1],
				node = elem;

                    switch (type) {
                        case "only":
                        case "first":
                            while ((node = node.previousSibling)) {
                                if (node.nodeType === 1) {
                                    return false;
                                }
                            }

                            if (type === "first") {
                                return true;
                            }

                            node = elem;

                        case "last":
                            while ((node = node.nextSibling)) {
                                if (node.nodeType === 1) {
                                    return false;
                                }
                            }

                            return true;

                        case "nth":
                            var first = match[2],
						last = match[3];

                            if (first === 1 && last === 0) {
                                return true;
                            }

                            var doneName = match[0],
						parent = elem.parentNode;

                            if (parent && (parent.sizcache !== doneName || !elem.nodeIndex)) {
                                var count = 0;

                                for (node = parent.firstChild; node; node = node.nextSibling) {
                                    if (node.nodeType === 1) {
                                        node.nodeIndex = ++count;
                                    }
                                }

                                parent.sizcache = doneName;
                            }

                            var diff = elem.nodeIndex - last;

                            if (first === 0) {
                                return diff === 0;

                            } else {
                                return (diff % first === 0 && diff / first >= 0);
                            }
                    }
                },

                ID: function (elem, match) {
                    return elem.nodeType === 1 && elem.getAttribute("id") === match;
                },

                TAG: function (elem, match) {
                    return (match === "*" && elem.nodeType === 1) || elem.nodeName.toLowerCase() === match;
                },

                CLASS: function (elem, match) {
                    return (" " + (elem.className || elem.getAttribute("class")) + " ")
				.indexOf(match) > -1;
                },

                ATTR: function (elem, match) {
                    var name = match[1],
				result = Expr.attrHandle[name] ?
					Expr.attrHandle[name](elem) :
					elem[name] != null ?
						elem[name] :
						elem.getAttribute(name),
				value = result + "",
				type = match[2],
				check = match[4];

                    return result == null ?
				type === "!=" :
				type === "=" ?
				value === check :
				type === "*=" ?
				value.indexOf(check) >= 0 :
				type === "~=" ?
				(" " + value + " ").indexOf(check) >= 0 :
				!check ?
				value && result !== false :
				type === "!=" ?
				value !== check :
				type === "^=" ?
				value.indexOf(check) === 0 :
				type === "$=" ?
				value.substr(value.length - check.length) === check :
				type === "|=" ?
				value === check || value.substr(0, check.length + 1) === check + "-" :
				false;
                },

                POS: function (elem, match, i, array) {
                    var name = match[2],
				filter = Expr.setFilters[name];

                    if (filter) {
                        return filter(elem, i, match, array);
                    }
                }
            }
        };

        var origPOS = Expr.match.POS,
	fescape = function (all, num) {
	    return "\\" + (num - 0 + 1);
	};

        for (var type in Expr.match) {
            Expr.match[type] = new RegExp(Expr.match[type].source + (/(?![^\[]*\])(?![^\(]*\))/.source));
            Expr.leftMatch[type] = new RegExp(/(^(?:.|\r|\n)*?)/.source + Expr.match[type].source.replace(/\\(\d+)/g, fescape));
        }

        var makeArray = function (array, results) {
            array = Array.prototype.slice.call(array, 0);

            if (results) {
                results.push.apply(results, array);
                return results;
            }

            return array;
        };

        // Perform a simple check to determine if the browser is capable of
        // converting a NodeList to an array using builtin methods.
        // Also verifies that the returned array holds DOM nodes
        // (which is not the case in the Blackberry browser)
        try {
            Array.prototype.slice.call(document.documentElement.childNodes, 0)[0].nodeType;

            // Provide a fallback method if it does not work
        } catch (e) {
            makeArray = function (array, results) {
                var i = 0,
			ret = results || [];

                if (toString.call(array) === "[object Array]") {
                    Array.prototype.push.apply(ret, array);

                } else {
                    if (typeof array.length === "number") {
                        for (var l = array.length; i < l; i++) {
                            ret.push(array[i]);
                        }

                    } else {
                        for (; array[i]; i++) {
                            ret.push(array[i]);
                        }
                    }
                }

                return ret;
            };
        }

        var sortOrder, siblingCheck;

        if (document.documentElement.compareDocumentPosition) {
            sortOrder = function (a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }

                if (!a.compareDocumentPosition || !b.compareDocumentPosition) {
                    return a.compareDocumentPosition ? -1 : 1;
                }

                return a.compareDocumentPosition(b) & 4 ? -1 : 1;
            };

        } else {
            sortOrder = function (a, b) {
                // The nodes are identical, we can exit early
                if (a === b) {
                    hasDuplicate = true;
                    return 0;

                    // Fallback to using sourceIndex (in IE) if it's available on both nodes
                } else if (a.sourceIndex && b.sourceIndex) {
                    return a.sourceIndex - b.sourceIndex;
                }

                var al, bl,
			ap = [],
			bp = [],
			aup = a.parentNode,
			bup = b.parentNode,
			cur = aup;

                // If the nodes are siblings (or identical) we can do a quick check
                if (aup === bup) {
                    return siblingCheck(a, b);

                    // If no parents were found then the nodes are disconnected
                } else if (!aup) {
                    return -1;

                } else if (!bup) {
                    return 1;
                }

                // Otherwise they're somewhere else in the tree so we need
                // to build up a full list of the parentNodes for comparison
                while (cur) {
                    ap.unshift(cur);
                    cur = cur.parentNode;
                }

                cur = bup;

                while (cur) {
                    bp.unshift(cur);
                    cur = cur.parentNode;
                }

                al = ap.length;
                bl = bp.length;

                // Start walking down the tree looking for a discrepancy
                for (var i = 0; i < al && i < bl; i++) {
                    if (ap[i] !== bp[i]) {
                        return siblingCheck(ap[i], bp[i]);
                    }
                }

                // We ended someplace up the tree so do a sibling check
                return i === al ?
			siblingCheck(a, bp[i], -1) :
			siblingCheck(ap[i], b, 1);
            };

            siblingCheck = function (a, b, ret) {
                if (a === b) {
                    return ret;
                }

                var cur = a.nextSibling;

                while (cur) {
                    if (cur === b) {
                        return -1;
                    }

                    cur = cur.nextSibling;
                }

                return 1;
            };
        }

        // Utility function for retreiving the text value of an array of DOM nodes
        Sizzle.getText = function (elems) {
            var ret = "", elem;

            for (var i = 0; elems[i]; i++) {
                elem = elems[i];

                // Get the text from text nodes and CDATA nodes
                if (elem.nodeType === 3 || elem.nodeType === 4) {
                    ret += elem.nodeValue;

                    // Traverse everything else, except comment nodes
                } else if (elem.nodeType !== 8) {
                    ret += Sizzle.getText(elem.childNodes);
                }
            }

            return ret;
        };

        // Check to see if the browser returns elements by name when
        // querying by getElementById (and provide a workaround)
        (function () {
            // We're going to inject a fake input element with a specified name
            var form = document.createElement("div"),
		id = "script" + (new Date()).getTime(),
		root = document.documentElement;

            form.innerHTML = "<a name='" + id + "'/>";

            // Inject it into the root element, check its status, and remove it quickly
            root.insertBefore(form, root.firstChild);

            // The workaround has to do additional checks after a getElementById
            // Which slows things down for other browsers (hence the branching)
            if (document.getElementById(id)) {
                Expr.find.ID = function (match, context, isXML) {
                    if (typeof context.getElementById !== "undefined" && !isXML) {
                        var m = context.getElementById(match[1]);

                        return m ?
					m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ?
						[m] :
						undefined :
					[];
                    }
                };

                Expr.filter.ID = function (elem, match) {
                    var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");

                    return elem.nodeType === 1 && node && node.nodeValue === match;
                };
            }

            root.removeChild(form);

            // release memory in IE
            root = form = null;
        })();

        (function () {
            // Check to see if the browser returns only elements
            // when doing getElementsByTagName("*")

            // Create a fake element
            var div = document.createElement("div");
            div.appendChild(document.createComment(""));

            // Make sure no comments are found
            if (div.getElementsByTagName("*").length > 0) {
                Expr.find.TAG = function (match, context) {
                    var results = context.getElementsByTagName(match[1]);

                    // Filter out possible comments
                    if (match[1] === "*") {
                        var tmp = [];

                        for (var i = 0; results[i]; i++) {
                            if (results[i].nodeType === 1) {
                                tmp.push(results[i]);
                            }
                        }

                        results = tmp;
                    }

                    return results;
                };
            }

            // Check to see if an attribute returns normalized href attributes
            div.innerHTML = "<a href='#'></a>";

            if (div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
			div.firstChild.getAttribute("href") !== "#") {

                Expr.attrHandle.href = function (elem) {
                    return elem.getAttribute("href", 2);
                };
            }

            // release memory in IE
            div = null;
        })();

        if (document.querySelectorAll) {
            (function () {
                var oldSizzle = Sizzle,
			div = document.createElement("div"),
			id = "__sizzle__";

                div.innerHTML = "<p class='TEST'></p>";

                // Safari can't handle uppercase or unicode characters when
                // in quirks mode.
                if (div.querySelectorAll && div.querySelectorAll(".TEST").length === 0) {
                    return;
                }

                Sizzle = function (query, context, extra, seed) {
                    context = context || document;

                    // Only use querySelectorAll on non-XML documents
                    // (ID selectors don't work in non-HTML documents)
                    if (!seed && !Sizzle.isXML(context)) {
                        // See if we find a selector to speed up
                        var match = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec(query);

                        if (match && (context.nodeType === 1 || context.nodeType === 9)) {
                            // Speed-up: Sizzle("TAG")
                            if (match[1]) {
                                return makeArray(context.getElementsByTagName(query), extra);

                                // Speed-up: Sizzle(".CLASS")
                            } else if (match[2] && Expr.find.CLASS && context.getElementsByClassName) {
                                return makeArray(context.getElementsByClassName(match[2]), extra);
                            }
                        }

                        if (context.nodeType === 9) {
                            // Speed-up: Sizzle("body")
                            // The body element only exists once, optimize finding it
                            if (query === "body" && context.body) {
                                return makeArray([context.body], extra);

                                // Speed-up: Sizzle("#ID")
                            } else if (match && match[3]) {
                                var elem = context.getElementById(match[3]);

                                // Check parentNode to catch when Blackberry 4.6 returns
                                // nodes that are no longer in the document #6963
                                if (elem && elem.parentNode) {
                                    // Handle the case where IE and Opera return items
                                    // by name instead of ID
                                    if (elem.id === match[3]) {
                                        return makeArray([elem], extra);
                                    }

                                } else {
                                    return makeArray([], extra);
                                }
                            }

                            try {
                                return makeArray(context.querySelectorAll(query), extra);
                            } catch (qsaError) { }

                            // qSA works strangely on Element-rooted queries
                            // We can work around this by specifying an extra ID on the root
                            // and working up from there (Thanks to Andrew Dupont for the technique)
                            // IE 8 doesn't work on object elements
                        } else if (context.nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
                            var oldContext = context,
						old = context.getAttribute("id"),
						nid = old || id,
						hasParent = context.parentNode,
						relativeHierarchySelector = /^\s*[+~]/.test(query);

                            if (!old) {
                                context.setAttribute("id", nid);
                            } else {
                                nid = nid.replace(/'/g, "\\$&");
                            }
                            if (relativeHierarchySelector && hasParent) {
                                context = context.parentNode;
                            }

                            try {
                                if (!relativeHierarchySelector || hasParent) {
                                    return makeArray(context.querySelectorAll("[id='" + nid + "'] " + query), extra);
                                }

                            } catch (pseudoError) {
                            } finally {
                                if (!old) {
                                    oldContext.removeAttribute("id");
                                }
                            }
                        }
                    }

                    return oldSizzle(query, context, extra, seed);
                };

                for (var prop in oldSizzle) {
                    Sizzle[prop] = oldSizzle[prop];
                }

                // release memory in IE
                div = null;
            })();
        }

        (function () {
            var html = document.documentElement,
		matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;

            if (matches) {
                // Check to see if it's possible to do matchesSelector
                // on a disconnected node (IE 9 fails this)
                var disconnectedMatch = !matches.call(document.createElement("div"), "div"),
			pseudoWorks = false;

                try {
                    // This should fail with an exception
                    // Gecko does not error, returns false instead
                    matches.call(document.documentElement, "[test!='']:sizzle");

                } catch (pseudoError) {
                    pseudoWorks = true;
                }

                Sizzle.matchesSelector = function (node, expr) {
                    // Make sure that attribute selectors are quoted
                    expr = expr.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");

                    if (!Sizzle.isXML(node)) {
                        try {
                            if (pseudoWorks || !Expr.match.PSEUDO.test(expr) && !/!=/.test(expr)) {
                                var ret = matches.call(node, expr);

                                // IE 9's matchesSelector returns false on disconnected nodes
                                if (ret || !disconnectedMatch ||
                                // As well, disconnected nodes are said to be in a document
                                // fragment in IE 9, so check for that
								node.document && node.document.nodeType !== 11) {
                                    return ret;
                                }
                            }
                        } catch (e) { }
                    }

                    return Sizzle(expr, null, null, [node]).length > 0;
                };
            }
        })();

        (function () {
            var div = document.createElement("div");

            div.innerHTML = "<div class='test e'></div><div class='test'></div>";

            // Opera can't find a second classname (in 9.6)
            // Also, make sure that getElementsByClassName actually exists
            if (!div.getElementsByClassName || div.getElementsByClassName("e").length === 0) {
                return;
            }

            // Safari caches class attributes, doesn't catch changes (in 3.2)
            div.lastChild.className = "e";

            if (div.getElementsByClassName("e").length === 1) {
                return;
            }

            Expr.order.splice(1, 0, "CLASS");
            Expr.find.CLASS = function (match, context, isXML) {
                if (typeof context.getElementsByClassName !== "undefined" && !isXML) {
                    return context.getElementsByClassName(match[1]);
                }
            };

            // release memory in IE
            div = null;
        })();

        function dirNodeCheck(dir, cur, doneName, checkSet, nodeCheck, isXML) {
            for (var i = 0, l = checkSet.length; i < l; i++) {
                var elem = checkSet[i];

                if (elem) {
                    var match = false;

                    elem = elem[dir];

                    while (elem) {
                        if (elem.sizcache === doneName) {
                            match = checkSet[elem.sizset];
                            break;
                        }

                        if (elem.nodeType === 1 && !isXML) {
                            elem.sizcache = doneName;
                            elem.sizset = i;
                        }

                        if (elem.nodeName.toLowerCase() === cur) {
                            match = elem;
                            break;
                        }

                        elem = elem[dir];
                    }

                    checkSet[i] = match;
                }
            }
        }

        function dirCheck(dir, cur, doneName, checkSet, nodeCheck, isXML) {
            for (var i = 0, l = checkSet.length; i < l; i++) {
                var elem = checkSet[i];

                if (elem) {
                    var match = false;

                    elem = elem[dir];

                    while (elem) {
                        if (elem.sizcache === doneName) {
                            match = checkSet[elem.sizset];
                            break;
                        }

                        if (elem.nodeType === 1) {
                            if (!isXML) {
                                elem.sizcache = doneName;
                                elem.sizset = i;
                            }

                            if (typeof cur !== "string") {
                                if (elem === cur) {
                                    match = true;
                                    break;
                                }

                            } else if (Sizzle.filter(cur, [elem]).length > 0) {
                                match = elem;
                                break;
                            }
                        }

                        elem = elem[dir];
                    }

                    checkSet[i] = match;
                }
            }
        }

        if (document.documentElement.contains) {
            Sizzle.contains = function (a, b) {
                return a !== b && (a.contains ? a.contains(b) : true);
            };

        } else if (document.documentElement.compareDocumentPosition) {
            Sizzle.contains = function (a, b) {
                return !!(a.compareDocumentPosition(b) & 16);
            };

        } else {
            Sizzle.contains = function () {
                return false;
            };
        }

        Sizzle.isXML = function (elem) {
            // documentElement is verified for cases where it doesn't yet exist
            // (such as loading iframes in IE - #4833) 
            var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;

            return documentElement ? documentElement.nodeName !== "HTML" : false;
        };

        var posProcess = function (selector, context) {
            var match,
		tmpSet = [],
		later = "",
		root = context.nodeType ? [context] : context;

            // Position selectors must be done after the filter
            // And so must :not(positional) so we move all PSEUDOs to the end
            while ((match = Expr.match.PSEUDO.exec(selector))) {
                later += match[0];
                selector = selector.replace(Expr.match.PSEUDO, "");
            }

            selector = Expr.relative[selector] ? selector + "*" : selector;

            for (var i = 0, l = root.length; i < l; i++) {
                Sizzle(selector, root[i], tmpSet);
            }

            return Sizzle.filter(later, tmpSet);
        };

        // EXPOSE
        jQuery.find = Sizzle;
        jQuery.expr = Sizzle.selectors;
        jQuery.expr[":"] = jQuery.expr.filters;
        jQuery.unique = Sizzle.uniqueSort;
        jQuery.text = Sizzle.getText;
        jQuery.isXMLDoc = Sizzle.isXML;
        jQuery.contains = Sizzle.contains;


    })();


    var runtil = /Until$/,
	rparentsprev = /^(?:parents|prevUntil|prevAll)/,
    // Note: This RegExp should be improved, or likely pulled from Sizzle
	rmultiselector = /,/,
	isSimple = /^.[^:#\[\.,]*$/,
	slice = Array.prototype.slice,
	POS = jQuery.expr.match.POS,
    // methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
	    children: true,
	    contents: true,
	    next: true,
	    prev: true
	};

    jQuery.fn.extend({
        find: function (selector) {
            var self = this,
			i, l;

            if (typeof selector !== "string") {
                return jQuery(selector).filter(function () {
                    for (i = 0, l = self.length; i < l; i++) {
                        if (jQuery.contains(self[i], this)) {
                            return true;
                        }
                    }
                });
            }

            var ret = this.pushStack("", "find", selector),
			length, n, r;

            for (i = 0, l = this.length; i < l; i++) {
                length = ret.length;
                jQuery.find(selector, this[i], ret);

                if (i > 0) {
                    // Make sure that the results are unique
                    for (n = length; n < ret.length; n++) {
                        for (r = 0; r < length; r++) {
                            if (ret[r] === ret[n]) {
                                ret.splice(n--, 1);
                                break;
                            }
                        }
                    }
                }
            }

            return ret;
        },

        has: function (target) {
            var targets = jQuery(target);
            return this.filter(function () {
                for (var i = 0, l = targets.length; i < l; i++) {
                    if (jQuery.contains(this, targets[i])) {
                        return true;
                    }
                }
            });
        },

        not: function (selector) {
            return this.pushStack(winnow(this, selector, false), "not", selector);
        },

        filter: function (selector) {
            return this.pushStack(winnow(this, selector, true), "filter", selector);
        },

        is: function (selector) {
            return !!selector && (typeof selector === "string" ?
			jQuery.filter(selector, this).length > 0 :
			this.filter(selector).length > 0);
        },

        closest: function (selectors, context) {
            var ret = [], i, l, cur = this[0];

            // Array
            if (jQuery.isArray(selectors)) {
                var match, selector,
				matches = {},
				level = 1;

                if (cur && selectors.length) {
                    for (i = 0, l = selectors.length; i < l; i++) {
                        selector = selectors[i];

                        if (!matches[selector]) {
                            matches[selector] = POS.test(selector) ?
							jQuery(selector, context || this.context) :
							selector;
                        }
                    }

                    while (cur && cur.ownerDocument && cur !== context) {
                        for (selector in matches) {
                            match = matches[selector];

                            if (match.jquery ? match.index(cur) > -1 : jQuery(cur).is(match)) {
                                ret.push({ selector: selector, elem: cur, level: level });
                            }
                        }

                        cur = cur.parentNode;
                        level++;
                    }
                }

                return ret;
            }

            // String
            var pos = POS.test(selectors) || typeof selectors !== "string" ?
				jQuery(selectors, context || this.context) :
				0;

            for (i = 0, l = this.length; i < l; i++) {
                cur = this[i];

                while (cur) {
                    if (pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors)) {
                        ret.push(cur);
                        break;

                    } else {
                        cur = cur.parentNode;
                        if (!cur || !cur.ownerDocument || cur === context || cur.nodeType === 11) {
                            break;
                        }
                    }
                }
            }

            ret = ret.length > 1 ? jQuery.unique(ret) : ret;

            return this.pushStack(ret, "closest", selectors);
        },

        // Determine the position of an element within
        // the matched set of elements
        index: function (elem) {
            if (!elem || typeof elem === "string") {
                return jQuery.inArray(this[0],
                // If it receives a string, the selector is used
                // If it receives nothing, the siblings are used
				elem ? jQuery(elem) : this.parent().children());
            }
            // Locate the position of the desired element
            return jQuery.inArray(
            // If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem, this);
        },

        add: function (selector, context) {
            var set = typeof selector === "string" ?
				jQuery(selector, context) :
				jQuery.makeArray(selector && selector.nodeType ? [selector] : selector),
			all = jQuery.merge(this.get(), set);

            return this.pushStack(isDisconnected(set[0]) || isDisconnected(all[0]) ?
			all :
			jQuery.unique(all));
        },

        andSelf: function () {
            return this.add(this.prevObject);
        }
    });

    // A painfully simple check to see if an element is disconnected
    // from a document (should be improved, where feasible).
    function isDisconnected(node) {
        return !node || !node.parentNode || node.parentNode.nodeType === 11;
    }

    jQuery.each({
        parent: function (elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function (elem) {
            return jQuery.dir(elem, "parentNode");
        },
        parentsUntil: function (elem, i, until) {
            return jQuery.dir(elem, "parentNode", until);
        },
        next: function (elem) {
            return jQuery.nth(elem, 2, "nextSibling");
        },
        prev: function (elem) {
            return jQuery.nth(elem, 2, "previousSibling");
        },
        nextAll: function (elem) {
            return jQuery.dir(elem, "nextSibling");
        },
        prevAll: function (elem) {
            return jQuery.dir(elem, "previousSibling");
        },
        nextUntil: function (elem, i, until) {
            return jQuery.dir(elem, "nextSibling", until);
        },
        prevUntil: function (elem, i, until) {
            return jQuery.dir(elem, "previousSibling", until);
        },
        siblings: function (elem) {
            return jQuery.sibling(elem.parentNode.firstChild, elem);
        },
        children: function (elem) {
            return jQuery.sibling(elem.firstChild);
        },
        contents: function (elem) {
            return jQuery.nodeName(elem, "iframe") ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.makeArray(elem.childNodes);
        }
    }, function (name, fn) {
        jQuery.fn[name] = function (until, selector) {
            var ret = jQuery.map(this, fn, until),
            // The variable 'args' was introduced in
            // https://github.com/jquery/jquery/commit/52a0238
            // to work around a bug in Chrome 10 (Dev) and should be removed when the bug is fixed.
            // http://code.google.com/p/v8/issues/detail?id=1050
			args = slice.call(arguments);

            if (!runtil.test(name)) {
                selector = until;
            }

            if (selector && typeof selector === "string") {
                ret = jQuery.filter(selector, ret);
            }

            ret = this.length > 1 && !guaranteedUnique[name] ? jQuery.unique(ret) : ret;

            if ((this.length > 1 || rmultiselector.test(selector)) && rparentsprev.test(name)) {
                ret = ret.reverse();
            }

            return this.pushStack(ret, name, args.join(","));
        };
    });

    jQuery.extend({
        filter: function (expr, elems, not) {
            if (not) {
                expr = ":not(" + expr + ")";
            }

            return elems.length === 1 ?
			jQuery.find.matchesSelector(elems[0], expr) ? [elems[0]] : [] :
			jQuery.find.matches(expr, elems);
        },

        dir: function (elem, dir, until) {
            var matched = [],
			cur = elem[dir];

            while (cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery(cur).is(until))) {
                if (cur.nodeType === 1) {
                    matched.push(cur);
                }
                cur = cur[dir];
            }
            return matched;
        },

        nth: function (cur, result, dir, elem) {
            result = result || 1;
            var num = 0;

            for (; cur; cur = cur[dir]) {
                if (cur.nodeType === 1 && ++num === result) {
                    break;
                }
            }

            return cur;
        },

        sibling: function (n, elem) {
            var r = [];

            for (; n; n = n.nextSibling) {
                if (n.nodeType === 1 && n !== elem) {
                    r.push(n);
                }
            }

            return r;
        }
    });

    // Implement the identical functionality for filter and not
    function winnow(elements, qualifier, keep) {

        // Can't pass null or undefined to indexOf in Firefox 4
        // Set to 0 to skip string check
        qualifier = qualifier || 0;

        if (jQuery.isFunction(qualifier)) {
            return jQuery.grep(elements, function (elem, i) {
                var retVal = !!qualifier.call(elem, i, elem);
                return retVal === keep;
            });

        } else if (qualifier.nodeType) {
            return jQuery.grep(elements, function (elem, i) {
                return (elem === qualifier) === keep;
            });

        } else if (typeof qualifier === "string") {
            var filtered = jQuery.grep(elements, function (elem) {
                return elem.nodeType === 1;
            });

            if (isSimple.test(qualifier)) {
                return jQuery.filter(qualifier, filtered, !keep);
            } else {
                qualifier = jQuery.filter(qualifier, filtered);
            }
        }

        return jQuery.grep(elements, function (elem, i) {
            return (jQuery.inArray(elem, qualifier) >= 0) === keep;
        });
    }




    var rinlinejQuery = / jQuery\d+="(?:\d+|null)"/g,
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnocache = /<(?:script|object|embed|option|style)/i,
    // checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /\/(java|ecma)script/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)/,
	wrapMap = {
	    option: [1, "<select multiple='multiple'>", "</select>"],
	    legend: [1, "<fieldset>", "</fieldset>"],
	    thead: [1, "<table>", "</table>"],
	    tr: [2, "<table><tbody>", "</tbody></table>"],
	    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
	    col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
	    area: [1, "<map>", "</map>"],
	    _default: [0, "", ""]
	};

    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;

    // IE can't serialize <link> and <script> tags normally
    if (!jQuery.support.htmlSerialize) {
        wrapMap._default = [1, "div<div>", "</div>"];
    }

    jQuery.fn.extend({
        text: function (text) {
            if (jQuery.isFunction(text)) {
                return this.each(function (i) {
                    var self = jQuery(this);

                    self.text(text.call(this, i, self.text()));
                });
            }

            if (typeof text !== "object" && text !== undefined) {
                return this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(text));
            }

            return jQuery.text(this);
        },

        wrapAll: function (html) {
            if (jQuery.isFunction(html)) {
                return this.each(function (i) {
                    jQuery(this).wrapAll(html.call(this, i));
                });
            }

            if (this[0]) {
                // The elements to wrap the target around
                var wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

                if (this[0].parentNode) {
                    wrap.insertBefore(this[0]);
                }

                wrap.map(function () {
                    var elem = this;

                    while (elem.firstChild && elem.firstChild.nodeType === 1) {
                        elem = elem.firstChild;
                    }

                    return elem;
                }).append(this);
            }

            return this;
        },

        wrapInner: function (html) {
            if (jQuery.isFunction(html)) {
                return this.each(function (i) {
                    jQuery(this).wrapInner(html.call(this, i));
                });
            }

            return this.each(function () {
                var self = jQuery(this),
				contents = self.contents();

                if (contents.length) {
                    contents.wrapAll(html);

                } else {
                    self.append(html);
                }
            });
        },

        wrap: function (html) {
            return this.each(function () {
                jQuery(this).wrapAll(html);
            });
        },

        unwrap: function () {
            return this.parent().each(function () {
                if (!jQuery.nodeName(this, "body")) {
                    jQuery(this).replaceWith(this.childNodes);
                }
            }).end();
        },

        append: function () {
            return this.domManip(arguments, true, function (elem) {
                if (this.nodeType === 1) {
                    this.appendChild(elem);
                }
            });
        },

        prepend: function () {
            return this.domManip(arguments, true, function (elem) {
                if (this.nodeType === 1) {
                    this.insertBefore(elem, this.firstChild);
                }
            });
        },

        before: function () {
            if (this[0] && this[0].parentNode) {
                return this.domManip(arguments, false, function (elem) {
                    this.parentNode.insertBefore(elem, this);
                });
            } else if (arguments.length) {
                var set = jQuery(arguments[0]);
                set.push.apply(set, this.toArray());
                return this.pushStack(set, "before", arguments);
            }
        },

        after: function () {
            if (this[0] && this[0].parentNode) {
                return this.domManip(arguments, false, function (elem) {
                    this.parentNode.insertBefore(elem, this.nextSibling);
                });
            } else if (arguments.length) {
                var set = this.pushStack(this, "after", arguments);
                set.push.apply(set, jQuery(arguments[0]).toArray());
                return set;
            }
        },

        // keepData is for internal use only--do not document
        remove: function (selector, keepData) {
            for (var i = 0, elem; (elem = this[i]) != null; i++) {
                if (!selector || jQuery.filter(selector, [elem]).length) {
                    if (!keepData && elem.nodeType === 1) {
                        jQuery.cleanData(elem.getElementsByTagName("*"));
                        jQuery.cleanData([elem]);
                    }

                    if (elem.parentNode) {
                        elem.parentNode.removeChild(elem);
                    }
                }
            }

            return this;
        },

        empty: function () {
            for (var i = 0, elem; (elem = this[i]) != null; i++) {
                // Remove element nodes and prevent memory leaks
                if (elem.nodeType === 1) {
                    jQuery.cleanData(elem.getElementsByTagName("*"));
                }

                // Remove any remaining nodes
                while (elem.firstChild) {
                    elem.removeChild(elem.firstChild);
                }
            }

            return this;
        },

        clone: function (dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

            return this.map(function () {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },

        html: function (value) {
            if (value === undefined) {
                return this[0] && this[0].nodeType === 1 ?
				this[0].innerHTML.replace(rinlinejQuery, "") :
				null;

                // See if we can take a shortcut and just use innerHTML
            } else if (typeof value === "string" && !rnocache.test(value) &&
			(jQuery.support.leadingWhitespace || !rleadingWhitespace.test(value)) &&
			!wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {

                value = value.replace(rxhtmlTag, "<$1></$2>");

                try {
                    for (var i = 0, l = this.length; i < l; i++) {
                        // Remove element nodes and prevent memory leaks
                        if (this[i].nodeType === 1) {
                            jQuery.cleanData(this[i].getElementsByTagName("*"));
                            this[i].innerHTML = value;
                        }
                    }

                    // If using innerHTML throws an exception, use the fallback method
                } catch (e) {
                    this.empty().append(value);
                }

            } else if (jQuery.isFunction(value)) {
                this.each(function (i) {
                    var self = jQuery(this);

                    self.html(value.call(this, i, self.html()));
                });

            } else {
                this.empty().append(value);
            }

            return this;
        },

        replaceWith: function (value) {
            if (this[0] && this[0].parentNode) {
                // Make sure that the elements are removed from the DOM before they are inserted
                // this can help fix replacing a parent with child elements
                if (jQuery.isFunction(value)) {
                    return this.each(function (i) {
                        var self = jQuery(this), old = self.html();
                        self.replaceWith(value.call(this, i, old));
                    });
                }

                if (typeof value !== "string") {
                    value = jQuery(value).detach();
                }

                return this.each(function () {
                    var next = this.nextSibling,
					parent = this.parentNode;

                    jQuery(this).remove();

                    if (next) {
                        jQuery(next).before(value);
                    } else {
                        jQuery(parent).append(value);
                    }
                });
            } else {
                return this.length ?
				this.pushStack(jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value) :
				this;
            }
        },

        detach: function (selector) {
            return this.remove(selector, true);
        },

        domManip: function (args, table, callback) {
            var results, first, fragment, parent,
			value = args[0],
			scripts = [];

            // We can't cloneNode fragments that contain checked, in WebKit
            if (!jQuery.support.checkClone && arguments.length === 3 && typeof value === "string" && rchecked.test(value)) {
                return this.each(function () {
                    jQuery(this).domManip(args, table, callback, true);
                });
            }

            if (jQuery.isFunction(value)) {
                return this.each(function (i) {
                    var self = jQuery(this);
                    args[0] = value.call(this, i, table ? self.html() : undefined);
                    self.domManip(args, table, callback);
                });
            }

            if (this[0]) {
                parent = value && value.parentNode;

                // If we're in a fragment, just use that instead of building a new one
                if (jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length) {
                    results = { fragment: parent };

                } else {
                    results = jQuery.buildFragment(args, this, scripts);
                }

                fragment = results.fragment;

                if (fragment.childNodes.length === 1) {
                    first = fragment = fragment.firstChild;
                } else {
                    first = fragment.firstChild;
                }

                if (first) {
                    table = table && jQuery.nodeName(first, "tr");

                    for (var i = 0, l = this.length, lastIndex = l - 1; i < l; i++) {
                        callback.call(
						table ?
							root(this[i], first) :
							this[i],
                        // Make sure that we do not leak memory by inadvertently discarding
                        // the original fragment (which might have attached data) instead of
                        // using it; in addition, use the original fragment object for the last
                        // item instead of first because it can end up being emptied incorrectly
                        // in certain situations (Bug #8070).
                        // Fragments from the fragment cache must always be cloned and never used
                        // in place.
						results.cacheable || (l > 1 && i < lastIndex) ?
							jQuery.clone(fragment, true, true) :
							fragment
					);
                    }
                }

                if (scripts.length) {
                    jQuery.each(scripts, evalScript);
                }
            }

            return this;
        }
    });

    function root(elem, cur) {
        return jQuery.nodeName(elem, "table") ?
		(elem.getElementsByTagName("tbody")[0] ||
		elem.appendChild(elem.ownerDocument.createElement("tbody"))) :
		elem;
    }

    function cloneCopyEvent(src, dest) {

        if (dest.nodeType !== 1 || !jQuery.hasData(src)) {
            return;
        }

        var internalKey = jQuery.expando,
		oldData = jQuery.data(src),
		curData = jQuery.data(dest, oldData);

        // Switch to use the internal data object, if it exists, for the next
        // stage of data copying
        if ((oldData = oldData[internalKey])) {
            var events = oldData.events;
            curData = curData[internalKey] = jQuery.extend({}, oldData);

            if (events) {
                delete curData.handle;
                curData.events = {};

                for (var type in events) {
                    for (var i = 0, l = events[type].length; i < l; i++) {
                        jQuery.event.add(dest, type + (events[type][i].namespace ? "." : "") + events[type][i].namespace, events[type][i], events[type][i].data);
                    }
                }
            }
        }
    }

    function cloneFixAttributes(src, dest) {
        var nodeName;

        // We do not need to do anything for non-Elements
        if (dest.nodeType !== 1) {
            return;
        }

        // clearAttributes removes the attributes, which we don't want,
        // but also removes the attachEvent events, which we *do* want
        if (dest.clearAttributes) {
            dest.clearAttributes();
        }

        // mergeAttributes, in contrast, only merges back on the
        // original attributes, not the events
        if (dest.mergeAttributes) {
            dest.mergeAttributes(src);
        }

        nodeName = dest.nodeName.toLowerCase();

        // IE6-8 fail to clone children inside object elements that use
        // the proprietary classid attribute value (rather than the type
        // attribute) to identify the type of content to display
        if (nodeName === "object") {
            dest.outerHTML = src.outerHTML;

        } else if (nodeName === "input" && (src.type === "checkbox" || src.type === "radio")) {
            // IE6-8 fails to persist the checked state of a cloned checkbox
            // or radio button. Worse, IE6-7 fail to give the cloned element
            // a checked appearance if the defaultChecked value isn't also set
            if (src.checked) {
                dest.defaultChecked = dest.checked = src.checked;
            }

            // IE6-7 get confused and end up setting the value of a cloned
            // checkbox/radio button to an empty string instead of "on"
            if (dest.value !== src.value) {
                dest.value = src.value;
            }

            // IE6-8 fails to return the selected option to the default selected
            // state when cloning options
        } else if (nodeName === "option") {
            dest.selected = src.defaultSelected;

            // IE6-8 fails to set the defaultValue to the correct value when
            // cloning other types of input fields
        } else if (nodeName === "input" || nodeName === "textarea") {
            dest.defaultValue = src.defaultValue;
        }

        // Event data gets referenced instead of copied if the expando
        // gets copied too
        dest.removeAttribute(jQuery.expando);
    }

    jQuery.buildFragment = function (args, nodes, scripts) {
        var fragment, cacheable, cacheresults, doc;

        // nodes may contain either an explicit document object,
        // a jQuery collection or context object.
        // If nodes[0] contains a valid object to assign to doc
        if (nodes && nodes[0]) {
            doc = nodes[0].ownerDocument || nodes[0];
        }

        // Ensure that an attr object doesn't incorrectly stand in as a document object
        // Chrome and Firefox seem to allow this to occur and will throw exception
        // Fixes #8950
        if (!doc.createDocumentFragment) {
            doc = document;
        }

        // Only cache "small" (1/2 KB) HTML strings that are associated with the main document
        // Cloning options loses the selected state, so don't cache them
        // IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
        // Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
        if (args.length === 1 && typeof args[0] === "string" && args[0].length < 512 && doc === document &&
		args[0].charAt(0) === "<" && !rnocache.test(args[0]) && (jQuery.support.checkClone || !rchecked.test(args[0]))) {

            cacheable = true;

            cacheresults = jQuery.fragments[args[0]];
            if (cacheresults && cacheresults !== 1) {
                fragment = cacheresults;
            }
        }

        if (!fragment) {
            fragment = doc.createDocumentFragment();
            jQuery.clean(args, doc, fragment, scripts);
        }

        if (cacheable) {
            jQuery.fragments[args[0]] = cacheresults ? fragment : 1;
        }

        return { fragment: fragment, cacheable: cacheable };
    };

    jQuery.fragments = {};

    jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function (name, original) {
        jQuery.fn[name] = function (selector) {
            var ret = [],
			insert = jQuery(selector),
			parent = this.length === 1 && this[0].parentNode;

            if (parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1) {
                insert[original](this[0]);
                return this;

            } else {
                for (var i = 0, l = insert.length; i < l; i++) {
                    var elems = (i > 0 ? this.clone(true) : this).get();
                    jQuery(insert[i])[original](elems);
                    ret = ret.concat(elems);
                }

                return this.pushStack(ret, name, insert.selector);
            }
        };
    });

    function getAll(elem) {
        if ("getElementsByTagName" in elem) {
            return elem.getElementsByTagName("*");

        } else if ("querySelectorAll" in elem) {
            return elem.querySelectorAll("*");

        } else {
            return [];
        }
    }

    // Used in clean, fixes the defaultChecked property
    function fixDefaultChecked(elem) {
        if (elem.type === "checkbox" || elem.type === "radio") {
            elem.defaultChecked = elem.checked;
        }
    }
    // Finds all inputs and passes them to fixDefaultChecked
    function findInputs(elem) {
        if (jQuery.nodeName(elem, "input")) {
            fixDefaultChecked(elem);
        } else if ("getElementsByTagName" in elem) {
            jQuery.grep(elem.getElementsByTagName("input"), fixDefaultChecked);
        }
    }

    jQuery.extend({
        clone: function (elem, dataAndEvents, deepDataAndEvents) {
            var clone = elem.cloneNode(true),
				srcElements,
				destElements,
				i;

            if ((!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                // IE copies events bound via attachEvent when using cloneNode.
                // Calling detachEvent on the clone will also remove the events
                // from the original. In order to get around this, we use some
                // proprietary methods to clear the events. Thanks to MooTools
                // guys for this hotness.

                cloneFixAttributes(elem, clone);

                // Using Sizzle here is crazy slow, so we use getElementsByTagName
                // instead
                srcElements = getAll(elem);
                destElements = getAll(clone);

                // Weird iteration because IE will replace the length property
                // with an element if you are cloning the body and one of the
                // elements on the page has a name or id of "length"
                for (i = 0; srcElements[i]; ++i) {
                    cloneFixAttributes(srcElements[i], destElements[i]);
                }
            }

            // Copy the events from the original to the clone
            if (dataAndEvents) {
                cloneCopyEvent(elem, clone);

                if (deepDataAndEvents) {
                    srcElements = getAll(elem);
                    destElements = getAll(clone);

                    for (i = 0; srcElements[i]; ++i) {
                        cloneCopyEvent(srcElements[i], destElements[i]);
                    }
                }
            }

            srcElements = destElements = null;

            // Return the cloned set
            return clone;
        },

        clean: function (elems, context, fragment, scripts) {
            var checkScriptType;

            context = context || document;

            // !context.createElement fails in IE with an error but returns typeof 'object'
            if (typeof context.createElement === "undefined") {
                context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
            }

            var ret = [], j;

            for (var i = 0, elem; (elem = elems[i]) != null; i++) {
                if (typeof elem === "number") {
                    elem += "";
                }

                if (!elem) {
                    continue;
                }

                // Convert html string into DOM nodes
                if (typeof elem === "string") {
                    if (!rhtml.test(elem)) {
                        elem = context.createTextNode(elem);
                    } else {
                        // Fix "XHTML"-style tags in all browsers
                        elem = elem.replace(rxhtmlTag, "<$1></$2>");

                        // Trim whitespace, otherwise indexOf won't work as expected
                        var tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase(),
						wrap = wrapMap[tag] || wrapMap._default,
						depth = wrap[0],
						div = context.createElement("div");

                        // Go to html and back, then peel off extra wrappers
                        div.innerHTML = wrap[1] + elem + wrap[2];

                        // Move to the right depth
                        while (depth--) {
                            div = div.lastChild;
                        }

                        // Remove IE's autoinserted <tbody> from table fragments
                        if (!jQuery.support.tbody) {

                            // String was a <table>, *may* have spurious <tbody>
                            var hasBody = rtbody.test(elem),
							tbody = tag === "table" && !hasBody ?
								div.firstChild && div.firstChild.childNodes :

                            // String was a bare <thead> or <tfoot>
								wrap[1] === "<table>" && !hasBody ?
									div.childNodes :
									[];

                            for (j = tbody.length - 1; j >= 0; --j) {
                                if (jQuery.nodeName(tbody[j], "tbody") && !tbody[j].childNodes.length) {
                                    tbody[j].parentNode.removeChild(tbody[j]);
                                }
                            }
                        }

                        // IE completely kills leading whitespace when innerHTML is used
                        if (!jQuery.support.leadingWhitespace && rleadingWhitespace.test(elem)) {
                            div.insertBefore(context.createTextNode(rleadingWhitespace.exec(elem)[0]), div.firstChild);
                        }

                        elem = div.childNodes;
                    }
                }

                // Resets defaultChecked for any radios and checkboxes
                // about to be appended to the DOM in IE 6/7 (#8060)
                var len;
                if (!jQuery.support.appendChecked) {
                    if (elem[0] && typeof (len = elem.length) === "number") {
                        for (j = 0; j < len; j++) {
                            findInputs(elem[j]);
                        }
                    } else {
                        findInputs(elem);
                    }
                }

                if (elem.nodeType) {
                    ret.push(elem);
                } else {
                    ret = jQuery.merge(ret, elem);
                }
            }

            if (fragment) {
                checkScriptType = function (elem) {
                    return !elem.type || rscriptType.test(elem.type);
                };
                for (i = 0; ret[i]; i++) {
                    if (scripts && jQuery.nodeName(ret[i], "script") && (!ret[i].type || ret[i].type.toLowerCase() === "text/javascript")) {
                        scripts.push(ret[i].parentNode ? ret[i].parentNode.removeChild(ret[i]) : ret[i]);

                    } else {
                        if (ret[i].nodeType === 1) {
                            var jsTags = jQuery.grep(ret[i].getElementsByTagName("script"), checkScriptType);

                            ret.splice.apply(ret, [i + 1, 0].concat(jsTags));
                        }
                        fragment.appendChild(ret[i]);
                    }
                }
            }

            return ret;
        },

        cleanData: function (elems) {
            var data, id, cache = jQuery.cache, internalKey = jQuery.expando, special = jQuery.event.special,
			deleteExpando = jQuery.support.deleteExpando;

            for (var i = 0, elem; (elem = elems[i]) != null; i++) {
                if (elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()]) {
                    continue;
                }

                id = elem[jQuery.expando];

                if (id) {
                    data = cache[id] && cache[id][internalKey];

                    if (data && data.events) {
                        for (var type in data.events) {
                            if (special[type]) {
                                jQuery.event.remove(elem, type);

                                // This is a shortcut to avoid jQuery.event.remove's overhead
                            } else {
                                jQuery.removeEvent(elem, type, data.handle);
                            }
                        }

                        // Null the DOM reference to avoid IE6/7/8 leak (#7054)
                        if (data.handle) {
                            data.handle.elem = null;
                        }
                    }

                    if (deleteExpando) {
                        delete elem[jQuery.expando];

                    } else if (elem.removeAttribute) {
                        elem.removeAttribute(jQuery.expando);
                    }

                    delete cache[id];
                }
            }
        }
    });

    function evalScript(i, elem) {
        if (elem.src) {
            jQuery.ajax({
                url: elem.src,
                async: false,
                dataType: "script"
            });
        } else {
            jQuery.globalEval((elem.text || elem.textContent || elem.innerHTML || "").replace(rcleanScript, "/*$0*/"));
        }

        if (elem.parentNode) {
            elem.parentNode.removeChild(elem);
        }
    }



    var ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity=([^)]*)/,
    // fixed for IE9, see #8346
	rupper = /([A-Z]|^ms)/g,
	rnumpx = /^-?\d+(?:px)?$/i,
	rnum = /^-?\d/,
	rrelNum = /^[+\-]=/,
	rrelNumFilter = /[^+\-\.\de]+/g,

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssWidth = ["Left", "Right"],
	cssHeight = ["Top", "Bottom"],
	curCSS,

	getComputedStyle,
	currentStyle;

    jQuery.fn.css = function (name, value) {
        // Setting 'undefined' is a no-op
        if (arguments.length === 2 && value === undefined) {
            return this;
        }

        return jQuery.access(this, name, value, true, function (elem, name, value) {
            return value !== undefined ?
			jQuery.style(elem, name, value) :
			jQuery.css(elem, name);
        });
    };

    jQuery.extend({
        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
            opacity: {
                get: function (elem, computed) {
                    if (computed) {
                        // We should always get a number back from opacity
                        var ret = curCSS(elem, "opacity", "opacity");
                        return ret === "" ? "1" : ret;

                    } else {
                        return elem.style.opacity;
                    }
                }
            }
        },

        // Exclude the following css properties to add px
        cssNumber: {
            "fillOpacity": true,
            "fontWeight": true,
            "lineHeight": true,
            "opacity": true,
            "orphans": true,
            "widows": true,
            "zIndex": true,
            "zoom": true
        },

        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {
            // normalize float css property
            "float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
        },

        // Get and set the style property on a DOM Node
        style: function (elem, name, value, extra) {
            // Don't set styles on text and comment nodes
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return;
            }

            // Make sure that we're working with the right name
            var ret, type, origName = jQuery.camelCase(name),
			style = elem.style, hooks = jQuery.cssHooks[origName];

            name = jQuery.cssProps[origName] || origName;

            // Check if we're setting a value
            if (value !== undefined) {
                type = typeof value;

                // Make sure that NaN and null values aren't set. See: #7116
                if (type === "number" && isNaN(value) || value == null) {
                    return;
                }

                // convert relative number strings (+= or -=) to relative numbers. #7345
                if (type === "string" && rrelNum.test(value)) {
                    value = +value.replace(rrelNumFilter, "") + parseFloat(jQuery.css(elem, name));
                    // Fixes bug #9237
                    type = "number";
                }

                // If a number was passed in, add 'px' to the (except for certain CSS properties)
                if (type === "number" && !jQuery.cssNumber[origName]) {
                    value += "px";
                }

                // If a hook was provided, use that value, otherwise just set the specified value
                if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value)) !== undefined) {
                    // Wrapped to prevent IE from throwing errors when 'invalid' values are provided
                    // Fixes bug #5509
                    try {
                        style[name] = value;
                    } catch (e) { }
                }

            } else {
                // If a hook was provided get the non-computed value from there
                if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                    return ret;
                }

                // Otherwise just get the value from the style object
                return style[name];
            }
        },

        css: function (elem, name, extra) {
            var ret, hooks;

            // Make sure that we're working with the right name
            name = jQuery.camelCase(name);
            hooks = jQuery.cssHooks[name];
            name = jQuery.cssProps[name] || name;

            // cssFloat needs a special treatment
            if (name === "cssFloat") {
                name = "float";
            }

            // If a hook was provided get the computed value from there
            if (hooks && "get" in hooks && (ret = hooks.get(elem, true, extra)) !== undefined) {
                return ret;

                // Otherwise, if a way to get the computed value exists, use that
            } else if (curCSS) {
                return curCSS(elem, name);
            }
        },

        // A method for quickly swapping in/out CSS properties to get correct calculations
        swap: function (elem, options, callback) {
            var old = {};

            // Remember the old values, and insert the new ones
            for (var name in options) {
                old[name] = elem.style[name];
                elem.style[name] = options[name];
            }

            callback.call(elem);

            // Revert the old values
            for (name in options) {
                elem.style[name] = old[name];
            }
        }
    });

    // DEPRECATED, Use jQuery.css() instead
    jQuery.curCSS = jQuery.css;

    jQuery.each(["height", "width"], function (i, name) {
        jQuery.cssHooks[name] = {
            get: function (elem, computed, extra) {
                var val;

                if (computed) {
                    if (elem.offsetWidth !== 0) {
                        return getWH(elem, name, extra);
                    } else {
                        jQuery.swap(elem, cssShow, function () {
                            val = getWH(elem, name, extra);
                        });
                    }

                    return val;
                }
            },

            set: function (elem, value) {
                if (rnumpx.test(value)) {
                    // ignore negative width and height values #1599
                    value = parseFloat(value);

                    if (value >= 0) {
                        return value + "px";
                    }

                } else {
                    return value;
                }
            }
        };
    });

    if (!jQuery.support.opacity) {
        jQuery.cssHooks.opacity = {
            get: function (elem, computed) {
                // IE uses filters for opacity
                return ropacity.test((computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "") ?
				(parseFloat(RegExp.$1) / 100) + "" :
				computed ? "1" : "";
            },

            set: function (elem, value) {
                var style = elem.style,
				currentStyle = elem.currentStyle;

                // IE has trouble with opacity if it does not have layout
                // Force it by setting the zoom level
                style.zoom = 1;

                // Set the alpha filter to set the opacity
                var opacity = jQuery.isNaN(value) ?
				"" :
				"alpha(opacity=" + value * 100 + ")",
				filter = currentStyle && currentStyle.filter || style.filter || "";

                style.filter = ralpha.test(filter) ?
				filter.replace(ralpha, opacity) :
				filter + " " + opacity;
            }
        };
    }

    jQuery(function () {
        // This hook cannot be added until DOM ready because the support test
        // for it is not run until after DOM ready
        if (!jQuery.support.reliableMarginRight) {
            jQuery.cssHooks.marginRight = {
                get: function (elem, computed) {
                    // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                    // Work around by temporarily setting element display to inline-block
                    var ret;
                    jQuery.swap(elem, { "display": "inline-block" }, function () {
                        if (computed) {
                            ret = curCSS(elem, "margin-right", "marginRight");
                        } else {
                            ret = elem.style.marginRight;
                        }
                    });
                    return ret;
                }
            };
        }
    });

    if (document.defaultView && document.defaultView.getComputedStyle) {
        getComputedStyle = function (elem, name) {
            var ret, defaultView, computedStyle;

            name = name.replace(rupper, "-$1").toLowerCase();

            if (!(defaultView = elem.ownerDocument.defaultView)) {
                return undefined;
            }

            if ((computedStyle = defaultView.getComputedStyle(elem, null))) {
                ret = computedStyle.getPropertyValue(name);
                if (ret === "" && !jQuery.contains(elem.ownerDocument.documentElement, elem)) {
                    ret = jQuery.style(elem, name);
                }
            }

            return ret;
        };
    }

    if (document.documentElement.currentStyle) {
        currentStyle = function (elem, name) {
            var left,
			ret = elem.currentStyle && elem.currentStyle[name],
			rsLeft = elem.runtimeStyle && elem.runtimeStyle[name],
			style = elem.style;

            // From the awesome hack by Dean Edwards
            // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

            // If we're not dealing with a regular pixel number
            // but a number that has a weird ending, we need to convert it to pixels
            if (!rnumpx.test(ret) && rnum.test(ret)) {
                // Remember the original values
                left = style.left;

                // Put in the new values to get a computed value out
                if (rsLeft) {
                    elem.runtimeStyle.left = elem.currentStyle.left;
                }
                style.left = name === "fontSize" ? "1em" : (ret || 0);
                ret = style.pixelLeft + "px";

                // Revert the changed values
                style.left = left;
                if (rsLeft) {
                    elem.runtimeStyle.left = rsLeft;
                }
            }

            return ret === "" ? "auto" : ret;
        };
    }

    curCSS = getComputedStyle || currentStyle;

    function getWH(elem, name, extra) {

        // Start with offset property
        var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		which = name === "width" ? cssWidth : cssHeight;

        if (val > 0) {
            if (extra !== "border") {
                jQuery.each(which, function () {
                    if (!extra) {
                        val -= parseFloat(jQuery.css(elem, "padding" + this)) || 0;
                    }
                    if (extra === "margin") {
                        val += parseFloat(jQuery.css(elem, extra + this)) || 0;
                    } else {
                        val -= parseFloat(jQuery.css(elem, "border" + this + "Width")) || 0;
                    }
                });
            }

            return val + "px";
        }

        // Fall back to computed then uncomputed css if necessary
        val = curCSS(elem, name, name);
        if (val < 0 || val == null) {
            val = elem.style[name] || 0;
        }
        // Normalize "", auto, and prepare for extra
        val = parseFloat(val) || 0;

        // Add padding, border, margin
        if (extra) {
            jQuery.each(which, function () {
                val += parseFloat(jQuery.css(elem, "padding" + this)) || 0;
                if (extra !== "padding") {
                    val += parseFloat(jQuery.css(elem, "border" + this + "Width")) || 0;
                }
                if (extra === "margin") {
                    val += parseFloat(jQuery.css(elem, extra + this)) || 0;
                }
            });
        }

        return val + "px";
    }

    if (jQuery.expr && jQuery.expr.filters) {
        jQuery.expr.filters.hidden = function (elem) {
            var width = elem.offsetWidth,
			height = elem.offsetHeight;

            return (width === 0 && height === 0) || (!jQuery.support.reliableHiddenOffsets && (elem.style.display || jQuery.css(elem, "display")) === "none");
        };

        jQuery.expr.filters.visible = function (elem) {
            return !jQuery.expr.filters.hidden(elem);
        };
    }




    var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rhash = /#.*$/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
	rinput = /^(?:color|date|datetime|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
    // #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rquery = /\?/,
	rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
	rselectTextarea = /^(?:select|textarea)/i,
	rspacesAjax = /\s+/,
	rts = /([?&])_=[^&]*/,
	rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,

    // Keep a copy of the old load method
	_load = jQuery.fn.load,

    /* Prefilters
    * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
    * 2) These are called:
    *    - BEFORE asking for a transport
    *    - AFTER param serialization (s.data is a string if s.processData is true)
    * 3) key is the dataType
    * 4) the catchall symbol "*" can be used
    * 5) execution will start with transport dataType and THEN continue down to "*" if needed
    */
	prefilters = {},

    /* Transports bindings
    * 1) key is the dataType
    * 2) the catchall symbol "*" can be used
    * 3) selection will start with transport dataType and THEN go to "*" if needed
    */
	transports = {},

    // Document location
	ajaxLocation,

    // Document location segments
	ajaxLocParts;

    // #8138, IE may throw an exception when accessing
    // a field from window.location if document.domain has been set
    try {
        ajaxLocation = location.href;
    } catch (e) {
        // Use the href attribute of an A element
        // since IE will modify it given document.location
        ajaxLocation = document.createElement("a");
        ajaxLocation.href = "";
        ajaxLocation = ajaxLocation.href;
    }

    // Segment location into parts
    ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];

    // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
    function addToPrefiltersOrTransports(structure) {

        // dataTypeExpression is optional and defaults to "*"
        return function (dataTypeExpression, func) {

            if (typeof dataTypeExpression !== "string") {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }

            if (jQuery.isFunction(func)) {
                var dataTypes = dataTypeExpression.toLowerCase().split(rspacesAjax),
				i = 0,
				length = dataTypes.length,
				dataType,
				list,
				placeBefore;

                // For each dataType in the dataTypeExpression
                for (; i < length; i++) {
                    dataType = dataTypes[i];
                    // We control if we're asked to add before
                    // any existing element
                    placeBefore = /^\+/.test(dataType);
                    if (placeBefore) {
                        dataType = dataType.substr(1) || "*";
                    }
                    list = structure[dataType] = structure[dataType] || [];
                    // then we add to the structure accordingly
                    list[placeBefore ? "unshift" : "push"](func);
                }
            }
        };
    }

    // Base inspection function for prefilters and transports
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR,
		dataType /* internal */, inspected /* internal */) {

        dataType = dataType || options.dataTypes[0];
        inspected = inspected || {};

        inspected[dataType] = true;

        var list = structure[dataType],
		i = 0,
		length = list ? list.length : 0,
		executeOnly = (structure === prefilters),
		selection;

        for (; i < length && (executeOnly || !selection); i++) {
            selection = list[i](options, originalOptions, jqXHR);
            // If we got redirected to another dataType
            // we try there if executing only and not done already
            if (typeof selection === "string") {
                if (!executeOnly || inspected[selection]) {
                    selection = undefined;
                } else {
                    options.dataTypes.unshift(selection);
                    selection = inspectPrefiltersOrTransports(
						structure, options, originalOptions, jqXHR, selection, inspected);
                }
            }
        }
        // If we're only executing or nothing was selected
        // we try the catchall dataType if not done already
        if ((executeOnly || !selection) && !inspected["*"]) {
            selection = inspectPrefiltersOrTransports(
				structure, options, originalOptions, jqXHR, "*", inspected);
        }
        // unnecessary when only executing (prefilters)
        // but it'll be ignored by the caller in that case
        return selection;
    }

    jQuery.fn.extend({
        load: function (url, params, callback) {
            if (typeof url !== "string" && _load) {
                return _load.apply(this, arguments);

                // Don't do a request if no elements are being requested
            } else if (!this.length) {
                return this;
            }

            var off = url.indexOf(" ");
            if (off >= 0) {
                var selector = url.slice(off, url.length);
                url = url.slice(0, off);
            }

            // Default to a GET request
            var type = "GET";

            // If the second parameter was provided
            if (params) {
                // If it's a function
                if (jQuery.isFunction(params)) {
                    // We assume that it's the callback
                    callback = params;
                    params = undefined;

                    // Otherwise, build a param string
                } else if (typeof params === "object") {
                    params = jQuery.param(params, jQuery.ajaxSettings.traditional);
                    type = "POST";
                }
            }

            var self = this;

            // Request the remote document
            jQuery.ajax({
                url: url,
                type: type,
                dataType: "html",
                data: params,
                // Complete callback (responseText is used internally)
                complete: function (jqXHR, status, responseText) {
                    // Store the response as specified by the jqXHR object
                    responseText = jqXHR.responseText;
                    // If successful, inject the HTML into all the matched elements
                    if (jqXHR.isResolved()) {
                        // #4825: Get the actual response in case
                        // a dataFilter is present in ajaxSettings
                        jqXHR.done(function (r) {
                            responseText = r;
                        });
                        // See if a selector was specified
                        self.html(selector ?
                        // Create a dummy div to hold the results
						jQuery("<div>")
                        // inject the contents of the document in, removing the scripts
                        // to avoid any 'Permission Denied' errors in IE
							.append(responseText.replace(rscript, ""))

                        // Locate the specified elements
							.find(selector) :

                        // If not, just inject the full result
						responseText);
                    }

                    if (callback) {
                        self.each(callback, [responseText, status, jqXHR]);
                    }
                }
            });

            return this;
        },

        serialize: function () {
            return jQuery.param(this.serializeArray());
        },

        serializeArray: function () {
            return this.map(function () {
                return this.elements ? jQuery.makeArray(this.elements) : this;
            })
		.filter(function () {
		    return this.name && !this.disabled &&
				(this.checked || rselectTextarea.test(this.nodeName) ||
					rinput.test(this.type));
		})
		.map(function (i, elem) {
		    var val = jQuery(this).val();

		    return val == null ?
				null :
				jQuery.isArray(val) ?
					jQuery.map(val, function (val, i) {
					    return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
					}) :
					{ name: elem.name, value: val.replace(rCRLF, "\r\n") };
		}).get();
        }
    });

    // Attach a bunch of functions for handling common AJAX events
    jQuery.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "), function (i, o) {
        jQuery.fn[o] = function (f) {
            return this.bind(o, f);
        };
    });

    jQuery.each(["get", "post"], function (i, method) {
        jQuery[method] = function (url, data, callback, type) {
            // shift arguments if data argument was omitted
            if (jQuery.isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined;
            }

            return jQuery.ajax({
                type: method,
                url: url,
                data: data,
                success: callback,
                dataType: type
            });
        };
    });

    jQuery.extend({

        getScript: function (url, callback) {
            return jQuery.get(url, undefined, callback, "script");
        },

        getJSON: function (url, data, callback) {
            return jQuery.get(url, data, callback, "json");
        },

        // Creates a full fledged settings object into target
        // with both ajaxSettings and settings fields.
        // If target is omitted, writes into ajaxSettings.
        ajaxSetup: function (target, settings) {
            if (!settings) {
                // Only one parameter, we extend ajaxSettings
                settings = target;
                target = jQuery.extend(true, jQuery.ajaxSettings, settings);
            } else {
                // target was provided, we extend into it
                jQuery.extend(true, target, jQuery.ajaxSettings, settings);
            }
            // Flatten fields we don't want deep extended
            for (var field in { context: 1, url: 1 }) {
                if (field in settings) {
                    target[field] = settings[field];
                } else if (field in jQuery.ajaxSettings) {
                    target[field] = jQuery.ajaxSettings[field];
                }
            }
            return target;
        },

        ajaxSettings: {
            url: ajaxLocation,
            isLocal: rlocalProtocol.test(ajaxLocParts[1]),
            global: true,
            type: "GET",
            contentType: "application/x-www-form-urlencoded",
            processData: true,
            async: true,
            /*
            timeout: 0,
            data: null,
            dataType: null,
            username: null,
            password: null,
            cache: null,
            traditional: false,
            headers: {},
            */

            accepts: {
                xml: "application/xml, text/xml",
                html: "text/html",
                text: "text/plain",
                json: "application/json, text/javascript",
                "*": "*/*"
            },

            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },

            responseFields: {
                xml: "responseXML",
                text: "responseText"
            },

            // List of data converters
            // 1) key format is "source_type destination_type" (a single space in-between)
            // 2) the catchall symbol "*" can be used for source_type
            converters: {

                // Convert anything to text
                "* text": window.String,

                // Text to html (true = no transformation)
                "text html": true,

                // Evaluate text as a json expression
                "text json": jQuery.parseJSON,

                // Parse text as xml
                "text xml": jQuery.parseXML
            }
        },

        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),

        // Main method
        ajax: function (url, options) {

            // If url is an object, simulate pre-1.5 signature
            if (typeof url === "object") {
                options = url;
                url = undefined;
            }

            // Force options to be an object
            options = options || {};

            var // Create the final options object
			s = jQuery.ajaxSetup({}, options),
            // Callbacks context
			callbackContext = s.context || s,
            // Context for global events
            // It's the callbackContext if one was provided in the options
            // and if it's a DOM node or a jQuery collection
			globalEventContext = callbackContext !== s &&
				(callbackContext.nodeType || callbackContext instanceof jQuery) ?
						jQuery(callbackContext) : jQuery.event,
            // Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery._Deferred(),
            // Status-dependent callbacks
			statusCode = s.statusCode || {},
            // ifModified key
			ifModifiedKey,
            // Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
            // Response headers
			responseHeadersString,
			responseHeaders,
            // transport
			transport,
            // timeout handle
			timeoutTimer,
            // Cross-domain detection vars
			parts,
            // The jqXHR state
			state = 0,
            // To know if global events are to be dispatched
			fireGlobals,
            // Loop variable
			i,
            // Fake xhr
			jqXHR = {

			    readyState: 0,

			    // Caches the header
			    setRequestHeader: function (name, value) {
			        if (!state) {
			            var lname = name.toLowerCase();
			            name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
			            requestHeaders[name] = value;
			        }
			        return this;
			    },

			    // Raw string
			    getAllResponseHeaders: function () {
			        return state === 2 ? responseHeadersString : null;
			    },

			    // Builds headers hashtable if needed
			    getResponseHeader: function (key) {
			        var match;
			        if (state === 2) {
			            if (!responseHeaders) {
			                responseHeaders = {};
			                while ((match = rheaders.exec(responseHeadersString))) {
			                    responseHeaders[match[1].toLowerCase()] = match[2];
			                }
			            }
			            match = responseHeaders[key.toLowerCase()];
			        }
			        return match === undefined ? null : match;
			    },

			    // Overrides response content-type header
			    overrideMimeType: function (type) {
			        if (!state) {
			            s.mimeType = type;
			        }
			        return this;
			    },

			    // Cancel the request
			    abort: function (statusText) {
			        statusText = statusText || "abort";
			        if (transport) {
			            transport.abort(statusText);
			        }
			        done(0, statusText);
			        return this;
			    }
			};

            // Callback for when everything is done
            // It is defined here because jslint complains if it is declared
            // at the end of the function (which would be more logical and readable)
            function done(status, statusText, responses, headers) {

                // Called once
                if (state === 2) {
                    return;
                }

                // State is "done" now
                state = 2;

                // Clear timeout if it exists
                if (timeoutTimer) {
                    clearTimeout(timeoutTimer);
                }

                // Dereference transport for early garbage collection
                // (no matter how long the jqXHR object will be used)
                transport = undefined;

                // Cache response headers
                responseHeadersString = headers || "";

                // Set readyState
                jqXHR.readyState = status ? 4 : 0;

                var isSuccess,
				success,
				error,
				response = responses ? ajaxHandleResponses(s, jqXHR, responses) : undefined,
				lastModified,
				etag;

                // If successful, handle type chaining
                if (status >= 200 && status < 300 || status === 304) {

                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                    if (s.ifModified) {

                        if ((lastModified = jqXHR.getResponseHeader("Last-Modified"))) {
                            jQuery.lastModified[ifModifiedKey] = lastModified;
                        }
                        if ((etag = jqXHR.getResponseHeader("Etag"))) {
                            jQuery.etag[ifModifiedKey] = etag;
                        }
                    }

                    // If not modified
                    if (status === 304) {

                        statusText = "notmodified";
                        isSuccess = true;

                        // If we have data
                    } else {

                        try {
                            success = ajaxConvert(s, response);
                            statusText = "success";
                            isSuccess = true;
                        } catch (e) {
                            // We have a parsererror
                            statusText = "parsererror";
                            error = e;
                        }
                    }
                } else {
                    // We extract error from statusText
                    // then normalize statusText and status for non-aborts
                    error = statusText;
                    if (!statusText || status) {
                        statusText = "error";
                        if (status < 0) {
                            status = 0;
                        }
                    }
                }

                // Set data for the fake xhr object
                jqXHR.status = status;
                jqXHR.statusText = statusText;

                // Success/Error
                if (isSuccess) {
                    deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
                } else {
                    deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
                }

                // Status-dependent callbacks
                jqXHR.statusCode(statusCode);
                statusCode = undefined;

                if (fireGlobals) {
                    globalEventContext.trigger("ajax" + (isSuccess ? "Success" : "Error"),
						[jqXHR, s, isSuccess ? success : error]);
                }

                // Complete
                completeDeferred.resolveWith(callbackContext, [jqXHR, statusText]);

                if (fireGlobals) {
                    globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
                    // Handle the global AJAX counter
                    if (!(--jQuery.active)) {
                        jQuery.event.trigger("ajaxStop");
                    }
                }
            }

            // Attach deferreds
            deferred.promise(jqXHR);
            jqXHR.success = jqXHR.done;
            jqXHR.error = jqXHR.fail;
            jqXHR.complete = completeDeferred.done;

            // Status-dependent callbacks
            jqXHR.statusCode = function (map) {
                if (map) {
                    var tmp;
                    if (state < 2) {
                        for (tmp in map) {
                            statusCode[tmp] = [statusCode[tmp], map[tmp]];
                        }
                    } else {
                        tmp = map[jqXHR.status];
                        jqXHR.then(tmp, tmp);
                    }
                }
                return this;
            };

            // Remove hash character (#7531: and string promotion)
            // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
            // We also use the url parameter if available
            s.url = ((url || s.url) + "").replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//");

            // Extract dataTypes list
            s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().split(rspacesAjax);

            // Determine if a cross-domain request is in order
            if (s.crossDomain == null) {
                parts = rurl.exec(s.url.toLowerCase());
                s.crossDomain = !!(parts &&
				(parts[1] != ajaxLocParts[1] || parts[2] != ajaxLocParts[2] ||
					(parts[3] || (parts[1] === "http:" ? 80 : 443)) !=
						(ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? 80 : 443)))
			);
            }

            // Convert data if not already a string
            if (s.data && s.processData && typeof s.data !== "string") {
                s.data = jQuery.param(s.data, s.traditional);
            }

            // Apply prefilters
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

            // If request was aborted inside a prefiler, stop there
            if (state === 2) {
                return false;
            }

            // We can fire global events as of now if asked to
            fireGlobals = s.global;

            // Uppercase the type
            s.type = s.type.toUpperCase();

            // Determine if request has content
            s.hasContent = !rnoContent.test(s.type);

            // Watch for a new set of requests
            if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger("ajaxStart");
            }

            // More options handling for requests with no content
            if (!s.hasContent) {

                // If data is available, append data to url
                if (s.data) {
                    s.url += (rquery.test(s.url) ? "&" : "?") + s.data;
                }

                // Get ifModifiedKey before adding the anti-cache parameter
                ifModifiedKey = s.url;

                // Add anti-cache in url if needed
                if (s.cache === false) {

                    var ts = jQuery.now(),
                    // try replacing _= if it is there
					ret = s.url.replace(rts, "$1_=" + ts);

                    // if nothing was replaced, add timestamp to the end
                    s.url = ret + ((ret === s.url) ? (rquery.test(s.url) ? "&" : "?") + "_=" + ts : "");
                }
            }

            // Set the correct header, if data is being sent
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                jqXHR.setRequestHeader("Content-Type", s.contentType);
            }

            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
            if (s.ifModified) {
                ifModifiedKey = ifModifiedKey || s.url;
                if (jQuery.lastModified[ifModifiedKey]) {
                    jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[ifModifiedKey]);
                }
                if (jQuery.etag[ifModifiedKey]) {
                    jqXHR.setRequestHeader("If-None-Match", jQuery.etag[ifModifiedKey]);
                }
            }

            // Set the Accepts header for the server, depending on the dataType
            jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[0] && s.accepts[s.dataTypes[0]] ?
				s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", */*; q=0.01" : "") :
				s.accepts["*"]
		);

            // Check for headers option
            for (i in s.headers) {
                jqXHR.setRequestHeader(i, s.headers[i]);
            }

            // Allow custom headers/mimetypes and early abort
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
                // Abort if not done already
                jqXHR.abort();
                return false;

            }

            // Install callbacks on deferreds
            for (i in { success: 1, error: 1, complete: 1 }) {
                jqXHR[i](s[i]);
            }

            // Get transport
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

            // If no transport, we auto-abort
            if (!transport) {
                done(-1, "No Transport");
            } else {
                jqXHR.readyState = 1;
                // Send global event
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxSend", [jqXHR, s]);
                }
                // Timeout
                if (s.async && s.timeout > 0) {
                    timeoutTimer = setTimeout(function () {
                        jqXHR.abort("timeout");
                    }, s.timeout);
                }

                try {
                    state = 1;
                    transport.send(requestHeaders, done);
                } catch (e) {
                    // Propagate exception as error if not done
                    if (status < 2) {
                        done(-1, e);
                        // Simply rethrow otherwise
                    } else {
                        jQuery.error(e);
                    }
                }
            }

            return jqXHR;
        },

        // Serialize an array of form elements or a set of
        // key/values into a query string
        param: function (a, traditional) {
            var s = [],
			add = function (key, value) {
			    // If value is a function, invoke it and return its value
			    value = jQuery.isFunction(value) ? value() : value;
			    s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
			};

            // Set traditional to true for jQuery <= 1.3.2 behavior.
            if (traditional === undefined) {
                traditional = jQuery.ajaxSettings.traditional;
            }

            // If an array was passed in, assume that it is an array of form elements.
            if (jQuery.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
                // Serialize the form elements
                jQuery.each(a, function () {
                    add(this.name, this.value);
                });

            } else {
                // If traditional, encode the "old" way (the way 1.3.2 or older
                // did it), otherwise encode params recursively.
                for (var prefix in a) {
                    buildParams(prefix, a[prefix], traditional, add);
                }
            }

            // Return the resulting serialization
            return s.join("&").replace(r20, "+");
        }
    });

    function buildParams(prefix, obj, traditional, add) {
        if (jQuery.isArray(obj)) {
            // Serialize array item.
            jQuery.each(obj, function (i, v) {
                if (traditional || rbracket.test(prefix)) {
                    // Treat each array item as a scalar.
                    add(prefix, v);

                } else {
                    // If array item is non-scalar (array or object), encode its
                    // numeric index to resolve deserialization ambiguity issues.
                    // Note that rack (as of 1.0.0) can't currently deserialize
                    // nested arrays properly, and attempting to do so may cause
                    // a server error. Possible fixes are to modify rack's
                    // deserialization algorithm or to provide an option or flag
                    // to force array serialization to be shallow.
                    buildParams(prefix + "[" + (typeof v === "object" || jQuery.isArray(v) ? i : "") + "]", v, traditional, add);
                }
            });

        } else if (!traditional && obj != null && typeof obj === "object") {
            // Serialize object item.
            for (var name in obj) {
                buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
            }

        } else {
            // Serialize scalar item.
            add(prefix, obj);
        }
    }

    // This is still on the jQuery object... for now
    // Want to move this to jQuery.ajax some day
    jQuery.extend({

        // Counter for holding the number of active queries
        active: 0,

        // Last-Modified header cache for next request
        lastModified: {},
        etag: {}

    });

    /* Handles responses to an ajax request:
    * - sets all responseXXX fields accordingly
    * - finds the right dataType (mediates between content-type and expected dataType)
    * - returns the corresponding response
    */
    function ajaxHandleResponses(s, jqXHR, responses) {

        var contents = s.contents,
		dataTypes = s.dataTypes,
		responseFields = s.responseFields,
		ct,
		type,
		finalDataType,
		firstDataType;

        // Fill responseXXX fields
        for (type in responseFields) {
            if (type in responses) {
                jqXHR[responseFields[type]] = responses[type];
            }
        }

        // Remove auto dataType and get content-type in the process
        while (dataTypes[0] === "*") {
            dataTypes.shift();
            if (ct === undefined) {
                ct = s.mimeType || jqXHR.getResponseHeader("content-type");
            }
        }

        // Check if we're dealing with a known content-type
        if (ct) {
            for (type in contents) {
                if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type);
                    break;
                }
            }
        }

        // Check to see if we have a response for the expected dataType
        if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
        } else {
            // Try convertible dataTypes
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                if (!firstDataType) {
                    firstDataType = type;
                }
            }
            // Or just use first one
            finalDataType = finalDataType || firstDataType;
        }

        // If we found a dataType
        // We add the dataType to the list if needed
        // and return the corresponding response
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
                dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
        }
    }

    // Chain conversions given the request and the original response
    function ajaxConvert(s, response) {

        // Apply the dataFilter if provided
        if (s.dataFilter) {
            response = s.dataFilter(response, s.dataType);
        }

        var dataTypes = s.dataTypes,
		converters = {},
		i,
		key,
		length = dataTypes.length,
		tmp,
        // Current and previous dataTypes
		current = dataTypes[0],
		prev,
        // Conversion expression
		conversion,
        // Conversion function
		conv,
        // Conversion functions (transitive conversion)
		conv1,
		conv2;

        // For each dataType in the chain
        for (i = 1; i < length; i++) {

            // Create converters map
            // with lowercased keys
            if (i === 1) {
                for (key in s.converters) {
                    if (typeof key === "string") {
                        converters[key.toLowerCase()] = s.converters[key];
                    }
                }
            }

            // Get the dataTypes
            prev = current;
            current = dataTypes[i];

            // If current is auto dataType, update it to prev
            if (current === "*") {
                current = prev;
                // If no auto and dataTypes are actually different
            } else if (prev !== "*" && prev !== current) {

                // Get the converter
                conversion = prev + " " + current;
                conv = converters[conversion] || converters["* " + current];

                // If there is no direct converter, search transitively
                if (!conv) {
                    conv2 = undefined;
                    for (conv1 in converters) {
                        tmp = conv1.split(" ");
                        if (tmp[0] === prev || tmp[0] === "*") {
                            conv2 = converters[tmp[1] + " " + current];
                            if (conv2) {
                                conv1 = converters[conv1];
                                if (conv1 === true) {
                                    conv = conv2;
                                } else if (conv2 === true) {
                                    conv = conv1;
                                }
                                break;
                            }
                        }
                    }
                }
                // If we found no converter, dispatch an error
                if (!(conv || conv2)) {
                    jQuery.error("No conversion from " + conversion.replace(" ", " to "));
                }
                // If found converter is not an equivalence
                if (conv !== true) {
                    // Convert with 1 or 2 converters accordingly
                    response = conv ? conv(response) : conv2(conv1(response));
                }
            }
        }
        return response;
    }




    var jsc = jQuery.now(),
	jsre = /(\=)\?(&|$)|\?\?/i;

    // Default jsonp settings
    jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function () {
            return jQuery.expando + "_" + (jsc++);
        }
    });

    // Detect, normalize options and install callbacks for jsonp requests
    jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {

        var inspectData = s.contentType === "application/x-www-form-urlencoded" &&
		(typeof s.data === "string");

        if (s.dataTypes[0] === "jsonp" ||
		s.jsonp !== false && (jsre.test(s.url) ||
				inspectData && jsre.test(s.data))) {

            var responseContainer,
			jsonpCallback = s.jsonpCallback =
				jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback,
			previous = window[jsonpCallback],
			url = s.url,
			data = s.data,
			replace = "$1" + jsonpCallback + "$2";

            if (s.jsonp !== false) {
                url = url.replace(jsre, replace);
                if (s.url === url) {
                    if (inspectData) {
                        data = data.replace(jsre, replace);
                    }
                    if (s.data === data) {
                        // Add callback manually
                        url += (/\?/.test(url) ? "&" : "?") + s.jsonp + "=" + jsonpCallback;
                    }
                }
            }

            s.url = url;
            s.data = data;

            // Install callback
            window[jsonpCallback] = function (response) {
                responseContainer = [response];
            };

            // Clean-up function
            jqXHR.always(function () {
                // Set callback back to previous value
                window[jsonpCallback] = previous;
                // Call if it was a function and we have a response
                if (responseContainer && jQuery.isFunction(previous)) {
                    window[jsonpCallback](responseContainer[0]);
                }
            });

            // Use data converter to retrieve json after script execution
            s.converters["script json"] = function () {
                if (!responseContainer) {
                    jQuery.error(jsonpCallback + " was not called");
                }
                return responseContainer[0];
            };

            // force json dataType
            s.dataTypes[0] = "json";

            // Delegate to script
            return "script";
        }
    });




    // Install script dataType
    jQuery.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /javascript|ecmascript/
        },
        converters: {
            "text script": function (text) {
                jQuery.globalEval(text);
                return text;
            }
        }
    });

    // Handle cache's special case and global
    jQuery.ajaxPrefilter("script", function (s) {
        if (s.cache === undefined) {
            s.cache = false;
        }
        if (s.crossDomain) {
            s.type = "GET";
            s.global = false;
        }
    });

    // Bind script tag hack transport
    jQuery.ajaxTransport("script", function (s) {

        // This transport only deals with cross domain requests
        if (s.crossDomain) {

            var script,
			head = document.head || document.getElementsByTagName("head")[0] || document.documentElement;

            return {

                send: function (_, callback) {

                    script = document.createElement("script");

                    script.async = "async";

                    if (s.scriptCharset) {
                        script.charset = s.scriptCharset;
                    }

                    script.src = s.url;

                    // Attach handlers for all browsers
                    script.onload = script.onreadystatechange = function (_, isAbort) {

                        if (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) {

                            // Handle memory leak in IE
                            script.onload = script.onreadystatechange = null;

                            // Remove the script
                            if (head && script.parentNode) {
                                head.removeChild(script);
                            }

                            // Dereference the script
                            script = undefined;

                            // Callback if not abort
                            if (!isAbort) {
                                callback(200, "success");
                            }
                        }
                    };
                    // Use insertBefore instead of appendChild  to circumvent an IE6 bug.
                    // This arises when a base node is used (#2709 and #4378).
                    head.insertBefore(script, head.firstChild);
                },

                abort: function () {
                    if (script) {
                        script.onload(0, 1);
                    }
                }
            };
        }
    });




    var // #5280: Internet Explorer will keep connections alive if we don't abort on unload
	xhrOnUnloadAbort = window.ActiveXObject ? function () {
	    // Abort all pending requests
	    for (var key in xhrCallbacks) {
	        xhrCallbacks[key](0, 1);
	    }
	} : false,
	xhrId = 0,
	xhrCallbacks;

    // Functions to create xhrs
    function createStandardXHR() {
        try {
            return new window.XMLHttpRequest();
        } catch (e) { }
    }

    function createActiveXHR() {
        try {
            return new window.ActiveXObject("Microsoft.XMLHTTP");
        } catch (e) { }
    }

    // Create the request object
    // (This is still attached to ajaxSettings for backward compatibility)
    jQuery.ajaxSettings.xhr = window.ActiveXObject ?
    /* Microsoft failed to properly
    * implement the XMLHttpRequest in IE7 (can't request local files),
    * so we use the ActiveXObject when it is available
    * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
    * we need a fallback.
    */
	function () {
	    return !this.isLocal && createStandardXHR() || createActiveXHR();
	} :
    // For all other browsers, use the standard XMLHttpRequest object
	createStandardXHR;

    // Determine support properties
    (function (xhr) {
        jQuery.extend(jQuery.support, {
            ajax: !!xhr,
            cors: !!xhr && ("withCredentials" in xhr)
        });
    })(jQuery.ajaxSettings.xhr());

    // Create transport if the browser can provide an xhr
    if (jQuery.support.ajax) {

        jQuery.ajaxTransport(function (s) {
            // Cross domain only allowed if supported through XMLHttpRequest
            if (!s.crossDomain || jQuery.support.cors) {

                var callback;

                return {
                    send: function (headers, complete) {

                        // Get a new xhr
                        var xhr = s.xhr(),
						handle,
						i;

                        // Open the socket
                        // Passing null username, generates a login popup on Opera (#2865)
                        if (s.username) {
                            xhr.open(s.type, s.url, s.async, s.username, s.password);
                        } else {
                            xhr.open(s.type, s.url, s.async);
                        }

                        // Apply custom fields if provided
                        if (s.xhrFields) {
                            for (i in s.xhrFields) {
                                xhr[i] = s.xhrFields[i];
                            }
                        }

                        // Override mime type if needed
                        if (s.mimeType && xhr.overrideMimeType) {
                            xhr.overrideMimeType(s.mimeType);
                        }

                        // X-Requested-With header
                        // For cross-domain requests, seeing as conditions for a preflight are
                        // akin to a jigsaw puzzle, we simply never set it to be sure.
                        // (it can always be set on a per-request basis or even using ajaxSetup)
                        // For same-domain requests, won't change header if already provided.
                        if (!s.crossDomain && !headers["X-Requested-With"]) {
                            headers["X-Requested-With"] = "XMLHttpRequest";
                        }

                        // Need an extra try/catch for cross domain requests in Firefox 3
                        try {
                            for (i in headers) {
                                xhr.setRequestHeader(i, headers[i]);
                            }
                        } catch (_) { }

                        // Do send the request
                        // This may raise an exception which is actually
                        // handled in jQuery.ajax (so no try/catch here)
                        xhr.send((s.hasContent && s.data) || null);

                        // Listener
                        callback = function (_, isAbort) {

                            var status,
							statusText,
							responseHeaders,
							responses,
							xml;

                            // Firefox throws exceptions when accessing properties
                            // of an xhr when a network error occured
                            // http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
                            try {

                                // Was never called and is aborted or complete
                                if (callback && (isAbort || xhr.readyState === 4)) {

                                    // Only called once
                                    callback = undefined;

                                    // Do not keep as active anymore
                                    if (handle) {
                                        xhr.onreadystatechange = jQuery.noop;
                                        if (xhrOnUnloadAbort) {
                                            delete xhrCallbacks[handle];
                                        }
                                    }

                                    // If it's an abort
                                    if (isAbort) {
                                        // Abort it manually if needed
                                        if (xhr.readyState !== 4) {
                                            xhr.abort();
                                        }
                                    } else {
                                        status = xhr.status;
                                        responseHeaders = xhr.getAllResponseHeaders();
                                        responses = {};
                                        xml = xhr.responseXML;

                                        // Construct response list
                                        if (xml && xml.documentElement /* #4958 */) {
                                            responses.xml = xml;
                                        }
                                        responses.text = xhr.responseText;

                                        // Firefox throws an exception when accessing
                                        // statusText for faulty cross-domain requests
                                        try {
                                            statusText = xhr.statusText;
                                        } catch (e) {
                                            // We normalize with Webkit giving an empty statusText
                                            statusText = "";
                                        }

                                        // Filter status for non standard behaviors

                                        // If the request is local and we have data: assume a success
                                        // (success with no data won't get notified, that's the best we
                                        // can do given current implementations)
                                        if (!status && s.isLocal && !s.crossDomain) {
                                            status = responses.text ? 200 : 404;
                                            // IE - #1450: sometimes returns 1223 when it should be 204
                                        } else if (status === 1223) {
                                            status = 204;
                                        }
                                    }
                                }
                            } catch (firefoxAccessException) {
                                if (!isAbort) {
                                    complete(-1, firefoxAccessException);
                                }
                            }

                            // Call complete if needed
                            if (responses) {
                                complete(status, statusText, responses, responseHeaders);
                            }
                        };

                        // if we're in sync mode or it's in cache
                        // and has been retrieved directly (IE6 & IE7)
                        // we need to manually fire the callback
                        if (!s.async || xhr.readyState === 4) {
                            callback();
                        } else {
                            handle = ++xhrId;
                            if (xhrOnUnloadAbort) {
                                // Create the active xhrs callbacks list if needed
                                // and attach the unload handler
                                if (!xhrCallbacks) {
                                    xhrCallbacks = {};
                                    jQuery(window).unload(xhrOnUnloadAbort);
                                }
                                // Add to list of active xhrs callbacks
                                xhrCallbacks[handle] = callback;
                            }
                            xhr.onreadystatechange = callback;
                        }
                    },

                    abort: function () {
                        if (callback) {
                            callback(0, 1);
                        }
                    }
                };
            }
        });
    }




    var elemdisplay = {},
	iframe, iframeDoc,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = /^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,
	timerId,
	fxAttrs = [
    // height animations
		["height", "marginTop", "marginBottom", "paddingTop", "paddingBottom"],
    // width animations
		["width", "marginLeft", "marginRight", "paddingLeft", "paddingRight"],
    // opacity animations
		["opacity"]
	],
	fxNow,
	requestAnimationFrame = window.webkitRequestAnimationFrame ||
		window.mozRequestAnimationFrame ||
		window.oRequestAnimationFrame;

    jQuery.fn.extend({
        show: function (speed, easing, callback) {
            var elem, display;

            if (speed || speed === 0) {
                return this.animate(genFx("show", 3), speed, easing, callback);

            } else {
                for (var i = 0, j = this.length; i < j; i++) {
                    elem = this[i];

                    if (elem.style) {
                        display = elem.style.display;

                        // Reset the inline display of this element to learn if it is
                        // being hidden by cascaded rules or not
                        if (!jQuery._data(elem, "olddisplay") && display === "none") {
                            display = elem.style.display = "";
                        }

                        // Set elements which have been overridden with display: none
                        // in a stylesheet to whatever the default browser style is
                        // for such an element
                        if (display === "" && jQuery.css(elem, "display") === "none") {
                            jQuery._data(elem, "olddisplay", defaultDisplay(elem.nodeName));
                        }
                    }
                }

                // Set the display of most of the elements in a second loop
                // to avoid the constant reflow
                for (i = 0; i < j; i++) {
                    elem = this[i];

                    if (elem.style) {
                        display = elem.style.display;

                        if (display === "" || display === "none") {
                            elem.style.display = jQuery._data(elem, "olddisplay") || "";
                        }
                    }
                }

                return this;
            }
        },

        hide: function (speed, easing, callback) {
            if (speed || speed === 0) {
                return this.animate(genFx("hide", 3), speed, easing, callback);

            } else {
                for (var i = 0, j = this.length; i < j; i++) {
                    if (this[i].style) {
                        var display = jQuery.css(this[i], "display");

                        if (display !== "none" && !jQuery._data(this[i], "olddisplay")) {
                            jQuery._data(this[i], "olddisplay", display);
                        }
                    }
                }

                // Set the display of the elements in a second loop
                // to avoid the constant reflow
                for (i = 0; i < j; i++) {
                    if (this[i].style) {
                        this[i].style.display = "none";
                    }
                }

                return this;
            }
        },

        // Save the old toggle function
        _toggle: jQuery.fn.toggle,

        toggle: function (fn, fn2, callback) {
            var bool = typeof fn === "boolean";

            if (jQuery.isFunction(fn) && jQuery.isFunction(fn2)) {
                this._toggle.apply(this, arguments);

            } else if (fn == null || bool) {
                this.each(function () {
                    var state = bool ? fn : jQuery(this).is(":hidden");
                    jQuery(this)[state ? "show" : "hide"]();
                });

            } else {
                this.animate(genFx("toggle", 3), fn, fn2, callback);
            }

            return this;
        },

        fadeTo: function (speed, to, easing, callback) {
            return this.filter(":hidden").css("opacity", 0).show().end()
					.animate({ opacity: to }, speed, easing, callback);
        },

        animate: function (prop, speed, easing, callback) {
            var optall = jQuery.speed(speed, easing, callback);

            if (jQuery.isEmptyObject(prop)) {
                return this.each(optall.complete, [false]);
            }

            // Do not change referenced properties as per-property easing will be lost
            prop = jQuery.extend({}, prop);

            return this[optall.queue === false ? "each" : "queue"](function () {
                // XXX 'this' does not always have a nodeName when running the
                // test suite

                if (optall.queue === false) {
                    jQuery._mark(this);
                }

                var opt = jQuery.extend({}, optall),
				isElement = this.nodeType === 1,
				hidden = isElement && jQuery(this).is(":hidden"),
				name, val, p,
				display, e,
				parts, start, end, unit;

                // will store per property easing and be used to determine when an animation is complete
                opt.animatedProperties = {};

                for (p in prop) {

                    // property name normalization
                    name = jQuery.camelCase(p);
                    if (p !== name) {
                        prop[name] = prop[p];
                        delete prop[p];
                    }

                    val = prop[name];

                    // easing resolution: per property > opt.specialEasing > opt.easing > 'swing' (default)
                    if (jQuery.isArray(val)) {
                        opt.animatedProperties[name] = val[1];
                        val = prop[name] = val[0];
                    } else {
                        opt.animatedProperties[name] = opt.specialEasing && opt.specialEasing[name] || opt.easing || 'swing';
                    }

                    if (val === "hide" && hidden || val === "show" && !hidden) {
                        return opt.complete.call(this);
                    }

                    if (isElement && (name === "height" || name === "width")) {
                        // Make sure that nothing sneaks out
                        // Record all 3 overflow attributes because IE does not
                        // change the overflow attribute when overflowX and
                        // overflowY are set to the same value
                        opt.overflow = [this.style.overflow, this.style.overflowX, this.style.overflowY];

                        // Set display property to inline-block for height/width
                        // animations on inline elements that are having width/height
                        // animated
                        if (jQuery.css(this, "display") === "inline" &&
							jQuery.css(this, "float") === "none") {
                            if (!jQuery.support.inlineBlockNeedsLayout) {
                                this.style.display = "inline-block";

                            } else {
                                display = defaultDisplay(this.nodeName);

                                // inline-level elements accept inline-block;
                                // block-level elements need to be inline with layout
                                if (display === "inline") {
                                    this.style.display = "inline-block";

                                } else {
                                    this.style.display = "inline";
                                    this.style.zoom = 1;
                                }
                            }
                        }
                    }
                }

                if (opt.overflow != null) {
                    this.style.overflow = "hidden";
                }

                for (p in prop) {
                    e = new jQuery.fx(this, opt, p);
                    val = prop[p];

                    if (rfxtypes.test(val)) {
                        e[val === "toggle" ? hidden ? "show" : "hide" : val]();

                    } else {
                        parts = rfxnum.exec(val);
                        start = e.cur();

                        if (parts) {
                            end = parseFloat(parts[2]);
                            unit = parts[3] || (jQuery.cssNumber[p] ? "" : "px");

                            // We need to compute starting value
                            if (unit !== "px") {
                                jQuery.style(this, p, (end || 1) + unit);
                                start = ((end || 1) / e.cur()) * start;
                                jQuery.style(this, p, start + unit);
                            }

                            // If a +=/-= token was provided, we're doing a relative animation
                            if (parts[1]) {
                                end = ((parts[1] === "-=" ? -1 : 1) * end) + start;
                            }

                            e.custom(start, end, unit);

                        } else {
                            e.custom(start, val, "");
                        }
                    }
                }

                // For JS strict compliance
                return true;
            });
        },

        stop: function (clearQueue, gotoEnd) {
            if (clearQueue) {
                this.queue([]);
            }

            this.each(function () {
                var timers = jQuery.timers,
				i = timers.length;
                // clear marker counters if we know they won't be
                if (!gotoEnd) {
                    jQuery._unmark(true, this);
                }
                while (i--) {
                    if (timers[i].elem === this) {
                        if (gotoEnd) {
                            // force the next step to be the last
                            timers[i](true);
                        }

                        timers.splice(i, 1);
                    }
                }
            });

            // start the next in the queue if the last step wasn't forced
            if (!gotoEnd) {
                this.dequeue();
            }

            return this;
        }

    });

    // Animations created synchronously will run synchronously
    function createFxNow() {
        setTimeout(clearFxNow, 0);
        return (fxNow = jQuery.now());
    }

    function clearFxNow() {
        fxNow = undefined;
    }

    // Generate parameters to create a standard animation
    function genFx(type, num) {
        var obj = {};

        jQuery.each(fxAttrs.concat.apply([], fxAttrs.slice(0, num)), function () {
            obj[this] = type;
        });

        return obj;
    }

    // Generate shortcuts for custom animations
    jQuery.each({
        slideDown: genFx("show", 1),
        slideUp: genFx("hide", 1),
        slideToggle: genFx("toggle", 1),
        fadeIn: { opacity: "show" },
        fadeOut: { opacity: "hide" },
        fadeToggle: { opacity: "toggle" }
    }, function (name, props) {
        jQuery.fn[name] = function (speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    });

    jQuery.extend({
        speed: function (speed, easing, fn) {
            var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
                complete: fn || !fn && easing ||
				jQuery.isFunction(speed) && speed,
                duration: speed,
                easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
            };

            opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
			opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;

            // Queueing
            opt.old = opt.complete;
            opt.complete = function (noUnmark) {
                if (jQuery.isFunction(opt.old)) {
                    opt.old.call(this);
                }

                if (opt.queue !== false) {
                    jQuery.dequeue(this);
                } else if (noUnmark !== false) {
                    jQuery._unmark(this);
                }
            };

            return opt;
        },

        easing: {
            linear: function (p, n, firstNum, diff) {
                return firstNum + diff * p;
            },
            swing: function (p, n, firstNum, diff) {
                return ((-Math.cos(p * Math.PI) / 2) + 0.5) * diff + firstNum;
            }
        },

        timers: [],

        fx: function (elem, options, prop) {
            this.options = options;
            this.elem = elem;
            this.prop = prop;

            options.orig = options.orig || {};
        }

    });

    jQuery.fx.prototype = {
        // Simple function for setting a style value
        update: function () {
            if (this.options.step) {
                this.options.step.call(this.elem, this.now, this);
            }

            (jQuery.fx.step[this.prop] || jQuery.fx.step._default)(this);
        },

        // Get the current size
        cur: function () {
            if (this.elem[this.prop] != null && (!this.elem.style || this.elem.style[this.prop] == null)) {
                return this.elem[this.prop];
            }

            var parsed,
			r = jQuery.css(this.elem, this.prop);
            // Empty strings, null, undefined and "auto" are converted to 0,
            // complex values such as "rotate(1rad)" are returned as is,
            // simple values such as "10px" are parsed to Float.
            return isNaN(parsed = parseFloat(r)) ? !r || r === "auto" ? 0 : r : parsed;
        },

        // Start an animation from one number to another
        custom: function (from, to, unit) {
            var self = this,
			fx = jQuery.fx,
			raf;

            this.startTime = fxNow || createFxNow();
            this.start = from;
            this.end = to;
            this.unit = unit || this.unit || (jQuery.cssNumber[this.prop] ? "" : "px");
            this.now = this.start;
            this.pos = this.state = 0;

            function t(gotoEnd) {
                return self.step(gotoEnd);
            }

            t.elem = this.elem;

            if (t() && jQuery.timers.push(t) && !timerId) {
                // Use requestAnimationFrame instead of setInterval if available
                if (requestAnimationFrame) {
                    timerId = true;
                    raf = function () {
                        // When timerId gets set to null at any point, this stops
                        if (timerId) {
                            requestAnimationFrame(raf);
                            fx.tick();
                        }
                    };
                    requestAnimationFrame(raf);
                } else {
                    timerId = setInterval(fx.tick, fx.interval);
                }
            }
        },

        // Simple 'show' function
        show: function () {
            // Remember where we started, so that we can go back to it later
            this.options.orig[this.prop] = jQuery.style(this.elem, this.prop);
            this.options.show = true;

            // Begin the animation
            // Make sure that we start at a small width/height to avoid any
            // flash of content
            this.custom(this.prop === "width" || this.prop === "height" ? 1 : 0, this.cur());

            // Start by showing the element
            jQuery(this.elem).show();
        },

        // Simple 'hide' function
        hide: function () {
            // Remember where we started, so that we can go back to it later
            this.options.orig[this.prop] = jQuery.style(this.elem, this.prop);
            this.options.hide = true;

            // Begin the animation
            this.custom(this.cur(), 0);
        },

        // Each step of an animation
        step: function (gotoEnd) {
            var t = fxNow || createFxNow(),
			done = true,
			elem = this.elem,
			options = this.options,
			i, n;

            if (gotoEnd || t >= options.duration + this.startTime) {
                this.now = this.end;
                this.pos = this.state = 1;
                this.update();

                options.animatedProperties[this.prop] = true;

                for (i in options.animatedProperties) {
                    if (options.animatedProperties[i] !== true) {
                        done = false;
                    }
                }

                if (done) {
                    // Reset the overflow
                    if (options.overflow != null && !jQuery.support.shrinkWrapBlocks) {

                        jQuery.each(["", "X", "Y"], function (index, value) {
                            elem.style["overflow" + value] = options.overflow[index];
                        });
                    }

                    // Hide the element if the "hide" operation was done
                    if (options.hide) {
                        jQuery(elem).hide();
                    }

                    // Reset the properties, if the item has been hidden or shown
                    if (options.hide || options.show) {
                        for (var p in options.animatedProperties) {
                            jQuery.style(elem, p, options.orig[p]);
                        }
                    }

                    // Execute the complete function
                    options.complete.call(elem);
                }

                return false;

            } else {
                // classical easing cannot be used with an Infinity duration
                if (options.duration == Infinity) {
                    this.now = t;
                } else {
                    n = t - this.startTime;
                    this.state = n / options.duration;

                    // Perform the easing function, defaults to swing
                    this.pos = jQuery.easing[options.animatedProperties[this.prop]](this.state, n, 0, 1, options.duration);
                    this.now = this.start + ((this.end - this.start) * this.pos);
                }
                // Perform the next step of the animation
                this.update();
            }

            return true;
        }
    };

    jQuery.extend(jQuery.fx, {
        tick: function () {
            for (var timers = jQuery.timers, i = 0; i < timers.length; ++i) {
                if (!timers[i]()) {
                    timers.splice(i--, 1);
                }
            }

            if (!timers.length) {
                jQuery.fx.stop();
            }
        },

        interval: 13,

        stop: function () {
            clearInterval(timerId);
            timerId = null;
        },

        speeds: {
            slow: 600,
            fast: 200,
            // Default speed
            _default: 400
        },

        step: {
            opacity: function (fx) {
                jQuery.style(fx.elem, "opacity", fx.now);
            },

            _default: function (fx) {
                if (fx.elem.style && fx.elem.style[fx.prop] != null) {
                    fx.elem.style[fx.prop] = (fx.prop === "width" || fx.prop === "height" ? Math.max(0, fx.now) : fx.now) + fx.unit;
                } else {
                    fx.elem[fx.prop] = fx.now;
                }
            }
        }
    });

    if (jQuery.expr && jQuery.expr.filters) {
        jQuery.expr.filters.animated = function (elem) {
            return jQuery.grep(jQuery.timers, function (fn) {
                return elem === fn.elem;
            }).length;
        };
    }

    // Try to restore the default display value of an element
    function defaultDisplay(nodeName) {

        if (!elemdisplay[nodeName]) {

            var body = document.body,
			elem = jQuery("<" + nodeName + ">").appendTo(body),
			display = elem.css("display");

            elem.remove();

            // If the simple way fails,
            // get element's real default display by attaching it to a temp iframe
            if (display === "none" || display === "") {
                // No iframe to use yet, so create it
                if (!iframe) {
                    iframe = document.createElement("iframe");
                    iframe.frameBorder = iframe.width = iframe.height = 0;
                }

                body.appendChild(iframe);

                // Create a cacheable copy of the iframe document on first call.
                // IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
                // document to it; WebKit & Firefox won't allow reusing the iframe document.
                if (!iframeDoc || !iframe.createElement) {
                    iframeDoc = (iframe.contentWindow || iframe.contentDocument).document;
                    iframeDoc.write((document.compatMode === "CSS1Compat" ? "<!doctype html>" : "") + "<html><body>");
                    iframeDoc.close();
                }

                elem = iframeDoc.createElement(nodeName);

                iframeDoc.body.appendChild(elem);

                display = jQuery.css(elem, "display");

                body.removeChild(iframe);
            }

            // Store the correct default display
            elemdisplay[nodeName] = display;
        }

        return elemdisplay[nodeName];
    }




    var rtable = /^t(?:able|d|h)$/i,
	rroot = /^(?:body|html)$/i;

    if ("getBoundingClientRect" in document.documentElement) {
        jQuery.fn.offset = function (options) {
            var elem = this[0], box;

            if (options) {
                return this.each(function (i) {
                    jQuery.offset.setOffset(this, options, i);
                });
            }

            if (!elem || !elem.ownerDocument) {
                return null;
            }

            if (elem === elem.ownerDocument.body) {
                return jQuery.offset.bodyOffset(elem);
            }

            try {
                // SIESTA PATCH BEGIN, fix broken getBoundingClientRect for IE11/Edge
                box = Siesta.Util.Role.Dom.meta.methods.getBoundingClientRect.value(elem)
                // box = elem.getBoundingClientRect();
                // SIESTA PATCH END
            } catch (e) { }

            var doc = elem.ownerDocument,
			docElem = doc.documentElement;

            // Make sure we're not dealing with a disconnected DOM node
            if (!box || !jQuery.contains(docElem, elem)) {
                return box ? { top: box.top, left: box.left} : { top: 0, left: 0 };
            }

            var body = doc.body,
			win = getWindow(doc),
			clientTop = docElem.clientTop || body.clientTop || 0,
			clientLeft = docElem.clientLeft || body.clientLeft || 0,
			scrollTop = win.pageYOffset || jQuery.support.boxModel && docElem.scrollTop || body.scrollTop,
			scrollLeft = win.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft,
// SIESTA PATCH BEGIN            
			top = Math.floor(box.top) + scrollTop - clientTop,
			left = Math.floor(box.left) + scrollLeft - clientLeft;
// SIESTA PATCH END

            return { top: top, left: left };
        };

    } else {
        jQuery.fn.offset = function (options) {
            var elem = this[0];

            if (options) {
                return this.each(function (i) {
                    jQuery.offset.setOffset(this, options, i);
                });
            }

            if (!elem || !elem.ownerDocument) {
                return null;
            }

            if (elem === elem.ownerDocument.body) {
                return jQuery.offset.bodyOffset(elem);
            }

            jQuery.offset.initialize();

            var computedStyle,
			offsetParent = elem.offsetParent,
			prevOffsetParent = elem,
			doc = elem.ownerDocument,
			docElem = doc.documentElement,
			body = doc.body,
			defaultView = doc.defaultView,
			prevComputedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle,
			top = elem.offsetTop,
			left = elem.offsetLeft;

            while ((elem = elem.parentNode) && elem !== body && elem !== docElem) {
                if (jQuery.offset.supportsFixedPosition && prevComputedStyle.position === "fixed") {
                    break;
                }

                computedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;
                top -= elem.scrollTop;
                left -= elem.scrollLeft;

                if (elem === offsetParent) {
                    top += elem.offsetTop;
                    left += elem.offsetLeft;

                    if (jQuery.offset.doesNotAddBorder && !(jQuery.offset.doesAddBorderForTableAndCells && rtable.test(elem.nodeName))) {
                        top += parseFloat(computedStyle.borderTopWidth) || 0;
                        left += parseFloat(computedStyle.borderLeftWidth) || 0;
                    }

                    prevOffsetParent = offsetParent;
                    offsetParent = elem.offsetParent;
                }

                if (jQuery.offset.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== "visible") {
                    top += parseFloat(computedStyle.borderTopWidth) || 0;
                    left += parseFloat(computedStyle.borderLeftWidth) || 0;
                }

                prevComputedStyle = computedStyle;
            }

            if (prevComputedStyle.position === "relative" || prevComputedStyle.position === "static") {
                top += body.offsetTop;
                left += body.offsetLeft;
            }

            if (jQuery.offset.supportsFixedPosition && prevComputedStyle.position === "fixed") {
                top += Math.max(docElem.scrollTop, body.scrollTop);
                left += Math.max(docElem.scrollLeft, body.scrollLeft);
            }

            return { top: top, left: left };
        };
    }

    jQuery.offset = {
        initialize: function () {
            var body = document.body, container = document.createElement("div"), innerDiv, checkDiv, table, td, bodyMarginTop = parseFloat(jQuery.css(body, "marginTop")) || 0,
			html = "<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div><table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>";

            jQuery.extend(container.style, { position: "absolute", top: 0, left: 0, margin: 0, border: 0, width: "1px", height: "1px", visibility: "hidden" });

            container.innerHTML = html;
            body.insertBefore(container, body.firstChild);
            innerDiv = container.firstChild;
            checkDiv = innerDiv.firstChild;
            td = innerDiv.nextSibling.firstChild.firstChild;

            this.doesNotAddBorder = (checkDiv.offsetTop !== 5);
            this.doesAddBorderForTableAndCells = (td.offsetTop === 5);

            checkDiv.style.position = "fixed";
            checkDiv.style.top = "20px";

            // safari subtracts parent border width here which is 5px
            this.supportsFixedPosition = (checkDiv.offsetTop === 20 || checkDiv.offsetTop === 15);
            checkDiv.style.position = checkDiv.style.top = "";

            innerDiv.style.overflow = "hidden";
            innerDiv.style.position = "relative";

            this.subtractsBorderForOverflowNotVisible = (checkDiv.offsetTop === -5);

            this.doesNotIncludeMarginInBodyOffset = (body.offsetTop !== bodyMarginTop);

            body.removeChild(container);
            jQuery.offset.initialize = jQuery.noop;
        },

        bodyOffset: function (body) {
            var top = body.offsetTop,
			left = body.offsetLeft;

            jQuery.offset.initialize();

            if (jQuery.offset.doesNotIncludeMarginInBodyOffset) {
                top += parseFloat(jQuery.css(body, "marginTop")) || 0;
                left += parseFloat(jQuery.css(body, "marginLeft")) || 0;
            }

            return { top: top, left: left };
        },

        setOffset: function (elem, options, i) {
            var position = jQuery.css(elem, "position");

            // set position first, in-case top/left are set even on static elem
            if (position === "static") {
                elem.style.position = "relative";
            }

            var curElem = jQuery(elem),
			curOffset = curElem.offset(),
			curCSSTop = jQuery.css(elem, "top"),
			curCSSLeft = jQuery.css(elem, "left"),
			calculatePosition = (position === "absolute" || position === "fixed") && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
			props = {}, curPosition = {}, curTop, curLeft;

            // need to be able to calculate position if either top or left is auto and position is either absolute or fixed
            if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
            }

            if (jQuery.isFunction(options)) {
                options = options.call(elem, i, curOffset);
            }

            if (options.top != null) {
                props.top = (options.top - curOffset.top) + curTop;
            }
            if (options.left != null) {
                props.left = (options.left - curOffset.left) + curLeft;
            }

            if ("using" in options) {
                options.using.call(elem, props);
            } else {
                curElem.css(props);
            }
        }
    };


    jQuery.fn.extend({
        position: function () {
            if (!this[0]) {
                return null;
            }

            var elem = this[0],

            // Get *real* offsetParent
		offsetParent = this.offsetParent(),

            // Get correct offsets
		offset = this.offset(),
		parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0} : offsetParent.offset();

            // Subtract element margins
            // note: when an element has margin: auto the offsetLeft and marginLeft
            // are the same in Safari causing offset.left to incorrectly be 0
            offset.top -= parseFloat(jQuery.css(elem, "marginTop")) || 0;
            offset.left -= parseFloat(jQuery.css(elem, "marginLeft")) || 0;

            // Add offsetParent borders
            parentOffset.top += parseFloat(jQuery.css(offsetParent[0], "borderTopWidth")) || 0;
            parentOffset.left += parseFloat(jQuery.css(offsetParent[0], "borderLeftWidth")) || 0;

            // Subtract the two offsets
            return {
                top: offset.top - parentOffset.top,
                left: offset.left - parentOffset.left
            };
        },

        offsetParent: function () {
            return this.map(function () {
                var offsetParent = this.offsetParent || document.body;
                while (offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static")) {
                    offsetParent = offsetParent.offsetParent;
                }
                return offsetParent;
            });
        }
    });


    // Create scrollLeft and scrollTop methods
    jQuery.each(["Left", "Top"], function (i, name) {
        var method = "scroll" + name;

        jQuery.fn[method] = function (val) {
            var elem, win;

            if (val === undefined) {
                elem = this[0];

                if (!elem) {
                    return null;
                }

                win = getWindow(elem);

                // Return the scroll offset
                /* original jQuery code - contradicts with "offset" method, where the document scroll top position is calculated differently
                return win ? ("pageXOffset" in win) ? win[i ? "pageYOffset" : "pageXOffset"] :
				jQuery.support.boxModel && win.document.documentElement[method] ||
					win.document.body[method] :
				elem[method];
                */
                
                return win 
                    ? 
                        win[ i ? "pageYOffset" : "pageXOffset" ] || jQuery.support.boxModel && win.document.documentElement[method] || win.document.body[method] 
                    :
                        elem[method];
            }

            // Set the scroll offset
            return this.each(function () {
                win = getWindow(this);

                if (win) {
                    win.scrollTo(
					!i ? val : jQuery(win).scrollLeft(),
					 i ? val : jQuery(win).scrollTop()
				);

                } else {
                    this[method] = val;
                }
            });
        };
    });

    function getWindow(elem) {
        return jQuery.isWindow(elem) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
    }




    // Create width, height, innerHeight, innerWidth, outerHeight and outerWidth methods
    jQuery.each(["Height", "Width"], function (i, name) {

        var type = name.toLowerCase();

        // innerHeight and innerWidth
        jQuery.fn["inner" + name] = function () {
            var elem = this[0];
            return elem && elem.style ?
			parseFloat(jQuery.css(elem, type, "padding")) :
			null;
        };

        // outerHeight and outerWidth
        jQuery.fn["outer" + name] = function (margin) {
            var elem = this[0];
            return elem && elem.style ?
			parseFloat(jQuery.css(elem, type, margin ? "margin" : "border")) :
			null;
        };

        jQuery.fn[type] = function (size) {
            // Get window width or height
            var elem = this[0];
            if (!elem) {
                return size == null ? null : this;
            }

            if (jQuery.isFunction(size)) {
                return this.each(function (i) {
                    var self = jQuery(this);
                    self[type](size.call(this, i, self[type]()));
                });
            }

            if (jQuery.isWindow(elem)) {
                // Everyone else use document.documentElement or document.body depending on Quirks vs Standards mode
                // 3rd condition allows Nokia support, as it supports the docElem prop but not CSS1Compat
                var docElemProp = elem.document.documentElement["client" + name];
                return elem.document.compatMode === "CSS1Compat" && docElemProp ||
				elem.document.body["client" + name] || docElemProp;

                // Get document width or height
            } else if (elem.nodeType === 9) {
                // Either scroll[Width/Height] or offset[Width/Height], whichever is greater
                return Math.max(
				elem.documentElement["client" + name],
				elem.body["scroll" + name], elem.documentElement["scroll" + name],
				elem.body["offset" + name], elem.documentElement["offset" + name]
			);

                // Get or set width or height on the element
            } else if (size === undefined) {
                var orig = jQuery.css(elem, type),
				ret = parseFloat(orig);

                return jQuery.isNaN(ret) ? orig : ret;

                // Set the width or height on the element (default to pixels if value is unitless)
            } else {
                return this.css(type, typeof size === "string" ? size : size + "px");
            }
        };

    });


    // Expose jQuery to the global object
    window.jQuery = window.$ = jQuery;
    
    // @PATCH
    window.jQuery.siesta = true

    // @PATCH
    window.$.rebindWindowContext = function (win) {
        window = win;
        document = win.document;
        rootjQuery = $(document);
        return function (selector, context) {
            // The jQuery object is actually just the init constructor 'enhanced'
            return new jQuery.fn.init(selector, context, rootjQuery);
        }
    };

})(window);

jQuery.fn.center = function () {
    this.css("position","absolute");
    
    this.css("top", Math.max(0, (($(window).height() - this.outerHeight()) / 2) + $(window).scrollTop()) + "px");
    this.css("left", Math.max(0, (($(window).width() - this.outerWidth()) / 2) +  $(window).scrollLeft()) + "px");
    
    return this;
}


;
/*!
 * Sizzle CSS Selector Engine v2.3.4-pre
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-08-15
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
// SIESTA PATCH BEGIN
                        if (!(bowser.msie || bowser.msedge) || !/:nth-of-type\(\d/i.test(newSelector)) {
// SIESTA PATCH END
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
// SIESTA PATCH BEGIN
                        }
// SIESTA PATCH END
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

// SIESTA PATCH BEGIN
Sizzle.unescape = function( sel ) {
    return (sel + "").replace( runescape, funescape );
};
// SIESTA PATCH END

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

// EXPOSE
var _sizzle = window.Sizzle;

Sizzle.noConflict = function() {
	if ( window.Sizzle === Sizzle ) {
		window.Sizzle = _sizzle;
	}

	return Sizzle;
};

if ( typeof define === "function" && define.amd ) {
	define(function() { return Sizzle; });
// Sizzle requires that there be a global window in Common-JS like environments
} else if ( typeof module !== "undefined" && module.exports ) {
	module.exports = Sizzle;
} else {
	window.Sizzle = Sizzle;
}
// EXPOSE

// SIESTA PATCH BEGIN
// We rely on Sizzle symbol always being present, Sizzle doesn't always expose it
window.Sizzle = Sizzle;

// mark this copy of Sizzle as being used by Siesta
Sizzle.siesta = true

// Add "textEquals" pseudo - exact text matching selector
Sizzle.selectors.pseudos.textEquals = function(el, i, m) {
    var searchText = Sizzle.unescape(m[ 3 ])

    return Sizzle.getText([ el ]).replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '') === searchText
};

// patch jQuery (only if it exists and its a Siesta's jQuery) to use this copy of Sizzle
// instead of the built-ine one
if (window.jQuery && window.jQuery.siesta) {
    var oldExpr         = jQuery.expr
    
    jQuery.find         = Sizzle;
    jQuery.expr         = Sizzle.selectors;
    jQuery.expr[":"]    = jQuery.expr.filters;
    jQuery.unique       = Sizzle.uniqueSort;
    jQuery.text         = Sizzle.getText;
    jQuery.isXMLDoc     = Sizzle.isXML;
    jQuery.contains     = Sizzle.contains;
    
    jQuery.expr.filters.hidden      = oldExpr.filters.hidden
    jQuery.expr.filters.visible     = oldExpr.filters.visible
}
// SIESTA PATCH END

})( window );;
Siesta.Sizzle = Sizzle; Sizzle.noConflict();;
/*!
 * deep-diff.
 * Licensed under the MIT License.
 *
 * PATCHES:
 *  1. Patched to handle Date objects from different frames (replaced all instanceof checks)
 *  2. Patched to handle comparing { foo : undefined }, {}. https://github.com/flitbit/diff/issues/70
 */
// jshint ignore: start
if (Object.create) {
    ;(function (root, factory) {
        'use strict';
        if (typeof define === 'function' && define.amd) {
            // AMD. Register as an anonymous module.
            define([], factory);
        } else if (typeof exports === 'object') {
            // Node. Does not work with strict CommonJS, but
            // only CommonJS-like environments that support module.exports,
            // like Node.
            module.exports = factory();
        } else {
            // Browser globals (root is window)
            root.DeepDiff = factory();
        }
    }(this, function (undefined) {
        'use strict';

        var $scope, conflict, conflictResolution = [];
        if (typeof global === 'object' && global) {
            $scope = global;
        } else if (typeof window !== 'undefined') {
            $scope = window;
        } else {
            $scope = {};
        }
        conflict = $scope.DeepDiff;
        if (conflict) {
            conflictResolution.push(
                function () {
                    if ('undefined' !== typeof conflict && $scope.DeepDiff === accumulateDiff) {
                        $scope.DeepDiff = conflict;
                        conflict        = undefined;
                    }
                });
        }

        // nodejs compatible on server side and in the browser.
        function inherits(ctor, superCtor) {
            ctor.super_    = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
                constructor : {
                    value        : ctor,
                    enumerable   : false,
                    writable     : true,
                    configurable : true
                }
            });
        }

        function Diff(kind, path) {
            Object.defineProperty(this, 'kind', {
                value      : kind,
                enumerable : true
            });
            if (path && path.length) {
                Object.defineProperty(this, 'path', {
                    value      : path,
                    enumerable : true
                });
            }
        }

        function DiffEdit(path, origin, value) {
            DiffEdit.super_.call(this, 'E', path);
            Object.defineProperty(this, 'lhs', {
                value      : origin,
                enumerable : true
            });
            Object.defineProperty(this, 'rhs', {
                value      : value,
                enumerable : true
            });
        }

        inherits(DiffEdit, Diff);

        function DiffNew(path, value) {
            DiffNew.super_.call(this, 'N', path);
            Object.defineProperty(this, 'rhs', {
                value      : value,
                enumerable : true
            });
        }

        inherits(DiffNew, Diff);

        function DiffDeleted(path, value) {
            DiffDeleted.super_.call(this, 'D', path);
            Object.defineProperty(this, 'lhs', {
                value      : value,
                enumerable : true
            });
        }

        inherits(DiffDeleted, Diff);

        function DiffArray(path, index, item) {
            DiffArray.super_.call(this, 'A', path);
            Object.defineProperty(this, 'index', {
                value      : index,
                enumerable : true
            });
            Object.defineProperty(this, 'item', {
                value      : item,
                enumerable : true
            });
        }

        inherits(DiffArray, Diff);

        function arrayRemove(arr, from, to) {
            var rest   = arr.slice((to || from) + 1 || arr.length);
            arr.length = from < 0 ? arr.length + from : from;
            arr.push.apply(arr, rest);
            return arr;
        }

        function realTypeOf(subject) {
            var type = typeof subject;
            if (type !== 'object') {
                return type;
            }

            if (subject === Math) {
                return 'math';
            } else if (subject === null) {
                return 'null';
            } else if (Array.isArray(subject)) {
                return 'array';
            } else if (Object.prototype.toString.call(subject) === '[object Date]') {
                return 'date';
            } else if (/^\/.*\//.test(subject.toString())) {
                return 'regexp';
            }
            return 'object';
        }

        function deepDiff(lhs, rhs, changes, prefilter, path, key, stack) {
            path            = path || [];
            var currentPath = path.slice(0);
            if (typeof key !== 'undefined') {
                if (prefilter && prefilter(currentPath, key, { lhs : lhs, rhs : rhs })) {
                    return;
                }
                currentPath.push(key);
            }

            // Use string comparison for regexes
            if (realTypeOf(lhs) === 'regexp' && realTypeOf(rhs) === 'regexp') {
                lhs = lhs.toString();
                rhs = rhs.toString();
            }

            var ltype = typeof lhs;
            var rtype = typeof rhs;
            if (ltype === 'undefined') {
                if (rtype !== 'undefined') {
                    changes(new DiffNew(currentPath, rhs));
                }
            } else if (rtype === 'undefined') {
                changes(new DiffDeleted(currentPath, lhs));
            } else if (realTypeOf(lhs) !== realTypeOf(rhs)) {
                changes(new DiffEdit(currentPath, lhs, rhs));
                // @PATCH DATE COMPARISON NEEDS TO HANDLE DATE OBJECTS FROM DIFFERENT CONTEXTS (FRAMES ETC)
            } else if (Object.prototype.toString.call(lhs) === '[object Date]' && Object.prototype.toString.call(rhs) === '[object Date]' && ((lhs - rhs) !== 0)) {
                // EOF @PATCH
                changes(new DiffEdit(currentPath, lhs, rhs));
            } else if (ltype === 'object' && lhs !== null && rhs !== null /* PATCH */ && lhs !== rhs /* EOF PATCH */ ) {
                stack = stack || [];
                if (stack.indexOf(lhs) < 0) {
                    stack.push(lhs);
                    
                    if (Array.isArray(lhs)) {
                        var i, len = lhs.length;
                        for (i = 0; i < lhs.length; i++) {
                            if (i >= rhs.length) {
                                changes(new DiffArray(currentPath, i, new DiffDeleted(undefined, lhs[i])));
                            } else {
                                deepDiff(lhs[i], rhs[i], changes, prefilter, currentPath, i, stack);
                            }
                        }
                        while (i < rhs.length) {
                            changes(new DiffArray(currentPath, i, new DiffNew(undefined, rhs[i++])));
                        }
                    } else {
                        var akeys = Object.keys(lhs);
                        var pkeys = Object.keys(rhs);

                        akeys.forEach(function (k, i) {
                            var other = pkeys.indexOf(k);

                            if (other >= 0) {
                                deepDiff(lhs[k], rhs[k], changes, prefilter, currentPath, k, stack);
                                pkeys = arrayRemove(pkeys, other);
                            } else {
                                // @PATCH
                                // KEY NOT FOUND IN OTHER OBJECT; THIS SHOULD BE CONSIDERED A DIFF ITEM
                                // deepDiff(lhs[k], undefined, changes, prefilter, currentPath, k, stack);

                                changes(new DiffDeleted(currentPath, k));

                                // EOF PATCH
                            }
                        });

                        pkeys.forEach(function (k) {
                            // @PATCH
                            // KEY NOT FOUND IN ORIGINAL OBJECT; THIS SHOULD BE CONSIDERED A DIFF ITEM
                            // deepDiff(undefined, rhs[k], changes, prefilter, currentPath, k, stack);
                            
                            changes(new DiffNew(currentPath, rhs[ k ]))

                            // EOF PATCH
                        });

                    }
                    stack.length = stack.length - 1;
                }
            } else if (lhs !== rhs) {
                if (!(ltype === 'number' && isNaN(lhs) && isNaN(rhs))) {
                    changes(new DiffEdit(currentPath, lhs, rhs));
                }
            }
        }

        function accumulateDiff(lhs, rhs, prefilter, accum) {
            accum = accum || [];
            deepDiff(lhs, rhs,
                function (diff) {
                    if (diff) {
                        accum.push(diff);
                    }
                },
                prefilter);
            return (accum.length) ? accum : undefined;
        }

        function applyArrayChange(arr, index, change) {
            if (change.path && change.path.length) {
                var it   = arr[index],
                    i, u = change.path.length - 1;
                for (i = 0; i < u; i++) {
                    it = it[change.path[i]];
                }
                switch (change.kind) {
                    case 'A':
                        applyArrayChange(it[change.path[i]], change.index, change.item);
                        break;
                    case 'D':
                        delete it[change.path[i]];
                        break;
                    case 'E':
                    case 'N':
                        it[change.path[i]] = change.rhs;
                        break;
                }
            } else {
                switch (change.kind) {
                    case 'A':
                        applyArrayChange(arr[index], change.index, change.item);
                        break;
                    case 'D':
                        arr = arrayRemove(arr, index);
                        break;
                    case 'E':
                    case 'N':
                        arr[index] = change.rhs;
                        break;
                }
            }
            return arr;
        }

        function applyChange(target, source, change) {
            if (target && source && change && change.kind) {
                var it   = target,
                    i    = -1,
                    last = change.path ? change.path.length - 1 : 0;
                while (++i < last) {
                    if (typeof it[change.path[i]] === 'undefined') {
                        it[change.path[i]] = (typeof change.path[i] === 'number') ? [] : {};
                    }
                    it = it[change.path[i]];
                }
                switch (change.kind) {
                    case 'A':
                        applyArrayChange(change.path ? it[change.path[i]] : it, change.index, change.item);
                        break;
                    case 'D':
                        delete it[change.path[i]];
                        break;
                    case 'E':
                    case 'N':
                        it[change.path[i]] = change.rhs;
                        break;
                }
            }
        }

        function revertArrayChange(arr, index, change) {
            if (change.path && change.path.length) {
                // the structure of the object at the index has changed...
                var it   = arr[index],
                    i, u = change.path.length - 1;
                for (i = 0; i < u; i++) {
                    it = it[change.path[i]];
                }
                switch (change.kind) {
                    case 'A':
                        revertArrayChange(it[change.path[i]], change.index, change.item);
                        break;
                    case 'D':
                        it[change.path[i]] = change.lhs;
                        break;
                    case 'E':
                        it[change.path[i]] = change.lhs;
                        break;
                    case 'N':
                        delete it[change.path[i]];
                        break;
                }
            } else {
                // the array item is different...
                switch (change.kind) {
                    case 'A':
                        revertArrayChange(arr[index], change.index, change.item);
                        break;
                    case 'D':
                        arr[index] = change.lhs;
                        break;
                    case 'E':
                        arr[index] = change.lhs;
                        break;
                    case 'N':
                        arr = arrayRemove(arr, index);
                        break;
                }
            }
            return arr;
        }

        function revertChange(target, source, change) {
            if (target && source && change && change.kind) {
                var it = target,
                    i, u;
                u      = change.path.length - 1;
                for (i = 0; i < u; i++) {
                    if (typeof it[change.path[i]] === 'undefined') {
                        it[change.path[i]] = {};
                    }
                    it = it[change.path[i]];
                }
                switch (change.kind) {
                    case 'A':
                        // Array was modified...
                        // it will be an array...
                        revertArrayChange(it[change.path[i]], change.index, change.item);
                        break;
                    case 'D':
                        // Item was deleted...
                        it[change.path[i]] = change.lhs;
                        break;
                    case 'E':
                        // Item was edited...
                        it[change.path[i]] = change.lhs;
                        break;
                    case 'N':
                        // Item is new...
                        delete it[change.path[i]];
                        break;
                }
            }
        }

        function applyDiff(target, source, filter) {
            if (target && source) {
                var onChange = function (change) {
                    if (!filter || filter(target, source, change)) {
                        applyChange(target, source, change);
                    }
                };
                deepDiff(target, source, onChange);
            }
        }

        Object.defineProperties(accumulateDiff, {

            diff           : {
                value      : accumulateDiff,
                enumerable : true
            },
            observableDiff : {
                value      : deepDiff,
                enumerable : true
            },
            applyDiff      : {
                value      : applyDiff,
                enumerable : true
            },
            applyChange    : {
                value      : applyChange,
                enumerable : true
            },
            revertChange   : {
                value      : revertChange,
                enumerable : true
            },
            isConflict     : {
                value      : function () {
                    return 'undefined' !== typeof conflict;
                },
                enumerable : true
            },
            noConflict     : {
                value      : function () {
                    if (conflictResolution) {
                        conflictResolution.forEach(function (it) {
                            it();
                        });
                        conflictResolution = null;
                    }
                    return accumulateDiff;
                },
                enumerable : true
            }
        });

        return accumulateDiff;
    }));
}
;
/*
 * jQuery scrollintoview() plugin and :scrollable selector filter
 *
 * Version 1.8 (14 Jul 2011)
 * Requires jQuery 1.4 or newer
 *
 * Copyright (c) 2011 Robert Koritnik
 * Licensed under the terms of the MIT license
 * http://www.opensource.org/licenses/mit-license.php
 */
(function(f){var c={vertical:{x:false,y:true},horizontal:{x:true,y:false},both:{x:true,y:true},x:{x:true,y:false},y:{x:false,y:true}};var b={duration:"fast",direction:"both"};var e=/^(?:html)$/i;var g=function(k,j){j=j||(document.defaultView&&document.defaultView.getComputedStyle?document.defaultView.getComputedStyle(k,null):k.currentStyle);var i=document.defaultView&&document.defaultView.getComputedStyle?true:false;var h={top:(parseFloat(i?j.borderTopWidth:f.css(k,"borderTopWidth"))||0),left:(parseFloat(i?j.borderLeftWidth:f.css(k,"borderLeftWidth"))||0),bottom:(parseFloat(i?j.borderBottomWidth:f.css(k,"borderBottomWidth"))||0),right:(parseFloat(i?j.borderRightWidth:f.css(k,"borderRightWidth"))||0)};return{top:h.top,left:h.left,bottom:h.bottom,right:h.right,vertical:h.top+h.bottom,horizontal:h.left+h.right}};var d=function(h){var j=f(window);var i=e.test(h[0].nodeName);return{border:i?{top:0,left:0,bottom:0,right:0}:g(h[0]),scroll:{top:(i?j:h).scrollTop(),left:(i?j:h).scrollLeft()},scrollbar:{right:i?0:h.innerWidth()-h[0].clientWidth,bottom:i?0:h.innerHeight()-h[0].clientHeight},rect:(function(){var k=h[0].getBoundingClientRect();return{top:i?0:k.top,left:i?0:k.left,bottom:i?h[0].clientHeight:k.bottom,right:i?h[0].clientWidth:k.right}})()}};f.fn.extend({scrollintoview:function(j){j=f.extend({},b,j);j.direction=c[typeof(j.direction)==="string"&&j.direction.toLowerCase()]||c.both;var n="";if(j.direction.x===true){n="horizontal"}if(j.direction.y===true){n=n?"both":"vertical"}var l=this.eq(0);var i=l.closest(":scrollable("+n+")");if(i.length>0){i=i.eq(0);var m={e:d(l),s:d(i)};var h={top:m.e.rect.top-(m.s.rect.top+m.s.border.top),bottom:m.s.rect.bottom-m.s.border.bottom-m.s.scrollbar.bottom-m.e.rect.bottom,left:m.e.rect.left-(m.s.rect.left+m.s.border.left),right:m.s.rect.right-m.s.border.right-m.s.scrollbar.right-m.e.rect.right};var k={};if(j.direction.y===true){if(h.top<0){k.scrollTop=m.s.scroll.top+h.top}else{if(h.top>0&&h.bottom<0){k.scrollTop=m.s.scroll.top+Math.min(h.top,-h.bottom)}}}if(j.direction.x===true){if(h.left<0){k.scrollLeft=m.s.scroll.left+h.left}else{if(h.left>0&&h.right<0){k.scrollLeft=m.s.scroll.left+Math.min(h.left,-h.right)}}}if(!f.isEmptyObject(k)){if(e.test(i[0].nodeName)){i=f("html,body")}i.animate(k,j.duration).eq(0).queue(function(o){f.isFunction(j.complete)&&j.complete.call(i[0]);o()})}else{f.isFunction(j.complete)&&j.complete.call(i[0])}}return this}});var a={auto:true,scroll:true,visible:false,hidden:false};f.extend(f.expr[":"],{scrollable:function(k,i,n,h){var m=c[typeof(n[3])==="string"&&n[3].toLowerCase()]||c.both;var l=(document.defaultView&&document.defaultView.getComputedStyle?document.defaultView.getComputedStyle(k,null):k.currentStyle);var o={x:a[l.overflowX.toLowerCase()]||false,y:a[l.overflowY.toLowerCase()]||false,isRoot:e.test(k.nodeName)};if(!o.x&&!o.y&&!o.isRoot){return false}var j={height:{scroll:k.scrollHeight,client:k.clientHeight},width:{scroll:k.scrollWidth,client:k.clientWidth},scrollableX:function(){return(o.x||o.isRoot)&&this.width.scroll>this.width.client},scrollableY:function(){return(o.y||o.isRoot)&&this.height.scroll>this.height.client}};return m.y&&j.scrollableY()||m.x&&j.scrollableX()}})})(jQuery);;
if (typeof JooseX != "undefined" && !JooseX.SimpleRequest) {;
Class("JooseX.SimpleRequest", {

    have : {
    	req : null
	},

    
    methods: {
    	
        initialize: function () {
            if (window.XMLHttpRequest)
                this.req = new XMLHttpRequest()
            else
                this.req = new ActiveXObject("Microsoft.XMLHTTP")
        },
        
        
        getText: function (urlOrOptions, async, callback, scope) {
            var req = this.req
            
            var headers
            var url
            
            if (typeof urlOrOptions != 'string') {
                headers = urlOrOptions.headers
                url = urlOrOptions.url
                async = async || urlOrOptions.async
                callback = callback || urlOrOptions.callback
                scope = scope || urlOrOptions.scope
            } else url = urlOrOptions
            
            req.open('GET', url, async || false)
            
            if (headers) Joose.O.eachOwn(headers, function (value, name) {
                req.setRequestHeader(name, value)
            })
            
            try {
                req.onreadystatechange = function (event) {  
                    if (async && req.readyState == 4) {  
                        // status is set to 0 for failed cross-domain requests..
                        // but if the response text presents - we treat this as successfull request
                        // see https://www.assembla.com/spaces/bryntum/tickets/590
                        if (req.status == 200 || req.status == 0 && req.responseText.length > 0) 
                            callback.call(scope || this, true, req.responseText)
                        else 
                            callback.call(scope || this, false, "File not found: " + url)
                    }  
                };  
                req.send(null)
            } catch (e) {
                throw "File not found: " + url
            }
            
            if (!async)
                if (req.status == 200 || req.status == 0 && req.responseText.length > 0) 
                    return req.responseText; 
                else 
                    throw "File not found: " + url
            
            return null
        }
    }
})
;
};
Role('Siesta.Util.Role.CanCalculatePageScroll', {
    // also recognizes the "global" attribute

    methods : {

        getElForPageScroll : function (win) {
            win                 = win || this.global
            var doc             = win.document

            return doc.scrollingElement || (bowser.webkit || bowser.blink || bowser.msedge ? doc.body : doc.documentElement)
        },


        getPageScrollX : function (win) {
            win                 = win || this.global
            var doc             = win.document

            if (window.pageXOffset != null) return win.pageXOffset

            var scrollEl        = this.getElForPageScroll()

            return scrollEl ? scrollEl.scrollLeft : 0
        },


        getPageScrollY : function (win) {
            win                 = win || this.global
            var doc             = win.document

            if (window.pageYOffset != null) return win.pageYOffset

            var scrollEl        = this.getElForPageScroll()

            return scrollEl ? scrollEl.scrollTop : 0
        },


        viewportXtoPageX : function (x, win) {
            win                 = win || this.global
            var docEl           = win.document.documentElement

            // seems the "docEl.clientLeft" thing is copied from jQuery, not sure what kind of
            // edge case it is supposed to solve
            return x + this.getPageScrollX(win) - docEl.clientLeft
        },


        viewportYtoPageY : function (y, win) {
            win                 = win || this.global
            var docEl           = win.document.documentElement

            // seems the "docEl.clientLeft" thing is copied from jQuery, not sure what kind of
            // edge case it is supposed to solve
            return y + this.getPageScrollY(win) - docEl.clientTop
        },


        pageXtoViewportX : function (x, win) {
            win                 = win || this.global
            var docEl           = win.document.documentElement

            // seems the "docEl.clientLeft" thing is copied from jQuery, not sure what kind of
            // edge case it is supposed to solve
            return x - this.getPageScrollX(win) + docEl.clientLeft
        },


        pageYtoViewportY : function (y, win) {
            win                 = win || this.global
            var docEl           = win.document.documentElement

            // seems the "docEl.clientLeft" thing is copied from jQuery, not sure what kind of
            // edge case it is supposed to solve
            return y - this.getPageScrollY(win) + docEl.clientTop
        },


        // this method is only actual, when Siesta UI is embedded inside the iframe of the parent window
        // in this case we don't want the scrolling position of the parent window to change in reaction
        // to the Siesta tests launches / progress
        maintainScrollPositionDuring : function (func, scope) {
            var parent                  = window.parent
            var isEmbedded              = Boolean(parent)

            var scrollLeftBefore        = isEmbedded && this.getPageScrollX(parent)
            var scrollTopBefore         = isEmbedded && this.getPageScrollY(parent)

            func.call(scope || this)

            // prevent scroll position change in the parent window, if Siesta UI is embedded
            if (isEmbedded) {
                var scrollEl            = this.getElForPageScroll(parent)

                if (scrollLeftBefore !== this.getPageScrollX(parent)) scrollEl.scrollLeft = scrollLeftBefore
                if (scrollTopBefore !== this.getPageScrollY(parent)) scrollEl.scrollTop = scrollTopBefore
            }
        }
    }
})
;
Role('Siesta.Util.Role.CanInstallCQRootPseudo', {

    methods : {

        // add :root pseudo CQ selector to be able to identify 'root' level components that don't have
        // parent containers. value is 1-based
        installRootPseudoCQ : function (Ext) {
            if (!Ext) return

            var CQ      = Ext.ComponentQuery

            if (!CQ) return

            var pseudos = CQ.pseudos

            if (!pseudos.root || !pseudos.root.__IS_ROOT_PSEUDO_OVERRIDE__) {

                var rootPseudo = function (items, value) {
                    var i = 0, l = items.length, c, result = [];
                    var findAllRoots = value === undefined

                    if (!findAllRoots) {
                        value = Number(value) - 1;
                    }

                    for (; i < l; i++) {
                        c = items[i].up();
                        var hasParentContainer = c && c.contains && c.contains(items[i]);

                        if (!hasParentContainer) {
                            result.push(items[i]);
                        }
                    }

                    if (!findAllRoots) {
                        result = result[value] ? [result[value]] : [];
                    }

                    return result;
                }

                rootPseudo.__IS_ROOT_PSEUDO_OVERRIDE__ = true

                pseudos.root = rootPseudo
            }

            if (!pseudos[ "ariadne-nth-child" ]) {

                pseudos[ "ariadne-nth-child" ] = function (items, selector) {
                    var result      = []

                    var pos         = Number(selector) - 1
                    var len         = items.length

                    for (var i = 0; i < len; i++) {
                        var cmp         = items[ i ]
                        var parentCt    = cmp.getRefOwner && cmp.getRefOwner() || cmp.ownerCt

                        var parentCtItems       = parentCt && parentCt.items

                        // parentCt could be an Ext ActionColumn which has 'items' but isn't a true container
                        if (parentCtItems && parentCtItems.getCount) {
                            var innerItemsLen   = parentCtItems.getCount()

                            if (pos < innerItemsLen) {
                                if (parentCtItems.getAt(pos) === cmp)
                                    result.push(cmp)
                            } else {
                                var refItems    = parentCt.getRefItems()

                                if (refItems[ pos ] === cmp) result.push(cmp)
                            }
                        }
                    }

                    return result;
                }
            }


            var version     = Ext.getVersion && Ext.getVersion('ext')

            if (version && version.major == 4 && !CQ.__CQ4_PATCHED__) {
                // install workarounds for ExtJS 4 which does not pay any attention to attribute values
                // escaping/unescaping
                Ext.dom.Query.operators[ '=' ] = function (a, b) {
                    return a == Siesta.Sizzle.unescape(b)
                }

                var prevQuery   = CQ.query

                // also ExtJS4 CQ just "split" the query by "," even that comma can be part of string expression
                CQ.query        = function (query, root) {
                    if (/\\,/.test(query))
                        return prevQuery.call(this, { split : function () { return [ query ] } }, root)
                    else
                        return prevQuery.call(this, query, root)
                }

                CQ.__CQ4_PATCHED__ = true
            }
        }
    }
});
;
/**
@class Siesta.Test.Browser.Role.CanGetElementFromPoint

*/
Role('Siesta.Test.Browser.Role.CanGetElementFromPoint', {

    requires    : [
        '$'
    ],

    does        : [
        Siesta.Util.Role.CanCalculatePageScroll
    ],

    has : {
    },

    methods : {

        /**
         * This method will return the top-most DOM element at the specified coordinates from the test page. If
         * the resulting element is an iframe and `shallow` argument is not passed as `true`
         * it'll query the iframe for its element from the local point inside it.
         *
         * @param {Number} x The X coordinate, relative to the viewport area (currently visible part of the page)
         * @param {Number} y The Y coordinate, relative to the viewport area (currently visible part of the page)
         * @param {Boolean} [shallow] Pass `true` to _not_ check the nested iframe if element at original coordinates is an iframe.
         *
         * @return {HTMLElement} The top-most element at the specified position on the test page
         */
        elementFromPoint : function (viewportX, viewportY, shallow, fallbackEl, fullInfo) {
            var document    = this.global.document;
            var el          = document.elementFromPoint(viewportX, viewportY)

            // trying 2nd time if 1st attempt failed and returned null
            // this weird thing seems to be required sometimes for IE8 and may be for IE10
            if (!el) el     = document.elementFromPoint(viewportX, viewportY)

            // final fallback to the provided element or to the <body> element
            el              = el || fallbackEl || document.body;

            var localX      = viewportX
            var localY      = viewportY

            // If we found IFRAME and its not a `shallow` request, try to dig deeper
            if (el && el.nodeName.toUpperCase() == 'IFRAME' && !shallow) {
                // if found iframe is loaded from different domain
                // just accessing its "el.contentWindow.document" property will throw exception
                try {
                    var iframeDoc       = el.contentWindow.document;
                    var offsetsToTop    = this.$(el).offset();

                    localX              = viewportX - this.pageXtoViewportX(offsetsToTop.left)
                    localY              = viewportY - this.pageYtoViewportY(offsetsToTop.top)

                    var resolvedEl      = iframeDoc.elementFromPoint(localX, localY)

                    // again weird 2nd attempt for IE
                    if (!resolvedEl) resolvedEl = iframeDoc.elementFromPoint(localX, localY)

                    resolvedEl          = resolvedEl || iframeDoc.body;

                    // Chrome reports 'HTML' in nested document.elementFromPoint calls which makes no sense
                    if (resolvedEl.nodeName.toUpperCase() === 'HTML') resolvedEl = iframeDoc.body;

                    el                  = resolvedEl;
                } catch (e) {
                    // digging deeper failed, restore the local coordinates
                    localX              = viewportX
                    localY              = viewportY
                }
            }

            return fullInfo ? {
                el          : el,
                // viewport coords in the inner frame
                localXY     : [ localX, localY ],
                // viewport coords in the top frame (seems not needed, as just the input values are reused)
                globalXY    : [ viewportX, viewportY ]
            } : el
        }
    }
});
;
// requires "global" attribute
Role('Siesta.Test.Browser.Role.CanWorkWithKeyboard', {

    has : {
    },

    methods : {

        isTextInput : function(node) {
            // somehow "node.nodeName" is empty sometimes in IE10
            var name    = node.nodeName && node.nodeName.toLowerCase();

            if (name === 'textarea') return true;

            if (name === 'input') {
                var type    = String(node.type).toLowerCase()

                return type === 'password' ||
                    type === 'number' ||
                    type === 'search' ||
                    type === 'text' ||
                    type === 'url' ||
                    type === 'tel' ||
                    type === 'month' ||
                    type === 'time' ||
                    type === 'date' ||
                    type === 'datetime' ||
                    type === 'week' ||
                    type === 'email';
            }

            return false
        },


        isEditableNode : function(node) {
            return node.ownerDocument.designMode.toLowerCase() === 'on' || node.isContentEditable;
        },


        // private
        isReadableKey: function (keyCode) {
            var KC = Siesta.Test.UserAgent.KeyCodes();

            return !KC.isNav(keyCode) && !KC.isSpecial(keyCode);
        },


        activeElement : function (notAllowBody, fallbackEl, elOrDoc) {
            var doc         = elOrDoc ? elOrDoc.ownerDocument || elOrDoc : this.global.document

            var focusedEl   = doc.activeElement;

            // 1. In IE10,11 it seems activeElement cannot be trusted as it sometimes returns an empty object with no properties.
            // Try to detect this case and use the fallback el
            // 2. Sometimes receiving <body> from this method does not make sense either - use fallback el as well
            if (!focusedEl || !focusedEl.nodeName || !focusedEl.tagName || (focusedEl === doc.body && notAllowBody)) {
                focusedEl   = fallbackEl;
            }

            // For iframes, we need to grab the activeElement of the frame (if in the same domain)
            if (focusedEl && String(focusedEl.tagName).toLowerCase() == 'iframe') {
                try {
                    if (focusedEl.contentDocument && focusedEl.contentDocument.body) {
                        focusedEl = this.activeElement(notAllowBody, fallbackEl, focusedEl.contentDocument)
                    }
                }
                catch(e) {}
            }

            return focusedEl || doc.body
        }
    }
});
;
/**
@class Siesta.Test.Browser.Role.CanRebindJQueryContext

*/
Role('Siesta.Test.Browser.Role.CanRebindJQueryContext', {

    methods : {

        /**
         * This method rebinds jQuery context to a test page. It can be used as "normal" jQuery:
         *

            this.$('.cssSelector').setWidth(100)

         *
         */
        $ : function () {
            var local$ = $.rebindWindowContext(this.global);
            return local$.apply(this.global, arguments);
        }
    }
});
;
Role('Siesta.Util.Role.Dom', {

    does        : [
        Siesta.Util.Role.CanCalculatePageScroll
    ],

    has : {
        doesNotIncludeMarginInBodyOffset : false
    },

    methods : {

        isCrossOriginWindow : function (win) {
            try {
                var doc     = win.document;
            } catch (e) {
                return true
            }

            // Safari doesn't throw exception when trying to access x-domain frames
            return !doc
        },


        closest : function (elem, selector, maxLevels) {
            maxLevels = maxLevels || Number.MAX_VALUE;

            var docEl = elem.ownerDocument.documentElement;

            // Get closest match
            for (var i = 0; i < maxLevels && elem && elem !== docEl; elem = elem.parentNode) {
                if (Siesta.Sizzle.matchesSelector(elem, selector)) {
                    return elem;
                }

                i++;
            }

            return false;
        },


        contains : function (parentEl, childEl) {
            if (!parentEl) return false

            if (parentEl.contains)  return parentEl.contains(childEl)

            // SVG elements in IE does not have "contains" method
            if (parentEl.compareDocumentPosition)
                return parentEl === childEl || Boolean(parentEl.compareDocumentPosition(childEl) & 16)

            throw new Error("Can't determine `contains` status")
        },


        matches : function (node, selector) {
            return Siesta.Sizzle.matchesSelector(node, selector);
        },


        // returns { left : Number, top : Number } object in page coordinates
        offset : function (elem) {
            if (!elem) return null

            var doc     = elem.ownerDocument
            if (!doc) return null

            if (elem === doc.body) return this.bodyOffset(elem);

            var box = this.getBoundingClientRect(elem)

            var win     = doc.defaultView || doc.parentWindow

            return box ? {
                left    : this.viewportXtoPageX(Math.floor(box.left), win),
                top     : this.viewportYtoPageY(Math.floor(box.top), win)
            } : {
                left    : 0,
                top     : 0
            }
        },


        bodyOffset: function (body) {
            var top     = body.offsetTop,
                left    = body.offsetLeft;

            this.initializeOffset();

            if (this.doesNotIncludeMarginInBodyOffset) {
                var style = getComputedStyle(body);

                top     += parseFloat(style.marginTop) || 0;
                left    += parseFloat(style.marginLeft) || 0;
            }

            return { top: top, left: left };
        },


        initializeOffset: function () {
            var body        = document.body,
                container   = document.createElement("div"),
                bodyMarginTop = parseFloat(getComputedStyle(body).marginTop) || 0,
                html        = "<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div><table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>";

            var styles      = { position: "absolute", top: 0, left: 0, margin: 0, border: 0, width: "1px", height: "1px", visibility: "hidden" };

            for (var o in styles) {
                container.style[ o ] = styles[ o ];
            }

            container.innerHTML     = html;

            body.insertBefore(container, body.firstChild);

            var innerDiv            = container.firstChild;
            var checkDiv            = innerDiv.firstChild;
            var td                  = innerDiv.nextSibling.firstChild.firstChild;

            checkDiv.style.position = "fixed";
            checkDiv.style.top      = "20px";
            checkDiv.style.position = checkDiv.style.top = "";

            innerDiv.style.overflow = "hidden";
            innerDiv.style.position = "relative";

            this.doesNotIncludeMarginInBodyOffset = (body.offsetTop !== bodyMarginTop);

            body.removeChild(container);

            this.initializeOffset   = function () {};
        },


        getElementWidth : function (el) {
            return this.getBoundingClientRect(el).width;
        },


        getElementHeight : function (el) {
            return this.getBoundingClientRect(el).height;
        },


        getWindowSize : function (win) {
            var doc         = win.document

            return {
                width       : win.innerWidth || doc.documentElement.clientWidth || doc.body.clientWidth,
                height      : win.innerHeight || doc.documentElement.clientHeight || doc.body.clientHeight
            }
        },


        isPointWithinElement : function (x, y, el) {
            var rect = this.getBoundingClientRect(el);

            return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
        },


        isElementReachableAt : function (el, pageX, pageY, allowChild) {
            allowChild      = allowChild !== false

            var doc         = el.ownerDocument
            var win         = doc.defaultView || doc.parentWindow
            var foundEl     = doc.elementFromPoint(this.pageXtoViewportX(pageX, win), this.pageYtoViewportY(pageY, win))

            return foundEl && (foundEl === el || allowChild && this.contains(el, foundEl))
        },


        isElementReachableAtCenter : function (el, allowChild) {
            allowChild      = allowChild !== false

            var offsets     = this.offset(el);

            return this.isElementReachableAt(
                el,
                offsets.left + (this.getElementWidth(el) / 2),
                offsets.top + (this.getElementHeight(el) / 2),
                allowChild
            );
        },

        // patched version to support SVG in IE11/Edge
        getBoundingClientRect : function (el) {
            var svgEl = el.ownerSVGElement;

            if (svgEl && (bowser.msie || bowser.msedge || bowser.gecko)) {
                var elBox   = el.getBBox(),
                    svgRect = svgEl.getBoundingClientRect(),
                    left    = svgRect.left + elBox.x,
                    top     = svgRect.top + elBox.y,
                    right   = left + elBox.width,
                    bottom  = top + elBox.height;

                return {
                    x      : left,
                    y      : top,
                    left   : left,
                    top    : top,
                    bottom : bottom,
                    height : elBox.height,
                    width  : elBox.width
                };
            } else {
                return el.getBoundingClientRect();
            }
        },


        nodeIsUnloaded : function (el) {
            try {
                // throws if accessed when element belonged to an iframe that's no longer in DOM
                el && el.tagName

                var doc = el.ownerDocument
                var win = doc && (doc.defaultView || doc.parentWindow)

                return !Boolean(win)
            } catch (e) {
                // exception here probably means the "lastOverEl" is from freed context (unloaded page)
                // access to such elements throws exceptions in IE
                el          = null

                return true
            }
        },


        nodeIsOrphan : function (el) {
            var doc = el.ownerDocument

            return !doc || !doc.body || !el.parentNode || !(el === doc.body || $.contains(doc.body, el));
        },


        getNodeParents : function (node) {
            var doc   = node.ownerDocument;
            var nodes = [];

            for (; node && node.parentNode; node = node.parentNode) {
                nodes.unshift(node);
            }

            return nodes;
        },


        getCommonAncestor : function (node1, node2) {
            var parents1 = this.getNodeParents(node1);
            var parents2 = this.getNodeParents(node2);

            // Make sure both nodes are part of same DOM tree
            if (parents1[ 0 ] != parents2[ 0 ]) return null;

            for (var i = 0; i < parents1.length; i++) {
                if (parents1[ i ] !== parents2[ i ]) {
                    return parents1[ i - 1 ];
                }
            }
        }
    }
})
;
/**
@class Siesta.Test.Action.Role.HasTarget

This is a mixin, allowing the action to have "target" attribute, also aliased as "el". Target will be also passed
further on chain, as the argument after "next":

    t.chain(
        {
            action      : 'click',
            target      : buttonComp
        },
        function (next, buttonComp) {
            // target is available as 2nd argument

            next()
        },
        {
            action      : 'click',
            target      : '>>button',
            offset      : [10, 20]
        },
        function (next, buttonComp) {
            // various queries will be resolved down to Ext.Component instance or DOM element

            next()
        },
        ...
    )

If needed, this behavior can be disabled with {@link #passTargetToNext} option.

*/
Role('Siesta.Test.Action.Role.HasTarget', {


    has : {
        /**
         * @cfg {Siesta.Test.ActionTarget/Function} [target=undefined]
         *
         * A target for action. See {@link Siesta.Test.ActionTarget} for various values that can be provided.
         *
         * **Important.** If the function is provided for this config, it will be called and returning value used as actual target.
         * This is useful, since sometimes target for the action depends from the previous step and
         * is not yet available during `t.chain` call.
         *
         * For example, you want to click on the button which opens a window and then click on something in the window. Compare:
         *

    t.chain(
        // clicking on button opens the window
        {
            action      : 'click',
            target      : buttonComp
        },
        // FRAGILE: `windowComp` could not be rendered yet - `buttonComp` is not yet clicked!
        {
            action      : 'click',
            target      : windowComp.el.down('.clickArea')
        }

        // MORE ROBUST: taking the "el" right before this action starts
        {
            action      : 'click',
            target      : function () {
                return windowComp.el.down('.clickArea')
            }
        }
    )
         *
         * Target will be available in the next step as the 2nd argument. See {@link Siesta.Test.Action.Role.HasTarget}
         *
         * This config option can also be provided as "el"
         */
        target              : { required : false },

        normalizedTarget    : null,
        cachedTarget        : null,

        /**
         * @cfg {Object} el
         *
         * An alias for {@link #target}
         */

        /**
         * @cfg {Boolean} passTargetToNext Whether to pass the target further on chain as the first argument
         */
        passTargetToNext    : true,


        /**
         * @cfg {Object} options
         *
         * Any options that will be used when simulating the event. For information about possible
         * config options, please see: <https://developer.mozilla.org/en-US/docs/DOM/event.initMouseEvent>
         */
        options             : null,

        /**
         * @cfg {Array} offset
         *
         * An offset in X, Y coordinates from the targeted element. The offset can be expressed in 3 different ways.
         *
         * - Integers             : `[10, 20]`       -  offset 10px from left, 20px from top
         * - Percent              : `["10%", 20]`    -  offset 10% from left, 20px from top
         * - Percent + offset     : `["100%-2", 20]` -  offset -2px from right, 20px from top
         */
        offset              : null,

        waitForTarget       : true
    },


    after : {
        initialize : function () {
            if (!this.passTargetToNext) return

            var me          = this
            var prevNext    = this.next

            this.next       = function () {
                prevNext.call(this, me.normalizedTarget);
            }
        }
    },


    methods : {

        BUILD : function (config) {
            // allow "el" as synonym for "target"
            if (config.el && !config.target) config.target = config.el

            return config
        },


        getTarget : function () {
            if (this.cachedTarget) return this.cachedTarget

            var test        = this.test;
            var target      = this.target || test.getCursorPagePosition()

            if (test.typeOf(target) === 'Function') target = target.call(test, this);

            this.normalizedTarget   = test.normalizeActionTarget(target, true)

            return this.cachedTarget   = target
        }
    }
});
;
/**

@class Siesta.Test.Action.Swipe
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action can be included in the `t.chain` call with "swipe" shortcut:

    t.chain(
        {
            action      : 'swipe',
            target      : someDOMElement
        },
        // or
        {
            swipe       : someDOMElement
        }
    )

This action will perform a {@link Siesta.Test.SenchaTouch#swipe swipe} on the provided {@link #target}. 

*/
Class('Siesta.Test.Action.Swipe', {
    
    isa         : Siesta.Test.Action,
    
    does        : Siesta.Test.Action.Role.HasTarget,
        
    has : {
        requiredTestMethod          : 'swipe',
         
        /**
         * @cfg {String} direction Either 'left', 'right', 'up' or 'down'
         */
        direction                  : 'left'
    },

    
    methods : {
        
        process : function () {
            this.test.swipe(this.getTarget(), this.direction, this.next)
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('swipe', Siesta.Test.Action.Swipe)
;
/**

@class Siesta.Test.Action.Pinch
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action can be included in the `t.chain` call with "swipe" shortcut:

    t.chain(
        {
            action      : 'swipe',
            target      : someDOMElement
        },
        // or
        {
            swipe       : someDOMElement
        }
    )

This action will perform a {@link Siesta.Test.SenchaTouch#swipe swipe} on the provided {@link #target}. 

*/
Class('Siesta.Test.Action.Pinch', {
    
    isa         : Siesta.Test.Action,
    
    does        : Siesta.Test.Action.Role.HasTarget,
        
    has : {
        requiredTestMethod          : 'pinch',
         
        /**
         * @cfg {String} scale The scale for the pinch operation
         */
        scale                       : 2,
        
        target2                     : null,
        offset2                     : null,
        
        cachedTarget2               : null
    },

    
    methods : {
        
        process : function () {
            this.test.pinch(this.getTarget(), this.getTarget2(), this.scale, this.next, null, this.options, this.offset, this.offset2)
        },
        
        
        getTarget2 : function () {
            if (this.cachedTarget2) return this.cachedTarget2
            
            var test        = this.test;
            var target2     = this.target2

            if (test.typeOf(target2) === 'Function') target2 = target2.call(test, this);
            
            return this.cachedTarget2   = target2
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('pinch', Siesta.Test.Action.Pinch)
;
/**

@class Siesta.Test.Action.LongPress
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action can be included in the `t.chain` call with "click" shortcut:

    t.chain(
        {
            action      : 'longpress',
            target      : someDOMElement
        },
        // or
        {
            longpress   : someDOMElement
        }
    )

This action will perform a {@link Siesta.Test.SenchaTouch#longpress longpress} on the provided {@link #target}. 

*/
Class('Siesta.Test.Action.LongPress', {
    
    isa         : Siesta.Test.Action,
    
    does        : Siesta.Test.Action.Role.HasTarget,
        
    has : {
        requiredTestMethod  : 'longPress'
    },

    
    methods : {
        
        process : function () {
            this.test.longpress(this.getTarget(), this.next, null, this.options, this.offset)
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('longpress', Siesta.Test.Action.LongPress)
;
/**

@class Siesta.Test.Action.Tap
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action can be included in the `t.chain` call with "tap" shortcut:

    t.chain(
        {
            action      : 'tap',
            target      : someDOMElement
        },
        // or
        {
            tap         : someDOMElement
        }
    )

This action will perform a {@link Siesta.Test.Browser#tap tap} on the provided {@link #target}. 

*/
Class('Siesta.Test.Action.Tap', {
    
    isa         : Siesta.Test.Action,
    
    does        : Siesta.Test.Action.Role.HasTarget,
        
    has : {
        requiredTestMethod  : 'tap'
    },

    
    methods : {
        
        process : function () {
            this.test.tap(this.getTarget(), this.next, null, this.options, this.offset)
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('tap', Siesta.Test.Action.Tap);
/**

@class Siesta.Test.Action.DoubleTap
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action will perform a {@link Siesta.Test.Browser#doubleClick double tap} on the provided {@link #target}. 

This action can be included in the `t.chain` call with "doubletap" or "doubleTap" shortcuts:

    t.chain(
        {
            action      : 'doubletap',
            target      : someDOMElement
        },
        // or
        {
            doubletap   : someDOMElement,
            offset      : [20,20] // click 20px from the left/top corner of the element
        }
    )


*/
Class('Siesta.Test.Action.DoubleTap', {
    
    isa         : Siesta.Test.Action,
    
    does        : Siesta.Test.Action.Role.HasTarget,
        
    has : {
        requiredTestMethod  : 'doubleTap'
    },

    
    methods : {
        
        process : function () {
            this.test.doubleTap(this.getTarget(), this.next, null, this.options, this.offset, this.waitForTarget)
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('doubletap', Siesta.Test.Action.DoubleTap)
;
/**

@class Siesta.Test.Action.TouchDrag
@extends Siesta.Test.Action

This action can be included in the `t.chain` call with the "touchDrag" shortcut:

    t.chain(
        {
            action      : 'touchDrag',
            target      : someDOMElementOrArray,
            to          : someDOMElementOrArray
        },
        {
            action      : 'touchDrag',
            target      : someDOMElementOrArray,
            by          : [ 10, 10 ]
        },
        // or
        {
            touchDrag   : someDOMElementOrArray,
            to          : someDOMElementOrArray
        }
    )

This action will perform a {@link Siesta.Test.Browser#dragTo dragTo} or {@link Siesta.Test.Browser#dragBy dragBy} actions on the provided {@link #target}.

*/
Class('Siesta.Test.Action.TouchDrag', {

    isa         : Siesta.Test.Action,

    does        : Siesta.Test.Action.Role.HasTarget,

    has : {
        requiredTestMethod  : 'touchDragTo',

        /**
         * @cfg {Siesta.Test.ActionTarget/Function} target
         *
         * The initial point of dragging operation. Can be provided as Siesta.Test.ActionTarget or the function returning it.
         * Will also be passed further to the next step.
         */

        /**
         * @cfg {Siesta.Test.ActionTarget/Function} source
         *
         * Alias for {@link #target}. This may sound confusing, but "target" of "drag" action is its "source" in the same time.
         */


        /**
         * @cfg {Siesta.Test.ActionTarget/Function} to
         *
         * The target point of dragging operation. Can be provided as the DOM element, the array with screen coordinates: `[ x, y ]`, or the function
         * returning one of those.
         *
         * Exactly one of the `to` and `by` configuration options should be provided for this action.
         */
        to                  : null,

        /**
         * @cfg {Array} fromOffset
         *
         * An offset in X, Y coordinates from the source element. Can be also specified as `offset` config.
         */
        fromOffset          : null,

        /**
         * @cfg {Array} toOffset
         *
         * An offset in X, Y coordinates from the targeted element
         */
        toOffset            : null,

        /**
         * @cfg {Array/Function} by
         *
         * The delta for dragging operation. Should be provided as the array with delta value for each coordinate: `[ dX, dY ]` or the function returning such.
         *
         * Exactly one of the `to` and `by` configuration options should be provided for this action.
         */
        by                  : null,


        /**
         * @cfg {Boolean} dragOnly
         *
         * True to skip the mouseup and not finish the drop operation (one can start another drag operation, emulating the pause during drag-n-drop).
         */
        dragOnly            : false,

        byOrToMissingText   : 'Either "to" or "by" configuration option is required for "drag" step',
        byAndToDefinedText  : 'Exactly one of "to" or "by" configuration options is required for "drag" step, not both'
    },


    override : {
        BUILD : function (config) {
            // allow "source" as synonym for "target"
            // sounds weird, but "target" in action domain means source point for dragging
            if (config.source && !config.target) config.target = config.source

            return this.SUPER(config)
        }
    },


    methods : {

        initialize : function () {
            this.SUPER()

            if (!this.to && !this.by)   throw this.byOrToMissingText
            if (this.to && this.by)     throw this.byAndToDefinedText
        },


        getTo : function () {
            if (this.test.typeOf(this.to) == 'Function')
                return this.to.call(this.test, this)
            else
                return this.to
        },


        getBy : function () {
            if (this.test.typeOf(this.by) == 'Function')
                return this.by.call(this.test, this)
            else
                return this.by
        },


        process : function () {
            var next                = this.next;
            var test                = this.test
            var target              = this.getTarget();
            var normalizedTarget    = test.normalizeActionTarget(target, true)

            if (this.to) {
                test.touchDragTo(
                    target,
                    this.getTo(),
                    function() { next(normalizedTarget || test.normalizeActionTarget(target)); },
                    null,
                    this.options,
                    this.dragOnly,
                    this.fromOffset || this.offset,
                    this.toOffset
                )
            } else {
                test.touchDragBy(
                    target,
                    this.getBy(),
                    function() { next(normalizedTarget || test.normalizeActionTarget(target)); },
                    null,
                    this.options,
                    this.dragOnly,
                    this.fromOffset || this.offset
                )
            }
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('touchdrag', Siesta.Test.Action.TouchDrag);
/**

@class Siesta.Test.Action.MouseDown
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action can be included in a `t.chain` call with "mouseDown" shortcut:

    t.chain(
        {
            action      : 'mouseDown',
            target      : someDOMElement,
            options     : { shiftKey : true } // Optionally hold shiftkey
        },
        // or
        {
            mousedown   : someDOMElement,
            options     : { shiftKey : true } // Optionally hold shiftkey
        }
    )

This action will perform a {@link Siesta.Test.Browser#MouseDown MouseDown} on the provided {@link #target}.

*/
Class('Siesta.Test.Action.MouseDown', {

    isa         : Siesta.Test.Action,

    does        : Siesta.Test.Action.Role.HasTarget,

    has : {
        requiredTestMethod  : 'mouseDown'
    },


    methods : {

        process : function () {
            this.test.mouseDown(this.getTarget(), this.options, this.offset, this.next, this, this.waitForTarget);
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('mouseDown', Siesta.Test.Action.MouseDown)
Siesta.Test.ActionRegistry().registerAction('fingerDown', Siesta.Test.Action.MouseDown)
;
/**

@class Siesta.Test.Action.MouseUp
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action can be included in a `t.chain` call with "mouseUp" shortcut:

    t.chain(
        {
            action      : 'mouseUp',
            target      : someDOMElement,
            options     : { shiftKey : true } // Optionally hold shiftkey
        },
        // or
        {
            mouseup     : someDOMElement,
            options     : { shiftKey : true } // Optionally hold shiftkey
        }
    )

This action will perform a {@link Siesta.Test.Browser#mouseUp mouseUp} on the provided {@link #target}.

*/
Class('Siesta.Test.Action.MouseUp', {

    isa         : Siesta.Test.Action,

    does        : Siesta.Test.Action.Role.HasTarget,

    has : {
        requiredTestMethod  : 'mouseUp'
    },


    methods : {

        process : function () {
            this.test.mouseUp(this.getTarget(), this.options, this.offset, this.next);
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('mouseUp', Siesta.Test.Action.MouseUp)
Siesta.Test.ActionRegistry().registerAction('fingerUp', Siesta.Test.Action.MouseUp)
;
/**

@class Siesta.Test.Action.Click
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action can be included in the `t.chain` call with "click" shortcut:

    t.chain(
        {
            action      : 'click',
            target      : someDOMElement,
            options     : { shiftKey : true } // Optionally hold shiftkey
        },
        // or
        {
            click       : someDOMElement,
            options     : { shiftKey : true } // Optionally hold shiftkey
        }
    )

This action will perform a {@link Siesta.Test.Browser#click click} on the provided {@link #target}. 

*/
Class('Siesta.Test.Action.Click', {
    
    isa         : Siesta.Test.Action,
    
    does        : Siesta.Test.Action.Role.HasTarget,
        
    has : {
        requiredTestMethod  : 'click'
    },

    methods : {
        
        process : function () {
            this.test.click(this.getTarget(), this.next, null, this.options, this.offset, this.waitForTarget);
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('click', Siesta.Test.Action.Click);
;
/**

@class Siesta.Test.Action.DoubleClick
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action will perform a {@link Siesta.Test.Browser#doubleClick double click} on the provided {@link #target}. 

This action can be included in the `t.chain` call with "doubleclick" or "doubleClick" shortcuts:

    t.chain(
        {
            action      : 'doubleclick',
            target      : someDOMElement,
            options     : { shiftKey : true } // Optionally hold shiftkey
        },
        // or
        {
            doubleclick : someDOMElement,
            options     : { shiftKey : true } // Optionally hold shiftkey
        }
        
    )


*/
Class('Siesta.Test.Action.DoubleClick', {
    
    isa         : Siesta.Test.Action,
    
    does        : Siesta.Test.Action.Role.HasTarget,
        
    has : {
        requiredTestMethod  : 'doubleClick'
    },

    
    methods : {
        
        process : function () {
            this.test.doubleClick(this.getTarget(), this.next, null, this.options, this.offset, this.waitForTarget)
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('doubleclick', Siesta.Test.Action.DoubleClick)
Siesta.Test.ActionRegistry().registerAction('dblclick', Siesta.Test.Action.DoubleClick)
;
/**

@class Siesta.Test.Action.RightClick
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action will perform a {@link Siesta.Test.Browser#rightClick right click} on the provided {@link #target}. 

This action can be included in the `t.chain` call with "rightclick" or "rightClick" shortcuts:

    t.chain(
        {
            action      : 'rightclick',
            target      : someDOMElement,
            options     : { shiftKey : true } // Optionally hold shiftkey
        },
        // or
        {
            rightclick  : someDOMElement,
            options     : { shiftKey : true } // Optionally hold shiftkey
        }
    )


*/
Class('Siesta.Test.Action.RightClick', {
    
    isa         : Siesta.Test.Action,
    
    does        : Siesta.Test.Action.Role.HasTarget,
        
    has : {
        requiredTestMethod  : 'rightClick'
    },

    
    methods : {
        
        process : function () {
            this.test.rightClick(this.getTarget(), this.next, null, this.options, this.offset, this.waitForTarget)
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('rightclick', Siesta.Test.Action.RightClick)
Siesta.Test.ActionRegistry().registerAction('contextmenu', Siesta.Test.Action.RightClick);
/**

@class Siesta.Test.Action.Wheel
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action can be included in the `t.chain` call with the "wheel" shortcut:

    t.chain(
        {
            action      : 'wheel',
            target      : someDOMElement,
            options     : { deltaY : 10 }
        },
        // or
        {
            wheel       : someDOMElement,
            options     : { deltaY : 10 }
        }
    )

This action will perform a {@link Siesta.Test.Browser#wheel wheel} action on the provided {@link #target}.

*/
Class('Siesta.Test.Action.Wheel', {
    
    isa         : Siesta.Test.Action,
    
    does        : Siesta.Test.Action.Role.HasTarget,
        
    has : {
        requiredTestMethod  : 'wheel'
    },

    methods : {
        
        process : function () {
            this.test.wheel(this.getTarget(), this.next, null, this.options, this.offset, this.waitForTarget);
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('wheel', Siesta.Test.Action.Wheel);
;
/**

@class Siesta.Test.Action.Type
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action will {@link Siesta.Test.Browser#type type} the provided {@link #text} into the provided {@link #target}. For more
 information about how you can type special characters and hold special keys such as ALT or SHIFT, please see the docs for the {@link Siesta.Test.Browser#type type} method.
 The target provide should be a {@link Siesta.Test.ActionTarget} - CSS selector, DOM element instance, Component Query etc.

This action can be included in a `t.chain` call with the "type" shortcut. **Note** that unlike other actions, in its compact
form the value of the "type" property should contain the text to type, not the target of action.

    t.chain(
         {
             // "type" into the currently focused DOM element
             type        : 'Some text[ENTER]'
         },
         // or
         {
             action      : 'type',
             target      : someDOMElement,
             text        : 'Some text',
             options     : { shiftKey : true }
         },
         // or
         {
            // NOTE: "type" contains text to type, not the action target as in other actions
            type        : 'Some text',
            target      : someDOMElement
         }
    );

*/
Class('Siesta.Test.Action.Type', {

    isa         : Siesta.Test.Action,

    does        : Siesta.Test.Action.Role.HasTarget,

    has : {
        requiredTestMethod  : 'type',

        /**
         * @cfg {String} text
         *
         * The text to type into the target
         */
        text                : '',

        /**
         * @cfg {Object} options
         *
         * Any options that will be used when simulating the event. For information about possible
         * config options, please see: <https://developer.mozilla.org/en-US/docs/DOM/event.initMouseEvent>
         */
        options             : null,

        /**
         * @cfg {Boolean} clearExisting
         *
         *  true to clear existing text in the target before typing
         */
        clearExisting       : false
    },


    methods : {

        process : function () {
            var waitForTarget = this.waitForTarget || !!this.target;

            // By default use the current focused element as target
            this.target = this.target || this.test.activeElement();

            // additional "getTarget" to allow functions as "target" value
            this.test.type(this.getTarget(), this.text, this.next, null, this.options, this.clearExisting, waitForTarget);
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('type', Siesta.Test.Action.Type);
/**

@class Siesta.Test.Action.Drag
@extends Siesta.Test.Action

This action can be included in the `t.chain` call with the "drag" shortcut:

    t.chain(
        {
            action      : 'drag',
            target      : someDOMElementOrArray,
            to          : someDOMElementOrArray
        },
        {
            action      : 'drag',
            target      : someDOMElementOrArray,
            options     : { shiftKey : true } // Optionally hold shiftkey
            by          : [ 10, 10 ]
        },
        // or
        {
            drag        : someDOMElementOrArray,
            to          : someDOMElementOrArray
        }
    )

This action will perform a {@link Siesta.Test.Browser#dragTo dragTo} or {@link Siesta.Test.Browser#dragBy dragBy} actions on the provided {@link #target}.

*/
Class('Siesta.Test.Action.Drag', {

    isa         : Siesta.Test.Action,

    does        : Siesta.Test.Action.Role.HasTarget,

    has : {
        requiredTestMethod  : 'dragTo',

        /**
         * @cfg {Siesta.Test.ActionTarget/Function} target
         *
         * The initial point of dragging operation. Can be provided as Siesta.Test.ActionTarget or the function returning it.
         * Will also be passed further to the next step.
         */

        /**
         * @cfg {Siesta.Test.ActionTarget/Function} source
         *
         * Alias for {@link #target}. This may sound confusing, but "target" of "drag" action is its "source" in the same time.
         */


        /**
         * @cfg {Siesta.Test.ActionTarget/Function} to
         *
         * The target point of dragging operation. Can be provided as the DOM element, the array with screen coordinates: `[ x, y ]`, or the function
         * returning one of those.
         *
         * Exactly one of the `to` and `by` configuration options should be provided for this action.
         */
        to                  : null,

        /**
         * @cfg {Array} fromOffset
         *
         * An offset in X, Y coordinates from the source element. Can be also specified as `offset` config.
         */
        fromOffset          : null,

        /**
         * @cfg {Array} toOffset
         *
         * An offset in X, Y coordinates from the targeted element
         */
        toOffset            : null,

        /**
         * @cfg {Array/Function} by
         *
         * The delta for dragging operation. Should be provided as the array with delta value for each coordinate: `[ dX, dY ]` or the function returning such.
         *
         * Exactly one of the `to` and `by` configuration options should be provided for this action.
         */
        by                  : null,


        /**
         * @cfg {Boolean} dragOnly
         *
         * True to skip the mouseup and not finish the drop operation (one can start another drag operation, emulating the pause during drag-n-drop).
         */
        dragOnly            : false,

        byOrToMissingText   : 'Either "to" or "by" configuration option is required for "drag" step',
        byAndToDefinedText  : 'Exactly one of "to" or "by" configuration options is required for "drag" step, not both'
    },


    override : {
        BUILD : function (config) {
            // allow "source" as synonym for "target"
            // sounds weird, but "target" in action domain means source point for dragging
            if (config.source && !config.target) config.target = config.source

            return this.SUPER(config)
        }
    },


    methods : {

        initialize : function () {
            this.SUPER()

            if (!this.to && !this.by)   throw this.byOrToMissingText
            if (this.to && this.by)     throw this.byAndToDefinedText
        },


        getTo : function () {
            if (this.test.typeOf(this.to) === 'Function')
                return this.to.call(this.test, this)
            else
                return this.to
        },


        getBy : function () {
            if (this.test.typeOf(this.by) === 'Function')
                return this.by.call(this.test, this)
            else
                return this.by
        },


        process : function () {
            var next                = this.next;
            var test                = this.test
            var target              = this.getTarget();
            var normalizedTarget    = test.normalizeActionTarget(target, true)

            if (this.to) {
                test.dragTo(target, this.getTo(), function() { next(normalizedTarget || test.normalizeActionTarget(target, true)); }, null, this.options, this.dragOnly, this.fromOffset || this.offset, this.toOffset, this.waitForTarget)
            } else {
                test.dragBy(target, this.getBy(), function() { next(normalizedTarget || test.normalizeActionTarget(target, true)); }, null, this.options, this.dragOnly, this.fromOffset || this.offset, this.waitForTarget)
            }
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('drag', Siesta.Test.Action.Drag)
;
/**

@class Siesta.Test.Action.MonkeyTest
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action can be included in a `t.chain` call with "monkeyTest" shortcut:

    t.chain(
        { monkeyTest   : '.someSelector' }
    )

This action will perform a {@link Siesta.Test.Browser#MouseDown MouseDown} on the provided {@link #target}.

*/
Class('Siesta.Test.Action.MonkeyTest', {

    isa         : Siesta.Test.Action,

    does        : Siesta.Test.Action.Role.HasTarget,

    has : {
        requiredTestMethod  : 'monkeyTest',

        nbrInteractions     : 10,

        skipTargets         : null,

        hasOwnAsyncFrame    : true
    },


    methods : {

        process : function () {
            this.test.monkeyTest({
                target              : this.getTarget(),
                nbrInteractions     : this.nbrInteractions,
                skipTargets         : this.skipTargets,
                callback            : this.next
            })
        }
    }
})


Siesta.Test.ActionRegistry().registerAction('monkeyTest', Siesta.Test.Action.MonkeyTest)
Siesta.Test.ActionRegistry().registerAction('monkey', Siesta.Test.Action.MonkeyTest)
;
/**

@class Siesta.Test.Action.MoveCursor
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action can be included in the `t.chain` call with "moveCursor" shortcut:

    t.chain(
        {
            action      : 'moveCursor',
            to          : 'div.someClass'   // A div with class='someClass'
        },
        {
            action      : 'moveCursor',
            to          : [400, 300]        // Target pixel coordinates
        },
        {
            action      : 'moveCursor',
            by          : [20, 10]  // 20 px right, 10 px down
        }
    )

This action will perform a {@link Siesta.Test.Simulate.Mouse#moveCursorTo moveCursorTo} to the provided 'to' destination or the relative 'by' offset.

*/
Class('Siesta.Test.Action.MoveCursor', {
    
    isa         : Siesta.Test.Action,
    
    has : {
        requiredTestMethod  : 'moveMouseTo',
        
        /**
         * @cfg {Siesta.Test.ActionTarget/Function} to 
         * 
         * The target point the cursor should be moved to. Can be provided as a DOM element, an array with client coordinates: `[ x, y ]`, or a function
         * returning one of those. You can additionally pass an 'offset' array to click at a point relative to the XY position of the target.
         * 
         * Exactly one of the `to` and `by` configuration options should be provided for this action.
         */
        to                  : null,
        
        
        /**
         * @cfg {Array/Function} by 
         * 
         * The delta for moving cursor. Should be provided as the array with delta value for each coordinate: `[ dX, dY ]` or the function returning such.
         * 
         * Exactly one of the `to` and `by` configuration options should be provided for this action.
         */
        by                  : null,

        /**
         * @cfg {Array} offset
         *
         * An offset in X, Y coordinates from the targeted element (only applicable when using the 'to' target option.
         */
        offset              : null
    },

    
    methods : {
        getTo : function () {
            if (this.test.typeOf(this.to) == 'Function')
                return this.to.call(this.test, this)
            else
                return this.to
        },
        
        
        getBy : function () {
            if (this.test.typeOf(this.by) == 'Function')
                return this.by.call(this.test, this)
            else
                return this.by
        },

        process : function () {
            var test                    = this.test;
            var next                    = this.next;

            if (this.to) {
                var to                  = this.getTo()
                
                var normalizedTarget    = test.normalizeActionTarget(to, false)
                
                test.moveMouseTo(to, function() { next(normalizedTarget); }, null, this.offset)
            } else {
                var by                  = this.getBy()
                var currentXY           = test.getCursorPagePosition()
                
                var normalizedTarget    = test.normalizeActionTarget([ currentXY[ 0 ] + by[ 0 ], currentXY[ 1 ] + by[ 1 ] ]);

                test.moveMouseBy(by, function() { next(normalizedTarget); })
            }
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('moveCursor', Siesta.Test.Action.MoveCursor)
Siesta.Test.ActionRegistry().registerAction('moveMouse', Siesta.Test.Action.MoveCursor)
Siesta.Test.ActionRegistry().registerAction('moveFinger', Siesta.Test.Action.MoveCursor)
;
/**

@class Siesta.Test.Action.MoveCursorTo
@extends Siesta.Test.Action
@mixin Siesta.Test.Action.Role.HasTarget

This action can be included in the `t.chain` call with "moveCursorTo" shortcut:

    t.chain(
        {
            action          : 'moveCursorTo',
            target          : someDOMElement
        },
        // or
        {
            moveCursorTo    : someDOMElement
        }
    )

This action will perform a {@link Siesta.Test.Simulate.Mouse#moveCursorTo moveCursorTo} on the provided {@link #target}.

*/
Class('Siesta.Test.Action.MoveCursorTo', {

    isa         : Siesta.Test.Action,

    does        : Siesta.Test.Action.Role.HasTarget,

    has : {
        requiredTestMethod  : 'moveMouseTo',
        target              : { required : true }
    },


    methods : {

        process : function () {
            this.test.moveMouseTo(this.getTarget(), this.next, null, this.offset, this.waitForTarget, this.options)
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('moveCursorTo', Siesta.Test.Action.MoveCursorTo)
Siesta.Test.ActionRegistry().registerAction('moveMouseTo', Siesta.Test.Action.MoveCursorTo)
Siesta.Test.ActionRegistry().registerAction('moveFingerTo', Siesta.Test.Action.MoveCursorTo)
;
/**

@class Siesta.Test.Action.MoveCursorBy
@extends Siesta.Test.Action

Action which moves the cursor by an x/y delta, call it with the "moveCursorBy" shortcut:

    t.chain(
        {
            moveCursorBy : [ 100, 100 ]
        },
        ...
    )

*/
Class('Siesta.Test.Action.MoveCursorBy', {

    isa         : Siesta.Test.Action,

    does        : [
        Siesta.Test.Action.Role.HasTarget,
        Siesta.Util.Role.CanGetType
    ],

    has : {
        requiredTestMethod  : 'moveMouseBy'
    },


    methods : {
        process : function () {
            var test = this.test;
            var next = this.next;

            if (this.target && this.typeOf(this.target) === 'Array' && this.typeOf(this.target[ 0 ]) === 'Array') {
                this.target     = this.target[ 0 ]
            }

            test.moveMouseBy(this.getTarget(), this.next, this, this.options);
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('moveMouseBy', Siesta.Test.Action.MoveCursorBy)
Siesta.Test.ActionRegistry().registerAction('moveCursorBy', Siesta.Test.Action.MoveCursorBy)
Siesta.Test.ActionRegistry().registerAction('moveFingerBy', Siesta.Test.Action.MoveCursorBy)
;
/**

@class Siesta.Test.Action.SetUrl
@extends Siesta.Test.Action

Used to set the URL of the test page. The url must be on the same domain as Siesta itself.

    t.chain(
        { setUrl      : 'www.yourdomain.com' }
    )

This action will perform a {@link Siesta.Test.Browser#setUrl setUrl} call using the provided {@link #value}.

*/
Class('Siesta.Test.Action.SetUrl', {
    
    isa         : Siesta.Test.Action,
    
    has : {
        /**
         * @cfg {String} The URL to navigate to
         */
        value              : null,
        setUrl             : null,

        requiredTestMethod  : 'setUrl'
    },

    
    methods : {
        
        process : function () {
            var value   = this.setUrl || this.value;
            var test    = this.test;

            test.setUrl(value, this.next);
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('setUrl', Siesta.Test.Action.SetUrl);
;
/**

@class Siesta.Test.Action.SetValue
@extends Siesta.Test.Action

Used to set value to an Ext.form.Field (text input, checkbox, radio button etc.) This action can be used in a `t.chain` call with the "setValue" shortcut:

    t.chain(
        {
            setValue    : 'Some text',
            target      : '.textInput'
        }
    )

This action will perform a {@link Siesta.Test.ExtJS#setValue setValue} call on the provided {@link #target}.

*/
Class('Siesta.Test.Action.SetValue', {
    
    isa         : Siesta.Test.Action,
    
    has : {
        /**
         * @cfg {Ext.Component/String/Function} target
         * A component instance or a component query to resolve, or a function, returning such.
         */
        target              : null,
        
        setValue            : null,
        
        requiredTestMethod  : 'setValue'
    },

    
    methods : {
        
        process : function () {
            var target  = this.target;
            var test    = this.test;

            if (test.typeOf(target) === 'Function') target = target.call(test, this);

            test.setValue(target, this.setValue, this.next, null);
        }
    }
});


Siesta.Test.ActionRegistry().registerAction('setValue', Siesta.Test.Action.SetValue);
;
Role('Siesta.Test.Simulate.Mouse', {

    requires        : [
        'simulateEvent', 'getSimulateEventsWith', '$'
    ],

    does : [
        Siesta.Util.Role.Dom,
        Siesta.Util.Role.CanCalculatePageScroll,
        Siesta.Test.Browser.Role.CanGetElementFromPoint
    ],

    has: {
        // Current viewport coordinates of the cursor
        // this will be a shared array instance between all subtests
        // it should not be overwritten, instead modify individual elements:
        // NO: this.currentPosition = [ 1, 2 ]
        // YES: this.currentPosition[ 0 ] = 1
        // YES: this.currentPosition[ 1 ] = 2
        currentPosition         : {
            init : function () { return [ 0, 0 ]; }
        },

        /**
         * @cfg {Int} dragDelay The delay between individual drag events (mousemove)
         */
        dragDelay                       : 25,

        pathBatchSize                   : bowser.msie ? 10 : 5,

        mouseMovePrecision              : 1,
        mouseDragPrecision              : 1,

        enableUnreachableClickWarning   : true,

        overEls                         : Joose.I.Array,
        lastMouseOverEl                 : null,

        mouseState                      : 'up',

        // The last element we fired 'mousedown' upon
        lastMouseDownEl                 : null,

        pointerEventNamesMap            : {
            lazy : function () {
                if (window.PointerEvent)
                    return {
                        pointerdown         : 'pointerdown',
                        pointerup           : 'pointerup',
                        pointerover         : 'pointerover',
                        pointerout          : 'pointerout',
                        pointerenter        : 'pointerenter',
                        pointerleave        : 'pointerleave',
                        pointermove         : 'pointermove'
                    }
                else
                    if (window.MSPointerEvent)
                        return {
                            pointerdown         : 'MSPointerDown',
                            pointerup           : 'MSPointerUp',
                            pointerover         : 'MSPointerOver',
                            pointerout          : 'MSPointerOut',
                            pointerenter        : 'MSPointerEnter',
                            pointerleave        : 'MSPointerLeave',
                            pointermove         : 'MSPointerMove'
                        }
                    else
                        return {}
            }
        }
    },


    after : {
        cleanup : function () {
            this.overEls            = null
            this.lastMouseDownEl    = null
            this.lastMouseOverEl    = null
        }
    },


    override : {

        normalizeEventName : function (eventName) {
            var eventMap        = this.getPointerEventNamesMap()

            return eventMap[ eventName ] || this.SUPERARG(arguments);
        },


        simulateEvent : function (el, eventName) {
            var supportsPointerEvents   = Siesta.Project.Browser.FeatureSupport().supports.PointerEventsGeneric

            if (supportsPointerEvents ? /pointerdown$/i.test(eventName) : eventName == 'mousedown') {
                this.mouseState   = 'down'

                this.lastMouseDownEl = el;
            }

            if (supportsPointerEvents ? /pointerup$/i.test(eventName) : eventName == 'mouseup') {
                this.mouseState   = 'up'

                this.lastMouseUpEl = el;
            }

            var event   = this.SUPERARG(arguments)

            if (/pointerdown$/i.test(eventName)) {
                this.lastPointerDownPrevented = this.isEventPrevented(event);
            }

            // in FF for 'textInput' events the returning value can be `undefined`
            if (this.test && this.test.mouseVisualizer && event) this.test.mouseVisualizer.onEventSimulated(event, this.currentPosition)

            return event
        }
    },


    methods: {
        // private
        createMouseEvent: function (type, options, el) {
            var global      = this.global
            var doc         = el.ownerDocument
            var event

            var isPointer   = type.match(/^(ms)?pointer/i)

            options         = this.prepareMouseEventOptions(type, options, el)

            if (!bowser.msie && global.MouseEvent) {
                if (type === 'wheel') {
                    event           = new global.WheelEvent(type, options);
                } else if (isPointer) {
                    // this is non IE branch, so no mess with MS prefix

                    // Chrome sets button to -1 for pointermove
                    if (type === 'pointermove') {
                        options.button = -1;
                    }

                    event           = new global.PointerEvent(type, options);
                } else {
                    event           = new global.MouseEvent(type, options);
                }
            }
            // use W3C standard when available and allowed by "simulateEventsWith" option
            else if (doc.createEvent && this.getSimulateEventsWith() == 'dispatchEvent') {

                if (type === 'wheel') {
                    // https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/platform-apis/ff975847(v=vs.85)
                    /*
                    * A space-separated list of any of the following values:
                        Alt
                        The left or right Alt key is pressed.

                        AltGraph
                        The Ctrl and Alt keys are pressed.

                        CapsLock
                        The Caps Lock toggle is enabled.

                        Control
                        The left or right Ctrl key is pressed.

                        Meta
                        The Meta/Control key is pressed.

                        NumLock
                        The Num Lock toggle is enabled.

                        Scroll
                        The Scroll Lock toggle is enabled.

                        Shift
                        The left or right Shift key is pressed.

                        Win
                        The left or right Windows logo key is pressed.
                    **/
                    var modifiersArg = '';

                    if (options.ctrlKey) modifiersArg = 'Control';
                    if (options.altKey) modifiersArg += ' Alt';
                    if (options.shiftKey) modifiersArg += ' Shift';

                    event           = doc.createEvent('WheelEvent');

                    event.initWheelEvent(
                        type,
                        options.bubbles,
                        options.cancelable,
                        options.view,
                        options.detail,
                        options.screenX,
                        options.screenY,
                        options.clientX,
                        options.clientY,
                        options.button,
                        options.relatedTarget || doc.documentElement,
                        modifiersArg,
                        options.deltaX || 0,
                        options.deltaY || 0,
                        options.deltaZ || 0,
                        options.deltaMode || 0);
                } else {
                    event           = doc.createEvent(isPointer ? (isPointer[ 1 ] ? 'MS' : '') + 'PointerEvent' : 'MouseEvents');

                    event[ isPointer ? 'initPointerEvent' : 'initMouseEvent' ](
                        type, options.bubbles, options.cancelable, options.view, options.detail,
                        options.screenX, options.screenY, options.clientX, options.clientY,
                        options.ctrlKey, options.altKey, options.shiftKey, options.metaKey,
                        options.button, options.relatedTarget || doc.documentElement,
                        // the following extra args are used in the "initPointerEvent"
                        // offsetX, offsetY
                        null, null,
                        // width, height
                        null, null,
                        // pressure, rotation
                        null, null,
                        // tiltX, tiltY
                        null, null,
                        // pointerId
                        options.pointerId,
                        // pointerType
                        // NOTE: this has to be set to "mouse" (IE11) or 4 (IE10, 11) because otherwise
                        // ExtJS5 blocks the event
                        // need to investigate what happens in SenchaTouch
                        options.pointerType,
                        // timestamp
                        null,
                        // isPrimary
                        null
                    );
                }

            } else if (doc.createEventObject) {
                event       = doc.createEventObject();

                $.extend(event, options);

                event.button = { 0: 1, 1: 4, 2: 2 }[ event.button ] || event.button;
            }

            // in Edge, the "pageX/pageY" properties of the event object are calculated by browser completely
            // wrong - need to override those
            if (this.bowser.msedge) {
                global.Object.defineProperty(event, 'pageX', { value : options.pageX })
                global.Object.defineProperty(event, 'pageY', { value : options.pageY })
            }

            // Mouse over is used in some certain edge cases which interfer with this tracking
            if (!/(mouse|pointer)over$/.test(type) && !/(mouse|pointer)out$/.test(type)) {
                var elWindow    = doc.defaultView || doc.parentWindow;
                var cursorX     = options.clientX;
                var cursorY     = options.clientY;

                // Potentially we're interacting with an element inside a nested frame, which means the coordinates are local to that frame
                if (elWindow !== global) {
                    var offsets = this.$(elWindow.frameElement).offset();

                    cursorX     += offsets.left;
                    cursorY     += offsets.top;
                }

                if (!options.doNotUpdateCurrentPosition) {
                    // TODO should be moved to `simulateEvent` (and set right before the `dispatchEvent` call)
                    this.currentPosition[ 0 ]   = cursorX;
                    this.currentPosition[ 1 ]   = cursorY;
                }
            }

            return event;
        },


        prepareMouseEventOptions : function (type, options, el) {
            var global      = this.global

            options         = $.extend({
                bubbles     : !/(ms)?(mouse|pointer)enter/i.test(type) && !/(ms)?(mouse|pointer)leave/i.test(type),
                cancelable  : !/(ms)?(mouse|pointer)move/i.test(type),
                view        : global,
                detail      : 0,

                screenX     : 0,
                screenY     : 0,

                ctrlKey     : false,
                altKey      : false,
                shiftKey    : false,
                metaKey     : false,

                /*
                 * https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button
                 *
                 * A number representing a given button:

                 0: Main button pressed, usually the left button or the un-initialized state
                 1: Auxiliary button pressed, usually the wheel button or the middle button (if present)
                 2: Secondary button pressed, usually the right button
                 3: Fourth button, typically the Browser Back button
                 4: Fifth button, typically the Browser Forward button

                 * */
                button          : 0,
                /*
                 * https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons
                 *
                 * 0  : No button or un-initialized
                 * 1  : Left button
                 * 2  : Right button
                 * 4  : Wheel button or middle button
                 * 8  : 4th button (typically the "Browser Back" button)
                 * 16 : 5th button (typically the "Browser Forward" button)
                 *
                 * */
                buttons         : 0,
                relatedTarget   : undefined,

                // pointerType
                // NOTE: this has to be set to "mouse" (IE11) or 4 (IE10, 11) because otherwise
                // ExtJS5 blocks the event
                // need to investigate what happens in SenchaTouch
                pointerType     : bowser.msie ? 4 : 'mouse'

            }, options);

            if (!("clientX" in options) || !("clientY" in options)) {
                var center          = this.test.findCenter(el);

                options.clientX     = center[ 0 ]
                options.clientY     = center[ 1 ]
            }

            options.clientX         = Math.round(options.clientX)
            options.clientY         = Math.round(options.clientY)

            // edge seems to incorrectly calculate pageX/pageY, providing explicitly
            if (this.bowser.msedge && (!("pageX" in options) || !("pageY" in options))) {
                options.pageX       = this.viewportXtoPageX(options.clientX)
                options.pageY       = this.viewportYtoPageY(options.clientY)
            }

            // Not supported in IE
            if ("screenX" in window) {
                options.screenX     = Math.round(global.screenX + options.clientX)
                options.screenY     = Math.round(global.screenY + options.clientY)
            }

            return options
        },


        simulateMouseMove : function (x, y, options, params) {
            var me              = this

            params              = params || {}

            var pathBatchSize   = params.pathBatchSize
            var async           = params.async
            var mouseMovePrecision = params.mouseMovePrecision

            if (params.moveKind == 'instant') {
                pathBatchSize           = 10000
                mouseMovePrecision      = 10000
            }

            return this.movePointerTemplate({
                xy              : this.currentPosition,
                xy2             : [ x, y ],
                options         : options,

                overEls         : this.overEls,
                interval        : async !== false ? this.dragDelay : 0,
                callbackDelay   : async !== false ? 50 : 0,
                pathBatchSize   : pathBatchSize || me.pathBatchSize,
                mouseMovePrecision : mouseMovePrecision || me.mouseMovePrecision,

                onVoidOverEls   : function () {
                    return me.overEls  = []
                },

                onPointerEnter  : function (el, options) {
                    me.onPointerEnter(el, options)
                },

                onPointerLeave  : function (el, options) {
                    me.onPointerLeave(el, options)
                },

                onPointerOver   : function (el, options) {
                    me.onPointerOver(el, options)
                },

                onPointerOut    : function (el, options) {
                    me.onPointerOut(el, options)
                },

                onPointerMove   : function (el, options) {
                    me.onPointerMove(el, options)
                }
            })
        },

        // xy, xy2, overEls, pathBatchSize, interval, callbackDelay, options,
        // onPointerEnter, onPointerLeave, onPointerOver, onPointerOut, onPointerMove
        movePointerTemplate: function (args) {
            var document    = this.global.document,
                me          = this,
                overEls     = args.overEls,
                // Remember last visited element, since a previous action may have changed the DOM
                // which possibly should trigger a mouseout event
                lastOverEl  = overEls[ overEls.length - 1 ];

            if (lastOverEl && this.nodeIsUnloaded(lastOverEl)) {
                lastOverEl  = null
                overEls     = args.onVoidOverEls()
            }

            // this method works as follows:
            // `path` - contains in array of points
            // we split that array into batches with size - `pathBatchSize`, but, each batch can't be less than `mouseMovePrecision`
            // every batch is processed by one queue step (see below), so for every batch there's one call to `processor`
            // inside the processor, there's a loop, which iterates the batch with the delta, equal to `mouseMovePrecision`,
            // but no less than 1st and last point

            // always simulate drag with 1px precision
            var mouseMovePrecision  = me.mouseState == 'down' ? me.mouseDragPrecision : args.mouseMovePrecision || me.mouseMovePrecision
            var pathBatchSize       = Math.max(args.pathBatchSize, mouseMovePrecision)
            var options             = args.options || {}
            var supports            = Siesta.Project.Browser.FeatureSupport().supports

            var path        = this.getPathBetweenPoints(args.xy, args.xy2);

            var queue       = new Siesta.Util.Queue({
                deferer         : this.test.originalSetTimeout,
                deferClearer    : this.test.originalClearTimeout,

                interval        : args.interval,
                callbackDelay   : args.callbackDelay,

                observeTest     : this.test,

                processor       : function (data, index) {
                    var fromIndex   = data.sourceIndex,
                        toIndex     = data.targetIndex,
                        info,
                        x,
                        y,
                        visitPoint  = function (point) {
                            info        = me.elementFromPoint(point[ 0 ], point[ 1 ], false, null, true);

                            // targetEl will possibly be from the nested iframe
                            // and `localXY in `info` will contain local viewport point for `x, y` in that iframe
                            var targetEl    = info.el

                            // Might get null if moving over a non-initialized frame (seen in Chrome)
                            if (!targetEl) return

                            x           = info.localXY[ 0 ]
                            y           = info.localXY[ 1 ]

                            if (targetEl !== lastOverEl) {
                                me.onElementAtCursorChanged(targetEl, lastOverEl, x, y, options);
                                lastOverEl = targetEl;
                            }

                            args.onPointerMove(targetEl, $.extend({ clientX : x, clientY : y }, options), j < toIndex)
                        };

                    // replace 0 with 1 to avoid infinite loop
                    var delta       = Math.min(toIndex - fromIndex, mouseMovePrecision) || 1

                    for (var j = fromIndex; j <= toIndex; j += delta) {
                        var point = path[ j ];
                        visitPoint(point);
                    }

                    // Absolutely vital that we visit the final point of the path,
                    // which can be missed above with different combinations pathBatchSize and mouseMovePrecision
                    if (j >= path.length && point !== path[path.length - 1]) {
                        point = visitPoint(path[path.length - 1]);
                    }

                    // check again if the PointerMove simulation triggered a change of the element at the cursor
                    // and process it if needed
                    if (point) {
                        info        = me.elementFromPoint(point[ 0 ], point[ 1 ], false, null, true);

                        if (info.el && info.el !== lastOverEl) {
                            me.onElementAtCursorChanged(info.el, lastOverEl, x, y, options);
                        }
                    }
                    // eof for
                }
            });

            var pathLength = path.length

            if (pathLength <= pathBatchSize && mouseMovePrecision >= pathBatchSize) {
                // special case, when only the 1st and last points of the path will simulate mouse events
                // in this case, we want to simulate the events for *two* initial and *two* final points
                // so that in the begining and at the end of the path simulation is more accurate
                queue.addStep({
                    sourceIndex : 0,
                    targetIndex : Math.min(1, pathLength - 1)
                });

                if (pathLength >= 3)
                    queue.addStep({
                        sourceIndex : pathLength - 2,
                        targetIndex : pathLength - 1
                    })
            } else
                for (var i = 0, l = pathLength; i < l; i += pathBatchSize) {
                    queue.addStep({
                        sourceIndex : i,
                        targetIndex : Math.min(i + pathBatchSize - 1, pathLength - 1)
                    });
                }

            queue.addStep({
                processor : function () {
                    me.afterMouseInteraction()
                }
            });

            return new Promise(function (resolve, reject) {
                queue.run(resolve)
            })
        },


        onPointerEnter : function (el, options) {
            var me                    = this;
            var supportsPointerEvents = Siesta.Project.Browser.FeatureSupport().supports.PointerEventsGeneric

            if (supportsPointerEvents) me.simulateEvent(el, "pointerenter", options)
            me.simulateEvent(el, "mouseenter", options)
        },


        onPointerLeave : function (el, options) {
            var me                    = this;
            var supportsPointerEvents = Siesta.Project.Browser.FeatureSupport().supports.PointerEventsGeneric

            if (supportsPointerEvents) me.simulateEvent(el, "pointerleave", options)
            me.simulateEvent(el, "mouseleave", options)
        },


        onPointerOver : function (el, options) {
            var me                    = this;
            var supportsPointerEvents = Siesta.Project.Browser.FeatureSupport().supports.PointerEventsGeneric

            if (supportsPointerEvents) me.simulateEvent(el, "pointerover", options)
            me.simulateEvent(el, "mouseover", options)
        },


        onPointerOut : function (el, options) {
            var me                    = this;
            var supportsPointerEvents = Siesta.Project.Browser.FeatureSupport().supports.PointerEventsGeneric

            if (supportsPointerEvents) me.simulateEvent(el, "pointerout", options)
            me.simulateEvent(el, "mouseout", options)
        },


        onPointerMove : function (el, options) {
            var me                    = this;
            var supportsPointerEvents = Siesta.Project.Browser.FeatureSupport().supports.PointerEventsGeneric

            options.buttons = me.mouseState == 'up' ? 0 : 1

            if (supportsPointerEvents) me.simulateEvent(el, "pointermove", options)
            me.simulateEvent(el, "mousemove", options)
        },


        onElementAtCursorChanged : function (targetEl, lastOverEl, clientX, clientY, options) {
            var me       = this,
                supports = Siesta.Project.Browser.FeatureSupport().supports,
                overEls  = me.overEls;

            if (lastOverEl && !me.nodeIsOrphan(lastOverEl) && !me.nodeIsUnloaded(lastOverEl)) {
                me.onPointerOut(lastOverEl, $.extend({
                    clientX       : clientX,
                    clientY       : clientY,
                    relatedTarget : targetEl
                }, options))
            }

            for (var i = overEls.length - 1; i >= 0; i--) {
                var el = overEls[ i ];

                if (me.nodeIsUnloaded(el) || me.nodeIsOrphan(el))
                    overEls.splice(i, 1);
                else if (el !== targetEl && me.$(el).has(targetEl).length === 0) {
                    if (supports.mouseEnterLeave) {
                        me.onPointerLeave(el, $.extend({
                            clientX       : clientX,
                            clientY       : clientY,
                            relatedTarget : targetEl
                        }, options))
                    }
                    overEls.splice(i, 1);
                }
            }

            // "mouseover" should be simulated before "mouseleave"
            me.onPointerOver(targetEl, $.extend({
                clientX       : clientX,
                clientY       : clientY,
                relatedTarget : lastOverEl
            }, options))

            if (supports.mouseEnterLeave && jQuery.inArray(targetEl, overEls) == -1) {
                var els          = []
                var docEl        = targetEl.ownerDocument.documentElement
                var mouseEnterEl = targetEl

                // collecting all the els for which to fire the "mouseenter" event, strictly speaking these can be any elements
                // (because of absolute positioning) but in most cases it will be just parent elements
                while (mouseEnterEl && mouseEnterEl != docEl) {
                    els.unshift(mouseEnterEl)
                    mouseEnterEl = mouseEnterEl.parentNode
                }

                for (var i = 0; i < els.length; i++) {
                    if (jQuery.inArray(els[ i ], overEls) == -1) {
                        me.onPointerEnter(els[ i ], $.extend({
                            clientX       : clientX,
                            clientY       : clientY,
                            relatedTarget : lastOverEl
                        }, options))

                        overEls.push(els[ i ]);
                    }
                }
            }
        },


        // Check if the mouse interaction triggered a DOM update causing the last interacted element to be removed from the DOM
        // In this case we should simulate a new 'mouseover' event on whatever appeared under the cursor.
        afterMouseInteraction : function() {
            // var overEls         = this.overEls,
            //     lastOverEl      = overEls[ overEls.length - 1 ]
            //
            // //URL might have changed, then ignore
            // if (!this.global.document.body) return;
            //
            // if (lastOverEl&&this.nodeIsUnloaded(lastOverEl)) {
            //     lastOverEl  = null
            //     this.overEls = []
            //
            //     //after page reload we want to simulate the `mouseover`
            //     //for the element appeared at the current cursor position
            //     this.mouseOver(this.currentPosition);
            // }
        },


        simulateMouseDown: function (clickInfo, options) {
            var supportsPointerEvents   = Siesta.Project.Browser.FeatureSupport().supports.PointerEventsGeneric

            return this.processMouseActionSteps(
                clickInfo,
                options,
                [
                    supportsPointerEvents ?
                        { event : "pointerdown", interval : 0 }
                    :
                        null,
                    { event : "mousedown", focus : true }
                ]
            );
        },


        simulateMouseUp: function (clickInfo, options) {
            var el                    = clickInfo.el;
            // Should only happen if parent el of the mousedown/up events are the same
            var targetChanged         = this.lastMouseDownEl && el !== this.lastMouseDownEl && !($.contains(el, this.lastMouseDownEl) || $.contains(this.lastMouseDownEl, el));
            var shouldFireClick       = !targetChanged || !(this.bowser.safari || this.bowser.gecko);
            var supportsPointerEvents = Siesta.Project.Browser.FeatureSupport().supports.PointerEventsGeneric

            return this.processMouseActionSteps(
                clickInfo,
                options,
                [
                    supportsPointerEvents ?
                        { event : "pointerup", interval : 0 }
                    :
                        null,
                    { event : "mouseup" }
                ].concat(shouldFireClick ?
                    [
                        { event : "click" }
                    ] :
                    []
                )
            );
        },

        // private, should not be used in tests
        mouseOver: function (el, options) {
            var info        = this.test.getNormalizedTopElementInfo(el, true);

            if (!info) return;

            options         = options || {}

            options.clientX = options.clientX != null ? options.clientX : info.localXY[0];
            options.clientY = options.clientY != null ? options.clientY : info.localXY[1];

            var supportsPointerEvents   = Siesta.Project.Browser.FeatureSupport().supports.PointerEventsGeneric

            if (supportsPointerEvents) this.simulateEvent(el, 'pointerover', options);
            this.simulateEvent(el, 'mouseover', options);
        },


        // private, should not be used in tests
        mouseOut: function (el, options) {
            var info        = this.test.getNormalizedTopElementInfo(el, true);

            if (!info) return;

            options         = options || {}

            options.clientX = options.clientX != null ? options.clientX : info.localXY[0];
            options.clientY = options.clientY != null ? options.clientY : info.localXY[1];

            var supportsPointerEvents   = Siesta.Project.Browser.FeatureSupport().supports.PointerEventsGeneric

            if (supportsPointerEvents) this.simulateEvent(el, 'pointerout', options);
            this.simulateEvent(el, 'mouseout', options);
        },


        processMouseActionSteps : function (clickInfo, options, steps) {
            // trying to get the top element again, enabling the warning if needed
            // do it here and not in the `genericMouseAction` method to allow scenario
            // when target element appears when mouse moves to the click point
            if (clickInfo.originalEl && this.enableUnreachableClickWarning) {
                this.test.getNormalizedTopElementInfo(clickInfo.originalEl, false, clickInfo.method, clickInfo.offset)
            }

            var me          = this

            var x           = clickInfo.globalXY[ 0 ]
            var y           = clickInfo.globalXY[ 1 ]
            var isOption    = clickInfo.el.nodeName.toLowerCase() === 'option';

            var doc         = me.global.document

            var prevScrollTop   = this.getPageScrollY()

            // re-evaluate the target el - it might have changed while we were syncing the cursor position
            var target       = isOption ? clickInfo.el : me.elementFromPoint(x, y, false, clickInfo.el)
            var targetParent = target.parentNode;

            var targetHasChanged    = false

            var queue       = new Siesta.Util.Queue({
                deferer         : this.test.originalSetTimeout,
                deferClearer    : this.test.originalClearTimeout,

                interval        : 10,
                callbackDelay   : me.afterActionDelay,

                observeTest     : this.test,

                processor       : function (data) {
                    if (me.lastPointerDownPrevented && /mouse/i.test(data.event)) return

                    // XXX this has to be investigated more deeply (notably the <body> vs <html> scrolling, etc)
                    // - When simulating events browser performs weird scrolls on the document.
                    // Seems it tries to make the point of simulated event visible on the screen.
                    // This is native browser behavior out of our control.
                    // Thing is, when the document is scrolled, `elementFromPoint` returns different
                    // element for the same point. Because of that the logic for clicks is vulnerable.
                    // Scenario is - "mousedown" (or may be "mouseup") is simulated, scroll position changes
                    // further "click" event happens on different element

                    // body can be absent if the doubleclick happens on the anchor and page is reloaded in the middle
                    // of double click
                    var delta       = doc.body ? me.getPageScrollY() - prevScrollTop : 0
                    var elAtCursor  = isOption ? target : me.elementFromPoint(x, y - delta, false, target)
                    var fireEl      = elAtCursor;

                    if (!isOption && data.recaptureTarget) { target = elAtCursor; targetHasChanged = false }

                    // The "click" event should be canceled if "mousedown/up" happened on different elements,
                    // _unless_ these elements has parent/child relationship
                    if (!isOption && elAtCursor !== target && !($.contains(elAtCursor, target) || $.contains(target, elAtCursor))) targetHasChanged = true

                    // Special treatment of click event firing:
                    // * Don't fire click if a node was moved in the DOM tree, or if was orphaned
                    // * Chrome + IE fires click on the common ancestor of mousedown target + mouseup target after drag drop
                    if (!isOption && data.event === 'click') {
                        var nodeMovedInDomTree = elAtCursor === target && elAtCursor.parentNode !== targetParent;

                        // Don't fire click if a node was moved in the DOM tree, or if target or mouseDown target was orphaned
                        // or if mouseDownElement !== mouseUpElement
                        if (nodeMovedInDomTree || me.nodeIsOrphan(target) || (me.lastMouseDownEl && me.nodeIsOrphan(me.lastMouseDownEl))) return;

                        var mouseDownUpTargetsChanged;

                        // Check if mousedownElement differs from what is at cursor
                        if (
                            me.lastMouseDownEl && elAtCursor !== me.lastMouseDownEl
                            && !($.contains(elAtCursor, me.lastMouseDownEl) || $.contains(me.lastMouseDownEl, elAtCursor))
                        ) {
                            mouseDownUpTargetsChanged   = true;
                            fireEl                      = me.getCommonAncestor(elAtCursor, me.lastMouseDownEl);

                            // Also check if mouseupElement differs from what is at cursor
                        } else
                            if (
                                me.lastMouseUpEl && me.lastMouseUpEl !== elAtCursor && !($.contains(elAtCursor, me.lastMouseUpEl))
                            ) {

                                mouseDownUpTargetsChanged   = true;
                                fireEl                      = me.getCommonAncestor(elAtCursor, me.lastMouseUpEl);
                            }

                        // When target changed, Chrome + IE fires click on the common ancestor after drag drop
                        if (mouseDownUpTargetsChanged) {
                            if (me.bowser.gecko || me.bowser.safari) {
                                // Safari + FF does not fire click on the common ancestor after drag drop
                                return;
                            } else {
                                // mouseDown/mouseUp happened in 2 different frames?
                                if (!fireEl) return;
                            }
                        }
                    }

                    if (targetHasChanged && data.cancelIfTargetChanged) {
                        return;
                    }

                    var event       = me.simulateEvent(fireEl, data.event, options);

                    if (!me.lastPointerDownPrevented && data.focus) {
                        me.mimicFocusOnMouseDown(elAtCursor, event);
                    }

                    if (!isOption) {
                        // Check if this event triggered another element to be visible at cursor, if so handle pointerleave/mouseleave.
                        var elementAtPoint = me.elementFromPoint(x, y - delta, false, target);

                        if (elementAtPoint !== elAtCursor) {
                            me.onElementAtCursorChanged(elementAtPoint, elAtCursor, x, y - delta, options);
                        }
                    }
                }
            })

            Joose.A.each(steps, function (step) {
                step && queue.addStep(step)
            })

            return new Promise(function (resolve, reject) {
                queue.run(function () {
                    me.afterMouseInteraction();

                    resolve()
                })
            })
        },


        // private
        simulateMouseClick: function (clickInfo, options) {
            var supportsPointerEvents   = Siesta.Project.Browser.FeatureSupport().supports.PointerEventsGeneric

            return this.processMouseActionSteps(
                clickInfo,
                options,
                [
                    supportsPointerEvents ?
                        { event : "pointerdown", interval : 0 }
                    :
                        null,
                    { event : "mousedown", focus : true },

                    supportsPointerEvents ?
                        { event : "pointerup", interval : 0 }
                    :
                        null,
                    { event : "mouseup", interval : 0 },

                    { event : "click", cancelIfTargetChanged : true }
                ]
            )
        },

        // private
        simulateRightClick: function (clickInfo, options) {
            // Mac doesn't fire mouseup when right clicking
            var isMac       = navigator.platform.indexOf('Mac') > -1;

            var supportsPointerEvents   = Siesta.Project.Browser.FeatureSupport().supports.PointerEventsGeneric

            options         = options || {};
            options.button  = options.buttons  = 2;

            return this.processMouseActionSteps(
                clickInfo,
                options,
                [
                    supportsPointerEvents ?
                        { event : "pointerdown", interval : 0 }
                    :
                        null,
                    { event : "mousedown", focus : true }
                ].concat(isMac ? [] :
                    [
                        supportsPointerEvents ?
                            { event : "pointerup", interval : 0 }
                        :
                            null,
                        { event : "mouseup", interval : 0 }
                    ]
                ).concat(
                    [ { event : "contextmenu" } ]
                )
            )
        },

        // private
        simulateDoubleClick: function (clickInfo, options) {
            var supportsPointerEvents   = Siesta.Project.Browser.FeatureSupport().supports.PointerEventsGeneric

            return this.processMouseActionSteps(
                clickInfo,
                options,
                [
                    supportsPointerEvents ?
                        { event : "pointerdown", interval : 0 }
                    :
                        null,
                    { event : "mousedown", focus : true },

                    supportsPointerEvents ?
                        { event : "pointerup", interval : 0 }
                        :
                        null,
                    { event : "mouseup", interval : 0 },

                    { event : "click", cancelIfTargetChanged : true },

                    supportsPointerEvents ?
                        { event : "pointerdown", interval : 0 }
                        :
                        null,
                    { event : "mousedown", recaptureTarget : true, focus : true },

                    supportsPointerEvents ?
                        { event : "pointerup", interval : 0 }
                        :
                        null,
                    { event : "mouseup", interval : 0 },

                    { event : "click" , cancelIfTargetChanged : true, interval : 0 },
                    { event : "dblclick" , cancelIfTargetChanged : true }
                ]
            )
        },


        // private
        mimicFocusOnMouseDown : function (el, mouseDownEvent) {
            // only do focus if `mousedown` event is not prevented by outside world
            if (this.isEventPrevented(mouseDownEvent)) return;

            var test        = this.test

            // if we've clicked text input element just do regular focus
            if (test.isElementFocusable(el)) {
                test.focus(el, true)
                return
            }

            var doc         = el.ownerDocument
            var win         = doc.defaultView || doc.parentWindow
            var body        = doc.body

            if (!body) return;

            // otherwise focus the nearest parent with non-null `tabIndex` attribute
            // as an edge case an "<html> element can be clicked
            while (el && el != body && el != doc) {
                // IE-specific: don't look up the parent nodes when clicked an element with "unselectable" attribute set to "on"
                // and do not focus the body
                // "unselectable" attr should not be used to determine focusability state
                if (bowser.msie && el.getAttribute('unselectable') == 'on') return

                if (test.isElementFocusable(el)) {
                    test.focus(el, true)
                    return
                }

                el          = el.parentNode
            }

            // focus body as the last resort to trigger the "blur" event on the currently focused element
            test.focus(body || doc.documentElement, true)
        },


        simulateMouseWheel : function (targetInfo, options) {
            var eventName   = 'wheel';
            var doc         = targetInfo.el.ownerDocument;

            // For legacy browsers where we don't use dispatchEvent, fallback to 'mousewheel' event ('wheel' cannot be simulated with doc.createEventObject in <= IE9)
            if (!doc.createEvent || this.getSimulateEventsWith() !== 'dispatchEvent') {
                eventName   = 'mousewheel';
            }

            return this.processMouseActionSteps(
                targetInfo,
                options,
                [
                    { event : eventName }
                ]
            );
        },


        // private
        getPathBetweenPoints: function (from, to) {
            if (
                typeof from[0] !== 'number' ||
                typeof from[1] !== 'number' ||
                typeof to[0] !== 'number'   ||
                typeof to[1] !== 'number'   ||
                isNaN(from[0])              ||
                isNaN(from[1])              ||
                isNaN(to[0])                ||
                isNaN(to[1])
            ) {
                throw new Error('Incorrect arguments passed to getPathBetweenPoints: ' + from + ', ' + to);
            }

            var stops = [],
                x0 = Math.floor(from[0]),
                x1 = Math.floor(to[0]),
                y0 = Math.floor(from[1]),
                y1 = Math.floor(to[1]),
                dx = Math.abs(x1 - x0),
                dy = Math.abs(y1 - y0),
                sx, sy, err, e2;

            if (x0 < x1) {
                sx = 1;
            } else {
                sx = -1;
            }

            if (y0 < y1) {
                sy = 1;
            } else {
                sy = -1;
            }
            err = dx - dy;

            while (x0 !== x1 || y0 !== y1) {
                e2 = 2 * err;
                if (e2 > -dy) {
                    err = err - dy;
                    x0 = x0 + sx;
                }

                if (e2 < dx) {
                    err = err + dx;
                    y0 = y0 + sy;
                }
                stops.push([x0, y0]);
            }

            var last = stops[stops.length-1];

            if (stops.length > 0 && (last[0] !== to[0] || last[1] !== to[1])) {
                // the points of the path can be modified in the move mouse method - thus pushing a copy
                // of the original target
                stops.push(to.slice());
            }
            return stops;
        }
    }
});
;
/**
@class Siesta.Test.UserAgent.KeyCodes
@singleton

This is a singleton class, containing the mnemonical names for various advanced key codes. You can use this names in the {@link Siesta.Test.Browser#type} method, like this:

    t.type(el, 'Foo bar[ENTER]', function () {
        ...
    })

Below is the full list:

 - `BACKSPACE`

 - `TAB`

 - `ENTER` (`RETURN`)
 - `SPACE`

 - `SHIFT`
 - `CTRL`
 - `ALT`

 - `PAUSE-BREAK`
 - `CAPS`
 - `ESCAPE` (`ESC`)
 - `NUM-LOCK`
 - `SCROLL-LOCK`
 - `PRINT`

 - `PAGE-UP`
 - `PAGE-DOWN`
 - `END`
 - `HOME`
 - `LEFT`
 - `UP`
 - `RIGHT`
 - `DOWN`
 - `INSERT`
 - `DELETE`


 - `NUM0`
 - `NUM1`
 - `NUM2`
 - `NUM3`
 - `NUM4`
 - `NUM5`
 - `NUM6`
 - `NUM7`
 - `NUM8`
 - `NUM9`

 - `F1`
 - `F2`
 - `F3`
 - `F4`
 - `F5`
 - `F6`
 - `F7`
 - `F8`
 - `F9`
 - `F10`
 - `F11`
 - `F12`

 */
Singleton('Siesta.Test.UserAgent.KeyCodes', {

    methods : {

        isNav : function (k) {
            var keys = this.keys

            return (k >= 33 && k <= 40) ||
                k == keys.RETURN ||
                k == keys.TAB ||
                k == keys.ESCAPE;
        },

        isSpecial : function (k) {

            return k === this.keys.BACKSPACE ||
                (k >= 16 && k <= 20) ||
                (k >= 44 && k <= 46) ||
                (k >= 112 && k <= 123) ||
                k === 91;
        },

        isModifier : function(k) {
            return k === this.keys.SHIFT ||
                   k === this.keys.CTRL ||
                   k === this.keys.ALT ||
                   k === this.keys.CMD; // TODO add check to make sure it's a Mac?
        },

        fromCharCode : function (code, readableForm) {
            var keys    = this.keys

            for (var key in keys) if (keys[ key ] === code && (!readableForm || key.length > 1)) return key;
        }
    },

    has : {
        // FROM Syn library by JupiterJS, MIT License. www.jupiterjs.com

        // key codes
        keys : {

            init : {
                //backspace
                '\b'            : 8,
                'BACKSPACE'     : 8,

                //tab
                '\t'            : 9,
                'TAB'           : 9,

                //enter
                '\r'            : 13,
                'RETURN'        : 13,
                'ENTER'         : 13,
                'SPACE'         : 32,

                //special
                'SHIFT'         : 16,
                'CTRL'          : 17,
                'ALT'           : 18,
                'CMD'           : 91, // Mac

                //weird
                'PAUSE-BREAK'   : 19,
                'CAPS'          : 20,
                'ESCAPE'        : 27,
                'ESC'           : 27,
                'NUM-LOCK'      : 144,
                'SCROLL-LOCK'   : 145,
                'PRINT'         : 44,

                //navigation
                'PAGE-UP'       : 33,
                'PAGEUP'        : 33,
                'PAGE-DOWN'     : 34,
                'PAGEDOWN'      : 34,
                'END'           : 35,
                'HOME'          : 36,
                'LEFT'          : 37,
                'ARROWLEFT'     : 37,
                'UP'            : 38,
                'ARROWUP'       : 38,
                'RIGHT'         : 39,
                'ARROWRIGHT'    : 39,
                'DOWN'          : 40,
                'ARROWDOWN'     : 40,
                'INSERT'        : 45,
                'DELETE'        : 46,

                //normal characters
                ' '             : 32,
                '0'             : 48,
                '1'             : 49,
                '2'             : 50,
                '3'             : 51,
                '4'             : 52,
                '5'             : 53,
                '6'             : 54,
                '7'             : 55,
                '8'             : 56,
                '9'             : 57,
                'A'             : 65,
                'B'             : 66,
                'C'             : 67,
                'D'             : 68,
                'E'             : 69,
                'F'             : 70,
                'G'             : 71,
                'H'             : 72,
                'I'             : 73,
                'J'             : 74,
                'K'             : 75,
                'L'             : 76,
                'M'             : 77,
                'N'             : 78,
                'O'             : 79,
                'P'             : 80,
                'Q'             : 81,
                'R'             : 82,
                'S'             : 83,
                'T'             : 84,
                'U'             : 85,
                'V'             : 86,
                'W'             : 87,
                'X'             : 88,
                'Y'             : 89,
                'Z'             : 90,

                //NORMAL-CHARACTERS, NUMPAD
                'NUM0'          : 96,
                'NUM1'          : 97,
                'NUM2'          : 98,
                'NUM3'          : 99,
                'NUM4'          : 100,
                'NUM5'          : 101,
                'NUM6'          : 102,
                'NUM7'          : 103,
                'NUM8'          : 104,
                'NUM9'          : 105,
                '*'             : 106,
                '+'             : 107,

                //normal-characters, others
                ';'             : 186,
                '='             : 187,
                ','             : 188,
                '-'             : 189,
                '.'             : 190,
                '/'             : 191,
                '`'             : 192,
                '['             : 219,
                '\\'            : 220,
                ']'             : 221,
                "'"             : 222,

                'F1'            : 112,
                'F2'            : 113,
                'F3'            : 114,
                'F4'            : 115,
                'F5'            : 116,
                'F6'            : 117,
                'F7'            : 118,
                'F8'            : 119,
                'F9'            : 120,
                'F10'           : 121,
                'F11'           : 122,
                'F12'           : 123
            }
        },
        // eof key codes

        // key names // https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values
        keyNameMap : {

            init : {
                //backspace
                '8'             : 'Backspace',
                '9'             : 'Tab',

                //enter
                '13'            : 'Enter',

                //space
                '32'            : 'Space',

                //special
                '16'            : 'Shift',
                '17'            : 'Control',
                '18'            : 'Alt',
                '91'            : 'Meta', // Mac Cmd

                '20'            : 'CapsLock',
                '27'            : 'Escape',
                '144'           : 'NumLock',
                '145'           : 'ScrollLock',
                '44'            : 'Print',

                //navigation
                '33'            : 'PageUp',
                '34'            : 'PageDown',
                '35'            : 'End',
                '36'            : 'Home',
                '37'            : 'ArrowLeft',
                '38'            : 'ArrowUp',
                '39'            : 'ArrowRight',
                '40'            : 'ArrowDown',
                '45'            : 'Insert',
                '46'            : 'Delete',

                '106'           : 'Multiply',
                '107'           : 'Add',

                '112'           : 'F1',
                '113'           : 'F2',
                '114'           : 'F3',
                '115'           : 'F4',
                '116'           : 'F5',
                '117'           : 'F6',
                '118'           : 'F7',
                '119'           : 'F8',
                '120'           : 'F9',
                '121'           : 'F10',
                '122'           : 'F11',
                '123'           : 'F12'
            }
        }
        // eof key names
    }
    // eof has
});
;
Role('Siesta.Test.Simulate.Keyboard', {

    requires        : [
        '$',
        'simulateEvent', 'isEventPrevented'
        /*'getSimulateEventsWith', 'getElementAtCursor'*/
    ],

    does : [
        Siesta.Util.Role.CanFormatStrings,
        Siesta.Test.Browser.Role.CanWorkWithKeyboard
    ],

    has : {
                                 // For "KeyboardEvent" only Firefox set values for deprecated keyCode/charCode, Chrome just sets them to 0
        keyboardEventName       : ("KeyboardEvent" in window && bowser.gecko) ? "KeyboardEvent" : ("KeyEvent" in window ? "KeyEvents" : null)
    },

    methods: {

        // TODO switch fully to KeyboardEvent https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/KeyboardEvent
        // private
        createKeyboardEvent: function (type, options, el) {
            var event;
            var doc = el.ownerDocument,
                global = this.global;

            options = $.extend({
                bubbles    : true,
                cancelable : true,
                view       : this.global,
                ctrlKey    : false,
                altKey     : false,
                shiftKey   : false,
                metaKey    : false,
                keyCode    : 0,
                charCode   : 0,
                key        : options.key || ''
            }, options);

            // use W3C standard when available and allowed by "simulateEventsWith" option
            if (doc.createEvent && this.getSimulateEventsWith() == 'dispatchEvent') {
                try {
                    if (this.keyboardEventName === 'KeyboardEvent') {
                        event = new KeyboardEvent(type, options);
                    }
                } catch (err) {
                    event = null;
                }

                if (!event) {
                    event = doc.createEvent("Events");
                    event.initEvent(type, options.bubbles, options.cancelable);

                    $.extend(event, {
                        view     : options.view,
                        ctrlKey  : options.ctrlKey,
                        altKey   : options.altKey,
                        shiftKey : options.shiftKey,
                        metaKey  : options.metaKey,
                        keyCode  : options.keyCode,
                        charCode : options.charCode,
                        key      : options.key || '',
                        code     : options.code
                    });
                }
            } else if (doc.createEventObject) {
                event = doc.createEventObject();
                $.extend(event, options);
            }

            if (bowser.msie || bowser.opera) {
                event.keyCode = (options.charCode > 0) ? options.charCode : options.keyCode;
                event.charCode = undefined;
            }

            return event;
        },

        // private
        createTextEvent: function (type, options, el) {
            var doc         = el.ownerDocument;
            var event       = null;

            // only for Webkit / IE for now
            if (doc.createEvent) {
                try {
                    event = doc.createEvent('TextEvent');

                    if (event && event.initTextEvent) {
                        event.initTextEvent(
                            type,
                            true,
                            true,
                            this.global,
                            options.text,
                            // IE ONLY below here
                            0,
                            window.navigator.userLanguage || window.navigator.language
                        );
                        return event;
                    }
                }
                catch(e) {}
            }

            return null;
        },


        /*!
         * Based on:
         *
         * @license EmulateTab
         * Copyright (c) 2011, 2012 The Swedish Post and Telecom Authority (PTS)
         * Developed for PTS by Joel Purra <http://joelpurra.se/>
         * Released under the BSD license.
         *
         * A jQuery plugin to emulate tabbing between elements on a page.
         */
        findNextFocusable : function (el, offset) {
            var $el         = this.$(el)

            var $focusable  = this.$(":focus, :input, a[href], [tabindex], body", el.ownerDocument)
                .not(":disabled")
                .not(":hidden")
                .not("a[href]:empty")


            var escapeSelectorName  = function (str) {
                // Based on http://api.jquery.com/category/selectors/
                // Still untested
                return str.replace(/(!"#$%&'\(\)\*\+,\.\/:;<=>\?@\[\]^`\{\|\}~)/g, "\\\\$1");
            }

            var isRadio     = false
            var selector

            if (el.tagName === "INPUT" && el.type === "radio" && el.name !== "" ) {
                isRadio     = true
                selector    = "input[type=radio][name=" + escapeSelectorName(el.name) + "]"
            }

            var processed       = []

            for (var i = 0; i < $focusable.length; i++) {
                var currEl      = $focusable[ i ]

                // always include current element
                if (currEl != el && currEl.getAttribute('tabIndex') == -1 || isRadio && $(currEl).is(selector)) continue

                processed.push(currEl)
            }

            var body                = el.ownerDocument.body
            var currentTabIndex     = el.getAttribute('tabIndex')

            var getTabIndex         = function (dom) {
                if (dom == el && currentTabIndex == -1) return 0

                if (dom == body) return 0

                return dom.getAttribute('tabIndex') || 0
            }

            processed.sort(function (a, b) {
                var aIndex      = getTabIndex(a)
                var bIndex      = getTabIndex(b)

                return aIndex < bIndex ? -1 : (aIndex > bIndex ? 1 : (a == body ? 1 : (b == body ? -1 : 0)))
            });

            var currentIndex    = $(processed).index($el);

            if (currentIndex == -1) return null

            return processed[ (currentIndex + offset) % processed.length ]
        },


        emulateTab : function (el, offset) {
            var next        = this.findNextFocusable(el, offset || 1)

            if (next)
                this.test.focus(next)
            else
                el.blur()

            return next
        },


        simulateType : function (text, options, params) {
            if (text == null) throw 'Must supply a string to type';

            var me          = this

            var el          = params.el

            if (el.disabled) {
                return Promise.resolve()
            }

            // Store initial value of text fields, updated after ENTER key press in ´keyPress´ method
            if ('value' in el) {
                el.setAttribute('__lastValue', el.value);
            }

            // Extract normal chars, or special keys in brackets such as [TAB], [RIGHT] or [ENTER]
            var keys        = this.extractKeysAndSpecialKeys(text + '');

            var queue       = new Siesta.Util.Queue({
                deferer         : this.test.originalSetTimeout,
                deferClearer    : this.test.originalClearTimeout,

                interval        : this.actionDelay,
                // this is 0, since user agent `type` method also contains queue with "callbackDelay"
                // so we don't need to double that (which also breaks 624_rerun_hotkey)
                callbackDelay   : 0,

                observeTest     : this.test,

                processor       : function (data, index) {
                    // 1. In IE10, it seems activeElement cannot be trusted as it sometimes returns an empty object with no properties.
                    // Try to detect this case and simply use the original el
                    // 2. If user clicks around in the project during ongoing test, the activeElement will be reset to BODY
                    // If this happens, reuse the original el and hope all is well
                    var focusedEl   = me.activeElement(true, el, el)

                    me.simulateKeyPress(focusedEl, data.key, options)
                }
            })

            // the `el` should be already focused in the `type` method of the "user agent" code,
            // still allow to focus it, but using special "param.focus"
            if (params.focus) {
                // Manually focus event to be typed into first
                queue.addStep({
                    processor       : function () {
                        if (!me.nodeIsOrphan(el)) me.focus(el)
                    }
                })

                // focus the element one more time for IE - this seems to fix the weird sporadic failures in 042_keyevent_simulation3.t.js
                // failures are caused by the field "blur" immediately after 1st focus
                // no Ext "focus/blur" methods seems to be called, so it can be a browser behavior
                bowser.msie && queue.addStep({
                    processor       : function () {
                        if (!me.nodeIsOrphan(el)) me.focus(el)
                    }
                })
            }

            Joose.A.each(keys, function (key, index) {
                key             = key.length == 1 ? key : key.substring(1, key.length - 1)

                keys[ index ]   = key

                queue.addStep({ key : key })
            });

            if (!el.readOnly && keys.length) {
                var KeyCodes        = Siesta.Test.UserAgent.KeyCodes().keys;
                var firstKeyCode    = KeyCodes[ keys[ 0 ].toUpperCase() ]

                if (this.isReadableKey(firstKeyCode)) {
                    // Some browsers (IE/FF) do not overwrite selected text, do it manually
                    // but only if the key is readable (some letter etc)
                    // do not clear the selection in case of special symbol
                    var selText     = this.test.getSelectedText(el);

                    if (selText && 'value' in el && 'selectionStart' in el) {
                        var caretPos;

                        try {
                            caretPos = el.selectionStart;
                        } catch(e) {}

                        if (caretPos != null) {
                            // mimic replacing selected text
                            this.silentSetValue(el, el.value.substr(0, caretPos) + el.value.substr(caretPos + selText.length), 'value')

                            // Now set caret position to start of selection range
                            this.test.setCaretPosition(el, caretPos);
                        }
                    }
                }
            }

            return new Promise(function (resolve, reject) {
                queue.run(resolve)
            })
        },


        simulateKeyPress: function (el, key, options) {
            var isMac           = bowser.mac;

            var KeyCodes        = Siesta.Test.UserAgent.KeyCodes().keys
            var keyNameMap      = Siesta.Test.UserAgent.KeyCodes().keyNameMap;
            var keyCode         = KeyCodes[ key.toUpperCase() ] || 0;
            var keyDownEl       = el = this.test.normalizeElement(el);

            options             = options || {};

            options.readableKey = key;

            // keypress should not be fired on Mac when CMD is pressed
            // nor on Windows when CTRL is pressed
            var suppressKeyPress = (isMac && options.metaKey) || (!isMac && options.ctrlKey);

            // Should not actually type anything when CTRL / CMD are pressed
            var isReadableKey   = this.isReadableKey(keyCode);
            var charCode        = isReadableKey && !suppressKeyPress ? key.charCodeAt(0) : 0

            options.key         = isReadableKey ? key : (keyNameMap[ keyCode ] || '');
            options.code        = keyNameMap[ keyCode ];

            var me              = this,
                isTextInput     = me.isTextInput(el),
                isEditableNode  = me.isEditableNode(el),
                acceptsTextInput = isTextInput || isEditableNode;

            var textValueProp       = 'value' in el ? 'value' : 'innerHTML';
            var originalLength      = el[ textValueProp ].length;

            var keyDownEvent        = me.simulateEvent(el, 'keydown', Joose.O.extend({ charCode : 0, keyCode : keyCode }, options));
            var keyDownPrevented    = this.isEventPrevented(keyDownEvent)

            var isSelection         = acceptsTextInput && this.mimicTextSelection(keyDownEvent, el);

            if (!isSelection) {
                var keyPressPrevented = false;
                var supports          = Siesta.Project.Browser.FeatureSupport().supports

                // Need to reevaluate focused element here, it may have changed in a 'keydown' listener
                el                  = me.activeElement(true, el, el);

                // keypress should not be fired when CTRL or CMD are pressed
                if (!suppressKeyPress && !keyDownPrevented) {
                    var event         = me.simulateEvent(el, 'keypress', Joose.O.extend({ charCode : charCode, keyCode : isReadableKey ? 0 : keyCode }, options));
                    keyPressPrevented = this.isEventPrevented(event)

                    if (!keyPressPrevented && keyCode === KeyCodes.TAB) {
                        el          = this.emulateTab(el, options.shiftKey ? -1 : 1) || el;
                    }
                }

                if (!keyDownPrevented && acceptsTextInput && keyCode != KeyCodes.TAB) {

                    if (isReadableKey && !suppressKeyPress && !keyPressPrevented) {
                        var innerHTML

                        // IE10 tries to be 'helpful' by inserting an empty space, clean it
                        // IE11 inserts <br> after call to the .focus() method of the element
                        if (isEditableNode && bowser.msie) {
                            innerHTML               = el.innerHTML

                            if (innerHTML.indexOf('&nbsp;') === 0) {
                                el.innerHTML        = innerHTML.substring(6)
                                originalLength      = el.innerHTML.length
                            } else
                                if (innerHTML.indexOf('<br>') === 0) {
                                    el.innerHTML    = innerHTML.substring(4);
                                    originalLength  = el.innerHTML.length
                                }
                        }

                        // IE won't do execCommand with insertText
                        if (isEditableNode && !bowser.msie) {
                            innerHTML           = el.innerHTML

                            if (innerHTML.charCodeAt(innerHTML.length - 1) === 8203) {
                                el.innerHTML    = innerHTML.substring(0, innerHTML.length - 1);
                            }
                            el.ownerDocument.execCommand('insertText', false, options.readableKey);
                        } else {
                             //TODO should check first if textInput event is supported
                            me.simulateEvent(el, bowser.msie ? 'textinput' : 'textInput', { text: options.readableKey });
                        }

                        // will fire 'input' event
                        me.mimicCharacterInsertion(el, key, options, originalLength);
                    } else {
                        me.mimicCaretMovement(el, keyCode);
                    }

                    // Manually delete one char off the end if backspace simulation is not supported by the browser
                    if (
                        (keyCode === KeyCodes.BACKSPACE || keyCode === KeyCodes.DELETE)
                        && !supports.canSimulateBackspace && el[ textValueProp ].length > 0
                    ) {
                        this.mimicCharacterDeletion(el, keyCode, options);
                    }

                    if (textValueProp === 'value' && keyCode === KeyCodes.ENTER && !keyPressPrevented) {
                        if (isTextInput) this.maybeMimicChangeEvent(keyDownEl);

                        if (!supports.enterSubmitsForm) {
                            this.mimicFormSubmit(el);
                        }
                    }
                }
            }

            this.mimicClickOnEnter(el, keyCode);

            me.simulateEvent(el, 'keyup', $.extend({ charCode : 0, keyCode : keyCode }, options));

            return Promise.resolve()
        },


        mimicCharacterInsertion : function (el, readableKey, options, originalLength) {
            var textValueProp   = 'value' in el ? 'value' : 'innerHTML';

            var maxLength       = el.getAttribute('maxlength') || Infinity
            var isTextInput     = this.isTextInput(el);
            var supports        = Siesta.Project.Browser.FeatureSupport().supports;

            if (maxLength != null) maxLength    = Number(maxLength)

            // If the entered char had no impact on the textfield - manually put it there
            if (
                !el.readOnly && (isTextInput || bowser.msie)
                && !supports.canSimulateKeyCharacters
                && originalLength === el[ textValueProp ].length && originalLength < maxLength
            ) {
                var val         = el[ textValueProp ];
                var caretPos    = this.test.getCaretPosition(el);

                // Fallback to appending text to end of string if caret position cannot be determined
                if (caretPos == undefined) {
                    caretPos    = val.length;
                }

                // Inject char at caret position
                this.silentSetValue(
                    el,
                    val.substr(0, caretPos) + readableKey + val.substr(caretPos),
                    textValueProp
                )

                // Restore caret position
                this.test.setCaretPosition(el, caretPos + 1);

                this.simulateEvent(el, 'input', options);
            }
        },


        // this method will change the property `propertyName` of the `el` to a `newValue`
        // if `propertyName` will be "value" it will try to avoid "touching" the actual "value"
        // property, since that may trigger side effects
        // if user has defined own "value" property on the element (React did that, crazy)
        silentSetValue : function (el, newValue, propetyName) {
            var Object      = this.global.Object

            if (Object.getOwnPropertyDescriptor && propetyName == 'value') {
                var desc    = Object.getOwnPropertyDescriptor(el.constructor.prototype, propetyName)

                desc.set.call(el, newValue)
            } else
                el[ propetyName ] = newValue;
        },


        mimicTextSelection : function(keyDownEvent, el) {
            var isMac       = bowser.mac;
            var KC          = Siesta.Test.UserAgent.KeyCodes().keys;

            var retVal      = false;

            // CTRL-A or CMD-A in text input should select all
            var ctrlKey     = (!isMac && keyDownEvent.ctrlKey) || (keyDownEvent.metaKey && isMac);

            switch (keyDownEvent.keyCode) {
                // Select all
                case KC["A"]:
                    if (ctrlKey) {
                        this.test.selectText(el);
                        retVal = true;
                    }
                    break;

                case KC["LEFT"]:
                case KC["HOME"]:
                    if (keyDownEvent.shiftKey) {
                        this.test.selectText(el, 0, this.test.getCaretPosition(el));
                        retVal = true;
                    }
                    break;

                case KC["RIGHT"]:
                case KC["END"]:
                    if (keyDownEvent.shiftKey) {
                        this.test.selectText(el, this.test.getCaretPosition(el));
                        retVal = true;
                    }
                    break;
            }

            return retVal;
        },


        mimicClickOnEnter : function (el, keyCode) {
            // somehow "node.nodeName" is empty sometimes in IE10
            var nodeName        = el.nodeName && el.nodeName.toLowerCase()
            var supports        = Siesta.Project.Browser.FeatureSupport().supports
            var KeyCodes        = Siesta.Test.UserAgent.KeyCodes().keys

            if ((nodeName == 'a' || nodeName == 'button') && keyCode === KeyCodes.ENTER && !supports.enterOnAnchorTriggersClick) {
                // this "click" should not update the current cursor position its merely for activating "click" listeners
                this.simulateEvent(el, 'click', { doNotUpdateCurrentPosition : true });
            }
        },


        mimicCaretMovement : function(el, keyCode) {
            // somehow "node.nodeName" is empty sometimes in IE10
            var nodeName        = el.nodeName && el.nodeName.toLowerCase()

            if ((nodeName == 'input' || nodeName == 'textarea')) {
                var KeyCodes        = Siesta.Test.UserAgent.KeyCodes().keys;

                switch (keyCode) {
                    case KeyCodes.HOME:
                        this.test.setCaretPosition(el, 0);
                        break;

                    case KeyCodes.LEFT:
                        var selText  = this.test.getSelectedText(el);

                        if (selText) {
                            var caretPos = this.test.getCaretPosition(el);

                            this.test.selectText(el, caretPos, caretPos);
                        } else {
                            this.test.moveCaretPosition(el, -1);
                        }
                        break;

                    case KeyCodes.RIGHT:
                        var selText  = this.test.getSelectedText(el);

                        if (selText) {
                            var caretPos = this.test.getCaretPosition(el);

                            this.test.selectText(el, caretPos + selText.length, caretPos + selText.length);
                        } else {
                            this.test.moveCaretPosition(el, 1);
                        }
                        break;

                    case KeyCodes.END:
                        this.test.setCaretPosition(el, el.value.length);
                        break;
                }
            }
        },


        mimicFormSubmit : function (el) {
            var form        = this.$(el).closest('form');

            if (form.length) {
                // Use jQuery's :submit instead of [type=submit] since <button>Foo</button> could have button.type=submit, but this is not queryable
                var submitButton = form.find(':submit')[ 0 ];
                var hasOneInput  = form.find('input').length === 1;

                if (submitButton) {
                    submitButton.click();
                }
                else if (hasOneInput) {
                    var submitPrevented = this.isEventPrevented(this.simulateEvent(form[ 0 ], 'submit', {}));

                    if (!submitPrevented) form[ 0 ].submit();
                }
            }
        },


        mimicCharacterDeletion : function (el, keyCode, options) {
            var isTextInput     = this.isTextInput(el);

            if (!el.readOnly) {
                // IE won't do execCommand with insertText
                if (isTextInput || bowser.msie) {
                    var textValueProp       = 'value' in el ? 'value' : 'innerHTML';
                    var text                = el[ textValueProp ];

                    var selText             = this.test.getSelectedText(el) || '';
                    var caretPosition       = this.test.getCaretPosition(el);

                    var inputChanged        = false

                    if (caretPosition != null && selText) {
                        this.silentSetValue(
                            el,
                            text.substring(0, caretPosition) + text.substring(caretPosition + selText.length),
                            textValueProp
                        )

                        inputChanged        = true
                    } else {
                        var KeyCodes        = Siesta.Test.UserAgent.KeyCodes().keys;

                        // fall back to last char index if caret position could not be determined
                        caretPosition       = caretPosition == null ? text.length : caretPosition;

                        if (keyCode === KeyCodes.BACKSPACE) {
                            if (caretPosition > 0) {
                                inputChanged = true

                                this.silentSetValue(
                                    el,
                                    text.substring(0, caretPosition - 1) + text.substring(caretPosition),
                                    textValueProp
                                )

                                caretPosition       = caretPosition - 1;
                            }
                        } else {
                            if (caretPosition < text.length) inputChanged = true

                            // DELETE key
                            this.silentSetValue(
                                el,
                                (caretPosition > 0 ? text.substring(0, caretPosition + 1) : '') + text.substring(caretPosition + 1),
                                textValueProp
                            )
                        }
                    }

                    // Caret position is moved to end when setting text value, restore it manually
                    this.test.setCaretPosition(el, caretPosition);

                    inputChanged && this.simulateEvent(el, 'input', options);
                } else {
                    el.ownerDocument.execCommand('delete');
                }
            }
        },


        maybeMimicChangeEvent : function (el) {
            if (el.getAttribute('__lastValue') !== el.value) {
                this.simulateEvent(el, 'change');

                el.setAttribute('__lastValue', el.value);
            }
        }
    }
});


;
Role('Siesta.Test.Simulate.Event', {

    does        : [ JooseX.Observable ],

    requires : [
        '$',
        'typeOf',
        'createTextEvent',
        'createMouseEvent',
        'createKeyboardEvent'
    ],

    has : {
        bowser              : function () { return bowser },
        browser             : function () { return bowser },

        actionDelay         : 100,
        afterActionDelay    : 100,

        /**
         * @cfg {String} simulateEventsWith
         *
         * This option is IE9-strict mode (and probably above) specific. It specifies, which events simulation function Siesta should use.
         * The choice is between 'dispatchEvent' (W3C standard) and 'fireEvent' (MS interface) - both are available in IE9 strict mode
         * and both activates different event listeners. See this blog post for detailed explanations:
         * <http://www.digitalenginesoftware.com/blog/archives/76-DOM-Event-Model-Compatibility-or-Why-fireEvent-Doesnt-Trigger-addEventListener.html>
         *
         * Valid values are "dispatchEvent" and "fireEvent".
         *
         * The framework specific adapters choose the most appropriate value automatically (unless explicitly configured).
         */
        simulateEventsWith  : {
            is   : 'rw',
            lazy : function () { return 'dispatchEvent' }
        }
    },

    methods : {

        normalizeEventName : function (eventName) {
            return eventName
        },


        /**
         * This method will simulate an event triggered by the passed element. If no coordinates are supplied in the options object, the center of the element
         * will be used.
         * @param {Siesta.Test.ActionTarget} el
         * @param {String} type The type of event (e.g. 'mouseover', 'click', 'keypress')
         * @param {Object} the options for the event. See http://developer.mozilla.org/en/DOM/event for reference.
         */
        simulateEvent : function (el, type, options) {
            var global  = this.global;
            options     = options || {};

            if (this.typeOf(el) == 'Array') {
                if (el.length == 0) el = this.currentPosition.slice()

                if (!('clientX' in options)) {
                    options.clientX = el[ 0 ];
                }

                if (!('clientY' in options)) {
                    options.clientY = el[ 1 ];
                }
            }

            el          = this.test.normalizeElement(el);
            type        = this.normalizeEventName(type)

            var evt     = this.createEvent(type, options, el);

            if (evt) {
                this.maintainScrollPositionDuring(function () {
                    evt.synthetic = true;

                    this.mimicBrowserBehaviorBefore(evt, type, el);

                    this.dispatchEvent(el, type, evt);

                    !this.isEventPrevented(evt) && this.mimicBrowserBehaviorAfter(evt, type, el);
                })
            }

            this.fireEvent('eventsimulated', evt, el, type, options)

            return evt;
        },


        createEvent : function (type, options, el) {
            var event

            if (/^textinput$/i.test(type)) {
                event = this.createTextEvent(type, options, el);
            } else if (/^mouse(over|out|down|up|move|enter|leave)|contextmenu|wheel|(dbl)?click$/.test(type) || /^(ms)?pointer/i.test(type)) {
                event = this.createMouseEvent(type, options, el);
            } else if (/^key(up|down|press)$/.test(type)) {
                event = this.createKeyboardEvent(type, options, el);
            } /*else if (/^touch/.test(type)) {
             return this.createTouchEvent(type, options, el);
             }*/
            else if (/^change$|^input$|^submit/.test(type)) {
                event = this.createGenericEvent(type, options, el);
            }
            else
                event = this.createHtmlEvent(type, options, el);

            // IE>=9 somehow reports that "defaultPrevented" property of the event object is `false`
            // even that "preventDefault()" has been called on the object
            // more over, immediately after call to "preventDefault()" the property is updated
            // but down in stack it is replaced with "false" again somehow
            // we setup our own, additional property, indicating that event has been prevented
            if (event && bowser.msie && bowser.version >= 9) {
                var prev = event.preventDefault

                event.preventDefault = function () {
                    arguments.callee.$prevented = true;
                    this.returnValue = false

                    return prev && prev.apply(this, arguments)
                }
            }

            return event
        },


        isEventPrevented : function (event) {
            // our custom property - takes highest priority
            if (event.preventDefault && this.typeOf(event.preventDefault.$prevented) == 'Boolean') return event.preventDefault.$prevented

            // W3C standards property
            if (this.typeOf(event.defaultPrevented) == 'Boolean') return event.defaultPrevented

            return event.returnValue === false
        },


        createGenericEvent : function (type, options, el) {
            var doc                 = el.ownerDocument;

            if (doc.createEvent && this.getSimulateEventsWith() == 'dispatchEvent') {
                var evt             = doc.createEvent("Events");

                evt.initEvent(type, true, true);

                return evt;
            } else if (doc.createEventObject) {
                var event           = doc.createEventObject()

                event.srcElement    = el

                event.bubbles       = options.bubbles
                event.cancelBubble  = !options.bubbles
                event.type          = type

                return event
            }
        },


        createHtmlEvent : function (type, options, el) {
            var doc = el.ownerDocument;

            if (doc.createEvent && this.getSimulateEventsWith() == 'dispatchEvent') {
                var evt = doc.createEvent("HTMLEvents");
                evt.initEvent(type, false, false);
                return evt;
            } else if (doc.createEventObject) {
                return doc.createEventObject();
            }
        },


        dispatchEvent : function (el, type, evt) {

            // use W3C standard when available and allowed by "simulateEventsWith" option
            if (el.dispatchEvent && this.getSimulateEventsWith() == 'dispatchEvent') {
                el.dispatchEvent(evt);
            } else if (el.fireEvent) {
                // IE 6,7,8 can't dispatch many events cleanly - throws exceptions
                try {
                    // this is the serios nominant to the best-IE-bug-ever prize and it's IE7 specific
                    // accessing the "scrollLeft" property on document or body triggers a synchronous(!) "resize" event on the window
                    // ExtJS uses a singleton for Ext.EventObj and its "target" property gets overwritten with "null"
                    // thus consequent event handlers fails
                    // doing an access to that property to cache it
                    var doc  = this.global.document.documentElement;
                    var body = this.global.document.body;

                    var xxx = doc && doc.scrollLeft || body && body.scrollLeft || 0;

                    el.fireEvent('on' + type.toLowerCase(), evt);
                } catch (e) {
                }

                // in IE, the "fireEvent" does not bubble the "change" event
                // we try to bubble it manually (to fix the TaskBoard2.x "subtasks" tests, but then
                // the target el is not set correctly and it goes too deep into Ext sources, so commenting for now
//                if (type == 'change') {
//                    if (el != doc && el != body && el.parentElement) this.dispatchEvent(el.parentElement, type, evt)
//                }
            } else
                throw "Can't dispatch event: " + type

            return evt;
        },


        mimicBrowserBehaviorBefore : function (event, type, target) {
        },


        mimicBrowserBehaviorAfter : function (event, type, target) {
            var tagName = target.tagName.toLowerCase();

            switch (type) {
                case 'mousedown':
                    // it seems selection is actually cleared in "pointerup" (mouseup)
                    if (this.isTextInput(target)) {
                        this.mimicClearTextSelection(target);
                    }
                    break;
                case 'click':
                    if (
                        bowser.msie && bowser.version < 11 &&
                        tagName === 'a' &&
                        target.getAttribute("href")
                    ) {
                        this.mimicHashUpdate(target);
                    } else if (tagName === 'option' && !target.getAttribute('disabled')) {
                        this.mimicOptionSelect(target);
                    }
                    break;
                case 'dblclick':
                    if (this.isTextInput(target)) {
                        this.mimicDblClickTextSelection(target);
                    }
                    break;
                case 'keydown':
                    var KeyCodes = Siesta.Test.UserAgent.KeyCodes().keys

                    if (event.keyCode === KeyCodes.BACKSPACE) {
                        this.mimicHistoryChangeAfterBackspace(event, target);
                    }
                    break;
            }
        },

        // IE9+
        // Breaks IE9 with Ext JS 5.1.0, tested in .540_extjs_type.t.js?5.1.0
        mimicClearTextSelection : function (target) {
            var extVersion = this.global.Ext && this.global.Ext.versions;
            var isExtJS51  = extVersion && extVersion.extjs && extVersion.extjs.equals('5.1.0.107');

            if (!bowser.msie || !isExtJS51 || (bowser.version > 9)) {
                this.test.selectText(target, target.value.length - 1, target.value.length);

                this.test.setCaretPosition(target, target.value.length);
            }
        },


        mimicDblClickTextSelection : function (target) {
            this.test.selectText(target);
        },

        // After a click action in old IE, change location hash manually
        mimicHashUpdate : function (el) {
            var href = el.getAttribute("href").match(/#(.*)/);

            if (href) {
                this.global.location.hash = href[1];
            }
        },


        mimicHistoryChangeAfterBackspace : function (event, target) {
            // Chrome+Safari doesn't trigger page navigation (as of Chrome52)
            if (bowser.webkit || bowser.blink) return;

            var doc      = target.ownerDocument;

            if (!target.isContentEditable && doc.designMode.toLowerCase() !== "on" && !this.isTextInput(target)) {
                var elWindow = target.ownerDocument.defaultView || target.ownerDocument.parentWindow;

                if (event.shiftKey) {
                    this.mimicNextHistory(elWindow);
                } else {
                    this.mimicPreviousHistory(elWindow);
                }
            }
        },


        mimicPreviousHistory : function (global) {
            global.history.back();
        },


        mimicNextHistory : function (global) {
            global.history.forward();
        },


        mimicOptionSelect : function (optionNode) {
            var select   = this.$(optionNode).closest('select')[0];
            var oldValue = select.value;

            select.value = optionNode.value;

            if (oldValue !== optionNode.value) {
                this.simulateEvent(select, "change");
            }
        }
    }
});
;
Role('Siesta.Test.Simulate.Touch', {

    requires        : [
    ],

    has: {
        touchEventNamesMap  : {
            lazy        : 'this.buildTouchEventNamesMap'
        },

        currentTouchId  : 1,

        activeTouches   : Joose.I.Object,

        longPressDelay      : {
            init        : 1500,
            is          : 'rw'
        },

        forceTouchEvents    : bowser.chrome
    },


    methods: {

        simulateTap : function (context, options) {

            var queue       = new Siesta.Util.Queue({
                deferer         : this.test.originalSetTimeout,
                deferClearer    : this.test.originalClearTimeout,

                interval        : 30,

                observeTest     : this.test
            })

            var me          = this;
            var id

            queue.addStep({
                processor : function () {
                    id      = me.touchStart(null, null, options, context)
                }
            })
            queue.addStep({
                processor : function () {
                    me.touchEnd(id, options)
                }
            })

            return new Promise(function (resolve, reject) {
                queue.run(resolve)
            })
        },


        simulateDoubleTap : function (context, options) {

            var queue       = new Siesta.Util.Queue({
                deferer         : this.test.originalSetTimeout,
                deferClearer    : this.test.originalClearTimeout,

                interval        : 30,

                observeTest     : this.test
            })

            var me      = this;
            var id

            queue.addStep({
                processor : function () {
                    id      = me.touchStart(null, null, options, context)
                }
            })
            queue.addStep({
                processor : function () {
                    me.touchEnd(id, options)
                }
            })
            queue.addStep({
                processor : function () {
                    id      = me.touchStart(null, null, options, context)
                }
            })
            queue.addStep({
                processor : function () {
                    me.touchEnd(id, options)
                }
            })

            return new Promise(function (resolve, reject) {
                queue.run(resolve)
            })
        },


        simulateLongPress : function (context, options) {

            var queue       = new Siesta.Util.Queue({
                deferer         : this.test.originalSetTimeout,
                deferClearer    : this.test.originalClearTimeout,

                interval        : 30,

                observeTest     : this.test
            })

            var me      = this;
            var id

            queue.addStep({
                processor : function () {
                    id      = me.touchStart(null, null, options, context)
                }
            })
            queue.addDelayStep(this.getLongPressDelay())
            queue.addStep({
                processor : function () {
                    me.touchEnd(id, options)
                }
            })

            return new Promise(function (resolve, reject) {
                queue.run(resolve)
            })
        },


        simulatePinch : function (context1, context2, options) {

            var queue       = new Siesta.Util.Queue({
                deferer         : this.test.originalSetTimeout,
                deferClearer    : this.test.originalClearTimeout,

                interval        : 30,

                observeTest     : this.test
            })

            var id1, id2

            var dx          = context1.localXY[ 0 ] - context2.localXY[ 0 ]
            var dy          = context1.localXY[ 1 ] - context2.localXY[ 1 ]

            var distance    = Math.sqrt(dx * dx + dy * dy)

            if (distance < 1) distance = 1

            var scaled      = distance * scale
            var delta       = (scaled - distance) / 2

            var angle       = Math.atan(dy / dx)

            var x1          = Math.round(context1.localXY[ 0 ] - delta * Math.cos(angle))
            var y1          = Math.round(context1.localXY[ 1 ] - delta * Math.sin(angle))

            var x2          = Math.round(context2.localXY[ 0 ] + delta * Math.cos(angle))
            var y2          = Math.round(context2.localXY[ 1 ] + delta * Math.sin(angle))

            var options2    = Joose.O.extend({}, options)

            queue.addStep({
                processor : function () {
                    id1     = me.touchStart(null, null, options, context1)
                    id2     = me.touchStart(null, null, options2, context2)
                }
            })
            queue.addAsyncStep({
                processor : function (data) {
                    var move1Done   = false
                    var move2Done   = false

                    me.touchMove(id1, x1, y1, function () {
                        move1Done       = true

                        if (move1Done && move2Done) data.next()
                    }, null, options)

                    me.touchMove(id2, x2, y2, function () {
                        move2Done       = true

                        if (move1Done && move2Done) data.next()
                    }, null, options2)
                }
            })
            queue.addStep({
                processor : function () {
                    me.touchEnd(id1, options)
                    me.touchEnd(id2, options2)
                }
            })

            return new Promise(function (resolve, reject) {
                queue.run(resolve)
            })
        },


        simulateTouchDrag : function (sourceXY, targetXY, options, dragOnly) {
            var me          = this
            options         = options || {};

            // For drag operations we should always use the top level document.elementFromPoint
            var source      = me.elementFromPoint(sourceXY[ 0 ], sourceXY[ 1 ], true);
            var target      = me.elementFromPoint(targetXY[ 0 ], targetXY[ 1 ], true);

            var queue       = new Siesta.Util.Queue({
                deferer         : this.test.originalSetTimeout,
                deferClearer    : this.test.originalClearTimeout,

                interval        : me.dragDelay,
                callbackDelay   : me.afterActionDelay,

                observeTest     : this.test
            });

            var id

            queue.addStep({
                processor : function () {
                    id      = me.touchStart(sourceXY, null, options)
                }
            })
            queue.addAsyncStep({
                processor : function (data) {
                    me.touchMove(id, targetXY[ 0 ], targetXY[ 1 ], options).then(data.next)
                }
            })
            queue.addStep({
                processor : function () {
                    // if `dragOnly` flag is set, do not finalize the touch, instead, pass the touch id
                    // to the user in the callback (see below)
                    if (!dragOnly) me.touchEnd(id, options)
                }
            })

            return new Promise(function (resolve, reject) {
                queue.run(function () {
                    // if `dragOnly` flag is set pass the touch id as promise result
                    if (dragOnly)
                        resolve(id)
                    else
                        resolve()
                })
            })
        },


        touchStart : function (target, offset, options, context) {
            if (!context) context = this.test.getNormalizedTopElementInfo(target, true, 'touchStart', offset)

            options         = Joose.O.extend({
                clientX     : context.localXY[ 0 ],
                clientY     : context.localXY[ 1 ]
            }, options || {})

            var event       = this.simulateTouchEventGeneric(context.el, 'start', options)

            return event.pointerId || event.changedTouches[ 0 ].identifier
        },


        touchEnd : function (touchId, options) {
            var touch       = this.activeTouches[ touchId ]

            if (!touch) throw "Can't find active touch: " + touchId

            options         = Joose.O.extend({
                clientX     : touch.clientX,
                clientY     : touch.clientY
            }, options || {})

            var target      = touch.target

            if (!this.test.isInDom(target)) {
                touch.target = this.global.document.body
            }

            this.simulateTouchEventGeneric(touch.currentEl || touch.target, 'end', options, { touchId : touchId })
        },


        touchMove : function (touchId, toX, toY, options) {
            var touch       = this.activeTouches[ touchId ]

            if (!touch) throw "Can't find active touch: " + touchId

            var me          = this
            var overEls     = []

            return this.movePointerTemplate({
                xy              : [ touch.clientX, touch.clientY ],
                xy2             : [ toX, toY ],
                options         : options || {},

                overEls         : overEls,
                interval        : me.dragDelay,
                callbackDelay   : me.afterActionDelay,
                pathBatchSize   : me.pathBatchSize,

                onVoidOverEls   : function () {
                    return overEls = []
                },

                onPointerEnter  : function (el, options) {
                },

                onPointerLeave  : function (el, options) {
                },

                onPointerOver   : function (el, options) {
                },

                onPointerOut    : function (el, options) {
                },

                onPointerMove   : function (el, options) {
                    touch.clientX       = options.clientX
                    touch.clientY       = options.clientY

                    touch.pageX         = me.viewportXtoPageX(options.clientX)
                    touch.pageY         = me.viewportYtoPageY(options.clientY)

                    touch.currentEl     = el

                    me.simulateTouchEventGeneric(el, 'move', options, { touchId : touchId })
                }
            })
        },


        // never used yet, should be called when touchMove goes out of the document
        touchCancel : function (touchId, options) {
            var touch       = this.activeTouches[ touchId ]

            if (!touch) throw "Can't find active touch: " + touchId

            this.simulateTouchEventGeneric(touch.currentEl || touch.target, 'cancel', options, { touchId : touchId })
        },


        simulatePointerEventModern : function (target, type, options, simOptions) {
            target          = this.test.normalizeElement(target)

            if (!target) return false

            var supports    = Siesta.Project.Browser.FeatureSupport().supports

            options         = options || {}

            if (/pointerdown$/i.test(type) && (!("clientX" in options) || !("clientY" in options))) {
                var center  = this.test.findCenter(target);

                options     = Joose.O.extend({
                    clientX     : center[ 0 ],
                    clientY     : center[ 1 ]
                }, options)
            }

            var doc         = this.global.document

            var event       = new PointerEvent(type, {
                bubbles         : true,
                cancelable      : true,

                view            : this.global,
                detail          : options.detail,

                screenX         : options.screenX,
                screenY         : options.screenY,

                clientX         : options.clientX,
                clientY         : options.clientY,

                ctrlKey         : options.ctrlKey || false,
                altKey          : options.altKey || false,
                shiftKey        : options.shiftKey || false,
                metaKey         : options.metaKey || false,

                button          : options.button,
                relatedTarget   : options.relatedTarget || doc.documentElement,

                pointerId       : simOptions.touchId || this.currentTouchId++,

                // pointerType
                // NOTE: this has to be set to "mouse" (IE11) or 4 (IE10, 11) because otherwise
                // ExtJS5 blocks the event
                // need to investigate what happens in SenchaTouch
                pointerType     : 4 //mouse
            })

            target.dispatchEvent(event)

            return event
        },


        simulatePointerEvent : function (target, type, options, simOptions) {
            var supports    = Siesta.Project.Browser.FeatureSupport().supports

            if (supports.PointerEvents && this.bowser.chrome) return this.simulatePointerEventModern(target, type, options, simOptions)

            target          = this.test.normalizeElement(target)

            if (!target) return false

            options         = options || {}

            var doc         = this.global.document,
                event       = doc.createEvent(
                    supports.PointerEvents ? 'PointerEvent' : supports.MSPointerEvents ? 'MSPointerEvent' : 'MouseEvents'
                )

            if (/pointerdown$/i.test(type) && (!("clientX" in options) || !("clientY" in options))) {
                var center  = this.test.findCenter(target);

                options     = Joose.O.extend({
                    clientX     : center[ 0 ],
                    clientY     : center[ 1 ]
                }, options)
            }

            event[ (supports.MSPointerEvents || supports.PointerEvents) ? 'initPointerEvent' : 'initMouseEvent' ](
                type, true, true, this.global, options.detail,
                options.screenX, options.screenY, options.clientX, options.clientY,
                options.ctrlKey || false, options.altKey || false, options.shiftKey || false, options.metaKey || false,
                options.button, options.relatedTarget || doc.documentElement,
                // the following extra args are used in the "initPointerEvent"
                // offsetX, offsetY
                null, null,
                // width, height
                null, null,
                // pressure, rotation
                null, null,
                // tiltX, tiltY
                null, null,
                // pointerId
                simOptions.touchId || this.currentTouchId++,
                // pointerType
                // NOTE: this has to be set to "mouse" (IE11) or 4 (IE10, 11) because otherwise
                // ExtJS5 blocks the event
                // need to investigate what happens in SenchaTouch
                4,//'mouse',
                // timestamp, isPrimary
                null, null
            );

            if (!(supports.MSPointerEvents || supports.PointerEvents)) {
                event.pointerId = simOptions.touchId || this.currentTouchId++
            }

            target.dispatchEvent(event)

            return event
        },


        simulateTouchEvent : function (target, type, options, simOptions) {
            options         = options || {}
            var global      = this.global
            var doc         = global.document

            var event       = new global.CustomEvent(type, {
                bubbles     : true,
                cancelable  : true
            })

            var target      = this.test.normalizeElement(target)

            var clientX, clientY

            if (("clientX" in options) && ("clientY" in options)) {
                clientX     = options.clientX
                clientY     = options.clientY
            } else {
                var center  = this.test.findCenter(target);

                clientX     = center[ 0 ]
                clientY     = center[ 1 ]
            }

            var activeTouches   = this.activeTouches
            var touch           = simOptions.touch
            var touches         = []
            var targetTouches   = []

            for (var id in activeTouches) {
                var currentTouch    = activeTouches[ id ]

                touches.push(currentTouch)
                if (currentTouch.target == target) targetTouches.push(currentTouch)
            }

            Joose.O.extend(event, {
                target          : target,

                changedTouches  : this.createTouchList([ touch ]),

                touches         : this.createTouchList(touches),
                targetTouches   : this.createTouchList(targetTouches),

                altKey          : options.altKey,
                metaKey         : options.metaKey,
                ctrlKey         : options.ctrlKey,
                shiftKey        : options.shiftKey
            });

            target.dispatchEvent(event)

            return event
        },


        createTouchList : function  (touchList) {
            var doc         = this.global.document

            // a branch for browsers supporting "createTouch/createTouchList"
            if (doc.createTouch) {
                var touches = [];

                for (var i = 0; i < touchList.length; i++) {
                    var touchCfg    = touchList[ i ];

                    touches.push(doc.createTouch(
                        doc.defaultView || doc.parentWindow,
                        touchCfg.target,
                        touchCfg.identifier || this.currentTouchId++,
                        touchCfg.pageX,
                        touchCfg.pageY,
                        touchCfg.screenX || touchCfg.pageX,
                        touchCfg.screenY || touchCfg.pageY,
                        touchCfg.clientX,
                        touchCfg.clientY
                    ))
                }

                return doc.createTouchList.apply(doc, touches);
            } else
                return touchList
        },


        createTouch: function (target, clientX, clientY) {
            return {
                identifier  : this.currentTouchId++,
                target      : target,

                clientX     : clientX,
                clientY     : clientY,

                screenX     : 0,
                screenY     : 0,

                // TODO should take scrolling into account
                pageX       : clientX,
                pageY       : clientY
            }
        },


        buildTouchEventNamesMap : function () {
            var supports        = Siesta.Project.Browser.FeatureSupport().supports

            return supports.PointerEvents && !this.forceTouchEvents ?
                {
                    start   : 'pointerdown',
                    move    : 'pointermove',
                    end     : 'pointerup',
                    cancel  : 'pointercancel'
                }
                : supports.MSPointerEvents ?
                    {
                        start   : 'MSPointerDown',
                        move    : 'MSPointerMove',
                        end     : 'MSPointerUp',
                        cancel  : 'MSPointerCancel'
                    }
                    : /*supports.TouchEvents ?*/
                    {
                        start   : 'touchstart',
                        move    : 'touchmove',
                        end     : 'touchend',
                        cancel  : 'touchcancel'
                    }
//                :
//                // todo: fire mouseevents?
//                (function () { throw "Touch events not supported" })()
        },


        simulateTouchEventGeneric : function (target, type, options, simOptions) {
            simOptions      = simOptions || {}

            var target      = this.test.normalizeElement(target)

            var clientX, clientY

            if (("clientX" in options) && ("clientY" in options)) {
                clientX     = options.clientX
                clientY     = options.clientY
            } else {
                var center  = this.test.findCenter(target);

                clientX     = center[ 0 ]
                clientY     = center[ 1 ]
            }

            var activeTouches   = this.activeTouches
            var touch

            if (type === 'end' || type === 'cancel') {
                touch       = activeTouches[ simOptions.touchId ]

                target      = touch.currentEl || touch.target

                delete activeTouches[ simOptions.touchId ]
            } else if (type == 'start') {
                touch       = this.createTouch(target, clientX, clientY)

                activeTouches[ touch.identifier ] = touch

            } else if (type == 'move') {
                touch           = activeTouches[ simOptions.touchId ]

                // "*move" events should be fired only from the "movePointerTemplate" method
                // which provides the "clientX/clientY" properties
                touch.clientX   = options.clientX
                touch.clientY   = options.clientY
            }

            if (!touch) throw "Can't find active touch" + (simOptions.touchId ? ': ' + simOptions.touchId : '')

            if (!simOptions.touchId) simOptions.touchId = touch.identifier

            simOptions.touch    = touch

            var eventType       = this.getTouchEventNamesMap()[ type ]
            var supports        = Siesta.Project.Browser.FeatureSupport().supports

            if ((supports.PointerEvents || supports.MSPointerEvents) && !this.forceTouchEvents) {
                return this.simulatePointerEvent(target, eventType, options, simOptions)
            } else /*if (supports.TouchEvents)*/ {
                return this.simulateTouchEvent(target, eventType, options, simOptions);
            }
//            } else {
//                // TODO fallback to mouse events?
//                throw "Can't simulate any type of touch events"
//            }
        }
    }
});;
Class('Siesta.Test.Simulator', {

    does : [
        Siesta.Util.Role.CanGetType,
        Siesta.Test.Browser.Role.CanRebindJQueryContext,

        Siesta.Test.Simulate.Event,
        Siesta.Test.Simulate.Mouse,
        Siesta.Test.Simulate.Keyboard,
        Siesta.Test.Simulate.Touch
    ],

    has : {
        type : 'synthetic',

        test   : null,
        global : null
    },


    methods : {

        initialize : function () {
            this.SUPER();

            this.onBlur = this.onBlur.bind(this);
        },

        onTestLaunch : function (test) {
            var me = this;

            me.test   = test
            me.global = test.global

            // Synthetic events unfortunately doesn't trigger change events on blur of an INPUT
            if (me.type === 'synthetic') {
                var inputFiresChangeAfterLosingFocus = Siesta.Project.Browser.FeatureSupport().supports.inputFiresChangeAfterLosingFocus;

                if (!inputFiresChangeAfterLosingFocus) {
                    me.global.document.documentElement.addEventListener('blur', me.onBlur, true);
                }
            }
        },

        onBlur : function (e) {
            if (e.target && this.test.isTextInput(e.target)) {
                this.maybeMimicChangeEvent(e.target);
            }
        },

        cleanup : function () {
            // Added check that global exists, made tests crash without
            this.global && this.global.document.documentElement.removeEventListener('blur', this.onBlur, true);

            this.test   = null
            this.global = null
        },

        setSpeed : function (name) {
            Joose.O.extend(this, Siesta.Test.Simulator.speedPresets[name]);
        }
    }
});

Siesta.Test.Simulator.speedPresets = {
    slow : {
        actionDelay        : 100,
        afterActionDelay   : 100,
        dragDelay          : 25,
        pathBatchSize      : 5,
        mouseMovePrecision : 1,
        mouseDragPrecision : 1
    },

    speedRun : {
        actionDelay        : 1,
        afterActionDelay   : 100,
        dragDelay          : 10,
        pathBatchSize      : 30,
        mouseMovePrecision : 1,
        mouseDragPrecision : 1
    },

    turboMode : {
        actionDelay        : 1,
        afterActionDelay   : 1,
        dragDelay          : 0,
        pathBatchSize      : 100,
        mouseMovePrecision : Infinity,
        mouseDragPrecision : Infinity
    }
};
;
Class('Siesta.Test.SimulatorExtJS', {

    isa : Siesta.Test.Simulator,

    has : {
        simulateEventsWith      : {
            is      : 'rw',
            lazy    : function () {
                var isIE9           = navigator.userAgent.match(/MSIE 9.0;/)
                var Ext             = this.global.Ext

                // no Ext or Ext3, should use standard "dispatchEvent" method
                if (!Ext || !Ext.getVersion) return 'dispatchEvent'

                var extVersion      = Ext.getVersion('extjs')

                // the "Ext.getVersion('extjs')" is just "true" in Ext3? (when testing SA)
                var isBelowExt421   = Boolean((extVersion && extVersion.isLessThan && extVersion.isLessThan('4.2.1.883')))

                var div             = document.createElement('div')

                return div.attachEvent && (isIE9 || isBelowExt421) ? 'fireEvent' : 'dispatchEvent'
            }
        }
    },

    methods : {

        // Overridden to deal with the different event firing mechanisms in Ext JS 3 vs 4
        // This code is required because in IE events are simulated using fireEvent instead of dispatchEvent and it seems fireEvent will
        // will not update a checkbox 'checked' state properly so we're forcing the toggle to solve this situation.
        // This issue is only relevant in IE + Ext.
        //
        // Test case: 507_form_checkbox.t.js
        simulateMouseClick: function (clickInfo, options) {
            var me      = this
            var el      = clickInfo.el
            var Ext     = this.global.Ext

            var isExt5  = Ext && Ext.getVersion && Ext.getVersion('extjs') && Ext.getVersion('extjs').major == 5

            // Force check toggle for input checkboxes
            if (
                (this.getSimulateEventsWith() === 'fireEvent' || isExt5)
                    &&
                (el.type === 'checkbox' || el.type === 'radio') && !el.disabled && !el.readOnly
            ) {
                var oldState = el.checked;

                return this.SUPER(clickInfo, options).then(function () {
                    if (el.checked === oldState) {
                        el.checked = !oldState;

                        var optionsWithBubble       = Joose.O.copy(options)
                        optionsWithBubble.bubbles   = true

                        me.simulateEvent(el, 'change', optionsWithBubble)
                    }
                });
            } else {
                return this.SUPERARG(arguments);
            }
        }
    }
})
;
/**
@class Siesta.Test.UserAgent.Mouse

This is a mixin, providing the mouse events simulation functionality.
*/


Role('Siesta.Test.UserAgent.Mouse', {

    requires        : [
        //'simulateEvent', 'getSimulateEventsWith', 'normalizeElement', 'isTextInput'
    ],

    has: {
        // backward-compat only - just reference to a `this.simulator.currentPosition`
        currentPosition                 : null,

        /**
         *  @cfg {Boolean} moveCursorBetweenPoints True to move the mouse cursor between for example two clicks on
         *  separate elements (for better visual experience)
         */
        moveCursorBetweenPoints         : true,


        enableUnreachableClickWarning   : true,

        autoScrollElementsIntoView      : true,
        delayAfterScrollIntoView        : 200
    },


    methods: {

        // not used anymore? previously been used in RootCause, as "instance" mouse move
        setCursorPosition : function (x, y, callback) {
            this.doMouseMove(this.simulator.currentPosition, [ x, y ], callback, null, null, { moveKind : 'instant' });
        },


        moveMouseAlongPath : function () {
            return this.moveCursorAlongPath.apply(this, arguments);
        },

        /**
         * This method sequentially moves a cursor through a series of "path points".
         *
         * A path point can be one of the following:
         *
         * - An object `{ target : 'query', offset : [ x, y ] }`, where 'query' is any valid
         * {@link Siesta.Test.ActionTarget} query. This object will specify an absolute point on the page.
         * - A more compact notation with single letter properties `{ t : 'query', o : [ x, y ] }`
         * - An object `{ target : [ x, y ] }`, where 'x' and 'y' specifies an aboslute point on the page.
         * - An object `{ by : [ dx, dy ] }`, where `by` is an array, with a relative delta from previous point.
         * - An array with 3 elements: `[ 'query', x, y ]`, specifying an absolute point on the page, using
         * 'query' and 'x' 'y' offset.
         * - An array with 1 element: `[ [ x, y ] ]`, which is in turn an array, specifying an absolute
         * point on the page, using 'x' and 'y' page coordinates.
         * - An array with 2 elements: `[ dx, dy ]`, specifying a relative delta from previous point
         *
         * This method is generally intended to be used by {@link Siesta.Recorder.Recorder} with enabled
         * {@link Siesta.Recorder.Recorder#recordMouseMovePath recordMouseMovePath} option. That option can generate
         * a substantial amount of data, thus there is a focus on having a compact notation for it.
         *
         * @param {Array[path point]} pathArray An array of "path points"
         * @param {Function} callback A function to call after visiting all points
         *
         * @return {Promise} Returns a promise resolved once the action has completed
         */
        moveCursorAlongPath : function (pathArray, callback) {
            var me          = this

            var queue       = new Siesta.Util.Queue({
                deferer         : this.originalSetTimeout,
                deferClearer    : this.originalClearTimeout,

                interval        : 0,

                processor       : function (data) {
                    var pathPoint       = data.pathPoint

                    var target, offset, isDelta

                    if (me.typeOf(pathPoint) == 'Array') {
                        if (me.typeOf(pathPoint[ 0 ]) == 'Array') {
                            target      = pathPoint[ 0 ]
                        } else if (me.typeOf(pathPoint[ 0 ]) == 'String') {
                            target      = pathPoint[ 0 ]
                            offset      = pathPoint.length == 3 ? [ pathPoint[ 1 ], pathPoint[ 2 ] ] : null
                        } else {
                            isDelta     = true
                            target      = pathPoint
                        }

                    } else {
                        if (pathPoint.by) {
                            isDelta     = true
                            target      = pathPoint.by
                        } else {
                            target      = pathPoint.t || pathPoint.target
                            offset      = pathPoint.o || pathPoint.offset
                        }
                    }

                    if (isDelta)
                        me.moveMouseBy(target, data.next, me)
                    else
                        me.moveMouseTo(target, data.next, me, offset)
                }
            })

            Joose.A.each(pathArray, function (pathPoint) {
                queue.addStep({
                    isAsync     : true,

                    pathPoint   : pathPoint
                })
            })

            return new Promise(function (resolve, _reject) {
                queue.run(function () {
                    me.processCallbackFromTest(callback, null, me)

                    resolve()
                })
            })
        },


        /**
         * This method will simulate a mouse move to an xy-coordinate or an element (the center of it)
         *
         * @param {Siesta.Test.ActionTarget} target Target point to move the mouse to.
         * @param {Function} [callback] To run this method async, provide a callback method to be called after the operation is completed.
         * @param {Object} [scope] the scope for the callback
         * @param {Array} [offset] An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "50%"] to click in the center.
         * @param {Object} [waitForTarget] *private* True to wait for the target to exist before moving mouse
         * @param {Object} [options] Any options to use for the simulated DOM event
         *
         * @return {Promise} Returns a promise resolved once the action has completed
         */
        moveMouseTo : function (target, callback, scope, offset, waitForTarget, options) {
            if (!target) throw new Error('Trying to call `moveMouseTo` without a target')

            // TODO this method should also accept an options object, so user can for example hold CTRL key during mouse operation

            if (waitForTarget !== false) {
                return this.waitForTargetAndSyncMousePosition(target, offset, function () {
                    callback.call(scope || this);
                }, [], false, undefined, options);
            } else {
                var me          = this

                return new Promise(function (resolve, _reject) {
                    // skip warning about clicking in an unreachable point of the element at me step
                    // when mouse position is not yet updated
                    // potentially the element will become reachable when the mouse is moved to the required point
                    var data        = me.getNormalizedTopElementInfo(target, true, 'moveMouseTo', offset);

                    if (data) {
                        me.syncCursor(data.globalXY, function () {
                            callback && callback.call(scope || me);

                            resolve()
                        }, options);
                    } else {
                        // No point in continuing
                        callback && callback.call(scope || me);

                        resolve()
                    }
                })
            }
        },


        /**
         * Alias for moveMouseTo, this method will simulate a mouse move to an xy-coordinate or an element (the center of it)
         *
         * @param {Siesta.Test.ActionTarget} target Target point to move the mouse to.
         * @param {Function} [callback] To run this method async, provide a callback method to be called after the operation is completed.
         * @param {Object} [scope] the scope for the callback
         * @param {Array} [offset] An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "50%"] to click in the center.
         *
         * @return {Promise} Returns a promise resolved once the action has completed
         */
        moveCursorTo : function (target, callback, scope, offset) {
            this.moveMouseTo.apply(this, arguments);
        },

        /**
         * This method will simulate a mouse move by an x a y delta amount
         * @param {Array} delta The delta x and y distance to move, e.g. [20, 20] for 20px down/right, or [0, 10] for just 10px down.
         * @param {Function} [callback] To run this method async, provide a callback method to be called after the operation is completed.
         * @param {Object} [scope] the scope for the callback
         * @param {Object} [options] Any options to use for the simulated DOM events
         *
         * @return {Promise} Returns a promise resolved once the action has completed
         */
        moveMouseBy : function (delta, callback, scope, options) {
            this.moveCursorBy.apply(this, arguments);
        },

        /**
         * This method will simulate a mouse move by an x and y delta amount
         * @param {Array} delta The delta x and y distance to move, e.g. [20, 20] for 20px down/right, or [0, -10] for 10px up.
         * @param {Function} [callback] To run this method async, provide a callback method to be called after the operation is completed.
         * @param {Object} [scope] the scope for the callback
         * @param {Object} [options] Any options to use for the simulated DOM events
         *
         * @return {Promise} Returns a promise resolved once the action has completed
         */
        moveCursorBy : function (delta, callback, scope, options) {
            if (!delta) {
                throw 'Trying to call moveCursorBy without relative distances';
            }

            // Normalize target
            var target = [
                this.simulator.currentPosition[ 0 ] + delta[ 0 ],
                this.simulator.currentPosition[ 1 ] + delta[ 1 ]
            ];

            return this.doMouseMove(this.simulator.currentPosition, target, callback, scope, undefined, options);
        },


        // private, to be removed in the future?
        // we don't support source `xy` coordinates in native simulator
        doMouseMove : function (xy, xy2, callback, scope, params, options) {
            var promise         = this.simulator.simulateMouseMove(xy2[ 0 ], xy2[ 1 ], options, params)

            return this.runPromiseAsync(promise, 'mousemove', callback, scope)
        },


        // candidate for removal, only used in 2 places, feels redundant with "doMouseMouse"
        syncCursor : function (toXY, callback, options) {
            var fromXY      = this.simulator.currentPosition;

            if (toXY[ 0 ] !== fromXY[ 0 ] || toXY[ 1 ] !== fromXY[ 1 ]) {

                this.doMouseMove(fromXY, toXY, callback, this, undefined, options);
            } else
                // already aligned
                callback && callback();
        },


        runPromiseAsync : function (promise, actionDesc, callback, callbackScope, errback) {
            var me          = this

            var async       = this.beginAsync(null, function () {
                me.fail(me.formatString("Action `{actionDesc}` failed to complete within {time}ms", { actionDesc : actionDesc, time : this.defaultTimeout }))

                return true
            })

            return promise.then(function (result) {
                me.endAsync(async)

                me.processCallbackFromTest(callback, result !== undefined ? [ result ] : [], callbackScope || me)
            }, function (exception) {
                me.endAsync(async)

                if (errback)
                    errback(exception)
                else if (!me.isFinished()) {
                    me.fail("Command failed: " + exception)

                    me.processCallbackFromTest(callback, [], callbackScope || me)
                }
            })
        },


        // This method is called before mouse interactions (the "method" param, along with its "args") to assure that target is visible and reachable.
        // It also handles cases where the target is moved or made unreachable while the cursor is moving towards it.
        // In such unusual cases, a wait is added and the method calls itself to start over
        waitForTargetAndSyncMousePosition : function (target, offset, method, args, waitForTargetTop, syncMousePosition, options) {
            var originalXY
            var targetIsNotAPoint                   = this.typeOf(target) != 'Array'
            var oldSuppressPassedWaitForAssertion   = this.suppressPassedWaitForAssertion

            this.suppressPassedWaitForAssertion     = true

            var me                                  = this

            return new Promise(function (resolve, reject) {
                me.chain(
                    { waitForAnimations : [] },

                    // Initial wait for target to be
                    // 1. in the dom,
                    // 2. visible
                    targetIsNotAPoint && { waitForElementVisible : target },

                    me.autoScrollElementsIntoView
                        ?
                            function (next) {
                                if (me.scrollTargetIntoView(target, offset) === true)
                                    // me "waitFor" has been added because of Ext6 behaviour (see https://www.assembla.com/spaces/bryntum/tickets/2211#/activity/ticket:)
                                    // Ext6 listens to scroll event on grid view and sets the "pointer-event : none" on the grid view el in the handler
                                    // Problem happens during click.
                                    // Seems, depending from browser engine, "scroll" event may be fired after slight delay, already after the "mousedown"
                                    // even has been fired, then, with "pointer-events" none on grid view, grid container becomes a top element
                                    // and further `mouseup` and `click` happens on it, instead of original element
                                    // the "pointer-event" style is reset back in the another ExtJS handler, which is buffered for 100ms
                                    // so we need to wait > 100ms, waiting for 200ms
                                    // potential race condition
                                    me.waitFor(me.delayAfterScrollIntoView, next)
                                else
                                    next()
                            }
                        :
                            null,

                    function (next) {
                        var data    = me.getNormalizedTopElementInfo(target, true, method.toString(), offset)

                        // No target available, possibly page is reloading. Go back to waiting for something to appear
                        if (!data) {
                            me.waitForTarget(target, function () {
                                var data    = me.getNormalizedTopElementInfo(target, true, method.toString(), offset)

                                originalXY  = data.globalXY

                                if (me.moveCursorBetweenPoints && syncMousePosition !== false) {
                                    me.syncCursor(originalXY, next, options)
                                } else {
                                    next()
                                }
                            })

                            return
                        }

                        originalXY  = data.globalXY;

                        if (me.moveCursorBetweenPoints && syncMousePosition !== false) {
                            me.syncCursor(originalXY, next, options)
                        } else {
                            next()
                        }
                    },

                    // After moving cursor, we again wait as something might have changed in the while we moved the cursor
                    waitForTargetTop !== false && targetIsNotAPoint && function (next) {
                        me.waitForTarget(target, next, me, null, offset)
                    },

                    function (_next) {
                        var data    = me.getNormalizedTopElementInfo(target, true, method.toString(), offset)
                        var newXY   = data && data.globalXY

                        // If target has moved or disappeared, start over after a short wait
                        if (targetIsNotAPoint && (!data || originalXY[0] !== newXY[0] || originalXY[1] !== newXY[1])) {
                            me.diag(Siesta.Resource('Siesta.Test.Browser','targetMoved'))

                            me.waitFor(100, function() {
                                me.waitForTargetAndSyncMousePosition(target, offset, method, args, waitForTargetTop, syncMousePosition).then(resolve, reject)
                            });
                        } else {
                            me.suppressPassedWaitForAssertion = oldSuppressPassedWaitForAssertion;

                            // Here we're done - call original method if its a function
                            method && method.apply && method.apply(me, args)

                            resolve()
                        }
                    }
                )
                // eof chain
            })
            // eof promise
        },


        getCursorPagePosition : function () {
            return [
                this.viewportXtoPageX(this.simulator.currentPosition[ 0 ]),
                this.viewportYtoPageY(this.simulator.currentPosition[ 1 ])
            ]
        },


        // el - the target
        // callback
        // scope
        // options for the events emitted
        // actionName (string) - the method of simulator to call (will return promise)
        // offset
        // performTargetCheck, true to waitFor target appearing - false to avoid
        genericMouseAction : function (el, callback, scope, options, actionName, offset, waitForTargetAndSyncMousePosition) {
            var me          = this

            if (this.typeOf(el) == 'Function') {
                scope       = callback
                callback    = el
                el          = null
            }

            waitForTargetAndSyncMousePosition = waitForTargetAndSyncMousePosition && Boolean(el);

            el              = el || this.getCursorPagePosition()

            var targetCheckPromise = waitForTargetAndSyncMousePosition !== false ? this.waitForTargetAndSyncMousePosition(el, offset, actionName, undefined, undefined, undefined, options) : Promise.resolve()

            return me.runPromiseAsync(targetCheckPromise.then(function () {
                options         = options ? Joose.O.copy(options) : {}

                // skip warning about clicking in an unreachable point of the element at me step
                // when mouse position is not yet updated
                // potentially the element will become reachable when the mouse is moved to the required point
                var data        = me.getNormalizedTopElementInfo(el, true, actionName, offset)

                if (!data) {
                    // No point in continuing
                    return
                }

                // marking data as preliminary, indicating that it should be updated before the click
                data.originalEl     = el
                data.method         = actionName
                data.offset         = offset

                options.clientX     = options.clientX != null ? options.clientX : data.localXY[ 0 ]
                options.clientY     = options.clientY != null ? options.clientY : data.localXY[ 1 ]

                options.testUniqueId = me.uniqueId

                return me.simulator[ actionName ](data, options);
            }), 'generic click', callback, scope)
        },



        /**
         * This method will simulate a mouse click in the center of the specified DOM element,
         * or at current cursor position if no target is provided.
         *
         * Note, that it will first calculate the central point of the specified element and then
         * will pick the top-most DOM element from that point. For example, if you will provide a grid row as the `el`,
         * then click will happen on top of the central cell, and then will bubble to the row itself.
         * In most cases this is the desired behavior.
         *
         * Example:
         *
         *      t.click(t.getFirstRow(grid), function () { ... })
         *
         * The 1st argument for this method can be omitted. In this case, Siesta will use the current cursor position:
         *
         *      t.click(function () { ... })
         *
         * This method returns a `Promise` which is resolved once the click has completed:
         *
         *      t.click('#someEl').then(function () {
         *          return t.click('#anotherEl')
         *      }).then(function () {
         *          return t.click('#yetAnotherEl')
         *      })
         *
         * See also {@link Siesta.Test#chain chain} method for slimer chaining notation.
         *
         * @param {Siesta.Test.ActionTarget} [el] One of the {@link Siesta.Test.ActionTarget} values to convert to DOM element
         * @param {Function} [callback] A function to call after the click
         * @param {Object} [scope] The scope for the callback
         * @param {Object} [options] Any options to use for the simulated DOM event
         * @param {Array} [offset] An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "100%-2"]
         * to click in the center horizontally and 2px from the bottom edge.
         * @return {Promise} Returns a promise resolved once the click has completed
         */
        click : function (el, callback, scope, options, offset, waitForTarget) {
            return this.genericMouseAction(el, callback, scope, options, 'simulateMouseClick', offset, waitForTarget)
        },


        /**
         * This method will simulate a mouse right click in the center of the specified DOM/Ext element,
         * or at current cursor position if no target is provided.
         *
         * Note, that it will first calculate the centeral point of the specified element and then
         * will pick the top-most DOM element from that point. For example, if you will provide a grid row as the `el`,
         * then click will happen on top of the central cell, and then will bubble to the row itself.
         * In most cases this is the desired behavior.
         *
         * Example:
         *
         *      t.rightClick(t.getFirstRow(grid), function () { ... })
         *
         * The 1st argument for this method can be omitted. In this case, Siesta will use the current cursor position:
         *
         *      t.rightClick(function () { ... })
         *
         * This method returns a `Promise` which is resolved once the right click has completed
         *
         * @param {Siesta.Test.ActionTarget} [el] One of the {@link Siesta.Test.ActionTarget} values to convert to DOM element
         * @param {Function} [callback] A function to call after click.
         * @param {Object} [scope] The scope for the callback
         * @param {Object} [options] Any options to use for the simulated DOM event
         * @param {Array} [offset] An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "100%-2"]
         * to click in the center horizontally and 2px from the bottom edge.
         * @return {Promise} Returns a promise resolved once the right click has completed
         */
        rightClick : function (el, callback, scope, options, offset, waitForTarget) {
            return this.genericMouseAction(el, callback, scope, options, 'simulateRightClick', offset, waitForTarget)
        },


        /**
         * This method will simulate a mouse double click in the center of the specified DOM/Ext element,
         * or at current cursor position if no target is provided.
         *
         * Note, that it will first calculate the centeral point of the specified element and then
         * will pick the top-most DOM element from that point. For example, if you will provide a grid row as the `el`,
         * then click will happen on top of the central cell, and then will bubble to the row itself.
         * In most cases this is the desired behavior.
         *
         * Example:
         *
         *      t.doubleClick(t.getFirstRow(grid), function () { ... })
         *
         * The 1st argument for this method can be omitted. In this case, Siesta will use the current cursor position:
         *
         *      t.doubleClick(function () { ... })
         *
         * This method returns a `Promise` which is resolved once the double click has completed
         *
         * @param {Siesta.Test.ActionTarget} [el] One of the {@link Siesta.Test.ActionTarget} values to convert to DOM element
         * @param {Function} [callback] A function to call after click.
         * @param {Object} [scope] The scope for the callback
         * @param {Object} [options] Any options to use for the simulated DOM event
         * @param {Array} [offset] An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "100%-2"]
         * to click in the center horizontally and 2px from the bottom edge.
         * @return {Promise} Returns a promise resolved once the double click has completed
         */
        doubleClick : function (el, callback, scope, options, offset, waitForTarget) {
            return this.genericMouseAction(el, callback, scope, options, 'simulateDoubleClick', offset, waitForTarget)
        },


        /**
         * This method will simulate a mousedown event in the center of the specified DOM element,
         * or at current cursor position if no target is provided.
         *
         * @param {Siesta.Test.ActionTarget} el
         * @param {Object} options any extra options used to configure the DOM event
         * @param {Array} [offset] An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "100%-2"]
         * to click in the center horizontally and 2px from the bottom edge.
         * @param {Function} [callback] A function to call after mousedown.
         * @param {Object} [scope] The scope for the callback
         * @return {Promise} Returns a promise resolved once the action has completed
         */
        mouseDown : function (el, options, offset, callback, scope, performTargetCheck) {
            return this.genericMouseAction(el, callback, scope, options, 'simulateMouseDown', offset, performTargetCheck);
        },


        /**
         * This method will simulate a mousedown event in the center of the specified DOM element,
         * or at current cursor position if no target is provided.
         *
         * @param {Siesta.Test.ActionTarget} el
         * @param {Object} options any extra options used to configure the DOM event
         * @param {Array} [offset] An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "100%-2"]
         * to click in the center horizontally and 2px from the bottom edge.
         * @return {Promise} Returns a promise resolved once the action has completed
         */
        mouseUp : function (el, options, offset, callback, scope) {
            return this.genericMouseAction(el, callback, scope, options, 'simulateMouseUp', offset, true);
        },


        /**
         * This method will simulate a drag and drop operation between either two points or two DOM elements.
         *
         * @param {Siesta.Test.ActionTarget} source {@link Siesta.Test.ActionTarget} value for the drag starting point
         * @param {Siesta.Test.ActionTarget} target {@link Siesta.Test.ActionTarget} value for the drag end point
         * @param {Function} [callback] To run this method async, provide a callback method to be called after the drag operation is completed.
         * @param {Object} [scope] the scope for the callback
         * @param {Object} options any extra options used to configure the DOM event
         * @param {Boolean} dragOnly true to skip the mouseup and not finish the drop operation.
         * @param {Array} [sourceOffset] An X,Y offset relative to the source. Example: [20, 20] for 20px or ["50%", "100%-2"] to click in the center horizontally and 2px from the bottom edge.
         * @param {Array} [targetOffset] An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "100%-2"] to click in the center horizontally and 2px from the bottom edge.
         * @return {Promise} Returns a promise resolved once the action has completed
         */
        dragTo : function (source, target, callback, scope, options, dragOnly, sourceOffset, targetOffset) {
            var me              = this;

            if (!target) throw new Error('No drag target defined');

            source              = source || me.getCursorPagePosition()

            return new Promise(function (resolve, reject) {

                me.chain(
                    { mouseDown : source, offset : sourceOffset, options : options },

                    function (next) {
                        var data    = me.getNormalizedTopElementInfo(target, true, 'dragTo', targetOffset);

                        target      = data.globalXY;

                        next();
                    },

                    { moveCursorTo : function () { return target }, options : options },

                    dragOnly ? null : { mouseUp : null, options : options },

                    function () {
                        me.processCallbackFromTest(callback, null, scope || me);

                        resolve()
                    }
                );
            })
        },


        /**
         * This method will simulate a drag and drop operation from a point (or DOM element) and move by a delta.
         *
         * @param {Siesta.Test.ActionTarget} source {@link Siesta.Test.ActionTarget} value as the drag starting point
         * @param {Array} delta The amount to drag from the source coordinate, expressed as [x,y]. E.g. [50, 10] will drag 50px to the right and 10px down.
         * @param {Function} [callback] To run this method async, provide a callback method to be called after the drag operation is completed.
         * @param {Object} [scope] the scope for the callback
         * @param {Object} options any extra options used to configure the DOM event
         * @param {Boolean} dragOnly true to skip the mouseup and not finish the drop operation.
         * @param {Array} [offset] An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "100%-2"] to click in the center horizontally and 2px from the bottom edge.
         * @return {Promise} Returns a promise resolved once the action has completed
         */
        dragBy : function (source, delta, callback, scope, options, dragOnly, offset) {
            var me              = this;

            if (!delta) throw new Error('No drag delta defined');

            source              = source || this.getCursorPagePosition()

            return new Promise(function (resolve, reject) {
                me.chain(
                    { mouseDown : source, offset : offset, options : options },

                    { moveCursorBy : delta, options : options },

                    dragOnly ? null : { mouseUp : null, options : options },

                    function () {
                        me.processCallbackFromTest(callback, null, scope || me);

                        resolve()
                    }
                );
            })
        },


        /**
         * This method will simulate a wheel event on the specified DOM element.
         *
         * @param {Siesta.Test.ActionTarget} [el] One of the {@link Siesta.Test.ActionTarget} values to convert to a DOM element
         * @param {Function} [callback] A function to call after the action.
         * @param {Object} [scope] The scope for the callback
         * @param {Object} [options] Any options to use for the simulated DOM event
         * @param {Object} options any extra options used to configure the DOM event
         * @param {Object} options.deltaX a double representing the horizontal scroll amount.
         * @param {Object} options.deltaY a double representing the vertical scroll amount. Not supported in native events simulation.
         * @param {Object} options.deltaZ a double representing scroll amount for the z-axis. Not supported in native events simulation.
         * @param {Array} [offset] An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "100%-2"] to click in the center horizontally and 2px from the bottom edge.
         * @return {Promise} Returns a promise resolved once the action has completed
         */
        wheel : function (el, callback, scope, options, offset, waitForTarget) {
            return this.genericMouseAction(el, callback, scope, options, 'simulateMouseWheel', offset, waitForTarget)
        }
    }
});
;
/**
@class Siesta.Test.UserAgent.Keyboard

This is a mixin, providing the keyboard events simulation functionality.


*/

Role('Siesta.Test.UserAgent.Keyboard', {

    requires        : [ 'normalizeElement', 'runPromiseAsync', 'activeElement' ],

    does : [
        Siesta.Util.Role.CanFormatStrings,
        Siesta.Test.Browser.Role.CanWorkWithKeyboard
    ],

    has : {
    },

    methods: {

        /**
         * This method will simulate keyboard typing on either a provided DOM element, or, if omitted, on the currently focuced DOM element.
         * Simulation of certain special keys such as ENTER, ESC, LEFT etc is supported.
         * You can type these special keys by using the all uppercase name the key inside square brackets: `[ENTER]`, `[BACKSPACE]`.
         * See {@link Siesta.Test.UserAgent.KeyCodes} for a list of key names.
         *
         * For example:
         *
    t.type(el, 'Foo bar[ENTER]', function () {
        ...
    })
         *
         * To type the `[ENTER]` as plain text and not as a special character - use double square brackets: `[[ENTER]]`
         *
         * To specify a control key like "shift/control/alt" of to be pressed during typing, use the `options` argument, for example:

    t.type(el, 'Foo bar[ENTER]', callback, scope, { shiftKey : true, ctrlKey : true, altKey : true });

         *
         * This method returns a `Promise` which is resolved once the click has completed:
         *
         *      t.type('#someEl', 'someText').then(function () {
         *          return t.type('#anotherEl', 'someText')
         *      }).then(function () {
         *          return t.type('#yetAnotherEl', 'someText')
         *      })
         *
         * See also {@link Siesta.Test#chain chain} method for slimer chaining notation.
         *
         * @param {Siesta.Test.ActionTarget} el The element to type into. If not provided, currently focused element will be used as target.
         * @param {String} text The text to type, including any names of special keys in square brackets.
         * @param {Function} callback A function to be called after the type operation is completed.
         * @param {Object} scope The scope for the callback
         * @param {Object} options (optional) any extra options used to configure the DOM key events (like holding shiftKey, ctrlKey, altKey etc).
         * @param {Boolean} clearExisting (optional) true to clear existing text in the target before typing
         *
         * @return {Promise} Returns a promise resolved once the action has completed
         */
        type : function (el, text, callback, scope, options, clearExisting, performTargetCheck) {
            if (text == null) throw 'Must supply a string to type';

            // Skip target check if user is simply targeting whatever is focused
            if (!el) performTargetCheck = false;

            el              = el || this.activeElement();

            var targetCheckPromise =
                performTargetCheck !== false
                    ?
                this.waitForTargetAndSyncMousePosition(el, null, 'Type: ' + text, [], false, false)
                    :
                Promise.resolve()

            var me          = this

            return me.runPromiseAsync(targetCheckPromise.then(function () {
                el              = me.normalizeElement(el);

                if (!el || el.disabled) {
                    return;
                }

                if (clearExisting) {
                    el.value    = ''
                }

                var queue       = new Siesta.Util.Queue({
                    deferer         : me.originalSetTimeout,
                    deferClearer    : me.originalClearTimeout,

                    interval        : me.simulator.actionDelay,
                    callbackDelay   : me.simulator.afterActionDelay,

                    observeTest     : me
                })

                // Manually focus the element to type into first
                queue.addStep({
                    processor       : function () {
                        me.focus(el)
                    }
                })

                // focus the element one more time for IE - me seems to fix the weird sporadic failures in 042_keyevent_simulation3.t.js
                // failures are caused by the field "blur" immediately after 1st focus
                // no Ext "focus/blur" methods seems to be called, so it can be a browser behavior
                bowser.msie && queue.addStep({
                    processor       : function () {
                        me.focus(el)
                    }
                })

                queue.addStep({
                    isAsync         : true,

                    processor       : function (stepData) {
                        var promise     = me.simulator.simulateType(text, options, { el : el })

                        me.runPromiseAsync(promise, '', stepData.next)
                    }
                })

                return new Promise(function (resolve, reject) {
                    queue.run(function () {
                        resolve()
                    })
                })
            }), 'type : `' + text + '`', callback, scope)
        },

        /**
         * @param {Siesta.Test.ActionTarget} el
         * @param {String} key
         * @param {Object} options any extra options used to configure the DOM event. This argument can be omitted.
         * @param {Function} callback A function to be called after the type operation is completed.
         * @param {Object} scope The scope for the callback
         *
         * @return {Promise} Returns a promise resolved once the action has completed
         *
         * This method will simluate the key press, translated to the specified DOM element. It is generally exactly equivalent of
         * typing a single character, special characters are supported in the same way as in {@link #type} method.
         */
        keyPress: function (el, key, options, callback, scope) {
            if (typeof options === 'function') {
                callback        = options;
                options         = undefined;
            }

            return this.type(el, key, callback, scope, options)
        }
    }
});


;
/**
@class Siesta.Test.UserAgent.Touch

This is a mixin, providing the touch events simulation functionality.
*/
Role('Siesta.Test.UserAgent.Touch', {

    requires        : [
        'normalizeElement'
    ],

    has: {
        notSupportedWarned  : false
    },


    methods: {

        checkTouchEventsSupport : function () {
            var supports        = Siesta.Project.Browser.FeatureSupport().supports

            var root            = this.getRootTest()

            if (!supports.TouchEvents && !supports.PointerEvents && !supports.MSPointerEvents && !root.notSupportedWarned) {
                root.notSupportedWarned = true

                this.warn("Touch events are not supported by browser. For Chrome, you can enable them, by launching it with: --args --touch-events")
            }
        },

        /**
         * This method taps the passed target, which can be of several different types, see {@link Siesta.Test.ActionTarget}
         *
         * @param {Siesta.Test.ActionTarget} target Target for this action
         * @param {Function} callback (optional) A function to call after action.
         * @param {Object} scope (optional) The scope for the callback
         * @param {Object} options (optional) Any options that will be used when simulating the event. For information about possible
         * config options, please see: <https://developer.mozilla.org/en-US/docs/DOM/event.initMouseEvent>
         * @param {Array} offset (optional) An X,Y offset relative to the target. Example: [20, 20] for 20px or
         * ["50%", "100%-2"] to click in the center horizontally and 2px from the bottom edge.
         */
        tap : function (target, callback, scope, options, offset, performTargetCheck) {
            this.checkTouchEventsSupport()

            target      = target || this.getCursorPagePosition()

            if (performTargetCheck !== false && callback) {
                this.waitForTargetAndSyncMousePosition(
                    target, offset, this.tap, [ target, callback, scope, options, offset, false ]
                );
                return;
            }

            var context     = this.getNormalizedTopElementInfo(target, true, 'tap', offset);

            if (!context) {
                callback && callback.call(scope || this);

                return;
            }

            this.runPromiseAsync(
                this.simulator.simulateTap(context, options),
                'tap',
                callback,
                scope
            )
        },


        /**
         * This method double taps the passed target, which can be of several different types, see {@link Siesta.Test.ActionTarget}
         *
         * @param {Siesta.Test.ActionTarget} target Target for this action
         * @param {Function} callback (optional) A function to call after action.
         * @param {Object} scope (optional) The scope for the callback
         * @param {Object} options (optional) Any optionsthat will be used when simulating the event. For information about possible
         * config options, please see: <https://developer.mozilla.org/en-US/docs/DOM/event.initMouseEvent>
         * @param {Array} offset (optional) An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "100%-2"] to click in the center horizontally and 2px from the bottom edge.
         */
        doubleTap : function (target, callback, scope, options, offset, performTargetCheck) {
            this.checkTouchEventsSupport()

            target      = target || this.getCursorPagePosition()

            if (performTargetCheck !== false && callback) {
                this.waitForTargetAndSyncMousePosition(
                    target, offset, this.doubleTap, [ target, callback, scope, options, offset, false ]
                );
                return;
            }

            var context = this.getNormalizedTopElementInfo(target, true, 'doubleTap', offset);

            if (!context) {
                callback && callback.call(scope || this);

                return;
            }

            this.runPromiseAsync(
                this.simulator.simulateDoubleTap(context, options),
                'doubleTap',
                callback,
                scope
            )
        },


        // backward-compat with SenchaTouch class, which used to have all lower-cased method
        longpress : function () {
            return this.longPress.apply(this, arguments)
        },


        /**
         * This performs a long press on the passed target, which can be of several different types, see {@link Siesta.Test.ActionTarget}
         *
         * @param {Siesta.Test.ActionTarget} target Target for this action
         * @param {Function} callback (optional) A function to call after action.
         * @param {Object} scope (optional) The scope for the callback
         * @param {Object} options (optional) Any optionsthat will be used when simulating the event. For information about possible
         * config options, please see: <https://developer.mozilla.org/en-US/docs/DOM/event.initMouseEvent>
         * @param {Array} offset (optional) An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "100%-2"] to click in the center horizontally and 2px from the bottom edge.
         */
        longPress : function (target, callback, scope, options, offset, performTargetCheck) {
            this.checkTouchEventsSupport()

            target      = target || this.getCursorPagePosition()

            if (performTargetCheck !== false && callback) {
                this.waitForTargetAndSyncMousePosition(
                    target, offset, this.longPress, [ target, callback, scope, options, offset, false ]
                );
                return;
            }

            var context = this.getNormalizedTopElementInfo(target, true, 'longPress', offset);

            if (!context) {
                callback && callback.call(scope || this);

                return;
            }

            this.runPromiseAsync(
                this.simulator.simulateLongPress(context, options),
                'longPress',
                callback,
                scope
            )
        },


        /**
         * This method performs a pinch between the two specified points. It draws a line between the specified points and then moves 2 touches along that line,
         * so that the final distance between the touches becomes `scale * original distance`.
         *
         * This method can be called either in the full form with 2 different targets:
         *

    t.pinch("#grid > .col1", "#grid > .col2", 3, function () { ... })

         * or, in the short form, where the 2nd target argument is omitted:
         *

    t.pinch("#grid > .col1", 3, function () { ... })

         * In the latter form, `target2` is considered to be the same as `target1`.
         *
         * If `target1` and `target2` are the same, and no offsets are provided, offsets are set to the following values:
         *

    offset1     = [ '25%', '50%' ]
    offset2     = [ '75%', '50%' ]

         *
         *
         * @param {Siesta.Test.ActionTarget} target1 First point for pinch
         * @param {Siesta.Test.ActionTarget} target2 Second point for pinch. Can be omitted, in this case both points will belong to `target1`
         * @param {Number} scale The multiplier for a final distance between the points
         * @param {Function} callback A function to call after the pinch has completed
         * @param {Object} scope A scope for the `callback`
         * @param {Object} options (optional) Any optionsthat will be used when simulating the event. For information about possible
         * config options, please see: <https://developer.mozilla.org/en-US/docs/DOM/event.initMouseEvent>
         * @param {Array} offset1 An X,Y offset relative to the target1. Example: [20, 20] for 20px or ["50%", "100%-2"]
         * for the point in the center horizontally and 2px from the bottom edge.
         * @param {Array} offset2 An X,Y offset relative to the target1. Example: [20, 20] for 20px or ["50%", "100%-2"]
         * for the point in the center horizontally and 2px from the bottom edge.
         */
        pinch : function (target1, target2, scale, callback, scope, options, offset1, offset2) {
            this.checkTouchEventsSupport()

            var me          = this;

            if (this.typeOf(target2) == 'Number') {
                offset2     = offset1
                offset1     = options
                options     = scope
                scope       = callback
                callback    = scale
                scale       = target2
                target2     = target1
            }

            if (target2 == null) target2 = target1

            if (target1 == target2 && !offset1 && !offset2) {
                offset1     = [ '25%', '50%' ]
                offset2     = [ '75%', '50%' ]
            }

            var context1    = this.getNormalizedTopElementInfo(target1, true, 'pinch: target1', offset1);
            var context2    = this.getNormalizedTopElementInfo(target2, true, 'pinch: target2', offset2);

            if (!context1 || !context2) {
                var R  = Siesta.Resource('Siesta.Test.Browser');

                this.waitFor({
                    method          : function () {
                        var el1     = me.normalizeElement(target1, true)
                        var el2     = me.normalizeElement(target2, true)

                        return el1 && me.elementIsTop(el1, true, offset) && el2 && me.elementIsTop(el2, true, offset)
                    },
                    callback        : function () {
                        me.pinch(target1, target2, scope, callback, scope, options, offset1, offset2)
                    },
                    assertionName   : 'waitForTarget',
                    description     : ' ' + R.get('target') + ' "' + target1 + '" and "' + target2 + '" ' + R.get('toAppear')
                });

                return
            }

            this.runPromiseAsync(
                this.simulator.simulatePinch(context1, context2, options),
                'pinch',
                callback,
                scope
            )
        },


        /**
         * This method will simulate a drag and drop operation between either two points or two DOM elements.
         *
         * @param {Siesta.Test.ActionTarget} source {@link Siesta.Test.ActionTarget} value for the drag starting point
         * @param {Siesta.Test.ActionTarget} target {@link Siesta.Test.ActionTarget} value for the drag end point
         * @param {Function} callback A function to call after the drag operation is completed.
         * @param {Object} scope (optional) the scope for the callback
         * @param {Object} options (optional) Any optionsthat will be used when simulating the event. For information about possible
         * config options, please see: <https://developer.mozilla.org/en-US/docs/DOM/event.initMouseEvent>
         * @param {Boolean} dragOnly true to skip the mouseup and not finish the drop operation.
         * @param {Array} sourceOffset (optional) An X,Y offset relative to the source. Example: [20, 20] for 20px or ["50%", "100%-2"] to click in the center horizontally and 2px from the bottom edge.
         * @param {Array} targetOffset (optional) An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "100%-2"] to click in the center horizontally and 2px from the bottom edge.
         */
        touchDragTo : function (source, target, callback, scope, options, dragOnly, sourceOffset, targetOffset) {
            var me          = this
            var context1    = this.getNormalizedTopElementInfo(source, true, 'touchDragTo: source', sourceOffset);
            var context2    = this.getNormalizedTopElementInfo(target, true, 'touchDragTo: target', targetOffset);

            if (!context1 || !context2) {
                var R  = Siesta.Resource('Siesta.Test.Browser');

                this.waitFor({
                    method          : function () {
                        var el1     = me.normalizeElement(source, true)
                        var el2     = me.normalizeElement(target, true)

                        return el1 && me.elementIsTop(el1, true, sourceOffset) && el2 && me.elementIsTop(el2, true, targetOffset)
                    },
                    callback        : function () {
                        me.touchDragTo(source, target, callback, scope, options, dragOnly, sourceOffset, targetOffset)
                    },
                    assertionName   : 'waitForTarget',
                    description     : ' ' + R.get('target') + ' "' + source + '" and "' + target + '" ' + R.get('toAppear')
                });

                return
            }

            this.runPromiseAsync(
                this.simulator.simulateTouchDrag(context1.localXY, context2.localXY, options, dragOnly),
                'touchDragTo',
                callback,
                scope
            )
        },


        /**
         * This method will simulate a drag and drop operation from a point (or DOM element) and move by a delta.
         *
         * @param {Siesta.Test.ActionTarget} source {@link Siesta.Test.ActionTarget} value as the drag starting point
         * @param {Array} delta The amount to drag from the source coordinate, expressed as [ x, y ]. E.g. [ 50, 10 ] will drag 50px to the right and 10px down.
         * @param {Function} callback A function to call after the drag operation is completed.
         * @param {Object} scope (optional) the scope for the callback
         * @param {Object} options (optional) Any optionsthat will be used when simulating the event. For information about possible
         * config options, please see: <https://developer.mozilla.org/en-US/docs/DOM/event.initMouseEvent>
         * @param {Boolean} dragOnly true to skip the mouseup and not finish the drop operation.
         * @param {Array} offset (optional) An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "100%-2"] to click in the center horizontally and 2px from the bottom edge.
         */
        touchDragBy : function (source, delta, callback, scope, options, dragOnly, offset) {
            var me      = this;
            var context = this.getNormalizedTopElementInfo(source, true, 'touchDragBy', offset);

            if (!context) {
                this.waitForTarget(source, function() {
                    this.touchDragBy(source, delta, callback, scope, options, dragOnly, offset)
                }, this, null, offset)

                return
            }

            var sourceXY        = context.globalXY;
            var targetXY        = [ sourceXY[ 0 ] + delta[ 0 ], sourceXY[ 1 ] + delta[ 1 ] ];

            this.runPromiseAsync(
                this.simulator.simulateTouchDrag(sourceXY, targetXY, options, dragOnly),
                'touchDragBy',
                callback,
                scope
            )
        },


        /**
         * This method will simulate a swipe operation between either two points or on a single DOM element.
         *
         * @param {Siesta.Test.ActionTarget} target Target for this action
         * @param {String} direction Either 'left', 'right', 'up' or 'down'
         * @param {Function} callback A function to call after the swing operation is completed
         * @param {Object} scope (optional) the scope for the callback
         * @param {Object} options (optional) Any options that will be used when simulating the event. For information about possible
         * config options, please see: <https://developer.mozilla.org/en-US/docs/DOM/event.initMouseEvent>
         */
        swipe : function (target, direction, callback, scope, options, performTargetCheck) {
            this.checkTouchEventsSupport()

            target      = target || this.getCursorPagePosition()

            if (performTargetCheck !== false && callback) {
                this.waitForTargetAndSyncMousePosition(
                    target, null, this.swipe, [ target, direction, callback, scope, options, false ]
                );
                return;
            }

            var context = this.getNormalizedTopElementInfo(target, true, 'swipe');

            if (!context) {
                callback && callback.call(scope || this);

                return;
            }

            var Ext     = this.Ext()
            var R       = Siesta.Resource('Siesta.Test.SenchaTouch')

            var box     = Ext.fly(context.el).getBox(),
                x       = box.x,
                y       = box.y,
                width   = box.width,
                height  = box.height,
                centerX = x + width / 2,
                centerY = y + height / 2,
                start,
                end,
                edgeCoef    = 0.1

            // Since this method accepts elements as target, we need to assure that we swipe at least about 150px
            // using Math.max below etc
            switch (direction) {
                case 'u':
                case 'up':
                    start       = [ centerX, y + height * (1 - edgeCoef) ];
                    end         = [ centerX, y + height * edgeCoef ];

                    end[ 1 ]    = Math.min(start[ 1 ] - 100, end[ 1 ]);
                break;

                case 'd':
                case 'down':
                    start       = [ centerX, y + height * edgeCoef ];
                    end         = [ centerX, y + height * (1 - edgeCoef) ];

                    end[ 1 ]    = Math.max(start[ 1 ] + 100, end[ 1 ]);
                break;

                case 'r':
                case 'right':
                    start       = [ x + width * edgeCoef, centerY ];
                    end         = [ x + width * (1 - edgeCoef), centerY ];

                    end[ 0 ]    = Math.max(start[ 0 ] + 100, end[ 0 ]);
                break;

                case 'l':
                case 'left':
                    start       = [ x + width * (1 - edgeCoef), centerY ];
                    end         = [ x + width * edgeCoef, centerY ];

                    end[ 0 ]    = Math.min(start[ 0 ] - 100, end[ 0 ]);
                break;

                default:
                    throw R.get('invalidSwipeDir') + ': ' + direction;
            }

            this.touchDragTo(start, end, callback, scope, options);
        }
    }
});;
/**

 @class Siesta.Test.TextSelection

 This is a mixin providing text selection functionality.

 */
Role('Siesta.Test.TextSelection', {

    methods : {
        /**
         * Utility method which returns the selected text in the passed element or in the document
         * @param {Siesta.Test.ActionTarget} el The element
         * @return {String} The selected text
         */
        getSelectedText : function (el) {
            el      = this.normalizeElement(el);

            if ('selectionStart' in el) {
                try {
                    return el.value.substring(el.selectionStart, el.selectionEnd);
                } catch (e) {
                    // the "email" and "number" input fields (possibly some other too) does not allow to access
                    // the "selectionStart/End" properties and throws exceptions
                }
            }

            var win = this.global,
                doc = win.document;

            if (win.getSelection) {
                return win.getSelection().toString();
            } else if (doc.getSelection) {
                return doc.getSelection();
            } else if (doc.selection) {
                return doc.selection.createRange().text;
            }
        },

        /**
         * Utility method which selects text in the passed element (should be an &lt;input&gt; element).
         * @param {Siesta.Test.ActionTarget} el The element
         * @param {Int} start (optional) The selection start index
         * @param {Int} end (optional) The selection end index
         */
        selectText : function (el, start, end, callback) {
            el          = this.normalizeElement(el, true);

            if (el && this.elementSupportsSelection(el)) {

                var v       = el.value || el.innerHTML,
                    doFocus = true;

                if (v.length > 0) {
                    start   = start === undefined ? 0 : start;
                    end     = end === undefined ? v.length : end;

                    if (el.setSelectionRange) {
                        try {
                            // can throw exception in IE9 (if element is not visible)
                            el.setSelectionRange(start, end);
                        } catch (e) {
                        }
                    } else if (el.createTextRange) {
                        var R = el.createTextRange();

                        R.moveStart('character', start);
                        R.moveEnd('character', end - v.length);

                        R.select();
                    }

                    doFocus = bowser.gecko || bowser.opera;
                }

                if (doFocus) {
                    this.focus(el);
                }
            }

            callback && callback.call(this);
        },

        // Returns undefined if caret pos cannot be determined (older IEs with contentEditable)
        getCaretPosition : function (el) {
            var pos;

            var win         = this.global;
            var document    = win.document;

            if ('selectionStart' in el) {
                try {
                    // the exception can be thrown in case of manipulating with input#type=email fields
                    // and possibly some other input types
                    pos     = el.selectionStart;
                } catch (e) {
                    pos     = null
                }
            } else if (win.getSelection && this.isEditableNode(el)){
                var sel     = win.getSelection();

                if (sel.rangeCount) {
                    var range = sel.getRangeAt(0);

                    if (range.commonAncestorContainer.parentNode == el) {
                        pos = range.endOffset;
                    }
                }
            } else if (document.selection) { // Legacy IE
                this.focus(el)

                var oSel    = document.selection.createRange();

                oSel.moveStart('character', -el.value.length);

                pos         = oSel.text.length;
            }

            return pos;
        },


        setCaretPosition : function (el, caretPos) {
            if (el.createTextRange) {
                // seems range methods throws sometimes in IE
                try {
                    var range = el.createTextRange();

                    range.move('character', caretPos);
                    range.select();
                } catch (e) {
                }
            } else {

                if (el.setSelectionRange) {
                    this.focus(el)

                    try {
                        // the exception can be thrown in case of manipulating with input#type=email fields
                        // and possibly some other input types
                        el.setSelectionRange(caretPos, caretPos);
                    } catch (e) {
                    }

                } else {
                    this.focus(el)
                }
            }
        },

        moveCaretPosition : function (el, distance) {
            var pos = Math.min(Math.max(0, this.getCaretPosition(el) + distance), el.value.length);

            this.setCaretPosition(el, pos);
        },

        elementSupportsSelection : function (el) {
            var tagName    = el.tagName.toLowerCase();
            var inputTypes = /^text|password|tel|url|search$/i;

            return tagName === 'textarea' || tagName === 'input' && inputTypes.test(el.getAttribute('type'));
        }
    }
})
;
/**
@class Siesta.Test.Element

This is a mixin, with helper methods for testing functionality relating to DOM elements. This mixin is consumed by {@link Siesta.Test}

*/
Role('Siesta.Test.Element', {

    does        : [
        Siesta.Util.Role.CanCalculatePageScroll,
        Siesta.Util.Role.Dom
    ],

    requires    : [
        'typeOf',
        'chain',
        'normalizeElement'
    ],

    has : {
        allowMonkeyToClickOnAnchors     : false,

        allowedCharacters               : function () {
            return {
                // does not include TAB by purpose, because our "TAB" simulation is not perfect
                // Also exclude BACKSPACE since it navigates the page
                special     : 'ENTER/ESCAPE/PAGE-UP/PAGE-DOWN/END/HOME/UP/RIGHT/DOWN/LEFT/INSERT/DELETE',
                // does not inlcude * because Ext fails on typing it
                punctuation : '.,/()[]{}\\"\'`~!?@#$%^&_=+-',
                normal      : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
            }
        }
    },

    methods : {

        /**
         * Utility method which returns the center of a passed element. The coordinates are by default relative to the
         * containing document of the element (so for example if the element is inside of the nested iframe, coordinates
         * will be "local" to that iframe element). To get coordinates relative to the test iframe ("global" coordinates),
         * pass `local` as `false`.
         *
         * @param {Siesta.Test.ActionTarget} el The element to find the center of.
         * @param {Boolean} [local] Pass `true` means coordinates are relative to the containing document. This is the default value.
         * Pass `false` to make sure the coordinates are global to the test window.
         *
         * @return {Array} The array first element of which is the `x` coordinate and 2nd - `y`
         */
        findCenter : function (target, local) {
            return this.getTargetCoordinate(target, local);
        },


        isInDom : function (el) {
            var doc     = el.ownerDocument

            if (!doc) return false

            while (el && el != doc.body) {
                el      = el.parentNode
            }

            return Boolean(el)
        },


        normalizeOffset : function (offset, $el) {
            var parts;

            if (this.typeOf(offset) == 'Function') offset = offset.call(this)

            offset              = offset && offset.slice() || [ '50%', '50%' ];

            var rect            = this.getBoundingClientRect($el[ 0 ])

            // The rounding rules are still magical
            // one is for sure, that if we get a precise whole number w/o fractional part
            // we subtract 1 from it, since pixel counting starts from 0
            // when we have fractional part, in good browsers it seems its enough to throw it away with `floor`
            // in IE we additionally need to subtract 1
            // following the conservative path and subtracting 1 in all browsers

            var width           = Math.floor(rect.width)
//            if (bowser.msie || bowser.edge || width === rect.width) width--
            width--

            var height          = Math.floor(rect.height)
//            if (bowser.msie || bowser.edge || height === rect.height) height--
            height--

            if (typeof (offset[ 0 ]) === 'string') {
                parts           = offset[ 0 ].split('%');
                offset[ 0 ]     = parseInt(offset[ 0 ].match(/\d+/)[ 0 ], 10) * width / 100;

                if (parts[ 1 ]) {
                    offset[ 0 ] += parseInt(parts[ 1 ]);
                }
            }

            offset[ 0 ]         = Math.round(offset[ 0 ])

            if (typeof (offset[ 1 ]) === 'string') {
                parts           = offset[ 1 ].split('%');
                offset[ 1 ]     = parseInt(offset[ 1 ].match(/\d+/)[ 0 ], 10) * height / 100;

                if (parts[ 1 ]) {
                    offset[ 1 ] += parseInt(parts[ 1 ]);
                }
            }

            offset[ 1 ]         = Math.round(offset[ 1 ])

            return offset
        },


        // return viewport coordinates
        // can be simplified with just `getBoundingClientRect` ?
        getTargetCoordinate : function (target, local, offset) {
            var el              = this.normalizeElement(target),
                $el             = this.$(el),
                elOffset        = $el.offset(),
                elDoc           = el.ownerDocument,
                elWin           = elDoc.defaultView || elDoc.parentWindow,
                xy              = [ this.pageXtoViewportX(elOffset.left, elWin), this.pageYtoViewportY(elOffset.top, elWin) ]

            offset              = this.normalizeOffset(offset, $el)

            xy[ 0 ]             += offset[ 0 ];
            xy[ 1 ]             += offset[ 1 ];

            if (local === false) {
                // Potentially we're interacting with an element inside a nested frame, which means
                // the coordinates are local to that frame
                if (elWin !== this.global) {
                    var offsetsToTop    = this.$(elWin.frameElement).offset()

                    xy[ 0 ]     += this.pageXtoViewportX(offsetsToTop.left)
                    xy[ 1 ]     += this.pageYtoViewportY(offsetsToTop.top)
                }
            }

            return xy;
        },

        /**
         * Returns true if the element is visible, checking jQuery :visible selector + style visibility value.
         *
         * @param {Siesta.Test.ActionTarget} el The element
         * @return {Boolean}
         */
        isElementVisible : function(el) {
            el          = this.normalizeElement(el);

            // Workaround for OPTION elements which don't behave like normal DOM elements. jQuery always consider them invisible.
            // Decide based on visibility of the parent SELECT node
            if (el && el.nodeName.toLowerCase() === 'option') {
                el      = this.$(el).closest('select')[ 0 ]
            }

            if (el) {
                try {
                    // Jquery :visible doesn't handle SVG/VML, so manual check
                    // accessing to `this.global.SVGElement` throws exceptions for popups in IE 9
                    if (window.SVGElement && el instanceof this.global.SVGElement)
                        return el.style.display !== 'none' && el.style.visibility !== 'hidden'
                } catch (e) {
                }

                // Jquery :visible doesn't take visibility into account
                return this.$(el).is(':visible') && (this.$(el).css('visibility') !== 'hidden')
            }

            return false
        },

        /**
         * Passes if the `innerText` property of the &lt;body&gt; element contains the text passed
         *
         * @param {String} text The text to match
         * @param {String} [description] The description for the assertion
         */
        assertTextPresent : function(text, description) {
            this.like(this.global.document.body.innerText, text, description);
        },

        /**
         * Passes if the innerHTML of the passed element contains the text passed
         *
         * @param {Siesta.Test.ActionTarget} el The element to query
         * @param {String} text The text to match
         * @param {String} [description] The description for the assertion
         */
        contentLike : function(el, text, description) {
            el = this.normalizeElement(el);

            this.like(el.innerHTML, text, description);
        },

        /**
         * Passes if the innerHTML of the passed element does not contain the text passed
         *
         * @param {Siesta.Test.ActionTarget} el The element to query
         * @param {String} text The text to match
         * @param {String} [description] The description for the assertion
         */
        contentNotLike : function(el, text, description) {
            el = this.normalizeElement(el);

            this.unlike(el.innerHTML, text, description);
        },

        /**
         * Waits until the innerHTML of the passed element contains the text passed
         *
         * @param {Siesta.Test.ActionTarget} el The element to query
         * @param {String} text The text to match
         * @param {Function} callback The callback to call after the CSS selector has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForContentLike : function(el, text, callback, scope, timeout) {
            var R = Siesta.Resource('Siesta.Test.Element');

            el = this.normalizeElement(el);

            return this.waitFor({
                method          : function() { return el.innerHTML.match(text); },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForContentLike',
                description     : ' ' + R.get('elementContent') + ' "' + text + '" ' + R.get('toAppear')
            });
        },

        /**
         * Waits until the innerHTML of the passed element does not contain the text passed
         *
         * @param {Siesta.Test.ActionTarget} el The element to query
         * @param {String} text The text to match
         * @param {Function} callback The callback to call after the CSS selector has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForContentNotLike : function(el, text, callback, scope, timeout) {
            var R = Siesta.Resource('Siesta.Test.Element');

            el = this.normalizeElement(el);

            return this.waitFor({
                method          : function() { return !el.innerHTML.match(text); },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForContentNotLike',
                description     : ' ' + R.get('elementContent') + ' "' + text + '" ' + R.get('toDisappear')
            });
        },


        getRandomTypeString : function (length) {
            var allowedCharacters   = this.allowedCharacters

            var special     = allowedCharacters.special.split('/')
            var punctuation = allowedCharacters.punctuation
            var normal      = allowedCharacters.normal

            var total       = special.length + punctuation.length + normal.length

            var str         = ''

            for (var i = 0; i < length; i++) {
                var index       = this.randomBetween(0, total - 1)

                if (index < normal.length)
                    str     += normal.substr(index, 1)
                else {
                    index   -= normal.length

                    if (index < punctuation.length)
                        str     += punctuation.substr(index, 1)
                    else {
                        index   -= punctuation.length

                        str     += '[' + special[ index ] + ']'
                    }
                }
            }

            return str
        },

        /**
         * Performs clicks, double clicks, right clicks and drags at random coordinates within the passed target.
         * Also performs random key presses. You can specify an array of DOM selectors to avoid (see `skipTargets` below).
         *
         * While doing all these random actions it tracks the number of exceptions thrown and reports a failure
         * if there was any. Otherwise it reports a passed assertion.
         *
         * Use this assertion to "stress-test" your component, making sure it will work correctly in various unexpected
         * interaction scenarious.
         *
         * Note that as a special case, when this method is provided with the document's &lt;body&gt; element as a target,
         * it will test the whole browser viewport.
         *
         * This method supports two call signatures. One is with multiple positional arguments and another with single options object.
         *
         * @param {Siesta.Test.ActionTarget | Object} options The element to upon which to unleash the "monkey", or a config object with the options
         * @param {Siesta.Test.ActionTarget} options.target The element to upon which to unleash the "monkey"
         * @param {Array[String]} options.skipTargets An array of DOM selectors, for the elements inside the `target`, which will be avoided by monkeys.
         * @param {Number} options.nbrInteractions The number of random interactions to perform. Default value is 30
         * @param {String} options.description The optional description for the assertion.
         * @param {Function} options.callback The callback to call after all actions are completed
         * @param {Object} options.scope The scope for the callback
         * @param {Number} nbrInteractions The number of random interactions to perform. Default value is 30
         * @param {String} [description] The description for the assertion
         * @param {Function} callback The callback to call after all actions are completed
         * @param {Object} scope The scope for the callback
         */
        monkeyTest : function (el, nbrInteractions, description, callback, scope, stepCallback) {
            var skipTargets

            if (arguments.length === 1) {
                nbrInteractions = el.nbrInteractions
                description     = el.description
                callback        = el.callback
                scope           = el.scope
                stepCallback    = el.stepCallback
                skipTargets     = el.skipTargets

                el              = el.target
            } else {

                if (typeof nbrInteractions === 'function') {
                    callback    = nbrInteractions;
                    scope       = description;
                    description = '';
                } else if (typeof description === 'function') {
                    callback    = description;
                    description = '';
                }
            }

            skipTargets     = skipTargets || []

            // ignore actions on anchors by default, to prevent page navigation
            skipTargets.push('a')

            nbrInteractions = typeof nbrInteractions === 'number' ? nbrInteractions : 30;

            el              = this.normalizeElement(el, false, true);

            this.suppressPassedWaitForAssertion = true;

            var global      = this.global
            var isBody      = el == global.document.body

            var me          = this,
                offset      = me.$(el).offset(),
                right       = offset.left + me.$(isBody ? global : el).width(),
                bottom      = offset.top + me.$(isBody ? global : el).height();

            var actionLog   = []
            var R           = Siesta.Resource('Siesta.Test.Element');

            var queue       = new Siesta.Util.Queue({
                deferer         : me.originalSetTimeout,
                deferClearer    : me.originalClearTimeout,

                interval        : me.actionDelay,

                observeTest     : this,

                processor   : function (data) {
                    if (me.nbrExceptions || me.failed) {
                        assertionChecker()

                        // do not continue if the test has detected an exception thrown
                        queue.abort()
                    } else {
                        var async       = me.beginAsync(null, function (test) {
                            test.fail(
                                description || R.get('monkeyNoExceptions'),
                                R.get('monkeyActionLog') + ":" + JSON.stringify(actionLog)
                            )

                            return true
                        });

                        var next        = data.next

                        data.next       = function () {
                            // callback to call after each monkey action
                            stepCallback && stepCallback(data)

                            me.endAsync(async)

                            next()
                        }

                        data.action(data)
                    }
                }
            });

            var dummy       = []
            dummy.length    = nbrInteractions

            var ignoreAction    = function (data, i) {
                var target          = me.normalizeElement(data.dragFrom || data.xy)
                // Prevent also drag target as it could be a link tag
                var dragToTarget    = data.dragTo && me.normalizeElement(data.dragTo)

                for (var i = 0; i < skipTargets.length; i++) {
                    var toSkip    = me.$(skipTargets[ i ], el)

                    for (var j = 0; j < toSkip.length; j++) {
                        var skip    = toSkip[ j ]

                        if (
                            (target && (target == skip || me.contains(skip, target)))
                            || dragToTarget && (dragToTarget == skip || me.contains(skip, dragToTarget))
                        ) {
                            data.next()

                            return true
                        }
                    }
                }

                return false
            }

            Joose.A.each(dummy, function (value, i) {
                // Inject { waitForSelector : 'body' } before every monkey action to make sure we always have a body
                queue.addAsyncStep({
                    action          : function (data) {
                        me.waitForSelector('body', data.next);
                    }
                });

                var xy = [ me.randomBetween(offset.left, right), me.randomBetween(offset.top, bottom) ];

                switch (me.randomBetween(0, 4)) {
                    case 0:
                        queue.addAsyncStep({
                            action          : function (data) {
                                if (!ignoreAction(data)) {
                                    actionLog.push({ 'click' : xy })

                                    me.click(data.xy, data.next)
                                }
                            },
                            xy              : xy
                        });
                    break;

                    case 1:
                        queue.addAsyncStep({
                            action          : function (data) {
                                if (!ignoreAction(data)) {
                                    actionLog.push({ 'doubleclick' : xy })

                                    me.doubleClick(data.xy, data.next)
                                }
                            },
                            xy              : xy
                        });
                    break;

                    case 2:
                        queue.addAsyncStep({
                            action          : function (data) {
                                if (!ignoreAction(data)) {
                                    if (me.simulator.type != 'native' && "oncontextmenu" in window) {
                                        actionLog.push({ 'rightclick' : xy })

                                        me.rightClick(data.xy, data.next)
                                    } else {
                                        actionLog.push({ 'click' : xy })

                                        me.click(data.xy, data.next)
                                    }
                                }
                            },
                            xy              : xy
                        });
                    break;

                    case 3:
                        var dragTo      = [ me.randomBetween(offset.left, right), me.randomBetween(offset.top, bottom) ]

                        queue.addAsyncStep({
                            action          : function (data) {
                                if (!ignoreAction(data)) {
                                    actionLog.push({
                                        action  : 'drag',
                                        target  : xy,
                                        to      : dragTo
                                    })

                                    me.dragTo(data.dragFrom, data.dragTo, data.next)
                                }
                            },
                            dragFrom        : xy,
                            dragTo          : dragTo
                        });
                    break;

                    case 4:
                        var text = me.getRandomTypeString(15)

                        // First click somewhere then type
                        queue.addAsyncStep({
                            action          : function (data) {
                                if (!ignoreAction(data)) {
                                    actionLog.push({ 'click' : xy })

                                    me.click(data.xy, function () {
                                        me.waitForSelector('body', function () {
                                            actionLog.push({ 'type' : text.replace("'", "\\'") })

                                            me.type(null, text, data.next)
                                        });
                                    })
                                }
                            },
                            xy              : xy
                        });
                    break;
                }
            })

            var checkerActivated    = false

            var assertionChecker    = function () {
                checkerActivated    = true

                if (me.nbrExceptions || me.failed) {
                    me.fail(description || R.get('monkeyNoExceptions'), R.get('monkeyActionLog') + ":" + JSON.stringify(actionLog))
                } else
                    me.pass(description || R.get('monkeyNoExceptions'))
            }

            this.on('beforetestfinalizeearly', assertionChecker)

            queue.run(function () {
                if (!checkerActivated) {
                    me.un('beforetestfinalizeearly', assertionChecker)

                    assertionChecker()
                }

                me.suppressPassedWaitForAssertion = false;

                me.processCallbackFromTest(callback, [actionLog], scope || me)
            });
        },

        /**
         * Passes if the element has the supplied CSS classname
         *
         * @param {Siesta.Test.ActionTarget} el The element to query
         * @param {String} cls The class name to check for
         * @param {String} [description] The description for the assertion
         */
        hasCls : function (el, cls, description) {
            var R           = Siesta.Resource('Siesta.Test.Element');

            el              = this.normalizeElement(el);

            if (this.$(el).hasClass(cls)) {
                this.pass(description, {
                    descTpl     : R.get('elementHasClass') + ' {cls}',
                    cls         : cls
                });
            } else {
                this.fail(description, {
                    assertionName   : 'hasCls',

                    got             : el.className,
                    gotDesc         : R.get('elementClasses'),
                    need            : cls,
                    needDesc        : R.get('needClass')
                })
            }
        },


        /**
         * Passes if the element does not have the supplied CSS classname
         *
         * @param {Siesta.Test.ActionTarget} el The element to query
         * @param {String} cls The class name to check for
         * @param {String} [description] The description for the assertion
         */
        hasNotCls : function (el, cls, description) {
            var R           = Siesta.Resource('Siesta.Test.Element');

            el              = this.normalizeElement(el);

            if (!this.$(el).hasClass(cls)) {
                this.pass(description, {
                    descTpl         : R.get('elementHasNoClass') + ' {cls}',
                    cls             : cls
                });
            } else {
                this.fail(description, {
                    assertionName   : 'hasNotCls',
                    got             : el.className,
                    gotDesc         : R.get('elementClasses'),
                    annotation      : R.get('elementHasClass') + ' [' + cls + ']'
                })
            }
        },

        /**
         * Passes if the element has the supplied style value
         *
         * @param {Siesta.Test.ActionTarget} el The element to query
         * @param {String} property The style property to check for
         * @param {String} value The style value to check for
         * @param {String} [description] The description for the assertion
         */
        hasStyle : function (el, property, value, description) {
            var R           = Siesta.Resource('Siesta.Test.Element');

            el              = this.normalizeElement(el);

            if (this.$(el).css(property) === value) {
                this.pass(description, {
                    descTpl         : R.get('hasStyleDescTpl'),
                    value           : value,
                    property        : property
                });
            } else {
                this.fail(description, {
                    assertionName   : 'hasStyle',
                    got             : this.$(el).css(property),
                    gotDesc         : R.get('elementStyles'),
                    need            : value,
                    needDesc        :  R.get('needStyle')
                });
            }
        },


        /**
         * Passes if the element does not have the supplied style value
         *
         * @param {Siesta.Test.ActionTarget} el The element to query
         * @param {String} property The style property to check for
         * @param {String} value The style value to check for
         * @param {String} [description] The description for the assertion
         */
        hasNotStyle : function (el, property, value, description) {
            var R           = Siesta.Resource('Siesta.Test.Element');

            el              = this.normalizeElement(el);

            if (this.$(el).css(property) !== value) {
                this.pass(description, {
                    descTpl         : R.get('hasNotStyleDescTpl'),
                    value           : value,
                    property        : property
                });
            } else {
                this.fail(description, {
                    assertionName   : 'hasNotStyle',
                    got             : el.style.toString(),
                    gotDesc         : R.get('elementStyles'),
                    annotation      : R.get('hasTheStyle') + ' [' + property + ']'
                });
            }
        },

        /**
         * Waits for a certain CSS selector to be found at the passed XY coordinate, and calls the callback when found.
         * The callback will receive the element from the passed XY coordinates.
         *
         * @param {Array} xy The x and y coordinates to query
         * @param {String} selector The CSS selector to check for
         * @param {Function} callback The callback to call after the CSS selector has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test#waitForTimeout} value.
         */
        waitForSelectorAt : function(xy, selector, callback, scope, timeout) {
            var R           = Siesta.Resource('Siesta.Test.Element');

            if (!selector) throw R.get('noCssSelector');

            var me      = this

            return this.waitFor({
                method          : function() {
                    var el = me.elementFromPoint(xy[0], xy[1], true);

                    if (el && me.$(el).is(selector)) return el;
                },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForSelectorAt',
                description     : ' ' + R.get('selector') + ' "' + selector + '" ' + R.get('toAppearAt') + ': [' + xy.toString() + ']'
            });
        },

        /**
         * Waits for a certain CSS selector to be found at current cursor position, and calls the callback when found.
         * The callback will receive the element found.
         *
         * @param {String} selector The CSS selector to check for
         * @param {Function} callback The callback to call after the CSS selector has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test#waitForTimeout} value.
         */
        waitForSelectorAtCursor : function(selector, callback, scope, timeout) {
            return this.waitForSelectorAt(this.simulator.currentPosition, selector, callback, scope, timeout);
        },

        /**
         * Waits for a certain CSS selector to be found in the DOM, and then calls the callback supplied.
         * The callback will receive the results of jQuery selector.
         *
         * @param {String} selector The CSS selector to check for
         * @param {Siesta.Test.ActionTarget} root (optional) The root element in which to detect the selector.
         * @param {Function} callback The callback to call after the CSS selector has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test#waitForTimeout} value.
         */
        waitForSelector : function(selector, root, callback, scope, timeout) {
            var R           = Siesta.Resource('Siesta.Test.Element');
            var me          = this;

            if (!selector) throw R.get('noCssSelector');

            if (this.typeOf(root) == 'Function') {
                timeout     = scope;
                scope       = callback;
                callback    = root;
                root        = null;
            }

            if (root) root  = this.normalizeElement(root);

            return this.waitFor({
                method          : function() {
                    var result = me.$(selector, root);
                    if (result.length > 0) return result;
                },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForSelector',
                description     : ' ' + R.get('selector') + ' "' + selector + '" ' + R.get('toAppear')
            });
        },


        /**
         * Waits till all the CSS selectors from the provided array to be found in the DOM, and then calls the callback supplied.
         *
         * @param {Array[String]} selectors The array of CSS selectors to check for
         * @param {Siesta.Test.ActionTarget} root (optional) The root element in which to detect the selector.
         * @param {Function} callback The callback to call after the CSS selector has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test#waitForTimeout} value.
         */
        waitForSelectors : function(selectors, root, callback, scope, timeout) {
            var R           = Siesta.Resource('Siesta.Test.Element');

            if (selectors.length < 1) throw R.get('waitForSelectorsBadInput');

            if (this.typeOf(root) == 'Function') {
                timeout     = scope;
                scope       = callback;
                callback    = root;
                root        = null;
            }

            if (root) root  = this.normalizeElement(root);

            var me          = this

            return this.waitFor({
                method          :  function () {
                    var allPresent  = true

                    Joose.A.each(selectors, function (selector) {
                        if (me.$(selector, root).length === 0) {
                            allPresent = false
                            // stop iteration
                            return false
                        }
                    })

                    return allPresent
                },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForSelectors',
                description     : ' ' + R.get('selectors') + ' "' + selectors + '" ' + R.get('toAppear')
            });
        },



        /**
         * Waits for a certain CSS selector to not be found in the DOM, and then calls the callback supplied.
         *
         * @param {String} selector The CSS selector to check for
         * @param {Siesta.Test.ActionTarget} root (optional) The root element in which to detect the selector.
         * @param {Function} callback The callback to call after the CSS selector has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test#waitForTimeout} value.
         */
        waitForSelectorNotFound : function(selector, root, callback, scope, timeout) {
            var R           = Siesta.Resource('Siesta.Test.Element');
            var me          = this;

            if (!selector) throw 'A CSS selector must be supplied';

            if (this.typeOf(root) == 'Function') {
                timeout     = scope;
                scope       = callback;
                callback    = root;
                root        = null;
            }

            if (root) root  = this.normalizeElement(root);

            return this.waitFor({
                method          : function() { return me.$(selector, root).length === 0; },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForSelectorNotFound',
                description     : ' ' + R.get('selector') + ' "' + selector + '" ' + R.get('toDisappear')
            });
        },


        /**
         * Waits until the passed element becomes "visible" in the DOM and calls the provided callback.
         * Please note, that "visible" means element will just have a DOM node, and still may be hidden by another visible element.
         *
         * The callback will receive the passed element as the 1st argument.
         *
         * See also {@link #waitForElementTop} method.
         *
         * @param {Siesta.Test.ActionTarget} el The element to look for.
         * @param {Function} callback The callback to call after the CSS selector has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForElementVisible : function(el, callback, scope, timeout) {
            var R       = Siesta.Resource('Siesta.Test.Element');

            return this.waitFor({
                method          : function() {
                    var normalized = this.normalizeElement(el, true);

                    if (normalized && this.isElementVisible(normalized)) return normalized;
                },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForElementVisible',
                description     : ' ' + R.get('element') + ' "' + el.toString() + '" ' + R.get('toAppear')
            });
        },

        /**
         * Waits until the passed element is becomes not "visible" in the DOM and call the provided callback.
         * Please note, that "visible" means element will just have a DOM node, and still may be hidden by another visible element.
         *
         * The callback will receive the passed element as the 1st argument.
         *
         * See also {@link #waitForElementNotTop} method.
         *
         * @param {Siesta.Test.ActionTarget} el The element to look for.
         * @param {Function} callback The callback to call after the CSS selector has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForElementNotVisible : function(el, callback, scope, timeout) {
            el          = this.normalizeElement(el);

            var R       = Siesta.Resource('Siesta.Test.Element');
            var me      = this;

            return this.waitFor({
                method          : function() { return !me.isElementVisible(el) && el; },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForElementNotVisible',
                description     :  ' ' + R.get('element') + ' "' + el.toString() +  '" ' + R.get('toDisappear')
            });
        },


        /**
         * Waits until the passed element is the 'top' element in the DOM and call the provided callback.
         *
         * The callback will receive the passed element as the 1st argument.
         *
         * @param {Siesta.Test.ActionTarget} el The element to look for.
         * @param {Function} callback The callback to call
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForElementTop : function(el, callback, scope, timeout) {
            var R       = Siesta.Resource('Siesta.Test.Element');

            return this.waitFor({
                method          : function() {
                    var normalized = this.normalizeElement(el, true);

                    if (normalized && this.elementIsTop(normalized, true)) {
                        return normalized;
                    }
                },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForElementTop',
                description     : ' ' + R.get('element') + ' "' + el.toString() + '" ' + R.get('toBeTopEl')
            });
        },

        /**
         * Waits until the passed element is not the 'top' element in the DOM and calls the provided callback with the element found.
         *
         * The callback will receive the actual top element.
         *
         * @param {Siesta.Test.ActionTarget} el The element to look for.
         * @param {Function} callback The callback to call
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForElementNotTop : function(el, callback, scope, timeout) {
            el          = this.normalizeElement(el);

            var R       = Siesta.Resource('Siesta.Test.Element');
            var me      = this

            return this.waitFor({
                method          : function() {
                    if (!me.elementIsTop(el, true)) {
                        var center = me.findCenter(el);
                        return me.elementFromPoint(center[0], center[1], true);
                    }
                },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForElementNotTop',
                description     : ' ' + R.get('element') + ' "' + el.toString() + '" ' + R.get('toNotBeTopEl')
            });
        },

        /**
         * Passes if the element is in the DOM and visible.
         * @param {Siesta.Test.ActionTarget} el The element
         * @param {String} [description] The description for the assertion
         */
        elementIsVisible : function(el, description) {
            el = this.normalizeElement(el, true, false, false, { ignoreNonVisible : false });

            this.ok(el && this.isElementVisible(el), description);
        },

        /**
         * Passes if the element is not visible.
         * @param {Siesta.Test.ActionTarget} el The element
         * @param {String} [description] The description for the assertion
         */
        elementIsNotVisible : function(el, description) {
            el = this.normalizeElement(el, false, false, false, { ignoreNonVisible : false });

            this.notOk(this.isElementVisible(el), description);
        },

        /**
         * Utility method which checks if the passed method is the 'top' element at its position. By default, "top" element means,
         * that center point of the element is not covered with any other elements. You can also check any other point reachability
         * using the "offset" argument.
         *
         * @param {Siesta.Test.ActionTarget} el The element to look for.
         * @param {Boolean} allowChildren true to also include child nodes. False to strictly check for the passed element.
         * @param {Array} offset An array of 2 elements, defining "x" and "y" offset from the left-top corner of the element
         *
         * @return {Boolean} true if the element is the top element.
         */
        elementIsTop : function (el, allowChildren, offset) {
            el              = this.normalizeElement(el);

            // Workaround for OPTION elements which don't behave like normal DOM elements. jQuery always consider them invisible.
            // Decide based on visibility of the parent SELECT node
            if (el && el.nodeName.toLowerCase() === 'option') {
                el = this.$(el).closest('select')[0];
            }

            var elDoc       = el.ownerDocument

            var localPoint  = this.getTargetCoordinate(el, true, offset)
            var foundEl     = elDoc.elementFromPoint(localPoint[ 0 ], localPoint[ 1 ]);

            return foundEl && (foundEl === el || (allowChildren && this.$(foundEl).closest(el).length > 0));
        },

        // Helper method to find out if an offset is targeting a point outside its target
        // Assumes the el passed is visible
        isOffsetInsideElementBox : function (el, offset) {
            if (!offset) return true;

            var $el = this.$(this.normalizeElement(el));
            var w   = $el.outerWidth();
            var h   = $el.outerHeight();

            offset = this.normalizeOffset(offset, $el);

            return offset[0] >= 0 && offset[0] < w &&
                   offset[1] >= 0 && offset[1] < h;
        },

        /**
         * Passes if the element is found at the supplied xy coordinates.
         *
         * @param {Siesta.Test.ActionTarget} el The element to query
         * @param {Array} xy The xy coordinate to query.
         * @param {Boolean} allowChildren true to also include child nodes. False to strictly check for the passed element.
         * @param {String} [description] The description for the assertion
         */
        elementIsAt : function(el, xy, allowChildren, description) {
            el              = this.normalizeElement(el);

            var foundEl     = this.elementFromPoint(xy[0], xy[1], true);
            var R           = Siesta.Resource('Siesta.Test.Element');

            if (!foundEl) {
                this.fail(description, {
                    assertionName       : 'elementIsAt',
                    got                 : { x: xy[0], y : xy[1] },
                    gotDesc             : R.get('Position'),
                    annotation          : R.get('noElementAtPosition')
                });
            } else if (allowChildren) {
                if (foundEl === el || this.$(foundEl).closest(el).length > 0) {
                    this.pass(description, {
                        descTpl         : R.get('elementIsAtDescTpl'),
                        x               : xy[ 0 ],
                        y               : xy[ 1 ]
                    });
                } else {
                    this.fail(description, {
                        assertionName   : 'elementIsAt',
                        got             : foundEl,
                        gotDesc         : R.get('topElement'),
                        need            : el,
                        needDesc        : R.get('allowChildrenDesc'),
                        annotation      : R.get('allowChildrenAnnotation')
                    });
                }
            } else {
                if (foundEl === el) {
                    this.pass(description, {
                        descTpl         : R.get('elementIsAtPassTpl'),
                        x               : xy[ 0 ],
                        y               : xy[ 1 ]
                    });
                } else {
                    this.fail(description, {
                        assertionName   : 'elementIsAt',
                        got             : foundEl,
                        gotDesc         : R.get('topElement'),
                        need            : el,
                        needDesc        : 'Should be',
                        annotation      : R.get('noChildrenFailAnnotation')
                    });
                }
            }
        },

        /**
         * Passes if the element is the top element (using its center xy coordinates). "Top" element means,
         * that element is not covered with any other elements.
         *
         * This assertion can be used for example to test, that some element, that appears only when mouse hovers some other element is accessible by user
         * with mouse (which is not always true because of various z-index issues).
         *
         * @param {Siesta.Test.ActionTarget} el The element to look for.
         * @param {Boolean} allowChildren true to also include child nodes. False to strictly check for the passed element.
         * @param {String} [description] The description for the assertion
         * @param {Boolean} strict true to check all four corners of the element. False to only check at element center.
         */
        elementIsTopElement : function(el, allowChildren, description, strict) {
            el = this.normalizeElement(el);

            if (strict) {
                var o           = this.$(el).offset();
                var R           = Siesta.Resource('Siesta.Test.Element');
                var region      = {
                    top     : o.top,
                    right   : o.left + this.$(el).outerWidth(),
                    bottom  : o.top + this.$(el).outerHeight(),
                    left    : o.left
                };

                this.elementIsAt(el, [region.left+1, region.top+1], allowChildren, description + ' ' + R.get('topLeft'));
                this.elementIsAt(el, [region.left+1, region.bottom-1], allowChildren, description + ' ' + R.get('bottomLeft'));
                this.elementIsAt(el, [region.right-1, region.top+1], allowChildren, description + ' ' + R.get('topRight'));
                this.elementIsAt(el, [region.right-1, region.bottom-1], allowChildren, description + ' ' + R.get('bottomRight'));
            } else {
                this.elementIsAt(el, this.findCenter(el), allowChildren, description);
            }
        },

        /**
         * Passes if the element is not the top element (using its center xy coordinates).
         *
         * @param {Siesta.Test.ActionTarget} el The element to look for.
         * @param {Boolean} allowChildren true to also include child nodes. False to strictly check for the passed element.
         * @param {String} [description] The description for the assertion
         */
        elementIsNotTopElement : function(el, allowChildren, description) {
            el              = this.normalizeElement(el);
            var center      = this.findCenter(el);

            var foundEl     = this.elementFromPoint(center[ 0 ], center[ 1 ], true);

            if (!foundEl) {
                var R           = Siesta.Resource('Siesta.Test.Element');

                this.pass(description, {
                    descTpl         : R.get('elementIsNotTopElementPassTpl')
                });

                return
            }

            if (allowChildren) {
                this.ok(foundEl !== el && this.$(foundEl).closest(el).length === 0, description);
            } else {
                this.isnt(foundEl, el, description);
            }
        },

        /**
         * Passes if the element is found at the supplied xy coordinates.
         *
         * @param {String} selector The selector to query for
         * @param {Array} xy The xy coordinate to query.
         * @param {Boolean} allowChildren true to also include child nodes. False to strictly check for the passed element.
         * @param {String} [description] The description for the assertion
         */
        selectorIsAt : function(selector, xy, description) {
            var R           = Siesta.Resource('Siesta.Test.Element');

            if (!selector) throw R.get('noCssSelector');

            var foundEl = this.$(this.elementFromPoint(xy[0], xy[1], true));

            if (foundEl.has(selector).length > 0 || foundEl.closest(selector).length > 0) {
                this.pass(description, {
                    descTpl         : R.get('selectorIsAtPassTpl'),
                    selector        : selector,
                    xy              : xy
                });
            } else {
                this.fail(description, {
                    got             : foundEl[0].outerHTML ? foundEl[0].outerHTML : foundEl[0].innerHTML,
                    need            : R.get('elementMatching') + ' ' + selector,
                    assertionName   : 'selectorIsAt',
                    annotation      : R.get('selectorIsAtFailAnnotation') + ' [' + xy + ']'
                });
            }
        },

        /**
         * Passes if the selector is found in the DOM
         *
         * @param {String} selector The selector to query for
         * @param {String} [description] The description for the assertion
         */
        selectorExists : function (selector, description) {
            var R           = Siesta.Resource('Siesta.Test.Element');

            if (!selector) throw R.get('noCssSelector');

            if (this.$(selector).length <= 0) {
                this.fail(description, R.get('selectorExistsFailTpl') + ' : ' + selector);
            } else {
                this.pass(description, {
                    descTpl         : R.get('selectorExistsPassTpl'),
                    selector        : selector
                });
            }
        },

        /**
         * Passes if the selector is not found in the DOM
         *
         * @param {String} selector The selector to query for
         * @param {String} [description] The description for the assertion
         */
        selectorNotExists : function (selector, description) {
            var R           = Siesta.Resource('Siesta.Test.Element');
            var els         = this.$(selector);

            if (els.length > 0) {
                this.fail(description, {
                    descTpl     : R.get('selectorNotExistsFailTpl') + ': ' + selector,
                    annotation  : $.map(els, function (el, i) { return (i + 1) + ". " + el.cloneNode().outerHTML; }).join('\r\n')
                });
            } else {
                this.pass(description, {
                    descTpl         : R.get('selectorNotExistsPassTpl'),
                    selector        : selector
                });
            }
        },

        /**
         * Waits until the passed scroll property of the element has changed.
         *
         * The callback will receive the new `scroll` value.
         *
         * @param {Siesta.Test.ActionTarget} el The element
         * @param {String} side 'left' or 'top'
         * @param {Function} callback The callback to call
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForScrollChange : function(el, side, callback, scope, timeout) {
            el                  = this.normalizeElement(el);
            var scrollProp      = 'scroll' + Joose.S.uppercaseFirst(side);
            var original        = el[ scrollProp ];
            var R               = Siesta.Resource('Siesta.Test.Element');

            return this.waitFor({
                method          : function() { if (el[ scrollProp ] !== original) return el[ scrollProp ]; },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForScrollChange',
                description     : ' ' + scrollProp + ' ' + R.get('toChangeForElement') + ' ' + el.toString()
            });
        },

        /**
         * Waits until the `scrollLeft` property of the element has changed.
         *
         * The callback will receive the new `scrollLeft` value.
         *
         * @param {Siesta.Test.ActionTarget} el The element
         * @param {Function} callback The callback to call
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForScrollLeftChange : function(el, callback, scope, timeout) {
            return this.waitForScrollChange(this.normalizeElement(el), 'left', callback, scope, timeout);
        },

        /**
         * Waits until the scrollTop property of the element has changed
         *
         * The callback will receive the new `scrollTop` value.
         *
         * @param {Siesta.Test.ActionTarget} el The element
         * @param {Function} callback The callback to call
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForScrollTopChange : function(el, callback, scope, timeout) {
            return this.waitForScrollChange(this.normalizeElement(el), 'top', callback, scope, timeout);
        },


        /**
         * This method changes the `scrollLeft` and `scrollTop` properties of the dom element, then waits for the "scroll" event
         * from it and calls the provided callback.
         *
         * For example:
         *

    // scroll the domEl to the 50px horizontal offset, 100px vertical, wait for "scroll" event, call the callback
    t.scrollTo(domEl, 50, 100, function () { ... })

         * Optionally it can also wait some additional time before calling the callback:
         *
    // scroll the domEl to the 50px horizontal offset, 100px vertical, wait for "scroll" event, wait 1000ms more, call the callback
    t.scrollTo(domEl, 50, 100, function () { ... }, 1000)

         *
         * @param {Siesta.Test.ActionTarget} el The element
         * @param {Number} newLeft The value for the `scrollLeft` property
         * @param {Number} newTop The value for the `scrollTop` property
         * @param {Function} callback A function to call after "scroll" event has been fired and additional delay completed (if any)
         * @param {Number} [delay] Optional, additional delay before calling a callback
         *
         * @return {Object} An object with new scrolling position
         * @return {Number} return.scrollLeft The new value of the `scrollLeft` property of the dom element
         * @return {Number} return.scrollTop The new value of the `scrollTop` property of the dom element
         */
        scrollTo : function (el, scrollLeft, scrollTop, callback, delay, allowEmpty) {
            el                          = this.normalizeElement(el, allowEmpty);

            if (!el) { this.processCallbackFromTest(callback); return }

            var me                      = this
            var originalSetTimeout      = this.originalSetTimeout;

            var doc                     = el.ownerDocument

            var waiter                  = this.waitForEvent(el == this.getElForPageScroll() ? doc : el, 'scroll', function () {
                if (delay > 0) {
                    var async               = me.beginAsync(delay + 100)

                    originalSetTimeout(function () {
                        me.endAsync(async)

                        me.processCallbackFromTest(callback)
                    }, delay)
                } else
                    me.processCallbackFromTest(callback)
            })

            var prevScrollTop   = el.scrollTop
            var prevScrollLeft  = el.scrollLeft

            el.scrollLeft       = scrollLeft
            el.scrollTop        = scrollTop

            // no event will be fired in this case probably - force the waiting operation to complete
            if (el.scrollTop == prevScrollTop && el.scrollLeft == prevScrollLeft) {
                waiter.force()
            }

            return { scrollLeft : el.scrollLeft, scrollTop : el.scrollTop }
        },


        /**
         * This method changes the "scrollTop" property of the dom element, then waits for the "scroll" event from it and calls the provided callback.
         *
         * For example:
         *

    // scroll the domEl to the 100px offset, wait for "scroll" event, call the callback
    t.scrollVerticallyTo(domEl, 100, function () { ... })

         * Optionally it can also wait some additional time before calling the callback:
         *
    // scroll the domEl to the 100px offset, wait for "scroll" event, wait 1000ms more, call the callback
    t.scrollVerticallyTo(domEl, 100, 1000, function () { ... })

         *
         * @param {Siesta.Test.ActionTarget} el The element
         * @param {Number} newTop The value for the "scrollTop" property
         * @param {Number} [delay] Additional delay, this argument can be omitted
         * @param {Function} callback A function to call after "scroll" event has been fired and additional delay completed (if any)
         *
         * @return {Number} The new value of the "scrollTop" property of the dom element
         */
        scrollVerticallyTo : function (el, newTop, delay, callback) {
            el                          = this.normalizeElement(el);

            if (this.typeOf(delay) != 'Number') {
                callback                = delay
                delay                   = null
            }

            var me                      = this
            var originalSetTimeout      = this.originalSetTimeout;

            var doc                     = el.ownerDocument

            var waiter                  = this.waitForEvent(el == this.getElForPageScroll() ? doc : el, 'scroll', function () {
                if (delay > 0) {
                    var async               = me.beginAsync(delay + 100)

                    originalSetTimeout(function () {
                        me.endAsync(async)

                        me.processCallbackFromTest(callback)
                    }, delay)
                } else
                    me.processCallbackFromTest(callback)
            })

            var prevScrollTop   = el.scrollTop

            el.scrollTop        = newTop

            // no event will be fired in this case probably - force the waiting operation to complete
            if (el.scrollTop == prevScrollTop) {
                waiter.force()
            }

            // re-read the scrollTop value and return it (newTop can be too big for example and will be truncated)
            return el.scrollTop
        },


        /**
         * This method changes the "scrollLeft" property of the dom element, then waits for the "scroll" event from it and calls the provided callback.
         *
         * For example:
         *

    // scroll the domEl to the 100px offset, wait for "scroll" event, call the callback
    t.scrollHorizontallyTo(domEl, 100, function () { ... })

         * Optionally it can also wait some additional time before calling the callback:
         *
    // scroll the domEl to the 100px offset, wait for "scroll" event, wait 1000ms more, call the callback
    t.scrollHorizontallyTo(domEl, 100, 1000, function () { ... })

         *
         * @param {Siesta.Test.ActionTarget} el The element
         * @param {Number} newLeft The value for the "scrollLeft" property
         * @param {Number} [delay] Additional delay, this argument can be omitted
         * @param {Function} callback A function to call after "scroll" event has been fired and additional delay completed (if any)
         *
         * @return {Number} The new value of the "scrollLeft" property of the dom element
         */
        scrollHorizontallyTo : function (el, newLeft, delay, callback) {
            el                          = this.normalizeElement(el);

            if (this.typeOf(delay) != 'Number') {
                callback                = delay
                delay                   = null
            }

            var me                      = this
            var originalSetTimeout      = this.originalSetTimeout;

            var doc                     = el.ownerDocument

            var waiter                  = this.waitForEvent(el == this.getElForPageScroll() ? doc : el, 'scroll', function () {
                if (delay > 0) {
                    var async               = me.beginAsync(delay + 100)

                    originalSetTimeout(function () {
                        me.endAsync(async)

                        me.processCallbackFromTest(callback)
                    }, delay)
                } else
                    me.processCallbackFromTest(callback)
            })

            var prevScrollLeft  = el.scrollLeft

            el.scrollLeft       = newLeft

            // no event will be fired in this case probably - force the waiting operation to complete
            if (el.scrollLeft == prevScrollLeft) {
                waiter.force()
            }

            // re-read the scrollLeft value and return it (newLeft can be too big for example and will be truncated)
            return el.scrollLeft
        },



        /**
         * This method accepts an array of the DOM elements and performs a mouse click on them, in order. After that, it calls the provided callback:
         *
```javascript
t.clickAll([ el1, el2 ], function () {
    ...
})

 * the elements can be also provided inline, w/o wrapping array:

t.clickAll(el1, el2, function () {
    ...
})
```
         *
         * @param {Array[Siesta.Test.ActionTarget]} elements The array of elements to click
         * @param {Function} callback The function to call after clicking all elements
         */
        clickAll : function () {
            var args        = Array.prototype.concat.apply([], arguments)
            var callback

            if (this.typeOf(args[ args.length - 1 ]) == 'Function') callback = args.pop()

            // poor-man Array.flatten, with only 1 level of nesting support
            args            = Array.prototype.concat.apply([], args)

            var steps       = []

            Joose.A.each(args, function (arg) {
                steps.push({
                    action      : 'click',
                    target      : arg
                })
            })

            var me          = this

            if (callback) steps.push(function () {
                me.processCallbackFromTest(callback)
            })

            this.chain.apply(this, steps)
        },

        /*
        * @deprecated
        * Alias for {@link clickAll}
        * */
        chainClick : function() {
            return this.clickAll.apply(this, arguments);
        },


        /**
         * This method is a wrapper around the {@link #clickAll}, it performs a click on the every element found by the DOM query.
         *
         * You can specify the optional `root` element to start the query from:
         *
         *      t.clickSelector('.my-grid .x-grid-row', someEl, function () {})
         *
         * or omit it (query will start from the document):
         *
         *      t.clickSelector('.my-grid .x-grid-row', function () {})
         *
         * The provided callback will receive an array with DOM elements - result of query.
         *
         *
         * @param {String} selector The selector/xpath query
         * @param {Siesta.Test.ActionTarget} [root=document] The root of the query, defaults to the `document`. You can omit this parameter.
         * @param {Function} [callback]
         * @param {Object} [scope]
         */
        clickSelector : function (selector, root, callback, scope) {
            if (arguments.length > 1 && this.typeOf(arguments[ 1 ]) == 'Function') {
                scope       = callback;
                callback    = root;
                root        = null;
            }

            if (root) root = this.normalizeElement(root);

            // convert the result from jQuery dom query to a usual array
            var result      = Joose.A.map(this.sizzle(selector, root), function (el) { return el });

            this.clickAll(result, function () { callback && callback.call(scope || this, result) })
        },


        /**
         * This assertion passes when the DOM query with specified selector returns the expected number of elements
         *
         * You can specify the optional `root` element to start the query from:
         *
         *      t.selectorCountIs('.x-grid-row', grid, 5, "Grid has 5 rows")
         *
         * or omit it (query will start from the document):
         *
         *      t.selectorCountIs('.x-grid-row', 0, "No grid rows on the page")
         *
         * @param {String} selector DOM query selector
         * @param {Siesta.Test.ActionTarget} [root] An optional root element to start the query from, if omited query will start from the document
         * @param {Number} count The expected number of elements in the query result
         * @param {String} [description] The description for the assertion
         */
        selectorCountIs : function (selector, root, count, description) {
            var R               = Siesta.Resource('Siesta.Test.Element');

            if (!selector) throw R.get('noCssSelector');

            if (this.typeOf(root) == 'Number') {
                description     = count
                count           = root
                root            = null
            } else
                root            = this.normalizeElement(root)

            var inDOMCount      = this.$(selector, root).length

            if (inDOMCount != count) {
                this.fail(description, {
                    assertionName   : 'selectorCountIs',
                    descTpl         : R.get('selectorCountIsFailTpl'),
                    selector        : selector,
                    got             : inDOMCount,
                    need            : count
                });
            } else {
                this.pass(description, {
                    descTpl         : R.get('selectorCountIsPassTpl'),
                    count           : count,
                    selector        : selector
                });
            }
        },


        /**
         * Passes if the passed element is inside of the visible viewport
         *
         * @param {Siesta.Test.ActionTarget} el The element
         * @param {String} [description] The description for the assertion
         */
        isInView : function (el, description) {
            if (this.elementIsInView(el)) {
                var R           = Siesta.Resource('Siesta.Test.Element');

                this.pass(description, {
                    descTpl         : R.get('isInViewPassTpl')
                })
            }
            else
                this.fail(description, {
                    assertionName   : 'isInView'
                })
        },

        /**
         * Returns true if the passed element is inside of the visible viewport
         *
         * @param {Siesta.Test.ActionTarget} el The element
         */
        elementIsInView : function(el) {
            el              = this.normalizeElement(el);

            var inView      = false;
            var offset      = this.$(el).offset();

            if (offset) {
                var docViewTop      = $(this.global).scrollTop();
                var docViewBottom   = docViewTop + $(this.global).height();

                var elemTop         = offset.top;
                var elemBottom      = elemTop + $(el).height();

                inView              = elemBottom >= docViewTop && elemTop <= docViewBottom;
            }

            return inView;
        },

        /**
         * Waits until element is inside in the visible viewport and then calls the supplied callback
         *
         * @param {Siesta.Test.ActionTarget} el The element
         * @param {Function} callback The callback to call
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitUntilInView : function (el, callback, scope, timeout) {
            var me          = this;
            var R           = Siesta.Resource('Siesta.Test.Element');

            this.waitFor({
                method          : function() {
                    var normalized  = this.normalizeElement(el, true);

                    if(normalized && me.elementIsInView(normalized)) {
                        return normalized;
                    }
                },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitUntilInView',
                description     : el.toString + ' ' + R.get('toAppearInTheViewport')
            });
        },


        findScrolledParent : function(el) {
            var body   = el.ownerDocument.body;

            var parent = this.$(el);

            while (parent = parent.parent(), parent.length && parent[ 0 ] != body) {
                if (parent[0].scrollTop > 0 || parent[0].scrollLeft > 0) {
                    return parent[0];
                }
            }
        },


        focus : function (el, tryPreventScrollChange) {
            var prevIndex   = el.getAttribute('tabIndex')
            var scrolledParent;

            if (this.activeElement() === el) return;

            try {
                if (prevIndex == null) el.setAttribute('tabIndex', -1)

                if (tryPreventScrollChange) {
                    var oldScrollLeft, oldScrollTop, pageScrollX, pageScrollY;

                    // In Chrome, when calling focus() manually on an element - it's scrolled into view in its parent hierarchy
                    // Try to detect this and restore (This is far from optimal since application might have a listener triggering a desired
                    // scroll of this element. But not triggering focus() on mousedown seems like a worse situation
                    scrolledParent = this.findScrolledParent(el);

                    if (scrolledParent) {
                        oldScrollLeft   = scrolledParent.scrollLeft;
                        oldScrollTop    = scrolledParent.scrollTop;
                    }

                    pageScrollX         = this.getPageScrollX()
                    pageScrollY         = this.getPageScrollY()
                }

                this.maintainScrollPositionDuring(function () {
                    el.focus({ preventScroll : tryPreventScrollChange })

                    if (tryPreventScrollChange) {
                        if (scrolledParent) {
                            if (oldScrollLeft !== scrolledParent.scrollLeft)  {
                                scrolledParent.scrollLeft = oldScrollLeft;
                            }

                            if (oldScrollTop !== scrolledParent.scrollTop)  {
                                scrolledParent.scrollTop = oldScrollTop;
                            }
                        }

                        if (pageScrollX != this.getPageScrollX() || pageScrollY != this.getPageScrollY()) {
                            this.global.scrollTo(pageScrollX, pageScrollY)
                        }
                    }
                })

            } catch (e) {
            } finally {
                if (prevIndex == null)
                    el.removeAttribute('tabIndex')
                else
                    el.setAttribute('tabIndex', prevIndex)
            }
        },


        /**
         * Passes if the passed element has no content (whitespace will be trimmed)
         *
         * @param {Siesta.Test.ActionTarget} el The element
         * @param {String} [description] The description for the assertion
         */
        elementIsEmpty : function (el, description) {

            el              = this.normalizeElement(el);

            if (el && this.isElementEmpty(el)) {
                var R           = Siesta.Resource('Siesta.Test.Element');

                this.pass(description, {
                    descTpl         : R.get('elementIsEmptyPassTpl')
                })
            }
            else
                this.fail(description, {
                    got             : el.innerHTML,
                    need            : '',
                    assertionName   : 'elementIsEmpty'
                })
        },

        /**
         * Passes if the passed element has some non-whitespace content
         *
         * @param {Siesta.Test.ActionTarget} el The element
         * @param {String} [description] The description for the assertion
         */
        elementIsNotEmpty : function (el, description) {
            el              = this.normalizeElement(el);

            if (el && !this.isElementEmpty(el)) {
                var R           = Siesta.Resource('Siesta.Test.Element');

                this.pass(description, {
                    descTpl         : R.get('elementIsNotEmptyPassTpl')
                })
            }
            else
                this.fail(description, {
                    assertionName   : 'elementIsNotEmpty'
                })
        },

        /**
         * Waits until the innerHTML of the passed element is empty (whitespace will be trimmed)
         *
         * @param {Siesta.Test.ActionTarget} el The element to query
         * @param {Function} callback The callback to call after the CSS selector has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForElementEmpty : function(el, callback, scope, timeout) {
            var me          = this;
            var R           = Siesta.Resource('Siesta.Test.Element');

            el              = this.normalizeElement(el);

            return this.waitFor({
                method          : function() { return me.isElementEmpty(el); },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForElementEmpty',
                description     : ' ' + R.get('elementToBeEmpty')
            });
        },

        /**
         * Waits until the innerHTML of the passed element contains some non-whitespace text.
         *
         * @param {Siesta.Test.ActionTarget} el The element to query
         * @param {Function} callback The callback to call after the CSS selector has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForElementNotEmpty : function(el, callback, scope, timeout) {
            var me          = this;
            var R           = Siesta.Resource('Siesta.Test.Element');

            el              = this.normalizeElement(el);

            return this.waitFor({
                method          : function() { return !me.isElementEmpty(el); },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForElementNotEmpty',
                description     : ' ' + R.get('elementToNotBeEmpty')
            });
        },

        isElementEmpty : function (el) {
            return !el.innerHTML.replace(/^\s+|\s+$/g, '');
        },

        /**
         * Passes if the target element has an attribute with the provided value.
         *
         * @param {Siesta.Test.ActionTarget} el The element to query
         * @param {String} attribute The attribute
         * @param {String} value The value
         * @param {String} [description] The description for the assertion
         */
        hasAttributeValue : function(el, attribute, value, description) {
            el              = this.normalizeElement(el);

            var foundValue = el.getAttribute(attribute);

            this.is(foundValue, value, description);
        },

        /**
         * Passes if the passed element has the expected value as its "value" property (use with SELECT, INPUT type elements).
         *
         * @param {Siesta.Test.ActionTarget} el The element to query
         * @param {Mixed} value The value to compare to.
         * @param {String} [description] The description of the assertion
         */
        hasValue : function(el, value, description) {
            el              = this.normalizeElement(el);

            var foundValue = el.value;

            this.is(foundValue, value, description);
        },

        /**
         * This assertion passes when the passed element offsetWidth matches the offsetWidth of the reference element
         *
         * @param {Siesta.Test.ActionTarget} el The element to query
         * @param {Siesta.Test.ActionTarget} referenceEl The element to compare against
         * @param {String} [description] The description of the assertion
         */
        hasSameWidth: function (el, referenceEl, description) {
            el          = this.normalizeElement(el);
            referenceEl = this.normalizeElement(referenceEl);

            this.is(el.offsetWidth, referenceEl.offsetWidth, description);
        },

        /**
         * This assertion passes when the passed element offsetHeight matches the offsetHeight of the reference element
         *
         * @param {Siesta.Test.ActionTarget} el The element to query
         * @param {Siesta.Test.ActionTarget} referenceEl The element to compare against
         * @param {String} [description] The description of the assertion
         */
        hasSameHeight: function (el, referenceEl, description) {
            el          = this.normalizeElement(el);
            referenceEl = this.normalizeElement(referenceEl);

            this.is(el.offsetHeight, referenceEl.offsetHeight, description);
        },


        isElementFocusable : function(el) {
            var disabled    = el.getAttribute('disabled') === "true";
            var nodeName    = el.nodeName.toLowerCase();
            // Other tags are covered in isTextInput
            var focusable   = { a : 1, area : 1, button : 1, object : 1, select : 1 };

            return !disabled && (
                this.isTextInput(el) || el.isContentEditable
                || (el.nodeName.toLowerCase() === 'input' && el.type === 'file')
                || (nodeName in focusable)
                || (el.getAttribute('tabIndex') != null && (!bowser.msie || String(el.getAttribute('unselectable')).toLowerCase() != 'on'))
            );
        }
    }
});
;
/**
@class Siesta.Test.Observable

This is a mixin, with assertions/ helper methods for testing observable pattern (in NodeJS world known as `EventEmitter`).

*/
Role('Siesta.Test.Observable', {

    does    : [
        Siesta.Util.Role.CanGetType
    ],

    requires : [
        'addListenerToObservable',
        'removeListenerFromObservable',
        'getSourceLine',
        'pass', 'fail',
        'processCallbackFromTest'
    ],

    has : {
    },

    methods : {

        /**
         * This method will wait for the first browser `event`, fired by the provided `observable` and will then call the provided callback.
         *
         * @param {Mixed} observable Any browser observable, window object, element instances, CSS selector.
         * @param {String} event The name of the event to wait for
         * @param {Function} callback The callback to call
         * @param {Object} scope The scope for the callback
         * @param {Number} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForEvent : function (observable, event, callback, scope, timeout) {
            var eventFired      = false
            var R               = Siesta.Resource('Siesta.Test.Browser');

            this.addListenerToObservable(observable, event, function () { eventFired = true })

            return this.waitFor({
                method          : function() { return eventFired; },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForEvent',
                description     : ' ' + R.get('waitForEvent') + ' "' + event + '" ' + R.get('event')
            });
        },


        /**
         * This assertion verifies the number of certain events fired by the provided observable instance during provided function (possibly `async`) or time period.
         *
         * For example:
         *

    t.firesOk({
        observable      : store,
        events          : {
            update      : 1,
            add         : 2,
            datachanged : '> 1'
        },
        during          : function () {
            store.getAt(0).set('Foo', 'Bar');

            store.add({ FooBar : 'BazQuix' })
            store.add({ Foo : 'Baz' })
        },
        desc            : 'Correct events fired'
    })

    // or async

    await t.firesOk({
        observable      : someObservable,
        events          : {
            datachanged : '> 1'
        },
        during          : async () => {
            await someObservable.loadData()
        },
        desc            : 'Correct events fired'
    })

    // or

    t.firesOk({
        observable      : store,
        events          : {
            update      : 1,
            add         : 2,
            datachanged : '>= 1'
        },
        during          : 1
    })

    store.getAt(0).set('Foo', 'Bar');

    store.add({ FooBar : 'BazQuix' })
    store.add({ Foo : 'Baz' })

         *
         * Normally this method accepts a single object with various options (as shown above), but also can be called in 2 additional shortcuts forms:
         *

    // 1st form for multiple events
    t.firesOk(observable, { event1 : 1, event2 : '>1' }, description)

    // 2nd form for single event
    t.firesOk(observable, eventName, 1, description)
    t.firesOk(observable, eventName, '>1', description)

         *
         * In both forms, `during` is assumed to be undefined and `description` is optional.
         *
         * @param {Object} options An obect with the following properties:
         * @param {Ext.util.Observable/Ext.Element/HTMLElement} options.observable The observable instance that will fire events
         * @param {Object} options.events The object, properties of which corresponds to event names and values - to expected
         * number of this event triggering. If value of some property is a number then exact that number of events is expected. If value
         * of some property is a string starting with one of the comparison operators like "\<", "\<=", "==" etc and followed by the number
         * then Siesta will perform that comparison with the number of actualy fired events.
         * @param {Number/Function} [options.during] If provided as a number denotes the number of milliseconds during which
         * this assertion will "record" the events from observable, if provided as regular function - then this assertion will "record"
         * only events fired during execution of this function (`async` functions are supported, in this case, don't forget to `await`
         * on the assertion call itself). If not provided at all - assertions are recorded until the end of
         * current test (or sub-test)
         * @param {Function} [options.callback] A callback to call after this assertion has been checked. Only used if `during` value is provided.
         * @param {String} [options.desc] A description for this assertion
         */
        firesOk: function (options, events, n, timeOut, func, desc, callback) {
            //                    |        backward compat arguments        |
            var me              = this;
            var sourceLine      = me.getSourceLine();
            var R               = Siesta.Resource('Siesta.Test.Browser');
            var nbrArgs         = arguments.length
            var observable, during

            if (nbrArgs == 1) {
                observable      = options.observable
                events          = options.events
                during          = options.during
                desc            = options.desc || options.description
                callback        = options.callback

                timeOut         = this.typeOf(during) == 'Number' ? during : null
                func            = /Function/.test(this.typeOf(during)) ? during : null

            } else if (nbrArgs >= 5) {
                // old signature, backward compat
                observable      = options

                if (this.typeOf(events) == 'String') {
                    var obj         = {}
                    obj[ events ]   = n

                    events          = obj
                }
            } else if (nbrArgs <= 3 && this.typeOf(events) == 'Object') {
                // shortcut form 1
                observable      = options
                desc            = n
            } else if (nbrArgs <= 4 && this.typeOf(events) == 'String') {
                // shortcut form 2
                observable      = options

                var obj         = {}
                obj[ events ]   = n
                events          = obj

                desc            = timeOut
                timeOut         = null
            } else
                throw new Error(R.get('unrecognizedSignature'))

            // start recording
            var counters    = {};
            var countFuncs  = {};

            Joose.O.each(events, function (expected, eventName) {
                counters[ eventName ]   = 0

                var countFunc   = countFuncs[ eventName ] = function () {
                    counters[ eventName ]++
                }

                me.addListenerToObservable(observable, eventName, countFunc);
            })


            // stop recording and verify the results
            var stopRecording   = function () {
                Joose.O.each(events, function (expected, eventName) {
                    me.removeListenerFromObservable(observable, eventName, countFuncs[ eventName ]);

                    var actualNumber    = counters[ eventName ]

                    if (me.verifyExpectedNumber(actualNumber, expected))
                        me.pass(desc, {
                            descTpl         : R.get('observableFired') + ' ' + actualNumber + ' `' + eventName + '` ' + R.get('events')
                        });
                    else
                        me.fail(desc, {
                            assertionName   : 'firesOk',
                            sourceLine      : sourceLine,
                            descTpl         : R.get('observableFiredOk') + ' `' + eventName + '` ' + R.get('events'),
                            got             : actualNumber,
                            gotDesc         : R.get('actualNbrEvents'),
                            need            : expected,
                            needDesc        : R.get('expectedNbrEvents')
                        });
                })
            }

            if (timeOut) {
                var async               = this.beginAsync(timeOut + 100);

                var originalSetTimeout  = this.originalSetTimeout;

                originalSetTimeout(function () {
                    me.endAsync(async);

                    stopRecording()

                    me.processCallbackFromTest(callback);
                }, timeOut);
            } else if (func) {
                var typeOf  = this.typeOf(func)

                var cont = function () {
                    stopRecording()

                    me.processCallbackFromTest(callback)
                }

                if (typeOf === 'Function') {
                    func()
                    cont()
                }
                else if (typeOf === 'AsyncFunction') {
                    return func().then(cont, cont)
                }

            } else {
                this.on('beforetestfinalizeearly', stopRecording)
            }
        },


        /**
         * This assertion passes if the observable fires the specified event exactly (n) times during the test execution.
         *
         * @param {Ext.util.Observable/Ext.Element/HTMLElement} observable The observable instance
         * @param {String} event The name of event
         * @param {Number} n The expected number of events to be fired
         * @param {String} [desc] The description of the assertion.
         */
        willFireNTimes: function (observable, event, n, desc, isGreaterEqual) {
            this.firesOk(observable, event, isGreaterEqual ? '>=' + n : n, desc)
        },


        getObjectWithExpectedEvents : function (event, expected) {
            var events      = {}

            if (this.typeOf(event) == 'Array')
                Joose.A.each(event, function (eventName) {
                    events[ eventName ] = expected
                })
            else
                events[ event ]         = expected

            return events
        },


        /**
         * This assertion passes if the observable does not fire the specified event(s) after calling this method.
         *
         * @param {Mixed} observable Any browser observable, window object, element instances, CSS selector.
         * @param {String/Array[String]} event The name of event or array of such
         * @param {String} [desc] The description of the assertion.
         */
        wontFire : function(observable, event, desc) {
            this.firesOk({
                observable      : observable,
                events          : this.getObjectWithExpectedEvents(event, 0),
                desc            : desc
            });
        },

        /**
         * This assertion passes if the observable fires the specified event exactly once after calling this method.
         *
         * @param {Mixed} observable Any browser observable, window object, element instances, CSS selector.
         * @param {String/Array[String]} event The name of event or array of such
         * @param {String} [desc] The description of the assertion.
         */
        firesOnce : function(observable, event, desc) {
            this.firesOk({
                observable      : observable,
                events          : this.getObjectWithExpectedEvents(event, 1),
                desc            : desc
            });
        },

        /**
         * Alias for {@link #wontFire} method
         *
         * @param {Mixed} observable Any browser observable, window object, element instances, CSS selector.
         * @param {String/Array[String]} event The name of event or array of such
         * @param {String} [desc] The description of the assertion.
         */
        isntFired : function() {
            this.wontFire.apply(this, arguments);
        },

        /**
         * This assertion passes if the observable fires the specified event at least `n` times after calling this method.
         *
         * @param {Mixed} observable Any browser observable, window object, element instances, CSS selector.
         * @param {String} event The name of event
         * @param {Number} n The minimum number of events to be fired
         * @param {String} [desc] The description of the assertion.
         */
        firesAtLeastNTimes : function(observable, event, n, desc) {
            this.firesOk(observable, event, '>=' + n, desc);
        },

        /**
         * This assertion will verify that the observable fires the specified event and supplies the correct parameters to the listener function.
         * A checker method should be supplied that verifies the arguments passed to the listener function, and then returns true or false depending on the result.
         * If the event was never fired, this assertion fails. If the event is fired multiple times, all events will be checked, but
         * only one pass/fail message will be reported.
         *
         * For example:
         *

    t.isFiredWithSignature(store, 'add', function (store, records, index) {
        return (store instanceof Ext.data.Store) && (records instanceof Array) && t.typeOf(index) == 'Number'
    })

         * @param {Ext.util.Observable/Siesta.Test.ActionTarget} observable Ext.util.Observable instance or target as specified by the {@link Siesta.Test.ActionTarget} rules with
         * the only difference that component queries will be resolved till the component level, and not the DOM element.
         * @param {String} event The name of event
         * @param {Function} checkerFn A method that should verify each argument, and return true or false depending on the result.
         * @param {String} [desc] The description of the assertion.
         */
        isFiredWithSignature : function(observable, event, checkerFn, description) {
            var eventFired;
            var me              = this;
            var sourceLine      = me.getSourceLine();
            var R               = Siesta.Resource('Siesta.Test.ExtJS.Observable');

            var verifyFiredFn = function () {
                me.removeListenerFromObservable(observable, event, listener)

                if (!eventFired) {
                    me.fail('The [' + event + "] " + R.get('isFiredWithSignatureNotFired'));
                }
            };

            me.on('beforetestfinalizeearly', verifyFiredFn);

            var listener = function () {
                me.un('beforetestfinalizeearly', verifyFiredFn);

                var result = checkerFn.apply(me, arguments);

                if (!eventFired && result) {
                    me.pass(description || R.get('observableFired') + ' ' + event + ' ' + R.get('correctSignature'), {
                        sourceLine  : sourceLine
                    });
                }

                if (!result) {
                    me.fail(description || R.get('observableFired') + ' ' + event + ' ' + R.get('incorrectSignature'), {
                        sourceLine  : sourceLine
                    });

                    // Don't spam the assertion grid with failure, one failure is enough
                    me.removeListenerFromObservable(observable, event, listener)
                }
                eventFired = true
            };

            me.addListenerToObservable(observable, event, listener)
        }
    }
});
;
/**

@class Siesta.Test.ExtJSCore

A base mixin for testing Ext JS and Sencha Touch applications.

Contains testing functionality that is common for both frameworks.

This file is a reference only, for a getting start guide and manual, please refer to <a href="#!/guide/getting_started_browser">Siesta getting started in browser environment</a> guide.

*/
Role('Siesta.Test.ExtJSCore', {

    does    : Siesta.Util.Role.CanInstallCQRootPseudo,

    has : {
        waitForExtReady         : true,
        waitForAppReady         : false,

        waitForExtComponentQueryReady   : true,

        loaderPath              : null,
        requires                : null,

        isExtOnReadyDone        : false,
        onReadyWaitingStarted   : false,
        isAppReadyDone          : false,

        loaderWaitingStarted    : false,
        requiringWaitingStarted : false,
        isRequiringDone         : false,

        modelsDefinedInPreload  : Joose.I.Object
    },

    override : {

        onTestStart : function () {
            var me                  = this
            var sharedSandboxState  = this.sharedSandboxState

            // `!this.reusingSandbox` - is true only for the 1st test in the "shared sandbox" group
            if (!this.reusingSandbox && sharedSandboxState) {
                if (!sharedSandboxState.modelsDefinedInPreload) sharedSandboxState.modelsDefinedInPreload = {}

                this.forEachModelInAllSchemas(function (entity, entityName, className, schema) {
                    sharedSandboxState.modelsDefinedInPreload[ className ] = true
                })
            }
        },


        // only called for the re-used contexts
        cleanupContextBeforeStartDom : function () {
            var Ext         = this.getExt()

            if (!Ext) return this.SUPER()

            var me          = this

            // if component query is present - try to unregister all components
            if (Ext.ComponentQuery) {
                var keep        = {}
                var msgBox      = Ext.MessageBox

                if (msgBox) {
                    keep[ msgBox.id ] = true
                }

                // retrieve the top-level components
                var comps       = Ext.ComponentQuery.query('{ownerCt == null}')

                // sort, so that containers goes first
                // the logic is, that containers have "more logic" and may affect components
                // use case - grid editing is active and the editor field is destroyed before the grid -
                // that throws exception in gantt code

                comps.sort(function (a, b) {
                    a   = (a instanceof Ext.Container) ? 0 : 1
                    b   = (b instanceof Ext.Container) ? 0 : 1

                    return a - b
                })

                Joose.A.each(comps, function (comp) {
                    if (!keep[ comp.id ] && !comp.isDestroyed) comp.destroy()
                })
            }

            // if there's a class manager - unregister "unexpected" classes
            if (Ext.ClassManager && Ext.undefine) {
                var index       = {}

                Joose.O.each(Ext.ClassManager.classes, function (cls, name) {
                    var global      = name.split('.')[ 0 ]

                    if (!me.isGlobalExpected(global, index)) Ext.undefine(name)
                })
            }

            // if there's a store manager - also unregister stores (all stores except internal ext js store(s))
            if (Ext.data && Ext.data.StoreManager) {
                var toRemove = [];

                Ext.data.StoreManager.each(function(store) {
                    if (store.storeId !== "ext-empty-store") toRemove.push(store);
                });

                Ext.data.StoreManager.unregister.apply(Ext.data.StoreManager, toRemove);
            }

            var sharedSandboxState          = this.sharedSandboxState
            var modelsDefinedInPreload      = sharedSandboxState && sharedSandboxState.modelsDefinedInPreload

            modelsDefinedInPreload && me.forEachModelInAllSchemas(function (entity, entityName, className, schema) {
                if (!modelsDefinedInPreload[ className ]) {
                    Ext.undefine(className)

                    // TODO also need to remove the associations
                    delete schema.entityClasses[ className ]
                    delete schema.entities[ entityName ]
                }
            })

            Ext.resumeLayouts && Ext.resumeLayouts()
        },


        processSubTestConfig : function (config) {
            var res                 = this.SUPER(config)

            // sub tests should not wait for Ext.onReady or for application launch
            res.waitForAppReady     = false
            res.waitForExtReady     = false

            return res
        },


        isReady : function () {
            var result      = this.SUPERARG(arguments);

            if (!result.ready) return result;

            var me          = this
            var Ext         = this.getExt();
            var R           = Siesta.Resource('Siesta.Test.ExtJSCore');

            var loaderPath  = this.loaderPath
            var StartTest   = this.global.StartTest

            if (loaderPath && Ext && Ext.Loader && !StartTest.loaderPathHookInstalled) {
                this.project.generateLoaderPathHook()(StartTest, Ext, loaderPath)
            }

            var requires    = this.requires

            if (requires && !this.requiringWaitingStarted && Ext && Ext.require) {
                this.requiringWaitingStarted    = true

                Ext.require(requires, function () {
                    me.isRequiringDone      = true
                })
            }

            // in microloaded apps, Ext.onReady may appear with some arbitrary delay
            if (this.waitForExtReady && !this.onReadyWaitingStarted && Ext && Ext.onReady) {
                this.onReadyWaitingStarted  = true

                Ext.onReady(function () {
                    me.isExtOnReadyDone     = true
                })
            }

            // Sencha Touch has a weird intermediate state, where Ext object is already on the page, but it misses
            // almost every property people are used to, like "ComponentQuery", "onReady" etc
            // detecting such state with "Ext.blink" property
            if (
                this.waitForExtComponentQueryReady
                && Ext
                // this indicates Ext>=4, Ext3 does not have "ComponentQuery" concept
                && (Ext.getVersion || Ext.blink || Ext.manifest || Ext.microloaded)
                && !Ext.ComponentQuery
            ) return {
                ready       : false,
                reason      : R.get('waitedForComponentQuery')
            }

            if (requires && !this.isRequiringDone) return {
                ready       : false,
                reason      : R.get('waitedForRequires')
            }

            if (this.waitForExtReady && this.onReadyWaitingStarted && !this.isExtOnReadyDone) return {
                ready       : false,
                reason      : R.get('waitedForExt')
            }

            if (this.waitForAppReady && !this.isAppReadyDone && Ext) {
                var name            = Ext.manifest.name

                var isAppReadyDone  = false

                try {
                    isAppReadyDone  = me.global[ name ].getApplication().launched
                } catch (e) {
                }

                if (isAppReadyDone)
                    this.isAppReadyDone = isAppReadyDone
                else
                    return {
                        ready       : false,
                        reason      : R.get('waitedForApp')
                    }
            }

            if (Ext && Ext.ComponentQuery) {
                // add :root pseudo CQ selector to be able to identify 'root' level components that don't have
                // parent containers. value is 1-based
                this.installRootPseudoCQ(Ext)
            }

            return {
                ready       : true
            }
        }
    },

    methods : {

        initialize : function() {
            // Since this test is preloading Ext JS, we should let Siesta know what to 'expect'
            this.expectGlobals('Ext', 'id');
            this.SUPER();
        },


        getSimulatorClass : function () {
            return Siesta.Test.SimulatorExtJS
        },


        forEachModelInAllSchemas : function (func) {
            var Ext     = this.getExt()

            if (Ext && Ext.data && Ext.data.schema && Ext.data.schema.Schema && Ext.undefine) {
                Joose.O.each(Ext.data.schema.Schema.instances, function (schema, name) {

                    schema.eachEntity(function (entityName) {
                        var entity  = schema.getEntity(entityName)

                        func(entity, entityName, entity.$className, schema)
                    })
                })
            }
        },


        doStart : function () {
            var me      = this;
            var Ext     = this.getExt();

            if (!Ext) {
                // proceed to parent implementation disabling our "can start" checkers
                this.waitForAppReady    = false
                this.waitForExtReady    = false
                this.requires           = null

                this.SUPERARG(arguments)

                return
            }

            // PROBABLY NOT NEEDED AS OF EXT5
            // this flag will explain to Ext, that DOM ready event has already happened
            // Ext fails to set this flag if it was loaded dynamically, already after DOM ready
            // the test will start only after DOM ready anyway, so we just set this flag
            Ext.isReady         = true

            if (!Ext.manifest || !Ext.manifest.name) this.waitForAppReady = false

            this.SUPERARG(arguments)
        },

        /**
         * This method returns the `Ext` object from the scope of the test. When creating your own assertions for Ext JS code, you need
         * to make sure you are using this method to get the `Ext` instance. Otherwise, you'll be using the same "top-level" `Ext`
         * instance, used by the project for its UI.
         *
         * For example:
         *
         *      elementHasProvidedCssClass : function (el, cls, desc) {
         *          var Ext     = this.getExt();
         *
         *          if (Ext.fly(el).hasCls(cls)) {
         *              this.pass(desc);
         *          } else {
         *              this.fail(desc);
         *          }
         *      }
         *
         * @return {Object} The `Ext` object from the scope of test
         */
        getExt : function () {
            return this.global.Ext
        },


        /**
         * The alias for {@link #getExt}
         * @method
         */
        Ext : function () {
            return this.global.Ext
        },


        isExtJSComponentQueryTarget : function (obj) {
            var Ext     = this.getExt()

            return Boolean(obj && Ext && (Ext.Component && obj instanceof Ext.Component || obj.isWidget))
        },


        /**
         * This method performs an ExtJS component query. The selector may start with `>>` which will be
         * trimmed.
         *
         * @param {String} selector A component query selector. The leading '>>' will be trimmed.
         * @param {Ext.Component} root A root for the component query.
         * @param {Object} options
         * @param {Boolean} options.ignoreNonVisible Whether to remove the hidden components from the results
         *
         * @return {Array[Ext.Component]} Array of matching components
         */
        componentQuery : function (selector, root, options) {
            options     = options || {}
            var Ext     = this.Ext()

            if (!selector || !Ext || !Ext.ComponentQuery) return []

            // strip out leading >>  which is used as indicator of the ComponentQuery in ActionTarget string
            selector    = this.trimString(selector.replace(/^(\s*>>)?/, ''))

            var result  = Ext.ComponentQuery.query(selector, root);

            if (options.ignoreNonVisible) {
                var me              = this
                var onlyVisible     = []

                Joose.A.each(result, function (cmp) {
                    // Sencha Touch components have no "isVisible()" method
                    // we use `componentIsHidden` here which peforms just the "hierarchical" check (does not use "elementIsTop")
                    if (!me.componentIsHidden(cmp)) onlyVisible.push(cmp)
                });

                result              = onlyVisible
            }

            return result
        },


        // Accepts Ext.Component or ComponentQuery
        normalizeComponent : function (component, allowEmpty, options) {
            options         = options || {}
            var Ext         = this.Ext()
            var me          = this

            var matchingMultiple    = false

            if (this.typeOf(component) === 'String') {
                var result  = this.componentQuery(component, null, { ignoreNonVisible : options.ignoreNonVisible })

                var R       = Siesta.Resource('Siesta.Test.ExtJSCore');

                if (!allowEmpty && result.length < 1)   this.warn(R.get('noComponentMatch').replace('{component}', component));

                if (result.length > 1)   {
                    matchingMultiple    = true

                    var text        = R.get('multipleComponentMatch').replace('{component}', component);

                    if (this.project.failOnMultipleComponentMatches) {
                        this.fail(text);
                    } else {
                        this.warn(text);
                    }
                }

                component = result[ 0 ];
            }

            return options.detailed ? { comp : component, matchingMultiple : matchingMultiple } : component
        },

        /**
         * @private
         *
         * @param {Ext.Component} comp the Ext.Component
         * @param {Boolean} locateInputEl For form fields, try to find the inner input element by default.
         * If you want to target the containing Component element, pass false instead.
         *
         * @return {Ext.dom.Element}
         */
        compToEl : function (comp, locateInputEl) {
            if (!comp) return null

            var Ext         = this.Ext();
            locateInputEl   = locateInputEl !== false;

            // Handle editors, deal with the field directly
            if (Ext.Editor && comp instanceof Ext.Editor && comp.field) {
                comp        = comp.field;
            }

            // Ext JS
            if (Ext && Ext.form && Ext.form.Field && locateInputEl) {
                // Deal with bizarre markup in Ext 5.1.2+
                if (
                    (Ext.form.Checkbox && comp instanceof Ext.form.Checkbox || Ext.form.Radio && comp instanceof Ext.form.Radio)
                    && comp.el
                ) {
                    var displayEl   = comp.displayEl;

                    if (displayEl && comp.boxLabel) {
                        return displayEl;
                    }

                    var inputComponent  = Ext.ComponentQuery.query('checkboxinput', comp)[ 0 ]

                    if (inputComponent) return this.compToEl(inputComponent)

                    //                                                    Ext6 Modern               Ext6.7                                   Fallback
                    return comp.el.down('.x-form-field') || comp.el.down('.x-field-input') || comp.el.down('.x-input-el') || comp.inputEl || comp.el;
                }

                if (comp instanceof Ext.form.Field && comp.inputEl) {
                    var field       = comp.el.down('.x-form-field');

                    return (field && field.dom) ? field : comp.inputEl;
                }

                if (Ext.form.HtmlEditor && comp instanceof Ext.form.HtmlEditor) {
                    //     Ext JS 3       Ext JS 4
                    return comp.iframe || comp.inputEl;
                }
            }

            if (Ext && Ext.field && Ext.field.Slider && (comp instanceof Ext.field.Slider)) {
                return this.compToEl(Ext.ComponentQuery.query('slider', comp)[ 0 ])
            }

            // Sencha Touch: Form fields can have a child input component
            if (Ext && Ext.field && Ext.field.Field && comp instanceof Ext.field.Field && locateInputEl && comp.getComponent) {
                comp        = comp.getComponent();

                // some of the SenchaTouch fields uses "masks" - another DOM element, which is applied
                // on top of the field when it does not have focus
                // some of them have mask always ("useMask === true"), for such fields return mask element
                // as its the primary point of user interaction
                if (comp.getUseMask && comp.getUseMask() === true && comp.mask) return comp.mask

                if (locateInputEl && comp.input) return comp.input

                if (comp.bodyElement) return comp.bodyElement
            }

            //                      Ext JS   vs                    Sencha Touch
            return comp.getEl && !comp.element ? comp.getEl() : locateInputEl && comp.input || comp.el || comp.element;
        },

        // Accept Ext.Element and Ext.Component
        // If the 'shallow' flag is true we should not 'reevaluate' the target element - stop at the component element.
        normalizeElement : function(el, allowMissing, shallow, detailed, options) {
            if (!el)         return null

            if (el.nodeName) return el;

            var matchingMultiple = false
            var query
            var Ext     = this.getExt();
            var origEl  = el;
            var scopeAdjusted;

            //var offset                      = options && options.offset
            var stopAtComponentLevel        = options && options.stopAtComponentLevel
            var ignoreNonVisible            = options && options.hasOwnProperty('ignoreNonVisible') ? options.ignoreNonVisible : true

            if (typeof el === 'string') {
                var mainParts  = el.split('->');

                if (mainParts.length === 2) {
                    scopeAdjusted = this.adjustScope(el);

                    el = this.trimString(mainParts[ 1 ]);

                    // Frame might not yet exist, or be ready
                    if (!scopeAdjusted ||
                        ((el.match(/^\s*>>/) || el.match(/=>/)) && !this.Ext())) {
                        this.resetScope();
                        return null;
                    }
                }

                if (el.match(/=>/)) {
                    // Composite query
                    query               = this.compositeQuery(el, null, allowMissing, ignoreNonVisible)
                    el                  = query[ 0 ]
                    matchingMultiple    = query.length > 1
                } else if (el.match(/^\s*>>/)) {
                    var compRes         = this.normalizeComponent(el, allowMissing, { ignoreNonVisible : ignoreNonVisible, detailed : true })

                    el                  = compRes.comp
                    matchingMultiple    = compRes.matchingMultiple
                } else {
                    // string in unknown format, guessing it's a DOM query
                    var retVal          = this.SUPER(el, allowMissing, shallow, detailed);

                    if (scopeAdjusted) this.resetScope();

                    return retVal;
                }

                if (!allowMissing && !el) {
                    var R               = Siesta.Resource('Siesta.Test.ExtJSCore');
                    var warning         = R.get('noComponentFound') + ': ' + origEl;

                    this.warn(warning);
                    if (scopeAdjusted) this.resetScope();
                    throw warning;
                }
            }

            var rawResult       = false

            if (this.isExtJSComponentQueryTarget(el))
                if (stopAtComponentLevel)
                    rawResult   = true
                else {
                    el          = this.compToEl(el);
                }

            // ExtJS Element
            if (el && el.dom)
                if (stopAtComponentLevel)
                    rawResult   = true
                else
                    el          = el.dom

            // will also handle the case of conversion of array with coordinates to el
            var res             = rawResult ? el : this.SUPER(el, allowMissing, shallow);

            if (scopeAdjusted) this.resetScope();

            return detailed ? { el : res, matchingMultiple : matchingMultiple } : res
        },


        // this method generally has the same semantic as the "normalizeElement", but resolved
        // till the component level only.. Which we prefer for the "firesOk" assertions family.
        // It's also being used in Siesta.Test.Action.Role.HasTarget to determine what to pass to the next step
        // from the previous step, which has been specified with the Siesta.Test.ActionTarget descriptor
        //
        // on the browser level the only possibility is DOM element
        // but on ExtJS level user can also use ComponentQuery and next step need to receive the
        // component instance
        normalizeActionTarget : function (el, allowMissing, ignoreNonVisible) {
            return this.normalizeElement(
                el,
                allowMissing,
                false, // shallow
                false, // detailed
                { ignoreNonVisible : ignoreNonVisible !== false, stopAtComponentLevel : true } // options
            );
        },

         /**
         * This method allow assertions to fail silently for tests executed in versions of Ext JS up to a certain release. When you try to run this test on a newer
         * version of Ext JS and it fails, it will fail properly and force you to re-investigate. If it passes in the newer version, you should remove the
         * use of this method.
         *
         * See also {@link Siesta.Test#todo}
         *
         * @param {String} frameworkVersion The Ext JS framework version, e.g. '4.0.7'
         * @param {Function} fn The method covering the broken functionality
         * @param {String} reason The reason or explanation of the bug
        */
        knownBugIn : function(frameworkVersion, fn, reason) {
            var Ext     = this.getExt();
            var version = Ext.versions.extjs || Ext.versions.touch;
            var R       = Siesta.Resource('Siesta.Test.ExtJSCore');

            if (this.project.failKnownBugIn || version.isGreaterThan(frameworkVersion)) {
                fn.call(this.global, this);
            } else {
                this.todo(R.get('knownBugIn') + ' ' + frameworkVersion + ': ' + (reason || ''), fn);
            }
        },


         /**
         * This method will load the specified classes with `Ext.require()` and call the provided callback. Additionally it will check that all classes have been loaded.
         *
         * This method accepts either variable number of arguments:
         *
         *      t.requireOk('Some.Class1', 'Some.Class2', function () { ... })
         * or array of class names:
         *
         *      t.requireOk([ 'Some.Class1', 'Some.Class2' ], function () { ... })
         *
         * @param {String} className1 The name of the class to `require`
         * @param {String} className2 The name of the class to `require`
         * @param {String} classNameN The name of the class to `require`
         * @param {Function} fn The callback. Will be called even if the loading of some classes have failed.
        */
        requireOk : function () {
            var me                  = this
            var global              = this.global
            var Ext                 = this.getExt()
            var args                = Array.prototype.concat.apply([], arguments)
            var R                   = Siesta.Resource('Siesta.Test.ExtJSCore');

            var callback

            if (this.typeOf(args[ args.length - 1 ]) == 'Function') callback = args.pop()


            // what to do when loading completed or timed-out
            var continuation    = function () {
                me.endAsync(async)

                Joose.A.each(args, function (className) {
                    var clsManager  = Ext.ClassManager
                    var cls         = clsManager.get(className)

                    /**
                     * Checks if the class being required is an override, which is not available
                     * via Ext.ClassManager.get(). Only available in ExtJS 5+.
                     *
                     * See: https://www.assembla.com/spaces/bryntum/tickets/2201
                     */
                    var isOverride  = clsManager.overrideMap && clsManager.overrideMap[ className ]

                    //   override               normal class                         singleton
                    if (isOverride || cls && (me.typeOf(cls) == 'Function' || me.typeOf(cls.self) == 'Function'))
                        me.pass(R.get('Class') + ": " + className + " " + R.get('wasLoaded'))
                    else
                        me.fail(R.get('Class') + ": " + className + " " + R.get('wasNotLoaded'))
                })

                me.processCallbackFromTest(callback)
            }

            var timeout         = this.defaultTimeout,
                async           = this.beginAsync(timeout + 100)

            var hasTimedOut             = false
            var originalSetTimeout      = this.originalSetTimeout
            var originalClearTimeout    = this.originalClearTimeout

            var timeoutId       = originalSetTimeout(function () {
                hasTimedOut     = true
                continuation()
            }, timeout)

            Ext.Loader.setConfig({ enabled : true });

            Ext.require(args, function () {
                originalClearTimeout(timeoutId)

                if (!hasTimedOut) continuation()
            })
        },

        /**
         * This method is a simple wrapper around the {@link #chainClick} - it performs a component query for provided `selector` starting from the `root` container
         * and then clicks on all found components, in order:
         *

    // click all buttons in the `panel`
    t.clickComponentQuery('button', panel, function () {})

         *
         * The 2nd argument for this method can be omitted and method can be called with 2 arguments only. In this case a global component query will be performed:
         *

    // click all buttons in the application
    t.clickComponentQuery('button', function () {})

         *
         * @param {String} selector The selector to perform a component query with
         * @param {Ext.Container} root The optional root container to start a query from.
         * @param {Function} callback The callback to call, after clicking all the found components
         */
        clickComponentQuery : function (selector, root, callback) {

            if (arguments.length == 2 && this.typeOf(arguments[ 1 ]) == 'Function') {
                callback    = root
                root        = this.Ext().ComponentQuery
            }

            if (arguments.length == 1) {
                root        = this.Ext().ComponentQuery
            }

            var result      = root.query(selector)

            this.chainClick(result, function () { callback && callback.call(this, result) })
        },


        /**
         * An alias for {@link #clickComponentQuery}.
         *
         * @param {String} selector The selector to perform a component query with
         * @param {Ext.Container} root The optional root container to start a query from.
         * @param {Function} callback The callback to call, after clicking all the found components
         */
        clickCQ : function () {
            this.clickComponentQuery.apply(this, arguments)
        },

        /**
         * This method performs a combination of `Ext.ComponentQuery` and DOM query, allowing to easily find the DOM elements,
         * matching a css selector, inside of some Ext.Component.
         *
         * Both queries should be combined with the `=>` separator:
         *
         *      gridpanel[title=Accounts] => .x-grid-row
         *
         * On the left side of such "composite" query should be a component query, on the right - DOM query (CSS selector)
         *
         * In case when component query returns more than one component, this method iterate through all of them and will try to
         * resolve the 2nd part of the query. The results from the 1st component with matching DOM nodes is returned.
         *
         * E.g. the composite query `gridpanel[title=Accounts] => .x-grid-row` will give you the grid row elements inside a grid panel
         * with `title` config matching "Accounts".
         *
         * @param {String} selector The CompositeQuery selector
         * @param {Ext.Component} root The optional root component to start the component query from. If omitted, a global component query will be performed.
         * @param {Boolean} allowEmpty False to throw the exception from this method if no matching DOM element is found. Default is `true`.
         *
         * @return {HTMLElement[]} The array of DOM elements
         */
        compositeQuery : function (selector, root, allowEmpty, onlyVisibleComponents) {
            allowEmpty          = allowEmpty !== false

            var Ext             = this.Ext();
            var R               = Siesta.Resource('Siesta.Test.ExtJSCore')
            var i

            // Try to find magic => selector for nested ComponentQuery and CSS selector
            var mainParts       = selector.split('=>');

            root                = root || Ext && Ext.ComponentQuery;

            // Root might not exist, Ext could be loaded in bootstrap mode without CQ
            if (!root) return []

            if (mainParts.length < 2) throw R.get('invalidCompositeQuery') + ': ' + selector

            var compQuery       = mainParts[ 0 ]
            var domQuery        = mainParts[ 1 ]

            var components

            if (compQuery.match(/\.\w+\(/)) {
                var match
                var re          = /(.+?)\.(\w+)\(\)/g

                // complex case like: xtype1 xtype2.getPicker() xtype3 xtype4.someMethod()
                while (root && (match = re.exec(compQuery)) != null) {
                    // TODO assuming query is specific, targeting just one target
                    root        = root.query(match[ 1 ])[ 0 ]

                    if (root && match[ 2 ]) root = root[ match[ 2 ] ]()
                }

                if (!root && !allowEmpty) throw R.get('invalidCompositeQuery') + ': ' + selector

                components     = [ root ]
            } else {
                components     = root.query(compQuery)
            }

            if (!components.length)
                if (allowEmpty)
                    return []
                else
                    throw R.get('ComponentQuery') + ' ' + compQuery + ' ' + R.get('matchedNoCmp');

            for (i = 0; i < components.length; i++) {
                var cmp             = components[i];

                if (
                    cmp.rendered && (            // Widgets don't implement isVisible/isHidden
                        !onlyVisibleComponents || cmp.isWidget || (cmp.isVisible ? cmp.isVisible() : !cmp.isHidden())
                    )
                ) {
                    var result  = this.compToEl(cmp, false);
                    result      = this.sizzle(domQuery, result.dom)

                    if (result.length > 0) {
                        return result;
                    }
                }
            }

            if (allowEmpty) {
                return [];
            }
            throw R.get('CompositeQuery') + ' ' + selector + ' matched no DOM elements';
        },

        /**
         * An alias for Ext.ComponentQuery.query.
         *
         * As a convenience, this method will strip leading `>>` characters from the query
         * (which denotes the component query in {@link Siesta.Test.ActionTarget}).
         *
         * @param {String} selector The selector to perform a component query with
         */
        cq : function (selector) {
            return this.Ext().ComponentQuery.query(selector.replace(/^(\s*>>)?/, ''));
        },

        /**
         * An shorthand method to get the first result of any Ext.ComponentQuery.query
         *
         * As a convenience, this method will strip leading `>>` characters from the query
         * (which denotes the component query in {@link Siesta.Test.ActionTarget}).
         *
         * @param {String} selector The selector to perform a component query with
         */
        cq1 : function (selector) {
            return this.Ext().ComponentQuery.query(selector.replace(/^(\s*>>)?/, ''))[ 0 ];
        },

        /**
         * Waits until the passed action target is detected and no ongoing animations are found. This can be a string such as a component query, CSS query or a composite query.
         *
         * @param {String/Siesta.Test.ActionTarget} target The target presence to wait for
         * @param {Function} callback The callback to call after the target has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForTarget : function(target, callback, scope, timeout, offset) {
            var SUPER   = this.SUPER

            this.waitForAnimations(function () {
                SUPER.call(this, target, callback, scope, timeout, offset)
            }, this, timeout);
        },

        /**
         * This assertion passes if the singleton MessageBox instance is currently visible.
         * The assertion is relevant if you use one of the following methods Ext.Msg.alert, Ext.Msg.confirm, Ext.Msg.prompt.
         *
         * @param {String} [description] The description for the assertion
         */
        messageBoxIsVisible : function(desc) {
            return this.notOk(this.Ext().Msg.isHidden(), desc || Siesta.Resource('Siesta.Test.ExtJSCore', 'messageBoxVisible'));
        },

        /**
         * This assertion passes if the singleton MessageBox instance is currently hidden.
         * The assertion is relevant if you use one of the following methods Ext.Msg.alert, Ext.Msg.confirm, Ext.Msg.prompt.
         *
         * @param {String} [description] The description for the assertion
         */
        messageBoxIsHidden : function(desc) {
            return this.ok(this.Ext().Msg.isHidden(), desc || Siesta.Resource('Siesta.Test.ExtJSCore', 'messageBoxHidden'));
        },

        /**
         * This assertion passes if the passed component query matches at least one component.
         *
         * @param {String} query The component query
         * @param {String} [description] The description for the assertion
         */
        cqExists : function(query, description) {
            this.ok(this.cq1(query), description);
        },

        /**
         * This assertion passes if the passed component query matches no components.
         *
         * @param {String} query The component query
         * @param {String} [description] The description for the assertion
         */
        cqNotExists : function(query, description) {
            this.notOk(this.cq1(query), description);
        },

        /**
         * This assertion passes if the passed component query matches at least one component.
         *
         * @param {String} query The component query
         * @param {String} [description] The description for the assertion
         */
        componentQueryExists : function() {
            this.cqExists.apply(this, arguments);
        },

        /**
         * Sets a value to an Ext Component. A faster way to set a value than manually calling "type" into
         * a text field for example. A value is set by calling either the `setRawValue` or `setValue` method
         * of the component.
         *
         * @param {Ext.Component/String} component A component instance or a component query to resolve
         * @param {Mixed} value
         */
        setValue : function (component, value, callback, scope) {
            component = this.normalizeComponent(component);

            (component.setChecked || component.setRawValue || component.setValue).call(component, value);

            callback && this.processCallbackFromTest(callback, null, scope)
        },


        /**
         * Waits until no ongoing animations can be detected.
         *
         * @param {Function} callback The callback to call after the component becomes visible
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForAnimations: function (callback, scope, timeout) {
            var R   = Siesta.Resource('Siesta.Test.ExtJS');
            var me  = this;

            return this.waitFor({
                method          : function () { return !me.areAnimationsRunning(); },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForAnimations',
                description     : ' ' + R.get('animationsToFinalize')
            });
        },


        /**
         * This method resolves a query string, as defined by the {@link Siesta.Test.ActionTarget}. See the link for details,
         * here we'll just briefly mention, that by default string supposed to be a CSS query. If it starts with `>>`
         * it will be recognized as Component query. And if it contains the `=>` characters, then it will be
         * considered a {@link compositeQuery compositeQuery}.
         *
         * @param {String} selector
         * @return {Array[Element]}
         */
        query : function (selector) {
            var me              = this
            var result

            if (selector.match(/=>/)) {
                // Composite query
                result          = this.compositeQuery(selector, null, true, false)
            } else if (selector.match(/^\s*>>/)) {
                // Component query
                result          = this.componentQuery(selector, null, { ignoreNonVisible : false })

                result          = Joose.A.map(result, function (cmp) { return me.compToEl(cmp).dom })

            } else {
                // DOM query
                result          = this.sizzle(selector)
            }

            return result
        }
    }
})
;
/**
@class Siesta.Test.ExtJS.Ajax

This is a mixin, with helper methods for mocking Ajax functionality in Ext JS. This mixin is consumed by {@link Siesta.Test.ExtJS}. 
This is only supported when testing Ext JS 4.
*/
Role('Siesta.Test.ExtJS.Ajax', {
    has : {
        responses   : Joose.I.Array,
        urlMatchers : Joose.I.Array
    },

    methods: {

        /**
         * This assertion passes if there is at least one ongoing ajax call.
         * 
         * @param {Object} object (optional) The options object passed to Ext.Ajax.request
         * @param {String} [description] The description for the assertion
         */
        isAjaxLoading: function (obj, description) {
            var Ext = this.Ext();
            this.ok(Ext.Ajax.isLoading(obj), description || Siesta.Resource('Siesta.Test.ExtJS.Ajax', 'ajaxIsLoading'));
        },

        /**
         * This method calls the supplied URL using Ext.Ajax.request and then calls the provided callback. The callback will be called with the 
         * same parameters as the normal Ext.Ajax.request callback is called with ("options", "success" and "response"). To get the response text,
         * use response.responseText.
         * 
         * @param {String/Object} url The url or the options to pass to Ext.Ajax.request
         * @param {Function} callback The callback to call after the ajax request is completed
         * @param {Object} scope The scope for the callback
         */
        ajaxRequestAndThen: function (url, callback, scope) {
            var Ext     = this.Ext();
            var options = url;

            if (typeof(url) === 'string') {
                options = {
                    url         : url,
                    callback    : callback,
                    scope       : scope
                };
            }

            Ext.Ajax.request(options);
        },

        /**
         * Waits until the passed Ext.Ajax request object has completed, or until the latest performed Ajax request is done if the first argument is omitted.
         * 
         * @param {Object} object (optional) The options object passed to Ext.Ajax.request
         * @param {Function} callback The callback to call after the ajax request is completed
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test#waitForTimeout} value. 
         */
        waitForAjaxRequest: function (obj, callback, scope, timeout) {
            var Ext = this.Ext();
            var msg;

            if (typeof obj === 'function') {
                msg         = ' ' + Siesta.Resource('Siesta.Test.ExtJS.Ajax', 'allAjaxRequestsToComplete');
                timeout     = scope;
                scope       = callback;
                callback    = obj;
                obj         = undefined;
            } else {
                msg = ' ' + Siesta.Resource('Siesta.Test.ExtJS.Ajax', 'ajaxRequest') + ' "' + obj.options.url + '" ' + Siesta.Resource('Siesta.Test.ExtJS.Ajax', 'toComplete');
            }

            return this.waitFor({
                method          : function() { 
                    if (obj) {
                        return !Ext.Ajax.isLoading(obj) && obj;
                    }
                    return !Ext.Ajax.isLoading();
                }, 
                callback        : callback,
                scope           : scope, 
                timeout         : timeout,
                assertionName   : 'waitForAjaxRequest',
                description     : msg
            });
        }
    }
});
;
/**
@class Siesta.Test.ExtJS.Store

This is a mixin, with helper methods for testing functionality relating to Ext.data.Store class. This mixin is being consumed by {@link Siesta.Test.ExtJS}

*/
Role('Siesta.Test.ExtJS.Store', {
    
    methods : {
        
        /**
         * Waits until all the passed stores have been loaded (fires the "load" event) and calls the provided callback.
         * 
         * This method accepts either variable number of arguments:
         *
         *      t.waitForStoresToLoad(store1, store2, function () { ... })
         * or array of stores:
         * 
         *      t.waitForStoresToLoad([ store1, store2 ], function () { ... })
         * 
         * @param {Ext.data.AbstractStore} store1 The store to load.
         * @param {Ext.data.AbstractStore} store2 The store to load.
         * @param {Ext.data.AbstractStore} storeN The store to load.
         * @param {Function} callback A function to call when the condition has been met.
         */        
        waitForStoresToLoad: function () {
            var Ext         = this.getExt();
            var args        = Array.prototype.concat.apply([], arguments)
            var me          = this;
            var R           = Siesta.Resource('Siesta.Test.ExtJS.Store');

            // Ext 3
            var baseStoreCls = Ext.data.AbstractStore || Ext.data.Store;
            var callback
            var storesNum;
            
            // First locate the callback
            Joose.A.each(args, function (arg, index) {
                if (me.typeOf(arg) == 'Function') {
                    callback = arg;
                    storesNum = index;
                    return false;
                }
            });

            var loaded      = 0;
            
            var result      = me.waitFor({
                method      : function() { return loaded == storesNum; },
                callback    : callback,
                name        : 'waitForStoresToLoad',
                description : storesNum + ' ' + R.get('storesToLoad')
            });

            Joose.A.each(args, function (store) {               
                             // Ext 3       // Ext 4 && ST
                var proxy = (store.proxy || store.getProxy && store.getProxy());
                
                if (!(store instanceof baseStoreCls)) {
                    return false;
                }

                if (!proxy) {
                    storesNum--;
                    return;
                }

                store.on('load', function () {
                    loaded++;
                    proxy.un('exception', exceptionFailure);
                }, null, { single : true });

                var exceptionFailure = function (proxy, response, operation) {
                    var url     = proxy.api && proxy.api.read || proxy.url
                    
                    me.fail(R.get('failedToLoadStore'), R.get('URL') + ": " + url);
                };

                proxy.on('exception', exceptionFailure);
            });
            
            return result
        },

        /**
         * This method is a wrapper around {@link #waitForStoresToLoad} method - it waits for the provided stores to fire the "load" event.
         * In addition to {@link #waitForStoresToLoad} this method also calls the `load` method of each passed store.
         * 
         * This method accepts either variable number of arguments:
         *
         *      t.loadStoresAndThen(store1, store2, function () { ... })
         * or array of stores:
         * 
         *      t.loadStoresAndThen([ store1, store2 ], function () { ... })
         * 
         * @param {Ext.data.AbstractStore} store1 The store to load.
         * @param {Ext.data.AbstractStore} store2 The store to load.
         * @param {Ext.data.AbstractStore} storeN The store to load.
         * @param {Function} callback A function to call when the condition has been met.
         */  
        loadStoresAndThen: function () {
            var Ext = this.getExt();
            this.waitForStoresToLoad.apply(this, arguments);
            
            var args                =  Array.prototype.concat.apply([], arguments)
            
            if (this.typeOf(args[ args.length - 1 ]) == 'Function') args.pop()

            Joose.A.each(args, function (store) {
                var proxy = (store.proxy || store.getProxy && store.getProxy());
                if (proxy && store.load) {
                    store.load();
                }
            });
        },

        /**
         * Passes if the passed store has no data.
         * 
         * @param {Ext.data.AbstractStore} store
         * @param {String} [description] The description of the assertion
         */
        isStoreEmpty : function(store, description) {
            this.is(store.getCount(), 0, description);
        }
    }
});
;
/**
@class Siesta.Test.ExtJS.Observable

This is a mixin, with helper methods for testing functionality relating to Ext.util.Observable class. This mixin is being consumed by {@link Siesta.Test.ExtJS}

*/
Role('Siesta.Test.ExtJS.Observable', {
    
    methods : {
        
        addListenerToObservable : function (observable, event, listener, isSingle) {
            var Ext     = this.Ext()
            
            if (Ext) {
                observable  = this.normalizeActionTarget(observable, false, false)

                // The way events are fired is slightly different for Ext vs raw DOM tests
                if (observable.nodeName && observable.tagName) {
                    var targetWin = (observable.ownerDocument.parentWindow || observable.ownerDocument.defaultView);

                    if (targetWin.Ext) {
                        observable = targetWin.Ext.get(observable);
                    }
                }

                if (observable.on && observable.un)
                    observable.on(event, listener, null, { single : isSingle })
                else
                    this.SUPERARG(arguments)
            } else
                this.SUPERARG(arguments)
        },
        
        
        removeListenerFromObservable : function (observable, event, listener) {
            var Ext     = this.Ext()
            
            if (Ext) {
                // DOM element might already be removed from the DOM
                observable  = this.normalizeActionTarget(observable, true, false)

                if (!observable) return;

                // The way events are fired is slightly different for Ext vs raw DOM tests
                if (observable && observable.nodeName && observable.tagName) {
                    var targetWin = (observable.ownerDocument.parentWindow || observable.ownerDocument.defaultView);

                    if (targetWin.Ext) {
                        observable = targetWin.Ext.get(observable);
                    }
                }

                if (observable.on && observable.un)
                    observable.un(event, listener)
                else
                    this.SUPERARG(arguments)
            } else
                this.SUPERARG(arguments)
        },

        /**
         * This assertion passes if the observable does not fire the specified event(s) after calling this method.
         * 
         * Its overriden in this role, so you can also provide Ext.util.Observable instances to it, otherwise its identical to parent method.
         * 
         * @param {Ext.util.Observable/Siesta.Test.ActionTarget} observable Ext.util.Observable instance or target as specified by the {@link Siesta.Test.ActionTarget} rules with 
         * the only difference that component queries will be resolved till the component level, and not the DOM element.
         * @param {String/Array[String]} event The name of event or array of such
         * @param {String} [desc] The description of the assertion.
         * 
         * @method wontFire
         */
        

        /**
         * This assertion passes if the observable fires the specified event exactly once after calling this method.
         * 
         * Its overriden in this role, so you can also provide Ext.util.Observable instances to it, otherwise its identical to parent method.
         * 
         * @param {Ext.util.Observable/Siesta.Test.ActionTarget} observable Ext.util.Observable instance or target as specified by the {@link Siesta.Test.ActionTarget} rules with 
         * the only difference that component queries will be resolved till the component level, and not the DOM element.
         * @param {String/Array[String]} event The name of event or array of such
         * @param {String} [desc] The description of the assertion.
         * 
         * @method firesOnce
         */

        /**
         * This assertion passes if the observable fires the specified event at least `n` times after calling this method.
         * 
         * Its overriden in this role, so you can also provide Ext.util.Observable instances to it, otherwise its identical to parent method.
         * 
         * @param {Ext.util.Observable/Siesta.Test.ActionTarget} observable Ext.util.Observable instance or target as specified by the {@link Siesta.Test.ActionTarget} rules with 
         * the only difference that component queries will be resolved till the component level, and not the DOM element.
         * @param {String} event The name of event
         * @param {Number} n The minimum number of events to be fired
         * @param {String} [desc] The description of the assertion.
         * 
         * @method firesAtLeastNTimes
         */
        
        
        /**
         * This method will wait for the first `event`, fired by the provided Ext JS `observable` and will then call the provided callback.
         * 
         * @param {Ext.util.Observable/Siesta.Test.ActionTarget} observable Ext.util.Observable instance or target as specified by the {@link Siesta.Test.ActionTarget} rules with 
         * the only difference that component queries will be resolved till the component level, and not the DOM element.
         * @param {String} event The name of the event to wait for
         * @param {Function} callback The callback to call 
         * @param {Object} scope The scope for the callback
         * @param {Number} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        
        /**
         * This method passes if the provided `observable` has a listener for the `eventName`
         * 
         * @param {Ext.util.Observable/Siesta.Test.ActionTarget} observable Ext.util.Observable instance or target as specified by the {@link Siesta.Test.ActionTarget} rules with 
         * the only difference that component queries will be resolved till the component level, and not the DOM element.
         * @param {String} eventName The name of the event
         * @param {String} [description] The description of the assertion.
         */
        hasListener : function (observable, eventName, description) {
            var R           = Siesta.Resource('Siesta.Test.ExtJS.Observable');
            
            observable      = this.normalizeActionTarget(observable, true, false);

            if (!observable || !observable.hasListener) {
                this.fail(description, {
                    assertionName       : 'hasListener',
                    annotation          : R.get('hasListenerInvalid')
                })
                
                return
            }
            
            if (observable.hasListener(eventName))
                this.pass(description, {
                    descTpl             : R.get('hasListenerPass'),
                    eventName           : eventName
                })
            else
                this.fail(description, {
                    assertionName       : 'hasListener',
                    annotation          : R.get('hasListenerFail') + ': ' + eventName
                })
        }


        /**
         * This assertion will verify that the observable fires the specified event and supplies the correct parameters to the listener function.
         * A checker method should be supplied that verifies the arguments passed to the listener function, and then returns true or false depending on the result.
         * If the event was never fired, this assertion fails. If the event is fired multiple times, all events will be checked, but 
         * only one pass/fail message will be reported.
         * 
         * For example:
         * 

    t.isFiredWithSignature(store, 'add', function (store, records, index) {
        return (store instanceof Ext.data.Store) && (records instanceof Array) && t.typeOf(index) == 'Number'
    })
 
         * @param {Ext.util.Observable/Siesta.Test.ActionTarget} observable Ext.util.Observable instance or target as specified by the {@link Siesta.Test.ActionTarget} rules with 
         * the only difference that component queries will be resolved till the component level, and not the DOM element.
         * @param {String} event The name of event
         * @param {Function} checkerFn A method that should verify each argument, and return true or false depending on the result.
         * @param {String} [desc] The description of the assertion.
         */
    }
});
;
/**
@class Siesta.Test.ExtJS.Component

This is a mixin, with helper methods for testing functionality relating to Ext.Component. This mixin is being consumed by {@link Siesta.Test.ExtJS}.

*/
Role('Siesta.Test.ExtJS.Component', {

    requires: ['waitFor'],

    methods: {

        componentIsHidden : function (comp) {
            var el      = this.compToEl(comp);

            if (!el) return true

            return (comp.isHidden && comp.isHidden() || comp.isVisible && !comp.isVisible()) || !this.isElementVisible(el);
        },


        /**
         * Waits until the main element of the passed component is the 'top' element in the DOM. The callback will receive the passed component instance.
         *
         * @param {Ext.Component/String} component An Ext.Component instance or a ComponentQuery string. In the latter case,
         * this method will also wait until the component query find some component (meaning the component does not have to
         * be already created when waiting starts)
         * @param {Function} callback The callback to call after the component becomes visible
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForComponentVisible: function (component, callback, scope, timeout) {
            var R       = Siesta.Resource('Siesta.Test.ExtJS.Component');
            var me      = this;

            if (this.typeOf(component) != 'String' && !this.isExtJSComponentQueryTarget(component)) {
                throw R.get('badInputText') + ': ' + component;
            }

            return this.waitFor({
                method          : function () {
                    var comp    = me.normalizeComponent(component, true)

                    if (!comp) return false

                    var el      = me.compToEl(comp);

                    return el && me.elementIsTop(el, true) && comp;
                },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForComponentVisible',
                description     : ' ' + R.get('component') + ' "' + (me.typeOf(component) == 'String' ? component : component.id) + '" ' + R.get('toBeVisible')
            });
        },


        /**
         * Waits until the main element of the passed component is not visible. The callback will receive the passed component instance.
         *
         * @param {Ext.Component/String} component An Ext.Component instance or a ComponentQuery string. In the latter case,
         * this method will also wait until the component query find some component (meaning the component does not have to
         * be already created when waiting starts)
         * @param {Function} callback The callback to call after the component becomes not visible
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForComponentNotVisible: function (component, callback, scope, timeout) {
            var R       = Siesta.Resource('Siesta.Test.ExtJS.Component');
            var me      = this;

            if (this.typeOf(component) != 'String' && !this.isExtJSComponentQueryTarget(component)) {
                throw R.get('badInputText') + ': ' + component;
            }

            return this.waitFor({
                method          : function () {
                    var comp    = me.normalizeComponent(component, true)

                    if (!comp) return false

                    return me.componentIsHidden(comp) && comp
                },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForComponentNotVisible',
                description     : ' ' + R.get('component') + ' "' + (me.typeOf(component) == 'String' ? component : component.id) + '" ' + R.get('toNotBeVisible')
            });
        },


        /**
        * Waits until Ext.ComponentQuery detects some results from the passed query parameter. The callback will receive the result of the query.
        *
        * The "root" argument of this method can be omitted.
        *
        * @param {String} selector The component query phrase
        * @param {Ext.Container} root The container to start a component query from. Optional
        * @param {Function} callback The callback to call after the xtype has been found
        * @param {Object} scope The scope for the callback
        * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
        */
        waitForComponentQuery: function (selector, root, callback, scope, timeout) {
            // no `root` supplied
            if (this.typeOf(root) == 'Function') {
                timeout = scope
                scope = callback
                callback = root
                root = this.getExt() && this.getExt().ComponentQuery
            }

            return this.waitFor({
                method      : function () {
                    var result = (root && root.query(selector) || this.getExt() && this.getExt().ComponentQuery.query(selector));
                    return result && result.length > 0 ? result : false;
                },
                callback    : callback,
                scope       : scope,
                timeout     : timeout,
                assertionName   : 'waitForComponentQuery',
                description     : ' ' + Siesta.Resource('Siesta.Test.ExtJS.Component', 'componentQuery') + ' "' + selector + '"'
            });
        },

        /**
        * Waits until {@link Siesta.Test.ExtJSCore#compositeQuery} detects some results from the passed query parameter. The callback will receive the result of the query.
        *
        * The "root" argument of this method can be omitted.
        *
        * @param {String} query The composite query phrase
        * @param {Ext.Container} root The container to start a component query from. Optional
        * @param {Function} callback The callback
        * @param {Object} scope The scope for the callback
        * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
        */
        waitForCompositeQuery: function (query, root, callback, scope, timeout) {
            // no `root` supplied
            if (this.typeOf(root) == 'Function') {
                timeout     = scope
                scope       = callback
                callback    = root
                root        = this.getExt().ComponentQuery
            }

            var me = this;

            return me.waitFor({
                method      : function () {
                    var result = me.compositeQuery(query, root, true);

                    return result.length > 0 ? result : false;
                },
                callback    : callback,
                scope       : scope,
                timeout     : timeout,

                assertionName   : 'waitForCompositeQuery',
                description     : ' ' + Siesta.Resource('Siesta.Test.ExtJS.Component', 'compositeQuery') + ' "' + query + '"'
            });
        },


        /**
        * Waits until {@link Siesta.Test.ExtJSCore#compositeQuery} does not detects any results from the passed query parameter.
        *
        * The "root" argument of this method can be omitted.
        *
        * @param {String} query The composite query phrase
        * @param {Ext.Container} root The container to start a component query from. Optional
        * @param {Function} callback The callback
        * @param {Object} scope The scope for the callback
        * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
        */
        waitForCompositeQueryNotFound: function (query, root, callback, scope, timeout) {
            // no `root` supplied
            if (this.typeOf(root) == 'Function') {
                timeout     = scope
                scope       = callback
                callback    = root
                root        = this.getExt().ComponentQuery
            }

            var me = this;

            return me.waitFor({
                method      : function () {
                    var result = me.compositeQuery(query, root, true);

                    return result.length > 0 ? false : true;
                },
                callback    : callback,
                scope       : scope,
                timeout     : timeout,

                assertionName   : 'waitForCompositeQueryNotFound',
                description     : ' ' + Siesta.Resource('Siesta.Test.ExtJS.Component', 'compositeQuery') + ' "' + query + '" ' + Siesta.Resource('Siesta.Test.ExtJS.Component', 'toReturnEmptyArray')
            });
        },



        /**
        * Shorthand alias for {@link #waitForComponentQuery}
        *
        * @param {String} query The component query phrase
        * @param {Ext.Container} root The container to start a component query from
        * @param {Function} callback The callback to call after the xtype has been found
        * @param {Object} scope The scope for the callback
        * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
        */
        waitForCQ: function () {
            return this.waitForComponentQuery.apply(this, arguments);
        },


        /**
        * Alias for {@link #waitForComponentQueryNotFound}
        *
        * @param {String} query
        * @param {Function} callback
        * @param {Object} scope
        * @param {Number} timeout
        */
        waitForCQNotFound: function () {
            return this.waitForComponentQueryNotFound.apply(this, arguments);
        },


        /**
        * Waits until Ext.ComponentQuery from the passed query parameter is no longer found, and then calls the callback supplied.
        *
        * The "root" argument of this method can be omitted.
        *
        * @param {String} query The component query selector
        * @param {Ext.Container} root The container to start a component query from. Optional
        * @param {Function} callback The callback to call after the xtype has been found
        * @param {Object} scope The scope for the callback
        * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
        */
        waitForComponentQueryNotFound: function (query, root, callback, scope, timeout) {
            var R = Siesta.Resource('Siesta.Test.ExtJS.Component');

            // no `root` supplied
            if (this.typeOf(root) == 'Function') {
                timeout     = scope
                scope       = callback
                callback    = root
                root        = this.getExt().ComponentQuery
            }

            return this.waitFor({
                method      : function () {
                    var result = root.query(query);
                    return result.length === 0 && result;
                },
                callback    : callback,
                scope       : scope,
                timeout     : timeout,
                assertionName   : 'waitForComponentQueryNotFound',
                description     : R.get('componentQuery') + ': ' + query + ' ' + R.get('toReturnEmpty')
            });
        },


        /**
        * Alias for {@link #waitForComponentQueryVisible}
        *
        * @param {String} query
        * @param {Function} callback
        * @param {Object} scope
        * @param {Number} timeout
        */
        waitForCQVisible: function () {
            return this.waitForComponentQueryVisible.apply(this, arguments);
        },

        /**
         * Alias for {@link #waitForComponentQueryNotVisible}
         *
         * @param {String} query
         * @param {Function} callback
         * @param {Object} scope
         * @param {Number} timeout
         */
        waitForCQNotVisible: function () {
            return this.waitForComponentQueryNotVisible.apply(this, arguments);
        },

        /**
        * Waits until all results of the `Ext.ComponentQuery` are detected and visible.
        *
        * The "root" argument of this method can be omitted.
        *
        * @param {String} query The component query selector
        * @param {Ext.Container} root The container to start a component query from. Optional
        * @param {Function} callback The callback to call after the waiting has been completed
        * @param {Object} scope The scope for the callback
        * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
        */
        waitForComponentQueryVisible: function (query, root, callback, scope, timeout) {
            var me  = this,
                R   = Siesta.Resource('Siesta.Test.ExtJS.Component'),
                Ext = me.getExt();

            // no `root` supplied
            if (this.typeOf(root) == 'Function') {
                timeout     = scope
                scope       = callback
                callback    = root
                root        = Ext.ComponentQuery
            }

            var firstNonVisibleId
            var resultsLen

            return this.waitFor({
                method      : function () {
                    firstNonVisibleId   = null

                    var result          = root.query(query),
                        allVisible      = true

                    resultsLen          = result.length

                    if (resultsLen > 0) {

                        Joose.A.each(result, function (c) {
                            if (!c.rendered || !me.isElementVisible(c)) {
                                allVisible          = false

                                firstNonVisibleId   = c.id

                                return false
                            }
                        })

                        return allVisible && result
                    } else {
                        return false
                    }
                },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForComponentQueryVisible',
                description     : ' ' + R.get('componentQuery') + ': ' + query + ' to return a non-empty set of visible components',

                annotation      : function () {
                    // empty resultset
                    if (resultsLen === 0) return "No matching components"

                    // success - return nothing to not pollute the output with extra details
                    if (resultsLen > 0 && firstNonVisibleId == null) return ""

                    // non-empty resultset with some components hidden
                    if (resultsLen > 0 && firstNonVisibleId != null) return "The matching component [id=" + firstNonVisibleId + "] is not visible"
                }
            })
        },

        /**
         * Waits until the result of the `Ext.ComponentQuery` is either empty, or the found component(s) is hidden.
         *
         * The "root" argument of this method can be omitted.
         *
         * @param {String} query The component query selector
         * @param {Ext.Container} root The container to start a component query from. Optional
         * @param {Function} callback The callback to call after the xtype has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForComponentQueryNotVisible: function (query, root, callback, scope, timeout) {
            var me  = this,
                R   = Siesta.Resource('Siesta.Test.ExtJS.Component'),
                Ext = me.getExt();

            // no `root` supplied
            if (this.typeOf(root) == 'Function') {
                timeout     = scope
                scope       = callback
                callback    = root
                root        = Ext.ComponentQuery
            }

            var firstVisibleId
            var resultsLen

            return this.waitFor({
                method          : function () {
                    firstVisibleId  = null

                    var result = root.query(query),
                        allHidden = true;

                    resultsLen = result.length

                    if (resultsLen > 0) {
                        Joose.A.each(result, function (comp) {
                            if (!me.componentIsHidden(comp)) {
                                firstVisibleId  = comp.id

                                allHidden       = false;
                                return false;
                            }
                        });
                        return allHidden && result;
                    } else {
                        return true;
                    }
                },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForComponentQueryVisible',
                description     : ' ' + R.get('componentQuery') + ': ' + query + ' ' + R.get('toReturnHiddenCmp'),

                annotation      : function () {
                    // success - return nothing to not pollute the output with extra details
                    if (resultsLen === 0 || firstVisibleId == null) return ""

                    // non-empty resultset with some components visible
                    if (firstVisibleId != null) return "The matching component [id=" + firstVisibleId + "] is visible"
                }
            });
        },

        /**
        * Waits until the a component with the specified xtype can be detected by a simple ComponentQuery.
        *
        * The "root" argument of this method can be omitted.
        *
        * @param {String} xtype The component xtype to look for.
        * @param {Ext.Container} root The container to start a component query from. Optional
        * @param {Function} callback The callback to call after the xtype has been found
        * @param {Object} scope The scope for the callback
        * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
        */
        waitForXType: function (xtype, root, callback, scope, timeout) {
            return this.waitForComponentQuery(xtype, root, callback, scope, timeout);
        },

        /**
        * Waits until the a component with the specified xtype can be detected by a simple ComponentQuery.
        *
        * @param {String} component The class name to wait for.
        * @param {Boolean} rendered true to also wait for the component to be rendered
        * @param {Function} callback The callback to call after the component has been found
        * @param {Object} scope The scope for the callback
        * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
        */
        waitForComponent: function (component, rendered, callback, scope, timeout) {
            var Ext         = this.getExt();
            var xtype

            if (Ext.isString(component)) {
                xtype = Ext.ClassManager.get(component).xtype;
            } else {
                xtype = component.xtype;
            }

            if (rendered) {
                xtype = xtype + '[rendered]';
            }

            return this.waitForXType(xtype, callback, scope, timeout);
        },

        /**
        * This assertion passes when the passed width and height matches the result of component.getSize()
        *
        * @param {Ext.Component/String} component An Ext.Component instance or a ComponentQuery
        * @param {Int} width
        * @param {Int} height
        * @param {String} [description] The description of the assertion
        */
        hasSize: function (component, width, height, description) {
            component = this.normalizeComponent(component);
            this.isDeeply(component.getSize(), { width: width, height: height }, description);
        },

        /**
        * This assertion passes when the passed x and y matches the result of component.getPosition()
        *
        * @param {Ext.Component/String} component An Ext.Component instance or a ComponentQuery
        * @param {Int} x
        * @param {Int} y
        * @param {String} [description] The description of the assertion
        */
        hasPosition: function (component, x, y, description) {
            component = this.normalizeComponent(component);
            this.isDeeply(component.getPosition(), [x, y], description);
        },


        /**
         * This assertion accepts variable number of Ext.Component instances (can be also provided as component query string).
         * Then it calls their "destroy" method and verifies that:
         * - there were no exceptions during destroy
         * - that each component was actually destoyed (since destroy can be canceled in the "beforedestroy" event listener)
         *
         * @param {Ext.Component/Array[Ext.Component]/String} components A single instance of Ext.Component, an array of such or a string with component query
         * @param {String} [description] The description of the assertion
         */
        destroysOk : function (components, description) {
            var Ext     = this.Ext();
            var R       = Siesta.Resource('Siesta.Test.ExtJS.Component');

            if (this.typeOf(components) != 'Array') {
                if (this.typeOf(components) == 'String')
                    components  = this.Ext().ComponentQuery.query(components);
                else
                    components  = [ components ]
            }

            if (!components.length) {
                this.fail(description, {
                    assertionName       : 'destroysOk',
                    annotation          : R.get('invalidDestroysOkInput')
                })

                return
            }

            var currentComp

            var e       = this.getExceptionCatcher()(function () {
                Joose.A.each(components, function (component) {
                    currentComp = component

                    component.destroy()
                })
            })

            if (e !== undefined) {
                this.fail(description, {
                    assertionName       : 'destroysOk',
                    got                 : e,
                    gotDesc             : R.get('exception'),
                    annotation          : R.get('exceptionAnnotation') + ' ' + currentComp.id
                })

                return
            }

            var me      = this

            var allDestroyed = Joose.A.each(components, function (component) {
                //          ExtJS                             ST
                if (!(component.isDestroyed || component.destroy == Ext.emptyFn)) {
                    me.fail(description, {
                        assertionName       : 'destroysOk',
                        annotation          : R.get('Component') + ' [' + component.id + '] ' + R.get('destroyFailed')
                    })

                    return false
                }
            })

            if (allDestroyed === false) return

            this.pass(description, {
                descTpl     : R.get('destroyPassed')
            })
        }
    }
});
;
/**
@class Siesta.Test.ExtJS.Grid

This is a mixin, with helper methods for testing functionality relating to ExtJS grids. This mixin is being consumed by {@link Siesta.Test.ExtJS}

*/
Role('Siesta.Test.ExtJS.Grid', {

    requires        : [ 'waitFor', 'pass', 'fail', 'typeOf' ],


    methods : {
        /**
         * Waits for the rows of a gridpanel or tree panel (or view) to render and then calls the supplied callback. Please note, that if the store of the grid has no records,
         * the condition for this waiter will never be fullfilled.
         *
         * @param {Ext.view.Table/Ext.panel.Table/String} view The view or a ComponentQuery matching a view
         * @param {Function} callback A function to call when the condition has been met.
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForRowsVisible : function(view, callback, scope, timeout) {
            if (typeof view === 'function') {
                timeout     = scope;
                scope       = callback;
                callback    = view;
                view       = this.Ext() && this.cq1('tableview') || 'tableview';
            }

            var cmp = this.Ext() && this.normalizeComponent(view, true);
            var me = this;

            if (!cmp && typeof view === 'string') {
                // Make sure CQ returns a result first
                return this.waitForCQ(view, function(result) { this.waitForRowsVisible(result[0], callback, scope, timeout); }, this);
            } else {
                var checkerFn;

                // Handle case of locking grid (Ext JS 4+ only)
                if (cmp.normalGrid) {
                    var selector = cmp.normalGrid.getView().itemSelector;

                    checkerFn = function() {
                        if (!cmp.rendered || !cmp.normalGrid.rendered || !cmp.lockedGrid.rendered) return;

                        var lockedResult = this.$(selector, cmp.lockedGrid.getView().getEl().dom);
                        var normalResult = this.$(selector, cmp.normalGrid.getView().getEl().dom);

                        if (lockedResult.length > 0 && normalResult.length > 0) {
                            return {
                                lockedRows : lockedResult,
                                normalRows : normalResult
                            };
                        }
                    }
                } else {
                    var view = (cmp.getView && cmp.getView()) || cmp;
                    var selector = view.itemSelector || view.rowSelector; // Handling Ext 4 + Ext 3 cases

                    checkerFn = function() {
                        if (!cmp.rendered) return;

                        var result = this.$(selector, view.el.dom);

                        if (result.length > 0) {
                            return result;
                        }
                    }
                }


                return this.waitFor({
                    method          : checkerFn,
                    callback        : function() {
                        // Grid might be refreshing itself multiple times during initialization which can
                        // break tests easily
                        var as = me.beginAsync();

                        me.global.setTimeout(function(){
                            me.endAsync(as);
                            callback.call(scope || me);
                        }, 100);
                    },
                    timeout         : timeout,
                    assertionName   : 'waitForRowsVisible',
                    description     : ' ' + Siesta.Resource('Siesta.Test.ExtJS.Grid').get('waitForRowsVisible') + ' "' + cmp.id + '"'
                });
            }
        },

        /**
         * Utility method which returns the first grid row element.
         *
         * Please also refer to the {@link #getRow} method for additional information about the buffered renderer case.
         *
         * @param {Ext.panel.Table/String} panel The panel or a ComponentQuery matching a panel
         * @return {Ext.Element} The element of the first row in the grid.
         */
        getFirstRow : function(grid) {
            grid = this.normalizeComponent(grid);

            return this.getRow(grid, 0);
        },

        /**
         * Utility method which returns the first grid cell element (the one at (0, 0) coordinates).
         *
         * Please also refer to the {@link #getRow} method for additional information about the buffered renderer case.
         *
         * @param {Ext.panel.Table/String} panel The panel or a ComponentQuery matching a panel
         *
         * @return {Ext.Element} The element of the first cell in the grid.
         */
        getFirstCell : function(panel) {
            panel = this.normalizeComponent(panel);

            return this.getCell(panel, 0, 0);
        },

        /**
         * Utility method which returns a grid row element. If the grid is locking, then the row element from the locked grid is returned
         * (from the left part).
         *
         * Please note, that if the grid uses buffered rendering, you need to make sure the row with the required index
         * is currently rendered (as buffered renderer only renders a part of the dataset). This can be done
         * with the `grid.ensureVisible()` call, please refer to ExtJS grid docs:
         *

    grid.ensureVisible(80, {
        callback : function() {
            var row     = t.getRow(80);
            var cell    = t.getCell(grid, 80, 0);
        }
    });

         *
         * @param {Ext.panel.Table/String} panel The table panel instance or a ComponentQuery matching a panel
         * @param {Int} index The row index in the whole dataset
         *
         * @return {Ext.Element} The element corresponding to the grid row.
         */
        getRow : function (grid, index) {
            var Ext         = this.Ext();

            grid            = this.normalizeComponent(grid);

            var domNode;

            // Sencha Modern
            if (Ext.grid.Grid && (grid instanceof Ext.grid.Grid)) {
                var rowCmp  = grid.getViewItems()[ index ];

                domNode     = rowCmp && rowCmp.element;
            } else {
                // Sencha Classic
                // if this is a locking grid, grab from locked grid
                grid        = grid.lockedGrid || grid;

                if (grid.getView().bufferedRenderer) {
                    var record  = grid.getStore().getRange(index, index + 1)[ 0 ]

                    if (record) {
                        domNode = grid.getView().getNode(record)
                    }
                } else
                    domNode     = grid && this.$(grid.getView().itemSelector, grid.getView().getEl().dom)[ index ];
            }

            return domNode && Ext.get(domNode);
        },

        /**
         * Utility method which returns the cell at the supplied row and col position.
         *
         * Please also refer to the {@link #getRow} method for additional information about the buffered renderer case.
         *
         * @param {Ext.panel.Table/String} panel The panel or a ComponentQuery matching a panel
         * @param {Int} row The row index
         * @param {Int} column The column index
         *
         * @return {Ext.Element} The element of the grid cell at specified position.
         */
        getCell : function(grid, row, col) {
            grid            = this.normalizeComponent(grid);

            var rowEl       = grid && this.getRow(grid, row);
            var cellNode    = rowEl && this.$(grid.view.cellSelector, rowEl.dom)[ col ];

            return cellNode && this.Ext().get(cellNode);
        },

        /**
         * Utility method which returns the last cell for the supplied row.
         *
         * @param {Ext.panel.Table/String} panel The panel or a ComponentQuery matching a panel
         * @param {Int} row The row index
         *
         * @return {Ext.Element} The element of the grid cell at specified position.
         */
        getLastCellInRow : function(grid, row) {
            grid = this.normalizeComponent(grid);

            return this.getCell(grid, row, grid.headerCt.getColumnCount() - 1);
        },

        /**
         * This assertion passes if the passed string is found in the passed grid's cell element.
         *
         * @param {Ext.panel.Table/String} panel The panel or a ComponentQuery matching a panel
         * @param {Int} row The row index
         * @param {Int} column The column index
         * @param {String/RegExp} string The string to find or RegExp to match
         * @param {String} [description] The description for the assertion
         */
        matchGridCellContent : function(grid, rowIndex, colIndex, string, description) {
            grid = this.normalizeComponent(grid);

            var view = grid.getView(),
                Ext = this.Ext(),
                cell = this.getCell(grid, rowIndex, colIndex).child('.' + Ext.baseCSSPrefix + 'grid-cell-inner');

            var isRegExp    = this.typeOf(string) == 'RegExp';
            var content     = cell.dom.innerHTML;

            if (isRegExp ? string.test(content) : content.indexOf(string) != -1) {
                this.pass(description, {
                    descTpl     : isRegExp ? 'Cell content {content} matches regexp {string}' : 'Cell content {content} has a string {string}',
                    content     : content,
                    string      : string
                });
            } else {
                this.fail(description, {
                    assertionName   : 'matchGridCellContent',

                    got         : cell.dom.innerHTML,
                    gotDesc     : 'Cell content',

                    need        : string,
                    needDesc    : 'String matching',

                    annotation  : 'Row index: ' + rowIndex + ', column index: ' + colIndex
                });
            }
        },


        /**
         * This method performs either a click or double click on the specified grid cell
         * (depending from the [clicksToEdit](http://docs.sencha.com/extjs/4.2.2/#!/api/Ext.grid.plugin.Editing-cfg-clicksToEdit)
         * config of its editing plugin), then waits until the `input` selector appears under the cursor and calls the provided callback.
         * The callback will receive the DOM `&lt;input&gt; element as the 1st argument.
         *
         * In some browsers the editor is shown with delay, so its highly recommended to use this method when editing cells.
         * Typical usage will be:
         *

    t.chain(
        function (next) {
            t.clickToEditCell(grid, 0, 1, next)
        },
        function (next, inputEl) {
            t.type(inputEl, "my text", next)
        }
    )

         *
         *
         * @param {Ext.grid.Panel/String} grid The grid panel or a ComponentQuery matching a panel
         * @param {Int} rowIndex The row index
         * @param {Int} colIndex The column index
         * @param {Function} callback The callback to call once the `input` selector appears under the cursor
         * @param {String} selector Custom selector to wait for, instead of `input`.
         */
        clickToEditCell : function (grid, rowIndex, colIndex, callback, selector) {
            var Ext             = this.getExt()

            grid                = this.normalizeComponent(grid);

            var editingPlugin   = grid && grid.editingPlugin

            if (!editingPlugin || !(editingPlugin instanceof Ext.grid.plugin.CellEditing)) {
                this.fail("No grid, or grid has no editing plugin, or its not a Ext.grid.plugin.CellEditing plugin")

                callback && callback(null)

                return
            }

            var me      = this

            this[ editingPlugin.clicksToEdit == 2 ? 'doubleClick' : 'click' ](this.getCell(grid, rowIndex, colIndex), function () {
                // manually force editing if it didn't get started by the click
                if (!editingPlugin.getActiveEditor()) editingPlugin.startEditByPosition({ row : rowIndex, column : colIndex })

                me.waitForSelectorAtCursor(selector || '.x-editor,input', callback)
            })
        },

        getTrimmedCellContent : function(grid, row, column) {
            var cell = this.getCell(grid, row, column);

            return $.trim(this.$(cell.dom).text());
        },

        /**
         * Assertion method which passes if the grid cell is empty.
         *
         * @param {Ext.panel.Table/String} panel The panel or a ComponentQuery matching a panel
         * @param {Int} rowIndex The row index
         * @param {Int} colIndex The column index
         * @param {String} message The assertion message
         *
         * @return {Ext.Element} The element of the grid cell at specified position.
         */
        assertCellIsEmpty : function(grid, row, column, message) {
            this.is(this.getTrimmedCellContent(grid, row, column), '', message);
        },

        /**
         * Wait-for method which waits until the chosen grid cell is empty.
         *
         * @param {Ext.panel.Table/String} panel The panel or a ComponentQuery matching a panel
         * @param {Int} rowIndex The row index
         * @param {Int} colIndex The column index
         * @param {Object} scope The 'this' object for the callback
         * @param {Int} timeout The timeout in ms
         * @param {Function} callback The callback called when the condition is fulfilled
         *
         * @return {Ext.Element} The element of the grid cell at specified position.
         */
        waitForCellEmpty : function(grid, row, column, scope, timeout, callback) {
            if (typeof scope === 'function') {
                callback    = scope;
            } else if (typeof timeout === 'function') {
                callback    = timeout;
            }

            this.waitFor({
                method          : function() {
                    return this.getTrimmedCellContent(grid, row, column).length === 0;
                },
                callback        : function() {
                    callback.call(scope || this);
                },
                timeout         : timeout,
                assertionName   : 'waitForCellEmpty',
                description     : ' ' + Siesta.Resource('Siesta.Test.ExtJS.Grid').get('waitForCellEmpty')
            });
        }
    }
});
;
/**
@class Siesta.Test.ExtJS.DataView

This is a mixin, with helper methods for testing functionality relating to ExtJS dataviews. This mixin is being consumed by {@link Siesta.Test.ExtJS}

*/
Role('Siesta.Test.ExtJS.DataView', {

    requires        : [ 'waitFor', 'getExt' ],


    methods : {
        /**
         * Waits for the items of a dataview to render and then calls the supplied callback.
         * @param {Ext.view.View/String} view An Ext.view.View instance or a ComponentQuery
         * @param {Function} callback A function to call when the condition has been met.
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForViewRendered : function(view, callback, scope, timeout) {
            view            = this.normalizeComponent(view);

            var hasItems    = view && view.store && view.store.getCount() > 0
            var R           = Siesta.Resource('Siesta.Test.ExtJS.DataView');

            return this.waitFor({
                method      : function() { return hasItems ? !!view.getNode(0) : view.rendered },
                callback    : callback,
                scope       : scope,
                timeout     : timeout,
                assertionName   : 'waitForViewRendered',
                description     : ' ' + R.get('view') + ' ' + view.id + ' ' + R.get('toRender')
            });
        },

        /**
         * Utility method which returns the first view element.
         *
         * @param {Ext.view.View/String} view An Ext.view.View instance or a ComponentQuery
         * @return {Ext.Element} The first element of the view
         */
        getFirstItem : function(view) {
            var Ext = this.getExt();

            view = this.normalizeComponent(view);

            return Ext.get(view.getNode(0));
        }
    }
});
;
/**
@class Siesta.Test.ExtJS.Element

This is a mixin, with helper methods for testing functionality relating to ExtJS/DOM elements. This mixin is consumed by {@link Siesta.Test.ExtJS}

*/
Role('Siesta.Test.ExtJS.Element', {
    
    methods : {
        /**
         * Passes if the passed element has the expected region.
         * 
         * @param {Ext.Element} el The element
         * @param {Ext.util.Region} region The region to compare to.
         * @param {String} [description] The description of the assertion
         */
        hasRegion : function(el, region, description) {
            var elRegion = el.getRegion();
            var R        = Siesta.Resource('Siesta.Test.ExtJS.Element');

            this.is(elRegion["top"], region["top"], description + ' ' + R.get('top') + ')');
            this.is(elRegion["right"], region["right"], description + ' ' + R.get('right') + ')');
            this.is(elRegion["bottom"], region["bottom"], description + ' ' + R.get('bottom') + ')');
            this.is(elRegion["left"], region["left"], description + ' ' + R.get('left') + ')');
        }
    }
});
;
/**
@class Siesta.Test.ExtJS.FormField

This is a mixin, with helper methods for testing functionality relating to Ext.form.Field class. This mixin is being consumed by {@link Siesta.Test.ExtJS}

*/
Role('Siesta.Test.ExtJS.FormField', {
    
    methods : {
        /**
         * Passes if the passed Field has the expected value.
         * 
         * @param {Ext.form.field.Field/String} field A form field or a ComponentQuery
         * @param {Mixed} value The value to compare to.
         * @param {String} [description] The description of the assertion
         */
        fieldHasValue : function(field, value, description) {
            field = this.normalizeComponent(field);
            this.is(field.getValue(), value, description);
        },

        /**
         * Passes if the passed Field has no value ("" or null).
         * 
         * @param {Ext.form.field.Field/String} field A form field or a ComponentQuery
         * @param {String} [description] The description of the assertion
         */
        isFieldEmpty : function(field, description) {
            field = this.normalizeComponent(field);
            var val = field.getValue();
            this.ok(val === null || val === "", description);
        }
    }
});
;
/**
@class Siesta.Test.Browser
@extends Siesta.Test
@mixin Siesta.Test.TextSelection
@mixin Siesta.Test.Element

@mixin Siesta.Test.UserAgent.Mouse
@mixin Siesta.Test.UserAgent.Keyboard
@mixin Siesta.Test.UserAgent.Touch

@mixin Siesta.Test.Browser.Role.CanGetElementFromPoint

A base class for testing a generic browser functionality. It has various DOM-related assertions, and is not optimized for any framework.

*/
Class('Siesta.Test.Browser', {

    isa         : Siesta.Test,

    does        : [
        Siesta.Util.Role.CanParseBrowser,
        Siesta.Util.Role.CanCalculatePageScroll,
        Siesta.Util.Role.Dom,
        Siesta.Test.Browser.Role.CanGetElementFromPoint,
        Siesta.Test.Browser.Role.CanWorkWithKeyboard,
        Siesta.Test.Browser.Role.CanRebindJQueryContext,

        Siesta.Test.UserAgent.Mouse,
        Siesta.Test.UserAgent.Keyboard,
        Siesta.Test.UserAgent.Touch,

        Siesta.Test.Element,
        Siesta.Test.TextSelection,
        Siesta.Test.Observable
    ],

    has : {
        /**
         * @property {Object} bowser An instance of browser detection library - [Bowser](https://github.com/ded/bowser).
         * Please refer to the provided link for the detailed documentation, here we just provide some examples how
         * it can be used in the test file:
         *

    // Browser detection
    if (t.bowser.chrome && t.bowser.version > 50) { .. do something .. }
    if (t.bowser.msie && t.bowser.version >= 10) { .. do something .. }

    // OS detection
    if (t.bowser.mac) { .. do something .. }

    // Rendering engine detection
    if (t.bowser.gecko) { .. do something .. }

    // Rendering engine detection
    if (t.bowser.webkit || t.bowser.blink) { .. do something .. }

         *
         * This property has an alias - {@link #browser}.
         */
        bowser                  : null,


        /**
         * @property {Object} bowser Alias for {@link #bowser}
         */
        browser                 : null,

        forceDOMVisible         : false,
        isDOMForced             : false,

        browserInfo             : {
            lazy    : function () {
                return this.parseBrowser(window.navigator.userAgent)
            }
        },

        nextConfirmValue        : null,
        nextPromptReturnValue   : null,

        realAlert               : null,
        realConfirm             : null,
        realPrompt              : null,
        realPrint               : null,
        realOpen                : null,
        previousConfirm         : null,
        previousPrompt          : null,

        blurListener            : null,
        restartOnBlur           : false,

        blurWindow              : null,

        mouseVisualizer         : null,

        popups                  : Joose.I.Array,

        simulator               : null,
        simulatorConfig         : null,

        isHandlingThrowAsync    : false,

        initialCursorPosition   : null
    },

    override : {

        cleanup : function () {
            if (this.mouseVisualizer) {
                this.mouseVisualizer.destroy()
                this.mouseVisualizer = null
            }

            this.SUPERARG(arguments)

            this.bowser     = this.browser = null

            this._global    = null

            this.realAlert  = this.realConfirm = this.realPrompt = this.realPrint = this.realOpen = null

            this.previousPrompt = this.previousConfirm = null

            this.blurListener   = null

            this.blurWindow && this.blurWindow.close();

            this.blurWindow     = null;

            Joose.A.each(this.popups, function (handle) {
                if (!handle.popup.closed) handle.popup.close()
            })

            this.popups.length  = 0
            this.popups         = null

            this.simulator.cleanup()
        },


        attachSimulator : function () {
            var me              = this
            var simulator       = this.simulator
            var isRoot          = !this.parent

            // this will "attach" simulator to a test window, by setting up a "global" property
            if (isRoot) simulator.onTestLaunch(this)

            if (simulator.type == 'synthetic') {
                // for synthetic simulator we can just update the current position directly (move to simulator class?)
                if (isRoot && me.initialCursorPosition) {
                    simulator.currentPosition[ 0 ] = me.initialCursorPosition[ 0 ]
                    simulator.currentPosition[ 1 ] = me.initialCursorPosition[ 1 ]
                }

                return
            }

            var cont            = Promise.resolve()

            return cont.then(function () {
                if (isRoot) {
                    var x       = me.initialCursorPosition ? me.initialCursorPosition[ 0 ] : 0
                    var y       = me.initialCursorPosition ? me.initialCursorPosition[ 1 ] : 0

                    // for native simulator we need to actually move the cursor
                    return simulator.simulateMouseMove(x, y, null, { moveKind : 'instant' })
                }
            }).then(function () {
                var hasFocus        = me.project.browserWindowHasFocus()

                // browser window has lost focus for some reason, trying to re-focus by clicking
                // in -1, -1 point
                if (!hasFocus) {
                    var currentPosition     = simulator.currentPosition.slice()

                    return simulator.simulateMouseMove(-1, -1, null, { moveKind : 'instant' }).then(function () {
                        return simulator.simulateMouseClick({ globalXY : [] })
                    }).then(function () {
                        return simulator.simulateMouseMove(currentPosition[ 0 ], currentPosition[ 1 ], null, { moveKind : 'instant' })
                    })
                }
            })
        },


        launch : function (errorMessage) {
            var me              = this
            var SUPER           = this.SUPER

            var cont            = this.attachSimulator()

            // "attachSimulator" completed synchronously - call SUPER immediately
            // this is required for "subTest" call to be synchronous on what some tests relies (subject for change)
            if (!cont) {
                this.SUPER(errorMessage)
            } else {
                // "attachSimulator" returned promise
                cont.then(function () {
                    SUPER.call(me, errorMessage)
                }, function (reason) {
                    SUPER.call(me, reason)
                })
            }
        }
    },

    methods : {

        initialize : function () {
            if (!this.simulator) this.simulator = new (this.getSimulatorClass())(this.simulatorConfig || {})

            // copy the "currentPosition" to the test instance for backward compatibility
            this.currentPosition    = this.simulator.currentPosition

            this.SUPERARG(arguments)
        },


        onBeforeTestFinalize : function () {
            var global          = this.global

            // If expectAlertMessage(which overwrites the alert method) was called but no alert() call happened - fail the test
            if (global.alert.__EXPECTED_ALERT__) {
                this.fail(Siesta.Resource('Siesta.Test.Browser', 'alertMethodNotCalled'))
            }

            this.SUPERARG(arguments)
        },


        getSimulatorClass : function () {
            return Siesta.Test.Simulator
        },


        // setup : function (callback, errback) {
        //     var simulator           = this.simulator
        //
        //     // this will "attach" simulator to a test window, by setting up a "global" property
        //     simulator.onTestLaunch(this)
        //
        //     if (simulator instanceof Siesta.Test.Simulator) {
        //         // synthetic events start with [ 0, 0 ] point anyway, so avoid extra mouseover/mousemove event
        //         callback()
        //     } else {
        //         simulator.simulateMouseMove(0, 0, null, { moveKind : 'instant' }).then(callback, errback)
        //     }
        // },


        earlySetup : function (callback, errback) {
            var simulator           = this.simulator

            if (simulator.type == 'synthetic') {
                // synthetic events start with [ 0, 0 ] point anyway, so avoid extra mouseover/mousemove event
                callback()
            } else
                // for native events need to reset the simulation state *before* the test starts
                // all keys up, mouse buttons up, cursor in 0, 0
                simulator.doFullSimulationReset().then(callback, errback)
        },


        launch : function (errorMessage) {
            var me          = this
            var win         = this.global

            // top test
            if (!me.parent) {
                me.realAlert        = win.alert
                me.realConfirm      = win.confirm
                me.realPrompt       = win.prompt
                me.realPrint        = win.print
                me.realOpen         = win.open

                this.maintainScrollPositionDuring(function () {
                    if (!me.project.browserWindowHasFocus() && !bowser.safari) me.onWindowBlur()

                    // trying to focus the window (hopefully fixes the tab key issues)
                    win.focus && win.focus()
                })

//                win.addEventListener && win.addEventListener('blur', me.blurListener = function () {
//                    if (bowser.gecko && win.document.getElementsByTagName('iframe').length > 0)
//                        // this "waitFor" can be interrupted, but only by forceful test finalization, which
//                        // happens when test throws exception for example, so it fails anyway
//                        me.waitFor({
//                            method              : 0,
//                            suppressAssertion   : true,
//                            callback            : function () { me.onWindowBlur() }
//                        })
//                    else
//                        me.onWindowBlur()
//                })

                // 1. IE can't show cursor, since it's IE.
                // 2. Clients can opt-in for cursor display in automation mode
                // 3. Currently we don't show cursor for tests running in popups, since that would require
                // injecting cursor element on the test page and we don't want that
                if (!bowser.msie && me.project.showCursor && !win.opener) {
                    me.mouseVisualizer = new Siesta.Project.Browser.UI.MouseVisualizer({
                        currentContainer    : me.global.frameElement.parentElement
                    });
                }
            }

            // WARN: behavior when several sub-tests are running at the same time is not well-defined
            me.previousConfirm      = win.confirm
            me.previousPrompt       = win.prompt

            var emptyFn             = function () {};

            win.alert               = win.print = emptyFn;

            win.confirm = function () {
                var retVal                  = typeof me.nextConfirmValue === 'boolean' ? me.nextConfirmValue : true;

                me.nextConfirmValue         = null;

                return retVal;
            };

            win.prompt = function () {
                var retVal                  = me.nextPromptReturnValue || '';

                me.nextPromptReturnValue    = null;

                return retVal;
            };

            win.open = function (url) {
                var popup   = me.realOpen.apply(win, arguments)

                if (!popup)
                    me.fail(Siesta.Resource('Siesta.Test.Browser','popupsDisabled', { url : url }))
                else {
                    me.popups.push({ url : url, popup : popup })
                }

                return popup
            }

            this.SUPERARG(arguments)
        },


        onTestFinalize : function () {
            var win         = this.global

            if (win) {
                if (!this.parent) {
                    win.confirm = this.previousConfirm;
                    win.prompt  = this.previousPrompt;

                    win.print   = this.realPrint
                    win.alert   = this.realAlert
                    win.open    = this.realOpen
                } else {
                    win.confirm = this.realConfirm;
                    win.prompt  = this.realPrompt;

                    win.alert   = win.print = function () {}
                }
            }

//            this.blurListener && win.removeEventListener('blur', this.blurListener)
//
//            this.blurListener   = null

            this.SUPERARG(arguments)
        },


        onWindowBlur : function (arg1, arg2) {
//            var doc             = this.global.document
//
//            // ignore the case when focus is moved inside of the child iframe
//            // IGNORE
//            if (!doc.hasFocus && doc.hasFocus()) return
//
//            var slice           = Array.prototype.slice
//
//            //                  convert from HTMLCollection to Array
//            var iframes         = slice.apply(doc.getElementsByTagName('iframe'))
//
//            while (iframes.length) {
//                try {
//                    var innerDoc    = iframes[ 0 ].contentWindow.document
//
//                    if (innerDoc.hasFocus()) return
//
//                    iframes.push.apply(iframes, slice.apply(innerDoc.getElementsByTagName('iframe')))
//                } catch (e) {
//                }
//
//                iframes.shift()
//            }
//            // EOF IGNORE

            if (this.restartOnBlur)
                this.fireEvent('focuslost')
            else
                this.warn(Siesta.Resource('Siesta.Test.Browser').get('focusLostWarning', { url : this.url }))
        },


        sizzle : function (selector, root) {
            return Siesta.Sizzle(selector, root || this.global.document)
        },


        isEventPrevented : function (event) {
            // our custom property - takes highest priority
            if (event.preventDefault && this.typeOf(event.preventDefault.$prevented) == 'Boolean') return event.preventDefault.$prevented

            // W3C standards property
            if (this.typeOf(event.defaultPrevented) == 'Boolean') return event.defaultPrevented

            return event.returnValue === false
        },


        // only called for the re-used contexts
        cleanupContextBeforeStart : function () {
            this.cleanupContextBeforeStartDom()

            this.SUPER()
        },


        cleanupContextBeforeStartDom : function () {
            var doc                 = this.global.document

            doc.body.innerHTML      = ''
        },


        getElementPageRect : function (el, $el) {
            $el             = $el || this.$(el)

            var offset      = $el.offset()

            return new Siesta.Util.Rect({
                left        : offset.left,
                top         : offset.top,
                width       : $el.outerWidth(),
                height      : $el.outerHeight()
            })
        },

//        TODO no longer used, remove after some time
//        elementHasScroller : function (el, $el) {
//            $el             = $el || this.$(el)
//
//            var overflowX   = $el.css('overflow-x')
//            var overflowY   = $el.css('overflow-y')
//
//            var hasX        = el.scrollWidth != el.clientWidth && overflowX != 'visible' && overflowX != 'hidden'
//            var hasY        = el.scrollHeight != el.clientHeight && overflowY != 'visible' && overflowY != 'hidden'
//
//            return hasX || hasY ? { x : hasX, y : hasY } : false
//        },


        hasForcedIframe : function () {
            return Boolean(
                (this.isDOMForced || this.forceDOMVisible) && (this.scopeProvider instanceof Scope.Provider.IFrame) && this.scopeProvider.iframe
            )
        },


        getDivBox : function (doc, left, top, width, height) {
            var div             = doc.createElement('div')

            div.style.cssText   =
                'position: absolute !important; left: ' + left + 'px !important; top: ' + top + 'px !important;' +
                'border-width: 0 !important; padding: 0 !important; margin: 0 !important;' +
                'width: ' + width + 'px !important; height: ' + height + 'px !important;'

            return div
        },


        elementIsScrolledOut : function (el, offset) {
            var doc                 = el.ownerDocument
            var win                 = doc.defaultView || doc.parentWindow
            var body                = doc.body

            var parents             = []

            for (var parent = el; parent && parent != body; parent = parent.parentNode) parents.push(parent)

            var currentRect         = new Siesta.Util.Rect({
                left        : this.getPageScrollX(win),
                top         : this.getPageScrollY(win),

                // using height / width of the *whole viewport*, BODY tag may have 0 height in some cases
                width       : this.$(win).width(),
                height      : this.$(win).height()
            })

            for (var i = parents.length - 1; i >= 0; i--) {
                var parent          = parents[ i ]

                var overflowX       = this.$(parent).css('overflow-x')
                var overflowY       = this.$(parent).css('overflow-y')

                if (overflowX != 'visible' || overflowY != 'visible') {
                    // only get the bounding rect if we need it
                    // in IE10 a series of call to `getBoundingClientRect` of the parent elements
                    // were making the el itself hidden (offsetWidth = offsetHeight = 0)
                    var parentRect  = this.getElementPageRect(parent)

                    if (overflowX != 'visible') {
                        currentRect = currentRect.cropLeftRight(parentRect)
                        if (currentRect.isEmpty()) return true
                    }

                    if (overflowY != 'visible') {
                        currentRect     = currentRect.cropTopBottom(parentRect)

                        if (currentRect.isEmpty()) return true
                    }
                }
            }

            var $el                 = this.$(el)

            var elPageRect          = this.getElementPageRect($el[ 0 ], $el)

            offset                  = this.normalizeOffset(offset, $el)

            return !currentRect.contains(elPageRect.left + offset[ 0 ], elPageRect.top + offset[ 1 ])
        },


        // returns "true" if scrolling has actually occured
        scrollTargetIntoView : function (target, offset) {
            var win             = this.global
            var doc             = win.document

            if (this.typeOf(target) != 'Array') {
                target          = this.normalizeElement(target, true, null, false);
                offset          = this.normalizeOffset(offset, this.$(target))

                var isInside    = this.isOffsetInsideElementBox(target, offset);

                if (
                    target && this.isElementVisible(target) &&
                    // If element isn't visible, try to bring it into view
                    isInside && this.elementIsScrolledOut(target, offset)
                ) {
                    this.maintainScrollPositionDuring(function () {
                        // Required to handle the case where the body is scrolled
                        target.scrollIntoView();
                    })

//                    No longer use jQuery "scrollIntoView" plugin - tests passes w/o it
//                    and it does not take the offset point into account anyway
//                    we still need it for ":scrollable" pseudo (which it does kind of ok)
//                    this.$(target).scrollintoview({ duration : 0 });

                    // If element is still out of view, try manually scrolling first scrollable parent found
                    if (this.elementIsScrolledOut(target, offset)) {

                        var scrollableParent = this.$(target).closest(':scrollable')[ 0 ];

                        if (scrollableParent) {
                            var parentBox       = this.getBoundingClientRect(scrollableParent)
                            var targetBox       = this.getBoundingClientRect(target)

                            scrollableParent.scrollLeft = Math.max(0, scrollableParent.scrollLeft + targetBox.left - parentBox.left + offset[ 0 ] - 1)
                            scrollableParent.scrollTop  = Math.max(0, scrollableParent.scrollTop + targetBox.top - parentBox.top + offset[ 1 ] - 1)
                        }
                    }

                    return true
                }
            } else {
                var leftVisible     = this.getPageScrollX()
                var rightVisible    = leftVisible + this.$(win).width()

                var topVisible      = this.getPageScrollY()
                var bottomVisible   = topVisible + this.$(win).height()

                if (
                    leftVisible <= target[ 0 ] && target[ 0 ] <= rightVisible
                    && topVisible <= target[ 1 ] && target[ 1 ] <= bottomVisible
                ) {
                    // no need to scroll, target point is within visible viewport area
                    return false
                }

                var div             = this.getDivBox(doc, target[ 0 ], target[ 1 ], 1, 1)

                doc.body.appendChild(div)

                this.maintainScrollPositionDuring(function () {
                    div.scrollIntoView()
                })

                doc.body.removeChild(div)

                return true
            }
        },


        processSubTestConfig : function (config) {
            var res             = this.SUPER(config)
            var me              = this

            Joose.A.each([
                'currentPosition',
                'mouseVisualizer',
                'simulator',
                'simulatorConfig',
                'bowser', 'browser',
                'moveCursorBetweenPoints',
                'realAlert', 'realConfirm', 'realPrompt', 'realPrint', 'realOpen', 'popups'
            ], function (name) {
                res[ name ]     = me[ name ]
            })

            return res
        },


        // Normalizes the element to an HTML element. Every 'framework layer' will need to provide its own implementation
        // This implementation accepts either a CSS selector or an Array with xy coordinates.
        normalizeElement : function (el, allowMissing, shallow, detailed) {
            // Quick exit if already an element
            if (el && el.nodeName) return el;

            var matchingMultiple = false

            if (this.typeOf(el) === 'String') {
                // DOM query
                var origEl  = el;

                var wasAdjusted = this.adjustScope(el);

                var query   = this.$(el.indexOf('->') >= 0 ? el.split('->')[1] : el);

                if (wasAdjusted) this.resetScope();

                el          = query[ 0 ];
                matchingMultiple = query.length > 1

                if (!allowMissing && !el) {
                    var warning = Siesta.Resource('Siesta.Test.Browser','noDomElementFound') + ': ' + origEl

                    this.warn(warning);
                    throw new Error(warning);
                }
            }

            if (this.typeOf(el) == 'Array') {
                var x, y

                if (el.length < 2) {
                    x       = this.simulator.currentPosition[ 0 ]
                    y       = this.simulator.currentPosition[ 1 ]
                } else {
                    x       = this.pageXtoViewportX(Math.round(el[ 0 ]))
                    y       = this.pageYtoViewportY(Math.round(el[ 1 ]))
                }

                el          = this.elementFromPoint(x, y);
            }

            return detailed ? { el : el, matchingMultiple : matchingMultiple } : el;
        },


        // this method generally has the same semantic as the "normalizeElement", its being used in
        // Siesta.Test.Action.Role.HasTarget to determine what to pass to next step
        //
        // on the browser level the only possibility is DOM element
        // but on ExtJS level user can also use ComponentQuery and next step need to receive the
        // component instance
        normalizeActionTarget : function (el, allowMissing) {
            return this.normalizeElement(el, allowMissing);
        },


        randomBetween : function (min, max) {
            return Math.floor(min + (Math.random() * (max - min + 1)));
        },


        /**
         * This method uses native `document.elementFromPoint()` and returns the DOM element under the current logical cursor
         * position in the test. Note, that this method may work not 100% reliable in IE due to its bugs. In cases
         * when `document.elementFromPoint()` can't find any element this method returns the &lt;body&gt; element.
         *
         * @return {HTMLElement}
         */
        getElementAtCursor : function() {
            var xy          = this.simulator.currentPosition;

            return this.elementFromPoint(xy[ 0 ], xy[ 1 ])
        },


        addListenerToObservable : function (observable, event, listener, isSingle) {
            this.$(observable).bind(event, listener)
        },


        removeListenerFromObservable : function (observable, event, listener) {
            this.$(observable).unbind(event, listener)
        },

        // This method accepts actionTargets as input (Dom node, string, CQ etc) and does a first
        // normalization pass to get a DOM element.
        // After initial normalization it also tries to locate, the 'top' DOM node at the center of
        // the first pass resulting DOM node.
        // This is the only element we can truly interact with in a real browser.
        // returns an object containing the element plus viewport coordinates
        getNormalizedTopElementInfo : function (actionTarget, skipWarning, actionName, offset) {
            var localXY, globalXY, el;

            // support empty array as a synonym for empty target
            if (this.typeOf(actionTarget) == 'Array' && actionTarget.length == 0) { actionTarget = null }

            var targetIsPoint   = !actionTarget || this.typeOf(actionTarget) == 'Array'

            // First lets get a normal DOM element to work with
            if (targetIsPoint) {
                // viewport coords
                var x, y

                if (actionTarget) {
                    x       = this.pageXtoViewportX(Math.round(actionTarget[ 0 ]))
                    y       = this.pageYtoViewportY(Math.round(actionTarget[ 1 ]))
                } else {
                    x       = this.simulator.currentPosition[ 0 ]
                    y       = this.simulator.currentPosition[ 1 ]
                }

                globalXY    = [ x, y ]

                var info    = this.elementFromPoint(x, y, false, null, true)

                el          = info.el
                localXY     = info.localXY
            } else {
                el          = this.normalizeElement(actionTarget, skipWarning)
            }

            if (!el && skipWarning) {
                return;
            }

            // 1. If this element is not visible, something is wrong
            // 2. If element is visible but not reachable (scrolled out of view) this is also an invalid scenario (this check is skipped for IE)
            //    TODO needs further investigation, conflicting with starting a drag operation on an element that isn't visible until the cursor is above it

            // we don't need to this check if target is a coordinate point, because in this case element is reachable by definition
            if (!targetIsPoint) {
                var R       = Siesta.Resource('Siesta.Test.Browser');
                var message = 'getNormalizedTopElementInfo: ' + (actionName ? R.get('targetElementOfAction') + " [" + actionName + "]" : R.get('targetElementOfSomeAction')) +
                    " " + R.get('isNotVisible') + ": " + (el.id ? '#' + el.id : el)

                if (!this.isElementVisible(el)) {
                    this.fail(message)
                    return;
                }
                else if (!skipWarning && this.isOffsetInsideElementBox(el, offset) && !this.elementIsTop(el, true, offset)) {
                    this.warn(message)
                }
            }

            var isOption    = el && el.nodeName.toLowerCase() === 'option';

            if (isOption) {
                localXY     = this.simulator.currentPosition.slice();
                globalXY    = this.simulator.currentPosition.slice();
            } else if (!targetIsPoint) {
                var doc     = el.ownerDocument;
                var R       = Siesta.Resource('Siesta.Test.Browser');

                localXY     = this.getTargetCoordinate(el, true, offset)
                globalXY    = this.getTargetCoordinate(el, false, offset)

                // trying 2 times for IE
                el          = doc.elementFromPoint(localXY[ 0 ], localXY[ 1 ]) || doc.elementFromPoint(localXY[ 0 ], localXY[ 1 ]) || doc.body;

                if (!el) {
                    this.fail('getNormalizedTopElementInfo: ' + R.get('noElementFound') + ' [' + localXY + ']');
                    return; // No point going further
                }
            }

            return {
                el          : el,

                // both are viewport coords
                localXY     : localXY,
                globalXY    : globalXY,

                offset      : isOption ? [ 0, 0 ] : this.getOffsetRelativeToEl(el, localXY)
            }
        },

        // point should be in page coords
        getOffsetRelativeToEl : function(el, point) {
            var box = this.getElementPageRect(el);

            return [ point[0] - box.left, point[1] - box.top ];
        },

        /**
         * This method will wait for the presence of the passed string.
         *
         * @param {String} text The text to wait for
         * @param {Function} callback The callback to call
         * @param {Object} scope The scope for the callback
         * @param {Number} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForTextPresent : function (text, callback, scope, timeout) {
            var R               = Siesta.Resource('Siesta.Test.Browser');

            return this.waitFor({
                method          : function () {
                    var body        = this.global.document.body
                    var selector    = ':contains(' + text + ')'

                    return this.$(selector, body).length > 0 || this.$(body).is(selector);
                },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForTextPresent',
                description     : ' ' + R.get('text') + ' "' + text + '" ' + R.get('toBePresent')
            });
        },

        /**
         * This method will wait for the absence of the passed string.
         *
         * @param {String} text The text to wait for
         * @param {Function} callback The callback to call
         * @param {Object} scope The scope for the callback
         * @param {Number} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForTextNotPresent : function (text, callback, scope, timeout) {
            var R               = Siesta.Resource('Siesta.Test.Browser');

            return this.waitFor({
                method          : function () {
                    var body        = this.global.document.body
                    var selector    = ':contains(' + text + ')'

                    return this.$(selector, body).length === 0 && !this.$(body).is(selector);
                },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForTextNotPresent',
                description     : ' ' + R.get('text') + ' "' + text + '" ' + R.get('toNotBePresent')
            });
        },

        /**
         * Waits until the passed action target is detected. This can be a string such as a component query, CSS query or a composite query.
         *
         * @param {String/Siesta.Test.ActionTarget} target The target presence to wait for
         * @param {Function} callback The callback to call after the target has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForTarget : function(target, callback, scope, timeout, offset) {
            var me = this;
            var R  = Siesta.Resource('Siesta.Test.Browser');

            return this.waitFor({
                method          : function () {
                    var el      = me.normalizeElement(target, true, true, false, { offset : offset })

                    // If user is aiming outside the target, we'll *not* use the offset while
                    // detecting target presence since having a visible sized box will suffice
                    if (el && offset && me.isElementVisible(el) && !me.isOffsetInsideElementBox(el, offset)) {
                        return true;
                    }

                    return el && me.elementIsTop(el, true, offset)
                },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForTarget',
                description     : ' ' + R.get('target') + ' "' + target + '" ' + R.get('toAppear')
            });
        },

        /**
         * Sets a new size for the test iframe
         *
         * @param {Int} width The new width
         * @param {Int} height The new height
         */
        setWindowSize : function(width, height, callback) {
            this.scopeProvider.setViewportSize(width, height);

            callback && callback.call(this);
        },


        getJUnitClass : function () {
            var browserInfo         = this.getBrowserInfo()

            browserInfo             = browserInfo.name + browserInfo.version

            return browserInfo + ':' + this.SUPER()
        },


        // Returns true if the scope was adjusted to another frame for the target string
        adjustScope : function(target) {

            if (this.typeOf(target) == 'String') {
                var mainParts  = target.split('->');

                if (mainParts.length === 2) {
                    var frameEl = this.$(this.trimString(mainParts[ 0 ]))[ 0 ];

                    if (!frameEl || !frameEl.contentWindow) {
                        return false;
                    }

                    this._global    = this.global
                    this.setGlobal(frameEl.contentWindow)

                    return true;
                }
            }

            return false;
        },


        resetScope : function() {
            this.setGlobal(this._global || this.global)

            this._global    = null
        },


        // a stub method for the Lite package
        screenshot : function (options, callback) {
            this.diag("Command: `screenshot` skipped - not running in Standard Package")

            this.processCallbackFromTest(callback, [ 'skipped' ], this)
        },


        // a stub method for the Lite package
        screenshotElement : function (target, fileName, callback) {
            this.diag("Command: `screenshot` skipped - not running in Standard Package")

            this.processCallbackFromTest(callback, [ 'skipped' ], this)
        },

        /**
         * setUrl Opens the url provided (make sure you use the {@link Siesta.Project.Browser#enablePageRedirect} option on the Harness when using this API method)
         *
         * @param {String} url The new url for current page
         * @param {Function} callback The callback to call after the page has been loaded
         * @param {Object} scope The scope for the callback
         */
        setUrl : function(url, callback, scope) {
            if (!url) throw new Error('Must provide a valid URL');

            var me = this;

            if (me.global.location.href !== url) {
                var baseUrl = this.scopeProvider.sourceURL || this.project.baseUrl;
                var absURl  = this.project.absolutizeURL(url, baseUrl);

                me.waitForPageLoad(callback, scope);
                me.global.location.href = absURl;
            } else {
                callback.call(scope || me);
            }
        },

        /**
         * Sets the hash value of the location object
         *
         * @param {String} url The new hash
         * @param {Function} callback
         * @param {Object} scope The scope for the callback
         */
        setHash : function(hash, callback, scope) {
            var me = this;

            me.global.location.hash = hash;

            callback && callback(scope || me);
        },

        /**
         * Expects an alert message with the specified text to be shown during the test. If no alert is called,
         * or the text doesn't match, a failed assertion will be added.
         *
         * @param {String/RegExp} message The expected alert message or a regular expression to match
         * @param callback Only used internally when this method is called in a t.chain command
         */
        expectAlertMessage : function (message, callback) {
            var me          = this
            var global      = this.global
            var prevAlert   = global.alert

            global.alert = function (msg) {
                var passed      = me.typeOf(message) == 'RegExp' ? message.test(msg) : message == msg

                if (passed)
                    me.pass("Expected alert message has been shown")
                else
                    me.fail("Wrong alert message has been shown", {
                        assertionName       : 'expectAlertMessage',
                        got                 : msg,
                        gotDesc             : "Message shown",
                        need                : message,
                        needDesc            : "Expected message"
                    })

                global.alert = prevAlert
            };

            global.alert.__EXPECTED_ALERT__ = true

            this.processCallbackFromTest(callback, null, this)
        },

        /**
         * Sets the confirm dialog return value for the next window.confirm() call.
         *
         * @param {Boolean} value The confirm dialog return value (true or false)
         * @param callback Only used internally when this method is called in a t.chain command
         * */
        setNextConfirmReturnValue : function (value, callback) {
            this.nextConfirmValue = value;

            this.processCallbackFromTest(callback, null, this)
        },

        /**
         * Sets the prompt dialog return value for the next window.prompt() call.
         *
         * @param {String} value The confirm dialog return value
         * @param callback Only used internally when this method is called in a t.chain command
         */
        setNextPromptReturnValue : function (value, callback) {
            this.nextPromptReturnValue = value;

            this.processCallbackFromTest(callback, null, this)
        },


        waitForAnimations : function(callback) {
            callback.call(this);
        },


        popupHasStartedLoading : function (popup, initialUrl) {
            if (String(initialUrl).toLowerCase() != 'about:blank' && popup.location.href == 'about:blank') return false

            return true
        },


        /**
         * Switches the target of all Siesta interactive commands (like "click/type" etc) to a different
         * window (usually a popup). You can use {@link #switchToMain} method to switch back to main window.
         *
         * @param {String/RegExp/Object/Window/HTMLIFrameElement} [win] A new window which should be a target for all interactive commands.
         * If this argument is specified as `null` a first opened popup is used.
         * Can be specified as the:
         *
         * - Window - A global window instance
         * - Object - Object with the following properties
         *      - url   : String/RegExp - The first popup, opened with matching url will be used
         *      - title : String/RegExp - The first popup, opened with matching title will be used
         * - String - corresponds to the `title` property of the Object branch
         *
         * @param {Function} callback Function to call once the switch has complete (will also wait until the target page
         * completes loading)
         *
         * @return {Window} Previously active window reference
         */
        switchTo : function (win, callback) {
            var me          = this

            // In Chrome, when popup for some url is just created, it has "url" set to "about:blank"
            // after some time the url is set to the original value and load process begins
            // this opens a race condition - one can not reliably predict when the popup has completed loading
            // doing our best
            this.waitFor({
                method              : function () {
                    for (var i = 0; i < me.popups.length; i++)
                        if (!me.popupHasStartedLoading(me.popups[ i ].popup, me.popups[ i ].url)) return false

                    return true
                },
                suppressAssertion   : true,

                callback            : function () {
                    var found

                    if (!win) {
                        Joose.A.each(this.popups, function (handle) {
                            if (!handle.popup.closed) { found = handle.popup;  return false }
                        })

                        win  = found
                    }

                    if (this.typeOf(win) == 'String') win = { title : win }

                    if (this.typeOf(win) == 'Object') {
                        found           = null
                        var regexp      = win.title || win.url

                        if (this.typeOf(regexp) == 'String') regexp = new RegExp('^' + this.escapeRegExp(regexp) + '$')

                        Joose.A.each(this.popups, function (handle) {
                            var popup       = handle.popup

                            if (!popup.closed)
                                if (
                                    win.url && regexp.test(popup.location.href)
                                    ||
                                    win.title && regexp.test(popup.document && popup.document.title || '')
                                ) {
                                    found = popup
                                    return false
                                }
                        })

                        win  = found
                    }

                    if (!win || win.self != win) {
                        this.fail("Can't resolve target win: " + win)

                        this.processCallbackFromTest(callback, null, this)

                        return
                    }

                    this.setGlobal(win)
//                    This has to be revised properly in the "context" branch, idea is, that we switch to popup's implementation
//                    of `setTimeout` for waiting, asyncing etc, because thats what really user expect
//                    however in IE test just hangs
//                    this.originalSetTimeout     = win.setTimeout
//                    this.originalClearTimeout   = win.clearTimeout

                    this.waitFor({
                        suppressAssertion   : true,
                        method      :  function () {
                            return win.document && win.document.readyState == 'complete'
                        },
                        callback    : callback
                    })
                }
            })

            return this.global
        },


        setGlobal : function (newGlobal) {
            this.global             = newGlobal
            this.simulator.global   = newGlobal
        },


        /**
         * Switches all interactive commands back to main test window.
         *
         * @param {Function} callback Function to call once the switch has complete.
         */
        switchToMain : function (callback) {
            this.switchTo(this.scopeProvider.scope, callback)
        },

        /**
         * Only useful along with {@link Siesta.Project.Browser.enablePageRedirect enablePageRedirect} option
         *
         * Wait for the page load to occur and runs the callback. The callback will receive a "window" object.
         * Should be used when you are doing a redirect / refresh of the test page:
         *
         *      t.waitForPageLoad(function (window) {
         *          ...
         *      })
         *
         * Note, that method obviously must be called before the new page has completed loading, otherwise it will
         * wait indefinitely and fail (since there will be no page load). So, to avoid the race conditions, one
         * should always start waiting for page load *before* the action, that causes it.
         *
         * Consider the following example (where click on the `>> #loginPanel button` trigger a page redirect):

         // this code does not reliably - it contains a race condition
         // in Chrome, page refresh may happen too fast (even synchronously),
         // so, by the time the `waitForPageLoad` action will start, the page load event will already happen
         // and `waitForPageLoad` will wait indefinitely
         { click : '>> #loginPanel button' },
         { waitFor : 'PageLoad'}
         * &nbsp;

         // Need to start waiting first, and only then - click
         // we'll use "trigger" config of the `wait` action for that
         {
             waitFor     : 'PageLoad',
             trigger     : {
                 click : '>> #loginPanel button'
             }
         }
         // or, same action using function step:
         function (next) {
        t.waitForPageLoad(next)

        t.click('>> #loginPanel button', function () {})
    }

         *
         * @method
         * @member Siesta.Test.Browser
         */
        waitForPageLoad : function (callback, scope) {
            var me              = this

            var global          = this.global
            var unloaded        = false
            var description     = Siesta.Resource('Siesta.Test.More').get('pageToLoad');
            var onUnloadHandler = function () {
                global.removeEventListener('unload', onUnloadHandler)

                unloaded        = true
            }

            global.addEventListener('unload', onUnloadHandler)

            this.chain(
                {
                    description    : description,
                    waitFor : function () {
                        return unloaded || me.global.document.readyState != 'complete'
                    }},
                function (next) {
                    global.removeEventListener('unload', onUnloadHandler)

                    global          = null
                    onUnloadHandler = null

                    next()
                },
                {
                    description    : description,
                    waitFor : function () {
                        return me.global.document.readyState == 'complete'
                    }
                },
                { waitFor : 50 },
                function () {
                    me.processCallbackFromTest(callback, [ me.global ], scope || me)
                }
            )
        },


        /**
         * This method will just call the `setTimeout` method from the scope of the test page.
         *
         * Usually you don't need to use it - you can just call `setTimeout`, but if your test scripts resides in the
         * separate context, you need to use this method for `setTimeout` functionality. See documentation for {@link Siesta.Project.Browser#enablePageRedirect enablePageRedirect}
         * option and <a href="#!/guide/cross_page_testing">Cross page testing</a> guide.
         *
         * @param {Function} func The function to call after specified `delay`
         * @param {Number} delay The time to wait (in ms) before calling the `func`
         * @return {Number} timeoutId The id of the timeout, can be passed to {@link #clearTimeout} to cancel the function execution.
         *
         * @method
         * @member Siesta.Test.Browser
         */
        setTimeout : function (func, delay) {
            var pageSetTimeout = this.global.setTimeout

            pageSetTimeout(func, delay)
        },


        /**
         * This method will just call the `clearTimeout` method from the scope of the test page.
         *
         * Usually you don't need to use it - you can just call `clearTimeout`, but if your test scripts resides in the
         * separate context, you need to use this method for `clearTimeout` functionality. See documentation for {@link Siesta.Project.Browser#enablePageRedirect enablePageRedirect}
         * option and <a href="#!/guide/cross_page_testing">Cross page testing</a> guide.
         *
         * @param {Number} timeoutId The id of the timeout, recevied from the {@link #setTimeout} call
         *
         * @method
         * @member Siesta.Test.Browser
         */
        clearTimeout : function (id) {
            var pageClearTimeout = this.global.clearTimeout

            pageClearTimeout(id)
        },

        /**
         * This method mimics the deactivation of a browser window by opening a new window. Useful if you want to test
         * how your application behaves when your application is not active.
         *
         * @method
         * @member Siesta.Test.Browser
         */
        simulateDeactivateWindow : function(callback) {
            this.blurWindow = this.global.open('about:blank');

            callback && callback.call(this);
        },

        /**
         * This method activates the main browser window reverts focus to the window object of the test.
         *
         * @method
         * @member Siesta.Test.Browser
         */
        simulateActivateWindow : function(callback) {
            this.blurWindow && this.blurWindow.close();

            this.global.focus();

            this.blurWindow = null;

            callback && callback.call(this);
        },


        /**
         * This method resolves a query string. At the generic browser level, this is supposed to be a CSS selector
         * (other framework specific layers, like ExtJS adds additional semantic).
         *
         * @param {String} selector
         * @return {Array[Element]}
         */
        query : function (selector) {
            return this.sizzle(selector)
        },


        /**
         * This assertion passes if an exception with certain message is thrown, during the time since this method has been called
         * and until the `done` function has been called. The `done` function is returned from this method. It should be called once
         * the code, that is expected to throw exception, has completed. `done` function can be called asynchronously.
         *
         * If `done` is not called for more than `timeout` time, this assertions finalizes forcefully.
         *
         * For example:
         *

    var done

    t.chain(
        function (next) {
            done = t.throwsOkAsync('oops', 'Correct exception thrown', 25000)
            next()
        },
        // the exception is expected from the click handler
        { click : '.some-button' },
        function (next) {
            done()
            next()
        },
    )

         *
         * See also {@link Siesta.Test.Browser#livesOkAsync} method.
         *
         * @param {String/RegExp} expected The regex against which to test the stringified exception, can be also a plain string
         * @param {String} [desc] The description of the assertion
         * @param {Number} [timeout] The timeout after which this assertion will be finalized forcefully. Default value is {@link Siesta.Project#defaultTimeout}
         *
         * @return {Function} A function which should be called when the code block, which is expected to throw the exception, is completed
         */
        throwsOkAsync : function (expected, desc, timeout) {
            var R                   = Siesta.Resource('Siesta.Test.More')
            var me                  = this

            var exceptionThrown     = false
            var doneCalled          = false
            var prevOnError         = this.global.onerror

            var done        = function () {
                if (doneCalled) return
                doneCalled                  = true

                me.endAsync(async)

                if (!exceptionThrown) {
                    me.fail(desc, {
                        assertionName       : 'throwsOkAsync',
                        annotation          : R.get('didntThrow')
                    })
                }

                me.isHandlingThrowAsync     = false

                me.global.onerror           = prevOnError

                // return true to suppress possible timeout failure, since `done` is also used as a errback for `beginAsync`
                return true
            }

            this.on('beforetestfinalize', function () {
                if (!doneCalled) done()
            }, null, { single : true })

            var async       = this.beginAsync(timeout, done)

            this.isHandlingThrowAsync = true

            this.global.onerror = function (msg, url, lineNumber, col, error) {
                exceptionThrown     = true

                var errorText       = String(error ? error : msg)

                if (me.typeOf(expected) == "RegExp")

                    if (errorText.match(expected))
                        me.pass(desc, {
                            descTpl             : R.get('exMatchesRe'),
                            expected            : expected
                        })
                    else
                        me.fail(desc, {
                            assertionName       : 'throwsOkAsync',
                            got                 : errorText,
                            gotDesc             : R.get('exceptionStringifiesTo'),
                            need                : expected,
                            needDesc            : R.get('needStringMatching')
                        })
                else

                    if (errorText.indexOf(expected) != -1)
                        me.pass(desc, {
                            descTpl             : R.get('exContainsSubstring'),
                            expected            : expected
                        })
                    else
                        me.fail(desc, {
                            assertionName       : 'throwsOkAsync',
                            got                 : errorText,
                            gotDesc             : R.get('exceptionStringifiesTo'),
                            need                : expected,
                            needDesc            : R.get('needStringContaining')
                        })

                // "hide" the exception
                return true
            }

            return done
        },


        /**
         * This assertion passes if no exceptions are thrown, during the time since this method has been called
         * and until the `done` function has been called. The `done` function is returned from this method. It should be called once
         * the code, that is expected to not throw exceptions, has completed. `done` function can be called asynchronously.
         *
         * If `done` is not called for more than `timeout` time, this assertions finalizes forcefully.
         *
         * For example:
         *

    var done

    t.chain(
        function (next) {
            done = t.livesOkAsync('No exception thrown')
            next()
        },
        // the exception is expected from the click handler
        { click : '.some-button' },
        function (next) {
            done()
            next()
        }
    )

         *
         * See also {@link Siesta.Test.Browser#throwsOkAsync} method.
         *
         * @param {String} [desc] The description of the assertion
         * @param {Number} [timeout] The timeout after which this assertion will be finalized forcefully. Default value is {@link Siesta.Project#defaultTimeout}
         *
         * @return {Function} A function which should be called when the code block, which is expected to now throw exceptions, is completed
         */
        livesOkAsync : function (desc, timeout) {
            var R                   = Siesta.Resource('Siesta.Test.More')
            var me                  = this

            var exceptionThrown     = false
            var doneCalled          = false
            var prevOnError         = this.global.onerror

            var done        = function () {
                if (doneCalled) return
                doneCalled                  = true

                me.endAsync(async)

                if (!exceptionThrown) {
                    me.pass(desc, {
                        descTpl             : R.get('fnDoesntThrow')
                    })
                }

                me.isHandlingThrowAsync     = false

                me.global.onerror           = prevOnError

                // return true to suppress possible timeout failure, since `done` is also used as a errback for `beginAsync`
                return true
            }

            this.on('beforetestfinalize', function () {
                if (!doneCalled) done()
            }, null, { single : true })

            var async       = this.beginAsync(timeout, done)

            this.isHandlingThrowAsync = true

            this.global.onerror = function (msg, url, lineNumber, col, error) {
                exceptionThrown     = true

                var errorText       = String(error ? error : msg)

                me.fail(desc, {
                    assertionName       : 'livesOk',
                    annotation          : R.get('fnThrew') + ': ' + errorText
                })

                // "hide" the exception
                return true
            }

            return done
        },


        onException : function () {
            if (this.isHandlingThrowAsync) return true
        }
    }
});
;
/**
 *
@class Siesta.Test.ExtJS
@extends Siesta.Test.Browser
@mixin Siesta.Test.ExtJSCore
@mixin Siesta.Test.ExtJS.Ajax
@mixin Siesta.Test.ExtJS.Observable
@mixin Siesta.Test.ExtJS.FormField
@mixin Siesta.Test.ExtJS.Component
@mixin Siesta.Test.ExtJS.Element
@mixin Siesta.Test.ExtJS.Store
@mixin Siesta.Test.ExtJS.DataView
@mixin Siesta.Test.ExtJS.Grid

A base class for testing browser and ExtJS applications. It inherit from {@link Siesta.Test.Browser}
and adds various ExtJS specific assertions.

This file is a reference only, for a getting start guide and manual, please refer to <a href="#!/guide/getting_started_browser">Siesta getting started in browser environment</a> guide.

*/
Class('Siesta.Test.ExtJS', {

    isa         : Siesta.Test.Browser,

    does        :  [
        Siesta.Test.ExtJSCore,
        Siesta.Test.ExtJS.Component,
        Siesta.Test.ExtJS.Element,
        Siesta.Test.ExtJS.FormField,
        Siesta.Test.ExtJS.Observable,
        Siesta.Test.ExtJS.Store,
        Siesta.Test.ExtJS.Grid,
        Siesta.Test.ExtJS.DataView,
		Siesta.Test.ExtJS.Ajax
    ],


    has : {
        globalExtOverrides      : null,

        extPathRegex1           : /(.*ext(?:js)?(?:-\d\.\d+\.\d+)?.*?)\/(?:build\/)?ext(?:-all)?(?:-debug|-dev)?\.js/,
        extPathRegex2           : /(.*ext(?:js)?-\d\.\d+(?:\.\d+)?.*?)\/ext-all(?:-debug|-dev)?\.js/,
        extPathRegex3           : /(.*ext(?:js)?\/gpl\/\d\.\d+(?:\.\d+)?.*?)\/ext-all(?:-debug|-dev)?\.js/
    },

    methods : {

        getExtBundlePath : function() {
            var path
            var testDescriptor      = this.project.getScriptDescriptor(this.url)
            var me                  = this

            while (testDescriptor && !path) {
                if (testDescriptor.preload) {
                    Joose.A.each(testDescriptor.preload, function (url) {
                        if (url.match && (url.match(me.extPathRegex1) || url.match(me.extPathRegex2) || me.extPathRegex3.exec(url))) {
                            path    = url;
                            return false;
                        }
                    });
                }
                testDescriptor = testDescriptor.parent;
            }

            return path;
        },


        getExtBundleFolder : function() {
            var folder;
            var testDescriptor      = this.project.getScriptDescriptor(this.url)
            var me                  = this

            while (testDescriptor && !folder) {
                if (testDescriptor.preload) {
                    Joose.A.each(testDescriptor.preload, function (url) {
                        var match = me.extPathRegex1.exec(url) || me.extPathRegex2.exec(url) || me.extPathRegex3.exec(url);

                        if (match) folder = match[1];

                        return false
                    });
                }
                testDescriptor = testDescriptor.parent;
            }

            return folder;
        },


        getNumberOfGlobalExtOverrides : function (callback) {
            var globalExtOverrides  = this.globalExtOverrides;

            if (globalExtOverrides != null)
                callback && callback.call(this, globalExtOverrides.length, globalExtOverrides)
            else {
                var me              = this;
                var Ext             = this.getExt();
                var extjsBundleURL  = me.getExtBundlePath()

                if (!extjsBundleURL) {
                    me.fail(Siesta.Resource('Siesta.Test.ExtJS', 'bundleUrlNotFound'));
                    callback && callback.call(me, null, null)
                    return;
                }

                // For IE
                this.expectGlobal('0');

                var frame           = Ext.core.DomHelper.append(Ext.getBody(), {
                    tag     : "iframe",
                    style   : 'width:1024px;height:768px;position:absolute;left:-10000px;top:-10000px',
                    src     : 'about:blank'
                }, false);

                var freshWin        = frame.contentWindow;

                freshWin.document.open();

                freshWin.document.write(
                    '<!DOCTYPE html>' +
                    '<html>' +
                        '<head>' +
                            '<script type="text/javascript" src="' + extjsBundleURL + '"></script>' +
                        '</head>' +
                        '<body></body>' +
                    '</html>'
                );

                freshWin.document.close();

                var resolveObject   = function (hostObj, nameSpace) {
                    var parts   = nameSpace.split('.');
                    var p       = hostObj

                    for (var i = 0; i < parts.length; i++) {
                        p       = p[ parts[ i ] ];
                    };

                    return p;
                }

                var ignoreRegexp    = [
                    /Ext\.data\.Store\.ImplicitModel|collectorThreadId|Ext\.dom\.GarbageCollector\.lastTime/,
                    /Ext.globalEvents.cur/i,
                    /Ext\.dd\.(DragDropManager|DragDropMgr|DDM)\.(currentPoint|offsetX|offsetY)/
                ]

                var ignore          = function (name) {
                    for (var i = 0; i < ignoreRegexp.length; i++)
                        if (ignoreRegexp[ i ].test(name)) return true

                    return false
                }

                var getObjectDifferences    = function (cleanObj, dirtyObj, ns) {
                    var diff    = []

                    for (var p in dirtyObj) {
                        try {
                            if (dirtyObj.hasOwnProperty(p)) {
                                var dirtyValue  = dirtyObj[ p ]
                                var cleanValue  = cleanObj[ p ]

                                // Check if the object exists on the clean window and also do a string comparison
                                // in case a builtin method has been overridden
                                if (
                                    (!cleanObj.hasOwnProperty(p) && typeof cleanValue == 'undefined' )
                                        ||
                                    (
                                        String(cleanValue) != String(dirtyValue)
                                            &&
                                        (typeof dirtyValue == 'function' || Ext.isPrimitive(dirtyValue))
                                    )
                                ) {
                                    if (!ignore(ns + '.' + p)) diff.push(ns + '.' + p)
                                }
                            }
                        } catch (e) {
                            // Just continue
                        }
                    }
                    return diff;
                }

                me.waitFor(
                    function () { return freshWin.Ext && freshWin.Ext.isReady; },
                    function () {
                        var dirtyWin    = me.global,
                            overrides   = [];

                        // Check for native class augmentations
                        Ext.iterate(Ext.ClassManager.classes, function (item) {
                            if (!item.match(/^Ext\./)) return;

                            var freshItem   = resolveObject(freshWin, item);
                            var dirtyItem   = resolveObject(dirtyWin, item);

                            if (freshItem && typeof dirtyItem !== 'undefined') {
                                var staticDiff = getObjectDifferences(freshItem,  dirtyItem, item);

                                overrides.push.apply(overrides, staticDiff);

                                // Prototype properties
                                if (dirtyItem.prototype) {
                                    var prototypeDiff = getObjectDifferences(freshItem.prototype, dirtyItem.prototype, item + '.prototype');

                                    overrides.push.apply(overrides, prototypeDiff);
                                }
                            }
                        });

                        me.globalExtOverrides   = overrides

                        Ext.destroy(frame);

                        callback && callback.call(me, overrides.length, overrides)
                    }
                )
                // eof waitFor
            }
        },


        /**
         * This assertion passes if no global Ext JS overrides exist. It creates a fresh iframe window where a new, fresh copy
         * of Ext JS w/o any overrides is loaded and then a comparison is made against the copy of Ext JS loaded in the test.
         *
         * A global ExtJS override is some change, made in the core class, for example like this:
         *

    Ext.data.Store.override({
        removeAll       : function () {
            // my fix
            ...
        }
    })

         * While such overrides are often seems as the only possible solution (usually for some bug in Ext) they should be
         * avoided as much as possible, because it a very bad practice. For example, in the previous case, a better approach
         * would be to create a new subclass of the Ext.data.Store with the desired changed.
         *
         * See also {@link #assertMaxNumberOfGlobalExtOverrides} assertion.
         *
         * @param {String} [description] The description for the assertion
         */
        assertNoGlobalExtOverrides : function (description, cb) {
            this.getNumberOfGlobalExtOverrides(function (length, overrides) {
                var R = Siesta.Resource('Siesta.Test.ExtJS');

                if (length == null) {
                    this.fail(R.get('assertNoGlobalExtOverridesInvalid'))
                } else {

                    if (length) {
                        this.fail(description, {
                            assertionName   : 'assertNoGlobalExtOverrides',
                            descTpl         : R.get('assertNoGlobalExtOverridesPassTpl'),

                            got             : length,
                            gotDesc         : R.get('assertNoGlobalExtOverridesGotDesc'),

                            annotation      : R.get('foundOverridesFor') + ': `' + overrides.join('`, `') + '`'
                        })
                    } else {
                        this.pass(description, {
                            descTpl             : R.get('assertNoGlobalExtOverridesPassTpl')
                        })
                    }

                    // For testing only
                    cb && cb.call(this);
                }

            })
        },


        /**
         * This assertion passes if the number of global overrides does not exceed the given number.
         *
         * For example, you can add this assertion in your existing codebase (assuming you have 3 overrides your application
         * cannot function without):
         *
         *      t.assertMaxNumberOfGlobalExtOverrides(3, "Ideally should be none of these")
         *
         * and catch all the cases when someone adds a new global override.
         *
         * @param {Number} maxNumber The maximum number of Ext JS overrides allowed
         * @param {String} [description] The description for the assertion
         */
        assertMaxNumberOfGlobalExtOverrides : function (maxNumber, description, cb) {
            var R   = Siesta.Resource('Siesta.Test.ExtJS');

            this.getNumberOfGlobalExtOverrides(function (length, overrides) {
                if (length == null) {
                    this.fail(R.get("extOverridesInvalid"));
                } else {

                    if (length > maxNumber) {
                        this.fail(description, {
                            assertionName   : 'assertNoGlobalExtOverrides',
                            descTpl         : R.get('foundLessOrEqualThan') + ' ' + maxNumber + ' ' + R.get('globalOverrides'),

                            got             : length,
                            gotDesc         : R.get('nbrOverridesFound'),

                            annotation      : R.get('foundOverridesFor') + ': `' + overrides.join('`, `') + '`'
                        })
                    } else {
                        this.pass(description, {
                            descTpl             : R.get('foundLessOrEqualThan') + ' ' + maxNumber + ' ' + R.get('globalOverrides'),
                            annotation          : R.get('nbrOverridesFound') + ': ' + length
                        })
                    }

                    // For testing only
                    cb && cb.call(this)
                }

            })
        },

        /**
         * A helper method returning the total number of Ext JS container layouts that have been performed since the beginning of the page lifecycle.
         * @return {Int} The number of layouts
         */
        getTotalLayoutCounter : function () {
            var count       = 0

            this.Ext().each(this.cq('container'), function(c) { count += c.layoutCounter });

            return count;
        },

        /**
         * This assertion passes if no Ext JS layout cycles are performed as a result of running the passed function. This
         * function will query all containers on the page and measure the number of layouts performed before and after the function call.
         *
         * @param {Function} fn The function to call
         * @param {Object} scope The 'thisObject' to use for the function call
         * @param {String} [description] The description for the assertion
         */
        assertNoLayoutTriggered : function(fn, scope, description) {
            var countBefore = this.getTotalLayoutCounter();

            fn.call(scope || this);

            this.is(this.getTotalLayoutCounter(), countBefore, description);
        },

        areAnimationsRunning : function() {
            var Ext = this.Ext();

            return Ext && Ext.fx && Ext.fx.Manager && Ext.fx.Manager.items && Ext.fx.Manager.items.getCount() > 0;
        }
    }
})
;
/**
@class Siesta.Test.SenchaTouch
@extends Siesta.Test.Browser
@mixin Siesta.Test.ExtJSCore
@mixin Siesta.Test.ExtJS.Observable
@mixin Siesta.Test.ExtJS.FormField
@mixin Siesta.Test.ExtJS.Component
@mixin Siesta.Test.ExtJS.Element
@mixin Siesta.Test.ExtJS.Store

A base class for testing Sencha Touch applications. It inherits from {@link Siesta.Test.Browser}
and adds various ST specific assertions.

This file is a reference only, for a getting start guide and manual, please refer to <a href="#!/guide/getting_started_browser">Siesta getting started in browser environment</a> guide.

*/
Class('Siesta.Test.SenchaTouch', {

    isa         : Siesta.Test.Browser,

    does        :  [
        Siesta.Test.ExtJSCore,
        Siesta.Test.ExtJS.Component,
        Siesta.Test.ExtJS.Element,
        Siesta.Test.ExtJS.Observable,
        Siesta.Test.ExtJS.Store,
		Siesta.Test.ExtJS.Ajax,
        Siesta.Test.ExtJS.FormField
    ],

    has         : {
        performSetup        : true,
        isSTSetupDone       : false,

        moveCursorBetweenPoints : false
    },

    override : {

        isReady : function () {
            var result  = this.SUPERARG(arguments);
            var R       = Siesta.Resource('Siesta.Test.SenchaTouch');

            if (!result.ready) return result;

            if (!this.parent && this.performSetup && !this.isSTSetupDone) return {
                ready       : false,
                reason      : R.get('STSetupFailed')
            }

            return {
                ready       : true
            }
        },


        doStart : function () {
            var me      = this;
            var Ext     = this.getExt();

            if (Ext) {
                // execute "Ext.setup()" for top-level tests only
                if (this.performSetup && !this.parent)
                    // calling before the SUPER, to possibly avoid waiting in "isReady" polling at all
                    // (since page can be already DOM ready)
                    Ext.setup({
                        onReady : function () {
                            me.isSTSetupDone    = true
                        }
                    })
            }

            // calling SUPER to setup the loader paths, Ext.setup() will already do Ext.require
            this.SUPERARG(arguments)
        }
    },

    methods : {

        initialize : function () {
            // delete the possibly provided native simulator to force synthetic
            if (!this.parent) this.simulator = null

            this.SUPERARG(arguments)
        },


        // one of these methods feels redundant
        getTouchBundlePath : function() {
            var path;
            var testDescriptor      = this.project.getScriptDescriptor(this.url)

            while (testDescriptor && !path) {
                if (testDescriptor.preload) {
                    Joose.A.each(testDescriptor.preload, function (url) {
                        if (url.match && url.match(/(.*sencha-touch-\d\.\d+\.\d+.*?)\/sencha-touch(.*)\.js/)) {
                            path = url;
                            return false;
                        }
                    });
                }
                testDescriptor = testDescriptor.parent;
            }

            return path;
        },


        getTouchBundleFolder : function() {
            var folder;
            var testDescriptor      = this.project.getScriptDescriptor(this.url)

            while (testDescriptor && !folder) {
                if (testDescriptor.preload) {
                    Joose.A.each(testDescriptor.preload, function (url) {
                        var regex = /(.*sencha-touch-\d\.\d+\.\d+.*?)\/sencha-touch(.*)\.js/;
                        var match = regex.exec(url);

                        if (match) {
                           folder = match[1];
                        }
                    });
                }
                testDescriptor = testDescriptor.parent;
            }

            return folder;
        },


        getExtBundleFolder : function() {
            var folder;

            this.project.mainPreset.eachResource(function (resource) {
                var desc = resource.asDescriptor();

                var regex = /(.*sencha-touch-\d\.\d+\.\d+.*?)\/sencha-touch-all(?:-debug)?\.js/;
                var match = regex.exec(desc.url);

                if (match) {
                   folder = match[1];
                }
            });

            return folder;
        },


        /**
        * This method will simulate a finger move to an xy-coordinate or an element (the center of it)
        *
        * @param {Siesta.Test.ActionTarget} target Target point to move the finger to.
        * @param {Function} callback (optional) To run this method async, provide a callback method to be called after the operation is completed.
        * @param {Object} scope (optional) the scope for the callback
        * @param {Array} offset (optional) An X,Y offset relative to the target. Example: [20, 20] for 20px or ["50%", "50%"] to click in the center.
         */
        moveFingerTo : function(target, callback, scope, offset) {
            this.moveCursorTo.apply(this, arguments);
        },

        /**
        * This method will simulate a finger move from current position relative by the x and y distances provided.
        *
        * @param {Array} delta The delta offset to move the finger by.
        * @param {Function} callback (optional) To run this method async, provide a callback method to be called after the operation is completed.
        * @param {Object} scope (optional) the scope for the callback
        */
        moveFingerBy : function(delta, callback, scope) {
            if (!delta) {
                var R = Siesta.Resource('Siesta.Test.SenchaTouch');
                throw R.get('moveFingerByInvalidInput');
            }

            this.moveCursorBy.apply(this, arguments);
        },


        scrollUntil : function(target, direction, checkerFn, callback, scope) {
            var me          = this,
                startDate   = new Date(),
                dir         = direction;

            var R = Siesta.Resource('Siesta.Test.SenchaTouch');

            // Invert direction, Scroll up => Swipe down
            switch(dir) {
                case 'u':
                case 'up':
                    direction = 'down';
                break;

                case 'd':
                case 'down':
                    direction = 'up';
                break;

                case 'l':
                case 'left':
                    direction = 'right';
                break;

                case 'r':
                case 'right':
                    direction = 'left';
                break;

                default:
                    throw R.get('invalidSwipeDir') + ': ' + direction;
            }

            var inner = function() {
                if (checkerFn.call(scope || me, target)) {
                    // We're done
                    me.processCallbackFromTest(callback, null, scope || me)
                } else {
                    me.swipe(target, direction, function() {

                        if (new Date() - startDate < this.waitForTimeout) {
                            var as = me.beginAsync();
                            setTimeout(function() {
                                me.endAsync(as);
                                inner();
                            }, 1000);
                        } else {
                            me.fail(R.get('scrollUntilFailed'));
                        }
                    });
                }
            };

            inner();
        },

        /**
         * Waits until the supplied x&y scroll property has the passed value. You can test for either x or y, or both.
         *
         * @param {Ext.scroller.Scroller} scrollable The scroller instance
         * @param {String} direction 'up', 'down', 'left' or 'right'
         * @param {Siesta.Test.ActionTarget} actionTarget The target, either an element or a CSS selector normally.
         * @param {Function} callback The callback to call
         * @param {Object} scope The scope for the callback
         */
        scrollUntilElementVisible : function(scrollable, direction, actionTarget, callback, scope) {
            var me = this;

            if (!actionTarget || !scrollable) {
                var R = Siesta.Resource('Siesta.Test.SenchaTouch');
                this.fail(R.get('scrollUntilElementVisibleInvalid'));

                return;
            }

            this.scrollUntil(scrollable, direction, function() {
                var element = me.normalizeElement(actionTarget, true);
                return me.elementIsInView(element);
            },
            callback, scope);
        },


        /**
         * Waits until the supplied x&y scroll property has the passed value. You can test for either x or y, or both.
         *
         * @param {Ext.scroller.Scroller} scroller The scroller instance
         * @param {Object} position An object with an x, y, or x&y values. Ex. { x : 0 } or { x : 0, y : 200 }.
         * @param {Int} value
         * @param {Function} callback The callback to call
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForScrollerPosition: function(scroller, pos, callback, scope, timeout) {
            return this.waitFor({
                method          : function() {
                    return (!('x' in pos) || pos.x === scroller.position.x) && (!('y' in pos) || pos.y === scroller.position.y);
                },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : 'waitForScrollerPosition',
                description     : ' ' + Siesta.Resource('Siesta.Test.SenchaTouch', 'scrollerReachPos') + ' '+ Siesta.Util.Serializer.stringify(pos)
            });
        },


        areAnimationsRunning : function() {
            var Ext = this.Ext();

            return Ext && Ext.Anim && !Joose.O.isEmpty(Ext.Anim.running);
        }
    }
})
;
/**
 *
@class Siesta.Test.jQuery
@extends Siesta.Test.Browser

A base class for testing jQuery applications. It inherit from {@link Siesta.Test.Browser} and adds various jQuery specific assertions.

This file is a reference only, for a getting start guide and manual, please refer to <a href="#!/guide/getting_started_browser">Siesta getting started in browser environment</a> guide.

*/
Class('Siesta.Test.jQuery', {

    isa         : Siesta.Test.Browser,

    methods : {

        initialize : function() {
            // Since this test is preloading jQuery, we should let Siesta know what to 'expect'
            this.expectGlobals('$', 'jQuery');
            this.SUPER();
        },


        /**
         * This method returns the jQuery object from the scope of the test. When creating your own assertions for jQuery code, you need
         * to make sure you are using this method to get the `jQuery` instance.
         * @return {Object} The `$` object from the scope of test
         */
        get$ : function () {
            return this.global.$;
        },

        normalizeElement : function (el) {
            return el.jquery ? el.get(0) : this.SUPERARG(arguments);
        }
    }
})
;
Class('Siesta.Content.Manager.Browser', {
    
    isa     : Siesta.Content.Manager,
    
    has : {
        baseHost            : function () { return window.location.host },
        baseProtocol        : function () { return window.location.protocol }
    },
    
    
    methods : {
        
        load : function (url, onsuccess, onerror) {
            var match       = /^((?:https?|file):)?\/\/([^/]*)/i.exec(url)
            
            if (match && (match[ 1 ] && match[ 1 ] != this.baseProtocol || match[ 2 ] != this.baseHost)) {
                onerror('cross-domain access')
                
                return
            }
            
            var req = new JooseX.SimpleRequest()
            
            try {
                req.getText(url, true, function (success, text) {
                    
                    if (!success) { 
                        onerror(this + " not found") 
                        return 
                    }
                    
                    onsuccess(text)
                })
            } catch (e) {
                onerror(e)
            }
        }
    }
})

;
Class('Siesta.Content.Manager.Browser.ExtJSCore', {
    isa     : Siesta.Content.Manager.Browser
})

;
/**
@class Siesta.Project.Browser
@extends Siesta.Project

Class, representing the browser project. This class provides a web-based UI and defines some additional configuration options.

The default value of the `testClass` configuration option in this class is {@link Siesta.Test.Browser}, which contains
only generic browser-related assertions. So, use this project class, when testing a generic web page.

This file is for reference only, for a getting start guide and manual, please refer to <a href="#!/guide/getting_started_browser">Siesta getting started in browser environment</a> guide.


Synopsys
========

    var project = new Siesta.Project.Browser();

    project.configure({
        title     : 'Awesome Test Suite',

        transparentEx       : true,

        autoCheckGlobals    : true,
        expectedGlobals     : [
            'Ext',
            'Sch'
        ],

        preload : [
            "http://cdn.sencha.io/ext-4.0.2a/ext-all-debug.js",
            "../awesome-project-all.js",
            {
                text    : "console.log('preload completed')"
            }
        ]
    })


    project.plan(
        // simple string - url relative to project file
        'sanity.t.js',

        // test file descriptor with own configuration options
        {
            url     : 'basic.t.js',

            // replace `preload` option of project
            preload : [
                "http://cdn.sencha.io/ext-4.0.6/ext-all-debug.js",
                "../awesome-project-all.js"
            ]
        },

        // groups ("folders") of test files (possibly with own options)
        {
            group       : 'Sanity',

            autoCheckGlobals    : false,

            items       : [
                'data/crud.t.js',
                ...
            ]
        },
        ...
    )

    project.start()



*/

Class('Siesta.Project.Browser', {

    isa         : Siesta.Project,

    has : {
        id                  : null,

        /**
         * @cfg {Class} testClass The test class which will be used for creating test instances, defaults to {@link Siesta.Test.Browser}.
         * You can subclass {@link Siesta.Test.Browser} and provide a new class, please refer to the <a href="#!/guide/extending_test_clas">Extending test class</a> guide.
         *
         * This option can be also specified in the test file descriptor.
         */
        testClass           : Siesta.Test.Browser,

        viewportClass       : "Siesta.Project.Browser.UI.Viewport",

        viewport            : null,

        /**
         * @cfg {Boolean} autoRun When set to `true`, project will automatically launch the execution either of the checked test files or the whole suite.
         * Default value is `false`
         */
        autoRun             : false,

        /**
         * @cfg {Boolean} viewDOM When set to `true`, project will expand the panel with the `<iframe>` of the test file, so you can examine the content of DOM.
         * Default value is `false`
         */
        viewDOM             : false,

        /**
         * @cfg {Boolean} scaleToFit When set to `true`, the `<iframe>` of the test file will be scaled to fit the available space.
         */
        scaleToFit          : true,

        /**
         * @cfg {String} scaleToFitMode One of the `full`, `width`, `height` to scale to fit to particular dimension only, or to both.
         */
        scaleToFitMode      : 'full',


        /**
         * @cfg {String} domContainerRegion Should be exactly one of `east/west/south/north`. Controls the position of the dom container
         * panel. Set it to `south` to create a "portrait" mode of the results panel with the assertions grid at the top and DOM container
         * at the bottom.
         */
        domContainerRegion  : 'east',


        // flag which enables mouse cursor visualization
        showCursor          : true,

        /**
         * @cfg {Boolean} showTestDurationColumn Enable to display the column with tests duration. This column is always
         * visible in the HTML report.
         */
        showTestDurationColumn  : false,

        /**
         * @cfg {Boolean} speedRun When set to `true`, project will reduce the quality or completely remove the visual effects
         * for events simulation, improving the speed of test. Default value is `true`.
         *
         * Note, that events will still be simulated for every point in the mouse move path, so the accuracy of the
         * simulation is not affected by this option. See {@link #mouseMovePrecision} for additional performance improvement.
         *
         * This option can be also specified in the test file descriptor.
         */
        speedRun            : true,

        /**
         * @cfg {Boolean} turboMode When set to `true`, project will reduce the precision of mouse move operations to only simulate 'mouseover' events for 1st and last
         * point of a path. Siesta also has various internal delays, which happen between action steps and after every action. The purpose of these delays is to allow
         * to tests to pass more easily, as UI frameworks typically expect the user behavior to be slow. For example, there is an afterAction delay set to 100ms, which can add up to be a quite big number, especially for big UI test suites.
         * With the turboMode option, Siesta sets all such delays to 1, providing the fastest possible test execution. This will force you to know your code very well and
         * introduce proper waitFor statements wherever you have asynchronous flows.
         *
         * Default value is `false`. **Only intended for power users who want extremely fast UI tests**.
         *
         * Note, that only start and end point events will be simulated, so you may experience unexpected side effects
         * See {@link #mouseMovePrecision} for additional performance improvement.
         *
         * This option can be also specified in the test file descriptor.
         */
        turboMode : false,

        /**
         * @cfg {Integer} mouseMovePrecision
         *
         * Defines how precisely to follow the path between two points when simulating a drag or mouse move.
         *
         * - Value 1 indicates that "mouseover/mouseout" events are simulated for every point along the path (which is
         * often not required at all).
         * - Value 2 indicates every 2nd point will be used
         * - ... and so on, in general, low value = slow dragging, higher accuracy, high value = fast dragging, lower accuracy.
         *
         * Setting this option to some big number (like 100000) will cause Siesta to only simulate events for the
         * two initial and two final points in the path, which provides significant performance boost. However, if you need
         * to verify some behaviour, triggered by mouse events from the element somewhere in the middle of the path
         * you may need to use lower value for this option.
         *
         * See also {@link #speedRun} option.
         *
         * This option can be also specified in the test file descriptor.
         */
        mouseMovePrecision      : 1,

        /**
         * @cfg {Boolean} failOnResourceLoadError When set to `true`, test will try to detect the failures for loading of
         * various resources (`script/link/img` tags) and report those as failed assertions. Only supported in modern browsers.
         * Default value is `false`.
         *
         * This option can be also specified in the test file descriptor.
         */
        failOnResourceLoadError : false,

        /**
         * @cfg {Boolean} failOnPromiseRejection When set to `true`, test will add a failing assertion for the unhandled promise rejections (if browser
         * supports detecting them).
         *
         * This option can be also specified in the test file descriptor.
         */
        failOnPromiseRejection  : true,


        contentManagerClass : Siesta.Content.Manager.Browser,
        scopeProvider       : 'Scope.Provider.IFrame',

        /**
         * @cfg {Boolean} disableCaching When set to `true`, project will prevent the browser caching of files being preloaded and the test files, by appending
         * a query string to it.
         * Note, that in this case, debuggers may not understand that you are actually loading the same file, and breakpoints may not work. Default value is `false`
         */
        disableCaching      : false,

        baseUrl             : window.location.href.replace(/(\?|#).*$/, '').replace(/\/[^/]*$/, '/'),
        baseHost            : window.location.host,
        baseProtocol        : window.location.protocol,

        /**
         * @cfg {Boolean} forceDOMVisible When set to `true` the tests will be executed in "fullscreen" mode, with their iframes on top of all other elements.
         * This is required in IE if your test includes interaction with the DOM, because the `document.getElementFromPoint()` method
         * does not work correctly in IE unless the element is visible.
         *
         * This option is enabled by default in IE / Edge and disabled in all other browsers.
         * This option can be also specified in the test file descriptor (usually you will create a group of "rendering" tests). Usually it's only relevant for IE,
         * so using this option should look like:
         *

    project.plan(
        {
            group       : 'Rendering',

            forceDOMVisible    : bowser.msie,

            items       : [
                'rendering/01_grid.t.js',
                ...
            ]
        },
        ...
    )

         */
        forceDOMVisible     : bowser.msie || bowser.msedge,

        // "override from UI" setting
        observerMode        : false,

        /**
         * @cfg {Boolean} runInPopup Experimental. When set to `true` the tests will be executed in the popup, instead of iframe.
         * You will need to enable popups the host you are testing from.
         *
         * Popups provides almost exactly the same environment as standalone page - notably the `window.top` property
         * reference the popup itself, making it easier to test hash-based navigation.
         *
         * Note, that mouse cursor visualization does not work for tests in popups.
         *
         * This option can be also specified in the test file descriptor.
         */
        runInPopup          : false,


        /**
         * @cfg {String} pageUrl The url of the HTML page which will be the target for the test(s) (the URL must be on the same domain the project HTML page). This option is used for application level testing, Siesta will visit this URL and then launch
         * the test. See `/examples/021-extjs-drag-drop/index.js` for an example.
         *
         * Note that with this option, the test descriptor will stop inheriting the {@link #preload} option from parent descriptors/project
         * (to make sure you don't preload your dependencies twice). This is usually an expected behavior, and you still can specify the `preload` option
         * directly on such descriptor if needed.
         *
         * This option can be also specified in the test file descriptor. This option has a deprecated synonym - "hostPageUrl"
         *
         * For example, to define that a test should be executed on a page generated by some php script:

    project.plan(
        {
            pageUrl         : '../my_php_script?page=home',     // url of the html page for test
            url             : '020_home_page_drag_n_drop.t.js'  // url of the js file, containing actual test code
        },
        ...
    )
         *
         *
         */
        pageUrl             : null,


        /**
         * @cfg {Boolean} useStrictMode When set to `false` the test scopes will be created w/o strict mode `DOCTYPE`. Default value is `true`.
         * This option is not applicable for tests with `pageUrl` option.
         *
         * This option can be also specified in the test file descriptor.
         */
        useStrictMode       : true,


        /**
         * @cfg {String} innerHtmlHead
         *
         * A string that will be placed into the `innerHTML` property of the &lt;head&gt; tag, before starting the preload process.
         * No validity checks will be performed.
         *
         * This option will not be inherited by the tests with {@link #pageUrl} option set, unless it is explicitly set to the
         * `inherit` value.
         *
         * This option can be specified in the test file descriptor.
         *
         * See also {@link #innerHtmlBody}
         */
        innerHtmlHead       : null,


        /**
         * @cfg {String} innerHtmlBody
         *
         * A string that will be placed into the `innerHTML` property of the &lt;body&gt; tag, before starting the preload process.
         * No validity checks will be performed.
         *
         * This option will not be inherited by the tests with {@link #pageUrl} option set, unless it is explicitly set to the
         * `inherit` value.
         *
         * This option can be specified in the test file descriptor.
         *
         * See also {@link #innerHtmlHead}
         */
        innerHtmlBody       : null,


        /**
         * @cfg {String} runCore Either `parallel` or `sequential`. Indicates how the individual tests should be run - several at once or one-by-one.
         *
         * Default value is "parallel", except for IE 6, 7, 8 where it's set to `sequential`.
         *
         * Set this option to `sequential` for tests, that uses some exclusive resources (like for example focus of the
         * text fields).
         *

    project.plan(
        'some_test.t.js',
        {
            url         : 'test_that_relies_on_focus.t.js',
            runCore     : 'sequential'
        }
    )

         *
         * This option can be also specified in the test file descriptor.
         */
        runCore                 : 'parallel',

        // a `runCore` value, "forced" for all tests, private, used for automation
        forcedRunCore           : null,

        /**
         * @cfg {String} simulateEventsWith
         *
         * This option is IE9-strict mode (and probably above) specific. It specifies how Siesta should simulate events.
         * The options are 'dispatchEvent' (W3C standard) or 'fireEvent' (MS interface) - both are available in IE9 strict mode
         * and each activates different set of event listeners. See this blog post for detailed explanations:
         * <http://www.digitalenginesoftware.com/blog/archives/76-DOM-Event-Model-Compatibility-or-Why-fireEvent-Doesnt-Trigger-addEventListener.html>
         *
         * Valid values are "dispatchEvent" and "fireEvent".
         *
         * The framework specific adapters (like {@link Siesta.Test.ExtJS} and like {@link Siesta.Test.jQuery}) choose the most appropriate value
         * automatically (unless explicitly configured).
         */
        simulateEventsWith  : {
            is      : 'rw',
            init    : 'dispatchEvent'
        },

        // the test with currently "forced" (by the "forceDOMVisible" option) iframe
        testOfForcedIFrame          : null,

        /**
         * @cfg {Boolean} autoScrollElementsIntoView
         *
         * With this option enabled Siesta will try to scroll invisible action targets into the view automatically, before performing an
         * action (such as click etc).
         *
         * This option can also be specified in the test file descriptor.
         */
        autoScrollElementsIntoView  : true,

        /**
         * @cfg {Boolean} enableUnreachableClickWarning When this option is set to `true` (default) Siesta will generate warnings
         * when click happens in the unreachable point of some element. For example, imagine the following situation: you have
         * a 10x10px "div" element with "overflow : hidden", and inside of it, another inner "div" 10x50px. Then you ask Siesta
         * to click on the inner div (by default it clicks in the center). The center of inner div is hidden by the outer div,
         * so click will happen on some other element and a warning will be issued.
         *
         * Usually this behaviour is what you want, since it protects you from various mistakes, but sometimes you may want
         * to disable it, for example if you want to write your clicks like this: `{ click : someEl, offset : [ "50%", "100%+10" ] }`
         * (which means - click 10px to the right from right edge of the `someEl`).
         *
         * Note, that warning won't be issued if in the click point there's some child element of the target element.
         *
         * This option can also be specified in the test file descriptor.
         */
        enableUnreachableClickWarning   : true,


        /**
         * @cfg {Boolean} maintainViewportSize
         *
         * Enabling this option will cause Siesta to honor the {@link #viewportWidth} and {@link #viewportHeight} configuration options.
         *
         * This option can also be specified in the test file descriptor.
         */
        maintainViewportSize        : true,

        /**
         * @cfg {Number} viewportWidth
         *
         * The width of the test iframe, default value is 1024
         */
        viewportWidth               : 1024,

        /**
         * @cfg {Number} viewportHeight
         *
         * The height of the test iframe, default value is 768
         */
        viewportHeight              : 768,


        /**
         * @cfg {Function} recorderClass A recorder class to use
         */
        recorderClass               : function () {
            // in the RootCause bundle recorder classes are missing
            return Siesta.Recorder && Siesta.Recorder.Recorder
        },

        /**
         * @cfg {Object} recorderConfig A custom config object used to configure the {@link Siesta.Recorder.Recorder} instance
         */
        recorderConfig              : null,

        /**
         * @cfg {Boolean} jasmine This option can only be specified in the {@link Siesta.Project#start test files descriptor}.
         * If its set to `true`, the `url` property of the descriptor should point to the Jasmine spec runner html page.
         * Siesta then will automatically import the results from the Jasmine suite.
         *
         * Additionally, one need to add a special reporter to the spec runner page, which is available
         * as `SIESTA_FOLDER/bin/jasmine-siesta-reporter.js`.
         *
         * Currently Siesta can import the results from Jasmine 2.0 and above.
         *
         * Typical setup will look like (see also `SIESTA_FOLDER/examples/1.unit-tests/jasmine_suite/SpecRunner.html` example):

    <head>
        ...
        <script src="lib/jasmine-2.2.0/jasmine.js"></script>
        <script src="lib/jasmine-2.2.0/jasmine-html.js"></script>
        <script src="lib/jasmine-2.2.0/boot.js"></script>

        <!-- Add Siesta reporter to your Jamsine spec runner (adjust the path) -->
        <script src="../../../bin/jasmine-siesta-reporter.js"></script>
        ....
    </head>
             * &nbsp;

    project.plan(
        // regular Siesta test
        '010_regular_test.t.js',

        // a Jasmine test suite
        {
            jasmine         : true,
            expectedGlobals : [ 'Player', 'Song' ],
            // url should point to the specs runner html page in this case
            url             : 'jasmine_suite/SpecRunner.html'
        }
    )

         */


        /**
         * @cfg {Boolean} needUI This option determines whether the Siesta UI should be rendered. By default, it is enabled
         * when running suite in the browser and disabled in automation launcher. You can explictly set it to `true`, to show the UI
         * even in automation mode:
         *

    project.configure({
        needUI      : true
    })

         */
        needUI                      : true,

        // will read the settings from cookies when started
        stateful                    : true,

        uiMask                      : null,
        uiMaskActive                : false,

        hostPageUrlStopsInheriting  : function () {
            return this.buildHostPageUrlStopsInheriting()
        },

        /**
         * @cfg {String} rerunHotKey The key to press together with CTRL to rerun the latest test
         */
        rerunHotKey                 : 'E',

        /**
         * @cfg {String} observerModeHotKey The key to press together with CTRL to toggle the "observer mode" on/off.
         * The "observer mode" is a combination of enabled {@link #forceDOMVisible} and {@link #runCore} `sequential`.
         */
        observerModeHotKey          : 'O',

        /**
         * @cfg {Boolean} restartOnBlur
         *
         * **Experimental**. When this option is enabled, Siesta will emit a warning when focus moves outside of the test window.
         * When running in automation mode Siesta will also restart the test.
         *
         * This option can also be specified in the test file descriptor.
         */
        restartOnBlur           : false,

        focusChecker            : {
            lazy        : function () {
                var el      = document.createElement('input')

                el.setAttribute('style', 'position : absolute; left : -1000px; top : -1000px')
                el.type     = 'text'

                document.body.appendChild(el)

                return el
            }
        },

        supportEcmaModules : function () {
            var script = document.createElement('script');

            return 'noModule' in script;
        }
    },


    after : {

        onBeforeScopePreload : function (scopeProvider, url) {
            if (this.viewport) this.viewport.onBeforeScopePreload(scopeProvider, url)
        },


        onTestSuiteStart : function (descriptors, contentManager, launchState) {
            if (this.viewport) this.viewport.onTestSuiteStart(descriptors, contentManager)
        },


        onTestSuiteEnd : function (descriptors, contentManager) {
            if (this.viewport) this.viewport.onTestSuiteEnd(descriptors, contentManager)

            // remove the links to forced iframe / test in hope to ease the memory pressure
            delete this.testOfForcedIFrame

            if (this.uiMaskActive) this.hideUiMask()
        },


        onTestStart : function (test) {
            if (this.viewport) this.viewport.onTestStart(test)

            if (test.hasForcedIframe()) {
                if (this.testOfForcedIFrame) this.hideForcedIFrame(this.testOfForcedIFrame)

                this.showForcedIFrame(test)

                this.testOfForcedIFrame     = test
            } else {
                if (this.uiMaskActive) this.hideUiMask()
            }
        },


        onTestUpdate : function (test, result, parentResult) {
            if (this.viewport) this.viewport.onTestUpdate(test, result, parentResult)

            if ((result instanceof Siesta.Result.Diagnostic) && result.isWarning && this.needUI) {
                if (typeof console != 'undefined' && console.warn) console.warn(result + '')
            }
        },


        onTestEnd : function (test) {
            if (test.hasForcedIframe())             this.hideForcedIFrame(test)

            if (test == this.testOfForcedIFrame)    this.testOfForcedIFrame = null

            if (this.viewport) this.viewport.onTestEnd(test)

            // when browser is simulating the event on the element that is not visible in the iframe
            // it will scroll that point into view, using the `scrollLeft` property of the parent element
            // this line fixes that displacement
            var wrapper     = test.scopeProvider && test.scopeProvider.wrapper

            if (wrapper) {
                wrapper.scrollLeft      = wrapper.scrollTop = 0
            }
            document.body.scrollLeft    = document.body.scrollTop = 0
        },


        onTestFail : function (test, exception, stack) {
            if (this.viewport) this.viewport.onTestFail(test, exception, stack)
        }
    },


    methods : {

        setObserverMode : function (value) {
            if (value) {
                this.forcedRunCore      = 'sequential'
            } else
                this.forcedRunCore      = null

            this.observerMode           = value
        },


        buildHostPageUrlStopsInheriting : function () {
            // the value for the key is a default value which is used when descriptor is "hidden" by `pageUrl`
            return {
                preload         : [],
                innerHtmlHead   : null,
                innerHtmlBody   : null
            }
        },


        buildConfigSynonyms : function () {
            return Joose.O.extend(this.SUPER(), {
                pageUrl             : 'hostPageUrl',
                enablePageRedirect  : 'separateContext'
            })
        },


        createViewport       : function(config) {
            return Ext.create(this.viewportClass, config);
        },


        configure : function() {
            this.SUPERARG(arguments);

            this.id = this.title || window.location.href;
        },


        start : function () {
            // Opera's global variables handling is weird
            if (bowser.opera) {
                this.autoCheckGlobals = false;
            }

            if (bowser.msie) {
                if (!this.hasOwnProperty('runCore')) this.runCore = 'sequential'
            }

            this.SUPERARG(arguments)
        },


        populateCleanScopeGlobals : function (scopeProvider, callback) {
            if (this.disableGlobalsCheck || bowser.msie && bowser.version < 9) {
                // do nothing for IE < 9 - testing leakage of globals is not supported
                // also IE8 often crashes on this stage
                this.disableGlobalsCheck = true

                callback()

                return
            }

            // always populate the globals from IFrame (even if user specified the Window provider)
            this.SUPER('Scope.Provider.IFrame', callback)
        },


        onUnload : function () {
            Joose.O.each(this.scopesByURL, function (scopeProvider, url) {
                // to close opened popups when project page unloads
                scopeProvider.cleanup()
            })
        },


        launch : function () {
            // init the singleton
            Siesta.Project.Browser.FeatureSupport();

            this.SUPERARG(arguments)
        },


        setup : function (callback) {
            var me      = this
            var SUPER   = this.SUPER

            window.onunload     = function () { me.onUnload() }

            // required to bring the window to front in FF
            // skip, when Siesta UI is enmbedded into iframe, to prevent
            // scrolling
            if (!window.parent) window.focus()

            if (this.title) document.title = this.title

            $(function () {
                var needUI          = me.hasOwnProperty('needUI') || !me.isAutomated ? me.needUI : false

                if (typeof Ext != 'undefined' && needUI) {
                    me.autoLaunchTests  = false

                    Ext.onReady(function () {
                        SUPER.call(me, function () {
                            var filter      = me.getQueryParam('filter')

                            me.viewport = me.createViewport({
                                filter          : filter ? decodeURIComponent(filter) : null,
                                autoLaunch      : me.getQueryParam('autolaunch'),

                                title           : me.title,
                                project         : me
                            })

                            callback && callback()
                        })
                    })
                } else {
                    SUPER.call(me, callback)
                }
            })
        },


        getDescriptorConfig : function (descriptor, configName, doNotLookAtRoot) {
            // for any "normal" config use regular parent implementation
            if (!(configName in this.hostPageUrlStopsInheriting)) return this.SUPERARG(arguments)

            var defaultValue        = this.hostPageUrlStopsInheriting[ configName ]

            var pageUrlConfigFound  = false
            var isInheriting        = false

            do {
                pageUrlConfigFound  = pageUrlConfigFound || this.descriptorHasOwnValueFor(descriptor, 'pageUrl')

                if (this.descriptorHasOwnValueFor(descriptor, configName)) {
                    var value       = this.getConfigValueFromDescriptor(descriptor, configName)

                    if (value == 'inherit')
                        isInheriting = true
                    else
                        return value
                }

                if (pageUrlConfigFound && !isInheriting) return defaultValue

                descriptor          = descriptor.parent

            } while (descriptor && descriptor != this)

            if (doNotLookAtRoot)
                return undefined
            else
                return this.getConfigValueFromDescriptor(this, configName)
        },


        normalizeScopeProvider : function (desc) {
            this.SUPERARG(arguments)

            if (this.getDescriptorConfig(desc, 'runInPopup')) desc.scopeProvider = 'Scope.Provider.Window'
        },


        getScopeProviderConfigFor : function (desc, launchId) {
            var me                          = this
            var config                      = this.SUPERARG(arguments)

            config.cleanupDelay             = 0
            config.name                     = desc.title || desc.url.replace(/(.*\/)?(.*)/, '$2')
            config.cls                      = 'tr-iframe'

            config.performWrap              = true

            var wrapper                     = document.createElement('div')

            wrapper.className               = 'tr-iframe-wrapper'
            wrapper.innerHTML               = "<div class='tr-close fa fa-close'>&nbsp;</div><div class='tr-iframe-wrapper-scroll-canvas'><div class='tr-iframe-wrapper-inner'></div></div>"

            wrapper.childNodes[ 0 ].onclick = function () {
                var test                    = me.getTestByURL(desc.url)

                if (test) {
                    me.hideForcedIFrame(test)

                    if (me.viewport) me.viewport.onManualCloseOfForcedIframe(test)
                } else {
                    this.parentElement.style.left   = '-10000px'
                    this.parentElement.style.top    = '-10000px'
                }
            }

            config.wrapper                  = wrapper
            config.iframeParentEl           = wrapper.childNodes[ 1 ].childNodes[ 0 ]

            config.sourceURL                = config.sourceURL || this.getDescriptorConfig(desc, 'pageUrl')
            config.minViewportSize          = config.minViewportSize || {
                width   : this.getDescriptorConfig(desc, 'viewportWidth'),
                height  : this.getDescriptorConfig(desc, 'viewportHeight')
            }

            config.innerHtmlHead            = this.getDescriptorConfig(desc, 'innerHtmlHead')
            config.innerHtmlBody            = this.getDescriptorConfig(desc, 'innerHtmlBody')

            config.failOnResourceLoadError  = this.getDescriptorConfig(desc, 'failOnResourceLoadError')
            config.failOnPromiseRejection   = this.getDescriptorConfig(desc, 'failOnPromiseRejection')

            if (!config.hasOwnProperty('useStrictMode')) config.useStrictMode = this.getDescriptorConfig(desc, 'useStrictMode')

            return config
        },


        getNewTestConfiguration : function (desc, scopeProvider, contentManager, launchState) {
            var me              = this
            var config          = this.SUPERARG(arguments)

            // the simulation-related configs are grouped in `simulatorConfig` attribute of the test
            config.simulatorConfig  = this.getSimulatorConfigForNewTest(desc)

            Joose.A.each([
                'forceDOMVisible',
                'autoScrollElementsIntoView',
                'restartOnBlur'
            ], function (name) {
                config[ name ]  = me.getDescriptorConfig(desc, name)
            })

            if (this.observerMode) config.forceDOMVisible = true

            config.browser      = config.bowser = bowser

            return config
        },


        getSimulatorConfigForNewTest : function (desc) {
            var me              = this

            var config          = {}

            if (this.hasOwnProperty('simulateEventsWith')) config.simulateEventsWith = this.simulateEventsWith

            Joose.A.each([
                'actionDelay',
                'afterActionDelay',
                'dragDelay',
                'pathBatchSize',
                'mouseDragPrecision',
                'mouseMovePrecision',
                // TODO this config is currently not supported in native events, though we could do that
                // for that we would need to split all click-like actions in 2 stages
                // - sync cursor (native)
                // - one more getNormalizedTopElementInfo with "skipWarning=false" (user agent layer)
                // - actual click (native)
                'enableUnreachableClickWarning'
            ], function (name) {
                var cfg = me.getDescriptorConfig(desc, name);

                if (cfg != null) {
                    config[ name ]  = me.getDescriptorConfig(desc, name)
                }
            })

            if (this.getDescriptorConfig(desc, 'turboMode')) {
                config.speedRun = false;

                Joose.O.extend(config, Siesta.Test.Simulator.speedPresets.turboMode)
            }
            else if (this.getDescriptorConfig(desc, 'speedRun')) {
                Joose.O.extend(config, Siesta.Test.Simulator.speedPresets.speedRun)
            }

            return config
        },


        testMustRunSequential : function (descriptor) {
            return this.getDescriptorConfig(descriptor, 'forceDOMVisible')
        },


        runCoreGeneral : function (descriptors, contentManager, launchState, callback) {
            var me          = this
            var sorted      = this.sortDescriptors(descriptors, this.forcedRunCore, false)

            me.runCoreSharedContext(sorted.sharedContextGroups, contentManager, launchState, function () {

                me.runCoreParallel(sorted.canRunParallel, contentManager, launchState, function () {

                    me.runCoreSequential(sorted.mustRunSequential, contentManager, launchState, callback)
                })
            })
        },


        runCoreSharedContext : function (sharedContextGroups, contentManager, launchState, callback) {
            var me                  = this

            var processDescriptor   = function (group, isFirst, scopeProvider, firstDesc, testHolder) {
                var descriptors     = group.items

                if (!descriptors.length || launchState.needToStop) { processGroup(sharedContextGroups); return }

                var desc            = descriptors.shift()

                // if there's a descriptor left after the shift do not cleanup the
                // scope provider at the end of the test (as its going to be re-used by the next test)
                var noCleanup       = descriptors.length > 0

                if (isFirst) {
                    // new context should be created for the 1st item in the group
                    me.processURL(desc, desc.index, contentManager, launchState, function (testHolder) {
                        processDescriptor(group, false, me.scopesByURL[ desc.url ], desc, testHolder)

                        // trying hard to cleanup and avoid memory leaks
                        testHolder  = null

                    }, noCleanup, group)
                } else {
                    // same context should be re-used
                    me.processUrlShared(desc, desc.index, contentManager, launchState, function () {
                        processDescriptor(group, false, scopeProvider, firstDesc, testHolder)
                    }, noCleanup, group, scopeProvider, firstDesc, testHolder)
                }
            }

            var processGroup        = function (sharedContextGroups) {
                if (!sharedContextGroups.length || launchState.needToStop) { callback(); return }

                var group           = sharedContextGroups.shift()

                processDescriptor(group, true)
            }

            processGroup(sharedContextGroups)
        },


        processUrlShared : function (
            desc, index, contentManager, launchState, callback, noCleanup, sharedSandboxState, scopeProvider, firstDesc, testHolder
        ) {
            var me      = this
            var url     = desc.url

            // If first test in group is missing - behavior is undefined
            if (desc.isMissing) {
                callback()

                return
            }

            // an array of errors occurred during preload phase
            var preloadErrors   = []

            var transparentEx   = this.getDescriptorConfig(desc, 'transparentEx')

            delete scopeProvider.scope.describe.called

            if (desc.testCode || this.cachePreload && contentManager.hasContentOf(desc.url))
                scopeProvider.runCode(desc.testCode || contentManager.getContentOf(desc.url), cont)
            else
                scopeProvider.runScript(this.resolveURL(desc.url, scopeProvider, desc), cont)

            function cont() {
                // scope provider has been cleaned up while setting up? (may be user has restarted the test)
                // then do nothing
                if (!scopeProvider.scope) { callback(); return }

                var testClass       = me.getDescriptorConfig(desc, 'testClass')
                if (me.typeOf(testClass) == 'String') testClass = Joose.S.strToClass(testClass)

                var testConfig      = me.getNewTestConfiguration(desc, scopeProvider, contentManager, launchState, sharedSandboxState)

                // testHolder here is a shared object between the whole group
                // create the test instance early, so that one can perform some setup (as the test class method call)
                // even before the "pageUrl" starts loading
                var test            = testHolder.test = new testClass(testConfig)

                test.earlySetup(function () {
                    cont2()
                }, function (errorMessage) {
                    preloadErrors.push({ isException : false, message : errorMessage })

                    cont2()
                })

                function cont2() {
                    me.launchTest({
                        testHolder          : testHolder,
                        desc                : desc,
                        scopeProvider       : scopeProvider,
                        contentManager      : contentManager,
                        launchState         : launchState,
                        preloadErrors       : preloadErrors,

                        startTestAnchor     : scopeProvider.scope.StartTest,
                        noCleanup           : noCleanup,
                        cleanupUrl          : firstDesc.url,
                        reusingSandbox      : true
                    }, callback)
                }
            }
        },


        normalizeURL : function (url) {
            // ref to JSAN module - DEPRECATED
            if (/^jsan:/.test(url)) url = '/jsan/' + url.replace(/^jsan:/, '').replace(/\./g, '/') + '.js'

            // ref to lib in current dist (no `/` and trailing `.js`) - DEPRECATED
            if (!/\.js$/.test(url) && !/\//.test(url) && !/\.css(\?.*)?$/i.test(url)) url = '../lib/' + url.replace(/\./g, '/') + '.js'

            return url
        },


        normalizeDescriptor : function (desc, parent, index, level) {
            var desc        = this.SUPERARG(arguments)

            if (!desc.group && desc.jasmine) {
                desc.pageUrl            = desc.url
                desc.testCode           = this.getJasmineTestCode()
                // preloads will not be inherited anyway because "pageUrl" option presents
                // but we explicitly remove them one more time
                desc.preload            = []
                desc.sandbox            = true
            }

            return desc
        },


        resolveURL : function (url, scopeProvider, desc) {
            // if the `scopeProvider` is provided and it has a sourceURL - then absolutize the preloads relative to that url
            if (scopeProvider && scopeProvider.sourceURL) url = this.absolutizeURL(url)

            if (this.disableCaching)
                // if there's a ?param string in url - append new param
                if (/\?./.test(url))
                    url += '&disableCaching=' + new Date().getTime()
                else
                    if (!/\?$/.test(url))
                        url += '?disableCaching=' + new Date().getTime()

            // otherwise assumed to be a raw filename, relative or absolute
            return url
        },


        absolutizeURL : function (url, baseUrl) {
            // if the url is already absolute - just return it (perhaps with some normalization - 2nd case)
            // the url starting with // is also valid absolute url
            if (/^((https?|file):)?\/\//.test(url))  return url
            if (/^\//.test(url))    return this.baseProtocol + '//' + this.baseHost + url

            baseUrl             = baseUrl || this.baseUrl

            // strip the potential query and filename from baseURL, leaving only the "directory" part
            baseUrl             = baseUrl.replace(/\?.*$/,'').replace(/\/[^/]*$/, '/')

            // first absolutize the base url relative the project page (which will be always global, so it won't recurse)
            var absBaseUrl      = this.absolutizeURL(baseUrl, this.baseUrl)

            // add a trailing "/" if missing
            absBaseUrl          = absBaseUrl.replace(/\/?$/, '/')

            return absBaseUrl + url
        },


        getUiMask : function () {
            if (this.uiMask) return this.uiMask

            var uiMask              = this.uiMask = document.createElement('div')

            uiMask.className        = 'tr-ui-mask'
            uiMask.style.display    = 'none'

            document.body.appendChild(uiMask)

            return uiMask
        },


        showUiMask  : function () {
            var mask            = this.getUiMask()

            mask.style.display  = 'block'

            this.uiMaskActive   = true
        },


        hideUiMask  : function () {
            var mask            = this.getUiMask()

            mask.style.display  = 'none'

            this.uiMaskActive   = false
        },


        showForcedIFrame : function (test) {
            $.rebindWindowContext(window);

            test.isDOMForced    = true

            var wrapper         = test.scopeProvider.wrapper

            $(wrapper).addClass('tr-iframe-forced')
            $(wrapper).removeClass('tr-iframe-hidden')

            $(wrapper).center()

            // round left/top offset of the forced iframe window - this is to avoid weird fractional offsets
            // in event coordinates
            wrapper.style.top   = this.roundNumericStyleValue(wrapper.style.top)
            wrapper.style.left  = this.roundNumericStyleValue(wrapper.style.left)

            test.fireEvent('testframeshow')

            var rect            = wrapper.getBoundingClientRect()

            // a dummy call to `elementFromPoint`, to force the rendering engine to actually render the
            // centered iframe (perhaps the `getBoundingRect` is enought, this is extra caution
            // otherwise, when using native simulation, it seems the frame is centered (via styles update)
            // but actually not rendered at that position (browser waits for animation frame or whatever)
            // so native simulation starts, w/o actual frame in place
            document.elementFromPoint(rect.left, rect.top)
        },


        roundNumericStyleValue : function (styleStr) {
            var match           = /(.*?)([^\d\.-]*)$/.exec(styleStr)

            var rounded         = Math.round(Number(match[ 1 ]))

            return String(rounded) + match[ 2 ]
        },


        hideForcedIFrame : function (test) {
            $.rebindWindowContext(window);

            // once hidden, forced iframe will be never be shown again as "forced", only as "normal"
            test.isDOMForced        = false
            test.forceDOMVisible    = false

            var wrapper         = test.scopeProvider.wrapper

            $(wrapper).removeClass('tr-iframe-forced')
            $(wrapper).addClass('tr-iframe-hidden')

            test.fireEvent('testframehide')
        },


        showForcedIFrameScreenshot : function (test) {
            this.showUiMask()

            $.rebindWindowContext(window);

            var wrapper         = test.scopeProvider.wrapper

            $(wrapper).addClass('tr-iframe-forced-screenshot')
            $(wrapper).removeClass('tr-iframe-forced')
            $(wrapper).removeClass('tr-iframe-hidden')
        },


        hideForcedIFrameScreenshot : function (test) {
            this.hideUiMask()

            $.rebindWindowContext(window);

            var wrapper         = test.scopeProvider.wrapper

            $(wrapper).removeClass('tr-iframe-forced-screenshot')

            if (test.isDOMForced) {
                $(wrapper).addClass('tr-iframe-forced')
                $(wrapper).center()
            }
        },


        stopCurrentLaunch : function (sourceTest) {
            if (this.SUPER(sourceTest) === true) {
                if (this.viewport) this.viewport.onTestSuiteStop(sourceTest)

                return true
            }
        },


        /**
         * @param {String} paramName
         *
         * Returns a query string parameter with name `paramName` (`http://domain.com/index.html?paramName=paramValue`)
         *
         * @return {String}
         */
        getQueryParam : function (paramName) {
            return this.my.getQueryParam(paramName, true)
        },


        getJasmineTestCode : function () {
            return ';(' + (function () {

                StartTest(function (t) {
                    t.expectGlobals(
                        'getJasmineRequireObj', 'jasmineRequire', 'jasmine', 'xdescribe', 'describe', 'xdescribe', 'fdescribe',
                        'it', 'xit', 'fit', 'spyOn', 'fail', 'jsApiReporter', 'beforeEach', 'afterEach', 'beforeAll', 'afterAll',
                        'expect', 'pending'
                    )

                    if (!window.jasmine) {
                        t.fail(t.resource('Siesta.Project.Browser', 'noJasmine'))

                        return
                    }

                    if (!jasmine.SiestaReporter) {
                        t.fail(t.resource('Siesta.Project.Browser', 'noJasmineSiestaReporter'))

                        return
                    }

                    jasmine.SiestaReporter.importResults(t)
                })

            }).toString() + ')();'
        },


        /**
         * This methos returns `true` if this project is being run on the
         * [Standard package](https://www.bryntum.com/products/siesta/) of Siesta, `false` otherwise.
         *
         * @return {Boolean}
         */
        isStandardPackage : function () {
            return this.my.isStandardPackage(true)
        },


        // should only be used when no tests are running
        // does not work for IE
        // Safari webdriver has known problem of starting browser in the background, w/o focus
        browserWindowHasFocus : function () {
            window.focus()

            var el      = this.getFocusChecker()

            el.focus({preventScroll : true})

            $.rebindWindowContext(window);

            return $(el).is(':focus')
        },


        /**
         * This method returns a test instance of the currently selected test in the UI.
         *
         * You can use this instance to call usual test methods, like:
         *

    project.getSelectedTest().click("#some-el")

         *
         * Note, that test instance might be already cleaned up, so DOM interaction methods might not be functional.
         * This cleanup behavior is controlled by the {@link #keepNLastResults} option.
         *
         * For convenience, the result of this method is duplicated as simple `T` global variable:
         *

    T.click("#some-el")

         *
         * @return {Siesta.Test} Currently selected test in the UI
         */
        getSelectedTest : function () {
            var selected    = this.viewport.slots.filesTree.getSelectionModel().getSelection()[ 0 ]

            if (selected) {
                return this.getTestByURL(selected.get('url'))
            }
        }
    },


    my : {

        methods : {

            isStandardPackage : function (calledFromInstance) {
                if (!calledFromInstance) this.staticDeprecationWarning('isStandardPackage')

                return Boolean(Siesta.Project.Browser.Automation)
            },


            getQueryParam : function (paramName, calledFromInstance) {
                if (!calledFromInstance) this.staticDeprecationWarning('getQueryParam')

                var regex       = new RegExp('(?:\\?|&)' + paramName + '=(.*?)(?:\\?|&|$)', 'i')

                var match       = regex.exec(window.location.search)

                if (!match) return null

                return match[ 1 ]
            }
        }
    }
})
//eof Siesta.Project.Browser

// backward compat
Class('Siesta.Harness.Browser', { isa : Siesta.Project.Browser })
;
Singleton('Siesta.Project.Browser.FeatureSupport', {

    does : [
        Siesta.Util.Role.CanCalculatePageScroll
    ],

    has     : {
        isConfigured        : false,

        supports    : Joose.I.Object,

        simulator   : {
            lazy        : 'this.buildWebSimulator'
        },

        tests       : {
            init        : [
                {
                    id  : 'TouchEvents',
                    fn  : function() {
                        return this.isEventSupported('touchend', window);
                    }
                },
                {
                    id  : 'PointerEvents',
                    fn  : function () {
                        return Boolean(window.PointerEvent)
                    }
                },
                {
                    id  : 'MSPointerEvents',
                    fn  : function() {
                        return Boolean(window.MSPointerEvent)
                    }
                },
                {
                    id  : 'PointerEventsGeneric',
                    fn  : function () {
                        return Boolean(window.PointerEvent || window.MSPointerEvent)
                    }
                },
                // "fn"s are called as methods of the "Siesta.Project.Browser.FeatureSupport" singleton
                {
                    id : "mouseEnterLeave",
                    fn : function() {
                        var el = document.createElement("div");
                        return 'onmouseenter' in el && 'onmouseleave' in el;
                    }
                },

                {
                    id : "enterOnAnchorTriggersClick",
                    fn : function() {
                        var sim     = this.getSimulator(),
                            E       = Siesta.Test.UserAgent.KeyCodes().keys.ENTER,
                            result  = false;

                        var anchor = $('<a href="foo" style="display:none">test me</a>');
                        $('body').append(anchor);

                        anchor.focus({ preventScroll : true });
                        anchor.click(function(e) {
                            result = true;
                            return false;
                        });

                        sim.simulateEvent(anchor, 'keypress', { keyCode : E, charCode : 0 });

                        anchor.remove();
                        return result;
                    }
                },

                {
                    id : "canSimulateKeyCharacters",
                    fn : function() {
                        var sim     = this.getSimulator();

                        var input   = $('<input class="siesta-hidden" type="text" />'),
                            A       = Siesta.Test.UserAgent.KeyCodes().keys.A;

                        $('body').append(input);

                        input.focus({ preventScroll : true });
                        sim.simulateEvent(input, 'keypress', { keyCode : A, charCode : A });
                        sim.simulateEvent(input, 'textInput', { text : "A" });

                        var result  = input.val() === 'A';

                        input.remove();

                        return result;
                    }
                },

                {
                    id : "canSimulateBackspace",
                    fn : function() {
                        var sim     = this.getSimulator();

                        var input   = $('<input class="siesta-hidden" type="text" />'),
                            BS      = Siesta.Test.UserAgent.KeyCodes().keys.BACKSPACE,
                            A       = Siesta.Test.UserAgent.KeyCodes().keys.A;

                        $('body').append(input);

                        input.focus({ preventScroll : true });
                        sim.simulateEvent(input, 'keypress', { keyCode : A, charCode : A });
                        sim.simulateEvent(input, 'keypress', { keyCode : A, charCode : A });
                        sim.simulateEvent(input, 'keypress', { keyCode : BS, charCode : BS });

                        var result  = input.val() === 'A';

                        input.remove();

                        return result;
                    }
                },

                {
                    id : "enterSubmitsForm",
                    fn : function() {
                        var sim     = this.getSimulator(),
                            E       = Siesta.Test.UserAgent.KeyCodes().keys.ENTER,
                            result  = false;

                        var form = $('<form method="post"><input type="text"/></form>');
                        var input = $(form).find('input');
                        $('body').append(form);

                        form[0].onsubmit = function(e) {
                            result = true;
                            return false;
                        };

                        input.focus({ preventScroll : true });
                        sim.simulateEvent(input, 'keypress', { keyCode : E, charCode : 0 });

                        form.remove();
                        return result;
                    }
                },
                // remove after https://bugzilla.mozilla.org/show_bug.cgi?id=959992 will be fixed
                {
                    id : "imageWithIdCreatesGlobalEnumerable",
                    fn : function () {
                        var img     = $('<img id="test_img_id"/>');

                        $('body').append(img);

                        var hasImgId    = false

                        for (var i in window) {
                            if (i == 'test_img_id') hasImgId = true
                        }

                        img.remove();

                        return hasImgId;
                    }
                },

                // Safari triggers native 'change' event when an INPUT is blurred
                {
                    id : "inputFiresChangeAfterLosingFocus",
                    fn : function() {
                        var sim     = this.getSimulator();
                        var input   = document.createElement('input'),
                            result  = false,
                            A       = Siesta.Test.UserAgent.KeyCodes().keys.A;

                        input.className = "siesta-hidden";

                        document.body.appendChild(input);

                        input.addEventListener('change', function (ev) {
                            result = ev.isTrusted;
                        });

                        input.focus({ preventScroll : true });

                        sim.simulateEvent(input, 'keydown', { keyCode : A, charCode : A });
                        sim.simulateEvent(input, 'keypress', { keyCode : A, charCode : A });
                        sim.simulateEvent(input, 'keyup', { keyCode : A, charCode : A });
                        sim.simulateEvent(input, 'textInput', { text : "A" });

                        input.blur();

                        document.body.removeChild(input);

                        return result;
                    }
                }
            ]
        }

    },

    methods     : {

        buildWebSimulator : function () {
            return new Siesta.Test.Simulator({
                global  : window,
                test    : {
                    normalizeElement    : function(a) { return a[ 0 ] || a; }
                }
            });
        },


        configure : function() {
            // Already configured
            if (this.isConfigured) return

            this.isConfigured       = true

            this.maintainScrollPositionDuring(function () {
                for (var i = 0; i < this.tests.length; i++) {
                    var test            = this.tests[i];
                    var testId          = test.id;
                    var detectorFn      = test.fn;

                    try {
                        // also save the results to "results" property - we'll use this in our own test suite
                        // where we copy the feature testing results from the outer scope to inner
                        this.supports[ testId ] = detectorFn.call(this);
                    } catch (e) {
                        this.supports[ testId ] = false
                    }
                }
            })
        },


        // from Modernizr
        isEventSupported: function (eventName, element) {
            var isSupported;

            if (!eventName) return false
            if (!element || typeof element === 'string') element = document.createElement(element || 'div');

            // Testing via the `in` operator is sufficient for modern browsers and IE.
            // When using `setAttribute`, IE skips "unload", WebKit skips "unload" and
            // "resize", whereas `in` "catches" those.
            eventName       = 'on' + eventName;
            isSupported     = eventName in element;

            // Fallback technique for old Firefox - bit.ly/event-detection
            if (!isSupported) {
                if (!element.setAttribute) {
                    // Switch to generic element if it lacks `setAttribute`.
                    // It could be the `document`, `window`, or something else.
                    element = document.createElement('div');
                }

                element.setAttribute(eventName, '');
                isSupported = typeof element[ eventName ] === 'function';

                if (element[ eventName ] !== undefined ) {
                    // If property was created, "remove it" by setting value to `undefined`.
                    element[ eventName ] = undefined;
                }
                element.removeAttribute(eventName);
            }

            return isSupported;
        }

    }
})
;
/**
@class Siesta.Project.Browser.ExtJSCore

This is a role (mixin), representing the shared functionality between Ext JS and SenchaTouch projects.

*/
Role('Siesta.Project.Browser.ExtJSCore', {

    has : {
        /**
         * @cfg {Object} loaderPath
         *
         * The path used to configure the Ext.Loader 'paths' config to resolve JS namespaces to file paths, for dynamic loading of Ext JS classes.
         * For more information, please see the Ext docs: http://docs.sencha.com/extjs/apidocs/#!/api/Ext.Loader-cfg-paths
         *
         * See also {@link #requires}.
         *
         * By default the value will be set right before the test starts. If you need to set it earlier (during preloading phase),
         * use {@link #getLoaderPathHook} method.
         *
         * This option can be also specified in the test file descriptor.
         *
         * **Note**, that the value of this config will not be inherited from the parent tests group, if test has {@link Siesta.Project.Browser#pageUrl} option set.
         */
        loaderPath              : null,

        /**
         * @cfg {Array[String]} requires
         *
         * The array of class names, to be dynamically loaded with `Ext.require` call, before the test starts. Naturally, requires
         * the correct value for the {@link #loaderPath} to be set.
         *
         * This option can be also specified in the test file descriptor.
         */
        requires                : null,

        /**
         * @cfg {Boolean} waitForExtComponentQueryReady
         *
         * Setting this configuration option to "true" will cause Siesta to wait until the `Ext.ComponentQuery` class is loaded on the page,
         * before starting the test.
         *
         * This option can (and probably should) be also specified in the test file descriptor.
         */
        waitForExtComponentQueryReady       : true,


        // Set to true to fail t.knownBugInStatements, useful when running against Ext JS nightly builds
        failKnownBugIn          : false,

        recorderClass               : function () {
            return Siesta.Recorder.ExtJS
        }
    },


    override : {

        getNewTestConfiguration : function (desc, scopeProvider, contentManager, launchState) {
            var config              = this.SUPERARG(arguments)

            config.loaderPath       = this.getDescriptorConfig(desc, 'loaderPath')
            config.requires         = this.getDescriptorConfig(desc, 'requires')

            config.waitForExtComponentQueryReady = this.getDescriptorConfig(desc, 'waitForExtComponentQueryReady')

            return config
        },


        buildSandboxHashStructure : function () {
            var structure           = this.SUPERARG(arguments)

            structure.push('loaderPath', 'requires')

            return structure
        },


        buildHostPageUrlStopsInheriting : function () {
            var res         = this.SUPER()

            res.loaderPath  = true

            return res
        }
    },


    methods : {

        createViewport       : function(config) {
           return Ext.create("Siesta.Project.Browser.UI.Viewport", config);
        },


        generateLoaderPathHook : function () {
            // Such tedious check to allow setting the paths without crash for Ext JS versions < 4
            // (which may have own "Ext.Loader" object)
            return function (StartTest, Ext, loaderPath) {
                if (!loaderPath || StartTest.loaderPathHookInstalled || !Ext || !Ext.Loader || !Ext.Loader.setPath) return

                StartTest.loaderPathHookInstalled   = true

                Ext.Loader.setPath(loaderPath)
            }
        },


        /**
         * Returns a string presentation of the ExtJS/SenchaTouch hook for setting "Ext.Loader" paths,
         * suitable to be used in the test's {@link Siesta.Project#preload preloads}.
         * This will allow you to install the hook at the earliest possible point,
         * right after preloading Ext and before "requiring" any classes.
         *
         * The value for the paths should be provided in the {@link #loaderPath} config.
         * The inheritance of the value from groups is supported as usually, except the tests with
         * {@link Siesta.Project.Browser#pageUrl} option set.
         *
         * Typical usage will be:
         *

    var project = new Siesta.Project.Browser.ExtJS();

    project.configure({
        loaderPath              : { 'My' : 'js', 'My.Namespace' : 'js/somepath' },

        preload                 : [
            'http://cdn.sencha.io/ext-4.2.0-gpl/ext-all.js',
            {
                // inject the loader paths right after ExtJS and before the application file
                text    : project.getLoaderPathHook()
            },
            'app.js'
        ]
    });

         *
         * @return {String}
         */
        getLoaderPathHook : function () {
            var hook     = function (installationHook) {
                var parentWindow        = window.opener || window.parent
                var project             = parentWindow.Siesta.my.activeHarness

                eval('(' + installationHook + ')')(StartTest, Ext, project.getDescriptorConfig(project.getScriptDescriptor(StartTest.id), "loaderPath"))
            }

            return ';(' + hook.toString() + ')(' + JSON.stringify(this.generateLoaderPathHook().toString()) + ')'
        }
    }
});
/**
@class Siesta.Project.Browser.ExtJS
@extends Siesta.Project.Browser
@mixin Siesta.Project.Browser.ExtJSCore

Class, representing the browser project. This class provides a web-based UI and defines some additional configuration options.

The default value of the `testClass` configuration option in this class is {@link Siesta.Test.ExtJS}, which inherits from
{@link Siesta.Test.Browser} and contains various ExtJS-specific assertions. So, use this project class, when testing an ExtJS application.

This file is for reference only, for a getting start guide and manual, please refer to <a href="#!/guide/getting_started_browser">Siesta getting started in browser environment</a> guide.

Synopsys
========

    var project = new Siesta.Project.Browser.ExtJS();

    project.configure({
        title     : 'Awesome ExtJS Application Test Suite',

        transparentEx       : true,

        autoCheckGlobals    : true,
        expectedGlobals     : [
            'Ext',
            'Sch'
        ],

        preload : [
            "http://cdn.sencha.io/ext-4.0.2a/ext-all-debug.js",
            "../awesome-project-all.js",
            {
                text    : "console.log('preload completed')"
            }
        ]
    })


    project.plan(
        // simple string - url relative to project file
        'sanity.t.js',

        // test file descriptor with own configuration options
        {
            url     : 'basic.t.js',

            // replace `preload` option of project
            preload : [
                "http://cdn.sencha.io/ext-4.0.6/ext-all-debug.js",
                "../awesome-project-all.js"
            ]
        },

        // groups ("folders") of test files (possibly with own options)
        {
            group       : 'Sanity',

            autoCheckGlobals    : false,

            items       : [
                'data/crud.t.js',
                ...
            ]
        },
        ...
    )


*/

Class('Siesta.Project.Browser.ExtJS', {

    isa     : Siesta.Project.Browser,

    does    : [
        Siesta.Project.Browser.ExtJSCore
    ],

    has     : {
        /**
         * @cfg {Class} testClass The test class which will be used for creating test instances, defaults to {@link Siesta.Test.ExtJS}.
         * You can subclass {@link Siesta.Test.ExtJS} and provide a new class.
         *
         * This option can be also specified in the test file descriptor.
         */
        testClass               : Siesta.Test.ExtJS,

        /**
         * @cfg {Boolean} waitForExtReady
         *
         * By default the `StartTest` function will be executed after `Ext.onReady`. Set to `false` to launch `StartTest` immediately.
         *
         * This option can be also specified in the test file descriptor.
         */
        waitForExtReady         : true,

        /**
         * @cfg {Boolean} waitForAppReady
         *
         * Setting this configuration option to "true" will cause Siesta to wait until the ExtJS MVC application on the test page will become ready,
         * before starting the test. More precisely, it will wait till the "launched" property of the application, specified
         * in the `Ext.manifest.name` to be `true`.
         *
         * This option can (and probably should) be also specified in the test file descriptor.
         */
        waitForAppReady         : false,


        extVersion              : null,

        /**
         * @cfg {Boolean} failOnMultipleComponentMatches
         *
         * True to fail when providing a Component Query matching multiple components. False to warn only.
         * Component Queries should ideally always be unique to identify only one target in the DOM.
         */
        failOnMultipleComponentMatches   : false,

        extVersionRegExp        : /ext(?:js)?-(\d\.\d+\.\d+.*?)\//,

        contentManagerClass     : Siesta.Content.Manager.Browser.ExtJSCore,

        // Required by Ext JS 6
        innerHtmlHead           : '<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">'
    },


    methods : {

        setup : function (callback) {
            var me      = this

            /*
                This is to be able to pass "next" function form the chain step to the Ext as callback:
                    function (next) {
                        resourceStore.reload({
                            callback : next
                        })
                    }
                For some reason, Ext performs "isFunction" check on the callback value and only calls it if this check passes
                (assuming programmer does not know what he is doing)
                "isFunction" check in turn relies on the presence of this property in the Function prototype

                This line can be removed once "isFunction" in Ext will become cross-context or Ext will stop
                using "isFunction" check for callbacks
            */
            Function.prototype.$extIsFunction = true;

            this.SUPER(function () {
                callback()
            })
        },


        getNewTestConfiguration : function (desc, scopeProvider, contentManager, launchState) {
            var config          = this.SUPERARG(arguments)

            config.waitForExtReady  = this.getDescriptorConfig(desc, 'waitForExtReady')
            config.waitForAppReady  = this.getDescriptorConfig(desc, 'waitForAppReady')

            return config
        },


        findExtVersion : function () {
            var me      = this

            var found

            this.mainPreset.eachResource(function (resource) {
                var match   = me.extVersionRegExp.exec(resource.url)

                if (match) {
                    found   = match[ 1 ]

                    return false
                }
            })

            return found
        }
    }
})


// backward compat
Class('Siesta.Harness.Browser.ExtJS', { isa : Siesta.Project.Browser.ExtJS });
/**
@class Siesta.Project.Browser.SenchaTouch
@extends Siesta.Project.Browser
@mixin Siesta.Project.Browser.ExtJSCore

A Class representing the browser project. This class provides a web-based UI and defines some additional configuration options.

The default value of the `testClass` configuration option in this class is {@link Siesta.Test.SenchaTouch}, which inherits from
{@link Siesta.Test.Browser} and contains various Sencha Touch-specific assertions. Use this project class when testing Sencha Touch applications.

* **Note** Make sure, you've checked the {@link #performSetup} configuration option.

This file is for reference only, for a getting start guide and manual, please refer to <a href="#!/guide/getting_started_browser">Siesta getting started in browser environment</a> guide.

Synopsys
========

    var project = new Siesta.Project.Browser.SenchaTouch();

    project.configure({
        title           : 'Awesome Sencha Touch Application Test Suite',

        transparentEx   : true,

        preload         : [
            "http://cdn.sencha.io/ext-4.0.2a/ext-all-debug.js",
            "../awesome-project-all.js"
        ]
    })


    project.plan(
        // simple string - url relative to project file
        'sanity.t.js',

        // test file descriptor with own configuration options
        {
            url     : 'basic.t.js',

            // replace `preload` option of project
            preload : [
                "http://cdn.sencha.io/ext-4.0.6/ext-all-debug.js",
                "../awesome-project-all.js"
            ]
        },

        // groups ("folders") of test files (possibly with own options)
        {
            group       : 'Sanity',

            autoCheckGlobals    : false,

            items       : [
                'data/crud.t.js',
                ...
            ]
        },
        ...
    )


*/

Class('Siesta.Project.Browser.SenchaTouch', {

    isa: Siesta.Project.Browser,

    does    : [
        Siesta.Project.Browser.ExtJSCore
    ],

    has     : {
        /**
        * @cfg {Class} testClass The test class which will be used for creating test instances, defaults to {@link Siesta.Test.SenchaTouch}.
        * You can subclass {@link Siesta.Test.SenchaTouch} and provide a new class.
        *
        * This option can be also specified in the test file descriptor.
        */
        testClass           : Siesta.Test.SenchaTouch,

        /**
         * @cfg {Boolean} transparentEx
         */
        transparentEx       : true,
        keepNLastResults    : 0,

        /**
         * @cfg {Boolean} performSetup When set to `true`, Siesta will perform a `Ext.setup()` call, so you can safely assume there's a viewport for example.
         * If, however your test code, performs `Ext.setup()` itself, you need to disable this option.
         *
         * If this option is not explicitly specified in the test descritor, but instead inherited, it will be automatically disabled if test has {@link #pageUrl} value.
         *
         * This option can be also specified in the test file descriptor.
         */
        performSetup        : true,

        forcedRunCore       : 'sequential',

        isRunningOnMobile   : true,

        contentManagerClass : Siesta.Content.Manager.Browser.ExtJSCore
    },


    methods: {

        setup : function () {
            // TODO fix proper mobile detection, since Ext may be absent in "no-ui" project
            this.isRunningOnMobile = typeof Ext !== 'undefined' && Ext.getVersion && Ext.getVersion('touch')

            if (!this.isRunningOnMobile) this.keepNLastResults = 2

            this.SUPERARG(arguments)
        },


        getNewTestConfiguration: function (desc, scopeProvider, contentManager, launchState) {
            var config      = this.SUPERARG(arguments)
            var pageUrl     = this.getDescriptorConfig(desc, 'pageUrl');

            if (!desc.hasOwnProperty('performSetup') && pageUrl) {
                config.performSetup = false;
            } else {
                config.performSetup = this.getDescriptorConfig(desc, 'performSetup')
            }

            return config
        }
    }
})


// backward compat
Class('Siesta.Harness.Browser.SenchaTouch', { isa : Siesta.Project.Browser.SenchaTouch });
// Internal class visualizing the cursor position, only used in good browsers (!== IE)
Class('Siesta.Project.Browser.UI.MouseVisualizer', {

    has : {
        cursorEl                    : null,

        currentContainer            : { required : true },

        clickEvents     : function () {
            return {
                click       : null,
                touchend    : null,
                contextmenu : null
            }
        },

        mouseDownEvents : function () {
            return {
                touchstart  : null,
                mousedown   : null
            }
        },

        mouseUpEvents : function () {
            return {
                touchend    : null,
                mouseup     : null
            }
        }
    },

    methods : {

        initialize : function (config) {
            this.onEventSimulated = this.onEventSimulated.bind(this);
        },


        getCursorEl : function () {
            if (this.cursorEl) return this.cursorEl

            var currentContainer = this.currentContainer
            if (!currentContainer) throw "Need container for cursor"

            var el          = document.createElement('div');

            el.className    = 'ghost-cursor fa fa-mouse-pointer';

            return this.cursorEl = currentContainer.appendChild(el)
        },


        destroy : function () {
            var cursorEl            = this.cursorEl

            if (cursorEl) {
                cursorEl.parentElement.removeChild(cursorEl);

                this.cursorEl       = null
            }

            this.currentContainer   = null
        },


        onEventSimulated : function (event, point) {
            if (typeof event.clientX === 'number') {
                this.updatePointer(event.type, point)
            }
        },


        updatePointer : function (eventType, point) {
            var x       = point[ 0 ],
                y       = point[ 1 ]

            this.updateGhostCursor(x, y);

            if (eventType in this.clickEvents) {
                this.showClickIndicator(eventType, x, y);
            } else if (eventType in this.mouseDownEvents) {
                this.getCursorEl().classList.add('ghost-cursor-press');
            }

            if (eventType in this.mouseUpEvents || eventType in this.clickEvents) {
                this.getCursorEl().classList.remove('ghost-cursor-press');
            }
        },


        // This method shows a fading growing circle at the xy position
        showClickIndicator : function (type, x, y) {
            var clickEl = document.createElement('div');

            clickEl.className = 'ghost-cursor-click-indicator ';
            clickEl.style.setProperty('left', x + 'px');
            clickEl.style.setProperty('top', y + 'px');

            clickEl.addEventListener("animationend", this.afterAnimation);
            clickEl.addEventListener("webkitAnimationEnd", this.afterAnimation);

            this.currentContainer.appendChild(clickEl);
        },


        afterAnimation : function() {
            // "this" here is a DOM element instance
            this.parentElement && this.parentElement.removeChild(this);
        },


        // Updates the ghost cursor position and appearance
        updateGhostCursor : function (x, y) {
            var cursorEl        = this.getCursorEl()

            var translateStyle  = bowser.opera ?
                'translate(' + x + 'px,' + y + 'px)'
            :
                'translate3d(' + x + 'px, ' + y + 'px, 0)'

            cursorEl.style.setProperty('-webkit-transform', translateStyle)
            cursorEl.style.setProperty('transform', translateStyle)
        }
    }
});
;
if (typeof module != "undefined") module.exports = Siesta;
;
/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
eval(function(p,a,c,k,e,d){e=function(c){return(c<a?'':e(parseInt(c/a)))+((c=c%a)>35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--){d[e(c)]=k[c]||e(c)}k=[function(e){return d[e]}];e=function(){return'\\w+'};c=1};while(c--){if(k[c]){p=p.replace(new RegExp('\\b'+e(c)+'\\b','g'),k[c])}}return p}('K M;I(M)1S 2U("2a\'t 4k M 4K 2g 3l 4G 4H");(6(){6 r(f,e){I(!M.1R(f))1S 3m("3s 15 4R");K a=f.1w;f=M(f.1m,t(f)+(e||""));I(a)f.1w={1m:a.1m,19:a.19?a.19.1a(0):N};H f}6 t(f){H(f.1J?"g":"")+(f.4s?"i":"")+(f.4p?"m":"")+(f.4v?"x":"")+(f.3n?"y":"")}6 B(f,e,a,b){K c=u.L,d,h,g;v=R;5K{O(;c--;){g=u[c];I(a&g.3r&&(!g.2p||g.2p.W(b))){g.2q.12=e;I((h=g.2q.X(f))&&h.P===e){d={3k:g.2b.W(b,h,a),1C:h};1N}}}}5v(i){1S i}5q{v=11}H d}6 p(f,e,a){I(3b.Z.1i)H f.1i(e,a);O(a=a||0;a<f.L;a++)I(f[a]===e)H a;H-1}M=6(f,e){K a=[],b=M.1B,c=0,d,h;I(M.1R(f)){I(e!==1d)1S 3m("2a\'t 5r 5I 5F 5B 5C 15 5E 5p");H r(f)}I(v)1S 2U("2a\'t W 3l M 59 5m 5g 5x 5i");e=e||"";O(d={2N:11,19:[],2K:6(g){H e.1i(g)>-1},3d:6(g){e+=g}};c<f.L;)I(h=B(f,c,b,d)){a.U(h.3k);c+=h.1C[0].L||1}Y I(h=n.X.W(z[b],f.1a(c))){a.U(h[0]);c+=h[0].L}Y{h=f.3a(c);I(h==="[")b=M.2I;Y I(h==="]")b=M.1B;a.U(h);c++}a=15(a.1K(""),n.Q.W(e,w,""));a.1w={1m:f,19:d.2N?d.19:N};H a};M.3v="1.5.0";M.2I=1;M.1B=2;K C=/\\$(?:(\\d\\d?|[$&`\'])|{([$\\w]+)})/g,w=/[^5h]+|([\\s\\S])(?=[\\s\\S]*\\1)/g,A=/^(?:[?*+]|{\\d+(?:,\\d*)?})\\??/,v=11,u=[],n={X:15.Z.X,1A:15.Z.1A,1C:1r.Z.1C,Q:1r.Z.Q,1e:1r.Z.1e},x=n.X.W(/()??/,"")[1]===1d,D=6(){K f=/^/g;n.1A.W(f,"");H!f.12}(),y=6(){K f=/x/g;n.Q.W("x",f,"");H!f.12}(),E=15.Z.3n!==1d,z={};z[M.2I]=/^(?:\\\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\\29-26-f]{2}|u[\\29-26-f]{4}|c[A-3o-z]|[\\s\\S]))/;z[M.1B]=/^(?:\\\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\\d*|x[\\29-26-f]{2}|u[\\29-26-f]{4}|c[A-3o-z]|[\\s\\S])|\\(\\?[:=!]|[?*+]\\?|{\\d+(?:,\\d*)?}\\??)/;M.1h=6(f,e,a,b){u.U({2q:r(f,"g"+(E?"y":"")),2b:e,3r:a||M.1B,2p:b||N})};M.2n=6(f,e){K a=f+"/"+(e||"");H M.2n[a]||(M.2n[a]=M(f,e))};M.3c=6(f){H r(f,"g")};M.5l=6(f){H f.Q(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g,"\\\\$&")};M.5e=6(f,e,a,b){e=r(e,"g"+(b&&E?"y":""));e.12=a=a||0;f=e.X(f);H b?f&&f.P===a?f:N:f};M.3q=6(){M.1h=6(){1S 2U("2a\'t 55 1h 54 3q")}};M.1R=6(f){H 53.Z.1q.W(f)==="[2m 15]"};M.3p=6(f,e,a,b){O(K c=r(e,"g"),d=-1,h;h=c.X(f);){a.W(b,h,++d,f,c);c.12===h.P&&c.12++}I(e.1J)e.12=0};M.57=6(f,e){H 6 a(b,c){K d=e[c].1I?e[c]:{1I:e[c]},h=r(d.1I,"g"),g=[],i;O(i=0;i<b.L;i++)M.3p(b[i],h,6(k){g.U(d.3j?k[d.3j]||"":k[0])});H c===e.L-1||!g.L?g:a(g,c+1)}([f],0)};15.Z.1p=6(f,e){H J.X(e[0])};15.Z.W=6(f,e){H J.X(e)};15.Z.X=6(f){K e=n.X.1p(J,14),a;I(e){I(!x&&e.L>1&&p(e,"")>-1){a=15(J.1m,n.Q.W(t(J),"g",""));n.Q.W(f.1a(e.P),a,6(){O(K c=1;c<14.L-2;c++)I(14[c]===1d)e[c]=1d})}I(J.1w&&J.1w.19)O(K b=1;b<e.L;b++)I(a=J.1w.19[b-1])e[a]=e[b];!D&&J.1J&&!e[0].L&&J.12>e.P&&J.12--}H e};I(!D)15.Z.1A=6(f){(f=n.X.W(J,f))&&J.1J&&!f[0].L&&J.12>f.P&&J.12--;H!!f};1r.Z.1C=6(f){M.1R(f)||(f=15(f));I(f.1J){K e=n.1C.1p(J,14);f.12=0;H e}H f.X(J)};1r.Z.Q=6(f,e){K a=M.1R(f),b,c;I(a&&1j e.58()==="3f"&&e.1i("${")===-1&&y)H n.Q.1p(J,14);I(a){I(f.1w)b=f.1w.19}Y f+="";I(1j e==="6")c=n.Q.W(J,f,6(){I(b){14[0]=1f 1r(14[0]);O(K d=0;d<b.L;d++)I(b[d])14[0][b[d]]=14[d+1]}I(a&&f.1J)f.12=14[14.L-2]+14[0].L;H e.1p(N,14)});Y{c=J+"";c=n.Q.W(c,f,6(){K d=14;H n.Q.W(e,C,6(h,g,i){I(g)5b(g){24"$":H"$";24"&":H d[0];24"`":H d[d.L-1].1a(0,d[d.L-2]);24"\'":H d[d.L-1].1a(d[d.L-2]+d[0].L);5a:i="";g=+g;I(!g)H h;O(;g>d.L-3;){i=1r.Z.1a.W(g,-1)+i;g=1Q.3i(g/10)}H(g?d[g]||"":"$")+i}Y{g=+i;I(g<=d.L-3)H d[g];g=b?p(b,i):-1;H g>-1?d[g+1]:h}})})}I(a&&f.1J)f.12=0;H c};1r.Z.1e=6(f,e){I(!M.1R(f))H n.1e.1p(J,14);K a=J+"",b=[],c=0,d,h;I(e===1d||+e<0)e=5D;Y{e=1Q.3i(+e);I(!e)H[]}O(f=M.3c(f);d=f.X(a);){I(f.12>c){b.U(a.1a(c,d.P));d.L>1&&d.P<a.L&&3b.Z.U.1p(b,d.1a(1));h=d[0].L;c=f.12;I(b.L>=e)1N}f.12===d.P&&f.12++}I(c===a.L){I(!n.1A.W(f,"")||h)b.U("")}Y b.U(a.1a(c));H b.L>e?b.1a(0,e):b};M.1h(/\\(\\?#[^)]*\\)/,6(f){H n.1A.W(A,f.2S.1a(f.P+f[0].L))?"":"(?:)"});M.1h(/\\((?!\\?)/,6(){J.19.U(N);H"("});M.1h(/\\(\\?<([$\\w]+)>/,6(f){J.19.U(f[1]);J.2N=R;H"("});M.1h(/\\\\k<([\\w$]+)>/,6(f){K e=p(J.19,f[1]);H e>-1?"\\\\"+(e+1)+(3R(f.2S.3a(f.P+f[0].L))?"":"(?:)"):f[0]});M.1h(/\\[\\^?]/,6(f){H f[0]==="[]"?"\\\\b\\\\B":"[\\\\s\\\\S]"});M.1h(/^\\(\\?([5A]+)\\)/,6(f){J.3d(f[1]);H""});M.1h(/(?:\\s+|#.*)+/,6(f){H n.1A.W(A,f.2S.1a(f.P+f[0].L))?"":"(?:)"},M.1B,6(){H J.2K("x")});M.1h(/\\./,6(){H"[\\\\s\\\\S]"},M.1B,6(){H J.2K("s")})})();1j 2e!="1d"&&(2e.M=M);K 1v=6(){6 r(a,b){a.1l.1i(b)!=-1||(a.1l+=" "+b)}6 t(a){H a.1i("3e")==0?a:"3e"+a}6 B(a){H e.1Y.2A[t(a)]}6 p(a,b,c){I(a==N)H N;K d=c!=R?a.3G:[a.2G],h={"#":"1c",".":"1l"}[b.1o(0,1)]||"3h",g,i;g=h!="3h"?b.1o(1):b.5u();I((a[h]||"").1i(g)!=-1)H a;O(a=0;d&&a<d.L&&i==N;a++)i=p(d[a],b,c);H i}6 C(a,b){K c={},d;O(d 2g a)c[d]=a[d];O(d 2g b)c[d]=b[d];H c}6 w(a,b,c,d){6 h(g){g=g||1P.5y;I(!g.1F){g.1F=g.52;g.3N=6(){J.5w=11}}c.W(d||1P,g)}a.3g?a.3g("4U"+b,h):a.4y(b,h,11)}6 A(a,b){K c=e.1Y.2j,d=N;I(c==N){c={};O(K h 2g e.1U){K g=e.1U[h];d=g.4x;I(d!=N){g.1V=h.4w();O(g=0;g<d.L;g++)c[d[g]]=h}}e.1Y.2j=c}d=e.1U[c[a]];d==N&&b!=11&&1P.1X(e.13.1x.1X+(e.13.1x.3E+a));H d}6 v(a,b){O(K c=a.1e("\\n"),d=0;d<c.L;d++)c[d]=b(c[d],d);H c.1K("\\n")}6 u(a,b){I(a==N||a.L==0||a=="\\n")H a;a=a.Q(/</g,"&1y;");a=a.Q(/ {2,}/g,6(c){O(K d="",h=0;h<c.L-1;h++)d+=e.13.1W;H d+" "});I(b!=N)a=v(a,6(c){I(c.L==0)H"";K d="";c=c.Q(/^(&2s;| )+/,6(h){d=h;H""});I(c.L==0)H d;H d+\'<17 1g="\'+b+\'">\'+c+"</17>"});H a}6 n(a,b){a.1e("\\n");O(K c="",d=0;d<50;d++)c+="                    ";H a=v(a,6(h){I(h.1i("\\t")==-1)H h;O(K g=0;(g=h.1i("\\t"))!=-1;)h=h.1o(0,g)+c.1o(0,b-g%b)+h.1o(g+1,h.L);H h})}6 x(a){H a.Q(/^\\s+|\\s+$/g,"")}6 D(a,b){I(a.P<b.P)H-1;Y I(a.P>b.P)H 1;Y I(a.L<b.L)H-1;Y I(a.L>b.L)H 1;H 0}6 y(a,b){6 c(k){H k[0]}O(K d=N,h=[],g=b.2D?b.2D:c;(d=b.1I.X(a))!=N;){K i=g(d,b);I(1j i=="3f")i=[1f e.2L(i,d.P,b.23)];h=h.1O(i)}H h}6 E(a){K b=/(.*)((&1G;|&1y;).*)/;H a.Q(e.3A.3M,6(c){K d="",h=N;I(h=b.X(c)){c=h[1];d=h[2]}H\'<a 2h="\'+c+\'">\'+c+"</a>"+d})}6 z(){O(K a=1E.36("1k"),b=[],c=0;c<a.L;c++)a[c].3s=="20"&&b.U(a[c]);H b}6 f(a){a=a.1F;K b=p(a,".20",R);a=p(a,".3O",R);K c=1E.4i("3t");I(!(!a||!b||p(a,"3t"))){B(b.1c);r(b,"1m");O(K d=a.3G,h=[],g=0;g<d.L;g++)h.U(d[g].4z||d[g].4A);h=h.1K("\\r");c.39(1E.4D(h));a.39(c);c.2C();c.4C();w(c,"4u",6(){c.2G.4E(c);b.1l=b.1l.Q("1m","")})}}I(1j 3F!="1d"&&1j M=="1d")M=3F("M").M;K e={2v:{"1g-27":"","2i-1s":1,"2z-1s-2t":11,1M:N,1t:N,"42-45":R,"43-22":4,1u:R,16:R,"3V-17":R,2l:11,"41-40":R,2k:11,"1z-1k":11},13:{1W:"&2s;",2M:R,46:11,44:11,34:"4n",1x:{21:"4o 1m",2P:"?",1X:"1v\\n\\n",3E:"4r\'t 4t 1D O: ",4g:"4m 4B\'t 51 O 1z-1k 4F: ",37:\'<!4T 1z 4S "-//4V//3H 4W 1.0 4Z//4Y" "1Z://2y.3L.3K/4X/3I/3H/3I-4P.4J"><1z 4I="1Z://2y.3L.3K/4L/5L"><3J><4N 1Z-4M="5G-5M" 6K="2O/1z; 6J=6I-8" /><1t>6L 1v</1t></3J><3B 1L="25-6M:6Q,6P,6O,6N-6F;6y-2f:#6x;2f:#6w;25-22:6v;2O-3D:3C;"><T 1L="2O-3D:3C;3w-32:1.6z;"><T 1L="25-22:6A-6E;">1v</T><T 1L="25-22:.6C;3w-6B:6R;"><T>3v 3.0.76 (72 73 3x)</T><T><a 2h="1Z://3u.2w/1v" 1F="38" 1L="2f:#3y">1Z://3u.2w/1v</a></T><T>70 17 6U 71.</T><T>6T 6X-3x 6Y 6D.</T></T><T>6t 61 60 J 1k, 5Z <a 2h="6u://2y.62.2w/63-66/65?64=5X-5W&5P=5O" 1L="2f:#3y">5R</a> 5V <2R/>5U 5T 5S!</T></T></3B></1z>\'}},1Y:{2j:N,2A:{}},1U:{},3A:{6n:/\\/\\*[\\s\\S]*?\\*\\//2c,6m:/\\/\\/.*$/2c,6l:/#.*$/2c,6k:/"([^\\\\"\\n]|\\\\.)*"/g,6o:/\'([^\\\\\'\\n]|\\\\.)*\'/g,6p:1f M(\'"([^\\\\\\\\"]|\\\\\\\\.)*"\',"3z"),6s:1f M("\'([^\\\\\\\\\']|\\\\\\\\.)*\'","3z"),6q:/(&1y;|<)!--[\\s\\S]*?--(&1G;|>)/2c,3M:/\\w+:\\/\\/[\\w-.\\/?%&=:@;]*/g,6a:{18:/(&1y;|<)\\?=?/g,1b:/\\?(&1G;|>)/g},69:{18:/(&1y;|<)%=?/g,1b:/%(&1G;|>)/g},6d:{18:/(&1y;|<)\\s*1k.*?(&1G;|>)/2T,1b:/(&1y;|<)\\/\\s*1k\\s*(&1G;|>)/2T}},16:{1H:6(a){6 b(i,k){H e.16.2o(i,k,e.13.1x[k])}O(K c=\'<T 1g="16">\',d=e.16.2x,h=d.2X,g=0;g<h.L;g++)c+=(d[h[g]].1H||b)(a,h[g]);c+="</T>";H c},2o:6(a,b,c){H\'<2W><a 2h="#" 1g="6e 6h\'+b+" "+b+\'">\'+c+"</a></2W>"},2b:6(a){K b=a.1F,c=b.1l||"";b=B(p(b,".20",R).1c);K d=6(h){H(h=15(h+"6f(\\\\w+)").X(c))?h[1]:N}("6g");b&&d&&e.16.2x[d].2B(b);a.3N()},2x:{2X:["21","2P"],21:{1H:6(a){I(a.V("2l")!=R)H"";K b=a.V("1t");H e.16.2o(a,"21",b?b:e.13.1x.21)},2B:6(a){a=1E.6j(t(a.1c));a.1l=a.1l.Q("47","")}},2P:{2B:6(){K a="68=0";a+=", 18="+(31.30-33)/2+", 32="+(31.2Z-2Y)/2+", 30=33, 2Z=2Y";a=a.Q(/^,/,"");a=1P.6Z("","38",a);a.2C();K b=a.1E;b.6W(e.13.1x.37);b.6V();a.2C()}}}},35:6(a,b){K c;I(b)c=[b];Y{c=1E.36(e.13.34);O(K d=[],h=0;h<c.L;h++)d.U(c[h]);c=d}c=c;d=[];I(e.13.2M)c=c.1O(z());I(c.L===0)H d;O(h=0;h<c.L;h++){O(K g=c[h],i=a,k=c[h].1l,j=3W 0,l={},m=1f M("^\\\\[(?<2V>(.*?))\\\\]$"),s=1f M("(?<27>[\\\\w-]+)\\\\s*:\\\\s*(?<1T>[\\\\w-%#]+|\\\\[.*?\\\\]|\\".*?\\"|\'.*?\')\\\\s*;?","g");(j=s.X(k))!=N;){K o=j.1T.Q(/^[\'"]|[\'"]$/g,"");I(o!=N&&m.1A(o)){o=m.X(o);o=o.2V.L>0?o.2V.1e(/\\s*,\\s*/):[]}l[j.27]=o}g={1F:g,1n:C(i,l)};g.1n.1D!=N&&d.U(g)}H d},1M:6(a,b){K c=J.35(a,b),d=N,h=e.13;I(c.L!==0)O(K g=0;g<c.L;g++){b=c[g];K i=b.1F,k=b.1n,j=k.1D,l;I(j!=N){I(k["1z-1k"]=="R"||e.2v["1z-1k"]==R){d=1f e.4l(j);j="4O"}Y I(d=A(j))d=1f d;Y 6H;l=i.3X;I(h.2M){l=l;K m=x(l),s=11;I(m.1i("<![6G[")==0){m=m.4h(9);s=R}K o=m.L;I(m.1i("]]\\>")==o-3){m=m.4h(0,o-3);s=R}l=s?m:l}I((i.1t||"")!="")k.1t=i.1t;k.1D=j;d.2Q(k);b=d.2F(l);I((i.1c||"")!="")b.1c=i.1c;i.2G.74(b,i)}}},2E:6(a){w(1P,"4k",6(){e.1M(a)})}};e.2E=e.2E;e.1M=e.1M;e.2L=6(a,b,c){J.1T=a;J.P=b;J.L=a.L;J.23=c;J.1V=N};e.2L.Z.1q=6(){H J.1T};e.4l=6(a){6 b(j,l){O(K m=0;m<j.L;m++)j[m].P+=l}K c=A(a),d,h=1f e.1U.5Y,g=J,i="2F 1H 2Q".1e(" ");I(c!=N){d=1f c;O(K k=0;k<i.L;k++)(6(){K j=i[k];g[j]=6(){H h[j].1p(h,14)}})();d.28==N?1P.1X(e.13.1x.1X+(e.13.1x.4g+a)):h.2J.U({1I:d.28.17,2D:6(j){O(K l=j.17,m=[],s=d.2J,o=j.P+j.18.L,F=d.28,q,G=0;G<s.L;G++){q=y(l,s[G]);b(q,o);m=m.1O(q)}I(F.18!=N&&j.18!=N){q=y(j.18,F.18);b(q,j.P);m=m.1O(q)}I(F.1b!=N&&j.1b!=N){q=y(j.1b,F.1b);b(q,j.P+j[0].5Q(j.1b));m=m.1O(q)}O(j=0;j<m.L;j++)m[j].1V=c.1V;H m}})}};e.4j=6(){};e.4j.Z={V:6(a,b){K c=J.1n[a];c=c==N?b:c;K d={"R":R,"11":11}[c];H d==N?c:d},3Y:6(a){H 1E.4i(a)},4c:6(a,b){K c=[];I(a!=N)O(K d=0;d<a.L;d++)I(1j a[d]=="2m")c=c.1O(y(b,a[d]));H J.4e(c.6b(D))},4e:6(a){O(K b=0;b<a.L;b++)I(a[b]!==N)O(K c=a[b],d=c.P+c.L,h=b+1;h<a.L&&a[b]!==N;h++){K g=a[h];I(g!==N)I(g.P>d)1N;Y I(g.P==c.P&&g.L>c.L)a[b]=N;Y I(g.P>=c.P&&g.P<d)a[h]=N}H a},4d:6(a){K b=[],c=2u(J.V("2i-1s"));v(a,6(d,h){b.U(h+c)});H b},3U:6(a){K b=J.V("1M",[]);I(1j b!="2m"&&b.U==N)b=[b];a:{a=a.1q();K c=3W 0;O(c=c=1Q.6c(c||0,0);c<b.L;c++)I(b[c]==a){b=c;1N a}b=-1}H b!=-1},2r:6(a,b,c){a=["1s","6i"+b,"P"+a,"6r"+(b%2==0?1:2).1q()];J.3U(b)&&a.U("67");b==0&&a.U("1N");H\'<T 1g="\'+a.1K(" ")+\'">\'+c+"</T>"},3Q:6(a,b){K c="",d=a.1e("\\n").L,h=2u(J.V("2i-1s")),g=J.V("2z-1s-2t");I(g==R)g=(h+d-1).1q().L;Y I(3R(g)==R)g=0;O(K i=0;i<d;i++){K k=b?b[i]:h+i,j;I(k==0)j=e.13.1W;Y{j=g;O(K l=k.1q();l.L<j;)l="0"+l;j=l}a=j;c+=J.2r(i,k,a)}H c},49:6(a,b){a=x(a);K c=a.1e("\\n");J.V("2z-1s-2t");K d=2u(J.V("2i-1s"));a="";O(K h=J.V("1D"),g=0;g<c.L;g++){K i=c[g],k=/^(&2s;|\\s)+/.X(i),j=N,l=b?b[g]:d+g;I(k!=N){j=k[0].1q();i=i.1o(j.L);j=j.Q(" ",e.13.1W)}i=x(i);I(i.L==0)i=e.13.1W;a+=J.2r(g,l,(j!=N?\'<17 1g="\'+h+\' 5N">\'+j+"</17>":"")+i)}H a},4f:6(a){H a?"<4a>"+a+"</4a>":""},4b:6(a,b){6 c(l){H(l=l?l.1V||g:g)?l+" ":""}O(K d=0,h="",g=J.V("1D",""),i=0;i<b.L;i++){K k=b[i],j;I(!(k===N||k.L===0)){j=c(k);h+=u(a.1o(d,k.P-d),j+"48")+u(k.1T,j+k.23);d=k.P+k.L+(k.75||0)}}h+=u(a.1o(d),c()+"48");H h},1H:6(a){K b="",c=["20"],d;I(J.V("2k")==R)J.1n.16=J.1n.1u=11;1l="20";J.V("2l")==R&&c.U("47");I((1u=J.V("1u"))==11)c.U("6S");c.U(J.V("1g-27"));c.U(J.V("1D"));a=a.Q(/^[ ]*[\\n]+|[\\n]*[ ]*$/g,"").Q(/\\r/g," ");b=J.V("43-22");I(J.V("42-45")==R)a=n(a,b);Y{O(K h="",g=0;g<b;g++)h+=" ";a=a.Q(/\\t/g,h)}a=a;a:{b=a=a;h=/<2R\\s*\\/?>|&1y;2R\\s*\\/?&1G;/2T;I(e.13.46==R)b=b.Q(h,"\\n");I(e.13.44==R)b=b.Q(h,"");b=b.1e("\\n");h=/^\\s*/;g=4Q;O(K i=0;i<b.L&&g>0;i++){K k=b[i];I(x(k).L!=0){k=h.X(k);I(k==N){a=a;1N a}g=1Q.4q(k[0].L,g)}}I(g>0)O(i=0;i<b.L;i++)b[i]=b[i].1o(g);a=b.1K("\\n")}I(1u)d=J.4d(a);b=J.4c(J.2J,a);b=J.4b(a,b);b=J.49(b,d);I(J.V("41-40"))b=E(b);1j 2H!="1d"&&2H.3S&&2H.3S.1C(/5s/)&&c.U("5t");H b=\'<T 1c="\'+t(J.1c)+\'" 1g="\'+c.1K(" ")+\'">\'+(J.V("16")?e.16.1H(J):"")+\'<3Z 5z="0" 5H="0" 5J="0">\'+J.4f(J.V("1t"))+"<3T><3P>"+(1u?\'<2d 1g="1u">\'+J.3Q(a)+"</2d>":"")+\'<2d 1g="17"><T 1g="3O">\'+b+"</T></2d></3P></3T></3Z></T>"},2F:6(a){I(a===N)a="";J.17=a;K b=J.3Y("T");b.3X=J.1H(a);J.V("16")&&w(p(b,".16"),"5c",e.16.2b);J.V("3V-17")&&w(p(b,".17"),"56",f);H b},2Q:6(a){J.1c=""+1Q.5d(1Q.5n()*5k).1q();e.1Y.2A[t(J.1c)]=J;J.1n=C(e.2v,a||{});I(J.V("2k")==R)J.1n.16=J.1n.1u=11},5j:6(a){a=a.Q(/^\\s+|\\s+$/g,"").Q(/\\s+/g,"|");H"\\\\b(?:"+a+")\\\\b"},5f:6(a){J.28={18:{1I:a.18,23:"1k"},1b:{1I:a.1b,23:"1k"},17:1f M("(?<18>"+a.18.1m+")(?<17>.*?)(?<1b>"+a.1b.1m+")","5o")}}};H e}();1j 2e!="1d"&&(2e.1v=1v);',62,441,'||||||function|||||||||||||||||||||||||||||||||||||return|if|this|var|length|XRegExp|null|for|index|replace|true||div|push|getParam|call|exec|else|prototype||false|lastIndex|config|arguments|RegExp|toolbar|code|left|captureNames|slice|right|id|undefined|split|new|class|addToken|indexOf|typeof|script|className|source|params|substr|apply|toString|String|line|title|gutter|SyntaxHighlighter|_xregexp|strings|lt|html|test|OUTSIDE_CLASS|match|brush|document|target|gt|getHtml|regex|global|join|style|highlight|break|concat|window|Math|isRegExp|throw|value|brushes|brushName|space|alert|vars|http|syntaxhighlighter|expandSource|size|css|case|font|Fa|name|htmlScript|dA|can|handler|gm|td|exports|color|in|href|first|discoveredBrushes|light|collapse|object|cache|getButtonHtml|trigger|pattern|getLineHtml|nbsp|numbers|parseInt|defaults|com|items|www|pad|highlighters|execute|focus|func|all|getDiv|parentNode|navigator|INSIDE_CLASS|regexList|hasFlag|Match|useScriptTags|hasNamedCapture|text|help|init|br|input|gi|Error|values|span|list|250|height|width|screen|top|500|tagName|findElements|getElementsByTagName|aboutDialog|_blank|appendChild|charAt|Array|copyAsGlobal|setFlag|highlighter_|string|attachEvent|nodeName|floor|backref|output|the|TypeError|sticky|Za|iterate|freezeTokens|scope|type|textarea|alexgorbatchev|version|margin|2010|005896|gs|regexLib|body|center|align|noBrush|require|childNodes|DTD|xhtml1|head|org|w3|url|preventDefault|container|tr|getLineNumbersHtml|isNaN|userAgent|tbody|isLineHighlighted|quick|void|innerHTML|create|table|links|auto|smart|tab|stripBrs|tabs|bloggerMode|collapsed|plain|getCodeLinesHtml|caption|getMatchesHtml|findMatches|figureOutLineNumbers|removeNestedMatches|getTitleHtml|brushNotHtmlScript|substring|createElement|Highlighter|load|HtmlScript|Brush|pre|expand|multiline|min|Can|ignoreCase|find|blur|extended|toLowerCase|aliases|addEventListener|innerText|textContent|wasn|select|createTextNode|removeChild|option|same|frame|xmlns|dtd|twice|1999|equiv|meta|htmlscript|transitional|1E3|expected|PUBLIC|DOCTYPE|on|W3C|XHTML|TR|EN|Transitional||configured|srcElement|Object|after|run|dblclick|matchChain|valueOf|constructor|default|switch|click|round|execAt|forHtmlScript|token|gimy|functions|getKeywords|1E6|escape|within|random|sgi|another|finally|supply|MSIE|ie|toUpperCase|catch|returnValue|definition|event|border|imsx|constructing|one|Infinity|from|when|Content|cellpadding|flags|cellspacing|try|xhtml|Type|spaces|2930402|hosted_button_id|lastIndexOf|donate|active|development|keep|to|xclick|_s|Xml|please|like|you|paypal|cgi|cmd|webscr|bin|highlighted|scrollbars|aspScriptTags|phpScriptTags|sort|max|scriptScriptTags|toolbar_item|_|command|command_|number|getElementById|doubleQuotedString|singleLinePerlComments|singleLineCComments|multiLineCComments|singleQuotedString|multiLineDoubleQuotedString|xmlComments|alt|multiLineSingleQuotedString|If|https|1em|000|fff|background|5em|xx|bottom|75em|Gorbatchev|large|serif|CDATA|continue|utf|charset|content|About|family|sans|Helvetica|Arial|Geneva|3em|nogutter|Copyright|syntax|close|write|2004|Alex|open|JavaScript|highlighter|July|02|replaceChild|offset|83'.split('|'),0,{}))
;
/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
eval(function(p,a,c,k,e,d){e=function(c){return(c<a?'':e(parseInt(c/a)))+((c=c%a)>35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--){d[e(c)]=k[c]||e(c)}k=[function(e){return d[e]}];e=function(){return'\\w+'};c=1};while(c--){if(k[c]){p=p.replace(new RegExp('\\b'+e(c)+'\\b','g'),k[c])}}return p}('(2(){1 h=5;h.I=2(){2 n(c,a){4(1 d=0;d<c.9;d++)i[c[d]]=a}2 o(c){1 a=r.H("J"),d=3;a.K=c;a.M="L/t";a.G="t";a.u=a.v=2(){6(!d&&(!8.7||8.7=="F"||8.7=="z")){d=q;e[c]=q;a:{4(1 p y e)6(e[p]==3)B a;j&&5.C(k)}a.u=a.v=x;a.D.O(a)}};r.N.R(a)}1 f=Q,l=h.P(),i={},e={},j=3,k=x,b;5.T=2(c){k=c;j=q};4(b=0;b<f.9;b++){1 m=f[b].w?f[b]:f[b].S(/\\s+/),g=m.w();n(m,g)}4(b=0;b<l.9;b++)6(g=i[l[b].E.A]){e[g]=3;o(g)}}})();',56,56,'|var|function|false|for|SyntaxHighlighter|if|readyState|this|length|||||||||||||||||true|document||javascript|onload|onreadystatechange|pop|null|in|complete|brush|break|highlight|parentNode|params|loaded|language|createElement|autoloader|script|src|text|type|body|removeChild|findElements|arguments|appendChild|split|all'.split('|'),0,{}))
;
/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 *
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
;(function()
{
	// CommonJS
	// SIESTA PATCH BEGIN
	// always assume browser setup, even when `require` present
	// typeof(require) != 'undefined' ? SyntaxHighlighter = require('shCore').SyntaxHighlighter : null;
	// SIESTA PATCH END

	function Brush()
	{
		var keywords =	'break case catch continue ' +
						'default delete do else false  ' +
						'for function if in instanceof ' +
						'new null return super switch ' +
						'this throw true try typeof var while with'
						;

		var r = SyntaxHighlighter.regexLib;

		this.regexList = [
			{ regex: r.multiLineDoubleQuotedString,					css: 'string' },			// double quoted strings
			{ regex: r.multiLineSingleQuotedString,					css: 'string' },			// single quoted strings
			{ regex: r.singleLineCComments,							css: 'comments' },			// one line comments
			{ regex: r.multiLineCComments,							css: 'comments' },			// multiline comments
			{ regex: /\s*#.*/gm,									css: 'preprocessor' },		// preprocessor tags like #region and #endregion
			{ regex: new RegExp(this.getKeywords(keywords), 'gm'),	css: 'keyword' }			// keywords
			];

		this.forHtmlScript(r.scriptScriptTags);
	};

	Brush.prototype	= new SyntaxHighlighter.Highlighter();
	Brush.aliases	= ['js', 'jscript', 'javascript'];

	SyntaxHighlighter.brushes.JScript = Brush;

	// CommonJS
	typeof(exports) != 'undefined' ? exports.Brush = Brush : null;
})();
;
var $jscomp={};$jscomp.scope={};$jscomp.defineProperty=typeof Object.defineProperties=='function'?Object.defineProperty:function(b,c,a){a=(a);if(a.get||a.set){throw new TypeError('ES3 does not support getters and setters.')}if(b==Array.prototype||b==Object.prototype){return}b[c]=a.value};$jscomp.getGlobal=function(a){return typeof window!='undefined'&&window===a?a:typeof global!='undefined'&&global!=null?global:a};$jscomp.global=$jscomp.getGlobal(this);$jscomp.polyfill=function(i,f,j,k){if(!f){return}var a=$jscomp.global;var b=i.split('.');for(var e=0;e<b.length-1;e++){var d=b[e];if(!(d in a)){a[d]={}}a=a[d]}var g=b[b.length-1];var h=a[g];var c=f(h);if(c==h||c==null){return}$jscomp.defineProperty(a,g,{configurable:!0,writable:!0,value:c})};$jscomp.polyfill('Array.prototype.copyWithin',function(a){if(a){return a}var b=function(c,b,a){var d=this.length;c=Number(c);b=Number(b);a=Number(a!=null?a:d);if(c<b){a=Math.min(a,d);while(b<a){if(b in this){this[c++]=this[b++]}else {delete this[c++];b++}}}else {a=Math.min(a,d+b-c);c+=a-b;while(a>b){if(--a in this){this[--c]=this[a]}else {delete this[c]}}}return this};return b},'es6-impl','es3');$jscomp.SYMBOL_PREFIX='jscomp_symbol_';$jscomp.initSymbol=function(){$jscomp.initSymbol=function(){};if(!$jscomp.global.Symbol){$jscomp.global.Symbol=$jscomp.Symbol}};$jscomp.symbolCounter_=0;$jscomp.Symbol=function(a){return ($jscomp.SYMBOL_PREFIX+(a||'')+$jscomp.symbolCounter_++)};$jscomp.initSymbolIterator=function(){$jscomp.initSymbol();var a=$jscomp.global.Symbol.iterator;if(!a){a=$jscomp.global.Symbol.iterator=$jscomp.global.Symbol('iterator')}if(typeof Array.prototype[a]!='function'){$jscomp.defineProperty(Array.prototype,a,{configurable:!0,writable:!0,value:function(){return $jscomp.arrayIterator(this)}})}$jscomp.initSymbolIterator=function(){}};$jscomp.arrayIterator=function(a){var b=0;return $jscomp.iteratorPrototype(function(){if(b<a.length){return {done:!1,value:a[b++]}}else {return {done:!0}}})};$jscomp.iteratorPrototype=function(b){$jscomp.initSymbolIterator();var a={next:b};a[$jscomp.global.Symbol.iterator]=function(){return this};return (a)};$jscomp.array=$jscomp.array||{};$jscomp.iteratorFromArray=function(a,d){$jscomp.initSymbolIterator();if(a instanceof String){a=a+''}var c=0;var b={next:function(){if(c<a.length){var e=c++;return {value:d(e,a[e]),done:!1}}b.next=function(){return {done:!0,value:void 0}};return b.next()}};b[Symbol.iterator]=function(){return b};return b};$jscomp.polyfill('Array.prototype.entries',function(a){if(a){return a}var b=function(){return $jscomp.iteratorFromArray(this,function(a,b){return [a,b]})};return b},'es6-impl','es3');$jscomp.polyfill('Array.prototype.fill',function(a){if(a){return a}var b=function(e,b,a){var c=this.length||0;if(b<0){b=Math.max(0,c+(b))}if(a==null||a>c){a=c}a=Number(a);if(a<0){a=Math.max(0,c+a)}for(var d=Number(b||0);d<a;d++){this[d]=e}return this};return b},'es6-impl','es3');$jscomp.findInternal=function(a,d,e){if(a instanceof String){a=(String(a))}var f=a.length;for(var b=0;b<f;b++){var c=a[b];if(d.call(e,c,b,a)){return {i:b,v:c}}}return {i:-1,v:void 0}};$jscomp.polyfill('Array.prototype.find',function(a){if(a){return a}var b=function(b,a){return $jscomp.findInternal(this,b,a).v};return b},'es6-impl','es3');$jscomp.polyfill('Array.prototype.findIndex',function(a){if(a){return a}var b=function(b,a){return $jscomp.findInternal(this,b,a).i};return b},'es6-impl','es3');$jscomp.polyfill('Array.from',function(a){if(a){return a}var b=function(a,b,f){$jscomp.initSymbolIterator();b=b!=null?b:function(a){return a};var c=[];var e=(a)[Symbol.iterator];if(typeof e=='function'){a=e.call(a);var g;while(!(g=a.next()).done){c.push(b.call((f),g.value))}}else {var h=a.length;for(var d=0;d<h;d++){c.push(b.call((f),a[d]))}}return c};return b},'es6-impl','es3');$jscomp.polyfill('Array.prototype.keys',function(a){if(a){return a}var b=function(){return $jscomp.iteratorFromArray(this,function(a){return a})};return b},'es6-impl','es3');$jscomp.polyfill('Array.of',function(a){if(a){return a}var b=function(a){return Array.from(arguments)};return b},'es6-impl','es3');$jscomp.polyfill('Array.prototype.values',function(a){if(a){return a}var b=function(){return $jscomp.iteratorFromArray(this,function(b,a){return a})};return b},'es6','es3');$jscomp.executeAsyncGenerator=function(a){function passValueToGenerator(b){return a.next(b)}function passErrorToGenerator(b){return a['throw'](b)}return new Promise(function(b,c){function handleGeneratorRecord(a){if(a.done){b(a.value)}else {Promise.resolve(a.value).then(passValueToGenerator,passErrorToGenerator).then(handleGeneratorRecord,c)}}handleGeneratorRecord(a.next())})};$jscomp.makeIterator=function(a){$jscomp.initSymbolIterator();var b=(a)[Symbol.iterator];return b?b.call(a):$jscomp.arrayIterator((a))};$jscomp.owns=function(b,a){return Object.prototype.hasOwnProperty.call(b,a)};$jscomp.polyfill('WeakMap',function(c){function isConformant(){if(!c||!Object.seal){return !1}try{var b=Object.seal({});var d=Object.seal({});var a=new (c)([[b,2],[d,3]]);if(a.get(b)!=2||a.get(d)!=3){return !1}a['delete'](b);a.set(d,4);return !a.has(b)&&a.get(d)==4}catch(e){return !1}}if(isConformant()){return c}var a='$jscomp_hidden_'+Math.random().toString().substring(2);function insert(b){if(!$jscomp.owns(b,a)){var c={};$jscomp.defineProperty(b,a,{value:c})}}function patch(a){var b=Object[a];if(b){Object[a]=function(a){insert(a);return b(a)}}}patch('freeze');patch('preventExtensions');patch('seal');var d=0;var b=function(a){this.id_=(d+=Math.random()+1).toString();if(a){$jscomp.initSymbol();$jscomp.initSymbolIterator();var e=$jscomp.makeIterator(a);var b;while(!(b=e.next()).done){var c=b.value;this.set((c[0]),(c[1]))}}};b.prototype.set=function(b,c){insert(b);if(!$jscomp.owns(b,a)){throw new Error('WeakMap key fail: '+b)}b[a][this.id_]=c;return this};b.prototype.get=function(b){return $jscomp.owns(b,a)?b[a][this.id_]:undefined};b.prototype.has=function(b){return $jscomp.owns(b,a)&&$jscomp.owns(b[a],this.id_)};b.prototype['delete']=function(b){if(!$jscomp.owns(b,a)||!$jscomp.owns(b[a],this.id_)){return !1}return delete b[a][this.id_]};return b},'es6-impl','es3');$jscomp.ASSUME_NO_NATIVE_MAP=!1;$jscomp.polyfill('Map',function(b){var h=!$jscomp.ASSUME_NO_NATIVE_MAP&&function(){if(!b||!b.prototype.entries||typeof Object.seal!='function'){return !1}try{b=(b);var e=Object.seal({x:4});var c=new b($jscomp.makeIterator([[e,'s']]));if(c.get(e)!='s'||c.size!=1||c.get({x:4})||c.set({x:4},'t')!=c||c.size!=2){return !1}var d=c.entries();var a=d.next();if(a.done||a.value[0]!=e||a.value[1]!='s'){return !1}a=d.next();if(a.done||a.value[0].x!=4||a.value[1]!='t'||!d.next().done){return !1}return !0}catch(k){return !1}}();if(h){return b}$jscomp.initSymbol();$jscomp.initSymbolIterator();var f=new WeakMap();var c=function(){};c.prototype.previous;c.prototype.next;c.prototype.head;c.prototype.key;c.prototype.value;var a=function(a){this.data_={};this.head_=g();this.size=0;if(a){var d=$jscomp.makeIterator(a);var b;while(!(b=d.next()).done){var c=(b).value;this.set((c[0]),(c[1]))}}};a.prototype.set=function(c,b){var a=d(this,c);if(!a.list){a.list=this.data_[a.id]=[]}if(!a.entry){a.entry={next:this.head_,previous:this.head_.previous,head:this.head_,key:c,value:b};a.list.push(a.entry);this.head_.previous.next=a.entry;this.head_.previous=a.entry;this.size++}else {a.entry.value=b}return this};a.prototype['delete']=function(b){var a=d(this,b);if(a.entry&&a.list){a.list.splice(a.index,1);if(!a.list.length){delete this.data_[a.id]}a.entry.previous.next=a.entry.next;a.entry.next.previous=a.entry.previous;a.entry.head=null;this.size--;return !0}return !1};a.prototype.clear=function(){this.data_={};this.head_=this.head_.previous=g();this.size=0};a.prototype.has=function(a){return !!d(this,a).entry};a.prototype.get=function(b){var a=d(this,b).entry;return (a&&(a.value))};a.prototype.entries=function(){return e(this,function(a){return [a.key,a.value]})};a.prototype.keys=function(){return e(this,function(a){return a.key})};a.prototype.values=function(){return e(this,function(a){return a.value})};a.prototype.forEach=function(d,c){var e=this.entries();var b;while(!(b=e.next()).done){var a=b.value;d.call((c),(a[1]),(a[0]),this)}};(a.prototype)[Symbol.iterator]=a.prototype.entries;var d=function(f,d){var e=j(d);var a=f.data_[e];if(a&&$jscomp.owns(f.data_,e)){for(var c=0;c<a.length;c++){var b=a[c];if(d!==d&&b.key!==b.key||d===b.key){return {id:e,list:a,index:c,entry:b}}}}return {id:e,list:a,index:-1,entry:undefined}};var e=function(b,c){var a=b.head_;return $jscomp.iteratorPrototype(function(){if(a){while(a.head!=b.head_){a=a.previous}while(a.next!=a.head){a=a.next;return {done:!1,value:c(a)}}a=null}return {done:!0,value:void 0}})};var g=function(){var a={};a.previous=a.next=a.head=a;return a};var i=0;var j=function(a){var b=a&&typeof a;if(b=='object'||b=='function'){a=(a);if(!f.has(a)){var c=''+ ++i;f.set(a,c);return c}return f.get(a)}return 'p_'+a};return a},'es6-impl','es3');$jscomp.polyfill('Math.acosh',function(a){if(a){return a}var b=function(a){a=Number(a);return Math.log(a+Math.sqrt(a*a-1))};return b},'es6-impl','es3');$jscomp.polyfill('Math.asinh',function(a){if(a){return a}var b=function(a){a=Number(a);if(a===0){return a}var b=Math.log(Math.abs(a)+Math.sqrt(a*a+1));return a<0?-b:b};return b},'es6-impl','es3');$jscomp.polyfill('Math.log1p',function(a){if(a){return a}var b=function(a){a=Number(a);if(a<0.25&&a>-0.25){var e=a;var f=1;var b=a;var c=0;var d=1;while(c!=b){e*=a;d*=-1;b=(c=b)+d*e/++f}return b}return Math.log(1+a)};return b},'es6-impl','es3');$jscomp.polyfill('Math.atanh',function(b){if(b){return b}var a=Math.log1p;var c=function(b){b=Number(b);return (a(b)-a(-b))/2};return c},'es6-impl','es3');$jscomp.polyfill('Math.cbrt',function(a){if(a){return a}var b=function(a){if(a===0){return a}a=Number(a);var b=Math.pow(Math.abs(a),1/3);return a<0?-b:b};return b},'es6-impl','es3');$jscomp.polyfill('Math.clz32',function(a){if(a){return a}var b=function(a){a=Number(a)>>>0;if(a===0){return 32}var b=0;if((a&4.29490176E9)===0){a<<=16;b+=16}if((a&4.27819008E9)===0){a<<=8;b+=8}if((a&4.02653184E9)===0){a<<=4;b+=4}if((a&3.221225472E9)===0){a<<=2;b+=2}if((a&2.147483648E9)===0){b++}return b};return b},'es6-impl','es3');$jscomp.polyfill('Math.cosh',function(a){if(a){return a}var b=Math.exp;var c=function(a){a=Number(a);return (b(a)+b(-a))/2};return c},'es6-impl','es3');$jscomp.polyfill('Math.expm1',function(a){if(a){return a}var b=function(a){a=Number(a);if(a<0.25&&a>-0.25){var d=a;var e=1;var b=a;var c=0;while(c!=b){d*=a/++e;b=(c=b)+d}return b}return Math.exp(a)-1};return b},'es6-impl','es3');$jscomp.polyfill('Math.hypot',function(a){if(a){return a}var b=function(b,c,g){b=Number(b);c=Number(c);var a,f,e;var d=Math.max(Math.abs(b),Math.abs(c));for(a=2;a<arguments.length;a++){d=Math.max(d,Math.abs(arguments[a]))}if(d>1.0E100||d<1.0E-100){b=b/d;c=c/d;e=b*b+c*c;for(a=2;a<arguments.length;a++){f=Number(arguments[a])/d;e+=f*f}return Math.sqrt(e)*d}else {e=b*b+c*c;for(a=2;a<arguments.length;a++){f=Number(arguments[a]);e+=f*f}return Math.sqrt(e)}};return b},'es6-impl','es3');$jscomp.polyfill('Math.imul',function(a){if(a){return a}var b=function(a,b){a=Number(a);b=Number(b);var e=a>>>16&65535;var c=a&65535;var f=b>>>16&65535;var d=b&65535;var g=e*d+c*f<<16>>>0;return c*d+g|0};return b},'es6-impl','es3');$jscomp.polyfill('Math.log10',function(a){if(a){return a}var b=function(a){return Math.log(a)/Math.LN10};return b},'es6-impl','es3');$jscomp.polyfill('Math.log2',function(a){if(a){return a}var b=function(a){return Math.log(a)/Math.LN2};return b},'es6-impl','es3');$jscomp.polyfill('Math.sign',function(a){if(a){return a}var b=function(a){a=Number(a);return a===0||isNaN(a)?a:a>0?1:-1};return b},'es6-impl','es3');$jscomp.polyfill('Math.sinh',function(a){if(a){return a}var b=Math.exp;var c=function(a){a=Number(a);if(a===0){return a}return (b(a)-b(-a))/2};return c},'es6-impl','es3');$jscomp.polyfill('Math.tanh',function(a){if(a){return a}var b=function(a){a=Number(a);if(a===0){return a}var b=Math.exp(-2*Math.abs(a));var c=(1-b)/(1+b);return a<0?-c:c};return b},'es6-impl','es3');$jscomp.polyfill('Math.trunc',function(a){if(a){return a}var b=function(a){a=Number(a);if(isNaN(a)||a===Infinity||a===-Infinity||a===0){return a}var b=Math.floor(Math.abs(a));return a<0?-b:b};return b},'es6-impl','es3');$jscomp.polyfill('Number.EPSILON',function(a){return Math.pow(2,-52)},'es6-impl','es3');$jscomp.polyfill('Number.MAX_SAFE_INTEGER',function(){return 9.007199254740991E15},'es6-impl','es3');$jscomp.polyfill('Number.MIN_SAFE_INTEGER',function(){return -9.007199254740991E15},'es6-impl','es3');$jscomp.polyfill('Number.isFinite',function(a){if(a){return a}var b=function(a){if(typeof a!=='number'){return !1}return !isNaN(a)&&a!==Infinity&&a!==-Infinity};return b},'es6-impl','es3');$jscomp.polyfill('Number.isInteger',function(a){if(a){return a}var b=function(a){if(!Number.isFinite(a)){return !1}return a===Math.floor(a)};return b},'es6-impl','es3');$jscomp.polyfill('Number.isNaN',function(a){if(a){return a}var b=function(a){return typeof a==='number'&&isNaN(a)};return b},'es6-impl','es3');$jscomp.polyfill('Number.isSafeInteger',function(a){if(a){return a}var b=function(a){return Number.isInteger(a)&&Math.abs(a)<=Number.MAX_SAFE_INTEGER};return b},'es6-impl','es3');$jscomp.polyfill('Object.assign',function(a){if(a){return a}var b=function(d,e){for(var c=1;c<arguments.length;c++){var a=arguments[c];if(!a){continue}for(var b in a){if($jscomp.owns(a,b)){d[b]=a[b]}}}return d};return b},'es6-impl','es3');$jscomp.polyfill('Object.getOwnPropertySymbols',function(a){if(a){return a}return function(){return []}},'es6-impl','es5');$jscomp.polyfill('Object.is',function(a){if(a){return a}var b=function(a,b){if(a===b){return a!==0||1/a===1/(b)}else {return a!==a&&b!==b}};return b},'es6-impl','es3');$jscomp.polyfill('Object.setPrototypeOf',function(a){if(a){return a}if(typeof ''.__proto__!='object'){return null}var b=function(a,b){a.__proto__=b;if(a.__proto__!==b){throw new TypeError(a+' is not extensible')}return a};return b},'es6','es5');$jscomp.EXPOSE_ASYNC_EXECUTOR=!0;$jscomp.FORCE_POLYFILL_PROMISE=!1;$jscomp.polyfill('Promise',function(c){if(c&&!$jscomp.FORCE_POLYFILL_PROMISE){return c}function AsyncExecutor(){this.batch_=null}AsyncExecutor.prototype.asyncExecute=function(a){if(this.batch_==null){this.batch_=[];this.asyncExecuteBatch_()}this.batch_.push(a);return this};AsyncExecutor.prototype.asyncExecuteBatch_=function(){var a=this;this.asyncExecuteFunction(function(){a.executeBatch_()})};var e=$jscomp.global['setTimeout'];AsyncExecutor.prototype.asyncExecuteFunction=function(a){e(a,0)};AsyncExecutor.prototype.executeBatch_=function(){while(this.batch_&&this.batch_.length){var b=this.batch_;this.batch_=[];for(var a=0;a<b.length;++a){var c=b[a];delete b[a];try{c()}catch(f){this.asyncThrow_(f)}}}this.batch_=null};AsyncExecutor.prototype.asyncThrow_=function(a){this.asyncExecuteFunction(function(){throw a})};var b={PENDING:0,FULFILLED:1,REJECTED:2};var a=function(c){this.state_=b.PENDING;this.result_=undefined;this.onSettledCallbacks_=[];var a=this.createResolveAndReject_();try{c(a.resolve,a.reject)}catch(f){a.reject(f)}};a.prototype.createResolveAndReject_=function(){var b=this;var a=!1;function firstCallWins(c){return function(d){if(!a){a=!0;c.call(b,d)}}}return {resolve:firstCallWins(this.resolveTo_),reject:firstCallWins(this.reject_)}};a.prototype.resolveTo_=function(b){if(b===this){this.reject_(new TypeError('A Promise cannot resolve to itself'))}else {if(b instanceof a){this.settleSameAsPromise_((b))}else {if(isObject(b)){this.resolveToNonPromiseObj_((b))}else {this.fulfill_(b)}}}};a.prototype.resolveToNonPromiseObj_=function(b){var a=undefined;try{a=b.then}catch(f){this.reject_(f);return}if(typeof a=='function'){this.settleSameAsThenable_(a,(b))}else {this.fulfill_(b)}};function isObject(a){switch(typeof a){case 'object':return a!=null;case 'function':return !0;default:return !1;}}a.prototype.reject_=function(a){this.settle_(b.REJECTED,a)};a.prototype.fulfill_=function(a){this.settle_(b.FULFILLED,a)};a.prototype.settle_=function(c,a){if(this.state_!=b.PENDING){throw new Error('Cannot settle('+c+', '+a|'): Promise already settled in state'+this.state_)}this.state_=c;this.result_=a;this.executeOnSettledCallbacks_()};a.prototype.executeOnSettledCallbacks_=function(){if(this.onSettledCallbacks_!=null){var b=this.onSettledCallbacks_;for(var a=0;a<b.length;++a){(b[a]).call();b[a]=null}this.onSettledCallbacks_=null}};var d=new AsyncExecutor();a.prototype.settleSameAsPromise_=function(b){var a=this.createResolveAndReject_();b.callWhenSettled_(a.resolve,a.reject)};a.prototype.settleSameAsThenable_=function(b,c){var a=this.createResolveAndReject_();try{b.call(c,a.resolve,a.reject)}catch(f){a.reject(f)}};a.prototype.then=function(e,f){var b;var c;var d=new a(function(a,d){b=a;c=d});function createCallback(a,d){if(typeof a=='function'){return function(d){try{b(a(d))}catch(g){c(g)}}}else {return d}}this.callWhenSettled_(createCallback(e,b),createCallback(f,c));return d};a.prototype['catch']=function(a){return this.then(undefined,a)};a.prototype.callWhenSettled_=function(c,e){var a=this;function callback(){switch(a.state_){case b.FULFILLED:c(a.result_);break;case b.REJECTED:e(a.result_);break;default:throw new Error('Unexpected state: '+a.state_);}}if(this.onSettledCallbacks_==null){d.asyncExecute(callback)}else {this.onSettledCallbacks_.push(function(){d.asyncExecute(callback)})}};a.resolve=function(b){if(b instanceof a){return b}else {return new a(function(a,c){a(b)})}};a.reject=function(b){return new a(function(c,a){a(b)})};a.race=function(b){return new a(function(e,f){var d=$jscomp.makeIterator(b);for(var c=d.next();!c.done;c=d.next()){a.resolve(c.value).callWhenSettled_(e,f)}})};a.all=function(d){var c=$jscomp.makeIterator(d);var b=c.next();if(b.done){return a.resolve([])}else {return new a(function(f,g){var d=[];var e=0;function onFulfilled(a){return function(b){d[a]=b;e--;if(e==0){f(d)}}}do{d.push(undefined);e++;a.resolve(b.value).callWhenSettled_(onFulfilled(d.length-1),g);b=c.next()}while(!b.done)})}};if($jscomp.EXPOSE_ASYNC_EXECUTOR){a['$jscomp$new$AsyncExecutor']=function(){return new AsyncExecutor()}}return a},'es6-impl','es3');$jscomp.polyfill('Reflect.apply',function(a){if(a){return a}var c=Function.prototype.apply;var b=function(d,b,a){return c.call(d,b,a)};return b},'es6','es3');$jscomp.polyfill('Reflect.construct',function(a){if(a){return a}var b=function(b,d,a){if(a===undefined){a=b}var e=a.prototype||Object.prototype;var c=Object.create(e);var f=Reflect.apply(b,c,d);return f||c};return b},'es6','es5');$jscomp.polyfill('Reflect.defineProperty',function(a){if(a){return a}var b=function(d,c,b){try{Object.defineProperty(d,c,b);var a=Object.getOwnPropertyDescriptor(d,c);if(!a){return !1}return a.configurable===(b.configurable||!1)&&a.enumerable===(b.enumerable||!1)&&('value' in a?a.value===b.value&&a.writable===(b.writable||!1):a.get===b.get&&a.set===b.set)}catch(e){return !1}};return b},'es6','es5');$jscomp.polyfill('Reflect.deleteProperty',function(a){if(a){return a}var b=function(b,a){if(!$jscomp.owns(b,a)){return !0}try{return delete b[a]}catch(c){return !1}};return b},'es6','es3');$jscomp.polyfill('Reflect.getOwnPropertyDescriptor',function(a){return a||Object.getOwnPropertyDescriptor},'es6','es5');$jscomp.polyfill('Reflect.getPrototypeOf',function(a){return a||Object.getPrototypeOf},'es6','es5');$jscomp.findDescriptor=function(d,c){var a=d;while(a){var b=Reflect.getOwnPropertyDescriptor(a,c);if(b){return b}a=Reflect.getPrototypeOf(a)}return undefined};$jscomp.polyfill('Reflect.get',function(a){if(a){return a}var b=function(c,b,d){if(arguments.length<=2){return c[b]}var a=$jscomp.findDescriptor(c,b);if(a){return a.get?a.get.call(d):a.value}return undefined};return b},'es6','es5');$jscomp.polyfill('Reflect.has',function(a){if(a){return a}var b=function(b,a){return a in b};return b},'es6','es3');$jscomp.polyfill('Reflect.isExtensible',function(a){if(a){return a}if(typeof Object.isExtensible=='function'){return Object.isExtensible}return function(){return !0}},'es6','es3');$jscomp.polyfill('Reflect.ownKeys',function(b){if(b){return b}var a='jscomp_symbol_';function isSymbol(b){return b.substring(0,a.length)==a}var c=function(d){var e=[];var b=Object.getOwnPropertyNames(d);var c=Object.getOwnPropertySymbols(d);for(var a=0;a<b.length;a++){(isSymbol(b[a])?c:e).push(b[a])}return e.concat(c)};return c},'es6','es5');$jscomp.polyfill('Reflect.preventExtensions',function(a){if(a){return a}if(typeof Object.preventExtensions!='function'){return function(){return !1}}var b=function(a){Object.preventExtensions(a);return !Object.isExtensible(a)};return b},'es6','es3');$jscomp.polyfill('Reflect.set',function(a){if(a){return a}var b=function(a,c,d,e){var b=$jscomp.findDescriptor(a,c);if(!b){if(Reflect.isExtensible(a)){a[c]=d;return !0}return !1}if(b.set){b.set.call(arguments.length>3?e:a,d);return !0}else {if(b.writable&&!Object.isFrozen(a)){a[c]=d;return !0}}return !1};return b},'es6','es5');$jscomp.polyfill('Reflect.setPrototypeOf',function(a){if(a){return a}if(typeof ''.__proto__!='object'){return null}var b=function(a,b){try{a.__proto__=b;return a.__proto__===b}catch(c){return !1}};return b},'es6','es5');$jscomp.ASSUME_NO_NATIVE_SET=!1;$jscomp.polyfill('Set',function(b){var c=!$jscomp.ASSUME_NO_NATIVE_SET&&function(){if(!b||!b.prototype.entries||typeof Object.seal!='function'){return !1}try{b=(b);var d=Object.seal({x:4});var c=new b($jscomp.makeIterator([d]));if(!c.has(d)||c.size!=1||c.add(d)!=c||c.size!=1||c.add({x:4})!=c||c.size!=2){return !1}var e=c.entries();var a=e.next();if(a.done||a.value[0]!=d||a.value[1]!=d){return !1}a=e.next();if(a.done||a.value[0]==d||a.value[0].x!=4||a.value[1]!=a.value[0]){return !1}return e.next().done}catch(f){return !1}}();if(c){return b}$jscomp.initSymbol();$jscomp.initSymbolIterator();var a=function(a){this.map_=new Map();if(a){var d=$jscomp.makeIterator(a);var b;while(!(b=d.next()).done){var c=(b).value;this.add(c)}}this.size=this.map_.size};a.prototype.add=function(a){this.map_.set(a,a);this.size=this.map_.size;return this};a.prototype['delete']=function(b){var a=this.map_['delete'](b);this.size=this.map_.size;return a};a.prototype.clear=function(){this.map_.clear();this.size=0};a.prototype.has=function(a){return this.map_.has(a)};a.prototype.entries=function(){return this.map_.entries()};a.prototype.values=function(){return this.map_.values()};(a.prototype)[Symbol.iterator]=a.prototype.values;a.prototype.forEach=function(b,a){var c=this;this.map_.forEach(function(d){return b.call((a),d,d,c)})};return a},'es6-impl','es3');$jscomp.checkStringArgs=function(a,c,b){if(a==null){throw new TypeError("The 'this' value for String.prototype."+b+' must not be null or undefined')}if(c instanceof RegExp){throw new TypeError('First argument to String.prototype.'+b+' must not be a regular expression')}return a+''};$jscomp.polyfill('String.prototype.codePointAt',function(a){if(a){return a}var b=function(a){var d=$jscomp.checkStringArgs(this,null,'codePointAt');var e=d.length;a=Number(a)||0;if(!(a>=0&&a<e)){return void 0}a=a|0;var b=d.charCodeAt(a);if(b<55296||b>56319||a+1===e){return b}var c=d.charCodeAt(a+1);if(c<56320||c>57343){return b}return (b-55296)*1024+c+9216};return b},'es6-impl','es3');$jscomp.polyfill('String.prototype.endsWith',function(a){if(a){return a}var b=function(a,b){var c=$jscomp.checkStringArgs(this,a,'endsWith');a=a+'';if(b===void 0){b=c.length}var e=Math.max(0,Math.min(b|0,c.length));var d=a.length;while(d>0&&e>0){if(c[--e]!=a[--d]){return !1}}return d<=0};return b},'es6-impl','es3');$jscomp.polyfill('String.fromCodePoint',function(a){if(a){return a}var b=function(d){var b='';for(var c=0;c<arguments.length;c++){var a=Number(arguments[c]);if(a<0||a>1114111||a!==Math.floor(a)){throw new RangeError('invalid_code_point '+a)}if(a<=65535){b+=String.fromCharCode(a)}else {a-=65536;b+=String.fromCharCode(a>>>10&1023|55296);b+=String.fromCharCode(a&1023|56320)}}return b};return b},'es6-impl','es3');$jscomp.polyfill('String.prototype.includes',function(a){if(a){return a}var b=function(a,b){var c=$jscomp.checkStringArgs(this,a,'includes');return c.indexOf(a,b||0)!==-1};return b},'es6-impl','es3');$jscomp.polyfill('String.prototype.repeat',function(a){if(a){return a}var b=function(a){var b=$jscomp.checkStringArgs(this,null,'repeat');if(a<0||a>1342177279){throw new RangeError('Invalid count value')}a=a|0;var c='';while(a){if(a&1){c+=b}if(a>>>=1){b+=b}}return c};return b},'es6-impl','es3');$jscomp.polyfill('String.prototype.startsWith',function(a){if(a){return a}var b=function(a,f){var b=$jscomp.checkStringArgs(this,a,'startsWith');a=a+'';var g=b.length;var d=a.length;var e=Math.max(0,Math.min((f)|0,b.length));var c=0;while(c<d&&e<g){if(b[e++]!=a[c++]){return !1}}return c>=d};return b},'es6-impl','es3');$jscomp.arrayFromIterator=function(c){var b;var a=[];while(!(b=c.next()).done){a.push(b.value)}return a};$jscomp.arrayFromIterable=function(a){if(a instanceof Array){return a}else {return $jscomp.arrayFromIterator($jscomp.makeIterator(a))}};$jscomp.inherits=function(a,b){function tempCtor(){}tempCtor.prototype=b.prototype;a.prototype=new tempCtor();a.prototype.constructor=a;for(var c in b){if(Object.defineProperties){var d=Object.getOwnPropertyDescriptor(b,c);if(d){Object.defineProperty(a,c,d)}}else {a[c]=b[c]}}};$jscomp.polyfill('WeakSet',function(b){function isConformant(){if(!b||!Object.seal){return !1}try{var c=Object.seal({});var d=Object.seal({});var a=new (b)([c]);if(!a.has(c)||a.has(d)){return !1}a['delete'](c);a.add(d);return !a.has(c)&&a.has(d)}catch(e){return !1}}if(isConformant()){return b}var a=function(a){this.map_=new WeakMap();if(a){$jscomp.initSymbol();$jscomp.initSymbolIterator();var d=$jscomp.makeIterator(a);var b;while(!(b=d.next()).done){var c=b.value;this.add(c)}}};a.prototype.add=function(a){this.map_.set(a,!0);return this};a.prototype.has=function(a){return this.map_.has(a)};a.prototype['delete']=function(a){return this.map_['delete'](a)};return a},'es6-impl','es3');try{if(Array.prototype.values.toString().indexOf('[native code]')==-1){delete Array.prototype.values}}catch(a){}Ext.define('ExtX.Reference.Slot',{override:'Ext.Component',slot:null,__COLLECTOR__:null,onRemoved:function(){if(this.__COLLECTOR__){delete this.__COLLECTOR__.slots[this.slot];delete this.__COLLECTOR__}this.callOverridden(arguments)},beforeDestroy:function(){if(this.__COLLECTOR__){delete this.__COLLECTOR__.slots[this.slot];delete this.__COLLECTOR__}this.callOverridden(arguments)}});Ext.define('ExtX.Reference.Slot2',{override:'Ext.Container',slots:null,onAdd:function(){this.cascade(function(a){if(a.slot&&!a.__COLLECTOR__){var b=a.__COLLECTOR__=a.up('{slots}');if(b){b.slots[a.slot]=a}}})},initComponent:function(){if(this.slots){this.slots={}}this.callOverridden()}});Ext.define('Siesta.Project.Browser.UI.AboutWindow',{extend:Ext.Window,id:'aboutwindow',bodyPadding:20,modal:!0,width:500,height:380,closeAction:'destroy',bodyStyle:'background: #fff',autoScroll:!0,initComponent:function(){this.title=Siesta.Resource('Siesta.Project.Browser.UI.AboutWindow','titleText').replace('{VERSION}',Siesta.meta.VERSION||'1.0.0');this.html=Siesta.Resource('Siesta.Project.Browser.UI.AboutWindow','bodyText');this.buttons={padding:'10 13',style:'background: transparent',items:[{hidden:Siesta.Project.Browser.isStandardPackage(),text:Siesta.Resource('Siesta.Project.Browser.UI.AboutWindow','upgradeText'),handler:function(){window.open('https://bryntum.com/store/siesta')}},{text:Siesta.Resource('Siesta.Project.Browser.UI.AboutWindow','closeText'),handler:function(){this.up('window').close()}}]};this.callParent(arguments)}});Ext.define('Siesta.Project.Browser.UI.CanFillAssertionsStore',{processNewResult:function(c,f,a,d){var e={id:a.id,result:a,loaded:!0,leaf:!(a instanceof Siesta.Result.SubTest),expanded:a instanceof Siesta.Result.SubTest&&a.test.specType!='it'};var b=c.getNodeById(a.id);if(b){b.triggerUIUpdate()}else {Ext.suspendLayouts();b=(c.getNodeById(d.id)||c.getRootNode()).appendChild(e);Ext.resumeLayouts()}if(a.isPassed&&!a.isPassed()||a.isWarning){b.ensureVisible()}b.updateFolderStatus()},processEveryTestEnd:function(b,c){var a=b.getNodeById(c.getResults().id);a&&a.updateFolderStatus()}});Ext.define('Sch.data.mixin.FilterableTreeStore',{isFilteredFlag:!1,isHiddenFlag:!1,lastTreeFilter:null,lastTreeHiding:null,allowExpandCollapseWhileFiltered:!0,reApplyFilterOnDataChange:!0,suspendIncrementalFilterRefresh:0,filterGeneration:0,currentFilterGeneration:null,dataChangeListeners:null,monitoringDataChange:!1,filterer:null,onClassMixedIn:function(a){a.override(Sch.data.mixin.FilterableTreeStore.prototype.inheritables()||{})},initTreeFiltering:function(){this.filterer=new Siesta.Util.TreeStoreFilterer({isLeaf:function(a){return a.data.leaf},idProp:'internalId',childNodesProp:'childNodes',parentNodeProp:'parentNode'});this.treeFilter=new Ext.util.Filter({filterFn:this.isNodeFilteredIn,scope:this});this.dataChangeListeners={nodeappend:this.onNeedToUpdateFilter,nodeinsert:this.onNeedToUpdateFilter,scope:this}},startDataChangeMonitoring:function(){if(this.monitoringDataChange){return}this.monitoringDataChange=!0;this.on(this.dataChangeListeners)},stopDataChangeMonitoring:function(){if(!this.monitoringDataChange){return}this.monitoringDataChange=!1;this.un(this.dataChangeListeners)},onNeedToUpdateFilter:function(){if(this.reApplyFilterOnDataChange&&!this.suspendIncrementalFilterRefresh){this.reApplyFilter()}},clearTreeFilter:function(){if(!this.isTreeFiltered()){return}this.currentFilterGeneration=null;this.isFilteredFlag=!1;this.lastTreeFilter=null;if(!this.isTreeFiltered(!0)){this.stopDataChangeMonitoring()}this.refreshNodeStoreContent();this.fireEvent('filter-clear',this)},reApplyFilter:function(){if(this.isHiddenFlag){this.hideNodesBy.apply(this,this.lastTreeHiding.concat(this.isFilteredFlag))}if(this.isFilteredFlag){this.filterTreeBy(this.lastTreeFilter)}},refreshNodeStoreContent:function(){var a=this,b=a.getFilters();if(b.indexOf(a.treeFilter)<0){a.addFilter(a.treeFilter)}else {this.getFilters().fireEvent('endupdate',this.getFilters())}},getIndexInTotalDataset:function(a){var b=this.getRootNode(),e=-1;var d=this.rootVisible;if(!d&&a==b){return -1}var g=this.isTreeFiltered();var f=this.currentFilterGeneration;var c=function(h){if(g&&h.__filterGen!=f||h.hidden){if(h==a){return !1}}if(d||h!=b){e++}if(h==a){return !1}if(!h.data.leaf&&h.isExpanded()){var j=h.childNodes,k=j.length;for(var i=0;i<k;i++){if(c(j[i])===!1){return !1}}}};c(b);return e},isTreeFiltered:function(a){return this.isFilteredFlag||a&&this.isHiddenFlag},markFilteredNodes:function(d){var e=this;var c=this.currentFilterGeneration;var a=this.getRootNode();var b=this.filterer.collectNodes(a,Ext.apply({rootVisible:this.rootVisible},d));a.cascadeBy(function(a){if(b[a.internalId]){a.__filterGen=c;if(e.allowExpandCollapseWhileFiltered&&!a.data.leaf){a.expand()}}})},filterTreeBy:function(a,c){this.currentFilterGeneration=this.filterGeneration++;var b;if(arguments.length==1&&Ext.isObject(arguments[0])){c=a.scope;b=a.filter}else {b=a;a={filter:b,scope:c}}this.fireEvent('nodestore-datachange-start',this);a=a||{};this.markFilteredNodes(a);this.startDataChangeMonitoring();this.isFilteredFlag=!0;this.lastTreeFilter=a;this.refreshNodeStoreContent();this.fireEvent('nodestore-datachange-end',this);this.fireEvent('filter-set',this)},isNodeFilteredIn:function(a){var c=this.isTreeFiltered();var b=this.currentFilterGeneration;return this.loading||!Boolean(c&&a.__filterGen!=b||a.hidden)},hasNativeFilters:function(){var c=this,a=c.getFilters(),b=a.getCount();return b&&b>1||a.indexOf(c.treeFilter)<0},hideNodesBy:function(c,b,d){var a=this;if(a.isFiltered()&&a.hasNativeFilters()){throw new Error("Can't hide nodes of the filtered tree store")}b=b||a;a.getRootNode().cascadeBy(function(d){d.hidden=Boolean(c.call(b,d,a))});a.startDataChangeMonitoring();a.isHiddenFlag=!0;a.lastTreeHiding=[c,b];if(!d){a.refreshNodeStoreContent()}},showAllNodes:function(a){this.getRootNode().cascadeBy(function(a){a.hidden=!1});this.isHiddenFlag=!1;this.lastTreeHiding=null;if(!this.isTreeFiltered(!0)){this.stopDataChangeMonitoring()}if(!a){this.refreshNodeStoreContent()}},inheritables:function(){return {onNodeExpand:function(a,c,b){if(this.isTreeFiltered(!0)&&a==this.getRoot()){this.callParent(arguments);this.reApplyFilter()}else {return this.callParent(arguments)}},onNodeCollapse:function(g,b,h,i,j){var a=this;var c=a.data;var e=c.contains;var f=a.isTreeFiltered();var d=a.currentFilterGeneration;c.contains=function(){var h,c,j;var k=a.indexOf(g)+1;var l=!1;for(var i=0;i<b.length;i++){if(!(b[i].hidden||f&&b[i].__filterGen!=d)&&e.call(this,b[i])){h=g;while(h.parentNode){c=h;do{c=c.nextSibling}while(c&&(c.hidden||f&&c.__filterGen!=d));if(c){l=!0;j=a.indexOf(c);break}else {h=h.parentNode}}if(!l){j=a.getCount()}a.removeAt(k,j-k);break}}return !1};this.callParent(arguments);c.contains=e},handleNodeExpand:function(h,d,i){var e=this;var a=[];var g=e.isTreeFiltered();var f=e.currentFilterGeneration;for(var c=0;c<d.length;c++){var b=d[c];if(!(g&&b.__filterGen!=f||b.hidden)){a[a.length]=b}}return this.callParent([h,a,i])},onNodeInsert:function(f,a,m){var b=this,e,c,l,i,d,k,n=a.raw||a.data,j,h,g;if(b.filterFn){h=b.filterFn(a);a.set('visible',h);if(h){f.set('visible',b.filterFn(f))}}b.registerNode(a,!0);b.beginUpdate();if(b.isVisible(a)){if(m===0||!a.previousSibling){e=f}else {for(c=a.previousSibling;c&&!c.get('visible');c=c.previousSibling){}if(!c){e=f}else {while(c.isExpanded()&&c.lastChild){c=c.lastChild}e=c}}b.insert(b.indexOf(e)+1,a);if(!a.isLeaf()&&a.isExpanded()){if(a.isLoaded()){b.onNodeExpand(a,a.childNodes)}else {if(!b.fillCount){a.set('expanded',!1);a.expand()}}}}else {b.needsSync=b.needsSync||a.phantom||a.dirty}if(!a.isLeaf()&&!a.isLoaded()&&!b.lazyFill){l=b.getProxy().getReader();i=a.getProxy();d=i?i.getReader():null;k=d&&d.initialConfig.rootProperty?d:l;j=k.getRoot(n);if(j){g=a.childType;b.fillNode(a,k.extractData(j,g?{model:g}:undefined))}}b.endUpdate()},isFiltered:function(){return this.callParent(arguments)||this.isTreeFiltered()}}}});Ext.define('Siesta.Project.Browser.Model.Assertion',{extend:Ext.data.Model,idProperty:'id',proxy:{type:'memory'},fields:['id',{name:'folderStatus',defaultValue:'yellow'},{name:'result'}],getResult:function(){return this.data.result},isAssertion:function(){return this.data.result instanceof Siesta.Result.Assertion},isDiagnostic:function(){return this.data.result instanceof Siesta.Result.Diagnostic},isSummary:function(){return this.data.result instanceof Siesta.Result.Summary},ensureVisible:function(){var a=this.parentNode;while(a&&!a.isRoot()){a.expand();a=a.parentNode}},isWaitingAssertion:function(){var a=this.data.result;return this.isAssertion()&&a.isWaiting&&!a.completed},updateFolderStatus:function(){if(!this.isLeaf()){this.set('folderStatus',this.computeFolderStatus())}var a=this.parentNode;if(a&&!a.isRoot()){a.updateFolderStatus()}},triggerUIUpdate:function(){this.callJoined('afterEdit',[])},computeFolderStatus:function(){if(!this.isLeaf()&&this.getResult().isWorking()){return 'working'}if(!this.childNodes.length){return 'yellow'}var c=!1;var b=!1;var a=!0;Joose.A.each(this.childNodes,function(d){var f=d.getResult();if(d.isLeaf()){if(d.isWaitingAssertion()){c=!0}if(d.isAssertion()){if(!f.isPassed()){a=!1;b=!0;return !1}}}else {var e=d.computeFolderStatus();if(e=='red'){a=!1;b=!0;return !1}if(f.isWorking()||e=='working'){c=!0;return !1}if(e=='yellow'){a=!1}}});if(c){return 'working'}if(b){return 'red'}if(a){return 'green'}return 'yellow'}});Ext.define('Siesta.Project.Browser.Model.AssertionTreeStore',{extend:Ext.data.TreeStore,model:'Siesta.Project.Browser.Model.Assertion',mixins:[Sch.data.mixin.FilterableTreeStore],constructor:function(){this.callParent(arguments);this.initTreeFiltering()},removeAll:function(){var a=this.setRootNode({id:'__ROOT__',expanded:!0,loaded:!0})},add:function(a){this.getRootNode().appendChild(a)}});Ext.define('Sch.mixin.FilterableTreeView',{filterableTreeStore:null,treeStoreFilteringListeners:null,initTreeFiltering:function(){this.treeStoreFilteringListeners={'nodestore-datachange-start':this.onFilterChangeStart,'nodestore-datachange-end':this.onFilterChangeEnd,'filter-clear':this.onFilterCleared,'filter-set':this.onFilterSet,'forcedrefresh':this.onForcedRefresh,scope:this};var a=function(){var a=this.up('tablepanel').store;this.bindFilterableTreeStore(a)};if(this.rendered){a.call(this)}else {this.on('beforerender',a,this,{single:!0})}},bindFilterableTreeStore:function(a){if(this.filterableTreeStore){this.mun(this.filterableTreeStore,this.treeStoreFilteringListeners)}this.filterableTreeStore=a;if(a){this.mon(a,this.treeStoreFilteringListeners)}},onForcedRefresh:function(){this.focusRow=function(){};this.refresh();delete this.focusRow},onFilterChangeStart:function(){Ext.suspendLayouts()},onFilterChangeEnd:function(){Ext.resumeLayouts(!0)},onFilterCleared:function(){},onFilterSet:function(){}});Ext.define('Siesta.Project.Browser.UI.FilterableTreeView',{extend:Ext.tree.View,alias:'widget.filterabletreeview',mixins:[Sch.mixin.FilterableTreeView],constructor:function(){this.callParent(arguments);this.initTreeFiltering()},bindStore:function(a,c,b){if(a instanceof Ext.data.TreeStore){this.bindFilterableTreeStore(a);this.callParent([a.nodeStore||a,c,b])}else {this.callParent(arguments)}}});Ext.define('Siesta.Project.Browser.UI.AssertionTreeColumn',{extend:Ext.tree.Column,alias:'widget.assertiontreecolumn',imgWithOffsetText:'<img src="{1}" class="{0}" style="left:{2}px" />',tdCls:'tr-tree-column',resultTpl:null,dataIndex:'folderStatus',menuDisabled:!0,sortable:!1,width:500,descriptionTpl:'<span class="assertion-text">{text}</span>',initComponent:function(){this.descriptionTpl=this.descriptionTpl instanceof Ext.XTemplate?this.descriptionTpl:new Ext.XTemplate(this.descriptionTpl);Ext.apply(this,{scope:this});this.callParent(arguments)},renderer:function(i,f,c,g,e,h){var d='';var a=c.data.result;var b=a.annotation;if(a instanceof Siesta.Result.Summary){return c.data.result.description.join('<br>')}d=this.descriptionTpl.apply({text:Ext.String.htmlEncode(a.isWarning?'WARN: '+a.description:a.description)});if(b){d+='<pre title="'+b.replace(/"/g,"'")+'" style="margin-left:'+c.data.depth*16+'px" class="tr-assert-row-annotation">'+Ext.String.htmlEncode(b).replace('[code]','<code>').replace('[/code]','</code>');+'</pre>'}return d},treeRenderer:function(d,c,a){var b=a.getResult();if(b instanceof Siesta.Result.Assertion){if(b.isWaitFor){a.data.iconCls=b.completed?'fa-clock-o':'fa-spinner fa-spin'}else {if(b.isException){a.data.iconCls='fa-flag'}else {a.data.iconCls=b.passed?'fa-check':'fa-bug'}}}else {if(b instanceof Siesta.Result.SubTest){if(a.get('folderStatus')==='working'){a.data.iconCls='fa-spinner fa-spin'}else {a.data.iconCls=''}}}return this.callParent(arguments)}});Ext.define('Siesta.Project.Browser.UI.AssertionGrid',{alias:'widget.assertiongrid',extend:Ext.tree.Panel,mixins:[Siesta.Project.Browser.UI.CanFillAssertionsStore],cls:'siesta-assertion-grid',enableColumnHide:!1,enableColumnMove:!1,enableColumnResize:!1,sortableColumns:!1,useArrows:!0,border:!1,minWidth:100,trackMouseOver:!1,autoScrollToBottom:!0,hideHeaders:!0,rowLines:!1,rootVisible:!1,collapseDirection:'left',viewType:'filterabletreeview',lines:!1,disableSelection:!0,bufferedRenderer:!1,isStandalone:!1,test:null,testListeners:null,initComponent:function(){var a=this;this.testListeners=[];if(!this.store){this.store=new Siesta.Project.Browser.Model.AssertionTreeStore({proxy:'memory',root:{id:'__ROOT__',expanded:!0,loaded:!0}})}Ext.apply(this,{columns:[this.assertionColumn=new Siesta.Project.Browser.UI.AssertionTreeColumn()],viewConfig:{enableTextSelection:!0,stripeRows:!1,markDirty:!1,animate:!1,trackOver:!1,store:new Ext.data.Store({fields:[],data:[]}),deferInitialRefresh:!1,getRowClass:this.getRowClass},listeners:{itemexpand:this.adaptColumnSize,scope:this}});this.callParent(arguments);this.getView().on('itemadd',this.onMyItemAdd,this)},onMyItemAdd:function(a){if(!this.test.isFinished()&&this.autoScrollToBottom){this.ensureVisible(a[0])}},getRowClass:function(c,e,d,f){var a=c.getResult();var b='';switch(a.meta.name){case 'Siesta.Result.Diagnostic':return 'tr-diagnostic-row '+(a.isWarning?'tr-warning-row':'');case 'Siesta.Result.Summary':return 'tr-summary-row '+(a.isFailed?' tr-summary-failure':'');case 'Siesta.Result.SubTest':b='tr-subtest-row tr-subtest-row-'+c.get('folderStatus');if(a.test.specType=='describe'){b+=' tr-subtest-row-describe'};if(a.test.specType=='it'){b+=' tr-subtest-row-it'};return b;case 'Siesta.Result.Assertion':b+='tr-assertion-row ';if(a.isWaitFor){b+='tr-waiting-row '+(a.completed?a.passed?'tr-waiting-row-passed':'tr-assertion-row-failed tr-waiting-row-failed':'')}else {if(a.isException){b+=a.isTodo?'tr-exception-todo-row':'tr-exception-row'}else {if(a.isTodo){b+=a.passed?'tr-todo-row-passed':'tr-todo-row-failed'}else {b+=a.passed?'tr-assertion-row-passed':'tr-assertion-row-failed'}}};return b;default:throw 'Unknown result class';}},showTest:function(a,b){if(this.test){Joose.A.each(this.testListeners,function(a){a.remove()});this.testListeners=[]}this.test=a;this.testListeners=[].concat(this.isStandalone?[a.on('testupdate',this.onTestUpdate,this),a.on('testendbubbling',this.onEveryTestEnd,this),a.on('assertiondiscard',this.onAssertionDiscarded,this)]:[a.on('testfinalize',this.adaptColumnSize,this)]);Ext.suspendLayouts();if(b){if(this.store!==b){this.reconfigure(b)}}else {if(this.getStore().getRoot().childNodes.length>0){this.store.removeAll()}}Ext.resumeLayouts()},onTestUpdate:function(d,c,b,a){this.processNewResult(this.store,c,b,a)},adaptColumnSize:function(){var b=this.getHeaderContainer();var a=this.getView().getMaxContentWidth(this.assertionColumn);this.assertionColumn.setWidth(Math.max(a,this.getWidth()))},onResize:function(){this.callParent(arguments);this.adaptColumnSize()},onEveryTestEnd:function(b,a){this.processEveryTestEnd(this.store,a)},onAssertionDiscarded:function(b,c,a){this.store.getNodeById(a.id).remove()},bindStore:function(a,b,c){this.callParent(arguments);this.store=a;if(a&&a.nodeStore){this.getView().dataSource=a.nodeStore;this.getView().bindStore(a,b,c)}},destroy:function(){Joose.A.each(this.testListeners,function(a){a.remove()});this.testListeners=[];this.test=null;this.callParent(arguments)},setInitializing:function(a){if(a){this.getView().addCls('siesta-test-initializing')}else {this.getView().removeCls('siesta-test-initializing')}}});Ext.define('Siesta.Project.Browser.UI.CanCopyToClipboard',{copyToClipboard:function(c){var a=this.getCopyToClipboardTextarea();a.value=c;a.focus();a.select();try{var b=document.execCommand('copy')}catch(d){}return b},getCopyToClipboardTextarea:function(){var a=document.getElementById('fa-copy-to-clipboard');if(!a){a=document.createElement('textarea');a.id='fa-copy-to-clipboard';a.style.position='absolute';a.style.left='-10000px';a.style.top='-10000px';document.body.appendChild(a)}return a}});Ext.define('Siesta.Project.Browser.UI.ComponentInspector',{extend:Ext.util.Observable,inspectedComponent:null,inspectedComponentXType:null,boxIndicatorEl:null,active:!1,window:null,trackMouse:!0,showSelectorText:!0,bufferTime:30,injectIntoTestFrame:!1,getIndicatorEl:function(){return this.boxIndicatorEl},getExt:function(){return this.window.Ext},start:function(a,e){a=a||this.window;if(!a){throw 'Must provide a window context for the inspector'}this.window=a;var c=this.getExt();var d=this;var f=this.injectIntoTestFrame?a.document.body:e||a.document.body;var b='box-sizing: border-box;-moz-box-sizing: border-box;-ms-box-sizing: border-box;-webkit-box-sizing: border-box;';d.boxIndicatorEl=d.boxIndicatorEl||Ext.fly(f).createChild({cls:'target-inspector-box',style:'position : absolute;left:0;top:0;pointer-events : none;z-index : 100001; border : 2px solid red;transition-property : transform,border-color;transition-duration : 0.3s;',children:[{tag:'div',style:'border:1px solid;border-color:inherit;width : 13px; height : 13px;position : absolute;margin-top : -8px;margin-left : -8px;border-radius:19px;transition-property : transform;transition-duration : 0.3s;'+b,cls:'target-inspector-coordinate',html:'<div style="border-left: 1px solid;border-color:inherit;position: absolute;top: -3px;left: 5px;height: 6px;'+b+'"></div>'+'<div style="border-left: 1px solid;border-color:inherit;position: absolute;bottom: -3px;left: 5px;height: 6px;'+b+'"></div>'+'<div style="border-top: 1px solid;border-color:inherit;position: absolute;top: 5px;left: -3px;width: 6px;'+b+'"></div>'+'<div style="border-top: 1px solid;border-color:inherit;position: absolute;top: 5px;right: -3px;width: 6px;'+b+'"></div>'}].concat(this.showSelectorText?{tag:'a',cls:'target-inspector-label',target:'_blank'}:[])});if(this.trackMouse&&c&&c.getBody){this.toggleMouseMoveListener(!0);c.getBody().on('click',this.onInspectionClick,{me:this})}this.fireEvent('start',this);this.active=!0},stop:function(b){if(!this.active){return}this.active=!1;var a=this.getExt();Ext.destroy(this.boxIndicatorEl);this.boxIndicatorEl=null;if(!b){this.fireEvent('stop',this)}if(a&&a.getBody){this.toggleMouseMoveListener(!1);a.getBody().un('click',this.onInspectionClick,{me:this})}this.inspectedComponent=this.inspectedComponentXType=null},toggleMouseMoveListener:function(f){var b=this.getExt();if(!b){return}var d=b.getBody().select('iframe');var e=f?'on':'un';b.getBody()[e]('mousemove',this.onMouseMove,{me:this},{buffer:this.bufferTime});for(var c=0;c<d.getCount();c++){var a=d.item(c).dom.contentWindow.Ext;a&&a.getBody&&a.getBody()[e]('mousemove',this.onMouseMove,{me:this},{buffer:this.bufferTime})}},onInspectionClick:function(c,b){if(!this.boxIndicatorEl){return}var a=this.me;a.toggleMouseMoveListener(!1);if(!a.inspectedComponent||a.findComponentByTarget(b)!==a.inspectedComponent){a.stop()}else {a.fireEvent('targetselected',a,a.inspectedComponent,a.inspectedComponentXType)}},onMouseMove:function(e,d){var a=this.me;if(!a.boxIndicatorEl){return}var b=a.findComponentByTarget(d);if(b){if(b===a.inspectedComponent){return}var c=a.resolveComponentXtype(b);a.inspectedComponent=b;a.inspectedComponentXType=c;a.highlightTarget(b.el.dom);a.updateHighlightContent(b,c);a.fireEvent('targethover',a,a.inspectedComponent,a.inspectedComponentXType)}},resolveComponentXtype:function(a){var b=a.getXType&&a.getXType()||a.xtype;if(!b){var c=a;for(var d=0;d<10&&!b;d++){c=a.superclass;b=c.xtype}}return b},updateHighlightContent:function(c,j){var a;var b={tag:'a',cls:'target-inspector-label',href:'#'};if(typeof c==='string'){a=c}else {if(Ext.ClassManager){var e=Ext.ComponentQuery.query('recorderpanel')[0];var f=c.el.dom.ownerDocument.defaultView;var k=f&&f.Ext&&f.Ext.ComponentQuery;if(e&&e.isVisible()){var d;if(k&&e.recorder.extractor.findComponentQueryFor){d=e.recorder.extractor.findComponentQueryFor(c);d=d&&d.query||j}a='>>'+(d||j)}else {var h=this.findExtAncestorClassName(c);if(h){var l=Siesta.Resource('Siesta.Project.Browser.UI.DomContainer','docsUrlText');var g;if(Ext.versions.touch){g='touch'}else {g='extjs'}b.target='_blank';b.href=Ext.String.format(l,g,h);b.title=Siesta.Resource('Siesta.Project.Browser.UI.DomContainer','viewDocsText')+h}a=j}}}if(a){b.html=a;var i=this.boxIndicatorEl.down('.target-inspector-label',!0);i.href=b.href;i.title=b.title;i.innerHTML=a}},highlightTarget:function(a,h,c){var b=this.boxIndicatorEl.dom.style;if(!this.active){this.start()}if(a){var i=this.getOffsets(a);var f=Ext.fly(a).getX()-2+i[0];var g=Ext.fly(a).getY()-2+i[1];var k=(Ext.fly(a).getWidth()||parseInt(a.style.width.substring(0,a.style.width.length-2),10))+2;var j=(Ext.fly(a).getHeight()||parseInt(a.style.height.substring(0,a.style.height.length-2),10))+2;if(this.injectIntoTestFrame){f+=this.window.document.body.scrollLeft;g+=this.window.document.body.scrollTop}var d=bowser.opera?'translate('+f+'px,'+g+'px)':'translate3d('+f+'px,'+g+'px, 0)';b.setProperty('transform',d);b.width=k+'px';b.height=j+'px';b['border-color']='red';if(this.showSelectorText&&h){this.updateHighlightContent(h)}}else {b['border-color']='#ccc'}var e=this.boxIndicatorEl.down('.target-inspector-coordinate',!0);if(c){d=bowser.opera?'translate('+c[0]+'px,'+c[1]+'px)':'translate3d('+c[0]+'px, '+c[1]+'px, 0)';e.style.setProperty('display','block');e.style.setProperty('transform',d)}else {e.style.setProperty('display','none')}},findComponentByTarget:function(a){var c=this.getExt();var e=this.window.document;if(a.ownerDocument!==e){var d=(a.ownerDocument.parentWindow||a.ownerDocument.defaultView).frameElement;c=d.contentWindow.Ext}var b;while(!b&&a&&a.nodeName!=='BODY'){b=c.getCmp(a.id);a=a.parentNode}return b},getOffsets:function(a){var d=this.window.document;var b=[0,0];if(a.ownerDocument!==d){var c=(a.ownerDocument.parentWindow||a.ownerDocument.defaultView).frameElement;b=Ext.fly(c).getXY();b[0]-=a.ownerDocument.body.scrollLeft;b[1]-=a.ownerDocument.body.scrollTop}return b},findExtAncestorClassName:function(a){while(a){var b=Ext.ClassManager.getName(a);if(b.match(/^Ext./)){return b}a=a.superclass}return ''}});Ext.define('Siesta.Project.Browser.UI.TreeFilterField',{extend:Ext.form.field.Text,alias:'widget.treefilter',filterGroups:!1,cls:'filterfield',store:null,filterField:'text',hasAndCheck:null,andChecker:null,andCheckerScope:null,triggerLeafCls:'fa-file-o',triggerGroupCls:'fa-folder-o',tipText:null,constructor:function(b){var a=this;Ext.apply(b,{triggers:{clear:{cls:'fa-close',handler:function(){a.store.clearTreeFilter();a.reset()}},leafOrGroup:{cls:a.triggerLeafCls,handler:function(){a.setFilterGroups(!a.getFilterGroups())}}},listeners:{change:{fn:this.onFilterChange,buffer:400,scope:this},specialkey:this.onFilterSpecialKey,scope:this}});this.callParent(arguments)},afterRender:function(){this.callParent(arguments);this.tipText&&this.inputEl.set({title:this.tipText});if(this.filterGroups){this.triggerEl.item(1).addCls(this.triggerGroupCls);this.triggerEl.item(1).removeCls(this.triggerLeafCls)}},onFilterSpecialKey:function(b,a,c){if(a.keyCode===a.ESC){this.store.clearTreeFilter();b.reset()}},setFilterGroups:function(b){if(b!=this.filterGroups){this.filterGroups=b;if(this.rendered){var a=this.triggerEl.item(1);if(b){a.addCls(this.triggerGroupCls);a.removeCls(this.triggerLeafCls)}else {a.removeCls(this.triggerGroupCls);a.addCls(this.triggerLeafCls)}}this.refreshFilter();this.fireEvent('filter-group-change',this)}},getFilterGroups:function(){return this.filterGroups},refreshFilter:function(){this.onFilterChange(this,this.getValue())},onFilterChange:function(k,b){if(b||this.hasAndCheck&&this.hasAndCheck()){var c=this.store.filterer;var i=this.filterField;var a;var d;var e=this.filterGroups;if(e){a=c.splitTermByPipe(b)}else {var g=c.parseFilterValue(b);a=g.testFilterRegexps;d=g.groupFilterRegexps}var f=this.andChecker;var h=this.andCheckerScope||this;var j=function(a){return a.get(i)};this.store.filterTreeBy({filter:function(b){if(f&&!f.call(h,b)){return !1}return c.checkCommonFilter(b,j,a,d)},fullMatchingParents:e})}else {this.store.clearTreeFilter()}}});Ext.define('Siesta.Project.Browser.Model.FilterableTreeStore',{extend:Ext.data.TreeStore,mixins:[Sch.data.mixin.FilterableTreeStore],constructor:function(){this.callParent(arguments);this.initTreeFiltering()},forEach:function(b,a){this.getRootNode().cascadeBy(b,a)}});Ext.define('Siesta.Project.Browser.UI.DomContainer',{extend:Ext.Panel,alias:'widget.domcontainer',cls:'siesta-domcontainer',header:!1,collapsible:!0,animCollapse:!1,padding:10,test:null,testListeners:null,scaleToFit:!0,scaleToFitMode:'full',maintainViewportSize:!0,canManageDOM:!0,suspendAfterLayoutAlign:!1,inspector:null,inspectorConfig:null,enableConsole:!0,trackMouse:!0,initComponent:function(){var a=this;this.testListeners=[];this.title=Siesta.Resource('Siesta.Project.Browser.UI.DomContainer','title');if(this.enableConsole){Ext.apply(this,{dockedItems:this.consoleCt={xtype:'component',dock:'bottom',hidden:!0,height:20,cls:'domcontainer-console',renderTpl:'<div><input type="text" /></div>'}})}this.callParent();this.on({afterlayout:this.onAfterLayout,expand:this.onExpand,collapse:this.onCollapse,scope:this});this.inspector=new Siesta.Project.Browser.UI.ComponentInspector(this.inspectorConfig);if(this.trackMouse){this.inspector.on({start:this.onInspectionStart,stop:this.onInspectionStop,scope:this})}this.relayEvents(this.inspector,['start','stop'],'inspection');this.enableBubble('statechange')},afterRender:function(){this.callParent(arguments);if(this.enableConsole){var a=this.consoleInput=this.el.down('.domcontainer-console input');this.inspector.on('targethover',function(c,b){a.dom.value='Ext.getCmp("'+b.id+'").'});this.inspector.on('targetselected',function(c,b){a.focus(!0)});a.on({keyup:function(c,f){var b=a.dom.value;if(c.getKey()===c.ENTER&&b){var e=this.getIFrame();try{var d=e.contentWindow.eval(b);if(window.console){console.log(d)}}catch(g){window.console&&console.log(g.message)}}},scope:this})}},setScaleToFit:function(b,a){if(this.scaleToFit==b&&(!a||this.scaleToFitMode==a)){return}this.scaleToFit=b;if(a){this.scaleToFitMode=a}if(b){this.doScaleToFit()}else {this.undoScaleToFit()}this.fireEvent('statechange')},doScaleToFit:function(p){var d=this.getIFrame();if(!d){return}var c=this.scaleToFitMode;var j=Ext.getScrollbarSize();var a=d.parentNode;var g=a.parentNode;var n=g.parentNode;var i=this.body.dom.offsetWidth-(c==='width'?j.width:0);var h=this.body.dom.offsetHeight-(c==='height'?j.height:0);var f=d.offsetWidth;var e=d.offsetHeight;var m=i/f;var l=h/e;var b=c==='width'?m:c==='height'?l:Math.min(m,l);var q=i-b*f;var o=h-b*e;var r=Math.max(0,q/2);var s=Math.max(0,o/2);a.style.transition=p?'none':'transform 0.3s';a.style.transform='translate('+r+'px, '+s+'px) scale('+b+') ';g.style.width=b*f+'px';g.style.height=b*e+'px';this.removeScaleToFitClasses(n);Ext.fly(n).addCls('scaleToFit'+Joose.S.uppercaseFirst(c));this.scrollTo(0,0);var k=this.test.scopeProvider.minViewportSize;a.style.width=k.width+'px';a.style.height=k.height+'px'},removeScaleToFitClasses:function(a){Ext.fly(a).removeCls('scaleToFitFull');Ext.fly(a).removeCls('scaleToFitWidth');Ext.fly(a).removeCls('scaleToFitHeight')},undoScaleToFit:function(){var b=this.getIFrame();if(!b){return}var a=b.parentNode;var c=a.parentNode;this.removeScaleToFitClasses(c.parentNode);a.style.transform='';a.style.width=b.style.width;a.style.height=b.style.height;a.style.left='';a.style.top='';c.style.width=b.style.width;c.style.height=b.style.height},setCanManageDOM:function(a){this.canManageDOM=a;if(a&&!this.hidden){this.alignIFrame()}},getIFrameWrapper:function(b){var a=this.test;if(a){return (this.canManageDOM||b)&&a.scopeProvider&&a.scopeProvider.wrapper||null}else {return null}},getIFrame:function(b){var a=this.test;if(a){return (this.canManageDOM||b)&&a.scopeProvider&&a.scopeProvider.iframe||null}else {return null}},onAfterLayout:function(){if(!this.suspendAfterLayoutAlign){this.alignIFrame()}},alignIFrame:function(b,d){var a=this.getIFrameWrapper(b);if(!this.isFrameVisible()||!a){return}Ext.fly(a).removeCls('tr-iframe-hidden');Ext.fly(a).removeCls('tr-iframe-forced');var e=this.body.getBox();Ext.fly(a).setBox(e);if(!this.maintainViewportSize){Ext.fly(this.getIFrame(b)).setSize(this.body.getSize())}if(this.scaleToFit){this.doScaleToFit(d)}else {this.undoScaleToFit()}var c=this.test;c&&c.fireEvent('testframeshow')},onCollapse:function(){this.hideIFrame()},onExpand:function(){this.alignIFrame()},hideIFrame:function(){var a=this.getIFrameWrapper();a&&Ext.fly(a).setStyle({left:'-10000px',top:'-10000px'});var b=this.test;b&&b.fireEvent('testframehide')},isFrameVisible:function(){return !(this.hidden||this.collapsed)},showTest:function(a){this.stopInspection();if(this.test){Joose.A.each(this.testListeners,function(a){a.remove()});this.testListeners=[];this.hideIFrame()}this.test=a;this.testListeners=[a.on('testfinalize',this.onTestFinalize,this)];this.setCanManageDOM(!a.hasForcedIframe());this.alignIFrame(!1,!0)},onTestFinalize:function(b,a){this.setCanManageDOM(!0);if(this.isFrameVisible()){a.forceDOMVisible=!1;a.isDOMForced=!1}},destroy:function(){Ext.destroy(this.boxIndicator);this.boxIndicator=null;this.hideIFrame();Joose.A.each(this.testListeners,function(a){a.remove()});this.test=null;this.callParent(arguments)},inspectedComponent:null,inspectedComponentXType:null,boxIndicator:null,inspecting:!1,toggleInspectionMode:function(a){if(!this.test){return}if(a){this.startInspection()}else {this.stopInspection()}},startInspection:function(b){if(!this.test||!this.test.global){return}var a=Ext.get(this.getIFrameWrapper());this.inspector.start(this.test.global,a.down('.tr-iframe-wrapper-inner',!0));if(this.trackMouse){a.un('mouseout',this.onMouseLeave,this);a.on('mouseout',this.onMouseLeave,this)}if(this.enableConsole&&b!==!1){if(!(this.consoleCt instanceof Ext.Component)){this.consoleCt=Ext.widget(this.consoleCt)}this.consoleCt.show()}this.addCls('inspection-mode')},stopInspection:function(){this.inspector.stop();this.removeCls('inspection-mode');if(this.enableConsole&&this.consoleCt.rendered){this.consoleCt.hide()}},onMouseLeave:function(a,b){if(!this.el.contains(a.relatedTarget)&&!Ext.fly(this.getIFrameWrapper()).contains(a.relatedTarget)){this.stopInspection()}},onInspectionStart:function(){var a=Ext.get(this.getIFrameWrapper());if(a){a.on('mouseout',this.onMouseLeave,this)}},onInspectionStop:function(){var a=Ext.get(this.getIFrameWrapper());if(a){a.un('mouseout',this.onMouseLeave,this)}},clearHighlight:function(){this.stopInspection()},highlightTarget:function(a,d,b){var c=a instanceof Array;if(!this.inspector.active){this.startInspection()}if(c){b=a;a=null}else {a=this.test.normalizeElement(a,!0,!0,!1);if(a){if(!a.offsetWidth&&!a.offsetHeight){a=b=null}else {if(b){b=this.test.normalizeOffset(b,$(a))}}}}this.inspector.highlightTarget(a,d,b)}});Ext.XTemplate.override({strict:!0});Ext.data.Connection.override({parseStatus:function(b){var a=this.callOverridden(arguments);if(b===0){a.success=!0}return a}});!function(){Ext.util.XTemplateCompiler.prototype.useEval=!1;Ext.Template.prototype.useEval=!1;window.$=window.jQuery;var a=Ext.data.schema.Schema.get('default').getProxy();a.apply=a.compile(a.template)}();Ext.define('Siesta.Project.Browser.UI.SourcePanel',{extend:Ext.Panel,alias:'widget.sourcepanel',__filled__:!1,autoScroll:!0,cls:'test-source-ct',layout:'absolute',border:!1,bodyBorder:!1,setSource:function(d,b){var a=this.el;if(!this.__filled__){this.__filled__=!0;this.update(Ext.String.format('<pre class="brush: javascript;">{0}</pre>',d));SyntaxHighlighter.defaults['quick-code']=!1;SyntaxHighlighter.highlight(a)}a.select('.highlighted').removeCls('highlighted');Ext.Array.each(b,function(b){a.select('.line.number'+b).addCls('highlighted')});if(b.length>0){var c=a.down('.highlighted');c&&c.scrollIntoView(a)}},clear:function(){this.__filled__=!1}});Ext.define('Siesta.Project.Browser.UI.ResultPanel',{extend:Ext.Panel,alias:'widget.resultpanel',slots:!0,test:null,testListeners:null,maintainViewportSize:!0,scaleToFit:!0,scaleToFitMode:'full',viewDOM:!1,border:!1,canManageDOM:!0,project:null,isStandalone:!1,showToolbar:!0,title:'Result panel',header:!1,minWidth:100,layout:'border',sourceButton:null,filterButton:null,inspectionButton:null,recorderPanel:null,recorderConfig:null,recorderPanelClass:'Siesta.Recorder.UI.RecorderPanel',domContainerRegion:'east',isReadOnlyReport:!1,initComponent:function(){var c=this;var b=Siesta.Resource('Siesta.Project.Browser.UI.ResultPanel');var a=this.domContainerRegion||'east';Ext.apply(this,{cls:'tr-container',tbar:{cls:'resultpanel-toolbar',defaults:{tooltipType:'title',scope:this},items:this.getTopToolbarItems(b)},items:[{region:'center',slot:'cardContainer',xtype:'container',layout:{type:'card',deferredRender:!0},activeItem:0,minWidth:100,items:[{xtype:'assertiongrid',slot:'grid',isStandalone:this.isStandalone,listeners:{itemdblclick:this.onAssertionDoubleClick,scope:this}},{xtype:'sourcepanel',slot:'source',listeners:{render:function(a){var b=a.getEl().appendChild({cls:'si-sourcepanel-close fa-close',style:'right:'+(Ext.getScrollbarSize().width+5)+'px'});b.on('click',this.hideSource,this)},scope:this}}].concat(Ext.ClassManager.getByAlias('widget.coveragereport')?{xtype:'coverage'+'report',slot:'coverageReport',project:this.project}:[])},{xtype:'domcontainer',region:a,collapsible:!0,hidden:this.isReadOnlyReport,split:{size:7},bodyStyle:'text-align : center',slot:'domContainer',stateful:!0,id:this.id+'-domContainer',width:a=='east'||a=='west'?'50%':null,height:a=='south'||a=='north'?'50%':null,cls:'siesta-domcontainer',collapsed:!this.viewDOM,scaleToFit:this.scaleToFit,scaleToFitMode:this.scaleToFitMode}]});this.callParent();this.slots.domContainer&&this.slots.domContainer.on({expand:this.onDomContainerExpand,collapse:this.onDomContainerCollapse,inspectionstart:function(){this.inspectionButton.toggle(!0)},inspectionstop:function(){this.inspectionButton.toggle(!1)},scope:this})},onLoadReportFileChange:function(c){var b=this;var d=c.fileInputEl.dom.files[0];var a=new FileReader();a.onload=function(){try{var c=JSON.parse(a.result)}catch(e){Ext.Msg.alert('Error','Error parsing JSON')}if(c){b.fireEvent('newjsonreport',b,c)}};a.onerror=function(){Ext.Msg.alert('Error','Error loading file')};a.readAsText(d)},getTopToolbarItems:function(c){var e=this;if(!this.showToolbar){return null}var b=this.stateConfig;var d=this.isReadOnlyReport;var a=[];if(!d){a.push({text:c.get('rerunText'),cls:'rerun-button',glyph:61515,scale:'medium',handler:this.onRunTestClick})}a.push({xtype:'label',cls:'resultpanel-testtitle',itemId:'resultpanel-testtitle',margin:'0 0 0 10',height:48,text:' ',flex:1});if(d&&window.FileReader){a.push({xtype:'fileuploadfield',buttonOnly:!0,buttonText:'Load data file',listeners:{change:this.onLoadReportFileChange,scope:this}})}if(!d){a.push({xtype:'label',cls:'speedlabel',margin:'0 20',text:'Mouse speed'},{xtype:'segmentedbutton',cls:'speed-button',scale:'small',margin:'0 30 0 0',items:[{text:'Slow',tooltip:'Slow and accurate mouse simulation',pressed:!b.speedRun&&!b.turboMode,option:'mouseSimSlow'},{text:'Fast',tooltip:'Fast, but still accurate mouse simulation',pressed:b.speedRun&&!b.turboMode,option:'mouseSimFast'},{text:'Turbo',pressed:b.turboMode,tooltip:'Turbo mode! Super fast with reduced mouse precision (read docs before using)',option:'mouseSimFastest'}],listeners:{toggle:function(b,a){e.fireEvent('optionchange',a,a.option,!0)}}},this.viewDomButton=new Ext.Button({tooltip:'Force native events simulation',cls:'testaction-button',action:'force-native',scale:'medium',glyph:62042,enableToggle:!0,scope:this,pressed:this.project.simulation=='native',handler:function(a){this.project.simulation=a.pressed?'native':'synthetic'}}),this.viewDomButton=new Ext.Button({tooltip:c.get('toggleDomVisibleText'),cls:'testaction-button',action:'view-dom',scale:'medium',glyph:62060,enableToggle:!0,scope:this,pressed:this.viewDOM,handler:function(a){this.setViewDOM(a.pressed)}}),this.scaleToFitButton=new Ext.SplitButton({tooltip:'Scale to fit',cls:'testaction-button',action:'scale-to-fit',scale:'medium',glyph:61541,enableToggle:!0,pressed:Boolean(this.scaleToFit),menu:{items:[{glyph:61618,text:'Fit full',itemId:'full'},{glyph:61566,text:'Fit width',itemId:'width'},{glyph:61565,text:'Fit height',itemId:'height'}],listeners:{click:function(b,a){this.slots.domContainer.setScaleToFit(!0,a.itemId);this.scaleToFitButton.setPressed(!0)},scope:this}},scope:this,handler:function(a){this.slots.domContainer.setScaleToFit(a.pressed)}}),this.sourceButton=new Ext.Button({tooltip:c.get('viewSourceText'),action:'view-source',cls:'testaction-button',glyph:61686,scale:'medium',tooltipType:'title',disabled:!0,enableToggle:!0,scope:this,handler:function(a){if(a.pressed){this.showSource()}else {this.hideSource()}}}),this.filterButton=new Ext.Button({tooltip:c.get('showFailedOnlyText'),action:'show-failed-only',cls:'testaction-button',scale:'medium',glyph:61832,tooltipType:'title',scope:this,enableToggle:!0,handler:this.onAssertionFilterClick}),this.inspectionButton=new Ext.Button({glyph:61442,cls:'testaction-button cmp-inspector',action:'toggle-cmp-inspector',scale:'medium',tooltip:'Target highlighter',tooltipType:'title',handler:this.toggleComponentInspectionMode,scope:this,enableToggle:!0}),this.recorderButton=new Ext.Button({glyph:61501,action:'toggle-recorder',cls:'testaction-button',scale:'medium',disabled:!Siesta.Recorder||Ext.isIE9m,tooltip:c.get('eventRecorderText'),handler:this.onRecorderClick,margin:'0 30 0 0',scope:this,enableToggle:!0}),{xtype:'versionupdatebutton'},{xtype:'component',id:'siesta-logo'})}return a},ensureLayout:function(){var a=this.getWidth();var e=this.slots.cardContainer;var c=this.slots.domContainer;var d=c.getWidth();var b=e.minWidth+20;if(a-d<b){c.setWidth(Math.max(0,a-b))}},showSource:function(f){var d=this.test;if(!this.test){return}var a=[];var c=this.slots;var e=c.cardContainer;var b=c.source;e.layout.setActiveItem(b);if(arguments.length===0){Ext.each(d.getFailedAssertions(),function(b){if(b.sourceLine!=null){a.push(b.sourceLine)}})}else {a=[f]}b.setSource(d.getSource(),a)},hideSource:function(){var a=this.slots;var b=a.cardContainer;if(b.layout.getActiveItem()===a.source){this.sourceButton.setPressed(!1);b.layout.setActiveItem(a.grid)}},setViewDOM:function(b){var a=this.slots.domContainer;if(b){a.expand(!1)}else {a.collapse(null,!1)}},onDomContainerCollapse:function(){this.viewDOM=!1;this.viewDomButton.toggle(!1);this.fireEvent('viewdomchange',this,!1)},onDomContainerExpand:function(){this.viewDOM=!0;this.viewDomButton.toggle(!0);this.fireEvent('viewdomchange',this,!0)},onRunTestClick:function(){this.fireEvent('runbuttonclick',this)},showTest:function(b,c){var a=this.slots.recorderPanel;this.slots.source.clear();this.filterButton&&this.filterButton.toggle(!1);this.hideSource();this.sourceButton&&this.sourceButton.enable();var d=b.url;Ext.suspendLayouts();this.slots.grid.showTest(b,c);this.slots.domContainer.showTest(b,c);if(a){if(!a.test||b.url!==a.test.url){a.stop();a.attachTo(b)}}this.setTestTitle(d==='/'?a.getRecordingName():d);Ext.resumeLayouts();this.test=b},setTestTitle:function(a){this.testTitle.setText(a)},onAssertionFilterClick:function(c){var b=this.slots.grid;var a=b.store;if(!a.filterTreeBy){return}if(c.pressed){b.addCls('assertiongrid-filtered');a.filterTreeBy(function(b){var a=b.getResult();return a.passed===!1&&!a.isTodo})}else {b.removeCls('assertiongrid-filtered');a.clearTreeFilter()}},alignIFrame:function(){this.slots.domContainer.alignIFrame()},hideIFrame:function(){this.slots.domContainer.hideIFrame()},setInitializing:function(a){this.slots.grid.setInitializing(a)},onAssertionDoubleClick:function(c,b){var a=b.getResult();if(a instanceof Siesta.Result.Assertion&&!a.isPassed(!0)){this.showSource(a.sourceLine)}},toggleComponentInspectionMode:function(a){this.slots.domContainer.toggleInspectionMode(a.pressed)},onRecorderClick:function(){var a=this.slots.cardContainer;if(!this.recorderPanel){this.recorderPanel=Ext.create(this.recorderPanelClass,{slot:'recorderPanel',project:this.project,domContainer:this.slots.domContainer,recorderConfig:this.recorderConfig,closeButton:{text:Siesta.Resource('Siesta.Project.Browser.UI.ResultPanel','closeText'),cls:'recorder-tool',handler:function(){a.layout.setActiveItem(0)}},listeners:{startrecord:function(b,a){this.fireEvent('startrecord',b,a);this.showTest(a)},show:function(){this.recorderButton.toggle(!0)},play:function(b,a){this.showTest(a)},hide:function(){this.recorderButton.toggle(!1)},scope:this}});this.slots.cardContainer.add(this.recorderPanel);this.relayEvents(this.recorderPanel,['startrecord','play'],'recorder');if(this.test){this.slots.recorderPanel.attachTo(this.test)}}if(a.layout.getActiveItem()===this.recorderPanel){a.layout.setActiveItem(this.slots.grid)}else {a.layout.setActiveItem(this.recorderPanel)}},afterRender:function(){this.callParent(arguments);var a=this.child('bordersplitter');this.testTitle=this.down('#resultpanel-testtitle');a&&(a.tracker.tolerance=0)}});Ext.define('Siesta.Project.Browser.UI.TestGridController',{extend:Ext.app.ViewController,alias:'controller.testgrid',control:{'#tool-menu [option]':{click:'onMenuItemClick'},'[actionName^=run]':{click:'onRunBtnClicked'},'#aboutSiesta':{click:'onAboutSiesta'}},onRunBtnClicked:function(a){this.getView().fireEvent('buttonclick',this,a,a.actionName)},onMenuItemClick:function(a){this.getView().fireEvent('optionchange',this,a.option,a.checked)},onAboutSiesta:function(){(new Siesta.Project.Browser.UI.AboutWindow()).show()}});Ext.define('Siesta.Project.Browser.UI.TestNameColumn',{extend:Ext.tree.Column,xtype:'testnamecolumn',dataIndex:'title',sortable:!1,menuDisabled:!0,flex:1,tdCls:'test-name-cell',scope:this,project:null,filterGroups:null,store:null,initComponent:function(){var a=Siesta.Resource('Siesta.Project.Browser.UI.TestGrid');Ext.apply(this,{items:[{xtype:'treefilter',emptyText:a.get('filterTestsText'),margins:'0 0 0 10',itemId:'trigger',filterGroups:this.filterGroups,filterField:'title',store:this.store,tipText:a.get('filterFieldTooltip')}]});this.callParent(arguments)},treeRenderer:function(g,e,b){e.tdCls='test-name-cell-'+(b.data.leaf?'leaf':'parent');var a='';if(b.isLeaf()){var c=b.get('test');if(c){if(b.get('isFailed')){a='siesta-test-failed fa-flag'}else {if(b.get('isRunning')&&!c.isFinished()){a='fa-flash siesta-running-not-finished'}else {if(c.isFinished()){if(c.isPassed()){a='fa-check siesta-test-passed'}else {a='fa-bug siesta-test-failed'}}else {a='fa-hourglass-o siesta-test-starting'}}}}else {if(b.get('isMissing')){a='fa-close siesta-test-file-missing'}else {if(b.get('isStarting')){a='fa-hourglass-o siesta-test-starting'}else {a=this.getTestIcon(b)+' siesta-test-file'}}}}else {var d=b.get('folderStatus');if(d=='working'){a=' fa-hourglass-o siesta-folder-running'}else {if(d=='green'){a=' fa-check siesta-folder-pass'}else {if(d=='red'){a=' fa-bug siesta-folder-fail'}else {a=''}}}}b.data.iconCls=a;if(b.isLeaf()){var f=b.get('tooltip')||g;e.tdAttr='title="'+f+'"'}return this.callParent(arguments)},getTestIcon:function(a){if(this.project.getDescriptorConfig(a.get('descriptor'),'pageUrl')){return 'fa-desktop'}else {return 'fa-file-o'}},renderer:function(b,c,a){return b+(a.get('descriptor').referenceUrl?'<span style="padding-left: 3px; vertical-align: super; font-size: xx-small" class="fa fa-external-link" aria-hidden="true"></span>':'')}});Ext.define('Siesta.Project.Browser.UI.TestGrid',{extend:Ext.tree.Panel,alias:'widget.testgrid',controller:'testgrid',stateful:!0,rootVisible:!1,header:!1,rowLines:!1,useArrows:!0,border:!1,cls:'tr-testgrid',iconCls:'tr-status-neutral-small',width:340,collapsible:!0,expanded:!0,viewType:'filterabletreeview',enableColumnMove:!1,project:null,lines:!1,filter:null,filterGroups:!1,resultSummary:null,stateConfig:null,showSizeControls:!1,isReadOnlyReport:!1,menuHideTimeout:!1,viewConfig:{enableTextSelection:!0,toggleOnDblClick:!1,markDirty:!1,trackOver:!1,getRowClass:function(a){if(a.get('descriptor').isSystemDescriptor){return 'siesta-system-descriptor'}},shouldUpdateCell:function(c,b,a){if(b.dataIndex==='passCount'&&a&&!(Ext.Array.contains(a,'passCount')||Ext.Array.contains(a,'todoPassCount'))){return 0}if(b.dataIndex==='failCount'&&a&&!(Ext.Array.contains(a,'failCount')||Ext.Array.contains(a,'todoFailCount'))){return 0}return Ext.tree.View.prototype.shouldUpdateCell.apply(this,arguments)}},initComponent:function(){var a=this;var b=Siesta.Resource('Siesta.Project.Browser.UI.TestGrid');var c=this.stateConfig;Ext.apply(this,{title:b.get('title'),columns:{createFocusableContainerKeyNav:Ext.emptyFn,items:[{xtype:'testnamecolumn',store:this.store,project:this.project},{header:b.get('passText'),width:35,sortable:!1,tdCls:'x-unselectable result-cell',menuDisabled:!0,dataIndex:'passCount',align:'center',renderer:this.passedColumnRenderer,scope:this},{header:b.get('failText'),width:35,sortable:!1,tdCls:'x-unselectable result-cell',menuDisabled:!0,dataIndex:'failCount',align:'center',renderer:this.failedColumnRenderer,scope:this},{header:'Time',width:50,sortable:!1,dataIndex:'time',align:'center',renderer:function(b,c,a){if(!a.isLeaf()){return ''}return b+'ms'},hidden:!(this.project.showTestDurationColumn||this.isReadOnlyReport)}]},bbar:{xtype:'toolbar',cls:'main-bbar siesta-toolbar',border:!1,height:45,defaults:{scale:'large',width:30,tooltipType:'title'},items:this.getBottomBarItems(c,b)},dockedItems:this.showSizeControls?[{xtype:'toolbar',cls:'size-toolbar',border:!0,dock:'bottom',items:[{xtype:'slider',itemId:'framesizeSlider',width:130,value:3,increment:1,minValue:0,maxValue:this.viewportSizes.length-1,listeners:{change:this.onDimensionOrOrientationChange,scope:this}},{xtype:'label',cls:'size-label',itemId:'sizeLabel',width:65},{boxLabel:b.get('landscape'),itemId:'orientationCheckbox',xtype:'checkbox',checked:!0,listeners:{change:this.onDimensionOrOrientationChange,scope:this}}]}]:[]});this.callParent(arguments);this.getView().on('beforerefresh',function(){var b=a.down('#trigger');if(a.filterGroups){b.setFilterGroups(a.filterGroups)}if(a.filter){b.setValue(a.filter)}return !a.filter},null,{single:!0});this.on('viewready',this.onMyViewReady,this,{delay:10})},getBottomBarItems:function(b,a){var c=[];if(!this.isReadOnlyReport){c.push({glyph:61515,cls:'run-checked',text:'<span class="subicon fa-check"></span>',tooltip:a.get('runCheckedText'),actionName:'run-checked'},{glyph:61518,cls:'run-all',tooltip:a.get('runAllText'),actionName:'run-all'},{glyph:61515,cls:'run-failed',text:'<span class="subicon fa-bug"></span>',tooltip:a.get('runFailedText'),actionName:'run-failed'},{glyph:61459,tooltip:a.get('optionsText'),cls:'options',action:'options',listeners:{mouseover:this.onOptionsButtonMouseOver,mouseout:this.onOptionsButtonMouseOut,scope:this},menu:{itemId:'tool-menu',listeners:{mouseenter:{fn:this.onOptionsMenuMouseEnter,delay:100},mouseover:{fn:this.onOptionsMenuMouseEnter,delay:100},mouseleave:this.onOptionsMenuMouseLeave,scope:this},items:[{text:a.get('transparentExText'),option:'transparentEx',checked:b.transparentEx,tooltip:a.get('transparentExTooltip')},{text:a.get('breakOnFailText'),option:'breakOnFail',checked:b.breakOnFail,tooltip:a.get('breakOnFailTooltip')},{text:a.get('debuggerOnFailText'),option:'debuggerOnFail',checked:b.debuggerOnFail,tooltip:a.get('debuggerOnFailTooltip')},{itemId:'observerModeMenuItem',text:a.get('observerModeText'),option:'observerMode',checked:b.observerMode,tooltip:a.get('observerModeTooltip')},{text:a.get('autoLaunchText'),option:'autoRun',checked:b.autoRun,tooltip:a.get('autoLaunchTooltip')},{xtype:'menuseparator'},{text:a.get('aboutText'),itemId:'aboutSiesta'},{text:a.get('documentationText'),href:a.get('siestaDocsUrl'),hrefTarget:'_blank'}]}})}c.push('->',{xtype:'component',cls:'summary-bar',border:!1,width:55,itemId:'result-summary',data:{pass:0,fail:0},tpl:'<div><span class="total-pass">{pass}</span><span class="icon fa-check"></span></div><div><span class="total-fail">{fail}</span><span class="icon fa-bug"></span></div>'});return c},onHistoryChange:function(b){if(b){var a=this.store.getNodeById(b);if(a){this.selectTestFile(a)}}},onDimensionOrOrientationChange:function(c,d){var a=this.viewportSizes[this.framesizeSlider.getValue()];var b=this.orientationCheckbox.getValue();this.sizeLabel.setText(a.join('x'));this.fireEvent('framesizechange',c,a[0],a[1],b)},getFilterValue:function(){return this.down('#trigger').getValue()},getFilterGroups:function(){return this.down('#trigger').getFilterGroups()},passedColumnRenderer:function(b,c,a){if(!a.isLeaf()){return ''}if(a.data.todoPassCount>0){b+=' <span title="'+a.data.todoPassCount+' '+Siesta.Resource('Siesta.Project.Browser.UI.TestGrid','todoPassedText')+'" class="tr-test-todo tr-test-todo-pass">+ '+a.data.todoPassCount+'</span>'}return b},failedColumnRenderer:function(b,c,a){if(!a.isLeaf()){return ''}if(a.data.todoFailCount>0){b+=' <span title="'+a.data.todoFailCount+' '+Siesta.Resource('Siesta.Project.Browser.UI.TestGrid','todoFailedText')+'" class="tr-test-todo tr-test-todo-fail">+ '+a.data.todoFailCount+'</span>'}return b},onOptionsButtonMouseOver:function(a){clearTimeout(this.menuHideTimeout);a.showMenu();a.menu.hide=function(){};setTimeout(function(){delete a.menu.hide},1000)},onOptionsButtonMouseOut:function(a){var b=this;if(this.menuHideTimeout){return}this.menuHideTimeout=setTimeout(function(){delete a.menu.hide;a.hideMenu();b.menuHideTimeout=null},500)},onOptionsMenuMouseEnter:function(a){clearTimeout(this.menuHideTimeout);this.menuHideTimeout=null},onOptionsMenuMouseLeave:function(){var b=this;var a=this.down('#tool-menu');if(this.menuHideTimeout){return}this.menuHideTimeout=setTimeout(function(){delete a.hide;a.hide();b.menuHideTimeout=null},500)},afterRender:function(){this.callParent(arguments);this.summaryPassEl=this.el.down('.total-pass');this.summaryFailEl=this.el.down('.total-fail');if(this.showSizeControls){this.orientationCheckbox=this.down('#orientationCheckbox');this.sizeLabel=this.down('#sizeLabel');this.framesizeSlider=this.down('#framesizeSlider');var a=this.viewportSizes[this.framesizeSlider.getValue()];this.sizeLabel.setText(a.join('x'))}},onMyViewReady:function(){Ext.History.on('change',this.onHistoryChange,this);var a=window.location.hash;if(a){this.onHistoryChange(a.substring(1))}},updateStatus:function(b,a){this.summaryPassEl.update(String(b));this.summaryFailEl.update(String(a))},setFilterValue:function(a){this.down('treefilter').setValue(a)},selectTestFile:function(a){if(a){a.bubble(function(a){a.expand()});if(this.store.getById(a.id)&&this.store.indexOf(a)>=0){if(!this.getCollapsed()&&this.getView().getNodes().length>0){this.ensureVisible(a)}this.getSelectionModel().select(a)}}}});Ext.define('Siesta.Project.Browser.UI.TestGridContextMenu',{extend:Ext.menu.Menu,xtype:'testgridcontextmenu',items:[{itemId:'uncheckOthers',text:Siesta.Resource('Siesta.Project.Browser.UI.Viewport').get('uncheckOthersText')},{itemId:'uncheckAll',text:Siesta.Resource('Siesta.Project.Browser.UI.Viewport').get('uncheckAllText')},{itemId:'checkAll',text:Siesta.Resource('Siesta.Project.Browser.UI.Viewport').get('checkAllText')},{itemId:'runThis',text:Siesta.Resource('Siesta.Project.Browser.UI.Viewport').get('runThisText')},{itemId:'viewSource',text:Siesta.Resource('Siesta.Project.Browser.UI.Viewport').get('viewSource')},{text:'Link to this test',menu:[{itemId:'linkSelect',text:'Select only'},{itemId:'linkFilterAutoLaunch',text:'Filter and auto launch'}]},{xtype:'menuseparator'},{itemId:'expandAll',text:Siesta.Resource('Siesta.Project.Browser.UI.Viewport').get('expandAll')},{itemId:'collapseAll',text:Siesta.Resource('Siesta.Project.Browser.UI.Viewport').get('collapseAll')},{xtype:'menuseparator'},{itemId:'filterToCurrentGroup',text:Siesta.Resource('Siesta.Project.Browser.UI.Viewport').get('filterToCurrentGroup')},{itemId:'filterToFailed',text:Siesta.Resource('Siesta.Project.Browser.UI.Viewport').get('filterToFailed')}]});Ext.define('Siesta.Project.Browser.UI.VersionUpdateButton',{extend:Ext.Button,xtype:'versionupdatebutton',text:Siesta.Resource('Siesta.Project.Browser.UI.VersionUpdateButton','newUpdateText'),action:'upgrade-siesta',hidden:!0,latestVersion:null,scale:'medium',constructor:function(){this.callParent(arguments);this.scope=this;if(Siesta.meta.VERSION&&!window.location.href.match('^https')){this.fetchVersionInfo()}},fetchVersionInfo:function(){Ext.data.JsonP.request({url:'https://bryntum.com/siesta_version',params:{v:Siesta.meta.VERSION},scope:this,callback:this.onRequestCompleted})},onRequestCompleted:function(b,a){if(b&&a&&a.name&&(new Ext.Version(a.name)).isGreaterThan(Siesta.meta.VERSION||'1.0.0')){this.latestVersion=a.name;this.show()}},handler:function(){var c=this;var a=Siesta.Resource('Siesta.Project.Browser.UI.VersionUpdateButton');var b=new Ext.Window({cls:'changelog-window',title:a.get('updateWindowTitleText')+(Siesta.meta.VERSION||'1.0.0'),modal:!0,width:500,height:380,closeAction:'destroy',plain:!0,autoScroll:!0,buttons:{padding:'10 13',style:'background: transparent',items:[{cls:'light-button',href:'https://www.npmjs.com/package/siesta-lite',hrefTarget:'_blank',scale:'medium',text:a.get('downloadText')+this.latestVersion+a.get('liteText')},{cls:'light-button',href:'https://customerzone.bryntum.com',hrefTarget:'_blank',scale:'medium',text:a.get('downloadText')+this.latestVersion+a.get('standardText')},{text:a.get('cancelText'),scale:'medium',handler:function(){b.close()}}]}});b.show();b.body.mask(a.get('loadingChangelogText'));Ext.Ajax.request({useDefaultXhrHeader:!1,url:'https://bryntum.com/changelogs/_siesta.php',callback:function(d,c,a){b.body.unmask();if(c&&a&&a.responseText){b.update(a.responseText)}else {b.update(Siesta.Resource('Siesta.Project.Browser.UI.VersionUpdateButton','changelogLoadFailedText'))}}})}});Ext.define('Siesta.Project.Browser.UI.ViewportController',{extend:Ext.app.ViewController,alias:'controller.viewport',mixins:[Siesta.Project.Browser.UI.CanCopyToClipboard],control:{testgrid:{selectionchange:'onTestGridSelectionChange',checkchange:'onTestGridCheckChange',itemcontextmenu:'onTestFileContextMenu',itemdblclick:'onTestFileDoubleClick',itemclick:'onTestFileClick',resize:'onTestGridResize',optionchange:'onTestGridOptionChange',buttonclick:'onTestGridToolbarClick',framesizechange:'onFrameSizeChange'},'testnamecolumn treefilter':{change:{fn:'onFilterChange',buffer:300}},'testgridcontextmenu #uncheckOthers':{click:'uncheckOthers'},'testgridcontextmenu #runThis':{click:'runThisFile'},'testgridcontextmenu #uncheckAll':{click:'uncheckAll'},'testgridcontextmenu #checkAll':{click:'checkAll'},'testgridcontextmenu #expandAll':{click:'expandAll'},'testgridcontextmenu #collapseAll':{click:'collapseAll'},'testgridcontextmenu #filterToCurrentGroup':{click:'filterToCurrentGroup'},'testgridcontextmenu #filterToFailed':{click:'filterToFailed'},'testgridcontextmenu #viewSource':{click:'viewSource'},'testgridcontextmenu #linkSelect':{click:'linkSelect'},'testgridcontextmenu #linkFilterAutoLaunch':{click:'linkFilterAutoLaunch'},resultpanel:{optionchange:'onResultPanelOptionChange',viewdomchange:'onDomPanelVisibilityChange',runbuttonclick:'runTest'}},disableRunButtonTimeout:null,disableRunButtonInterval:150,onFilterChange:function(){var a=this.getView();a.saveState()},filterToFailed:function(){var b=this.getView();var a=[];b.forEachTestFile(function(b){var c=b.get('test');if(c&&c.isFailed()){a.push(b.get('title'))}});if(a.length){b.slots.filesTree.setFilterValue(a.join(' | '))}},filterToCurrentGroup:function(){var a=this.getView();var b=a.currentFile.get('descriptor');if(b.parent){a.slots.filesTree.setFilterValue(b.parent.group+'>')}},onTestGridSelectionChange:function(e,c){if(c.length){var d=this.getView();var a=c[0];var b=a.get('test');if(b){T=b;d.slots.resultPanel.showTest(b,a.get('assertionsStore'))}if(a.isLeaf()){Ext.History.add(a.data.url)}}},onTestGridCheckChange:function(a,c){var b=this.getView();b.setNodeChecked(a,c)},onTestFileContextMenu:function(e,c,f,d,b){var a=this.getView();if(a.isReadOnlyReport){return}a.currentFile=c;if(!a.contextMenu){a.contextMenu=new Siesta.Project.Browser.UI.TestGridContextMenu()}a.contextMenu.showAt(b.getXY());b.preventDefault()},onTestFileDoubleClick:function(e,a){var b=this.getView();if(b.isReadOnlyReport){return}var c=b.testsStore;if(c.isTreeFiltered()&&!a.isLeaf()){var d=[];a.cascadeBy(function(b){if(b!=a&&b.isLeaf()&&c.isNodeFilteredIn(b)){d.push(b.get('descriptor'))}});b.project.launch(d)}else {b.launchTest(a)}},onTestFileClick:function(f,c,g,h,d){var b=this.getView();if(b.isReadOnlyReport){return}var a=b.project.getDescriptorConfig(c.get('descriptor'),'referenceUrl');if(a&&d.ctrlKey){var e=window.open(a,'_blank');if(!e){Ext.toast('Popups are disabled in the browser',"Can't open new tab")}}},onTestGridResize:function(){this.getView().slots.resultPanel.ensureLayout()},onTestGridOptionChange:function(d,c,b){var a=this.getView();a.setOption(c,b);a.saveState()},onResultPanelOptionChange:function(f,b,e){var c=this.getView(),d=c.slots.resultPanel.test;c.setOption(b,e);c.saveState();if(d){var a;switch(b){case 'mouseSimSlow':a='slow';break;case 'mouseSimFast':a='speedRun';break;case 'mouseSimFastest':a='turboMode';break;default:throw new Error('Wrong option name: '+b);}d.simulator.setSpeed(a)}},onTestGridToolbarClick:function(d,c,b){var a=this.getView();switch(b){case 'run-checked':a.runChecked();break;case 'run-failed':a.runFailed();break;case 'run-all':a.runAll();break;case 'stop':a.stopSuite(c);break;}},onFrameSizeChange:function(f,b,a,d){var c=this.getView();if(!d){var e=b;b=a;a=e}$('.tr-iframe').width(b);$('.tr-iframe').height(a);c.project.viewportHeight=a;c.project.viewportWidth=b},uncheckOthers:function(){var a=this.getView();var b=a.currentFile;a.uncheckAllExcept(b);a.setNodeChecked(b,!0)},linkFilterAutoLaunch:function(){var c=this.getView();var b=c.currentFile;var e=/([^\/]*)$/.exec(b.get('descriptor').url);var a=location.protocol+'//'+location.host+location.pathname+'?'+'filter='+encodeURIComponent(e[1])+'&autolaunch=1';var d=this.copyToClipboard(a);if(d){Ext.toast('Url copied to clipboard','Success')}else {Ext.Msg.show({message:'Please select & copy this url manually:<br>'+a,title:'Copy to clipboard failed',modal:!1})}},linkSelect:function(){var c=this.getView();var b=c.currentFile;var a=location.protocol+'//'+location.host+location.pathname+'#'+b.get('descriptor').url;var d=this.copyToClipboard(a);if(d){Ext.toast('Url copied to clipboard','Success')}else {Ext.Msg.show({message:'Please select & copy this url manually:<br>'+a,title:'Copy to clipboard failed',modal:!1})}},runThisFile:function(){var a=this.getView();a.project.launch([a.currentFile.get('descriptor')])},uncheckAll:function(){var a=this.getView();a.uncheckAllExcept()},checkAll:function(){var a=this.getView();a.testsStore.forEach(function(b){a.setNodeChecked(b,!0,!0)})},expandAll:function(){var a=this.getView();a.slots.filesTree.expandAll()},collapseAll:function(){var a=this.getView();a.slots.filesTree.collapseAll()},viewSource:function(){var a=this.getView().currentFile;var c=a.get('test');var d=window.open('','siesta-source');var e=d.document.documentElement.getElementsByTagName('head')[0];var b=d.document.body;e.innerHTML='<title>'+a.get('title')+'</title>';if(c){b.innerHTML='<pre>'+c.getSource()+'</pre>'}else {$.ajax(a.get('url'),{success:function(a){b.innerHTML='<pre>'+a+'</pre>'}})}},onDomPanelVisibilityChange:function(c,b){var a=this.getView();a.setOption('viewDOM',b);a.saveState()},runTest:function(){var a=this;if(a.disableRunButtonTimeout!=null){return}a.disableRunButtonTimeout=setTimeout(function(){a.disableRunButtonTimeout=null},a.disableRunButtonInterval);var b=a.getView();b.runTest()}});Ext.define('Siesta.Project.Browser.Model.TestFile',{extend:Ext.data.Model,idProperty:'id',fields:['id','url','title','tooltip',{name:'passCount',type:'int',defaultValue:0},{name:'failCount',type:'int',defaultValue:0},{name:'todoPassCount',type:'int',defaultValue:0},{name:'todoFailCount',type:'int',defaultValue:0},{name:'time',type:'int',defaultValue:0},{name:'checked',defaultValue:!1},{name:'folderStatus',defaultValue:'yellow'},'isStarting',{name:'isRunning',type:'boolean',defaultValue:!1},{name:'isMissing',type:'boolean',defaultValue:!1},{name:'isFailed',type:'boolean',defaultValue:!1},'assertionsStore','test','descriptor'],computeFolderStatus:function(){if(!this.childNodes.length){return 'yellow'}var b=!1;var c=!1;var a=!0;Joose.A.each(this.childNodes,function(e){if(e.isLeaf()){var d=e.get('test');if(d&&d.isFailed()){a=!1;c=!0;return !1}if(!d&&e.get('isStarting')){b=!0}if(d&&!d.isFinished()){b=!0}if(d&&!d.isPassed()){a=!1}if(!d){a=!1}}else {var f=e.computeFolderStatus();if(f=='red'){a=!1;c=!0;return !1}if(f=='working'){b=!0;return !1}if(f=='yellow'){a=!1}}});if(b){return 'working'}if(c){return 'red'}if(a){return 'green'}return 'yellow'},updateFolderStatus:function(){this.set('folderStatus',this.computeFolderStatus());var a=this.parentNode;if(a&&!a.isRoot()){a.updateFolderStatus()}}});if(Ext.supports&&Ext.supports.TouchEvents&&!Ext.supports.Touch){Ext.supports.Touch=!1;Ext.supports.touchScroll=!1}Ext.define('Siesta.Project.Browser.UI.Viewport',{extend:Ext.container.Viewport,mixins:[Siesta.Project.Browser.UI.CanFillAssertionsStore],controller:'viewport',title:null,project:null,stateful:!1,layout:'border',selection:null,filter:null,filterGroups:!1,testsStore:null,contextMenu:null,enableVersionCheck:!0,collapsedNodes:null,showSizeControls:!1,expectedExtJSVersion:'6.0.1.250',viewportSizes:[[640,480],[800,600],[1024,768],[1920,1080],[2048,1536]],idGenSequence:1,isReadOnlyReport:!1,dataUrl:'report-data.json',autoLaunch:!1,initComponent:function(){var a;if(this.isReadOnlyReport){a=new Siesta.Project.Browser();a.configure({stateful:!1});this.project=a}else {a=this.project}Ext.getBody().addCls('siesta');Ext.getBody().on('keydown',this.onBodyKeyDown,this);Ext.setGlyphFontFamily('FontAwesome');Ext.state.Manager.setProvider(Ext.supports.LocalStorage?new Ext.state.LocalStorageProvider():new Ext.state.CookieProvider());this.selection={};var b=this.filter;if(a.stateful){this.applyState(this.loadState())}if(b){this.filter=b;this.filterGroups=!1}var e=this.buildTreeData({id:'root',group:'test suite'+this.title,items:a.descriptors}).children;var d=this.testsStore=new Siesta.Project.Browser.Model.FilterableTreeStore({model:'Siesta.Project.Browser.Model.TestFile',sortOnLoad:!1,root:{expanded:!0,children:e},proxy:'memory',listeners:{nodecollapse:this.saveState,nodeexpand:this.saveState,scope:this}});Ext.apply(this,{slots:!0,items:[{region:'west',xtype:'testgrid',store:d,stateful:a.stateful,slot:'filesTree',id:a.id.replace(/\W/g,'_')+'-testTree',showSizeControls:this.showSizeControls,viewportSizes:this.viewportSizes,stateConfig:this.getState(),project:this.project,isReadOnlyReport:this.isReadOnlyReport,animate:!Ext.isIE,split:{size:7},filter:this.filter,filterGroups:this.filterGroups,listeners:{viewready:this.onFilterApplied,scope:this}},{xtype:'resultpanel',region:'center',slot:'resultPanel',cls:'resultPanel-panel',viewDOM:this.getOption('viewDOM'),scaleToFit:this.getOption('scaleToFit'),scaleToFitMode:this.getOption('scaleToFitMode'),stateConfig:this.getState(),id:a.id.replace(/\W/g,'_')+'-resultpanel',project:a,recorderConfig:a.recorderConfig,isReadOnlyReport:this.isReadOnlyReport,maintainViewportSize:a.maintainViewportSize,domContainerRegion:a.domContainerRegion,listeners:{newjsonreport:this.onNewJsonReport,scope:this}}]});this.callParent();this.slots.filesTree.store.on({'filter-set':this.saveState,'filter-clear':this.saveState,scope:this});this.on('statechange',this.saveState,this);a.on('testendbubbling',this.onEveryTestEnd,this);a.on('testsuitelaunch',this.onTestSuiteLaunch,this);a.on('assertiondiscard',this.onAssertionDiscarded,this);if(window.location.href.match('^file:///')&&!(this.isReadOnlyReport&&Ext.browser.is('Firefox'))){var c=Siesta.Resource('Siesta.Project.Browser.UI.Viewport');Ext.Msg.alert(c.get('httpWarningTitle'),c.get('httpWarningDesc'))}else {if(this.isReadOnlyReport){this.fetchJsonReport()}}},onNewJsonReport:function(b,a){this.loadJsonReport(a)},buildTreeData:function(a){var b={id:a.id,title:a.group||a.title||a.name,descriptor:a,nodeType:1,cloneNode:function(){return this}};b.tooltip=a.desc||b.title;var d=this;var c=b.id;var f=this.collapsedNodes||{};if(a.group){var e=[];Ext.each(a.items,function(a){e.push(d.buildTreeData(a))});Ext.apply(b,{expanded:f[c]!=null||a.expanded===!1?!1:!0,checked:d.selection.hasOwnProperty(c)||!1,folderStatus:'yellow',children:e,leaf:!1})}else {Ext.apply(b,{url:a.url,leaf:!0,checked:d.selection.hasOwnProperty(c)||!1,passCount:0,failCount:0,time:0,assertionsStore:new Siesta.Project.Browser.Model.AssertionTreeStore({model:'Siesta.Project.Browser.Model.Assertion',proxy:'memory',root:{id:'__ROOT__',expanded:!0}})})}return b},onBodyKeyDown:function(a){if(a.ctrlKey){var c=this.project;if(a.getKey()==Ext.event.Event[c.rerunHotKey]){this.runTest();a.preventDefault()}if(a.getKey()==Ext.event.Event[c.observerModeHotKey]){var d=!c.observerMode;var b=this.down('#observerModeMenuItem');b.setChecked(d);b.fireEvent('click',b);a.preventDefault()}}},buildTreeDataFromJSONSReportNode:function(a){var c={id:this.idGenSequence++,title:a.group||a.name||a.url.replace(/(?:.*\/)?([^/]+)$/,'$1'),descriptor:a,nodeType:1,cloneNode:function(){return this}};var e=this;if(a.group){var d=[];Ext.each(a.items,function(a){d.push(e.buildTreeDataFromJSONSReportNode(a))});Ext.apply(c,{expanded:!0,checked:null,leaf:!1,folderStatus:'yellow',children:d})}else {var b=new Siesta.Test.Browser({project:this.project,url:a.url,name:a.name,startDate:new Date(a.startDate)});Ext.apply(c,{url:a.url,leaf:!0,checked:null,time:a.endDate-a.startDate,test:b,assertionsStore:new Siesta.Project.Browser.Model.AssertionTreeStore({model:'Siesta.Project.Browser.Model.Assertion',proxy:'memory',root:{id:'__ROOT__',expanded:!0,children:this.buildAssertionDataFromJSONSReportNode(a.assertions,b)}})});b.endDate=new Date(a.endDate);Ext.apply(c,{passCount:b.getPassCount(),failCount:b.getFailCount(),todoPassCount:b.getTodoPassCount(),todoFailCount:b.getTodoFailCount()})}return c},buildAssertionDataFromJSONSReportNode:function(e,a){var d=this;var c=Joose.A.map(e,function(b){var e=b.type=='Siesta.Result.SubTest';var c;var g={id:d.idGenSequence++,leaf:!e,expanded:e&&(b.bddSpecType!='it'||!b.passed)};if(e){var f=new Siesta.Test.Browser({trait:Siesta.Test.Sub,name:b.name,isTodo:b.isTodo,startDate:new Date(b.startDate),url:a.url,parent:a,specType:b.bddSpecType});g.children=d.buildAssertionDataFromJSONSReportNode(b.assertions,f);f.endDate=new Date(b.endDate);c=f.getResults()}else {var h=Joose.S.strToClass(b.type);c=new h(b)}a.addResult(c);g.result=c;return g});if(!a.parent){var b=new Siesta.Result.Summary({isFailed:a.isFailed(),description:a.getSummaryMessage()});a.addResult(b);c.push({id:this.idGenSequence++,result:b,loaded:!0,leaf:!0,expanded:!1})}return c},loadJsonReport:function(a){this.title=a.testSuiteName||'';this.testsStore.setRootNode(this.buildTreeDataFromJSONSReportNode({group:'TOP',items:a.testCases}));this.testsStore.getRootNode().cascadeBy(function(a){if(a.parentNode&&!a.isLeaf()){a.updateFolderStatus()}});this.updateStatusIndicator()},fetchJsonReport:function(){var b=this;var a=new Ext.LoadMask({target:this,msg:Siesta.Resource('Siesta.Project.Browser.UI.CoverageReport','loadingText')});a.show();Ext.Ajax.request({url:this.dataUrl,success:function(c){a.hide();b.loadJsonReport(Ext.JSON.decode(c.responseText))},failure:function(){a.hide();Ext.Msg.show({title:Siesta.Resource('Siesta.Project.Browser.UI.CoverageReport','loadingErrorText'),msg:Siesta.Resource('Siesta.Project.Browser.UI.CoverageReport','loadingErrorMessageText')+b.dataUrl,buttons:Ext.MessageBox.OK,icon:Ext.MessageBox.ERROR})}})},onFilterApplied:function(){if(this.autoLaunch){this.runAll()}else {if(this.getOption('autoRun')){var a=this.getChecked();this.project.launch(a.length&&a||this.project.descriptors)}}},setNodeChecked:function(a,b,e,f){var d=this;var c=a.getId();if(b){this.selection[c]=1}else {delete this.selection[c]}a.set('checked',b);if(!b&&a.parentNode){d.setNodeChecked(a.parentNode,!1,!0,!0)}if(!a.isLeaf()&&!e){Ext.each(a.childNodes,function(a){d.setNodeChecked(a,b,!1,!0)})}if(!f){this.saveState()}},forEachTestFile:function(d,a){a=a||this;var b=this.testsStore;var c=b.getRootNode();c.cascadeBy(function(e){var f=b.isNodeFilteredIn(e);if(e!=c&&f){d.call(a,e)}return f})},getChecked:function(){var a=[];this.forEachTestFile(function(b){if(b.get('checked')&&b.isLeaf()){a.push(b.get('descriptor'))}});return a},runChecked:function(){var a=this.getChecked();if(a.length>0){this.project.launch(this.getChecked())}},runFailed:function(){var a=[];this.forEachTestFile(function(b){var c=b.get('test');if(c&&c.isFailed()){a.push(b.get('descriptor'))}});if(a.length>0){this.project.launch(a)}},runAll:function(){var a=[];this.forEachTestFile(function(b){if(b.isLeaf()){a.push(b.get('descriptor'))}});if(a.length>0){this.project.launch(a)}},stopSuite:function(a){a.disable();this.project.stopCurrentLaunch();setTimeout(function(){a.enable()},1000)},onTestSuiteStop:function(a){this.testsStore.forEach(function(a){if(a.get('isStarting')){a.set('isStarting',!1)}});if(a){var b=this.testsStore.getNodeById(a.url);this.slots.filesTree.getSelectionModel().select(b)}},onBeforeScopePreload:function(b,a){var c=this.testsStore.getNodeById(a)},isTestRunningVisible:function(b){if(!(b.scopeProvider instanceof Scope.Provider.IFrame)){return !1}if(this.project.testOfForcedIFrame){return this.project.testOfForcedIFrame.isFromTheSameGeneration(b)}var a=this.slots.resultPanel;if(!a.test||!a.test.isFromTheSameGeneration(b)){return !1}return a.isFrameVisible()},resetDescriptors:function(a){var b=this.testsStore;Joose.A.each(this.project.flattenDescriptors(a),function(c){var a=b.getNodeById(c.id);a.get('assertionsStore').removeAll(!0);a.reject();a.set('checked',this.selection.hasOwnProperty(c.id)||!1)},this)},onTestSuiteStart:function(c){Ext.getBody().addCls('testsuite-running');var e=this.slots.filesTree;var b=e.getSelectionModel();var a=b.getLastSelected();var d=this.testsStore;this.resetDescriptors(c);if(a){b.select(d.getNodeById(a.getId()))}},onTestSuiteLaunch:function(d,b){var c=this.testsStore;var a={};Joose.A.each(this.project.flattenDescriptors(b),function(e){var f=c.getNodeById(e.id);f.set({isMissing:e.isMissing,isStarting:!0});var b=f.parentNode;if(b&&!a[b.getId()]){for(var d=b;d;d=d.parentNode){a[d.getId()]=!0}b.updateFolderStatus()}})},onTestSuiteEnd:function(a){Ext.getBody().removeCls('testsuite-running');this.updateStatusIndicator();if(Ext.isChrome){window.focus()}else {document.body.tabIndex=-1;document.body.focus()}},onTestStart:function(a){var b=this.testsStore.getNodeById(a.url);if(!this.isTestUpdateActual(a,b)){return}b.beginEdit();b.set({test:a,isRunning:!0});b.endEdit();var c=this.slots.filesTree.getSelectionModel().getLastSelected();if(c&&c.getId()==a.url){var d=this.slots.resultPanel;d.showTest(a,b.get('assertionsStore'));d.setInitializing(!1);T=a}},isTestUpdateActual:function(a,b){return a.launchId==this.project.currentLaunchId},onTestUpdate:function(a,d,c){var b=this.testsStore.getNodeById(a.url);if(this.isTestUpdateActual(a,b)){this.processNewResult(b.get('assertionsStore'),a,d,c)}},onAssertionDiscarded:function(e,b,d){var a=this.testsStore.getNodeById(b.url);if(this.isTestUpdateActual(b,a)){var c=a.get('assertionsStore');c.getNodeById(d.id).remove()}},onTestEnd:function(a){var b=this.testsStore.getNodeById(a.url);if(this.isTestUpdateActual(a,b)){b.beginEdit();b.set({'passCount':a.getPassCount(),'failCount':a.getFailCount(),'todoPassCount':a.getTodoPassCount(),'todoFailCount':a.getTodoFailCount(),'time':a.getDuration()+'ms'});b.endEdit();b.parentNode&&b.parentNode.updateFolderStatus()}this.updateStatusIndicator()},onEveryTestEnd:function(c,a){var b=this.testsStore.getNodeById(a.url);if(this.isTestUpdateActual(a,b)){this.processEveryTestEnd(b.get('assertionsStore'),a)}},onTestFail:function(b,c,d){var a=this.testsStore.getNodeById(b.url);if(this.isTestUpdateActual(b,a)&&!b.isTodo){a.set('isFailed',!0);a.parentNode&&a.parentNode.updateFolderStatus()}},getOption:function(a,c){switch(a){case 'selection':return this.selection;default:var b=this.project;if(c){return b.hasOwnProperty(a)?b[a]:undefined};return b[a];}},setOption:function(c,a){var b=this.project;switch(c){case 'selection':return this.selection=a||{};case 'collapsedNodes':return this.collapsedNodes=a;case 'filter':return this.filter=a;case 'filterGroups':return this.filterGroups=a;case 'observerMode':b.setObserverMode(a);break;case 'mouseSimSlow':if(a){b['speedRun']=!1;b['turboMode']=!1};break;case 'mouseSimFast':if(a){b['speedRun']=!0;b['turboMode']=!1};break;case 'mouseSimFastest':if(a){b['speedRun']=!0;b['turboMode']=!0};break;default:return b[c]=a;}},getState:function(c){var a=this.slots&&this.down('domcontainer');var b={scaleToFit:a?a.scaleToFit:this.scaleToFit,scaleToFitMode:a?a.scaleToFitMode:this.scaleToFitMode,selection:this.getCheckedNodes(),collapsedNodes:this.getCollapsedFolders(),filter:this.slots?this.slots.filesTree.getFilterValue():this.filter,filterGroups:this.slots?this.slots.filesTree.getFilterGroups():this.filterGroups};var d=this;Joose.A.each(['autoRun','speedRun','turboMode','viewDOM','transparentEx','breakOnFail','debuggerOnFail','observerMode'],function(e){var a=d.getOption(e,c);if(c){if(a!==undefined){b[e]=a}}else {b[e]=a}});return b},getCheckedNodes:function(){var a={};this.testsStore.forEach(function(b){if(b.get('checked')){a[b.getId()]=1}});return a},getCollapsedFolders:function(){var a={};this.testsStore.forEach(function(b){if(!b.isLeaf()&&!b.isExpanded()){a[b.getId()]=1}});return a},applyState:function(a){var b=this;if(a){Joose.O.each(a,function(a,c){b.setOption(c,a)})}},getStateId:function(){return 'test-run-'+this.title},loadState:function(){var b=this.getStateId();var a=Ext.state.Manager.get(b);if(!a){return}if(!a.collapsedNodes){a.collapsedNodes=Ext.state.Manager.get(b+'-collapsed')}if(!a.selection){a.selection=Ext.state.Manager.get(b+'-selection')}return a},saveState:function(){var b=this.getStateId();var a=this.getState(!0);Ext.state.Manager.set(b+'-collapsed',a.collapsedNodes);Ext.state.Manager.set(b+'-selection',a.selection);delete a.collapsedNodes;delete a.selection;Ext.state.Manager.set(b,a)},uncheckAllExcept:function(a){var b=this;this.testsStore.forEach(function(c){if(c!=a){b.setNodeChecked(c,!1,!0)}})},launchTest:function(a){if(this.isReadOnlyReport){return}var c=this.slots.resultPanel;var d=a instanceof Ext.data.Model?a.data.leaf:!0;var b=a instanceof Siesta.Test?this.project.getScriptDescriptor(a):a.get('descriptor');if(d){Ext.History.add(b.url);c.setInitializing(!0)}this.project.launch([b])},updateStatusIndicator:function(){var b=0;var a=0;this.testsStore.forEach(function(d){var c=d.get('test');if(c&&c.isFinished()){b+=c.getPassCount();a+=c.getFailCount()}});this.slots.filesTree.updateStatus(b,a)},runTest:function(){if(this.isReadOnlyReport){return}var a=this.slots.filesTree.getSelectionModel().getSelection()[0]||this.slots.resultPanel.test;if(a){this.launchTest(a)}},afterRender:function(){this.callParent(arguments);if(Ext.versions.extjs.isLessThan(this.expectedExtJSVersion)&&window.console){console.log('Wrong Ext JS version detected.','Siesta expects that you use Ext JS version >= '+this.expectedExtJSVersion+'. You may experience errors when using another version')}if(!this.project.isAutomated){setTimeout(Ext.Function.bind(this.deferredSetup,this),1000)}},deferredSetup:function(){Ext.QuickTips&&Ext.QuickTips.init();if(this.enableVersionCheck&&Siesta.Project.Browser.UI.VersionUpdateButton){new Siesta.Project.Browser.UI.VersionUpdateButton()}},onManualCloseOfForcedIframe:function(b){var a=this.down('domcontainer');if(a&&a.test==b){a.alignIFrame(!0)}}});;
;
