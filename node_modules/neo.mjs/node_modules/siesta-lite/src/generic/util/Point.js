"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// copied from Siesta.Test.Simulate.Mouse
exports.getPathBetweenPoints = function (from, to) {
    if (typeof from[0] !== 'number' || typeof from[1] !== 'number'
        || typeof to[0] !== 'number' || typeof to[1] !== 'number'
        || isNaN(from[0]) || isNaN(from[1])
        || isNaN(to[0]) || isNaN(to[1])) {
        throw new Error('Incorrect arguments passed to getPathBetweenPoints: ' + from + ', ' + to);
    }
    var stops = [], x0 = Math.floor(from[0]), y0 = Math.floor(from[1]), x1 = Math.floor(to[0]), y1 = Math.floor(to[1]), dx = Math.abs(x1 - x0), dy = Math.abs(y1 - y0), err, e2;
    var sx = x0 < x1 ? 1 : -1;
    var sy = y0 < y1 ? 1 : -1;
    err = dx - dy;
    while (x0 !== x1 || y0 !== y1) {
        e2 = 2 * err;
        if (e2 > -dy) {
            err = err - dy;
            x0 = x0 + sx;
        }
        if (e2 < dx) {
            err = err + dx;
            y0 = y0 + sy;
        }
        stops.push([x0, y0]);
    }
    var last = stops[stops.length - 1];
    if (stops.length > 0 && (last[0] !== to[0] || last[1] !== to[1])) {
        stops.push(to.slice());
    }
    return stops;
};
exports.filterPathAccordingToPrecision = function (path, precision) {
    if (precision === void 0) { precision = 1; }
    var pathLength = path.length;
    // we always want to simulate the events for 2 initial and 2 final points of the path
    if (pathLength <= 4)
        return path.slice();
    var filtered = [path[0], path[1]];
    for (var i = 3; i < pathLength - 2; i += precision)
        filtered.push(path[i]);
    filtered.push(path[pathLength - 2], path[pathLength - 1]);
    return filtered;
};
