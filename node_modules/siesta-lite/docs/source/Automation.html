<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*

Siesta 5.3.0
Copyright(c) 2009-2019 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
Role(&#39;Siesta.Project.Browser.Automation&#39;, {

    does        : [
        Siesta.Util.Role.CanStyleOutput,
        Siesta.Util.Role.CanFormatStrings
    ],

    has : {
        outputLog                       : Joose.I.Array,

        currentTestTimeout              : null,

        lastActivity                    : null,
        exitStatus                      : null,

        activeTestAutomationId          : null,

        testResults                     : Joose.I.Array,

        streamAssertions                : false,

        eventLog                        : Joose.I.Array,

        enableCodeCoverage              : false,

        manuallyProcessCoverageResults  : true,

        codeCoverageResults             : Joose.I.Array
    },


    override : {

        setup : function () {
            if (this.isAutomated) {
                this.autoLaunchTests    = false
                this.forceDOMVisible    = true

                this.speedRun           = true
                this.forcedRunCore      = &#39;sequential&#39;
                this.transparentEx      = false
                this.keepNLastResults   = 0

                this.waitForTimeout     = this.waitForTimeout * 3
                this.defaultTimeout     = this.defaultTimeout * 3
                this.isReadyTimeout     = this.isReadyTimeout * 3

                this.lastActivity       = new Date()

                var me                  = this

                if (typeof window != &#39;undefined&#39;)
                    window.onerror          = function (message, url, lineNumber, col, error) {
                        me.warn(&quot;[ERROR] message : &quot; + message)
                        me.warn(&quot;[ERROR] url     : &quot; + url)
                        me.warn(&quot;[ERROR] line    : &quot; + lineNumber)

                        if (col) me.warn(&quot;[ERROR] col     : &quot; + col)
                        if (error &amp;&amp; error.stack) me.warn(&quot;[ERROR] stack   : &quot; + error.stack)
                    }

                this.on(&#39;maxtimeoutchanged&#39;, function (event, timeout) {
                    me.onTestMaxTimeoutChanged(event.source, timeout)
                })

                this.on(&#39;focuslost&#39;, function (event) {
                    me.onTestFocusLost(event.source)
                })
            }

            this.SUPERARG(arguments)
        }
    },


    after : {

        markMissingFile : function (desc) {
            this.warn(Siesta.Resource(&#39;Siesta.Role.ConsoleReporter&#39;, &#39;missingFileText&#39;).replace(&quot;{URL}&quot;, desc.url))

            if (this.isAutomated) {
                this.lastActivity           = new Date()

                var result                  = {
                    automationElementId : desc.automationElementId,
                    url                 : desc.url,
                    ERROR               : &quot;Can&#39;t open test file: &quot; + desc.url
                }

                if (this.streamAssertions)
                    this.eventLog.push({
                        isResult        : true,
                        data            : result
                    })
                else
                    this.testResults.push(result)
            }
        },


        onTestSuiteStart : function (descriptors, contenManager, launchState) {
            // if (this.isAutomated &amp;&amp; this.initialContentManagerState) contenManager.setState(this.initialContentManagerState)
        },


        onTestSuiteEnd : function (descriptors, contenManager, launchState) {
            if (this.isAutomated &amp;&amp; !launchState.needToStop) this.exit()
        },


        onTestStart : function (test) {
            if (this.isAutomated &amp;&amp; this.isTestActionActual(test)) {
                this.currentTestTimeout     = test.getMaximalTimeout() * 2

                this.activeTestAutomationId = test.automationElementId

                this.lastActivity           = new Date()

                if (this.streamAssertions)
                    if (!test.parent)
                        this.eventLog.push({
                            isUpdate        : true,
                            data            : test.getResults().toJSON()
                        })
            }
        },


        onTestEnd : function (test) {
            if (this.isAutomated &amp;&amp; this.isTestActionActual(test)) {
                this.lastActivity           = new Date()

                this.activeTestAutomationId = null

                if (this.streamAssertions)
                    this.eventLog.push({
                        isResult        : true,
                        data            : test.getResults().toJSON()
                    })
                else
                    this.testResults.push(test.getResults().toJSON())

                if (this.enableCodeCoverage &amp;&amp; this.manuallyProcessCoverageResults) {
                    var result      = test.global.__coverage__

                    result &amp;&amp; this.codeCoverageResults.push(result)
                }
            }
        },


        onTestUpdate : function (test, result, parentResult) {
            if (this.isAutomated &amp;&amp; this.isTestActionActual(test)) {
                this.lastActivity           = new Date()

                if (this.streamAssertions)
                    if (!(result.isWaitFor &amp;&amp; !result.completed) &amp;&amp; !(result instanceof Siesta.Result.Summary)) {
                        this.eventLog.push({
                            isUpdate        : true,
                            data            : result.toJSON()
                        })

                        // in &quot;breakOnFail&quot; case the failed assertion will switch &quot;launchState&quot; to &quot;needToStop&quot;
                        // and &quot;isTestActionActual&quot; will return false for any following updates/results,
                        // so, adding total test result manually
                        if (this.breakOnFail &amp;&amp; ((result instanceof Siesta.Result.Assertion) &amp;&amp; !result.isPassed()))
                            this.eventLog.push({
                                isResult        : true,
                                data            : test.getResults().toJSON()
                            })
                    }
            }
        }
    },


    methods : {

        isTestActionActual : function (test) {
            if (test.launchId != this.currentLaunchId) return false

            var launchState   = this.launches[ this.currentLaunchId ]

            return launchState ? !launchState.needToStop : false
        },


        onTestFocusLost : function (test) {
            if (this.isAutomated) {
                test.warn(Siesta.Resource(&#39;Siesta.Test.Browser&#39;).get(&#39;focusLostWarningLauncher&#39;, { url : test.url }))

                this.stopCurrentLaunch()

                this.exit(&#39;focus_lost&#39;)
            }
        },


        onTestMaxTimeoutChanged : function (test, timeout) {
            if (this.isAutomated) this.currentTestTimeout = timeout * 2
        },


        filterDescriptors : function (includeTests, excludeTests, descriptors) {
            includeTests        = includeTests ? new RegExp(includeTests) : null
            excludeTests        = excludeTests ? new RegExp(excludeTests) : null

            var filtered        = []

            if (includeTests || excludeTests) {
                Joose.A.each(this.flattenDescriptors(descriptors || this.descriptors), function (desc) {
                    if (includeTests &amp;&amp; !includeTests.test(desc.url)) return
                    if (excludeTests &amp;&amp; excludeTests.test(desc.url)) return

                    filtered.push(desc)
                })
            } else
                filtered        = this.flattenDescriptors(descriptors || this.descriptors)

            return filtered
        },


        getLastActivity : function () {
            return this.lastActivity - 0
        },


        log : function (text) {
            if (this.isAutomated) {
                if (this.streamAssertions)
                    this.eventLog.push({
                        isLog       : true,
                        data        : text
                    })
                else
                    this.outputLog.push(text)
            }
        },


        exit : function (status) {
            this.exitStatus = status || &#39;all_processed&#39;
        },


        getAutomationState : function () {
            var launchState   = this.launches[ this.currentLaunchId ]

            var state   = {
                activeTestAutomationId  : this.activeTestAutomationId,
                activityTimeout         : this.currentTestTimeout,
                lastActivity            : this.lastActivity - 0,
                testResults             : this.flushTestResults(),
                log                     : this.flushLog(),
                exitStatus              : this.exitStatus,
                commands                : this.flushAutomationCommands &amp;&amp; this.flushAutomationCommands(),
                // launchState is deleted upon launch completion
                notLaunched             : launchState ? launchState.notLaunchedByAutomationId : {}
            }

            if (this.streamAssertions) {
                state.eventLog          = this.flushEventLog()
            }

            if (this.enableCodeCoverage) {
                state.coverageResult    = this.flushCoverageResults()
            }

            return state
        },


        flushLog : function () {
            var outputLog       = this.outputLog

            if (outputLog.length) {
                this.outputLog  = []

                return outputLog
            }
        },


        flushCoverageResults : function () {
            var results         = this.codeCoverageResults

            if (results.length) {
                this.codeCoverageResults    = []

                return results
            }
        },


        flushTestResults : function () {
            var testResults         = this.testResults

            if (testResults.length) {
                this.testResults    = []

                return testResults
            }
        },


        flushEventLog : function () {
            var eventLog        = this.eventLog

            if (eventLog.length) {
                this.eventLog   = []

                return eventLog
            }
        },


        cascadeStructureLeafOnly : function (func, list) {
            var me      = this

            Joose.A.each(list, function (desc) {
                if (desc.group) {
                    me.cascadeStructureLeafOnly(func, desc.items)
                } else
                    func(desc)
            })
        },


        getDescriptorStructure : function (desc, visibleById) {
            var me      = this

            if (visibleById &amp;&amp; desc.id != &#39;__ROOT__&#39; &amp;&amp; !visibleById[ desc.id ]) return null

            if (desc.group) {
                var items       = []

                Joose.A.each(desc.items, function (desc) {
                    var res     = me.getDescriptorStructure(desc, visibleById)

                    if (res) items.push(res)
                })

                return {
                    id      : desc.id,
                    group   : desc.group || desc.title || desc.name,
                    items   : items
                }
            } else {
                return desc.id
            }
        },


        getConfigInfo : function (includeTest, excludeTests, filterValue, projectConfig) {
            var me                  = this
            var visibleById

            // need to configure project first, because some command line options (like `simulation`) overrides
            // default project config and affect the result of this method
            if (projectConfig) this.configure(projectConfig)

            if (filterValue) {
                var filterer        = new Siesta.Util.TreeStoreFilterer({
                    idProp          : &#39;id&#39;,
                    childNodesProp  : &#39;items&#39;,
                    parentNodeProp  : &#39;parent&#39;,
                    isLeaf          : function (node) { return !node.group }
                })

                var res             = filterer.parseFilterValue(filterValue)

                var testFilterRegexps   = res.testFilterRegexps
                var groupFilterRegexps  = res.groupFilterRegexps

                var getTitle        = function (node) {
                    // do not consider a test suite title as a &quot;root group&quot;, otherwise, for the suite title &quot;Test suite&quot;
                    // the --filter=&quot;ui&gt;&quot; will match all top-level tests
                    if (node == me)
                        return &#39;&#39;
                    else
                        return node.group || node.title || node.name
                }

                visibleById         = filterer.collectNodes({
                    id              : &#39;__ROOT__&#39;,
                    group           : &#39;__ROOT__&#39;,
                    items           : this.descriptors
                }, {
                    filter          : function (node) {
                        return filterer.checkCommonFilter(node, getTitle, testFilterRegexps, groupFilterRegexps)
                    }
                })
            }

            var structure           = this.getDescriptorStructure(
                { id : &#39;__ROOT__&#39;, group : &#39;__ROOT__&#39;, items : this.descriptors },
                visibleById
            )

            var list

            if (filterValue) {
                list                = []

                this.cascadeStructureLeafOnly(function (id) { list.push(me.getDescById(id)) }, structure.items)
            } else
                list                = this.descriptors

            var filteredFlattenList = this.filterDescriptors(includeTest, excludeTests, list)

            return {
                // system info
                VERSION         : Siesta.meta.VERSION,
                title           : this.title,
                structure       : structure,
                descriptors     : this.sortDescriptors(filteredFlattenList, &#39;sequential&#39;, true),

                // environment
                hostName        : typeof location != &#39;undefined&#39; ? location.host : require(&#39;os&#39;).hostname(),
                userAgent       : typeof navigator != &#39;undefined&#39; ? navigator.userAgent : &#39;NodeJS/&#39; + process.version,
                platform        : typeof navigator != &#39;undefined&#39; ? navigator.platform : process.platform,

                hasNativeSimulation         : this.hasDescriptorWithNativeEventsSimulation(filteredFlattenList),

                // options
                breakOnFail                 : this.breakOnFail,
                screenshotCompareConfig     : this.screenshotCompareConfig
            }
        },


        // chunk task - [ { descId : descId, automationElementId : elId }, ... ]
        launchAutomatedTests : function (task, options) {
            if (!this.setupDone) {
                this.on(&#39;setupdone&#39;, function () { this.launchAutomatedTests(task, options) })

                return
            }

            if (options.projectConfig) this.configure(options.projectConfig)

            this.enableCodeCoverage             = Boolean(options.enableCodeCoverage)
            this.streamAssertions               = Boolean(options.streamAssertions)
            this.showCursor                     = Boolean(options.showCursor)

            if (options.pause != null) this.pauseBetweenTests   = options.pause
            if (options.restartOnBlur != null) this.restartOnBlur   = options.restartOnBlur

            var me              = this

            var descriptors     = Joose.A.map(task, function (el) {
                var desc                    = me.getScriptDescriptor(el.descId)

                desc.automationElementId    = el.automationElementId

                return desc
            })

            this.launch(descriptors)
        },


        warn : function (text) {
            this.log({
                text        : text,
                isWarning   : true
            })

            if (typeof window != &#39;undefined&#39;)
                window.console &amp;&amp; console.warn(text)

            if (this.viewport) {
                Ext.toast({
                    cls     : &#39;tr-warn-toast&#39;,
                    title   : &#39;Warning&#39;,
                    html    : text.replace(/\n/g, &#39;&lt;br&gt;&#39;),
                    align   : &#39;t&#39;,
                    autoCloseDelay : 3000
                })
            }
        },


        getExitCode : function () {
            return this.allPassed() ? 0 : 1
        }

    }
})
//eof Siesta.Project.Browser.Automation

if (!Siesta.Project.NodeJS)
    Siesta.Project.Browser.meta.extend({
        does : [
            Siesta.Project.Browser.Automation,
            Siesta.Project.Browser.Automation.Selenium,
            Siesta.Project.Browser.Automation.Puppeteer
        ]
    })
else
    if (Siesta.Project.NodeJS)
        Siesta.Project.NodeJS.meta.extend({
            does : [
                Siesta.Project.Browser.Automation,
                Siesta.Project.Browser.Automation.NodeJS
            ]
        })

</pre>
</body>
</html>
