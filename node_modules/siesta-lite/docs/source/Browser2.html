<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*

Siesta 5.3.0
Copyright(c) 2009-2019 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
<span id='Siesta-Test-Browser'>/**
</span>@class Siesta.Test.Browser
@extends Siesta.Test
@mixin Siesta.Test.TextSelection
@mixin Siesta.Test.Element

@mixin Siesta.Test.UserAgent.Mouse
@mixin Siesta.Test.UserAgent.Keyboard
@mixin Siesta.Test.UserAgent.Touch

@mixin Siesta.Test.Browser.Role.CanGetElementFromPoint

A base class for testing a generic browser functionality. It has various DOM-related assertions, and is not optimized for any framework.

*/
Class(&#39;Siesta.Test.Browser&#39;, {

    isa         : Siesta.Test,

    does        : [
        Siesta.Util.Role.CanParseBrowser,
        Siesta.Util.Role.CanCalculatePageScroll,
        Siesta.Util.Role.Dom,
        Siesta.Test.Browser.Role.CanGetElementFromPoint,
        Siesta.Test.Browser.Role.CanWorkWithKeyboard,
        Siesta.Test.Browser.Role.CanRebindJQueryContext,

        Siesta.Test.UserAgent.Mouse,
        Siesta.Test.UserAgent.Keyboard,
        Siesta.Test.UserAgent.Touch,

        Siesta.Test.Element,
        Siesta.Test.TextSelection,
        Siesta.Test.Observable
    ],

    has : {
<span id='Siesta-Test-Browser-property-bowser'>        /**
</span>         * @property {Object} bowser An instance of browser detection library - [Bowser](https://github.com/ded/bowser).
         * Please refer to the provided link for the detailed documentation, here we just provide some examples how
         * it can be used in the test file:
         *

    // Browser detection
    if (t.bowser.chrome &amp;&amp; t.bowser.version &gt; 50) { .. do something .. }
    if (t.bowser.msie &amp;&amp; t.bowser.version &gt;= 10) { .. do something .. }

    // OS detection
    if (t.bowser.mac) { .. do something .. }

    // Rendering engine detection
    if (t.bowser.gecko) { .. do something .. }

    // Rendering engine detection
    if (t.bowser.webkit || t.bowser.blink) { .. do something .. }

         *
         * This property has an alias - {@link #browser}.
         */
        bowser                  : null,


<span id='Siesta-Test-Browser-property-bowser'>        /**
</span>         * @property {Object} bowser Alias for {@link #bowser}
         */
        browser                 : null,

        forceDOMVisible         : false,
        isDOMForced             : false,

        browserInfo             : {
            lazy    : function () {
                return this.parseBrowser(window.navigator.userAgent)
            }
        },

        nextConfirmValue        : null,
        nextPromptReturnValue   : null,

        realAlert               : null,
        realConfirm             : null,
        realPrompt              : null,
        realPrint               : null,
        realOpen                : null,
        previousConfirm         : null,
        previousPrompt          : null,

        blurListener            : null,
        restartOnBlur           : false,

        blurWindow              : null,

        mouseVisualizer         : null,

        popups                  : Joose.I.Array,

        simulator               : null,
        simulatorConfig         : null,

        isHandlingThrowAsync    : false,

        initialCursorPosition   : null
    },

    override : {

        cleanup : function () {
            if (this.mouseVisualizer) {
                this.mouseVisualizer.destroy()
                this.mouseVisualizer = null
            }

            this.SUPERARG(arguments)

            this.bowser     = this.browser = null

            this._global    = null

            this.realAlert  = this.realConfirm = this.realPrompt = this.realPrint = this.realOpen = null

            this.previousPrompt = this.previousConfirm = null

            this.blurListener   = null

            this.blurWindow &amp;&amp; this.blurWindow.close();

            this.blurWindow     = null;

            Joose.A.each(this.popups, function (handle) {
                if (!handle.popup.closed) handle.popup.close()
            })

            this.popups.length  = 0
            this.popups         = null

            this.simulator.cleanup()
        },


        attachSimulator : function () {
            var me              = this
            var simulator       = this.simulator
            var isRoot          = !this.parent

            // this will &quot;attach&quot; simulator to a test window, by setting up a &quot;global&quot; property
            if (isRoot) simulator.onTestLaunch(this)

            if (simulator.type == &#39;synthetic&#39;) {
                // for synthetic simulator we can just update the current position directly (move to simulator class?)
                if (isRoot &amp;&amp; me.initialCursorPosition) {
                    simulator.currentPosition[ 0 ] = me.initialCursorPosition[ 0 ]
                    simulator.currentPosition[ 1 ] = me.initialCursorPosition[ 1 ]
                }

                return
            }

            var cont            = Promise.resolve()

            return cont.then(function () {
                if (isRoot) {
                    var x       = me.initialCursorPosition ? me.initialCursorPosition[ 0 ] : 0
                    var y       = me.initialCursorPosition ? me.initialCursorPosition[ 1 ] : 0

                    // for native simulator we need to actually move the cursor
                    return simulator.simulateMouseMove(x, y, null, { moveKind : &#39;instant&#39; })
                }
            }).then(function () {
                var hasFocus        = me.project.browserWindowHasFocus()

                // browser window has lost focus for some reason, trying to re-focus by clicking
                // in -1, -1 point
                if (!hasFocus) {
                    var currentPosition     = simulator.currentPosition.slice()

                    return simulator.simulateMouseMove(-1, -1, null, { moveKind : &#39;instant&#39; }).then(function () {
                        return simulator.simulateMouseClick({ globalXY : [] })
                    }).then(function () {
                        return simulator.simulateMouseMove(currentPosition[ 0 ], currentPosition[ 1 ], null, { moveKind : &#39;instant&#39; })
                    })
                }
            })
        },


        launch : function (errorMessage) {
            var me              = this
            var SUPER           = this.SUPER

            var cont            = this.attachSimulator()

            // &quot;attachSimulator&quot; completed synchronously - call SUPER immediately
            // this is required for &quot;subTest&quot; call to be synchronous on what some tests relies (subject for change)
            if (!cont) {
                this.SUPER(errorMessage)
            } else {
                // &quot;attachSimulator&quot; returned promise
                cont.then(function () {
                    SUPER.call(me, errorMessage)
                }, function (reason) {
                    SUPER.call(me, reason)
                })
            }
        }
    },

    methods : {

        initialize : function () {
            if (!this.simulator) this.simulator = new (this.getSimulatorClass())(this.simulatorConfig || {})

            // copy the &quot;currentPosition&quot; to the test instance for backward compatibility
            this.currentPosition    = this.simulator.currentPosition

            this.SUPERARG(arguments)
        },


        onBeforeTestFinalize : function () {
            var global          = this.global

            // If expectAlertMessage(which overwrites the alert method) was called but no alert() call happened - fail the test
            if (global.alert.__EXPECTED_ALERT__) {
                this.fail(Siesta.Resource(&#39;Siesta.Test.Browser&#39;, &#39;alertMethodNotCalled&#39;))
            }

            this.SUPERARG(arguments)
        },


        getSimulatorClass : function () {
            return Siesta.Test.Simulator
        },


        // setup : function (callback, errback) {
        //     var simulator           = this.simulator
        //
        //     // this will &quot;attach&quot; simulator to a test window, by setting up a &quot;global&quot; property
        //     simulator.onTestLaunch(this)
        //
        //     if (simulator instanceof Siesta.Test.Simulator) {
        //         // synthetic events start with [ 0, 0 ] point anyway, so avoid extra mouseover/mousemove event
        //         callback()
        //     } else {
        //         simulator.simulateMouseMove(0, 0, null, { moveKind : &#39;instant&#39; }).then(callback, errback)
        //     }
        // },


        earlySetup : function (callback, errback) {
            var simulator           = this.simulator

            if (simulator.type == &#39;synthetic&#39;) {
                // synthetic events start with [ 0, 0 ] point anyway, so avoid extra mouseover/mousemove event
                callback()
            } else
                // for native events need to reset the simulation state *before* the test starts
                // all keys up, mouse buttons up, cursor in 0, 0
                simulator.doFullSimulationReset().then(callback, errback)
        },


        launch : function (errorMessage) {
            var me          = this
            var win         = this.global

            // top test
            if (!me.parent) {
                me.realAlert        = win.alert
                me.realConfirm      = win.confirm
                me.realPrompt       = win.prompt
                me.realPrint        = win.print
                me.realOpen         = win.open

                this.maintainScrollPositionDuring(function () {
                    if (!me.project.browserWindowHasFocus() &amp;&amp; !bowser.safari) me.onWindowBlur()

                    // trying to focus the window (hopefully fixes the tab key issues)
                    win.focus &amp;&amp; win.focus()
                })

//                win.addEventListener &amp;&amp; win.addEventListener(&#39;blur&#39;, me.blurListener = function () {
//                    if (bowser.gecko &amp;&amp; win.document.getElementsByTagName(&#39;iframe&#39;).length &gt; 0)
//                        // this &quot;waitFor&quot; can be interrupted, but only by forceful test finalization, which
//                        // happens when test throws exception for example, so it fails anyway
//                        me.waitFor({
//                            method              : 0,
//                            suppressAssertion   : true,
//                            callback            : function () { me.onWindowBlur() }
//                        })
//                    else
//                        me.onWindowBlur()
//                })

                // 1. IE can&#39;t show cursor, since it&#39;s IE.
                // 2. Clients can opt-in for cursor display in automation mode
                // 3. Currently we don&#39;t show cursor for tests running in popups, since that would require
                // injecting cursor element on the test page and we don&#39;t want that
                if (!bowser.msie &amp;&amp; me.project.showCursor &amp;&amp; !win.opener) {
                    me.mouseVisualizer = new Siesta.Project.Browser.UI.MouseVisualizer({
                        currentContainer    : me.global.frameElement.parentElement
                    });
                }
            }

            // WARN: behavior when several sub-tests are running at the same time is not well-defined
            me.previousConfirm      = win.confirm
            me.previousPrompt       = win.prompt

            var emptyFn             = function () {};

            win.alert               = win.print = emptyFn;

            win.confirm = function () {
                var retVal                  = typeof me.nextConfirmValue === &#39;boolean&#39; ? me.nextConfirmValue : true;

                me.nextConfirmValue         = null;

                return retVal;
            };

            win.prompt = function () {
                var retVal                  = me.nextPromptReturnValue || &#39;&#39;;

                me.nextPromptReturnValue    = null;

                return retVal;
            };

            win.open = function (url) {
                var popup   = me.realOpen.apply(win, arguments)

                if (!popup)
                    me.fail(Siesta.Resource(&#39;Siesta.Test.Browser&#39;,&#39;popupsDisabled&#39;, { url : url }))
                else {
                    me.popups.push({ url : url, popup : popup })
                }

                return popup
            }

            this.SUPERARG(arguments)
        },


        onTestFinalize : function () {
            var win         = this.global

            if (win) {
                if (!this.parent) {
                    win.confirm = this.previousConfirm;
                    win.prompt  = this.previousPrompt;

                    win.print   = this.realPrint
                    win.alert   = this.realAlert
                    win.open    = this.realOpen
                } else {
                    win.confirm = this.realConfirm;
                    win.prompt  = this.realPrompt;

                    win.alert   = win.print = function () {}
                }
            }

//            this.blurListener &amp;&amp; win.removeEventListener(&#39;blur&#39;, this.blurListener)
//
//            this.blurListener   = null

            this.SUPERARG(arguments)
        },


        onWindowBlur : function (arg1, arg2) {
//            var doc             = this.global.document
//
//            // ignore the case when focus is moved inside of the child iframe
//            // IGNORE
//            if (!doc.hasFocus &amp;&amp; doc.hasFocus()) return
//
//            var slice           = Array.prototype.slice
//
//            //                  convert from HTMLCollection to Array
//            var iframes         = slice.apply(doc.getElementsByTagName(&#39;iframe&#39;))
//
//            while (iframes.length) {
//                try {
//                    var innerDoc    = iframes[ 0 ].contentWindow.document
//
//                    if (innerDoc.hasFocus()) return
//
//                    iframes.push.apply(iframes, slice.apply(innerDoc.getElementsByTagName(&#39;iframe&#39;)))
//                } catch (e) {
//                }
//
//                iframes.shift()
//            }
//            // EOF IGNORE

            if (this.restartOnBlur)
                this.fireEvent(&#39;focuslost&#39;)
            else
                this.warn(Siesta.Resource(&#39;Siesta.Test.Browser&#39;).get(&#39;focusLostWarning&#39;, { url : this.url }))
        },


        sizzle : function (selector, root) {
            return Siesta.Sizzle(selector, root || this.global.document)
        },


        isEventPrevented : function (event) {
            // our custom property - takes highest priority
            if (event.preventDefault &amp;&amp; this.typeOf(event.preventDefault.$prevented) == &#39;Boolean&#39;) return event.preventDefault.$prevented

            // W3C standards property
            if (this.typeOf(event.defaultPrevented) == &#39;Boolean&#39;) return event.defaultPrevented

            return event.returnValue === false
        },


        // only called for the re-used contexts
        cleanupContextBeforeStart : function () {
            this.cleanupContextBeforeStartDom()

            this.SUPER()
        },


        cleanupContextBeforeStartDom : function () {
            var doc                 = this.global.document

            doc.body.innerHTML      = &#39;&#39;
        },


        getElementPageRect : function (el, $el) {
            $el             = $el || this.$(el)

            var offset      = $el.offset()

            return new Siesta.Util.Rect({
                left        : offset.left,
                top         : offset.top,
                width       : $el.outerWidth(),
                height      : $el.outerHeight()
            })
        },

//        TODO no longer used, remove after some time
//        elementHasScroller : function (el, $el) {
//            $el             = $el || this.$(el)
//
//            var overflowX   = $el.css(&#39;overflow-x&#39;)
//            var overflowY   = $el.css(&#39;overflow-y&#39;)
//
//            var hasX        = el.scrollWidth != el.clientWidth &amp;&amp; overflowX != &#39;visible&#39; &amp;&amp; overflowX != &#39;hidden&#39;
//            var hasY        = el.scrollHeight != el.clientHeight &amp;&amp; overflowY != &#39;visible&#39; &amp;&amp; overflowY != &#39;hidden&#39;
//
//            return hasX || hasY ? { x : hasX, y : hasY } : false
//        },


        hasForcedIframe : function () {
            return Boolean(
                (this.isDOMForced || this.forceDOMVisible) &amp;&amp; (this.scopeProvider instanceof Scope.Provider.IFrame) &amp;&amp; this.scopeProvider.iframe
            )
        },


        getDivBox : function (doc, left, top, width, height) {
            var div             = doc.createElement(&#39;div&#39;)

            div.style.cssText   =
                &#39;position: absolute !important; left: &#39; + left + &#39;px !important; top: &#39; + top + &#39;px !important;&#39; +
                &#39;border-width: 0 !important; padding: 0 !important; margin: 0 !important;&#39; +
                &#39;width: &#39; + width + &#39;px !important; height: &#39; + height + &#39;px !important;&#39;

            return div
        },


        elementIsScrolledOut : function (el, offset) {
            var doc                 = el.ownerDocument
            var win                 = doc.defaultView || doc.parentWindow
            var body                = doc.body

            var parents             = []

            for (var parent = el; parent &amp;&amp; parent != body; parent = parent.parentNode) parents.push(parent)

            var currentRect         = new Siesta.Util.Rect({
                left        : this.getPageScrollX(win),
                top         : this.getPageScrollY(win),

                // using height / width of the *whole viewport*, BODY tag may have 0 height in some cases
                width       : this.$(win).width(),
                height      : this.$(win).height()
            })

            for (var i = parents.length - 1; i &gt;= 0; i--) {
                var parent          = parents[ i ]

                var overflowX       = this.$(parent).css(&#39;overflow-x&#39;)
                var overflowY       = this.$(parent).css(&#39;overflow-y&#39;)

                if (overflowX != &#39;visible&#39; || overflowY != &#39;visible&#39;) {
                    // only get the bounding rect if we need it
                    // in IE10 a series of call to `getBoundingClientRect` of the parent elements
                    // were making the el itself hidden (offsetWidth = offsetHeight = 0)
                    var parentRect  = this.getElementPageRect(parent)

                    if (overflowX != &#39;visible&#39;) {
                        currentRect = currentRect.cropLeftRight(parentRect)
                        if (currentRect.isEmpty()) return true
                    }

                    if (overflowY != &#39;visible&#39;) {
                        currentRect     = currentRect.cropTopBottom(parentRect)

                        if (currentRect.isEmpty()) return true
                    }
                }
            }

            var $el                 = this.$(el)

            var elPageRect          = this.getElementPageRect($el[ 0 ], $el)

            offset                  = this.normalizeOffset(offset, $el)

            return !currentRect.contains(elPageRect.left + offset[ 0 ], elPageRect.top + offset[ 1 ])
        },


        // returns &quot;true&quot; if scrolling has actually occured
        scrollTargetIntoView : function (target, offset) {
            var win             = this.global
            var doc             = win.document

            if (this.typeOf(target) != &#39;Array&#39;) {
                target          = this.normalizeElement(target, true, null, false);
                offset          = this.normalizeOffset(offset, this.$(target))

                var isInside    = this.isOffsetInsideElementBox(target, offset);

                if (
                    target &amp;&amp; this.isElementVisible(target) &amp;&amp;
                    // If element isn&#39;t visible, try to bring it into view
                    isInside &amp;&amp; this.elementIsScrolledOut(target, offset)
                ) {
                    this.maintainScrollPositionDuring(function () {
                        // Required to handle the case where the body is scrolled
                        target.scrollIntoView();
                    })

//                    No longer use jQuery &quot;scrollIntoView&quot; plugin - tests passes w/o it
//                    and it does not take the offset point into account anyway
//                    we still need it for &quot;:scrollable&quot; pseudo (which it does kind of ok)
//                    this.$(target).scrollintoview({ duration : 0 });

                    // If element is still out of view, try manually scrolling first scrollable parent found
                    if (this.elementIsScrolledOut(target, offset)) {

                        var scrollableParent = this.$(target).closest(&#39;:scrollable&#39;)[ 0 ];

                        if (scrollableParent) {
                            var parentBox       = this.getBoundingClientRect(scrollableParent)
                            var targetBox       = this.getBoundingClientRect(target)

                            scrollableParent.scrollLeft = Math.max(0, scrollableParent.scrollLeft + targetBox.left - parentBox.left + offset[ 0 ] - 1)
                            scrollableParent.scrollTop  = Math.max(0, scrollableParent.scrollTop + targetBox.top - parentBox.top + offset[ 1 ] - 1)
                        }
                    }

                    return true
                }
            } else {
                var leftVisible     = this.getPageScrollX()
                var rightVisible    = leftVisible + this.$(win).width()

                var topVisible      = this.getPageScrollY()
                var bottomVisible   = topVisible + this.$(win).height()

                if (
                    leftVisible &lt;= target[ 0 ] &amp;&amp; target[ 0 ] &lt;= rightVisible
                    &amp;&amp; topVisible &lt;= target[ 1 ] &amp;&amp; target[ 1 ] &lt;= bottomVisible
                ) {
                    // no need to scroll, target point is within visible viewport area
                    return false
                }

                var div             = this.getDivBox(doc, target[ 0 ], target[ 1 ], 1, 1)

                doc.body.appendChild(div)

                this.maintainScrollPositionDuring(function () {
                    div.scrollIntoView()
                })

                doc.body.removeChild(div)

                return true
            }
        },


        processSubTestConfig : function (config) {
            var res             = this.SUPER(config)
            var me              = this

            Joose.A.each([
                &#39;currentPosition&#39;,
                &#39;mouseVisualizer&#39;,
                &#39;simulator&#39;,
                &#39;simulatorConfig&#39;,
                &#39;bowser&#39;, &#39;browser&#39;,
                &#39;moveCursorBetweenPoints&#39;,
                &#39;realAlert&#39;, &#39;realConfirm&#39;, &#39;realPrompt&#39;, &#39;realPrint&#39;, &#39;realOpen&#39;, &#39;popups&#39;
            ], function (name) {
                res[ name ]     = me[ name ]
            })

            return res
        },


        // Normalizes the element to an HTML element. Every &#39;framework layer&#39; will need to provide its own implementation
        // This implementation accepts either a CSS selector or an Array with xy coordinates.
        normalizeElement : function (el, allowMissing, shallow, detailed) {
            // Quick exit if already an element
            if (el &amp;&amp; el.nodeName) return el;

            var matchingMultiple = false

            if (this.typeOf(el) === &#39;String&#39;) {
                // DOM query
                var origEl  = el;

                var wasAdjusted = this.adjustScope(el);

                var query   = this.$(el.indexOf(&#39;-&gt;&#39;) &gt;= 0 ? el.split(&#39;-&gt;&#39;)[1] : el);

                if (wasAdjusted) this.resetScope();

                el          = query[ 0 ];
                matchingMultiple = query.length &gt; 1

                if (!allowMissing &amp;&amp; !el) {
                    var warning = Siesta.Resource(&#39;Siesta.Test.Browser&#39;,&#39;noDomElementFound&#39;) + &#39;: &#39; + origEl

                    this.warn(warning);
                    throw new Error(warning);
                }
            }

            if (this.typeOf(el) == &#39;Array&#39;) {
                var x, y

                if (el.length &lt; 2) {
                    x       = this.simulator.currentPosition[ 0 ]
                    y       = this.simulator.currentPosition[ 1 ]
                } else {
                    x       = this.pageXtoViewportX(Math.round(el[ 0 ]))
                    y       = this.pageYtoViewportY(Math.round(el[ 1 ]))
                }

                el          = this.elementFromPoint(x, y);
            }

            return detailed ? { el : el, matchingMultiple : matchingMultiple } : el;
        },


        // this method generally has the same semantic as the &quot;normalizeElement&quot;, its being used in
        // Siesta.Test.Action.Role.HasTarget to determine what to pass to next step
        //
        // on the browser level the only possibility is DOM element
        // but on ExtJS level user can also use ComponentQuery and next step need to receive the
        // component instance
        normalizeActionTarget : function (el, allowMissing) {
            return this.normalizeElement(el, allowMissing);
        },


        randomBetween : function (min, max) {
            return Math.floor(min + (Math.random() * (max - min + 1)));
        },


<span id='Siesta-Test-Browser-method-getElementAtCursor'>        /**
</span>         * This method uses native `document.elementFromPoint()` and returns the DOM element under the current logical cursor
         * position in the test. Note, that this method may work not 100% reliable in IE due to its bugs. In cases
         * when `document.elementFromPoint()` can&#39;t find any element this method returns the &amp;lt;body&amp;gt; element.
         *
         * @return {HTMLElement}
         */
        getElementAtCursor : function() {
            var xy          = this.simulator.currentPosition;

            return this.elementFromPoint(xy[ 0 ], xy[ 1 ])
        },


        addListenerToObservable : function (observable, event, listener, isSingle) {
            this.$(observable).bind(event, listener)
        },


        removeListenerFromObservable : function (observable, event, listener) {
            this.$(observable).unbind(event, listener)
        },

        // This method accepts actionTargets as input (Dom node, string, CQ etc) and does a first
        // normalization pass to get a DOM element.
        // After initial normalization it also tries to locate, the &#39;top&#39; DOM node at the center of
        // the first pass resulting DOM node.
        // This is the only element we can truly interact with in a real browser.
        // returns an object containing the element plus viewport coordinates
        getNormalizedTopElementInfo : function (actionTarget, skipWarning, actionName, offset) {
            var localXY, globalXY, el;

            // support empty array as a synonym for empty target
            if (this.typeOf(actionTarget) == &#39;Array&#39; &amp;&amp; actionTarget.length == 0) { actionTarget = null }

            var targetIsPoint   = !actionTarget || this.typeOf(actionTarget) == &#39;Array&#39;

            // First lets get a normal DOM element to work with
            if (targetIsPoint) {
                // viewport coords
                var x, y

                if (actionTarget) {
                    x       = this.pageXtoViewportX(Math.round(actionTarget[ 0 ]))
                    y       = this.pageYtoViewportY(Math.round(actionTarget[ 1 ]))
                } else {
                    x       = this.simulator.currentPosition[ 0 ]
                    y       = this.simulator.currentPosition[ 1 ]
                }

                globalXY    = [ x, y ]

                var info    = this.elementFromPoint(x, y, false, null, true)

                el          = info.el
                localXY     = info.localXY
            } else {
                el          = this.normalizeElement(actionTarget, skipWarning)
            }

            if (!el &amp;&amp; skipWarning) {
                return;
            }

            // 1. If this element is not visible, something is wrong
            // 2. If element is visible but not reachable (scrolled out of view) this is also an invalid scenario (this check is skipped for IE)
            //    TODO needs further investigation, conflicting with starting a drag operation on an element that isn&#39;t visible until the cursor is above it

            // we don&#39;t need to this check if target is a coordinate point, because in this case element is reachable by definition
            if (!targetIsPoint) {
                var R       = Siesta.Resource(&#39;Siesta.Test.Browser&#39;);
                var message = &#39;getNormalizedTopElementInfo: &#39; + (actionName ? R.get(&#39;targetElementOfAction&#39;) + &quot; [&quot; + actionName + &quot;]&quot; : R.get(&#39;targetElementOfSomeAction&#39;)) +
                    &quot; &quot; + R.get(&#39;isNotVisible&#39;) + &quot;: &quot; + (el.id ? &#39;#&#39; + el.id : el)

                if (!this.isElementVisible(el)) {
                    this.fail(message)
                    return;
                }
                else if (!skipWarning &amp;&amp; this.isOffsetInsideElementBox(el, offset) &amp;&amp; !this.elementIsTop(el, true, offset)) {
                    this.warn(message)
                }
            }

            var isOption    = el &amp;&amp; el.nodeName.toLowerCase() === &#39;option&#39;;

            if (isOption) {
                localXY     = this.simulator.currentPosition.slice();
                globalXY    = this.simulator.currentPosition.slice();
            } else if (!targetIsPoint) {
                var doc     = el.ownerDocument;
                var R       = Siesta.Resource(&#39;Siesta.Test.Browser&#39;);

                localXY     = this.getTargetCoordinate(el, true, offset)
                globalXY    = this.getTargetCoordinate(el, false, offset)

                // trying 2 times for IE
                el          = doc.elementFromPoint(localXY[ 0 ], localXY[ 1 ]) || doc.elementFromPoint(localXY[ 0 ], localXY[ 1 ]) || doc.body;

                if (!el) {
                    this.fail(&#39;getNormalizedTopElementInfo: &#39; + R.get(&#39;noElementFound&#39;) + &#39; [&#39; + localXY + &#39;]&#39;);
                    return; // No point going further
                }
            }

            return {
                el          : el,

                // both are viewport coords
                localXY     : localXY,
                globalXY    : globalXY,

                offset      : isOption ? [ 0, 0 ] : this.getOffsetRelativeToEl(el, localXY)
            }
        },

        // point should be in page coords
        getOffsetRelativeToEl : function(el, point) {
            var box = this.getElementPageRect(el);

            return [ point[0] - box.left, point[1] - box.top ];
        },

<span id='Siesta-Test-Browser-method-waitForTextPresent'>        /**
</span>         * This method will wait for the presence of the passed string.
         *
         * @param {String} text The text to wait for
         * @param {Function} callback The callback to call
         * @param {Object} scope The scope for the callback
         * @param {Number} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForTextPresent : function (text, callback, scope, timeout) {
            var R               = Siesta.Resource(&#39;Siesta.Test.Browser&#39;);

            return this.waitFor({
                method          : function () {
                    var body        = this.global.document.body
                    var selector    = &#39;:contains(&#39; + text + &#39;)&#39;

                    return this.$(selector, body).length &gt; 0 || this.$(body).is(selector);
                },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : &#39;waitForTextPresent&#39;,
                description     : &#39; &#39; + R.get(&#39;text&#39;) + &#39; &quot;&#39; + text + &#39;&quot; &#39; + R.get(&#39;toBePresent&#39;)
            });
        },

<span id='Siesta-Test-Browser-method-waitForTextNotPresent'>        /**
</span>         * This method will wait for the absence of the passed string.
         *
         * @param {String} text The text to wait for
         * @param {Function} callback The callback to call
         * @param {Object} scope The scope for the callback
         * @param {Number} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForTextNotPresent : function (text, callback, scope, timeout) {
            var R               = Siesta.Resource(&#39;Siesta.Test.Browser&#39;);

            return this.waitFor({
                method          : function () {
                    var body        = this.global.document.body
                    var selector    = &#39;:contains(&#39; + text + &#39;)&#39;

                    return this.$(selector, body).length === 0 &amp;&amp; !this.$(body).is(selector);
                },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : &#39;waitForTextNotPresent&#39;,
                description     : &#39; &#39; + R.get(&#39;text&#39;) + &#39; &quot;&#39; + text + &#39;&quot; &#39; + R.get(&#39;toNotBePresent&#39;)
            });
        },

<span id='Siesta-Test-Browser-method-waitForTarget'>        /**
</span>         * Waits until the passed action target is detected. This can be a string such as a component query, CSS query or a composite query.
         *
         * @param {String/Siesta.Test.ActionTarget} target The target presence to wait for
         * @param {Function} callback The callback to call after the target has been found
         * @param {Object} scope The scope for the callback
         * @param {Int} timeout The maximum amount of time to wait for the condition to be fulfilled. Defaults to the {@link Siesta.Test.ExtJS#waitForTimeout} value.
         */
        waitForTarget : function(target, callback, scope, timeout, offset) {
            var me = this;
            var R  = Siesta.Resource(&#39;Siesta.Test.Browser&#39;);

            return this.waitFor({
                method          : function () {
                    var el      = me.normalizeElement(target, true, true, false, { offset : offset })

                    // If user is aiming outside the target, we&#39;ll *not* use the offset while
                    // detecting target presence since having a visible sized box will suffice
                    if (el &amp;&amp; offset &amp;&amp; me.isElementVisible(el) &amp;&amp; !me.isOffsetInsideElementBox(el, offset)) {
                        return true;
                    }

                    return el &amp;&amp; me.elementIsTop(el, true, offset)
                },
                callback        : callback,
                scope           : scope,
                timeout         : timeout,
                assertionName   : &#39;waitForTarget&#39;,
                description     : &#39; &#39; + R.get(&#39;target&#39;) + &#39; &quot;&#39; + target + &#39;&quot; &#39; + R.get(&#39;toAppear&#39;)
            });
        },

<span id='Siesta-Test-Browser-method-setWindowSize'>        /**
</span>         * Sets a new size for the test iframe
         *
         * @param {Int} width The new width
         * @param {Int} height The new height
         */
        setWindowSize : function(width, height, callback) {
            this.scopeProvider.setViewportSize(width, height);

            callback &amp;&amp; callback.call(this);
        },


        getJUnitClass : function () {
            var browserInfo         = this.getBrowserInfo()

            browserInfo             = browserInfo.name + browserInfo.version

            return browserInfo + &#39;:&#39; + this.SUPER()
        },


        // Returns true if the scope was adjusted to another frame for the target string
        adjustScope : function(target) {

            if (this.typeOf(target) == &#39;String&#39;) {
                var mainParts  = target.split(&#39;-&gt;&#39;);

                if (mainParts.length === 2) {
                    var frameEl = this.$(this.trimString(mainParts[ 0 ]))[ 0 ];

                    if (!frameEl || !frameEl.contentWindow) {
                        return false;
                    }

                    this._global    = this.global
                    this.setGlobal(frameEl.contentWindow)

                    return true;
                }
            }

            return false;
        },


        resetScope : function() {
            this.setGlobal(this._global || this.global)

            this._global    = null
        },


        // a stub method for the Lite package
        screenshot : function (options, callback) {
            this.diag(&quot;Command: `screenshot` skipped - not running in Standard Package&quot;)

            this.processCallbackFromTest(callback, [ &#39;skipped&#39; ], this)
        },


        // a stub method for the Lite package
        screenshotElement : function (target, fileName, callback) {
            this.diag(&quot;Command: `screenshot` skipped - not running in Standard Package&quot;)

            this.processCallbackFromTest(callback, [ &#39;skipped&#39; ], this)
        },

<span id='Siesta-Test-Browser-method-setUrl'>        /**
</span>         * setUrl Opens the url provided (make sure you use the {@link Siesta.Project.Browser#enablePageRedirect} option on the Harness when using this API method)
         *
         * @param {String} url The new url for current page
         * @param {Function} callback The callback to call after the page has been loaded
         * @param {Object} scope The scope for the callback
         */
        setUrl : function(url, callback, scope) {
            if (!url) throw new Error(&#39;Must provide a valid URL&#39;);

            var me = this;

            if (me.global.location.href !== url) {
                var baseUrl = this.scopeProvider.sourceURL || this.project.baseUrl;
                var absURl  = this.project.absolutizeURL(url, baseUrl);

                me.waitForPageLoad(callback, scope);
                me.global.location.href = absURl;
            } else {
                callback.call(scope || me);
            }
        },

<span id='Siesta-Test-Browser-method-setHash'>        /**
</span>         * Sets the hash value of the location object
         *
         * @param {String} url The new hash
         * @param {Function} callback
         * @param {Object} scope The scope for the callback
         */
        setHash : function(hash, callback, scope) {
            var me = this;

            me.global.location.hash = hash;

            callback &amp;&amp; callback(scope || me);
        },

<span id='Siesta-Test-Browser-method-expectAlertMessage'>        /**
</span>         * Expects an alert message with the specified text to be shown during the test. If no alert is called,
         * or the text doesn&#39;t match, a failed assertion will be added.
         *
         * @param {String/RegExp} message The expected alert message or a regular expression to match
         * @param callback Only used internally when this method is called in a t.chain command
         */
        expectAlertMessage : function (message, callback) {
            var me          = this
            var global      = this.global
            var prevAlert   = global.alert

            global.alert = function (msg) {
                var passed      = me.typeOf(message) == &#39;RegExp&#39; ? message.test(msg) : message == msg

                if (passed)
                    me.pass(&quot;Expected alert message has been shown&quot;)
                else
                    me.fail(&quot;Wrong alert message has been shown&quot;, {
                        assertionName       : &#39;expectAlertMessage&#39;,
                        got                 : msg,
                        gotDesc             : &quot;Message shown&quot;,
                        need                : message,
                        needDesc            : &quot;Expected message&quot;
                    })

                global.alert = prevAlert
            };

            global.alert.__EXPECTED_ALERT__ = true

            this.processCallbackFromTest(callback, null, this)
        },

<span id='Siesta-Test-Browser-method-setNextConfirmReturnValue'>        /**
</span>         * Sets the confirm dialog return value for the next window.confirm() call.
         *
         * @param {Boolean} value The confirm dialog return value (true or false)
         * @param callback Only used internally when this method is called in a t.chain command
         * */
        setNextConfirmReturnValue : function (value, callback) {
            this.nextConfirmValue = value;

            this.processCallbackFromTest(callback, null, this)
        },

<span id='Siesta-Test-Browser-method-setNextPromptReturnValue'>        /**
</span>         * Sets the prompt dialog return value for the next window.prompt() call.
         *
         * @param {String} value The confirm dialog return value
         * @param callback Only used internally when this method is called in a t.chain command
         */
        setNextPromptReturnValue : function (value, callback) {
            this.nextPromptReturnValue = value;

            this.processCallbackFromTest(callback, null, this)
        },


        waitForAnimations : function(callback) {
            callback.call(this);
        },


        popupHasStartedLoading : function (popup, initialUrl) {
            if (String(initialUrl).toLowerCase() != &#39;about:blank&#39; &amp;&amp; popup.location.href == &#39;about:blank&#39;) return false

            return true
        },


<span id='Siesta-Test-Browser-method-switchTo'>        /**
</span>         * Switches the target of all Siesta interactive commands (like &quot;click/type&quot; etc) to a different
         * window (usually a popup). You can use {@link #switchToMain} method to switch back to main window.
         *
         * @param {String/RegExp/Object/Window/HTMLIFrameElement} [win] A new window which should be a target for all interactive commands.
         * If this argument is specified as `null` a first opened popup is used.
         * Can be specified as the:
         *
         * - Window - A global window instance
         * - Object - Object with the following properties
         *      - url   : String/RegExp - The first popup, opened with matching url will be used
         *      - title : String/RegExp - The first popup, opened with matching title will be used
         * - String - corresponds to the `title` property of the Object branch
         *
         * @param {Function} callback Function to call once the switch has complete (will also wait until the target page
         * completes loading)
         *
         * @return {Window} Previously active window reference
         */
        switchTo : function (win, callback) {
            var me          = this

            // In Chrome, when popup for some url is just created, it has &quot;url&quot; set to &quot;about:blank&quot;
            // after some time the url is set to the original value and load process begins
            // this opens a race condition - one can not reliably predict when the popup has completed loading
            // doing our best
            this.waitFor({
                method              : function () {
                    for (var i = 0; i &lt; me.popups.length; i++)
                        if (!me.popupHasStartedLoading(me.popups[ i ].popup, me.popups[ i ].url)) return false

                    return true
                },
                suppressAssertion   : true,

                callback            : function () {
                    var found

                    if (!win) {
                        Joose.A.each(this.popups, function (handle) {
                            if (!handle.popup.closed) { found = handle.popup;  return false }
                        })

                        win  = found
                    }

                    if (this.typeOf(win) == &#39;String&#39;) win = { title : win }

                    if (this.typeOf(win) == &#39;Object&#39;) {
                        found           = null
                        var regexp      = win.title || win.url

                        if (this.typeOf(regexp) == &#39;String&#39;) regexp = new RegExp(&#39;^&#39; + this.escapeRegExp(regexp) + &#39;$&#39;)

                        Joose.A.each(this.popups, function (handle) {
                            var popup       = handle.popup

                            if (!popup.closed)
                                if (
                                    win.url &amp;&amp; regexp.test(popup.location.href)
                                    ||
                                    win.title &amp;&amp; regexp.test(popup.document &amp;&amp; popup.document.title || &#39;&#39;)
                                ) {
                                    found = popup
                                    return false
                                }
                        })

                        win  = found
                    }

                    if (!win || win.self != win) {
                        this.fail(&quot;Can&#39;t resolve target win: &quot; + win)

                        this.processCallbackFromTest(callback, null, this)

                        return
                    }

                    this.setGlobal(win)
//                    This has to be revised properly in the &quot;context&quot; branch, idea is, that we switch to popup&#39;s implementation
//                    of `setTimeout` for waiting, asyncing etc, because thats what really user expect
//                    however in IE test just hangs
//                    this.originalSetTimeout     = win.setTimeout
//                    this.originalClearTimeout   = win.clearTimeout

                    this.waitFor({
                        suppressAssertion   : true,
                        method      :  function () {
                            return win.document &amp;&amp; win.document.readyState == &#39;complete&#39;
                        },
                        callback    : callback
                    })
                }
            })

            return this.global
        },


        setGlobal : function (newGlobal) {
            this.global             = newGlobal
            this.simulator.global   = newGlobal
        },


<span id='Siesta-Test-Browser-method-switchToMain'>        /**
</span>         * Switches all interactive commands back to main test window.
         *
         * @param {Function} callback Function to call once the switch has complete.
         */
        switchToMain : function (callback) {
            this.switchTo(this.scopeProvider.scope, callback)
        },

<span id='Siesta-Test-Browser-method-waitForPageLoad'>        /**
</span>         * Only useful along with {@link Siesta.Project.Browser.enablePageRedirect enablePageRedirect} option
         *
         * Wait for the page load to occur and runs the callback. The callback will receive a &quot;window&quot; object.
         * Should be used when you are doing a redirect / refresh of the test page:
         *
         *      t.waitForPageLoad(function (window) {
         *          ...
         *      })
         *
         * Note, that method obviously must be called before the new page has completed loading, otherwise it will
         * wait indefinitely and fail (since there will be no page load). So, to avoid the race conditions, one
         * should always start waiting for page load *before* the action, that causes it.
         *
         * Consider the following example (where click on the `&gt;&gt; #loginPanel button` trigger a page redirect):

         // this code does not reliably - it contains a race condition
         // in Chrome, page refresh may happen too fast (even synchronously),
         // so, by the time the `waitForPageLoad` action will start, the page load event will already happen
         // and `waitForPageLoad` will wait indefinitely
         { click : &#39;&gt;&gt; #loginPanel button&#39; },
         { waitFor : &#39;PageLoad&#39;}
         * &amp;nbsp;

         // Need to start waiting first, and only then - click
         // we&#39;ll use &quot;trigger&quot; config of the `wait` action for that
         {
             waitFor     : &#39;PageLoad&#39;,
             trigger     : {
                 click : &#39;&gt;&gt; #loginPanel button&#39;
             }
         }
         // or, same action using function step:
         function (next) {
        t.waitForPageLoad(next)

        t.click(&#39;&gt;&gt; #loginPanel button&#39;, function () {})
    }

         *
         * @method
         * @member Siesta.Test.Browser
         */
        waitForPageLoad : function (callback, scope) {
            var me              = this

            var global          = this.global
            var unloaded        = false
            var description     = Siesta.Resource(&#39;Siesta.Test.More&#39;).get(&#39;pageToLoad&#39;);
            var onUnloadHandler = function () {
                global.removeEventListener(&#39;unload&#39;, onUnloadHandler)

                unloaded        = true
            }

            global.addEventListener(&#39;unload&#39;, onUnloadHandler)

            this.chain(
                {
                    description    : description,
                    waitFor : function () {
                        return unloaded || me.global.document.readyState != &#39;complete&#39;
                    }},
                function (next) {
                    global.removeEventListener(&#39;unload&#39;, onUnloadHandler)

                    global          = null
                    onUnloadHandler = null

                    next()
                },
                {
                    description    : description,
                    waitFor : function () {
                        return me.global.document.readyState == &#39;complete&#39;
                    }
                },
                { waitFor : 50 },
                function () {
                    me.processCallbackFromTest(callback, [ me.global ], scope || me)
                }
            )
        },


<span id='Siesta-Test-Browser-method-setTimeout'>        /**
</span>         * This method will just call the `setTimeout` method from the scope of the test page.
         *
         * Usually you don&#39;t need to use it - you can just call `setTimeout`, but if your test scripts resides in the
         * separate context, you need to use this method for `setTimeout` functionality. See documentation for {@link Siesta.Project.Browser#enablePageRedirect enablePageRedirect}
         * option and &lt;a href=&quot;#!/guide/cross_page_testing&quot;&gt;Cross page testing&lt;/a&gt; guide.
         *
         * @param {Function} func The function to call after specified `delay`
         * @param {Number} delay The time to wait (in ms) before calling the `func`
         * @return {Number} timeoutId The id of the timeout, can be passed to {@link #clearTimeout} to cancel the function execution.
         *
         * @method
         * @member Siesta.Test.Browser
         */
        setTimeout : function (func, delay) {
            var pageSetTimeout = this.global.setTimeout

            pageSetTimeout(func, delay)
        },


<span id='Siesta-Test-Browser-method-clearTimeout'>        /**
</span>         * This method will just call the `clearTimeout` method from the scope of the test page.
         *
         * Usually you don&#39;t need to use it - you can just call `clearTimeout`, but if your test scripts resides in the
         * separate context, you need to use this method for `clearTimeout` functionality. See documentation for {@link Siesta.Project.Browser#enablePageRedirect enablePageRedirect}
         * option and &lt;a href=&quot;#!/guide/cross_page_testing&quot;&gt;Cross page testing&lt;/a&gt; guide.
         *
         * @param {Number} timeoutId The id of the timeout, recevied from the {@link #setTimeout} call
         *
         * @method
         * @member Siesta.Test.Browser
         */
        clearTimeout : function (id) {
            var pageClearTimeout = this.global.clearTimeout

            pageClearTimeout(id)
        },

<span id='Siesta-Test-Browser-method-simulateDeactivateWindow'>        /**
</span>         * This method mimics the deactivation of a browser window by opening a new window. Useful if you want to test
         * how your application behaves when your application is not active.
         *
         * @method
         * @member Siesta.Test.Browser
         */
        simulateDeactivateWindow : function(callback) {
            this.blurWindow = this.global.open(&#39;about:blank&#39;);

            callback &amp;&amp; callback.call(this);
        },

<span id='Siesta-Test-Browser-method-simulateActivateWindow'>        /**
</span>         * This method activates the main browser window reverts focus to the window object of the test.
         *
         * @method
         * @member Siesta.Test.Browser
         */
        simulateActivateWindow : function(callback) {
            this.blurWindow &amp;&amp; this.blurWindow.close();

            this.global.focus();

            this.blurWindow = null;

            callback &amp;&amp; callback.call(this);
        },


<span id='Siesta-Test-Browser-method-query'>        /**
</span>         * This method resolves a query string. At the generic browser level, this is supposed to be a CSS selector
         * (other framework specific layers, like ExtJS adds additional semantic).
         *
         * @param {String} selector
         * @return {Array[Element]}
         */
        query : function (selector) {
            return this.sizzle(selector)
        },


<span id='Siesta-Test-Browser-method-throwsOkAsync'>        /**
</span>         * This assertion passes if an exception with certain message is thrown, during the time since this method has been called
         * and until the `done` function has been called. The `done` function is returned from this method. It should be called once
         * the code, that is expected to throw exception, has completed. `done` function can be called asynchronously.
         *
         * If `done` is not called for more than `timeout` time, this assertions finalizes forcefully.
         *
         * For example:
         *

    var done

    t.chain(
        function (next) {
            done = t.throwsOkAsync(&#39;oops&#39;, &#39;Correct exception thrown&#39;, 25000)
            next()
        },
        // the exception is expected from the click handler
        { click : &#39;.some-button&#39; },
        function (next) {
            done()
            next()
        },
    )

         *
         * See also {@link Siesta.Test.Browser#livesOkAsync} method.
         *
         * @param {String/RegExp} expected The regex against which to test the stringified exception, can be also a plain string
         * @param {String} [desc] The description of the assertion
         * @param {Number} [timeout] The timeout after which this assertion will be finalized forcefully. Default value is {@link Siesta.Project#defaultTimeout}
         *
         * @return {Function} A function which should be called when the code block, which is expected to throw the exception, is completed
         */
        throwsOkAsync : function (expected, desc, timeout) {
            var R                   = Siesta.Resource(&#39;Siesta.Test.More&#39;)
            var me                  = this

            var exceptionThrown     = false
            var doneCalled          = false
            var prevOnError         = this.global.onerror

            var done        = function () {
                if (doneCalled) return
                doneCalled                  = true

                me.endAsync(async)

                if (!exceptionThrown) {
                    me.fail(desc, {
                        assertionName       : &#39;throwsOkAsync&#39;,
                        annotation          : R.get(&#39;didntThrow&#39;)
                    })
                }

                me.isHandlingThrowAsync     = false

                me.global.onerror           = prevOnError

                // return true to suppress possible timeout failure, since `done` is also used as a errback for `beginAsync`
                return true
            }

            this.on(&#39;beforetestfinalize&#39;, function () {
                if (!doneCalled) done()
            }, null, { single : true })

            var async       = this.beginAsync(timeout, done)

            this.isHandlingThrowAsync = true

            this.global.onerror = function (msg, url, lineNumber, col, error) {
                exceptionThrown     = true

                var errorText       = String(error ? error : msg)

                if (me.typeOf(expected) == &quot;RegExp&quot;)

                    if (errorText.match(expected))
                        me.pass(desc, {
                            descTpl             : R.get(&#39;exMatchesRe&#39;),
                            expected            : expected
                        })
                    else
                        me.fail(desc, {
                            assertionName       : &#39;throwsOkAsync&#39;,
                            got                 : errorText,
                            gotDesc             : R.get(&#39;exceptionStringifiesTo&#39;),
                            need                : expected,
                            needDesc            : R.get(&#39;needStringMatching&#39;)
                        })
                else

                    if (errorText.indexOf(expected) != -1)
                        me.pass(desc, {
                            descTpl             : R.get(&#39;exContainsSubstring&#39;),
                            expected            : expected
                        })
                    else
                        me.fail(desc, {
                            assertionName       : &#39;throwsOkAsync&#39;,
                            got                 : errorText,
                            gotDesc             : R.get(&#39;exceptionStringifiesTo&#39;),
                            need                : expected,
                            needDesc            : R.get(&#39;needStringContaining&#39;)
                        })

                // &quot;hide&quot; the exception
                return true
            }

            return done
        },


<span id='Siesta-Test-Browser-method-livesOkAsync'>        /**
</span>         * This assertion passes if no exceptions are thrown, during the time since this method has been called
         * and until the `done` function has been called. The `done` function is returned from this method. It should be called once
         * the code, that is expected to not throw exceptions, has completed. `done` function can be called asynchronously.
         *
         * If `done` is not called for more than `timeout` time, this assertions finalizes forcefully.
         *
         * For example:
         *

    var done

    t.chain(
        function (next) {
            done = t.livesOkAsync(&#39;No exception thrown&#39;)
            next()
        },
        // the exception is expected from the click handler
        { click : &#39;.some-button&#39; },
        function (next) {
            done()
            next()
        }
    )

         *
         * See also {@link Siesta.Test.Browser#throwsOkAsync} method.
         *
         * @param {String} [desc] The description of the assertion
         * @param {Number} [timeout] The timeout after which this assertion will be finalized forcefully. Default value is {@link Siesta.Project#defaultTimeout}
         *
         * @return {Function} A function which should be called when the code block, which is expected to now throw exceptions, is completed
         */
        livesOkAsync : function (desc, timeout) {
            var R                   = Siesta.Resource(&#39;Siesta.Test.More&#39;)
            var me                  = this

            var exceptionThrown     = false
            var doneCalled          = false
            var prevOnError         = this.global.onerror

            var done        = function () {
                if (doneCalled) return
                doneCalled                  = true

                me.endAsync(async)

                if (!exceptionThrown) {
                    me.pass(desc, {
                        descTpl             : R.get(&#39;fnDoesntThrow&#39;)
                    })
                }

                me.isHandlingThrowAsync     = false

                me.global.onerror           = prevOnError

                // return true to suppress possible timeout failure, since `done` is also used as a errback for `beginAsync`
                return true
            }

            this.on(&#39;beforetestfinalize&#39;, function () {
                if (!doneCalled) done()
            }, null, { single : true })

            var async       = this.beginAsync(timeout, done)

            this.isHandlingThrowAsync = true

            this.global.onerror = function (msg, url, lineNumber, col, error) {
                exceptionThrown     = true

                var errorText       = String(error ? error : msg)

                me.fail(desc, {
                    assertionName       : &#39;livesOk&#39;,
                    annotation          : R.get(&#39;fnThrew&#39;) + &#39;: &#39; + errorText
                })

                // &quot;hide&quot; the exception
                return true
            }

            return done
        },


        onException : function () {
            if (this.isHandlingThrowAsync) return true
        }
    }
});
</pre>
</body>
</html>
