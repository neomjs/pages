<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*

Siesta 5.3.0
Copyright(c) 2009-2019 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
Role(&#39;Siesta.Test.Simulate.Touch&#39;, {

    requires        : [
    ],

    has: {
        touchEventNamesMap  : {
            lazy        : &#39;this.buildTouchEventNamesMap&#39;
        },

        currentTouchId  : 1,

        activeTouches   : Joose.I.Object,

        longPressDelay      : {
            init        : 1500,
            is          : &#39;rw&#39;
        },

        forceTouchEvents    : bowser.chrome
    },


    methods: {

        simulateTap : function (context, options) {

            var queue       = new Siesta.Util.Queue({
                deferer         : this.test.originalSetTimeout,
                deferClearer    : this.test.originalClearTimeout,

                interval        : 30,

                observeTest     : this.test
            })

            var me          = this;
            var id

            queue.addStep({
                processor : function () {
                    id      = me.touchStart(null, null, options, context)
                }
            })
            queue.addStep({
                processor : function () {
                    me.touchEnd(id, options)
                }
            })

            return new Promise(function (resolve, reject) {
                queue.run(resolve)
            })
        },


        simulateDoubleTap : function (context, options) {

            var queue       = new Siesta.Util.Queue({
                deferer         : this.test.originalSetTimeout,
                deferClearer    : this.test.originalClearTimeout,

                interval        : 30,

                observeTest     : this.test
            })

            var me      = this;
            var id

            queue.addStep({
                processor : function () {
                    id      = me.touchStart(null, null, options, context)
                }
            })
            queue.addStep({
                processor : function () {
                    me.touchEnd(id, options)
                }
            })
            queue.addStep({
                processor : function () {
                    id      = me.touchStart(null, null, options, context)
                }
            })
            queue.addStep({
                processor : function () {
                    me.touchEnd(id, options)
                }
            })

            return new Promise(function (resolve, reject) {
                queue.run(resolve)
            })
        },


        simulateLongPress : function (context, options) {

            var queue       = new Siesta.Util.Queue({
                deferer         : this.test.originalSetTimeout,
                deferClearer    : this.test.originalClearTimeout,

                interval        : 30,

                observeTest     : this.test
            })

            var me      = this;
            var id

            queue.addStep({
                processor : function () {
                    id      = me.touchStart(null, null, options, context)
                }
            })
            queue.addDelayStep(this.getLongPressDelay())
            queue.addStep({
                processor : function () {
                    me.touchEnd(id, options)
                }
            })

            return new Promise(function (resolve, reject) {
                queue.run(resolve)
            })
        },


        simulatePinch : function (context1, context2, options) {

            var queue       = new Siesta.Util.Queue({
                deferer         : this.test.originalSetTimeout,
                deferClearer    : this.test.originalClearTimeout,

                interval        : 30,

                observeTest     : this.test
            })

            var id1, id2

            var dx          = context1.localXY[ 0 ] - context2.localXY[ 0 ]
            var dy          = context1.localXY[ 1 ] - context2.localXY[ 1 ]

            var distance    = Math.sqrt(dx * dx + dy * dy)

            if (distance &lt; 1) distance = 1

            var scaled      = distance * scale
            var delta       = (scaled - distance) / 2

            var angle       = Math.atan(dy / dx)

            var x1          = Math.round(context1.localXY[ 0 ] - delta * Math.cos(angle))
            var y1          = Math.round(context1.localXY[ 1 ] - delta * Math.sin(angle))

            var x2          = Math.round(context2.localXY[ 0 ] + delta * Math.cos(angle))
            var y2          = Math.round(context2.localXY[ 1 ] + delta * Math.sin(angle))

            var options2    = Joose.O.extend({}, options)

            queue.addStep({
                processor : function () {
                    id1     = me.touchStart(null, null, options, context1)
                    id2     = me.touchStart(null, null, options2, context2)
                }
            })
            queue.addAsyncStep({
                processor : function (data) {
                    var move1Done   = false
                    var move2Done   = false

                    me.touchMove(id1, x1, y1, function () {
                        move1Done       = true

                        if (move1Done &amp;&amp; move2Done) data.next()
                    }, null, options)

                    me.touchMove(id2, x2, y2, function () {
                        move2Done       = true

                        if (move1Done &amp;&amp; move2Done) data.next()
                    }, null, options2)
                }
            })
            queue.addStep({
                processor : function () {
                    me.touchEnd(id1, options)
                    me.touchEnd(id2, options2)
                }
            })

            return new Promise(function (resolve, reject) {
                queue.run(resolve)
            })
        },


        simulateTouchDrag : function (sourceXY, targetXY, options, dragOnly) {
            var me          = this
            options         = options || {};

            // For drag operations we should always use the top level document.elementFromPoint
            var source      = me.elementFromPoint(sourceXY[ 0 ], sourceXY[ 1 ], true);
            var target      = me.elementFromPoint(targetXY[ 0 ], targetXY[ 1 ], true);

            var queue       = new Siesta.Util.Queue({
                deferer         : this.test.originalSetTimeout,
                deferClearer    : this.test.originalClearTimeout,

                interval        : me.dragDelay,
                callbackDelay   : me.afterActionDelay,

                observeTest     : this.test
            });

            var id

            queue.addStep({
                processor : function () {
                    id      = me.touchStart(sourceXY, null, options)
                }
            })
            queue.addAsyncStep({
                processor : function (data) {
                    me.touchMove(id, targetXY[ 0 ], targetXY[ 1 ], options).then(data.next)
                }
            })
            queue.addStep({
                processor : function () {
                    // if `dragOnly` flag is set, do not finalize the touch, instead, pass the touch id
                    // to the user in the callback (see below)
                    if (!dragOnly) me.touchEnd(id, options)
                }
            })

            return new Promise(function (resolve, reject) {
                queue.run(function () {
                    // if `dragOnly` flag is set pass the touch id as promise result
                    if (dragOnly)
                        resolve(id)
                    else
                        resolve()
                })
            })
        },


        touchStart : function (target, offset, options, context) {
            if (!context) context = this.test.getNormalizedTopElementInfo(target, true, &#39;touchStart&#39;, offset)

            options         = Joose.O.extend({
                clientX     : context.localXY[ 0 ],
                clientY     : context.localXY[ 1 ]
            }, options || {})

            var event       = this.simulateTouchEventGeneric(context.el, &#39;start&#39;, options)

            return event.pointerId || event.changedTouches[ 0 ].identifier
        },


        touchEnd : function (touchId, options) {
            var touch       = this.activeTouches[ touchId ]

            if (!touch) throw &quot;Can&#39;t find active touch: &quot; + touchId

            options         = Joose.O.extend({
                clientX     : touch.clientX,
                clientY     : touch.clientY
            }, options || {})

            var target      = touch.target

            if (!this.test.isInDom(target)) {
                touch.target = this.global.document.body
            }

            this.simulateTouchEventGeneric(touch.currentEl || touch.target, &#39;end&#39;, options, { touchId : touchId })
        },


        touchMove : function (touchId, toX, toY, options) {
            var touch       = this.activeTouches[ touchId ]

            if (!touch) throw &quot;Can&#39;t find active touch: &quot; + touchId

            var me          = this
            var overEls     = []

            return this.movePointerTemplate({
                xy              : [ touch.clientX, touch.clientY ],
                xy2             : [ toX, toY ],
                options         : options || {},

                overEls         : overEls,
                interval        : me.dragDelay,
                callbackDelay   : me.afterActionDelay,
                pathBatchSize   : me.pathBatchSize,

                onVoidOverEls   : function () {
                    return overEls = []
                },

                onPointerEnter  : function (el, options) {
                },

                onPointerLeave  : function (el, options) {
                },

                onPointerOver   : function (el, options) {
                },

                onPointerOut    : function (el, options) {
                },

                onPointerMove   : function (el, options) {
                    touch.clientX       = options.clientX
                    touch.clientY       = options.clientY

                    touch.pageX         = me.viewportXtoPageX(options.clientX)
                    touch.pageY         = me.viewportYtoPageY(options.clientY)

                    touch.currentEl     = el

                    me.simulateTouchEventGeneric(el, &#39;move&#39;, options, { touchId : touchId })
                }
            })
        },


        // never used yet, should be called when touchMove goes out of the document
        touchCancel : function (touchId, options) {
            var touch       = this.activeTouches[ touchId ]

            if (!touch) throw &quot;Can&#39;t find active touch: &quot; + touchId

            this.simulateTouchEventGeneric(touch.currentEl || touch.target, &#39;cancel&#39;, options, { touchId : touchId })
        },


        simulatePointerEventModern : function (target, type, options, simOptions) {
            target          = this.test.normalizeElement(target)

            if (!target) return false

            var supports    = Siesta.Project.Browser.FeatureSupport().supports

            options         = options || {}

            if (/pointerdown$/i.test(type) &amp;&amp; (!(&quot;clientX&quot; in options) || !(&quot;clientY&quot; in options))) {
                var center  = this.test.findCenter(target);

                options     = Joose.O.extend({
                    clientX     : center[ 0 ],
                    clientY     : center[ 1 ]
                }, options)
            }

            var doc         = this.global.document

            var event       = new PointerEvent(type, {
                bubbles         : true,
                cancelable      : true,

                view            : this.global,
                detail          : options.detail,

                screenX         : options.screenX,
                screenY         : options.screenY,

                clientX         : options.clientX,
                clientY         : options.clientY,

                ctrlKey         : options.ctrlKey || false,
                altKey          : options.altKey || false,
                shiftKey        : options.shiftKey || false,
                metaKey         : options.metaKey || false,

                button          : options.button,
                relatedTarget   : options.relatedTarget || doc.documentElement,

                pointerId       : simOptions.touchId || this.currentTouchId++,

                // pointerType
                // NOTE: this has to be set to &quot;mouse&quot; (IE11) or 4 (IE10, 11) because otherwise
                // ExtJS5 blocks the event
                // need to investigate what happens in SenchaTouch
                pointerType     : 4 //mouse
            })

            target.dispatchEvent(event)

            return event
        },


        simulatePointerEvent : function (target, type, options, simOptions) {
            var supports    = Siesta.Project.Browser.FeatureSupport().supports

            if (supports.PointerEvents &amp;&amp; this.bowser.chrome) return this.simulatePointerEventModern(target, type, options, simOptions)

            target          = this.test.normalizeElement(target)

            if (!target) return false

            options         = options || {}

            var doc         = this.global.document,
                event       = doc.createEvent(
                    supports.PointerEvents ? &#39;PointerEvent&#39; : supports.MSPointerEvents ? &#39;MSPointerEvent&#39; : &#39;MouseEvents&#39;
                )

            if (/pointerdown$/i.test(type) &amp;&amp; (!(&quot;clientX&quot; in options) || !(&quot;clientY&quot; in options))) {
                var center  = this.test.findCenter(target);

                options     = Joose.O.extend({
                    clientX     : center[ 0 ],
                    clientY     : center[ 1 ]
                }, options)
            }

            event[ (supports.MSPointerEvents || supports.PointerEvents) ? &#39;initPointerEvent&#39; : &#39;initMouseEvent&#39; ](
                type, true, true, this.global, options.detail,
                options.screenX, options.screenY, options.clientX, options.clientY,
                options.ctrlKey || false, options.altKey || false, options.shiftKey || false, options.metaKey || false,
                options.button, options.relatedTarget || doc.documentElement,
                // the following extra args are used in the &quot;initPointerEvent&quot;
                // offsetX, offsetY
                null, null,
                // width, height
                null, null,
                // pressure, rotation
                null, null,
                // tiltX, tiltY
                null, null,
                // pointerId
                simOptions.touchId || this.currentTouchId++,
                // pointerType
                // NOTE: this has to be set to &quot;mouse&quot; (IE11) or 4 (IE10, 11) because otherwise
                // ExtJS5 blocks the event
                // need to investigate what happens in SenchaTouch
                4,//&#39;mouse&#39;,
                // timestamp, isPrimary
                null, null
            );

            if (!(supports.MSPointerEvents || supports.PointerEvents)) {
                event.pointerId = simOptions.touchId || this.currentTouchId++
            }

            target.dispatchEvent(event)

            return event
        },


        simulateTouchEvent : function (target, type, options, simOptions) {
            options         = options || {}
            var global      = this.global
            var doc         = global.document

            var event       = new global.CustomEvent(type, {
                bubbles     : true,
                cancelable  : true
            })

            var target      = this.test.normalizeElement(target)

            var clientX, clientY

            if ((&quot;clientX&quot; in options) &amp;&amp; (&quot;clientY&quot; in options)) {
                clientX     = options.clientX
                clientY     = options.clientY
            } else {
                var center  = this.test.findCenter(target);

                clientX     = center[ 0 ]
                clientY     = center[ 1 ]
            }

            var activeTouches   = this.activeTouches
            var touch           = simOptions.touch
            var touches         = []
            var targetTouches   = []

            for (var id in activeTouches) {
                var currentTouch    = activeTouches[ id ]

                touches.push(currentTouch)
                if (currentTouch.target == target) targetTouches.push(currentTouch)
            }

            Joose.O.extend(event, {
                target          : target,

                changedTouches  : this.createTouchList([ touch ]),

                touches         : this.createTouchList(touches),
                targetTouches   : this.createTouchList(targetTouches),

                altKey          : options.altKey,
                metaKey         : options.metaKey,
                ctrlKey         : options.ctrlKey,
                shiftKey        : options.shiftKey
            });

            target.dispatchEvent(event)

            return event
        },


        createTouchList : function  (touchList) {
            var doc         = this.global.document

            // a branch for browsers supporting &quot;createTouch/createTouchList&quot;
            if (doc.createTouch) {
                var touches = [];

                for (var i = 0; i &lt; touchList.length; i++) {
                    var touchCfg    = touchList[ i ];

                    touches.push(doc.createTouch(
                        doc.defaultView || doc.parentWindow,
                        touchCfg.target,
                        touchCfg.identifier || this.currentTouchId++,
                        touchCfg.pageX,
                        touchCfg.pageY,
                        touchCfg.screenX || touchCfg.pageX,
                        touchCfg.screenY || touchCfg.pageY,
                        touchCfg.clientX,
                        touchCfg.clientY
                    ))
                }

                return doc.createTouchList.apply(doc, touches);
            } else
                return touchList
        },


        createTouch: function (target, clientX, clientY) {
            return {
                identifier  : this.currentTouchId++,
                target      : target,

                clientX     : clientX,
                clientY     : clientY,

                screenX     : 0,
                screenY     : 0,

                // TODO should take scrolling into account
                pageX       : clientX,
                pageY       : clientY
            }
        },


        buildTouchEventNamesMap : function () {
            var supports        = Siesta.Project.Browser.FeatureSupport().supports

            return supports.PointerEvents &amp;&amp; !this.forceTouchEvents ?
                {
                    start   : &#39;pointerdown&#39;,
                    move    : &#39;pointermove&#39;,
                    end     : &#39;pointerup&#39;,
                    cancel  : &#39;pointercancel&#39;
                }
                : supports.MSPointerEvents ?
                    {
                        start   : &#39;MSPointerDown&#39;,
                        move    : &#39;MSPointerMove&#39;,
                        end     : &#39;MSPointerUp&#39;,
                        cancel  : &#39;MSPointerCancel&#39;
                    }
                    : /*supports.TouchEvents ?*/
                    {
                        start   : &#39;touchstart&#39;,
                        move    : &#39;touchmove&#39;,
                        end     : &#39;touchend&#39;,
                        cancel  : &#39;touchcancel&#39;
                    }
//                :
//                // todo: fire mouseevents?
//                (function () { throw &quot;Touch events not supported&quot; })()
        },


        simulateTouchEventGeneric : function (target, type, options, simOptions) {
            simOptions      = simOptions || {}

            var target      = this.test.normalizeElement(target)

            var clientX, clientY

            if ((&quot;clientX&quot; in options) &amp;&amp; (&quot;clientY&quot; in options)) {
                clientX     = options.clientX
                clientY     = options.clientY
            } else {
                var center  = this.test.findCenter(target);

                clientX     = center[ 0 ]
                clientY     = center[ 1 ]
            }

            var activeTouches   = this.activeTouches
            var touch

            if (type === &#39;end&#39; || type === &#39;cancel&#39;) {
                touch       = activeTouches[ simOptions.touchId ]

                target      = touch.currentEl || touch.target

                delete activeTouches[ simOptions.touchId ]
            } else if (type == &#39;start&#39;) {
                touch       = this.createTouch(target, clientX, clientY)

                activeTouches[ touch.identifier ] = touch

            } else if (type == &#39;move&#39;) {
                touch           = activeTouches[ simOptions.touchId ]

                // &quot;*move&quot; events should be fired only from the &quot;movePointerTemplate&quot; method
                // which provides the &quot;clientX/clientY&quot; properties
                touch.clientX   = options.clientX
                touch.clientY   = options.clientY
            }

            if (!touch) throw &quot;Can&#39;t find active touch&quot; + (simOptions.touchId ? &#39;: &#39; + simOptions.touchId : &#39;&#39;)

            if (!simOptions.touchId) simOptions.touchId = touch.identifier

            simOptions.touch    = touch

            var eventType       = this.getTouchEventNamesMap()[ type ]
            var supports        = Siesta.Project.Browser.FeatureSupport().supports

            if ((supports.PointerEvents || supports.MSPointerEvents) &amp;&amp; !this.forceTouchEvents) {
                return this.simulatePointerEvent(target, eventType, options, simOptions)
            } else /*if (supports.TouchEvents)*/ {
                return this.simulateTouchEvent(target, eventType, options, simOptions);
            }
//            } else {
//                // TODO fallback to mouse events?
//                throw &quot;Can&#39;t simulate any type of touch events&quot;
//            }
        }
    }
});</pre>
</body>
</html>
