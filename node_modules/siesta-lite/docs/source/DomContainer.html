<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*

Siesta 5.3.0
Copyright(c) 2009-2019 Bryntum AB
https://bryntum.com/contact
https://bryntum.com/products/siesta/license

*/
Ext.define(&#39;Siesta.Project.Browser.UI.DomContainer&#39;, {
    extend : &#39;Ext.Panel&#39;,
    alias  : &#39;widget.domcontainer&#39;,

    requires                : [
        &#39;Siesta.Project.Browser.UI.ComponentInspector&#39;
    ],

    cls                     : &#39;siesta-domcontainer&#39;,
    header                  : false,
    collapsible             : true,
    animCollapse            : false,
    padding                 : 10,

    test                    : null,
    testListeners           : null,

    scaleToFit              : true,
    scaleToFitMode          : &#39;full&#39;,

    maintainViewportSize    : true,
    canManageDOM            : true,
    suspendAfterLayoutAlign : false,

    inspector               : null,
    inspectorConfig         : null,
    enableConsole           : true,

    trackMouse              : true,

    initComponent : function () {
        var me = this;

        this.testListeners  = []

        this.title          = Siesta.Resource(&#39;Siesta.Project.Browser.UI.DomContainer&#39;, &#39;title&#39;);

        //this.addEvents(
        //    &#39;inspectionstart&#39;,
        //    &#39;inspectionstop&#39;,
        //    &#39;targethover&#39;,
        //    &#39;targetselected&#39;
        //)

        if (this.enableConsole) {
            Ext.apply(this, {
                dockedItems : this.consoleCt = {
                    xtype     : &#39;component&#39;,
                    dock      : &#39;bottom&#39;,
                    hidden    : true,
                    height    : 20,
                    cls       : &#39;domcontainer-console&#39;,
                    renderTpl : &#39;&lt;div&gt;&lt;input type=&quot;text&quot; /&gt;&lt;/div&gt;&#39;
                }
            });
        }

        this.callParent()

        this.on({
            afterlayout : this.onAfterLayout,
            expand      : this.onExpand,
            collapse    : this.onCollapse,

            scope : this
        });

        this.inspector = new Siesta.Project.Browser.UI.ComponentInspector(this.inspectorConfig);

        if (this.trackMouse) {
            this.inspector.on({
                start : this.onInspectionStart,
                stop  : this.onInspectionStop,
                scope : this
            });
        }

        this.relayEvents(this.inspector, [&#39;start&#39;, &#39;stop&#39;], &#39;inspection&#39;)

        this.enableBubble(&#39;statechange&#39;);
    },


    afterRender : function () {
        this.callParent(arguments);

        if (this.enableConsole) {
            var input = this.consoleInput = this.el.down(&#39;.domcontainer-console input&#39;);

            this.inspector.on(&#39;targethover&#39;, function (dc, cmp) {
                input.dom.value = &#39;Ext.getCmp(&quot;&#39; + cmp.id + &#39;&quot;).&#39;;
            });

            this.inspector.on(&#39;targetselected&#39;, function (dc, cmp) {
                input.focus(true);
            });

            input.on({
                keyup : function (e, t) {
                    var val = input.dom.value;

                    if (e.getKey() === e.ENTER &amp;&amp; val) {
                        var frame = this.getIFrame();

                        try {
                            var retVal = frame.contentWindow.eval(val);
                            if (window.console) {
                                console.log(retVal);
                            }
                        } catch (e) {
                            window.console &amp;&amp; console.log(e.message);
                        }
                    }
                },
                scope : this
            });
        }
    },


    setScaleToFit : function (scaleToFit, mode) {
        if (this.scaleToFit == scaleToFit &amp;&amp; (!mode || this.scaleToFitMode == mode)) return

        this.scaleToFit = scaleToFit
        if (mode) this.scaleToFitMode = mode

        if (scaleToFit) {
            this.doScaleToFit();
        } else {
            this.undoScaleToFit();
        }

        this.fireEvent(&#39;statechange&#39;)
    },


    doScaleToFit : function (isInitial) {
        var iframe      = this.getIFrame();
        if (!iframe) return

        var mode            = this.scaleToFitMode
        var scrollbarSize   = Ext.getScrollbarSize()

        var innerWrapper    = iframe.parentNode
        var scrollCanvas    = innerWrapper.parentNode
        var wrapper         = scrollCanvas.parentNode

        var availableWidth  = this.body.dom.offsetWidth - (mode === &#39;width&#39; ? scrollbarSize.width : 0)
        var availableHeight = this.body.dom.offsetHeight - (mode === &#39;height&#39; ? scrollbarSize.height : 0)

        var contentWidth    = iframe.offsetWidth
        var contentHeight   = iframe.offsetHeight

        var widthScale      = availableWidth / contentWidth
        var heightScale     = availableHeight / contentHeight

        var scale           = mode === &#39;width&#39; ? widthScale :
                              mode === &#39;height&#39; ? heightScale :
                              Math.min(widthScale, heightScale)

        var leftWidth       = availableWidth - scale * contentWidth
        var leftHeight      = availableHeight - scale * contentHeight

        var left            = Math.max(0, leftWidth / 2)
        var top             = Math.max(0, leftHeight / 2)

        innerWrapper.style.transition    = isInitial ? &#39;none&#39; : &#39;transform 0.3s&#39;
        innerWrapper.style.transform     = &#39;translate(&#39; + left + &#39;px, &#39; + top + &#39;px) scale(&#39; + scale + &#39;) &#39;;

        scrollCanvas.style.width    = scale * contentWidth + &#39;px&#39;
        scrollCanvas.style.height   = scale * contentHeight + &#39;px&#39;

        this.removeScaleToFitClasses(wrapper)

        Ext.fly(wrapper).addCls(&#39;scaleToFit&#39; + Joose.S.uppercaseFirst(mode));

        this.scrollTo(0, 0);

        // the &quot;min&quot; in the name should be removed
        var viewportSize        = this.test.scopeProvider.minViewportSize

        innerWrapper.style.width     = viewportSize.width + &#39;px&#39;
        innerWrapper.style.height    = viewportSize.height + &#39;px&#39;
    },


    removeScaleToFitClasses : function (wrapper) {
        Ext.fly(wrapper).removeCls(&#39;scaleToFitFull&#39;);
        Ext.fly(wrapper).removeCls(&#39;scaleToFitWidth&#39;);
        Ext.fly(wrapper).removeCls(&#39;scaleToFitHeight&#39;);
    },


    undoScaleToFit : function () {
        var iframe                  = this.getIFrame();
        if (!iframe) return

        var innerWrapper            = iframe.parentNode
        var scrollCanvas            = innerWrapper.parentNode

        this.removeScaleToFitClasses(scrollCanvas.parentNode)

        innerWrapper.style.transform    = &#39;&#39;
        innerWrapper.style.width        = iframe.style.width
        innerWrapper.style.height       = iframe.style.height
        innerWrapper.style.left         = &#39;&#39;
        innerWrapper.style.top          = &#39;&#39;

        scrollCanvas.style.width        = iframe.style.width
        scrollCanvas.style.height       = iframe.style.height
    },


    setCanManageDOM : function (value) {
        this.canManageDOM = value

        if (value &amp;&amp; !this.hidden) this.alignIFrame()
    },


    getIFrameWrapper : function (force) {
        var test = this.test;

        if (test)
            return (this.canManageDOM || force) &amp;&amp; test.scopeProvider &amp;&amp; test.scopeProvider.wrapper || null
        else
            return null;
    },


    getIFrame : function (force) {
        var test = this.test;

        if (test)
            return (this.canManageDOM || force) &amp;&amp; test.scopeProvider &amp;&amp; test.scopeProvider.iframe || null
        else
            return null;
    },


    onAfterLayout : function () {
        if (!this.suspendAfterLayoutAlign) this.alignIFrame();
    },


    alignIFrame : function (force, isInitial) {
        var wrapper = this.getIFrameWrapper(force);

        if (!this.isFrameVisible() || !wrapper) return

        Ext.fly(wrapper).removeCls(&#39;tr-iframe-hidden&#39;)
        Ext.fly(wrapper).removeCls(&#39;tr-iframe-forced&#39;)

        var box = this.body.getBox()

        Ext.fly(wrapper).setBox(box)

        if (!this.maintainViewportSize) {
            Ext.fly(this.getIFrame(force)).setSize(this.body.getSize())
        }

        if (this.scaleToFit)
            this.doScaleToFit(isInitial)
        else
            this.undoScaleToFit()

        var test = this.test

        test &amp;&amp; test.fireEvent(&#39;testframeshow&#39;)
    },


    onCollapse : function () {
        this.hideIFrame();
    },


    onExpand : function () {
        this.alignIFrame();
    },


    hideIFrame : function () {
        var iframe = this.getIFrameWrapper()

        iframe &amp;&amp; Ext.fly(iframe).setStyle({
            left : &#39;-10000px&#39;,
            top  : &#39;-10000px&#39;
        })

        var test = this.test

        test &amp;&amp; test.fireEvent(&#39;testframehide&#39;)
    },


    isFrameVisible : function () {
        return !(this.hidden || this.collapsed)
    },


    showTest : function (test) {
        this.stopInspection();

        if (this.test) {
            Joose.A.each(this.testListeners, function (listener) {
                listener.remove()
            })

            this.testListeners = []

            this.hideIFrame()
        }

        this.test = test

        this.testListeners = [
            test.on(&#39;testfinalize&#39;, this.onTestFinalize, this)
        ]

        // when starting the test with forcedIframe - do not allow the assertion grid to change the location of the iframe
        // (canManageDOM is set to false)
        this.setCanManageDOM(!test.hasForcedIframe())

        this.alignIFrame(false, true);
    },


    onTestFinalize : function (event, test) {
        this.setCanManageDOM(true)

        // this prevents project from hiding the iframe, because &quot;test.hasForcedIframe()&quot; will return null
        // we&#39;ve moved the iframe to the correct position, and it can never be &quot;forced&quot; again anyway
        if (this.isFrameVisible()) {
            test.forceDOMVisible    = false
            test.isDOMForced        = false
        }
    },


    destroy                 : function () {
        Ext.destroy(this.boxIndicator);
        this.boxIndicator = null;

        // just in case
        this.hideIFrame()

        Joose.A.each(this.testListeners, function (listener) {
            listener.remove()
        })

        this.test = null

        this.callParent(arguments)
    },

    // BEGIN Inspection related code
    // -----------------------------
    inspectedComponent      : null,
    inspectedComponentXType : null,
    boxIndicator            : null,

    inspecting : false,

    toggleInspectionMode : function (on) {
        if (!this.test) return;

        if (on) {
            this.startInspection();

        } else {
            this.stopInspection();
        }
    },


    startInspection : function (showConsole) {
        if (!this.test || !this.test.global) return;

        var wrap = Ext.get(this.getIFrameWrapper());

        this.inspector.start(this.test.global, wrap.down(&#39;.tr-iframe-wrapper-inner&#39;, true));

        if (this.trackMouse) {
            wrap.un(&#39;mouseout&#39;, this.onMouseLeave, this);
            wrap.on(&#39;mouseout&#39;, this.onMouseLeave, this);
        }

        if (this.enableConsole &amp;&amp; showConsole !== false) {
            if (!(this.consoleCt instanceof Ext.Component)) {
                this.consoleCt = Ext.widget(this.consoleCt);
            }
            this.consoleCt.show();
        }
        this.addCls(&#39;inspection-mode&#39;);
    },


    stopInspection : function () {
        this.inspector.stop();

        this.removeCls(&#39;inspection-mode&#39;);

        if (this.enableConsole &amp;&amp; this.consoleCt.rendered) {
            this.consoleCt.hide();
        }
    },


    onMouseLeave : function (e, t) {
        if (!this.el.contains(e.relatedTarget) &amp;&amp; !Ext.fly(this.getIFrameWrapper()).contains(e.relatedTarget)) {
            this.stopInspection();
        }
    },


    onInspectionStart : function () {
        var wrap = Ext.get(this.getIFrameWrapper());

        if (wrap) {
            wrap.on(&#39;mouseout&#39;, this.onMouseLeave, this);
        }
    },


    onInspectionStop : function () {
        var wrap = Ext.get(this.getIFrameWrapper());

        if (wrap) {
            wrap.un(&#39;mouseout&#39;, this.onMouseLeave, this);
        }
    },


    clearHighlight : function () {
        this.stopInspection();
    },


    highlightTarget : function (target, content, offset) {
        var targetIsPoint = target instanceof Array;

        if (!this.inspector.active) {
            this.startInspection();
        }

        if (targetIsPoint) {
            offset = target;
            target = null;
        } else {
            target = this.test.normalizeElement(target, true, true, false);


            if (target) {
                // Detect if we&#39;re trying to highlight a hidden target, then skip the target
                if (!target.offsetWidth &amp;&amp; !target.offsetHeight) {
                    target = offset = null;
                }
                else if (offset) {
                    offset = this.test.normalizeOffset(offset, $(target));
                }
            }
        }

        this.inspector.highlightTarget(target, content, offset);
    }
});</pre>
</body>
</html>
